void sub_2165A3E74(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

void Phase::SpatialModeler::ConvertMetadataSphericalToCartesian<float>(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  float *v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  __float2 v10;
  __float2 v11;

  if (*(_DWORD *)(a1 + 204) != 1)
  {
    v2 = *(uint64_t **)(a1 + 104);
    if (v2)
    {
      v3 = *v2;
      if (*v2)
      {
        v4 = (float *)(*(_QWORD *)(a1 + 8) + 8);
        do
        {
          v5 = *(v4 - 1);
          v6 = (float)((float)(180.0 - *v4) - (float)(floorf((float)(180.0 - *v4) / 360.0) * 360.0)) + 0.0;
          if (v6 >= 360.0)
            v6 = nextafterf(360.0, 0.0);
          v7 = v5 * 0.017453;
          v8 = v6 * 0.017453;
          v9 = *(v4 - 2);
          v10 = __sincosf_stret(v7);
          v11 = __sincosf_stret(v8);
          *(v4 - 2) = (float)(v10.__sinval * v9) * v11.__sinval;
          *(v4 - 1) = v10.__cosval * v9;
          *v4 = (float)(v10.__sinval * v9) * v11.__cosval;
          v4 += 3;
          --v3;
        }
        while (v3);
        *(_DWORD *)(a1 + 204) = 1;
      }
    }
  }
}

void Phase::SpatialModeler::ConvertMetadataCartesianToSpherical<float>(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t v4;
  float v5;
  uint64_t v6;
  int v7;
  float v8;
  float v9;

  if (*(_DWORD *)(a1 + 204))
  {
    v2 = *(_QWORD **)(a1 + 104);
    if (v2)
    {
      if (*v2)
      {
        v3 = 0;
        v4 = 0;
LABEL_5:
        v2 = (_QWORD *)*v2;
        while (v4 < (unint64_t)v2)
        {
          Phase::CartesianToSphericalXZ<float>((float *)(*(_QWORD *)(a1 + 8) + v3), (float *)&v7);
          v8 = v8 * 57.296;
          v5 = (float)((float)(180.0 - (float)(v9 * 57.296))
                     - (float)(floorf((float)(180.0 - (float)(v9 * 57.296)) / 360.0) * 360.0))
             + 0.0;
          if (v5 >= 360.0)
            v5 = nextafterf(360.0, 0.0);
          v9 = v5;
          v6 = *(_QWORD *)(a1 + 8) + v3;
          *(_DWORD *)v6 = v7;
          *(float *)(v6 + 4) = v8;
          *(float *)(v6 + 8) = v9;
          ++v4;
          v2 = *(_QWORD **)(a1 + 104);
          v3 += 12;
          if (v2)
            goto LABEL_5;
        }
        *(_DWORD *)(a1 + 204) = 0;
      }
    }
  }
}

void Phase::SpatialModeler::EarlyReflectionsSimulation::GetSupportedQueryDescs(std::string **a1@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::string *v9;
  uint64_t v10;
  char *v11;
  void *v12;
  __int128 v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  _BYTE v18[32];
  char v19[24];
  uint64_t v20;
  uint64_t v21;
  int v22;
  _BYTE v23[32];
  char v24[24];
  uint64_t v25;
  uint64_t v26;
  int v27;
  _BYTE v28[32];
  __int128 v29;

  *(_QWORD *)&v29 = *MEMORY[0x24BDAC8D0];
  v14 = 4;
  strcpy((char *)&v13, "CULL");
  v15 = 0;
  v16 = 0x100000001;
  v17 = 1;
  memset(v18, 0, sizeof(v18));
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)v18, 7uLL);
  v3 = 0;
  v4 = *(_QWORD *)v18;
  do
  {
    *(_DWORD *)(v4 + v3 * 4) = Phase::SpatialModeler::EarlyReflectionsSimulationPrivate::sCullQueryPropertyUIDs[v3];
    ++v3;
  }
  while (v3 != 7);
  v19[23] = 7;
  strcpy(v19, "CLUSTER");
  v20 = 1;
  v21 = 0x200000003;
  v22 = 1;
  memset(v23, 0, sizeof(v23));
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)v23, 7uLL);
  v5 = 0;
  v6 = *(_QWORD *)v23;
  do
  {
    *(_DWORD *)(v6 + v5 * 4) = Phase::SpatialModeler::EarlyReflectionsSimulationPrivate::sClusterQueryPropertyUIDs[v5];
    ++v5;
  }
  while (v5 != 7);
  v24[23] = 7;
  strcpy(v24, "SPATIAL");
  v25 = 2;
  v26 = 0x300000002;
  v27 = 2;
  memset(v28, 0, sizeof(v28));
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)v28, 7uLL);
  v7 = 0;
  v8 = *(_QWORD *)v28;
  do
  {
    *(_DWORD *)(v8 + v7 * 4) = Phase::SpatialModeler::EarlyReflectionsSimulationPrivate::sSpatialQueryPropertyUIDs[v7];
    ++v7;
  }
  while (v7 != 7);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v9 = (std::string *)operator new(0xF0uLL);
  *a1 = v9;
  a1[1] = v9;
  a1[2] = v9 + 10;
  v10 = 0;
  a1[1] = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Phase::SpatialModeler::QueryDesc>,Phase::SpatialModeler::QueryDesc const*,Phase::SpatialModeler::QueryDesc const*,Phase::SpatialModeler::QueryDesc*>((uint64_t)(a1 + 2), &v13, &v29, v9);
  do
  {
    v11 = (char *)&v13 + v10;
    v12 = *(void **)&v28[v10];
    if (v12)
    {
      *((_QWORD *)v11 + 27) = v12;
      operator delete(v12);
    }
    if (v11[183] < 0)
      operator delete(*((void **)v11 + 20));
    v10 -= 80;
  }
  while (v10 != -240);
}

void sub_2165A42C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t i;

  *(_QWORD *)(v12 + 8) = v13;
  std::vector<Phase::SpatialModeler::QueryDesc>::__destroy_vector::operator()[abi:ne180100](&a10);
  for (i = 160; i != -80; i -= 80)
    Phase::SpatialModeler::QueryDesc::~QueryDesc((Phase::SpatialModeler::QueryDesc *)(&a12 + i));
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulation::GetEntityShapeTemplates@<X0>(Phase::SpatialModeler::EarlyReflectionsSimulation *this@<X0>, uint64_t *a2@<X8>)
{
  int v3;
  int *v4;
  uint64_t v5;
  int v7;
  _OWORD v8[2];
  int v9;
  int v10;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v7 = 0;
  memset(v8, 0, sizeof(v8));
  v9 = 1065353216;
  v10 = 4;
  v3 = *(_DWORD *)(Phase::Logger::GetInstancePtr(this) + 1200);
  if (!v3)
    v3 = 3;
  v7 = v3;
  if ((v3 - 4) < 0xFFFFFFFD)
    __assert_rtn("GetEntityShapeTemplates", "EarlyReflectionsSimulationModeler.cpp", 238, "occluderTemplate.mShapeType > Geometry::DefaultShapeType::Invalid && occluderTemplate.mShapeType < Geometry::DefaultShapeType::Count");
  v4 = (int *)a2[1];
  if ((unint64_t)v4 >= a2[2])
  {
    v5 = std::vector<Phase::SpatialModeler::EntityShapeTemplate>::__push_back_slow_path<Phase::SpatialModeler::EntityShapeTemplate const&>(a2, &v7);
  }
  else
  {
    *v4 = v3;
    std::unordered_map<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,std::allocator<std::pair<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey const,Phase::OptionsValue>>>::unordered_map((uint64_t)(v4 + 2), (uint64_t)v8);
    v4[12] = v10;
    v5 = (uint64_t)(v4 + 14);
    a2[1] = (uint64_t)(v4 + 14);
  }
  a2[1] = v5;
  return std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table((uint64_t)v8);
}

void sub_2165A4420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v13 = v12;
  *(_QWORD *)(v10 + 8) = v13;
  std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table(v11);
  a10 = (void **)v10;
  std::vector<Phase::SpatialModeler::EntityShapeTemplate>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::EarlyReflectionsSimulation::Init(uint64_t a1, _QWORD *a2)
{
  __int128 *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  _DWORD *v12;
  Phase::SpatialModeler::RoomSimulation *v13;
  uint64_t v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  float64x2_t *v21;
  Phase::Logger *v22;
  NSObject *v23;
  _BOOL8 v24;
  int *InstancePtr;
  uint64_t v26;
  const char *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  Phase::SpatialModeler::DefaultRayDistribution *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *p_shared_owners;
  unint64_t v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  _BYTE buf[18];
  __int16 v39;
  const char *v40;
  __int16 v41;
  int v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(a1 + 40) = a2[3];
  *(_DWORD *)(a1 + 32) = 2;
  *(_DWORD *)(a1 + 60) = Phase::Geometry::SceneQueryTypeRegistry::DeriveNewType((Phase::Geometry::SceneQueryTypeRegistry *)(*(_QWORD *)(a1 + 16) + 2288), 3u);
  *(_DWORD *)(a1 + 64) = Phase::Geometry::SceneQueryTypeRegistry::DeriveNewType((Phase::Geometry::SceneQueryTypeRegistry *)(*(_QWORD *)(a1 + 16) + 2288), 3u);
  Phase::Geometry::System::GetCurrentState(*(Phase::Geometry::System **)(a1 + 16), &v36);
  v4 = (__int128 *)a2[1];
  if (v4)
  {
    v5 = *v4;
    *(_OWORD *)(a1 + 1072) = v4[1];
    *(_OWORD *)(a1 + 1056) = v5;
    v6 = v4[2];
    v7 = v4[3];
    v8 = v4[4];
    *(_OWORD *)(a1 + 1136) = v4[5];
    *(_OWORD *)(a1 + 1120) = v8;
    *(_OWORD *)(a1 + 1104) = v7;
    *(_OWORD *)(a1 + 1088) = v6;
    v9 = v4[6];
    v10 = v4[7];
    v11 = v4[8];
    *(_DWORD *)(a1 + 1200) = *((_DWORD *)v4 + 36);
    *(_OWORD *)(a1 + 1184) = v11;
    *(_OWORD *)(a1 + 1168) = v10;
    *(_OWORD *)(a1 + 1152) = v9;
  }
  Phase::SpatialModeler::RoomSimulationConfig::ReadDefaultsWriteFlags((Phase::SpatialModeler::RoomSimulationConfig *)(a1 + 1056));
  *(_QWORD *)(a1 + 1280) = *a2;
  v12 = (_DWORD *)operator new();
  bzero(v12, 0x125E0uLL);
  *v12 = -1;
  v14 = 3;
  v15 = v12;
  do
  {
    v15[16] = 0;
    v15 += 25072;
    *v15 = 0;
    --v14;
  }
  while (v14);
  *(_QWORD *)buf = 0;
  v16 = *(_QWORD *)(a1 + 1312);
  *(_QWORD *)(a1 + 1312) = v12;
  if (v16)
  {
    std::default_delete<caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>>::operator()[abi:ne180100](a1 + 1312, v16);
    v17 = *(_QWORD *)buf;
    *(_QWORD *)buf = 0;
    if (v17)
      std::default_delete<caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>>::operator()[abi:ne180100]((uint64_t)buf, v17);
  }
  Phase::SpatialModeler::RoomSimulation::InitERtoLRModelerCache(v13);
  Phase::Geometry::DirectivityFactory::Create(*(_QWORD *)(a1 + 16) + 208, 3u, buf);
  std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100](a1 + 51936, (__int128 *)buf);
  v18 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v19 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = **(float64x2_t ***)(*(_QWORD *)(a1 + 51936) + 40);
  v21[1] = vcvtq_f64_f32(*(float32x2_t *)(a1 + 1192));
  Phase::Geometry::SphericalCapDirectivity::InitializeSubbandGainsDatabase((Phase::Geometry::SphericalCapDirectivity *)v21);
  v23 = **(NSObject ***)(Phase::Logger::GetInstancePtr(v22) + 1184);
  v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
  if (v24)
  {
    InstancePtr = (int *)Phase::Logger::GetInstancePtr((Phase::Logger *)v24);
    v26 = InstancePtr[307];
    if (v26 > 3)
      v27 = "Invalid";
    else
      v27 = off_24D57C9B0[v26];
    v28 = *(_DWORD *)(Phase::Logger::GetInstancePtr((Phase::Logger *)InstancePtr) + 1228);
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "EarlyReflectionsSimulationModeler.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 314;
    v39 = 2080;
    v40 = v27;
    v41 = 1024;
    v42 = v28;
    _os_log_impl(&dword_2164CC000, v23, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Selected Space Blend Algorithm: %s (index %d)", buf, 0x22u);
  }
  if (*(_BYTE *)(a1 + 1202))
  {
    v29 = operator new();
    *(_QWORD *)v29 = &off_24D580DD0;
    *(_OWORD *)(v29 + 8) = xmmword_2166F8040;
  }
  else
  {
    v29 = operator new();
    *(_QWORD *)v29 = &off_24D580DF8;
  }
  v30 = *(_QWORD *)(a1 + 51952);
  *(_QWORD *)(a1 + 51952) = v29;
  if (v30)
    (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
  v31 = (Phase::SpatialModeler::DefaultRayDistribution *)operator new();
  Phase::SpatialModeler::DefaultRayDistribution::DefaultRayDistribution(v31);
  v32 = *(_QWORD *)(a1 + 51960);
  *(_QWORD *)(a1 + 51960) = v31;
  if (v32)
    (*(void (**)(uint64_t))(*(_QWORD *)v32 + 8))(v32);
  v33 = v37;
  if (v37)
  {
    p_shared_owners = (unint64_t *)&v37->__shared_owners_;
    do
      v35 = __ldaxr(p_shared_owners);
    while (__stlxr(v35 - 1, p_shared_owners));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
}

void sub_2165A47E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulation::Shutdown(Phase::SpatialModeler::EarlyReflectionsSimulation *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 164);
  *((_QWORD *)this + 164) = 0;
  if (v1)
    std::default_delete<caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>>::operator()[abi:ne180100]((uint64_t)this + 1312, v1);
  return Phase::SpatialModeler::RoomSimulation::DeinitERtoLRModelerCache(this);
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulation::RunQuery@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3;
  _DWORD *v4;
  char *v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v3 = a2[10];
  if (v3 > 2)
  {
    *(_QWORD *)a3 = 2;
    *(_QWORD *)(a3 + 8) = result + 72;
    *(_DWORD *)(a3 + 24) = 2;
  }
  else
  {
    v4 = (_DWORD *)a2[11];
    if (v4
      && (v5 = Phase::SpatialModeler::EarlyReflectionsSimulationPrivate::QueryTable[v3], *((_DWORD *)v5 + 4) == *v4))
    {
      v6 = (_DWORD *)a2[12];
      if (v6 && *((_DWORD *)v5 + 5) == *v6)
        return (*((uint64_t (**)(void))v5 + 8))();
      v7 = result + 72;
      v8 = 4;
    }
    else
    {
      v7 = result + 72;
      v8 = 3;
    }
    *(_QWORD *)a3 = v8;
    *(_QWORD *)(a3 + 8) = v7;
    *(_DWORD *)(a3 + 24) = 2;
  }
  return result;
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulation::AllocateQueryState@<X0>(uint64_t this@<X0>, Phase::SpatialModeler::Query *a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t v3;
  uint64_t (*v4)(uint64_t);

  v3 = *((_QWORD *)a2 + 10);
  if (v3 <= 2)
  {
    v4 = (uint64_t (*)(uint64_t))*((_QWORD *)Phase::SpatialModeler::EarlyReflectionsSimulationPrivate::QueryTable[v3]
                                          + 7);
    if (v4)
      return v4(this);
  }
  *a3 = 0;
  a3[4] = 0;
  return this;
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulation::GetGraphDescription@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t result;

  switch(a1)
  {
    case 2:
      *(_OWORD *)(a2 + 16) = 0uLL;
      *(_OWORD *)(a2 + 32) = 0uLL;
      *(_OWORD *)a2 = 0uLL;
      MEMORY[0x2199F99B0](a2, "EarlyReflectionsSimSpatialQueryGraph");
      std::vector<Phase::SpatialModeler::GraphDescriptionNode>::resize((uint64_t *)(a2 + 24), 1uLL);
      v4 = *(_QWORD *)(a2 + 24);
      result = MEMORY[0x2199F99B0](v4, "FullEarlyReflectionsSimSpatialGraph");
      goto LABEL_7;
    case 1:
      *(_OWORD *)(a2 + 16) = 0uLL;
      *(_OWORD *)(a2 + 32) = 0uLL;
      *(_OWORD *)a2 = 0uLL;
      MEMORY[0x2199F99B0](a2, "EarlyReflectionsSimClusterQueryGraph");
      std::vector<Phase::SpatialModeler::GraphDescriptionNode>::resize((uint64_t *)(a2 + 24), 1uLL);
      v4 = *(_QWORD *)(a2 + 24);
      result = MEMORY[0x2199F99B0](v4, "FullEarlyReflectionsSimClusterGraph");
      goto LABEL_7;
    case 0:
      *(_OWORD *)(a2 + 16) = 0uLL;
      *(_OWORD *)(a2 + 32) = 0uLL;
      *(_OWORD *)a2 = 0uLL;
      MEMORY[0x2199F99B0](a2, "EarlyReflectionsSimCullQueryGraph");
      std::vector<Phase::SpatialModeler::GraphDescriptionNode>::resize((uint64_t *)(a2 + 24), 1uLL);
      v4 = *(_QWORD *)(a2 + 24);
      result = MEMORY[0x2199F99B0](v4, "FullEarlyReflectionsSimCullGraph");
LABEL_7:
      *(_QWORD *)(v4 + 24) = 0xFFFFFFFFLL;
      return result;
  }
  *(_OWORD *)(a2 + 16) = 0uLL;
  *(_OWORD *)(a2 + 32) = 0uLL;
  *(_OWORD *)a2 = 0uLL;
  return result;
}

void sub_2165A4A24(_Unwind_Exception *a1)
{
  void **v1;

  Phase::SpatialModeler::GraphDescription::~GraphDescription(v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulation::GetErrorCategory(Phase::SpatialModeler::EarlyReflectionsSimulation *this)
{
  return (uint64_t)this + 72;
}

BOOL Phase::SpatialModeler::EarlyReflectionsSimulation::IsQueryIndexValid(Phase::SpatialModeler::EarlyReflectionsSimulation *this, unint64_t a2)
{
  return a2 < 3;
}

void Phase::SpatialModeler::EarlyReflectionsSimulation::StoreRayTracerStateToCache(Phase::SpatialModeler::EarlyReflectionsSimulation *this, const Phase::SpatialModeler::RayTracerState *a2)
{
  uint64_t v2;
  unsigned int *v3;
  const Phase::SpatialModeler::RayTracerState *v4;
  void *v5[3134];

  v2 = MEMORY[0x24BDAC7A8](this);
  v5[3133] = *(void **)MEMORY[0x24BDAC8D0];
  v3 = *(unsigned int **)(v2 + 1312);
  Phase::SpatialModeler::RayTracerState::RayTracerState((Phase::SpatialModeler::RayTracerState *)v5, v4);
  caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>::write(v3, (const Phase::SpatialModeler::RayTracerState *)v5);
  Phase::SpatialModeler::RayTracerState::~RayTracerState(v5);
}

void sub_2165A4AE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  Phase::SpatialModeler::RayTracerState::~RayTracerState(&a9);
  _Unwind_Resume(a1);
}

uint64_t caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>::write(unsigned int *a1, const Phase::SpatialModeler::RayTracerState *a2)
{
  unsigned int v4;
  unsigned int i;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v11;

  v11 = 0;
  if (a1[1] == 3)
    v4 = 0;
  else
    v4 = a1[1];
  for (i = atomic_load(a1); v4 == (unsigned __int16)i || v4 == HIWORD(i); i = atomic_load(a1))
  {
    caulk::concurrent::details::spinloop::spin((uint64_t)&v11);
    if (v4 == 2)
      v4 = 0;
    else
      ++v4;
  }
  std::optional<Phase::SpatialModeler::RayTracerState>::operator=[abi:ne180100]<Phase::SpatialModeler::RayTracerState&,void>((Phase::SpatialModeler::RayTracerState *)&a1[6268 * v4 + 4], a2);
  do
  {
    v7 = __ldaxr(a1);
    if (v7 != i)
    {
      __clrex();
      while (1)
      {
        v8 = __ldaxr(a1);
        if (v8 != v7)
          break;
        if (!__stlxr((unsigned __int16)v7 | (v4 << 16), a1))
        {
          v9 = 1;
LABEL_22:
          v7 = v8;
          if (v9)
            goto LABEL_23;
        }
      }
      v9 = 0;
      __clrex();
      goto LABEL_22;
    }
  }
  while (__stlxr((unsigned __int16)i | ((unsigned __int16)v4 << 16), a1));
LABEL_23:
  a1[1] = v4 + 1;
  return (uint64_t)&a1[6268 * v4 + 4];
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulation::LoadRayTracerStateFromCache(unsigned int **this)
{
  return caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>::read_if (this[164]);
}

uint64_t caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>::read_if (unsigned int *a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  uint64_t result;
  unsigned int *v5;

  v1 = atomic_load(a1);
  v2 = HIWORD(v1);
  if (HIWORD(v1) == 0xFFFF)
  {
    LOWORD(v3) = v1;
  }
  else
  {
    do
    {
      while (1)
      {
        v3 = __ldaxr(a1);
        if (v3 != v1)
          break;
        if (!__stlxr(v2 | 0xFFFF0000, a1))
          goto LABEL_9;
      }
      __clrex();
      v2 = HIWORD(v3);
      v1 = v3;
    }
    while (HIWORD(v3) != 0xFFFF);
  }
  v2 = (unsigned __int16)v3;
  if ((unsigned __int16)v3 == 0xFFFF)
    return 0;
LABEL_9:
  v5 = &a1[6268 * v2];
  if (*((_BYTE *)v5 + 25072))
    return (uint64_t)(v5 + 4);
  _os_assert_log();
  result = _os_crash();
  __break(1u);
  return result;
}

void Phase::SpatialModeler::EarlyReflectionsSimulation::~EarlyReflectionsSimulation(Phase::SpatialModeler::EarlyReflectionsSimulation *this)
{
  Phase::SpatialModeler::RoomSimulation::~RoomSimulation(this);
  JUMPOUT(0x2199F9D70);
}

void Phase::SpatialModeler::RoomSimulation::~RoomSimulation(Phase::SpatialModeler::RoomSimulation *this)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;

  v2 = (char *)this + 51784;
  *(_QWORD *)this = &off_24D57C940;
  v3 = *((_QWORD *)this + 6495);
  *((_QWORD *)v2 + 22) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)v2 + 21);
  *((_QWORD *)v2 + 21) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)this + 51936);
  v5 = (void *)*((_QWORD *)v2 + 15);
  if (v5)
  {
    *((_QWORD *)v2 + 16) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)v2 + 6);
  if (v6)
  {
    *((_QWORD *)v2 + 7) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)v2 + 3);
  if (v7)
  {
    *((_QWORD *)v2 + 4) = v7;
    operator delete(v7);
  }
  v8 = *(void **)v2;
  if (*(_QWORD *)v2)
  {
    *((_QWORD *)v2 + 1) = v8;
    operator delete(v8);
  }
  Phase::SpatialModeler::RayTracerState::~RayTracerState((void **)this + 3340);
  std::mutex::~mutex((std::mutex *)((char *)this + 26640));
  v9 = (void *)*((_QWORD *)this + 3326);
  if (v9)
  {
    *((_QWORD *)this + 3327) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 3317);
  if (v10)
  {
    *((_QWORD *)this + 3318) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 3314);
  if (v11)
  {
    *((_QWORD *)this + 3315) = v11;
    operator delete(v11);
  }
  v12 = (void *)*((_QWORD *)this + 3311);
  if (v12)
  {
    *((_QWORD *)this + 3312) = v12;
    operator delete(v12);
  }
  Phase::SpatialModeler::RayTracerState::~RayTracerState((void **)this + 178);
  std::mutex::~mutex((std::mutex *)this + 21);
  Phase::SpatialModeler::HistogramPtrStack::Clear((Phase::SpatialModeler::RoomSimulation *)((char *)this + 1328));
  v13 = *((_QWORD *)this + 164);
  *((_QWORD *)this + 164) = 0;
  if (v13)
    std::default_delete<caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>>::operator()[abi:ne180100]((uint64_t)this + 1312, v13);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)this + 120);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)this + 80);
  std::error_category::~error_category((std::error_category *)this + 9);
  *(_QWORD *)this = &off_24D577480;
  std::error_category::~error_category((std::error_category *)this + 1);
}

void Phase::SpatialModeler::HistogramPtrStack::Clear(Phase::SpatialModeler::HistogramPtrStack *this)
{
  unsigned int v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  do
    v2 = __ldaxr((unsigned int *)&Phase::SpatialModeler::HistogramPtrStack::sIsClearingPoolFlag);
  while (__stlxr(v2 + 1, (unsigned int *)&Phase::SpatialModeler::HistogramPtrStack::sIsClearingPoolFlag));
  do
  {
    while (1)
    {
      Phase::SpatialModeler::HistogramPtrStack::Pop(this, &v8);
      v4 = v8;
      v3 = v9;
      if (!v9)
        break;
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v6 = __ldaxr(p_shared_owners);
      while (__stlxr(v6 - 1, p_shared_owners));
      if (v6)
        break;
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
      if (!v4)
        goto LABEL_9;
    }
  }
  while (v4);
  do
LABEL_9:
    v7 = __ldaxr((unsigned int *)&Phase::SpatialModeler::HistogramPtrStack::sIsClearingPoolFlag);
  while (__stlxr(v7 - 1, (unsigned int *)&Phase::SpatialModeler::HistogramPtrStack::sIsClearingPoolFlag));
}

unint64_t *Phase::SpatialModeler::HistogramPtrStack::Pop@<X0>(Phase::SpatialModeler::HistogramPtrStack *this@<X0>, _QWORD *a2@<X8>)
{
  unint64_t *result;
  uint64_t v4;

  *a2 = 0;
  a2[1] = 0;
  result = caulk::concurrent::stack<caulk::alloc::free_block,caulk::concurrent::intrusive_single_link_node<caulk::alloc::free_block>>::pop((unsigned __int128 *)this);
  if (result)
  {
    v4 = (uint64_t)(result + 1);
    std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100](a2, (uint64_t *)result + 1);
    return (unint64_t *)std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v4);
  }
  return result;
}

void sub_2165A4F48(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void std::default_delete<caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t i;

  if (a2)
  {
    v3 = 75216;
    for (i = 50160; ; i -= 25072)
    {
      if (*(_BYTE *)(a2 + v3))
        Phase::SpatialModeler::RayTracerState::~RayTracerState((void **)(a2 + i));
      v3 -= 25072;
      if (!v3)
        JUMPOUT(0x2199F9D70);
    }
  }
}

Phase::SpatialModeler::RayTracerState *std::optional<Phase::SpatialModeler::RayTracerState>::operator=[abi:ne180100]<Phase::SpatialModeler::RayTracerState&,void>(Phase::SpatialModeler::RayTracerState *this, const Phase::SpatialModeler::RayTracerState *a2)
{
  _BYTE *v3;

  v3 = (char *)this + 25056;
  if (*((_BYTE *)this + 25056))
  {
    Phase::SpatialModeler::RayTracerState::operator=((uint64_t)this, (uint64_t)a2);
  }
  else
  {
    Phase::SpatialModeler::RayTracerState::RayTracerState(this, a2);
    *v3 = 1;
  }
  return this;
}

void Phase::SpatialModeler::GenerateEarlyScattering(Phase::Logger *a1, uint64_t *a2, Phase::SpatialModeler::RayTracerState *this, double a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  Phase::Logger *v9;
  unint64_t v10;
  float v11;
  _QWORD *v12;
  int v13;
  float v14;
  unint64_t *v15;
  __n128 v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  char v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *p_shared_owners;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  float v42;
  float v43;
  int v44;
  float v45;
  float v46;
  float v47;
  float v48;
  uint64_t InstancePtr;
  int v50;
  float v51;
  float v52;
  float v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t *v58;
  uint64_t *v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  _DWORD *v80;
  _DWORD *v81;
  int *v82;
  _DWORD *v83;
  uint64_t i;
  int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  _DWORD *v94;
  _DWORD *v95;
  int *v96;
  _DWORD *v97;
  uint64_t j;
  int v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  float v108;
  float v109;
  unsigned int v110;
  unsigned int v111;
  uint64_t v112;
  uint64_t v113;
  float v114;
  uint64_t v115;
  float v116;
  float v118;
  uint64_t v119;
  float v120;
  float *v121;
  unint64_t *v122;
  unint64_t v123;
  float v124;
  float *v125;
  __n128 v129;
  _QWORD v130[2];
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  std::__shared_weak_count *v134;
  uint64_t v135;
  std::__shared_weak_count *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139[6];
  uint64_t v140[5];
  uint64_t v141[7];
  __int16 v142;
  int v143;
  uint64_t *v144;
  _QWORD *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148[4];
  uint64_t *v149;
  uint64_t *v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  _OWORD v155[2];
  uint64_t v156;
  uint64_t v157;

  v157 = *MEMORY[0x24BDAC8D0];
  if (!*((_QWORD *)a1 + 3))
    return;
  v9 = a1;
  v10 = 0;
  v125 = (float *)((char *)this + 19512);
  v11 = a4;
  v124 = v11;
  do
  {
    v129 = 0uLL;
    v12 = (_QWORD *)*((_QWORD *)v9 + 2);
    if (!v12)
      goto LABEL_104;
    v13 = 0;
    v14 = 3.4028e38;
    do
    {
      if (v12[3] != v10)
        goto LABEL_54;
      v15 = (unint64_t *)(*((_QWORD *)v9 + 2) + 16);
      v16.n128_f32[0] = Phase::SpatialModeler::RayTracerState::GetSourceListenerResult(this, v15, (uint64_t)&v133);
      if (v135)
      {
        if (!v129.n128_u64[0])
        {
          Phase::SpatialModeler::RayTracerState::CopyDirectivityHistogram(this, &v135, (Phase::SpatialModeler::EnergyHistogram **)v155);
          v16 = (__n128)v155[0];
          v155[0] = 0uLL;
          v30 = (std::__shared_weak_count *)v129.n128_u64[1];
          v129 = v16;
          if (v30)
          {
            p_shared_owners = (unint64_t *)&v30->__shared_owners_;
            do
              v32 = __ldaxr(p_shared_owners);
            while (__stlxr(v32 - 1, p_shared_owners));
            if (!v32)
            {
              ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
              std::__shared_weak_count::__release_weak(v30);
            }
          }
          v33 = (std::__shared_weak_count *)*((_QWORD *)&v155[0] + 1);
          if (*((_QWORD *)&v155[0] + 1))
          {
            v34 = (unint64_t *)(*((_QWORD *)&v155[0] + 1) + 8);
            do
              v35 = __ldaxr(v34);
            while (__stlxr(v35 - 1, v34));
            if (!v35)
            {
              ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
              std::__shared_weak_count::__release_weak(v33);
            }
          }
          ++v13;
          goto LABEL_44;
        }
        a1 = (Phase::Logger *)Phase::SpatialModeler::DirectivityHistogram::operator+=(v129.n128_i64[0], v135);
        if (v129.n128_u64[1])
        {
          v17 = (unint64_t *)(v129.n128_u64[1] + 8);
          do
            v18 = __ldxr(v17);
          while (__stxr(v18 + 1, v17));
        }
        v19 = *((_QWORD *)this + 2367);
        v20 = *((_QWORD *)this + 2366);
        v21 = v19 - v20;
        if (v19 == v20)
        {
LABEL_24:
          v27 = 0;
          if (v129.n128_u64[1])
            goto LABEL_25;
        }
        else
        {
          v22 = 0;
          v23 = *(_QWORD *)(a6 + 144);
          v24 = v21 / 56;
          if (v24 <= 1)
            v24 = 1;
          while (1)
          {
            if (*v15 == *(_QWORD *)(v20 + 56 * v22) && v23)
            {
              v25 = 0;
              v26 = (_BYTE *)(*(_QWORD *)(a6 + 104) + 152);
              while (*((_QWORD *)v26 - 1) != *(_QWORD *)(v20 + 56 * v22 + 48))
              {
                ++v25;
                v26 += 304;
                if (v23 == v25)
                  goto LABEL_23;
              }
              if ((v25 & 0x8000000000000000) == 0 && !*v26)
              {
                v16.n128_u32[0] = *(_DWORD *)(v129.n128_u64[0] + 40);
                if (v16.n128_f32[0] < 0.000029155)
                  break;
              }
            }
LABEL_23:
            if (++v22 == v24)
              goto LABEL_24;
          }
          v27 = 1;
          if (!v129.n128_u64[1])
            goto LABEL_29;
LABEL_25:
          v28 = (unint64_t *)(v129.n128_u64[1] + 8);
          do
            v29 = __ldaxr(v28);
          while (__stlxr(v29 - 1, v28));
          if (!v29)
          {
            (*(void (**)(unint64_t))(*(_QWORD *)v129.n128_u64[1] + 16))(v129.n128_u64[1]);
            std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v129.n128_u64[1]);
          }
        }
LABEL_29:
        ++v13;
        if ((v27 & 1) == 0)
        {
          v16.n128_u32[0] = *(_DWORD *)(v135 + 40);
          if (v16.n128_f32[0] < v14)
            v14 = *(float *)(v135 + 40);
        }
      }
LABEL_44:
      v36 = v136;
      if (v136)
      {
        v37 = (unint64_t *)&v136->__shared_owners_;
        do
          v38 = __ldaxr(v37);
        while (__stlxr(v38 - 1, v37));
        if (!v38)
        {
          ((void (*)(std::__shared_weak_count *, __n128))v36->__on_zero_shared)(v36, v16);
          std::__shared_weak_count::__release_weak(v36);
        }
      }
      v39 = v134;
      if (v134)
      {
        v40 = (unint64_t *)&v134->__shared_owners_;
        do
          v41 = __ldaxr(v40);
        while (__stlxr(v41 - 1, v40));
        if (!v41)
        {
          ((void (*)(std::__shared_weak_count *, __n128))v39->__on_zero_shared)(v39, v16);
          std::__shared_weak_count::__release_weak(v39);
        }
      }
LABEL_54:
      v12 = (_QWORD *)*v12;
    }
    while (v12);
    if (v14 < 3.4028e38)
      *(float *)(v129.n128_u64[0] + 40) = v14;
    if (v13 >= 2)
      a1 = (Phase::Logger *)Phase::SpatialModeler::DirectivityHistogram::operator/=(v129.n128_i64[0], (float)v13);
    if (v129.n128_u64[0])
    {
      v42 = *(float *)(v129.n128_u64[0] + 40);
      v43 = *((float *)this + 116);
      v44 = *((unsigned __int8 *)this + 135);
      LODWORD(v133) = 3;
      BYTE4(v133) = 1;
      v134 = 0;
      v143 = 0;
      v138 = 0;
      v139[0] = 0;
      v137 = 0;
      v139[5] = 0;
      v140[0] = 0;
      v139[4] = 0;
      v140[4] = 0;
      v141[0] = 0;
      memset(&v141[4], 0, 24);
      v142 = 0;
      v45 = *v125;
      v46 = *((float *)this + 32);
      v48 = *((float *)this + 26);
      v47 = *((float *)this + 27);
      InstancePtr = Phase::Logger::GetInstancePtr(a1);
      if (v44)
        v50 = 0;
      else
        v50 = (v42 * a4);
      v51 = v42 * v43;
      if (v42 <= 0.0)
        v51 = 1.0;
      v52 = log10f((float)((float)(1.0 / (float)(v51 * v51)) * v48) + 1.0e-15) * 10.0;
      v53 = expf((float)((float)(*(float *)(InstancePtr + 1204) * 10.0) / 10.0) * 0.11513);
      Phase::SpatialModeler::generateDirectionalMetadataLR((Phase::SpatialModeler::DirectivityHistogram *)v129.n128_u64[0], v50, &v133, a7, v45, v43, v124, v52, v46, 0.0, v47, v53);
      v54 = *a2;
      if (v140[0])
      {
        v55 = *(_QWORD *)v140[0];
        if (*(_QWORD *)v140[0])
        {
          if (*(_DWORD *)(v54 + 208 * v10 + 204) != v143)
            goto LABEL_111;
          v56 = *(_QWORD *)(v140[0] + 8);
          if (!v56)
            goto LABEL_111;
          v57 = v54 + 208 * v10;
          v60 = *(uint64_t **)(v57 + 104);
          v59 = (uint64_t *)(v57 + 104);
          v58 = v60;
          if (v60)
          {
            v61 = v58[1];
            if (!v61 || v61 == v56)
            {
              v62 = *v58;
              goto LABEL_77;
            }
LABEL_111:
            std::terminate();
          }
          v62 = 0;
LABEL_77:
          v144 = (uint64_t *)(v62 + v55);
          v147 = 4;
          v149 = (uint64_t *)&v144;
          v150 = &v147;
          Phase::details::AllocArray<Phase::Vector<float,3ul>,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(Phase::Vector<float,3ul>*)#1} const&>(v62 + v55, (uint64_t)&v149, v155);
          v63 = *(_QWORD *)&v155[0];
          *(_QWORD *)&v155[0] = 0;
          v152 = v63;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v153, (uint64_t)v155 + 8);
          v154 = v62 + v55;
          std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v155);
          v147 = v62 + v55;
          v130[0] = 4;
          v144 = &v147;
          v145 = v130;
          Phase::details::AllocArray<float,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(float*)#1} const&>(v62 + v55, (uint64_t)&v144, v155);
          v64 = *(_QWORD *)&v155[0];
          *(_QWORD *)&v155[0] = 0;
          v149 = (uint64_t *)v64;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v150, (uint64_t)v155 + 8);
          v151 = v62 + v55;
          std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v155);
          if (v140[0])
            v65 = *(_QWORD *)(v140[0] + 8);
          else
            v65 = 0;
          Phase::AllocPackedSubbandArray<float>(v62 + v55, v65, (void **)&v147);
          v131 = 1;
          v132 = v62 + v55;
          v130[0] = &v132;
          v130[1] = &v131;
          Phase::details::AllocArray<BOOL,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(BOOL*)#1} const&>(v62 + v55, (uint64_t)v130, v155);
          v66 = *(_QWORD *)&v155[0];
          *(_QWORD *)&v155[0] = 0;
          v144 = (uint64_t *)v66;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v145, (uint64_t)v155 + 8);
          v146 = v62 + v55;
          std::unique_ptr<BOOL [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v155);
          v67 = v152;
          v68 = (uint64_t)v149;
          v69 = v147;
          if (v62)
          {
            v70 = 0;
            v71 = (_QWORD *)(v54 + 208 * v10);
            v72 = v71[1];
            v73 = v71[7];
            v74 = *v59 + 16;
            v75 = *(_QWORD *)(*v59 + 8);
            v76 = (char *)(v147 + 16);
            v77 = *(_QWORD *)(v147 + 8);
            v78 = v71[18];
            v79 = (uint64_t)v144;
            do
            {
              v80 = (_DWORD *)(v72 + 12 * v70);
              v81 = (_DWORD *)(v67 + 12 * v70);
              *v81 = *v80;
              v81[1] = v80[1];
              v81[2] = v80[2];
              *(_DWORD *)(v68 + 4 * v70) = *(_DWORD *)(v73 + 4 * v70);
              v82 = (int *)v74;
              v83 = v76;
              for (i = v75; i; --i)
              {
                v85 = *v82++;
                *v83++ = v85;
              }
              *(_BYTE *)(v79 + v70) = *(_BYTE *)(v78 + v70);
              ++v70;
              v76 += 4 * v77;
              v74 += 4 * v75;
            }
            while (v70 != v62);
          }
          else
          {
            v77 = *(_QWORD *)(v147 + 8);
            v79 = (uint64_t)v144;
          }
          v86 = 0;
          v87 = (uint64_t)v134;
          v88 = v139[0];
          v89 = v141[0];
          v90 = v140[0] + 16;
          v91 = *(_QWORD *)(v140[0] + 8);
          v92 = 4 * v77;
          v93 = v69 + v92 * v62 + 16;
          do
          {
            v94 = (_DWORD *)(v87 + 12 * v86);
            v95 = (_DWORD *)(v67 + 12 * (v86 + v62));
            *v95 = *v94;
            v95[1] = v94[1];
            v95[2] = v94[2];
            *(_DWORD *)(v68 + 4 * (v86 + v62)) = *(_DWORD *)(v88 + 4 * v86);
            v96 = (int *)v90;
            v97 = (_DWORD *)v93;
            for (j = v91; j; --j)
            {
              v99 = *v96++;
              *v97++ = v99;
            }
            *(_BYTE *)(v79 + v86 + v62) = *(_BYTE *)(v89 + v86);
            ++v86;
            v93 += v92;
            v90 += 4 * v91;
          }
          while (v86 != v55);
          v100 = v54 + 208 * v10;
          v101 = *(_QWORD *)(v100 + 8);
          *(_QWORD *)(v100 + 8) = 0;
          *(_QWORD *)&v155[0] = v101;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v155 + 8, v100 + 16);
          v156 = *(_QWORD *)(v100 + 48);
          std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(v100 + 8), &v152);
          *(_QWORD *)(v100 + 48) = v154;
          std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100](&v152, (uint64_t *)v155);
          v154 = v156;
          std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v155);
          v102 = *(_QWORD *)(v100 + 56);
          *(_QWORD *)(v100 + 56) = 0;
          *(_QWORD *)&v155[0] = v102;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v155 + 8, v100 + 64);
          v156 = *(_QWORD *)(v100 + 96);
          std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(v100 + 56), (uint64_t *)&v149);
          *(_QWORD *)(v100 + 96) = v151;
          std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)&v149, (uint64_t *)v155);
          v151 = v156;
          std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v155);
          v103 = *v59;
          *v59 = v147;
          v147 = v103;
          std::__function::__value_func<void ()(void *)>::swap[abi:ne180100]((_QWORD *)(v100 + 112), v148);
          v104 = *(_QWORD *)(v100 + 144);
          v100 += 144;
          *(_QWORD *)v100 = 0;
          *(_QWORD *)&v155[0] = v104;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v155 + 8, v100 + 8);
          v156 = *(_QWORD *)(v100 + 40);
          std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)v100, (uint64_t *)&v144);
          *(_QWORD *)(v100 + 40) = v146;
          std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)&v144, (uint64_t *)v155);
          v146 = v156;
          std::unique_ptr<BOOL [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v155);
          *(_BYTE *)(v100 + 57) = 0;
          std::unique_ptr<BOOL [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v144);
          std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v147);
          std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v149);
          std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v152);
          v54 = *a2;
        }
      }
      Phase::SpatialModeler::SortMetadataByDelay<float>(v54 + 208 * v10);
      v105 = *(_QWORD *)(*a2 + 208 * v10 + 48);
      if (v105)
      {
        v106 = 0;
        v107 = 0;
        v108 = *((float *)this + 19);
        v109 = *((float *)this + 27) - v108;
        v110 = ((float)(v108 + v108) * a4);
        v111 = v110 >> 1;
        v112 = *a2 + 208 * v10;
        v113 = *(_QWORD *)(v112 + 56);
        v114 = (float)v110 + -1.0;
        v115 = v112 + 104;
        do
        {
          v116 = *(float *)(v113 + 4 * v107) - v109;
          if (v116 >= 0.0 && v116 < *((float *)this + 19))
          {
            v118 = cosf((float)((float)(v111 + (v116 * a4)) * 6.2832) / v114);
            v119 = *(_QWORD *)(*(_QWORD *)v115 + 8);
            if (v119)
            {
              v120 = (float)(1.0 - v118) * 0.5;
              v121 = (float *)(*(_QWORD *)v115 + v119 * v106 + 16);
              do
              {
                *v121 = v120 * *v121;
                ++v121;
                --v119;
              }
              while (v119);
            }
          }
          ++v107;
          v106 += 4;
        }
        while (v105 > v107);
      }
      std::unique_ptr<BOOL [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](v141);
      std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](v140);
      std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](v139);
      a1 = (Phase::Logger *)std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v134);
    }
LABEL_104:
    if (v129.n128_u64[1])
    {
      v122 = (unint64_t *)(v129.n128_u64[1] + 8);
      do
        v123 = __ldaxr(v122);
      while (__stlxr(v123 - 1, v122));
      if (!v123)
      {
        (*(void (**)(unint64_t))(*(_QWORD *)v129.n128_u64[1] + 16))(v129.n128_u64[1]);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v129.n128_u64[1]);
      }
    }
    ++v10;
  }
  while (v10 < *((_QWORD *)v9 + 3));
}

void sub_2165A5AB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t a70;
  uint64_t v70;

  std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&a70);
  std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&STACK[0x210]);
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)(v70 - 256));
  Phase::SpatialModeler::DirectionalMetadataOutput<float>::~DirectionalMetadataOutput(&a38);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a31);
  _Unwind_Resume(a1);
}

uint64_t *Phase::SpatialModeler::DirectionalMetadataOutput<float>::~DirectionalMetadataOutput(uint64_t *a1)
{
  std::unique_ptr<BOOL [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](a1 + 18);
  std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](a1 + 13);
  std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](a1 + 7);
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](a1 + 1);
  return a1;
}

uint64_t Phase::SpatialModeler::EnergyHistogram::resizeEnergyHistogram(Phase::SpatialModeler::EnergyHistogram *this, float a2, int a3, float a4, float a5)
{
  unsigned int v6;

  *((float *)this + 4) = a4;
  *((float *)this + 5) = a2;
  *((float *)this + 10) = a5;
  v6 = vcvtms_u32_f32(a2 / a4) + 1;
  if (*((_DWORD *)this + 7) != a3 || v6 != *((_DWORD *)this + 6))
  {
    *((_DWORD *)this + 6) = v6;
    *((_DWORD *)this + 7) = a3;
    free(*((void **)this + 1));
    *((_QWORD *)this + 1) = malloc_type_malloc(4 * (*((_DWORD *)this + 7) * *((_DWORD *)this + 6)), 0x100004052888210uLL);
  }
  return 0;
}

void **Phase::SpatialModeler::EnergyHistogram::operator=(void **this, uint64_t a2)
{
  if ((void **)a2 != this)
  {
    Phase::SpatialModeler::EnergyHistogram::resizeEnergyHistogram((Phase::SpatialModeler::EnergyHistogram *)this, *(float *)(a2 + 20), *(_DWORD *)(a2 + 28), *(float *)(a2 + 16), *(float *)(a2 + 40));
    memcpy(this[1], *(const void **)(a2 + 8), 4 * (*((_DWORD *)this + 7) * *((_DWORD *)this + 6)));
    *((_BYTE *)this + 36) = *(_BYTE *)(a2 + 36);
    *((_DWORD *)this + 11) = *(_DWORD *)(a2 + 44);
    *((_DWORD *)this + 12) = *(_DWORD *)(a2 + 48);
    *((_DWORD *)this + 13) = *(_DWORD *)(a2 + 52);
    *((_DWORD *)this + 14) = *(_DWORD *)(a2 + 56);
    *((_DWORD *)this + 15) = *(_DWORD *)(a2 + 60);
    *((_DWORD *)this + 16) = *(_DWORD *)(a2 + 64);
    *((_DWORD *)this + 17) = *(_DWORD *)(a2 + 68);
    *((_DWORD *)this + 18) = *(_DWORD *)(a2 + 72);
    *((_DWORD *)this + 19) = *(_DWORD *)(a2 + 76);
    *((_DWORD *)this + 10) = *(_DWORD *)(a2 + 40);
    *((_DWORD *)this + 8) = *(_DWORD *)(a2 + 32);
  }
  return this;
}

void Phase::SpatialModeler::EnergyHistogram::~EnergyHistogram(void **this)
{
  *this = &off_24D57C9E0;
  free(this[1]);
}

{
  *this = &off_24D57C9E0;
  free(this[1]);
  JUMPOUT(0x2199F9D70);
}

float Phase::SpatialModeler::EnergyHistogram::addEnergy_TS(uint64_t a1, unsigned int a2, uint64_t a3)
{
  float result;
  uint64_t v4;
  float v5;
  float *v6;
  uint64_t v7;
  float v8;
  unsigned int v9;
  float *v10;
  float v11;
  int v12;
  int v13;

  result = 0.0;
  if (*(_DWORD *)(a1 + 24) > a2)
  {
    LODWORD(v4) = *(_DWORD *)(a3 + 124);
    if ((_DWORD)v4)
    {
      v5 = 0.0;
      v6 = (float *)a3;
      v7 = *(unsigned int *)(a3 + 124);
      do
      {
        v8 = *v6++;
        v5 = v5 + v8;
        --v7;
      }
      while (v7);
      result = 0.0;
      if (v5 > 1.1755e-38)
      {
        v9 = *(_DWORD *)(a1 + 28);
        if (v9 >= v4)
          v4 = v4;
        else
          v4 = v9;
        if ((int)v4 >= 1)
        {
          v10 = (float *)(*(_QWORD *)(a1 + 8) + 4 * v9 * a2);
          do
          {
            v11 = *(float *)a3;
            a3 += 4;
            *v10 = v11 + *v10;
            ++v10;
            --v4;
          }
          while (v4);
        }
        *(_BYTE *)(a1 + 36) = 0;
        v12 = *(_DWORD *)(a1 + 44);
        if ((v12 + 1) < 0xC350)
          v13 = v12 + 1;
        else
          v13 = 50000;
        *(_DWORD *)(a1 + 44) = v13;
        return v5;
      }
    }
  }
  return result;
}

float Phase::SpatialModeler::EnergyHistogram::getTemporalEnergyEnvelope_Band@<S0>(Phase::SpatialModeler::EnergyHistogram *this@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X8>)
{
  unint64_t v5;
  _QWORD *v6;
  float result;
  uint64_t v8;
  uint64_t v9;
  float *v10;
  _DWORD *v11;
  uint64_t v12;
  int v13;

  v5 = *((unsigned int *)this + 6);
  v13 = 0;
  v6 = std::vector<float>::vector(a3, v5, &v13);
  if (!*((_BYTE *)this + 36))
  {
    v8 = *((unsigned int *)this + 7);
    if (v8 > a2)
    {
      v9 = *((unsigned int *)this + 6);
      if ((_DWORD)v9)
      {
        v10 = (float *)(*((_QWORD *)this + 1) + 4 * a2);
        v11 = (_DWORD *)*v6;
        v12 = 4 * v8;
        do
        {
          result = *v10;
          *v11++ = *(_DWORD *)v10;
          v10 = (float *)((char *)v10 + v12);
          --v9;
        }
        while (v9);
      }
    }
  }
  return result;
}

uint64_t Phase::SpatialModeler::EnergyHistogram::setEnergy(uint64_t this, float a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4;
  NSObject *v6;
  std::logic_error *exception;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  unsigned int v14;
  __int16 v15;
  unsigned int v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v4 = *(_DWORD *)(this + 28);
  if (v4 <= a3 || *(_DWORD *)(this + 24) <= a4)
  {
    v6 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)this) + 1184);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v10 = "EnergyHistogram.cpp";
      v11 = 1024;
      v12 = 246;
      v13 = 1024;
      v14 = a3;
      v15 = 1024;
      v16 = a4;
      _os_log_impl(&dword_2164CC000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"Invalid band (%i) of timestep (%i) selected.\\n\"", buf, 0x1Eu);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Invalid band (%i) of timestep (%i) selected.\n");
  }
  if (a2 > 1.1755e-38)
  {
    *(float *)(*(_QWORD *)(this + 8) + 4 * (a3 + v4 * a4)) = a2;
    *(_BYTE *)(this + 36) = 0;
  }
  return this;
}

void sub_2165A5F68(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

float Phase::SpatialModeler::EnergyHistogram::getTotalEnergyDivBands(Phase::SpatialModeler::EnergyHistogram *this, double a2, double a3, double a4, double a5, double a6, double a7, double a8, uint64x2_t a9)
{
  int32x2_t v9;
  unsigned int v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  uint64x2_t v14;
  int64x2_t v15;
  int64x2_t v16;
  float32x4_t v17;
  __int32 *v18;
  int64x2_t v19;
  float32x4_t v20;
  int32x4_t v21;
  int32x2_t v22;
  int8x16_t v23;

  if (*((_BYTE *)this + 36))
  {
    v10 = *((_DWORD *)this + 7);
LABEL_3:
    v11 = 0.0;
    return v11 / (float)v10;
  }
  v10 = *((_DWORD *)this + 7);
  v12 = v10 * *((_DWORD *)this + 6);
  if (!(_DWORD)v12)
    goto LABEL_3;
  v13 = (v12 + 3) & 0x1FFFFFFFCLL;
  v14 = (uint64x2_t)vdupq_n_s64(v12 - 1);
  v15 = (int64x2_t)xmmword_2166F7AD0;
  v16 = (int64x2_t)xmmword_2166F7AE0;
  v17 = (float32x4_t)xmmword_2166F7AF0;
  v18 = (__int32 *)(*((_QWORD *)this + 1) + 8);
  v19 = vdupq_n_s64(4uLL);
  do
  {
    v20 = v17;
    v21 = (int32x4_t)vcgeq_u64(v14, (uint64x2_t)v16);
    *(int32x2_t *)a9.i8 = vmovn_s64((int64x2_t)v21);
    *(int16x4_t *)v17.f32 = vmovn_s32((int32x4_t)a9);
    if ((v17.i8[0] & 1) != 0)
      v17.i32[0] = *(v18 - 2);
    if ((vmovn_s32(*(int32x4_t *)&a9).i8[2] & 1) != 0)
      v17.i32[1] = *(v18 - 1);
    a9 = vcgeq_u64(v14, (uint64x2_t)v15);
    v22 = (int32x2_t)vmovn_s32(vmovn_hight_s64(v9, (int64x2_t)a9));
    if ((v22.i8[4] & 1) != 0)
      v17.i32[2] = *v18;
    v9 = (int32x2_t)vmovn_s32(vmovn_hight_s64(v22, (int64x2_t)a9));
    if ((v9.i8[6] & 1) != 0)
      v17.i32[3] = v18[1];
    v17 = vaddq_f32(v20, v17);
    v15 = vaddq_s64(v15, v19);
    v16 = vaddq_s64(v16, v19);
    v18 += 4;
    v13 -= 4;
  }
  while (v13);
  v23 = vbslq_s8((int8x16_t)vuzp1q_s32(v21, (int32x4_t)a9), (int8x16_t)v17, (int8x16_t)v20);
  v11 = (float)(vaddv_f32(*(float32x2_t *)v23.i8) + *(float *)&v23.i32[2]) + *(float *)&v23.i32[3];
  return v11 / (float)v10;
}

uint64_t Phase::SpatialModeler::EnergyHistogram::operator+=(uint64_t result, uint64_t a2)
{
  int v2;
  unsigned int v3;
  uint64_t v4;
  float *v5;
  float *v6;
  float v7;
  BOOL v8;
  char v9;
  unsigned int v10;
  NSObject *v11;
  std::logic_error *exception;
  int v13;
  const char *v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (vabds_f32(*(float *)(result + 16), *(float *)(a2 + 16)) > 0.000001
    || (v2 = *(_DWORD *)(result + 28), v2 != *(_DWORD *)(a2 + 28)))
  {
    v11 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)result) + 1184);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v13 = 136315394;
      v14 = "EnergyHistogram.cpp";
      v15 = 1024;
      v16 = 317;
      _os_log_impl(&dword_2164CC000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"Histograms have unequal resolution, they cannot be added.\\n\"", (uint8_t *)&v13, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Histograms have unequal resolution, they cannot be added.\n");
  }
  v3 = *(_DWORD *)(a2 + 24);
  if (v3 >= *(_DWORD *)(result + 24))
    v3 = *(_DWORD *)(result + 24);
  v4 = v3 * v2;
  if ((_DWORD)v4)
  {
    v5 = *(float **)(a2 + 8);
    v6 = *(float **)(result + 8);
    do
    {
      v7 = *v5++;
      *v6 = v7 + *v6;
      ++v6;
      --v4;
    }
    while (v4);
  }
  if (*(_BYTE *)(result + 36))
    v8 = *(_BYTE *)(a2 + 36) == 0;
  else
    v8 = 1;
  v9 = !v8;
  *(_BYTE *)(result + 36) = v9;
  v10 = *(_DWORD *)(a2 + 44) + *(_DWORD *)(result + 44);
  if (v10 >= 0xC350)
    v10 = 50000;
  *(_DWORD *)(result + 44) = v10;
  return result;
}

void sub_2165A6200(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t Phase::SpatialModeler::EnergyHistogram::operator*=(uint64_t a1, float a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64x2_t v5;
  int64x2_t v6;
  int64x2_t v7;
  float *v8;
  int64x2_t v9;
  int32x4_t v10;
  int32x2_t v11;
  int64x2_t v12;
  void *v13;

  if (a2 == 0.0)
  {
    v13 = *(void **)(a1 + 8);
    if (v13)
      bzero(v13, 4 * (*(_DWORD *)(a1 + 28) * *(_DWORD *)(a1 + 24)));
    *(_BYTE *)(a1 + 36) = 1;
    *(_DWORD *)(a1 + 44) = 0;
  }
  else
  {
    v3 = (*(_DWORD *)(a1 + 28) * *(_DWORD *)(a1 + 24));
    if ((_DWORD)v3)
    {
      v4 = (v3 + 3) & 0x1FFFFFFFCLL;
      v5 = (uint64x2_t)vdupq_n_s64(v3 - 1);
      v6 = (int64x2_t)xmmword_2166F7AD0;
      v7 = (int64x2_t)xmmword_2166F7AE0;
      v8 = (float *)(*(_QWORD *)(a1 + 8) + 8);
      v9 = vdupq_n_s64(4uLL);
      do
      {
        v10 = (int32x4_t)vcgeq_u64(v5, (uint64x2_t)v7);
        *(int32x2_t *)v10.i8 = vmovn_s64((int64x2_t)v10);
        v11 = (int32x2_t)vmovn_s32(v10);
        if ((v11.i8[0] & 1) != 0)
        {
          *(float *)v11.i32 = *(v8 - 2) * a2;
          *(v8 - 2) = *(float *)v11.i32;
        }
        if ((vmovn_s32(v10).i8[2] & 1) != 0)
          *(v8 - 1) = *(v8 - 1) * a2;
        v12 = (int64x2_t)vcgeq_u64(v5, (uint64x2_t)v6);
        if ((vmovn_s32(vmovn_hight_s64(v11, v12)).i32[1] & 1) != 0)
          *v8 = *v8 * a2;
        if ((vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v12, v12)).i8[6] & 1) != 0)
          v8[1] = v8[1] * a2;
        v6 = vaddq_s64(v6, v9);
        v7 = vaddq_s64(v7, v9);
        v8 += 4;
        v4 -= 4;
      }
      while (v4);
    }
  }
  return a1;
}

uint64_t Phase::SpatialModeler::EnergyHistogram::MultiplyAdd(uint64_t this, const Phase::SpatialModeler::EnergyHistogram *a2, float a3)
{
  int v3;
  unsigned int v4;
  uint64_t v5;
  float *v6;
  float *v7;
  float v8;
  BOOL v9;
  char v10;
  unsigned int v11;
  NSObject *v12;
  std::logic_error *exception;
  int v14;
  const char *v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (vabds_f32(*(float *)(this + 16), *((float *)a2 + 4)) > 0.000001
    || (v3 = *(_DWORD *)(this + 28), v3 != *((_DWORD *)a2 + 7)))
  {
    v12 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)this) + 1184);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v14 = 136315394;
      v15 = "EnergyHistogram.cpp";
      v16 = 1024;
      v17 = 385;
      _os_log_impl(&dword_2164CC000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"Histograms have unequal resolution, they cannot be multiply added.\\n\"", (uint8_t *)&v14, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Histograms have unequal resolution, they cannot be multiply added.\n");
  }
  v4 = *((_DWORD *)a2 + 6);
  if (v4 >= *(_DWORD *)(this + 24))
    v4 = *(_DWORD *)(this + 24);
  v5 = v4 * v3;
  if ((_DWORD)v5)
  {
    v6 = (float *)*((_QWORD *)a2 + 1);
    v7 = *(float **)(this + 8);
    do
    {
      v8 = *v6++;
      *v7 = *v7 + (float)(v8 * a3);
      ++v7;
      --v5;
    }
    while (v5);
  }
  if (*(_BYTE *)(this + 36))
    v9 = *((_BYTE *)a2 + 36) == 0;
  else
    v9 = 1;
  v10 = !v9;
  *(_BYTE *)(this + 36) = v10;
  v11 = *((_DWORD *)a2 + 11) + *(_DWORD *)(this + 44);
  if (v11 >= 0xC350)
    v11 = 50000;
  *(_DWORD *)(this + 44) = v11;
  return this;
}

void sub_2165A64B4(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t Phase::EQSphere::eq_point_set_polar(unsigned int a1, unsigned int a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  _DWORD **v10;
  unint64_t v11;
  _QWORD *v12;
  _DWORD *v13;
  _DWORD *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  int v21;
  uint64_t v22;
  float *v23;
  std::vector<unsigned int>::pointer begin;
  unsigned int v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float *v30;
  uint64_t v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float *v36;
  std::vector<unsigned int>::pointer v37;
  uint64_t v38;
  unint64_t v39;
  float v40;
  float v41;
  unsigned int v42;
  char *v43;
  int64_t v44;
  uint64_t v45;
  float *v46;
  std::vector<unsigned int>::pointer v47;
  unsigned int v48;
  int v49;
  float v50;
  float *v51;
  unint64_t v52;
  float v53;
  uint64_t v54;
  float *v55;
  unint64_t v56;
  float *v57;
  float *v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t v62;
  char *v63;
  float *v64;
  int v65;
  std::vector<unsigned int>::pointer end;
  std::vector<unsigned int>::pointer v67;
  uint64_t v68;
  int v69;
  float v70;
  float v71;
  uint64_t v72;
  float v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  void **v77;
  unsigned int v78;
  void **v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  char *v84;
  void **v85;
  void **v86;
  int v87;
  uint64_t v88;
  unint64_t v89;
  void **v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  float v94;
  char v95;
  int v96;
  signed int v97;
  int v98;
  int v99;
  uint64_t v100;
  uint64_t v101;
  float v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v106;
  unsigned int v107;
  void **p_p;
  void **v109;
  void **v110;
  std::vector<unsigned int> v111;
  void *v112;
  _BYTE *v113;
  uint64_t v114;
  void *__p;
  _BYTE *v116;
  uint64_t v117;

  if (a2 != 1)
  {
    if (!a2)
    {
      std::vector<std::vector<float>>::resize(a3, 0);
      return 0;
    }
    v112 = 0;
    v113 = 0;
    v114 = 0;
    memset(&v111, 0, sizeof(v111));
    if (a1 == 1)
    {
      std::vector<float>::resize((uint64_t)&v112, a2);
      std::vector<unsigned int>::resize(&v111, a2);
      v22 = 0;
      v23 = (float *)v112;
      begin = v111.__begin_;
      do
      {
        v23[v22] = (float)((float)((float)(v22 + 1) + (float)(v22 + 1)) * 3.1416)
                 / (float)(int)a2;
        begin[v22++] = 1;
      }
      while (a2 != v22);
    }
    else
    {
      if (a2 == 2)
      {
        v25 = 0;
        v26 = 6.2832;
        v27 = 1.5708;
      }
      else
      {
        v26 = 12.566 / (float)a2;
        v28 = asinf(sqrtf(v26 / 3.1416) * 0.5);
        v27 = v28 + v28;
        v29 = sqrtf(v26);
        if (v29 <= 0.0)
        {
          v25 = 0;
        }
        else if ((int)((3.14159265 - (float)(v27 + v27)) / v29 + 0.5) <= 1)
        {
          v25 = 1;
        }
        else
        {
          v25 = (int)((3.14159265 - (float)(v27 + v27)) / v29 + 0.5);
        }
      }
      __p = 0;
      v116 = 0;
      v117 = 0;
      std::vector<float>::resize((uint64_t)&__p, v25 + 2);
      v30 = (float *)__p;
      *(_DWORD *)__p = 1065353216;
      if (v25)
      {
        v31 = 0;
        v32 = (float)((float)(v27 * -2.0) + 3.1416) / (float)v25;
        do
        {
          v33 = sinf((float)(v27 + (float)((float)v31 * v32)) * 0.5);
          v34 = (float)(v33 * v33) * 12.566;
          v35 = sinf((float)(v27 + (float)((float)(v31 + 1) * v32)) * 0.5);
          v30[++v31] = (float)((float)((float)(v35 * v35) * 12.566) - v34) / v26;
        }
        while (v25 != v31);
      }
      v30[v25 + 1] = 1.0;
      std::vector<unsigned int>::resize(&v111, (v116 - (_BYTE *)v30) >> 2);
      v36 = (float *)__p;
      v37 = v111.__begin_;
      if (v116 != __p)
      {
        v38 = 0;
        v39 = (v116 - (_BYTE *)__p) >> 2;
        v40 = 0.0;
        do
        {
          v41 = v40 + v36[v38];
          v42 = (int)(float)(v41 + 0.5);
          v37[v38] = v42;
          v40 = v41 - (float)v42;
          ++v38;
        }
        while (v39 > v38);
      }
      std::vector<float>::resize((uint64_t)&v112, v111.__end_ - v37);
      v43 = (char *)v112;
      *(float *)v112 = v27;
      v44 = v111.__end_ - v111.__begin_;
      v45 = (v44 - 2);
      if ((_DWORD)v44 != 2)
      {
        v46 = (float *)(v43 + 4);
        v47 = v111.__begin_ + 1;
        v48 = 1;
        do
        {
          v49 = *v47++;
          v48 += v49;
          v50 = asinf(sqrtf((float)(v26 * (float)v48) / 3.1416) * 0.5);
          *v46++ = v50 + v50;
          --v45;
        }
        while (v45);
      }
      *(_DWORD *)&v43[4 * (v44 - 1)] = 1078530011;
      if (__p)
      {
        v116 = __p;
        operator delete(__p);
      }
    }
    v107 = a1 - 1;
    if (a1 == 1)
    {
      std::vector<std::vector<float>>::resize(a3, 1uLL);
      v51 = (float *)v112;
      if (((v113 - (_BYTE *)v112) & 0x3FFFFFFFCLL) != 0)
      {
        v52 = 0;
        do
        {
          v53 = v51[v52] - 3.14159265 / (float)a2;
          v54 = *a3;
          v55 = *(float **)(*a3 + 8);
          v56 = *(_QWORD *)(*a3 + 16);
          if ((unint64_t)v55 >= v56)
          {
            v58 = *(float **)v54;
            v59 = ((uint64_t)v55 - *(_QWORD *)v54) >> 2;
            v60 = v59 + 1;
            if ((unint64_t)(v59 + 1) >> 62)
              std::vector<float>::__throw_length_error[abi:ne180100]();
            v61 = v56 - (_QWORD)v58;
            if (v61 >> 1 > v60)
              v60 = v61 >> 1;
            if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFFCLL)
              v62 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v62 = v60;
            if (v62)
            {
              v63 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(*a3 + 16, v62);
              v58 = *(float **)v54;
              v55 = *(float **)(v54 + 8);
            }
            else
            {
              v63 = 0;
            }
            v64 = (float *)&v63[4 * v59];
            *v64 = v53;
            v57 = v64 + 1;
            while (v55 != v58)
            {
              v65 = *((_DWORD *)v55-- - 1);
              *((_DWORD *)v64-- - 1) = v65;
            }
            *(_QWORD *)v54 = v64;
            *(_QWORD *)(v54 + 8) = v57;
            *(_QWORD *)(v54 + 16) = &v63[4 * v62];
            if (v58)
              operator delete(v58);
          }
          else
          {
            *v55 = v53;
            v57 = v55 + 1;
          }
          *(_QWORD *)(v54 + 8) = v57;
          ++v52;
          v51 = (float *)v112;
        }
        while (v52 < ((unint64_t)(v113 - (_BYTE *)v112) >> 2));
      }
LABEL_112:
      if (v111.__begin_)
      {
        v111.__end_ = v111.__begin_;
        operator delete(v111.__begin_);
      }
      if (v112)
      {
        v113 = v112;
        operator delete(v112);
      }
      return 0;
    }
    v67 = v111.__begin_;
    end = v111.__end_;
    std::vector<std::vector<float>>::resize(a3, 2uLL);
    std::vector<float>::resize(*a3, a2);
    std::vector<float>::resize(*a3 + 24, a2);
    v106 = ((unint64_t)((char *)end - (char *)v67) >> 2) - 2;
    if (((unint64_t)((char *)end - (char *)v67) >> 2) == 2)
    {
      v103 = 1;
LABEL_111:
      v104 = *a3;
      *(_DWORD *)(*(_QWORD *)*a3 + 4 * v103) = 0;
      *(_DWORD *)(*(_QWORD *)(v104 + 24) + 4 * v103) = 1078530011;
      goto LABEL_112;
    }
    v68 = 0;
    v69 = 2;
    v70 = 0.0;
    while (1)
    {
      v71 = *((float *)v112 + v68);
      v72 = v68 + 1;
      v73 = *((float *)v112 + v68 + 1);
      v74 = v111.__begin_[v68 + 1];
      __p = 0;
      v116 = 0;
      v117 = 0;
      Phase::EQSphere::eq_point_set_polar(v107, v74, &__p);
      v109 = 0;
      v110 = 0;
      p_p = 0;
      v75 = *((_QWORD *)__p + 1);
      v76 = v75 - *(_QWORD *)__p;
      if (v75 == *(_QWORD *)__p)
        break;
      v77 = 0;
      v78 = 0;
      do
      {
        ++v78;
        if (v77 >= v110)
        {
          v79 = p_p;
          v80 = ((char *)v77 - (char *)p_p) >> 2;
          v81 = v80 + 1;
          if ((unint64_t)(v80 + 1) >> 62)
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          v82 = (char *)v110 - (char *)p_p;
          if (((char *)v110 - (char *)p_p) >> 1 > v81)
            v81 = v82 >> 1;
          if ((unint64_t)v82 >= 0x7FFFFFFFFFFFFFFCLL)
            v83 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v83 = v81;
          if (v83)
          {
            v84 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v110, v83);
            v79 = p_p;
            v77 = v109;
          }
          else
          {
            v84 = 0;
          }
          v85 = (void **)&v84[4 * v80];
          *(_DWORD *)v85 = v78;
          v86 = (void **)((char *)v85 + 4);
          while (v77 != v79)
          {
            v87 = *((_DWORD *)v77 - 1);
            v77 = (void **)((char *)v77 - 4);
            *((_DWORD *)v85 - 1) = v87;
            v85 = (void **)((char *)v85 - 4);
          }
          p_p = v85;
          v109 = v86;
          v110 = (void **)&v84[4 * v83];
          if (v79)
            operator delete(v79);
          v77 = v86;
        }
        else
        {
          *(_DWORD *)v77 = v78;
          v77 = (void **)((char *)v77 + 4);
        }
        v109 = v77;
        v88 = *(_QWORD *)__p;
        v89 = (uint64_t)(*((_QWORD *)__p + 1) - *(_QWORD *)__p) >> 2;
      }
      while (v89 > v78);
      v90 = p_p;
      v91 = ((char *)v77 - (char *)p_p) >> 2;
      if (v77 == p_p)
        goto LABEL_96;
      v92 = 0;
      v93 = *(_QWORD *)*a3;
      do
      {
        v94 = *(float *)(v88 + 4 * v92) + (float)(v70 * 6.2832);
        if (v94 >= 6.28318531)
          v94 = v94 + -6.2832;
        *(float *)(v93 + 4 * (v69 - 2 + *((_DWORD *)v90 + v92++))) = v94;
      }
      while (v91 > v92);
      v95 = 0;
      v77 = v90;
LABEL_97:
      v96 = v111.__begin_[(v68 + 2)];
      if ((int)v74 >= v96)
      {
        v97 = v74;
        v98 = v111.__begin_[(v68 + 2)];
        v99 = v74;
        if ((int)v74 <= v96)
          goto LABEL_101;
      }
      else
      {
        v97 = v111.__begin_[(v68 + 2)];
        v98 = v74;
      }
      do
      {
        v99 = v98;
        v98 = v97 % v98;
        v97 = v99;
      }
      while (v98);
LABEL_101:
      if ((v95 & 1) != 0)
      {
        v69 += v89;
        if (!v77)
          goto LABEL_108;
      }
      else
      {
        v100 = 0;
        v101 = *(_QWORD *)(*a3 + 24);
        do
          *(float *)(v101 + 4 * (v69 - 2 + *((_DWORD *)v77 + v100++))) = (float)(v71 + v73) * 0.5;
        while (v91 > v100);
        v69 += v89;
      }
      v109 = v77;
      operator delete(v77);
LABEL_108:
      v102 = v70
           + (float)((float)((float)((float)(1.0 / (float)v96) - (float)(1.0 / (float)v74))
                           * 0.5)
                   + (float)((float)v99
                           / (float)((float)((float)v74 + (float)v74)
                                   * (float)v96)));
      v70 = v102 - (float)(int)v102;
      p_p = &__p;
      std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&p_p);
      v68 = v72;
      if (v72 == v106)
      {
        v103 = (v69 - 1);
        goto LABEL_111;
      }
    }
    v91 = 0;
    v77 = 0;
    v89 = v76 >> 2;
LABEL_96:
    v95 = 1;
    goto LABEL_97;
  }
  v6 = a1;
  std::vector<std::vector<float>>::resize(a3, a1);
  if (a1)
  {
    v7 = 0;
    do
    {
      v8 = *a3 + 24 * v7;
      v10 = (_DWORD **)(v8 + 8);
      v9 = *(_DWORD **)(v8 + 8);
      v12 = (_QWORD *)(v8 + 16);
      v11 = *(_QWORD *)(v8 + 16);
      if ((unint64_t)v9 >= v11)
      {
        v14 = *(_DWORD **)v8;
        v15 = ((uint64_t)v9 - *(_QWORD *)v8) >> 2;
        v16 = v15 + 1;
        if ((unint64_t)(v15 + 1) >> 62)
          std::vector<float>::__throw_length_error[abi:ne180100]();
        v17 = v11 - (_QWORD)v14;
        if (v17 >> 1 > v16)
          v16 = v17 >> 1;
        if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL)
          v18 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v18 = v16;
        if (v18)
        {
          v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v12, v18);
          v9 = *v10;
          v14 = *(_DWORD **)v8;
        }
        else
        {
          v19 = 0;
        }
        v20 = &v19[4 * v15];
        *(_DWORD *)v20 = 0;
        v13 = v20 + 4;
        while (v9 != v14)
        {
          v21 = *--v9;
          *((_DWORD *)v20 - 1) = v21;
          v20 -= 4;
        }
        *(_QWORD *)v8 = v20;
        *v10 = v13;
        *v12 = &v19[4 * v18];
        if (v14)
          operator delete(v14);
      }
      else
      {
        *v9 = 0;
        v13 = v9 + 1;
      }
      *v10 = v13;
      ++v7;
    }
    while (v7 != v6);
  }
  return 0;
}

void sub_2165A6D58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22)
{
  if (__p)
    operator delete(__p);
  if (a18)
    operator delete(a18);
  _Unwind_Resume(exception_object);
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 4 * a2;
  }
  else
  {
    std::vector<float>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<float>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  int v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 2);
    if (v10 >> 62)
      std::vector<float>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 2;
    v12 = v5 - v8;
    if (v12 >> 1 > v10)
      v10 = v12 >> 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
      v13 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[4 * v11];
    v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void sub_2165A6FDC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2165A7178(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2165A731C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_2165A749C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_2165A782C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{

  _Unwind_Resume(a1);
}

void sub_2165A7D08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  int v19;
  void *v20;

  if (v19)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

BOOL Phase::IsFeatureEnabled_SessionBasedMuting(Phase *this)
{
  unsigned __int8 v1;
  unsigned __int8 v2;
  BOOL v3;

  v1 = atomic_load((unsigned __int8 *)&qword_254E448C0);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_254E448C0))
  {
    _MergedGlobals_15 = _os_feature_enabled_impl();
    __cxa_guard_release(&qword_254E448C0);
  }
  v2 = atomic_load((unsigned __int8 *)&qword_254E448C8);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_254E448C8))
  {
    byte_254E448B9 = _os_feature_enabled_impl();
    __cxa_guard_release(&qword_254E448C8);
  }
  if (_MergedGlobals_15)
    v3 = byte_254E448B9 == 0;
  else
    v3 = 1;
  return !v3;
}

void sub_2165A7E90(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254E448C8);
  _Unwind_Resume(a1);
}

void sub_2165A8368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, void *a15, void *a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  if (a14)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

void sub_2165A8898(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  int v3;
  void *v4;
  void *v5;

  if (v3)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

void sub_2165A8C4C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  int v3;
  void *v4;
  void *v5;

  if (v3)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

void sub_2165A8D90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_2165A9284(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

void sub_2165A9628(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2 + 48);
    __cxa_end_catch();
    JUMPOUT(0x2165A9568);
  }
  _Unwind_Resume(exception_object);
}

void sub_2165A9ACC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, int a11)
{
  void *v11;

  if (a11)
    os_unfair_recursive_lock_unlock();
  _Unwind_Resume(a1);
}

void sub_2165A9EEC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  int v3;
  void *v4;
  void *v5;
  void *v6;

  if (v3)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

void sub_2165AA230(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, int a12, uint64_t a13)
{
  if (a12)
    os_unfair_recursive_lock_unlock();
  _Unwind_Resume(exception_object);
}

void sub_2165AA554(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2165AAA7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, int a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  if (a15)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

void sub_2165AAF30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  int v15;
  void *v16;
  void *v17;
  void *v18;

  if (v15)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

void sub_2165AB498(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  int v3;
  void *v4;

  if (v3)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

void sub_2165ABAB4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  int v4;
  void *v5;

  if (v4)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

void sub_2165ABFA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  int v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  if (v3)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

void sub_2165AC37C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13)
{
  void *v13;
  void *v14;
  void *v15;

  if (a13)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

void sub_2165AC778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13)
{
  void *v13;
  void *v14;
  void *v15;

  if (a13)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

void sub_2165ACB84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13)
{
  void *v13;
  void *v14;
  void *v15;

  if (a13)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

void sub_2165ACF90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13)
{
  void *v13;
  void *v14;
  void *v15;

  if (a13)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

void sub_2165ADE88(_Unwind_Exception *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, void *a6, void *a7, void *a8, void *a9, uint64_t a10, int a11, int a12, void *a13, void *a14, ...)
{
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  va_list va;

  va_start(va, a14);

  std::unique_ptr<Phase::Controller::StreamRenderer>::reset[abi:ne180100]((Phase::Controller::StreamRenderer **)va, 0);
  if (a12)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

void sub_2165AE580(_Unwind_Exception *a1)
{
  void *v1;
  id *v2;

  operator delete(v2);
  _Unwind_Resume(a1);
}

void sub_2165AE944(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, int a11, void *a12)
{
  void *v12;

  if (a11)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

void sub_2165AEE7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, int a11, void *a12, uint64_t a13, uint64_t a14, void *a15)
{

  if (a11)
    os_unfair_recursive_lock_unlock();

  _Unwind_Resume(a1);
}

Phase::Logger *Phase::Envelope<float>::Envelope(Phase::Logger *a1, float *a2, float *a3)
{
  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = 0;
  Phase::Envelope<float>::InitializeFromSingleSegment(a1, a2, a3);
  return a1;
}

void sub_2165AF0FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<Phase::Envelope<double>::Segment,std::allocator<Phase::Envelope<double>::Segment>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void Phase::ExternalStreamSessionCommandExecutor::~ExternalStreamSessionCommandExecutor(Phase::ExternalStreamSessionCommandExecutor *this)
{
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::~Commandable(this);
  JUMPOUT(0x2199F9D70);
}

Phase::FIRFilterUtils *Phase::FIRFilterUtils::FIRFilterUtils(Phase::FIRFilterUtils *this, Phase::DFTUtils *a2, int a3)
{
  _DWORD *v6;
  _OWORD *v7;
  _OWORD *v8;
  uint64_t v9;
  int v10;
  int v11;
  char *v12;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  v6 = operator new(0xCuLL);
  *(_QWORD *)v6 = 0x447A000043FA0000;
  v6[2] = 1167867904;
  *(_QWORD *)this = v6;
  *((_QWORD *)this + 1) = v6 + 3;
  *((_QWORD *)this + 2) = v6 + 3;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  v7 = operator new(0x28uLL);
  *v7 = xmmword_2166F8160;
  v7[1] = unk_2166F8170;
  *((_QWORD *)v7 + 4) = 0x467A000045FA0000;
  *((_QWORD *)this + 3) = v7;
  *((_QWORD *)this + 4) = (char *)v7 + 40;
  *((_QWORD *)this + 5) = (char *)v7 + 40;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  v8 = operator new(0x7CuLL);
  v9 = 0;
  v8[4] = xmmword_2166F81C8;
  v8[5] = unk_2166F81D8;
  v8[6] = xmmword_2166F81E8;
  *(_OWORD *)((char *)v8 + 108) = *(__int128 *)((char *)&xmmword_2166F81E8 + 12);
  *v8 = xmmword_2166F8188;
  v8[1] = unk_2166F8198;
  v8[2] = xmmword_2166F81A8;
  v8[3] = unk_2166F81B8;
  *((_QWORD *)this + 6) = v8;
  *((_QWORD *)this + 7) = (char *)v8 + 124;
  *((_QWORD *)this + 8) = (char *)v8 + 124;
  *((_QWORD *)this + 9) = a2;
  v10 = *(_DWORD *)a2;
  if (*(int *)a2 >= 0)
    v11 = *(_DWORD *)a2;
  else
    v11 = v10 + 1;
  *((_DWORD *)this + 20) = (v11 >> 1) + 1;
  *((_DWORD *)this + 21) = a3;
  *((_DWORD *)this + 22) = v10;
  do
  {
    v12 = (char *)this + v9;
    *((_QWORD *)v12 + 12) = 0;
    *((_DWORD *)v12 + 26) = 0;
    *((_QWORD *)v12 + 15) = 0;
    *((_QWORD *)v12 + 16) = 0;
    *((_QWORD *)v12 + 14) = 0;
    *(_OWORD *)(v12 + 152) = 0uLL;
    *(_OWORD *)(v12 + 168) = 0uLL;
    *(_OWORD *)(v12 + 184) = 0uLL;
    *(_OWORD *)(v12 + 200) = 0uLL;
    v9 += 128;
    *((_QWORD *)v12 + 27) = 0;
  }
  while (v9 != 384);
  return this;
}

void sub_2165AF2F8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  void *v4;

  *(_QWORD *)(v1 + 32) = v2;
  operator delete(v2);
  v4 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

void Phase::FIRFilterUtils::ConstructFIREqFilter(uint64_t a1, int a2, uint64_t a3, int a4, float *__C, float *a6, DSPComplex *a7)
{
  Phase::Logger *v13;
  uint64_t v14;
  float v15;
  int v16;
  uint64_t v17;
  float v18;
  int v19;
  float v20;
  int v21;
  Phase::Logger *v22;
  float *v23;
  NSObject *v24;
  std::logic_error *v25;
  NSObject *v26;
  uint64_t v27;
  std::runtime_error *exception;
  int v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  uint64_t v34;
  uint64_t v35;
  DSPSplitComplex v36;

  v35 = *MEMORY[0x24BDAC8D0];
  vDSP_vclr(__C, 1, *(int *)(a1 + 80));
  vDSP_vclr(a6, 1, *(int *)(a1 + 80));
  v14 = (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2;
  switch(v14)
  {
    case 31:
      v20 = (float)*(int *)(a1 + 84);
      v21 = *(_DWORD *)(a1 + 88);
      if (*(_DWORD *)(a1 + 352) != v21 || *(_DWORD *)(a1 + 356) != 31 || vabds_f32(*(float *)(a1 + 360), v20) >= 0.1)
        Phase::LookupInterpolator::Initialize((Phase::LookupInterpolator *)(a1 + 352), v20, v21, 0x1Fu, *(float **)(a1 + 48));
      v17 = 2;
      break;
    case 10:
      v18 = (float)*(int *)(a1 + 84);
      v19 = *(_DWORD *)(a1 + 88);
      if (*(_DWORD *)(a1 + 224) != v19 || *(_DWORD *)(a1 + 228) != 10 || vabds_f32(*(float *)(a1 + 232), v18) >= 0.1)
        Phase::LookupInterpolator::Initialize((Phase::LookupInterpolator *)(a1 + 224), v18, v19, 0xAu, *(float **)(a1 + 24));
      v17 = 1;
      break;
    case 3:
      v15 = (float)*(int *)(a1 + 84);
      v16 = *(_DWORD *)(a1 + 88);
      if (*(_DWORD *)(a1 + 96) != v16 || *(_DWORD *)(a1 + 100) != 3 || vabds_f32(*(float *)(a1 + 104), v15) >= 0.1)
        Phase::LookupInterpolator::Initialize((Phase::LookupInterpolator *)(a1 + 96), v15, v16, 3u, *(float **)a1);
      v17 = 0;
      break;
    default:
      v26 = **(NSObject ***)(Phase::Logger::GetInstancePtr(v13) + 608);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        v27 = (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2;
        v29 = 136315650;
        v30 = "FIRFilterUtils.cpp";
        v31 = 1024;
        v32 = 89;
        v33 = 2048;
        v34 = v27;
        _os_log_impl(&dword_2164CC000, v26, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error): \"Given third octave filter must have 3, 10 or 31 bands (it has %lu coefficients\"", (uint8_t *)&v29, 0x1Cu);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Given third octave filter must have 3, 10 or 31 bands (it has %lu coefficients");
  }
  Phase::LookupInterpolator::InterpolateWithFractions((Phase::LookupInterpolator *)(a1 + (v17 << 7) + 96), *(float **)a3, __C);
  if (a2)
  {
    if (a2 != 1)
    {
      v24 = **(NSObject ***)(Phase::Logger::GetInstancePtr(v22) + 608);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        v29 = 136315650;
        v30 = "FIRFilterUtils.cpp";
        v31 = 1024;
        v32 = 53;
        v33 = 1024;
        LODWORD(v34) = a2;
        _os_log_impl(&dword_2164CC000, v24, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"FIR filter phase type requested is not supported. (FIRPhaseType: %d)\"", (uint8_t *)&v29, 0x18u);
      }
      v25 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](v25, "FIR filter phase type requested is not supported. (FIRPhaseType: %d)");
    }
    v36.realp = __C;
    v36.imagp = a6;
    Phase::FIRFilterUtils::ConstructMinimumPhaseInPlace((Phase::FIRFilterUtils *)a1, v36, a7, v23);
  }
}

void sub_2165AF6A0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void Phase::FIRFilterUtils::ConstructMinimumPhaseInPlace(Phase::FIRFilterUtils *this, DSPSplitComplex a2, DSPComplex *a3, float *a4)
{
  DSPComplex *v4;
  float *imagp;
  float *realp;
  int v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  int v12;
  float v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t i;
  float *v19;
  float *v20;
  int v21;
  uint64_t v22;
  float v23;
  float v24;
  int v25;
  float __B;
  DSPSplitComplex __Z;
  uint64_t v28;

  v4 = a3;
  imagp = a2.imagp;
  realp = a2.realp;
  v28 = *MEMORY[0x24BDAC8D0];
  __Z = a2;
  v8 = *((_DWORD *)this + 20);
  if (!a3)
  {
    MEMORY[0x24BDAC7A8](this);
    v4 = (DSPComplex *)((char *)&v22 - v9);
    bzero((char *)&v22 - v9, v10);
  }
  v25 = v8;
  __B = 1.1755e-38;
  vDSP_vabs(realp, 1, realp, 1, v8);
  vDSP_vsadd(realp, 1, &__B, realp, 1, v8);
  vvlogf(realp, realp, &v25);
  v11 = *((_QWORD *)this + 9);
  *imagp = realp[*(_DWORD *)v11 / 2];
  vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)(v11 + 16), realp, imagp, realp, imagp);
  v24 = 1.0 / (float)**((int **)this + 9);
  vDSP_ztoc(&__Z, 1, v4, 2, *((int *)this + 20));
  vDSP_vsmul((const float *)v4, 1, &v24, (float *)v4, 1, *((int *)this + 22));
  v12 = *((_DWORD *)this + 22);
  v13 = (float)v12 / 10.0;
  v14 = (int)v13;
  v15 = v12 + ~(_DWORD)v14;
  v16 = v12 - v14;
  if (v15 >= 0)
    v16 = v15;
  v17 = v16 >> 1;
  v23 = 2.0;
  vDSP_vsmul(&v4->imag, 1, &v23, &v4->imag, 1, (v16 >> 1) - 1);
  if ((_DWORD)v14)
  {
    for (i = 0; i != v14; ++i)
      *(&v4->real + (v17 + i)) = *(&v4->real + (v17 + i))
                                             * (float)(cosf((float)((float)(1.0 / (float)(int)v13) * (float)i)* 3.1416)+ 1.0);
  }
  vDSP_vclr((float *)v4 + v17 + (int)v14, 1, *((int *)this + 22) - (uint64_t)(v17 + (int)v14));
  Phase::DFTUtils::ProcessDFT(*((const vDSP_DFT_SetupStruct ***)this + 9), v4, &__Z, 0.5);
  v19 = __Z.realp;
  v20 = __Z.imagp;
  v21 = **((_DWORD **)this + 9) / 2;
  __Z.realp[v21] = *__Z.imagp;
  v20[v21] = 0.0;
  *v20 = 0.0;
  vvexpf(v19, v19, &v25);
  vvcosf((float *)v4, __Z.imagp, &v25);
  vvsinf(__Z.imagp, __Z.imagp, &v25);
  vDSP_vmul(__Z.realp, 1, __Z.imagp, 1, __Z.imagp, 1, v25);
  vDSP_vmul(__Z.realp, 1, (const float *)v4, 1, __Z.realp, 1, v25);
}

void Phase::FIRFilterUtils::GetFrequencyVectorOfDFTBins(int *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64x2_t v9;
  int64x2_t v10;
  float v11;
  int64x2_t v12;
  unint64_t v13;
  int32x2_t v14;

  std::vector<float>::resize((uint64_t)a2, a1[20]);
  v4 = *a2;
  v5 = a2[1];
  v6 = v5 - *a2;
  if (v5 != *a2)
  {
    v7 = 0;
    v8 = v6 >> 2;
    if (v8 <= 1)
      v8 = 1;
    v9 = (uint64x2_t)vdupq_n_s64(v8 - 1);
    v10 = (int64x2_t)xmmword_2166F7AE0;
    v11 = (float)a1[21] / (float)a1[22];
    v12 = vdupq_n_s64(2uLL);
    v13 = (v8 + 1) & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      v14 = vmovn_s64((int64x2_t)vcgeq_u64(v9, (uint64x2_t)v10));
      if ((v14.i8[0] & 1) != 0)
        *(float *)(v4 + 4 * v7) = v11 * (float)(int)v7;
      if ((v14.i8[4] & 1) != 0)
        *(float *)(v4 + 4 * v7 + 4) = v11 * (float)(v7 + 1);
      v7 += 2;
      v10 = vaddq_s64(v10, v12);
    }
    while (v13 != v7);
  }
}

uint64_t *Phase::DspLayer::GainControl::GetNewRegistryEntry(Phase::DspLayer::GainControl *this)
{
  _QWORD *v1;
  uint64_t *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v6[2];
  char v7;
  void *__p[2];
  char v9;
  _QWORD v10[3];
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v1 = malloc_type_malloc(0x38uLL, 0x1050040B063AAFAuLL);
  *v1 = "Gain";
  v1[1] = 0x500000000;
  *(_QWORD *)((char *)v1 + 20) = 0x100000000;
  *((_DWORD *)v1 + 7) = 3;
  *((_OWORD *)v1 + 2) = xmmword_2166F7470;
  v1[6] = 0x3FF0000000000000;
  v2 = (uint64_t *)operator new();
  v10[0] = &off_24D57CBB0;
  v11 = v10;
  Phase::Controller::VoicePoolEntry::VoicePoolEntry((uint64_t)v2, "GainControl", 1, (uint64_t)v1, (uint64_t)v10);
  v3 = v11;
  if (v11 == v10)
  {
    v4 = 4;
    v3 = v10;
  }
  else
  {
    if (!v11)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  std::string::basic_string[abi:ne180100]<0>(__p, "Input");
  Phase::Controller::VoicePoolEntry::AddInput(v2, (__int128 *)__p);
  if (v9 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(v6, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v6);
  if (v7 < 0)
    operator delete(v6[0]);
  return v2;
}

void sub_2165AFBE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Phase::DspLayer::GainControl::~GainControl(Phase::DspLayer::GainControl *this)
{
  Phase::DspLayer::VoicePool::~VoicePool(this);
  JUMPOUT(0x2199F9D70);
}

void `anonymous namespace'::GainControlSlice::~GainControlSlice(_anonymous_namespace_::GainControlSlice *this)
{
  JUMPOUT(0x2199F9D70);
}

double `anonymous namespace'::GainControlSlice::Reset(_OWORD *a1)
{
  double result;

  __asm { FMOV            V0.4S, #1.0 }
  a1[1] = _Q0;
  a1[2] = 0u;
  a1[259] = 0u;
  (*(void (**)(_OWORD *))(*(_QWORD *)a1 + 48))(a1);
  result = 0.0;
  a1[520] = 0u;
  a1[519] = 0u;
  return result;
}

uint64_t `anonymous namespace'::GainControlSlice::Reset(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  _DWORD *v7;
  uint64_t result;

  v7 = (_DWORD *)(a1 + 4 * a3);
  v7[4] = 1065353216;
  v7[8] = 0;
  v7[1036] = 0;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  *(_QWORD *)(a1 + 8 * a3 + 8304) = a4;
  return result;
}

double `anonymous namespace'::GainControlSlice::GetParameter(_anonymous_namespace_::GainControlSlice *this, int a2, int a3)
{
  double result;

  if (!a2)
    return *((float *)this + a3 + 4);
  return result;
}

float `anonymous namespace'::GainControlSlice::SetParameter(_anonymous_namespace_::GainControlSlice *this, int a2, int a3, double a4)
{
  if (!a2)
  {
    *(float *)&a4 = a4;
    *((_DWORD *)this + a3 + 4) = LODWORD(a4);
  }
  return *(float *)&a4;
}

__n128 `anonymous namespace'::GainControlSlice::UpdateParameters(__n128 *a1)
{
  __n128 result;
  __n128 v3;
  __n128 v4;

  v3 = a1[1];
  v4 = a1[259];
  memcpy(&a1[260], &a1[2], 0x1010uLL);
  a1[517] = v4;
  result = v3;
  a1[518] = v3;
  return result;
}

uint64_t `anonymous namespace'::GainControlSlice::UpdateParameters(uint64_t result, uint64_t a2, int a3)
{
  _DWORD *v3;
  int v4;
  int v5;
  uint64_t v6;
  _DWORD *v7;
  uint64_t v8;

  v3 = (_DWORD *)(result + 4 * a3);
  v4 = v3[1036];
  v5 = v3[4];
  v6 = v3[8];
  v3[1040] = v6;
  if ((int)v6 >= 1)
  {
    v7 = (_DWORD *)(result + 4 * a3);
    do
    {
      v7[1044] = v7[12];
      v7[1048] = v7[16];
      v7 += 8;
      --v6;
    }
    while (v6);
  }
  v8 = result + 4 * a3;
  *(_DWORD *)(v8 + 8272) = v4;
  *(_DWORD *)(v8 + 8288) = v5;
  return result;
}

uint64_t `anonymous namespace'::GainControlSlice::Run(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int32x4_t v4;
  int64x2_t v5;
  uint64_t v6;
  float32x4_t *v7;
  float32x4_t v8;
  int32x4_t v9;
  int32x4_t v10;
  int8x16_t v11;
  unint64_t v12;
  float32x4_t v13;
  int8x16_t v14;

  v4 = (int32x4_t)vandq_s8(*(int8x16_t *)(result + 4160), (int8x16_t)vcgtq_s32(vdupq_n_s32(a4), (int32x4_t)xmmword_2166F76B0));
  v5 = (int64x2_t)vcgtzq_s32(v4);
  if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0])
  {
    v6 = *(_QWORD *)(a2 + 56);
    v7 = (float32x4_t *)(result + 4192);
    v8 = 0uLL;
    v9 = 0uLL;
    v10.i64[0] = 0x100000001;
    v10.i64[1] = 0x100000001;
    do
    {
      v11.i32[0] = *(_DWORD *)(v6 + 4 * v7[-1].i32[0]);
      v11.i32[1] = *(_DWORD *)(v6 + 4 * v7[-1].i32[1]);
      v11.i32[2] = *(_DWORD *)(v6 + 4 * v7[-1].i32[2]);
      v11.i32[3] = *(_DWORD *)(v6 + 4 * v7[-1].i32[3]);
      v8 = vmlaq_f32(v8, (float32x4_t)vandq_s8((int8x16_t)v5, v11), *v7);
      v9 = vaddq_s32(v9, v10);
      v5 = (int64x2_t)vcgtq_s32(v4, v9);
      v7 += 2;
    }
    while (vorrq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0]);
  }
  else
  {
    v8 = 0uLL;
  }
  HIDWORD(v12) = a4 - 1;
  LODWORD(v12) = a4 - 1;
  v13 = vmulq_f32(*(float32x4_t *)(result + 8288), v8);
  v14 = vandq_s8((int8x16_t)v13, vorrq_s8((int8x16_t)vcltzq_f32(v13), (int8x16_t)vcgezq_f32(v13)));
  switch((v12 >> 1))
  {
    case 0u:
      goto LABEL_10;
    case 1u:
      goto LABEL_9;
    case 3u:
      goto LABEL_8;
    case 7u:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8284)) = v14.i32[3];
LABEL_8:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8280)) = v14.i32[2];
LABEL_9:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8276)) = v14.i32[1];
LABEL_10:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8272)) = v14.i32[0];
      break;
    default:
      return result;
  }
  return result;
}

float `anonymous namespace'::GainControlSlice::CopyVoiceState(_anonymous_namespace_::GainControlSlice *this, Phase::DspLayer::VoicePoolSlice *a2, int a3, int a4)
{
  char *v4;
  char *v5;
  uint64_t v6;
  _DWORD *v7;
  int *v8;
  int v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _DWORD *v13;
  int *v14;
  int v15;
  float result;

  v4 = (char *)a2 + 4 * a3;
  v5 = (char *)this + 4 * a4;
  *((_DWORD *)v5 + 4) = *((_DWORD *)v4 + 4);
  v6 = *((unsigned int *)v4 + 8);
  *((_DWORD *)v5 + 8) = v6;
  if ((int)v6 >= 1)
  {
    v7 = (_DWORD *)((char *)this + 4 * a4 + 64);
    v8 = (int *)((char *)a2 + 4 * a3 + 64);
    do
    {
      *(v7 - 4) = *(v8 - 4);
      v9 = *v8;
      v8 += 8;
      *v7 = v9;
      v7 += 8;
      --v6;
    }
    while (v6);
  }
  v10 = (char *)this + 4 * a4;
  v11 = (char *)a2 + 4 * a3;
  v12 = *((unsigned int *)v11 + 1040);
  *((_DWORD *)v10 + 1040) = v12;
  if ((int)v12 >= 1)
  {
    v13 = v10 + 4192;
    v14 = (int *)(v11 + 4192);
    do
    {
      *(v13 - 4) = *(v14 - 4);
      v15 = *v14;
      v14 += 8;
      *v13 = v15;
      v13 += 8;
      --v12;
    }
    while (v12);
  }
  *((_DWORD *)v10 + 1036) = *((_DWORD *)v11 + 1036);
  *((_DWORD *)v10 + 2068) = *((_DWORD *)v11 + 2068);
  result = *((float *)v11 + 2072);
  *((float *)v10 + 2072) = result;
  *((_QWORD *)this + a4 + 1038) = *((_QWORD *)a2 + a3 + 1038);
  return result;
}

uint64_t `anonymous namespace'::GainControlSlice::AddInput(_anonymous_namespace_::GainControlSlice *this, int a2, int a3, int a4, float a5)
{
  uint64_t result;
  char *v7;
  uint64_t v8;
  char *v9;

  if (a2)
    return 8;
  v7 = (char *)this + 32;
  v8 = *((int *)this + a3 + 8);
  if ((int)v8 > 127)
    return 6;
  result = 0;
  v9 = (char *)this + 32 * v8 + 4 * a3;
  *((_DWORD *)v9 + 12) = a4;
  *((float *)v9 + 16) = a5;
  *(_DWORD *)&v7[4 * a3] = v8 + 1;
  return result;
}

uint64_t `anonymous namespace'::GainControlSlice::RemoveInput(_anonymous_namespace_::GainControlSlice *this, int a2, int a3, int a4)
{
  if (a2)
    return 8;
  else
    return Phase::DspLayer::VoiceConnectionList<128>::RemoveConnection((uint64_t)this + 32, a3, a4);
}

uint64_t `anonymous namespace'::GainControlSlice::SetInputGain(_anonymous_namespace_::GainControlSlice *this, int a2, int a3, int a4, float a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  float *i;

  if (a2)
    return 8;
  v6 = *((unsigned int *)this + a3 + 8);
  if ((int)v6 < 1)
    return 7;
  v7 = 0;
  for (i = (float *)((char *)this + 4 * a3 + 64); *((_DWORD *)i - 4) != a4; i += 8)
  {
    if (v6 == ++v7)
      return 7;
  }
  if ((v7 & 0x80000000) != 0)
    return 7;
  result = 0;
  *i = a5;
  return result;
}

void `anonymous namespace'::GainControlSlice::GetInputs(_anonymous_namespace_::GainControlSlice *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (a2)
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    *(_QWORD *)(a4 + 16) = 0;
  }
  else
  {
    Phase::DspLayer::VoiceConnectionList<128>::GetConnections((uint64_t)this + 32, a3, (char **)a4);
  }
}

uint64_t `anonymous namespace'::GainControlSlice::ClearInputs(_anonymous_namespace_::GainControlSlice *this, int a2)
{
  *((_DWORD *)this + a2 + 8) = 0;
  return 0;
}

uint64_t `anonymous namespace'::GainControlSlice::GetMaximumInputConnectionCount(_anonymous_namespace_::GainControlSlice *this, int a2)
{
  return (a2 == 0) << 7;
}

unint64_t `anonymous namespace'::GainControlSlice::GetOutput(_anonymous_namespace_::GainControlSlice *this, int a2, int a3)
{
  if (a2)
    return 0xFFFFFFFF00000008;
  else
    return (unint64_t)*((unsigned int *)this + a3 + 1036) << 32;
}

uint64_t `anonymous namespace'::GainControlSlice::SetOutput(_anonymous_namespace_::GainControlSlice *this, int a2, int a3, int a4)
{
  uint64_t result;

  if (a2)
    return 8;
  result = 0;
  *((_DWORD *)this + a3 + 1036) = a4;
  return result;
}

void std::__function::__func<Phase::DspLayer::GainControl::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::GainControl::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<Phase::DspLayer::GainControl::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::GainControl::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57CBB0;
  return result;
}

void std::__function::__func<Phase::DspLayer::GainControl::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::GainControl::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57CBB0;
}

uint64_t std::__function::__func<Phase::DspLayer::GainControl::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::GainControl::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::operator()(uint64_t a1, Phase::DspLayer::VoiceEngine **a2, int *a3)
{
  Phase::DspLayer::VoiceEngine *v3;
  int v4;
  uint64_t v5;
  int v6;
  _OWORD *v12;
  __int128 v14;

  v3 = *a2;
  v4 = *a3;
  v5 = operator new();
  Phase::DspLayer::VoicePool::VoicePool((Phase::DspLayer::VoicePool *)v5, "GainControl", v3, v4, 8336);
  *(_QWORD *)v5 = &off_24D57CAB8;
  if (*(int *)(v5 + 40) >= 1)
  {
    v6 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    v14 = _Q0;
    do
    {
      v12 = (_OWORD *)(*(_QWORD *)(v5 + 24) + *(int *)(v5 + 16) * (uint64_t)v6);
      *(_QWORD *)v12 = &off_24D57CAD8;
      *((_QWORD *)v12 + 1) = 0;
      bzero(v12 + 3, 0x1000uLL);
      v12[2] = 0u;
      v12 += 2;
      *(v12 - 1) = v14;
      v12[257] = 0u;
      memcpy(v12 + 258, v12, 0x1010uLL);
      v12[515] = 0u;
      v12[516] = v14;
      v12[517] = 0u;
      v12[518] = 0u;
      ++v6;
    }
    while (v6 < *(_DWORD *)(v5 + 40));
  }
  return v5;
}

void sub_2165B02AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199F9D70](v1, 0x10F1C408EBD29CELL);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::generateDirectionalMetadataER(_QWORD *a1, double a2, double a3, double a4, double a5, float a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  unint64_t v11;
  unint64_t v14;
  const Phase::SpatialModeler::AudibleEarlyReflection *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  float v19;
  float v20;
  uint64_t v21;
  float *v22;
  float v23;
  uint64_t v24;
  float v25;
  float v26;
  float v27;
  float *v28;
  void *v29;
  int v30;
  int *v31;
  void *v32;
  int *v33;
  NSObject *v34;
  unint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  float v39;
  float *v40;
  unint64_t v41;
  float *v42;
  float *v43;
  float v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  float v48;
  float v49;
  float v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  void *v54;
  void *v55;
  uint64_t v56;
  uint8_t buf[4];
  const char *v58;
  __int16 v59;
  int v60;
  __int16 v61;
  unint64_t v62;
  uint64_t v63;

  v63 = *MEMORY[0x24BDAC8D0];
  if (a9)
  {
    v10 = a1;
    if ((int)(954437177 * ((uint64_t)(a1[1] - *a1) >> 5)) >= 1)
    {
      v11 = a10;
      v14 = *(unsigned int *)(*a1 + 140);
      v46 = 954437177 * ((uint64_t)(a1[1] - *a1) >> 5);
      Phase::SpatialModeler::AllocMetadata<float>((uint64_t *)a9, v46, a10);
      v16 = 0;
      v45 = 4 * v11;
      v52 = 16;
      v53 = 0;
      v51 = v11;
      v47 = v14;
      while (1)
      {
        v17 = *v10;
        if (v16 >= (int)(954437177 * ((v10[1] - *v10) >> 5)))
        {
LABEL_46:
          *(_BYTE *)(a9 + 201) = 0;
          *(_DWORD *)(a9 + 204) = 0;
          return;
        }
        v18 = v17 + 288 * v16;
        v19 = *(float *)(v18 + 8);
        v20 = (float)((float)(180.0 - *(float *)(v18 + 4))
                    - (float)(floorf((float)(180.0 - *(float *)(v18 + 4)) / 360.0) * 360.0))
            + 0.0;
        if (v20 >= 360.0)
          v20 = nextafterf(360.0, 0.0);
        v21 = *(_QWORD *)(a9 + 8) + 12 * v16;
        *(_DWORD *)v21 = 1065353216;
        *(float *)(v21 + 4) = 90.0 - v19;
        *(float *)(v21 + 8) = v20;
        v22 = (float *)(v17 + 288 * v16);
        v23 = v22[3] - v22[66];
        v24 = *(_QWORD *)(a9 + 56);
        if (v23 < 0.0)
          v23 = 0.0;
        *(float *)(v24 + 4 * v16) = v23;
        *(_BYTE *)(*(_QWORD *)(a9 + 144) + v16) = 0;
        v25 = v22[67];
        v49 = v22[58];
        v50 = v22[59];
        v26 = v22[68];
        v48 = v22[60];
        v27 = v22[69];
        v28 = v22 + 4;
        v54 = 0;
        v55 = 0;
        v56 = 0;
        if (v14 != v11)
          break;
        v29 = 0;
LABEL_35:
        v36 = v10;
        v37 = *(_QWORD *)(a9 + 104);
        v38 = *(_QWORD *)(v37 + 8);
        if (*(float *)(v24 + 4 * v16) == 0.0)
        {
          if (v11)
            bzero((void *)(v37 + 4 * v38 * v16 + 16), v45);
        }
        else if (v11)
        {
          v39 = 1.0
              / sqrtf((float)((float)((float)(v49 - v25) * (float)(v49 - v25))+ (float)((float)(v50 - v26) * (float)(v50 - v26)))+ (float)((float)(v48 - v27) * (float)(v48 - v27)));
          v40 = (float *)(*v10 + 288 * v16);
          v41 = v51;
          v42 = (float *)(*v10 + v52);
          v43 = (float *)(v37 + v38 * v53 + 16);
          do
          {
            v44 = fminf(fmaxf(v40[36], 0.0), 10.0) / 10.0;
            *v43 = (float)((float)(v39 * fabsf(*v28))
                         * sqrtf((float)(v44 * v44)* fminf(fmaxf(fmaxf(Phase::SpatialModeler::EarlyReflectionDetector::GetLastPathAngleError((Phase::SpatialModeler::EarlyReflectionDetector *)v40, v15)+ -0.86603, 0.0)/ 0.040282, 0.0), 1.0)))* a6;
            if (*v42 < 0.0)
              *(_BYTE *)(*(_QWORD *)(a9 + 144) + v16) = 1;
            ++v42;
            ++v43;
            ++v28;
            --v41;
          }
          while (v41);
        }
        if (v29)
        {
          v55 = v29;
          operator delete(v29);
        }
        ++v16;
        v11 = v51;
        v52 += 288;
        v53 += 4;
        v10 = v36;
        v14 = v47;
        if (v16 == v46)
          goto LABEL_46;
      }
      std::vector<float>::resize((uint64_t)&v54, v11);
      switch((_DWORD)v14)
      {
        case 0x1F:
          v30 = 1;
          v31 = &Phase::sThirdOctaveBandFrequencies;
          break;
        case 0xA:
          v30 = 1;
          v31 = &Phase::sOctaveBandFrequencies;
          break;
        case 3:
          v30 = 1;
          v31 = (int *)&Phase::sThreeBandFrequencies;
          break;
        default:
          v30 = 0;
          v31 = 0;
          break;
      }
      v32 = v54;
      if (v11 == 3)
      {
        v33 = (int *)&Phase::sThreeBandFrequencies;
        if (!v30)
          goto LABEL_24;
      }
      else
      {
        if (v11 != 31)
        {
          if (v11 == 10)
          {
            v33 = &Phase::sOctaveBandFrequencies;
            if (v30)
              goto LABEL_33;
          }
LABEL_24:
          if ((Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce & 1) == 0)
          {
            v34 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)v31) + 1184);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315650;
              if (v30)
                v35 = v11;
              else
                v35 = v14;
              v58 = "GeneratePlaneWaveList.hpp";
              v59 = 1024;
              v60 = 177;
              v61 = 2048;
              v62 = v35;
              _os_log_impl(&dword_2164CC000, v34, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported subband count: %zu\n", buf, 0x1Cu);
            }
            Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce = 1;
          }
          bzero(v32, v45);
          goto LABEL_34;
        }
        v33 = &Phase::sThirdOctaveBandFrequencies;
        if (!v30)
          goto LABEL_24;
      }
LABEL_33:
      Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>((float *)v31, (float *)&v31[v14], (uint64_t)v28, (uint64_t)&v28[v14], (float *)v33, (float *)&v33[v11], (uint64_t)v54);
LABEL_34:
      v29 = v54;
      v24 = *(_QWORD *)(a9 + 56);
      v28 = (float *)v54;
      goto LABEL_35;
    }
  }
}

void sub_2165B0798(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t *Phase::SpatialModeler::AllocMetadata<float>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  _QWORD v13[4];
  uint64_t v14;
  uint64_t *v15;
  _QWORD v16[5];

  v16[4] = *MEMORY[0x24BDAC8D0];
  v10 = 4;
  v11 = a2;
  v12 = &v11;
  v13[0] = &v10;
  Phase::details::AllocArray<Phase::Vector<float,3ul>,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(Phase::Vector<float,3ul>*)#1} const&>(a2, (uint64_t)&v12, &v15);
  v6 = v15;
  v15 = 0;
  v12 = v6;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v13, (uint64_t)v16);
  v14 = a2;
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v15);
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100](a1 + 1, (uint64_t *)&v12);
  a1[6] = v14;
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v12);
  v10 = 4;
  v11 = a2;
  v12 = &v11;
  v13[0] = &v10;
  Phase::details::AllocArray<float,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(float*)#1} const&>(a2, (uint64_t)&v12, &v15);
  v7 = v15;
  v15 = 0;
  v12 = v7;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v13, (uint64_t)v16);
  v14 = a2;
  std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v15);
  std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100](a1 + 7, (uint64_t *)&v12);
  a1[12] = v14;
  std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v12);
  Phase::AllocPackedSubbandArray<float>(a2, a3, (void **)&v12);
  std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::operator=[abi:ne180100](a1 + 13, (uint64_t *)&v12);
  std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v12);
  v10 = 1;
  v11 = a2;
  v12 = &v11;
  v13[0] = &v10;
  Phase::details::AllocArray<BOOL,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(BOOL*)#1} const&>(a2, (uint64_t)&v12, &v15);
  v8 = v15;
  v15 = 0;
  v12 = v8;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v13, (uint64_t)v16);
  v14 = a2;
  std::unique_ptr<BOOL [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v15);
  std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100](a1 + 18, (uint64_t *)&v12);
  a1[23] = v14;
  return std::unique_ptr<BOOL [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v12);
}

void Phase::SpatialModeler::generateDirectionalMetadataLR(Phase::SpatialModeler::DirectivityHistogram *a1, int a2, uint64_t *a3, uint64_t a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12)
{
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void **v27;

  Phase::SpatialModeler::DirectivityHistogram::updateWasHitVector(a1);
  switch(a4)
  {
    case 31:
      v24 = 0;
      v25 = 0;
      v26 = 0;
      Phase::SpatialModeler::computePlaneWaveList_RayTracing<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>((uint64_t)a1, 1, 0xFFD9u, a2, &v24, a5, a6, a7, a8, a9, a10, a11, a12);
      Phase::SpatialModeler::convertRayTracingPlaneWaveListToDirectionalMetadata<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>((uint64_t)&v24, a3, 1);
      v27 = (void **)&v24;
      std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::__destroy_vector::operator()[abi:ne180100](&v27);
      break;
    case 10:
      v24 = 0;
      v25 = 0;
      v26 = 0;
      Phase::SpatialModeler::computePlaneWaveList_RayTracing<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>((uint64_t)a1, 1, 0xFFD9u, a2, &v24, a5, a6, a7, a8, a9, a10, a11, a12);
      Phase::SpatialModeler::convertRayTracingPlaneWaveListToDirectionalMetadata<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>((uint64_t)&v24, a3, 1);
      v27 = (void **)&v24;
      std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::__destroy_vector::operator()[abi:ne180100](&v27);
      break;
    case 3:
      v24 = 0;
      v25 = 0;
      v26 = 0;
      Phase::SpatialModeler::computePlaneWaveList_RayTracing<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>((uint64_t)a1, 1, 0xFFD9u, a2, &v24, a5, a6, a7, a8, a9, a10, a11, a12);
      Phase::SpatialModeler::convertRayTracingPlaneWaveListToDirectionalMetadata<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>((uint64_t)&v24, a3, 1);
      v27 = (void **)&v24;
      std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__destroy_vector::operator()[abi:ne180100](&v27);
      break;
  }
}

void sub_2165B0B5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::computePlaneWaveList_RayTracing<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(uint64_t a1, char a2, unsigned int a3, int a4, _QWORD *a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12, float a13)
{
  float v19;
  float v20;
  float v21;
  uint64_t i;
  Phase::Logger *v23;
  uint64_t v24;
  BOOL v25;
  _DWORD *v26;
  uint64_t v27;
  uint64_t v28;
  int *v29;
  NSObject *v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD *v34;
  uint64_t v35;
  int v36;
  int v37;
  unsigned int v38;
  float v39;
  float v40;
  void *v41;
  int *v42;
  int *v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  char *v48;
  int *v49;
  int v50;
  unsigned int v51;
  int *v52;
  unint64_t v53;
  unsigned int v54;
  int v55;
  BOOL v56;
  uint64_t v57;
  char *v58;
  char *v59;
  uint64_t v60;
  BOOL v61;
  _DWORD *v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  int *v67;
  NSObject *v68;
  unsigned int v69;
  char *v70;
  BOOL v71;
  float v72;
  uint64_t v73;
  float v74;
  unsigned int v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  int v79;
  int v80;
  int v81;
  float v82;
  float v83;
  float v84;
  uint64_t v85;
  uint64_t v86;
  float v87;
  float v88;
  float *v89;
  int v90;
  int v91;
  uint64_t v92;
  int v93;
  int v94;
  float v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  _QWORD *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  char *v104;
  _QWORD *v105;
  unint64_t v106;
  uint64_t v107;
  uint64_t v108;
  __int128 v109;
  int64x2_t v110;
  uint64_t v111;
  uint64_t j;
  void *v113;
  double v114;
  int v115;
  int v117;
  signed int v120;
  float v121;
  int v122;
  Phase::SpatialModeler::DirectivityHistogram *v126;
  float *v127;
  int *__p;
  int *v129;
  int *v130;
  uint64_t v131;
  void *v132;
  __int128 v133;
  _OWORD v134[4];
  uint64_t v135;
  _BYTE buf[32];
  _QWORD *v137;
  uint64_t v138;

  v138 = *MEMORY[0x24BDAC8D0];
  v19 = __exp10f(fabsf(a9) / -20.0);
  v20 = *(float *)(a1 + 16);
  if (*(float *)(a1 + 20) < a12)
    v21 = *(float *)(a1 + 20);
  else
    v21 = a12;
  v132 = 0;
  v133 = 0uLL;
  v130 = 0;
  v131 = 0;
  __p = 0;
  v129 = 0;
  v135 = 0;
  memset(v134, 0, sizeof(v134));
  v126 = (Phase::SpatialModeler::DirectivityHistogram *)a1;
  v115 = *(_DWORD *)(a1 + 28);
  if (v115 == 3)
    goto LABEL_25;
  for (i = 0; i != 72; i += 24)
    std::vector<float>::resize((uint64_t)v134 + i, 3uLL);
  v24 = *((unsigned int *)v126 + 7);
  if (*((_DWORD *)v126 + 6))
    v25 = *((_BYTE *)v126 + 36) == 0;
  else
    v25 = 0;
  if (v25)
    v26 = (_DWORD *)*((_QWORD *)v126 + 1);
  else
    v26 = &Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
  v27 = *(_QWORD *)&v134[0];
  switch((_DWORD)v24)
  {
    case 0x1F:
      v29 = &Phase::sThirdOctaveBandFrequencies;
      goto LABEL_19;
    case 0xA:
      v29 = (int *)Phase::sOctaveBandFrequencies;
LABEL_19:
      Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>((float *)v29, (float *)&v29[v24], (uint64_t)v26, (uint64_t)&v26[v24], Phase::sThreeBandFrequencies, Phase::sOctaveBandFrequencies, *(uint64_t *)&v134[0]);
      break;
    case 3:
      v28 = *(_QWORD *)v26;
      *(_DWORD *)(*(_QWORD *)&v134[0] + 8) = v26[2];
      *(_QWORD *)v27 = v28;
      break;
    default:
      if ((Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce & 1) == 0)
      {
        v30 = **(NSObject ***)(Phase::Logger::GetInstancePtr(v23) + 1184);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "GeneratePlaneWaveList.hpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 177;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v24;
          _os_log_impl(&dword_2164CC000, v30, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported subband count: %zu\n", buf, 0x1Cu);
        }
        Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce = 1;
      }
      *(_DWORD *)(v27 + 8) = 0;
      *(_QWORD *)v27 = 0;
      break;
  }
LABEL_25:
  v32 = (_QWORD *)*a5;
  v31 = a5[1];
  if (v31 != *a5)
  {
    v33 = (_QWORD *)(v31 - 32);
    v34 = (_QWORD *)(v31 - 32);
    do
    {
      v35 = *v34;
      v34 -= 4;
      (*(void (**)(_QWORD *))(v35 + 16))(v33);
      v25 = v33 == v32;
      v33 = v34;
    }
    while (!v25);
  }
  a5[1] = v32;
  if ((a2 & 1) == 0)
    a3 = time(0);
  srand(a3);
  v36 = vcvtps_u32_f32(a8 * a11);
  v120 = vcvtps_u32_f32(v21 * a8);
  v37 = v115;
  if (v36 < v120)
  {
    v38 = 0;
    v39 = v20 * a8;
    v114 = a7 * 12.5663706 * a7 * a7;
    v121 = 0.0;
    while (1)
    {
      if (v36 % 50 == 1)
      {
        v40 = a10;
        if (a6 >= 0.00000011921)
        {
          v40 = v114 * (float)((float)v36 / a8) * (float)((float)v36 / a8) / a6;
          if (v40 > a10)
            v40 = a10;
        }
        v121 = (float)(1.0 / a8) * v40;
      }
      v41 = (void *)rand();
      if ((float)((float)(int)v41 * 4.6566e-10) < v121)
      {
        v42 = v129;
        if (v129 >= v130)
        {
          v41 = __p;
          v44 = v129 - __p;
          v45 = v44 + 1;
          if ((unint64_t)(v44 + 1) >> 62)
            std::vector<int>::__throw_length_error[abi:ne180100]();
          v46 = (char *)v130 - (char *)__p;
          if (((char *)v130 - (char *)__p) >> 1 > v45)
            v45 = v46 >> 1;
          if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFFCLL)
            v47 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v47 = v45;
          if (v47)
          {
            v48 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v130, v47);
            v41 = __p;
            v42 = v129;
          }
          else
          {
            v48 = 0;
          }
          v49 = (int *)&v48[4 * v44];
          *v49 = v36;
          v43 = v49 + 1;
          while (v42 != v41)
          {
            v50 = *--v42;
            *--v49 = v50;
          }
          __p = v49;
          v130 = (int *)&v48[4 * v47];
          if (v41)
            operator delete(v41);
        }
        else
        {
          *v129 = v36;
          v43 = v129 + 1;
        }
        v129 = v43;
      }
      v51 = (int)(float)((float)v36 / v39);
      if ((int)v38 >= (int)v51)
        goto LABEL_166;
      v122 = (int)(float)((float)v36 / v39);
      if (v37 == 3)
      {
        v52 = __p;
        v53 = (unint64_t)((char *)v129 - (char *)__p) >> 2;
        if ((_DWORD)v53)
        {
          v54 = *((_DWORD *)v126 + 6);
          v55 = *((_DWORD *)v126 + 7);
          v56 = v54 > v38 && *((_BYTE *)v126 + 36) == 0;
          v57 = *((_QWORD *)v126 + 1);
          if (v56)
            v58 = (char *)(v57 + 4 * v55 * v38);
          else
            v58 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
          if ((int)v54 <= v122)
          {
            v66 = (char *)(v57 + 4 * v55 * (v54 - 1));
            if (!v54)
              v66 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            if (*((_BYTE *)v126 + 36))
              v59 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            else
              v59 = v66;
          }
          else if (*((_BYTE *)v126 + 36) || v54 <= v122)
          {
            v59 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
          }
          else
          {
            v59 = (char *)(v57 + 4 * (v55 * v122));
          }
LABEL_97:
          v69 = v38 - 1;
          if ((int)v38 < 1)
          {
            if (v37 == 3)
            {
              if (*((_BYTE *)v126 + 36))
                v71 = 1;
              else
                v71 = v54 == 0;
              if (v71)
                v70 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
              else
                v70 = (char *)*((_QWORD *)v126 + 1);
            }
            else
            {
              v70 = *(char **)&v134[0];
            }
          }
          else if (v37 == 3)
          {
            if (*((_BYTE *)v126 + 36))
            {
              v70 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            }
            else
            {
              v70 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
              if (v54 > v69)
                v70 = (char *)(*((_QWORD *)v126 + 1) + 4 * *((_DWORD *)v126 + 7) * v69);
            }
          }
          else
          {
            v70 = (char *)*((_QWORD *)v134 + 3 * (v69 % 3));
          }
          v72 = 1.0;
          if (v53 >= 2)
            v72 = sqrtf(1.0 / (float)v53);
          v73 = 0;
          v74 = v72 * a13;
          v75 = (float)((float)((float)(*((float *)v126 + 4) * (float)v38) * a8) + 0.5);
          while (*(float *)&v70[v73] <= 1.1755e-37
               && *(float *)&v58[v73] <= 1.1755e-37
               && *(float *)&v59[v73] <= 1.1755e-37)
          {
            v73 += 4;
            if (v73 == 12)
              goto LABEL_164;
          }
          v117 = v36;
          v76 = 0;
          v77 = v53;
          do
          {
            v78 = rand();
            if (v78 >= 0)
              v79 = v78 & 1;
            else
              v79 = -(v78 & 1);
            v80 = __p[v76];
            v81 = rand();
            v82 = (float)(v80 - v75) / v39;
            if (v82 < 0.0)
              v82 = 0.0;
            if (v82 <= 1.0)
              v83 = v82;
            else
              v83 = 1.0;
            std::vector<float>::vector(buf, 3uLL);
            v84 = (float)v81 * 4.6566e-10;
            v85 = *(_QWORD *)buf;
            v86 = 0;
            if (v83 >= 0.5)
            {
              v88 = (float)(v84 * (float)((float)(v83 + -0.5) + (float)(v83 + -0.5)))
                  * (float)(v84 * (float)((float)(v83 + -0.5) + (float)(v83 + -0.5)));
              do
              {
                *(float *)(v85 + v86) = (float)(v88 * *(float *)&v59[v86])
                                      + (float)((float)(1.0 - v88) * *(float *)&v58[v86]);
                v86 += 4;
              }
              while (v86 != 12);
            }
            else
            {
              v87 = (float)(v84 * (float)((float)(0.5 - v83) + (float)(0.5 - v83)))
                  * (float)(v84 * (float)((float)(0.5 - v83) + (float)(0.5 - v83)));
              do
              {
                *(float *)(v85 + v86) = (float)(v87 * *(float *)&v70[v86])
                                      + (float)((float)(1.0 - v87) * *(float *)&v58[v86]);
                v86 += 4;
              }
              while (v86 != 12);
            }
            if (v132)
              operator delete(v132);
            v89 = *(float **)buf;
            v132 = *(void **)buf;
            v127 = *(float **)&buf[8];
            v133 = *(_OWORD *)&buf[8];
            v90 = rand();
            v91 = rand();
            if (!Phase::SpatialModeler::DirectivityHistogram::findImpactAngle_TS(v126, v38, (float *)&v131 + 1, (float *)&v131, (float)v90 * 4.6566e-10, (float)v91 * 4.6566e-10))
            {
              v92 = 0;
              v93 = __p[v76];
              do
              {
                v89[v92] = v74 * (float)(sqrtf(v89[v92]) * (float)(2 * v79 - 1));
                ++v92;
              }
              while (v92 != 3);
              if (v89 != v127)
              {
                v94 = (v93 - a4) & ~((v93 - a4) >> 31);
                while (fabsf(*v89) <= v19)
                {
                  if (++v89 == v127)
                    goto LABEL_138;
                }
                v95 = (float)v94 / a8;
                v97 = a5[1];
                v96 = a5[2];
                if (v97 >= v96)
                {
                  v100 = (uint64_t)(v97 - *a5) >> 5;
                  if ((unint64_t)(v100 + 1) >> 59)
                    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
                  v101 = v96 - *a5;
                  v102 = v101 >> 4;
                  if (v101 >> 4 <= (unint64_t)(v100 + 1))
                    v102 = v100 + 1;
                  if ((unint64_t)v101 >= 0x7FFFFFFFFFFFFFE0)
                    v103 = 0x7FFFFFFFFFFFFFFLL;
                  else
                    v103 = v102;
                  v137 = a5 + 2;
                  if (v103)
                    v104 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::GraphDescriptionNode>>((uint64_t)(a5 + 2), v103);
                  else
                    v104 = 0;
                  *(_QWORD *)buf = v104;
                  *(_QWORD *)&buf[8] = &v104[32 * v100];
                  *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
                  *(_QWORD *)&buf[24] = &v104[32 * v103];
                  Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band::PhaseSpatialModelerMetadata_3Band(*(uint64_t *)&buf[8], (uint64_t *)&v132, *(float *)&v131, *((float *)&v131 + 1), v95);
                  v105 = (_QWORD *)*a5;
                  v106 = a5[1];
                  v107 = *(_QWORD *)&buf[8];
                  v108 = *(_QWORD *)&buf[16];
                  if (v106 == *a5)
                  {
                    v110 = vdupq_n_s64(v106);
                  }
                  else
                  {
                    do
                    {
                      *(_QWORD *)(v107 - 32) = off_24D57CBF8;
                      v107 -= 32;
                      v109 = *(_OWORD *)(v106 - 24);
                      *(_QWORD *)(v107 + 24) = *(_QWORD *)(v106 - 8);
                      *(_OWORD *)(v107 + 8) = v109;
                      v106 -= 32;
                    }
                    while ((_QWORD *)v106 != v105);
                    v110 = *(int64x2_t *)a5;
                  }
                  v99 = a5;
                  v98 = v108 + 32;
                  *a5 = v107;
                  a5[1] = v108 + 32;
                  *(int64x2_t *)&buf[8] = v110;
                  v111 = a5[2];
                  a5[2] = *(_QWORD *)&buf[24];
                  *(_QWORD *)&buf[24] = v111;
                  *(_QWORD *)buf = v110.i64[0];
                  std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::~__split_buffer((uint64_t)buf);
                }
                else
                {
                  Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band::PhaseSpatialModelerMetadata_3Band(a5[1], (uint64_t *)&v132, *(float *)&v131, *((float *)&v131 + 1), v95);
                  v98 = v97 + 32;
                  v99 = a5;
                  a5[1] = v97 + 32;
                }
                v99[1] = v98;
              }
            }
LABEL_138:
            ++v76;
          }
          while (v76 != v77);
          v52 = __p;
          v37 = v115;
          v36 = v117;
LABEL_164:
          v129 = v52;
          goto LABEL_165;
        }
        goto LABEL_165;
      }
      v60 = *((unsigned int *)v126 + 7);
      v61 = *((_DWORD *)v126 + 6) > v51 && *((_BYTE *)v126 + 36) == 0;
      v62 = v61
          ? (_DWORD *)(*((_QWORD *)v126 + 1) + 4 * v60 * v51)
          : &Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
      v63 = (uint64_t *)v134 + 3 * (v51 % 3);
      v64 = *v63;
      if ((_DWORD)v60 == 31)
        break;
      if ((_DWORD)v60 == 10)
      {
        v67 = (int *)Phase::sOctaveBandFrequencies;
LABEL_86:
        Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>((float *)v67, (float *)&v67[v60], (uint64_t)v62, (uint64_t)&v62[v60], Phase::sThreeBandFrequencies, Phase::sOctaveBandFrequencies, *v63);
        goto LABEL_92;
      }
      if ((_DWORD)v60 == 3)
      {
        v65 = *(_QWORD *)v62;
        *(_DWORD *)(v64 + 8) = v62[2];
        *(_QWORD *)v64 = v65;
      }
      else
      {
        if ((Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce & 1) == 0)
        {
          v68 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)v41) + 1184);
          if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "GeneratePlaneWaveList.hpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 177;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v60;
            _os_log_impl(&dword_2164CC000, v68, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported subband count: %zu\n", buf, 0x1Cu);
          }
          Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce = 1;
        }
        *(_DWORD *)(v64 + 8) = 0;
        *(_QWORD *)v64 = 0;
      }
LABEL_92:
      v52 = __p;
      v53 = (unint64_t)((char *)v129 - (char *)__p) >> 2;
      if ((_DWORD)v53)
      {
        v58 = (char *)*((_QWORD *)v134 + 3 * (v38 % 3));
        v54 = *((_DWORD *)v126 + 6);
        if ((int)v54 <= v122)
          v59 = (char *)*((_QWORD *)v134 + 3 * ((v54 - 1) % 3));
        else
          v59 = (char *)*v63;
        goto LABEL_97;
      }
LABEL_165:
      v38 = v122;
LABEL_166:
      if (++v36 == v120)
        goto LABEL_167;
    }
    v67 = &Phase::sThirdOctaveBandFrequencies;
    goto LABEL_86;
  }
LABEL_167:
  for (j = 0; j != -72; j -= 24)
  {
    v113 = *(void **)((char *)&v134[3] + j);
    if (v113)
    {
      *(_QWORD *)((char *)&v134[3] + j + 8) = v113;
      operator delete(v113);
    }
  }
  if (__p)
    operator delete(__p);
  if (v132)
    operator delete(v132);
}

void sub_2165B1720(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,char a33)
{
  uint64_t v34;
  void *v35;

  v34 = 0;
  while (1)
  {
    v35 = *(void **)(&a33 + v34 + 48);
    if (v35)
    {
      *(_QWORD *)(&a33 + v34 + 56) = v35;
      operator delete(v35);
    }
    v34 -= 24;
    if (v34 == -72)
    {
      if (__p)
        operator delete(__p);
      if (a30)
        operator delete(a30);
      _Unwind_Resume(exception_object);
    }
  }
}

uint64_t Phase::SpatialModeler::convertRayTracingPlaneWaveListToDirectionalMetadata<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(uint64_t result, uint64_t *a2, char a3)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float *v18;
  uint64_t v19;
  float v20;
  float v21;
  uint64_t v22;
  uint64_t v23;
  float *v24;
  float *v25;
  uint64_t v26;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;

  if (a2)
  {
    v3 = (uint64_t *)result;
    result = *(_QWORD *)result;
    v4 = v3[1];
    if (result != v4)
    {
      v6 = (v4 - result) >> 5;
      v7 = (**(uint64_t (***)(uint64_t))result)(result);
      Phase::SpatialModeler::AllocMetadata<float>(a2, v6, (int)v7);
      v8 = 0;
      v9 = *v3;
      v10 = a2[1];
      v11 = a2[7];
      v12 = a2[18];
      v28 = a2;
      v13 = a2[13];
      v14 = (float *)(v13 + 16);
      if (v6 <= 1)
        v15 = 1;
      else
        v15 = v6;
      v16 = v7;
      v17 = 4 * *(_QWORD *)(v13 + 8);
      v18 = (float *)(v9 + 20);
      result = 1127481344;
      v29 = v17;
      v30 = v9;
      do
      {
        v19 = v9 + 32 * v8;
        v20 = *(float *)(v19 + 8);
        v21 = (float)((float)(180.0 - *(float *)(v19 + 12))
                    - (float)(floorf((float)(180.0 - *(float *)(v19 + 12)) / 360.0) * 360.0))
            + 0.0;
        if (v21 >= 360.0)
        {
          v22 = v15;
          v21 = nextafterf(360.0, 0.0);
          result = 1127481344;
          v17 = v29;
          v9 = v30;
          v15 = v22;
        }
        v23 = v10 + 12 * v8;
        *(_DWORD *)v23 = 1065353216;
        *(float *)(v23 + 4) = 90.0 - v20;
        *(float *)(v23 + 8) = v21;
        *(_DWORD *)(v11 + 4 * v8) = *(_DWORD *)(v19 + 16);
        *(_BYTE *)(v12 + v8) = 0;
        v24 = v18;
        v25 = v14;
        v26 = v16;
        if ((int)v16 >= 1)
        {
          do
          {
            *v25 = fabsf(*v24);
            if (*v24 < 0.0)
              *(_BYTE *)(v12 + v8) = 1;
            ++v25;
            ++v24;
            --v26;
          }
          while (v26);
        }
        ++v8;
        v14 = (float *)((char *)v14 + v17);
        v18 += 8;
      }
      while (v8 != v15);
      *((_BYTE *)v28 + 201) = a3;
      *((_DWORD *)v28 + 51) = 0;
    }
  }
  return result;
}

void Phase::SpatialModeler::computePlaneWaveList_RayTracing<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(uint64_t a1, char a2, unsigned int a3, int a4, _QWORD *a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12, float a13)
{
  float v19;
  float v20;
  float v21;
  uint64_t i;
  Phase::Logger *v23;
  uint64_t v24;
  BOOL v25;
  _OWORD *v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  float *v30;
  NSObject *v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t v36;
  int v37;
  int v38;
  unsigned int v39;
  float v40;
  float v41;
  void *v42;
  int *v43;
  int *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  int *v50;
  int v51;
  unsigned int v52;
  int *v53;
  unint64_t v54;
  unsigned int v55;
  int v56;
  BOOL v57;
  uint64_t v58;
  char *v59;
  char *v60;
  uint64_t v61;
  BOOL v62;
  _OWORD *v63;
  uint64_t *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  char *v68;
  float *v69;
  NSObject *v70;
  unsigned int v71;
  char *v72;
  BOOL v73;
  float v74;
  uint64_t v75;
  float v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  int v82;
  int v83;
  float v84;
  float v85;
  float v86;
  uint64_t v87;
  uint64_t v88;
  float v89;
  float v90;
  float *v91;
  int v92;
  int v93;
  uint64_t v94;
  int v95;
  int v96;
  float v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  _QWORD *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  char *v106;
  _QWORD *v107;
  unint64_t v108;
  uint64_t v109;
  uint64_t v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  int64x2_t v114;
  uint64_t v115;
  uint64_t j;
  void *v117;
  double v118;
  int v119;
  int v121;
  signed int v124;
  float v125;
  int v126;
  Phase::SpatialModeler::DirectivityHistogram *v130;
  float *v131;
  int *__p;
  int *v133;
  int *v134;
  uint64_t v135;
  void *v136;
  __int128 v137;
  _OWORD v138[4];
  uint64_t v139;
  _BYTE buf[32];
  _QWORD *v141;
  uint64_t v142;

  v142 = *MEMORY[0x24BDAC8D0];
  v19 = __exp10f(fabsf(a9) / -20.0);
  v20 = *(float *)(a1 + 16);
  if (*(float *)(a1 + 20) < a12)
    v21 = *(float *)(a1 + 20);
  else
    v21 = a12;
  v136 = 0;
  v137 = 0uLL;
  v134 = 0;
  v135 = 0;
  __p = 0;
  v133 = 0;
  v139 = 0;
  memset(v138, 0, sizeof(v138));
  v130 = (Phase::SpatialModeler::DirectivityHistogram *)a1;
  v119 = *(_DWORD *)(a1 + 28);
  if (v119 == 10)
    goto LABEL_26;
  for (i = 0; i != 72; i += 24)
    std::vector<float>::resize((uint64_t)v138 + i, 0xAuLL);
  v24 = *((unsigned int *)v130 + 7);
  if (*((_DWORD *)v130 + 6))
    v25 = *((_BYTE *)v130 + 36) == 0;
  else
    v25 = 0;
  if (v25)
    v26 = (_OWORD *)*((_QWORD *)v130 + 1);
  else
    v26 = &Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
  v27 = *(_QWORD *)&v138[0];
  switch((_DWORD)v24)
  {
    case 3:
      v30 = Phase::sThreeBandFrequencies;
      goto LABEL_19;
    case 0x1F:
      v30 = Phase::sThirdOctaveBandFrequencies;
LABEL_19:
      Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>(v30, &v30[v24], (uint64_t)v26, (uint64_t)v26 + 4 * v24, Phase::sOctaveBandFrequencies, Phase::sThirdOctaveBandFrequencies, *(uint64_t *)&v138[0]);
      goto LABEL_26;
    case 0xA:
      v28 = *v26;
      v29 = v26[1];
      *(_QWORD *)(*(_QWORD *)&v138[0] + 32) = *((_QWORD *)v26 + 4);
      *(_OWORD *)(v27 + 16) = v29;
      break;
    default:
      if ((Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce & 1) == 0)
      {
        v31 = **(NSObject ***)(Phase::Logger::GetInstancePtr(v23) + 1184);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "GeneratePlaneWaveList.hpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 177;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v24;
          _os_log_impl(&dword_2164CC000, v31, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported subband count: %zu\n", buf, 0x1Cu);
        }
        Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce = 1;
      }
      *(_QWORD *)(v27 + 32) = 0;
      v28 = 0uLL;
      *(_OWORD *)(v27 + 16) = 0u;
      break;
  }
  *(_OWORD *)v27 = v28;
LABEL_26:
  v33 = (_QWORD *)*a5;
  v32 = a5[1];
  if (v32 != *a5)
  {
    v34 = (_QWORD *)(v32 - 64);
    v35 = (_QWORD *)(v32 - 64);
    do
    {
      v36 = *v35;
      v35 -= 8;
      (*(void (**)(_QWORD *))(v36 + 16))(v34);
      v25 = v34 == v33;
      v34 = v35;
    }
    while (!v25);
  }
  a5[1] = v33;
  if ((a2 & 1) == 0)
    a3 = time(0);
  srand(a3);
  v37 = vcvtps_u32_f32(a8 * a11);
  v124 = vcvtps_u32_f32(v21 * a8);
  v38 = v119;
  if (v37 < v124)
  {
    v39 = 0;
    v40 = v20 * a8;
    v118 = a7 * 12.5663706 * a7 * a7;
    v125 = 0.0;
    while (1)
    {
      if (v37 % 50 == 1)
      {
        v41 = a10;
        if (a6 >= 0.00000011921)
        {
          v41 = v118 * (float)((float)v37 / a8) * (float)((float)v37 / a8) / a6;
          if (v41 > a10)
            v41 = a10;
        }
        v125 = (float)(1.0 / a8) * v41;
      }
      v42 = (void *)rand();
      if ((float)((float)(int)v42 * 4.6566e-10) < v125)
      {
        v43 = v133;
        if (v133 >= v134)
        {
          v42 = __p;
          v45 = v133 - __p;
          v46 = v45 + 1;
          if ((unint64_t)(v45 + 1) >> 62)
            std::vector<int>::__throw_length_error[abi:ne180100]();
          v47 = (char *)v134 - (char *)__p;
          if (((char *)v134 - (char *)__p) >> 1 > v46)
            v46 = v47 >> 1;
          if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL)
            v48 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v48 = v46;
          if (v48)
          {
            v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v134, v48);
            v42 = __p;
            v43 = v133;
          }
          else
          {
            v49 = 0;
          }
          v50 = (int *)&v49[4 * v45];
          *v50 = v37;
          v44 = v50 + 1;
          while (v43 != v42)
          {
            v51 = *--v43;
            *--v50 = v51;
          }
          __p = v50;
          v134 = (int *)&v49[4 * v48];
          if (v42)
            operator delete(v42);
        }
        else
        {
          *v133 = v37;
          v44 = v133 + 1;
        }
        v133 = v44;
      }
      v52 = (int)(float)((float)v37 / v40);
      if ((int)v39 >= (int)v52)
        goto LABEL_168;
      v126 = (int)(float)((float)v37 / v40);
      if (v38 == 10)
      {
        v53 = __p;
        v54 = (unint64_t)((char *)v133 - (char *)__p) >> 2;
        if ((_DWORD)v54)
        {
          v55 = *((_DWORD *)v130 + 6);
          v56 = *((_DWORD *)v130 + 7);
          v57 = v55 > v39 && *((_BYTE *)v130 + 36) == 0;
          v58 = *((_QWORD *)v130 + 1);
          if (v57)
            v59 = (char *)(v58 + 4 * v56 * v39);
          else
            v59 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
          if ((int)v55 <= v126)
          {
            v68 = (char *)(v58 + 4 * v56 * (v55 - 1));
            if (!v55)
              v68 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            if (*((_BYTE *)v130 + 36))
              v60 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            else
              v60 = v68;
          }
          else if (*((_BYTE *)v130 + 36) || v55 <= v126)
          {
            v60 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
          }
          else
          {
            v60 = (char *)(v58 + 4 * (v56 * v126));
          }
LABEL_99:
          v71 = v39 - 1;
          if ((int)v39 < 1)
          {
            if (v38 == 10)
            {
              if (*((_BYTE *)v130 + 36))
                v73 = 1;
              else
                v73 = v55 == 0;
              if (v73)
                v72 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
              else
                v72 = (char *)*((_QWORD *)v130 + 1);
            }
            else
            {
              v72 = *(char **)&v138[0];
            }
          }
          else if (v38 == 10)
          {
            if (*((_BYTE *)v130 + 36))
            {
              v72 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            }
            else
            {
              v72 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
              if (v55 > v71)
                v72 = (char *)(*((_QWORD *)v130 + 1) + 4 * *((_DWORD *)v130 + 7) * v71);
            }
          }
          else
          {
            v72 = (char *)*((_QWORD *)v138 + 3 * (v71 % 3));
          }
          v74 = 1.0;
          if (v54 >= 2)
            v74 = sqrtf(1.0 / (float)v54);
          v75 = 0;
          v76 = v74 * a13;
          v77 = (float)((float)((float)(*((float *)v130 + 4) * (float)v39) * a8) + 0.5);
          while (*(float *)&v72[v75] <= 1.1755e-37
               && *(float *)&v59[v75] <= 1.1755e-37
               && *(float *)&v60[v75] <= 1.1755e-37)
          {
            v75 += 4;
            if (v75 == 40)
              goto LABEL_166;
          }
          v121 = v37;
          v78 = 0;
          v79 = v54;
          do
          {
            v80 = rand();
            if (v80 >= 0)
              v81 = v80 & 1;
            else
              v81 = -(v80 & 1);
            v82 = __p[v78];
            v83 = rand();
            v84 = (float)(v82 - v77) / v40;
            if (v84 < 0.0)
              v84 = 0.0;
            if (v84 <= 1.0)
              v85 = v84;
            else
              v85 = 1.0;
            std::vector<float>::vector(buf, 0xAuLL);
            v86 = (float)v83 * 4.6566e-10;
            v87 = *(_QWORD *)buf;
            v88 = 0;
            if (v85 >= 0.5)
            {
              v90 = (float)(v86 * (float)((float)(v85 + -0.5) + (float)(v85 + -0.5)))
                  * (float)(v86 * (float)((float)(v85 + -0.5) + (float)(v85 + -0.5)));
              do
              {
                *(float *)(v87 + v88) = (float)(v90 * *(float *)&v60[v88])
                                      + (float)((float)(1.0 - v90) * *(float *)&v59[v88]);
                v88 += 4;
              }
              while (v88 != 40);
            }
            else
            {
              v89 = (float)(v86 * (float)((float)(0.5 - v85) + (float)(0.5 - v85)))
                  * (float)(v86 * (float)((float)(0.5 - v85) + (float)(0.5 - v85)));
              do
              {
                *(float *)(v87 + v88) = (float)(v89 * *(float *)&v72[v88])
                                      + (float)((float)(1.0 - v89) * *(float *)&v59[v88]);
                v88 += 4;
              }
              while (v88 != 40);
            }
            if (v136)
              operator delete(v136);
            v91 = *(float **)buf;
            v136 = *(void **)buf;
            v131 = *(float **)&buf[8];
            v137 = *(_OWORD *)&buf[8];
            v92 = rand();
            v93 = rand();
            if (!Phase::SpatialModeler::DirectivityHistogram::findImpactAngle_TS(v130, v39, (float *)&v135 + 1, (float *)&v135, (float)v92 * 4.6566e-10, (float)v93 * 4.6566e-10))
            {
              v94 = 0;
              v95 = __p[v78];
              do
              {
                v91[v94] = v76 * (float)(sqrtf(v91[v94]) * (float)(2 * v81 - 1));
                ++v94;
              }
              while (v94 != 10);
              if (v91 != v131)
              {
                v96 = (v95 - a4) & ~((v95 - a4) >> 31);
                while (fabsf(*v91) <= v19)
                {
                  if (++v91 == v131)
                    goto LABEL_140;
                }
                v97 = (float)v96 / a8;
                v99 = a5[1];
                v98 = a5[2];
                if (v99 >= v98)
                {
                  v102 = (uint64_t)(v99 - *a5) >> 6;
                  if ((unint64_t)(v102 + 1) >> 58)
                    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
                  v103 = v98 - *a5;
                  v104 = v103 >> 5;
                  if (v103 >> 5 <= (unint64_t)(v102 + 1))
                    v104 = v102 + 1;
                  if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFC0)
                    v105 = 0x3FFFFFFFFFFFFFFLL;
                  else
                    v105 = v104;
                  v141 = a5 + 2;
                  if (v105)
                    v106 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Envelope<double>::SegmentInternal>>((uint64_t)(a5 + 2), v105);
                  else
                    v106 = 0;
                  *(_QWORD *)buf = v106;
                  *(_QWORD *)&buf[8] = &v106[64 * v102];
                  *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
                  *(_QWORD *)&buf[24] = &v106[64 * v105];
                  Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave::PhaseSpatialModelerMetadata_Octave(*(uint64_t *)&buf[8], (uint64_t)&v136, *(float *)&v135, *((float *)&v135 + 1), v97);
                  v107 = (_QWORD *)*a5;
                  v108 = a5[1];
                  v109 = *(_QWORD *)&buf[8];
                  v110 = *(_QWORD *)&buf[16];
                  if (v108 == *a5)
                  {
                    v114 = vdupq_n_s64(v108);
                  }
                  else
                  {
                    do
                    {
                      *(_QWORD *)(v109 - 64) = off_24D57CC28;
                      v109 -= 64;
                      v111 = *(_OWORD *)(v108 - 56);
                      v112 = *(_OWORD *)(v108 - 40);
                      v113 = *(_OWORD *)(v108 - 24);
                      *(_DWORD *)(v109 + 56) = *(_DWORD *)(v108 - 8);
                      *(_OWORD *)(v109 + 40) = v113;
                      *(_OWORD *)(v109 + 24) = v112;
                      *(_OWORD *)(v109 + 8) = v111;
                      v108 -= 64;
                    }
                    while ((_QWORD *)v108 != v107);
                    v114 = *(int64x2_t *)a5;
                  }
                  v101 = a5;
                  v100 = v110 + 64;
                  *a5 = v109;
                  a5[1] = v110 + 64;
                  *(int64x2_t *)&buf[8] = v114;
                  v115 = a5[2];
                  a5[2] = *(_QWORD *)&buf[24];
                  *(_QWORD *)&buf[24] = v115;
                  *(_QWORD *)buf = v114.i64[0];
                  std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::~__split_buffer((uint64_t)buf);
                }
                else
                {
                  Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave::PhaseSpatialModelerMetadata_Octave(a5[1], (uint64_t)&v136, *(float *)&v135, *((float *)&v135 + 1), v97);
                  v100 = v99 + 64;
                  v101 = a5;
                  a5[1] = v99 + 64;
                }
                v101[1] = v100;
              }
            }
LABEL_140:
            ++v78;
          }
          while (v78 != v79);
          v53 = __p;
          v38 = v119;
          v37 = v121;
LABEL_166:
          v133 = v53;
          goto LABEL_167;
        }
        goto LABEL_167;
      }
      v61 = *((unsigned int *)v130 + 7);
      v62 = *((_DWORD *)v130 + 6) > v52 && *((_BYTE *)v130 + 36) == 0;
      v63 = v62
          ? (_OWORD *)(*((_QWORD *)v130 + 1) + 4 * v61 * v52)
          : &Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
      v64 = (uint64_t *)v138 + 3 * (v52 % 3);
      v65 = *v64;
      if ((_DWORD)v61 == 3)
        break;
      if ((_DWORD)v61 == 31)
      {
        v69 = Phase::sThirdOctaveBandFrequencies;
LABEL_87:
        Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>(v69, &v69[v61], (uint64_t)v63, (uint64_t)v63 + 4 * v61, Phase::sOctaveBandFrequencies, Phase::sThirdOctaveBandFrequencies, *v64);
        goto LABEL_94;
      }
      if ((_DWORD)v61 == 10)
      {
        v66 = *v63;
        v67 = v63[1];
        *(_QWORD *)(v65 + 32) = *((_QWORD *)v63 + 4);
        *(_OWORD *)(v65 + 16) = v67;
      }
      else
      {
        if ((Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce & 1) == 0)
        {
          v70 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)v42) + 1184);
          if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "GeneratePlaneWaveList.hpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 177;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v61;
            _os_log_impl(&dword_2164CC000, v70, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported subband count: %zu\n", buf, 0x1Cu);
          }
          Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce = 1;
        }
        *(_QWORD *)(v65 + 32) = 0;
        v66 = 0uLL;
        *(_OWORD *)(v65 + 16) = 0u;
      }
      *(_OWORD *)v65 = v66;
LABEL_94:
      v53 = __p;
      v54 = (unint64_t)((char *)v133 - (char *)__p) >> 2;
      if ((_DWORD)v54)
      {
        v59 = (char *)*((_QWORD *)v138 + 3 * (v39 % 3));
        v55 = *((_DWORD *)v130 + 6);
        if ((int)v55 <= v126)
          v60 = (char *)*((_QWORD *)v138 + 3 * ((v55 - 1) % 3));
        else
          v60 = (char *)*v64;
        goto LABEL_99;
      }
LABEL_167:
      v39 = v126;
LABEL_168:
      if (++v37 == v124)
        goto LABEL_169;
    }
    v69 = Phase::sThreeBandFrequencies;
    goto LABEL_87;
  }
LABEL_169:
  for (j = 0; j != -72; j -= 24)
  {
    v117 = *(void **)((char *)&v138[3] + j);
    if (v117)
    {
      *(_QWORD *)((char *)&v138[3] + j + 8) = v117;
      operator delete(v117);
    }
  }
  if (__p)
    operator delete(__p);
  if (v136)
    operator delete(v136);
}

void sub_2165B251C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,char a33)
{
  uint64_t v34;
  void *v35;

  v34 = 0;
  while (1)
  {
    v35 = *(void **)(&a33 + v34 + 48);
    if (v35)
    {
      *(_QWORD *)(&a33 + v34 + 56) = v35;
      operator delete(v35);
    }
    v34 -= 24;
    if (v34 == -72)
    {
      if (__p)
        operator delete(__p);
      if (a30)
        operator delete(a30);
      _Unwind_Resume(exception_object);
    }
  }
}

uint64_t Phase::SpatialModeler::convertRayTracingPlaneWaveListToDirectionalMetadata<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(uint64_t result, uint64_t *a2, char a3)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float *v18;
  uint64_t v19;
  float v20;
  float v21;
  uint64_t v22;
  uint64_t v23;
  float *v24;
  float *v25;
  uint64_t v26;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;

  if (a2)
  {
    v3 = (uint64_t *)result;
    result = *(_QWORD *)result;
    v4 = v3[1];
    if (result != v4)
    {
      v6 = (v4 - result) >> 6;
      v7 = (**(uint64_t (***)(uint64_t))result)(result);
      Phase::SpatialModeler::AllocMetadata<float>(a2, v6, (int)v7);
      v8 = 0;
      v9 = *v3;
      v10 = a2[1];
      v11 = a2[7];
      v12 = a2[18];
      v28 = a2;
      v13 = a2[13];
      v14 = (float *)(v13 + 16);
      if (v6 <= 1)
        v15 = 1;
      else
        v15 = v6;
      v16 = v7;
      v17 = 4 * *(_QWORD *)(v13 + 8);
      v18 = (float *)(v9 + 20);
      result = 1127481344;
      v29 = v17;
      v30 = v9;
      do
      {
        v19 = v9 + (v8 << 6);
        v20 = *(float *)(v19 + 8);
        v21 = (float)((float)(180.0 - *(float *)(v19 + 12))
                    - (float)(floorf((float)(180.0 - *(float *)(v19 + 12)) / 360.0) * 360.0))
            + 0.0;
        if (v21 >= 360.0)
        {
          v22 = v15;
          v21 = nextafterf(360.0, 0.0);
          result = 1127481344;
          v17 = v29;
          v9 = v30;
          v15 = v22;
        }
        v23 = v10 + 12 * v8;
        *(_DWORD *)v23 = 1065353216;
        *(float *)(v23 + 4) = 90.0 - v20;
        *(float *)(v23 + 8) = v21;
        *(_DWORD *)(v11 + 4 * v8) = *(_DWORD *)(v19 + 16);
        *(_BYTE *)(v12 + v8) = 0;
        v24 = v18;
        v25 = v14;
        v26 = v16;
        if ((int)v16 >= 1)
        {
          do
          {
            *v25 = fabsf(*v24);
            if (*v24 < 0.0)
              *(_BYTE *)(v12 + v8) = 1;
            ++v25;
            ++v24;
            --v26;
          }
          while (v26);
        }
        ++v8;
        v14 = (float *)((char *)v14 + v17);
        v18 += 16;
      }
      while (v8 != v15);
      *((_BYTE *)v28 + 201) = a3;
      *((_DWORD *)v28 + 51) = 0;
    }
  }
  return result;
}

void Phase::SpatialModeler::computePlaneWaveList_RayTracing<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(uint64_t a1, char a2, unsigned int a3, int a4, _QWORD *a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12, float a13)
{
  float v19;
  float v20;
  float v21;
  uint64_t i;
  Phase::Logger *v23;
  uint64_t v24;
  BOOL v25;
  __int128 *v26;
  _OWORD *v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  float *v34;
  NSObject *v35;
  uint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  uint64_t v40;
  int v41;
  int v42;
  unsigned int v43;
  float v44;
  float v45;
  void *v46;
  int *v47;
  int *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char *v53;
  int *v54;
  int v55;
  unsigned int v56;
  int *v57;
  unint64_t v58;
  unsigned int v59;
  int v60;
  BOOL v61;
  uint64_t v62;
  char *v63;
  char *v64;
  uint64_t v65;
  BOOL v66;
  __int128 *v67;
  uint64_t *v68;
  _OWORD *v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  char *v76;
  float *v77;
  NSObject *v78;
  unsigned int v79;
  char *v80;
  BOOL v81;
  float v82;
  uint64_t v83;
  float v84;
  unsigned int v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  int v89;
  int v90;
  int v91;
  float v92;
  float v93;
  float v94;
  uint64_t v95;
  uint64_t v96;
  float v97;
  float v98;
  float *v99;
  int v100;
  int v101;
  uint64_t v102;
  int v103;
  int v104;
  float v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  _QWORD *v109;
  unint64_t v110;
  unint64_t v111;
  unint64_t v112;
  unint64_t v113;
  char *v114;
  _QWORD *v115;
  unint64_t v116;
  uint64_t v117;
  uint64_t v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  int64x2_t v125;
  uint64_t v126;
  uint64_t j;
  void *v128;
  double v129;
  int v130;
  int v132;
  signed int v135;
  float v136;
  int v137;
  Phase::SpatialModeler::DirectivityHistogram *v141;
  float *v142;
  int *__p;
  int *v144;
  int *v145;
  uint64_t v146;
  void *v147;
  __int128 v148;
  _OWORD v149[4];
  uint64_t v150;
  _BYTE buf[32];
  _QWORD *v152;
  uint64_t v153;

  v153 = *MEMORY[0x24BDAC8D0];
  v19 = __exp10f(fabsf(a9) / -20.0);
  v20 = *(float *)(a1 + 16);
  if (*(float *)(a1 + 20) < a12)
    v21 = *(float *)(a1 + 20);
  else
    v21 = a12;
  v147 = 0;
  v148 = 0uLL;
  v145 = 0;
  v146 = 0;
  __p = 0;
  v144 = 0;
  v150 = 0;
  memset(v149, 0, sizeof(v149));
  v141 = (Phase::SpatialModeler::DirectivityHistogram *)a1;
  v130 = *(_DWORD *)(a1 + 28);
  if (v130 == 31)
    goto LABEL_25;
  for (i = 0; i != 72; i += 24)
    std::vector<float>::resize((uint64_t)v149 + i, 0x1FuLL);
  v24 = *((unsigned int *)v141 + 7);
  if (*((_DWORD *)v141 + 6))
    v25 = *((_BYTE *)v141 + 36) == 0;
  else
    v25 = 0;
  if (v25)
    v26 = (__int128 *)*((_QWORD *)v141 + 1);
  else
    v26 = (__int128 *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
  v27 = *(_OWORD **)&v149[0];
  switch((_DWORD)v24)
  {
    case 3:
      v34 = Phase::sThreeBandFrequencies;
      goto LABEL_19;
    case 0xA:
      v34 = Phase::sOctaveBandFrequencies;
LABEL_19:
      Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>(v34, &v34[v24], (uint64_t)v26, (uint64_t)v26 + 4 * v24, Phase::sThirdOctaveBandFrequencies, (float *)&jpt_2165B70F0, *(uint64_t *)&v149[0]);
      break;
    case 0x1F:
      v28 = *v26;
      v29 = v26[1];
      v30 = v26[3];
      *(_OWORD *)(*(_QWORD *)&v149[0] + 32) = v26[2];
      v27[3] = v30;
      *v27 = v28;
      v27[1] = v29;
      v31 = v26[4];
      v32 = v26[5];
      v33 = v26[6];
      *(_OWORD *)((char *)v27 + 108) = *(__int128 *)((char *)v26 + 108);
      v27[5] = v32;
      v27[6] = v33;
      v27[4] = v31;
      break;
    default:
      if ((Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce & 1) == 0)
      {
        v35 = **(NSObject ***)(Phase::Logger::GetInstancePtr(v23) + 1184);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "GeneratePlaneWaveList.hpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 177;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v24;
          _os_log_impl(&dword_2164CC000, v35, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported subband count: %zu\n", buf, 0x1Cu);
        }
        Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce = 1;
      }
      *(_OWORD *)((char *)v27 + 108) = 0u;
      v27[5] = 0u;
      v27[6] = 0u;
      v27[3] = 0u;
      v27[4] = 0u;
      v27[1] = 0u;
      v27[2] = 0u;
      *v27 = 0u;
      break;
  }
LABEL_25:
  v37 = (_QWORD *)*a5;
  v36 = a5[1];
  if (v36 != *a5)
  {
    v38 = (_QWORD *)(v36 - 144);
    v39 = (_QWORD *)(v36 - 144);
    do
    {
      v40 = *v39;
      v39 -= 18;
      (*(void (**)(_QWORD *))(v40 + 16))(v38);
      v25 = v38 == v37;
      v38 = v39;
    }
    while (!v25);
  }
  a5[1] = v37;
  if ((a2 & 1) == 0)
    a3 = time(0);
  srand(a3);
  v41 = vcvtps_u32_f32(a8 * a11);
  v135 = vcvtps_u32_f32(v21 * a8);
  v42 = v130;
  if (v41 < v135)
  {
    v43 = 0;
    v44 = v20 * a8;
    v129 = a7 * 12.5663706 * a7 * a7;
    v136 = 0.0;
    while (1)
    {
      if (v41 % 50 == 1)
      {
        v45 = a10;
        if (a6 >= 0.00000011921)
        {
          v45 = v129 * (float)((float)v41 / a8) * (float)((float)v41 / a8) / a6;
          if (v45 > a10)
            v45 = a10;
        }
        v136 = (float)(1.0 / a8) * v45;
      }
      v46 = (void *)rand();
      if ((float)((float)(int)v46 * 4.6566e-10) < v136)
      {
        v47 = v144;
        if (v144 >= v145)
        {
          v46 = __p;
          v49 = v144 - __p;
          v50 = v49 + 1;
          if ((unint64_t)(v49 + 1) >> 62)
            std::vector<int>::__throw_length_error[abi:ne180100]();
          v51 = (char *)v145 - (char *)__p;
          if (((char *)v145 - (char *)__p) >> 1 > v50)
            v50 = v51 >> 1;
          if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFFCLL)
            v52 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v52 = v50;
          if (v52)
          {
            v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v145, v52);
            v46 = __p;
            v47 = v144;
          }
          else
          {
            v53 = 0;
          }
          v54 = (int *)&v53[4 * v49];
          *v54 = v41;
          v48 = v54 + 1;
          while (v47 != v46)
          {
            v55 = *--v47;
            *--v54 = v55;
          }
          __p = v54;
          v145 = (int *)&v53[4 * v52];
          if (v46)
            operator delete(v46);
        }
        else
        {
          *v144 = v41;
          v48 = v144 + 1;
        }
        v144 = v48;
      }
      v56 = (int)(float)((float)v41 / v44);
      if ((int)v43 >= (int)v56)
        goto LABEL_166;
      v137 = (int)(float)((float)v41 / v44);
      if (v42 == 31)
      {
        v57 = __p;
        v58 = (unint64_t)((char *)v144 - (char *)__p) >> 2;
        if ((_DWORD)v58)
        {
          v59 = *((_DWORD *)v141 + 6);
          v60 = *((_DWORD *)v141 + 7);
          v61 = v59 > v43 && *((_BYTE *)v141 + 36) == 0;
          v62 = *((_QWORD *)v141 + 1);
          if (v61)
            v63 = (char *)(v62 + 4 * v60 * v43);
          else
            v63 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
          if ((int)v59 <= v137)
          {
            v76 = (char *)(v62 + 4 * v60 * (v59 - 1));
            if (!v59)
              v76 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            if (*((_BYTE *)v141 + 36))
              v64 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            else
              v64 = v76;
          }
          else if (*((_BYTE *)v141 + 36) || v59 <= v137)
          {
            v64 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
          }
          else
          {
            v64 = (char *)(v62 + 4 * (v60 * v137));
          }
LABEL_97:
          v79 = v43 - 1;
          if ((int)v43 < 1)
          {
            if (v42 == 31)
            {
              if (*((_BYTE *)v141 + 36))
                v81 = 1;
              else
                v81 = v59 == 0;
              if (v81)
                v80 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
              else
                v80 = (char *)*((_QWORD *)v141 + 1);
            }
            else
            {
              v80 = *(char **)&v149[0];
            }
          }
          else if (v42 == 31)
          {
            if (*((_BYTE *)v141 + 36))
            {
              v80 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            }
            else
            {
              v80 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
              if (v59 > v79)
                v80 = (char *)(*((_QWORD *)v141 + 1) + 4 * *((_DWORD *)v141 + 7) * v79);
            }
          }
          else
          {
            v80 = (char *)*((_QWORD *)v149 + 3 * (v79 % 3));
          }
          v82 = 1.0;
          if (v58 >= 2)
            v82 = sqrtf(1.0 / (float)v58);
          v83 = 0;
          v84 = v82 * a13;
          v85 = (float)((float)((float)(*((float *)v141 + 4) * (float)v43) * a8) + 0.5);
          while (*(float *)&v80[v83] <= 1.1755e-37
               && *(float *)&v63[v83] <= 1.1755e-37
               && *(float *)&v64[v83] <= 1.1755e-37)
          {
            v83 += 4;
            if (v83 == 124)
              goto LABEL_164;
          }
          v132 = v41;
          v86 = 0;
          v87 = v58;
          do
          {
            v88 = rand();
            if (v88 >= 0)
              v89 = v88 & 1;
            else
              v89 = -(v88 & 1);
            v90 = __p[v86];
            v91 = rand();
            v92 = (float)(v90 - v85) / v44;
            if (v92 < 0.0)
              v92 = 0.0;
            if (v92 <= 1.0)
              v93 = v92;
            else
              v93 = 1.0;
            std::vector<float>::vector(buf, 0x1FuLL);
            v94 = (float)v91 * 4.6566e-10;
            v95 = *(_QWORD *)buf;
            v96 = 0;
            if (v93 >= 0.5)
            {
              v98 = (float)(v94 * (float)((float)(v93 + -0.5) + (float)(v93 + -0.5)))
                  * (float)(v94 * (float)((float)(v93 + -0.5) + (float)(v93 + -0.5)));
              do
              {
                *(float *)(v95 + v96) = (float)(v98 * *(float *)&v64[v96])
                                      + (float)((float)(1.0 - v98) * *(float *)&v63[v96]);
                v96 += 4;
              }
              while (v96 != 124);
            }
            else
            {
              v97 = (float)(v94 * (float)((float)(0.5 - v93) + (float)(0.5 - v93)))
                  * (float)(v94 * (float)((float)(0.5 - v93) + (float)(0.5 - v93)));
              do
              {
                *(float *)(v95 + v96) = (float)(v97 * *(float *)&v80[v96])
                                      + (float)((float)(1.0 - v97) * *(float *)&v63[v96]);
                v96 += 4;
              }
              while (v96 != 124);
            }
            if (v147)
              operator delete(v147);
            v99 = *(float **)buf;
            v147 = *(void **)buf;
            v142 = *(float **)&buf[8];
            v148 = *(_OWORD *)&buf[8];
            v100 = rand();
            v101 = rand();
            if (!Phase::SpatialModeler::DirectivityHistogram::findImpactAngle_TS(v141, v43, (float *)&v146 + 1, (float *)&v146, (float)v100 * 4.6566e-10, (float)v101 * 4.6566e-10))
            {
              v102 = 0;
              v103 = __p[v86];
              do
              {
                v99[v102] = v84 * (float)(sqrtf(v99[v102]) * (float)(2 * v89 - 1));
                ++v102;
              }
              while (v102 != 31);
              if (v99 != v142)
              {
                v104 = (v103 - a4) & ~((v103 - a4) >> 31);
                while (fabsf(*v99) <= v19)
                {
                  if (++v99 == v142)
                    goto LABEL_138;
                }
                v105 = (float)v104 / a8;
                v107 = a5[1];
                v106 = a5[2];
                if (v107 >= v106)
                {
                  v110 = 0x8E38E38E38E38E39 * ((uint64_t)(v107 - *a5) >> 4);
                  v111 = v110 + 1;
                  if (v110 + 1 > 0x1C71C71C71C71C7)
                    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
                  v112 = 0x8E38E38E38E38E39 * ((uint64_t)(v106 - *a5) >> 4);
                  if (2 * v112 > v111)
                    v111 = 2 * v112;
                  if (v112 >= 0xE38E38E38E38E3)
                    v113 = 0x1C71C71C71C71C7;
                  else
                    v113 = v111;
                  v152 = a5 + 2;
                  if (v113)
                    v114 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>>((uint64_t)(a5 + 2), v113);
                  else
                    v114 = 0;
                  *(_QWORD *)buf = v114;
                  *(_QWORD *)&buf[8] = &v114[144 * v110];
                  *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
                  *(_QWORD *)&buf[24] = &v114[144 * v113];
                  Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave::PhaseSpatialModelerMetadata_ThirdOctave(*(uint64_t *)&buf[8], (char **)&v147, *(float *)&v146, *((float *)&v146 + 1), v105);
                  v115 = (_QWORD *)*a5;
                  v116 = a5[1];
                  v117 = *(_QWORD *)&buf[8];
                  v118 = *(_QWORD *)&buf[16];
                  if (v116 == *a5)
                  {
                    v125 = vdupq_n_s64(v116);
                  }
                  else
                  {
                    do
                    {
                      *(_QWORD *)(v117 - 144) = off_24D57CC58;
                      v117 -= 144;
                      *(_OWORD *)(v117 + 8) = *(_OWORD *)(v116 - 136);
                      v119 = *(_OWORD *)(v116 - 120);
                      v120 = *(_OWORD *)(v116 - 104);
                      v121 = *(_OWORD *)(v116 - 88);
                      *(_OWORD *)(v117 + 72) = *(_OWORD *)(v116 - 72);
                      *(_OWORD *)(v117 + 56) = v121;
                      *(_OWORD *)(v117 + 40) = v120;
                      *(_OWORD *)(v117 + 24) = v119;
                      v122 = *(_OWORD *)(v116 - 56);
                      v123 = *(_OWORD *)(v116 - 40);
                      v124 = *(_OWORD *)(v116 - 24);
                      *(_QWORD *)(v117 + 136) = *(_QWORD *)(v116 - 8);
                      *(_OWORD *)(v117 + 120) = v124;
                      *(_OWORD *)(v117 + 104) = v123;
                      *(_OWORD *)(v117 + 88) = v122;
                      v116 -= 144;
                    }
                    while ((_QWORD *)v116 != v115);
                    v125 = *(int64x2_t *)a5;
                  }
                  v109 = a5;
                  v108 = v118 + 144;
                  *a5 = v117;
                  a5[1] = v118 + 144;
                  *(int64x2_t *)&buf[8] = v125;
                  v126 = a5[2];
                  a5[2] = *(_QWORD *)&buf[24];
                  *(_QWORD *)&buf[24] = v126;
                  *(_QWORD *)buf = v125.i64[0];
                  std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::~__split_buffer((uint64_t)buf);
                }
                else
                {
                  Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave::PhaseSpatialModelerMetadata_ThirdOctave(a5[1], (char **)&v147, *(float *)&v146, *((float *)&v146 + 1), v105);
                  v108 = v107 + 144;
                  v109 = a5;
                  a5[1] = v107 + 144;
                }
                v109[1] = v108;
              }
            }
LABEL_138:
            ++v86;
          }
          while (v86 != v87);
          v57 = __p;
          v42 = v130;
          v41 = v132;
LABEL_164:
          v144 = v57;
          goto LABEL_165;
        }
        goto LABEL_165;
      }
      v65 = *((unsigned int *)v141 + 7);
      v66 = *((_DWORD *)v141 + 6) > v56 && *((_BYTE *)v141 + 36) == 0;
      v67 = v66
          ? (__int128 *)(*((_QWORD *)v141 + 1) + 4 * v65 * v56)
          : (__int128 *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
      v68 = (uint64_t *)v149 + 3 * (v56 % 3);
      v69 = (_OWORD *)*v68;
      if ((_DWORD)v65 == 3)
        break;
      if ((_DWORD)v65 == 10)
      {
        v77 = Phase::sOctaveBandFrequencies;
LABEL_86:
        Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>(v77, &v77[v65], (uint64_t)v67, (uint64_t)v67 + 4 * v65, Phase::sThirdOctaveBandFrequencies, (float *)&jpt_2165B70F0, *v68);
        goto LABEL_92;
      }
      if ((_DWORD)v65 == 31)
      {
        v70 = *v67;
        v71 = v67[1];
        v72 = v67[3];
        v69[2] = v67[2];
        v69[3] = v72;
        *v69 = v70;
        v69[1] = v71;
        v73 = v67[4];
        v74 = v67[5];
        v75 = v67[6];
        *(_OWORD *)((char *)v69 + 108) = *(__int128 *)((char *)v67 + 108);
        v69[5] = v74;
        v69[6] = v75;
        v69[4] = v73;
      }
      else
      {
        if ((Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce & 1) == 0)
        {
          v78 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)v46) + 1184);
          if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "GeneratePlaneWaveList.hpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 177;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v65;
            _os_log_impl(&dword_2164CC000, v78, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported subband count: %zu\n", buf, 0x1Cu);
          }
          Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce = 1;
        }
        *(_OWORD *)((char *)v69 + 108) = 0u;
        v69[5] = 0u;
        v69[6] = 0u;
        v69[3] = 0u;
        v69[4] = 0u;
        v69[1] = 0u;
        v69[2] = 0u;
        *v69 = 0u;
      }
LABEL_92:
      v57 = __p;
      v58 = (unint64_t)((char *)v144 - (char *)__p) >> 2;
      if ((_DWORD)v58)
      {
        v63 = (char *)*((_QWORD *)v149 + 3 * (v43 % 3));
        v59 = *((_DWORD *)v141 + 6);
        if ((int)v59 <= v137)
          v64 = (char *)*((_QWORD *)v149 + 3 * ((v59 - 1) % 3));
        else
          v64 = (char *)*v68;
        goto LABEL_97;
      }
LABEL_165:
      v43 = v137;
LABEL_166:
      if (++v41 == v135)
        goto LABEL_167;
    }
    v77 = Phase::sThreeBandFrequencies;
    goto LABEL_86;
  }
LABEL_167:
  for (j = 0; j != -72; j -= 24)
  {
    v128 = *(void **)((char *)&v149[3] + j);
    if (v128)
    {
      *(_QWORD *)((char *)&v149[3] + j + 8) = v128;
      operator delete(v128);
    }
  }
  if (__p)
    operator delete(__p);
  if (v147)
    operator delete(v147);
}

void sub_2165B33B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,char a33)
{
  uint64_t v34;
  void *v35;

  v34 = 0;
  while (1)
  {
    v35 = *(void **)(&a33 + v34 + 48);
    if (v35)
    {
      *(_QWORD *)(&a33 + v34 + 56) = v35;
      operator delete(v35);
    }
    v34 -= 24;
    if (v34 == -72)
    {
      if (__p)
        operator delete(__p);
      if (a30)
        operator delete(a30);
      _Unwind_Resume(exception_object);
    }
  }
}

uint64_t Phase::SpatialModeler::convertRayTracingPlaneWaveListToDirectionalMetadata<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(uint64_t result, uint64_t *a2, char a3)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v6;
  unint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float *v20;
  uint64_t v21;
  float v22;
  float v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  float *v27;
  float *v28;
  uint64_t v29;
  uint64_t *v31;
  uint64_t v32;

  if (a2)
  {
    v3 = (uint64_t *)result;
    result = *(_QWORD *)result;
    v4 = v3[1];
    if (result != v4)
    {
      v6 = (unsigned __int128)((v4 - result) * (__int128)0xE38E38E38E38E39) >> 64;
      v7 = (v6 >> 3) + ((unint64_t)v6 >> 63);
      v8 = (**(uint64_t (***)(uint64_t))result)(result);
      Phase::SpatialModeler::AllocMetadata<float>(a2, v7, (int)v8);
      v9 = 0;
      v10 = *v3;
      v11 = a2[1];
      v12 = a2[7];
      v13 = a2[13];
      v14 = (float *)(v13 + 16);
      v15 = *(_QWORD *)(v13 + 8);
      if (v7 <= 1)
        v16 = 1;
      else
        v16 = v7;
      v17 = v8;
      v18 = 4 * v15;
      v31 = a2;
      v32 = v8;
      v19 = a2[18];
      v20 = (float *)(v10 + 20);
      result = 1119092736;
      do
      {
        v21 = v10 + 144 * v9;
        v22 = *(float *)(v21 + 8);
        v23 = (float)((float)(180.0 - *(float *)(v21 + 12))
                    - (float)(floorf((float)(180.0 - *(float *)(v21 + 12)) / 360.0) * 360.0))
            + 0.0;
        if (v23 >= 360.0)
        {
          v24 = v11;
          v25 = v10;
          v23 = nextafterf(360.0, 0.0);
          result = 1119092736;
          v17 = v32;
          v10 = v25;
          v11 = v24;
        }
        v26 = v11 + 12 * v9;
        *(_DWORD *)v26 = 1065353216;
        *(float *)(v26 + 4) = 90.0 - v22;
        *(float *)(v26 + 8) = v23;
        *(_DWORD *)(v12 + 4 * v9) = *(_DWORD *)(v10 + 144 * v9 + 16);
        *(_BYTE *)(v19 + v9) = 0;
        v27 = v20;
        v28 = v14;
        v29 = v17;
        if ((int)v17 >= 1)
        {
          do
          {
            *v28 = fabsf(*v27);
            if (*v27 < 0.0)
              *(_BYTE *)(v19 + v9) = 1;
            ++v28;
            ++v27;
            --v29;
          }
          while (v29);
        }
        ++v9;
        v14 = (float *)((char *)v14 + v18);
        v20 += 36;
      }
      while (v9 != v16);
      *((_BYTE *)v31 + 201) = a3;
      *((_DWORD *)v31 + 51) = 0;
    }
  }
  return result;
}

void Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>(float *a1, float *a2, uint64_t a3, uint64_t a4, float *a5, float *a6, uint64_t a7)
{
  uint64_t v10;
  float *i;
  float v12;
  float v13;
  float *j;
  float v15;
  float v16;
  float *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  float *v24;
  float v25;
  float v26;
  float *v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  uint64_t v33;
  float *v34;
  float *v35;
  float *v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  char *v41;
  float *v42;
  int v43;
  char *v44;
  char *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  uint64_t *v51;
  uint64_t v52;
  float *v53;
  float v54;
  float *v55;
  float v56;
  float *v57;
  unint64_t v58;
  float v59;
  float v60;
  float *v61;
  float v62;
  float v63;
  float v64;
  float *v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  char *v70;
  float *v71;
  int v72;
  double v73;
  float *v74;
  float v75;
  float v76;
  uint64_t v77;
  float *v79;
  float *v80;
  float *v81;
  void *v82;
  char *v83;
  char *v84;
  void *__p;
  float *v86;
  float *v87;
  void *v88[3];
  void *v89[4];

  v10 = (char *)a2 - (char *)a1;
  if (a2 != a1)
  {
    for (i = a1 + 1; i != a2; ++i)
    {
      v13 = *(i - 1);
      v12 = *i;
      if (v12 < v13)
        __assert_rtn("GetValuesFromFrequencyResponse", "FrequencyResponse.hpp", 262, "std::is_sorted(inFrequenciesFirst, inFrequenciesLast)");
    }
  }
  if (a5 != a6)
  {
    for (j = a5 + 1; j != a6; ++j)
    {
      v16 = *(j - 1);
      v15 = *j;
      if (v15 < v16)
        __assert_rtn("GetValuesFromFrequencyResponse", "FrequencyResponse.hpp", 263, "std::is_sorted(inOutputFrequenciesFirst, inOutputFrequenciesLast)");
    }
  }
  Phase::GetBandsFromCenterFrequencies<float const*,float>(a1, a2, (float **)v89, 22000.0);
  Phase::GetBandsFromCenterFrequencies<float const*,float>(a5, a6, (float **)v88, 22000.0);
  __p = 0;
  v86 = 0;
  v87 = 0;
  v82 = 0;
  v83 = 0;
  v84 = 0;
  v79 = 0;
  v81 = 0;
  if ((char *)a6 - (char *)a5 > 0)
  {
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v21 = a6 - a5;
    v22 = v10 >> 2;
    v23 = (v10 >> 2) - 1;
    if (v21 <= 1)
      v21 = 1;
    v77 = v21;
    do
    {
      v24 = (float *)((char *)v88[0] + 8 * v20);
      v25 = *v24;
      v26 = v24[1];
      v86 = (float *)__p;
      v83 = v18;
      v80 = v17;
      if (v19 < v22)
      {
        v27 = (float *)((char *)v89[0] + 8 * v19);
        v28 = *v27;
        v29 = v27[1];
        if (v26 < v29)
          v29 = v26;
        if (v28 >= v25)
          v30 = *v27;
        else
          v30 = v25;
        v31 = fmaxf(v29 - v30, 0.0);
        v32 = v26;
        v33 = v19;
        if (v31 == 0.0)
        {
LABEL_62:
          v19 -= v28 != v32;
        }
        else
        {
          while (1)
          {
            v34 = v86;
            if (v86 >= v87)
            {
              v36 = (float *)__p;
              v37 = ((char *)v86 - (_BYTE *)__p) >> 2;
              v38 = v37 + 1;
              if ((unint64_t)(v37 + 1) >> 62)
                std::vector<float>::__throw_length_error[abi:ne180100]();
              v39 = (char *)v87 - (_BYTE *)__p;
              if (((char *)v87 - (_BYTE *)__p) >> 1 > v38)
                v38 = v39 >> 1;
              if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFFCLL)
                v40 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v40 = v38;
              if (v40)
              {
                v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v87, v40);
                v36 = (float *)__p;
                v34 = v86;
              }
              else
              {
                v41 = 0;
              }
              v42 = (float *)&v41[4 * v37];
              *v42 = v31;
              v35 = v42 + 1;
              while (v34 != v36)
              {
                v43 = *((_DWORD *)v34-- - 1);
                *((_DWORD *)v42-- - 1) = v43;
              }
              __p = v42;
              v86 = v35;
              v87 = (float *)&v41[4 * v40];
              if (v36)
                operator delete(v36);
            }
            else
            {
              *v86 = v31;
              v35 = v34 + 1;
            }
            v86 = v35;
            v44 = v83;
            if (v83 >= v84)
            {
              v45 = (char *)v82;
              v46 = (v83 - (_BYTE *)v82) >> 3;
              v47 = v46 + 1;
              if ((unint64_t)(v46 + 1) >> 61)
                std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
              v48 = v84 - (_BYTE *)v82;
              if ((v84 - (_BYTE *)v82) >> 2 > v47)
                v47 = v48 >> 2;
              if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8)
                v49 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v49 = v47;
              if (v49)
              {
                v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&v84, v49);
                v45 = (char *)v82;
                v44 = v83;
              }
              else
              {
                v50 = 0;
              }
              v51 = (uint64_t *)&v50[8 * v46];
              *v51 = v19;
              v18 = (char *)(v51 + 1);
              while (v44 != v45)
              {
                v52 = *((_QWORD *)v44 - 1);
                v44 -= 8;
                *--v51 = v52;
              }
              v82 = v51;
              v83 = v18;
              v84 = &v50[8 * v49];
              if (v45)
                operator delete(v45);
            }
            else
            {
              *(_QWORD *)v83 = v19;
              v18 = v44 + 8;
            }
            v83 = v18;
            if (v19 == v23)
              v33 = v19;
            if (++v19 == v22)
              break;
            v53 = (float *)((char *)v89[0] + 8 * v19);
            v28 = *v53;
            v54 = v53[1];
            v55 = (float *)((char *)v88[0] + 8 * v20);
            v56 = *v55;
            v32 = v55[1];
            if (v32 < v54)
              v54 = v55[1];
            if (v28 >= v56)
              v56 = v28;
            v31 = fmaxf(v54 - v56, 0.0);
            if (v31 == 0.0)
              goto LABEL_62;
          }
          v19 = v33;
        }
      }
      v57 = v80;
      if (v18 == v82)
      {
        v60 = 0.0;
      }
      else
      {
        v58 = 0;
        v59 = v26 - v25;
        v60 = 0.0;
        v61 = v80;
        v18 = (char *)v82;
        do
        {
          v62 = *((float *)__p + v58) / v59;
          v63 = *(float *)(a3 + 4 * *(_QWORD *)&v18[8 * v58]);
          v64 = v62 * (float)(v63 * v63);
          if (v61 >= v81)
          {
            v65 = v79;
            v66 = v61 - v79;
            v67 = v66 + 1;
            if ((unint64_t)(v66 + 1) >> 62)
              std::vector<float>::__throw_length_error[abi:ne180100]();
            v68 = (char *)v81 - (char *)v79;
            if (((char *)v81 - (char *)v79) >> 1 > v67)
              v67 = v68 >> 1;
            if ((unint64_t)v68 >= 0x7FFFFFFFFFFFFFFCLL)
              v69 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v69 = v67;
            if (v69)
            {
              v70 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v81, v69);
              v65 = v79;
              v61 = v80;
            }
            else
            {
              v70 = 0;
            }
            v71 = (float *)&v70[4 * v66];
            *v71 = v64;
            v57 = v71 + 1;
            while (v61 != v65)
            {
              v72 = *((_DWORD *)v61-- - 1);
              *((_DWORD *)v71-- - 1) = v72;
            }
            v79 = v71;
            v81 = (float *)&v70[4 * v69];
            if (v65)
              operator delete(v65);
          }
          else
          {
            *v61 = v64;
            v57 = v61 + 1;
          }
          v80 = v57;
          v60 = v60 + v62;
          ++v58;
          v18 = (char *)v82;
          v61 = v57;
        }
        while (v58 < (v83 - (_BYTE *)v82) >> 3);
      }
      v17 = v79;
      v73 = 0.0;
      if (v79 != v57)
      {
        v74 = v79;
        do
        {
          v75 = *v74++;
          v73 = v73 + v75;
        }
        while (v74 != v57);
      }
      v76 = v73;
      v23 = (v10 >> 2) - 1;
      *(float *)(a7 + 4 * v20++) = sqrtf(v76 / v60);
    }
    while (v20 != v77);
    if (v79)
    {
      operator delete(v79);
      v18 = (char *)v82;
    }
    if (v18)
    {
      v83 = v18;
      operator delete(v18);
    }
  }
  if (__p)
  {
    v86 = (float *)__p;
    operator delete(__p);
  }
  if (v88[0])
  {
    v88[1] = v88[0];
    operator delete(v88[0]);
  }
  if (v89[0])
  {
    v89[1] = v89[0];
    operator delete(v89[0]);
  }
}

void sub_2165B3B80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

Phase::Logger *Phase::GetBandsFromCenterFrequencies<float const*,float>@<X0>(float *a1@<X0>, float *a2@<X1>, float **a3@<X8>, float a4@<S0>)
{
  uint64_t v8;
  int64_t v9;
  Phase::Logger *result;
  float *v11;
  float *v12;
  float *v13;
  float v14;
  _BOOL4 v15;
  BOOL v16;
  float *v17;
  float *v18;
  float v19;
  _BOOL4 v20;
  BOOL v21;
  int64_t v22;
  int64_t v23;
  uint64_t v24;
  float *v25;
  float *v26;
  float v27;
  float v28;
  float v29;
  uint64_t v30;
  NSObject *v31;
  double v32;
  std::logic_error *exception;
  NSObject *v34;
  double v35;
  NSObject *v36;
  double v37;
  NSObject *v38;
  double v39;
  double v40;
  _BYTE v41[12];
  __int16 v42;
  int v43;
  __int16 v44;
  double v45;
  __int16 v46;
  double v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v8 = (char *)a2 - (char *)a1;
  v9 = a2 - a1;
  *(_QWORD *)v41 = 0;
  result = (Phase::Logger *)std::vector<Phase::FrequencyBand<float>>::vector(a3, v9, v41);
  v11 = *a3;
  **a3 = 10.0;
  if (v9 == 31)
  {
    if (a1 == a2)
    {
      v15 = 0;
      v20 = 1;
    }
    else
    {
      v17 = a1 + 1;
      v18 = (float *)&Phase::sThirdOctaveBandFrequencies;
      do
      {
        v19 = *v18++;
        v20 = *(v17 - 1) == v19;
        v21 = *(v17 - 1) != v19 || v17 == a2;
        ++v17;
      }
      while (!v21);
      v15 = 0;
    }
  }
  else
  {
    if (v9 != 10)
    {
      v15 = 0;
LABEL_20:
      v20 = 0;
      goto LABEL_21;
    }
    if (a1 != a2)
    {
      v12 = a1 + 1;
      v13 = (float *)&Phase::sOctaveBandFrequencies;
      do
      {
        v14 = *v13++;
        v15 = *(v12 - 1) == v14;
        v16 = *(v12 - 1) != v14 || v12 == a2;
        ++v12;
      }
      while (!v16);
      goto LABEL_20;
    }
    v20 = 0;
    v15 = 1;
  }
LABEL_21:
  if (v8 >= 1)
  {
    v22 = 0;
    v23 = v9 - 1;
    if (v9 <= 1)
      v24 = 1;
    else
      v24 = v9;
    v25 = v11 + 2;
    v26 = a1;
    do
    {
      v27 = *v26;
      if (v15)
      {
        v28 = v27 + (float)((float)(v27 / 1.4142) * 0.5);
        if (v28 >= a4)
          v28 = a4;
        v29 = 20.363;
      }
      else if (v20)
      {
        v28 = v27 + (float)((float)(v27 / 4.2426) * 0.5);
        if (v28 >= a4)
          v28 = a4;
        v29 = 17.643;
      }
      else
      {
        if ((LODWORD(v27) & 0x7FFFFFFFu) >= 0x7F800000)
        {
          v31 = **(NSObject ***)(Phase::Logger::GetInstancePtr(result) + 1136);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            v32 = *v26;
            *(_DWORD *)v41 = 136315650;
            *(_QWORD *)&v41[4] = "FrequencyResponse.hpp";
            v42 = 1024;
            v43 = 99;
            v44 = 2048;
            v45 = v32;
            _os_log_impl(&dword_2164CC000, v31, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [!std::isfinite(inFrequenciesFirst[i]) is true]: \"GetBandsFromCenterFrequencies: bad center frequency: %fHz\"", v41, 0x1Cu);
          }
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(exception, "GetBandsFromCenterFrequencies: bad center frequency: %fHz");
LABEL_60:
          exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8D0] + 16);
        }
        if (v27 < 10.0)
        {
          v36 = **(NSObject ***)(Phase::Logger::GetInstancePtr(result) + 1136);
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          {
            v37 = *v26;
            *(_DWORD *)v41 = 136315906;
            *(_QWORD *)&v41[4] = "FrequencyResponse.hpp";
            v42 = 1024;
            v43 = 103;
            v44 = 2048;
            v45 = v37;
            v46 = 2048;
            v47 = 10.0;
            _os_log_impl(&dword_2164CC000, v36, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [inFrequenciesFirst[i] < lowestSupportedFreqInHz is true]: \"GetBandsFromCenterFrequencies: center frequency: %fHz cannot be below lowest supported frequency: %fHz\"", v41, 0x26u);
          }
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(exception, "GetBandsFromCenterFrequencies: center frequency: %fHz cannot be below lowest supported frequency: %fHz");
          goto LABEL_60;
        }
        if (v27 > a4)
        {
          v34 = **(NSObject ***)(Phase::Logger::GetInstancePtr(result) + 1136);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            v35 = *v26;
            *(_DWORD *)v41 = 136315906;
            *(_QWORD *)&v41[4] = "FrequencyResponse.hpp";
            v42 = 1024;
            v43 = 107;
            v44 = 2048;
            v45 = v35;
            v46 = 2048;
            v47 = a4;
            _os_log_impl(&dword_2164CC000, v34, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [inFrequenciesFirst[i] > highestSupportedFreqInHz is true]: \"GetBandsFromCenterFrequencies: center frequency: %fHz cannot be above highest supported frequency: %fHz\"", v41, 0x26u);
          }
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(exception, "GetBandsFromCenterFrequencies: center frequency: %fHz cannot be above highest supported frequency: %fHz");
          goto LABEL_60;
        }
        if (v22)
        {
          v30 = (v22 - 1);
          if (a1[v30] >= v27)
          {
            v38 = **(NSObject ***)(Phase::Logger::GetInstancePtr(result) + 1136);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
            {
              v39 = a1[v30];
              v40 = *v26;
              *(_DWORD *)v41 = 136315906;
              *(_QWORD *)&v41[4] = "FrequencyResponse.hpp";
              v42 = 1024;
              v43 = 111;
              v44 = 2048;
              v45 = v39;
              v46 = 2048;
              v47 = v40;
              _os_log_impl(&dword_2164CC000, v38, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [i > 0 && inFrequenciesFirst[i - 1] >= inFrequenciesFirst[i] is true]: \"GetBandsFromCenterFrequencies: center frequencies are not in ascending order. %fHz is before %fHz\"", v41, 0x26u);
            }
            exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
            std::logic_error::logic_error(exception, "GetBandsFromCenterFrequencies: center frequencies are not in ascending order. %fHz is before %fHz");
            goto LABEL_60;
          }
        }
        v29 = 10.0;
        if (v23 <= v22)
          v28 = a4;
        else
          v28 = v27 * sqrtf(v26[1] / v27);
      }
      *(v25 - 1) = v28;
      *v11 = v29;
      if (v23 > v22)
        *v25 = v28;
      ++v22;
      ++v26;
      v25 += 2;
    }
    while (v24 != v22);
  }
  return result;
}

void sub_2165B40E4(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  void *v4;

  __cxa_free_exception(v2);
  v4 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

void std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  BOOL v9;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 32;
      v7 = v4 - 32;
      do
      {
        v8 = *(_QWORD *)v7;
        v7 -= 32;
        (*(void (**)(char *))(v8 + 16))(v6);
        v9 = v6 == v2;
        v6 = v7;
      }
      while (!v9);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band::PhaseSpatialModelerMetadata_3Band(uint64_t a1, uint64_t *a2, float a3, float a4, float a5)
{
  uint64_t v6;
  uint64_t v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  NSObject *v14;
  uint64_t v15;
  int v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = off_24D57CBF8;
  *(float *)(a1 + 8) = a3;
  *(float *)(a1 + 12) = a4;
  *(float *)(a1 + 16) = a5;
  v6 = *a2;
  v7 = (a2[1] - *a2) >> 2;
  switch(v7)
  {
    case 3:
      *(_DWORD *)(a1 + 20) = *(_DWORD *)v6;
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(v6 + 4);
      v10 = *(float *)(v6 + 8);
LABEL_8:
      *(float *)(a1 + 28) = v10;
      return a1;
    case 31:
      v11 = *(float *)(v6 + 44);
      *(float *)(a1 + 20) = sqrtf((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*(float *)(v6 + 4) * *(float *)(v6 + 4)) + (float)(*(float *)v6 * *(float *)v6)) + (float)(*(float *)(v6 + 8) * *(float *)(v6 + 8))) + (float)(*(float *)(v6 + 12) * *(float *)(v6 + 12)))+ (float)(*(float *)(v6 + 16) * *(float *)(v6 + 16)))+ (float)(*(float *)(v6 + 20)* *(float *)(v6 + 20)))+ (float)(*(float *)(v6 + 24)* *(float *)(v6 + 24)))+ (float)(*(float *)(v6 + 28) * *(float *)(v6 + 28)))+ (float)(*(float *)(v6 + 32) * *(float *)(v6 + 32)))+ (float)(*(float *)(v6 + 36) * *(float *)(v6 + 36)))+ (float)(*(float *)(v6 + 40) * *(float *)(v6 + 40)))+ (float)(v11 * v11))/ 12.0);
      v12 = *(float *)(v6 + 92);
      *(float *)(a1 + 24) = sqrtf((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*(float *)(v6 + 52) * *(float *)(v6 + 52)) + (float)(*(float *)(v6 + 48) * *(float *)(v6 + 48))) + (float)(*(float *)(v6 + 56) * *(float *)(v6 + 56))) + (float)(*(float *)(v6 + 60) * *(float *)(v6 + 60)))+ (float)(*(float *)(v6 + 64) * *(float *)(v6 + 64)))+ (float)(*(float *)(v6 + 68)* *(float *)(v6 + 68)))+ (float)(*(float *)(v6 + 72)* *(float *)(v6 + 72)))+ (float)(*(float *)(v6 + 76) * *(float *)(v6 + 76)))+ (float)(*(float *)(v6 + 80) * *(float *)(v6 + 80)))+ (float)(*(float *)(v6 + 84) * *(float *)(v6 + 84)))+ (float)(*(float *)(v6 + 88) * *(float *)(v6 + 88)))+ (float)(v12 * v12))/ 12.0);
      v9 = (float)((float)((float)((float)((float)((float)(*(float *)(v6 + 100) * *(float *)(v6 + 100))
                                                 + (float)(*(float *)(v6 + 96) * *(float *)(v6 + 96)))
                                         + (float)(*(float *)(v6 + 104) * *(float *)(v6 + 104)))
                                 + (float)(*(float *)(v6 + 108) * *(float *)(v6 + 108)))
                         + (float)(*(float *)(v6 + 112) * *(float *)(v6 + 112)))
                 + (float)(*(float *)(v6 + 116) * *(float *)(v6 + 116)))
         + (float)(*(float *)(v6 + 120) * *(float *)(v6 + 120));
      v8 = 7.0;
      goto LABEL_7;
    case 10:
      *(float *)(a1 + 20) = sqrtf((float)((float)((float)((float)(*(float *)(v6 + 4) * *(float *)(v6 + 4))+ (float)(*(float *)v6 * *(float *)v6))+ (float)(*(float *)(v6 + 8) * *(float *)(v6 + 8)))+ (float)(*(float *)(v6 + 12) * *(float *)(v6 + 12)))* 0.25);
      v8 = 3.0;
      *(float *)(a1 + 24) = sqrtf((float)((float)((float)(*(float *)(v6 + 20) * *(float *)(v6 + 20))+ (float)(*(float *)(v6 + 16) * *(float *)(v6 + 16)))+ (float)(*(float *)(v6 + 24) * *(float *)(v6 + 24)))/ 3.0);
      v9 = (float)((float)(*(float *)(v6 + 32) * *(float *)(v6 + 32))
                 + (float)(*(float *)(v6 + 28) * *(float *)(v6 + 28)))
         + (float)(*(float *)(v6 + 36) * *(float *)(v6 + 36));
LABEL_7:
      v10 = sqrtf(v9 / v8);
      goto LABEL_8;
  }
  v14 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)a1) + 1184);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    v15 = (a2[1] - *a2) >> 2;
    v17 = 136315650;
    v18 = "RayTracingTypes.hpp";
    v19 = 1024;
    v20 = 422;
    v21 = 2048;
    v22 = v15;
    _os_log_impl(&dword_2164CC000, v14, OS_LOG_TYPE_ERROR, "%25s:%-5d PhaseSpatialModelerMetadata_3Band invalid number of subbands %zu", (uint8_t *)&v17, 0x1Cu);
  }
  *(_DWORD *)(a1 + 28) = 0;
  *(_QWORD *)(a1 + 20) = 0;
  return a1;
}

uint64_t Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band::getNumBands(Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band *this)
{
  return 3;
}

float Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band::getDelay(Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band *this)
{
  return *((float *)this + 4);
}

void Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band::~PhaseSpatialModelerMetadata_3Band(Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band *this)
{
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(_QWORD *)(i - 32);
    *(_QWORD *)(a1 + 16) = i - 32;
    (*(void (**)(void))(v4 + 16))();
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  BOOL v9;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 64;
      v7 = v4 - 64;
      do
      {
        v8 = *(_QWORD *)v7;
        v7 -= 64;
        (*(void (**)(char *))(v8 + 16))(v6);
        v9 = v6 == v2;
        v6 = v7;
      }
      while (!v9);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave::PhaseSpatialModelerMetadata_Octave(uint64_t a1, uint64_t a2, float a3, float a4, float a5)
{
  _BYTE *v7;
  _BYTE *v8;
  uint64_t v10;
  float v11;
  NSObject *v12;
  uint64_t v13;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = off_24D57CC28;
  *(float *)(a1 + 8) = a3;
  *(float *)(a1 + 12) = a4;
  *(float *)(a1 + 16) = a5;
  v7 = *(_BYTE **)a2;
  v8 = *(_BYTE **)(a2 + 8);
  v10 = (v8 - v7) >> 2;
  switch(v10)
  {
    case 3:
      *(_DWORD *)(a1 + 20) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 24) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 28) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 36) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 40) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 44) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 48) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 52) = *((_DWORD *)v7 + 2);
      v11 = *((float *)v7 + 2);
LABEL_8:
      *(float *)(a1 + 56) = v11;
      return a1;
    case 31:
      *(float *)(a1 + 20) = sqrtf((float)((float)((float)((float)(*((float *)v7 + 1) * *((float *)v7 + 1))+ (float)(*(float *)v7 * *(float *)v7))+ (float)(*((float *)v7 + 2) * *((float *)v7 + 2)))+ (float)(*((float *)v7 + 3) * *((float *)v7 + 3)))* 0.25);
      *(float *)(a1 + 24) = sqrtf((float)((float)((float)(*((float *)v7 + 5) * *((float *)v7 + 5))+ (float)(*((float *)v7 + 4) * *((float *)v7 + 4)))+ (float)(*((float *)v7 + 6) * *((float *)v7 + 6)))/ 3.0);
      *(float *)(a1 + 28) = sqrtf((float)((float)((float)(*((float *)v7 + 8) * *((float *)v7 + 8))+ (float)(*((float *)v7 + 7) * *((float *)v7 + 7)))+ (float)(*((float *)v7 + 9) * *((float *)v7 + 9)))/ 3.0);
      *(float *)(a1 + 32) = sqrtf((float)((float)((float)(*((float *)v7 + 11) * *((float *)v7 + 11))+ (float)(*((float *)v7 + 10) * *((float *)v7 + 10)))+ (float)(*((float *)v7 + 12) * *((float *)v7 + 12)))/ 3.0);
      *(float *)(a1 + 36) = sqrtf((float)((float)((float)(*((float *)v7 + 14) * *((float *)v7 + 14))+ (float)(*((float *)v7 + 13) * *((float *)v7 + 13)))+ (float)(*((float *)v7 + 15) * *((float *)v7 + 15)))/ 3.0);
      *(float *)(a1 + 40) = sqrtf((float)((float)((float)(*((float *)v7 + 17) * *((float *)v7 + 17))+ (float)(*((float *)v7 + 16) * *((float *)v7 + 16)))+ (float)(*((float *)v7 + 18) * *((float *)v7 + 18)))/ 3.0);
      *(float *)(a1 + 44) = sqrtf((float)((float)((float)(*((float *)v7 + 20) * *((float *)v7 + 20))+ (float)(*((float *)v7 + 19) * *((float *)v7 + 19)))+ (float)(*((float *)v7 + 21) * *((float *)v7 + 21)))/ 3.0);
      *(float *)(a1 + 48) = sqrtf((float)((float)((float)(*((float *)v7 + 23) * *((float *)v7 + 23))+ (float)(*((float *)v7 + 22) * *((float *)v7 + 22)))+ (float)(*((float *)v7 + 24) * *((float *)v7 + 24)))/ 3.0);
      *(float *)(a1 + 52) = sqrtf((float)((float)((float)(*((float *)v7 + 26) * *((float *)v7 + 26))+ (float)(*((float *)v7 + 25) * *((float *)v7 + 25)))+ (float)(*((float *)v7 + 27) * *((float *)v7 + 27)))/ 3.0);
      v11 = sqrtf((float)((float)((float)(*((float *)v7 + 29) * *((float *)v7 + 29))+ (float)(*((float *)v7 + 28) * *((float *)v7 + 28)))+ (float)(*((float *)v7 + 30) * *((float *)v7 + 30)))/ 3.0);
      goto LABEL_8;
    case 10:
      if (v8 != v7)
        memmove((void *)(a1 + 20), v7, v8 - v7);
      break;
    default:
      v12 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)a1) + 1184);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        v13 = (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2;
        v15 = 136315650;
        v16 = "RayTracingTypes.hpp";
        v17 = 1024;
        v18 = 514;
        v19 = 2048;
        v20 = v13;
        _os_log_impl(&dword_2164CC000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d PhaseSpatialModelerMetadata_Octave invalid number of subbands %zu", (uint8_t *)&v15, 0x1Cu);
      }
      *(_QWORD *)(a1 + 52) = 0;
      *(_OWORD *)(a1 + 36) = 0u;
      *(_OWORD *)(a1 + 20) = 0u;
      break;
  }
  return a1;
}

uint64_t Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave::getNumBands(Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave *this)
{
  return 10;
}

float Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave::getDelay(Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave *this)
{
  return *((float *)this + 4);
}

void Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave::~PhaseSpatialModelerMetadata_Octave(Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave *this)
{
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(_QWORD *)(i - 64);
    *(_QWORD *)(a1 + 16) = i - 64;
    (*(void (**)(void))(v4 + 16))();
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  BOOL v9;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 144;
      v7 = v4 - 144;
      do
      {
        v8 = *(_QWORD *)v7;
        v7 -= 144;
        (*(void (**)(char *))(v8 + 16))(v6);
        v9 = v6 == v2;
        v6 = v7;
      }
      while (!v9);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave::PhaseSpatialModelerMetadata_ThirdOctave(uint64_t a1, char **a2, float a3, float a4, float a5)
{
  char *v7;
  char *v8;
  uint64_t v10;
  int v11;
  NSObject *v12;
  uint64_t v13;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = off_24D57CC58;
  *(float *)(a1 + 8) = a3;
  *(float *)(a1 + 12) = a4;
  *(float *)(a1 + 16) = a5;
  v7 = *a2;
  v8 = a2[1];
  v10 = (v8 - v7) >> 2;
  switch(v10)
  {
    case 3:
      *(_DWORD *)(a1 + 20) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 24) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 28) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 36) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 40) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 44) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 48) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 52) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 56) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 60) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 64) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 68) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 72) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 76) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 80) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 84) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 88) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 92) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 96) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 100) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 104) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 108) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 112) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 116) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 120) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 124) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 128) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 132) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 136) = *((_DWORD *)v7 + 2);
      v11 = *((_DWORD *)v7 + 2);
      goto LABEL_6;
    case 31:
      if (v8 != v7)
        memmove((void *)(a1 + 20), v7, v8 - v7);
      break;
    case 10:
      *(_DWORD *)(a1 + 20) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 24) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 28) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 36) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 40) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 44) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 48) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 52) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 56) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 60) = *((_DWORD *)v7 + 3);
      *(_DWORD *)(a1 + 64) = *((_DWORD *)v7 + 3);
      *(_DWORD *)(a1 + 68) = *((_DWORD *)v7 + 3);
      *(_DWORD *)(a1 + 72) = *((_DWORD *)v7 + 4);
      *(_DWORD *)(a1 + 76) = *((_DWORD *)v7 + 4);
      *(_DWORD *)(a1 + 80) = *((_DWORD *)v7 + 4);
      *(_DWORD *)(a1 + 84) = *((_DWORD *)v7 + 5);
      *(_DWORD *)(a1 + 88) = *((_DWORD *)v7 + 5);
      *(_DWORD *)(a1 + 92) = *((_DWORD *)v7 + 5);
      *(_DWORD *)(a1 + 96) = *((_DWORD *)v7 + 6);
      *(_DWORD *)(a1 + 100) = *((_DWORD *)v7 + 6);
      *(_DWORD *)(a1 + 104) = *((_DWORD *)v7 + 6);
      *(_DWORD *)(a1 + 108) = *((_DWORD *)v7 + 7);
      *(_DWORD *)(a1 + 112) = *((_DWORD *)v7 + 7);
      *(_DWORD *)(a1 + 116) = *((_DWORD *)v7 + 7);
      *(_DWORD *)(a1 + 120) = *((_DWORD *)v7 + 8);
      *(_DWORD *)(a1 + 124) = *((_DWORD *)v7 + 8);
      *(_DWORD *)(a1 + 128) = *((_DWORD *)v7 + 8);
      *(_DWORD *)(a1 + 132) = *((_DWORD *)v7 + 9);
      *(_DWORD *)(a1 + 136) = *((_DWORD *)v7 + 9);
      v11 = *((_DWORD *)v7 + 9);
LABEL_6:
      *(_DWORD *)(a1 + 140) = v11;
      return a1;
    default:
      v12 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)a1) + 1184);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        v13 = (a2[1] - *a2) >> 2;
        v15 = 136315650;
        v16 = "RayTracingTypes.hpp";
        v17 = 1024;
        v18 = 639;
        v19 = 2048;
        v20 = v13;
        _os_log_impl(&dword_2164CC000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d PhaseSpatialModelerMetadata_ThirdOctave invalid number of subbands %zu", (uint8_t *)&v15, 0x1Cu);
      }
      *(_OWORD *)(a1 + 128) = 0u;
      *(_OWORD *)(a1 + 116) = 0u;
      *(_OWORD *)(a1 + 100) = 0u;
      *(_OWORD *)(a1 + 84) = 0u;
      *(_OWORD *)(a1 + 68) = 0u;
      *(_OWORD *)(a1 + 52) = 0u;
      *(_OWORD *)(a1 + 36) = 0u;
      *(_OWORD *)(a1 + 20) = 0u;
      break;
  }
  return a1;
}

uint64_t Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave::getNumBands(Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave *this)
{
  return 31;
}

float Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave::getDelay(Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave *this)
{
  return *((float *)this + 4);
}

void Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave::~PhaseSpatialModelerMetadata_ThirdOctave(Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave *this)
{
  JUMPOUT(0x2199F9D70);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1C71C71C71C71C8)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(144 * a2);
}

uint64_t std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(_QWORD *)(i - 144);
    *(_QWORD *)(a1 + 16) = i - 144;
    (*(void (**)(void))(v4 + 16))();
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t (*Phase::GetTypeId<Phase::Geometry::CardioidDirectivity>())()
{
  return Phase::GetTypeId<Phase::Geometry::CardioidDirectivity>;
}

uint64_t *Phase::Geometry::CreateCardioidDirectivity@<X0>(_QWORD *a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t **v3;
  uint64_t v4;
  _QWORD *v5;
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *result;
  __int128 v13[2];
  _QWORD v14[3];
  _QWORD *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v13[0] = "DirectivityDataMapSize";
  *((_QWORD *)&v13[0] + 1) = 22;
  if (a1 && (v3 = Phase::UnorderedStringMap<Phase::OptionsValue>::Find(a1, v13)) != 0 && *((_DWORD *)v3 + 24) == 1)
  {
    LODWORD(v4) = *((_DWORD *)v3 + 14);
    if ((int)v4 <= 0)
      std::terminate();
  }
  else
  {
    LODWORD(v4) = 1;
  }
  v5 = operator new(0x58uLL);
  v5[1] = 0;
  v5[2] = 0;
  *v5 = &off_24D57CC88;
  *((_DWORD *)v5 + 6) = 1;
  v6 = (char *)(v5 + 3);
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  v5[10] = 0;
  *((_OWORD *)v5 + 4) = 0u;
  v7 = v5 + 8;
  v4 = v4;
  *a2 = v5 + 3;
  a2[1] = v5;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v5 + 8, v4);
  v8 = 0;
  do
  {
    v9 = operator new();
    *(_QWORD *)v9 = Phase::GetTypeId<Phase::Geometry::CardioidDirectivity>;
    *(_QWORD *)(v9 + 8) = v6;
    *(_OWORD *)(v9 + 16) = 0u;
    *(_OWORD *)(v9 + 32) = 0u;
    *(_OWORD *)(v9 + 48) = 0u;
    *(_OWORD *)(v9 + 64) = 0u;
    *(_OWORD *)(v9 + 80) = 0u;
    *(_OWORD *)(v9 + 96) = 0u;
    *(_OWORD *)(v9 + 112) = 0u;
    *(_OWORD *)(v9 + 128) = 0u;
    *(_OWORD *)(v9 + 144) = 0u;
    *(_OWORD *)(v9 + 160) = 0u;
    *(_OWORD *)(v9 + 176) = 0u;
    *(_OWORD *)(v9 + 192) = 0u;
    *(_OWORD *)(v9 + 208) = 0u;
    *(_OWORD *)(v9 + 224) = 0u;
    *(_OWORD *)(v9 + 240) = 0u;
    *(_OWORD *)(v9 + 256) = 0u;
    *(_OWORD *)(v9 + 272) = 0u;
    *(_OWORD *)(v9 + 288) = 0u;
    *(_OWORD *)(v9 + 304) = 0u;
    *(_OWORD *)(v9 + 320) = 0u;
    *(_OWORD *)(v9 + 336) = 0u;
    *(_OWORD *)(v9 + 352) = 0u;
    *(_OWORD *)(v9 + 368) = 0u;
    *(_OWORD *)(v9 + 384) = 0u;
    v14[0] = &off_24D57CCC0;
    v15 = v14;
    *(_QWORD *)&v13[0] = v9;
    std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v13 + 8, (uint64_t)v14);
    v10 = v15;
    if (v15 == v14)
    {
      v10 = v14;
      v11 = 4;
    }
    else
    {
      if (!v15)
        goto LABEL_13;
      v11 = 5;
    }
    (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_13:
    std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(*v7 + v8), (uint64_t *)v13);
    result = std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v13);
    v8 += 40;
    --v4;
  }
  while (v4);
  return result;
}

void sub_2165B4F14(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t *result;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  result = (uint64_t *)a1[1];
  v4 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)result - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
    return (uint64_t *)std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__append(a1, v6);
  if (!v5)
  {
    v7 = *a1 + 40 * a2;
    while (result != (uint64_t *)v7)
      result = std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](result - 5);
    a1[1] = v7;
  }
  return result;
}

uint64_t *std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100](uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;

  v4 = *a2;
  *a2 = 0;
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::reset[abi:ne180100](a1, v4);
  std::__function::__value_func<double ()(double)>::operator=[abi:ne180100](a1 + 1, (uint64_t)(a2 + 1));
  return a1;
}

uint64_t *Phase::Geometry::CreateCardioidDirectivityFromDirectivity@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  char *v5;
  _QWORD *v6;
  uint64_t *result;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _OWORD *v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD v35[3];
  _QWORD *v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)a1 != 1)
    std::terminate();
  v4 = operator new(0x58uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_24D57CC88;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  v4[10] = 0;
  *((_DWORD *)v4 + 6) = 1;
  v5 = (char *)(v4 + 3);
  *((_OWORD *)v4 + 4) = 0u;
  v6 = v4 + 8;
  *a2 = v4 + 3;
  a2[1] = v4;
  result = std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v4 + 8, 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 48) - *(_QWORD *)(a1 + 40)) >> 3));
  v8 = *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)(a1 + 48) != v8)
  {
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *(_OWORD **)(v8 + v9);
      v12 = operator new();
      *(_QWORD *)v12 = Phase::GetTypeId<Phase::Geometry::CardioidDirectivity>;
      *(_QWORD *)(v12 + 8) = v5;
      v13 = v11[1];
      v14 = v11[2];
      v15 = v11[4];
      *(_OWORD *)(v12 + 48) = v11[3];
      *(_OWORD *)(v12 + 64) = v15;
      *(_OWORD *)(v12 + 16) = v13;
      *(_OWORD *)(v12 + 32) = v14;
      v16 = v11[5];
      v17 = v11[6];
      v18 = v11[8];
      *(_OWORD *)(v12 + 112) = v11[7];
      *(_OWORD *)(v12 + 128) = v18;
      *(_OWORD *)(v12 + 80) = v16;
      *(_OWORD *)(v12 + 96) = v17;
      v19 = v11[16];
      v21 = v11[13];
      v20 = v11[14];
      *(_OWORD *)(v12 + 240) = v11[15];
      *(_OWORD *)(v12 + 256) = v19;
      *(_OWORD *)(v12 + 208) = v21;
      *(_OWORD *)(v12 + 224) = v20;
      v22 = v11[9];
      v23 = v11[10];
      v24 = v11[12];
      *(_OWORD *)(v12 + 176) = v11[11];
      *(_OWORD *)(v12 + 192) = v24;
      *(_OWORD *)(v12 + 144) = v22;
      *(_OWORD *)(v12 + 160) = v23;
      v25 = v11[24];
      v27 = v11[21];
      v26 = v11[22];
      *(_OWORD *)(v12 + 368) = v11[23];
      *(_OWORD *)(v12 + 384) = v25;
      *(_OWORD *)(v12 + 336) = v27;
      *(_OWORD *)(v12 + 352) = v26;
      v28 = v11[17];
      v29 = v11[18];
      v30 = v11[20];
      *(_OWORD *)(v12 + 304) = v11[19];
      *(_OWORD *)(v12 + 320) = v30;
      *(_OWORD *)(v12 + 272) = v28;
      *(_OWORD *)(v12 + 288) = v29;
      v35[0] = &off_24D57CCC0;
      v36 = v35;
      v33 = v12;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v34, (uint64_t)v35);
      v31 = v36;
      if (v36 == v35)
        break;
      if (v36)
      {
        v32 = 5;
LABEL_8:
        (*(void (**)(void))(*v31 + 8 * v32))();
      }
      std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(*v6 + v9), &v33);
      result = std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v33);
      ++v10;
      v8 = *(_QWORD *)(a1 + 40);
      v9 += 40;
      if (0xCCCCCCCCCCCCCCCDLL * ((*(_QWORD *)(a1 + 48) - v8) >> 3) <= v10)
        return result;
    }
    v31 = v35;
    v32 = 4;
    goto LABEL_8;
  }
  return result;
}

void sub_2165B5204(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](a10);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<Phase::Geometry::Directivity>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57CC88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Phase::Geometry::Directivity>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57CC88;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

void std::__shared_ptr_emplace<Phase::Geometry::Directivity>::__on_zero_shared(uint64_t a1)
{
  void **v2;

  v2 = (void **)(a1 + 64);
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (void **)(a1 + 40);
  std::vector<std::shared_ptr<Phase::Controller::Renderer>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

void std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  uint64_t *v2;
  uint64_t *v4;
  void *v5;

  v1 = *a1;
  v2 = (uint64_t *)**a1;
  if (v2)
  {
    v4 = (uint64_t *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        v4 = std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](v4 - 5);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  _QWORD *v13;
  char *v14;
  char *v15;
  _QWORD v16[5];

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD **)(result - 8);
  if (0xCCCCCCCCCCCCCCCDLL * ((v6 - (uint64_t)v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = &v7[5 * a2];
      do
      {
        *v7 = 0;
        v7[4] = 0;
        v7 += 5;
      }
      while (v7 != v13);
      v7 = v13;
    }
    a1[1] = (uint64_t)v7;
  }
  else
  {
    v8 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x666666666666666)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x333333333333333)
      v11 = 0x666666666666666;
    else
      v11 = v9;
    v16[4] = result;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>>(result, v11);
    else
      v12 = 0;
    v14 = &v12[40 * v8];
    v16[0] = v12;
    v16[1] = v14;
    v16[3] = &v12[40 * v11];
    v15 = &v14[40 * a2];
    do
    {
      *(_QWORD *)v14 = 0;
      *((_QWORD *)v14 + 4) = 0;
      v14 += 40;
    }
    while (v14 != v15);
    v16[2] = v15;
    std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__swap_out_circular_buffer(a1, v16);
    return std::__split_buffer<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::~__split_buffer((uint64_t)v16);
  }
  return result;
}

void sub_2165B5440(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = result;
  v5 = (_QWORD *)*result;
  v4 = (_QWORD *)result[1];
  v6 = a2[1];
  while (v4 != v5)
  {
    v7 = *(v4 - 5);
    v4 -= 5;
    *v4 = 0;
    *(_QWORD *)(v6 - 40) = v7;
    v6 -= 40;
    result = (uint64_t *)std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100](v6 + 8, (uint64_t)(v4 + 1));
  }
  a2[1] = v6;
  v8 = *v3;
  *v3 = v6;
  a2[1] = v8;
  v9 = v3[1];
  v3[1] = a2[2];
  a2[2] = v9;
  v10 = v3[2];
  v3[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 40;
    std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)(i - 40));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::CardioidDirectivity>(Phase::Geometry::CardioidDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::CardioidDirectivity>(Phase::Geometry::CardioidDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::CardioidDirectivity>(Phase::Geometry::CardioidDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::CardioidDirectivity>(Phase::Geometry::CardioidDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57CCC0;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::CardioidDirectivity>(Phase::Geometry::CardioidDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::CardioidDirectivity>(Phase::Geometry::CardioidDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57CCC0;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::CardioidDirectivity>(Phase::Geometry::CardioidDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::CardioidDirectivity>(Phase::Geometry::CardioidDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
    JUMPOUT(0x2199F9D70);
  return result;
}

uint64_t *std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t *v2;
  uint64_t v3;

  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::reset[abi:ne180100](a1, 0);
  v2 = (uint64_t *)a1[4];
  if (v2 == a1 + 1)
  {
    v3 = 4;
    v2 = a1 + 1;
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return a1;
}

uint64_t *std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v4 = v2;
    v3 = result[4];
    if (!v3)
      std::__throw_bad_function_call[abi:ne180100]();
    return (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v4);
  }
  return result;
}

uint64_t (*Phase::GetTypeId<Phase::Geometry::ConeDirectivity>())()
{
  return Phase::GetTypeId<Phase::Geometry::ConeDirectivity>;
}

uint64_t *Phase::Geometry::CreateConeDirectivity@<X0>(_QWORD *a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t **v3;
  uint64_t v4;
  _QWORD *v5;
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *result;
  __int128 v13[2];
  _QWORD v14[3];
  _QWORD *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v13[0] = "DirectivityDataMapSize";
  *((_QWORD *)&v13[0] + 1) = 22;
  if (a1 && (v3 = Phase::UnorderedStringMap<Phase::OptionsValue>::Find(a1, v13)) != 0 && *((_DWORD *)v3 + 24) == 1)
  {
    LODWORD(v4) = *((_DWORD *)v3 + 14);
    if ((int)v4 <= 0)
      std::terminate();
  }
  else
  {
    LODWORD(v4) = 1;
  }
  v5 = operator new(0x58uLL);
  v5[1] = 0;
  v5[2] = 0;
  *v5 = &off_24D57CC88;
  *((_DWORD *)v5 + 6) = 2;
  v6 = (char *)(v5 + 3);
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  v5[10] = 0;
  *((_OWORD *)v5 + 4) = 0u;
  v7 = v5 + 8;
  v4 = v4;
  *a2 = v5 + 3;
  a2[1] = v5;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v5 + 8, v4);
  v8 = 0;
  do
  {
    v9 = operator new();
    *(_QWORD *)v9 = Phase::GetTypeId<Phase::Geometry::ConeDirectivity>;
    *(_QWORD *)(v9 + 8) = v6;
    *(_OWORD *)(v9 + 16) = 0u;
    *(_OWORD *)(v9 + 32) = 0u;
    *(_OWORD *)(v9 + 48) = 0u;
    *(_OWORD *)(v9 + 64) = 0u;
    *(_OWORD *)(v9 + 80) = 0u;
    *(_OWORD *)(v9 + 96) = 0u;
    *(_OWORD *)(v9 + 112) = 0u;
    *(_OWORD *)(v9 + 128) = 0u;
    *(_OWORD *)(v9 + 144) = 0u;
    *(_OWORD *)(v9 + 160) = 0u;
    *(_OWORD *)(v9 + 176) = 0u;
    *(_OWORD *)(v9 + 192) = 0u;
    *(_OWORD *)(v9 + 208) = 0u;
    *(_OWORD *)(v9 + 224) = 0u;
    *(_OWORD *)(v9 + 240) = 0u;
    *(_OWORD *)(v9 + 256) = 0u;
    *(_OWORD *)(v9 + 272) = 0u;
    *(_OWORD *)(v9 + 288) = 0u;
    *(_OWORD *)(v9 + 304) = 0u;
    *(_OWORD *)(v9 + 320) = 0u;
    *(_OWORD *)(v9 + 336) = 0u;
    *(_OWORD *)(v9 + 352) = 0u;
    *(_OWORD *)(v9 + 368) = 0u;
    *(_OWORD *)(v9 + 384) = 0u;
    *(_OWORD *)(v9 + 400) = 0u;
    *(_OWORD *)(v9 + 416) = 0u;
    *(_OWORD *)(v9 + 432) = 0u;
    *(_OWORD *)(v9 + 448) = 0u;
    *(_OWORD *)(v9 + 464) = 0u;
    *(_OWORD *)(v9 + 480) = 0u;
    *(_OWORD *)(v9 + 496) = 0u;
    *(_OWORD *)(v9 + 512) = 0u;
    v14[0] = &off_24D57CD08;
    v15 = v14;
    *(_QWORD *)&v13[0] = v9;
    std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v13 + 8, (uint64_t)v14);
    v10 = v15;
    if (v15 == v14)
    {
      v10 = v14;
      v11 = 4;
    }
    else
    {
      if (!v15)
        goto LABEL_13;
      v11 = 5;
    }
    (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_13:
    std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(*v7 + v8), (uint64_t *)v13);
    result = std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v13);
    v8 += 40;
    --v4;
  }
  while (v4);
  return result;
}

void sub_2165B5840(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t *Phase::Geometry::CreateConeDirectivityFromDirectivity@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  char *v5;
  _QWORD *v6;
  uint64_t *result;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _OWORD *v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD v41[3];
  _QWORD *v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)a1 != 2)
    std::terminate();
  v4 = operator new(0x58uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_24D57CC88;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  v4[10] = 0;
  *((_DWORD *)v4 + 6) = 2;
  v5 = (char *)(v4 + 3);
  *((_OWORD *)v4 + 4) = 0u;
  v6 = v4 + 8;
  *a2 = v4 + 3;
  a2[1] = v4;
  result = std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v4 + 8, 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 48) - *(_QWORD *)(a1 + 40)) >> 3));
  v8 = *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)(a1 + 48) != v8)
  {
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *(_OWORD **)(v8 + v9);
      v12 = operator new();
      *(_QWORD *)v12 = Phase::GetTypeId<Phase::Geometry::ConeDirectivity>;
      *(_QWORD *)(v12 + 8) = v5;
      v13 = v11[1];
      v14 = v11[2];
      v15 = v11[4];
      *(_OWORD *)(v12 + 48) = v11[3];
      *(_OWORD *)(v12 + 64) = v15;
      *(_OWORD *)(v12 + 16) = v13;
      *(_OWORD *)(v12 + 32) = v14;
      v16 = v11[5];
      v17 = v11[6];
      v18 = v11[8];
      *(_OWORD *)(v12 + 112) = v11[7];
      *(_OWORD *)(v12 + 128) = v18;
      *(_OWORD *)(v12 + 80) = v16;
      *(_OWORD *)(v12 + 96) = v17;
      v19 = v11[16];
      v21 = v11[13];
      v20 = v11[14];
      *(_OWORD *)(v12 + 240) = v11[15];
      *(_OWORD *)(v12 + 256) = v19;
      *(_OWORD *)(v12 + 208) = v21;
      *(_OWORD *)(v12 + 224) = v20;
      v22 = v11[9];
      v23 = v11[10];
      v24 = v11[12];
      *(_OWORD *)(v12 + 176) = v11[11];
      *(_OWORD *)(v12 + 192) = v24;
      *(_OWORD *)(v12 + 144) = v22;
      *(_OWORD *)(v12 + 160) = v23;
      v25 = v11[24];
      v27 = v11[21];
      v26 = v11[22];
      *(_OWORD *)(v12 + 368) = v11[23];
      *(_OWORD *)(v12 + 384) = v25;
      *(_OWORD *)(v12 + 336) = v27;
      *(_OWORD *)(v12 + 352) = v26;
      v28 = v11[17];
      v29 = v11[18];
      v30 = v11[20];
      *(_OWORD *)(v12 + 304) = v11[19];
      *(_OWORD *)(v12 + 320) = v30;
      *(_OWORD *)(v12 + 272) = v28;
      *(_OWORD *)(v12 + 288) = v29;
      v31 = v11[25];
      v32 = v11[26];
      v33 = v11[28];
      *(_OWORD *)(v12 + 432) = v11[27];
      *(_OWORD *)(v12 + 448) = v33;
      *(_OWORD *)(v12 + 400) = v31;
      *(_OWORD *)(v12 + 416) = v32;
      v34 = v11[29];
      v35 = v11[30];
      v36 = v11[32];
      *(_OWORD *)(v12 + 496) = v11[31];
      *(_OWORD *)(v12 + 512) = v36;
      *(_OWORD *)(v12 + 464) = v34;
      *(_OWORD *)(v12 + 480) = v35;
      v41[0] = &off_24D57CD08;
      v42 = v41;
      v39 = v12;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v40, (uint64_t)v41);
      v37 = v42;
      if (v42 == v41)
        break;
      if (v42)
      {
        v38 = 5;
LABEL_8:
        (*(void (**)(void))(*v37 + 8 * v38))();
      }
      std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(*v6 + v9), &v39);
      result = std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v39);
      ++v10;
      v8 = *(_QWORD *)(a1 + 40);
      v9 += 40;
      if (0xCCCCCCCCCCCCCCCDLL * ((*(_QWORD *)(a1 + 48) - v8) >> 3) <= v10)
        return result;
    }
    v37 = v41;
    v38 = 4;
    goto LABEL_8;
  }
  return result;
}

void sub_2165B5A98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](a10);
  _Unwind_Resume(a1);
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::ConeDirectivity>(Phase::Geometry::ConeDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::ConeDirectivity>(Phase::Geometry::ConeDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::ConeDirectivity>(Phase::Geometry::ConeDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::ConeDirectivity>(Phase::Geometry::ConeDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57CD08;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::ConeDirectivity>(Phase::Geometry::ConeDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::ConeDirectivity>(Phase::Geometry::ConeDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57CD08;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::ConeDirectivity>(Phase::Geometry::ConeDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::ConeDirectivity>(Phase::Geometry::ConeDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
    JUMPOUT(0x2199F9D70);
  return result;
}

uint64_t Phase::Geometry::DirectivityFactory::Create@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  uint64_t result;

  v3 = *(_QWORD *)(*(_QWORD *)a1 + 224);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)a1 + 232) - v3) >> 5) <= a2)
    __assert_rtn("GetTypeDef", "GeoDirectivityTypeRegistry.cpp", 33, "IsValid(inDirectivityType)");
  result = *(_QWORD *)(v3 + 96 * a2 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  *a3 = 0;
  a3[1] = 0;
  return result;
}

_QWORD *Phase::Geometry::DirectivityTypeRegistry::CustomizeType(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 16) - v3) >> 5) <= a2)
    __assert_rtn("CustomizeType", "GeoDirectivityTypeRegistry.cpp", 43, "IsValid(inDirectivityType)");
  return std::function<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((_QWORD *)(v3 + 96 * a2 + 8), a3);
}

{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 16) - v3) >> 5) <= a2)
    __assert_rtn("CustomizeType", "GeoDirectivityTypeRegistry.cpp", 54, "IsValid(inDirectivityType)");
  return std::function<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((_QWORD *)(v3 + 96 * a2 + 40), a3);
}

_QWORD *std::function<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

_QWORD *std::function<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::vector<Phase::Geometry::DirectivityTypeDefinition>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 5);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<Phase::Geometry::DirectivityTypeDefinition>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 96 * a2;
    while (v3 != v7)
    {
      v3 -= 96;
      std::allocator<Phase::Geometry::DirectivityTypeDefinition>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
    }
    a1[1] = v7;
  }
}

_QWORD *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_2165B5FA4(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_2165B6118(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t std::vector<Phase::Geometry::DirectivityTypeDefinition>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::DirectivityTypeDefinition>,std::reverse_iterator<Phase::Geometry::DirectivityTypeDefinition*>,std::reverse_iterator<Phase::Geometry::DirectivityTypeDefinition*>,std::reverse_iterator<Phase::Geometry::DirectivityTypeDefinition*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void std::vector<Phase::Geometry::DirectivityTypeDefinition>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::DirectivityTypeDefinition>,std::reverse_iterator<Phase::Geometry::DirectivityTypeDefinition*>,std::reverse_iterator<Phase::Geometry::DirectivityTypeDefinition*>,std::reverse_iterator<Phase::Geometry::DirectivityTypeDefinition*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;

  if (a3 != a5)
  {
    v11 = 0;
    v12 = a3;
    while (1)
    {
      v13 = a7 + v11;
      v14 = a3 + v11;
      *(_QWORD *)(a7 + v11 - 96) = *(_QWORD *)(a3 + v11 - 96);
      v15 = *(_QWORD *)(a3 + v11 - 64);
      if (!v15)
        break;
      if (v14 - 88 != v15)
      {
        v16 = (_QWORD *)(v12 - 64);
        *(_QWORD *)(v13 - 64) = v15;
LABEL_7:
        *v16 = 0;
        goto LABEL_9;
      }
      *(_QWORD *)(v13 - 64) = v13 - 88;
      (*(void (**)(_QWORD))(**(_QWORD **)(v14 - 64) + 24))(*(_QWORD *)(v14 - 64));
LABEL_9:
      v17 = a7 + v11;
      v18 = a3 + v11;
      v19 = *(_QWORD *)(a3 + v11 - 32);
      if (v19)
      {
        if (v18 - 56 == v19)
        {
          *(_QWORD *)(v17 - 32) = v17 - 56;
          (*(void (**)(_QWORD))(**(_QWORD **)(v18 - 32) + 24))(*(_QWORD *)(v18 - 32));
          goto LABEL_15;
        }
        v20 = (_QWORD *)(v12 - 32);
        *(_QWORD *)(v17 - 32) = v19;
      }
      else
      {
        v20 = (_QWORD *)(v17 - 32);
      }
      *v20 = 0;
LABEL_15:
      v12 -= 96;
      v21 = a7 + v11;
      v22 = a3 + v11;
      *(_QWORD *)(v21 - 24) = 0;
      *(_QWORD *)(v21 - 16) = 0;
      *(_QWORD *)(v21 - 8) = 0;
      *(_OWORD *)(v21 - 24) = *(_OWORD *)(a3 + v11 - 24);
      *(_QWORD *)(v21 - 8) = *(_QWORD *)(a3 + v11 - 8);
      *(_QWORD *)(v22 - 24) = 0;
      *(_QWORD *)(v22 - 16) = 0;
      *(_QWORD *)(v22 - 8) = 0;
      v11 -= 96;
      if (a3 + v11 == a5)
        return a6;
    }
    v16 = (_QWORD *)(v13 - 64);
    goto LABEL_7;
  }
  return a6;
}

_QWORD *std::allocator<Phase::Geometry::DirectivityTypeDefinition>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *result;
  uint64_t v7;
  void **v8;

  v3 = (_QWORD *)(a2 + 8);
  v8 = (void **)(a2 + 72);
  std::vector<Phase::Envelope<float>::Segment,std::allocator<Phase::Envelope<float>::Segment>>::__destroy_vector::operator()[abi:ne180100](&v8);
  v4 = *(_QWORD **)(a2 + 64);
  if (v4 == (_QWORD *)(a2 + 40))
  {
    v5 = 4;
    v4 = (_QWORD *)(a2 + 40);
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  result = *(_QWORD **)(a2 + 32);
  if (result == v3)
  {
    v7 = 4;
    result = v3;
  }
  else
  {
    if (!result)
      return result;
    v7 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v7))();
}

void **std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::~__split_buffer(void **a1)
{
  std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

_QWORD *std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::clear[abi:ne180100](_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = result[1];
  v1 = result[2];
  if (v1 != v2)
  {
    v3 = result;
    do
    {
      v4 = v3[4];
      v3[2] = v1 - 96;
      result = std::allocator<Phase::Geometry::DirectivityTypeDefinition>::destroy[abi:ne180100](v4, v1 - 96);
      v1 = v3[2];
    }
    while (v1 != v2);
  }
  return result;
}

void std::vector<Phase::Geometry::DirectivityTypeDefinition>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  void *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 5) >= a2)
  {
    if (a2)
    {
      v13 = 96 * ((96 * a2 - 96) / 0x60) + 96;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 5);
    v9 = v8 + a2;
    if (v8 + a2 > 0x2AAAAAAAAAAAAAALL)
      std::vector<Phase::Geometry::DirectivityTypeDefinition>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 5);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x155555555555555)
      v11 = 0x2AAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::VoiceData>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[96 * v8];
    v18 = &v12[96 * v11];
    v14 = 96 * ((96 * a2 - 96) / 0x60) + 96;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<Phase::Geometry::DirectivityTypeDefinition>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::~__split_buffer(&v15);
  }
}

void sub_2165B653C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::DistanceModelFactory::Create@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  uint64_t result;

  v3 = *(_QWORD *)(*(_QWORD *)a1 + 472);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)a1 + 480) - v3) >> 5) <= a2)
    __assert_rtn("GetTypeDef", "GeoDistanceModelTypeRegistry.cpp", 33, "IsValid(inDistanceModelType)");
  result = *(_QWORD *)(v3 + 96 * a2 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  *a3 = 0;
  a3[1] = 0;
  return result;
}

_QWORD *Phase::Geometry::DistanceModelTypeRegistry::CustomizeType(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 16) - v3) >> 5) <= a2)
    __assert_rtn("CustomizeType", "GeoDistanceModelTypeRegistry.cpp", 43, "IsValid(inDistanceModelType)");
  return std::function<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((_QWORD *)(v3 + 96 * a2 + 8), a3);
}

{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 16) - v3) >> 5) <= a2)
    __assert_rtn("CustomizeType", "GeoDistanceModelTypeRegistry.cpp", 54, "IsValid(inDistanceModelType)");
  return std::function<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((_QWORD *)(v3 + 96 * a2 + 40), a3);
}

_QWORD *std::function<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

_QWORD *std::function<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::vector<Phase::Geometry::DistanceModelTypeDefinition>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 5);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<Phase::Geometry::DistanceModelTypeDefinition>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 96 * a2;
    while (v3 != v7)
    {
      v3 -= 96;
      std::allocator<Phase::Geometry::DirectivityTypeDefinition>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
    }
    a1[1] = v7;
  }
}

_QWORD *std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_2165B69D0(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_2165B6B44(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t std::vector<Phase::Geometry::DistanceModelTypeDefinition>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::DistanceModelTypeDefinition>,std::reverse_iterator<Phase::Geometry::DistanceModelTypeDefinition*>,std::reverse_iterator<Phase::Geometry::DistanceModelTypeDefinition*>,std::reverse_iterator<Phase::Geometry::DistanceModelTypeDefinition*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void std::vector<Phase::Geometry::DistanceModelTypeDefinition>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::DistanceModelTypeDefinition>,std::reverse_iterator<Phase::Geometry::DistanceModelTypeDefinition*>,std::reverse_iterator<Phase::Geometry::DistanceModelTypeDefinition*>,std::reverse_iterator<Phase::Geometry::DistanceModelTypeDefinition*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;

  if (a3 != a5)
  {
    v11 = 0;
    v12 = a3;
    while (1)
    {
      v13 = a7 + v11;
      v14 = a3 + v11;
      *(_QWORD *)(a7 + v11 - 96) = *(_QWORD *)(a3 + v11 - 96);
      v15 = *(_QWORD *)(a3 + v11 - 64);
      if (!v15)
        break;
      if (v14 - 88 != v15)
      {
        v16 = (_QWORD *)(v12 - 64);
        *(_QWORD *)(v13 - 64) = v15;
LABEL_7:
        *v16 = 0;
        goto LABEL_9;
      }
      *(_QWORD *)(v13 - 64) = v13 - 88;
      (*(void (**)(_QWORD))(**(_QWORD **)(v14 - 64) + 24))(*(_QWORD *)(v14 - 64));
LABEL_9:
      v17 = a7 + v11;
      v18 = a3 + v11;
      v19 = *(_QWORD *)(a3 + v11 - 32);
      if (v19)
      {
        if (v18 - 56 == v19)
        {
          *(_QWORD *)(v17 - 32) = v17 - 56;
          (*(void (**)(_QWORD))(**(_QWORD **)(v18 - 32) + 24))(*(_QWORD *)(v18 - 32));
          goto LABEL_15;
        }
        v20 = (_QWORD *)(v12 - 32);
        *(_QWORD *)(v17 - 32) = v19;
      }
      else
      {
        v20 = (_QWORD *)(v17 - 32);
      }
      *v20 = 0;
LABEL_15:
      v12 -= 96;
      v21 = a7 + v11;
      v22 = a3 + v11;
      *(_QWORD *)(v21 - 24) = 0;
      *(_QWORD *)(v21 - 16) = 0;
      *(_QWORD *)(v21 - 8) = 0;
      *(_OWORD *)(v21 - 24) = *(_OWORD *)(a3 + v11 - 24);
      *(_QWORD *)(v21 - 8) = *(_QWORD *)(a3 + v11 - 8);
      *(_QWORD *)(v22 - 24) = 0;
      *(_QWORD *)(v22 - 16) = 0;
      *(_QWORD *)(v22 - 8) = 0;
      v11 -= 96;
      if (a3 + v11 == a5)
        return a6;
    }
    v16 = (_QWORD *)(v13 - 64);
    goto LABEL_7;
  }
  return a6;
}

void std::vector<Phase::Geometry::DistanceModelTypeDefinition>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  void *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 5) >= a2)
  {
    if (a2)
    {
      v13 = 96 * ((96 * a2 - 96) / 0x60) + 96;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 5);
    v9 = v8 + a2;
    if (v8 + a2 > 0x2AAAAAAAAAAAAAALL)
      std::vector<Phase::Geometry::DistanceModelTypeDefinition>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 5);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x155555555555555)
      v11 = 0x2AAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::VoiceData>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[96 * v8];
    v18 = &v12[96 * v11];
    v14 = 96 * ((96 * a2 - 96) / 0x60) + 96;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<Phase::Geometry::DistanceModelTypeDefinition>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::~__split_buffer(&v15);
  }
}

void sub_2165B6E60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::Entity::AddShape(_QWORD *a1, uint64_t a2)
{
  char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;

  v5 = (char *)a1[15];
  v6 = (char *)a1[16];
  v7 = (v6 - v5) >> 3;
  v8 = (uint64_t)(a1 + 17);
  v9 = a1[17];
  if ((unint64_t)v6 >= v9)
  {
    if ((unint64_t)(v7 + 1) >> 61)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v11 = v9 - (_QWORD)v5;
    v12 = (uint64_t)(v9 - (_QWORD)v5) >> 2;
    if (v12 <= v7 + 1)
      v12 = v7 + 1;
    if (v11 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(v8, v13);
      v5 = (char *)a1[15];
      v6 = (char *)a1[16];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[8 * v7];
    v16 = &v14[8 * v13];
    *(_QWORD *)v15 = a2;
    v10 = v15 + 8;
    while (v6 != v5)
    {
      v17 = *((_QWORD *)v6 - 1);
      v6 -= 8;
      *((_QWORD *)v15 - 1) = v17;
      v15 -= 8;
    }
    a1[15] = v15;
    a1[16] = v10;
    a1[17] = v16;
    if (v5)
      operator delete(v5);
  }
  else
  {
    *(_QWORD *)v6 = a2;
    v10 = v6 + 8;
  }
  a1[16] = v10;
  return v7;
}

BOOL Phase::Geometry::Entity::AddChild(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  unint64_t v6;
  char *v7;
  _QWORD *v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;

  v2 = *(_QWORD *)(a2 + 88);
  if (!v2)
  {
    v5 = (uint64_t)(a1 + 14);
    v6 = a1[14];
    v7 = (char *)a1[13];
    if ((unint64_t)v7 >= v6)
    {
      v9 = (char *)a1[12];
      v10 = (v7 - v9) >> 3;
      if ((unint64_t)(v10 + 1) >> 61)
        std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
      v11 = v6 - (_QWORD)v9;
      v12 = (uint64_t)(v6 - (_QWORD)v9) >> 2;
      if (v12 <= v10 + 1)
        v12 = v10 + 1;
      if (v11 >= 0x7FFFFFFFFFFFFFF8)
        v13 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v13 = v12;
      if (v13)
      {
        v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(v5, v13);
        v9 = (char *)a1[12];
        v7 = (char *)a1[13];
      }
      else
      {
        v14 = 0;
      }
      v15 = &v14[8 * v10];
      v16 = &v14[8 * v13];
      *(_QWORD *)v15 = *(_QWORD *)(a2 + 8);
      v8 = v15 + 8;
      while (v7 != v9)
      {
        v17 = *((_QWORD *)v7 - 1);
        v7 -= 8;
        *((_QWORD *)v15 - 1) = v17;
        v15 -= 8;
      }
      a1[12] = v15;
      a1[13] = v8;
      a1[14] = v16;
      if (v9)
        operator delete(v9);
    }
    else
    {
      *(_QWORD *)v7 = *(_QWORD *)(a2 + 8);
      v8 = v7 + 8;
    }
    a1[13] = v8;
    *(_QWORD *)(a2 + 88) = a1[1];
    *(_BYTE *)(a2 + 80) = 1;
  }
  return v2 == 0;
}

uint64_t Phase::Geometry::Entity::RemoveChild(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  _QWORD *i;
  uint64_t result;

  if (a1[1] != *(_QWORD *)(a2 + 88))
    return 0;
  v3 = a1[12];
  v2 = a1[13];
  if (v2 == v3)
    return 0;
  v4 = (v2 - v3) >> 3;
  if (v4 <= 1)
    v5 = 1;
  else
    v5 = (v2 - v3) >> 3;
  for (i = (_QWORD *)a1[12]; *(_QWORD *)(a2 + 8) != *i; ++i)
  {
    if (!--v5)
      return 0;
  }
  *i = *(_QWORD *)(v3 + 8 * v4 - 8);
  a1[13] = v2 - 8;
  *(_QWORD *)(a2 + 88) = 0;
  result = 1;
  *(_BYTE *)(a2 + 80) = 1;
  return result;
}

_QWORD *Phase::Geometry::EntityFactory::Create@<X0>(int a1@<W1>, uint64_t a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *result;

  switch(a1)
  {
    case 1:
      result = Phase::Geometry::CreateEntity<Phase::Geometry::Entity>(a2, a3);
      break;
    case 2:
      result = Phase::Geometry::CreateEntity<Phase::Geometry::Listener>(a2, a3);
      break;
    case 3:
      result = Phase::Geometry::CreateEntity<Phase::Geometry::Source>(a2, a3);
      break;
    case 4:
      result = Phase::Geometry::CreateEntity<Phase::Geometry::Occluder>(a2, a3);
      break;
    case 5:
      result = Phase::Geometry::CreateEntity<Phase::Geometry::Environment>(a2, a3);
      break;
    default:
      *a3 = 0;
      a3[1] = 0;
      break;
  }
  return result;
}

_QWORD *Phase::Geometry::CreateEntity<Phase::Geometry::Entity>@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  _QWORD *result;

  v4 = operator new();
  *(_DWORD *)v4 = 1;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 28) = 1065353216;
  *(_QWORD *)(v4 + 36) = 0;
  *(_OWORD *)(v4 + 44) = xmmword_2166F8010;
  *(_QWORD *)(v4 + 60) = 1065353216;
  *(_QWORD *)(v4 + 68) = 0;
  *(_DWORD *)(v4 + 76) = 1065353216;
  *(_BYTE *)(v4 + 80) = 0;
  *(_OWORD *)(v4 + 88) = 0u;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_OWORD *)(v4 + 120) = 0u;
  *(_QWORD *)(v4 + 136) = 0;
  *(_QWORD *)(v4 + 144) = 0xFFFFFFFFLL;
  result = std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(a2, v4);
  if (a1)
    __assert_rtn("CreateEntity", "GeoEntityFactory.cpp", 39, "false");
  return result;
}

void sub_2165B7210(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

_QWORD *Phase::Geometry::CreateEntity<Phase::Geometry::Environment>@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  _QWORD *result;

  v4 = operator new();
  *(_DWORD *)v4 = 5;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 28) = 1065353216;
  *(_QWORD *)(v4 + 36) = 0;
  *(_OWORD *)(v4 + 44) = xmmword_2166F8010;
  *(_QWORD *)(v4 + 60) = 1065353216;
  *(_QWORD *)(v4 + 68) = 0;
  *(_DWORD *)(v4 + 76) = 1065353216;
  *(_BYTE *)(v4 + 80) = 0;
  *(_OWORD *)(v4 + 88) = 0u;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_OWORD *)(v4 + 120) = 0u;
  *(_QWORD *)(v4 + 136) = 0;
  *(_OWORD *)(v4 + 144) = xmmword_2166F82E0;
  *(_DWORD *)(v4 + 160) = 1065353216;
  result = std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(a2, v4);
  if (a1)
    __assert_rtn("CreateEntity", "GeoEntityFactory.cpp", 39, "false");
  return result;
}

void sub_2165B72F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

_QWORD *Phase::Geometry::CreateEntity<Phase::Geometry::Listener>@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  _QWORD *result;

  v4 = operator new();
  *(_DWORD *)v4 = 2;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 28) = 1065353216;
  *(_QWORD *)(v4 + 36) = 0;
  *(_OWORD *)(v4 + 44) = xmmword_2166F8010;
  *(_QWORD *)(v4 + 60) = 1065353216;
  *(_QWORD *)(v4 + 68) = 0;
  *(_DWORD *)(v4 + 76) = 1065353216;
  *(_BYTE *)(v4 + 80) = 0;
  *(_OWORD *)(v4 + 88) = 0u;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_OWORD *)(v4 + 120) = 0u;
  *(_QWORD *)(v4 + 136) = 0;
  *(_QWORD *)(v4 + 144) = 0xFFFFFFFFLL;
  *(_QWORD *)(v4 + 152) = 0x3FB999999999999ALL;
  *(_DWORD *)(v4 + 160) = 0;
  *(_QWORD *)(v4 + 164) = 0;
  *(_QWORD *)(v4 + 184) = 0;
  *(_QWORD *)(v4 + 192) = 0;
  *(_QWORD *)(v4 + 176) = 0x3FF0000000000000;
  result = std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(a2, v4);
  if (a1)
    __assert_rtn("CreateEntity", "GeoEntityFactory.cpp", 39, "false");
  return result;
}

void sub_2165B73F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

_QWORD *Phase::Geometry::CreateEntity<Phase::Geometry::Occluder>@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  _QWORD *result;

  v4 = operator new();
  *(_DWORD *)v4 = 4;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 28) = 1065353216;
  *(_QWORD *)(v4 + 36) = 0;
  *(_OWORD *)(v4 + 44) = xmmword_2166F8010;
  *(_QWORD *)(v4 + 60) = 1065353216;
  *(_QWORD *)(v4 + 68) = 0;
  *(_DWORD *)(v4 + 76) = 1065353216;
  *(_BYTE *)(v4 + 80) = 0;
  *(_OWORD *)(v4 + 88) = 0u;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_OWORD *)(v4 + 120) = 0u;
  *(_QWORD *)(v4 + 136) = 0;
  *(_QWORD *)(v4 + 144) = 0xFFFFFFFFLL;
  *(_DWORD *)(v4 + 152) = 1065353216;
  *(_BYTE *)(v4 + 156) = 0;
  result = std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(a2, v4);
  if (a1)
    __assert_rtn("CreateEntity", "GeoEntityFactory.cpp", 39, "false");
  return result;
}

void sub_2165B74D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

_QWORD *Phase::Geometry::CreateEntity<Phase::Geometry::Source>@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  _QWORD *result;

  v4 = operator new();
  *(_DWORD *)v4 = 3;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 28) = 1065353216;
  *(_QWORD *)(v4 + 36) = 0;
  *(_OWORD *)(v4 + 44) = xmmword_2166F8010;
  *(_QWORD *)(v4 + 60) = 1065353216;
  *(_QWORD *)(v4 + 68) = 0;
  *(_DWORD *)(v4 + 76) = 1065353216;
  *(_BYTE *)(v4 + 80) = 0;
  *(_OWORD *)(v4 + 88) = 0u;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_OWORD *)(v4 + 120) = 0u;
  *(_QWORD *)(v4 + 136) = 0;
  *(_QWORD *)(v4 + 144) = 0xFFFFFFFFLL;
  *(_QWORD *)(v4 + 152) = 10;
  *(_QWORD *)(v4 + 160) = 0;
  *(_QWORD *)(v4 + 176) = 0;
  *(_QWORD *)(v4 + 184) = 0;
  *(_QWORD *)(v4 + 168) = 0x3FF0000000000000;
  result = std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(a2, v4);
  if (a1)
    __assert_rtn("CreateEntity", "GeoEntityFactory.cpp", 39, "false");
  return result;
}

void sub_2165B75BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::EntityFactory::Create@<X0>(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t result;

  switch(*(_DWORD *)a1)
  {
    case 1:
      result = (uint64_t)Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Entity>(a1, a2);
      break;
    case 2:
      result = Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Listener>(a1, a2);
      break;
    case 3:
      result = Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Source>(a1, a2);
      break;
    case 4:
      result = (uint64_t)Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Occluder>(a1, a2);
      break;
    case 5:
      result = (uint64_t)Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Environment>(a1, a2);
      break;
    default:
      *a2 = 0;
      a2[1] = 0;
      break;
  }
  return result;
}

_QWORD *Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Entity>@<X0>(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  _QWORD *result;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  v4 = operator new();
  *(_DWORD *)v4 = 1;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 28) = 1065353216;
  *(_QWORD *)(v4 + 36) = 0;
  *(_OWORD *)(v4 + 44) = xmmword_2166F8010;
  *(_QWORD *)(v4 + 60) = 1065353216;
  *(_QWORD *)(v4 + 68) = 0;
  *(_DWORD *)(v4 + 76) = 1065353216;
  *(_BYTE *)(v4 + 80) = 0;
  *(_OWORD *)(v4 + 88) = 0u;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_OWORD *)(v4 + 120) = 0u;
  *(_QWORD *)(v4 + 136) = 0;
  *(_QWORD *)(v4 + 144) = 0xFFFFFFFFLL;
  *a2 = v4;
  result = (_QWORD *)operator new();
  v6 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)v4 = *(_OWORD *)a1;
  *(_OWORD *)(v4 + 16) = v6;
  v7 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(v4 + 32) = *(_OWORD *)(a1 + 32);
  *(_OWORD *)(v4 + 48) = v7;
  v8 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)(v4 + 64) = *(_OWORD *)(a1 + 64);
  *result = &off_24D57CE68;
  result[1] = 0;
  result[2] = 0;
  result[3] = v4;
  a2[1] = (uint64_t)result;
  *(_OWORD *)(v4 + 80) = v8;
  if (v4 != a1)
  {
    std::vector<Phase::SpatialModeler::DirectivityHistogram *>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::DirectivityHistogram **,Phase::SpatialModeler::DirectivityHistogram **>((char *)(v4 + 96), *(char **)(a1 + 96), *(_QWORD *)(a1 + 104), (uint64_t)(*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96)) >> 3);
    result = std::vector<Phase::SpatialModeler::DirectivityHistogram *>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::DirectivityHistogram **,Phase::SpatialModeler::DirectivityHistogram **>((char *)(v4 + 120), *(char **)(a1 + 120), *(_QWORD *)(a1 + 128), (uint64_t)(*(_QWORD *)(a1 + 128) - *(_QWORD *)(a1 + 120)) >> 3);
  }
  *(_QWORD *)(v4 + 144) = *(_QWORD *)(a1 + 144);
  return result;
}

void sub_2165B7760(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(v1);
  __cxa_rethrow();
}

void sub_2165B7774(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Environment>@<X0>(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  _QWORD *result;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v4 = operator new();
  *(_DWORD *)v4 = 5;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 28) = 1065353216;
  *(_QWORD *)(v4 + 36) = 0;
  *(_OWORD *)(v4 + 44) = xmmword_2166F8010;
  *(_QWORD *)(v4 + 60) = 1065353216;
  *(_QWORD *)(v4 + 68) = 0;
  *(_DWORD *)(v4 + 76) = 1065353216;
  *(_BYTE *)(v4 + 80) = 0;
  *(_OWORD *)(v4 + 88) = 0u;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_OWORD *)(v4 + 120) = 0u;
  *(_QWORD *)(v4 + 136) = 0;
  *(_OWORD *)(v4 + 144) = xmmword_2166F82E0;
  *(_DWORD *)(v4 + 160) = 1065353216;
  *a2 = v4;
  result = (_QWORD *)operator new();
  v6 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)v4 = *(_OWORD *)a1;
  *(_OWORD *)(v4 + 16) = v6;
  v7 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(v4 + 32) = *(_OWORD *)(a1 + 32);
  *(_OWORD *)(v4 + 48) = v7;
  v8 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)(v4 + 64) = *(_OWORD *)(a1 + 64);
  *result = &off_24D57CEA0;
  result[1] = 0;
  result[2] = 0;
  result[3] = v4;
  a2[1] = (uint64_t)result;
  *(_OWORD *)(v4 + 80) = v8;
  if (v4 != a1)
  {
    std::vector<Phase::SpatialModeler::DirectivityHistogram *>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::DirectivityHistogram **,Phase::SpatialModeler::DirectivityHistogram **>((char *)(v4 + 96), *(char **)(a1 + 96), *(_QWORD *)(a1 + 104), (uint64_t)(*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96)) >> 3);
    result = std::vector<Phase::SpatialModeler::DirectivityHistogram *>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::DirectivityHistogram **,Phase::SpatialModeler::DirectivityHistogram **>((char *)(v4 + 120), *(char **)(a1 + 120), *(_QWORD *)(a1 + 128), (uint64_t)(*(_QWORD *)(a1 + 128) - *(_QWORD *)(a1 + 120)) >> 3);
  }
  v9 = *(_QWORD *)(a1 + 152);
  *(_QWORD *)(v4 + 144) = *(_QWORD *)(a1 + 144);
  *(_QWORD *)(v4 + 152) = v9;
  *(_DWORD *)(v4 + 160) = *(_DWORD *)(a1 + 160);
  return result;
}

void sub_2165B78D0(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(v1);
  __cxa_rethrow();
}

void sub_2165B78E4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Listener>@<X0>(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v4;

  v4 = operator new();
  *(_DWORD *)v4 = 2;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 28) = 1065353216;
  *(_QWORD *)(v4 + 36) = 0;
  *(_OWORD *)(v4 + 44) = xmmword_2166F8010;
  *(_QWORD *)(v4 + 60) = 1065353216;
  *(_QWORD *)(v4 + 68) = 0;
  *(_DWORD *)(v4 + 76) = 1065353216;
  *(_BYTE *)(v4 + 80) = 0;
  *(_OWORD *)(v4 + 88) = 0u;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_OWORD *)(v4 + 120) = 0u;
  *(_QWORD *)(v4 + 136) = 0;
  *(_QWORD *)(v4 + 144) = 0xFFFFFFFFLL;
  *(_QWORD *)(v4 + 152) = 0x3FB999999999999ALL;
  *(_DWORD *)(v4 + 160) = 0;
  *(_QWORD *)(v4 + 164) = 0;
  *(_QWORD *)(v4 + 184) = 0;
  *(_QWORD *)(v4 + 192) = 0;
  *(_QWORD *)(v4 + 176) = 0x3FF0000000000000;
  std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(a2, v4);
  return Phase::Geometry::Listener::operator=(*a2, a1);
}

void sub_2165B79D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

_QWORD *Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Occluder>@<X0>(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  _QWORD *result;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  v4 = operator new();
  *(_DWORD *)v4 = 4;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 28) = 1065353216;
  *(_QWORD *)(v4 + 36) = 0;
  *(_OWORD *)(v4 + 44) = xmmword_2166F8010;
  *(_QWORD *)(v4 + 60) = 1065353216;
  *(_QWORD *)(v4 + 68) = 0;
  *(_DWORD *)(v4 + 76) = 1065353216;
  *(_BYTE *)(v4 + 80) = 0;
  *(_OWORD *)(v4 + 88) = 0u;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_OWORD *)(v4 + 120) = 0u;
  *(_QWORD *)(v4 + 136) = 0;
  *(_QWORD *)(v4 + 144) = 0xFFFFFFFFLL;
  *(_DWORD *)(v4 + 152) = 1065353216;
  *(_BYTE *)(v4 + 156) = 0;
  *a2 = v4;
  result = (_QWORD *)operator new();
  v6 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)v4 = *(_OWORD *)a1;
  *(_OWORD *)(v4 + 16) = v6;
  v7 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(v4 + 32) = *(_OWORD *)(a1 + 32);
  *(_OWORD *)(v4 + 48) = v7;
  v8 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)(v4 + 64) = *(_OWORD *)(a1 + 64);
  *result = &off_24D57CF10;
  result[1] = 0;
  result[2] = 0;
  result[3] = v4;
  a2[1] = (uint64_t)result;
  *(_OWORD *)(v4 + 80) = v8;
  if (v4 != a1)
  {
    std::vector<Phase::SpatialModeler::DirectivityHistogram *>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::DirectivityHistogram **,Phase::SpatialModeler::DirectivityHistogram **>((char *)(v4 + 96), *(char **)(a1 + 96), *(_QWORD *)(a1 + 104), (uint64_t)(*(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96)) >> 3);
    result = std::vector<Phase::SpatialModeler::DirectivityHistogram *>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::DirectivityHistogram **,Phase::SpatialModeler::DirectivityHistogram **>((char *)(v4 + 120), *(char **)(a1 + 120), *(_QWORD *)(a1 + 128), (uint64_t)(*(_QWORD *)(a1 + 128) - *(_QWORD *)(a1 + 120)) >> 3);
  }
  *(_QWORD *)(v4 + 144) = *(_QWORD *)(a1 + 144);
  *(_DWORD *)(v4 + 152) = *(_DWORD *)(a1 + 152);
  *(_BYTE *)(v4 + 156) = *(_BYTE *)(a1 + 156);
  return result;
}

void sub_2165B7B30(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(v1);
  __cxa_rethrow();
}

void sub_2165B7B44(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Source>@<X0>(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v4;

  v4 = operator new();
  *(_DWORD *)v4 = 3;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 28) = 1065353216;
  *(_QWORD *)(v4 + 36) = 0;
  *(_OWORD *)(v4 + 44) = xmmword_2166F8010;
  *(_QWORD *)(v4 + 60) = 1065353216;
  *(_QWORD *)(v4 + 68) = 0;
  *(_DWORD *)(v4 + 76) = 1065353216;
  *(_BYTE *)(v4 + 80) = 0;
  *(_OWORD *)(v4 + 88) = 0u;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_OWORD *)(v4 + 120) = 0u;
  *(_QWORD *)(v4 + 136) = 0;
  *(_QWORD *)(v4 + 144) = 0xFFFFFFFFLL;
  *(_QWORD *)(v4 + 152) = 10;
  *(_QWORD *)(v4 + 160) = 0;
  *(_QWORD *)(v4 + 176) = 0;
  *(_QWORD *)(v4 + 184) = 0;
  *(_QWORD *)(v4 + 168) = 0x3FF0000000000000;
  std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(a2, v4);
  return Phase::Geometry::Source::operator=(*a2, a1);
}

void sub_2165B7C24(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D57CD50;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_2165B7C94(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  _QWORD *v13;

  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_2165B7CAC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(uint64_t a1, _QWORD *a2)
{
  void *v3;
  void *v4;

  if (a2)
  {
    v3 = (void *)a2[15];
    if (v3)
    {
      a2[16] = v3;
      operator delete(v3);
    }
    v4 = (void *)a2[12];
    if (v4)
    {
      a2[13] = v4;
      operator delete(v4);
    }
    JUMPOUT(0x2199F9D70);
  }
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  _QWORD *v1;
  void *v2;
  void *v3;

  v1 = *(_QWORD **)(result + 24);
  if (v1)
  {
    v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

_QWORD *std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D57CD88;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_2165B7E00(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  _QWORD *v13;

  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_2165B7E18(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(uint64_t a1, _QWORD *a2)
{
  void *v3;
  void *v4;

  if (a2)
  {
    v3 = (void *)a2[15];
    if (v3)
    {
      a2[16] = v3;
      operator delete(v3);
    }
    v4 = (void *)a2[12];
    if (v4)
    {
      a2[13] = v4;
      operator delete(v4);
    }
    JUMPOUT(0x2199F9D70);
  }
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  _QWORD *v1;
  void *v2;
  void *v3;

  v1 = *(_QWORD **)(result + 24);
  if (v1)
  {
    v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

_QWORD *std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D57CDC0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_2165B7F6C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  _QWORD *v13;

  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_2165B7F84(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(uint64_t a1, _QWORD *a2)
{
  void *v3;
  void *v4;

  if (a2)
  {
    v3 = (void *)a2[15];
    if (v3)
    {
      a2[16] = v3;
      operator delete(v3);
    }
    v4 = (void *)a2[12];
    if (v4)
    {
      a2[13] = v4;
      operator delete(v4);
    }
    JUMPOUT(0x2199F9D70);
  }
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  _QWORD *v1;
  void *v2;
  void *v3;

  v1 = *(_QWORD **)(result + 24);
  if (v1)
  {
    v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

_QWORD *std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D57CDF8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_2165B80D8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  _QWORD *v13;

  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_2165B80F0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(uint64_t a1, _QWORD *a2)
{
  void *v3;
  void *v4;

  if (a2)
  {
    v3 = (void *)a2[15];
    if (v3)
    {
      a2[16] = v3;
      operator delete(v3);
    }
    v4 = (void *)a2[12];
    if (v4)
    {
      a2[13] = v4;
      operator delete(v4);
    }
    JUMPOUT(0x2199F9D70);
  }
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  _QWORD *v1;
  void *v2;
  void *v3;

  v1 = *(_QWORD **)(result + 24);
  if (v1)
  {
    v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

_QWORD *std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D57CE30;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_2165B8244(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  _QWORD *v13;

  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_2165B825C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(uint64_t a1, _QWORD *a2)
{
  void *v3;
  void *v4;

  if (a2)
  {
    v3 = (void *)a2[15];
    if (v3)
    {
      a2[16] = v3;
      operator delete(v3);
    }
    v4 = (void *)a2[12];
    if (v4)
    {
      a2[13] = v4;
      operator delete(v4);
    }
    JUMPOUT(0x2199F9D70);
  }
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  _QWORD *v1;
  void *v2;
  void *v3;

  v1 = *(_QWORD **)(result + 24);
  if (v1)
  {
    v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

_QWORD *std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(_QWORD *result)
{
  _QWORD *v1;
  void *v2;
  void *v3;

  if (result)
  {
    v1 = result;
    v2 = (void *)result[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  _QWORD *v1;
  void *v2;
  void *v3;

  v1 = *(_QWORD **)(result + 24);
  if (v1)
  {
    v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

_QWORD *std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(_QWORD *result)
{
  _QWORD *v1;
  void *v2;
  void *v3;

  if (result)
  {
    v1 = result;
    v2 = (void *)result[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  _QWORD *v1;
  void *v2;
  void *v3;

  v1 = *(_QWORD **)(result + 24);
  if (v1)
  {
    v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

uint64_t Phase::Geometry::Listener::operator=(uint64_t a1, uint64_t a2)
{
  __int128 v4;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 76) = *(_DWORD *)(a2 + 76);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  if (a1 != a2)
  {
    std::vector<Phase::SpatialModeler::DirectivityHistogram *>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::DirectivityHistogram **,Phase::SpatialModeler::DirectivityHistogram **>((char *)(a1 + 96), *(char **)(a2 + 96), *(_QWORD *)(a2 + 104), (uint64_t)(*(_QWORD *)(a2 + 104) - *(_QWORD *)(a2 + 96)) >> 3);
    std::vector<Phase::SpatialModeler::DirectivityHistogram *>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::DirectivityHistogram **,Phase::SpatialModeler::DirectivityHistogram **>((char *)(a1 + 120), *(char **)(a2 + 120), *(_QWORD *)(a2 + 128), (uint64_t)(*(_QWORD *)(a2 + 128) - *(_QWORD *)(a2 + 120)) >> 3);
  }
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
  *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
  *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
  *(_DWORD *)(a1 + 164) = *(_DWORD *)(a2 + 164);
  *(_DWORD *)(a1 + 168) = *(_DWORD *)(a2 + 168);
  v4 = *(_OWORD *)(a2 + 176);
  *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 192);
  *(_OWORD *)(a1 + 176) = v4;
  return a1;
}

_QWORD *std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D57CED8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_2165B8694(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  _QWORD *v13;

  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_2165B86AC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  _QWORD *v1;
  void *v2;
  void *v3;

  v1 = *(_QWORD **)(result + 24);
  if (v1)
  {
    v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

_QWORD *std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(_QWORD *result)
{
  _QWORD *v1;
  void *v2;
  void *v3;

  if (result)
  {
    v1 = result;
    v2 = (void *)result[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  _QWORD *v1;
  void *v2;
  void *v3;

  v1 = *(_QWORD **)(result + 24);
  if (v1)
  {
    v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

uint64_t Phase::Geometry::Source::operator=(uint64_t a1, uint64_t a2)
{
  __int128 v4;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 76) = *(_DWORD *)(a2 + 76);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  if (a1 != a2)
  {
    std::vector<Phase::SpatialModeler::DirectivityHistogram *>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::DirectivityHistogram **,Phase::SpatialModeler::DirectivityHistogram **>((char *)(a1 + 96), *(char **)(a2 + 96), *(_QWORD *)(a2 + 104), (uint64_t)(*(_QWORD *)(a2 + 104) - *(_QWORD *)(a2 + 96)) >> 3);
    std::vector<Phase::SpatialModeler::DirectivityHistogram *>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::DirectivityHistogram **,Phase::SpatialModeler::DirectivityHistogram **>((char *)(a1 + 120), *(char **)(a2 + 120), *(_QWORD *)(a2 + 128), (uint64_t)(*(_QWORD *)(a2 + 128) - *(_QWORD *)(a2 + 120)) >> 3);
  }
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a2 + 152);
  *(_DWORD *)(a1 + 156) = *(_DWORD *)(a2 + 156);
  *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
  *(_DWORD *)(a1 + 164) = *(_DWORD *)(a2 + 164);
  v4 = *(_OWORD *)(a2 + 168);
  *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 168) = v4;
  return a1;
}

_QWORD *std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D57CF48;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_2165B89A8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  _QWORD *v13;

  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_2165B89C0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  _QWORD *v1;
  void *v2;
  void *v3;

  v1 = *(_QWORD **)(result + 24);
  if (v1)
  {
    v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

uint64_t (*Phase::GetTypeId<Phase::Geometry::EnvelopeDistanceModel>())()
{
  return Phase::GetTypeId<Phase::Geometry::EnvelopeDistanceModel>;
}

uint64_t *Phase::Geometry::CreateEnvelopeDistanceModel@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t *v6;
  float *v7;
  uint64_t v8;
  float v10[6];
  float *v11;
  uint64_t v12;
  _QWORD v13[3];
  _QWORD *v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v2 = operator new(0x58uLL);
  v2[1] = 0;
  v2[2] = 0;
  *v2 = &off_24D57CF80;
  *((_DWORD *)v2 + 6) = 2;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  v2[10] = 0;
  *a1 = v2 + 3;
  a1[1] = v2;
  v3 = (_QWORD *)operator new();
  *v3 = Phase::GetTypeId<Phase::Geometry::EnvelopeDistanceModel>;
  v3[1] = v2 + 3;
  *(_QWORD *)v10 = 0x3F8000007F7FFFFFLL;
  v12 = 2139095039;
  v4 = v13;
  v13[0] = &unk_24D579958;
  v13[1] = Phase::CurveFunction::Linear<float>;
  v14 = v13;
  Phase::Envelope<float>::Envelope((Phase::Logger *)(v3 + 2), v10, (float *)&v12);
  if (v14 == v13)
  {
    v5 = 4;
  }
  else
  {
    if (!v14)
      goto LABEL_6;
    v5 = 5;
    v4 = v14;
  }
  (*(void (**)(_QWORD *))(*v4 + 8 * v5))(v4);
LABEL_6:
  v6 = v2 + 8;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v6, 1uLL);
  *(_QWORD *)v10 = &off_24D57CFB8;
  v11 = v10;
  v12 = (uint64_t)v3;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v13, (uint64_t)v10);
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
  }
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)*v6, &v12);
  return std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v12);
}

void sub_2165B8C14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, _QWORD *a17)
{
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v21;

  if (a17 == v19)
  {
    v21 = 4;
  }
  else
  {
    if (!a17)
      goto LABEL_6;
    v21 = 5;
    v19 = a17;
  }
  (*(void (**)(_QWORD *))(*v19 + 8 * v21))(v19);
LABEL_6:
  MEMORY[0x2199F9D70](v18, 0xA0C40987D6AD5);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v17);
  _Unwind_Resume(a1);
}

uint64_t *Phase::Geometry::CreateEnvelopeDistanceModelFromDistanceModel@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  char *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t (***v15)();
  uint64_t v16;
  _DWORD *v18;
  _DWORD *v19;
  _QWORD *v20;
  _QWORD v21[2];
  char v22;
  uint64_t (**v23)();
  char v24;
  uint64_t (***v25)();
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)a1 != 2)
    __assert_rtn("CreateEnvelopeDistanceModelFromDistanceModel", "GeoEnvelopeDistanceModel.mm", 43, "inDistanceModel.mType == DefaultDistanceModelType::Envelope");
  v4 = operator new(0x58uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_24D57CF80;
  *((_DWORD *)v4 + 6) = 2;
  v5 = (char *)(v4 + 3);
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *((_OWORD *)v4 + 4) = 0u;
  v4[10] = 0;
  *a2 = v4 + 3;
  a2[1] = v4;
  v6 = **(_QWORD **)(a1 + 40);
  if (!v6)
    __assert_rtn("CreateEnvelopeDistanceModelFromDistanceModel", "GeoEnvelopeDistanceModel.mm", 48, "pSrcDistanceModel");
  v7 = v4;
  v8 = (_QWORD *)operator new();
  *v8 = Phase::GetTypeId<Phase::Geometry::EnvelopeDistanceModel>;
  v8[1] = v5;
  v8[2] = 0;
  v8[3] = 0;
  v8[4] = 0;
  v9 = *(_QWORD *)(v6 + 16);
  v10 = *(_QWORD *)(v6 + 24);
  v23 = (uint64_t (**)())(v8 + 2);
  v24 = 0;
  if (v10 != v9)
  {
    std::vector<Phase::Envelope<float>::SegmentInternal,std::allocator<Phase::Envelope<float>::SegmentInternal>>::__vallocate[abi:ne180100](v8 + 2, 0xAAAAAAAAAAAAAAABLL * ((v10 - v9) >> 4));
    v18 = (_DWORD *)v8[3];
    v19 = v18;
    v20 = v8 + 4;
    v21[0] = &v18;
    v21[1] = &v19;
    v22 = 0;
    v11 = v9 + 16;
    v12 = v18;
    do
    {
      v13 = v11 - 16;
      *v12 = *(_DWORD *)(v11 - 16);
      v12[1] = *(_DWORD *)(v11 - 12);
      v12[2] = *(_DWORD *)(v11 - 8);
      v12[3] = *(_DWORD *)(v11 - 4);
      std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)(v12 + 4), v11);
      v12 = v19 + 12;
      v19 += 12;
      v11 += 48;
    }
    while (v13 + 48 != v10);
    v22 = 1;
    std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::Envelope<float>::SegmentInternal>,Phase::Envelope<float>::SegmentInternal*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&v20);
    v8[3] = v12;
  }
  v14 = v7 + 8;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v14, 1uLL);
  v23 = &off_24D57CFB8;
  v25 = &v23;
  v20 = v8;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v21, (uint64_t)&v23);
  v15 = v25;
  if (v25 == &v23)
  {
    v16 = 4;
    v15 = &v23;
    goto LABEL_11;
  }
  if (v25)
  {
    v16 = 5;
LABEL_11:
    (*v15)[v16]();
  }
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)*v14, (uint64_t *)&v20);
  return std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v20);
}

void sub_2165B8ED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  uint64_t v9;
  va_list va;

  va_start(va, a8);
  std::vector<Phase::Envelope<double>::Segment,std::allocator<Phase::Envelope<double>::Segment>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  MEMORY[0x2199F9D70](v9, 0xA0C40987D6AD5);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v8);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<Phase::Geometry::DistanceModel>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57CF80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Phase::Geometry::DistanceModel>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57CF80;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

void std::__shared_ptr_emplace<Phase::Geometry::DistanceModel>::__on_zero_shared(uint64_t a1)
{
  void **v2;

  v2 = (void **)(a1 + 64);
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (void **)(a1 + 40);
  std::vector<std::shared_ptr<Phase::Controller::Renderer>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::EnvelopeDistanceModel>(Phase::Geometry::EnvelopeDistanceModel *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::EnvelopeDistanceModel>(Phase::Geometry::EnvelopeDistanceModel *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::EnvelopeDistanceModel>(Phase::Geometry::EnvelopeDistanceModel *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::EnvelopeDistanceModel>(Phase::Geometry::EnvelopeDistanceModel *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57CFB8;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::EnvelopeDistanceModel>(Phase::Geometry::EnvelopeDistanceModel *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::EnvelopeDistanceModel>(Phase::Geometry::EnvelopeDistanceModel *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57CFB8;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::EnvelopeDistanceModel>(Phase::Geometry::EnvelopeDistanceModel *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::EnvelopeDistanceModel>(Phase::Geometry::EnvelopeDistanceModel *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t result;
  void **v4;

  v2 = *a2;
  if (*a2)
  {
    v4 = (void **)(v2 + 16);
    std::vector<Phase::Envelope<double>::Segment,std::allocator<Phase::Envelope<double>::Segment>>::__destroy_vector::operator()[abi:ne180100](&v4);
    return MEMORY[0x2199F9D70](v2, 0xA0C40987D6AD5);
  }
  return result;
}

uint64_t (*Phase::GetTypeId<Phase::Geometry::GeometricSpreadingDistanceModel>())()
{
  return Phase::GetTypeId<Phase::Geometry::GeometricSpreadingDistanceModel>;
}

uint64_t *Phase::Geometry::CreateGeometricSpreadingDistanceModel@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[3];
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = operator new(0x58uLL);
  v2[1] = 0;
  v2[2] = 0;
  *v2 = &off_24D57CF80;
  *((_DWORD *)v2 + 6) = 1;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  v2[10] = 0;
  *a1 = v2 + 3;
  a1[1] = v2;
  v3 = operator new();
  *(_QWORD *)v3 = Phase::GetTypeId<Phase::Geometry::GeometricSpreadingDistanceModel>;
  *(_QWORD *)(v3 + 8) = v2 + 3;
  *(_DWORD *)(v3 + 16) = 1065353216;
  v4 = v2 + 8;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v4, 1uLL);
  v10[0] = &off_24D57D000;
  v11 = v10;
  v8 = v3;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v9, (uint64_t)v10);
  v5 = v11;
  if (v11 == v10)
  {
    v6 = 4;
    v5 = v10;
    goto LABEL_5;
  }
  if (v11)
  {
    v6 = 5;
LABEL_5:
    (*(void (**)(_QWORD *))(*v5 + 8 * v6))(v5);
  }
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)*v4, &v8);
  return std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v8);
}

void sub_2165B919C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t *Phase::Geometry::CreateGeometricSpreadingDistanceModelFromDistanceModel@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  char *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[3];
  _QWORD *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)a1 != 1)
    __assert_rtn("CreateGeometricSpreadingDistanceModelFromDistanceModel", "GeoGeometricSpreadingDistanceModel.mm", 43, "inDistanceModel.mType == DefaultDistanceModelType::GeometricSpreading");
  v4 = operator new(0x58uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_24D57CF80;
  *((_DWORD *)v4 + 6) = 1;
  v5 = (char *)(v4 + 3);
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *((_OWORD *)v4 + 4) = 0u;
  v4[10] = 0;
  *a2 = v4 + 3;
  a2[1] = v4;
  v6 = **(_QWORD **)(a1 + 40);
  if (!v6)
    __assert_rtn("CreateGeometricSpreadingDistanceModelFromDistanceModel", "GeoGeometricSpreadingDistanceModel.mm", 48, "pSrcDistanceModel");
  v7 = v4;
  v8 = operator new();
  *(_QWORD *)v8 = Phase::GetTypeId<Phase::Geometry::GeometricSpreadingDistanceModel>;
  *(_QWORD *)(v8 + 8) = v5;
  *(_DWORD *)(v8 + 16) = *(_DWORD *)(v6 + 16);
  v9 = v7 + 8;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v9, 1uLL);
  v15[0] = &off_24D57D000;
  v16 = v15;
  v13 = v8;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v14, (uint64_t)v15);
  v10 = v16;
  if (v16 == v15)
  {
    v11 = 4;
    v10 = v15;
    goto LABEL_7;
  }
  if (v16)
  {
    v11 = 5;
LABEL_7:
    (*(void (**)(_QWORD *))(*v10 + 8 * v11))(v10);
  }
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)*v9, &v13);
  return std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v13);
}

void sub_2165B9354(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::GeometricSpreadingDistanceModel>(Phase::Geometry::GeometricSpreadingDistanceModel *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::GeometricSpreadingDistanceModel>(Phase::Geometry::GeometricSpreadingDistanceModel *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::GeometricSpreadingDistanceModel>(Phase::Geometry::GeometricSpreadingDistanceModel *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::GeometricSpreadingDistanceModel>(Phase::Geometry::GeometricSpreadingDistanceModel *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57D000;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::GeometricSpreadingDistanceModel>(Phase::Geometry::GeometricSpreadingDistanceModel *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::GeometricSpreadingDistanceModel>(Phase::Geometry::GeometricSpreadingDistanceModel *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57D000;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::GeometricSpreadingDistanceModel>(Phase::Geometry::GeometricSpreadingDistanceModel *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::GeometricSpreadingDistanceModel>(Phase::Geometry::GeometricSpreadingDistanceModel *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
    JUMPOUT(0x2199F9D70);
  return result;
}

uint64_t Phase::Geometry::MaterialFactory::Create@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  uint64_t result;

  v3 = *(_QWORD *)(*(_QWORD *)a1 + 968);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)a1 + 976) - v3) >> 5) <= a2)
    __assert_rtn("GetTypeDef", "GeoMaterialTypeRegistry.cpp", 33, "IsValid(inMaterialType)");
  result = *(_QWORD *)(v3 + 96 * a2 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  *a3 = 0;
  a3[1] = 0;
  return result;
}

uint64_t Phase::Geometry::MaterialFactory::Create@<X0>(uint64_t a1@<X0>, unsigned int *a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t result;

  v3 = *a2;
  v4 = *(_QWORD *)(*(_QWORD *)a1 + 968);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)a1 + 976) - v4) >> 5) <= v3)
    __assert_rtn("GetTypeDef", "GeoMaterialTypeRegistry.cpp", 33, "IsValid(inMaterialType)");
  result = *(_QWORD *)(v4 + 96 * v3 + 64);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  *a3 = 0;
  a3[1] = 0;
  return result;
}

_QWORD *Phase::Geometry::MaterialTypeRegistry::CustomizeType(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 16) - v3) >> 5) <= a2)
    __assert_rtn("CustomizeType", "GeoMaterialTypeRegistry.cpp", 43, "IsValid(inMaterialType)");
  return std::function<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((_QWORD *)(v3 + 96 * a2 + 8), a3);
}

{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 16) - v3) >> 5) <= a2)
    __assert_rtn("CustomizeType", "GeoMaterialTypeRegistry.cpp", 54, "IsValid(inMaterialType)");
  return std::function<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((_QWORD *)(v3 + 96 * a2 + 40), a3);
}

_QWORD *std::function<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

_QWORD *std::function<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::vector<Phase::Geometry::MaterialTypeDefinition>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 5);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<Phase::Geometry::MaterialTypeDefinition>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 96 * a2;
    while (v3 != v7)
    {
      v3 -= 96;
      std::allocator<Phase::Geometry::DirectivityTypeDefinition>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
    }
    a1[1] = v7;
  }
}

_QWORD *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_2165B98FC(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_2165B9A70(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t std::vector<Phase::Geometry::MaterialTypeDefinition>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::MaterialTypeDefinition>,std::reverse_iterator<Phase::Geometry::MaterialTypeDefinition*>,std::reverse_iterator<Phase::Geometry::MaterialTypeDefinition*>,std::reverse_iterator<Phase::Geometry::MaterialTypeDefinition*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void std::vector<Phase::Geometry::MaterialTypeDefinition>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::MaterialTypeDefinition>,std::reverse_iterator<Phase::Geometry::MaterialTypeDefinition*>,std::reverse_iterator<Phase::Geometry::MaterialTypeDefinition*>,std::reverse_iterator<Phase::Geometry::MaterialTypeDefinition*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;

  if (a3 != a5)
  {
    v11 = 0;
    v12 = a3;
    while (1)
    {
      v13 = a7 + v11;
      v14 = a3 + v11;
      *(_QWORD *)(a7 + v11 - 96) = *(_QWORD *)(a3 + v11 - 96);
      v15 = *(_QWORD *)(a3 + v11 - 64);
      if (!v15)
        break;
      if (v14 - 88 != v15)
      {
        v16 = (_QWORD *)(v12 - 64);
        *(_QWORD *)(v13 - 64) = v15;
LABEL_7:
        *v16 = 0;
        goto LABEL_9;
      }
      *(_QWORD *)(v13 - 64) = v13 - 88;
      (*(void (**)(_QWORD))(**(_QWORD **)(v14 - 64) + 24))(*(_QWORD *)(v14 - 64));
LABEL_9:
      v17 = a7 + v11;
      v18 = a3 + v11;
      v19 = *(_QWORD *)(a3 + v11 - 32);
      if (v19)
      {
        if (v18 - 56 == v19)
        {
          *(_QWORD *)(v17 - 32) = v17 - 56;
          (*(void (**)(_QWORD))(**(_QWORD **)(v18 - 32) + 24))(*(_QWORD *)(v18 - 32));
          goto LABEL_15;
        }
        v20 = (_QWORD *)(v12 - 32);
        *(_QWORD *)(v17 - 32) = v19;
      }
      else
      {
        v20 = (_QWORD *)(v17 - 32);
      }
      *v20 = 0;
LABEL_15:
      v12 -= 96;
      v21 = a7 + v11;
      v22 = a3 + v11;
      *(_QWORD *)(v21 - 24) = 0;
      *(_QWORD *)(v21 - 16) = 0;
      *(_QWORD *)(v21 - 8) = 0;
      *(_OWORD *)(v21 - 24) = *(_OWORD *)(a3 + v11 - 24);
      *(_QWORD *)(v21 - 8) = *(_QWORD *)(a3 + v11 - 8);
      *(_QWORD *)(v22 - 24) = 0;
      *(_QWORD *)(v22 - 16) = 0;
      *(_QWORD *)(v22 - 8) = 0;
      v11 -= 96;
      if (a3 + v11 == a5)
        return a6;
    }
    v16 = (_QWORD *)(v13 - 64);
    goto LABEL_7;
  }
  return a6;
}

void std::vector<Phase::Geometry::MaterialTypeDefinition>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  void *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 5) >= a2)
  {
    if (a2)
    {
      v13 = 96 * ((96 * a2 - 96) / 0x60) + 96;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 5);
    v9 = v8 + a2;
    if (v8 + a2 > 0x2AAAAAAAAAAAAAALL)
      std::vector<Phase::Geometry::MaterialTypeDefinition>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 5);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x155555555555555)
      v11 = 0x2AAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::VoiceData>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[96 * v8];
    v18 = &v12[96 * v11];
    v14 = 96 * ((96 * a2 - 96) / 0x60) + 96;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<Phase::Geometry::MaterialTypeDefinition>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::~__split_buffer(&v15);
  }
}

void sub_2165B9D8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

Phase::MdlMeshAsset *Phase::Geometry::MdlMeshReader::MdlMeshReader(Phase::MdlMeshAsset *a1, const Phase::MdlMeshAsset *a2)
{
  Phase::Geometry::MdlMeshReader *v3;

  v3 = Phase::MdlMeshAsset::MdlMeshAsset(a1, a2);
  Phase::Geometry::MdlMeshReader::SetupVertexDescriptor(v3);
  Phase::MdlMeshAsset::SetTopology((uint64_t)a1, 2);
  *((_QWORD *)a1 + 2) = Phase::MdlMeshAsset::GetVertexBuffer((id **)a1, 0);
  return a1;
}

void sub_2165B9DE4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<Phase::details::MdlMeshAssetImplementation>::reset[abi:ne180100]((id **)(v1 + 8), 0);
  _Unwind_Resume(a1);
}

void Phase::Geometry::MdlMeshReader::SetupVertexDescriptor(Phase::Geometry::MdlMeshReader *this)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  uint64_t j;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  void *__p[2];
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  *(_OWORD *)__p = 0u;
  v14 = 0u;
  v12 = 0u;
  std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::resize((uint64_t *)&v12, 2uLL);
  std::vector<Phase::MdlMeshAsset::VertexDescriptor::Layout>::resize((uint64_t)&__p[1], 1uLL);
  Phase::sGetStdStringFromNsString((Phase *)*MEMORY[0x24BDDE6B8], &v15);
  v8 = v15;
  v10 = v16;
  v2 = v12;
  if (*(char *)(v12 + 23) < 0)
    operator delete(*(void **)v12);
  *(_OWORD *)v2 = v8;
  *(_QWORD *)(v2 + 16) = v10;
  v3 = (_QWORD *)v12;
  *(_BYTE *)(v12 + 24) = 47;
  v3[5] = 0;
  v3[6] = 0;
  v3[4] = 0;
  for (i = 56; i != 68; i += 4)
    *(_DWORD *)(v12 + i) = 0;
  Phase::sGetStdStringFromNsString((Phase *)*MEMORY[0x24BDDE6B0], &v15);
  v9 = v15;
  v11 = v16;
  v5 = v12;
  v6 = v12 + 72;
  if (*(char *)(v12 + 95) < 0)
  {
    operator delete(*(void **)v6);
    v5 = v12;
  }
  *(_OWORD *)v6 = v9;
  *(_QWORD *)(v6 + 16) = v11;
  *(_BYTE *)(v5 + 96) = 47;
  *(_QWORD *)(v5 + 112) = 0;
  *(_QWORD *)(v5 + 120) = 0;
  *(_QWORD *)(v5 + 104) = 12;
  for (j = 128; j != 140; j += 4)
    *(_DWORD *)(v12 + j) = 0;
  *(_QWORD *)__p[1] = 24;
  Phase::MdlMeshAsset::SetVertexDescriptor((uint64_t)this, (uint64_t *)&v12);
  if (__p[1])
  {
    *(void **)&v14 = __p[1];
    operator delete(__p[1]);
  }
  *(_QWORD *)&v15 = &v12;
  std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__destroy_vector::operator()[abi:ne180100]((void ***)&v15);
}

void sub_2165B9F70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  Phase::MdlMeshAsset::VertexDescriptor::~VertexDescriptor((Phase::MdlMeshAsset::VertexDescriptor *)va);
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::MdlMeshReader::CalculateAABB@<X0>(id **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result;
  float *v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;

  *(_OWORD *)a2 = xmmword_2166F8300;
  *(_QWORD *)(a2 + 16) = 0x80000000800000;
  result = objc_msgSend(*this[1], "vertexCount");
  if (result)
  {
    v5 = (float *)(this[2] + 1);
    v6 = -3.4028e38;
    v7 = 3.4028e38;
    v8 = 3.4028e38;
    v9 = 3.4028e38;
    v10 = -3.4028e38;
    v11 = -3.4028e38;
    do
    {
      v12 = *(v5 - 2);
      v13 = *(v5 - 1);
      v7 = fminf(v7, v12);
      v8 = fminf(v8, v13);
      v14 = *v5;
      v5 += 6;
      v9 = fminf(v9, v14);
      v6 = fmaxf(v6, v12);
      v10 = fmaxf(v10, v13);
      v11 = fmaxf(v11, v14);
      --result;
    }
    while (result);
    *(float *)a2 = v7;
    *(float *)(a2 + 4) = v8;
    *(float *)(a2 + 8) = v9;
    *(float *)(a2 + 12) = v6;
    *(float *)(a2 + 16) = v10;
    *(float *)(a2 + 20) = v11;
  }
  return result;
}

void std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0x8E38E38E38E38E39 * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 72 * a2;
    while (v3 != v7)
    {
      if (*(char *)(v3 - 49) < 0)
        operator delete(*(void **)(v3 - 72));
      v3 -= 72;
    }
    a1[1] = v7;
  }
}

void std::vector<Phase::MdlMeshAsset::VertexDescriptor::Layout>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<Phase::MdlMeshAsset::VertexDescriptor::Layout>::__append((char **)a1, a2 - v2);
  }
}

void Phase::MdlMeshAsset::VertexDescriptor::~VertexDescriptor(Phase::MdlMeshAsset::VertexDescriptor *this)
{
  void *v2;
  void **v3;

  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
  v3 = (void **)this;
  std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 72)
  {
    if (*(char *)(i - 49) < 0)
      operator delete(*(void **)(i - 72));
  }
  a1[1] = v2;
}

void std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0x8E38E38E38E38E39 * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 72 * ((72 * a2 - 72) / 0x48) + 72;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0x8E38E38E38E38E39 * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x38E38E38E38E38ELL)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v10 = 0x8E38E38E38E38E39 * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x1C71C71C71C71C7)
      v11 = 0x38E38E38E38E38ELL;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::DVM::Submix::ChannelStrip>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[72 * v8];
    v18 = &v12[72 * v11];
    v14 = 72 * ((72 * a2 - 72) / 0x48) + 72;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_2165BA350(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::MdlMeshAsset::VertexDescriptor::Attribute>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::MdlMeshAsset::VertexDescriptor::Attribute>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _QWORD v14[3];
  char v15;
  __int128 v16;
  __int128 v17;

  v7 = a7;
  *(_QWORD *)&v17 = a6;
  *((_QWORD *)&v17 + 1) = a7;
  v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  v14[2] = &v17;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 72);
      *(_QWORD *)(v9 - 56) = *(_QWORD *)(a3 - 56);
      *(_OWORD *)(v9 - 72) = v10;
      *(_QWORD *)(a3 - 64) = 0;
      *(_QWORD *)(a3 - 56) = 0;
      *(_QWORD *)(a3 - 72) = 0;
      v11 = *(_OWORD *)(a3 - 48);
      v12 = *(_OWORD *)(a3 - 16);
      *(_OWORD *)(v9 - 32) = *(_OWORD *)(a3 - 32);
      *(_OWORD *)(v9 - 16) = v12;
      *(_OWORD *)(v9 - 48) = v11;
      v9 -= 72;
      v7 -= 72;
      a3 -= 72;
    }
    while (a3 != a5);
    *((_QWORD *)&v17 + 1) = v9;
  }
  v15 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::MdlMeshAsset::VertexDescriptor::Attribute>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v14);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::MdlMeshAsset::VertexDescriptor::Attribute>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<Phase::MdlMeshAsset::VertexDescriptor::Attribute>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<Phase::MdlMeshAsset::VertexDescriptor::Attribute>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    v1 += 72;
  }
}

uint64_t std::__split_buffer<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__destruct_at_end[abi:ne180100](a1, *(void ***)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 9;
      *(_QWORD *)(a1 + 16) = v2 - 9;
      if (*((char *)v2 - 49) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

void std::vector<Phase::MdlMeshAsset::VertexDescriptor::Layout>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 3);
    if (v10 >> 61)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 3;
    v12 = v5 - v8;
    if (v12 >> 2 > v10)
      v10 = v12 >> 2;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[8 * v11];
    v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      v18 = *((_QWORD *)v7 - 1);
      v7 -= 8;
      *((_QWORD *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

uint64_t Phase::Geometry::MediumFactory::Create@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  uint64_t result;

  v3 = *(_QWORD *)(*(_QWORD *)a1 + 720);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)a1 + 728) - v3) >> 5) <= a2)
    __assert_rtn("GetTypeDef", "GeoMediumTypeRegistry.cpp", 33, "IsValid(inMediumType)");
  result = *(_QWORD *)(v3 + 96 * a2 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  *a3 = 0;
  a3[1] = 0;
  return result;
}

_QWORD *Phase::Geometry::MediumTypeRegistry::CustomizeType(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 16) - v3) >> 5) <= a2)
    __assert_rtn("CustomizeType", "GeoMediumTypeRegistry.cpp", 43, "IsValid(inMediumType)");
  return std::function<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((_QWORD *)(v3 + 96 * a2 + 8), a3);
}

{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 16) - v3) >> 5) <= a2)
    __assert_rtn("CustomizeType", "GeoMediumTypeRegistry.cpp", 54, "IsValid(inMediumType)");
  return std::function<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((_QWORD *)(v3 + 96 * a2 + 40), a3);
}

_QWORD *std::function<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

_QWORD *std::function<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::vector<Phase::Geometry::MediumTypeDefinition>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 5);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<Phase::Geometry::MediumTypeDefinition>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 96 * a2;
    while (v3 != v7)
    {
      v3 -= 96;
      std::allocator<Phase::Geometry::DirectivityTypeDefinition>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
    }
    a1[1] = v7;
  }
}

_QWORD *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_2165BAB10(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_2165BAC84(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t std::vector<Phase::Geometry::MediumTypeDefinition>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::MediumTypeDefinition>,std::reverse_iterator<Phase::Geometry::MediumTypeDefinition*>,std::reverse_iterator<Phase::Geometry::MediumTypeDefinition*>,std::reverse_iterator<Phase::Geometry::MediumTypeDefinition*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void std::vector<Phase::Geometry::MediumTypeDefinition>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::MediumTypeDefinition>,std::reverse_iterator<Phase::Geometry::MediumTypeDefinition*>,std::reverse_iterator<Phase::Geometry::MediumTypeDefinition*>,std::reverse_iterator<Phase::Geometry::MediumTypeDefinition*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;

  if (a3 != a5)
  {
    v11 = 0;
    v12 = a3;
    while (1)
    {
      v13 = a7 + v11;
      v14 = a3 + v11;
      *(_QWORD *)(a7 + v11 - 96) = *(_QWORD *)(a3 + v11 - 96);
      v15 = *(_QWORD *)(a3 + v11 - 64);
      if (!v15)
        break;
      if (v14 - 88 != v15)
      {
        v16 = (_QWORD *)(v12 - 64);
        *(_QWORD *)(v13 - 64) = v15;
LABEL_7:
        *v16 = 0;
        goto LABEL_9;
      }
      *(_QWORD *)(v13 - 64) = v13 - 88;
      (*(void (**)(_QWORD))(**(_QWORD **)(v14 - 64) + 24))(*(_QWORD *)(v14 - 64));
LABEL_9:
      v17 = a7 + v11;
      v18 = a3 + v11;
      v19 = *(_QWORD *)(a3 + v11 - 32);
      if (v19)
      {
        if (v18 - 56 == v19)
        {
          *(_QWORD *)(v17 - 32) = v17 - 56;
          (*(void (**)(_QWORD))(**(_QWORD **)(v18 - 32) + 24))(*(_QWORD *)(v18 - 32));
          goto LABEL_15;
        }
        v20 = (_QWORD *)(v12 - 32);
        *(_QWORD *)(v17 - 32) = v19;
      }
      else
      {
        v20 = (_QWORD *)(v17 - 32);
      }
      *v20 = 0;
LABEL_15:
      v12 -= 96;
      v21 = a7 + v11;
      v22 = a3 + v11;
      *(_QWORD *)(v21 - 24) = 0;
      *(_QWORD *)(v21 - 16) = 0;
      *(_QWORD *)(v21 - 8) = 0;
      *(_OWORD *)(v21 - 24) = *(_OWORD *)(a3 + v11 - 24);
      *(_QWORD *)(v21 - 8) = *(_QWORD *)(a3 + v11 - 8);
      *(_QWORD *)(v22 - 24) = 0;
      *(_QWORD *)(v22 - 16) = 0;
      *(_QWORD *)(v22 - 8) = 0;
      v11 -= 96;
      if (a3 + v11 == a5)
        return a6;
    }
    v16 = (_QWORD *)(v13 - 64);
    goto LABEL_7;
  }
  return a6;
}

void std::vector<Phase::Geometry::MediumTypeDefinition>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  void *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 5) >= a2)
  {
    if (a2)
    {
      v13 = 96 * ((96 * a2 - 96) / 0x60) + 96;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 5);
    v9 = v8 + a2;
    if (v8 + a2 > 0x2AAAAAAAAAAAAAALL)
      std::vector<Phase::Geometry::MediumTypeDefinition>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 5);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x155555555555555)
      v11 = 0x2AAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::VoiceData>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[96 * v8];
    v18 = &v12[96 * v11];
    v14 = 96 * ((96 * a2 - 96) / 0x60) + 96;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<Phase::Geometry::MediumTypeDefinition>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::~__split_buffer(&v15);
  }
}

void sub_2165BAFA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t (*Phase::GetTypeId<Phase::Geometry::Mesh>())()
{
  return Phase::GetTypeId<Phase::Geometry::Mesh>;
}

_QWORD *Phase::Geometry::CreateMesh@<X0>(_QWORD *a1@<X8>)
{
  char *v2;

  v2 = (char *)operator new(0xC0uLL);
  *((_QWORD *)v2 + 1) = 0;
  *((_QWORD *)v2 + 2) = 0;
  *(_QWORD *)v2 = &off_24D57D128;
  *((_OWORD *)v2 + 2) = xmmword_2166F8310;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *(_OWORD *)(v2 + 76) = 0u;
  *((_OWORD *)v2 + 6) = 0u;
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  *((_OWORD *)v2 + 9) = 0u;
  *((_OWORD *)v2 + 10) = 0u;
  *((_OWORD *)v2 + 11) = xmmword_2166F8320;
  a1[1] = v2;
  *((_DWORD *)v2 + 6) = 1;
  v2 += 24;
  *a1 = v2;
  return Phase::Geometry::AddMesh(v2, 0);
}

void sub_2165BB038(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

_QWORD *Phase::Geometry::AddMesh(_QWORD *a1, unint64_t a2)
{
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  char *v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  __int128 v40[2];
  _QWORD v41[3];
  _QWORD *v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  v4 = 2 * a2 + 4;
  v5 = a1 + 12;
  v6 = (uint64_t)(a1[13] - a1[12]) >> 4;
  std::vector<std::shared_ptr<Phase::Geometry::SharedDataStream>>::resize((uint64_t)(a1 + 12), v4);
  if (v6 < v4)
  {
    do
    {
      v7 = (char *)operator new(0x40uLL);
      *((_QWORD *)v7 + 1) = 0;
      *((_QWORD *)v7 + 2) = 0;
      *(_QWORD *)v7 = &off_24D57D048;
      *(_OWORD *)(v7 + 40) = 0u;
      *((_QWORD *)v7 + 7) = 0;
      *(_OWORD *)(v7 + 24) = 0u;
      *(_QWORD *)&v40[0] = v7 + 24;
      *((_QWORD *)&v40[0] + 1) = v7;
      std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100](*v5 + 16 * v6, v40);
      v8 = (std::__shared_weak_count *)*((_QWORD *)&v40[0] + 1);
      if (*((_QWORD *)&v40[0] + 1))
      {
        v9 = (unint64_t *)(*((_QWORD *)&v40[0] + 1) + 8);
        do
          v10 = __ldaxr(v9);
        while (__stlxr(v10 - 1, v9));
        if (!v10)
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
      ++v6;
    }
    while (v6 != v4);
  }
  v11 = (_QWORD *)operator new();
  *v11 = Phase::GetTypeId<Phase::Geometry::Mesh>;
  v11[1] = a1;
  v11[2] = 0;
  v11[3] = -1;
  v11[4] = 0;
  v11[5] = -1;
  v11[6] = 0;
  v11[7] = -1;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(a1 + 15, 1uLL);
  v41[0] = &off_24D57D080;
  v42 = v41;
  *(_QWORD *)&v40[0] = v11;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v40 + 8, (uint64_t)v41);
  v12 = v42;
  if (v42 == v41)
  {
    v13 = 4;
    v12 = v41;
  }
  else
  {
    if (!v42)
      goto LABEL_13;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_13:
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)a1[15], (uint64_t *)v40);
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v40);
  a1[18] = v5;
  a1[19] = 0;
  v14 = (uint64_t *)a1[12];
  v15 = *v14;
  *(_DWORD *)v15 = 1;
  *(_QWORD *)(v15 + 16) = 8;
  *(_QWORD *)(v15 + 32) = 8;
  v11[2] = v5;
  v11[3] = 1;
  v16 = v14[2];
  *(_DWORD *)v16 = 2;
  *(_QWORD *)(v16 + 16) = 4;
  *(_QWORD *)(v16 + 32) = 12;
  v11[4] = v5;
  v11[5] = 2;
  v17 = v14[4];
  *(_DWORD *)v17 = 3;
  *(_QWORD *)(v17 + 16) = 4;
  *(_QWORD *)(v17 + 32) = 12;
  v11[6] = v5;
  v11[7] = 3;
  v18 = v14[6];
  *(_DWORD *)v18 = 4;
  *(_QWORD *)(v18 + 16) = 8;
  *(_QWORD *)(v18 + 32) = 64;
  if (a2)
  {
    v19 = *(_QWORD *)(v18 + 24);
    if (v19 == a2)
    {
      v20 = 0;
    }
    else
    {
      v20 = *(_QWORD *)(v18 + 8);
      *(_QWORD *)(v18 + 8) = 0;
      Phase::Geometry::DataStream::Alloc((std::align_val_t)8uLL, a2 << 6, v40);
      v21 = *(_QWORD *)&v40[0];
      *(_QWORD *)&v40[0] = 0;
      v22 = *(_QWORD *)(v18 + 8);
      *(_QWORD *)(v18 + 8) = v21;
      if (v22)
      {
        MEMORY[0x2199F9D4C](v22, 0x1000C8077774924);
        v23 = *(_QWORD *)&v40[0];
        *(_QWORD *)&v40[0] = 0;
        if (v23)
          MEMORY[0x2199F9D4C](v23, 0x1000C8077774924);
      }
      *(_QWORD *)(v18 + 24) = a2;
    }
    if (v19 >= a2)
      v24 = a2;
    else
      v24 = v19;
    if (v24)
    {
      v25 = v20 + 12;
      v26 = *(_QWORD *)(v18 + 8) + 12;
      v27 = v24;
      do
      {
        *(_DWORD *)(v26 - 12) = *(_DWORD *)(v25 - 12);
        *(_DWORD *)(v26 - 8) = *(_DWORD *)(v25 - 8);
        *(_DWORD *)(v26 - 4) = *(_DWORD *)(v25 - 4);
        *(_DWORD *)v26 = *(_DWORD *)v25;
        *(_DWORD *)(v26 + 4) = *(_DWORD *)(v25 + 4);
        *(_DWORD *)(v26 + 8) = *(_DWORD *)(v25 + 8);
        v28 = *(_OWORD *)(v25 + 12);
        v29 = *(_OWORD *)(v25 + 28);
        *(_QWORD *)(v26 + 44) = *(_QWORD *)(v25 + 44);
        *(_OWORD *)(v26 + 28) = v29;
        *(_OWORD *)(v26 + 12) = v28;
        v25 += 64;
        v26 += 64;
        --v27;
      }
      while (v27);
    }
    if (v19 < a2)
    {
      do
      {
        v30 = *(_QWORD *)(*(_QWORD *)v11[6] + 16 * v11[7]);
        v31 = (_QWORD *)(*(_QWORD *)(v30 + 8) + *(_QWORD *)(v30 + 32) * v24);
        *v31 = 0;
        v31[1] = 0;
        v31[2] = 0;
        v31[3] = 0xFFFFFFFF00000000;
        v31[4] = 0;
        v31[5] = -1;
        v31[6] = 0;
        v31[7] = -1;
        ++v24;
      }
      while (a2 != v24);
    }
    if (v20)
      MEMORY[0x2199F9D4C](v20, 0x1000C8077774924);
    v32 = 0;
    v33 = *(_QWORD *)(*(_QWORD *)v11[6] + 16 * v11[7]);
    v34 = (uint64_t *)(*v5 + 80);
    v35 = 5;
    do
    {
      v36 = (_QWORD *)(*(_QWORD *)(v33 + 8) + *(_QWORD *)(v33 + 32) * v32);
      v36[4] = v5;
      v36[5] = v35 - 1;
      v37 = *(v34 - 2);
      *(_DWORD *)v37 = 5;
      *(_QWORD *)(v37 + 16) = 4;
      *(_QWORD *)(v37 + 32) = 4;
      v36[6] = v5;
      v36[7] = v35;
      v38 = *v34;
      v34 += 4;
      *(_DWORD *)v38 = 6;
      *(_QWORD *)(v38 + 16) = 4;
      *(_QWORD *)(v38 + 32) = 12;
      ++v32;
      v35 += 2;
    }
    while (a2 != v32);
  }
  return v11;
}

void sub_2165BB454(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    MEMORY[0x2199F9D4C](v1, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

id **Phase::Geometry::CreateMeshFromMdlMesh@<X0>(const Phase::MdlMeshAsset *a1@<X1>, Phase::Logger *a2@<X2>, uint64_t *a3@<X8>)
{
  unint64_t SubmeshCount;
  char *v6;
  uint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _DWORD *v16;
  _DWORD *v17;
  _DWORD *v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  int v26;
  float v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float v33;
  float v34;
  float v35;
  float v36;
  uint64_t v37;
  float *v38;
  unint64_t v39;
  float *v40;
  float *v41;
  float *v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  char *v47;
  float *v48;
  int v49;
  float v50;
  float v51;
  float32x2_t v52;
  std::vector<unsigned int>::size_type v53;
  uint64_t v54;
  uint64_t v55;
  _DWORD *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int *v61;
  uint64_t v62;
  int v63;
  _DWORD *v64;
  unsigned int v65;
  _DWORD *v66;
  unint64_t v67;
  unint64_t v68;
  _QWORD *v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  _DWORD *v76;
  _DWORD *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unsigned int *v85;
  uint64_t v86;
  unsigned int v87;
  Phase::Logger *Name;
  const char *v89;
  NSObject *v90;
  int *v91;
  int *v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  unint64_t v102;
  unint64_t v103;
  void *v104;
  _QWORD *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  unsigned int v109;
  float v110;
  int8x16_t v111;
  int64x2_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  float32x2_t *v122;
  float32x2_t *v123;
  float32x2_t *v124;
  float32x2_t v125;
  float v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  int8x16_t v130;
  int8x16_t v131;
  int8x16_t v132;
  uint64_t v133;
  int8x16_t v134;
  int64x2_t v135;
  int8x16_t v136;
  int64x2_t v137;
  float v138;
  float v139;
  float v140;
  unint64_t v141;
  unint64_t v142;
  unint64_t v143;
  int8x16_t v144;
  int8x16_t v145;
  uint64_t v146;
  int8x16_t v147;
  int64x2_t v148;
  int8x16_t v149;
  int8x16_t v150;
  int64x2_t v151;
  int64x2_t v152;
  uint64_t v153;
  int8x8_t *v154;
  __int32 v155;
  int8x8_t *v156;
  unint64_t v157;
  uint64_t v158;
  unsigned int v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  _DWORD *v166;
  _DWORD *v167;
  uint64_t v168;
  uint64_t **v169;
  NSObject *v171;
  std::logic_error *exception;
  Phase::Logger *v173;
  uint64_t v174;
  int64x2_t v176;
  int64x2_t v177;
  uint64_t v178;
  float v179;
  id **v180;
  unsigned int v181;
  _QWORD *v182;
  float v183;
  uint64_t v184;
  id *v185;
  id *v186[2];
  _BYTE v187[36];
  unint64_t v188;
  std::vector<unsigned int>::value_type __x[2];
  _DWORD v190[8];
  _BYTE buf[12];
  __int16 v192;
  int v193;
  _BYTE *v194;
  uint64_t v195;

  v195 = *MEMORY[0x24BDAC8D0];
  Phase::Geometry::MdlMeshReader::MdlMeshReader((Phase::MdlMeshAsset *)&v185, a1);
  SubmeshCount = Phase::MdlMeshAsset::GetSubmeshCount(&v185);
  if (!SubmeshCount)
    goto LABEL_119;
  v6 = (char *)operator new(0xC0uLL);
  *((_QWORD *)v6 + 1) = 0;
  *((_QWORD *)v6 + 2) = 0;
  *(_QWORD *)v6 = &off_24D57D128;
  *((_DWORD *)v6 + 6) = 1;
  v7 = (uint64_t)(v6 + 24);
  *((_OWORD *)v6 + 6) = 0u;
  *((_OWORD *)v6 + 2) = xmmword_2166F8310;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *(_OWORD *)(v6 + 76) = 0u;
  *((_OWORD *)v6 + 7) = 0u;
  *((_OWORD *)v6 + 8) = 0u;
  *((_OWORD *)v6 + 9) = 0u;
  *((_OWORD *)v6 + 10) = 0u;
  *((_OWORD *)v6 + 11) = xmmword_2166F8320;
  *a3 = (uint64_t)(v6 + 24);
  a3[1] = (uint64_t)v6;
  v8 = Phase::Geometry::AddMesh((_QWORD *)v6 + 3, SubmeshCount);
  v9 = objc_msgSend(*v186[0], "vertexCount");
  v178 = (uint64_t)(v8 + 2);
  Phase::Geometry::DataStreamReference<Phase::Vector<float,3ul>>::Resize((uint64_t)(v8 + 2), v9);
  Phase::Geometry::DataStreamReference<Phase::Vector<float,3ul>>::Resize((uint64_t)(v8 + 4), v9);
  if (v9)
  {
    v10 = *(_QWORD *)(*(_QWORD *)v8[2] + 16 * v8[3]);
    v11 = *(_QWORD *)(v10 + 8);
    v12 = *(_QWORD *)(*(_QWORD *)v8[4] + 16 * v8[5]);
    v13 = *(_QWORD *)(v10 + 32);
    v14 = *(_QWORD *)(v12 + 8);
    v15 = *(_QWORD *)(v12 + 32);
    v16 = (_DWORD *)(v11 + 8);
    v17 = (_DWORD *)(v14 + 8);
    v18 = (_DWORD *)v186[1] + 3;
    do
    {
      *(v16 - 2) = *(v18 - 3);
      *(v16 - 1) = *(v18 - 2);
      *v16 = *(v18 - 1);
      *(v17 - 2) = *v18;
      *(v17 - 1) = v18[1];
      *v17 = v18[2];
      v16 = (_DWORD *)((char *)v16 + v13);
      v17 = (_DWORD *)((char *)v17 + v15);
      v18 += 6;
      --v9;
    }
    while (v9);
  }
  *((_OWORD *)v6 + 3) = xmmword_2166F8300;
  *((_QWORD *)v6 + 8) = 0x80000000800000;
  Phase::Geometry::InitMaterials(v7, SubmeshCount, 0);
  *((_DWORD *)v6 + 22) = 0;
  *((_QWORD *)v6 + 13) = *((_QWORD *)v6 + 12);
  std::vector<float>::reserve((void **)v6 + 12, SubmeshCount);
  v180 = (id **)a1;
  v19 = 0;
  v20 = 0;
  v173 = a2;
  *((_QWORD *)v6 + 23) = 0;
  if (SubmeshCount <= 1)
    v21 = 1;
  else
    v21 = SubmeshCount;
  v182 = v8;
  do
  {
    v22 = *(_QWORD *)(*(_QWORD *)v8[6] + 16 * v8[7]);
    v23 = *(_QWORD *)(v22 + 8) + *(_QWORD *)(v22 + 32) * v19;
    *(_DWORD *)(v23 + 24) = 1;
    *(_DWORD *)(v23 + 28) = v19;
    v24 = objc_msgSend(Phase::MdlMeshAsset::GetSubmesh(&v185, v19), "indexCount");
    Phase::Geometry::DataStreamReference<unsigned int>::Resize(**(_QWORD **)(v23 + 32), *(_QWORD *)(v23 + 40), v24);
    v25 = v24 / 3;
    if (v24 != 3 * (v24 / 3))
      goto LABEL_119;
    *(_QWORD *)(v7 + 160) += v25;
    *(_OWORD *)v23 = xmmword_2166F8300;
    *(_QWORD *)(v23 + 16) = 0x80000000800000;
    Phase::Geometry::DataStreamReference<Phase::Vector<float,3ul>>::Resize(v23 + 48, v24 / 3);
    if (v24 >= 3)
    {
      v28 = 0;
      v26 = 0;
      if (v25 <= 1)
        v29 = 1;
      else
        v29 = v25;
      v27 = 0.0;
      do
      {
        *(_DWORD *)buf = 0;
        v184 = 0;
        memset(v187, 0, sizeof(v187));
        v183 = 0.0;
        if (Phase::Geometry::MdlMeshReader::GetTriangle<unsigned int>((uint64_t)&v185, v19, v28, buf, (_DWORD *)&v184 + 1, (unsigned int *)&v184, (uint64_t)v187, &v183))
        {
          v30 = *(_QWORD *)(**(_QWORD **)(v23 + 32) + 16 * *(_QWORD *)(v23 + 40));
          v31 = *(_QWORD *)(v30 + 8);
          v32 = *(_QWORD *)(v30 + 32);
          *(_DWORD *)(v31 + v32 * 3 * v26) = *(_DWORD *)buf;
          *(_DWORD *)(v31 + v32 * (3 * v26 + 1)) = HIDWORD(v184);
          *(_DWORD *)(v31 + v32 * (3 * v26 + 2)) = v184;
          v33 = (float)((float)(*(float *)&v187[16] - *(float *)&v187[4])
                      * (float)(*(float *)&v187[32] - *(float *)&v187[8]))
              - (float)((float)(*(float *)&v187[20] - *(float *)&v187[8])
                      * (float)(*(float *)&v187[28] - *(float *)&v187[4]));
          v34 = (float)((float)(*(float *)&v187[20] - *(float *)&v187[8]) * (float)(*(float *)&v187[24] - *(float *)v187))
              - (float)((float)(*(float *)&v187[12] - *(float *)v187) * (float)(*(float *)&v187[32] - *(float *)&v187[8]));
          v35 = (float)((float)(*(float *)&v187[12] - *(float *)v187) * (float)(*(float *)&v187[28] - *(float *)&v187[4]))
              - (float)((float)(*(float *)&v187[16] - *(float *)&v187[4]) * (float)(*(float *)&v187[24] - *(float *)v187));
          v36 = sqrtf((float)(v35 * v35) + (float)((float)(v33 * v33) + (float)(v34 * v34)));
          v37 = *(_QWORD *)(**(_QWORD **)(v23 + 48) + 16 * *(_QWORD *)(v23 + 56));
          v38 = (float *)(*(_QWORD *)(v37 + 8) + *(_QWORD *)(v37 + 32) * v26);
          *v38 = v33 / v36;
          v38[1] = v34 / v36;
          v38[2] = v35 / v36;
          Phase::Enclose<float>((float *)v23, (float *)v187, (float *)__x);
          ++v26;
          *(_DWORD *)v23 = __x[0];
          *(_DWORD *)(v23 + 4) = __x[1];
          *(_DWORD *)(v23 + 8) = v190[0];
          *(_DWORD *)(v23 + 12) = v190[1];
          *(_DWORD *)(v23 + 16) = v190[2];
          *(_DWORD *)(v23 + 20) = v190[3];
          v27 = v27 + v183;
        }
        v28 += 3;
        --v29;
      }
      while (v29);
    }
    else
    {
      v26 = 0;
      v27 = 0.0;
    }
    v39 = *(_QWORD *)(v7 + 88);
    v40 = *(float **)(v7 + 80);
    if ((unint64_t)v40 >= v39)
    {
      v42 = *(float **)(v7 + 72);
      v43 = v40 - v42;
      v8 = v182;
      if ((unint64_t)(v43 + 1) >> 62)
        std::vector<float>::__throw_length_error[abi:ne180100]();
      v44 = v39 - (_QWORD)v42;
      v45 = (uint64_t)(v39 - (_QWORD)v42) >> 1;
      if (v45 <= v43 + 1)
        v45 = v43 + 1;
      if (v44 >= 0x7FFFFFFFFFFFFFFCLL)
        v46 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v46 = v45;
      if (v46)
      {
        v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v7 + 88, v46);
        v42 = *(float **)(v7 + 72);
        v40 = *(float **)(v7 + 80);
      }
      else
      {
        v47 = 0;
      }
      v48 = (float *)&v47[4 * v43];
      *v48 = v27;
      v41 = v48 + 1;
      while (v40 != v42)
      {
        v49 = *((_DWORD *)v40-- - 1);
        *((_DWORD *)v48-- - 1) = v49;
      }
      *(_QWORD *)(v7 + 72) = v48;
      *(_QWORD *)(v7 + 80) = v41;
      *(_QWORD *)(v7 + 88) = &v47[4 * v46];
      if (v42)
        operator delete(v42);
    }
    else
    {
      *v40 = v27;
      v41 = v40 + 1;
      v8 = v182;
    }
    *(_QWORD *)(v7 + 80) = v41;
    v7 = *a3;
    *(float *)(*a3 + 64) = v27 + *(float *)(*a3 + 64);
    if (v25 != v26)
    {
      Phase::Geometry::DataStreamReference<unsigned int>::Resize(**(_QWORD **)(v23 + 32), *(_QWORD *)(v23 + 40), 3 * v26);
      Phase::Geometry::DataStreamReference<Phase::Vector<float,3ul>>::Resize(v23 + 48, v26);
      v20 = v20 + v25 - v26;
    }
    v50 = fminf(*(float *)(v7 + 32), *(float *)(v23 + 8));
    v51 = fmaxf(*(float *)(v7 + 44), *(float *)(v23 + 20));
    v52 = vmaxnm_f32(*(float32x2_t *)(v7 + 36), *(float32x2_t *)(v23 + 12));
    *(float32x2_t *)(v7 + 24) = vminnm_f32(*(float32x2_t *)(v7 + 24), *(float32x2_t *)v23);
    *(float *)(v7 + 32) = v50;
    *(float32x2_t *)(v7 + 36) = v52;
    *(float *)(v7 + 44) = v51;
    ++v19;
  }
  while (v19 != v21);
  if (v20 > 0)
  {
    v53 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v8[2] + 16 * v8[3]) + 24);
    __x[0] = -1;
    std::vector<unsigned int>::vector((std::vector<unsigned int> *)v187, v53, __x);
    v54 = *(_QWORD *)(*(_QWORD *)v8[6] + 16 * v8[7]);
    v55 = *(_QWORD *)(v54 + 24);
    v56 = *(_DWORD **)v187;
    if (v55)
    {
      v57 = *(_QWORD *)(v54 + 8);
      v58 = v57 + (v55 << 6);
      do
      {
        v59 = *(_QWORD *)(**(_QWORD **)(v57 + 32) + 16 * *(_QWORD *)(v57 + 40));
        v60 = *(_QWORD *)(v59 + 24);
        if (v60)
        {
          v61 = *(int **)(v59 + 8);
          v62 = 4 * v60;
          do
          {
            v63 = *v61++;
            v56[v63] = 0;
            v62 -= 4;
          }
          while (v62);
        }
        v57 += 64;
      }
      while (v57 != v58);
    }
    v64 = *(_DWORD **)&v187[8];
    if (v56 == *(_DWORD **)&v187[8])
    {
      v65 = 0;
    }
    else
    {
      v65 = 0;
      v66 = v56;
      do
      {
        if (*v66 != -1)
          *v66 = v65++;
        ++v66;
      }
      while (v66 != v64);
    }
    if (v53 != v65)
    {
      v67 = v65;
      if (v53)
      {
        v68 = 0;
        v69 = (_QWORD *)v8[2];
        v70 = 16 * v8[3];
        do
        {
          v71 = v56[v68];
          if ((_DWORD)v71 != -1)
          {
            if (v71 >= v67 || v68 < v71)
              goto LABEL_119;
            v73 = *(_QWORD *)(*v69 + v70);
            v74 = *(_QWORD *)(v73 + 8);
            v75 = *(_QWORD *)(v73 + 32);
            v76 = (_DWORD *)(v74 + v75 * v68);
            v77 = (_DWORD *)(v74 + v75 * v71);
            *v77 = *v76;
            v77[1] = v76[1];
            v77[2] = v76[2];
          }
          ++v68;
        }
        while (v53 != v68);
      }
      Phase::Geometry::DataStreamReference<Phase::Vector<float,3ul>>::Resize(v178, v67);
      v78 = *(_QWORD *)(*(_QWORD *)v8[6] + 16 * v8[7]);
      v79 = *(_QWORD *)(v78 + 24);
      if (v79)
      {
        v80 = *(_QWORD *)(v78 + 8);
        v81 = v80 + (v79 << 6);
        v82 = *(_QWORD *)v187;
        while (1)
        {
          v83 = *(_QWORD *)(**(_QWORD **)(v80 + 32) + 16 * *(_QWORD *)(v80 + 40));
          v84 = *(_QWORD *)(v83 + 24);
          if (v84)
            break;
LABEL_69:
          v80 += 64;
          if (v80 == v81)
            goto LABEL_70;
        }
        v85 = *(unsigned int **)(v83 + 8);
        v86 = 4 * v84;
        while (1)
        {
          v87 = *(_DWORD *)(v82 + 4 * *v85);
          if (v87 >= v67)
            break;
          *v85++ = v87;
          v86 -= 4;
          if (!v86)
            goto LABEL_69;
        }
LABEL_119:
        std::terminate();
      }
    }
LABEL_70:
    if (*(_QWORD *)v187)
    {
      *(_QWORD *)&v187[8] = *(_QWORD *)v187;
      operator delete(*(void **)v187);
    }
    Name = (Phase::Logger *)Phase::MdlMeshAsset::GetName(v180);
    if (Name)
      v89 = (const char *)Name;
    else
      v89 = "";
    v90 = **(NSObject ***)(Phase::Logger::GetInstancePtr(Name) + 416);
    if (os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v187 = 136315906;
      *(_QWORD *)&v187[4] = "GeoMesh.cpp";
      *(_WORD *)&v187[12] = 1024;
      *(_DWORD *)&v187[14] = 446;
      *(_WORD *)&v187[18] = 1024;
      *(_DWORD *)&v187[20] = v20;
      *(_WORD *)&v187[24] = 2080;
      *(_QWORD *)&v187[26] = v89;
      _os_log_impl(&dword_2164CC000, v90, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: [%i] degenerate triangles ignored while creating a Geometry::Mesh Shape from MDLMesh:[%s]", v187, 0x22u);
    }
    *(_QWORD *)(v7 + 160) -= v20;
  }
  v91 = (int *)v173;
  if (v173
    && (v91 = (int *)Phase::UnorderedStringMap<Phase::OptionsValue>::Find(v173, (__int128 *)&Phase::Geometry::MeshOptions::SortPrimitives)) != 0&& v91[24] == 1)
  {
    v92 = v91 + 14;
  }
  else
  {
    v92 = &dword_24D579740;
  }
  v181 = *v92;
  if (*v92)
  {
    v93 = *(_QWORD **)(*(_QWORD *)v8[6] + 16 * v8[7]);
    if (v93[3])
    {
      v94 = 0;
      v176 = vdupq_n_s64(2uLL);
      v177 = vdupq_n_s64(1uLL);
      while (1)
      {
        v95 = v93[1] + v93[4] * v94;
        if (*(_DWORD *)(v95 + 24) != 1)
          goto LABEL_119;
        if (*(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v95 + 32) + 16 * *(_QWORD *)(v95 + 40)) + 24) <= 2uLL)
        {
          v171 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)v91) + 112);
          if (os_log_type_enabled(v171, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = "ManagedPtr.hpp";
            v192 = 1024;
            v193 = 229;
            _os_log_impl(&dword_2164CC000, v171, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [inCount == 0 is true]: \"Attempting to allocate an array of 0 elements\"", buf, 0x12u);
          }
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(exception, "Attempting to allocate an array of 0 elements");
        }
        v96 = *(float *)v95;
        v97 = *(float *)(v95 + 4);
        v98 = *(float *)(v95 + 16);
        v99 = *(float *)(v95 + 20);
        v100 = *(float *)(v95 + 8);
        v101 = *(float *)(v95 + 12);
        v102 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v95 + 32) + 16 * *(_QWORD *)(v95 + 40)) + 24);
        v103 = v102 / 3;
        v104 = operator new(32 * (v102 / 3), (std::align_val_t)8uLL);
        v174 = v94;
        bzero(v104, 32 * (v102 / 3));
        *(_QWORD *)buf = &off_24D57D0C8;
        buf[8] = 0;
        v194 = buf;
        *(_QWORD *)__x = v104;
        std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v190, (uint64_t)buf);
        v105 = v194;
        if (v194 == buf)
          break;
        if (v194)
        {
          v106 = 5;
LABEL_92:
          (*(void (**)(void))(*v105 + 8 * v106))();
        }
        v107 = *(_QWORD *)__x;
        *(_QWORD *)__x = 0;
        *(_QWORD *)v187 = v107;
        std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v187[8], (uint64_t)v190);
        v188 = v102 / 3;
        std::unique_ptr<Phase::Geometry::PrimitiveSortEntry [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)__x);
        if (v181 > 2)
          goto LABEL_119;
        v108 = 0;
        v109 = 0;
        v110 = 16384.0 / fmaxf(fmaxf(v101 - v96, v98 - v97), v99 - v100);
        v112 = v176;
        v111 = (int8x16_t)v177;
        do
        {
          v113 = *(_QWORD *)(**(_QWORD **)(v95 + 32) + 16 * *(_QWORD *)(v95 + 40));
          v114 = *(_QWORD *)(v113 + 8);
          v115 = *(_QWORD *)(v113 + 32);
          v116 = *(unsigned int *)(v114 + v115 * v109);
          v117 = *(unsigned int *)(v114 + v115 * (v109 + 1));
          v118 = *(unsigned int *)(v114 + v115 * (v109 + 2));
          v119 = *(_QWORD *)(*(_QWORD *)v182[2] + 16 * v182[3]);
          v120 = *(_QWORD *)(v119 + 8);
          v121 = *(_QWORD *)(v119 + 32);
          v122 = (float32x2_t *)(v120 + v121 * v116);
          v123 = (float32x2_t *)(v120 + v121 * v117);
          v124 = (float32x2_t *)(v120 + v121 * v118);
          v125 = vmul_f32(vadd_f32(vminnm_f32(vminnm_f32(*v122, *v123), *v124), vmaxnm_f32(vmaxnm_f32(*v122, *v123), *v124)), (float32x2_t)0x3F0000003F000000);
          v126 = (float)(fminf(fminf(v122[1].f32[0], v123[1].f32[0]), v124[1].f32[0])
                       + fmaxf(fmaxf(v122[1].f32[0], v123[1].f32[0]), v124[1].f32[0]))
               * 0.5;
          if (v181 == 1)
          {
            v127 = (int)(float)(v110 * (float)(v125.f32[0] - *(float *)v95));
            if (v127 >= 0x7FFF)
              goto LABEL_119;
            v128 = (int)(float)(v110 * (float)(v125.f32[1] - *(float *)(v95 + 4)));
            if (v128 >= 0x7FFF)
              goto LABEL_119;
            v129 = (int)(float)(v110 * (float)(v126 - *(float *)(v95 + 8)));
            if (v129 >= 0x7FFF)
              goto LABEL_119;
            v130 = (int8x16_t)vdupq_n_s64(v127);
            v131 = (int8x16_t)vdupq_n_s64(v128);
            v132 = 0uLL;
            v133 = 16;
            v134 = (int8x16_t)vdupq_n_s64(v129);
            v135 = (int64x2_t)xmmword_2166F7AE0;
            do
            {
              v136 = (int8x16_t)vshlq_u64((uint64x2_t)v111, (uint64x2_t)v135);
              v137 = vaddq_s64(v135, v135);
              v132 = vorrq_s8(vorrq_s8((int8x16_t)vshlq_u64((uint64x2_t)vandq_s8(v136, v131), (uint64x2_t)vorrq_s8((int8x16_t)v137, v111)), v132), vorrq_s8((int8x16_t)vshlq_u64((uint64x2_t)vandq_s8(v136, v130), (uint64x2_t)v137), (int8x16_t)vshlq_u64((uint64x2_t)vandq_s8(v136, v134), (uint64x2_t)vaddq_s64(v137, v112))));
              v135 = vaddq_s64(v135, v112);
              v133 -= 2;
            }
            while (v133);
          }
          else
          {
            v179 = v125.f32[0];
            v138 = sqrtf(vaddv_f32(vmul_f32(v125, v125)) + (float)(v126 * v126));
            v139 = acosf(v125.f32[1] / v138);
            v140 = atan2f(v179, v126);
            v141 = (int)(float)(v110 * v138);
            if (v141 >= 0x7FFF)
              goto LABEL_119;
            v142 = (int)(float)(v139 * 2607.5);
            if (v142 >= 0x7FFF)
              goto LABEL_119;
            v143 = (int)(float)((float)(v140 + 3.1416) * 2607.5);
            if (v143 >= 0x7FFF)
              goto LABEL_119;
            v144 = (int8x16_t)vdupq_n_s64(v143);
            v145 = (int8x16_t)vdupq_n_s64(v142);
            v132 = 0uLL;
            v146 = 16;
            v147 = (int8x16_t)vdupq_n_s64(v141);
            v148 = (int64x2_t)xmmword_2166F7AE0;
            v112 = v176;
            v111 = (int8x16_t)v177;
            do
            {
              v149 = (int8x16_t)vdupq_n_s64(1uLL);
              v150 = (int8x16_t)vshlq_u64((uint64x2_t)v149, (uint64x2_t)v148);
              v151 = vaddq_s64(v148, v148);
              v152 = vdupq_n_s64(2uLL);
              v132 = vorrq_s8(vorrq_s8((int8x16_t)vshlq_u64((uint64x2_t)vandq_s8(v150, v145), (uint64x2_t)vorrq_s8((int8x16_t)v151, v149)), v132), vorrq_s8((int8x16_t)vshlq_u64((uint64x2_t)vandq_s8(v150, v144), (uint64x2_t)v151), (int8x16_t)vshlq_u64((uint64x2_t)vandq_s8(v150, v147), (uint64x2_t)vaddq_s64(v151, v152))));
              v148 = vaddq_s64(v148, v152);
              v146 -= 2;
            }
            while (v146);
          }
          v109 += 3;
          v153 = *(_QWORD *)(**(_QWORD **)(v95 + 48) + 16 * *(_QWORD *)(v95 + 56));
          v154 = (int8x8_t *)(*(_QWORD *)(v153 + 8) + *(_QWORD *)(v153 + 32) * v108);
          v155 = v154[1].i32[0];
          v156 = (int8x8_t *)(*(_QWORD *)v187 + 32 * v108);
          *v156 = vorr_s8(*(int8x8_t *)v132.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v132, v132, 8uLL));
          v156[1] = *v154;
          v156[2].i32[0] = v155;
          v156[2].i32[1] = v116;
          v156[3].i32[0] = v117;
          v156[3].i32[1] = v118;
          ++v108;
        }
        while (v108 != v103);
        v157 = 126 - 2 * __clz(v188);
        if (v188)
          v158 = v157;
        else
          v158 = 0;
        std::__introsort<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *,false>(*(uint64_t *)v187, *(_QWORD *)v187 + 32 * v188, v158, 1);
        v159 = 0;
        v160 = *(_QWORD *)(**(_QWORD **)(v95 + 48) + 16 * *(_QWORD *)(v95 + 56));
        v161 = *(_QWORD *)(v160 + 8);
        v162 = *(_QWORD *)(v160 + 32);
        v163 = *(_QWORD *)(**(_QWORD **)(v95 + 32) + 16 * *(_QWORD *)(v95 + 40));
        v164 = *(_QWORD *)(v163 + 8);
        v165 = *(_QWORD *)(v163 + 32);
        v166 = (_DWORD *)(*(_QWORD *)v187 + 16);
        v167 = (_DWORD *)(v161 + 8);
        do
        {
          *(v167 - 2) = *(v166 - 2);
          *(v167 - 1) = *(v166 - 1);
          *v167 = *v166;
          *(_DWORD *)(v164 + v165 * v159) = v166[1];
          *(_DWORD *)(v164 + v165 * (v159 + 1)) = v166[2];
          v168 = v165 * (v159 + 2);
          v159 += 3;
          *(_DWORD *)(v164 + v168) = v166[3];
          v166 += 8;
          v167 = (_DWORD *)((char *)v167 + v162);
          --v103;
        }
        while (v103);
        v91 = (int *)std::unique_ptr<Phase::Geometry::PrimitiveSortEntry [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v187);
        v94 = v174 + 1;
        v93 = *(_QWORD **)(*(_QWORD *)v182[6] + 16 * v182[7]);
        if ((unint64_t)(v174 + 1) >= v93[3])
          goto LABEL_114;
      }
      v105 = buf;
      v106 = 4;
      goto LABEL_92;
    }
  }
LABEL_114:
  Phase::Geometry::SetMaterialsFromOptionalMaterialList((uint64_t **)v7, v173);
  if (v173)
  {
    v169 = Phase::UnorderedStringMap<Phase::OptionsValue>::Find(v173, (__int128 *)&Phase::Geometry::ShapeOptions::SceneQueryFilter);
    if (v169)
    {
      if (*((_DWORD *)v169 + 24) == 2)
        *(_QWORD *)(v7 + 16) = *((unsigned int *)v169 + 14);
    }
  }
  return std::unique_ptr<Phase::details::MdlMeshAssetImplementation>::reset[abi:ne180100](v186, 0);
}

void sub_2165BC304(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34)
{
  if (__p)
  {
    a34 = (uint64_t)__p;
    operator delete(__p);
  }
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](a16);
  std::unique_ptr<Phase::details::MdlMeshAssetImplementation>::reset[abi:ne180100]((id **)&a31, 0);
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::DataStreamReference<Phase::Vector<float,3ul>>::Resize(uint64_t result, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  _DWORD *v9;
  int *v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  _DWORD *v17;
  uint64_t v18;

  v3 = result;
  v4 = *(_QWORD *)(**(_QWORD **)result + 16 * *(_QWORD *)(result + 8));
  v5 = *(_QWORD *)(v4 + 24);
  if (v5 == a2)
  {
    v6 = 0;
  }
  else
  {
    v6 = *(_QWORD *)(v4 + 8);
    *(_QWORD *)(v4 + 8) = 0;
    if (a2)
    {
      Phase::Geometry::DataStream::Alloc(*(std::align_val_t *)(v4 + 16), *(_QWORD *)(v4 + 32) * a2, &v18);
      v7 = v18;
      v18 = 0;
      result = *(_QWORD *)(v4 + 8);
      *(_QWORD *)(v4 + 8) = v7;
      if (result)
      {
        MEMORY[0x2199F9D4C](result, 0x1000C8077774924);
        result = v18;
        v18 = 0;
        if (result)
          result = MEMORY[0x2199F9D4C](result, 0x1000C8077774924);
      }
    }
    *(_QWORD *)(v4 + 24) = a2;
  }
  if (v5 >= a2)
    v8 = a2;
  else
    v8 = v5;
  if (v8)
  {
    v9 = (_DWORD *)(*(_QWORD *)(v4 + 8) + 8);
    v10 = (int *)(v6 + 8);
    v11 = v8;
    do
    {
      *(v9 - 2) = *(v10 - 2);
      *(v9 - 1) = *(v10 - 1);
      v12 = *v10;
      v10 += 3;
      *v9 = v12;
      v9 += 3;
      --v11;
    }
    while (v11);
  }
  if (v5 < a2)
  {
    v13 = *(_QWORD *)(**(_QWORD **)v3 + 16 * *(_QWORD *)(v3 + 8));
    v14 = *(_QWORD *)(v13 + 8);
    v15 = *(_QWORD *)(v13 + 32);
    v16 = a2 - v8;
    v17 = (_DWORD *)(v14 + v15 * v8 + 8);
    do
    {
      *((_QWORD *)v17 - 1) = 0;
      *v17 = 0;
      v17 = (_DWORD *)((char *)v17 + v15);
      --v16;
    }
    while (v16);
  }
  if (v6)
    return MEMORY[0x2199F9D4C](v6, 0x1000C8077774924);
  return result;
}

void sub_2165BC500(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    MEMORY[0x2199F9D4C](v1, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void std::vector<float>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  int v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 2)
  {
    if (a2 >> 62)
      std::vector<float>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    v9 = &v6[4 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_DWORD *)v11 - 1);
        v11 -= 4;
        *((_DWORD *)v12 - 1) = v13;
        v12 -= 4;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t Phase::Geometry::DataStreamReference<unsigned int>::Resize(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = a3;
  v4 = *(_QWORD *)(result + 16 * a2);
  v5 = *(_QWORD *)(v4 + 24);
  if (v5 == a3)
  {
    if (!a3)
      return result;
    v6 = 0;
  }
  else
  {
    v6 = *(_QWORD *)(v4 + 8);
    *(_QWORD *)(v4 + 8) = 0;
    if (a3)
    {
      Phase::Geometry::DataStream::Alloc(*(std::align_val_t *)(v4 + 16), *(_QWORD *)(v4 + 32) * a3, &v10);
      v7 = v10;
      v10 = 0;
      result = *(_QWORD *)(v4 + 8);
      *(_QWORD *)(v4 + 8) = v7;
      if (result)
      {
        MEMORY[0x2199F9D4C](result, 0x1000C8077774924);
        result = v10;
        v10 = 0;
        if (result)
          result = MEMORY[0x2199F9D4C](result, 0x1000C8077774924);
      }
    }
    *(_QWORD *)(v4 + 24) = v3;
    if (v5 < v3)
      v3 = v5;
    if (!v3)
    {
      if (!v6)
        return result;
      return MEMORY[0x2199F9D4C](v6, 0x1000C8077774924);
    }
  }
  v8 = 0;
  v9 = *(_QWORD *)(v4 + 8);
  do
  {
    *(_DWORD *)(v9 + 4 * v8) = *(_DWORD *)(v6 + 4 * v8);
    ++v8;
  }
  while (v3 != v8);
  return MEMORY[0x2199F9D4C](v6, 0x1000C8077774924);
}

void sub_2165BC6BC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    MEMORY[0x2199F9D4C](v1, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

BOOL Phase::Geometry::MdlMeshReader::GetTriangle<unsigned int>(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5, unsigned int *a6, uint64_t a7, float *a8)
{
  unsigned int Vertex;
  uint64_t v17;
  _DWORD *v18;
  _DWORD *v19;
  _DWORD *v20;
  float v21;
  float v23;
  float v24;
  float v25;

  *a4 = Phase::Geometry::MdlMeshReader::GetVertexIndex<unsigned int>((id **)a1, a2, a3);
  *a5 = Phase::Geometry::MdlMeshReader::GetVertexIndex<unsigned int>((id **)a1, a2, a3 + 1);
  Vertex = Phase::Geometry::MdlMeshReader::GetVertexIndex<unsigned int>((id **)a1, a2, a3 + 2);
  *a6 = Vertex;
  v17 = *(_QWORD *)(a1 + 16);
  v18 = (_DWORD *)(v17 + 24 * *a4);
  *(_DWORD *)a7 = *v18;
  *(_DWORD *)(a7 + 4) = v18[1];
  *(_DWORD *)(a7 + 8) = v18[2];
  v19 = (_DWORD *)(v17 + 24 * *a5);
  *(_DWORD *)(a7 + 12) = *v19;
  *(_DWORD *)(a7 + 16) = v19[1];
  *(_DWORD *)(a7 + 20) = v19[2];
  v20 = (_DWORD *)(v17 + 24 * Vertex);
  *(_DWORD *)(a7 + 24) = *v20;
  *(_DWORD *)(a7 + 28) = v20[1];
  *(_DWORD *)(a7 + 32) = v20[2];
  Phase::UnnormalizedNormalCCW<float>((float *)a7, &v23);
  v21 = sqrtf((float)((float)(v23 * v23) + (float)(v24 * v24)) + (float)(v25 * v25)) * 0.5;
  *a8 = v21;
  return v21 > 0.00000011921;
}

float Phase::Enclose<float>@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float result;
  float v22;
  float v23;

  v3 = a2[1];
  v5 = a2[2];
  v4 = a2[3];
  v6 = a2[4];
  v7 = a2[5];
  v8 = a2[6];
  v9 = a2[7];
  v10 = fminf(fminf(*a2, v4), v8);
  v11 = fminf(fminf(v3, v6), v9);
  v12 = a2[8];
  v13 = fminf(fminf(v5, v7), v12);
  v14 = fmaxf(*a2, v4);
  v15 = fmaxf(fmaxf(v3, v6), v9);
  v16 = fmaxf(fmaxf(v5, v7), v12);
  v17 = fminf(*a1, v10);
  v18 = fminf(a1[1], v11);
  v19 = a1[3];
  v20 = fminf(a1[2], v13);
  *a3 = v17;
  a3[1] = v18;
  result = fmaxf(v19, fmaxf(v14, v8));
  v22 = fmaxf(a1[4], v15);
  v23 = fmaxf(a1[5], v16);
  a3[2] = v20;
  a3[3] = result;
  a3[4] = v22;
  a3[5] = v23;
  return result;
}

void Phase::Geometry::CreateMeshFromShape(uint64_t a1@<X1>, _QWORD *a2@<X2>, uint64_t ***a3@<X8>)
{
  std::vector<unsigned int>::pointer end;
  unsigned int *v7;
  std::vector<unsigned int>::pointer begin;
  int64_t v9;
  unint64_t v10;
  int64_t v11;
  unint64_t v12;
  char *v13;
  unsigned int *v14;
  unsigned int *v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t **v18;
  _QWORD *v19;
  uint64_t **v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  std::vector<unsigned int> __p;
  _QWORD *v40;
  uint64_t v41;
  _QWORD v42[3];
  _QWORD *v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)a1 != 1)
    std::terminate();
  Phase::Geometry::ForcedCopyTagsIncludingMaterialListFromOptions(1uLL, a2, &__p);
  end = __p.__end_;
  if (__p.__end_ >= __p.__end_cap_.__value_)
  {
    begin = __p.__begin_;
    v9 = __p.__end_ - __p.__begin_;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v11 = (char *)__p.__end_cap_.__value_ - (char *)__p.__begin_;
    if (((char *)__p.__end_cap_.__value_ - (char *)__p.__begin_) >> 1 > v10)
      v10 = v11 >> 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL)
      v12 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&__p.__end_cap_, v12);
      begin = __p.__begin_;
      end = __p.__end_;
    }
    else
    {
      v13 = 0;
    }
    v14 = (unsigned int *)&v13[4 * v9];
    v15 = (unsigned int *)&v13[4 * v12];
    *v14 = 4;
    v7 = v14 + 1;
    while (end != begin)
    {
      v16 = *--end;
      *--v14 = v16;
    }
    __p.__begin_ = v14;
    __p.__end_ = v7;
    __p.__end_cap_.__value_ = v15;
    if (begin)
      operator delete(begin);
  }
  else
  {
    *__p.__end_ = 4;
    v7 = end + 1;
  }
  __p.__end_ = v7;
  std::allocate_shared[abi:ne180100]<Phase::Geometry::Shape,std::allocator<Phase::Geometry::Shape>,Phase::Geometry::Shape&,std::vector<unsigned int> &,void>(a1, (__int32 **)&__p, a3);
  v17 = **(_QWORD **)(a1 + 120);
  v18 = *a3;
  v19 = (_QWORD *)operator new();
  *v19 = Phase::GetTypeId<Phase::Geometry::Mesh>;
  v19[1] = v18;
  v19[2] = 0;
  v19[3] = -1;
  v19[4] = 0;
  v19[5] = -1;
  v20 = v18 + 15;
  v19[6] = 0;
  v19[7] = -1;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize((uint64_t *)v18 + 15, 1uLL);
  v21 = v18 + 12;
  v42[0] = &off_24D57D080;
  v43 = v42;
  v40 = v19;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v41, (uint64_t)v42);
  v22 = v43;
  if (v43 == v42)
  {
    v23 = 4;
    v22 = v42;
  }
  else
  {
    if (!v43)
      goto LABEL_23;
    v23 = 5;
  }
  (*(void (**)(void))(*v22 + 8 * v23))();
LABEL_23:
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100](*v20, (uint64_t *)&v40);
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v40);
  v24 = *(_QWORD *)(v17 + 24);
  v19[2] = v21;
  v19[3] = v24;
  v25 = *(_QWORD *)(v17 + 40);
  v19[4] = v21;
  v19[5] = v25;
  v26 = *(_QWORD *)(v17 + 56);
  v19[6] = v21;
  v19[7] = v26;
  v27 = 16 * v26;
  v28 = *(_QWORD **)(**(_QWORD **)(v17 + 48) + 16 * v26);
  v29 = v28[3];
  if (v29)
  {
    v30 = 0;
    v31 = 0;
    v32 = v28[4];
    v33 = *(_QWORD *)(*v21 + v27);
    v34 = *(_QWORD *)(v33 + 32);
    do
    {
      v35 = (_QWORD *)(*(_QWORD *)(v33 + 8) + v31);
      v36 = v28[1] + v30;
      v37 = *(_QWORD *)(v36 + 40);
      v35[4] = v21;
      v35[5] = v37;
      v38 = *(_QWORD *)(v36 + 56);
      v35[6] = v21;
      v35[7] = v38;
      v31 += v34;
      v30 += v32;
      --v29;
    }
    while (v29);
  }
  Phase::Geometry::SetMaterialsFromOptionalMaterialList(*a3, a2);
  (*a3)[2] = *(uint64_t **)(a1 + 16);
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }
}

void sub_2165BCB4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

float Phase::Geometry::GetNormals(uint64_t a1, unsigned int *a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float result;

  v6 = a3 * a6;
  if (v6 >= 1)
  {
    v7 = (unsigned int *)((char *)a2 + v6);
    v8 = *(_QWORD *)(**(_QWORD **)(a1 + 48) + 16 * *(_QWORD *)(a1 + 56));
    v9 = *(_QWORD *)(v8 + 8);
    v10 = *(_QWORD *)(v8 + 32);
    v11 = (float *)(a4 + 8);
    do
    {
      v12 = *a2;
      v13 = *(_QWORD *)(**(_QWORD **)(v9 + v10 * (v12 >> 24) + 48) + 16 * *(_QWORD *)(v9 + v10 * (v12 >> 24) + 56));
      v14 = *(_QWORD *)(v13 + 8) + *(_QWORD *)(v13 + 32) * (v12 & 0xFFFFFF);
      *(v11 - 2) = *(float *)v14;
      *(v11 - 1) = *(float *)(v14 + 4);
      result = *(float *)(v14 + 8);
      *v11 = result;
      a2 = (unsigned int *)((char *)a2 + a3);
      v11 = (float *)((char *)v11 + a5);
    }
    while (a2 < v7);
  }
  return result;
}

{
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float *v11;
  float *v12;
  float result;

  v6 = a3 * a6;
  if (v6 >= 1)
  {
    v7 = (unsigned int *)((char *)a2 + v6);
    v8 = *(_QWORD *)(**(_QWORD **)(a1 + 48) + 16 * *(_QWORD *)(a1 + 56));
    v9 = *(_QWORD *)(v8 + 8);
    v10 = *(_QWORD *)(v8 + 32);
    v11 = (float *)(a4 + 8);
    do
    {
      v12 = (float *)(v9 + v10 * *a2);
      *(v11 - 2) = *v12;
      *(v11 - 1) = v12[1];
      result = v12[2];
      *v11 = result;
      a2 = (unsigned int *)((char *)a2 + a3);
      v11 = (float *)((char *)v11 + a5);
    }
    while (a2 < v7);
  }
  return result;
}

{
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float *v14;
  float *v15;
  float result;

  v6 = a3 * a6;
  if (v6 >= 1)
  {
    v7 = (unsigned int *)((char *)a2 + v6);
    v8 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 40) + 16 * *(_QWORD *)(a1 + 48)) + 8);
    v9 = *(_QWORD **)(**(_QWORD **)(v8 + 40) + 16 * *(_QWORD *)(v8 + 48));
    v10 = v9[1] + (v9[3] - 1) * v9[4];
    v11 = *(_QWORD *)(**(_QWORD **)(v10 + 40) + 16 * *(_QWORD *)(v10 + 48));
    v12 = *(_QWORD *)(v11 + 8);
    v13 = *(_QWORD *)(v11 + 32);
    v14 = (float *)(a4 + 8);
    do
    {
      v15 = (float *)(v12 + v13 * *a2);
      *(v14 - 2) = *v15;
      *(v14 - 1) = v15[1];
      result = v15[2];
      *v14 = result;
      a2 = (unsigned int *)((char *)a2 + a3);
      v14 = (float *)((char *)v14 + a5);
    }
    while (a2 < v7);
  }
  return result;
}

float Phase::Geometry::GetNormals(uint64_t a1, float *a2, unsigned int *a3, int a4, uint64_t a5, int a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  uint64_t v12;
  unint64_t v13;
  _DWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float result;
  uint64_t v19;
  float v20;

  v7 = a4;
  v8 = a4 * a7;
  if (v8 >= 1)
  {
    v9 = a3;
    v12 = a6;
    v13 = (unint64_t)a3 + v8;
    v14 = (_DWORD *)(a5 + 8);
    do
    {
      v15 = *v9;
      v16 = *(_QWORD *)(**(_QWORD **)(a1 + 48) + 16 * *(_QWORD *)(a1 + 56));
      v17 = *(_QWORD *)(**(_QWORD **)(*(_QWORD *)(v16 + 8) + *(_QWORD *)(v16 + 32) * (v15 >> 24) + 48)
                      + 16 * *(_QWORD *)(*(_QWORD *)(v16 + 8) + *(_QWORD *)(v16 + 32) * (v15 >> 24) + 56));
      Phase::operator*<float>(a2, (float *)(*(_QWORD *)(v17 + 8) + *(_QWORD *)(v17 + 32) * (v15 & 0xFFFFFF)), (float *)&v19);
      *((_QWORD *)v14 - 1) = v19;
      result = v20;
      *(float *)v14 = v20;
      v9 = (unsigned int *)((char *)v9 + v7);
      v14 = (_DWORD *)((char *)v14 + v12);
    }
    while ((unint64_t)v9 < v13);
  }
  return result;
}

{
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _DWORD *v16;
  uint64_t v17;
  float result;
  uint64_t v19;
  float v20;

  v7 = a4;
  v8 = a4 * a7;
  if (v8 >= 1)
  {
    v9 = a3;
    v11 = a6;
    v12 = (unint64_t)a3 + v8;
    v13 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 40) + 16 * *(_QWORD *)(a1 + 48)) + 8);
    v14 = *(_QWORD **)(**(_QWORD **)(v13 + 40) + 16 * *(_QWORD *)(v13 + 48));
    v15 = v14[1] + (v14[3] - 1) * v14[4];
    v16 = (_DWORD *)(a5 + 8);
    do
    {
      v17 = *(_QWORD *)(**(_QWORD **)(v15 + 40) + 16 * *(_QWORD *)(v15 + 48));
      Phase::operator*<float>(a2, (float *)(*(_QWORD *)(v17 + 8) + *(_QWORD *)(v17 + 32) * *v9), (float *)&v19);
      *((_QWORD *)v16 - 1) = v19;
      result = v20;
      *(float *)v16 = v20;
      v9 = (unsigned int *)((char *)v9 + v7);
      v16 = (_DWORD *)((char *)v16 + v11);
    }
    while ((unint64_t)v9 < v12);
  }
  return result;
}

uint64_t Phase::Geometry::GetMaterials(uint64_t result, unint64_t a2, int a3, _QWORD *a4, int a5, uint64_t a6)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v6 = a3 * a6;
  if (v6 >= 1)
  {
    v7 = a2 + v6;
    v8 = *(_QWORD *)(**(_QWORD **)(result + 48) + 16 * *(_QWORD *)(result + 56));
    v9 = *(_QWORD *)(v8 + 8);
    v10 = *(_QWORD *)(v8 + 32);
    v11 = v9 + 28;
    v12 = *(_QWORD *)(**(_QWORD **)(*(_QWORD *)(result + 8) + 144)
                    + 16 * *(_QWORD *)(*(_QWORD *)(result + 8) + 152));
    v13 = *(_QWORD *)(v12 + 8);
    v14 = *(_QWORD *)(v12 + 32);
    do
    {
      *a4 = *(_QWORD *)(v13 + v14 * *(unsigned int *)(v11 + v10 * *(unsigned __int8 *)(a2 + 3)));
      a4 = (_QWORD *)((char *)a4 + a5);
      a2 += a3;
    }
    while (a2 < v7);
  }
  return result;
}

void std::vector<std::shared_ptr<Phase::Geometry::SharedDataStream>>::resize(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v3 = *(_QWORD *)(a1 + 8);
  v4 = (v3 - *(_QWORD *)a1) >> 4;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *(_QWORD *)a1 + 16 * a2;
      while (v3 != v5)
        v3 = std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v3 - 16);
      *(_QWORD *)(a1 + 8) = v5;
    }
  }
  else
  {
    std::vector<std::shared_ptr<Phase::Geometry::SharedDataStream>>::__append((char **)a1, a2 - v4);
  }
}

void std::vector<std::shared_ptr<Phase::Geometry::SharedDataStream>>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;
  int64x2_t v20;
  char *v21;
  uint64_t v22;
  int64x2_t v23;
  char *v24;
  uint64_t v25;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 4);
    if (v9 >> 60)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 4;
    v11 = v5 - *a1;
    if (v11 >> 3 > v9)
      v9 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v25 = v4;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::UniqueObjectId>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[16 * v10];
    v15 = &v13[16 * v12];
    v24 = v15;
    bzero(v14, 16 * a2);
    v16 = &v14[16 * a2];
    v23.i64[1] = (uint64_t)v16;
    v18 = *a1;
    v17 = a1[1];
    if (v17 == *a1)
    {
      v20 = vdupq_n_s64((unint64_t)v17);
    }
    else
    {
      do
      {
        v19 = *((_OWORD *)v17 - 1);
        v17 -= 16;
        *((_OWORD *)v14 - 1) = v19;
        v14 -= 16;
        *(_QWORD *)v17 = 0;
        *((_QWORD *)v17 + 1) = 0;
      }
      while (v17 != v18);
      v20 = *(int64x2_t *)a1;
      v16 = (char *)v23.i64[1];
      v15 = v24;
    }
    *a1 = v14;
    a1[1] = v16;
    v23 = v20;
    v21 = a1[2];
    a1[2] = v15;
    v24 = v21;
    v22 = v20.i64[0];
    std::__split_buffer<std::shared_ptr<Phase::Geometry::SharedDataStream>>::~__split_buffer((uint64_t)&v22);
  }
}

uint64_t std::__split_buffer<std::shared_ptr<Phase::Geometry::SharedDataStream>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;
    std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](i - 16);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__shared_ptr_emplace<Phase::Geometry::SharedDataStream>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57D048;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Phase::Geometry::SharedDataStream>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57D048;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__shared_ptr_emplace<Phase::Geometry::SharedDataStream>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = 0;
  if (result)
    JUMPOUT(0x2199F9D4CLL);
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::Mesh>(Phase::Geometry::Mesh *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::Mesh>(Phase::Geometry::Mesh *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::Mesh>(Phase::Geometry::Mesh *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::Mesh>(Phase::Geometry::Mesh *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57D080;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::Mesh>(Phase::Geometry::Mesh *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::Mesh>(Phase::Geometry::Mesh *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57D080;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::Mesh>(Phase::Geometry::Mesh *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::Mesh>(Phase::Geometry::Mesh *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
    JUMPOUT(0x2199F9D70);
  return result;
}

void *Phase::Geometry::DataStream::Alloc@<X0>(std::align_val_t this@<X0>, size_t __sz@<X1>, _QWORD *a3@<X8>)
{
  void *result;
  NSObject *v6;
  std::logic_error *exception;
  int v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  std::align_val_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if (__sz)
  {
    if (this)
    {
      if ((this & (this - 1)) != 0)
      {
        v6 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)this) + 416);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          v8 = 136315650;
          v9 = "GeoData.hpp";
          v10 = 1024;
          v11 = 186;
          v12 = 2048;
          v13 = this;
          _os_log_impl(&dword_2164CC000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [!Phase::IsPowerOfTwo(inAlignment) is true]: \"Error allocating memory - alignment must be power of two. Alignment requested %zu\"", (uint8_t *)&v8, 0x1Cu);
        }
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "Error allocating memory - alignment must be power of two. Alignment requested %zu");
      }
      result = operator new(__sz, this);
    }
    else
    {
      result = operator new(__sz);
    }
  }
  else
  {
    result = 0;
  }
  *a3 = result;
  return result;
}

void sub_2165BD150(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

std::vector<unsigned int> *__cdecl std::vector<unsigned int>::vector(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n, const std::vector<unsigned int>::value_type *__x)
{
  std::vector<unsigned int>::pointer end;
  unsigned int *v7;
  std::vector<unsigned int>::size_type v8;

  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<unsigned int>::__vallocate[abi:ne180100](this, __n);
    end = this->__end_;
    v7 = &end[__n];
    v8 = 4 * __n;
    do
    {
      *end++ = *__x;
      v8 -= 4;
    }
    while (v8);
    this->__end_ = v7;
  }
  return this;
}

void sub_2165BD1D0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry18PrimitiveSortEntryERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_ED0Ev()
{
  JUMPOUT(0x2199F9D70);
}

_BYTE *_ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry18PrimitiveSortEntryERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_E7__cloneEv(uint64_t a1)
{
  _BYTE *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = &off_24D57D0C8;
  result[8] = *(_BYTE *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry18PrimitiveSortEntryERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_E7__cloneEPNS0_6__baseISD_EE(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24D57D0C8;
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(result + 8);
  return result;
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry18PrimitiveSortEntryERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_EclEOSC_(uint64_t a1, void **a2)
{
  operator delete(*a2);
}

uint64_t *std::unique_ptr<Phase::Geometry::PrimitiveSortEntry [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v7;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v7 = v2;
    v3 = a1[4];
    if (!v3)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v7);
  }
  v4 = (uint64_t *)a1[4];
  if (v4 == a1 + 1)
  {
    v5 = 4;
    v4 = a1 + 1;
    goto LABEL_8;
  }
  if (v4)
  {
    v5 = 5;
LABEL_8:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  return a1;
}

void std::__introsort<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *,false>(uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  int v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  BOOL v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  int v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int64_t v65;
  int64_t v66;
  int64_t v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  BOOL v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  int v85;
  int v86;
  int v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  uint64_t *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  int v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  int v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  int v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  int v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  int v131;
  int v132;
  int v133;
  int v134;
  int v135;
  int v136;
  int v137;
  int v138;

float std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  float result;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  int v32;
  int v33;

  result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>(a1, a2, a3, a4);
  v11 = *(_QWORD *)a4;
  if (*(_QWORD *)a5 < *(_QWORD *)a4)
  {
    result = *(float *)(a4 + 16);
    v12 = (_QWORD *)(a4 + 20);
    v26 = *(_QWORD *)(a4 + 20);
    v30 = *(_DWORD *)(a4 + 28);
    *(_QWORD *)a4 = *(_QWORD *)a5;
    v13 = *(_QWORD *)(a4 + 8);
    *(_DWORD *)(a4 + 8) = *(_DWORD *)(a5 + 8);
    *(_DWORD *)(a4 + 12) = *(_DWORD *)(a5 + 12);
    *(_DWORD *)(a4 + 16) = *(_DWORD *)(a5 + 16);
    v14 = *(_DWORD *)(a5 + 28);
    *(_QWORD *)(a4 + 20) = *(_QWORD *)(a5 + 20);
    *(_DWORD *)(a4 + 28) = v14;
    *(_QWORD *)a5 = v11;
    *(_QWORD *)(a5 + 8) = v13;
    *(float *)(a5 + 16) = result;
    *(_QWORD *)(a5 + 20) = v26;
    *(_DWORD *)(a5 + 28) = v30;
    v15 = *(_QWORD *)a3;
    if (*(_QWORD *)a4 < *(_QWORD *)a3)
    {
      result = *(float *)(a3 + 16);
      v16 = (_QWORD *)(a3 + 20);
      v27 = *(_QWORD *)(a3 + 20);
      v31 = *(_DWORD *)(a3 + 28);
      *(_QWORD *)a3 = *(_QWORD *)a4;
      v17 = *(_QWORD *)(a3 + 8);
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(a4 + 8);
      *(_DWORD *)(a3 + 12) = *(_DWORD *)(a4 + 12);
      *(_DWORD *)(a3 + 16) = *(_DWORD *)(a4 + 16);
      v18 = *(_DWORD *)(a4 + 28);
      *(_QWORD *)(a3 + 20) = *v12;
      *(_DWORD *)(a3 + 28) = v18;
      *(_QWORD *)a4 = v15;
      *(_QWORD *)(a4 + 8) = v17;
      *(float *)(a4 + 16) = result;
      *v12 = v27;
      *(_DWORD *)(a4 + 28) = v31;
      v19 = *(_QWORD *)a2;
      if (*(_QWORD *)a3 < *(_QWORD *)a2)
      {
        result = *(float *)(a2 + 16);
        v20 = (_QWORD *)(a2 + 20);
        v28 = *(_QWORD *)(a2 + 20);
        v32 = *(_DWORD *)(a2 + 28);
        *(_QWORD *)a2 = *(_QWORD *)a3;
        v21 = *(_QWORD *)(a2 + 8);
        *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
        *(_DWORD *)(a2 + 12) = *(_DWORD *)(a3 + 12);
        *(_DWORD *)(a2 + 16) = *(_DWORD *)(a3 + 16);
        v22 = *(_DWORD *)(a3 + 28);
        *(_QWORD *)(a2 + 20) = *v16;
        *(_DWORD *)(a2 + 28) = v22;
        *(_QWORD *)a3 = v19;
        *(_QWORD *)(a3 + 8) = v21;
        *(float *)(a3 + 16) = result;
        *v16 = v28;
        *(_DWORD *)(a3 + 28) = v32;
        v23 = *(_QWORD *)a1;
        if (*(_QWORD *)a2 < *(_QWORD *)a1)
        {
          result = *(float *)(a1 + 16);
          v29 = *(_QWORD *)(a1 + 20);
          v33 = *(_DWORD *)(a1 + 28);
          *(_QWORD *)a1 = *(_QWORD *)a2;
          v24 = *(_QWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
          *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
          *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
          v25 = *(_DWORD *)(a2 + 28);
          *(_QWORD *)(a1 + 20) = *v20;
          *(_DWORD *)(a1 + 28) = v25;
          *(_QWORD *)a2 = v23;
          *(_QWORD *)(a2 + 8) = v24;
          *(float *)(a2 + 16) = result;
          *v20 = v29;
          *(_DWORD *)(a2 + 28) = v33;
        }
      }
    }
  }
  return result;
}

unint64_t *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>(unint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  int v7;
  unint64_t v8;
  int v9;
  int v10;
  uint64_t *v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  int v31;

  v3 = *a2;
  v4 = *result;
  v5 = *a3;
  if (*a2 >= *result)
  {
    if (v5 < v3)
    {
      v10 = *((_DWORD *)a2 + 4);
      v11 = (uint64_t *)((char *)a2 + 20);
      v25 = *(unint64_t *)((char *)a2 + 20);
      v29 = *((_DWORD *)a2 + 7);
      *a2 = v5;
      v12 = a2[1];
      *((_DWORD *)a2 + 2) = *((_DWORD *)a3 + 2);
      *((_DWORD *)a2 + 3) = *((_DWORD *)a3 + 3);
      *((_DWORD *)a2 + 4) = *((_DWORD *)a3 + 4);
      v13 = *((_DWORD *)a3 + 7);
      *(unint64_t *)((char *)a2 + 20) = *(unint64_t *)((char *)a3 + 20);
      *((_DWORD *)a2 + 7) = v13;
      *a3 = v3;
      a3[1] = v12;
      *((_DWORD *)a3 + 4) = v10;
      *(unint64_t *)((char *)a3 + 20) = v25;
      *((_DWORD *)a3 + 7) = v29;
      v14 = *result;
      if (*a2 < *result)
      {
        v15 = *((_DWORD *)result + 4);
        v26 = *(unint64_t *)((char *)result + 20);
        v30 = *((_DWORD *)result + 7);
        *result = *a2;
        v16 = result[1];
        *((_DWORD *)result + 2) = *((_DWORD *)a2 + 2);
        *((_DWORD *)result + 3) = *((_DWORD *)a2 + 3);
        *((_DWORD *)result + 4) = *((_DWORD *)a2 + 4);
        v17 = *((_DWORD *)a2 + 7);
        *(unint64_t *)((char *)result + 20) = *v11;
        *((_DWORD *)result + 7) = v17;
        *a2 = v14;
        a2[1] = v16;
        *((_DWORD *)a2 + 4) = v15;
        *v11 = v26;
        *((_DWORD *)a2 + 7) = v30;
      }
    }
  }
  else
  {
    v6 = (uint64_t *)((char *)result + 20);
    if (v5 >= v3)
    {
      v18 = *((_DWORD *)result + 2);
      v19 = *((_DWORD *)result + 3);
      v20 = *((_DWORD *)result + 4);
      v27 = *v6;
      v31 = *((_DWORD *)result + 7);
      *result = v3;
      *((_DWORD *)result + 2) = *((_DWORD *)a2 + 2);
      *((_DWORD *)result + 3) = *((_DWORD *)a2 + 3);
      *((_DWORD *)result + 4) = *((_DWORD *)a2 + 4);
      v21 = (uint64_t *)((char *)a2 + 20);
      v22 = *(unint64_t *)((char *)a2 + 20);
      *((_DWORD *)result + 7) = *((_DWORD *)a2 + 7);
      *v6 = v22;
      *a2 = v4;
      *((_DWORD *)a2 + 2) = v18;
      *((_DWORD *)a2 + 3) = v19;
      *((_DWORD *)a2 + 4) = v20;
      *(unint64_t *)((char *)a2 + 20) = v27;
      *((_DWORD *)a2 + 7) = v31;
      if (*a3 >= v4)
        return result;
      v24 = *v21;
      v28 = *((_DWORD *)a2 + 7);
      *a2 = *a3;
      *((_DWORD *)a2 + 2) = *((_DWORD *)a3 + 2);
      *((_DWORD *)a2 + 3) = *((_DWORD *)a3 + 3);
      *((_DWORD *)a2 + 4) = *((_DWORD *)a3 + 4);
      v23 = *((_DWORD *)a3 + 7);
      *v21 = *(unint64_t *)((char *)a3 + 20);
      *((_DWORD *)a2 + 7) = v23;
      *a3 = v4;
      *((_DWORD *)a3 + 2) = v18;
      *((_DWORD *)a3 + 3) = v19;
      *((_DWORD *)a3 + 4) = v20;
    }
    else
    {
      v7 = *((_DWORD *)result + 4);
      v24 = *v6;
      v28 = *((_DWORD *)result + 7);
      *result = v5;
      v8 = result[1];
      *((_DWORD *)result + 2) = *((_DWORD *)a3 + 2);
      *((_DWORD *)result + 3) = *((_DWORD *)a3 + 3);
      *((_DWORD *)result + 4) = *((_DWORD *)a3 + 4);
      v9 = *((_DWORD *)a3 + 7);
      *v6 = *(unint64_t *)((char *)a3 + 20);
      *((_DWORD *)result + 7) = v9;
      *a3 = v4;
      a3[1] = v8;
      *((_DWORD *)a3 + 4) = v7;
    }
    *(unint64_t *)((char *)a3 + 20) = v24;
    *((_DWORD *)a3 + 7) = v28;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  unint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  unint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;

  v4 = (a2 - a1) >> 5;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(_QWORD *)(a2 - 32);
      v7 = *(_QWORD *)a1;
      if (v6 < *(_QWORD *)a1)
      {
        v8 = *(_DWORD *)(a1 + 16);
        v23 = *(_QWORD *)(a1 + 20);
        v25 = *(_DWORD *)(a1 + 28);
        *(_QWORD *)a1 = v6;
        v9 = *(_QWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 - 24);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 - 20);
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 - 16);
        v10 = *(_DWORD *)(a2 - 4);
        *(_QWORD *)(a1 + 20) = *(_QWORD *)(a2 - 12);
        *(_DWORD *)(a1 + 28) = v10;
        *(_QWORD *)(a2 - 32) = v7;
        *(_QWORD *)(a2 - 24) = v9;
        *(_DWORD *)(a2 - 16) = v8;
        *(_QWORD *)(a2 - 12) = v23;
        *(_DWORD *)(a2 - 4) = v25;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>((unint64_t *)a1, (unint64_t *)(a1 + 32), (unint64_t *)(a2 - 32));
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>(a1, a1 + 32, a1 + 64, a2 - 32);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *,0>(a1, a1 + 32, a1 + 64, a1 + 96, a2 - 32);
      return 1;
    default:
      v11 = (unint64_t *)(a1 + 64);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>((unint64_t *)a1, (unint64_t *)(a1 + 32), (unint64_t *)(a1 + 64));
      v12 = a1 + 96;
      if (a1 + 96 == a2)
        return 1;
      v13 = 0;
      v14 = 0;
      break;
  }
  while (1)
  {
    v15 = *(_QWORD *)v12;
    if (*(_QWORD *)v12 < *v11)
    {
      v16 = *(_QWORD *)(v12 + 8);
      v17 = *(_DWORD *)(v12 + 16);
      v24 = *(_QWORD *)(v12 + 20);
      v26 = *(_DWORD *)(v12 + 28);
      v18 = *v11;
      v19 = v13;
      while (1)
      {
        v20 = a1 + v19;
        v21 = *(_QWORD *)(a1 + v19 + 72);
        *(_QWORD *)(v20 + 96) = v18;
        *(_QWORD *)(v20 + 104) = v21;
        *(_DWORD *)(v20 + 112) = *(_DWORD *)(a1 + v19 + 80);
        *(_QWORD *)(v20 + 116) = *(_QWORD *)(a1 + v19 + 84);
        *(_DWORD *)(v20 + 124) = *(_DWORD *)(a1 + v19 + 92);
        if (v19 == -64)
          break;
        v18 = *(_QWORD *)(v20 + 32);
        v19 -= 32;
        if (v15 >= v18)
        {
          v22 = a1 + v19 + 96;
          goto LABEL_12;
        }
      }
      v22 = a1;
LABEL_12:
      *(_QWORD *)v22 = v15;
      *(_QWORD *)(v22 + 8) = v16;
      *(_DWORD *)(v22 + 16) = v17;
      *(_QWORD *)(v20 + 84) = v24;
      *(_DWORD *)(v20 + 92) = v26;
      if (++v14 == 8)
        return v12 + 32 == a2;
    }
    v11 = (unint64_t *)v12;
    v13 += 32;
    v12 += 32;
    if (v12 == a2)
      return 1;
  }
}

float std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  float result;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;

  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>((unint64_t *)a1, (unint64_t *)a2, (unint64_t *)a3);
  v9 = *(_QWORD *)a3;
  if (*(_QWORD *)a4 < *(_QWORD *)a3)
  {
    result = *(float *)(a3 + 16);
    v10 = (_QWORD *)(a3 + 20);
    v20 = *(_QWORD *)(a3 + 20);
    v23 = *(_DWORD *)(a3 + 28);
    *(_QWORD *)a3 = *(_QWORD *)a4;
    v11 = *(_QWORD *)(a3 + 8);
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a4 + 8);
    *(_DWORD *)(a3 + 12) = *(_DWORD *)(a4 + 12);
    *(_DWORD *)(a3 + 16) = *(_DWORD *)(a4 + 16);
    v12 = *(_DWORD *)(a4 + 28);
    *(_QWORD *)(a3 + 20) = *(_QWORD *)(a4 + 20);
    *(_DWORD *)(a3 + 28) = v12;
    *(_QWORD *)a4 = v9;
    *(_QWORD *)(a4 + 8) = v11;
    *(float *)(a4 + 16) = result;
    *(_QWORD *)(a4 + 20) = v20;
    *(_DWORD *)(a4 + 28) = v23;
    v13 = *(_QWORD *)a2;
    if (*(_QWORD *)a3 < *(_QWORD *)a2)
    {
      result = *(float *)(a2 + 16);
      v14 = (_QWORD *)(a2 + 20);
      v21 = *(_QWORD *)(a2 + 20);
      v24 = *(_DWORD *)(a2 + 28);
      *(_QWORD *)a2 = *(_QWORD *)a3;
      v15 = *(_QWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(a3 + 12);
      *(_DWORD *)(a2 + 16) = *(_DWORD *)(a3 + 16);
      v16 = *(_DWORD *)(a3 + 28);
      *(_QWORD *)(a2 + 20) = *v10;
      *(_DWORD *)(a2 + 28) = v16;
      *(_QWORD *)a3 = v13;
      *(_QWORD *)(a3 + 8) = v15;
      *(float *)(a3 + 16) = result;
      *v10 = v21;
      *(_DWORD *)(a3 + 28) = v24;
      v17 = *(_QWORD *)a1;
      if (*(_QWORD *)a2 < *(_QWORD *)a1)
      {
        result = *(float *)(a1 + 16);
        v22 = *(_QWORD *)(a1 + 20);
        v25 = *(_DWORD *)(a1 + 28);
        *(_QWORD *)a1 = *(_QWORD *)a2;
        v18 = *(_QWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
        v19 = *(_DWORD *)(a2 + 28);
        *(_QWORD *)(a1 + 20) = *v14;
        *(_DWORD *)(a1 + 28) = v19;
        *(_QWORD *)a2 = v17;
        *(_QWORD *)(a2 + 8) = v18;
        *(float *)(a2 + 16) = result;
        *v14 = v22;
        *(_DWORD *)(a2 + 28) = v25;
      }
    }
  }
  return result;
}

void std::__shared_ptr_emplace<Phase::Geometry::Shape>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57D128;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Phase::Geometry::Shape>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57D128;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

void std::__shared_ptr_emplace<Phase::Geometry::Shape>::__on_zero_shared(uint64_t a1)
{
  char v1;

  std::allocator<Phase::Geometry::Shape>::destroy[abi:ne180100]((uint64_t)&v1, a1 + 24);
}

void std::allocator<Phase::Geometry::Shape>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v3;
  void **v4;

  v4 = (void **)(a2 + 120);
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__destroy_vector::operator()[abi:ne180100](&v4);
  v4 = (void **)(a2 + 96);
  std::vector<std::shared_ptr<Phase::Controller::Renderer>>::__destroy_vector::operator()[abi:ne180100](&v4);
  v3 = *(void **)(a2 + 72);
  if (v3)
  {
    *(_QWORD *)(a2 + 80) = v3;
    operator delete(v3);
  }
}

uint64_t Phase::Geometry::MdlMeshReader::GetVertexIndex<unsigned int>(id **a1, uint64_t a2, uint64_t a3)
{
  int IndexBufferFormat;
  id Submesh;

  Submesh = Phase::MdlMeshAsset::GetSubmesh(a1, a2);
  IndexBufferFormat = Phase::MdlMeshAsset::Submesh::GetIndexBufferFormat(&Submesh);
  switch(IndexBufferFormat)
  {
    case 3:
      return *(unsigned int *)(Phase::MdlMeshAsset::Submesh::GetIndexBuffer(&Submesh) + 4 * a3);
    case 2:
      return *(unsigned __int16 *)(Phase::MdlMeshAsset::Submesh::GetIndexBuffer(&Submesh) + 2 * a3);
    case 1:
      return *(unsigned __int8 *)(Phase::MdlMeshAsset::Submesh::GetIndexBuffer(&Submesh) + a3);
  }
  return 0;
}

float Phase::UnnormalizedNormalCCW<float>@<S0>(float *a1@<X0>, float *a2@<X8>)
{
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float result;

  v2 = a1[1];
  v3 = a1[2];
  v4 = a1[3] - *a1;
  v5 = a1[6] - *a1;
  v6 = a1[4] - v2;
  v7 = a1[5] - v3;
  v8 = a1[7] - v2;
  v9 = a1[8] - v3;
  v10 = (float)(v6 * v9) - (float)(v7 * v8);
  v11 = (float)(v7 * v5) - (float)(v4 * v9);
  result = (float)(v4 * v8) - (float)(v6 * v5);
  *a2 = v10;
  a2[1] = v11;
  a2[2] = result;
  return result;
}

_QWORD *std::allocate_shared[abi:ne180100]<Phase::Geometry::Shape,std::allocator<Phase::Geometry::Shape>,Phase::Geometry::Shape&,std::vector<unsigned int> &,void>@<X0>(uint64_t a1@<X1>, __int32 **a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = operator new(0xC0uLL);
  result = std::__shared_ptr_emplace<Phase::Geometry::Shape>::__shared_ptr_emplace[abi:ne180100]<Phase::Geometry::Shape&,std::vector<unsigned int> &,std::allocator<Phase::Geometry::Shape>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_2165BE6F4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<Phase::Geometry::Shape>::__shared_ptr_emplace[abi:ne180100]<Phase::Geometry::Shape&,std::vector<unsigned int> &,std::allocator<Phase::Geometry::Shape>,0>(_QWORD *a1, uint64_t a2, __int32 **a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_24D57D128;
  Phase::Geometry::Shape::Shape((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_2165BE73C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::Shape::Shape(uint64_t a1, uint64_t a2, __int32 **a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  v6 = *(_QWORD *)(a2 + 60);
  *(_QWORD *)(a1 + 72) = 0;
  v7 = a1 + 72;
  *(_QWORD *)(a1 + 60) = v6;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)(a1 + 72), *(const void **)(a2 + 72), *(_QWORD *)(a2 + 80), (uint64_t)(*(_QWORD *)(a2 + 80) - *(_QWORD *)(a2 + 72)) >> 2);
  v8 = Phase::Geometry::DataSet::DataSet((_QWORD *)(v7 + 24), (uint64_t *)(a2 + 96), a3);
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 144) = v8;
  *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
  return a1;
}

void sub_2165BE828(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 80) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *Phase::Geometry::DataSet::DataSet(_QWORD *a1, uint64_t *a2, __int32 **a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int32 *v11;
  __int32 *v12;
  __int32 *v13;
  char *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  __int128 v19;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v7 = *a2;
  v6 = a2[1];
  v8 = (v6 - *a2) >> 4;
  std::vector<std::shared_ptr<Phase::Geometry::SharedDataStream>>::resize((uint64_t)a1, v8);
  if (v6 != v7)
  {
    v9 = 0;
    if (v8 <= 1)
      v10 = 1;
    else
      v10 = v8;
    do
    {
      v11 = a3[1];
      v12 = wmemchr(*a3, **(_DWORD **)(*a2 + 16 * v9), v11 - *a3);
      if (v12)
        v13 = v12;
      else
        v13 = v11;
      if (v13 == a3[1])
      {
        std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(*a1 + 16 * v9), (uint64_t *)(*a2 + 16 * v9));
      }
      else
      {
        v14 = (char *)operator new(0x40uLL);
        *((_QWORD *)v14 + 1) = 0;
        *((_QWORD *)v14 + 2) = 0;
        *(_QWORD *)v14 = &off_24D57D048;
        *(_OWORD *)(v14 + 40) = 0u;
        *((_QWORD *)v14 + 7) = 0;
        *(_OWORD *)(v14 + 24) = 0u;
        *(_QWORD *)&v19 = v14 + 24;
        *((_QWORD *)&v19 + 1) = v14;
        std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100](*a1 + 16 * v9, &v19);
        v15 = (std::__shared_weak_count *)*((_QWORD *)&v19 + 1);
        if (*((_QWORD *)&v19 + 1))
        {
          v16 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
          do
            v17 = __ldaxr(v16);
          while (__stlxr(v17 - 1, v16));
          if (!v17)
          {
            ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
            std::__shared_weak_count::__release_weak(v15);
          }
        }
        Phase::Geometry::DataStream::operator=(*(_QWORD *)(*a1 + 16 * v9), *(_QWORD *)(*a2 + 16 * v9));
      }
      ++v9;
    }
    while (v9 != v10);
  }
  return a1;
}

void sub_2165BE9A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::shared_ptr<Phase::Controller::Renderer>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::DataStream::operator=(uint64_t a1, uint64_t a2)
{
  std::align_val_t v4;
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  v4 = *(_QWORD *)(a2 + 16);
  v5 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 24) = v5;
  v6 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = v6;
  v7 = v6 * v5;
  Phase::Geometry::DataStream::Alloc(v4, v6 * v5, &v12);
  v8 = v12;
  v12 = 0;
  v9 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v8;
  if (v9)
  {
    MEMORY[0x2199F9D4C](v9, 0x1000C8077774924);
    v10 = v12;
    v12 = 0;
    if (v10)
      MEMORY[0x2199F9D4C](v10, 0x1000C8077774924);
  }
  if (v7)
    memcpy(*(void **)(a1 + 8), *(const void **)(a2 + 8), v7);
  return a1;
}

void Phase::Geometry::GenerateProjectedTriangleWeights(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, Phase::Logger *a7, int a8)
{
  uint64_t v15;
  Phase::Logger *v16;
  float *v17;
  float v18;
  unsigned int *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  __int128 v23;
  float v24;
  float v25;
  float32x2_t v26;
  float v27;
  float v28;
  float v29;
  uint64_t v30;
  __int128 v31;
  _BYTE *v32;
  _BYTE v33[12];
  Phase::Logger *v34;
  float v35;
  _BYTE v36[20];
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  if (a7)
  {
    v34 = a7;
    *(_QWORD *)v33 = 4;
    *(_QWORD *)&v31 = a2;
    *((_QWORD *)&v31 + 1) = &v34;
    v32 = v33;
    v30 = a2;
    Phase::details::AllocArray<float,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(float*)#1} const&>(a7, (uint64_t)&v31, &v30, v36);
    v15 = *(_QWORD *)v36;
    *(_QWORD *)v36 = 0;
    *a1 = v15;
    std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)(a1 + 1), (uint64_t)&v36[8]);
    a1[5] = a7;
    std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v36);
    v16 = 0;
    v17 = (float *)(a4 + 8);
    v18 = 0.0;
    v19 = (unsigned int *)(a6 + 8);
    do
    {
      v20 = a5 + 12 * *(v19 - 2);
      v21 = a5 + 12 * *(v19 - 1);
      v22 = (uint64_t *)(a5 + 12 * *v19);
      *(_DWORD *)v36 = *(_DWORD *)v20;
      *(_QWORD *)&v23 = *(_QWORD *)(v20 + 4);
      *((_QWORD *)&v23 + 1) = *(_QWORD *)v21;
      *(_OWORD *)&v36[4] = v23;
      v37 = *(_DWORD *)(v21 + 8);
      v38 = *v22;
      v39 = *((_DWORD *)v22 + 2);
      if (!a8
        || (v34 = (Phase::Logger *)*((_QWORD *)v17 - 1),
            v35 = *v17,
            Phase::operator*<float>((float *)a3, (float *)&v34, (float *)v33),
            Phase::operator*<float>((float *)a3, (float *)v36, (float *)&v31),
            v24 = *(float *)(a3 + 28),
            v25 = (float)(v24 * *(float *)&v31) + *(float *)(a3 + 16),
            v26 = vmul_f32(vadd_f32(vmul_n_f32(*(float32x2_t *)((char *)&v31 + 4), v24), *(float32x2_t *)(a3 + 20)), *(float32x2_t *)&v33[4]), (float)((float)((float)(v25 * *(float *)v33) + v26.f32[0]) + v26.f32[1]) <= 0.0))
      {
        Phase::Geometry::sProjectPointOntoSphere((float32x2_t *)&v31, (float *)v36, (float32x2_t *)a3);
        Phase::Geometry::sProjectPointOntoSphere((float32x2_t *)&v34, (float *)&v36[12], (float32x2_t *)a3);
        Phase::Geometry::sProjectPointOntoSphere((float32x2_t *)v33, (float *)&v38, (float32x2_t *)a3);
        v27 = (float)((float)(*((float *)&v34 + 1) - *((float *)&v31 + 1))
                    * (float)(*(float *)&v33[8] - *((float *)&v31 + 2)))
            - (float)((float)(v35 - *((float *)&v31 + 2)) * (float)(*(float *)&v33[4] - *((float *)&v31 + 1)));
        v28 = (float)((float)(v35 - *((float *)&v31 + 2)) * (float)(*(float *)v33 - *(float *)&v31))
            - (float)((float)(*(float *)&v34 - *(float *)&v31) * (float)(*(float *)&v33[8] - *((float *)&v31 + 2)));
        v29 = (float)((float)((float)(*(float *)&v34 - *(float *)&v31)
                            * (float)(*(float *)&v33[4] - *((float *)&v31 + 1)))
                    - (float)((float)(*((float *)&v34 + 1) - *((float *)&v31 + 1))
                            * (float)(*(float *)v33 - *(float *)&v31)))
            * 0.5;
        v18 = v18
            + sqrtf((float)(v29 * v29)+ (float)((float)((float)(v27 * 0.5) * (float)(v27 * 0.5))+ (float)((float)(v28 * 0.5) * (float)(v28 * 0.5))));
      }
      v19 += 3;
      *(float *)(*a1 + 4 * (_QWORD)v16) = v18;
      v16 = (Phase::Logger *)((char *)v16 + 1);
      v17 += 3;
    }
    while (a7 != v16);
  }
  else
  {
    *a1 = 0;
    a1[4] = 0;
    a1[5] = 0;
  }
}

void sub_2165BED14(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t *Phase::Geometry::GetTriangles(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t *v9;
  unsigned int v10;
  uint64_t v11;
  float v12;
  uint64_t v13;
  float *v14;
  float v15;
  float v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  int v22;
  uint64_t v23;
  float v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  float *v28;
  uint64_t *v29;
  float v30;
  unsigned int *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  int v38;
  float v40;
  size_t v41;
  char *v42;
  float v43;
  int v44;
  uint64_t v45;
  float v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  float v50;
  float v51;
  float v52;
  uint64_t v53;
  int v54;
  int v55;
  float v56;
  uint64_t v57;
  uint64_t **v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  float v71;
  _QWORD *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  float v76;
  BOOL v77;
  unsigned int *v78;
  unsigned int v79;
  unsigned int v80;
  uint64_t v81;
  uint64_t v82;
  __int128 v83;
  int v84;
  uint64_t v85;
  __int128 v86;
  int v87;
  uint64_t v88;
  float v89;
  uint64_t *v90;
  unint64_t v91;
  int v92;
  int v93;
  __int128 v94;
  __int128 v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  _BYTE v106[32];
  uint64_t v107;
  uint64_t v108;
  _QWORD v109[6];

  v101 = a2;
  v9 = result;
  v109[4] = *MEMORY[0x24BDAC8D0];
  if (a6 == 1)
  {
    if (!a5)
      goto LABEL_71;
    v10 = 0;
    v11 = 0;
    v12 = 0.0;
    do
    {
      v13 = *(_QWORD *)(a4 + 72 * v11 + 64);
      if (v13)
      {
        v14 = *(float **)(a4 + 72 * v11 + 8);
        do
        {
          v15 = *v14++;
          v16 = v15;
          if ((float)(v15 - v12) > 0.0)
            ++v10;
          v12 = v16;
          --v13;
        }
        while (v13);
      }
      else
      {
        v16 = v12;
      }
      ++v11;
      v12 = v16;
    }
    while (v11 != a5);
    if ((int)v10 >= 1)
    {
      v108 = *(_QWORD *)(v101 + 1024);
      Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&>((Phase::Logger *)&v105, 1, 1, (std::align_val_t)8uLL, &v108);
      v17 = (uint64_t *)(v101 + 1024);
      v18 = v105;
      v105 = 0;
      *v9 = v18;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)(v9 + 1), (uint64_t)v106);
      v9[5] = 1;
      std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v105);
      v19 = *v17;
      v103 = 4;
      v104 = v10;
      v102 = v19;
      Phase::details::AllocArray<Phase::Triangle<float>,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&>((Phase::Logger *)&v108, v10, &v104, (std::align_val_t *)&v103, &v102);
      v20 = v108;
      v108 = 0;
      v105 = v20;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v106, (uint64_t)v109);
      v107 = v10;
      std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v108);
      v21 = std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)*v9, &v105);
      v21[5] = v107;
      result = std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v105);
      v22 = 0;
      v23 = 0;
      v24 = 0.0;
      do
      {
        v25 = (_QWORD *)(a4 + 72 * v23);
        v26 = v25[8];
        if (v26)
        {
          v27 = 0;
          v28 = *(float **)(a4 + 72 * v23 + 8);
          v29 = (uint64_t *)*v9;
          do
          {
            v30 = v24;
            v24 = *v28;
            if ((float)(*v28 - v30) > 0.0)
            {
              v31 = (unsigned int *)(*v25 + v27);
              v32 = a3 + 12 * *v31;
              v33 = a3 + 12 * v31[1];
              v34 = (uint64_t *)(a3 + 12 * v31[2]);
              *(_QWORD *)&v35 = *(_QWORD *)v32;
              DWORD2(v35) = *(_DWORD *)(v32 + 8);
              HIDWORD(v35) = *(_DWORD *)v33;
              *(_QWORD *)&v36 = *(_QWORD *)(v33 + 4);
              v37 = *v34;
              v38 = *((_DWORD *)v34 + 2);
              result = (uint64_t *)(*v29 + 36 * v22++);
              *((_QWORD *)&v36 + 1) = v37;
              *(_OWORD *)result = v35;
              *((_OWORD *)result + 1) = v36;
              *((_DWORD *)result + 8) = v38;
            }
            v27 += 12;
            ++v28;
            --v26;
          }
          while (v26);
        }
        ++v23;
      }
      while (v23 != a5);
    }
    else
    {
LABEL_71:
      *result = 0;
      result[4] = 0;
      result[5] = 0;
    }
    return result;
  }
  v40 = *(float *)(a4 + 72 * a5 - 12);
  MEMORY[0x24BDAC7A8](result);
  v42 = (char *)&v98 - ((v41 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v42, v41);
  v43 = v40 / (float)a6;
  if (a5)
  {
    v44 = 0;
    v45 = 0;
    v46 = 0.0;
    do
    {
      v47 = *(_QWORD *)(a4 + 72 * v45 + 64);
      if (v47)
      {
        v48 = 0;
        v49 = *(_QWORD *)(a4 + 72 * v45 + 8);
        do
        {
          v50 = v46;
          v46 = *(float *)(v49 + 4 * v48);
          if ((float)(v46 - v50) > 0.0)
          {
            ++*(_DWORD *)&v42[4 * v44];
            if (v44 + 1 < a6)
            {
              v51 = v43 * (float)(v44 + 1);
              v52 = v43 * (float)(v44 + 2);
              if (v51 <= v46)
              {
                ++v44;
                v51 = v52;
              }
              if (v51 <= v46)
              {
                v53 = v44;
                v54 = v44 + 2;
                while (1)
                {
                  v55 = v53 + 1;
                  if (v53 + 1 >= a6)
                    break;
                  ++*(_DWORD *)&v42[4 * v53];
                  v56 = v43 * (float)v54++;
                  ++v53;
                  if (v56 > v46)
                    goto LABEL_35;
                }
                v55 = v53;
LABEL_35:
                v44 = v55;
              }
            }
          }
          ++v48;
        }
        while (v48 != v47);
      }
      ++v45;
    }
    while (v45 != a5);
  }
  v108 = *(_QWORD *)(v101 + 1024);
  Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&>((Phase::Logger *)&v105, a6, a6, (std::align_val_t)8uLL, &v108);
  v99 = a4;
  v100 = a5;
  v57 = v105;
  v105 = 0;
  *v9 = v57;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)(v9 + 1), (uint64_t)v106);
  v58 = (uint64_t **)v9;
  v9[5] = a6;
  std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v105);
  v59 = 0;
  v60 = 5;
  do
  {
    v61 = *(_QWORD *)(v101 + 1024);
    v62 = *(int *)&v42[4 * v59];
    v103 = 4;
    v104 = v62;
    v102 = v61;
    Phase::details::AllocArray<Phase::Triangle<float>,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&>((Phase::Logger *)&v108, v62, &v104, (std::align_val_t *)&v103, &v102);
    v63 = v108;
    v108 = 0;
    v105 = v63;
    std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v106, (uint64_t)v109);
    v107 = v62;
    std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v108);
    v64 = &(*v58)[v60];
    std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>>::operator=[abi:ne180100](v64 - 5, &v105);
    *v64 = v107;
    result = std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v105);
    ++v59;
    v60 += 6;
  }
  while (a6 != v59);
  v66 = v99;
  v65 = v100;
  if (v100)
  {
    v67 = 0;
    v68 = 0;
    v69 = 0;
    v70 = 0;
    v71 = 0.0;
    while (1)
    {
      v72 = (_QWORD *)(v66 + 72 * v70);
      v73 = v72[8];
      if (v73)
        break;
      v88 = v69;
LABEL_69:
      ++v70;
      v69 = v88;
      if (v70 == v65)
        return result;
    }
    v74 = 0;
    v75 = *(_QWORD *)(v66 + 72 * v70 + 8);
    result = *v58;
    while (1)
    {
      v76 = v71;
      v71 = *(float *)(v75 + 4 * v74);
      if ((float)(v71 - v76) > 0.0)
      {
        v77 = v68 == (_DWORD)v69;
        v78 = (unsigned int *)(*v72 + 12 * v74);
        v79 = v78[1];
        v80 = v78[2];
        v81 = a3 + 12 * *v78;
        v82 = a3 + 12 * v79;
        if (v77)
          v84 = v67;
        else
          v84 = 0;
        v85 = a3 + 12 * v80;
        *(_QWORD *)&v86 = *(_QWORD *)(v82 + 4);
        v87 = *(_DWORD *)(v85 + 8);
        v67 = v84 + 1;
        v88 = result[6 * (int)v69] + 36 * v84;
        *((_QWORD *)&v86 + 1) = *(_QWORD *)v85;
        HIDWORD(v83) = *(_DWORD *)v82;
        DWORD2(v83) = *(_DWORD *)(v81 + 8);
        *(_QWORD *)&v83 = *(_QWORD *)v81;
        *(_OWORD *)v88 = v83;
        *(_OWORD *)(v88 + 16) = v86;
        *(_DWORD *)(v88 + 32) = v87;
        LODWORD(v88) = v69 + 1;
        if ((int)v69 + 1 < a6)
        {
          v89 = v43 * (float)(int)v88;
          if (v89 <= v71)
            v88 = v88;
          else
            v88 = v69;
          if (v89 <= v71)
            v89 = v43 * (float)(v69 + 2);
          if (v89 <= v71)
          {
            v90 = &result[6 * (int)v88];
            v91 = (int)v88 + 1;
            while (1)
            {
              v92 = v88;
              if (v91 >= a6)
                break;
              if ((_DWORD)v88 == (_DWORD)v69)
                v93 = v67;
              else
                v93 = 0;
              *(_QWORD *)&v94 = *(_QWORD *)v81;
              DWORD2(v94) = *(_DWORD *)(v81 + 8);
              HIDWORD(v94) = *(_DWORD *)v82;
              *(_QWORD *)&v95 = *(_QWORD *)(v82 + 4);
              v96 = *(_DWORD *)(v85 + 8);
              v67 = v93 + 1;
              v97 = *v90;
              v90 += 6;
              *((_QWORD *)&v95 + 1) = *(_QWORD *)v85;
              v69 = v97 + 36 * v93;
              *(_OWORD *)v69 = v94;
              *(_OWORD *)(v69 + 16) = v95;
              *(_DWORD *)(v69 + 32) = v96;
              *(float *)&v94 = v43 * (float)(v88 + 2);
              v88 = (v88 + 1);
              ++v91;
              LODWORD(v69) = v92;
              if (*(float *)&v94 > v71)
              {
                v68 = v88 - 1;
                goto LABEL_58;
              }
            }
            v68 = v69;
          }
          else
          {
            v68 = v69;
          }
          goto LABEL_58;
        }
        v68 = v69;
      }
      v88 = v69;
LABEL_58:
      ++v74;
      v69 = v88;
      if (v74 == v73)
        goto LABEL_69;
    }
  }
  return result;
}

void sub_2165BF388(_Unwind_Exception *a1)
{
  uint64_t *v1;

  std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void Phase::Geometry::GeneratePoints(float **a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, int *a6, uint64_t a7)
{
  int *v7;
  float v13;
  unint64_t v14;
  uint64_t v15;
  void **v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  float v20;
  float v21;
  int v22;
  float v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  float v27;
  float v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float v32;
  uint64_t v33;
  uint64_t v34;
  float v35;
  float v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  float *v41;
  void **v42;
  uint64_t v43;
  void **v44;
  float *v45;
  unint64_t v46;
  int v47;
  float v48;
  _QWORD *v49;
  unint64_t v50;
  unint64_t v51;
  BOOL v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  float v56;
  float *v57;
  float v58;
  float v59;
  float v60;
  unint64_t v61;
  uint64_t v62;
  float32x2_t *v63;
  float32x2_t *v64;
  float32x2_t *v65;
  float v66;
  float v67;
  float32x2_t v68;
  float32x2_t v69;
  float32x2_t v70;
  float v71;
  unint64_t v72;
  unint64_t v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  _QWORD *v83;
  float **v89;
  uint64_t v90;
  float v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  void **v96;
  float **v97;
  unint64_t *v98;
  uint64_t *v99;
  uint64_t v100;
  unint64_t v101;
  float *v102;
  _QWORD v103[2];
  float **v104;
  uint64_t v105;
  uint64_t v106;
  _QWORD v107[3];
  _QWORD *v108;
  unint64_t v109;
  uint64_t v110;

  v7 = a6;
  v110 = *MEMORY[0x24BDAC8D0];
  v13 = *(float *)(a4 + 72 * a5 - 12);
  v14 = a6[1];
  if ((int)v14 > 0)
    goto LABEL_2;
  if (v13 < 0.0001)
    goto LABEL_9;
  if (v13 > 0.1)
  {
    v14 = *a6;
    goto LABEL_2;
  }
  v83 = v107;
  v107[0] = &off_24D579910;
  v108 = v107;
  __asm { FMOV            V0.2S, #1.0 }
  v106 = _D0;
  v102 = (float *)&unk_24D579958;
  v103[0] = Phase::CurveFunction::Squared<float>;
  v104 = &v102;
  std::__function::__value_func<float ()(float)>::swap[abi:ne180100](&v102, v107);
  v89 = v104;
  if (v104 == &v102)
  {
    v90 = 4;
    v89 = &v102;
    goto LABEL_78;
  }
  if (v104)
  {
    v90 = 5;
LABEL_78:
    (*(void (**)(void))&(*v89)[2 * v90])();
  }
  v91 = (float)*a6;
  LODWORD(v97) = 0;
  *((float *)&v97 + 1) = v91;
  Phase::Envelope<float>::Envelope((Phase::Logger *)&v102, (float *)&v97, (float *)&v106);
  v14 = vcvtas_u32_f32(Phase::Envelope<float>::operator()(&v102, (float)(0.1 - v13) / 0.0999));
  v97 = &v102;
  std::vector<Phase::Envelope<double>::Segment,std::allocator<Phase::Envelope<double>::Segment>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v97);
  if (v108 == v107)
  {
    v92 = 4;
    v7 = a6;
  }
  else
  {
    v7 = a6;
    if (!v108)
      goto LABEL_2;
    v92 = 5;
    v83 = v108;
  }
  (*(void (**)(_QWORD *))(*v83 + 8 * v92))(v83);
LABEL_2:
  if (v14 <= 1)
  {
LABEL_9:
    *a1 = 0;
    a1[4] = 0;
    a1[5] = 0;
    return;
  }
  v94 = a5;
  v15 = *((_QWORD *)v7 + 3);
  v16 = *(void ***)(a2 + 1024);
  v100 = 4;
  v101 = v14;
  v97 = (float **)v16;
  v98 = &v101;
  v99 = &v100;
  v96 = v16;
  Phase::details::AllocArray<float,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(float*)#1} const&>((Phase::Logger *)v14, (uint64_t)&v97, (uint64_t *)&v96, &v102);
  v17 = 0x7ABA4977B4617663;
  v18 = 0x5BC180D1366118D2;
  v19 = v102;
  v102 = 0;
  v106 = (uint64_t)v19;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v107, (uint64_t)v103);
  v109 = v14;
  std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v102);
  v93 = a4;
  if (*((_BYTE *)v7 + 8))
  {
    v20 = v13 / (float)(int)v14;
    v21 = 0.0;
    if (*((_BYTE *)v7 + 9) && (v22 = v7[3], v22 >= 1))
    {
      v23 = v20 / (float)v22;
      v24 = v7[4];
      if (v24 >= 1)
        v21 = v23 * (float)v24;
    }
    else
    {
      v23 = v13 / (float)(int)v14;
    }
    if ((int)v14 >= 1)
    {
      v25 = 0;
      v26 = v106;
      do
      {
        if (v15)
        {
          v27 = *(float *)(v15 + 24);
          v28 = *(float *)(v15 + 28) - v27;
          v30 = *(_QWORD *)v15;
          v29 = *(_QWORD *)(v15 + 8);
          *(_QWORD *)v15 = v29;
        }
        else
        {
          v27 = 0.0;
          v28 = 1.0;
          v29 = v17;
          v30 = v18;
          v18 = v17;
        }
        v31 = (v29 >> 26) ^ ((v30 ^ (unint64_t)(v30 << 23)) >> 17) ^ v29 ^ v30 ^ (v30 << 23);
        if (v15)
          *(_QWORD *)(v15 + 8) = v31;
        else
          v17 = v31;
        v32 = (float)(v21 + (float)(v20 * (float)(int)v25))
            + (float)(v23 * (float)(v27 + (float)(v28 * (float)((float)(v31 + v29) * 5.421e-20))));
        if (v32 >= (float)(v13 * 1.01))
          __assert_rtn("GeneratePoints", "GeoMeshUtility.cpp", 416, "value < totalMeshWeight * 1.01f");
        if (v32 >= v13)
          v32 = nextafterf(v13, v13 + -1.0);
        *(float *)(v26 + 4 * v25++) = v32;
      }
      while (v14 != v25);
    }
  }
  else
  {
    v33 = 0;
    v34 = v106;
    do
    {
      if (v15)
      {
        v35 = *(float *)(v15 + 24);
        v36 = *(float *)(v15 + 28) - v35;
        v38 = *(_QWORD *)v15;
        v37 = *(_QWORD *)(v15 + 8);
        *(_QWORD *)v15 = v37;
      }
      else
      {
        v35 = 0.0;
        v36 = 1.0;
        v37 = v17;
        v38 = v18;
        v18 = v17;
      }
      v39 = (v37 >> 26) ^ ((v38 ^ (unint64_t)(v38 << 23)) >> 17) ^ v37 ^ v38 ^ (v38 << 23);
      if (v15)
        *(_QWORD *)(v15 + 8) = v39;
      else
        v17 = v39;
      *(float *)(v34 + 4 * v33++) = v13 * (float)(v35 + (float)(v36 * (float)((float)(v39 + v37) * 5.421e-20)));
    }
    while (v14 != v33);
    std::__sort<std::__less<float,float> &,float *>();
  }
  if (a7)
  {
    if (*((_BYTE *)v7 + 8))
      v40 = v14;
    else
      v40 = 1;
    Phase::Geometry::GetTriangles((uint64_t *)&v102, a2, a3, v93, v94, v40);
    v41 = v102;
    v102 = 0;
    v42 = *(void ***)a7;
    *(_QWORD *)a7 = v41;
    if (v42)
    {
      v97 = (float **)v42;
      v43 = *(_QWORD *)(a7 + 32);
      if (!v43)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, float ***))(*(_QWORD *)v43 + 48))(v43, &v97);
    }
    std::__function::__value_func<double ()(double)>::operator=[abi:ne180100]((_QWORD *)(a7 + 8), (uint64_t)v103);
    *(_QWORD *)(a7 + 40) = v105;
    std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v102);
  }
  v44 = *(void ***)(a2 + 1024);
  v100 = 4;
  v101 = v14;
  v97 = (float **)v44;
  v98 = &v101;
  v99 = &v100;
  v96 = v44;
  Phase::details::AllocArray<Phase::Vector<float,3ul>,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Vector<float,3ul>*)#1} const&>((Phase::Logger *)v14, (uint64_t)&v97, (uint64_t *)&v96, (size_t *)&v102);
  v45 = v102;
  v102 = 0;
  *a1 = v45;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)(a1 + 1), (uint64_t)v103);
  a1[5] = (float *)v14;
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v102);
  if (v94)
  {
    v46 = 0;
    v47 = 0;
    v48 = 0.0;
    do
    {
      v49 = (_QWORD *)(v93 + 72 * v46);
      v50 = v49[8];
      v51 = v47;
      if (v50)
        v52 = v14 > v47;
      else
        v52 = 0;
      if (v52)
      {
        v53 = 0;
        v54 = *(_QWORD *)(v93 + 72 * v46 + 8);
        v55 = v106;
        v56 = v48;
        do
        {
          v48 = *(float *)(v54 + 4 * v53);
          v51 = v47;
          if (v14 > v47)
          {
            v57 = &(*a1)[3 * v47 + 2];
            while (1)
            {
              v58 = *(float *)(v55 + 4 * v51);
              if (v58 >= *(float *)(v54 + 4 * v53))
                break;
              if (v15)
              {
                v59 = *(float *)(v15 + 24);
                v60 = *(float *)(v15 + 28) - v59;
                v62 = *(_QWORD *)v15;
                v61 = *(_QWORD *)(v15 + 8);
              }
              else
              {
                v60 = 1.0;
                v59 = 0.0;
                v62 = v18;
                v61 = v17;
              }
              v63 = (float32x2_t *)(a3 + 12 * *(unsigned int *)(*v49 + 12 * v53));
              v64 = (float32x2_t *)(a3 + 12 * *(unsigned int *)(*v49 + 4 * (3 * v53 + 1)));
              v65 = (float32x2_t *)(a3 + 12 * *(unsigned int *)(*v49 + 4 * (3 * v53 + 2)));
              v66 = v63[1].f32[0];
              v67 = v64[1].f32[0];
              v68 = *v63;
              v69 = *v64;
              v70 = *v65;
              v71 = v65[1].f32[0];
              v72 = ((v62 ^ (unint64_t)(v62 << 23)) >> 17) ^ (v61 >> 26) ^ v62 ^ (v62 << 23) ^ v61;
              if (v15)
                *(_QWORD *)v15 = v72;
              else
                v18 = v72;
              v73 = ((v61 ^ (v61 << 23)) >> 17) ^ (v72 >> 26) ^ v61 ^ (v61 << 23) ^ v72;
              if (v15)
                *(_QWORD *)(v15 + 8) = v73;
              else
                v17 = ((v61 ^ (v61 << 23)) >> 17) ^ (v72 >> 26) ^ v61 ^ (v61 << 23) ^ v72;
              v74 = (float)((float)(v58 - v56) / (float)(v48 - v56)) * 1000.0;
              v75 = floorf(v74);
              v76 = floorf((float)(v74 - v75) * 1000.0);
              v77 = v75 + (float)(v59 + (float)(v60 * (float)((float)(v72 + v61) * 5.421e-20)));
              v78 = (float)(v76 + (float)(v59 + (float)(v60 * (float)((float)(v73 + v72) * 5.421e-20)))) / 1000.0;
              v79 = sqrtf(v77 / 1000.0);
              v80 = v79 * (float)(1.0 - v78);
              v81 = v79 * v78;
              ++v51;
              *((float32x2_t *)v57 - 1) = vadd_f32(vmul_n_f32(v70, v81), vadd_f32(vmul_n_f32(v68, 1.0 - v79), vmul_n_f32(v69, v80)));
              *v57 = (float)(v71 * v81) + (float)((float)(v66 * (float)(1.0 - v79)) + (float)(v67 * v80));
              v57 += 3;
              if (v14 == v51)
              {
                LODWORD(v51) = v14;
                break;
              }
            }
            v47 = v51;
            v51 = (int)v51;
          }
          if (++v53 >= v50)
            break;
          v56 = v48;
        }
        while (v14 > v51);
      }
      ++v46;
    }
    while (v46 < v94 && v14 > v51);
  }
  else
  {
    v51 = 0;
  }
  if (v14 != v51)
    __assert_rtn("GeneratePoints", "GeoMeshUtility.cpp", 470, "pointIndex == pointCount");
  std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v106);
}

void sub_2165BFB48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,_QWORD *a31)
{
  _QWORD *v31;
  uint64_t v33;

  std::vector<Phase::Envelope<double>::Segment,std::allocator<Phase::Envelope<double>::Segment>>::__destroy_vector::operator()[abi:ne180100](&a16);
  if (a31 == v31)
  {
    v33 = 4;
  }
  else
  {
    if (!a31)
      goto LABEL_6;
    v33 = 5;
    v31 = a31;
  }
  (*(void (**)(_QWORD *))(*v31 + 8 * v33))(v31);
LABEL_6:
  _Unwind_Resume(a1);
}

uint64_t *Phase::Geometry::CreatePointCloudLoD@<X0>(uint64_t *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>, int32x4_t a7@<Q3>)
{
  _QWORD *v9;
  uint64_t v10;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  unsigned int v22;
  __int32 v23;
  int32x2_t v24;
  int32x4_t v25;
  int32x4_t v26;
  uint64_t v27;
  uint64_t v28;
  size_t v29;
  size_t v30;
  uint64_t (***v31)();
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35[5];
  uint64_t v36;
  uint64_t (**v37)();
  uint64_t v38[2];
  uint64_t (***v39)();
  __int128 v40;
  __int128 v41;
  _OWORD v42[2];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  _BYTE v51[24];
  __int128 v52;
  uint64_t v53;
  unsigned __int32 v54;
  __int32 v55;
  int v56;
  int32x4_t v57;
  int v58;
  unint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  if (!*(_BYTE *)(a4 + 20))
    __assert_rtn("CreatePointCloudLoD", "GeoMeshUtility.cpp", 551, "true == inOptions.mProjectIntoListenerSpace");
  v9 = *(_QWORD **)(**(_QWORD **)(a2 + 48) + 16 * *(_QWORD *)(a2 + 56));
  v10 = v9[3];
  if (!v10)
    goto LABEL_9;
  v14 = (uint64_t)result;
  v15 = 0;
  v16 = v9[1];
  v17 = v9[4];
  v18 = (_QWORD *)(v16 + 40);
  v19 = v10;
  do
  {
    v15 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)*(v18 - 1) + 16 * *v18) + 24) / 3uLL;
    v18 = (_QWORD *)((char *)v18 + v17);
    --v19;
  }
  while (v19);
  if (!v15)
  {
LABEL_9:
    *(_QWORD *)a6 = 0;
    *(_QWORD *)(a6 + 32) = 0;
    *(_QWORD *)(a6 + 40) = 0;
    return result;
  }
  if (v15 < 0x2711)
  {
    v27 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 16) + 16 * *(_QWORD *)(a2 + 24)) + 8);
    v28 = result[128];
    v29 = 72 * v10;
    if (72 * v10)
      v29 = (size_t)operator new(v29, (std::align_val_t)8uLL);
    v30 = v29;
    do
    {
      *(_QWORD *)v30 = 0;
      *(_QWORD *)(v30 + 8) = 0;
      *(_OWORD *)(v30 + 40) = 0uLL;
      *(_OWORD *)(v30 + 56) = 0uLL;
      v30 += 72;
    }
    while (v30 != v29 + 72 * v10);
    v37 = &off_24D57D1F0;
    v38[0] = v10;
    v38[1] = v28;
    v39 = &v37;
    v50 = v29;
    std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v51, (uint64_t)&v37);
    v31 = v39;
    if (v39 == &v37)
    {
      v32 = 4;
      v31 = &v37;
    }
    else
    {
      if (!v39)
        goto LABEL_19;
      v32 = 5;
    }
    (*v31)[v32]();
LABEL_19:
    v33 = v50;
    v50 = 0;
    *(_QWORD *)&v42[0] = v33;
    std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v42 + 8, (uint64_t)v51);
    *((_QWORD *)&v43 + 1) = v10;
    v34 = std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v50);
    v50 = v10;
    *(_QWORD *)v51 = v42;
    *(_QWORD *)&v51[8] = v27;
    *(_QWORD *)&v51[16] = a2;
    *(_QWORD *)&v52 = v14;
    *((_QWORD *)&v52 + 1) = a3;
    if (Phase::Geometry::CreatePointCloudLoD(Phase::Geometry::SystemState &,Phase::Geometry::Mesh const&,Phase::Affine<float> const&,Phase::Affine<float> const&,Phase::Geometry::PointCloudOptions const&,Phase::Geometry::PointCloudDebugOutput)::$_0::operator()((unint64_t *)v34, *(unsigned __int8 *)(a4 + 21)) > 0.0|| *(_BYTE *)(a4 + 21)&& Phase::Geometry::CreatePointCloudLoD(Phase::Geometry::SystemState &,Phase::Geometry::Mesh const&,Phase::Affine<float> const&,Phase::Affine<float> const&,Phase::Geometry::PointCloudOptions const&,Phase::Geometry::PointCloudDebugOutput)::$_0::operator()((unint64_t *)&v50, 0) > 0.0)
    {
      Phase::Geometry::GeneratePoints((float **)a6, v14, v27, *(uint64_t *)&v42[0], *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 48) + 16 * *(_QWORD *)(a2 + 56)) + 24), (int *)a4, a5);
    }
    else
    {
      *(_QWORD *)a6 = 0;
      *(_QWORD *)(a6 + 32) = 0;
      *(_QWORD *)(a6 + 40) = 0;
    }
    return std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v42);
  }
  v20 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)&v21 = *(_QWORD *)(v20 + 24);
  v50 = v21;
  v22 = *(_DWORD *)(v20 + 32);
  v23 = *(_DWORD *)(v20 + 36);
  a7.i64[0] = *(_QWORD *)(v20 + 40);
  v24 = vzip1_s32(*(int32x2_t *)&v21, *(int32x2_t *)a7.i8);
  v53 = v21;
  v56 = DWORD1(v21);
  v58 = v21;
  LODWORD(v21) = v23;
  *((_QWORD *)&v21 + 1) = __PAIR64__(v23, v22);
  v55 = v23;
  *(_OWORD *)&v51[4] = v21;
  *(int32x2_t *)((char *)&v52 + 4) = v24;
  *(_DWORD *)&v51[20] = a7.i32[0];
  LODWORD(v52) = v22;
  HIDWORD(v52) = v22;
  v54 = a7.u32[1];
  v25 = vuzp2q_s32(a7, vzip1q_s32(a7, a7));
  v26 = v25;
  v26.i32[1] = v23;
  v26.i32[3] = v25.i32[0];
  *(_DWORD *)v51 = v22;
  v57 = v26;
  v59 = a7.i64[0];
  v46 = unk_2166F83A8;
  v47 = xmmword_2166F83B8;
  v48 = unk_2166F83C8;
  v49 = xmmword_2166F83D8;
  v42[1] = unk_2166F8368;
  v43 = xmmword_2166F8378;
  v44 = unk_2166F8388;
  v45 = xmmword_2166F8398;
  v37 = 0;
  v38[0] = 0;
  v40 = 0u;
  v41 = 0u;
  v42[0] = xmmword_2166F8358;
  Phase::Geometry::GenerateProjectedTriangleWeights(v35, result[128], a3, (uint64_t)&unk_2166F83E8, (uint64_t)&v50, (uint64_t)v42, (Phase::Logger *)0xC, *(unsigned __int8 *)(a4 + 21));
  std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100](v38, v35);
  *((_QWORD *)&v40 + 1) = v36;
  std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](v35);
  if (*((_QWORD *)&v40 + 1))
    goto LABEL_8;
  if (!*(_BYTE *)(a4 + 21))
    goto LABEL_26;
  if (!*(_BYTE *)(a4 + 20))
    __assert_rtn("GenerateTriangleWeights", "GeoMeshUtility.cpp", 164, "false");
  Phase::Geometry::GenerateProjectedTriangleWeights(v35, *(_QWORD *)(v14 + 1024), a3, (uint64_t)&unk_2166F83E8, (uint64_t)&v50, (uint64_t)v42, (Phase::Logger *)0xC, 0);
  std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100](v38, v35);
  *((_QWORD *)&v40 + 1) = v36;
  std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](v35);
  if (*((_QWORD *)&v40 + 1))
  {
LABEL_8:
    v37 = (uint64_t (**)())v42;
    LODWORD(v41) = 0;
    DWORD1(v41) = *(_DWORD *)(v38[0] + 44);
    *((_QWORD *)&v41 + 1) = 12;
    Phase::Geometry::GeneratePoints((float **)a6, v14, (uint64_t)&v50, (uint64_t)&v37, 1uLL, (int *)a4, a5);
  }
  else
  {
LABEL_26:
    *(_QWORD *)a6 = 0;
    *(_QWORD *)(a6 + 32) = 0;
    *(_QWORD *)(a6 + 40) = 0;
  }
  return std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](v38);
}

void sub_2165C0034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

float Phase::Geometry::CreatePointCloudLoD(Phase::Geometry::SystemState &,Phase::Geometry::Mesh const&,Phase::Affine<float> const&,Phase::Affine<float> const&,Phase::Geometry::PointCloudOptions const&,Phase::Geometry::PointCloudDebugOutput)::$_0::operator()(unint64_t *a1, int a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  float v16;
  uint64_t v18[7];

  v18[6] = *MEMORY[0x24BDAC8D0];
  if (!*a1)
    return 0.0;
  v4 = 0;
  v5 = 0;
  v6 = (uint64_t *)a1[1];
  v7 = *v6;
  v8 = 0.0;
  do
  {
    v9 = *(_QWORD *)(**(_QWORD **)(a1[3] + 48) + 16 * *(_QWORD *)(a1[3] + 56));
    v10 = *(_QWORD *)(v9 + 32) * v5;
    v11 = *(_QWORD *)(**(_QWORD **)(*(_QWORD *)(v9 + 8) + v10 + 32) + 16 * *(_QWORD *)(*(_QWORD *)(v9 + 8) + v10 + 40));
    *(_QWORD *)(v7 + v4) = *(_QWORD *)(v11 + 8);
    v12 = *(_QWORD *)(v11 + 24) / 3uLL;
    v13 = (uint64_t *)(*v6 + v4);
    v13[8] = v12;
    Phase::Geometry::GenerateProjectedTriangleWeights(v18, *(_QWORD *)(a1[4] + 1024), a1[5], *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(*(_QWORD *)(v9 + 8) + v10 + 48)+ 16 * *(_QWORD *)(*(_QWORD *)(v9 + 8) + v10 + 56))+ 8), a1[2], *v13, (Phase::Logger *)v12, a2);
    std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100](v13 + 1, v18);
    v13[6] = v18[5];
    std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](v18);
    v6 = (uint64_t *)a1[1];
    v7 = *v6;
    v14 = *v6 + v4;
    *(float *)(v14 + 56) = v8;
    v15 = v13[6];
    if (v15)
      v16 = *(float *)(v13[1] + 4 * v15 - 4);
    else
      v16 = 0.0;
    v8 = v8 + v16;
    *(float *)(v14 + 60) = v8;
    ++v5;
    v4 += 72;
  }
  while (v5 < *a1);
  return v8;
}

void Phase::Geometry::sProjectPointOntoSphere(float32x2_t *a1, float *a2, float32x2_t *a3)
{
  float v5;
  float v6;
  float32x2_t v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float32x2_t v12;
  float32x2_t v13;
  float v14;

  Phase::operator*<float>((float *)a3, a2, (float *)&v13);
  v5 = a3[3].f32[1];
  v6 = v5 * v14;
  v7 = vadd_f32(vmul_n_f32(v13, v5), a3[2]);
  v8 = v6 + a3[3].f32[0];
  if (v7.f32[0] < 0.0)
    v9 = -v7.f32[0];
  else
    v9 = v7.f32[0];
  if (v9 > 0.0001)
    goto LABEL_11;
  v10 = v7.f32[1];
  if (v7.f32[1] < 0.0)
    v10 = -v7.f32[1];
  if (v10 > 0.0001)
    goto LABEL_11;
  v11 = -v8;
  if (v8 >= 0.0)
    v11 = v8;
  if (v11 > 0.0001)
  {
LABEL_11:
    v12 = vmul_f32(v7, v7);
    v12.f32[0] = sqrtf(vaddv_f32(v12) + (float)(v8 * v8));
    v7 = vdiv_f32(v7, (float32x2_t)vdup_lane_s32((int32x2_t)v12, 0));
    v8 = v8 / v12.f32[0];
  }
  *a1 = v7;
  a1[1].f32[0] = v8;
}

uint64_t *std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v7;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v7 = v2;
    v3 = a1[4];
    if (!v3)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v7);
  }
  v4 = (uint64_t *)a1[4];
  if (v4 == a1 + 1)
  {
    v5 = 4;
    v4 = a1 + 1;
    goto LABEL_8;
  }
  if (v4)
  {
    v5 = 5;
LABEL_8:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  return a1;
}

uint64_t *std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v7;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v7 = v2;
    v3 = a1[4];
    if (!v3)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v7);
  }
  v4 = (uint64_t *)a1[4];
  if (v4 == a1 + 1)
  {
    v5 = 4;
    v4 = a1 + 1;
    goto LABEL_8;
  }
  if (v4)
  {
    v5 = 5;
LABEL_8:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  return a1;
}

_QWORD *Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&>(Phase::Logger *a1, uint64_t a2, uint64_t a3, std::align_val_t a4, uint64_t *a5)
{
  uint64_t v8;
  _QWORD *v9;
  NSObject *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *result;
  uint64_t v14;
  _BYTE v15[32];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v8 = 48 * a3;
  if (!(48 * a3))
  {
LABEL_8:
    v9 = 0;
    goto LABEL_9;
  }
  if (!a4)
  {
    v9 = operator new(48 * a3);
    goto LABEL_9;
  }
  if ((a4 & (a4 - 1)) != 0)
  {
    v10 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 176);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v15 = 136315650;
      *(_QWORD *)&v15[4] = "SystemAllocator.hpp";
      *(_WORD *)&v15[12] = 1024;
      *(_DWORD *)&v15[14] = 47;
      *(_WORD *)&v15[18] = 2048;
      *(_QWORD *)&v15[20] = v8;
      _os_log_impl(&dword_2164CC000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d Error allocating memory - alignment must be power of two. Alignment requested %zu", v15, 0x1Cu);
    }
    goto LABEL_8;
  }
  v9 = operator new(48 * a3, a4);
LABEL_9:
  v11 = v9;
  do
  {
    *v11 = 0;
    v11[4] = 0;
    v11[5] = 0;
    v11 += 6;
  }
  while (v11 != &v9[6 * a2]);
  v12 = *a5;
  *(_QWORD *)v15 = &off_24D57D160;
  *(_QWORD *)&v15[8] = a2;
  *(_QWORD *)&v15[16] = v12;
  *(_QWORD *)&v15[24] = v15;
  *(_QWORD *)a1 = v9;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)a1 + 8, (uint64_t)v15);
  result = *(_QWORD **)&v15[24];
  if (*(_BYTE **)&v15[24] == v15)
  {
    v14 = 4;
    result = v15;
  }
  else
  {
    if (!*(_QWORD *)&v15[24])
      return result;
    v14 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v14))();
}

void std::__function::__func<std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

__n128 std::__function::__func<std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24D57D160;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24D57D160;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::ManagedArray<Phase::Triangle<float>>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::ManagedArray<Phase::Triangle<float>>*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, void **a2)
{
  void *v2;
  unint64_t v4;
  uint64_t *v5;

  v2 = *a2;
  if (*(_QWORD *)(a1 + 8))
  {
    v4 = 0;
    v5 = (uint64_t *)*a2;
    do
    {
      ++v4;
      v5 = std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](v5) + 6;
    }
    while (v4 < *(_QWORD *)(a1 + 8));
  }
  operator delete(v2);
}

_QWORD *Phase::details::AllocArray<Phase::Triangle<float>,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&>(Phase::Logger *a1, uint64_t a2, _QWORD *a3, std::align_val_t *a4, uint64_t *a5)
{
  uint64_t v8;
  std::align_val_t v9;
  void *v10;
  NSObject *v11;
  uint64_t v12;
  _QWORD *result;
  uint64_t v14;
  NSObject *v15;
  std::logic_error *exception;
  _BYTE v17[18];
  __int16 v18;
  _DWORD v19[7];

  *(_QWORD *)&v19[5] = *MEMORY[0x24BDAC8D0];
  if (!a2)
  {
    v15 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 112);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v17 = 136315394;
      *(_QWORD *)&v17[4] = "ManagedPtr.hpp";
      *(_WORD *)&v17[12] = 1024;
      *(_DWORD *)&v17[14] = 229;
      _os_log_impl(&dword_2164CC000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [inCount == 0 is true]: \"Attempting to allocate an array of 0 elements\"", v17, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempting to allocate an array of 0 elements");
  }
  v8 = 36 * *a3;
  if (v8)
  {
    v9 = *a4;
    if (!*a4)
    {
      v10 = operator new(36 * *a3);
      goto LABEL_7;
    }
    if ((v9 & (v9 - 1)) == 0)
    {
      v10 = operator new(36 * *a3, v9);
LABEL_7:
      v8 = (uint64_t)v10;
      goto LABEL_11;
    }
    v11 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 176);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v17 = 136315650;
      *(_QWORD *)&v17[4] = "SystemAllocator.hpp";
      *(_WORD *)&v17[12] = 1024;
      *(_DWORD *)&v17[14] = 47;
      v18 = 2048;
      *(_QWORD *)v19 = v8;
      _os_log_impl(&dword_2164CC000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d Error allocating memory - alignment must be power of two. Alignment requested %zu", v17, 0x1Cu);
    }
    v8 = 0;
  }
LABEL_11:
  bzero((void *)v8, 36 * ((36 * a2 - 36) / 0x24uLL) + 36);
  v12 = *a5;
  *(_QWORD *)v17 = &off_24D57D1A8;
  *(_QWORD *)&v17[8] = v12;
  *(_QWORD *)&v19[1] = v17;
  *(_QWORD *)a1 = v8;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)a1 + 8, (uint64_t)v17);
  result = *(_QWORD **)&v19[1];
  if (*(_BYTE **)&v19[1] == v17)
  {
    v14 = 4;
    result = v17;
  }
  else
  {
    if (!*(_QWORD *)&v19[1])
      return result;
    v14 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v14))();
}

void sub_2165C0874(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void std::__function::__func<std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D57D1A8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D57D1A8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Triangle<float>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Triangle<float>*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, void **a2)
{
  operator delete(*a2);
}

uint64_t *std::unique_ptr<Phase::Triangle<float> [],std::function<void ()(void *)>>::operator=[abi:ne180100](uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;

  v4 = *a2;
  *a2 = 0;
  v5 = *a1;
  *a1 = v4;
  if (v5)
  {
    v8 = v5;
    v6 = a1[4];
    if (!v6)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v6 + 48))(v6, &v8);
  }
  std::__function::__value_func<double ()(double)>::operator=[abi:ne180100](a1 + 1, (uint64_t)(a2 + 1));
  return a1;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Geometry::SubmeshInfo*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Geometry::SubmeshInfo*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Geometry::SubmeshInfo*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Geometry::SubmeshInfo*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

__n128 std::__function::__func<std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Geometry::SubmeshInfo*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Geometry::SubmeshInfo*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Geometry::SubmeshInfo*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Geometry::SubmeshInfo*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24D57D1F0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Geometry::SubmeshInfo*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Geometry::SubmeshInfo*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Geometry::SubmeshInfo*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Geometry::SubmeshInfo*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24D57D1F0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Geometry::SubmeshInfo*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Geometry::SubmeshInfo*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Geometry::SubmeshInfo*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::Geometry::SubmeshInfo [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::SubmeshInfo,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Geometry::SubmeshInfo*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, void **a2)
{
  uint64_t *v2;
  unint64_t v4;
  uint64_t *v5;

  v2 = (uint64_t *)*a2;
  if (*(_QWORD *)(a1 + 8))
  {
    v4 = 0;
    v5 = v2 + 1;
    do
    {
      ++v4;
      v5 = std::unique_ptr<float [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](v5) + 9;
    }
    while (v4 < *(_QWORD *)(a1 + 8));
  }
  operator delete(v2);
}

void Phase::Geometry::MpsCpuSceneBuilder::~MpsCpuSceneBuilder(Phase::Geometry::MpsCpuSceneBuilder *this)
{
  void *v2;
  void *v3;
  void **v4;

  Phase::Geometry::MpsCpuSceneBuilder::TearDown(this);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)this + 128);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)this + 104);
  v4 = (void **)((char *)this + 72);
  std::vector<Phase::Geometry::MpsCpuSceneBuilder::BuildEntry>::__destroy_vector::operator()[abi:ne180100](&v4);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)this + 56);
  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 1);
  if (v3)
  {
    *((_QWORD *)this + 2) = v3;
    operator delete(v3);
  }
}

void Phase::Geometry::MpsCpuSceneBuilder::TearDown(Phase::Geometry::MpsCpuSceneBuilder *this)
{
  Phase::Geometry::MpsCpuSceneBuilder::WaitForCurrentBuild(this);
  Phase::Geometry::MpsCpuSceneBuilder::ResetBuildTask(this);
  std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)this + 13);
  *((_DWORD *)this + 30) = 0;
  std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)this + 16);
  *((_DWORD *)this + 36) = 0;
  *((_QWORD *)this + 2) = *((_QWORD *)this + 1);
  *((_QWORD *)this + 5) = *((_QWORD *)this + 4);
}

void Phase::Geometry::MpsCpuSceneBuilder::Update(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;

  Phase::Geometry::MpsCpuSceneBuilder::CheckForChanges(a1, a2);
  Phase::Geometry::MpsCpuSceneBuilder::UpdateActiveGroupList(a1, a2);
  Phase::Geometry::MpsCpuSceneBuilder::RemoveInactiveScenes(a1, a3);
  v10 = *(_QWORD *)(a1 + 56);
  Phase::Geometry::MpsCpuSceneBuilder::ProcessFinishedBuild((unsigned __int8 *)a1, (uint64_t)a3);
  if (*(_QWORD *)(a1 + 56))
  {
    Phase::Geometry::MpsCpuSceneBuilder::UpdateWaitList((_QWORD *)a1, a2);
  }
  else if (Phase::Geometry::MpsCpuSceneBuilder::StartNewBuild((unsigned __int8 *)a1, a2))
  {
    Phase::Geometry::MpsCpuSceneBuilder::SaveSceneShapes(a1, v10 != 0, a4, a5);
  }
  else if (v10)
  {
    std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)(a1 + 104));
    *(_DWORD *)(a1 + 120) = 0;
    std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)(a1 + 128));
    *(_DWORD *)(a1 + 144) = 0;
  }
  if (!*(_QWORD *)(a1 + 56))
    *(_QWORD *)(a1 + 152) = *(_QWORD *)(*(_QWORD *)a1 + 2424);
}

uint64_t Phase::Geometry::MpsCpuSceneBuilder::CheckForChanges(uint64_t result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  char v8;

  v2 = *a2;
  v3 = a2[1];
  if (*a2 != v3)
  {
    v4 = result;
    do
    {
      if (!*(_BYTE *)(v2 + 40))
      {
        v5 = *(_QWORD **)(v4 + 8);
        v6 = *(_QWORD **)(v4 + 16);
        if (v5 == v6)
          goto LABEL_14;
        v7 = *(_QWORD **)(v4 + 8);
        while (1)
        {
          result = std::__equal_aligned[abi:ne180100]<std::__bitset<1ul,32ul>,true,true>(v5, 0, (uint64_t)v5, 0x20u, (_QWORD *)(v2 + 24));
          v8 = *((unsigned __int8 *)v7 + 8) == *(unsigned __int8 *)(v2 + 32) ? result : 0;
          if ((v8 & 1) != 0)
            break;
          v7 += 3;
          v5 += 3;
          if (v7 == v6)
          {
            v7 = v6;
            break;
          }
        }
        if (*(_QWORD **)(v4 + 16) == v7
          || 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(_QWORD *)(v2 + 8) - *(_QWORD *)v2) >> 3) != v7[2])
        {
LABEL_14:
          *(_BYTE *)(v2 + 40) = 1;
        }
      }
      v2 += 48;
    }
    while (v2 != v3);
  }
  return result;
}

void Phase::Geometry::MpsCpuSceneBuilder::UpdateActiveGroupList(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  size_t v24;
  char *v25;
  __int128 v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v4 = *a2;
  v5 = a2[1];
  if (*a2 == v5)
  {
    v12 = *a2;
  }
  else
  {
    do
    {
      v6 = *(_QWORD **)(a1 + 8);
      v7 = *(_QWORD **)(a1 + 16);
      if (v6 == v7)
      {
LABEL_9:
        v11 = 0;
      }
      else
      {
        v8 = *(_QWORD *)(a1 + 8);
        while (1)
        {
          v9 = std::__equal_aligned[abi:ne180100]<std::__bitset<1ul,32ul>,true,true>(v6, 0, (uint64_t)v6, 0x20u, (_QWORD *)(v4 + 24));
          v10 = *(unsigned __int8 *)(v8 + 8) == *(unsigned __int8 *)(v4 + 32) ? v9 : 0;
          if (v10 == 1)
            break;
          v8 += 24;
          v6 += 3;
          if ((_QWORD *)v8 == v7)
            goto LABEL_9;
        }
        v11 = *(_QWORD *)(v8 + 16);
      }
      if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(_QWORD *)(v4 + 8) - *(_QWORD *)v4) >> 3) != v11)
        *(_BYTE *)(v4 + 40) = 1;
      v4 += 48;
    }
    while (v4 != v5);
    v4 = *a2;
    v12 = a2[1];
  }
  v13 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v4) >> 4);
  v15 = *(char **)(a1 + 8);
  v14 = *(char **)(a1 + 16);
  v16 = 0xAAAAAAAAAAAAAAABLL * ((v14 - v15) >> 3);
  v17 = v13 - v16;
  if (v13 <= v16)
  {
    if (v13 >= v16)
      goto LABEL_33;
    v27 = &v15[24 * v13];
    goto LABEL_32;
  }
  v18 = *(_QWORD *)(a1 + 24);
  if (0xAAAAAAAAAAAAAAABLL * ((v18 - (uint64_t)v14) >> 3) >= v17)
  {
    bzero(*(void **)(a1 + 16), 24 * ((24 * v17 - 24) / 0x18) + 24);
    v27 = &v14[24 * ((24 * v17 - 24) / 0x18) + 24];
LABEL_32:
    *(_QWORD *)(a1 + 16) = v27;
    goto LABEL_33;
  }
  if (v13 > 0xAAAAAAAAAAAAAAALL)
    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
  v19 = 0xAAAAAAAAAAAAAAABLL * ((v18 - (uint64_t)v15) >> 3);
  if (2 * v19 > v13)
    v13 = 2 * v19;
  if (v19 >= 0x555555555555555)
    v13 = 0xAAAAAAAAAAAAAAALL;
  if (v13 > 0xAAAAAAAAAAAAAAALL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v20 = 3 * v13;
  v21 = (char *)operator new(24 * v13);
  v22 = &v21[8 * ((v14 - v15) >> 3)];
  v23 = &v21[8 * v20];
  v24 = 24 * ((24 * v17 - 24) / 0x18) + 24;
  bzero(v22, v24);
  v25 = &v22[v24];
  if (v14 != v15)
  {
    do
    {
      v26 = *(_OWORD *)(v14 - 24);
      *((_QWORD *)v22 - 1) = *((_QWORD *)v14 - 1);
      *(_OWORD *)(v22 - 24) = v26;
      v22 -= 24;
      v14 -= 24;
    }
    while (v14 != v15);
    v14 = v15;
  }
  *(_QWORD *)(a1 + 8) = v22;
  *(_QWORD *)(a1 + 16) = v25;
  *(_QWORD *)(a1 + 24) = v23;
  if (v14)
    operator delete(v14);
LABEL_33:
  v28 = *a2;
  if (a2[1] != *a2)
  {
    v29 = 0;
    v30 = 0;
    v31 = 0;
    do
    {
      v32 = *(_QWORD *)(a1 + 8) + v30;
      v33 = v28 + v29;
      v34 = *(_QWORD *)(v33 + 24);
      *(_BYTE *)(v32 + 8) = *(_BYTE *)(v33 + 32);
      *(_QWORD *)v32 = v34;
      *(_QWORD *)(v32 + 16) = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(_QWORD *)(v33 + 8) - *(_QWORD *)v33) >> 3);
      ++v31;
      v28 = *a2;
      v30 += 24;
      v29 += 48;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 4) > v31);
  }
}

uint64_t Phase::Geometry::MpsCpuSceneBuilder::RemoveInactiveScenes(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v6;
  unsigned int v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  char v13;
  unint64_t v14;

  v4 = *a2;
  result = a2[1];
  if (result != *a2)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = *(_QWORD **)(a1 + 8);
      v9 = *(_QWORD **)(a1 + 16);
      if (v8 == v9)
        goto LABEL_13;
      v10 = *(_QWORD *)(v4 + 16 * v6);
      v11 = *(_QWORD *)(a1 + 8);
      while (1)
      {
        v12 = std::__equal_aligned[abi:ne180100]<std::__bitset<1ul,32ul>,true,true>(v8, 0, (uint64_t)v8, 0x20u, (_QWORD *)(v10 + 32));
        v13 = *(unsigned __int8 *)(v11 + 8) == *(unsigned __int8 *)(v10 + 40) ? v12 : 0;
        if ((v13 & 1) != 0)
          break;
        v11 += 24;
        v8 += 3;
        if ((_QWORD *)v11 == v9)
        {
          result = a2[1];
          goto LABEL_13;
        }
      }
      result = a2[1];
      if ((_QWORD *)v11 == v9)
      {
LABEL_13:
        if ((v7 & 0x80000000) == 0)
        {
          v14 = (result - *a2) >> 4;
          if (v14 > v7)
          {
            if (v14 - 1 > v7)
            {
              std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(*a2 + 16 * v7), (uint64_t *)(result - 16));
              result = a2[1];
            }
            result = std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](result - 16);
            a2[1] = result;
          }
        }
      }
      else
      {
        ++v7;
      }
      v6 = (int)v7;
      v4 = *a2;
    }
    while ((int)v7 < (unint64_t)((result - *a2) >> 4));
  }
  return result;
}

void Phase::Geometry::MpsCpuSceneBuilder::ProcessFinishedBuild(unsigned __int8 *a1, uint64_t a2)
{
  unsigned __int8 v3;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *i;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  char v14;
  char v15;
  uint64_t *MpsCpuScenePtr;
  uint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  char *v35;
  __int128 v36;
  uint64_t v37;
  int v38;
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  uint64_t v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)a1 + 7))
  {
    v3 = atomic_load(a1 + 160);
    if ((v3 & 1) != 0)
    {
      v5 = *(_QWORD *)(*(_QWORD *)a1 + 2424);
      v6 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)a1) + 416);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *((_QWORD *)a1 + 12);
        v38 = 136315906;
        v39 = "GeoMpsCpuSceneBuilder.cpp";
        v40 = 1024;
        v41 = 273;
        v42 = 2048;
        v43 = v7;
        v44 = 2048;
        v45 = v5;
        _os_log_impl(&dword_2164CC000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Integrating built MPS Scenes from cycle: %llu, current cycle: %llu", (uint8_t *)&v38, 0x26u);
      }
      v8 = (uint64_t *)*((_QWORD *)a1 + 9);
      for (i = (uint64_t *)*((_QWORD *)a1 + 10); v8 != i; v8 += 8)
      {
        v10 = *v8;
        if (*v8)
        {
          v12 = (_QWORD *)*((_QWORD *)a1 + 1);
          v11 = (_QWORD *)*((_QWORD *)a1 + 2);
          if (v12 != v11)
          {
            v13 = *((_QWORD *)a1 + 1);
            while (1)
            {
              v14 = std::__equal_aligned[abi:ne180100]<std::__bitset<1ul,32ul>,true,true>(v12, 0, (uint64_t)v12, 0x20u, (_QWORD *)(v10 + 32));
              v15 = *(unsigned __int8 *)(v13 + 8) == *(unsigned __int8 *)(v10 + 40) ? v14 : 0;
              if ((v15 & 1) != 0)
                break;
              v13 += 24;
              v12 += 3;
              if ((_QWORD *)v13 == v11)
                goto LABEL_42;
            }
            if ((_QWORD *)v13 != v11)
            {
              MpsCpuScenePtr = Phase::Geometry::GetMpsCpuScenePtr((uint64_t **)a2, *(_QWORD *)(v10 + 32), *(_QWORD *)(v10 + 40));
              if (MpsCpuScenePtr)
              {
                std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100](MpsCpuScenePtr, v8);
              }
              else
              {
                v17 = *(uint64_t **)(a2 + 8);
                v18 = *(_QWORD *)(a2 + 16);
                if ((unint64_t)v17 >= v18)
                {
                  v23 = ((uint64_t)v17 - *(_QWORD *)a2) >> 4;
                  v24 = v23 + 1;
                  if ((unint64_t)(v23 + 1) >> 60)
                    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
                  v25 = v18 - *(_QWORD *)a2;
                  if (v25 >> 3 > v24)
                    v24 = v25 >> 3;
                  if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF0)
                    v26 = 0xFFFFFFFFFFFFFFFLL;
                  else
                    v26 = v24;
                  v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::UniqueObjectId>>(a2 + 16, v26);
                  v29 = &v27[16 * v23];
                  v30 = *(_OWORD *)v8;
                  *(_OWORD *)v29 = *(_OWORD *)v8;
                  if (*((_QWORD *)&v30 + 1))
                  {
                    v31 = (unint64_t *)(*((_QWORD *)&v30 + 1) + 8);
                    do
                      v32 = __ldxr(v31);
                    while (__stxr(v32 + 1, v31));
                  }
                  v33 = *(uint64_t **)a2;
                  v34 = *(uint64_t **)(a2 + 8);
                  if (v34 == *(uint64_t **)a2)
                  {
                    v22 = v29 + 16;
                    *(_QWORD *)a2 = v29;
                    *(_QWORD *)(a2 + 8) = v29 + 16;
                    *(_QWORD *)(a2 + 16) = &v27[16 * v28];
                  }
                  else
                  {
                    v35 = v29;
                    do
                    {
                      v36 = *((_OWORD *)v34 - 1);
                      v34 -= 2;
                      *((_OWORD *)v35 - 1) = v36;
                      v35 -= 16;
                      *v34 = 0;
                      v34[1] = 0;
                    }
                    while (v34 != v33);
                    v34 = *(uint64_t **)a2;
                    v37 = *(_QWORD *)(a2 + 8);
                    v22 = v29 + 16;
                    *(_QWORD *)a2 = v35;
                    *(_QWORD *)(a2 + 8) = v29 + 16;
                    *(_QWORD *)(a2 + 16) = &v27[16 * v28];
                    while ((uint64_t *)v37 != v34)
                    {
                      v37 -= 16;
                      std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v37);
                    }
                  }
                  if (v34)
                    operator delete(v34);
                }
                else
                {
                  *v17 = *v8;
                  v19 = v8[1];
                  v17[1] = v19;
                  if (v19)
                  {
                    v20 = (unint64_t *)(v19 + 8);
                    do
                      v21 = __ldxr(v20);
                    while (__stxr(v21 + 1, v20));
                  }
                  v22 = v17 + 2;
                }
                *(_QWORD *)(a2 + 8) = v22;
              }
            }
          }
        }
LABEL_42:
        ;
      }
      *((_QWORD *)a1 + 19) = *((_QWORD *)a1 + 12);
      Phase::Geometry::MpsCpuSceneBuilder::ResetBuildTask((Phase::Geometry::MpsCpuSceneBuilder *)a1);
    }
  }
}

void sub_2165C13C4(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

void Phase::Geometry::MpsCpuSceneBuilder::UpdateWaitList(_QWORD *a1, uint64_t *a2)
{
  _BYTE *v4;
  _BYTE *v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  _QWORD *v11;
  char v12;
  char v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  uint64_t v19;
  _OWORD *v20;
  unint64_t v21;
  _BYTE *v22;
  _BYTE *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  char v32;

  v4 = (_BYTE *)a1[4];
  v5 = (_BYTE *)a1[5];
  if (v5 != v4)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = *a2;
      v9 = a2[1];
      if (*a2 == v9)
      {
LABEL_11:
        if ((v7 & 0x80000000) == 0)
        {
          v14 = a1[4];
          v15 = (uint64_t)&v5[-v14] >> 4;
          if (v15 > v7)
          {
            if (v15 - 1 > v7)
            {
              v16 = v14 + 16 * v7;
              v17 = *((_QWORD *)v5 - 2);
              *(_BYTE *)(v16 + 8) = *(v5 - 8);
              *(_QWORD *)v16 = v17;
              v5 = (_BYTE *)a1[5];
            }
            v5 -= 16;
            a1[5] = v5;
          }
        }
      }
      else
      {
        v10 = &v4[16 * v6];
        v11 = (_QWORD *)(v8 + 24);
        while (1)
        {
          v12 = std::__equal_aligned[abi:ne180100]<std::__bitset<1ul,32ul>,true,true>(v11, 0, (uint64_t)v11, 0x20u, v10);
          v13 = *(unsigned __int8 *)(v8 + 32) == v10[8] ? v12 : 0;
          if ((v13 & 1) != 0)
            break;
          v8 += 48;
          v11 += 6;
          if (v8 == v9)
          {
            v5 = (_BYTE *)a1[5];
            goto LABEL_11;
          }
        }
        *(_BYTE *)(v8 + 40) = 0;
        ++v7;
        v5 = (_BYTE *)a1[5];
      }
      v6 = (int)v7;
      v4 = (_BYTE *)a1[4];
    }
    while ((int)v7 < (unint64_t)((v5 - v4) >> 4));
  }
  v19 = *a2;
  for (i = a2[1]; v19 != i; v19 += 48)
  {
    if (*(_BYTE *)(v19 + 40))
    {
      v20 = (_OWORD *)(v19 + 24);
      v21 = a1[6];
      if ((unint64_t)v5 >= v21)
      {
        v23 = (_BYTE *)a1[4];
        v24 = (v5 - v23) >> 4;
        v25 = v24 + 1;
        if ((unint64_t)(v24 + 1) >> 60)
          std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
        v26 = v21 - (_QWORD)v23;
        if (v26 >> 3 > v25)
          v25 = v26 >> 3;
        if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0)
          v27 = 0xFFFFFFFFFFFFFFFLL;
        else
          v27 = v25;
        if (v27)
        {
          if (v27 >> 60)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v28 = (char *)operator new(16 * v27);
        }
        else
        {
          v28 = 0;
        }
        v29 = &v28[16 * v24];
        *(_OWORD *)v29 = *v20;
        v30 = v29;
        if (v5 != v23)
        {
          do
          {
            v31 = *((_QWORD *)v5 - 2);
            v5 -= 16;
            v32 = v5[8];
            *((_QWORD *)v30 - 2) = v31;
            v30 -= 16;
            v30[8] = v32;
          }
          while (v5 != v23);
          v5 = (_BYTE *)a1[4];
        }
        v22 = v29 + 16;
        a1[4] = v30;
        a1[5] = v29 + 16;
        a1[6] = &v28[16 * v27];
        if (v5)
          operator delete(v5);
      }
      else
      {
        *(_OWORD *)v5 = *v20;
        v22 = v5 + 16;
      }
      a1[5] = v22;
      v5 = v22;
    }
  }
}

BOOL Phase::Geometry::MpsCpuSceneBuilder::StartNewBuild(unsigned __int8 *a1, uint64_t *a2)
{
  unsigned __int8 *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  int64x2_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *p_shared_owners;
  unint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  uint64_t v55;
  uint64_t v56;
  unsigned __int8 *v57;
  uint64_t v58[2];
  void *__p;
  int64x2_t v60;
  char *v61;
  _QWORD *v62;
  __int128 v63;

  if (*((_QWORD *)a1 + 7))
    goto LABEL_62;
  v2 = a1;
  if (*((_QWORD *)a1 + 10) != *((_QWORD *)a1 + 9))
    goto LABEL_62;
  v55 = (uint64_t)(a1 + 56);
  v5 = *((_QWORD *)a1 + 4);
  v4 = *((_QWORD *)a1 + 5);
  if (v5 != v4)
  {
    do
    {
      v7 = *a2;
      v8 = a2[1];
      if (*a2 != v8)
      {
        v9 = (_QWORD *)(v7 + 24);
        while (1)
        {
          v10 = std::__equal_aligned[abi:ne180100]<std::__bitset<1ul,32ul>,true,true>(v9, 0, (uint64_t)v9, 0x20u, (_QWORD *)v5);
          v11 = *(unsigned __int8 *)(v7 + 32) == *(unsigned __int8 *)(v5 + 8) ? v10 : 0;
          if (v11 == 1)
            break;
          v7 += 48;
          v9 += 6;
          if (v7 == v8)
            goto LABEL_13;
        }
        *(_BYTE *)(v7 + 40) = 1;
      }
LABEL_13:
      v5 += 16;
    }
    while (v5 != v4);
    v2 = a1;
    v5 = *((_QWORD *)a1 + 4);
  }
  *((_QWORD *)v2 + 5) = v5;
  v12 = *a2;
  v13 = a2[1];
  if (*a2 != v13)
  {
    v14 = v2 + 88;
    v56 = v13;
    v57 = v2;
    do
    {
      if (*(_BYTE *)(v12 + 40))
      {
        v16 = *((_QWORD *)v2 + 10);
        v15 = *((_QWORD *)v2 + 11);
        if (v16 >= v15)
        {
          v18 = *((_QWORD *)v2 + 9);
          v19 = (uint64_t)(v16 - v18) >> 6;
          if ((unint64_t)(v19 + 1) >> 58)
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          v20 = v15 - v18;
          v21 = v20 >> 5;
          if (v20 >> 5 <= (unint64_t)(v19 + 1))
            v21 = v19 + 1;
          if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFC0)
            v22 = 0x3FFFFFFFFFFFFFFLL;
          else
            v22 = v21;
          v62 = v14;
          if (v22)
          {
            if (v22 >> 58)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v23 = (char *)operator new(v22 << 6);
          }
          else
          {
            v23 = 0;
          }
          __p = v23;
          v60.i64[0] = (uint64_t)&v23[64 * v19];
          v60.i64[1] = v60.i64[0];
          v61 = &v23[64 * v22];
          Phase::Geometry::MpsCpuSceneBuilder::BuildEntry::BuildEntry(v60.i64[0], v12);
          v24 = v60.i64[0];
          v17 = v60.i64[1] + 64;
          v60.i64[1] += 64;
          v27 = v2 + 72;
          v26 = *((_QWORD *)v2 + 9);
          v25 = v27[1];
          if (v25 == v26)
          {
            v36 = vdupq_n_s64(v25);
            v2 = v57;
          }
          else
          {
            v28 = 0;
            v29 = v60.i64[0];
            v30 = v25;
            v31 = v60.i64[0];
            do
            {
              v32 = *(_QWORD *)(v30 - 64);
              v30 -= 64;
              *(_QWORD *)(v31 - 64) = v32;
              v31 -= 64;
              v33 = *(_QWORD *)(v30 + 8);
              *(_QWORD *)(v31 + 8) = v33;
              if (v33)
              {
                v34 = (unint64_t *)(v33 + 8);
                do
                  v35 = __ldxr(v34);
                while (__stxr(v35 + 1, v34));
              }
              *(_QWORD *)(v29 - 48) = 0;
              *(_QWORD *)(v29 - 40) = 0;
              *(_QWORD *)(v29 - 32) = 0;
              std::vector<std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>>::__init_with_size[abi:ne180100]<std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>*,std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>*>((_QWORD *)(v29 - 48), *(_QWORD *)(v25 - 48), *(_QWORD *)(v25 - 40), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(_QWORD *)(v25 - 40) - *(_QWORD *)(v25 - 48)) >> 3));
              *(_OWORD *)(v29 - 24) = *(_OWORD *)(v25 - 24);
              *(_BYTE *)(v29 - 8) = *(_BYTE *)(v25 - 8);
              v28 -= 64;
              v29 = v31;
              v25 = v30;
            }
            while (v30 != v26);
            v2 = v57;
            v36 = *(int64x2_t *)(v57 + 72);
            v17 = v60.i64[1];
            v24 = v31;
            v13 = v56;
          }
          *((_QWORD *)v2 + 9) = v24;
          *((_QWORD *)v2 + 10) = v17;
          v60 = v36;
          v37 = (char *)*((_QWORD *)v2 + 11);
          *((_QWORD *)v2 + 11) = v61;
          v61 = v37;
          __p = (void *)v36.i64[0];
          std::__split_buffer<Phase::Geometry::MpsCpuSceneBuilder::BuildEntry>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          Phase::Geometry::MpsCpuSceneBuilder::BuildEntry::BuildEntry(*((_QWORD *)v2 + 10), v12);
          v17 = v16 + 64;
          *((_QWORD *)v2 + 10) = v16 + 64;
        }
        *((_QWORD *)v2 + 10) = v17;
      }
      v12 += 48;
    }
    while (v12 != v13);
  }
  v39 = *((_QWORD *)v2 + 9);
  v38 = *((_QWORD *)v2 + 10);
  if (v38 != v39)
  {
    v40 = *((_QWORD *)v2 + 9);
    do
    {
      if (*(_QWORD *)(v40 + 24) == *(_QWORD *)(v40 + 16))
        goto LABEL_62;
      v40 += 64;
    }
    while (v40 != v38);
    v41 = *(_QWORD *)v2;
    *((_QWORD *)v2 + 12) = *(_QWORD *)(*(_QWORD *)v2 + 2424);
    v42 = *(_QWORD *)(v41 + 2416);
    std::string::basic_string[abi:ne180100]<0>(&__p, "BuildMpsCpuScene");
    (*(void (**)(__int128 *__return_ptr, uint64_t, void **))(*(_QWORD *)v42 + 16))(&v63, v42, &__p);
    std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100](v55, &v63);
    v43 = (std::__shared_weak_count *)*((_QWORD *)&v63 + 1);
    if (*((_QWORD *)&v63 + 1))
    {
      v44 = (unint64_t *)(*((_QWORD *)&v63 + 1) + 8);
      do
        v45 = __ldaxr(v44);
      while (__stlxr(v45 - 1, v44));
      if (!v45)
      {
        ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
        std::__shared_weak_count::__release_weak(v43);
      }
    }
    if (v60.i8[15] < 0)
      operator delete(__p);
    v46 = *((_QWORD *)v2 + 7);
    *(_DWORD *)(v46 + 524) = 0;
    atomic_store(1u, (unsigned __int8 *)(v46 + 40));
    v47 = *((_QWORD *)v2 + 7);
    *(_QWORD *)(v47 + 256) = &off_24D57D270;
    *(_QWORD *)(v47 + 264) = v2;
    *(_BYTE *)(v47 + 383) = 1;
    atomic_store(1u, (unsigned __int8 *)(v47 + 40));
    atomic_store(0, v2 + 160);
    if (*((_QWORD *)v2 + 7))
    {
      v48 = *(_QWORD *)(*(_QWORD *)v2 + 2416);
      v49 = (std::__shared_weak_count *)*((_QWORD *)v2 + 8);
      v58[0] = *((_QWORD *)v2 + 7);
      v58[1] = (uint64_t)v49;
      if (v49)
      {
        p_shared_owners = (unint64_t *)&v49->__shared_owners_;
        do
          v51 = __ldxr(p_shared_owners);
        while (__stxr(v51 + 1, p_shared_owners));
      }
      Phase::JobManager::RunJobAsync(v48, v58);
      if (v49)
      {
        v52 = (unint64_t *)&v49->__shared_owners_;
        do
          v53 = __ldaxr(v52);
        while (__stlxr(v53 - 1, v52));
        if (!v53)
        {
          ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
          std::__shared_weak_count::__release_weak(v49);
        }
      }
      return v38 != v39;
    }
LABEL_62:
    std::terminate();
  }
  return v38 != v39;
}

void sub_2165C19E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  _Unwind_Resume(a1);
}

_QWORD *Phase::Geometry::MpsCpuSceneBuilder::SaveSceneShapes(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  _QWORD *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t *v11;
  unsigned int v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  _QWORD *result;
  __int128 v23;
  unsigned int v24;
  uint64_t v25;
  std::__shared_mutex_base v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    v23 = 0uLL;
    v24 = 0;
    v25 = 0xFFFFFFFFLL;
    std::__shared_mutex_base::__shared_mutex_base(&v26);
    v27 = 0;
    v8 = *(_QWORD **)(a1 + 104);
    v7 = *(_QWORD *)(a1 + 112);
    *(_QWORD *)&v23 = v8;
    *((_QWORD *)&v23 + 1) = v7;
    *(_OWORD *)(a1 + 104) = 0uLL;
    v9 = v24;
    v10 = *(_DWORD *)(a1 + 120);
    v24 = v10;
    *(_DWORD *)(a1 + 120) = v9;
    v11 = *(uint64_t **)a4;
    if (*(_QWORD *)a4 && v8)
    {
      v12 = *(_DWORD *)(a4 + 16);
      if (v12 >= v10)
        v13 = v10;
      else
        v13 = v12;
      v14 = &v8[3 * v13];
      if (v7 && *(uint64_t *)(v7 + 8) >= 1 && (_DWORD)v13)
      {
        v15 = 0;
        while (1)
        {
          v16 = v8[v15];
          if (v16 && v16 != v11[v15])
            break;
          v15 += 3;
          if (3 * v13 == v15)
            goto LABEL_26;
        }
        Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::Realloc(&v23);
        v11 = (uint64_t *)((char *)v11 + v15 * 8);
        v8 = (_QWORD *)(v23 + v15 * 8);
        v14 = (_QWORD *)(v23 + 24 * v13);
      }
      while (v8 != v14)
      {
        if (*v8)
          v18 = *v8 == *v11;
        else
          v18 = 1;
        if (!v18)
        {
          std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100](v8, v11);
          v8[2] = v11[2];
        }
        v8 += 3;
        v11 += 3;
      }
    }
LABEL_26:
    std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(a1 + 128), (uint64_t *)&v23);
    *(_DWORD *)(a1 + 144) = v24;
    std::condition_variable::~condition_variable(&v26.__gate2_);
    std::condition_variable::~condition_variable(&v26.__gate1_);
    std::mutex::~mutex(&v26.__mut_);
    v19 = (std::__shared_weak_count *)*((_QWORD *)&v23 + 1);
    if (*((_QWORD *)&v23 + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&v23 + 1) + 8);
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }
  else
  {
    std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(a1 + 128), (uint64_t *)a4);
    *(_DWORD *)(a1 + 144) = *(_DWORD *)(a4 + 16);
  }
  result = std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(a1 + 104), (uint64_t *)a3);
  *(_DWORD *)(a1 + 120) = *(_DWORD *)(a3 + 16);
  return result;
}

void sub_2165C1C68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  Phase::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64,Phase::Geometry::ShapeFactory>::~SharedSlotMap((std::condition_variable *)&a9);
  _Unwind_Resume(a1);
}

void Phase::Geometry::MpsCpuSceneBuilder::WaitForCurrentBuild(Phase::Geometry::MpsCpuSceneBuilder *this)
{
  uint64_t v1;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;

  v1 = *((_QWORD *)this + 7);
  if (v1)
  {
    v3 = *(_QWORD *)(*(_QWORD *)this + 2416);
    v4 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
    v10 = v1;
    v11 = v4;
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }
    (*(void (**)(uint64_t, uint64_t *, double))(*(_QWORD *)v3 + 96))(v3, &v10, 0.0);
    v7 = v11;
    if (v11)
    {
      v8 = (unint64_t *)&v11->__shared_owners_;
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

void sub_2165C1D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void Phase::Geometry::MpsCpuSceneBuilder::ResetBuildTask(Phase::Geometry::MpsCpuSceneBuilder *this)
{
  uint64_t i;
  uint64_t v3;

  std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)this + 7);
  v3 = *((_QWORD *)this + 9);
  for (i = *((_QWORD *)this + 10);
        i != v3;
        std::allocator<Phase::Geometry::MpsCpuSceneBuilder::BuildEntry>::destroy[abi:ne180100]((uint64_t)this + 88, i))
  {
    i -= 64;
  }
  *((_QWORD *)this + 10) = v3;
}

void Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::MergeFrom(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  _QWORD *v3;
  BOOL v4;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;

  v2 = *(uint64_t **)a2;
  v3 = *(_QWORD **)a1;
  if (*(_QWORD *)a2)
    v4 = v3 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    v6 = *(_DWORD *)(a1 + 16);
    v7 = *(_DWORD *)(a2 + 16);
    if (v7 >= v6)
      v8 = v6;
    else
      v8 = v7;
    v9 = (uint64_t)&v3[3 * v8];
    v10 = *(_QWORD *)(a1 + 8);
    if (v10)
    {
      if (*(uint64_t *)(v10 + 8) >= 1 && (_DWORD)v8 != 0)
      {
        v12 = 0;
        while (v3[v12] || !v2[v12])
        {
          v12 += 3;
          if (3 * v8 == v12)
            return;
        }
        Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::Realloc((__int128 *)a1);
        v3 = (_QWORD *)(*(_QWORD *)a1 + v12 * 8);
        v9 = *(_QWORD *)a1 + 24 * v8;
        v2 = (uint64_t *)((char *)v2 + v12 * 8);
      }
    }
    while (v3 != (_QWORD *)v9)
    {
      if (!*v3)
      {
        if (*v2)
        {
          std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100](v3, v2);
          v3[2] = v2[2];
        }
      }
      v3 += 3;
      v2 += 3;
    }
  }
}

uint64_t Phase::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64,Phase::Geometry::ShapeFactory>::~SharedSlotMap(std::condition_variable *a1)
{
  std::mutex *v2;

  v2 = (std::mutex *)&a1->__cv_.__opaque[24];
  std::condition_variable::~condition_variable(a1 + 3);
  std::condition_variable::~condition_variable(a1 + 2);
  std::mutex::~mutex(v2);
  return std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)a1);
}

void std::vector<Phase::Geometry::MpsCpuSceneBuilder::BuildEntry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 64;
        std::allocator<Phase::Geometry::MpsCpuSceneBuilder::BuildEntry>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::allocator<Phase::Geometry::MpsCpuSceneBuilder::BuildEntry>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v3;

  v3 = *(void **)(a2 + 16);
  if (v3)
  {
    *(_QWORD *)(a2 + 24) = v3;
    operator delete(v3);
  }
  return std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](a2);
}

uint64_t std::__equal_aligned[abi:ne180100]<std::__bitset<1ul,32ul>,true,true>(_QWORD *a1, unsigned int a2, uint64_t a3, unsigned int a4, _QWORD *a5)
{
  int64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;

  v5 = a4 - (unint64_t)a2 + 8 * (a3 - (_QWORD)a1);
  if (v5 >= 1)
  {
    if (a2)
    {
      if (v5 >= (unint64_t)(64 - a2))
        v6 = 64 - a2;
      else
        v6 = a4 - (unint64_t)a2 + 8 * (a3 - (_QWORD)a1);
      if (((0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v6)) & (-1 << a2) & (*a1 ^ *a5)) != 0)
        return 0;
      v5 -= v6;
      ++a5;
      ++a1;
    }
    if (v5 >= 64)
    {
      while (*a5 == *a1)
      {
        v7 = v5 - 64;
        ++a1;
        ++a5;
        v8 = v5 <= 127;
        v5 -= 64;
        if (v8)
          goto LABEL_14;
      }
      return 0;
    }
    v7 = v5;
LABEL_14:
    if (v7 >= 1 && (*a1 ^ *a5) << -(char)v7)
      return 0;
  }
  return 1;
}

void Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::Realloc(__int128 *a1)
{
  unint64_t v1;
  unint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  __int128 v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  __int128 *v11;
  char v12;
  __int128 v13;

  v1 = *((unsigned int *)a1 + 4);
  if ((_DWORD)v1)
  {
    Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::AllocSlots(v1, &v13);
    if (*((_DWORD *)a1 + 4))
    {
      v3 = 0;
      v4 = 16;
      do
      {
        v5 = (_QWORD *)(*(_QWORD *)a1 + v4);
        v6 = (_QWORD *)(v13 + v4);
        std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(v13 + v4 - 16), v5 - 2);
        *v6 = *v5;
        ++v3;
        v4 += 24;
      }
      while (v3 < *((unsigned int *)a1 + 4));
    }
    v11 = a1 + 2;
    v12 = 1;
    std::__shared_mutex_base::lock((std::__shared_mutex_base *)(a1 + 2));
    v7 = *a1;
    *a1 = v13;
    v13 = v7;
    std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v11);
    v8 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
    if (*((_QWORD *)&v13 + 1))
    {
      v9 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
}

void sub_2165C2134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::AllocSlots(unint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;

  if (a1)
  {
    is_mul_ok(a1, 0x18uLL);
    v4 = 24 * a1;
    v5 = (_QWORD *)operator new[]();
    *v5 = 24;
    v5[1] = a1;
    v6 = v5 + 2;
    do
    {
      *v6 = 0;
      v6[1] = 0;
      v6 += 3;
      v4 -= 24;
    }
    while (v4);
    std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::Shape,Phase::Handle64>::Slot []>::shared_ptr[abi:ne180100]<Phase::SharedSlotMapState<Phase::Geometry::Shape,Phase::Handle64>::Slot,void>(a2, (uint64_t)(v5 + 2));
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

_QWORD *std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::Shape,Phase::Handle64>::Slot []>::shared_ptr[abi:ne180100]<Phase::SharedSlotMapState<Phase::Geometry::Shape,Phase::Handle64>::Slot,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D57D238;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_2165C2240(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot,std::default_delete<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot>>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<Phase::SharedSlotMapState<Phase::Geometry::Shape,Phase::Handle64>::Slot *,std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::Shape,Phase::Handle64>::Slot[]>::__shared_ptr_default_delete<Phase::SharedSlotMapState<Phase::Geometry::Shape,Phase::Handle64>::Slot[],Phase::SharedSlotMapState<Phase::Geometry::Shape,Phase::Handle64>::Slot>,std::allocator<Phase::SharedSlotMapState<Phase::Geometry::Shape,Phase::Handle64>::Slot>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

void std::__shared_ptr_pointer<Phase::SharedSlotMapState<Phase::Geometry::Shape,Phase::Handle64>::Slot *,std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::Shape,Phase::Handle64>::Slot[]>::__shared_ptr_default_delete<Phase::SharedSlotMapState<Phase::Geometry::Shape,Phase::Handle64>::Slot[],Phase::SharedSlotMapState<Phase::Geometry::Shape,Phase::Handle64>::Slot>,std::allocator<Phase::SharedSlotMapState<Phase::Geometry::Shape,Phase::Handle64>::Slot>>::__on_zero_shared(uint64_t a1)
{
  std::default_delete<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot []>::operator()[abi:ne180100]<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot>(a1 + 24, *(_QWORD *)(a1 + 24));
}

void Phase::Command<128>::Invoker<Phase::Geometry::MpsCpuSceneBuilder::PrepareBuildJob(void)::$_0,void>::~Invoker()
{
  JUMPOUT(0x2199F9D70);
}

void Phase::Command<128>::Invoker<Phase::Geometry::MpsCpuSceneBuilder::PrepareBuildJob(void)::$_0,void>::Call(Phase::Logger *a1)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v1 = *((_QWORD *)a1 + 1);
  v2 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 416);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_QWORD *)(v1 + 96);
    v12 = 136315650;
    v13 = "GeoMpsCpuSceneBuilder.cpp";
    v14 = 1024;
    v15 = 139;
    v16 = 2048;
    v17 = v3;
    _os_log_impl(&dword_2164CC000, v2, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Starting build of MPS Scenes from cycle: %llu", (uint8_t *)&v12, 0x1Cu);
  }
  v4 = *(_QWORD *)(v1 + 72);
  for (i = *(_QWORD *)(v1 + 80); v4 != i; v4 += 64)
  {
    v6 = *(_QWORD *)(v1 + 96);
    v7 = operator new(0x50uLL);
    v7[2] = 0;
    *v7 = &off_24D57D298;
    v7[1] = 0;
    v8 = Phase::Geometry::MpsCpuScene::MpsCpuScene((uint64_t)(v7 + 3), v4 + 16, v6);
    v9 = *(std::__shared_weak_count **)(v4 + 8);
    *(_QWORD *)v4 = v8;
    *(_QWORD *)(v4 + 8) = v7;
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    Phase::Geometry::MpsCpuScene::Build(*(Phase::Geometry::MpsCpuScene **)v4);
  }
  atomic_store(1u, (unsigned __int8 *)(v1 + 160));
}

void sub_2165C2414(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v3;

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<Phase::Geometry::MpsCpuScene>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57D298;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Phase::Geometry::MpsCpuScene>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57D298;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

void std::__shared_ptr_emplace<Phase::Geometry::MpsCpuScene>::__on_zero_shared(uint64_t a1)
{
  Phase::Geometry::MpsCpuScene::~MpsCpuScene((Phase::Geometry::MpsCpuScene *)(a1 + 24));
}

uint64_t Phase::Geometry::MpsCpuSceneBuilder::BuildEntry::BuildEntry(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  std::vector<std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>>::__init_with_size[abi:ne180100]<std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>*,std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>*>((_QWORD *)(a1 + 16), *(_QWORD *)a2, *(_QWORD *)(a2 + 8), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3));
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 24);
  *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 40);
  return a1;
}

void sub_2165C24EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>>::__init_with_size[abi:ne180100]<std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>*,std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>>,std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>*,std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>*,std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_2165C2554(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  void *v4;

  *(_QWORD *)(v1 + 8) = v2;
  v4 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>>,std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>*,std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>*,std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  result = a4;
  while (a2 != a3)
  {
    *(_DWORD *)result = *(_DWORD *)a2;
    *(_DWORD *)(result + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(result + 12) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(result + 20) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(result + 24) = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(result + 28) = *(_DWORD *)(a2 + 28);
    *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
    *(_OWORD *)(result + 40) = *(_OWORD *)(a2 + 40);
    result += 56;
    a2 += 56;
  }
  return result;
}

uint64_t std::__split_buffer<Phase::Geometry::MpsCpuSceneBuilder::BuildEntry>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 16) = i - 64;
    std::allocator<Phase::Geometry::MpsCpuSceneBuilder::BuildEntry>::destroy[abi:ne180100](v4, i - 64);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t Phase::Geometry::MpsCpuScene::MpsCpuScene(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 48) = a3;
  *(_QWORD *)a1 = objc_opt_new();
  return a1;
}

void sub_2165C2694(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(_QWORD *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void Phase::Geometry::MpsCpuScene::~MpsCpuScene(Phase::Geometry::MpsCpuScene *this)
{
  void *v2;
  void *v3;

  v2 = *(void **)this;
  *(_QWORD *)this = 0;

  v3 = (void *)*((_QWORD *)this + 1);
  if (v3)
  {
    *((_QWORD *)this + 2) = v3;
    operator delete(v3);
  }
}

void Phase::Geometry::MpsCpuScene::Build(Phase::Geometry::MpsCpuScene *this)
{
  uint64_t InstancePtr;
  Phase::Logger *v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  char *v14;
  uint64_t v15;
  int64x2_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  uint64_t v23;
  uint64_t v24;
  float32x4_t v25;
  float32x4_t *v26;
  float32x4_t *v27;
  uint64_t v28;
  float32x4_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  unint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  uint64_t v42;
  int64x2_t v43;
  uint64_t v44;
  NSObject *v45;
  uint64_t v46;
  void *v47;
  void *v48;
  id v49;
  NSObject *v50;
  _BOOL8 v51;
  const char *v52;
  Phase::Logger *v53;
  NSObject *v54;
  NSObject *v55;
  os_signpost_id_t v56;
  Phase::Geometry::MpsCpuScene *v57;
  int64x2_t v58;
  _QWORD v59[2];
  _BYTE buf[40];
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  InstancePtr = Phase::Logger::GetInstancePtr(this);
  v3 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(InstancePtr + 416));
  v4 = Phase::Logger::GetInstancePtr(v3);
  if (*(_BYTE *)(v4 + 424))
  {
    v5 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr((Phase::Logger *)v4)
                                                                                       + 416)));
    v6 = v5;
    if ((unint64_t)v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v6, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v3, "Phase_MpsCpuScene_Build", "MpsCpuScene: Build", buf, 2u);
    }

  }
  v58 = 0uLL;
  v59[0] = 0;
  v7 = *((_QWORD *)this + 1);
  v8 = *((_QWORD *)this + 2);
  if (v8 != v7)
  {
    v9 = 0x6DB6DB6DB6DB6DB7 * ((v8 - v7) >> 3);
    if (v9 >> 61)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    *(_QWORD *)&buf[32] = v59;
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int *>>(v9);
    v12 = (_QWORD *)v58.i64[1];
    v13 = (_QWORD *)v58.i64[0];
    if (v58.i64[1] == v58.i64[0])
    {
      v16 = vdupq_n_s64(v58.u64[1]);
      v14 = v10;
    }
    else
    {
      v14 = v10;
      do
      {
        v15 = *--v12;
        *v12 = 0;
        *((_QWORD *)v14 - 1) = v15;
        v14 -= 8;
      }
      while (v12 != v13);
      v16 = v58;
    }
    v58.i64[0] = (uint64_t)v14;
    v58.i64[1] = (uint64_t)v10;
    *(int64x2_t *)&buf[8] = v16;
    v17 = v59[0];
    v59[0] = &v10[8 * v11];
    *(_QWORD *)&buf[24] = v17;
    *(_QWORD *)buf = v16.i64[0];
    v4 = std::__split_buffer<MPSCPUAccelerationStructureTriangleGeometryDescriptor * {__strong}>::~__split_buffer((uint64_t)buf);
    v7 = *((_QWORD *)this + 1);
    v8 = *((_QWORD *)this + 2);
  }
  v56 = (os_signpost_id_t)v3;
  v57 = this;
  if (v7 == v8)
  {
    v18 = 0;
  }
  else
  {
    v18 = 0;
    do
    {
      v19 = **(_QWORD **)(*(_QWORD *)(v7 + 48) + 120);
      if (Phase::operator!=<float>((float *)v7, (float *)(v19 + 112)))
      {
        v20 = Phase::Matrix33From<float>((float *)v7, (float32x4_t *)buf);
        v23 = *(_QWORD *)(**(_QWORD **)(v19 + 16) + 16 * *(_QWORD *)(v19 + 24));
        v24 = *(_QWORD *)(v23 + 24);
        if (v24)
        {
          v20.i64[0] = *(_QWORD *)&buf[12];
          v20.i32[2] = *(_DWORD *)&buf[20];
          v25 = *(float32x4_t *)buf;
          v21.i64[0] = *(_QWORD *)&buf[24];
          v21.i32[2] = *(_DWORD *)&buf[32];
          v22.i64[0] = *(_QWORD *)(v7 + 16);
          v22.i32[2] = *(_DWORD *)(v7 + 24);
          v26 = *(float32x4_t **)(v23 + 8);
          v27 = *(float32x4_t **)(*(_QWORD *)(**(_QWORD **)(v19 + 96) + 16 * *(_QWORD *)(v19 + 104)) + 8);
          v28 = 16 * v24;
          do
          {
            v29 = *v26++;
            *v27++ = vaddq_f32(v22, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v25, v29.f32[0]), v20, *(float32x2_t *)v29.f32, 1), v21, v29, 2));
            v28 -= 16;
          }
          while (v28);
        }
        *(_DWORD *)(v19 + 112) = *(_DWORD *)v7;
        *(_DWORD *)(v19 + 116) = *(_DWORD *)(v7 + 4);
        *(_DWORD *)(v19 + 120) = *(_DWORD *)(v7 + 8);
        *(_DWORD *)(v19 + 124) = *(_DWORD *)(v7 + 12);
        *(_DWORD *)(v19 + 128) = *(_DWORD *)(v7 + 16);
        *(_DWORD *)(v19 + 132) = *(_DWORD *)(v7 + 20);
        *(_DWORD *)(v19 + 136) = *(_DWORD *)(v7 + 24);
        *(_DWORD *)(v19 + 140) = *(_DWORD *)(v7 + 28);
      }
      v30 = objc_opt_new();
      v31 = v30;
      v32 = v58.i64[1];
      if (v58.i64[1] >= v59[0])
      {
        v34 = (v58.i64[1] - v58.i64[0]) >> 3;
        if ((unint64_t)(v34 + 1) >> 61)
          std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
        v35 = (v59[0] - v58.i64[0]) >> 2;
        if (v35 <= v34 + 1)
          v35 = v34 + 1;
        if (v59[0] - v58.i64[0] >= 0x7FFFFFFFFFFFFFF8uLL)
          v36 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v36 = v35;
        *(_QWORD *)&buf[32] = v59;
        if (v36)
          v36 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<int *>>(v36);
        else
          v37 = 0;
        v38 = (uint64_t *)(v36 + 8 * v34);
        v39 = v36 + 8 * v37;
        *(_QWORD *)&buf[24] = v39;
        *v38 = v31;
        v33 = v38 + 1;
        *(_QWORD *)&buf[16] = v38 + 1;
        v40 = (_QWORD *)v58.i64[1];
        v41 = (_QWORD *)v58.i64[0];
        if (v58.i64[1] == v58.i64[0])
        {
          v43 = vdupq_n_s64(v58.u64[1]);
        }
        else
        {
          do
          {
            v42 = *--v40;
            *v40 = 0;
            *--v38 = v42;
          }
          while (v40 != v41);
          v43 = v58;
          v33 = *(_QWORD **)&buf[16];
          v39 = *(_QWORD *)&buf[24];
        }
        v58.i64[0] = (uint64_t)v38;
        v58.i64[1] = (uint64_t)v33;
        *(int64x2_t *)&buf[8] = v43;
        v44 = v59[0];
        v59[0] = v39;
        *(_QWORD *)&buf[24] = v44;
        *(_QWORD *)buf = v43.i64[0];
        std::__split_buffer<MPSCPUAccelerationStructureTriangleGeometryDescriptor * {__strong}>::~__split_buffer((uint64_t)buf);
      }
      else
      {
        *(_QWORD *)v58.i64[1] = v30;
        v33 = (_QWORD *)(v32 + 8);
      }
      v58.i64[1] = (uint64_t)v33;
      objc_msgSend((id)*(v33 - 1), "setVertexData:", *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v19 + 96) + 16 * *(_QWORD *)(v19 + 104)) + 8), v56);
      objc_msgSend((id)*(v33 - 1), "setVertexStride:", 16);
      objc_msgSend((id)*(v33 - 1), "setIndexData:", *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v19 + 32) + 16 * *(_QWORD *)(v19 + 40)) + 8));
      objc_msgSend((id)*(v33 - 1), "setIndexDataType:", 536870944);
      objc_msgSend((id)*(v33 - 1), "setTriangleCount:", *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v19 + 48) + 16 * *(_QWORD *)(v19 + 56)) + 24));
      v4 = objc_msgSend((id)*(v33 - 1), "triangleCount");
      v18 += v4;
      *(_QWORD *)(v7 + 48) = 0;
      v7 += 56;
    }
    while (v7 != v8);
  }
  v45 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr((Phase::Logger *)v4) + 416));
  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
  {
    v46 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((_QWORD *)v57 + 2) - *((_QWORD *)v57 + 1)) >> 3);
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "GeoMpsImplementation.mm";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 110;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v46;
    *(_WORD *)&buf[28] = 2048;
    *(_QWORD *)&buf[30] = v18;
    _os_log_impl(&dword_2164CC000, v45, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Rebuild BVH for %lu shapes. Triangles count %lu", buf, 0x26u);
  }
  v47 = (void *)objc_opt_new();
  objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:");
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v47, "setGeometryDescriptors:", v48);

  v49 = *(id *)v57;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v50 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr((Phase::Logger *)objc_msgSend(v49, "rebuildWithDescriptor:queue:", v47, 0))
                                                     + 416));
    v51 = os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT);
    if (!v51)
      goto LABEL_48;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "GeoMpsImplementation.mm";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 123;
    v52 = "%25s:%-5d Rebuild BVH in thread from selector";
  }
  else
  {
    v50 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr((Phase::Logger *)objc_msgSend(v49, "rebuildWithDescriptor:", v47))
                                                     + 416));
    v51 = os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT);
    if (!v51)
      goto LABEL_48;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "GeoMpsImplementation.mm";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 130;
    v52 = "%25s:%-5d Rebuild BVH asynchronously from selector";
  }
  _os_log_impl(&dword_2164CC000, v50, OS_LOG_TYPE_DEFAULT, v52, buf, 0x12u);
LABEL_48:
  v53 = (Phase::Logger *)Phase::Logger::GetInstancePtr((Phase::Logger *)v51);
  if (*((_BYTE *)v53 + 424))
  {
    v54 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v53)
                                                                                        + 416)));
    v55 = v54;
    if (v56 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v54))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v55, OS_SIGNPOST_INTERVAL_END, v56, "Phase_MpsCpuScene_Build", (const char *)&unk_21676613F, buf, 2u);
    }

  }
  *(_QWORD *)buf = &v58;
  std::vector<MPSCPUAccelerationStructureTriangleGeometryDescriptor * {__strong}>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
}

void sub_2165C2D7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void **a14)
{
  void *v14;
  void *v15;

  a14 = (void **)&a11;
  std::vector<MPSCPUAccelerationStructureTriangleGeometryDescriptor * {__strong}>::__destroy_vector::operator()[abi:ne180100](&a14);
  _Unwind_Resume(a1);
}

float32x4_t Phase::Matrix33From<float>@<Q0>(float *a1@<X0>, float32x4_t *a2@<X8>)
{
  float v4;
  float32_t v5;
  float32x4_t v6;
  float32x4_t result;
  float32x4_t v8[2];
  float v9;

  Phase::Matrix33From<float>(a1, v8[0].f32);
  v4 = a1[7];
  v5 = v4 * v9;
  v6 = vmulq_n_f32(v8[0], v4);
  result = vmulq_n_f32(v8[1], v4);
  *a2 = v6;
  a2[1] = result;
  a2[2].f32[0] = v5;
  return result;
}

void Phase::Geometry::ConvertValidMpsResult<Phase::Geometry::RaycastHit>(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, int a5, uint64_t a6)
{
  unint64_t v7;
  __int128 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  float v20[3];
  __int128 v21;
  uint64_t v22;

  v7 = HIDWORD(a4);
  *(_DWORD *)a6 = a4;
  *(_DWORD *)(a6 + 24) = HIDWORD(a4);
  v8 = (__int128 *)(a3 + 56 * a5);
  v21 = *v8;
  v9 = *((_QWORD *)v8 + 5);
  v22 = v9;
  *(_QWORD *)(a6 + 16) = v9;
  if (v9 < a2
    && *(_DWORD *)(a1 + 24 * v9 + 20) == HIDWORD(v9)
    && (v10 = *(_QWORD *)(a1 + 24 * v9)) != 0)
  {
    v11 = **(_QWORD **)(v10 + 120);
    v12 = *(_QWORD *)(**(_QWORD **)(v11 + 48) + 16 * *(_QWORD *)(v11 + 56));
    v13 = (float *)(*(_QWORD *)(v12 + 8) + *(_QWORD *)(v12 + 32) * v7);
    v20[0] = *v13;
    v20[1] = v13[1];
    v20[2] = v13[2];
    Phase::operator*<float>((float *)&v21, v20, (float *)&v18);
    *(_QWORD *)(a6 + 4) = v18;
    *(_DWORD *)(a6 + 12) = v19;
    v14 = *(_QWORD *)(**(_QWORD **)(v11 + 64) + 16 * *(_QWORD *)(v11 + 72));
    v15 = *(_QWORD *)(**(_QWORD **)(v11 + 80) + 16 * *(_QWORD *)(v11 + 88));
    v16 = *(_QWORD *)(v15 + 8)
        + *(_QWORD *)(v15 + 32) * *(unsigned __int16 *)(*(_QWORD *)(v14 + 8) + *(_QWORD *)(v14 + 32) * v7);
    v17 = *(_QWORD *)(**(_QWORD **)(*(_QWORD *)(v11 + 8) + 144) + 16 * *(_QWORD *)(*(_QWORD *)(v11 + 8) + 152));
    *(_QWORD *)(a6 + 32) = *(_QWORD *)(*(_QWORD *)(v17 + 8) + *(_QWORD *)(v17 + 32) * *(unsigned int *)(v16 + 56));
  }
  else
  {
    *(_QWORD *)(a6 + 8) = 0;
    *(_DWORD *)(a6 + 4) = 0;
    *(_QWORD *)(a6 + 32) = 0;
  }
}

uint64_t Phase::Geometry::RunSingleHitVsMpsScene(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  unsigned int v4;
  unint64_t v7;
  int MpsIntersections;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;

  v4 = a4 - a3;
  if ((int)(a4 - a3) >= 1)
  {
    if (*(_DWORD *)(a2 + 96) <= a3)
      __assert_rtn("Get", "GeoSceneQuery.hpp", 115, "inIndex < inBatch.mCount");
    v7 = *(_QWORD *)(a2 + 88) + *(_DWORD *)(a2 + 100) * a3 + 32;
    MpsIntersections = Phase::Geometry::GetMpsIntersections(a1 + 984);
    if (MpsIntersections == 1)
    {
      v10 = v9;
      if (!v9)
        std::terminate();
      v11 = *(unsigned int *)(a2 + 100);
      if ((_DWORD)v11)
      {
        v12 = v7 + v11 * (unint64_t)v4;
        do
        {
          if (*(float *)v7 >= 0.0)
            Phase::Geometry::ConvertValidMpsResult<Phase::Geometry::RaycastHit>(*(_QWORD *)(a1 + 96), *(_DWORD *)(a1 + 112), *(_QWORD *)(v10 + 8), *(_QWORD *)v7, *(_DWORD *)(v7 + 8), v7);
          else
            *(_DWORD *)v7 = 2139095039;
          v7 += v11;
        }
        while (v7 < v12);
      }
      return 1;
    }
    if (MpsIntersections >= 2)
    {
      v13 = *(unsigned int *)(a2 + 100);
      if ((_DWORD)v13)
      {
        v14 = v7 + v13 * (unint64_t)v4;
        do
        {
          if (*(float *)v7 >= 0.0)
            Phase::Geometry::ConvertValidMpsResult<Phase::Geometry::RaycastHit>(*(_QWORD *)(a1 + 96), *(_DWORD *)(a1 + 112), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 984) + 16 * *(int *)(v7 + 12)) + 8), *(_QWORD *)v7, *(_DWORD *)(v7 + 8), v7);
          else
            *(_DWORD *)v7 = 2139095039;
          v7 += v13;
        }
        while (v7 < v14);
      }
      return 1;
    }
  }
  return 0;
}

uint64_t Phase::Geometry::RunSingleHitVsMpsSceneV2(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  unsigned int v4;
  unint64_t v6;
  _QWORD *v7;
  int MpsIntersections;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int8x16_t *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  int8x16_t *v17;

  v4 = a4 - a3;
  if ((int)(a4 - a3) >= 1)
  {
    if (*(_DWORD *)(a2 + 96) <= a3)
      __assert_rtn("Get", "GeoSceneQuery.hpp", 115, "inIndex < inBatch.mCount");
    v6 = *(_QWORD *)(a2 + 88) + *(_DWORD *)(a2 + 100) * a3 + 32;
    v7 = (_QWORD *)(a1 + 984);
    MpsIntersections = Phase::Geometry::GetMpsIntersections(a1 + 984);
    if (MpsIntersections == 1)
    {
      if (!v9)
        std::terminate();
      v10 = *(unsigned int *)(a2 + 100);
      if ((_DWORD)v10)
      {
        v11 = v6 + v10 * (unint64_t)v4;
        do
        {
          LODWORD(v12) = 2139095039;
          if (*(float *)v6 >= 0.0)
          {
            v12 = *(_QWORD *)v6;
            v13 = (int8x16_t *)(*(_QWORD *)(v9 + 8) + 56 * *(int *)(v6 + 8));
            *(_DWORD *)(v6 + 4) = HIDWORD(*(_QWORD *)v6);
            *(int8x16_t *)(v6 + 8) = vextq_s8(v13[2], v13[2], 8uLL);
          }
          *(_DWORD *)v6 = v12;
          v6 += v10;
        }
        while (v6 < v11);
      }
      return 1;
    }
    if (MpsIntersections >= 2)
    {
      v14 = *(unsigned int *)(a2 + 100);
      if ((_DWORD)v14)
      {
        v15 = v6 + v14 * (unint64_t)v4;
        do
        {
          LODWORD(v16) = 2139095039;
          if (*(float *)v6 >= 0.0)
          {
            v16 = *(_QWORD *)v6;
            v17 = (int8x16_t *)(*(_QWORD *)(*(_QWORD *)(*v7 + 16 * *(int *)(v6 + 12)) + 8) + 56 * *(int *)(v6 + 8));
            *(_DWORD *)(v6 + 4) = HIDWORD(*(_QWORD *)v6);
            *(int8x16_t *)(v6 + 8) = vextq_s8(v17[2], v17[2], 8uLL);
          }
          *(_DWORD *)v6 = v16;
          v6 += v14;
        }
        while (v6 < v15);
      }
      return 1;
    }
  }
  return 0;
}

uint64_t Phase::Geometry::GetOrAddMpsCpuSceneDescriptor(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  char v7;
  char v8;
  __int128 v10;

  *(_QWORD *)&v10 = a2;
  *((_QWORD *)&v10 + 1) = a3;
  v4 = *a1;
  v5 = a1[1];
  if (*a1 == v5)
  {
LABEL_8:
    std::vector<Phase::Geometry::MpsCpuSceneDescriptor>::emplace_back<Phase::Geometry::MpsCpuGroupParams &>(a1, &v10);
    return a1[1] - 48;
  }
  else
  {
    v6 = (_QWORD *)(v4 + 24);
    while (1)
    {
      v7 = std::__equal_aligned[abi:ne180100]<std::__bitset<1ul,32ul>,true,true>(v6, 0, (uint64_t)v6, 0x20u, &v10);
      v8 = *(unsigned __int8 *)(v4 + 32) == BYTE8(v10) ? v7 : 0;
      if ((v8 & 1) != 0)
        break;
      v4 += 48;
      v6 += 6;
      if (v4 == v5)
        goto LABEL_8;
    }
  }
  return v4;
}

uint64_t std::vector<Phase::Geometry::MpsCpuSceneDescriptor>::emplace_back<Phase::Geometry::MpsCpuGroupParams &>(uint64_t *a1, _OWORD *a2)
{
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  uint64_t v24;
  char *v25;
  _BYTE v26[24];
  _QWORD *v27;
  _QWORD v28[3];
  char v29;
  __int128 v30;
  __int128 v31;

  v5 = a1 + 2;
  v4 = a1[2];
  v6 = a1[1];
  if (v6 >= v4)
  {
    v9 = *a1;
    v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - *a1) >> 4);
    v11 = v10 + 1;
    if (v10 + 1 > 0x555555555555555)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v9) >> 4);
    if (2 * v12 > v11)
      v11 = 2 * v12;
    if (v12 >= 0x2AAAAAAAAAAAAAALL)
      v13 = 0x555555555555555;
    else
      v13 = v11;
    v27 = a1 + 2;
    if (v13 > 0x555555555555555)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v14 = 3 * v13;
    v15 = (char *)operator new(48 * v13);
    v16 = (uint64_t)&v15[48 * v10];
    v25 = v15;
    *(_QWORD *)v26 = v16;
    *(_QWORD *)(v16 + 8) = 0;
    *(_QWORD *)(v16 + 16) = 0;
    *(_QWORD *)v16 = 0;
    *(_OWORD *)(v16 + 24) = *a2;
    *(_BYTE *)(v16 + 40) = 0;
    *(_QWORD *)&v26[8] = v16 + 48;
    *(_QWORD *)&v26[16] = &v15[16 * v14];
    *(_QWORD *)&v31 = v16;
    *((_QWORD *)&v31 + 1) = v16;
    v30 = v31;
    v28[0] = v5;
    v28[1] = &v30;
    v28[2] = &v31;
    v29 = 0;
    if (v6 != v9)
    {
      v17 = v6;
      do
      {
        *(_QWORD *)(v16 - 48) = 0;
        *(_QWORD *)(v16 - 40) = 0;
        *(_QWORD *)(v16 - 32) = 0;
        v18 = *(_QWORD *)(v17 - 48);
        v19 = *(_QWORD *)(v17 - 40);
        v17 -= 48;
        std::vector<std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>>::__init_with_size[abi:ne180100]<std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>*,std::tuple<Phase::Affine<float>,Phase::Handle64,Phase::Handle64,Phase::Geometry::Shape *>*>((_QWORD *)(v16 - 48), v18, v19, 0x6DB6DB6DB6DB6DB7 * ((v19 - v18) >> 3));
        *(_OWORD *)(v16 - 24) = *(_OWORD *)(v6 - 24);
        *(_BYTE *)(v16 - 8) = *(_BYTE *)(v6 - 8);
        v16 = *((_QWORD *)&v31 + 1) - 48;
        *((_QWORD *)&v31 + 1) -= 48;
        v6 = v17;
      }
      while (v17 != v9);
    }
    v29 = 1;
    std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::Geometry::MpsCpuSceneDescriptor>,std::reverse_iterator<Phase::Geometry::MpsCpuSceneDescriptor*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v28);
    v20 = a1[2];
    v21 = *(_OWORD *)&v26[8];
    v24 = *(_QWORD *)&v26[8];
    v22 = *(_OWORD *)a1;
    *a1 = v16;
    *(_OWORD *)v26 = v22;
    *(_OWORD *)(a1 + 1) = v21;
    *(_QWORD *)&v26[16] = v20;
    v25 = (char *)v22;
    std::__split_buffer<Phase::Geometry::MpsCpuSceneDescriptor>::~__split_buffer((uint64_t)&v25);
    v8 = v24;
  }
  else
  {
    v7 = *a2;
    *(_QWORD *)v6 = 0;
    *(_QWORD *)(v6 + 8) = 0;
    *(_QWORD *)(v6 + 16) = 0;
    *(_OWORD *)(v6 + 24) = v7;
    *(_BYTE *)(v6 + 40) = 0;
    v8 = v6 + 48;
    a1[1] = v6 + 48;
  }
  a1[1] = v8;
  return v8 - 48;
}

void sub_2165C34F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::Geometry::MpsCpuSceneDescriptor>,std::reverse_iterator<Phase::Geometry::MpsCpuSceneDescriptor*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)va1);
  std::__split_buffer<Phase::Geometry::MpsCpuSceneDescriptor>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *Phase::Geometry::GetMpsCpuScenePtr(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  char v6;
  char v7;
  uint64_t v9;
  uint64_t v10;

  v9 = a2;
  v10 = a3;
  v3 = *a1;
  v4 = a1[1];
  while (v3 != v4)
  {
    v5 = *v3;
    v6 = std::__equal_aligned[abi:ne180100]<std::__bitset<1ul,32ul>,true,true>((_QWORD *)(*v3 + 32), 0, *v3 + 32, 0x20u, &v9);
    if (*(unsigned __int8 *)(v5 + 40) == v10)
      v7 = v6;
    else
      v7 = 0;
    if ((v7 & 1) != 0)
      return v3;
    v3 += 2;
  }
  return 0;
}

void std::vector<MPSCPUAccelerationStructureTriangleGeometryDescriptor * {__strong}>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (void *)*((_QWORD *)v4 - 1);
        v4 -= 8;

      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__split_buffer<MPSCPUAccelerationStructureTriangleGeometryDescriptor * {__strong}>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;

  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

float Phase::Matrix33From<float>@<S0>(float *a1@<X0>, float *a2@<X8>)
{
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float result;

  v2 = a1[1];
  v3 = *a1 * *a1;
  v4 = v2 * v2;
  v5 = a1[2];
  v6 = a1[3];
  v7 = v5 * v5;
  v8 = *a1 * v5;
  v9 = *a1 * v2;
  v10 = v2 * v5;
  v11 = *a1 * v6;
  v12 = v2 * v6;
  v13 = v5 * v6;
  *a2 = (float)((float)(v4 + v7) * -2.0) + 1.0;
  a2[1] = (float)(v9 + v13) + (float)(v9 + v13);
  a2[2] = (float)(v8 - v12) + (float)(v8 - v12);
  a2[3] = (float)(v9 - v13) + (float)(v9 - v13);
  a2[4] = (float)((float)(v3 + v7) * -2.0) + 1.0;
  a2[5] = (float)(v10 + v11) + (float)(v10 + v11);
  a2[6] = (float)(v8 + v12) + (float)(v8 + v12);
  a2[7] = (float)(v10 - v11) + (float)(v10 - v11);
  result = (float)((float)(v3 + v4) * -2.0) + 1.0;
  a2[8] = result;
  return result;
}

uint64_t Phase::Geometry::GetMpsIntersections(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t *v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  void *v18;
  unint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  id *v24;
  id v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _DWORD *v33;
  unsigned int v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t *v42;
  uint64_t v43;
  _DWORD v44[1281];
  uint64_t v45;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v43 = v6;
  v45 = *MEMORY[0x24BDAC8D0];
  v7 = (v5 - v4);
  if ((int)v7 < 1)
    return 0;
  v8 = (_QWORD *)v1;
  v10 = *(uint64_t **)v1;
  v9 = *(uint64_t **)(v1 + 8);
  if (v9 == *(uint64_t **)v1)
    return 0;
  v11 = v5;
  v12 = v4;
  v13 = v3;
  v14 = v2;
  v15 = *(unsigned int *)(v2 + 72);
  if ((v15 & *(_QWORD *)(*v10 + 32)) == 0)
  {
    v16 = v10 + 2;
    while (v16 != v9)
    {
      v17 = *v16;
      v16 += 2;
      if ((*(_QWORD *)(v17 + 32) & v15) != 0)
      {
        v10 = v16 - 2;
        goto LABEL_8;
      }
    }
    return 0;
  }
LABEL_8:
  v18 = (void *)objc_opt_new();
  objc_msgSend(v18, "setRayDataType:", 1);
  objc_msgSend(v18, "setRayStride:", *(unsigned int *)(v14 + 100));
  objc_msgSend(v18, "setIntersectionDataType:", 5);
  objc_msgSend(v18, "setIntersectionStride:", *(unsigned int *)(v14 + 100));
  objc_msgSend(v18, "getIntersectionsOfType:rays:intersections:rayCount:accelerationStructure:", 0, v13, v43, v7, *(_QWORD *)*v10);
  v19 = ((unint64_t)v10 - *v8) >> 4;
  v20 = v10 + 2;
  do
  {
    if (v20 == (uint64_t *)v8[1])
    {
      v35 = 1;
      goto LABEL_37;
    }
    v21 = *v20;
    v20 += 2;
  }
  while ((*(unsigned int *)(v14 + 72) & *(_QWORD *)(v21 + 32)) == 0);
  objc_msgSend(v18, "setIntersectionStride:", 12);
  v22 = *(unsigned int *)(v14 + 100);
  if ((_DWORD)v22)
  {
    v23 = v43;
    do
    {
      *(_DWORD *)(v23 + 12) = v19;
      v23 += v22;
    }
    while (v23 < v43 + v22 * (unint64_t)v7);
  }
  v40 = v12;
  v42 = v20 - 2;
  v39 = v12;
  v24 = (id *)*(v20 - 2);
  v41 = 1;
LABEL_15:
  v25 = *v24;
  if (v11 > v12)
  {
    v26 = ((unint64_t)v42 - *v8) >> 4;
    v27 = v39;
    do
    {
      v28 = v27 + 427;
      if ((int)v27 + 427 >= v11)
        v29 = v11;
      else
        v29 = v27 + 427;
      v30 = v29 - v27;
      objc_msgSend(v18, "getIntersectionsOfType:rays:intersections:rayCount:accelerationStructure:", 0, v13 + 32 * v27, v44, v30, v25, v39);
      if (v30 >= 1)
      {
        v31 = *(unsigned int *)(v14 + 100);
        v32 = v43 + 16 * v27;
        v33 = v44;
        do
        {
          if (*(float *)v33 >= 0.0 && (*(float *)v32 < 0.0 || *(float *)v33 < *(float *)v32))
          {
            *(_QWORD *)v32 = *(_QWORD *)v33;
            *(_DWORD *)(v32 + 8) = v33[2];
            *(_DWORD *)(v32 + 12) = v26;
          }
          v32 += v31;
          v33 += 3;
        }
        while (v33 < &v44[3 * v30]);
      }
      v27 += 427;
    }
    while (v28 < v11);
  }

  v35 = v41 + 1;
  v36 = v42 + 2;
  v12 = v40;
  while (v36 != (uint64_t *)v8[1])
  {
    v37 = *v36;
    v36 += 2;
    v24 = (id *)v37;
    if ((*(unsigned int *)(v14 + 72) & *(_QWORD *)(v37 + 32)) != 0)
    {
      ++v41;
      v42 = v36 - 2;
      goto LABEL_15;
    }
  }
LABEL_37:

  return v35;
}

void sub_2165C39CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::Geometry::MpsCpuSceneDescriptor>,std::reverse_iterator<Phase::Geometry::MpsCpuSceneDescriptor*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  uint64_t v3;
  uint64_t i;
  void *v5;

  if (!*(_BYTE *)(a1 + 24))
  {
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
    for (i = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8); i != v3; i += 48)
    {
      v5 = *(void **)i;
      if (*(_QWORD *)i)
      {
        *(_QWORD *)(i + 8) = v5;
        operator delete(v5);
      }
    }
  }
  return a1;
}

uint64_t std::__split_buffer<Phase::Geometry::MpsCpuSceneDescriptor>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    v4 = *(void **)(v2 - 48);
    *(_QWORD *)(a1 + 16) = v2 - 48;
    if (v4)
    {
      *(_QWORD *)(v2 - 40) = v4;
      operator delete(v4);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 48;
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t (*Phase::GetTypeId<Phase::Geometry::MpsMesh>())()
{
  return Phase::GetTypeId<Phase::Geometry::MpsMesh>;
}

uint64_t Phase::Geometry::CreateMpsMesh@<X0>(_QWORD *a1@<X8>)
{
  char *v2;

  v2 = (char *)operator new(0xC0uLL);
  *((_QWORD *)v2 + 1) = 0;
  *((_QWORD *)v2 + 2) = 0;
  *(_QWORD *)v2 = &off_24D57D128;
  *((_OWORD *)v2 + 2) = xmmword_2166F8310;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *(_OWORD *)(v2 + 76) = 0u;
  *((_OWORD *)v2 + 6) = 0u;
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  *((_OWORD *)v2 + 9) = 0u;
  *((_OWORD *)v2 + 10) = 0u;
  *((_OWORD *)v2 + 11) = xmmword_2166F8320;
  a1[1] = v2;
  *((_DWORD *)v2 + 6) = 3;
  v2 += 24;
  *a1 = v2;
  return Phase::Geometry::AddMpsMesh(v2);
}

void sub_2165C3B34(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::AddMpsMesh(_QWORD *a1)
{
  _QWORD *v2;
  unint64_t v3;
  unint64_t v4;
  char *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v21[2];
  _QWORD v22[3];
  _QWORD *v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v2 = a1 + 12;
  v3 = a1[13] - a1[12];
  std::vector<std::shared_ptr<Phase::Geometry::SharedDataStream>>::resize((uint64_t)(a1 + 12), 7uLL);
  if (v3 <= 0x6F)
  {
    v4 = v3 >> 4;
    do
    {
      v5 = (char *)operator new(0x40uLL);
      *((_QWORD *)v5 + 1) = 0;
      *((_QWORD *)v5 + 2) = 0;
      *(_QWORD *)v5 = &off_24D57D048;
      *(_OWORD *)(v5 + 40) = 0u;
      *((_QWORD *)v5 + 7) = 0;
      *(_OWORD *)(v5 + 24) = 0u;
      *(_QWORD *)&v21[0] = v5 + 24;
      *((_QWORD *)&v21[0] + 1) = v5;
      std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100](*v2 + 16 * v4, v21);
      v6 = (std::__shared_weak_count *)*((_QWORD *)&v21[0] + 1);
      if (*((_QWORD *)&v21[0] + 1))
      {
        v7 = (unint64_t *)(*((_QWORD *)&v21[0] + 1) + 8);
        do
          v8 = __ldaxr(v7);
        while (__stlxr(v8 - 1, v7));
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
      ++v4;
    }
    while (v4 != 7);
  }
  v9 = operator new();
  *(_QWORD *)v9 = Phase::GetTypeId<Phase::Geometry::MpsMesh>;
  *(_QWORD *)(v9 + 8) = a1;
  *(_QWORD *)(v9 + 16) = 0;
  *(_QWORD *)(v9 + 24) = -1;
  *(_QWORD *)(v9 + 32) = 0;
  *(_QWORD *)(v9 + 40) = -1;
  *(_QWORD *)(v9 + 48) = 0;
  *(_QWORD *)(v9 + 56) = -1;
  *(_QWORD *)(v9 + 64) = 0;
  *(_QWORD *)(v9 + 72) = -1;
  *(_QWORD *)(v9 + 80) = 0;
  *(_QWORD *)(v9 + 88) = -1;
  *(_QWORD *)(v9 + 96) = 0;
  *(_QWORD *)(v9 + 104) = -1;
  *(_OWORD *)(v9 + 112) = xmmword_2166F7280;
  *(_OWORD *)(v9 + 128) = xmmword_2166F8480;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(a1 + 15, 1uLL);
  v22[0] = &off_24D57D2D0;
  v23 = v22;
  *(_QWORD *)&v21[0] = v9;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v21 + 8, (uint64_t)v22);
  v10 = v23;
  if (v23 == v22)
  {
    v11 = 4;
    v10 = v22;
    goto LABEL_13;
  }
  if (v23)
  {
    v11 = 5;
LABEL_13:
    (*(void (**)(void))(*v10 + 8 * v11))();
  }
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)a1[15], (uint64_t *)v21);
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v21);
  a1[18] = v2;
  a1[19] = 0;
  v12 = (uint64_t *)a1[12];
  v13 = *v12;
  *(_DWORD *)v13 = 1;
  *(_QWORD *)(v13 + 16) = 8;
  *(_QWORD *)(v13 + 32) = 8;
  *(_QWORD *)(v9 + 16) = v2;
  *(_QWORD *)(v9 + 24) = 1;
  v14 = v12[2];
  *(_DWORD *)v14 = 11;
  *(_QWORD *)(v14 + 16) = 16;
  *(_QWORD *)(v14 + 32) = 16;
  *(_QWORD *)(v9 + 32) = v2;
  *(_QWORD *)(v9 + 40) = 2;
  v15 = v12[4];
  *(_DWORD *)v15 = 12;
  *(_QWORD *)(v15 + 16) = 4;
  *(_QWORD *)(v15 + 32) = 4;
  *(_QWORD *)(v9 + 48) = v2;
  *(_QWORD *)(v9 + 56) = 3;
  v16 = v12[6];
  *(_DWORD *)v16 = 13;
  *(_QWORD *)(v16 + 16) = 4;
  *(_QWORD *)(v16 + 32) = 12;
  *(_QWORD *)(v9 + 64) = v2;
  *(_QWORD *)(v9 + 72) = 4;
  v17 = v12[8];
  *(_DWORD *)v17 = 14;
  *(_QWORD *)(v17 + 16) = 2;
  *(_QWORD *)(v17 + 32) = 2;
  *(_QWORD *)(v9 + 80) = v2;
  *(_QWORD *)(v9 + 88) = 5;
  v18 = v12[10];
  *(_DWORD *)v18 = 15;
  *(_QWORD *)(v18 + 16) = 8;
  *(_QWORD *)(v18 + 32) = 64;
  *(_QWORD *)(v9 + 96) = v2;
  *(_QWORD *)(v9 + 104) = 6;
  v19 = v12[12];
  *(_DWORD *)v19 = 16;
  *(_QWORD *)(v19 + 16) = 16;
  *(_QWORD *)(v19 + 32) = 16;
  return v9;
}

id **Phase::Geometry::CreateMpsMeshFromMdlMesh@<X0>(const Phase::MdlMeshAsset *a1@<X1>, _QWORD *a2@<X2>, uint64_t *a3@<X8>)
{
  unint64_t SubmeshCount;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  Phase::Logger *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  std::vector<unsigned int>::pointer begin;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  uint64_t v23;
  std::align_val_t v24;
  std::vector<unsigned int>::pointer v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  unint64_t v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t i;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  float v45;
  uint64_t v46;
  int Vertex;
  int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  float *v63;
  uint64_t v64;
  unint64_t v65;
  float *v66;
  float *v67;
  unint64_t v68;
  float *v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  char *v74;
  float *v75;
  int v76;
  float v77;
  float v78;
  float32x2_t v79;
  std::vector<unsigned int>::size_type v80;
  uint64_t v81;
  uint64_t v82;
  unsigned int *v83;
  int *v84;
  uint64_t v85;
  uint64_t v86;
  std::vector<unsigned int>::pointer end;
  unsigned int v88;
  unsigned int *v89;
  unint64_t v90;
  unint64_t j;
  unint64_t v92;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unsigned int *v97;
  uint64_t v98;
  unsigned int v99;
  Phase::Logger *Name;
  unsigned int *v101;
  NSObject *v102;
  uint64_t **v103;
  id **v105;
  _QWORD *v106;
  uint64_t *v107;
  int v108;
  uint64_t v109;
  void **v110;
  unint64_t v111;
  id *v112;
  id *v113;
  uint64_t v114;
  std::vector<unsigned int>::value_type __x[6];
  std::vector<unsigned int> buf[2];
  uint64_t v117;

  v117 = *MEMORY[0x24BDAC8D0];
  Phase::Geometry::MdlMeshReader::MdlMeshReader((Phase::MdlMeshAsset *)&v112, a1);
  SubmeshCount = Phase::MdlMeshAsset::GetSubmeshCount(&v112);
  if (!SubmeshCount)
    goto LABEL_108;
  v7 = (char *)operator new(0xC0uLL);
  *((_QWORD *)v7 + 1) = 0;
  *((_QWORD *)v7 + 2) = 0;
  *(_QWORD *)v7 = &off_24D57D128;
  *((_DWORD *)v7 + 6) = 3;
  *((_OWORD *)v7 + 6) = 0u;
  v110 = (void **)(v7 + 96);
  *((_OWORD *)v7 + 2) = xmmword_2166F8310;
  *((_OWORD *)v7 + 3) = 0u;
  *((_OWORD *)v7 + 4) = 0u;
  *(_OWORD *)(v7 + 76) = 0u;
  *((_OWORD *)v7 + 7) = 0u;
  *((_OWORD *)v7 + 8) = 0u;
  *((_OWORD *)v7 + 9) = 0u;
  *((_OWORD *)v7 + 10) = 0u;
  *((_OWORD *)v7 + 11) = xmmword_2166F8320;
  *a3 = (uint64_t)(v7 + 24);
  a3[1] = (uint64_t)v7;
  v109 = (uint64_t)(v7 + 24);
  v8 = Phase::Geometry::AddMpsMesh((_QWORD *)v7 + 3);
  v105 = (id **)a1;
  v9 = objc_msgSend(*v113, "vertexCount");
  v10 = 0;
  v11 = 0;
  do
  {
    v12 = objc_msgSend(Phase::MdlMeshAsset::GetSubmesh(&v112, v10), "indexCount");
    if (0xAAAAAAAAAAAAAAABLL * v12 >= 0x5555555555555556)
      goto LABEL_108;
    v11 += v12;
    ++v10;
  }
  while (SubmeshCount != v10);
  v108 = v11 / 3;
  *((_QWORD *)v7 + 23) = v11 / 3;
  _ZN5Phase8Geometry19DataStreamReferenceIDv3_fE6ResizeEm(**(_QWORD **)(v8 + 16), *(_QWORD *)(v8 + 24), v9);
  Phase::Geometry::DataStreamReference<int>::Resize(**(_QWORD **)(v8 + 32), *(_QWORD *)(v8 + 40), v11);
  v13 = (Phase::Logger *)Phase::Geometry::DataStreamReference<Phase::Vector<float,3ul>>::Resize(v8 + 48, v11 / 3);
  v14 = *(_QWORD *)(**(_QWORD **)(v8 + 64) + 16 * *(_QWORD *)(v8 + 72));
  v15 = *(_QWORD *)(v14 + 24);
  if (v15 == v11 / 3)
  {
    if ((v11 + 2) < 5)
      goto LABEL_18;
    v16 = 0;
    v17 = v108;
    goto LABEL_15;
  }
  v16 = *(_QWORD *)(v14 + 8);
  *(_QWORD *)(v14 + 8) = 0;
  if ((v11 + 2) >= 5)
  {
    Phase::Geometry::DataStream::Alloc(*(std::align_val_t *)(v14 + 16), *(_QWORD *)(v14 + 32) * v108, buf);
    begin = buf[0].__begin_;
    buf[0].__begin_ = 0;
    v13 = *(Phase::Logger **)(v14 + 8);
    *(_QWORD *)(v14 + 8) = begin;
    if (v13)
    {
      MEMORY[0x2199F9D4C](v13, 0x1000C8077774924);
      v13 = (Phase::Logger *)buf[0].__begin_;
      buf[0].__begin_ = 0;
      if (v13)
        v13 = (Phase::Logger *)MEMORY[0x2199F9D4C](v13, 0x1000C8077774924);
    }
  }
  v17 = v108;
  *(_QWORD *)(v14 + 24) = v108;
  if (v15 < v108)
    v17 = v15;
  if (v17)
  {
LABEL_15:
    v19 = 0;
    v20 = *(_QWORD *)(v14 + 8);
    do
    {
      *(_WORD *)(v20 + 2 * v19) = *(_WORD *)(v16 + 2 * v19);
      ++v19;
    }
    while (v17 != v19);
    goto LABEL_17;
  }
  if (v16)
LABEL_17:
    v13 = (Phase::Logger *)MEMORY[0x2199F9D4C](v16, 0x1000C8077774924);
LABEL_18:
  v21 = *(_QWORD **)(**(_QWORD **)(v8 + 80) + 16 * *(_QWORD *)(v8 + 88));
  v22 = v21[3];
  if (v22 == SubmeshCount)
  {
    v23 = 0;
  }
  else
  {
    v23 = v21[1];
    v24 = v21[2];
    v21[1] = 0;
    Phase::Geometry::DataStream::Alloc(v24, v21[4] * SubmeshCount, buf);
    v25 = buf[0].__begin_;
    buf[0].__begin_ = 0;
    v13 = (Phase::Logger *)v21[1];
    v21[1] = v25;
    if (v13)
    {
      MEMORY[0x2199F9D4C](v13, 0x1000C8077774924);
      v13 = (Phase::Logger *)buf[0].__begin_;
      buf[0].__begin_ = 0;
      if (v13)
        v13 = (Phase::Logger *)MEMORY[0x2199F9D4C](v13, 0x1000C8077774924);
    }
    v21[3] = SubmeshCount;
  }
  if (v22 >= SubmeshCount)
    v26 = SubmeshCount;
  else
    v26 = v22;
  if (v26)
  {
    v27 = v23 + 12;
    v28 = v21[1] + 12;
    v29 = v26;
    do
    {
      *(_DWORD *)(v28 - 12) = *(_DWORD *)(v27 - 12);
      *(_DWORD *)(v28 - 8) = *(_DWORD *)(v27 - 8);
      *(_DWORD *)(v28 - 4) = *(_DWORD *)(v27 - 4);
      *(_DWORD *)v28 = *(_DWORD *)v27;
      *(_DWORD *)(v28 + 4) = *(_DWORD *)(v27 + 4);
      *(_DWORD *)(v28 + 8) = *(_DWORD *)(v27 + 8);
      v30 = *(_OWORD *)(v27 + 12);
      v31 = *(_OWORD *)(v27 + 28);
      *(_DWORD *)(v28 + 44) = *(_DWORD *)(v27 + 44);
      *(_OWORD *)(v28 + 28) = v31;
      *(_OWORD *)(v28 + 12) = v30;
      v27 += 64;
      v28 += 64;
      --v29;
    }
    while (v29);
  }
  if (v22 < SubmeshCount)
  {
    do
    {
      v32 = *(_QWORD *)(**(_QWORD **)(v8 + 80) + 16 * *(_QWORD *)(v8 + 88));
      v33 = *(_QWORD *)(v32 + 8) + *(_QWORD *)(v32 + 32) * v26;
      *(_QWORD *)(v33 + 48) = 0;
      *(_OWORD *)(v33 + 16) = 0uLL;
      *(_OWORD *)(v33 + 32) = 0uLL;
      *(_OWORD *)v33 = 0uLL;
      *(_DWORD *)(v33 + 56) = -1;
      ++v26;
    }
    while (SubmeshCount != v26);
  }
  if (v23)
    v13 = (Phase::Logger *)MEMORY[0x2199F9D4C](v23, 0x1000C8077774924);
  v34 = **(NSObject ***)(Phase::Logger::GetInstancePtr(v13) + 1184);
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf[0].__begin_) = 136315906;
    *(std::vector<unsigned int>::pointer *)((char *)&buf[0].__begin_ + 4) = (std::vector<unsigned int>::pointer)"GeoMpsMesh.cpp";
    WORD2(buf[0].__end_) = 1024;
    *(_DWORD *)((char *)&buf[0].__end_ + 6) = 310;
    WORD1(buf[0].__end_cap_.__value_) = 1024;
    HIDWORD(buf[0].__end_cap_.__value_) = v108;
    LOWORD(buf[1].__begin_) = 2048;
    *(std::vector<unsigned int>::pointer *)((char *)&buf[1].__begin_ + 2) = (std::vector<unsigned int>::pointer)SubmeshCount;
    _os_log_impl(&dword_2164CC000, v34, OS_LOG_TYPE_DEFAULT, "%25s:%-5d MPS mesh added containing %i triangles and %lu submeshes", (uint8_t *)buf, 0x22u);
  }
  _ZN5Phase8Geometry19DataStreamReferenceIDv3_fE6ResizeEm(**(_QWORD **)(v8 + 96), *(_QWORD *)(v8 + 104), v9);
  if (v9)
  {
    v35 = 0;
    for (i = 0; i != v9; ++i)
    {
      v37 = *(_QWORD *)(**(_QWORD **)(v8 + 16) + 16 * *(_QWORD *)(v8 + 24));
      *(_OWORD *)(*(_QWORD *)(v37 + 8) + *(_QWORD *)(v37 + 32) * i) = *(_OWORD *)(v114 + v35);
      v35 += 24;
    }
  }
  *((_OWORD *)v7 + 3) = xmmword_2166F8300;
  *((_QWORD *)v7 + 8) = 0x80000000800000;
  Phase::Geometry::InitMaterials(v109, SubmeshCount, 0);
  v38 = Phase::MdlMeshAsset::GetSubmeshCount(&v112);
  *((_DWORD *)v7 + 22) = 0;
  *((_QWORD *)v7 + 13) = *((_QWORD *)v7 + 12);
  std::vector<float>::reserve(v110, v38);
  v106 = a2;
  v107 = a3;
  if (v38)
  {
    v39 = 0;
    v40 = 0;
    v111 = v38;
    while (1)
    {
      v41 = *(_QWORD *)(**(_QWORD **)(v8 + 80) + 16 * *(_QWORD *)(v8 + 88));
      v42 = *(_QWORD *)(v41 + 8) + *(_QWORD *)(v41 + 32) * v39;
      *(_DWORD *)(v42 + 56) = v39;
      v43 = objc_msgSend(Phase::MdlMeshAsset::GetSubmesh(&v112, v39), "indexCount");
      v44 = v43 / 3;
      if (v43 != 3 * (v43 / 3))
        break;
      *(_QWORD *)(v42 + 24) = 3 * v40;
      *(_QWORD *)(v42 + 40) = v40;
      *(_OWORD *)v42 = xmmword_2166F8300;
      *(_QWORD *)(v42 + 16) = 0x80000000800000;
      v45 = 0.0;
      if (v43 >= 3)
      {
        v46 = 0;
        do
        {
          memset(buf, 0, 36);
          Vertex = Phase::Geometry::MdlMeshReader::GetVertexIndex<unsigned int>(&v112, v39, v46);
          v48 = Phase::Geometry::MdlMeshReader::GetVertexIndex<unsigned int>(&v112, v39, v46 + 1);
          v49 = Phase::Geometry::MdlMeshReader::GetVertexIndex<unsigned int>(&v112, v39, v46 + 2);
          v50 = v114 + 24 * Vertex;
          buf[0].__begin_ = *(std::vector<unsigned int>::pointer *)v50;
          LODWORD(buf[0].__end_) = *(_DWORD *)(v50 + 8);
          v51 = v114 + 24 * v48;
          HIDWORD(buf[0].__end_) = *(_DWORD *)v51;
          buf[0].__end_cap_.__value_ = *(unsigned int **)(v51 + 4);
          v52 = v114 + 24 * v49;
          buf[1].__begin_ = *(std::vector<unsigned int>::pointer *)v52;
          LODWORD(buf[1].__end_) = *(_DWORD *)(v52 + 8);
          v53 = (float)((float)(*(float *)&buf[0].__end_cap_.__value_ - *((float *)&buf[0].__begin_ + 1))
                      * (float)(*(float *)&buf[1].__end_ - *(float *)&buf[0].__end_))
              - (float)((float)(*((float *)&buf[0].__end_cap_.__value_ + 1) - *(float *)&buf[0].__end_)
                      * (float)(*((float *)&buf[1].__begin_ + 1) - *((float *)&buf[0].__begin_ + 1)));
          v54 = (float)((float)(*((float *)&buf[0].__end_cap_.__value_ + 1) - *(float *)&buf[0].__end_)
                      * (float)(*(float *)&buf[1].__begin_ - *(float *)&buf[0].__begin_))
              - (float)((float)(*((float *)&buf[0].__end_ + 1) - *(float *)&buf[0].__begin_)
                      * (float)(*(float *)&buf[1].__end_ - *(float *)&buf[0].__end_));
          v55 = (float)((float)(*((float *)&buf[0].__end_ + 1) - *(float *)&buf[0].__begin_)
                      * (float)(*((float *)&buf[1].__begin_ + 1) - *((float *)&buf[0].__begin_ + 1)))
              - (float)((float)(*(float *)&buf[0].__end_cap_.__value_ - *((float *)&buf[0].__begin_ + 1))
                      * (float)(*(float *)&buf[1].__begin_ - *(float *)&buf[0].__begin_));
          v56 = sqrtf((float)(v55 * v55) + (float)((float)(v53 * v53) + (float)(v54 * v54)));
          v57 = v56 * 0.5;
          if ((float)(v56 * 0.5) > 0.00000011921)
          {
            v58 = *(_QWORD *)(**(_QWORD **)(v8 + 32) + 16 * *(_QWORD *)(v8 + 40));
            v59 = *(_QWORD *)(v58 + 8);
            v60 = *(_QWORD *)(v58 + 32);
            v61 = v60 * 3 * v40;
            *(_DWORD *)(v59 + v61) = Vertex;
            *(_DWORD *)(v59 + v60 + v61) = v48;
            *(_DWORD *)(v59 + v60 * (3 * v40 + 2)) = v49;
            v62 = *(_QWORD *)(**(_QWORD **)(v8 + 48) + 16 * *(_QWORD *)(v8 + 56));
            v63 = (float *)(*(_QWORD *)(v62 + 8) + *(_QWORD *)(v62 + 32) * v40);
            *v63 = v53 / v56;
            v63[1] = v54 / v56;
            v63[2] = v55 / v56;
            v64 = *(_QWORD *)(**(_QWORD **)(v8 + 64) + 16 * *(_QWORD *)(v8 + 72));
            *(_WORD *)(*(_QWORD *)(v64 + 8) + *(_QWORD *)(v64 + 32) * v40) = v39;
            Phase::Enclose<float>((float *)v42, (float *)buf, (float *)__x);
            v45 = v45 + v57;
            ++v40;
            *(_DWORD *)v42 = __x[0];
            *(_DWORD *)(v42 + 4) = __x[1];
            *(_DWORD *)(v42 + 8) = __x[2];
            *(_DWORD *)(v42 + 12) = __x[3];
            *(_DWORD *)(v42 + 16) = __x[4];
            *(_DWORD *)(v42 + 20) = __x[5];
          }
          v46 += 3;
          --v44;
        }
        while (v44);
      }
      v66 = (float *)*((_QWORD *)v7 + 13);
      v65 = *((_QWORD *)v7 + 14);
      if ((unint64_t)v66 >= v65)
      {
        v68 = v111;
        v69 = (float *)*v110;
        v70 = ((char *)v66 - (_BYTE *)*v110) >> 2;
        v71 = v70 + 1;
        if ((unint64_t)(v70 + 1) >> 62)
          std::vector<float>::__throw_length_error[abi:ne180100]();
        v72 = v65 - (_QWORD)v69;
        if (v72 >> 1 > v71)
          v71 = v72 >> 1;
        if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFFCLL)
          v73 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v73 = v71;
        if (v73)
        {
          v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(v7 + 112), v73);
          v69 = (float *)*((_QWORD *)v7 + 12);
          v66 = (float *)*((_QWORD *)v7 + 13);
        }
        else
        {
          v74 = 0;
        }
        v75 = (float *)&v74[4 * v70];
        *v75 = v45;
        v67 = v75 + 1;
        while (v66 != v69)
        {
          v76 = *((_DWORD *)v66-- - 1);
          *((_DWORD *)v75-- - 1) = v76;
        }
        *((_QWORD *)v7 + 12) = v75;
        *((_QWORD *)v7 + 13) = v67;
        *((_QWORD *)v7 + 14) = &v74[4 * v73];
        if (v69)
          operator delete(v69);
      }
      else
      {
        *v66 = v45;
        v67 = v66 + 1;
        v68 = v111;
      }
      *((_QWORD *)v7 + 13) = v67;
      *((float *)v7 + 22) = v45 + *((float *)v7 + 22);
      *(_QWORD *)(v42 + 32) = 3 * v40 - *(_QWORD *)(v42 + 24);
      *(_QWORD *)(v42 + 48) = v40 - *(_QWORD *)(v42 + 40);
      v77 = fminf(*((float *)v7 + 14), *(float *)(v42 + 8));
      v78 = fmaxf(*((float *)v7 + 17), *(float *)(v42 + 20));
      v79 = vmaxnm_f32(*(float32x2_t *)(v7 + 60), *(float32x2_t *)(v42 + 12));
      *((float32x2_t *)v7 + 6) = vminnm_f32(*(float32x2_t *)(v7 + 48), *(float32x2_t *)v42);
      *((float *)v7 + 14) = v77;
      *(float32x2_t *)(v7 + 60) = v79;
      *((float *)v7 + 17) = v78;
      if (++v39 == v68)
        goto LABEL_66;
    }
LABEL_108:
    std::terminate();
  }
  v40 = 0;
LABEL_66:
  if (v40 != v108)
  {
    Phase::Geometry::DataStreamReference<int>::Resize(**(_QWORD **)(v8 + 32), *(_QWORD *)(v8 + 40), 3 * v40);
    Phase::Geometry::DataStreamReference<Phase::Vector<float,3ul>>::Resize(v8 + 48, v40);
    v80 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v8 + 16) + 16 * *(_QWORD *)(v8 + 24)) + 24);
    __x[0] = -1;
    std::vector<unsigned int>::vector(buf, v80, __x);
    v81 = *(_QWORD *)(**(_QWORD **)(v8 + 32) + 16 * *(_QWORD *)(v8 + 40));
    v82 = *(_QWORD *)(v81 + 24);
    v83 = buf[0].__begin_;
    if (v82)
    {
      v84 = *(int **)(v81 + 8);
      v85 = 4 * v82;
      do
      {
        v86 = *v84++;
        v83[v86] = 0;
        v85 -= 4;
      }
      while (v85);
    }
    end = buf[0].__end_;
    if (v83 == buf[0].__end_)
    {
      v88 = 0;
    }
    else
    {
      v88 = 0;
      v89 = v83;
      do
      {
        if (*v89 != -1)
          *v89 = v88++;
        ++v89;
      }
      while (v89 != end);
    }
    if (v80 != v88)
    {
      v90 = v88;
      if (v80)
      {
        for (j = 0; v80 != j; ++j)
        {
          v92 = buf[0].__begin_[j];
          if ((_DWORD)v92 != -1)
          {
            if (v92 >= v90 || j < v92)
              goto LABEL_108;
            v94 = *(_QWORD *)(**(_QWORD **)(v8 + 16) + 16 * *(_QWORD *)(v8 + 24));
            *(_OWORD *)(*(_QWORD *)(v94 + 8) + *(_QWORD *)(v94 + 32) * v92) = *(_OWORD *)(*(_QWORD *)(v94 + 8)
                                                                                        + *(_QWORD *)(v94 + 32) * j);
          }
        }
      }
      _ZN5Phase8Geometry19DataStreamReferenceIDv3_fE6ResizeEm(**(_QWORD **)(v8 + 16), *(_QWORD *)(v8 + 24), v90);
      v95 = *(_QWORD *)(**(_QWORD **)(v8 + 32) + 16 * *(_QWORD *)(v8 + 40));
      v96 = *(_QWORD *)(v95 + 24);
      v83 = buf[0].__begin_;
      if (v96)
      {
        v97 = *(unsigned int **)(v95 + 8);
        v98 = 4 * v96;
        while (1)
        {
          v99 = v83[*v97];
          if (v99 >= v90)
            goto LABEL_108;
          *v97++ = v99;
          v98 -= 4;
          if (!v98)
            goto LABEL_96;
        }
      }
    }
    if (v83)
    {
LABEL_96:
      buf[0].__end_ = v83;
      operator delete(v83);
    }
    Name = (Phase::Logger *)Phase::MdlMeshAsset::GetName(v105);
    if (Name)
      v101 = (unsigned int *)Name;
    else
      v101 = (unsigned int *)"";
    v102 = **(NSObject ***)(Phase::Logger::GetInstancePtr(Name) + 416);
    if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf[0].__begin_) = 136315906;
      *(std::vector<unsigned int>::pointer *)((char *)&buf[0].__begin_ + 4) = (std::vector<unsigned int>::pointer)"GeoMpsMesh.cpp";
      WORD2(buf[0].__end_) = 1024;
      *(_DWORD *)((char *)&buf[0].__end_ + 6) = 348;
      WORD1(buf[0].__end_cap_.__value_) = 1024;
      HIDWORD(buf[0].__end_cap_.__value_) = v108 - v40;
      LOWORD(buf[1].__begin_) = 2080;
      *(std::vector<unsigned int>::pointer *)((char *)&buf[1].__begin_ + 2) = v101;
      _os_log_impl(&dword_2164CC000, v102, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: [%i] degenerate triangles ignored while creating a Geometry::MpsMesh Shape from MDLMesh:[%s]", (uint8_t *)buf, 0x22u);
    }
    v109 = *v107;
    *(_QWORD *)(*v107 + 160) -= v108 - (int)v40;
  }
  Phase::Geometry::SetMaterialsFromOptionalMaterialList((uint64_t **)v109, v106);
  if (v106)
  {
    v103 = Phase::UnorderedStringMap<Phase::OptionsValue>::Find(v106, (__int128 *)&Phase::Geometry::ShapeOptions::SceneQueryFilter);
    if (v103)
    {
      if (*((_DWORD *)v103 + 24) == 2)
        *(_QWORD *)(v109 + 16) = *((unsigned int *)v103 + 14);
    }
  }
  return std::unique_ptr<Phase::details::MdlMeshAssetImplementation>::reset[abi:ne180100](&v113, 0);
}

void sub_2165C4968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30)
{
  if (__p)
  {
    a30 = (uint64_t)__p;
    operator delete(__p);
  }
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](a13);
  std::unique_ptr<Phase::details::MdlMeshAssetImplementation>::reset[abi:ne180100]((id **)&a24, 0);
  _Unwind_Resume(a1);
}

uint64_t _ZN5Phase8Geometry19DataStreamReferenceIDv3_fE6ResizeEm(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = a3;
  v4 = *(_QWORD *)(result + 16 * a2);
  v5 = *(_QWORD *)(v4 + 24);
  if (v5 == a3)
  {
    if (!a3)
      return result;
    v6 = 0;
  }
  else
  {
    v6 = *(_QWORD *)(v4 + 8);
    *(_QWORD *)(v4 + 8) = 0;
    if (a3)
    {
      Phase::Geometry::DataStream::Alloc(*(std::align_val_t *)(v4 + 16), *(_QWORD *)(v4 + 32) * a3, &v10);
      v7 = v10;
      v10 = 0;
      result = *(_QWORD *)(v4 + 8);
      *(_QWORD *)(v4 + 8) = v7;
      if (result)
      {
        MEMORY[0x2199F9D4C](result, 0x1000C8077774924);
        result = v10;
        v10 = 0;
        if (result)
          result = MEMORY[0x2199F9D4C](result, 0x1000C8077774924);
      }
    }
    *(_QWORD *)(v4 + 24) = v3;
    if (v5 < v3)
      v3 = v5;
    if (!v3)
    {
      if (!v6)
        return result;
      return MEMORY[0x2199F9D4C](v6, 0x1000C8077774924);
    }
  }
  v8 = 0;
  v9 = *(_QWORD *)(v4 + 8);
  do
  {
    *(_OWORD *)(v9 + 16 * v8) = *(_OWORD *)(v6 + 16 * v8);
    ++v8;
  }
  while (v3 != v8);
  return MEMORY[0x2199F9D4C](v6, 0x1000C8077774924);
}

void sub_2165C4B14(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    MEMORY[0x2199F9D4C](v1, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Geometry::DataStreamReference<int>::Resize(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = a3;
  v4 = *(_QWORD *)(result + 16 * a2);
  v5 = *(_QWORD *)(v4 + 24);
  if (v5 == a3)
  {
    if (!a3)
      return result;
    v6 = 0;
  }
  else
  {
    v6 = *(_QWORD *)(v4 + 8);
    *(_QWORD *)(v4 + 8) = 0;
    if (a3)
    {
      Phase::Geometry::DataStream::Alloc(*(std::align_val_t *)(v4 + 16), *(_QWORD *)(v4 + 32) * a3, &v10);
      v7 = v10;
      v10 = 0;
      result = *(_QWORD *)(v4 + 8);
      *(_QWORD *)(v4 + 8) = v7;
      if (result)
      {
        MEMORY[0x2199F9D4C](result, 0x1000C8077774924);
        result = v10;
        v10 = 0;
        if (result)
          result = MEMORY[0x2199F9D4C](result, 0x1000C8077774924);
      }
    }
    *(_QWORD *)(v4 + 24) = v3;
    if (v5 < v3)
      v3 = v5;
    if (!v3)
    {
      if (!v6)
        return result;
      return MEMORY[0x2199F9D4C](v6, 0x1000C8077774924);
    }
  }
  v8 = 0;
  v9 = *(_QWORD *)(v4 + 8);
  do
  {
    *(_DWORD *)(v9 + 4 * v8) = *(_DWORD *)(v6 + 4 * v8);
    ++v8;
  }
  while (v3 != v8);
  return MEMORY[0x2199F9D4C](v6, 0x1000C8077774924);
}

void sub_2165C4C3C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    MEMORY[0x2199F9D4C](v1, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void Phase::Geometry::CreateMpsMeshFromShape(uint64_t a1@<X1>, _QWORD *a2@<X2>, uint64_t ***a3@<X8>)
{
  unsigned int *value;
  std::vector<unsigned int>::pointer end;
  unsigned int *v8;
  std::vector<unsigned int>::pointer begin;
  int64_t v10;
  unint64_t v11;
  int64_t v12;
  unint64_t v13;
  char *v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int *v17;
  std::vector<unsigned int>::pointer v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  unsigned int *v24;
  unsigned int *v25;
  unsigned int v26;
  _QWORD *v27;
  uint64_t **v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  std::vector<unsigned int> __p;
  uint64_t v39;
  uint64_t v40;
  _QWORD v41[3];
  _QWORD *v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)a1 != 3)
    std::terminate();
  Phase::Geometry::ForcedCopyTagsIncludingMaterialListFromOptions(1uLL, a2, &__p);
  end = __p.__end_;
  value = __p.__end_cap_.__value_;
  if (__p.__end_ >= __p.__end_cap_.__value_)
  {
    begin = __p.__begin_;
    v10 = __p.__end_ - __p.__begin_;
    v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 62)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v12 = (char *)__p.__end_cap_.__value_ - (char *)__p.__begin_;
    if (((char *)__p.__end_cap_.__value_ - (char *)__p.__begin_) >> 1 > v11)
      v11 = v12 >> 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
      v13 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v13 = v11;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&__p.__end_cap_, v13);
      begin = __p.__begin_;
      end = __p.__end_;
    }
    else
    {
      v14 = 0;
    }
    v15 = (unsigned int *)&v14[4 * v10];
    value = (unsigned int *)&v14[4 * v13];
    *v15 = 15;
    v8 = v15 + 1;
    while (end != begin)
    {
      v16 = *--end;
      *--v15 = v16;
    }
    __p.__begin_ = v15;
    __p.__end_ = v8;
    __p.__end_cap_.__value_ = value;
    if (begin)
    {
      operator delete(begin);
      value = __p.__end_cap_.__value_;
    }
  }
  else
  {
    *__p.__end_ = 15;
    v8 = end + 1;
  }
  __p.__end_ = v8;
  if (v8 >= value)
  {
    v18 = __p.__begin_;
    v19 = v8 - __p.__begin_;
    v20 = v19 + 1;
    if ((unint64_t)(v19 + 1) >> 62)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v21 = (char *)value - (char *)__p.__begin_;
    if (v21 >> 1 > v20)
      v20 = v21 >> 1;
    if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL)
      v22 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v22 = v20;
    if (v22)
    {
      v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&__p.__end_cap_, v22);
      v18 = __p.__begin_;
      v8 = __p.__end_;
    }
    else
    {
      v23 = 0;
    }
    v24 = (unsigned int *)&v23[4 * v19];
    v25 = (unsigned int *)&v23[4 * v22];
    *v24 = 16;
    v17 = v24 + 1;
    while (v8 != v18)
    {
      v26 = *--v8;
      *--v24 = v26;
    }
    __p.__begin_ = v24;
    __p.__end_ = v17;
    __p.__end_cap_.__value_ = v25;
    if (v18)
      operator delete(v18);
  }
  else
  {
    *v8 = 16;
    v17 = v8 + 1;
  }
  __p.__end_ = v17;
  std::allocate_shared[abi:ne180100]<Phase::Geometry::Shape,std::allocator<Phase::Geometry::Shape>,Phase::Geometry::Shape&,std::vector<unsigned int> &,void>(a1, (__int32 **)&__p, a3);
  v27 = **(_QWORD ***)(a1 + 120);
  v28 = *a3;
  v29 = operator new();
  *(_QWORD *)v29 = Phase::GetTypeId<Phase::Geometry::MpsMesh>;
  *(_QWORD *)(v29 + 8) = v28;
  *(_QWORD *)(v29 + 16) = 0;
  *(_QWORD *)(v29 + 24) = -1;
  *(_QWORD *)(v29 + 32) = 0;
  *(_QWORD *)(v29 + 40) = -1;
  *(_QWORD *)(v29 + 48) = 0;
  *(_QWORD *)(v29 + 56) = -1;
  *(_QWORD *)(v29 + 64) = 0;
  *(_QWORD *)(v29 + 72) = -1;
  *(_QWORD *)(v29 + 80) = 0;
  *(_QWORD *)(v29 + 88) = -1;
  *(_QWORD *)(v29 + 96) = 0;
  *(_QWORD *)(v29 + 104) = -1;
  *(_OWORD *)(v29 + 112) = xmmword_2166F7280;
  *(_OWORD *)(v29 + 128) = xmmword_2166F8480;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize((uint64_t *)v28 + 15, 1uLL);
  v41[0] = &off_24D57D2D0;
  v42 = v41;
  v39 = v29;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v40, (uint64_t)v41);
  v30 = v42;
  if (v42 == v41)
  {
    v31 = 4;
    v30 = v41;
  }
  else
  {
    if (!v42)
      goto LABEL_39;
    v31 = 5;
  }
  (*(void (**)(void))(*v30 + 8 * v31))();
LABEL_39:
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100](v28[15], &v39);
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v39);
  v32 = v27[3];
  *(_QWORD *)(v29 + 16) = v28 + 12;
  *(_QWORD *)(v29 + 24) = v32;
  v33 = v27[5];
  *(_QWORD *)(v29 + 32) = v28 + 12;
  *(_QWORD *)(v29 + 40) = v33;
  v34 = v27[7];
  *(_QWORD *)(v29 + 48) = v28 + 12;
  *(_QWORD *)(v29 + 56) = v34;
  v35 = v27[9];
  *(_QWORD *)(v29 + 64) = v28 + 12;
  *(_QWORD *)(v29 + 72) = v35;
  v36 = v27[11];
  *(_QWORD *)(v29 + 80) = v28 + 12;
  *(_QWORD *)(v29 + 88) = v36;
  v37 = v27[13];
  *(_QWORD *)(v29 + 96) = v28 + 12;
  *(_QWORD *)(v29 + 104) = v37;
  Phase::Geometry::SetMaterialsFromOptionalMaterialList(*a3, a2);
  (*a3)[2] = *(uint64_t **)(a1 + 16);
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }
}

void sub_2165C4FB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Geometry::GetMaterials(uint64_t result, unsigned int *a2, int a3, _QWORD *a4, int a5, uint64_t a6)
{
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v6 = a3 * a6;
  if (v6 >= 1)
  {
    v7 = (unsigned int *)((char *)a2 + v6);
    v8 = *(_QWORD *)(**(_QWORD **)(result + 64) + 16 * *(_QWORD *)(result + 72));
    v9 = *(_QWORD *)(v8 + 8);
    v10 = *(_QWORD *)(v8 + 32);
    v11 = *(_QWORD *)(**(_QWORD **)(result + 80) + 16 * *(_QWORD *)(result + 88));
    v12 = *(_QWORD *)(v11 + 8);
    v13 = *(_QWORD *)(v11 + 32);
    v14 = v12 + 56;
    v15 = *(_QWORD *)(**(_QWORD **)(*(_QWORD *)(result + 8) + 144)
                    + 16 * *(_QWORD *)(*(_QWORD *)(result + 8) + 152));
    v16 = *(_QWORD *)(v15 + 8);
    v17 = *(_QWORD *)(v15 + 32);
    do
    {
      *a4 = *(_QWORD *)(v16 + v17 * *(unsigned int *)(v14 + v13 * *(unsigned __int16 *)(v9 + v10 * *a2)));
      a4 = (_QWORD *)((char *)a4 + a5);
      a2 = (unsigned int *)((char *)a2 + a3);
    }
    while (a2 < v7);
  }
  return result;
}

{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v6 = a3 * a6;
  if (v6 >= 1)
  {
    v7 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(result + 40) + 16 * *(_QWORD *)(result + 48)) + 8);
    v8 = *(_QWORD **)(**(_QWORD **)(v7 + 40) + 16 * *(_QWORD *)(v7 + 48));
    v9 = (unsigned int *)((char *)a2 + v6);
    v10 = v8[1] + (v8[3] - 1) * v8[4];
    v11 = *(_QWORD *)(**(_QWORD **)(v10 + 40) + 16 * *(_QWORD *)(v10 + 48));
    v12 = *(_QWORD *)(v11 + 8);
    v13 = *(_QWORD *)(v11 + 32);
    v14 = v12 + 12;
    v15 = *(_QWORD *)(**(_QWORD **)(*(_QWORD *)(result + 8) + 144)
                    + 16 * *(_QWORD *)(*(_QWORD *)(result + 8) + 152));
    v16 = *(_QWORD *)(v15 + 8);
    v17 = *(_QWORD *)(v15 + 32);
    do
    {
      *a4 = *(_QWORD *)(v16 + v17 * *(int *)(v14 + v13 * *a2));
      a4 = (_QWORD *)((char *)a4 + a5);
      a2 = (unsigned int *)((char *)a2 + a3);
    }
    while (a2 < v9);
  }
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::MpsMesh>(Phase::Geometry::MpsMesh *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::MpsMesh>(Phase::Geometry::MpsMesh *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::MpsMesh>(Phase::Geometry::MpsMesh *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::MpsMesh>(Phase::Geometry::MpsMesh *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57D2D0;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::MpsMesh>(Phase::Geometry::MpsMesh *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::MpsMesh>(Phase::Geometry::MpsMesh *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57D2D0;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::MpsMesh>(Phase::Geometry::MpsMesh *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::MpsMesh>(Phase::Geometry::MpsMesh *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
    JUMPOUT(0x2199F9D70);
  return result;
}

uint64_t Phase::Geometry::SingleHitRaycastVsMesh(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unsigned int *v21;
  float32x2_t *v22;
  float32x2_t *v23;
  float32x2_t *v24;
  uint64_t result;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  float64x2_t v32;
  double v33;
  float64x2_t v34;
  double v35;
  float64x2_t v36;
  double v37;
  double v38[2];
  char v39;
  float64x2_t v40;
  double v41;
  float64x2_t v42;
  double v43;

  v5 = *(float *)(a3 + 8);
  v4 = *(float *)(a3 + 12);
  v6 = *(float *)(a3 + 24);
  v7 = *(float *)(a3 + 28);
  *(_DWORD *)(a3 + 32) = 2139095039;
  *(_QWORD *)(a3 + 36) = 0;
  v31 = a3 + 36;
  *(_QWORD *)(a3 + 44) = 0;
  *(_DWORD *)(a3 + 52) = 0;
  *(_QWORD *)(a3 + 56) = 0xFFFFFFFFLL;
  *(_QWORD *)(a3 + 64) = 0;
  v30 = (_QWORD *)(a3 + 64);
  v29 = a4[1];
  v8 = **(_QWORD **)(v29 + 120);
  v9 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v8 + 16) + 16 * *(_QWORD *)(v8 + 24)) + 8);
  v40 = vcvtq_f64_f32(*(float32x2_t *)a3);
  v41 = v5;
  v42 = vcvtq_f64_f32(*(float32x2_t *)(a3 + 16));
  v43 = v6;
  v10 = *(_QWORD *)(v8 + 56);
  v28 = v8;
  v11 = **(_QWORD **)(v8 + 48);
  v12 = *(_QWORD **)(v11 + 16 * v10);
  if (v12[3])
  {
    v15 = 0;
    v16 = v4;
    do
    {
      v17 = v12[1] + v12[4] * v15;
      if (*(_DWORD *)(v17 + 24) != 1)
        __assert_rtn("RaycastVsMesh", "GeoRaycastUtility.hpp", 533, "MeshTopology::Triangles == submesh.mTopology");
      v18 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v17 + 48) + 16 * *(_QWORD *)(v17 + 56)) + 24);
      if (v18)
      {
        v19 = 0;
        v20 = (_DWORD)v15 << 24;
        v21 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v17 + 32) + 16 * *(_QWORD *)(v17 + 40)) + 8)
                             + 8);
        do
        {
          v22 = (float32x2_t *)(v9 + 12 * *(v21 - 2));
          v23 = (float32x2_t *)(v9 + 12 * *(v21 - 1));
          v24 = (float32x2_t *)(v9 + 12 * *v21);
          v32 = vcvtq_f64_f32(*v22);
          v33 = v22[1].f32[0];
          v34 = vcvtq_f64_f32(*v23);
          v35 = v23[1].f32[0];
          v36 = vcvtq_f64_f32(*v24);
          v37 = v24[1].f32[0];
          result = (uint64_t)Phase::Intersection<double>(v32.f64, v40.f64, (uint64_t)v38);
          if (v39 && v38[0] < v7 && v38[0] > v16)
          {
            if (v15 >= 0x100)
              std::terminate();
            v7 = v38[0];
            v26 = *(_QWORD *)(v29 + 8);
            LODWORD(v32.f64[0]) = v20 | v19;
            *(float *)(a3 + 32) = v7;
            *(_QWORD *)(a3 + 48) = v26;
            *(_DWORD *)(a3 + 56) = v20 | v19;
            v27 = **(_QWORD **)(a4[1] + 120);
            Phase::Geometry::GetNormals(v27, (float *)(*a4 + 48), (unsigned int *)&v32, 1, v31, 1, 1);
            result = Phase::Geometry::GetMaterials(v27, (unint64_t)&v32, 1, v30, 1, 1);
          }
          v21 += 3;
          ++v19;
        }
        while (v18 != v19);
        v10 = *(_QWORD *)(v28 + 56);
        v11 = **(_QWORD **)(v28 + 48);
      }
      ++v15;
      v12 = *(_QWORD **)(v11 + 16 * v10);
    }
    while (v15 < v12[3]);
  }
  return result;
}

double *Phase::Geometry::SingleHitRaycastVsMeshV2(uint64_t a1, uint64_t a2, float32x2_t *a3, float32x2_t **a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float32x2_t *v8;
  float32x2_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  float32x2_t *v22;
  float32x2_t *v23;
  float32x2_t *v24;
  double *result;
  float32x2_t v26;
  uint64_t v27;
  float64x2_t v28;
  double v29;
  float64x2_t v30;
  double v31;
  float64x2_t v32;
  double v33;
  double v34[2];
  char v35;
  float64x2_t v36;
  double v37;
  float64x2_t v38;
  double v39;

  v5 = a3[1].f32[0];
  v4 = a3[1].f32[1];
  v6 = a3[3].f32[0];
  v7 = a3[3].f32[1];
  a3[5] = 0;
  a3[6] = 0;
  a3[4] = (float32x2_t)-2155872257;
  v8 = a4[1];
  v9 = (*a4)[1];
  v10 = **(_QWORD **)&v8[15];
  v11 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v10 + 16) + 16 * *(_QWORD *)(v10 + 24)) + 8);
  v36 = vcvtq_f64_f32(*a3);
  v37 = v5;
  v38 = vcvtq_f64_f32(a3[2]);
  v39 = v6;
  v12 = *(_QWORD *)(v10 + 56);
  v27 = v10;
  v13 = **(_QWORD **)(v10 + 48);
  v14 = *(_QWORD **)(v13 + 16 * v12);
  if (v14[3])
  {
    v16 = 0;
    v17 = v4;
    do
    {
      v18 = v14[1] + v14[4] * v16;
      if (*(_DWORD *)(v18 + 24) != 1)
        __assert_rtn("RaycastVsMesh", "GeoRaycastUtility.hpp", 533, "MeshTopology::Triangles == submesh.mTopology");
      v19 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v18 + 48) + 16 * *(_QWORD *)(v18 + 56)) + 24);
      if (v19)
      {
        v20 = 0;
        v21 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v18 + 32) + 16 * *(_QWORD *)(v18 + 40)) + 8)
                             + 8);
        do
        {
          v22 = (float32x2_t *)(v11 + 12 * *(v21 - 2));
          v23 = (float32x2_t *)(v11 + 12 * *(v21 - 1));
          v24 = (float32x2_t *)(v11 + 12 * *v21);
          v28 = vcvtq_f64_f32(*v22);
          v29 = v22[1].f32[0];
          v30 = vcvtq_f64_f32(*v23);
          v31 = v23[1].f32[0];
          v32 = vcvtq_f64_f32(*v24);
          v33 = v24[1].f32[0];
          result = Phase::Intersection<double>(v28.f64, v36.f64, (uint64_t)v34);
          if (v35 && v34[0] < v7 && v34[0] > v17)
          {
            if (v16 >= 0x100)
              std::terminate();
            v26 = v8[1];
            v7 = v34[0];
            a3[4].f32[0] = v7;
            a3[4].i32[1] = ((_DWORD)v16 << 24) | v20;
            a3[5] = v26;
            a3[6] = v9;
          }
          v21 += 3;
          ++v20;
        }
        while (v19 != v20);
        v12 = *(_QWORD *)(v27 + 56);
        v13 = **(_QWORD **)(v27 + 48);
      }
      ++v16;
      v14 = *(_QWORD **)(v13 + 16 * v12);
    }
    while (v16 < v14[3]);
  }
  return result;
}

void Phase::Geometry::MultiHitRaycastVsMesh(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  double v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  float32x2_t *v20;
  float32x2_t *v21;
  float32x2_t *v22;
  float v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  __int128 v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  void *__p;
  char *v36;
  unint64_t v37;
  float64x2_t v38;
  _BYTE v39[24];
  double v40;
  float64x2_t v41;
  double v42;
  double v43[2];
  char v44;
  float64x2_t v45;
  double v46;
  float64x2_t v47;
  double v48;
  unsigned int v49[3];

  v7 = (uint64_t *)(a3 + 32);
  std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)(a3 + 32));
  *(_QWORD *)(a3 + 72) = 0;
  __p = 0;
  v36 = 0;
  v37 = 0;
  v33 = a4[1];
  v8 = **(_QWORD **)(v33 + 120);
  v9 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v8 + 16) + 16 * *(_QWORD *)(v8 + 24)) + 8);
  v10 = *(float *)(a3 + 8);
  v11 = *(float *)(a3 + 24);
  v45 = vcvtq_f64_f32(*(float32x2_t *)a3);
  v46 = v10;
  v47 = vcvtq_f64_f32(*(float32x2_t *)(a3 + 16));
  v48 = v11;
  v12 = *(_QWORD *)(v8 + 56);
  v32 = v8;
  v13 = **(_QWORD **)(v8 + 48);
  v14 = *(_QWORD **)(v13 + 16 * v12);
  if (v14[3])
  {
    v30 = v7;
    v31 = a1;
    v15 = 0;
    do
    {
      v16 = v14[1] + v14[4] * v15;
      if (*(_DWORD *)(v16 + 24) != 1)
        __assert_rtn("RaycastVsMesh", "GeoRaycastUtility.hpp", 533, "MeshTopology::Triangles == submesh.mTopology");
      v17 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v16 + 48) + 16 * *(_QWORD *)(v16 + 56)) + 24);
      if (v17)
      {
        v18 = 0;
        v34 = (_DWORD)v15 << 24;
        v19 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v16 + 32) + 16 * *(_QWORD *)(v16 + 40)) + 8)
                             + 8);
        do
        {
          v20 = (float32x2_t *)(v9 + 12 * *(v19 - 2));
          v21 = (float32x2_t *)(v9 + 12 * *(v19 - 1));
          v22 = (float32x2_t *)(v9 + 12 * *v19);
          v38 = vcvtq_f64_f32(*v20);
          *(double *)v39 = v20[1].f32[0];
          *(float64x2_t *)&v39[8] = vcvtq_f64_f32(*v21);
          v40 = v21[1].f32[0];
          v41 = vcvtq_f64_f32(*v22);
          v42 = v22[1].f32[0];
          Phase::Intersection<double>(v38.f64, v45.f64, (uint64_t)v43);
          if (v44 && v43[0] < *(float *)(a3 + 28) && v43[0] > *(float *)(a3 + 12))
          {
            if (v15 >= 0x100)
              std::terminate();
            v23 = v43[0];
            v24 = *(_QWORD *)(v33 + 8);
            v49[0] = v34 | v18;
            HIDWORD(v38.f64[1]) = 0;
            *(float64_t *)((char *)v38.f64 + 4) = 0.0;
            *(_QWORD *)&v39[16] = 0;
            *(float *)v38.f64 = v23;
            *(_QWORD *)v39 = v24;
            *(_DWORD *)&v39[8] = v34 | v18;
            v25 = **(_QWORD **)(a4[1] + 120);
            Phase::Geometry::GetNormals(v25, (float *)(*a4 + 48), v49, 1, (uint64_t)v38.f64 + 4, 1, 1);
            Phase::Geometry::GetMaterials(v25, (unint64_t)v49, 1, &v39[16], 1, 1);
            v26 = v36;
            if ((unint64_t)v36 >= v37)
            {
              v28 = std::vector<Phase::Geometry::RaycastHit>::__push_back_slow_path<Phase::Geometry::RaycastHit const&>((uint64_t *)&__p, (uint64_t)&v38);
            }
            else
            {
              *(float64x2_t *)v36 = v38;
              v27 = *(_OWORD *)v39;
              *((_QWORD *)v26 + 4) = *(_QWORD *)&v39[16];
              *((_OWORD *)v26 + 1) = v27;
              v28 = (uint64_t)(v26 + 40);
            }
            v36 = (char *)v28;
          }
          v19 += 3;
          ++v18;
        }
        while (v17 != v18);
        v12 = *(_QWORD *)(v32 + 56);
        v13 = **(_QWORD **)(v32 + 48);
      }
      ++v15;
      v14 = *(_QWORD **)(v13 + 16 * v12);
    }
    while (v15 < v14[3]);
    v29 = 0xCCCCCCCCCCCCCCCDLL * ((v36 - (_BYTE *)__p) >> 3);
    v7 = v30;
    a1 = v31;
  }
  else
  {
    v29 = 0;
  }
  Phase::Geometry::MergeRaycastQueryHits<Phase::Geometry::RaycastHit,std::vector<Phase::Geometry::RaycastHit>>(a1, v7, &__p, v29);
  if (__p)
  {
    v36 = (char *)__p;
    operator delete(__p);
  }
}

void sub_2165C598C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t *Phase::Geometry::MergeRaycastQueryHits<Phase::Geometry::RaycastHit,std::vector<Phase::Geometry::RaycastHit>>(uint64_t a1, uint64_t *a2, _QWORD *a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  __int128 v20;
  uint64_t v21;
  uint64_t *result;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  _BYTE v29[32];
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  if (a4)
  {
    v7 = a2 + 5;
    v8 = a2[5] + a4;
    v23 = 8;
    v24 = v8;
    v25 = &v24;
    v26 = &v23;
    Phase::details::AllocArray<Phase::Geometry::RaycastHit,std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::RaycastHit>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::RaycastHit>(unsigned long,unsigned long)::{lambda(Phase::Geometry::RaycastHit*)#1} const&>(v8, (uint64_t)&v25, &v28);
    v9 = v28;
    v28 = 0;
    v25 = (_QWORD *)v9;
    std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v26, (uint64_t)v29);
    v27 = v8;
    std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v28);
    if (*v7)
    {
      v10 = 0;
      v11 = 0;
      do
      {
        v12 = *a2 + v10 * 8;
        v13 = &v25[v10];
        *(_DWORD *)v13 = *(_DWORD *)v12;
        *((_DWORD *)v13 + 1) = *(_DWORD *)(v12 + 4);
        *((_DWORD *)v13 + 2) = *(_DWORD *)(v12 + 8);
        *((_DWORD *)v13 + 3) = *(_DWORD *)(v12 + 12);
        v14 = *(_OWORD *)(v12 + 16);
        v13[4] = *(_QWORD *)(v12 + 32);
        *((_OWORD *)v13 + 1) = v14;
        ++v11;
        v10 += 5;
      }
      while (a2[5] > v11);
    }
    v15 = 0;
    v16 = 0;
    if (a4 <= 1)
      v17 = 1;
    else
      v17 = a4;
    do
    {
      v18 = *a3 + v15;
      v19 = &v25[5 * v16 + 5 * a2[5]];
      *(_DWORD *)v19 = *(_DWORD *)v18;
      *((_DWORD *)v19 + 1) = *(_DWORD *)(v18 + 4);
      *((_DWORD *)v19 + 2) = *(_DWORD *)(v18 + 8);
      *((_DWORD *)v19 + 3) = *(_DWORD *)(v18 + 12);
      v20 = *(_OWORD *)(v18 + 16);
      v19[4] = *(_QWORD *)(v18 + 32);
      *((_OWORD *)v19 + 1) = v20;
      ++v16;
      v15 += 40;
    }
    while (v17 != v16);
    v21 = *a2;
    *a2 = 0;
    v28 = v21;
    std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v29, (uint64_t)(a2 + 1));
    v30 = a2[5];
    std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::operator=[abi:ne180100](a2, (uint64_t *)&v25);
    a2[5] = v27;
    std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)&v25, &v28);
    v27 = v30;
    std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v28);
    return std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v25);
  }
  return result;
}

void Phase::Geometry::MultiHitRaycastVsMeshV2(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  double v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int *v20;
  float32x2_t *v21;
  float32x2_t *v22;
  float32x2_t *v23;
  int v24;
  float v25;
  uint64_t v26;
  float *v27;
  float *v28;
  float *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  __int128 v36;
  unint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *__p;
  float *v43;
  float *v44;
  float64x2_t v45;
  double v46;
  float64x2_t v47;
  double v48;
  float64x2_t v49;
  double v50;
  double v51[2];
  char v52;
  float64x2_t v53;
  double v54;
  float64x2_t v55;
  double v56;

  v7 = (uint64_t *)(a3 + 32);
  std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)(a3 + 32));
  *(_QWORD *)(a3 + 72) = 0;
  v43 = 0;
  v44 = 0;
  __p = 0;
  v40 = *(_QWORD *)(*a4 + 8);
  v41 = a4[1];
  v8 = **(_QWORD **)(v41 + 120);
  v9 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v8 + 16) + 16 * *(_QWORD *)(v8 + 24)) + 8);
  v10 = *(float *)(a3 + 8);
  v11 = *(float *)(a3 + 24);
  v53 = vcvtq_f64_f32(*(float32x2_t *)a3);
  v54 = v10;
  v55 = vcvtq_f64_f32(*(float32x2_t *)(a3 + 16));
  v56 = v11;
  v12 = *(_QWORD *)(v8 + 56);
  v39 = v8;
  v13 = **(_QWORD **)(v8 + 48);
  v14 = *(_QWORD **)(v13 + 16 * v12);
  if (v14[3])
  {
    v38 = v7;
    v15 = 0;
    do
    {
      v16 = v14[1] + v14[4] * v15;
      if (*(_DWORD *)(v16 + 24) != 1)
        __assert_rtn("RaycastVsMesh", "GeoRaycastUtility.hpp", 533, "MeshTopology::Triangles == submesh.mTopology");
      v17 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v16 + 48) + 16 * *(_QWORD *)(v16 + 56)) + 24);
      if (v17)
      {
        v18 = 0;
        v19 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v16 + 32) + 16 * *(_QWORD *)(v16 + 40)) + 8);
        do
        {
          v20 = (unsigned int *)(v19 + 12 * v18);
          v21 = (float32x2_t *)(v9 + 12 * *v20);
          v22 = (float32x2_t *)(v9 + 12 * v20[1]);
          v23 = (float32x2_t *)(v9 + 12 * v20[2]);
          v45 = vcvtq_f64_f32(*v21);
          v46 = v21[1].f32[0];
          v47 = vcvtq_f64_f32(*v22);
          v48 = v22[1].f32[0];
          v49 = vcvtq_f64_f32(*v23);
          v50 = v23[1].f32[0];
          Phase::Intersection<double>(v45.f64, v53.f64, (uint64_t)v51);
          if (v52 && v51[0] < *(float *)(a3 + 28) && v51[0] > *(float *)(a3 + 12))
          {
            if (v15 >= 0x100)
              std::terminate();
            v24 = ((_DWORD)v15 << 24) | v18;
            v25 = v51[0];
            v26 = *(_QWORD *)(v41 + 8);
            v27 = v43;
            if (v43 >= v44)
            {
              v29 = (float *)__p;
              v30 = 0xAAAAAAAAAAAAAAABLL * (((char *)v43 - (_BYTE *)__p) >> 3);
              v31 = v30 + 1;
              if (v30 + 1 > 0xAAAAAAAAAAAAAAALL)
                std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
              if (0x5555555555555556 * (((char *)v44 - (_BYTE *)__p) >> 3) > v31)
                v31 = 0x5555555555555556 * (((char *)v44 - (_BYTE *)__p) >> 3);
              if (0xAAAAAAAAAAAAAAABLL * (((char *)v44 - (_BYTE *)__p) >> 3) >= 0x555555555555555)
                v32 = 0xAAAAAAAAAAAAAAALL;
              else
                v32 = v31;
              if (v32)
              {
                v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&v44, v32);
                v29 = (float *)__p;
                v27 = v43;
              }
              else
              {
                v33 = 0;
              }
              v34 = &v33[8 * (((char *)v43 - (_BYTE *)__p) >> 3)];
              *(float *)v34 = v25;
              *((_DWORD *)v34 + 1) = v24;
              *((_QWORD *)v34 + 1) = v26;
              *((_QWORD *)v34 + 2) = v40;
              v35 = &v33[24 * v30];
              if (v27 != v29)
              {
                do
                {
                  v36 = *(_OWORD *)(v27 - 6);
                  *((_QWORD *)v35 - 1) = *((_QWORD *)v27 - 1);
                  *(_OWORD *)(v35 - 24) = v36;
                  v35 -= 24;
                  v27 -= 6;
                }
                while (v27 != v29);
                v29 = (float *)__p;
              }
              v28 = (float *)(v34 + 24);
              __p = v35;
              v43 = (float *)(v34 + 24);
              v44 = (float *)&v33[24 * v32];
              if (v29)
                operator delete(v29);
            }
            else
            {
              *v43 = v25;
              *((_DWORD *)v27 + 1) = v24;
              v28 = v27 + 6;
              *((_QWORD *)v27 + 1) = v26;
              *((_QWORD *)v27 + 2) = v40;
            }
            v43 = v28;
          }
          ++v18;
        }
        while (v18 != v17);
        v12 = *(_QWORD *)(v39 + 56);
        v13 = **(_QWORD **)(v39 + 48);
      }
      ++v15;
      v14 = *(_QWORD **)(v13 + 16 * v12);
    }
    while (v15 < v14[3]);
    v37 = 0xAAAAAAAAAAAAAAABLL * (((char *)v43 - (_BYTE *)__p) >> 3);
    v7 = v38;
  }
  else
  {
    v37 = 0;
  }
  Phase::Geometry::MergeRaycastQueryHits<Phase::Geometry::RaycastHitV2,std::vector<Phase::Geometry::RaycastHitV2>>(a1, v7, &__p, v37);
  if (__p)
  {
    v43 = (float *)__p;
    operator delete(__p);
  }
}

void sub_2165C5F5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t *Phase::Geometry::MergeRaycastQueryHits<Phase::Geometry::RaycastHitV2,std::vector<Phase::Geometry::RaycastHitV2>>(uint64_t a1, uint64_t *a2, _QWORD *a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 *v18;
  _QWORD *v19;
  __int128 v20;
  uint64_t v21;
  uint64_t *result;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  _BYTE v29[32];
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  if (a4)
  {
    v7 = a2 + 5;
    v8 = a2[5] + a4;
    v23 = 8;
    v24 = v8;
    v25 = &v24;
    v26 = &v23;
    Phase::details::AllocArray<Phase::Geometry::RaycastHitV2,std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::RaycastHitV2>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::RaycastHitV2>(unsigned long,unsigned long)::{lambda(Phase::Geometry::RaycastHitV2*)#1} const&>(v8, (uint64_t)&v25, &v28);
    v9 = v28;
    v28 = 0;
    v25 = (_QWORD *)v9;
    std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v26, (uint64_t)v29);
    v27 = v8;
    std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v28);
    if (*v7)
    {
      v10 = 0;
      v11 = 0;
      do
      {
        v12 = *a2 + v10 * 8;
        v13 = &v25[v10];
        v14 = *(_OWORD *)v12;
        v13[2] = *(_QWORD *)(v12 + 16);
        *(_OWORD *)v13 = v14;
        ++v11;
        v10 += 3;
      }
      while (a2[5] > v11);
    }
    v15 = 0;
    v16 = 0;
    if (a4 <= 1)
      v17 = 1;
    else
      v17 = a4;
    do
    {
      v18 = (__int128 *)(*a3 + v15);
      v19 = &v25[3 * v16 + 3 * a2[5]];
      v20 = *v18;
      v19[2] = *((_QWORD *)v18 + 2);
      *(_OWORD *)v19 = v20;
      ++v16;
      v15 += 24;
    }
    while (v17 != v16);
    v21 = *a2;
    *a2 = 0;
    v28 = v21;
    std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v29, (uint64_t)(a2 + 1));
    v30 = a2[5];
    std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::operator=[abi:ne180100](a2, (uint64_t *)&v25);
    a2[5] = v27;
    std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)&v25, &v28);
    v27 = v30;
    std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v28);
    return std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v25);
  }
  return result;
}

double *Phase::Intersection<double>@<X0>(double *result@<X0>, double *a2@<X1>, uint64_t a3@<X8>)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  BOOL v24;
  double v25;
  double v26;
  double v27;
  double v28;
  BOOL v29;
  double v30;
  char v31;

  v3 = a2[3];
  v4 = a2[4];
  v5 = a2[5];
  v6 = result[1];
  v7 = result[2];
  v8 = result[3] - *result;
  v9 = result[4] - v6;
  v10 = result[5] - v7;
  v11 = result[6] - *result;
  v12 = result[7] - v6;
  v13 = result[8] - v7;
  v14 = v4 * v13 - v5 * v12;
  v15 = v5 * v11 - v3 * v13;
  v16 = v3 * v12 - v4 * v11;
  v17 = v10 * v16 + v8 * v14 + v9 * v15;
  v18 = -v17;
  if (v17 >= 0.0)
    v18 = v10 * v16 + v8 * v14 + v9 * v15;
  if (v18 <= 2.22044605e-16)
    goto LABEL_16;
  v19 = 1.0 / v17;
  v20 = *a2 - *result;
  v21 = a2[1] - v6;
  v22 = a2[2] - v7;
  v23 = v19 * (v16 * v22 + v15 * v21 + v14 * v20);
  v24 = v23 >= 0.0 && v23 <= 1.0;
  if (v24
    && ((v25 = v21 * v10 - v22 * v9,
         v26 = v22 * v8 - v20 * v10,
         v27 = v20 * v9 - v21 * v8,
         v28 = v19 * (v5 * v27 + v3 * v25 + v4 * v26),
         v28 >= 0.0)
      ? (v29 = v23 + v28 <= 1.0)
      : (v29 = 0),
        v29 && (v30 = v19 * (v13 * v27 + v11 * v25 + v12 * v26), v30 > 0.0)))
  {
    *(double *)a3 = v30;
    *(double *)(a3 + 8) = v30;
    v31 = 1;
  }
  else
  {
LABEL_16:
    v31 = 0;
    *(_BYTE *)a3 = 0;
  }
  *(_BYTE *)(a3 + 16) = v31;
  return result;
}

uint64_t *std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::reset[abi:ne180100](uint64_t *result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *result;
  *result = 0;
  if (v1)
  {
    v3 = v1;
    v2 = result[4];
    if (!v2)
      std::__throw_bad_function_call[abi:ne180100]();
    return (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v2 + 48))(v2, &v3);
  }
  return result;
}

uint64_t std::vector<Phase::Geometry::RaycastHit>::__push_back_slow_path<Phase::Geometry::RaycastHit const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  __int128 v12;
  uint64_t v13;
  void *__p;
  char *v16;
  char *v17;
  char *v18;
  uint64_t *v19;

  v3 = *a1;
  v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0x666666666666666)
    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x333333333333333)
    v9 = 0x666666666666666;
  else
    v9 = v5;
  v19 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[40 * v4];
  __p = v10;
  v16 = v11;
  v18 = &v10[40 * v9];
  *(_DWORD *)v11 = *(_DWORD *)a2;
  *((_DWORD *)v11 + 1) = *(_DWORD *)(a2 + 4);
  *((_DWORD *)v11 + 2) = *(_DWORD *)(a2 + 8);
  *((_DWORD *)v11 + 3) = *(_DWORD *)(a2 + 12);
  v12 = *(_OWORD *)(a2 + 16);
  *((_QWORD *)v11 + 4) = *(_QWORD *)(a2 + 32);
  *((_OWORD *)v11 + 1) = v12;
  v17 = v11 + 40;
  std::vector<Phase::Geometry::RaycastHit>::__swap_out_circular_buffer(a1, &__p);
  v13 = a1[1];
  if (v17 != v16)
    v17 = &v16[(v17 - v16 - 40) % 0x28uLL];
  if (__p)
    operator delete(__p);
  return v13;
}

void sub_2165C640C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t *std::vector<Phase::Geometry::RaycastHit>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  while (v2 != v3)
  {
    v5 = *(_DWORD *)(v2 - 40);
    v2 -= 40;
    *(_DWORD *)(v4 - 40) = v5;
    v4 -= 40;
    *(_DWORD *)(v4 + 4) = *(_DWORD *)(v2 + 4);
    *(_DWORD *)(v4 + 8) = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v4 + 12) = *(_DWORD *)(v2 + 12);
    v6 = *(_OWORD *)(v2 + 16);
    *(_QWORD *)(v4 + 32) = *(_QWORD *)(v2 + 32);
    *(_OWORD *)(v4 + 16) = v6;
  }
  a2[1] = v4;
  v7 = *result;
  *result = v4;
  a2[1] = v7;
  v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

_QWORD *Phase::details::AllocArray<Phase::Geometry::RaycastHit,std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::RaycastHit>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::RaycastHit>(unsigned long,unsigned long)::{lambda(Phase::Geometry::RaycastHit*)#1} const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  char *v5;
  char *v6;
  _QWORD *result;
  uint64_t v8;
  NSObject *v9;
  std::logic_error *exception;
  _BYTE v11[12];
  __int16 v12;
  int v13;
  _BYTE *v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v9 = **(NSObject ***)(Phase::Logger::GetInstancePtr(0) + 112);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v11 = 136315394;
      *(_QWORD *)&v11[4] = "ManagedPtr.hpp";
      v12 = 1024;
      v13 = 229;
      _os_log_impl(&dword_2164CC000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [inCount == 0 is true]: \"Attempting to allocate an array of 0 elements\"", v11, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempting to allocate an array of 0 elements");
  }
  v5 = (char *)operator new(40 * **(_QWORD **)a2, **(std::align_val_t **)(a2 + 8));
  v6 = v5;
  do
  {
    *(_DWORD *)v6 = 2139095039;
    *(_QWORD *)(v6 + 12) = 0;
    *(_QWORD *)(v6 + 4) = 0;
    *(_QWORD *)(v6 + 20) = 0xFFFFFFFF00000000;
    *((_QWORD *)v6 + 4) = 0;
    v6 += 40;
  }
  while (v6 != &v5[40 * a1]);
  *(_QWORD *)v11 = &off_24D57D318;
  v11[8] = 0;
  v14 = v11;
  *a3 = v5;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)(a3 + 1), (uint64_t)v11);
  result = v14;
  if (v14 == v11)
  {
    v8 = 4;
    result = v11;
  }
  else
  {
    if (!v14)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_2165C666C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry10RaycastHitERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_ED0Ev()
{
  JUMPOUT(0x2199F9D70);
}

_BYTE *_ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry10RaycastHitERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_E7__cloneEv(uint64_t a1)
{
  _BYTE *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = &off_24D57D318;
  result[8] = *(_BYTE *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry10RaycastHitERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_E7__cloneEPNS0_6__baseISD_EE(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24D57D318;
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(result + 8);
  return result;
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry10RaycastHitERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_EclEOSC_(uint64_t a1, void **a2)
{
  operator delete(*a2);
}

uint64_t *std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t *v2;
  uint64_t v3;

  std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::reset[abi:ne180100](a1);
  v2 = (uint64_t *)a1[4];
  if (v2 == a1 + 1)
  {
    v3 = 4;
    v2 = a1 + 1;
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return a1;
}

uint64_t *std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::operator=[abi:ne180100](uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;

  v4 = *a2;
  *a2 = 0;
  std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::reset[abi:ne180100]<Phase::Geometry::RaycastHit*,0>(a1, v4);
  std::__function::__value_func<double ()(double)>::operator=[abi:ne180100](a1 + 1, (uint64_t)(a2 + 1));
  return a1;
}

uint64_t *std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::reset[abi:ne180100]<Phase::Geometry::RaycastHit*,0>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v4 = v2;
    v3 = result[4];
    if (!v3)
      std::__throw_bad_function_call[abi:ne180100]();
    return (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v4);
  }
  return result;
}

uint64_t *std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::reset[abi:ne180100](uint64_t *result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *result;
  *result = 0;
  if (v1)
  {
    v3 = v1;
    v2 = result[4];
    if (!v2)
      std::__throw_bad_function_call[abi:ne180100]();
    return (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v2 + 48))(v2, &v3);
  }
  return result;
}

_QWORD *Phase::details::AllocArray<Phase::Geometry::RaycastHitV2,std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::RaycastHitV2>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::RaycastHitV2>(unsigned long,unsigned long)::{lambda(Phase::Geometry::RaycastHitV2*)#1} const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *result;
  uint64_t v8;
  NSObject *v9;
  std::logic_error *exception;
  _BYTE v11[12];
  __int16 v12;
  int v13;
  _BYTE *v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v9 = **(NSObject ***)(Phase::Logger::GetInstancePtr(0) + 112);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v11 = 136315394;
      *(_QWORD *)&v11[4] = "ManagedPtr.hpp";
      v12 = 1024;
      v13 = 229;
      _os_log_impl(&dword_2164CC000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [inCount == 0 is true]: \"Attempting to allocate an array of 0 elements\"", v11, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempting to allocate an array of 0 elements");
  }
  v5 = operator new(24 * **(_QWORD **)a2, **(std::align_val_t **)(a2 + 8));
  v6 = v5;
  do
  {
    v6[1] = 0;
    v6[2] = 0;
    *v6 = -2155872257;
    v6 += 3;
  }
  while (v6 != &v5[3 * a1]);
  *(_QWORD *)v11 = &off_24D57D360;
  v11[8] = 0;
  v14 = v11;
  *a3 = v5;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)(a3 + 1), (uint64_t)v11);
  result = v14;
  if (v14 == v11)
  {
    v8 = 4;
    result = v11;
  }
  else
  {
    if (!v14)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_2165C69B0(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry12RaycastHitV2ERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_ED0Ev()
{
  JUMPOUT(0x2199F9D70);
}

_BYTE *_ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry12RaycastHitV2ERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_E7__cloneEv(uint64_t a1)
{
  _BYTE *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = &off_24D57D360;
  result[8] = *(_BYTE *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry12RaycastHitV2ERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_E7__cloneEPNS0_6__baseISD_EE(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24D57D360;
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(result + 8);
  return result;
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry12RaycastHitV2ERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_EclEOSC_(uint64_t a1, void **a2)
{
  operator delete(*a2);
}

uint64_t *std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t *v2;
  uint64_t v3;

  std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::reset[abi:ne180100](a1);
  v2 = (uint64_t *)a1[4];
  if (v2 == a1 + 1)
  {
    v3 = 4;
    v2 = a1 + 1;
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return a1;
}

uint64_t *std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::operator=[abi:ne180100](uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;

  v4 = *a2;
  *a2 = 0;
  std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::reset[abi:ne180100]<Phase::Geometry::RaycastHitV2*,0>(a1, v4);
  std::__function::__value_func<double ()(double)>::operator=[abi:ne180100](a1 + 1, (uint64_t)(a2 + 1));
  return a1;
}

uint64_t *std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::reset[abi:ne180100]<Phase::Geometry::RaycastHitV2*,0>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v4 = v2;
    v3 = result[4];
    if (!v3)
      std::__throw_bad_function_call[abi:ne180100]();
    return (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v4);
  }
  return result;
}

uint64_t Phase::Geometry::SingleHitRaycastVsScene(uint64_t result, uint64_t a2, __int128 *a3, _QWORD *a4, int a5)
{
  uint64_t v6;
  float32x2_t **v7;
  unsigned int v8;
  float32x2_t **v9;
  float32x2_t *v10;
  float32x2_t **v11;
  unint64_t v12;
  _QWORD *i;
  _QWORD *v14;
  uint64_t v15;
  unsigned int *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  int v20;
  float v21;
  __int128 *v22;
  __int32 v23;
  float v24;
  float v25;
  float v26;
  float32x2_t **v27;
  __int128 *v28;
  _QWORD v30[2];
  uint64_t v31;
  int v32;
  __int128 v33;
  uint64_t v34;
  int v35;
  float v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  float32x2_t v40;
  float v41;
  __int32 v42;

  v6 = result;
  if (a5)
  {
    *((_DWORD *)a3 + 8) = 2139095039;
    *(_QWORD *)((char *)a3 + 44) = 0;
    *(_QWORD *)((char *)a3 + 36) = 0;
    *((_DWORD *)a3 + 13) = 0;
    *((_QWORD *)a3 + 7) = 0xFFFFFFFFLL;
    *((_QWORD *)a3 + 8) = 0;
  }
  v7 = *(float32x2_t ***)(result + 120);
  v8 = *(_DWORD *)(result + 136);
  v9 = &v7[3 * v8];
  if (v8)
  {
    v10 = *v7;
    if (!*v7)
    {
      v11 = v7 + 3;
      while (1)
      {
        v7 = v11;
        if (v11 >= v9)
          break;
        v11 += 3;
        v10 = *v7;
        if (*v7)
          goto LABEL_11;
      }
      v10 = 0;
    }
LABEL_11:
    v12 = (unint64_t)v9;
  }
  else
  {
    v10 = 0;
    v12 = *(_QWORD *)(result + 120);
  }
  if (v7 != v9)
  {
    v28 = a3 + 3;
    do
    {
      if (v10)
      {
        if (v10->i32[0] == 4 && (v10[18].i32[0] & *(_DWORD *)(a2 + 72)) != 0)
        {
          v14 = (_QWORD *)v10[15];
          for (i = (_QWORD *)v10[16]; v14 != i; ++v14)
          {
            if (*(_DWORD *)(v6 + 112) > *v14)
            {
              v15 = *(_QWORD *)(v6 + 96);
              if (*(_DWORD *)(v15 + 24 * *v14 + 20) == HIDWORD(*v14))
              {
                v16 = *(unsigned int **)(v15 + 24 * *v14);
                if (v16)
                {
                  if ((v16[4] & *(_DWORD *)(a2 + 72)) != 0)
                  {
                    v17 = *a4 + 32 * *v16;
                    v19 = *(_QWORD *)(v17 + 24);
                    v18 = (_QWORD *)(v17 + 24);
                    if (v19)
                    {
                      v30[0] = v10;
                      v30[1] = v16;
                      v33 = *a3;
                      v34 = *((_QWORD *)a3 + 2);
                      v20 = *((_DWORD *)a3 + 6);
                      v21 = *((float *)a3 + 7);
                      v38 = *v28;
                      v22 = a3;
                      v37 = a3[2];
                      v39 = *((_QWORD *)v28 + 2);
                      v35 = v20;
                      v36 = fminf(v21, *(float *)&v37);
                      Phase::TransformPositionByInverse<float>(v10 + 6, (float32x2_t *)&v33, (float *)&v40);
                      *(float32x2_t *)&v33 = v40;
                      *((float *)&v33 + 2) = v41;
                      v23 = v10[7].i32[1];
                      v24 = -v10[7].f32[0];
                      v40 = vneg_f32(v10[6]);
                      v41 = v24;
                      v42 = v23;
                      Phase::operator*<float>((float *)&v40, (float *)&v34, (float *)&v31);
                      v34 = v31;
                      v25 = 1.0 / v10[9].f32[1];
                      *((float *)&v33 + 3) = *((float *)&v33 + 3) * v25;
                      v35 = v32;
                      v36 = v25 * v36;
                      if (!*v18)
                        std::__throw_bad_function_call[abi:ne180100]();
                      result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, __int128 *, _QWORD *))(*(_QWORD *)*v18 + 48))(*v18, v6, a2, &v33, v30);
                      a3 = v22;
                      if (*(float *)&v37 < v36)
                      {
                        v26 = *(float *)&v37 * v10[9].f32[1];
                        if (v26 < *((float *)v22 + 8))
                        {
                          *((float *)v22 + 8) = v26;
                          *(_QWORD *)((char *)v22 + 36) = *(_QWORD *)((char *)&v37 + 4);
                          *((_DWORD *)v22 + 11) = HIDWORD(v37);
                          *v28 = v38;
                          *((_QWORD *)v28 + 2) = v39;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if ((unint64_t)v7 < v12)
      {
        v27 = v7 + 3;
        while (1)
        {
          v7 = v27;
          if ((unint64_t)v27 >= v12)
            break;
          v27 += 3;
          v10 = *v7;
          if (*v7)
            goto LABEL_34;
        }
        v10 = 0;
      }
LABEL_34:
      ;
    }
    while (v7 != v9);
  }
  return result;
}

uint64_t Phase::Geometry::SingleHitRaycastVsSceneV2(uint64_t result, uint64_t a2, __int128 *a3, _QWORD *a4, int a5)
{
  uint64_t v6;
  float32x2_t **v7;
  unsigned int v8;
  float32x2_t **v9;
  float32x2_t *v10;
  float32x2_t **v11;
  unint64_t v12;
  _QWORD *i;
  _QWORD *v14;
  uint64_t v15;
  unsigned int *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  int v20;
  float v21;
  float v22;
  __int32 v23;
  float v24;
  float v25;
  float32x2_t **v26;
  __int128 *v29;
  _QWORD v30[2];
  uint64_t v31;
  int v32;
  __int128 v33;
  uint64_t v34;
  int v35;
  float v36;
  __int128 v37;
  uint64_t v38;
  float32x2_t v39;
  float v40;
  __int32 v41;

  v6 = result;
  if (a5)
  {
    *((_QWORD *)a3 + 5) = 0;
    *((_QWORD *)a3 + 6) = 0;
    *((_QWORD *)a3 + 4) = -2155872257;
  }
  v7 = *(float32x2_t ***)(result + 120);
  v8 = *(_DWORD *)(result + 136);
  v9 = &v7[3 * v8];
  if (v8)
  {
    v10 = *v7;
    if (!*v7)
    {
      v11 = v7 + 3;
      while (1)
      {
        v7 = v11;
        if (v11 >= v9)
          break;
        v11 += 3;
        v10 = *v7;
        if (*v7)
          goto LABEL_11;
      }
      v10 = 0;
    }
LABEL_11:
    v12 = (unint64_t)v9;
  }
  else
  {
    v10 = 0;
    v12 = *(_QWORD *)(result + 120);
  }
  if (v7 != v9)
  {
    v29 = a3 + 2;
    do
    {
      if (v10)
      {
        if (v10->i32[0] == 4 && (v10[18].i32[0] & *(_DWORD *)(a2 + 72)) != 0)
        {
          v14 = (_QWORD *)v10[15];
          for (i = (_QWORD *)v10[16]; v14 != i; ++v14)
          {
            if (*(_DWORD *)(v6 + 112) > *v14)
            {
              v15 = *(_QWORD *)(v6 + 96);
              if (*(_DWORD *)(v15 + 24 * *v14 + 20) == HIDWORD(*v14))
              {
                v16 = *(unsigned int **)(v15 + 24 * *v14);
                if (v16)
                {
                  if ((v16[4] & *(_DWORD *)(a2 + 72)) != 0)
                  {
                    v17 = *a4 + 32 * *v16;
                    v19 = *(_QWORD *)(v17 + 24);
                    v18 = (_QWORD *)(v17 + 24);
                    if (v19)
                    {
                      v33 = *a3;
                      v20 = *((_DWORD *)a3 + 6);
                      v21 = *((float *)a3 + 7);
                      v37 = *v29;
                      v22 = fminf(v21, *((float *)a3 + 8));
                      v30[0] = v10;
                      v30[1] = v16;
                      v34 = *((_QWORD *)a3 + 2);
                      v38 = *((_QWORD *)v29 + 2);
                      v35 = v20;
                      v36 = v22;
                      Phase::TransformPositionByInverse<float>(v10 + 6, (float32x2_t *)&v33, (float *)&v39);
                      *(float32x2_t *)&v33 = v39;
                      *((float *)&v33 + 2) = v40;
                      v23 = v10[7].i32[1];
                      v24 = -v10[7].f32[0];
                      v39 = vneg_f32(v10[6]);
                      v40 = v24;
                      v41 = v23;
                      Phase::operator*<float>((float *)&v39, (float *)&v34, (float *)&v31);
                      v34 = v31;
                      v25 = 1.0 / v10[9].f32[1];
                      *((float *)&v33 + 3) = *((float *)&v33 + 3) * v25;
                      v35 = v32;
                      v36 = v25 * v36;
                      if (!*v18)
                        std::__throw_bad_function_call[abi:ne180100]();
                      result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, __int128 *, _QWORD *))(*(_QWORD *)*v18 + 48))(*v18, v6, a2, &v33, v30);
                      if (*(float *)&v37 < v36)
                      {
                        *(float *)&v37 = *(float *)&v37 * v10[9].f32[1];
                        if (*(float *)&v37 < *(float *)v29)
                        {
                          *v29 = v37;
                          *((_QWORD *)v29 + 2) = v38;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if ((unint64_t)v7 < v12)
      {
        v26 = v7 + 3;
        while (1)
        {
          v7 = v26;
          if ((unint64_t)v26 >= v12)
            break;
          v26 += 3;
          v10 = *v7;
          if (*v7)
            goto LABEL_34;
        }
        v10 = 0;
      }
LABEL_34:
      ;
    }
    while (v7 != v9);
  }
  return result;
}

uint64_t *Phase::Geometry::MultiHitRaycastVsScene(uint64_t *result, uint64_t a2, uint64_t *a3, _QWORD *a4, int a5)
{
  uint64_t *v7;
  float32x2_t **v8;
  unsigned int v9;
  float32x2_t **v10;
  float32x2_t *v11;
  float32x2_t **v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *i;
  uint64_t v16;
  unsigned int *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  __int128 v21;
  __int32 v22;
  float v23;
  float v24;
  unint64_t v25;
  float *v26;
  float v27;
  unint64_t v28;
  uint64_t v29;
  float32x2_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  __int128 v41;
  float32x2_t v42;
  float32x2_t **v43;
  float32x2_t **v44;
  uint64_t v45;
  _QWORD v47[2];
  _QWORD v48[2];
  uint64_t v49;
  uint64_t v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53[5];
  unint64_t v54;
  char v55;
  float32x2_t v56;
  int v57[8];
  uint64_t v58;
  float32x2_t v59;
  _DWORD v60[8];
  uint64_t v61;
  uint64_t v62;

  v7 = result;
  v62 = *MEMORY[0x24BDAC8D0];
  if (a5)
  {
    result = std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::reset[abi:ne180100](a3 + 4);
    a3[9] = 0;
  }
  v8 = (float32x2_t **)v7[15];
  v9 = *((_DWORD *)v7 + 34);
  v10 = &v8[3 * v9];
  if (v9)
  {
    v11 = *v8;
    if (!*v8)
    {
      v12 = v8 + 3;
      while (1)
      {
        v8 = v12;
        if (v12 >= v10)
          break;
        v12 += 3;
        v11 = *v8;
        if (*v8)
          goto LABEL_11;
      }
      v11 = 0;
    }
LABEL_11:
    v13 = (unint64_t)v10;
  }
  else
  {
    v11 = 0;
    v13 = v7[15];
  }
  if (v8 != v10)
  {
    v45 = a2;
    v44 = v10;
    do
    {
      if (v11)
      {
        if (v11->i32[0] == 4 && (v11[18].i32[0] & *(_DWORD *)(a2 + 72)) != 0)
        {
          v14 = (_QWORD *)v11[15];
          for (i = (_QWORD *)v11[16]; v14 != i; ++v14)
          {
            if (*((_DWORD *)v7 + 28) > *v14)
            {
              v16 = v7[12];
              if (*(_DWORD *)(v16 + 24 * *v14 + 20) == HIDWORD(*v14))
              {
                v17 = *(unsigned int **)(v16 + 24 * *v14);
                if (v17)
                {
                  if ((v17[4] & *(_DWORD *)(a2 + 72)) != 0)
                  {
                    v18 = *a4 + 32 * *v17;
                    v20 = *(_QWORD *)(v18 + 24);
                    v19 = (_QWORD *)(v18 + 24);
                    if (v20)
                    {
                      v47[0] = v11;
                      v47[1] = v17;
                      v53[0] = 0;
                      v53[4] = 0;
                      v54 = 0;
                      v21 = *((_OWORD *)a3 + 1);
                      v51 = *(_OWORD *)a3;
                      v52 = v21;
                      v55 = *((_BYTE *)a3 + 80);
                      Phase::TransformPositionByInverse<float>(v11 + 6, (float32x2_t *)&v51, (float *)&v59);
                      *(float32x2_t *)&v51 = v59;
                      DWORD2(v51) = v60[0];
                      v22 = v11[7].i32[1];
                      v23 = -v11[7].f32[0];
                      v59 = vneg_f32(v11[6]);
                      *(float *)v60 = v23;
                      v60[1] = v22;
                      Phase::operator*<float>((float *)&v59, (float *)&v52, (float *)&v56);
                      *(float32x2_t *)&v52 = v56;
                      v24 = 1.0 / v11[9].f32[1];
                      *((float *)&v51 + 3) = *((float *)&v51 + 3) * v24;
                      DWORD2(v52) = v57[0];
                      *((float *)&v52 + 3) = v24 * *((float *)&v52 + 3);
                      if (!*v19)
                        std::__throw_bad_function_call[abi:ne180100]();
                      (*(void (**)(_QWORD, uint64_t *, uint64_t, __int128 *, _QWORD *))(*(_QWORD *)*v19 + 48))(*v19, v7, a2, &v51, v47);
                      v25 = v54;
                      if (v54)
                      {
                        v26 = (float *)v53[0];
                        v27 = *((float *)&v52 + 3);
                        v28 = v54;
                        do
                        {
                          if (*v26 < v27)
                            *v26 = *v26 * v11[9].f32[1];
                          v26 += 10;
                          --v28;
                        }
                        while (v28);
                        v29 = a3[9] + v25;
                        v49 = 8;
                        v50 = v29;
                        v48[0] = &v50;
                        v48[1] = &v49;
                        Phase::details::AllocArray<Phase::Geometry::RaycastHit,std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::RaycastHit>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::RaycastHit>(unsigned long,unsigned long)::{lambda(Phase::Geometry::RaycastHit*)#1} const&>(v29, (uint64_t)v48, &v59);
                        v30 = v59;
                        v59 = 0;
                        v56 = v30;
                        std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v57, (uint64_t)v60);
                        v58 = v29;
                        std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v59);
                        if (a3[9])
                        {
                          v31 = 0;
                          v32 = 0;
                          do
                          {
                            v33 = a3[4] + v31;
                            v34 = *(_QWORD *)&v56 + v31;
                            *(_DWORD *)v34 = *(_DWORD *)v33;
                            *(_DWORD *)(v34 + 4) = *(_DWORD *)(v33 + 4);
                            *(_DWORD *)(v34 + 8) = *(_DWORD *)(v33 + 8);
                            *(_DWORD *)(v34 + 12) = *(_DWORD *)(v33 + 12);
                            v35 = *(_OWORD *)(v33 + 16);
                            *(_QWORD *)(v34 + 32) = *(_QWORD *)(v33 + 32);
                            *(_OWORD *)(v34 + 16) = v35;
                            ++v32;
                            v31 += 40;
                          }
                          while (a3[9] > v32);
                        }
                        v36 = 0;
                        v37 = 0;
                        if (v25 <= 1)
                          v38 = 1;
                        else
                          v38 = v25;
                        do
                        {
                          v39 = v53[0] + v36;
                          v40 = *(_QWORD *)&v56 + 40 * (v37 + a3[9]);
                          *(_DWORD *)v40 = *(_DWORD *)(v53[0] + v36);
                          *(_DWORD *)(v40 + 4) = *(_DWORD *)(v39 + 4);
                          *(_DWORD *)(v40 + 8) = *(_DWORD *)(v39 + 8);
                          *(_DWORD *)(v40 + 12) = *(_DWORD *)(v39 + 12);
                          v41 = *(_OWORD *)(v39 + 16);
                          *(_QWORD *)(v40 + 32) = *(_QWORD *)(v39 + 32);
                          *(_OWORD *)(v40 + 16) = v41;
                          ++v37;
                          v36 += 40;
                        }
                        while (v38 != v37);
                        v42 = (float32x2_t)a3[4];
                        a3[4] = 0;
                        v59 = v42;
                        std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v60, (uint64_t)(a3 + 5));
                        v61 = a3[9];
                        std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::operator=[abi:ne180100](a3 + 4, (uint64_t *)&v56);
                        a3[9] = v58;
                        std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)&v56, (uint64_t *)&v59);
                        v58 = v61;
                        std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v59);
                        std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v56);
                      }
                      result = std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](v53);
                      v10 = v44;
                      a2 = v45;
                    }
                  }
                }
              }
            }
          }
        }
      }
      if ((unint64_t)v8 < v13)
      {
        v43 = v8 + 3;
        while (1)
        {
          v8 = v43;
          if ((unint64_t)v43 >= v13)
            break;
          v43 += 3;
          v11 = *v8;
          if (*v8)
            goto LABEL_45;
        }
        v11 = 0;
      }
LABEL_45:
      ;
    }
    while (v8 != v10);
  }
  return result;
}

void sub_2165C7580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t *a16)
{
  std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](a16);
  _Unwind_Resume(a1);
}

uint64_t *Phase::Geometry::MultiHitRaycastVsSceneV2(uint64_t *result, uint64_t a2, uint64_t *a3, _QWORD *a4, int a5)
{
  uint64_t *v7;
  float32x2_t **v8;
  unsigned int v9;
  float32x2_t **v10;
  float32x2_t *v11;
  float32x2_t **v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *i;
  uint64_t v16;
  unsigned int *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  __int128 v21;
  __int32 v22;
  float v23;
  float v24;
  unint64_t v25;
  float *v26;
  float v27;
  unint64_t v28;
  uint64_t v29;
  float32x2_t v30;
  uint64_t v31;
  unint64_t v32;
  __int128 *v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v40;
  float32x2_t v41;
  float32x2_t **v42;
  float32x2_t **v43;
  uint64_t v44;
  _QWORD v46[2];
  _QWORD v47[2];
  uint64_t v48;
  uint64_t v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52[5];
  unint64_t v53;
  char v54;
  float32x2_t v55;
  int v56[8];
  uint64_t v57;
  float32x2_t v58;
  _DWORD v59[8];
  uint64_t v60;
  uint64_t v61;

  v7 = result;
  v61 = *MEMORY[0x24BDAC8D0];
  if (a5)
  {
    result = std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::reset[abi:ne180100](a3 + 4);
    a3[9] = 0;
  }
  v8 = (float32x2_t **)v7[15];
  v9 = *((_DWORD *)v7 + 34);
  v10 = &v8[3 * v9];
  if (v9)
  {
    v11 = *v8;
    if (!*v8)
    {
      v12 = v8 + 3;
      while (1)
      {
        v8 = v12;
        if (v12 >= v10)
          break;
        v12 += 3;
        v11 = *v8;
        if (*v8)
          goto LABEL_11;
      }
      v11 = 0;
    }
LABEL_11:
    v13 = (unint64_t)v10;
  }
  else
  {
    v11 = 0;
    v13 = v7[15];
  }
  if (v8 != v10)
  {
    v44 = a2;
    v43 = v10;
    do
    {
      if (v11)
      {
        if (v11->i32[0] == 4 && (v11[18].i32[0] & *(_DWORD *)(a2 + 72)) != 0)
        {
          v14 = (_QWORD *)v11[15];
          for (i = (_QWORD *)v11[16]; v14 != i; ++v14)
          {
            if (*((_DWORD *)v7 + 28) > *v14)
            {
              v16 = v7[12];
              if (*(_DWORD *)(v16 + 24 * *v14 + 20) == HIDWORD(*v14))
              {
                v17 = *(unsigned int **)(v16 + 24 * *v14);
                if (v17)
                {
                  if ((v17[4] & *(_DWORD *)(a2 + 72)) != 0)
                  {
                    v18 = *a4 + 32 * *v17;
                    v20 = *(_QWORD *)(v18 + 24);
                    v19 = (_QWORD *)(v18 + 24);
                    if (v20)
                    {
                      v46[0] = v11;
                      v46[1] = v17;
                      v52[0] = 0;
                      v52[4] = 0;
                      v53 = 0;
                      v21 = *((_OWORD *)a3 + 1);
                      v50 = *(_OWORD *)a3;
                      v51 = v21;
                      v54 = *((_BYTE *)a3 + 80);
                      Phase::TransformPositionByInverse<float>(v11 + 6, (float32x2_t *)&v50, (float *)&v58);
                      *(float32x2_t *)&v50 = v58;
                      DWORD2(v50) = v59[0];
                      v22 = v11[7].i32[1];
                      v23 = -v11[7].f32[0];
                      v58 = vneg_f32(v11[6]);
                      *(float *)v59 = v23;
                      v59[1] = v22;
                      Phase::operator*<float>((float *)&v58, (float *)&v51, (float *)&v55);
                      *(float32x2_t *)&v51 = v55;
                      v24 = 1.0 / v11[9].f32[1];
                      *((float *)&v50 + 3) = *((float *)&v50 + 3) * v24;
                      DWORD2(v51) = v56[0];
                      *((float *)&v51 + 3) = v24 * *((float *)&v51 + 3);
                      if (!*v19)
                        std::__throw_bad_function_call[abi:ne180100]();
                      (*(void (**)(_QWORD, uint64_t *, uint64_t, __int128 *, _QWORD *))(*(_QWORD *)*v19 + 48))(*v19, v7, a2, &v50, v46);
                      v25 = v53;
                      if (v53)
                      {
                        v26 = (float *)v52[0];
                        v27 = *((float *)&v51 + 3);
                        v28 = v53;
                        do
                        {
                          if (*v26 < v27)
                            *v26 = *v26 * v11[9].f32[1];
                          v26 += 6;
                          --v28;
                        }
                        while (v28);
                        v29 = a3[9] + v25;
                        v48 = 8;
                        v49 = v29;
                        v47[0] = &v49;
                        v47[1] = &v48;
                        Phase::details::AllocArray<Phase::Geometry::RaycastHitV2,std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::RaycastHitV2>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Geometry::RaycastHitV2>(unsigned long,unsigned long)::{lambda(Phase::Geometry::RaycastHitV2*)#1} const&>(v29, (uint64_t)v47, &v58);
                        v30 = v58;
                        v58 = 0;
                        v55 = v30;
                        std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v56, (uint64_t)v59);
                        v57 = v29;
                        std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v58);
                        if (a3[9])
                        {
                          v31 = 0;
                          v32 = 0;
                          do
                          {
                            v33 = (__int128 *)(a3[4] + v31);
                            v34 = *(_QWORD *)&v55 + v31;
                            v35 = *v33;
                            *(_QWORD *)(v34 + 16) = *((_QWORD *)v33 + 2);
                            *(_OWORD *)v34 = v35;
                            ++v32;
                            v31 += 24;
                          }
                          while (a3[9] > v32);
                        }
                        v36 = 0;
                        v37 = 0;
                        if (v25 <= 1)
                          v38 = 1;
                        else
                          v38 = v25;
                        do
                        {
                          v39 = *(_QWORD *)&v55 + 24 * (v37 + a3[9]);
                          v40 = *(_OWORD *)(v52[0] + v36);
                          *(_QWORD *)(v39 + 16) = *(_QWORD *)(v52[0] + v36 + 16);
                          *(_OWORD *)v39 = v40;
                          ++v37;
                          v36 += 24;
                        }
                        while (v38 != v37);
                        v41 = (float32x2_t)a3[4];
                        a3[4] = 0;
                        v58 = v41;
                        std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v59, (uint64_t)(a3 + 5));
                        v60 = a3[9];
                        std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::operator=[abi:ne180100](a3 + 4, (uint64_t *)&v55);
                        a3[9] = v57;
                        std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)&v55, (uint64_t *)&v58);
                        v57 = v60;
                        std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v58);
                        std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v55);
                      }
                      result = std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](v52);
                      v10 = v43;
                      a2 = v44;
                    }
                  }
                }
              }
            }
          }
        }
      }
      if ((unint64_t)v8 < v13)
      {
        v42 = v8 + 3;
        while (1)
        {
          v8 = v42;
          if ((unint64_t)v42 >= v13)
            break;
          v42 += 3;
          v11 = *v8;
          if (*v8)
            goto LABEL_45;
        }
        v11 = 0;
      }
LABEL_45:
      ;
    }
    while (v8 != v10);
  }
  return result;
}

void sub_2165C79EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t *a16)
{
  std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](a16);
  _Unwind_Resume(a1);
}

void Phase::Geometry::SingleHitRaycastVsVoxelTree(double a1, double a2, double a3, double a4, double a5, float64x2_t a6, uint64_t a7, uint64_t a8, __int128 *a9, _QWORD *a10)
{
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  int64x2_t v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  float v26;
  float *v27;
  uint64_t v28;
  _QWORD v29[2];
  _OWORD v30[2];
  int64x2_t v31;
  unsigned int v32;
  unsigned int v33;

  *((_DWORD *)a9 + 8) = 2139095039;
  *(_QWORD *)((char *)a9 + 36) = 0;
  v10 = (uint64_t)a9 + 36;
  *(_QWORD *)((char *)a9 + 44) = 0;
  *((_DWORD *)a9 + 13) = 0;
  *((_QWORD *)a9 + 7) = 0xFFFFFFFFLL;
  *((_QWORD *)a9 + 8) = 0;
  v11 = a9 + 4;
  v12 = a10[1];
  v13 = **(_QWORD **)(v12 + 120);
  v14 = vdupq_n_s64(0x47EFFFFFE0000000uLL);
  v32 = -1;
  v15 = *a9;
  v16 = a9[1];
  v30[0] = *a9;
  v30[1] = v16;
  v31 = v14;
  v29[0] = &v31;
  v29[1] = v30;
  v17 = *(_QWORD *)(v13 + 48);
  v18 = **(_QWORD **)(v13 + 40);
  v19 = *(_QWORD **)(v18 + 16 * v17);
  if (v19[3])
  {
    v22 = 0;
    do
    {
      v23 = v19[1] + v19[4] * v22;
      if (*(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v23 + 40) + 16 * *(_QWORD *)(v23 + 48)) + 24))
      {
        _ZN5Phase8Geometry7details21RaycastVsVoxelSubtreeILb1ERKZNS0_18RaycastVsVoxelTreeILb1ERZNS0_27SingleHitRaycastVsVoxelTreeERNS0_11SystemStateERNS0_15SceneQueryBatchERNS0_10SceneQueryERNS0_20SceneQueryShapeStateEE3__0EEvS5_RNS0_12RaycastInputERKNS0_5ShapeEOT0_EUlT_SJ_T1_E_EEvS5_SF_RKNS0_12VoxelSubtreeESK_((float32x2_t *)v30, v23, (uint64_t)v29, *(double *)&v15, *(double *)&v16, *(double *)v14.i64, a4, a5, a6);
        v17 = *(_QWORD *)(v13 + 48);
        v18 = **(_QWORD **)(v13 + 40);
      }
      ++v22;
      v19 = *(_QWORD **)(v18 + 16 * v17);
    }
    while (v19[3] > v22);
    v24 = v32;
    if (v32 != -1)
    {
      v25 = *(_QWORD *)(v12 + 8);
      v33 = v32;
      v26 = *(double *)v31.i64;
      *((float *)a9 + 8) = v26;
      *((_QWORD *)a9 + 6) = v25;
      *((_DWORD *)a9 + 14) = v24;
      v27 = (float *)(*a10 + 48);
      v28 = **(_QWORD **)(a10[1] + 120);
      Phase::Geometry::GetNormals(v28, v27, &v33, 1, v10, 1, 1);
      Phase::Geometry::GetMaterials(v28, &v33, 1, v11, 1, 1);
    }
  }
}

float Phase::Geometry::SingleHitRaycastVsVoxelTreeV2(double a1, double a2, double a3, double a4, double a5, float64x2_t a6, uint64_t a7, uint64_t a8, __int128 *a9, _QWORD *a10)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int64x2_t v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  unint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  _QWORD v25[2];
  _OWORD v26[2];
  int64x2_t v27;
  int v28;

  *((_QWORD *)a9 + 5) = 0;
  *((_QWORD *)a9 + 6) = 0;
  *((_QWORD *)a9 + 4) = -2155872257;
  v10 = a10[1];
  v11 = *(_QWORD *)(*a10 + 8);
  v12 = **(_QWORD **)(v10 + 120);
  v13 = vdupq_n_s64(0x47EFFFFFE0000000uLL);
  v28 = -1;
  v14 = *a9;
  v15 = a9[1];
  v26[0] = *a9;
  v26[1] = v15;
  v27 = v13;
  v25[0] = &v27;
  v25[1] = v26;
  v16 = *(_QWORD *)(v12 + 48);
  v17 = **(_QWORD **)(v12 + 40);
  v18 = *(_QWORD **)(v17 + 16 * v16);
  if (v18[3])
  {
    v20 = 0;
    do
    {
      v21 = v18[1] + v18[4] * v20;
      if (*(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v21 + 40) + 16 * *(_QWORD *)(v21 + 48)) + 24))
      {
        _ZN5Phase8Geometry7details21RaycastVsVoxelSubtreeILb1ERKZNS0_18RaycastVsVoxelTreeILb1ERZNS0_27SingleHitRaycastVsVoxelTreeERNS0_11SystemStateERNS0_15SceneQueryBatchERNS0_10SceneQueryERNS0_20SceneQueryShapeStateEE3__0EEvS5_RNS0_12RaycastInputERKNS0_5ShapeEOT0_EUlT_SJ_T1_E_EEvS5_SF_RKNS0_12VoxelSubtreeESK_((float32x2_t *)v26, v21, (uint64_t)v25, *(double *)&v14, *(double *)&v15, *(double *)v13.i64, a4, a5, a6);
        v16 = *(_QWORD *)(v12 + 48);
        v17 = **(_QWORD **)(v12 + 40);
      }
      ++v20;
      v18 = *(_QWORD **)(v17 + 16 * v16);
    }
    while (v18[3] > v20);
    v22 = v28;
    if (v28 != -1)
    {
      v23 = *(_QWORD *)(v10 + 8);
      *(float *)&v14 = *(double *)v27.i64;
      *((_DWORD *)a9 + 8) = v14;
      *((_DWORD *)a9 + 9) = v22;
      *((_QWORD *)a9 + 5) = v23;
      *((_QWORD *)a9 + 6) = v11;
    }
  }
  return *(float *)&v14;
}

void Phase::Geometry::MultiHitRaycastVsVoxelTree(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  float64x2_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  _QWORD v22[3];
  unint64_t v23;
  void *__p;
  _BYTE *v25;
  uint64_t v26;
  uint64_t v27[2];

  v7 = (uint64_t *)(a3 + 32);
  std::unique_ptr<Phase::Geometry::RaycastHit [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)(a3 + 32));
  *(_QWORD *)(a3 + 72) = 0;
  __p = 0;
  v25 = 0;
  v26 = 0;
  v22[0] = &v23;
  v22[1] = a4;
  v22[2] = &__p;
  v23 = 0xBFF0000000000000;
  v14 = *(_QWORD *)(a4 + 8);
  v15 = **(_QWORD **)(v14 + 120);
  v27[0] = (uint64_t)v22;
  v27[1] = v14;
  v16 = *(_QWORD *)(v15 + 48);
  v17 = **(_QWORD **)(v15 + 40);
  v18 = *(_QWORD **)(v17 + 16 * v16);
  if (v18[3])
  {
    v19 = 0;
    do
    {
      v20 = v18[1] + v18[4] * v19;
      if (*(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v20 + 40) + 16 * *(_QWORD *)(v20 + 48)) + 24))
      {
        _ZN5Phase8Geometry7details21RaycastVsVoxelSubtreeILb0ERKZNS0_18RaycastVsVoxelTreeILb0ERZNS0_26MultiHitRaycastVsVoxelTreeERNS0_11SystemStateERNS0_15SceneQueryBatchERNS0_10SceneQueryERNS0_20SceneQueryShapeStateEE3__0EEvS5_RNS0_12RaycastInputERKNS0_5ShapeEOT0_EUlT_SJ_T1_E_EEvS5_SF_RKNS0_12VoxelSubtreeESK_((float32x2_t *)a3, v20, v27, v8, v9, v10, v11, v12, v13);
        v16 = *(_QWORD *)(v15 + 48);
        v17 = **(_QWORD **)(v15 + 40);
      }
      ++v19;
      v18 = *(_QWORD **)(v17 + 16 * v16);
    }
    while (v18[3] > v19);
    v21 = 0xCCCCCCCCCCCCCCCDLL * ((v25 - (_BYTE *)__p) >> 3);
  }
  else
  {
    v21 = 0;
  }
  Phase::Geometry::MergeRaycastQueryHits<Phase::Geometry::RaycastHit,std::vector<Phase::Geometry::RaycastHit>>(a1, v7, &__p, v21);
  if (__p)
  {
    v25 = __p;
    operator delete(__p);
  }
}

void sub_2165C7DC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Phase::Geometry::MultiHitRaycastVsVoxelTreeV2(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  float64x2_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  _QWORD v23[3];
  unint64_t v24;
  uint64_t v25;
  void *__p;
  _BYTE *v27;
  uint64_t v28;
  _QWORD v29[2];

  v7 = (uint64_t *)(a3 + 32);
  std::unique_ptr<Phase::Geometry::RaycastHitV2 [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)(a3 + 32));
  *(_QWORD *)(a3 + 72) = 0;
  __p = 0;
  v27 = 0;
  v28 = 0;
  v14 = a4[1];
  v15 = *(_QWORD *)(*a4 + 8);
  v24 = 0xBFF0000000000000;
  v25 = v15;
  v23[0] = &v24;
  v23[1] = &v25;
  v23[2] = &__p;
  v16 = **(_QWORD **)(v14 + 120);
  v29[0] = v23;
  v29[1] = v14;
  v17 = *(_QWORD *)(v16 + 48);
  v18 = **(_QWORD **)(v16 + 40);
  v19 = *(_QWORD **)(v18 + 16 * v17);
  if (v19[3])
  {
    v20 = 0;
    do
    {
      v21 = v19[1] + v19[4] * v20;
      if (*(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v21 + 40) + 16 * *(_QWORD *)(v21 + 48)) + 24))
      {
        _ZN5Phase8Geometry7details21RaycastVsVoxelSubtreeILb0ERKZNS0_18RaycastVsVoxelTreeILb0ERZNS0_28MultiHitRaycastVsVoxelTreeV2ERNS0_11SystemStateERNS0_15SceneQueryBatchERNS0_10SceneQueryERNS0_20SceneQueryShapeStateEE3__0EEvS5_RNS0_12RaycastInputERKNS0_5ShapeEOT0_EUlT_SJ_T1_E_EEvS5_SF_RKNS0_12VoxelSubtreeESK_((float32x2_t *)a3, v21, (uint64_t)v29, v8, v9, v10, v11, v12, v13);
        v17 = *(_QWORD *)(v16 + 48);
        v18 = **(_QWORD **)(v16 + 40);
      }
      ++v20;
      v19 = *(_QWORD **)(v18 + 16 * v17);
    }
    while (v19[3] > v20);
    v22 = 0xAAAAAAAAAAAAAAABLL * ((v27 - (_BYTE *)__p) >> 3);
  }
  else
  {
    v22 = 0;
  }
  Phase::Geometry::MergeRaycastQueryHits<Phase::Geometry::RaycastHitV2,std::vector<Phase::Geometry::RaycastHitV2>>(a1, v7, &__p, v22);
  if (__p)
  {
    v27 = __p;
    operator delete(__p);
  }
}

void sub_2165C7F18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void _ZN5Phase8Geometry7details21RaycastVsVoxelSubtreeILb1ERKZNS0_18RaycastVsVoxelTreeILb1ERZNS0_27SingleHitRaycastVsVoxelTreeERNS0_11SystemStateERNS0_15SceneQueryBatchERNS0_10SceneQueryERNS0_20SceneQueryShapeStateEE3__0EEvS5_RNS0_12RaycastInputERKNS0_5ShapeEOT0_EUlT_SJ_T1_E_EEvS5_SF_RKNS0_12VoxelSubtreeESK_(float32x2_t *a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, float64x2_t a9)
{
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  unint64_t v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  double v26;
  double v27;
  _QWORD *v29;
  uint64_t v30;
  double *v31;
  float v32;
  size_t v33;
  char *v34;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;
  float64x2_t v38;
  float64x2_t v39;
  float64x2_t v40;
  float64x2_t v41;
  float64x2_t v42;
  float64x2_t v43;
  int8x16_t v44;
  float64x2_t v45;
  double v46;
  double v47;
  float32x2_t *v48;
  float64x2_t v49;
  float64x2_t v50;
  float64x2_t v51;
  float64x2_t v52;
  float64x2_t v53;
  float64x2_t v54;
  int32x4_t v55;
  int32x4_t v56;
  int32x4_t v57;
  int32x4_t v58;
  int64x2_t v59;
  float64x2_t v60;
  float64x2_t v61;
  int64x2_t v62;
  int32x4_t v63;
  unint64_t v64;
  float64x2_t v65;
  float64x2_t v66;
  uint64_t v67;
  int8x16_t v68;
  uint64_t v69;
  float32x2_t *v70;
  int v71;
  char *v72;
  int8x16_t v73;
  int8x16_t v74;
  int64x2_t v75;
  double v76;
  unint64_t *v77;
  unint64_t v78;
  unint64_t v79;
  char *v80;
  int32x4_t v81;
  unsigned __int128 v82;
  int32x4_t v83;
  uint32x4_t v84;
  int32x4_t v85;
  int32x4_t v86;
  int64x2_t v87;
  float64x2_t v88;
  double v89;
  int v90;
  int8x16_t v91;
  int8x16_t v92;
  int8x16_t v93;
  int32x4_t v94;
  float64x2_t v95;
  float64x2_t v96;
  const float *v97;
  int32x4_t v98;
  int32x4_t v99;
  int32x4_t v100;
  unsigned __int8 v101;
  uint8x8_t v102;
  __int32 v103;
  float64x2_t v104;
  int32x4_t v105;
  int32x4_t v106;
  unint64_t *v107;
  unint64_t v108;
  int32x4_t v109;
  unsigned __int128 v110;
  int32x4_t v111;
  int64x2_t v112;
  float64x2_t v113;
  int32x4_t v114;
  int32x4_t v115;
  int8x16_t v116;
  uint32x4_t v117;
  float64x2_t v118;
  float64x2_t v119;
  NSObject *v120;
  double v121;
  double *v122;
  float64x2_t v123;
  float64x2_t v124;
  float64x2_t v125;
  float64x2_t v126;
  int8x16_t v127;
  float64x2_t v128;
  float64x2_t v129;
  float64x2_t v130;
  float64x2_t v131;
  float64x2_t v132;
  float64x2_t v133;
  float64x2_t v134;
  uint8_t buf[4];
  const char *v136;
  __int16 v137;
  int v138;
  __int16 v139;
  int v140;
  uint64_t v141;

  v141 = *MEMORY[0x24BDAC8D0];
  v12 = vcvtq_f64_f32(*a1);
  v10.f64[0] = a1[1].f32[0];
  v13 = vcvtq_f64_f32(a1[2]);
  v9.f64[0] = a1[3].f32[0];
  __asm { FMOV            V16.2D, #1.0 }
  v19 = vminnmq_f64(vmaxnmq_f64(vdivq_f64(_Q16, v13), (float64x2_t)vdupq_n_s64(0xC1EFFFFFFFE00000)), (float64x2_t)vdupq_n_s64(0x41EFFFFFFFE00000uLL));
  v20 = vminnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmaxnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vdivq_f64(_Q16, v9), (float64x2_t)xmmword_2166F8490), (float64x2_t)xmmword_2166F84A0);
  v11.f64[0] = *(float *)(a2 + 8);
  a9.f64[0] = *(float *)(a2 + 20);
  v21 = vmulq_f64(v19, vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)a2), v12));
  v22 = *(_OWORD *)&vmulq_f64(v20, vsubq_f64(v11, v10));
  v23 = vmulq_f64(v19, vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)(a2 + 12)), v12));
  *(_QWORD *)&v20.f64[0] = *(_OWORD *)&vmulq_f64(v20, vsubq_f64(a9, v10));
  *(_QWORD *)&v24.f64[0] = *(_OWORD *)&vminnmq_f64((float64x2_t)v22, (float64x2_t)*(unint64_t *)&v20.f64[0]);
  v24.f64[1] = a1[1].f32[1];
  *(_QWORD *)&v25.f64[0] = *(_OWORD *)&vmaxnmq_f64((float64x2_t)v22, (float64x2_t)*(unint64_t *)&v20.f64[0]);
  v25.f64[1] = a1[3].f32[1];
  v26 = vpmaxq_f64(vmaxnmq_f64(vminnmq_f64(v21, v23), v24));
  v27 = vpminq_f64(vminnmq_f64(vmaxnmq_f64(v21, v23), v25));
  if (v26 <= v27)
  {
    if (v26 >= 0.0 || (v26 = 0.0, v27 > 0.0))
    {
      v29 = *(_QWORD **)(**(_QWORD **)(a2 + 40) + 16 * *(_QWORD *)(a2 + 48));
      v30 = v29[3];
      if ((_DWORD)v30 == 1)
      {
        v31 = *(double **)a3;
        if (**(double **)a3 <= v26)
          return;
        *v31 = v26;
        v31[1] = v27;
        *((_DWORD *)v31 + 4) = 0;
        v32 = v26;
        goto LABEL_27;
      }
      if ((int)v30 > 32)
      {
        v120 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)a1) + 416);
        if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v136 = "GeoRaycastUtility.hpp";
          v137 = 1024;
          v138 = 477;
          v139 = 1024;
          v140 = v30;
          _os_log_impl(&dword_2164CC000, v120, OS_LOG_TYPE_ERROR, "%25s:%-5d Excessive level count (%d) in voxel tree: resolution has an invalid numerical value.", buf, 0x18u);
        }
      }
      else
      {
        v130 = (float64x2_t)xmmword_2166F84A0;
        v131 = (float64x2_t)xmmword_2166F8490;
        v127 = vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL);
        MEMORY[0x24BDAC7A8](a1);
        v34 = (char *)&v123 - v33;
        v133 = v35;
        v134 = v36;
        v132 = v37;
        v128 = v39;
        v129 = v38;
        v123 = v40;
        v124 = v41;
        v125 = v42;
        v126 = v43;
        bzero((char *)&v123 - v33, v33);
        v45.f64[1] = v129.f64[1];
        v46 = v133.f64[0];
        v47 = v134.f64[0];
        v48 = (float32x2_t *)v29[1];
        v49.f64[0] = v48[3].f32[0];
        v50 = vdivq_f64(v132, vcvtq_f64_f32(v48[2]));
        v51 = vdivq_f64(v132, v49);
        v52.f64[0] = v128.f64[0];
        *(_QWORD *)&v52.f64[1] = v127.i64[0];
        v53.f64[0] = 1073741820.0;
        v54 = (float64x2_t)vdupq_n_s64(0x41CFFFFFFF800000uLL);
        v55 = (int32x4_t)vcvtq_s64_f64(vmulq_f64(vminnmq_f64(vmaxnmq_f64(vmulq_f64(vsubq_f64(vmlaq_n_f64(v123, v52, v134.f64[0]), v126), v50), (float64x2_t)0), v132), v54));
        v56 = (int32x4_t)vcvtq_s64_f64(vmulq_f64(vminnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmaxnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmulq_f64(vsubq_f64(vmlaq_f64(v124, v134, v129), v125), v51), (float64x2_t)0), (float64x2_t)xmmword_2166F7480), v53));
        v57 = (int32x4_t)vcvtq_s64_f64(vmulq_f64(vminnmq_f64(vmaxnmq_f64(vmulq_f64(vsubq_f64(vmlaq_n_f64(v123, v52, v133.f64[0]), v126), v50), (float64x2_t)0), v132), v54));
        v58 = (int32x4_t)vcvtq_s64_f64(vmulq_f64(vminnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmaxnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmulq_f64(vsubq_f64(vmlaq_f64(v124, v133, v129), v125), v51), (float64x2_t)0), (float64x2_t)xmmword_2166F7480), v53));
        *(int32x2_t *)&v52.f64[0] = vsub_s32(vmovn_s64((int64x2_t)v57), vmovn_s64((int64x2_t)v55));
        v59.i64[0] = SLODWORD(v52.f64[0]);
        v59.i64[1] = SHIDWORD(v52.f64[0]);
        v60 = vcvtq_f64_s64(v59);
        *(int32x2_t *)&v49.f64[0] = vsub_s32(vmovn_s64((int64x2_t)v58), vmovn_s64((int64x2_t)v56));
        v59.i64[0] = SLODWORD(v49.f64[0]);
        v59.i64[1] = SHIDWORD(v49.f64[0]);
        v61 = vcvtq_f64_s64(v59);
        v62 = vceqzq_f64(v60);
        if ((vandq_s8(vandq_s8((int8x16_t)vdupq_laneq_s64(v62, 1), (int8x16_t)v62), (int8x16_t)vceqzq_f64(v61)).u64[0] & 0x8000000000000000) != 0)
        {
          *(_QWORD *)&v50.f64[1] = vextq_s8((int8x16_t)v50, (int8x16_t)v50, 8uLL).u64[0];
          v61 = vmulq_f64(vmulq_f64(v129, v51), v53);
          v60 = vmulq_f64(vmulq_f64(v128, v50), v54);
        }
        v63 = vuzp1q_s32(v55, v56);
        v64 = vextq_s8((int8x16_t)v60, (int8x16_t)v60, 8uLL).u64[0];
        v65 = vminnmq_f64(vmaxnmq_f64(vdivq_f64(v132, v60), (float64x2_t)vdupq_n_s64(0xC1EFFFFFFFE00000)), (float64x2_t)vdupq_n_s64(0x41EFFFFFFFE00000uLL));
        v66 = vminnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmaxnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vdivq_f64(v132, v61), v131), v130);
        if ((int)v30 >= 1)
        {
          v67 = 0;
          v68 = (int8x16_t)vcltzq_s32(vsubq_s32(vuzp1q_s32(v57, v58), v63));
          v69 = v29[4];
          v70 = v48 + 8;
          v71 = 30;
          do
          {
            v72 = &v34[v67];
            v73 = (int8x16_t)vdupq_n_s32(1 << v71);
            *((_DWORD *)v72 + 52) = v71;
            *((int8x16_t *)v72 + 3) = vorrq_s8(v73, v68);
            v74 = vorrq_s8(vandq_s8((int8x16_t)vdupq_n_s32(-(1 << v71)), v68), vbicq_s8(v73, v68));
            v75.i64[0] = v74.i32[2];
            v75.i64[1] = v74.i32[3];
            *((float64x2_t *)v72 + 9) = vmulq_f64(v66, vcvtq_f64_s64(v75));
            v75.i64[0] = v74.i32[0];
            v75.i64[1] = v74.i32[1];
            *((int8x16_t *)v72 + 7) = v74;
            *((float64x2_t *)v72 + 8) = vmulq_f64(v65, vcvtq_f64_s64(v75));
            *((_QWORD *)v72 + 27) = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)&v70[-1] + 16 * *(_QWORD *)v70) + 8);
            v67 += 224;
            v70 = (float32x2_t *)((char *)v70 + v69);
            v71 -= 2;
          }
          while (224 * v30 != v67);
        }
        v76 = v46 - v47;
        v77 = (unint64_t *)*((_QWORD *)v34 + 27);
        v79 = *v77;
        v78 = v77[1];
        *((_QWORD *)v34 + 28) = v79;
        v80 = v34 + 224;
        v81 = vdupq_n_s32(*((_DWORD *)v80 + 52));
        LODWORD(v53.f64[0]) = *((_DWORD *)v80 + 52);
        v82 = *(_OWORD *)&vshlq_s32(v63, vnegq_s32(v81)) & __PAIR128__(0xFFFFFFFCFFFFFFFCLL, 0xFFFFFFFCFFFFFFFCLL);
        v83.i64[0] = 0x400000004;
        v83.i64[1] = 0x400000004;
        *((uint32x4_t *)v80 + 1) = vshlq_u32((uint32x4_t)v82, (uint32x4_t)v81);
        *((uint32x4_t *)v80 + 2) = vshlq_u32((uint32x4_t)vaddq_s32((int32x4_t)v82, v83), (uint32x4_t)v81);
        v84.i64[0] = -1;
        v84.i64[1] = -1;
        v85 = vaddq_s32((int32x4_t)vandq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshlq_u32(v84, (uint32x4_t)v53), 0), (int8x16_t)v63), *((int32x4_t *)v80 + 3));
        v86 = vsubq_s32(v85, v63);
        v87.i64[0] = v86.i32[2];
        v87.i64[1] = v86.i32[3];
        v88 = vcvtq_f64_s64(v87);
        v87.i64[0] = v86.i32[0];
        v87.i64[1] = v86.i32[1];
        *((float64x2_t *)v80 + 5) = vmulq_f64(v65, vcvtq_f64_s64(v87));
        *((float64x2_t *)v80 + 6) = vmulq_f64(v66, v88);
        *((int32x4_t *)v80 + 4) = v85;
        *((_DWORD *)v80 + 2) = v78;
        v89 = 0.0;
        v90 = 1;
        v91.i64[0] = 0x100000001;
        v91.i64[1] = 0x100000001;
        v92.i64[0] = 0x800000008;
        v92.i64[1] = 0x800000008;
        *(_QWORD *)&v60.f64[1] = v64;
        v93 = (int8x16_t)vdupq_n_s64(0x8000000000000000);
        v94 = v63;
        while (1)
        {
          while (1)
          {
            v95 = *((float64x2_t *)v80 + 5);
            v96 = *((float64x2_t *)v80 + 6);
            v45.f64[0] = fmin(fmin(v95.f64[0], v96.f64[0]), *((double *)v80 + 11));
            v97 = (const float *)(v80 + 208);
            v98 = (int32x4_t)vld1q_dup_f32(v97);
            v99 = vshlq_s32(v94, vnegq_s32(v98));
            v100 = (int32x4_t)vshlq_u32((uint32x4_t)vorrq_s8(vandq_s8((int8x16_t)vshlq_n_s32(v99, 2uLL), v92), vandq_s8((int8x16_t)v99, v91)), (uint32x4_t)xmmword_2166F84B0);
            v101 = vorrq_s8(vorrq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v100.i8, 1), (int8x16_t)vdupq_laneq_s32(v100, 2)), (int8x16_t)v100).u8[0];
            if (((v79 >> v101) & 1) != 0)
              break;
            if (v45.f64[0] >= 1.0)
              return;
            v114 = (int32x4_t)vceqq_f64(v96, v45);
            v115 = (int32x4_t)vceqq_f64(v95, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v45.f64[0], 0));
            v116 = (int8x16_t)vuzp1q_s32(v115, v114);
            *((int32x4_t *)v80 + 10) = v115;
            *((int32x4_t *)v80 + 11) = v114;
            *((int8x16_t *)v80 + 12) = v116;
            v94 = (int32x4_t)vbslq_s8(v116, *((int8x16_t *)v80 + 4), (int8x16_t)vaddq_s32(vuzp1q_s32((int32x4_t)vcvtq_s64_f64(vmulq_n_f64(v60, v45.f64[0])), (int32x4_t)vcvtq_s64_f64(vmulq_f64(v61, v45))), v63));
            while (1)
            {
              v117 = (uint32x4_t)vorrq_s8((int8x16_t)vcgeq_s32(v94, *((int32x4_t *)v80 + 2)), (int8x16_t)vcgtq_s32(*((int32x4_t *)v80 + 1), v94));
              v117.i32[3] = v117.i32[2];
              if ((vmaxvq_u32(v117) & 0x80000000) == 0)
                break;
              if (v90 < 2)
                return;
              --v90;
              v80 -= 224;
            }
            v44.i64[0] = 0x8000000000000000;
            v118 = vaddq_f64(*((float64x2_t *)v80 + 6), (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64((int64x2_t)*((unint64_t *)v80 + 22)), *((int8x16_t *)v80 + 9), v44));
            v119 = vaddq_f64(*((float64x2_t *)v80 + 5), (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(*((int64x2_t *)v80 + 10)), *((int8x16_t *)v80 + 8), v93));
            *((int8x16_t *)v80 + 4) = vbslq_s8(*((int8x16_t *)v80 + 12), (int8x16_t)vaddq_s32(*((int32x4_t *)v80 + 7), *((int32x4_t *)v80 + 4)), *((int8x16_t *)v80 + 4));
            *((float64x2_t *)v80 + 5) = v119;
            *((float64x2_t *)v80 + 6) = v118;
            v79 = *(_QWORD *)v80;
            v89 = v45.f64[0];
          }
          v102 = (uint8x8_t)vcnt_s8((int8x8_t)(v79 & ~(-1 << v101)));
          v102.i16[0] = vaddlv_u8(v102);
          v103 = *((_DWORD *)v80 + 2) + v102.i32[0];
          if ((_DWORD)v30 - 1 == v90)
            break;
          v104 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v45.f64[0], 0);
          v105 = (int32x4_t)vceqq_f64(v96, v45);
          v106 = (int32x4_t)vceqq_f64(v95, v104);
          *((int32x4_t *)v80 + 10) = v106;
          *((int32x4_t *)v80 + 11) = v105;
          *((int32x4_t *)v80 + 12) = vuzp1q_s32(v106, v105);
          v107 = (unint64_t *)(*((_QWORD *)v80 + 27) + 16 * v103);
          v79 = *v107;
          v108 = v107[1];
          *((_QWORD *)v80 + 28) = v79;
          v80 += 224;
          ++v90;
          v109 = vdupq_n_s32(*((_DWORD *)v80 + 52));
          v106.i32[0] = *((_DWORD *)v80 + 52);
          v110 = *(_OWORD *)&vshlq_s32(v94, vnegq_s32(v109)) & __PAIR128__(0xFFFFFFFCFFFFFFFCLL, 0xFFFFFFFCFFFFFFFCLL);
          *((uint32x4_t *)v80 + 1) = vshlq_u32((uint32x4_t)v110, (uint32x4_t)v109);
          *((uint32x4_t *)v80 + 2) = vshlq_u32((uint32x4_t)vaddq_s32((int32x4_t)v110, v83), (uint32x4_t)v109);
          v45 = (float64x2_t)vaddq_s32((int32x4_t)vandq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshlq_u32(v84, (uint32x4_t)v106), 0), (int8x16_t)v94), *((int32x4_t *)v80 + 3));
          v111 = vsubq_s32((int32x4_t)v45, v63);
          v112.i64[0] = v111.i32[2];
          v112.i64[1] = v111.i32[3];
          v113 = vcvtq_f64_s64(v112);
          v112.i64[0] = v111.i32[0];
          v112.i64[1] = v111.i32[1];
          *((float64x2_t *)v80 + 5) = vmulq_f64(v65, vcvtq_f64_s64(v112));
          *((float64x2_t *)v80 + 6) = vmulq_f64(v66, v113);
          *((float64x2_t *)v80 + 4) = v45;
          *((_DWORD *)v80 + 2) = v108;
        }
        v121 = v47 + v76 * v89;
        v122 = *(double **)a3;
        if (**(double **)a3 > v121)
        {
          *v122 = v121;
          v122[1] = v47 + v76 * v45.f64[0];
          *((_DWORD *)v122 + 4) = v103;
          v32 = v121;
LABEL_27:
          *(float *)(*(_QWORD *)(a3 + 8) + 28) = v32;
        }
      }
    }
  }
}

void _ZN5Phase8Geometry7details21RaycastVsVoxelSubtreeILb0ERKZNS0_18RaycastVsVoxelTreeILb0ERZNS0_26MultiHitRaycastVsVoxelTreeERNS0_11SystemStateERNS0_15SceneQueryBatchERNS0_10SceneQueryERNS0_20SceneQueryShapeStateEE3__0EEvS5_RNS0_12RaycastInputERKNS0_5ShapeEOT0_EUlT_SJ_T1_E_EEvS5_SF_RKNS0_12VoxelSubtreeESK_(float32x2_t *a1, uint64_t a2, uint64_t *a3, double a4, double a5, double a6, double a7, double a8, float64x2_t a9)
{
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  unint64_t v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  float64x2_t v26;
  float64x2_t v27;
  float64x2_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  __int128 v39;
  uint64_t v40;
  size_t v41;
  char *v42;
  __int128 v43;
  int32x4_t v44;
  float64x2_t v45;
  float64x2_t v46;
  float64x2_t v47;
  int64x2_t v48;
  float64x2_t v49;
  float32x2_t *v50;
  float64x2_t v51;
  float64x2_t v52;
  float64x2_t v53;
  float64x2_t v54;
  double v55;
  float64x2_t v56;
  float64x2_t v57;
  int32x4_t v58;
  int32x4_t v59;
  int32x4_t v60;
  int32x4_t v61;
  int32x2_t v62;
  int64x2_t v63;
  float64x2_t v64;
  int32x2_t v65;
  float64x2_t v66;
  int64x2_t v67;
  unint64_t v68;
  uint32x4_t v69;
  float64x2_t v70;
  float64x2_t v71;
  uint64_t v72;
  int8x16_t v73;
  uint64_t v74;
  float32x2_t *v75;
  int v76;
  char *v77;
  int8x16_t v78;
  int64x2_t v79;
  float64x2_t v80;
  int32x4_t v81;
  double v82;
  unint64_t *v83;
  unint64_t v84;
  unint64_t v85;
  char *v86;
  int32x4_t v87;
  unsigned __int128 v88;
  float64x2_t v89;
  int32x4_t v90;
  int32x4_t v91;
  int32x4_t v92;
  int64x2_t v93;
  float64x2_t v94;
  double v95;
  int v96;
  int32x4_t v97;
  float64x2_t v98;
  float64x2_t v99;
  const float *v100;
  int32x4_t v101;
  int32x4_t v102;
  int8x16_t v103;
  int8x16_t v104;
  int32x4_t v105;
  unsigned __int8 v106;
  uint8x8_t v107;
  __int32 v108;
  int32x4_t v109;
  int32x4_t v110;
  unint64_t *v111;
  unint64_t v112;
  int32x4_t v113;
  unsigned __int128 v114;
  int32x4_t v115;
  int32x4_t v116;
  int32x4_t v117;
  int64x2_t v118;
  float64x2_t v119;
  double v120;
  uint64_t v121;
  uint64_t v122;
  float v123;
  _QWORD *v124;
  uint64_t v125;
  uint64_t v126;
  unint64_t v127;
  __int128 v128;
  uint64_t v129;
  float64_t v130;
  float64x2_t v131;
  int32x4_t v132;
  int8x16_t v133;
  int32x4_t v134;
  int8x16_t v135;
  int32x4_t v136;
  uint32x4_t v137;
  float64x2_t v138;
  float64x2_t v139;
  NSObject *v140;
  float64x2_t v141;
  float64x2_t v142;
  float64x2_t v143;
  int64x2_t v144;
  int8x16_t v145;
  float64x2_t v146;
  float64x2_t v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  int32x4_t v151;
  float64x2_t v152;
  __int32 v153;
  uint8_t buf[4];
  const char *v155;
  _BYTE v156[20];
  _QWORD v157[4];

  v157[2] = *MEMORY[0x24BDAC8D0];
  v12 = vcvtq_f64_f32(*a1);
  v10.f64[0] = a1[1].f32[0];
  v13 = vcvtq_f64_f32(a1[2]);
  v9.f64[0] = a1[3].f32[0];
  __asm { FMOV            V16.2D, #1.0 }
  v19 = vminnmq_f64(vmaxnmq_f64(vdivq_f64(_Q16, v13), (float64x2_t)vdupq_n_s64(0xC1EFFFFFFFE00000)), (float64x2_t)vdupq_n_s64(0x41EFFFFFFFE00000uLL));
  v20 = vminnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmaxnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vdivq_f64(_Q16, v9), (float64x2_t)xmmword_2166F8490), (float64x2_t)xmmword_2166F84A0);
  v11.f64[0] = *(float *)(a2 + 8);
  a9.f64[0] = *(float *)(a2 + 20);
  v21 = vmulq_f64(v19, vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)a2), v12));
  v22 = *(_OWORD *)&vmulq_f64(v20, vsubq_f64(v11, v10));
  v23 = vmulq_f64(v19, vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)(a2 + 12)), v12));
  *(_QWORD *)&v20.f64[0] = *(_OWORD *)&vmulq_f64(v20, vsubq_f64(a9, v10));
  *(_QWORD *)&v24.f64[0] = *(_OWORD *)&vminnmq_f64((float64x2_t)v22, (float64x2_t)*(unint64_t *)&v20.f64[0]);
  v24.f64[1] = a1[1].f32[1];
  *(_QWORD *)&v25.f64[0] = *(_OWORD *)&vmaxnmq_f64((float64x2_t)v22, (float64x2_t)*(unint64_t *)&v20.f64[0]);
  v25.f64[1] = a1[3].f32[1];
  v26 = vmaxnmq_f64(vminnmq_f64(v21, v23), v24);
  v26.f64[0] = vpmaxq_f64(v26);
  v27 = vminnmq_f64(vmaxnmq_f64(v21, v23), v25);
  v27.f64[0] = vpminq_f64(v27);
  v147 = v26;
  v152 = v27;
  if (v26.f64[0] > v27.f64[0])
    return;
  v29.f64[1] = v147.f64[1];
  if (v147.f64[0] < 0.0)
  {
    v29.f64[0] = 0.0;
    v147 = v29;
    if (v152.f64[0] <= 0.0)
      return;
  }
  v30 = *(_QWORD **)(**(_QWORD **)(a2 + 40) + 16 * *(_QWORD *)(a2 + 48));
  v31 = v30[3];
  if ((_DWORD)v31 == 1)
  {
    v32 = *a3;
    v33 = *(_QWORD *)(a3[1] + 8);
    v153 = 0;
    if (**(double **)v32 != v147.f64[0])
    {
      *(_DWORD *)v156 = 0;
      v155 = 0;
      v157[0] = 0;
      v34 = v147.f64[0];
      *(float *)buf = v34;
      *(_QWORD *)&v156[4] = v33;
      *(_DWORD *)&v156[12] = 0;
      v35 = *(_QWORD **)(v32 + 8);
      v36 = **(_QWORD **)(v35[1] + 120);
      Phase::Geometry::GetNormals(v36, (float *)(*v35 + 48), (unsigned int *)&v153, 1, (uint64_t)&v155, 1, 1);
      Phase::Geometry::GetMaterials(v36, (unsigned int *)&v153, 1, v157, 1, 1);
      v37 = *(_QWORD *)(v32 + 16);
      v38 = *(_QWORD *)(v37 + 8);
      if (v38 >= *(_QWORD *)(v37 + 16))
      {
        v40 = std::vector<Phase::Geometry::RaycastHit>::__push_back_slow_path<Phase::Geometry::RaycastHit const&>(*(uint64_t **)(v32 + 16), (uint64_t)buf);
      }
      else
      {
        *(_DWORD *)v38 = *(_DWORD *)buf;
        *(_QWORD *)(v38 + 4) = v155;
        *(_DWORD *)(v38 + 12) = *(_DWORD *)v156;
        v39 = *(_OWORD *)&v156[4];
        *(_QWORD *)(v38 + 32) = v157[0];
        *(_OWORD *)(v38 + 16) = v39;
        v40 = v38 + 40;
      }
      *(_QWORD *)(v37 + 8) = v40;
      **(_QWORD **)v32 = *(_QWORD *)&v152.f64[0];
    }
    return;
  }
  if ((int)v31 <= 32)
  {
    v148 = xmmword_2166F84A0;
    v149 = xmmword_2166F8490;
    v145 = vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL);
    MEMORY[0x24BDAC7A8](a1);
    v42 = (char *)&v141 - v41;
    v150 = v43;
    v151 = v44;
    v146 = v45;
    v141 = v46;
    v142 = v47;
    v144 = v48;
    v143 = v49;
    bzero((char *)&v141 - v41, v41);
    v50 = (float32x2_t *)v30[1];
    v51.f64[0] = v50[3].f32[0];
    v52 = vdivq_f64((float64x2_t)v150, vcvtq_f64_f32(v50[2]));
    v53 = vdivq_f64((float64x2_t)v150, v51);
    v54.f64[0] = v146.f64[0];
    *(_QWORD *)&v54.f64[1] = v145.i64[0];
    v55 = v147.f64[0];
    v56.f64[0] = 1073741820.0;
    v57 = (float64x2_t)vdupq_n_s64(0x41CFFFFFFF800000uLL);
    v58 = (int32x4_t)vcvtq_s64_f64(vmulq_f64(vminnmq_f64(vmaxnmq_f64(vmulq_f64(vsubq_f64(vmlaq_n_f64(v141, v54, v147.f64[0]), (float64x2_t)v144), v52), (float64x2_t)0), (float64x2_t)v150), v57));
    v59 = (int32x4_t)vcvtq_s64_f64(vmulq_f64(vminnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmaxnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmulq_f64(vsubq_f64(vmlaq_f64(v142, v147, (float64x2_t)v151), v143), v53), (float64x2_t)0), (float64x2_t)xmmword_2166F7480), v56));
    v60 = (int32x4_t)vcvtq_s64_f64(vmulq_f64(vminnmq_f64(vmaxnmq_f64(vmulq_f64(vsubq_f64(vmlaq_n_f64(v141, v54, v152.f64[0]), (float64x2_t)v144), v52), (float64x2_t)0), (float64x2_t)v150), v57));
    v61 = (int32x4_t)vcvtq_s64_f64(vmulq_f64(vminnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmaxnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmulq_f64(vsubq_f64(vmlaq_f64(v142, v152, (float64x2_t)v151), v143), v53), (float64x2_t)0), (float64x2_t)xmmword_2166F7480), v56));
    v62 = vsub_s32(vmovn_s64((int64x2_t)v60), vmovn_s64((int64x2_t)v58));
    v63.i64[0] = v62.i32[0];
    v63.i64[1] = v62.i32[1];
    v64 = vcvtq_f64_s64(v63);
    v65 = vsub_s32(vmovn_s64((int64x2_t)v61), vmovn_s64((int64x2_t)v59));
    v63.i64[0] = v65.i32[0];
    v63.i64[1] = v65.i32[1];
    v66 = vcvtq_f64_s64(v63);
    v67 = vceqzq_f64(v64);
    if ((vandq_s8(vandq_s8((int8x16_t)vdupq_laneq_s64(v67, 1), (int8x16_t)v67), (int8x16_t)vceqzq_f64(v66)).u64[0] & 0x8000000000000000) != 0)
    {
      *(_QWORD *)&v52.f64[1] = vextq_s8((int8x16_t)v52, (int8x16_t)v52, 8uLL).u64[0];
      v66 = vmulq_f64(vmulq_f64((float64x2_t)v151, v53), v56);
      v64 = vmulq_f64(vmulq_f64(v146, v52), v57);
    }
    v151 = vuzp1q_s32(v58, v59);
    v68 = vextq_s8((int8x16_t)v64, (int8x16_t)v64, 8uLL).u64[0];
    v145 = (int8x16_t)v66;
    v69 = (uint32x4_t)(unint64_t)*(_OWORD *)&vmaxnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vdivq_f64((float64x2_t)v150, v66), (float64x2_t)v149);
    v70 = vminnmq_f64(vmaxnmq_f64(vdivq_f64((float64x2_t)v150, v64), (float64x2_t)vdupq_n_s64(0xC1EFFFFFFFE00000)), (float64x2_t)vdupq_n_s64(0x41EFFFFFFFE00000uLL));
    v71 = vminnmq_f64((float64x2_t)v69.u64[0], (float64x2_t)v148);
    if ((int)v31 >= 1)
    {
      v72 = 0;
      v73 = (int8x16_t)vcltzq_s32(vsubq_s32(vuzp1q_s32(v60, v61), v151));
      v74 = v30[4];
      v75 = v50 + 8;
      v76 = 30;
      do
      {
        v77 = &v42[v72];
        v78 = (int8x16_t)vdupq_n_s32(1 << v76);
        *((_DWORD *)v77 + 52) = v76;
        *((int8x16_t *)v77 + 3) = vorrq_s8(v78, v73);
        v69 = (uint32x4_t)vorrq_s8(vandq_s8((int8x16_t)vdupq_n_s32(-(1 << v76)), v73), vbicq_s8(v78, v73));
        v79.i64[0] = v69.i32[2];
        v79.i64[1] = v69.i32[3];
        v80 = vmulq_f64(v71, vcvtq_f64_s64(v79));
        v79.i64[0] = v69.i32[0];
        v79.i64[1] = v69.i32[1];
        *((uint32x4_t *)v77 + 7) = v69;
        *((float64x2_t *)v77 + 8) = vmulq_f64(v70, vcvtq_f64_s64(v79));
        *((float64x2_t *)v77 + 9) = v80;
        *((_QWORD *)v77 + 27) = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)&v75[-1] + 16 * *(_QWORD *)v75) + 8);
        v72 += 224;
        v75 = (float32x2_t *)((char *)v75 + v74);
        v76 -= 2;
      }
      while (224 * v31 != v72);
    }
    v81 = v151;
    v82 = v152.f64[0] - v55;
    v83 = (unint64_t *)*((_QWORD *)v42 + 27);
    v84 = *v83;
    v85 = v83[1];
    *((_QWORD *)v42 + 28) = v84;
    v86 = v42 + 224;
    v87 = vdupq_n_s32(*((_DWORD *)v86 + 52));
    v69.i32[0] = *((_DWORD *)v86 + 52);
    v88 = *(_OWORD *)&vshlq_s32(v81, vnegq_s32(v87)) & __PAIR128__(0xFFFFFFFCFFFFFFFCLL, 0xFFFFFFFCFFFFFFFCLL);
    v89 = (float64x2_t)vshlq_u32((uint32x4_t)v88, (uint32x4_t)v87);
    v90.i64[0] = 0x400000004;
    v90.i64[1] = 0x400000004;
    *((float64x2_t *)v86 + 1) = v89;
    *((uint32x4_t *)v86 + 2) = vshlq_u32((uint32x4_t)vaddq_s32((int32x4_t)v88, v90), (uint32x4_t)v87);
    v87.i64[0] = -1;
    v87.i64[1] = -1;
    v91 = vaddq_s32((int32x4_t)vandq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshlq_u32((uint32x4_t)v87, v69), 0), (int8x16_t)v81), *((int32x4_t *)v86 + 3));
    v92 = vsubq_s32(v91, v81);
    v93.i64[0] = v92.i32[2];
    v93.i64[1] = v92.i32[3];
    v94 = vcvtq_f64_s64(v93);
    v93.i64[0] = v92.i32[0];
    v93.i64[1] = v92.i32[1];
    v148 = (__int128)v71;
    v149 = (__int128)v70;
    *((float64x2_t *)v86 + 5) = vmulq_f64(v70, vcvtq_f64_s64(v93));
    *((float64x2_t *)v86 + 6) = vmulq_f64(v71, v94);
    *((int32x4_t *)v86 + 4) = v91;
    *((_DWORD *)v86 + 2) = v85;
    v95 = 0.0;
    v96 = 1;
    v150 = xmmword_2166F84B0;
    *(_QWORD *)&v64.f64[1] = v68;
    v146 = v64;
    v144 = vdupq_n_s64(0x8000000000000000);
    v97 = v81;
    while (1)
    {
      v98 = *((float64x2_t *)v86 + 5);
      v99 = *((float64x2_t *)v86 + 6);
      v89.f64[0] = fmin(fmin(v98.f64[0], v99.f64[0]), *((double *)v86 + 11));
      v152 = v89;
      v100 = (const float *)(v86 + 208);
      v101 = (int32x4_t)vld1q_dup_f32(v100);
      v102 = vshlq_s32(v97, vnegq_s32(v101));
      v103.i64[0] = 0x100000001;
      v103.i64[1] = 0x100000001;
      v104.i64[0] = 0x800000008;
      v104.i64[1] = 0x800000008;
      v105 = (int32x4_t)vshlq_u32((uint32x4_t)vorrq_s8(vandq_s8((int8x16_t)vshlq_n_s32(v102, 2uLL), v104), vandq_s8((int8x16_t)v102, v103)), (uint32x4_t)v150);
      v106 = vorrq_s8(vorrq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v105.i8, 1), (int8x16_t)vdupq_laneq_s32(v105, 2)), (int8x16_t)v105).u8[0];
      if (((v84 >> v106) & 1) == 0)
        goto LABEL_23;
      v107 = (uint8x8_t)vcnt_s8((int8x8_t)(v84 & ~(-1 << v106)));
      v107.i16[0] = vaddlv_u8(v107);
      v108 = *((_DWORD *)v86 + 2) + v107.i32[0];
      if ((_DWORD)v31 - 1 == v96)
      {
        v120 = v147.f64[0] + v82 * v95;
        v121 = *a3;
        v122 = *(_QWORD *)(a3[1] + 8);
        v153 = *((_DWORD *)v86 + 2) + v107.i32[0];
        if (**(double **)v121 != v120)
        {
          *(_DWORD *)v156 = 0;
          v155 = 0;
          v157[0] = 0;
          v123 = v120;
          *(float *)buf = v123;
          *(_QWORD *)&v156[4] = v122;
          *(_DWORD *)&v156[12] = v108;
          v124 = *(_QWORD **)(v121 + 8);
          v125 = **(_QWORD **)(v124[1] + 120);
          Phase::Geometry::GetNormals(v125, (float *)(*v124 + 48), (unsigned int *)&v153, 1, (uint64_t)&v155, 1, 1);
          Phase::Geometry::GetMaterials(v125, (unsigned int *)&v153, 1, v157, 1, 1);
          v126 = *(_QWORD *)(v121 + 16);
          v127 = *(_QWORD *)(v126 + 8);
          if (v127 >= *(_QWORD *)(v126 + 16))
          {
            v129 = std::vector<Phase::Geometry::RaycastHit>::__push_back_slow_path<Phase::Geometry::RaycastHit const&>(*(uint64_t **)(v121 + 16), (uint64_t)buf);
          }
          else
          {
            *(_DWORD *)v127 = *(_DWORD *)buf;
            *(_QWORD *)(v127 + 4) = v155;
            *(_DWORD *)(v127 + 12) = *(_DWORD *)v156;
            v128 = *(_OWORD *)&v156[4];
            *(_QWORD *)(v127 + 32) = v157[0];
            *(_OWORD *)(v127 + 16) = v128;
            v129 = v127 + 40;
          }
          v130 = v147.f64[0] + v82 * v152.f64[0];
          *(_QWORD *)(v126 + 8) = v129;
          **(float64_t **)v121 = v130;
        }
LABEL_23:
        if (v152.f64[0] >= 1.0)
          return;
        v131 = v152;
        v132 = (int32x4_t)vceqq_f64(*((float64x2_t *)v86 + 6), v152);
        v133 = *((int8x16_t *)v86 + 4);
        v134 = (int32x4_t)vceqq_f64(*((float64x2_t *)v86 + 5), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v152.f64[0], 0));
        v135 = (int8x16_t)vuzp1q_s32(v134, v132);
        *((int32x4_t *)v86 + 10) = v134;
        *((int32x4_t *)v86 + 11) = v132;
        v136 = vuzp1q_s32((int32x4_t)vcvtq_s64_f64(vmulq_n_f64(v146, v131.f64[0])), (int32x4_t)vcvtq_s64_f64(vmulq_f64((float64x2_t)v145, v131)));
        *((int8x16_t *)v86 + 12) = v135;
        v97 = (int32x4_t)vbslq_s8(v135, v133, (int8x16_t)vaddq_s32(v136, v151));
        while (1)
        {
          v137 = (uint32x4_t)vorrq_s8((int8x16_t)vcgeq_s32(v97, *((int32x4_t *)v86 + 2)), (int8x16_t)vcgtq_s32(*((int32x4_t *)v86 + 1), v97));
          v137.i32[3] = v137.i32[2];
          if ((vmaxvq_u32(v137) & 0x80000000) == 0)
            break;
          if (v96 < 2)
            return;
          --v96;
          v86 -= 224;
        }
        v89 = *((float64x2_t *)v86 + 6);
        v90.i64[0] = 0x8000000000000000;
        v138 = vaddq_f64(v89, (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64((int64x2_t)*((unint64_t *)v86 + 22)), *((int8x16_t *)v86 + 9), (int8x16_t)v90));
        v139 = vaddq_f64(*((float64x2_t *)v86 + 5), (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(*((int64x2_t *)v86 + 10)), *((int8x16_t *)v86 + 8), (int8x16_t)v144));
        *((int8x16_t *)v86 + 4) = vbslq_s8(*((int8x16_t *)v86 + 12), (int8x16_t)vaddq_s32(*((int32x4_t *)v86 + 7), *((int32x4_t *)v86 + 4)), *((int8x16_t *)v86 + 4));
        *((float64x2_t *)v86 + 5) = v139;
        *((float64x2_t *)v86 + 6) = v138;
        v84 = *(_QWORD *)v86;
        v95 = v152.f64[0];
      }
      else
      {
        v109 = (int32x4_t)vceqq_f64(v99, v152);
        v110 = (int32x4_t)vceqq_f64(v98, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v152.f64[0], 0));
        *((int32x4_t *)v86 + 10) = v110;
        *((int32x4_t *)v86 + 11) = v109;
        *((int32x4_t *)v86 + 12) = vuzp1q_s32(v110, v109);
        v111 = (unint64_t *)(*((_QWORD *)v86 + 27) + 16 * v108);
        v84 = *v111;
        v112 = v111[1];
        *((_QWORD *)v86 + 28) = v84;
        v86 += 224;
        ++v96;
        v113 = vdupq_n_s32(*((_DWORD *)v86 + 52));
        v109.i32[0] = *((_DWORD *)v86 + 52);
        v114 = *(_OWORD *)&vshlq_s32(v97, vnegq_s32(v113)) & __PAIR128__(0xFFFFFFFCFFFFFFFCLL, 0xFFFFFFFCFFFFFFFCLL);
        v115.i64[0] = 0x400000004;
        v115.i64[1] = 0x400000004;
        *((uint32x4_t *)v86 + 1) = vshlq_u32((uint32x4_t)v114, (uint32x4_t)v113);
        *((uint32x4_t *)v86 + 2) = vshlq_u32((uint32x4_t)vaddq_s32((int32x4_t)v114, v115), (uint32x4_t)v113);
        v113.i64[0] = -1;
        v113.i64[1] = -1;
        v116 = vaddq_s32((int32x4_t)vandq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshlq_u32((uint32x4_t)v113, (uint32x4_t)v109), 0), (int8x16_t)v97), *((int32x4_t *)v86 + 3));
        v117 = vsubq_s32(v116, v151);
        v118.i64[0] = v117.i32[2];
        v118.i64[1] = v117.i32[3];
        v119 = vcvtq_f64_s64(v118);
        v118.i64[0] = v117.i32[0];
        v118.i64[1] = v117.i32[1];
        v89 = vmulq_f64((float64x2_t)v148, v119);
        *((float64x2_t *)v86 + 5) = vmulq_f64((float64x2_t)v149, vcvtq_f64_s64(v118));
        *((float64x2_t *)v86 + 6) = v89;
        *((int32x4_t *)v86 + 4) = v116;
        *((_DWORD *)v86 + 2) = v112;
      }
    }
  }
  v140 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)a1) + 416);
  if (os_log_type_enabled(v140, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315650;
    v155 = "GeoRaycastUtility.hpp";
    *(_WORD *)v156 = 1024;
    *(_DWORD *)&v156[2] = 477;
    *(_WORD *)&v156[6] = 1024;
    *(_DWORD *)&v156[8] = v31;
    _os_log_impl(&dword_2164CC000, v140, OS_LOG_TYPE_ERROR, "%25s:%-5d Excessive level count (%d) in voxel tree: resolution has an invalid numerical value.", buf, 0x18u);
  }
}

void _ZN5Phase8Geometry7details21RaycastVsVoxelSubtreeILb0ERKZNS0_18RaycastVsVoxelTreeILb0ERZNS0_28MultiHitRaycastVsVoxelTreeV2ERNS0_11SystemStateERNS0_15SceneQueryBatchERNS0_10SceneQueryERNS0_20SceneQueryShapeStateEE3__0EEvS5_RNS0_12RaycastInputERKNS0_5ShapeEOT0_EUlT_SJ_T1_E_EEvS5_SF_RKNS0_12VoxelSubtreeESK_(float32x2_t *a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, float64x2_t a9)
{
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  unint64_t v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  float64x2_t v26;
  double v27;
  float64x2_t v28;
  _QWORD *v30;
  uint64_t v31;
  double **v32;
  uint64_t v33;
  float v34;
  double *v35;
  uint64_t v36;
  float *v37;
  unint64_t v38;
  float *v39;
  size_t v40;
  char *v41;
  float64x2_t v42;
  float64x2_t v43;
  float64x2_t v44;
  float64x2_t v45;
  float64x2_t v46;
  float64x2_t v47;
  float64x2_t v48;
  float64x2_t v49;
  float64x2_t v50;
  float64x2_t v51;
  double v52;
  double v53;
  float32x2_t *v54;
  float64x2_t v55;
  float64x2_t v56;
  float64x2_t v57;
  float64x2_t v58;
  float64x2_t v59;
  float64x2_t v60;
  int32x4_t v61;
  int32x4_t v62;
  int32x4_t v63;
  int32x4_t v64;
  int32x2_t v65;
  int64x2_t v66;
  float64x2_t v67;
  int32x2_t v68;
  float64x2_t v69;
  int64x2_t v70;
  int8x16_t v71;
  int32x4_t v72;
  unint64_t v73;
  uint32x4_t v74;
  float64x2_t v75;
  float64x2_t v76;
  int v77;
  uint64_t v78;
  int8x16_t v79;
  uint64_t v80;
  float32x2_t *v81;
  int v82;
  char *v83;
  int8x16_t v84;
  int64x2_t v85;
  float64x2_t v86;
  double v87;
  unint64_t *v88;
  unint64_t v89;
  unint64_t v90;
  char *v91;
  int32x4_t v92;
  unsigned __int128 v93;
  int32x4_t v94;
  uint32x4_t v95;
  int32x4_t v96;
  int32x4_t v97;
  int64x2_t v98;
  float64x2_t v99;
  double v100;
  int v101;
  int8x16_t v102;
  int8x16_t v103;
  uint32x4_t v104;
  int8x16_t v105;
  int32x4_t v106;
  float64x2_t v107;
  float64x2_t v108;
  const float *v109;
  int32x4_t v110;
  int32x4_t v111;
  int32x4_t v112;
  unsigned __int8 v113;
  uint8x8_t v114;
  __int32 v115;
  int32x4_t v116;
  int32x4_t v117;
  unint64_t *v118;
  unint64_t v119;
  int32x4_t v120;
  unsigned __int128 v121;
  int32x4_t v122;
  int32x4_t v123;
  int64x2_t v124;
  float64x2_t v125;
  double v126;
  double **v127;
  float64_t v128;
  float v129;
  double *v130;
  uint64_t v131;
  float *v132;
  unint64_t v133;
  float *v134;
  float *v135;
  unint64_t v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t v139;
  char *v140;
  char *v141;
  char *v142;
  char *v143;
  __int128 v144;
  int32x4_t v145;
  int8x16_t v146;
  int32x4_t v147;
  int8x16_t v148;
  uint32x4_t v149;
  float64x2_t v150;
  float64x2_t v151;
  NSObject *v152;
  float *v153;
  unint64_t v154;
  unint64_t v155;
  unint64_t v156;
  unint64_t v157;
  char *v158;
  char *v159;
  char *v160;
  __int128 v161;
  float64x2_t v162;
  float64x2_t v163;
  float64x2_t v164;
  float64x2_t v165;
  int8x16_t v166;
  float64x2_t v167;
  float64x2_t v168;
  __int128 v169;
  float64x2_t v170;
  float64x2_t v171;
  float64x2_t v172;
  float64x2_t v173;
  uint8_t buf[4];
  const char *v175;
  __int16 v176;
  int v177;
  __int16 v178;
  int v179;
  uint64_t v180;

  v180 = *MEMORY[0x24BDAC8D0];
  v12 = vcvtq_f64_f32(*a1);
  v10.f64[0] = a1[1].f32[0];
  v13 = vcvtq_f64_f32(a1[2]);
  v9.f64[0] = a1[3].f32[0];
  __asm { FMOV            V16.2D, #1.0 }
  v19 = vminnmq_f64(vmaxnmq_f64(vdivq_f64(_Q16, v13), (float64x2_t)vdupq_n_s64(0xC1EFFFFFFFE00000)), (float64x2_t)vdupq_n_s64(0x41EFFFFFFFE00000uLL));
  v20 = vminnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmaxnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vdivq_f64(_Q16, v9), (float64x2_t)xmmword_2166F8490), (float64x2_t)xmmword_2166F84A0);
  v11.f64[0] = *(float *)(a2 + 8);
  a9.f64[0] = *(float *)(a2 + 20);
  v21 = vmulq_f64(v19, vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)a2), v12));
  v22 = *(_OWORD *)&vmulq_f64(v20, vsubq_f64(v11, v10));
  v23 = vmulq_f64(v19, vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)(a2 + 12)), v12));
  *(_QWORD *)&v20.f64[0] = *(_OWORD *)&vmulq_f64(v20, vsubq_f64(a9, v10));
  v24 = vminnmq_f64(v21, v23);
  *(_QWORD *)&v25.f64[0] = *(_OWORD *)&vminnmq_f64((float64x2_t)v22, (float64x2_t)*(unint64_t *)&v20.f64[0]);
  v25.f64[1] = a1[1].f32[1];
  *(_QWORD *)&v26.f64[0] = *(_OWORD *)&vmaxnmq_f64((float64x2_t)v22, (float64x2_t)*(unint64_t *)&v20.f64[0]);
  v26.f64[1] = a1[3].f32[1];
  v28 = vmaxnmq_f64(v21, v23);
  v27 = vpmaxq_f64(vmaxnmq_f64(v24, v25));
  v28.f64[0] = vpminq_f64(vminnmq_f64(v28, v26));
  if (v27 > v28.f64[0])
    return;
  if (v27 < 0.0)
  {
    v27 = 0.0;
    if (v28.f64[0] <= 0.0)
      return;
  }
  v30 = *(_QWORD **)(**(_QWORD **)(a2 + 40) + 16 * *(_QWORD *)(a2 + 48));
  v31 = v30[3];
  if ((_DWORD)v31 == 1)
  {
    v32 = *(double ***)a3;
    if (***(double ***)a3 != v27)
    {
      v33 = *(_QWORD *)(*(_QWORD *)(a3 + 8) + 8);
      v34 = v27;
      v35 = v32[2];
      v36 = *(_QWORD *)v32[1];
      v37 = (float *)*((_QWORD *)v35 + 1);
      v38 = *((_QWORD *)v35 + 2);
      if ((unint64_t)v37 >= v38)
      {
        v153 = *(float **)v35;
        v154 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v37 - *(_QWORD *)v35) >> 3);
        v155 = v154 + 1;
        if (v154 + 1 > 0xAAAAAAAAAAAAAAALL)
          std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
        v173 = v28;
        v156 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v38 - (_QWORD)v153) >> 3);
        if (2 * v156 > v155)
          v155 = 2 * v156;
        if (v156 >= 0x555555555555555)
          v157 = 0xAAAAAAAAAAAAAAALL;
        else
          v157 = v155;
        if (v157)
        {
          v158 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)(v35 + 2), v157);
          v153 = *(float **)v35;
          v37 = (float *)*((_QWORD *)v35 + 1);
        }
        else
        {
          v158 = 0;
        }
        v159 = &v158[24 * v154];
        *(float *)v159 = v34;
        *((_DWORD *)v159 + 1) = 0;
        v160 = &v158[24 * v157];
        *((_QWORD *)v159 + 1) = v33;
        *((_QWORD *)v159 + 2) = v36;
        v39 = (float *)(v159 + 24);
        if (v37 != v153)
        {
          do
          {
            v161 = *(_OWORD *)(v37 - 6);
            *((_QWORD *)v159 - 1) = *((_QWORD *)v37 - 1);
            *(_OWORD *)(v159 - 24) = v161;
            v159 -= 24;
            v37 -= 6;
          }
          while (v37 != v153);
          v153 = *(float **)v35;
        }
        *(_QWORD *)v35 = v159;
        *((_QWORD *)v35 + 1) = v39;
        *((_QWORD *)v35 + 2) = v160;
        if (v153)
          operator delete(v153);
        v28.f64[0] = v173.f64[0];
      }
      else
      {
        *v37 = v34;
        v37[1] = 0.0;
        v39 = v37 + 6;
        *((_QWORD *)v37 + 1) = v33;
        *((_QWORD *)v37 + 2) = v36;
      }
      *((_QWORD *)v35 + 1) = v39;
      **v32 = v28.f64[0];
    }
    return;
  }
  if ((int)v31 <= 32)
  {
    v169 = xmmword_2166F84A0;
    v170 = (float64x2_t)xmmword_2166F8490;
    v166 = vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL);
    MEMORY[0x24BDAC7A8](a1);
    v41 = (char *)&v162 - v40;
    v172 = v43;
    v173 = v42;
    v171 = v44;
    v168 = v45;
    v167 = v46;
    v162 = v47;
    v163 = v48;
    v165 = v49;
    v164 = v50;
    bzero((char *)&v162 - v40, v40);
    v52 = v172.f64[0];
    v53 = v173.f64[0];
    v54 = (float32x2_t *)v30[1];
    v55.f64[0] = v54[3].f32[0];
    v56 = vdivq_f64(v171, vcvtq_f64_f32(v54[2]));
    v57 = vdivq_f64(v171, v55);
    v58.f64[0] = v167.f64[0];
    *(_QWORD *)&v58.f64[1] = v166.i64[0];
    v59.f64[0] = 1073741820.0;
    v60 = (float64x2_t)vdupq_n_s64(0x41CFFFFFFF800000uLL);
    v61 = (int32x4_t)vcvtq_s64_f64(vmulq_f64(vminnmq_f64(vmaxnmq_f64(vmulq_f64(vsubq_f64(vmlaq_n_f64(v162, v58, v172.f64[0]), v165), v56), (float64x2_t)0), v171), v60));
    v62 = (int32x4_t)vcvtq_s64_f64(vmulq_f64(vminnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmaxnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmulq_f64(vsubq_f64(vmlaq_f64(v163, v172, v168), v164), v57), (float64x2_t)0), (float64x2_t)xmmword_2166F7480), v59));
    v63 = (int32x4_t)vcvtq_s64_f64(vmulq_f64(vminnmq_f64(vmaxnmq_f64(vmulq_f64(vsubq_f64(vmlaq_n_f64(v162, v58, v173.f64[0]), v165), v56), (float64x2_t)0), v171), v60));
    v64 = (int32x4_t)vcvtq_s64_f64(vmulq_f64(vminnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmaxnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmulq_f64(vsubq_f64(vmlaq_f64(v163, v173, v168), v164), v57), (float64x2_t)0), (float64x2_t)xmmword_2166F7480), v59));
    v65 = vsub_s32(vmovn_s64((int64x2_t)v63), vmovn_s64((int64x2_t)v61));
    v66.i64[0] = v65.i32[0];
    v66.i64[1] = v65.i32[1];
    v67 = vcvtq_f64_s64(v66);
    v68 = vsub_s32(vmovn_s64((int64x2_t)v64), vmovn_s64((int64x2_t)v62));
    v66.i64[0] = v68.i32[0];
    v66.i64[1] = v68.i32[1];
    v69 = vcvtq_f64_s64(v66);
    v70 = vceqzq_f64(v67);
    v71 = vandq_s8(vandq_s8((int8x16_t)vdupq_laneq_s64(v70, 1), (int8x16_t)v70), (int8x16_t)vceqzq_f64(v69));
    if (v71.i64[0] < 0)
    {
      v71 = vextq_s8((int8x16_t)v56, (int8x16_t)v56, 8uLL);
      *(_QWORD *)&v56.f64[1] = v71.i64[0];
      v69 = vmulq_f64(vmulq_f64(v168, v57), v59);
      v67 = vmulq_f64(vmulq_f64(v167, v56), v60);
    }
    v72 = vuzp1q_s32(v61, v62);
    v73 = vextq_s8((int8x16_t)v67, (int8x16_t)v67, 8uLL).u64[0];
    v74 = (uint32x4_t)(unint64_t)*(_OWORD *)&vmaxnmq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vdivq_f64(v171, v69), v170);
    v75 = vminnmq_f64(vmaxnmq_f64(vdivq_f64(v171, v67), (float64x2_t)vdupq_n_s64(0xC1EFFFFFFFE00000)), (float64x2_t)vdupq_n_s64(0x41EFFFFFFFE00000uLL));
    v76 = vminnmq_f64((float64x2_t)v74.u64[0], (float64x2_t)v169);
    v77 = v31 - 1;
    if ((int)v31 >= 1)
    {
      v78 = 0;
      v79 = (int8x16_t)vcltzq_s32(vsubq_s32(vuzp1q_s32(v63, v64), v72));
      v80 = v30[4];
      v81 = v54 + 8;
      v82 = 30;
      do
      {
        v83 = &v41[v78];
        v84 = (int8x16_t)vdupq_n_s32(1 << v82);
        *((_DWORD *)v83 + 52) = v82;
        *((int8x16_t *)v83 + 3) = vorrq_s8(v84, v79);
        v74 = (uint32x4_t)vorrq_s8(vandq_s8((int8x16_t)vdupq_n_s32(-(1 << v82)), v79), vbicq_s8(v84, v79));
        v85.i64[0] = v74.i32[2];
        v85.i64[1] = v74.i32[3];
        v86 = vmulq_f64(v76, vcvtq_f64_s64(v85));
        v85.i64[0] = v74.i32[0];
        v85.i64[1] = v74.i32[1];
        *((uint32x4_t *)v83 + 7) = v74;
        *((float64x2_t *)v83 + 8) = vmulq_f64(v75, vcvtq_f64_s64(v85));
        *((float64x2_t *)v83 + 9) = v86;
        *((_QWORD *)v83 + 27) = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)&v81[-1] + 16 * *(_QWORD *)v81) + 8);
        v78 += 224;
        v81 = (float32x2_t *)((char *)v81 + v80);
        v82 -= 2;
      }
      while (224 * v31 != v78);
    }
    v87 = v53 - v52;
    v88 = (unint64_t *)*((_QWORD *)v41 + 27);
    v89 = *v88;
    v90 = v88[1];
    *((_QWORD *)v41 + 28) = v89;
    v91 = v41 + 224;
    v92 = vdupq_n_s32(*((_DWORD *)v91 + 52));
    v74.i32[0] = *((_DWORD *)v91 + 52);
    v93 = *(_OWORD *)&vshlq_s32(v72, vnegq_s32(v92)) & __PAIR128__(0xFFFFFFFCFFFFFFFCLL, 0xFFFFFFFCFFFFFFFCLL);
    v94.i64[0] = 0x400000004;
    v94.i64[1] = 0x400000004;
    *((uint32x4_t *)v91 + 1) = vshlq_u32((uint32x4_t)v93, (uint32x4_t)v92);
    *((uint32x4_t *)v91 + 2) = vshlq_u32((uint32x4_t)vaddq_s32((int32x4_t)v93, v94), (uint32x4_t)v92);
    v95.i64[0] = -1;
    v95.i64[1] = -1;
    v96 = vaddq_s32((int32x4_t)vandq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshlq_u32(v95, v74), 0), (int8x16_t)v72), *((int32x4_t *)v91 + 3));
    v97 = vsubq_s32(v96, v72);
    v98.i64[0] = v97.i32[2];
    v98.i64[1] = v97.i32[3];
    v99 = vcvtq_f64_s64(v98);
    v98.i64[0] = v97.i32[0];
    v98.i64[1] = v97.i32[1];
    *((float64x2_t *)v91 + 5) = vmulq_f64(v75, vcvtq_f64_s64(v98));
    *((float64x2_t *)v91 + 6) = vmulq_f64(v76, v99);
    *((int32x4_t *)v91 + 4) = v96;
    *((_DWORD *)v91 + 2) = v90;
    v100 = 0.0;
    v101 = 1;
    v102.i64[0] = 0x100000001;
    v102.i64[1] = 0x100000001;
    v103.i64[0] = 0x800000008;
    v103.i64[1] = 0x800000008;
    v104 = (uint32x4_t)xmmword_2166F84B0;
    *(_QWORD *)&v67.f64[1] = v73;
    v105 = (int8x16_t)vdupq_n_s64(0x8000000000000000);
    v106 = v72;
    while (1)
    {
      v107 = *((float64x2_t *)v91 + 5);
      v108 = *((float64x2_t *)v91 + 6);
      v51.f64[0] = fmin(fmin(v107.f64[0], v108.f64[0]), *((double *)v91 + 11));
      v109 = (const float *)(v91 + 208);
      v110 = (int32x4_t)vld1q_dup_f32(v109);
      v111 = vshlq_s32(v106, vnegq_s32(v110));
      v112 = (int32x4_t)vshlq_u32((uint32x4_t)vorrq_s8(vandq_s8((int8x16_t)vshlq_n_s32(v111, 2uLL), v103), vandq_s8((int8x16_t)v111, v102)), v104);
      v113 = vorrq_s8(vorrq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v112.i8, 1), (int8x16_t)vdupq_laneq_s32(v112, 2)), (int8x16_t)v112).u8[0];
      if (((v89 >> v113) & 1) == 0)
        goto LABEL_38;
      v114 = (uint8x8_t)vcnt_s8((int8x8_t)(v89 & ~(-1 << v113)));
      v114.i16[0] = vaddlv_u8(v114);
      v115 = *((_DWORD *)v91 + 2) + v114.i32[0];
      if (v77 == v101)
      {
        v126 = v52 + v87 * v100;
        v127 = *(double ***)a3;
        if (***(double ***)a3 != v126)
        {
          v128 = *(double *)(*(_QWORD *)(a3 + 8) + 8);
          v129 = v126;
          v130 = v127[2];
          v131 = *(_QWORD *)v127[1];
          v132 = (float *)*((_QWORD *)v130 + 1);
          v133 = *((_QWORD *)v130 + 2);
          if ((unint64_t)v132 >= v133)
          {
            v135 = *(float **)v130;
            v136 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v132 - *(_QWORD *)v130) >> 3);
            v137 = v136 + 1;
            if (v136 + 1 > 0xAAAAAAAAAAAAAAALL)
              std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
            v165 = v51;
            v166 = v105;
            v167 = (float64x2_t)v104;
            v168 = v76;
            v169 = (__int128)v75;
            v170 = (float64x2_t)v72;
            v171 = v69;
            v173 = v67;
            v138 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v133 - (_QWORD)v135) >> 3);
            if (2 * v138 > v137)
              v137 = 2 * v138;
            if (v138 >= 0x555555555555555)
              v139 = 0xAAAAAAAAAAAAAAALL;
            else
              v139 = v137;
            if (v139)
            {
              v164.f64[0] = v128;
              v140 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)(v130 + 2), v139);
              v128 = v164.f64[0];
              v141 = v140;
              v135 = *(float **)v130;
              v132 = (float *)*((_QWORD *)v130 + 1);
            }
            else
            {
              v141 = 0;
            }
            v142 = &v141[24 * v136];
            *(float *)v142 = v129;
            *((_DWORD *)v142 + 1) = v115;
            *((float64_t *)v142 + 1) = v128;
            *((_QWORD *)v142 + 2) = v131;
            v143 = v142;
            if (v132 != v135)
            {
              do
              {
                v144 = *(_OWORD *)(v132 - 6);
                *((_QWORD *)v143 - 1) = *((_QWORD *)v132 - 1);
                *(_OWORD *)(v143 - 24) = v144;
                v143 -= 24;
                v132 -= 6;
              }
              while (v132 != v135);
              v135 = *(float **)v130;
            }
            v134 = (float *)(v142 + 24);
            *(_QWORD *)v130 = v143;
            *((_QWORD *)v130 + 1) = v142 + 24;
            *((_QWORD *)v130 + 2) = &v141[24 * v139];
            if (v135)
              operator delete(v135);
            v52 = v172.f64[0];
            v67 = v173;
            v72 = (int32x4_t)v170;
            v69 = v171;
            v76 = v168;
            v75 = (float64x2_t)v169;
            v94.i64[0] = 0x400000004;
            v94.i64[1] = 0x400000004;
            v95.i64[0] = -1;
            v95.i64[1] = -1;
            v102.i64[0] = 0x100000001;
            v102.i64[1] = 0x100000001;
            v103.i64[0] = 0x800000008;
            v103.i64[1] = 0x800000008;
            v104 = (uint32x4_t)v167;
            v105 = v166;
            v51 = v165;
          }
          else
          {
            *v132 = v129;
            *((_DWORD *)v132 + 1) = v115;
            v134 = v132 + 6;
            *((float64_t *)v132 + 1) = v128;
            *((_QWORD *)v132 + 2) = v131;
          }
          *((_QWORD *)v130 + 1) = v134;
          **v127 = v52 + v87 * v51.f64[0];
        }
LABEL_38:
        if (v51.f64[0] >= 1.0)
          return;
        v145 = (int32x4_t)vceqq_f64(*((float64x2_t *)v91 + 6), v51);
        v146 = *((int8x16_t *)v91 + 4);
        v147 = (int32x4_t)vceqq_f64(*((float64x2_t *)v91 + 5), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v51.f64[0], 0));
        v148 = (int8x16_t)vuzp1q_s32(v147, v145);
        *((int32x4_t *)v91 + 10) = v147;
        *((int32x4_t *)v91 + 11) = v145;
        *((int8x16_t *)v91 + 12) = v148;
        v106 = (int32x4_t)vbslq_s8(v148, v146, (int8x16_t)vaddq_s32(vuzp1q_s32((int32x4_t)vcvtq_s64_f64(vmulq_n_f64(v67, v51.f64[0])), (int32x4_t)vcvtq_s64_f64(vmulq_f64(v69, v51))), v72));
        while (1)
        {
          v149 = (uint32x4_t)vorrq_s8((int8x16_t)vcgeq_s32(v106, *((int32x4_t *)v91 + 2)), (int8x16_t)vcgtq_s32(*((int32x4_t *)v91 + 1), v106));
          v149.i32[3] = v149.i32[2];
          if ((vmaxvq_u32(v149) & 0x80000000) == 0)
            break;
          if (v101 < 2)
            return;
          --v101;
          v91 -= 224;
        }
        v71.i64[0] = 0x8000000000000000;
        v150 = vaddq_f64(*((float64x2_t *)v91 + 6), (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64((int64x2_t)*((unint64_t *)v91 + 22)), *((int8x16_t *)v91 + 9), v71));
        v151 = vaddq_f64(*((float64x2_t *)v91 + 5), (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(*((int64x2_t *)v91 + 10)), *((int8x16_t *)v91 + 8), v105));
        *((int8x16_t *)v91 + 4) = vbslq_s8(*((int8x16_t *)v91 + 12), (int8x16_t)vaddq_s32(*((int32x4_t *)v91 + 7), *((int32x4_t *)v91 + 4)), *((int8x16_t *)v91 + 4));
        *((float64x2_t *)v91 + 5) = v151;
        *((float64x2_t *)v91 + 6) = v150;
        v89 = *(_QWORD *)v91;
        v100 = v51.f64[0];
      }
      else
      {
        v116 = (int32x4_t)vceqq_f64(v108, v51);
        v117 = (int32x4_t)vceqq_f64(v107, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v51.f64[0], 0));
        *((int32x4_t *)v91 + 10) = v117;
        *((int32x4_t *)v91 + 11) = v116;
        *((int32x4_t *)v91 + 12) = vuzp1q_s32(v117, v116);
        v118 = (unint64_t *)(*((_QWORD *)v91 + 27) + 16 * v115);
        v89 = *v118;
        v119 = v118[1];
        *((_QWORD *)v91 + 28) = v89;
        v91 += 224;
        ++v101;
        v120 = vdupq_n_s32(*((_DWORD *)v91 + 52));
        v116.i32[0] = *((_DWORD *)v91 + 52);
        v121 = *(_OWORD *)&vshlq_s32(v106, vnegq_s32(v120)) & __PAIR128__(0xFFFFFFFCFFFFFFFCLL, 0xFFFFFFFCFFFFFFFCLL);
        *((uint32x4_t *)v91 + 1) = vshlq_u32((uint32x4_t)v121, (uint32x4_t)v120);
        *((uint32x4_t *)v91 + 2) = vshlq_u32((uint32x4_t)vaddq_s32((int32x4_t)v121, v94), (uint32x4_t)v120);
        v122 = vaddq_s32((int32x4_t)vandq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshlq_u32(v95, (uint32x4_t)v116), 0), (int8x16_t)v106), *((int32x4_t *)v91 + 3));
        v123 = vsubq_s32(v122, v72);
        v124.i64[0] = v123.i32[2];
        v124.i64[1] = v123.i32[3];
        v125 = vcvtq_f64_s64(v124);
        v124.i64[0] = v123.i32[0];
        v124.i64[1] = v123.i32[1];
        *((float64x2_t *)v91 + 5) = vmulq_f64(v75, vcvtq_f64_s64(v124));
        *((float64x2_t *)v91 + 6) = vmulq_f64(v76, v125);
        *((int32x4_t *)v91 + 4) = v122;
        *((_DWORD *)v91 + 2) = v119;
      }
    }
  }
  v152 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)a1) + 416);
  if (os_log_type_enabled(v152, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315650;
    v175 = "GeoRaycastUtility.hpp";
    v176 = 1024;
    v177 = 477;
    v178 = 1024;
    v179 = v31;
    _os_log_impl(&dword_2164CC000, v152, OS_LOG_TYPE_ERROR, "%25s:%-5d Excessive level count (%d) in voxel tree: resolution has an invalid numerical value.", buf, 0x18u);
  }
}

uint64_t Phase::Geometry::IterateSceneQueryBatch(Phase::Logger *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;

  if (!*(_QWORD *)(a3 + 88))
    __assert_rtn("IterateSceneQueryBatch", "GeoSceneQueryFunctions.cpp", 22, "inSceneQueryFunctionTable.mTestScene");
  std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)(a2 + 8));
  Phase::Geometry::RunSceneQueriesOnRange(a1, a2, a3, 0, *(_DWORD *)(a2 + 96));
  atomic_store(3u, (unsigned int *)a2);
  atomic_store(2u, (unsigned int *)(a2 + 4));
  result = *(_QWORD *)(a2 + 48);
  if (result)
  {
    v7 = a2;
    return (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)result + 48))(result, &v7);
  }
  return result;
}

void Phase::Geometry::IterateSceneQueryBatchAsync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6;
  int v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  BOOL v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  void *v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  void *__p[2];
  char v46;
  __int128 v47;

  if (!*(_QWORD *)(a3 + 88))
    __assert_rtn("IterateBatchAsync", "GeoSceneQueryUtility.hpp", 85, "inSceneQueryFunctionTable.mTestScene");
  v6 = *(unsigned __int8 *)(a2 + 80);
  if (v6 <= 0xC0)
    v7 = v6 > 0x3F;
  else
    v7 = 2;
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 1016) + 2416);
  std::string::basic_string[abi:ne180100]<0>(__p, "GeoBatch");
  (*(void (**)(__int128 *__return_ptr, uint64_t, void **))(*(_QWORD *)v8 + 16))(&v47, v8, __p);
  std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100](a2 + 8, &v47);
  v9 = (std::__shared_weak_count *)*((_QWORD *)&v47 + 1);
  if (*((_QWORD *)&v47 + 1))
  {
    v10 = (unint64_t *)(*((_QWORD *)&v47 + 1) + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  if (v46 < 0)
    operator delete(__p[0]);
  v12 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(v12 + 256) = &off_24D57D3A8;
  *(_QWORD *)(v12 + 264) = Phase::Geometry::CompleteSceneQueryBatch;
  *(_QWORD *)(v12 + 272) = a2;
  *(_BYTE *)(v12 + 383) = 1;
  atomic_store(1u, (unsigned __int8 *)(v12 + 40));
  v13 = *(_QWORD *)(a2 + 8);
  *(_DWORD *)(v13 + 524) = v7;
  atomic_store(1u, (unsigned __int8 *)(v13 + 40));
  v14 = *(_DWORD *)(a2 + 96);
  if (v14)
  {
    v15 = 0;
    v16 = v14 >> 4;
    v17 = *(_DWORD *)(a2 + 96) & 0xF;
    do
    {
      v18 = v15;
      v19 = v17 <= 0;
      if (v17 <= 0)
        v17 = 0;
      else
        --v17;
      if (v19)
        v15 += v16;
      else
        v15 += v16 + 1;
      std::string::basic_string[abi:ne180100]<0>(__p, "GeoTestScene");
      (*(void (**)(__int128 *__return_ptr, uint64_t, void **))(*(_QWORD *)v8 + 16))(&v47, v8, __p);
      if (v46 < 0)
        operator delete(__p[0]);
      v20 = v47;
      *(_QWORD *)(v47 + 256) = &off_24D57D3D0;
      *(_QWORD *)(v20 + 264) = Phase::Geometry::RunSceneQueriesOnRange;
      *(_QWORD *)(v20 + 272) = a1;
      *(_QWORD *)(v20 + 280) = a2;
      *(_QWORD *)(v20 + 288) = a3;
      *(_DWORD *)(v20 + 296) = v18;
      *(_DWORD *)(v20 + 300) = v15;
      *(_BYTE *)(v20 + 383) = 1;
      atomic_store(1u, (unsigned __int8 *)(v20 + 40));
      *(_DWORD *)(v20 + 524) = v7;
      atomic_store(1u, (unsigned __int8 *)(v20 + 40));
      v21 = *(std::__shared_weak_count **)(a2 + 16);
      v43 = *(_QWORD *)(a2 + 8);
      v44 = v21;
      if (v21)
      {
        p_shared_owners = (unint64_t *)&v21->__shared_owners_;
        do
          v23 = __ldxr(p_shared_owners);
        while (__stxr(v23 + 1, p_shared_owners));
      }
      v41 = v20;
      v42 = (std::__shared_weak_count *)*((_QWORD *)&v47 + 1);
      if (*((_QWORD *)&v47 + 1))
      {
        v24 = (unint64_t *)(*((_QWORD *)&v47 + 1) + 8);
        do
          v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v8 + 24))(v8, &v43, &v41);
      v26 = v42;
      if (v42)
      {
        v27 = (unint64_t *)&v42->__shared_owners_;
        do
          v28 = __ldaxr(v27);
        while (__stlxr(v28 - 1, v27));
        if (!v28)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
      v29 = v44;
      if (v44)
      {
        v30 = (unint64_t *)&v44->__shared_owners_;
        do
          v31 = __ldaxr(v30);
        while (__stlxr(v31 - 1, v30));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
          std::__shared_weak_count::__release_weak(v29);
        }
      }
      v32 = (std::__shared_weak_count *)*((_QWORD *)&v47 + 1);
      if (*((_QWORD *)&v47 + 1))
      {
        v33 = (unint64_t *)(*((_QWORD *)&v47 + 1) + 8);
        do
          v34 = __ldaxr(v33);
        while (__stlxr(v34 - 1, v33));
        if (!v34)
        {
          ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
          std::__shared_weak_count::__release_weak(v32);
        }
      }
    }
    while (v15 < *(_DWORD *)(a2 + 96));
  }
  v35 = *(void **)(a2 + 8);
  v36 = *(std::__shared_weak_count **)(a2 + 16);
  __p[0] = v35;
  __p[1] = v36;
  if (v36)
  {
    v37 = (unint64_t *)&v36->__shared_owners_;
    do
      v38 = __ldxr(v37);
    while (__stxr(v38 + 1, v37));
  }
  Phase::JobManager::RunJobAsync(v8, (uint64_t *)__p);
  if (v36)
  {
    v39 = (unint64_t *)&v36->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
}

void sub_2165C9EEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21)
{
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v24;

  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v24 = __ldaxr(p_shared_owners);
    while (__stlxr(v24 - 1, p_shared_owners));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  _Unwind_Resume(exception_object);
}

unsigned int *Phase::Geometry::CompleteSceneQueryBatch(unsigned int *result)
{
  unsigned int *v1;
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int *v6;

  v1 = result;
  v2 = result + 1;
  do
  {
    v3 = __ldaxr(v2);
    if (v3 != 1)
    {
      __clrex();
      return result;
    }
  }
  while (__stlxr(2u, v2));
  std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)result + 1);
  v4 = atomic_load(v1);
  if (v4 == 2)
  {
    v5 = 3;
  }
  else
  {
    if (v4 == 5)
      goto LABEL_10;
    v5 = 5;
  }
  atomic_store(v5, v1);
LABEL_10:
  atomic_store(4u, v1 + 1);
  result = (unsigned int *)*((_QWORD *)v1 + 6);
  if (result)
  {
    v6 = v1;
    return (unsigned int *)(*(uint64_t (**)(unsigned int *, unsigned int **))(*(_QWORD *)result + 48))(result, &v6);
  }
  return result;
}

void Phase::Command<128>::Invoker<void (*)(Phase::Geometry::SceneQueryBatch *),void,Phase::Geometry::SceneQueryBatch *>::~Invoker()
{
  JUMPOUT(0x2199F9D70);
}

uint64_t Phase::Command<128>::Invoker<void (*)(Phase::Geometry::SceneQueryBatch *),void,Phase::Geometry::SceneQueryBatch *>::Call(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 8))(*(_QWORD *)(a1 + 16));
}

void Phase::Command<128>::Invoker<void (*)(Phase::Geometry::SystemState *,Phase::Geometry::SceneQueryBatch *,Phase::Geometry::SceneQueryFunctionTable const*,int,int),void,Phase::Geometry::SystemState *,Phase::Geometry::SceneQueryBatch *,Phase::Geometry::SceneQueryFunctionTable const*,int,int>::~Invoker()
{
  JUMPOUT(0x2199F9D70);
}

uint64_t Phase::Command<128>::Invoker<void (*)(Phase::Geometry::SystemState *,Phase::Geometry::SceneQueryBatch *,Phase::Geometry::SceneQueryFunctionTable const*,int,int),void,Phase::Geometry::SystemState *,Phase::Geometry::SceneQueryBatch *,Phase::Geometry::SceneQueryFunctionTable const*,int,int>::Call(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 8))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(unsigned int *)(a1 + 40), *(unsigned int *)(a1 + 44));
}

uint64_t Phase::Geometry::SceneQueryScheduler::RunQuery(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;

  v3 = *(unsigned int *)(a3 + 64);
  v4 = *(_QWORD *)(*(_QWORD *)a1 + 2296);
  if (0x86BCA1AF286BCA1BLL * ((*(_QWORD *)(*(_QWORD *)a1 + 2304) - v4) >> 3) <= v3)
    __assert_rtn("GetTypeDef", "GeoSceneQueryTypeRegistry.cpp", 33, "IsValid(inQueryType)");
  v5 = v4 + 152 * v3;
  if (*(_QWORD *)(v5 + 32))
  {
    atomic_store(1u, (unsigned int *)a3);
    atomic_store(1u, (unsigned int *)(a3 + 4));
    v6 = *(_QWORD *)(v5 + 32);
    if (!v6)
      std::__throw_bad_function_call[abi:ne180100]();
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 48))(v6);
  }
  else
  {
    atomic_store(5u, (unsigned int *)a3);
    atomic_store(4u, (unsigned int *)(a3 + 4));
    result = *(_QWORD *)(a3 + 48);
    if (result)
    {
      v8 = a3;
      return (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)result + 48))(result, &v8);
    }
  }
  return result;
}

_QWORD *Phase::Geometry::SceneQueryTypeRegistry::CustomizeType(_QWORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4;

  v4 = a1[1];
  if (0x86BCA1AF286BCA1BLL * ((a1[2] - v4) >> 3) <= a2)
    __assert_rtn("CustomizeType", "GeoSceneQueryTypeRegistry.cpp", 44, "IsValid(inQueryType)");
  if (a1[4] <= (unint64_t)a3)
    __assert_rtn("CustomizeType", "GeoSceneQueryTypeRegistry.cpp", 45, "inShapeType < mTestShapeTableEntryCount");
  return std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>::operator=((_QWORD *)(*(_QWORD *)(v4 + 152 * a2 + 104) + 32 * a3), a4);
}

{
  uint64_t v4;

  v4 = a1[1];
  if (0x86BCA1AF286BCA1BLL * ((a1[2] - v4) >> 3) <= a2)
    __assert_rtn("CustomizeType", "GeoSceneQueryTypeRegistry.cpp", 58, "IsValid(inQueryType)");
  if (a1[4] <= (unint64_t)a3)
    __assert_rtn("CustomizeType", "GeoSceneQueryTypeRegistry.cpp", 59, "inShapeType < mTestShapeTableEntryCount");
  return std::function<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>::operator=((_QWORD *)(*(_QWORD *)(v4 + 152 * a2 + 128) + 32 * a3), a4);
}

_QWORD *std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

_QWORD *std::function<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

_QWORD *Phase::Geometry::SceneQueryTypeRegistry::CustomizeType(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  if (0x86BCA1AF286BCA1BLL * ((*(_QWORD *)(a1 + 16) - v3) >> 3) <= a2)
    __assert_rtn("CustomizeType", "GeoSceneQueryTypeRegistry.cpp", 70, "IsValid(inQueryType)");
  return std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL)>::operator=((_QWORD *)(v3 + 152 * a2 + 72), a3);
}

_QWORD *std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

_QWORD *Phase::Geometry::SceneQueryTypeRegistry::CustomizeType(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;

  v4 = *(_QWORD *)(a1 + 8);
  if (0x86BCA1AF286BCA1BLL * ((*(_QWORD *)(a1 + 16) - v4) >> 3) <= a2)
    __assert_rtn("CustomizeType", "GeoSceneQueryTypeRegistry.cpp", 83, "IsValid(inQueryType)");
  v6 = v4 + 152 * a2;
  std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&)>::operator=((_QWORD *)(v6 + 8), a3);
  return std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&)>::operator=((_QWORD *)(v6 + 40), a4);
}

_QWORD *std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

uint64_t Phase::Geometry::SceneQueryTypeRegistry::RegisterNewType(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;
  uint64_t Type;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char **v27;
  char v28;
  _DWORD v29[2];
  _BYTE v30[24];
  _BYTE *v31;
  _BYTE v32[24];
  _BYTE *v33;
  _BYTE v34[24];
  _BYTE *v35;
  char *v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  v5 = a1 + 1;
  v6 = (a1[2] - a1[1]) >> 3;
  v7 = (678152731 * v6);
  v29[0] = 678152731 * v6;
  v29[1] = 678152731 * v6;
  v8 = v30;
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v30, a2);
  v9 = v32;
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v32, a3);
  v10 = v34;
  v35 = 0;
  v36 = 0;
  v11 = a1[4];
  v37 = 0;
  v38 = 0;
  v27 = &v36;
  v28 = 0;
  if (v11)
  {
    if (v11 >> 59)
      std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>::__throw_length_error[abi:ne180100]();
    v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::SpatialModelerInstance::SubmixHandleInfo>>(v11);
    v38 = &v36[32 * v12];
    v13 = &v36[32 * v11];
    v14 = 32 * v11;
    v15 = v36 + 24;
    do
    {
      *v15 = 0;
      v15 += 4;
      v14 -= 32;
    }
    while (v14);
    v16 = a1[4];
    v37 = v13;
    v39 = 0;
    v40 = 0;
    v41 = 0;
    v27 = &v39;
    v28 = 0;
    if (v16)
    {
      if (v16 >> 59)
        std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>::__throw_length_error[abi:ne180100]();
      v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::SpatialModelerInstance::SubmixHandleInfo>>(v16);
      v39 = v17;
      v41 = &v17[32 * v18];
      v19 = 32 * v16;
      v20 = v17 + 24;
      do
      {
        *v20 = 0;
        v20 += 4;
        v19 -= 32;
      }
      while (v19);
      v40 = &v17[32 * v16];
    }
  }
  else
  {
    v40 = 0;
    v41 = 0;
    v39 = 0;
  }
  v21 = a1[2];
  if (v21 >= a1[3])
  {
    Type = std::vector<Phase::Geometry::SceneQueryTypeDefinition>::__push_back_slow_path<Phase::Geometry::SceneQueryTypeDefinition>(v5, (uint64_t)v29);
  }
  else
  {
    std::allocator<Phase::Geometry::SceneQueryTypeDefinition>::construct[abi:ne180100]<Phase::Geometry::SceneQueryTypeDefinition,Phase::Geometry::SceneQueryTypeDefinition>((uint64_t)(a1 + 3), (_QWORD *)a1[2], (uint64_t)v29);
    Type = v21 + 152;
  }
  a1[2] = Type;
  v27 = &v39;
  std::vector<std::function<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v27);
  v27 = &v36;
  std::vector<std::function<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v27);
  if (v35 == v34)
  {
    v23 = 4;
  }
  else
  {
    if (!v35)
      goto LABEL_19;
    v23 = 5;
    v10 = v35;
  }
  (*(void (**)(_QWORD *))(*v10 + 8 * v23))(v10);
LABEL_19:
  if (v33 == v32)
  {
    v24 = 4;
  }
  else
  {
    if (!v33)
      goto LABEL_24;
    v24 = 5;
    v9 = v33;
  }
  (*(void (**)(_QWORD *))(*v9 + 8 * v24))(v9);
LABEL_24:
  if (v31 == v30)
  {
    v25 = 4;
    goto LABEL_28;
  }
  if (v31)
  {
    v25 = 5;
    v8 = v31;
LABEL_28:
    (*(void (**)(_QWORD *))(*v8 + 8 * v25))(v8);
  }
  return v7;
}

void sub_2165CA8A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  Phase::Geometry::SceneQueryTypeDefinition::~SceneQueryTypeDefinition((Phase::Geometry::SceneQueryTypeDefinition *)va);
  _Unwind_Resume(a1);
}

void Phase::Geometry::SceneQueryTypeDefinition::~SceneQueryTypeDefinition(Phase::Geometry::SceneQueryTypeDefinition *this)
{
  Phase::Geometry::SceneQueryTypeDefinition *v2;
  uint64_t v3;
  Phase::Geometry::SceneQueryTypeDefinition *v4;
  uint64_t v5;
  Phase::Geometry::SceneQueryTypeDefinition *v6;
  uint64_t v7;
  void **v8;

  v8 = (void **)((char *)this + 128);
  std::vector<std::function<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>>::__destroy_vector::operator()[abi:ne180100](&v8);
  v8 = (void **)((char *)this + 104);
  std::vector<std::function<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>>::__destroy_vector::operator()[abi:ne180100](&v8);
  v2 = (Phase::Geometry::SceneQueryTypeDefinition *)*((_QWORD *)this + 12);
  if (v2 == (Phase::Geometry::SceneQueryTypeDefinition *)((char *)this + 72))
  {
    v3 = 4;
    v2 = (Phase::Geometry::SceneQueryTypeDefinition *)((char *)this + 72);
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
LABEL_6:
  v4 = (Phase::Geometry::SceneQueryTypeDefinition *)*((_QWORD *)this + 8);
  if (v4 == (Phase::Geometry::SceneQueryTypeDefinition *)((char *)this + 40))
  {
    v5 = 4;
    v4 = (Phase::Geometry::SceneQueryTypeDefinition *)((char *)this + 40);
  }
  else
  {
    if (!v4)
      goto LABEL_11;
    v5 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v4 + 8 * v5))();
LABEL_11:
  v6 = (Phase::Geometry::SceneQueryTypeDefinition *)*((_QWORD *)this + 4);
  if (v6 == (Phase::Geometry::SceneQueryTypeDefinition *)((char *)this + 8))
  {
    v7 = 4;
    v6 = (Phase::Geometry::SceneQueryTypeDefinition *)((char *)this + 8);
  }
  else
  {
    if (!v6)
      return;
    v7 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v6 + 8 * v7))();
}

unint64_t Phase::Geometry::SceneQueryTypeRegistry::DeriveNewType(Phase::Geometry::SceneQueryTypeRegistry *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t *v3;
  unint64_t v4;
  unint64_t v6;
  uint64_t Type;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  void **v15;
  _DWORD v16[2];
  _QWORD v17[3];
  _QWORD *v18;
  _BYTE v19[24];
  _BYTE *v20;
  _BYTE v21[24];
  _BYTE *v22;
  uint64_t v23;
  _QWORD v24[4];

  v24[3] = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 1);
  v3 = (uint64_t *)((char *)this + 8);
  v4 = 0x86BCA1AF286BCA1BLL * ((*((_QWORD *)this + 2) - v2) >> 3);
  if (v4 <= a2)
    __assert_rtn("DeriveNewType", "GeoSceneQueryTypeRegistry.cpp", 112, "IsValid(inBaseQueryType)");
  v16[0] = a2;
  v16[1] = v4;
  Phase::Geometry::SceneQueryFunctionTable::SceneQueryFunctionTable(v17, (_QWORD *)(v2 + 152 * a2 + 8));
  v6 = *((_QWORD *)this + 2);
  if (v6 >= *((_QWORD *)this + 3))
  {
    Type = std::vector<Phase::Geometry::SceneQueryTypeDefinition>::__push_back_slow_path<Phase::Geometry::SceneQueryTypeDefinition>(v3, (uint64_t)v16);
  }
  else
  {
    std::allocator<Phase::Geometry::SceneQueryTypeDefinition>::construct[abi:ne180100]<Phase::Geometry::SceneQueryTypeDefinition,Phase::Geometry::SceneQueryTypeDefinition>((uint64_t)this + 24, *((_QWORD **)this + 2), (uint64_t)v16);
    Type = v6 + 152;
  }
  *((_QWORD *)this + 2) = Type;
  v15 = (void **)v24;
  std::vector<std::function<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>>::__destroy_vector::operator()[abi:ne180100](&v15);
  v15 = (void **)&v23;
  std::vector<std::function<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>>::__destroy_vector::operator()[abi:ne180100](&v15);
  v8 = v22;
  if (v22 == v21)
  {
    v9 = 4;
    v8 = v21;
  }
  else
  {
    if (!v22)
      goto LABEL_10;
    v9 = 5;
  }
  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_10:
  v10 = v20;
  if (v20 == v19)
  {
    v11 = 4;
    v10 = v19;
  }
  else
  {
    if (!v20)
      goto LABEL_15;
    v11 = 5;
  }
  (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_15:
  v12 = v18;
  if (v18 == v17)
  {
    v13 = 4;
    v12 = v17;
    goto LABEL_19;
  }
  if (v18)
  {
    v13 = 5;
LABEL_19:
    (*(void (**)(void))(*v12 + 8 * v13))();
  }
  return v4;
}

void sub_2165CAC14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  Phase::Geometry::SceneQueryTypeDefinition::~SceneQueryTypeDefinition((Phase::Geometry::SceneQueryTypeDefinition *)va);
  _Unwind_Resume(a1);
}

void std::vector<Phase::Geometry::SceneQueryTypeDefinition>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0x86BCA1AF286BCA1BLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<Phase::Geometry::SceneQueryTypeDefinition>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 152 * a2;
    while (v3 != v7)
    {
      v3 -= 152;
      std::allocator<Phase::Geometry::SceneQueryTypeDefinition>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
    }
    a1[1] = v7;
  }
}

unint64_t *Phase::Geometry::SceneQueryTypeRegistry::SetTestShapeTableEntryCount(unint64_t *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t *v5;
  unint64_t *v6;

  this[4] = a2;
  v2 = this[1];
  v3 = this[2];
  if (v2 != v3)
  {
    v5 = (unint64_t *)(v2 + 104);
    do
    {
      if (a2 != (uint64_t)(v5[1] - *v5) >> 5)
        std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>::resize(v5, a2);
      this = v5 + 3;
      if (a2 != (uint64_t)(v5[4] - v5[3]) >> 5)
        this = std::vector<std::function<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>>::resize(this, a2);
      v6 = v5 + 6;
      v5 += 19;
    }
    while (v6 != (unint64_t *)v3);
  }
  return this;
}

unint64_t *std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>::resize(unint64_t *result, unint64_t a2)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;

  v2 = result;
  v3 = result[1];
  v4 = (uint64_t)(v3 - *result) >> 5;
  if (a2 > v4)
    return std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>::__append(result, a2 - v4);
  if (a2 < v4)
  {
    v5 = *result + 32 * a2;
    if (v3 != v5)
    {
      while (1)
      {
        v6 = v3 - 32;
        result = *(unint64_t **)(v3 - 8);
        if ((unint64_t *)(v3 - 32) == result)
          break;
        if (result)
        {
          v7 = 5;
LABEL_9:
          result = (unint64_t *)(*(uint64_t (**)(void))(*result + 8 * v7))();
        }
        v3 = v6;
        if (v6 == v5)
          goto LABEL_11;
      }
      result = (unint64_t *)(v3 - 32);
      v7 = 4;
      goto LABEL_9;
    }
LABEL_11:
    v2[1] = v5;
  }
  return result;
}

unint64_t *std::vector<std::function<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>>::resize(unint64_t *result, unint64_t a2)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;

  v2 = result;
  v3 = result[1];
  v4 = (uint64_t)(v3 - *result) >> 5;
  if (a2 > v4)
    return std::vector<std::function<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>>::__append(result, a2 - v4);
  if (a2 < v4)
  {
    v5 = *result + 32 * a2;
    if (v3 != v5)
    {
      while (1)
      {
        v6 = v3 - 32;
        result = *(unint64_t **)(v3 - 8);
        if ((unint64_t *)(v3 - 32) == result)
          break;
        if (result)
        {
          v7 = 5;
LABEL_9:
          result = (unint64_t *)(*(uint64_t (**)(void))(*result + 8 * v7))();
        }
        v3 = v6;
        if (v6 == v5)
          goto LABEL_11;
      }
      result = (unint64_t *)(v3 - 32);
      v7 = 4;
      goto LABEL_9;
    }
LABEL_11:
    v2[1] = v5;
  }
  return result;
}

void std::vector<std::function<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  uint64_t v8;

  v1 = *a1;
  v2 = (char *)**a1;
  if (!v2)
    return;
  v4 = (char *)v1[1];
  v5 = **a1;
  if (v4 == v2)
    goto LABEL_10;
  do
  {
    v6 = v4 - 32;
    v7 = (char *)*((_QWORD *)v4 - 1);
    if (v4 - 32 == v7)
    {
      v7 = v4 - 32;
      v8 = 4;
    }
    else
    {
      if (!v7)
        goto LABEL_8;
      v8 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_8:
    v4 = v6;
  }
  while (v6 != v2);
  v5 = **a1;
LABEL_10:
  v1[1] = v2;
  operator delete(v5);
}

_QWORD *Phase::Geometry::SceneQueryFunctionTable::SceneQueryFunctionTable(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v18;
  char **v19;
  char **v20;
  char v21;
  char *v22;
  char *v23;

  v4 = std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)a1, (uint64_t)a2);
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100](v4 + 32, (uint64_t)(a2 + 4));
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)(a1 + 8), (uint64_t)(a2 + 8));
  a1[12] = 0;
  a1[13] = 0;
  a1[14] = 0;
  v5 = a2[12];
  v6 = a2[13];
  v7 = v6 - v5;
  if (v6 != v5)
  {
    if (v7 < 0)
      std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>::__throw_length_error[abi:ne180100]();
    v8 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::SpatialModelerInstance::SubmixHandleInfo>>(v7 >> 5);
    a1[14] = &v8[32 * v9];
    a1[12] = v8;
    a1[13] = v8;
    v22 = v8;
    v23 = v8;
    v18 = a1 + 14;
    v19 = &v22;
    v20 = &v23;
    v10 = (uint64_t)v8;
    v21 = 0;
    do
    {
      std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100](v10, v5);
      v5 += 32;
      v10 = (uint64_t)(v23 + 32);
      v23 += 32;
    }
    while (v5 != v6);
    v21 = 1;
    std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>,std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&v18);
    a1[13] = v10;
  }
  a1[15] = 0;
  a1[16] = 0;
  a1[17] = 0;
  v11 = a2[15];
  v12 = a2[16];
  v13 = v12 - v11;
  if (v12 != v11)
  {
    if (v13 < 0)
      std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>::__throw_length_error[abi:ne180100]();
    v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::SpatialModelerInstance::SubmixHandleInfo>>(v13 >> 5);
    a1[17] = &v14[32 * v15];
    a1[15] = v14;
    a1[16] = v14;
    v22 = v14;
    v23 = v14;
    v18 = a1 + 17;
    v19 = &v22;
    v20 = &v23;
    v16 = (uint64_t)v14;
    v21 = 0;
    do
    {
      std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100](v16, v11);
      v11 += 32;
      v16 = (uint64_t)(v23 + 32);
      v23 += 32;
    }
    while (v11 != v12);
    v21 = 1;
    std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>,std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&v18);
    a1[16] = v16;
  }
  return a1;
}

void sub_2165CB0D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;

  v14 = (_QWORD *)v11[7];
  if (v14 == v12)
  {
    v15 = 4;
    v14 = v12;
  }
  else
  {
    if (!v14)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_6:
  v16 = (_QWORD *)v11[3];
  if (v16 == v11)
  {
    v17 = 4;
  }
  else
  {
    if (!v16)
      goto LABEL_11;
    v17 = 5;
    v11 = (_QWORD *)v11[3];
  }
  (*(void (**)(_QWORD *))(*v11 + 8 * v17))(v11);
LABEL_11:
  _Unwind_Resume(exception_object);
}

void std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>,std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  if (!*(_BYTE *)(a1 + 24))
  {
    v2 = **(_QWORD **)(a1 + 8);
    v3 = **(_QWORD **)(a1 + 16);
    if (v3 != v2)
    {
      while (1)
      {
        v4 = v3 - 32;
        v5 = *(_QWORD **)(v3 - 8);
        if ((_QWORD *)(v3 - 32) == v5)
          break;
        if (v5)
        {
          v6 = 5;
LABEL_7:
          (*(void (**)(void))(*v5 + 8 * v6))();
        }
        v3 = v4;
        if (v4 == v2)
          return a1;
      }
      v5 = (_QWORD *)(v3 - 32);
      v6 = 4;
      goto LABEL_7;
    }
  }
  return a1;
}

_QWORD *std::__function::__value_func<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_2165CB3B8(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::__function::__value_func<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_2165CB52C(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::__function::__value_func<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_2165CB6A0(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::__function::__value_func<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_2165CB814(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t std::vector<Phase::Geometry::SceneQueryTypeDefinition>::__push_back_slow_path<Phase::Geometry::SceneQueryTypeDefinition>(uint64_t *a1, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char *Type;
  uint64_t v8;
  void *v10;
  char *v11;
  _QWORD *v12;
  char *v13;
  uint64_t *v14;

  v3 = 0x86BCA1AF286BCA1BLL * ((a1[1] - *a1) >> 3);
  v4 = v3 + 1;
  if (v3 + 1 > 0x1AF286BCA1AF286)
    std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>::__throw_length_error[abi:ne180100]();
  if (0xD79435E50D79436 * ((a1[2] - *a1) >> 3) > v4)
    v4 = 0xD79435E50D79436 * ((a1[2] - *a1) >> 3);
  if (0x86BCA1AF286BCA1BLL * ((a1[2] - *a1) >> 3) >= 0xD79435E50D7943)
    v6 = 0x1AF286BCA1AF286;
  else
    v6 = v4;
  v14 = a1 + 2;
  if (v6)
    Type = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Geometry::SceneQueryTypeDefinition>>((uint64_t)(a1 + 2), v6);
  else
    Type = 0;
  v10 = Type;
  v11 = &Type[152 * v3];
  v13 = &Type[152 * v6];
  std::allocator<Phase::Geometry::SceneQueryTypeDefinition>::construct[abi:ne180100]<Phase::Geometry::SceneQueryTypeDefinition,Phase::Geometry::SceneQueryTypeDefinition>((uint64_t)(a1 + 2), v11, a2);
  v12 = v11 + 152;
  std::vector<Phase::Geometry::SceneQueryTypeDefinition>::__swap_out_circular_buffer(a1, &v10);
  v8 = a1[1];
  std::__split_buffer<Phase::Geometry::SceneQueryTypeDefinition>::~__split_buffer(&v10);
  return v8;
}

void sub_2165CB92C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<Phase::Geometry::SceneQueryTypeDefinition>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

__n128 std::allocator<Phase::Geometry::SceneQueryTypeDefinition>::construct[abi:ne180100]<Phase::Geometry::SceneQueryTypeDefinition,Phase::Geometry::SceneQueryTypeDefinition>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  __n128 result;

  *a2 = *(_QWORD *)a3;
  std::__function::__value_func<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&)>::__value_func[abi:ne180100]((uint64_t)(a2 + 1), a3 + 8);
  std::__function::__value_func<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&)>::__value_func[abi:ne180100]((uint64_t)(a2 + 5), a3 + 40);
  std::__function::__value_func<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL)>::__value_func[abi:ne180100]((uint64_t)(a2 + 9), a3 + 72);
  a2[13] = 0;
  a2[14] = 0;
  a2[15] = 0;
  *(_OWORD *)(a2 + 13) = *(_OWORD *)(a3 + 104);
  a2[15] = *(_QWORD *)(a3 + 120);
  *(_QWORD *)(a3 + 104) = 0;
  *(_QWORD *)(a3 + 112) = 0;
  *(_QWORD *)(a3 + 120) = 0;
  a2[16] = 0;
  a2[17] = 0;
  a2[18] = 0;
  result = *(__n128 *)(a3 + 128);
  *((__n128 *)a2 + 8) = result;
  a2[18] = *(_QWORD *)(a3 + 144);
  *(_QWORD *)(a3 + 128) = 0;
  *(_QWORD *)(a3 + 136) = 0;
  *(_QWORD *)(a3 + 144) = 0;
  return result;
}

uint64_t std::__function::__value_func<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

uint64_t std::__function::__value_func<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

void std::vector<Phase::Geometry::SceneQueryTypeDefinition>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  v6 = (_QWORD *)a2[1];
  if (v4 != *a1)
  {
    do
    {
      v6 -= 19;
      v4 -= 152;
      std::allocator<Phase::Geometry::SceneQueryTypeDefinition>::construct[abi:ne180100]<Phase::Geometry::SceneQueryTypeDefinition,Phase::Geometry::SceneQueryTypeDefinition>((uint64_t)(a1 + 2), v6, v4);
    }
    while (v4 != v5);
  }
  a2[1] = v6;
  v7 = *a1;
  *a1 = (uint64_t)v6;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Geometry::SceneQueryTypeDefinition>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1AF286BCA1AF287)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(152 * a2);
}

_QWORD *std::allocator<Phase::Geometry::SceneQueryTypeDefinition>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *result;
  uint64_t v8;
  void **v9;

  v9 = (void **)(a2 + 128);
  std::vector<std::function<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>>::__destroy_vector::operator()[abi:ne180100](&v9);
  v9 = (void **)(a2 + 104);
  std::vector<std::function<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>>::__destroy_vector::operator()[abi:ne180100](&v9);
  v3 = *(_QWORD **)(a2 + 96);
  if (v3 == (_QWORD *)(a2 + 72))
  {
    v4 = 4;
    v3 = (_QWORD *)(a2 + 72);
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  v5 = *(_QWORD **)(a2 + 64);
  if (v5 == (_QWORD *)(a2 + 40))
  {
    v6 = 4;
    v5 = (_QWORD *)(a2 + 40);
  }
  else
  {
    if (!v5)
      goto LABEL_11;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  result = *(_QWORD **)(a2 + 32);
  if (result == (_QWORD *)(a2 + 8))
  {
    v8 = 4;
    result = (_QWORD *)(a2 + 8);
  }
  else
  {
    if (!result)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void **std::__split_buffer<Phase::Geometry::SceneQueryTypeDefinition>::~__split_buffer(void **a1)
{
  std::__split_buffer<Phase::Geometry::SceneQueryTypeDefinition>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

_QWORD *std::__split_buffer<Phase::Geometry::SceneQueryTypeDefinition>::clear[abi:ne180100](_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = result[1];
  v1 = result[2];
  if (v1 != v2)
  {
    v3 = result;
    do
    {
      v4 = v3[4];
      v3[2] = v1 - 152;
      result = std::allocator<Phase::Geometry::SceneQueryTypeDefinition>::destroy[abi:ne180100](v4, v1 - 152);
      v1 = v3[2];
    }
    while (v1 != v2);
  }
  return result;
}

void std::vector<Phase::Geometry::SceneQueryTypeDefinition>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *Type;
  size_t v13;
  size_t v14;
  void *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0x86BCA1AF286BCA1BLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 152 * ((152 * a2 - 152) / 0x98) + 152;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0x86BCA1AF286BCA1BLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x1AF286BCA1AF286)
      std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>::__throw_length_error[abi:ne180100]();
    v10 = 0x86BCA1AF286BCA1BLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0xD79435E50D7943)
      v11 = 0x1AF286BCA1AF286;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      Type = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Geometry::SceneQueryTypeDefinition>>(v4, v11);
    else
      Type = 0;
    v15 = Type;
    v16 = &Type[152 * v8];
    v18 = &Type[152 * v11];
    v14 = 152 * ((152 * a2 - 152) / 0x98) + 152;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<Phase::Geometry::SceneQueryTypeDefinition>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<Phase::Geometry::SceneQueryTypeDefinition>::~__split_buffer(&v15);
  }
}

void sub_2165CBE50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<Phase::Geometry::SceneQueryTypeDefinition>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

unint64_t *std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>::__append(unint64_t *result, unint64_t a2)
{
  unint64_t *v3;
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  int64x2_t v28;
  unint64_t v29;
  unint64_t v30;
  int64x2_t v31;
  unint64_t v32;
  _QWORD *v33;

  v3 = result;
  v4 = result + 2;
  v5 = result[2];
  v6 = result[1];
  if (a2 <= (uint64_t)(v5 - v6) >> 5)
  {
    if (a2)
    {
      v13 = 32 * a2;
      v14 = (_QWORD *)(v6 + 24);
      v15 = v6 + 32 * a2;
      do
      {
        *v14 = 0;
        v14 += 4;
        v13 -= 32;
      }
      while (v13);
    }
    else
    {
      v15 = result[1];
    }
    result[1] = v15;
  }
  else
  {
    v7 = v6 - *result;
    v8 = a2 + (v7 >> 5);
    if (v8 >> 59)
      std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>::__throw_length_error[abi:ne180100]();
    v9 = v7 >> 5;
    v10 = v5 - *result;
    if (v10 >> 4 > v8)
      v8 = v10 >> 4;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0)
      v11 = 0x7FFFFFFFFFFFFFFLL;
    else
      v11 = v8;
    v33 = v4;
    if (v11)
      v11 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::SpatialModelerInstance::SubmixHandleInfo>>(v11);
    else
      v12 = 0;
    v16 = v11 + 32 * v9;
    v30 = v11;
    v31.i64[0] = v16;
    v32 = v11 + 32 * v12;
    v17 = 32 * a2;
    v18 = (_QWORD *)(v16 + 24);
    v19 = v16 + 32 * a2;
    do
    {
      *v18 = 0;
      v18 += 4;
      v17 -= 32;
    }
    while (v17);
    v31.i64[1] = v16 + 32 * a2;
    v21 = *v3;
    v20 = v3[1];
    if (v20 != *v3)
    {
      v22 = 0;
      v23 = v3[1];
      while (1)
      {
        v24 = v16 + v22;
        v25 = v20 + v22;
        v26 = *(_QWORD *)(v20 + v22 - 8);
        if (v26)
        {
          if (v25 - 32 == v26)
          {
            *(_QWORD *)(v24 - 8) = v24 - 32;
            (*(void (**)(_QWORD))(**(_QWORD **)(v25 - 8) + 24))(*(_QWORD *)(v25 - 8));
            goto LABEL_27;
          }
          v27 = (_QWORD *)(v23 - 8);
          *(_QWORD *)(v24 - 8) = v26;
        }
        else
        {
          v27 = (_QWORD *)(v24 - 8);
        }
        *v27 = 0;
LABEL_27:
        v23 -= 32;
        v22 -= 32;
        if (v20 + v22 == v21)
        {
          v28 = *(int64x2_t *)v3;
          v19 = v31.u64[1];
          v16 += v22;
          goto LABEL_30;
        }
      }
    }
    v28 = vdupq_n_s64(v20);
LABEL_30:
    *v3 = v16;
    v3[1] = v19;
    v31 = v28;
    v29 = v3[2];
    v3[2] = v32;
    v32 = v29;
    v30 = v28.i64[0];
    return (unint64_t *)std::__split_buffer<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>::~__split_buffer((uint64_t)&v30);
  }
  return result;
}

uint64_t std::__split_buffer<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>::~__split_buffer(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  v3 = *(_QWORD **)(a1 + 8);
  v2 = *(_QWORD **)(a1 + 16);
  if (v2 != v3)
  {
    while (1)
    {
      v4 = v2 - 4;
      *(_QWORD *)(a1 + 16) = v2 - 4;
      v5 = (_QWORD *)*(v2 - 1);
      if (v5 == v4)
        break;
      if (v5)
      {
        v4 = v5;
        v6 = 5;
LABEL_6:
        (*(void (**)(void))(*v4 + 8 * v6))();
        v4 = *(_QWORD **)(a1 + 16);
      }
      v2 = v4;
      if (v4 == v3)
        goto LABEL_8;
    }
    v6 = 4;
    goto LABEL_6;
  }
LABEL_8:
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

unint64_t *std::vector<std::function<BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>>::__append(unint64_t *result, unint64_t a2)
{
  unint64_t *v3;
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  int64x2_t v28;
  unint64_t v29;
  unint64_t v30;
  int64x2_t v31;
  unint64_t v32;
  _QWORD *v33;

  v3 = result;
  v4 = result + 2;
  v5 = result[2];
  v6 = result[1];
  if (a2 <= (uint64_t)(v5 - v6) >> 5)
  {
    if (a2)
    {
      v13 = 32 * a2;
      v14 = (_QWORD *)(v6 + 24);
      v15 = v6 + 32 * a2;
      do
      {
        *v14 = 0;
        v14 += 4;
        v13 -= 32;
      }
      while (v13);
    }
    else
    {
      v15 = result[1];
    }
    result[1] = v15;
  }
  else
  {
    v7 = v6 - *result;
    v8 = a2 + (v7 >> 5);
    if (v8 >> 59)
      std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>::__throw_length_error[abi:ne180100]();
    v9 = v7 >> 5;
    v10 = v5 - *result;
    if (v10 >> 4 > v8)
      v8 = v10 >> 4;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0)
      v11 = 0x7FFFFFFFFFFFFFFLL;
    else
      v11 = v8;
    v33 = v4;
    if (v11)
      v11 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::SpatialModelerInstance::SubmixHandleInfo>>(v11);
    else
      v12 = 0;
    v16 = v11 + 32 * v9;
    v30 = v11;
    v31.i64[0] = v16;
    v32 = v11 + 32 * v12;
    v17 = 32 * a2;
    v18 = (_QWORD *)(v16 + 24);
    v19 = v16 + 32 * a2;
    do
    {
      *v18 = 0;
      v18 += 4;
      v17 -= 32;
    }
    while (v17);
    v31.i64[1] = v16 + 32 * a2;
    v21 = *v3;
    v20 = v3[1];
    if (v20 != *v3)
    {
      v22 = 0;
      v23 = v3[1];
      while (1)
      {
        v24 = v16 + v22;
        v25 = v20 + v22;
        v26 = *(_QWORD *)(v20 + v22 - 8);
        if (v26)
        {
          if (v25 - 32 == v26)
          {
            *(_QWORD *)(v24 - 8) = v24 - 32;
            (*(void (**)(_QWORD))(**(_QWORD **)(v25 - 8) + 24))(*(_QWORD *)(v25 - 8));
            goto LABEL_27;
          }
          v27 = (_QWORD *)(v23 - 8);
          *(_QWORD *)(v24 - 8) = v26;
        }
        else
        {
          v27 = (_QWORD *)(v24 - 8);
        }
        *v27 = 0;
LABEL_27:
        v23 -= 32;
        v22 -= 32;
        if (v20 + v22 == v21)
        {
          v28 = *(int64x2_t *)v3;
          v19 = v31.u64[1];
          v16 += v22;
          goto LABEL_30;
        }
      }
    }
    v28 = vdupq_n_s64(v20);
LABEL_30:
    *v3 = v16;
    v3[1] = v19;
    v31 = v28;
    v29 = v3[2];
    v3[2] = v32;
    v32 = v29;
    v30 = v28.i64[0];
    return (unint64_t *)std::__split_buffer<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>>::~__split_buffer((uint64_t)&v30);
  }
  return result;
}

void Phase::Geometry::RunSceneQueriesOnRange(Phase::Logger *a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  uint64_t InstancePtr;
  Phase::Logger *v11;
  Phase::Logger *v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint8_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  Phase::Logger *v20;
  uint64_t v21;
  NSObject *v22;
  int v23;
  uint8_t buf[4];
  int v25;
  __int16 v26;
  unsigned int v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  InstancePtr = Phase::Logger::GetInstancePtr(a1);
  v11 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(InstancePtr + 416));
  v12 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v11);
  if (*((_BYTE *)v12 + 424))
  {
    v13 = Phase::Logger::GetInstancePtr(v12);
    if ((unint64_t)v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v14 = **(NSObject ***)(v13 + 416);
      if (os_signpost_enabled(v14))
      {
        *(_DWORD *)buf = 67109632;
        v25 = a5 - a4;
        v26 = 1024;
        v27 = a4;
        v28 = 1024;
        v29 = a5;
        _os_signpost_emit_with_name_impl(&dword_2164CC000, v14, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v11, "Phase_Scene_Queries_Range", "%d rays, Run Scene Queries on Range: %d -> %d", buf, 0x14u);
      }
    }
  }
  atomic_store(2u, (unsigned int *)a2);
  v15 = *(_QWORD *)(*(_QWORD *)(a3 + 120) + 120);
  if (v15)
  {
    v23 = a5;
    *(_DWORD *)buf = a4;
    v15 = (*(uint64_t (**)(uint64_t, Phase::Logger *, uint64_t, uint8_t *, int *))(*(_QWORD *)v15 + 48))(v15, a1, a2, buf, &v23);
    v16 = v15 ^ 1;
  }
  else
  {
    v16 = 1;
  }
  if (a5 > (int)a4 && (*((_DWORD *)a1 + 242) & *(_DWORD *)(a2 + 72)) != 0)
  {
    do
    {
      if (*(_DWORD *)(a2 + 96) <= a4)
        __assert_rtn("Get", "GeoSceneQuery.hpp", 115, "inIndex < inBatch.mCount");
      v17 = *(_QWORD *)(a2 + 88);
      v18 = *(_DWORD *)(a2 + 100);
      buf[0] = v16;
      v19 = *(_QWORD *)(a3 + 88);
      if (!v19)
        std::__throw_bad_function_call[abi:ne180100]();
      v15 = (*(uint64_t (**)(uint64_t, Phase::Logger *, uint64_t, uint64_t, uint64_t, uint8_t *))(*(_QWORD *)v19 + 48))(v19, a1, a2, v17 + v18 * a4++, a3 + 96, buf);
    }
    while (a5 != a4);
  }
  v20 = (Phase::Logger *)Phase::Logger::GetInstancePtr((Phase::Logger *)v15);
  if (*((_BYTE *)v20 + 424))
  {
    v21 = Phase::Logger::GetInstancePtr(v20);
    if ((unint64_t)v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v22 = **(NSObject ***)(v21 + 416);
      if (os_signpost_enabled(v22))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_2164CC000, v22, OS_SIGNPOST_INTERVAL_END, (os_signpost_id_t)v11, "Phase_Scene_Queries_Range", (const char *)&unk_21676613F, buf, 2u);
      }
    }
  }
}

void Phase::Geometry::SceneState::Update(Phase::Geometry::SceneState *this)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  __int128 v8;
  int v9;
  uint64_t v10;
  std::__shared_mutex_base v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)this;
  v3 = *(_QWORD *)(*(_QWORD *)this + 2424);
  if (*(_QWORD *)(*(_QWORD *)this + 2256) == -1)
    v2[282] = v3;
  if (v2[283] == -1)
    v2[283] = v3;
  if (v2[284] == -1)
    v2[284] = v3;
  std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)this + 25);
  *((_DWORD *)this + 54) = 0;
  v8 = 0uLL;
  v9 = 0;
  v10 = 0xFFFFFFFFLL;
  std::__shared_mutex_base::__shared_mutex_base(&v11);
  v4 = *(_QWORD *)this;
  v12 = *(_QWORD *)(*(_QWORD *)this + 1192);
  Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::Resize(&v8, *(_DWORD *)(v4 + 1008));
  Phase::Geometry::SceneState::UpdateSceneEntities(this, (uint64_t)&v8);
  Phase::Geometry::MpsCpuSceneBuilder::Update((uint64_t)this + 32, (uint64_t *)this + 33, (uint64_t *)this + 1, (uint64_t)&v8, (uint64_t)this + 224);
  std::vector<Phase::Geometry::MpsCpuSceneDescriptor>::__clear[abi:ne180100]((uint64_t *)this + 33);
  if (*((_QWORD *)this + 11))
    Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::MergeFrom((uint64_t)&v8, (uint64_t)this + 160);
  std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)this + 28, (uint64_t *)&v8);
  *((_DWORD *)this + 60) = v9;
  std::condition_variable::~condition_variable(&v11.__gate2_);
  std::condition_variable::~condition_variable(&v11.__gate1_);
  std::mutex::~mutex(&v11.__mut_);
  v5 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v6 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_2165CC610(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::Resize(__int128 *a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  __int128 *v15;
  char v16;
  __int128 v17;

  v2 = *((unsigned int *)a1 + 4);
  if (v2 < a2)
  {
    Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::AllocSlots(a2, &v17);
    if ((_DWORD)v2)
    {
      v5 = 0;
      do
      {
        v6 = (uint64_t *)(*(_QWORD *)a1 + v5);
        v7 = v17 + v5;
        std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(v17 + v5), v6);
        *(_QWORD *)(v7 + 16) = v6[2];
        v5 += 24;
      }
      while (24 * v2 != v5);
      v8 = v2;
    }
    else
    {
      v8 = 0;
    }
    v9 = 24 * v8;
    do
    {
      v10 = v17 + v9;
      std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)(v17 + v9));
      *(_QWORD *)(v10 + 16) = 0x1FFFFFFFFLL;
      LODWORD(v2) = v2 + 1;
      v9 += 24;
    }
    while (a2 != (_DWORD)v2);
    v15 = a1 + 2;
    v16 = 1;
    std::__shared_mutex_base::lock((std::__shared_mutex_base *)(a1 + 2));
    v11 = *a1;
    *a1 = v17;
    v17 = v11;
    std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v15);
    *((_DWORD *)a1 + 4) = a2;
    v12 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
    if (*((_QWORD *)&v17 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
}

void sub_2165CC77C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void Phase::Geometry::SceneState::UpdateSceneEntities(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  BOOL v14;
  char *v15;
  unint64_t v16;
  float32x2_t *v17;
  float32x2_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *UniqueSlot;
  uint64_t v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  __int128 v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _DWORD *v42;
  unint64_t v43;
  _DWORD *v44;
  _DWORD *v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  char *v50;
  char *v51;
  _DWORD *v52;
  uint64_t v53;
  char *v54;
  char *v55;
  char *v56;
  unint64_t v57;
  unint64_t v58;
  char *v59;
  char *v60;
  char *v61;
  __int128 v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  _QWORD *v66;
  uint64_t *v67;
  _QWORD *v68;
  char *v69;
  char v70;
  unint64_t v71;
  uint64_t *v72;
  char *__p;
  int v74;
  _QWORD *v75;
  __int128 v77[2];
  __int128 v78;
  unsigned int v79;
  uint64_t v80;
  std::__shared_mutex_base v81;
  uint64_t v82;
  uint64_t v83;

  v83 = *MEMORY[0x24BDAC8D0];
  v78 = 0uLL;
  v79 = 0;
  v80 = 0xFFFFFFFFLL;
  std::__shared_mutex_base::__shared_mutex_base(&v81);
  v3 = *a1;
  v82 = *(_QWORD *)(*a1 + 1440);
  Phase::details::SharedSlotMap<Phase::Geometry::Entity,Phase::Handle64>::Resize(&v78, *(_DWORD *)(v3 + 1256));
  std::vector<Phase::Geometry::MpsCpuSceneDescriptor>::__clear[abi:ne180100](a1 + 33);
  a1[31] = 0;
  v66 = a1 + 31;
  v67 = a1 + 33;
  a1[32] = 0;
  v4 = *a1;
  std::vector<Phase::Geometry::MpsCpuSceneDescriptor>::__clear[abi:ne180100](a1 + 33);
  v5 = *(_QWORD *)(v4 + 1456);
  if (*(_DWORD *)(v4 + 1256) <= v5
    || (v75 = (_QWORD *)(v4 + 1240),
        v6 = *(_QWORD *)(v4 + 1240) + 24 * v5,
        *(_DWORD *)(v6 + 20) != HIDWORD(v5))
    || (v7 = *(_QWORD *)v6) == 0)
  {
    __assert_rtn("UpdateAndCopyScene", "GeoSceneState.cpp", 36, "nullptr != pRootPtr && nullptr != pRootPtr->get()");
  }
  v8 = operator new(0x18uLL);
  v68 = a1;
  *v8 = v7;
  v8[1] = 0;
  *((_BYTE *)v8 + 16) = 0;
  v9 = *(_QWORD *)(v4 + 1456);
  v10 = (char *)v8;
  if (v79 > v9)
  {
    v11 = v78 + 24 * v9;
    std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)v11, (uint64_t *)v6);
    *(_DWORD *)(v11 + 20) = HIDWORD(v9);
  }
  v12 = v10 + 24;
  *(_QWORD *)(v4 + 2248) = 0;
  v13 = *(_QWORD *)(v4 + 1248);
  if (v13)
    v14 = *(_QWORD *)(v13 + 8) < 1;
  else
    v14 = 1;
  v70 = v14;
  v69 = v10 + 24;
  v15 = v10 + 24;
  do
  {
    v17 = (float32x2_t *)*((_QWORD *)v15 - 3);
    v16 = *((_QWORD *)v15 - 2);
    v18 = v17[12];
    if (v16 >= (uint64_t)(*(_QWORD *)&v17[13] - *(_QWORD *)&v18) >> 3)
    {
      v56 = v15 - 24;
LABEL_63:
      v15 = v56;
      goto LABEL_65;
    }
    v19 = *(v15 - 8);
    v20 = *(_QWORD *)(*(_QWORD *)&v18 + 8 * v16);
    *((_QWORD *)v15 - 2) = v16 + 1;
    if (*(_DWORD *)(v4 + 1256) > v20
      && (v21 = *v75 + 24 * v20, v22 = *(_DWORD *)(v21 + 20), v22 == HIDWORD(v20)))
    {
      __p = v10;
      v23 = *(_QWORD *)v21;
      v74 = *(unsigned __int8 *)(*(_QWORD *)v21 + 80) | v19;
      if (v74)
      {
        if ((v70 & 1) == 0 || (v24 = *(_QWORD *)(v21 + 8)) != 0 && *(uint64_t *)(v24 + 8) >= 1)
        {
          UniqueSlot = (uint64_t *)Phase::details::SharedSlotMap<Phase::Geometry::Entity,Phase::Handle64>::GetUniqueSlot((uint64_t)v75, v20);
          v21 = (uint64_t)UniqueSlot;
          if (UniqueSlot)
          {
            v26 = UniqueSlot[1];
            if (v26)
            {
              if (*(uint64_t *)(v26 + 8) >= 1)
              {
                if (!*(_QWORD *)(v4 + 1440))
                  std::terminate();
                Phase::Geometry::EntityFactory::Create(*UniqueSlot, (uint64_t *)v77);
                v27 = v21;
                std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100](v21, v77);
                v28 = (std::__shared_weak_count *)*((_QWORD *)&v77[0] + 1);
                if (*((_QWORD *)&v77[0] + 1))
                {
                  v29 = (unint64_t *)(*((_QWORD *)&v77[0] + 1) + 8);
                  do
                    v30 = __ldaxr(v29);
                  while (__stlxr(v30 - 1, v29));
                  if (!v30)
                  {
                    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
                    std::__shared_weak_count::__release_weak(v28);
                  }
                }
                v21 = v27;
              }
            }
          }
          v23 = *(_QWORD *)v21;
        }
        Phase::operator*<float>(v17 + 6, (float *)(v23 + 16), (uint64_t)v77);
        v31 = v77[1];
        *(_OWORD *)(v23 + 48) = v77[0];
        *(_OWORD *)(v23 + 64) = v31;
        *(_BYTE *)(v23 + 80) = 0;
        v70 = 1;
      }
      v72 = (uint64_t *)v21;
      if (v79 > v20)
      {
        v32 = v78 + 24 * v20;
        std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)v32, v72);
        *(_DWORD *)(v32 + 20) = v22;
      }
      v34 = *(uint64_t **)(v23 + 120);
      v33 = *(uint64_t **)(v23 + 128);
      while (v34 != v33)
      {
        v35 = *v34;
        if (*(_DWORD *)(v4 + 1008) > *v34)
        {
          v36 = *(_QWORD *)(v4 + 992) + 24 * v35;
          v37 = *(_DWORD *)(v36 + 20);
          if (v37 == HIDWORD(v35))
          {
            v38 = *(_QWORD *)v36;
            if (*(_QWORD *)v36)
            {
              if (*(_DWORD *)(a2 + 16) > v35)
              {
                v39 = *(_QWORD *)a2 + 24 * *v34;
                std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)v39, (uint64_t *)v36);
                *(_DWORD *)(v39 + 20) = v37;
                v38 = *(_QWORD *)v36;
              }
              if (*(_DWORD *)v23 == 4)
              {
                v40 = *(_QWORD *)(v38 + 16) & *(_QWORD *)(v23 + 144);
                if (*(_DWORD *)v38 == 3)
                {
                  v71 = v71 & 0xFFFFFFFFFFFFFF00 | *(unsigned __int8 *)(v23 + 156);
                  v41 = Phase::Geometry::GetOrAddMpsCpuSceneDescriptor(v67, *(_QWORD *)(v38 + 16) & *(_QWORD *)(v23 + 144), v71);
                  *(_BYTE *)(v41 + 40) |= v74;
                  v68[32] |= v40;
                  v42 = (_DWORD *)*v72;
                  v43 = *(_QWORD *)(v41 + 16);
                  v44 = *(_DWORD **)(v41 + 8);
                  if ((unint64_t)v44 >= v43)
                  {
                    v46 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)v44 - *(_QWORD *)v41) >> 3);
                    v47 = v46 + 1;
                    if ((unint64_t)(v46 + 1) > 0x492492492492492)
                      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
                    v48 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v43 - *(_QWORD *)v41) >> 3);
                    if (2 * v48 > v47)
                      v47 = 2 * v48;
                    if (v48 >= 0x249249249249249)
                      v49 = 0x492492492492492;
                    else
                      v49 = v47;
                    if (v49)
                    {
                      v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::EntityShapeTemplate>>(v41 + 16, v49);
                      v44 = *(_DWORD **)(v41 + 8);
                    }
                    else
                    {
                      v50 = 0;
                    }
                    v51 = &v50[56 * v46];
                    *(_DWORD *)v51 = v42[12];
                    *((_DWORD *)v51 + 1) = v42[13];
                    *((_DWORD *)v51 + 2) = v42[14];
                    *((_DWORD *)v51 + 3) = v42[15];
                    *((_DWORD *)v51 + 4) = v42[16];
                    *((_DWORD *)v51 + 5) = v42[17];
                    *((_DWORD *)v51 + 6) = v42[18];
                    *((_DWORD *)v51 + 7) = v42[19];
                    *((_QWORD *)v51 + 4) = v20;
                    *((_QWORD *)v51 + 5) = *v34;
                    *((_QWORD *)v51 + 6) = v38;
                    v52 = *(_DWORD **)v41;
                    if (v44 == *(_DWORD **)v41)
                    {
                      v55 = &v50[56 * v46];
                    }
                    else
                    {
                      v53 = 0;
                      do
                      {
                        v54 = &v51[v53 * 4];
                        *((_DWORD *)v54 - 14) = v44[v53 - 14];
                        *((_DWORD *)v54 - 13) = v44[v53 - 13];
                        *((_DWORD *)v54 - 12) = v44[v53 - 12];
                        *((_DWORD *)v54 - 11) = v44[v53 - 11];
                        *((_DWORD *)v54 - 10) = v44[v53 - 10];
                        *((_DWORD *)v54 - 9) = v44[v53 - 9];
                        *((_DWORD *)v54 - 8) = v44[v53 - 8];
                        *((_DWORD *)v54 - 7) = v44[v53 - 7];
                        *((_QWORD *)v54 - 3) = *(_QWORD *)&v44[v53 - 6];
                        *((_OWORD *)v54 - 1) = *(_OWORD *)&v44[v53 - 4];
                        v53 -= 14;
                      }
                      while (&v44[v53] != v52);
                      v44 = *(_DWORD **)v41;
                      v55 = &v51[v53 * 4];
                    }
                    v45 = v51 + 56;
                    *(_QWORD *)v41 = v55;
                    *(_QWORD *)(v41 + 8) = v51 + 56;
                    *(_QWORD *)(v41 + 16) = &v50[56 * v49];
                    if (v44)
                      operator delete(v44);
                  }
                  else
                  {
                    *v44 = v42[12];
                    v44[1] = v42[13];
                    v44[2] = v42[14];
                    v44[3] = v42[15];
                    v44[4] = v42[16];
                    v44[5] = v42[17];
                    v44[6] = v42[18];
                    v44[7] = v42[19];
                    *((_QWORD *)v44 + 4) = v20;
                    *((_QWORD *)v44 + 5) = *v34;
                    *((_QWORD *)v44 + 6) = v38;
                    v45 = v44 + 14;
                  }
                  *(_QWORD *)(v41 + 8) = v45;
                }
                else
                {
                  *v66 |= v40;
                }
              }
              *(_QWORD *)(v4 + 2248) += *(_QWORD *)(v38 + 160);
            }
          }
        }
        ++v34;
      }
      if (*(_QWORD *)(v23 + 104) == *(_QWORD *)(v23 + 96))
      {
        v56 = v12;
        v15 = v12;
      }
      else
      {
        if (v12 >= v69)
        {
          v57 = 0xAAAAAAAAAAAAAAABLL * ((v12 - __p) >> 3) + 1;
          if (v57 > 0xAAAAAAAAAAAAAAALL)
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          if (0x5555555555555556 * ((v69 - __p) >> 3) > v57)
            v57 = 0x5555555555555556 * ((v69 - __p) >> 3);
          if (0xAAAAAAAAAAAAAAABLL * ((v69 - __p) >> 3) >= 0x555555555555555)
            v58 = 0xAAAAAAAAAAAAAAALL;
          else
            v58 = v57;
          if (v58)
          {
            if (v58 > 0xAAAAAAAAAAAAAAALL)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v59 = (char *)operator new(24 * v58);
          }
          else
          {
            v59 = 0;
          }
          v60 = &v59[8 * ((v12 - __p) >> 3)];
          *(_QWORD *)v60 = v23;
          *((_QWORD *)v60 + 1) = 0;
          v60[16] = v74;
          if (v12 == __p)
          {
            v10 = &v59[8 * ((v12 - __p) >> 3)];
          }
          else
          {
            v61 = &v59[8 * ((v12 - __p) >> 3)];
            do
            {
              v62 = *(_OWORD *)(v12 - 24);
              *((_QWORD *)v61 - 1) = *((_QWORD *)v12 - 1);
              *(_OWORD *)(v61 - 24) = v62;
              v61 -= 24;
              v12 -= 24;
            }
            while (v12 != __p);
            v12 = __p;
            v10 = v61;
          }
          v69 = &v59[24 * v58];
          v56 = v60 + 24;
          if (v12)
            operator delete(v12);
          goto LABEL_63;
        }
        *(_QWORD *)v12 = v23;
        *((_QWORD *)v12 + 1) = 0;
        v12[16] = v74;
        v56 = v12 + 24;
        v15 = v12 + 24;
      }
      v10 = __p;
    }
    else
    {
      v56 = v12;
    }
LABEL_65:
    v12 = v56;
  }
  while (v10 != v15);
  if (v15)
    operator delete(v15);
  std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100](v68 + 25, (uint64_t *)&v78);
  *((_DWORD *)v68 + 54) = v79;
  std::condition_variable::~condition_variable(&v81.__gate2_);
  std::condition_variable::~condition_variable(&v81.__gate1_);
  std::mutex::~mutex(&v81.__mut_);
  v63 = (std::__shared_weak_count *)*((_QWORD *)&v78 + 1);
  if (*((_QWORD *)&v78 + 1))
  {
    v64 = (unint64_t *)(*((_QWORD *)&v78 + 1) + 8);
    do
      v65 = __ldaxr(v64);
    while (__stlxr(v65 - 1, v64));
    if (!v65)
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
    }
  }
}

void sub_2165CCF88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  if (__p)
    operator delete(__p);
  Phase::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64,Phase::Geometry::ShapeFactory>::~SharedSlotMap((std::condition_variable *)&a25);
  _Unwind_Resume(a1);
}

void Phase::details::SharedSlotMap<Phase::Geometry::Entity,Phase::Handle64>::Resize(__int128 *a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  __int128 *v15;
  char v16;
  __int128 v17;

  v2 = *((unsigned int *)a1 + 4);
  if (v2 < a2)
  {
    Phase::details::SharedSlotMap<Phase::Geometry::Entity,Phase::Handle64>::AllocSlots(a2, &v17);
    if ((_DWORD)v2)
    {
      v5 = 0;
      do
      {
        v6 = (uint64_t *)(*(_QWORD *)a1 + v5);
        v7 = v17 + v5;
        std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(v17 + v5), v6);
        *(_QWORD *)(v7 + 16) = v6[2];
        v5 += 24;
      }
      while (24 * v2 != v5);
      v8 = v2;
    }
    else
    {
      v8 = 0;
    }
    v9 = 24 * v8;
    do
    {
      v10 = v17 + v9;
      std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)(v17 + v9));
      *(_QWORD *)(v10 + 16) = 0x1FFFFFFFFLL;
      LODWORD(v2) = v2 + 1;
      v9 += 24;
    }
    while (a2 != (_DWORD)v2);
    v15 = a1 + 2;
    v16 = 1;
    std::__shared_mutex_base::lock((std::__shared_mutex_base *)(a1 + 2));
    v11 = *a1;
    *a1 = v17;
    v17 = v11;
    std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v15);
    *((_DWORD *)a1 + 4) = a2;
    v12 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
    if (*((_QWORD *)&v17 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
}

void sub_2165CD128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<Phase::Geometry::MpsCpuSceneDescriptor>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;

  v3 = *a1;
  v2 = a1[1];
  if (v2 != *a1)
  {
    v4 = a1[1];
    do
    {
      v6 = *(void **)(v4 - 48);
      v4 -= 48;
      v5 = v6;
      if (v6)
      {
        *(_QWORD *)(v2 - 40) = v5;
        operator delete(v5);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

void Phase::Geometry::ShapeDebugger::GetVoxels(Phase::Geometry::System **a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  std::__shared_weak_count *v24;

  Phase::Geometry::System::GetCurrentState(*a1, &v23);
  if (*(_DWORD *)(v23 + 112) > a2
    && (v9 = *(_QWORD *)(v23 + 96), *(_DWORD *)(v9 + 24 * a2 + 20) == HIDWORD(a2))
    && (v10 = *(_QWORD *)(v9 + 24 * a2)) != 0
    && (v11 = **(_QWORD **)(v10 + 120)) != 0
    && (v12 = *(_QWORD **)(**(_QWORD **)(v11 + 40) + 16 * *(_QWORD *)(v11 + 48)), v12[3] > a3)
    && (v13 = v12[1] + v12[4] * a3,
        v14 = *(_QWORD *)(**(_QWORD **)(v13 + 40) + 16 * *(_QWORD *)(v13 + 48)),
        *(_QWORD *)(v14 + 24) > a4))
  {
    *(_OWORD *)(a5 + 16) = 0u;
    *(_OWORD *)(a5 + 32) = 0u;
    *(_OWORD *)a5 = 0u;
    if (a4)
    {
      v15 = *(uint64_t **)(*(_QWORD *)(**(_QWORD **)(*(_QWORD *)(v14 + 8) + 56)
                                    + 16 * *(_QWORD *)(*(_QWORD *)(v14 + 8) + 64))
                        + 8);
      v21 = 0;
      v22 = 0;
      Phase::Geometry::sAddVoxels((uint64_t *)a5, v13, v15, (uint64_t)&v21, 1, a4);
    }
    else
    {
      LODWORD(v21) = 0;
      WORD2(v21) = 0;
      *(_QWORD *)(a5 + 32) = std::vector<Phase::Vector<unsigned short,3ul>>::__push_back_slow_path<Phase::Vector<unsigned short,3ul>>((uint64_t *)(a5 + 24), &v21);
    }
    v19 = *(_QWORD *)(**(_QWORD **)(v13 + 40) + 16 * *(_QWORD *)(v13 + 48));
    v20 = (_DWORD *)(*(_QWORD *)(v19 + 8) + *(_QWORD *)(v19 + 32) * a4);
    *(_DWORD *)(a5 + 12) = v20[4];
    *(_DWORD *)(a5 + 16) = v20[5];
    *(_DWORD *)(a5 + 20) = v20[6];
    *(_DWORD *)a5 = *(_DWORD *)v13;
    *(_DWORD *)(a5 + 4) = *(_DWORD *)(v13 + 4);
    *(_DWORD *)(a5 + 8) = *(_DWORD *)(v13 + 8);
  }
  else
  {
    *(_OWORD *)(a5 + 16) = 0u;
    *(_OWORD *)(a5 + 32) = 0u;
    *(_OWORD *)a5 = 0u;
  }
  v16 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
}

void sub_2165CD35C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  void *v5;
  va_list va;

  va_start(va, a3);
  v5 = *(void **)(v3 + 24);
  if (v5)
  {
    *(_QWORD *)(v3 + 32) = v5;
    operator delete(v5);
  }
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void Phase::Geometry::sAddVoxels(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint32x2_t v16;
  int32x2_t v17;
  __int16 v18;
  __int16 v19;
  unint64_t v20;
  _WORD *v21;
  _WORD *v22;
  uint8x8_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  _WORD *v34;
  uint64_t *v35;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  __int128 __p;
  _WORD *v41;
  unint64_t v42;
  uint64_t *v43;

  v7 = a5;
  v9 = a3;
  v10 = a2;
  v12 = 0;
  v13 = *(_QWORD *)(**(_QWORD **)(a2 + 40) + 16 * *(_QWORD *)(a2 + 48));
  v38 = a5 + 1;
  v39 = *(_QWORD *)(v13 + 8) + *(_QWORD *)(v13 + 32) * a5;
  v35 = a1 + 5;
  v37 = a1 + 3;
  do
  {
    v14 = *v9;
    if ((((unint64_t)*v9 >> v12) & 1) != 0)
    {
      v15 = *(_DWORD *)a4 + (v12 & 1 | (2 * ((v12 >> 3) & 1)));
      v16 = (uint32x2_t)vand_s8((int8x8_t)vdup_n_s32(v12), (int8x8_t)0x2400000012);
      v17 = vadd_s32(*(int32x2_t *)(a4 + 4), (int32x2_t)vorr_s8((int8x8_t)(*(_QWORD *)&vshl_u32(v16, (uint32x2_t)0xFFFFFFFEFFFFFFFFLL) & 0xFFFFFFC1FFFFFFC1), (int8x8_t)vshl_u32(v16, (uint32x2_t)0xFFFFFFFCFFFFFFFDLL)));
      if (v7 == a6)
      {
        v18 = v17.i16[0];
        v19 = v17.i16[2];
        v21 = (_WORD *)a1[4];
        v20 = a1[5];
        if ((unint64_t)v21 >= v20)
        {
          v25 = a4;
          v26 = a6;
          v27 = v7;
          v28 = v10;
          v29 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v21 - *v37) >> 1);
          v30 = v29 + 1;
          if (v29 + 1 > 0x2AAAAAAAAAAAAAAALL)
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - *v37) >> 1);
          if (2 * v31 > v30)
            v30 = 2 * v31;
          if (v31 >= 0x1555555555555555)
            v32 = 0x2AAAAAAAAAAAAAAALL;
          else
            v32 = v30;
          v43 = v35;
          if (v32)
            v32 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Vector<unsigned short,3ul>>>(v32);
          else
            v33 = 0;
          v34 = (_WORD *)(v32 + 6 * v29);
          *(_QWORD *)&__p = v32;
          *((_QWORD *)&__p + 1) = v34;
          *v34 = v15;
          v34[1] = v18;
          v34[2] = v19;
          v41 = v34 + 3;
          v42 = v32 + 6 * v33;
          std::vector<Phase::Vector<unsigned short,3ul>>::__swap_out_circular_buffer(v37, &__p);
          v22 = (_WORD *)a1[4];
          if ((_QWORD)__p)
            operator delete((void *)__p);
          v10 = v28;
          v7 = v27;
          a6 = v26;
          a4 = v25;
          v9 = a3;
        }
        else
        {
          *v21 = v15;
          v21[1] = v17.i16[0];
          v22 = v21 + 3;
          v21[2] = v17.i16[2];
        }
        a1[4] = (uint64_t)v22;
      }
      else
      {
        LODWORD(__p) = 4 * v15;
        *(int32x2_t *)((char *)&__p + 4) = vshl_n_s32(v17, 2uLL);
        v23 = (uint8x8_t)vcnt_s8((int8x8_t)(v14 & ~(-1 << v12)));
        v23.i16[0] = vaddlv_u8(v23);
        v24 = *(_QWORD *)(**(_QWORD **)(v39 + 56) + 16 * *(_QWORD *)(v39 + 64));
        Phase::Geometry::sAddVoxels(a1, v10, *(_QWORD *)(v24 + 8) + *(_QWORD *)(v24 + 32) * (*((_DWORD *)v9 + 2) + v23.i32[0]), &__p, v38, a6);
      }
    }
    ++v12;
  }
  while (v12 != 64);
}

uint64_t *std::vector<Phase::Vector<unsigned short,3ul>>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __int16 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  while (v2 != v3)
  {
    v5 = *(_WORD *)(v2 - 6);
    v2 -= 6;
    *(_WORD *)(v4 - 6) = v5;
    v4 -= 6;
    *(_WORD *)(v4 + 2) = *(_WORD *)(v2 + 2);
    *(_WORD *)(v4 + 4) = *(_WORD *)(v2 + 4);
  }
  a2[1] = v4;
  v6 = *result;
  *result = v4;
  a2[1] = v6;
  v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Vector<unsigned short,3ul>>>(unint64_t a1)
{
  if (a1 >= 0x2AAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(6 * a1);
}

uint64_t std::vector<Phase::Vector<unsigned short,3ul>>::__push_back_slow_path<Phase::Vector<unsigned short,3ul>>(uint64_t *a1, _WORD *a2)
{
  unint64_t v2;
  unint64_t v3;
  void *v6;
  unint64_t v7;
  uint64_t v8;
  _WORD *v9;
  uint64_t v10;
  void *__p[5];

  v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 1);
  v3 = v2 + 1;
  if (v2 + 1 > 0x2AAAAAAAAAAAAAAALL)
    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
  v6 = a1 + 2;
  if (0x5555555555555556 * ((a1[2] - *a1) >> 1) > v3)
    v3 = 0x5555555555555556 * ((a1[2] - *a1) >> 1);
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 1) >= 0x1555555555555555)
    v7 = 0x2AAAAAAAAAAAAAAALL;
  else
    v7 = v3;
  __p[4] = v6;
  if (v7)
    v7 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Vector<unsigned short,3ul>>>(v7);
  else
    v8 = 0;
  v9 = (_WORD *)(v7 + 6 * v2);
  __p[0] = (void *)v7;
  __p[1] = v9;
  *v9 = *a2;
  v9[1] = a2[1];
  v9[2] = a2[2];
  __p[2] = v9 + 3;
  __p[3] = (void *)(v7 + 6 * v8);
  std::vector<Phase::Vector<unsigned short,3ul>>::__swap_out_circular_buffer(a1, __p);
  v10 = a1[1];
  if (__p[0])
    operator delete(__p[0]);
  return v10;
}

uint64_t Phase::Geometry::ShapeFactory::Create@<X0>(uint64_t a1@<X0>, unsigned int *a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t result;

  v3 = *a2;
  v4 = *(_QWORD *)(*(_QWORD *)a1 + 1216);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)a1 + 1224) - v4) >> 5) <= v3)
    __assert_rtn("GetTypeDef", "GeoShapeTypeRegistry.cpp", 33, "IsValid(inShapeType)");
  result = *(_QWORD *)(v4 + 96 * v3 + 64);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  *a3 = 0;
  a3[1] = 0;
  return result;
}

uint64_t *Phase::Geometry::ShapeFactory::Create@<X0>(uint64_t *result@<X0>, unsigned int a2@<W1>, _DWORD *a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE v16[24];
  uint64_t *v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(*result + 1216);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*result + 1224) - v6) >> 5) <= a2)
    __assert_rtn("GetTypeDef", "GeoShapeTypeRegistry.cpp", 33, "IsValid(inShapeType)");
  v7 = v6 + 96 * a2;
  v8 = *(_DWORD **)(v7 + 72);
  v9 = *(_DWORD **)(v7 + 80);
  if (v8 == v9)
    goto LABEL_11;
  v12 = result;
  while (*v8 != *a3)
  {
    v8 += 10;
    if (v8 == v9)
      goto LABEL_11;
  }
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v16, (uint64_t)(v8 + 2));
  result = v17;
  if (!v17)
  {
LABEL_11:
    *a5 = 0;
    a5[1] = 0;
  }
  else
  {
    v13 = *v12;
    v15 = a4;
    (*(void (**)(uint64_t *, uint64_t, _DWORD *, uint64_t *))(*v17 + 48))(v17, v13, a3, &v15);
    result = v17;
    if (v17 == (uint64_t *)v16)
    {
      v14 = 4;
      result = (uint64_t *)v16;
      return (uint64_t *)(*(uint64_t (**)(void))(*result + 8 * v14))();
    }
    if (v17)
    {
      v14 = 5;
      return (uint64_t *)(*(uint64_t (**)(void))(*result + 8 * v14))();
    }
  }
  return result;
}

void sub_2165CD9AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *Phase::Geometry::ShapeTypeRegistry::CustomizeType(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 16) - v3) >> 5) <= a2)
    __assert_rtn("CustomizeType", "GeoShapeTypeRegistry.cpp", 43, "IsValid(inShapeType)");
  return std::function<std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((_QWORD *)(v3 + 96 * a2 + 8), a3);
}

{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 16) - v3) >> 5) <= a2)
    __assert_rtn("CustomizeType", "GeoShapeTypeRegistry.cpp", 54, "IsValid(inShapeType)");
  return std::function<std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Geometry::Shape&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((_QWORD *)(v3 + 96 * a2 + 40), a3);
}

_QWORD *std::function<std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

_QWORD *std::function<std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Geometry::Shape&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Geometry::Shape&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

_QWORD *Phase::Geometry::ShapeTypeRegistry::CustomizeType(uint64_t a1, unsigned int a2, int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t i;
  _QWORD *v11;
  _DWORD *v12;
  _DWORD *v13;
  _QWORD *result;
  uint64_t v15;
  int v16;
  _BYTE v17[24];
  _BYTE *v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 16) - v4) >> 5) <= a2)
    __assert_rtn("CustomizeType", "GeoShapeTypeRegistry.cpp", 65, "IsValid(inShapeType)");
  v6 = v4 + 96 * a2;
  v9 = *(_QWORD *)(v6 + 80);
  v8 = (uint64_t *)(v6 + 80);
  v7 = v9;
  for (i = *(v8 - 1); i != v7; i += 40)
  {
    if (*(_DWORD *)i == a3)
      return std::function<std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((_QWORD *)(i + 8), a4);
  }
  v16 = a3;
  v11 = v17;
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v17, a4);
  v12 = (_DWORD *)*v8;
  if ((unint64_t)*v8 >= *(_QWORD *)(v4 + 96 * a2 + 88))
  {
    result = (_QWORD *)std::vector<Phase::Geometry::LoadShapeFunctionTableEntry>::__push_back_slow_path<Phase::Geometry::LoadShapeFunctionTableEntry>(v8 - 1, &v16);
    v13 = result;
  }
  else
  {
    *v12 = v16;
    v13 = v12 + 10;
    result = (_QWORD *)std::__function::__value_func<std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100]((uint64_t)(v12 + 2), (uint64_t)v17);
  }
  *v8 = (uint64_t)v13;
  if (v18 == v17)
  {
    v15 = 4;
  }
  else
  {
    if (!v18)
      return result;
    v15 = 5;
    v11 = v18;
  }
  return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v11 + 8 * v15))(v11);
}

void sub_2165CDD80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, _QWORD *a13)
{
  _QWORD *v13;
  uint64_t v15;

  if (a13 == v13)
  {
    v15 = 4;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
    v13 = a13;
  }
  (*(void (**)(_QWORD *))(*v13 + 8 * v15))(v13);
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *std::function<std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::vector<Phase::Geometry::ShapeTypeDefinition>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 5);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<Phase::Geometry::ShapeTypeDefinition>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 96 * a2;
    while (v3 != v7)
    {
      v3 -= 96;
      std::allocator<Phase::Geometry::DirectivityTypeDefinition>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
    }
    a1[1] = v7;
  }
}

void std::vector<Phase::Geometry::LoadShapeFunctionTableEntry>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

_QWORD *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_2165CE068(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Geometry::Shape&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_2165CE1DC(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_2165CE350(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t std::vector<Phase::Geometry::LoadShapeFunctionTableEntry>::__push_back_slow_path<Phase::Geometry::LoadShapeFunctionTableEntry>(uint64_t *a1, _DWORD *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  void *v14[5];

  v3 = *a1;
  v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0x666666666666666)
    std::vector<Phase::Geometry::LoadShapeFunctionTableEntry>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x333333333333333)
    v9 = 0x666666666666666;
  else
    v9 = v5;
  v14[4] = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[40 * v4];
  v14[0] = v10;
  v14[1] = v11;
  v14[3] = &v10[40 * v9];
  *(_DWORD *)v11 = *a2;
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100]((uint64_t)(v11 + 8), (uint64_t)(a2 + 2));
  v14[2] = v11 + 40;
  std::vector<Phase::Geometry::LoadShapeFunctionTableEntry>::__swap_out_circular_buffer(a1, v14);
  v12 = a1[1];
  std::__split_buffer<Phase::Geometry::LoadShapeFunctionTableEntry>::~__split_buffer(v14);
  return v12;
}

void sub_2165CE44C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<Phase::Geometry::LoadShapeFunctionTableEntry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

uint64_t *std::vector<Phase::Geometry::LoadShapeFunctionTableEntry>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = result;
  v5 = *result;
  v4 = result[1];
  v6 = a2[1];
  while (v4 != v5)
  {
    v7 = *(_DWORD *)(v4 - 40);
    v4 -= 40;
    *(_DWORD *)(v6 - 40) = v7;
    v6 -= 40;
    result = (uint64_t *)std::__function::__value_func<std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100](v6 + 8, v4 + 8);
  }
  a2[1] = v6;
  v8 = *v3;
  *v3 = v6;
  a2[1] = v8;
  v9 = v3[1];
  v3[1] = a2[2];
  a2[2] = v9;
  v10 = v3[2];
  v3[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

void **std::__split_buffer<Phase::Geometry::LoadShapeFunctionTableEntry>::~__split_buffer(void **a1)
{
  std::__split_buffer<Phase::Geometry::LoadShapeFunctionTableEntry>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

_QWORD *std::__split_buffer<Phase::Geometry::LoadShapeFunctionTableEntry>::clear[abi:ne180100](_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = result[1];
  v1 = result[2];
  if (v1 != v2)
  {
    v3 = result;
    do
    {
      v3[2] = v1 - 40;
      result = *(_QWORD **)(v1 - 8);
      if (result == (_QWORD *)(v1 - 32))
      {
        result = (_QWORD *)(v1 - 32);
        v4 = 4;
      }
      else
      {
        if (!result)
        {
          v1 -= 40;
          continue;
        }
        v4 = 5;
      }
      result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v4))();
      v1 = v3[2];
    }
    while (v1 != v2);
  }
  return result;
}

uint64_t std::vector<Phase::Geometry::ShapeTypeDefinition>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::ShapeTypeDefinition>,std::reverse_iterator<Phase::Geometry::ShapeTypeDefinition*>,std::reverse_iterator<Phase::Geometry::ShapeTypeDefinition*>,std::reverse_iterator<Phase::Geometry::ShapeTypeDefinition*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::ShapeTypeDefinition>,std::reverse_iterator<Phase::Geometry::ShapeTypeDefinition*>,std::reverse_iterator<Phase::Geometry::ShapeTypeDefinition*>,std::reverse_iterator<Phase::Geometry::ShapeTypeDefinition*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;

  if (a3 != a5)
  {
    v11 = 0;
    v12 = a3;
    while (1)
    {
      v13 = a7 + v11;
      v14 = a3 + v11;
      *(_QWORD *)(a7 + v11 - 96) = *(_QWORD *)(a3 + v11 - 96);
      v15 = *(_QWORD *)(a3 + v11 - 64);
      if (!v15)
        break;
      if (v14 - 88 != v15)
      {
        v16 = (_QWORD *)(v12 - 64);
        *(_QWORD *)(v13 - 64) = v15;
LABEL_7:
        *v16 = 0;
        goto LABEL_9;
      }
      *(_QWORD *)(v13 - 64) = v13 - 88;
      (*(void (**)(_QWORD))(**(_QWORD **)(v14 - 64) + 24))(*(_QWORD *)(v14 - 64));
LABEL_9:
      v17 = a7 + v11;
      v18 = a3 + v11;
      v19 = *(_QWORD *)(a3 + v11 - 32);
      if (v19)
      {
        if (v18 - 56 == v19)
        {
          *(_QWORD *)(v17 - 32) = v17 - 56;
          (*(void (**)(_QWORD))(**(_QWORD **)(v18 - 32) + 24))(*(_QWORD *)(v18 - 32));
          goto LABEL_15;
        }
        v20 = (_QWORD *)(v12 - 32);
        *(_QWORD *)(v17 - 32) = v19;
      }
      else
      {
        v20 = (_QWORD *)(v17 - 32);
      }
      *v20 = 0;
LABEL_15:
      v12 -= 96;
      v21 = a7 + v11;
      v22 = a3 + v11;
      *(_QWORD *)(v21 - 24) = 0;
      *(_QWORD *)(v21 - 16) = 0;
      *(_QWORD *)(v21 - 8) = 0;
      *(_OWORD *)(v21 - 24) = *(_OWORD *)(a3 + v11 - 24);
      *(_QWORD *)(v21 - 8) = *(_QWORD *)(a3 + v11 - 8);
      *(_QWORD *)(v22 - 24) = 0;
      *(_QWORD *)(v22 - 16) = 0;
      *(_QWORD *)(v22 - 8) = 0;
      v11 -= 96;
      if (a3 + v11 == a5)
        return a6;
    }
    v16 = (_QWORD *)(v13 - 64);
    goto LABEL_7;
  }
  return a6;
}

void std::vector<Phase::Geometry::ShapeTypeDefinition>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  void *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 5) >= a2)
  {
    if (a2)
    {
      v13 = 96 * ((96 * a2 - 96) / 0x60) + 96;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 5);
    v9 = v8 + a2;
    if (v8 + a2 > 0x2AAAAAAAAAAAAAALL)
      std::vector<Phase::Geometry::LoadShapeFunctionTableEntry>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 5);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x155555555555555)
      v11 = 0x2AAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::VoiceData>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[96 * v8];
    v18 = &v12[96 * v11];
    v14 = 96 * ((96 * a2 - 96) / 0x60) + 96;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<Phase::Geometry::ShapeTypeDefinition>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::~__split_buffer(&v15);
  }
}

void sub_2165CE8F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::InitMaterials(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t result;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  result = Phase::Geometry::DataStreamReference<Phase::Handle64>::Resize(a1 + 144, a2);
  v6 = *(_QWORD **)(**(_QWORD **)(a1 + 144) + 16 * *(_QWORD *)(a1 + 152));
  v7 = v6[3];
  if (v7)
  {
    v8 = (_QWORD *)v6[1];
    v9 = v6[4];
    do
    {
      *v8 = a3;
      v8 = (_QWORD *)((char *)v8 + v9);
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t Phase::Geometry::DataStreamReference<Phase::Handle64>::Resize(uint64_t result, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  uint64_t v18;

  v3 = result;
  v4 = *(_QWORD *)(**(_QWORD **)result + 16 * *(_QWORD *)(result + 8));
  v5 = *(_QWORD *)(v4 + 24);
  if (v5 == a2)
  {
    v6 = 0;
  }
  else
  {
    v6 = *(uint64_t **)(v4 + 8);
    *(_QWORD *)(v4 + 8) = 0;
    if (a2)
    {
      Phase::Geometry::DataStream::Alloc(*(std::align_val_t *)(v4 + 16), *(_QWORD *)(v4 + 32) * a2, &v18);
      v7 = v18;
      v18 = 0;
      result = *(_QWORD *)(v4 + 8);
      *(_QWORD *)(v4 + 8) = v7;
      if (result)
      {
        MEMORY[0x2199F9D4C](result, 0x1000C8077774924);
        result = v18;
        v18 = 0;
        if (result)
          result = MEMORY[0x2199F9D4C](result, 0x1000C8077774924);
      }
    }
    *(_QWORD *)(v4 + 24) = a2;
  }
  if (v5 >= a2)
    v8 = a2;
  else
    v8 = v5;
  if (v8)
  {
    v9 = *(_QWORD **)(v4 + 8);
    v10 = v6;
    v11 = v8;
    do
    {
      v12 = *v10++;
      *v9++ = v12;
      --v11;
    }
    while (v11);
  }
  if (v5 < a2)
  {
    v13 = *(_QWORD *)(**(_QWORD **)v3 + 16 * *(_QWORD *)(v3 + 8));
    v14 = *(_QWORD *)(v13 + 8);
    v15 = *(_QWORD *)(v13 + 32);
    v16 = a2 - v8;
    v17 = (_QWORD *)(v14 + v15 * v8);
    do
    {
      *v17 = 0;
      v17 = (_QWORD *)((char *)v17 + v15);
      --v16;
    }
    while (v16);
  }
  if (v6)
    return MEMORY[0x2199F9D4C](v6, 0x1000C8077774924);
  return result;
}

void sub_2165CEAA4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    MEMORY[0x2199F9D4C](v1, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void Phase::Geometry::InitSurfaceArea(uint64_t a1, unint64_t a2)
{
  void *v3;
  uint64_t v4;

  std::vector<float>::resize(a1 + 72, a2);
  v3 = *(void **)(a1 + 72);
  v4 = *(_QWORD *)(a1 + 80) - (_QWORD)v3;
  if (v4 >= 1)
    bzero(v3, 4 * (((unint64_t)v4 >> 2) - ((unint64_t)v4 > 3)) + 4);
}

uint64_t **Phase::Geometry::SetMaterialsFromOptionalMaterialList(uint64_t **result, _QWORD *a2)
{
  uint64_t **v2;
  uint64_t *v3;
  uint64_t *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;

  if (a2)
  {
    v2 = result;
    result = Phase::UnorderedStringMap<Phase::OptionsValue>::Find(a2, (__int128 *)&Phase::Geometry::ShapeOptions::MaterialList);
    if (result)
    {
      if (*((_DWORD *)result + 24) == 10)
      {
        v4 = result[7];
        v3 = result[8];
        if (v3 != v4)
        {
          v5 = *(_QWORD **)(*v2[18] + 16 * (_QWORD)v2[19]);
          v6 = v5[3];
          if (v6)
          {
            v7 = (_QWORD *)v5[1];
            v8 = v5[4];
            v9 = result[7];
            do
            {
              v10 = *v9++;
              *v7 = v10;
              if (v3 == v9)
                v9 = v4;
              v7 = (_QWORD *)((char *)v7 + v8);
              --v6;
            }
            while (v6);
          }
        }
      }
    }
  }
  return result;
}

void Phase::Geometry::ForcedCopyTagsIncludingMaterialListFromOptions(std::vector<unsigned int>::size_type __n@<X1>, _QWORD *a2@<X0>, std::vector<unsigned int> *a3@<X8>)
{
  uint64_t **v6;
  _BOOL4 v7;
  uint64_t **v8;
  uint64_t **v9;
  std::vector<unsigned int>::size_type v10;
  char v11;
  uint64_t v12;
  unsigned int *value;
  std::vector<unsigned int>::pointer end;
  unsigned int *v15;
  std::vector<unsigned int>::pointer begin;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  unsigned int *v22;
  unsigned int *v23;
  unsigned int v24;
  uint64_t *v25;
  uint64_t *v26;
  std::__compressed_pair<unsigned int *> *p_end_cap;
  std::vector<unsigned int>::pointer v28;
  unsigned int *v29;
  std::vector<unsigned int>::pointer v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  char *v35;
  unsigned int *v36;
  unsigned int v37;

  a3->__begin_ = 0;
  a3->__end_ = 0;
  a3->__end_cap_.__value_ = 0;
  if (!a2)
  {
    std::vector<unsigned int>::reserve(a3, __n);
    return;
  }
  v6 = Phase::UnorderedStringMap<Phase::OptionsValue>::Find(a2, (__int128 *)&Phase::Geometry::ShapeOptions::MaterialList);
  v7 = v6 && *((_DWORD *)v6 + 24) == 10;
  v8 = Phase::UnorderedStringMap<Phase::OptionsValue>::Find(a2, (__int128 *)&Phase::Geometry::ShapeOptions::ForcedCopyTags);
  v9 = v8;
  v10 = __n + v7;
  if (!v8)
    goto LABEL_11;
  if (*((_DWORD *)v8 + 24) != 9)
  {
    v9 = 0;
LABEL_11:
    v12 = 0;
    v11 = 1;
    goto LABEL_12;
  }
  v11 = 0;
  v9 = v8 + 7;
  v12 = ((char *)v8[8] - (char *)v8[7]) >> 2;
LABEL_12:
  std::vector<unsigned int>::reserve(a3, v10 + v12);
  if (v7)
  {
    value = a3->__end_cap_.__value_;
    end = a3->__end_;
    if (end >= value)
    {
      begin = a3->__begin_;
      v17 = end - a3->__begin_;
      v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 62)
        std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
      v19 = (char *)value - (char *)begin;
      if (v19 >> 1 > v18)
        v18 = v19 >> 1;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL)
        v20 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v20 = v18;
      if (v20)
      {
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&a3->__end_cap_, v20);
        begin = a3->__begin_;
        end = a3->__end_;
      }
      else
      {
        v21 = 0;
      }
      v22 = (unsigned int *)&v21[4 * v17];
      v23 = (unsigned int *)&v21[4 * v20];
      *v22 = 1;
      v15 = v22 + 1;
      while (end != begin)
      {
        v24 = *--end;
        *--v22 = v24;
      }
      a3->__begin_ = v22;
      a3->__end_ = v15;
      a3->__end_cap_.__value_ = v23;
      if (begin)
        operator delete(begin);
    }
    else
    {
      *end = 1;
      v15 = end + 1;
    }
    a3->__end_ = v15;
  }
  if ((v11 & 1) == 0)
  {
    v25 = *v9;
    v26 = v9[1];
    if (*v9 != v26)
    {
      p_end_cap = &a3->__end_cap_;
      v28 = a3->__end_;
      do
      {
        if (v28 >= p_end_cap->__value_)
        {
          v30 = a3->__begin_;
          v31 = v28 - a3->__begin_;
          v32 = v31 + 1;
          if ((unint64_t)(v31 + 1) >> 62)
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          v33 = (char *)p_end_cap->__value_ - (char *)v30;
          if (v33 >> 1 > v32)
            v32 = v33 >> 1;
          if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFFCLL)
            v34 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v34 = v32;
          if (v34)
          {
            v35 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&a3->__end_cap_, v34);
            v30 = a3->__begin_;
            v28 = a3->__end_;
          }
          else
          {
            v35 = 0;
          }
          v36 = (unsigned int *)&v35[4 * v31];
          *v36 = *(_DWORD *)v25;
          v29 = v36 + 1;
          while (v28 != v30)
          {
            v37 = *--v28;
            *--v36 = v37;
          }
          a3->__begin_ = v36;
          a3->__end_ = v29;
          a3->__end_cap_.__value_ = (unsigned int *)&v35[4 * v34];
          if (v30)
            operator delete(v30);
        }
        else
        {
          *v28 = *(_DWORD *)v25;
          v29 = v28 + 1;
        }
        a3->__end_ = v29;
        v25 = (uint64_t *)((char *)v25 + 4);
        v28 = v29;
      }
      while (v25 != v26);
    }
  }
}

void sub_2165CEE2C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<unsigned int>::reserve(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  std::__compressed_pair<unsigned int *> *p_end_cap;
  unsigned int *value;
  int64_t v5;
  char *v6;
  unsigned int *v7;
  uint64_t v8;
  unsigned int *v9;
  std::vector<unsigned int>::pointer begin;
  unsigned int *end;
  unsigned int *v12;
  unsigned int v13;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (__n > value - this->__begin_)
  {
    if (__n >> 62)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v5 = (char *)this->__end_ - (char *)this->__begin_;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, __n);
    v7 = (unsigned int *)&v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    v9 = (unsigned int *)&v6[4 * v8];
    begin = this->__begin_;
    end = this->__end_;
    v12 = v7;
    if (end != this->__begin_)
    {
      v12 = v7;
      do
      {
        v13 = *--end;
        *--v12 = v13;
      }
      while (end != begin);
    }
    this->__begin_ = v12;
    this->__end_ = v7;
    this->__end_cap_.__value_ = v9;
    if (begin)
      operator delete(begin);
  }
}

uint64_t Phase::Geometry::GetNormals(int *a1, unsigned int *a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  int v6;

  v6 = *a1;
  if (*a1 == 3)
  {
    Phase::Geometry::GetNormals(**((_QWORD **)a1 + 15), a2, a3, a4, a5, a6);
    return 1;
  }
  if (v6 == 2)
  {
    Phase::Geometry::GetNormals(**((_QWORD **)a1 + 15), a2, a3, a4, a5, a6);
    return 1;
  }
  if (v6 == 1)
  {
    Phase::Geometry::GetNormals(**((_QWORD **)a1 + 15), a2, a3, a4, a5, a6);
    return 1;
  }
  return 0;
}

uint64_t Phase::Geometry::GetMaterials(int *a1, unsigned int *a2, int a3, _QWORD *a4, int a5, uint64_t a6)
{
  int v6;

  v6 = *a1;
  if (*a1 == 3)
  {
    Phase::Geometry::GetMaterials(**((_QWORD **)a1 + 15), a2, a3, a4, a5, a6);
    return 1;
  }
  if (v6 == 2)
  {
    Phase::Geometry::GetMaterials(**((_QWORD **)a1 + 15), a2, a3, a4, a5, a6);
    return 1;
  }
  if (v6 == 1)
  {
    Phase::Geometry::GetMaterials(**((_QWORD **)a1 + 15), (unint64_t)a2, a3, a4, a5, a6);
    return 1;
  }
  return 0;
}

uint64_t (*Phase::GetTypeId<Phase::Geometry::SimpleUniformMaterial>())()
{
  return Phase::GetTypeId<Phase::Geometry::SimpleUniformMaterial>;
}

uint64_t *Phase::Geometry::CreateSimpleUniformMaterial@<X0>(_QWORD *a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t **v3;
  uint64_t v4;
  _QWORD *v5;
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *result;
  __int128 v13[2];
  _QWORD v14[3];
  _QWORD *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v13[0] = "MaterialDataMapSize";
  *((_QWORD *)&v13[0] + 1) = 19;
  if (a1 && (v3 = Phase::UnorderedStringMap<Phase::OptionsValue>::Find(a1, v13)) != 0 && *((_DWORD *)v3 + 24) == 1)
  {
    LODWORD(v4) = *((_DWORD *)v3 + 14);
    if ((int)v4 <= 0)
      std::terminate();
  }
  else
  {
    LODWORD(v4) = 1;
  }
  v5 = operator new(0x58uLL);
  v5[1] = 0;
  v5[2] = 0;
  *v5 = &off_24D57D418;
  *((_DWORD *)v5 + 6) = 1;
  v6 = (char *)(v5 + 3);
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  v5[10] = 0;
  *((_OWORD *)v5 + 4) = 0u;
  v7 = v5 + 8;
  v4 = v4;
  *a2 = v5 + 3;
  a2[1] = v5;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v5 + 8, v4);
  v8 = 0;
  do
  {
    v9 = operator new();
    *(_QWORD *)v9 = Phase::GetTypeId<Phase::Geometry::SimpleUniformMaterial>;
    *(_QWORD *)(v9 + 8) = v6;
    *(_OWORD *)(v9 + 16) = 0u;
    *(_OWORD *)(v9 + 32) = 0u;
    *(_OWORD *)(v9 + 48) = 0u;
    *(_OWORD *)(v9 + 64) = 0u;
    *(_OWORD *)(v9 + 80) = 0u;
    *(_OWORD *)(v9 + 96) = 0u;
    *(_OWORD *)(v9 + 112) = 0u;
    *(_OWORD *)(v9 + 128) = 0u;
    *(_OWORD *)(v9 + 144) = 0u;
    *(_OWORD *)(v9 + 160) = 0u;
    *(_OWORD *)(v9 + 176) = 0u;
    *(_OWORD *)(v9 + 192) = 0u;
    *(_OWORD *)(v9 + 208) = 0u;
    *(_OWORD *)(v9 + 224) = 0u;
    *(_OWORD *)(v9 + 240) = 0u;
    *(_OWORD *)(v9 + 256) = 0u;
    *(_OWORD *)(v9 + 768) = 0u;
    *(_OWORD *)(v9 + 784) = 0u;
    *(_OWORD *)(v9 + 736) = 0u;
    *(_OWORD *)(v9 + 752) = 0u;
    *(_OWORD *)(v9 + 704) = 0u;
    *(_OWORD *)(v9 + 720) = 0u;
    *(_OWORD *)(v9 + 672) = 0u;
    *(_OWORD *)(v9 + 688) = 0u;
    *(_OWORD *)(v9 + 640) = 0u;
    *(_OWORD *)(v9 + 656) = 0u;
    *(_OWORD *)(v9 + 608) = 0u;
    *(_OWORD *)(v9 + 624) = 0u;
    *(_OWORD *)(v9 + 576) = 0u;
    *(_OWORD *)(v9 + 592) = 0u;
    *(_OWORD *)(v9 + 544) = 0u;
    *(_OWORD *)(v9 + 560) = 0u;
    *(_OWORD *)(v9 + 512) = 0u;
    *(_OWORD *)(v9 + 528) = 0u;
    *(_OWORD *)(v9 + 480) = 0u;
    *(_OWORD *)(v9 + 496) = 0u;
    *(_OWORD *)(v9 + 448) = 0u;
    *(_OWORD *)(v9 + 464) = 0u;
    *(_OWORD *)(v9 + 416) = 0u;
    *(_OWORD *)(v9 + 432) = 0u;
    *(_OWORD *)(v9 + 384) = 0u;
    *(_OWORD *)(v9 + 400) = 0u;
    *(_OWORD *)(v9 + 352) = 0u;
    *(_OWORD *)(v9 + 368) = 0u;
    *(_OWORD *)(v9 + 320) = 0u;
    *(_OWORD *)(v9 + 336) = 0u;
    *(_OWORD *)(v9 + 288) = 0u;
    *(_OWORD *)(v9 + 304) = 0u;
    v14[0] = &off_24D57D450;
    v15 = v14;
    *(_QWORD *)&v13[0] = v9;
    std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v13 + 8, (uint64_t)v14);
    v10 = v15;
    if (v15 == v14)
    {
      v10 = v14;
      v11 = 4;
    }
    else
    {
      if (!v15)
        goto LABEL_13;
      v11 = 5;
    }
    (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_13:
    std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(*v7 + v8), (uint64_t *)v13);
    result = std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v13);
    v8 += 40;
    --v4;
  }
  while (v4);
  return result;
}

void sub_2165CF1CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t *Phase::Geometry::CreateSimpleUniformMaterialFromMaterial@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  char *v5;
  _QWORD *v6;
  uint64_t *result;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _OWORD *v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD v41[3];
  _QWORD *v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)a1 != 1)
    std::terminate();
  v4 = operator new(0x58uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_24D57D418;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  v4[10] = 0;
  *((_DWORD *)v4 + 6) = 1;
  v5 = (char *)(v4 + 3);
  *((_OWORD *)v4 + 4) = 0u;
  v6 = v4 + 8;
  *a2 = v4 + 3;
  a2[1] = v4;
  result = std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v4 + 8, 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 48) - *(_QWORD *)(a1 + 40)) >> 3));
  v8 = *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)(a1 + 48) != v8)
  {
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *(_OWORD **)(v8 + v9);
      v12 = operator new();
      *(_QWORD *)v12 = Phase::GetTypeId<Phase::Geometry::SimpleUniformMaterial>;
      *(_QWORD *)(v12 + 8) = v5;
      memcpy((void *)(v12 + 16), v11 + 1, 0x110uLL);
      v13 = v11[21];
      v15 = v11[18];
      v14 = v11[19];
      *(_OWORD *)(v12 + 320) = v11[20];
      *(_OWORD *)(v12 + 336) = v13;
      *(_OWORD *)(v12 + 288) = v15;
      *(_OWORD *)(v12 + 304) = v14;
      v16 = v11[25];
      v18 = v11[22];
      v17 = v11[23];
      *(_OWORD *)(v12 + 384) = v11[24];
      *(_OWORD *)(v12 + 400) = v16;
      *(_OWORD *)(v12 + 352) = v18;
      *(_OWORD *)(v12 + 368) = v17;
      v19 = v11[29];
      v21 = v11[26];
      v20 = v11[27];
      *(_OWORD *)(v12 + 448) = v11[28];
      *(_OWORD *)(v12 + 464) = v19;
      *(_OWORD *)(v12 + 416) = v21;
      *(_OWORD *)(v12 + 432) = v20;
      v22 = v11[33];
      v24 = v11[30];
      v23 = v11[31];
      *(_OWORD *)(v12 + 512) = v11[32];
      *(_OWORD *)(v12 + 528) = v22;
      *(_OWORD *)(v12 + 480) = v24;
      *(_OWORD *)(v12 + 496) = v23;
      v25 = v11[34];
      v26 = v11[35];
      v27 = v11[37];
      *(_OWORD *)(v12 + 576) = v11[36];
      *(_OWORD *)(v12 + 592) = v27;
      *(_OWORD *)(v12 + 544) = v25;
      *(_OWORD *)(v12 + 560) = v26;
      v28 = v11[38];
      v29 = v11[39];
      v30 = v11[41];
      *(_OWORD *)(v12 + 640) = v11[40];
      *(_OWORD *)(v12 + 656) = v30;
      *(_OWORD *)(v12 + 608) = v28;
      *(_OWORD *)(v12 + 624) = v29;
      v31 = v11[42];
      v32 = v11[43];
      v33 = v11[45];
      *(_OWORD *)(v12 + 704) = v11[44];
      *(_OWORD *)(v12 + 720) = v33;
      *(_OWORD *)(v12 + 672) = v31;
      *(_OWORD *)(v12 + 688) = v32;
      v34 = v11[46];
      v35 = v11[47];
      v36 = v11[49];
      *(_OWORD *)(v12 + 768) = v11[48];
      *(_OWORD *)(v12 + 784) = v36;
      *(_OWORD *)(v12 + 736) = v34;
      *(_OWORD *)(v12 + 752) = v35;
      v41[0] = &off_24D57D450;
      v42 = v41;
      v39 = v12;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v40, (uint64_t)v41);
      v37 = v42;
      if (v42 == v41)
        break;
      if (v42)
      {
        v38 = 5;
LABEL_8:
        (*(void (**)(void))(*v37 + 8 * v38))();
      }
      std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(*v6 + v9), &v39);
      result = std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v39);
      ++v10;
      v8 = *(_QWORD *)(a1 + 40);
      v9 += 40;
      if (0xCCCCCCCCCCCCCCCDLL * ((*(_QWORD *)(a1 + 48) - v8) >> 3) <= v10)
        return result;
    }
    v37 = v41;
    v38 = 4;
    goto LABEL_8;
  }
  return result;
}

void sub_2165CF434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](a10);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<Phase::Geometry::Material>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57D418;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Phase::Geometry::Material>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57D418;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

void std::__shared_ptr_emplace<Phase::Geometry::Material>::__on_zero_shared(uint64_t a1)
{
  void **v2;

  v2 = (void **)(a1 + 64);
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (void **)(a1 + 40);
  std::vector<std::shared_ptr<Phase::Controller::Renderer>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SimpleUniformMaterial>(Phase::Geometry::SimpleUniformMaterial *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SimpleUniformMaterial>(Phase::Geometry::SimpleUniformMaterial *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SimpleUniformMaterial>(Phase::Geometry::SimpleUniformMaterial *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SimpleUniformMaterial>(Phase::Geometry::SimpleUniformMaterial *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57D450;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SimpleUniformMaterial>(Phase::Geometry::SimpleUniformMaterial *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SimpleUniformMaterial>(Phase::Geometry::SimpleUniformMaterial *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57D450;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SimpleUniformMaterial>(Phase::Geometry::SimpleUniformMaterial *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SimpleUniformMaterial>(Phase::Geometry::SimpleUniformMaterial *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
    JUMPOUT(0x2199F9D70);
  return result;
}

uint64_t (*Phase::GetTypeId<Phase::Geometry::SimpleUniformMedium>())()
{
  return Phase::GetTypeId<Phase::Geometry::SimpleUniformMedium>;
}

uint64_t *Phase::Geometry::CreateSimpleUniformMedium@<X0>(_QWORD *a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t **v3;
  uint64_t v4;
  _QWORD *v5;
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *result;
  __int128 v13[2];
  _QWORD v14[3];
  _QWORD *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v13[0] = "MediumDataMapSize";
  *((_QWORD *)&v13[0] + 1) = 17;
  if (a1 && (v3 = Phase::UnorderedStringMap<Phase::OptionsValue>::Find(a1, v13)) != 0 && *((_DWORD *)v3 + 24) == 1)
  {
    LODWORD(v4) = *((_DWORD *)v3 + 14);
    if ((int)v4 <= 0)
      std::terminate();
  }
  else
  {
    LODWORD(v4) = 1;
  }
  v5 = operator new(0x58uLL);
  v5[1] = 0;
  v5[2] = 0;
  *v5 = &off_24D57D498;
  *((_DWORD *)v5 + 6) = 1;
  v6 = (char *)(v5 + 3);
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  v5[10] = 0;
  *((_OWORD *)v5 + 4) = 0u;
  v7 = v5 + 8;
  v4 = v4;
  *a2 = v5 + 3;
  a2[1] = v5;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v5 + 8, v4);
  v8 = 0;
  do
  {
    v9 = operator new();
    *(_QWORD *)v9 = Phase::GetTypeId<Phase::Geometry::SimpleUniformMedium>;
    *(_QWORD *)(v9 + 8) = v6;
    *(_OWORD *)(v9 + 16) = 0u;
    *(_OWORD *)(v9 + 32) = 0u;
    *(_OWORD *)(v9 + 48) = 0u;
    *(_OWORD *)(v9 + 64) = 0u;
    *(_OWORD *)(v9 + 80) = 0u;
    *(_OWORD *)(v9 + 96) = 0u;
    *(_OWORD *)(v9 + 112) = 0u;
    *(_OWORD *)(v9 + 128) = 0u;
    *(_OWORD *)(v9 + 144) = 0u;
    *(_OWORD *)(v9 + 160) = 0u;
    *(_OWORD *)(v9 + 176) = 0u;
    *(_OWORD *)(v9 + 192) = 0u;
    *(_OWORD *)(v9 + 208) = 0u;
    *(_OWORD *)(v9 + 224) = 0u;
    *(_OWORD *)(v9 + 240) = 0u;
    *(_OWORD *)(v9 + 256) = 0u;
    *(_DWORD *)(v9 + 272) = 1135312896;
    v14[0] = &off_24D57D4D0;
    v15 = v14;
    *(_QWORD *)&v13[0] = v9;
    std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v13 + 8, (uint64_t)v14);
    v10 = v15;
    if (v15 == v14)
    {
      v10 = v14;
      v11 = 4;
    }
    else
    {
      if (!v15)
        goto LABEL_13;
      v11 = 5;
    }
    (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_13:
    std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(*v7 + v8), (uint64_t *)v13);
    result = std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v13);
    v8 += 40;
    --v4;
  }
  while (v4);
  return result;
}

void sub_2165CF728(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t *Phase::Geometry::CreateSimpleUniformMediumFromMedium@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  char *v5;
  _QWORD *v6;
  uint64_t *result;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD v29[3];
  _QWORD *v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)a1 != 1)
    std::terminate();
  v4 = operator new(0x58uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_24D57D498;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  v4[10] = 0;
  *((_DWORD *)v4 + 6) = 1;
  v5 = (char *)(v4 + 3);
  *((_OWORD *)v4 + 4) = 0u;
  v6 = v4 + 8;
  *a2 = v4 + 3;
  a2[1] = v4;
  result = std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v4 + 8, 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 48) - *(_QWORD *)(a1 + 40)) >> 3));
  v8 = *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)(a1 + 48) != v8)
  {
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *(_QWORD *)(v8 + v9);
      v12 = operator new();
      *(_QWORD *)v12 = Phase::GetTypeId<Phase::Geometry::SimpleUniformMedium>;
      *(_QWORD *)(v12 + 8) = v5;
      v13 = *(_OWORD *)(v11 + 16);
      v14 = *(_OWORD *)(v11 + 32);
      v15 = *(_OWORD *)(v11 + 64);
      *(_OWORD *)(v12 + 48) = *(_OWORD *)(v11 + 48);
      *(_OWORD *)(v12 + 64) = v15;
      *(_OWORD *)(v12 + 16) = v13;
      *(_OWORD *)(v12 + 32) = v14;
      v16 = *(_OWORD *)(v11 + 80);
      v17 = *(_OWORD *)(v11 + 96);
      v18 = *(_OWORD *)(v11 + 128);
      *(_OWORD *)(v12 + 112) = *(_OWORD *)(v11 + 112);
      *(_OWORD *)(v12 + 128) = v18;
      *(_OWORD *)(v12 + 80) = v16;
      *(_OWORD *)(v12 + 96) = v17;
      v19 = *(_OWORD *)(v11 + 256);
      v21 = *(_OWORD *)(v11 + 208);
      v20 = *(_OWORD *)(v11 + 224);
      *(_OWORD *)(v12 + 240) = *(_OWORD *)(v11 + 240);
      *(_OWORD *)(v12 + 256) = v19;
      *(_OWORD *)(v12 + 208) = v21;
      *(_OWORD *)(v12 + 224) = v20;
      v22 = *(_OWORD *)(v11 + 144);
      v23 = *(_OWORD *)(v11 + 160);
      v24 = *(_OWORD *)(v11 + 192);
      *(_OWORD *)(v12 + 176) = *(_OWORD *)(v11 + 176);
      *(_OWORD *)(v12 + 192) = v24;
      *(_OWORD *)(v12 + 144) = v22;
      *(_OWORD *)(v12 + 160) = v23;
      *(_DWORD *)(v12 + 272) = *(_DWORD *)(v11 + 272);
      v29[0] = &off_24D57D4D0;
      v30 = v29;
      v27 = v12;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v28, (uint64_t)v29);
      v25 = v30;
      if (v30 == v29)
        break;
      if (v30)
      {
        v26 = 5;
LABEL_8:
        (*(void (**)(void))(*v25 + 8 * v26))();
      }
      std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(*v6 + v9), &v27);
      result = std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v27);
      ++v10;
      v8 = *(_QWORD *)(a1 + 40);
      v9 += 40;
      if (0xCCCCCCCCCCCCCCCDLL * ((*(_QWORD *)(a1 + 48) - v8) >> 3) <= v10)
        return result;
    }
    v25 = v29;
    v26 = 4;
    goto LABEL_8;
  }
  return result;
}

void sub_2165CF948(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](a10);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<Phase::Geometry::Medium>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57D498;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Phase::Geometry::Medium>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57D498;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

void std::__shared_ptr_emplace<Phase::Geometry::Medium>::__on_zero_shared(uint64_t a1)
{
  void **v2;

  v2 = (void **)(a1 + 64);
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (void **)(a1 + 40);
  std::vector<std::shared_ptr<Phase::Controller::Renderer>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SimpleUniformMedium>(Phase::Geometry::SimpleUniformMedium *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SimpleUniformMedium>(Phase::Geometry::SimpleUniformMedium *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SimpleUniformMedium>(Phase::Geometry::SimpleUniformMedium *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SimpleUniformMedium>(Phase::Geometry::SimpleUniformMedium *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57D4D0;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SimpleUniformMedium>(Phase::Geometry::SimpleUniformMedium *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SimpleUniformMedium>(Phase::Geometry::SimpleUniformMedium *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57D4D0;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SimpleUniformMedium>(Phase::Geometry::SimpleUniformMedium *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SimpleUniformMedium>(Phase::Geometry::SimpleUniformMedium *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
    JUMPOUT(0x2199F9D70);
  return result;
}

uint64_t *Phase::Geometry::GenerateSourcePoints@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, float32x2_t *a3@<X2>, _OWORD *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  float *v8;
  int32x4_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  float32x2_t *v18;
  float32x2_t *v19;
  float32x2_t *v20;
  float32x2_t *v21;
  uint64_t v23;
  float32x2_t *v24;
  float32_t v25;
  float32x2_t *v26;
  _OWORD v27[2];
  uint64_t v28[4];
  float32x2_t v29[4];
  uint64_t v30;
  _QWORD v31[3];
  uint64_t v32;
  uint64_t v33;
  float32x2_t *v34;
  _BYTE v35[32];
  uint64_t v36;
  float32x2_t *v37;
  _QWORD v38[4];
  uint64_t v39;
  uint64_t v40;
  _QWORD v41[5];

  v41[4] = *MEMORY[0x24BDAC8D0];
  v8 = (float *)(a2 + 48);
  if (*(_DWORD *)a2 == 3
    && *(_QWORD *)(a2 + 128) != *(_QWORD *)(a2 + 120)
    && (Phase::Inverse<float>(a3 + 6, (uint64_t)v29),
        Phase::operator*<float>(v29, v8, (uint64_t)v28),
        v13 = **(_QWORD **)(a2 + 120),
        *(_DWORD *)(a1 + 112) > v13)
    && (v14 = *(_QWORD *)(a1 + 96), *(_DWORD *)(v14 + 24 * v13 + 20) == HIDWORD(v13))
    && (v15 = *(_QWORD *)(v14 + 24 * **(_QWORD **)(a2 + 120))) != 0
    && *(_DWORD *)v15 == 1)
  {
    v16 = **(_QWORD **)(v15 + 120);
    v17 = a4[1];
    v27[0] = *a4;
    v27[1] = v17;
    if (*(int *)a4 <= 0)
      LODWORD(v27[0]) = *(_DWORD *)(a2 + 152);
    Phase::Geometry::CreatePointCloudLoD((uint64_t *)a1, v16, (uint64_t)v28, (uint64_t)v27, a5, (uint64_t)&v37, v12);
    if (v39)
    {
      v18 = v37;
      v37 = 0;
      *(_QWORD *)a6 = v18;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100](a6 + 8, (uint64_t)v38);
      *(_QWORD *)(a6 + 40) = v39;
      *(_BYTE *)(a6 + 48) = 1;
    }
    else
    {
      v23 = *(_QWORD *)(a1 + 1024);
      v33 = 1;
      v32 = 4;
      v31[0] = v23;
      v31[1] = &v33;
      v31[2] = &v32;
      v30 = v23;
      Phase::details::AllocArray<Phase::Vector<float,3ul>,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Vector<float,3ul>*)#1} const&>((Phase::Logger *)1, (uint64_t)v31, &v30, (size_t *)&v40);
      v24 = (float32x2_t *)v40;
      v40 = 0;
      v34 = v24;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v35, (uint64_t)v41);
      v36 = 1;
      std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v40);
      v25 = (float)(*(float *)(v15 + 32) + *(float *)(v15 + 44)) * 0.5;
      v26 = v34;
      *v34 = vmul_f32(vadd_f32(*(float32x2_t *)(v15 + 24), *(float32x2_t *)(v15 + 36)), (float32x2_t)0x3F0000003F000000);
      v26[1].f32[0] = v25;
      v34 = 0;
      *(_QWORD *)a6 = v26;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100](a6 + 8, (uint64_t)v35);
      *(_QWORD *)(a6 + 40) = v36;
      *(_BYTE *)(a6 + 48) = 0;
      std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v34);
    }
  }
  else
  {
    v19 = *(float32x2_t **)(a1 + 1024);
    v40 = 1;
    v29[0] = (float32x2_t)4;
    v37 = v19;
    v38[0] = &v40;
    v38[1] = v29;
    v28[0] = (uint64_t)v19;
    Phase::details::AllocArray<Phase::Vector<float,3ul>,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::Vector<float,3ul>*)#1} const&>((Phase::Logger *)1, (uint64_t)&v37, v28, (size_t *)&v34);
    v20 = v34;
    v34 = 0;
    v37 = v20;
    std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v38, (uint64_t)v35);
    v39 = 1;
    std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v34);
    v21 = v37;
    *v37 = 0;
    v21[1].i32[0] = 0;
    v37 = 0;
    *(_QWORD *)a6 = v21;
    std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100](a6 + 8, (uint64_t)v38);
    *(_QWORD *)(a6 + 40) = v39;
    *(_BYTE *)(a6 + 48) = 0;
  }
  return std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v37);
}

void sub_2165CFD48(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)(v1 - 160));
  _Unwind_Resume(a1);
}

uint64_t (*Phase::GetTypeId<Phase::Geometry::SphericalCapDirectivity>())()
{
  return Phase::GetTypeId<Phase::Geometry::SphericalCapDirectivity>;
}

uint64_t *Phase::Geometry::CreateSphericalCapDirectivity@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  _QWORD v10[3];
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = operator new(0x58uLL);
  v2[1] = 0;
  v2[2] = 0;
  *v2 = &off_24D57CC88;
  *((_DWORD *)v2 + 6) = 3;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  v2[10] = 0;
  *a1 = v2 + 3;
  a1[1] = v2;
  v3 = (_QWORD *)operator new();
  *v3 = Phase::GetTypeId<Phase::Geometry::SphericalCapDirectivity>;
  v3[1] = v2 + 3;
  v3[5] = 0;
  v3[6] = 0;
  v3[4] = 0;
  v4 = v2 + 8;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v4, 1uLL);
  v10[0] = &off_24D57D518;
  v11 = v10;
  v8 = v3;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v9, (uint64_t)v10);
  v5 = v11;
  if (v11 == v10)
  {
    v6 = 4;
    v5 = v10;
    goto LABEL_5;
  }
  if (v11)
  {
    v6 = 5;
LABEL_5:
    (*(void (**)(_QWORD *))(*v5 + 8 * v6))(v5);
  }
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)*v4, (uint64_t *)&v8);
  return std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v8);
}

void sub_2165CFEAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t *Phase::Geometry::CreateSphericalCapDirectivityFromDirectivity@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  char *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[3];
  _QWORD *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)a1 != 3)
    __assert_rtn("CreateSphericalCapDirectivityFromDirectivity", "GeoSphericalCapDirectivity.cpp", 42, "inDirectivity.mType == DefaultDirectivityType::SphericalCap");
  v4 = operator new(0x58uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_24D57CC88;
  *((_DWORD *)v4 + 6) = 3;
  v5 = (char *)(v4 + 3);
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *((_OWORD *)v4 + 4) = 0u;
  v4[10] = 0;
  *a2 = v4 + 3;
  a2[1] = v4;
  v6 = **(_QWORD **)(a1 + 40);
  if (!v6)
    __assert_rtn("CreateSphericalCapDirectivityFromDirectivity", "GeoSphericalCapDirectivity.cpp", 47, "pSrcDirectivity");
  v7 = v4;
  v8 = operator new();
  *(_QWORD *)v8 = Phase::GetTypeId<Phase::Geometry::SphericalCapDirectivity>;
  *(_QWORD *)(v8 + 8) = v5;
  *(_OWORD *)(v8 + 16) = *(_OWORD *)(v6 + 16);
  *(_QWORD *)(v8 + 40) = 0;
  *(_QWORD *)(v8 + 48) = 0;
  *(_QWORD *)(v8 + 32) = 0;
  v9 = v7 + 8;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v9, 1uLL);
  v15[0] = &off_24D57D518;
  v16 = v15;
  v13 = v8;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v14, (uint64_t)v15);
  v10 = v16;
  if (v16 == v15)
  {
    v11 = 4;
    v10 = v15;
    goto LABEL_7;
  }
  if (v16)
  {
    v11 = 5;
LABEL_7:
    (*(void (**)(_QWORD *))(*v10 + 8 * v11))(v10);
  }
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)*v9, &v13);
  return std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v13);
}

void sub_2165D006C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SphericalCapDirectivity>(Phase::Geometry::SphericalCapDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SphericalCapDirectivity>(Phase::Geometry::SphericalCapDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SphericalCapDirectivity>(Phase::Geometry::SphericalCapDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SphericalCapDirectivity>(Phase::Geometry::SphericalCapDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57D518;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SphericalCapDirectivity>(Phase::Geometry::SphericalCapDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SphericalCapDirectivity>(Phase::Geometry::SphericalCapDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57D518;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SphericalCapDirectivity>(Phase::Geometry::SphericalCapDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::SphericalCapDirectivity>(Phase::Geometry::SphericalCapDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t ***a2)
{
  uint64_t **v2;

  v2 = *a2;
  if (*a2)
  {
    std::unique_ptr<Phase::Zeppelin::HorizontalSliceDatabase>::reset[abi:ne180100](v2 + 6, 0);
    std::unique_ptr<Phase::Zeppelin::HorizontalSliceDatabase>::reset[abi:ne180100](v2 + 5, 0);
    std::unique_ptr<Phase::Zeppelin::HorizontalSliceDatabase>::reset[abi:ne180100](v2 + 4, 0);
    JUMPOUT(0x2199F9D70);
  }
}

uint64_t (***Phase::Geometry::SystemSetup::InitDefaultDirectivities(uint64_t a1))()
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t (***v5)();
  uint64_t v6;
  uint64_t (***v7)();
  uint64_t v8;
  uint64_t (***v9)();
  uint64_t v10;
  uint64_t (***v11)();
  uint64_t v12;
  uint64_t (***v13)();
  uint64_t v14;
  uint64_t (***result)();
  uint64_t v16;
  uint64_t (**v17)();
  void *v18;
  uint64_t (***v19)();
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v2 = a1 + 216;
  v3 = a1 + 224;
  std::vector<Phase::Geometry::DirectivityTypeDefinition>::resize((uint64_t *)(a1 + 224), 4uLL);
  v4 = *(_QWORD **)(a1 + 224);
  *v4 = 0;
  v4[12] = 0x100000001;
  v17 = &off_24D57D590;
  v18 = Phase::Geometry::CreateCardioidDirectivity;
  v19 = &v17;
  Phase::Geometry::DirectivityTypeRegistry::CustomizeType(v2, 1u, (uint64_t)&v17);
  v5 = v19;
  if (v19 == &v17)
  {
    v6 = 4;
    v5 = &v17;
  }
  else
  {
    if (!v19)
      goto LABEL_6;
    v6 = 5;
  }
  (*v5)[v6]();
LABEL_6:
  v17 = &off_24D57D5D8;
  v18 = Phase::Geometry::CreateCardioidDirectivityFromDirectivity;
  v19 = &v17;
  Phase::Geometry::DirectivityTypeRegistry::CustomizeType(v2, 1u, (uint64_t)&v17);
  v7 = v19;
  if (v19 == &v17)
  {
    v8 = 4;
    v7 = &v17;
  }
  else
  {
    if (!v19)
      goto LABEL_11;
    v8 = 5;
  }
  (*v7)[v8]();
LABEL_11:
  *(_QWORD *)(*(_QWORD *)v3 + 192) = 0x200000002;
  v17 = &off_24D57D590;
  v18 = Phase::Geometry::CreateConeDirectivity;
  v19 = &v17;
  Phase::Geometry::DirectivityTypeRegistry::CustomizeType(v2, 2u, (uint64_t)&v17);
  v9 = v19;
  if (v19 == &v17)
  {
    v10 = 4;
    v9 = &v17;
  }
  else
  {
    if (!v19)
      goto LABEL_16;
    v10 = 5;
  }
  (*v9)[v10]();
LABEL_16:
  v17 = &off_24D57D5D8;
  v18 = Phase::Geometry::CreateConeDirectivityFromDirectivity;
  v19 = &v17;
  Phase::Geometry::DirectivityTypeRegistry::CustomizeType(v2, 2u, (uint64_t)&v17);
  v11 = v19;
  if (v19 == &v17)
  {
    v12 = 4;
    v11 = &v17;
  }
  else
  {
    if (!v19)
      goto LABEL_21;
    v12 = 5;
  }
  (*v11)[v12]();
LABEL_21:
  *(_QWORD *)(*(_QWORD *)v3 + 288) = 0x300000003;
  v17 = &off_24D57D590;
  v18 = Phase::Geometry::CreateSphericalCapDirectivity;
  v19 = &v17;
  Phase::Geometry::DirectivityTypeRegistry::CustomizeType(v2, 3u, (uint64_t)&v17);
  v13 = v19;
  if (v19 == &v17)
  {
    v14 = 4;
    v13 = &v17;
  }
  else
  {
    if (!v19)
      goto LABEL_26;
    v14 = 5;
  }
  (*v13)[v14]();
LABEL_26:
  v17 = &off_24D57D5D8;
  v18 = Phase::Geometry::CreateSphericalCapDirectivityFromDirectivity;
  v19 = &v17;
  Phase::Geometry::DirectivityTypeRegistry::CustomizeType(v2, 3u, (uint64_t)&v17);
  result = v19;
  if (v19 == &v17)
  {
    v16 = 4;
    result = &v17;
  }
  else
  {
    if (!v19)
      return result;
    v16 = 5;
  }
  return (uint64_t (***)())(*result)[v16]();
}

void sub_2165D03C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_2165D041C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v13;

  if (a13 != v13)
    JUMPOUT(0x2165D03DCLL);
  JUMPOUT(0x2165D0400);
}

uint64_t (***Phase::Geometry::SystemSetup::InitDefaultDistanceModels(uint64_t a1))()
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t (***v5)();
  uint64_t v6;
  uint64_t (***v7)();
  uint64_t v8;
  uint64_t (***v9)();
  uint64_t v10;
  uint64_t (***result)();
  uint64_t v12;
  uint64_t (**v13)();
  void *v14;
  uint64_t (***v15)();
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v2 = a1 + 464;
  v3 = a1 + 472;
  std::vector<Phase::Geometry::DistanceModelTypeDefinition>::resize((uint64_t *)(a1 + 472), 3uLL);
  v4 = *(_QWORD **)(a1 + 472);
  *v4 = 0;
  v4[12] = 0x100000001;
  v13 = &off_24D57D620;
  v14 = Phase::Geometry::CreateGeometricSpreadingDistanceModel;
  v15 = &v13;
  Phase::Geometry::DistanceModelTypeRegistry::CustomizeType(v2, 1u, (uint64_t)&v13);
  v5 = v15;
  if (v15 == &v13)
  {
    v6 = 4;
    v5 = &v13;
  }
  else
  {
    if (!v15)
      goto LABEL_6;
    v6 = 5;
  }
  (*v5)[v6]();
LABEL_6:
  v13 = &off_24D57D668;
  v14 = Phase::Geometry::CreateGeometricSpreadingDistanceModelFromDistanceModel;
  v15 = &v13;
  Phase::Geometry::DistanceModelTypeRegistry::CustomizeType(v2, 1u, (uint64_t)&v13);
  v7 = v15;
  if (v15 == &v13)
  {
    v8 = 4;
    v7 = &v13;
  }
  else
  {
    if (!v15)
      goto LABEL_11;
    v8 = 5;
  }
  (*v7)[v8]();
LABEL_11:
  *(_QWORD *)(*(_QWORD *)v3 + 192) = 0x200000002;
  v13 = &off_24D57D620;
  v14 = Phase::Geometry::CreateEnvelopeDistanceModel;
  v15 = &v13;
  Phase::Geometry::DistanceModelTypeRegistry::CustomizeType(v2, 2u, (uint64_t)&v13);
  v9 = v15;
  if (v15 == &v13)
  {
    v10 = 4;
    v9 = &v13;
  }
  else
  {
    if (!v15)
      goto LABEL_16;
    v10 = 5;
  }
  (*v9)[v10]();
LABEL_16:
  v13 = &off_24D57D668;
  v14 = Phase::Geometry::CreateEnvelopeDistanceModelFromDistanceModel;
  v15 = &v13;
  Phase::Geometry::DistanceModelTypeRegistry::CustomizeType(v2, 2u, (uint64_t)&v13);
  result = v15;
  if (v15 == &v13)
  {
    v12 = 4;
    result = &v13;
  }
  else
  {
    if (!v15)
      return result;
    v12 = 5;
  }
  return (uint64_t (***)())(*result)[v12]();
}

void sub_2165D0610(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t (***Phase::Geometry::SystemSetup::InitDefaultMediums(uint64_t a1))()
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t (***v4)();
  uint64_t v5;
  uint64_t (***result)();
  uint64_t v7;
  uint64_t (**v8)();
  void *v9;
  uint64_t (***v10)();
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v2 = a1 + 712;
  std::vector<Phase::Geometry::MediumTypeDefinition>::resize((uint64_t *)(a1 + 720), 2uLL);
  v3 = *(_QWORD **)(a1 + 720);
  *v3 = 0;
  v3[12] = 0x100000001;
  v8 = &off_24D57D6B0;
  v9 = Phase::Geometry::CreateSimpleUniformMedium;
  v10 = &v8;
  Phase::Geometry::MediumTypeRegistry::CustomizeType(v2, 1u, (uint64_t)&v8);
  v4 = v10;
  if (v10 == &v8)
  {
    v5 = 4;
    v4 = &v8;
  }
  else
  {
    if (!v10)
      goto LABEL_6;
    v5 = 5;
  }
  (*v4)[v5]();
LABEL_6:
  v8 = &off_24D57D6F8;
  v9 = Phase::Geometry::CreateSimpleUniformMediumFromMedium;
  v10 = &v8;
  Phase::Geometry::MediumTypeRegistry::CustomizeType(v2, 1u, (uint64_t)&v8);
  result = v10;
  if (v10 == &v8)
  {
    v7 = 4;
    result = &v8;
  }
  else
  {
    if (!v10)
      return result;
    v7 = 5;
  }
  return (uint64_t (***)())(*result)[v7]();
}

void sub_2165D0790(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t (***Phase::Geometry::SystemSetup::InitDefaultMaterials(uint64_t a1))()
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t (***v4)();
  uint64_t v5;
  uint64_t (***result)();
  uint64_t v7;
  uint64_t (**v8)();
  void *v9;
  uint64_t (***v10)();
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v2 = a1 + 960;
  std::vector<Phase::Geometry::MaterialTypeDefinition>::resize((uint64_t *)(a1 + 968), 2uLL);
  v3 = *(_QWORD **)(a1 + 968);
  *v3 = 0;
  v3[12] = 0x100000001;
  v8 = &off_24D57D740;
  v9 = Phase::Geometry::CreateSimpleUniformMaterial;
  v10 = &v8;
  Phase::Geometry::MaterialTypeRegistry::CustomizeType(v2, 1u, (uint64_t)&v8);
  v4 = v10;
  if (v10 == &v8)
  {
    v5 = 4;
    v4 = &v8;
  }
  else
  {
    if (!v10)
      goto LABEL_6;
    v5 = 5;
  }
  (*v4)[v5]();
LABEL_6:
  v8 = &off_24D57D788;
  v9 = Phase::Geometry::CreateSimpleUniformMaterialFromMaterial;
  v10 = &v8;
  Phase::Geometry::MaterialTypeRegistry::CustomizeType(v2, 1u, (uint64_t)&v8);
  result = v10;
  if (v10 == &v8)
  {
    v7 = 4;
    result = &v8;
  }
  else
  {
    if (!v10)
      return result;
    v7 = 5;
  }
  return (uint64_t (***)())(*result)[v7]();
}

void sub_2165D08EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t (***Phase::Geometry::SystemSetup::InitDefaultShapes(uint64_t a1))()
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t (***v5)();
  uint64_t v6;
  uint64_t (***v7)();
  uint64_t v8;
  uint64_t (***v9)();
  uint64_t v10;
  uint64_t (***v11)();
  uint64_t v12;
  uint64_t (***v13)();
  uint64_t v14;
  uint64_t (***v15)();
  uint64_t v16;
  uint64_t (***v17)();
  uint64_t v18;
  uint64_t (***v19)();
  uint64_t v20;
  uint64_t (***result)();
  uint64_t v22;
  uint64_t (**v23)();
  void *v24;
  uint64_t (***v25)();
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v2 = a1 + 1208;
  v3 = a1 + 1216;
  std::vector<Phase::Geometry::ShapeTypeDefinition>::resize((uint64_t *)(a1 + 1216), 4uLL);
  v4 = *(_QWORD **)(a1 + 1216);
  *v4 = 0;
  v4[12] = 0x100000001;
  v23 = &off_24D57D7D0;
  v24 = Phase::Geometry::CreateMesh;
  v25 = &v23;
  Phase::Geometry::ShapeTypeRegistry::CustomizeType(v2, 1u, (uint64_t)&v23);
  v5 = v25;
  if (v25 == &v23)
  {
    v6 = 4;
    v5 = &v23;
  }
  else
  {
    if (!v25)
      goto LABEL_6;
    v6 = 5;
  }
  (*v5)[v6]();
LABEL_6:
  v23 = &off_24D57D818;
  v24 = Phase::Geometry::CreateMeshFromShape;
  v25 = &v23;
  Phase::Geometry::ShapeTypeRegistry::CustomizeType(v2, 1u, (uint64_t)&v23);
  v7 = v25;
  if (v25 == &v23)
  {
    v8 = 4;
    v7 = &v23;
  }
  else
  {
    if (!v25)
      goto LABEL_11;
    v8 = 5;
  }
  (*v7)[v8]();
LABEL_11:
  v23 = &off_24D57D860;
  v24 = Phase::Geometry::CreateMeshFromMdlMesh;
  v25 = &v23;
  Phase::Geometry::ShapeTypeRegistry::CustomizeType(v2, 1u, 1, (uint64_t)&v23);
  v9 = v25;
  if (v25 == &v23)
  {
    v10 = 4;
    v9 = &v23;
  }
  else
  {
    if (!v25)
      goto LABEL_16;
    v10 = 5;
  }
  (*v9)[v10]();
LABEL_16:
  *(_QWORD *)(*(_QWORD *)v3 + 192) = 0x200000002;
  v23 = &off_24D57D7D0;
  v24 = Phase::Geometry::CreateVoxelTree;
  v25 = &v23;
  Phase::Geometry::ShapeTypeRegistry::CustomizeType(v2, 2u, (uint64_t)&v23);
  v11 = v25;
  if (v25 == &v23)
  {
    v12 = 4;
    v11 = &v23;
  }
  else
  {
    if (!v25)
      goto LABEL_21;
    v12 = 5;
  }
  (*v11)[v12]();
LABEL_21:
  v23 = &off_24D57D818;
  v24 = Phase::Geometry::CreateVoxelTreeFromShape;
  v25 = &v23;
  Phase::Geometry::ShapeTypeRegistry::CustomizeType(v2, 2u, (uint64_t)&v23);
  v13 = v25;
  if (v25 == &v23)
  {
    v14 = 4;
    v13 = &v23;
  }
  else
  {
    if (!v25)
      goto LABEL_26;
    v14 = 5;
  }
  (*v13)[v14]();
LABEL_26:
  v23 = &off_24D57D860;
  v24 = Phase::Geometry::CreateVoxelTreeFromMdlMesh;
  v25 = &v23;
  Phase::Geometry::ShapeTypeRegistry::CustomizeType(v2, 2u, 1, (uint64_t)&v23);
  v15 = v25;
  if (v25 == &v23)
  {
    v16 = 4;
    v15 = &v23;
  }
  else
  {
    if (!v25)
      goto LABEL_31;
    v16 = 5;
  }
  (*v15)[v16]();
LABEL_31:
  *(_QWORD *)(*(_QWORD *)v3 + 288) = 0x300000003;
  v23 = &off_24D57D7D0;
  v24 = Phase::Geometry::CreateMpsMesh;
  v25 = &v23;
  Phase::Geometry::ShapeTypeRegistry::CustomizeType(v2, 3u, (uint64_t)&v23);
  v17 = v25;
  if (v25 == &v23)
  {
    v18 = 4;
    v17 = &v23;
  }
  else
  {
    if (!v25)
      goto LABEL_36;
    v18 = 5;
  }
  (*v17)[v18]();
LABEL_36:
  v23 = &off_24D57D818;
  v24 = Phase::Geometry::CreateMpsMeshFromShape;
  v25 = &v23;
  Phase::Geometry::ShapeTypeRegistry::CustomizeType(v2, 3u, (uint64_t)&v23);
  v19 = v25;
  if (v25 == &v23)
  {
    v20 = 4;
    v19 = &v23;
  }
  else
  {
    if (!v25)
      goto LABEL_41;
    v20 = 5;
  }
  (*v19)[v20]();
LABEL_41:
  v23 = &off_24D57D860;
  v24 = Phase::Geometry::CreateMpsMeshFromMdlMesh;
  v25 = &v23;
  Phase::Geometry::ShapeTypeRegistry::CustomizeType(v2, 3u, 1, (uint64_t)&v23);
  result = v25;
  if (v25 == &v23)
  {
    v22 = 4;
    result = &v23;
  }
  else
  {
    if (!v25)
      return result;
    v22 = 5;
  }
  return (uint64_t (***)())(*result)[v22]();
}

void sub_2165D0CB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_2165D0D14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v13;

  if (a13 != v13)
    JUMPOUT(0x2165D0CD0);
  JUMPOUT(0x2165D0CF8);
}

void sub_2165D0D28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v13;

  if (a13 != v13)
    JUMPOUT(0x2165D0CD0);
  JUMPOUT(0x2165D0CF8);
}

uint64_t (***Phase::Geometry::SystemSetup::InitDefaultSceneQueries(_QWORD *a1))()
{
  unint64_t *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t (***v5)();
  uint64_t v6;
  uint64_t (***v7)();
  uint64_t v8;
  uint64_t (***v9)();
  uint64_t v10;
  uint64_t (***v11)();
  uint64_t v12;
  uint64_t (***v13)();
  uint64_t v14;
  uint64_t (***v15)();
  uint64_t v16;
  uint64_t (***v17)();
  uint64_t v18;
  uint64_t (***v19)();
  uint64_t v20;
  uint64_t (***v21)();
  uint64_t v22;
  uint64_t (***v23)();
  uint64_t v24;
  uint64_t (***v25)();
  uint64_t v26;
  uint64_t (***v27)();
  uint64_t v28;
  uint64_t (***v29)();
  uint64_t v30;
  uint64_t (***v31)();
  uint64_t v32;
  uint64_t (***v33)();
  uint64_t v34;
  uint64_t (***v35)();
  uint64_t v36;
  uint64_t (***v37)();
  uint64_t v38;
  uint64_t (***v39)();
  uint64_t v40;
  uint64_t (***v41)();
  uint64_t v42;
  uint64_t (***v43)();
  uint64_t v44;
  uint64_t (***v45)();
  uint64_t v46;
  uint64_t (***result)();
  uint64_t v48;
  uint64_t (**v49)();
  void (*v50)(uint64_t, uint64_t, uint64_t);
  uint64_t (***v51)();
  uint64_t (**v52)();
  void *v53;
  uint64_t (***v54)();
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v2 = a1 + 286;
  v3 = a1 + 287;
  std::vector<Phase::Geometry::SceneQueryTypeDefinition>::resize(a1 + 287, 5uLL);
  Phase::Geometry::SceneQueryTypeRegistry::SetTestShapeTableEntryCount(v2, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[153] - a1[152]) >> 5));
  v4 = (_QWORD *)a1[287];
  *v4 = 0;
  v4[19] = 0x100000001;
  v52 = &off_24D57D8A8;
  v53 = Phase::Geometry::IterateSceneQueryBatch;
  v54 = &v52;
  v49 = &off_24D57D8A8;
  v50 = Phase::Geometry::IterateSceneQueryBatchAsync;
  v51 = &v49;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType((uint64_t)v2, 1u, (uint64_t)&v52, (uint64_t)&v49);
  v5 = v51;
  if (v51 == &v49)
  {
    v6 = 4;
    v5 = &v49;
  }
  else
  {
    if (!v51)
      goto LABEL_6;
    v6 = 5;
  }
  (*v5)[v6]();
LABEL_6:
  v7 = v54;
  if (v54 == &v52)
  {
    v8 = 4;
    v7 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_11;
    v8 = 5;
  }
  (*v7)[v8]();
LABEL_11:
  v52 = &off_24D57D8F0;
  v53 = Phase::Geometry::SingleHitRaycastVsScene;
  v54 = &v52;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType((uint64_t)v2, 1u, (uint64_t)&v52);
  v9 = v54;
  if (v54 == &v52)
  {
    v10 = 4;
    v9 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_16;
    v10 = 5;
  }
  (*v9)[v10]();
LABEL_16:
  v52 = &off_24D57D938;
  v53 = Phase::Geometry::SingleHitRaycastVsMesh;
  v54 = &v52;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType(v2, 1u, 1u, (uint64_t)&v52);
  v11 = v54;
  if (v54 == &v52)
  {
    v12 = 4;
    v11 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_21;
    v12 = 5;
  }
  (*v11)[v12]();
LABEL_21:
  v52 = &off_24D57D938;
  v53 = Phase::Geometry::SingleHitRaycastVsVoxelTree;
  v54 = &v52;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType(v2, 1u, 2u, (uint64_t)&v52);
  v13 = v54;
  if (v54 == &v52)
  {
    v14 = 4;
    v13 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_26;
    v14 = 5;
  }
  (*v13)[v14]();
LABEL_26:
  v52 = &off_24D57D980;
  v53 = Phase::Geometry::RunSingleHitVsMpsScene;
  v54 = &v52;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType(v2, 1u, 3u, (uint64_t)&v52);
  v15 = v54;
  if (v54 == &v52)
  {
    v16 = 4;
    v15 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_31;
    v16 = 5;
  }
  (*v15)[v16]();
LABEL_31:
  *(_QWORD *)(*v3 + 304) = 0x200000002;
  v52 = &off_24D57D8A8;
  v53 = Phase::Geometry::IterateSceneQueryBatch;
  v54 = &v52;
  v49 = &off_24D57D8A8;
  v50 = Phase::Geometry::IterateSceneQueryBatchAsync;
  v51 = &v49;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType((uint64_t)v2, 2u, (uint64_t)&v52, (uint64_t)&v49);
  v17 = v51;
  if (v51 == &v49)
  {
    v18 = 4;
    v17 = &v49;
  }
  else
  {
    if (!v51)
      goto LABEL_36;
    v18 = 5;
  }
  (*v17)[v18]();
LABEL_36:
  v19 = v54;
  if (v54 == &v52)
  {
    v20 = 4;
    v19 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_41;
    v20 = 5;
  }
  (*v19)[v20]();
LABEL_41:
  v52 = &off_24D57D8F0;
  v53 = Phase::Geometry::MultiHitRaycastVsScene;
  v54 = &v52;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType((uint64_t)v2, 2u, (uint64_t)&v52);
  v21 = v54;
  if (v54 == &v52)
  {
    v22 = 4;
    v21 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_46;
    v22 = 5;
  }
  (*v21)[v22]();
LABEL_46:
  v52 = &off_24D57D938;
  v53 = Phase::Geometry::MultiHitRaycastVsMesh;
  v54 = &v52;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType(v2, 2u, 1u, (uint64_t)&v52);
  v23 = v54;
  if (v54 == &v52)
  {
    v24 = 4;
    v23 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_51;
    v24 = 5;
  }
  (*v23)[v24]();
LABEL_51:
  v52 = &off_24D57D938;
  v53 = Phase::Geometry::MultiHitRaycastVsVoxelTree;
  v54 = &v52;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType(v2, 2u, 2u, (uint64_t)&v52);
  v25 = v54;
  if (v54 == &v52)
  {
    v26 = 4;
    v25 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_56;
    v26 = 5;
  }
  (*v25)[v26]();
LABEL_56:
  *(_QWORD *)(*v3 + 456) = 0x300000003;
  v52 = &off_24D57D8A8;
  v53 = Phase::Geometry::IterateSceneQueryBatch;
  v54 = &v52;
  v49 = &off_24D57D8A8;
  v50 = Phase::Geometry::IterateSceneQueryBatchAsync;
  v51 = &v49;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType((uint64_t)v2, 3u, (uint64_t)&v52, (uint64_t)&v49);
  v27 = v51;
  if (v51 == &v49)
  {
    v28 = 4;
    v27 = &v49;
  }
  else
  {
    if (!v51)
      goto LABEL_61;
    v28 = 5;
  }
  (*v27)[v28]();
LABEL_61:
  v29 = v54;
  if (v54 == &v52)
  {
    v30 = 4;
    v29 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_66;
    v30 = 5;
  }
  (*v29)[v30]();
LABEL_66:
  v52 = &off_24D57D8F0;
  v53 = Phase::Geometry::SingleHitRaycastVsSceneV2;
  v54 = &v52;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType((uint64_t)v2, 3u, (uint64_t)&v52);
  v31 = v54;
  if (v54 == &v52)
  {
    v32 = 4;
    v31 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_71;
    v32 = 5;
  }
  (*v31)[v32]();
LABEL_71:
  v52 = &off_24D57D938;
  v53 = Phase::Geometry::SingleHitRaycastVsMeshV2;
  v54 = &v52;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType(v2, 3u, 1u, (uint64_t)&v52);
  v33 = v54;
  if (v54 == &v52)
  {
    v34 = 4;
    v33 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_76;
    v34 = 5;
  }
  (*v33)[v34]();
LABEL_76:
  v52 = &off_24D57D938;
  v53 = Phase::Geometry::SingleHitRaycastVsVoxelTreeV2;
  v54 = &v52;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType(v2, 3u, 2u, (uint64_t)&v52);
  v35 = v54;
  if (v54 == &v52)
  {
    v36 = 4;
    v35 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_81;
    v36 = 5;
  }
  (*v35)[v36]();
LABEL_81:
  v52 = &off_24D57D980;
  v53 = Phase::Geometry::RunSingleHitVsMpsSceneV2;
  v54 = &v52;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType(v2, 3u, 3u, (uint64_t)&v52);
  v37 = v54;
  if (v54 == &v52)
  {
    v38 = 4;
    v37 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_86;
    v38 = 5;
  }
  (*v37)[v38]();
LABEL_86:
  *(_QWORD *)(*v3 + 608) = 0x400000004;
  v52 = &off_24D57D8A8;
  v53 = Phase::Geometry::IterateSceneQueryBatch;
  v54 = &v52;
  v49 = &off_24D57D8A8;
  v50 = Phase::Geometry::IterateSceneQueryBatchAsync;
  v51 = &v49;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType((uint64_t)v2, 4u, (uint64_t)&v52, (uint64_t)&v49);
  v39 = v51;
  if (v51 == &v49)
  {
    v40 = 4;
    v39 = &v49;
  }
  else
  {
    if (!v51)
      goto LABEL_91;
    v40 = 5;
  }
  (*v39)[v40]();
LABEL_91:
  v41 = v54;
  if (v54 == &v52)
  {
    v42 = 4;
    v41 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_96;
    v42 = 5;
  }
  (*v41)[v42]();
LABEL_96:
  v52 = &off_24D57D8F0;
  v53 = Phase::Geometry::MultiHitRaycastVsSceneV2;
  v54 = &v52;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType((uint64_t)v2, 4u, (uint64_t)&v52);
  v43 = v54;
  if (v54 == &v52)
  {
    v44 = 4;
    v43 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_101;
    v44 = 5;
  }
  (*v43)[v44]();
LABEL_101:
  v52 = &off_24D57D938;
  v53 = Phase::Geometry::MultiHitRaycastVsMeshV2;
  v54 = &v52;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType(v2, 4u, 1u, (uint64_t)&v52);
  v45 = v54;
  if (v54 == &v52)
  {
    v46 = 4;
    v45 = &v52;
  }
  else
  {
    if (!v54)
      goto LABEL_106;
    v46 = 5;
  }
  (*v45)[v46]();
LABEL_106:
  v52 = &off_24D57D938;
  v53 = Phase::Geometry::MultiHitRaycastVsVoxelTreeV2;
  v54 = &v52;
  Phase::Geometry::SceneQueryTypeRegistry::CustomizeType(v2, 4u, 2u, (uint64_t)&v52);
  result = v54;
  if (v54 == &v52)
  {
    v48 = 4;
    result = &v52;
  }
  else
  {
    if (!v54)
      return result;
    v48 = 5;
  }
  return (uint64_t (***)())(*result)[v48]();
}

void sub_2165D14F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  char *v17;
  char *v19;
  uint64_t v20;

  v19 = a17;
  if (a17 == v17)
  {
    v20 = 4;
    v19 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_6;
    v20 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v19 + 8 * v20))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void Phase::Geometry::SystemSetup::InitScene(Phase::Geometry::SystemSetup *this, Phase::Geometry::System *a2)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;

  Phase::Geometry::CreateEntity<Phase::Geometry::Entity>(0, &v6);
  *((_QWORD *)this + 182) = Phase::Geometry::SystemScheduler::AddToDatabase((uint64_t)this + 2352, &v6);
  v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_2165D1674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *Phase::Geometry::CreateSystem(Phase::JobManager *a1)
{
  _QWORD *v2;
  Phase::Geometry::System *v3;

  v2 = (_QWORD *)operator new();
  Phase::Geometry::System::System((Phase::Geometry::System *)v2, a1);
  Phase::Geometry::SystemScheduler::Init((Phase::Geometry::SystemScheduler *)(v2 + 294), (Phase::Geometry::System *)v2);
  v2[25] = v2 + 26;
  v2[56] = v2 + 57;
  v2[88] = v2 + 62;
  v2[118] = v2 + 119;
  v2[149] = v2 + 150;
  v2[180] = v2 + 181;
  Phase::Geometry::SystemSetup::InitDefaultDirectivities((uint64_t)v2);
  Phase::Geometry::SystemSetup::InitDefaultDistanceModels((uint64_t)v2);
  Phase::Geometry::SystemSetup::InitDefaultMediums((uint64_t)v2);
  Phase::Geometry::SystemSetup::InitDefaultMaterials((uint64_t)v2);
  Phase::Geometry::SystemSetup::InitDefaultShapes((uint64_t)v2);
  Phase::Geometry::SystemSetup::InitDefaultSceneQueries(v2);
  Phase::Geometry::SystemSetup::InitScene((Phase::Geometry::SystemSetup *)v2, v3);
  Phase::Geometry::SystemScheduler::Update((Phase::Geometry::SystemScheduler *)(v2 + 294), 0.016667);
  return v2;
}

void sub_2165D1754(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199F9D70](v1, 0x10E0C402C518574);
  _Unwind_Resume(a1);
}

uint64_t *Phase::Geometry::System::ProcessReleaseRequestsUpTo(uint64_t *this, unint64_t a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v3 = this;
  v4 = (uint64_t *)this[343];
  if (v4)
  {
    v5 = this + 343;
    do
    {
      if (v4[1] >= a2)
      {
        v5 = v4 + 2;
      }
      else
      {
        Phase::details::SharedSlotMap<Phase::Geometry::Material,Phase::Handle64>::Release((uint64_t)(v3 + 93), *v4);
        v13 = v4[2];
        v6 = v13;
        v4[2] = 0;
        v7 = *v5;
        *v5 = v6;
        v13 = v7;
        std::unique_ptr<Phase::Geometry::System::ReleaseRequest>::reset[abi:ne180100](&v13, 0);
        this = std::unique_ptr<Phase::Geometry::System::ReleaseRequest>::reset[abi:ne180100](&v13, 0);
      }
      v4 = (uint64_t *)*v5;
    }
    while (*v5);
  }
  v8 = (uint64_t *)v3[344];
  if (v8)
  {
    v9 = v3 + 344;
    v10 = (uint64_t)(v3 + 124);
    do
    {
      if (v8[1] >= a2)
      {
        v9 = v8 + 2;
      }
      else
      {
        Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::UnblockSlot(v10, *v8);
        v13 = v8[2];
        v11 = v13;
        v8[2] = 0;
        v12 = *v9;
        *v9 = v11;
        v13 = v12;
        std::unique_ptr<Phase::Geometry::System::ReleaseRequest>::reset[abi:ne180100](&v13, 0);
        this = std::unique_ptr<Phase::Geometry::System::ReleaseRequest>::reset[abi:ne180100](&v13, 0);
      }
      v8 = (uint64_t *)*v9;
    }
    while (*v9);
  }
  return this;
}

void Phase::Geometry::System::BuildCurrentState(Phase::Geometry::System *this)
{
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  __int128 v5;

  *((_QWORD *)this + 342) = pthread_self();
  ++*((_QWORD *)this + 303);
  Phase::Geometry::SceneState::Update((Phase::Geometry::System *)((char *)this + 2432));
  Phase::Geometry::System::ProcessReleaseRequestsUpTo((uint64_t *)this, *((_QWORD *)this + 327));
  _ZNSt3__115allocate_sharedB8ne180100IN5Phase8Geometry11SystemStateENS_9allocatorIS3_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v5);
  Phase::Geometry::SystemState::Init(v5, (uint64_t)this);
  Phase::DataMessengerSPSC<std::shared_ptr<Phase::Geometry::SystemState>>::SendNewDataToObservers((_QWORD *)this + 291, (uint64_t *)&v5);
  std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100]((uint64_t)this + 2720, &v5);
  v2 = (std::__shared_weak_count *)*((_QWORD *)&v5 + 1);
  if (*((_QWORD *)&v5 + 1))
  {
    v3 = (unint64_t *)(*((_QWORD *)&v5 + 1) + 8);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
}

void sub_2165D1938(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void Phase::DataMessengerSPSC<std::shared_ptr<Phase::Geometry::SystemState>>::SendNewDataToObservers(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;

  v2 = a1[1] - *a1;
  if (v2)
  {
    v5 = 0;
    v6 = v2 >> 4;
    while (1)
    {
      v7 = *a1 + 16 * v5;
      v8 = *(std::__shared_weak_count **)(v7 + 8);
      if (!v8)
        break;
      v9 = std::__shared_weak_count::lock(v8);
      if (!v9)
        goto LABEL_13;
      v10 = *(unint64_t **)v7;
      if (!v10)
        goto LABEL_13;
      v11 = (_QWORD *)v10[1];
      if (!v11)
        __assert_rtn("SendNewData", "DataObserverSPSC.hpp", 79, "nullptr != pNewMessage");
      v10[1] = v11[2];
      v11[2] = 0;
      std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100](v11, a2);
      do
        v12 = __ldaxr(v10);
      while (__stlxr((unint64_t)v11, v10));
      if (v12)
        Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>::ReleaseMessage((uint64_t)v10, v12);
      ++v5;
LABEL_19:
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v20 = __ldaxr(p_shared_owners);
      while (__stlxr(v20 - 1, p_shared_owners));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
LABEL_23:
      if (v5 >= v6)
        return;
    }
    v9 = 0;
LABEL_13:
    if (v5 + 1 < v6)
    {
      v13 = a1[1];
      v14 = *a1 + 16 * v5;
      v15 = *(_OWORD *)(v13 - 16);
      *(_QWORD *)(v13 - 16) = 0;
      *(_QWORD *)(v13 - 8) = 0;
      v16 = *(std::__shared_weak_count **)(v14 + 8);
      *(_OWORD *)v14 = v15;
      if (v16)
        std::__shared_weak_count::__release_weak(v16);
    }
    v17 = a1[1];
    v18 = *(std::__shared_weak_count **)(v17 - 8);
    if (v18)
      std::__shared_weak_count::__release_weak(v18);
    a1[1] = v17 - 16;
    --v6;
    if (!v9)
      goto LABEL_23;
    goto LABEL_19;
  }
}

void sub_2165D1ABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

Phase::Logger *Phase::Geometry::System::GetCurrentState@<X0>(Phase::Geometry::System *this@<X0>, _QWORD *a2@<X8>)
{
  Phase::Logger *result;
  Phase::Logger *v5;
  BOOL v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  NSObject *v10;
  std::runtime_error *exception;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  result = (Phase::Logger *)pthread_self();
  v5 = (Phase::Logger *)*((_QWORD *)this + 342);
  if (result)
  {
    if (v5)
      v6 = result == v5;
    else
      v6 = 0;
    if (!v6)
    {
LABEL_12:
      v10 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(result) + 416));
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        v12 = 136315394;
        v13 = "GeoSystem.mm";
        v14 = 1024;
        v15 = 374;
        _os_log_impl(&dword_2164CC000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error): \"Calling Geometry::System::GetCurrentState() outside the main update thread is unsafe.\"", (uint8_t *)&v12, 0x12u);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Calling Geometry::System::GetCurrentState() outside the main update thread is unsafe.");
    }
  }
  else if (v5)
  {
    goto LABEL_12;
  }
  v7 = *((_QWORD *)this + 341);
  *a2 = *((_QWORD *)this + 340);
  a2[1] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  return result;
}

void sub_2165D1C08(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

_QWORD *Phase::Geometry::System::ObserveSystemState@<X0>(Phase::Geometry::System *this@<X0>, __int128 *a2@<X8>)
{
  _ZNSt3__115allocate_sharedB8ne180100IN5Phase16DataObserverSPSCINS_10shared_ptrINS1_8Geometry11SystemStateEEEEENS_9allocatorIS7_EEJEvEENS3_IT_EERKT0_DpOT1_(a2);
  return std::vector<std::weak_ptr<Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>>>::emplace_back<std::shared_ptr<Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>> const&>((unint64_t *)this + 291, a2);
}

void sub_2165D1C74(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t *Phase::Geometry::System::AddNewReleaseRequest(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t v8;

  v5 = *(_QWORD *)(a1 + 2424);
  v6 = (_QWORD *)operator new();
  *v6 = a3;
  v6[1] = v5;
  v6[2] = *a2;
  *a2 = v6;
  v8 = 0;
  return std::unique_ptr<Phase::Geometry::System::ReleaseRequest>::reset[abi:ne180100](&v8, 0);
}

void Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::ReleaseAndBlockSlot(uint64_t a1, uint64_t a2)
{
  uint64_t UniqueSlot;

  UniqueSlot = Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::GetUniqueSlot(a1, a2);
  if (UniqueSlot)
  {
    ++*(_DWORD *)(UniqueSlot + 20);
    std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)UniqueSlot);
  }
}

Phase::Geometry::System *Phase::Geometry::System::System(Phase::Geometry::System *this, Phase::JobManager *a2)
{
  Phase::SpatialModeler::TRAP *v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t InstancePtr;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *(_QWORD *)((char *)this + 20) = 0xFFFFFFFFLL;
  std::__shared_mutex_base::__shared_mutex_base((std::__shared_mutex_base *)((char *)this + 32));
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = this;
  *((_QWORD *)this + 27) = this;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *(_OWORD *)((char *)this + 252) = 0u;
  *(_QWORD *)((char *)this + 268) = 0xFFFFFFFFLL;
  std::__shared_mutex_base::__shared_mutex_base((std::__shared_mutex_base *)((char *)this + 280));
  *((_QWORD *)this + 56) = 0;
  *((_QWORD *)this + 57) = this;
  *((_QWORD *)this + 58) = this;
  *((_QWORD *)this + 59) = 0;
  *((_QWORD *)this + 60) = 0;
  *((_QWORD *)this + 61) = 0;
  *((_QWORD *)this + 63) = 0;
  *((_QWORD *)this + 64) = 0;
  *((_QWORD *)this + 62) = this;
  *((_DWORD *)this + 130) = 0;
  *(_QWORD *)((char *)this + 524) = 0xFFFFFFFFLL;
  std::__shared_mutex_base::__shared_mutex_base((std::__shared_mutex_base *)((char *)this + 536));
  *((_QWORD *)this + 88) = 0;
  *((_QWORD *)this + 89) = this;
  *((_OWORD *)this + 45) = 0u;
  *((_OWORD *)this + 46) = 0u;
  *(_OWORD *)((char *)this + 748) = 0u;
  *(_QWORD *)((char *)this + 764) = 0xFFFFFFFFLL;
  std::__shared_mutex_base::__shared_mutex_base((std::__shared_mutex_base *)((char *)this + 776));
  *((_QWORD *)this + 118) = 0;
  *((_QWORD *)this + 119) = this;
  *(_OWORD *)((char *)this + 984) = 0u;
  *(_OWORD *)((char *)this + 996) = 0u;
  *((_QWORD *)this + 120) = this;
  *(_OWORD *)((char *)this + 968) = 0u;
  *(_QWORD *)((char *)this + 1012) = 0xFFFFFFFFLL;
  std::__shared_mutex_base::__shared_mutex_base((std::__shared_mutex_base *)((char *)this + 1024));
  *((_QWORD *)this + 149) = 0;
  *((_QWORD *)this + 150) = this;
  *((_QWORD *)this + 151) = this;
  *((_OWORD *)this + 76) = 0u;
  *((_OWORD *)this + 77) = 0u;
  *(_OWORD *)((char *)this + 1244) = 0u;
  *(_QWORD *)((char *)this + 1260) = 0xFFFFFFFFLL;
  std::__shared_mutex_base::__shared_mutex_base((std::__shared_mutex_base *)((char *)this + 1272));
  *((_QWORD *)this + 180) = 0;
  *((_QWORD *)this + 181) = this;
  *((_QWORD *)this + 274) = 0;
  bzero((char *)this + 1456, 0x2DCuLL);
  v5 = Phase::SpatialModeler::TRAP::TP(v4);
  *((_DWORD *)this + 550) = *((_DWORD *)v5 + 101);
  v6 = Phase::SpatialModeler::TRAP::TP((Phase::SpatialModeler::TRAP *)v5);
  *((_BYTE *)this + 2204) = v6[508];
  v7 = Phase::SpatialModeler::TRAP::TP((Phase::SpatialModeler::TRAP *)v6);
  *((_DWORD *)this + 552) = *((_DWORD *)v7 + 102);
  *(_OWORD *)((char *)this + 2216) = 0u;
  *((_DWORD *)this + 558) = 0;
  *(_QWORD *)((char *)this + 2236) = 1065353216;
  *((_BYTE *)this + 2244) = 0;
  *((_QWORD *)this + 281) = 0;
  *((_QWORD *)this + 282) = -1;
  *((_QWORD *)this + 283) = -1;
  *((_QWORD *)this + 284) = -1;
  *((_QWORD *)this + 285) = this;
  *((_QWORD *)this + 286) = this;
  *((_QWORD *)this + 287) = 0;
  *((_QWORD *)this + 289) = 0;
  *((_QWORD *)this + 288) = 0;
  *((_QWORD *)this + 291) = 0;
  *((_QWORD *)this + 293) = 0;
  *((_QWORD *)this + 292) = 0;
  InstancePtr = Phase::Logger::GetInstancePtr((Phase::Logger *)v7);
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::Commandable((uint64_t)this + 2352, *(_QWORD *)(InstancePtr + 416), 1, 0x20000);
  *((_QWORD *)this + 294) = off_24D57D560;
  *((_QWORD *)this + 300) = 0;
  *((_QWORD *)this + 299) = 0;
  *((_QWORD *)this + 302) = a2;
  *((_QWORD *)this + 303) = 0;
  *((_QWORD *)this + 304) = this;
  *((_QWORD *)this + 305) = 0;
  *((_QWORD *)this + 307) = 0;
  *((_QWORD *)this + 306) = 0;
  *((_QWORD *)this + 308) = this;
  *((_QWORD *)this + 322) = 0;
  *((_QWORD *)this + 321) = 0;
  *((_DWORD *)this + 646) = 0;
  *((_QWORD *)this + 325) = 0;
  *((_QWORD *)this + 324) = 0;
  *((_DWORD *)this + 652) = 0;
  *((_BYTE *)this + 2624) = 0;
  *((_QWORD *)this + 319) = 0;
  *(_OWORD *)((char *)this + 2472) = 0u;
  *(_OWORD *)((char *)this + 2488) = 0u;
  *(_OWORD *)((char *)this + 2504) = 0u;
  *(_OWORD *)((char *)this + 2520) = 0u;
  *(_OWORD *)((char *)this + 2536) = 0u;
  *((_QWORD *)this + 330) = 0;
  *((_QWORD *)this + 329) = 0;
  *((_DWORD *)this + 662) = 0;
  *((_DWORD *)this + 668) = 0;
  *((_QWORD *)this + 332) = 0;
  *((_QWORD *)this + 333) = 0;
  *(_OWORD *)((char *)this + 2680) = 0u;
  *((_QWORD *)this + 345) = 0;
  *(_OWORD *)((char *)this + 2696) = 0u;
  *(_OWORD *)((char *)this + 2712) = 0u;
  *(_OWORD *)((char *)this + 2728) = 0u;
  *(_OWORD *)((char *)this + 2744) = 0u;
  return this;
}

void sub_2165D1FC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::condition_variable *a9, void **a10)
{
  uint64_t v10;
  std::condition_variable *v11;
  std::condition_variable *v12;
  std::condition_variable *v13;
  uint64_t v14;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v14);
  a10 = (void **)(v10 + 1216);
  std::vector<Phase::Geometry::ShapeTypeDefinition>::__destroy_vector::operator()[abi:ne180100](&a10);
  Phase::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64,Phase::Geometry::ShapeFactory>::~SharedSlotMap(v13);
  std::vector<Phase::Geometry::ShapeTypeDefinition>::__destroy_vector::operator()[abi:ne180100](&a10);
  Phase::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64,Phase::Geometry::ShapeFactory>::~SharedSlotMap(v12);
  a10 = (void **)(v10 + 720);
  std::vector<Phase::Geometry::ShapeTypeDefinition>::__destroy_vector::operator()[abi:ne180100](&a10);
  Phase::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64,Phase::Geometry::ShapeFactory>::~SharedSlotMap(v11);
  a10 = (void **)(v10 + 472);
  std::vector<Phase::Geometry::ShapeTypeDefinition>::__destroy_vector::operator()[abi:ne180100](&a10);
  Phase::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64,Phase::Geometry::ShapeFactory>::~SharedSlotMap(a9);
  std::vector<Phase::Geometry::ShapeTypeDefinition>::__destroy_vector::operator()[abi:ne180100](&a10);
  Phase::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64,Phase::Geometry::ShapeFactory>::~SharedSlotMap((std::condition_variable *)v10);
  _Unwind_Resume(a1);
}

uint64_t *Phase::DataMessengerSPSC<std::shared_ptr<Phase::Geometry::SystemState>>::~DataMessengerSPSC(uint64_t *a1)
{
  void **v3;

  std::vector<std::weak_ptr<Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>>>::__clear[abi:ne180100](a1);
  v3 = (void **)a1;
  std::vector<std::weak_ptr<Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>>>::__destroy_vector::operator()[abi:ne180100](&v3);
  return a1;
}

void Phase::Geometry::SystemExecutor::~SystemExecutor(Phase::Geometry::SystemExecutor *this)
{
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::~Commandable(this);
  JUMPOUT(0x2199F9D70);
}

void std::vector<std::weak_ptr<Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  std::__shared_weak_count *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 16)
  {
    v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4)
      std::__shared_weak_count::__release_weak(v4);
  }
  a1[1] = v2;
}

void std::vector<std::weak_ptr<Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::weak_ptr<Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>>>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<Phase::Geometry::SceneQueryTypeDefinition>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 152;
        std::allocator<Phase::Geometry::SceneQueryTypeDefinition>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<Phase::Geometry::ShapeTypeDefinition>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 96;
        std::allocator<Phase::Geometry::DirectivityTypeDefinition>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void Phase::Geometry::System::~System(Phase::Geometry::System *this)
{
  uint64_t v2;
  void **v3;

  v2 = *((_QWORD *)this + 345);
  *((_QWORD *)this + 345) = 0;
  if (v2)
    std::default_delete<Phase::Geometry::SystemDebugger>::operator()[abi:ne180100]((uint64_t)this + 2760, v2);
  std::unique_ptr<Phase::Geometry::System::ReleaseRequest>::reset[abi:ne180100]((uint64_t *)this + 344, 0);
  std::unique_ptr<Phase::Geometry::System::ReleaseRequest>::reset[abi:ne180100]((uint64_t *)this + 343, 0);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)this + 2720);
  v3 = (void **)((char *)this + 2696);
  std::vector<Phase::Geometry::MpsCpuSceneDescriptor>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)this + 2656);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)this + 2632);
  Phase::Geometry::MpsCpuSceneBuilder::~MpsCpuSceneBuilder((Phase::Geometry::System *)((char *)this + 2464));
  v3 = (void **)((char *)this + 2440);
  std::vector<std::shared_ptr<Phase::Controller::Renderer>>::__destroy_vector::operator()[abi:ne180100](&v3);
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::~Commandable((_QWORD *)this + 294);
  std::vector<std::weak_ptr<Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>>>::__clear[abi:ne180100]((uint64_t *)this + 291);
  v3 = (void **)((char *)this + 2328);
  std::vector<std::weak_ptr<Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 2296);
  std::vector<Phase::Geometry::SceneQueryTypeDefinition>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 1384));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 1336));
  std::mutex::~mutex((std::mutex *)((char *)this + 1272));
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)this + 1240);
  v3 = (void **)((char *)this + 1216);
  std::vector<Phase::Geometry::ShapeTypeDefinition>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 1136));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 1088));
  std::mutex::~mutex((std::mutex *)this + 16);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)this + 992);
  v3 = (void **)((char *)this + 968);
  std::vector<Phase::Geometry::ShapeTypeDefinition>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 888));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 840));
  std::mutex::~mutex((std::mutex *)((char *)this + 776));
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)this + 744);
  v3 = (void **)((char *)this + 720);
  std::vector<Phase::Geometry::ShapeTypeDefinition>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 648));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 600));
  std::mutex::~mutex((std::mutex *)((char *)this + 536));
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)this + 504);
  v3 = (void **)((char *)this + 472);
  std::vector<Phase::Geometry::ShapeTypeDefinition>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 392));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 344));
  std::mutex::~mutex((std::mutex *)((char *)this + 280));
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)this + 248);
  v3 = (void **)((char *)this + 224);
  std::vector<Phase::Geometry::ShapeTypeDefinition>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::condition_variable::~condition_variable((std::condition_variable *)this + 3);
  std::condition_variable::~condition_variable((std::condition_variable *)this + 2);
  std::mutex::~mutex((std::mutex *)((char *)this + 32));
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)this);
}

void std::default_delete<Phase::Geometry::SystemDebugger>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<Phase::Handle64,Phase::SpatialModeler::RoomSimulationDebugger::EntityDebugInfo>,std::__map_value_compare<Phase::Handle64,std::__value_type<Phase::Handle64,Phase::SpatialModeler::RoomSimulationDebugger::EntityDebugInfo>,std::less<Phase::Handle64>,true>,std::allocator<std::__value_type<Phase::Handle64,Phase::SpatialModeler::RoomSimulationDebugger::EntityDebugInfo>>>::destroy(a2 + 104, *(_QWORD **)(a2 + 112));
    std::__tree<std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>,std::__map_value_compare<Phase::Handle64,std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>,std::less<Phase::Handle64>,true>,std::allocator<std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>>>::destroy(a2 + 16, *(_QWORD **)(a2 + 24));
    JUMPOUT(0x2199F9D70);
  }
}

void std::__tree<std::__value_type<Phase::Handle64,Phase::SpatialModeler::RoomSimulationDebugger::EntityDebugInfo>,std::__map_value_compare<Phase::Handle64,std::__value_type<Phase::Handle64,Phase::SpatialModeler::RoomSimulationDebugger::EntityDebugInfo>,std::less<Phase::Handle64>,true>,std::allocator<std::__value_type<Phase::Handle64,Phase::SpatialModeler::RoomSimulationDebugger::EntityDebugInfo>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<Phase::Handle64,Phase::SpatialModeler::RoomSimulationDebugger::EntityDebugInfo>,std::__map_value_compare<Phase::Handle64,std::__value_type<Phase::Handle64,Phase::SpatialModeler::RoomSimulationDebugger::EntityDebugInfo>,std::less<Phase::Handle64>,true>,std::allocator<std::__value_type<Phase::Handle64,Phase::SpatialModeler::RoomSimulationDebugger::EntityDebugInfo>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<Phase::Handle64,Phase::SpatialModeler::RoomSimulationDebugger::EntityDebugInfo>,std::__map_value_compare<Phase::Handle64,std::__value_type<Phase::Handle64,Phase::SpatialModeler::RoomSimulationDebugger::EntityDebugInfo>,std::less<Phase::Handle64>,true>,std::allocator<std::__value_type<Phase::Handle64,Phase::SpatialModeler::RoomSimulationDebugger::EntityDebugInfo>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<Phase::Handle64 const,Phase::SpatialModeler::RoomSimulationDebugger::EntityDebugInfo>,0>(a2 + 4);
    operator delete(a2);
  }
}

_QWORD *std::__destroy_at[abi:ne180100]<std::pair<Phase::Handle64 const,Phase::SpatialModeler::RoomSimulationDebugger::EntityDebugInfo>,0>(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *result;
  uint64_t v14;

  v2 = a1 + 23;
  v3 = (_QWORD *)a1[26];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  v5 = (_QWORD *)a1[22];
  if (v5 == a1 + 19)
  {
    v6 = 4;
    v5 = a1 + 19;
  }
  else
  {
    if (!v5)
      goto LABEL_11;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  v7 = (_QWORD *)a1[18];
  if (v7 == a1 + 15)
  {
    v8 = 4;
    v7 = a1 + 15;
  }
  else
  {
    if (!v7)
      goto LABEL_16;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_16:
  v9 = (_QWORD *)a1[14];
  if (v9 == a1 + 11)
  {
    v10 = 4;
    v9 = a1 + 11;
  }
  else
  {
    if (!v9)
      goto LABEL_21;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_21:
  v11 = (_QWORD *)a1[10];
  if (v11 == a1 + 7)
  {
    v12 = 4;
    v11 = a1 + 7;
  }
  else
  {
    if (!v11)
      goto LABEL_26;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_26:
  result = (_QWORD *)a1[6];
  if (result == a1 + 3)
  {
    v14 = 4;
    result = a1 + 3;
  }
  else
  {
    if (!result)
      return result;
    v14 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v14))();
}

void std::__tree<std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>,std::__map_value_compare<Phase::Handle64,std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>,std::less<Phase::Handle64>,true>,std::allocator<std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>,std::__map_value_compare<Phase::Handle64,std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>,std::less<Phase::Handle64>,true>,std::allocator<std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>,std::__map_value_compare<Phase::Handle64,std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>,std::less<Phase::Handle64>,true>,std::allocator<std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<Phase::Handle64 const,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>,0>(a2 + 4);
    operator delete(a2);
  }
}

void std::vector<Phase::Geometry::MpsCpuSceneDescriptor>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<Phase::Geometry::MpsCpuSceneDescriptor>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

uint64_t *std::unique_ptr<Phase::Geometry::System::ReleaseRequest>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    std::unique_ptr<Phase::Geometry::System::ReleaseRequest>::reset[abi:ne180100](v2 + 16, 0);
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

void Phase::details::SharedSlotMap<Phase::Geometry::Material,Phase::Handle64>::Release(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t UniqueSlot;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;

  v2 = a2;
  UniqueSlot = Phase::details::SharedSlotMap<Phase::Geometry::Material,Phase::Handle64>::GetUniqueSlot(a1, a2);
  if (!UniqueSlot)
    return;
  v5 = UniqueSlot;
  ++*(_DWORD *)(UniqueSlot + 20);
  std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)UniqueSlot);
  v6 = (unsigned int *)(a1 + 20);
  v7 = atomic_load((unsigned int *)(a1 + 20));
  *(_DWORD *)(v5 + 16) = v7;
  v8 = __ldaxr((unsigned int *)(a1 + 20));
  if (v8 != v7)
  {
    __clrex();
LABEL_6:
    while (1)
    {
      *(_DWORD *)(v5 + 16) = v8;
      v9 = __ldaxr(v6);
      if (v9 != v8)
        break;
      if (__stlxr(v2, v6))
        goto LABEL_10;
      v10 = 1;
LABEL_11:
      v8 = v9;
      if (v10)
        return;
    }
    __clrex();
LABEL_10:
    v10 = 0;
    goto LABEL_11;
  }
  if (__stlxr(v2, v6))
    goto LABEL_6;
}

uint64_t Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::UnblockSlot(uint64_t result, uint64_t a2)
{
  unsigned int *v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  char v7;
  unsigned int v8;
  int v9;

  if (*(_DWORD *)(result + 16) <= a2
    || *(_DWORD *)(*(_QWORD *)result + 24 * a2 + 20) - 1 != HIDWORD(a2))
  {
    return result;
  }
  v2 = (unsigned int *)(result + 20);
  v3 = atomic_load((unsigned int *)(result + 20));
  v4 = *(_QWORD *)result + 24 * a2;
  *(_DWORD *)(v4 + 16) = v3;
  v5 = (unsigned int *)(v4 + 16);
  v6 = __ldaxr((unsigned int *)(result + 20));
  if (v6 == v3)
  {
    if (!__stlxr(a2, v2))
    {
      v7 = 1;
      goto LABEL_8;
    }
  }
  else
  {
    __clrex();
  }
  v7 = 0;
LABEL_8:
  if ((v7 & 1) == 0)
  {
    while (1)
    {
      *v5 = v6;
      v8 = __ldaxr(v2);
      if (v8 != v6)
        break;
      if (__stlxr(a2, v2))
        goto LABEL_13;
      v9 = 1;
LABEL_14:
      v6 = v8;
      if (v9)
        return result;
    }
    __clrex();
LABEL_13:
    v9 = 0;
    goto LABEL_14;
  }
  return result;
}

void std::__function::__func<std::shared_ptr<Phase::Geometry::Directivity> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Directivity> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::shared_ptr<Phase::Geometry::Directivity> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Directivity> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D57D590;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Directivity> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Directivity> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D57D590;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Directivity> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Directivity> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 8))(a2, *a3);
}

void std::__function::__func<std::shared_ptr<Phase::Geometry::Directivity> (*)(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Directivity> (*)(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::shared_ptr<Phase::Geometry::Directivity> (*)(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Directivity> (*)(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D57D5D8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Directivity> (*)(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Directivity> (*)(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D57D5D8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Directivity> (*)(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Directivity> (*)(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a1 + 8))(a2, a3, *a4);
}

void std::__function::__func<std::shared_ptr<Phase::Geometry::DistanceModel> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::DistanceModel> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::shared_ptr<Phase::Geometry::DistanceModel> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::DistanceModel> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D57D620;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::DistanceModel> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::DistanceModel> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D57D620;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::DistanceModel> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::DistanceModel> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 8))(a2, *a3);
}

void std::__function::__func<std::shared_ptr<Phase::Geometry::DistanceModel> (*)(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::DistanceModel> (*)(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::shared_ptr<Phase::Geometry::DistanceModel> (*)(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::DistanceModel> (*)(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D57D668;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::DistanceModel> (*)(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::DistanceModel> (*)(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D57D668;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::DistanceModel> (*)(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::DistanceModel> (*)(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a1 + 8))(a2, a3, *a4);
}

void std::__function::__func<std::shared_ptr<Phase::Geometry::Medium> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Medium> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::shared_ptr<Phase::Geometry::Medium> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Medium> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D57D6B0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Medium> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Medium> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D57D6B0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Medium> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Medium> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 8))(a2, *a3);
}

void std::__function::__func<std::shared_ptr<Phase::Geometry::Medium> (*)(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Medium> (*)(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::shared_ptr<Phase::Geometry::Medium> (*)(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Medium> (*)(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D57D6F8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Medium> (*)(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Medium> (*)(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D57D6F8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Medium> (*)(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Medium> (*)(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a1 + 8))(a2, a3, *a4);
}

void std::__function::__func<std::shared_ptr<Phase::Geometry::Material> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Material> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::shared_ptr<Phase::Geometry::Material> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Material> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D57D740;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Material> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Material> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D57D740;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Material> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Material> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 8))(a2, *a3);
}

void std::__function::__func<std::shared_ptr<Phase::Geometry::Material> (*)(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Material> (*)(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::shared_ptr<Phase::Geometry::Material> (*)(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Material> (*)(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D57D788;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Material> (*)(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Material> (*)(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D57D788;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Material> (*)(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Material> (*)(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a1 + 8))(a2, a3, *a4);
}

void std::__function::__func<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D57D7D0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D57D7D0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 8))(a2, *a3);
}

void std::__function::__func<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::Geometry::Shape&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::Geometry::Shape&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Geometry::Shape&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::Geometry::Shape&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::Geometry::Shape&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Geometry::Shape&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D57D818;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::Geometry::Shape&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::Geometry::Shape&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Geometry::Shape&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D57D818;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::Geometry::Shape&,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::Geometry::Shape&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Geometry::Shape&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a1 + 8))(a2, a3, *a4);
}

void std::__function::__func<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D57D860;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D57D860;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *),std::allocator<std::shared_ptr<Phase::Geometry::Shape> (*)(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>,std::shared_ptr<Phase::Geometry::Shape> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a1 + 8))(a2, a3, *a4);
}

void std::__function::__func<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&),std::allocator<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&)>,void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&),std::allocator<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&)>,void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D57D8A8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&),std::allocator<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&)>,void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D57D8A8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&),std::allocator<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&)>,void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQueryFunctionTable const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a2, a3, a4);
}

void std::__function::__func<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL),std::allocator<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL)>,void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL),std::allocator<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL)>,void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D57D8F0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL),std::allocator<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL)>,void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D57D8F0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL),std::allocator<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL)>,void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,std::vector<std::function<void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>> const&,BOOL)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int8 *a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(a1 + 8))(a2, a3, a4, a5, *a6);
}

void std::__function::__func<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &),std::allocator<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>,void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &),std::allocator<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>,void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D57D938;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &),std::allocator<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>,void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D57D938;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &),std::allocator<void (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>,void ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,Phase::Geometry::SceneQuery &,Phase::Geometry::SceneQueryShapeState &)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8))(a2, a3, a4, a5);
}

void std::__function::__func<BOOL (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int),std::allocator<BOOL (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>,BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<BOOL (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int),std::allocator<BOOL (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>,BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24D57D980;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<BOOL (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int),std::allocator<BOOL (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>,BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24D57D980;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<BOOL (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int),std::allocator<BOOL (*)(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>,BOOL ()(Phase::Geometry::SystemState &,Phase::Geometry::SceneQueryBatch &,int,int)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4, unsigned int *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(a1 + 8))(a2, a3, *a4, *a5);
}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100IN5Phase8Geometry11SystemStateENS_9allocatorIS3_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x420uLL);
  result = _ZNSt3__120__shared_ptr_emplaceIN5Phase8Geometry11SystemStateENS_9allocatorIS3_EEEC2B8ne180100IJES5_Li0EEES5_DpOT_(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_2165D305C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceIN5Phase8Geometry11SystemStateENS_9allocatorIS3_EEEC2B8ne180100IJES5_Li0EEES5_DpOT_(_QWORD *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_24D57D9C8;
  Phase::Geometry::SystemState::SystemState((Phase::Geometry::SystemState *)(a1 + 3));
  return a1;
}

void sub_2165D30A4(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<Phase::Geometry::SystemState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57D9C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Phase::Geometry::SystemState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57D9C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__shared_ptr_emplace<Phase::Geometry::SystemState>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2;
  void **v4;

  v2 = a1 + 24;
  v4 = (void **)(a1 + 1008);
  std::vector<std::shared_ptr<Phase::Controller::Renderer>>::__destroy_vector::operator()[abi:ne180100](&v4);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](a1 + 144);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](a1 + 120);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](a1 + 96);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](a1 + 72);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](a1 + 48);
  return std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v2);
}

Phase::Geometry::SystemState *Phase::Geometry::SystemState::SystemState(Phase::Geometry::SystemState *this)
{
  Phase::SpatialModeler::TRAP *v2;
  char *v3;
  char *v4;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_DWORD *)this + 34) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 110) = 0;
  bzero((char *)this + 144, 0x2DCuLL);
  v3 = Phase::SpatialModeler::TRAP::TP(v2);
  *((_DWORD *)this + 222) = *((_DWORD *)v3 + 101);
  v4 = Phase::SpatialModeler::TRAP::TP((Phase::SpatialModeler::TRAP *)v3);
  *((_BYTE *)this + 892) = v4[508];
  *((_DWORD *)this + 224) = *((_DWORD *)Phase::SpatialModeler::TRAP::TP((Phase::SpatialModeler::TRAP *)v4) + 102);
  *(_OWORD *)((char *)this + 904) = 0u;
  *((_DWORD *)this + 230) = 0;
  *(_QWORD *)((char *)this + 924) = 1065353216;
  *((_BYTE *)this + 932) = 0;
  *((_QWORD *)this + 117) = 0;
  *((_QWORD *)this + 118) = -1;
  *((_QWORD *)this + 119) = -1;
  *((_QWORD *)this + 120) = -1;
  *(_OWORD *)((char *)this + 968) = 0u;
  *(_OWORD *)((char *)this + 984) = 0u;
  *(_OWORD *)((char *)this + 1000) = 0u;
  *(_OWORD *)((char *)this + 1016) = 0u;
  return this;
}

void sub_2165D3268(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v6);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v5);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v3);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>::ReleaseMessage(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v7;

  v7 = 0uLL;
  std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100](a2, &v7);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v7 + 1);
  if (*((_QWORD *)&v7 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v7 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  *(_BYTE *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = a2;
}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100IN5Phase16DataObserverSPSCINS_10shared_ptrINS1_8Geometry11SystemStateEEEEENS_9allocatorIS7_EEJEvEENS3_IT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x90uLL);
  result = _ZNSt3__120__shared_ptr_emplaceIN5Phase16DataObserverSPSCINS_10shared_ptrINS1_8Geometry11SystemStateEEEEENS_9allocatorIS7_EEEC2B8ne180100IJES9_Li0EEES9_DpOT_(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_2165D3360(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceIN5Phase16DataObserverSPSCINS_10shared_ptrINS1_8Geometry11SystemStateEEEEENS_9allocatorIS7_EEEC2B8ne180100IJES9_Li0EEES9_DpOT_(_QWORD *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_24D57DA00;
  Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>::DataObserverSPSC((uint64_t)(a1 + 3));
  return a1;
}

void sub_2165D33A8(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57DA00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57DA00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__shared_ptr_emplace<Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t i;
  uint64_t result;

  for (i = 112; i != 16; i -= 32)
    result = std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](a1 + i);
  return result;
}

uint64_t Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>::DataObserverSPSC(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_BYTE *)(a1 + 112) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  v2 = 24;
  *(_BYTE *)(a1 + 48) = 0;
  do
  {
    Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>::ReleaseMessage(a1, a1 + v2);
    v2 += 32;
  }
  while (v2 != 120);
  return a1;
}

void sub_2165D34A0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t i;

  for (i = 88; i != -8; i -= 32)
    std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1 + i);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<std::weak_ptr<Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>>>::emplace_back<std::shared_ptr<Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>> const&>(unint64_t *a1, __int128 *a2)
{
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  __int128 v17;
  unint64_t *v18;
  unint64_t v19;
  __int128 v20;
  int64x2_t v21;
  unint64_t v22;
  uint64_t v24;
  int64x2_t v25;
  unint64_t v26;
  unint64_t *v27;

  v4 = a1[2];
  v5 = (_QWORD *)a1[1];
  if ((unint64_t)v5 >= v4)
  {
    v10 = *a1;
    v11 = (uint64_t)((uint64_t)v5 - *a1) >> 4;
    v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 60)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v13 = v4 - v10;
    if (v13 >> 3 > v12)
      v12 = v13 >> 3;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0)
      v14 = 0xFFFFFFFFFFFFFFFLL;
    else
      v14 = v12;
    v27 = a1 + 2;
    if (v14 >> 60)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v15 = (char *)operator new(16 * v14);
    v16 = &v15[16 * v11];
    v17 = *a2;
    *(_OWORD *)v16 = *a2;
    if (*((_QWORD *)&v17 + 1))
    {
      v18 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 16);
      do
        v19 = __ldxr(v18);
      while (__stxr(v19 + 1, v18));
      v10 = *a1;
      v5 = (_QWORD *)a1[1];
    }
    v9 = v16 + 16;
    if (v5 == (_QWORD *)v10)
    {
      v21 = vdupq_n_s64(v10);
    }
    else
    {
      do
      {
        v20 = *((_OWORD *)v5 - 1);
        v5 -= 2;
        *((_OWORD *)v16 - 1) = v20;
        v16 -= 16;
        *v5 = 0;
        v5[1] = 0;
      }
      while (v5 != (_QWORD *)v10);
      v21 = *(int64x2_t *)a1;
    }
    *a1 = (unint64_t)v16;
    a1[1] = (unint64_t)v9;
    v25 = v21;
    v22 = a1[2];
    a1[2] = (unint64_t)&v15[16 * v14];
    v26 = v22;
    v24 = v21.i64[0];
    std::__split_buffer<std::weak_ptr<Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>>>::~__split_buffer((uint64_t)&v24);
  }
  else
  {
    *v5 = *(_QWORD *)a2;
    v6 = *((_QWORD *)a2 + 1);
    v5[1] = v6;
    if (v6)
    {
      v7 = (unint64_t *)(v6 + 16);
      do
        v8 = __ldxr(v7);
      while (__stxr(v8 + 1, v7));
    }
    v9 = v5 + 2;
  }
  a1[1] = (unint64_t)v9;
  return v9 - 2;
}

uint64_t std::__split_buffer<std::weak_ptr<Phase::DataObserverSPSC<std::shared_ptr<Phase::Geometry::SystemState>>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    *(_QWORD *)(a1 + 16) = v2 - 16;
    v4 = *(std::__shared_weak_count **)(v2 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_weak(v4);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 16;
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::GetUniqueSlot(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  uint64_t result;
  uint64_t v5;

  if (*(_DWORD *)(a1 + 16) <= a2)
    return 0;
  v3 = a2;
  result = *(_QWORD *)a1 + 24 * a2;
  if (*(_DWORD *)(result + 20) != HIDWORD(a2))
    return 0;
  v5 = *(_QWORD *)(a1 + 8);
  if (v5)
  {
    if (*(uint64_t *)(v5 + 8) >= 1)
    {
      Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::Realloc((__int128 *)a1);
      return *(_QWORD *)a1 + 24 * v3;
    }
  }
  return result;
}

uint64_t Phase::Geometry::SystemDebugger::GetFromSystem(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;

  result = *(_QWORD *)(a1 + 2760);
  if (!result)
  {
    result = operator new();
    *(_QWORD *)result = a1;
    *(_QWORD *)(result + 8) = a1;
    *(_QWORD *)(result + 32) = 0;
    *(_QWORD *)(result + 24) = 0;
    *(_QWORD *)(result + 16) = result + 24;
    *(_BYTE *)(result + 40) = 1;
    *(_QWORD *)(result + 48) = 2;
    *(_QWORD *)(result + 56) = 0x3C03126F3C23D70ALL;
    *(_QWORD *)(result + 64) = 0;
    *(_QWORD *)(result + 72) = 0;
    *(_BYTE *)(result + 80) = 0;
    *(int32x2_t *)(result + 84) = vdup_n_s32(0x3F51EB85u);
    *(_DWORD *)(result + 92) = 1049918178;
    *(_QWORD *)(result + 120) = 0;
    *(_QWORD *)(result + 112) = 0;
    *(_QWORD *)(result + 96) = a1;
    *(_QWORD *)(result + 104) = result + 112;
    v3 = *(_QWORD *)(a1 + 2760);
    *(_QWORD *)(a1 + 2760) = result;
    if (v3)
    {
      v4 = a1 + 2760;
      std::default_delete<Phase::Geometry::SystemDebugger>::operator()[abi:ne180100](v4, v3);
      return *(_QWORD *)v4;
    }
  }
  return result;
}

Phase::Logger *Phase::Geometry::SystemExecutor::Init(Phase::Logger *this, Phase::Geometry::System *a2)
{
  NSObject *v2;
  std::runtime_error *exception;
  int v4;
  const char *v5;
  __int16 v6;
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (!a2)
  {
    v2 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 416);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v4 = 136315394;
      v5 = "GeoSystemExecutor.cpp";
      v6 = 1024;
      v7 = 33;
      _os_log_impl(&dword_2164CC000, v2, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [nullptr == inpSystem is true]: \"Null system pointer passed to SystemExecutor::Init\"", (uint8_t *)&v4, 0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Null system pointer passed to SystemExecutor::Init");
  }
  *((_QWORD *)this + 5) = a2;
  return this;
}

void sub_2165D3898(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void Phase::Geometry::SystemExecutor::Update(Phase::Geometry::SystemExecutor *this, float a2)
{
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;

  v3 = *((_QWORD *)this + 5);
  v4 = atomic_load((unsigned int *)(v3 + 24));
  if (*(_DWORD *)(v3 + 16) < v4)
  {
    if (v4 >= 0x40)
      v5 = v4 + (v4 >> 1);
    else
      v5 = 64;
    Phase::details::SharedSlotMap<Phase::Geometry::Directivity,Phase::Handle64>::Resize((__int128 *)v3, v5);
  }
  v6 = *((_QWORD *)this + 5);
  v7 = atomic_load((unsigned int *)(v6 + 272));
  if (*(_DWORD *)(v6 + 264) < v7)
  {
    if (v7 >= 0x40)
      v8 = v7 + (v7 >> 1);
    else
      v8 = 64;
    Phase::details::SharedSlotMap<Phase::Geometry::DistanceModel,Phase::Handle64>::Resize((__int128 *)(v6 + 248), v8);
  }
  v9 = *((_QWORD *)this + 5);
  v10 = atomic_load((unsigned int *)(v9 + 528));
  if (*(_DWORD *)(v9 + 520) < v10)
  {
    if (v10 >= 0x40)
      v11 = v10 + (v10 >> 1);
    else
      v11 = 64;
    Phase::details::SharedSlotMap<Phase::Geometry::Medium,Phase::Handle64>::Resize((__int128 *)(v9 + 504), v11);
  }
  v12 = *((_QWORD *)this + 5);
  v13 = atomic_load((unsigned int *)(v12 + 768));
  if (*(_DWORD *)(v12 + 760) < v13)
  {
    if (v13 >= 0x40)
      v14 = v13 + (v13 >> 1);
    else
      v14 = 64;
    Phase::details::SharedSlotMap<Phase::Geometry::Material,Phase::Handle64>::Resize((__int128 *)(v12 + 744), v14);
  }
  v15 = *((_QWORD *)this + 5);
  v16 = atomic_load((unsigned int *)(v15 + 1016));
  if (*(_DWORD *)(v15 + 1008) < v16)
  {
    if (v16 >= 0x40)
      v17 = v16 + (v16 >> 1);
    else
      v17 = 64;
    Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::Resize((__int128 *)(v15 + 992), v17);
  }
  v18 = *((_QWORD *)this + 5);
  v19 = atomic_load((unsigned int *)(v18 + 1264));
  if (*(_DWORD *)(v18 + 1256) < v19)
  {
    if (v19 >= 0x40)
      v20 = v19 + (v19 >> 1);
    else
      v20 = 64;
    Phase::details::SharedSlotMap<Phase::Geometry::Entity,Phase::Handle64>::Resize((__int128 *)(v18 + 1240), v20);
  }
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::ExecuteCommands((uint64_t)this);
  Phase::Geometry::System::BuildCurrentState(*((Phase::Geometry::System **)this + 5));
}

uint64_t Phase::Geometry::SystemExecutor::SetDefaulSceneMedium(uint64_t this, Handle64 a2)
{
  *(Handle64 *)(*(_QWORD *)(this + 40) + 1464) = a2;
  return this;
}

uint64_t Phase::Geometry::SystemExecutor::SetDefaultSceneReverbPreset(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(this + 40) + 1472) = a2;
  return this;
}

void Phase::details::SharedSlotMap<Phase::Geometry::Directivity,Phase::Handle64>::Resize(__int128 *a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  __int128 *v15;
  char v16;
  __int128 v17;

  v2 = *((unsigned int *)a1 + 4);
  if (v2 < a2)
  {
    Phase::details::SharedSlotMap<Phase::Geometry::Directivity,Phase::Handle64>::AllocSlots(a2, &v17);
    if ((_DWORD)v2)
    {
      v5 = 0;
      do
      {
        v6 = (uint64_t *)(*(_QWORD *)a1 + v5);
        v7 = v17 + v5;
        std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(v17 + v5), v6);
        *(_QWORD *)(v7 + 16) = v6[2];
        v5 += 24;
      }
      while (24 * v2 != v5);
      v8 = v2;
    }
    else
    {
      v8 = 0;
    }
    v9 = 24 * v8;
    do
    {
      v10 = v17 + v9;
      std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)(v17 + v9));
      *(_QWORD *)(v10 + 16) = 0x1FFFFFFFFLL;
      LODWORD(v2) = v2 + 1;
      v9 += 24;
    }
    while (a2 != (_DWORD)v2);
    v15 = a1 + 2;
    v16 = 1;
    std::__shared_mutex_base::lock((std::__shared_mutex_base *)(a1 + 2));
    v11 = *a1;
    *a1 = v17;
    v17 = v11;
    std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v15);
    *((_DWORD *)a1 + 4) = a2;
    v12 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
    if (*((_QWORD *)&v17 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
}

void sub_2165D3B58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void Phase::details::SharedSlotMap<Phase::Geometry::Directivity,Phase::Handle64>::AllocSlots(unint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;

  if (a1)
  {
    is_mul_ok(a1, 0x18uLL);
    v4 = 24 * a1;
    v5 = (_QWORD *)operator new[]();
    *v5 = 24;
    v5[1] = a1;
    v6 = v5 + 2;
    do
    {
      *v6 = 0;
      v6[1] = 0;
      v6 += 3;
      v4 -= 24;
    }
    while (v4);
    std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::Slot []>::shared_ptr[abi:ne180100]<Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::Slot,void>(a2, (uint64_t)(v5 + 2));
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

_QWORD *std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::Slot []>::shared_ptr[abi:ne180100]<Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::Slot,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D57DA38;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_2165D3C64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot,std::default_delete<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot>>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::Slot *,std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::Slot[]>::__shared_ptr_default_delete<Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::Slot[],Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::Slot>,std::allocator<Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::Slot>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

void std::__shared_ptr_pointer<Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::Slot *,std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::Slot[]>::__shared_ptr_default_delete<Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::Slot[],Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::Slot>,std::allocator<Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::Slot>>::__on_zero_shared(uint64_t a1)
{
  std::default_delete<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot []>::operator()[abi:ne180100]<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot>(a1 + 24, *(_QWORD *)(a1 + 24));
}

void Phase::details::SharedSlotMap<Phase::Geometry::DistanceModel,Phase::Handle64>::Resize(__int128 *a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  __int128 *v15;
  char v16;
  __int128 v17;

  v2 = *((unsigned int *)a1 + 4);
  if (v2 < a2)
  {
    Phase::details::SharedSlotMap<Phase::Geometry::DistanceModel,Phase::Handle64>::AllocSlots(a2, &v17);
    if ((_DWORD)v2)
    {
      v5 = 0;
      do
      {
        v6 = (uint64_t *)(*(_QWORD *)a1 + v5);
        v7 = v17 + v5;
        std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(v17 + v5), v6);
        *(_QWORD *)(v7 + 16) = v6[2];
        v5 += 24;
      }
      while (24 * v2 != v5);
      v8 = v2;
    }
    else
    {
      v8 = 0;
    }
    v9 = 24 * v8;
    do
    {
      v10 = v17 + v9;
      std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)(v17 + v9));
      *(_QWORD *)(v10 + 16) = 0x1FFFFFFFFLL;
      LODWORD(v2) = v2 + 1;
      v9 += 24;
    }
    while (a2 != (_DWORD)v2);
    v15 = a1 + 2;
    v16 = 1;
    std::__shared_mutex_base::lock((std::__shared_mutex_base *)(a1 + 2));
    v11 = *a1;
    *a1 = v17;
    v17 = v11;
    std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v15);
    *((_DWORD *)a1 + 4) = a2;
    v12 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
    if (*((_QWORD *)&v17 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
}

void sub_2165D3DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void Phase::details::SharedSlotMap<Phase::Geometry::DistanceModel,Phase::Handle64>::AllocSlots(unint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;

  if (a1)
  {
    is_mul_ok(a1, 0x18uLL);
    v4 = 24 * a1;
    v5 = (_QWORD *)operator new[]();
    *v5 = 24;
    v5[1] = a1;
    v6 = v5 + 2;
    do
    {
      *v6 = 0;
      v6[1] = 0;
      v6 += 3;
      v4 -= 24;
    }
    while (v4);
    std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::DistanceModel,Phase::Handle64>::Slot []>::shared_ptr[abi:ne180100]<Phase::SharedSlotMapState<Phase::Geometry::DistanceModel,Phase::Handle64>::Slot,void>(a2, (uint64_t)(v5 + 2));
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

_QWORD *std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::DistanceModel,Phase::Handle64>::Slot []>::shared_ptr[abi:ne180100]<Phase::SharedSlotMapState<Phase::Geometry::DistanceModel,Phase::Handle64>::Slot,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D57DA70;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_2165D3F04(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot,std::default_delete<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot>>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<Phase::SharedSlotMapState<Phase::Geometry::DistanceModel,Phase::Handle64>::Slot *,std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::DistanceModel,Phase::Handle64>::Slot[]>::__shared_ptr_default_delete<Phase::SharedSlotMapState<Phase::Geometry::DistanceModel,Phase::Handle64>::Slot[],Phase::SharedSlotMapState<Phase::Geometry::DistanceModel,Phase::Handle64>::Slot>,std::allocator<Phase::SharedSlotMapState<Phase::Geometry::DistanceModel,Phase::Handle64>::Slot>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

void std::__shared_ptr_pointer<Phase::SharedSlotMapState<Phase::Geometry::DistanceModel,Phase::Handle64>::Slot *,std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::DistanceModel,Phase::Handle64>::Slot[]>::__shared_ptr_default_delete<Phase::SharedSlotMapState<Phase::Geometry::DistanceModel,Phase::Handle64>::Slot[],Phase::SharedSlotMapState<Phase::Geometry::DistanceModel,Phase::Handle64>::Slot>,std::allocator<Phase::SharedSlotMapState<Phase::Geometry::DistanceModel,Phase::Handle64>::Slot>>::__on_zero_shared(uint64_t a1)
{
  std::default_delete<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot []>::operator()[abi:ne180100]<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot>(a1 + 24, *(_QWORD *)(a1 + 24));
}

void Phase::details::SharedSlotMap<Phase::Geometry::Medium,Phase::Handle64>::Resize(__int128 *a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  __int128 *v15;
  char v16;
  __int128 v17;

  v2 = *((unsigned int *)a1 + 4);
  if (v2 < a2)
  {
    Phase::details::SharedSlotMap<Phase::Geometry::Medium,Phase::Handle64>::AllocSlots(a2, &v17);
    if ((_DWORD)v2)
    {
      v5 = 0;
      do
      {
        v6 = (uint64_t *)(*(_QWORD *)a1 + v5);
        v7 = v17 + v5;
        std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(v17 + v5), v6);
        *(_QWORD *)(v7 + 16) = v6[2];
        v5 += 24;
      }
      while (24 * v2 != v5);
      v8 = v2;
    }
    else
    {
      v8 = 0;
    }
    v9 = 24 * v8;
    do
    {
      v10 = v17 + v9;
      std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)(v17 + v9));
      *(_QWORD *)(v10 + 16) = 0x1FFFFFFFFLL;
      LODWORD(v2) = v2 + 1;
      v9 += 24;
    }
    while (a2 != (_DWORD)v2);
    v15 = a1 + 2;
    v16 = 1;
    std::__shared_mutex_base::lock((std::__shared_mutex_base *)(a1 + 2));
    v11 = *a1;
    *a1 = v17;
    v17 = v11;
    std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v15);
    *((_DWORD *)a1 + 4) = a2;
    v12 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
    if (*((_QWORD *)&v17 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
}

void sub_2165D4098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void Phase::details::SharedSlotMap<Phase::Geometry::Medium,Phase::Handle64>::AllocSlots(unint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;

  if (a1)
  {
    is_mul_ok(a1, 0x18uLL);
    v4 = 24 * a1;
    v5 = (_QWORD *)operator new[]();
    *v5 = 24;
    v5[1] = a1;
    v6 = v5 + 2;
    do
    {
      *v6 = 0;
      v6[1] = 0;
      v6 += 3;
      v4 -= 24;
    }
    while (v4);
    std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::Medium,Phase::Handle64>::Slot []>::shared_ptr[abi:ne180100]<Phase::SharedSlotMapState<Phase::Geometry::Medium,Phase::Handle64>::Slot,void>(a2, (uint64_t)(v5 + 2));
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

_QWORD *std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::Medium,Phase::Handle64>::Slot []>::shared_ptr[abi:ne180100]<Phase::SharedSlotMapState<Phase::Geometry::Medium,Phase::Handle64>::Slot,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24D57DAA8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_2165D41A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot,std::default_delete<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot>>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<Phase::SharedSlotMapState<Phase::Geometry::Medium,Phase::Handle64>::Slot *,std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::Medium,Phase::Handle64>::Slot[]>::__shared_ptr_default_delete<Phase::SharedSlotMapState<Phase::Geometry::Medium,Phase::Handle64>::Slot[],Phase::SharedSlotMapState<Phase::Geometry::Medium,Phase::Handle64>::Slot>,std::allocator<Phase::SharedSlotMapState<Phase::Geometry::Medium,Phase::Handle64>::Slot>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

void std::__shared_ptr_pointer<Phase::SharedSlotMapState<Phase::Geometry::Medium,Phase::Handle64>::Slot *,std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::Medium,Phase::Handle64>::Slot[]>::__shared_ptr_default_delete<Phase::SharedSlotMapState<Phase::Geometry::Medium,Phase::Handle64>::Slot[],Phase::SharedSlotMapState<Phase::Geometry::Medium,Phase::Handle64>::Slot>,std::allocator<Phase::SharedSlotMapState<Phase::Geometry::Medium,Phase::Handle64>::Slot>>::__on_zero_shared(uint64_t a1)
{
  std::default_delete<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot []>::operator()[abi:ne180100]<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot>(a1 + 24, *(_QWORD *)(a1 + 24));
}

void Phase::details::SharedSlotMap<Phase::Geometry::Material,Phase::Handle64>::Resize(__int128 *a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  __int128 *v15;
  char v16;
  __int128 v17;

  v2 = *((unsigned int *)a1 + 4);
  if (v2 < a2)
  {
    Phase::details::SharedSlotMap<Phase::Geometry::Material,Phase::Handle64>::AllocSlots(a2, &v17);
    if ((_DWORD)v2)
    {
      v5 = 0;
      do
      {
        v6 = (uint64_t *)(*(_QWORD *)a1 + v5);
        v7 = v17 + v5;
        std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(v17 + v5), v6);
        *(_QWORD *)(v7 + 16) = v6[2];
        v5 += 24;
      }
      while (24 * v2 != v5);
      v8 = v2;
    }
    else
    {
      v8 = 0;
    }
    v9 = 24 * v8;
    do
    {
      v10 = v17 + v9;
      std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)(v17 + v9));
      *(_QWORD *)(v10 + 16) = 0x1FFFFFFFFLL;
      LODWORD(v2) = v2 + 1;
      v9 += 24;
    }
    while (a2 != (_DWORD)v2);
    v15 = a1 + 2;
    v16 = 1;
    std::__shared_mutex_base::lock((std::__shared_mutex_base *)(a1 + 2));
    v11 = *a1;
    *a1 = v17;
    v17 = v11;
    std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v15);
    *((_DWORD *)a1 + 4) = a2;
    v12 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
    if (*((_QWORD *)&v17 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
}

void sub_2165D4338(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

Phase::Logger *Phase::Geometry::SystemScheduler::Init(Phase::Geometry::SystemScheduler *this, Phase::Geometry::System *a2)
{
  NSObject *v3;
  std::runtime_error *exception;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (!a2)
  {
    v3 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 416);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "GeoSystemScheduler.cpp";
      v7 = 1024;
      v8 = 35;
      _os_log_impl(&dword_2164CC000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [nullptr == inpSystem is true]: \"Null system pointer passed to SystemScheduler::Init\"", (uint8_t *)&v5, 0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Null system pointer passed to SystemScheduler::Init");
  }
  *((_QWORD *)this + 6) = a2;
  return Phase::Geometry::SystemExecutor::Init(this, a2);
}

void sub_2165D443C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void Phase::Geometry::SystemScheduler::Update(Phase::Geometry::SystemScheduler *this, float a2)
{
  uint64_t InstancePtr;
  Phase::Logger *v5;
  Phase::Logger *v6;
  uint64_t v7;
  NSObject *v8;
  Phase::Logger *v9;
  Phase::Logger *v10;
  uint64_t v11;
  NSObject *v12;
  uint8_t v13[16];
  uint8_t buf[16];

  InstancePtr = Phase::Logger::GetInstancePtr(this);
  v5 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(InstancePtr + 896));
  v6 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v5);
  if (*((_BYTE *)v6 + 904))
  {
    v7 = Phase::Logger::GetInstancePtr(v6);
    if ((unint64_t)v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v8 = **(NSObject ***)(v7 + 896);
      if (os_signpost_enabled(v8))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_2164CC000, v8, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v5, "Phase_GeometrySystemScheduler_Update", "Geometry System Scheduler Update", buf, 2u);
      }
    }
  }
  Phase::Geometry::SystemExecutor::Update(this, a2);
  v10 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v9);
  if (*((_BYTE *)v10 + 904))
  {
    v11 = Phase::Logger::GetInstancePtr(v10);
    if ((unint64_t)v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v12 = **(NSObject ***)(v11 + 896);
      if (os_signpost_enabled(v12))
      {
        *(_WORD *)v13 = 0;
        _os_signpost_emit_with_name_impl(&dword_2164CC000, v12, OS_SIGNPOST_INTERVAL_END, (os_signpost_id_t)v5, "Phase_GeometrySystemScheduler_Update", (const char *)&unk_21676613F, v13, 2u);
      }
    }
  }
}

uint64_t Phase::Geometry::SystemScheduler::AddToDatabase(uint64_t a1, uint64_t *a2)
{
  uint64_t *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  NSObject *v19;
  Phase::Logger *InstancePtr;
  NSObject *v22;
  std::runtime_error *exception;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  unint64_t v28;
  _BYTE buf[12];
  __int16 v30;
  int v31;
  __int16 v32;
  unint64_t v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v4 = *(uint64_t **)(a1 + 48);
  v5 = (unsigned int *)v4 + 5;
  v6 = atomic_load((unsigned int *)v4 + 5);
  if (v6 != -1)
  {
    *(_QWORD *)buf = v4 + 4;
    buf[8] = 1;
    std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v4 + 4));
    do
    {
      v7 = v6;
      v8 = *v4;
      v9 = *(_DWORD *)(*v4 + 24 * v6 + 16);
      while (1)
      {
        v6 = __ldaxr(v5);
        if (v6 != v7)
          break;
        if (!__stlxr(v9, v5))
        {
          Phase::Handle64::Set((Phase::Logger *)&v24, v7, *(unsigned int *)(v8 + 24 * v7 + 20));
          std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
          v12 = v24;
          goto LABEL_12;
        }
      }
      __clrex();
    }
    while (v6 != -1);
    std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
  }
  v10 = (unsigned int *)(v4 + 3);
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 + 1, v10));
  v12 = v11 | 0x100000000;
LABEL_12:
  *(_QWORD *)&v24 = *(_QWORD *)(a1 + 48);
  *((_QWORD *)&v24 + 1) = v12;
  v13 = *a2;
  v14 = a2[1];
  v25 = *a2;
  v26 = v14;
  if (v14)
  {
    v15 = (unint64_t *)(v14 + 8);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  v17 = **(_QWORD **)(a1 + 8);
  v28 = 0;
  v27 = 1;
  v18 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v17, 40, &v28, &v27);
  if (!v18)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v22 = **(NSObject ***)(v17 + 48);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "CommandQueue.hpp";
      v30 = 1024;
      v31 = 100;
      _os_log_impl(&dword_2164CC000, v22, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v27)
  {
    v19 = **(NSObject ***)(v17 + 48);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "CommandQueue.hpp";
      v30 = 1024;
      v31 = 89;
      v32 = 2048;
      v33 = v28;
      v34 = 2048;
      v35 = 40;
      _os_log_impl(&dword_2164CC000, v19, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *(_QWORD *)v18 = &off_24D57DAE0;
  *(_OWORD *)(v18 + 2) = v24;
  *((_QWORD *)v18 + 3) = v13;
  *((_QWORD *)v18 + 4) = v14;
  v25 = 0;
  v26 = 0;
  Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v17, 40);
  atomic_store(0, (unsigned __int8 *)(v17 + 40));
  return v12;
}

{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  NSObject *v19;
  Phase::Logger *InstancePtr;
  NSObject *v22;
  std::runtime_error *exception;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  unint64_t v28;
  _BYTE buf[12];
  __int16 v30;
  int v31;
  __int16 v32;
  unint64_t v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 48);
  v5 = (unsigned int *)(v4 + 268);
  v6 = atomic_load((unsigned int *)(v4 + 268));
  if (v6 != -1)
  {
    *(_QWORD *)buf = v4 + 280;
    buf[8] = 1;
    std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v4 + 280));
    do
    {
      v7 = v6;
      v8 = *(_QWORD *)(v4 + 248);
      v9 = *(_DWORD *)(v8 + 24 * v6 + 16);
      while (1)
      {
        v6 = __ldaxr(v5);
        if (v6 != v7)
          break;
        if (!__stlxr(v9, v5))
        {
          Phase::Handle64::Set((Phase::Logger *)&v24, v7, *(unsigned int *)(v8 + 24 * v7 + 20));
          std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
          v12 = v24;
          goto LABEL_12;
        }
      }
      __clrex();
    }
    while (v6 != -1);
    std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
  }
  v10 = (unsigned int *)(v4 + 272);
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 + 1, v10));
  v12 = v11 | 0x100000000;
LABEL_12:
  *(_QWORD *)&v24 = *(_QWORD *)(a1 + 48);
  *((_QWORD *)&v24 + 1) = v12;
  v13 = *a2;
  v14 = a2[1];
  v25 = *a2;
  v26 = v14;
  if (v14)
  {
    v15 = (unint64_t *)(v14 + 8);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  v17 = **(_QWORD **)(a1 + 8);
  v28 = 0;
  v27 = 1;
  v18 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v17, 40, &v28, &v27);
  if (!v18)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v22 = **(NSObject ***)(v17 + 48);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "CommandQueue.hpp";
      v30 = 1024;
      v31 = 100;
      _os_log_impl(&dword_2164CC000, v22, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v27)
  {
    v19 = **(NSObject ***)(v17 + 48);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "CommandQueue.hpp";
      v30 = 1024;
      v31 = 89;
      v32 = 2048;
      v33 = v28;
      v34 = 2048;
      v35 = 40;
      _os_log_impl(&dword_2164CC000, v19, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *(_QWORD *)v18 = &off_24D57DB08;
  *(_OWORD *)(v18 + 2) = v24;
  *((_QWORD *)v18 + 3) = v13;
  *((_QWORD *)v18 + 4) = v14;
  v25 = 0;
  v26 = 0;
  Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v17, 40);
  atomic_store(0, (unsigned __int8 *)(v17 + 40));
  return v12;
}

{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  NSObject *v19;
  Phase::Logger *InstancePtr;
  NSObject *v22;
  std::runtime_error *exception;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  unint64_t v28;
  _BYTE buf[12];
  __int16 v30;
  int v31;
  __int16 v32;
  unint64_t v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 48);
  v5 = (unsigned int *)(v4 + 764);
  v6 = atomic_load((unsigned int *)(v4 + 764));
  if (v6 != -1)
  {
    *(_QWORD *)buf = v4 + 776;
    buf[8] = 1;
    std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v4 + 776));
    do
    {
      v7 = v6;
      v8 = *(_QWORD *)(v4 + 744);
      v9 = *(_DWORD *)(v8 + 24 * v6 + 16);
      while (1)
      {
        v6 = __ldaxr(v5);
        if (v6 != v7)
          break;
        if (!__stlxr(v9, v5))
        {
          Phase::Handle64::Set((Phase::Logger *)&v24, v7, *(unsigned int *)(v8 + 24 * v7 + 20));
          std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
          v12 = v24;
          goto LABEL_12;
        }
      }
      __clrex();
    }
    while (v6 != -1);
    std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
  }
  v10 = (unsigned int *)(v4 + 768);
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 + 1, v10));
  v12 = v11 | 0x100000000;
LABEL_12:
  *(_QWORD *)&v24 = *(_QWORD *)(a1 + 48);
  *((_QWORD *)&v24 + 1) = v12;
  v13 = *a2;
  v14 = a2[1];
  v25 = *a2;
  v26 = v14;
  if (v14)
  {
    v15 = (unint64_t *)(v14 + 8);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  v17 = **(_QWORD **)(a1 + 8);
  v28 = 0;
  v27 = 1;
  v18 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v17, 40, &v28, &v27);
  if (!v18)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v22 = **(NSObject ***)(v17 + 48);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "CommandQueue.hpp";
      v30 = 1024;
      v31 = 100;
      _os_log_impl(&dword_2164CC000, v22, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v27)
  {
    v19 = **(NSObject ***)(v17 + 48);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "CommandQueue.hpp";
      v30 = 1024;
      v31 = 89;
      v32 = 2048;
      v33 = v28;
      v34 = 2048;
      v35 = 40;
      _os_log_impl(&dword_2164CC000, v19, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *(_QWORD *)v18 = &off_24D57DB30;
  *(_OWORD *)(v18 + 2) = v24;
  *((_QWORD *)v18 + 3) = v13;
  *((_QWORD *)v18 + 4) = v14;
  v25 = 0;
  v26 = 0;
  Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v17, 40);
  atomic_store(0, (unsigned __int8 *)(v17 + 40));
  return v12;
}

{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  NSObject *v19;
  Phase::Logger *InstancePtr;
  NSObject *v22;
  std::runtime_error *exception;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  unint64_t v28;
  _BYTE buf[12];
  __int16 v30;
  int v31;
  __int16 v32;
  unint64_t v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 48);
  v5 = (unsigned int *)(v4 + 524);
  v6 = atomic_load((unsigned int *)(v4 + 524));
  if (v6 != -1)
  {
    *(_QWORD *)buf = v4 + 536;
    buf[8] = 1;
    std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v4 + 536));
    do
    {
      v7 = v6;
      v8 = *(_QWORD *)(v4 + 504);
      v9 = *(_DWORD *)(v8 + 24 * v6 + 16);
      while (1)
      {
        v6 = __ldaxr(v5);
        if (v6 != v7)
          break;
        if (!__stlxr(v9, v5))
        {
          Phase::Handle64::Set((Phase::Logger *)&v24, v7, *(unsigned int *)(v8 + 24 * v7 + 20));
          std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
          v12 = v24;
          goto LABEL_12;
        }
      }
      __clrex();
    }
    while (v6 != -1);
    std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
  }
  v10 = (unsigned int *)(v4 + 528);
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 + 1, v10));
  v12 = v11 | 0x100000000;
LABEL_12:
  *(_QWORD *)&v24 = *(_QWORD *)(a1 + 48);
  *((_QWORD *)&v24 + 1) = v12;
  v13 = *a2;
  v14 = a2[1];
  v25 = *a2;
  v26 = v14;
  if (v14)
  {
    v15 = (unint64_t *)(v14 + 8);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  v17 = **(_QWORD **)(a1 + 8);
  v28 = 0;
  v27 = 1;
  v18 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v17, 40, &v28, &v27);
  if (!v18)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v22 = **(NSObject ***)(v17 + 48);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "CommandQueue.hpp";
      v30 = 1024;
      v31 = 100;
      _os_log_impl(&dword_2164CC000, v22, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v27)
  {
    v19 = **(NSObject ***)(v17 + 48);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "CommandQueue.hpp";
      v30 = 1024;
      v31 = 89;
      v32 = 2048;
      v33 = v28;
      v34 = 2048;
      v35 = 40;
      _os_log_impl(&dword_2164CC000, v19, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *(_QWORD *)v18 = &off_24D57DB58;
  *(_OWORD *)(v18 + 2) = v24;
  *((_QWORD *)v18 + 3) = v13;
  *((_QWORD *)v18 + 4) = v14;
  v25 = 0;
  v26 = 0;
  Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v17, 40);
  atomic_store(0, (unsigned __int8 *)(v17 + 40));
  return v12;
}

{
  uint64_t Handle;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  NSObject *v11;
  Phase::Logger *InstancePtr;
  NSObject *v14;
  std::runtime_error *exception;
  __int128 v16;
  BOOL v17;
  unint64_t v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  unint64_t v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  Handle = Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::AllocateHandle((uint64_t *)(*(_QWORD *)(a1 + 48) + 992));
  *(_QWORD *)&v16 = *(_QWORD *)(a1 + 48);
  *((_QWORD *)&v16 + 1) = Handle;
  v5 = *a2;
  v6 = a2[1];
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = **(_QWORD **)(a1 + 8);
  v18 = 0;
  v17 = 1;
  v10 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v9, 40, &v18, &v17);
  if (!v10)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v14 = **(NSObject ***)(v9 + 48);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v20 = "CommandQueue.hpp";
      v21 = 1024;
      v22 = 100;
      _os_log_impl(&dword_2164CC000, v14, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v17)
  {
    v11 = **(NSObject ***)(v9 + 48);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v20 = "CommandQueue.hpp";
      v21 = 1024;
      v22 = 89;
      v23 = 2048;
      v24 = v18;
      v25 = 2048;
      v26 = 40;
      _os_log_impl(&dword_2164CC000, v11, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *(_QWORD *)v10 = &off_24D57DB80;
  *(_OWORD *)(v10 + 2) = v16;
  *((_QWORD *)v10 + 3) = v5;
  *((_QWORD *)v10 + 4) = v6;
  Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v9, 40);
  atomic_store(0, (unsigned __int8 *)(v9 + 40));
  return Handle;
}

{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  NSObject *v19;
  Phase::Logger *InstancePtr;
  NSObject *v22;
  std::runtime_error *exception;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  unint64_t v28;
  _BYTE buf[12];
  __int16 v30;
  int v31;
  __int16 v32;
  unint64_t v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 48);
  v5 = (unsigned int *)(v4 + 1260);
  v6 = atomic_load((unsigned int *)(v4 + 1260));
  if (v6 != -1)
  {
    *(_QWORD *)buf = v4 + 1272;
    buf[8] = 1;
    std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v4 + 1272));
    do
    {
      v7 = v6;
      v8 = *(_QWORD *)(v4 + 1240);
      v9 = *(_DWORD *)(v8 + 24 * v6 + 16);
      while (1)
      {
        v6 = __ldaxr(v5);
        if (v6 != v7)
          break;
        if (!__stlxr(v9, v5))
        {
          Phase::Handle64::Set((Phase::Logger *)&v24, v7, *(unsigned int *)(v8 + 24 * v7 + 20));
          std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
          v12 = v24;
          goto LABEL_12;
        }
      }
      __clrex();
    }
    while (v6 != -1);
    std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)buf);
  }
  v10 = (unsigned int *)(v4 + 1264);
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 + 1, v10));
  v12 = v11 | 0x100000000;
LABEL_12:
  *(_QWORD *)&v24 = *(_QWORD *)(a1 + 48);
  *((_QWORD *)&v24 + 1) = v12;
  v13 = *a2;
  v14 = a2[1];
  v25 = *a2;
  v26 = v14;
  if (v14)
  {
    v15 = (unint64_t *)(v14 + 8);
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  v17 = **(_QWORD **)(a1 + 8);
  v28 = 0;
  v27 = 1;
  v18 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v17, 40, &v28, &v27);
  if (!v18)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v22 = **(NSObject ***)(v17 + 48);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "CommandQueue.hpp";
      v30 = 1024;
      v31 = 100;
      _os_log_impl(&dword_2164CC000, v22, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v27)
  {
    v19 = **(NSObject ***)(v17 + 48);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "CommandQueue.hpp";
      v30 = 1024;
      v31 = 89;
      v32 = 2048;
      v33 = v28;
      v34 = 2048;
      v35 = 40;
      _os_log_impl(&dword_2164CC000, v19, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *(_QWORD *)v18 = &off_24D57DBA8;
  *(_OWORD *)(v18 + 2) = v24;
  *((_QWORD *)v18 + 3) = v13;
  *((_QWORD *)v18 + 4) = v14;
  v25 = 0;
  v26 = 0;
  Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v17, 40);
  atomic_store(0, (unsigned __int8 *)(v17 + 40));
  return v12;
}

void sub_2165D4860(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, char a15)
{
  uint64_t v15;
  void *v16;
  unint64_t *p_shared_owners;
  unint64_t v19;

  if (a2)
  {
    __cxa_free_exception(v16);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v15);
    __cxa_end_catch();
    if (a12)
    {
      p_shared_owners = (unint64_t *)&a12->__shared_owners_;
      do
        v19 = __ldaxr(p_shared_owners);
      while (__stlxr(v19 - 1, p_shared_owners));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
        std::__shared_weak_count::__release_weak(a12);
      }
    }
    JUMPOUT(0x2165D477CLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_2165D48E0()
{
  uint64_t v0;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v0);
  JUMPOUT(0x2165D4880);
}

void sub_2165D48FC(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x2165D4880);
}

void sub_2165D4BF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, char a15)
{
  uint64_t v15;
  void *v16;
  unint64_t *p_shared_owners;
  unint64_t v19;

  if (a2)
  {
    __cxa_free_exception(v16);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v15);
    __cxa_end_catch();
    if (a12)
    {
      p_shared_owners = (unint64_t *)&a12->__shared_owners_;
      do
        v19 = __ldaxr(p_shared_owners);
      while (__stlxr(v19 - 1, p_shared_owners));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
        std::__shared_weak_count::__release_weak(a12);
      }
    }
    JUMPOUT(0x2165D4B10);
  }
  _Unwind_Resume(exception_object);
}

void sub_2165D4C74()
{
  uint64_t v0;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v0);
  JUMPOUT(0x2165D4C14);
}

void sub_2165D4C90(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x2165D4C14);
}

void sub_2165D4F88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, char a15)
{
  uint64_t v15;
  void *v16;
  unint64_t *p_shared_owners;
  unint64_t v19;

  if (a2)
  {
    __cxa_free_exception(v16);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v15);
    __cxa_end_catch();
    if (a12)
    {
      p_shared_owners = (unint64_t *)&a12->__shared_owners_;
      do
        v19 = __ldaxr(p_shared_owners);
      while (__stlxr(v19 - 1, p_shared_owners));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
        std::__shared_weak_count::__release_weak(a12);
      }
    }
    JUMPOUT(0x2165D4EA4);
  }
  _Unwind_Resume(exception_object);
}

void sub_2165D5008()
{
  uint64_t v0;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v0);
  JUMPOUT(0x2165D4FA8);
}

void sub_2165D5024(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x2165D4FA8);
}

void sub_2165D531C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, char a15)
{
  uint64_t v15;
  void *v16;
  unint64_t *p_shared_owners;
  unint64_t v19;

  if (a2)
  {
    __cxa_free_exception(v16);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v15);
    __cxa_end_catch();
    if (a12)
    {
      p_shared_owners = (unint64_t *)&a12->__shared_owners_;
      do
        v19 = __ldaxr(p_shared_owners);
      while (__stlxr(v19 - 1, p_shared_owners));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
        std::__shared_weak_count::__release_weak(a12);
      }
    }
    JUMPOUT(0x2165D5238);
  }
  _Unwind_Resume(exception_object);
}

void sub_2165D539C()
{
  uint64_t v0;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v0);
  JUMPOUT(0x2165D533CLL);
}

void sub_2165D53B8(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x2165D533CLL);
}

void sub_2165D5608(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  uint64_t v12;
  void *v13;
  unint64_t *p_shared_owners;
  unint64_t v16;

  if (a2)
  {
    __cxa_free_exception(v13);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v12);
    __cxa_end_catch();
    if (a12)
    {
      p_shared_owners = (unint64_t *)&a12->__shared_owners_;
      do
        v16 = __ldaxr(p_shared_owners);
      while (__stlxr(v16 - 1, p_shared_owners));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
        std::__shared_weak_count::__release_weak(a12);
      }
    }
    JUMPOUT(0x2165D5524);
  }
  _Unwind_Resume(exception_object);
}

void sub_2165D5694(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x2165D568CLL);
}

uint64_t Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::AllocateHandle(uint64_t *a1)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int v8;
  uint64_t *v10;
  char v11;
  uint64_t v12;

  v2 = (unsigned int *)a1 + 5;
  v3 = atomic_load((unsigned int *)a1 + 5);
  if (v3 != -1)
  {
    v10 = a1 + 4;
    v11 = 1;
    std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(a1 + 4));
    do
    {
      v4 = v3;
      v5 = *a1;
      v6 = *(_DWORD *)(*a1 + 24 * v3 + 16);
      while (1)
      {
        v3 = __ldaxr(v2);
        if (v3 != v4)
          break;
        if (!__stlxr(v6, v2))
        {
          Phase::Handle64::Set((Phase::Logger *)&v12, v4, *(unsigned int *)(v5 + 24 * v4 + 20));
          std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v10);
          return v12;
        }
      }
      __clrex();
    }
    while (v3 != -1);
    std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v10);
  }
  v7 = (unsigned int *)(a1 + 3);
  do
    v8 = __ldaxr(v7);
  while (__stlxr(v8 + 1, v7));
  return v8 | 0x100000000;
}

void sub_2165D5784(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_2165D5A80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, char a15)
{
  uint64_t v15;
  void *v16;
  unint64_t *p_shared_owners;
  unint64_t v19;

  if (a2)
  {
    __cxa_free_exception(v16);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v15);
    __cxa_end_catch();
    if (a12)
    {
      p_shared_owners = (unint64_t *)&a12->__shared_owners_;
      do
        v19 = __ldaxr(p_shared_owners);
      while (__stlxr(v19 - 1, p_shared_owners));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
        std::__shared_weak_count::__release_weak(a12);
      }
    }
    JUMPOUT(0x2165D599CLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_2165D5B00()
{
  uint64_t v0;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v0);
  JUMPOUT(0x2165D5AA0);
}

void sub_2165D5B1C(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x2165D5AA0);
}

void Phase::Geometry::SystemScheduler::AddShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  const void *v5;
  int64_t v6;
  char *v7;
  uint64_t v8;
  _DWORD *v9;
  NSObject *v10;
  Phase::Logger *InstancePtr;
  NSObject *v12;
  std::runtime_error *exception;
  __int128 v14;
  void *__dst[2];
  uint64_t v16;
  BOOL v17;
  unint64_t v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  unint64_t v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v14 = *(_QWORD *)(a1 + 48);
  *((_QWORD *)&v14 + 1) = a2;
  __dst[1] = 0;
  v16 = 0;
  __dst[0] = 0;
  v5 = *(const void **)a3;
  v4 = *(_QWORD *)(a3 + 8);
  v6 = v4 - *(_QWORD *)a3;
  if (v4 != *(_QWORD *)a3)
  {
    std::vector<Phase::FrequencyBand<float>>::__vallocate[abi:ne180100](__dst, v6 >> 3);
    v7 = (char *)__dst[1];
    memmove(__dst[1], v5, v6);
    __dst[1] = &v7[8 * (v6 >> 3)];
  }
  v8 = **(_QWORD **)(a1 + 8);
  v18 = 0;
  v17 = 1;
  v9 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v8, 48, &v18, &v17);
  if (!v9)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v12 = **(NSObject ***)(v8 + 48);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v20 = "CommandQueue.hpp";
      v21 = 1024;
      v22 = 100;
      _os_log_impl(&dword_2164CC000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v17)
  {
    v10 = **(NSObject ***)(v8 + 48);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v20 = "CommandQueue.hpp";
      v21 = 1024;
      v22 = 89;
      v23 = 2048;
      v24 = v18;
      v25 = 2048;
      v26 = 48;
      _os_log_impl(&dword_2164CC000, v10, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *(_QWORD *)v9 = &off_24D57DBD0;
  *(_OWORD *)(v9 + 2) = v14;
  *(_OWORD *)(v9 + 6) = *(_OWORD *)__dst;
  *((_QWORD *)v9 + 5) = v16;
  __dst[0] = 0;
  __dst[1] = 0;
  v16 = 0;
  Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v8, 48);
  atomic_store(0, (unsigned __int8 *)(v8 + 40));
  if (__dst[0])
  {
    __dst[1] = __dst[0];
    operator delete(__dst[0]);
  }
}

void sub_2165D5D8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  uint64_t v13;
  void *v14;

  if (a2)
  {
    __cxa_free_exception(v14);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v13);
    __cxa_end_catch();
    JUMPOUT(0x2165D5CA0);
  }
  _Unwind_Resume(exception_object);
}

void sub_2165D5DE0()
{
  __cxa_end_catch();
  JUMPOUT(0x2165D5DA4);
}

void sub_2165D5DEC(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x2165D5DB4);
}

uint64_t Phase::Geometry::SystemScheduler::Copy(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Handle;
  uint64_t v7;
  _DWORD *v8;
  NSObject *v9;
  Phase::Logger *InstancePtr;
  NSObject *v12;
  std::runtime_error *exception;
  __int128 v14;
  void *__p;
  _BYTE *v16;
  uint64_t v17;
  BOOL v18;
  unint64_t v19;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  unint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  Handle = Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::AllocateHandle((uint64_t *)(*(_QWORD *)(a1 + 48) + 992));
  *(_QWORD *)&v14 = *(_QWORD *)(a1 + 48);
  *((_QWORD *)&v14 + 1) = a2;
  __p = 0;
  v16 = 0;
  v17 = 0;
  std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(&__p, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
  v7 = **(_QWORD **)(a1 + 8);
  v19 = 0;
  v18 = 1;
  v8 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v7, 56, &v19, &v18);
  if (!v8)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v12 = **(NSObject ***)(v7 + 48);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v21 = "CommandQueue.hpp";
      v22 = 1024;
      v23 = 100;
      _os_log_impl(&dword_2164CC000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v18)
  {
    v9 = **(NSObject ***)(v7 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v21 = "CommandQueue.hpp";
      v22 = 1024;
      v23 = 89;
      v24 = 2048;
      v25 = v19;
      v26 = 2048;
      v27 = 56;
      _os_log_impl(&dword_2164CC000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *(_QWORD *)v8 = &off_24D57DBF8;
  *((_QWORD *)v8 + 3) = Handle;
  *(_OWORD *)(v8 + 2) = v14;
  *((_QWORD *)v8 + 5) = 0;
  *((_QWORD *)v8 + 6) = 0;
  *((_QWORD *)v8 + 4) = 0;
  std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>((_QWORD *)v8 + 4, __p, (uint64_t)v16, (v16 - (_BYTE *)__p) >> 2);
  Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v7, 56);
  atomic_store(0, (unsigned __int8 *)(v7 + 40));
  if (__p)
  {
    v16 = __p;
    operator delete(__p);
  }
  return Handle;
}

void sub_2165D605C(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x2165D5F6CLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_2165D609C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  JUMPOUT(0x2165D6074);
}

void sub_2165D60C0(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x2165D6074);
}

uint64_t Phase::Geometry::SystemScheduler::SetMaterial(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  NSObject *v10;
  uint64_t result;
  Phase::Logger *InstancePtr;
  NSObject *v13;
  std::runtime_error *exception;
  BOOL v15;
  unint64_t v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  unint64_t v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v7 = *(_QWORD *)(a1 + 48);
  v8 = **(_QWORD **)(a1 + 8);
  v16 = 0;
  v15 = 1;
  v9 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v8, 40, &v16, &v15);
  if (!v9)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v13 = **(NSObject ***)(v8 + 48);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v18 = "CommandQueue.hpp";
      v19 = 1024;
      v20 = 100;
      _os_log_impl(&dword_2164CC000, v13, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v15)
  {
    v10 = **(NSObject ***)(v8 + 48);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v18 = "CommandQueue.hpp";
      v19 = 1024;
      v20 = 89;
      v21 = 2048;
      v22 = v16;
      v23 = 2048;
      v24 = 40;
      _os_log_impl(&dword_2164CC000, v10, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *v9 = &off_24D57DC20;
  v9[1] = v7;
  v9[2] = a2;
  v9[3] = a3;
  v9[4] = a4;
  result = Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v8, 40);
  atomic_store(0, (unsigned __int8 *)(v8 + 40));
  return result;
}

void sub_2165D62D0(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x2165D61F0);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Geometry::SystemScheduler::AddChild(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  NSObject *v8;
  uint64_t result;
  Phase::Logger *InstancePtr;
  NSObject *v11;
  std::runtime_error *exception;
  BOOL v13;
  unint64_t v14;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unint64_t v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD *)(a1 + 48);
  v6 = **(_QWORD **)(a1 + 8);
  v14 = 0;
  v13 = 1;
  v7 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v6, 32, &v14, &v13);
  if (!v7)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v11 = **(NSObject ***)(v6 + 48);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v16 = "CommandQueue.hpp";
      v17 = 1024;
      v18 = 100;
      _os_log_impl(&dword_2164CC000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v13)
  {
    v8 = **(NSObject ***)(v6 + 48);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v16 = "CommandQueue.hpp";
      v17 = 1024;
      v18 = 89;
      v19 = 2048;
      v20 = v14;
      v21 = 2048;
      v22 = 32;
      _os_log_impl(&dword_2164CC000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *v7 = &off_24D57DC98;
  v7[1] = v5;
  v7[2] = a2;
  v7[3] = a3;
  result = Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v6, 32);
  atomic_store(0, (unsigned __int8 *)(v6 + 40));
  return result;
}

void sub_2165D6520(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x2165D6444);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Geometry::SystemScheduler::RemoveChild(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  NSObject *v8;
  uint64_t result;
  Phase::Logger *InstancePtr;
  NSObject *v11;
  std::runtime_error *exception;
  BOOL v13;
  unint64_t v14;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unint64_t v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD *)(a1 + 48);
  v6 = **(_QWORD **)(a1 + 8);
  v14 = 0;
  v13 = 1;
  v7 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v6, 32, &v14, &v13);
  if (!v7)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v11 = **(NSObject ***)(v6 + 48);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v16 = "CommandQueue.hpp";
      v17 = 1024;
      v18 = 100;
      _os_log_impl(&dword_2164CC000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v13)
  {
    v8 = **(NSObject ***)(v6 + 48);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v16 = "CommandQueue.hpp";
      v17 = 1024;
      v18 = 89;
      v19 = 2048;
      v20 = v14;
      v21 = 2048;
      v22 = 32;
      _os_log_impl(&dword_2164CC000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *v7 = &off_24D57DCC0;
  v7[1] = v5;
  v7[2] = a2;
  v7[3] = a3;
  result = Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v6, 32);
  atomic_store(0, (unsigned __int8 *)(v6 + 40));
  return result;
}

void sub_2165D6770(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x2165D6694);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Geometry::SystemScheduler::UpdateTransform(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  NSObject *v7;
  uint64_t result;
  Phase::Logger *InstancePtr;
  NSObject *v10;
  std::runtime_error *exception;
  __int128 v12;
  __int128 v13;
  BOOL v14;
  unint64_t v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  unint64_t v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 48);
  v12 = a3[1];
  v13 = *a3;
  v5 = **(_QWORD **)(a1 + 8);
  v15 = 0;
  v14 = 1;
  v6 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v5, 56, &v15, &v14);
  if (!v6)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v10 = **(NSObject ***)(v5 + 48);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v17 = "CommandQueue.hpp";
      v18 = 1024;
      v19 = 100;
      _os_log_impl(&dword_2164CC000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v14)
  {
    v7 = **(NSObject ***)(v5 + 48);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v17 = "CommandQueue.hpp";
      v18 = 1024;
      v19 = 89;
      v20 = 2048;
      v21 = v15;
      v22 = 2048;
      v23 = 56;
      _os_log_impl(&dword_2164CC000, v7, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *(_QWORD *)v6 = &off_24D57DCE8;
  *((_QWORD *)v6 + 1) = v4;
  *((_QWORD *)v6 + 2) = a2;
  *(_OWORD *)(v6 + 6) = v13;
  *(_OWORD *)(v6 + 10) = v12;
  result = Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v5, 56);
  atomic_store(0, (unsigned __int8 *)(v5 + 40));
  return result;
}

void sub_2165D69D4(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x2165D68F8);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Geometry::SystemScheduler::ReleaseDirectivity(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  NSObject *v6;
  uint64_t result;
  Phase::Logger *InstancePtr;
  NSObject *v9;
  std::runtime_error *exception;
  BOOL v11;
  unint64_t v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  unint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 48);
  v4 = **(_QWORD **)(a1 + 8);
  v12 = 0;
  v11 = 1;
  v5 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v4, 24, &v12, &v11);
  if (!v5)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v9 = **(NSObject ***)(v4 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v14 = "CommandQueue.hpp";
      v15 = 1024;
      v16 = 100;
      _os_log_impl(&dword_2164CC000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v11)
  {
    v6 = **(NSObject ***)(v4 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v14 = "CommandQueue.hpp";
      v15 = 1024;
      v16 = 89;
      v17 = 2048;
      v18 = v12;
      v19 = 2048;
      v20 = 24;
      _os_log_impl(&dword_2164CC000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *v5 = &off_24D57DD10;
  v5[1] = v3;
  v5[2] = a2;
  result = Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v4, 24);
  atomic_store(0, (unsigned __int8 *)(v4 + 40));
  return result;
}

void sub_2165D6C20(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x2165D6B44);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Geometry::SystemScheduler::ReleaseDistanceModel(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  NSObject *v6;
  uint64_t result;
  Phase::Logger *InstancePtr;
  NSObject *v9;
  std::runtime_error *exception;
  BOOL v11;
  unint64_t v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  unint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 48);
  v4 = **(_QWORD **)(a1 + 8);
  v12 = 0;
  v11 = 1;
  v5 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v4, 24, &v12, &v11);
  if (!v5)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v9 = **(NSObject ***)(v4 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v14 = "CommandQueue.hpp";
      v15 = 1024;
      v16 = 100;
      _os_log_impl(&dword_2164CC000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v11)
  {
    v6 = **(NSObject ***)(v4 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v14 = "CommandQueue.hpp";
      v15 = 1024;
      v16 = 89;
      v17 = 2048;
      v18 = v12;
      v19 = 2048;
      v20 = 24;
      _os_log_impl(&dword_2164CC000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *v5 = &off_24D57DD38;
  v5[1] = v3;
  v5[2] = a2;
  result = Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v4, 24);
  atomic_store(0, (unsigned __int8 *)(v4 + 40));
  return result;
}

void sub_2165D6E6C(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x2165D6D90);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Geometry::SystemScheduler::ReleaseMedium(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  NSObject *v6;
  uint64_t result;
  Phase::Logger *InstancePtr;
  NSObject *v9;
  std::runtime_error *exception;
  BOOL v11;
  unint64_t v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  unint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 48);
  v4 = **(_QWORD **)(a1 + 8);
  v12 = 0;
  v11 = 1;
  v5 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v4, 24, &v12, &v11);
  if (!v5)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v9 = **(NSObject ***)(v4 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v14 = "CommandQueue.hpp";
      v15 = 1024;
      v16 = 100;
      _os_log_impl(&dword_2164CC000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v11)
  {
    v6 = **(NSObject ***)(v4 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v14 = "CommandQueue.hpp";
      v15 = 1024;
      v16 = 89;
      v17 = 2048;
      v18 = v12;
      v19 = 2048;
      v20 = 24;
      _os_log_impl(&dword_2164CC000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *v5 = &off_24D57DD60;
  v5[1] = v3;
  v5[2] = a2;
  result = Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v4, 24);
  atomic_store(0, (unsigned __int8 *)(v4 + 40));
  return result;
}

void sub_2165D70B8(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x2165D6FDCLL);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Geometry::SystemScheduler::ReleaseMaterial(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  NSObject *v6;
  uint64_t result;
  Phase::Logger *InstancePtr;
  NSObject *v9;
  std::runtime_error *exception;
  BOOL v11;
  unint64_t v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  unint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 48);
  v4 = **(_QWORD **)(a1 + 8);
  v12 = 0;
  v11 = 1;
  v5 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v4, 24, &v12, &v11);
  if (!v5)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v9 = **(NSObject ***)(v4 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v14 = "CommandQueue.hpp";
      v15 = 1024;
      v16 = 100;
      _os_log_impl(&dword_2164CC000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v11)
  {
    v6 = **(NSObject ***)(v4 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v14 = "CommandQueue.hpp";
      v15 = 1024;
      v16 = 89;
      v17 = 2048;
      v18 = v12;
      v19 = 2048;
      v20 = 24;
      _os_log_impl(&dword_2164CC000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *v5 = &off_24D57DD88;
  v5[1] = v3;
  v5[2] = a2;
  result = Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v4, 24);
  atomic_store(0, (unsigned __int8 *)(v4 + 40));
  return result;
}

void sub_2165D7304(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x2165D7228);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Geometry::SystemScheduler::ReleaseShape(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  NSObject *v6;
  uint64_t result;
  Phase::Logger *InstancePtr;
  NSObject *v9;
  std::runtime_error *exception;
  BOOL v11;
  unint64_t v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  unint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 48);
  v4 = **(_QWORD **)(a1 + 8);
  v12 = 0;
  v11 = 1;
  v5 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v4, 24, &v12, &v11);
  if (!v5)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v9 = **(NSObject ***)(v4 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v14 = "CommandQueue.hpp";
      v15 = 1024;
      v16 = 100;
      _os_log_impl(&dword_2164CC000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v11)
  {
    v6 = **(NSObject ***)(v4 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v14 = "CommandQueue.hpp";
      v15 = 1024;
      v16 = 89;
      v17 = 2048;
      v18 = v12;
      v19 = 2048;
      v20 = 24;
      _os_log_impl(&dword_2164CC000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *v5 = &off_24D57DDB0;
  v5[1] = v3;
  v5[2] = a2;
  result = Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v4, 24);
  atomic_store(0, (unsigned __int8 *)(v4 + 40));
  return result;
}

void sub_2165D7550(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x2165D7474);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Geometry::SystemScheduler::ReleaseEntity(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  NSObject *v6;
  uint64_t result;
  Phase::Logger *InstancePtr;
  NSObject *v9;
  std::runtime_error *exception;
  BOOL v11;
  unint64_t v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  unint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 48);
  v4 = **(_QWORD **)(a1 + 8);
  v12 = 0;
  v11 = 1;
  v5 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v4, 24, &v12, &v11);
  if (!v5)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v9 = **(NSObject ***)(v4 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v14 = "CommandQueue.hpp";
      v15 = 1024;
      v16 = 100;
      _os_log_impl(&dword_2164CC000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v11)
  {
    v6 = **(NSObject ***)(v4 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v14 = "CommandQueue.hpp";
      v15 = 1024;
      v16 = 89;
      v17 = 2048;
      v18 = v12;
      v19 = 2048;
      v20 = 24;
      _os_log_impl(&dword_2164CC000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *v5 = &off_24D57DDD8;
  v5[1] = v3;
  v5[2] = a2;
  result = Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v4, 24);
  atomic_store(0, (unsigned __int8 *)(v4 + 40));
  return result;
}

void sub_2165D779C(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x2165D76C0);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *Phase::Geometry::SystemScheduler::RunFunction(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  NSObject *v6;
  uint64_t v7;
  _QWORD *result;
  uint64_t v9;
  Phase::Logger *InstancePtr;
  NSObject *v11;
  std::runtime_error *exception;
  BOOL v13;
  unint64_t v14;
  _QWORD v15[3];
  _QWORD *v16;
  uint64_t v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  unint64_t v23;
  __int16 v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v3 = (_QWORD *)a2[3];
  if (v3)
  {
    if (v3 == a2)
    {
      v16 = v15;
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v15);
    }
    else
    {
      v16 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v3 + 16))(v3);
    }
  }
  else
  {
    v16 = 0;
  }
  v17 = a1;
  v4 = **(_QWORD **)(a1 + 8);
  v14 = 0;
  v13 = 1;
  v5 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v4, 48, &v14, &v13);
  if (!v5)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v11 = **(NSObject ***)(v4 + 48);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v19 = "CommandQueue.hpp";
      v20 = 1024;
      v21 = 100;
      _os_log_impl(&dword_2164CC000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v13)
  {
    v6 = **(NSObject ***)(v4 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v19 = "CommandQueue.hpp";
      v20 = 1024;
      v21 = 89;
      v22 = 2048;
      v23 = v14;
      v24 = 2048;
      v25 = 48;
      _os_log_impl(&dword_2164CC000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *v5 = &off_24D57DE00;
  v7 = (uint64_t)v16;
  if (!v16)
    goto LABEL_13;
  if (v16 != v15)
  {
    v7 = (*(uint64_t (**)(void))(*v16 + 16))();
LABEL_13:
    v5[4] = v7;
    goto LABEL_15;
  }
  v5[4] = v5 + 1;
  (*(void (**)(_QWORD *))(v15[0] + 24))(v15);
LABEL_15:
  v5[5] = v17;
  Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v4, 48);
  atomic_store(0, (unsigned __int8 *)(v4 + 40));
  result = v16;
  if (v16 == v15)
  {
    v9 = 4;
    result = v15;
  }
  else
  {
    if (!v16)
      return result;
    v9 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v9))();
}

void sub_2165D7A9C(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x2165D7994);
  }
  _Unwind_Resume(exception_object);
}

void sub_2165D7ADC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char *a15)
{
  char *v15;
  uint64_t v16;

  v15 = a15;
  if (a15 == &a12)
  {
    v16 = 4;
    v15 = &a12;
  }
  else
  {
    if (!a15)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  JUMPOUT(0x2165D7AB4);
}

void sub_2165D7B20(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x2165D7AB4);
}

uint64_t Phase::Geometry::SystemScheduler::RunDebugFunction(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  Phase::Logger *InstancePtr;
  NSObject *v12;
  std::runtime_error *exception;
  BOOL v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD v17[3];
  _QWORD *v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  unint64_t v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v16 = a1;
  v3 = v17;
  v4 = (_QWORD *)a2[3];
  if (v4)
  {
    if (v4 == a2)
    {
      v18 = v17;
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v17);
    }
    else
    {
      v18 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v4 + 16))(v4);
    }
  }
  else
  {
    v18 = 0;
  }
  v5 = **(_QWORD **)(a1 + 8);
  v15 = 0;
  v14 = 1;
  v6 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v5, 48, &v15, &v14);
  if (!v6)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v12 = **(NSObject ***)(v5 + 48);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v20 = "CommandQueue.hpp";
      v21 = 1024;
      v22 = 100;
      _os_log_impl(&dword_2164CC000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v14)
  {
    v7 = **(NSObject ***)(v5 + 48);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v20 = "CommandQueue.hpp";
      v21 = 1024;
      v22 = 89;
      v23 = 2048;
      v24 = v15;
      v25 = 2048;
      v26 = 48;
      _os_log_impl(&dword_2164CC000, v7, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *v6 = &off_24D57DE28;
  v6[1] = v16;
  v8 = (uint64_t)v18;
  if (!v18)
    goto LABEL_13;
  if (v18 != v17)
  {
    v8 = (*(uint64_t (**)(void))(*v18 + 16))();
LABEL_13:
    v6[5] = v8;
    goto LABEL_15;
  }
  v6[5] = v6 + 2;
  (*(void (**)(_QWORD *))(v17[0] + 24))(v17);
LABEL_15:
  result = Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v5, 48);
  atomic_store(0, (unsigned __int8 *)(v5 + 40));
  if (v18 == v17)
  {
    v10 = 4;
  }
  else
  {
    if (!v18)
      return result;
    v10 = 5;
    v3 = v18;
  }
  return (*(uint64_t (**)(_QWORD *))(*v3 + 8 * v10))(v3);
}

void sub_2165D7DD4(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x2165D7CC8);
  }
  _Unwind_Resume(exception_object);
}

void sub_2165D7E14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, _QWORD *a16)
{
  _QWORD *v16;
  uint64_t v17;

  if (a16 == v16)
  {
    v17 = 4;
  }
  else
  {
    if (!a16)
      goto LABEL_6;
    v17 = 5;
    v16 = a16;
  }
  (*(void (**)(_QWORD *))(*v16 + 8 * v17))(v16);
LABEL_6:
  JUMPOUT(0x2165D7DECLL);
}

void sub_2165D7E58(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x2165D7DECLL);
}

_QWORD *Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::Directivity> &)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  *a1 = &off_24D57DAE0;
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 3));
  return a1;
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::Directivity> &)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  *a1 = &off_24D57DAE0;
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 3));
  JUMPOUT(0x2199F9D70);
}

uint64_t Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::Directivity> &)::$_0,void>::operator()(uint64_t a1)
{
  __int128 *v2;
  uint64_t v3;
  uint64_t result;

  v2 = (__int128 *)(a1 + 24);
  v3 = *(_QWORD *)(a1 + 24);
  result = Phase::details::SharedSlotMap<Phase::Geometry::Directivity,Phase::Handle64>::GetUniqueSlot(*(__int128 **)(a1 + 8), *(_QWORD *)(a1 + 16));
  if (result)
    result = std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100](result, v2);
  __dmb(0xBu);
  *(_QWORD *)(v3 + 8) = *(_QWORD *)(a1 + 16);
  return result;
}

uint64_t Phase::details::SharedSlotMap<Phase::Geometry::Directivity,Phase::Handle64>::GetUniqueSlot(__int128 *a1, uint64_t a2)
{
  unint64_t v3;
  unsigned int v5;
  uint64_t result;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  __int128 v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  __int128 *v16;
  char v17;
  __int128 v18;

  v3 = *((unsigned int *)a1 + 4);
  if (v3 <= a2)
    return 0;
  v5 = a2;
  result = *(_QWORD *)a1 + 24 * a2;
  if (*(_DWORD *)(result + 20) != HIDWORD(a2))
    return 0;
  v7 = *((_QWORD *)a1 + 1);
  if (v7 && *(uint64_t *)(v7 + 8) >= 1)
  {
    Phase::details::SharedSlotMap<Phase::Geometry::Directivity,Phase::Handle64>::AllocSlots(v3, &v18);
    if (*((_DWORD *)a1 + 4))
    {
      v8 = 0;
      v9 = 16;
      do
      {
        v10 = (_QWORD *)(*(_QWORD *)a1 + v9);
        v11 = (_QWORD *)(v18 + v9);
        std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(v18 + v9 - 16), v10 - 2);
        *v11 = *v10;
        ++v8;
        v9 += 24;
      }
      while (v8 < *((unsigned int *)a1 + 4));
    }
    v16 = a1 + 2;
    v17 = 1;
    std::__shared_mutex_base::lock((std::__shared_mutex_base *)(a1 + 2));
    v12 = *a1;
    *a1 = v18;
    v18 = v12;
    std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v16);
    v13 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
    if (*((_QWORD *)&v18 + 1))
    {
      v14 = (unint64_t *)(*((_QWORD *)&v18 + 1) + 8);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    return *(_QWORD *)a1 + 24 * v5;
  }
  return result;
}

void sub_2165D8068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::DistanceModel> &)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  *a1 = &off_24D57DB08;
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 3));
  return a1;
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::DistanceModel> &)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  *a1 = &off_24D57DB08;
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 3));
  JUMPOUT(0x2199F9D70);
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::DistanceModel> &)::$_0,void>::operator()(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t UniqueSlot;
  __int128 v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  v2 = a1 + 3;
  v3 = a1[3];
  UniqueSlot = Phase::details::SharedSlotMap<Phase::Geometry::DistanceModel,Phase::Handle64>::GetUniqueSlot((__int128 *)(a1[1] + 248), a1[2]);
  if (UniqueSlot)
  {
    v5 = *(_OWORD *)v2;
    *v2 = 0;
    v2[1] = 0;
    v6 = *(std::__shared_weak_count **)(UniqueSlot + 8);
    *(_OWORD *)UniqueSlot = v5;
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  __dmb(0xBu);
  *(_QWORD *)(v3 + 8) = a1[2];
}

uint64_t Phase::details::SharedSlotMap<Phase::Geometry::DistanceModel,Phase::Handle64>::GetUniqueSlot(__int128 *a1, uint64_t a2)
{
  unint64_t v3;
  unsigned int v5;
  uint64_t result;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  __int128 v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  __int128 *v16;
  char v17;
  __int128 v18;

  v3 = *((unsigned int *)a1 + 4);
  if (v3 <= a2)
    return 0;
  v5 = a2;
  result = *(_QWORD *)a1 + 24 * a2;
  if (*(_DWORD *)(result + 20) != HIDWORD(a2))
    return 0;
  v7 = *((_QWORD *)a1 + 1);
  if (v7 && *(uint64_t *)(v7 + 8) >= 1)
  {
    Phase::details::SharedSlotMap<Phase::Geometry::DistanceModel,Phase::Handle64>::AllocSlots(v3, &v18);
    if (*((_DWORD *)a1 + 4))
    {
      v8 = 0;
      v9 = 16;
      do
      {
        v10 = (_QWORD *)(*(_QWORD *)a1 + v9);
        v11 = (_QWORD *)(v18 + v9);
        std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(v18 + v9 - 16), v10 - 2);
        *v11 = *v10;
        ++v8;
        v9 += 24;
      }
      while (v8 < *((unsigned int *)a1 + 4));
    }
    v16 = a1 + 2;
    v17 = 1;
    std::__shared_mutex_base::lock((std::__shared_mutex_base *)(a1 + 2));
    v12 = *a1;
    *a1 = v18;
    v18 = v12;
    std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v16);
    v13 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
    if (*((_QWORD *)&v18 + 1))
    {
      v14 = (unint64_t *)(*((_QWORD *)&v18 + 1) + 8);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    return *(_QWORD *)a1 + 24 * v5;
  }
  return result;
}

void sub_2165D82BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::Material> &)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  *a1 = &off_24D57DB30;
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 3));
  return a1;
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::Material> &)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  *a1 = &off_24D57DB30;
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 3));
  JUMPOUT(0x2199F9D70);
}

uint64_t Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::Material> &)::$_0,void>::operator()(_QWORD *a1)
{
  __int128 *v2;
  uint64_t v3;
  uint64_t result;

  v2 = (__int128 *)(a1 + 3);
  v3 = a1[3];
  result = Phase::details::SharedSlotMap<Phase::Geometry::Material,Phase::Handle64>::GetUniqueSlot(a1[1] + 744, a1[2]);
  if (result)
    result = std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100](result, v2);
  __dmb(0xBu);
  *(_QWORD *)(v3 + 8) = a1[2];
  return result;
}

_QWORD *Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::Medium> &)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  *a1 = &off_24D57DB58;
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 3));
  return a1;
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::Medium> &)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  *a1 = &off_24D57DB58;
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 3));
  JUMPOUT(0x2199F9D70);
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::Medium> &)::$_0,void>::operator()(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t UniqueSlot;
  __int128 v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  v2 = a1 + 3;
  v3 = a1[3];
  UniqueSlot = Phase::details::SharedSlotMap<Phase::Geometry::Medium,Phase::Handle64>::GetUniqueSlot((__int128 *)(a1[1] + 504), a1[2]);
  if (UniqueSlot)
  {
    v5 = *(_OWORD *)v2;
    *v2 = 0;
    v2[1] = 0;
    v6 = *(std::__shared_weak_count **)(UniqueSlot + 8);
    *(_OWORD *)UniqueSlot = v5;
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  __dmb(0xBu);
  *(_QWORD *)(v3 + 8) = a1[2];
}

uint64_t Phase::details::SharedSlotMap<Phase::Geometry::Medium,Phase::Handle64>::GetUniqueSlot(__int128 *a1, uint64_t a2)
{
  unint64_t v3;
  unsigned int v5;
  uint64_t result;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  __int128 v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  __int128 *v16;
  char v17;
  __int128 v18;

  v3 = *((unsigned int *)a1 + 4);
  if (v3 <= a2)
    return 0;
  v5 = a2;
  result = *(_QWORD *)a1 + 24 * a2;
  if (*(_DWORD *)(result + 20) != HIDWORD(a2))
    return 0;
  v7 = *((_QWORD *)a1 + 1);
  if (v7 && *(uint64_t *)(v7 + 8) >= 1)
  {
    Phase::details::SharedSlotMap<Phase::Geometry::Medium,Phase::Handle64>::AllocSlots(v3, &v18);
    if (*((_DWORD *)a1 + 4))
    {
      v8 = 0;
      v9 = 16;
      do
      {
        v10 = (_QWORD *)(*(_QWORD *)a1 + v9);
        v11 = (_QWORD *)(v18 + v9);
        std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(v18 + v9 - 16), v10 - 2);
        *v11 = *v10;
        ++v8;
        v9 += 24;
      }
      while (v8 < *((unsigned int *)a1 + 4));
    }
    v16 = a1 + 2;
    v17 = 1;
    std::__shared_mutex_base::lock((std::__shared_mutex_base *)(a1 + 2));
    v12 = *a1;
    *a1 = v18;
    v18 = v12;
    std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v16);
    v13 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
    if (*((_QWORD *)&v18 + 1))
    {
      v14 = (unint64_t *)(*((_QWORD *)&v18 + 1) + 8);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    return *(_QWORD *)a1 + 24 * v5;
  }
  return result;
}

void sub_2165D85D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::Shape> &)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  *a1 = &off_24D57DB80;
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 3));
  return a1;
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::Shape> &)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  *a1 = &off_24D57DB80;
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 3));
  JUMPOUT(0x2199F9D70);
}

uint64_t Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::Shape> &)::$_0,void>::operator()(_QWORD *a1)
{
  __int128 *v2;
  uint64_t v3;
  uint64_t result;

  v2 = (__int128 *)(a1 + 3);
  v3 = a1[3];
  result = Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::GetUniqueSlot(a1[1] + 992, a1[2]);
  if (result)
    result = std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100](result, v2);
  __dmb(0xBu);
  *(_QWORD *)(v3 + 8) = a1[2];
  return result;
}

_QWORD *Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::Entity> &)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  *a1 = &off_24D57DBA8;
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 3));
  return a1;
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::Entity> &)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  *a1 = &off_24D57DBA8;
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)(a1 + 3));
  JUMPOUT(0x2199F9D70);
}

uint64_t Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddToDatabase(std::shared_ptr<Phase::Geometry::Entity> &)::$_0,void>::operator()(_QWORD *a1)
{
  __int128 *v2;
  uint64_t v3;
  uint64_t result;

  v2 = (__int128 *)(a1 + 3);
  v3 = a1[3];
  result = Phase::details::SharedSlotMap<Phase::Geometry::Entity,Phase::Handle64>::GetUniqueSlot(a1[1] + 1240, a1[2]);
  if (result)
    result = std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100](result, v2);
  __dmb(0xBu);
  *(_QWORD *)(v3 + 8) = a1[2];
  return result;
}

_QWORD *Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddShapes(Phase::Handle64,std::vector<Phase::Handle64> const&)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D57DBD0;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddShapes(Phase::Handle64,std::vector<Phase::Handle64> const&)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D57DBD0;
  v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199F9D70);
}

_QWORD **Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddShapes(Phase::Handle64,std::vector<Phase::Handle64> const&)::$_0,void>::operator()(_QWORD *a1)
{
  uint64_t v2;
  _QWORD **result;
  _QWORD *v4;
  uint64_t *i;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = a1[2];
  v10 = a1[1] + 1240;
  result = (_QWORD **)_ZN5Phase7details13SharedSlotMapINS_8Geometry6EntityENS_8Handle64EE13GetSlotToEditIRZNS_13SharedSlotMapIS3_S4_NS2_13EntityFactoryEE9GetUniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA_(v10, v2, (uint64_t)&v10);
  if (result)
  {
    v4 = *result;
    if (*result)
    {
      v6 = (uint64_t *)a1[3];
      for (i = (uint64_t *)a1[4]; v6 != i; ++v6)
      {
        v7 = a1[1];
        v8 = *v6;
        if (*(_DWORD *)(v7 + 1008) > *v6)
        {
          v9 = *(_QWORD *)(v7 + 992);
          if (*(_DWORD *)(v9 + 24 * v8 + 20) == HIDWORD(v8))
          {
            if (*(_QWORD *)(v9 + 24 * *v6))
            {
              result = (_QWORD **)Phase::Geometry::Entity::AddShape(v4, v8);
              i = (uint64_t *)a1[4];
            }
          }
        }
      }
    }
  }
  return result;
}

_QWORD *Phase::LambdaFunction<Phase::Geometry::SystemScheduler::Copy(Phase::Handle64,std::vector<unsigned int> const&)::$_0 const,void>::~LambdaFunction(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D57DBF8;
  v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  return a1;
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::Copy(Phase::Handle64,std::vector<unsigned int> const&)::$_0 const,void>::~LambdaFunction(_QWORD *a1)
{
  void *v2;

  *a1 = &off_24D57DBF8;
  v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2199F9D70);
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::Copy(Phase::Handle64,std::vector<unsigned int> const&)::$_0 const,void>::operator()(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  unsigned int *v5;
  _QWORD *UniqueSlot;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  _OWORD v17[2];
  int v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  v4 = (_QWORD *)(v3 + 992);
  if (*(_DWORD *)(v3 + 1008) > v2 && *(_DWORD *)(*v4 + 24 * v2 + 20) == HIDWORD(v2))
  {
    v5 = *(unsigned int **)(*v4 + 24 * v2);
    if (v5)
    {
      memset(v17, 0, sizeof(v17));
      v18 = 1065353216;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(&v19, *(const void **)(a1 + 32), *(_QWORD *)(a1 + 40), (uint64_t)(*(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32)) >> 2);
      v22 = 9;
      Phase::UnorderedStringMap<Phase::OptionsValue>::Set((uint64_t)v17, (uint64_t)&Phase::Geometry::ShapeOptions::ForcedCopyTags, (uint64_t)&v19);
      std::__variant_detail::__dtor<std::__variant_detail::__traits<BOOL,int,unsigned int,float,double,Phase::Vector<float,2ul>,Phase::Vector<float,3ul>,Phase::Vector<float,4ul>,std::string,std::vector<unsigned int>,std::vector<unsigned long long>,Phase::UnorderedStringMap<Phase::OptionsValue>>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)&v19);
      Phase::Geometry::ShapeFactory::Create(*(_QWORD *)(a1 + 8) + 1200, v5, &v19);
      UniqueSlot = (_QWORD *)Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::GetUniqueSlot(*(_QWORD *)(a1 + 8) + 992, *(_QWORD *)(a1 + 24));
      if (UniqueSlot)
        std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100](UniqueSlot, &v19);
      *(_QWORD *)(v19 + 8) = *(_QWORD *)(a1 + 24);
      v7 = v20;
      if (v20)
      {
        p_shared_owners = (unint64_t *)&v20->__shared_owners_;
        do
          v9 = __ldaxr(p_shared_owners);
        while (__stlxr(v9 - 1, p_shared_owners));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table((uint64_t)v17);
      return;
    }
  }
  v10 = Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::GetUniqueSlot((uint64_t)v4, v2);
  if (!v10)
    return;
  v11 = v10;
  ++*(_DWORD *)(v10 + 20);
  std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)v10);
  v12 = (unsigned int *)(v3 + 1012);
  v13 = atomic_load((unsigned int *)(v3 + 1012));
  *(_DWORD *)(v11 + 16) = v13;
  v14 = __ldaxr((unsigned int *)(v3 + 1012));
  if (v14 != v13)
  {
    __clrex();
LABEL_17:
    while (1)
    {
      *(_DWORD *)(v11 + 16) = v14;
      v15 = __ldaxr(v12);
      if (v15 != v14)
        break;
      if (__stlxr(v2, v12))
        goto LABEL_21;
      v16 = 1;
LABEL_22:
      v14 = v15;
      if (v16)
        return;
    }
    __clrex();
LABEL_21:
    v16 = 0;
    goto LABEL_22;
  }
  if (__stlxr(v2, v12))
    goto LABEL_17;
}

void sub_2165D8B20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;

  v16 = a15;
  if (a15)
  {
    p_shared_owners = (unint64_t *)&a15->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::SetMaterial(Phase::Handle64,unsigned long,Phase::Handle64)::$_0 const,void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::SetMaterial(Phase::Handle64,unsigned long,Phase::Handle64)::$_0 const,void>::operator()(_QWORD *a1)
{
  uint64_t v2;
  uint64_t UniqueSlot;
  unsigned int **v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  __int128 v13;

  v2 = a1[1];
  UniqueSlot = Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::GetUniqueSlot(v2 + 992, a1[2]);
  if (UniqueSlot)
  {
    v4 = (unsigned int **)UniqueSlot;
    v5 = *(_QWORD *)(UniqueSlot + 8);
    if (v5 && *(uint64_t *)(v5 + 8) >= 1)
    {
      v6 = *(_QWORD *)(v2 + 1192);
      if (!v6)
        std::terminate();
      v7 = *v4;
      Phase::Geometry::ShapeFactory::Create(v6, *v4, &v13);
      if ((_QWORD)v13)
        *(_QWORD *)(v13 + 8) = *((_QWORD *)v7 + 1);
      std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100]((uint64_t)v4, &v13);
      v8 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
      if (*((_QWORD *)&v13 + 1))
      {
        v9 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
        do
          v10 = __ldaxr(v9);
        while (__stlxr(v10 - 1, v9));
        if (!v10)
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
    }
    if (*v4)
    {
      v11 = a1[3];
      v12 = *(_QWORD **)(**((_QWORD **)*v4 + 18) + 16 * *((_QWORD *)*v4 + 19));
      if (v12[3] > v11)
        *(_QWORD *)(v12[1] + v12[4] * v11) = a1[4];
    }
  }
}

uint64_t Phase::Commandable<128,Phase::LockFreeQueueMPSC>::CallAsync<Phase::Geometry::SystemExecutor,void,Phase::Handle64>(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  _QWORD *v10;
  NSObject *v11;
  NSObject *v13;
  std::logic_error *exception;
  Phase::Logger *InstancePtr;
  NSObject *v16;
  std::runtime_error *v17;
  BOOL v18;
  unint64_t v19;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  unint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)(a1 + 16) <= (signed int)a2)
  {
    v13 = **(NSObject ***)(a1 + 24);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v21 = "Commandable.hpp";
      v22 = 1024;
      v23 = 132;
      _os_log_impl(&dword_2164CC000, v13, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: pQueueId >= 0 && pQueueId < mQueueCount is false.", buf, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::domain_error::domain_error[abi:ne180100](exception, "PRECONDITION: pQueueId >= 0 && pQueueId < mQueueCount is false.");
  }
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
  v19 = 0;
  v18 = 1;
  v10 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v9, 40, &v19, &v18);
  if (!v10)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v16 = **(NSObject ***)(v9 + 48);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v21 = "CommandQueue.hpp";
      v22 = 1024;
      v23 = 100;
      _os_log_impl(&dword_2164CC000, v16, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    v17 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v17, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v18)
  {
    v11 = **(NSObject ***)(v9 + 48);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v21 = "CommandQueue.hpp";
      v22 = 1024;
      v23 = 89;
      v24 = 2048;
      v25 = v19;
      v26 = 2048;
      v27 = 40;
      _os_log_impl(&dword_2164CC000, v11, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *v10 = &off_24D57DC48;
  v10[1] = a1;
  v10[2] = a3;
  v10[3] = a4;
  v10[4] = a5;
  Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v9, 40);
  atomic_store(0, (unsigned __int8 *)(v9 + 40));
  return 1;
}

void sub_2165D8F4C(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x2165D8DD4);
  }
  _Unwind_Resume(exception_object);
}

void Phase::LambdaFunction<BOOL Phase::Commandable<128,Phase::LockFreeQueueMPSC>::CallAsync<Phase::Geometry::SystemExecutor,void,Phase::Handle64>(int,void (Phase::Geometry::SystemExecutor::*)(Phase::Handle64),Phase::Handle64)::{lambda(void)#1},void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

uint64_t Phase::LambdaFunction<BOOL Phase::Commandable<128,Phase::LockFreeQueueMPSC>::CallAsync<Phase::Geometry::SystemExecutor,void,Phase::Handle64>(int,void (Phase::Geometry::SystemExecutor::*)(Phase::Handle64),Phase::Handle64)::{lambda(void)#1},void>::operator()(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *, _QWORD);
  uint64_t v2;
  _QWORD *v3;

  v1 = (uint64_t (*)(_QWORD *, _QWORD))a1[2];
  v2 = a1[3];
  v3 = (_QWORD *)(a1[1] + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *, _QWORD))(*v3 + v1);
  return v1(v3, a1[4]);
}

uint64_t Phase::Commandable<128,Phase::LockFreeQueueMPSC>::CallAsync<Phase::Geometry::SystemExecutor,void,unsigned long long>(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  _QWORD *v10;
  NSObject *v11;
  NSObject *v13;
  std::logic_error *exception;
  Phase::Logger *InstancePtr;
  NSObject *v16;
  std::runtime_error *v17;
  BOOL v18;
  unint64_t v19;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  unint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)(a1 + 16) <= (signed int)a2)
  {
    v13 = **(NSObject ***)(a1 + 24);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v21 = "Commandable.hpp";
      v22 = 1024;
      v23 = 132;
      _os_log_impl(&dword_2164CC000, v13, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: pQueueId >= 0 && pQueueId < mQueueCount is false.", buf, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::domain_error::domain_error[abi:ne180100](exception, "PRECONDITION: pQueueId >= 0 && pQueueId < mQueueCount is false.");
  }
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
  v19 = 0;
  v18 = 1;
  v10 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v9, 40, &v19, &v18);
  if (!v10)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v16 = **(NSObject ***)(v9 + 48);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v21 = "CommandQueue.hpp";
      v22 = 1024;
      v23 = 100;
      _os_log_impl(&dword_2164CC000, v16, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    v17 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v17, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v18)
  {
    v11 = **(NSObject ***)(v9 + 48);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v21 = "CommandQueue.hpp";
      v22 = 1024;
      v23 = 89;
      v24 = 2048;
      v25 = v19;
      v26 = 2048;
      v27 = 40;
      _os_log_impl(&dword_2164CC000, v11, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *v10 = &off_24D57DC70;
  v10[1] = a1;
  v10[2] = a3;
  v10[3] = a4;
  v10[4] = a5;
  Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v9, 40);
  atomic_store(0, (unsigned __int8 *)(v9 + 40));
  return 1;
}

void sub_2165D92A0(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x2165D9128);
  }
  _Unwind_Resume(exception_object);
}

void Phase::LambdaFunction<BOOL Phase::Commandable<128,Phase::LockFreeQueueMPSC>::CallAsync<Phase::Geometry::SystemExecutor,void,unsigned long long>(int,void (Phase::Geometry::SystemExecutor::*)(unsigned long long),unsigned long long)::{lambda(void)#1},void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

uint64_t Phase::LambdaFunction<BOOL Phase::Commandable<128,Phase::LockFreeQueueMPSC>::CallAsync<Phase::Geometry::SystemExecutor,void,unsigned long long>(int,void (Phase::Geometry::SystemExecutor::*)(unsigned long long),unsigned long long)::{lambda(void)#1},void>::operator()(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *, _QWORD);
  uint64_t v2;
  _QWORD *v3;

  v1 = (uint64_t (*)(_QWORD *, _QWORD))a1[2];
  v2 = a1[3];
  v3 = (_QWORD *)(a1[1] + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *, _QWORD))(*v3 + v1);
  return v1(v3, a1[4]);
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddChild(Phase::Handle64,Phase::Handle64)::$_0 const,void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

uint64_t Phase::LambdaFunction<Phase::Geometry::SystemScheduler::AddChild(Phase::Handle64,Phase::Handle64)::$_0 const,void>::operator()(_QWORD *a1)
{
  uint64_t v2;
  _QWORD **UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA;
  _QWORD *v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  _QWORD **v9;
  _QWORD *v10;
  uint64_t v11;

  v2 = a1[2];
  v11 = a1[1] + 1240;
  UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA = (_QWORD **)_ZN5Phase7details13SharedSlotMapINS_8Geometry6EntityENS_8Handle64EE13GetSlotToEditIRZNS_13SharedSlotMapIS3_S4_NS2_13EntityFactoryEE9GetUniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA_(v11, v2, (uint64_t)&v11);
  if (UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA)
    v4 = *UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA;
  else
    v4 = 0;
  v5 = a1[3];
  v11 = a1[1] + 1240;
  result = _ZN5Phase7details13SharedSlotMapINS_8Geometry6EntityENS_8Handle64EE13GetSlotToEditIRZNS_13SharedSlotMapIS3_S4_NS2_13EntityFactoryEE9GetUniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA_(v11, v5, (uint64_t)&v11);
  if (result)
  {
    if (v4)
    {
      v7 = *(_QWORD *)result;
      if (*(_QWORD *)result)
      {
        v8 = *(_QWORD *)(v7 + 88);
        if (v8)
        {
          v11 = a1[1] + 1240;
          v9 = (_QWORD **)_ZN5Phase7details13SharedSlotMapINS_8Geometry6EntityENS_8Handle64EE13GetSlotToEditIRZNS_13SharedSlotMapIS3_S4_NS2_13EntityFactoryEE9GetUniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA_(v11, v8, (uint64_t)&v11);
          if (v9 && (v10 = *v9) != 0)
            Phase::Geometry::Entity::RemoveChild(v10, v7);
          else
            *(_QWORD *)(v7 + 88) = 0;
          result = Phase::Geometry::Entity::AddChild(v4, v7);
          if ((result & 1) != 0)
            *(_QWORD *)(a1[1] + 2272) = -1;
        }
        else
        {
          result = Phase::Geometry::Entity::AddChild(v4, v7);
          if ((result & 1) != 0)
            *(_QWORD *)(a1[1] + 2256) = -1;
        }
      }
    }
  }
  return result;
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::RemoveChild(Phase::Handle64,Phase::Handle64)::$_0 const,void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

uint64_t *Phase::LambdaFunction<Phase::Geometry::SystemScheduler::RemoveChild(Phase::Handle64,Phase::Handle64)::$_0 const,void>::operator()(_QWORD *a1)
{
  uint64_t v2;
  _QWORD **UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA;
  _QWORD *v4;
  uint64_t v5;
  uint64_t *result;
  uint64_t v7;

  v2 = a1[2];
  v7 = a1[1] + 1240;
  UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA = (_QWORD **)_ZN5Phase7details13SharedSlotMapINS_8Geometry6EntityENS_8Handle64EE13GetSlotToEditIRZNS_13SharedSlotMapIS3_S4_NS2_13EntityFactoryEE9GetUniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA_(v7, v2, (uint64_t)&v7);
  if (UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA)
    v4 = *UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA;
  else
    v4 = 0;
  v5 = a1[3];
  v7 = a1[1] + 1240;
  result = (uint64_t *)_ZN5Phase7details13SharedSlotMapINS_8Geometry6EntityENS_8Handle64EE13GetSlotToEditIRZNS_13SharedSlotMapIS3_S4_NS2_13EntityFactoryEE9GetUniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA_(v7, v5, (uint64_t)&v7);
  if (result && v4 && *result)
  {
    result = (uint64_t *)Phase::Geometry::Entity::RemoveChild(v4, *result);
    if ((_DWORD)result)
      *(_QWORD *)(a1[1] + 2264) = -1;
  }
  return result;
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::UpdateTransform(Phase::Handle64,Phase::Affine<float> const&)::$_0 const,void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

float Phase::LambdaFunction<Phase::Geometry::SystemScheduler::UpdateTransform(Phase::Handle64,Phase::Affine<float> const&)::$_0 const,void>::operator()(uint64_t a1)
{
  uint64_t v2;
  uint64_t *UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA;
  float result;
  uint64_t v5;
  uint64_t v6;

  v2 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD *)(a1 + 8) + 1240;
  UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA = (uint64_t *)_ZN5Phase7details13SharedSlotMapINS_8Geometry6EntityENS_8Handle64EE13GetSlotToEditIRZNS_13SharedSlotMapIS3_S4_NS2_13EntityFactoryEE9GetUniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA_(v6, v2, (uint64_t)&v6);
  if (UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA)
  {
    v5 = *UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA;
    if (*UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA)
    {
      *(_DWORD *)(v5 + 16) = *(_DWORD *)(a1 + 24);
      *(_DWORD *)(v5 + 20) = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(v5 + 24) = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(v5 + 28) = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(v5 + 32) = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(v5 + 36) = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(v5 + 40) = *(_DWORD *)(a1 + 48);
      result = *(float *)(a1 + 52);
      *(float *)(v5 + 44) = result;
      *(_BYTE *)(v5 + 80) = 1;
    }
  }
  return result;
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::ReleaseDirectivity(Phase::Handle64)::$_0,void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::ReleaseDirectivity(Phase::Handle64)::$_0,void>::operator()(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t UniqueSlot;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  UniqueSlot = Phase::details::SharedSlotMap<Phase::Geometry::Directivity,Phase::Handle64>::GetUniqueSlot((__int128 *)v2, v1);
  if (!UniqueSlot)
    return;
  v4 = UniqueSlot;
  ++*(_DWORD *)(UniqueSlot + 20);
  std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)UniqueSlot);
  v5 = (unsigned int *)(v2 + 20);
  v6 = atomic_load((unsigned int *)(v2 + 20));
  *(_DWORD *)(v4 + 16) = v6;
  v7 = __ldaxr((unsigned int *)(v2 + 20));
  if (v7 != v6)
  {
    __clrex();
LABEL_6:
    while (1)
    {
      *(_DWORD *)(v4 + 16) = v7;
      v8 = __ldaxr(v5);
      if (v8 != v7)
        break;
      if (__stlxr(v1, v5))
        goto LABEL_10;
      v9 = 1;
LABEL_11:
      v7 = v8;
      if (v9)
        return;
    }
    __clrex();
LABEL_10:
    v9 = 0;
    goto LABEL_11;
  }
  if (__stlxr(v1, v5))
    goto LABEL_6;
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::ReleaseDistanceModel(Phase::Handle64)::$_0,void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::ReleaseDistanceModel(Phase::Handle64)::$_0,void>::operator()(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t UniqueSlot;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  UniqueSlot = Phase::details::SharedSlotMap<Phase::Geometry::DistanceModel,Phase::Handle64>::GetUniqueSlot((__int128 *)(v2 + 248), v1);
  if (!UniqueSlot)
    return;
  v4 = UniqueSlot;
  ++*(_DWORD *)(UniqueSlot + 20);
  std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)UniqueSlot);
  v5 = (unsigned int *)(v2 + 268);
  v6 = atomic_load((unsigned int *)(v2 + 268));
  *(_DWORD *)(v4 + 16) = v6;
  v7 = __ldaxr((unsigned int *)(v2 + 268));
  if (v7 != v6)
  {
    __clrex();
LABEL_6:
    while (1)
    {
      *(_DWORD *)(v4 + 16) = v7;
      v8 = __ldaxr(v5);
      if (v8 != v7)
        break;
      if (__stlxr(v1, v5))
        goto LABEL_10;
      v9 = 1;
LABEL_11:
      v7 = v8;
      if (v9)
        return;
    }
    __clrex();
LABEL_10:
    v9 = 0;
    goto LABEL_11;
  }
  if (__stlxr(v1, v5))
    goto LABEL_6;
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::ReleaseMedium(Phase::Handle64)::$_0,void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::ReleaseMedium(Phase::Handle64)::$_0,void>::operator()(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t UniqueSlot;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  UniqueSlot = Phase::details::SharedSlotMap<Phase::Geometry::Medium,Phase::Handle64>::GetUniqueSlot((__int128 *)(v2 + 504), v1);
  if (!UniqueSlot)
    return;
  v4 = UniqueSlot;
  ++*(_DWORD *)(UniqueSlot + 20);
  std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)UniqueSlot);
  v5 = (unsigned int *)(v2 + 524);
  v6 = atomic_load((unsigned int *)(v2 + 524));
  *(_DWORD *)(v4 + 16) = v6;
  v7 = __ldaxr((unsigned int *)(v2 + 524));
  if (v7 != v6)
  {
    __clrex();
LABEL_6:
    while (1)
    {
      *(_DWORD *)(v4 + 16) = v7;
      v8 = __ldaxr(v5);
      if (v8 != v7)
        break;
      if (__stlxr(v1, v5))
        goto LABEL_10;
      v9 = 1;
LABEL_11:
      v7 = v8;
      if (v9)
        return;
    }
    __clrex();
LABEL_10:
    v9 = 0;
    goto LABEL_11;
  }
  if (__stlxr(v1, v5))
    goto LABEL_6;
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::ReleaseMaterial(Phase::Handle64)::$_0,void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

uint64_t *Phase::LambdaFunction<Phase::Geometry::SystemScheduler::ReleaseMaterial(Phase::Handle64)::$_0,void>::operator()(uint64_t a1)
{
  return Phase::Geometry::System::AddNewReleaseRequest(*(_QWORD *)(a1 + 8), (_QWORD *)(*(_QWORD *)(a1 + 8) + 2744), *(_QWORD *)(a1 + 16));
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::ReleaseShape(Phase::Handle64)::$_0,void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

uint64_t *Phase::LambdaFunction<Phase::Geometry::SystemScheduler::ReleaseShape(Phase::Handle64)::$_0,void>::operator()(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  Phase::details::SharedSlotMap<Phase::Geometry::Shape,Phase::Handle64>::ReleaseAndBlockSlot(v1 + 992, v2);
  return Phase::Geometry::System::AddNewReleaseRequest(v1, (_QWORD *)(v1 + 2752), v2);
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::ReleaseEntity(Phase::Handle64)::$_0,void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::ReleaseEntity(Phase::Handle64)::$_0,void>::operator()(uint64_t a1)
{
  uint64_t v2;
  uint64_t *UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA;
  uint64_t v4;
  uint64_t v5;
  _QWORD **v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t UniqueSlot;
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  uint64_t v17;

  v2 = *(_QWORD *)(a1 + 16);
  v17 = *(_QWORD *)(a1 + 8) + 1240;
  UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA = (uint64_t *)_ZN5Phase7details13SharedSlotMapINS_8Geometry6EntityENS_8Handle64EE13GetSlotToEditIRZNS_13SharedSlotMapIS3_S4_NS2_13EntityFactoryEE9GetUniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA_(v17, v2, (uint64_t)&v17);
  if (UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA)
  {
    v4 = *UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA;
    if (*UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA)
    {
      v5 = *(_QWORD *)(v4 + 88);
      if (v5)
      {
        v17 = *(_QWORD *)(a1 + 8) + 1240;
        v6 = (_QWORD **)_ZN5Phase7details13SharedSlotMapINS_8Geometry6EntityENS_8Handle64EE13GetSlotToEditIRZNS_13SharedSlotMapIS3_S4_NS2_13EntityFactoryEE9GetUniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA_(v17, v5, (uint64_t)&v17);
        if (v6)
        {
          v7 = *v6;
          if (v7)
          {
            if (Phase::Geometry::Entity::RemoveChild(v7, v4))
              *(_QWORD *)(*(_QWORD *)(a1 + 8) + 2264) = -1;
          }
        }
      }
    }
  }
  v9 = *(_QWORD *)(a1 + 8);
  v8 = *(_QWORD *)(a1 + 16);
  UniqueSlot = Phase::details::SharedSlotMap<Phase::Geometry::Entity,Phase::Handle64>::GetUniqueSlot(v9 + 1240, v8);
  if (!UniqueSlot)
    return;
  v11 = UniqueSlot;
  ++*(_DWORD *)(UniqueSlot + 20);
  std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)UniqueSlot);
  v12 = (unsigned int *)(v9 + 1260);
  v13 = atomic_load((unsigned int *)(v9 + 1260));
  *(_DWORD *)(v11 + 16) = v13;
  v14 = __ldaxr((unsigned int *)(v9 + 1260));
  if (v14 != v13)
  {
    __clrex();
LABEL_13:
    while (1)
    {
      *(_DWORD *)(v11 + 16) = v14;
      v15 = __ldaxr(v12);
      if (v15 != v14)
        break;
      if (__stlxr(v8, v12))
        goto LABEL_17;
      v16 = 1;
LABEL_18:
      v14 = v15;
      if (v16)
        return;
    }
    __clrex();
LABEL_17:
    v16 = 0;
    goto LABEL_18;
  }
  if (__stlxr(v8, v12))
    goto LABEL_13;
}

_QWORD *Phase::LambdaFunction<Phase::Geometry::SystemScheduler::RunFunction(std::function<void ()(Phase::Geometry::System *)> const&)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_24D57DE00;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::RunFunction(std::function<void ()(Phase::Geometry::System *)> const&)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_24D57DE00;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x2199F9D70);
}

uint64_t Phase::LambdaFunction<Phase::Geometry::SystemScheduler::RunFunction(std::function<void ()(Phase::Geometry::System *)> const&)::$_0,void>::operator()(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  v2 = a1 + 32;
  v1 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(*(_QWORD *)(v2 + 8) + 48);
  if (!v1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v1 + 48))(v1, &v4);
}

_QWORD *Phase::LambdaFunction<Phase::Geometry::SystemScheduler::RunDebugFunction(std::function<void ()(Phase::Geometry::SystemDebugger *)> const&)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_24D57DE28;
  v2 = a1 + 2;
  v3 = (_QWORD *)a1[5];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void Phase::LambdaFunction<Phase::Geometry::SystemScheduler::RunDebugFunction(std::function<void ()(Phase::Geometry::SystemDebugger *)> const&)::$_0,void>::~LambdaFunction(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_24D57DE28;
  v1 = a1 + 2;
  v2 = (_QWORD *)a1[5];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x2199F9D70);
}

uint64_t Phase::LambdaFunction<Phase::Geometry::SystemScheduler::RunDebugFunction(std::function<void ()(Phase::Geometry::SystemDebugger *)> const&)::$_0,void>::operator()(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;

  result = Phase::Geometry::SystemDebugger::GetFromSystem(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 48));
  if (result)
  {
    v4 = result;
    v3 = *(_QWORD *)(a1 + 40);
    if (!v3)
      std::__throw_bad_function_call[abi:ne180100]();
    return (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v4);
  }
  return result;
}

_QWORD *Phase::Geometry::SystemState::Init(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  _QWORD *result;

  std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)a1, (uint64_t *)a2);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(a1 + 24), (uint64_t *)(a2 + 248));
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 264);
  std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(a1 + 48), (uint64_t *)(a2 + 504));
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 520);
  std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(a1 + 72), (uint64_t *)(a2 + 744));
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 760);
  std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(a1 + 96), (uint64_t *)(a2 + 2656));
  *(_DWORD *)(a1 + 112) = *(_DWORD *)(a2 + 2672);
  std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(a1 + 120), (uint64_t *)(a2 + 2632));
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 2648);
  memcpy((void *)(a1 + 144), (const void *)(a2 + 1456), 0x310uLL);
  v4 = *(_OWORD *)(a2 + 2256);
  v5 = *(_OWORD *)(a2 + 2240);
  *(_QWORD *)(a1 + 960) = *(_QWORD *)(a2 + 2272);
  *(_OWORD *)(a1 + 928) = v5;
  *(_OWORD *)(a1 + 944) = v4;
  result = (_QWORD *)(a1 + 984);
  if (a1 + 984 != a2 + 2440)
    result = (_QWORD *)std::vector<std::shared_ptr<Phase::Geometry::MpsCpuScene>>::__assign_with_size[abi:ne180100]<std::shared_ptr<Phase::Geometry::MpsCpuScene>*,std::shared_ptr<Phase::Geometry::MpsCpuScene>*>(result, *(uint64_t **)(a2 + 2440), *(uint64_t **)(a2 + 2448), (uint64_t)(*(_QWORD *)(a2 + 2448) - *(_QWORD *)(a2 + 2440)) >> 4);
  *(_QWORD *)(a1 + 968) = *(_QWORD *)(a2 + 2680);
  *(_QWORD *)(a1 + 976) = *(_QWORD *)(a2 + 2688);
  *(_QWORD *)(a1 + 1016) = a2;
  *(_QWORD *)(a1 + 1024) = a2 + 2408;
  *(_QWORD *)(a1 + 1008) = *(_QWORD *)(a2 + 2424);
  return result;
}

uint64_t std::vector<std::shared_ptr<Phase::Geometry::MpsCpuScene>>::__assign_with_size[abi:ne180100]<std::shared_ptr<Phase::Geometry::MpsCpuScene>*,std::shared_ptr<Phase::Geometry::MpsCpuScene>*>(_QWORD *a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t *v6;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t result;
  uint64_t *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  _QWORD *v25;

  v6 = a2;
  v8 = a1[2];
  v9 = (_QWORD *)*a1;
  if (a4 > (v8 - *a1) >> 4)
  {
    if (v9)
    {
      v10 = a1[1];
      v11 = v9;
      if ((_QWORD *)v10 != v9)
      {
        do
          v10 = std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v10 - 16);
        while ((_QWORD *)v10 != v9);
        v11 = (_QWORD *)*a1;
      }
      a1[1] = v9;
      operator delete(v11);
      v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 60)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v12 = v8 >> 3;
    if (v8 >> 3 <= a4)
      v12 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
      v13 = 0xFFFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    result = (uint64_t)std::vector<std::shared_ptr<Phase::Geometry::MpsCpuScene>>::__vallocate[abi:ne180100](a1, v13);
    v15 = (uint64_t *)a1[1];
    while (v6 != a3)
    {
      v16 = v6[1];
      *v15 = *v6;
      v15[1] = v16;
      if (v16)
      {
        v17 = (unint64_t *)(v16 + 8);
        do
          v18 = __ldxr(v17);
        while (__stxr(v18 + 1, v17));
      }
      v6 += 2;
      v15 += 2;
    }
LABEL_30:
    a1[1] = v15;
    return result;
  }
  result = a1[1];
  v19 = (result - (uint64_t)v9) >> 4;
  if (v19 < a4)
  {
    v20 = &a2[2 * v19];
    if ((_QWORD *)result != v9)
    {
      v21 = 16 * v19;
      do
      {
        result = (uint64_t)std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100](v9, v6);
        v6 += 2;
        v9 += 2;
        v21 -= 16;
      }
      while (v21);
      v9 = (_QWORD *)a1[1];
    }
    v15 = v9;
    if (v20 != a3)
    {
      v15 = v9;
      do
      {
        v22 = v20[1];
        *v15 = *v20;
        v15[1] = v22;
        if (v22)
        {
          v23 = (unint64_t *)(v22 + 8);
          do
            v24 = __ldxr(v23);
          while (__stxr(v24 + 1, v23));
        }
        v20 += 2;
        v15 += 2;
      }
      while (v20 != a3);
    }
    goto LABEL_30;
  }
  if (a2 == a3)
  {
    v25 = v9;
  }
  else
  {
    v25 = v9;
    do
    {
      std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100](v9, v6);
      v6 += 2;
      v9 += 2;
      v25 += 2;
    }
    while (v6 != a3);
    result = a1[1];
  }
  while ((_QWORD *)result != v25)
    result = std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](result - 16);
  a1[1] = v25;
  return result;
}

uint64_t (*Phase::GetTypeId<Phase::Geometry::VoxelTree>())()
{
  return Phase::GetTypeId<Phase::Geometry::VoxelTree>;
}

uint64_t Phase::Geometry::AddVoxelTree(uint64_t *a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  _BYTE v31[36];
  _QWORD v32[3];
  _QWORD *v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v4 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)a1) + 1184);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v31 = 136315394;
    *(_QWORD *)&v31[4] = "GeoVoxelTree.cpp";
    *(_WORD *)&v31[12] = 1024;
    *(_DWORD *)&v31[14] = 82;
    _os_log_impl(&dword_2164CC000, v4, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Voxel tree added", v31, 0x12u);
  }
  v6 = a1[12];
  v7 = a1[13];
  v5 = a1 + 12;
  std::vector<std::shared_ptr<Phase::Geometry::SharedDataStream>>::resize((uint64_t)(a1 + 12), a2 + 2);
  v8 = (v7 - v6) >> 4;
  if (v8 < a2 + 2)
  {
    do
    {
      v9 = (char *)operator new(0x40uLL);
      *((_QWORD *)v9 + 1) = 0;
      *((_QWORD *)v9 + 2) = 0;
      *(_QWORD *)v9 = &off_24D57D048;
      *(_OWORD *)(v9 + 40) = 0u;
      *((_QWORD *)v9 + 7) = 0;
      *(_OWORD *)(v9 + 24) = 0u;
      *(_QWORD *)v31 = v9 + 24;
      *(_QWORD *)&v31[8] = v9;
      std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100](*v5 + 16 * v8, (__int128 *)v31);
      v10 = *(std::__shared_weak_count **)&v31[8];
      if (*(_QWORD *)&v31[8])
      {
        v11 = (unint64_t *)(*(_QWORD *)&v31[8] + 8);
        do
          v12 = __ldaxr(v11);
        while (__stlxr(v12 - 1, v11));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
      ++v8;
    }
    while (v8 != a2 + 2);
  }
  v13 = operator new();
  *(_QWORD *)v13 = Phase::GetTypeId<Phase::Geometry::VoxelTree>;
  *(_QWORD *)(v13 + 8) = a1;
  *(_OWORD *)(v13 + 16) = 0u;
  *(_OWORD *)(v13 + 32) = 0u;
  *(_QWORD *)(v13 + 48) = -1;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(a1 + 15, 1uLL);
  v32[0] = &off_24D57DE68;
  v33 = v32;
  *(_QWORD *)v31 = v13;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v31[8], (uint64_t)v32);
  v14 = v33;
  if (v33 == v32)
  {
    v15 = 4;
    v14 = v32;
  }
  else
  {
    if (!v33)
      goto LABEL_15;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_15:
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)a1[15], (uint64_t *)v31);
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v31);
  a1[18] = (uint64_t)v5;
  a1[19] = 0;
  v16 = (uint64_t *)a1[12];
  v17 = *v16;
  *(_DWORD *)v17 = 1;
  *(_QWORD *)(v17 + 16) = 8;
  *(_QWORD *)(v17 + 32) = 8;
  *(_QWORD *)(v13 + 40) = v5;
  *(_QWORD *)(v13 + 48) = 1;
  v18 = v16[2];
  *(_DWORD *)v18 = 7;
  *(_QWORD *)(v18 + 16) = 8;
  *(_QWORD *)(v18 + 32) = 56;
  if (a2)
  {
    v19 = *(_QWORD *)(v18 + 24);
    if (v19 == 1)
    {
      v20 = 0;
    }
    else
    {
      v20 = *(_QWORD *)(v18 + 8);
      *(_QWORD *)(v18 + 8) = 0;
      Phase::Geometry::DataStream::Alloc((std::align_val_t)8uLL, 0x38uLL, v31);
      v21 = *(_QWORD *)v31;
      *(_QWORD *)v31 = 0;
      v22 = *(_QWORD *)(v18 + 8);
      *(_QWORD *)(v18 + 8) = v21;
      if (v22)
      {
        MEMORY[0x2199F9D4C](v22, 0x1000C8077774924);
        v23 = *(_QWORD *)v31;
        *(_QWORD *)v31 = 0;
        if (v23)
          MEMORY[0x2199F9D4C](v23, 0x1000C8077774924);
      }
      *(_QWORD *)(v18 + 24) = 1;
      if (!v19)
      {
        v30 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v13 + 40) + 16 * *(_QWORD *)(v13 + 48)) + 8);
        *(_OWORD *)v30 = 0u;
        *(_OWORD *)(v30 + 16) = 0u;
        *(_QWORD *)(v30 + 32) = 0xFFFFFFFFLL;
        *(_QWORD *)(v30 + 40) = 0;
        *(_QWORD *)(v30 + 48) = -1;
        if (!v20)
          goto LABEL_24;
        goto LABEL_23;
      }
    }
    v24 = *(_QWORD *)(v18 + 8);
    *(_DWORD *)v24 = *(_DWORD *)v20;
    *(_DWORD *)(v24 + 4) = *(_DWORD *)(v20 + 4);
    *(_DWORD *)(v24 + 8) = *(_DWORD *)(v20 + 8);
    *(_DWORD *)(v24 + 12) = *(_DWORD *)(v20 + 12);
    *(_DWORD *)(v24 + 16) = *(_DWORD *)(v20 + 16);
    *(_DWORD *)(v24 + 20) = *(_DWORD *)(v20 + 20);
    v25 = *(_OWORD *)(v20 + 24);
    *(_OWORD *)(v24 + 40) = *(_OWORD *)(v20 + 40);
    *(_OWORD *)(v24 + 24) = v25;
LABEL_23:
    MEMORY[0x2199F9D4C](v20, 0x1000C8077774924);
LABEL_24:
    v26 = *v5;
    v27 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v13 + 40) + 16 * *(_QWORD *)(v13 + 48)) + 8);
    *(_QWORD *)(v27 + 40) = v5;
    *(_QWORD *)(v27 + 48) = 2;
    v28 = *(_QWORD *)(v26 + 32);
    *(_DWORD *)v28 = 8;
    *(_QWORD *)(v28 + 16) = 8;
    *(_QWORD *)(v28 + 32) = 72;
  }
  return v13;
}

void sub_2165DA270(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    MEMORY[0x2199F9D4C](v1, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Geometry::CreateVoxelTree@<X0>(_QWORD *a1@<X8>)
{
  char *v2;

  v2 = (char *)operator new(0xC0uLL);
  *((_QWORD *)v2 + 1) = 0;
  *((_QWORD *)v2 + 2) = 0;
  *(_QWORD *)v2 = &off_24D57D128;
  *((_OWORD *)v2 + 2) = xmmword_2166F8310;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *(_OWORD *)(v2 + 76) = 0u;
  *((_OWORD *)v2 + 6) = 0u;
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  *((_OWORD *)v2 + 9) = 0u;
  *((_OWORD *)v2 + 10) = 0u;
  *((_OWORD *)v2 + 11) = xmmword_2166F8320;
  a1[1] = v2;
  *((_DWORD *)v2 + 6) = 2;
  v2 += 24;
  *a1 = v2;
  return Phase::Geometry::AddVoxelTree((uint64_t *)v2, 0);
}

void sub_2165DA318(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::AddBuilderVoxelToSubtree(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  v5 = *(_QWORD **)(**(_QWORD **)(result + 40) + 16 * *(_QWORD *)(result + 48));
  v6 = v5[1];
  v7 = v5[3];
  v8 = v5[4];
  v9 = *(unsigned int *)(a4 + 4 * a3);
  v10 = v6 + v8 * a3;
  *(_DWORD *)(a4 + 4 * a3) = v9 + 1;
  v11 = *(_QWORD **)(**(_QWORD **)(v10 + 40) + 16 * *(_QWORD *)(v10 + 48));
  if (v11[3] <= v9)
    __assert_rtn("AddBuilderVoxelToSubtree", "GeoVoxelTree.cpp", 188, "voxelIndex < level.mVoxels.Count()");
  v13 = result;
  v14 = v7 - 1;
  v15 = v11[1] + v11[4] * v9;
  v16 = *(float *)a2;
  v17 = *(float *)(a2 + 4);
  v18 = *(float *)(a2 + 8);
  v19 = (float)((float)(v16 * v16) + (float)(v17 * v17)) + (float)(v18 * v18);
  if (v19 <= 0.00000011921)
  {
    *(_QWORD *)v15 = 0;
    *(_DWORD *)(v15 + 8) = 0;
    if (v14 == a3)
      ++*a5;
  }
  else
  {
    v20 = sqrtf(v19);
    *(float *)v15 = v16 / v20;
    *(float *)(v15 + 4) = v17 / v20;
    *(float *)(v15 + 8) = v18 / v20;
  }
  *(_DWORD *)(v15 + 12) = *(_DWORD *)(a2 + 12);
  if (v14 != a3)
  {
    v21 = *(_QWORD **)(**(_QWORD **)(v10 + 56) + 16 * *(_QWORD *)(v10 + 64));
    if (v21[3] <= v9)
      __assert_rtn("AddBuilderVoxelToSubtree", "GeoVoxelTree.cpp", 207, "voxelIndex < level.mTreeNodes.Count()");
    v22 = 0;
    v23 = 0;
    v24 = v21[1] + v21[4] * v9;
    *(_DWORD *)(v24 + 8) = *(_DWORD *)(a4 + 4 * (a3 + 1));
    *(_QWORD *)v24 = 0;
    do
    {
      if (*(_DWORD *)(*(_QWORD *)(a2 + 16) + v22 + 12) != -1)
      {
        *(_QWORD *)v24 |= 1 << v23;
        result = Phase::Geometry::AddBuilderVoxelToSubtree(v13);
      }
      ++v23;
      v22 += 24;
    }
    while (v23 != 64);
  }
  return result;
}

uint64_t Phase::Geometry::AddBuilderToSubtree(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v6;
  char *v7;
  size_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x24BDAC8D0];
  MEMORY[0x24BDAC7A8](a1);
  v7 = (char *)v21 - v6;
  bzero((char *)v21 - v6, v8);
  result = Phase::Geometry::AddBuilderVoxelToSubtree(a1, a2 + 64, 0, (uint64_t)v7, a3);
  v11 = *(_QWORD *)(a2 + 96);
  v10 = *(_QWORD *)(a2 + 104);
  v12 = v10 - v11;
  if (v10 != v11)
  {
    v13 = 0;
    v14 = v12 >> 5;
    v15 = (v12 >> 5) - 1;
    if (v14 <= 1)
      v14 = 1;
    v16 = (uint64_t *)(v11 + 24);
    do
    {
      v17 = *(unsigned int *)&v7[4 * v13];
      v18 = *v16;
      v16 += 4;
      if (v18 != v17)
        __assert_rtn("AddBuilderToSubtree", "GeoVoxelTree.cpp", 240, "currentVoxelCounts[i] == inBuilder.mLevels[i].mVoxelCount");
      v19 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 40) + 16 * *(_QWORD *)(a1 + 48)) + 8)
          + *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a1 + 40) + 16 * *(_QWORD *)(a1 + 48)) + 32) * v13;
      if (*(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v19 + 40) + 16 * *(_QWORD *)(v19 + 48)) + 24) != v17)
        __assert_rtn("AddBuilderToSubtree", "GeoVoxelTree.cpp", 241, "currentVoxelCounts[i] == inSubtree.mLevels[i].mVoxels.Count()");
      v20 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v19 + 56) + 16 * *(_QWORD *)(v19 + 64)) + 24);
      if (v15 == v13)
      {
        if (v20)
          __assert_rtn("AddBuilderToSubtree", "GeoVoxelTree.cpp", 249, "0 == inSubtree.mLevels[i].mTreeNodes.Count()");
      }
      else if (v20 != v17)
      {
        __assert_rtn("AddBuilderToSubtree", "GeoVoxelTree.cpp", 245, "currentVoxelCounts[i] == inSubtree.mLevels[i].mTreeNodes.Count()");
      }
      ++v13;
    }
    while (v14 != v13);
  }
  return result;
}

id **Phase::Geometry::CreateVoxelTreeFromMdlMesh@<X0>(int a1@<W0>, const Phase::MdlMeshAsset *a2@<X1>, _QWORD *a3@<X2>, float32x2_t **a4@<X8>)
{
  id **v6;
  unint64_t SubmeshCount;
  char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t **v17;
  int *v18;
  unint64_t v19;
  int v20;
  _QWORD *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  void *v31;
  void *v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  __int128 v44;
  uint64_t v45;
  unint64_t v46;
  _QWORD *v47;
  _QWORD *v48;
  unint64_t v49;
  int64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int64_t v54;
  float *v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  float v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _DWORD *v72;
  _DWORD *v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  _QWORD *v79;
  float v80;
  float v81;
  int v82;
  uint64_t Name;
  const char *v84;
  NSObject *v85;
  NSObject *v86;
  uint64_t **v87;
  uint64_t v88;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  unint64_t v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  int v105;
  _OWORD v106[2];
  __int128 v107;
  int v108;
  uint64_t v109;
  uint64_t v110;
  unint64_t v111;
  __int128 v112;
  void *__p[2];
  uint64_t v114;
  id *v115;
  id *v116;
  _BYTE buf[18];
  __int16 v118;
  int v119;
  __int16 v120;
  const char *v121;
  uint64_t v122;

  v122 = *MEMORY[0x24BDAC8D0];
  v6 = (id **)Phase::Geometry::MdlMeshReader::MdlMeshReader((Phase::MdlMeshAsset *)&v115, a2);
  SubmeshCount = Phase::MdlMeshAsset::GetSubmeshCount(v6);
  if (!SubmeshCount)
    __assert_rtn("CreateVoxelTreeFromMdlMesh", "GeoVoxelTree.cpp", 262, "mdlSubmeshCount > 0");
  v8 = (char *)operator new(0xC0uLL);
  v9 = 0;
  v10 = 0;
  *((_QWORD *)v8 + 1) = 0;
  *((_QWORD *)v8 + 2) = 0;
  *(_QWORD *)v8 = &off_24D57D128;
  *((_DWORD *)v8 + 6) = 2;
  v11 = (uint64_t)(v8 + 24);
  *((_OWORD *)v8 + 2) = xmmword_2166F8310;
  *((_OWORD *)v8 + 3) = 0u;
  *((_OWORD *)v8 + 4) = 0u;
  *(_OWORD *)(v8 + 76) = 0u;
  *((_OWORD *)v8 + 6) = 0u;
  *((_OWORD *)v8 + 7) = 0u;
  *((_OWORD *)v8 + 8) = 0u;
  *((_OWORD *)v8 + 9) = 0u;
  *((_OWORD *)v8 + 10) = 0u;
  *((_OWORD *)v8 + 11) = xmmword_2166F8320;
  *a4 = (float32x2_t *)(v8 + 24);
  a4[1] = (float32x2_t *)v8;
  do
  {
    v12 = objc_msgSend(Phase::MdlMeshAsset::GetSubmesh(&v115, v9), "indexCount");
    if (0xAAAAAAAAAAAAAAABLL * v12 >= 0x5555555555555556)
      std::terminate();
    v10 += v12;
    ++v9;
  }
  while (SubmeshCount != v9);
  *((_QWORD *)v8 + 23) = v10 / 3;
  v13 = Phase::Geometry::AddVoxelTree((uint64_t *)v11, 1);
  v15 = *((_QWORD *)v8 + 15);
  v14 = *((_QWORD *)v8 + 16);
  *((_OWORD *)v8 + 3) = xmmword_2166F8300;
  *((_QWORD *)v8 + 8) = 0x80000000800000;
  Phase::Geometry::InitMaterials(v11, SubmeshCount, 0);
  Phase::Geometry::InitSurfaceArea(v11, SubmeshCount);
  v16 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v13 + 40) + 16 * *(_QWORD *)(v13 + 48)) + 8);
  *(_DWORD *)(v16 + 32) = 0;
  if (a3
    && (v17 = Phase::UnorderedStringMap<Phase::OptionsValue>::Find(a3, (__int128 *)&Phase::Geometry::VoxelTreeOptions::Resolution)) != 0)
  {
    v18 = (int *)(v17 + 7);
    if (*((_DWORD *)v17 + 24) != 1)
      v18 = &dword_24D57DE50;
  }
  else
  {
    v18 = &dword_24D57DE50;
  }
  v19 = *v18;
  *(_QWORD *)(v16 + 24) = v19;
  v108 = 0;
  v107 = 0u;
  memset(v106, 0, sizeof(v106));
  v109 = 0;
  v110 = 0;
  v111 = 0xFFFFFFFF00000000;
  v112 = 0u;
  *(_OWORD *)__p = 0u;
  v114 = 0;
  v20 = a1;
  v21 = a3;
  Phase::Geometry::VoxelTreeBuilder::Build((uint64_t)v106, v20, &v115, v19);
  if (__p[1] == __p[0])
  {
    *(_OWORD *)v16 = xmmword_2166F8300;
    *(_QWORD *)(v16 + 16) = 0x80000000800000;
    goto LABEL_77;
  }
  v22 = (v14 - v15) >> 4;
  v23 = v22 + (((char *)__p[1] - (char *)__p[0]) >> 4);
  v25 = *((_QWORD *)v8 + 15);
  v24 = *((_QWORD *)v8 + 16);
  std::vector<std::shared_ptr<Phase::Geometry::SharedDataStream>>::resize((uint64_t)(v8 + 120), v23);
  v26 = (v24 - v25) >> 4;
  if (v26 < v23)
  {
    do
    {
      v27 = (char *)operator new(0x40uLL);
      *((_QWORD *)v27 + 1) = 0;
      *((_QWORD *)v27 + 2) = 0;
      *(_QWORD *)v27 = &off_24D57D048;
      *(_OWORD *)(v27 + 40) = 0u;
      *((_QWORD *)v27 + 7) = 0;
      *(_OWORD *)(v27 + 24) = 0u;
      *(_QWORD *)buf = v27 + 24;
      *(_QWORD *)&buf[8] = v27;
      std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100](*((_QWORD *)v8 + 15) + 16 * v26, (__int128 *)buf);
      v28 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v29 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
      ++v26;
    }
    while (v26 != v23);
  }
  *(_QWORD *)v16 = *((_QWORD *)&v106[1] + 1);
  *(_OWORD *)(v16 + 8) = v107;
  v32 = __p[0];
  v31 = __p[1];
  v33 = ((char *)__p[1] - (char *)__p[0]) >> 5;
  v34 = *(_QWORD *)(**(_QWORD **)(v16 + 40) + 16 * *(_QWORD *)(v16 + 48));
  v35 = *(_QWORD *)(v34 + 24);
  if (v35 == v33)
  {
    v36 = 0;
  }
  else
  {
    v36 = *(_QWORD *)(v34 + 8);
    *(_QWORD *)(v34 + 8) = 0;
    if (v31 != v32)
    {
      Phase::Geometry::DataStream::Alloc(*(std::align_val_t *)(v34 + 16), *(_QWORD *)(v34 + 32) * v33, buf);
      v37 = *(_QWORD *)buf;
      *(_QWORD *)buf = 0;
      v38 = *(_QWORD *)(v34 + 8);
      *(_QWORD *)(v34 + 8) = v37;
      if (v38)
      {
        MEMORY[0x2199F9D4C](v38, 0x1000C8077774924);
        v39 = *(_QWORD *)buf;
        *(_QWORD *)buf = 0;
        if (v39)
          MEMORY[0x2199F9D4C](v39, 0x1000C8077774924);
      }
    }
    *(_QWORD *)(v34 + 24) = v33;
  }
  if (v35 >= v33)
    v40 = v33;
  else
    v40 = v35;
  if (v40)
  {
    v41 = v36 + 20;
    v42 = *(_QWORD *)(v34 + 8) + 20;
    v43 = v40;
    do
    {
      *(_OWORD *)(v42 - 20) = *(_OWORD *)(v41 - 20);
      *(_DWORD *)(v42 - 4) = *(_DWORD *)(v41 - 4);
      *(_DWORD *)v42 = *(_DWORD *)v41;
      *(_DWORD *)(v42 + 4) = *(_DWORD *)(v41 + 4);
      *(_DWORD *)(v42 + 8) = *(_DWORD *)(v41 + 8);
      *(_DWORD *)(v42 + 12) = *(_DWORD *)(v41 + 12);
      *(_DWORD *)(v42 + 16) = *(_DWORD *)(v41 + 16);
      v44 = *(_OWORD *)(v41 + 20);
      *(_OWORD *)(v42 + 36) = *(_OWORD *)(v41 + 36);
      *(_OWORD *)(v42 + 20) = v44;
      v41 += 72;
      v42 += 72;
      --v43;
    }
    while (v43);
  }
  if (v35 < v33)
  {
    do
    {
      v45 = *(_QWORD *)(**(_QWORD **)(v16 + 40) + 16 * *(_QWORD *)(v16 + 48));
      v46 = *(_QWORD *)(v45 + 8) + *(_QWORD *)(v45 + 32) * v40;
      *(_OWORD *)(v46 + 16) = 0uLL;
      *(_OWORD *)(v46 + 32) = 0uLL;
      *(_OWORD *)v46 = 0uLL;
      *(_QWORD *)(v46 + 48) = -1;
      *(_QWORD *)(v46 + 56) = 0;
      *(_QWORD *)(v46 + 64) = -1;
      ++v40;
    }
    while (v33 != v40);
  }
  if (v36)
    MEMORY[0x2199F9D4C](v36, 0x1000C8077774924);
  v47 = __p[0];
  v48 = __p[1];
  v49 = ((char *)__p[1] - (char *)__p[0]) >> 5;
  v50 = (char *)__p[1] - (char *)__p[0];
  if (__p[1] != __p[0])
  {
    v51 = 0;
    v52 = *(_QWORD *)(**(_QWORD **)(v16 + 40) + 16 * *(_QWORD *)(v16 + 48));
    v53 = (uint64_t)&(*a4)[12];
    if (v49 <= 1)
      v54 = 1;
    else
      v54 = ((char *)__p[1] - (char *)__p[0]) >> 5;
    v55 = (float *)((char *)__p[0] + 8);
    v56 = (uint64_t *)(*(_QWORD *)&(*a4)[12] + 16 * v22 + 16);
    do
    {
      v57 = *(_QWORD *)(v52 + 8) + *(_QWORD *)(v52 + 32) * v51;
      *(_QWORD *)(v57 + 56) = v53;
      *(_QWORD *)(v57 + 64) = v22;
      v58 = *(v56 - 2);
      *(_DWORD *)v58 = 10;
      *(_QWORD *)(v58 + 16) = 8;
      *(_QWORD *)(v58 + 32) = 16;
      *(_QWORD *)(v57 + 40) = v53;
      *(_QWORD *)(v57 + 48) = v22 + 1;
      v59 = *v56;
      v56 += 4;
      *(_DWORD *)v59 = 9;
      *(_QWORD *)(v59 + 16) = 4;
      *(_QWORD *)(v59 + 32) = 16;
      *(_QWORD *)(v57 + 8) = v51;
      *(_QWORD *)v57 = *(_QWORD *)v55;
      v60 = *(v55 - 2);
      *(float *)(v57 + 16) = v60;
      *(float *)(v57 + 20) = v60;
      *(float *)(v57 + 24) = v60;
      *(float *)(v57 + 28) = 1.0 / v60;
      ++v51;
      *(float *)(v57 + 32) = 1.0 / v60;
      *(float *)(v57 + 36) = 1.0 / v60;
      v55 += 8;
      v22 += 2;
    }
    while (v54 != v51);
  }
  if (v50 != 32)
  {
    v90 = 0;
    v91 = v49 - 1;
    while (1)
    {
      if (v91 == v90)
        __assert_rtn("CreateVoxelTreeFromMdlMesh", "GeoVoxelTree.cpp", 335, "i != bottomDepth");
      v92 = *(_QWORD *)(**(_QWORD **)(v16 + 40) + 16 * *(_QWORD *)(v16 + 48));
      v93 = *(_QWORD *)(v92 + 8) + *(_QWORD *)(v92 + 32) * v90;
      v94 = v47[4 * v90 + 3];
      v95 = *(_QWORD *)(**(_QWORD **)(v93 + 56) + 16 * *(_QWORD *)(v93 + 64));
      v96 = *(_QWORD *)(v95 + 24);
      if (v96 != v94)
        break;
      if (v94)
      {
        v97 = 0;
        goto LABEL_98;
      }
LABEL_101:
      ++v90;
      v47 = __p[0];
      v48 = __p[1];
      if ((((char *)__p[1] - (char *)__p[0]) >> 5) - 1 <= v90)
        goto LABEL_44;
    }
    v97 = *(_QWORD *)(v95 + 8);
    *(_QWORD *)(v95 + 8) = 0;
    if (v94)
    {
      Phase::Geometry::DataStream::Alloc(*(std::align_val_t *)(v95 + 16), *(_QWORD *)(v95 + 32) * v94, buf);
      v98 = *(_QWORD *)buf;
      *(_QWORD *)buf = 0;
      v99 = *(_QWORD *)(v95 + 8);
      *(_QWORD *)(v95 + 8) = v98;
      if (v99)
      {
        MEMORY[0x2199F9D4C](v99, 0x1000C8077774924);
        v100 = *(_QWORD *)buf;
        *(_QWORD *)buf = 0;
        if (v100)
          MEMORY[0x2199F9D4C](v100, 0x1000C8077774924);
      }
    }
    *(_QWORD *)(v95 + 24) = v94;
    if (v96 < v94)
      v94 = v96;
    if (v94)
    {
LABEL_98:
      v101 = 0;
      v102 = *(_QWORD *)(v95 + 8);
      do
      {
        *(_OWORD *)(v102 + v101) = *(_OWORD *)(v97 + v101);
        v101 += 16;
        --v94;
      }
      while (v94);
    }
    else if (!v97)
    {
      goto LABEL_101;
    }
    MEMORY[0x2199F9D4C](v97, 0x1000C8077774924);
    goto LABEL_101;
  }
LABEL_44:
  if (v48 != v47)
  {
    v61 = 0;
    do
    {
      v62 = *(_QWORD *)(**(_QWORD **)(v16 + 40) + 16 * *(_QWORD *)(v16 + 48));
      v63 = *(_QWORD *)(v62 + 8) + *(_QWORD *)(v62 + 32) * v61;
      v64 = v47[4 * v61 + 3];
      v65 = *(_QWORD *)(**(_QWORD **)(v63 + 40) + 16 * *(_QWORD *)(v63 + 48));
      v66 = *(_QWORD *)(v65 + 24);
      if (v66 == v64)
      {
        v67 = 0;
      }
      else
      {
        v67 = *(_QWORD *)(v65 + 8);
        *(_QWORD *)(v65 + 8) = 0;
        if (v64)
        {
          Phase::Geometry::DataStream::Alloc(*(std::align_val_t *)(v65 + 16), *(_QWORD *)(v65 + 32) * v64, buf);
          v68 = *(_QWORD *)buf;
          *(_QWORD *)buf = 0;
          v69 = *(_QWORD *)(v65 + 8);
          *(_QWORD *)(v65 + 8) = v68;
          if (v69)
          {
            MEMORY[0x2199F9D4C](v69, 0x1000C8077774924);
            v70 = *(_QWORD *)buf;
            *(_QWORD *)buf = 0;
            if (v70)
              MEMORY[0x2199F9D4C](v70, 0x1000C8077774924);
          }
        }
        *(_QWORD *)(v65 + 24) = v64;
      }
      if (v66 >= v64)
        v71 = v64;
      else
        v71 = v66;
      if (v71)
      {
        v72 = (_DWORD *)(*(_QWORD *)(v65 + 8) + 8);
        v73 = (_DWORD *)(v67 + 8);
        v74 = v71;
        do
        {
          *(v72 - 2) = *(v73 - 2);
          *(v72 - 1) = *(v73 - 1);
          *v72 = *v73;
          v72[1] = v73[1];
          v72 += 4;
          v73 += 4;
          --v74;
        }
        while (v74);
      }
      if (v66 < v64)
      {
        v75 = *(_QWORD *)(**(_QWORD **)(v63 + 40) + 16 * *(_QWORD *)(v63 + 48));
        v76 = *(_QWORD *)(v75 + 8);
        v77 = *(_QWORD *)(v75 + 32);
        v78 = v64 - v71;
        v79 = (_QWORD *)(v76 + v77 * v71);
        do
        {
          *v79 = 0;
          v79[1] = 0;
          v79 = (_QWORD *)((char *)v79 + v77);
          --v78;
        }
        while (v78);
      }
      if (v67)
        MEMORY[0x2199F9D4C](v67, 0x1000C8077774924);
      ++v61;
      v47 = __p[0];
    }
    while (v61 < ((char *)__p[1] - (char *)__p[0]) >> 5);
  }
  v105 = 0;
  Phase::Geometry::AddBuilderToSubtree(v16, (uint64_t)v106, &v105);
  v11 = (uint64_t)*a4;
  v80 = fminf((*a4)[4].f32[0], *((float *)v106 + 2));
  v81 = fmaxf((*a4)[5].f32[1], *((float *)&v106[1] + 1));
  *(float32x2_t *)(v11 + 24) = vminnm_f32((*a4)[3], *(float32x2_t *)&v106[0]);
  *(float *)(v11 + 32) = v80;
  *(float32x2_t *)(v11 + 36) = vmaxnm_f32(*(float32x2_t *)(v11 + 36), *(float32x2_t *)((char *)v106 + 12));
  *(float *)(v11 + 44) = v81;
  **(_DWORD **)(v11 + 72) = DWORD2(v112);
  *(float *)(v11 + 64) = *((float *)&v112 + 2) + *(float *)(v11 + 64);
  v82 = v105;
  v21 = a3;
  if (SHIDWORD(v112) > 0 || v105 >= 1)
  {
    Name = Phase::MdlMeshAsset::GetName((id **)a2);
    if (Name)
      v84 = (const char *)Name;
    else
      v84 = "";
    if (*((uint64_t *)&v112 + 1) > 0)
    {
      v85 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)Name) + 416);
      Name = os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)Name)
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = "GeoVoxelTree.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 372;
        v118 = 1024;
        v119 = HIDWORD(v112);
        v120 = 2080;
        v121 = v84;
        _os_log_impl(&dword_2164CC000, v85, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: [%i] degenerate triangles ignored while creating a Geometry::VoxelTree Shape from MDLMesh:[%s]", buf, 0x22u);
      }
      *(_QWORD *)(v11 + 160) -= SHIDWORD(v112);
    }
    if (v82 >= 1)
    {
      v86 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)Name) + 416);
      if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = "GeoVoxelTree.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 383;
        v118 = 1024;
        v119 = v82;
        v120 = 2080;
        v121 = v84;
        _os_log_impl(&dword_2164CC000, v86, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: [%i] voxels created with zero length normals while creating a Geometry::VoxelTree Shape from MDLMesh:[%s]", buf, 0x22u);
      }
    }
  }
LABEL_77:
  *(_DWORD *)(v13 + 16) = *(_DWORD *)(v11 + 24);
  *(_DWORD *)(v13 + 20) = *(_DWORD *)(v11 + 28);
  *(_DWORD *)(v13 + 24) = *(_DWORD *)(v11 + 32);
  *(_DWORD *)(v13 + 28) = *(_DWORD *)(v11 + 36);
  *(_DWORD *)(v13 + 32) = *(_DWORD *)(v11 + 40);
  *(_DWORD *)(v13 + 36) = *(_DWORD *)(v11 + 44);
  Phase::Geometry::SetMaterialsFromOptionalMaterialList((uint64_t **)v11, v21);
  if (v21)
  {
    v87 = Phase::UnorderedStringMap<Phase::OptionsValue>::Find(v21, (__int128 *)&Phase::Geometry::ShapeOptions::SceneQueryFilter);
    if (v87)
    {
      if (*((_DWORD *)v87 + 24) == 2)
        *(_QWORD *)(v11 + 16) = *((unsigned int *)v87 + 14);
    }
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  v88 = v112;
  *(_QWORD *)&v112 = 0;
  if (v88)
    std::default_delete<Phase::Geometry::VoxelTreeBuilder::Voxel []>::operator()[abi:ne180100]<Phase::Geometry::VoxelTreeBuilder::Voxel>((uint64_t)&v112, v88);
  return std::unique_ptr<Phase::details::MdlMeshAssetImplementation>::reset[abi:ne180100](&v116, 0);
}

void sub_2165DB1C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30)
{
  uint64_t v30;

  Phase::Geometry::VoxelTreeBuilder::~VoxelTreeBuilder((Phase::Geometry::VoxelTreeBuilder *)&a17);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](a14);
  std::unique_ptr<Phase::details::MdlMeshAssetImplementation>::reset[abi:ne180100]((id **)(v30 - 160), 0);
  _Unwind_Resume(a1);
}

void Phase::Geometry::VoxelTreeBuilder::~VoxelTreeBuilder(Phase::Geometry::VoxelTreeBuilder *this)
{
  void *v2;
  uint64_t v3;

  v2 = (void *)*((_QWORD *)this + 12);
  if (v2)
  {
    *((_QWORD *)this + 13) = v2;
    operator delete(v2);
  }
  v3 = *((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v3)
    std::default_delete<Phase::Geometry::VoxelTreeBuilder::Voxel []>::operator()[abi:ne180100]<Phase::Geometry::VoxelTreeBuilder::Voxel>((uint64_t)this + 80, v3);
}

void Phase::Geometry::CreateVoxelTreeFromShape(uint64_t a1@<X1>, _QWORD *a2@<X2>, uint64_t ***a3@<X8>)
{
  unsigned int *value;
  std::vector<unsigned int>::pointer end;
  unsigned int *v8;
  std::vector<unsigned int>::pointer begin;
  int64_t v10;
  unint64_t v11;
  int64_t v12;
  unint64_t v13;
  char *v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int *v17;
  std::vector<unsigned int>::pointer v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  unsigned int *v24;
  unsigned int *v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t **v28;
  uint64_t v29;
  uint64_t **v30;
  uint64_t *v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  std::vector<unsigned int> __p;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[3];
  _QWORD *v60;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)a1 != 2)
    __assert_rtn("CreateVoxelTreeFromShape", "GeoVoxelTree.cpp", 416, "inShape.mType == DefaultShapeType::VoxelTree");
  Phase::Geometry::ForcedCopyTagsIncludingMaterialListFromOptions(2uLL, a2, &__p);
  end = __p.__end_;
  value = __p.__end_cap_.__value_;
  if (__p.__end_ >= __p.__end_cap_.__value_)
  {
    begin = __p.__begin_;
    v10 = __p.__end_ - __p.__begin_;
    v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 62)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v12 = (char *)__p.__end_cap_.__value_ - (char *)__p.__begin_;
    if (((char *)__p.__end_cap_.__value_ - (char *)__p.__begin_) >> 1 > v11)
      v11 = v12 >> 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
      v13 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v13 = v11;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&__p.__end_cap_, v13);
      begin = __p.__begin_;
      end = __p.__end_;
    }
    else
    {
      v14 = 0;
    }
    v15 = (unsigned int *)&v14[4 * v10];
    value = (unsigned int *)&v14[4 * v13];
    *v15 = 7;
    v8 = v15 + 1;
    while (end != begin)
    {
      v16 = *--end;
      *--v15 = v16;
    }
    __p.__begin_ = v15;
    __p.__end_ = v8;
    __p.__end_cap_.__value_ = value;
    if (begin)
    {
      operator delete(begin);
      value = __p.__end_cap_.__value_;
    }
  }
  else
  {
    *__p.__end_ = 7;
    v8 = end + 1;
  }
  __p.__end_ = v8;
  if (v8 >= value)
  {
    v18 = __p.__begin_;
    v19 = v8 - __p.__begin_;
    v20 = v19 + 1;
    if ((unint64_t)(v19 + 1) >> 62)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v21 = (char *)value - (char *)__p.__begin_;
    if (v21 >> 1 > v20)
      v20 = v21 >> 1;
    if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL)
      v22 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v22 = v20;
    if (v22)
    {
      v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&__p.__end_cap_, v22);
      v18 = __p.__begin_;
      v8 = __p.__end_;
    }
    else
    {
      v23 = 0;
    }
    v24 = (unsigned int *)&v23[4 * v19];
    v25 = (unsigned int *)&v23[4 * v22];
    *v24 = 8;
    v17 = v24 + 1;
    while (v8 != v18)
    {
      v26 = *--v8;
      *--v24 = v26;
    }
    __p.__begin_ = v24;
    __p.__end_ = v17;
    __p.__end_cap_.__value_ = v25;
    if (v18)
      operator delete(v18);
  }
  else
  {
    *v8 = 8;
    v17 = v8 + 1;
  }
  __p.__end_ = v17;
  std::allocate_shared[abi:ne180100]<Phase::Geometry::Shape,std::allocator<Phase::Geometry::Shape>,Phase::Geometry::Shape&,std::vector<unsigned int> &,void>(a1, (__int32 **)&__p, a3);
  v27 = **(_QWORD **)(a1 + 120);
  v28 = *a3;
  v29 = operator new();
  *(_QWORD *)v29 = Phase::GetTypeId<Phase::Geometry::VoxelTree>;
  *(_QWORD *)(v29 + 8) = v28;
  *(_OWORD *)(v29 + 16) = 0u;
  *(_OWORD *)(v29 + 32) = 0u;
  *(_QWORD *)(v29 + 48) = -1;
  v30 = v28 + 15;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize((uint64_t *)v28 + 15, 1uLL);
  v31 = (uint64_t *)(v28 + 12);
  v59[0] = &off_24D57DE68;
  v60 = v59;
  v57 = v29;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v58, (uint64_t)v59);
  v32 = v60;
  if (v60 == v59)
  {
    v33 = 4;
    v32 = v59;
  }
  else
  {
    if (!v60)
      goto LABEL_39;
    v33 = 5;
  }
  (*(void (**)(void))(*v32 + 8 * v33))();
LABEL_39:
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100](*v30, &v57);
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v57);
  v34 = *(_QWORD *)(v27 + 48);
  *(_QWORD *)(v29 + 40) = v31;
  *(_QWORD *)(v29 + 48) = v34;
  v35 = 16 * v34;
  v36 = *(_QWORD **)(**(_QWORD **)(v27 + 40) + 16 * v34);
  v37 = v36[3];
  if (v37)
  {
    v38 = 0;
    v39 = v36[4];
    v40 = *v31;
    v41 = *(_QWORD *)(*v31 + v35);
    v42 = *(_QWORD *)(v41 + 32);
    do
    {
      v43 = v36[1] + v38 * v39;
      v44 = *(_QWORD *)(v41 + 8) + v38 * v42;
      *(_QWORD *)(v44 + 40) = v31;
      v45 = *(_QWORD **)(**(_QWORD **)(v43 + 40) + 16 * *(_QWORD *)(v43 + 48));
      v46 = v45[3];
      if (v46)
      {
        v47 = 0;
        v48 = 0;
        v49 = v45[4];
        v50 = *(_QWORD *)(v40 + 16 * *(_QWORD *)(v44 + 48));
        v51 = *(_QWORD *)(v50 + 32);
        do
        {
          v52 = (_QWORD *)(*(_QWORD *)(v50 + 8) + v48);
          v53 = v45[1] + v47;
          v54 = *(_QWORD *)(v53 + 48);
          v52[5] = v31;
          v52[6] = v54;
          v55 = *(_QWORD *)(v53 + 64);
          v52[7] = v31;
          v52[8] = v55;
          v48 += v51;
          v47 += v49;
          --v46;
        }
        while (v46);
      }
      ++v38;
    }
    while (v38 != v37);
  }
  Phase::Geometry::SetMaterialsFromOptionalMaterialList(*a3, a2);
  (*a3)[2] = *(uint64_t **)(a1 + 16);
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }
}

void sub_2165DB6B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t *Phase::Geometry::GetVoxelTreeDebugInfo@<X0>(Phase::Logger *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int32x4_t v26;
  uint64_t v27;
  uint64_t i;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  NSObject *v38;
  std::logic_error *v39;
  NSObject *v40;
  std::logic_error *exception;
  uint64_t v42;
  _BYTE v43[32];
  uint64_t v44;
  _BYTE v45[12];
  __int16 v46;
  int v47;
  _BYTE buf[18];
  _BYTE *v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  v3 = **((_QWORD **)a1 + 15);
  *a2 = 0;
  a2[4] = 0;
  v4 = a2 + 4;
  a2[5] = 0;
  v5 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v3 + 40) + 16 * *(_QWORD *)(v3 + 48)) + 24);
  if (!v5)
  {
    v40 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 112);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v45 = 136315394;
      *(_QWORD *)&v45[4] = "ManagedPtr.hpp";
      v46 = 1024;
      v47 = 229;
      _os_log_impl(&dword_2164CC000, v40, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [inCount == 0 is true]: \"Attempting to allocate an array of 0 elements\"", v45, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempting to allocate an array of 0 elements");
  }
  v6 = operator new(48 * v5, (std::align_val_t)8uLL);
  v7 = v6;
  do
  {
    *v7 = 0;
    v7[4] = 0;
    v7[5] = 0;
    v7 += 6;
  }
  while (v7 != &v6[6 * v5]);
  *(_QWORD *)buf = &off_24D57DEB0;
  *(_QWORD *)&buf[8] = v5;
  v49 = buf;
  *(_QWORD *)v45 = v6;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v45[8], (uint64_t)buf);
  v8 = v49;
  if (v49 == buf)
  {
    v9 = 4;
    v8 = buf;
  }
  else
  {
    if (!v49)
      goto LABEL_9;
    v9 = 5;
  }
  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_9:
  v10 = *(_QWORD *)v45;
  *(_QWORD *)v45 = 0;
  v42 = v10;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v43, (uint64_t)&v45[8]);
  v44 = v5;
  std::unique_ptr<Phase::Geometry::VoxelTreeDebugInfo::VoxelSubtreeDebugInfo [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v45);
  v11 = v42;
  v42 = 0;
  v12 = *a2;
  *a2 = v11;
  if (v12)
  {
    *(_QWORD *)v45 = v12;
    if (!*v4)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(_QWORD, _BYTE *))(*(_QWORD *)*v4 + 48))(*v4, v45);
  }
  std::__function::__value_func<double ()(double)>::operator=[abi:ne180100](a2 + 1, (uint64_t)v43);
  a2[5] = v44;
  result = std::unique_ptr<Phase::Geometry::VoxelTreeDebugInfo::VoxelSubtreeDebugInfo [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v42);
  if (a2[5])
  {
    v14 = 0;
    while (1)
    {
      v15 = *(_QWORD *)(**(_QWORD **)(v3 + 40) + 16 * *(_QWORD *)(v3 + 48));
      v16 = *(_QWORD *)(v15 + 8) + *(_QWORD *)(v15 + 32) * v14;
      v17 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v16 + 40) + 16 * *(_QWORD *)(v16 + 48)) + 24);
      if (!v17)
      {
        v38 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)result) + 112);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "ManagedPtr.hpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 229;
          _os_log_impl(&dword_2164CC000, v38, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [inCount == 0 is true]: \"Attempting to allocate an array of 0 elements\"", buf, 0x12u);
        }
        v39 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v39, "Attempting to allocate an array of 0 elements");
      }
      v18 = operator new(48 * v17, (std::align_val_t)0x10uLL);
      *(_QWORD *)buf = &off_24D57DEF8;
      buf[8] = 0;
      v49 = buf;
      *(_QWORD *)v45 = v18;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v45[8], (uint64_t)buf);
      v19 = v49;
      if (v49 == buf)
        break;
      if (v49)
      {
        v20 = 5;
LABEL_19:
        (*(void (**)(_QWORD *))(*v19 + 8 * v20))(v19);
      }
      v21 = *(_QWORD *)v45;
      *(_QWORD *)v45 = 0;
      v42 = v21;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v43, (uint64_t)&v45[8]);
      v44 = v17;
      std::unique_ptr<Phase::Geometry::VoxelTreeDebugInfo::VoxelSubtreeDebugInfo::VoxelLevelDebugInfo [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v45);
      v22 = (uint64_t *)(*a2 + 48 * v14);
      v23 = v42;
      v42 = 0;
      v24 = *v22;
      *v22 = v23;
      if (v24)
      {
        *(_QWORD *)v45 = v24;
        v25 = v22[4];
        if (!v25)
          std::__throw_bad_function_call[abi:ne180100]();
        (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v25 + 48))(v25, v45);
      }
      std::__function::__value_func<double ()(double)>::operator=[abi:ne180100](v22 + 1, (uint64_t)v43);
      v22[5] = v44;
      result = std::unique_ptr<Phase::Geometry::VoxelTreeDebugInfo::VoxelSubtreeDebugInfo::VoxelLevelDebugInfo [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v42);
      v27 = 0;
      for (i = 0; i != v17; ++i)
      {
        v29 = *(_QWORD *)(**(_QWORD **)(v3 + 40) + 16 * *(_QWORD *)(v3 + 48));
        v30 = *(_QWORD *)(v29 + 8) + *(_QWORD *)(v29 + 32) * v14;
        v31 = *(_QWORD *)(**(_QWORD **)(v30 + 40) + 16 * *(_QWORD *)(v30 + 48));
        *(float *)v26.i32 = (float)*(unint64_t *)(*(_QWORD *)(v31 + 8) + *(_QWORD *)(v31 + 32) * i);
        v26 = vdupq_lane_s32(*(int32x2_t *)v26.i8, 0);
        *(int32x4_t *)(*(_QWORD *)(*a2 + 48 * v14) + v27 + 32) = v26;
        v32 = *(_QWORD *)(**(_QWORD **)(v3 + 40) + 16 * *(_QWORD *)(v3 + 48));
        v33 = *(_QWORD *)(v32 + 8) + *(_QWORD *)(v32 + 32) * v14;
        v26.i64[0] = *(_QWORD *)v33;
        v26.i32[2] = *(_DWORD *)(v33 + 8);
        *(int32x4_t *)(*(_QWORD *)(*a2 + 48 * v14) + v27) = v26;
        v34 = *(_QWORD *)(**(_QWORD **)(v3 + 40) + 16 * *(_QWORD *)(v3 + 48));
        v35 = *(_QWORD *)(v34 + 8) + *(_QWORD *)(v34 + 32) * v14;
        v36 = *(_QWORD *)(**(_QWORD **)(v35 + 40) + 16 * *(_QWORD *)(v35 + 48));
        v37 = *(_QWORD *)(v36 + 8) + *(_QWORD *)(v36 + 32) * i;
        v26.i64[0] = *(_QWORD *)(v37 + 16);
        v26.i32[2] = *(_DWORD *)(v37 + 24);
        *(int32x4_t *)(*(_QWORD *)(*a2 + 48 * v14) + v27 + 16) = v26;
        v27 += 48;
      }
      if (++v14 >= (unint64_t)a2[5])
        return result;
    }
    v19 = buf;
    v20 = 4;
    goto LABEL_19;
  }
  return result;
}

void sub_2165DBC0C(_Unwind_Exception *a1)
{
  uint64_t *v1;
  void *v2;

  __cxa_free_exception(v2);
  std::unique_ptr<Phase::Geometry::VoxelTreeDebugInfo::VoxelSubtreeDebugInfo [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void std::default_delete<Phase::Geometry::VoxelTreeBuilder::Voxel []>::operator()[abi:ne180100]<Phase::Geometry::VoxelTreeBuilder::Voxel>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (a2)
  {
    v3 = a2 - 8;
    v2 = *(_QWORD *)(a2 - 8);
    if (v2)
    {
      v4 = 24 * v2;
      do
      {
        v5 = *(_QWORD *)(v3 + v4);
        *(_QWORD *)(v3 + v4) = 0;
        if (v5)
          std::default_delete<Phase::Geometry::VoxelTreeBuilder::Voxel []>::operator()[abi:ne180100]<Phase::Geometry::VoxelTreeBuilder::Voxel>();
        v4 -= 24;
      }
      while (v4);
    }
    JUMPOUT(0x2199F9D4CLL);
  }
}

uint64_t *std::unique_ptr<Phase::Geometry::VoxelTreeDebugInfo::VoxelSubtreeDebugInfo::VoxelLevelDebugInfo [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v7;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v7 = v2;
    v3 = a1[4];
    if (!v3)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v7);
  }
  v4 = (uint64_t *)a1[4];
  if (v4 == a1 + 1)
  {
    v5 = 4;
    v4 = a1 + 1;
    goto LABEL_8;
  }
  if (v4)
  {
    v5 = 5;
LABEL_8:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  return a1;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::VoxelTree>(Phase::Geometry::VoxelTree *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::VoxelTree>(Phase::Geometry::VoxelTree *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::VoxelTree>(Phase::Geometry::VoxelTree *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::VoxelTree>(Phase::Geometry::VoxelTree *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57DE68;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::VoxelTree>(Phase::Geometry::VoxelTree *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::VoxelTree>(Phase::Geometry::VoxelTree *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57DE68;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::VoxelTree>(Phase::Geometry::VoxelTree *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::VoxelTree>(Phase::Geometry::VoxelTree *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
    JUMPOUT(0x2199F9D70);
  return result;
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry18VoxelTreeDebugInfo21VoxelSubtreeDebugInfoERKZNS3_10AllocArrayIS7_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS8_IS7_EESG_mmEUlPSA_E_EESG_mOT0_OT1_EUlSD_E_NS_9allocatorISS_EESE_ED0Ev()
{
  JUMPOUT(0x2199F9D70);
}

__n128 _ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry18VoxelTreeDebugInfo21VoxelSubtreeDebugInfoERKZNS3_10AllocArrayIS7_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS8_IS7_EESG_mmEUlPSA_E_EESG_mOT0_OT1_EUlSD_E_NS_9allocatorISS_EESE_E7__cloneEv(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24D57DEB0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry18VoxelTreeDebugInfo21VoxelSubtreeDebugInfoERKZNS3_10AllocArrayIS7_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS8_IS7_EESG_mmEUlPSA_E_EESG_mOT0_OT1_EUlSD_E_NS_9allocatorISS_EESE_E7__cloneEPNS0_6__baseISE_EE(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24D57DEB0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry18VoxelTreeDebugInfo21VoxelSubtreeDebugInfoERKZNS3_10AllocArrayIS7_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS8_IS7_EESG_mmEUlPSA_E_EESG_mOT0_OT1_EUlSD_E_NS_9allocatorISS_EESE_EclEOSD_(uint64_t a1, void **a2)
{
  void *v2;
  unint64_t v4;
  uint64_t *v5;

  v2 = *a2;
  if (*(_QWORD *)(a1 + 8))
  {
    v4 = 0;
    v5 = (uint64_t *)*a2;
    do
    {
      ++v4;
      v5 = std::unique_ptr<Phase::Geometry::VoxelTreeDebugInfo::VoxelSubtreeDebugInfo::VoxelLevelDebugInfo [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](v5)
         + 6;
    }
    while (v4 < *(_QWORD *)(a1 + 8));
  }
  operator delete(v2);
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry18VoxelTreeDebugInfo21VoxelSubtreeDebugInfo19VoxelLevelDebugInfoERKZNS3_10AllocArrayIS8_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS9_IS8_EESH_mmEUlPSB_E_EESH_mOT0_OT1_EUlSE_E_NS_9allocatorIST_EESF_ED0Ev()
{
  JUMPOUT(0x2199F9D70);
}

_BYTE *_ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry18VoxelTreeDebugInfo21VoxelSubtreeDebugInfo19VoxelLevelDebugInfoERKZNS3_10AllocArrayIS8_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS9_IS8_EESH_mmEUlPSB_E_EESH_mOT0_OT1_EUlSE_E_NS_9allocatorIST_EESF_E7__cloneEv(uint64_t a1)
{
  _BYTE *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = &off_24D57DEF8;
  result[8] = *(_BYTE *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry18VoxelTreeDebugInfo21VoxelSubtreeDebugInfo19VoxelLevelDebugInfoERKZNS3_10AllocArrayIS8_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS9_IS8_EESH_mmEUlPSB_E_EESH_mOT0_OT1_EUlSE_E_NS_9allocatorIST_EESF_E7__cloneEPNS0_6__baseISF_EE(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24D57DEF8;
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(result + 8);
  return result;
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry18VoxelTreeDebugInfo21VoxelSubtreeDebugInfo19VoxelLevelDebugInfoERKZNS3_10AllocArrayIS8_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS9_IS8_EESH_mmEUlPSB_E_EESH_mOT0_OT1_EUlSE_E_NS_9allocatorIST_EESF_EclEOSE_(uint64_t a1, void **a2)
{
  operator delete(*a2);
}

unint64_t Phase::Geometry::VoxelTreeBuilder::Build(uint64_t a1, int a2, id **this, unint64_t a4)
{
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  unint64_t result;
  int v21;
  unint64_t i;
  _DWORD v23[2];
  float v24;
  float v25;
  float v26;
  float v27;

  Phase::Geometry::MdlMeshReader::CalculateAABB(this, (uint64_t)v23);
  v7 = *(float *)v23;
  v8 = *(float *)&v23[1];
  *(_DWORD *)a1 = v23[0];
  *(float *)(a1 + 4) = v8;
  v9 = v24;
  v10 = v25;
  *(float *)(a1 + 8) = v24;
  *(float *)(a1 + 12) = v10;
  v11 = v26;
  v12 = v27;
  *(float *)(a1 + 16) = v26;
  *(float *)(a1 + 20) = v12;
  if (a4 <= 3)
    __assert_rtn("ExpandAABB", "GeoVoxelTreeBuilder.cpp", 49, "inResolution >= 4");
  v13 = (float)(0.5 / (float)(a4 - 1)) * fmaxf(fmaxf(v10 - v7, v11 - v8), v12 - v9);
  v14 = v7 - v13;
  v15 = v8 - v13;
  *(float *)a1 = v14;
  *(float *)(a1 + 4) = v15;
  v16 = v9 - v13;
  v17 = v10 + v13;
  *(float *)(a1 + 8) = v16;
  *(float *)(a1 + 12) = v17;
  v18 = v11 + v13;
  v19 = v12 + v13;
  *(float *)(a1 + 16) = v18;
  *(float *)(a1 + 20) = v19;
  *(float *)(a1 + 24) = v14;
  *(float *)(a1 + 28) = v15;
  *(float *)(a1 + 32) = v16;
  *(float *)(a1 + 36) = v17;
  *(float *)(a1 + 40) = v18;
  *(float *)(a1 + 44) = v19;
  *(_QWORD *)(a1 + 56) = a4;
  *(_DWORD *)(a1 + 92) = 0;
  Phase::Geometry::VoxelTreeBuilder::CreateLevels((Phase::Geometry::VoxelTreeBuilder *)a1);
  result = Phase::MdlMeshAsset::GetSubmeshCount(this);
  if (result)
  {
    for (i = 0; i < result; ++i)
    {
      Phase::Geometry::VoxelTreeBuilder::BuildLevels((float32x2_t *)a1, v21, this, i);
      result = Phase::MdlMeshAsset::GetSubmeshCount(this);
    }
  }
  return result;
}

void Phase::Geometry::VoxelTreeBuilder::CreateLevels(Phase::Geometry::VoxelTreeBuilder *this)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  float v6;
  float *v7;
  uint64_t v8;

  v2 = 0;
  v3 = *((_QWORD *)this + 7);
  *((float *)this + 12) = fmaxf(fmaxf((float)(*((float *)this + 3) - *(float *)this) / (float)v3, (float)(*((float *)this + 4) - *((float *)this + 1)) / (float)v3), (float)(*((float *)this + 5) - *((float *)this + 2)) / (float)v3);
  v4 = 1;
  while (1 << v2 != v3)
  {
    ++v4;
    v2 += 2;
    if (v2 == 64)
      __assert_rtn("PowerOfFour", "GeoVoxelTreeBuilder.cpp", 35, "false");
  }
  std::vector<Phase::Geometry::VoxelTreeBuilder::Level>::resize((uint64_t)this + 96, v4);
  v5 = 0;
  v6 = *((float *)this + 12);
  v7 = (float *)(*((_QWORD *)this + 12) + 16);
  v8 = 1;
  do
  {
    *(v7 - 4) = v6 * (float)(1 << v2);
    *((_QWORD *)v7 - 1) = v8;
    *(_QWORD *)v7 = v5;
    v8 *= 4;
    ++v5;
    v7 += 8;
    LODWORD(v2) = v2 - 2;
  }
  while (v4 != v5);
  *((_DWORD *)this + 22) = 0;
}

unint64_t Phase::Geometry::VoxelTreeBuilder::BuildLevels(float32x2_t *a1, int a2, id **this, uint64_t a4)
{
  unint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;

  result = objc_msgSend(Phase::MdlMeshAsset::GetSubmesh(this, a4), "indexCount");
  if (result >= 3)
  {
    v10 = 0;
    v11 = result / 3;
    do
      result = Phase::Geometry::VoxelTreeBuilder::VoxelizeFace(a1, v8, (uint64_t)this, a4, v10++, v9, (float *)&a1[11]);
    while (v11 != v10);
  }
  return result;
}

void std::vector<Phase::Geometry::VoxelTreeBuilder::Level>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 5;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 32 * a2;
  }
  else
  {
    std::vector<Phase::Geometry::VoxelTreeBuilder::Level>::__append((char **)a1, a2 - v2);
  }
}

uint64_t Phase::Geometry::VoxelTreeBuilder::VoxelizeFace(float32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, float *a7)
{
  __int32 v8;
  uint64_t result;
  float v11;
  double v12;
  double v13;
  float v14;
  double v15;
  double v16;
  float32x2_t v17;
  float32x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  double v22;
  double v23;
  double v24;
  float64_t v25;
  double v26;
  double v27;
  double v28;
  int32x2_t v29;
  unsigned int v30;
  int32x2_t v31;
  unsigned int v32;
  float64x2_t v33;
  double v34;
  float64x2_t v35;
  double v36;
  float64x2_t v37;
  double v38;
  float64x2_t v39;
  double v40;
  float v41;
  float32x2_t v42[4];
  uint64_t v43;
  uint64_t v44;

  v8 = a4;
  v43 = 0;
  v44 = 0;
  memset(v42, 0, sizeof(v42));
  v41 = 0.0;
  result = Phase::Geometry::MdlMeshReader::GetTriangle<unsigned int>(a3, a4, 3 * a5, (_DWORD *)&v44 + 1, &v44, (unsigned int *)&v43 + 1, (uint64_t)v42, &v41);
  if ((_DWORD)result)
  {
    v11 = a1[1].f32[0];
    v36 = (float)(v42[1].f32[0] - v11);
    v38 = (float)(v42[2].f32[1] - v11);
    v40 = (float)(*(float *)&v43 - v11);
    v12 = fmin(fmin(v36, v38), v40);
    v13 = fmax(fmax(v36, v38), v40);
    v14 = v41 + *a7;
    v15 = v38 - v36;
    v16 = v40 - v36;
    v17 = vsub_f32(*(float32x2_t *)((char *)&v42[1] + 4), *a1);
    v18 = vsub_f32(v42[3], *a1);
    v19 = vcvtq_f64_f32(vsub_f32(v42[0], *a1));
    v35 = v19;
    v20 = vcvtq_f64_f32(v17);
    v37 = v20;
    v21 = vcvtq_f64_f32(v18);
    v39 = v21;
    *a7 = v14;
    v22 = 1.0 / a1[6].f32[0];
    v23 = vsubq_f64(v20, v19).f64[0];
    v24 = vsubq_f64(v21, v19).f64[0];
    v25 = (v20.f64[1] - v19.f64[1]) * v16 - v15 * (v21.f64[1] - v19.f64[1]);
    v26 = vmlad_n_f64(-(v23 * v16), v15, v24);
    v27 = vmlad_n_f64(-(v20.f64[1] - v19.f64[1]) * v24, v21.f64[1] - v19.f64[1], v23);
    v28 = sqrt(v27 * v27 + v25 * v25 + v26 * v26);
    v33.f64[0] = v25 / v28;
    v33.f64[1] = v26 / v28;
    v34 = v27 / v28;
    v31 = vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vmulq_n_f64(vminnmq_f64(vminnmq_f64(v19, v20), v21), v22))));
    v32 = vcvtmd_s64_f64(v12 * v22);
    v29 = vmovn_s64(vcvtq_s64_f64(vrndpq_f64(vmulq_n_f64(vmaxnmq_f64(vmaxnmq_f64(v19, v20), v21), v22))));
    v30 = vcvtpd_s64_f64(v13 * v22);
    return Phase::Geometry::VoxelTreeBuilder::UpdateVoxel((uint64_t)a1, a1 + 8, v35.f64, &v33, v8, 0, (int *)&v31, (int *)&v29);
  }
  else
  {
    ++a1[11].i32[1];
  }
  return result;
}

uint64_t Phase::Geometry::VoxelTreeBuilder::UpdateVoxel(uint64_t result, float32x2_t *a2, double *a3, float64x2_t *a4, __int32 a5, uint64_t a6, int *a7, int *a8)
{
  __int128 v8;
  __int128 v9;
  uint64_t v13;
  float v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  __int32 v19;
  int *v20;
  int *v21;
  _OWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  float *v31;
  int v32;
  int v33;
  double v34;
  int v35;
  int v36;
  int v37;
  double v38;
  BOOL v39;
  double v40;
  uint64_t v41;
  int v42;
  double v43;
  __int128 v44;
  int v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  double v60;
  BOOL v61;
  double v62;
  double v63;
  double v68;
  double v69;
  double v70;
  double v71;
  double v72;
  double v73;
  double v74;
  double v75;
  double v76;
  double v77;
  float v78;
  float v79;
  float v80;
  float v81;
  double v82;
  double v83;
  double v84;
  double v85;
  double v86;
  double v87;
  double v88;
  double v89;
  double v90;
  float v92;
  float v93;
  double v94;
  double v95;
  double v96;
  double v97;
  double v98;
  double v99;
  double v100;
  BOOL v101;
  double v102;
  double v103;
  double v104;
  double v105;
  double v106;
  double v109;
  float v110;
  float v111;
  float v112;
  float v113;
  double v114;
  double v115;
  double v116;
  double v117;
  double v118;
  double v119;
  double v120;
  double v121;
  double v122;
  double v124;
  double v125;
  float v126;
  float v127;
  double v128;
  double v129;
  double v130;
  double v131;
  double v132;
  double v133;
  double v134;
  BOOL v135;
  double v136;
  double v137;
  double v138;
  double v139;
  double v140;
  float v143;
  float v144;
  float v145;
  float v146;
  double v147;
  double v148;
  double v149;
  double v150;
  double v151;
  double v152;
  double v153;
  float v154;
  float v155;
  double v156;
  double v157;
  double v158;
  double v159;
  double v160;
  double v161;
  double v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  uint64_t v166;
  int v167;
  int v168;
  int v169;
  int v170;
  int v171;
  uint64_t *v172;
  int *v173;
  int *v174;
  uint64_t v175;
  uint64_t v176;
  __int32 v177;

  v13 = *(_QWORD *)(result + 96);
  if (a2[1].i32[1] == -1)
  {
    ++*(_QWORD *)(v13 + 32 * a6 + 24);
    a2[1].i32[1] = a5;
  }
  *a2 = vadd_f32(*a2, vcvt_f32_f64(*a4));
  v14 = a4[1].f64[0];
  a2[1].f32[0] = a2[1].f32[0] + v14;
  v15 = ((*(_QWORD *)(result + 104) - v13) >> 5) - 1;
  if (v15 != a6)
  {
    v16 = (uint64_t *)&a2[2];
    if (!*(_QWORD *)&a2[2])
    {
      v17 = result;
      v18 = (uint64_t *)&a2[2];
      v19 = a5;
      v20 = a7;
      v21 = a8;
      v22 = (_OWORD *)operator new[]();
      v23 = v22 + 97;
      *v22 = xmmword_2166F8500;
      v24 = v22 + 1;
      v25 = v24;
      do
      {
        *v25 = 0;
        v25[1] = 0xFFFFFFFF00000000;
        v25[2] = 0;
        v25 += 3;
      }
      while (v25 != v23);
      v16 = v18;
      v26 = *v18;
      *v18 = (uint64_t)v24;
      if (v26)
      {
        std::default_delete<Phase::Geometry::VoxelTreeBuilder::Voxel []>::operator()[abi:ne180100]<Phase::Geometry::VoxelTreeBuilder::Voxel>((uint64_t)v18, v26);
        v16 = v18;
      }
      result = v17;
      v13 = *(_QWORD *)(v17 + 96);
      a8 = v21;
      a7 = v20;
      a5 = v19;
    }
    v27 = a6 + 1;
    v28 = 2 * (v15 - (a6 + 1));
    v29 = *a7 >> (2 * (v15 - (a6 + 1)));
    v30 = *a8 >> (2 * (v15 - (a6 + 1)));
    if (v29 <= v30)
    {
      v31 = (float *)(v13 + 32 * v27);
      v32 = a7[1] >> v28;
      v33 = a7[2] >> v28;
      v34 = *v31 * 0.5;
      v35 = a8[2] >> v28;
      v36 = a8[1] >> v28;
      v37 = ~(-1 << v28);
      v38 = -v34;
      do
      {
        if (v32 <= v36)
        {
          v40 = (double)v29 + 0.5;
          v41 = v29 & 3;
          LODWORD(v8) = v29 << v28;
          LODWORD(v9) = (v29 << v28) + v37;
          v42 = v32;
          do
          {
            if (v33 <= v35)
            {
              v43 = (double)v42 + 0.5;
              v44 = v8;
              DWORD1(v44) = v42 << v28;
              v45 = v33;
              do
              {
                v46 = *v31;
                v47 = v43 * v46;
                v48 = ((double)v45 + 0.5) * v46;
                v49 = *a3 - v40 * v46;
                v50 = a3[1] - v43 * v46;
                v51 = a3[2] - v48;
                v52 = a3[3] - v40 * v46;
                v53 = a3[4] - v43 * v46;
                v54 = a3[5] - v48;
                v55 = a3[6] - v40 * v46;
                v56 = a3[7] - v47;
                v57 = a3[8] - v48;
                v58 = fmax(fmax(v49, v52), v55);
                v59 = fmin(fmin(v51, v54), v57);
                v60 = fmax(fmax(v51, v54), v57);
                v61 = fmin(fmin(v49, v52), v55) > v34 || v58 < v38;
                v62 = fmax(fmax(v50, v53), v56);
                v63 = fmin(fmin(v50, v53), v56);
                if (!v61 && v63 <= v34 && v62 >= v38 && v59 <= v34 && v60 >= v38)
                {
                  v68 = a4->f64[0];
                  v69 = a4->f64[1];
                  v70 = a4[1].f64[0];
                  v71 = v49 * a4->f64[0] + v50 * v69 + v51 * v70;
                  v72 = a4->f64[0] <= 0.0 ? v34 : -v34;
                  v73 = v69 <= 0.0 ? v34 : -v34;
                  v74 = v70 <= 0.0 ? v34 : -v34;
                  if (v68 * v72 + v69 * v73 + v70 * v74 <= v71)
                  {
                    v75 = v70 <= 0.0 ? -v34 : v34;
                    v76 = v69 <= 0.0 ? -v34 : v34;
                    v77 = v68 <= 0.0 ? -v34 : v34;
                    if (v68 * v77 + v69 * v76 + v70 * v75 >= v71)
                    {
                      v78 = v53 - v50;
                      v79 = v54 - v51;
                      v80 = v78 < 0.0 ? -v78 : v53 - v50;
                      v81 = v79 < 0.0 ? -v79 : v54 - v51;
                      v82 = v79;
                      v83 = v78;
                      v84 = v79 * v50 - v51 * v83;
                      v85 = v82 * v56 - v57 * v83;
                      v86 = fmin(v84, v85);
                      v87 = fmax(v84, v85);
                      v88 = v81;
                      v89 = v80;
                      v90 = v34 * v80 + v88 * v34;
                      if (v86 <= v90 && v87 >= -v90)
                      {
                        v92 = v52 - v49;
                        v93 = -v92;
                        if (v92 >= 0.0)
                          v93 = v52 - v49;
                        v94 = v92;
                        v95 = v94 * v51 - v49 * v82;
                        v96 = v94 * v57 - v55 * v82;
                        v97 = fmin(v95, v96);
                        v98 = fmax(v95, v96);
                        v99 = v93;
                        v100 = v34 * v88 + v99 * v34;
                        v101 = v97 > v100 || v98 < -v100;
                        v102 = v83 * v52 - v53 * v94;
                        v103 = v83 * v55 - v56 * v94;
                        v104 = fmin(v102, v103);
                        v105 = fmax(v102, v103);
                        v106 = v34 * v99 + v89 * v34;
                        if (!v101 && v104 <= v106 && v105 >= -v106)
                        {
                          v109 = -v51;
                          v110 = v56 - v53;
                          v111 = v57 - v54;
                          v112 = -v110;
                          if (v110 >= 0.0)
                            v112 = v56 - v53;
                          if (v111 < 0.0)
                            v113 = -v111;
                          else
                            v113 = v57 - v54;
                          v114 = v111;
                          v115 = v110;
                          v116 = v109 * v110 + v114 * v50;
                          v117 = -v57 * v115 + v114 * v56;
                          v118 = fmin(v116, v117);
                          v119 = fmax(v116, v117);
                          v120 = v113;
                          v121 = v112;
                          v122 = v34 * v121 + v120 * v34;
                          if (v118 <= v122 && v119 >= -v122)
                          {
                            v124 = -v49;
                            v125 = -v53;
                            v126 = v55 - v52;
                            v127 = -v126;
                            if (v126 >= 0.0)
                              v127 = v55 - v52;
                            v128 = v126;
                            v129 = v124 * v114 + v128 * v51;
                            v130 = -v55 * v114 + v128 * v57;
                            v131 = fmin(v129, v130);
                            v132 = fmax(v129, v130);
                            v133 = v127;
                            v134 = v34 * v120 + v133 * v34;
                            v135 = v131 > v134 || v132 < -v134;
                            v136 = v115 * v49 - v50 * v128;
                            v137 = v125 * v128 + v115 * v52;
                            v138 = fmin(v136, v137);
                            v139 = fmax(v136, v137);
                            v140 = v34 * v133 + v121 * v34;
                            if (!v135 && v138 <= v140 && v139 >= -v140)
                            {
                              v143 = v50 - v56;
                              v144 = v51 - v57;
                              v145 = v143 < 0.0 ? -v143 : v50 - v56;
                              v146 = v144 < 0.0 ? -v144 : v144;
                              v147 = v144;
                              v148 = v143;
                              v149 = v109 * v143 + v147 * v50;
                              v150 = v147 * v53 - v54 * v143;
                              v151 = v146;
                              v152 = v145;
                              v153 = v34 * v145;
                              if (fmin(v149, v150) <= v153 + v146 * v34 && fmax(v149, v150) >= -(v153 + v151 * v34))
                              {
                                v154 = v49 - v55;
                                if (v154 < 0.0)
                                  v155 = -v154;
                                else
                                  v155 = v154;
                                v156 = v154;
                                v157 = v124 * v147 + v156 * v51;
                                v158 = v156 * v54 - v52 * v147;
                                v159 = v155;
                                v160 = v34 * v151;
                                if (fmin(v157, v158) <= v160 + v155 * v34 && fmax(v157, v158) >= -(v160 + v159 * v34))
                                {
                                  v161 = v125 * v156 + v148 * v52;
                                  v162 = -v56 * v156 + v148 * v55;
                                  if (fmin(v161, v162) <= v34 * v159 + v152 * v34
                                    && fmax(v161, v162) >= -(v34 * v159 + v152 * v34))
                                  {
                                    v170 = v29;
                                    v171 = v28;
                                    v166 = v41;
                                    v173 = a7;
                                    v174 = a8;
                                    v175 = v27;
                                    v176 = result;
                                    v177 = a5;
                                    v172 = v16;
                                    v168 = v32;
                                    v169 = v30;
                                    v167 = v37;
                                    v164 = v9;
                                    v165 = v8;
                                    v163 = v44;
                                    Phase::Geometry::VoxelTreeBuilder::UpdateVoxel();
                                    v44 = v163;
                                    v9 = v164;
                                    v8 = v165;
                                    v41 = v166;
                                    v37 = v167;
                                    v32 = v168;
                                    v30 = v169;
                                    v29 = v170;
                                    v28 = v171;
                                    v27 = v175;
                                    result = v176;
                                    v16 = v172;
                                    a7 = v173;
                                    a5 = v177;
                                    a8 = v174;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                ++v45;
              }
              while (v35 + 1 != v45);
            }
            v39 = v42++ == v36;
          }
          while (!v39);
        }
        v39 = v29++ == v30;
      }
      while (!v39);
    }
  }
  return result;
}

void std::vector<Phase::Geometry::VoxelTreeBuilder::Level>::__append(char **a1, unint64_t a2)
{
  char *v4;
  char *v5;
  char *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  __int128 v15;

  v5 = a1[1];
  v4 = a1[2];
  if (a2 <= (v4 - v5) >> 5)
  {
    if (a2)
    {
      bzero(a1[1], 32 * a2);
      v5 += 32 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    v6 = *a1;
    v7 = v5 - *a1;
    v8 = a2 + (v7 >> 5);
    if (v8 >> 59)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v9 = v4 - v6;
    if (v9 >> 4 > v8)
      v8 = v9 >> 4;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0)
      v10 = 0x7FFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if (v10)
    {
      if (v10 >> 59)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v11 = (char *)operator new(32 * v10);
    }
    else
    {
      v11 = 0;
    }
    v12 = &v11[32 * (v7 >> 5)];
    v13 = &v11[32 * v10];
    bzero(v12, 32 * a2);
    v14 = &v12[32 * a2];
    if (v5 != v6)
    {
      do
      {
        v15 = *((_OWORD *)v5 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v5 - 2);
        *((_OWORD *)v12 - 1) = v15;
        v12 -= 32;
        v5 -= 32;
      }
      while (v5 != v6);
      v5 = *a1;
    }
    *a1 = v12;
    a1[1] = v14;
    a1[2] = v13;
    if (v5)
      operator delete(v5);
  }
}

Phase::Controller::Ducker *Phase::Controller::Ducker::Ducker(Phase::Controller::Ducker *this, PHASEDucker *a2, double a3)
{
  PHASEDucker *v5;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  double v15;
  void *v16;
  id v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  Phase *v21;
  NSString *v22;
  uint64_t StringHashId;
  id v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  Phase *v28;
  NSString *v29;
  uint64_t v30;
  void *v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  _BYTE v41[128];
  _BYTE v42[128];
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  v5 = a2;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 1065353216;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 18) = 1065353216;
  __asm { FMOV            V0.2D, #1.0 }
  *((_OWORD *)this + 5) = _Q0;
  *((_QWORD *)this + 12) = 0x3FF0000000000000;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *(int64x2_t *)((char *)this + 120) = vdupq_n_s64(0x63724C6EuLL);
  *((_BYTE *)this + 136) = 0;
  Phase::Fader<double>::Fader((Phase::Controller::Ducker *)((char *)this + 144), 1.0);
  Phase::Fader<double>::Fader((Phase::Controller::Ducker *)((char *)this + 192), 1.0);
  Phase::Fader<double>::Fader((Phase::Controller::Ducker *)((char *)this + 240), 1.0);
  *((_BYTE *)this + 288) = 0;
  -[PHASEDucker gain](v5, "gain", (char *)this + 240, (char *)this + 192, (char *)this + 144);
  *((_QWORD *)this + 10) = v11;
  -[PHASEDucker gainHighFrequency](v5, "gainHighFrequency");
  *((_QWORD *)this + 11) = v12;
  -[PHASEDucker gainLowFrequency](v5, "gainLowFrequency");
  *((_QWORD *)this + 12) = v13;
  -[PHASEDucker attackTime](v5, "attackTime");
  *((double *)this + 13) = v14 * a3;
  -[PHASEDucker releaseTime](v5, "releaseTime");
  *((double *)this + 14) = v15 * a3;
  *((_QWORD *)this + 15) = -[PHASEDucker attackCurve](v5, "attackCurve");
  *((_QWORD *)this + 16) = -[PHASEDucker releaseCurve](v5, "releaseCurve");
  -[PHASEDucker sourceGroups](v5, "sourceGroups");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  -[PHASEDucker targetGroups](v5, "targetGroups");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::__rehash<true>((uint64_t)this, vcvtps_u32_f32((float)(unint64_t)objc_msgSend(v32, "count") / *((float *)this + 8)));
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::__rehash<true>((uint64_t)this + 40, vcvtps_u32_f32((float)(unint64_t)objc_msgSend(v16, "count") / *((float *)this + 18)));
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v17 = v32;
  v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v37, v42, 16);
  if (v18)
  {
    v19 = *(_QWORD *)v38;
    do
    {
      v20 = 0;
      do
      {
        if (*(_QWORD *)v38 != v19)
          objc_enumerationMutation(v17);
        objc_msgSend(*(id *)(*((_QWORD *)&v37 + 1) + 8 * v20), "identifier");
        v21 = (Phase *)objc_claimAutoreleasedReturnValue();
        StringHashId = Phase::GetStringHashId(v21, v22);
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long>((uint64_t)this, StringHashId, StringHashId);

        ++v20;
      }
      while (v18 != v20);
      v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v37, v42, 16);
    }
    while (v18);
  }

  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v24 = v16;
  v25 = objc_msgSend(v24, "countByEnumeratingWithState:objects:count:", &v33, v41, 16);
  if (v25)
  {
    v26 = *(_QWORD *)v34;
    do
    {
      v27 = 0;
      do
      {
        if (*(_QWORD *)v34 != v26)
          objc_enumerationMutation(v24);
        objc_msgSend(*(id *)(*((_QWORD *)&v33 + 1) + 8 * v27), "identifier");
        v28 = (Phase *)objc_claimAutoreleasedReturnValue();
        v30 = Phase::GetStringHashId(v28, v29);
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long>((uint64_t)this + 40, v30, v30);

        ++v27;
      }
      while (v25 != v27);
      v25 = objc_msgSend(v24, "countByEnumeratingWithState:objects:count:", &v33, v41, 16);
    }
    while (v25);
  }

  return this;
}

void sub_2165DD16C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, void **a10, void **a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void **a30)
{
  uint64_t v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;

  a30 = a9;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&a30);
  a30 = a10;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&a30);
  a30 = a11;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&a30);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v32);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v30);

  _Unwind_Resume(a1);
}

_QWORD *Phase::Controller::Ducker::Release(Phase::Controller::Ducker *this)
{
  _QWORD *result;
  uint64_t v3;
  _QWORD v4[3];
  _QWORD *v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  *((_BYTE *)this + 136) = 1;
  Phase::Controller::GetCurveFunctionFromCurveType<double>(*((Phase::Logger **)this + 16), v4);
  Phase::Fader<double>::SetInternal((uint64_t)this + 144, (uint64_t)v4, *((double *)this + 22), *((double *)this + 14));
  Phase::Fader<double>::SetInternal((uint64_t)this + 192, (uint64_t)v4, *((double *)this + 28), *((double *)this + 14));
  Phase::Fader<double>::SetInternal((uint64_t)this + 240, (uint64_t)v4, *((double *)this + 34), *((double *)this + 14));
  result = v5;
  if (v5 == v4)
  {
    v3 = 4;
    result = v4;
  }
  else
  {
    if (!v5)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_2165DD318(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  _Unwind_Resume(exception_object);
}

__n128 Phase::Controller::GroupManager::GroupManager(Phase::Controller::GroupManager *this)
{
  uint64_t InstancePtr;
  __n128 result;

  InstancePtr = Phase::Logger::GetInstancePtr(this);
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::Commandable((uint64_t)this, *(_QWORD *)(InstancePtr + 656), 1, 0x20000);
  *(_QWORD *)this = off_24D57DF40;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 18) = 1065353216;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_DWORD *)this + 28) = 1065353216;
  *((_QWORD *)this + 15) = 0;
  *((_BYTE *)this + 128) = 0;
  *(_OWORD *)((char *)this + 136) = xmmword_2166F7A20;
  __asm { FMOV            V0.2D, #1.0 }
  *(__n128 *)((char *)this + 152) = result;
  *((_BYTE *)this + 168) = 0;
  *((_QWORD *)this + 22) = 0x3FF0000000000000;
  return result;
}

uint64_t Phase::Controller::GroupManager::AddGroup(Phase::Controller::GroupManager *this, PHASEGroup *a2)
{
  PHASEGroup *v3;
  Phase *v4;
  NSString *v5;
  uint64_t StringHashId;
  char v7;
  uint64_t v9[2];
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void **v19;

  v3 = a2;
  -[PHASEGroup identifier](v3, "identifier");
  v4 = (Phase *)objc_claimAutoreleasedReturnValue();
  StringHashId = Phase::GetStringHashId(v4, v5);

  v18 = StringHashId;
  Phase::Controller::Group::Group((Phase::Controller::Group *)v9, StringHashId, v3);
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Group>>>::__emplace_unique_key_args<unsigned long long,unsigned long long &,Phase::Controller::Group>((uint64_t)this + 40, (unint64_t *)&v18, &v18, v9);
  LOBYTE(this) = v7;
  v19 = (void **)&v17;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v19);
  v19 = (void **)&v16;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v19);
  v19 = (void **)&v15;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v19);
  v19 = (void **)&v14;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v19);
  v19 = (void **)&v13;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v19);
  v19 = (void **)&v12;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v19);
  v19 = (void **)&v11;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v19);
  v19 = (void **)&v10;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v19);

  return this & 1;
}

void sub_2165DD4F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  Phase::Controller::Group::~Group((id *)va);

  _Unwind_Resume(a1);
}

void Phase::Controller::Group::~Group(id *this)
{
  void **v2;
  void **v3;

  v2 = this + 2;
  v3 = this + 47;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = this + 41;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = this + 35;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = this + 29;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = this + 20;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = this + 14;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = this + 8;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = v2;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v3);

}

void Phase::Controller::GroupManager::Update(uint64_t a1, _QWORD *a2, double a3)
{
  uint64_t *v6;
  BOOL i;
  uint64_t *v12;
  int8x8_t v13;
  unint64_t v14;
  uint8x8_t v15;
  _QWORD *v16;
  BOOL v17;
  int8x8_t v18;
  uint8x8_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  unint64_t v24;
  BOOL v25;
  uint64_t *v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t *v30;
  unint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  double *v36;
  int8x8_t v37;
  uint8x8_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  _QWORD *v42;
  unint64_t v43;
  double v44;
  unint64_t v45;
  uint64_t *j;
  int v47;
  uint64_t k;
  __int128 v49;
  _QWORD v50[2];
  char v51;
  _QWORD *v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::ExecuteCommands(a1);
  *(_BYTE *)(a1 + 128) = 0;
  v6 = *(uint64_t **)(a1 + 56);
  if (v6)
  {
    __asm { FMOV            V0.2D, #1.0 }
    v49 = _Q0;
LABEL_4:
    for (i = *((_BYTE *)v6 + 449) != 0; ; i = 1)
    {
      *(_BYTE *)(a1 + 128) = i;
      Phase::Fader<double>::Update((uint64_t)(v6 + 5), a3);
      Phase::Fader<double>::Update((uint64_t)(v6 + 11), a3);
      Phase::Fader<double>::Update((uint64_t)(v6 + 17), a3);
      Phase::Fader<double>::Update((uint64_t)(v6 + 23), a3);
      Phase::Fader<double>::Update((uint64_t)(v6 + 32), a3);
      Phase::Fader<double>::Update((uint64_t)(v6 + 44), a3);
      Phase::Fader<double>::Update((uint64_t)(v6 + 38), a3);
      Phase::Fader<double>::Update((uint64_t)(v6 + 50), a3);
      v6[31] = 0x3FF0000000000000;
      *(_OWORD *)(v6 + 29) = v49;
      v6 = (uint64_t *)*v6;
      if (!v6)
        break;
      if (!*(_BYTE *)(a1 + 128))
        goto LABEL_4;
    }
  }
  v12 = *(uint64_t **)(a1 + 96);
  if (v12)
  {
    do
    {
      if (!*((_BYTE *)v12 + 160) || *((double *)v12 + 26) != *((double *)v12 + 25))
      {
        v16 = (_QWORD *)v12[5];
        v17 = v16 != 0;
        if (v16)
        {
          v18 = (int8x8_t)a2[1];
          v19 = (uint8x8_t)vcnt_s8(v18);
          v19.i16[0] = vaddlv_u8(v19);
          v20 = *(_QWORD *)&v18 - 1;
          do
          {
            if (v18)
            {
              v21 = v16[2];
              if (v19.u32[0] > 1uLL)
              {
                v22 = v16[2];
                if (v21 >= *(_QWORD *)&v18)
                  v22 = v21 % *(_QWORD *)&v18;
              }
              else
              {
                v22 = v20 & v21;
              }
              v23 = *(_QWORD **)(*a2 + 8 * v22);
              if (v23)
              {
                while (1)
                {
                  v23 = (_QWORD *)*v23;
                  if (!v23)
                    break;
                  v24 = v23[1];
                  if (v24 == v21)
                  {
                    if (v23[2] == v21)
                      goto LABEL_31;
                  }
                  else
                  {
                    if (v19.u32[0] > 1uLL)
                    {
                      if (v24 >= *(_QWORD *)&v18)
                        v24 %= *(_QWORD *)&v18;
                    }
                    else
                    {
                      v24 &= v20;
                    }
                    if (v24 != v22)
                      break;
                  }
                }
              }
            }
            v16 = (_QWORD *)*v16;
            v17 = v16 != 0;
          }
          while (v16);
        }
LABEL_31:
        v25 = v17;
        if (*((_BYTE *)v12 + 312) == v17 || *((_BYTE *)v12 + 160) != 0)
          goto LABEL_58;
        if (v17)
        {
          Phase::Controller::GetCurveFunctionFromCurveType<double>((Phase::Logger *)v12[18], v50);
          Phase::Fader<double>::SetInternal((uint64_t)(v12 + 21), (uint64_t)v50, *((double *)v12 + 13), *((double *)v12 + 16));
          Phase::Fader<double>::SetInternal((uint64_t)(v12 + 27), (uint64_t)v50, *((double *)v12 + 14), *((double *)v12 + 16));
          Phase::Fader<double>::SetInternal((uint64_t)(v12 + 33), (uint64_t)v50, *((double *)v12 + 15), *((double *)v12 + 16));
        }
        else
        {
          Phase::Controller::GetCurveFunctionFromCurveType<double>((Phase::Logger *)v12[19], v50);
          Phase::Fader<double>::SetInternal((uint64_t)(v12 + 21), (uint64_t)v50, *((double *)v12 + 25), *((double *)v12 + 17));
          Phase::Fader<double>::SetInternal((uint64_t)(v12 + 27), (uint64_t)v50, *((double *)v12 + 31), *((double *)v12 + 17));
          Phase::Fader<double>::SetInternal((uint64_t)(v12 + 33), (uint64_t)v50, *((double *)v12 + 37), *((double *)v12 + 17));
        }
        v32 = v52;
        if (v52 == v50)
        {
          v32 = v50;
          v33 = 4;
LABEL_56:
          (*(void (**)(void))(*v32 + 8 * v33))();
        }
        else if (v52)
        {
          v33 = 5;
          goto LABEL_56;
        }
        *((_BYTE *)v12 + 312) = v25;
LABEL_58:
        Phase::Fader<double>::Update((uint64_t)(v12 + 21), a3);
        Phase::Fader<double>::Update((uint64_t)(v12 + 27), a3);
        Phase::Fader<double>::Update((uint64_t)(v12 + 33), a3);
        v36 = *(double **)(a1 + 56);
        if (v36)
        {
          v37 = (int8x8_t)v12[9];
          v38 = (uint8x8_t)vcnt_s8(v37);
          v38.i16[0] = vaddlv_u8(v38);
          v39 = *(_QWORD *)&v37 - 1;
          do
          {
            if (v37)
            {
              v40 = *((_QWORD *)v36 + 2);
              if (v38.u32[0] > 1uLL)
              {
                v41 = *((_QWORD *)v36 + 2);
                if (*(_QWORD *)&v37 <= v40)
                  v41 = v40 % *(_QWORD *)&v37;
              }
              else
              {
                v41 = v39 & v40;
              }
              v42 = *(_QWORD **)(v12[8] + 8 * v41);
              if (v42)
              {
                while (1)
                {
                  v42 = (_QWORD *)*v42;
                  if (!v42)
                    break;
                  v43 = v42[1];
                  if (v43 == v40)
                  {
                    if (v42[2] == v40)
                    {
                      v44 = v36[30];
                      v36[29] = fmin(v36[29], *((double *)v12 + 26));
                      v36[31] = fmin(v36[31], *((double *)v12 + 32));
                      v36[30] = fmin(v44, *((double *)v12 + 38));
                      break;
                    }
                  }
                  else
                  {
                    if (v38.u32[0] > 1uLL)
                    {
                      if (v43 >= *(_QWORD *)&v37)
                        v43 %= *(_QWORD *)&v37;
                    }
                    else
                    {
                      v43 &= v39;
                    }
                    if (v43 != v41)
                      break;
                  }
                }
              }
            }
            v36 = *(double **)v36;
          }
          while (v36);
        }
        v27 = (uint64_t *)*v12;
        goto LABEL_89;
      }
      v13 = *(int8x8_t *)(a1 + 88);
      v14 = v12[1];
      v15 = (uint8x8_t)vcnt_s8(v13);
      v15.i16[0] = vaddlv_u8(v15);
      if (v15.u32[0] > 1uLL)
      {
        if (v14 >= *(_QWORD *)&v13)
          v14 %= *(_QWORD *)&v13;
      }
      else
      {
        v14 &= *(_QWORD *)&v13 - 1;
      }
      v27 = (uint64_t *)*v12;
      v28 = *(_QWORD *)(a1 + 80);
      v29 = *(uint64_t **)(v28 + 8 * v14);
      do
      {
        v30 = v29;
        v29 = (uint64_t *)*v29;
      }
      while (v29 != v12);
      if (v30 == (uint64_t *)(a1 + 96))
        goto LABEL_96;
      v31 = v30[1];
      if (v15.u32[0] > 1uLL)
      {
        if (v31 >= *(_QWORD *)&v13)
          v31 %= *(_QWORD *)&v13;
      }
      else
      {
        v31 &= *(_QWORD *)&v13 - 1;
      }
      v34 = *v12;
      if (v31 != v14)
      {
LABEL_96:
        if (v27)
        {
          v35 = v27[1];
          if (v15.u32[0] > 1uLL)
          {
            if (v35 >= *(_QWORD *)&v13)
              v35 %= *(_QWORD *)&v13;
          }
          else
          {
            v35 &= *(_QWORD *)&v13 - 1;
          }
          v34 = *v12;
          if (v35 == v14)
          {
LABEL_82:
            v45 = *(_QWORD *)(v34 + 8);
            if (v15.u32[0] > 1uLL)
            {
              if (v45 >= *(_QWORD *)&v13)
                v45 %= *(_QWORD *)&v13;
            }
            else
            {
              v45 &= *(_QWORD *)&v13 - 1;
            }
            if (v45 != v14)
            {
              *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v45) = v30;
              v34 = *v12;
            }
            goto LABEL_88;
          }
        }
        *(_QWORD *)(v28 + 8 * v14) = 0;
        v34 = *v12;
      }
      if (v34)
        goto LABEL_82;
LABEL_88:
      *v30 = v34;
      *v12 = 0;
      --*(_QWORD *)(a1 + 104);
      v50[0] = v12;
      v50[1] = a1 + 96;
      v51 = 1;
      std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,void *>>>>::reset[abi:ne180100]((uint64_t)v50);
LABEL_89:
      v12 = v27;
    }
    while (v27);
  }
  for (j = *(uint64_t **)(a1 + 56); j; j = (uint64_t *)*j)
  {
    v47 = -2128831035;
    for (k = 40; k != 456; ++k)
      v47 = 16777619 * (v47 ^ *((char *)j + k));
    *((_DWORD *)j + 114) = v47;
  }
}

void sub_2165DDB4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char *a15)
{
  char *v16;
  uint64_t v17;

  v16 = a15;
  if (a15 == &a12)
  {
    v17 = 4;
    v16 = &a12;
  }
  else
  {
    if (!a15)
      goto LABEL_6;
    v17 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v16 + 8 * v17))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

double Phase::Controller::GroupManager::GetGain(Phase::Controller::GroupManager *this, unint64_t a2)
{
  double *v3;
  double result;
  unint64_t v5;

  v5 = a2;
  v3 = (double *)std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>((_QWORD *)this + 5, &v5);
  if (v3)
  {
    if (*((_BYTE *)v3 + 449))
      return v3[10] * v3[37] * v3[29];
    result = 0.0;
    if (!*((_BYTE *)v3 + 448) && !*((_BYTE *)this + 128))
      return v3[10] * v3[37] * v3[29];
  }
  else
  {
    result = 0.0;
    if (!*((_BYTE *)this + 128))
      return 1.0;
  }
  return result;
}

_QWORD *Phase::Controller::GroupManager::SetGain(Phase::Controller::GroupManager *this, unint64_t a2, double a3, double a4, Phase::Logger *a5)
{
  _QWORD *result;
  uint64_t v10;
  double v11;
  uint64_t v12;
  unint64_t v13;
  _QWORD v14[3];
  _QWORD *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  result = std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>((_QWORD *)this + 5, &v13);
  v10 = (uint64_t)result;
  if (result)
  {
    v11 = *((double *)this + 22);
    Phase::Controller::GetCurveFunctionFromCurveType<double>(a5, v14);
    Phase::Fader<double>::SetInternal(v10 + 40, (uint64_t)v14, a3, v11 * a4);
    result = v15;
    if (v15 == v14)
    {
      v12 = 4;
      result = v14;
    }
    else
    {
      if (!v15)
        return result;
      v12 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v12))();
  }
  return result;
}

void sub_2165DDCF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *Phase::Controller::GroupManager::SetGainHighFreq(Phase::Controller::GroupManager *this, unint64_t a2, double a3, double a4, Phase::Logger *a5)
{
  _QWORD *result;
  uint64_t v10;
  double v11;
  uint64_t v12;
  unint64_t v13;
  _QWORD v14[3];
  _QWORD *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  result = std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>((_QWORD *)this + 5, &v13);
  v10 = (uint64_t)result;
  if (result)
  {
    v11 = *((double *)this + 22);
    Phase::Controller::GetCurveFunctionFromCurveType<double>(a5, v14);
    Phase::Fader<double>::SetInternal(v10 + 88, (uint64_t)v14, a3, v11 * a4);
    result = v15;
    if (v15 == v14)
    {
      v12 = 4;
      result = v14;
    }
    else
    {
      if (!v15)
        return result;
      v12 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v12))();
  }
  return result;
}

void sub_2165DDE18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *Phase::Controller::GroupManager::SetGainLowFreq(Phase::Controller::GroupManager *this, unint64_t a2, double a3, double a4, Phase::Logger *a5)
{
  _QWORD *result;
  uint64_t v10;
  double v11;
  uint64_t v12;
  unint64_t v13;
  _QWORD v14[3];
  _QWORD *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  result = std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>((_QWORD *)this + 5, &v13);
  v10 = (uint64_t)result;
  if (result)
  {
    v11 = *((double *)this + 22);
    Phase::Controller::GetCurveFunctionFromCurveType<double>(a5, v14);
    Phase::Fader<double>::SetInternal(v10 + 136, (uint64_t)v14, a3, v11 * a4);
    result = v15;
    if (v15 == v14)
    {
      v12 = 4;
      result = v14;
    }
    else
    {
      if (!v15)
        return result;
      v12 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v12))();
  }
  return result;
}

void sub_2165DDF38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *Phase::Controller::GroupManager::SetRate(Phase::Controller::GroupManager *this, unint64_t a2, double a3, double a4, Phase::Logger *a5)
{
  _QWORD *result;
  uint64_t v10;
  double v11;
  uint64_t v12;
  unint64_t v13;
  _QWORD v14[3];
  _QWORD *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  result = std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>((_QWORD *)this + 5, &v13);
  v10 = (uint64_t)result;
  if (result)
  {
    v11 = *((double *)this + 22);
    Phase::Controller::GetCurveFunctionFromCurveType<double>(a5, v14);
    Phase::Fader<double>::SetInternal(v10 + 184, (uint64_t)v14, a3, v11 * a4);
    result = v15;
    if (v15 == v14)
    {
      v12 = 4;
      result = v14;
    }
    else
    {
      if (!v15)
        return result;
      v12 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v12))();
  }
  return result;
}

void sub_2165DE058(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::GroupManager::StartDuck(Phase::Controller::GroupManager *this, PHASEDucker *a2)
{
  PHASEDucker *v3;
  Phase *v4;
  NSString *v5;
  char v6;
  _BYTE v8[40];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t StringHashId;
  void **v14;

  v3 = a2;
  -[PHASEDucker identifier](v3, "identifier");
  v4 = (Phase *)objc_claimAutoreleasedReturnValue();
  StringHashId = Phase::GetStringHashId(v4, v5);
  Phase::Controller::Ducker::Ducker((Phase::Controller::Ducker *)v8, v3, *((double *)this + 22));
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>>>::__emplace_unique_key_args<unsigned long long,unsigned long long,Phase::Controller::Ducker>((uint64_t)this + 80, (unint64_t *)&StringHashId, &StringHashId, (uint64_t)v8);
  LOBYTE(this) = v6;
  v14 = (void **)&v12;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v14);
  v14 = (void **)&v11;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v14);
  v14 = (void **)&v10;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v14);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)&v9);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)v8);

  return this & 1;
}

void sub_2165DE164(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  va_list va;

  va_start(va, a2);
  Phase::Controller::Ducker::~Ducker((Phase::Controller::Ducker *)va);

  _Unwind_Resume(a1);
}

void Phase::Controller::Ducker::~Ducker(Phase::Controller::Ducker *this)
{
  void **v2;

  v2 = (void **)((char *)this + 240);
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (void **)((char *)this + 192);
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (void **)((char *)this + 144);
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v2);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)this + 40);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)this);
}

BOOL Phase::Controller::GroupManager::ReleaseDuck(Phase::Controller::GroupManager *this, PHASEDucker *a2)
{
  PHASEDucker *v3;
  Phase *v4;
  NSString *v5;
  _QWORD *v6;
  uint64_t StringHashId;

  v3 = a2;
  -[PHASEDucker identifier](v3, "identifier");
  v4 = (Phase *)objc_claimAutoreleasedReturnValue();
  StringHashId = Phase::GetStringHashId(v4, v5);
  v6 = std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>((_QWORD *)this + 10, (unint64_t *)&StringHashId);

  if (v6)
    Phase::Controller::Ducker::Release((Phase::Controller::Ducker *)(v6 + 3));

  return v6 != 0;
}

void sub_2165DE274(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::GroupManager::SetPreset(uint64_t a1, void *a2, uint64_t a3, char a4)
{
  id v7;
  void *v8;
  uint64_t v9;
  double v10;
  double v11;
  double *i;
  void **v13;
  uint64_t v14;
  void **v15;
  uint64_t v16;
  void **v17;
  uint64_t v18;
  void **v19;
  uint64_t v20;
  NSString *v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  Phase *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  double v30;
  void **v31;
  uint64_t v32;
  double v33;
  void **v34;
  uint64_t v35;
  double v36;
  void **v37;
  uint64_t v38;
  double v39;
  void **v40;
  uint64_t v41;
  double v42;
  double *v43;
  double v44;
  void **v45;
  uint64_t v46;
  void **v47;
  uint64_t v48;
  void **v49;
  uint64_t v50;
  void **v51;
  uint64_t v52;
  id obj;
  void *v55;
  uint64_t StringHashId;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  _BYTE v61[128];
  void *v62;
  uint64_t (*v63)();
  void **v64;
  uint64_t v65;

  v65 = *MEMORY[0x24BDAC8D0];
  v7 = a2;
  v55 = v7;
  if (v7)
  {
    v8 = v7;
    objc_msgSend(v7, "timeToReset");
    *(_QWORD *)(a1 + 120) = v9;
    objc_msgSend(v8, "timeToTarget");
    if (a4)
      v10 = *(double *)&a3;
    v11 = v10 * *(double *)(a1 + 176);
    for (i = *(double **)(a1 + 56); i; i = *(double **)i)
    {
      v62 = &unk_24D5770F0;
      v63 = Phase::CurveFunction::Linear<double>;
      v64 = &v62;
      Phase::Fader<double>::SetInternal((uint64_t)(i + 32), (uint64_t)&v62, i[36], v11);
      v13 = v64;
      if (v64 == &v62)
      {
        v13 = &v62;
        v14 = 4;
      }
      else
      {
        if (!v64)
          goto LABEL_10;
        v14 = 5;
      }
      (*((void (**)(void))*v13 + v14))();
LABEL_10:
      v62 = &unk_24D5770F0;
      v63 = Phase::CurveFunction::Linear<double>;
      v64 = &v62;
      Phase::Fader<double>::SetInternal((uint64_t)(i + 44), (uint64_t)&v62, i[48], v11);
      v15 = v64;
      if (v64 == &v62)
      {
        v15 = &v62;
        v16 = 4;
      }
      else
      {
        if (!v64)
          goto LABEL_15;
        v16 = 5;
      }
      (*((void (**)(void))*v15 + v16))();
LABEL_15:
      v62 = &unk_24D5770F0;
      v63 = Phase::CurveFunction::Linear<double>;
      v64 = &v62;
      Phase::Fader<double>::SetInternal((uint64_t)(i + 38), (uint64_t)&v62, i[42], v11);
      v17 = v64;
      if (v64 == &v62)
      {
        v17 = &v62;
        v18 = 4;
      }
      else
      {
        if (!v64)
          goto LABEL_20;
        v18 = 5;
      }
      (*((void (**)(void))*v17 + v18))();
LABEL_20:
      v62 = &unk_24D5770F0;
      v63 = Phase::CurveFunction::Linear<double>;
      v64 = &v62;
      Phase::Fader<double>::SetInternal((uint64_t)(i + 50), (uint64_t)&v62, i[54], v11);
      v19 = v64;
      if (v64 == &v62)
      {
        v19 = &v62;
        v20 = 4;
        goto LABEL_24;
      }
      if (v64)
      {
        v20 = 5;
LABEL_24:
        (*((void (**)(void))*v19 + v20))();
      }
    }
    v59 = 0u;
    v60 = 0u;
    v57 = 0u;
    v58 = 0u;
    objc_msgSend(v55, "settings");
    obj = (id)objc_claimAutoreleasedReturnValue();
    v22 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v57, v61, 16);
    if (!v22)
      goto LABEL_55;
    v23 = (_QWORD *)(a1 + 40);
    v24 = *(_QWORD *)v58;
LABEL_28:
    v25 = 0;
    while (1)
    {
      if (*(_QWORD *)v58 != v24)
        objc_enumerationMutation(obj);
      v26 = *(Phase **)(*((_QWORD *)&v57 + 1) + 8 * v25);
      StringHashId = 0;
      StringHashId = Phase::GetStringHashId(v26, v21);
      v27 = std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>(v23, (unint64_t *)&StringHashId);
      if (!v27)
        goto LABEL_53;
      objc_msgSend(v55, "settings");
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v28, "objectForKey:", v26);
      v29 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(v29, "gain");
      v62 = &unk_24D5770F0;
      v63 = Phase::CurveFunction::Linear<double>;
      v64 = &v62;
      Phase::Fader<double>::SetInternal((uint64_t)(v27 + 32), (uint64_t)&v62, v30, v11);
      v31 = v64;
      if (v64 == &v62)
      {
        v31 = &v62;
        v32 = 4;
      }
      else
      {
        if (!v64)
          goto LABEL_37;
        v32 = 5;
      }
      (*((void (**)(void))*v31 + v32))();
LABEL_37:
      objc_msgSend(v29, "gainHighFrequency");
      v62 = &unk_24D5770F0;
      v63 = Phase::CurveFunction::Linear<double>;
      v64 = &v62;
      Phase::Fader<double>::SetInternal((uint64_t)(v27 + 44), (uint64_t)&v62, v33, v11);
      v34 = v64;
      if (v64 == &v62)
      {
        v34 = &v62;
        v35 = 4;
      }
      else
      {
        if (!v64)
          goto LABEL_42;
        v35 = 5;
      }
      (*((void (**)(void))*v34 + v35))();
LABEL_42:
      objc_msgSend(v29, "gainLowFrequency");
      v62 = &unk_24D5770F0;
      v63 = Phase::CurveFunction::Linear<double>;
      v64 = &v62;
      Phase::Fader<double>::SetInternal((uint64_t)(v27 + 38), (uint64_t)&v62, v36, v11);
      v37 = v64;
      if (v64 == &v62)
      {
        v37 = &v62;
        v38 = 4;
      }
      else
      {
        if (!v64)
          goto LABEL_47;
        v38 = 5;
      }
      (*((void (**)(void))*v37 + v38))();
LABEL_47:
      objc_msgSend(v29, "rate");
      v62 = &unk_24D5770F0;
      v63 = Phase::CurveFunction::Linear<double>;
      v64 = &v62;
      Phase::Fader<double>::SetInternal((uint64_t)(v27 + 50), (uint64_t)&v62, v39, v11);
      v40 = v64;
      if (v64 == &v62)
      {
        v40 = &v62;
        v41 = 4;
        goto LABEL_51;
      }
      if (v64)
      {
        v41 = 5;
LABEL_51:
        (*((void (**)(void))*v40 + v41))();
      }

LABEL_53:
      if (v22 == ++v25)
      {
        v22 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v57, v61, 16);
        if (!v22)
        {
LABEL_55:

          goto LABEL_81;
        }
        goto LABEL_28;
      }
    }
  }
  if (!a4)
    a3 = *(uint64_t *)(a1 + 120);
  v42 = *(double *)(a1 + 176);
  *(_QWORD *)(a1 + 120) = 0;
  v43 = *(double **)(a1 + 56);
  if (v43)
  {
    v44 = *(double *)&a3 * v42;
    do
    {
      v62 = &unk_24D5770F0;
      v63 = Phase::CurveFunction::Linear<double>;
      v64 = &v62;
      Phase::Fader<double>::SetInternal((uint64_t)(v43 + 32), (uint64_t)&v62, v43[36], v44);
      v45 = v64;
      if (v64 == &v62)
      {
        v45 = &v62;
        v46 = 4;
      }
      else
      {
        if (!v64)
          goto LABEL_65;
        v46 = 5;
      }
      (*((void (**)(void))*v45 + v46))();
LABEL_65:
      v62 = &unk_24D5770F0;
      v63 = Phase::CurveFunction::Linear<double>;
      v64 = &v62;
      Phase::Fader<double>::SetInternal((uint64_t)(v43 + 44), (uint64_t)&v62, v43[48], v44);
      v47 = v64;
      if (v64 == &v62)
      {
        v47 = &v62;
        v48 = 4;
      }
      else
      {
        if (!v64)
          goto LABEL_70;
        v48 = 5;
      }
      (*((void (**)(void))*v47 + v48))();
LABEL_70:
      v62 = &unk_24D5770F0;
      v63 = Phase::CurveFunction::Linear<double>;
      v64 = &v62;
      Phase::Fader<double>::SetInternal((uint64_t)(v43 + 38), (uint64_t)&v62, v43[42], v44);
      v49 = v64;
      if (v64 == &v62)
      {
        v49 = &v62;
        v50 = 4;
      }
      else
      {
        if (!v64)
          goto LABEL_75;
        v50 = 5;
      }
      (*((void (**)(void))*v49 + v50))();
LABEL_75:
      v62 = &unk_24D5770F0;
      v63 = Phase::CurveFunction::Linear<double>;
      v64 = &v62;
      Phase::Fader<double>::SetInternal((uint64_t)(v43 + 50), (uint64_t)&v62, v43[54], v44);
      v51 = v64;
      if (v64 == &v62)
      {
        v51 = &v62;
        v52 = 4;
        goto LABEL_79;
      }
      if (v64)
      {
        v52 = 5;
LABEL_79:
        (*((void (**)(void))*v51 + v52))();
      }
      v43 = *(double **)v43;
    }
    while (v43);
  }
LABEL_81:

  return 1;
}

void sub_2165DE880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11)
{

  _Unwind_Resume(a1);
}

double Phase::Controller::GroupManager::SetUnitsPerSecond(Phase::Controller::GroupManager *this, double a2)
{
  double v3;
  double v4;
  double result;

  v3 = Phase::Controller::sClamp<double>(this, a2, *((double *)this + 17), *((double *)this + 18));
  v4 = *((double *)this + 20);
  if (v3 != v4)
  {
    *((double *)this + 20) = v3;
    *((_BYTE *)this + 168) = 1;
    v4 = v3;
  }
  result = 1.0 / v4;
  *((double *)this + 22) = 1.0 / v4;
  return result;
}

void Phase::Controller::GroupManager::~GroupManager(Phase::Controller::GroupManager *this)
{
  char *v2;

  *(_QWORD *)this = off_24D57DF40;
  v2 = (char *)this + 40;
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>>>::~__hash_table((uint64_t)this + 80);
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Group>>>::~__hash_table((uint64_t)v2);
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::~Commandable(this);
}

{
  char *v2;

  *(_QWORD *)this = off_24D57DF40;
  v2 = (char *)this + 40;
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>>>::~__hash_table((uint64_t)this + 80);
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Group>>>::~__hash_table((uint64_t)v2);
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::~Commandable(this);
  JUMPOUT(0x2199F9D70);
}

Phase::Controller::Group *Phase::Controller::Group::Group(Phase::Controller::Group *this, uint64_t a2, PHASEGroup *a3)
{
  PHASEGroup *v5;
  PHASEGroup *v6;

  v5 = a3;
  *(_QWORD *)this = a2;
  v6 = v5;
  *((_QWORD *)this + 1) = v6;
  Phase::Controller::Group::DiffableState::DiffableState((Phase::Controller::Group *)((char *)this + 16));
  *((_DWORD *)this + 108) = 0;

  return this;
}

void sub_2165DEAA8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;

  _Unwind_Resume(a1);
}

Phase::Controller::Group::DiffableState *Phase::Controller::Group::DiffableState::DiffableState(Phase::Controller::Group::DiffableState *this)
{
  Phase::Logger *v2;

  v2 = Phase::Fader<double>::Fader(this, 1.0);
  Phase::Fader<double>::Fader((Phase::Logger *)((char *)v2 + 48), 1.0);
  Phase::Fader<double>::Fader((Phase::Controller::Group::DiffableState *)((char *)this + 96), 1.0);
  Phase::Fader<double>::Fader((Phase::Controller::Group::DiffableState *)((char *)this + 144), 1.0);
  __asm { FMOV            V0.2D, #1.0 }
  *((_OWORD *)this + 12) = _Q0;
  *((_QWORD *)this + 26) = 0x3FF0000000000000;
  Phase::Fader<double>::Fader((Phase::Controller::Group::DiffableState *)((char *)this + 216), 1.0);
  Phase::Fader<double>::Fader((Phase::Controller::Group::DiffableState *)((char *)this + 264), 1.0);
  Phase::Fader<double>::Fader((Phase::Controller::Group::DiffableState *)((char *)this + 312), 1.0);
  Phase::Fader<double>::Fader((Phase::Controller::Group::DiffableState *)((char *)this + 360), 1.0);
  *((_WORD *)this + 204) = 0;
  return this;
}

void sub_2165DEB88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  void **v10;
  void **v11;

  v11 = v10;
  a10 = v11;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&a10);
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&a10);
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&a10);
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&a10);
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&a10);
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&a10);
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

void sub_2165DEC0C()
{
  JUMPOUT(0x2165DEBECLL);
}

void sub_2165DEC14()
{
  JUMPOUT(0x2165DEBF8);
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD *v9;
  _QWORD *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = (_QWORD *)*v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2)
            return;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = operator new(0x18uLL);
  *v12 = 0;
  v12[1] = a2;
  v12[2] = a3;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::__rehash<true>(a1, v18);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2)
        v3 = a2 % v7;
      else
        v3 = a2;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v20)
  {
    *v12 = *v20;
LABEL_38:
    *v20 = v12;
    goto LABEL_39;
  }
  *v12 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v12;
  *(_QWORD *)(v19 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    v21 = *(_QWORD *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7)
        v21 %= v7;
    }
    else
    {
      v21 &= v7 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
}

void sub_2165DEE0C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Group>>>::~__hash_table(uint64_t a1)
{
  id *v2;
  id *v3;
  void *v4;

  v2 = *(id **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (id *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<unsigned long long const,Phase::Controller::Group>,0>(v2 + 2);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void std::__destroy_at[abi:ne180100]<std::pair<unsigned long long const,Phase::Controller::Group>,0>(id *a1)
{
  void **v2;
  void **v3;

  v2 = a1 + 3;
  v3 = a1 + 48;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = a1 + 42;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = a1 + 36;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = a1 + 30;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = a1 + 21;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = a1 + 15;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = a1 + 9;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = v2;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v3);

}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>>>::~__hash_table(uint64_t a1)
{
  void **v2;
  void **v3;
  void *v4;

  v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (void **)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<unsigned long long const,Phase::Controller::Ducker>,0>(v2 + 2);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

uint64_t std::__destroy_at[abi:ne180100]<std::pair<unsigned long long const,Phase::Controller::Ducker>,0>(void **a1)
{
  uint64_t v2;
  void **v4;

  v2 = (uint64_t)(a1 + 1);
  v4 = a1 + 31;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v4);
  v4 = a1 + 25;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v4);
  v4 = a1 + 19;
  std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v4);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)(a1 + 6));
  return std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v2);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Group>>>::__emplace_unique_key_args<unsigned long long,unsigned long long &,Phase::Controller::Group>(uint64_t a1, unint64_t *a2, _QWORD *a3, uint64_t *a4)
{
  unint64_t v4;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  _OWORD *v14;
  _QWORD *v15;
  char *v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  float v22;
  float v23;
  _BOOL8 v24;
  unint64_t v25;
  unint64_t v26;
  int8x8_t prime;
  void *v28;
  void *v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  uint8x8_t v33;
  unint64_t v34;
  uint8x8_t v35;
  uint64_t v36;
  _QWORD *v37;
  unint64_t v38;
  _QWORD *v39;
  unint64_t v40;
  void *v42;
  _QWORD v43[2];
  char v44;

  v8 = *a2;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v8 >= v9)
        v4 = v8 % v9;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
    v11 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
    if (v11)
    {
      v12 = (_QWORD *)*v11;
      if (*v11)
      {
        do
        {
          v13 = v12[1];
          if (v13 == v8)
          {
            if (v12[2] == v8)
              return v12;
          }
          else
          {
            if (v10.u32[0] > 1uLL)
            {
              if (v13 >= v9)
                v13 %= v9;
            }
            else
            {
              v13 &= v9 - 1;
            }
            if (v13 != v4)
              break;
          }
          v12 = (_QWORD *)*v12;
        }
        while (v12);
      }
    }
  }
  v14 = a4 + 35;
  v15 = (_QWORD *)(a1 + 16);
  v16 = (char *)operator new(0x1D0uLL);
  v43[0] = v16;
  v43[1] = a1 + 16;
  *(_QWORD *)v16 = 0;
  *((_QWORD *)v16 + 1) = v8;
  *((_QWORD *)v16 + 2) = *a3;
  v17 = *a4;
  v18 = *(_OWORD *)(a4 + 3);
  *((_OWORD *)v16 + 2) = *(_OWORD *)(a4 + 1);
  *((_OWORD *)v16 + 3) = v18;
  *((_QWORD *)v16 + 10) = a4[7];
  *((_OWORD *)v16 + 4) = *(_OWORD *)(a4 + 5);
  *(_OWORD *)(v16 + 88) = *((_OWORD *)a4 + 4);
  *((_QWORD *)v16 + 13) = a4[10];
  *((_OWORD *)v16 + 7) = *(_OWORD *)(a4 + 11);
  *((_QWORD *)v16 + 16) = a4[13];
  *(_OWORD *)(v16 + 136) = *((_OWORD *)a4 + 7);
  *((_QWORD *)v16 + 19) = a4[16];
  v19 = *(_OWORD *)(a4 + 17);
  *((_QWORD *)v16 + 22) = a4[19];
  *((_OWORD *)v16 + 10) = v19;
  *(_OWORD *)(v16 + 184) = *((_OWORD *)a4 + 10);
  *((_QWORD *)v16 + 25) = a4[22];
  v20 = *(_OWORD *)(a4 + 23);
  *((_QWORD *)v16 + 28) = a4[25];
  *((_OWORD *)v16 + 13) = v20;
  v21 = *((_OWORD *)a4 + 13);
  *((_QWORD *)v16 + 31) = a4[28];
  *(_OWORD *)(v16 + 232) = v21;
  *((_OWORD *)v16 + 16) = *(_OWORD *)(a4 + 29);
  *((_QWORD *)v16 + 34) = a4[31];
  *((_QWORD *)v16 + 37) = a4[34];
  *((_OWORD *)v16 + 19) = *v14;
  *((_QWORD *)v16 + 40) = a4[37];
  *((_QWORD *)v16 + 43) = a4[40];
  *((_OWORD *)v16 + 22) = *(_OWORD *)(a4 + 41);
  *((_QWORD *)v16 + 46) = a4[43];
  *((_QWORD *)v16 + 49) = a4[46];
  *((_OWORD *)v16 + 25) = *(_OWORD *)(a4 + 47);
  *((_QWORD *)v16 + 52) = a4[49];
  *((_QWORD *)v16 + 55) = a4[52];
  *((_WORD *)v16 + 224) = *((_WORD *)a4 + 212);
  *((_DWORD *)v16 + 114) = *((_DWORD *)a4 + 108);
  *((_QWORD *)v16 + 3) = v17;
  v16 += 24;
  a4[1] = 0;
  a4[2] = 0;
  a4[3] = 0;
  a4[4] = 0;
  a4[9] = 0;
  a4[10] = 0;
  a4[8] = 0;
  a4[14] = 0;
  a4[15] = 0;
  a4[16] = 0;
  a4[20] = 0;
  a4[21] = 0;
  a4[22] = 0;
  a4[29] = 0;
  a4[30] = 0;
  a4[31] = 0;
  *((_OWORD *)v16 + 16) = *((_OWORD *)a4 + 16);
  *(_QWORD *)v14 = 0;
  a4[36] = 0;
  a4[37] = 0;
  *((_OWORD *)v16 + 19) = *((_OWORD *)a4 + 19);
  a4[41] = 0;
  a4[42] = 0;
  a4[43] = 0;
  *((_OWORD *)v16 + 22) = *((_OWORD *)a4 + 22);
  a4[47] = 0;
  a4[48] = 0;
  a4[49] = 0;
  *((_OWORD *)v16 + 25) = *((_OWORD *)a4 + 25);
  v44 = 1;
  v22 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v23 = *(float *)(a1 + 32);
  if (!v9 || (float)(v23 * (float)v9) < v22)
  {
    v24 = v9 < 3 || (v9 & (v9 - 1)) != 0;
    v25 = v24 | (2 * v9);
    v26 = vcvtps_u32_f32(v22 / v23);
    if (v25 <= v26)
      prime = (int8x8_t)v26;
    else
      prime = (int8x8_t)v25;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v9 = *(_QWORD *)(a1 + 8);
    if (*(_QWORD *)&prime > v9)
      goto LABEL_31;
    if (*(_QWORD *)&prime < v9)
    {
      v34 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v9 < 3 || (v35 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v35.i16[0] = vaddlv_u8(v35), v35.u32[0] > 1uLL))
      {
        v34 = std::__next_prime(v34);
      }
      else
      {
        v36 = 1 << -(char)__clz(v34 - 1);
        if (v34 >= 2)
          v34 = v36;
      }
      if (*(_QWORD *)&prime <= v34)
        prime = (int8x8_t)v34;
      if (*(_QWORD *)&prime >= v9)
      {
        v9 = *(_QWORD *)(a1 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_31:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v28 = operator new(8 * *(_QWORD *)&prime);
          v29 = *(void **)a1;
          *(_QWORD *)a1 = v28;
          if (v29)
            operator delete(v29);
          v30 = 0;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v30++) = 0;
          while (*(_QWORD *)&prime != v30);
          v31 = (_QWORD *)*v15;
          if (*v15)
          {
            v32 = v31[1];
            v33 = (uint8x8_t)vcnt_s8(prime);
            v33.i16[0] = vaddlv_u8(v33);
            if (v33.u32[0] > 1uLL)
            {
              if (v32 >= *(_QWORD *)&prime)
                v32 %= *(_QWORD *)&prime;
            }
            else
            {
              v32 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v32) = v15;
            v37 = (_QWORD *)*v31;
            if (*v31)
            {
              do
              {
                v38 = v37[1];
                if (v33.u32[0] > 1uLL)
                {
                  if (v38 >= *(_QWORD *)&prime)
                    v38 %= *(_QWORD *)&prime;
                }
                else
                {
                  v38 &= *(_QWORD *)&prime - 1;
                }
                if (v38 != v32)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v38))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v38) = v31;
                    goto LABEL_56;
                  }
                  *v31 = *v37;
                  *v37 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v38);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v38) = v37;
                  v37 = v31;
                }
                v38 = v32;
LABEL_56:
                v31 = v37;
                v37 = (_QWORD *)*v37;
                v32 = v38;
              }
              while (v37);
            }
          }
          v9 = (unint64_t)prime;
          goto LABEL_60;
        }
        v42 = *(void **)a1;
        *(_QWORD *)a1 = 0;
        if (v42)
          operator delete(v42);
        v9 = 0;
        *(_QWORD *)(a1 + 8) = 0;
      }
    }
LABEL_60:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v4 = v8 % v9;
      else
        v4 = v8;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
  }
  v39 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v39)
  {
    *(_QWORD *)v43[0] = *v39;
    *v39 = v43[0];
  }
  else
  {
    *(_QWORD *)v43[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v43[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = v15;
    if (*(_QWORD *)v43[0])
    {
      v40 = *(_QWORD *)(*(_QWORD *)v43[0] + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v40 >= v9)
          v40 %= v9;
      }
      else
      {
        v40 &= v9 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v40) = v43[0];
    }
  }
  v12 = (_QWORD *)v43[0];
  v43[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::Group>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::Group>,void *>>>>::reset[abi:ne180100]((uint64_t)v43, 0);
  return v12;
}

void sub_2165DF578(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::Group>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::Group>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::Group>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::Group>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  id *v2;

  v2 = *(id **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<unsigned long long const,Phase::Controller::Group>,0>(v2 + 2);
    operator delete(v2);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Group>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Group>>>::__erase_unique<unsigned long long>(_QWORD *a1, unint64_t *a2)
{
  uint64_t result;
  _BYTE v4[24];

  result = (uint64_t)std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>>>::remove(a1, (_QWORD *)result, (uint64_t)v4);
    std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::Group>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::Group>,void *>>>>::reset[abi:ne180100]((uint64_t)v4, 0);
    return 1;
  }
  return result;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void **v1;

  v1 = *(void ***)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<unsigned long long const,Phase::Controller::Ducker>,0>(v1 + 2);
    operator delete(v1);
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>>>::__emplace_unique_key_args<unsigned long long,unsigned long long,Phase::Controller::Ducker>(uint64_t a1, unint64_t *a2, _QWORD *a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  _QWORD *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  float v20;
  float v21;
  _BOOL8 v22;
  unint64_t v23;
  unint64_t v24;
  int8x8_t prime;
  void *v26;
  void *v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  uint8x8_t v31;
  unint64_t v32;
  uint8x8_t v33;
  uint64_t v34;
  _QWORD *v35;
  unint64_t v36;
  _QWORD *v37;
  unint64_t v38;
  void *v40;
  _QWORD v41[2];
  char v42;

  v8 = *a2;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v8 >= v9)
        v4 = v8 % v9;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == v8)
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4)
            break;
        }
      }
    }
  }
  v14 = (_QWORD *)(a1 + 16);
  v15 = (char *)operator new(0x140uLL);
  v41[0] = v15;
  v41[1] = a1 + 16;
  *(_QWORD *)v15 = 0;
  *((_QWORD *)v15 + 1) = v8;
  *((_QWORD *)v15 + 2) = *a3;
  std::__hash_table<std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::Parameter<double>>>>::__hash_table((uint64_t)(v15 + 24), (uint64_t *)a4);
  std::__hash_table<std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::Parameter<double>>>>::__hash_table((uint64_t)(v15 + 64), (uint64_t *)(a4 + 40));
  v16 = *(_OWORD *)(a4 + 96);
  *(_OWORD *)(v15 + 104) = *(_OWORD *)(a4 + 80);
  *(_OWORD *)(v15 + 120) = v16;
  *(_OWORD *)(v15 + 136) = *(_OWORD *)(a4 + 112);
  *(_OWORD *)(v15 + 145) = *(_OWORD *)(a4 + 121);
  *(_OWORD *)(v15 + 168) = *(_OWORD *)(a4 + 144);
  *((_QWORD *)v15 + 23) = *(_QWORD *)(a4 + 160);
  *(_QWORD *)(a4 + 144) = 0;
  *(_QWORD *)(a4 + 152) = 0;
  *(_QWORD *)(a4 + 160) = 0;
  *((_OWORD *)v15 + 12) = *(_OWORD *)(a4 + 168);
  *((_QWORD *)v15 + 26) = *(_QWORD *)(a4 + 184);
  v18 = *(_OWORD *)(a4 + 240);
  v17 = a4 + 240;
  *(_OWORD *)(v15 + 216) = *(_OWORD *)(v17 - 48);
  *((_QWORD *)v15 + 29) = *(_QWORD *)(v17 - 32);
  *(_QWORD *)(v17 - 40) = 0;
  *(_QWORD *)(v17 - 32) = 0;
  *(_QWORD *)(v17 - 48) = 0;
  *((_OWORD *)v15 + 15) = *(_OWORD *)(v17 - 24);
  *((_QWORD *)v15 + 32) = *(_QWORD *)(v17 - 8);
  *(_OWORD *)(v15 + 264) = v18;
  *((_QWORD *)v15 + 35) = *(_QWORD *)(v17 + 16);
  *(_QWORD *)v17 = 0;
  *(_QWORD *)(v17 + 8) = 0;
  *(_QWORD *)(v17 + 16) = 0;
  v19 = *(_OWORD *)(v17 + 24);
  *((_QWORD *)v15 + 38) = *(_QWORD *)(v17 + 40);
  *((_OWORD *)v15 + 18) = v19;
  v15[312] = *(_BYTE *)(v17 + 48);
  v42 = 1;
  v20 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v21 = *(float *)(a1 + 32);
  if (!v9 || (float)(v21 * (float)v9) < v20)
  {
    v22 = v9 < 3 || (v9 & (v9 - 1)) != 0;
    v23 = v22 | (2 * v9);
    v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24)
      prime = (int8x8_t)v24;
    else
      prime = (int8x8_t)v23;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v9 = *(_QWORD *)(a1 + 8);
    if (*(_QWORD *)&prime > v9)
      goto LABEL_31;
    if (*(_QWORD *)&prime < v9)
    {
      v32 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v9 < 3 || (v33 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        v32 = std::__next_prime(v32);
      }
      else
      {
        v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2)
          v32 = v34;
      }
      if (*(_QWORD *)&prime <= v32)
        prime = (int8x8_t)v32;
      if (*(_QWORD *)&prime >= v9)
      {
        v9 = *(_QWORD *)(a1 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_31:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v26 = operator new(8 * *(_QWORD *)&prime);
          v27 = *(void **)a1;
          *(_QWORD *)a1 = v26;
          if (v27)
            operator delete(v27);
          v28 = 0;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v28++) = 0;
          while (*(_QWORD *)&prime != v28);
          v29 = (_QWORD *)*v14;
          if (*v14)
          {
            v30 = v29[1];
            v31 = (uint8x8_t)vcnt_s8(prime);
            v31.i16[0] = vaddlv_u8(v31);
            if (v31.u32[0] > 1uLL)
            {
              if (v30 >= *(_QWORD *)&prime)
                v30 %= *(_QWORD *)&prime;
            }
            else
            {
              v30 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v30) = v14;
            v35 = (_QWORD *)*v29;
            if (*v29)
            {
              do
              {
                v36 = v35[1];
                if (v31.u32[0] > 1uLL)
                {
                  if (v36 >= *(_QWORD *)&prime)
                    v36 %= *(_QWORD *)&prime;
                }
                else
                {
                  v36 &= *(_QWORD *)&prime - 1;
                }
                if (v36 != v30)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v36))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v36) = v29;
                    goto LABEL_56;
                  }
                  *v29 = *v35;
                  *v35 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v36);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v36) = v35;
                  v35 = v29;
                }
                v36 = v30;
LABEL_56:
                v29 = v35;
                v35 = (_QWORD *)*v35;
                v30 = v36;
              }
              while (v35);
            }
          }
          v9 = (unint64_t)prime;
          goto LABEL_60;
        }
        v40 = *(void **)a1;
        *(_QWORD *)a1 = 0;
        if (v40)
          operator delete(v40);
        v9 = 0;
        *(_QWORD *)(a1 + 8) = 0;
      }
    }
LABEL_60:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v4 = v8 % v9;
      else
        v4 = v8;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
  }
  v37 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  i = (_QWORD *)v41[0];
  if (v37)
  {
    *(_QWORD *)v41[0] = *v37;
LABEL_73:
    *v37 = i;
    goto LABEL_74;
  }
  *(_QWORD *)v41[0] = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = v14;
  if (*i)
  {
    v38 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v38 >= v9)
        v38 %= v9;
    }
    else
    {
      v38 &= v9 - 1;
    }
    v37 = (_QWORD *)(*(_QWORD *)a1 + 8 * v38);
    goto LABEL_73;
  }
LABEL_74:
  v41[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,void *>>>>::reset[abi:ne180100]((uint64_t)v41);
  return i;
}

void sub_2165DFB30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::Ducker>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void *Phase::HeapAllocator::Destroy(Phase::HeapAllocator *this)
{
  unsigned int v2;
  int v3;
  Phase::VirtualAllocator *v4;
  void *result;

  v2 = *((_DWORD *)this + 8);
  if ((v2 & 0x10) != 0)
    Phase::SpinLock::Lock((unsigned __int8 *)this);
  v3 = (v2 >> 4) & 1;
  v4 = (Phase::VirtualAllocator *)*((_QWORD *)this + 118);
  if (v4)
  {
    Phase::VirtualAllocator::DecommitPages(v4, (const void *)*((unsigned int *)this + 239));
    Phase::VirtualAllocator::ReleaseAddressSpace(*((Phase::VirtualAllocator **)this + 118), (const void *)*((unsigned int *)this + 238));
  }
  *((_QWORD *)this + 15) = 0;
  *((_DWORD *)this + 32) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 68) = 0u;
  *((_QWORD *)this + 11) = 0;
  *((_OWORD *)this + 6) = 0u;
  *((_DWORD *)this + 28) = 0;
  *((_QWORD *)this + 1) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 0;
  result = memset((char *)this + 132, 255, 0x280uLL);
  *(_OWORD *)((char *)this + 776) = 0u;
  *((_DWORD *)this + 198) = 0;
  *((_OWORD *)this + 50) = 0u;
  *((_OWORD *)this + 51) = 0u;
  *((_OWORD *)this + 52) = 0u;
  *((_OWORD *)this + 53) = 0u;
  *((_OWORD *)this + 54) = 0u;
  *((_OWORD *)this + 55) = 0u;
  *((_OWORD *)this + 56) = 0u;
  *((_OWORD *)this + 57) = 0u;
  *((_OWORD *)this + 58) = 0u;
  *((_OWORD *)this + 59) = 0u;
  *((_OWORD *)this + 60) = 0u;
  *((_QWORD *)this + 122) = 0;
  if (v3)
    atomic_store(0, (unsigned __int8 *)this);
  return result;
}

void sub_2165DFC04(_Unwind_Exception *a1)
{
  unsigned __int8 *v1;
  int v2;

  if (v2)
    atomic_store(0, v1);
  _Unwind_Resume(a1);
}

void Phase::HeapAllocator::InitializeWithBacking(Phase::HeapAllocator *this, unint64_t a2, const char *a3, int a4, uint64_t a5, int a6)
{
  uint8x8_t v8;
  char *v13;
  char *v14;
  char *v15;
  _OWORD *v16;
  _DWORD *v17;
  unint64_t v18;
  Phase::Logger *v19;
  Phase::VirtualAllocator *v20;
  unint64_t v21;
  int v22;
  int v23;
  signed int v24;
  unsigned int v25;
  int v26;
  const void *v27;
  BOOL v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t i;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  unsigned int *v37;
  uint64_t v38;
  uint64_t v39;
  signed int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  Phase *Internal;
  NSObject *v46;
  std::logic_error *exception;
  NSObject *v48;
  std::logic_error *v49;
  Phase::Logger *v50;
  NSObject *v51;
  std::logic_error *v52;
  NSObject *v53;
  std::logic_error *v54;
  Phase::Logger *v55;
  NSObject *v56;
  std::logic_error *v57;
  int v58;
  const char *v59;
  __int16 v60;
  int v61;
  __int16 v62;
  uint64_t v63;
  uint64_t v64;

  v64 = *MEMORY[0x24BDAC8D0];
  if (HIDWORD(a2))
  {
    v46 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 64);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      v58 = 136315650;
      v59 = "HeapAllocator.cpp";
      v60 = 1024;
      v61 = 1100;
      v62 = 2048;
      v63 = a2;
      _os_log_impl(&dword_2164CC000, v46, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [inMaxSizeInBytes > 0xffffffff is true]: \"Invalid inMaxSizeInBytes: %zu!\\n\"", (uint8_t *)&v58, 0x1Cu);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Invalid inMaxSizeInBytes: %zu!\n");
  }
  v8 = (uint8x8_t)vcnt_s8((int8x8_t)a5);
  v8.i16[0] = vaddlv_u8(v8);
  if (v8.u32[0] != 1)
  {
    v48 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 64);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
    {
      v58 = 136315650;
      v59 = "HeapAllocator.cpp";
      v60 = 1024;
      v61 = 1107;
      v62 = 2048;
      v63 = a5;
      _os_log_impl(&dword_2164CC000, v48, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [!IsPowerOfTwo(inAlignmentInBytes) is true]: \"Invalid inAlignmentInBytes: %zu!\\n\"", (uint8_t *)&v58, 0x1Cu);
    }
    v49 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](v49, "Invalid inAlignmentInBytes: %zu!\n");
  }
  *(_OWORD *)((char *)this + 40) = 0u;
  v13 = (char *)this + 40;
  *((_QWORD *)this + 11) = 0;
  v14 = (char *)this + 88;
  *((_QWORD *)this + 15) = 0;
  *((_DWORD *)this + 32) = 0;
  v15 = (char *)this + 132;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 68) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_DWORD *)this + 28) = 0;
  v16 = (_OWORD *)((char *)this + 800);
  *((_OWORD *)this + 1) = 0u;
  memset((char *)this + 132, 255, 0x280uLL);
  *((_OWORD *)v13 + 46) = 0u;
  *((_DWORD *)v13 + 188) = 0;
  *v16 = 0u;
  *(_OWORD *)(v13 + 776) = 0u;
  *(_OWORD *)(v13 + 792) = 0u;
  *(_OWORD *)(v13 + 808) = 0u;
  *(_OWORD *)(v13 + 824) = 0u;
  *(_OWORD *)(v13 + 840) = 0u;
  *(_OWORD *)(v13 + 856) = 0u;
  *(_OWORD *)(v13 + 872) = 0u;
  *(_OWORD *)(v13 + 888) = 0u;
  *(_OWORD *)(v13 + 904) = 0u;
  *(_OWORD *)(v13 + 920) = 0u;
  *((_QWORD *)v13 + 117) = 0;
  *((_DWORD *)v13 - 2) = a4;
  *((_QWORD *)v13 - 4) = a3;
  v17 = (_DWORD *)MEMORY[0x24BDB03C0];
  v18 = (*MEMORY[0x24BDB03B8] + a2) >> *MEMORY[0x24BDB03C0];
  if (!a2)
    LODWORD(v18) = 0;
  *((_DWORD *)v13 + 228) = v18;
  v19 = (Phase::Logger *)Phase::VirtualAllocator::ReserveAddressSpace((Phase::VirtualAllocator *)v18);
  *((_QWORD *)v13 + 113) = v19;
  if (!v19)
  {
    v50 = (Phase::Logger *)Phase::HeapAllocator::Destroy(this);
    v51 = **(NSObject ***)(Phase::Logger::GetInstancePtr(v50) + 32);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
      v58 = 136315394;
      v59 = "HeapAllocator.cpp";
      v60 = 1024;
      v61 = 195;
      _os_log_impl(&dword_2164CC000, v51, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (OutOfMemory): \"Could not acquire the specified amount of address space from the virtual allocator!\"", (uint8_t *)&v58, 0x12u);
    }
    v52 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    _ZN5Phase11OutOfMemoryCI1St11logic_errorEPKc(v52, "Could not acquire the specified amount of address space from the virtual allocator!");
  }
  v20 = v19;
  v21 = 8;
  if (a5 > 8)
    v21 = a5;
  v22 = __clz(v21) ^ 0x3F;
  *((_DWORD *)this + 6) = v22;
  *((_QWORD *)this + 116) = v19;
  if (a6 < 0)
  {
    v53 = **(NSObject ***)(Phase::Logger::GetInstancePtr(v19) + 64);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      v58 = 136315650;
      v59 = "HeapAllocator.cpp";
      v60 = 1024;
      v61 = 89;
      v62 = 2048;
      v63 = a6;
      _os_log_impl(&dword_2164CC000, v53, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [inMaximumAllocationCount < 0 is true]: \"Invalid inMaximumAllocationCount: %lld!\\n\"", (uint8_t *)&v58, 0x1Cu);
    }
    v54 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](v54, "Invalid inMaximumAllocationCount: %lld!\n");
  }
  v23 = (((2454267027u * (unint64_t)(((a6 + 15) & 0xFFFFFFF0) >> 1)) >> 32 << 6) & 0xFFFFFF00)
      + (((((a6 + 15) & 0xFFFFFFF0) + 34) / 0x1F) << 9)
      + 688 * ((((a6 + 15) & 0xFFFFFFF0) + 24) / 0x15)
      + 11008;
  *((_DWORD *)this + 235) = v23;
  v24 = (v23 + ~(-1 << v22)) >> v22;
  *((_QWORD *)this + 2) = (char *)v19 + (v24 << v22);
  if (v24 >= (int)(a2 >> v22))
  {
    v55 = (Phase::Logger *)Phase::HeapAllocator::Destroy(this);
    v56 = **(NSObject ***)(Phase::Logger::GetInstancePtr(v55) + 32);
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      v58 = 136315394;
      v59 = "HeapAllocator.cpp";
      v60 = 1024;
      v61 = 211;
      _os_log_impl(&dword_2164CC000, v56, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"InitializeWithBacking failed!\"", (uint8_t *)&v58, 0x12u);
    }
    v57 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](v57, "InitializeWithBacking failed!");
  }
  v25 = *((_DWORD *)this + 8);
  v26 = (v25 >> 4) & 1;
  if ((v25 & 0x10) != 0
    && (Phase::SpinLock::Lock((unsigned __int8 *)this), (v20 = (Phase::VirtualAllocator *)*((_QWORD *)this + 118)) == 0))
  {
    v28 = 1;
  }
  else
  {
    v27 = (const void *)*((unsigned int *)this + 239);
    if ((_DWORD)v27)
    {
      Phase::VirtualAllocator::DecommitPages(v20, v27);
      v20 = (Phase::VirtualAllocator *)*((_QWORD *)this + 118);
      v28 = v20 == 0;
    }
    else
    {
      v28 = 0;
    }
  }
  *((_DWORD *)this + 234) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_DWORD *)this + 32) = 0;
  *(_OWORD *)v13 = 0u;
  *((_OWORD *)v13 + 1) = 0u;
  *(_OWORD *)(v13 + 28) = 0u;
  *((_QWORD *)v14 + 1) = 0;
  *((_QWORD *)v14 + 2) = 0;
  *(_QWORD *)v14 = 0;
  *((_DWORD *)v14 + 6) = 0;
  memset(v15, 255, 0x280uLL);
  *v16 = 0u;
  v16[1] = 0u;
  v16[2] = 0u;
  v16[3] = 0u;
  v16[4] = 0u;
  v16[5] = 0u;
  v16[6] = 0u;
  v16[7] = 0u;
  if (!v28)
  {
    v29 = *((unsigned int *)this + 235);
    if ((_DWORD)v29)
      v30 = (unint64_t)(*MEMORY[0x24BDB03B8] + v29) >> *v17;
    else
      v30 = 0;
    Phase::VirtualAllocator::CommitPages(v20, (void *)v30);
    *((_DWORD *)this + 239) = v30;
    *((_DWORD *)this + 7) = (*((_DWORD *)this + 236) + *MEMORY[0x24BDB03C8] * (int)v30 - *((_DWORD *)this + 4)) >> *((_DWORD *)this + 6);
  }
  v31 = *((_QWORD *)this + 116);
  if (v31)
  {
    v32 = *((_DWORD *)this + 234);
    for (i = 132; i != 644; i += 8)
    {
      v34 = Phase::HeapAllocator::AddLookupSet(this, (unsigned int *)(v31 + v32));
      v32 = *((_DWORD *)this + 234) + 128;
      *((_DWORD *)this + 234) = v32;
      v31 = *((_QWORD *)this + 116);
      *(int32x2_t *)((char *)this + i) = vdup_n_s32(v34 - v31);
    }
    do
    {
      v35 = Phase::HeapAllocator::AddLookupSet(this, (unsigned int *)(v31 + v32));
      v32 = *((_DWORD *)this + 234) + 128;
      *((_DWORD *)this + 234) = v32;
      v31 = *((_QWORD *)this + 116);
      *(int32x2_t *)((char *)this + i) = vdup_n_s32(v35 - v31);
      i += 8;
    }
    while (i != 772);
    v36 = 6;
    do
    {
      v37 = Phase::HeapAllocator::AddLookupSet(this, (unsigned int *)(*((_QWORD *)this + 116) + v32));
      v32 = *((_DWORD *)this + 234) + 128;
      *((_DWORD *)this + 234) = v32;
      v38 = *((_QWORD *)this + 15);
      if (v38)
        v37[29] = v38 - *((_DWORD *)this + 232);
      *((_QWORD *)this + 15) = v37;
      ++*((_DWORD *)this + 32);
      --v36;
    }
    while (v36);
    Phase::HeapAllocator::AddBlockSet(this, (char *)(*((_QWORD *)this + 116) + v32));
    v39 = (*((_DWORD *)this + 234) + 688);
    *((_DWORD *)this + 234) = v39;
    Phase::HeapAllocator::AddGapSet(this, (_OWORD *)(*((_QWORD *)this + 116) + v39));
    *((_DWORD *)this + 234) += 512;
    v40 = *((_DWORD *)this + 7);
    if (v40 > 0)
      Phase::HeapAllocator::AddGap(this, 0, v40, 0xFFFFFFFF, 0xFFFFFFFF);
    v41 = *((_DWORD *)this + 8);
    if ((v41 & 1) != 0)
    {
      Phase::Memset8(*((Phase **)this + 2), (void *)0xCDCDCDCDCDCDCDCDLL, (int)(*((_DWORD *)this + 7) << *((_DWORD *)this + 6)));
      v41 = *((_DWORD *)this + 8);
    }
    if ((v41 & 0x20) != 0)
    {
      v42 = *((_QWORD *)this + 118);
      v43 = v42
          ? v42 + *MEMORY[0x24BDB03C8] * *((unsigned int *)this + 238) - *((_QWORD *)this + 2)
          : (int)(*((_DWORD *)this + 7) << *((_DWORD *)this + 6));
      v44 = ((0x8000000 - v43) & ((0x8000000 - v43) >> 63)) + v43;
      Internal = Phase::HeapAllocator::AllocateInternal(this, ((unint64_t)((int)(v44 >> 10) + 63) >> 3) & 0x1FFFFFFFFFFFFFF8, "Internal Small Allocation Bits", 0, 0);
      *((_QWORD *)this + 98) = Internal;
      if (Internal)
      {
        *((_QWORD *)this + 97) = (*((_QWORD *)this + 2) + 1023) & 0xFFFFFFFFFFFFFC00;
        *((_DWORD *)this + 198) = (unint64_t)v44 >> 10;
        Phase::Memset8(Internal, 0, ((unint64_t)((int)(v44 >> 10) + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
      }
    }
  }
  if (v26)
    atomic_store(0, (unsigned __int8 *)this);
}

void sub_2165E0490(_Unwind_Exception *exception_object)
{
  unsigned __int8 *v1;
  int v2;

  if (v2)
    atomic_store(0, v1);
  _Unwind_Resume(exception_object);
}

uint64_t Phase::HeapAllocator::Free(Phase::HeapAllocator *this, Phase *a2)
{
  unsigned int v4;
  uint64_t result;

  v4 = *((_DWORD *)this + 8);
  if ((v4 & 0x10) != 0)
    Phase::SpinLock::Lock((unsigned __int8 *)this);
  result = Phase::HeapAllocator::FreeInternal(this, a2);
  if (((v4 >> 4) & 1) != 0)
    atomic_store(0, (unsigned __int8 *)this);
  return result;
}

void sub_2165E0524(_Unwind_Exception *a1)
{
  unsigned __int8 *v1;
  int v2;

  if (v2)
    atomic_store(0, v1);
  _Unwind_Resume(a1);
}

unsigned int *Phase::HeapAllocator::AddLookupSet(Phase::HeapAllocator *this, unsigned int *a2)
{
  uint64_t v2;
  uint64_t v3;
  __int128 v4;

  if (a2)
  {
LABEL_7:
    *(_QWORD *)&v4 = -1;
    *((_QWORD *)&v4 + 1) = -1;
    *((_OWORD *)a2 + 5) = v4;
    *((_OWORD *)a2 + 6) = v4;
    *((_OWORD *)a2 + 3) = v4;
    *((_OWORD *)a2 + 4) = v4;
    *((_OWORD *)a2 + 1) = v4;
    *((_OWORD *)a2 + 2) = v4;
    *(_OWORD *)a2 = v4;
    *((_QWORD *)a2 + 14) = 0xFFFFFFFF00000000;
    a2[30] = -1;
    return a2;
  }
  a2 = (unsigned int *)*((_QWORD *)this + 15);
  if (a2)
  {
    v2 = a2[29];
    if ((_DWORD)v2 == -1)
      v3 = 0;
    else
      v3 = *((_QWORD *)this + 116) + v2;
    *((_QWORD *)this + 15) = v3;
    --*((_DWORD *)this + 32);
    goto LABEL_7;
  }
  return a2;
}

void Phase::HeapAllocator::AddBlockSet(Phase::HeapAllocator *this, char *a2)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  int v8;
  _QWORD *v9;
  uint64_t v10;

  bzero(a2, 0x2B0uLL);
  v4 = 0;
  v5 = *((_QWORD *)this + 116);
  do
  {
    v6 = &a2[v4];
    *(_DWORD *)v6 = -1;
    *((_DWORD *)v6 + 2) = -1;
    *((_DWORD *)v6 + 3) = (_DWORD)a2 - v5 + 32 + v4;
    v4 += 32;
  }
  while (v4 != 672);
  v7 = *((_QWORD *)this + 9);
  v8 = v7 - v5;
  if (!v7)
    v8 = -1;
  *((_DWORD *)a2 + 163) = v8;
  *((_QWORD *)this + 9) = a2;
  *((_DWORD *)this + 20) += 21;
  if (*((_QWORD *)this + 7))
  {
    *((_QWORD *)a2 + 84) = 0;
    v10 = *((_QWORD *)this + 8);
    v9 = (_QWORD *)((char *)this + 64);
    *((_QWORD *)a2 + 85) = v10;
    *(_QWORD *)(v10 + 672) = a2;
  }
  else
  {
    *((_QWORD *)a2 + 84) = 0;
    *((_QWORD *)a2 + 85) = 0;
    *((_QWORD *)this + 7) = a2;
    v9 = (_QWORD *)((char *)this + 64);
  }
  *v9 = a2;
}

_QWORD *Phase::HeapAllocator::AddGapSet(Phase::HeapAllocator *this, _OWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  _DWORD *v4;
  uint64_t v5;
  int v6;
  int v7;
  _QWORD *result;
  uint64_t v9;

  v2 = 0;
  a2[30] = 0u;
  a2[31] = 0u;
  a2[28] = 0u;
  a2[29] = 0u;
  a2[26] = 0u;
  a2[27] = 0u;
  a2[24] = 0u;
  a2[25] = 0u;
  a2[22] = 0u;
  a2[23] = 0u;
  a2[20] = 0u;
  a2[21] = 0u;
  a2[18] = 0u;
  a2[19] = 0u;
  a2[16] = 0u;
  a2[17] = 0u;
  a2[14] = 0u;
  a2[15] = 0u;
  a2[12] = 0u;
  a2[13] = 0u;
  a2[10] = 0u;
  a2[11] = 0u;
  a2[8] = 0u;
  a2[9] = 0u;
  a2[6] = 0u;
  a2[7] = 0u;
  a2[4] = 0u;
  a2[5] = 0u;
  a2[2] = 0u;
  a2[3] = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  v3 = *((_QWORD *)this + 116);
  do
  {
    v4 = &a2[v2];
    *v4 = -1;
    v4[2] = -1;
    v4[3] = (_DWORD)a2 - v3 + 16 + v2 * 16;
    ++v2;
  }
  while (v2 != 31);
  v5 = *((_QWORD *)this + 13);
  v6 = v5 - v3;
  if (v5)
    v7 = v6;
  else
    v7 = -1;
  *((_DWORD *)a2 + 123) = v7;
  *((_QWORD *)this + 13) = a2;
  *((_DWORD *)this + 28) += 31;
  if (*((_QWORD *)this + 11))
  {
    v9 = *((_QWORD *)this + 12);
    result = (_QWORD *)((char *)this + 96);
    *((_QWORD *)a2 + 62) = 0;
    *((_QWORD *)a2 + 63) = v9;
    *(_QWORD *)(v9 + 496) = a2;
  }
  else
  {
    *((_QWORD *)a2 + 62) = 0;
    *((_QWORD *)a2 + 63) = 0;
    *((_QWORD *)this + 11) = a2;
    result = (_QWORD *)((char *)this + 96);
  }
  *result = a2;
  return result;
}

_DWORD *Phase::HeapAllocator::AddGap(Phase::HeapAllocator *this, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  _DWORD *v10;
  unsigned int v11;
  Phase::Logger *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v16;
  std::runtime_error *exception;
  NSObject *v18;
  std::runtime_error *v19;
  int v20;
  const char *v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  if (!a3)
    __assert_rtn("AddGap", "HeapAllocator.cpp", 1847, "inPageSize != 0");
  if (!*((_DWORD *)this + 28))
    return 0;
  v10 = (_DWORD *)*((_QWORD *)this + 13);
  v11 = __clz(a3) ^ 0x1F;
  v12 = (Phase::Logger *)Phase::HeapAllocator::AddLookup((uint64_t)this, (_DWORD *)this + 2 * (int)(((15 - v11) & ((int)(15 - v11) >> 31)) + v11) + 161, a3, (int)v10 - *((_DWORD *)this + 232));
  if (!(_DWORD)v12)
    return 0;
  --*((_DWORD *)this + 28);
  v13 = v10[3];
  if ((_DWORD)v13 == -1)
    v14 = 0;
  else
    v14 = *((_QWORD *)this + 116) + v13;
  *((_QWORD *)this + 13) = v14;
  *v10 = a2;
  v10[1] = -a3;
  v10[2] = a4;
  v10[3] = a5;
  if (a4 != -1 && *(int *)(*((_QWORD *)this + 116) + a4 + 4) <= 0)
  {
    v16 = **(NSObject ***)(Phase::Logger::GetInstancePtr(v12) + 64);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v20 = 136315394;
      v21 = "HeapAllocator.cpp";
      v22 = 1024;
      v23 = 1889;
      _os_log_impl(&dword_2164CC000, v16, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [ToAllocElem(inNeighborLow)->mSize <= 0 is true]: \"FindGapLookup() failed!\\n\"", (uint8_t *)&v20, 0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "FindGapLookup() failed!\n");
  }
  if (a5 != -1 && *(int *)(*((_QWORD *)this + 116) + a5 + 4) <= 0)
  {
    v18 = **(NSObject ***)(Phase::Logger::GetInstancePtr(v12) + 64);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v20 = 136315394;
      v21 = "HeapAllocator.cpp";
      v22 = 1024;
      v23 = 1895;
      _os_log_impl(&dword_2164CC000, v18, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [ToAllocElem(inNeighborHigh)->mSize <= 0 is true]: \"FindGapLookup() failed!\\n\"", (uint8_t *)&v20, 0x12u);
    }
    v19 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v19, "FindGapLookup() failed!\n");
  }
  if (a4 == -1)
    *((_QWORD *)this + 5) = v10;
  else
    *(_DWORD *)(*((_QWORD *)this + 116) + a4 + 12) = (_DWORD)v10 - *((_QWORD *)this + 116);
  if (a5 == -1)
    *((_QWORD *)this + 6) = v10;
  else
    *(_DWORD *)(*((_QWORD *)this + 116) + a5 + 8) = (_DWORD)v10 - *((_QWORD *)this + 116);
  return v10;
}

void sub_2165E09D4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

Phase *Phase::HeapAllocator::AllocateInternal(Phase::HeapAllocator *this, unint64_t a2, const char *a3, int a4, unint64_t a5)
{
  Phase::HeapAllocator *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  signed int v13;
  int v14;
  unsigned int v15;
  int v16;
  unint64_t v17;
  unsigned int v18;
  Phase::Logger *GapBySize;
  Phase::Logger *v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  int v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  unsigned int v35;
  uint64_t v36;
  int v37;
  unsigned int v38;
  uint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t v44;
  Phase *v45;
  unint64_t v46;
  char v47;
  char *v48;
  unsigned __int16 *v49;
  _QWORD *v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  int v58;
  int v59;
  uint64_t v60;
  int v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int v65;
  uint64_t v66;
  unsigned int v67;
  int v68;
  unsigned int v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  int v74;
  uint64_t v75;
  int v76;
  _BOOL8 v77;
  int v78;
  Phase *v79;
  size_t v80;
  void *v81;
  int v83;
  _BOOL8 v84;
  NSObject *v85;
  std::logic_error *v86;
  NSObject *v87;
  const char *v88;
  std::logic_error *exception;
  NSObject *v90;
  std::runtime_error *v91;
  NSObject *v92;
  std::runtime_error *v93;
  NSObject *v94;
  std::logic_error *v95;
  NSObject *v96;
  std::logic_error *v97;
  NSObject *v98;
  std::logic_error *v99;
  NSObject *v100;
  std::runtime_error *v102;
  NSObject *v103;
  std::runtime_error *v104;
  NSObject *v105;
  std::runtime_error *v106;
  NSObject *v107;
  std::runtime_error *v108;
  char v109;
  unsigned int v110;
  unsigned int *v111;
  uint8_t buf[4];
  const char *v113;
  __int16 v114;
  int v115;
  __int16 v116;
  unint64_t v117;
  uint64_t v118;

  v9 = this;
  v118 = *MEMORY[0x24BDAC8D0];
  if (!a3 && (*((_DWORD *)this + 8) & 8) != 0)
  {
    v87 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 64);
    if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
    {
      v88 = (const char *)*((_QWORD *)v9 + 1);
      if (!v88)
        v88 = "<Unnamed>";
      *(_DWORD *)buf = 136315650;
      v113 = "HeapAllocator.cpp";
      v114 = 1024;
      v115 = 1124;
      v116 = 2080;
      v117 = (unint64_t)v88;
      _os_log_impl(&dword_2164CC000, v87, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [(mFlags & kHeapFlagRequireOwnerName) && (pInOwnerName == nullptr) is true]: \"Heap '%s' requires owner name!\\n\"", buf, 0x1Cu);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Heap '%s' requires owner name!\n");
  }
  v10 = a2 - 1;
  v11 = ((1 << *((_DWORD *)this + 6)) + a2 - 1) >> *((_DWORD *)this + 6);
  if (!v11)
    return 0;
  if (a3 == "Internal Bookkeeping")
    goto LABEL_13;
  Phase::HeapAllocator::AllocateBookkeeping(this);
  if (a4 || a2 > 0xC0 || !*((_QWORD *)v9 + 98))
    goto LABEL_13;
  v12 = 0;
  v13 = 31 - __clz(v10);
  if ((int)a2 <= 1)
    v13 = 0;
  if (v13 >= 4)
    v12 = ((v10 >> (v13 - 1)) & 1 | (2 * v13)) - 7;
  v14 = 8 * (v12 & 1);
  v15 = v12 >> 1;
  if ((unint64_t)(16 - v14) << (v12 >> 1) < a5)
  {
LABEL_13:
    v16 = *((_DWORD *)v9 + 6);
    if (1 << v16 >= a5)
    {
      LODWORD(v17) = 0;
      a5 = 0;
    }
    else
    {
      if ((a5 & (a5 - 1)) != 0)
      {
        v94 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 64);
        if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v113 = "HeapAllocator.cpp";
          v114 = 1024;
          v115 = 1165;
          v116 = 2048;
          v117 = a5;
          _os_log_impl(&dword_2164CC000, v94, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [!IsPowerOfTwo(alignment) is true]: \"invalid alignment: %zu!\\n\"", buf, 0x1Cu);
        }
        v95 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::invalid_argument::invalid_argument[abi:ne180100](v95, "invalid alignment: %zu!\n");
      }
      v17 = a5 >> v16;
    }
    v18 = ((*((_DWORD *)v9 + 8) >> 2) & 1) + v11;
    v111 = 0;
    v110 = 0;
    GapBySize = (Phase::Logger *)Phase::HeapAllocator::FindGapBySize((uint64_t)v9, &v111, &v110, v18, v17);
    v20 = GapBySize;
    if (GapBySize)
    {
LABEL_49:
      v58 = *(_DWORD *)v20;
      if (a5
        && (v59 = *((_DWORD *)v9 + 6),
            v60 = (v58 << v59) + *((_QWORD *)v9 + 2),
            a5 = (((a5 + v60 - 1) & -(uint64_t)a5) - v60) >> v59,
            (_DWORD)a5))
      {
        if (!*((_DWORD *)v9 + 28) || *((_DWORD *)v9 + 32) <= 1u)
        {
          v90 = **(NSObject ***)(Phase::Logger::GetInstancePtr(GapBySize) + 64);
          if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315394;
            v113 = "HeapAllocator.cpp";
            v114 = 1024;
            v115 = 1226;
            _os_log_impl(&dword_2164CC000, v90, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [(mGapFreeCount < 1) || (mLookupSetFreeCount < 2) is true]: \"not enough memory in additional bookkeeping data to create a new gap!\"", buf, 0x12u);
          }
          v91 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v91, "not enough memory in additional bookkeeping data to create a new gap!");
        }
        v61 = a4;
        v109 = 0;
      }
      else
      {
        v61 = a4;
        v109 = 1;
      }
      if (!*((_DWORD *)v9 + 20))
        goto LABEL_92;
      v62 = a5 + v58;
      v63 = *((unsigned int *)v20 + 2);
      v64 = *((_QWORD *)v9 + 116);
      v65 = (_DWORD)v20 - v64;
      v66 = *((_QWORD *)v9 + 9);
      v67 = -306674912;
      v68 = 4;
      v69 = v62;
      do
      {
        v67 = Phase::sCRC32LookupTable[(v69 ^ v67)] ^ (v67 >> 8);
        v69 >>= 8;
        --v68;
      }
      while (v68);
      GapBySize = (Phase::Logger *)Phase::HeapAllocator::AddLookup((uint64_t)v9, (_DWORD *)v9 + 2 * (v67 & 0x3F) + 33, v62, (int)v66 - (int)v64);
      if (!(_DWORD)GapBySize)
      {
LABEL_92:
        v85 = **(NSObject ***)(Phase::Logger::GetInstancePtr(GapBySize) + 64);
        if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v113 = "HeapAllocator.cpp";
          v114 = 1024;
          v115 = 1234;
          _os_log_impl(&dword_2164CC000, v85, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (OutOfMemory) [pBlock == nullptr is true]: \"we ran out of bookkeeping data to make allocations!\"", buf, 0x12u);
        }
        v86 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        _ZN5Phase11OutOfMemoryCI1St11logic_errorEPKc(v86, "we ran out of bookkeeping data to make allocations!");
      }
      --*((_DWORD *)v9 + 20);
      v70 = *(unsigned int *)(v66 + 12);
      if ((_DWORD)v70 == -1)
        v71 = 0;
      else
        v71 = *((_QWORD *)v9 + 116) + v70;
      *((_QWORD *)v9 + 9) = v71;
      *(_DWORD *)v66 = v62;
      *(_DWORD *)(v66 + 4) = v18;
      *(_DWORD *)(v66 + 8) = v63;
      *(_DWORD *)(v66 + 12) = v65;
      *(_DWORD *)(v66 + 24) = 0;
      *(_QWORD *)(v66 + 16) = 0;
      if ((_DWORD)v63 == -1)
        *((_QWORD *)v9 + 5) = v66;
      else
        *(_DWORD *)(*((_QWORD *)v9 + 116) + v63 + 12) = v66 - *((_QWORD *)v9 + 116);
      if (v65 == -1)
        *((_QWORD *)v9 + 6) = v66;
      else
        *(_DWORD *)(*((_QWORD *)v9 + 116) + v65 + 8) = v66 - *((_QWORD *)v9 + 116);
      *(_DWORD *)(v66 + 24) = v61;
      *(_QWORD *)(v66 + 16) = a3;
      v72 = *((_DWORD *)v20 + 1);
      if (v72 >= 0)
        v73 = *((_DWORD *)v20 + 1);
      else
        v73 = -v72;
      if (v73 <= (int)(a5 + v18))
      {
        Phase::HeapAllocator::RemoveGap((uint64_t)v9, (uint64_t)v20, (uint64_t)v111, v110);
      }
      else
      {
        *(_DWORD *)v20 += a5 + v18;
        Phase::HeapAllocator::ResizeGap((uint64_t)v9, (uint64_t)v20, (uint64_t)v111, v110, v73 - (a5 + v18));
      }
      if ((v109 & 1) == 0
        && !Phase::HeapAllocator::AddGap(v9, *(_DWORD *)v66 - (int)a5, a5, *(_DWORD *)(v66 + 8), (int)v66 - *((_DWORD *)v9 + 232)))
      {
        v96 = **(NSObject ***)(Phase::Logger::GetInstancePtr(0) + 64);
        if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v113 = "HeapAllocator.cpp";
          v114 = 1024;
          v115 = 1259;
          v116 = 2048;
          v117 = 0;
          _os_log_impl(&dword_2164CC000, v96, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (OutOfMemory) [pFrontGap == nullptr is true]: \"pFrontGap %p should be nullptr!\\n\"", buf, 0x1Cu);
        }
        v97 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        _ZN5Phase11OutOfMemoryCI1St11logic_errorEPKc(v97, "pFrontGap %p should be nullptr!\n");
      }
      v74 = *((_DWORD *)v9 + 6);
      v75 = (*(_DWORD *)v66 << v74);
      v45 = (Phase *)(*((_QWORD *)v9 + 2) + v75);
      v76 = *((_DWORD *)v9 + 8);
      if ((v76 & 1) != 0)
      {
        v77 = Phase::MemCompare8((Phase *)(*((_QWORD *)v9 + 2) + v75), (const void *)0xCDCDCDCDCDCDCDCDLL, v18 << v74);
        if (!v77)
        {
          v98 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)v77) + 64);
          if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315394;
            v113 = "HeapAllocator.cpp";
            v114 = 1024;
            v115 = 1269;
            _os_log_impl(&dword_2164CC000, v98, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (OutOfMemory) [!success is true]: \"MemCompare8 failed!\\n\"", buf, 0x12u);
          }
          v99 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          _ZN5Phase11OutOfMemoryCI1St11logic_errorEPKc(v99, "MemCompare8 failed!\n");
        }
        v76 = *((_DWORD *)v9 + 8);
      }
      if ((v76 & 2) != 0)
      {
        Phase::Memset8(v45, 0, v18 << *((_DWORD *)v9 + 6));
        v76 = *((_DWORD *)v9 + 8);
      }
      if ((v76 & 4) != 0)
      {
        v78 = *((_DWORD *)v9 + 6);
        v79 = (Phase *)((char *)v45 + ((v18 - 1) << v78));
        v80 = 1 << v78;
        v81 = (void *)0xEFEFEFEFEFEFEFEFLL;
LABEL_83:
        Phase::Memset8(v79, v81, v80);
        return v45;
      }
      return v45;
    }
    v21 = *((_QWORD *)v9 + 118);
    if (!v21)
    {
LABEL_103:
      v92 = **(NSObject ***)(Phase::Logger::GetInstancePtr(GapBySize) + 64);
      if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v113 = "HeapAllocator.cpp";
        v114 = 1024;
        v115 = 1210;
        _os_log_impl(&dword_2164CC000, v92, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [pGap == nullptr is true]: \"no gap could be found to fit this allocation (and we weren't able to get additional memory from the backing allocator)!\"", buf, 0x12u);
      }
      v93 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v93, "no gap could be found to fit this allocation (and we weren't able to get additional memory from the backing allocator)!");
    }
    v22 = *((_QWORD *)v9 + 6);
    if (v22)
      LODWORD(v22) = -*(_DWORD *)(v22 + 4) & (*(int *)(v22 + 4) >> 31);
    v23 = v17 + v18 >= v22;
    v24 = v17 + v18 - v22;
    if (v24 == 0 || !v23)
    {
      v100 = **(NSObject ***)(Phase::Logger::GetInstancePtr(0) + 32);
      if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v113 = "HeapAllocator.cpp";
        v114 = 1024;
        v115 = 1200;
        _os_log_impl(&dword_2164CC000, v100, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error): \"InitializeWithoutBacking failed!\"", buf, 0x12u);
      }
      v102 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v102, "InitializeWithoutBacking failed!");
    }
    v25 = *MEMORY[0x24BDB03C8];
    v26 = ((unint64_t)(v24 << v16) + *MEMORY[0x24BDB03C8] - 1) / *MEMORY[0x24BDB03C8];
    v27 = *((unsigned int *)v9 + 239);
    v28 = (*((_DWORD *)v9 + 238) - v27) - v26;
    v29 = v28 & (v28 >> 63);
    v30 = v29 + v26;
    if (v29 + v26)
    {
      Phase::VirtualAllocator::CommitPages((Phase::VirtualAllocator *)(v21 + v25 * v27), (void *)(v29 + v26));
      LODWORD(v27) = *((_DWORD *)v9 + 239) + v30;
      *((_DWORD *)v9 + 239) = v27;
      v21 = *((_QWORD *)v9 + 118);
      v16 = *((_DWORD *)v9 + 6);
    }
    v31 = v21 + v25 * v27;
    v32 = *((_QWORD *)v9 + 2);
    v33 = (v31 - (int)v32) >> v16;
    v34 = *((_DWORD *)v9 + 7);
    v35 = v33 - v34;
    if (v33 <= v34)
    {
LABEL_48:
      GapBySize = (Phase::Logger *)Phase::HeapAllocator::FindGapBySize((uint64_t)v9, &v111, &v110, v18, v17);
      v20 = GapBySize;
      if (GapBySize)
        goto LABEL_49;
      goto LABEL_103;
    }
    if ((*((_BYTE *)v9 + 32) & 1) != 0)
      Phase::Memset8((Phase *)(v32 + (v34 << v16)), (void *)0xCDCDCDCDCDCDCDCDLL, (int)(v35 << v16));
    v36 = *((_QWORD *)v9 + 6);
    if (v36)
    {
      v37 = *(_DWORD *)(v36 + 4);
      if (v37 < 0)
      {
        Phase::HeapAllocator::ResizeGap((uint64_t)v9, v36, 0, 0, v35 - v37);
        goto LABEL_47;
      }
      v38 = v36 - *((_DWORD *)v9 + 232);
    }
    else
    {
      v38 = -1;
    }
    Phase::HeapAllocator::AddGap(v9, *((_DWORD *)v9 + 7), v35, v38, 0xFFFFFFFF);
LABEL_47:
    *((_DWORD *)v9 + 7) = v33;
    goto LABEL_48;
  }
  v39 = v12;
  v40 = (unint64_t *)((char *)v9 + 8 * v12 + 800);
  v41 = *v40;
  if (!*v40)
  {
    this = (Phase::HeapAllocator *)Phase::HeapAllocator::AllocateInternal(v9, 0x400uLL, "Internal Small Allocation Bundle", 0, 0x400uLL);
    if (this)
    {
      v51 = (unint64_t)this - *((_QWORD *)v9 + 97);
      v52 = v51 >> 10;
      v53 = *((_QWORD *)v9 + 98);
      v54 = v51 >> 16;
      v55 = *(_QWORD *)(v53 + 8 * v54);
      v56 = 1 << v52;
      if ((v56 & v55) != 0)
      {
        v107 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 64);
        if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v113 = "HeapAllocator.cpp";
          v114 = 1024;
          v115 = 2254;
          _os_log_impl(&dword_2164CC000, v107, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [(mSmallBundleAllocBits[bundleIndex >> 6] & (0x1ULL << (bundleIndex & 0x3f))) != 0 is true]: \"FindGapLookup() failed!\\n\"", buf, 0x12u);
        }
        v108 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v108, "FindGapLookup() failed!\n");
      }
      *(_QWORD *)(v53 + 8 * v54) = v56 | v55;
      v41 = (unint64_t)this + 992;
      v57 = (unint64_t)(v14 | 0x10u) << v15;
      *((_WORD *)this + 496) = v57;
      *((_BYTE *)this + 994) = 0x3E0u / (unsigned __int16)v57;
      *((_BYTE *)this + 995) = 0x3E0u / (unsigned __int16)v57;
      *((_QWORD *)this + 125) = 0;
      *((_QWORD *)this + 127) = 0;
      *((_QWORD *)this + 126) = 0;
      *v40 = (unint64_t)this + 992;
      *((_QWORD *)v9 + v39 + 108) = (char *)this + 992;
      if ((*((_BYTE *)v9 + 32) & 1) != 0)
      {
        Phase::Memset8(this, (void *)0xCDCDCDCDCDCDCDCDLL, ((unsigned __int16)v57 & 0xFFF8) * (unint64_t)(0x3E0u / (unsigned __int16)v57));
        v41 = *v40;
      }
      goto LABEL_32;
    }
    return 0;
  }
LABEL_32:
  v42 = *(_QWORD *)(v41 + 8);
  v43 = __clz(~v42);
  if (v43 >= *(unsigned __int8 *)(v41 + 2))
  {
    v103 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 64);
    if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v113 = "HeapAllocator.cpp";
      v114 = 1024;
      v115 = 2283;
      _os_log_impl(&dword_2164CC000, v103, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [freeIndex >= pBundle->mBlockTotalCount is true]: \"FindGapLookup() failed!\\n\"", buf, 0x12u);
    }
    v104 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v104, "FindGapLookup() failed!\n");
  }
  v44 = *(unsigned __int16 *)v41;
  v45 = (Phase *)((v41 & 0xFFFFFFFFFFFFFC00) + v43 * v44);
  if (v43 <= 0x3F)
    v46 = 0x8000000000000000 >> v43;
  else
    v46 = 0;
  *(_QWORD *)(v41 + 8) = v46 | v42;
  v47 = *(_BYTE *)(v41 + 3) - 1;
  *(_BYTE *)(v41 + 3) = v47;
  if (!v47)
  {
    v48 = (char *)v9 + 8 * v39;
    if (v41 == *((_QWORD *)v48 + 108))
    {
      v49 = 0;
      v50 = v48 + 864;
    }
    else
    {
      v49 = *(unsigned __int16 **)(v41 + 16);
      v50 = v49 + 12;
    }
    *v40 = (unint64_t)v49;
    *v50 = 0;
    *(_QWORD *)(v41 + 16) = 0;
    *(_QWORD *)(v41 + 24) = 0;
  }
  v83 = *((_DWORD *)v9 + 8);
  if ((v83 & 1) != 0)
  {
    v84 = Phase::MemCompare8(v45, (const void *)0xCDCDCDCDCDCDCDCDLL, v44);
    if (!v84)
    {
      v105 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)v84) + 64);
      if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v113 = "HeapAllocator.cpp";
        v114 = 1024;
        v115 = 2314;
        _os_log_impl(&dword_2164CC000, v105, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [!success is true]: \"MemCompare8 failed!\\n\"", buf, 0x12u);
      }
      v106 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v106, "MemCompare8 failed!\n");
    }
    v83 = *((_DWORD *)v9 + 8);
  }
  if ((v83 & 2) != 0)
  {
    v80 = *(unsigned __int16 *)v41;
    v79 = v45;
    v81 = 0;
    goto LABEL_83;
  }
  return v45;
}

void sub_2165E1768(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

Phase *Phase::HeapAllocator::Allocate(Phase::HeapAllocator *this, unint64_t a2, const char *a3, int a4, unint64_t a5)
{
  unsigned int v10;
  Phase *result;

  v10 = *((_DWORD *)this + 8);
  if ((v10 & 0x10) != 0)
    Phase::SpinLock::Lock((unsigned __int8 *)this);
  result = Phase::HeapAllocator::AllocateInternal(this, a2, a3, a4, a5);
  if (((v10 >> 4) & 1) != 0)
    atomic_store(0, (unsigned __int8 *)this);
  return result;
}

void sub_2165E181C(_Unwind_Exception *a1)
{
  unsigned __int8 *v1;
  int v2;

  if (v2)
    atomic_store(0, v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::HeapAllocator::FreeInternal(Phase::HeapAllocator *this, Phase *a2)
{
  Phase::HeapAllocator *v2;
  char v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  size_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  _QWORD *v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  unsigned int v30;
  _DWORD *v31;
  unsigned int *v32;
  _BOOL8 v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v40;
  _DWORD *v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  unsigned int v51;
  int v52;
  uint64_t v53;
  int v54;
  int v55;
  unsigned int v56;
  int v57;
  uint64_t GapLookup;
  uint64_t v59;
  unsigned int v60;
  NSObject *v62;
  const char *v63;
  std::logic_error *exception;
  NSObject *v65;
  const char *v66;
  std::runtime_error *v67;
  NSObject *v68;
  const char *v69;
  std::runtime_error *v70;
  NSObject *v71;
  std::runtime_error *v72;
  NSObject *v73;
  const char *v74;
  std::logic_error *v75;
  NSObject *v76;
  std::runtime_error *v77;
  NSObject *v78;
  std::runtime_error *v79;
  NSObject *v80;
  std::runtime_error *v81;
  unsigned int v82;
  _DWORD *v83;
  uint64_t v84;
  unsigned int v85;
  unsigned int v86;
  unsigned int v87;
  uint64_t v88;
  uint8_t buf[4];
  const char *v90;
  __int16 v91;
  int v92;
  __int16 v93;
  const char *v94;
  uint64_t v95;

  v95 = *MEMORY[0x24BDAC8D0];
  if (!a2)
    return 0;
  v2 = this;
  v3 = 0;
  v4 = *((_DWORD *)this + 6);
  while (1)
  {
    v5 = ((uint64_t)a2 - *((_QWORD *)v2 + 2)) >> v4;
    if (v5 < 0 || v5 >= *((int *)v2 + 7))
    {
      v62 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 32);
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
      {
        v63 = (const char *)*((_QWORD *)v2 + 1);
        if (!v63)
          v63 = "<Unnamed>";
        *(_DWORD *)buf = 136315650;
        v90 = "HeapAllocator.cpp";
        v91 = 1024;
        v92 = 1303;
        v93 = 2080;
        v94 = v63;
        _os_log_impl(&dword_2164CC000, v62, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"Something tried to free an allocation from heap '%s' that was outside of its memory range.\\n\"", buf, 0x1Cu);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "Something tried to free an allocation from heap '%s' that was outside of its memory range.\n");
    }
    v6 = *((_QWORD *)v2 + 98);
    if (!v6)
      break;
    v7 = *((_QWORD *)v2 + 97);
    v8 = (uint64_t)a2 - v7;
    if (*((unsigned int *)v2 + 198) <= ((uint64_t)a2 - v7) >> 10)
      break;
    v9 = (unint64_t)v8 >> 10;
    if (((*(_QWORD *)(v6 + 8 * (v8 >> 16)) >> ((unint64_t)v8 >> 10)) & 1) == 0)
      break;
    v10 = v7 + (int)((_DWORD)v9 << 10);
    v11 = *(unsigned __int16 *)(v10 + 992);
    if ((v11 - 193) <= 0xFFFFFF4E)
    {
      v65 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 32);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
      {
        v66 = (const char *)*((_QWORD *)v2 + 1);
        if (!v66)
          v66 = "<Unnamed>";
        *(_DWORD *)buf = 136315650;
        v90 = "HeapAllocator.cpp";
        v91 = 1024;
        v92 = 2340;
        v93 = 2080;
        v94 = v66;
        _os_log_impl(&dword_2164CC000, v65, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error): \"Tried to free a bundled small allocation from heap %s, but the bundle is malformed.\\n\"", buf, 0x1Cu);
      }
      v67 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v67, "Tried to free a bundled small allocation from heap %s, but the bundle is malformed.\n");
    }
    v12 = ((unint64_t)a2 - v10) / v11;
    if (a2 != (Phase *)(v10 + v12 * v11))
    {
      v68 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 32);
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
      {
        v69 = (const char *)*((_QWORD *)v2 + 1);
        if (!v69)
          v69 = "<Unnamed>";
        *(_DWORD *)buf = 136315650;
        v90 = "HeapAllocator.cpp";
        v91 = 1024;
        v92 = 2353;
        v93 = 2080;
        v94 = v69;
        _os_log_impl(&dword_2164CC000, v68, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error): \"Tried to free a bundled small allocation from heap %s, but the address is misaligned.\\n\"", buf, 0x1Cu);
      }
      v70 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v70, "Tried to free a bundled small allocation from heap %s, but the address is misaligned.\n");
    }
    v13 = v10 + 992;
    v14 = 0x8000000000000000 >> v12;
    v15 = *(_QWORD *)(v10 + 1000);
    if ((v15 & v14) == 0)
    {
      v71 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 64);
      if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v90 = "HeapAllocator.cpp";
        v91 = 1024;
        v92 = 2361;
        _os_log_impl(&dword_2164CC000, v71, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [!(pBundle->mBlockAllocBits & blockMask) is true]: \"MemCompare8 failed!\\n\"", buf, 0x12u);
      }
      v72 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v72, "MemCompare8 failed!\n");
    }
    *(_QWORD *)(v10 + 1000) = v15 & ~v14;
    v16 = *(unsigned __int8 *)(v10 + 995);
    *(_BYTE *)(v10 + 995) = v16 + 1;
    v17 = __clz(v11 - 1);
    this = (Phase::HeapAllocator *)(((2 * v17) ^ 0x3E) & 0xFFFFFFFE | ((v11 - 1) >> (30 - v17)) & 1);
    if ((v11 - 1) >= 0x10)
      v18 = ((_DWORD)this - 7);
    else
      v18 = 0;
    if (*(unsigned __int8 *)(v10 + 994) != (v16 + 1)
      || (v19 = (char *)v2 + 8 * v18, *((_QWORD *)v19 + 100) == v13))
    {
      if (!v16)
      {
        v37 = (char *)v2 + 8 * v18;
        v38 = v37 + 864;
        v39 = *((_QWORD *)v37 + 108);
        if (v39)
        {
          *(_QWORD *)(v10 + 1016) = v39;
          v40 = (_QWORD *)(*v38 + 16);
        }
        else
        {
          v40 = v37 + 800;
        }
        *v40 = v13;
        *v38 = v13;
      }
      if ((*((_BYTE *)v2 + 32) & 1) != 0)
      {
        Phase::Memset8(a2, (void *)0xCDCDCDCDCDCDCDCDLL, v11);
        return 0;
      }
      goto LABEL_61;
    }
    v20 = *(_QWORD *)(v10 + 1016);
    *(_QWORD *)(v20 + 16) = *(_QWORD *)(v10 + 1008);
    if (*((_QWORD *)v19 + 108) == v13)
      v21 = v19 + 864;
    else
      v21 = (_QWORD *)(*(_QWORD *)(v10 + 1008) + 24);
    *v21 = v20;
    v3 = 1;
    *(_QWORD *)(*((_QWORD *)v2 + 98) + 8 * ((int)v9 >> 6)) &= ~(1 << v9);
    a2 = (Phase *)v10;
    if (!v10)
      return 0;
  }
  v22 = -306674912;
  v23 = 4;
  v24 = -306674912;
  v25 = v5;
  do
  {
    v24 = Phase::sCRC32LookupTable[(v25 ^ v24)] ^ (v24 >> 8);
    v25 >>= 8;
    --v23;
  }
  while (v23);
  v26 = *((unsigned int *)v2 + 2 * (v24 & 0x3F) + 33);
  if ((_DWORD)v26 == -1)
    goto LABEL_107;
  v27 = *((_QWORD *)v2 + 116);
  while (1)
  {
    v28 = v26 + v27;
    v29 = *(_DWORD *)(v26 + v27 + 112);
    v26 = *(unsigned int *)(v26 + v27 + 116);
    if (v29)
      break;
LABEL_29:
    if (v26 == 0xFFFFFFFFLL)
      goto LABEL_107;
  }
  v30 = 0;
  v31 = (_DWORD *)(v28 + 4);
  while (*(v31 - 1) != (_DWORD)v5)
  {
    ++v30;
    v31 += 2;
    if (v29 == v30)
      goto LABEL_29;
  }
  v32 = (unsigned int *)(*v31 + v27);
  if (!v32)
  {
LABEL_107:
    v73 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 32);
    if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
    {
      v74 = (const char *)*((_QWORD *)v2 + 1);
      if (!v74)
        v74 = "<Unnamed>";
      *(_DWORD *)buf = 136315650;
      v90 = "HeapAllocator.cpp";
      v91 = 1024;
      v92 = 1328;
      v93 = 2080;
      v94 = v74;
      _os_log_impl(&dword_2164CC000, v73, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"Something tried to free an allocation from heap '%s' that did not exist in the heap.\\n\"", buf, 0x1Cu);
    }
    v75 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](v75, "Something tried to free an allocation from heap '%s' that did not exist in the heap.\n");
  }
  Phase::HeapAllocator::AllocateBookkeeping(v2);
  if ((*((_BYTE *)v2 + 32) & 4) != 0)
  {
    v33 = Phase::MemCompare8((Phase *)(*((_QWORD *)v2 + 2) + ((*v32 + v32[1] - 1) << *((_DWORD *)v2 + 6))), (const void *)0xEFEFEFEFEFEFEFEFLL, 1 << *((_DWORD *)v2 + 6));
    if (!v33)
    {
      v78 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)v33) + 64);
      if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v90 = "HeapAllocator.cpp";
        v91 = 1024;
        v92 = 1340;
        _os_log_impl(&dword_2164CC000, v78, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [!success is true]: \"MemCompare8 failed!\\n\"", buf, 0x12u);
      }
      v79 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v79, "MemCompare8 failed!\n");
    }
  }
  v35 = v32[2];
  v34 = v32[3];
  if ((_DWORD)v35 == -1)
    v36 = 0;
  else
    v36 = *((_QWORD *)v2 + 116) + v35;
  if ((_DWORD)v34 == -1)
    v41 = 0;
  else
    v41 = (_DWORD *)(*((_QWORD *)v2 + 116) + v34);
  v42 = v32[6];
  v43 = *v32;
  v86 = v32[1];
  if ((!v36 || *(int *)(v36 + 4) >= 1)
    && (!v41 || (int)v41[1] >= 1)
    && (!*((_DWORD *)v2 + 28) || *((_DWORD *)v2 + 32) < 2u))
  {
LABEL_61:
    v42 = 0;
    goto LABEL_86;
  }
  v44 = *((_QWORD *)v2 + 116);
  if (*v31 != (_DWORD)v32 - (_DWORD)v44)
  {
    v76 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)v33) + 64);
    if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v90 = "HeapAllocator.cpp";
      v91 = 1024;
      v92 = 1763;
      _os_log_impl(&dword_2164CC000, v76, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [pInLookupSet->mLookups[inLookupIndex].mValue != ToOffset(pInBlock) is true]: \"FindGapLookup() failed!\\n\"", buf, 0x12u);
    }
    v77 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v77, "FindGapLookup() failed!\n");
  }
  if ((_DWORD)v35 == -1)
  {
    v47 = v44 + v34;
    if ((_DWORD)v34 == -1)
      v48 = 0;
    else
      v48 = v44 + v34;
    *((_QWORD *)v2 + 5) = v48;
    if ((_DWORD)v34 != -1)
      goto LABEL_57;
    v45 = 0;
  }
  else
  {
    v45 = v44 + v35;
    *(_DWORD *)(v44 + v35 + 12) = v34;
    v46 = v32[3];
    if ((_DWORD)v46 != -1)
    {
      v47 = v46 + v44;
LABEL_57:
      *(_DWORD *)(v47 + 8) = v35;
      goto LABEL_65;
    }
  }
  *((_QWORD *)v2 + 6) = v45;
LABEL_65:
  v85 = v43;
  v82 = v34;
  v83 = v41;
  v84 = v36;
  *(_QWORD *)v32 = 0;
  v32[2] = -1;
  v49 = *((_QWORD *)v2 + 9);
  v50 = v49 - v44;
  if (!v49)
    v50 = -1;
  v32[3] = v50;
  *((_QWORD *)v2 + 9) = v32;
  ++*((_DWORD *)v2 + 20);
  v51 = *(v31 - 1);
  v52 = 4;
  do
  {
    v22 = Phase::sCRC32LookupTable[(v51 ^ v22)] ^ (v22 >> 8);
    v51 >>= 8;
    --v52;
  }
  while (v52);
  Phase::HeapAllocator::RemoveLookup(v2, (_DWORD *)v2 + 2 * (v22 & 0x3F) + 33, v28, v30);
  if ((*((_BYTE *)v2 + 32) & 1) != 0)
    Phase::Memset8((Phase *)(*((_QWORD *)v2 + 2) + (v85 << *((_DWORD *)v2 + 6))), (void *)0xCDCDCDCDCDCDCDCDLL, v86 << *((_DWORD *)v2 + 6));
  v53 = v84;
  if (!v84 || (v54 = *(_DWORD *)(v84 + 4), (v54 & 0x80000000) == 0))
  {
    v53 = (uint64_t)v83;
    if (!v83 || (v55 = v83[1], (v55 & 0x80000000) == 0))
    {
      Phase::HeapAllocator::AddGap(v2, v85, v86, v35, v82);
      goto LABEL_86;
    }
    *v83 -= v86;
    v60 = v86 - v55;
    v59 = (uint64_t)v2;
    goto LABEL_85;
  }
  v56 = v86 - v54;
  if (v83)
  {
    v57 = v83[1];
    if (v57 < 0)
    {
      v88 = 0;
      v87 = 0;
      GapLookup = Phase::HeapAllocator::FindGapLookup((uint64_t)v2, &v88, &v87, (uint64_t)v83);
      if ((GapLookup & 1) == 0)
      {
        v80 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)GapLookup) + 64);
        if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v90 = "HeapAllocator.cpp";
          v91 = 1024;
          v92 = 1389;
          _os_log_impl(&dword_2164CC000, v80, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [!result is true]: \"FindGapLookup() failed!\\n\"", buf, 0x12u);
        }
        v81 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v81, "FindGapLookup() failed!\n");
      }
      v56 -= v57;
      Phase::HeapAllocator::RemoveGap((uint64_t)v2, (uint64_t)v83, v88, v87);
      v53 = v84;
      v54 = *(_DWORD *)(v84 + 4);
    }
  }
  if (v54 < 0)
    v54 = -v54;
  if (v54 != v56)
  {
    v59 = (uint64_t)v2;
    v60 = v56;
LABEL_85:
    Phase::HeapAllocator::ResizeGap(v59, v53, 0, 0, v60);
  }
LABEL_86:
  if ((v3 & 1) != 0)
    return 0;
  return v42;
}

void sub_2165E22D8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void Phase::HeapAllocator::AllocateBookkeeping(Phase::HeapAllocator *this)
{
  uint64_t v2;
  char *Internal;
  int v4;
  BOOL v5;
  uint64_t v6;
  _OWORD *v7;
  int v8;
  uint64_t v9;
  int v10;
  unsigned int *v11;
  unsigned int *v12;
  uint64_t v13;

  do
  {
    while (1)
    {
      if (*((_DWORD *)this + 20) >= 4u)
      {
        if (*((_DWORD *)this + 28) >= 4u)
        {
          if (*((_DWORD *)this + 32) >= 6u)
            return;
          v5 = 0;
          goto LABEL_19;
        }
        v5 = 0;
      }
      else
      {
        v2 = *((unsigned int *)this + 234);
        if (v2 + 688 <= (unint64_t)*((unsigned int *)this + 235))
        {
          Internal = (char *)(*((_QWORD *)this + 116) + v2);
          *((_DWORD *)this + 234) = v2 + 688;
          v4 = 1;
        }
        else
        {
          Internal = (char *)Phase::HeapAllocator::AllocateInternal(this, 0x560uLL, "Internal Bookkeeping", 0, 8uLL);
          v4 = 2;
        }
        v5 = Internal != 0;
        if (Internal)
        {
          do
          {
            Phase::HeapAllocator::AddBlockSet(this, Internal);
            Internal += 688;
            --v4;
          }
          while (v4);
        }
        if (*((_DWORD *)this + 28) > 3u)
          goto LABEL_18;
      }
      v6 = *((unsigned int *)this + 234);
      if (v6 + 512 <= (unint64_t)*((unsigned int *)this + 235))
      {
        v7 = (_OWORD *)(*((_QWORD *)this + 116) + v6);
        *((_DWORD *)this + 234) = v6 + 512;
        v8 = 1;
        if (!v7)
          goto LABEL_18;
      }
      else
      {
        v7 = (_OWORD *)Phase::HeapAllocator::AllocateInternal(this, 0x400uLL, "Internal Bookkeeping", 0, 8uLL);
        v8 = 2;
        if (!v7)
          goto LABEL_18;
      }
      do
      {
        Phase::HeapAllocator::AddGapSet(this, v7);
        v7 += 32;
        --v8;
      }
      while (v8);
      v5 = 1;
LABEL_18:
      if (*((_DWORD *)this + 32) > 5u)
        goto LABEL_26;
LABEL_19:
      v9 = *((unsigned int *)this + 234);
      if (v9 + 128 <= (unint64_t)*((unsigned int *)this + 235))
        break;
      v10 = 8;
      v11 = (unsigned int *)Phase::HeapAllocator::AllocateInternal(this, 0x400uLL, "Internal Bookkeeping", 0, 8uLL);
      if (!v11)
        goto LABEL_26;
      do
      {
LABEL_21:
        v12 = Phase::HeapAllocator::AddLookupSet(this, v11);
        v13 = *((_QWORD *)this + 15);
        if (v13)
          v12[29] = v13 - *((_DWORD *)this + 232);
        v11 += 32;
        *((_QWORD *)this + 15) = v12;
        ++*((_DWORD *)this + 32);
        --v10;
      }
      while (v10);
    }
    v11 = (unsigned int *)(*((_QWORD *)this + 116) + v9);
    *((_DWORD *)this + 234) = v9 + 128;
    v10 = 1;
    if (v11)
      goto LABEL_21;
LABEL_26:
    ;
  }
  while (v5);
}

uint64_t Phase::HeapAllocator::FindGapLookup(uint64_t a1, _QWORD *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t result;
  int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;

  result = 0;
  v6 = *(_DWORD *)(a4 + 4);
  if (v6 >= 0)
    v7 = *(_DWORD *)(a4 + 4);
  else
    v7 = -v6;
  v8 = 31 - __clz(v7);
  if (v6)
    v9 = v8;
  else
    v9 = 0;
  v10 = *(unsigned int *)(a1 + 8 * (int)(((15 - v9) & ((int)(15 - v9) >> 31)) + v9) + 644);
  if ((_DWORD)v10 != -1)
  {
    v11 = *(_QWORD *)(a1 + 928);
    while (1)
    {
      v12 = v10 + v11;
      v13 = *(_DWORD *)(v10 + v11 + 112);
      v10 = *(unsigned int *)(v10 + v11 + 116);
      if (v13)
        break;
LABEL_13:
      if (v10 == 0xFFFFFFFFLL)
        return 0;
    }
    v14 = 0;
    v15 = 4;
    while (*(_DWORD *)(v12 + v15) != (_DWORD)a4 - (_DWORD)v11)
    {
      ++v14;
      v15 += 8;
      if (v13 == v14)
        goto LABEL_13;
    }
    *a2 = v12;
    *a3 = v14;
    return 1;
  }
  return result;
}

Phase::Logger *Phase::HeapAllocator::RemoveGap(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  NSObject *v18;
  std::runtime_error *exception;
  int v20;
  const char *v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 928);
  if (*(_DWORD *)(a3 + 8 * a4 + 4) != (_DWORD)a2 - (_DWORD)v4)
  {
    v18 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)a1) + 64);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v20 = 136315394;
      v21 = "HeapAllocator.cpp";
      v22 = 1024;
      v23 = 1930;
      _os_log_impl(&dword_2164CC000, v18, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [pInLookupSet->mLookups[inLookupIndex].mValue != ToOffset(pInGap) is true]: \"FindGapLookup() failed!\\n\"", (uint8_t *)&v20, 0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "FindGapLookup() failed!\n");
  }
  v5 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v5 == -1)
  {
    v9 = *(unsigned int *)(a2 + 12);
    v8 = v9 + v4;
    v10 = (_DWORD)v9 == -1;
    if ((_DWORD)v9 == -1)
      v11 = 0;
    else
      v11 = v9 + v4;
    *(_QWORD *)(a1 + 40) = v11;
    if (!v10)
      goto LABEL_9;
    v6 = 0;
  }
  else
  {
    v6 = v5 + v4;
    *(_DWORD *)(v5 + v4 + 12) = *(_DWORD *)(a2 + 12);
    v7 = *(unsigned int *)(a2 + 12);
    if ((_DWORD)v7 != -1)
    {
      v8 = v7 + v4;
LABEL_9:
      *(_DWORD *)(v8 + 8) = v5;
      goto LABEL_12;
    }
  }
  *(_QWORD *)(a1 + 48) = v6;
LABEL_12:
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  v12 = *(_QWORD *)(a1 + 104);
  v13 = v12 - v4;
  if (!v12)
    v13 = -1;
  *(_DWORD *)(a2 + 12) = v13;
  *(_QWORD *)(a1 + 104) = a2;
  ++*(_DWORD *)(a1 + 112);
  v14 = *(_DWORD *)(a3 + 8 * a4);
  v15 = 31 - __clz(v14);
  if (v14)
    v16 = v15;
  else
    v16 = 0;
  return Phase::HeapAllocator::RemoveLookup((Phase::Logger *)a1, (_DWORD *)(a1 + 8 * (int)(((15 - v16) & ((int)(15 - v16) >> 31)) + v16) + 644), a3, a4);
}

void sub_2165E2754(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t Phase::HeapAllocator::ResizeGap(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  Phase::Logger *v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  NSObject *v15;
  std::runtime_error *v16;
  NSObject *v17;
  std::runtime_error *v18;
  NSObject *v19;
  std::runtime_error *exception;
  unsigned int v21;
  uint64_t v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v7 = (Phase::Logger *)result;
  v27 = *MEMORY[0x24BDAC8D0];
  v22 = a3;
  v21 = a4;
  if (!a3)
  {
    result = Phase::HeapAllocator::FindGapLookup(result, &v22, &v21, a2);
    if (!(_DWORD)result)
    {
      v19 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)result) + 32);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v24 = "HeapAllocator.cpp";
        v25 = 1024;
        v26 = 1986;
        _os_log_impl(&dword_2164CC000, v19, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error): \"FindGapLookup failed!\"", buf, 0x12u);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "FindGapLookup failed!");
    }
    a3 = v22;
    a4 = v21;
  }
  if (*(_DWORD *)(a3 + 8 * a4 + 4) != (_DWORD)a2 - *((_DWORD *)v7 + 232))
  {
    v15 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)result) + 64);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v24 = "HeapAllocator.cpp";
      v25 = 1024;
      v26 = 1995;
      _os_log_impl(&dword_2164CC000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [pInLookupSet->mLookups[inLookupIndex].mValue != ToOffset(pInGap) is true]: \"FindGapLookup() failed!\\n\"", buf, 0x12u);
    }
    v16 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v16, "FindGapLookup() failed!\n");
  }
  v8 = *(_DWORD *)(a2 + 4);
  if (v8 >= 0)
    v9 = *(_DWORD *)(a2 + 4);
  else
    v9 = -v8;
  v10 = 31 - __clz(v9);
  if (v8)
    v11 = v10;
  else
    v11 = 0;
  v12 = ((15 - v11) & ((int)(15 - v11) >> 31)) + v11;
  v13 = 31 - __clz(a5);
  if (!a5)
    v13 = 0;
  v14 = ((15 - v13) & ((int)(15 - v13) >> 31)) + v13;
  if (v12 == v14)
  {
    *(_DWORD *)(a3 + 8 * a4) = a5;
  }
  else
  {
    Phase::HeapAllocator::RemoveLookup(v7, (_DWORD *)v7 + 2 * (int)v12 + 161, a3, a4);
    result = Phase::HeapAllocator::AddLookup((uint64_t)v7, (_DWORD *)v7 + 2 * (int)v14 + 161, a5, (int)a2 - *((_DWORD *)v7 + 232));
    if ((result & 1) == 0)
    {
      v17 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)result) + 32);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v24 = "HeapAllocator.cpp";
        v25 = 1024;
        v26 = 2013;
        _os_log_impl(&dword_2164CC000, v17, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error): \"AddLookup failed!\"", buf, 0x12u);
      }
      v18 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v18, "AddLookup failed!");
    }
  }
  *(_DWORD *)(a2 + 4) = -a5;
  return result;
}

void sub_2165E2A88(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_DWORD *Phase::HeapAllocator::FindGapBySize(uint64_t a1, unsigned int **a2, unsigned int *a3, unsigned int a4, int a5)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int v14;
  _DWORD *v16;
  int v17;
  _DWORD *v19;

  v5 = 31 - __clz(a4);
  if (!a4)
    v5 = 0;
  v6 = ((15 - v5) & ((int)(15 - v5) >> 31)) + v5;
  if (v6 > 0xF)
    return 0;
  v7 = (unsigned int *)(a1 + 8 * v6 + 644);
  v8 = -1;
  do
  {
    v9 = *v7;
    if ((_DWORD)v9 != -1)
    {
      v19 = 0;
      do
      {
        v10 = (unsigned int *)(*(_QWORD *)(a1 + 928) + v9);
        v11 = v10[28];
        v9 = v10[29];
        if (v11)
        {
          v12 = 0;
          v13 = v10;
          do
          {
            v14 = *v13;
            if (*v13 >= a4 && v14 < v8)
            {
              v16 = (_DWORD *)(*(_QWORD *)(a1 + 928) + v13[1]);
              if (!a5
                || v14 >= a5 - 1 + a4
                || (v17 = (*(_QWORD *)(a1 + 16) >> *(_DWORD *)(a1 + 24)) + *v16, v14 >= ((v17 + a5 - 1) & -a5)
                                                                                      - v17
                                                                                      + a4))
              {
                *a2 = v10;
                *a3 = v12;
                v8 = *v13;
                if (*v13 == a4)
                  return v16;
                v11 = v10[28];
                v19 = v16;
              }
            }
            ++v12;
            v13 += 2;
          }
          while (v12 < v11);
        }
      }
      while (v9 != 0xFFFFFFFFLL);
      if (v19)
        return v19;
    }
    ++v6;
    v7 += 2;
  }
  while (v6 != 16);
  return 0;
}

uint64_t Phase::HeapAllocator::AddLookup(uint64_t a1, _DWORD *a2, int a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _DWORD *v16;
  __int128 v18;
  int v19;

  v4 = a2[1];
  if ((_DWORD)v4 == -1)
  {
    v13 = *(_QWORD *)(a1 + 120);
    if (v13)
    {
      v14 = *(unsigned int *)(v13 + 116);
      if ((_DWORD)v14 == -1)
        v15 = 0;
      else
        v15 = *(_QWORD *)(a1 + 928) + v14;
      *(_QWORD *)(a1 + 120) = v15;
      --*(_DWORD *)(a1 + 128);
      *(_QWORD *)&v18 = -1;
      *((_QWORD *)&v18 + 1) = -1;
      *(_OWORD *)(v13 + 80) = v18;
      *(_OWORD *)(v13 + 96) = v18;
      *(_OWORD *)(v13 + 48) = v18;
      *(_OWORD *)(v13 + 64) = v18;
      *(_OWORD *)(v13 + 16) = v18;
      *(_OWORD *)(v13 + 32) = v18;
      *(_OWORD *)v13 = v18;
      *(_DWORD *)(v13 + 120) = -1;
      v19 = v13 - *(_DWORD *)(a1 + 928);
      *a2 = v19;
      a2[1] = v19;
      *(_QWORD *)(v13 + 112) = 0xFFFFFFFF00000001;
      *(_DWORD *)v13 = a3;
      *(_DWORD *)(v13 + 4) = a4;
      return 1;
    }
    return 0;
  }
  v5 = *(_QWORD *)(a1 + 928);
  v6 = v5 + v4;
  v7 = *(unsigned int *)(v6 + 112);
  if (v7 >= 0xE)
  {
    v8 = *(_QWORD *)(a1 + 120);
    if (v8)
    {
      v9 = *(unsigned int *)(v8 + 116);
      v10 = v9 + v5;
      if ((_DWORD)v9 == -1)
        v10 = 0;
      *(_QWORD *)(a1 + 120) = v10;
      --*(_DWORD *)(a1 + 128);
      *(_QWORD *)&v11 = -1;
      *((_QWORD *)&v11 + 1) = -1;
      *(_OWORD *)(v8 + 32) = v11;
      *(_OWORD *)(v8 + 48) = v11;
      *(_OWORD *)(v8 + 64) = v11;
      *(_OWORD *)(v8 + 80) = v11;
      *(_OWORD *)(v8 + 96) = v11;
      *(_OWORD *)v8 = v11;
      *(_OWORD *)(v8 + 16) = v11;
      v12 = *(_DWORD *)(a1 + 928);
      *(_DWORD *)(v8 + 120) = v6 - v12;
      a2[1] = v8 - v12;
      *(_QWORD *)(v8 + 112) = 0xFFFFFFFF00000001;
      *(_DWORD *)(v6 + 116) = v8 - v12;
      *(_DWORD *)v8 = a3;
      *(_DWORD *)(v8 + 4) = a4;
      return 1;
    }
    return 0;
  }
  v16 = (_DWORD *)(v6 + 8 * v7);
  *v16 = a3;
  v16[1] = a4;
  *(_DWORD *)(v6 + 112) = v7 + 1;
  return 1;
}

Phase::Logger *Phase::HeapAllocator::RemoveLookup(Phase::Logger *result, _DWORD *a2, uint64_t a3, unsigned int a4)
{
  int v4;
  uint64_t v6;
  unsigned int v7;
  _QWORD *v8;
  NSObject *v9;
  std::runtime_error *exception;
  NSObject *v11;
  std::runtime_error *v12;
  int v13;
  const char *v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v4 = *(_DWORD *)(a3 + 112);
  if (v4 == 1)
  {
    if (a4)
    {
      v9 = **(NSObject ***)(Phase::Logger::GetInstancePtr(result) + 64);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        v13 = 136315394;
        v14 = "HeapAllocator.cpp";
        v15 = 1024;
        v16 = 1605;
        _os_log_impl(&dword_2164CC000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [inLookupIndex != 0 is true]: \"FindGapLookup() failed!\\n\"", (uint8_t *)&v13, 0x12u);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "FindGapLookup() failed!\n");
    }
    if (a2[1] != (_DWORD)a3 - *((_DWORD *)result + 232))
    {
      v11 = **(NSObject ***)(Phase::Logger::GetInstancePtr(result) + 64);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        v13 = 136315394;
        v14 = "HeapAllocator.cpp";
        v15 = 1024;
        v16 = 1609;
        _os_log_impl(&dword_2164CC000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [pLookupList->mTailOffset != ToOffset(pLookupSet) is true]: \"FindGapLookup() failed!\\n\"", (uint8_t *)&v13, 0x12u);
      }
      v12 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v12, "FindGapLookup() failed!\n");
    }
    return (Phase::Logger *)Phase::HeapAllocator::RemoveLastLookup((uint64_t)result, a2);
  }
  if (v4 == a4 + 1 && *(_DWORD *)(a3 + 116) == -1)
  {
    *(_QWORD *)(a3 + 8 * a4) = 0;
    *(_DWORD *)(a3 + 112) = v4 - 1;
  }
  else
  {
    v6 = *((_QWORD *)result + 116) + a2[1];
    v7 = *(_DWORD *)(v6 + 112) - 1;
    v8 = (_QWORD *)(v6 + 8 * v7);
    *(_QWORD *)(a3 + 8 * a4) = *v8;
    *v8 = 0;
    *(_DWORD *)(v6 + 112) = v7;
    if (!v7)
      return (Phase::Logger *)Phase::HeapAllocator::RemoveLastLookup((uint64_t)result, a2);
  }
  return result;
}

void sub_2165E2F28(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::HeapAllocator::RemoveLastLookup(uint64_t result, _DWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  NSObject *v9;
  std::runtime_error *v10;
  NSObject *v11;
  std::runtime_error *exception;
  int v13;
  const char *v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v2 = a2[1];
  v3 = *(_QWORD *)(result + 928);
  v4 = v3 + v2;
  v5 = *(unsigned int *)(v3 + v2 + 120);
  if ((_DWORD)v5 == -1)
  {
    if (*a2 != (_DWORD)v2)
    {
      v11 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)result) + 64);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        v13 = 136315394;
        v14 = "HeapAllocator.cpp";
        v15 = 1024;
        v16 = 1662;
        _os_log_impl(&dword_2164CC000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [pInLookupList->mHeadOffset != pInLookupList->mTailOffset is true]: \"FindGapLookup() failed!\\n\"", (uint8_t *)&v13, 0x12u);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "FindGapLookup() failed!\n");
    }
    v6 = *(_DWORD *)(v4 + 116);
    *a2 = v6;
  }
  else
  {
    *(_DWORD *)(v5 + v3 + 116) = *(_DWORD *)(v4 + 116);
    v6 = *(_DWORD *)(v4 + 116);
  }
  if (v6 != -1)
  {
    v9 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)result) + 64);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v13 = 136315394;
      v14 = "HeapAllocator.cpp";
      v15 = 1024;
      v16 = 1668;
      _os_log_impl(&dword_2164CC000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [pLookupSet->mNextOffset != kInvalidOffset is true]: \"FindGapLookup() failed!\\n\"", (uint8_t *)&v13, 0x12u);
    }
    v10 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v10, "FindGapLookup() failed!\n");
  }
  a2[1] = v5;
  *(_QWORD *)v4 = 0;
  *(_DWORD *)(v4 + 112) = 0;
  *(_DWORD *)(v4 + 120) = -1;
  v7 = *(_QWORD *)(result + 120);
  v8 = v7 - v3;
  if (!v7)
    v8 = -1;
  *(_DWORD *)(v4 + 116) = v8;
  *(_QWORD *)(result + 120) = v4;
  ++*(_DWORD *)(result + 128);
  return result;
}

void sub_2165E314C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *Phase::SpinLock::Lock(unsigned __int8 *this)
{
  unsigned __int8 *v1;
  unsigned __int8 v2;
  unsigned __int8 v3;

  v1 = this;
  do
    v2 = __ldaxr(this);
  while (__stxr(1u, this));
  if ((v2 & 1) != 0)
  {
    do
    {
      while ((*v1 & 1) != 0)
        this = (unsigned __int8 *)sched_yield();
      do
        v3 = __ldaxr(v1);
      while (__stxr(1u, v1));
    }
    while ((v3 & 1) != 0);
  }
  return this;
}

void applesauce::CF::DictionaryRef::~DictionaryRef(const void **this)
{
  const void *v1;

  v1 = *this;
  if (v1)
    CFRelease(v1);
}

void std::vector<Phase::Controller::HrirAsset::Implementation::Node>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;
  void **v6;
  void *v7;
  void **v8;
  void **v9;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 3;
      do
      {
        v9 = v6;
        std::vector<Phase::Controller::HrirAsset::Implementation::Node>::__destroy_vector::operator()[abi:ne180100](&v9);
        v7 = *(v6 - 3);
        if (v7)
        {
          *(v6 - 2) = v7;
          operator delete(v7);
        }
        v9 = v6 - 6;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v9);
        v8 = v6 - 7;
        v6 -= 10;
      }
      while (v8 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::default_delete<Phase::Controller::HrirAsset::Implementation>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t result;
  void **v4;

  if (a2)
  {
    v4 = (void **)(a2 + 64);
    std::vector<Phase::Controller::HrirAsset::Implementation::Node>::__destroy_vector::operator()[abi:ne180100](&v4);
    v4 = (void **)(a2 + 40);
    std::vector<Phase::Controller::HrirAsset::Implementation::Dimension>::__destroy_vector::operator()[abi:ne180100](&v4);
    if (*(char *)(a2 + 39) < 0)
      operator delete(*(void **)(a2 + 16));
    return MEMORY[0x2199F9D70](a2, 0x1032C40B7D69034);
  }
  return result;
}

void std::vector<Phase::Controller::HrirAsset::Implementation::Dimension>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<Phase::Controller::HrirAsset::Implementation::Dimension>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<Phase::Controller::HrirAsset::Implementation::Dimension>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 40)
  {
    if (*(char *)(i - 17) < 0)
      operator delete(*(void **)(i - 40));
  }
  a1[1] = v2;
}

vDSP_DFT_Setup Phase::DspLayer::IConvolver::GetFftFwd(Phase::DspLayer::IConvolver *this, int a2)
{
  vDSP_DFT_Setup result;

  if (a2 <= 2047)
  {
    switch(a2)
    {
      case 256:
        result = (vDSP_DFT_Setup)Phase::DspLayer::IConvolver::mFFTFwd_256;
        if (!Phase::DspLayer::IConvolver::mFFTFwd_256)
        {
          result = vDSP_DFT_zrop_CreateSetup(0, 0x100uLL, vDSP_DFT_FORWARD);
          Phase::DspLayer::IConvolver::mFFTFwd_256 = (uint64_t)result;
        }
        break;
      case 512:
        result = (vDSP_DFT_Setup)Phase::DspLayer::IConvolver::mFFTFwd_512;
        if (!Phase::DspLayer::IConvolver::mFFTFwd_512)
        {
          result = vDSP_DFT_zrop_CreateSetup(0, 0x200uLL, vDSP_DFT_FORWARD);
          Phase::DspLayer::IConvolver::mFFTFwd_512 = (uint64_t)result;
        }
        break;
      case 1024:
        result = (vDSP_DFT_Setup)Phase::DspLayer::IConvolver::mFFTFwd_1024;
        if (!Phase::DspLayer::IConvolver::mFFTFwd_1024)
        {
          result = vDSP_DFT_zrop_CreateSetup(0, 0x400uLL, vDSP_DFT_FORWARD);
          Phase::DspLayer::IConvolver::mFFTFwd_1024 = (uint64_t)result;
        }
        break;
      default:
        goto LABEL_25;
    }
  }
  else if (a2 >= 0x2000)
  {
    if (a2 == 0x2000)
    {
      result = (vDSP_DFT_Setup)Phase::DspLayer::IConvolver::mFFTFwd_8192;
      if (!Phase::DspLayer::IConvolver::mFFTFwd_8192)
      {
        result = vDSP_DFT_zrop_CreateSetup(0, 0x2000uLL, vDSP_DFT_FORWARD);
        Phase::DspLayer::IConvolver::mFFTFwd_8192 = (uint64_t)result;
      }
    }
    else
    {
      if (a2 != 0x4000)
        goto LABEL_25;
      result = (vDSP_DFT_Setup)Phase::DspLayer::IConvolver::mFFTFwd_16384;
      if (!Phase::DspLayer::IConvolver::mFFTFwd_16384)
      {
        result = vDSP_DFT_zrop_CreateSetup(0, 0x4000uLL, vDSP_DFT_FORWARD);
        Phase::DspLayer::IConvolver::mFFTFwd_16384 = (uint64_t)result;
      }
    }
  }
  else
  {
    if (a2 != 2048)
    {
      if (a2 == 4096)
      {
        result = (vDSP_DFT_Setup)Phase::DspLayer::IConvolver::mFFTFwd_4096;
        if (!Phase::DspLayer::IConvolver::mFFTFwd_4096)
        {
          result = vDSP_DFT_zrop_CreateSetup(0, 0x1000uLL, vDSP_DFT_FORWARD);
          Phase::DspLayer::IConvolver::mFFTFwd_4096 = (uint64_t)result;
        }
        return result;
      }
LABEL_25:
      __assert_rtn("GetFftFwd", "IConvolver.cpp", 53, "false && \"No global forward vDSP_DFT_Setup is available for requested size.\"");
    }
    result = (vDSP_DFT_Setup)Phase::DspLayer::IConvolver::mFFTFwd_2048;
    if (!Phase::DspLayer::IConvolver::mFFTFwd_2048)
    {
      result = vDSP_DFT_zrop_CreateSetup(0, 0x800uLL, vDSP_DFT_FORWARD);
      Phase::DspLayer::IConvolver::mFFTFwd_2048 = (uint64_t)result;
    }
  }
  return result;
}

vDSP_DFT_Setup Phase::DspLayer::IConvolver::GetFftInv(Phase::DspLayer::IConvolver *this, int a2)
{
  vDSP_DFT_Setup result;

  if (a2 <= 2047)
  {
    switch(a2)
    {
      case 256:
        result = (vDSP_DFT_Setup)Phase::DspLayer::IConvolver::mFFTInv_256;
        if (!Phase::DspLayer::IConvolver::mFFTInv_256)
        {
          result = vDSP_DFT_zrop_CreateSetup(0, 0x100uLL, vDSP_DFT_INVERSE);
          Phase::DspLayer::IConvolver::mFFTInv_256 = (uint64_t)result;
        }
        break;
      case 512:
        result = (vDSP_DFT_Setup)Phase::DspLayer::IConvolver::mFFTInv_512;
        if (!Phase::DspLayer::IConvolver::mFFTInv_512)
        {
          result = vDSP_DFT_zrop_CreateSetup(0, 0x200uLL, vDSP_DFT_INVERSE);
          Phase::DspLayer::IConvolver::mFFTInv_512 = (uint64_t)result;
        }
        break;
      case 1024:
        result = (vDSP_DFT_Setup)Phase::DspLayer::IConvolver::mFFTInv_1024;
        if (!Phase::DspLayer::IConvolver::mFFTInv_1024)
        {
          result = vDSP_DFT_zrop_CreateSetup(0, 0x400uLL, vDSP_DFT_INVERSE);
          Phase::DspLayer::IConvolver::mFFTInv_1024 = (uint64_t)result;
        }
        break;
      default:
        goto LABEL_25;
    }
  }
  else if (a2 >= 0x2000)
  {
    if (a2 == 0x2000)
    {
      result = (vDSP_DFT_Setup)Phase::DspLayer::IConvolver::mFFTInv_8192;
      if (!Phase::DspLayer::IConvolver::mFFTInv_8192)
      {
        result = vDSP_DFT_zrop_CreateSetup(0, 0x2000uLL, vDSP_DFT_INVERSE);
        Phase::DspLayer::IConvolver::mFFTInv_8192 = (uint64_t)result;
      }
    }
    else
    {
      if (a2 != 0x4000)
        goto LABEL_25;
      result = (vDSP_DFT_Setup)Phase::DspLayer::IConvolver::mFFTInv_16384;
      if (!Phase::DspLayer::IConvolver::mFFTInv_16384)
      {
        result = vDSP_DFT_zrop_CreateSetup(0, 0x4000uLL, vDSP_DFT_INVERSE);
        Phase::DspLayer::IConvolver::mFFTInv_16384 = (uint64_t)result;
      }
    }
  }
  else
  {
    if (a2 != 2048)
    {
      if (a2 == 4096)
      {
        result = (vDSP_DFT_Setup)Phase::DspLayer::IConvolver::mFFTInv_4096;
        if (!Phase::DspLayer::IConvolver::mFFTInv_4096)
        {
          result = vDSP_DFT_zrop_CreateSetup(0, 0x1000uLL, vDSP_DFT_INVERSE);
          Phase::DspLayer::IConvolver::mFFTInv_4096 = (uint64_t)result;
        }
        return result;
      }
LABEL_25:
      __assert_rtn("GetFftInv", "IConvolver.cpp", 84, "false && \"No global inverse vDSP_DFT_Setup is available for requested size.\"");
    }
    result = (vDSP_DFT_Setup)Phase::DspLayer::IConvolver::mFFTInv_2048;
    if (!Phase::DspLayer::IConvolver::mFFTInv_2048)
    {
      result = vDSP_DFT_zrop_CreateSetup(0, 0x800uLL, vDSP_DFT_INVERSE);
      Phase::DspLayer::IConvolver::mFFTInv_2048 = (uint64_t)result;
    }
  }
  return result;
}

uint64_t Phase::DspLayer::IConvolver::GetReblockerIn(Phase::DspLayer::IConvolver *this)
{
  return 0;
}

void Phase::SpatialModeler::ImportanceSampling::init(void **this, void *a2, float a3)
{
  Phase::SpatialModeler::ImportanceSampling::alloc(this, a2);
  if (*this)
  {
    bzero(this[2], 4 * (_QWORD)*this);
    bzero(this[3], 4 * (_QWORD)*this + 4);
  }
  *((float *)this + 2) = a3;
}

void **Phase::SpatialModeler::ImportanceSampling::operator=(void **this, uint64_t a2)
{
  if (this != (void **)a2)
  {
    Phase::SpatialModeler::ImportanceSampling::alloc(this, *(void **)a2);
    if (*this)
    {
      memcpy(this[2], *(const void **)(a2 + 16), 4 * (_QWORD)*this);
      memcpy(this[3], *(const void **)(a2 + 24), 4 * (_QWORD)*this + 4);
    }
    *((_DWORD *)this + 2) = *(_DWORD *)(a2 + 8);
  }
  return this;
}

void Phase::SpatialModeler::ImportanceSampling::alloc(void **this, void *a2)
{
  size_t v4;

  if (*this != a2)
  {
    *this = a2;
    free(this[2]);
    this[2] = 0;
    free(this[3]);
    this[3] = 0;
    if (a2)
    {
      v4 = 4 * (_QWORD)a2;
      this[2] = malloc_type_malloc(v4, 0x100004052888210uLL);
      this[3] = malloc_type_malloc(v4 + 4, 0x100004052888210uLL);
    }
  }
}

void Phase::SpatialModeler::ImportanceSampling::~ImportanceSampling(void **this)
{
  free(this[2]);
  free(this[3]);
}

uint64_t Phase::SpatialModeler::ImportanceSampling::computeProbabilityDistribution(uint64_t result, uint64_t a2, uint64_t a3, _QWORD *a4, float *a5)
{
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float32x2_t *v8;
  float v9;
  float32x2_t v10;
  float32x2_t v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float32x2_t v16;
  float v17;
  float v18;
  uint64_t v19;
  float v20;
  _DWORD *v21;
  float v22;

  *a5 = 0.0;
  v5 = *(_QWORD *)result;
  if (*(_QWORD *)result)
  {
    v6 = 0;
    v7 = *(_QWORD *)(result + 16);
    v8 = (float32x2_t *)(*a4 + 28);
    do
    {
      v9 = *(float *)a2 - v8[-1].f32[1];
      v10 = vsub_f32(*(float32x2_t *)(a2 + 4), *v8);
      v11 = vmul_f32(v10, v10);
      v12 = sqrtf((float)((float)(v9 * v9) + v11.f32[0]) + v11.f32[1]);
      v13 = *(float *)(result + 8);
      v14 = 1.0;
      if ((float)(v12 * v12) > v13)
      {
        v15 = fminf(fmaxf((float)(v13 / (float)(v12 * v12)) * 0.5, 0.0), 1.0);
        v16 = vmul_f32(v10, *(float32x2_t *)(a3 + 4));
        v17 = fabsf((float)((float)(v9 * *(float *)a3) + v16.f32[0]) + v16.f32[1]);
        v14 = (float)((float)(v15 * v17) / v12) + (float)((float)(v15 * v17) / v12);
      }
      *(float *)(v7 + 4 * v6) = v14;
      v18 = v14 + *a5;
      *a5 = v18;
      ++v6;
      v8 += 7;
    }
    while (v5 > v6);
    v19 = 0;
    v20 = v18 / (float)v5;
    if (v18 <= 0.0)
      v20 = 1.0;
    v21 = *(_DWORD **)(result + 24);
    *v21 = 0;
    v22 = 0.0;
    do
    {
      v22 = v22 + (float)((float)(*(float *)(v7 + 4 * v19++) / v20) / (float)v5);
      *(float *)&v21[v19] = v22;
    }
    while (v5 > v19);
  }
  else
  {
    **(_DWORD **)(result + 24) = 0;
  }
  return result;
}

uint64_t Phase::SpatialModeler::ImportanceSampling::pickRandomSource(Phase::SpatialModeler::ImportanceSampling *this, float a2)
{
  float *v2;
  unint64_t v3;
  float v4;
  uint64_t result;
  unsigned int v6;
  float v7;

  if (a2 == 1.0)
    a2 = 0.0;
  v2 = (float *)*((_QWORD *)this + 3);
  if (a2 < *v2)
    return 0;
  v3 = *(_QWORD *)this;
  v4 = v2[*(_QWORD *)this];
  if (a2 >= v4)
    return 0;
  result = (float)((float)((float)(a2 - *v2) / (float)(v4 - *v2)) * (float)v3);
  if (a2 >= v2[result] && a2 < v2[(result + 1)])
    return result;
  if (v3 < 2)
    return 0;
  LODWORD(result) = 0;
  do
  {
    v6 = (result + v3) >> 1;
    v7 = v2[v6];
    if (a2 >= v7)
      result = v6;
    else
      result = result;
    if (a2 < v7)
      LODWORD(v3) = v6;
  }
  while ((v3 - result) > 1);
  return result;
}

uint64_t Phase::Controller::InMemoryAudioFile::Init(uint64_t a1, void *a2, AudioFileTypeID a3, uint64_t a4, _QWORD *a5)
{
  id v9;
  void *v10;
  id v11;
  OSStatus v12;
  Phase::Logger *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  Phase::Logger *v18;
  NSObject *v19;
  void *v20;
  NSObject *v21;
  id v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  Phase::Logger *v29;
  uint64_t v30;
  Phase::Logger *v31;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v9 = a2;
  v10 = v9;
  if (!v9)
  {
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("inAudioFileData is null!"));
    v13 = (Phase::Logger *)objc_claimAutoreleasedReturnValue();
    v23 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v13)
                                                                                        + 816)));
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v33 = "InMemoryAudioFile.mm";
      v34 = 1024;
      v35 = 31;
      v36 = 2048;
      v37 = a4;
      v38 = 2080;
      v39 = -[Phase::Logger UTF8String](objc_retainAutorelease(v13), "UTF8String");
      _os_log_impl(&dword_2164CC000, v23, OS_LOG_TYPE_ERROR, "%25s:%-5d SoundAssetError for assetId %llu: %s", buf, 0x26u);
    }

    if (!a5)
      goto LABEL_19;
    v30 = *MEMORY[0x24BDD0FC8];
    v31 = v13;
    objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v31, &v30, 1);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", CFSTR("com.apple.coreaudio.phase"), 1346920803, v17);
    v22 = (id)objc_claimAutoreleasedReturnValue();
LABEL_17:
    *a5 = v22;
LABEL_18:

LABEL_19:
    v24 = 0;
    goto LABEL_20;
  }
  v11 = objc_retainAutorelease(v9);
  if (!objc_msgSend(v11, "bytes") || !objc_msgSend(v11, "length"))
  {
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("inAudioFileData.bytes is null! This is either because the NSData bytes property was explicitly set to nil, or because the NSData length property was explicitly set to 0."));
    v13 = (Phase::Logger *)objc_claimAutoreleasedReturnValue();
    v21 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v13)
                                                                                        + 816)));
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v33 = "InMemoryAudioFile.mm";
      v34 = 1024;
      v35 = 40;
      v36 = 2048;
      v37 = a4;
      v38 = 2080;
      v39 = -[Phase::Logger UTF8String](objc_retainAutorelease(v13), "UTF8String");
      _os_log_impl(&dword_2164CC000, v21, OS_LOG_TYPE_ERROR, "%25s:%-5d SoundAssetError for assetId %llu: %s", buf, 0x26u);
    }

    if (!a5)
      goto LABEL_19;
    v28 = *MEMORY[0x24BDD0FC8];
    v29 = v13;
    objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v29, &v28, 1);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", CFSTR("com.apple.coreaudio.phase"), 1346920803, v17);
    v22 = (id)objc_claimAutoreleasedReturnValue();
    goto LABEL_17;
  }
  objc_storeStrong((id *)a1, v11);
  v12 = AudioFileOpenWithCallbacks((void *)a1, (AudioFile_ReadProc)Phase::Controller::InMemoryAudioFile::sReadProc, 0, (AudioFile_GetSizeProc)Phase::Controller::InMemoryAudioFile::sGetSizeProc, 0, a3, (AudioFileID *)(a1 + 8));
  if (v12)
  {
    objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", *MEMORY[0x24BDD1100], v12, 0);
    v13 = (Phase::Logger *)objc_claimAutoreleasedReturnValue();
    v14 = (void *)MEMORY[0x24BDD17C8];
    objc_msgSend(v11, "description");
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    -[Phase::Logger description](v13, "description");
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v14, "stringWithFormat:", CFSTR("AudioFileOpenWithCallbacks() failed to read audio file data from '%@' with error '%@'."), v15, v16);
    v17 = (void *)objc_claimAutoreleasedReturnValue();

    v19 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v18)
                                                                                        + 816)));
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v33 = "InMemoryAudioFile.mm";
      v34 = 1024;
      v35 = 56;
      v36 = 2048;
      v37 = a4;
      v38 = 2080;
      v39 = objc_msgSend(objc_retainAutorelease(v17), "UTF8String");
      _os_log_impl(&dword_2164CC000, v19, OS_LOG_TYPE_ERROR, "%25s:%-5d SoundAssetError for assetId %llu: %s", buf, 0x26u);
    }

    if (a5)
    {
      v26 = *MEMORY[0x24BDD0FC8];
      v27 = v17;
      objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v27, &v26, 1);
      v20 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", CFSTR("com.apple.coreaudio.phase"), 1346920801, v20);
      *a5 = (id)objc_claimAutoreleasedReturnValue();

    }
    goto LABEL_18;
  }
  if (!*(_QWORD *)(a1 + 8))
    std::terminate();
  v24 = 1;
LABEL_20:

  return v24;
}

void sub_2165E3E34(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::InMemoryAudioFile::sReadProc(id *this, Phase::Logger *a2, uint64_t a3, void *a4, int *a5, unsigned int *a6)
{
  unsigned int v8;
  Phase::Logger *v11;
  char *v12;
  int v13;
  uint64_t result;
  NSObject *v15;
  id v16;
  int v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  Phase::Logger *v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  if (!this)
    std::terminate();
  v8 = a3;
  v11 = (Phase::Logger *)objc_msgSend(*this, "length", a3, a4, a5, a6);
  if ((uint64_t)v11 < (uint64_t)a2)
    a2 = v11;
  if ((uint64_t)v11 >= (uint64_t)((char *)a2 + v8))
    v12 = (char *)a2 + v8;
  else
    v12 = (char *)v11;
  v13 = (_DWORD)v12 - (_DWORD)a2;
  if ((uint64_t)v12 > (uint64_t)a2)
  {
    memcpy(a4, (char *)a2 + objc_msgSend(*this, "bytes"), v12 - (char *)a2);
    result = 0;
    if (!a5)
      return result;
    goto LABEL_14;
  }
  v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v11)
                                                                                      + 384)));
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    objc_msgSend(*this, "description");
    v16 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v17 = 136316162;
    v18 = "InMemoryAudioFile.mm";
    v19 = 1024;
    v20 = 105;
    v21 = 2080;
    v22 = objc_msgSend(v16, "UTF8String");
    v23 = 2048;
    v24 = v12;
    v25 = 2048;
    v26 = a2;
    _os_log_impl(&dword_2164CC000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d Invalid read request for audio file data '%s'! The end position %lld is <= the start position %lld,", (uint8_t *)&v17, 0x30u);

  }
  result = 4294967256;
  if (a5)
  {
    v13 = 0;
LABEL_14:
    *a5 = v13;
  }
  return result;
}

void sub_2165E407C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::InMemoryAudioFile::sGetSizeProc(id *this, void *a2)
{
  if (!this)
    std::terminate();
  return objc_msgSend(*this, "length");
}

void Phase::Controller::InMemoryAudioFile::~InMemoryAudioFile(Phase::Controller::InMemoryAudioFile *this)
{
  void *v2;

  Phase::Controller::InMemoryAudioFile::CloseAudioFile(this, 0);
  v2 = *(void **)this;
  *(_QWORD *)this = 0;

}

void Phase::Controller::InMemoryAudioFile::CloseAudioFile(Phase::Controller::InMemoryAudioFile *this, int a2)
{
  OpaqueAudioFileID *v3;
  OSStatus v5;
  Phase::Logger *v6;
  Phase::Logger *v7;
  NSObject *v8;
  id v9;
  uint64_t v10;
  id v11;
  NSObject *v12;
  id v13;
  uint64_t v14;
  id v15;
  std::runtime_error *exception;
  int v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v3 = (OpaqueAudioFileID *)*((_QWORD *)this + 1);
  if (v3)
  {
    v5 = AudioFileClose(v3);
    if (v5)
    {
      objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", *MEMORY[0x24BDD1100], v5, 0);
      v6 = (Phase::Logger *)objc_claimAutoreleasedReturnValue();
      v7 = v6;
      if (a2)
      {
        v12 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v6)
                                                                                            + 384)));
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          objc_msgSend(*(id *)this, "description");
          v13 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v14 = objc_msgSend(v13, "UTF8String");
          -[Phase::Logger description](v7, "description");
          v15 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v17 = 136315906;
          v18 = "InMemoryAudioFile.mm";
          v19 = 1024;
          v20 = 139;
          v21 = 2080;
          v22 = v14;
          v23 = 2080;
          v24 = objc_msgSend(v15, "UTF8String");
          _os_log_impl(&dword_2164CC000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error): \"Failed to close audio file referencing audio file data '%s' with error '%s'.\"", (uint8_t *)&v17, 0x26u);

        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Failed to close audio file referencing audio file data '%s' with error '%s'.");
      }
      v8 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v6)
                                                                                         + 384)));
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        objc_msgSend(*(id *)this, "description");
        v9 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v10 = objc_msgSend(v9, "UTF8String");
        -[Phase::Logger description](v7, "description");
        v11 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v17 = 136315906;
        v18 = "InMemoryAudioFile.mm";
        v19 = 1024;
        v20 = 146;
        v21 = 2080;
        v22 = v10;
        v23 = 2080;
        v24 = objc_msgSend(v11, "UTF8String");
        _os_log_impl(&dword_2164CC000, v8, OS_LOG_TYPE_ERROR, "%25s:%-5d Failed to close audio file referencing audio file data '%s' with error '%s'.", (uint8_t *)&v17, 0x26u);

      }
    }
    *((_QWORD *)this + 1) = 0;
  }
}

void sub_2165E436C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void Phase::Controller::InMemoryAudioFile::Description(id *this@<X0>, _QWORD *a2@<X8>)
{
  id v3;

  objc_msgSend(*this, "description");
  v3 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  std::string::basic_string[abi:ne180100]<0>(a2, (char *)objc_msgSend(v3, "UTF8String"));

}

void sub_2165E442C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

_OWORD *Phase::Controller::IR::IRBuilder::IRBuilder(_OWORD *a1, _OWORD *a2, const Phase::Controller::Spatializer *a3)
{
  uint64_t v3;
  _OWORD *v5;
  uint64_t v6;
  Phase::Logger *v7;
  void **v8;
  uint64_t InstancePtr;
  Phase::Logger *v10;
  Phase::Logger *v11;
  NSObject *v12;
  NSObject *v13;
  _QWORD *v14;
  double v15;
  unint64_t v16;
  uint64_t *v17;
  uint8x8_t v18;
  size_t v19;
  _QWORD *v20;
  float v21;
  _BOOL8 v22;
  unint64_t v23;
  unint64_t v24;
  size_t v25;
  _QWORD *v26;
  _QWORD *v27;
  unint64_t v28;
  uint64_t v29;
  double v30;
  unint64_t v31;
  uint8x8_t v32;
  uint64_t *v33;
  size_t v34;
  _QWORD *v35;
  float v36;
  _BOOL8 v37;
  unint64_t v38;
  unint64_t v39;
  size_t v40;
  size_t v41;
  _QWORD *v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint8x8_t v46;
  uint64_t **v47;
  uint64_t *i;
  size_t v49;
  _QWORD *v50;
  float v51;
  _BOOL8 v52;
  unint64_t v53;
  unint64_t v54;
  size_t v55;
  size_t v56;
  _QWORD *v57;
  unint64_t v58;
  _QWORD *v59;
  size_t v60;
  uint8x8_t v61;
  uint64_t **v62;
  uint64_t *j;
  size_t v64;
  _QWORD *v65;
  float v66;
  _BOOL8 v67;
  unint64_t v68;
  unint64_t v69;
  size_t v70;
  size_t v71;
  _QWORD *v72;
  size_t v73;
  uint64_t *v74;
  unint64_t v75;
  uint8x8_t v76;
  uint64_t **v77;
  uint64_t *k;
  unint64_t v79;
  _QWORD *v80;
  float v81;
  _BOOL8 v82;
  unint64_t v83;
  unint64_t v84;
  size_t v85;
  uint64_t v86;
  _QWORD *v87;
  unint64_t v88;
  int v89;
  unint64_t v90;
  unint64_t v91;
  uint8x8_t v92;
  uint64_t **v93;
  uint64_t *m;
  unint64_t v95;
  char *v96;
  _QWORD *v97;
  __int128 v98;
  __int128 v99;
  unint64_t v100;
  float v101;
  float v102;
  _BOOL8 v103;
  unint64_t v104;
  unint64_t v105;
  int8x8_t prime;
  void *v107;
  void *v108;
  uint64_t v109;
  _QWORD *v110;
  unint64_t v111;
  uint8x8_t v112;
  unint64_t v113;
  uint8x8_t v114;
  uint64_t v115;
  _QWORD *v116;
  unint64_t v117;
  _QWORD *v118;
  uint64_t v119;
  unint64_t v120;
  Phase::Logger *v121;
  Phase::Logger *v122;
  NSObject *v123;
  NSObject *v124;
  void *v126;
  Phase::Logger *v127;
  const Phase::Controller::Spatializer *v128;
  _OWORD *v129;
  uint8_t buf[4];
  __int128 v131;
  __int128 v132;
  float v133;
  _BYTE v134[40];
  _BYTE v135[40];
  size_t __n[2];
  __int128 v137;
  float v138;
  _QWORD v139[2];
  char v140;

  v5 = a1;
  *a1 = *a2;
  v6 = (uint64_t)(a1 + 1);
  v7 = (Phase::Logger *)std::unordered_map<unsigned int,unsigned int>::unordered_map((uint64_t)(a1 + 1), (uint64_t)(a2 + 1));
  *(_OWORD *)((char *)v5 + 56) = 0u;
  v8 = (void **)v5 + 7;
  *(_OWORD *)((char *)v5 + 72) = 0u;
  *((_DWORD *)v5 + 22) = 1065353216;
  *((_QWORD *)v5 + 12) = 0;
  InstancePtr = Phase::Logger::GetInstancePtr(v7);
  v10 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(InstancePtr + 272));
  v11 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v10);
  if (*((_BYTE *)v11 + 280))
  {
    v12 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v11)
                                                                                        + 272)));
    v13 = v12;
    if ((unint64_t)v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v12))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v13, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v10, "Phase_IrBuilder_Construction", "IR builders construction", buf, 2u);
    }

  }
  if ((*((_DWORD *)v5 + 3) | 2) != 2)
    goto LABEL_269;
  *(_OWORD *)__n = 0u;
  v137 = 0u;
  v138 = 1.0;
  v14 = (_QWORD *)operator new();
  v15 = *(double *)v5;
  *v14 = &off_24D57DFC0;
  Phase::Controller::IR::FIRUtilManager::FIRUtilManager((Phase::Controller::IR::FIRUtilManager *)(v14 + 1), v15);
  v16 = __n[1];
  if (__n[1])
  {
    if (*(_QWORD *)__n[0])
    {
      v17 = **(uint64_t ***)__n[0];
      if (v17)
      {
        v18 = (uint8x8_t)vcnt_s8((int8x8_t)__n[1]);
        v18.i16[0] = vaddlv_u8(v18);
        do
        {
          v19 = v17[1];
          if (v19)
          {
            if (v18.u32[0] > 1uLL)
            {
              if (v19 < __n[1] || v19 % __n[1])
                break;
            }
            else if ((v19 & (__n[1] - 1)) != 0)
            {
              break;
            }
          }
          else if (!*((_DWORD *)v17 + 4))
          {
            goto LABEL_38;
          }
          v17 = (uint64_t *)*v17;
        }
        while (v17);
      }
    }
  }
  v20 = operator new(0x20uLL);
  *v20 = 0;
  v20[1] = 0;
  *((_DWORD *)v20 + 4) = 0;
  v20[3] = v14;
  v21 = (float)(unint64_t)(*((_QWORD *)&v137 + 1) + 1);
  if (!v16 || (float)(v138 * (float)v16) < v21)
  {
    v22 = 1;
    if (v16 >= 3)
      v22 = (v16 & (v16 - 1)) != 0;
    v23 = v22 | (2 * v16);
    v24 = vcvtps_u32_f32(v21 / v138);
    if (v23 <= v24)
      v25 = v24;
    else
      v25 = v23;
    std::__hash_table<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>>>::__rehash<true>((uint64_t)__n, v25);
    v16 = __n[1];
  }
  v26 = (_QWORD *)__n[0];
  v27 = *(_QWORD **)__n[0];
  if (*(_QWORD *)__n[0])
  {
    *v20 = *v27;
LABEL_36:
    *v27 = v20;
    goto LABEL_37;
  }
  *v20 = v137;
  *(_QWORD *)&v137 = v20;
  *v26 = &v137;
  if (*v20)
  {
    v28 = *(_QWORD *)(*v20 + 8);
    if ((v16 & (v16 - 1)) != 0)
    {
      if (v28 >= v16)
        v28 %= v16;
    }
    else
    {
      v28 &= v16 - 1;
    }
    v27 = (_QWORD *)(__n[0] + 8 * v28);
    goto LABEL_36;
  }
LABEL_37:
  ++*((_QWORD *)&v137 + 1);
LABEL_38:
  v29 = operator new();
  v30 = *(double *)v5;
  std::unordered_map<unsigned int,unsigned int>::unordered_map((uint64_t)v135, v6);
  Phase::Controller::IR::IRBuilderCpuFIRCrossover::IRBuilderCpuFIRCrossover(v29, (uint64_t)v135, *((_DWORD *)v5 + 2), 16, v30);
  v31 = __n[1];
  if (__n[1])
  {
    v32 = (uint8x8_t)vcnt_s8((int8x8_t)__n[1]);
    v32.i16[0] = vaddlv_u8(v32);
    v3 = v32.u32[0] >= 2uLL ? __n[1] != 1 : (__n[1] & 1) == 0;
    v33 = *(uint64_t **)(__n[0] + 8 * v3);
    if (v33)
    {
      while (1)
      {
        v33 = (uint64_t *)*v33;
        if (!v33)
          break;
        v34 = v33[1];
        if (v34 == 1)
        {
          if (*((_DWORD *)v33 + 4) == 1)
            goto LABEL_72;
        }
        else
        {
          if (v32.u32[0] > 1uLL)
          {
            if (v34 >= __n[1])
              v34 %= __n[1];
          }
          else
          {
            v34 &= __n[1] - 1;
          }
          if (v34 != v3)
            break;
        }
      }
    }
  }
  v35 = operator new(0x20uLL);
  *v35 = 0;
  v35[1] = 1;
  *((_DWORD *)v35 + 4) = 1;
  v35[3] = v29;
  v36 = (float)(unint64_t)(*((_QWORD *)&v137 + 1) + 1);
  if (!v31 || (float)(v138 * (float)v31) < v36)
  {
    v37 = 1;
    if (v31 >= 3)
      v37 = (v31 & (v31 - 1)) != 0;
    v38 = v37 | (2 * v31);
    v39 = vcvtps_u32_f32(v36 / v138);
    if (v38 <= v39)
      v40 = v39;
    else
      v40 = v38;
    std::__hash_table<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>>>::__rehash<true>((uint64_t)__n, v40);
    v31 = __n[1];
    if ((__n[1] & (__n[1] - 1)) != 0)
      v3 = __n[1] > 1;
    else
      v3 = (__n[1] & 1) == 0;
  }
  v41 = __n[0];
  v42 = *(_QWORD **)(__n[0] + 8 * v3);
  if (v42)
  {
    *v35 = *v42;
LABEL_70:
    *v42 = v35;
    goto LABEL_71;
  }
  *v35 = v137;
  *(_QWORD *)&v137 = v35;
  *(_QWORD *)(v41 + 8 * v3) = &v137;
  if (*v35)
  {
    v43 = *(_QWORD *)(*v35 + 8);
    if ((v31 & (v31 - 1)) != 0)
    {
      if (v43 >= v31)
        v43 %= v31;
    }
    else
    {
      v43 &= v31 - 1;
    }
    v42 = (_QWORD *)(__n[0] + 8 * v43);
    goto LABEL_70;
  }
LABEL_71:
  ++*((_QWORD *)&v137 + 1);
LABEL_72:
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)v135);
  v44 = operator new();
  std::unordered_map<unsigned int,unsigned int>::unordered_map((uint64_t)v134, v6);
  Phase::Controller::IR::IRBuilderCpuIIRCrossover::IRBuilderCpuIIRCrossover(v44, (uint64_t)v134);
  v45 = __n[1];
  if (__n[1])
  {
    v46 = (uint8x8_t)vcnt_s8((int8x8_t)__n[1]);
    v46.i16[0] = vaddlv_u8(v46);
    if (v46.u32[0] > 1uLL)
    {
      v16 = 2;
      if (__n[1] <= 2)
        v16 = 2u % LOBYTE(__n[1]);
    }
    else
    {
      v16 = (LODWORD(__n[1]) - 1) & 2;
    }
    v47 = *(uint64_t ***)(__n[0] + 8 * v16);
    if (v47)
    {
      for (i = *v47; i; i = (uint64_t *)*i)
      {
        v49 = i[1];
        if (v49 == 2)
        {
          if (*((_DWORD *)i + 4) == 2)
            goto LABEL_110;
        }
        else
        {
          if (v46.u32[0] > 1uLL)
          {
            if (v49 >= __n[1])
              v49 %= __n[1];
          }
          else
          {
            v49 &= __n[1] - 1;
          }
          if (v49 != v16)
            break;
        }
      }
    }
  }
  v50 = operator new(0x20uLL);
  *v50 = 0;
  v50[1] = 2;
  *((_DWORD *)v50 + 4) = 2;
  v50[3] = v44;
  v51 = (float)(unint64_t)(*((_QWORD *)&v137 + 1) + 1);
  if (!v45 || (float)(v138 * (float)v45) < v51)
  {
    v52 = 1;
    if (v45 >= 3)
      v52 = (v45 & (v45 - 1)) != 0;
    v53 = v52 | (2 * v45);
    v54 = vcvtps_u32_f32(v51 / v138);
    if (v53 <= v54)
      v55 = v54;
    else
      v55 = v53;
    std::__hash_table<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>>>::__rehash<true>((uint64_t)__n, v55);
    v45 = __n[1];
    if ((__n[1] & (__n[1] - 1)) != 0)
    {
      v16 = 2;
      if (__n[1] <= 2)
        v16 = 2u % LOBYTE(__n[1]);
    }
    else
    {
      v16 = (LODWORD(__n[1]) - 1) & 2;
    }
  }
  v56 = __n[0];
  v57 = *(_QWORD **)(__n[0] + 8 * v16);
  if (v57)
  {
    *v50 = *v57;
LABEL_108:
    *v57 = v50;
    goto LABEL_109;
  }
  *v50 = v137;
  *(_QWORD *)&v137 = v50;
  *(_QWORD *)(v56 + 8 * v16) = &v137;
  if (*v50)
  {
    v58 = *(_QWORD *)(*v50 + 8);
    if ((v45 & (v45 - 1)) != 0)
    {
      if (v58 >= v45)
        v58 %= v45;
    }
    else
    {
      v58 &= v45 - 1;
    }
    v57 = (_QWORD *)(__n[0] + 8 * v58);
    goto LABEL_108;
  }
LABEL_109:
  ++*((_QWORD *)&v137 + 1);
LABEL_110:
  v128 = a3;
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)v134);
  v59 = (_QWORD *)operator new();
  *v59 = &off_24D57E020;
  v60 = __n[1];
  v129 = v5;
  if (__n[1])
  {
    v61 = (uint8x8_t)vcnt_s8((int8x8_t)__n[1]);
    v61.i16[0] = vaddlv_u8(v61);
    if (v61.u32[0] > 1uLL)
    {
      v16 = 3;
      if (__n[1] <= 3)
        v16 = 3u % LOBYTE(__n[1]);
    }
    else
    {
      v16 = (LODWORD(__n[1]) - 1) & 3;
    }
    v62 = *(uint64_t ***)(__n[0] + 8 * v16);
    if (v62)
    {
      for (j = *v62; j; j = (uint64_t *)*j)
      {
        v64 = j[1];
        if (v64 == 3)
        {
          if (*((_DWORD *)j + 4) == 3)
            goto LABEL_148;
        }
        else
        {
          if (v61.u32[0] > 1uLL)
          {
            if (v64 >= __n[1])
              v64 %= __n[1];
          }
          else
          {
            v64 &= __n[1] - 1;
          }
          if (v64 != v16)
            break;
        }
      }
    }
  }
  v65 = operator new(0x20uLL);
  *v65 = 0;
  v65[1] = 3;
  *((_DWORD *)v65 + 4) = 3;
  v65[3] = v59;
  v66 = (float)(unint64_t)(*((_QWORD *)&v137 + 1) + 1);
  if (!v60 || (float)(v138 * (float)v60) < v66)
  {
    v67 = 1;
    if (v60 >= 3)
      v67 = (v60 & (v60 - 1)) != 0;
    v68 = v67 | (2 * v60);
    v69 = vcvtps_u32_f32(v66 / v138);
    if (v68 <= v69)
      v70 = v69;
    else
      v70 = v68;
    std::__hash_table<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>>>::__rehash<true>((uint64_t)__n, v70);
    v60 = __n[1];
    if ((__n[1] & (__n[1] - 1)) != 0)
    {
      v16 = 3;
      if (__n[1] <= 3)
        v16 = 3u % LOBYTE(__n[1]);
    }
    else
    {
      v16 = (LODWORD(__n[1]) - 1) & 3;
    }
  }
  v71 = __n[0];
  v72 = *(_QWORD **)(__n[0] + 8 * v16);
  if (v72)
  {
    *v65 = *v72;
LABEL_146:
    *v72 = v65;
    goto LABEL_147;
  }
  *v65 = v137;
  *(_QWORD *)&v137 = v65;
  *(_QWORD *)(v71 + 8 * v16) = &v137;
  if (*v65)
  {
    v73 = *(_QWORD *)(*v65 + 8);
    if ((v60 & (v60 - 1)) != 0)
    {
      if (v73 >= v60)
        v73 %= v60;
    }
    else
    {
      v73 &= v60 - 1;
    }
    v72 = (_QWORD *)(__n[0] + 8 * v73);
    goto LABEL_146;
  }
LABEL_147:
  ++*((_QWORD *)&v137 + 1);
LABEL_148:
  v127 = v10;
  *(_DWORD *)buf = 0;
  v131 = 0u;
  v132 = 0u;
  v133 = v138;
  std::__hash_table<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>>>::__rehash<true>((uint64_t)&v131, v60);
  v74 = (uint64_t *)v137;
  if ((_QWORD)v137)
  {
    v45 = *((_QWORD *)&v131 + 1);
    do
    {
      v75 = *((int *)v74 + 4);
      if (v45)
      {
        v76 = (uint8x8_t)vcnt_s8((int8x8_t)v45);
        v76.i16[0] = vaddlv_u8(v76);
        if (v76.u32[0] > 1uLL)
        {
          v3 = *((int *)v74 + 4);
          if (v45 <= v75)
            v3 = v75 % v45;
        }
        else
        {
          v3 = (v45 - 1) & v75;
        }
        v77 = *(uint64_t ***)(v131 + 8 * v3);
        if (v77)
        {
          for (k = *v77; k; k = (uint64_t *)*k)
          {
            v79 = k[1];
            if (v79 == v75)
            {
              if (*((_DWORD *)k + 4) == (_DWORD)v75)
                goto LABEL_188;
            }
            else
            {
              if (v76.u32[0] > 1uLL)
              {
                if (v79 >= v45)
                  v79 %= v45;
              }
              else
              {
                v79 &= v45 - 1;
              }
              if (v79 != v3)
                break;
            }
          }
        }
      }
      v80 = operator new(0x20uLL);
      *v80 = 0;
      v80[1] = v75;
      *((_OWORD *)v80 + 1) = *((_OWORD *)v74 + 1);
      v81 = (float)(unint64_t)(*((_QWORD *)&v132 + 1) + 1);
      if (!v45 || (float)(v133 * (float)v45) < v81)
      {
        v82 = (v45 & (v45 - 1)) != 0;
        if (v45 < 3)
          v82 = 1;
        v83 = v82 | (2 * v45);
        v84 = vcvtps_u32_f32(v81 / v133);
        if (v83 <= v84)
          v85 = v84;
        else
          v85 = v83;
        std::__hash_table<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>>>::__rehash<true>((uint64_t)&v131, v85);
        v45 = *((_QWORD *)&v131 + 1);
        if ((*((_QWORD *)&v131 + 1) & (*((_QWORD *)&v131 + 1) - 1)) != 0)
        {
          if (*((_QWORD *)&v131 + 1) <= v75)
            v3 = v75 % *((_QWORD *)&v131 + 1);
          else
            v3 = v75;
        }
        else
        {
          v3 = (*((_QWORD *)&v131 + 1) - 1) & v75;
        }
      }
      v86 = v131;
      v87 = *(_QWORD **)(v131 + 8 * v3);
      if (v87)
      {
        *v80 = *v87;
      }
      else
      {
        *v80 = v132;
        *(_QWORD *)&v132 = v80;
        *(_QWORD *)(v86 + 8 * v3) = &v132;
        if (!*v80)
          goto LABEL_187;
        v88 = *(_QWORD *)(*v80 + 8);
        if ((v45 & (v45 - 1)) != 0)
        {
          if (v88 >= v45)
            v88 %= v45;
        }
        else
        {
          v88 &= v45 - 1;
        }
        v87 = (_QWORD *)(v131 + 8 * v88);
      }
      *v87 = v80;
LABEL_187:
      ++*((_QWORD *)&v132 + 1);
LABEL_188:
      v74 = (uint64_t *)*v74;
    }
    while (v74);
  }
  v89 = *(_DWORD *)buf;
  v90 = *(int *)buf;
  v91 = *((_QWORD *)v5 + 8);
  if (v91)
  {
    v92 = (uint8x8_t)vcnt_s8((int8x8_t)v91);
    v92.i16[0] = vaddlv_u8(v92);
    if (v92.u32[0] > 1uLL)
    {
      v45 = *(int *)buf;
      if (v91 <= *(int *)buf)
        v45 = *(int *)buf % v91;
    }
    else
    {
      v45 = (v91 - 1) & *(int *)buf;
    }
    v93 = (uint64_t **)*((_QWORD *)*v8 + v45);
    if (v93)
    {
      for (m = *v93; m; m = (uint64_t *)*m)
      {
        v95 = m[1];
        if (v95 == *(int *)buf)
        {
          if (*((_DWORD *)m + 4) == *(_DWORD *)buf)
            goto LABEL_268;
        }
        else
        {
          if (v92.u32[0] > 1uLL)
          {
            if (v95 >= v91)
              v95 %= v91;
          }
          else
          {
            v95 &= v91 - 1;
          }
          if (v95 != v45)
            break;
        }
      }
    }
  }
  v96 = (char *)operator new(0x40uLL);
  v97 = (_QWORD *)v5 + 9;
  v139[0] = v96;
  v139[1] = (char *)v129 + 72;
  *(_QWORD *)v96 = 0;
  *((_QWORD *)v96 + 1) = v90;
  *((_DWORD *)v96 + 4) = v89;
  v98 = v131;
  v131 = 0uLL;
  *(_OWORD *)(v96 + 24) = v98;
  v99 = v132;
  *(_OWORD *)(v96 + 40) = v132;
  *((float *)v96 + 14) = v133;
  if (*((_QWORD *)&v99 + 1))
  {
    v100 = *(_QWORD *)(v99 + 8);
    if ((*((_QWORD *)&v98 + 1) & (*((_QWORD *)&v98 + 1) - 1)) != 0)
    {
      if (v100 >= *((_QWORD *)&v98 + 1))
        v100 %= *((_QWORD *)&v98 + 1);
    }
    else
    {
      v100 &= *((_QWORD *)&v98 + 1) - 1;
    }
    *(_QWORD *)(v98 + 8 * v100) = v96 + 40;
    v132 = 0uLL;
  }
  v140 = 1;
  v101 = (float)(unint64_t)(*((_QWORD *)v129 + 10) + 1);
  v102 = *((float *)v129 + 22);
  if (!v91 || (float)(v102 * (float)v91) < v101)
  {
    v103 = 1;
    if (v91 >= 3)
      v103 = (v91 & (v91 - 1)) != 0;
    v104 = v103 | (2 * v91);
    v105 = vcvtps_u32_f32(v101 / v102);
    if (v104 <= v105)
      prime = (int8x8_t)v105;
    else
      prime = (int8x8_t)v104;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v91 = *((_QWORD *)v129 + 8);
    }
    if (*(_QWORD *)&prime > v91)
      goto LABEL_224;
    if (*(_QWORD *)&prime < v91)
    {
      v113 = vcvtps_u32_f32((float)*((unint64_t *)v129 + 10) / *((float *)v129 + 22));
      if (v91 < 3 || (v114 = (uint8x8_t)vcnt_s8((int8x8_t)v91), v114.i16[0] = vaddlv_u8(v114), v114.u32[0] > 1uLL))
      {
        v113 = std::__next_prime(v113);
      }
      else
      {
        v115 = 1 << -(char)__clz(v113 - 1);
        if (v113 >= 2)
          v113 = v115;
      }
      if (*(_QWORD *)&prime <= v113)
        prime = (int8x8_t)v113;
      if (*(_QWORD *)&prime >= v91)
      {
        v91 = *((_QWORD *)v129 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_224:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v107 = operator new(8 * *(_QWORD *)&prime);
          v108 = *v8;
          *v8 = v107;
          if (v108)
            operator delete(v108);
          v109 = 0;
          *((int8x8_t *)v129 + 8) = prime;
          do
            *((_QWORD *)*v8 + v109++) = 0;
          while (*(_QWORD *)&prime != v109);
          v110 = (_QWORD *)*v97;
          if (*v97)
          {
            v111 = v110[1];
            v112 = (uint8x8_t)vcnt_s8(prime);
            v112.i16[0] = vaddlv_u8(v112);
            if (v112.u32[0] > 1uLL)
            {
              if (v111 >= *(_QWORD *)&prime)
                v111 %= *(_QWORD *)&prime;
            }
            else
            {
              v111 &= *(_QWORD *)&prime - 1;
            }
            *((_QWORD *)*v8 + v111) = v97;
            v116 = (_QWORD *)*v110;
            if (*v110)
            {
              do
              {
                v117 = v116[1];
                if (v112.u32[0] > 1uLL)
                {
                  if (v117 >= *(_QWORD *)&prime)
                    v117 %= *(_QWORD *)&prime;
                }
                else
                {
                  v117 &= *(_QWORD *)&prime - 1;
                }
                if (v117 != v111)
                {
                  if (!*((_QWORD *)*v8 + v117))
                  {
                    *((_QWORD *)*v8 + v117) = v110;
                    goto LABEL_249;
                  }
                  *v110 = *v116;
                  *v116 = **((_QWORD **)*v8 + v117);
                  **((_QWORD **)*v8 + v117) = v116;
                  v116 = v110;
                }
                v117 = v111;
LABEL_249:
                v110 = v116;
                v116 = (_QWORD *)*v116;
                v111 = v117;
              }
              while (v116);
            }
          }
          v91 = (unint64_t)prime;
          goto LABEL_253;
        }
        v126 = *v8;
        *v8 = 0;
        if (v126)
          operator delete(v126);
        v91 = 0;
        *((_QWORD *)v129 + 8) = 0;
      }
    }
LABEL_253:
    if ((v91 & (v91 - 1)) != 0)
    {
      if (v91 <= v90)
        v45 = v90 % v91;
      else
        v45 = v90;
    }
    else
    {
      v45 = (v91 - 1) & v90;
    }
  }
  v118 = (_QWORD *)*((_QWORD *)*v8 + v45);
  v119 = v139[0];
  if (v118)
  {
    *(_QWORD *)v139[0] = *v118;
    v5 = v129;
  }
  else
  {
    *(_QWORD *)v139[0] = *v97;
    *v97 = v119;
    *((_QWORD *)*v8 + v45) = v97;
    v5 = v129;
    if (!*(_QWORD *)v119)
      goto LABEL_267;
    v120 = *(_QWORD *)(*(_QWORD *)v119 + 8);
    if ((v91 & (v91 - 1)) != 0)
    {
      if (v120 >= v91)
        v120 %= v91;
    }
    else
    {
      v120 &= v91 - 1;
    }
    v118 = (char *)*v8 + 8 * v120;
  }
  *v118 = v119;
LABEL_267:
  v139[0] = 0;
  ++*((_QWORD *)v5 + 10);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,void *>>>>::reset[abi:ne180100]((uint64_t)v139);
LABEL_268:
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)&v131);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)__n);
  a3 = v128;
  v10 = v127;
LABEL_269:
  Phase::Controller::IR::IRBuilder::SetSpatializer((Phase::Controller::IR::IRBuilder *)v5, a3);
  v122 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v121);
  if (*((_BYTE *)v122 + 280))
  {
    v123 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v122)
                                                                                         + 272)));
    v124 = v123;
    if ((unint64_t)v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v123))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v124, OS_SIGNPOST_INTERVAL_END, (os_signpost_id_t)v10, "Phase_IrBuilder_Construction", (const char *)&unk_21676613F, buf, 2u);
    }

  }
  return v5;
}

void sub_2165E53D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;
  void *v30;

  operator delete(v30);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)&a29);
  std::__hash_table<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::__unordered_map_hasher<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,true>,std::__unordered_map_equal<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,true>,std::allocator<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>>>::~__hash_table(v29);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(a11);
  _Unwind_Resume(a1);
}

void Phase::Controller::IR::IRBuilder::SetSpatializer(Phase::Controller::IR::IRBuilder *this, const Phase::Controller::Spatializer *a2)
{
  Phase::Logger *v4;
  NSObject *v5;
  void **v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  void *__p[2];
  char v17;
  _BYTE v18[8];
  std::__shared_weak_count *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  std::__shared_weak_count *v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  void **v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  if (*((const Phase::Controller::Spatializer **)this + 12) != a2)
  {
    Phase::Controller::Spatializer::AcquireFilters(a2, (uint64_t)v18);
    v5 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v4)
                                                                                       + 272)));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      (*(void (**)(void **__return_ptr))(*(_QWORD *)v20 + 40))(__p);
      v6 = v17 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136315650;
      v24 = "IRBuilder.mm";
      v25 = 1024;
      v26 = 77;
      v27 = 2080;
      v28 = v6;
      _os_log_impl(&dword_2164CC000, v5, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Reinitializing IR builder with new spatializer encoder. Encoder Details: %s", buf, 0x1Cu);
      if (v17 < 0)
        operator delete(__p[0]);
    }

    *((_QWORD *)this + 12) = a2;
    v7 = v22;
    if (v22)
    {
      p_shared_owners = (unint64_t *)&v22->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    v10 = v21;
    if (v21)
    {
      v11 = (unint64_t *)&v21->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    v13 = v19;
    if (v19)
    {
      v14 = (unint64_t *)&v19->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }
}

void sub_2165E56E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void *v5;
  va_list va;

  va_start(va, a5);

  Phase::Controller::SpatializerFilterHandle::~SpatializerFilterHandle((Phase::Controller::SpatializerFilterHandle *)va);
  _Unwind_Resume(a1);
}

void Phase::Controller::IR::IRBuilder::~IRBuilder(Phase::Controller::IR::IRBuilder *this)
{
  _QWORD *i;
  _QWORD *j;
  uint64_t v4;

  for (i = (_QWORD *)*((_QWORD *)this + 9); i; i = (_QWORD *)*i)
  {
    for (j = (_QWORD *)i[5]; j; j = (_QWORD *)*j)
    {
      v4 = j[3];
      if (v4)
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
    }
  }
  std::__hash_table<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::__unordered_map_hasher<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,true>,std::__unordered_map_equal<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,true>,std::allocator<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>>>::~__hash_table((uint64_t)this + 56);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)this + 16);
}

uint64_t Phase::Controller::IR::IRBuilder::GetWorkBufferSizeInBytes(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t *v6;
  uint64_t *v7;

  v6 = std::__hash_table<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::__unordered_map_hasher<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,true>,std::__unordered_map_equal<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,true>,std::allocator<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>>>::find<Phase::Controller::IR::IRBuilder::Processor>((_QWORD *)(a1 + 56), a3);
  if (!v6)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  v7 = std::__hash_table<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::__unordered_map_hasher<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,true>,std::__unordered_map_equal<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,true>,std::allocator<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>>>::find<Phase::Controller::IR::IRBuilder::Processor>(v6 + 3, a4);
  if (!v7)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7[3] + 16))(v7[3], a2);
}

void sub_2165E5824(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9)
{
  Phase::Logger *v9;
  NSObject *v10;
  std::logic_error *exception;

  if (a2 == 1)
  {
    v9 = (Phase::Logger *)__cxa_begin_catch(exception_object);
    v10 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v9) + 272));
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LODWORD(a9) = 136315394;
      *(_QWORD *)((char *)&a9 + 4) = "IRBuilder.mm";
      WORD6(a9) = 1024;
      *(_DWORD *)((char *)&a9 + 14) = 99;
      _os_log_impl(&dword_2164CC000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error): \"Requested an IR Build on a builder hasn't been created. Make sure the builder is requested as an initialization parameter.\"", (uint8_t *)&a9, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Requested an IR Build on a builder hasn't been created. Make sure the builder is requested as an initialization parameter.");
  }
  _Unwind_Resume(exception_object);
}

void sub_2165E58DC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_2165E58FC(void *a1, int a2)
{
  if (!a2)
    JUMPOUT(0x2165E5904);
  __clang_call_terminate(a1);
}

void Phase::Controller::IR::IRBuilder::Build(Phase::Logger *a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t InstancePtr;
  Phase::Logger *v13;
  Phase::Logger *v14;
  NSObject *v15;
  NSObject *v16;
  _QWORD *v17;
  uint64_t *v18;
  uint64_t *v19;
  Phase::Logger *v20;
  Phase::Logger *v21;
  NSObject *v22;
  NSObject *v23;
  int v24;
  _QWORD *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  InstancePtr = Phase::Logger::GetInstancePtr(a1);
  v13 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(InstancePtr + 272));
  v14 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v13);
  if (*((_BYTE *)v14 + 280))
  {
    v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v14)
                                                                                        + 272)));
    v16 = v15;
    if ((unint64_t)v13 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v15))
    {
      v17 = *(_QWORD **)(a2 + 8);
      if (v17)
      {
        if (*(_DWORD *)v17 == 3)
        {
          v17 = (_QWORD *)v17[13];
          if (v17)
            v17 = (_QWORD *)*v17;
        }
        else
        {
          v17 = 0;
        }
      }
      v24 = 134217984;
      v25 = v17;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v16, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v13, "Phase_IrBuilder_Build", "IR Build: %zu reflections", (uint8_t *)&v24, 0xCu);
    }

  }
  v18 = std::__hash_table<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::__unordered_map_hasher<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,true>,std::__unordered_map_equal<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,true>,std::allocator<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>>>::find<Phase::Controller::IR::IRBuilder::Processor>((_QWORD *)a1 + 7, a3);
  if (!v18)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  v19 = std::__hash_table<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::__unordered_map_hasher<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,true>,std::__unordered_map_equal<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,true>,std::allocator<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>>>::find<Phase::Controller::IR::IRBuilder::Processor>(v18 + 3, a4);
  if (!v19)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  v20 = (Phase::Logger *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v19[3] + 24))(v19[3], a2, a5, a6);
  v21 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v20);
  if (*((_BYTE *)v21 + 280))
  {
    v22 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v21)
                                                                                        + 272)));
    v23 = v22;
    if ((unint64_t)v13 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v22))
    {
      LOWORD(v24) = 0;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v23, OS_SIGNPOST_INTERVAL_END, (os_signpost_id_t)v13, "Phase_IrBuilder_Build", (const char *)&unk_21676613F, (uint8_t *)&v24, 2u);
    }

  }
}

void sub_2165E5B24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9)
{
  Phase::Logger *v9;
  NSObject *v10;
  std::logic_error *exception;

  if (a2 == 1)
  {
    v9 = (Phase::Logger *)__cxa_begin_catch(exception_object);
    v10 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v9) + 272));
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LODWORD(a9) = 136315394;
      *(_QWORD *)((char *)&a9 + 4) = "IRBuilder.mm";
      WORD6(a9) = 1024;
      *(_DWORD *)((char *)&a9 + 14) = 129;
      _os_log_impl(&dword_2164CC000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error): \"Requested an IR Build on a builder hasn't been created. Make sure the builder is requested as an initialization parameter.\"", (uint8_t *)&a9, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Requested an IR Build on a builder hasn't been created. Make sure the builder is requested as an initialization parameter.");
  }
  _Unwind_Resume(exception_object);
}

void sub_2165E5BDC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_2165E5BFC(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

char *Phase::Controller::IR::IRBuilder::GetMethodString(Phase::Controller::IR::IRBuilder *this, const Method *a2)
{
  uint64_t v2;
  NSObject *v5;
  uint64_t v6;
  std::logic_error *exception;
  int v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v2 = *(int *)this;
  if (v2 >= 4)
  {
    v5 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(this) + 272));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v6 = *(int *)this;
      v8 = 136315650;
      v9 = "IRBuilder.mm";
      v10 = 1024;
      v11 = 158;
      v12 = 2048;
      v13 = v6;
      _os_log_impl(&dword_2164CC000, v5, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"Invalid IR builder method index %lu\"", (uint8_t *)&v8, 0x1Cu);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Invalid IR builder method index %lu");
  }
  return off_24D57DF60[v2];
}

void sub_2165E5D30(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t std::unordered_map<unsigned int,unsigned int>::unordered_map(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t **v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  uint8x8_t v10;
  uint64_t **v11;
  uint64_t *i;
  unint64_t v13;
  _QWORD *v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  v5 = *(uint64_t ***)(a2 + 16);
  if (v5)
  {
    v6 = (_QWORD *)(a1 + 16);
    v7 = *(_QWORD *)(a1 + 8);
    do
    {
      v8 = *((unsigned int *)v5 + 4);
      v9 = v5[2];
      if (v7)
      {
        v10 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
        v10.i16[0] = vaddlv_u8(v10);
        if (v10.u32[0] > 1uLL)
        {
          v2 = *((unsigned int *)v5 + 4);
          if (v7 <= v8)
            v2 = v8 % v7;
        }
        else
        {
          v2 = ((_DWORD)v7 - 1) & v8;
        }
        v11 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v2);
        if (v11)
        {
          for (i = *v11; i; i = (uint64_t *)*i)
          {
            v13 = i[1];
            if (v13 == v8)
            {
              if (*((_DWORD *)i + 4) == (_DWORD)v8)
                goto LABEL_41;
            }
            else
            {
              if (v10.u32[0] > 1uLL)
              {
                if (v13 >= v7)
                  v13 %= v7;
              }
              else
              {
                v13 &= v7 - 1;
              }
              if (v13 != v2)
                break;
            }
          }
        }
      }
      v14 = operator new(0x18uLL);
      *v14 = 0;
      v14[1] = v8;
      v14[2] = v9;
      v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
      v16 = *(float *)(a1 + 32);
      if (!v7 || (float)(v16 * (float)v7) < v15)
      {
        v17 = (v7 & (v7 - 1)) != 0;
        if (v7 < 3)
          v17 = 1;
        v18 = v17 | (2 * v7);
        v19 = vcvtps_u32_f32(v15 / v16);
        if (v18 <= v19)
          v20 = v19;
        else
          v20 = v18;
        std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::__rehash<true>(a1, v20);
        v7 = *(_QWORD *)(a1 + 8);
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= v8)
            v2 = v8 % v7;
          else
            v2 = v8;
        }
        else
        {
          v2 = ((_DWORD)v7 - 1) & v8;
        }
      }
      v21 = *(_QWORD *)a1;
      v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v2);
      if (v22)
      {
        *v14 = *v22;
      }
      else
      {
        *v14 = *v6;
        *v6 = v14;
        *(_QWORD *)(v21 + 8 * v2) = v6;
        if (!*v14)
          goto LABEL_40;
        v23 = *(_QWORD *)(*v14 + 8);
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v23 >= v7)
            v23 %= v7;
        }
        else
        {
          v23 &= v7 - 1;
        }
        v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
      }
      *v22 = v14;
LABEL_40:
      ++*(_QWORD *)(a1 + 24);
LABEL_41:
      v5 = (uint64_t **)*v5;
    }
    while (v5);
  }
  return a1;
}

void sub_2165E5F7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::__unordered_map_hasher<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,true>,std::__unordered_map_equal<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,true>,std::allocator<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::__unordered_map_hasher<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,true>,std::__unordered_map_equal<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,true>,std::allocator<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::__unordered_map_hasher<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,true>,std::__unordered_map_equal<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,true>,std::allocator<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)(v2 + 3));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)v1 + 24);
    operator delete(v1);
  }
}

uint64_t *std::__hash_table<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::__unordered_map_hasher<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,true>,std::__unordered_map_equal<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,true>,std::allocator<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>>>::find<Phase::Controller::IR::IRBuilder::Processor>(_QWORD *a1, int a2)
{
  unint64_t v2;
  uint8x8_t v3;
  unint64_t v4;
  uint64_t **v5;
  uint64_t *result;
  unint64_t v7;

  v2 = a1[1];
  if (!v2)
    return 0;
  v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (v2 <= a2)
      v4 = a2 % v2;
  }
  else
  {
    v4 = (v2 - 1) & a2;
  }
  v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5)
    return 0;
  for (result = *v5; result; result = (uint64_t *)*result)
  {
    v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2)
        return result;
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2)
          v7 %= v2;
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4)
        return 0;
    }
  }
  return result;
}

uint64_t Phase::Controller::IR::IRBuilderCpuFIRCrossover::IRBuilderCpuFIRCrossover(uint64_t a1, uint64_t a2, signed int a3, int a4, double a5)
{
  uint64_t v8;
  uint64_t *i;
  int v10;
  int v11;
  Phase::LinkwitzRileyFilterBank *v12;
  Phase::LinkwitzRileyFilterBank **v13;
  unsigned int v14;
  int v15;
  float v16;
  int v19;
  Phase::LinkwitzRileyFilterBank *v20;
  int *v21;

  *(_QWORD *)a1 = &off_24D57DF90;
  v8 = a1 + 8;
  Phase::Controller::IR::FIRUtilManager::FIRUtilManager((Phase::Controller::IR::FIRUtilManager *)(a1 + 8), a5);
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_DWORD *)(a1 + 264) = 1065353216;
  *(_DWORD *)(a1 + 272) = a3;
  for (i = *(uint64_t **)(a2 + 16); i; i = (uint64_t *)*i)
  {
    v10 = *((_DWORD *)i + 4);
    v11 = *((_DWORD *)i + 5);
    v12 = (Phase::LinkwitzRileyFilterBank *)operator new();
    Phase::LinkwitzRileyFilterBank::LinkwitzRileyFilterBank(v12, *(_DWORD *)(a1 + 272), v10, v11, 48000);
    v20 = v12;
    v19 = *((_DWORD *)i + 4);
    v21 = &v19;
    v13 = (Phase::LinkwitzRileyFilterBank **)std::__hash_table<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(a1 + 232, &v19, (uint64_t)&std::piecewise_construct, &v21);
    std::unique_ptr<Phase::LinkwitzRileyFilterBank>::reset[abi:ne180100](v13 + 3, v12);
  }
  v14 = 31 - __clz(a3);
  if (a3 <= 0)
    v15 = 0;
  else
    v15 = v14;
  if (v15 <= a4)
  {
    do
    {
      v16 = ldexpf(1.0, v15);
      Phase::Controller::IR::FIRUtilManager::AddNewFFTSizeSupport(v8, (int)v16);
      ++v15;
    }
    while (a4 + 1 != v15);
  }
  return a1;
}

void sub_2165E6264(_Unwind_Exception *a1)
{
  Phase::Controller::IR::FIRUtilManager *v1;
  uint64_t v2;

  std::__hash_table<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>>>::~__hash_table(v2);
  Phase::Controller::IR::FIRUtilManager::~FIRUtilManager(v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::IR::FIRUtilManager::AddNewFFTSizeSupport(uint64_t this, int a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  char v6;
  int v7;
  _QWORD v8[2];
  int *v9;

  v7 = a2;
  if (a2 <= 0)
    std::terminate();
  v2 = this;
  v3 = (unint64_t *)(this + 216);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 | a2, v3));
  if ((v4 & v7) == 0)
  {
    v5 = this + 48;
    v6 = 1;
    std::__shared_mutex_base::lock((std::__shared_mutex_base *)(this + 48));
    v9 = &v7;
    v8[0] = v2;
    v8[1] = &v7;
    std::__hash_table<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<double const&,int &>>(v2 + 8, &v7, (uint64_t)&std::piecewise_construct, &v9, (uint64_t)v8);
    return std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v5);
  }
  return this;
}

void sub_2165E6354(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void Phase::Controller::IR::FIRUtilManager::~FIRUtilManager(Phase::Controller::IR::FIRUtilManager *this)
{
  std::mutex *v2;

  v2 = (std::mutex *)((char *)this + 48);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 160));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 112));
  std::mutex::~mutex(v2);
  std::__hash_table<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>>>::~__hash_table((uint64_t)this + 8);
}

void Phase::Controller::IR::IRBuilderCpuFIRCrossover::~IRBuilderCpuFIRCrossover(Phase::Controller::IR::IRBuilderCpuFIRCrossover *this)
{
  std::mutex *v2;

  *(_QWORD *)this = &off_24D57DF90;
  v2 = (std::mutex *)((char *)this + 56);
  std::__hash_table<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>>>::~__hash_table((uint64_t)this + 232);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 168));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 120));
  std::mutex::~mutex(v2);
  std::__hash_table<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>>>::~__hash_table((uint64_t)this + 16);
}

{
  Phase::Controller::IR::IRBuilderCpuFIRCrossover::~IRBuilderCpuFIRCrossover(this);
  JUMPOUT(0x2199F9D70);
}

unint64_t Phase::Controller::IR::IRBuilderCpuFIRCrossover::GetWorkBufferSizeInBytes(Phase::Controller::IR::IRBuilderCpuFIRCrossover *this, const Phase::Controller::IR::Metadata *a2)
{
  char *v4;
  const Phase::Controller::SpatializerEncoder *v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t result;

  v4 = (char *)a2 + 16;
  v5 = (const Phase::Controller::SpatializerEncoder *)*((_QWORD *)a2 + 4);
  v6 = (*(uint64_t (**)(const Phase::Controller::SpatializerEncoder *))(*(_QWORD *)v5 + 48))(v5);
  v7 = (*(uint64_t (**)(const Phase::Controller::SpatializerEncoder *, char *))(*(_QWORD *)v5 + 80))(v5, v4);
  v8 = *((_QWORD *)a2 + 1);
  if (v8 && *(_DWORD *)v8 == 3 && (v9 = *(_QWORD *)(v8 + 104)) != 0)
    v10 = *(_QWORD *)(v9 + 8);
  else
    LODWORD(v10) = 0;
  v11 = Phase::Controller::IR::IRBuilderCpuFIRCrossover::CalculateFilterProperties(this, a2, v5);
  v12 = (v7 + 63) & 0x1FFFFFFF0;
  if (v7 <= 0)
    v12 = 48;
  v13 = 8 * v6;
  v14 = v12 + v13;
  if (v6 < 1)
  {
    v20 = (v14 + 15) & 0xFFFFFFFFFFFFFFF0;
    v17 = (v11 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    v19 = ((((v13 + v20 + 15) | 0xC) + v17) & 0xFFFFFFFFFFFFFFF0) + v13;
  }
  else
  {
    v15 = v6;
    do
    {
      v14 = ((v14 + 15) & 0xFFFFFFFFFFFFFFF0) + 4 * (int)v11;
      --v15;
    }
    while (v15);
    v16 = ((v14 + 15) & 0xFFFFFFFFFFFFFFF0) + v13;
    v17 = (v11 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    v18 = v6;
    do
    {
      v16 = ((v16 + 15) & 0xFFFFFFFFFFFFFFF0) + v17;
      --v18;
    }
    while (v18);
    v19 = ((v17 + ((v16 + 15) & 0xFFFFFFFFFFFFFFF0) + 15) & 0xFFFFFFFFFFFFFFF0) + v13;
    do
    {
      v19 = ((v19 + 15) & 0xFFFFFFFFFFFFFFF0) + v17;
      --v6;
    }
    while (v6);
  }
  result = ((v19 + 15) & 0xFFFFFFFFFFFFFFF0) + 8 * (int)v10;
  if ((int)v10 >= 1)
  {
    do
    {
      result = ((result + 15) & 0xFFFFFFFFFFFFFFF0) + v17;
      LODWORD(v10) = v10 - 1;
    }
    while ((_DWORD)v10);
  }
  return result;
}

unint64_t Phase::Controller::IR::IRBuilderCpuFIRCrossover::CalculateFilterProperties(Phase::Controller::IR::IRBuilderCpuFIRCrossover *this, const Phase::Controller::IR::Metadata *a2, const Phase::Controller::SpatializerEncoder *a3)
{
  unsigned int MaxDelayInSamples;
  __n128 v7;
  int v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  float v12;
  double v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  BOOL v18;

  MaxDelayInSamples = Phase::Controller::IR::GetMaxDelayInSamples(a2, a2);
  v7 = ((__n128 (*)(const Phase::Controller::SpatializerEncoder *, char *))*(_QWORD *)(*(_QWORD *)a3 + 64))(a3, (char *)a2 + 16);
  v9 = *((_DWORD *)this + 68);
  v10 = v8 + MaxDelayInSamples + v9;
  v11 = v10 - 1;
  v7.n128_u32[0] = v10 - 1;
  v7.n128_u64[0] = (unint64_t)vcnt_s8((int8x8_t)v7.n128_u64[0]);
  v7.n128_u16[0] = vaddlv_u8((uint8x8_t)v7.n128_u64[0]);
  if (v7.n128_u32[0] != 1)
  {
    v12 = log2f((float)(int)v11);
    v13 = ldexp(1.0, vcvtms_s32_f32(v12));
    v14 = (int)v13;
    if (v9 >= 0)
      v15 = v9;
    else
      v15 = v9 + 1;
    if ((int)v11 - v14 >= v15 >> 1)
    {
      v16 = v10 - 2;
      v17 = 1;
      do
      {
        v16 |= v16 >> v17;
        v18 = v17 >= 0x10;
        v17 *= 2;
      }
      while (!v18);
      v11 = v16 + 1;
    }
    else
    {
      v9 -= v11 - v14;
      v11 = (int)v13;
    }
  }
  return v9 | (unint64_t)(v11 << 32);
}

void Phase::Controller::IR::IRBuilderCpuFIRCrossover::Build(Phase::Controller::IR::IRBuilderCpuFIRCrossover *this, const Phase::Controller::IR::Metadata *a2, char *a3, float *a4)
{
  char *v8;
  const Phase::Controller::SpatializerEncoder *v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int64_t v16;
  int v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  unsigned int *v21;
  char *v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  Phase::Logger *v47;
  uint64_t *FIRUtils;
  unint64_t v49;
  uint8x8_t v50;
  unint64_t v51;
  uint64_t **v52;
  uint64_t *v53;
  unint64_t v54;
  NSObject *v55;
  std::runtime_error *v56;
  vDSP_Length v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _BOOL4 v61;
  const void *OneBandImpulseResponse;
  uint64_t v63;
  __n128 v64;
  __n128 v65;
  int v66;
  uint64_t v67;
  uint64_t i;
  _BOOL4 v69;
  _QWORD *v70;
  uint64_t v71;
  float v72;
  float v73;
  uint64_t v74;
  uint64_t v75;
  _BOOL4 v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  float *v81;
  float *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  float *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  DSPComplex *v90;
  uint64_t v91;
  float *v92;
  float *v93;
  uint64_t v94;
  float v95;
  NSObject *v96;
  std::runtime_error *exception;
  NSObject *v98;
  std::runtime_error *v99;
  uint64_t v100;
  size_t __n;
  Phase::LinkwitzRileyFilterBank *v102;
  int v103;
  float *v104;
  uint64_t __N;
  uint64_t *v106;
  char *v107;
  int v108;
  Phase::Controller::IR::Metadata *v109;
  uint64_t v110;
  int v111;
  uint64_t v112;
  int v113;
  const vDSP_DFT_SetupStruct ***v114;
  Phase::Controller::IR::IRBuilderCpuFIRCrossover *v115;
  char *v116;
  DSPSplitComplex __D;
  DSPSplitComplex v118;
  DSPSplitComplex __A;
  uint8_t buf[4];
  const char *v121;
  __int16 v122;
  int v123;
  __int16 v124;
  Phase::Controller::IR::IRBuilderCpuFIRCrossover *v125;
  __int16 v126;
  int v127;
  uint64_t v128;

  v128 = *MEMORY[0x24BDAC8D0];
  v8 = (char *)a2 + 16;
  v9 = (const Phase::Controller::SpatializerEncoder *)*((_QWORD *)a2 + 4);
  v10 = (*(uint64_t (**)(const Phase::Controller::SpatializerEncoder *))(*(_QWORD *)v9 + 48))(v9);
  v107 = v8;
  v11 = (*(uint64_t (**)(const Phase::Controller::SpatializerEncoder *, char *))(*(_QWORD *)v9 + 80))(v9, v8);
  v109 = a2;
  v12 = *((_QWORD *)a2 + 1);
  v104 = a4;
  if (v12 && *(_DWORD *)v12 == 3 && (v13 = *(_QWORD *)(v12 + 104)) != 0)
    v14 = *(unsigned int *)(v13 + 8);
  else
    v14 = 0;
  v15 = (*(uint64_t (**)(const Phase::Controller::SpatializerEncoder *, char *))(*(_QWORD *)v9 + 64))(v9, v107);
  v16 = Phase::Controller::IR::IRBuilderCpuFIRCrossover::CalculateFilterProperties(this, v109, v9);
  v103 = v17;
  v18 = HIDWORD(v16);
  if (v16 >= 0)
    v19 = HIDWORD(v16);
  else
    v19 = HIDWORD(v16) + 1;
  v113 = v19;
  v20 = *((_QWORD *)v109 + 1);
  if (v20 && *(_DWORD *)v20 == 3 && (v21 = *(unsigned int **)(v20 + 104)) != 0)
    v110 = *v21;
  else
    v110 = 0;
  *(_QWORD *)a3 = 0;
  v22 = a3 + 48;
  v115 = this;
  if (v11 >= 1)
  {
    v23 = (unint64_t)(a3 + 63) & 0xFFFFFFFFFFFFFFF0;
    *(_QWORD *)a3 = v23;
    v22 = (char *)(v23 + v11);
  }
  v24 = (unint64_t)(v22 + 15);
  v25 = 8 * v10;
  v24 &= 0xFFFFFFFFFFFFFFF0;
  *((_QWORD *)a3 + 1) = v24;
  v26 = v24 + v25;
  v27 = 4 * (int)v16;
  v28 = v10;
  if (v10 <= 0)
  {
    v36 = (v26 + 15) & 0xFFFFFFFFFFFFFFF0;
    *((_QWORD *)a3 + 2) = v36;
    v33 = (uint64_t *)(a3 + 16);
    v34 = v36 + v25;
  }
  else
  {
    v29 = 0;
    do
    {
      v30 = (v26 + 15) & 0xFFFFFFFFFFFFFFF0;
      *(_QWORD *)(*((_QWORD *)a3 + 1) + v29) = v30;
      v26 = v30 + v27;
      v29 += 8;
    }
    while (8 * v10 != v29);
    v31 = 0;
    v32 = (v26 + 15) & 0xFFFFFFFFFFFFFFF0;
    *((_QWORD *)a3 + 2) = v32;
    v33 = (uint64_t *)(a3 + 16);
    v34 = v32 + v25;
    do
    {
      v35 = (v34 + 15) & 0xFFFFFFFFFFFFFFF0;
      *(_QWORD *)(*v33 + v31) = v35;
      v34 = v35 + ((v16 >> 30) & 0xFFFFFFFFFFFFFFFCLL);
      v31 += 8;
    }
    while (8 * v10 != v31);
  }
  v37 = (v34 + 15) & 0xFFFFFFFFFFFFFFF0;
  v38 = 4 * (v16 >> 32);
  __N = v16 >> 32;
  v106 = v33;
  v39 = (v37 + v38 + 15) & 0xFFFFFFFFFFFFFFF0;
  *((_QWORD *)a3 + 3) = v37;
  *((_QWORD *)a3 + 4) = v39;
  v40 = v39 + v25;
  if (v10 >= 1)
  {
    v41 = 0;
    do
    {
      v42 = (v40 + 15) & 0xFFFFFFFFFFFFFFF0;
      *(_QWORD *)(*((_QWORD *)a3 + 4) + v41) = v42;
      v40 = v42 + v38;
      v41 += 8;
    }
    while (8 * v10 != v41);
  }
  v43 = (v40 + 15) & 0xFFFFFFFFFFFFFFF0;
  *((_QWORD *)a3 + 5) = v43;
  v44 = v43 + 8 * (int)v14;
  if ((int)v14 >= 1)
  {
    v45 = 0;
    do
    {
      v46 = (v44 + 15) & 0xFFFFFFFFFFFFFFF0;
      *(_QWORD *)(*((_QWORD *)a3 + 5) + v45) = v46;
      v44 = v46 + v38;
      v45 += 8;
    }
    while (8 * v14 != v45);
  }
  v47 = (Phase::Logger *)(*(uint64_t (**)(Phase::Controller::IR::IRBuilderCpuFIRCrossover *, Phase::Controller::IR::Metadata *))(*(_QWORD *)v115 + 16))(v115, v109);
  if (v47 != (Phase::Logger *)(v44 - (_QWORD)a3))
  {
    v96 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v47) + 272));
    if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v121 = "IRBuilderCpuFIRCrossover.mm";
      v122 = 1024;
      v123 = 177;
      _os_log_impl(&dword_2164CC000, v96, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [GetWorkBufferSizeInBytes(inMetadata) != PointerDiff(pMemory, pInWorkBuffer) is true]: \"Memory Allocation Error\"", buf, 0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Memory Allocation Error");
  }
  __A.realp = 0;
  __A.imagp = 0;
  v118.realp = 0;
  v118.imagp = 0;
  __D.realp = 0;
  __D.imagp = 0;
  Phase::Controller::IR::FIRUtilManager::AddNewFFTSizeSupport((uint64_t)v115 + 8, v18);
  FIRUtils = Phase::Controller::IR::FIRUtilManager::GetFIRUtils((Phase::Controller::IR::IRBuilderCpuFIRCrossover *)((char *)v115 + 8), v18);
  v114 = (const vDSP_DFT_SetupStruct ***)FIRUtils;
  v49 = *((_QWORD *)v115 + 30);
  if (!v49)
    goto LABEL_47;
  v50 = (uint8x8_t)vcnt_s8((int8x8_t)v49);
  v50.i16[0] = vaddlv_u8(v50);
  if (v50.u32[0] > 1uLL)
  {
    v51 = (int)v14;
    if (v49 <= (int)v14)
      v51 = (int)v14 % v49;
  }
  else
  {
    v51 = (v49 - 1) & (int)v14;
  }
  v52 = *(uint64_t ***)(*((_QWORD *)v115 + 29) + 8 * v51);
  if (!v52 || (v53 = *v52) == 0)
  {
LABEL_47:
    v55 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr((Phase::Logger *)FIRUtils) + 272));
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v121 = "IRBuilderCpuFIRCrossover.mm";
      v122 = 1024;
      v123 = 316;
      v124 = 2048;
      v125 = v115;
      v126 = 1024;
      v127 = v14;
      _os_log_impl(&dword_2164CC000, v55, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error): \"IRBuilderCpuFIRCrossover:%p Filterbank with %d bands is not supported.\"", buf, 0x22u);
    }
    v56 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v56, "IRBuilderCpuFIRCrossover:%p Filterbank with %d bands is not supported.");
  }
  v108 = v113 >> 1;
  while (1)
  {
    v54 = v53[1];
    if (v54 == (int)v14)
      break;
    if (v50.u32[0] > 1uLL)
    {
      if (v54 >= v49)
        v54 %= v49;
    }
    else
    {
      v54 &= v49 - 1;
    }
    if (v54 != v51)
      goto LABEL_47;
LABEL_46:
    v53 = (uint64_t *)*v53;
    if (!v53)
      goto LABEL_47;
  }
  if (*((_DWORD *)v53 + 4) != (_DWORD)v14)
    goto LABEL_46;
  v102 = (Phase::LinkwitzRileyFilterBank *)v53[3];
  if (!v102)
  {
    v98 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr((Phase::Logger *)FIRUtils) + 272));
    if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v121 = "IRBuilderCpuFIRCrossover.mm";
      v122 = 1024;
      v123 = 196;
      v124 = 1024;
      LODWORD(v125) = v14;
      _os_log_impl(&dword_2164CC000, v98, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [nullptr == pFilterBankInUse is true]: \"Failed to get filter bank for subband count %d\"", buf, 0x18u);
    }
    v99 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v99, "Failed to get filter bank for subband count %d");
  }
  v57 = __N;
  if (v10 >= 1)
  {
    v58 = 0;
    do
    {
      vDSP_vclr(*(float **)(*((_QWORD *)a3 + 4) + v58), 1, __N);
      v58 += 8;
    }
    while (8 * v10 != v58);
  }
  __n = v27;
  v59 = 4 * v10;
  v116 = a3;
  if ((int)v14 >= 1)
  {
    v60 = 0;
    v112 = 8 * v10;
    v100 = v14;
    v111 = v10;
    do
    {
      vDSP_vclr(*((float **)a3 + 3), 1, v57);
      v61 = v10 > 0;
      OneBandImpulseResponse = (const void *)Phase::LinkwitzRileyFilterBank::GetOneBandImpulseResponse(v102, v60);
      memcpy(*((void **)v116 + 3), OneBandImpulseResponse, __n);
      v63 = *((_QWORD *)v116 + 5);
      v118.realp = *(float **)(v63 + 8 * v60);
      v118.imagp = (float *)(*(_QWORD *)(v63 + 8 * v60) + 4 * v108);
      Phase::DFTUtils::ProcessDFT(*v114, *((DSPComplex **)v116 + 3), &v118, 0.5);
      v66 = v111;
      if (v61)
      {
        v67 = 0;
        do
        {
          vDSP_vclr(*(float **)(*v106 + v67), 1, __N);
          v67 += 8;
        }
        while (v112 != v67);
      }
      if ((int)v110 >= 1)
      {
        for (i = 0; i != v110; ++i)
        {
          v69 = v66 > 0;
          v70 = (_QWORD *)*((_QWORD *)v109 + 1);
          v71 = v70[1] + 12 * i;
          v72 = *(float *)(v70[7] + 4 * i);
          v64.n128_u32[0] = *(_DWORD *)(v71 + 4);
          v65.n128_u32[0] = *(_DWORD *)(v71 + 8);
          v73 = *(float *)v109;
          v74 = v70[13];
          v75 = *(_QWORD *)(v74 + 8);
          v76 = *(unsigned __int8 *)(v70[18] + i) == 0;
          v77 = (*(uint64_t (**)(const Phase::Controller::SpatializerEncoder *, char *, _QWORD, __n128, __n128))(*(_QWORD *)v9 + 88))(v9, v107, *(_QWORD *)v116, v64, v65);
          v64.n128_u32[0] = *(_DWORD *)(v74 + 4 * v75 * i + 16 + 4 * v60);
          if (!v76)
            v64.n128_f32[0] = -v64.n128_f32[0];
          v66 = v111;
          if (v69)
          {
            v78 = 0;
            v79 = *v106;
            v80 = 4 * (int)vcvtas_u32_f32(v72 * v73);
            do
            {
              if (v15 >= 1)
              {
                v81 = (float *)(*(_QWORD *)(v79 + 8 * v78) + v80);
                v82 = (float *)v77;
                v83 = v15;
                do
                {
                  *v81 = *v81 + (float)(*v82 * v64.n128_f32[0]);
                  ++v81;
                  v82 = (float *)((char *)v82 + v59);
                  --v83;
                }
                while (v83);
              }
              ++v78;
              v77 += 4;
            }
            while (v78 != v28);
          }
        }
      }
      if (v66 >= 1)
      {
        v84 = 0;
        do
        {
          v85 = *((_QWORD *)v116 + 2);
          v86 = (float *)(*((_QWORD *)v116 + 3) + 4 * v108);
          __A.realp = (float *)*((_QWORD *)v116 + 3);
          __A.imagp = v86;
          Phase::DFTUtils::ProcessDFT(*v114, *(DSPComplex **)(v85 + v84), &__A, 0.5);
          v88 = *((_QWORD *)v116 + 4);
          v87 = *((_QWORD *)v116 + 5);
          v118.realp = *(float **)(v87 + 8 * v60);
          v118.imagp = (float *)(*(_QWORD *)(v87 + 8 * v60) + 4 * v108);
          __D.realp = *(float **)(v88 + v84);
          __D.imagp = (float *)(*(_QWORD *)(v88 + v84) + 4 * v108);
          Phase::DFTUtils::MultiplyAddComplexPackedSpectrums((Phase::DFTUtils *)*v114, &__A, &v118, &__D, &__D, v108);
          v84 += 8;
        }
        while (v112 != v84);
      }
      ++v60;
      a3 = v116;
      v10 = v111;
      v57 = __N;
    }
    while (v60 != v100);
  }
  if (v10 >= 1)
  {
    v89 = 0;
    do
    {
      v90 = (DSPComplex *)*((_QWORD *)a3 + 3);
      v91 = *((_QWORD *)a3 + 4);
      __D.realp = *(float **)(v91 + 8 * v89);
      __D.imagp = (float *)(*(_QWORD *)(v91 + 8 * v89) + 4 * v108);
      Phase::DFTUtils::ProcessIDFT(*v114, &__D, v90);
      a3 = v116;
      if (v103 > 0)
      {
        v92 = (float *)*((_QWORD *)v116 + 3);
        v93 = v104;
        v94 = v103;
        do
        {
          v95 = *v92++;
          *v93 = v95 + *v93;
          v93 = (float *)((char *)v93 + v59);
          --v94;
        }
        while (v94);
      }
      ++v89;
      ++v104;
    }
    while (v89 != v28);
  }
}

void sub_2165E6FD4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t *Phase::Controller::IR::FIRUtilManager::GetFIRUtils(Phase::Controller::IR::FIRUtilManager *this, int a2)
{
  uint64_t *v3;
  NSObject *v5;
  std::logic_error *exception;
  char *v7;
  char v8;
  int v9;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v9 = a2;
  v7 = (char *)this + 48;
  v8 = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 48));
  v3 = std::__hash_table<std::__hash_value_type<Phase::ActionTreeServerCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeServerCommand,std::__hash_value_type<Phase::ActionTreeServerCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeServerCommand>,std::equal_to<Phase::ActionTreeServerCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeServerCommand,std::__hash_value_type<Phase::ActionTreeServerCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeServerCommand>,std::hash<Phase::ActionTreeServerCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeServerCommand,std::function<void ()(void const*)>>>>::find<Phase::ActionTreeServerCommand>((_QWORD *)this + 1, &v9);
  if (!v3)
  {
    v5 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(0) + 272));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v11 = "IRBuilderFIRUtilManager.h";
      v12 = 1024;
      v13 = 77;
      v14 = 1024;
      v15 = v9;
      _os_log_impl(&dword_2164CC000, v5, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [mFIRUtilsPool.end() == FFTUtilsIt is true]: \"Failed to get DFT/FIR utils from pool for FFT length %i\"", buf, 0x18u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Failed to get DFT/FIR utils from pool for FFT length %i");
  }
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v7);
  return v3 + 3;
}

void sub_2165E7144(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  void *v10;

  __cxa_free_exception(v10);
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

Phase::Controller::IR::FIRUtilManager *Phase::Controller::IR::FIRUtilManager::FIRUtilManager(Phase::Controller::IR::FIRUtilManager *this, double a2)
{
  *(double *)this = a2;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_DWORD *)this + 10) = 1065353216;
  std::__shared_mutex_base::__shared_mutex_base((std::__shared_mutex_base *)((char *)this + 48));
  *((_QWORD *)this + 27) = 0;
  return this;
}

void sub_2165E71B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<int const,Phase::Controller::IR::FIRUtilManager::FIRUtils>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

vDSP_DFT_Setup *std::__destroy_at[abi:ne180100]<std::pair<int const,Phase::Controller::IR::FIRUtilManager::FIRUtils>,0>(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
  std::unique_ptr<Phase::FIRFilterUtils>::reset[abi:ne180100]((Phase::FIRFilterUtils **)(a1 + 16), 0);
  return std::unique_ptr<Phase::DFTUtils>::reset[abi:ne180100]((vDSP_DFT_Setup **)(a1 + 8), 0);
}

Phase::FIRFilterUtils *std::unique_ptr<Phase::FIRFilterUtils>::reset[abi:ne180100](Phase::FIRFilterUtils **a1, Phase::FIRFilterUtils *a2)
{
  Phase::FIRFilterUtils *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    Phase::FIRFilterUtils::~FIRFilterUtils(result);
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

void Phase::FIRFilterUtils::~FIRFilterUtils(Phase::FIRFilterUtils *this)
{
  uint64_t i;
  char *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void **v9;

  for (i = 0; i != -384; i -= 128)
  {
    v3 = (char *)this + i;
    v9 = (void **)((char *)this + i + 456);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v9);
    v9 = (void **)((char *)this + i + 432);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v9);
    v4 = *(void **)((char *)this + i + 408);
    if (v4)
    {
      *((_QWORD *)v3 + 52) = v4;
      operator delete(v4);
    }
    v5 = (void *)*((_QWORD *)v3 + 46);
    if (v5)
    {
      *(_QWORD *)((char *)this + i + 376) = v5;
      operator delete(v5);
    }
  }
  v6 = (void *)*((_QWORD *)this + 6);
  if (v6)
  {
    *((_QWORD *)this + 7) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 3);
  if (v7)
  {
    *((_QWORD *)this + 4) = v7;
    operator delete(v7);
  }
  v8 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v8;
    operator delete(v8);
  }
}

vDSP_DFT_Setup *std::unique_ptr<Phase::DFTUtils>::reset[abi:ne180100](vDSP_DFT_Setup **a1, vDSP_DFT_Setup *a2)
{
  vDSP_DFT_Setup *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    Phase::DFTUtils::~DFTUtils(result);
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

uint64_t *std::__hash_table<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<double const&,int &>>(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4, uint64_t a5)
{
  unint64_t v5;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  uint64_t **v10;
  uint64_t *i;
  unint64_t v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  _QWORD *v19;
  unint64_t v20;
  _QWORD v22[3];

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v5 = *a2;
      if (v8 <= v7)
        v5 = v7 % v8;
    }
    else
    {
      v5 = (v8 - 1) & v7;
    }
    v10 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v5);
    if (v10)
    {
      for (i = *v10; i; i = (uint64_t *)*i)
      {
        v12 = i[1];
        if (v12 == v7)
        {
          if (*((_DWORD *)i + 4) == (_DWORD)v7)
            return i;
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8)
              v12 %= v8;
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v5)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<double const&,int &>>(a1, *a2, a4, a5, (uint64_t)v22);
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    v15 = 1;
    if (v8 >= 3)
      v15 = (v8 & (v8 - 1)) != 0;
    v16 = v15 | (2 * v8);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::__rehash<true>(a1, v18);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7)
        v5 = v7 % v8;
      else
        v5 = v7;
    }
    else
    {
      v5 = (v8 - 1) & v7;
    }
  }
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v5);
  if (v19)
  {
    *(_QWORD *)v22[0] = *v19;
    *v19 = v22[0];
  }
  else
  {
    *(_QWORD *)v22[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v22[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v5) = a1 + 16;
    if (*(_QWORD *)v22[0])
    {
      v20 = *(_QWORD *)(*(_QWORD *)v22[0] + 8);
      if ((v8 & (v8 - 1)) != 0)
      {
        if (v20 >= v8)
          v20 %= v8;
      }
      else
      {
        v20 &= v8 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v20) = v22[0];
    }
  }
  i = (uint64_t *)v22[0];
  v22[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,void *>>>>::reset[abi:ne180100]((uint64_t)v22, 0);
  return i;
}

void sub_2165E75DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

Phase::Controller::IR::FIRUtilManager::FIRUtils *std::__hash_table<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<double const&,int &>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD **a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v9;
  _QWORD *v10;
  double *v11;
  int *v12;
  Phase::Controller::IR::FIRUtilManager::FIRUtils *result;

  v9 = a1 + 16;
  v10 = operator new(0x40uLL);
  *(_QWORD *)a5 = v10;
  *(_QWORD *)(a5 + 8) = v9;
  *(_BYTE *)(a5 + 16) = 0;
  *v10 = 0;
  v10[1] = a2;
  v11 = *(double **)a4;
  v12 = *(int **)(a4 + 8);
  *((_DWORD *)v10 + 4) = **a3;
  result = Phase::Controller::IR::FIRUtilManager::FIRUtils::FIRUtils((Phase::Controller::IR::FIRUtilManager::FIRUtils *)(v10 + 3), *v11, *v12);
  *(_BYTE *)(a5 + 16) = 1;
  return result;
}

void sub_2165E766C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

Phase::Controller::IR::FIRUtilManager::FIRUtils *Phase::Controller::IR::FIRUtilManager::FIRUtils::FIRUtils(Phase::Controller::IR::FIRUtilManager::FIRUtils *this, double a2, int a3)
{
  uint64_t *v6;
  Phase::FIRFilterUtils **v7;
  Phase::DFTUtils *v8;
  Phase::DFTUtils *v9;
  Phase::FIRFilterUtils *v10;

  *((_OWORD *)this + 1) = 0u;
  v6 = (uint64_t *)((char *)this + 16);
  v7 = (Phase::FIRFilterUtils **)((char *)this + 8);
  *((_QWORD *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  v8 = (Phase::DFTUtils *)operator new();
  *(_QWORD *)v8 = 0x8000000100;
  *((_QWORD *)v8 + 1) = 0;
  *((_QWORD *)v8 + 2) = 0;
  Phase::DFTUtils::SetFftSize(v8, a3);
  std::unique_ptr<Phase::DFTUtils>::reset[abi:ne180100]((vDSP_DFT_Setup **)this, (vDSP_DFT_Setup *)v8);
  v9 = *(Phase::DFTUtils **)this;
  v10 = (Phase::FIRFilterUtils *)operator new();
  Phase::FIRFilterUtils::FIRFilterUtils(v10, v9, llround(a2));
  std::unique_ptr<Phase::FIRFilterUtils>::reset[abi:ne180100](v7, v10);
  Phase::FIRFilterUtils::GetFrequencyVectorOfDFTBins((int *)*v7, v6);
  return this;
}

void sub_2165E7760(_Unwind_Exception *a1)
{
  uint64_t v1;
  Phase::FIRFilterUtils **v2;
  void **v3;
  void *v5;

  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 24) = v5;
    operator delete(v5);
  }
  std::unique_ptr<Phase::FIRFilterUtils>::reset[abi:ne180100](v2, 0);
  std::unique_ptr<Phase::DFTUtils>::reset[abi:ne180100]((vDSP_DFT_Setup **)v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<int const,Phase::Controller::IR::FIRUtilManager::FIRUtils>,0>((uint64_t)v2 + 16);
    operator delete(v2);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>>>::__deallocate_node(a1, *(Phase::LinkwitzRileyFilterBank ***)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>>>::__deallocate_node(uint64_t a1, Phase::LinkwitzRileyFilterBank **a2)
{
  Phase::LinkwitzRileyFilterBank **v2;
  Phase::LinkwitzRileyFilterBank *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = *v2;
      std::unique_ptr<Phase::LinkwitzRileyFilterBank>::reset[abi:ne180100](v2 + 3, 0);
      operator delete(v2);
      v2 = (Phase::LinkwitzRileyFilterBank **)v3;
    }
    while (v3);
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  _QWORD *v11;
  unint64_t v12;
  _QWORD *v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v8 <= v7)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == (_DWORD)v7)
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v13 = (_QWORD *)(a1 + 16);
  v11 = operator new(0x20uLL);
  *v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  v11[3] = 0;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    v16 = 1;
    if (v8 >= 3)
      v16 = (v8 & (v8 - 1)) != 0;
    v17 = v16 | (2 * v8);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::__rehash<true>(a1, v19);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v21)
  {
    *v11 = *v21;
LABEL_38:
    *v21 = v11;
    goto LABEL_39;
  }
  *v11 = *v13;
  *v13 = v11;
  *(_QWORD *)(v20 + 8 * v4) = v13;
  if (*v11)
  {
    v22 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8)
        v22 %= v8;
    }
    else
    {
      v22 &= v8 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_2165E7AC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  Phase::LinkwitzRileyFilterBank **v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,void *>>>::operator()[abi:ne180100](uint64_t a1, Phase::LinkwitzRileyFilterBank **__p)
{
  if (*(_BYTE *)(a1 + 8))
    std::unique_ptr<Phase::LinkwitzRileyFilterBank>::reset[abi:ne180100](__p + 3, 0);
  if (__p)
    operator delete(__p);
}

Phase::LinkwitzRileyFilterBank *std::unique_ptr<Phase::LinkwitzRileyFilterBank>::reset[abi:ne180100](Phase::LinkwitzRileyFilterBank **a1, Phase::LinkwitzRileyFilterBank *a2)
{
  Phase::LinkwitzRileyFilterBank *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    Phase::LinkwitzRileyFilterBank::~LinkwitzRileyFilterBank(result);
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

void Phase::Controller::IR::IRBuilderCpuFIREq::~IRBuilderCpuFIREq(Phase::Controller::IR::IRBuilderCpuFIREq *this)
{
  std::mutex *v2;

  *(_QWORD *)this = &off_24D57DFC0;
  v2 = (std::mutex *)((char *)this + 56);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 168));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 120));
  std::mutex::~mutex(v2);
  std::__hash_table<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::IR::FIRUtilManager::FIRUtils>>>::~__hash_table((uint64_t)this + 16);
}

{
  Phase::Controller::IR::IRBuilderCpuFIREq::~IRBuilderCpuFIREq(this);
  JUMPOUT(0x2199F9D70);
}

unint64_t Phase::Controller::IR::IRBuilderCpuFIREq::GetWorkBufferSizeInBytes(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  int v15;

  v3 = a2 + 16;
  v4 = *(_QWORD *)(a2 + 32);
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
  v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 80))(v4, v3);
  v7 = *(_QWORD *)(a2 + 8);
  if (v7 && *(_DWORD *)v7 == 3 && (v8 = *(_QWORD *)(v7 + 104)) != 0)
    v9 = ((uint64_t)(*(_QWORD *)(v8 + 8) << 32) >> 30) + 15;
  else
    v9 = 15;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 64))(v4, v3);
  v11 = (v6 + 95) & 0x1FFFFFFF0;
  if (v6 <= 0)
    v11 = 80;
  v12 = ((v9 + v11) & 0xFFFFFFFFFFFFFFF0) + 8 * v5;
  v13 = 4 * v10;
  if (v5 >= 1)
  {
    do
    {
      v12 = ((v12 + 15) & 0xFFFFFFFFFFFFFFF0) + v13;
      --v5;
    }
    while (v5);
  }
  if (v10 >= 0)
    v14 = v10;
  else
    v14 = v10 + 1;
  v15 = (v14 >> 1) + 1;
  return ((((((((((((v12 + 15) & 0xFFFFFFFFFFFFFFF0) + 4 * v15 + 15) & 0xFFFFFFFFFFFFFFF0) + 4 * v15 + 15) & 0xFFFFFFFFFFFFFFF0)
             + 4 * v15
             + 15) & 0xFFFFFFFFFFFFFFF0)
           + 4 * v15
           + 15) & 0xFFFFFFFFFFFFFFF0)
         + 8 * v15
         + 15) & 0xFFFFFFFFFFFFFFF0)
       + v13;
}

void Phase::Controller::IR::IRBuilderCpuFIREq::Build(Phase::Controller::IR::IRBuilderCpuFIREq *this, const Phase::Controller::IR::Metadata *a2, char *a3, float *a4)
{
  char *v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  unsigned int *v20;
  int v21;
  char *v22;
  unint64_t v23;
  int v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  Phase::Logger *v38;
  Phase::Controller::IR::FIRUtilManager *v39;
  uint64_t *FIRUtils;
  DSPSplitComplex v41;
  DSPSplitComplex v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  float v48;
  float v49;
  uint64_t v50;
  uint64_t v51;
  float v52;
  DSPComplex *v53;
  const void *v54;
  uint64_t v55;
  unsigned int v56;
  float *v57;
  unsigned int v58;
  uint64_t v59;
  float v60;
  NSObject *v61;
  std::runtime_error *exception;
  int v63;
  int v64;
  vDSP_Length v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  const Phase::Controller::IR::Metadata *v69;
  uint64_t v70;
  DSPSplitComplex __C;
  DSPSplitComplex v72;
  void *__p[6];

  __p[4] = *(void **)MEMORY[0x24BDAC8D0];
  v8 = (char *)a2 + 16;
  v9 = *((_QWORD *)a2 + 4);
  v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 48))(v9);
  v67 = v9;
  v68 = v8;
  v11 = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v9 + 80))(v9, v8);
  v69 = a2;
  v12 = *((_QWORD *)a2 + 1);
  if (v12 && *(_DWORD *)v12 == 3 && (v13 = *(_QWORD *)(v12 + 104)) != 0)
    v14 = *(_QWORD *)(v13 + 8) << 32;
  else
    v14 = 0;
  v15 = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v9 + 64))(v9, v68);
  v16 = v15;
  if (v15 >= 0)
    v17 = v15;
  else
    v17 = v15 + 1;
  v18 = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v9 + 64))(v9, v68);
  v19 = *((_QWORD *)v69 + 1);
  if (v19 && *(_DWORD *)v19 == 3 && (v20 = *(unsigned int **)(v19 + 104)) != 0)
    v66 = *v20;
  else
    v66 = 0;
  v21 = v17 >> 1;
  *(_QWORD *)a3 = 0;
  v22 = a3 + 72;
  if (v11 >= 1)
  {
    v23 = (unint64_t)(a3 + 87) & 0xFFFFFFFFFFFFFFF0;
    *(_QWORD *)a3 = v23;
    v22 = (char *)(v23 + v11);
  }
  v24 = v21 + 1;
  v25 = (unint64_t)(v22 + 15) & 0xFFFFFFFFFFFFFFF0;
  v26 = (v25 + (v14 >> 30) + 15) & 0xFFFFFFFFFFFFFFF0;
  *((_QWORD *)a3 + 1) = v25;
  *((_QWORD *)a3 + 2) = v26;
  v27 = v26 + 8 * v10;
  v28 = 4 * v16;
  if (v10 >= 1)
  {
    v29 = 0;
    do
    {
      v30 = (v27 + 15) & 0xFFFFFFFFFFFFFFF0;
      *(_QWORD *)(*((_QWORD *)a3 + 2) + v29) = v30;
      v27 = v30 + v28;
      v29 += 8;
    }
    while (8 * v10 != v29);
  }
  v31 = (v27 + 15) & 0xFFFFFFFFFFFFFFF0;
  v32 = (v31 + 4 * v24 + 15) & 0xFFFFFFFFFFFFFFF0;
  *((_QWORD *)a3 + 3) = v31;
  *((_QWORD *)a3 + 4) = v32;
  v33 = (v32 + 4 * v24 + 15) & 0xFFFFFFFFFFFFFFF0;
  v34 = (v33 + 4 * v24 + 15) & 0xFFFFFFFFFFFFFFF0;
  *((_QWORD *)a3 + 5) = v33;
  *((_QWORD *)a3 + 6) = v34;
  v35 = (v34 + 4 * v24 + 15) & 0xFFFFFFFFFFFFFFF0;
  v36 = (v35 + 8 * v24 + 15) & 0xFFFFFFFFFFFFFFF0;
  *((_QWORD *)a3 + 7) = v35;
  *((_QWORD *)a3 + 8) = v36;
  v37 = v36 + v28;
  v38 = (Phase::Logger *)(*(uint64_t (**)(Phase::Controller::IR::IRBuilderCpuFIREq *, const Phase::Controller::IR::Metadata *))(*(_QWORD *)this + 16))(this, v69);
  if (v38 != (Phase::Logger *)(v37 - (_QWORD)a3))
  {
    v61 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v38) + 272));
    if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
    {
      LODWORD(__p[0]) = 136315394;
      *(void **)((char *)__p + 4) = "IRBuilderCpuFIREq.mm";
      WORD2(__p[1]) = 1024;
      *(_DWORD *)((char *)&__p[1] + 6) = 149;
      _os_log_impl(&dword_2164CC000, v61, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [GetWorkBufferSizeInBytes(inMetadata) != PointerDiff(pMemory, pInWorkBuffer) is true]: \"Memory Allocation Error\"", (uint8_t *)__p, 0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Memory Allocation Error");
  }
  v39 = (Phase::Controller::IR::IRBuilderCpuFIREq *)((char *)this + 8);
  Phase::Controller::IR::FIRUtilManager::AddNewFFTSizeSupport((uint64_t)v39, v16);
  FIRUtils = Phase::Controller::IR::FIRUtilManager::GetFIRUtils(v39, v16);
  v41 = *(DSPSplitComplex *)(a3 + 40);
  v42 = *(DSPSplitComplex *)(a3 + 24);
  __C = v42;
  v72 = v41;
  if ((int)v66 >= 1)
  {
    v43 = FIRUtils;
    v44 = 0;
    v65 = v18;
    v63 = v18;
    v64 = (_DWORD)FIRUtils + 16;
    v45 = v18;
    do
    {
      v46 = (_QWORD *)*((_QWORD *)v69 + 1);
      v47 = v46[1] + 12 * v44;
      v48 = *(float *)(v46[7] + 4 * v44);
      v49 = *(float *)v69;
      v50 = v46[13];
      v70 = v44;
      v51 = *(_QWORD *)(v50 + 8);
      if (*(_BYTE *)(v46[18] + v44))
        v52 = -1.0;
      else
        v52 = 1.0;
      LODWORD(v42.realp) = *(_DWORD *)(v47 + 4);
      LODWORD(v41.realp) = *(_DWORD *)(v47 + 8);
      v53 = (DSPComplex *)(*(uint64_t (**)(uint64_t, char *, _QWORD, DSPSplitComplex, DSPSplitComplex))(*(_QWORD *)v67 + 88))(v67, v68, *(_QWORD *)a3, v42, v41);
      memcpy(*((void **)a3 + 1), (const void *)(v50 + 4 * v51 * v70 + 16), v14 >> 30);
      Phase::ArrayFunction::Deinterleave(v53, *((void ***)a3 + 2), v65, v10);
      v54 = (const void *)*((_QWORD *)a3 + 1);
      memset(__p, 0, 24);
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(__p, v54, (uint64_t)v54 + 4 * (v14 >> 32), v14 >> 32);
      Phase::FIRFilterUtils::ConstructFIREqFilter(v43[1], 1, (uint64_t)__p, v64, v72.realp, v72.imagp, *((DSPComplex **)a3 + 7));
      if (v10 >= 1)
      {
        v55 = 0;
        v56 = v10 * vcvtas_u32_f32(v48 * v49);
        do
        {
          Phase::DFTUtils::ProcessDFT((const vDSP_DFT_SetupStruct **)*v43, *(DSPComplex **)(*((_QWORD *)a3 + 2) + 8 * v55), &__C, 0.5);
          Phase::DFTUtils::MultiplyComplexPackedSpectrums((Phase::DFTUtils *)*v43, &__C, &v72, &__C, v21);
          Phase::DFTUtils::ProcessIDFT((const vDSP_DFT_SetupStruct **)*v43, &__C, *((DSPComplex **)a3 + 8));
          if (v63 >= 1)
          {
            v57 = (float *)*((_QWORD *)a3 + 8);
            v58 = v56;
            v59 = v45;
            do
            {
              v60 = *v57++;
              a4[v58] = a4[v58] + (float)(v52 * v60);
              v58 += v10;
              --v59;
            }
            while (v59);
          }
          ++v55;
          ++v56;
        }
        while (v55 != v10);
      }
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      v44 = v70 + 1;
    }
    while (v70 + 1 != v66);
  }
}

void sub_2165E81FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  void *v26;

  __cxa_free_exception(v26);
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::IR::IRBuilderCpuIIRCrossover::IRBuilderCpuIIRCrossover(uint64_t a1, uint64_t a2)
{
  void **v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t *v6;
  unint64_t v7;
  int v8;
  Phase::LinkwitzRileyFilterBank *v9;
  Phase::LinkwitzRileyFilterBank **v10;
  int v11;
  int v12;
  unint64_t v13;
  uint8x8_t v14;
  void **v15;
  _QWORD *v16;
  unint64_t v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  int8x8_t v23;
  void *v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  uint8x8_t v29;
  unint64_t v30;
  uint8x8_t v31;
  uint64_t v32;
  _QWORD *v33;
  unint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  unint64_t v37;
  _QWORD *v38;
  int v39;
  unint64_t v40;
  uint8x8_t v41;
  void **v42;
  char *v43;
  unint64_t v44;
  float v45;
  float v46;
  _BOOL8 v47;
  unint64_t v48;
  unint64_t v49;
  int8x8_t prime;
  void *v51;
  void *v52;
  uint64_t v53;
  _QWORD *v54;
  unint64_t v55;
  uint8x8_t v56;
  unint64_t v57;
  uint8x8_t v58;
  uint64_t v59;
  _QWORD *v60;
  unint64_t v61;
  _QWORD *v62;
  _QWORD *v63;
  unint64_t v64;
  void *v65;
  _QWORD *v66;
  void *v67;
  _QWORD *v69;
  _QWORD *v70;
  uint64_t v71;
  __int128 v72;
  uint64_t v73;
  int v74;
  int *v75;

  *(_QWORD *)a1 = &off_24D57DFF0;
  *(_OWORD *)(a1 + 8) = 0u;
  v3 = (void **)(a1 + 8);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_DWORD *)(a1 + 40) = 1065353216;
  *(_OWORD *)(a1 + 48) = 0u;
  v4 = a1 + 48;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 80) = 1065353216;
  *(_OWORD *)(a1 + 88) = 0u;
  v5 = (_QWORD *)(a1 + 88);
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 1065353216;
  v6 = *(uint64_t **)(a2 + 16);
  if (v6)
  {
    v69 = (_QWORD *)(a1 + 24);
    v70 = (_QWORD *)(a1 + 104);
    v71 = a1 + 48;
    while (1)
    {
      v7 = *((unsigned int *)v6 + 4);
      v8 = *((_DWORD *)v6 + 5);
      v9 = (Phase::LinkwitzRileyFilterBank *)operator new();
      Phase::LinkwitzRileyFilterBank::LinkwitzRileyFilterBank(v9, 0x8000, v7, v8, 48000);
      v75 = (int *)v9;
      v74 = *((_DWORD *)v6 + 4);
      *(_QWORD *)&v72 = &v74;
      v10 = (Phase::LinkwitzRileyFilterBank **)std::__hash_table<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(v4, &v74, (uint64_t)&std::piecewise_construct, (_DWORD **)&v72);
      std::unique_ptr<Phase::LinkwitzRileyFilterBank>::reset[abi:ne180100](v10 + 3, v9);
      LODWORD(v75) = *((_DWORD *)v6 + 4);
      *(_QWORD *)&v72 = &v75;
      v11 = *(_DWORD *)(std::__hash_table<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(v4, (int *)&v75, (uint64_t)&std::piecewise_construct, (_DWORD **)&v72)[3]+ 12);
      v12 = *((_DWORD *)v6 + 4);
      v13 = *(_QWORD *)(a1 + 96);
      if (v13)
      {
        v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
        v14.i16[0] = vaddlv_u8(v14);
        if (v14.u32[0] > 1uLL)
        {
          v7 = v12;
          if (v13 <= v12)
            v7 = v12 % v13;
        }
        else
        {
          v7 = (v13 - 1) & v12;
        }
        v15 = *(void ***)(*v5 + 8 * v7);
        if (v15)
        {
          v16 = *v15;
          if (*v15)
          {
            do
            {
              v17 = v16[1];
              if (v17 == v12)
              {
                if (*((_DWORD *)v16 + 4) == v12)
                  goto LABEL_75;
              }
              else
              {
                if (v14.u32[0] > 1uLL)
                {
                  if (v17 >= v13)
                    v17 %= v13;
                }
                else
                {
                  v17 &= v13 - 1;
                }
                if (v17 != v7)
                  break;
              }
              v16 = (_QWORD *)*v16;
            }
            while (v16);
          }
        }
      }
      v16 = operator new(0x18uLL);
      *v16 = 0;
      v16[1] = v12;
      *((_DWORD *)v16 + 4) = v12;
      *((_DWORD *)v16 + 5) = 0;
      v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 112) + 1);
      v19 = *(float *)(a1 + 120);
      if (!v13 || (float)(v19 * (float)v13) < v18)
        break;
LABEL_65:
      v35 = (_QWORD *)*v5;
      v36 = *(_QWORD **)(*v5 + 8 * v7);
      if (v36)
      {
        *v16 = *v36;
LABEL_73:
        *v36 = v16;
        goto LABEL_74;
      }
      *v16 = *v70;
      *v70 = v16;
      v35[v7] = v70;
      if (*v16)
      {
        v37 = *(_QWORD *)(*v16 + 8);
        if ((v13 & (v13 - 1)) != 0)
        {
          if (v37 >= v13)
            v37 %= v13;
        }
        else
        {
          v37 &= v13 - 1;
        }
        v36 = (_QWORD *)(*v5 + 8 * v37);
        goto LABEL_73;
      }
LABEL_74:
      ++*(_QWORD *)(a1 + 112);
LABEL_75:
      *((_DWORD *)v16 + 5) = v11;
      v74 = *((_DWORD *)v6 + 4);
      v75 = &v74;
      v38 = std::__hash_table<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(v71, &v74, (uint64_t)&std::piecewise_construct, &v75);
      Phase::LinkwitzRileyFilterBank::CreateVDSPFilterBankSetup((Phase::LinkwitzRileyFilterBank *)v38[3], &v72);
      v39 = *((_DWORD *)v6 + 4);
      v40 = *(_QWORD *)(a1 + 16);
      if (v40)
      {
        v41 = (uint8x8_t)vcnt_s8((int8x8_t)v40);
        v41.i16[0] = vaddlv_u8(v41);
        if (v41.u32[0] > 1uLL)
        {
          v13 = v39;
          if (v40 <= v39)
            v13 = v39 % v40;
        }
        else
        {
          v13 = (v40 - 1) & v39;
        }
        v42 = (void **)*((_QWORD *)*v3 + v13);
        if (v42)
        {
          v43 = (char *)*v42;
          if (*v42)
          {
            do
            {
              v44 = *((_QWORD *)v43 + 1);
              if (v44 == v39)
              {
                if (*((_DWORD *)v43 + 4) == v39)
                {
                  v4 = v71;
                  goto LABEL_147;
                }
              }
              else
              {
                if (v41.u32[0] > 1uLL)
                {
                  if (v44 >= v40)
                    v44 %= v40;
                }
                else
                {
                  v44 &= v40 - 1;
                }
                if (v44 != v13)
                  break;
              }
              v43 = *(char **)v43;
            }
            while (v43);
          }
        }
      }
      v43 = (char *)operator new(0x30uLL);
      *(_QWORD *)v43 = 0;
      *((_QWORD *)v43 + 1) = v39;
      *((_DWORD *)v43 + 4) = v39;
      *((_QWORD *)v43 + 4) = 0;
      *((_QWORD *)v43 + 5) = 0;
      *((_QWORD *)v43 + 3) = 0;
      v45 = (float)(unint64_t)(*(_QWORD *)(a1 + 32) + 1);
      v46 = *(float *)(a1 + 40);
      if (!v40 || (float)(v46 * (float)v40) < v45)
      {
        v47 = (v40 & (v40 - 1)) != 0;
        if (v40 < 3)
          v47 = 1;
        v48 = v47 | (2 * v40);
        v49 = vcvtps_u32_f32(v45 / v46);
        if (v48 <= v49)
          prime = (int8x8_t)v49;
        else
          prime = (int8x8_t)v48;
        if (*(_QWORD *)&prime == 1)
        {
          prime = (int8x8_t)2;
        }
        else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
        {
          prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
          v40 = *(_QWORD *)(a1 + 16);
        }
        if (*(_QWORD *)&prime <= v40)
        {
          if (*(_QWORD *)&prime < v40)
          {
            v57 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 32) / *(float *)(a1 + 40));
            if (v40 < 3 || (v58 = (uint8x8_t)vcnt_s8((int8x8_t)v40), v58.i16[0] = vaddlv_u8(v58), v58.u32[0] > 1uLL))
            {
              v57 = std::__next_prime(v57);
            }
            else
            {
              v59 = 1 << -(char)__clz(v57 - 1);
              if (v57 >= 2)
                v57 = v59;
            }
            if (*(_QWORD *)&prime <= v57)
              prime = (int8x8_t)v57;
            if (*(_QWORD *)&prime >= v40)
            {
              v40 = *(_QWORD *)(a1 + 16);
            }
            else
            {
              if (prime)
                goto LABEL_103;
              v67 = *v3;
              *v3 = 0;
              if (v67)
                operator delete(v67);
              v40 = 0;
              *(_QWORD *)(a1 + 16) = 0;
            }
          }
        }
        else
        {
LABEL_103:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v51 = operator new(8 * *(_QWORD *)&prime);
          v52 = *v3;
          *v3 = v51;
          if (v52)
            operator delete(v52);
          v53 = 0;
          *(int8x8_t *)(a1 + 16) = prime;
          do
            *((_QWORD *)*v3 + v53++) = 0;
          while (*(_QWORD *)&prime != v53);
          v54 = (_QWORD *)*v69;
          if (*v69)
          {
            v55 = v54[1];
            v56 = (uint8x8_t)vcnt_s8(prime);
            v56.i16[0] = vaddlv_u8(v56);
            if (v56.u32[0] > 1uLL)
            {
              if (v55 >= *(_QWORD *)&prime)
                v55 %= *(_QWORD *)&prime;
            }
            else
            {
              v55 &= *(_QWORD *)&prime - 1;
            }
            *((_QWORD *)*v3 + v55) = v69;
            v60 = (_QWORD *)*v54;
            if (*v54)
            {
              do
              {
                v61 = v60[1];
                if (v56.u32[0] > 1uLL)
                {
                  if (v61 >= *(_QWORD *)&prime)
                    v61 %= *(_QWORD *)&prime;
                }
                else
                {
                  v61 &= *(_QWORD *)&prime - 1;
                }
                if (v61 != v55)
                {
                  if (!*((_QWORD *)*v3 + v61))
                  {
                    *((_QWORD *)*v3 + v61) = v54;
                    goto LABEL_128;
                  }
                  *v54 = *v60;
                  *v60 = **((_QWORD **)*v3 + v61);
                  **((_QWORD **)*v3 + v61) = v60;
                  v60 = v54;
                }
                v61 = v55;
LABEL_128:
                v54 = v60;
                v60 = (_QWORD *)*v60;
                v55 = v61;
              }
              while (v60);
            }
          }
          v40 = (unint64_t)prime;
        }
        if ((v40 & (v40 - 1)) != 0)
        {
          if (v40 <= v39)
            v13 = v39 % v40;
          else
            v13 = v39;
        }
        else
        {
          v13 = (v40 - 1) & v39;
        }
      }
      v62 = *v3;
      v63 = (_QWORD *)*((_QWORD *)*v3 + v13);
      if (v63)
      {
        *(_QWORD *)v43 = *v63;
        v4 = v71;
      }
      else
      {
        *(_QWORD *)v43 = *v69;
        *v69 = v43;
        v62[v13] = v69;
        v4 = v71;
        if (!*(_QWORD *)v43)
          goto LABEL_146;
        v64 = *(_QWORD *)(*(_QWORD *)v43 + 8);
        if ((v40 & (v40 - 1)) != 0)
        {
          if (v64 >= v40)
            v64 %= v40;
        }
        else
        {
          v64 &= v40 - 1;
        }
        v63 = (char *)*v3 + 8 * v64;
      }
      *v63 = v43;
LABEL_146:
      ++*(_QWORD *)(a1 + 32);
LABEL_147:
      v65 = (void *)*((_QWORD *)v43 + 3);
      if (v65)
      {
        *((_QWORD *)v43 + 4) = v65;
        operator delete(v65);
        *((_QWORD *)v43 + 3) = 0;
        *((_QWORD *)v43 + 4) = 0;
        *((_QWORD *)v43 + 5) = 0;
      }
      *(_OWORD *)(v43 + 24) = v72;
      *((_QWORD *)v43 + 5) = v73;
      v6 = (uint64_t *)*v6;
      if (!v6)
        return a1;
    }
    v20 = (v13 & (v13 - 1)) != 0;
    if (v13 < 3)
      v20 = 1;
    v21 = v20 | (2 * v13);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      v23 = (int8x8_t)v22;
    else
      v23 = (int8x8_t)v21;
    if (*(_QWORD *)&v23 == 1)
    {
      v23 = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&v23 & (*(_QWORD *)&v23 - 1)) != 0)
    {
      v23 = (int8x8_t)std::__next_prime(*(_QWORD *)&v23);
      v13 = *(_QWORD *)(a1 + 96);
    }
    if (*(_QWORD *)&v23 > v13)
      goto LABEL_31;
    if (*(_QWORD *)&v23 < v13)
    {
      v30 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 112) / *(float *)(a1 + 120));
      if (v13 < 3 || (v31 = (uint8x8_t)vcnt_s8((int8x8_t)v13), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
      {
        v30 = std::__next_prime(v30);
      }
      else
      {
        v32 = 1 << -(char)__clz(v30 - 1);
        if (v30 >= 2)
          v30 = v32;
      }
      if (*(_QWORD *)&v23 <= v30)
        v23 = (int8x8_t)v30;
      if (*(_QWORD *)&v23 >= v13)
      {
        v13 = *(_QWORD *)(a1 + 96);
      }
      else
      {
        if (v23)
        {
LABEL_31:
          if (*(_QWORD *)&v23 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v24 = operator new(8 * *(_QWORD *)&v23);
          v25 = (_QWORD *)*v5;
          *v5 = v24;
          if (v25)
            operator delete(v25);
          v26 = 0;
          *(int8x8_t *)(a1 + 96) = v23;
          do
            *(_QWORD *)(*v5 + 8 * v26++) = 0;
          while (*(_QWORD *)&v23 != v26);
          v27 = (_QWORD *)*v70;
          if (*v70)
          {
            v28 = v27[1];
            v29 = (uint8x8_t)vcnt_s8(v23);
            v29.i16[0] = vaddlv_u8(v29);
            if (v29.u32[0] > 1uLL)
            {
              if (v28 >= *(_QWORD *)&v23)
                v28 %= *(_QWORD *)&v23;
            }
            else
            {
              v28 &= *(_QWORD *)&v23 - 1;
            }
            *(_QWORD *)(*v5 + 8 * v28) = v70;
            v33 = (_QWORD *)*v27;
            if (*v27)
            {
              do
              {
                v34 = v33[1];
                if (v29.u32[0] > 1uLL)
                {
                  if (v34 >= *(_QWORD *)&v23)
                    v34 %= *(_QWORD *)&v23;
                }
                else
                {
                  v34 &= *(_QWORD *)&v23 - 1;
                }
                if (v34 != v28)
                {
                  if (!*(_QWORD *)(*v5 + 8 * v34))
                  {
                    *(_QWORD *)(*v5 + 8 * v34) = v27;
                    goto LABEL_56;
                  }
                  *v27 = *v33;
                  *v33 = **(_QWORD **)(*v5 + 8 * v34);
                  **(_QWORD **)(*v5 + 8 * v34) = v33;
                  v33 = v27;
                }
                v34 = v28;
LABEL_56:
                v27 = v33;
                v33 = (_QWORD *)*v33;
                v28 = v34;
              }
              while (v33);
            }
          }
          v13 = (unint64_t)v23;
          goto LABEL_60;
        }
        v66 = (_QWORD *)*v5;
        *v5 = 0;
        if (v66)
          operator delete(v66);
        v13 = 0;
        *(_QWORD *)(a1 + 96) = 0;
      }
    }
LABEL_60:
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v13 <= v12)
        v7 = v12 % v13;
      else
        v7 = v12;
    }
    else
    {
      v7 = (v13 - 1) & v12;
    }
    goto LABEL_65;
  }
  return a1;
}

void sub_2165E8B5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  uint64_t v18;
  uint64_t v19;
  void *v20;

  operator delete(v20);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v19);
  std::__hash_table<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>>>::~__hash_table(a12);
  std::__hash_table<std::__hash_value_type<int,std::vector<vDSP_biquad_SetupStruct *>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<vDSP_biquad_SetupStruct *>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<vDSP_biquad_SetupStruct *>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<vDSP_biquad_SetupStruct *>>>>::~__hash_table(v18);
  _Unwind_Resume(a1);
}

void Phase::Controller::IR::IRBuilderCpuIIRCrossover::~IRBuilderCpuIIRCrossover(Phase::Controller::IR::IRBuilderCpuIIRCrossover *this)
{
  _QWORD *i;
  vDSP_biquad_Setup *v3;
  vDSP_biquad_Setup *v4;

  *(_QWORD *)this = &off_24D57DFF0;
  for (i = (_QWORD *)*((_QWORD *)this + 3); i; i = (_QWORD *)*i)
  {
    v3 = (vDSP_biquad_Setup *)i[3];
    v4 = (vDSP_biquad_Setup *)i[4];
    while (v3 != v4)
      vDSP_biquad_DestroySetup(*v3++);
  }
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)this + 88);
  std::__hash_table<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unique_ptr<Phase::LinkwitzRileyFilterBank>>>>::~__hash_table((uint64_t)this + 48);
  std::__hash_table<std::__hash_value_type<int,std::vector<vDSP_biquad_SetupStruct *>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<vDSP_biquad_SetupStruct *>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<vDSP_biquad_SetupStruct *>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<vDSP_biquad_SetupStruct *>>>>::~__hash_table((uint64_t)this + 8);
}

{
  Phase::Controller::IR::IRBuilderCpuIIRCrossover::~IRBuilderCpuIIRCrossover(this);
  JUMPOUT(0x2199F9D70);
}

unint64_t Phase::Controller::IR::IRBuilderCpuIIRCrossover::GetWorkBufferSizeInBytes(Phase::Controller::IR::IRBuilderCpuIIRCrossover *this, const Phase::Controller::IR::Metadata *a2)
{
  char *v4;
  uint64_t v5;
  unsigned int MaxDelayInSamples;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  unint64_t result;

  v4 = (char *)a2 + 16;
  v5 = *((_QWORD *)a2 + 4);
  MaxDelayInSamples = Phase::Controller::IR::GetMaxDelayInSamples(a2, a2);
  v7 = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v5 + 64))(v5, v4);
  v8 = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v5 + 80))(v5, v4);
  v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
  v10 = *((_QWORD *)a2 + 1);
  if (v10 && *(_DWORD *)v10 == 3 && (v11 = *(_QWORD *)(v10 + 104)) != 0)
    v12 = *(_DWORD *)(v11 + 8);
  else
    v12 = 0;
  v13 = std::__hash_table<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::__unordered_map_hasher<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,true>,std::__unordered_map_equal<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,true>,std::allocator<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>>>::find<Phase::Controller::IR::IRBuilder::Processor>((_QWORD *)this + 11, v12);
  if (!v13)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  v14 = v7 + MaxDelayInSamples;
  v15 = (v8 + 63) | 8;
  if (v8 <= 0)
    v15 = 56;
  v16 = 8 * v9;
  v17 = ((((v15 + 8 * *((int *)v13 + 5) + 8) & 0xFFFFFFFFFFFFFFF0) + 4 * v14 + 15) & 0xFFFFFFFFFFFFFFF0) + v16;
  if (v9 < 1)
    return ((v17 + 15) & 0xFFFFFFFFFFFFFFF0) + v16;
  v18 = 4 * v14;
  v19 = v9;
  do
  {
    v17 = ((v17 + 15) & 0xFFFFFFFFFFFFFFF0) + v18;
    --v19;
  }
  while (v19);
  result = ((v17 + 15) & 0xFFFFFFFFFFFFFFF0) + v16;
  do
  {
    result = ((result + 15) & 0xFFFFFFFFFFFFFFF0) + v18;
    --v9;
  }
  while (v9);
  return result;
}

void Phase::Controller::IR::IRBuilderCpuIIRCrossover::Build(Phase::Controller::IR::IRBuilderCpuIIRCrossover *this, const Phase::Controller::IR::Metadata *a2, char *a3, float *a4)
{
  char *v8;
  uint64_t v9;
  unsigned int MaxDelayInSamples;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  unsigned int *v17;
  uint64_t v18;
  char *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  Phase::Logger *v35;
  uint64_t InstancePtr;
  int v37;
  unsigned __int8 v38;
  uint64_t *v39;
  uint64_t v40;
  BOOL v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t i;
  _QWORD *v46;
  float v47;
  float v48;
  uint64_t v49;
  int v50;
  float v51;
  float v52;
  uint64_t v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t v56;
  signed int v57;
  float *v58;
  uint64_t v59;
  unint64_t v60;
  uint8x8_t v61;
  unint64_t v62;
  uint64_t **v63;
  uint64_t *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  float *v69;
  int v70;
  uint64_t v71;
  float v72;
  NSObject *v73;
  std::runtime_error *v74;
  NSObject *v75;
  std::runtime_error *exception;
  NSObject *v77;
  std::runtime_error *v78;
  float *v79;
  _QWORD *v80;
  Phase::Controller::IR::IRBuilderCpuIIRCrossover *v81;
  int v82;
  uint64_t *v83;
  char *v84;
  const Phase::Controller::IR::Metadata *v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  uint64_t __N;
  uint8_t buf[4];
  const char *v91;
  __int16 v92;
  int v93;
  __int16 v94;
  Phase::Controller::IR::IRBuilderCpuIIRCrossover *v95;
  __int16 v96;
  int v97;
  uint64_t v98;

  v98 = *MEMORY[0x24BDAC8D0];
  v8 = (char *)a2 + 16;
  v9 = *((_QWORD *)a2 + 4);
  MaxDelayInSamples = Phase::Controller::IR::GetMaxDelayInSamples(a2, a2);
  v11 = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v9 + 64))(v9, v8);
  v84 = v8;
  v12 = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v9 + 80))(v9, v8);
  v87 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 48))(v9);
  v85 = a2;
  v13 = *((_QWORD *)a2 + 1);
  if (v13 && *(_DWORD *)v13 == 3 && (v14 = *(_QWORD *)(v13 + 104)) != 0)
    v15 = *(_QWORD *)(v14 + 8);
  else
    LODWORD(v15) = 0;
  v82 = v15;
  v16 = std::__hash_table<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::__unordered_map_hasher<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,true>,std::__unordered_map_equal<Phase::Controller::IR::IRBuilder::Processor,std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>,std::equal_to<Phase::Controller::IR::IRBuilder::Processor>,std::hash<Phase::Controller::IR::IRBuilder::Processor>,true>,std::allocator<std::__hash_value_type<Phase::Controller::IR::IRBuilder::Processor,std::unordered_map<Phase::Controller::IR::IRBuilder::Method,Phase::Controller::IR::IRBuilderBase *>>>>::find<Phase::Controller::IR::IRBuilder::Processor>((_QWORD *)this + 11, v15);
  if (!v16)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  if (v13 && *(_DWORD *)v13 == 3 && (v17 = *(unsigned int **)(v13 + 104)) != 0)
    v86 = *v17;
  else
    v86 = 0;
  v18 = v11 + MaxDelayInSamples;
  __N = 2 * *((int *)v16 + 5) + 2;
  *(_QWORD *)a3 = 0;
  v19 = a3 + 40;
  if (v12 >= 1)
  {
    v20 = (unint64_t)(a3 + 55) & 0xFFFFFFFFFFFFFFF0;
    *(_QWORD *)a3 = v20;
    v19 = (char *)(v20 + v12);
  }
  v21 = (unint64_t)(v19 + 15) & 0xFFFFFFFFFFFFFFF0;
  v22 = (v21 + 4 * __N + 15) & 0xFFFFFFFFFFFFFFF0;
  *((_QWORD *)a3 + 1) = v21;
  *((_QWORD *)a3 + 2) = v22;
  v23 = v22 + 4 * (int)v18 + 15;
  v24 = 8 * v87;
  v23 &= 0xFFFFFFFFFFFFFFF0;
  *((_QWORD *)a3 + 3) = v23;
  v25 = v23 + v24;
  if (v87 <= 0)
  {
    v34 = (v25 + 15) & 0xFFFFFFFFFFFFFFF0;
    *((_QWORD *)a3 + 4) = v34;
    v31 = a3 + 32;
    v32 = v34 + v24;
  }
  else
  {
    v26 = 0;
    v27 = 4 * (int)v18;
    do
    {
      v28 = (v25 + 15) & 0xFFFFFFFFFFFFFFF0;
      *(_QWORD *)(*((_QWORD *)a3 + 3) + v26) = v28;
      v25 = v28 + v27;
      v26 += 8;
    }
    while (8 * v87 != v26);
    v29 = 0;
    v30 = (v25 + 15) & 0xFFFFFFFFFFFFFFF0;
    *((_QWORD *)a3 + 4) = v30;
    v31 = a3 + 32;
    v32 = v30 + v24;
    do
    {
      v33 = (v32 + 15) & 0xFFFFFFFFFFFFFFF0;
      *(_QWORD *)(*v31 + v29) = v33;
      v32 = v33 + v27;
      v29 += 8;
    }
    while (8 * v87 != v29);
  }
  v35 = (Phase::Logger *)(*(uint64_t (**)(Phase::Controller::IR::IRBuilderCpuIIRCrossover *, const Phase::Controller::IR::Metadata *))(*(_QWORD *)this + 16))(this, v85);
  InstancePtr = Phase::Logger::GetInstancePtr(v35);
  if (v35 != (Phase::Logger *)(v32 - (_QWORD)a3))
  {
    v75 = objc_retainAutorelease(**(id **)(InstancePtr + 272));
    if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v91 = "IRBuilderCpuIIRCrossover.mm";
      v92 = 1024;
      v93 = 202;
      _os_log_impl(&dword_2164CC000, v75, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [GetWorkBufferSizeInBytes(inMetadata) != PointerDiff(pMemory, pInWorkBuffer) is true]: \"Memory Allocation Error\"", buf, 0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Memory Allocation Error");
  }
  v37 = v82;
  v79 = a4;
  v80 = v31;
  if (v82 == 31)
  {
    v39 = (uint64_t *)&Phase::Controller::IR::sGetCompensationGains(unsigned long)::sThirdOctaveBandCompensationGains;
    goto LABEL_31;
  }
  if (v82 == 10)
  {
    v39 = (uint64_t *)&Phase::Controller::IR::sGetCompensationGains(unsigned long)::sOctaveBandCompensationGains;
LABEL_31:
    v83 = v39;
    goto LABEL_32;
  }
  if (v82 != 3)
  {
    v77 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr((Phase::Logger *)InstancePtr) + 272));
    if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v91 = "IRBuilderCpuIIRCrossover.mm";
      v92 = 1024;
      v93 = 212;
      v94 = 1024;
      LODWORD(v95) = v82;
      _os_log_impl(&dword_2164CC000, v77, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [nullptr == pSubbandCompensationGains is true]: \"Failed to get compensation gains for subband count %d\"", buf, 0x18u);
    }
    v78 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v78, "Failed to get compensation gains for subband count %d");
  }
  v38 = atomic_load((unsigned __int8 *)&_MergedGlobals_16);
  v83 = &qword_254E448E0;
  if ((v38 & 1) == 0)
  {
    InstancePtr = __cxa_guard_acquire(&_MergedGlobals_16);
    if ((_DWORD)InstancePtr)
    {
      qword_254E448E0 = 0x3F8000003F9820D7;
      v83 = &qword_254E448E0;
      dword_254E448E8 = 1065353216;
      __cxa_guard_release(&_MergedGlobals_16);
    }
    v37 = v82;
  }
LABEL_32:
  if (v87 >= 1)
  {
    v40 = 0;
    do
    {
      vDSP_vclr(*(float **)(*v31 + v40), 1, (int)v18);
      v40 += 8;
    }
    while (8 * v87 != v40);
  }
  v81 = this;
  v41 = v37 < 1;
  v42 = v87;
  if (!v41)
  {
    v43 = 0;
    v88 = 8 * v87;
    do
    {
      if (v42 >= 1)
      {
        v44 = 0;
        do
        {
          vDSP_vclr(*(float **)(*((_QWORD *)a3 + 3) + v44), 1, (int)v18);
          v44 += 8;
        }
        while (v88 != v44);
      }
      if ((int)v86 >= 1)
      {
        for (i = 0; i != v86; ++i)
        {
          v46 = (_QWORD *)*((_QWORD *)v85 + 1);
          v47 = *(float *)(v46[7] + 4 * i);
          v48 = *(float *)v85;
          v49 = v46[13] + 4 * *(_QWORD *)(v46[13] + 8) * i + 4 * v43;
          v50 = *(unsigned __int8 *)(v46[18] + i);
          InstancePtr = (*(uint64_t (**)(uint64_t, char *, _QWORD, float, float))(*(_QWORD *)v9 + 88))(v9, v84, *(_QWORD *)a3, *(float *)(v46[1] + 12 * i + 4), *(float *)(v46[1] + 12 * i + 8));
          v51 = *(float *)(v49 + 16);
          v52 = -(float)(v51 * *((float *)v83 + v43));
          if (!v50)
            v52 = v51 * *((float *)v83 + v43);
          if (v87 >= 1)
          {
            v53 = 0;
            v54 = vcvtas_u32_f32(v47 * v48);
            v55 = *((_QWORD *)a3 + 3);
            do
            {
              if (v11 >= 1)
              {
                v56 = *(_QWORD *)(v55 + 8 * v53);
                v57 = v54;
                v58 = (float *)InstancePtr;
                v59 = v11;
                do
                {
                  *(float *)(v56 + 4 * v57) = *(float *)(v56 + 4 * v57) + (float)(*v58 * v52);
                  v58 += v87;
                  ++v57;
                  --v59;
                }
                while (v59);
              }
              ++v53;
              InstancePtr += 4;
            }
            while (v53 != v87);
          }
        }
      }
      v60 = *((_QWORD *)v81 + 2);
      if (!v60)
        goto LABEL_79;
      v61 = (uint8x8_t)vcnt_s8((int8x8_t)v60);
      v61.i16[0] = vaddlv_u8(v61);
      if (v61.u32[0] > 1uLL)
      {
        v62 = v82;
        if (v60 <= v82)
          v62 = v82 % v60;
      }
      else
      {
        v62 = (v60 - 1) & v82;
      }
      v63 = *(uint64_t ***)(*((_QWORD *)v81 + 1) + 8 * v62);
      if (!v63 || (v64 = *v63) == 0)
      {
LABEL_79:
        v73 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr((Phase::Logger *)InstancePtr)
                                                         + 272));
        if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          v91 = "IRBuilderCpuIIRCrossover.mm";
          v92 = 1024;
          v93 = 328;
          v94 = 2048;
          v95 = v81;
          v96 = 1024;
          v97 = v82;
          _os_log_impl(&dword_2164CC000, v73, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error): \"IRBuilderCpuIIRCrossover:%p Filterbank with %d bands is not supported.\"", buf, 0x22u);
        }
        v74 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v74, "IRBuilderCpuIIRCrossover:%p Filterbank with %d bands is not supported.");
      }
      while (1)
      {
        v65 = v64[1];
        if (v65 == v82)
          break;
        if (v61.u32[0] > 1uLL)
        {
          if (v65 >= v60)
            v65 %= v60;
        }
        else
        {
          v65 &= v60 - 1;
        }
        if (v65 != v62)
          goto LABEL_79;
LABEL_66:
        v64 = (uint64_t *)*v64;
        if (!v64)
          goto LABEL_79;
      }
      if (*((_DWORD *)v64 + 4) != v82)
        goto LABEL_66;
      v42 = v87;
      if (v87 >= 1)
      {
        v66 = 0;
        do
        {
          vDSP_vclr(*((float **)a3 + 1), 1, __N);
          vDSP_biquad(*(const vDSP_biquad_SetupStruct **)(v64[3] + 8 * v43), *((float **)a3 + 1), *(const float **)(*((_QWORD *)a3 + 3) + v66), 1, *((float **)a3 + 2), 1, (int)v18);
          vDSP_vclr(*((float **)a3 + 1), 1, __N);
          vDSP_biquad(*(const vDSP_biquad_SetupStruct **)(v64[3] + 8 * v43), *((float **)a3 + 1), *((const float **)a3 + 2), 1, *((float **)a3 + 2), 1, (int)v18);
          vDSP_vadd(*((const float **)a3 + 2), 1, *(const float **)(*((_QWORD *)a3 + 4) + v66), 1, *(float **)(*((_QWORD *)a3 + 4) + v66), 1, (int)v18);
          v66 += 8;
        }
        while (v88 != v66);
      }
      ++v43;
      v31 = v80;
    }
    while (v43 != v82);
  }
  if (v42 >= 1)
  {
    v67 = 0;
    v68 = *v31;
    do
    {
      if ((_DWORD)v18)
      {
        v69 = *(float **)(v68 + 8 * v67);
        v70 = v67;
        v71 = v18;
        do
        {
          v72 = *v69++;
          v79[v70] = v72 + v79[v70];
          v70 += v42;
          --v71;
        }
        while (v71);
      }
      ++v67;
    }
    while (v67 != v87);
  }
}

void sub_2165E9660(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_2165E9674(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2165E968C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,__int128 buf,__int16 a24,__int16 a25,int a26,int a27,int a28)
{
  int v28;
  void *v29;
  Phase::Logger *v32;
  NSObject *v33;
  std::runtime_error *exception;

  __cxa_free_exception(v29);
  if (a2 == 2)
  {
    v32 = (Phase::Logger *)__cxa_begin_catch(a1);
    v33 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v32) + 272));
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315906;
      *(_QWORD *)((char *)&buf + 4) = "IRBuilderCpuIIRCrossover.mm";
      WORD6(buf) = 1024;
      *(_DWORD *)((char *)&buf + 14) = 297;
      a25 = 2048;
      LOWORD(a28) = 1024;
      *(int *)((char *)&a28 + 2) = v28;
      _os_log_impl(&dword_2164CC000, v33, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error): \"IRBuilderCpuIIRCrossover: %p Failed to filter subband %u\"", (uint8_t *)&buf, 0x22u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "IRBuilderCpuIIRCrossover: %p Failed to filter subband %u");
  }
  _Unwind_Resume(a1);
}

void sub_2165E977C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_2165E979C(void *a1, int a2)
{
  if (!a2)
    JUMPOUT(0x2165E97A4);
  __clang_call_terminate(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<int,std::vector<vDSP_biquad_SetupStruct *>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<vDSP_biquad_SetupStruct *>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<vDSP_biquad_SetupStruct *>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<vDSP_biquad_SetupStruct *>>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  void *v5;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v5 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v5)
    operator delete(v5);
  return a1;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::vector<vDSP_biquad_SetupStruct *>>,void *>>>::operator()[abi:ne180100](char a1, _QWORD *__p)
{
  void *v3;

  if (a1)
  {
    v3 = (void *)__p[3];
    if (v3)
    {
      __p[4] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

void Phase::Controller::IR::IRBuilderCpuSimple::~IRBuilderCpuSimple(Phase::Controller::IR::IRBuilderCpuSimple *this)
{
  JUMPOUT(0x2199F9D70);
}

uint64_t Phase::Controller::IR::IRBuilderCpuSimple::GetWorkBufferSizeInBytes(uint64_t a1, uint64_t a2)
{
  int v2;

  v2 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 32) + 80))(*(_QWORD *)(a2 + 32), a2 + 16);
  if (v2 <= 0)
    return 8;
  else
    return v2 + 16;
}

void Phase::Controller::IR::IRBuilderCpuSimple::Build(Phase::Controller::IR::IRBuilderCpuSimple *this, const Phase::Controller::IR::Metadata *a2, char *a3, float *a4)
{
  char *v7;
  uint64_t v8;
  unsigned int MaxDelayInSamples;
  int v10;
  int v11;
  uint64_t v12;
  unsigned int *v13;
  int v14;
  uint64_t v15;
  char *v16;
  unint64_t v17;
  Phase::Logger *v18;
  Phase::Logger *v19;
  __n128 v20;
  __n128 v21;
  NSObject *v22;
  uint64_t v23;
  vDSP_Length v24;
  uint64_t v25;
  _QWORD *v26;
  unsigned __int32 *v27;
  float v28;
  float v29;
  uint64_t v30;
  uint64_t v31;
  _BOOL4 v32;
  const float *v33;
  unsigned int v34;
  float v35;
  NSObject *v36;
  NSObject *v37;
  std::runtime_error *exception;
  char *v39;
  int v41;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  int v45;
  __int16 v46;
  Phase::Controller::IR::IRBuilderCpuSimple *v47;
  __int16 v48;
  int v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  v7 = (char *)a2 + 16;
  v8 = *((_QWORD *)a2 + 4);
  MaxDelayInSamples = Phase::Controller::IR::GetMaxDelayInSamples(a2, a2);
  v10 = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v8 + 64))(v8, v7);
  v41 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 48))(v8);
  v39 = v7;
  v11 = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v8 + 80))(v8, v7);
  v12 = *((_QWORD *)a2 + 1);
  if (v12 && *(_DWORD *)v12 == 3 && (v13 = *(unsigned int **)(v12 + 104)) != 0)
  {
    v14 = v13[2];
    v15 = *v13;
  }
  else
  {
    v14 = 0;
    v15 = 0;
  }
  *(_QWORD *)a3 = 0;
  v16 = a3 + 8;
  if (v11 >= 1)
  {
    v17 = (unint64_t)(a3 + 23) & 0xFFFFFFFFFFFFFFF0;
    *(_QWORD *)a3 = v17;
    v16 = (char *)(v17 + v11);
  }
  v18 = (Phase::Logger *)(*(uint64_t (**)(Phase::Controller::IR::IRBuilderCpuSimple *, const Phase::Controller::IR::Metadata *))(*(_QWORD *)this + 16))(this, a2);
  if (v18 != (Phase::Logger *)(v16 - a3))
  {
    v37 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v18) + 272));
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v43 = "IRBuilderCpuSimple.mm";
      v44 = 1024;
      v45 = 76;
      _os_log_impl(&dword_2164CC000, v37, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [GetWorkBufferSizeInBytes(inMetadata) != PointerDiff(pMemory, pInWorkBuffer) is true]: \"Memory Allocation Error\"", buf, 0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Memory Allocation Error");
  }
  vDSP_vclr(a4, 1, (int)(v41 * (v10 + MaxDelayInSamples)));
  if (v14)
  {
    if (v14 > 1)
    {
      v22 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v19) + 272));
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315906;
        v43 = "IRBuilderCpuSimple.mm";
        v44 = 1024;
        v45 = 91;
        v46 = 2048;
        v47 = this;
        v48 = 1024;
        v49 = v14;
        _os_log_impl(&dword_2164CC000, v22, OS_LOG_TYPE_ERROR, "%25s:%-5d IRBuilderCpuSimple@%p: Metadata has %d subbands. Falling back on first subband.", buf, 0x22u);
      }
    }
    if ((int)v15 >= 1)
    {
      v23 = 0;
      v24 = v41 * v10;
      v25 = 4;
      do
      {
        v26 = (_QWORD *)*((_QWORD *)a2 + 1);
        v27 = (unsigned __int32 *)(v26[1] + v25);
        v28 = *(float *)(v26[7] + 4 * v23);
        v20.n128_u32[0] = *v27;
        v21.n128_u32[0] = v27[1];
        v29 = *(float *)a2;
        v30 = v26[13];
        v31 = *(_QWORD *)(v30 + 8);
        v32 = *(unsigned __int8 *)(v26[18] + v23) == 0;
        v33 = (const float *)(*(uint64_t (**)(uint64_t, char *, _QWORD, __n128, __n128))(*(_QWORD *)v8 + 88))(v8, v39, *(_QWORD *)a3, v20, v21);
        v34 = vcvtas_u32_f32(v28 * v29);
        *(_DWORD *)buf = 0;
        v35 = *(float *)(v30 + 4 * v31 * v23 + 16);
        if (!v32)
          v35 = -v35;
        *(float *)buf = v35;
        vDSP_vsma(v33, 1, (const float *)buf, &a4[v41 * v34], 1, &a4[v41 * v34], 1, v24);
        ++v23;
        v25 += 12;
      }
      while (v15 != v23);
    }
  }
  else
  {
    v36 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v19) + 272));
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v43 = "IRBuilderCpuSimple.mm";
      v44 = 1024;
      v45 = 83;
      v46 = 2048;
      v47 = this;
      v48 = 1024;
      v49 = 0;
      _os_log_impl(&dword_2164CC000, v36, OS_LOG_TYPE_ERROR, "%25s:%-5d IRBuilderCpuSimple@%p: Metadata has %d subbands. Clearing the output.", buf, 0x22u);
    }
  }
}

void sub_2165E9C9C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::IR::Metadata::Metadata(uint64_t a1, uint64_t a2, Phase::Controller::Spatializer *this, float a4)
{
  _QWORD *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;

  *(float *)a1 = a4;
  *(_QWORD *)(a1 + 8) = a2;
  *(_OWORD *)(a1 + 16) = 0u;
  v5 = (_QWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)(a1 + 64) = this;
  Phase::Controller::Spatializer::AcquireFilters(this, (uint64_t)&v16);
  std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100](v5, &v16);
  std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(a1 + 32), &v18);
  std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(a1 + 48), &v20);
  v6 = v21;
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v9 = v19;
  if (v19)
  {
    v10 = (unint64_t *)&v19->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = v17;
  if (v17)
  {
    v13 = (unint64_t *)&v17->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  return a1;
}

void sub_2165E9DF0(_Unwind_Exception *a1)
{
  Phase::Controller::SpatializerFilterHandle *v1;

  Phase::Controller::SpatializerFilterHandle::~SpatializerFilterHandle(v1);
  _Unwind_Resume(a1);
}

void Phase::Controller::IR::Metadata::~Metadata(Phase::Controller::IR::Metadata *this)
{
  char *v2;

  v2 = (char *)this + 16;
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)this + 48);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)this + 32);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)v2);
}

unsigned int Phase::Controller::IR::GetMaxDelayInSamples(Phase::Controller::IR *this, const Phase::Controller::IR::Metadata *a2)
{
  uint64_t v2;
  float *v3;
  uint64_t *v4;
  uint64_t v5;
  float v7;
  Phase::Logger *InstancePtr;
  float *v9;
  unint64_t v10;
  float *v11;
  float v12;
  uint64_t v13;
  float *v14;
  float v15;
  float v16;
  float v17;
  NSObject *v18;
  unint64_t v20;
  float *v21;
  float v22;
  uint64_t v23;
  float *v24;
  float v25;
  float v26;
  int v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  double v32;
  __int16 v33;
  double v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 1);
  if (!v2)
    return 0;
  if (*(_DWORD *)v2 != 3)
    return 0;
  v3 = *(float **)(v2 + 56);
  if (!v3)
    return 0;
  v4 = *(uint64_t **)(v2 + 104);
  if (!v4)
    return 0;
  v5 = *v4;
  if (!v5)
    return 0;
  if (*(_BYTE *)(v2 + 201))
  {
    v7 = v3[v5 - 1] * *(float *)this;
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(this);
    if ((*(_BYTE *)(*((_QWORD *)InstancePtr + 34) + 8) & 1) != 0)
    {
      v9 = *(float **)(v2 + 56);
      v10 = *(_QWORD *)(v2 + 96);
      if (v10 >= 2)
      {
        v11 = v9 + 1;
        v12 = *v9;
        v13 = 4 * v10 - 4;
        v14 = v9 + 1;
        do
        {
          v15 = *v14++;
          v16 = v15;
          if (v12 < v15)
          {
            v12 = v16;
            v9 = v11;
          }
          v11 = v14;
          v13 -= 4;
        }
        while (v13);
      }
      v17 = *v9 * *(float *)this;
      if (v17 != v7)
      {
        v18 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(InstancePtr) + 272));
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          v27 = 136315906;
          v28 = "IRBuilderMetadata.mm";
          v29 = 1024;
          v30 = 80;
          v31 = 2048;
          v32 = v7;
          v33 = 2048;
          v34 = v17;
          _os_log_impl(&dword_2164CC000, v18, OS_LOG_TYPE_ERROR, "%25s:%-5d Invalid metadata sorting flag. Read max delay %f, actual value %f.", (uint8_t *)&v27, 0x26u);
        }
      }
    }
    return vcvtas_u32_f32(v7);
  }
  else
  {
    v20 = *(_QWORD *)(v2 + 96);
    if (v20 >= 2)
    {
      v21 = v3 + 1;
      v22 = *v3;
      v23 = 4 * v20 - 4;
      v24 = v3 + 1;
      do
      {
        v25 = *v24++;
        v26 = v25;
        if (v22 < v25)
        {
          v22 = v26;
          v3 = v21;
        }
        v21 = v24;
        v23 -= 4;
      }
      while (v23);
    }
    return vcvtas_u32_f32(*v3 * *(float *)this);
  }
}

int64x2_t *Phase::DspLayer::IRBuilderStereo3BandShelving::GetNewRegistryEntry(Phase::DspLayer::IRBuilderStereo3BandShelving *this)
{
  _QWORD *v1;
  int64x2_t *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v6[2];
  char v7;
  void *v8[2];
  char v9;
  void *__p[2];
  char v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v1 = malloc_type_malloc(0xA8uLL, 0x1050040B063AAFAuLL);
  *v1 = "Low Gain dB";
  v1[1] = 0x500000000;
  *(_QWORD *)((char *)v1 + 20) = 0x100000000;
  *((_DWORD *)v1 + 7) = 3;
  v1[4] = 0xC05E000000000000;
  v1[5] = 0;
  v1[6] = 0;
  v1[7] = "Mid Gain dB";
  v1[8] = 0x500000001;
  *(_QWORD *)((char *)v1 + 76) = 0x100000000;
  *((_DWORD *)v1 + 21) = 3;
  v1[11] = 0xC05E000000000000;
  v1[12] = 0;
  v1[13] = 0;
  v1[14] = "High Gain dB";
  v1[15] = 0x500000002;
  *(_QWORD *)((char *)v1 + 132) = 0x100000000;
  *((_DWORD *)v1 + 35) = 3;
  v1[19] = 0;
  v1[20] = 0;
  v1[18] = 0xC05E000000000000;
  v2 = (int64x2_t *)operator new();
  v12[0] = &off_24D57E148;
  v13 = v12;
  Phase::Controller::VoicePoolEntry::VoicePoolEntry((uint64_t)v2, "IRBuilderStereo3BandShelving", 3, (uint64_t)v1, (uint64_t)v12);
  v3 = v13;
  if (v13 == v12)
  {
    v4 = 4;
    v3 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  std::string::basic_string[abi:ne180100]<0>(__p, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2->i64, (__int128 *)__p);
  if (v11 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(v8, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2->i64, (__int128 *)v8);
  if (v9 < 0)
    operator delete(v8[0]);
  std::string::basic_string[abi:ne180100]<0>(v6, "buffer0");
  Phase::Controller::VoicePoolEntry::AddBuffer(v2, 0, (uint64_t)v6, 3, 1);
  if (v7 < 0)
    operator delete(v6[0]);
  return v2;
}

void sub_2165EA21C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Phase::DspLayer::IRBuilderStereo3BandShelving::~IRBuilderStereo3BandShelving(Phase::DspLayer::IRBuilderStereo3BandShelving *this)
{
  Phase::DspLayer::VoicePool::~VoicePool(this);
  JUMPOUT(0x2199F9D70);
}

void `anonymous namespace'::IRBuilderStereo3BandShelvingSlice::~IRBuilderStereo3BandShelvingSlice(_anonymous_namespace_::IRBuilderStereo3BandShelvingSlice *this)
{
  JUMPOUT(0x2199F9D70);
}

double `anonymous namespace'::IRBuilderStereo3BandShelvingSlice::Reset(_OWORD *a1)
{
  double result;

  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[32] = 0u;
  a1[33] = 0u;
  a1[34] = 0u;
  a1[35] = 0u;
  a1[36] = 0u;
  a1[37] = 0u;
  a1[38] = 0u;
  a1[39] = 0u;
  a1[40] = 0u;
  a1[41] = 0u;
  a1[42] = 0u;
  (*(void (**)(_OWORD *))(*(_QWORD *)a1 + 48))(a1);
  result = 0.0;
  a1[43] = 0u;
  a1[44] = 0u;
  return result;
}

uint64_t `anonymous namespace'::IRBuilderStereo3BandShelvingSlice::Reset(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  _DWORD *v7;
  uint64_t v8;
  uint64_t result;

  v7 = (_DWORD *)(a1 + 4 * a3);
  v7[4] = 0;
  v7[8] = 0;
  v7[12] = 0;
  *(_DWORD *)(a1 + 432 + 4 * a3) = 0;
  v8 = 4 * a3 + 16;
  *(_DWORD *)(a1 + 432 + v8) = 0;
  *(_DWORD *)(a1 + 464 + 4 * a3) = 0;
  v7[16] = 0;
  *(_DWORD *)(a1 + 464 + v8) = 0;
  *(_DWORD *)(a1 + 496 + 4 * a3) = 0;
  v7[20] = 0;
  *(_DWORD *)(a1 + 496 + v8) = 0;
  *(_DWORD *)(a1 + 528 + 4 * a3) = 0;
  *(_DWORD *)(a1 + 528 + v8) = 0;
  *(_QWORD *)(a1 + 96 + 8 * a3) = 0;
  *(_DWORD *)(a1 + 96 + 4 * a3 + 32) = 0;
  *(_DWORD *)(a1 + 560 + 4 * a3) = 0;
  *(_DWORD *)(a1 + 560 + v8) = 0;
  v7[104] = 0;
  *(_DWORD *)(a1 + 592 + 4 * a3) = 0;
  *(_DWORD *)(a1 + 592 + v8) = 0;
  *(_DWORD *)(a1 + 624 + 4 * a3) = 0;
  *(_DWORD *)(a1 + 624 + v8) = 0;
  *(_DWORD *)(a1 + 656 + 4 * a3) = 0;
  *(_DWORD *)(a1 + 656 + v8) = 0;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  *(_QWORD *)(a1 + 8 * a3 + 688) = a4;
  return result;
}

uint64_t `anonymous namespace'::IRBuilderStereo3BandShelvingSlice::GetParameter(_anonymous_namespace_::IRBuilderStereo3BandShelvingSlice *this, unsigned int a2)
{
  if (a2 > 2)
    return 9;
  else
    return 0;
}

uint64_t `anonymous namespace'::IRBuilderStereo3BandShelvingSlice::SetParameter(_anonymous_namespace_::IRBuilderStereo3BandShelvingSlice *this, int a2, int a3, double a4)
{
  uint64_t result;
  float v6;
  float v7;
  float v8;

  if (a2 == 2)
  {
    result = 0;
    v7 = a4;
    *((float *)this + a3 + 12) = v7;
  }
  else if (a2 == 1)
  {
    result = 0;
    v8 = a4;
    *((float *)this + a3 + 8) = v8;
  }
  else if (a2)
  {
    return 9;
  }
  else
  {
    result = 0;
    v6 = a4;
    *((float *)this + a3 + 4) = v6;
  }
  return result;
}

float32x4_t `anonymous namespace'::IRBuilderStereo3BandShelvingSlice::UpdateParameters(uint64_t a1, int32x2_t *a2)
{
  __int128 v4;
  int32x4_t v5;
  double v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int32x2_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  __int128 v25;
  __int128 v26;
  float32x4_t v27;
  float32x4_t result;
  float32x4_t v29;
  simd_float4 v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  simd_float4 v36;
  float32x4_t v37;
  simd_float4 v38;
  float32x4_t v39;
  float32x4_t v40;
  simd_float4 v41;
  float32x4_t v42;
  simd_float4 v43;
  float32x4_t v44;
  simd_float4 x;
  simd_float4 xa;
  simd_float4 v47;
  int32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;

  v4 = *(_OWORD *)(a1 + 128);
  *(_OWORD *)(a1 + 384) = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(a1 + 400) = v4;
  *(_OWORD *)(a1 + 368) = *(_OWORD *)(a1 + 96);
  v5.i64[0] = -1;
  v5.i64[1] = -1;
  v48 = vaddq_s32(*(int32x4_t *)(a1 + 400), v5);
  v51 = *(float32x4_t *)(a1 + 32);
  v53 = (float32x4_t)vdupq_n_s32(0x3D4CCCCDu);
  v47 = _simd_exp10_f4((simd_float4)vmulq_f32(v51, v53));
  v56 = vsubq_f32(*(float32x4_t *)(a1 + 48), v51);
  v37 = (float32x4_t)vdupq_n_s32(0x3CCCCCCDu);
  v43 = _simd_exp10_f4((simd_float4)vmulq_f32(v56, v37));
  __asm { FMOV            V1.4S, #1.0 }
  v59 = _Q1;
  v49 = vaddq_f32((float32x4_t)v43, _Q1);
  __asm { FMOV            V1.4S, #-1.0 }
  v35 = _Q1;
  v54 = vaddq_f32((float32x4_t)v43, _Q1);
  v12 = *(double *)a2;
  *(float *)&v12 = *(double *)a2->i32;
  *(float *)&v12 = 31416.0 / *(float *)&v12;
  x = (simd_float4)vdupq_lane_s32(*(int32x2_t *)&v12, 0);
  v41 = _simd_cos_f4(x);
  v32 = vmulq_f32(v54, (float32x4_t)v41);
  v39 = vaddq_f32(v49, v32);
  v13 = (float32x4_t)_simd_exp10_f4((simd_float4)vmulq_f32(v56, v53));
  v57 = vmulq_f32(v54, vnegq_f32(v54));
  v34 = (float32x4_t)vdupq_n_s32(0x3F9837F0u);
  v14 = vmulq_f32((float32x4_t)_simd_sin_f4(x), vmlaq_f32(v57, v34, vsqrtq_f32(vaddq_f32(v13, v59))));
  v15 = vsubq_f32(v49, v32);
  v16 = vdivq_f32(v59, vaddq_f32(v15, v14));
  xa = (simd_float4)vmulq_f32(vmulq_f32((float32x4_t)v43, vaddq_f32(v39, v14)), v16);
  v17 = vmulq_f32(v49, (float32x4_t)v41);
  v18.i64[0] = 0xC0000000C0000000;
  v18.i64[1] = 0xC0000000C0000000;
  v50 = vmulq_f32(vmulq_f32(vmulq_f32((float32x4_t)v43, v18), vaddq_f32(v54, v17)), v16);
  v19 = vsubq_f32(v54, v17);
  v42 = vmulq_f32(vaddq_f32(v19, v19), v16);
  v44 = vmulq_f32(vmulq_f32((float32x4_t)v43, vsubq_f32(v39, v14)), v16);
  v40 = vmulq_f32(vsubq_f32(v15, v14), v16);
  v33 = vsubq_f32(*(float32x4_t *)(a1 + 16), v51);
  v38 = _simd_exp10_f4((simd_float4)vmulq_f32(v33, v37));
  v52 = vaddq_f32((float32x4_t)v38, v59);
  v55 = vaddq_f32((float32x4_t)v38, v35);
  v20 = *a2;
  *(float *)v20.i32 = *(double *)a2->i32;
  *(float *)v20.i32 = 3141.6 / *(float *)v20.i32;
  v30 = (simd_float4)vdupq_lane_s32(v20, 0);
  v36 = _simd_cos_f4(v30);
  v29 = vmulq_f32(v55, (float32x4_t)v36);
  v31 = vsubq_f32(v52, v29);
  v58 = vmlaq_f32(v57, v34, vsqrtq_f32(vaddq_f32((float32x4_t)_simd_exp10_f4((simd_float4)vmulq_f32(v33, v53)), v59)));
  v21 = vmulq_f32((float32x4_t)_simd_sin_f4(v30), v58);
  v22 = vaddq_f32(v52, v29);
  v23 = vdivq_f32(v59, vaddq_f32(v22, v21));
  v24 = vmulq_f32(v52, (float32x4_t)v36);
  v25 = *(_OWORD *)(a1 + 64);
  v26 = *(_OWORD *)(a1 + 80);
  v27.i64[0] = 0xC0000000C0000000;
  v27.i64[1] = 0xC0000000C0000000;
  *(int32x4_t *)(a1 + 144) = v48;
  *(simd_float4 *)(a1 + 160) = v47;
  *(simd_float4 *)(a1 + 176) = xa;
  *(float32x4_t *)(a1 + 192) = v50;
  *(float32x4_t *)(a1 + 208) = v44;
  *(float32x4_t *)(a1 + 224) = v42;
  *(float32x4_t *)(a1 + 240) = v40;
  *(float32x4_t *)(a1 + 256) = vmulq_f32(vmulq_f32((float32x4_t)v38, vaddq_f32(v31, v21)), v23);
  *(float32x4_t *)(a1 + 272) = vmulq_f32(vmulq_f32(vaddq_f32((float32x4_t)v38, (float32x4_t)v38), vsubq_f32(v55, v24)), v23);
  *(float32x4_t *)(a1 + 288) = vmulq_f32(vmulq_f32((float32x4_t)v38, vsubq_f32(v31, v21)), v23);
  result = vmulq_f32(vsubq_f32(v22, v21), v23);
  *(float32x4_t *)(a1 + 304) = vmulq_f32(vmulq_f32(vaddq_f32(v55, v24), v27), v23);
  *(float32x4_t *)(a1 + 320) = result;
  *(_OWORD *)(a1 + 336) = v25;
  *(_OWORD *)(a1 + 352) = v26;
  return result;
}

float `anonymous namespace'::IRBuilderStereo3BandShelvingSlice::UpdateParameters(uint64_t a1, double *a2, int a3)
{
  int v4;
  int v5;
  uint64_t v6;
  float v7;
  float v8;
  float v9;
  float v10;
  __float2 v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  __float2 v19;
  float v20;
  float v21;
  float v22;
  float v23;
  int v24;
  int v25;
  float result;
  double v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;

  *(_QWORD *)(a1 + 368 + 8 * a3) = *(_QWORD *)(a1 + 96 + 8 * a3);
  v4 = *(_DWORD *)(a1 + 96 + 4 * a3 + 32);
  *(_DWORD *)(a1 + 368 + 4 * a3 + 32) = v4;
  v5 = v4 - 1;
  v6 = a1 + 4 * a3;
  v28 = *(float *)(v6 + 32);
  v34 = __exp10f(v28 * 0.05);
  v7 = *(float *)(v6 + 48) - v28;
  v8 = __exp10f(v7 * 0.025);
  v9 = v8 + -1.0;
  v27 = *a2;
  v10 = 31415.9258 / *a2;
  v11 = __sincosf_stret(v10);
  v12 = (float)(v8 + -1.0) * v11.__cosval;
  v13 = (float)(v8 + 1.0) + v12;
  v14 = v11.__sinval * (float)((float)(sqrtf(__exp10f(v7 * 0.05) + 1.0) * 1.1892) - (float)(v9 * v9));
  v15 = 1.0 / (float)((float)((float)(v8 + 1.0) - v12) + v14);
  v32 = (float)((float)(v8 * -2.0) * (float)((float)(v8 + -1.0) + (float)((float)(v8 + 1.0) * v11.__cosval))) * v15;
  v33 = (float)(v8 * (float)(v13 + v14)) * v15;
  v30 = (float)((float)(v9 - (float)((float)(v8 + 1.0) * v11.__cosval))
              + (float)(v9 - (float)((float)(v8 + 1.0) * v11.__cosval)))
      * v15;
  v31 = (float)(v8 * (float)(v13 - v14)) * v15;
  v29 = (float)((float)((float)(v8 + 1.0) - v12) - v14) * v15;
  v16 = *(float *)(v6 + 16) - v28;
  v17 = __exp10f(v16 * 0.025);
  v18 = 3141.59277 / v27;
  v19 = __sincosf_stret(v18);
  v20 = v19.__cosval * (float)(v17 + -1.0);
  v21 = (float)(v17 + 1.0) - v20;
  v22 = v19.__sinval * (float)((float)(sqrtf(__exp10f(v16 * 0.05) + 1.0) * 1.1892) - (float)(v9 * v9));
  v23 = 1.0 / (float)((float)((float)(v17 + 1.0) + v20) + v22);
  v24 = *(_DWORD *)(v6 + 64);
  v25 = *(_DWORD *)(v6 + 80);
  *(_DWORD *)(v6 + 144) = v5;
  *(float *)(v6 + 160) = v34;
  *(float *)(v6 + 176) = v33;
  *(float *)(v6 + 192) = v32;
  *(float *)(v6 + 208) = v31;
  *(float *)(v6 + 224) = v30;
  *(float *)(v6 + 240) = v29;
  *(float *)(v6 + 256) = (float)(v17 * (float)(v21 + v22)) * v23;
  *(float *)(v6 + 272) = (float)((float)(v17 + v17)
                               * (float)((float)(v17 + -1.0) - (float)(v19.__cosval * (float)(v17 + 1.0))))
                       * v23;
  *(float *)(v6 + 288) = (float)(v17 * (float)(v21 - v22)) * v23;
  *(float *)(v6 + 304) = (float)((float)((float)(v17 + -1.0) + (float)(v19.__cosval * (float)(v17 + 1.0))) * -2.0) * v23;
  result = (float)((float)((float)(v17 + 1.0) + v20) - v22) * v23;
  *(float *)(v6 + 320) = result;
  *(_DWORD *)(v6 + 336) = v24;
  *(_DWORD *)(v6 + 352) = v25;
  return result;
}

__n128 `anonymous namespace'::IRBuilderStereo3BandShelvingSlice::Run(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float32x4_t v4;
  int32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int v17;
  unint64_t v18;
  int32x4_t v19;
  int32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int32x4_t v27;
  int32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  int8x16_t v37;
  int32x4_t v38;
  int32x4_t v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __n128 result;

  v5 = *(int32x4_t *)(a1 + 144);
  v4 = *(float32x4_t *)(a1 + 160);
  v6 = *(float32x4_t *)(a1 + 176);
  v7 = *(float32x4_t *)(a1 + 192);
  v8 = *(float32x4_t *)(a1 + 208);
  v9 = *(float32x4_t *)(a1 + 224);
  v11 = *(float32x4_t *)(a1 + 240);
  v10 = *(float32x4_t *)(a1 + 256);
  v13 = *(float32x4_t *)(a1 + 272);
  v12 = *(float32x4_t *)(a1 + 288);
  v14 = 0uLL;
  v16 = *(float32x4_t *)(a1 + 304);
  v15 = *(float32x4_t *)(a1 + 320);
  HIDWORD(v18) = a4 - 1;
  LODWORD(v18) = a4 - 1;
  v17 = v18 >> 1;
  v19 = *(int32x4_t *)(a1 + 416);
  v20 = vminq_s32(vmaxq_s32(vminq_s32(v19, v5), (int32x4_t)0), v5);
  v21 = 0uLL;
  switch(v17)
  {
    case 0:
      v21.i32[0] = *(_DWORD *)(*(_QWORD *)(a1 + 368) + 4 * v20.i32[0]);
      break;
    case 1:
      v21.i32[0] = *(_DWORD *)(*(_QWORD *)(a1 + 368) + 4 * v20.i32[0]);
      v21.i32[1] = *(_DWORD *)(*(_QWORD *)(a1 + 376) + 4 * v20.i32[1]);
      break;
    case 3:
      v21.i32[0] = *(_DWORD *)(*(_QWORD *)(a1 + 368) + 4 * v20.i32[0]);
      v21.i32[1] = *(_DWORD *)(*(_QWORD *)(a1 + 376) + 4 * v20.i32[1]);
      v21.i32[2] = *(_DWORD *)(*(_QWORD *)(a1 + 384) + 4 * v20.i32[2]);
      break;
    case 7:
      v21.i32[0] = *(_DWORD *)(*(_QWORD *)(a1 + 368) + 4 * v20.i32[0]);
      v21.i32[1] = *(_DWORD *)(*(_QWORD *)(a1 + 376) + 4 * v20.i32[1]);
      v21.i32[2] = *(_DWORD *)(*(_QWORD *)(a1 + 384) + 4 * v20.i32[2]);
      v21.i32[3] = *(_DWORD *)(*(_QWORD *)(a1 + 392) + 4 * v20.i32[3]);
      break;
    default:
      break;
  }
  v22 = vmulq_f32(v4, v21);
  v23 = vnegq_f32(v9);
  v24 = vmlsq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32(v7, *(float32x4_t *)(a1 + 432)), v22, v6), *(float32x4_t *)(a1 + 448), v8), *(float32x4_t *)(a1 + 464), v9);
  v25 = vnegq_f32(v11);
  v26 = vmlsq_f32(v24, *(float32x4_t *)(a1 + 480), v11);
  v27.i64[0] = 0x100000001;
  v27.i64[1] = 0x100000001;
  v28 = vminq_s32(vmaxq_s32(vminq_s32(vaddq_s32(v19, v27), v5), (int32x4_t)0), v5);
  switch(v17)
  {
    case 0:
      v14.i32[0] = *(_DWORD *)(*(_QWORD *)(a1 + 368) + 4 * v28.i32[0]);
      break;
    case 1:
      v14.i32[0] = *(_DWORD *)(*(_QWORD *)(a1 + 368) + 4 * v28.i32[0]);
      v14.i32[1] = *(_DWORD *)(*(_QWORD *)(a1 + 376) + 4 * v28.i32[1]);
      break;
    case 3:
      v14.i32[0] = *(_DWORD *)(*(_QWORD *)(a1 + 368) + 4 * v28.i32[0]);
      v14.i32[1] = *(_DWORD *)(*(_QWORD *)(a1 + 376) + 4 * v28.i32[1]);
      v14.i32[2] = *(_DWORD *)(*(_QWORD *)(a1 + 384) + 4 * v28.i32[2]);
      break;
    case 7:
      v14.i32[0] = *(_DWORD *)(*(_QWORD *)(a1 + 368) + 4 * v28.i32[0]);
      v14.i32[1] = *(_DWORD *)(*(_QWORD *)(a1 + 376) + 4 * v28.i32[1]);
      v14.i32[2] = *(_DWORD *)(*(_QWORD *)(a1 + 384) + 4 * v28.i32[2]);
      v14.i32[3] = *(_DWORD *)(*(_QWORD *)(a1 + 392) + 4 * v28.i32[3]);
      break;
    default:
      break;
  }
  v29 = vmulq_f32(v4, v14);
  v30 = vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32(v7, *(float32x4_t *)(a1 + 496)), v29, v6), *(float32x4_t *)(a1 + 512), v8), *(float32x4_t *)(a1 + 528), v23), *(float32x4_t *)(a1 + 544), v25);
  v31 = vmlsq_f32(vmlsq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32(v13, *(float32x4_t *)(a1 + 560)), v26, v10), *(float32x4_t *)(a1 + 576), v12), *(float32x4_t *)(a1 + 592), v16), *(float32x4_t *)(a1 + 608), v15);
  v32 = vmlaq_f32(vmlaq_f32(vmulq_f32(v13, *(float32x4_t *)(a1 + 624)), v30, v10), *(float32x4_t *)(a1 + 640), v12);
  v33 = *(float32x4_t *)(a1 + 672);
  v34 = vmlsq_f32(v32, *(float32x4_t *)(a1 + 656), v16);
  v35 = vandq_s8((int8x16_t)v31, vorrq_s8((int8x16_t)vcltzq_f32(v31), (int8x16_t)vcgezq_f32(v31)));
  switch(v17)
  {
    case 0:
      goto LABEL_15;
    case 1:
      goto LABEL_14;
    case 3:
      goto LABEL_13;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(a1 + 348)) = v35.i32[3];
LABEL_13:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(a1 + 344)) = v35.i32[2];
LABEL_14:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(a1 + 340)) = v35.i32[1];
LABEL_15:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(a1 + 336)) = v35.i32[0];
      break;
    default:
      break;
  }
  v36 = vmlsq_f32(v34, v33, v15);
  v37 = vandq_s8((int8x16_t)v36, vorrq_s8((int8x16_t)vcltzq_f32(v36), (int8x16_t)vcgezq_f32(v36)));
  switch(v17)
  {
    case 0:
      goto LABEL_20;
    case 1:
      goto LABEL_19;
    case 3:
      goto LABEL_18;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(a1 + 364)) = v37.i32[3];
LABEL_18:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(a1 + 360)) = v37.i32[2];
LABEL_19:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(a1 + 356)) = v37.i32[1];
LABEL_20:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(a1 + 352)) = v37.i32[0];
      break;
    default:
      break;
  }
  v38.i64[0] = 0x200000002;
  v38.i64[1] = 0x200000002;
  v39 = vaddq_s32(v19, v38);
  v40 = *(_OWORD *)(a1 + 432);
  *(int32x4_t *)(a1 + 416) = v39;
  *(float32x4_t *)(a1 + 432) = v22;
  v41 = *(_OWORD *)(a1 + 464);
  *(_OWORD *)(a1 + 448) = v40;
  *(float32x4_t *)(a1 + 464) = v26;
  v42 = *(_OWORD *)(a1 + 496);
  *(_OWORD *)(a1 + 480) = v41;
  *(float32x4_t *)(a1 + 496) = v29;
  v43 = *(_OWORD *)(a1 + 528);
  *(_OWORD *)(a1 + 512) = v42;
  *(float32x4_t *)(a1 + 528) = v30;
  v44 = *(_OWORD *)(a1 + 560);
  *(_OWORD *)(a1 + 544) = v43;
  *(float32x4_t *)(a1 + 560) = v26;
  v45 = *(_OWORD *)(a1 + 592);
  *(_OWORD *)(a1 + 576) = v44;
  *(float32x4_t *)(a1 + 592) = v31;
  v46 = *(_OWORD *)(a1 + 624);
  *(_OWORD *)(a1 + 608) = v45;
  *(float32x4_t *)(a1 + 624) = v30;
  result = *(__n128 *)(a1 + 656);
  *(float32x4_t *)(a1 + 656) = v36;
  *(__n128 *)(a1 + 672) = result;
  *(_OWORD *)(a1 + 640) = v46;
  return result;
}

float `anonymous namespace'::IRBuilderStereo3BandShelvingSlice::CopyVoiceState(_anonymous_namespace_::IRBuilderStereo3BandShelvingSlice *this, Phase::DspLayer::VoicePoolSlice *a2, unsigned int a3, unsigned int a4)
{
  _DWORD *v4;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  float result;

  v4 = (_DWORD *)((char *)a2 + 4 * (int)a3);
  v5 = (_DWORD *)((char *)this + 4 * (int)a4);
  v5[4] = v4[4];
  v5[8] = v4[8];
  v5[12] = v4[12];
  v5[16] = v4[16];
  v5[20] = v4[20];
  *((_QWORD *)this + (int)a4 + 12) = *((_QWORD *)a2 + (int)a3 + 12);
  *((_DWORD *)this + (int)a4 + 32) = *((_DWORD *)a2 + (int)a3 + 32);
  v5[36] = v4[36];
  v5[40] = v4[40];
  v5[44] = v4[44];
  v5[48] = v4[48];
  v5[52] = v4[52];
  v5[56] = v4[56];
  v5[60] = v4[60];
  v5[64] = v4[64];
  v5[68] = v4[68];
  v5[72] = v4[72];
  v5[76] = v4[76];
  v5[80] = v4[80];
  v5[84] = v4[84];
  LODWORD(v4) = v4[88];
  *((_QWORD *)this + (int)a4 + 46) = *((_QWORD *)a2 + (int)a3 + 46);
  v5[88] = (_DWORD)v4;
  *((_DWORD *)this + (int)a4 + 100) = *((_DWORD *)a2 + (int)a3 + 100);
  if (a3 >= 4)
    __assert_rtn("Copy", "DelaylineLinear.hpp", 507, "fromLane >= 0 && fromLane < PHASE_SIMD_WIDTH");
  if (a4 >= 4)
    __assert_rtn("Copy", "DelaylineLinear.hpp", 508, "toLane >= 0 && toLane < PHASE_SIMD_WIDTH");
  *((_DWORD *)this + a4 + 104) = *((_DWORD *)a2 + a3 + 104);
  *((_DWORD *)this + a4 + 108) = *((_DWORD *)a2 + a3 + 108);
  v6 = 4 * a3 + 16;
  v7 = 4 * a4 + 16;
  *(_DWORD *)((char *)this + v7 + 432) = *(_DWORD *)((char *)a2 + v6 + 432);
  *((_DWORD *)this + a4 + 116) = *((_DWORD *)a2 + a3 + 116);
  *(_DWORD *)((char *)this + v7 + 464) = *(_DWORD *)((char *)a2 + v6 + 464);
  *((_DWORD *)this + a4 + 124) = *((_DWORD *)a2 + a3 + 124);
  *(_DWORD *)((char *)this + v7 + 496) = *(_DWORD *)((char *)a2 + v6 + 496);
  *((_DWORD *)this + a4 + 132) = *((_DWORD *)a2 + a3 + 132);
  *(_DWORD *)((char *)this + v7 + 528) = *(_DWORD *)((char *)a2 + v6 + 528);
  *((_DWORD *)this + a4 + 140) = *((_DWORD *)a2 + a3 + 140);
  *(_DWORD *)((char *)this + v7 + 560) = *(_DWORD *)((char *)a2 + v6 + 560);
  *((_DWORD *)this + a4 + 148) = *((_DWORD *)a2 + a3 + 148);
  *(_DWORD *)((char *)this + v7 + 592) = *(_DWORD *)((char *)a2 + v6 + 592);
  *((_DWORD *)this + a4 + 156) = *((_DWORD *)a2 + a3 + 156);
  *(_DWORD *)((char *)this + v7 + 624) = *(_DWORD *)((char *)a2 + v6 + 624);
  *((_DWORD *)this + a4 + 164) = *((_DWORD *)a2 + a3 + 164);
  result = *(float *)((char *)a2 + v6 + 656);
  *(float *)((char *)this + v7 + 656) = result;
  *((_QWORD *)this + (int)a4 + 86) = *((_QWORD *)a2 + (int)a3 + 86);
  return result;
}

uint64_t `anonymous namespace'::IRBuilderStereo3BandShelvingSlice::GetOutput(_anonymous_namespace_::IRBuilderStereo3BandShelvingSlice *this, int a2, int a3)
{
  char *v3;

  if (a2 == 1)
  {
    v3 = (char *)this + 4 * a3 + 80;
    return (unint64_t)*(unsigned int *)v3 << 32;
  }
  if (!a2)
  {
    v3 = (char *)this + 4 * a3 + 64;
    return (unint64_t)*(unsigned int *)v3 << 32;
  }
  return 0xFFFFFFFF00000008;
}

uint64_t `anonymous namespace'::IRBuilderStereo3BandShelvingSlice::SetOutput(_anonymous_namespace_::IRBuilderStereo3BandShelvingSlice *this, int a2, int a3, int a4)
{
  char *v4;
  uint64_t result;

  if (a2 == 1)
  {
    v4 = (char *)this + 4 * a3 + 80;
    goto LABEL_5;
  }
  if (!a2)
  {
    v4 = (char *)this + 4 * a3 + 64;
LABEL_5:
    result = 0;
    *(_DWORD *)v4 = a4;
    return result;
  }
  return 8;
}

uint64_t `anonymous namespace'::IRBuilderStereo3BandShelvingSlice::GetBuffer@<X0>(uint64_t this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v4;
  int v5;
  int v6;

  if (a2)
  {
    v4 = 0;
    v5 = -1;
    v6 = 10;
  }
  else
  {
    v6 = 0;
    v4 = *(_QWORD *)(this + 96 + 8 * a3);
    v5 = *(_DWORD *)(this + 96 + 4 * a3 + 32);
  }
  *(_DWORD *)a4 = v6;
  *(_QWORD *)(a4 + 8) = v4;
  *(_DWORD *)(a4 + 16) = v5;
  return this;
}

uint64_t `anonymous namespace'::IRBuilderStereo3BandShelvingSlice::SetBuffer(_anonymous_namespace_::IRBuilderStereo3BandShelvingSlice *this, int a2, int a3, void *a4, int a5)
{
  uint64_t result;

  if (a2)
    return 10;
  result = 0;
  this = (_anonymous_namespace_::IRBuilderStereo3BandShelvingSlice *)((char *)this + 96);
  *((_QWORD *)this + a3) = a4;
  *((_DWORD *)this + a3 + 8) = a5;
  return result;
}

void std::__function::__func<Phase::DspLayer::IRBuilderStereo3BandShelving::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::IRBuilderStereo3BandShelving::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<Phase::DspLayer::IRBuilderStereo3BandShelving::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::IRBuilderStereo3BandShelving::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57E148;
  return result;
}

void std::__function::__func<Phase::DspLayer::IRBuilderStereo3BandShelving::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::IRBuilderStereo3BandShelving::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57E148;
}

uint64_t std::__function::__func<Phase::DspLayer::IRBuilderStereo3BandShelving::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::IRBuilderStereo3BandShelving::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::operator()(uint64_t a1, Phase::DspLayer::VoiceEngine **a2, int *a3)
{
  Phase::DspLayer::VoiceEngine *v3;
  int v4;
  uint64_t v5;
  int v6;
  int32x2_t *v7;
  uint64_t v8;

  v3 = *a2;
  v4 = *a3;
  v5 = operator new();
  Phase::DspLayer::VoicePool::VoicePool((Phase::DspLayer::VoicePool *)v5, "IRBuilderStereo3BandShelving", v3, v4, 720);
  *(_QWORD *)v5 = &off_24D57E050;
  if (*(int *)(v5 + 40) >= 1)
  {
    v6 = 0;
    do
    {
      v7 = *(int32x2_t **)(v5 + 32);
      v8 = *(_QWORD *)(v5 + 24) + *(int *)(v5 + 16) * (uint64_t)v6;
      *(_QWORD *)v8 = &off_24D57E070;
      *(_QWORD *)(v8 + 8) = 0;
      *(_OWORD *)(v8 + 16) = 0u;
      *(_OWORD *)(v8 + 32) = 0u;
      *(_OWORD *)(v8 + 48) = 0u;
      *(_OWORD *)(v8 + 64) = 0u;
      *(_OWORD *)(v8 + 80) = 0u;
      *(_OWORD *)(v8 + 96) = 0u;
      *(_OWORD *)(v8 + 112) = 0u;
      *(_OWORD *)(v8 + 128) = 0u;
      *(_OWORD *)(v8 + 416) = 0u;
      *(_OWORD *)(v8 + 432) = 0u;
      *(_OWORD *)(v8 + 448) = 0u;
      *(_OWORD *)(v8 + 464) = 0u;
      *(_OWORD *)(v8 + 480) = 0u;
      *(_OWORD *)(v8 + 496) = 0u;
      *(_OWORD *)(v8 + 512) = 0u;
      *(_OWORD *)(v8 + 528) = 0u;
      *(_OWORD *)(v8 + 544) = 0u;
      *(_OWORD *)(v8 + 560) = 0u;
      *(_OWORD *)(v8 + 576) = 0u;
      *(_OWORD *)(v8 + 592) = 0u;
      *(_OWORD *)(v8 + 608) = 0u;
      *(_OWORD *)(v8 + 624) = 0u;
      *(_OWORD *)(v8 + 640) = 0u;
      *(_OWORD *)(v8 + 656) = 0u;
      *(_OWORD *)(v8 + 672) = 0u;
      *(_OWORD *)(v8 + 688) = 0u;
      *(_OWORD *)(v8 + 704) = 0u;
      ++v6;
    }
    while (v6 < *(_DWORD *)(v5 + 40));
  }
  return v5;
}

void sub_2165EB24C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199F9D70](v1, 0x10F1C408EBD29CELL);
  _Unwind_Resume(a1);
}

uint64_t Phase::Job::Job(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v5;

  *(_QWORD *)a1 = &off_24D57E190;
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 8), *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v5 = *a3;
    *(_QWORD *)(a1 + 24) = *((_QWORD *)a3 + 2);
    *(_OWORD *)(a1 + 8) = v5;
  }
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 72) = a1 + 80;
  *(_QWORD *)(a1 + 32) = a2;
  *(_BYTE *)(a1 + 40) = 1;
  *(_QWORD *)(a1 + 48) = a1 + 48;
  *(_QWORD *)(a1 + 56) = a1 + 48;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  MEMORY[0x2199F9B78](a1 + 96);
  *(_BYTE *)(a1 + 383) = 0;
  *(_BYTE *)(a1 + 511) = 0;
  *(_QWORD *)(a1 + 512) = 0;
  *(_QWORD *)(a1 + 520) = 0x1FFFFFFFFLL;
  *(_QWORD *)(a1 + 568) = 0;
  *(_OWORD *)(a1 + 528) = 0u;
  return a1;
}

void sub_2165EB334(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  uint64_t *v3;
  uint64_t v4;

  std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::destroy(v4, *(_QWORD **)(v1 + 80));
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear(v3);
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(a1);
}

void Phase::Job::~Job(Phase::Job *this)
{
  *(_QWORD *)this = &off_24D57E190;
  std::unique_ptr<void,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)this + 67);
  if (*((_BYTE *)this + 511))
    (**((void (***)(char *))this + 48))((char *)this + 384);
  if (*((_BYTE *)this + 383))
    (**((void (***)(char *))this + 32))((char *)this + 256);
  std::recursive_mutex::~recursive_mutex((std::recursive_mutex *)((char *)this + 96));
  std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::destroy((uint64_t)this + 72, *((_QWORD **)this + 10));
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear((uint64_t *)this + 6);
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  Phase::Job::~Job(this);
  JUMPOUT(0x2199F9D64);
}

void Phase::Job::Run(Phase::Job *this)
{
  uint64_t v2;
  unint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  NSObject *v12;
  uint64_t v13;
  char *v14;
  Phase::Logger *InstancePtr;
  NSObject *v16;
  std::runtime_error *exception;
  void *__p;
  void *v19;
  uint64_t v20;
  BOOL v21;
  unint64_t v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  unint64_t v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(*((_QWORD *)this + 4) + 32));
  v2 = *((_QWORD *)this + 4);
  v3 = *(_QWORD *)(v2 + 24);
  v19 = 0;
  v20 = 0;
  __p = 0;
  if (v3)
  {
    std::vector<void *>::__vallocate[abi:ne180100](&__p, v3);
    v4 = (char *)v19;
    bzero(v19, 8 * v3);
    v19 = &v4[8 * v3];
    v3 = (unint64_t)__p;
  }
  v5 = v2 + 8;
  v6 = *(_QWORD *)(v2 + 16);
  if (v6 == v2 + 8)
  {
    v7 = v2 + 8;
  }
  else
  {
    do
    {
      (*(void (**)(_QWORD, Phase::Job *, unint64_t))(**(_QWORD **)(v6 + 16) + 16))(*(_QWORD *)(v6 + 16), this, v3);
      v3 += 8;
      v6 = *(_QWORD *)(v6 + 8);
    }
    while (v6 != v5);
    v3 = (unint64_t)__p;
    v7 = *(_QWORD *)(v2 + 16);
  }
  if (*((_BYTE *)this + 383))
  {
    if (v7 == v5)
      goto LABEL_11;
    do
    {
      (*(void (**)(_QWORD, Phase::Job *, unint64_t))(**(_QWORD **)(v7 + 16) + 24))(*(_QWORD *)(v7 + 16), this, v3);
      v3 += 8;
      v7 = *(_QWORD *)(v7 + 8);
    }
    while (v7 != v5);
    if (*((_BYTE *)this + 383))
LABEL_11:
      (*(void (**)(char *))(*((_QWORD *)this + 32) + 16))((char *)this + 256);
    v3 = (unint64_t)__p;
    v8 = *(_QWORD *)(v2 + 16);
    if (v8 == v5)
    {
      v7 = v2 + 8;
    }
    else
    {
      do
      {
        (*(void (**)(_QWORD, Phase::Job *, unint64_t))(**(_QWORD **)(v8 + 16) + 32))(*(_QWORD *)(v8 + 16), this, v3);
        v3 += 8;
        v8 = *(_QWORD *)(v8 + 8);
      }
      while (v8 != v5);
      v3 = (unint64_t)__p;
      v7 = *(_QWORD *)(v2 + 16);
    }
  }
  if (!*((_BYTE *)this + 511))
    goto LABEL_32;
  while (v7 != v5)
  {
    (*(void (**)(_QWORD, Phase::Job *, unint64_t))(**(_QWORD **)(v7 + 16) + 40))(*(_QWORD *)(v7 + 16), this, v3);
    v3 += 8;
    v7 = *(_QWORD *)(v7 + 8);
  }
  v9 = *((_QWORD *)this + 64);
  if (v9)
  {
    v10 = **(_QWORD **)(v9 + 8);
    v22 = 0;
    v21 = 1;
    v11 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v10, 16, &v22, &v21);
    if (!v11)
    {
      InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
      Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
      v16 = **(NSObject ***)(v10 + 48);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v24 = "CommandQueue.hpp";
        v25 = 1024;
        v26 = 100;
        _os_log_impl(&dword_2164CC000, v16, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffe"
          "r is full, unable to grow.\"",
          buf,
          0x12u);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    }
    if (v21)
    {
      v12 = **(NSObject ***)(v10 + 48);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136315906;
        v24 = "CommandQueue.hpp";
        v25 = 1024;
        v26 = 89;
        v27 = 2048;
        v28 = v22;
        v29 = 2048;
        v30 = 16;
        _os_log_impl(&dword_2164CC000, v12, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
      }
    }
    *v11 = &off_24D57E1B0;
    v11[1] = this;
    Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v10, 16);
    atomic_store(0, (unsigned __int8 *)(v10 + 40));
  }
  else if (*((_BYTE *)this + 511))
  {
    (*(void (**)(char *))(*((_QWORD *)this + 48) + 16))((char *)this + 384);
  }
  v13 = *(_QWORD *)(v2 + 16);
  if (v13 != v5)
  {
    v14 = (char *)__p;
    do
    {
      (*(void (**)(_QWORD, Phase::Job *, char *))(**(_QWORD **)(v13 + 16) + 48))(*(_QWORD *)(v13 + 16), this, v14);
      v14 += 8;
      v13 = *(_QWORD *)(v13 + 8);
    }
    while (v13 != v5);
    v3 = (unint64_t)__p;
    v7 = *(_QWORD *)(v2 + 16);
LABEL_32:
    while (v7 != v5)
    {
      (*(void (**)(_QWORD, Phase::Job *, unint64_t))(**(_QWORD **)(v7 + 16) + 56))(*(_QWORD *)(v7 + 16), this, v3);
      v3 += 8;
      v7 = *(_QWORD *)(v7 + 8);
    }
  }
  std::__shared_mutex_base::unlock_shared((std::__shared_mutex_base *)(*((_QWORD *)this + 4) + 32));
  if (__p)
  {
    v19 = __p;
    operator delete(__p);
  }
}

void sub_2165EB7F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  uint64_t v11;
  void *v12;

  if (a2)
  {
    __cxa_free_exception(v12);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v11);
    __cxa_end_catch();
    JUMPOUT(0x2165EB694);
  }
  _Unwind_Resume(exception_object);
}

void std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::destroy(uint64_t a1, _QWORD *a2)
{
  std::__shared_weak_count *v4;

  if (a2)
  {
    std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::destroy(a1, *a2);
    std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::destroy(a1, a2[1]);
    v4 = (std::__shared_weak_count *)a2[5];
    if (v4)
      std::__shared_weak_count::__release_weak(v4);
    operator delete(a2);
  }
}

uint64_t *std::unique_ptr<void,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t *v2;
  uint64_t v3;

  std::unique_ptr<void,std::function<void ()(void *)>>::reset[abi:ne180100](a1, 0);
  v2 = (uint64_t *)a1[4];
  if (v2 == a1 + 1)
  {
    v3 = 4;
    v2 = a1 + 1;
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return a1;
}

uint64_t *std::unique_ptr<void,std::function<void ()(void *)>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v4 = v2;
    v3 = result[4];
    if (!v3)
      std::__throw_bad_function_call[abi:ne180100]();
    return (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v4);
  }
  return result;
}

void Phase::LambdaFunction<Phase::Job::Run(void)::$_0,void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

uint64_t Phase::LambdaFunction<Phase::Job::Run(void)::$_0,void>::operator()(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 8);
  if (*(_BYTE *)(v1 + 511))
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v1 + 384) + 16))(v1 + 384);
  return result;
}

_OWORD *Phase::JobManager::TreeLock::TreeLock(_OWORD *a1, Phase::JobManager *a2, uint64_t *a3)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  __n128 RootJob;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v4 = (std::__shared_weak_count *)a3[1];
  v12 = *a3;
  v13 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  RootJob = Phase::JobManager::GetRootJob(a2, (uint64_t)&v12, a1);
  v8 = v13;
  if (v13)
  {
    v9 = (unint64_t *)&v13->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v8->__on_zero_shared)(v8, RootJob);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  std::recursive_mutex::lock((std::recursive_mutex *)(*(_QWORD *)a1 + 96));
  return a1;
}

__n128 Phase::JobManager::GetRootJob@<Q0>(Phase::JobManager *a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  Phase::Job *v6;
  Phase::JobManager *Dependents;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  __n128 result;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  std::__shared_weak_count *v28;

  v6 = *(Phase::Job **)a2;
  Dependents = (Phase::JobManager *)Phase::JobManager::GetDependents(a1, *(Phase::Job **)a2);
  if (!*((_QWORD *)Dependents + 2)
    || (v8 = Phase::JobManager::GetDependents(Dependents, v6),
        v9 = *(_QWORD *)v8,
        (v10 = *(std::__shared_weak_count **)(*(_QWORD *)v8 + 40)) == 0)
    || (v11 = std::__shared_weak_count::lock(v10), (v28 = v11) == 0))
  {
LABEL_21:
    result = *(__n128 *)a2;
    *a3 = *(_OWORD *)a2;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    return result;
  }
  v12 = v11;
  v13 = *(_QWORD *)(v9 + 32);
  v27 = v13;
  if (!v13)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v24 = __ldaxr(p_shared_owners);
    while (__stlxr(v24 - 1, p_shared_owners));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v12);
    }
    goto LABEL_21;
  }
  v25 = v13;
  v26 = v11;
  v14 = (unint64_t *)&v11->__shared_owners_;
  do
    v15 = __ldxr(v14);
  while (__stxr(v15 + 1, v14));
  Phase::JobManager::GetRootJob(a1, &v25);
  v17 = v26;
  if (v26)
  {
    v18 = (unint64_t *)&v26->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v28;
  if (v28)
  {
    v21 = (unint64_t *)&v28->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  return result;
}

void sub_2165EBD14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

Phase::JobManager *Phase::JobManager::JobManager(Phase::JobManager *this)
{
  Phase::Logger *v2;
  _QWORD *v3;

  *(_QWORD *)this = off_24D57E1D8;
  *((_QWORD *)this + 1) = (char *)this + 8;
  *((_QWORD *)this + 2) = (char *)this + 8;
  *((_QWORD *)this + 3) = 0;
  v2 = (Phase::Logger *)std::__shared_mutex_base::__shared_mutex_base((std::__shared_mutex_base *)((char *)this + 32));
  *((_QWORD *)this + 26) = 0;
  if (*(_BYTE *)(Phase::Logger::GetInstancePtr(v2) + 472))
  {
    v3 = (_QWORD *)operator new();
    *v3 = &off_24D57E280;
    *((_QWORD *)this + 26) = v3;
    Phase::JobManager::AddObserver((uint64_t)this, (uint64_t)v3);
  }
  return this;
}

void sub_2165EBDBC(_Unwind_Exception *a1)
{
  _QWORD *v1;

  std::__list_imp<Phase::Controller::AssetUnloader::ObjectUnloadRequest>::clear(v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::JobManager::AddObserver(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v7;
  char v8;

  v3 = (_QWORD *)a1;
  v7 = a1 + 32;
  v8 = 1;
  std::__shared_mutex_base::lock((std::__shared_mutex_base *)(a1 + 32));
  v4 = operator new(0x18uLL);
  v5 = v3[1];
  v4[1] = ++v3;
  v4[2] = a2;
  *v4 = v5;
  *(_QWORD *)(v5 + 8) = v4;
  *v3 = v4;
  ++v3[2];
  return std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v7);
}

void sub_2165EBE4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void Phase::JobManager::~JobManager(Phase::JobManager *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_24D57E1D8;
  v2 = *((_QWORD *)this + 26);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  std::condition_variable::~condition_variable((std::condition_variable *)this + 3);
  std::condition_variable::~condition_variable((std::condition_variable *)this + 2);
  std::mutex::~mutex((std::mutex *)((char *)this + 32));
  std::__list_imp<Phase::Controller::AssetUnloader::ObjectUnloadRequest>::clear((_QWORD *)this + 1);
}

uint64_t Phase::JobManager::Create(Phase::Logger *a1)
{
  uint64_t v1;
  NSObject *v3;
  std::logic_error *exception;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if ((_DWORD)a1 == 1)
  {
    v1 = operator new();
    *(_OWORD *)v1 = 0u;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_OWORD *)(v1 + 64) = 0u;
    *(_OWORD *)(v1 + 80) = 0u;
    *(_OWORD *)(v1 + 96) = 0u;
    *(_OWORD *)(v1 + 112) = 0u;
    *(_OWORD *)(v1 + 128) = 0u;
    *(_OWORD *)(v1 + 144) = 0u;
    *(_OWORD *)(v1 + 160) = 0u;
    *(_OWORD *)(v1 + 176) = 0u;
    *(_OWORD *)(v1 + 192) = 0u;
    *(_QWORD *)(v1 + 208) = 0;
    Phase::JobManager::JobManager((Phase::JobManager *)v1);
    *(_QWORD *)v1 = &off_24D57E520;
  }
  else
  {
    if ((_DWORD)a1)
    {
      v3 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(a1) + 464));
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        v5 = 136315394;
        v6 = "JobManager.mm";
        v7 = 1024;
        v8 = 93;
        _os_log_impl(&dword_2164CC000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"Invalid Backend to create JobManager instance.\"", (uint8_t *)&v5, 0x12u);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "Invalid Backend to create JobManager instance.");
    }
    v1 = operator new();
    Phase::JobManager::JobManager((Phase::JobManager *)v1);
    *(_QWORD *)v1 = &off_24D57E2F0;
    *(_DWORD *)(v1 + 216) = 0;
    *(_BYTE *)(v1 + 220) = 0;
    *(_QWORD *)(v1 + 240) = 0;
    *(_QWORD *)(v1 + 232) = 0;
    *(_QWORD *)(v1 + 224) = v1 + 232;
  }
  return v1;
}

void sub_2165EC060(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t Phase::JobManager::DestroyJob(Phase::JobManager *this, Phase::Job *a2)
{
  uint64_t v2;
  NSObject *v4;
  std::logic_error *exception;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)a2 + 11))
  {
    v2 = *(_QWORD *)(*((_QWORD *)a2 + 9) + 40);
    if (v2)
    {
      if (*(_QWORD *)(v2 + 8) != -1)
      {
        v4 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(this) + 464));
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          v6 = 136315394;
          v7 = "JobManager.mm";
          v8 = 1024;
          v9 = 123;
          _os_log_impl(&dword_2164CC000, v4, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: pInJob->mDependentJobs.begin()->expired() is false.", (uint8_t *)&v6, 0x12u);
        }
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::invalid_argument::invalid_argument[abi:ne180100](exception, "PRECONDITION: pInJob->mDependentJobs.begin()->expired() is false.");
      }
    }
  }
  return (*(uint64_t (**)(Phase::Job *))(*(_QWORD *)a2 + 8))(a2);
}

void sub_2165EC1C8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t Phase::JobManager::GetDependencies(Phase::JobManager *this, Phase::Job *a2)
{
  NSObject *v3;
  std::logic_error *exception;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (!a2)
  {
    v3 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(this) + 464));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "JobManager.mm";
      v7 = 1024;
      v8 = 131;
      _os_log_impl(&dword_2164CC000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInJob is false.", (uint8_t *)&v5, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "PRECONDITION: nullptr != pInJob is false.");
  }
  return (uint64_t)a2 + 48;
}

void sub_2165EC2D8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t Phase::JobManager::GetDependents(Phase::JobManager *this, Phase::Job *a2)
{
  NSObject *v3;
  std::logic_error *exception;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (!a2)
  {
    v3 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(this) + 464));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "JobManager.mm";
      v7 = 1024;
      v8 = 145;
      _os_log_impl(&dword_2164CC000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInJob is false.", (uint8_t *)&v5, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "PRECONDITION: nullptr != pInJob is false.");
  }
  return (uint64_t)a2 + 72;
}

void sub_2165EC3E8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t Phase::JobManager::GetExecutionState(Phase::JobManager *this, Phase::Job *a2)
{
  NSObject *v3;
  std::logic_error *exception;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (!a2)
  {
    v3 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(this) + 464));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "JobManager.mm";
      v7 = 1024;
      v8 = 181;
      _os_log_impl(&dword_2164CC000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInJob is false.", (uint8_t *)&v5, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "PRECONDITION: nullptr != pInJob is false.");
  }
  return (uint64_t)a2 + 532;
}

void sub_2165EC4F8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

unint64_t Phase::JobManager::RunJob(uint64_t a1, uint64_t *a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v19;
  std::__shared_weak_count *v20;
  uint64_t v21[2];

  v4 = (std::__shared_weak_count *)a2[1];
  v21[0] = *a2;
  v21[1] = (uint64_t)v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = Phase::JobManager::RunJobAsync(a1, v21);
  if (v4)
  {
    v8 = (unint64_t *)&v4->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  if (HIDWORD(v7) || !(_DWORD)v7)
  {
    v11 = a2[1];
    v19 = *a2;
    v20 = (std::__shared_weak_count *)v11;
    if (v11)
    {
      v12 = (unint64_t *)(v11 + 8);
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }
    v14 = (*(uint64_t (**)(uint64_t, uint64_t *, double))(*(_QWORD *)a1 + 96))(a1, &v19, 0.0);
    LODWORD(v7) = v14;
    v10 = HIDWORD(v14);
    v15 = v20;
    if (v20)
    {
      v16 = (unint64_t *)&v20->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
  else
  {
    LODWORD(v10) = 0;
  }
  return v7 | ((unint64_t)v10 << 32);
}

void sub_2165EC640(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

unint64_t Phase::JobManager::RunJobAsync(uint64_t a1, uint64_t *a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;

  v4 = (std::__shared_weak_count *)a2[1];
  v22 = *a2;
  v23 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 144))(a1, &v22);
  v8 = v23;
  if (v23)
  {
    v9 = (unint64_t *)&v23->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  if (HIDWORD(v7) || !(_DWORD)v7)
  {
    v12 = (std::__shared_weak_count *)a2[1];
    v20 = *a2;
    v21 = v12;
    if (v12)
    {
      v13 = (unint64_t *)&v12->__shared_owners_;
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    v15 = (*(uint64_t (**)(uint64_t, uint64_t *, double))(*(_QWORD *)a1 + 120))(a1, &v20, 0.0);
    LODWORD(v7) = v15;
    v11 = HIDWORD(v15);
    v16 = v21;
    if (v21)
    {
      v17 = (unint64_t *)&v21->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
  else
  {
    LODWORD(v11) = 0;
  }
  return v7 | ((unint64_t)v11 << 32);
}

void sub_2165EC798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void Phase::JobManager::ScheduleJobWithPeriod(uint64_t a1, uint64_t *a2, uint64_t a3, double a4)
{
  Phase::Logger *HasManualJobs;
  uint64_t v9;
  NSObject *v10;
  _BOOL4 v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  Phase::Logger *v22;
  Phase::Logger *v23;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  BOOL v27;
  NSObject *v28;
  _BOOL4 v29;
  uint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t *v34;
  uint64_t v35;
  NSObject *v36;
  _BOOL4 v37;
  uint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t *v42;
  uint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  double *v46;
  _QWORD *v47;
  uint64_t v48;
  unint64_t *v49;
  std::logic_error *exception;
  std::logic_error *v51;
  std::logic_error *v52;
  uint64_t v53[3];
  double *v54;
  void **v55;
  uint64_t v56;
  uint64_t v57[3];
  uint64_t v58;
  std::__shared_weak_count *v59;
  uint64_t v60[3];
  uint64_t v61[3];
  char v62;
  _BYTE v63[24];
  _BYTE *v64;
  _BYTE buf[18];
  __int16 v66;
  double v67;
  uint64_t v68;

  v68 = *MEMORY[0x24BDAC8D0];
  HasManualJobs = (Phase::Logger *)Phase::JobManager::HasManualJobs(*a2, (uint64_t)a2);
  if ((_DWORD)HasManualJobs)
  {
    v9 = *(_QWORD *)(a3 + 24);
    v10 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(HasManualJobs) + 464));
    v11 = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!v9)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "JobManager.mm";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 262;
        _os_log_impl(&dword_2164CC000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"\\\"Job graph containing at least one manual job can't be scheduled.\\\"\"", buf, 0x12u);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "\"Job graph containing at least one manual job can't be scheduled.\"");
    }
    if (v11)
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "JobManager.mm";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 262;
      _os_log_impl(&dword_2164CC000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d \"Job graph containing at least one manual job can't be scheduled.\"", buf, 0x12u);
    }
    v12 = a2[1];
    *(_QWORD *)buf = *a2;
    *(_QWORD *)&buf[8] = v12;
    if (v12)
    {
      v13 = (unint64_t *)(v12 + 8);
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    std::list<std::shared_ptr<Phase::Job>>::list(v61, buf, 1);
    v62 = 0;
    v15 = *(_QWORD *)(a3 + 24);
    if (!v15)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, char *, uint64_t *))(*(_QWORD *)v15 + 48))(v15, &v62, v61);
    std::__list_imp<std::shared_ptr<Phase::Job>>::clear(v61);
    v16 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v17 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
LABEL_57:
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
      return;
    }
    return;
  }
  if (a4 <= 0.0)
  {
    v35 = *(_QWORD *)(a3 + 24);
    v36 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(HasManualJobs) + 464));
    v37 = os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
    if (!v35)
    {
      if (v37)
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "JobManager.mm";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 268;
        v66 = 2048;
        v67 = a4;
        _os_log_impl(&dword_2164CC000, v36, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"\\\"Job graph job can't be scheduled with invalid period %f\\\"\"", buf, 0x1Cu);
      }
      v51 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](v51, "\"Job graph job can't be scheduled with invalid period %f\"");
    }
    if (v37)
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "JobManager.mm";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 268;
      v66 = 2048;
      v67 = a4;
      _os_log_impl(&dword_2164CC000, v36, OS_LOG_TYPE_ERROR, "%25s:%-5d \"Job graph job can't be scheduled with invalid period %f\"", buf, 0x1Cu);
    }
    v38 = a2[1];
    *(_QWORD *)buf = *a2;
    *(_QWORD *)&buf[8] = v38;
    if (v38)
    {
      v39 = (unint64_t *)(v38 + 8);
      do
        v40 = __ldxr(v39);
      while (__stxr(v40 + 1, v39));
    }
    std::list<std::shared_ptr<Phase::Job>>::list(v60, buf, 1);
    v62 = 0;
    v41 = *(_QWORD *)(a3 + 24);
    if (!v41)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, char *, uint64_t *))(*(_QWORD *)v41 + 48))(v41, &v62, v60);
    std::__list_imp<std::shared_ptr<Phase::Job>>::clear(v60);
    v16 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v42 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v18 = __ldaxr(v42);
      while (__stlxr(v18 - 1, v42));
      goto LABEL_57;
    }
    return;
  }
  v19 = a2[1];
  v58 = *a2;
  v59 = (std::__shared_weak_count *)v19;
  if (v19)
  {
    v20 = (unint64_t *)(v19 + 8);
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  v22 = (Phase::Logger *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 144))(a1, &v58);
  v23 = v22;
  v24 = v59;
  if (v59)
  {
    p_shared_owners = (unint64_t *)&v59->__shared_owners_;
    do
      v26 = __ldaxr(p_shared_owners);
    while (__stlxr(v26 - 1, p_shared_owners));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  if ((unint64_t)v23 >> 32 || !(_DWORD)v23)
  {
    v43 = a2[1];
    *(_QWORD *)buf = *a2;
    *(_QWORD *)&buf[8] = v43;
    if (v43)
    {
      v44 = (unint64_t *)(v43 + 8);
      do
        v45 = __ldxr(v44);
      while (__stxr(v45 + 1, v44));
    }
    std::list<std::shared_ptr<Phase::Job>>::list(v57, buf, 1);
    v54 = (double *)&v54;
    v55 = (void **)&v54;
    v56 = 0;
    v46 = (double *)operator new(0x18uLL);
    v46[2] = a4;
    *(_QWORD *)v46 = &v54;
    *((_QWORD *)v46 + 1) = &v54;
    v54 = v46;
    v55 = (void **)v46;
    v56 = 1;
    std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v63, a3);
    (*(void (**)(uint64_t, uint64_t *, double **, _BYTE *))(*(_QWORD *)a1 + 128))(a1, v57, &v54, v63);
    v47 = v64;
    if (v64 == v63)
    {
      v48 = 4;
      v47 = v63;
    }
    else
    {
      if (!v64)
      {
LABEL_54:
        std::__list_imp<Phase::Controller::AssetUnloader::ObjectUnloadRequest>::clear(&v54);
        std::__list_imp<std::shared_ptr<Phase::Job>>::clear(v57);
        v16 = *(std::__shared_weak_count **)&buf[8];
        if (!*(_QWORD *)&buf[8])
          return;
        v49 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v18 = __ldaxr(v49);
        while (__stlxr(v18 - 1, v49));
        goto LABEL_57;
      }
      v48 = 5;
    }
    (*(void (**)(void))(*v47 + 8 * v48))();
    goto LABEL_54;
  }
  v27 = *(_QWORD *)(a3 + 24) == 0;
  v28 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v22) + 464));
  v29 = os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
  if (v27)
  {
    if (v29)
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "JobManager.mm";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 280;
      v66 = 1024;
      LODWORD(v67) = (_DWORD)v23;
      _os_log_impl(&dword_2164CC000, v28, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"\\\"Job graph prepare error %i\\\"\"", buf, 0x18u);
    }
    v52 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](v52, "\"Job graph prepare error %i\"");
  }
  if (v29)
  {
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "JobManager.mm";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 280;
    v66 = 1024;
    LODWORD(v67) = (_DWORD)v23;
    _os_log_impl(&dword_2164CC000, v28, OS_LOG_TYPE_ERROR, "%25s:%-5d \"Job graph prepare error %i\"", buf, 0x18u);
  }
  v30 = a2[1];
  *(_QWORD *)buf = *a2;
  *(_QWORD *)&buf[8] = v30;
  if (v30)
  {
    v31 = (unint64_t *)(v30 + 8);
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
  }
  std::list<std::shared_ptr<Phase::Job>>::list(v53, buf, 1);
  v62 = 0;
  v33 = *(_QWORD *)(a3 + 24);
  if (!v33)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *, uint64_t *))(*(_QWORD *)v33 + 48))(v33, &v62, v53);
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear(v53);
  v16 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v34 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v18 = __ldaxr(v34);
    while (__stlxr(v18 - 1, v34));
    goto LABEL_57;
  }
}

void sub_2165ECE58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  void *v30;

  __cxa_free_exception(v30);
  _Unwind_Resume(a1);
}

uint64_t Phase::JobManager::HasManualJobs(uint64_t a1, uint64_t a2)
{
  _BOOL8 v2;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  int HasManualJobs;
  int v11;
  unint64_t *v12;
  unint64_t v13;

  if (*(_DWORD *)(a1 + 528) == 1)
    return 1;
  v4 = (_QWORD *)(a1 + 48);
  v5 = (_QWORD *)(a1 + 48);
  while (1)
  {
    v5 = (_QWORD *)v5[1];
    v2 = v5 != v4;
    if (v5 == v4)
      return v2;
    v6 = v5[2];
    v7 = (std::__shared_weak_count *)v5[3];
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }
    HasManualJobs = Phase::JobManager::HasManualJobs(v6, a2);
    v11 = HasManualJobs;
    if (!v7)
      goto LABEL_13;
    v12 = (unint64_t *)&v7->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
      if (v11)
        return v2;
    }
    else
    {
LABEL_13:
      if (HasManualJobs)
        return v2;
    }
  }
}

void sub_2165ECFE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void Phase::JobManager::ScheduleJobsWithPeriods(Phase::Logger *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  Phase::Logger *HasManualJobs;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  Phase::Logger *v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  _BOOL4 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  NSObject *v27;
  std::logic_error *v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  std::logic_error *exception;
  _QWORD v33[3];
  uint64_t v34[6];
  uint64_t v35;
  std::__shared_weak_count *v36;
  uint64_t v37[3];
  _BYTE v38[24];
  Phase::Logger *v39;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  uint64_t v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a2 + 16) != *(_QWORD *)(a3 + 16))
  {
    v20 = *(_QWORD *)(a4 + 24);
    v21 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(a1) + 464));
    v22 = os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
    if (!v20)
    {
      if (v22)
      {
        v30 = *(_QWORD *)(a2 + 16);
        v31 = *(_QWORD *)(a3 + 16);
        *(_DWORD *)buf = 136315906;
        v41 = "JobManager.mm";
        v42 = 1024;
        v43 = 303;
        v44 = 2048;
        v45 = v30;
        v46 = 2048;
        v47 = v31;
        _os_log_impl(&dword_2164CC000, v21, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"\\\"Argument list size mismatch %lu jobs / %lu periods\\\"\"", buf, 0x26u);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "\"Argument list size mismatch %lu jobs / %lu periods\"");
    }
    if (v22)
    {
      v23 = *(_QWORD *)(a2 + 16);
      v24 = *(_QWORD *)(a3 + 16);
      *(_DWORD *)buf = 136315906;
      v41 = "JobManager.mm";
      v42 = 1024;
      v43 = 303;
      v44 = 2048;
      v45 = v23;
      v46 = 2048;
      v47 = v24;
      _os_log_impl(&dword_2164CC000, v21, OS_LOG_TYPE_ERROR, "%25s:%-5d \"Argument list size mismatch %lu jobs / %lu periods\"", buf, 0x26u);
    }
    std::list<std::shared_ptr<Phase::Job>>::list(v37, a2);
    buf[0] = 0;
    v25 = *(_QWORD *)(a4 + 24);
    if (!v25)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, uint8_t *, uint64_t *))(*(_QWORD *)v25 + 48))(v25, buf, v37);
    v26 = v37;
    goto LABEL_28;
  }
  v8 = *(_QWORD **)(a2 + 8);
  if (v8 == (_QWORD *)a2)
    goto LABEL_17;
  v9 = a3;
  do
  {
    v9 = *(_QWORD *)(v9 + 8);
    HasManualJobs = (Phase::Logger *)Phase::JobManager::HasManualJobs(v8[2], a2);
    if ((_DWORD)HasManualJobs)
    {
      v27 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(HasManualJobs) + 464));
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v41 = "JobManager.mm";
        v42 = 1024;
        v43 = 316;
        _os_log_impl(&dword_2164CC000, v27, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: not HasManualJobs(jobIt->get()) is false.", buf, 0x12u);
      }
      v28 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(v28, "PRECONDITION: not HasManualJobs(jobIt->get()) is false.");
LABEL_36:
      v28->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8D0] + 16);
    }
    if (*(double *)(v9 + 16) <= 0.0)
    {
      v29 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(HasManualJobs) + 464));
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v41 = "JobManager.mm";
        v42 = 1024;
        v43 = 319;
        _os_log_impl(&dword_2164CC000, v29, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: *periodIt > 0. is false.", buf, 0x12u);
      }
      v28 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(v28, "PRECONDITION: *periodIt > 0. is false.");
      goto LABEL_36;
    }
    v11 = (std::__shared_weak_count *)v8[3];
    v35 = v8[2];
    v36 = v11;
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }
    v14 = (*(uint64_t (**)(Phase::Logger *, uint64_t *))(*(_QWORD *)a1 + 144))(a1, &v35);
    v15 = v36;
    if (v36)
    {
      v16 = (unint64_t *)&v36->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    v8 = (_QWORD *)v8[1];
  }
  while (v8 != (_QWORD *)a2);
  if (HIDWORD(v14) || !(_DWORD)v14)
  {
LABEL_17:
    std::list<std::shared_ptr<Phase::Job>>::list(v34, a2);
    std::list<double>::list(v33, a3);
    std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v38, a4);
    (*(void (**)(Phase::Logger *, uint64_t *, _QWORD *, _BYTE *))(*(_QWORD *)a1 + 128))(a1, v34, v33, v38);
    v18 = v39;
    if (v39 == (Phase::Logger *)v38)
    {
      v19 = 4;
      v18 = (Phase::Logger *)v38;
LABEL_26:
      (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
    }
    else if (v39)
    {
      v19 = 5;
      goto LABEL_26;
    }
    std::__list_imp<Phase::Controller::AssetUnloader::ObjectUnloadRequest>::clear(v33);
    v26 = v34;
LABEL_28:
    std::__list_imp<std::shared_ptr<Phase::Job>>::clear(v26);
  }
}

void sub_2165ED460(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_2165ED470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,char *a26)
{
  char *v26;
  char *v28;
  uint64_t v29;

  v28 = a26;
  if (a26 == v26)
  {
    v29 = 4;
    v28 = &a23;
  }
  else
  {
    if (!a26)
      goto LABEL_6;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_6:
  std::__list_imp<Phase::Controller::AssetUnloader::ObjectUnloadRequest>::clear(&a9);
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear(&a12);
  _Unwind_Resume(a1);
}

void sub_2165ED4D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  Phase::Logger *v25;
  Phase::Logger *v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  std::logic_error *exception;

  __cxa_free_exception(v20);
  if (a2 == 1)
  {
    v25 = (Phase::Logger *)__cxa_begin_catch(a1);
    v26 = v25;
    if (*(_QWORD *)(v18 + 24))
    {
      v27 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v25)
                                                                                          + 464)));
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        v28 = (*(uint64_t (**)(Phase::Logger *))(*(_QWORD *)v26 + 16))(v26);
        *(_DWORD *)(v22 - 128) = 136315650;
        *(_QWORD *)(v21 + 4) = "JobManager.mm";
        *(_WORD *)(v22 - 116) = 1024;
        *(_DWORD *)(v21 + 14) = 333;
        *(_WORD *)(v22 - 110) = 2080;
        *(_QWORD *)(v21 + 20) = v28;
        _os_log_impl(&dword_2164CC000, v27, OS_LOG_TYPE_ERROR, "%25s:%-5d \"Job graph prepare error %s\"", (uint8_t *)(v22 - 128), 0x1Cu);
      }

      std::list<std::shared_ptr<Phase::Job>>::list(&a15, v19);
      *(_BYTE *)(v22 - 128) = 0;
      v29 = *(_QWORD *)(v18 + 24);
      if (v29)
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v29 + 48))(v29, v22 - 128, &a15);
        std::__list_imp<std::shared_ptr<Phase::Job>>::clear(&a15);
        __cxa_end_catch();
        JUMPOUT(0x2165ED244);
      }
      std::__throw_bad_function_call[abi:ne180100]();
    }
    v30 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v25)
                                                                                        + 464)));
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      v31 = (*(uint64_t (**)(Phase::Logger *))(*(_QWORD *)v26 + 16))(v26);
      *(_DWORD *)(v22 - 128) = 136315650;
      *(_QWORD *)(v21 + 4) = "JobManager.mm";
      *(_WORD *)(v22 - 116) = 1024;
      *(_DWORD *)(v21 + 14) = 333;
      *(_WORD *)(v22 - 110) = 2080;
      *(_QWORD *)(v21 + 20) = v31;
      _os_log_impl(&dword_2164CC000, v30, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"\\\"Job graph prepare error %s\\\"\"", (uint8_t *)(v22 - 128), 0x1Cu);
    }

    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "\"Job graph prepare error %s\"");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8D0] + 16);
  }
  _Unwind_Resume(a1);
}

void sub_2165ED6DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  void *v15;

  __cxa_free_exception(v15);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_2165ED710(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void Phase::JobManager::StopScheduledJob(Phase::Logger *a1)
{
  NSObject *v1;
  std::logic_error *exception;
  int v3;
  const char *v4;
  __int16 v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v1 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(a1) + 464));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "JobManager.mm";
    v5 = 1024;
    v6 = 346;
    _os_log_impl(&dword_2164CC000, v1, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"Attempting to stop a job that was not scheduled!\"", (uint8_t *)&v3, 0x12u);
  }
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::invalid_argument::invalid_argument[abi:ne180100](exception, "Attempting to stop a job that was not scheduled!");
}

void sub_2165ED7EC(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void Phase::JobManager::StopScheduledJobs(Phase::Logger *a1)
{
  NSObject *v1;
  std::logic_error *exception;
  int v3;
  const char *v4;
  __int16 v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v1 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(a1) + 464));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "JobManager.mm";
    v5 = 1024;
    v6 = 351;
    _os_log_impl(&dword_2164CC000, v1, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"Attempting to stop a list of jobs that were not scheduled!\"", (uint8_t *)&v3, 0x12u);
  }
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::invalid_argument::invalid_argument[abi:ne180100](exception, "Attempting to stop a list of jobs that were not scheduled!");
}

void sub_2165ED8C8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void Phase::JobManager::StopScheduledJobAsync(Phase::Logger *a1)
{
  NSObject *v1;
  std::logic_error *exception;
  int v3;
  const char *v4;
  __int16 v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v1 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(a1) + 464));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "JobManager.mm";
    v5 = 1024;
    v6 = 356;
    _os_log_impl(&dword_2164CC000, v1, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"Attempting to stop a job that was not scheduled!\"", (uint8_t *)&v3, 0x12u);
  }
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::invalid_argument::invalid_argument[abi:ne180100](exception, "Attempting to stop a job that was not scheduled!");
}

void sub_2165ED9A4(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void Phase::JobManager::StopScheduledJobsAsync(Phase::Logger *a1)
{
  NSObject *v1;
  std::logic_error *exception;
  int v3;
  const char *v4;
  __int16 v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v1 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(a1) + 464));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "JobManager.mm";
    v5 = 1024;
    v6 = 361;
    _os_log_impl(&dword_2164CC000, v1, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"Attempting to stop a list of jobs that were not scheduled!\"", (uint8_t *)&v3, 0x12u);
  }
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::invalid_argument::invalid_argument[abi:ne180100](exception, "Attempting to stop a list of jobs that were not scheduled!");
}

void sub_2165EDA80(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void Phase::JobObserverSignpost::~JobObserverSignpost(Phase::JobObserverSignpost *this)
{
  JUMPOUT(0x2199F9D70);
}

os_signpost_id_t Phase::JobObserverSignpost::Initialize(Phase::JobObserverSignpost *this, const Phase::Job *a2, Phase::Logger **a3)
{
  Phase::Logger *v4;
  uint64_t InstancePtr;
  os_signpost_id_t result;

  v4 = (Phase::Logger *)operator new();
  InstancePtr = Phase::Logger::GetInstancePtr(v4);
  result = os_signpost_id_generate(**(os_log_t **)(InstancePtr + 464));
  *(_QWORD *)v4 = result;
  *a3 = v4;
  return result;
}

void sub_2165EDB04(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199F9D70](v1, 0x1000C4000313F17);
  _Unwind_Resume(a1);
}

void Phase::JobObserverSignpost::ExecuteBegin(Phase::JobObserverSignpost *this, const Phase::Job *a2, os_signpost_id_t **a3)
{
  os_signpost_id_t *v4;
  Phase::Logger *InstancePtr;
  NSObject *v6;
  NSObject *v7;
  os_signpost_id_t v8;
  _QWORD *v9;
  int v10;
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v4 = *a3;
  InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(this);
  if (*((_BYTE *)InstancePtr + 472))
  {
    v6 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(InstancePtr)
                                                                                       + 464)));
    v7 = v6;
    v8 = *v4;
    if (v8 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v6))
    {
      v9 = (_QWORD *)((char *)a2 + 8);
      if (*((char *)a2 + 31) < 0)
        v9 = (_QWORD *)*v9;
      v10 = 136315138;
      v11 = v9;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v7, OS_SIGNPOST_INTERVAL_BEGIN, v8, "Phase_Job_Run", "%s", (uint8_t *)&v10, 0xCu);
    }

  }
}

void Phase::JobObserverSignpost::ExecuteEnd(Phase::JobObserverSignpost *this, const Phase::Job *a2, os_signpost_id_t **a3)
{
  os_signpost_id_t *v3;
  Phase::Logger *InstancePtr;
  NSObject *v5;
  NSObject *v6;
  os_signpost_id_t v7;
  uint8_t v8[16];

  v3 = *a3;
  InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(this);
  if (*((_BYTE *)InstancePtr + 472))
  {
    v5 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(InstancePtr)
                                                                                       + 464)));
    v6 = v5;
    v7 = *v3;
    if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
    {
      *(_WORD *)v8 = 0;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v6, OS_SIGNPOST_INTERVAL_END, v7, "Phase_Job_Run", (const char *)&unk_21676613F, v8, 2u);
    }

  }
}

uint64_t Phase::JobObserverSignpost::Finalize(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;

  result = *a3;
  if (*a3)
    JUMPOUT(0x2199F9D70);
  return result;
}

uint64_t *std::list<std::shared_ptr<Phase::Job>>::list(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;

  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  if (a3)
  {
    v5 = 16 * a3;
    do
    {
      std::list<std::shared_ptr<Phase::Job>>::push_back(a1, a2);
      a2 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  return a1;
}

void sub_2165EDD3C(_Unwind_Exception *a1)
{
  uint64_t *v1;

  std::__list_imp<std::shared_ptr<Phase::Job>>::clear(v1);
  _Unwind_Resume(a1);
}

void Phase::JobDispatch::~JobDispatch(Phase::JobDispatch *this)
{
  NSObject *v2;
  const void *v3;

  *(_QWORD *)this = &off_24D57E2D0;
  std::mutex::~mutex((std::mutex *)((char *)this + 632));
  std::unique_ptr<Phase::JobDispatch::Schedule>::reset[abi:ne180100]((uint64_t *)this + 78, 0);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)this + 608);
  v2 = *((_QWORD *)this + 73);
  if (v2)
    dispatch_release(v2);
  v3 = (const void *)*((_QWORD *)this + 72);
  if (v3)
    _Block_release(v3);
  Phase::Job::~Job(this);
}

{
  Phase::JobDispatch::~JobDispatch(this);
  JUMPOUT(0x2199F9D64);
}

void Phase::JobManagerDispatch::~JobManagerDispatch(Phase::JobManagerDispatch *this)
{
  int v2;
  int v3;
  std::chrono::nanoseconds __ns;

  *(_QWORD *)this = &off_24D57E2F0;
  atomic_store(1u, (unsigned __int8 *)this + 220);
  v2 = atomic_load((unsigned int *)this + 54);
  if (v2 >= 1)
  {
    do
    {
      __ns.__rep_ = 10000000;
      std::this_thread::sleep_for (&__ns);
      v3 = atomic_load((unsigned int *)this + 54);
    }
    while (v3 > 0);
  }
  std::__tree<std::__value_type<Phase::Job::Priority,applesauce::dispatch::v1::queue>,std::__map_value_compare<Phase::Job::Priority,std::__value_type<Phase::Job::Priority,applesauce::dispatch::v1::queue>,std::less<Phase::Job::Priority>,true>,std::allocator<std::__value_type<Phase::Job::Priority,applesauce::dispatch::v1::queue>>>::destroy(*((_QWORD **)this + 29));
  Phase::JobManager::~JobManager(this);
}

{
  Phase::JobManagerDispatch::~JobManagerDispatch(this);
  JUMPOUT(0x2199F9D70);
}

uint64_t Phase::JobManagerDispatch::CreateJob@<X0>(uint64_t a1@<X0>, __int128 *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int *v8;
  unsigned int v9;

  v6 = operator new(0x300uLL, (std::align_val_t)0x80uLL);
  Phase::Job::Job((uint64_t)v6, a1, a2);
  *v6 = &off_24D57E2D0;
  v6[72] = 0;
  v6[73] = dispatch_group_create();
  v6[74] = 0;
  *((_WORD *)v6 + 300) = 0;
  v6[76] = 0;
  v6[78] = 0;
  v6[77] = 0;
  v6[79] = 850045863;
  *((_OWORD *)v6 + 40) = 0u;
  *((_OWORD *)v6 + 41) = 0u;
  *((_OWORD *)v6 + 42) = 0u;
  v6[86] = 0;
  *a3 = v6;
  result = operator new();
  *(_OWORD *)(result + 32) = xmmword_2166F8A20;
  *(_QWORD *)(result + 48) = a1;
  *(_QWORD *)result = &off_24D57E3F0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = v6;
  a3[1] = result;
  v8 = (unsigned int *)(a1 + 216);
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 + 1, v8));
  return result;
}

void sub_2165EDF60(void *a1)
{
  uint64_t v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v1 + 112))(v1, v2);
  __cxa_rethrow();
}

void sub_2165EDF80(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Phase::JobManagerDispatch::AddDependency(Phase::Logger *a1, Phase::Job **a2, Phase::Job **a3)
{
  Phase::Job *v3;
  Phase::Job *v5;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t **Dependents;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_weak_owners;
  unint64_t v16;
  char v17;
  char v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  Phase::Job *v24;
  int v25;
  uint64_t *Dependencies;
  NSObject *v27;
  std::logic_error *exception;
  NSObject *v29;
  std::logic_error *v30;
  Phase::Job *v31;
  std::__shared_weak_count *v32;
  uint64_t v33[2];
  _BYTE buf[18];
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v3 = *a2;
  if (!*a2)
  {
    v27 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "JobManagerDispatch.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 107;
      _os_log_impl(&dword_2164CC000, v27, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInDependent is false.", buf, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "PRECONDITION: nullptr != pInDependent is false.");
  }
  v5 = *a3;
  if (!*a3)
  {
    v29 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "JobManagerDispatch.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 108;
      _os_log_impl(&dword_2164CC000, v29, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInDependency is false.", buf, 0x12u);
    }
    v30 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v30, "PRECONDITION: nullptr != pInDependency is false.");
  }
  v8 = (std::__shared_weak_count *)a2[1];
  v33[0] = (uint64_t)*a2;
  v33[1] = (uint64_t)v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  Phase::JobManager::TreeLock::TreeLock(buf, a1, v33);
  if (v8)
  {
    v11 = (unint64_t *)&v8->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  if ((*((_BYTE *)v3 + 592) & 2) != 0 || (*((_BYTE *)v5 + 592) & 2) != 0)
  {
    v19 = 3;
  }
  else
  {
    Dependents = (uint64_t **)Phase::JobManager::GetDependents(a1, v5);
    v14 = (std::__shared_weak_count *)a2[1];
    v31 = *a2;
    v32 = v14;
    if (v14)
    {
      p_shared_weak_owners = (unint64_t *)&v14->__shared_weak_owners_;
      do
        v16 = __ldxr(p_shared_weak_owners);
      while (__stxr(v16 + 1, p_shared_weak_owners));
    }
    std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::__emplace_unique_key_args<std::weak_ptr<Phase::Job>,std::weak_ptr<Phase::Job>>(Dependents, (uint64_t)&v31, (uint64_t)&v31);
    v18 = v17;
    if (v32)
      std::__shared_weak_count::__release_weak(v32);
    if ((v18 & 1) != 0)
    {
      v24 = *a3;
      v25 = *((_DWORD *)*a3 + 131);
      if (v25 <= *((_DWORD *)*a2 + 131))
        v25 = *((_DWORD *)*a2 + 131);
      *((_DWORD *)v24 + 131) = v25;
      atomic_store(1u, (unsigned __int8 *)v24 + 40);
      Dependencies = (uint64_t *)Phase::JobManager::GetDependencies(a1, v3);
      std::list<std::shared_ptr<Phase::Job>>::push_back(Dependencies, a3);
      v19 = 0;
    }
    else
    {
      v19 = 2;
    }
  }
  std::recursive_mutex::unlock((std::recursive_mutex *)(*(_QWORD *)buf + 96));
  v20 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v21 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  return v19;
}

void sub_2165EE2B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11, uint64_t a12, uint64_t a13)
{
  std::recursive_mutex::unlock((std::recursive_mutex *)(a13 + 96));
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t Phase::JobManagerDispatch::AddEnqueuedDependency(Phase::Logger *a1, dispatch_group_t **a2, uint64_t *a3, double a4)
{
  dispatch_group_t *v4;
  uint64_t v6;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t **Dependents;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_weak_owners;
  unint64_t v20;
  char v21;
  char v22;
  int v23;
  uint64_t *Dependencies;
  uint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  NSObject *v35;
  std::logic_error *exception;
  NSObject *v37;
  std::logic_error *v38;
  uint64_t v39[2];
  dispatch_group_t *v40;
  std::__shared_weak_count *v41;
  uint64_t v42[2];
  _BYTE buf[18];
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (!*a2)
  {
    v35 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "JobManagerDispatch.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 131;
      _os_log_impl(&dword_2164CC000, v35, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInDependent is false.", buf, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "PRECONDITION: nullptr != pInDependent is false.");
  }
  v6 = *a3;
  if (!*a3)
  {
    v37 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "JobManagerDispatch.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 132;
      _os_log_impl(&dword_2164CC000, v37, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInDependency is false.", buf, 0x12u);
    }
    v38 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v38, "PRECONDITION: nullptr != pInDependency is false.");
  }
  v10 = (std::__shared_weak_count *)a2[1];
  v42[0] = (uint64_t)*a2;
  v42[1] = (uint64_t)v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  Phase::JobManager::TreeLock::TreeLock(buf, a1, v42);
  if (v10)
  {
    v13 = (unint64_t *)&v10->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v15 = atomic_load((unsigned int *)Phase::JobManager::GetExecutionState(a1, (Phase::Job *)v4));
  if (v15 == 3)
  {
    v16 = 3;
  }
  else
  {
    Dependents = (uint64_t **)Phase::JobManager::GetDependents(a1, (Phase::Job *)v6);
    v18 = (std::__shared_weak_count *)a2[1];
    v40 = *a2;
    v41 = v18;
    if (v18)
    {
      p_shared_weak_owners = (unint64_t *)&v18->__shared_weak_owners_;
      do
        v20 = __ldxr(p_shared_weak_owners);
      while (__stxr(v20 + 1, p_shared_weak_owners));
    }
    std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::__emplace_unique_key_args<std::weak_ptr<Phase::Job>,std::weak_ptr<Phase::Job>>(Dependents, (uint64_t)&v40, (uint64_t)&v40);
    v22 = v21;
    if (v41)
      std::__shared_weak_count::__release_weak(v41);
    if ((v22 & 1) != 0)
    {
      v23 = *(_DWORD *)(v6 + 524);
      if (v23 <= *((_DWORD *)*a2 + 131))
        v23 = *((_DWORD *)*a2 + 131);
      *(_DWORD *)(v6 + 524) = v23;
      atomic_store(1u, (unsigned __int8 *)(v6 + 40));
      Dependencies = (uint64_t *)Phase::JobManager::GetDependencies(a1, (Phase::Job *)v4);
      std::list<std::shared_ptr<Phase::Job>>::push_back(Dependencies, a3);
      dispatch_group_enter(v4[73]);
      v25 = *a3;
      v26 = (std::__shared_weak_count *)a3[1];
      v39[0] = v25;
      v39[1] = (uint64_t)v26;
      if (v26)
      {
        v27 = (unint64_t *)&v26->__shared_owners_;
        do
          v28 = __ldxr(v27);
        while (__stxr(v28 + 1, v27));
      }
      Phase::JobManagerDispatch::doRunJob(a1, v39, a4);
      if (v26)
      {
        v29 = (unint64_t *)&v26->__shared_owners_;
        do
          v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
      v16 = 0;
    }
    else
    {
      v16 = 2;
    }
  }
  std::recursive_mutex::unlock((std::recursive_mutex *)(*(_QWORD *)buf + 96));
  v31 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v32 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  return v16;
}

void sub_2165EE694(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, char a13, uint64_t a14, uint64_t a15)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::recursive_mutex::unlock((std::recursive_mutex *)(a15 + 96));
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t Phase::JobManagerDispatch::doRunJob(Phase::JobManager *a1, uint64_t *a2, double a3)
{
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _BOOL4 v15;
  _BOOL4 v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  void *v20;
  NSObject *ConcurrentQueue;
  std::__shared_weak_count *v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  uint64_t Dependencies;
  _QWORD *v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  uint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t v36;
  int v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  uint64_t v43;
  NSObject *v44;
  NSObject *v45;
  uint64_t v46;
  NSObject *v47;
  dispatch_time_t v48;
  NSObject *v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  uint64_t v54;
  std::__shared_weak_count *v55;
  uint64_t v56;
  std::__shared_weak_count *v57;
  _QWORD notification_block[6];
  std::__shared_weak_count *v59;
  uint64_t v60;
  std::__shared_weak_count *v61;
  uint64_t v62[2];
  __int128 v63;

  v6 = *a2;
  v7 = (std::__shared_weak_count *)a2[1];
  v62[0] = *a2;
  v62[1] = (uint64_t)v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  Phase::JobManager::TreeLock::TreeLock(&v63, a1, v62);
  if (v7)
  {
    v10 = (unint64_t *)&v7->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v12 = (std::__shared_weak_count *)a2[1];
  v60 = *a2;
  v61 = v12;
  if (v12)
  {
    v13 = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  v15 = Phase::JobManagerDispatch::PrepareJobForExecution(a1, &v60);
  v16 = v15;
  v17 = v61;
  if (!v61)
    goto LABEL_16;
  v18 = (unint64_t *)&v61->__shared_owners_;
  do
    v19 = __ldaxr(v18);
  while (__stlxr(v19 - 1, v18));
  if (v19)
  {
LABEL_16:
    if (v15)
      goto LABEL_17;
LABEL_55:
    v31 = 1;
    goto LABEL_56;
  }
  ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
  std::__shared_weak_count::__release_weak(v17);
  if (!v16)
    goto LABEL_55;
LABEL_17:
  if (*(_QWORD *)(v6 + 624))
  {
    v20 = *(void **)(v6 + 576);
    ConcurrentQueue = Phase::JobManagerDispatch::GetConcurrentQueue(a1, *(_DWORD *)(*a2 + 524));
    notification_block[0] = MEMORY[0x24BDAC760];
    notification_block[1] = 1174405120;
    notification_block[2] = ___ZN5Phase18JobManagerDispatch8doRunJobENSt3__110shared_ptrINS_3JobEEEd_block_invoke;
    notification_block[3] = &__block_descriptor_tmp_8;
    v23 = *a2;
    v22 = (std::__shared_weak_count *)a2[1];
    notification_block[4] = a1;
    notification_block[5] = v23;
    v59 = v22;
    if (v22)
    {
      v24 = (unint64_t *)&v22->__shared_owners_;
      do
        v25 = __ldxr(v24);
      while (__stxr(v25 + 1, v24));
    }
    dispatch_block_notify(v20, ConcurrentQueue, notification_block);
    v26 = v59;
    if (v59)
    {
      v27 = (unint64_t *)&v59->__shared_owners_;
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
  }
  if (!*(_QWORD *)(Phase::JobManager::GetDependencies(a1, (Phase::Job *)v6) + 16))
  {
    v46 = *a2;
    if (!*(_DWORD *)(*a2 + 528))
    {
      *(_QWORD *)(v6 + 592) |= 4uLL;
      if (a3 == 0.0)
      {
        v47 = Phase::JobManagerDispatch::GetConcurrentQueue(a1, *(_DWORD *)(v46 + 524));
        dispatch_async(v47, *(dispatch_block_t *)(v6 + 576));
      }
      else
      {
        v48 = dispatch_time(0, (uint64_t)(a3 * 1000000000.0));
        v49 = Phase::JobManagerDispatch::GetConcurrentQueue(a1, *(_DWORD *)(*a2 + 524));
        dispatch_after(v48, v49, *(dispatch_block_t *)(v6 + 576));
      }
    }
    goto LABEL_55;
  }
  Dependencies = Phase::JobManager::GetDependencies(a1, (Phase::Job *)v6);
  v30 = *(_QWORD **)(Dependencies + 8);
  v31 = 1;
  while (v30 != (_QWORD *)Dependencies)
  {
    v33 = v30[2];
    v32 = (std::__shared_weak_count *)v30[3];
    v56 = v33;
    v57 = v32;
    if (v32)
    {
      v34 = (unint64_t *)&v32->__shared_owners_;
      do
        v35 = __ldxr(v34);
      while (__stxr(v35 + 1, v34));
      dispatch_group_enter(*(dispatch_group_t *)(v6 + 584));
      v55 = v32;
      do
        v36 = __ldxr(v34);
      while (__stxr(v36 + 1, v34));
    }
    else
    {
      dispatch_group_enter(*(dispatch_group_t *)(v6 + 584));
      v55 = 0;
    }
    v54 = v33;
    v37 = Phase::JobManagerDispatch::doRunJob(a1, &v54, a3);
    if (v32)
    {
      v38 = (unint64_t *)&v32->__shared_owners_;
      do
        v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    v40 = v57;
    if (v57)
    {
      v41 = (unint64_t *)&v57->__shared_owners_;
      do
        v42 = __ldaxr(v41);
      while (__stlxr(v42 - 1, v41));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
      }
    }
    v31 = (v37 + v31);
    v30 = (_QWORD *)v30[1];
  }
  v43 = *a2;
  if (!*(_DWORD *)(*a2 + 528))
  {
    *(_QWORD *)(v6 + 592) |= 4uLL;
    v44 = *(NSObject **)(v6 + 584);
    v45 = Phase::JobManagerDispatch::GetConcurrentQueue(a1, *(_DWORD *)(v43 + 524));
    dispatch_group_notify(v44, v45, *(dispatch_block_t *)(v6 + 576));
  }
LABEL_56:
  std::recursive_mutex::unlock((std::recursive_mutex *)(v63 + 96));
  v50 = (std::__shared_weak_count *)*((_QWORD *)&v63 + 1);
  if (*((_QWORD *)&v63 + 1))
  {
    v51 = (unint64_t *)(*((_QWORD *)&v63 + 1) + 8);
    do
      v52 = __ldaxr(v51);
    while (__stlxr(v52 - 1, v51));
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }
  return v31;
}

void sub_2165EEAF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::recursive_mutex::unlock((std::recursive_mutex *)(*(_QWORD *)(v1 - 112) + 96));
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v1 - 112);
  _Unwind_Resume(a1);
}

uint64_t Phase::JobManagerDispatch::InsertDependency(Phase::Logger *a1, uint64_t *a2, uint64_t *a3, Phase::Job **a4)
{
  uint64_t v4;
  uint64_t v6;
  Phase::Job *v8;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v23;
  uint64_t Dependencies;
  uint64_t **Dependents;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_weak_owners;
  unint64_t v28;
  char v29;
  int v30;
  uint64_t **v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  char v35;
  int v36;
  uint64_t *v37;
  uint64_t *v38;
  unsigned int v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  _BOOL4 v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t i;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t v52;
  NSObject *v53;
  NSObject *ConcurrentQueue;
  NSObject *v55;
  std::logic_error *exception;
  NSObject *v57;
  std::logic_error *v58;
  NSObject *v59;
  std::logic_error *v60;
  uint64_t v61;
  std::__shared_weak_count *v62;
  uint64_t v63;
  std::__shared_weak_count *v64;
  uint64_t v65;
  std::__shared_weak_count *v66;
  uint64_t v67[2];
  _BYTE buf[18];
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (!*a2)
  {
    v55 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "JobManagerDispatch.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 162;
      _os_log_impl(&dword_2164CC000, v55, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInInsertor is false.", buf, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "PRECONDITION: nullptr != pInInsertor is false.");
  }
  v6 = *a3;
  if (!*a3)
  {
    v57 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "JobManagerDispatch.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 163;
      _os_log_impl(&dword_2164CC000, v57, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInDependent is false.", buf, 0x12u);
    }
    v58 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v58, "PRECONDITION: nullptr != pInDependent is false.");
  }
  v8 = *a4;
  if (!*a4)
  {
    v59 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "JobManagerDispatch.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 164;
      _os_log_impl(&dword_2164CC000, v59, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInDependency is false.", buf, 0x12u);
    }
    v60 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v60, "PRECONDITION: nullptr != pInDependency is false.");
  }
  v11 = (std::__shared_weak_count *)a3[1];
  v67[0] = *a3;
  v67[1] = (uint64_t)v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }
  Phase::JobManager::TreeLock::TreeLock(buf, a1, v67);
  if (v11)
  {
    v14 = (unint64_t *)&v11->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v16 = atomic_load((unsigned int *)Phase::JobManager::GetExecutionState(a1, (Phase::Job *)v6));
  if (v16 == 3 || (v17 = atomic_load((unsigned int *)Phase::JobManager::GetExecutionState(a1, v8)), v17 == 3))
  {
    v18 = 3;
  }
  else
  {
    v23 = *(_QWORD *)(Phase::JobManager::GetDependencies(a1, (Phase::Job *)v6) + 8);
    Dependencies = Phase::JobManager::GetDependencies(a1, (Phase::Job *)v6);
    if (v23 != Dependencies)
    {
      while (*(Phase::Job **)(v23 + 16) != *a4)
      {
        v23 = *(_QWORD *)(v23 + 8);
        if (v23 == Dependencies)
        {
          v23 = Dependencies;
          break;
        }
      }
    }
    if (v23 == Phase::JobManager::GetDependencies(a1, (Phase::Job *)v6))
      goto LABEL_62;
    Dependents = (uint64_t **)Phase::JobManager::GetDependents(a1, v8);
    v26 = (std::__shared_weak_count *)a2[1];
    v65 = *a2;
    v66 = v26;
    if (v26)
    {
      p_shared_weak_owners = (unint64_t *)&v26->__shared_weak_owners_;
      do
        v28 = __ldxr(p_shared_weak_owners);
      while (__stxr(v28 + 1, p_shared_weak_owners));
    }
    std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::__emplace_unique_key_args<std::weak_ptr<Phase::Job>,std::weak_ptr<Phase::Job>>(Dependents, (uint64_t)&v65, (uint64_t)&v65);
    if ((v29 & 1) != 0)
    {
      v31 = (uint64_t **)Phase::JobManager::GetDependents(a1, (Phase::Job *)v4);
      v32 = (std::__shared_weak_count *)a3[1];
      v63 = *a3;
      v64 = v32;
      if (v32)
      {
        v33 = (unint64_t *)&v32->__shared_weak_owners_;
        do
          v34 = __ldxr(v33);
        while (__stxr(v34 + 1, v33));
      }
      std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::__emplace_unique_key_args<std::weak_ptr<Phase::Job>,std::weak_ptr<Phase::Job>>(v31, (uint64_t)&v63, (uint64_t)&v63);
      v30 = v35 & 1;
      if (v64)
        std::__shared_weak_count::__release_weak(v64);
    }
    else
    {
      v30 = 0;
    }
    if (v66)
      std::__shared_weak_count::__release_weak(v66);
    if (!v30)
    {
LABEL_62:
      v18 = 2;
    }
    else
    {
      v36 = *(_DWORD *)(v4 + 524);
      if (v36 <= *(_DWORD *)(v6 + 524))
        v36 = *(_DWORD *)(v6 + 524);
      *(_DWORD *)(v4 + 524) = v36;
      atomic_store(1u, (unsigned __int8 *)(v4 + 40));
      v37 = (uint64_t *)Phase::JobManager::GetDependencies(a1, (Phase::Job *)v6);
      std::list<std::shared_ptr<Phase::Job>>::push_back(v37, a2);
      v38 = (uint64_t *)Phase::JobManager::GetDependencies(a1, (Phase::Job *)v4);
      std::list<std::shared_ptr<Phase::Job>>::push_back(v38, a4);
      v39 = atomic_load((unsigned int *)Phase::JobManager::GetExecutionState(a1, v8));
      if (v39 == 1)
      {
        dispatch_group_enter(*(dispatch_group_t *)(v6 + 584));
        v40 = (std::__shared_weak_count *)a2[1];
        v61 = *a2;
        v62 = v40;
        if (v40)
        {
          v41 = (unint64_t *)&v40->__shared_owners_;
          do
            v42 = __ldxr(v41);
          while (__stxr(v42 + 1, v41));
        }
        v43 = Phase::JobManagerDispatch::PrepareJobForExecution(a1, &v61);
        v44 = v62;
        if (v62)
        {
          v45 = (unint64_t *)&v62->__shared_owners_;
          do
            v46 = __ldaxr(v45);
          while (__stlxr(v46 - 1, v45));
          if (!v46)
          {
            ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
            std::__shared_weak_count::__release_weak(v44);
          }
        }
        if (v43)
        {
          v47 = Phase::JobManager::GetDependencies(a1, (Phase::Job *)v4);
          for (i = *(_QWORD *)(v47 + 8); i != v47; i = *(_QWORD *)(i + 8))
          {
            v49 = *(std::__shared_weak_count **)(i + 24);
            if (v49)
            {
              v50 = (unint64_t *)&v49->__shared_owners_;
              do
                v51 = __ldxr(v50);
              while (__stxr(v51 + 1, v50));
              dispatch_group_enter(*(dispatch_group_t *)(v4 + 584));
              do
                v52 = __ldaxr(v50);
              while (__stlxr(v52 - 1, v50));
              if (!v52)
              {
                ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
                std::__shared_weak_count::__release_weak(v49);
              }
            }
            else
            {
              dispatch_group_enter(*(dispatch_group_t *)(v4 + 584));
            }
          }
          if (!*(_DWORD *)(v4 + 528))
          {
            *(_QWORD *)(v4 + 592) |= 4uLL;
            v53 = *(NSObject **)(v4 + 584);
            ConcurrentQueue = Phase::JobManagerDispatch::GetConcurrentQueue(a1, *(_DWORD *)(v4 + 524));
            dispatch_group_notify(v53, ConcurrentQueue, *(dispatch_block_t *)(v4 + 576));
          }
        }
      }
      v18 = 0;
    }
  }
  std::recursive_mutex::unlock((std::recursive_mutex *)(*(_QWORD *)buf + 96));
  v19 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v20 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  return v18;
}

void sub_2165EF114(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14, char a15, uint64_t a16, uint64_t a17)
{
  std::recursive_mutex::unlock((std::recursive_mutex *)(a17 + 96));
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  _Unwind_Resume(a1);
}

BOOL Phase::JobManagerDispatch::PrepareJobForExecution(Phase::JobManager *this, uint64_t *a2)
{
  std::__shared_weak_count *v4;
  Phase::Job *v5;
  unint64_t *p_shared_weak_owners;
  unint64_t v7;
  unsigned int v8;
  dispatch_block_t v9;
  const void *v10;
  const void *v11;
  _QWORD block[6];
  _QWORD v14[6];
  std::__shared_weak_count *v15;

  v14[0] = 0;
  v14[1] = v14;
  v14[2] = 0x3802000000;
  v14[3] = __Block_byref_object_copy_;
  v14[4] = __Block_byref_object_dispose_;
  v5 = (Phase::Job *)*a2;
  v4 = (std::__shared_weak_count *)a2[1];
  v14[5] = *a2;
  v15 = v4;
  if (v4)
  {
    p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
    do
      v7 = __ldxr(p_shared_weak_owners);
    while (__stxr(v7 + 1, p_shared_weak_owners));
    v5 = (Phase::Job *)*a2;
  }
  v8 = atomic_load((unsigned int *)Phase::JobManager::GetExecutionState(this, v5));
  if (v8 != 3)
  {
    std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)v5 + 76, a2);
    *((_QWORD *)v5 + 74) |= 2uLL;
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 0x40000000;
    block[2] = ___ZN5Phase18JobManagerDispatch22PrepareJobForExecutionENSt3__110shared_ptrINS_3JobEEE_block_invoke;
    block[3] = &unk_24D57E390;
    block[4] = v14;
    block[5] = this;
    v9 = dispatch_block_create(DISPATCH_BLOCK_INHERIT_QOS_CLASS|DISPATCH_BLOCK_DETACHED, block);
    v10 = v9;
    if (v9)
      v9 = _Block_copy(v9);
    v11 = (const void *)*((_QWORD *)v5 + 72);
    *((_QWORD *)v5 + 72) = v9;
    if (v11)
      _Block_release(v11);
    _Block_release(v10);
  }
  _Block_object_dispose(v14, 8);
  if (v15)
    std::__shared_weak_count::__release_weak(v15);
  return v8 != 3;
}

void sub_2165EF2EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  _Block_object_dispose(&a16, 8);
  if (a22)
    std::__shared_weak_count::__release_weak(a22);
  _Unwind_Resume(a1);
}

void *Phase::JobManagerDispatch::GetConcurrentQueue(_QWORD *a1, int a2)
{
  uint64_t v4;
  void **v5;
  void **v6;
  int v7;
  BOOL v8;
  uint64_t *v9;
  std::string *v10;
  std::string::size_type size;
  std::string *v12;
  __int128 v13;
  void **v14;
  NSObject *v15;
  void **v16;
  NSObject *v17;
  NSObject *v18;
  int v19;
  void *v20;
  void **v21;
  void **v22;
  void **v23;
  void **v24;
  void **v25;
  void **v26;
  BOOL v27;
  void **v28;
  void *v29;
  int v30;
  void **v31;
  void *v32;
  int v33;
  uint64_t v34;
  uint64_t *v35;
  NSObject *v37;
  std::logic_error *exception;
  std::string v39;
  void *__p[2];
  int64_t v41;
  std::string v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  v5 = (void **)(a1 + 29);
  v4 = a1[29];
  if (!v4)
    goto LABEL_11;
  v6 = (void **)(a1 + 29);
  do
  {
    v7 = *(_DWORD *)(v4 + 32);
    v8 = v7 < a2;
    if (v7 >= a2)
      v9 = (uint64_t *)v4;
    else
      v9 = (uint64_t *)(v4 + 8);
    if (!v8)
      v6 = (void **)v4;
    v4 = *v9;
  }
  while (*v9);
  if (v6 == v5 || *((_DWORD *)v6 + 8) > a2)
  {
LABEL_11:
    std::string::basic_string[abi:ne180100]<0>(&v42, "PHASE JobManager concurrent queue ");
    std::to_string(&v39, a2);
    if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v10 = &v39;
    else
      v10 = (std::string *)v39.__r_.__value_.__r.__words[0];
    if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v39.__r_.__value_.__r.__words[2]);
    else
      size = v39.__r_.__value_.__l.__size_;
    v12 = std::string::append(&v42, (const std::string::value_type *)v10, size);
    v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v41 = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v39.__r_.__value_.__l.__data_);
    if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v42.__r_.__value_.__l.__data_);
    if (a2 >= 3)
    {
      v37 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)v12) + 464);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v42.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)v42.__r_.__value_.__r.__words + 4) = (std::string::size_type)"JobManagerDispatch.cpp";
        WORD2(v42.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&v42.__r_.__value_.__r.__words[1] + 6) = 50;
        _os_log_impl(&dword_2164CC000, v37, OS_LOG_TYPE_ERROR, "%25s:%-5d INVARIANT: false is false.", (uint8_t *)&v42, 0x12u);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "INVARIANT: false is false.");
    }
    v14 = (void **)a1[28];
    v15 = dispatch_queue_attr_make_with_qos_class(MEMORY[0x24BDAC9C0], (dispatch_qos_class_t)dword_2166F8A48[a2], 0);
    if (v41 >= 0)
      v16 = __p;
    else
      v16 = (void **)__p[0];
    v17 = dispatch_queue_create((const char *)v16, v15);
    v18 = v17;
    if (v5 == v14 || (v19 = *((_DWORD *)v14 + 8), v19 > a2))
    {
      v20 = *v14;
      if ((void **)a1[28] == v14)
      {
        v22 = v14;
        goto LABEL_40;
      }
      if (v20)
      {
        v21 = (void **)*v14;
        do
        {
          v22 = v21;
          v21 = (void **)v21[1];
        }
        while (v21);
      }
      else
      {
        v26 = v14;
        do
        {
          v22 = (void **)v26[2];
          v27 = *v22 == v26;
          v26 = v22;
        }
        while (v27);
      }
      if (*((_DWORD *)v22 + 8) < a2)
      {
LABEL_40:
        v27 = v20 == 0;
        if (v20)
          v28 = v22;
        else
          v28 = v14;
        if (v27)
          v24 = v14;
        else
          v24 = v22 + 1;
        v6 = (void **)*v24;
        if (!*v24)
        {
          v14 = v28;
LABEL_66:
          v6 = (void **)operator new(0x30uLL);
          *((_DWORD *)v6 + 8) = a2;
          v6[5] = v18;
          *v6 = 0;
          v6[1] = 0;
          v6[2] = v14;
          *v24 = v6;
          v34 = *(_QWORD *)a1[28];
          v35 = (uint64_t *)v6;
          if (v34)
          {
            a1[28] = v34;
            v35 = (uint64_t *)*v24;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)a1[29], v35);
          ++a1[30];
LABEL_72:
          if (SHIBYTE(v41) < 0)
            operator delete(__p[0]);
          return v6[5];
        }
LABEL_70:
        if (v17)
          dispatch_release(v17);
        goto LABEL_72;
      }
      v29 = *v5;
      v24 = v5;
      v14 = v5;
      if (!*v5)
        goto LABEL_66;
      while (1)
      {
        while (1)
        {
          v14 = (void **)v29;
          v30 = *((_DWORD *)v29 + 8);
          if (v30 <= a2)
            break;
          v29 = *v14;
          v24 = v14;
          if (!*v14)
            goto LABEL_66;
        }
        if (v30 >= a2)
          break;
        v29 = v14[1];
        if (!v29)
          goto LABEL_54;
      }
    }
    else if (v19 < a2)
    {
      v24 = v14 + 1;
      v23 = (void **)v14[1];
      if (v23)
      {
        do
        {
          v24 = v23;
          v23 = (void **)*v23;
          v14 = v24;
          v25 = v24;
        }
        while (v23);
      }
      else
      {
        v25 = v14;
        do
        {
          v31 = v25;
          v25 = (void **)v25[2];
        }
        while (*v25 != v31);
      }
      if (v25 == v5)
        goto LABEL_66;
      if (*((_DWORD *)v25 + 8) > a2)
        goto LABEL_66;
      v32 = *v5;
      v24 = v5;
      v14 = v5;
      if (!*v5)
        goto LABEL_66;
      while (1)
      {
        while (1)
        {
          v14 = (void **)v32;
          v33 = *((_DWORD *)v32 + 8);
          if (v33 <= a2)
            break;
          v32 = *v14;
          v24 = v14;
          if (!*v14)
            goto LABEL_66;
        }
        if (v33 >= a2)
          break;
        v32 = v14[1];
        if (!v32)
        {
LABEL_54:
          v24 = v14 + 1;
          goto LABEL_66;
        }
      }
    }
    v6 = v14;
    goto LABEL_70;
  }
  return v6[5];
}

void sub_2165EF6F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  void *v28;

  __cxa_free_exception(v28);
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t Phase::JobManagerDispatch::ReplaceDependency(Phase::Logger *a1, uint64_t *a2, uint64_t a3, Phase::Job **a4)
{
  uint64_t v4;
  Phase::Job *v6;
  Phase::Job *v8;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t Dependencies;
  int v18;
  uint64_t Dependents;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_weak_owners;
  unint64_t v22;
  uint64_t **v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  _BOOL4 v31;
  _BOOL4 v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  _QWORD *i;
  std::__shared_weak_count *v38;
  uint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  uint64_t *v46;
  unint64_t v47;
  uint64_t v48;
  NSObject *v49;
  NSObject *ConcurrentQueue;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  NSObject *v55;
  std::logic_error *exception;
  NSObject *v57;
  std::logic_error *v58;
  NSObject *v59;
  std::logic_error *v60;
  uint64_t v61;
  std::__shared_weak_count *v62;
  uint64_t v63;
  std::__shared_weak_count *v64;
  uint64_t v65;
  std::__shared_weak_count *v66;
  uint64_t v67[2];
  _BYTE buf[18];
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (!*a2)
  {
    v55 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "JobManagerDispatch.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 221;
      _os_log_impl(&dword_2164CC000, v55, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInReplacement is false.", buf, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "PRECONDITION: nullptr != pInReplacement is false.");
  }
  v6 = *(Phase::Job **)a3;
  if (!*(_QWORD *)a3)
  {
    v57 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "JobManagerDispatch.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 222;
      _os_log_impl(&dword_2164CC000, v57, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInDependent is false.", buf, 0x12u);
    }
    v58 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v58, "PRECONDITION: nullptr != pInDependent is false.");
  }
  v8 = *a4;
  if (!*a4)
  {
    v59 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "JobManagerDispatch.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 223;
      _os_log_impl(&dword_2164CC000, v59, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInDependency is false.", buf, 0x12u);
    }
    v60 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v60, "PRECONDITION: nullptr != pInDependency is false.");
  }
  v11 = *(std::__shared_weak_count **)(a3 + 8);
  v67[0] = *(_QWORD *)a3;
  v67[1] = (uint64_t)v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }
  Phase::JobManager::TreeLock::TreeLock(buf, a1, v67);
  if (v11)
  {
    v14 = (unint64_t *)&v11->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v16 = *(_QWORD *)(Phase::JobManager::GetDependencies(a1, v6) + 8);
  Dependencies = Phase::JobManager::GetDependencies(a1, v6);
  if (v16 != Dependencies)
  {
    while (*(Phase::Job **)(v16 + 16) != *a4)
    {
      v16 = *(_QWORD *)(v16 + 8);
      if (v16 == Dependencies)
      {
        v16 = Dependencies;
        break;
      }
    }
  }
  if (Phase::JobManager::GetDependencies(a1, v6) != v16)
  {
    v18 = *(_DWORD *)(v4 + 524);
    if (v18 <= *((_DWORD *)v8 + 131))
      v18 = *((_DWORD *)v8 + 131);
    *(_DWORD *)(v4 + 524) = v18;
    atomic_store(1u, (unsigned __int8 *)(v4 + 40));
    std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(v16 + 16), a2);
    Dependents = Phase::JobManager::GetDependents(a1, v8);
    v20 = *(std::__shared_weak_count **)(a3 + 8);
    v65 = *(_QWORD *)a3;
    v66 = v20;
    if (v20)
    {
      p_shared_weak_owners = (unint64_t *)&v20->__shared_weak_owners_;
      do
        v22 = __ldxr(p_shared_weak_owners);
      while (__stxr(v22 + 1, p_shared_weak_owners));
    }
    std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::__erase_unique<std::weak_ptr<Phase::Job>>(Dependents, (uint64_t)&v65);
    if (v66)
      std::__shared_weak_count::__release_weak(v66);
    v23 = (uint64_t **)Phase::JobManager::GetDependents(a1, (Phase::Job *)v4);
    v24 = *(std::__shared_weak_count **)(a3 + 8);
    v65 = *(_QWORD *)a3;
    v66 = v24;
    if (v24)
    {
      v25 = (unint64_t *)&v24->__shared_weak_owners_;
      do
        v26 = __ldxr(v25);
      while (__stxr(v26 + 1, v25));
    }
    std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::__emplace_unique_key_args<std::weak_ptr<Phase::Job>,std::weak_ptr<Phase::Job>>(v23, (uint64_t)&v65, (uint64_t)&v65);
    if (v66)
      std::__shared_weak_count::__release_weak(v66);
    v27 = atomic_load((unsigned int *)Phase::JobManager::GetExecutionState(a1, v8));
    if (v27 != 1)
      goto LABEL_62;
    v28 = a2[1];
    v63 = *a2;
    v64 = (std::__shared_weak_count *)v28;
    if (v28)
    {
      v29 = (unint64_t *)(v28 + 8);
      do
        v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
    }
    v31 = Phase::JobManagerDispatch::PrepareJobForExecution(a1, &v63);
    v32 = v31;
    v33 = v64;
    if (!v64)
      goto LABEL_37;
    v34 = (unint64_t *)&v64->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
      if (v32)
        goto LABEL_38;
    }
    else
    {
LABEL_37:
      if (v31)
      {
LABEL_38:
        v36 = Phase::JobManager::GetDependencies(a1, (Phase::Job *)v4);
        for (i = *(_QWORD **)(v36 + 8); i != (_QWORD *)v36; i = (_QWORD *)i[1])
        {
          v39 = i[2];
          v38 = (std::__shared_weak_count *)i[3];
          v65 = v39;
          v66 = v38;
          if (v38)
          {
            v40 = (unint64_t *)&v38->__shared_owners_;
            do
              v41 = __ldxr(v40);
            while (__stxr(v41 + 1, v40));
            dispatch_group_enter(*(dispatch_group_t *)(v4 + 584));
            v62 = v38;
            do
              v42 = __ldxr(v40);
            while (__stxr(v42 + 1, v40));
          }
          else
          {
            dispatch_group_enter(*(dispatch_group_t *)(v4 + 584));
            v62 = 0;
          }
          v61 = v39;
          Phase::JobManagerDispatch::doRunJob(a1, &v61, 0.0);
          if (v38)
          {
            v43 = (unint64_t *)&v38->__shared_owners_;
            do
              v44 = __ldaxr(v43);
            while (__stlxr(v44 - 1, v43));
            if (!v44)
            {
              ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
              std::__shared_weak_count::__release_weak(v38);
            }
          }
          v45 = v66;
          if (v66)
          {
            v46 = &v66->__shared_owners_;
            do
              v47 = __ldaxr((unint64_t *)v46);
            while (__stlxr(v47 - 1, (unint64_t *)v46));
            if (!v47)
            {
              ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
              std::__shared_weak_count::__release_weak(v45);
            }
          }
        }
        if (!*(_DWORD *)(v4 + 528))
        {
          *(_QWORD *)(v4 + 592) |= 4uLL;
          v49 = *(NSObject **)(v4 + 584);
          ConcurrentQueue = Phase::JobManagerDispatch::GetConcurrentQueue(a1, *(_DWORD *)(v4 + 524));
          dispatch_group_notify(v49, ConcurrentQueue, *(dispatch_block_t *)(v4 + 576));
        }
      }
    }
LABEL_62:
    v48 = 0;
    goto LABEL_63;
  }
  v48 = 2;
LABEL_63:
  std::recursive_mutex::unlock((std::recursive_mutex *)(*(_QWORD *)buf + 96));
  v51 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v52 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }
  return v48;
}

void sub_2165EFD34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, std::__shared_weak_count *a14, char a15, uint64_t a16, uint64_t a17)
{
  std::recursive_mutex::unlock((std::recursive_mutex *)(a17 + 96));
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void ___ZN5Phase18JobManagerDispatch22PrepareJobForExecutionENSt3__110shared_ptrINS_3JobEEE_block_invoke(uint64_t a1)
{
  Phase::JobManager *v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unsigned int *ExecutionState;
  _QWORD *Dependents;
  _QWORD *v8;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  BOOL v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;

  v1 = *(Phase::JobManager **)(a1 + 40);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v23 = 0;
  v3 = *(std::__shared_weak_count **)(v2 + 48);
  if (v3)
  {
    v23 = std::__shared_weak_count::lock(v3);
    if (v23)
    {
      v4 = *(_QWORD *)(v2 + 40);
      if (v4)
      {
        ExecutionState = (unsigned int *)Phase::JobManager::GetExecutionState(v1, (Phase::Job *)v4);
        do
        {
          if (__ldaxr(ExecutionState))
          {
            __clrex();
            goto LABEL_27;
          }
        }
        while (__stlxr(1u, ExecutionState));
        Phase::Job::Run((Phase::Job *)v4);
        atomic_store(2u, (unsigned int *)Phase::JobManager::GetExecutionState(v1, (Phase::Job *)v4));
        *(_QWORD *)(v4 + 592) |= 8uLL;
        atomic_store(1u, (unsigned __int8 *)(v4 + 600));
        std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)(v4 + 608));
        Dependents = (_QWORD *)Phase::JobManager::GetDependents(v1, (Phase::Job *)v4);
        v8 = Dependents + 1;
        v9 = (_QWORD *)*Dependents;
        if ((_QWORD *)*Dependents != Dependents + 1)
        {
          do
          {
            v10 = (std::__shared_weak_count *)v9[5];
            if (v10)
            {
              v11 = v9[4];
              p_shared_weak_owners = (unint64_t *)&v10->__shared_weak_owners_;
              do
                v13 = __ldxr(p_shared_weak_owners);
              while (__stxr(v13 + 1, p_shared_weak_owners));
              v14 = std::__shared_weak_count::lock(v10);
              if (v14)
              {
                v15 = v14;
                if (v11)
                  dispatch_group_leave(*(dispatch_group_t *)(v11 + 584));
                p_shared_owners = (unint64_t *)&v15->__shared_owners_;
                do
                  v17 = __ldaxr(p_shared_owners);
                while (__stlxr(v17 - 1, p_shared_owners));
                if (!v17)
                {
                  ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
                  std::__shared_weak_count::__release_weak(v15);
                }
              }
              std::__shared_weak_count::__release_weak(v10);
            }
            v18 = (_QWORD *)v9[1];
            if (v18)
            {
              do
              {
                v19 = v18;
                v18 = (_QWORD *)*v18;
              }
              while (v18);
            }
            else
            {
              do
              {
                v19 = (_QWORD *)v9[2];
                v20 = *v19 == (_QWORD)v9;
                v9 = v19;
              }
              while (!v20);
            }
            v9 = v19;
          }
          while (v19 != v8);
        }
      }
    }
  }
LABEL_27:
  if (v23)
  {
    v21 = (unint64_t *)&v23->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
}

void sub_2165EFFB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t Phase::JobManagerDispatch::RunManualJob(Phase::JobManager *a1, uint64_t *a2)
{
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unsigned int v10;
  NSObject *v11;
  NSObject *ConcurrentQueue;
  uint64_t v13;
  NSObject *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v19[2];
  __int128 v20;

  v4 = *a2;
  v5 = (std::__shared_weak_count *)a2[1];
  v19[0] = *a2;
  v19[1] = (uint64_t)v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  Phase::JobManager::TreeLock::TreeLock(&v20, a1, v19);
  if (v5)
  {
    v8 = (unint64_t *)&v5->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v10 = atomic_load((unsigned int *)Phase::JobManager::GetExecutionState(a1, (Phase::Job *)v4));
  if (v10 == 3 || (*(_QWORD *)(v4 + 592) & 0x16) != 2)
  {
    v13 = 3;
  }
  else
  {
    *(_QWORD *)(v4 + 592) |= 4uLL;
    if (*(_QWORD *)(Phase::JobManager::GetDependencies(a1, (Phase::Job *)v4) + 16))
    {
      v11 = *(NSObject **)(v4 + 584);
      ConcurrentQueue = Phase::JobManagerDispatch::GetConcurrentQueue(a1, *(_DWORD *)(*a2 + 524));
      dispatch_group_notify(v11, ConcurrentQueue, *(dispatch_block_t *)(v4 + 576));
    }
    else
    {
      v14 = Phase::JobManagerDispatch::GetConcurrentQueue(a1, *(_DWORD *)(*a2 + 524));
      dispatch_async(v14, *(dispatch_block_t *)(v4 + 576));
    }
    v13 = 0;
  }
  std::recursive_mutex::unlock((std::recursive_mutex *)(v20 + 96));
  v15 = (std::__shared_weak_count *)*((_QWORD *)&v20 + 1);
  if (*((_QWORD *)&v20 + 1))
  {
    v16 = (unint64_t *)(*((_QWORD *)&v20 + 1) + 8);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  return v13;
}

void sub_2165F0140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t Phase::JobManagerDispatch::RunJob(Phase::JobManager *a1, uint64_t a2, double a3)
{
  Phase::Logger *Dependents;
  Phase::Job *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  int v11;
  unint64_t *v12;
  unint64_t v13;
  NSObject *v15;
  std::logic_error *exception;
  uint64_t v17[2];
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  Dependents = (Phase::Logger *)Phase::JobManager::GetDependents(a1, *(Phase::Job **)a2);
  if (*((_QWORD *)Dependents + 2))
  {
    v15 = **(NSObject ***)(Phase::Logger::GetInstancePtr(Dependents) + 464);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v19 = "JobManagerDispatch.cpp";
      v20 = 1024;
      v21 = 389;
      _os_log_impl(&dword_2164CC000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: GetDependents(static_cast<JobDispatch*>(pInJob.get())).empty() is false.", buf, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "PRECONDITION: GetDependents(static_cast<JobDispatch*>(pInJob.get())).empty() is false.");
  }
  v7 = *(Phase::Job **)a2;
  v8 = *(std::__shared_weak_count **)(a2 + 8);
  v17[0] = (uint64_t)v7;
  v17[1] = (uint64_t)v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v11 = Phase::JobManagerDispatch::doRunJob(a1, v17, a3);
  if (v8)
  {
    v12 = (unint64_t *)&v8->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return 2 * (v11 == 0);
}

void sub_2165F02EC(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void ___ZN5Phase18JobManagerDispatch8doRunJobENSt3__110shared_ptrINS_3JobEEEd_block_invoke(_QWORD *a1)
{
  unsigned __int8 *v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  Phase::Logger *v6;
  uint64_t v7;
  unsigned __int8 v8;
  unsigned __int8 v9;
  double v10;
  long double v11;
  long double v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  NSObject *v24;
  std::runtime_error *exception;
  uint64_t v26;
  std::__shared_weak_count *v27;
  _BYTE buf[18];
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v1 = (unsigned __int8 *)a1[4];
  v2 = a1[5];
  v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  std::mutex::lock((std::mutex *)(v2 + 632));
  v7 = *(_QWORD *)(v2 + 624);
  if (v7)
  {
    v8 = atomic_load((unsigned __int8 *)(v7 + 25));
    if ((v8 & 1) != 0 || (v9 = atomic_load(v1 + 220), (v9 & 1) != 0))
    {
      atomic_store(0, (unsigned __int8 *)(v7 + 24));
      std::condition_variable::notify_all((std::condition_variable *)(v7 + 32));
    }
    else
    {
      v10 = (double)std::chrono::steady_clock::now().__d_.__rep_ / 1000000000.0;
      v11 = *(double *)v7;
      v12 = v10 - (*(double *)(v7 + 8) + *(double *)(v7 + 16));
      *(double *)(v7 + 8) = v10;
      *(long double *)(v7 + 16) = v11 - fmod(v12, v11);
      *(_QWORD *)buf = v2;
      *(_QWORD *)&buf[8] = v3;
      if (v3)
      {
        v13 = (unint64_t *)&v3->__shared_owners_;
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
      }
      Phase::JobManagerDispatch::ResetJob((Phase::JobManager *)v1, (uint64_t *)buf);
      if (v3)
      {
        v15 = (unint64_t *)&v3->__shared_owners_;
        do
          v16 = __ldaxr(v15);
        while (__stlxr(v16 - 1, v15));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
          std::__shared_weak_count::__release_weak(v3);
        }
      }
      v26 = v2;
      v27 = v3;
      if (v3)
      {
        v17 = (unint64_t *)&v3->__shared_owners_;
        do
          v18 = __ldxr(v17);
        while (__stxr(v18 + 1, v17));
      }
      (*(void (**)(unsigned __int8 *, uint64_t *, double))(*(_QWORD *)v1 + 120))(v1, &v26, *(double *)(v7 + 16));
      v19 = v27;
      if (v27)
      {
        v20 = (unint64_t *)&v27->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }
    }
  }
  else if ((*(_BYTE *)(v2 + 592) & 0x10) == 0)
  {
    v24 = **(NSObject ***)(Phase::Logger::GetInstancePtr(v6) + 464);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "JobManagerDispatch.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 638;
      _os_log_impl(&dword_2164CC000, v24, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [!pJob->mRunState[JobDispatch::kRunStateCancelled] is true]: \"Unexpected periodic job state on iteration.\"", buf, 0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Unexpected periodic job state on iteration.");
  }
  std::mutex::unlock((std::mutex *)(v2 + 632));
  if (v3)
  {
    v22 = (unint64_t *)&v3->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_2165F05FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  std::mutex *v13;

  std::mutex::unlock(v13);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_40c38_ZTSNSt3__110shared_ptrIN5Phase3JobEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_e8_40c38_ZTSNSt3__110shared_ptrIN5Phase3JobEEE(uint64_t a1)
{
  return std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](a1 + 40);
}

void Phase::JobManagerDispatch::ScheduleJobs(Phase::Logger *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  NSObject *v18;
  std::logic_error *exception;
  uint64_t v20[3];
  uint64_t v21[2];
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a2 + 16) != *(_QWORD *)(a3 + 16))
  {
    v18 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v23 = "JobManagerDispatch.cpp";
      v24 = 1024;
      v25 = 459;
      _os_log_impl(&dword_2164CC000, v18, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: inJobs.size() == inPeriodsSeconds.size() is false.", buf, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "PRECONDITION: inJobs.size() == inPeriodsSeconds.size() is false.");
  }
  v6 = *(_QWORD **)(a2 + 8);
  if (v6 != (_QWORD *)a2)
  {
    v7 = a3;
    do
    {
      v7 = *(_QWORD *)(v7 + 8);
      v9 = v6[2];
      v10 = operator new();
      *(_QWORD *)v10 = *(_QWORD *)(v7 + 16);
      *(_WORD *)(v10 + 24) = 0;
      *(_QWORD *)(v10 + 8) = 0;
      *(_QWORD *)(v10 + 16) = 0;
      *(_QWORD *)(v10 + 32) = 1018212795;
      *(_QWORD *)(v10 + 72) = 0;
      *(_OWORD *)(v10 + 56) = 0u;
      *(_OWORD *)(v10 + 40) = 0u;
      std::unique_ptr<Phase::JobDispatch::Schedule>::reset[abi:ne180100]((uint64_t *)(v9 + 624), v10);
      v11 = *(_QWORD *)(v9 + 624);
      atomic_store(1u, (unsigned __int8 *)(v11 + 24));
      *(double *)(v11 + 8) = (double)std::chrono::steady_clock::now().__d_.__rep_ / 1000000000.0;
      v12 = (std::__shared_weak_count *)v6[3];
      v21[0] = v6[2];
      v21[1] = (uint64_t)v12;
      if (v12)
      {
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          v14 = __ldxr(p_shared_owners);
        while (__stxr(v14 + 1, p_shared_owners));
      }
      Phase::JobManager::RunJobAsync((uint64_t)a1, v21);
      if (v12)
      {
        v15 = (unint64_t *)&v12->__shared_owners_;
        do
          v16 = __ldaxr(v15);
        while (__stlxr(v16 - 1, v15));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      v6 = (_QWORD *)v6[1];
    }
    while (v6 != (_QWORD *)a2);
  }
  if (*(_QWORD *)(a4 + 24))
  {
    std::list<std::shared_ptr<Phase::Job>>::list(v20, a2);
    buf[0] = 1;
    v17 = *(_QWORD *)(a4 + 24);
    if (!v17)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, uint8_t *, uint64_t *))(*(_QWORD *)v17 + 48))(v17, buf, v20);
    std::__list_imp<std::shared_ptr<Phase::Job>>::clear(v20);
  }
}

void sub_2165F08E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13)
{
  void *v13;

  __cxa_free_exception(v13);
  _Unwind_Resume(a1);
}

void Phase::JobManagerDispatch::StopScheduledJob(Phase::Logger *a1, uint64_t *a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned __int8 v7;
  uint64_t i;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t v13;
  Phase::Logger *v14;
  Phase::Logger *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  NSObject *v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unsigned __int8 v23;
  unsigned __int8 v24;
  NSObject *v25;
  std::logic_error *exception;
  uint64_t v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  std::unique_lock<std::mutex> __lk;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  int v35;
  uint8_t v36[4];
  _BYTE v37[14];
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v3 = *a2;
  v4 = *(_QWORD *)(*a2 + 624);
  if (!v4)
  {
    v25 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v36 = 136315394;
      *(_QWORD *)v37 = "JobManagerDispatch.cpp";
      *(_WORD *)&v37[8] = 1024;
      *(_DWORD *)&v37[10] = 491;
      _os_log_impl(&dword_2164CC000, v25, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: pJob->mSchedule is false.", v36, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "PRECONDITION: pJob->mSchedule is false.");
  }
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v3 + 632);
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)(v3 + 632));
  v7 = atomic_load((unsigned __int8 *)(v4 + 24));
  if ((v7 & 1) != 0)
  {
    atomic_store(1u, (unsigned __int8 *)(v4 + 25));
    if (a3)
    {
      Phase::JobManagerDispatch::doCancelJob((Phase::JobManagerDispatch *)v36, a1, v3, 0);
      for (i = *(_QWORD *)&v37[4]; (uint8_t *)i != v36; i = *(_QWORD *)(i + 8))
      {
        v9 = *(_QWORD *)(i + 16);
        v10 = *(std::__shared_weak_count **)(i + 24);
        v29 = v9;
        v30 = v10;
        if (v10)
        {
          p_shared_owners = (unint64_t *)&v10->__shared_owners_;
          do
            v12 = __ldxr(p_shared_owners);
          while (__stxr(v12 + 1, p_shared_owners));
          v28 = v10;
          do
            v13 = __ldxr(p_shared_owners);
          while (__stxr(v13 + 1, p_shared_owners));
        }
        else
        {
          v28 = 0;
        }
        v27 = v9;
        v14 = (Phase::Logger *)(*(uint64_t (**)(Phase::Logger *, uint64_t *, double))(*(_QWORD *)a1 + 96))(a1, &v27, 0.0);
        v15 = v14;
        v16 = v28;
        if (v28)
        {
          v17 = (unint64_t *)&v28->__shared_owners_;
          do
            v18 = __ldaxr(v17);
          while (__stlxr(v18 - 1, v17));
          if (!v18)
          {
            ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
            std::__shared_weak_count::__release_weak(v16);
          }
        }
        if (!((unint64_t)v15 >> 32))
        {
          if ((_DWORD)v15)
          {
            v19 = **(NSObject ***)(Phase::Logger::GetInstancePtr(v14) + 464);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315394;
              v33 = "JobManagerDispatch.cpp";
              v34 = 1024;
              v35 = 514;
              _os_log_impl(&dword_2164CC000, v19, OS_LOG_TYPE_ERROR, "%25s:%-5d Couldn't wait on running job.", buf, 0x12u);
            }
          }
        }
        v20 = v30;
        if (v30)
        {
          v21 = (unint64_t *)&v30->__shared_owners_;
          do
            v22 = __ldaxr(v21);
          while (__stlxr(v22 - 1, v21));
          if (!v22)
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
          }
        }
      }
      std::__list_imp<std::shared_ptr<Phase::Job>>::clear((uint64_t *)v36);
    }
    v23 = atomic_load((unsigned __int8 *)(v4 + 24));
    if ((v23 & 1) != 0)
    {
      do
      {
        std::condition_variable::wait((std::condition_variable *)(v4 + 32), &__lk);
        v24 = atomic_load((unsigned __int8 *)(v4 + 24));
      }
      while ((v24 & 1) != 0);
    }
    atomic_store(0, (unsigned __int8 *)(v4 + 25));
  }
  std::unique_ptr<Phase::JobDispatch::Schedule>::reset[abi:ne180100]((uint64_t *)(v3 + 624), 0);
  if (__lk.__owns_)
    std::mutex::unlock(__lk.__m_);
}

void sub_2165F0C44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, std::mutex *a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (a16)
    std::mutex::unlock(a15);
  _Unwind_Resume(exception_object);
}

void Phase::JobManagerDispatch::doCancelJob(Phase::JobManagerDispatch *this, Phase::JobDispatch *a2, uint64_t a3, int a4)
{
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  void *v11;
  unsigned int *ExecutionState;
  unsigned int v13;
  uint64_t Dependencies;
  _QWORD *i;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  _QWORD *Dependents;
  _QWORD *v28;
  _QWORD *v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  unint64_t *p_shared_weak_owners;
  unint64_t v33;
  std::__shared_weak_count *v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t *v46;
  unint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  BOOL v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  _QWORD *v56;
  std::__shared_weak_count *v57;
  uint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  std::__shared_weak_count *v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  _QWORD *v67;
  uint64_t v68;
  unsigned __int8 v69;
  uint64_t v70;
  _QWORD *v71;
  uint64_t v72;
  uint64_t v73;
  std::__shared_weak_count *v74;
  uint64_t v75;
  std::__shared_weak_count *v76;

  *(_QWORD *)this = this;
  *((_QWORD *)this + 1) = this;
  *((_QWORD *)this + 2) = 0;
  if ((*(_BYTE *)(a3 + 592) & 0x10) == 0)
  {
    v8 = *(std::__shared_weak_count **)(a3 + 616);
    v75 = *(_QWORD *)(a3 + 608);
    v76 = v8;
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v10 = __ldxr(p_shared_owners);
      while (__stxr(v10 + 1, p_shared_owners));
    }
    v11 = *(void **)(a3 + 576);
    if (v11)
    {
      dispatch_block_cancel(v11);
      ExecutionState = (unsigned int *)Phase::JobManager::GetExecutionState(a2, (Phase::Job *)a3);
      do
      {
        v13 = __ldaxr(ExecutionState);
        if (v13)
        {
          __clrex();
          atomic_store(3u, (unsigned int *)Phase::JobManager::GetExecutionState(a2, (Phase::Job *)a3));
          goto LABEL_15;
        }
      }
      while (__stlxr(3u, ExecutionState));
      if (!v76 || v76->__shared_owners_ <= 0)
        __assert_rtn("doCancelJob", "JobManagerDispatch.cpp", 682, "jobRef.use_count() > 1");
      atomic_store(1u, (unsigned __int8 *)(a3 + 600));
      std::shared_ptr<Phase::Job>::reset[abi:ne180100]((_QWORD *)(a3 + 608));
    }
    v13 = 0;
LABEL_15:
    *(_QWORD *)(a3 + 592) |= 0x10uLL;
    Dependencies = Phase::JobManager::GetDependencies(a2, (Phase::Job *)a3);
    for (i = *(_QWORD **)(Dependencies + 8); i != (_QWORD *)Dependencies; i = (_QWORD *)i[1])
    {
      v16 = i[2];
      v17 = (std::__shared_weak_count *)i[3];
      v73 = v16;
      v74 = v17;
      if (v17)
      {
        v18 = (unint64_t *)&v17->__shared_owners_;
        do
          v19 = __ldxr(v18);
        while (__stxr(v19 + 1, v18));
      }
      Phase::JobManagerDispatch::doCancelJob((Phase::JobManagerDispatch *)&v70, a2, v16);
      v20 = v72;
      if (v72)
      {
        v22 = v70;
        v21 = v71;
        v23 = *v71;
        *(_QWORD *)(v23 + 8) = *(_QWORD *)(v70 + 8);
        **(_QWORD **)(v22 + 8) = v23;
        v24 = *(_QWORD *)this;
        *(_QWORD *)(v24 + 8) = v21;
        *v21 = v24;
        *(_QWORD *)this = v22;
        *(_QWORD *)(v22 + 8) = this;
        *((_QWORD *)this + 2) += v20;
        v72 = 0;
      }
      std::__list_imp<std::shared_ptr<Phase::Job>>::clear(&v70);
      if (v17)
      {
        v25 = (unint64_t *)&v17->__shared_owners_;
        do
          v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
    }
    if (v13 == 1)
      std::list<std::shared_ptr<Phase::Job>>::push_back((uint64_t *)this, &v75);
    if (a4)
    {
      Dependents = (_QWORD *)Phase::JobManager::GetDependents(a2, (Phase::Job *)a3);
      v28 = Dependents + 1;
      v29 = (_QWORD *)*Dependents;
      if ((_QWORD *)*Dependents != Dependents + 1)
      {
        do
        {
          v31 = v29[4];
          v30 = (std::__shared_weak_count *)v29[5];
          p_shared_weak_owners = (unint64_t *)&v30->__shared_weak_owners_;
          do
            v33 = __ldxr(p_shared_weak_owners);
          while (__stxr(v33 + 1, p_shared_weak_owners));
          v34 = std::__shared_weak_count::lock(v30);
          v35 = v34;
          v36 = (unint64_t *)&v34->__shared_owners_;
          do
            v37 = __ldaxr(v36);
          while (__stlxr(v37 - 1, v36));
          if (!v37)
          {
            ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
            std::__shared_weak_count::__release_weak(v35);
          }
          v38 = *(std::__shared_weak_count **)(v31 + 616);
          v73 = *(_QWORD *)(v31 + 608);
          v74 = v38;
          if (v38)
          {
            v39 = (unint64_t *)&v38->__shared_owners_;
            do
              v40 = __ldxr(v39);
            while (__stxr(v40 + 1, v39));
          }
          Phase::JobManagerDispatch::doCancelJob((Phase::JobManagerDispatch *)&v70, a2, v31);
          v41 = v72;
          if (v72)
          {
            v43 = v70;
            v42 = v71;
            v44 = *v71;
            *(_QWORD *)(v44 + 8) = *(_QWORD *)(v70 + 8);
            **(_QWORD **)(v43 + 8) = v44;
            v45 = *(_QWORD *)this;
            *(_QWORD *)(v45 + 8) = v42;
            *v42 = v45;
            *(_QWORD *)this = v43;
            *(_QWORD *)(v43 + 8) = this;
            *((_QWORD *)this + 2) += v41;
            v72 = 0;
          }
          std::__list_imp<std::shared_ptr<Phase::Job>>::clear(&v70);
          if (v38)
          {
            v46 = (unint64_t *)&v38->__shared_owners_;
            do
              v47 = __ldaxr(v46);
            while (__stlxr(v47 - 1, v46));
            if (!v47)
            {
              ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
              std::__shared_weak_count::__release_weak(v38);
            }
          }
          std::__shared_weak_count::__release_weak(v30);
          v48 = (_QWORD *)v29[1];
          if (v48)
          {
            do
            {
              v49 = v48;
              v48 = (_QWORD *)*v48;
            }
            while (v48);
          }
          else
          {
            do
            {
              v49 = (_QWORD *)v29[2];
              v50 = *v49 == (_QWORD)v29;
              v29 = v49;
            }
            while (!v50);
          }
          v29 = v49;
        }
        while (v49 != v28);
      }
    }
    if (!v13)
    {
      v54 = (_QWORD *)Phase::JobManager::GetDependents(a2, (Phase::Job *)a3);
      v55 = v54 + 1;
      v56 = (_QWORD *)*v54;
      if ((_QWORD *)*v54 != v54 + 1)
      {
        do
        {
          v57 = (std::__shared_weak_count *)v56[5];
          if (v57)
          {
            v58 = v56[4];
            v59 = (unint64_t *)&v57->__shared_weak_owners_;
            do
              v60 = __ldxr(v59);
            while (__stxr(v60 + 1, v59));
            v61 = std::__shared_weak_count::lock(v57);
            if (v61)
            {
              v62 = v61;
              v63 = (unint64_t *)&v61->__shared_owners_;
              do
                v64 = __ldaxr(v63);
              while (__stlxr(v64 - 1, v63));
              if (!v64)
              {
                ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
                std::__shared_weak_count::__release_weak(v62);
              }
              v65 = v58 + 584;
            }
            else
            {
              v65 = 584;
            }
            dispatch_group_leave(*(dispatch_group_t *)v65);
            std::__shared_weak_count::__release_weak(v57);
          }
          else
          {
            dispatch_group_leave(MEMORY[0x248]);
          }
          v66 = (_QWORD *)v56[1];
          if (v66)
          {
            do
            {
              v67 = v66;
              v66 = (_QWORD *)*v66;
            }
            while (v66);
          }
          else
          {
            do
            {
              v67 = (_QWORD *)v56[2];
              v50 = *v67 == (_QWORD)v56;
              v56 = v67;
            }
            while (!v50);
          }
          v56 = v67;
        }
        while (v67 != v55);
      }
      v68 = *(_QWORD *)(a3 + 624);
      if (v68)
      {
        v69 = atomic_load((unsigned __int8 *)(v68 + 25));
        if ((v69 & 1) != 0)
          atomic_store(0, (unsigned __int8 *)(*(_QWORD *)(a3 + 624) + 24));
      }
    }
    v51 = v76;
    if (v76)
    {
      v52 = (unint64_t *)&v76->__shared_owners_;
      do
        v53 = __ldaxr(v52);
      while (__stlxr(v53 - 1, v52));
      if (!v53)
      {
        ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
        std::__shared_weak_count::__release_weak(v51);
      }
    }
  }
}

void sub_2165F1170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t *v7;
  va_list va;

  va_start(va, a7);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear(v7);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<Phase::JobDispatch::Schedule>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    std::condition_variable::~condition_variable((std::condition_variable *)(v2 + 32));
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

void Phase::JobManagerDispatch::StopScheduledJobs(uint64_t a1, _QWORD *a2, char a3)
{
  _QWORD *i;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  uint64_t v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t v41[2];
  uint64_t v42;
  std::__shared_weak_count *v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  void *__p[2];
  char v51;
  uint64_t v52;
  uint64_t v53;

  std::string::basic_string[abi:ne180100]<0>(__p, "StopScheduledJobsRoot");
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void **))(*(_QWORD *)a1 + 16))(&v52, a1, __p);
  if (v51 < 0)
    operator delete(__p[0]);
  for (i = (_QWORD *)a2[1]; i != a2; i = (_QWORD *)i[1])
  {
    v8 = i[2];
    v7 = (std::__shared_weak_count *)i[3];
    v48 = v8;
    v49 = v7;
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v10 = __ldxr(p_shared_owners);
      while (__stxr(v10 + 1, p_shared_owners));
    }
    std::string::basic_string[abi:ne180100]<0>(__p, "StopScheduledJob");
    (*(void (**)(uint64_t *__return_ptr, uint64_t, void **))(*(_QWORD *)a1 + 16))(&v46, a1, __p);
    if (v51 < 0)
      operator delete(__p[0]);
    v11 = v46;
    if (v7)
    {
      p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
      do
        v13 = __ldxr(p_shared_weak_owners);
      while (__stxr(v13 + 1, p_shared_weak_owners));
      do
        v14 = __ldxr(p_shared_weak_owners);
      while (__stxr(v14 + 1, p_shared_weak_owners));
      do
        v15 = __ldxr(p_shared_weak_owners);
      while (__stxr(v15 + 1, p_shared_weak_owners));
      *(_QWORD *)(v11 + 256) = &off_24D57E428;
      *(_QWORD *)(v11 + 264) = v8;
      *(_QWORD *)(v11 + 272) = v7;
      do
        v16 = __ldxr(p_shared_weak_owners);
      while (__stxr(v16 + 1, p_shared_weak_owners));
      *(_QWORD *)(v11 + 280) = a1;
      *(_BYTE *)(v11 + 288) = a3;
      std::__shared_weak_count::__release_weak(v7);
      *(_BYTE *)(v11 + 383) = 1;
      std::__shared_weak_count::__release_weak(v7);
      atomic_store(1u, (unsigned __int8 *)(v11 + 40));
      std::__shared_weak_count::__release_weak(v7);
    }
    else
    {
      *(_QWORD *)(v46 + 256) = &off_24D57E428;
      *(_QWORD *)(v11 + 264) = v8;
      *(_QWORD *)(v11 + 272) = 0;
      *(_QWORD *)(v11 + 280) = a1;
      *(_BYTE *)(v11 + 288) = a3;
      *(_BYTE *)(v11 + 383) = 1;
      atomic_store(1u, (unsigned __int8 *)(v11 + 40));
    }
    v44 = v52;
    v45 = (std::__shared_weak_count *)v53;
    if (v53)
    {
      v17 = (unint64_t *)(v53 + 8);
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
    }
    v42 = v46;
    v43 = v47;
    if (v47)
    {
      v19 = (unint64_t *)&v47->__shared_owners_;
      do
        v20 = __ldxr(v19);
      while (__stxr(v20 + 1, v19));
    }
    (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)a1 + 24))(a1, &v44, &v42);
    v21 = v43;
    if (v43)
    {
      v22 = (unint64_t *)&v43->__shared_owners_;
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    v24 = v45;
    if (v45)
    {
      v25 = (unint64_t *)&v45->__shared_owners_;
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    v27 = v47;
    if (v47)
    {
      v28 = (unint64_t *)&v47->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    v30 = v49;
    if (v49)
    {
      v31 = (unint64_t *)&v49->__shared_owners_;
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
  }
  v33 = (std::__shared_weak_count *)v53;
  v41[0] = v52;
  v41[1] = v53;
  if (v53)
  {
    v34 = (unint64_t *)(v53 + 8);
    do
      v35 = __ldxr(v34);
    while (__stxr(v35 + 1, v34));
  }
  Phase::JobManager::RunJob(a1, v41);
  if (v33)
  {
    v36 = (unint64_t *)&v33->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  v38 = (std::__shared_weak_count *)v53;
  if (v53)
  {
    v39 = (unint64_t *)(v53 + 8);
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
}

void sub_2165F157C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  uint64_t v25;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v25 - 96);
  _Unwind_Resume(a1);
}

void Phase::JobManagerDispatch::StopScheduledJobAsync(Phase::Logger *a1, _QWORD *a2, uint64_t a3, char a4)
{
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_weak_owners;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  __int128 v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  unint64_t *v46;
  unint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  NSObject *v54;
  std::logic_error *exception;
  uint64_t v56[2];
  __int128 v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  uint64_t v60[3];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  _BYTE v64[24];
  _BYTE *v65;
  void *v66;
  std::__shared_weak_count *v67;
  char v68;
  _BYTE buf[12];
  __int16 v70;
  int v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x24BDAC8D0];
  if (!*(_QWORD *)(*a2 + 624))
  {
    v54 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "JobManagerDispatch.cpp";
      v70 = 1024;
      v71 = 554;
      _os_log_impl(&dword_2164CC000, v54, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: pJob->mSchedule is false.", buf, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "PRECONDITION: pJob->mSchedule is false.");
  }
  std::string::basic_string[abi:ne180100]<0>(buf, "StopScheduledJobAsync");
  (*(void (**)(__int128 *__return_ptr, Phase::Logger *, _BYTE *))(*(_QWORD *)a1 + 16))(&v63, a1, buf);
  if (v72 < 0)
    operator delete(*(void **)buf);
  v8 = (std::__shared_weak_count *)*((_QWORD *)&v63 + 1);
  v9 = v63;
  v62 = v63;
  if (*((_QWORD *)&v63 + 1))
  {
    v10 = (unint64_t *)(*((_QWORD *)&v63 + 1) + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  v12 = *a2;
  v13 = (std::__shared_weak_count *)a2[1];
  if (v13)
  {
    p_shared_weak_owners = (unint64_t *)&v13->__shared_weak_owners_;
    do
      v15 = __ldxr(p_shared_weak_owners);
    while (__stxr(v15 + 1, p_shared_weak_owners));
    do
      v16 = __ldxr(p_shared_weak_owners);
    while (__stxr(v16 + 1, p_shared_weak_owners));
    do
      v17 = __ldxr(p_shared_weak_owners);
    while (__stxr(v17 + 1, p_shared_weak_owners));
    *(_QWORD *)(v9 + 256) = &off_24D57E450;
    *(_QWORD *)(v9 + 264) = v12;
    *(_QWORD *)(v9 + 272) = v13;
    do
      v18 = __ldxr(p_shared_weak_owners);
    while (__stxr(v18 + 1, p_shared_weak_owners));
    *(_QWORD *)(v9 + 280) = a1;
    *(_BYTE *)(v9 + 288) = a4;
    std::__shared_weak_count::__release_weak(v13);
    *(_BYTE *)(v9 + 383) = 1;
    std::__shared_weak_count::__release_weak(v13);
    atomic_store(1u, (unsigned __int8 *)(v9 + 40));
    std::__shared_weak_count::__release_weak(v13);
  }
  else
  {
    *(_QWORD *)(v9 + 256) = &off_24D57E450;
    *(_QWORD *)(v9 + 264) = v12;
    *(_QWORD *)(v9 + 272) = 0;
    *(_QWORD *)(v9 + 280) = a1;
    *(_BYTE *)(v9 + 288) = a4;
    *(_BYTE *)(v9 + 383) = 1;
    atomic_store(1u, (unsigned __int8 *)(v9 + 40));
  }
  if (*(_QWORD *)(a3 + 24))
  {
    v19 = (std::__shared_weak_count *)a2[1];
    v66 = (void *)*a2;
    v67 = v19;
    if (v19)
    {
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        v21 = __ldxr(p_shared_owners);
      while (__stxr(v21 + 1, p_shared_owners));
    }
    std::list<std::shared_ptr<Phase::Job>>::list((uint64_t *)buf, &v66, 1);
    v22 = v67;
    if (v67)
    {
      v23 = (unint64_t *)&v67->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    std::string::basic_string[abi:ne180100]<0>(&v66, "StopScheduledJobAsyncCallback");
    (*(void (**)(__int128 *__return_ptr, Phase::Logger *, void **))(*(_QWORD *)a1 + 16))(&v61, a1, &v66);
    v25 = v61;
    v61 = 0uLL;
    v62 = v25;
    if (v8)
    {
      v26 = (unint64_t *)&v8->__shared_owners_;
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    v28 = (std::__shared_weak_count *)*((_QWORD *)&v61 + 1);
    if (*((_QWORD *)&v61 + 1))
    {
      v29 = (unint64_t *)(*((_QWORD *)&v61 + 1) + 8);
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    if (v68 < 0)
      operator delete(v66);
    v31 = v62;
    std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v64, a3);
    std::list<std::shared_ptr<Phase::Job>>::list(v60, (uint64_t)buf);
    Phase::Job::SetTaskFunction<std::function<void ()(BOOL,std::list<std::shared_ptr<Phase::Job>>)>,BOOL,std::list<std::shared_ptr<Phase::Job>>>(v31, (uint64_t)v64, (uint64_t)v60);
    std::__list_imp<std::shared_ptr<Phase::Job>>::clear(v60);
    v32 = v65;
    if (v65 == v64)
    {
      v33 = 4;
      v32 = v64;
    }
    else
    {
      if (!v65)
      {
LABEL_42:
        v58 = v31;
        v59 = (std::__shared_weak_count *)*((_QWORD *)&v62 + 1);
        if (*((_QWORD *)&v62 + 1))
        {
          v34 = (unint64_t *)(*((_QWORD *)&v62 + 1) + 8);
          do
            v35 = __ldxr(v34);
          while (__stxr(v35 + 1, v34));
        }
        v57 = v63;
        if (*((_QWORD *)&v63 + 1))
        {
          v36 = (unint64_t *)(*((_QWORD *)&v63 + 1) + 8);
          do
            v37 = __ldxr(v36);
          while (__stxr(v37 + 1, v36));
        }
        (*(void (**)(Phase::Logger *, uint64_t *, __int128 *))(*(_QWORD *)a1 + 24))(a1, &v58, &v57);
        v38 = (std::__shared_weak_count *)*((_QWORD *)&v57 + 1);
        if (*((_QWORD *)&v57 + 1))
        {
          v39 = (unint64_t *)(*((_QWORD *)&v57 + 1) + 8);
          do
            v40 = __ldaxr(v39);
          while (__stlxr(v40 - 1, v39));
          if (!v40)
          {
            ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
            std::__shared_weak_count::__release_weak(v38);
          }
        }
        v41 = v59;
        if (v59)
        {
          v42 = (unint64_t *)&v59->__shared_owners_;
          do
            v43 = __ldaxr(v42);
          while (__stlxr(v43 - 1, v42));
          if (!v43)
          {
            ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
            std::__shared_weak_count::__release_weak(v41);
          }
        }
        std::__list_imp<std::shared_ptr<Phase::Job>>::clear((uint64_t *)buf);
        v8 = (std::__shared_weak_count *)*((_QWORD *)&v62 + 1);
        v9 = v62;
        goto LABEL_59;
      }
      v33 = 5;
    }
    (*(void (**)(void))(*v32 + 8 * v33))();
    goto LABEL_42;
  }
LABEL_59:
  v56[0] = v9;
  v56[1] = (uint64_t)v8;
  if (v8)
  {
    v44 = (unint64_t *)&v8->__shared_owners_;
    do
      v45 = __ldxr(v44);
    while (__stxr(v45 + 1, v44));
  }
  Phase::JobManager::RunJobAsync((uint64_t)a1, v56);
  if (v8)
  {
    v46 = (unint64_t *)&v8->__shared_owners_;
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v48 = (std::__shared_weak_count *)*((_QWORD *)&v62 + 1);
  if (*((_QWORD *)&v62 + 1))
  {
    v49 = (unint64_t *)(*((_QWORD *)&v62 + 1) + 8);
    do
      v50 = __ldaxr(v49);
    while (__stlxr(v50 - 1, v49));
    if (!v50)
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
  }
  v51 = (std::__shared_weak_count *)*((_QWORD *)&v63 + 1);
  if (*((_QWORD *)&v63 + 1))
  {
    v52 = (unint64_t *)(*((_QWORD *)&v63 + 1) + 8);
    do
      v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }
}

void sub_2165F1B44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  void *v29;

  __cxa_free_exception(v29);
  _Unwind_Resume(a1);
}

_QWORD *Phase::Job::SetTaskFunction<std::function<void ()(BOOL,std::list<std::shared_ptr<Phase::Job>>)>,BOOL,std::list<std::shared_ptr<Phase::Job>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *result;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD v18[3];
  _QWORD *v19;
  _QWORD v20[3];
  _QWORD *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v18, a2);
  std::list<std::shared_ptr<Phase::Job>>::list(&v15, a3);
  v5 = v19;
  if (!v19)
  {
    v21 = 0;
    *(_QWORD *)(a1 + 256) = &off_24D57E478;
LABEL_9:
    *(_QWORD *)(a1 + 288) = v5;
    goto LABEL_10;
  }
  if (v19 == v18)
  {
    v21 = v20;
    (*(void (**)(_QWORD *, _QWORD *))(v18[0] + 24))(v18, v20);
    v5 = v21;
  }
  else
  {
    v5 = (_QWORD *)(*(uint64_t (**)(void))(*v19 + 16))();
    v21 = v5;
  }
  *(_QWORD *)(a1 + 256) = &off_24D57E478;
  if (!v5)
    goto LABEL_9;
  if (v5 != v20)
  {
    v5 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v5 + 16))(v5);
    goto LABEL_9;
  }
  *(_QWORD *)(a1 + 288) = a1 + 264;
  (*(void (**)(_QWORD *))(v20[0] + 24))(v20);
LABEL_10:
  *(_BYTE *)(a1 + 296) = 1;
  *(_QWORD *)(a1 + 304) = a1 + 304;
  *(_QWORD *)(a1 + 312) = a1 + 304;
  *(_QWORD *)(a1 + 320) = 0;
  v6 = v17;
  if (v17)
  {
    v8 = v15;
    v7 = v16;
    v9 = *v16;
    *(_QWORD *)(v9 + 8) = *(_QWORD *)(v15 + 8);
    **(_QWORD **)(v8 + 8) = v9;
    v10 = *(_QWORD *)(a1 + 304);
    *(_QWORD *)(v10 + 8) = v7;
    *v7 = v10;
    *(_QWORD *)(a1 + 304) = v8;
    *(_QWORD *)(v8 + 8) = a1 + 304;
    *(_QWORD *)(a1 + 320) = v6;
    v17 = 0;
  }
  v11 = v21;
  if (v21 == v20)
  {
    v12 = 4;
    v11 = v20;
  }
  else
  {
    if (!v21)
      goto LABEL_17;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_17:
  *(_BYTE *)(a1 + 383) = 1;
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear(&v15);
  result = v19;
  if (v19 == v18)
  {
    v14 = 4;
    result = v18;
    goto LABEL_21;
  }
  if (v19)
  {
    v14 = 5;
LABEL_21:
    result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v14))();
  }
  atomic_store(1u, (unsigned __int8 *)(a1 + 40));
  return result;
}

void sub_2165F1E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char *a15, char a16, uint64_t a17, uint64_t a18, char *a19)
{
  char *v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;

  v20 = a19;
  if (a19 == &a16)
  {
    v21 = 4;
    v20 = &a16;
  }
  else
  {
    if (!a19)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
LABEL_6:
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear(&a9);
  v22 = a15;
  if (a15 == &a12)
  {
    v23 = 4;
    v22 = &a12;
  }
  else
  {
    if (!a15)
      goto LABEL_11;
    v23 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v22 + 8 * v23))();
LABEL_11:
  _Unwind_Resume(a1);
}

void Phase::JobManagerDispatch::StopScheduledJobsAsync(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  Phase::Logger *v8;
  _QWORD *i;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  uint64_t v14;
  unint64_t *p_shared_weak_owners;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  NSObject *v47;
  std::logic_error *exception;
  uint64_t v49;
  uint64_t v50[2];
  uint64_t v51[3];
  uint64_t v52;
  std::__shared_weak_count *v53;
  uint64_t v54;
  std::__shared_weak_count *v55;
  uint64_t v56;
  std::__shared_weak_count *v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  uint64_t v60;
  uint64_t v61;
  _BYTE v62[24];
  _BYTE *v63;
  _BYTE buf[12];
  __int16 v65;
  int v66;
  char v67;
  uint64_t v68;

  v68 = *MEMORY[0x24BDAC8D0];
  std::string::basic_string[abi:ne180100]<0>(buf, "StopScheduledJobsAsyncRoot");
  v8 = (Phase::Logger *)(*(_QWORD *(**)(uint64_t *__return_ptr, uint64_t, _BYTE *))(*(_QWORD *)a1 + 16))(&v60, a1, buf);
  v49 = a3;
  if (v67 < 0)
    operator delete(*(void **)buf);
  for (i = *(_QWORD **)(a2 + 8); i != (_QWORD *)a2; i = (_QWORD *)i[1])
  {
    v11 = i[2];
    v10 = (std::__shared_weak_count *)i[3];
    v58 = v11;
    v59 = v10;
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }
    if (!*(_QWORD *)(v11 + 624))
    {
      v47 = **(NSObject ***)(Phase::Logger::GetInstancePtr(v8) + 464);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "JobManagerDispatch.cpp";
        v65 = 1024;
        v66 = 585;
        _os_log_impl(&dword_2164CC000, v47, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: static_cast<JobDispatch*>(inJob.get())->mSchedule is false.", buf, 0x12u);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "PRECONDITION: static_cast<JobDispatch*>(inJob.get())->mSchedule is false.");
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8D0] + 16);
    }
    std::string::basic_string[abi:ne180100]<0>(buf, "StopScheduledJobAsync");
    (*(void (**)(uint64_t *__return_ptr, uint64_t, _BYTE *))(*(_QWORD *)a1 + 16))(&v56, a1, buf);
    if (v67 < 0)
      operator delete(*(void **)buf);
    v14 = v56;
    if (v10)
    {
      p_shared_weak_owners = (unint64_t *)&v10->__shared_weak_owners_;
      do
        v16 = __ldxr(p_shared_weak_owners);
      while (__stxr(v16 + 1, p_shared_weak_owners));
      do
        v17 = __ldxr(p_shared_weak_owners);
      while (__stxr(v17 + 1, p_shared_weak_owners));
      do
        v18 = __ldxr(p_shared_weak_owners);
      while (__stxr(v18 + 1, p_shared_weak_owners));
      *(_QWORD *)(v14 + 256) = &off_24D57E4A0;
      *(_QWORD *)(v14 + 264) = v11;
      *(_QWORD *)(v14 + 272) = v10;
      do
        v19 = __ldxr(p_shared_weak_owners);
      while (__stxr(v19 + 1, p_shared_weak_owners));
      *(_QWORD *)(v14 + 280) = a1;
      *(_BYTE *)(v14 + 288) = a4;
      std::__shared_weak_count::__release_weak(v10);
      *(_BYTE *)(v14 + 383) = 1;
      std::__shared_weak_count::__release_weak(v10);
      atomic_store(1u, (unsigned __int8 *)(v14 + 40));
      std::__shared_weak_count::__release_weak(v10);
    }
    else
    {
      *(_QWORD *)(v56 + 256) = &off_24D57E4A0;
      *(_QWORD *)(v14 + 264) = v11;
      *(_QWORD *)(v14 + 272) = 0;
      *(_QWORD *)(v14 + 280) = a1;
      *(_BYTE *)(v14 + 288) = a4;
      *(_BYTE *)(v14 + 383) = 1;
      atomic_store(1u, (unsigned __int8 *)(v14 + 40));
    }
    v54 = v60;
    v55 = (std::__shared_weak_count *)v61;
    if (v61)
    {
      v20 = (unint64_t *)(v61 + 8);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    v52 = v56;
    v53 = v57;
    if (v57)
    {
      v22 = (unint64_t *)&v57->__shared_owners_;
      do
        v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }
    v8 = (Phase::Logger *)(*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)a1 + 24))(a1, &v54, &v52);
    v24 = v53;
    if (v53)
    {
      v25 = (unint64_t *)&v53->__shared_owners_;
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    v27 = v55;
    if (v55)
    {
      v28 = (unint64_t *)&v55->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    v30 = v57;
    if (v57)
    {
      v31 = (unint64_t *)&v57->__shared_owners_;
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    v33 = v59;
    if (v59)
    {
      v34 = (unint64_t *)&v59->__shared_owners_;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
  }
  if (*(_QWORD *)(v49 + 24))
  {
    v36 = v60;
    std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v62, v49);
    std::list<std::shared_ptr<Phase::Job>>::list(v51, a2);
    Phase::Job::SetTaskFunction<std::function<void ()(BOOL,std::list<std::shared_ptr<Phase::Job>>)>,BOOL,std::list<std::shared_ptr<Phase::Job>>>(v36, (uint64_t)v62, (uint64_t)v51);
    std::__list_imp<std::shared_ptr<Phase::Job>>::clear(v51);
    v37 = v63;
    if (v63 == v62)
    {
      v38 = 4;
      v37 = v62;
    }
    else
    {
      if (!v63)
        goto LABEL_52;
      v38 = 5;
    }
    (*(void (**)(void))(*v37 + 8 * v38))();
  }
LABEL_52:
  v39 = (std::__shared_weak_count *)v61;
  v50[0] = v60;
  v50[1] = v61;
  if (v61)
  {
    v40 = (unint64_t *)(v61 + 8);
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
  }
  Phase::JobManager::RunJobAsync(a1, v50);
  if (v39)
  {
    v42 = (unint64_t *)&v39->__shared_owners_;
    do
      v43 = __ldaxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (!v43)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
  v44 = (std::__shared_weak_count *)v61;
  if (v61)
  {
    v45 = (unint64_t *)(v61 + 8);
    do
      v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }
}

void sub_2165F235C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char *a28)
{
  char *v29;
  uint64_t v30;

  std::__list_imp<std::shared_ptr<Phase::Job>>::clear(&a12);
  v29 = a28;
  if (a28 == &a25)
  {
    v30 = 4;
    v29 = &a25;
  }
  else
  {
    if (!a28)
      goto LABEL_6;
    v30 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v29 + 8 * v30))();
LABEL_6:
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a23);
  _Unwind_Resume(a1);
}

void Phase::JobManagerDispatch::ResetJob(Phase::JobManager *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  const void *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t Dependencies;
  _QWORD *i;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  _QWORD *Dependents;
  _QWORD *v26;
  _QWORD *v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  unint64_t *p_shared_weak_owners;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  BOOL v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  uint64_t v47[2];
  __int128 v48;

  v2 = *a2;
  v3 = *(_QWORD *)(*a2 + 592);
  if ((v3 & 0x1F) != 0)
  {
    v6 = *(const void **)(v2 + 576);
    *(_QWORD *)(v2 + 576) = 0;
    if (v6)
    {
      _Block_release(v6);
      v3 = *(_QWORD *)(v2 + 592);
    }
    *(_QWORD *)(v2 + 592) = v3 & 0xFFFFFFFFFFFFFFE0;
    atomic_store(0, (unsigned int *)Phase::JobManager::GetExecutionState(a1, (Phase::Job *)v2));
    atomic_store(0, (unsigned __int8 *)(v2 + 600));
    atomic_store(0, (unsigned __int8 *)(v2 + 601));
    v7 = *a2;
    v8 = (std::__shared_weak_count *)a2[1];
    v47[0] = v7;
    v47[1] = (uint64_t)v8;
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v10 = __ldxr(p_shared_owners);
      while (__stxr(v10 + 1, p_shared_owners));
    }
    Phase::JobManager::TreeLock::TreeLock(&v48, a1, v47);
    if (v8)
    {
      v11 = (unint64_t *)&v8->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    Dependencies = Phase::JobManager::GetDependencies(a1, (Phase::Job *)v2);
    for (i = *(_QWORD **)(Dependencies + 8); i != (_QWORD *)Dependencies; i = (_QWORD *)i[1])
    {
      v15 = i[2];
      v16 = (std::__shared_weak_count *)i[3];
      v45 = v15;
      v46 = v16;
      if (v16)
      {
        v17 = (unint64_t *)&v16->__shared_owners_;
        do
          v18 = __ldxr(v17);
        while (__stxr(v18 + 1, v17));
        v44 = v16;
        do
          v19 = __ldxr(v17);
        while (__stxr(v19 + 1, v17));
      }
      else
      {
        v44 = 0;
      }
      v43 = v15;
      Phase::JobManagerDispatch::ResetJob(a1, &v43);
      if (v16)
      {
        v20 = (unint64_t *)&v16->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      v22 = v46;
      if (v46)
      {
        v23 = (unint64_t *)&v46->__shared_owners_;
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
    }
    Dependents = (_QWORD *)Phase::JobManager::GetDependents(a1, (Phase::Job *)v2);
    v26 = Dependents + 1;
    v27 = (_QWORD *)*Dependents;
    if ((_QWORD *)*Dependents != Dependents + 1)
    {
      while (1)
      {
        v28 = (std::__shared_weak_count *)v27[5];
        if (v28)
        {
          v29 = v27[4];
          p_shared_weak_owners = (unint64_t *)&v28->__shared_weak_owners_;
          do
            v31 = __ldxr(p_shared_weak_owners);
          while (__stxr(v31 + 1, p_shared_weak_owners));
          v41 = 0;
          v32 = std::__shared_weak_count::lock(v28);
          v42 = v32;
          if (v32)
            v41 = v29;
        }
        else
        {
          v32 = 0;
          v41 = 0;
          v42 = 0;
        }
        Phase::JobManagerDispatch::ResetJob(a1, &v41);
        if (v32)
        {
          v33 = (unint64_t *)&v32->__shared_owners_;
          do
            v34 = __ldaxr(v33);
          while (__stlxr(v34 - 1, v33));
          if (!v34)
            break;
        }
        if (v28)
          goto LABEL_44;
LABEL_45:
        v35 = (_QWORD *)v27[1];
        if (v35)
        {
          do
          {
            v36 = v35;
            v35 = (_QWORD *)*v35;
          }
          while (v35);
        }
        else
        {
          do
          {
            v36 = (_QWORD *)v27[2];
            v37 = *v36 == (_QWORD)v27;
            v27 = v36;
          }
          while (!v37);
        }
        v27 = v36;
        if (v36 == v26)
          goto LABEL_54;
      }
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
      if (!v28)
        goto LABEL_45;
LABEL_44:
      std::__shared_weak_count::__release_weak(v28);
      goto LABEL_45;
    }
LABEL_54:
    std::recursive_mutex::unlock((std::recursive_mutex *)(v48 + 96));
    v38 = (std::__shared_weak_count *)*((_QWORD *)&v48 + 1);
    if (*((_QWORD *)&v48 + 1))
    {
      v39 = (unint64_t *)(*((_QWORD *)&v48 + 1) + 8);
      do
        v40 = __ldaxr(v39);
      while (__stlxr(v40 - 1, v39));
      if (!v40)
      {
        ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
        std::__shared_weak_count::__release_weak(v38);
      }
    }
  }
}

void sub_2165F2744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  std::recursive_mutex::unlock((std::recursive_mutex *)(a17 + 96));
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t Phase::JobManagerDispatch::CancelJob(Phase::JobManager *a1, uint64_t *a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  std::__shared_weak_count_vtbl *v20;
  uint64_t v21;
  unint64_t *v22;
  uint64_t *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v38;
  std::__shared_weak_count *v39;
  uint64_t v40;
  std::__shared_weak_count *v41;
  uint64_t v42;
  uint64_t v43[2];
  __int128 v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;

  v4 = *a2;
  v47 = (uint64_t)&v47;
  v48 = &v47;
  v49 = 0;
  if (*(_QWORD *)(v4 + 624))
  {
    v5 = a2[1];
    v45 = v4;
    v46 = (std::__shared_weak_count *)v5;
    if (v5)
    {
      v6 = (unint64_t *)(v5 + 8);
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
    (*(void (**)(Phase::JobManager *, uint64_t *, uint64_t))(*(_QWORD *)a1 + 64))(a1, &v45, 1);
    v8 = v46;
    if (v46)
    {
      p_shared_owners = (unint64_t *)&v46->__shared_owners_;
      do
        v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      goto LABEL_22;
    }
  }
  else
  {
    v12 = (std::__shared_weak_count *)a2[1];
    v43[0] = v4;
    v43[1] = (uint64_t)v12;
    if (v12)
    {
      v13 = (unint64_t *)&v12->__shared_owners_;
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    Phase::JobManager::TreeLock::TreeLock(&v44, a1, v43);
    if (v12)
    {
      v15 = (unint64_t *)&v12->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    Phase::JobManagerDispatch::doCancelJob((Phase::JobManagerDispatch *)&v40, a1, v4, a3);
    std::__list_imp<std::shared_ptr<Phase::Job>>::clear(&v47);
    v17 = v42;
    if (v42)
    {
      v19 = v40;
      v18 = (uint64_t *)v41;
      v20 = v41->__vftable;
      v20->~__shared_weak_count_0 = *(void (__cdecl **)(std::__shared_weak_count *__hidden))(v40 + 8);
      **(_QWORD **)(v19 + 8) = v20;
      v21 = v47;
      *(_QWORD *)(v47 + 8) = v18;
      *v18 = v21;
      *(_QWORD *)(v19 + 8) = &v47;
      v47 = v19;
      v49 += v17;
      v42 = 0;
    }
    std::__list_imp<std::shared_ptr<Phase::Job>>::clear(&v40);
    std::recursive_mutex::unlock((std::recursive_mutex *)(v44 + 96));
    v8 = (std::__shared_weak_count *)*((_QWORD *)&v44 + 1);
    if (*((_QWORD *)&v44 + 1))
    {
      v22 = (unint64_t *)(*((_QWORD *)&v44 + 1) + 8);
      do
        v10 = __ldaxr(v22);
      while (__stlxr(v10 - 1, v22));
LABEL_22:
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
  v23 = v48;
  if (v48 == &v47)
  {
    v36 = 0;
  }
  else
  {
    do
    {
      v24 = v23[2];
      v25 = (std::__shared_weak_count *)v23[3];
      v40 = v24;
      v41 = v25;
      if (v25)
      {
        v26 = (unint64_t *)&v25->__shared_owners_;
        do
          v27 = __ldxr(v26);
        while (__stxr(v27 + 1, v26));
        v39 = v25;
        do
          v28 = __ldxr(v26);
        while (__stxr(v28 + 1, v26));
      }
      else
      {
        v39 = 0;
      }
      v38 = v24;
      v29 = (*(uint64_t (**)(Phase::JobManager *, uint64_t *, double))(*(_QWORD *)a1 + 96))(a1, &v38, 0.0);
      v30 = v39;
      if (v39)
      {
        v31 = (unint64_t *)&v39->__shared_owners_;
        do
          v32 = __ldaxr(v31);
        while (__stlxr(v32 - 1, v31));
        if (!v32)
        {
          ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
          std::__shared_weak_count::__release_weak(v30);
        }
      }
      v33 = v41;
      if (v41)
      {
        v34 = (unint64_t *)&v41->__shared_owners_;
        do
          v35 = __ldaxr(v34);
        while (__stlxr(v35 - 1, v34));
        if (!v35)
        {
          ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
          std::__shared_weak_count::__release_weak(v33);
        }
      }
      v23 = (uint64_t *)v23[1];
    }
    while (v23 != &v47);
    if (HIDWORD(v29))
      v36 = 0;
    else
      v36 = v29;
  }
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear(&v47);
  return v36;
}

void sub_2165F2A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v16;

  std::recursive_mutex::unlock((std::recursive_mutex *)(a16 + 96));
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear((uint64_t *)(v16 - 72));
  _Unwind_Resume(a1);
}

uint64_t Phase::JobManagerDispatch::WaitForJob(Phase::JobManager *a1, Phase::Job **a2, double a3)
{
  Phase::Job *v3;
  unsigned __int8 v5;
  int64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 v8;
  dispatch_time_t v9;
  unsigned int v10;
  BOOL v11;
  unsigned int v12;

  v3 = *a2;
  if (*((_QWORD *)*a2 + 78))
    return 1;
  v5 = atomic_load((unsigned __int8 *)v3 + 600);
  if ((v5 & 1) != 0)
  {
    v10 = atomic_load((unsigned int *)Phase::JobManager::GetExecutionState(a1, *a2));
    v11 = v10 == 2;
  }
  else
  {
    if (!*((_QWORD *)v3 + 72))
      return 3;
    v6 = (unint64_t)(a3 * 1000000000.0);
    v7 = (unsigned __int8 *)v3 + 601;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(1u, v7));
    if ((v8 & 1) != 0)
      return 1;
    if (v6)
      v9 = dispatch_time(0, v6);
    else
      v9 = -1;
    v11 = dispatch_block_wait(*((dispatch_block_t *)v3 + 72), v9) == 0;
  }
  v12 = !v11;
  return 4 * v12;
}

uint64_t Phase::JobManagerDispatch::DestroyJob(Phase::JobManagerDispatch *this, Phase::Job *a2)
{
  uint64_t result;
  unsigned int *v4;
  unsigned int v5;

  result = Phase::JobManager::DestroyJob(this, a2);
  v4 = (unsigned int *)((char *)this + 216);
  do
    v5 = __ldaxr(v4);
  while (__stlxr(v5 - 1, v4));
  return result;
}

uint64_t Phase::JobManagerDispatch::PrepareJob(Phase::JobManager *a1, uint64_t *a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v25[2];
  uint64_t v26;
  std::__shared_weak_count *v27;
  uint64_t v28[2];
  __int128 v29;

  v4 = (std::__shared_weak_count *)a2[1];
  v28[0] = *a2;
  v28[1] = (uint64_t)v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  Phase::JobManager::TreeLock::TreeLock(&v29, a1, v28);
  if (v4)
  {
    v7 = (unint64_t *)&v4->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  v9 = a2[1];
  v26 = *a2;
  v27 = (std::__shared_weak_count *)v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  (*(void (**)(Phase::JobManager *, uint64_t *, double))(*(_QWORD *)a1 + 96))(a1, &v26, 0.0);
  v12 = v27;
  if (v27)
  {
    v13 = (unint64_t *)&v27->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = *a2;
  v16 = (std::__shared_weak_count *)a2[1];
  v25[0] = v15;
  v25[1] = (uint64_t)v16;
  if (v16)
  {
    v17 = (unint64_t *)&v16->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  Phase::JobManagerDispatch::ResetJob(a1, v25);
  if (v16)
  {
    v19 = (unint64_t *)&v16->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  std::recursive_mutex::unlock((std::recursive_mutex *)(v29 + 96));
  v21 = (std::__shared_weak_count *)*((_QWORD *)&v29 + 1);
  if (*((_QWORD *)&v29 + 1))
  {
    v22 = (unint64_t *)(*((_QWORD *)&v29 + 1) + 8);
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  return 0;
}

void sub_2165F2D54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::recursive_mutex::unlock((std::recursive_mutex *)(a15 + 96));
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<Phase::Job::Priority,applesauce::dispatch::v1::queue>,std::__map_value_compare<Phase::Job::Priority,std::__value_type<Phase::Job::Priority,applesauce::dispatch::v1::queue>,std::less<Phase::Job::Priority>,true>,std::allocator<std::__value_type<Phase::Job::Priority,applesauce::dispatch::v1::queue>>>::destroy(_QWORD *a1)
{
  NSObject *v2;

  if (a1)
  {
    std::__tree<std::__value_type<Phase::Job::Priority,applesauce::dispatch::v1::queue>,std::__map_value_compare<Phase::Job::Priority,std::__value_type<Phase::Job::Priority,applesauce::dispatch::v1::queue>,std::less<Phase::Job::Priority>,true>,std::allocator<std::__value_type<Phase::Job::Priority,applesauce::dispatch::v1::queue>>>::destroy(*a1);
    std::__tree<std::__value_type<Phase::Job::Priority,applesauce::dispatch::v1::queue>,std::__map_value_compare<Phase::Job::Priority,std::__value_type<Phase::Job::Priority,applesauce::dispatch::v1::queue>,std::less<Phase::Job::Priority>,true>,std::allocator<std::__value_type<Phase::Job::Priority,applesauce::dispatch::v1::queue>>>::destroy(a1[1]);
    v2 = a1[5];
    if (v2)
      dispatch_release(v2);
    operator delete(a1);
  }
}

void std::__shared_ptr_pointer<Phase::JobDispatch *,std::__bind<void (Phase::JobManagerDispatch::*)(Phase::Job *),Phase::JobManagerDispatch*,std::placeholders::__ph<1> const&>,std::allocator<Phase::JobDispatch>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__shared_ptr_pointer<Phase::JobDispatch *,std::__bind<void (Phase::JobManagerDispatch::*)(Phase::Job *),Phase::JobManagerDispatch*,std::placeholders::__ph<1> const&>,std::allocator<Phase::JobDispatch>>::__on_zero_shared(_QWORD *a1)
{
  uint64_t v1;
  uint64_t (*v2)(_QWORD *, _QWORD);
  _QWORD *v3;

  v1 = a1[5];
  v2 = (uint64_t (*)(_QWORD *, _QWORD))a1[4];
  v3 = (_QWORD *)(a1[6] + (v1 >> 1));
  if ((v1 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *, _QWORD))(*v3 + v2);
  return v2(v3, a1[3]);
}

uint64_t **std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::__emplace_unique_key_args<std::weak_ptr<Phase::Job>,std::weak_ptr<Phase::Job>>(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unint64_t v7;
  uint64_t **v8;
  unint64_t v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *(_QWORD *)(a2 + 8);
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = v5[5];
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v10 + 2) = *(_OWORD *)a3;
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    std::__tree<Phase::SpatialCategory>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::__erase_unique<std::weak_ptr<Phase::Job>>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  unint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  BOOL v6;
  _QWORD *v7;

  v2 = *(_QWORD **)(a1 + 8);
  if (!v2)
    return 0;
  v3 = *(_QWORD *)(a2 + 8);
  v4 = (uint64_t *)(a1 + 8);
  do
  {
    v5 = v2[5];
    v6 = v5 >= v3;
    if (v5 >= v3)
      v7 = v2;
    else
      v7 = v2 + 1;
    if (v6)
      v4 = v2;
    v2 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t *)(a1 + 8) || v3 < v4[5])
    return 0;
  std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::erase((uint64_t **)a1, v4);
  return 1;
}

uint64_t *std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::erase(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v3;
  std::__shared_weak_count *v4;

  v3 = std::__tree<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::UniqueObjectId>,std::__map_value_compare<std::pair<Phase::DspLayer::VoicePool *,long long>,std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::UniqueObjectId>,std::less<std::pair<Phase::DspLayer::VoicePool *,long long>>,true>,std::allocator<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::UniqueObjectId>>>::__remove_node_pointer(a1, a2);
  v4 = (std::__shared_weak_count *)a2[5];
  if (v4)
    std::__shared_weak_count::__release_weak(v4);
  operator delete(a2);
  return v3;
}

_QWORD *Phase::Command<128>::Invoker<Phase::JobManagerDispatch::StopScheduledJobs(std::list<std::shared_ptr<Phase::Job>>,BOOL)::$_0,void>::~Invoker(_QWORD *a1)
{
  std::__shared_weak_count *v2;

  *a1 = &off_24D57E428;
  v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return a1;
}

void Phase::Command<128>::Invoker<Phase::JobManagerDispatch::StopScheduledJobs(std::list<std::shared_ptr<Phase::Job>>,BOOL)::$_0,void>::~Invoker(_QWORD *a1)
{
  std::__shared_weak_count *v1;

  *a1 = &off_24D57E428;
  v1 = (std::__shared_weak_count *)a1[2];
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
  JUMPOUT(0x2199F9D70);
}

void Phase::Command<128>::Invoker<Phase::JobManagerDispatch::StopScheduledJobs(std::list<std::shared_ptr<Phase::Job>>,BOOL)::$_0,void>::Call(uint64_t a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;

  v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 24);
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (*(_QWORD *)(a1 + 8))
      {
        v13 = *(_QWORD *)(a1 + 8);
        v14 = v4;
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
        (*(void (**)(uint64_t, uint64_t *, _QWORD))(*(_QWORD *)v3 + 64))(v3, &v13, *(unsigned __int8 *)(a1 + 32));
        v8 = v14;
        if (v14)
        {
          v9 = (unint64_t *)&v14->__shared_owners_;
          do
            v10 = __ldaxr(v9);
          while (__stlxr(v10 - 1, v9));
          if (!v10)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }
      v11 = (unint64_t *)&v5->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
}

void sub_2165F30FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t *p_shared_owners;
  unint64_t v14;
  unint64_t v15;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  do
    v15 = __ldaxr(v11);
  while (__stlxr(v15 - 1, v11));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *Phase::Command<128>::Invoker<Phase::JobManagerDispatch::StopScheduledJobAsync(std::shared_ptr<Phase::Job>,std::function<void ()(BOOL,std::list<std::shared_ptr<Phase::Job>>)>,BOOL)::$_0,void>::~Invoker(_QWORD *a1)
{
  std::__shared_weak_count *v2;

  *a1 = &off_24D57E450;
  v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return a1;
}

void Phase::Command<128>::Invoker<Phase::JobManagerDispatch::StopScheduledJobAsync(std::shared_ptr<Phase::Job>,std::function<void ()(BOOL,std::list<std::shared_ptr<Phase::Job>>)>,BOOL)::$_0,void>::~Invoker(_QWORD *a1)
{
  std::__shared_weak_count *v1;

  *a1 = &off_24D57E450;
  v1 = (std::__shared_weak_count *)a1[2];
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
  JUMPOUT(0x2199F9D70);
}

void Phase::Command<128>::Invoker<Phase::JobManagerDispatch::StopScheduledJobAsync(std::shared_ptr<Phase::Job>,std::function<void ()(BOOL,std::list<std::shared_ptr<Phase::Job>>)>,BOOL)::$_0,void>::Call(uint64_t a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;

  v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 24);
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (*(_QWORD *)(a1 + 8))
      {
        v13 = *(_QWORD *)(a1 + 8);
        v14 = v4;
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
        (*(void (**)(uint64_t, uint64_t *, _QWORD))(*(_QWORD *)v3 + 64))(v3, &v13, *(unsigned __int8 *)(a1 + 32));
        v8 = v14;
        if (v14)
        {
          v9 = (unint64_t *)&v14->__shared_owners_;
          do
            v10 = __ldaxr(v9);
          while (__stlxr(v10 - 1, v9));
          if (!v10)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }
      v11 = (unint64_t *)&v5->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
}

void sub_2165F32D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t *p_shared_owners;
  unint64_t v14;
  unint64_t v15;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  do
    v15 = __ldaxr(v11);
  while (__stlxr(v15 - 1, v11));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *Phase::Command<128>::Invoker<std::function<void ()(BOOL,std::list<std::shared_ptr<Phase::Job>>)>,void,BOOL,std::list<std::shared_ptr<Phase::Job>>>::~Invoker(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_24D57E478;
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear(a1 + 6);
  v2 = (_QWORD *)a1[4];
  if (v2 == a1 + 1)
  {
    v3 = 4;
    v2 = a1 + 1;
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return a1;
}

void Phase::Command<128>::Invoker<std::function<void ()(BOOL,std::list<std::shared_ptr<Phase::Job>>)>,void,BOOL,std::list<std::shared_ptr<Phase::Job>>>::~Invoker(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_24D57E478;
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear(a1 + 6);
  v2 = (_QWORD *)a1[4];
  if (v2 == a1 + 1)
  {
    v3 = 4;
    v2 = a1 + 1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x2199F9D70);
}

void Phase::Command<128>::Invoker<std::function<void ()(BOOL,std::list<std::shared_ptr<Phase::Job>>)>,void,BOOL,std::list<std::shared_ptr<Phase::Job>>>::Call(uint64_t a1)
{
  char v2;
  uint64_t v3;
  uint64_t v4[3];
  char v5;

  v2 = *(_BYTE *)(a1 + 40);
  std::list<std::shared_ptr<Phase::Job>>::list(v4, a1 + 48);
  v5 = v2;
  v3 = *(_QWORD *)(a1 + 32);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v5, v4);
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear(v4);
}

void sub_2165F3474(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear(&a9);
  _Unwind_Resume(a1);
}

_QWORD *Phase::Command<128>::Invoker<Phase::JobManagerDispatch::StopScheduledJobsAsync(std::list<std::shared_ptr<Phase::Job>>,std::function<void ()(BOOL,std::list<std::shared_ptr<Phase::Job>>)>,BOOL)::$_0,void>::~Invoker(_QWORD *a1)
{
  std::__shared_weak_count *v2;

  *a1 = &off_24D57E4A0;
  v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return a1;
}

void Phase::Command<128>::Invoker<Phase::JobManagerDispatch::StopScheduledJobsAsync(std::list<std::shared_ptr<Phase::Job>>,std::function<void ()(BOOL,std::list<std::shared_ptr<Phase::Job>>)>,BOOL)::$_0,void>::~Invoker(_QWORD *a1)
{
  std::__shared_weak_count *v1;

  *a1 = &off_24D57E4A0;
  v1 = (std::__shared_weak_count *)a1[2];
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
  JUMPOUT(0x2199F9D70);
}

void Phase::Command<128>::Invoker<Phase::JobManagerDispatch::StopScheduledJobsAsync(std::list<std::shared_ptr<Phase::Job>>,std::function<void ()(BOOL,std::list<std::shared_ptr<Phase::Job>>)>,BOOL)::$_0,void>::Call(uint64_t a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;

  v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 24);
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (*(_QWORD *)(a1 + 8))
      {
        v13 = *(_QWORD *)(a1 + 8);
        v14 = v4;
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
        (*(void (**)(uint64_t, uint64_t *, _QWORD))(*(_QWORD *)v3 + 64))(v3, &v13, *(unsigned __int8 *)(a1 + 32));
        v8 = v14;
        if (v14)
        {
          v9 = (unint64_t *)&v14->__shared_owners_;
          do
            v10 = __ldaxr(v9);
          while (__stlxr(v10 - 1, v9));
          if (!v10)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }
      v11 = (unint64_t *)&v5->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
}

void sub_2165F35EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t *p_shared_owners;
  unint64_t v14;
  unint64_t v15;

  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  do
    v15 = __ldaxr(v11);
  while (__stlxr(v15 - 1, v11));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  _Unwind_Resume(exception_object);
}

double Phase::JobManagerSynchronous::CreateJob@<D0>(uint64_t a1@<X0>, __int128 *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  uint64_t v7;
  double result;

  v6 = operator new(0x280uLL, (std::align_val_t)0x80uLL);
  Phase::Job::Job((uint64_t)v6, a1, a2);
  *v6 = &off_24D57E4C8;
  v6[72] = v6 + 72;
  v6[73] = v6 + 72;
  v6[74] = 0;
  *a3 = v6;
  v7 = operator new();
  *(_QWORD *)&result = 112;
  *(_OWORD *)(v7 + 32) = xmmword_2166F8A20;
  *(_QWORD *)(v7 + 48) = a1;
  *(_QWORD *)v7 = &off_24D57E4E8;
  *(_QWORD *)(v7 + 8) = 0;
  *(_QWORD *)(v7 + 16) = 0;
  *(_QWORD *)(v7 + 24) = v6;
  a3[1] = v7;
  return result;
}

void sub_2165F3700(void *a1)
{
  uint64_t v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v1 + 112))(v1, v2);
  __cxa_rethrow();
}

void sub_2165F3720(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Phase::JobManagerSynchronous::AddDependency(Phase::Logger *a1, uint64_t a2, Phase::Job **a3)
{
  Phase::Job *v3;
  Phase::Job *v5;
  uint64_t **Dependents;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  char v14;
  char v15;
  Phase::Job *v16;
  int v17;
  uint64_t *Dependencies;
  NSObject *v19;
  std::logic_error *exception;
  NSObject *v21;
  std::logic_error *v22;
  _BYTE v23[18];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v3 = *(Phase::Job **)a2;
  if (!*(_QWORD *)a2)
  {
    v19 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v23 = 136315394;
      *(_QWORD *)&v23[4] = "JobManagerSynchronous.cpp";
      *(_WORD *)&v23[12] = 1024;
      *(_DWORD *)&v23[14] = 33;
      _os_log_impl(&dword_2164CC000, v19, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInDependent is false.", v23, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "PRECONDITION: nullptr != pInDependent is false.");
  }
  v5 = *a3;
  if (!*a3)
  {
    v21 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v23 = 136315394;
      *(_QWORD *)&v23[4] = "JobManagerSynchronous.cpp";
      *(_WORD *)&v23[12] = 1024;
      *(_DWORD *)&v23[14] = 34;
      _os_log_impl(&dword_2164CC000, v21, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInDependency is false.", v23, 0x12u);
    }
    v22 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v22, "PRECONDITION: nullptr != pInDependency is false.");
  }
  if (atomic_load((unsigned int *)Phase::JobManager::GetExecutionState(a1, *(Phase::Job **)a2)))
    return 3;
  Dependents = (uint64_t **)Phase::JobManager::GetDependents(a1, v5);
  v11 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)v23 = *(_QWORD *)a2;
  *(_QWORD *)&v23[8] = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 16);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::__emplace_unique_key_args<std::weak_ptr<Phase::Job>,std::weak_ptr<Phase::Job>>(Dependents, (uint64_t)v23, (uint64_t)v23);
  v15 = v14;
  if (*(_QWORD *)&v23[8])
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v23[8]);
  if ((v15 & 1) == 0)
    return 2;
  v16 = *a3;
  v17 = *((_DWORD *)*a3 + 131);
  if (v17 <= *(_DWORD *)(*(_QWORD *)a2 + 524))
    v17 = *(_DWORD *)(*(_QWORD *)a2 + 524);
  *((_DWORD *)v16 + 131) = v17;
  atomic_store(1u, (unsigned __int8 *)v16 + 40);
  Dependencies = (uint64_t *)Phase::JobManager::GetDependencies(a1, v3);
  std::list<std::shared_ptr<Phase::Job>>::push_back(Dependencies, a3);
  return 0;
}

void sub_2165F39A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
    std::__shared_weak_count::__release_weak(a10);
  _Unwind_Resume(exception_object);
}

uint64_t Phase::JobManagerSynchronous::AddEnqueuedDependency(Phase::Logger *a1, uint64_t a2, Phase::Job **a3)
{
  uint64_t *v3;
  Phase::Job *v5;
  uint64_t **Dependents;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  char v14;
  char v15;
  uint64_t *Dependencies;
  unsigned int v17;
  NSObject *v18;
  std::logic_error *exception;
  NSObject *v20;
  std::logic_error *v21;
  _BYTE v22[18];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)a2;
  if (!*(_QWORD *)a2)
  {
    v18 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v22 = 136315394;
      *(_QWORD *)&v22[4] = "JobManagerSynchronous.cpp";
      *(_WORD *)&v22[12] = 1024;
      *(_DWORD *)&v22[14] = 55;
      _os_log_impl(&dword_2164CC000, v18, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInDependent is false.", v22, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "PRECONDITION: nullptr != pInDependent is false.");
  }
  v5 = *a3;
  if (!*a3)
  {
    v20 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v22 = 136315394;
      *(_QWORD *)&v22[4] = "JobManagerSynchronous.cpp";
      *(_WORD *)&v22[12] = 1024;
      *(_DWORD *)&v22[14] = 56;
      _os_log_impl(&dword_2164CC000, v20, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInDependency is false.", v22, 0x12u);
    }
    v21 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v21, "PRECONDITION: nullptr != pInDependency is false.");
  }
  if (atomic_load((unsigned int *)Phase::JobManager::GetExecutionState(a1, *a3)))
    return 3;
  Dependents = (uint64_t **)Phase::JobManager::GetDependents(a1, v5);
  v11 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)v22 = *(_QWORD *)a2;
  *(_QWORD *)&v22[8] = v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 16);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::__emplace_unique_key_args<std::weak_ptr<Phase::Job>,std::weak_ptr<Phase::Job>>(Dependents, (uint64_t)v22, (uint64_t)v22);
  v15 = v14;
  if (*(_QWORD *)&v22[8])
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v22[8]);
  if ((v15 & 1) == 0)
    return 2;
  Dependencies = (uint64_t *)Phase::JobManager::GetDependencies(a1, (Phase::Job *)v3);
  std::list<std::shared_ptr<Phase::Job>>::push_back(Dependencies, a3);
  v17 = atomic_load((unsigned int *)Phase::JobManager::GetExecutionState(a1, (Phase::Job *)v3));
  if (v17 == 1)
    std::list<std::shared_ptr<Phase::Job>>::push_back(v3 + 72, a3);
  return 0;
}

void sub_2165F3C30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
    std::__shared_weak_count::__release_weak(a10);
  _Unwind_Resume(exception_object);
}

uint64_t Phase::JobManagerSynchronous::InsertDependency(Phase::Logger *a1, uint64_t a2, uint64_t a3, Phase::Job **a4)
{
  Phase::Job *v4;
  uint64_t *v6;
  Phase::Job *v8;
  uint64_t v13;
  uint64_t Dependencies;
  uint64_t **Dependents;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  char v19;
  int v20;
  uint64_t **v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_weak_owners;
  unint64_t v24;
  char v25;
  int v26;
  uint64_t *v27;
  uint64_t *v28;
  unsigned int v29;
  uint64_t *v30;
  NSObject *v31;
  std::logic_error *exception;
  NSObject *v33;
  std::logic_error *v34;
  NSObject *v35;
  std::logic_error *v36;
  uint64_t *v37;
  std::__shared_weak_count *v38;
  _BYTE buf[18];
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v4 = *(Phase::Job **)a2;
  if (!*(_QWORD *)a2)
  {
    v31 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "JobManagerSynchronous.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 84;
      _os_log_impl(&dword_2164CC000, v31, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInInsertor is false.", buf, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "PRECONDITION: nullptr != pInInsertor is false.");
  }
  v6 = *(uint64_t **)a3;
  if (!*(_QWORD *)a3)
  {
    v33 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "JobManagerSynchronous.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 85;
      _os_log_impl(&dword_2164CC000, v33, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInDependent is false.", buf, 0x12u);
    }
    v34 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v34, "PRECONDITION: nullptr != pInDependent is false.");
  }
  v8 = *a4;
  if (!*a4)
  {
    v35 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "JobManagerSynchronous.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 86;
      _os_log_impl(&dword_2164CC000, v35, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInDependency is false.", buf, 0x12u);
    }
    v36 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v36, "PRECONDITION: nullptr != pInDependency is false.");
  }
  if (atomic_load((unsigned int *)Phase::JobManager::GetExecutionState(a1, *(Phase::Job **)a2)))
    return 3;
  v13 = *(_QWORD *)(Phase::JobManager::GetDependencies(a1, (Phase::Job *)v6) + 8);
  Dependencies = Phase::JobManager::GetDependencies(a1, (Phase::Job *)v6);
  if (v13 != Dependencies)
  {
    while (*(Phase::Job **)(v13 + 16) != *a4)
    {
      v13 = *(_QWORD *)(v13 + 8);
      if (v13 == Dependencies)
      {
        v13 = Dependencies;
        break;
      }
    }
  }
  if (v13 == Phase::JobManager::GetDependencies(a1, (Phase::Job *)v6))
    return 2;
  Dependents = (uint64_t **)Phase::JobManager::GetDependents(a1, v8);
  v16 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)buf = *(_QWORD *)a2;
  *(_QWORD *)&buf[8] = v16;
  if (v16)
  {
    v17 = (unint64_t *)(v16 + 16);
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::__emplace_unique_key_args<std::weak_ptr<Phase::Job>,std::weak_ptr<Phase::Job>>(Dependents, (uint64_t)buf, (uint64_t)buf);
  if ((v19 & 1) != 0)
  {
    v21 = (uint64_t **)Phase::JobManager::GetDependents(a1, v4);
    v22 = *(std::__shared_weak_count **)(a3 + 8);
    v37 = *(uint64_t **)a3;
    v38 = v22;
    if (v22)
    {
      p_shared_weak_owners = (unint64_t *)&v22->__shared_weak_owners_;
      do
        v24 = __ldxr(p_shared_weak_owners);
      while (__stxr(v24 + 1, p_shared_weak_owners));
    }
    std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::__emplace_unique_key_args<std::weak_ptr<Phase::Job>,std::weak_ptr<Phase::Job>>(v21, (uint64_t)&v37, (uint64_t)&v37);
    v20 = v25 & 1;
    if (v38)
      std::__shared_weak_count::__release_weak(v38);
  }
  else
  {
    v20 = 0;
  }
  if (*(_QWORD *)&buf[8])
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&buf[8]);
  if (!v20)
    return 2;
  v26 = *((_DWORD *)v4 + 131);
  if (v26 <= *((_DWORD *)v6 + 131))
    v26 = *((_DWORD *)v6 + 131);
  *((_DWORD *)v4 + 131) = v26;
  atomic_store(1u, (unsigned __int8 *)v4 + 40);
  v27 = (uint64_t *)Phase::JobManager::GetDependencies(a1, (Phase::Job *)v6);
  std::list<std::shared_ptr<Phase::Job>>::push_back(v27, (_QWORD *)a2);
  v28 = (uint64_t *)Phase::JobManager::GetDependencies(a1, v4);
  std::list<std::shared_ptr<Phase::Job>>::push_back(v28, a4);
  v29 = atomic_load((unsigned int *)Phase::JobManager::GetExecutionState(a1, (Phase::Job *)v6));
  if (v29 == 1)
  {
    v30 = v6 + 72;
    std::list<std::shared_ptr<Phase::Job>>::remove(v30, (uint64_t)*a4);
    std::list<std::shared_ptr<Phase::Job>>::push_back(v30, (_QWORD *)a2);
    std::list<std::shared_ptr<Phase::Job>>::push_back((uint64_t *)v4 + 72, a4);
  }
  return 0;
}

void sub_2165F4064(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10)
    std::__shared_weak_count::__release_weak(a10);
  if (a12)
    std::__shared_weak_count::__release_weak(a12);
  _Unwind_Resume(exception_object);
}

void std::list<std::shared_ptr<Phase::Job>>::remove(uint64_t *a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11[2];
  uint64_t v12;

  v11[0] = (uint64_t)v11;
  v11[1] = (uint64_t)v11;
  v12 = 0;
  v2 = (uint64_t *)a1[1];
  if (v2 != a1)
  {
    v3 = 0;
    do
    {
      v4 = (uint64_t *)v2[1];
      if (v2[2] == a2)
      {
        if (v4 == a1)
        {
          v5 = 1;
LABEL_9:
          v4 = a1;
        }
        else
        {
          while (1)
          {
            v5 = v4[2] == a2;
            if (v4[2] != a2)
              break;
            v4 = (uint64_t *)v4[1];
            if (v4 == a1)
              goto LABEL_9;
          }
        }
        if (v2 != v4)
        {
          v6 = *v4;
          if (v11 != a1)
          {
            v7 = 1;
            if ((uint64_t *)v6 != v2)
            {
              v8 = v2;
              do
              {
                v8 = (uint64_t *)v8[1];
                ++v7;
              }
              while (v8 != (uint64_t *)v6);
            }
            a1[2] -= v7;
            v3 += v7;
            v12 = v3;
          }
          v9 = *v2;
          *(_QWORD *)(v9 + 8) = *(_QWORD *)(v6 + 8);
          **(_QWORD **)(v6 + 8) = v9;
          v10 = v11[0];
          *(_QWORD *)(v11[0] + 8) = v2;
          *v2 = v10;
          v11[0] = v6;
          *(_QWORD *)(v6 + 8) = v11;
        }
        if (!v5)
          v4 = (uint64_t *)v4[1];
      }
      v2 = v4;
    }
    while (v4 != a1);
  }
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear(v11);
}

uint64_t Phase::JobManagerSynchronous::ReplaceDependency(Phase::Logger *a1, uint64_t *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  Phase::Job *v6;
  Phase::Job *v8;
  uint64_t v11;
  uint64_t Dependencies;
  int v15;
  uint64_t Dependents;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t **v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unsigned int v24;
  uint64_t *v25;
  NSObject *v26;
  std::logic_error *exception;
  NSObject *v28;
  std::logic_error *v29;
  NSObject *v30;
  std::logic_error *v31;
  _BYTE v32[18];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (!*a2)
  {
    v26 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v32 = 136315394;
      *(_QWORD *)&v32[4] = "JobManagerSynchronous.cpp";
      *(_WORD *)&v32[12] = 1024;
      *(_DWORD *)&v32[14] = 125;
      _os_log_impl(&dword_2164CC000, v26, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInReplacement is false.", v32, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "PRECONDITION: nullptr != pInReplacement is false.");
  }
  v6 = *(Phase::Job **)a3;
  if (!*(_QWORD *)a3)
  {
    v28 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v32 = 136315394;
      *(_QWORD *)&v32[4] = "JobManagerSynchronous.cpp";
      *(_WORD *)&v32[12] = 1024;
      *(_DWORD *)&v32[14] = 126;
      _os_log_impl(&dword_2164CC000, v28, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInDependent is false.", v32, 0x12u);
    }
    v29 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v29, "PRECONDITION: nullptr != pInDependent is false.");
  }
  v8 = (Phase::Job *)*a4;
  if (!*a4)
  {
    v30 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v32 = 136315394;
      *(_QWORD *)&v32[4] = "JobManagerSynchronous.cpp";
      *(_WORD *)&v32[12] = 1024;
      *(_DWORD *)&v32[14] = 127;
      _os_log_impl(&dword_2164CC000, v30, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: nullptr != pInDependency is false.", v32, 0x12u);
    }
    v31 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v31, "PRECONDITION: nullptr != pInDependency is false.");
  }
  v11 = *(_QWORD *)(Phase::JobManager::GetDependencies(a1, *(Phase::Job **)a3) + 8);
  Dependencies = Phase::JobManager::GetDependencies(a1, v6);
  if (v11 != Dependencies)
  {
    while (*(_QWORD *)(v11 + 16) != *a4)
    {
      v11 = *(_QWORD *)(v11 + 8);
      if (v11 == Dependencies)
      {
        v11 = Dependencies;
        break;
      }
    }
  }
  if (atomic_load((unsigned int *)Phase::JobManager::GetExecutionState(a1, (Phase::Job *)v4)))
    return 3;
  if (Phase::JobManager::GetDependencies(a1, v6) == v11)
    return 2;
  v15 = *(_DWORD *)(v4 + 524);
  if (v15 <= *((_DWORD *)v8 + 131))
    v15 = *((_DWORD *)v8 + 131);
  *(_DWORD *)(v4 + 524) = v15;
  atomic_store(1u, (unsigned __int8 *)(v4 + 40));
  std::shared_ptr<Phase::Controller::SpatializerFilterDatabase>::operator=[abi:ne180100]((_QWORD *)(v11 + 16), a2);
  Dependents = Phase::JobManager::GetDependents(a1, v8);
  v17 = *(_QWORD *)(a3 + 8);
  *(_QWORD *)v32 = *(_QWORD *)a3;
  *(_QWORD *)&v32[8] = v17;
  if (v17)
  {
    v18 = (unint64_t *)(v17 + 16);
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::__erase_unique<std::weak_ptr<Phase::Job>>(Dependents, (uint64_t)v32);
  if (*(_QWORD *)&v32[8])
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v32[8]);
  v20 = (uint64_t **)Phase::JobManager::GetDependents(a1, (Phase::Job *)v4);
  v21 = *(_QWORD *)(a3 + 8);
  *(_QWORD *)v32 = *(_QWORD *)a3;
  *(_QWORD *)&v32[8] = v21;
  if (v21)
  {
    v22 = (unint64_t *)(v21 + 16);
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }
  std::__tree<std::weak_ptr<Phase::Job>,std::owner_less<std::weak_ptr<Phase::Job>>,std::allocator<std::weak_ptr<Phase::Job>>>::__emplace_unique_key_args<std::weak_ptr<Phase::Job>,std::weak_ptr<Phase::Job>>(v20, (uint64_t)v32, (uint64_t)v32);
  if (*(_QWORD *)&v32[8])
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v32[8]);
  v24 = atomic_load((unsigned int *)Phase::JobManager::GetExecutionState(a1, v6));
  if (v24 == 1)
  {
    v25 = (uint64_t *)((char *)v6 + 576);
    std::list<std::shared_ptr<Phase::Job>>::remove(v25, *a4);
    std::list<std::shared_ptr<Phase::Job>>::push_back(v25, a2);
  }
  return 0;
}

void sub_2165F4570(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
    std::__shared_weak_count::__release_weak(a10);
  _Unwind_Resume(exception_object);
}

uint64_t Phase::JobManagerSynchronous::WaitForJob()
{
  return 1;
}

unint64_t Phase::JobManagerSynchronous::CancelJob(Phase::JobManager *this, uint64_t a2, int a3)
{
  Phase::Job *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  __n128 RootJob;
  unint64_t v10;
  unsigned int v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unsigned int *ExecutionState;
  unsigned int v20;
  uint64_t Dependencies;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v36;
  std::__shared_weak_count *v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  Phase::Job *v40;
  std::__shared_weak_count *v41;
  __int128 v42;

  v5 = *(Phase::Job **)a2;
  if (a3)
  {
    v6 = *(std::__shared_weak_count **)(a2 + 8);
    v40 = v5;
    v41 = v6;
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }
    RootJob = Phase::JobManager::GetRootJob(this, (uint64_t)&v40, &v42);
    v10 = (*(uint64_t (**)(Phase::JobManager *, __int128 *, _QWORD, __n128))(*(_QWORD *)this + 104))(this, &v42, 0, RootJob);
    v11 = v10;
    v12 = HIDWORD(v10);
    v13 = (std::__shared_weak_count *)*((_QWORD *)&v42 + 1);
    if (*((_QWORD *)&v42 + 1))
    {
      v14 = (unint64_t *)(*((_QWORD *)&v42 + 1) + 8);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    v16 = v41;
    if (v41)
    {
      v17 = (unint64_t *)&v41->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
  else
  {
    ExecutionState = (unsigned int *)Phase::JobManager::GetExecutionState(this, v5);
    do
    {
      v20 = __ldaxr(ExecutionState);
      if (v20 != 1)
      {
        LODWORD(v12) = 0;
        __clrex();
        v11 = 3;
        return v11 | ((unint64_t)v12 << 32);
      }
    }
    while (__stlxr(3u, ExecutionState));
    Dependencies = Phase::JobManager::GetDependencies(this, *(Phase::Job **)a2);
    v22 = *(_QWORD **)(Dependencies + 8);
    if (v22 != (_QWORD *)Dependencies)
    {
      v23 = (_QWORD *)Dependencies;
      do
      {
        v24 = v22[2];
        v25 = (std::__shared_weak_count *)v22[3];
        v38 = v24;
        v39 = v25;
        if (v25)
        {
          v26 = (unint64_t *)&v25->__shared_owners_;
          do
            v27 = __ldxr(v26);
          while (__stxr(v27 + 1, v26));
          v37 = v25;
          do
            v28 = __ldxr(v26);
          while (__stxr(v28 + 1, v26));
        }
        else
        {
          v37 = 0;
        }
        v36 = v24;
        (*(void (**)(Phase::JobManager *, uint64_t *, _QWORD))(*(_QWORD *)this + 104))(this, &v36, 0);
        v29 = v37;
        if (v37)
        {
          v30 = (unint64_t *)&v37->__shared_owners_;
          do
            v31 = __ldaxr(v30);
          while (__stlxr(v31 - 1, v30));
          if (!v31)
          {
            ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
            std::__shared_weak_count::__release_weak(v29);
          }
        }
        v32 = v39;
        if (v39)
        {
          v33 = (unint64_t *)&v39->__shared_owners_;
          do
            v34 = __ldaxr(v33);
          while (__stlxr(v34 - 1, v33));
          if (!v34)
          {
            ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
            std::__shared_weak_count::__release_weak(v32);
          }
        }
        v22 = (_QWORD *)v22[1];
      }
      while (v22 != v23);
    }
    v11 = 0;
    LODWORD(v12) = 0;
  }
  return v11 | ((unint64_t)v12 << 32);
}

void sub_2165F47E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v6;
  va_list va;
  uint64_t v8;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t Phase::JobManagerSynchronous::RunJob(Phase::JobManager *a1, Phase::Job **a2, double a3)
{
  unsigned int v3;
  Phase::Logger *Dependents;
  Phase::Job *v7;
  Phase::Job *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  NSObject *v14;
  std::logic_error *exception;
  Phase::Job *v16[2];
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  if (a3 <= 0.0)
  {
    Dependents = (Phase::Logger *)Phase::JobManager::GetDependents(a1, *a2);
    if (*((_QWORD *)Dependents + 2))
    {
      v14 = **(NSObject ***)(Phase::Logger::GetInstancePtr(Dependents) + 464);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v18 = "JobManagerSynchronous.cpp";
        v19 = 1024;
        v20 = 216;
        _os_log_impl(&dword_2164CC000, v14, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: GetDependents(pJob).empty() is false.", buf, 0x12u);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "PRECONDITION: GetDependents(pJob).empty() is false.");
    }
    v7 = *a2;
    v8 = a2[1];
    v16[0] = v7;
    v16[1] = v8;
    if (v8)
    {
      v9 = (unint64_t *)((char *)v8 + 8);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v3 = 2 * (Phase::JobManagerSynchronous::doRunJob(a1, v16) == 0);
    if (v8)
    {
      v11 = (unint64_t *)((char *)v8 + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        (*(void (**)(Phase::Job *))(*(_QWORD *)v8 + 16))(v8);
        std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v8);
      }
    }
  }
  else
  {
    return 1;
  }
  return v3;
}

void sub_2165F4998(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t Phase::JobManagerSynchronous::doRunJob(Phase::JobManager *a1, Phase::Job **a2)
{
  Phase::Job *v3;
  unsigned int *ExecutionState;
  unsigned int v5;
  _QWORD *v6;
  uint64_t Dependencies;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  NSObject *v20;
  uint64_t i;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  int v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  unsigned int v38;
  _QWORD v40[2];
  _BYTE buf[18];
  __int16 v42;
  unsigned int v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  v3 = *a2;
  ExecutionState = (unsigned int *)Phase::JobManager::GetExecutionState(a1, *a2);
  while (1)
  {
    v5 = __ldaxr(ExecutionState);
    if (v5)
      break;
    if (!__stlxr(1u, ExecutionState))
    {
      v6 = *(_QWORD **)(Phase::JobManager::GetDependencies(a1, v3) + 8);
      Dependencies = Phase::JobManager::GetDependencies(a1, v3);
      if (v6 == (_QWORD *)Dependencies)
      {
        v22 = *((_QWORD *)v3 + 74);
      }
      else
      {
        v8 = (_QWORD *)Dependencies;
        v9 = operator new(0x20uLL);
        v10 = v9;
        *v9 = 0;
        v9[1] = 0;
        v9[2] = v6[2];
        v11 = v6[3];
        v9[3] = v11;
        if (v11)
        {
          v12 = (unint64_t *)(v11 + 8);
          do
            v13 = __ldxr(v12);
          while (__stxr(v13 + 1, v12));
        }
        v14 = (_QWORD *)v6[1];
        v15 = 1;
        if (v14 != v8)
        {
          v16 = v9;
          do
          {
            v9 = operator new(0x20uLL);
            *v9 = v16;
            v9[1] = 0;
            v9[2] = v14[2];
            v17 = v14[3];
            v9[3] = v17;
            if (v17)
            {
              v18 = (unint64_t *)(v17 + 8);
              do
                v19 = __ldxr(v18);
              while (__stxr(v19 + 1, v18));
            }
            v16[1] = v9;
            ++v15;
            v14 = (_QWORD *)v14[1];
            v16 = v9;
          }
          while (v14 != v8);
        }
        v23 = *((_QWORD *)v3 + 72);
        *(_QWORD *)(v23 + 8) = v10;
        *v10 = v23;
        *((_QWORD *)v3 + 72) = v9;
        v9[1] = (char *)v3 + 576;
        v22 = *((_QWORD *)v3 + 74) + v15;
        *((_QWORD *)v3 + 74) = v22;
      }
      for (i = 1; v22; v22 = *((_QWORD *)v3 + 74))
      {
        v24 = (uint64_t *)*((_QWORD *)v3 + 73);
        v26 = v24[2];
        v25 = (std::__shared_weak_count *)v24[3];
        *(_QWORD *)buf = v26;
        *(_QWORD *)&buf[8] = v25;
        if (v25)
        {
          p_shared_owners = (unint64_t *)&v25->__shared_owners_;
          do
            v28 = __ldxr(p_shared_owners);
          while (__stxr(v28 + 1, p_shared_owners));
          v24 = (uint64_t *)*((_QWORD *)v3 + 73);
          v22 = *((_QWORD *)v3 + 74);
        }
        v29 = *v24;
        *(_QWORD *)(v29 + 8) = v24[1];
        *(_QWORD *)v24[1] = v29;
        *((_QWORD *)v3 + 74) = v22 - 1;
        std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)(v24 + 2));
        operator delete(v24);
        v40[0] = v26;
        v40[1] = v25;
        if (v25)
        {
          v30 = (unint64_t *)&v25->__shared_owners_;
          do
            v31 = __ldxr(v30);
          while (__stxr(v31 + 1, v30));
        }
        v32 = Phase::JobManagerSynchronous::doRunJob(a1, v40);
        if (v25)
        {
          v33 = (unint64_t *)&v25->__shared_owners_;
          do
            v34 = __ldaxr(v33);
          while (__stlxr(v34 - 1, v33));
          if (!v34)
          {
            ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
            std::__shared_weak_count::__release_weak(v25);
          }
        }
        v35 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v36 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v37 = __ldaxr(v36);
          while (__stlxr(v37 - 1, v36));
          if (!v37)
          {
            ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
            std::__shared_weak_count::__release_weak(v35);
          }
        }
        i = (v32 + i);
      }
      v38 = atomic_load((unsigned int *)Phase::JobManager::GetExecutionState(a1, v3));
      if (v38 != 3)
      {
        Phase::Job::Run(v3);
        atomic_store(2u, (unsigned int *)Phase::JobManager::GetExecutionState(a1, v3));
      }
      return i;
    }
  }
  __clrex();
  if (v5 != 3)
  {
    v20 = **(NSObject ***)(Phase::Logger::GetInstancePtr((Phase::Logger *)ExecutionState) + 464);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "JobManagerSynchronous.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 250;
      v42 = 1024;
      v43 = v5;
      _os_log_impl(&dword_2164CC000, v20, OS_LOG_TYPE_ERROR, "%25s:%-5d Attempting to run a job with active state %i", buf, 0x18u);
    }
  }
  return 0;
}

void sub_2165F4D08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _QWORD *v11;
  _QWORD *v12;

  if (a2)
  {
    __cxa_begin_catch(exception_object);
    do
    {
      v12 = (_QWORD *)*v11;
      std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)(v11 + 2));
      operator delete(v11);
      v11 = v12;
    }
    while (v12);
    __cxa_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void Phase::JobManagerSynchronous::ScheduleJobs(Phase::Logger *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  NSObject *v6;
  std::logic_error *exception;
  uint64_t v8[3];
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (!*(_QWORD *)(a4 + 24))
  {
    v6 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 464);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v10 = "JobManagerSynchronous.cpp";
      v11 = 1024;
      v12 = 265;
      _os_log_impl(&dword_2164CC000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error): \"Schedule periodic jobs is not supported in JobManagerSynchronous\"", buf, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Schedule periodic jobs is not supported in JobManagerSynchronous");
  }
  std::list<std::shared_ptr<Phase::Job>>::list(v8, a2);
  buf[0] = 0;
  v5 = *(_QWORD *)(a4 + 24);
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, uint8_t *, uint64_t *))(*(_QWORD *)v5 + 48))(v5, buf, v8);
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear(v8);
}

void sub_2165F4EA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  void *v10;

  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

uint64_t Phase::JobManagerSynchronous::RunManualJob()
{
  return 1;
}

uint64_t Phase::JobManagerSynchronous::PrepareJob(Phase::JobManager *a1, Phase::Job **a2)
{
  uint64_t *v3;
  unsigned int v4;
  uint64_t Dependencies;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;
  int v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;

  v3 = (uint64_t *)*a2;
  v4 = 2 * (*((_DWORD *)*a2 + 132) == 1);
  atomic_store(0, (unsigned int *)Phase::JobManager::GetExecutionState(a1, *a2));
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear(v3 + 72);
  Dependencies = Phase::JobManager::GetDependencies(a1, (Phase::Job *)v3);
  v6 = *(_QWORD **)(Dependencies + 8);
  if (v6 != (_QWORD *)Dependencies)
  {
    v7 = (_QWORD *)Dependencies;
    do
    {
      v8 = v6[2];
      v9 = (std::__shared_weak_count *)v6[3];
      v25 = v8;
      v26 = v9;
      if (v9)
      {
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v11 = __ldxr(p_shared_owners);
        while (__stxr(v11 + 1, p_shared_owners));
        v24 = v9;
        do
          v12 = __ldxr(p_shared_owners);
        while (__stxr(v12 + 1, p_shared_owners));
      }
      else
      {
        v24 = 0;
      }
      v23 = v8;
      v13 = (*(uint64_t (**)(Phase::JobManager *, uint64_t *))(*(_QWORD *)a1 + 144))(a1, &v23);
      if (HIDWORD(v13))
        v14 = 1;
      else
        v14 = (_DWORD)v13 == 0;
      v15 = v14;
      v16 = v24;
      if (v24)
      {
        v17 = (unint64_t *)&v24->__shared_owners_;
        do
          v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      if (!v15)
        v4 = 2;
      v19 = v26;
      if (v26)
      {
        v20 = (unint64_t *)&v26->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }
      v6 = (_QWORD *)v6[1];
    }
    while (v6 != v7);
  }
  return v4;
}

void sub_2165F5044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void Phase::JobManagerSynchronous::~JobManagerSynchronous(Phase::JobManagerSynchronous *this)
{
  Phase::JobManager::~JobManager(this);
  JUMPOUT(0x2199F9D70);
}

void Phase::JobSynchronous::~JobSynchronous(Phase::JobSynchronous *this)
{
  *(_QWORD *)this = &off_24D57E4C8;
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear((uint64_t *)this + 72);
  Phase::Job::~Job(this);
}

{
  *(_QWORD *)this = &off_24D57E4C8;
  std::__list_imp<std::shared_ptr<Phase::Job>>::clear((uint64_t *)this + 72);
  Phase::Job::~Job(this);
  JUMPOUT(0x2199F9D64);
}

void std::__shared_ptr_pointer<Phase::JobSynchronous *,std::__bind<void (Phase::JobManager::*)(Phase::Job *),Phase::JobManagerSynchronous *,std::placeholders::__ph<1> const&>,std::allocator<Phase::JobSynchronous>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

uint64_t std::__shared_ptr_pointer<Phase::JobSynchronous *,std::__bind<void (Phase::JobManager::*)(Phase::Job *),Phase::JobManagerSynchronous *,std::placeholders::__ph<1> const&>,std::allocator<Phase::JobSynchronous>>::__on_zero_shared(_QWORD *a1)
{
  uint64_t v1;
  uint64_t (*v2)(_QWORD *, _QWORD);
  _QWORD *v3;

  v1 = a1[5];
  v2 = (uint64_t (*)(_QWORD *, _QWORD))a1[4];
  v3 = (_QWORD *)(a1[6] + (v1 >> 1));
  if ((v1 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *, _QWORD))(*v3 + v2);
  return v2(v3, a1[3]);
}

uint64_t Phase::ParseJSONFile(void *a1, _QWORD *a2, void **a3)
{
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  Phase::Logger *v15;
  NSObject *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  Phase::Logger *v21;
  NSObject *v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t v26;
  uint64_t i;
  void *v28;
  Phase::Logger *v29;
  void *v30;
  int v31;
  id v32;
  void *v33;
  unint64_t v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  Phase::Logger *v39;
  NSObject *v40;
  NSObject *v41;
  uint64_t v42;
  Phase::Logger *v43;
  uint64_t v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  Phase::Logger *v49;
  NSObject *v50;
  void *v51;
  void *v53;
  void *v54;
  void *v55;
  Phase::Logger *v56;
  NSObject *v57;
  void *v58;
  void *v59;
  void *v60;
  id v61;
  id v62;
  id v63;
  id obj;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  void *v68;
  uint8_t v69[4];
  const char *v70;
  __int16 v71;
  int v72;
  __int16 v73;
  _BYTE v74[10];
  _BYTE buf[12];
  __int16 v76;
  int v77;
  __int16 v78;
  uint64_t v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  uint64_t v84;

  v84 = *MEMORY[0x24BDAC8D0];
  v62 = a1;
  objc_msgSend(MEMORY[0x24BDD1580], "defaultManager");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v62, "resourceSpecifier");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v60 = v5;
  objc_msgSend(v5, "contentsAtPath:", v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  v59 = v7;
  if (v7)
  {
    v63 = v7;
    if (a3)
      *a3 = 0;
    objc_msgSend(MEMORY[0x24BDD1608], "JSONObjectWithData:options:error:", v63, 2, a3);
    v61 = (id)objc_claimAutoreleasedReturnValue();
    if (a3 && ((v8 = *a3, !v61) || v8))
    {
      v82 = 0u;
      v83 = 0u;
      v80 = 0u;
      v81 = 0u;
      objc_msgSend(v8, "userInfo");
      v24 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v24, "allValues");
      v25 = (void *)objc_claimAutoreleasedReturnValue();

      obj = v25;
      v26 = objc_msgSend(v25, "countByEnumeratingWithState:objects:count:", &v80, buf, 16);
      if (v26)
      {
        v65 = *(_QWORD *)v81;
        do
        {
          v66 = v26;
          for (i = 0; i != v66; ++i)
          {
            if (*(_QWORD *)v81 != v65)
              objc_enumerationMutation(obj);
            v28 = *(void **)(*((_QWORD *)&v80 + 1) + 8 * i);
            v29 = (Phase::Logger *)objc_msgSend(v28, "hasPrefix:", CFSTR("Badly formed object around character"));
            if ((_DWORD)v29)
            {
              objc_msgSend(v28, "substringFromIndex:", objc_msgSend(CFSTR("Badly formed object around character"), "length"));
              v30 = (void *)objc_claimAutoreleasedReturnValue();
              v31 = objc_msgSend(v30, "intValue");
              v32 = v63;
              v33 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithData:encoding:", v32, 4);
              v34 = 0;
              v35 = 0;
              v36 = 0;
              if (v31 < 0)
                v37 = -1;
              else
                v37 = v31;
              v38 = (v37 + 1);
              while (objc_msgSend(v33, "length") > v34)
              {
                if (objc_msgSend(v33, "characterAtIndex:", v34) == 10)
                {
                  ++v35;
                  v36 = v34;
                }
                if (v38 + 1 == ++v34)
                {

                  v40 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v39) + 16));
                  if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)v69 = 136315906;
                    v70 = "JSONParser.mm";
                    v71 = 1024;
                    v72 = 92;
                    v73 = 1024;
                    *(_DWORD *)v74 = v35;
                    *(_WORD *)&v74[4] = 1024;
                    *(_DWORD *)&v74[6] = v38 - v36;
                    _os_log_impl(&dword_2164CC000, v40, OS_LOG_TYPE_ERROR, "%25s:%-5d JSON parse error at line %d, column %d", v69, 0x1Eu);
                  }
                  goto LABEL_43;
                }
              }

              v41 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v43)
                                                                                                  + 16)));
              if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
              {
                v44 = objc_msgSend(objc_retainAutorelease(v28), "UTF8String");
                *(_DWORD *)v69 = 136315650;
                v70 = "JSONParser.mm";
                v71 = 1024;
                v72 = 96;
                v73 = 2080;
                *(_QWORD *)v74 = v44;
                _os_log_impl(&dword_2164CC000, v41, OS_LOG_TYPE_ERROR, "%25s:%-5d %s", v69, 0x1Cu);
              }
            }
            else
            {
              v41 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v29)
                                                                                                  + 16)));
              if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
              {
                v42 = objc_msgSend(objc_retainAutorelease(v28), "UTF8String");
                *(_DWORD *)v69 = 136315650;
                v70 = "JSONParser.mm";
                v71 = 1024;
                v72 = 101;
                v73 = 2080;
                *(_QWORD *)v74 = v42;
                _os_log_impl(&dword_2164CC000, v41, OS_LOG_TYPE_ERROR, "%25s:%-5d %s", v69, 0x1Cu);
              }
            }

LABEL_43:
            ;
          }
          v26 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v80, buf, 16);
        }
        while (v26);
      }
    }
    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        objc_msgSend(v61, "objectForKeyedSubscript:", CFSTR("PHASEJSONVersion"));
        obj = (id)objc_claimAutoreleasedReturnValue();
        if (obj && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
        {
          if (objc_msgSend(obj, "integerValue") == 1)
          {
            *a2 = objc_retainAutorelease(v61);
            v9 = 1;
LABEL_52:

            goto LABEL_53;
          }
          v53 = (void *)MEMORY[0x24BDD17C8];
          objc_msgSend(MEMORY[0x24BDD1488], "mainBundle");
          v54 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v54, "localizedStringForKey:value:table:", CFSTR("Unsupported PHASEJSONVersion.  Should be %d, found %d"), &stru_24D582B00, 0);
          v55 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v53, "stringWithFormat:", v55, 1, objc_msgSend(obj, "intValue"), v7);
          v48 = (void *)objc_claimAutoreleasedReturnValue();

          v57 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v56)
                                                                                              + 16)));
          if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "JSONParser.mm";
            v76 = 1024;
            v77 = 118;
            v78 = 2080;
            v79 = objc_msgSend(objc_retainAutorelease(v48), "UTF8String");
            _os_log_impl(&dword_2164CC000, v57, OS_LOG_TYPE_ERROR, "%25s:%-5d %s", buf, 0x1Cu);
          }

          if (a3)
          {
            *(_QWORD *)&v80 = *MEMORY[0x24BDD0FC8];
            *(_QWORD *)buf = v48;
            objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", buf, &v80, 1);
            v58 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", CFSTR("com.apple.coreaudio.phase"), 1346924647, v58);
            *a3 = (id)objc_claimAutoreleasedReturnValue();

          }
        }
        else
        {
          v45 = (void *)MEMORY[0x24BDD17C8];
          objc_msgSend(MEMORY[0x24BDD1488], "mainBundle");
          v46 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v46, "localizedStringForKey:value:table:", CFSTR("Data is not a valid PHASE JSON"), &stru_24D582B00, 0);
          v47 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v45, "stringWithFormat:", v47);
          v48 = (void *)objc_claimAutoreleasedReturnValue();

          v50 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v49)
                                                                                              + 16)));
          if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "JSONParser.mm";
            v76 = 1024;
            v77 = 131;
            v78 = 2080;
            v79 = objc_msgSend(objc_retainAutorelease(v48), "UTF8String");
            _os_log_impl(&dword_2164CC000, v50, OS_LOG_TYPE_ERROR, "%25s:%-5d %s", buf, 0x1Cu);
          }

          if (a3)
          {
            *(_QWORD *)&v80 = *MEMORY[0x24BDD0FC8];
            *(_QWORD *)buf = v48;
            objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", buf, &v80, 1);
            v51 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", CFSTR("com.apple.coreaudio.phase"), 1346924648, v51);
            *a3 = (id)objc_claimAutoreleasedReturnValue();

          }
        }

      }
      else
      {
        v18 = (void *)MEMORY[0x24BDD17C8];
        objc_msgSend(MEMORY[0x24BDD1488], "mainBundle");
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v19, "localizedStringForKey:value:table:", CFSTR("Data is not a valid PHASE JSON"), &stru_24D582B00, 0);
        v20 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v18, "stringWithFormat:", v20);
        obj = (id)objc_claimAutoreleasedReturnValue();

        v22 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v21)
                                                                                            + 16)));
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "JSONParser.mm";
          v76 = 1024;
          v77 = 146;
          v78 = 2080;
          v79 = objc_msgSend(objc_retainAutorelease(obj), "UTF8String");
          _os_log_impl(&dword_2164CC000, v22, OS_LOG_TYPE_ERROR, "%25s:%-5d %s", buf, 0x1Cu);
        }

        if (a3)
        {
          *(_QWORD *)&v80 = *MEMORY[0x24BDD0FC8];
          *(_QWORD *)buf = obj;
          objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", buf, &v80, 1);
          v23 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", CFSTR("com.apple.coreaudio.phase"), 1346924648, v23);
          *a3 = (id)objc_claimAutoreleasedReturnValue();

        }
      }
    }
    v9 = 0;
    goto LABEL_52;
  }
  v10 = (void *)MEMORY[0x24BDD17C8];
  objc_msgSend(MEMORY[0x24BDD1488], "mainBundle");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "localizedStringForKey:value:table:", CFSTR("Could not read file %@"), &stru_24D582B00, 0);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v62, "resourceSpecifier");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v10, "stringWithFormat:", v12, v13);
  v14 = (void *)objc_claimAutoreleasedReturnValue();

  v16 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v15)
                                                                                      + 16)));
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "JSONParser.mm";
    v76 = 1024;
    v77 = 29;
    v78 = 2080;
    v79 = objc_msgSend(objc_retainAutorelease(v14), "UTF8String");
    _os_log_impl(&dword_2164CC000, v16, OS_LOG_TYPE_ERROR, "%25s:%-5d %s", buf, 0x1Cu);
  }

  if (a3)
  {
    v67 = *MEMORY[0x24BDD0FC8];
    v68 = v14;
    objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v68, &v67, 1);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", CFSTR("com.apple.coreaudio.phase"), 1346924647, v17);
    *a3 = (id)objc_claimAutoreleasedReturnValue();

  }
  v9 = 0;
LABEL_53:

  return v9;
}

void sub_2165F5BD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void Phase::MakeDataBundleFromJSONFile(_BYTE *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void **a4@<X3>, _QWORD *a5@<X8>)
{
  char v9;
  id v10;
  id v11;
  id v12;

  v11 = a2;
  v12 = 0;
  v9 = Phase::ParseJSONFile(v11, &v12, a4);
  v10 = v12;
  if ((v9 & 1) != 0)
    Phase::MakeDataBundle(a1, v10, a3, a4, a5);
  else
    *a5 = 0;

}

void sub_2165F5E68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  void *v9;

  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::LateReverbIRBuildControl::IsNewIRPerceptuallyDifferent(uint64_t a1, float *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  float *v8;
  float *v9;
  float v10;
  float *v11;
  float *v12;
  float v13;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;

  v6 = *((unsigned int *)a2 + 31);
  if ((_DWORD)v6 == *(_DWORD *)(a1 + 124) && (v7 = *((unsigned int *)a2 + 63), (_DWORD)v7 == *(_DWORD *)(a1 + 252)))
  {
    if ((_DWORD)v6)
    {
      v8 = (float *)a1;
      v9 = a2;
      do
      {
        v10 = *v9;
        if (*v8 == 0.0)
        {
          if (v10 != 0.0)
            goto LABEL_20;
        }
        else if (v10 == 0.0
               || fabsf((float)(v10 / *v8) + -1.0) > (float)(Phase::SpatialModeler::LateReverbIRBuildControl::sToleranceRT60InPercent[*(unsigned int *)(a1 + 256)]
                                                           / 100.0))
        {
          goto LABEL_20;
        }
        ++v9;
        ++v8;
        --v6;
      }
      while (v6);
    }
    if ((_DWORD)v7)
    {
      v11 = a2 + 32;
      v12 = (float *)(a1 + 128);
      do
      {
        v13 = *v11;
        if (*v12 == 0.0)
        {
          if (v13 != 0.0)
            goto LABEL_20;
        }
        else if (v13 == 0.0
               || fabsf(log10f(v13 / *v12) * 10.0) > Phase::SpatialModeler::LateReverbIRBuildControl::sToleranceEnergyInDb[*(unsigned int *)(a1 + 256)])
        {
          goto LABEL_20;
        }
        ++v11;
        ++v12;
        --v7;
      }
      while (v7);
    }
    return 0;
  }
  else
  {
LABEL_20:
    if (a3)
    {
      v15 = *(_OWORD *)a2;
      v16 = *((_OWORD *)a2 + 1);
      v17 = *((_OWORD *)a2 + 3);
      *(_OWORD *)(a1 + 32) = *((_OWORD *)a2 + 2);
      *(_OWORD *)(a1 + 48) = v17;
      *(_OWORD *)a1 = v15;
      *(_OWORD *)(a1 + 16) = v16;
      v18 = *((_OWORD *)a2 + 4);
      v19 = *((_OWORD *)a2 + 5);
      v20 = *((_OWORD *)a2 + 7);
      *(_OWORD *)(a1 + 96) = *((_OWORD *)a2 + 6);
      *(_OWORD *)(a1 + 112) = v20;
      *(_OWORD *)(a1 + 64) = v18;
      *(_OWORD *)(a1 + 80) = v19;
      v21 = *((_OWORD *)a2 + 8);
      v22 = *((_OWORD *)a2 + 9);
      v23 = *((_OWORD *)a2 + 11);
      *(_OWORD *)(a1 + 160) = *((_OWORD *)a2 + 10);
      *(_OWORD *)(a1 + 176) = v23;
      *(_OWORD *)(a1 + 128) = v21;
      *(_OWORD *)(a1 + 144) = v22;
      v24 = *((_OWORD *)a2 + 12);
      v25 = *((_OWORD *)a2 + 13);
      v26 = *((_OWORD *)a2 + 15);
      *(_OWORD *)(a1 + 224) = *((_OWORD *)a2 + 14);
      *(_OWORD *)(a1 + 240) = v26;
      *(_OWORD *)(a1 + 192) = v24;
      *(_OWORD *)(a1 + 208) = v25;
    }
    return 1;
  }
}

uint64_t *Phase::SpatialModeler::LateReverbSimulationImpl::AllocClusterQueryState@<X0>(Phase::SpatialModeler::LateReverbSimulationImpl *this@<X0>, Phase::SpatialModeler::LateReverbSimulation *a2@<X1>, uint64_t *a3@<X8>)
{
  char *v6;
  char *v7;
  void *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v13;
  _BYTE v14[32];
  _QWORD v15[3];
  _QWORD *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(*((_QWORD *)a2 + 11) + 48))
    v6 = (char *)this + 26640;
  else
    v6 = (char *)this + 1344;
  v7 = v6 + 25256;
  v8 = (void *)Phase::SpatialModeler::SingleBlockAllocator::Alloc((Phase::SpatialModeler::SingleBlockAllocator *)(v6 + 25256), 137856, 0x10uLL);
  bzero(v8, 0x21A80uLL);
  Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState::ClusterQueryState((Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState *)v8);
  v15[0] = &off_24D57C668;
  v15[1] = v7;
  v16 = v15;
  v13 = v8;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v14, (uint64_t)v15);
  v9 = v16;
  if (v16 == v15)
  {
    v10 = 4;
    v9 = v15;
    goto LABEL_8;
  }
  if (v16)
  {
    v10 = 5;
LABEL_8:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }
  v11 = (uint64_t)v13;
  v13[9] = *((_QWORD *)this + 3);
  *(_QWORD *)(v11 + 137808) = Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationBegin;
  v13 = 0;
  *a3 = v11;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)(a3 + 1), (uint64_t)v14);
  return std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v13);
}

uint64_t Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationBegin@<X0>(Phase::SpatialModeler::LateReverbSimulationImpl *this@<X0>, Phase::SpatialModeler::RoomSimulation *a2@<X1>, Phase::SpatialModeler::Query *a3@<X2>, Phase::Logger *a4@<X8>)
{
  uint64_t InstancePtr;
  Phase::Logger *v10;
  Phase::Logger *v11;
  NSObject *v12;
  NSObject *v13;
  _BYTE *v14;
  float *v15;
  uint64_t v16;
  uint64_t v17;
  float *v18;
  Phase::SpatialModeler::RayTracerState *v19;
  Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState *v20;
  uint64_t v21;
  uint64_t v22;
  Phase::Logger *v24;
  uint64_t v25;
  char *v26;
  int v27;
  BOOL v28;
  NSObject *v29;
  __int128 *v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _DWORD *v35;
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t *v41;
  char *v42;
  char *v43;
  uint64_t v44;
  char *v45;
  uint64_t (***v46)();
  uint64_t v47;
  char *v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  uint64_t (***v52)();
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  float32x2_t *v57;
  Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState *v58;
  uint64_t v59;
  _QWORD *v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  float v67;
  float32x2_t v68;
  float v69;
  float v70;
  char v71;
  uint64_t v72;
  uint64_t v73;
  float *v74;
  float v75;
  float v76;
  float v77;
  float v78;
  uint64_t v79;
  float v80;
  float SharedEnergyReFixedDb;
  uint64_t v82;
  float v83;
  float v84;
  _OWORD *v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  int v90;
  NSObject *v91;
  uint64_t v92;
  _QWORD *v93;
  char **v94;
  _QWORD *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  Phase::Geometry::SystemState *v99;
  Phase::Geometry::SystemState *v100;
  _QWORD v101[3];
  int v102;
  _BYTE v103[32];
  _BYTE v104[32];
  _QWORD v105[3];
  int v106;
  _BYTE v107[32];
  _BYTE v108[32];
  _BYTE v109[32];
  _BYTE v110[24];
  int v111;
  os_signpost_id_t *v112;
  Phase::Logger *v113;
  _BYTE v114[24];
  int v115;
  uint64_t v116;
  unint64_t v117;
  _BYTE buf[32];
  __int128 v119;
  _OWORD v120[5];
  __int128 v121;
  char v122;
  uint64_t (**v123)();
  uint64_t *v124;
  uint64_t (***v125)();
  uint64_t v126;

  v126 = *MEMORY[0x24BDAC8D0];
  InstancePtr = Phase::Logger::GetInstancePtr(this);
  v10 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(InstancePtr + 208));
  v113 = v10;
  v11 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v10);
  if (*((_BYTE *)v11 + 1192))
  {
    v12 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v11)
                                                                                        + 1184)));
    v13 = v12;
    if ((unint64_t)v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v12))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v13, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v10, "Phase_RoomSimulation_LateReverbBegin", "LateReverbBegin", buf, 2u);
    }

  }
  v112 = (os_signpost_id_t *)&v113;
  Phase::SpatialModeler::RoomSimulationImpl::RoomSimulationBeginInitCommon(this, a2, a3, (uint64_t)v110);
  if (v111 == 2)
  {
    std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__copy_constructor((uint64_t)v109, (uint64_t)v110);
    Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationBegin(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(a4, &v112, (uint64_t)v109);
    v14 = v109;
LABEL_20:
    std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v14);
    return std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v110);
  }
  v15 = (float *)((char *)a3 + 112800);
  v16 = *((_QWORD *)a2 + 8);
  v17 = *((_QWORD *)a2 + 11);
  v18 = (float *)((char *)a3 + 112876);
  Phase::SpatialModeler::RoomSimulationImpl::ParseOptionalProperties((uint64_t)this, v16, v17, (uint64_t *)a3 + 16940, (float *)a3 + 28219, (float *)a3 + 28216, (uint64_t)buf);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__generic_assign[abi:ne180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>>((uint64_t)v110, (uint64_t)buf);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)buf);
  if (v111 == 2)
  {
    std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__copy_constructor((uint64_t)v108, (uint64_t)v110);
    Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationBegin(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(a4, &v112, (uint64_t)v108);
    v14 = v108;
    goto LABEL_20;
  }
  if (*(_BYTE *)(v17 + 48))
    v20 = (Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 26720);
  else
    v20 = (Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 1424);
  if (*v15 <= 0.0)
  {
    Phase::SpatialModeler::RayTracerState::State::operator=((uint64_t)v20 + 496, (uint64_t)a3 + 113248);
    Phase::SpatialModeler::LateReverbSimulationImpl::ClusterLateReverb((Phase::SpatialModeler::LateReverbSimulationImpl *)v107, this, a2, a3);
    Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationBegin(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(a4, &v112, (uint64_t)v107);
    v14 = v107;
    goto LABEL_20;
  }
  if (*(_BYTE *)(v17 + 48))
  {
    v21 = *((_QWORD *)a2 + 11);
    v22 = (*(uint64_t (**)(Phase::SpatialModeler::LateReverbSimulationImpl *, float))(*(_QWORD *)this + 104))(this, *v15);
    if (v22 && *(_QWORD *)(v22 + 19448))
    {
      Phase::SpatialModeler::RayTracerState::operator=((uint64_t)this + 26720, v22);
      Phase::SpatialModeler::RoomSimulationLogging::CheckLRClusterResultAndSourceListenerResultCoherence((_QWORD *)this + 3340, (uint64_t)"RoomSimulationBegin - LR after sustain -> attack cache load", 59);
      Phase::SpatialModeler::RoomSimulationLogging::logInQuerySources((Phase::Logger *)(v21 + 104), (uint64_t)"RoomSimulationBegin - LR after sustain -> attack cache load", 59);
      Phase::SpatialModeler::RoomSimulationLogging::logRayTracerStateStatus((Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 26720), (uint64_t)"RoomSimulationBegin - LR after sustain -> attack cache load", 59);
      Phase::SpatialModeler::RoomSimulationImpl::CheckClusterQueryInput((uint64_t)this, a2, (uint64_t)v114);
      if (v115 == 2)
      {
        std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__move_constructor((uint64_t)v105, (uint64_t)v114);
LABEL_101:
        std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v114);
        Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationBegin(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(a4, &v112, (uint64_t)v105);
        v14 = v105;
        goto LABEL_20;
      }
      if (!*((_QWORD *)this + 5771))
      {
        v48 = (char *)this + 72;
        v49 = 4;
        goto LABEL_99;
      }
      v40 = *((_QWORD *)a2 + 8);
      v41 = (uint64_t *)*((_QWORD *)a2 + 12);
      v95 = (_QWORD *)*((_QWORD *)a2 + 11);
      v42 = (char *)operator new(0x150uLL, (std::align_val_t)0x10uLL);
      v43 = v42;
      v44 = 0;
      *((_DWORD *)v42 + 8) = 0;
      *(_OWORD *)v42 = 0u;
      *((_OWORD *)v42 + 1) = 0u;
      *(_QWORD *)(v42 + 36) = 1065353216;
      *(_QWORD *)(v42 + 44) = 0;
      *((_DWORD *)v42 + 13) = 1065353216;
      do
      {
        v45 = &v42[v44];
        *((_DWORD *)v45 + 14) = 0;
        *((_QWORD *)v45 + 8) = 0;
        v44 += 16;
      }
      while (v44 != 128);
      v97 = v40;
      *((_QWORD *)v42 + 23) = 0;
      *(_QWORD *)&v121 = 0;
      DWORD2(v121) = 0;
      Phase::Subbands<float>::Subbands((uint64_t)(v42 + 192), &v121, 3);
      v43[320] = 0;
      v123 = &off_24D57C6B0;
      LOBYTE(v124) = 0;
      v125 = &v123;
      *(_QWORD *)&v121 = v43;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v121 + 8, (uint64_t)&v123);
      v46 = v125;
      if (v125 == &v123)
      {
        v47 = 4;
        v46 = &v123;
      }
      else
      {
        if (!v125)
          goto LABEL_65;
        v47 = 5;
      }
      (*v46)[v47]();
LABEL_65:
      v50 = v121;
      *(_QWORD *)&v121 = 0;
      *(_QWORD *)buf = v50;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&buf[8], (uint64_t)&v121 + 8);
      *((_QWORD *)&v119 + 1) = 1;
      std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v121);
      v100 = (Phase::Geometry::SystemState *)(v41 + 1);
      std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::operator=[abi:ne180100](v41 + 1, (uint64_t *)buf);
      v41[6] = *((_QWORD *)&v119 + 1);
      std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)buf);
      v51 = operator new(1uLL, (std::align_val_t)1uLL);
      v123 = &off_24D57C788;
      LOBYTE(v124) = 0;
      v125 = &v123;
      *(_QWORD *)&v121 = v51;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v121 + 8, (uint64_t)&v123);
      v52 = v125;
      if (v125 == &v123)
      {
        v53 = 4;
        v52 = &v123;
      }
      else
      {
        if (!v125)
        {
LABEL_70:
          v54 = v121;
          *(_QWORD *)&v121 = 0;
          *(_QWORD *)buf = v54;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&buf[8], (uint64_t)&v121 + 8);
          *((_QWORD *)&v119 + 1) = 1;
          std::unique_ptr<BOOL [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v121);
          v94 = (char **)(v41 + 7);
          std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100](v41 + 7, (uint64_t *)buf);
          v41[12] = *((_QWORD *)&v119 + 1);
          std::unique_ptr<BOOL [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)buf);
          v55 = v95[18];
          v116 = 8;
          v117 = v55;
          v123 = (uint64_t (**)())&v117;
          v124 = &v116;
          Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput,std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput>(unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::SubmixRoutingOutput*)#1} const&>(v55, (uint64_t)&v123, &v121);
          v56 = v121;
          *(_QWORD *)&v121 = 0;
          *(_QWORD *)buf = v56;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&buf[8], (uint64_t)&v121 + 8);
          *((_QWORD *)&v119 + 1) = v55;
          std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v121);
          v93 = v41 + 13;
          std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>>::operator=[abi:ne180100](v41 + 13, (uint64_t *)buf);
          v41[18] = *((_QWORD *)&v119 + 1);
          v57 = (float32x2_t *)std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)buf);
          v59 = v40;
          if (!v95[18])
          {
LABEL_95:
            Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryCleanupCommon(this, a2, a3, v58);
            v90 = 1;
LABEL_100:
            v106 = v90;
            goto LABEL_101;
          }
          v60 = v95;
          v61 = 0;
          v62 = 16;
          while (1)
          {
            v63 = v60[13];
            v64 = v63 + 304 * v61;
            v65 = *(_QWORD *)(v64 + 144);
            if (*(_DWORD *)(v59 + 136) <= v65)
              break;
            v66 = *(_QWORD *)(v59 + 120);
            if (*(_DWORD *)(v66 + 24 * v65 + 20) != HIDWORD(v65))
              break;
            v57 = *(float32x2_t **)(v66 + 24 * *(_QWORD *)(v64 + 144));
            if (!v57 || v57->i32[0] != 3)
              break;
            v67 = *((float *)this + 12380) - v57[9].f32[0];
            v68 = vsub_f32(*(float32x2_t *)((char *)this + 49512), v57[8]);
            v69 = sqrtf(vaddv_f32(vmul_f32(v68, v68)) + (float)(v67 * v67));
            if (v69 <= 1000000.0)
              v70 = v69;
            else
              v70 = 1000000.0;
            v117 = *(_QWORD *)(*((_QWORD *)this + 5770) + 16);
            v121 = xmmword_2166F8020;
            if (v60[12])
            {
              v71 = 0;
              v121 = *(_OWORD *)v60[7];
            }
            else
            {
              v71 = 1;
            }
            **v94 = v71;
            LODWORD(v116) = 0;
            Phase::SpatialModeler::getClosestLRClusterToSourceInClusteringResults(v57, (Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 26720), &v117, &v121, (float *)&v116);
            v72 = *(_QWORD *)v100;
            *(_QWORD *)(v72 + 184) = v117;
            *(_OWORD *)v72 = v121;
            *(_BYTE *)(*(_QWORD *)v100 + 320) = 1;
            **v94 = 1;
            v73 = *(unsigned int *)(v64 + 140);
            if ((_DWORD)v73)
            {
              v59 = v97;
              v74 = (float *)(v63 + v62);
              v75 = -3.4028e38;
              do
              {
                v76 = *v74++;
                v77 = v76;
                if (v75 < v76)
                  v75 = v77;
                --v73;
              }
              while (v73);
            }
            else
            {
              v75 = -3.4028e38;
              v59 = v97;
            }
            v78 = (float)(fmaxf(v70, 1.0) * -0.5) + -6.0;
            v79 = *v93 + 16 * v61;
            *(_QWORD *)v79 = 0;
            if (v78 >= *(float *)&v116)
              v80 = *(float *)&v116;
            else
              v80 = (float)(v78 + *(float *)&v116) * 0.5;
            *(double *)(v79 + 8) = v80;
            SharedEnergyReFixedDb = Phase::SpatialModeler::RayTracerState::GetSharedEnergyReFixedDb((Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 26720), &v117);
            v82 = *v93 + 16 * v61;
            v83 = *(double *)(v82 + 8);
            v84 = v83 + (float)(*(float *)(v59 + 928) * (float)(SharedEnergyReFixedDb - v83));
            if (!*(_QWORD *)(v59 + 904))
              v84 = *(double *)(v82 + 8);
            *(double *)(v82 + 8) = v84;
            *(float *)&v123 = v75;
            *((float *)&v123 + 1) = v75;
            *(float *)&v124 = v75;
            v57 = (float32x2_t *)Phase::Subbands<float>::Subbands((uint64_t)buf, &v123, 3);
            v85 = *(_OWORD **)v100;
            v86 = v120[2];
            v85[16] = v120[1];
            v85[17] = v86;
            v87 = v120[4];
            v85[18] = v120[3];
            v85[19] = v87;
            v88 = *(_OWORD *)&buf[16];
            v85[12] = *(_OWORD *)buf;
            v85[13] = v88;
            v89 = v120[0];
            v85[14] = v119;
            v85[15] = v89;
            ++v61;
            v60 = v95;
            v62 += 304;
            if (v61 >= v95[18])
              goto LABEL_95;
          }
          v91 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr((Phase::Logger *)v57) + 1184));
          if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
          {
            v92 = *(_QWORD *)(v64 + 144);
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "LateReverbSimulationImpl.mm";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 773;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v92;
            _os_log_impl(&dword_2164CC000, v91, OS_LOG_TYPE_ERROR, "%25s:%-5d Source from persisting state not found in the Geo Layer (Handle %llu).", buf, 0x1Cu);
          }
          v48 = (char *)this + 72;
          v49 = 6;
LABEL_99:
          v105[0] = v49;
          v105[1] = v48;
          v90 = 2;
          goto LABEL_100;
        }
        v53 = 5;
      }
      (*v52)[v53]();
      goto LABEL_70;
    }
  }
  else
  {
    if (!*((_BYTE *)a3 + 112947))
    {
      v32 = *((_QWORD *)a2 + 8);
      v98 = *((_QWORD *)a2 + 11);
      v33 = *(_QWORD *)(v98 + 152);
      if (*(_DWORD *)(v32 + 136) <= v33
        || (v34 = *(_QWORD *)(v32 + 120), *(_DWORD *)(v34 + 24 * v33 + 20) != HIDWORD(v33))
        || (v35 = *(_DWORD **)(v34 + 24 * *(_QWORD *)(v98 + 152))) == 0
        || *v35 != 2)
      {
        v35 = 0;
      }
      v96 = (uint64_t)v35;
      v99 = (Phase::Geometry::SystemState *)*((_QWORD *)a2 + 8);
      if (Phase::SpatialModeler::RoomSimulation::psERtoLRModelerCache)
      {
        v36 = caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>::read_if ((unsigned int *)Phase::SpatialModeler::RoomSimulation::psERtoLRModelerCache);
        if (v36)
        {
          if ((float)((float)(std::chrono::steady_clock::now().__d_.__rep_ - *(_QWORD *)(v36 + 25048)) / 1000000000.0) < (float)(2.0 / *v18))
          {
            Phase::SpatialModeler::RayTracerState::CopyStateAndAssignToModelerInstance((uint64_t)this + 1424, (uint64_t)this, (uint64_t *)(v98 + 104), v96, v36, (uint64_t)v99);
            Phase::SpatialModeler::SimulationController::RequireSimulation((float *)this + 20, (Phase::SpatialModeler::Query *)((char *)a3 + 112752), (Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 1424), v99, (uint64_t)buf);
            v37 = v120[0];
            *(_OWORD *)((char *)this + 24264) = v119;
            *(_OWORD *)((char *)this + 24280) = v37;
            *(_OWORD *)((char *)this + 24294) = *(_OWORD *)((char *)v120 + 14);
            v38 = *(_OWORD *)&buf[16];
            *(_OWORD *)((char *)this + 24232) = *(_OWORD *)buf;
            *(_OWORD *)((char *)this + 24248) = v38;
            Phase::SpatialModeler::RoomSimulationLogging::logInQuerySources((Phase::Logger *)(v98 + 104), (uint64_t)"RoomSimulationBegin - LR after ER -> LR modeler cache load", 58);
            Phase::SpatialModeler::RoomSimulationLogging::logRayTracerStateStatus((Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 1424), (uint64_t)"RoomSimulationBegin - LR after ER -> LR modeler cache load", 58);
            Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationFinish(this, (Phase::Geometry::SystemState **)a2, a3, (Phase::Logger *)v104);
            Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationBegin(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(a4, &v112, (uint64_t)v104);
            v14 = v104;
            goto LABEL_20;
          }
        }
      }
    }
    Phase::SpatialModeler::RoomSimulationImpl::RoomSimulationBeginHandleSustainQueryCommon(this, a2, a3, (Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 1424), v19);
    v25 = 0;
    v26 = (char *)this + 24251;
    do
    {
      v27 = v26[v25];
      if (v26[v25])
        v28 = 1;
      else
        v28 = v25 == 18;
      ++v25;
    }
    while (!v28);
    if (!v27)
    {
      Phase::SpatialModeler::RayTracerState::State::operator=((uint64_t)this + 1920, (uint64_t)a3 + 113248);
      Phase::SpatialModeler::LateReverbSimulationImpl::ClusterLateReverb((Phase::SpatialModeler::LateReverbSimulationImpl *)v103, this, a2, a3);
      Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationBegin(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(a4, &v112, (uint64_t)v103);
      v14 = v103;
      goto LABEL_20;
    }
    if (!*((_BYTE *)this + 26464) || *((float *)this + 387) != *v18 || *((float *)this + 368) != *v15)
    {
      v29 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v24)
                                                                                          + 1184)));
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        Phase::SpatialModeler::RoomSimulationLogging::MakeInfoString((uint64_t)this + 1424, *((_DWORD *)this + 8));
        v30 = v122 >= 0 ? &v121 : (__int128 *)v121;
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "LateReverbSimulationImpl.mm";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 256;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = v30;
        _os_log_impl(&dword_2164CC000, v29, OS_LOG_TYPE_DEBUG, "%25s:%-5d %s", buf, 0x1Cu);
        if (v122 < 0)
          operator delete((void *)v121);
      }

    }
  }
  v31 = *(_DWORD *)(v16 + 168)
     && !*(_BYTE *)(v16 + 932)
     && *((_QWORD *)this + 6) <= (unint64_t)((uint64_t)(*((_QWORD *)v20 + 2617) - *((_QWORD *)v20 + 2616)) >> 2);
  Phase::SpatialModeler::RoomSimulationImpl::PrepareRayTrace(a3, v20, (Phase::SpatialModeler::RayTracerState *)*((unsigned int *)this + 15), v31);
  v39 = operator new(8uLL);
  *v39 = a3;
  memset(buf, 0, 24);
  std::vector<Phase::Geometry::SceneQueryBatch *>::__init_with_size[abi:ne180100]<Phase::Geometry::SceneQueryBatch **,Phase::Geometry::SceneQueryBatch **>(buf, v39, (uint64_t)(v39 + 1), 1uLL);
  operator delete(v39);
  memset(v101, 0, sizeof(v101));
  std::vector<Phase::Geometry::SceneQueryBatch *>::__init_with_size[abi:ne180100]<Phase::Geometry::SceneQueryBatch **,Phase::Geometry::SceneQueryBatch **>(v101, *(const void **)buf, *(uint64_t *)&buf[8], (uint64_t)(*(_QWORD *)&buf[8] - *(_QWORD *)buf) >> 3);
  v102 = 3;
  Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationBegin(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(a4, &v112, (uint64_t)v101);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v101);
  if (*(_QWORD *)buf)
  {
    *(_QWORD *)&buf[8] = *(_QWORD *)buf;
    operator delete(*(void **)buf);
  }
  return std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v110);
}

void sub_2165F6D90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,void *__p,uint64_t a60)
{
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)&a26);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)&a46);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::LateReverbSimulationImpl::RunCullQuery(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  *(_DWORD *)(*(_QWORD *)(a1 + 96) + 8) = 0;
  *(_DWORD *)(a2 + 24) = 1;
}

void Phase::SpatialModeler::LateReverbSimulationImpl::RunClusterQuery(Phase::Logger *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  char *v8;
  uint64_t (**v9)(Phase::Logger *, uint64_t, uint64_t);
  uint64_t InstancePtr;
  Phase::Logger *v11;
  Phase::Logger *v12;
  NSObject *v13;
  NSObject *v14;
  os_signpost_id_t v15;
  Phase::Logger *v16;
  Phase::Logger *v17;
  NSObject *v18;
  NSObject *v19;
  os_signpost_id_t v20;
  uint8_t v21[16];
  uint8_t buf[16];

  if (a3)
  {
    if (*(_BYTE *)(*(_QWORD *)(a2 + 88) + 48))
      v8 = (char *)a1 + 26640;
    else
      v8 = (char *)a1 + 1344;
    v9 = (uint64_t (**)(Phase::Logger *, uint64_t, uint64_t))(a3 + 137808);
    if (*(uint64_t (**)@<X0>(Phase::SpatialModeler::LateReverbSimulationImpl *@<X0>, Phase::SpatialModeler::RoomSimulation *@<X1>, Phase::SpatialModeler::Query *@<X2>, Phase::Logger *@<X8>))(a3 + 137808) == Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationBegin)
    {
      InstancePtr = Phase::Logger::GetInstancePtr(a1);
      v11 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(InstancePtr + 208));
      *((_QWORD *)v8 + 2966) = v11;
      v12 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v11);
      if (*((_BYTE *)v12 + 1192))
      {
        v13 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v12)
                                                                                            + 1184)));
        v14 = v13;
        v15 = *((_QWORD *)v8 + 2966);
        if (v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v13))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl(&dword_2164CC000, v14, OS_SIGNPOST_INTERVAL_BEGIN, v15, "Phase_RoomSimulation_LRClusterQuery", "LateReverbClusterQuery", buf, 2u);
        }

      }
    }
    v16 = (Phase::Logger *)(*v9)(a1, a2, a3);
    if (*(_DWORD *)(a4 + 24) == 1)
    {
      v17 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v16);
      if (*((_BYTE *)v17 + 1192))
      {
        v18 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v17)
                                                                                            + 1184)));
        v19 = v18;
        v20 = *((_QWORD *)v8 + 2966);
        if (v20 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v18))
        {
          *(_WORD *)v21 = 0;
          _os_signpost_emit_with_name_impl(&dword_2164CC000, v19, OS_SIGNPOST_INTERVAL_END, v20, "Phase_RoomSimulation_LRClusterQuery", (const char *)&unk_21676613F, v21, 2u);
        }

      }
    }
  }
  else
  {
    *(_QWORD *)a4 = 1;
    *(_QWORD *)(a4 + 8) = (char *)a1 + 72;
    *(_DWORD *)(a4 + 24) = 2;
  }
}

void sub_2165F7064(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::LateReverbSimulationImpl::RunSpatialQuery(uint64_t a1@<X0>, Phase::SpatialModeler::RoomSimulation *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t InstancePtr;
  Phase::Logger *v6;
  Phase::Logger *v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  Phase::Logger *v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  Phase::Logger *v15;
  NSObject *v16;
  NSObject *v17;
  Phase::Logger *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  NSObject *v26;
  uint64_t v27;
  _QWORD *v28;
  const Phase::SpatialModeler::RayTracerState *v29;
  uint64_t v30;
  _BOOL4 v31;
  int v32;
  uint64_t v33;
  int v34;
  BOOL v35;
  BOOL v36;
  char v37;
  uint64_t v38;
  _QWORD *v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  BOOL v43;
  _QWORD *v44;
  unint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  _BOOL4 v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  BOOL v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  BOOL v56;
  float v57;
  NSObject *v58;
  Phase::Logger *v59;
  int v60;
  __int128 *v61;
  NSObject *v62;
  int8x8_t v63;
  unint64_t v64;
  uint8x8_t v65;
  unint64_t v66;
  Phase::Logger *v67;
  _QWORD *v68;
  _QWORD *v69;
  unint64_t v70;
  NSObject *v71;
  uint64_t v72;
  const char *v73;
  uint64_t v74;
  uint64_t v75;
  float SumOfActiveRays;
  float v77;
  float v78;
  float *v79;
  float v80;
  NSObject *v82;
  float32x4_t *v83;
  float v84;
  uint64_t v85;
  uint64_t v86;
  float SharedEnergyReFixedDb;
  float v88;
  uint64_t v89;
  float v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  uint64_t v95;
  Phase::Logger *v96;
  Phase::Logger *v97;
  _BYTE *v98;
  Phase::Logger *v99;
  _BYTE *v100;
  NSObject *v101;
  _BOOL8 v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  Phase::Logger *v106;
  uint64_t v107;
  __int128 v108;
  __int128 v109;
  uint64_t v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  NSObject *v114;
  uint64_t v115;
  uint64_t v116;
  unsigned int v117;
  float v118;
  Phase::SpatialModeler::RayTracerState *v119;
  uint64_t v120;
  int v121;
  float *v122;
  uint64_t v123;
  unint64_t v124;
  uint64_t v125;
  int v126;
  float v127;
  int v128;
  float *v129;
  char v130;
  BOOL v131;
  float v132;
  float v133;
  int v134;
  float v135;
  Phase::Logger *v136;
  float v137;
  double v138;
  int v139;
  float v140;
  float v141;
  float v142;
  uint64_t v143;
  float v144;
  float v145;
  int v146;
  _QWORD *v147;
  uint64_t v148;
  _QWORD *v149;
  std::__shared_weak_count *v150;
  unint64_t *p_shared_owners;
  unint64_t v152;
  unint64_t v153;
  uint64_t v154;
  uint64_t v155;
  float v156;
  float v157;
  double v158;
  uint64_t v159;
  float v160;
  float v161;
  float v162;
  float v163;
  float *v164;
  unint64_t v165;
  int v166;
  int v167;
  float v168;
  float v169;
  uint64_t *v170;
  Phase::Logger *v171;
  uint64_t v172;
  float v173;
  __int32 v174;
  float v175;
  _QWORD *v176;
  uint64_t v177;
  unsigned int v178;
  unint64_t v179;
  unint64_t v180;
  int v181;
  Phase::SpatialModeler::RayTracerState *v182;
  __int128 v183;
  unint64_t v184;
  unsigned int v185;
  unsigned int v186;
  int v187;
  uint64_t v188;
  _BYTE *v189;
  _BYTE *v190;
  size_t v191;
  uint64_t v192;
  uint64_t v193;
  __int128 v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  char v199;
  unint64_t v200;
  uint64_t v201;
  uint64_t i;
  _DWORD *v203;
  _DWORD *v204;
  _DWORD *v205;
  int *v206;
  unint64_t v207;
  int v208;
  uint64_t v209;
  float v210;
  float v211;
  float v212;
  float v213;
  uint64_t v214;
  float v215;
  uint64_t v216;
  unint64_t v217;
  uint64_t v218;
  uint64_t v219;
  unint64_t v220;
  float v221;
  float *v222;
  uint64_t v223;
  float *v224;
  uint64_t v225;
  unint64_t v226;
  uint64_t v227;
  unint64_t v228;
  char *v229;
  float *v230;
  int v231;
  Phase::Logger *v232;
  void *v233;
  float *v234;
  unint64_t v235;
  float v236;
  int v237;
  float *v238;
  float v239;
  float *v240;
  uint64_t v241;
  unint64_t v242;
  uint64_t v243;
  unint64_t v244;
  char *v245;
  float *v246;
  float *v247;
  int v248;
  Phase::Logger *v249;
  void *v250;
  uint64_t v251;
  float32x4_t *v252;
  float *v253;
  float v254;
  float v255;
  Phase::Logger *v256;
  uint64_t v257;
  _BYTE *v258;
  float *v259;
  float *v260;
  void *v261;
  void *v262;
  uint64_t v263;
  uint64_t v264;
  float32x4_t *v265;
  NSObject *v266;
  float32x4_t v267;
  Phase::Logger *v268;
  NSObject *v269;
  NSObject *v270;
  std::__shared_weak_count *v271;
  unint64_t *v272;
  unint64_t v273;
  Phase::Logger *v274;
  Phase::Logger *v275;
  NSObject *v276;
  NSObject *v277;
  Phase::Logger *v278;
  NSObject *v279;
  std::runtime_error *exception;
  uint64_t v281;
  uint64_t v282;
  _BOOL4 v283;
  BOOL v284;
  float32x2_t *v285;
  uint64_t v286;
  _QWORD *v287;
  uint64_t v288;
  int v289;
  unint64_t v290;
  _DWORD *v291;
  Phase::Logger *v293;
  uint64_t v294;
  Phase::Logger *spid;
  void *v296;
  float *v297;
  uint64_t v298;
  void *__p;
  float *v300;
  char *v301;
  Phase::SpatialModeler::RayTracerState *v302[2];
  unint64_t v303;
  _BYTE v304[24];
  int v305;
  uint8_t buf[48];
  _OWORD v307[2];
  float32x4_t v308;
  float32x4_t v309;
  float32x4_t v310;
  _OWORD v311[7];
  __int128 v312;
  __int128 v313;
  __int128 v314;
  __int128 v315;
  __int128 v316;
  __int128 v317;
  uint64_t v318;
  int v319;
  __int128 v320;
  __int128 v321;
  __int128 v322;
  __int128 v323;
  __int128 v324;
  __int128 v325;
  _BYTE v326[128];
  float32x4_t __dst[2];
  float32x4_t v328;
  float32x4_t v329;
  float32x4_t v330;
  float32x4_t v331;
  _BYTE v332[32];
  uint64_t v333;

  v333 = *MEMORY[0x24BDAC8D0];
  InstancePtr = Phase::Logger::GetInstancePtr((Phase::Logger *)a1);
  v6 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(InstancePtr + 208));
  v7 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v6);
  if (*((_BYTE *)v7 + 216))
  {
    v8 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v7)
                                                                                       + 208)));
    v9 = v8;
    if ((unint64_t)v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v9, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v6, "Phase_LateReverb_Spatial_Query_Begin", "LateReverbSimulation: Spatial Query Begin", buf, 2u);
    }

  }
  v10 = Phase::Logger::GetInstancePtr(v7);
  spid = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(v10 + 208));
  v11 = (Phase::Logger *)Phase::Logger::GetInstancePtr(spid);
  if (*((_BYTE *)v11 + 1192))
  {
    v12 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v11)
                                                                                        + 1184)));
    v13 = v12;
    if ((unint64_t)spid - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v12))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v13, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)spid, "Phase_RoomSimulation_LRSpatialQuery", "LateReverbSpatialQuery", buf, 2u);
    }

  }
  v14 = Phase::Logger::GetInstancePtr(v11);
  v293 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(v14 + 416));
  v15 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v293);
  if (*((_BYTE *)v15 + 1192))
  {
    v16 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v15)
                                                                                        + 1184)));
    v17 = v16;
    if ((unint64_t)v293 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v16))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v17, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v293, "Phase_RoomSimulation_HandleResultsLateReverb", "LateReverbHandleResults", buf, 2u);
    }

  }
  v18 = (Phase::Logger *)Phase::SpatialModeler::RoomSimulationImpl::CheckSpatialQueryInput(a1, a2, (uint64_t)v304);
  if (v305 == 2)
  {
    std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__move_constructor(a3, (uint64_t)v304);
    goto LABEL_357;
  }
  v19 = *((_QWORD *)a2 + 8);
  v20 = *((_QWORD *)a2 + 11);
  v21 = *((_QWORD *)a2 + 12);
  v22 = *(_QWORD *)(v20 + 552);
  if (*(_DWORD *)(v19 + 136) <= v22
    || (v23 = *(_QWORD *)(v19 + 120), *(_DWORD *)(v23 + 24 * v22 + 20) != HIDWORD(v22))
    || (v285 = *(float32x2_t **)(v23 + 24 * *(_QWORD *)(v20 + 552))) == 0
    || v285->i32[0] != 2)
  {
    v285 = 0;
  }
  v294 = *((_QWORD *)a2 + 8);
  if (*(_BYTE *)(v20 + 48))
    v24 = a1 + 26720;
  else
    v24 = a1 + 1424;
  v25 = 1;
  v303 = 1;
  if (*(_QWORD *)(v20 + 376) != 1)
  {
    v26 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v18)
                                                                                        + 1184)));
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      v27 = *(_QWORD *)(v20 + 376);
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "LateReverbSimulationImpl.mm";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 874;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v303;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = v27;
      _os_log_impl(&dword_2164CC000, v26, OS_LOG_TYPE_ERROR, "%25s:%-5d Cluster Key mismatch in HandleResultsLR: %llu vs. %llu", buf, 0x26u);
    }

    v25 = v303;
  }
  v28 = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v24 + 19464, v25, (uint64_t *)&v303);
  v30 = 0;
  v291 = (_DWORD *)(v24 + 19016);
  v31 = v28[3] == 0;
  v32 = *(unsigned __int8 *)(v20 + 48);
  v33 = v24 + 22865;
  do
  {
    v34 = *(unsigned __int8 *)(v33 + v30);
    if (*(_BYTE *)(v33 + v30))
      v35 = 1;
    else
      v35 = v30 == 18;
    ++v30;
  }
  while (!v35);
  v288 = v24 + 19464;
  if (v34)
    v36 = 1;
  else
    v36 = *(_BYTE *)(v24 + 168) == 0;
  v37 = *(_BYTE *)(v24 + 132);
  v302[0] = 0;
  v302[1] = 0;
  v290 = *(_QWORD *)(*((_QWORD *)a2 + 11) + 8);
  v38 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v38 + 2760) && (v38 = Phase::Geometry::SystemDebugger::GetFromSystem(v38)) != 0)
  {
    v39 = *(_QWORD **)(v38 + 112);
    if (!v39)
      goto LABEL_56;
    v40 = *(_QWORD *)(v20 + 552);
    v41 = v38 + 112;
    do
    {
      v42 = v39[4];
      v43 = v42 >= v40;
      if (v42 >= v40)
        v44 = v39;
      else
        v44 = v39 + 1;
      if (v43)
        v41 = (uint64_t)v39;
      v39 = (_QWORD *)*v44;
    }
    while (*v44);
    if (v41 == v38 + 112)
    {
LABEL_56:
      v287 = 0;
    }
    else
    {
      v45 = *(_QWORD *)(v41 + 32);
      v46 = v41 + 40;
      if (v45 <= v40)
        v47 = (_QWORD *)v46;
      else
        v47 = 0;
      v287 = v47;
    }
    v284 = *(_BYTE *)(v38 + 80) != 0;
    v286 = v38;
    v48 = *(_BYTE *)(v38 + 40) != 0;
  }
  else
  {
    v286 = 0;
    v287 = 0;
    v284 = 0;
    v48 = 1;
  }
  v283 = v48;
  if (*(float *)(v24 + 19512) > 0.0 && *v291)
  {
    if (!*(_BYTE *)(v24 + 168))
      goto LABEL_75;
    v49 = 0;
    v50 = v24 + 22808;
    do
    {
      v51 = *(unsigned __int8 *)(v50 + v49);
      if (*(_BYTE *)(v50 + v49))
        v52 = 1;
      else
        v52 = v49 == 18;
      ++v49;
    }
    while (!v52);
    if (v51)
      goto LABEL_75;
    v53 = 0;
    v54 = v24 + 22827;
    do
    {
      v55 = *(unsigned __int8 *)(v54 + v53);
      if (*(_BYTE *)(v54 + v53))
        v56 = 1;
      else
        v56 = v53 == 18;
      ++v53;
    }
    while (!v56);
    if (v55)
    {
LABEL_75:
      v57 = (float)(*(float *)(v24 + 19308) / (float)(*v291 - *(_DWORD *)(v24 + 64))) * 100.0;
      if (v57 > 3.0)
      {
        v58 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr((Phase::Logger *)v38)
                                                                                            + 1184)));
        if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "LateReverbSimulationImpl.mm";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 924;
          *(_WORD *)&buf[18] = 2048;
          *(double *)&buf[20] = v57;
          _os_log_impl(&dword_2164CC000, v58, OS_LOG_TYPE_ERROR, "%25s:%-5d High energy loss: %.1f%%.\n", buf, 0x1Cu);
        }

      }
    }
  }
  Phase::SpatialModeler::RoomSimulationLogging::logInvalidIntersections((Phase::SpatialModeler::RoomSimulationLogging *)v24, v29);
  v60 = v32 | v31;
  v61 = &xmmword_2166F8000;
  if (!((v37 | v36) | v60))
  {
    v67 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v288, v303, (uint64_t *)&v303)[3];
    if (v67)
      v67 = (Phase::Logger *)Phase::SpatialModeler::CopyMetadata<float>((uint64_t)v67, v21);
    v282 = 0;
    goto LABEL_214;
  }
  if (*(_QWORD *)(v20 + 208))
  {
    v62 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v59)
                                                                                        + 1184)));
    if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "LateReverbSimulationImpl.mm";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 937;
      _os_log_impl(&dword_2164CC000, v62, OS_LOG_TYPE_ERROR, "%25s:%-5d LR Spatial Query is called with an individual source but must be called with a cluster key.", buf, 0x12u);
    }

  }
  v63 = *(int8x8_t *)(v24 + 19432);
  if (!*(_QWORD *)&v63)
    goto LABEL_103;
  v64 = *(_QWORD *)(v20 + 376);
  v65 = (uint8x8_t)vcnt_s8(v63);
  v65.i16[0] = vaddlv_u8(v65);
  if (v65.u32[0] > 1uLL)
  {
    v66 = *(_QWORD *)(v20 + 376);
    if (*(_QWORD *)&v63 <= v64)
      v66 = v64 % *(_QWORD *)&v63;
  }
  else
  {
    v66 = (*(_QWORD *)&v63 - 1) & v64;
  }
  v68 = *(_QWORD **)(*(_QWORD *)(v24 + 19424) + 8 * v66);
  if (!v68 || (v69 = (_QWORD *)*v68) == 0)
  {
LABEL_103:
    v282 = 0;
    goto LABEL_104;
  }
  while (1)
  {
    v70 = v69[1];
    if (v70 == v64)
      break;
    if (v65.u32[0] > 1uLL)
    {
      if (v70 >= *(_QWORD *)&v63)
        v70 %= *(_QWORD *)&v63;
    }
    else
    {
      v70 &= *(_QWORD *)&v63 - 1;
    }
    if (v70 != v66)
      goto LABEL_103;
LABEL_102:
    v69 = (_QWORD *)*v69;
    if (!v69)
      goto LABEL_103;
  }
  if (v69[2] != v64)
    goto LABEL_102;
  if (!v69[8])
    goto LABEL_103;
  Phase::SpatialModeler::RayTracerState::CopyDirectivityHistogram((Phase::Logger *)v24, v69 + 8, (Phase::SpatialModeler::EnergyHistogram **)buf);
  v108 = *(_OWORD *)buf;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  *(_OWORD *)v302 = v108;
  v282 = (uint64_t)(v69 + 3);
LABEL_104:
  if (!v302[0])
  {
    if (*(_QWORD *)(v20 + 208))
    {
      v71 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v59)
                                                                                          + 1184)));
      if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
      {
        v72 = *(_QWORD *)(v20 + 208);
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "LateReverbSimulationImpl.mm";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 957;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v72;
        v73 = "%25s:%-5d No histogram found for given sound source handle %llu.";
        goto LABEL_110;
      }
    }
    else
    {
      v71 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v59)
                                                                                          + 1184)));
      if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
      {
        v74 = *(_QWORD *)(v20 + 376);
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "LateReverbSimulationImpl.mm";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 962;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v74;
        v73 = "%25s:%-5d No histogram found for given cluster key %llu.";
LABEL_110:
        _os_log_impl(&dword_2164CC000, v71, OS_LOG_TYPE_ERROR, v73, buf, 0x1Cu);
      }
    }

  }
  v312 = 0u;
  memset(v311, 0, sizeof(v311));
  v309 = 0u;
  v310 = 0u;
  v308 = 0u;
  memset(v307, 0, sizeof(v307));
  memset(buf, 0, sizeof(buf));
  if (v283)
  {
    v75 = *(_QWORD *)(a1 + 48);
    if (v75)
    {
      SumOfActiveRays = Phase::SpatialModeler::RayTracerState::getSumOfActiveRays((Phase::SpatialModeler::RayTracerState *)v24);
      v77 = *(float *)(v24 + 19512);
      v78 = 0.0;
      v79 = (float *)(v24 + 19904);
      do
      {
        v80 = 3.4028e38;
        if (SumOfActiveRays > 0.0 && v77 > 0.0 && *v79 > 0.0)
          v80 = sqrtf((float)((float)(v77 * 0.163) / *v79) / (float)(SumOfActiveRays * 12.566)) * 4.34;
        if (v80 >= v78)
          v78 = v80;
        ++v79;
        --v75;
      }
      while (v75);
      if (v78 > 3.0 && v78 < 3.4028e38)
      {
        v82 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v59)
                                                                                            + 1184)));
        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
        {
          __dst[0].i32[0] = 136315650;
          *(uint64_t *)((char *)__dst[0].i64 + 4) = (uint64_t)"LateReverbSimulationImpl.mm";
          __dst[0].i16[6] = 1024;
          *(__int32 *)((char *)&__dst[0].i32[3] + 2) = 984;
          __dst[1].i16[1] = 2048;
          *(double *)((char *)__dst[1].i64 + 4) = v78;
          _os_log_impl(&dword_2164CC000, v82, OS_LOG_TYPE_DEBUG, "%25s:%-5d High ray tracing simulation uncertainty for total level: %.1fdB", (uint8_t *)__dst, 0x1Cu);
        }

      }
    }
    else
    {
      v78 = 0.0;
    }
    if (*(_BYTE *)(v294 + 932))
    {
LABEL_132:
      v83 = (float32x4_t *)(v24 + 19776);
    }
    else
    {
      v84 = fminf(fmaxf((float)(v78 + -0.5) / 2.5, 0.0), 1.0);
      if (*(_BYTE *)(*((_QWORD *)a2 + 11) + 48))
        v85 = a1 + 26640;
      else
        v85 = a1 + 1344;
      v86 = v85 + 25136;
      *(Phase::SpatialModeler::RayTracerState **)(v85 + 25136) = v302[0];
      SharedEnergyReFixedDb = Phase::SpatialModeler::RayTracerState::GetSharedEnergyReFixedDb((Phase::SpatialModeler::RayTracerState *)v24, &v303);
      v88 = expf((float)((float)(SharedEnergyReFixedDb * -10.0) / 10.0) * 0.23026);
      v89 = v24 + 20800;
      v90 = (float)(v84 + -1.0) + 1.0;
      if (!*(_DWORD *)(v294 + 168))
      {
        Phase::SpatialModeler::TailCorrection::execute(v86, (Phase::SpatialModeler::TailCorrection *)v24, v89, (float *)(v24 + 20544), v90, v88);
        goto LABEL_132;
      }
      v83 = (float32x4_t *)(v24 + 21040);
      Phase::SpatialModeler::TailCorrection::executeTargetRt60(v86, (Phase::SpatialModeler::TailCorrection *)v24, v89, v24 + 21040, (float *)(v24 + 20544), v90, v88);
    }
    v91 = v83[5];
    v307[1] = v83[4];
    v308 = v91;
    v92 = v83[7];
    v309 = v83[6];
    v310 = v92;
    v93 = v83[1];
    *(float32x4_t *)buf = *v83;
    *(float32x4_t *)&buf[16] = v93;
    v94 = v83[3];
    *(float32x4_t *)&buf[32] = v83[2];
    v307[0] = v94;
  }
  if (!v302[0])
    goto LABEL_182;
  v95 = *(_QWORD *)(a1 + 48);
  memset(__dst, 0, sizeof(__dst));
  v328 = 0u;
  v329 = 0u;
  v330 = 0u;
  v331 = 0u;
  memset(v332, 0, 28);
  *(_DWORD *)&v332[28] = v95;
  v96 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v59);
  if (*(_QWORD *)(a1 + 48) == (uint64_t)(*((_QWORD *)v96 + 185) - *((_QWORD *)v96 + 184)) >> 2)
  {
    v97 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v96);
    v98 = (_BYTE *)*((_QWORD *)v97 + 184);
    v99 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v97);
    v100 = (_BYTE *)*((_QWORD *)v99 + 185);
    if (v100 != v98)
      v99 = (Phase::Logger *)memmove(__dst, v98, v100 - v98);
  }
  else
  {
    if (*(_DWORD *)&v332[28])
      bzero(__dst, 4 * *(unsigned int *)&v332[28]);
    v101 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v96)
                                                                                         + 1184)));
    v102 = os_log_type_enabled(v101, OS_LOG_TYPE_ERROR);
    if (v102)
    {
      v103 = Phase::Logger::GetInstancePtr((Phase::Logger *)v102);
      v104 = (uint64_t)(*(_QWORD *)(v103 + 1480) - *(_QWORD *)(v103 + 1472)) >> 2;
      v105 = *(_QWORD *)(a1 + 48);
      *(_DWORD *)v326 = 136315906;
      *(_QWORD *)&v326[4] = "LateReverbSimulationImpl.mm";
      *(_WORD *)&v326[12] = 1024;
      *(_DWORD *)&v326[14] = 1054;
      *(_WORD *)&v326[18] = 2048;
      *(_QWORD *)&v326[20] = v104;
      *(_WORD *)&v326[28] = 2048;
      *(_QWORD *)&v326[30] = v105;
      _os_log_impl(&dword_2164CC000, v101, OS_LOG_TYPE_ERROR, "%25s:%-5d Error setting phase_room_eq_lr: Its sub-band count of %zu does not match the modeler internal sub-band count of %zu", v326, 0x26u);
    }

  }
  if ((*(_DWORD *)(v294 + 168) | 2) != 3)
    goto LABEL_164;
  v106 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v99);
  if (!*((_BYTE *)v106 + 1440) || *(_BYTE *)(v294 + 932))
    goto LABEL_164;
  v107 = *(_QWORD *)(a1 + 48);
  switch(v107)
  {
    case 31:
      *(_OWORD *)&v326[108] = *(_OWORD *)(v294 + 736);
      v111 = *(_OWORD *)(v294 + 708);
      *(_OWORD *)&v326[64] = *(_OWORD *)(v294 + 692);
      *(_OWORD *)&v326[80] = v111;
      *(_OWORD *)&v326[96] = *(_OWORD *)(v294 + 724);
      v112 = *(_OWORD *)(v294 + 644);
      *(_OWORD *)v326 = *(_OWORD *)(v294 + 628);
      *(_OWORD *)&v326[16] = v112;
      v113 = *(_OWORD *)(v294 + 676);
      *(_OWORD *)&v326[32] = *(_OWORD *)(v294 + 660);
      *(_OWORD *)&v326[48] = v113;
      *(_DWORD *)&v326[124] = 31;
      goto LABEL_160;
    case 10:
      v109 = *(_OWORD *)(v294 + 316);
      *(_OWORD *)v326 = *(_OWORD *)(v294 + 300);
      *(_OWORD *)&v326[16] = v109;
      v110 = *(_QWORD *)(v294 + 332);
      memset(&v326[40], 0, 80);
      *(_QWORD *)&v326[32] = v110;
      *(_QWORD *)&v326[120] = 0xA00000000;
LABEL_160:
      Phase::Subbands<float>::operator+=(__dst, (float32x4_t *)v326);
      goto LABEL_164;
    case 3:
      *(_QWORD *)v326 = *(_QWORD *)(v294 + 196);
      *(_DWORD *)&v326[8] = *(_DWORD *)(v294 + 204);
      *(_DWORD *)&v326[124] = 3;
      memset(&v326[12], 0, 112);
      goto LABEL_160;
  }
  v114 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v106)
                                                                                       + 1184)));
  if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
  {
    v115 = *(_QWORD *)(a1 + 48);
    *(_DWORD *)v326 = 136315650;
    *(_QWORD *)&v326[4] = "LateReverbSimulationImpl.mm";
    *(_WORD *)&v326[12] = 1024;
    *(_DWORD *)&v326[14] = 1083;
    *(_WORD *)&v326[18] = 2048;
    *(_QWORD *)&v326[20] = v115;
    _os_log_impl(&dword_2164CC000, v114, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported sub-band count: %zu\n", v326, 0x1Cu);
  }

LABEL_164:
  if (*(_QWORD *)(a1 + 48))
  {
    v116 = 0;
    v117 = 0;
    do
    {
      v118 = __exp10f(__dst[0].f32[v116] / 10.0);
      v119 = v302[0];
      if (!*((_BYTE *)v302[0] + 36))
      {
        v120 = *((unsigned int *)v302[0] + 7);
        if (v120 > v117)
        {
          v121 = *((_DWORD *)v302[0] + 6);
          if (v121)
          {
            v122 = (float *)(*((_QWORD *)v302[0] + 1) + 4 * v117);
            v123 = 4 * v120;
            do
            {
              *v122 = v118 * *v122;
              v122 = (float *)((char *)v122 + v123);
              --v121;
            }
            while (v121);
          }
        }
      }
      v124 = *(_QWORD *)(a1 + 48);
      v116 = ++v117;
    }
    while (v124 > v117);
    if (v119)
    {
      HIDWORD(v312) = *(_QWORD *)(a1 + 48);
      if (v124)
      {
        v125 = 0;
        v126 = *((unsigned __int8 *)v119 + 36);
        do
        {
          v127 = 0.0;
          if (!v126)
          {
            v128 = *((_DWORD *)v119 + 6);
            if (v128)
            {
              v129 = (float *)(*((_QWORD *)v119 + 1) + 4 * v125);
              do
              {
                v127 = v127 + *v129;
                v129 += *((unsigned int *)v119 + 7);
                --v128;
              }
              while (v128);
            }
          }
          *((float *)v311 + v125++) = v127;
        }
        while (v125 != v124);
      }
    }
  }
  else
  {
    HIDWORD(v312) = 0;
  }
LABEL_182:
  v130 = *(_BYTE *)(v24 + 132) | Phase::SpatialModeler::LateReverbIRBuildControl::IsNewIRPerceptuallyDifferent(v24 + 22896, (float *)buf, 1);
  v131 = v130 != 0;
  if (v284 || *(_BYTE *)(v24 + 72))
    v132 = *(float *)(v24 + 108);
  else
    v132 = 0.0;
  if (v302[0])
    v133 = *((float *)v302[0] + 10);
  else
    v133 = 0.0;
  v134 = (v130 | v60);
  v135 = *(float *)(v24 + 464);
  v137 = log10f((float)((float)(1.0 / (float)((float)(v133 * v135) * (float)(v133 * v135))) * *(float *)(v24 + 104))+ 1.0e-15);
  v138 = *(double *)(a1 + 40);
  if (*(_BYTE *)(v24 + 135))
    v139 = 0;
  else
    v139 = (int)(v138 * v133);
  v281 = v20;
  if (v134 && v302[0])
  {
    v140 = *(float *)(v24 + 19512);
    v141 = *(float *)(v24 + 128);
    v142 = *(float *)(v24 + 112);
    v143 = Phase::Logger::GetInstancePtr(v136);
    v145 = expf((float)((float)(*(float *)(v143 + 1204) * 10.0) / 10.0) * 0.11513);
    v144 = v138;
    Phase::SpatialModeler::generateDirectionalMetadataLR(v302[0], v139, (uint64_t *)v21, v290, v140, v135, v144, fminf(fmaxf(v137 * 10.0, -144.0), -60.0), v141, v132, v142, v145);
    v146 = v60;
    v147 = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v288, v303, (uint64_t *)&v303);
    v148 = v147[3];
    if (!v148)
    {
      v149 = operator new(0xE8uLL);
      v149[1] = 0;
      v149[2] = 0;
      *v149 = &off_24D57E5C8;
      *((_DWORD *)v149 + 6) = 3;
      *((_BYTE *)v149 + 28) = 1;
      v149[4] = 0;
      *((_DWORD *)v149 + 57) = 0;
      v149[9] = 0;
      v149[10] = 0;
      v149[8] = 0;
      v149[15] = 0;
      v149[16] = 0;
      v149[14] = 0;
      v149[20] = 0;
      v149[21] = 0;
      v149[26] = 0;
      v149[27] = 0;
      *((_WORD *)v149 + 112) = 0;
      v149[25] = 0;
      v150 = (std::__shared_weak_count *)v147[4];
      v147[3] = v149 + 3;
      v147[4] = v149;
      if (v150)
      {
        p_shared_owners = (unint64_t *)&v150->__shared_owners_;
        do
          v152 = __ldaxr(p_shared_owners);
        while (__stlxr(v152 - 1, p_shared_owners));
        if (!v152)
        {
          ((void (*)(std::__shared_weak_count *))v150->__on_zero_shared)(v150);
          std::__shared_weak_count::__release_weak(v150);
        }
      }
      v148 = v147[3];
    }
    v67 = (Phase::Logger *)Phase::SpatialModeler::CopyMetadata<float>(v21, v148);
    if (v284 || *(_BYTE *)(v24 + 72))
    {
      v153 = *(_QWORD *)(v21 + 48);
      if (v153)
      {
        v154 = 0;
        v155 = 0;
        v156 = *(float *)(v24 + 76);
        v157 = *(float *)(v24 + 108) - v156;
        v158 = *(double *)(a1 + 40);
        v159 = *(_QWORD *)(v21 + 56);
        v160 = (float)(v158 * (float)(v156 + v156)) + -1.0;
        do
        {
          v161 = *(float *)(v159 + 4 * v155) - v157;
          if (v161 >= 0.0 && v161 < *(float *)(v24 + 76))
          {
            v162 = cosf((float)((float)(v158 * v161) * 6.2832) / v160);
            if (v290)
            {
              v163 = (float)(1.0 - v162) * 0.5;
              v164 = (float *)(*(_QWORD *)(v21 + 104) + *(_QWORD *)(*(_QWORD *)(v21 + 104) + 8) * v154 + 16);
              v165 = v290;
              do
              {
                *v164 = v163 * *v164;
                ++v164;
                --v165;
              }
              while (v165);
            }
          }
          ++v155;
          v154 += 4;
        }
        while (v153 > v155);
      }
    }
  }
  else
  {
    v146 = v60;
    v67 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v288, v303, (uint64_t *)&v303)[3];
    if (v67)
      v67 = (Phase::Logger *)Phase::SpatialModeler::CopyMetadata<float>((uint64_t)v67, v21);
  }
  v61 = &xmmword_2166F8000;
  v60 = v146;
  v20 = v281;
  if (!v131)
  {
LABEL_214:
    if (!v60
      && *(_QWORD *)(v294 + 904) == *(_QWORD *)(a1 + 1288)
      && vabds_f32(*(float *)(v294 + 928), *(float *)(a1 + 1296)) < 0.05)
    {
      v166 = 0;
      v167 = 0;
      goto LABEL_221;
    }
  }
  v168 = Phase::SpatialModeler::RayTracerState::GetSharedEnergyReFixedDb((Phase::SpatialModeler::RayTracerState *)v24, &v303);
  v169 = *(float *)(v294 + 928);
  v170 = *(uint64_t **)(a1 + 1280);
  v172 = Phase::Logger::GetInstancePtr(v171);
  v173 = expf((float)((float)(v168 * -10.0) / 10.0) * *((float *)v61 + 670));
  v67 = (Phase::Logger *)Phase::SpatialModeler::SpaceBlending((unint64_t *)(v294 + 904), (float *)(v294 + 912), v170, 1, *(_DWORD *)(v172 + 1228), v21, *(_QWORD *)(a1 + 48), v169, -144.0, v173);
  v167 = (int)v67;
  if (*(_BYTE *)(v24 + 170))
  {
    v174 = v285[7].i32[1];
    v175 = -v285[7].f32[0];
    *(float32x2_t *)buf = vneg_f32(v285[6]);
    *(float *)&buf[8] = v175;
    *(_DWORD *)&buf[12] = v174;
    Phase::SpatialModeler::RotateMetadata<float>(v21, (float *)buf);
    v176 = v287;
    v166 = 1;
  }
  else
  {
    v166 = 1;
LABEL_221:
    v176 = v287;
  }
  if (v286 && v176 && v302[0] && !*(_BYTE *)(v20 + 48))
  {
    if (v176[9])
    {
      *(_QWORD *)&buf[40] = 0;
      *(_QWORD *)&v307[0] = 0;
      v308 = 0uLL;
      v309.i64[1] = 0;
      v310 = 0uLL;
      memset((char *)v311 + 8, 0, 96);
      v312 = 0u;
      v313 = 0u;
      v314 = 0u;
      v315 = 0u;
      v316 = 0u;
      v317 = 0u;
      v324 = 0u;
      v325 = 0u;
      v322 = 0u;
      v323 = 0u;
      v320 = 0u;
      v321 = 0u;
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = 0;
      v177 = *(_QWORD *)(v24 + 22576);
      *(_QWORD *)&buf[32] = 0;
      *(_QWORD *)&buf[16] = v177;
      *((_QWORD *)&v307[0] + 1) = *((unsigned int *)v302[0] + 7);
      v178 = *((_DWORD *)v302[0] + 6);
      v307[1] = v178;
      __dst[0].i32[0] = 0;
      std::vector<float>::assign((char **)&v307[1] + 1, v178 * (unint64_t)DWORD2(v307[0]), __dst);
      v179 = *((_QWORD *)&v307[0] + 1);
      if (*((_QWORD *)&v307[0] + 1))
      {
        LODWORD(v180) = 0;
        v181 = 0;
        v182 = v302[0];
        v183 = v307[1];
        do
        {
          if ((_QWORD)v183)
          {
            LODWORD(v184) = 0;
            v185 = *((_DWORD *)v182 + 7);
            v186 = v180;
            do
            {
              v187 = 0;
              if (v185 > v180 && *((_DWORD *)v182 + 6) > v184)
                v187 = *(_DWORD *)(*((_QWORD *)v182 + 1) + 4 * v186);
              *(_DWORD *)(*((_QWORD *)&v183 + 1) + 4 * (v181 + v184)) = v187;
              v184 = (v184 + 1);
              v186 += v185;
            }
            while ((unint64_t)v183 > v184);
            v181 += v184;
          }
          v180 = (v180 + 1);
        }
        while (v179 > v180);
      }
      __dst[0].i64[0] = (uint64_t)buf;
      v188 = v176[9];
      if (!v188)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, float32x4_t *))(*(_QWORD *)v188 + 48))(v188, __dst);
      Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView::~RoomSimulationDebugView((Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)buf);
    }
    if (v176[5])
    {
      v289 = v167;
      *(_QWORD *)(v24 + 23216) = *(_QWORD *)(v24 + 22576);
      v189 = *(_BYTE **)(v24 + 23240);
      v190 = *(_BYTE **)(v24 + 23232);
      *(_QWORD *)&buf[40] = 0;
      *(_QWORD *)&v307[0] = 0;
      *(_QWORD *)&buf[32] = 0;
      v191 = v189 - v190;
      v35 = v189 == v190;
      v192 = (v189 - v190) >> 2;
      v193 = 0x6DB6DB6DB6DB6DB7 * v192;
      *(_QWORD *)(v24 + 23224) = 0x6DB6DB6DB6DB6DB7 * v192;
      v194 = *(_OWORD *)(v24 + 23216);
      *(_OWORD *)buf = *(_OWORD *)(v24 + 23200);
      *(_OWORD *)&buf[16] = v194;
      if (!v35)
      {
        std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugIntersection>::__vallocate[abi:ne180100](&buf[32], 0x6DB6DB6DB6DB6DB7 * v192);
        v195 = *(_QWORD *)&buf[40];
        memmove(*(void **)&buf[40], v190, v191);
        *(_QWORD *)&buf[40] = v195 + 28 * v193;
      }
      *(_OWORD *)((char *)v307 + 8) = *(_OWORD *)(v24 + 23256);
      v308 = 0uLL;
      *((_QWORD *)&v307[1] + 1) = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)&v307[1] + 1, *(const void **)(v24 + 23272), *(_QWORD *)(v24 + 23280), (uint64_t)(*(_QWORD *)(v24 + 23280) - *(_QWORD *)(v24 + 23272)) >> 2);
      v309 = (float32x4_t)*(unint64_t *)(v24 + 23296);
      v310 = 0uLL;
      v196 = *(_QWORD *)(v24 + 23304);
      v197 = *(_QWORD *)(v24 + 23312);
      __dst[0].i64[0] = (uint64_t)&v309.i64[1];
      __dst[0].i8[8] = 0;
      if (v197 != v196)
      {
        std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__vallocate[abi:ne180100](&v309.i64[1], 0xCCCCCCCCCCCCCCCDLL * ((v197 - v196) >> 3));
        v310.i64[0] = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*>((uint64_t)&v310.i64[1], v196, v197, v310.i64[0]);
      }
      Phase::SpatialModeler::RoomSimulationDebugger::DebugDirectionalMetadata::DebugDirectionalMetadata((Phase::SpatialModeler::RoomSimulationDebugger::DebugDirectionalMetadata *)v311, (const Phase::SpatialModeler::RoomSimulationDebugger::DebugDirectionalMetadata *)(v24 + 23328));
      Phase::SpatialModeler::RoomSimulationDebugger::DebugDirectionalMetadata::DebugDirectionalMetadata((Phase::SpatialModeler::RoomSimulationDebugger::DebugDirectionalMetadata *)((char *)&v311[6] + 8), (const Phase::SpatialModeler::RoomSimulationDebugger::DebugDirectionalMetadata *)(v24 + 23432));
      v318 = *(_QWORD *)(v24 + 23536);
      v319 = *(_DWORD *)(v24 + 23544);
      *(_QWORD *)&v321 = 0;
      v320 = 0uLL;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v320, *(const void **)(v24 + 23552), *(_QWORD *)(v24 + 23560), (uint64_t)(*(_QWORD *)(v24 + 23560) - *(_QWORD *)(v24 + 23552)) >> 2);
      v322 = 0uLL;
      *((_QWORD *)&v321 + 1) = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)&v321 + 1, *(const void **)(v24 + 23576), *(_QWORD *)(v24 + 23584), (uint64_t)(*(_QWORD *)(v24 + 23584) - *(_QWORD *)(v24 + 23576)) >> 2);
      v323 = 0uLL;
      *(_QWORD *)&v324 = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v323, *(const void **)(v24 + 23600), *(_QWORD *)(v24 + 23608), (uint64_t)(*(_QWORD *)(v24 + 23608) - *(_QWORD *)(v24 + 23600)) >> 2);
      v325 = 0uLL;
      *((_QWORD *)&v324 + 1) = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)&v324 + 1, *(const void **)(v24 + 23624), *(_QWORD *)(v24 + 23632), (uint64_t)(*(_QWORD *)(v24 + 23632) - *(_QWORD *)(v24 + 23624)) >> 2);
      __dst[0].i64[0] = (uint64_t)buf;
      v198 = v176[5];
      if (!v198)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, float32x4_t *))(*(_QWORD *)v198 + 48))(v198, __dst);
      v61 = &xmmword_2166F8000;
      v167 = v289;
      Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView::~RoomSimulationDebugView((Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)buf);
    }
    v199 = v166 ^ 1;
    if (!v176[21])
      v199 = 1;
    if ((v199 & 1) == 0)
    {
      *(_QWORD *)&buf[40] = 0;
      *(_QWORD *)&v307[0] = 0;
      *((_QWORD *)&v307[1] + 1) = 0;
      v308 = 0uLL;
      v309.i64[1] = 0;
      v310 = 0uLL;
      memset((char *)v311 + 8, 0, 96);
      v312 = 0u;
      v313 = 0u;
      v314 = 0u;
      v315 = 0u;
      v316 = 0u;
      v317 = 0u;
      v324 = 0u;
      v325 = 0u;
      v322 = 0u;
      v323 = 0u;
      v320 = 0u;
      v321 = 0u;
      memset(buf, 0, 24);
      *(_QWORD *)&buf[32] = 0;
      v200 = *(_QWORD *)(v21 + 48);
      __dst[0].i64[0] = 0;
      __dst[0].i32[2] = 0;
      std::vector<Phase::Vector<float,3ul>>::assign((char **)&v312, v200, __dst);
      __dst[0].i32[0] = 0;
      std::vector<float>::assign((char **)&v313 + 1, v200, __dst);
      *(_DWORD *)v326 = 0;
      std::vector<float>::vector(__dst, v290, v326);
      std::vector<std::vector<float>>::assign((uint64_t *)&v315, v200, (uint64_t)__dst);
      if (__dst[0].i64[0])
      {
        __dst[0].i64[1] = __dst[0].i64[0];
        operator delete((void *)__dst[0].i64[0]);
      }
      __dst[0].i8[0] = 0;
      std::vector<unsigned char>::assign((char **)&v316 + 1, v200, (char *)__dst);
      *((_QWORD *)&v311[6] + 1) = v200;
      *(float32x2_t *)&buf[16] = v285[1];
      if (v200)
      {
        v201 = 0;
        for (i = 0; i != v200; ++i)
        {
          v203 = (_DWORD *)(*(_QWORD *)(v21 + 8) + 12 * i);
          v204 = (_DWORD *)(v312 + 12 * i);
          *v204 = *v203;
          v204[1] = v203[1];
          v204[2] = v203[2];
          *(_DWORD *)(*((_QWORD *)&v313 + 1) + 4 * i) = *(_DWORD *)(*(_QWORD *)(v21 + 56) + 4 * i);
          *(_BYTE *)(*((_QWORD *)&v316 + 1) + i) = *(_BYTE *)(*(_QWORD *)(v21 + 144) + i);
          if (v290)
          {
            v205 = *(_DWORD **)(v315 + 24 * i);
            v206 = (int *)(*(_QWORD *)(v21 + 104) + *(_QWORD *)(*(_QWORD *)(v21 + 104) + 8) * v201 + 16);
            v207 = v290;
            do
            {
              v208 = *v206++;
              *v205++ = v208;
              --v207;
            }
            while (v207);
          }
          v201 += 4;
        }
      }
      __dst[0].i64[0] = (uint64_t)buf;
      v209 = v176[21];
      if (!v209)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, float32x4_t *))(*(_QWORD *)v209 + 48))(v209, __dst);
      Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView::~RoomSimulationDebugView((Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)buf);
    }
  }
  if (v166)
  {
    *(_BYTE *)(v21 + 4) = 1;
    v210 = Phase::SpatialModeler::RayTracerState::GetSharedEnergyReFixedDb((Phase::SpatialModeler::RayTracerState *)v24, &v303);
    v211 = *((float *)v61 + 670);
    v212 = expf((float)((float)(v210 * 10.0) / 10.0) * v211);
    v213 = v212;
    if (*(_QWORD *)(a1 + 1304))
    {
      if (v302[0])
      {
        v310.i64[0] = 0;
        v308 = 0u;
        v309 = 0u;
        memset(v307, 0, sizeof(v307));
        memset(buf, 0, sizeof(buf));
        *(int32x2_t *)&v310.u32[2] = vrev64_s32(*(int32x2_t *)(v24 + 19508));
        v214 = Phase::Logger::GetInstancePtr(v67);
        v215 = expf((float)((float)(*(float *)(v214 + 1204) * 10.0) / 10.0) * v211);
        if (*(_BYTE *)(v294 + 932))
        {
          v216 = *(_QWORD *)(v21 + 104);
          if (v216)
            v217 = *(_QWORD *)(v216 + 8);
          else
            v217 = 0;
          *(_DWORD *)v326 = 0;
          std::vector<float>::vector(__dst, v217, v326);
          Phase::SpatialModeler::GetRT60EstimateFromDirectionalMetadata(v21, (uint64_t *)__dst, -3.0, -15.0);
          Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationHandleResultsLateReverberation(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &)::$_0::operator()<unsigned long,std::vector<float>,Phase::PackedSubbands<float,10ul>>((Phase::Logger *)((__dst[0].i64[1] - __dst[0].i64[0]) >> 2), __dst[0].i64[0], __dst[0].i64[1], (uint64_t)buf);
          if (__dst[0].i64[0])
          {
            __dst[0].i64[1] = __dst[0].i64[0];
            operator delete((void *)__dst[0].i64[0]);
          }
        }
        else
        {
          if (*(_DWORD *)(v294 + 168))
            v218 = v24 + 21040;
          else
            v218 = v24 + 19776;
          Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationHandleResultsLateReverberation(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &)::$_0::operator()<unsigned long,std::array<float,31ul>,Phase::PackedSubbands<float,10ul>>(*(Phase::Logger **)(a1 + 48), v218, (uint64_t)buf);
        }
        if (v167)
        {
          memset(&v326[8], 0, 40);
          Phase::SpatialModeler::GetRoomDataForSpaceBlendTarget((uint64_t *)(v294 + 904), (uint64_t)v326);
          v219 = 0;
          *(float32x2_t *)&v310.u32[2] = vmla_n_f32(vmul_n_f32(*(float32x2_t *)v326, *(float *)(v294 + 928)), (float32x2_t)vrev64_s32(*(int32x2_t *)(v24 + 19508)), 1.0 - *(float *)(v294 + 928));
          do
          {
            *(float *)&buf[v219] = (float)(*(float *)(v294 + 928) * *(float *)&v326[v219 + 8])
                                 + (float)((float)(1.0 - *(float *)(v294 + 928)) * *(float *)&buf[v219]);
            v219 += 4;
          }
          while (v219 != 40);
          __p = 0;
          v300 = 0;
          v301 = 0;
          if (*(_QWORD *)(a1 + 48))
          {
            v220 = 0;
            do
            {
              v221 = v213 * Phase::SpatialModeler::GetTotalEnergyInBand<float>(v21, v220);
              v222 = v300;
              if (v300 >= (float *)v301)
              {
                v224 = (float *)__p;
                v225 = ((char *)v300 - (_BYTE *)__p) >> 2;
                v226 = v225 + 1;
                if ((unint64_t)(v225 + 1) >> 62)
                  std::vector<float>::__throw_length_error[abi:ne180100]();
                v227 = v301 - (_BYTE *)__p;
                if ((v301 - (_BYTE *)__p) >> 1 > v226)
                  v226 = v227 >> 1;
                if ((unint64_t)v227 >= 0x7FFFFFFFFFFFFFFCLL)
                  v228 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v228 = v226;
                if (v228)
                {
                  v229 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v301, v228);
                  v224 = (float *)__p;
                  v222 = v300;
                }
                else
                {
                  v229 = 0;
                }
                v230 = (float *)&v229[4 * v225];
                *v230 = v221;
                v223 = (uint64_t)(v230 + 1);
                while (v222 != v224)
                {
                  v231 = *((_DWORD *)v222-- - 1);
                  *((_DWORD *)v230-- - 1) = v231;
                }
                __p = v230;
                v300 = (float *)v223;
                v301 = &v229[4 * v228];
                if (v224)
                  operator delete(v224);
              }
              else
              {
                *v300 = v221;
                v223 = (uint64_t)(v222 + 1);
              }
              v300 = (float *)v223;
              ++v220;
              v232 = *(Phase::Logger **)(a1 + 48);
            }
            while ((unint64_t)v232 > v220);
            v233 = __p;
          }
          else
          {
            v223 = 0;
            v233 = 0;
            v232 = 0;
          }
          Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationHandleResultsLateReverberation(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &)::$_0::operator()<unsigned long,std::vector<float>,Phase::PackedSubbands<float,10ul>>(v232, (uint64_t)v233, v223, (uint64_t)&v308);
          v296 = 0;
          v297 = 0;
          v298 = 0;
          Phase::SpatialModeler::RayTracerState::calculateTotalSpecularEarlyEnergy((Phase::SpatialModeler::RayTracerState *)v24, (char *)__dst);
          v255 = *(float *)(v294 + 928);
          v257 = Phase::Logger::GetInstancePtr(v256);
          Phase::SpatialModeler::EstimateEarlyEnergy((int *)__dst, &v296, *(_DWORD *)(v257 + 1228), *(uint64_t **)(a1 + 1280), *(_QWORD *)(v294 + 904), v255);
          v258 = v296;
          v259 = v297;
          if (v296 == v297)
          {
            v262 = v296;
            v261 = v296;
          }
          else
          {
            v260 = (float *)v296;
            do
            {
              *v260 = v215 * *v260;
              ++v260;
            }
            while (v260 != v259);
            v261 = v296;
            v262 = v297;
          }
          Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationHandleResultsLateReverberation(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &)::$_0::operator()<unsigned long,std::vector<float>,Phase::PackedSubbands<float,10ul>>((Phase::Logger *)(((char *)v259 - v258) >> 2), (uint64_t)v261, (uint64_t)v262, (uint64_t)&buf[40]);
          if (v296)
          {
            v297 = (float *)v296;
            operator delete(v296);
          }
        }
        else
        {
          __p = 0;
          v300 = 0;
          v301 = 0;
          if (*(_QWORD *)(a1 + 48))
          {
            v234 = 0;
            v235 = 0;
            do
            {
              v236 = 0.0;
              if (!*((_BYTE *)v302[0] + 36))
              {
                v237 = *((_DWORD *)v302[0] + 6);
                if (v237)
                {
                  v238 = (float *)(*((_QWORD *)v302[0] + 1) + 4 * v235);
                  do
                  {
                    v236 = v236 + *v238;
                    v238 += *((unsigned int *)v302[0] + 7);
                    --v237;
                  }
                  while (v237);
                }
              }
              v239 = v213 * (float)(v215 * v236);
              if (v234 >= (float *)v301)
              {
                v240 = (float *)__p;
                v241 = ((char *)v234 - (_BYTE *)__p) >> 2;
                v242 = v241 + 1;
                if ((unint64_t)(v241 + 1) >> 62)
                  std::vector<float>::__throw_length_error[abi:ne180100]();
                v243 = v301 - (_BYTE *)__p;
                if ((v301 - (_BYTE *)__p) >> 1 > v242)
                  v242 = v243 >> 1;
                if ((unint64_t)v243 >= 0x7FFFFFFFFFFFFFFCLL)
                  v244 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v244 = v242;
                if (v244)
                {
                  v245 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v301, v244);
                  v240 = (float *)__p;
                  v234 = v300;
                }
                else
                {
                  v245 = 0;
                }
                v246 = (float *)&v245[4 * v241];
                *v246 = v239;
                v247 = v246 + 1;
                while (v234 != v240)
                {
                  v248 = *((_DWORD *)v234-- - 1);
                  *((_DWORD *)v246-- - 1) = v248;
                }
                __p = v246;
                v300 = v247;
                v301 = &v245[4 * v244];
                if (v240)
                  operator delete(v240);
                v234 = v247;
              }
              else
              {
                *v234++ = v239;
              }
              v300 = v234;
              ++v235;
              v249 = *(Phase::Logger **)(a1 + 48);
            }
            while ((unint64_t)v249 > v235);
            v250 = __p;
          }
          else
          {
            v234 = 0;
            v250 = 0;
            v249 = 0;
          }
          Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationHandleResultsLateReverberation(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &)::$_0::operator()<unsigned long,std::vector<float>,Phase::PackedSubbands<float,10ul>>(v249, (uint64_t)v250, (uint64_t)v234, (uint64_t)&v308);
          Phase::SpatialModeler::RayTracerState::calculateTotalSpecularEarlyEnergy((Phase::SpatialModeler::RayTracerState *)v24, v326);
          v251 = *(unsigned int *)&v326[124];
          memset(__dst, 0, sizeof(__dst));
          v328 = 0u;
          v329 = 0u;
          v330 = 0u;
          v331 = 0u;
          memset(v332, 0, 28);
          *(_DWORD *)&v332[28] = *(_DWORD *)&v326[124];
          if (*(_DWORD *)&v326[124])
          {
            v252 = __dst;
            v253 = (float *)v326;
            do
            {
              v254 = *v253++;
              v252->f32[0] = v215 * v254;
              v252 = (float32x4_t *)((char *)v252 + 4);
              --v251;
            }
            while (v251);
          }
          Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationHandleResultsLateReverberation(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &)::$_0::operator()<unsigned long,std::array<float,31ul>,Phase::PackedSubbands<float,10ul>>(*(Phase::Logger **)(a1 + 48), (uint64_t)__dst, (uint64_t)&buf[40]);
        }
        if (__p)
        {
          v300 = (float *)__p;
          operator delete(__p);
        }
        v263 = *(_QWORD *)(a1 + 1304);
        v330 = (float32x4_t)v307[1];
        v331 = v308;
        *(float32x4_t *)v332 = v309;
        *(float32x4_t *)&v332[16] = v310;
        __dst[0] = *(float32x4_t *)buf;
        __dst[1] = *(float32x4_t *)&buf[16];
        v328 = *(float32x4_t *)&buf[32];
        v329 = (float32x4_t)v307[0];
        v264 = **(_QWORD **)(v263 + 8);
        __p = 0;
        LOBYTE(v296) = 1;
        v265 = (float32x4_t *)Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v264, 144, (unint64_t *)&__p, (BOOL *)&v296);
        if (!v265)
        {
          v278 = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
          Phase::Logger::DumpTailspinWithThrottleAsync(v278, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
          v279 = objc_retainAutorelease(**(id **)(v264 + 48));
          if (os_log_type_enabled(v279, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)v326 = 136315394;
            *(_QWORD *)&v326[4] = "CommandQueue.hpp";
            *(_WORD *)&v326[12] = 1024;
            *(_DWORD *)&v326[14] = 100;
            _os_log_impl(&dword_2164CC000, v279, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; b"
              "uffer is full, unable to grow.\"",
              v326,
              0x12u);
          }
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
        }
        if ((_BYTE)v296)
        {
          v266 = objc_retainAutorelease(**(id **)(v264 + 48));
          if (os_log_type_enabled(v266, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)v326 = 136315906;
            *(_QWORD *)&v326[4] = "CommandQueue.hpp";
            *(_WORD *)&v326[12] = 1024;
            *(_DWORD *)&v326[14] = 89;
            *(_WORD *)&v326[18] = 2048;
            *(_QWORD *)&v326[20] = __p;
            *(_WORD *)&v326[28] = 2048;
            *(_QWORD *)&v326[30] = 144;
            _os_log_impl(&dword_2164CC000, v266, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", v326, 0x26u);
          }
        }
        v265->i64[0] = (uint64_t)&off_24D57E600;
        v265->i64[1] = v263;
        v267 = __dst[0];
        v265[5] = v330;
        v265[6] = v331;
        v265[7] = *(float32x4_t *)v332;
        v265[8] = *(float32x4_t *)&v332[16];
        v265[1] = v267;
        v265[2] = __dst[1];
        v265[3] = v328;
        v265[4] = v329;
        Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v264, 144);
        atomic_store(0, (unsigned __int8 *)(v264 + 40));
        v67 = (Phase::Logger *)Phase::SpatialModeler::RoomSimulationLogging::logRoomStatisticsAtIRBuild(v24, v282, (uint64_t)buf, *(unsigned __int8 *)(v294 + 932), v167, v213);
      }
    }
    else if (v302[0])
    {
      v67 = (Phase::Logger *)Phase::SpatialModeler::RoomSimulationLogging::logRoomStatisticsAtIRBuild((Phase::SpatialModeler::RoomSimulationLogging *)v24, v302[0], (const Phase::SpatialModeler::DirectivityHistogram *)*(unsigned __int8 *)(v294 + 932), v212);
    }
    *(_DWORD *)(a1 + 1296) = *(_DWORD *)(v294 + 928);
    *(_QWORD *)(a1 + 1288) = *(_QWORD *)(v294 + 904);
    ++*(_DWORD *)(v24 + 22132);
  }
  else
  {
    *(_BYTE *)(v21 + 4) = 0;
  }
  if (v302[0])
    Phase::SpatialModeler::RayTracerState::FreeDirectivityHistogram((Phase::Logger *)v24, v302);
  *(_DWORD *)&buf[24] = 1;
  v268 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v67);
  if (*((_BYTE *)v268 + 1192))
  {
    v269 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v268)
                                                                                         + 1184)));
    v270 = v269;
    if ((unint64_t)v293 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v269))
    {
      __dst[0].i16[0] = 0;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v270, OS_SIGNPOST_INTERVAL_END, (os_signpost_id_t)v293, "Phase_RoomSimulation_HandleResultsLateReverb", (const char *)&unk_21676613F, (uint8_t *)__dst, 2u);
    }

  }
  std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__move_constructor(a3, (uint64_t)buf);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)buf);
  v271 = (std::__shared_weak_count *)v302[1];
  if (v302[1])
  {
    v272 = (unint64_t *)((char *)v302[1] + 8);
    do
      v273 = __ldaxr(v272);
    while (__stlxr(v273 - 1, v272));
    if (!v273)
    {
      ((void (*)(std::__shared_weak_count *))v271->__on_zero_shared)(v271);
      std::__shared_weak_count::__release_weak(v271);
    }
  }
LABEL_357:
  v274 = (Phase::Logger *)std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v304);
  v275 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v274);
  if (*((_BYTE *)v275 + 1192))
  {
    v276 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v275)
                                                                                         + 1184)));
    v277 = v276;
    if ((unint64_t)spid - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v276))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v277, OS_SIGNPOST_INTERVAL_END, (os_signpost_id_t)spid, "Phase_RoomSimulation_LRSpatialQuery", (const char *)&unk_21676613F, buf, 2u);
    }

  }
}

void sub_2165F91FC(_Unwind_Exception *a1, int a2)
{
  void *v2;
  uint64_t v3;

  if (a2)
  {
    __cxa_free_exception(v2);
    __cxa_begin_catch(a1);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v3);
    __cxa_end_catch();
    JUMPOUT(0x2165F8F20);
  }
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationBegin(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(Phase::Logger *a1, os_signpost_id_t **a2, uint64_t a3)
{
  Phase::Logger *InstancePtr;
  NSObject *v7;
  NSObject *v8;
  os_signpost_id_t v9;
  uint8_t v11[16];

  InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(a1);
  if (*((_BYTE *)InstancePtr + 1192))
  {
    v7 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(InstancePtr)
                                                                                       + 1184)));
    v8 = v7;
    v9 = **a2;
    if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v7))
    {
      *(_WORD *)v11 = 0;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v8, OS_SIGNPOST_INTERVAL_END, v9, "Phase_RoomSimulation_LateReverbBegin", (const char *)&unk_21676613F, v11, 2u);
    }

  }
  return std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__move_constructor((uint64_t)a1, a3);
}

uint64_t Phase::SpatialModeler::LateReverbSimulationImpl::ClusterLateReverb(Phase::SpatialModeler::LateReverbSimulationImpl *this, Phase::SpatialModeler::RoomSimulation *a2, Phase::SpatialModeler::Query *a3, Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState *a4)
{
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  float32x2_t *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char *v14;
  __int128 *v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  __int128 *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _OWORD *v23;
  char *v24;
  const Handle64 *v25;
  float MaximumEnergy;
  Phase::Logger *v27;
  float v28;
  float32x2_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _DWORD *v35;
  float v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  NSObject *v40;
  uint64_t v41;
  float SharedEnergyReFixedDb;
  float v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  unint64_t v47;
  float v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  float32x2_t *v53;
  float32x2_t v54;
  float v55;
  float v56;
  uint64_t v57;
  float *v58;
  float v59;
  float v60;
  __n128 v61;
  int32x4_t v62;
  int32x2_t v63;
  uint64_t v64;
  uint64_t v65;
  double *v66;
  float v67;
  float v68;
  uint64_t v69;
  uint64_t v70;
  uint64x2_t v71;
  __int32 *v72;
  int64x2_t v73;
  int64x2_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int32x4_t v77;
  int32x2_t v78;
  int8x16_t v79;
  float v80;
  float v81;
  uint64_t v82;
  float *v83;
  float v84;
  BOOL v85;
  double v86;
  uint64_t v87;
  float32x2_t *v88;
  Phase::Logger *v89;
  NSObject *v90;
  uint64_t v91;
  float v92;
  float v93;
  float v94;
  std::__shared_weak_count *v95;
  unint64_t *v96;
  unint64_t v97;
  std::__shared_weak_count *v98;
  unint64_t *v99;
  unint64_t v100;
  Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState *v101;
  _OWORD *v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  uint8_t *v108;
  uint64_t v109;
  std::__shared_weak_count *v111;
  unint64_t *v112;
  unint64_t v113;
  std::__shared_weak_count *v114;
  unint64_t *v115;
  unint64_t v116;
  Phase::SpatialModeler::Query *v117;
  Phase::SpatialModeler::RoomSimulationImpl *v118;
  Phase::SpatialModeler::LateReverbSimulationImpl *v119;
  _OWORD **v120;
  char *v122;
  uint64_t v123;
  int64x2_t v124;
  float v125;
  unint64_t v126;
  _BYTE v127[24];
  int v128;
  uint64_t v129;
  unint64_t SoundSourceHash;
  uint8_t buf[32];
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  uint8_t v138[12];
  __int16 v139;
  int v140;
  __int16 v141;
  unint64_t v142;
  __int16 v143;
  double v144;
  __int128 v145;
  __int128 *v146;
  uint64_t v147;

  v147 = *MEMORY[0x24BDAC8D0];
  Phase::SpatialModeler::RoomSimulationImpl::CheckClusterQueryInput((uint64_t)a2, a3, (uint64_t)v127);
  if (v128 == 2)
  {
    std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__move_constructor((uint64_t)this, (uint64_t)v127);
    return std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v127);
  }
  v7 = *((_QWORD *)a3 + 8);
  v9 = *((_QWORD *)a3 + 11);
  v8 = (uint64_t *)*((_QWORD *)a3 + 12);
  if (*(_BYTE *)(v9 + 48))
    v10 = (float32x2_t *)((char *)a2 + 26720);
  else
    v10 = (float32x2_t *)((char *)a2 + 1424);
  v11 = (char *)operator new(0x150uLL, (std::align_val_t)0x10uLL);
  v12 = v11;
  v13 = 0;
  *((_DWORD *)v11 + 8) = 0;
  *(_OWORD *)v11 = 0u;
  *((_OWORD *)v11 + 1) = 0u;
  *(_QWORD *)(v11 + 36) = 1065353216;
  *(_QWORD *)(v11 + 44) = 0;
  *((_DWORD *)v11 + 13) = 1065353216;
  do
  {
    v14 = &v11[v13];
    *((_DWORD *)v14 + 14) = 0;
    *((_QWORD *)v14 + 8) = 0;
    v13 += 16;
  }
  while (v13 != 128);
  *((_QWORD *)v11 + 23) = 0;
  memset(v138, 0, sizeof(v138));
  Phase::Subbands<float>::Subbands((uint64_t)(v11 + 192), v138, 3);
  v12[320] = 0;
  *(_QWORD *)&v145 = &off_24D57C6B0;
  BYTE8(v145) = 0;
  v146 = &v145;
  *(_QWORD *)v138 = v12;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v138[8], (uint64_t)&v145);
  v15 = v146;
  if (v146 == &v145)
  {
    v16 = 4;
    v15 = &v145;
  }
  else
  {
    if (!v146)
      goto LABEL_13;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_13:
  v17 = *(_QWORD *)v138;
  *(_QWORD *)v138 = 0;
  *(_QWORD *)buf = v17;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&buf[8], (uint64_t)&v138[8]);
  *((_QWORD *)&v132 + 1) = 1;
  std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v138);
  v120 = (_OWORD **)(v8 + 1);
  std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::operator=[abi:ne180100](v8 + 1, (uint64_t *)buf);
  v8[6] = *((_QWORD *)&v132 + 1);
  std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)buf);
  v18 = operator new(1uLL, (std::align_val_t)1uLL);
  *(_QWORD *)&v145 = &off_24D57C788;
  BYTE8(v145) = 0;
  v146 = &v145;
  *(_QWORD *)v138 = v18;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v138[8], (uint64_t)&v145);
  v19 = v146;
  if (v146 == &v145)
  {
    v20 = 4;
    v19 = &v145;
    goto LABEL_17;
  }
  if (v146)
  {
    v20 = 5;
LABEL_17:
    (*(void (**)(void))(*(_QWORD *)v19 + 8 * v20))();
  }
  v21 = *(_QWORD *)v138;
  *(_QWORD *)v138 = 0;
  *(_QWORD *)buf = v21;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&buf[8], (uint64_t)&v138[8]);
  *((_QWORD *)&v132 + 1) = 1;
  std::unique_ptr<BOOL [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v138);
  std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100](v8 + 7, (uint64_t *)buf);
  v8[12] = *((_QWORD *)&v132 + 1);
  std::unique_ptr<BOOL [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)buf);
  v126 = 1;
  v22 = v8[1];
  *(_QWORD *)(v22 + 184) = 1;
  *(_BYTE *)(v22 + 320) = 1;
  *(_BYTE *)v8[7] = 1;
  *(_OWORD *)v22 = xmmword_2166F8020;
  if (*(_QWORD *)(v9 + 96))
  {
    v23 = *(_OWORD **)(v9 + 56);
    if (*(_QWORD *)v23)
      *(_OWORD *)v22 = *v23;
  }
  *(_QWORD *)buf = &v126;
  v24 = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)&v10[2428], &v126, (uint64_t)&std::piecewise_construct, (_QWORD **)buf);
  *(_OWORD *)(v24 + 88) = **v120;
  MaximumEnergy = Phase::SpatialModeler::GetMaximumEnergy((Phase::SpatialModeler *)v10, (const Phase::SpatialModeler::RayTracerState *)(v9 + 152), v25);
  v28 = __exp10f((float)(v10[18].f32[1] - v10[18].f32[0]) / 10.0);
  v29 = v10[2366];
  v30 = *(_QWORD *)&v10[2367] - *(_QWORD *)&v29;
  if (v30)
  {
    v31 = v30 / 56;
    if ((unint64_t)(v30 / 56) <= 1)
      v31 = 1;
    v32 = 48;
    while (1)
    {
      v33 = *(_QWORD *)(*(_QWORD *)&v29 + v32);
      if (*(_DWORD *)(v7 + 136) <= v33)
        break;
      v34 = *(_QWORD *)(v7 + 120);
      if (*(_DWORD *)(v34 + 24 * v33 + 20) != HIDWORD(v33))
        break;
      v35 = *(_DWORD **)(v34 + 24 * *(_QWORD *)(*(_QWORD *)&v29 + v32));
      if (!v35 || *v35 != 3)
        break;
      v32 += 56;
      if (!--v31)
        goto LABEL_30;
    }
    v40 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v27) + 1184));
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      v41 = *(_QWORD *)(*(_QWORD *)&v10[2366] + v32);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "LateReverbSimulationImpl.mm";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 579;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v41;
      _os_log_impl(&dword_2164CC000, v40, OS_LOG_TYPE_ERROR, "%25s:%-5d Source from persisting state not found in the Geo Layer (Handle %llu).", buf, 0x1Cu);
    }
    *(_QWORD *)this = 6;
    *((_QWORD *)this + 1) = (char *)a2 + 72;
    *((_DWORD *)this + 6) = 2;
  }
  else
  {
LABEL_30:
    v36 = MaximumEnergy * v28;
    v123 = (uint64_t)(v24 + 24);
    if (*((_QWORD *)v24 + 8))
    {
      memset(buf, 0, sizeof(buf));
      LODWORD(v132) = 1065353216;
      *((_QWORD *)&v132 + 1) = 0;
      *(_QWORD *)&v133 = 0;
      Phase::SpatialModeler::ConstructSharedHistogram(a2, v9, v36, v7, (uint64_t)v10, (uint64_t)buf);
      Phase::SpatialModeler::AggregateSharedHistogram((float *)v10, v126, (uint64_t)buf);
      Phase::SpatialModeler::RayTracerState::FreeDirectivityHistogram((Phase::Logger *)v10, (_QWORD *)&v132 + 1);
      v37 = (std::__shared_weak_count *)v133;
      if ((_QWORD)v133)
      {
        v38 = (unint64_t *)(v133 + 8);
        do
          v39 = __ldaxr(v38);
        while (__stlxr(v39 - 1, v38));
        if (!v39)
        {
          ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
          std::__shared_weak_count::__release_weak(v37);
        }
      }
      std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)buf);
    }
    else
    {
      Phase::SpatialModeler::ConstructSharedHistogram(a2, v9, v36, v7, (uint64_t)v10, (uint64_t)(v24 + 24));
    }
    SharedEnergyReFixedDb = Phase::SpatialModeler::RayTracerState::GetSharedEnergyReFixedDb((Phase::SpatialModeler::RayTracerState *)v10, &v126);
    v43 = expf((float)((float)(SharedEnergyReFixedDb * -10.0) / 10.0) * 0.23026);
    v122 = v24;
    Phase::SpatialModeler::DirectivityHistogram::operator*=(*((_QWORD **)v24 + 8), v43);
    v44 = *(_QWORD *)(v9 + 144);
    v129 = 8;
    SoundSourceHash = v44;
    *(_QWORD *)&v145 = &SoundSourceHash;
    *((_QWORD *)&v145 + 1) = &v129;
    Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput,std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput>(unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::SubmixRoutingOutput*)#1} const&>(v44, (uint64_t)&v145, v138);
    v117 = a3;
    v118 = a2;
    v119 = this;
    v45 = *(_QWORD *)v138;
    *(_QWORD *)v138 = 0;
    *(_QWORD *)buf = v45;
    std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&buf[8], (uint64_t)&v138[8]);
    *((_QWORD *)&v132 + 1) = v44;
    std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)v138);
    v46 = v8 + 13;
    std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>>::operator=[abi:ne180100](v8 + 13, (uint64_t *)buf);
    v8[18] = *((_QWORD *)&v132 + 1);
    std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)buf);
    if (*(_QWORD *)(v9 + 144))
    {
      v47 = 0;
      v48 = -3.4028e38;
      v49 = 16;
      v124 = vdupq_n_s64(4uLL);
      while (1)
      {
        v50 = *(_QWORD *)(v9 + 104);
        v51 = v50 + 304 * v47;
        SoundSourceHash = 0;
        v52 = (uint64_t *)(v51 + 144);
        SoundSourceHash = Phase::SpatialModeler::GetSoundSourceHash(*(_QWORD *)(v51 + 144), *(_QWORD *)(v9 + 152), v51 + 160);
        *(_QWORD *)buf = &SoundSourceHash;
        v53 = (float32x2_t *)std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v123, &SoundSourceHash, (uint64_t)&std::piecewise_construct, (_QWORD **)buf);
        v54 = vsub_f32(v10[2849], v53[3]);
        v55 = sqrtf(vaddv_f32(vmul_f32(v54, v54))+ (float)((float)(v10[2850].f32[0] - v53[4].f32[0]) * (float)(v10[2850].f32[0] - v53[4].f32[0])));
        if (v55 <= 1000000.0)
          v56 = v55;
        else
          v56 = 1000000.0;
        v57 = *(unsigned int *)(v51 + 140);
        if ((_DWORD)v57)
        {
          v58 = (float *)(v50 + v49);
          do
          {
            v59 = *v58++;
            v60 = v59;
            if (v48 < v59)
              v48 = v60;
            --v57;
          }
          while (v57);
        }
        *(_QWORD *)(*v46 + 16 * v47) = 0;
        v61.n128_f32[0] = Phase::SpatialModeler::RayTracerState::GetSourceListenerResult((uint64_t)v10, v52, (uint64_t *)(v9 + 152), v51 + 160, (uint64_t)buf);
        v64 = *v46;
        v65 = *v46 + 16 * v47;
        *(_QWORD *)(v65 + 8) = 0xC7EFFFFFE0000000;
        v66 = (double *)(v65 + 8);
        if (*(_QWORD *)&buf[16])
        {
          v67 = 1.1755e-38;
          if (*((float *)v122 + 20) > 1.1755e-38)
          {
            v68 = 0.0;
            if (!*(_BYTE *)(*(_QWORD *)&buf[16] + 36))
            {
              v69 = (*(_DWORD *)(*(_QWORD *)&buf[16] + 28) * *(_DWORD *)(*(_QWORD *)&buf[16] + 24));
              if ((_DWORD)v69)
              {
                v70 = (v69 + 3) & 0x1FFFFFFFCLL;
                v71 = (uint64x2_t)vdupq_n_s64(v69 - 1);
                v72 = (__int32 *)(*(_QWORD *)(*(_QWORD *)&buf[16] + 8) + 8);
                v73 = (int64x2_t)xmmword_2166F7AE0;
                v74 = (int64x2_t)xmmword_2166F7AD0;
                v75 = (float32x4_t)xmmword_2166F7AF0;
                do
                {
                  v76 = v75;
                  v77 = (int32x4_t)vcgeq_u64(v71, (uint64x2_t)v73);
                  *(int32x2_t *)v62.i8 = vmovn_s64((int64x2_t)v77);
                  *(int16x4_t *)v75.f32 = vmovn_s32(v62);
                  if ((v75.i8[0] & 1) != 0)
                    v75.i32[0] = *(v72 - 2);
                  if ((vmovn_s32(v62).i8[2] & 1) != 0)
                    v75.i32[1] = *(v72 - 1);
                  v62 = (int32x4_t)vcgeq_u64(v71, (uint64x2_t)v74);
                  v78 = (int32x2_t)vmovn_s32(vmovn_hight_s64(v63, (int64x2_t)v62));
                  if ((v78.i8[4] & 1) != 0)
                    v75.i32[2] = *v72;
                  if ((vmovn_s32(vmovn_hight_s64(v78, *(int64x2_t *)&v62)).i8[6] & 1) != 0)
                    v75.i32[3] = v72[1];
                  v75 = vaddq_f32(v76, v75);
                  v63 = *(int32x2_t *)v124.i8;
                  v74 = vaddq_s64(v74, v124);
                  v73 = vaddq_s64(v73, v124);
                  v72 += 4;
                  v70 -= 4;
                }
                while (v70);
                v79 = vbslq_s8((int8x16_t)vuzp1q_s32(v77, v62), (int8x16_t)v75, (int8x16_t)v76);
                v68 = (float)(vaddv_f32(*(float32x2_t *)v79.i8) + *(float *)&v79.i32[2]) + *(float *)&v79.i32[3];
              }
            }
            v67 = v68 / v10[60].f32[0];
          }
          v80 = (float)(fmaxf(v56, 1.0) * -0.5) + -6.0;
          v81 = log10f(v67 + 1.1755e-38) * 10.0;
          if ((float)(v81 - SharedEnergyReFixedDb) >= v80)
          {
            v92 = v10[18].f32[0];
            if ((float)(v81 - SharedEnergyReFixedDb) > v92)
              v81 = SharedEnergyReFixedDb + v92;
            v86 = v81;
            *v66 = v86;
            v82 = v123;
          }
          else
          {
            *(_QWORD *)v138 = &SoundSourceHash;
            v82 = v123;
            v83 = (float *)std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v123, &SoundSourceHash, (uint64_t)&std::piecewise_construct, (_QWORD **)v138);
            if (!v10[19].i8[4]
              || ((v84 = v83[9], (float)(v84 - SharedEnergyReFixedDb) >= v80)
                ? (v85 = (float)(v84 - SharedEnergyReFixedDb) <= v10[18].f32[0])
                : (v85 = 0),
                  !v85))
            {
              v84 = SharedEnergyReFixedDb + v80;
            }
            v86 = v84;
            v64 = *v46;
            *(double *)(*v46 + 16 * v47 + 8) = v86;
          }
        }
        else
        {
          if (*(_DWORD *)(v7 + 136) <= *v52
            || (v87 = *(_QWORD *)(v7 + 120), *(_DWORD *)(v87 + 24 * *v52 + 20) != HIDWORD(*v52))
            || (v88 = *(float32x2_t **)(v87 + 24 * *v52)) == 0
            || v88->i32[0] != 3)
          {
            *(_QWORD *)v119 = 6;
            *((_QWORD *)v119 + 1) = (char *)v118 + 72;
            *((_DWORD *)v119 + 6) = 2;
            v111 = *(std::__shared_weak_count **)&buf[24];
            if (*(_QWORD *)&buf[24])
            {
              v112 = (unint64_t *)(*(_QWORD *)&buf[24] + 8);
              do
                v113 = __ldaxr(v112);
              while (__stlxr(v113 - 1, v112));
              if (!v113)
              {
                ((void (*)(std::__shared_weak_count *, __n128))v111->__on_zero_shared)(v111, v61);
                std::__shared_weak_count::__release_weak(v111);
              }
            }
            v114 = *(std::__shared_weak_count **)&buf[8];
            if (*(_QWORD *)&buf[8])
            {
              v115 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
              do
                v116 = __ldaxr(v115);
              while (__stlxr(v116 - 1, v115));
              if (!v116)
              {
                ((void (*)(std::__shared_weak_count *, __n128))v114->__on_zero_shared)(v114, v61);
                std::__shared_weak_count::__release_weak(v114);
              }
            }
            return std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v127);
          }
          v129 = 0;
          v145 = 0uLL;
          v125 = -3.4028e38;
          Phase::SpatialModeler::getClosestLRClusterToSourceInClusteringResults(v88, (Phase::SpatialModeler::RayTracerState *)v10, &v129, &v145, &v125);
          v82 = v123;
          v90 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v89) + 1184));
          if (os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)v138 = 136315906;
            *(_QWORD *)&v138[4] = "LateReverbSimulationImpl.mm";
            v139 = 1024;
            v140 = 708;
            v141 = 2048;
            v142 = SoundSourceHash;
            v143 = 2048;
            v144 = v125;
            _os_log_impl(&dword_2164CC000, v90, OS_LOG_TYPE_DEBUG, "%25s:%-5d ClusterLateReverb Warning: no histogram for for source %llu setting send to %f", v138, 0x26u);
          }
          v64 = *v46;
          v91 = *v46 + 16 * v47;
          *(double *)(v91 + 8) = v125;
          v86 = *(double *)(v91 + 8);
        }
        v93 = v86;
        if (*(_QWORD *)(v7 + 904))
          v94 = v93 + (float)(*(float *)(v7 + 928) * (float)(SharedEnergyReFixedDb - v93));
        else
          v94 = v93;
        *(double *)(v64 + 16 * v47 + 8) = v94;
        *(_QWORD *)v138 = &SoundSourceHash;
        *((float *)std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v82, &SoundSourceHash, (uint64_t)&std::piecewise_construct, (_QWORD **)v138)+ 9) = v94;
        v95 = *(std::__shared_weak_count **)&buf[24];
        if (*(_QWORD *)&buf[24])
        {
          v96 = (unint64_t *)(*(_QWORD *)&buf[24] + 8);
          do
            v97 = __ldaxr(v96);
          while (__stlxr(v97 - 1, v96));
          if (!v97)
          {
            ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
            std::__shared_weak_count::__release_weak(v95);
          }
        }
        v98 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v99 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v100 = __ldaxr(v99);
          while (__stlxr(v100 - 1, v99));
          if (!v100)
          {
            ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
            std::__shared_weak_count::__release_weak(v98);
          }
        }
        ++v47;
        v49 += 304;
        if (v47 >= *(_QWORD *)(v9 + 144))
          goto LABEL_101;
      }
    }
    v48 = -3.4028e38;
LABEL_101:
    *(float *)v138 = v48;
    *(float *)&v138[4] = v48;
    *(float *)&v138[8] = v48;
    Phase::Subbands<float>::Subbands((uint64_t)buf, v138, 3);
    v102 = *v120;
    v103 = v135;
    v104 = v136;
    v102[16] = v134;
    v102[17] = v103;
    v105 = v137;
    v102[18] = v104;
    v102[19] = v105;
    v106 = *(_OWORD *)&buf[16];
    v102[12] = *(_OWORD *)buf;
    v102[13] = v106;
    v107 = v133;
    v102[14] = v132;
    v102[15] = v107;
    if (!*(_BYTE *)(v9 + 48))
    {
      (*(void (**)(Phase::SpatialModeler::RoomSimulationImpl *, float32x2_t *))(*(_QWORD *)v118 + 96))(v118, v10);
      std::string::basic_string[abi:ne180100]<0>(buf, "ClusterLateReverb - after StoreRayTracerStateToCache");
      if ((buf[23] & 0x80u) == 0)
        v108 = buf;
      else
        v108 = *(uint8_t **)buf;
      if ((buf[23] & 0x80u) == 0)
        v109 = buf[23];
      else
        v109 = *(_QWORD *)&buf[8];
      Phase::SpatialModeler::RoomSimulationLogging::CheckLRClusterResultAndSourceListenerResultCoherence(v10, (uint64_t)v108, v109);
      if ((char)buf[23] < 0)
        operator delete(*(void **)buf);
    }
    Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryCleanupCommon(v118, v117, a4, v101);
    *((_DWORD *)v119 + 6) = 1;
  }
  return std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v127);
}

void sub_2165FA174(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a44 < 0)
    operator delete(__p);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)&a33);
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationFinish@<X0>(Phase::SpatialModeler::LateReverbSimulationImpl *this@<X0>, Phase::Geometry::SystemState **a2@<X1>, Phase::SpatialModeler::Query *a3@<X2>, Phase::Logger *a4@<X8>)
{
  uint64_t InstancePtr;
  Phase::Logger *v10;
  Phase::Logger *v11;
  NSObject *v12;
  NSObject *v13;
  uint8_t *v14;
  Phase::Geometry::SystemState *v15;
  Phase::SpatialModeler::RayTracerState *v16;
  float *v17;
  Phase::Logger *v18;
  NSObject *v19;
  int v20;
  Phase::SpatialModeler::RoomChangeDetector *v21;
  int v22;
  Phase::SpatialModeler::RayTracerState *v23;
  Phase::Geometry::SystemState *v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  Phase::Geometry::SystemState *v37;
  uint64_t v38;
  int v39;
  _BOOL8 v40;
  Phase::SpatialModeler::RayTracerState *v41;
  float32x2_t *v43;
  unsigned int *v44;
  _BYTE v45[32];
  _BYTE v46[32];
  uint8_t v47[32];
  uint8_t buf[24];
  int v49;
  os_signpost_id_t *v50;
  Phase::Logger *v51;
  uint8_t v52[4];
  const char *v53;
  __int16 v54;
  int v55;
  __int16 v56;
  int v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  InstancePtr = Phase::Logger::GetInstancePtr(this);
  v10 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(InstancePtr + 416));
  v51 = v10;
  v11 = (Phase::Logger *)Phase::Logger::GetInstancePtr(v10);
  if (*((_BYTE *)v11 + 1192))
  {
    v12 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v11)
                                                                                        + 1184)));
    v13 = v12;
    if ((unint64_t)v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v12))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v13, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v10, "Phase_RoomSimulation_LateReverbFinish", "LateReverbFinish", buf, 2u);
    }

  }
  v50 = (os_signpost_id_t *)&v51;
  Phase::SpatialModeler::RoomSimulationImpl::RoomSimulationFinishCommonPreProcess(this, a2, (std::chrono::steady_clock::time_point *)a3, (uint64_t)buf);
  if (v49 == 2)
  {
    std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__copy_constructor((uint64_t)v47, (uint64_t)buf);
    v14 = v47;
    Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationFinish(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(a4, &v50, (uint64_t)v47);
    goto LABEL_32;
  }
  v44 = (unsigned int *)((char *)a3 + 131768);
  v15 = a2[8];
  if (*((_BYTE *)a2[11] + 48))
    v16 = (Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 26720);
  else
    v16 = (Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 1424);
  if (*((_BYTE *)a2[11] + 48))
  {
    Phase::SpatialModeler::RayTracerState::operator=((uint64_t)this + 26720, (uint64_t)a3 + 112752);
LABEL_28:
    if (*((_DWORD *)v15 + 42))
      v40 = *((_BYTE *)v15 + 932) == 0;
    else
      v40 = 0;
    Phase::SpatialModeler::RayTracerState::UpdateLaunchedRayHistory(v16, *v44);
    Phase::SpatialModeler::RoomSimulationImpl::RoomSimulationFinishHandleMatchReverbTimes((Phase::SpatialModeler::RoomSimulationImpl *)v40, (Phase::SpatialModeler::Query *)((char *)a3 + 112752), v16, v41);
    *((_BYTE *)v16 + 25041) = 0;
    Phase::SpatialModeler::LateReverbSimulationImpl::ClusterLateReverb((Phase::SpatialModeler::LateReverbSimulationImpl *)v45, this, (Phase::SpatialModeler::Query *)a2, a3);
    v14 = v45;
    Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationFinish(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(a4, &v50, (uint64_t)v45);
    goto LABEL_32;
  }
  if (*((_BYTE *)this + 26465))
  {
LABEL_23:
    v23 = (Phase::SpatialModeler::RayTracerState *)*((_QWORD *)this + 2);
    Phase::SpatialModeler::RoomSimulationLogging::logRoomStatistics((unsigned int *)this + 356, *((_DWORD *)this + 8), (uint64_t)"RoomSimulationFinish after aggregation", 38);
    Phase::SpatialModeler::RoomSimulationDebugger::ExecuteRoomDataCallbacks((int32x2_t *)this + 178, v23, v15, v24);
    *((_OWORD *)this + 1435) = *((_OWORD *)this + 1408);
    *((_OWORD *)this + 1436) = *((_OWORD *)this + 1409);
    *((_OWORD *)this + 1437) = *((_OWORD *)this + 1410);
    *((_OWORD *)this + 1438) = *((_OWORD *)this + 1411);
    *((_OWORD *)this + 1431) = *((_OWORD *)this + 1404);
    *((_OWORD *)this + 1432) = *((_OWORD *)this + 1405);
    *((_OWORD *)this + 1433) = *((_OWORD *)this + 1406);
    *((_OWORD *)this + 1434) = *((_OWORD *)this + 1407);
    v25 = *((_OWORD *)this + 1341);
    v26 = *((_OWORD *)this + 1342);
    v27 = *((_OWORD *)this + 1343);
    *((_OWORD *)this + 1458) = *((_OWORD *)this + 1344);
    *((_OWORD *)this + 1457) = v27;
    *((_OWORD *)this + 1456) = v26;
    *((_OWORD *)this + 1455) = v25;
    v28 = *((_OWORD *)this + 1345);
    v29 = *((_OWORD *)this + 1346);
    v30 = *((_OWORD *)this + 1347);
    *((_OWORD *)this + 1462) = *((_OWORD *)this + 1348);
    *((_OWORD *)this + 1461) = v30;
    *((_OWORD *)this + 1460) = v29;
    *((_OWORD *)this + 1459) = v28;
    v31 = *((_OWORD *)this + 1309);
    v32 = *((_OWORD *)this + 1310);
    v33 = *((_OWORD *)this + 1311);
    *((_OWORD *)this + 1466) = *((_OWORD *)this + 1312);
    *((_OWORD *)this + 1465) = v33;
    *((_OWORD *)this + 1464) = v32;
    *((_OWORD *)this + 1463) = v31;
    v34 = *((_OWORD *)this + 1313);
    v35 = *((_OWORD *)this + 1314);
    v36 = *((_OWORD *)this + 1315);
    *((_OWORD *)this + 1470) = *((_OWORD *)this + 1316);
    *((_OWORD *)this + 1469) = v36;
    *((_OWORD *)this + 1468) = v35;
    *((_OWORD *)this + 1467) = v34;
    *((_QWORD *)this + 2942) = *((_QWORD *)this + 2616);
    *((_DWORD *)this + 5886) = *((_DWORD *)this + 5234);
    *((_DWORD *)this + 5887) = *((_DWORD *)this + 5110);
    *((_DWORD *)this + 5888) = *((_DWORD *)this + 5188);
    v37 = a2[8];
    v38 = *((unsigned int *)v37 + 42);
    if ((v38 & 0x80000000) == 0)
      ++*((_DWORD *)this + v38 + 5893);
    v39 = *((_DWORD *)v37 + 234);
    if (*((_DWORD *)this + 5897) != v39)
    {
      *((_DWORD *)this + 5897) = v39;
      ++*((_DWORD *)this + 5898);
    }
    Phase::SpatialModeler::Telemetry::Send((Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 22896));
    goto LABEL_28;
  }
  v43 = (float32x2_t *)((char *)this + 80);
  v17 = (float *)((char *)a3 + 112872);
  if (!Phase::SpatialModeler::SimulationController::ShouldEnableListenerOutsideMitigation((Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 80), (Phase::SpatialModeler::Query *)((char *)a3 + 112752), (Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 1424), *((_BYTE *)v15 + 932))|| !*((_BYTE *)a3 + 112945))
  {
    Phase::SpatialModeler::SimulationController::AdjustAggregationCoefficientsDefault(*v17, *((float *)a3 + 28219), (uint64_t)v43, (float *)a3 + 28190);
    if (*((_BYTE *)this + 1592) && *((_BYTE *)this + 1593))
      Phase::SpatialModeler::SimulationController::AdjustAggregationCoefficientsDynamic(v43, (uint64_t)this + 24232, (float *)a3 + 28190, *v17, *((float *)a3 + 28219), *((float *)this + 5613), (float)*v44);
    Phase::SpatialModeler::RoomChangeDetector::IncrementResultsFromTracerStates((Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 672), (Phase::SpatialModeler::Query *)((char *)a3 + 112752));
    Phase::SpatialModeler::GetRoomChangeProbabilityEstimate((Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 672), v21);
    *((_DWORD *)a3 + 33447) = v22;
    Phase::SpatialModeler::RayTracerState::AggregateResultData((Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 1424), (Phase::SpatialModeler::Query *)((char *)a3 + 112752), v15);
    Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView::operator=((uint64_t)this + 24624, (uint64_t)a3 + 135952);
    goto LABEL_23;
  }
  Phase::SpatialModeler::RayTracerState::UpdateResultData((Phase::SpatialModeler::LateReverbSimulationImpl *)((char *)this + 1424), (Phase::SpatialModeler::Query *)((char *)a3 + 112752), v15);
  v19 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v18) + 1184));
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    v20 = *((_DWORD *)this + 5614);
    *(_DWORD *)v52 = 136315650;
    v53 = "LateReverbSimulationImpl.mm";
    v54 = 1024;
    v55 = 306;
    v56 = 1024;
    v57 = v20;
    _os_log_impl(&dword_2164CC000, v19, OS_LOG_TYPE_DEFAULT, "%25s:%-5d listenerOutsideMitigation LR: Listener is outside, mitigating by skipping aggregation, counter %u", v52, 0x18u);
  }
  Phase::SpatialModeler::LateReverbSimulationImpl::ClusterLateReverb((Phase::SpatialModeler::LateReverbSimulationImpl *)v46, this, (Phase::SpatialModeler::Query *)a2, a3);
  v14 = v46;
  Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationFinish(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(a4, &v50, (uint64_t)v46);
LABEL_32:
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v14);
  return std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)buf);
}

void sub_2165FA714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)va);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationFinish(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(Phase::Logger *a1, os_signpost_id_t **a2, uint64_t a3)
{
  Phase::Logger *InstancePtr;
  NSObject *v7;
  NSObject *v8;
  os_signpost_id_t v9;
  uint8_t v11[16];

  InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(a1);
  if (*((_BYTE *)InstancePtr + 1192))
  {
    v7 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(InstancePtr)
                                                                                       + 1184)));
    v8 = v7;
    v9 = **a2;
    if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v7))
    {
      *(_WORD *)v11 = 0;
      _os_signpost_emit_with_name_impl(&dword_2164CC000, v8, OS_SIGNPOST_INTERVAL_END, v9, "Phase_RoomSimulation_LateReverbFinish", (const char *)&unk_21676613F, v11, 2u);
    }

  }
  return std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__move_constructor((uint64_t)a1, a3);
}

void Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationHandleResultsLateReverberation(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &)::$_0::operator()<unsigned long,std::array<float,31ul>,Phase::PackedSubbands<float,10ul>>(Phase::Logger *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  float *v7;
  float *v8;
  __int128 v9;
  __int128 v10;
  NSObject *v11;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  Phase::Logger *v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (a1 == (Phase::Logger *)31)
  {
    v6 = a2 + 124;
    v7 = Phase::sThirdOctaveBandFrequencies;
    v8 = (float *)&constinit_1;
    goto LABEL_6;
  }
  if (a1 == (Phase::Logger *)10)
  {
    v9 = *(_OWORD *)a2;
    v10 = *(_OWORD *)(a2 + 16);
    *(_QWORD *)(a3 + 32) = *(_QWORD *)(a2 + 32);
    *(_OWORD *)a3 = v9;
    *(_OWORD *)(a3 + 16) = v10;
  }
  else
  {
    if (a1 == (Phase::Logger *)3)
    {
      v6 = a2 + 124;
      v7 = (float *)&Phase::sThreeBandFrequencies;
      v8 = Phase::sOctaveBandFrequencies;
LABEL_6:
      Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>(v7, v8, a2, v6, Phase::sOctaveBandFrequencies, Phase::sThirdOctaveBandFrequencies, a3);
      return;
    }
    v11 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(a1) + 1184));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v12 = 136315650;
      v13 = "LateReverbSimulationImpl.mm";
      v14 = 1024;
      v15 = 1347;
      v16 = 2048;
      v17 = a1;
      _os_log_impl(&dword_2164CC000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported sub-band count: %zu\n", (uint8_t *)&v12, 0x1Cu);
    }
  }
}

void Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationHandleResultsLateReverberation(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &)::$_0::operator()<unsigned long,std::vector<float>,Phase::PackedSubbands<float,10ul>>(Phase::Logger *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  float *v6;
  float *v7;
  __int128 v8;
  __int128 v9;
  NSObject *v10;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  Phase::Logger *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (a1 == (Phase::Logger *)31)
  {
    v6 = Phase::sThirdOctaveBandFrequencies;
    v7 = (float *)&constinit_1;
    goto LABEL_6;
  }
  if (a1 == (Phase::Logger *)10)
  {
    v8 = *(_OWORD *)a2;
    v9 = *(_OWORD *)(a2 + 16);
    *(_QWORD *)(a4 + 32) = *(_QWORD *)(a2 + 32);
    *(_OWORD *)a4 = v8;
    *(_OWORD *)(a4 + 16) = v9;
  }
  else
  {
    if (a1 == (Phase::Logger *)3)
    {
      v6 = (float *)&Phase::sThreeBandFrequencies;
      v7 = Phase::sOctaveBandFrequencies;
LABEL_6:
      Phase::GetValuesFromFrequencyResponse<float const*,std::__wrap_iter<float const*>,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>(v6, v7, a2, a4);
      return;
    }
    v10 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(a1) + 1184));
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = 136315650;
      v12 = "LateReverbSimulationImpl.mm";
      v13 = 1024;
      v14 = 1347;
      v15 = 2048;
      v16 = a1;
      _os_log_impl(&dword_2164CC000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported sub-band count: %zu\n", (uint8_t *)&v11, 0x1Cu);
    }
  }
}

float Phase::SpatialModeler::GetTotalEnergyInBand<float>(uint64_t a1, uint64_t a2)
{
  vDSP_Length *v2;
  float result;
  vDSP_Length v4;
  vDSP_Stride v5;
  BOOL v6;
  float __C;

  v2 = *(vDSP_Length **)(a1 + 104);
  result = 0.0;
  if (v2)
  {
    v4 = *v2;
    v5 = v2[1];
    if (*v2)
      v6 = v5 == 0;
    else
      v6 = 1;
    if (!v6)
    {
      __C = 0.0;
      vDSP_svesq((const float *)v2 + a2 + 4, v5, &__C, v4);
      return __C;
    }
  }
  return result;
}

void Phase::SpatialModeler::RoomSimulationDebugger::DebugDirectionalMetadata::~DebugDirectionalMetadata(Phase::SpatialModeler::RoomSimulationDebugger::DebugDirectionalMetadata *this)
{
  void *v2;
  void *v3;
  void *v4;
  void **v5;

  v2 = (void *)*((_QWORD *)this + 10);
  if (v2)
  {
    *((_QWORD *)this + 11) = v2;
    operator delete(v2);
  }
  v5 = (void **)((char *)this + 56);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v3 = (void *)*((_QWORD *)this + 4);
  if (v3)
  {
    *((_QWORD *)this + 5) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 1);
  if (v4)
  {
    *((_QWORD *)this + 2) = v4;
    operator delete(v4);
  }
}

Phase::SpatialModeler::RoomSimulationDebugger::DebugDirectionalMetadata *Phase::SpatialModeler::RoomSimulationDebugger::DebugDirectionalMetadata::DebugDirectionalMetadata(Phase::SpatialModeler::RoomSimulationDebugger::DebugDirectionalMetadata *this, const Phase::SpatialModeler::RoomSimulationDebugger::DebugDirectionalMetadata *a2)
{
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  _BYTE *v7;
  size_t v8;
  char *v9;

  *(_QWORD *)this = *(_QWORD *)a2;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  std::vector<Phase::Vector<float,3ul>>::__init_with_size[abi:ne180100]<Phase::Vector<float,3ul>*,Phase::Vector<float,3ul>*>((char *)this + 8, *((_DWORD **)a2 + 1), *((_DWORD **)a2 + 2), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)a2 + 2) - *((_QWORD *)a2 + 1)) >> 2));
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)this + 4, *((const void **)a2 + 4), *((_QWORD *)a2 + 5), (uint64_t)(*((_QWORD *)a2 + 5) - *((_QWORD *)a2 + 4)) >> 2);
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  v4 = *((_QWORD *)a2 + 7);
  v5 = *((_QWORD *)a2 + 8);
  if (v5 != v4)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100]((_QWORD *)this + 7, 0xAAAAAAAAAAAAAAABLL * ((v5 - v4) >> 3));
    *((_QWORD *)this + 8) = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>((uint64_t)this + 72, v4, v5, *((_QWORD **)this + 8));
  }
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  v7 = (_BYTE *)*((_QWORD *)a2 + 10);
  v6 = (_BYTE *)*((_QWORD *)a2 + 11);
  v8 = v6 - v7;
  if (v6 != v7)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100]((_QWORD *)this + 10, v6 - v7);
    v9 = (char *)*((_QWORD *)this + 11);
    memmove(v9, v7, v8);
    *((_QWORD *)this + 11) = &v9[v8];
  }
  return this;
}

void sub_2165FACD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  _QWORD *v9;
  void **v10;
  void **v11;
  void **v12;
  void *v14;
  void *v15;
  void *v16;

  v14 = *v12;
  if (*v12)
  {
    v9[11] = v14;
    operator delete(v14);
  }
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  v15 = *v11;
  if (*v11)
  {
    v9[5] = v15;
    operator delete(v15);
  }
  v16 = *v10;
  if (*v10)
  {
    v9[2] = v16;
    operator delete(v16);
  }
  _Unwind_Resume(a1);
}

void Phase::GetValuesFromFrequencyResponse<float const*,std::__wrap_iter<float const*>,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>(float *a1, float *a2, uint64_t a3, uint64_t a4)
{
  float *i;
  float v6;
  float v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  float *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float *v17;
  float v18;
  float v19;
  float *v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  uint64_t v26;
  float *v27;
  float *v28;
  float *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  float *v35;
  int v36;
  char *v37;
  char *v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char *v43;
  uint64_t *v44;
  uint64_t v45;
  float *v46;
  float v47;
  float *v48;
  float v49;
  float *v50;
  unint64_t v51;
  float v52;
  float v53;
  float *v54;
  float v55;
  float v56;
  float v57;
  float *v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t v62;
  char *v63;
  float *v64;
  int v65;
  double v66;
  float *v67;
  float v68;
  float v69;
  float *v71;
  float *v72;
  float *v73;
  void *v74;
  char *v75;
  char *v76;
  void *__p;
  float *v78;
  float *v79;
  void *v80[3];
  void *v81[4];

  if (a2 != a1)
  {
    for (i = a1 + 1; i != a2; ++i)
    {
      v7 = *(i - 1);
      v6 = *i;
      if (v6 < v7)
        __assert_rtn("GetValuesFromFrequencyResponse", "FrequencyResponse.hpp", 262, "std::is_sorted(inFrequenciesFirst, inFrequenciesLast)");
    }
  }
  v8 = 0;
  v9 = a2 - a1;
  while (v8 != 9)
  {
    v10 = Phase::sOctaveBandFrequencies[v8 + 1];
    v11 = Phase::sOctaveBandFrequencies[v8++];
    if (v10 < v11)
      __assert_rtn("GetValuesFromFrequencyResponse", "FrequencyResponse.hpp", 263, "std::is_sorted(inOutputFrequenciesFirst, inOutputFrequenciesLast)");
  }
  Phase::GetBandsFromCenterFrequencies<float const*,float>(a1, a2, (float **)v81, 22000.0);
  Phase::GetBandsFromCenterFrequencies<float const*,float>(Phase::sOctaveBandFrequencies, Phase::sThirdOctaveBandFrequencies, (float **)v80, 22000.0);
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  __p = 0;
  v78 = 0;
  v79 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v16 = v9 - 1;
  v71 = 0;
  v73 = 0;
  do
  {
    v17 = (float *)((char *)v80[0] + 8 * v15);
    v18 = *v17;
    v19 = v17[1];
    v78 = (float *)__p;
    v75 = v13;
    v72 = v12;
    if (v14 < v9)
    {
      v20 = (float *)((char *)v81[0] + 8 * v14);
      v21 = *v20;
      v22 = v20[1];
      if (v19 < v22)
        v22 = v19;
      if (v21 >= v18)
        v23 = *v20;
      else
        v23 = v18;
      v24 = fmaxf(v22 - v23, 0.0);
      v25 = v19;
      v26 = v14;
      if (v24 == 0.0)
      {
LABEL_58:
        v14 -= v21 != v25;
      }
      else
      {
        while (1)
        {
          v27 = v78;
          if (v78 >= v79)
          {
            v29 = (float *)__p;
            v30 = ((char *)v78 - (_BYTE *)__p) >> 2;
            v31 = v30 + 1;
            if ((unint64_t)(v30 + 1) >> 62)
              std::vector<float>::__throw_length_error[abi:ne180100]();
            v32 = (char *)v79 - (_BYTE *)__p;
            if (((char *)v79 - (_BYTE *)__p) >> 1 > v31)
              v31 = v32 >> 1;
            if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFFCLL)
              v33 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v33 = v31;
            if (v33)
            {
              v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v79, v33);
              v29 = (float *)__p;
              v27 = v78;
            }
            else
            {
              v34 = 0;
            }
            v35 = (float *)&v34[4 * v30];
            *v35 = v24;
            v28 = v35 + 1;
            while (v27 != v29)
            {
              v36 = *((_DWORD *)v27-- - 1);
              *((_DWORD *)v35-- - 1) = v36;
            }
            __p = v35;
            v78 = v28;
            v79 = (float *)&v34[4 * v33];
            if (v29)
              operator delete(v29);
          }
          else
          {
            *v78 = v24;
            v28 = v27 + 1;
          }
          v78 = v28;
          v37 = v75;
          if (v75 >= v76)
          {
            v38 = (char *)v74;
            v39 = (v75 - (_BYTE *)v74) >> 3;
            v40 = v39 + 1;
            if ((unint64_t)(v39 + 1) >> 61)
              std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
            v41 = v76 - (_BYTE *)v74;
            if ((v76 - (_BYTE *)v74) >> 2 > v40)
              v40 = v41 >> 2;
            if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8)
              v42 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v42 = v40;
            if (v42)
            {
              v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&v76, v42);
              v38 = (char *)v74;
              v37 = v75;
            }
            else
            {
              v43 = 0;
            }
            v44 = (uint64_t *)&v43[8 * v39];
            *v44 = v14;
            v13 = (char *)(v44 + 1);
            while (v37 != v38)
            {
              v45 = *((_QWORD *)v37 - 1);
              v37 -= 8;
              *--v44 = v45;
            }
            v74 = v44;
            v75 = v13;
            v76 = &v43[8 * v42];
            if (v38)
              operator delete(v38);
          }
          else
          {
            *(_QWORD *)v75 = v14;
            v13 = v37 + 8;
          }
          v75 = v13;
          if (v14 == v16)
            v26 = v14;
          if (++v14 == v9)
            break;
          v46 = (float *)((char *)v81[0] + 8 * v14);
          v21 = *v46;
          v47 = v46[1];
          v48 = (float *)((char *)v80[0] + 8 * v15);
          v49 = *v48;
          v25 = v48[1];
          if (v25 < v47)
            v47 = v48[1];
          if (v21 >= v49)
            v49 = v21;
          v24 = fmaxf(v47 - v49, 0.0);
          if (v24 == 0.0)
            goto LABEL_58;
        }
        v14 = v26;
      }
    }
    v50 = v72;
    if (v13 == v74)
    {
      v53 = 0.0;
    }
    else
    {
      v51 = 0;
      v52 = v19 - v18;
      v53 = 0.0;
      v54 = v72;
      v13 = (char *)v74;
      do
      {
        v55 = *((float *)__p + v51) / v52;
        v56 = *(float *)(a3 + 4 * *(_QWORD *)&v13[8 * v51]);
        v57 = v55 * (float)(v56 * v56);
        if (v54 >= v73)
        {
          v58 = v71;
          v59 = v54 - v71;
          v60 = v59 + 1;
          if ((unint64_t)(v59 + 1) >> 62)
            std::vector<float>::__throw_length_error[abi:ne180100]();
          v61 = (char *)v73 - (char *)v71;
          if (((char *)v73 - (char *)v71) >> 1 > v60)
            v60 = v61 >> 1;
          if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFFCLL)
            v62 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v62 = v60;
          if (v62)
          {
            v63 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v73, v62);
            v58 = v71;
            v54 = v72;
          }
          else
          {
            v63 = 0;
          }
          v64 = (float *)&v63[4 * v59];
          *v64 = v57;
          v50 = v64 + 1;
          while (v54 != v58)
          {
            v65 = *((_DWORD *)v54-- - 1);
            *((_DWORD *)v64-- - 1) = v65;
          }
          v71 = v64;
          v73 = (float *)&v63[4 * v62];
          if (v58)
            operator delete(v58);
        }
        else
        {
          *v54 = v57;
          v50 = v54 + 1;
        }
        v72 = v50;
        v53 = v53 + v55;
        ++v51;
        v13 = (char *)v74;
        v54 = v50;
      }
      while (v51 < (v75 - (_BYTE *)v74) >> 3);
    }
    v12 = v71;
    v66 = 0.0;
    if (v71 != v50)
    {
      v67 = v71;
      do
      {
        v68 = *v67++;
        v66 = v66 + v68;
      }
      while (v67 != v50);
    }
    v69 = v66;
    v16 = v9 - 1;
    *(float *)(a4 + 4 * v15++) = sqrtf(v69 / v53);
  }
  while (v15 != 10);
  if (v71)
  {
    operator delete(v71);
    v13 = (char *)v74;
  }
  if (v13)
  {
    v75 = v13;
    operator delete(v13);
  }
  if (__p)
  {
    v78 = (float *)__p;
    operator delete(__p);
  }
  if (v80[0])
  {
    v80[1] = v80[0];
    operator delete(v80[0]);
  }
  if (v81[0])
  {
    v81[1] = v81[0];
    operator delete(v81[0]);
  }
}

void sub_2165FB260(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

char *std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, _QWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  char *v11;
  unint64_t v12;
  _QWORD *v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v7 >= v8)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = (char *)*v10;
      if (*v10)
      {
        do
        {
          v12 = *((_QWORD *)v11 + 1);
          if (v12 == v7)
          {
            if (*((_QWORD *)v11 + 2) == v7)
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = *(char **)v11;
        }
        while (v11);
      }
    }
  }
  v13 = (_QWORD *)(a1 + 16);
  v11 = (char *)operator new(0x68uLL);
  *(_QWORD *)v11 = 0;
  *((_QWORD *)v11 + 1) = v7;
  *((_QWORD *)v11 + 2) = **a4;
  *(_OWORD *)(v11 + 56) = 0u;
  *(_OWORD *)(v11 + 72) = 0u;
  *(_OWORD *)(v11 + 88) = 0u;
  *(_OWORD *)(v11 + 40) = 0u;
  *(_OWORD *)(v11 + 24) = 0u;
  *((_DWORD *)v11 + 14) = 1065353216;
  *((_QWORD *)v11 + 8) = 0;
  *((_QWORD *)v11 + 9) = 0;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    v16 = 1;
    if (v8 >= 3)
      v16 = (v8 & (v8 - 1)) != 0;
    v17 = v16 | (2 * v8);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::__rehash<true>(a1, v19);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v21)
  {
    *(_QWORD *)v11 = *v21;
LABEL_38:
    *v21 = v11;
    goto LABEL_39;
  }
  *(_QWORD *)v11 = *v13;
  *v13 = v11;
  *(_QWORD *)(v20 + 8 * v4) = v13;
  if (*(_QWORD *)v11)
  {
    v22 = *(_QWORD *)(*(_QWORD *)v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8)
        v22 %= v8;
    }
    else
    {
      v22 &= v8 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_2165FB520(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  void *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,void *>>>::operator()[abi:ne180100](uint64_t a1, void *__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)__p + 64);
    std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)__p + 24);
  }
  if (__p)
    operator delete(__p);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRSpatialResult>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  unint64_t v3;
  unint64_t v5;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  int8x8_t prime;
  void *v21;
  void *v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;
  uint8x8_t v26;
  unint64_t v27;
  uint8x8_t v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  _QWORD *v32;
  unint64_t v33;
  void *v35;
  _QWORD v36[2];
  char v37;

  v5 = a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = (_QWORD *)(a1 + 16);
  v13 = operator new(0x28uLL);
  v36[0] = v13;
  v36[1] = a1 + 16;
  *v13 = 0;
  v13[1] = v5;
  v14 = *a3;
  v13[3] = 0;
  v13[4] = 0;
  v13[2] = v14;
  v37 = 1;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (v7 && (float)(v16 * (float)v7) >= v15)
  {
    v5 = v3;
    goto LABEL_64;
  }
  v17 = 1;
  if (v7 >= 3)
    v17 = (v7 & (v7 - 1)) != 0;
  v18 = v17 | (2 * v7);
  v19 = vcvtps_u32_f32(v15 / v16);
  if (v18 <= v19)
    prime = (int8x8_t)v19;
  else
    prime = (int8x8_t)v18;
  if (*(_QWORD *)&prime == 1)
  {
    prime = (int8x8_t)2;
  }
  else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
  {
    prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    v7 = *(_QWORD *)(a1 + 8);
  }
  if (*(_QWORD *)&prime <= v7)
  {
    if (*(_QWORD *)&prime >= v7)
      goto LABEL_60;
    v27 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v7 < 3 || (v28 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
    {
      v27 = std::__next_prime(v27);
    }
    else
    {
      v29 = 1 << -(char)__clz(v27 - 1);
      if (v27 >= 2)
        v27 = v29;
    }
    if (*(_QWORD *)&prime <= v27)
      prime = (int8x8_t)v27;
    if (*(_QWORD *)&prime >= v7)
    {
      v7 = *(_QWORD *)(a1 + 8);
      goto LABEL_60;
    }
    if (!*(_QWORD *)&prime)
    {
      v35 = *(void **)a1;
      *(_QWORD *)a1 = 0;
      if (v35)
        operator delete(v35);
      v7 = 0;
      *(_QWORD *)(a1 + 8) = 0;
      goto LABEL_60;
    }
  }
  if (*(_QWORD *)&prime >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v21 = operator new(8 * *(_QWORD *)&prime);
  v22 = *(void **)a1;
  *(_QWORD *)a1 = v21;
  if (v22)
    operator delete(v22);
  v23 = 0;
  *(int8x8_t *)(a1 + 8) = prime;
  do
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v23++) = 0;
  while (*(_QWORD *)&prime != v23);
  v24 = (_QWORD *)*v12;
  if (*v12)
  {
    v25 = v24[1];
    v26 = (uint8x8_t)vcnt_s8(prime);
    v26.i16[0] = vaddlv_u8(v26);
    if (v26.u32[0] > 1uLL)
    {
      if (v25 >= *(_QWORD *)&prime)
        v25 %= *(_QWORD *)&prime;
    }
    else
    {
      v25 &= *(_QWORD *)&prime - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v25) = v12;
    v30 = (_QWORD *)*v24;
    if (*v24)
    {
      do
      {
        v31 = v30[1];
        if (v26.u32[0] > 1uLL)
        {
          if (v31 >= *(_QWORD *)&prime)
            v31 %= *(_QWORD *)&prime;
        }
        else
        {
          v31 &= *(_QWORD *)&prime - 1;
        }
        if (v31 != v25)
        {
          if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v31))
          {
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v31) = v24;
            goto LABEL_56;
          }
          *v24 = *v30;
          *v30 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v31);
          **(_QWORD **)(*(_QWORD *)a1 + 8 * v31) = v30;
          v30 = v24;
        }
        v31 = v25;
LABEL_56:
        v24 = v30;
        v30 = (_QWORD *)*v30;
        v25 = v31;
      }
      while (v30);
    }
  }
  v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5)
      v5 %= v7;
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_64:
  v32 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v5);
  i = (_QWORD *)v36[0];
  if (v32)
  {
    *(_QWORD *)v36[0] = *v32;
LABEL_72:
    *v32 = i;
    goto LABEL_73;
  }
  *(_QWORD *)v36[0] = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(*(_QWORD *)a1 + 8 * v5) = v12;
  if (*i)
  {
    v33 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v33 >= v7)
        v33 %= v7;
    }
    else
    {
      v33 &= v7 - 1;
    }
    v32 = (_QWORD *)(*(_QWORD *)a1 + 8 * v33);
    goto LABEL_72;
  }
LABEL_73:
  v36[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::shared_ptr<Phase::Job>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::shared_ptr<Phase::Job>>,void *>>>>::reset[abi:ne180100]((uint64_t)v36);
  return i;
}

void sub_2165FB988(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::shared_ptr<Phase::Job>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::shared_ptr<Phase::Job>>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57E5C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24D57E5C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2199F9D70);
}

uint64_t *std::__shared_ptr_emplace<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::__on_zero_shared(uint64_t a1)
{
  char v2;

  return std::allocator<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::destroy[abi:ne180100]((uint64_t)&v2, (uint64_t *)(a1 + 24));
}

void Phase::LambdaFunction<Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationHandleResultsLateReverberation(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &)::$_3,void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

uint64_t Phase::LambdaFunction<Phase::SpatialModeler::LateReverbSimulationImpl::RoomSimulationHandleResultsLateReverberation(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &)::$_3,void>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), a1 + 16);
}

void Phase::SpatialModeler::LateReverbSimulation::GetSupportedQueryDescs(std::string **a1@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::string *v9;
  uint64_t v10;
  char *v11;
  void *v12;
  __int128 v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  _BYTE v18[32];
  char v19[24];
  uint64_t v20;
  uint64_t v21;
  int v22;
  _BYTE v23[32];
  char v24[24];
  uint64_t v25;
  uint64_t v26;
  int v27;
  _BYTE v28[32];
  __int128 v29;

  *(_QWORD *)&v29 = *MEMORY[0x24BDAC8D0];
  v14 = 4;
  strcpy((char *)&v13, "CULL");
  v15 = 0;
  v16 = 0x100000001;
  v17 = 1;
  memset(v18, 0, sizeof(v18));
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)v18, 7uLL);
  v3 = 0;
  v4 = *(_QWORD *)v18;
  do
  {
    *(_DWORD *)(v4 + v3 * 4) = Phase::SpatialModeler::LateReverbSimulationPrivate::sCullQueryPropertyUIDs[v3];
    ++v3;
  }
  while (v3 != 7);
  v19[23] = 7;
  strcpy(v19, "CLUSTER");
  v20 = 1;
  v21 = 0x200000003;
  v22 = 1;
  memset(v23, 0, sizeof(v23));
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)v23, 7uLL);
  v5 = 0;
  v6 = *(_QWORD *)v23;
  do
  {
    *(_DWORD *)(v6 + v5 * 4) = Phase::SpatialModeler::LateReverbSimulationPrivate::sClusterQueryPropertyUIDs[v5];
    ++v5;
  }
  while (v5 != 7);
  v24[23] = 7;
  strcpy(v24, "SPATIAL");
  v25 = 2;
  v26 = 0x300000002;
  v27 = 2;
  memset(v28, 0, sizeof(v28));
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)v28, 7uLL);
  v7 = 0;
  v8 = *(_QWORD *)v28;
  do
  {
    *(_DWORD *)(v8 + v7 * 4) = Phase::SpatialModeler::LateReverbSimulationPrivate::sSpatialQueryPropertyUIDs[v7];
    ++v7;
  }
  while (v7 != 7);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v9 = (std::string *)operator new(0xF0uLL);
  *a1 = v9;
  a1[1] = v9;
  a1[2] = v9 + 10;
  v10 = 0;
  a1[1] = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Phase::SpatialModeler::QueryDesc>,Phase::SpatialModeler::QueryDesc const*,Phase::SpatialModeler::QueryDesc const*,Phase::SpatialModeler::QueryDesc*>((uint64_t)(a1 + 2), &v13, &v29, v9);
  do
  {
    v11 = (char *)&v13 + v10;
    v12 = *(void **)&v28[v10];
    if (v12)
    {
      *((_QWORD *)v11 + 27) = v12;
      operator delete(v12);
    }
    if (v11[183] < 0)
      operator delete(*((void **)v11 + 20));
    v10 -= 80;
  }
  while (v10 != -240);
}

void sub_2165FBC70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t i;

  *(_QWORD *)(v12 + 8) = v13;
  std::vector<Phase::SpatialModeler::QueryDesc>::__destroy_vector::operator()[abi:ne180100](&a10);
  for (i = 160; i != -80; i -= 80)
    Phase::SpatialModeler::QueryDesc::~QueryDesc((Phase::SpatialModeler::QueryDesc *)(&a12 + i));
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::LateReverbSimulation::GetEntityShapeTemplates@<X0>(Phase::SpatialModeler::LateReverbSimulation *this@<X0>, uint64_t *a2@<X8>)
{
  int v3;
  int *v4;
  uint64_t v5;
  int v7;
  _OWORD v8[2];
  int v9;
  int v10;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v7 = 0;
  memset(v8, 0, sizeof(v8));
  v9 = 1065353216;
  v10 = 4;
  v3 = *(_DWORD *)(Phase::Logger::GetInstancePtr(this) + 1200);
  if (!v3)
    v3 = 3;
  v7 = v3;
  if ((v3 - 4) < 0xFFFFFFFD)
    __assert_rtn("GetEntityShapeTemplates", "LateReverbSimulationModeler.cpp", 238, "occluderTemplate.mShapeType > Geometry::DefaultShapeType::Invalid && occluderTemplate.mShapeType < Geometry::DefaultShapeType::Count");
  v4 = (int *)a2[1];
  if ((unint64_t)v4 >= a2[2])
  {
    v5 = std::vector<Phase::SpatialModeler::EntityShapeTemplate>::__push_back_slow_path<Phase::SpatialModeler::EntityShapeTemplate const&>(a2, &v7);
  }
  else
  {
    *v4 = v3;
    std::unordered_map<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,std::allocator<std::pair<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey const,Phase::OptionsValue>>>::unordered_map((uint64_t)(v4 + 2), (uint64_t)v8);
    v4[12] = v10;
    v5 = (uint64_t)(v4 + 14);
    a2[1] = (uint64_t)(v4 + 14);
  }
  a2[1] = v5;
  return std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table((uint64_t)v8);
}

void sub_2165FBDD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v13 = v12;
  *(_QWORD *)(v10 + 8) = v13;
  std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table(v11);
  a10 = (void **)v10;
  std::vector<Phase::SpatialModeler::EntityShapeTemplate>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::LateReverbSimulation::Init(uint64_t a1, _QWORD *a2)
{
  __int128 *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  _DWORD *v12;
  Phase::SpatialModeler::RoomSimulation *v13;
  uint64_t v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  float64x2_t *v21;
  Phase::Logger *v22;
  NSObject *v23;
  _BOOL8 v24;
  int *InstancePtr;
  uint64_t v26;
  const char *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  Phase::SpatialModeler::DefaultRayDistribution *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *p_shared_owners;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  uint64_t v39;
  std::__shared_weak_count *v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  _BYTE buf[18];
  __int16 v44;
  const char *v45;
  __int16 v46;
  int v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(a1 + 40) = a2[3];
  *(_DWORD *)(a1 + 32) = 3;
  *(_DWORD *)(a1 + 60) = Phase::Geometry::SceneQueryTypeRegistry::DeriveNewType((Phase::Geometry::SceneQueryTypeRegistry *)(*(_QWORD *)(a1 + 16) + 2288), 3u);
  *(_DWORD *)(a1 + 64) = Phase::Geometry::SceneQueryTypeRegistry::DeriveNewType((Phase::Geometry::SceneQueryTypeRegistry *)(*(_QWORD *)(a1 + 16) + 2288), 3u);
  Phase::Geometry::System::GetCurrentState(*(Phase::Geometry::System **)(a1 + 16), &v41);
  v4 = (__int128 *)a2[1];
  if (v4)
  {
    v5 = *v4;
    *(_OWORD *)(a1 + 1072) = v4[1];
    *(_OWORD *)(a1 + 1056) = v5;
    v6 = v4[2];
    v7 = v4[3];
    v8 = v4[4];
    *(_OWORD *)(a1 + 1136) = v4[5];
    *(_OWORD *)(a1 + 1120) = v8;
    *(_OWORD *)(a1 + 1104) = v7;
    *(_OWORD *)(a1 + 1088) = v6;
    v9 = v4[6];
    v10 = v4[7];
    v11 = v4[8];
    *(_DWORD *)(a1 + 1200) = *((_DWORD *)v4 + 36);
    *(_OWORD *)(a1 + 1184) = v11;
    *(_OWORD *)(a1 + 1168) = v10;
    *(_OWORD *)(a1 + 1152) = v9;
  }
  Phase::SpatialModeler::RoomSimulationConfig::ReadDefaultsWriteFlags((Phase::SpatialModeler::RoomSimulationConfig *)(a1 + 1056));
  *(_QWORD *)(a1 + 1280) = *a2;
  *(_QWORD *)(a1 + 1304) = a2[2];
  v12 = (_DWORD *)operator new();
  bzero(v12, 0x125E0uLL);
  *v12 = -1;
  v14 = 3;
  v15 = v12;
  do
  {
    v15[16] = 0;
    v15 += 25072;
    *v15 = 0;
    --v14;
  }
  while (v14);
  *(_QWORD *)buf = 0;
  v16 = *(_QWORD *)(a1 + 1312);
  *(_QWORD *)(a1 + 1312) = v12;
  if (v16)
  {
    std::default_delete<caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>>::operator()[abi:ne180100](a1 + 1312, v16);
    v17 = *(_QWORD *)buf;
    *(_QWORD *)buf = 0;
    if (v17)
      std::default_delete<caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>>::operator()[abi:ne180100]((uint64_t)buf, v17);
  }
  Phase::SpatialModeler::RoomSimulation::InitERtoLRModelerCache(v13);
  Phase::Geometry::DirectivityFactory::Create(*(_QWORD *)(a1 + 16) + 208, 3u, buf);
  std::shared_ptr<Phase::Controller::BinauralEncoder::FilterSwapInfo>::operator=[abi:ne180100](a1 + 51936, (__int128 *)buf);
  v18 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v19 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  Phase::Geometry::DirectivityFactory::Create(*(_QWORD *)(a1 + 16) + 208, 3u, &v39);
  v21 = **(float64x2_t ***)(*(_QWORD *)(a1 + 51936) + 40);
  v21[1] = vcvtq_f64_f32(*(float32x2_t *)(a1 + 1192));
  Phase::Geometry::SphericalCapDirectivity::InitializeSubbandGainsDatabase((Phase::Geometry::SphericalCapDirectivity *)v21);
  v23 = **(NSObject ***)(Phase::Logger::GetInstancePtr(v22) + 1184);
  v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
  if (v24)
  {
    InstancePtr = (int *)Phase::Logger::GetInstancePtr((Phase::Logger *)v24);
    v26 = InstancePtr[307];
    if (v26 > 3)
      v27 = "Invalid";
    else
      v27 = off_24D57E788[v26];
    v28 = *(_DWORD *)(Phase::Logger::GetInstancePtr((Phase::Logger *)InstancePtr) + 1228);
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "LateReverbSimulationModeler.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 321;
    v44 = 2080;
    v45 = v27;
    v46 = 1024;
    v47 = v28;
    _os_log_impl(&dword_2164CC000, v23, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Selected Space Blend Algorithm: %s (index %d)", buf, 0x22u);
  }
  if (*(_BYTE *)(a1 + 1202))
  {
    v29 = operator new();
    *(_QWORD *)v29 = &off_24D580DD0;
    *(_OWORD *)(v29 + 8) = xmmword_2166F8040;
  }
  else
  {
    v29 = operator new();
    *(_QWORD *)v29 = &off_24D580DF8;
  }
  v30 = *(_QWORD *)(a1 + 51952);
  *(_QWORD *)(a1 + 51952) = v29;
  if (v30)
    (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
  v31 = (Phase::SpatialModeler::DefaultRayDistribution *)operator new();
  Phase::SpatialModeler::DefaultRayDistribution::DefaultRayDistribution(v31);
  v32 = *(_QWORD *)(a1 + 51960);
  *(_QWORD *)(a1 + 51960) = v31;
  if (v32)
    (*(void (**)(uint64_t))(*(_QWORD *)v32 + 8))(v32);
  v33 = v40;
  if (v40)
  {
    p_shared_owners = (unint64_t *)&v40->__shared_owners_;
    do
      v35 = __ldaxr(p_shared_owners);
    while (__stlxr(v35 - 1, p_shared_owners));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  v36 = v42;
  if (v42)
  {
    v37 = (unint64_t *)&v42->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
}

void sub_2165FC1F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::LateReverbSimulation::Shutdown(Phase::SpatialModeler::LateReverbSimulation *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 164);
  *((_QWORD *)this + 164) = 0;
  if (v1)
    std::default_delete<caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>>::operator()[abi:ne180100]((uint64_t)this + 1312, v1);
  return Phase::SpatialModeler::RoomSimulation::DeinitERtoLRModelerCache(this);
}

uint64_t Phase::SpatialModeler::LateReverbSimulation::RunQuery@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3;
  _DWORD *v4;
  char *v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v3 = a2[10];
  if (v3 > 2)
  {
    *(_QWORD *)a3 = 2;
    *(_QWORD *)(a3 + 8) = result + 72;
    *(_DWORD *)(a3 + 24) = 2;
  }
  else
  {
    v4 = (_DWORD *)a2[11];
    if (v4 && (v5 = Phase::SpatialModeler::LateReverbSimulationPrivate::QueryTable[v3], *((_DWORD *)v5 + 4) == *v4))
    {
      v6 = (_DWORD *)a2[12];
      if (v6 && *((_DWORD *)v5 + 5) == *v6)
        return (*((uint64_t (**)(void))v5 + 8))();
      v7 = result + 72;
      v8 = 4;
    }
    else
    {
      v7 = result + 72;
      v8 = 3;
    }
    *(_QWORD *)a3 = v8;
    *(_QWORD *)(a3 + 8) = v7;
    *(_DWORD *)(a3 + 24) = 2;
  }
  return result;
}

uint64_t Phase::SpatialModeler::LateReverbSimulation::AllocateQueryState@<X0>(uint64_t this@<X0>, Phase::SpatialModeler::Query *a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t v3;
  uint64_t (*v4)(uint64_t);

  v3 = *((_QWORD *)a2 + 10);
  if (v3 <= 2)
  {
    v4 = (uint64_t (*)(uint64_t))*((_QWORD *)Phase::SpatialModeler::LateReverbSimulationPrivate::QueryTable[v3]
                                          + 7);
    if (v4)
      return v4(this);
  }
  *a3 = 0;
  a3[4] = 0;
  return this;
}

uint64_t Phase::SpatialModeler::LateReverbSimulation::GetGraphDescription@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t result;

  switch(a1)
  {
    case 2:
      *(_OWORD *)(a2 + 16) = 0uLL;
      *(_OWORD *)(a2 + 32) = 0uLL;
      *(_OWORD *)a2 = 0uLL;
      MEMORY[0x2199F99B0](a2, "LateReverbSimSpatialQueryGraph");
      std::vector<Phase::SpatialModeler::GraphDescriptionNode>::resize((uint64_t *)(a2 + 24), 1uLL);
      v4 = *(_QWORD *)(a2 + 24);
      result = MEMORY[0x2199F99B0](v4, "FullLateReverbSimSpatialGraph");
      goto LABEL_7;
    case 1:
      *(_OWORD *)(a2 + 16) = 0uLL;
      *(_OWORD *)(a2 + 32) = 0uLL;
      *(_OWORD *)a2 = 0uLL;
      MEMORY[0x2199F99B0](a2, "LateReverbSimClusterQueryGraph");
      std::vector<Phase::SpatialModeler::GraphDescriptionNode>::resize((uint64_t *)(a2 + 24), 1uLL);
      v4 = *(_QWORD *)(a2 + 24);
      result = MEMORY[0x2199F99B0](v4, "FullLateReverbSimClusterGraph");
      goto LABEL_7;
    case 0:
      *(_OWORD *)(a2 + 16) = 0uLL;
      *(_OWORD *)(a2 + 32) = 0uLL;
      *(_OWORD *)a2 = 0uLL;
      MEMORY[0x2199F99B0](a2, "LateReverbSimCullQueryGraph");
      std::vector<Phase::SpatialModeler::GraphDescriptionNode>::resize((uint64_t *)(a2 + 24), 1uLL);
      v4 = *(_QWORD *)(a2 + 24);
      result = MEMORY[0x2199F99B0](v4, "FullLateReverbSimCullGraph");
LABEL_7:
      *(_QWORD *)(v4 + 24) = 0xFFFFFFFFLL;
      return result;
  }
  *(_OWORD *)(a2 + 16) = 0uLL;
  *(_OWORD *)(a2 + 32) = 0uLL;
  *(_OWORD *)a2 = 0uLL;
  return result;
}

void sub_2165FC43C(_Unwind_Exception *a1)
{
  void **v1;

  Phase::SpatialModeler::GraphDescription::~GraphDescription(v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::LateReverbSimulation::GetErrorCategory(Phase::SpatialModeler::LateReverbSimulation *this)
{
  return (uint64_t)this + 72;
}

BOOL Phase::SpatialModeler::LateReverbSimulation::IsQueryIndexValid(Phase::SpatialModeler::LateReverbSimulation *this, unint64_t a2)
{
  return a2 < 3;
}

void Phase::SpatialModeler::LateReverbSimulation::StoreRayTracerStateToCache(Phase::SpatialModeler::LateReverbSimulation *this, const Phase::SpatialModeler::RayTracerState *a2)
{
  uint64_t v2;
  unsigned int *v3;
  const Phase::SpatialModeler::RayTracerState *v4;
  void *v5[3134];

  v2 = MEMORY[0x24BDAC7A8](this);
  v5[3133] = *(void **)MEMORY[0x24BDAC8D0];
  v3 = *(unsigned int **)(v2 + 1312);
  Phase::SpatialModeler::RayTracerState::RayTracerState((Phase::SpatialModeler::RayTracerState *)v5, v4);
  caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>::write(v3, (const Phase::SpatialModeler::RayTracerState *)v5);
  Phase::SpatialModeler::RayTracerState::~RayTracerState(v5);
}

void sub_2165FC4FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  Phase::SpatialModeler::RayTracerState::~RayTracerState(&a9);
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::LateReverbSimulation::LoadRayTracerStateFromCache(unsigned int **this)
{
  return caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>::read_if (this[164]);
}

void Phase::SpatialModeler::LateReverbSimulation::~LateReverbSimulation(Phase::SpatialModeler::LateReverbSimulation *this)
{
  Phase::SpatialModeler::RoomSimulation::~RoomSimulation(this);
  JUMPOUT(0x2199F9D70);
}

Phase::SpatialModeler::LaunchConfig *Phase::SpatialModeler::LaunchConfig::LaunchConfig(Phase::SpatialModeler::LaunchConfig *this, unsigned int a2, unsigned int a3)
{
  *(_QWORD *)this = 0;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  Phase::SpatialModeler::LaunchConfig::Init(this, a2, a3);
  return this;
}

void sub_2165FC580(_Unwind_Exception *a1)
{
  uint64_t *v1;

  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

float Phase::SpatialModeler::LaunchConfig::Init(Phase::SpatialModeler::LaunchConfig *this, unsigned int a2, unsigned int a3)
{
  float result;

  result = Phase::SpatialModeler::LaunchConfig::SetLaunchingAngles((uint64_t)this, (uint64_t)&Phase::SpatialModeler::launchconfig_128x256, a2, a3);
  if (a2 != 256 || *(_DWORD *)this != 128)
    std::terminate();
  return result;
}

float Phase::SpatialModeler::LaunchConfig::SetLaunchingAngles(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v6;
  uint64_t v7;
  float result;
  uint64_t v9;
  unint64_t v10;
  float *v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD v19[5];

  v19[4] = *MEMORY[0x24BDAC8D0];
  *(_DWORD *)(a1 + 4) = a3;
  *(_DWORD *)(a1 + 8) = a4;
  *(_DWORD *)a1 = a4 / a3;
  v6 = a4;
  v13 = 4;
  v14 = a4;
  v15 = &v14;
  v16 = &v13;
  Phase::details::AllocArray<Phase::Vector<float,3ul>,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(Phase::Vector<float,3ul>*)#1} const&>(a4, (uint64_t)&v15, &v18);
  v7 = v18;
  v18 = 0;
  v15 = (uint64_t *)v7;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v16, (uint64_t)v19);
  v17 = v6;
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100](&v18);
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(a1 + 16), (uint64_t *)&v15);
  *(_QWORD *)(a1 + 56) = v17;
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::~unique_ptr[abi:ne180100]((uint64_t *)&v15);
  if (*(_QWORD *)(a1 + 56))
  {
    v9 = 0;
    v10 = 0;
    v11 = (float *)(a2 + 4);
    do
    {
      *(_DWORD *)(*(_QWORD *)(a1 + 16) + v9) = 1065353216;
      *(float *)(*(_QWORD *)(a1 + 16) + v9 + 4) = *(v11 - 1);
      v12 = *v11;
      v11 += 2;
      result = v12;
      *(float *)(*(_QWORD *)(a1 + 16) + v9 + 8) = v12;
      ++v10;
      v9 += 12;
    }
    while (*(_QWORD *)(a1 + 56) > v10);
  }
  return result;
}

_QWORD *std::ifstream::basic_ifstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  std::ios_base *v7;

  v2 = MEMORY[0x24BEDB838];
  v3 = MEMORY[0x24BEDB838] + 64;
  a1[53] = MEMORY[0x24BEDB838] + 64;
  v4 = a1 + 2;
  v5 = *(_QWORD *)(MEMORY[0x24BEDB7E0] + 8);
  v6 = *(_QWORD *)(MEMORY[0x24BEDB7E0] + 16);
  *a1 = v5;
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v5 - 24)) = v6;
  a1[1] = 0;
  v7 = (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24));
  std::ios_base::init(v7, a1 + 2);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  *a1 = v2 + 24;
  a1[53] = v3;
  MEMORY[0x2199F9A1C](v4);
  if (!std::filebuf::open())
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 4);
  return a1;
}

void sub_2165FC7FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::istream::~istream();
  MEMORY[0x2199F9CD4](v1 + 424);
  _Unwind_Resume(a1);
}

_QWORD *std::ifstream::~ifstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x24BEDB7E0];
  v3 = *MEMORY[0x24BEDB7E0];
  *a1 = *MEMORY[0x24BEDB7E0];
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  MEMORY[0x2199F9A28](a1 + 2);
  std::istream::~istream();
  MEMORY[0x2199F9CD4](a1 + 53);
  return a1;
}

uint64_t *Phase::DspLayer::LinearFade::GetNewRegistryEntry(Phase::DspLayer::LinearFade *this)
{
  char *v1;
  uint64_t *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v6[2];
  char v7;
  void *__p[2];
  char v9;
  _QWORD v10[3];
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v1 = (char *)malloc_type_malloc(0xA8uLL, 0x1050040B063AAFAuLL);
  *(_QWORD *)v1 = "Duration";
  *((_QWORD *)v1 + 1) = 0x500000000;
  *(_QWORD *)(v1 + 20) = 0x100000000;
  *((_DWORD *)v1 + 7) = 3;
  *((_OWORD *)v1 + 2) = xmmword_2166F7470;
  *((_QWORD *)v1 + 6) = 0;
  *((_QWORD *)v1 + 7) = "Start";
  *((_QWORD *)v1 + 8) = 0x500000001;
  *(_QWORD *)(v1 + 76) = 0x100000000;
  *((_DWORD *)v1 + 21) = 3;
  *(_OWORD *)(v1 + 88) = xmmword_2166F7470;
  *((_QWORD *)v1 + 13) = 0;
  *((_QWORD *)v1 + 14) = "End";
  *((_QWORD *)v1 + 15) = 0x500000002;
  *(_QWORD *)(v1 + 132) = 0x100000000;
  *((_DWORD *)v1 + 35) = 3;
  *((_OWORD *)v1 + 9) = xmmword_2166F7470;
  *((_QWORD *)v1 + 20) = 0x3FF0000000000000;
  v2 = (uint64_t *)operator new();
  v10[0] = &off_24D57E8B0;
  v11 = v10;
  Phase::Controller::VoicePoolEntry::VoicePoolEntry((uint64_t)v2, "LinearFade", 3, (uint64_t)v1, (uint64_t)v10);
  v3 = v11;
  if (v11 == v10)
  {
    v4 = 4;
    v3 = v10;
  }
  else
  {
    if (!v11)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  std::string::basic_string[abi:ne180100]<0>(__p, "Input");
  Phase::Controller::VoicePoolEntry::AddInput(v2, (__int128 *)__p);
  if (v9 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(v6, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v6);
  if (v7 < 0)
    operator delete(v6[0]);
  return v2;
}

void sub_2165FCA54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Phase::DspLayer::LinearFade::~LinearFade(Phase::DspLayer::LinearFade *this)
{
  Phase::DspLayer::VoicePool::~VoicePool(this);
  JUMPOUT(0x2199F9D70);
}

void `anonymous namespace'::LinearFadeSlice::~LinearFadeSlice(_anonymous_namespace_::LinearFadeSlice *this)
{
  JUMPOUT(0x2199F9D70);
}

double `anonymous namespace'::LinearFadeSlice::Reset(_OWORD *a1)
{
  double result;

  a1[1] = 0u;
  a1[2] = 0u;
  __asm { FMOV            V0.4S, #1.0 }
  a1[3] = _Q0;
  a1[4] = 0u;
  a1[261] = 0u;
  a1[524] = 0u;
  a1[525] = 0u;
  (*(void (**)(_OWORD *))(*(_QWORD *)a1 + 48))(a1);
  result = 0.0;
  a1[527] = 0u;
  a1[526] = 0u;
  return result;
}

uint64_t `anonymous namespace'::LinearFadeSlice::Reset(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  _DWORD *v7;
  uint64_t result;

  v7 = (_DWORD *)(a1 + 4 * a3);
  v7[4] = 0;
  v7[8] = 0;
  v7[12] = 1065353216;
  v7[16] = 0;
  v7[1044] = 0;
  v7[2096] = 0;
  v7[2100] = 0;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  *(_QWORD *)(a1 + 8 * a3 + 8416) = a4;
  return result;
}

uint64_t `anonymous namespace'::LinearFadeSlice::GetParameter(_anonymous_namespace_::LinearFadeSlice *this, unsigned int a2)
{
  if (a2 > 2)
    return 9;
  else
    return 0;
}

uint64_t `anonymous namespace'::LinearFadeSlice::SetParameter(_anonymous_namespace_::LinearFadeSlice *this, int a2, int a3, double a4)
{
  uint64_t result;
  float v6;
  float v7;
  float v8;

  if (a2 == 2)
  {
    result = 0;
    v7 = a4;
    *((float *)this + a3 + 12) = v7;
  }
  else if (a2 == 1)
  {
    result = 0;
    v8 = a4;
    *((float *)this + a3 + 8) = v8;
  }
  else if (a2)
  {
    return 9;
  }
  else
  {
    result = 0;
    v6 = a4;
    *((float *)this + a3 + 4) = v6;
  }
  return result;
}

float32x4_t `anonymous namespace'::LinearFadeSlice::UpdateParameters(uint64_t a1, uint64_t a2)
{
  const float *v3;
  float32x4_t v4;
  float32x4_t result;
  float32x4_t v6;
  float32x4_t v7;
  __int128 v8;
  float32x4_t v9;

  v3 = (const float *)(a2 + 8);
  v4 = vld1q_dup_f32(v3);
  v6 = *(float32x4_t *)(a1 + 48);
  v7 = vdivq_f32(v4, *(float32x4_t *)(a1 + 16));
  v8 = *(_OWORD *)(a1 + 4176);
  v9 = *(float32x4_t *)(a1 + 32);
  memcpy((void *)(a1 + 4192), (const void *)(a1 + 64), 0x1010uLL);
  *(float32x4_t *)(a1 + 8304) = v6;
  *(float32x4_t *)(a1 + 8320) = v7;
  *(_OWORD *)(a1 + 8336) = v8;
  *(float32x4_t *)(a1 + 8352) = v9;
  result = vsubq_f32(v6, v9);
  *(float32x4_t *)(a1 + 8368) = result;
  return result;
}

float `anonymous namespace'::LinearFadeSlice::UpdateParameters(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  float v4;
  float v5;
  float v6;
  int v7;
  float v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  float result;

  v3 = a1 + 4 * a3;
  v4 = *(float *)(v3 + 48);
  v5 = *(float *)(v3 + 16);
  v6 = *(float *)(a2 + 8);
  v7 = *(_DWORD *)(v3 + 4176);
  v8 = *(float *)(v3 + 32);
  v9 = *(unsigned int *)(v3 + 64);
  *(_DWORD *)(v3 + 4192) = v9;
  if ((int)v9 >= 1)
  {
    v10 = (_DWORD *)(a1 + 4 * a3);
    do
    {
      v10[1052] = v10[20];
      v10[1056] = v10[24];
      v10 += 8;
      --v9;
    }
    while (v9);
  }
  v11 = a1 + 4 * a3;
  *(float *)(v11 + 8304) = v4;
  *(float *)(v11 + 8320) = v6 / v5;
  *(_DWORD *)(v11 + 8336) = v7;
  result = v4 - v8;
  *(float *)(v11 + 8352) = v8;
  *(float *)(v11 + 8368) = result;
  return result;
}

uint64_t `anonymous namespace'::LinearFadeSlice::Run(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4)
{
  float32x4_t v4;
  int8x16_t v10;
  int8x16_t v11;
  int32x4_t v12;
  int64x2_t v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t v16;
  int32x4_t v17;
  int32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  unint64_t v21;
  float32x4_t v22;
  int8x16_t v23;

  v4 = *(float32x4_t *)(result + 8304);
  __asm { FMOV            V2.4S, #1.0 }
  v10 = (int8x16_t)vminnmq_f32(vaddq_f32(*(float32x4_t *)(result + 8320), *(float32x4_t *)(result + 8400)), _Q2);
  v11 = (int8x16_t)vceqq_f32(v4, *(float32x4_t *)(result + 8384));
  v12 = (int32x4_t)vandq_s8(*(int8x16_t *)(result + 4192), (int8x16_t)vcgtq_s32(vdupq_n_s32(a4), (int32x4_t)xmmword_2166F76B0));
  v13 = (int64x2_t)vcgtzq_s32(v12);
  if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v13, 1), (int8x16_t)v13).u64[0])
  {
    v14 = *(_QWORD *)(a2 + 56);
    v15 = (float32x4_t *)(result + 4224);
    v16 = 0uLL;
    v17 = 0uLL;
    v18.i64[0] = 0x100000001;
    v18.i64[1] = 0x100000001;
    do
    {
      v19.i32[0] = *(_DWORD *)(v14 + 4 * v15[-1].i32[0]);
      v19.i32[1] = *(_DWORD *)(v14 + 4 * v15[-1].i32[1]);
      v19.i32[2] = *(_DWORD *)(v14 + 4 * v15[-1].i32[2]);
      v19.i32[3] = *(_DWORD *)(v14 + 4 * v15[-1].i32[3]);
      v16 = vmlaq_f32(v16, (float32x4_t)vandq_s8((int8x16_t)v13, v19), *v15);
      v17 = vaddq_s32(v17, v18);
      v13 = (int64x2_t)vcgtq_s32(v12, v17);
      v15 += 2;
    }
    while (vorrq_s8((int8x16_t)vdupq_laneq_s64(v13, 1), (int8x16_t)v13).u64[0]);
  }
  else
  {
    v16 = 0uLL;
  }
  v20 = (float32x4_t)vandq_s8(v10, v11);
  HIDWORD(v21) = a4 - 1;
  LODWORD(v21) = a4 - 1;
  v22 = vmulq_f32(vmlaq_f32(*(float32x4_t *)(result + 8352), *(float32x4_t *)(result + 8368), v20), v16);
  v23 = vandq_s8((int8x16_t)v22, vorrq_s8((int8x16_t)vcltzq_f32(v22), (int8x16_t)vcgezq_f32(v22)));
  switch((v21 >> 1))
  {
    case 0u:
      goto LABEL_10;
    case 1u:
      goto LABEL_9;
    case 3u:
      goto LABEL_8;
    case 7u:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8348)) = v23.i32[3];
LABEL_8:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8344)) = v23.i32[2];
LABEL_9:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8340)) = v23.i32[1];
LABEL_10:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8336)) = v23.i32[0];
      break;
    default:
      break;
  }
  *(float32x4_t *)(result + 8384) = v4;
  *(float32x4_t *)(result + 8400) = v20;
  return result;
}

float `anonymous namespace'::LinearFadeSlice::CopyVoiceState(_anonymous_namespace_::LinearFadeSlice *this, Phase::DspLayer::VoicePoolSlice *a2, unsigned int a3, unsigned int a4)
{
  _DWORD *v4;
  _DWORD *v5;
  uint64_t v6;
  _DWORD *v7;
  int *v8;
  int v9;
  _DWORD *v10;
  _DWORD *v11;
  uint64_t v12;
  _DWORD *v13;
  int *v14;
  int v15;
  char *v16;
  char *v17;
  float result;

  v4 = (_DWORD *)((char *)a2 + 4 * (int)a3);
  v5 = (_DWORD *)((char *)this + 4 * (int)a4);
  v5[4] = v4[4];
  v5[8] = v4[8];
  v5[12] = v4[12];
  v6 = v4[16];
  v5[16] = v6;
  if ((int)v6 >= 1)
  {
    v7 = (_DWORD *)((char *)this + 4 * (int)a4 + 96);
    v8 = (int *)((char *)a2 + 4 * (int)a3 + 96);
    do
    {
      *(v7 - 4) = *(v8 - 4);
      v9 = *v8;
      v8 += 8;
      *v7 = v9;
      v7 += 8;
      --v6;
    }
    while (v6);
  }
  v10 = (_DWORD *)((char *)this + 4 * (int)a4);
  v11 = (_DWORD *)((char *)a2 + 4 * (int)a3);
  v12 = v11[1048];
  v10[1048] = v12;
  if ((int)v12 >= 1)
  {
    v13 = v10 + 1056;
    v14 = v11 + 1056;
    do
    {
      *(v13 - 4) = *(v14 - 4);
      v15 = *v14;
      v14 += 8;
      *v13 = v15;
      v13 += 8;
      --v12;
    }
    while (v12);
  }
  v10[1044] = v11[1044];
  v10[2076] = v11[2076];
  v10[2080] = v11[2080];
  v10[2084] = v11[2084];
  v10[2088] = v11[2088];
  v10[2092] = v11[2092];
  if (a3 >= 4)
    __assert_rtn("Copy", "DelaylineLinear.hpp", 507, "fromLane >= 0 && fromLane < PHASE_SIMD_WIDTH");
  if (a4 >= 4)
    __assert_rtn("Copy", "DelaylineLinear.hpp", 508, "toLane >= 0 && toLane < PHASE_SIMD_WIDTH");
  v16 = (char *)a2 + 4 * a3;
  v17 = (char *)this + 4 * a4;
  *((_DWORD *)v17 + 2096) = *((_DWORD *)v16 + 2096);
  result = *((float *)v16 + 2100);
  *((float *)v17 + 2100) = result;
  *((_QWORD *)this + (int)a4 + 1052) = *((_QWORD *)a2 + (int)a3 + 1052);
  return result;
}

uint64_t `anonymous namespace'::LinearFadeSlice::AddInput(_anonymous_namespace_::LinearFadeSlice *this, int a2, int a3, int a4, float a5)
{
  uint64_t result;
  char *v7;
  uint64_t v8;
  char *v9;

  if (a2)
    return 8;
  v7 = (char *)this + 64;
  v8 = *((int *)this + a3 + 16);
  if ((int)v8 > 127)
    return 6;
  result = 0;
  v9 = (char *)this + 32 * v8 + 4 * a3;
  *((_DWORD *)v9 + 20) = a4;
  *((float *)v9 + 24) = a5;
  *(_DWORD *)&v7[4 * a3] = v8 + 1;
  return result;
}

uint64_t `anonymous namespace'::LinearFadeSlice::RemoveInput(_anonymous_namespace_::LinearFadeSlice *this, int a2, int a3, int a4)
{
  if (a2)
    return 8;
  else
    return Phase::DspLayer::VoiceConnectionList<128>::RemoveConnection((uint64_t)this + 64, a3, a4);
}

uint64_t `anonymous namespace'::LinearFadeSlice::SetInputGain(_anonymous_namespace_::LinearFadeSlice *this, int a2, int a3, int a4, float a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  float *i;

  if (a2)
    return 8;
  v6 = *((unsigned int *)this + a3 + 16);
  if ((int)v6 < 1)
    return 7;
  v7 = 0;
  for (i = (float *)((char *)this + 4 * a3 + 96); *((_DWORD *)i - 4) != a4; i += 8)
  {
    if (v6 == ++v7)
      return 7;
  }
  if ((v7 & 0x80000000) != 0)
    return 7;
  result = 0;
  *i = a5;
  return result;
}

void `anonymous namespace'::LinearFadeSlice::GetInputs(_anonymous_namespace_::LinearFadeSlice *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (a2)
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    *(_QWORD *)(a4 + 16) = 0;
  }
  else
  {
    Phase::DspLayer::VoiceConnectionList<128>::GetConnections((uint64_t)this + 64, a3, (char **)a4);
  }
}

uint64_t `anonymous namespace'::LinearFadeSlice::ClearInputs(_anonymous_namespace_::LinearFadeSlice *this, int a2)
{
  *((_DWORD *)this + a2 + 16) = 0;
  return 0;
}

uint64_t `anonymous namespace'::LinearFadeSlice::GetMaximumInputConnectionCount(_anonymous_namespace_::LinearFadeSlice *this, int a2)
{
  return (a2 == 0) << 7;
}

unint64_t `anonymous namespace'::LinearFadeSlice::GetOutput(_anonymous_namespace_::LinearFadeSlice *this, int a2, int a3)
{
  if (a2)
    return 0xFFFFFFFF00000008;
  else
    return (unint64_t)*((unsigned int *)this + a3 + 1044) << 32;
}

uint64_t `anonymous namespace'::LinearFadeSlice::SetOutput(_anonymous_namespace_::LinearFadeSlice *this, int a2, int a3, int a4)
{
  uint64_t result;

  if (a2)
    return 8;
  result = 0;
  *((_DWORD *)this + a3 + 1044) = a4;
  return result;
}

void std::__function::__func<Phase::DspLayer::LinearFade::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::LinearFade::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<Phase::DspLayer::LinearFade::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::LinearFade::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57E8B0;
  return result;
}

void std::__function::__func<Phase::DspLayer::LinearFade::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::LinearFade::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57E8B0;
}

uint64_t std::__function::__func<Phase::DspLayer::LinearFade::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::LinearFade::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::operator()(uint64_t a1, Phase::DspLayer::VoiceEngine **a2, int *a3)
{
  Phase::DspLayer::VoiceEngine *v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v12;
  _OWORD *v13;
  void *v14;
  float32x4_t v15;
  int32x4_t v17;
  float32x4_t v18;

  v3 = *a2;
  v4 = *a3;
  v5 = operator new();
  Phase::DspLayer::VoicePool::VoicePool((Phase::DspLayer::VoicePool *)v5, "LinearFade", v3, v4, 8448);
  *(_QWORD *)v5 = &off_24D57E7B8;
  if (*(int *)(v5 + 40) >= 1)
  {
    v6 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    v18 = _Q0;
    do
    {
      v12 = *(_QWORD *)(v5 + 32);
      v13 = (_OWORD *)(*(_QWORD *)(v5 + 24) + *(int *)(v5 + 16) * (uint64_t)v6);
      *(_QWORD *)v13 = &off_24D57E7D8;
      *((_QWORD *)v13 + 1) = 0;
      bzero(v13 + 5, 0x1000uLL);
      v14 = v13 + 262;
      bzero(v13 + 262, 0x1010uLL);
      v13[4] = 0u;
      v13 += 4;
      *(v13 - 3) = 0u;
      *(v13 - 2) = 0u;
      v15 = v18;
      *(v13 - 1) = v18;
      v13[257] = 0u;
      v13[520] = 0u;
      v13[521] = 0u;
      v15.i32[0] = *(_DWORD *)(v12 + 8);
      v17 = vdupq_lane_s32((int32x2_t)*(_OWORD *)&vdivq_f32(v15, (float32x4_t)0), 0);
      memcpy(v14, v13, 0x1010uLL);
      v13[515] = v18;
      v13[516] = v17;
      v13[517] = 0u;
      v13[518] = 0u;
      v13[519] = v18;
      v13[522] = 0u;
      v13[523] = 0u;
      ++v6;
    }
    while (v6 < *(_DWORD *)(v5 + 40));
  }
  return v5;
}

void sub_2165FD2F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199F9D70](v1, 0x10F1C408EBD29CELL);
  _Unwind_Resume(a1);
}

uint64_t Phase::LinkedList::InsertNodeBefore(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v3;

  v3 = *(_DWORD *)(result + 16);
  *(_DWORD *)(result + 16) = v3 + 1;
  if (*(_QWORD *)result || *(_QWORD *)(result + 8))
  {
    if (a3)
    {
      if (*(_QWORD *)result == a3)
      {
        *(_QWORD *)(a2 + 8) = 0;
        *(_QWORD *)(a2 + 16) = a3;
        *(_QWORD *)(a3 + 8) = a2;
        *(_QWORD *)result = a2;
      }
      else
      {
        *(_QWORD *)(a2 + 8) = *(_QWORD *)(a3 + 8);
        *(_QWORD *)(a2 + 16) = a3;
        *(_QWORD *)(a3 + 8) = a2;
      }
    }
    else
    {
      *(_DWORD *)(result + 16) = v3;
    }
  }
  else
  {
    *(_QWORD *)result = a2;
    *(_QWORD *)(result + 8) = a2;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
  return result;
}

uint64_t Phase::LinkedList::InsertNodeAfter(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  ++*(_DWORD *)(result + 16);
  v3 = *(_QWORD *)(result + 8);
  if (*(_OWORD *)result == 0)
  {
    *(_QWORD *)result = a2;
    *(_QWORD *)(result + 8) = a2;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = a3;
    if (v3 == a3)
    {
      *(_QWORD *)(a2 + 16) = 0;
      *(_QWORD *)(a3 + 16) = a2;
      *(_QWORD *)(result + 8) = a2;
    }
    else
    {
      *(_QWORD *)(a2 + 16) = *(_QWORD *)(a3 + 16);
      *(_QWORD *)(a3 + 16) = a2;
    }
  }
  return result;
}

Phase::Logger *Phase::LinkedList::RemoveNode(Phase::Logger *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  std::logic_error *v10;
  NSObject *v11;
  std::logic_error *exception;
  int v13;
  const char *v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)result;
  if (!*(_QWORD *)result && !*((_QWORD *)result + 1))
  {
    v11 = **(NSObject ***)(Phase::Logger::GetInstancePtr(result) + 336);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v13 = 136315394;
      v14 = "LinkedList.cpp";
      v15 = 1024;
      v16 = 94;
      _os_log_impl(&dword_2164CC000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: !IsEmpty() is false.", (uint8_t *)&v13, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "PRECONDITION: !IsEmpty() is false.");
  }
  if (!a2)
    goto LABEL_15;
  v3 = a2;
  do
  {
    v4 = v3;
    v3 = *(_QWORD *)(v3 + 8);
  }
  while (v3);
  if (v4 != v2)
  {
LABEL_15:
    v9 = **(NSObject ***)(Phase::Logger::GetInstancePtr(result) + 336);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v13 = 136315394;
      v14 = "LinkedList.cpp";
      v15 = 1024;
      v16 = 95;
      _os_log_impl(&dword_2164CC000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: IsNodeOwner(pInNode) is false.", (uint8_t *)&v13, 0x12u);
    }
    v10 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v10, "PRECONDITION: IsNodeOwner(pInNode) is false.");
  }
  --*((_DWORD *)result + 4);
  v5 = *((_QWORD *)result + 1);
  if (v2 == v5)
  {
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)result = 0;
    *((_QWORD *)result + 1) = 0;
  }
  else if (v2 == a2)
  {
    v7 = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(v7 + 8) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)result = v7;
  }
  else if (v5 == a2)
  {
    v8 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(v8 + 16) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *((_QWORD *)result + 1) = v8;
  }
  else
  {
    v6 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(v6 + 16) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8) = v6;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
  return result;
}

void sub_2165FD5E8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::vector<double>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<double>::__append((char **)a1, a2 - v2);
  }
}

Phase::LinkwitzRileyFilterBank *Phase::LinkwitzRileyFilterBank::LinkwitzRileyFilterBank(Phase::LinkwitzRileyFilterBank *this, int a2, int a3, int a4, int a5)
{
  char *v8;
  Phase::LinkwitzRileyFilterBank *v9;
  void *__p[3];

  *(_DWORD *)this = a5;
  *((_DWORD *)this + 1) = a2;
  *((_DWORD *)this + 2) = a3;
  *((_DWORD *)this + 3) = a4;
  *((_DWORD *)this + 4) = 5;
  *(_OWORD *)((char *)this + 24) = 0u;
  v8 = (char *)this + 24;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_QWORD *)this + 9) = 0;
  *((_DWORD *)this + 20) = 1065353216;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  std::vector<float>::resize((uint64_t)this + 88, a3 * a2);
  std::vector<double>::resize((uint64_t)v8, *((int *)this + 4) * (uint64_t)*((int *)this + 2) * *((int *)this + 3));
  Phase::LinkwitzRileyFilterBank::GetDefaultCenterFrequencies(v9, a3, __p);
  Phase::LinkwitzRileyFilterBank::CreateWithCenterFrequency((int *)this, a4, (double **)__p);
  if (__p[0])
    operator delete(__p[0]);
  return this;
}

void sub_2165FD704(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  uint64_t v10;
  void **v11;
  void **v12;
  void *v14;
  void *v15;

  if (__p)
    operator delete(__p);
  v14 = *v12;
  if (*v12)
  {
    *(_QWORD *)(v10 + 96) = v14;
    operator delete(v14);
  }
  std::__hash_table<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>>>::~__hash_table(v10 + 48);
  v15 = *v11;
  if (*v11)
  {
    *(_QWORD *)(v10 + 32) = v15;
    operator delete(v15);
  }
  _Unwind_Resume(a1);
}

_OWORD *Phase::LinkwitzRileyFilterBank::GetDefaultCenterFrequencies@<X0>(Phase::LinkwitzRileyFilterBank *this@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  _OWORD *result;
  char *v5;
  NSObject *v7;
  std::logic_error *exception;
  _BYTE v9[24];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  if (a2 > 9)
  {
    if (a2 == 10)
    {
      memset(v9, 0, sizeof(v9));
      result = std::vector<double>::__init_with_size[abi:ne180100]<float const*,float const*>(v9, Phase::sOctaveBandFrequencies, &flt_216738C64, 0xAuLL);
    }
    else
    {
      if (a2 != 31)
      {
LABEL_12:
        v7 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 624);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v9 = 136315650;
          *(_QWORD *)&v9[4] = "LinkwitzRileyFilterBank.cpp";
          *(_WORD *)&v9[12] = 1024;
          *(_DWORD *)&v9[14] = 154;
          *(_WORD *)&v9[18] = 1024;
          *(_DWORD *)&v9[20] = a2;
          _os_log_impl(&dword_2164CC000, v7, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error): \"Current number of bands (%d bands) not defined in Subbands.hpp. Please, create your own custom vector of \" \"center frequencies.\"", v9, 0x18u);
        }
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "Current number of bands (%d bands) not defined in Subbands.hpp. Please, create your own custom vector of center frequencies.");
      }
      memset(v9, 0, sizeof(v9));
      result = std::vector<double>::__init_with_size[abi:ne180100]<float const*,float const*>(v9, Phase::sThirdOctaveBandFrequencies, Phase::sOctaveBandFrequencies, 0x1FuLL);
    }
LABEL_10:
    v5 = *(char **)&v9[16];
    *(_OWORD *)a3 = *(_OWORD *)v9;
    goto LABEL_11;
  }
  if (a2 == 3)
  {
    memset(v9, 0, sizeof(v9));
    result = std::vector<double>::__init_with_size[abi:ne180100]<float const*,float const*>(v9, Phase::sThreeBandFrequencies, &Phase::sThreeBandFrequencies[3], 3uLL);
    goto LABEL_10;
  }
  if (a2 != 5)
    goto LABEL_12;
  result = operator new(0x28uLL);
  *result = xmmword_216738C68;
  result[1] = unk_216738C78;
  *((_QWORD *)result + 4) = 0x40BF400000000000;
  v5 = (char *)result + 40;
  *a3 = result;
  a3[1] = (char *)result + 40;
LABEL_11:
  a3[2] = v5;
  return result;
}

void sub_2165FD920(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void Phase::LinkwitzRileyFilterBank::CreateWithCenterFrequency(int *a1, int a2, double **a3)
{
  void *__p[3];

  Phase::GetBandsFromCenterFrequencies<std::__wrap_iter<double *>,double>(*a3, a3[1], (double **)__p, (double)((*a1 >> 1) - 1));
  Phase::LinkwitzRileyFilterBank::CreateWithBands(a1, a2, __p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_2165FD9A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Phase::LinkwitzRileyFilterBank::~LinkwitzRileyFilterBank(Phase::LinkwitzRileyFilterBank *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 11);
  if (v2)
  {
    *((_QWORD *)this + 12) = v2;
    operator delete(v2);
  }
  std::__hash_table<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>>>::~__hash_table((uint64_t)this + 48);
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
}

void Phase::LinkwitzRileyFilterBank::CreateWithBands(int *a1, int a2, _QWORD *a3)
{
  double v3;
  unsigned int v6;
  int v7;
  int v8;
  int v9;
  double *v15;
  uint64_t v16;
  char *v17;
  char *v18;
  char *v19;
  _QWORD *v20;
  void *v21;
  double v22;
  double v23;
  uint64_t v24;
  _QWORD *v25;
  double v26;
  BOOL v27;
  double v28;
  double *v29;
  double *v30;
  long double v31;
  uint64_t v32;
  long double v33;
  double v34;
  double v35;
  double v36;
  double *v37;
  __double2 v38;
  float64x2_t v39;
  int8x16_t v40;
  double v41;
  int8x16_t v42;
  int8x16_t v43;
  double v44;
  double v45;
  long double v46;
  long double v47;
  long double v48;
  double v49;
  double v50;
  long double v51;
  double v52;
  long double v53;
  long double v54;
  double v55;
  double v56;
  __double2 v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  size_t v61;
  vDSP_biquad_SetupD *v62;
  uint64_t v63;
  vDSP_biquad_SetupD *v64;
  const double *OneBandBiquadStage;
  unint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  double *v71;
  float *v72;
  double v73;
  float v74;
  vDSP_biquad_SetupD *v75;
  double v76;
  int8x16_t v78;
  long double v79;
  long double v80;
  float64x2_t v81;
  double v82;
  double v83;
  char *v84;
  double v85;
  double *__Delay;
  double *v87;
  double *__Y[2];
  int v89;
  long double v90[2];
  double v91;
  double v92;
  double v93[2];
  float64x2_t v94;
  double v95;
  double v96;
  double v97;
  uint64_t v98;

  v98 = *MEMORY[0x24BDAC8D0];
  a1[3] = a2;
  v6 = *a1;
  std::vector<double>::resize((uint64_t)(a1 + 6), a1[2] * a2 * a1[4]);
  v89 = 0;
  v7 = a1[2];
  if (v7 >= 1)
  {
    v8 = 0;
    v9 = 0;
    v76 = (double)(v6 >> 1);
    __asm { FMOV            V0.2D, #0.5 }
    v81 = _Q0;
    _Q0.f64[0] = NAN;
    _Q0.f64[1] = NAN;
    v78 = (int8x16_t)vnegq_f64(_Q0);
    do
    {
      v15 = (double *)(*a3 + 16 * v8);
      if (v15[1] >= v76)
        __assert_rtn("CreateWithBands", "LinkwitzRileyFilterBank.cpp", 69, "band.mHighCutInHertz < nyquist");
      if (*v15 <= 0.0)
        __assert_rtn("CreateWithBands", "LinkwitzRileyFilterBank.cpp", 70, "band.mLowCutInHertz > dc");
      v16 = a1[3];
      if ((_DWORD)v16)
      {
        if ((v16 & 0x80000000) != 0)
          std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
        v17 = (char *)operator new(40 * v16);
        v18 = &v17[40 * (int)v16];
        v84 = v17;
        v19 = v17;
        do
        {
          *(_QWORD *)v19 = 0x3FF0000000000000;
          *(_OWORD *)(v19 + 8) = 0uLL;
          *(_OWORD *)(v19 + 24) = 0uLL;
          v19 += 40;
        }
        while (v19 != v18);
      }
      else
      {
        v84 = 0;
        v18 = 0;
      }
      v20 = std::__hash_table<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)a1 + 6, v8, &v89);
      v21 = (void *)v20[3];
      if (v21)
      {
        v20[4] = v21;
        operator delete(v21);
        v20[3] = 0;
        v20[4] = 0;
        v20[5] = 0;
      }
      v20[3] = v84;
      v20[4] = v18;
      v20[5] = v18;
      LODWORD(v3) = *a1;
      v22 = *v15;
      v23 = v15[1];
      v24 = std::__hash_table<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)a1 + 6, v8, &v89)[3];
      v25 = std::__hash_table<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)a1 + 6, v8, &v89);
      v26 = (double)*(unint64_t *)&v3;
      if ((double)*(unint64_t *)&v3 * 0.5 <= v23
        || (v22 > 0.0 ? (v27 = v23 <= v22) : (v27 = 1),
            v27 || (uint64_t)(0xCCCCCCCCCCCCCCCDLL * ((v25[4] - v24) >> 3)) < a2))
      {
        __assert_rtn("ButterworthBandPassNthOrder", "Biquad.hpp", 561, "inHighCutoffFrequencyInHertz > inLowCutoffFrequencyInHertz && inLowCutoffFrequencyInHertz > T(0) && inHighCutoffFrequencyInHertz < inSampleRateInHertz / T(2) && std::distance(outSectionFirst, outSectionLast) >= inOrder");
      }
      v28 = sqrt(v22 * v23) / v26 * 6.28318531;
      *(_OWORD *)__Y = xmmword_2166F7470;
      v95 = v28 * 0.0;
      v96 = v28;
      std::exp[abi:ne180100]<double>(&v95);
      __Delay = v29;
      v87 = v30;
      if (a2 > 0)
      {
        v31 = v26 / 3.14159265 * tan(v22 * 3.14159265 / v26);
        v32 = 0;
        v33 = v26 / 3.14159265 * tan(v23 * 3.14159265 / v26);
        v34 = sqrt(v31 * v33);
        v82 = (v33 - v31) / v34;
        v35 = v82 * 0.5;
        v3 = v34 * 6.28318531;
        v36 = v26 + v26;
        v37 = (double *)(v24 + 16);
        do
        {
          v38 = __sincos_stret(((double)(int)++v32 * 2.0 + -1.0) * 3.14159265 / ((double)a2 + (double)a2));
          v39.f64[0] = *(double *)__Y * v38.__cosval - v38.__sinval;
          v83 = v39.f64[0];
          v85 = *(double *)&__Y[1] * v38.__cosval;
          v39.f64[1] = *(double *)&__Y[1] * v38.__cosval;
          v94 = vmulq_f64(vmulq_n_f64(v39, v82), v81);
          *(double *)v40.i64 = std::operator*[abi:ne180100]<double>(v94.f64, v94.f64);
          *(double *)v42.i64 = -v41;
          v43.i64[0] = 0x7FF0000000000000;
          if (fabs(v41) != INFINITY)
          {
            *(double *)v43.i64 = 1.0 - *(double *)v40.i64;
            if (fabs(1.0 - *(double *)v40.i64) == INFINITY)
            {
              if (*(double *)v43.i64 <= 0.0)
              {
                v42.i64[0] = vbslq_s8(v78, v43, v42).u64[0];
                v43.i64[0] = 0;
              }
              else
              {
                v40.i64[0] = 0;
                v42.i64[0] = vbslq_s8(v78, v40, v42).u64[0];
              }
            }
            else
            {
              v79 = -v41;
              v80 = 1.0 - *(double *)v40.i64;
              v55 = sqrt(hypot(*(long double *)v43.i64, -v41));
              v56 = atan2(v79, v80);
              v42.i64[0] = 0x7FF8000000000000;
              v43.i64[0] = 0x7FF8000000000000;
              if ((*(_QWORD *)&v55 & 0x8000000000000000) == 0)
              {
                if (fabs(v56 * 0.5) == INFINITY)
                {
                  v42.i64[0] = 0x7FF8000000000000;
                  if (v55 == INFINITY)
                    *(double *)v43.i64 = v55;
                  else
                    *(double *)v43.i64 = NAN;
                }
                else
                {
                  v57 = __sincos_stret(v56 * 0.5);
                  *(double *)v43.i64 = v55 * v57.__cosval;
                  *(double *)v42.i64 = v55 * v57.__sinval;
                }
              }
            }
          }
          v93[0] = *(double *)v43.i64;
          v93[1] = *(double *)v42.i64;
          v45 = v3 * (v35 * v83 + std::operator*[abi:ne180100]<double>((double *)__Y, v93)) / v36;
          v95 = v45 + 1.0;
          v96 = v3 * (v35 * v85 + v44) / v36;
          v91 = 1.0 - v45;
          v92 = -v96;
          v46 = std::operator/[abi:ne180100]<double>(&v95, &v91);
          v48 = hypot(v46, v47);
          v49 = v48 * v48;
          v37[1] = v46 * -2.0;
          v37[2] = v49;
          v95 = 1.0;
          v96 = v46 * -2.0;
          v97 = v49;
          v91 = Phase::Biquad::details::EvaluatePolynomial<double>(dbl_216738CA0, (double *)&__Delay);
          v92 = v50;
          v90[0] = Phase::Biquad::details::EvaluatePolynomial<double>(&v95, (double *)&__Delay);
          v90[1] = v51;
          v52 = std::operator/[abi:ne180100]<double>(&v91, v90);
          v54 = 1.0 / hypot(v52, v53);
          *(v37 - 2) = v54;
          *(v37 - 1) = 0.0;
          *v37 = -v54;
          v37 += 5;
        }
        while (a2 != v32);
      }
      if (a1[3] >= 1)
      {
        v58 = 0;
        v59 = 0;
        do
        {
          v60 = a1 + 6;
          *(_QWORD *)(*((_QWORD *)a1 + 3) + 8 * v9) = *(_QWORD *)(std::__hash_table<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)a1 + 6, v8, &v89)[3]+ v58);
          *(_QWORD *)(*v60 + 8 * v9 + 8) = *(_QWORD *)(std::__hash_table<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)a1 + 6, v8, &v89)[3]+ v58+ 8);
          *(_QWORD *)(*v60 + 8 * v9 + 16) = *(_QWORD *)(std::__hash_table<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)a1 + 6, v8, &v89)[3]+ v58+ 16);
          *(_QWORD *)(*v60 + 8 * v9 + 24) = *(_QWORD *)(std::__hash_table<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)a1 + 6, v8, &v89)[3]+ v58+ 24);
          *(_QWORD *)(*v60 + 8 * v9 + 32) = *(_QWORD *)(std::__hash_table<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)a1 + 6, v8, &v89)[3]+ v58+ 32);
          v9 += a1[4];
          ++v59;
          v58 += 40;
        }
        while (v59 < a1[3]);
      }
      v89 = ++v8;
      v7 = a1[2];
    }
    while (v8 < v7);
  }
  if (v7)
  {
    if (v7 < 0)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v61 = 8 * v7;
    v62 = (vDSP_biquad_SetupD *)operator new(v61);
    bzero(v62, v61);
    v63 = 0;
    v64 = &v62[v61 / 8];
    do
    {
      OneBandBiquadStage = (const double *)Phase::LinkwitzRileyFilterBank::GetOneBandBiquadStage((Phase::LinkwitzRileyFilterBank *)a1, v63);
      v62[v63++] = vDSP_biquad_CreateSetupD(OneBandBiquadStage, a1[3]);
    }
    while (v63 < a1[2]);
  }
  else
  {
    v62 = 0;
    v64 = 0;
  }
  v66 = a1[1];
  __Y[0] = 0;
  std::vector<double>::vector(&v95, v66, __Y);
  v67 = a1[1];
  __Delay = 0;
  std::vector<double>::vector(__Y, v67, &__Delay);
  **(_QWORD **)&v95 = 0x3FF0000000000000;
  if (a1[2] >= 1)
  {
    v68 = 0;
    v69 = 2 * a1[3] + 2;
    do
    {
      v94.f64[0] = 0.0;
      std::vector<double>::vector(&__Delay, v69, &v94);
      vDSP_biquadD(v62[v68], __Delay, *(const double **)&v95, 1, __Y[0], 1, a1[1]);
      vDSP_vclrD(__Delay, 1, v69);
      vDSP_biquadD(v62[v68], __Delay, __Y[0], 1, __Y[0], 1, a1[1]);
      v70 = a1[1];
      if ((int)v70 >= 1)
      {
        v71 = __Y[0];
        v72 = (float *)(*((_QWORD *)a1 + 11) + 4 * (int)v70 * (int)v68);
        do
        {
          v73 = *v71++;
          v74 = v73;
          *v72++ = v74;
          --v70;
        }
        while (v70);
      }
      if (__Delay)
      {
        v87 = __Delay;
        operator delete(__Delay);
      }
      ++v68;
    }
    while (v68 < a1[2]);
  }
  if (v62 != v64)
  {
    v75 = v62;
    do
      vDSP_biquad_DestroySetupD(*v75++);
    while (v75 != v64);
  }
  if (__Y[0])
  {
    __Y[1] = __Y[0];
    operator delete(__Y[0]);
  }
  if (v95 != 0.0)
  {
    v96 = v95;
    operator delete(*(void **)&v95);
  }
  if (v62)
    operator delete(v62);
}

void sub_2165FE278(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36)
{
  void *v36;
  uint64_t v37;
  void *v39;

  v39 = *(void **)(v37 - 184);
  if (v39)
  {
    *(_QWORD *)(v37 - 176) = v39;
    operator delete(v39);
  }
  if (v36)
    operator delete(v36);
  _Unwind_Resume(exception_object);
}

Phase::Logger *Phase::GetBandsFromCenterFrequencies<std::__wrap_iter<double *>,double>@<X0>(double *a1@<X0>, double *a2@<X1>, double **a3@<X8>, double a4@<D0>)
{
  uint64_t v8;
  int64_t v9;
  Phase::Logger *result;
  double *v11;
  double *v12;
  float *v13;
  float v14;
  _BOOL4 v15;
  BOOL v16;
  double *v17;
  float *v18;
  float v19;
  _BOOL4 v20;
  BOOL v21;
  int64_t v22;
  int64_t v23;
  uint64_t v24;
  double *v25;
  double *v26;
  double v27;
  double v28;
  double v29;
  uint64_t v30;
  NSObject *v31;
  double v32;
  std::logic_error *exception;
  NSObject *v34;
  double v35;
  NSObject *v36;
  double v37;
  NSObject *v38;
  double v39;
  double v40;
  _BYTE v41[18];
  __int16 v42;
  double v43;
  __int16 v44;
  double v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  v8 = (char *)a2 - (char *)a1;
  v9 = a2 - a1;
  *(_QWORD *)v41 = 0;
  *(_QWORD *)&v41[8] = 0;
  result = (Phase::Logger *)std::vector<Phase::FrequencyBand<double>>::vector(a3, v9, v41);
  v11 = *a3;
  **a3 = 10.0;
  if (v9 == 31)
  {
    if (a1 == a2)
    {
      v15 = 0;
      v20 = 1;
    }
    else
    {
      v17 = a1 + 1;
      v18 = Phase::sThirdOctaveBandFrequencies;
      do
      {
        v19 = *v18++;
        v20 = *(v17 - 1) == v19;
        v21 = *(v17 - 1) != v19 || v17 == a2;
        ++v17;
      }
      while (!v21);
      v15 = 0;
    }
  }
  else
  {
    if (v9 != 10)
    {
      v15 = 0;
LABEL_20:
      v20 = 0;
      goto LABEL_21;
    }
    if (a1 != a2)
    {
      v12 = a1 + 1;
      v13 = Phase::sOctaveBandFrequencies;
      do
      {
        v14 = *v13++;
        v15 = *(v12 - 1) == v14;
        v16 = *(v12 - 1) != v14 || v12 == a2;
        ++v12;
      }
      while (!v16);
      goto LABEL_20;
    }
    v20 = 0;
    v15 = 1;
  }
LABEL_21:
  if (v8 >= 1)
  {
    v22 = 0;
    v23 = v9 - 1;
    if (v9 <= 1)
      v24 = 1;
    else
      v24 = v9;
    v25 = v11 + 2;
    v26 = a1;
    do
    {
      v27 = *v26;
      if (v15)
      {
        v28 = v27 + v27 / 1.41421356 * 0.5;
        if (v28 >= a4)
          v28 = a4;
        v29 = 20.3630682;
      }
      else if (v20)
      {
        v28 = v27 + v27 / 4.24264069 * 0.5;
        if (v28 >= a4)
          v28 = a4;
        v29 = 17.6429774;
      }
      else
      {
        if ((*(_QWORD *)&v27 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
        {
          v31 = **(NSObject ***)(Phase::Logger::GetInstancePtr(result) + 1136);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            v32 = *v26;
            *(_DWORD *)v41 = 136315650;
            *(_QWORD *)&v41[4] = "FrequencyResponse.hpp";
            *(_WORD *)&v41[12] = 1024;
            *(_DWORD *)&v41[14] = 99;
            v42 = 2048;
            v43 = v32;
            _os_log_impl(&dword_2164CC000, v31, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [!std::isfinite(inFrequenciesFirst[i]) is true]: \"GetBandsFromCenterFrequencies: bad center frequency: %fHz\"", v41, 0x1Cu);
          }
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(exception, "GetBandsFromCenterFrequencies: bad center frequency: %fHz");
LABEL_60:
          exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8D0] + 16);
        }
        if (v27 < 10.0)
        {
          v36 = **(NSObject ***)(Phase::Logger::GetInstancePtr(result) + 1136);
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          {
            v37 = *v26;
            *(_DWORD *)v41 = 136315906;
            *(_QWORD *)&v41[4] = "FrequencyResponse.hpp";
            *(_WORD *)&v41[12] = 1024;
            *(_DWORD *)&v41[14] = 103;
            v42 = 2048;
            v43 = v37;
            v44 = 2048;
            v45 = 10.0;
            _os_log_impl(&dword_2164CC000, v36, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [inFrequenciesFirst[i] < lowestSupportedFreqInHz is true]: \"GetBandsFromCenterFrequencies: center frequency: %fHz cannot be below lowest supported frequency: %fHz\"", v41, 0x26u);
          }
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(exception, "GetBandsFromCenterFrequencies: center frequency: %fHz cannot be below lowest supported frequency: %fHz");
          goto LABEL_60;
        }
        if (v27 > a4)
        {
          v34 = **(NSObject ***)(Phase::Logger::GetInstancePtr(result) + 1136);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            v35 = *v26;
            *(_DWORD *)v41 = 136315906;
            *(_QWORD *)&v41[4] = "FrequencyResponse.hpp";
            *(_WORD *)&v41[12] = 1024;
            *(_DWORD *)&v41[14] = 107;
            v42 = 2048;
            v43 = v35;
            v44 = 2048;
            v45 = a4;
            _os_log_impl(&dword_2164CC000, v34, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [inFrequenciesFirst[i] > highestSupportedFreqInHz is true]: \"GetBandsFromCenterFrequencies: center frequency: %fHz cannot be above highest supported frequency: %fHz\"", v41, 0x26u);
          }
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(exception, "GetBandsFromCenterFrequencies: center frequency: %fHz cannot be above highest supported frequency: %fHz");
          goto LABEL_60;
        }
        if (v22)
        {
          v30 = (v22 - 1);
          if (a1[v30] >= v27)
          {
            v38 = **(NSObject ***)(Phase::Logger::GetInstancePtr(result) + 1136);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
            {
              v39 = a1[v30];
              v40 = *v26;
              *(_DWORD *)v41 = 136315906;
              *(_QWORD *)&v41[4] = "FrequencyResponse.hpp";
              *(_WORD *)&v41[12] = 1024;
              *(_DWORD *)&v41[14] = 111;
              v42 = 2048;
              v43 = v39;
              v44 = 2048;
              v45 = v40;
              _os_log_impl(&dword_2164CC000, v38, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [i > 0 && inFrequenciesFirst[i - 1] >= inFrequenciesFirst[i] is true]: \"GetBandsFromCenterFrequencies: center frequencies are not in ascending order. %fHz is before %fHz\"", v41, 0x26u);
            }
            exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
            std::logic_error::logic_error(exception, "GetBandsFromCenterFrequencies: center frequencies are not in ascending order. %fHz is before %fHz");
            goto LABEL_60;
          }
        }
        v29 = 10.0;
        if (v23 <= v22)
          v28 = a4;
        else
          v28 = v27 * sqrt(v26[1] / v27);
      }
      *(v25 - 1) = v28;
      *v11 = v29;
      if (v23 > v22)
        *v25 = v28;
      ++v22;
      ++v26;
      v25 += 2;
    }
    while (v24 != v22);
  }
  return result;
}

void sub_2165FE7F4(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  void *v4;

  __cxa_free_exception(v2);
  v4 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

uint64_t Phase::LinkwitzRileyFilterBank::GetOneBandImpulseResponse(Phase::LinkwitzRileyFilterBank *this, int a2)
{
  NSObject *v4;
  int v5;
  std::logic_error *exception;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)this + 2) <= a2)
  {
    v4 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 624);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = *((_DWORD *)this + 2);
      *(_DWORD *)buf = 136315906;
      v9 = "LinkwitzRileyFilterBank.cpp";
      v10 = 1024;
      v11 = 173;
      v12 = 1024;
      v13 = a2;
      v14 = 1024;
      v15 = v5;
      _os_log_impl(&dword_2164CC000, v4, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [inBand > mNumBands - 1 is true]: \"Current band (%d) is bigger than than the current constructed filter bank (%d bands)\"", buf, 0x1Eu);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Current band (%d) is bigger than than the current constructed filter bank (%d bands)");
  }
  return *((_QWORD *)this + 11) + 4 * *((_DWORD *)this + 1) * a2;
}

void sub_2165FE968(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t Phase::LinkwitzRileyFilterBank::GetOneBandBiquadStage(Phase::LinkwitzRileyFilterBank *this, int a2)
{
  NSObject *v4;
  int v5;
  std::logic_error *exception;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)this + 2) <= a2)
  {
    v4 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 624);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = *((_DWORD *)this + 2);
      *(_DWORD *)buf = 136315906;
      v9 = "LinkwitzRileyFilterBank.cpp";
      v10 = 1024;
      v11 = 182;
      v12 = 1024;
      v13 = a2;
      v14 = 1024;
      v15 = v5;
      _os_log_impl(&dword_2164CC000, v4, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [inBand > mNumBands - 1 is true]: \"Current band (%d) is bigger than than the current constructed filter bank (%d bands)\"", buf, 0x1Eu);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Current band (%d) is bigger than than the current constructed filter bank (%d bands)");
  }
  return *((_QWORD *)this + 3) + 8 * *((_DWORD *)this + 4) * a2 * *((_DWORD *)this + 3);
}

void sub_2165FEAAC(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void Phase::LinkwitzRileyFilterBank::CreateVDSPFilterBankSetup(Phase::LinkwitzRileyFilterBank *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  const double *OneBandBiquadStage;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  std::vector<vDSP_biquad_SetupStruct *>::resize((uint64_t)a2, *((int *)this + 2));
  if (*((int *)this + 2) >= 1)
  {
    v4 = 0;
    do
    {
      OneBandBiquadStage = (const double *)Phase::LinkwitzRileyFilterBank::GetOneBandBiquadStage(this, v4);
      *(_QWORD *)(*a2 + 8 * v4++) = vDSP_biquad_CreateSetup(OneBandBiquadStage, *((int *)this + 3));
    }
    while (v4 < *((int *)this + 2));
  }
}

void sub_2165FEB40(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<vDSP_biquad_SetupStruct *>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<vDSP_biquad_SetupStruct *>::__append((char **)a1, a2 - v2);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>>>::__deallocate_node(int a1, _QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  if (__p)
  {
    v2 = __p;
    do
    {
      v3 = (_QWORD *)*v2;
      v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::vector<double>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 3);
    if (v10 >> 61)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 3;
    v12 = v5 - v8;
    if (v12 >> 2 > v10)
      v10 = v12 >> 2;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[8 * v11];
    v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      v18 = *((_QWORD *)v7 - 1);
      v7 -= 8;
      *((_QWORD *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<Phase::Biquad::Coefficients<double>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t *a1, int a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  int8x8_t prime;
  void *v19;
  void *v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  uint8x8_t v24;
  unint64_t v25;
  uint8x8_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  void *v34;

  v6 = a2;
  v7 = a1[1];
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v12 = a1 + 2;
  v10 = operator new(0x30uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  v13 = (float)(unint64_t)(a1[3] + 1);
  v14 = *((float *)a1 + 8);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      prime = (int8x8_t)v17;
    else
      prime = (int8x8_t)v16;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v7 = a1[1];
    }
    if (*(_QWORD *)&prime > v7)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v7)
    {
      v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v7 < 3 || (v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        v25 = std::__next_prime(v25);
      }
      else
      {
        v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2)
          v25 = v27;
      }
      if (*(_QWORD *)&prime <= v25)
        prime = (int8x8_t)v25;
      if (*(_QWORD *)&prime >= v7)
      {
        v7 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v19 = operator new(8 * *(_QWORD *)&prime);
          v20 = (void *)*a1;
          *a1 = (uint64_t)v19;
          if (v20)
            operator delete(v20);
          v21 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(_QWORD *)(*a1 + 8 * v21++) = 0;
          while (*(_QWORD *)&prime != v21);
          v22 = (_QWORD *)*v12;
          if (*v12)
          {
            v23 = v22[1];
            v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(_QWORD *)&prime)
                v23 %= *(_QWORD *)&prime;
            }
            else
            {
              v23 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*a1 + 8 * v23) = v12;
            v28 = (_QWORD *)*v22;
            if (*v22)
            {
              do
              {
                v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(_QWORD *)&prime)
                    v29 %= *(_QWORD *)&prime;
                }
                else
                {
                  v29 &= *(_QWORD *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(_QWORD *)(*a1 + 8 * v29))
                  {
                    *(_QWORD *)(*a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  *v22 = *v28;
                  *v28 = **(_QWORD **)(*a1 + 8 * v29);
                  **(_QWORD **)(*a1 + 8 * v29) = v28;
                  v28 = v22;
                }
                v29 = v23;
LABEL_55:
                v22 = v28;
                v28 = (_QWORD *)*v28;
                v23 = v29;
              }
              while (v28);
            }
          }
          v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        v34 = (void *)*a1;
        *a1 = 0;
        if (v34)
          operator delete(v34);
        v7 = 0;
        a1[1] = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v30 = *a1;
  v31 = *(_QWORD **)(*a1 + 8 * v3);
  if (v31)
  {
    *v10 = *v31;
LABEL_72:
    *v31 = v10;
    goto LABEL_73;
  }
  *v10 = *v12;
  *v12 = v10;
  *(_QWORD *)(v30 + 8 * v3) = v12;
  if (*v10)
  {
    v32 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7)
        v32 %= v7;
    }
    else
    {
      v32 &= v7 - 1;
    }
    v31 = (_QWORD *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return v10;
}

void sub_2165FF0F4(_Unwind_Exception *a1)
{
  _QWORD *v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::vector<vDSP_biquad_SetupStruct *>>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void std::exp[abi:ne180100]<double>(double *a1)
{
  long double v1;
  double v2;
  double v3;

  v1 = *a1;
  v2 = a1[1];
  if (v2 == 0.0)
  {
    exp(v1);
    return;
  }
  if (fabs(v1) == INFINITY)
  {
    if (v1 >= 0.0)
    {
      if ((*(_QWORD *)&v2 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
        return;
    }
    else if ((*(_QWORD *)&v2 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
    {
      v2 = 1.0;
    }
  }
  v3 = v2;
  exp(v1);
  __sincos_stret(v3);
}

double std::operator*[abi:ne180100]<double>(double *a1, double *a2)
{
  return *a1 * *a2 - a1[1] * a2[1];
}

double std::operator/[abi:ne180100]<double>(double *a1, long double *a2)
{
  double v2;
  int v3;
  double v4;
  long double v5;
  double v6;
  double v8;
  double v9;
  long double v10;
  double v11;
  long double __x;

  v8 = *a1;
  v9 = a1[1];
  v10 = a2[1];
  __x = *a2;
  v2 = logb(fmax(fabs(*a2), fabs(v10)));
  if ((*(_QWORD *)&v2 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    v3 = 0;
    v4 = v10;
  }
  else
  {
    v3 = (int)v2;
    __x = ldexp(__x, -(int)v2);
    v4 = ldexp(v10, -v3);
  }
  v11 = v4;
  v5 = v4 * v4 + __x * __x;
  v6 = ldexp((v9 * v4 + v8 * __x) / v5, -v3);
  ldexp((v9 * __x - v8 * v11) / v5, -v3);
  return v6;
}

double Phase::Biquad::details::EvaluatePolynomial<double>(double *a1, double *a2)
{
  uint64_t v3;
  _QWORD *v4;
  double result;
  uint64_t v6;
  double v7;
  uint64_t v8;

  v3 = 0;
  v4 = a1 + 1;
  v7 = *a1;
  v8 = 0;
  do
  {
    result = std::operator*[abi:ne180100]<double>(a2, &v7) + *(double *)&v4[v3];
    v7 = result;
    v8 = v6;
    ++v3;
  }
  while (v3 != 2);
  return result;
}

_QWORD *std::vector<double>::vector(_QWORD *a1, unint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<Phase::FrequencyBand<float>>::__vallocate[abi:ne180100](a1, a2);
    v6 = (_QWORD *)a1[1];
    v7 = &v6[a2];
    v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_2165FF714(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<double>::__init_with_size[abi:ne180100]<float const*,float const*>(char *result, float *a2, float *a3, unint64_t a4)
{
  char *v6;
  double *v7;
  float v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<Phase::FrequencyBand<float>>::__vallocate[abi:ne180100](result, a4);
    v7 = (double *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v8 = *a2++;
      *v7++ = v8;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_2165FF788(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<Phase::FrequencyBand<double>>::vector(_QWORD *a1, unint64_t a2, _OWORD *a3)
{
  _OWORD *v6;
  _OWORD *v7;
  uint64_t v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::shared_ptr<Phase::Geometry::MpsCpuScene>>::__vallocate[abi:ne180100](a1, a2);
    v6 = (_OWORD *)a1[1];
    v7 = &v6[a2];
    v8 = 16 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 16;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_2165FF808(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<vDSP_biquad_SetupStruct *>::__append(char **a1, unint64_t a2)
{
  char *v4;
  char *v5;
  char *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;

  v5 = a1[1];
  v4 = a1[2];
  if (a2 <= (v4 - v5) >> 3)
  {
    if (a2)
    {
      bzero(a1[1], 8 * a2);
      v5 += 8 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    v6 = *a1;
    v7 = v5 - *a1;
    v8 = a2 + (v7 >> 3);
    if (v8 >> 61)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v9 = v4 - v6;
    if (v9 >> 2 > v8)
      v8 = v9 >> 2;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
      v10 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if (v10)
    {
      if (v10 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v11 = (char *)operator new(8 * v10);
    }
    else
    {
      v11 = 0;
    }
    v12 = &v11[8 * (v7 >> 3)];
    v13 = &v11[8 * v10];
    bzero(v12, 8 * a2);
    v14 = &v12[8 * a2];
    if (v5 != v6)
    {
      do
      {
        v15 = *((_QWORD *)v5 - 1);
        v5 -= 8;
        *((_QWORD *)v12 - 1) = v15;
        v12 -= 8;
      }
      while (v5 != v6);
      v5 = *a1;
    }
    *a1 = v12;
    a1[1] = v14;
    a1[2] = v13;
    if (v5)
      operator delete(v5);
  }
}

Phase::Controller::ListenerHeadTracker *Phase::Controller::ListenerHeadTracker::ListenerHeadTracker(Phase::Controller::ListenerHeadTracker *this)
{
  id *v2;

  v2 = (id *)operator new();
  Phase::Controller::ListenerHeadTrackerImpl::ListenerHeadTrackerImpl(v2);
  *(_QWORD *)this = v2;
  return this;
}

void sub_2165FF978(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199F9D70](v1, 0x80C40B8603338);
  _Unwind_Resume(a1);
}

void Phase::Controller::ListenerHeadTracker::~ListenerHeadTracker(id **this)
{
  id *v1;

  v1 = *this;
  if (v1)
  {
    Phase::Controller::ListenerHeadTrackerImpl::~ListenerHeadTrackerImpl(v1);
    MEMORY[0x2199F9D70]();
  }
}

double Phase::Controller::ListenerHeadTrackerImpl::UpdateAndGetLatest(id *a1, _OWORD *a2)
{
  float v3;
  float v4;
  float v5;
  float v6;
  double result;
  __int128 v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  double v20[4];
  __int128 v21;
  _BYTE v22[32];
  int v23;

  v21 = xmmword_2166F7280;
  if (!objc_msgSend(*a1, "_currentAudioListenerPose:timestamp:", v20, 0))
  {
    v3 = v20[1];
    v4 = v20[2];
    v5 = v20[0];
    v6 = v20[3];
    *(float *)&v21 = v3;
    *((float *)&v21 + 1) = -v4;
    *((float *)&v21 + 2) = -v5;
    *((float *)&v21 + 3) = v6;
  }
  Phase::Matrix33From<float>((float *)&v21, (float *)v22);
  v9 = *(_QWORD *)v22;
  v10 = *(_DWORD *)&v22[8];
  v11 = 0;
  v12 = *(_QWORD *)&v22[12];
  v13 = *(_DWORD *)&v22[20];
  v14 = 0;
  v15 = *(_QWORD *)&v22[24];
  v16 = v23;
  v18 = 0;
  v17 = 0;
  v19 = 1065353216;
  Phase::AffineFrom<float>((float *)&v9, (uint64_t)v22);
  result = *(double *)v22;
  v8 = *(_OWORD *)&v22[16];
  *a2 = *(_OWORD *)v22;
  a2[1] = v8;
  return result;
}

id *Phase::Controller::ListenerHeadTrackerImpl::ListenerHeadTrackerImpl(id *this)
{
  void *v2;
  objc_class *v3;
  id v4;
  void *v5;
  objc_class *v6;
  uint64_t v7;
  id v8;
  uint64_t v10;
  uint64_t v11;
  Class (*v12)(uint64_t);
  void *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  *this = 0;
  v15 = 0;
  v16 = &v15;
  v17 = 0x2050000000;
  v2 = (void *)_MergedGlobals_17;
  v18 = _MergedGlobals_17;
  if (!_MergedGlobals_17)
  {
    v10 = MEMORY[0x24BDAC760];
    v11 = 3221225472;
    v12 = ___ZL29getRMMediaSessionOptionsClassv_block_invoke;
    v13 = &unk_24D57E8F0;
    v14 = &v15;
    ___ZL29getRMMediaSessionOptionsClassv_block_invoke((uint64_t)&v10);
    v2 = (void *)v16[3];
  }
  v3 = objc_retainAutorelease(v2);
  _Block_object_dispose(&v15, 8);
  v4 = [v3 alloc];
  objc_msgSend(v4, "setPredictionIntervalMicroseconds:", 100000);
  objc_msgSend(v4, "setClientMode:", 0);
  v15 = 0;
  v16 = &v15;
  v17 = 0x2050000000;
  v5 = (void *)qword_254E44900;
  v18 = qword_254E44900;
  if (!qword_254E44900)
  {
    v10 = MEMORY[0x24BDAC760];
    v11 = 3221225472;
    v12 = ___ZL22getRMMediaSessionClassv_block_invoke;
    v13 = &unk_24D57E8F0;
    v14 = &v15;
    ___ZL22getRMMediaSessionClassv_block_invoke((uint64_t)&v10);
    v5 = (void *)v16[3];
  }
  v6 = objc_retainAutorelease(v5);
  _Block_object_dispose(&v15, 8);
  v7 = objc_msgSend([v6 alloc], "_initWithOptions:", v4);
  v8 = *this;
  *this = (id)v7;

  objc_msgSend(*this, "_start");
  return this;
}

void sub_2165FFC28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  id *v7;
  void *v8;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

Class ___ZL29getRMMediaSessionOptionsClassv_block_invoke(uint64_t a1)
{
  Class result;

  if (!qword_254E448F8)
    qword_254E448F8 = _sl_dlopen();
  result = objc_getClass("RMMediaSessionOptions");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  _MergedGlobals_17 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

Class ___ZL22getRMMediaSessionClassv_block_invoke(uint64_t a1)
{
  Class result;

  if (!qword_254E448F8)
    qword_254E448F8 = _sl_dlopen();
  result = objc_getClass("RMMediaSession");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  qword_254E44900 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void Phase::Controller::ListenerHeadTrackerImpl::~ListenerHeadTrackerImpl(id *this)
{
  id v2;

  objc_msgSend(*this, "_stop");
  v2 = *this;
  *this = 0;

}

float Phase::AffineFrom<float>@<S0>(float *a1@<X0>, uint64_t a2@<X8>)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float result;
  NSObject *v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  std::runtime_error *v53;
  NSObject *v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  double v60;
  double v61;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double v68;
  double v69;
  double v70;
  std::runtime_error *exception;
  float v72[9];
  _BYTE buf[18];
  __int16 v74;
  double v75;
  __int16 v76;
  double v77;
  __int16 v78;
  double v79;
  __int16 v80;
  double v81;
  __int16 v82;
  double v83;
  __int16 v84;
  double v85;
  __int16 v86;
  double v87;
  __int16 v88;
  double v89;
  __int16 v90;
  double v91;
  __int16 v92;
  double v93;
  __int16 v94;
  double v95;
  __int16 v96;
  double v97;
  __int16 v98;
  double v99;
  __int16 v100;
  double v101;
  __int16 v102;
  double v103;
  __int16 v104;
  double v105;
  uint64_t v106;

  v106 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)a2 = xmmword_2166F7280;
  *(_DWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 28) = 1065353216;
  v5 = *a1;
  v4 = a1[1];
  v6 = a1[2];
  v8 = a1[4];
  v7 = a1[5];
  v9 = a1[6];
  v11 = a1[8];
  v10 = a1[9];
  v12 = a1[10];
  v13 = sqrtf((float)((float)(v5 * v5) + (float)(v4 * v4)) + (float)(v6 * v6));
  v14 = sqrtf((float)((float)(v8 * v8) + (float)(v7 * v7)) + (float)(v9 * v9));
  v15 = sqrtf((float)((float)(v11 * v11) + (float)(v10 * v10)) + (float)(v12 * v12));
  v16 = fmaxf(fmaxf(v13, v14), v15) * 0.001;
  v17 = v13 - v14;
  if ((float)(v13 - v14) < 0.0)
    v17 = -(float)(v13 - v14);
  if (v17 > v16)
    goto LABEL_20;
  v18 = v13 - v15;
  if ((float)(v13 - v15) < 0.0)
    v18 = -(float)(v13 - v15);
  if (v18 > v16)
  {
LABEL_20:
    v54 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr((Phase::Logger *)a1) + 96));
    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
    {
      v55 = *a1;
      v56 = a1[1];
      v57 = a1[2];
      v58 = a1[3];
      v59 = a1[4];
      v60 = a1[5];
      v61 = a1[6];
      v62 = a1[7];
      v63 = a1[8];
      v64 = a1[9];
      v65 = a1[10];
      v66 = a1[11];
      v67 = a1[12];
      v68 = a1[13];
      v69 = a1[14];
      v70 = a1[15];
      *(_DWORD *)buf = 136319490;
      *(_QWORD *)&buf[4] = "AffineFunctions.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 71;
      v74 = 2048;
      v75 = v55;
      v76 = 2048;
      v77 = v56;
      v78 = 2048;
      v79 = v57;
      v80 = 2048;
      v81 = v58;
      v82 = 2048;
      v83 = v59;
      v84 = 2048;
      v85 = v60;
      v86 = 2048;
      v87 = v61;
      v88 = 2048;
      v89 = v62;
      v90 = 2048;
      v91 = v63;
      v92 = 2048;
      v93 = v64;
      v94 = 2048;
      v95 = v65;
      v96 = 2048;
      v97 = v66;
      v98 = 2048;
      v99 = v67;
      v100 = 2048;
      v101 = v68;
      v102 = 2048;
      v103 = v69;
      v104 = 2048;
      v105 = v70;
      _os_log_impl(&dword_2164CC000, v54, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [!IsNearlyEqual(len0, len1, uniformScalingEpsilon) || !IsNearlyEqual(len0, len2, uniformScalingEpsilon) is true]: \"Matrix 4x4 passed into AffineFrom() does not have uniform scale: [%f, %f, %f, %f], [%f, %f, %f, %f], [%f, %f, %f, \" \"%f], [%f, %f, %f, %f]\"", buf, 0xB2u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Matrix 4x4 passed into AffineFrom() does not have uniform scale: [%f, %f, %f, %f], [%f, %f, %f, %f], [%f, %f, %f, %f], [%f, %f, %f, %f]");
  }
  *(float *)(a2 + 28) = (float)((float)(v13 + v14) + v15) / 3.0;
  v19 = 1.0 / v13;
  v20 = v5 * v19;
  v21 = v4 * v19;
  v72[0] = v20;
  v72[1] = v21;
  v22 = v6 * v19;
  v23 = 1.0 / v14;
  v24 = v8 * v23;
  v72[2] = v22;
  v72[3] = v24;
  v25 = v7 * v23;
  v26 = v9 * v23;
  v72[4] = v25;
  v72[5] = v26;
  v27 = 1.0 / v15;
  v28 = v11 * v27;
  v29 = v10 * v27;
  v72[6] = v28;
  v72[7] = v29;
  v30 = v12 * v27;
  v72[8] = v30;
  v31 = (float)(v22 * v26) + (float)((float)(v20 * v24) + (float)(v21 * v25));
  v32 = -v31;
  if (v31 >= 0.0)
    v32 = (float)(v22 * v26) + (float)((float)(v20 * v24) + (float)(v21 * v25));
  if (v32 > 0.017)
    goto LABEL_17;
  v33 = (float)(v22 * v30) + (float)((float)(v20 * v28) + (float)(v21 * v29));
  if (v33 < 0.0)
    v33 = -v33;
  if (v33 > 0.017)
    goto LABEL_17;
  v34 = (float)(v26 * v30) + (float)((float)(v24 * v28) + (float)(v25 * v29));
  if (v34 < 0.0)
    v34 = -v34;
  if (v34 > 0.017)
  {
LABEL_17:
    v36 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr((Phase::Logger *)a1) + 96));
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      v37 = *a1;
      v38 = a1[1];
      v39 = a1[2];
      v40 = a1[3];
      v41 = a1[4];
      v42 = a1[5];
      v43 = a1[6];
      v44 = a1[7];
      v45 = a1[8];
      v46 = a1[9];
      v47 = a1[10];
      v48 = a1[11];
      v49 = a1[12];
      v50 = a1[13];
      v51 = a1[14];
      v52 = a1[15];
      *(_DWORD *)buf = 136319490;
      *(_QWORD *)&buf[4] = "AffineFunctions.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 94;
      v74 = 2048;
      v75 = v37;
      v76 = 2048;
      v77 = v38;
      v78 = 2048;
      v79 = v39;
      v80 = 2048;
      v81 = v40;
      v82 = 2048;
      v83 = v41;
      v84 = 2048;
      v85 = v42;
      v86 = 2048;
      v87 = v43;
      v88 = 2048;
      v89 = v44;
      v90 = 2048;
      v91 = v45;
      v92 = 2048;
      v93 = v46;
      v94 = 2048;
      v95 = v47;
      v96 = 2048;
      v97 = v48;
      v98 = 2048;
      v99 = v49;
      v100 = 2048;
      v101 = v50;
      v102 = 2048;
      v103 = v51;
      v104 = 2048;
      v105 = v52;
      _os_log_impl(&dword_2164CC000, v36, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [!IsNearlyEqual(dot1, T(0), orthogonalityEpsilon) || !IsNearlyEqual(dot2, T(0), orthogonalityEpsilon) || !IsNearlyEqual(dot3, T(0), orthogonalityEpsilon) is true]: \"Matrix 4x4 passed into AffineFrom() is not orthogonal: [%f, %f, %f, %f], [%f, %f, %f, %f], [%f, %f, %f, %f], [%f, %f, %f, %f]\"", buf, 0xB2u);
    }
    v53 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v53, "Matrix 4x4 passed into AffineFrom() is not orthogonal: [%f, %f, %f, %f], [%f, %f, %f, %f], [%f, %f, %f, %f], [%f, %f, %f, %f]");
  }
  Phase::QuaternionFromMatrix33<float>(v72, (float *)buf);
  *(_OWORD *)a2 = *(_OWORD *)buf;
  result = a1[14];
  *(_QWORD *)(a2 + 16) = *((_QWORD *)a1 + 6);
  *(float *)(a2 + 24) = result;
  return result;
}

void sub_21660034C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

float Phase::QuaternionFromMatrix33<float>@<S0>(float *a1@<X0>, float *a2@<X8>)
{
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float result;

  v2 = a1[8];
  v3 = *a1;
  v4 = a1[4];
  if (v2 >= 0.0)
  {
    v7 = a1[1] - a1[3];
    if (v3 >= (float)-v4)
    {
      v8 = v2 + (float)((float)(v3 + 1.0) + v4);
      v5 = a1[5] - a1[7];
      v9 = a1[6] - a1[2];
      v6 = v8;
    }
    else
    {
      v6 = v2 + (float)((float)(1.0 - v3) - v4);
      v5 = a1[6] + a1[2];
      v9 = a1[5] + a1[7];
      v8 = a1[1] - a1[3];
      v7 = v6;
    }
  }
  else
  {
    v5 = a1[1] + a1[3];
    if (v3 <= v4)
    {
      v9 = (float)((float)(1.0 - v3) + v4) - v2;
      v7 = a1[5] + a1[7];
      v8 = a1[6] - a1[2];
      v6 = v9;
    }
    else
    {
      v6 = (float)((float)(v3 + 1.0) - v4) - v2;
      v7 = a1[6] + a1[2];
      v8 = a1[5] - a1[7];
      v9 = a1[1] + a1[3];
      v5 = v6;
    }
  }
  v10 = 0.5 / sqrtf(v6);
  *a2 = v5 * v10;
  a2[1] = v9 * v10;
  result = v7 * v10;
  a2[2] = result;
  a2[3] = v8 * v10;
  return result;
}

Phase::Controller::ListenerManager *Phase::Controller::ListenerManager::ListenerManager(Phase::Controller::ListenerManager *this, const Phase::Controller::TaskManager *a2)
{
  uint64_t InstancePtr;

  InstancePtr = Phase::Logger::GetInstancePtr(this);
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::Commandable((uint64_t)this, *(_QWORD *)(InstancePtr + 1040), 1, 0x20000);
  *(_QWORD *)this = off_24D57E938;
  *((_QWORD *)this + 5) = Phase::Controller::TaskManager::GetService<Phase::Geometry::System>(a2, 2);
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_DWORD *)this + 20) = 1065353216;
  *((_QWORD *)this + 11) = 0;
  return this;
}

void sub_2166004F0(_Unwind_Exception *a1)
{
  _QWORD *v1;

  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::~Commandable(v1);
  _Unwind_Resume(a1);
}

void Phase::Controller::ListenerManager::Update(id ***this, float a2)
{
  uint64_t **v3;
  char *v4;
  id **v5;
  Phase::Controller::ListenerHeadTracker *v6;
  uint64_t *i;
  __int128 v8;
  _OWORD v9[2];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  int v13;
  uint64_t v14;
  int v15;

  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::ExecuteCommands((uint64_t)this);
  v12 = xmmword_2166F7280;
  v13 = 0;
  v14 = 0;
  v15 = 1065353216;
  v3 = (uint64_t **)(this + 8);
  v4 = (char *)(this + 8);
  do
  {
    v4 = *(char **)v4;
    if (!v4)
    {
      std::unique_ptr<Phase::Controller::ListenerHeadTracker>::reset[abi:ne180100](this + 11, 0);
      goto LABEL_8;
    }
  }
  while (!v4[64]);
  v5 = this[11];
  if (!v5)
  {
    v6 = (Phase::Controller::ListenerHeadTracker *)operator new();
    Phase::Controller::ListenerHeadTracker::ListenerHeadTracker(v6);
    std::unique_ptr<Phase::Controller::ListenerHeadTracker>::reset[abi:ne180100](this + 11, (id **)v6);
    v5 = this[11];
  }
  Phase::Controller::ListenerHeadTrackerImpl::UpdateAndGetLatest(*v5, &v12);
LABEL_8:
  for (i = *v3; i; i = (uint64_t *)*i)
  {
    v8 = *((_OWORD *)i + 3);
    v10 = *((_OWORD *)i + 2);
    v11 = v8;
    if (*((_BYTE *)i + 64))
    {
      Phase::operator*<float>((float32x2_t *)i + 4, (float *)&v12, (uint64_t)v9);
      v10 = v9[0];
      v11 = v9[1];
    }
    Phase::Geometry::SystemScheduler::UpdateTransform((uint64_t)(this[5] + 294), i[3], &v10);
  }
}

void sub_21660060C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199F9D70](v1, 0x20C4093837F09);
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::ListenerManager::AddListener(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  NSObject *v6;
  uint64_t result;
  Phase::Logger *InstancePtr;
  NSObject *v9;
  std::runtime_error *exception;
  BOOL v11;
  unint64_t v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  unint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v4 = **(_QWORD **)(a1 + 8);
  v12 = 0;
  v11 = 1;
  v5 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v4, 24, &v12, &v11);
  if (!v5)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v9 = objc_retainAutorelease(**(id **)(v4 + 48));
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v14 = "CommandQueue.hpp";
      v15 = 1024;
      v16 = 100;
      _os_log_impl(&dword_2164CC000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v11)
  {
    v6 = objc_retainAutorelease(**(id **)(v4 + 48));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v14 = "CommandQueue.hpp";
      v15 = 1024;
      v16 = 89;
      v17 = 2048;
      v18 = v12;
      v19 = 2048;
      v20 = 24;
      _os_log_impl(&dword_2164CC000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *v5 = &off_24D57E968;
  v5[1] = a1;
  v5[2] = a2;
  result = Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v4, 24);
  atomic_store(0, (unsigned __int8 *)(v4 + 40));
  return result;
}

void sub_216600820(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x216600740);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::ListenerManager::RemoveListener(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  NSObject *v6;
  uint64_t result;
  Phase::Logger *InstancePtr;
  NSObject *v9;
  std::runtime_error *exception;
  BOOL v11;
  unint64_t v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  unint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v4 = **(_QWORD **)(a1 + 8);
  v12 = 0;
  v11 = 1;
  v5 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v4, 24, &v12, &v11);
  if (!v5)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v9 = objc_retainAutorelease(**(id **)(v4 + 48));
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v14 = "CommandQueue.hpp";
      v15 = 1024;
      v16 = 100;
      _os_log_impl(&dword_2164CC000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v11)
  {
    v6 = objc_retainAutorelease(**(id **)(v4 + 48));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v14 = "CommandQueue.hpp";
      v15 = 1024;
      v16 = 89;
      v17 = 2048;
      v18 = v12;
      v19 = 2048;
      v20 = 24;
      _os_log_impl(&dword_2164CC000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *v5 = &off_24D57E990;
  v5[1] = a1;
  v5[2] = a2;
  result = Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v4, 24);
  atomic_store(0, (unsigned __int8 *)(v4 + 40));
  return result;
}

void sub_216600A70(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x216600990);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::ListenerManager::UpdateTransform(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v5;
  _DWORD *v6;
  NSObject *v7;
  uint64_t result;
  Phase::Logger *InstancePtr;
  NSObject *v10;
  std::runtime_error *exception;
  __int128 v12;
  __int128 v13;
  BOOL v14;
  unint64_t v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  unint64_t v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v12 = a3[1];
  v13 = *a3;
  v5 = **(_QWORD **)(a1 + 8);
  v15 = 0;
  v14 = 1;
  v6 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v5, 56, &v15, &v14);
  if (!v6)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v10 = objc_retainAutorelease(**(id **)(v5 + 48));
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v17 = "CommandQueue.hpp";
      v18 = 1024;
      v19 = 100;
      _os_log_impl(&dword_2164CC000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v14)
  {
    v7 = objc_retainAutorelease(**(id **)(v5 + 48));
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v17 = "CommandQueue.hpp";
      v18 = 1024;
      v19 = 89;
      v20 = 2048;
      v21 = v15;
      v22 = 2048;
      v23 = 56;
      _os_log_impl(&dword_2164CC000, v7, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *(_QWORD *)v6 = &off_24D57E9B8;
  *((_QWORD *)v6 + 1) = a1;
  *((_QWORD *)v6 + 2) = a2;
  *(_OWORD *)(v6 + 6) = v13;
  *(_OWORD *)(v6 + 10) = v12;
  result = Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v5, 56);
  atomic_store(0, (unsigned __int8 *)(v5 + 40));
  return result;
}

void sub_216600CD8(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x216600BF8);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::ListenerManager::SetTracking(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6;
  _DWORD *v7;
  NSObject *v8;
  uint64_t result;
  Phase::Logger *InstancePtr;
  NSObject *v11;
  std::runtime_error *exception;
  BOOL v13;
  unint64_t v14;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unint64_t v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v6 = **(_QWORD **)(a1 + 8);
  v14 = 0;
  v13 = 1;
  v7 = Phase::LockFreeQueueMPSC::GetWriteBuffer((Phase::LockFreeQueueMPSC *)v6, 32, &v14, &v13);
  if (!v7)
  {
    InstancePtr = (Phase::Logger *)Phase::Logger::GetInstancePtr(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(InstancePtr, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    v11 = objc_retainAutorelease(**(id **)(v6 + 48));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v16 = "CommandQueue.hpp";
      v17 = 1024;
      v18 = 100;
      _os_log_impl(&dword_2164CC000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v13)
  {
    v8 = objc_retainAutorelease(**(id **)(v6 + 48));
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      v16 = "CommandQueue.hpp";
      v17 = 1024;
      v18 = 89;
      v19 = 2048;
      v20 = v14;
      v21 = 2048;
      v22 = 32;
      _os_log_impl(&dword_2164CC000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *(_QWORD *)v7 = &off_24D57E9E0;
  *((_QWORD *)v7 + 1) = a1;
  *((_QWORD *)v7 + 2) = a2;
  *((_BYTE *)v7 + 24) = a3;
  result = Phase::LockFreeQueueSPSC::CommitBytes((Phase::LockFreeQueueSPSC *)v6, 32);
  atomic_store(0, (unsigned __int8 *)(v6 + 40));
  return result;
}

void sub_216600F30(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;
  void *v3;

  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x216600E50);
  }
  _Unwind_Resume(exception_object);
}

void Phase::Controller::ListenerManager::~ListenerManager(id ***this)
{
  Phase::Controller::ListenerManager::~ListenerManager(this);
  JUMPOUT(0x2199F9D70);
}

{
  id **v2;
  id **v3;
  id **v4;

  *this = (id **)off_24D57E938;
  std::unique_ptr<Phase::Controller::ListenerHeadTracker>::reset[abi:ne180100](this + 11, 0);
  v2 = this[8];
  if (v2)
  {
    do
    {
      v3 = (id **)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = this[6];
  this[6] = 0;
  if (v4)
    operator delete(v4);
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::~Commandable(this);
}

id **std::unique_ptr<Phase::Controller::ListenerHeadTracker>::reset[abi:ne180100](id ***a1, id **a2)
{
  id **result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    Phase::Controller::ListenerHeadTracker::~ListenerHeadTracker(result);
    JUMPOUT(0x2199F9D70);
  }
  return result;
}

void Phase::LambdaFunction<Phase::Controller::ListenerManager::AddListener(Phase::Handle64)::$_0,void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

double Phase::LambdaFunction<Phase::Controller::ListenerManager::AddListener(Phase::Handle64)::$_0,void>::operator()(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  uint64_t v3;
  void **v4;
  double result;
  unint64_t v6;
  uint8x8_t v7;
  void **v8;
  char *v9;
  unint64_t v10;
  float v11;
  float v12;
  _BOOL8 v13;
  unint64_t v14;
  unint64_t v15;
  int8x8_t prime;
  void *v17;
  void *v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;
  uint8x8_t v22;
  unint64_t v23;
  uint8x8_t v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  unint64_t v30;
  void *v31;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  v4 = (void **)(v3 + 48);
  if (std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((_QWORD *)(v3 + 48), v2))
  {
    return result;
  }
  v6 = *(_QWORD *)(v3 + 56);
  if (v6)
  {
    v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      v1 = v2;
      if (v6 <= v2)
        v1 = v2 % v6;
    }
    else
    {
      v1 = (v6 - 1) & v2;
    }
    v8 = (void **)*((_QWORD *)*v4 + v1);
    if (v8)
    {
      v9 = (char *)*v8;
      if (*v8)
      {
        do
        {
          v10 = *((_QWORD *)v9 + 1);
          if (v10 == v2)
          {
            if (*((_QWORD *)v9 + 2) == v2)
              goto LABEL_75;
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v10 >= v6)
                v10 %= v6;
            }
            else
            {
              v10 &= v6 - 1;
            }
            if (v10 != v1)
              break;
          }
          v9 = *(char **)v9;
        }
        while (v9);
      }
    }
  }
  v9 = (char *)operator new(0x48uLL);
  *(_QWORD *)v9 = 0;
  *((_QWORD *)v9 + 1) = v2;
  *((_QWORD *)v9 + 2) = v2;
  *(_OWORD *)(v9 + 40) = 0u;
  *(_OWORD *)(v9 + 56) = 0u;
  *(_OWORD *)(v9 + 24) = 0u;
  *((_DWORD *)v9 + 11) = 1065353216;
  *((_DWORD *)v9 + 15) = 1065353216;
  v11 = (float)(unint64_t)(*(_QWORD *)(v3 + 72) + 1);
  v12 = *(float *)(v3 + 80);
  if (!v6 || (float)(v12 * (float)v6) < v11)
  {
    v13 = 1;
    if (v6 >= 3)
      v13 = (v6 & (v6 - 1)) != 0;
    v14 = v13 | (2 * v6);
    v15 = vcvtps_u32_f32(v11 / v12);
    if (v14 <= v15)
      prime = (int8x8_t)v15;
    else
      prime = (int8x8_t)v14;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v6 = *(_QWORD *)(v3 + 56);
    }
    if (*(_QWORD *)&prime > v6)
      goto LABEL_31;
    if (*(_QWORD *)&prime < v6)
    {
      v23 = vcvtps_u32_f32((float)*(unint64_t *)(v3 + 72) / *(float *)(v3 + 80));
      if (v6 < 3 || (v24 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v24.i16[0] = vaddlv_u8(v24), v24.u32[0] > 1uLL))
      {
        v23 = std::__next_prime(v23);
      }
      else
      {
        v25 = 1 << -(char)__clz(v23 - 1);
        if (v23 >= 2)
          v23 = v25;
      }
      if (*(_QWORD *)&prime <= v23)
        prime = (int8x8_t)v23;
      if (*(_QWORD *)&prime >= v6)
      {
        v6 = *(_QWORD *)(v3 + 56);
      }
      else
      {
        if (prime)
        {
LABEL_31:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v17 = operator new(8 * *(_QWORD *)&prime);
          v18 = *v4;
          *v4 = v17;
          if (v18)
            operator delete(v18);
          v19 = 0;
          *(int8x8_t *)(v3 + 56) = prime;
          do
            *((_QWORD *)*v4 + v19++) = 0;
          while (*(_QWORD *)&prime != v19);
          v20 = *(_QWORD **)(v3 + 64);
          if (v20)
          {
            v21 = v20[1];
            v22 = (uint8x8_t)vcnt_s8(prime);
            v22.i16[0] = vaddlv_u8(v22);
            if (v22.u32[0] > 1uLL)
            {
              if (v21 >= *(_QWORD *)&prime)
                v21 %= *(_QWORD *)&prime;
            }
            else
            {
              v21 &= *(_QWORD *)&prime - 1;
            }
            *((_QWORD *)*v4 + v21) = v3 + 64;
            v26 = (_QWORD *)*v20;
            if (*v20)
            {
              do
              {
                v27 = v26[1];
                if (v22.u32[0] > 1uLL)
                {
                  if (v27 >= *(_QWORD *)&prime)
                    v27 %= *(_QWORD *)&prime;
                }
                else
                {
                  v27 &= *(_QWORD *)&prime - 1;
                }
                if (v27 != v21)
                {
                  if (!*((_QWORD *)*v4 + v27))
                  {
                    *((_QWORD *)*v4 + v27) = v20;
                    goto LABEL_56;
                  }
                  *v20 = *v26;
                  *v26 = **((_QWORD **)*v4 + v27);
                  **((_QWORD **)*v4 + v27) = v26;
                  v26 = v20;
                }
                v27 = v21;
LABEL_56:
                v20 = v26;
                v26 = (_QWORD *)*v26;
                v21 = v27;
              }
              while (v26);
            }
          }
          v6 = (unint64_t)prime;
          goto LABEL_60;
        }
        v31 = *v4;
        *v4 = 0;
        if (v31)
          operator delete(v31);
        v6 = 0;
        *(_QWORD *)(v3 + 56) = 0;
      }
    }
LABEL_60:
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v2)
        v1 = v2 % v6;
      else
        v1 = v2;
    }
    else
    {
      v1 = (v6 - 1) & v2;
    }
  }
  v28 = *v4;
  v29 = (_QWORD *)*((_QWORD *)*v4 + v1);
  if (v29)
  {
    *(_QWORD *)v9 = *v29;
  }
  else
  {
    *(_QWORD *)v9 = *(_QWORD *)(v3 + 64);
    *(_QWORD *)(v3 + 64) = v9;
    v28[v1] = v3 + 64;
    if (!*(_QWORD *)v9)
      goto LABEL_74;
    v30 = *(_QWORD *)(*(_QWORD *)v9 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v30 >= v6)
        v30 %= v6;
    }
    else
    {
      v30 &= v6 - 1;
    }
    v29 = (char *)*v4 + 8 * v30;
  }
  *v29 = v9;
LABEL_74:
  ++*(_QWORD *)(v3 + 72);
LABEL_75:
  *((_QWORD *)v9 + 3) = v2;
  result = 0.0;
  *((_OWORD *)v9 + 2) = xmmword_2166F7280;
  *((_OWORD *)v9 + 3) = xmmword_2166F7280;
  v9[64] = 0;
  return result;
}

void sub_216601414(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void Phase::LambdaFunction<Phase::Controller::ListenerManager::RemoveListener(Phase::Handle64)::$_0,void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

void Phase::LambdaFunction<Phase::Controller::ListenerManager::RemoveListener(Phase::Handle64)::$_0,void>::operator()(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t *v3;
  int8x8_t v4;
  uint64_t v5;
  unint64_t v6;
  uint8x8_t v7;
  uint64_t *v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;

  v1 = *(_QWORD **)(a1 + 8);
  v2 = v1 + 6;
  v3 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>(v1 + 6, *(_QWORD *)(a1 + 16));
  if (v3)
  {
    v4 = (int8x8_t)v1[7];
    v5 = *v3;
    v6 = v3[1];
    v7 = (uint8x8_t)vcnt_s8(v4);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      if (v6 >= *(_QWORD *)&v4)
        v6 %= *(_QWORD *)&v4;
    }
    else
    {
      v6 &= *(_QWORD *)&v4 - 1;
    }
    v8 = *(uint64_t **)(*v2 + 8 * v6);
    do
    {
      v9 = v8;
      v8 = (uint64_t *)*v8;
    }
    while (v8 != v3);
    if (v9 == v1 + 8)
      goto LABEL_20;
    v10 = v9[1];
    if (v7.u32[0] > 1uLL)
    {
      if (v10 >= *(_QWORD *)&v4)
        v10 %= *(_QWORD *)&v4;
    }
    else
    {
      v10 &= *(_QWORD *)&v4 - 1;
    }
    if (v10 != v6)
    {
LABEL_20:
      if (v5)
      {
        v11 = *(_QWORD *)(v5 + 8);
        if (v7.u32[0] > 1uLL)
        {
          v12 = *(_QWORD *)(v5 + 8);
          if (v11 >= *(_QWORD *)&v4)
            v12 = v11 % *(_QWORD *)&v4;
        }
        else
        {
          v12 = v11 & (*(_QWORD *)&v4 - 1);
        }
        if (v12 == v6)
          goto LABEL_24;
      }
      *(_QWORD *)(*v2 + 8 * v6) = 0;
      v5 = *v3;
    }
    if (!v5)
    {
LABEL_30:
      *v9 = v5;
      *v3 = 0;
      --v1[9];
      operator delete(v3);
      return;
    }
    v11 = *(_QWORD *)(v5 + 8);
LABEL_24:
    if (v7.u32[0] > 1uLL)
    {
      if (v11 >= *(_QWORD *)&v4)
        v11 %= *(_QWORD *)&v4;
    }
    else
    {
      v11 &= *(_QWORD *)&v4 - 1;
    }
    if (v11 != v6)
    {
      *(_QWORD *)(*v2 + 8 * v11) = v9;
      v5 = *v3;
    }
    goto LABEL_30;
  }
}

void Phase::LambdaFunction<Phase::Controller::ListenerManager::UpdateTransform(Phase::Handle64,Phase::Affine<float> const&)::$_0,void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

float Phase::LambdaFunction<Phase::Controller::ListenerManager::UpdateTransform(Phase::Handle64,Phase::Affine<float> const&)::$_0,void>::operator()(uint64_t a1)
{
  _QWORD *v2;
  float result;

  v2 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((_QWORD *)(*(_QWORD *)(a1 + 8) + 48), *(_QWORD *)(a1 + 16));
  if (!v2)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  *((_DWORD *)v2 + 8) = *(_DWORD *)(a1 + 24);
  *((_DWORD *)v2 + 9) = *(_DWORD *)(a1 + 28);
  *((_DWORD *)v2 + 10) = *(_DWORD *)(a1 + 32);
  *((_DWORD *)v2 + 11) = *(_DWORD *)(a1 + 36);
  *((_DWORD *)v2 + 12) = *(_DWORD *)(a1 + 40);
  *((_DWORD *)v2 + 13) = *(_DWORD *)(a1 + 44);
  *((_DWORD *)v2 + 14) = *(_DWORD *)(a1 + 48);
  result = *(float *)(a1 + 52);
  *((float *)v2 + 15) = result;
  return result;
}

void Phase::LambdaFunction<Phase::Controller::ListenerManager::SetTracking(Phase::Handle64,BOOL)::$_0,void>::~LambdaFunction()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *Phase::LambdaFunction<Phase::Controller::ListenerManager::SetTracking(Phase::Handle64,BOOL)::$_0,void>::operator()(uint64_t a1)
{
  _QWORD *result;

  result = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((_QWORD *)(*(_QWORD *)(a1 + 8) + 48), *(_QWORD *)(a1 + 16));
  if (!result)
    std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  *((_BYTE *)result + 64) = *(_BYTE *)(a1 + 24);
  return result;
}

Phase::Controller::LoadBalancer *Phase::Controller::LoadBalancer::LoadBalancer(Phase::Controller::LoadBalancer *this, const char **a2, Phase::Controller::VoiceManager *a3, Phase::Controller::ProfileRegistry *a4, Phase::Geometry::System *a5)
{
  uint64_t InstancePtr;
  const char **v11;
  Phase::Logger *v17;
  const char *v18;
  const char *v19;
  NSObject *v21;
  std::runtime_error *exception;
  int v23;
  const char *v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  InstancePtr = Phase::Logger::GetInstancePtr(this);
  v11 = (const char **)Phase::Commandable<128,Phase::LockFreeQueueMPSC>::Commandable((uint64_t)this, *(_QWORD *)(InstancePtr + 800), 1, 0x20000);
  *(_QWORD *)this = off_24D57EA08;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = &str_33;
  *((_BYTE *)this + 56) = 1;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = &str_33;
  *((_BYTE *)this + 168) = 1;
  *((_BYTE *)this + 216) = 0;
  *((_OWORD *)this + 14) = xmmword_216738CD0;
  *((_QWORD *)this + 30) = a3;
  *((_QWORD *)this + 31) = a4;
  *((_QWORD *)this + 32) = a5;
  *((_QWORD *)this + 33) = 850045863;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_QWORD *)this + 40) = 0;
  *(_OWORD *)((char *)this + 72) = xmmword_2166F7470;
  __asm { FMOV            V1.2D, #1.0 }
  *(_OWORD *)((char *)this + 88) = _Q1;
  *((_BYTE *)this + 104) = 0;
  *((_OWORD *)this + 7) = xmmword_2166F7470;
  *((_OWORD *)this + 8) = _Q1;
  *((_BYTE *)this + 144) = 0;
  *((_OWORD *)this + 11) = xmmword_2166F7470;
  *((_OWORD *)this + 12) = _Q1;
  *((_BYTE *)this + 208) = 0;
  Phase::Controller::LoadBalancer::SetProfile(v11, (const Phase::StringId *)a2);
  if (*((const char **)this + 5) != *a2
    || (v18 = (const char *)*((_QWORD *)this + 6), v19 = a2[1], v18 != v19)
    && (v17 = (Phase::Logger *)strcmp(v18, v19), (_DWORD)v17))
  {
    v21 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v17) + 800));
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      v23 = 136315394;
      v24 = "LoadBalancer.mm";
      v25 = 1024;
      v26 = 148;
      _os_log_impl(&dword_2164CC000, v21, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [mProfileId != inDefaultProfileId is true]: \"Failed to set default profile id.\"", (uint8_t *)&v23, 0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to set default profile id.");
  }
  Phase::Controller::LoadBalancer::Update(this);
  return this;
}

void sub_2166018D0(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;

  __cxa_free_exception(v2);
  std::mutex::~mutex((std::mutex *)(v1 + 264));
  if (!*(_BYTE *)(v1 + 168))
    free(*(void **)(v1 + 160));
  *(_QWORD *)(v1 + 152) = 0;
  *(_QWORD *)(v1 + 160) = v3;
  *(_BYTE *)(v1 + 168) = 1;
  if (!*(_BYTE *)(v1 + 56))
    free(*(void **)(v1 + 48));
  *(_QWORD *)(v1 + 40) = 0;
  *(_QWORD *)(v1 + 48) = v3;
  *(_BYTE *)(v1 + 56) = 1;
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::~Commandable((_QWORD *)v1);
  _Unwind_Resume(a1);
}

void Phase::Controller::LoadBalancer::SetProfile(const char **this, const Phase::StringId *a2)
{
  _BYTE *v4;
  Phase::Logger *v5;
  const char *v6;
  const char *v7;
  NSObject *v8;
  const char *v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  const char *v13;
  int v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  Phase::Controller::LoadBalancer *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  if ((!*(_QWORD *)a2 || *(_QWORD *)a2 == -1)
    && ((v4 = (_BYTE *)*((_QWORD *)a2 + 1), v4 == (_BYTE *)&str_33) || !*v4))
  {
    v11 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr((Phase::Logger *)this) + 800));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v14 = 136315650;
      v15 = "LoadBalancer.mm";
      v16 = 1024;
      v17 = 177;
      v18 = 2048;
      v19 = (Phase::Controller::LoadBalancer *)this;
      _os_log_impl(&dword_2164CC000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d loadbalancer@%p: inProfile is invalid or empty. Not setting profile.", (uint8_t *)&v14, 0x1Cu);
    }
  }
  else
  {
    v5 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<Phase::StringId,Phase::Controller::ProfileRegistry::Profile>,std::__unordered_map_hasher<Phase::StringId,std::__hash_value_type<Phase::StringId,Phase::Controller::ProfileRegistry::Profile>,std::hash<Phase::StringId>,std::equal_to<Phase::StringId>,true>,std::__unordered_map_equal<Phase::StringId,std::__hash_value_type<Phase::StringId,Phase::Controller::ProfileRegistry::Profile>,std::equal_to<Phase::StringId>,std::hash<Phase::StringId>,true>,std::allocator<std::__hash_value_type<Phase::StringId,Phase::Controller::ProfileRegistry::Profile>>>::find<Phase::StringId>(this[31], (unint64_t *)a2);
    if (v5)
    {
      if (*(const char **)a2 != this[5]
        || (v6 = (const char *)*((_QWORD *)a2 + 1), v7 = this[6], v6 != v7)
        && (v5 = (Phase::Logger *)strcmp(v6, v7), (_DWORD)v5))
      {
        v8 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v5)
                                                                                           + 800)));
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          v9 = this[6];
          v10 = *((_QWORD *)a2 + 1);
          v14 = 136316162;
          v15 = "LoadBalancer.mm";
          v16 = 1024;
          v17 = 192;
          v18 = 2048;
          v19 = (Phase::Controller::LoadBalancer *)this;
          v20 = 2080;
          v21 = v9;
          v22 = 2080;
          v23 = v10;
          _os_log_impl(&dword_2164CC000, v8, OS_LOG_TYPE_DEFAULT, "%25s:%-5d loadbalancer@%p: Profile changed from '%s' to '%s'", (uint8_t *)&v14, 0x30u);
        }

        Phase::StringId::operator=((uint64_t)(this + 5), (uint64_t)a2);
        if (!*((_BYTE *)this + 216))
          this[29] = (const char *)((unint64_t)this[29] | 1);
      }
    }
    else
    {
      v12 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(0)
                                                                                          + 800)));
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        v13 = (const char *)*((_QWORD *)a2 + 1);
        v14 = 136315906;
        v15 = "LoadBalancer.mm";
        v16 = 1024;
        v17 = 185;
        v18 = 2048;
        v19 = (Phase::Controller::LoadBalancer *)this;
        v20 = 2080;
        v21 = v13;
        _os_log_impl(&dword_2164CC000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d loadbalancer@%p: Failed to find a profile with name '%s' in the profile registry. Not setting profile.", (uint8_t *)&v14, 0x26u);
      }

    }
  }
}

void Phase::Controller::LoadBalancer::Update(Phase::Controller::LoadBalancer *this)
{
  uint64_t v2;
  uint64_t v3;
  long double v4;
  Phase::Logger *v5;
  double v6;
  uint64_t v7;
  char *v8;
  double v9;
  Phase::Logger *v10;
  _QWORD *i;
  Phase::Logger *v12;
  Phase::Logger *v13;
  _QWORD *j;
  uint64_t ComputeTime;
  char v16;
  double *v17;
  double v18;
  double v19;
  double *v20;
  double v21;
  _QWORD *k;
  uint64_t v23;
  __int128 v24;
  char *v25;
  double v26;
  Phase::Logger *v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  __int128 v31;
  char v32;
  void *v33[2];
  _QWORD *v34;
  uint64_t v35;
  void *__p[3];
  uint64_t v37[2];
  _QWORD *v38;
  uint64_t v39;
  char v40[8];
  void *v41;
  char v42;
  uint64_t v43;
  std::__shared_weak_count *v44;

  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::ExecuteCommands((uint64_t)this);
  Phase::Geometry::System::GetCurrentState(*((Phase::Geometry::System **)this + 32), &v43);
  if (v43)
  {
    v2 = *(_QWORD *)(v43 + 936);
    v3 = v2 & ~(v2 >> 63);
    if (v3 != *((_QWORD *)this + 8))
    {
      if (v2 <= 1)
        v2 = 1;
      v4 = pow(1.0 - 1.0 / (double)v2, 10000.0);
      v6 = Phase::Controller::sClamp<double>(v5, 1.0 - v4, *((double *)this + 9), *((double *)this + 10));
      if (v6 == *((double *)this + 12))
      {
        if (!*((_BYTE *)this + 104))
        {
LABEL_10:
          *((_QWORD *)this + 8) = v3;
          goto LABEL_11;
        }
      }
      else
      {
        *((double *)this + 12) = v6;
      }
      *((_BYTE *)this + 104) = 0;
      if (!*((_BYTE *)this + 216))
        *((_QWORD *)this + 29) |= 2uLL;
      goto LABEL_10;
    }
  }
LABEL_11:
  v7 = *((_QWORD *)this + 29);
  if ((v7 & 1) != 0)
  {
    if (*((_BYTE *)this + 216))
      v8 = (char *)this + 152;
    else
      v8 = (char *)this + 40;
    Phase::StringId::StringId((uint64_t)v40, (uint64_t)v8);
    if (*((_BYTE *)this + 216))
      v9 = *((double *)this + 25);
    else
      v9 = fmin(fmax(*((double *)this + 12) * *((double *)this + 17), 0.0), 1.0);
    Phase::Controller::ProfileRegistry::GetModelers(*((Phase::Controller::ProfileRegistry **)this + 31), (const Phase::StringId *)v40, v37);
    if ((*(_BYTE *)(*(_QWORD *)(Phase::Logger::GetInstancePtr(v10) + 800) + 8) & 1) != 0)
    {
      if (v39)
      {
        for (i = v38; i; i = (_QWORD *)*i)
          ;
      }
    }
    Phase::Controller::ProfileRegistry::GetParameters(*((Phase::Controller::ProfileRegistry **)this + 31), (const Phase::StringId *)v40, v9, __p);
    Phase::Logger::GetInstancePtr(v12);
    Phase::Controller::SpatialModelerSystem::SetModelers((Phase::Logger *)(**((_QWORD **)this + 30) + 560), (uint64_t)v37, (uint64_t *)__p);
    Phase::Controller::ProfileRegistry::GetComputeWeights(*((Phase::Controller::ProfileRegistry **)this + 31), (const Phase::StringId *)v40, (uint64_t)v33);
    if ((*(_BYTE *)(*(_QWORD *)(Phase::Logger::GetInstancePtr(v13) + 800) + 8) & 1) != 0)
    {
      if (v35)
      {
        for (j = v34; j; j = (_QWORD *)*j)
          ;
      }
    }
    ComputeTime = Phase::Controller::ProfileRegistry::GetComputeTime(*((Phase::Controller::ProfileRegistry **)this + 31), (const Phase::StringId *)v40);
    v17 = (double *)v34;
    if (v34)
    {
      v18 = *(double *)&ComputeTime;
      v19 = 0.0;
      v20 = (double *)v34;
      do
      {
        v19 = v19 + v20[3];
        v20 = *(double **)v20;
      }
      while (v20);
      if (!v16)
        v18 = 1.79769313e308;
      v21 = v18 / v19;
      do
      {
        v17[3] = v21 * v17[3];
        v17 = *(double **)v17;
      }
      while (v17);
    }
    Phase::Controller::SpatialModelerSystem::SetComputeTimes((Phase::Logger *)(**((_QWORD **)this + 30) + 560), (uint64_t)v33);
    Phase::Controller::ProfileRegistry::GetOverflowParameters(*((Phase::Controller::ProfileRegistry **)this + 31), (const Phase::StringId *)v40, (uint64_t)&v31);
    if (v32)
    {
      for (k = *(_QWORD **)(**((_QWORD **)this + 30) + 576); k; k = (_QWORD *)*k)
      {
        v23 = k[3];
        v24 = v31;
        *(_OWORD *)(v23 + 136) = v31;
        *(_OWORD *)(*(_QWORD *)(v23 + 80) + 320) = v24;
      }
    }
    *((_QWORD *)this + 29) &= 0xFFFFFFFFFFFFFFFCLL;
    std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)v33);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)v37);
    if (!v42)
      free(v41);
    v7 = *((_QWORD *)this + 29);
  }
  if ((v7 & 2) != 0)
  {
    if (*((_BYTE *)this + 216))
      v25 = (char *)this + 152;
    else
      v25 = (char *)this + 40;
    Phase::StringId::StringId((uint64_t)v37, (uint64_t)v25);
    if (*((_BYTE *)this + 216))
      v26 = *((double *)this + 25);
    else
      v26 = fmin(fmax(*((double *)this + 12) * *((double *)this + 17), 0.0), 1.0);
    Phase::Controller::ProfileRegistry::GetParameters(*((Phase::Controller::ProfileRegistry **)this + 31), (const Phase::StringId *)v37, v26, v33);
    Phase::Logger::GetInstancePtr(v27);
    Phase::Controller::SpatialModelerSystem::SetParameters((unsigned __int8 *)(**((_QWORD **)this + 30) + 560), (uint64_t *)v33);
    *((_QWORD *)this + 29) &= ~2uLL;
    if (v33[0])
    {
      v33[1] = v33[0];
      operator delete(v33[0]);
    }
    if (!(_BYTE)v38)
      free((void *)v37[1]);
  }
  v28 = v44;
  if (v44)
  {
    p_shared_owners = (unint64_t *)&v44->__shared_owners_;
    do
      v30 = __ldaxr(p_shared_owners);
    while (__stlxr(v30 - 1, p_shared_owners));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
}

void sub_216601F48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,char a21,void *a22,char a23)
{
  uint64_t v23;

  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](v23 - 48);
  _Unwind_Resume(a1);
}

void Phase::Controller::LoadBalancer::~LoadBalancer(Phase::Controller::LoadBalancer *this)
{
  std::mutex::~mutex((std::mutex *)((char *)this + 264));
  if (!*((_BYTE *)this + 168))
    free(*((void **)this + 20));
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = &str_33;
  *((_BYTE *)this + 168) = 1;
  if (!*((_BYTE *)this + 56))
    free(*((void **)this + 6));
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = &str_33;
  *((_BYTE *)this + 56) = 1;
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::~Commandable(this);
}

{
  Phase::Controller::LoadBalancer::~LoadBalancer(this);
  JUMPOUT(0x2199F9D70);
}

void Phase::Controller::LoadBalancer::SetProfileOverride(Phase::Controller::LoadBalancer *this, uint64_t a2, double a3)
{
  Phase::Logger *ProfileId;
  uint64_t v7;
  char *v8;
  NSObject *v9;
  char *v10;
  Phase::Logger *v11;
  double v12;
  NSObject *v13;
  NSObject *v14;
  char *v15;
  char *v16;
  unint64_t v17;
  char *__s1;
  char v19;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  Phase::Controller::LoadBalancer *v25;
  __int16 v26;
  char *v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  ProfileId = (Phase::Logger *)Phase::Controller::ProfileRegistry::FindProfileId(*((_QWORD *)this + 31), a2, (uint64_t)&v17);
  if (v17 && v17 != -1 || __s1 != (char *)&str_33 && *__s1)
  {
    v7 = (uint64_t)std::__hash_table<std::__hash_value_type<Phase::StringId,Phase::Controller::ProfileRegistry::Profile>,std::__unordered_map_hasher<Phase::StringId,std::__hash_value_type<Phase::StringId,Phase::Controller::ProfileRegistry::Profile>,std::hash<Phase::StringId>,std::equal_to<Phase::StringId>,true>,std::__unordered_map_equal<Phase::StringId,std::__hash_value_type<Phase::StringId,Phase::Controller::ProfileRegistry::Profile>,std::equal_to<Phase::StringId>,std::hash<Phase::StringId>,true>,std::allocator<std::__hash_value_type<Phase::StringId,Phase::Controller::ProfileRegistry::Profile>>>::find<Phase::StringId>(*((_QWORD **)this + 31), &v17);
    if (!v7)
    {
      v14 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(0)
                                                                                          + 800)));
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315906;
        v21 = "LoadBalancer.mm";
        v22 = 1024;
        v23 = 274;
        v24 = 2048;
        v25 = this;
        v26 = 2080;
        v27 = __s1;
        _os_log_impl(&dword_2164CC000, v14, OS_LOG_TYPE_ERROR, "%25s:%-5d loadbalancer@%p: Failed to find a profile with name '%s' in the profile registry. Not overriding profile.", buf, 0x26u);
      }
      goto LABEL_23;
    }
    if (v17 != *((_QWORD *)this + 19)
      || (v7 = (uint64_t)__s1, v8 = (char *)*((_QWORD *)this + 20), __s1 != v8) && (v7 = strcmp(__s1, v8), (_DWORD)v7))
    {
      v9 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr((Phase::Logger *)v7)
                                                                                         + 800)));
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v10 = (char *)*((_QWORD *)this + 20);
        *(_DWORD *)buf = 136316162;
        v21 = "LoadBalancer.mm";
        v22 = 1024;
        v23 = 281;
        v24 = 2048;
        v25 = this;
        v26 = 2080;
        v27 = v10;
        v28 = 2080;
        v29 = __s1;
        _os_log_impl(&dword_2164CC000, v9, OS_LOG_TYPE_DEFAULT, "%25s:%-5d loadbalancer@%p: Overridden Profile changed from '%s' to '%s'", buf, 0x30u);
      }

      v7 = Phase::StringId::operator=((uint64_t)this + 152, (uint64_t)&v17);
      *((_QWORD *)this + 29) |= 1uLL;
    }
    v12 = Phase::Controller::sClamp<double>((Phase::Logger *)v7, a3, *((double *)this + 22), *((double *)this + 23));
    if (v12 == *((double *)this + 25))
    {
      if (!*((_BYTE *)this + 208))
        goto LABEL_21;
    }
    else
    {
      *((double *)this + 25) = v12;
      *((_BYTE *)this + 208) = 1;
    }
    *((_BYTE *)this + 208) = 0;
    *((_QWORD *)this + 29) |= 2uLL;
LABEL_21:
    *((_BYTE *)this + 216) = 1;
    v14 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v11)
                                                                                        + 800)));
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = (char *)*((_QWORD *)this + 20);
      v16 = (char *)*((_QWORD *)this + 25);
      *(_DWORD *)buf = 136316162;
      v21 = "LoadBalancer.mm";
      v22 = 1024;
      v23 = 301;
      v24 = 2048;
      v25 = this;
      v26 = 2080;
      v27 = v15;
      v28 = 2048;
      v29 = v16;
      _os_log_impl(&dword_2164CC000, v14, OS_LOG_TYPE_DEFAULT, "%25s:%-5d loadbalancer@%p: Overriding the Load Balancer with profile name: %s, balance: %f", buf, 0x30u);
    }
LABEL_23:

    goto LABEL_24;
  }
  v13 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(ProfileId) + 800));
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    v21 = "LoadBalancer.mm";
    v22 = 1024;
    v23 = 266;
    v24 = 2048;
    v25 = this;
    v26 = 2048;
    v27 = (char *)a2;
    _os_log_impl(&dword_2164CC000, v13, OS_LOG_TYPE_ERROR, "%25s:%-5d loadbalancer@%p: Profile name hash 0x%llx not found. Not overriding profile.", buf, 0x26u);
  }
LABEL_24:
  if (!v19)
    free(__s1);
}

void sub_216602428(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, char a12)
{
  if (!a12)
    free(a11);
  _Unwind_Resume(exception_object);
}

void Phase::Controller::LoadBalancer::ClearProfileOverride(Phase::Controller::LoadBalancer *this)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  __int16 v9;
  Phase::Controller::LoadBalancer *v10;
  __int16 v11;
  uint64_t v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 216))
  {
    *((_BYTE *)this + 216) = 0;
    *((_QWORD *)this + 29) |= 1uLL;
    v2 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(this)
                                                                                       + 800)));
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v3 = *((_QWORD *)this + 6);
      v4 = *((_QWORD *)this + 12);
      v5 = 136316162;
      v6 = "LoadBalancer.mm";
      v7 = 1024;
      v8 = 315;
      v9 = 2048;
      v10 = this;
      v11 = 2080;
      v12 = v3;
      v13 = 2048;
      v14 = v4;
      _os_log_impl(&dword_2164CC000, v2, OS_LOG_TYPE_DEFAULT, "%25s:%-5d loadbalancer@%p: Clearing the profile override in the Load Balancer. Going back to profile with name: %s, balance: %f", (uint8_t *)&v5, 0x30u);
    }

  }
}

_DWORD *Phase::LockFreeQueueMPSC::GetWriteBuffer(Phase::LockFreeQueueMPSC *this, uint64_t a2, unint64_t *a3, BOOL *a4)
{
  unsigned __int8 *v8;
  _DWORD *result;
  uint64_t v10;
  size_t v11;

  v8 = (unsigned __int8 *)this + 40;
  Phase::SpinLock::Lock((unsigned __int8 *)this + 40);
  result = Phase::LockFreeQueueSPSC::GetWriteBuffer(this, a2, a3);
  if (result)
  {
    *a4 = 0;
    return result;
  }
  if (!*a4)
  {
    result = 0;
    goto LABEL_10;
  }
  v10 = *(int *)this;
  if (a2 + 32 <= (unint64_t)(2 * v10))
    v11 = 2 * v10;
  else
    v11 = a2 + 32;
  result = (_DWORD *)Phase::LockFreeQueueSPSC::GrowBuffer(this, v11, a3);
  if (!result)
  {
    *a4 = 0;
LABEL_10:
    atomic_store(0, v8);
  }
  return result;
}

void Phase::LockFreeQueueSPSC::~LockFreeQueueSPSC(void **this)
{
  void *v2;

  free(this[2]);
  v2 = this[3];
  if (v2 != this[2])
    free(v2);
}

_DWORD *Phase::LockFreeQueueSPSC::GetWriteBuffer(Phase::LockFreeQueueSPSC *this, int a2, unint64_t *a3)
{
  unsigned __int8 v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  unint64_t v8;
  uint64_t v9;
  int v10;
  _DWORD *v11;
  _DWORD *v12;

  v3 = atomic_load((unsigned __int8 *)this + 32);
  v4 = *((int *)this + 3);
  if ((v3 & 1) != 0)
  {
    v5 = *((_DWORD *)this + 2);
  }
  else
  {
    v5 = *((_DWORD *)this + 1);
    if ((int)v4 > v5)
    {
      v6 = *((_DWORD *)this + 2) - v4 - 32;
      if (v6 < a2)
      {
        v7 = v5 - 32;
        if (v5 - 32 >= a2)
          goto LABEL_17;
        goto LABEL_8;
      }
      v8 = v6;
LABEL_19:
      *a3 = v8;
      return (_DWORD *)(*((_QWORD *)this + 3) + v4 + 16);
    }
    if ((int)v4 >= v5)
    {
      v10 = *((_DWORD *)this + 2) - 32;
      if (v10 - (int)v4 >= a2)
      {
        v8 = v10 - (int)v4;
        goto LABEL_19;
      }
      v7 = v5 - 32;
      if (v5 - 32 >= a2)
      {
LABEL_17:
        v12 = (_DWORD *)*((_QWORD *)this + 3);
        *v12 = 0;
        __dmb(0xBu);
        *(_DWORD *)((char *)v12 + *((int *)this + 3)) = -1;
        *((_DWORD *)this + 3) = 0;
        *a3 = v7;
        return v12 + 4;
      }
      if (v10 >= a2)
      {
        v9 = 0;
        v11 = (_DWORD *)*((_QWORD *)this + 3);
        *v11 = 0;
        __dmb(0xBu);
        *(_DWORD *)((char *)v11 + *((int *)this + 3)) = -1;
        *((_DWORD *)this + 3) = 0;
        goto LABEL_9;
      }
      goto LABEL_8;
    }
  }
  LODWORD(v8) = v5 - v4 - 32;
  if ((int)v8 >= a2)
  {
    v8 = (int)v8;
    goto LABEL_19;
  }
LABEL_8:
  v9 = 0;
LABEL_9:
  *a3 = 0;
  return (_DWORD *)v9;
}

uint64_t Phase::LockFreeQueueSPSC::GrowBuffer(Phase::LockFreeQueueSPSC *this, size_t size, unint64_t *a3)
{
  unsigned __int8 v3;
  int v4;
  _DWORD *v7;

  v3 = atomic_load((unsigned __int8 *)this + 32);
  if ((v3 & 1) != 0)
    return 0;
  v4 = size;
  if (*(int *)this >= size)
    return 0;
  v7 = malloc_type_malloc(size, 0xECB05BC0uLL);
  *((_DWORD *)this + 2) = v4;
  *((_DWORD *)this + 3) = 0;
  *a3 = v4 - 32;
  *((_QWORD *)this + 3) = v7;
  *v7 = 0;
  __dmb(0xBu);
  atomic_store(1u, (unsigned __int8 *)this + 32);
  return (uint64_t)v7 + *((int *)this + 3) + 16;
}

uint64_t Phase::LockFreeQueueSPSC::CommitBytes(Phase::LockFreeQueueSPSC *this, int a2)
{
  unsigned __int8 v2;
  uint64_t v3;
  int v4;
  int v6;
  uint64_t v7;

  v2 = atomic_load((unsigned __int8 *)this + 32);
  v3 = *((int *)this + 3);
  if ((v2 & 1) != 0 || (v4 = *((_DWORD *)this + 1), (int)v3 >= v4))
    v4 = *((_DWORD *)this + 2);
  if (v4 - (int)v3 - 32 < a2)
    return 0;
  v6 = ((a2 + 15) & 0xFFFFFFF0) + v3 + 16;
  *((_DWORD *)this + 3) = v6;
  v7 = *((_QWORD *)this + 3);
  *(_DWORD *)(v7 + v6) = 0;
  __dmb(0xBu);
  *(_DWORD *)(v7 + v3) = a2;
  return 1;
}

BOOL Phase::LockFreeQueueSPSC::HasData(Phase::LockFreeQueueSPSC *this)
{
  int v2;
  unsigned __int8 v4;
  _DWORD *v5;

  v2 = *(_DWORD *)(*((_QWORD *)this + 2) + *((int *)this + 1));
  __dmb(9u);
  if (v2 == -1)
  {
    *((_DWORD *)this + 1) = 0;
    v2 = **((_DWORD **)this + 2);
  }
  if (v2 > 0)
    return 1;
  v4 = atomic_load((unsigned __int8 *)this + 32);
  if ((v4 & 1) == 0)
    return 0;
  free(*((void **)this + 2));
  v5 = (_DWORD *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 2) = v5;
  *(_QWORD *)this = *((unsigned int *)this + 2);
  LODWORD(v5) = *v5;
  __dmb(0xBu);
  atomic_store(0, (unsigned __int8 *)this + 32);
  return (int)v5 > 0;
}

uint64_t Phase::Logger::GetInstancePtr(Phase::Logger *this)
{
  unsigned __int8 v1;
  Phase::Logger *v3;

  {
    v3 = (Phase::Logger *)operator new();
    Phase::Logger::Logger(v3);
    Phase::Logger::GetInstancePtr(void)::sInstance = (uint64_t)v3;
  }
  return Phase::Logger::GetInstancePtr(void)::sInstance;
}

void sub_216602944(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199F9D70](v1, 0x10F0C4099A34927);
  _Unwind_Resume(a1);
}

Phase::Logger *Phase::Logger::Logger(Phase::Logger *this)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  _QWORD *v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  _QWORD *v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  _QWORD *v42;
  _QWORD *v43;
  _QWORD *v44;
  _QWORD *v45;
  _QWORD *v46;
  _QWORD *v47;
  _QWORD *v48;
  _QWORD *v49;
  _QWORD *v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *v53;
  _QWORD *v54;
  _QWORD *v55;
  _QWORD *v56;
  _QWORD *v57;
  _QWORD *v58;
  _QWORD *v59;
  _QWORD *v60;
  _QWORD *v61;
  _QWORD *v62;
  _QWORD *v63;
  _QWORD *v64;
  _QWORD *v65;
  _QWORD *v66;
  _QWORD *v67;
  _QWORD *v68;
  _QWORD *v69;
  _QWORD *v70;
  _QWORD *v71;
  _QWORD *v72;
  _QWORD *v73;
  _QWORD *v74;
  void *v75;
  _QWORD *v76;
  int32x4_t v77;
  _QWORD *v78;
  _QWORD *v79;
  int32x2_t v80;
  void *v81;
  void *v82;
  void *v83;
  int v85;

  v2 = (_QWORD *)operator new();
  v2[1] = 0;
  *v2 = os_log_create("com.apple.coreaudio.phase", "Asset");
  *(_QWORD *)this = v2;
  *((_BYTE *)this + 8) = 0;
  v3 = (_QWORD *)operator new();
  v3[1] = 0;
  *v3 = os_log_create("com.apple.coreaudio.phase", "Default");
  *((_QWORD *)this + 2) = v3;
  *((_BYTE *)this + 24) = 0;
  v4 = (_QWORD *)operator new();
  v4[1] = 0;
  *v4 = os_log_create("com.apple.coreaudio.phase", "Event");
  *((_QWORD *)this + 4) = v4;
  *((_BYTE *)this + 40) = 0;
  v5 = (_QWORD *)operator new();
  v5[1] = 0;
  *v5 = os_log_create("com.apple.coreaudio.phase", "Handle");
  *((_QWORD *)this + 6) = v5;
  *((_BYTE *)this + 56) = 0;
  v6 = (_QWORD *)operator new();
  v6[1] = 0;
  *v6 = os_log_create("com.apple.coreaudio.phase", "HeapAllocator");
  *((_QWORD *)this + 8) = v6;
  *((_BYTE *)this + 72) = 0;
  v7 = (_QWORD *)operator new();
  v7[1] = 0;
  *v7 = os_log_create("com.apple.coreaudio.phase", "DSPVoiceManager");
  *((_QWORD *)this + 10) = v7;
  *((_BYTE *)this + 88) = 0;
  v8 = (_QWORD *)operator new();
  v8[1] = 0;
  *v8 = os_log_create("com.apple.coreaudio.phase", "Math");
  *((_QWORD *)this + 12) = v8;
  *((_BYTE *)this + 104) = 0;
  v9 = (_QWORD *)operator new();
  v9[1] = 0;
  *v9 = os_log_create("com.apple.coreaudio.phase", "VirtualAllocator");
  *((_QWORD *)this + 14) = v9;
  *((_BYTE *)this + 120) = 0;
  v10 = (_QWORD *)operator new();
  v10[1] = 0;
  *v10 = os_log_create("com.apple.coreaudio.phase", "VoicePool");
  *((_QWORD *)this + 16) = v10;
  *((_BYTE *)this + 136) = 0;
  v11 = (_QWORD *)operator new();
  v11[1] = 0;
  *v11 = os_log_create("com.apple.coreaudio.phase", "VoiceEngine");
  *((_QWORD *)this + 18) = v11;
  *((_BYTE *)this + 152) = 0;
  v12 = (_QWORD *)operator new();
  v12[1] = 0;
  *v12 = os_log_create("com.apple.coreaudio.phase", "Hrir");
  *((_QWORD *)this + 20) = v12;
  *((_BYTE *)this + 168) = 0;
  v13 = (_QWORD *)operator new();
  v13[1] = 0;
  *v13 = os_log_create("com.apple.coreaudio.phase", "Memory");
  *((_QWORD *)this + 22) = v13;
  *((_BYTE *)this + 184) = 0;
  v14 = (_QWORD *)operator new();
  v14[1] = 0;
  *v14 = os_log_create("com.apple.coreaudio.phase", "Thread");
  *((_QWORD *)this + 24) = v14;
  *((_BYTE *)this + 200) = 0;
  v15 = (_QWORD *)operator new();
  v15[1] = 0;
  *v15 = os_log_create("com.apple.coreaudio.phase", "SpatialModeler");
  *((_QWORD *)this + 26) = v15;
  *((_BYTE *)this + 216) = 0;
  v16 = (_QWORD *)operator new();
  v16[1] = 0;
  *v16 = os_log_create("com.apple.coreaudio.phase", "SpatialModelerSystem");
  *((_QWORD *)this + 28) = v16;
  *((_BYTE *)this + 232) = 0;
  v17 = (_QWORD *)operator new();
  v17[1] = 0;
  *v17 = os_log_create("com.apple.coreaudio.phase", "SpatialModelerCategory");
  *((_QWORD *)this + 30) = v17;
  *((_BYTE *)this + 248) = 0;
  v18 = (_QWORD *)operator new();
  v18[1] = 0;
  *v18 = os_log_create("com.apple.coreaudio.phase", "Commandable");
  *((_QWORD *)this + 32) = v18;
  *((_BYTE *)this + 264) = 0;
  v19 = (_QWORD *)operator new();
  v19[1] = 0;
  *v19 = os_log_create("com.apple.coreaudio.phase", "IrBuilder");
  *((_QWORD *)this + 34) = v19;
  *((_BYTE *)this + 280) = 0;
  v20 = (_QWORD *)operator new();
  v20[1] = 0;
  *v20 = os_log_create("com.apple.coreaudio.phase", "BitAllocator");
  *((_QWORD *)this + 36) = v20;
  *((_BYTE *)this + 296) = 0;
  v21 = (_QWORD *)operator new();
  v21[1] = 0;
  *v21 = os_log_create("com.apple.coreaudio.phase", "BitBlockAllocator");
  *((_QWORD *)this + 38) = v21;
  *((_BYTE *)this + 312) = 0;
  v22 = (_QWORD *)operator new();
  v22[1] = 0;
  *v22 = os_log_create("com.apple.coreaudio.phase", "BlockAllocator");
  *((_QWORD *)this + 40) = v22;
  *((_BYTE *)this + 328) = 0;
  v23 = (_QWORD *)operator new();
  v23[1] = 0;
  *v23 = os_log_create("com.apple.coreaudio.phase", "LinkedList");
  *((_QWORD *)this + 42) = v23;
  *((_BYTE *)this + 344) = 0;
  v24 = (_QWORD *)operator new();
  v24[1] = 0;
  *v24 = os_log_create("com.apple.coreaudio.phase", "MapLight");
  *((_QWORD *)this + 44) = v24;
  *((_BYTE *)this + 360) = 0;
  v25 = (_QWORD *)operator new();
  v25[1] = 0;
  *v25 = os_log_create("com.apple.coreaudio.phase", "SetLight");
  *((_QWORD *)this + 46) = v25;
  *((_BYTE *)this + 376) = 0;
  v26 = (_QWORD *)operator new();
  v26[1] = 0;
  *v26 = os_log_create("com.apple.coreaudio.phase", "ControllerVoiceManager");
  *((_QWORD *)this + 48) = v26;
  *((_BYTE *)this + 392) = 0;
  v27 = (_QWORD *)operator new();
  v27[1] = 0;
  *v27 = os_log_create("com.apple.coreaudio.phase", "VoicePoolRegistry");
  *((_QWORD *)this + 50) = v27;
  *((_BYTE *)this + 408) = 0;
  v28 = (_QWORD *)operator new();
  v28[1] = 0;
  *v28 = os_log_create("com.apple.coreaudio.phase", "Geometry");
  *((_QWORD *)this + 52) = v28;
  *((_BYTE *)this + 424) = 0;
  v29 = (_QWORD *)operator new();
  v29[1] = 0;
  *v29 = os_log_create("com.apple.coreaudio.phase", "Api");
  *((_QWORD *)this + 54) = v29;
  *((_BYTE *)this + 440) = 0;
  v30 = (_QWORD *)operator new();
  v30[1] = 0;
  *v30 = os_log_create("com.apple.coreaudio.phase", "TaskManager");
  *((_QWORD *)this + 56) = v30;
  *((_BYTE *)this + 456) = 0;
  v31 = (_QWORD *)operator new();
  v31[1] = 0;
  *v31 = os_log_create("com.apple.coreaudio.phase", "JobManager");
  *((_QWORD *)this + 58) = v31;
  *((_BYTE *)this + 472) = 0;
  v32 = (_QWORD *)operator new();
  v32[1] = 0;
  *v32 = os_log_create("com.apple.coreaudio.phase", "Engine");
  *((_QWORD *)this + 60) = v32;
  *((_BYTE *)this + 488) = 0;
  v33 = (_QWORD *)operator new();
  v33[1] = 0;
  *v33 = os_log_create("com.apple.coreaudio.phase", "Renderer");
  *((_QWORD *)this + 62) = v33;
  *((_BYTE *)this + 504) = 0;
  v34 = (_QWORD *)operator new();
  v34[1] = 0;
  *v34 = os_log_create("com.apple.coreaudio.phase", "CvmBuffer");
  *((_QWORD *)this + 64) = v34;
  *((_BYTE *)this + 520) = 0;
  v35 = (_QWORD *)operator new();
  v35[1] = 0;
  *v35 = os_log_create("com.apple.coreaudio.phase", "AudioIO");
  *((_QWORD *)this + 66) = v35;
  *((_BYTE *)this + 536) = 0;
  v36 = (_QWORD *)operator new();
  v36[1] = 0;
  *v36 = os_log_create("com.apple.coreaudio.phase", "SpatialModelerReverbPresetDatabase");
  *((_QWORD *)this + 68) = v36;
  *((_BYTE *)this + 552) = 0;
  v37 = (_QWORD *)operator new();
  v37[1] = 0;
  *v37 = os_log_create("com.apple.coreaudio.phase", "SpatialModelerReverbPresetFile");
  *((_QWORD *)this + 70) = v37;
  *((_BYTE *)this + 568) = 0;
  v38 = (_QWORD *)operator new();
  v38[1] = 0;
  *v38 = os_log_create("com.apple.coreaudio.phase", "Spatializer");
  *((_QWORD *)this + 72) = v38;
  *((_BYTE *)this + 584) = 0;
  v39 = (_QWORD *)operator new();
  v39[1] = 0;
  *v39 = os_log_create("com.apple.coreaudio.phase", "DeviceManager");
  *((_QWORD *)this + 74) = v39;
  *((_BYTE *)this + 600) = 0;
  v40 = (_QWORD *)operator new();
  v40[1] = 0;
  *v40 = os_log_create("com.apple.coreaudio.phase", "FIRFilterUtils");
  *((_QWORD *)this + 76) = v40;
  *((_BYTE *)this + 616) = 0;
  v41 = (_QWORD *)operator new();
  v41[1] = 0;
  *v41 = os_log_create("com.apple.coreaudio.phase", "LinkwitzRileyFilterBank");
  *((_QWORD *)this + 78) = v41;
  *((_BYTE *)this + 632) = 0;
  v42 = (_QWORD *)operator new();
  v42[1] = 0;
  *v42 = os_log_create("com.apple.coreaudio.phase", "Envelope");
  *((_QWORD *)this + 80) = v42;
  *((_BYTE *)this + 648) = 0;
  v43 = (_QWORD *)operator new();
  v43[1] = 0;
  *v43 = os_log_create("com.apple.coreaudio.phase", "Fader");
  *((_QWORD *)this + 82) = v43;
  *((_BYTE *)this + 664) = 0;
  v44 = (_QWORD *)operator new();
  v44[1] = 0;
  *v44 = os_log_create("com.apple.coreaudio.phase", "WeatherUtility");
  *((_QWORD *)this + 84) = v44;
  *((_BYTE *)this + 680) = 0;
  v45 = (_QWORD *)operator new();
  v45[1] = 0;
  *v45 = os_log_create("com.apple.coreaudio.phase", "ActionTree");
  *((_QWORD *)this + 86) = v45;
  *((_BYTE *)this + 696) = 0;
  v46 = (_QWORD *)operator new();
  v46[1] = 0;
  *v46 = os_log_create("com.apple.coreaudio.phase", "Parameter");
  *((_QWORD *)this + 88) = v46;
  *((_BYTE *)this + 712) = 0;
  v47 = (_QWORD *)operator new();
  v47[1] = 0;
  *v47 = os_log_create("com.apple.coreaudio.phase", "VoiceData");
  *((_QWORD *)this + 90) = v47;
  *((_BYTE *)this + 728) = 0;
  v48 = (_QWORD *)operator new();
  v48[1] = 0;
  *v48 = os_log_create("com.apple.coreaudio.phase", "SpatialModelerRegistry");
  *((_QWORD *)this + 92) = v48;
  *((_BYTE *)this + 744) = 0;
  v49 = (_QWORD *)operator new();
  v49[1] = 0;
  *v49 = os_log_create("com.apple.coreaudio.phase", "ProcedureRegistry");
  *((_QWORD *)this + 94) = v49;
  *((_BYTE *)this + 760) = 0;
  v50 = (_QWORD *)operator new();
  v50[1] = 0;
  *v50 = os_log_create("com.apple.coreaudio.phase", "ParameterRegistry");
  *((_QWORD *)this + 96) = v50;
  *((_BYTE *)this + 776) = 0;
  v51 = (_QWORD *)operator new();
  v51[1] = 0;
  *v51 = os_log_create("com.apple.coreaudio.phase", "ProfileRegistry");
  *((_QWORD *)this + 98) = v51;
  *((_BYTE *)this + 792) = 0;
  v52 = (_QWORD *)operator new();
  v52[1] = 0;
  *v52 = os_log_create("com.apple.coreaudio.phase", "LoadBalancer");
  *((_QWORD *)this + 100) = v52;
  *((_BYTE *)this + 808) = 0;
  v53 = (_QWORD *)operator new();
  v53[1] = 0;
  *v53 = os_log_create("com.apple.coreaudio.phase", "SoundAssetInfo");
  *((_QWORD *)this + 102) = v53;
  *((_BYTE *)this + 824) = 0;
  v54 = (_QWORD *)operator new();
  v54[1] = 0;
  *v54 = os_log_create("com.apple.coreaudio.phase", "Dispatcher");
  *((_QWORD *)this + 104) = v54;
  *((_BYTE *)this + 840) = 0;
  v55 = (_QWORD *)operator new();
  v55[1] = 0;
  *v55 = os_log_create("com.apple.coreaudio.phase", "XPC");
  *((_QWORD *)this + 106) = v55;
  *((_BYTE *)this + 856) = 0;
  v56 = (_QWORD *)operator new();
  v56[1] = 0;
  *v56 = os_log_create("com.apple.coreaudio.phase", "SharableMemory");
  *((_QWORD *)this + 108) = v56;
  *((_BYTE *)this + 872) = 0;
  v57 = (_QWORD *)operator new();
  v57[1] = 0;
  *v57 = os_log_create("com.apple.coreaudio.phase", "SubmixSystem");
  *((_QWORD *)this + 110) = v57;
  *((_BYTE *)this + 888) = 0;
  v58 = (_QWORD *)operator new();
  v58[1] = 0;
  *v58 = os_log_create("com.apple.coreaudio.phase", "SubsystemUpdate");
  *((_QWORD *)this + 112) = v58;
  *((_BYTE *)this + 904) = 0;
  v59 = (_QWORD *)operator new();
  v59[1] = 0;
  *v59 = os_log_create("com.apple.coreaudio.phase", "ExternalStream");
  *((_QWORD *)this + 114) = v59;
  *((_BYTE *)this + 920) = 0;
  v60 = (_QWORD *)operator new();
  v60[1] = 0;
  *v60 = os_log_create("com.apple.coreaudio.phase", "DirectivitySphericalCap");
  *((_QWORD *)this + 116) = v60;
  *((_BYTE *)this + 936) = 0;
  v61 = (_QWORD *)operator new();
  v61[1] = 0;
  *v61 = os_log_create("com.apple.coreaudio.phase", "TapSystem");
  *((_QWORD *)this + 118) = v61;
  *((_BYTE *)this + 952) = 0;
  v62 = (_QWORD *)operator new();
  v62[1] = 0;
  *v62 = os_log_create("com.apple.coreaudio.phase", "SessionManager");
  *((_QWORD *)this + 120) = v62;
  *((_BYTE *)this + 968) = 0;
  v63 = (_QWORD *)operator new();
  v63[1] = 0;
  *v63 = os_log_create("com.apple.coreaudio.phase", "EngineUpdate");
  *((_QWORD *)this + 122) = v63;
  *((_BYTE *)this + 984) = 0;
  v64 = (_QWORD *)operator new();
  v64[1] = 0;
  *v64 = os_log_create("com.apple.coreaudio.phase", "ClientEngineUpdate");
  *((_QWORD *)this + 124) = v64;
  *((_BYTE *)this + 1000) = 0;
  v65 = (_QWORD *)operator new();
  v65[1] = 0;
  *v65 = os_log_create("com.apple.coreaudio.phase", "ServerEngineUpdate");
  *((_QWORD *)this + 126) = v65;
  *((_BYTE *)this + 1016) = 0;
  v66 = (_QWORD *)operator new();
  v66[1] = 0;
  *v66 = os_log_create("com.apple.coreaudio.phase", "SharedEntity");
  *((_QWORD *)this + 128) = v66;
  *((_BYTE *)this + 1032) = 0;
  v67 = (_QWORD *)operator new();
  v67[1] = 0;
  *v67 = os_log_create("com.apple.coreaudio.phase", "ListenerManager");
  *((_QWORD *)this + 130) = v67;
  *((_BYTE *)this + 1048) = 0;
  v68 = (_QWORD *)operator new();
  v68[1] = 0;
  *v68 = os_log_create("com.apple.coreaudio.phase", "StatisticsDatabase");
  *((_QWORD *)this + 132) = v68;
  *((_BYTE *)this + 1064) = 0;
  v69 = (_QWORD *)operator new();
  v69[1] = 0;
  *v69 = os_log_create("com.apple.coreaudio.phase", "ControllerCommon");
  *((_QWORD *)this + 134) = v69;
  *((_BYTE *)this + 1080) = 0;
  v70 = (_QWORD *)operator new();
  v70[1] = 0;
  *v70 = os_log_create("com.apple.coreaudio.phase", "Diagnostics");
  *((_QWORD *)this + 136) = v70;
  *((_BYTE *)this + 1096) = 0;
  v71 = (_QWORD *)operator new();
  v71[1] = 0;
  *v71 = os_log_create("com.apple.coreaudio.phase", "SignalGenerator");
  *((_QWORD *)this + 138) = v71;
  *((_BYTE *)this + 1112) = 0;
  v72 = (_QWORD *)operator new();
  v72[1] = 0;
  *v72 = os_log_create("com.apple.coreaudio.phase", "mBinaryFile");
  *((_QWORD *)this + 140) = v72;
  *((_BYTE *)this + 1128) = 0;
  v73 = (_QWORD *)operator new();
  v73[1] = 0;
  *v73 = os_log_create("com.apple.coreaudio.phase", "mCenterFrequencyBands");
  *((_QWORD *)this + 142) = v73;
  *((_BYTE *)this + 1144) = 0;
  v74 = (_QWORD *)operator new();
  v74[1] = 0;
  *v74 = os_log_create("com.apple.coreaudio.phase", "DeviceInfo");
  *((_QWORD *)this + 144) = v74;
  *((_BYTE *)this + 1160) = 0;
  caulk::deferred_logger::create_v(MEMORY[0x24BDACB70], v75);
  v76 = (_QWORD *)operator new();
  v76[1] = 0;
  *v76 = os_log_create("com.apple.coreaudio.phase", "RoomSimulation");
  *((_QWORD *)this + 148) = v76;
  *((_BYTE *)this + 1192) = 0;
  *((_QWORD *)this + 150) = 0xC0E0000000000000;
  *(_OWORD *)((char *)this + 1208) = xmmword_216738CF0;
  *((_QWORD *)this + 153) = 0x3000003E8;
  v77 = vdupq_n_s32(0x7FC00000u);
  *((int32x4_t *)this + 77) = v77;
  *((_DWORD *)this + 312) = 2143289344;
  *(_OWORD *)((char *)this + 1256) = 0u;
  *(_OWORD *)((char *)this + 1272) = 0u;
  *(_OWORD *)((char *)this + 1288) = 0u;
  *(_OWORD *)((char *)this + 1304) = 0u;
  *((_QWORD *)this + 165) = 0;
  *((int32x4_t *)this + 83) = v77;
  *((int32x4_t *)this + 84) = v77;
  *((int32x4_t *)this + 85) = v77;
  *((int32x4_t *)this + 86) = v77;
  *((int32x4_t *)this + 87) = v77;
  *((_QWORD *)this + 176) = v77.i64[0];
  *((_BYTE *)this + 1416) = 0;
  *((_DWORD *)this + 355) = 2143289344;
  *((_QWORD *)this + 183) = 0;
  *(_OWORD *)((char *)this + 1448) = 0u;
  *((_OWORD *)this + 89) = 0u;
  *((_BYTE *)this + 1440) = 0;
  v78 = operator new(0x28uLL);
  *((_QWORD *)this + 181) = v78;
  *((_QWORD *)this + 183) = v78 + 5;
  v78[4] = 0;
  *(_OWORD *)v78 = xmmword_216738D20;
  *((_OWORD *)v78 + 1) = unk_216738D30;
  *((_QWORD *)this + 182) = v78 + 5;
  *((_QWORD *)this + 184) = 0;
  *((_QWORD *)this + 186) = 0;
  *((_QWORD *)this + 185) = 0;
  v79 = operator new(0x28uLL);
  *((_QWORD *)this + 184) = v79;
  *((_QWORD *)this + 186) = v79 + 5;
  v79[4] = 0;
  *(_OWORD *)v79 = xmmword_216738D20;
  *((_OWORD *)v79 + 1) = unk_216738D30;
  *((_QWORD *)this + 185) = v79 + 5;
  *((_WORD *)this + 748) = 257;
  v80 = vdup_n_s32(0x7FC00000u);
  *(int32x2_t *)((char *)this + 1500) = v80;
  *((_DWORD *)this + 377) = 16777217;
  *((int32x2_t *)this + 189) = v80;
  *((_DWORD *)this + 380) = 65793;
  *((_BYTE *)this + 1524) = 0;
  *(_OWORD *)((char *)this + 1528) = 0u;
  *((_DWORD *)this + 386) = 0x2000;
  *(_QWORD *)((char *)this + 1548) = 0x100000100000100;
  *((_QWORD *)this + 195) = 0;
  *((_BYTE *)this + 1568) = 0;
  *((_QWORD *)this + 197) = 0;
  *((_QWORD *)this + 198) = 300000000000;
  v81 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDBCF50]), "initWithSuiteName:", CFSTR("com.apple.coreaudio"));
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_audioio_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 66) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_actiontree_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 86) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_cvm_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 48) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_dvm_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 10) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_irbuilder_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 34) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_taskmanager_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 56) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_jobmanager_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 58) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_sharablememory_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 108) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_smrpd_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 68) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_smrpf_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 70) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_renderer_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 62) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_spatializer_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 72) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_devicemanager_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 74) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_envelope_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 80) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_fader_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 82) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_weatherutility_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 84) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_spatialmodeler_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 26) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_sms_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 28) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_parameter_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 88) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_voicedata_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 90) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_soundassetinfo_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 102) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_xpc_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 106) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_dispatcher_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 104) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_profileregistry_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 98) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_loadbalancer_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 100) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_tapsystem_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 118) + 8) = v85;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v81, (uint64_t)CFSTR("phase_roomsimulation_trace"), &v85);
  *(_QWORD *)(*((_QWORD *)this + 148) + 8) = v85;

  v82 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDBCF50]), "initWithSuiteName:", CFSTR("com.apple.coreaudio"));
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_room_simulation_drroffset"), (_DWORD *)this + 301);
  Phase::sReadDefaultsValue<int>(v82, (uint64_t)CFSTR("phase_room_geometry_shape_type"), (_DWORD *)this + 300);
  Phase::sReadDefaultsValue<int>(v82, (uint64_t)CFSTR("phase_room_simulation_disable_singletrace"), (_DWORD *)this + 302);
  Phase::sReadDefaultsValue<int>(v82, (uint64_t)CFSTR("phase_room_simulation_disable_reverboutsideroom"), (_DWORD *)this + 304);
  Phase::sReadDefaultsValue<int>(v82, (uint64_t)CFSTR("phase_room_simulation_keeprendereralive"), (_DWORD *)this + 305);
  Phase::sReadDefaultsValue<int>(v82, (uint64_t)CFSTR("phase_room_simulation_minimumintersections"), (_DWORD *)this + 306);
  Phase::sReadDefaultsValue<int>(v82, (uint64_t)CFSTR("phase_room_simulation_spaceblendalgorithm"), (_DWORD *)this + 307);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_minimum_reverb_time"), (_DWORD *)this + 308);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_maximum_reverb_time"), (_DWORD *)this + 309);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_smoothing_in_seconds_per_jnd"), (_DWORD *)this + 310);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_low_confidence_convergence_slowing_exponent"), (_DWORD *)this + 311);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_minimum_convergence_confidence"), (_DWORD *)this + 312);
  Phase::sReadDefaultsValue<std::vector<float>>(v82, CFSTR("phase_are_process_rt60_acoustic_confidence_multipliers"), (char **)this + 157);
  Phase::sReadDefaultsValue<std::vector<float>>(v82, CFSTR("phase_are_process_rt60_default_curated_from_scene_reverb_time"), (char **)this + 160);
  Phase::sReadDefaultsValue<std::vector<float>>(v82, CFSTR("phase_are_process_rt60_default_curated_from_scene_confidence"), (char **)this + 163);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_acoustic_high_confidence_weight_exponent"), (_DWORD *)this + 332);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_visual_high_confidence_weight_exponent"), (_DWORD *)this + 333);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_seatbelt_high_confidence_weight_exponent"), (_DWORD *)this + 334);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_acoustic_visual_high_confidence_weight_exponent"), (_DWORD *)this + 335);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_acoustic_mix_confidence_reduction_exponent"), (_DWORD *)this + 336);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_visual_mix_confidence_reduction_exponent"), (_DWORD *)this + 337);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_broadband_seatbelt_confidence"), (_DWORD *)this + 338);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_broadband_visual_confidence"), (_DWORD *)this + 339);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_seatbelt_to_initial_reverb_time_multiplier"), (_DWORD *)this + 340);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_broadband_seatbelt_initial_confidence"), (_DWORD *)this + 341);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_seatbelt_reverb_time_multiplier"), (_DWORD *)this + 342);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_seatbelt_confidence_exponent"), (_DWORD *)this + 343);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_seatbelt_maximum_mix"), (_DWORD *)this + 344);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_lower_seatbelt_mean_free_path_limit"), (_DWORD *)this + 345);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_upper_seatbelt_mean_free_path_limit"), (_DWORD *)this + 346);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_room_change_probability_min"), (_DWORD *)this + 347);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_room_change_probability_max"), (_DWORD *)this + 348);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_room_change_confidence_exponent"), (_DWORD *)this + 349);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_room_change_acoustic_confidence_exponent"), (_DWORD *)this + 350);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_room_change_rate_confidence_exponent"), (_DWORD *)this + 351);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_room_change_rate_confidence_max"), (_DWORD *)this + 352);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_minimum_seatbelt_initial_confidence"), (_DWORD *)this + 353);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_are_process_rt60_enable_soft_limiting"), (_BYTE *)this + 1416);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_are_process_rt60_maximum_log_rate_in_hz"), (_DWORD *)this + 355);
  Phase::sReadDefaultsValue<char const*>(v82, (uint64_t)CFSTR("phase_are_process_rt60_simulation_in_file_pathname"), (_QWORD *)this + 178);
  Phase::sReadDefaultsValue<char const*>(v82, (uint64_t)CFSTR("phase_are_process_rt60_simulation_out_file_pathname"), (_QWORD *)this + 179);
  Phase::sReadDefaultsValue<int>(v82, (uint64_t)CFSTR("phase_room_simulation_internal_subband_count"), (_DWORD *)this + 303);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_enable_are_room_eq"), (_BYTE *)this + 1440);
  Phase::sReadDefaultsValue<std::vector<float>>(v82, CFSTR("phase_room_eq_er"), (char **)this + 181);
  Phase::sReadDefaultsValue<std::vector<float>>(v82, CFSTR("phase_room_eq_lr"), (char **)this + 184);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_single_assignment_clustering"), (_BYTE *)this + 1496);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_fixed_er_lr_directivity"), (_BYTE *)this + 1497);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_er_lr_directivity_sphere_radius"), (_DWORD *)this + 375);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_er_lr_directivity_opening_angle"), (_DWORD *)this + 376);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_lr_sound_delay"), (_BYTE *)this + 1508);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_include_sources_outside_in_shared_reverb"), (_BYTE *)this + 1509);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_log_room_change_detection_data"), (_BYTE *)this + 1510);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_log_room_change_enable_mfp_fixed_std"), (_BYTE *)this + 1511);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_log_room_change_mfp_fixed_std"), (_DWORD *)this + 378);
  Phase::sReadDefaultsValue<float>(v82, (uint64_t)CFSTR("phase_log_room_change_dynamic_std_fraction"), (_DWORD *)this + 379);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_enable_listener_outside_mitigation"), (_BYTE *)this + 1520);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_enable_scene_observer"), (_BYTE *)this + 1521);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_enable_dynamic_aggregation"), (_BYTE *)this + 1522);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_enable_force_response_building"), (_BYTE *)this + 1523);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_enable_deterministic_ray_tracer_mode"), (_BYTE *)this + 1524);
  Phase::sReadDefaultsValue<int>(v82, (uint64_t)CFSTR("phase_audioio_captures"), (_DWORD *)this + 382);
  Phase::sReadDefaultsValue<int>(v82, (uint64_t)CFSTR("phase_streamrenderer_captures"), (_DWORD *)this + 383);
  Phase::sReadDefaultsValue<int>(v82, (uint64_t)CFSTR("phase_externalstream_captures"), (_DWORD *)this + 384);
  *((_BYTE *)this + 1568) = _os_feature_enabled_impl();
  Phase::sReadDefaultsValue<int>(v82, (uint64_t)CFSTR("phase_spatialmodeler_disableattackgraph"), (_DWORD *)this + 385);
  Phase::sReadDefaultsValue<int>(v82, (uint64_t)CFSTR("phase_spatializer_samples"), (_DWORD *)this + 386);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_m2s_trace"), (_BYTE *)this + 1548);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_enable_cvm_stats_logging"), (_BYTE *)this + 1549);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_sort_asset_info_by_type_and_size"), (_BYTE *)this + 1550);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_xpc_thread"), (_BYTE *)this + 1551);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_log_sound_event_state_transitions"), (_BYTE *)this + 1552);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_log_action_tree_object_state_transitions"), (_BYTE *)this + 1553);
  Phase::sReadDefaultsValue<BOOL>(v82, (uint64_t)CFSTR("phase_enable_ambient_submix_dynamic_orientation"), (_BYTE *)this + 1555);

  v83 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDBCF50]), "initWithSuiteName:", CFSTR("com.apple.coreaudio"));
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_engineupdate_signposts"), &v85);
  *((_BYTE *)this + 984) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_clientengineupdate_signposts"), &v85);
  *((_BYTE *)this + 1000) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_serverengineupdate_signposts"), &v85);
  *((_BYTE *)this + 1016) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_subsystemupdate_signposts"), &v85);
  *((_BYTE *)this + 904) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_engine_signposts"), &v85);
  *((_BYTE *)this + 488) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_audioio_signposts"), &v85);
  *((_BYTE *)this + 536) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_actiontree_signposts"), &v85);
  *((_BYTE *)this + 696) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_cvm_signposts"), &v85);
  *((_BYTE *)this + 392) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_dvm_signposts"), &v85);
  *((_BYTE *)this + 88) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_irbuilder_signposts"), &v85);
  *((_BYTE *)this + 280) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_taskmanager_signposts"), &v85);
  *((_BYTE *)this + 456) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_jobmanager_signposts"), &v85);
  *((_BYTE *)this + 472) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_sharablememory_signposts"), &v85);
  *((_BYTE *)this + 872) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_smrpd_signposts"), &v85);
  *((_BYTE *)this + 552) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_smrpf_signposts"), &v85);
  *((_BYTE *)this + 568) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_renderer_signposts"), &v85);
  *((_BYTE *)this + 504) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_spatializer_signposts"), &v85);
  *((_BYTE *)this + 584) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_devicemanager_signposts"), &v85);
  *((_BYTE *)this + 600) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_envelope_signposts"), &v85);
  *((_BYTE *)this + 648) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_fader_signposts"), &v85);
  *((_BYTE *)this + 664) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_weatherutility_signposts"), &v85);
  *((_BYTE *)this + 680) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_spatialmodeler_signposts"), &v85);
  *((_BYTE *)this + 216) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_sms_signposts"), &v85);
  *((_BYTE *)this + 232) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_parameter_signposts"), &v85);
  *((_BYTE *)this + 712) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_voicedata_signposts"), &v85);
  *((_BYTE *)this + 728) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_soundassetinfo_signposts"), &v85);
  *((_BYTE *)this + 824) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_xpc_signposts"), &v85);
  *((_BYTE *)this + 856) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_dispatcher_signposts"), &v85);
  *((_BYTE *)this + 840) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_profileregistry_signposts"), &v85);
  *((_BYTE *)this + 792) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_loadbalancer_signposts"), &v85);
  *((_BYTE *)this + 808) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_tapsystem_signposts"), &v85);
  *((_BYTE *)this + 952) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_sharedentity_signposts"), &v85);
  *((_BYTE *)this + 1032) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_listenermanager_signposts"), &v85);
  *((_BYTE *)this + 1048) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_api_signposts"), &v85);
  *((_BYTE *)this + 440) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_geometry_signposts"), &v85);
  *((_BYTE *)this + 424) = v85 != 0;
  v85 = 0;
  Phase::sReadDefaultsValue<int>(v83, (uint64_t)CFSTR("phase_roomsimulation_signposts"), &v85);
  *((_BYTE *)this + 1192) = v85 != 0;

  return this;
}

void sub_216604C14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16, void **a17)
{
  _QWORD *v17;
  void **v18;
  void **v19;
  void *v21;
  void *v22;
  void *v23;
  void *v24;

  v21 = *v19;
  if (*v19)
  {
    v17[182] = v21;
    operator delete(v21);
  }
  v22 = *a16;
  if (*a16)
  {
    v17[164] = v22;
    operator delete(v22);
  }
  v23 = *a17;
  if (*a17)
  {
    v17[161] = v23;
    operator delete(v23);
  }
  v24 = *v18;
  if (*v18)
  {
    v17[158] = v24;
    operator delete(v24);
  }
  std::shared_ptr<Phase::Geometry::SystemState>::~shared_ptr[abi:ne180100](a10);
  _Unwind_Resume(a1);
}

void Phase::sReadDefaultsValue<float>(void *a1, uint64_t a2, _DWORD *a3)
{
  void *v4;
  int v5;
  id v6;

  objc_msgSend(a1, "objectForKey:", a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4)
  {
    v6 = v4;
    objc_msgSend(v4, "floatValue");
    *a3 = v5;
    v4 = v6;
  }

}

void sub_216604CF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void Phase::sReadDefaultsValue<int>(void *a1, uint64_t a2, _DWORD *a3)
{
  void *v4;
  id v5;

  objc_msgSend(a1, "objectForKey:", a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4)
  {
    v5 = v4;
    *a3 = objc_msgSend(v4, "intValue");
    v4 = v5;
  }

}

void sub_216604D50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void Phase::sReadDefaultsValue<std::vector<float>>(void *a1, void *a2, char **a3)
{
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  id v10;
  int v11;
  int v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  int v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  id v28;
  id v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  _BYTE v34[128];
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v28 = a1;
  v29 = a2;
  objc_msgSend(v28, "objectForKey:", v29);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  if (v5)
  {
    a3[1] = *a3;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v33 = 0u;
    objc_msgSend(MEMORY[0x24BDD14A8], "characterSetWithCharactersInString:", CFSTR(",.0123456789"));
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v24, "invertedSet");
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "componentsSeparatedByCharactersInSet:", v25);
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v26, "componentsJoinedByString:", &stru_24D582B00);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v27, "componentsSeparatedByString:", CFSTR(","));
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v30, v34, 16);
    if (v7)
    {
      v8 = *(_QWORD *)v31;
      do
      {
        for (i = 0; i != v7; ++i)
        {
          if (*(_QWORD *)v31 != v8)
            objc_enumerationMutation(v6);
          v10 = *(id *)(*((_QWORD *)&v30 + 1) + 8 * i);
          objc_msgSend(v10, "floatValue");
          v12 = v11;
          v14 = a3[1];
          v13 = (unint64_t)a3[2];
          if ((unint64_t)v14 >= v13)
          {
            v16 = *a3;
            v17 = (v14 - *a3) >> 2;
            v18 = v17 + 1;
            if ((unint64_t)(v17 + 1) >> 62)
              std::vector<float>::__throw_length_error[abi:ne180100]();
            v19 = v13 - (_QWORD)v16;
            if (v19 >> 1 > v18)
              v18 = v19 >> 1;
            if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL)
              v20 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v20 = v18;
            if (v20)
            {
              v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), v20);
              v16 = *a3;
              v14 = a3[1];
            }
            else
            {
              v21 = 0;
            }
            v22 = &v21[4 * v17];
            *(_DWORD *)v22 = v12;
            v15 = v22 + 4;
            while (v14 != v16)
            {
              v23 = *((_DWORD *)v14 - 1);
              v14 -= 4;
              *((_DWORD *)v22 - 1) = v23;
              v22 -= 4;
            }
            *a3 = v22;
            a3[1] = v15;
            a3[2] = &v21[4 * v20];
            if (v16)
              operator delete(v16);
          }
          else
          {
            *(_DWORD *)v14 = v11;
            v15 = v14 + 4;
          }
          a3[1] = v15;

        }
        v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v30, v34, 16);
      }
      while (v7);
    }

  }
}

void sub_216605004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16)
{
  void *v16;

  _Unwind_Resume(a1);
}

void Phase::sReadDefaultsValue<BOOL>(void *a1, uint64_t a2, _BYTE *a3)
{
  void *v4;
  id v5;

  objc_msgSend(a1, "objectForKey:", a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4)
  {
    v5 = v4;
    *a3 = objc_msgSend(v4, "BOOLValue");
    v4 = v5;
  }

}

void sub_2166050E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void Phase::sReadDefaultsValue<char const*>(void *a1, uint64_t a2, _QWORD *a3)
{
  void *v4;
  id v5;

  objc_msgSend(a1, "objectForKey:", a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4)
  {
    v5 = v4;
    *a3 = objc_msgSend(objc_retainAutorelease(v4), "UTF8String");
    v4 = v5;
  }

}

void sub_216605140(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t Phase::Logger::CreateAudioCapturer@<X0>(Phase::Logger *this@<X0>, const char *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t result;

  if (qword_254E44920 != -1)
    dispatch_once(&qword_254E44920, &__block_literal_global_358);
  if (off_254E44918)
    result = off_254E44918(4386, "AudioCapture/PHASE", this, 1667327590, 0, a2);
  else
    result = 0;
  *a3 = result;
  return result;
}

void ___ZN5Phase6Logger25CheckTailspinWithThrottleEv_block_invoke()
{
  const void *v0;
  BOOL v1;
  char v2;

  v0 = (const void *)MGCopyAnswer();
  if (v0)
    v1 = v0 == (const void *)*MEMORY[0x24BDBD270];
  else
    v1 = 0;
  v2 = v1;
  _MergedGlobals_18 = v2;
  if (v0)
    CFRelease(v0);
}

void Phase::Logger::DumpTailspinWithThrottleAsync(Phase::Logger *this, const char *a2)
{
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  void *v10;
  NSObject *v11;
  id v12;
  NSObject *v13;
  _QWORD block[4];
  id v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (qword_254E44910 != -1)
    dispatch_once(&qword_254E44910, &__block_literal_global_2);
  if (_MergedGlobals_18)
  {
    mach_absolute_time();
    v4 = __udivti3();
    v5 = (unint64_t *)((char *)this + 1576);
    v6 = atomic_load((unint64_t *)this + 197);
    while (1)
    {
      if (v6)
      {
        v7 = atomic_load((unint64_t *)this + 198);
        if (v4 - v6 < v7)
          break;
      }
      while (1)
      {
        v8 = __ldaxr(v5);
        if (v8 != v6)
          break;
        if (!__stlxr(v4, v5))
        {
          v9 = 1;
          goto LABEL_11;
        }
      }
      v9 = 0;
      __clrex();
LABEL_11:
      v6 = v8;
      if (v9)
      {
        objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%s"), a2);
        v10 = (void *)objc_claimAutoreleasedReturnValue();
        dispatch_get_global_queue(25, 0);
        v11 = objc_claimAutoreleasedReturnValue();
        block[0] = MEMORY[0x24BDAC760];
        block[1] = 3221225472;
        block[2] = ___ZN5Phase6Logger29DumpTailspinWithThrottleAsyncEPKc_block_invoke;
        block[3] = &unk_24D57EA50;
        v15 = v10;
        v12 = v10;
        dispatch_async(v11, block);

        return;
      }
    }
  }
  else
  {
    v13 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(this) + 1088));
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136315394;
      v17 = "Log.mm";
      v18 = 1024;
      v19 = 478;
      _os_log_impl(&dword_2164CC000, v13, OS_LOG_TYPE_INFO, "%25s:%-5d skipping tailspin diagnostic on unsupported build", buf, 0x12u);
    }
  }
}

void ___ZN5Phase6Logger29DumpTailspinWithThrottleAsyncEPKc_block_invoke(uint64_t a1)
{
  Phase::Logger *v1;
  NSObject *v2;
  Phase::Logger *v3;
  char *v4;
  uint64_t i;
  void *v6;
  void **v7;
  void **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  void **v13;
  void **v14;
  void **v15;
  void *v16;
  void *v17;
  void **v18;
  void **v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  void **v24;
  void **v25;
  void **v26;
  void *v27;
  CFDictionaryRef v28;
  uint64_t j;
  const void *v30;
  const void *v31;
  std::runtime_error *exception;
  void **values;
  void **v34;
  void **v35;
  void **keys;
  void **v37;
  void **v38;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  _DWORD v42[2];
  _BYTE v43[16];
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  v1 = (Phase::Logger *)*(id *)(a1 + 32);
  v2 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v1) + 1088));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    v40 = "Log.mm";
    v41 = 1024;
    v42[0] = 448;
    _os_log_impl(&dword_2164CC000, v2, OS_LOG_TYPE_DEFAULT, "%25s:%-5d firing tailspin request through audio analytics", buf, 0x12u);
  }
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)buf, "issue_type");
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)((char *)&v40 + 4), "phase");
  v3 = objc_retainAutorelease(v1);
  v4 = (char *)-[Phase::Logger UTF8String](v3, "UTF8String");
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)((char *)v42 + 2), "context");
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v43, v4);
  keys = 0;
  v37 = 0;
  v38 = 0;
  std::vector<std::pair<int,float>>::reserve((void **)&keys, 2uLL);
  values = 0;
  v34 = 0;
  v35 = 0;
  std::vector<std::pair<int,float>>::reserve((void **)&values, 2uLL);
  for (i = 0; i != 2; ++i)
  {
    v6 = *(void **)&buf[16 * i];
    v7 = v37;
    if (v37 >= v38)
    {
      v9 = v37 - keys;
      if ((unint64_t)(v9 + 1) >> 61)
        std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
      v10 = ((char *)v38 - (char *)keys) >> 2;
      if (v10 <= v9 + 1)
        v10 = v9 + 1;
      if ((unint64_t)((char *)v38 - (char *)keys) >= 0x7FFFFFFFFFFFFFF8)
        v11 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v11 = v10;
      if (v11)
        v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&v38, v11);
      else
        v12 = 0;
      v13 = (void **)&v12[8 * v9];
      *v13 = v6;
      v8 = v13 + 1;
      v15 = keys;
      v14 = v37;
      if (v37 != keys)
      {
        do
        {
          v16 = *--v14;
          *--v13 = v16;
        }
        while (v14 != v15);
        v14 = keys;
      }
      keys = v13;
      v37 = v8;
      v38 = (void **)&v12[8 * v11];
      if (v14)
        operator delete(v14);
    }
    else
    {
      *v37 = v6;
      v8 = v7 + 1;
    }
    v37 = v8;
    v17 = *(void **)((char *)&v40 + 16 * i + 4);
    v18 = v34;
    if (v34 >= v35)
    {
      v20 = v34 - values;
      if ((unint64_t)(v20 + 1) >> 61)
        std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
      v21 = ((char *)v35 - (char *)values) >> 2;
      if (v21 <= v20 + 1)
        v21 = v20 + 1;
      if ((unint64_t)((char *)v35 - (char *)values) >= 0x7FFFFFFFFFFFFFF8)
        v22 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v22 = v21;
      if (v22)
        v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&v35, v22);
      else
        v23 = 0;
      v24 = (void **)&v23[8 * v20];
      *v24 = v17;
      v19 = v24 + 1;
      v26 = values;
      v25 = v34;
      if (v34 != values)
      {
        do
        {
          v27 = *--v25;
          *--v24 = v27;
        }
        while (v25 != v26);
        v25 = values;
      }
      values = v24;
      v34 = v19;
      v35 = (void **)&v23[8 * v22];
      if (v25)
        operator delete(v25);
    }
    else
    {
      *v34 = v17;
      v19 = v18 + 1;
    }
    v34 = v19;
  }
  v28 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!v28)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  if (values)
  {
    v34 = values;
    operator delete(values);
  }
  if (keys)
  {
    v37 = keys;
    operator delete(keys);
  }
  for (j = 0; j != -8; j -= 4)
  {
    v30 = *(const void **)&v43[j * 4];
    if (v30)
      CFRelease(v30);
    v31 = *(const void **)((char *)&v42[j] + 2);
    if (v31)
      CFRelease(v31);
  }
  CAReportingClientSendSingleMessage();
  CFRelease(v28);

}

void sub_2166057F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, CFTypeRef a15, CFTypeRef a16, CFTypeRef cf, uint64_t a18)
{
  void *v18;
  void *v19;
  uint64_t v21;
  const void *v22;
  const void *v23;

  __cxa_free_exception(v19);
  if (__p)
    operator delete(__p);
  if (a12)
    operator delete(a12);
  v21 = 0;
  while (1)
  {
    v22 = *(const void **)((char *)&a18 + v21);
    if (v22)
      CFRelease(v22);
    v23 = *(CFTypeRef *)((char *)&cf + v21);
    if (v23)
      CFRelease(v23);
    v21 -= 16;
    if (v21 == -32)
    {

      _Unwind_Resume(a1);
    }
  }
}

applesauce::CF::TypeRef *applesauce::CF::TypeRef::TypeRef(applesauce::CF::TypeRef *this, char *a2)
{
  void **v3;
  CFIndex v4;
  CFStringRef v5;
  std::runtime_error *exception;
  void *__p[2];
  unsigned __int8 v9;

  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  if ((v9 & 0x80u) == 0)
    v3 = __p;
  else
    v3 = (void **)__p[0];
  if ((v9 & 0x80u) == 0)
    v4 = v9;
  else
    v4 = (CFIndex)__p[1];
  v5 = CFStringCreateWithBytes(0, (const UInt8 *)v3, v4, 0x8000100u, 0);
  *(_QWORD *)this = v5;
  if (!v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  if ((char)v9 < 0)
    operator delete(__p[0]);
  return this;
}

void sub_216605A10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  CFTypeRef *v15;

  if (*v15)
    CFRelease(*v15);
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Phase::LookupInterpolator::Initialize(Phase::LookupInterpolator *this, float a2, int a3, unsigned int a4, float *a5)
{
  *((float *)this + 2) = a2;
  *(_DWORD *)this = a3;
  *((_DWORD *)this + 1) = a4;
  std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)this + 16, (char *)a5, (uint64_t)&a5[a4], a4);
  *((_QWORD *)this + 8) = *((_QWORD *)this + 7);
  Phase::LookupInterpolator::EvaluateMeanRange((uint64_t)this);
  Phase::LookupInterpolator::EvaluateInterpolationRanges(this, *((_DWORD *)this + 11) - 1);
  Phase::LookupInterpolator::EvaluateFractionsFromInterpolationRanges(this);
}

uint64_t Phase::LookupInterpolator::EvaluateMeanRange(uint64_t this)
{
  uint64_t v1;
  unsigned int v2;
  int v3;
  int v4;

  v1 = this;
  v2 = (float)(**(float **)(this + 16) / (float)(*(float *)(this + 8) / (float)*(unsigned int *)this));
  if (v2)
  {
    v3 = v2 + 1;
    v4 = 1;
  }
  else
  {
    this = Phase::LookupInterpolator::GetSubbandCountBelowFirstFFTBin((Phase::LookupInterpolator *)this);
    if (vabds_f32(*(float *)(v1 + 8) / (float)*(unsigned int *)v1, *(float *)(*(_QWORD *)(v1 + 16) + 4 * this)) >= (float)((float)(*(float *)(*(_QWORD *)(v1 + 16) + 4 * (this + 1))- *(float *)(*(_QWORD *)(v1 + 16) + 4 * this))* 0.5))v4 = this;
    else
      v4 = this + 1;
    v3 = 2;
  }
  *(_DWORD *)(v1 + 40) = 0;
  *(_DWORD *)(v1 + 44) = v4;
  *(_DWORD *)(v1 + 48) = 0;
  *(_DWORD *)(v1 + 52) = v3;
  return this;
}

void Phase::LookupInterpolator::EvaluateInterpolationRanges(Phase::LookupInterpolator *this, unsigned int a2)
{
  char *v2;
  int v3;
  uint64_t v5;
  uint64_t v6;
  float v7;
  unsigned int v8;
  unint64_t v9;
  float v10;
  unsigned int v11;
  unsigned int v12;
  unint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  char *v22;

  v2 = (char *)*((_QWORD *)this + 7);
  *((_QWORD *)this + 8) = v2;
  v3 = *((_DWORD *)this + 1);
  if (v3 - 1 > a2)
  {
    v5 = a2;
    do
    {
      v6 = *((_QWORD *)this + 2);
      v7 = *((float *)this + 2) / (float)*(unsigned int *)this;
      v8 = (float)(*(float *)(v6 + 4 * v5) / v7);
      v9 = v5 + 1;
      v10 = *(float *)(v6 + 4 * (v5 + 1)) / v7;
      v11 = v10 - v8;
      if (v10 != v8)
      {
        v12 = v8 + 1;
        v13 = *((_QWORD *)this + 9);
        if ((unint64_t)v2 >= v13)
        {
          v15 = (char *)*((_QWORD *)this + 7);
          v16 = (v2 - v15) >> 4;
          v17 = v16 + 1;
          if ((unint64_t)(v16 + 1) >> 60)
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          v18 = v13 - (_QWORD)v15;
          if (v18 >> 3 > v17)
            v17 = v18 >> 3;
          if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0)
            v19 = 0xFFFFFFFFFFFFFFFLL;
          else
            v19 = v17;
          if (v19)
          {
            if (v19 >> 60)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v20 = (char *)operator new(16 * v19);
          }
          else
          {
            v20 = 0;
          }
          v21 = &v20[16 * v16];
          *(_DWORD *)v21 = v5;
          *((_DWORD *)v21 + 1) = 1;
          *((_DWORD *)v21 + 2) = v12;
          *((_DWORD *)v21 + 3) = v11;
          v22 = v21;
          if (v2 != v15)
          {
            do
            {
              *((_OWORD *)v22 - 1) = *((_OWORD *)v2 - 1);
              v22 -= 16;
              v2 -= 16;
            }
            while (v2 != v15);
            v2 = (char *)*((_QWORD *)this + 7);
          }
          v14 = v21 + 16;
          *((_QWORD *)this + 7) = v22;
          *((_QWORD *)this + 8) = v21 + 16;
          *((_QWORD *)this + 9) = &v20[16 * v19];
          if (v2)
            operator delete(v2);
        }
        else
        {
          *(_DWORD *)v2 = v5;
          *((_DWORD *)v2 + 1) = 1;
          v14 = v2 + 16;
          *((_DWORD *)v2 + 2) = v12;
          *((_DWORD *)v2 + 3) = v11;
        }
        *((_QWORD *)this + 8) = v14;
        v3 = *((_DWORD *)this + 1);
        v2 = v14;
      }
      ++v5;
    }
    while (v9 < (v3 - 1));
  }
}

void Phase::LookupInterpolator::EvaluateFractionsFromInterpolationRanges(Phase::LookupInterpolator *this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int *v6;
  uint64_t v7;
  unsigned int v8;
  unint64_t v9;
  unsigned int v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float *v16;
  float *v17;
  unint64_t v18;
  float v19;
  float v20;
  float *v21;
  float v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  void *__p[3];
  void *v28[3];

  v2 = (uint64_t *)((char *)this + 104);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 13);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 10);
  v3 = *((_QWORD *)this + 7);
  if (*((_QWORD *)this + 8) != v3)
  {
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = (unsigned int *)(v3 + 16 * v4);
      v7 = *v6;
      v8 = v6[1];
      v10 = v6[2];
      v9 = v6[3];
      v11 = *((_QWORD *)this + 2);
      v12 = *(float *)(v11 + 4 * v7);
      v13 = *(float *)(v11 + 4 * (v8 + v7));
      std::vector<float>::vector(v28, v9);
      std::vector<float>::vector(__p, v9);
      if ((_DWORD)v9)
      {
        v14 = (float)*(unsigned int *)this;
        v15 = v13 - v12;
        v16 = (float *)v28[0];
        v17 = (float *)v28[0];
        v18 = v9;
        do
        {
          v19 = (float)((float)((float)((float)(*((float *)this + 2) / v14) * (float)v10) - v12) / v15) * 3.14159265;
          v20 = cosf(v19);
          *v17++ = (float)(1.0 - (float)((float)(1.0 - v20) * 0.5)) + (float)((float)((float)(1.0 - v20) * 0.5) * 0.0);
          ++v10;
          --v18;
        }
        while (v18);
        v21 = (float *)__p[0];
        do
        {
          v22 = *v16++;
          *v21++ = 1.0 - v22;
          --v9;
        }
        while (v9);
      }
      v23 = *((_QWORD *)this + 11);
      if (v23 >= *((_QWORD *)this + 12))
      {
        v24 = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>((uint64_t *)this + 10, (uint64_t)v28);
      }
      else
      {
        std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>((uint64_t)this + 80, (uint64_t)v28);
        v24 = v23 + 24;
      }
      *((_QWORD *)this + 11) = v24;
      v25 = *((_QWORD *)this + 14);
      if (v25 >= *((_QWORD *)this + 15))
      {
        v26 = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(v2, (uint64_t)__p);
      }
      else
      {
        std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>((uint64_t)v2, (uint64_t)__p);
        v26 = v25 + 24;
      }
      *((_QWORD *)this + 14) = v26;
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (v28[0])
      {
        v28[1] = v28[0];
        operator delete(v28[0]);
      }
      v3 = *((_QWORD *)this + 7);
      v4 = ++v5;
    }
    while (v5 < (unint64_t)((*((_QWORD *)this + 8) - v3) >> 4));
  }
}

void sub_216605EB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t Phase::LookupInterpolator::GetSubbandCountBelowFirstFFTBin(Phase::LookupInterpolator *this)
{
  uint64_t v1;
  uint64_t result;

  v1 = *((unsigned int *)this + 1);
  if (!(_DWORD)v1)
    return (v1 - 1);
  result = 0;
  while (!(float)(*(float *)(*((_QWORD *)this + 2) + 4 * result)
                               / (float)(*((float *)this + 2) / (float)*(unsigned int *)this)))
  {
    if (v1 == ++result)
      return (v1 - 1);
  }
  return result;
}

void Phase::LookupInterpolator::InterpolateWithFractions(Phase::LookupInterpolator *this, float *a2, float *a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unsigned int v9;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  vDSP_Length v13;
  float v14;
  uint64_t v15;
  const float *v16;
  float *v17;
  int v18;
  vDSP_Length v19;
  float v20;
  float __B;
  float __C;

  __C = 0.0;
  vDSP_meanv(&a2[*((unsigned int *)this + 10)], 1, &__C, *((unsigned int *)this + 11));
  vDSP_vfill(&__C, &a3[*((unsigned int *)this + 12)], 1, *((unsigned int *)this + 13));
  v6 = *((_QWORD *)this + 7);
  v7 = *((_QWORD *)this + 8);
  if (v7 != v6)
  {
    v8 = 0;
    v9 = 1;
    do
    {
      v10 = (unsigned int *)(v6 + 16 * v8);
      v11 = *v10;
      v12 = v10[2];
      v13 = v10[3];
      v14 = a2[v11];
      v20 = a2[v10[1] + v11];
      __B = v14;
      v15 = 3 * v8;
      v16 = *(const float **)(*((_QWORD *)this + 13) + 8 * v15);
      v17 = &a3[v12];
      vDSP_vsma(*(const float **)(*((_QWORD *)this + 10) + 8 * v15), 1, &__B, v17, 1, v17, 1, v13);
      vDSP_vsma(v16, 1, &v20, v17, 1, v17, 1, v13);
      v8 = v9;
      v6 = *((_QWORD *)this + 7);
      v7 = *((_QWORD *)this + 8);
      ++v9;
    }
    while (v8 < (v7 - v6) >> 4);
  }
  *a3 = *a2;
  v18 = *(_DWORD *)(v7 - 4) + *(_DWORD *)(v7 - 8);
  v19 = ((*(_DWORD *)this >> 1) - v18 + 1);
  __B = a2[*((_DWORD *)this + 1) - 1];
  vDSP_vfill(&__B, &a3[v18], 1, v19);
}

_QWORD *std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *result;

  v3 = *(_QWORD **)(a1 + 8);
  *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  result = std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v3, *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
  *(_QWORD *)(a1 + 8) = v3 + 3;
  return result;
}

void sub_2166060CC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _QWORD v14[2];
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL)
    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x555555555555555)
    v9 = 0xAAAAAAAAAAAAAAALL;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  v15 = v11;
  v16 = &v10[24 * v9];
  *(_QWORD *)v11 = 0;
  *((_QWORD *)v11 + 1) = 0;
  *((_QWORD *)v11 + 2) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v11, *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
  v15 += 24;
  std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, v14);
  v12 = a1[1];
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_2166061D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void Phase::Zeppelin::MathUtils::Legendre(Phase::Zeppelin::MathUtils *this, int a2, long double a3)
{
  double v4;
  long double v5;
  NSObject *v6;
  std::logic_error *exception;
  NSObject *v8;
  std::logic_error *v9;
  int v10;
  const char *v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if (a2 > (int)this)
  {
    v6 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 928);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v10 = 136315394;
      v11 = "MathUtils.cpp";
      v12 = 1024;
      v13 = 40;
      _os_log_impl(&dword_2164CC000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [(inM > inN) is true]: ErrorDescriptions::kErrDescr_assocLegendreOrderGreaterThanDegree", (uint8_t *)&v10, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, (const char *)Phase::Zeppelin::ErrorDescriptions::kErrDescr_assocLegendreOrderGreaterThanDegree);
  }
  switch((int)this)
  {
    case 0:
    case 1:
    case 2:
      return;
    case 3:
      if (a2 != 2 && a2 != 1)
      {
        if (a2)
          pow(1.0 - a3 * a3, 1.5);
        else
          pow(a3, 3.0);
      }
      break;
    case 4:
      switch(a2)
      {
        case 0:
          pow(a3, 4.0);
          break;
        case 3:
          v4 = 1.0 - a3 * a3;
          v5 = 1.5;
          goto LABEL_83;
        default:
          return;
      }
      break;
    case 5:
      switch(a2)
      {
        case 0:
          pow(a3, 4.0);
          break;
        case 1:
          goto LABEL_54;
        case 2:
        case 4:
          return;
        case 3:
          pow(1.0 - a3 * a3, 1.5);
          break;
        default:
          pow(1.0 - a3 * a3, 2.5);
          break;
      }
      break;
    case 6:
      switch(a2)
      {
        case 0:
          pow(a3, 6.0);
          pow(a3, 4.0);
          break;
        case 1:
          pow(a3, 4.0);
          break;
        case 2:
          goto LABEL_54;
        case 3:
          pow(1.0 - a3 * a3, 1.5);
          break;
        case 4:
          return;
        case 5:
          v4 = 1.0 - a3 * a3;
          v5 = 2.5;
          goto LABEL_83;
        default:
          pow(1.0 - a3 * a3, 3.0);
          break;
      }
      break;
    case 7:
      switch(a2)
      {
        case 0:
          pow(a3, 6.0);
          pow(a3, 4.0);
          break;
        case 1:
          goto LABEL_46;
        case 2:
          pow(a3, 4.0);
          break;
        case 3:
          pow(1.0 - a3 * a3, 1.5);
          pow(a3, 4.0);
          break;
        case 4:
          return;
        case 5:
          goto LABEL_41;
        case 6:
          v4 = 1.0 - a3 * a3;
          v5 = 3.0;
          goto LABEL_83;
        default:
          pow(1.0 - a3 * a3, 3.5);
          break;
      }
      break;
    case 8:
      switch(a2)
      {
        case 0:
          pow(a3, 8.0);
          pow(a3, 6.0);
          pow(a3, 4.0);
          break;
        case 1:
          goto LABEL_46;
        case 2:
          pow(a3, 6.0);
          pow(a3, 4.0);
          break;
        case 3:
          pow(1.0 - a3 * a3, 1.5);
          pow(a3, 4.0);
          break;
        case 4:
          goto LABEL_54;
        case 5:
LABEL_41:
          pow(1.0 - a3 * a3, 2.5);
          break;
        case 6:
          pow(1.0 - a3 * a3, 3.0);
          break;
        case 7:
          v4 = 1.0 - a3 * a3;
          v5 = 3.5;
          goto LABEL_83;
        default:
          pow(1.0 - a3 * a3, 4.0);
          break;
      }
      break;
    case 9:
      switch(a2)
      {
        case 0:
          pow(a3, 9.0);
          pow(a3, 7.0);
          pow(a3, 5.0);
          pow(a3, 3.0);
          break;
        case 1:
          pow(a3, 8.0);
          pow(a3, 6.0);
          pow(a3, 4.0);
          break;
        case 2:
          pow(a3, 7.0);
          pow(a3, 5.0);
          pow(a3, 3.0);
          break;
        case 3:
LABEL_46:
          pow(a3, 6.0);
          pow(a3, 4.0);
          break;
        case 4:
          pow(a3, 5.0);
          pow(a3, 3.0);
          break;
        case 5:
LABEL_54:
          pow(a3, 4.0);
          break;
        case 6:
          pow(a3 * a3 + -1.0, 3.0);
          pow(a3, 3.0);
          break;
        case 7:
          pow(a3 * a3 + -1.0, 3.0);
          break;
        case 8:
          v4 = a3 * a3 + -1.0;
          v5 = 4.0;
          goto LABEL_83;
        default:
          pow(1.0 - a3 * a3, 4.5);
          break;
      }
      break;
    case 10:
      switch(a2)
      {
        case 0:
          pow(a3, 10.0);
          pow(a3, 8.0);
          pow(a3, 6.0);
          pow(a3, 4.0);
          break;
        case 1:
          pow(a3, 9.0);
          pow(a3, 7.0);
          pow(a3, 5.0);
          pow(a3, 3.0);
          break;
        case 2:
          pow(a3, 8.0);
          pow(a3, 6.0);
          pow(a3, 4.0);
          break;
        case 3:
          pow(a3, 7.0);
          pow(a3, 5.0);
          pow(a3, 3.0);
          break;
        case 4:
          pow(a3, 6.0);
          pow(a3, 4.0);
          break;
        case 5:
          pow(a3, 5.0);
          pow(a3, 3.0);
          break;
        case 6:
          pow(a3 * a3 + -1.0, 3.0);
          pow(a3, 4.0);
          break;
        case 7:
          pow(a3 * a3 + -1.0, 3.0);
          pow(a3, 3.0);
          break;
        case 8:
          pow(a3 * a3 + -1.0, 4.0);
          break;
        case 9:
          v4 = 1.0 - a3 * a3;
          v5 = 4.5;
          goto LABEL_83;
        default:
          pow(a3 * a3 + -1.0, 5.0);
          break;
      }
      break;
    case 11:
      switch(a2)
      {
        case 0:
          pow(a3, 11.0);
          pow(a3, 9.0);
          pow(a3, 7.0);
          pow(a3, 5.0);
          pow(a3, 3.0);
          break;
        case 1:
          goto LABEL_76;
        case 2:
          pow(a3, 9.0);
          pow(a3, 7.0);
          pow(a3, 5.0);
          pow(a3, 3.0);
          break;
        case 3:
          pow(1.0 - a3 * a3, 1.5);
          pow(a3, 8.0);
          pow(a3, 6.0);
          pow(a3, 4.0);
          break;
        case 4:
          pow(a3, 7.0);
          pow(a3, 5.0);
          pow(a3, 3.0);
          break;
        case 5:
          pow(1.0 - a3 * a3, 2.5);
          pow(a3, 6.0);
          pow(a3, 4.0);
          break;
        case 6:
          pow(a3 * a3 + -1.0, 3.0);
          pow(a3, 5.0);
          pow(a3, 3.0);
          break;
        case 7:
          pow(1.0 - a3 * a3, 3.5);
          pow(a3, 4.0);
          break;
        case 8:
          pow(a3 * a3 + -1.0, 4.0);
          pow(a3, 3.0);
          break;
        case 9:
          pow(1.0 - a3 * a3, 4.5);
          break;
        case 10:
          v4 = a3 * a3 + -1.0;
          v5 = 5.0;
          goto LABEL_83;
        default:
          pow(1.0 - a3 * a3, 5.5);
          break;
      }
      break;
    case 12:
      switch(a2)
      {
        case 0:
          pow(a3, 12.0);
          pow(a3, 10.0);
          pow(a3, 8.0);
          pow(a3, 6.0);
          pow(a3, 4.0);
          break;
        case 1:
          pow(a3, 11.0);
          pow(a3, 9.0);
          pow(a3, 7.0);
          pow(a3, 5.0);
          pow(a3, 3.0);
          break;
        case 2:
LABEL_76:
          pow(a3, 10.0);
          pow(a3, 8.0);
          pow(a3, 6.0);
          pow(a3, 4.0);
          break;
        case 3:
          pow(1.0 - a3 * a3, 1.5);
          pow(a3, 9.0);
          pow(a3, 7.0);
          pow(a3, 5.0);
          pow(a3, 3.0);
          break;
        case 4:
          pow(a3, 8.0);
          pow(a3, 6.0);
          pow(a3, 4.0);
          break;
        case 5:
          pow(1.0 - a3 * a3, 2.5);
          pow(a3, 7.0);
          pow(a3, 5.0);
          pow(a3, 3.0);
          break;
        case 6:
          pow(a3 * a3 + -1.0, 3.0);
          pow(a3, 6.0);
          pow(a3, 4.0);
          break;
        case 7:
          pow(1.0 - a3 * a3, 3.5);
          pow(a3, 5.0);
          pow(a3, 3.0);
          break;
        case 8:
          pow(a3 * a3 + -1.0, 4.0);
          pow(a3, 4.0);
          break;
        case 9:
          pow(1.0 - a3 * a3, 4.5);
          pow(a3, 3.0);
          break;
        case 10:
          pow(a3 * a3 + -1.0, 5.0);
          break;
        case 11:
          v4 = 1.0 - a3 * a3;
          v5 = 5.5;
LABEL_83:
          pow(v4, v5);
          break;
        default:
          pow(a3 * a3 + -1.0, 6.0);
          break;
      }
      break;
    default:
      v8 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 928);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v10 = 136315394;
        v11 = "MathUtils.cpp";
        v12 = 1024;
        v13 = 447;
        _os_log_impl(&dword_2164CC000, v8, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): ErrorDescriptions::kErrDescr_assocLegendreDegreeNotSupported", (uint8_t *)&v10, 0x12u);
      }
      v9 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](v9, (const char *)Phase::Zeppelin::ErrorDescriptions::kErrDescr_assocLegendreDegreeNotSupported);
  }
}

void sub_216607ED4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void Phase::Zeppelin::MathUtils::ComputeSphHankelYUpToOrder(Phase::Zeppelin::MathUtils *this@<X0>, long double a2@<D0>, double **a3@<X8>)
{
  unsigned int v5;
  unint64_t v6;
  double *v7;
  uint64_t v8;
  double v9;
  double v10;
  double *v11;
  double *v12;
  double v13;
  char *v14;
  double v15;
  char *v16;
  int64_t v17;
  unint64_t v18;
  int64_t v19;
  unint64_t v20;
  char *v21;
  double v22;
  char *v23;
  double *v24;
  double *v25;
  int v26;
  double v27;
  double v28;
  double v29;
  char *v30;
  void *v31;
  char *v32;
  int64_t v33;
  unint64_t v34;
  int64_t v35;
  unint64_t v36;
  char *v37;
  double *v38;
  uint64_t v39;
  double *v41;
  char *v42;
  char *v43;
  uint64_t v44;
  BOOL v45;
  double v46;
  double *v47;
  char *v48;
  uint64_t v49;
  double v50;
  double *v51;
  double *v52;
  uint64_t v53;
  unint64_t v54;
  int64_t v55;
  unint64_t v56;
  char *v57;
  double *v58;
  int64_t v59;
  unint64_t v60;
  int64_t v61;
  unint64_t v62;
  char *v63;
  char *v64;
  int64_t v65;
  unint64_t v66;
  unint64_t v67;
  char *v68;
  double *v69;
  char *v70;
  uint64_t v71;
  double *v72;
  uint64_t v73;
  double v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  char *v79;
  double *v80;
  uint64_t v81;
  double *v82;
  char *v83;
  uint64_t v84;
  double *v85;
  uint64_t v86;
  double v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  char *v91;
  double *v92;
  uint64_t v93;
  double *v94;
  double v95;
  char *v96;
  double v97;
  double *v98;
  char *v99;
  int64_t v100;
  unint64_t v101;
  int64_t v102;
  unint64_t v103;
  char *v104;
  double *v105;
  char *v106;
  uint64_t v107;
  double v108;
  double *v109;
  double *v110;
  uint64_t v111;
  unint64_t v112;
  int64_t v113;
  unint64_t v114;
  char *v115;
  double *v116;
  char *v117;
  uint64_t v118;
  double *v119;
  uint64_t v120;
  double v121;
  void *v122;
  uint64_t v123;
  unint64_t v124;
  uint64_t v125;
  unint64_t v126;
  char *v127;
  double *v128;
  uint64_t v129;
  double *v130;
  double *v131;
  double *v132;
  uint64_t v133;
  double v134;
  unint64_t v135;
  double *v136;
  double *v137;
  uint64_t v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  unint64_t v143;
  double *v144;
  NSObject *v145;
  std::logic_error *exception;
  void *__p[4];

  __p[3] = *(void **)MEMORY[0x24BDAC8D0];
  if (a2 <= 0.0)
  {
    v145 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 928);
    if (os_log_type_enabled(v145, OS_LOG_TYPE_ERROR))
    {
      LODWORD(__p[0]) = 136315394;
      *(void **)((char *)__p + 4) = "MathUtils.cpp";
      WORD2(__p[1]) = 1024;
      *(_DWORD *)((char *)&__p[1] + 6) = 634;
      _os_log_impl(&dword_2164CC000, v145, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [(0.0 >= inX) is true]: ErrorDescriptions::kErrDescr_sphHankelNegativeArgumentsNotSupported", (uint8_t *)__p, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, (const char *)Phase::Zeppelin::ErrorDescriptions::kErrDescr_sphHankelNegativeArgumentsNotSupported);
  }
  v5 = this;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v6 = ((_DWORD)this + 1);
  if ((_DWORD)this != -1)
  {
    v7 = (double *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::complex<double>>>(((_DWORD)this + 1));
    *a3 = v7;
    a3[1] = v7;
    a3[2] = &v7[2 * v8];
  }
  if ((double)v5 <= a2)
  {
    memset(__p, 0, 24);
    std::vector<double>::reserve(__p, v6);
    v13 = sin(a2);
    v14 = (char *)__p[1];
    v15 = v13 / a2;
    if (__p[1] >= __p[2])
    {
      v16 = (char *)__p[0];
      v17 = ((char *)__p[1] - (char *)__p[0]) >> 3;
      v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61)
        std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
      v19 = (char *)__p[2] - (char *)__p[0];
      if (((char *)__p[2] - (char *)__p[0]) >> 2 > v18)
        v18 = v19 >> 2;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
        v20 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v20 = v18;
      if (v20)
      {
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&__p[2], v20);
        v16 = (char *)__p[0];
        v14 = (char *)__p[1];
      }
      else
      {
        v21 = 0;
      }
      v47 = (double *)&v21[8 * v17];
      v48 = &v21[8 * v20];
      *v47 = v15;
      v12 = v47 + 1;
      while (v14 != v16)
      {
        v49 = *((_QWORD *)v14 - 1);
        v14 -= 8;
        *((_QWORD *)v47-- - 1) = v49;
      }
      __p[0] = v47;
      __p[1] = v12;
      __p[2] = v48;
      if (v16)
        operator delete(v16);
    }
    else
    {
      *(double *)__p[1] = v15;
      v12 = (double *)(v14 + 8);
    }
    __p[1] = v12;
    if (!v5)
      goto LABEL_141;
    v50 = v13 / (a2 * a2) - cos(a2) / a2;
    if (v12 >= __p[2])
    {
      v52 = (double *)__p[0];
      v53 = ((char *)v12 - (char *)__p[0]) >> 3;
      v54 = v53 + 1;
      if ((unint64_t)(v53 + 1) >> 61)
        std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
      v55 = (char *)__p[2] - (char *)__p[0];
      if (((char *)__p[2] - (char *)__p[0]) >> 2 > v54)
        v54 = v55 >> 2;
      if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8)
        v56 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v56 = v54;
      if (v56)
      {
        v57 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&__p[2], v56);
        v52 = (double *)__p[0];
        v12 = (double *)__p[1];
      }
      else
      {
        v57 = 0;
      }
      v69 = (double *)&v57[8 * v53];
      v70 = &v57[8 * v56];
      *v69 = v50;
      v51 = v69 + 1;
      while (v12 != v52)
      {
        v71 = *((_QWORD *)v12-- - 1);
        *((_QWORD *)v69-- - 1) = v71;
      }
      __p[0] = v69;
      __p[1] = v51;
      __p[2] = v70;
      if (v52)
        operator delete(v52);
    }
    else
    {
      *v12 = v50;
      v51 = v12 + 1;
    }
    __p[1] = v51;
    if (v5 >= 2)
    {
      v72 = (double *)__p[0];
      v73 = 2;
      do
      {
        v74 = -(v72[v73 - 2] - (double)(2 * (int)v73 - 1) * (v72[v73 - 1] / a2));
        if (v51 >= __p[2])
        {
          v75 = v51 - v72;
          v76 = v75 + 1;
          if ((unint64_t)(v75 + 1) >> 61)
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          v77 = (char *)__p[2] - (char *)v72;
          if (((char *)__p[2] - (char *)v72) >> 2 > v76)
            v76 = v77 >> 2;
          if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8)
            v78 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v78 = v76;
          if (v78)
          {
            v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&__p[2], v78);
            v72 = (double *)__p[0];
            v51 = (double *)__p[1];
          }
          else
          {
            v79 = 0;
          }
          v80 = (double *)&v79[8 * v75];
          *v80 = v74;
          v12 = v80 + 1;
          while (v51 != v72)
          {
            v81 = *((_QWORD *)v51-- - 1);
            *((_QWORD *)v80-- - 1) = v81;
          }
          __p[0] = v80;
          __p[1] = v12;
          __p[2] = &v79[8 * v78];
          if (v72)
          {
            operator delete(v72);
            v72 = (double *)__p[0];
          }
          else
          {
            v72 = v80;
          }
        }
        else
        {
          *v51 = v74;
          v12 = v51 + 1;
        }
        __p[1] = v12;
        ++v73;
        v51 = v12;
      }
      while (v73 != v6);
      goto LABEL_141;
    }
LABEL_125:
    v12 = v51;
    goto LABEL_141;
  }
  memset(__p, 0, 24);
  std::vector<double>::reserve(__p, v6);
  v9 = sin(a2);
  v10 = v9 / a2;
  if (v5 == 1)
  {
    v22 = v9;
    v23 = (char *)__p[1];
    v24 = (double *)__p[2];
    if (__p[1] >= __p[2])
    {
      v64 = (char *)__p[0];
      v65 = ((char *)__p[1] - (char *)__p[0]) >> 3;
      v66 = v65 + 1;
      if ((unint64_t)(v65 + 1) >> 61)
        goto LABEL_229;
      if (((char *)__p[2] - (char *)__p[0]) >> 2 > v66)
        v66 = ((char *)__p[2] - (char *)__p[0]) >> 2;
      if ((void *)((char *)__p[2] - (char *)__p[0]) >= (void *)0x7FFFFFFFFFFFFFF8)
        v67 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v67 = v66;
      if (v67)
      {
        v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&__p[2], v67);
        v64 = (char *)__p[0];
        v23 = (char *)__p[1];
      }
      else
      {
        v68 = 0;
      }
      v85 = (double *)&v68[8 * v65];
      v24 = (double *)&v68[8 * v67];
      *v85 = v10;
      v25 = v85 + 1;
      while (v23 != v64)
      {
        v86 = *((_QWORD *)v23 - 1);
        v23 -= 8;
        *((_QWORD *)v85-- - 1) = v86;
      }
      __p[0] = v85;
      __p[1] = v25;
      __p[2] = &v68[8 * v67];
      if (v64)
      {
        operator delete(v64);
        v24 = (double *)__p[2];
      }
    }
    else
    {
      *(double *)__p[1] = v10;
      v25 = (double *)(v23 + 8);
    }
    __p[1] = v25;
    v87 = v22 / (a2 * a2) - cos(a2) / a2;
    if (v25 >= v24)
    {
      v58 = (double *)__p[0];
      v88 = ((char *)v25 - (char *)__p[0]) >> 3;
      v89 = v88 + 1;
      if ((unint64_t)(v88 + 1) >> 61)
        std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
      if (((char *)v24 - (char *)__p[0]) >> 2 > v89)
        v89 = ((char *)v24 - (char *)__p[0]) >> 2;
      if ((unint64_t)((char *)v24 - (char *)__p[0]) >= 0x7FFFFFFFFFFFFFF8)
        v90 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v90 = v89;
      if (v90)
      {
        v91 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&__p[2], v90);
        v58 = (double *)__p[0];
        v25 = (double *)__p[1];
      }
      else
      {
        v91 = 0;
      }
      v92 = (double *)&v91[8 * v88];
      v83 = &v91[8 * v90];
      *v92 = v87;
      v12 = v92 + 1;
      while (v25 != v58)
      {
        v93 = *((_QWORD *)v25-- - 1);
        *((_QWORD *)v92-- - 1) = v93;
      }
      __p[0] = v92;
      goto LABEL_139;
    }
    *v25 = v87;
    v51 = v25 + 1;
    goto LABEL_125;
  }
  if (!v5)
  {
    v11 = (double *)__p[1];
    if (__p[1] < __p[2])
    {
      *(double *)__p[1] = v10;
      v12 = v11 + 1;
      goto LABEL_141;
    }
    v58 = (double *)__p[0];
    v59 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v60 = v59 + 1;
    if (!((unint64_t)(v59 + 1) >> 61))
    {
      v61 = (char *)__p[2] - (char *)__p[0];
      if (((char *)__p[2] - (char *)__p[0]) >> 2 > v60)
        v60 = v61 >> 2;
      if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFF8)
        v62 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v62 = v60;
      if (v62)
      {
        v63 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&__p[2], v62);
        v58 = (double *)__p[0];
        v11 = (double *)__p[1];
      }
      else
      {
        v63 = 0;
      }
      v82 = (double *)&v63[8 * v59];
      v83 = &v63[8 * v62];
      *v82 = v10;
      v12 = v82 + 1;
      while (v11 != v58)
      {
        v84 = *((_QWORD *)v11-- - 1);
        *((_QWORD *)v82-- - 1) = v84;
      }
      __p[0] = v82;
LABEL_139:
      __p[1] = v12;
      __p[2] = v83;
      if (v58)
        operator delete(v58);
      goto LABEL_141;
    }
LABEL_229:
    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
  }
  v26 = (int)(sqrt((double)v5) * 3.0) + v5;
  if (v26 >= 1)
  {
    v27 = 1.0;
    v28 = 0.0;
    do
    {
      v29 = -(v28 - (double)((2 * v26) | 1) / a2 * v27);
      if (v26 - 1 <= v5)
      {
        v30 = (char *)__p[1];
        if (__p[1] >= __p[2])
        {
          v32 = (char *)__p[0];
          v33 = ((char *)__p[1] - (char *)__p[0]) >> 3;
          v34 = v33 + 1;
          if ((unint64_t)(v33 + 1) >> 61)
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          v35 = (char *)__p[2] - (char *)__p[0];
          if (((char *)__p[2] - (char *)__p[0]) >> 2 > v34)
            v34 = v35 >> 2;
          if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8)
            v36 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v36 = v34;
          if (v36)
          {
            v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&__p[2], v36);
            v32 = (char *)__p[0];
            v30 = (char *)__p[1];
          }
          else
          {
            v37 = 0;
          }
          v38 = (double *)&v37[8 * v33];
          *v38 = v29;
          v31 = v38 + 1;
          while (v30 != v32)
          {
            v39 = *((_QWORD *)v30 - 1);
            v30 -= 8;
            *((_QWORD *)v38-- - 1) = v39;
          }
          __p[0] = v38;
          __p[1] = v31;
          __p[2] = &v37[8 * v36];
          if (v32)
            operator delete(v32);
        }
        else
        {
          *(double *)__p[1] = v29;
          v31 = v30 + 8;
        }
        __p[1] = v31;
      }
      v28 = v27;
      v27 = v29;
    }
    while (v26-- > 1);
  }
  v12 = (double *)__p[0];
  v41 = (double *)__p[1];
  if (__p[0] != __p[1])
  {
    v42 = (char *)__p[1] - 8;
    if ((char *)__p[1] - 8 > __p[0])
    {
      v43 = (char *)__p[0] + 8;
      do
      {
        v44 = *((_QWORD *)v43 - 1);
        *((_QWORD *)v43 - 1) = *(_QWORD *)v42;
        *(_QWORD *)v42 = v44;
        v42 -= 8;
        v45 = v43 >= v42;
        v43 += 8;
      }
      while (!v45);
    }
  }
  if (v12 != v41)
  {
    v46 = v10 / *v12;
    do
    {
      *v12 = v46 * *v12;
      ++v12;
    }
    while (v12 != v41);
    v12 = v41;
  }
LABEL_141:
  v94 = (double *)__p[0];
  memset(__p, 0, 24);
  std::vector<double>::reserve(__p, v6);
  v95 = -cos(a2);
  v96 = (char *)__p[1];
  v97 = v95 / a2;
  if (__p[1] >= __p[2])
  {
    v99 = (char *)__p[0];
    v100 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v101 = v100 + 1;
    if ((unint64_t)(v100 + 1) >> 61)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v102 = (char *)__p[2] - (char *)__p[0];
    if (((char *)__p[2] - (char *)__p[0]) >> 2 > v101)
      v101 = v102 >> 2;
    if ((unint64_t)v102 >= 0x7FFFFFFFFFFFFFF8)
      v103 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v103 = v101;
    if (v103)
    {
      v104 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&__p[2], v103);
      v99 = (char *)__p[0];
      v96 = (char *)__p[1];
    }
    else
    {
      v104 = 0;
    }
    v105 = (double *)&v104[8 * v100];
    v106 = &v104[8 * v103];
    *v105 = v97;
    v98 = v105 + 1;
    while (v96 != v99)
    {
      v107 = *((_QWORD *)v96 - 1);
      v96 -= 8;
      *((_QWORD *)v105-- - 1) = v107;
    }
    __p[0] = v105;
    __p[1] = v98;
    __p[2] = v106;
    if (v99)
      operator delete(v99);
  }
  else
  {
    *(double *)__p[1] = v97;
    v98 = (double *)(v96 + 8);
  }
  __p[1] = v98;
  if (v5)
  {
    v108 = v95 / (a2 * a2) - sin(a2) / a2;
    if (v98 >= __p[2])
    {
      v110 = (double *)__p[0];
      v111 = ((char *)v98 - (char *)__p[0]) >> 3;
      v112 = v111 + 1;
      if ((unint64_t)(v111 + 1) >> 61)
        std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
      v113 = (char *)__p[2] - (char *)__p[0];
      if (((char *)__p[2] - (char *)__p[0]) >> 2 > v112)
        v112 = v113 >> 2;
      if ((unint64_t)v113 >= 0x7FFFFFFFFFFFFFF8)
        v114 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v114 = v112;
      if (v114)
      {
        v115 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&__p[2], v114);
        v110 = (double *)__p[0];
        v98 = (double *)__p[1];
      }
      else
      {
        v115 = 0;
      }
      v116 = (double *)&v115[8 * v111];
      v117 = &v115[8 * v114];
      *v116 = v108;
      v109 = v116 + 1;
      while (v98 != v110)
      {
        v118 = *((_QWORD *)v98-- - 1);
        *((_QWORD *)v116-- - 1) = v118;
      }
      __p[0] = v116;
      __p[1] = v109;
      __p[2] = v117;
      if (v110)
        operator delete(v110);
    }
    else
    {
      *v98 = v108;
      v109 = v98 + 1;
    }
    __p[1] = v109;
    if (v5 >= 2)
    {
      v119 = (double *)__p[0];
      v120 = 2;
      do
      {
        v121 = -(v119[v120 - 2] - (double)(2 * (int)v120 - 1) * (v119[v120 - 1] / a2));
        if (v109 >= __p[2])
        {
          v123 = v109 - v119;
          v124 = v123 + 1;
          if ((unint64_t)(v123 + 1) >> 61)
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          v125 = (char *)__p[2] - (char *)v119;
          if (((char *)__p[2] - (char *)v119) >> 2 > v124)
            v124 = v125 >> 2;
          if ((unint64_t)v125 >= 0x7FFFFFFFFFFFFFF8)
            v126 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v126 = v124;
          if (v126)
          {
            v127 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&__p[2], v126);
            v119 = (double *)__p[0];
            v109 = (double *)__p[1];
          }
          else
          {
            v127 = 0;
          }
          v128 = (double *)&v127[8 * v123];
          *v128 = v121;
          v122 = v128 + 1;
          while (v109 != v119)
          {
            v129 = *((_QWORD *)v109-- - 1);
            *((_QWORD *)v128-- - 1) = v129;
          }
          __p[0] = v128;
          __p[1] = v122;
          __p[2] = &v127[8 * v126];
          if (v119)
          {
            operator delete(v119);
            v119 = (double *)__p[0];
          }
          else
          {
            v119 = v128;
          }
        }
        else
        {
          *v109 = v121;
          v122 = v109 + 1;
        }
        __p[1] = v122;
        ++v120;
        v109 = (double *)v122;
      }
      while (v120 != v6);
    }
  }
  v130 = (double *)__p[0];
  if (v94 != v12)
  {
    v131 = a3[1];
    v132 = v94;
    do
    {
      v133 = *(_QWORD *)v132;
      v134 = -*v130;
      v135 = (unint64_t)a3[2];
      if ((unint64_t)v131 >= v135)
      {
        v137 = *a3;
        v138 = ((char *)v131 - (char *)*a3) >> 4;
        v139 = v138 + 1;
        if ((unint64_t)(v138 + 1) >> 60)
          std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
        v140 = v135 - (_QWORD)v137;
        if (v140 >> 3 > v139)
          v139 = v140 >> 3;
        if ((unint64_t)v140 >= 0x7FFFFFFFFFFFFFF0)
          v141 = 0xFFFFFFFFFFFFFFFLL;
        else
          v141 = v139;
        if (v141)
          v141 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::complex<double>>>(v141);
        else
          v142 = 0;
        v143 = v141 + 16 * v138;
        *(_QWORD *)v143 = v133;
        *(double *)(v143 + 8) = v134;
        v144 = (double *)v143;
        if (v131 != v137)
        {
          do
          {
            *((_OWORD *)v144 - 1) = *((_OWORD *)v131 - 1);
            v144 -= 2;
            v131 -= 2;
          }
          while (v131 != v137);
          v131 = *a3;
        }
        v136 = (double *)(v143 + 16);
        *a3 = v144;
        a3[1] = (double *)(v143 + 16);
        a3[2] = (double *)(v141 + 16 * v142);
        if (v131)
          operator delete(v131);
      }
      else
      {
        *(_QWORD *)v131 = v133;
        v131[1] = v134;
        v136 = v131 + 2;
      }
      a3[1] = v136;
      ++v132;
      ++v130;
      v131 = v136;
    }
    while (v132 != v12);
    v130 = (double *)__p[0];
  }
  if (v130)
  {
    __p[1] = v130;
    operator delete(v130);
  }
  if (v94)
    operator delete(v94);
}

void sub_216608A60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  uint64_t v10;
  void *v12;

  if (__p)
    operator delete(__p);
  v12 = *(void **)v10;
  if (*(_QWORD *)v10)
  {
    *(_QWORD *)(v10 + 8) = v12;
    operator delete(v12);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<double>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_QWORD *)v11 - 1);
        v11 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::complex<double>>>(unint64_t a1)
{
  if (a1 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(16 * a1);
}

uint64_t *Phase::DspLayer::MatrixMixer1x12::GetNewRegistryEntry(Phase::DspLayer::MatrixMixer1x12 *this)
{
  char *v1;
  uint64_t *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v6[2];
  char v7;
  void *v8[2];
  char v9;
  void *v10[2];
  char v11;
  void *v12[2];
  char v13;
  void *v14[2];
  char v15;
  void *v16[2];
  char v17;
  void *v18[2];
  char v19;
  void *v20[2];
  char v21;
  void *__p[2];
  char v23;
  __int128 v24;
  char v25;
  __int128 v26;
  char v27;
  __int128 v28;
  char v29;
  __int128 v30;
  char v31;
  _QWORD v32[3];
  _QWORD *v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v1 = (char *)malloc_type_malloc(0x2A0uLL, 0x1050040B063AAFAuLL);
  *(_QWORD *)v1 = "Gain 0";
  *((_QWORD *)v1 + 1) = 0x500000000;
  *(_QWORD *)(v1 + 20) = 0x100000000;
  *((_DWORD *)v1 + 7) = 3;
  *((_OWORD *)v1 + 2) = xmmword_2166F7470;
  *((_QWORD *)v1 + 6) = 0x3FF0000000000000;
  *((_QWORD *)v1 + 7) = "Gain 1";
  *((_QWORD *)v1 + 8) = 0x500000001;
  *(_QWORD *)(v1 + 76) = 0x100000000;
  *((_DWORD *)v1 + 21) = 3;
  *(_OWORD *)(v1 + 88) = xmmword_2166F7470;
  *((_QWORD *)v1 + 13) = 0;
  *((_QWORD *)v1 + 14) = "Gain 2";
  *((_QWORD *)v1 + 15) = 0x500000002;
  *(_QWORD *)(v1 + 132) = 0x100000000;
  *((_DWORD *)v1 + 35) = 3;
  *((_OWORD *)v1 + 9) = xmmword_2166F7470;
  *((_QWORD *)v1 + 20) = 0;
  *((_QWORD *)v1 + 21) = "Gain 3";
  *((_QWORD *)v1 + 22) = 0x500000003;
  *(_QWORD *)(v1 + 188) = 0x100000000;
  *((_DWORD *)v1 + 49) = 3;
  *(_OWORD *)(v1 + 200) = xmmword_2166F7470;
  *((_QWORD *)v1 + 27) = 0;
  *((_QWORD *)v1 + 28) = "Gain 4";
  *((_QWORD *)v1 + 29) = 0x500000004;
  *(_QWORD *)(v1 + 244) = 0x100000000;
  *((_DWORD *)v1 + 63) = 3;
  *((_OWORD *)v1 + 16) = xmmword_2166F7470;
  *((_QWORD *)v1 + 34) = 0;
  *((_QWORD *)v1 + 35) = "Gain 5";
  *((_QWORD *)v1 + 36) = 0x500000005;
  *((_DWORD *)v1 + 75) = 0;
  *((_QWORD *)v1 + 38) = 0x300000001;
  *((_QWORD *)v1 + 39) = 0;
  *((_OWORD *)v1 + 20) = xmmword_2166F7480;
  *((_QWORD *)v1 + 42) = "Gain 6";
  *((_QWORD *)v1 + 43) = 0x500000006;
  *((_DWORD *)v1 + 89) = 0;
  *((_QWORD *)v1 + 45) = 0x300000001;
  *((_OWORD *)v1 + 23) = xmmword_2166F7470;
  *((_QWORD *)v1 + 48) = 0;
  *((_QWORD *)v1 + 49) = "Gain 7";
  *((_QWORD *)v1 + 50) = 0x500000007;
  *((_DWORD *)v1 + 103) = 0;
  *((_QWORD *)v1 + 52) = 0x300000001;
  *((_QWORD *)v1 + 53) = 0;
  *((_OWORD *)v1 + 27) = xmmword_2166F7480;
  *((_QWORD *)v1 + 56) = "Gain 8";
  *((_QWORD *)v1 + 57) = 0x500000008;
  *((_DWORD *)v1 + 117) = 0;
  *((_QWORD *)v1 + 59) = 0x300000001;
  *((_OWORD *)v1 + 30) = xmmword_2166F7470;
  *((_QWORD *)v1 + 62) = 0;
  *((_QWORD *)v1 + 63) = "Gain 9";
  *((_QWORD *)v1 + 64) = 0x500000009;
  *((_DWORD *)v1 + 131) = 0;
  *((_QWORD *)v1 + 66) = 0x300000001;
  *((_QWORD *)v1 + 67) = 0;
  *((_OWORD *)v1 + 34) = xmmword_2166F7480;
  *((_QWORD *)v1 + 70) = "Gain 10";
  *((_QWORD *)v1 + 71) = 0x50000000ALL;
  *((_DWORD *)v1 + 145) = 0;
  *((_QWORD *)v1 + 73) = 0x300000001;
  *((_OWORD *)v1 + 37) = xmmword_2166F7470;
  *((_QWORD *)v1 + 76) = 0;
  *((_QWORD *)v1 + 77) = "Gain 11";
  *((_QWORD *)v1 + 78) = 0x50000000BLL;
  *((_DWORD *)v1 + 159) = 0;
  *((_QWORD *)v1 + 80) = 0x300000001;
  *((_QWORD *)v1 + 81) = 0;
  *((_OWORD *)v1 + 41) = xmmword_2166F7480;
  v2 = (uint64_t *)operator new();
  v32[0] = &off_24D57EB98;
  v33 = v32;
  Phase::Controller::VoicePoolEntry::VoicePoolEntry((uint64_t)v2, "MatrixMixer1x12", 12, (uint64_t)v1, (uint64_t)v32);
  v3 = v33;
  if (v33 == v32)
  {
    v4 = 4;
    v3 = v32;
  }
  else
  {
    if (!v33)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  std::string::basic_string[abi:ne180100]<0>(&v30, "Input");
  Phase::Controller::VoicePoolEntry::AddInput(v2, &v30);
  if (v31 < 0)
    operator delete((void *)v30);
  std::string::basic_string[abi:ne180100]<0>(&v28, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, &v28);
  if (v29 < 0)
    operator delete((void *)v28);
  std::string::basic_string[abi:ne180100]<0>(&v26, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, &v26);
  if (v27 < 0)
    operator delete((void *)v26);
  std::string::basic_string[abi:ne180100]<0>(&v24, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, &v24);
  if (v25 < 0)
    operator delete((void *)v24);
  std::string::basic_string[abi:ne180100]<0>(__p, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)__p);
  if (v23 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(v20, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v20);
  if (v21 < 0)
    operator delete(v20[0]);
  std::string::basic_string[abi:ne180100]<0>(v18, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v18);
  if (v19 < 0)
    operator delete(v18[0]);
  std::string::basic_string[abi:ne180100]<0>(v16, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v16);
  if (v17 < 0)
    operator delete(v16[0]);
  std::string::basic_string[abi:ne180100]<0>(v14, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v14);
  if (v15 < 0)
    operator delete(v14[0]);
  std::string::basic_string[abi:ne180100]<0>(v12, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v12);
  if (v13 < 0)
    operator delete(v12[0]);
  std::string::basic_string[abi:ne180100]<0>(v10, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v10);
  if (v11 < 0)
    operator delete(v10[0]);
  std::string::basic_string[abi:ne180100]<0>(v8, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v8);
  if (v9 < 0)
    operator delete(v8[0]);
  std::string::basic_string[abi:ne180100]<0>(v6, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v6);
  if (v7 < 0)
    operator delete(v6[0]);
  return v2;
}

void sub_2166090DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,uint64_t a51,uint64_t a52,int a53,__int16 a54,char a55,char a56,uint64_t a57,uint64_t a58,int a59,__int16 a60,char a61,char a62)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Phase::DspLayer::MatrixMixer1x12::~MatrixMixer1x12(Phase::DspLayer::MatrixMixer1x12 *this)
{
  Phase::DspLayer::VoicePool::~VoicePool(this);
  JUMPOUT(0x2199F9D70);
}

void `anonymous namespace'::MatrixMixer1x12Slice::~MatrixMixer1x12Slice(_anonymous_namespace_::MatrixMixer1x12Slice *this)
{
  JUMPOUT(0x2199F9D70);
}

double `anonymous namespace'::MatrixMixer1x12Slice::Reset(_OWORD *a1)
{
  double result;

  __asm { FMOV            V0.4S, #1.0 }
  a1[1] = _Q0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[270] = 0u;
  a1[271] = 0u;
  a1[272] = 0u;
  a1[273] = 0u;
  a1[274] = 0u;
  a1[275] = 0u;
  a1[276] = 0u;
  a1[277] = 0u;
  a1[278] = 0u;
  a1[279] = 0u;
  a1[280] = 0u;
  a1[281] = 0u;
  (*(void (**)(_OWORD *))(*(_QWORD *)a1 + 48))(a1);
  result = 0.0;
  a1[564] = 0u;
  a1[563] = 0u;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x12Slice::Reset(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  _DWORD *v7;
  uint64_t result;

  v7 = (_DWORD *)(a1 + 4 * a3);
  v7[4] = 1065353216;
  v7[8] = 0;
  v7[12] = 0;
  v7[16] = 0;
  v7[20] = 0;
  v7[24] = 0;
  v7[28] = 0;
  v7[32] = 0;
  v7[36] = 0;
  v7[40] = 0;
  v7[44] = 0;
  v7[48] = 0;
  v7[52] = 0;
  v7[1080] = 0;
  v7[1084] = 0;
  v7[1088] = 0;
  v7[1092] = 0;
  v7[1096] = 0;
  v7[1100] = 0;
  v7[1104] = 0;
  v7[1108] = 0;
  v7[1112] = 0;
  v7[1116] = 0;
  v7[1120] = 0;
  v7[1124] = 0;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  *(_QWORD *)(a1 + 8 * a3 + 9008) = a4;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x12Slice::GetParameter(_anonymous_namespace_::MatrixMixer1x12Slice *this, int a2)
{
  uint64_t result;

  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      result = 0;
      break;
    default:
      result = 9;
      break;
  }
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x12Slice::SetParameter(_anonymous_namespace_::MatrixMixer1x12Slice *this, int a2, int a3, double a4)
{
  uint64_t result;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;

  switch(a2)
  {
    case 0:
      result = 0;
      v6 = a4;
      *((float *)this + a3 + 4) = v6;
      break;
    case 1:
      result = 0;
      v7 = a4;
      *((float *)this + a3 + 8) = v7;
      break;
    case 2:
      result = 0;
      v8 = a4;
      *((float *)this + a3 + 12) = v8;
      break;
    case 3:
      result = 0;
      v9 = a4;
      *((float *)this + a3 + 16) = v9;
      break;
    case 4:
      result = 0;
      v10 = a4;
      *((float *)this + a3 + 20) = v10;
      break;
    case 5:
      result = 0;
      v11 = a4;
      *((float *)this + a3 + 24) = v11;
      break;
    case 6:
      result = 0;
      v12 = a4;
      *((float *)this + a3 + 28) = v12;
      break;
    case 7:
      result = 0;
      v13 = a4;
      *((float *)this + a3 + 32) = v13;
      break;
    case 8:
      result = 0;
      v14 = a4;
      *((float *)this + a3 + 36) = v14;
      break;
    case 9:
      result = 0;
      v15 = a4;
      *((float *)this + a3 + 40) = v15;
      break;
    case 10:
      result = 0;
      v16 = a4;
      *((float *)this + a3 + 44) = v16;
      break;
    case 11:
      result = 0;
      v17 = a4;
      *((float *)this + a3 + 48) = v17;
      break;
    default:
      result = 9;
      break;
  }
  return result;
}

__n128 `anonymous namespace'::MatrixMixer1x12Slice::UpdateParameters(__n128 *a1)
{
  __n128 result;
  __n128 v3;
  __n128 v4;
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;
  __n128 v9;
  __n128 v10;
  __n128 v11;
  __n128 v12;
  __n128 v13;
  __n128 v14;
  __n128 v15;
  __n128 v16;
  __n128 v17;
  __n128 v18;
  __n128 v19;
  __n128 v20;
  __n128 v21;
  __n128 v22;
  __n128 v23;
  __n128 v24;
  __n128 v25;
  __n128 v26;

  v25 = a1[271];
  v26 = a1[270];
  v9 = a1[1];
  v23 = a1[272];
  v24 = a1[2];
  v22 = a1[273];
  v8 = a1[3];
  v20 = a1[274];
  v21 = a1[4];
  v19 = a1[275];
  v7 = a1[5];
  v17 = a1[276];
  v18 = a1[6];
  v16 = a1[277];
  v14 = a1[278];
  v15 = a1[8];
  v5 = a1[9];
  v6 = a1[7];
  v12 = a1[10];
  v13 = a1[279];
  v10 = a1[281];
  v11 = a1[280];
  v3 = a1[11];
  v4 = a1[12];
  memcpy(&a1[282], &a1[13], 0x1010uLL);
  a1[539] = v26;
  a1[540] = v9;
  a1[541] = v25;
  a1[542] = v24;
  a1[543] = v23;
  a1[544] = v8;
  a1[545] = v22;
  a1[546] = v21;
  a1[547] = v20;
  a1[548] = v7;
  a1[549] = v19;
  a1[550] = v18;
  a1[551] = v17;
  a1[552] = v6;
  a1[553] = v16;
  a1[554] = v15;
  a1[555] = v14;
  a1[556] = v5;
  a1[557] = v13;
  a1[558] = v12;
  a1[559] = v11;
  a1[560] = v3;
  a1[561] = v10;
  result = v4;
  a1[562] = v4;
  return result;
}

_DWORD *`anonymous namespace'::MatrixMixer1x12Slice::UpdateParameters(uint64_t a1, uint64_t a2, int a3)
{
  _DWORD *v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  _DWORD *v30;
  _DWORD *result;

  v3 = (_DWORD *)(a1 + 4 * a3);
  v4 = v3[1080];
  v5 = v3[4];
  v6 = v3[1084];
  v7 = a3;
  v8 = v3[8];
  v9 = v3[1088];
  v10 = v3[12];
  v11 = v3[1092];
  v12 = v3[16];
  v13 = v3[1096];
  v14 = v3[20];
  v15 = v3[1100];
  v16 = v3[24];
  v17 = v3[1104];
  v18 = v3[28];
  v19 = v3[1108];
  v20 = v3[32];
  v21 = v3[1112];
  v22 = v3[36];
  v23 = v3[1116];
  v24 = v3[40];
  v25 = v3[1120];
  v26 = v3[44];
  v27 = v3[1124];
  v28 = v3[48];
  v29 = v3[52];
  v3[1128] = v29;
  if ((int)v29 >= 1)
  {
    v30 = (_DWORD *)(a1 + 4 * v7);
    do
    {
      v30[1132] = v30[56];
      v30[1136] = v30[60];
      v30 += 8;
      --v29;
    }
    while (v29);
  }
  result = (_DWORD *)(a1 + 4 * v7);
  result[2156] = v4;
  result[2160] = v5;
  result[2164] = v6;
  result[2168] = v8;
  result[2172] = v9;
  result[2176] = v10;
  result[2180] = v11;
  result[2184] = v12;
  result[2188] = v13;
  result[2192] = v14;
  result[2196] = v15;
  result[2200] = v16;
  result[2204] = v17;
  result[2208] = v18;
  result[2212] = v19;
  result[2216] = v20;
  result[2220] = v21;
  result[2224] = v22;
  result[2228] = v23;
  result[2232] = v24;
  result[2236] = v25;
  result[2240] = v26;
  result[2244] = v27;
  result[2248] = v28;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x12Slice::Run(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int32x4_t v4;
  int64x2_t v5;
  uint64_t v6;
  float32x4_t *v7;
  float32x4_t v8;
  int32x4_t v9;
  int32x4_t v10;
  int8x16_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int v22;
  unint64_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  int8x16_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  int8x16_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  int8x16_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  int8x16_t v40;
  float32x4_t v41;
  int8x16_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  int8x16_t v46;
  float32x4_t v47;
  int8x16_t v48;

  v4 = (int32x4_t)vandq_s8(*(int8x16_t *)(result + 4512), (int8x16_t)vcgtq_s32(vdupq_n_s32(a4), (int32x4_t)xmmword_2166F76B0));
  v5 = (int64x2_t)vcgtzq_s32(v4);
  if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0])
  {
    v6 = *(_QWORD *)(a2 + 56);
    v7 = (float32x4_t *)(result + 4544);
    v8 = 0uLL;
    v9 = 0uLL;
    v10.i64[0] = 0x100000001;
    v10.i64[1] = 0x100000001;
    do
    {
      v11.i32[0] = *(_DWORD *)(v6 + 4 * v7[-1].i32[0]);
      v11.i32[1] = *(_DWORD *)(v6 + 4 * v7[-1].i32[1]);
      v11.i32[2] = *(_DWORD *)(v6 + 4 * v7[-1].i32[2]);
      v11.i32[3] = *(_DWORD *)(v6 + 4 * v7[-1].i32[3]);
      v8 = vmlaq_f32(v8, (float32x4_t)vandq_s8((int8x16_t)v5, v11), *v7);
      v9 = vaddq_s32(v9, v10);
      v5 = (int64x2_t)vcgtq_s32(v4, v9);
      v7 += 2;
    }
    while (vorrq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0]);
  }
  else
  {
    v8 = 0uLL;
  }
  v12 = *(float32x4_t *)(result + 8672);
  v13 = *(float32x4_t *)(result + 8704);
  v14 = *(float32x4_t *)(result + 8736);
  v15 = *(float32x4_t *)(result + 8768);
  v16 = *(float32x4_t *)(result + 8800);
  v17 = *(float32x4_t *)(result + 8832);
  v18 = *(float32x4_t *)(result + 8864);
  v19 = *(float32x4_t *)(result + 8896);
  v20 = *(float32x4_t *)(result + 8928);
  v21 = *(float32x4_t *)(result + 8960);
  HIDWORD(v23) = a4 - 1;
  LODWORD(v23) = a4 - 1;
  v22 = v23 >> 1;
  v24 = *(float32x4_t *)(result + 8992);
  v25 = vmulq_f32(*(float32x4_t *)(result + 8640), v8);
  v26 = vandq_s8((int8x16_t)v25, vorrq_s8((int8x16_t)vcltzq_f32(v25), (int8x16_t)vcgezq_f32(v25)));
  switch(v22)
  {
    case 0:
      goto LABEL_10;
    case 1:
      goto LABEL_9;
    case 3:
      goto LABEL_8;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8636)) = v26.i32[3];
LABEL_8:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8632)) = v26.i32[2];
LABEL_9:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8628)) = v26.i32[1];
LABEL_10:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8624)) = v26.i32[0];
      break;
    default:
      break;
  }
  v27 = vmulq_f32(v12, v8);
  v28 = vandq_s8((int8x16_t)v27, vorrq_s8((int8x16_t)vcltzq_f32(v27), (int8x16_t)vcgezq_f32(v27)));
  switch(v22)
  {
    case 0:
      goto LABEL_15;
    case 1:
      goto LABEL_14;
    case 3:
      goto LABEL_13;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8668)) = v28.i32[3];
LABEL_13:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8664)) = v28.i32[2];
LABEL_14:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8660)) = v28.i32[1];
LABEL_15:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8656)) = v28.i32[0];
      break;
    default:
      break;
  }
  v29 = vmulq_f32(v13, v8);
  v30 = vandq_s8((int8x16_t)v29, vorrq_s8((int8x16_t)vcltzq_f32(v29), (int8x16_t)vcgezq_f32(v29)));
  switch(v22)
  {
    case 0:
      goto LABEL_20;
    case 1:
      goto LABEL_19;
    case 3:
      goto LABEL_18;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8700)) = v30.i32[3];
LABEL_18:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8696)) = v30.i32[2];
LABEL_19:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8692)) = v30.i32[1];
LABEL_20:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8688)) = v30.i32[0];
      break;
    default:
      break;
  }
  v31 = vmulq_f32(v14, v8);
  v32 = vandq_s8((int8x16_t)v31, vorrq_s8((int8x16_t)vcltzq_f32(v31), (int8x16_t)vcgezq_f32(v31)));
  switch(v22)
  {
    case 0:
      goto LABEL_25;
    case 1:
      goto LABEL_24;
    case 3:
      goto LABEL_23;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8732)) = v32.i32[3];
LABEL_23:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8728)) = v32.i32[2];
LABEL_24:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8724)) = v32.i32[1];
LABEL_25:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8720)) = v32.i32[0];
      break;
    default:
      break;
  }
  v33 = vmulq_f32(v15, v8);
  v34 = vandq_s8((int8x16_t)v33, vorrq_s8((int8x16_t)vcltzq_f32(v33), (int8x16_t)vcgezq_f32(v33)));
  switch(v22)
  {
    case 0:
      goto LABEL_30;
    case 1:
      goto LABEL_29;
    case 3:
      goto LABEL_28;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8764)) = v34.i32[3];
LABEL_28:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8760)) = v34.i32[2];
LABEL_29:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8756)) = v34.i32[1];
LABEL_30:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8752)) = v34.i32[0];
      break;
    default:
      break;
  }
  v35 = vmulq_f32(v16, v8);
  v36 = vandq_s8((int8x16_t)v35, vorrq_s8((int8x16_t)vcltzq_f32(v35), (int8x16_t)vcgezq_f32(v35)));
  switch(v22)
  {
    case 0:
      goto LABEL_35;
    case 1:
      goto LABEL_34;
    case 3:
      goto LABEL_33;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8796)) = v36.i32[3];
LABEL_33:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8792)) = v36.i32[2];
LABEL_34:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8788)) = v36.i32[1];
LABEL_35:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8784)) = v36.i32[0];
      break;
    default:
      break;
  }
  v37 = vmulq_f32(v17, v8);
  v38 = vandq_s8((int8x16_t)v37, vorrq_s8((int8x16_t)vcltzq_f32(v37), (int8x16_t)vcgezq_f32(v37)));
  switch(v22)
  {
    case 0:
      goto LABEL_40;
    case 1:
      goto LABEL_39;
    case 3:
      goto LABEL_38;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8828)) = v38.i32[3];
LABEL_38:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8824)) = v38.i32[2];
LABEL_39:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8820)) = v38.i32[1];
LABEL_40:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8816)) = v38.i32[0];
      break;
    default:
      break;
  }
  v39 = vmulq_f32(v18, v8);
  v40 = vandq_s8((int8x16_t)v39, vorrq_s8((int8x16_t)vcltzq_f32(v39), (int8x16_t)vcgezq_f32(v39)));
  switch(v22)
  {
    case 0:
      goto LABEL_45;
    case 1:
      goto LABEL_44;
    case 3:
      goto LABEL_43;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8860)) = v40.i32[3];
LABEL_43:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8856)) = v40.i32[2];
LABEL_44:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8852)) = v40.i32[1];
LABEL_45:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8848)) = v40.i32[0];
      break;
    default:
      break;
  }
  v41 = vmulq_f32(v19, v8);
  v42 = vandq_s8((int8x16_t)v41, vorrq_s8((int8x16_t)vcltzq_f32(v41), (int8x16_t)vcgezq_f32(v41)));
  switch(v22)
  {
    case 0:
      goto LABEL_50;
    case 1:
      goto LABEL_49;
    case 3:
      goto LABEL_48;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8892)) = v42.i32[3];
LABEL_48:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8888)) = v42.i32[2];
LABEL_49:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8884)) = v42.i32[1];
LABEL_50:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8880)) = v42.i32[0];
      break;
    default:
      break;
  }
  v43 = vmulq_f32(v20, v8);
  v44 = vandq_s8((int8x16_t)v43, vorrq_s8((int8x16_t)vcltzq_f32(v43), (int8x16_t)vcgezq_f32(v43)));
  switch(v22)
  {
    case 0:
      goto LABEL_55;
    case 1:
      goto LABEL_54;
    case 3:
      goto LABEL_53;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8924)) = v44.i32[3];
LABEL_53:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8920)) = v44.i32[2];
LABEL_54:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8916)) = v44.i32[1];
LABEL_55:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8912)) = v44.i32[0];
      break;
    default:
      break;
  }
  v45 = vmulq_f32(v21, v8);
  v46 = vandq_s8((int8x16_t)v45, vorrq_s8((int8x16_t)vcltzq_f32(v45), (int8x16_t)vcgezq_f32(v45)));
  switch(v22)
  {
    case 0:
      goto LABEL_60;
    case 1:
      goto LABEL_59;
    case 3:
      goto LABEL_58;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8956)) = v46.i32[3];
LABEL_58:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8952)) = v46.i32[2];
LABEL_59:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8948)) = v46.i32[1];
LABEL_60:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8944)) = v46.i32[0];
      break;
    default:
      break;
  }
  v47 = vmulq_f32(v24, v8);
  v48 = vandq_s8((int8x16_t)v47, vorrq_s8((int8x16_t)vcltzq_f32(v47), (int8x16_t)vcgezq_f32(v47)));
  switch(v22)
  {
    case 0:
      goto LABEL_65;
    case 1:
      goto LABEL_64;
    case 3:
      goto LABEL_63;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8988)) = v48.i32[3];
LABEL_63:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8984)) = v48.i32[2];
LABEL_64:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8980)) = v48.i32[1];
LABEL_65:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8976)) = v48.i32[0];
      break;
    default:
      return result;
  }
  return result;
}

float `anonymous namespace'::MatrixMixer1x12Slice::CopyVoiceState(_anonymous_namespace_::MatrixMixer1x12Slice *this, Phase::DspLayer::VoicePoolSlice *a2, int a3, int a4)
{
  _DWORD *v4;
  _DWORD *v5;
  uint64_t v6;
  _DWORD *v7;
  int *v8;
  int v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _DWORD *v13;
  int *v14;
  int v15;
  float result;

  v4 = (_DWORD *)((char *)a2 + 4 * a3);
  v5 = (_DWORD *)((char *)this + 4 * a4);
  v5[4] = v4[4];
  v5[8] = v4[8];
  v5[12] = v4[12];
  v5[16] = v4[16];
  v5[20] = v4[20];
  v5[24] = v4[24];
  v5[28] = v4[28];
  v5[32] = v4[32];
  v5[36] = v4[36];
  v5[40] = v4[40];
  v5[44] = v4[44];
  v5[48] = v4[48];
  v6 = v4[52];
  v5[52] = v6;
  if ((int)v6 >= 1)
  {
    v7 = (_DWORD *)((char *)this + 4 * a4 + 240);
    v8 = (int *)((char *)a2 + 4 * a3 + 240);
    do
    {
      *(v7 - 4) = *(v8 - 4);
      v9 = *v8;
      v8 += 8;
      *v7 = v9;
      v7 += 8;
      --v6;
    }
    while (v6);
  }
  v10 = (char *)this + 4 * a4;
  v11 = (char *)a2 + 4 * a3;
  v12 = *((unsigned int *)v11 + 1128);
  *((_DWORD *)v10 + 1128) = v12;
  if ((int)v12 >= 1)
  {
    v13 = v10 + 4544;
    v14 = (int *)(v11 + 4544);
    do
    {
      *(v13 - 4) = *(v14 - 4);
      v15 = *v14;
      v14 += 8;
      *v13 = v15;
      v13 += 8;
      --v12;
    }
    while (v12);
  }
  *((_DWORD *)v10 + 1080) = *((_DWORD *)v11 + 1080);
  *((_DWORD *)v10 + 1084) = *((_DWORD *)v11 + 1084);
  *((_DWORD *)v10 + 1088) = *((_DWORD *)v11 + 1088);
  *((_DWORD *)v10 + 1092) = *((_DWORD *)v11 + 1092);
  *((_DWORD *)v10 + 1096) = *((_DWORD *)v11 + 1096);
  *((_DWORD *)v10 + 1100) = *((_DWORD *)v11 + 1100);
  *((_DWORD *)v10 + 1104) = *((_DWORD *)v11 + 1104);
  *((_DWORD *)v10 + 1108) = *((_DWORD *)v11 + 1108);
  *((_DWORD *)v10 + 1112) = *((_DWORD *)v11 + 1112);
  *((_DWORD *)v10 + 1116) = *((_DWORD *)v11 + 1116);
  *((_DWORD *)v10 + 1120) = *((_DWORD *)v11 + 1120);
  *((_DWORD *)v10 + 1124) = *((_DWORD *)v11 + 1124);
  *((_DWORD *)v10 + 2156) = *((_DWORD *)v11 + 2156);
  *((_DWORD *)v10 + 2160) = *((_DWORD *)v11 + 2160);
  *((_DWORD *)v10 + 2164) = *((_DWORD *)v11 + 2164);
  *((_DWORD *)v10 + 2168) = *((_DWORD *)v11 + 2168);
  *((_DWORD *)v10 + 2172) = *((_DWORD *)v11 + 2172);
  *((_DWORD *)v10 + 2176) = *((_DWORD *)v11 + 2176);
  *((_DWORD *)v10 + 2180) = *((_DWORD *)v11 + 2180);
  *((_DWORD *)v10 + 2184) = *((_DWORD *)v11 + 2184);
  *((_DWORD *)v10 + 2188) = *((_DWORD *)v11 + 2188);
  *((_DWORD *)v10 + 2192) = *((_DWORD *)v11 + 2192);
  *((_DWORD *)v10 + 2196) = *((_DWORD *)v11 + 2196);
  *((_DWORD *)v10 + 2200) = *((_DWORD *)v11 + 2200);
  *((_DWORD *)v10 + 2204) = *((_DWORD *)v11 + 2204);
  *((_DWORD *)v10 + 2208) = *((_DWORD *)v11 + 2208);
  *((_DWORD *)v10 + 2212) = *((_DWORD *)v11 + 2212);
  *((_DWORD *)v10 + 2216) = *((_DWORD *)v11 + 2216);
  *((_DWORD *)v10 + 2220) = *((_DWORD *)v11 + 2220);
  *((_DWORD *)v10 + 2224) = *((_DWORD *)v11 + 2224);
  *((_DWORD *)v10 + 2228) = *((_DWORD *)v11 + 2228);
  *((_DWORD *)v10 + 2232) = *((_DWORD *)v11 + 2232);
  *((_DWORD *)v10 + 2236) = *((_DWORD *)v11 + 2236);
  *((_DWORD *)v10 + 2240) = *((_DWORD *)v11 + 2240);
  *((_DWORD *)v10 + 2244) = *((_DWORD *)v11 + 2244);
  result = *((float *)v11 + 2248);
  *((float *)v10 + 2248) = result;
  *((_QWORD *)this + a4 + 1126) = *((_QWORD *)a2 + a3 + 1126);
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x12Slice::AddInput(_anonymous_namespace_::MatrixMixer1x12Slice *this, int a2, int a3, int a4, float a5)
{
  uint64_t result;
  char *v7;
  uint64_t v8;
  char *v9;

  if (a2)
    return 8;
  v7 = (char *)this + 208;
  v8 = *((int *)this + a3 + 52);
  if ((int)v8 > 127)
    return 6;
  result = 0;
  v9 = (char *)this + 32 * v8 + 4 * a3;
  *((_DWORD *)v9 + 56) = a4;
  *((float *)v9 + 60) = a5;
  *(_DWORD *)&v7[4 * a3] = v8 + 1;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x12Slice::RemoveInput(_anonymous_namespace_::MatrixMixer1x12Slice *this, int a2, int a3, int a4)
{
  if (a2)
    return 8;
  else
    return Phase::DspLayer::VoiceConnectionList<128>::RemoveConnection((uint64_t)this + 208, a3, a4);
}

uint64_t `anonymous namespace'::MatrixMixer1x12Slice::SetInputGain(_anonymous_namespace_::MatrixMixer1x12Slice *this, int a2, int a3, int a4, float a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  float *i;

  if (a2)
    return 8;
  v6 = *((unsigned int *)this + a3 + 52);
  if ((int)v6 < 1)
    return 7;
  v7 = 0;
  for (i = (float *)((char *)this + 4 * a3 + 240); *((_DWORD *)i - 4) != a4; i += 8)
  {
    if (v6 == ++v7)
      return 7;
  }
  if ((v7 & 0x80000000) != 0)
    return 7;
  result = 0;
  *i = a5;
  return result;
}

void `anonymous namespace'::MatrixMixer1x12Slice::GetInputs(_anonymous_namespace_::MatrixMixer1x12Slice *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (a2)
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    *(_QWORD *)(a4 + 16) = 0;
  }
  else
  {
    Phase::DspLayer::VoiceConnectionList<128>::GetConnections((uint64_t)this + 208, a3, (char **)a4);
  }
}

uint64_t `anonymous namespace'::MatrixMixer1x12Slice::ClearInputs(_anonymous_namespace_::MatrixMixer1x12Slice *this, int a2)
{
  *((_DWORD *)this + a2 + 52) = 0;
  return 0;
}

uint64_t `anonymous namespace'::MatrixMixer1x12Slice::GetMaximumInputConnectionCount(_anonymous_namespace_::MatrixMixer1x12Slice *this, int a2)
{
  return (a2 == 0) << 7;
}

unint64_t `anonymous namespace'::MatrixMixer1x12Slice::GetOutput(_anonymous_namespace_::MatrixMixer1x12Slice *this, int a2, int a3)
{
  char *v3;
  uint64_t v4;
  unint64_t result;

  switch(a2)
  {
    case 0:
      v3 = (char *)this + 4 * a3;
      v4 = 4320;
      goto LABEL_14;
    case 1:
      v3 = (char *)this + 4 * a3;
      v4 = 4336;
      goto LABEL_14;
    case 2:
      v3 = (char *)this + 4 * a3;
      v4 = 4352;
      goto LABEL_14;
    case 3:
      v3 = (char *)this + 4 * a3;
      v4 = 4368;
      goto LABEL_14;
    case 4:
      v3 = (char *)this + 4 * a3;
      v4 = 4384;
      goto LABEL_14;
    case 5:
      v3 = (char *)this + 4 * a3;
      v4 = 4400;
      goto LABEL_14;
    case 6:
      v3 = (char *)this + 4 * a3;
      v4 = 4416;
      goto LABEL_14;
    case 7:
      v3 = (char *)this + 4 * a3;
      v4 = 4432;
      goto LABEL_14;
    case 8:
      v3 = (char *)this + 4 * a3;
      v4 = 4448;
      goto LABEL_14;
    case 9:
      v3 = (char *)this + 4 * a3;
      v4 = 4464;
      goto LABEL_14;
    case 10:
      v3 = (char *)this + 4 * a3;
      v4 = 4480;
      goto LABEL_14;
    case 11:
      v3 = (char *)this + 4 * a3;
      v4 = 4496;
LABEL_14:
      result = (unint64_t)*(unsigned int *)&v3[v4] << 32;
      break;
    default:
      result = 0xFFFFFFFF00000008;
      break;
  }
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x12Slice::SetOutput(_anonymous_namespace_::MatrixMixer1x12Slice *this, int a2, int a3, int a4)
{
  char *v4;
  uint64_t v5;
  uint64_t result;

  switch(a2)
  {
    case 0:
      v4 = (char *)this + 4 * a3;
      v5 = 4320;
      goto LABEL_14;
    case 1:
      v4 = (char *)this + 4 * a3;
      v5 = 4336;
      goto LABEL_14;
    case 2:
      v4 = (char *)this + 4 * a3;
      v5 = 4352;
      goto LABEL_14;
    case 3:
      v4 = (char *)this + 4 * a3;
      v5 = 4368;
      goto LABEL_14;
    case 4:
      v4 = (char *)this + 4 * a3;
      v5 = 4384;
      goto LABEL_14;
    case 5:
      v4 = (char *)this + 4 * a3;
      v5 = 4400;
      goto LABEL_14;
    case 6:
      v4 = (char *)this + 4 * a3;
      v5 = 4416;
      goto LABEL_14;
    case 7:
      v4 = (char *)this + 4 * a3;
      v5 = 4432;
      goto LABEL_14;
    case 8:
      v4 = (char *)this + 4 * a3;
      v5 = 4448;
      goto LABEL_14;
    case 9:
      v4 = (char *)this + 4 * a3;
      v5 = 4464;
      goto LABEL_14;
    case 10:
      v4 = (char *)this + 4 * a3;
      v5 = 4480;
      goto LABEL_14;
    case 11:
      v4 = (char *)this + 4 * a3;
      v5 = 4496;
LABEL_14:
      result = 0;
      *(_DWORD *)&v4[v5] = a4;
      break;
    default:
      result = 8;
      break;
  }
  return result;
}

void std::__function::__func<Phase::DspLayer::MatrixMixer1x12::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::MatrixMixer1x12::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<Phase::DspLayer::MatrixMixer1x12::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::MatrixMixer1x12::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57EB98;
  return result;
}

void std::__function::__func<Phase::DspLayer::MatrixMixer1x12::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::MatrixMixer1x12::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57EB98;
}

uint64_t std::__function::__func<Phase::DspLayer::MatrixMixer1x12::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::MatrixMixer1x12::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::operator()(uint64_t a1, Phase::DspLayer::VoiceEngine **a2, int *a3)
{
  Phase::DspLayer::VoiceEngine *v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v12;
  __int128 v14;

  v3 = *a2;
  v4 = *a3;
  v5 = operator new();
  Phase::DspLayer::VoicePool::VoicePool((Phase::DspLayer::VoicePool *)v5, "MatrixMixer1x12", v3, v4, 9040);
  *(_QWORD *)v5 = &off_24D57EAA0;
  if (*(int *)(v5 + 40) >= 1)
  {
    v6 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    v14 = _Q0;
    do
    {
      v12 = *(_QWORD *)(v5 + 24) + *(int *)(v5 + 16) * (uint64_t)v6;
      *(_QWORD *)v12 = &off_24D57EAC0;
      *(_QWORD *)(v12 + 8) = 0;
      bzero((void *)(v12 + 224), 0x1000uLL);
      bzero((void *)(v12 + 4512), 0x1010uLL);
      *(_OWORD *)(v12 + 16) = v14;
      *(_OWORD *)(v12 + 32) = 0u;
      *(_OWORD *)(v12 + 48) = 0u;
      *(_OWORD *)(v12 + 64) = 0u;
      *(_OWORD *)(v12 + 80) = 0u;
      *(_OWORD *)(v12 + 96) = 0u;
      *(_OWORD *)(v12 + 112) = 0u;
      *(_OWORD *)(v12 + 128) = 0u;
      *(_OWORD *)(v12 + 144) = 0u;
      *(_OWORD *)(v12 + 160) = 0u;
      *(_OWORD *)(v12 + 176) = 0u;
      *(_OWORD *)(v12 + 192) = 0u;
      *(_OWORD *)(v12 + 208) = 0u;
      *(_OWORD *)(v12 + 4320) = 0u;
      *(_OWORD *)(v12 + 4336) = 0u;
      *(_OWORD *)(v12 + 4352) = 0u;
      *(_OWORD *)(v12 + 4368) = 0u;
      *(_OWORD *)(v12 + 4384) = 0u;
      *(_OWORD *)(v12 + 4400) = 0u;
      *(_OWORD *)(v12 + 4416) = 0u;
      *(_OWORD *)(v12 + 4432) = 0u;
      *(_OWORD *)(v12 + 4448) = 0u;
      *(_OWORD *)(v12 + 4464) = 0u;
      *(_OWORD *)(v12 + 4480) = 0u;
      *(_OWORD *)(v12 + 4496) = 0u;
      *(_OWORD *)(v12 + 9024) = 0u;
      *(_OWORD *)(v12 + 9008) = 0u;
      ++v6;
    }
    while (v6 < *(_DWORD *)(v5 + 40));
  }
  return v5;
}

void sub_21660A47C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199F9D70](v1, 0x10F1C408EBD29CELL);
  _Unwind_Resume(a1);
}

uint64_t *Phase::DspLayer::MatrixMixer1x2::GetNewRegistryEntry(Phase::DspLayer::MatrixMixer1x2 *this)
{
  char *v1;
  uint64_t *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v6[2];
  char v7;
  void *v8[2];
  char v9;
  void *__p[2];
  char v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v1 = (char *)malloc_type_malloc(0x70uLL, 0x1050040B063AAFAuLL);
  *(_QWORD *)v1 = "Gain 0";
  *((_QWORD *)v1 + 1) = 0x500000000;
  *(_QWORD *)(v1 + 20) = 0x100000000;
  *((_DWORD *)v1 + 7) = 3;
  *((_OWORD *)v1 + 2) = xmmword_2166F7470;
  *((_QWORD *)v1 + 6) = 0x3FF0000000000000;
  *((_QWORD *)v1 + 7) = "Gain 1";
  *((_QWORD *)v1 + 8) = 0x500000001;
  *(_QWORD *)(v1 + 76) = 0x100000000;
  *((_DWORD *)v1 + 21) = 3;
  *(_OWORD *)(v1 + 88) = xmmword_2166F7470;
  *((_QWORD *)v1 + 13) = 0;
  v2 = (uint64_t *)operator new();
  v12[0] = &off_24D57ECD8;
  v13 = v12;
  Phase::Controller::VoicePoolEntry::VoicePoolEntry((uint64_t)v2, "MatrixMixer1x2", 2, (uint64_t)v1, (uint64_t)v12);
  v3 = v13;
  if (v13 == v12)
  {
    v4 = 4;
    v3 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  std::string::basic_string[abi:ne180100]<0>(__p, "Input");
  Phase::Controller::VoicePoolEntry::AddInput(v2, (__int128 *)__p);
  if (v11 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(v8, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v8);
  if (v9 < 0)
    operator delete(v8[0]);
  std::string::basic_string[abi:ne180100]<0>(v6, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v6);
  if (v7 < 0)
    operator delete(v6[0]);
  return v2;
}

void sub_21660A670(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Phase::DspLayer::MatrixMixer1x2::~MatrixMixer1x2(Phase::DspLayer::MatrixMixer1x2 *this)
{
  Phase::DspLayer::VoicePool::~VoicePool(this);
  JUMPOUT(0x2199F9D70);
}

void `anonymous namespace'::MatrixMixer1x2Slice::~MatrixMixer1x2Slice(_anonymous_namespace_::MatrixMixer1x2Slice *this)
{
  JUMPOUT(0x2199F9D70);
}

double `anonymous namespace'::MatrixMixer1x2Slice::Reset(_OWORD *a1)
{
  double result;

  __asm { FMOV            V0.4S, #1.0 }
  a1[1] = _Q0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[260] = 0u;
  a1[261] = 0u;
  (*(void (**)(_OWORD *))(*(_QWORD *)a1 + 48))(a1);
  result = 0.0;
  a1[524] = 0u;
  a1[523] = 0u;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x2Slice::Reset(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  _DWORD *v7;
  uint64_t result;

  v7 = (_DWORD *)(a1 + 4 * a3);
  v7[4] = 1065353216;
  v7[8] = 0;
  v7[12] = 0;
  v7[1040] = 0;
  v7[1044] = 0;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  *(_QWORD *)(a1 + 8 * a3 + 8368) = a4;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x2Slice::GetParameter(_anonymous_namespace_::MatrixMixer1x2Slice *this, unsigned int a2)
{
  if (a2 > 1)
    return 9;
  else
    return 0;
}

uint64_t `anonymous namespace'::MatrixMixer1x2Slice::SetParameter(_anonymous_namespace_::MatrixMixer1x2Slice *this, int a2, int a3, double a4)
{
  uint64_t result;
  float v6;
  float v7;

  if (a2 == 1)
  {
    result = 0;
    v7 = a4;
    *((float *)this + a3 + 8) = v7;
  }
  else if (a2)
  {
    return 9;
  }
  else
  {
    result = 0;
    v6 = a4;
    *((float *)this + a3 + 4) = v6;
  }
  return result;
}

__n128 `anonymous namespace'::MatrixMixer1x2Slice::UpdateParameters(__n128 *a1)
{
  __n128 result;
  __n128 v3;
  __n128 v4;
  __n128 v5;
  __n128 v6;

  v6 = a1[260];
  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[261];
  memcpy(&a1[262], &a1[3], 0x1010uLL);
  a1[519] = v6;
  a1[520] = v3;
  a1[521] = v5;
  result = v4;
  a1[522] = v4;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x2Slice::UpdateParameters(uint64_t result, uint64_t a2, int a3)
{
  _DWORD *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  _DWORD *v9;
  _DWORD *v10;

  v3 = (_DWORD *)(result + 4 * a3);
  v4 = v3[1040];
  v5 = v3[4];
  v6 = v3[1044];
  v7 = v3[8];
  v8 = v3[12];
  v3[1048] = v8;
  if ((int)v8 >= 1)
  {
    v9 = (_DWORD *)(result + 4 * a3);
    do
    {
      v9[1052] = v9[16];
      v9[1056] = v9[20];
      v9 += 8;
      --v8;
    }
    while (v8);
  }
  v10 = (_DWORD *)(result + 4 * a3);
  v10[2076] = v4;
  v10[2080] = v5;
  v10[2084] = v6;
  v10[2088] = v7;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x2Slice::Run(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int32x4_t v4;
  int64x2_t v5;
  uint64_t v6;
  float32x4_t *v7;
  float32x4_t v8;
  int32x4_t v9;
  int32x4_t v10;
  int8x16_t v11;
  float32x4_t v12;
  int v13;
  unint64_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  int8x16_t v18;

  v4 = (int32x4_t)vandq_s8(*(int8x16_t *)(result + 4192), (int8x16_t)vcgtq_s32(vdupq_n_s32(a4), (int32x4_t)xmmword_2166F76B0));
  v5 = (int64x2_t)vcgtzq_s32(v4);
  if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0])
  {
    v6 = *(_QWORD *)(a2 + 56);
    v7 = (float32x4_t *)(result + 4224);
    v8 = 0uLL;
    v9 = 0uLL;
    v10.i64[0] = 0x100000001;
    v10.i64[1] = 0x100000001;
    do
    {
      v11.i32[0] = *(_DWORD *)(v6 + 4 * v7[-1].i32[0]);
      v11.i32[1] = *(_DWORD *)(v6 + 4 * v7[-1].i32[1]);
      v11.i32[2] = *(_DWORD *)(v6 + 4 * v7[-1].i32[2]);
      v11.i32[3] = *(_DWORD *)(v6 + 4 * v7[-1].i32[3]);
      v8 = vmlaq_f32(v8, (float32x4_t)vandq_s8((int8x16_t)v5, v11), *v7);
      v9 = vaddq_s32(v9, v10);
      v5 = (int64x2_t)vcgtq_s32(v4, v9);
      v7 += 2;
    }
    while (vorrq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0]);
  }
  else
  {
    v8 = 0uLL;
  }
  v12 = *(float32x4_t *)(result + 8352);
  HIDWORD(v14) = a4 - 1;
  LODWORD(v14) = a4 - 1;
  v13 = v14 >> 1;
  v15 = vmulq_f32(*(float32x4_t *)(result + 8320), v8);
  v16 = vandq_s8((int8x16_t)v15, vorrq_s8((int8x16_t)vcltzq_f32(v15), (int8x16_t)vcgezq_f32(v15)));
  switch(v13)
  {
    case 0:
      goto LABEL_10;
    case 1:
      goto LABEL_9;
    case 3:
      goto LABEL_8;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8316)) = v16.i32[3];
LABEL_8:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8312)) = v16.i32[2];
LABEL_9:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8308)) = v16.i32[1];
LABEL_10:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8304)) = v16.i32[0];
      break;
    default:
      break;
  }
  v17 = vmulq_f32(v12, v8);
  v18 = vandq_s8((int8x16_t)v17, vorrq_s8((int8x16_t)vcltzq_f32(v17), (int8x16_t)vcgezq_f32(v17)));
  switch(v13)
  {
    case 0:
      goto LABEL_15;
    case 1:
      goto LABEL_14;
    case 3:
      goto LABEL_13;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8348)) = v18.i32[3];
LABEL_13:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8344)) = v18.i32[2];
LABEL_14:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8340)) = v18.i32[1];
LABEL_15:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8336)) = v18.i32[0];
      break;
    default:
      return result;
  }
  return result;
}

float `anonymous namespace'::MatrixMixer1x2Slice::CopyVoiceState(_anonymous_namespace_::MatrixMixer1x2Slice *this, Phase::DspLayer::VoicePoolSlice *a2, int a3, int a4)
{
  _DWORD *v4;
  _DWORD *v5;
  uint64_t v6;
  _DWORD *v7;
  int *v8;
  int v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _DWORD *v13;
  int *v14;
  int v15;
  float result;

  v4 = (_DWORD *)((char *)a2 + 4 * a3);
  v5 = (_DWORD *)((char *)this + 4 * a4);
  v5[4] = v4[4];
  v5[8] = v4[8];
  v6 = v4[12];
  v5[12] = v6;
  if ((int)v6 >= 1)
  {
    v7 = (_DWORD *)((char *)this + 4 * a4 + 80);
    v8 = (int *)((char *)a2 + 4 * a3 + 80);
    do
    {
      *(v7 - 4) = *(v8 - 4);
      v9 = *v8;
      v8 += 8;
      *v7 = v9;
      v7 += 8;
      --v6;
    }
    while (v6);
  }
  v10 = (char *)this + 4 * a4;
  v11 = (char *)a2 + 4 * a3;
  v12 = *((unsigned int *)v11 + 1048);
  *((_DWORD *)v10 + 1048) = v12;
  if ((int)v12 >= 1)
  {
    v13 = v10 + 4224;
    v14 = (int *)(v11 + 4224);
    do
    {
      *(v13 - 4) = *(v14 - 4);
      v15 = *v14;
      v14 += 8;
      *v13 = v15;
      v13 += 8;
      --v12;
    }
    while (v12);
  }
  *((_DWORD *)v10 + 1040) = *((_DWORD *)v11 + 1040);
  *((_DWORD *)v10 + 1044) = *((_DWORD *)v11 + 1044);
  *((_DWORD *)v10 + 2076) = *((_DWORD *)v11 + 2076);
  *((_DWORD *)v10 + 2080) = *((_DWORD *)v11 + 2080);
  *((_DWORD *)v10 + 2084) = *((_DWORD *)v11 + 2084);
  result = *((float *)v11 + 2088);
  *((float *)v10 + 2088) = result;
  *((_QWORD *)this + a4 + 1046) = *((_QWORD *)a2 + a3 + 1046);
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x2Slice::AddInput(_anonymous_namespace_::MatrixMixer1x2Slice *this, int a2, int a3, int a4, float a5)
{
  uint64_t result;
  char *v7;
  uint64_t v8;
  char *v9;

  if (a2)
    return 8;
  v7 = (char *)this + 48;
  v8 = *((int *)this + a3 + 12);
  if ((int)v8 > 127)
    return 6;
  result = 0;
  v9 = (char *)this + 32 * v8 + 4 * a3;
  *((_DWORD *)v9 + 16) = a4;
  *((float *)v9 + 20) = a5;
  *(_DWORD *)&v7[4 * a3] = v8 + 1;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x2Slice::RemoveInput(_anonymous_namespace_::MatrixMixer1x2Slice *this, int a2, int a3, int a4)
{
  if (a2)
    return 8;
  else
    return Phase::DspLayer::VoiceConnectionList<128>::RemoveConnection((uint64_t)this + 48, a3, a4);
}

uint64_t `anonymous namespace'::MatrixMixer1x2Slice::SetInputGain(_anonymous_namespace_::MatrixMixer1x2Slice *this, int a2, int a3, int a4, float a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  float *i;

  if (a2)
    return 8;
  v6 = *((unsigned int *)this + a3 + 12);
  if ((int)v6 < 1)
    return 7;
  v7 = 0;
  for (i = (float *)((char *)this + 4 * a3 + 80); *((_DWORD *)i - 4) != a4; i += 8)
  {
    if (v6 == ++v7)
      return 7;
  }
  if ((v7 & 0x80000000) != 0)
    return 7;
  result = 0;
  *i = a5;
  return result;
}

void `anonymous namespace'::MatrixMixer1x2Slice::GetInputs(_anonymous_namespace_::MatrixMixer1x2Slice *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (a2)
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    *(_QWORD *)(a4 + 16) = 0;
  }
  else
  {
    Phase::DspLayer::VoiceConnectionList<128>::GetConnections((uint64_t)this + 48, a3, (char **)a4);
  }
}

uint64_t `anonymous namespace'::MatrixMixer1x2Slice::ClearInputs(_anonymous_namespace_::MatrixMixer1x2Slice *this, int a2)
{
  *((_DWORD *)this + a2 + 12) = 0;
  return 0;
}

uint64_t `anonymous namespace'::MatrixMixer1x2Slice::GetMaximumInputConnectionCount(_anonymous_namespace_::MatrixMixer1x2Slice *this, int a2)
{
  return (a2 == 0) << 7;
}

uint64_t `anonymous namespace'::MatrixMixer1x2Slice::GetOutput(_anonymous_namespace_::MatrixMixer1x2Slice *this, int a2, int a3)
{
  char *v3;
  uint64_t v4;

  if (a2 == 1)
  {
    v3 = (char *)this + 4 * a3;
    v4 = 4176;
    return (unint64_t)*(unsigned int *)&v3[v4] << 32;
  }
  if (!a2)
  {
    v3 = (char *)this + 4 * a3;
    v4 = 4160;
    return (unint64_t)*(unsigned int *)&v3[v4] << 32;
  }
  return 0xFFFFFFFF00000008;
}

uint64_t `anonymous namespace'::MatrixMixer1x2Slice::SetOutput(_anonymous_namespace_::MatrixMixer1x2Slice *this, int a2, int a3, int a4)
{
  char *v4;
  uint64_t v5;
  uint64_t result;

  if (a2 == 1)
  {
    v4 = (char *)this + 4 * a3;
    v5 = 4176;
    goto LABEL_5;
  }
  if (!a2)
  {
    v4 = (char *)this + 4 * a3;
    v5 = 4160;
LABEL_5:
    result = 0;
    *(_DWORD *)&v4[v5] = a4;
    return result;
  }
  return 8;
}

void std::__function::__func<Phase::DspLayer::MatrixMixer1x2::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::MatrixMixer1x2::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<Phase::DspLayer::MatrixMixer1x2::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::MatrixMixer1x2::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57ECD8;
  return result;
}

void std::__function::__func<Phase::DspLayer::MatrixMixer1x2::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::MatrixMixer1x2::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57ECD8;
}

uint64_t std::__function::__func<Phase::DspLayer::MatrixMixer1x2::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::MatrixMixer1x2::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::operator()(uint64_t a1, Phase::DspLayer::VoiceEngine **a2, int *a3)
{
  Phase::DspLayer::VoiceEngine *v3;
  int v4;
  uint64_t v5;
  int v6;
  _OWORD *v12;
  __int128 v14;

  v3 = *a2;
  v4 = *a3;
  v5 = operator new();
  Phase::DspLayer::VoicePool::VoicePool((Phase::DspLayer::VoicePool *)v5, "MatrixMixer1x2", v3, v4, 8400);
  *(_QWORD *)v5 = &off_24D57EBE0;
  if (*(int *)(v5 + 40) >= 1)
  {
    v6 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    v14 = _Q0;
    do
    {
      v12 = (_OWORD *)(*(_QWORD *)(v5 + 24) + *(int *)(v5 + 16) * (uint64_t)v6);
      *(_QWORD *)v12 = &off_24D57EC00;
      *((_QWORD *)v12 + 1) = 0;
      bzero(v12 + 4, 0x1000uLL);
      v12[3] = 0u;
      v12 += 3;
      *(v12 - 2) = v14;
      *(v12 - 1) = 0u;
      v12[257] = 0u;
      v12[258] = 0u;
      memcpy(v12 + 259, v12, 0x1010uLL);
      v12[516] = 0u;
      v12[517] = v14;
      v12[518] = 0u;
      v12[519] = 0u;
      v12[520] = 0u;
      v12[521] = 0u;
      ++v6;
    }
    while (v6 < *(_DWORD *)(v5 + 40));
  }
  return v5;
}

void sub_21660AE8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199F9D70](v1, 0x10F1C408EBD29CELL);
  _Unwind_Resume(a1);
}

uint64_t *Phase::DspLayer::MatrixMixer1x6::GetNewRegistryEntry(Phase::DspLayer::MatrixMixer1x6 *this)
{
  char *v1;
  uint64_t *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v6[2];
  char v7;
  void *v8[2];
  char v9;
  void *v10[2];
  char v11;
  void *v12[2];
  char v13;
  void *v14[2];
  char v15;
  void *__p[2];
  char v17;
  __int128 v18;
  char v19;
  _QWORD v20[3];
  _QWORD *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v1 = (char *)malloc_type_malloc(0x150uLL, 0x1050040B063AAFAuLL);
  *(_QWORD *)v1 = "Gain 0";
  *((_QWORD *)v1 + 1) = 0x500000000;
  *(_QWORD *)(v1 + 20) = 0x100000000;
  *((_DWORD *)v1 + 7) = 3;
  *((_OWORD *)v1 + 2) = xmmword_2166F7470;
  *((_QWORD *)v1 + 6) = 0x3FF0000000000000;
  *((_QWORD *)v1 + 7) = "Gain 1";
  *((_QWORD *)v1 + 8) = 0x500000001;
  *(_QWORD *)(v1 + 76) = 0x100000000;
  *((_DWORD *)v1 + 21) = 3;
  *(_OWORD *)(v1 + 88) = xmmword_2166F7470;
  *((_QWORD *)v1 + 13) = 0;
  *((_QWORD *)v1 + 14) = "Gain 2";
  *((_QWORD *)v1 + 15) = 0x500000002;
  *(_QWORD *)(v1 + 132) = 0x100000000;
  *((_DWORD *)v1 + 35) = 3;
  *((_OWORD *)v1 + 9) = xmmword_2166F7470;
  *((_QWORD *)v1 + 20) = 0;
  *((_QWORD *)v1 + 21) = "Gain 3";
  *((_QWORD *)v1 + 22) = 0x500000003;
  *(_QWORD *)(v1 + 188) = 0x100000000;
  *((_DWORD *)v1 + 49) = 3;
  *(_OWORD *)(v1 + 200) = xmmword_2166F7470;
  *((_QWORD *)v1 + 27) = 0;
  *((_QWORD *)v1 + 28) = "Gain 4";
  *((_QWORD *)v1 + 29) = 0x500000004;
  *(_QWORD *)(v1 + 244) = 0x100000000;
  *((_DWORD *)v1 + 63) = 3;
  *((_OWORD *)v1 + 16) = xmmword_2166F7470;
  *((_QWORD *)v1 + 34) = 0;
  *((_QWORD *)v1 + 35) = "Gain 5";
  *((_QWORD *)v1 + 36) = 0x500000005;
  *((_DWORD *)v1 + 75) = 0;
  *((_QWORD *)v1 + 38) = 0x300000001;
  *((_QWORD *)v1 + 39) = 0;
  *((_OWORD *)v1 + 20) = xmmword_2166F7480;
  v2 = (uint64_t *)operator new();
  v20[0] = &off_24D57EE18;
  v21 = v20;
  Phase::Controller::VoicePoolEntry::VoicePoolEntry((uint64_t)v2, "MatrixMixer1x6", 6, (uint64_t)v1, (uint64_t)v20);
  v3 = v21;
  if (v21 == v20)
  {
    v4 = 4;
    v3 = v20;
  }
  else
  {
    if (!v21)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  std::string::basic_string[abi:ne180100]<0>(&v18, "Input");
  Phase::Controller::VoicePoolEntry::AddInput(v2, &v18);
  if (v19 < 0)
    operator delete((void *)v18);
  std::string::basic_string[abi:ne180100]<0>(__p, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)__p);
  if (v17 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(v14, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v14);
  if (v15 < 0)
    operator delete(v14[0]);
  std::string::basic_string[abi:ne180100]<0>(v12, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v12);
  if (v13 < 0)
    operator delete(v12[0]);
  std::string::basic_string[abi:ne180100]<0>(v10, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v10);
  if (v11 < 0)
    operator delete(v10[0]);
  std::string::basic_string[abi:ne180100]<0>(v8, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v8);
  if (v9 < 0)
    operator delete(v8[0]);
  std::string::basic_string[abi:ne180100]<0>(v6, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v6);
  if (v7 < 0)
    operator delete(v6[0]);
  return v2;
}

void sub_21660B1CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Phase::DspLayer::MatrixMixer1x6::~MatrixMixer1x6(Phase::DspLayer::MatrixMixer1x6 *this)
{
  Phase::DspLayer::VoicePool::~VoicePool(this);
  JUMPOUT(0x2199F9D70);
}

void `anonymous namespace'::MatrixMixer1x6Slice::~MatrixMixer1x6Slice(_anonymous_namespace_::MatrixMixer1x6Slice *this)
{
  JUMPOUT(0x2199F9D70);
}

double `anonymous namespace'::MatrixMixer1x6Slice::Reset(_OWORD *a1)
{
  double result;

  __asm { FMOV            V0.4S, #1.0 }
  a1[1] = _Q0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[264] = 0u;
  a1[265] = 0u;
  a1[266] = 0u;
  a1[267] = 0u;
  a1[268] = 0u;
  a1[269] = 0u;
  (*(void (**)(_OWORD *))(*(_QWORD *)a1 + 48))(a1);
  result = 0.0;
  a1[540] = 0u;
  a1[539] = 0u;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x6Slice::Reset(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  _DWORD *v7;
  uint64_t result;

  v7 = (_DWORD *)(a1 + 4 * a3);
  v7[4] = 1065353216;
  v7[8] = 0;
  v7[12] = 0;
  v7[16] = 0;
  v7[20] = 0;
  v7[24] = 0;
  v7[28] = 0;
  v7[1056] = 0;
  v7[1060] = 0;
  v7[1064] = 0;
  v7[1068] = 0;
  v7[1072] = 0;
  v7[1076] = 0;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  *(_QWORD *)(a1 + 8 * a3 + 8624) = a4;
  return result;
}

double `anonymous namespace'::MatrixMixer1x6Slice::GetParameter(_anonymous_namespace_::MatrixMixer1x6Slice *this, int a2, int a3)
{
  float *v3;
  double result;

  switch(a2)
  {
    case 0:
      v3 = (float *)((char *)this + 4 * a3 + 16);
      goto LABEL_8;
    case 1:
      v3 = (float *)((char *)this + 4 * a3 + 32);
      goto LABEL_8;
    case 2:
      v3 = (float *)((char *)this + 4 * a3 + 48);
      goto LABEL_8;
    case 3:
      v3 = (float *)((char *)this + 4 * a3 + 64);
      goto LABEL_8;
    case 4:
      v3 = (float *)((char *)this + 4 * a3 + 80);
      goto LABEL_8;
    case 5:
      v3 = (float *)((char *)this + 4 * a3 + 96);
LABEL_8:
      result = *v3;
      break;
    default:
      return result;
  }
  return result;
}

float `anonymous namespace'::MatrixMixer1x6Slice::SetParameter(_anonymous_namespace_::MatrixMixer1x6Slice *this, int a2, int a3, double a4)
{
  switch(a2)
  {
    case 0:
      *(float *)&a4 = a4;
      *((_DWORD *)this + a3 + 4) = LODWORD(a4);
      break;
    case 1:
      *(float *)&a4 = a4;
      *((_DWORD *)this + a3 + 8) = LODWORD(a4);
      break;
    case 2:
      *(float *)&a4 = a4;
      *((_DWORD *)this + a3 + 12) = LODWORD(a4);
      break;
    case 3:
      *(float *)&a4 = a4;
      *((_DWORD *)this + a3 + 16) = LODWORD(a4);
      break;
    case 4:
      *(float *)&a4 = a4;
      *((_DWORD *)this + a3 + 20) = LODWORD(a4);
      break;
    case 5:
      *(float *)&a4 = a4;
      *((_DWORD *)this + a3 + 24) = LODWORD(a4);
      break;
    default:
      return *(float *)&a4;
  }
  return *(float *)&a4;
}

__n128 `anonymous namespace'::MatrixMixer1x6Slice::UpdateParameters(__n128 *a1)
{
  __n128 result;
  __n128 v3;
  __n128 v4;
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;
  __n128 v9;
  __n128 v10;
  __n128 v11;
  __n128 v12;
  __n128 v13;
  __n128 v14;

  v13 = a1[265];
  v14 = a1[264];
  v6 = a1[1];
  v11 = a1[266];
  v12 = a1[2];
  v10 = a1[267];
  v8 = a1[268];
  v9 = a1[4];
  v7 = a1[269];
  v3 = a1[5];
  v4 = a1[6];
  v5 = a1[3];
  memcpy(&a1[270], &a1[7], 0x1010uLL);
  a1[527] = v14;
  a1[528] = v6;
  a1[529] = v13;
  a1[530] = v12;
  a1[531] = v11;
  a1[532] = v5;
  a1[533] = v10;
  a1[534] = v9;
  a1[535] = v8;
  a1[536] = v3;
  a1[537] = v7;
  result = v4;
  a1[538] = v4;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x6Slice::UpdateParameters(uint64_t result, uint64_t a2, int a3)
{
  _DWORD *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  _DWORD *v17;
  _DWORD *v18;

  v3 = (_DWORD *)(result + 4 * a3);
  v4 = v3[1056];
  v5 = v3[4];
  v6 = v3[1060];
  v7 = v3[8];
  v8 = v3[1064];
  v9 = v3[12];
  v10 = v3[1068];
  v11 = v3[16];
  v12 = v3[1072];
  v13 = v3[20];
  v14 = v3[1076];
  v15 = v3[24];
  v16 = v3[28];
  v3[1080] = v16;
  if ((int)v16 >= 1)
  {
    v17 = (_DWORD *)(result + 4 * a3);
    do
    {
      v17[1084] = v17[32];
      v17[1088] = v17[36];
      v17 += 8;
      --v16;
    }
    while (v16);
  }
  v18 = (_DWORD *)(result + 4 * a3);
  v18[2108] = v4;
  v18[2112] = v5;
  v18[2116] = v6;
  v18[2120] = v7;
  v18[2124] = v8;
  v18[2128] = v9;
  v18[2132] = v10;
  v18[2136] = v11;
  v18[2140] = v12;
  v18[2144] = v13;
  v18[2148] = v14;
  v18[2152] = v15;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x6Slice::Run(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int32x4_t v4;
  int64x2_t v5;
  uint64_t v6;
  float32x4_t *v7;
  float32x4_t v8;
  int32x4_t v9;
  int32x4_t v10;
  int8x16_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int v17;
  unint64_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  int8x16_t v28;
  float32x4_t v29;
  int8x16_t v30;

  v4 = (int32x4_t)vandq_s8(*(int8x16_t *)(result + 4320), (int8x16_t)vcgtq_s32(vdupq_n_s32(a4), (int32x4_t)xmmword_2166F76B0));
  v5 = (int64x2_t)vcgtzq_s32(v4);
  if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0])
  {
    v6 = *(_QWORD *)(a2 + 56);
    v7 = (float32x4_t *)(result + 4352);
    v8 = 0uLL;
    v9 = 0uLL;
    v10.i64[0] = 0x100000001;
    v10.i64[1] = 0x100000001;
    do
    {
      v11.i32[0] = *(_DWORD *)(v6 + 4 * v7[-1].i32[0]);
      v11.i32[1] = *(_DWORD *)(v6 + 4 * v7[-1].i32[1]);
      v11.i32[2] = *(_DWORD *)(v6 + 4 * v7[-1].i32[2]);
      v11.i32[3] = *(_DWORD *)(v6 + 4 * v7[-1].i32[3]);
      v8 = vmlaq_f32(v8, (float32x4_t)vandq_s8((int8x16_t)v5, v11), *v7);
      v9 = vaddq_s32(v9, v10);
      v5 = (int64x2_t)vcgtq_s32(v4, v9);
      v7 += 2;
    }
    while (vorrq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0]);
  }
  else
  {
    v8 = 0uLL;
  }
  v12 = *(float32x4_t *)(result + 8480);
  v13 = *(float32x4_t *)(result + 8512);
  v14 = *(float32x4_t *)(result + 8544);
  v15 = *(float32x4_t *)(result + 8576);
  v16 = *(float32x4_t *)(result + 8608);
  HIDWORD(v18) = a4 - 1;
  LODWORD(v18) = a4 - 1;
  v17 = v18 >> 1;
  v19 = vmulq_f32(*(float32x4_t *)(result + 8448), v8);
  v20 = vandq_s8((int8x16_t)v19, vorrq_s8((int8x16_t)vcltzq_f32(v19), (int8x16_t)vcgezq_f32(v19)));
  switch(v17)
  {
    case 0:
      goto LABEL_10;
    case 1:
      goto LABEL_9;
    case 3:
      goto LABEL_8;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8444)) = v20.i32[3];
LABEL_8:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8440)) = v20.i32[2];
LABEL_9:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8436)) = v20.i32[1];
LABEL_10:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8432)) = v20.i32[0];
      break;
    default:
      break;
  }
  v21 = vmulq_f32(v12, v8);
  v22 = vandq_s8((int8x16_t)v21, vorrq_s8((int8x16_t)vcltzq_f32(v21), (int8x16_t)vcgezq_f32(v21)));
  switch(v17)
  {
    case 0:
      goto LABEL_15;
    case 1:
      goto LABEL_14;
    case 3:
      goto LABEL_13;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8476)) = v22.i32[3];
LABEL_13:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8472)) = v22.i32[2];
LABEL_14:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8468)) = v22.i32[1];
LABEL_15:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8464)) = v22.i32[0];
      break;
    default:
      break;
  }
  v23 = vmulq_f32(v13, v8);
  v24 = vandq_s8((int8x16_t)v23, vorrq_s8((int8x16_t)vcltzq_f32(v23), (int8x16_t)vcgezq_f32(v23)));
  switch(v17)
  {
    case 0:
      goto LABEL_20;
    case 1:
      goto LABEL_19;
    case 3:
      goto LABEL_18;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8508)) = v24.i32[3];
LABEL_18:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8504)) = v24.i32[2];
LABEL_19:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8500)) = v24.i32[1];
LABEL_20:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8496)) = v24.i32[0];
      break;
    default:
      break;
  }
  v25 = vmulq_f32(v14, v8);
  v26 = vandq_s8((int8x16_t)v25, vorrq_s8((int8x16_t)vcltzq_f32(v25), (int8x16_t)vcgezq_f32(v25)));
  switch(v17)
  {
    case 0:
      goto LABEL_25;
    case 1:
      goto LABEL_24;
    case 3:
      goto LABEL_23;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8540)) = v26.i32[3];
LABEL_23:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8536)) = v26.i32[2];
LABEL_24:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8532)) = v26.i32[1];
LABEL_25:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8528)) = v26.i32[0];
      break;
    default:
      break;
  }
  v27 = vmulq_f32(v15, v8);
  v28 = vandq_s8((int8x16_t)v27, vorrq_s8((int8x16_t)vcltzq_f32(v27), (int8x16_t)vcgezq_f32(v27)));
  switch(v17)
  {
    case 0:
      goto LABEL_30;
    case 1:
      goto LABEL_29;
    case 3:
      goto LABEL_28;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8572)) = v28.i32[3];
LABEL_28:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8568)) = v28.i32[2];
LABEL_29:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8564)) = v28.i32[1];
LABEL_30:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8560)) = v28.i32[0];
      break;
    default:
      break;
  }
  v29 = vmulq_f32(v16, v8);
  v30 = vandq_s8((int8x16_t)v29, vorrq_s8((int8x16_t)vcltzq_f32(v29), (int8x16_t)vcgezq_f32(v29)));
  switch(v17)
  {
    case 0:
      goto LABEL_35;
    case 1:
      goto LABEL_34;
    case 3:
      goto LABEL_33;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8604)) = v30.i32[3];
LABEL_33:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8600)) = v30.i32[2];
LABEL_34:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8596)) = v30.i32[1];
LABEL_35:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8592)) = v30.i32[0];
      break;
    default:
      return result;
  }
  return result;
}

float `anonymous namespace'::MatrixMixer1x6Slice::CopyVoiceState(_anonymous_namespace_::MatrixMixer1x6Slice *this, Phase::DspLayer::VoicePoolSlice *a2, int a3, int a4)
{
  _DWORD *v4;
  _DWORD *v5;
  uint64_t v6;
  _DWORD *v7;
  int *v8;
  int v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _DWORD *v13;
  int *v14;
  int v15;
  float result;

  v4 = (_DWORD *)((char *)a2 + 4 * a3);
  v5 = (_DWORD *)((char *)this + 4 * a4);
  v5[4] = v4[4];
  v5[8] = v4[8];
  v5[12] = v4[12];
  v5[16] = v4[16];
  v5[20] = v4[20];
  v5[24] = v4[24];
  v6 = v4[28];
  v5[28] = v6;
  if ((int)v6 >= 1)
  {
    v7 = (_DWORD *)((char *)this + 4 * a4 + 144);
    v8 = (int *)((char *)a2 + 4 * a3 + 144);
    do
    {
      *(v7 - 4) = *(v8 - 4);
      v9 = *v8;
      v8 += 8;
      *v7 = v9;
      v7 += 8;
      --v6;
    }
    while (v6);
  }
  v10 = (char *)this + 4 * a4;
  v11 = (char *)a2 + 4 * a3;
  v12 = *((unsigned int *)v11 + 1080);
  *((_DWORD *)v10 + 1080) = v12;
  if ((int)v12 >= 1)
  {
    v13 = v10 + 4352;
    v14 = (int *)(v11 + 4352);
    do
    {
      *(v13 - 4) = *(v14 - 4);
      v15 = *v14;
      v14 += 8;
      *v13 = v15;
      v13 += 8;
      --v12;
    }
    while (v12);
  }
  *((_DWORD *)v10 + 1056) = *((_DWORD *)v11 + 1056);
  *((_DWORD *)v10 + 1060) = *((_DWORD *)v11 + 1060);
  *((_DWORD *)v10 + 1064) = *((_DWORD *)v11 + 1064);
  *((_DWORD *)v10 + 1068) = *((_DWORD *)v11 + 1068);
  *((_DWORD *)v10 + 1072) = *((_DWORD *)v11 + 1072);
  *((_DWORD *)v10 + 1076) = *((_DWORD *)v11 + 1076);
  *((_DWORD *)v10 + 2108) = *((_DWORD *)v11 + 2108);
  *((_DWORD *)v10 + 2112) = *((_DWORD *)v11 + 2112);
  *((_DWORD *)v10 + 2116) = *((_DWORD *)v11 + 2116);
  *((_DWORD *)v10 + 2120) = *((_DWORD *)v11 + 2120);
  *((_DWORD *)v10 + 2124) = *((_DWORD *)v11 + 2124);
  *((_DWORD *)v10 + 2128) = *((_DWORD *)v11 + 2128);
  *((_DWORD *)v10 + 2132) = *((_DWORD *)v11 + 2132);
  *((_DWORD *)v10 + 2136) = *((_DWORD *)v11 + 2136);
  *((_DWORD *)v10 + 2140) = *((_DWORD *)v11 + 2140);
  *((_DWORD *)v10 + 2144) = *((_DWORD *)v11 + 2144);
  *((_DWORD *)v10 + 2148) = *((_DWORD *)v11 + 2148);
  result = *((float *)v11 + 2152);
  *((float *)v10 + 2152) = result;
  *((_QWORD *)this + a4 + 1078) = *((_QWORD *)a2 + a3 + 1078);
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x6Slice::AddInput(_anonymous_namespace_::MatrixMixer1x6Slice *this, int a2, int a3, int a4, float a5)
{
  uint64_t result;
  char *v7;
  uint64_t v8;
  char *v9;

  if (a2)
    return 8;
  v7 = (char *)this + 112;
  v8 = *((int *)this + a3 + 28);
  if ((int)v8 > 127)
    return 6;
  result = 0;
  v9 = (char *)this + 32 * v8 + 4 * a3;
  *((_DWORD *)v9 + 32) = a4;
  *((float *)v9 + 36) = a5;
  *(_DWORD *)&v7[4 * a3] = v8 + 1;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x6Slice::RemoveInput(_anonymous_namespace_::MatrixMixer1x6Slice *this, int a2, int a3, int a4)
{
  if (a2)
    return 8;
  else
    return Phase::DspLayer::VoiceConnectionList<128>::RemoveConnection((uint64_t)this + 112, a3, a4);
}

uint64_t `anonymous namespace'::MatrixMixer1x6Slice::SetInputGain(_anonymous_namespace_::MatrixMixer1x6Slice *this, int a2, int a3, int a4, float a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  float *i;

  if (a2)
    return 8;
  v6 = *((unsigned int *)this + a3 + 28);
  if ((int)v6 < 1)
    return 7;
  v7 = 0;
  for (i = (float *)((char *)this + 4 * a3 + 144); *((_DWORD *)i - 4) != a4; i += 8)
  {
    if (v6 == ++v7)
      return 7;
  }
  if ((v7 & 0x80000000) != 0)
    return 7;
  result = 0;
  *i = a5;
  return result;
}

void `anonymous namespace'::MatrixMixer1x6Slice::GetInputs(_anonymous_namespace_::MatrixMixer1x6Slice *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (a2)
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    *(_QWORD *)(a4 + 16) = 0;
  }
  else
  {
    Phase::DspLayer::VoiceConnectionList<128>::GetConnections((uint64_t)this + 112, a3, (char **)a4);
  }
}

uint64_t `anonymous namespace'::MatrixMixer1x6Slice::ClearInputs(_anonymous_namespace_::MatrixMixer1x6Slice *this, int a2)
{
  *((_DWORD *)this + a2 + 28) = 0;
  return 0;
}

uint64_t `anonymous namespace'::MatrixMixer1x6Slice::GetMaximumInputConnectionCount(_anonymous_namespace_::MatrixMixer1x6Slice *this, int a2)
{
  return (a2 == 0) << 7;
}

unint64_t `anonymous namespace'::MatrixMixer1x6Slice::GetOutput(_anonymous_namespace_::MatrixMixer1x6Slice *this, int a2, int a3)
{
  char *v3;
  uint64_t v4;
  unint64_t result;

  switch(a2)
  {
    case 0:
      v3 = (char *)this + 4 * a3;
      v4 = 4224;
      goto LABEL_9;
    case 1:
      v3 = (char *)this + 4 * a3;
      v4 = 4240;
      goto LABEL_9;
    case 2:
      v3 = (char *)this + 4 * a3;
      v4 = 4256;
      goto LABEL_9;
    case 3:
      v3 = (char *)this + 4 * a3;
      v4 = 4272;
      goto LABEL_9;
    case 4:
      v3 = (char *)this + 4 * a3;
      v4 = 4288;
      goto LABEL_9;
    case 5:
      v3 = (char *)this + 4 * a3;
      v4 = 4304;
LABEL_9:
      result = (unint64_t)*(unsigned int *)&v3[v4] << 32;
      break;
    default:
      result = 0xFFFFFFFF00000008;
      break;
  }
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x6Slice::SetOutput(_anonymous_namespace_::MatrixMixer1x6Slice *this, int a2, int a3, int a4)
{
  char *v4;
  uint64_t v5;
  uint64_t result;

  switch(a2)
  {
    case 0:
      v4 = (char *)this + 4 * a3;
      v5 = 4224;
      goto LABEL_9;
    case 1:
      v4 = (char *)this + 4 * a3;
      v5 = 4240;
      goto LABEL_9;
    case 2:
      v4 = (char *)this + 4 * a3;
      v5 = 4256;
      goto LABEL_9;
    case 3:
      v4 = (char *)this + 4 * a3;
      v5 = 4272;
      goto LABEL_9;
    case 4:
      v4 = (char *)this + 4 * a3;
      v5 = 4288;
      goto LABEL_9;
    case 5:
      v4 = (char *)this + 4 * a3;
      v5 = 4304;
LABEL_9:
      result = 0;
      *(_DWORD *)&v4[v5] = a4;
      break;
    default:
      result = 8;
      break;
  }
  return result;
}

void std::__function::__func<Phase::DspLayer::MatrixMixer1x6::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::MatrixMixer1x6::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<Phase::DspLayer::MatrixMixer1x6::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::MatrixMixer1x6::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57EE18;
  return result;
}

void std::__function::__func<Phase::DspLayer::MatrixMixer1x6::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::MatrixMixer1x6::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57EE18;
}

uint64_t std::__function::__func<Phase::DspLayer::MatrixMixer1x6::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::MatrixMixer1x6::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::operator()(uint64_t a1, Phase::DspLayer::VoiceEngine **a2, int *a3)
{
  Phase::DspLayer::VoiceEngine *v3;
  int v4;
  uint64_t v5;
  int v6;
  _OWORD *v12;
  __int128 v14;

  v3 = *a2;
  v4 = *a3;
  v5 = operator new();
  Phase::DspLayer::VoicePool::VoicePool((Phase::DspLayer::VoicePool *)v5, "MatrixMixer1x6", v3, v4, 8656);
  *(_QWORD *)v5 = &off_24D57ED20;
  if (*(int *)(v5 + 40) >= 1)
  {
    v6 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    v14 = _Q0;
    do
    {
      v12 = (_OWORD *)(*(_QWORD *)(v5 + 24) + *(int *)(v5 + 16) * (uint64_t)v6);
      *(_QWORD *)v12 = &off_24D57ED40;
      *((_QWORD *)v12 + 1) = 0;
      bzero(v12 + 8, 0x1000uLL);
      v12[7] = 0u;
      v12 += 7;
      *(v12 - 6) = v14;
      *(v12 - 5) = 0u;
      *(v12 - 4) = 0u;
      *(v12 - 3) = 0u;
      *(v12 - 2) = 0u;
      *(v12 - 1) = 0u;
      v12[257] = 0u;
      v12[258] = 0u;
      v12[259] = 0u;
      v12[260] = 0u;
      v12[261] = 0u;
      v12[262] = 0u;
      memcpy(v12 + 263, v12, 0x1010uLL);
      v12[520] = 0u;
      v12[521] = v14;
      v12[526] = 0u;
      v12[525] = 0u;
      v12[524] = 0u;
      v12[523] = 0u;
      v12[522] = 0u;
      v12[527] = 0u;
      v12[528] = 0u;
      v12[529] = 0u;
      v12[530] = 0u;
      v12[531] = 0u;
      v12[532] = 0u;
      v12[533] = 0u;
      ++v6;
    }
    while (v6 < *(_DWORD *)(v5 + 40));
  }
  return v5;
}

void sub_21660BEE4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199F9D70](v1, 0x10F1C408EBD29CELL);
  _Unwind_Resume(a1);
}

uint64_t *Phase::DspLayer::MatrixMixer1x8::GetNewRegistryEntry(Phase::DspLayer::MatrixMixer1x8 *this)
{
  char *v1;
  uint64_t *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v6[2];
  char v7;
  void *v8[2];
  char v9;
  void *v10[2];
  char v11;
  void *v12[2];
  char v13;
  void *v14[2];
  char v15;
  void *v16[2];
  char v17;
  void *__p[2];
  char v19;
  __int128 v20;
  char v21;
  __int128 v22;
  char v23;
  _QWORD v24[3];
  _QWORD *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v1 = (char *)malloc_type_malloc(0x1C0uLL, 0x1050040B063AAFAuLL);
  *(_QWORD *)v1 = "Gain 0";
  *((_QWORD *)v1 + 1) = 0x500000000;
  *(_QWORD *)(v1 + 20) = 0x100000000;
  *((_DWORD *)v1 + 7) = 3;
  *((_OWORD *)v1 + 2) = xmmword_2166F7470;
  *((_QWORD *)v1 + 6) = 0x3FF0000000000000;
  *((_QWORD *)v1 + 7) = "Gain 1";
  *((_QWORD *)v1 + 8) = 0x500000001;
  *(_QWORD *)(v1 + 76) = 0x100000000;
  *((_DWORD *)v1 + 21) = 3;
  *(_OWORD *)(v1 + 88) = xmmword_2166F7470;
  *((_QWORD *)v1 + 13) = 0;
  *((_QWORD *)v1 + 14) = "Gain 2";
  *((_QWORD *)v1 + 15) = 0x500000002;
  *(_QWORD *)(v1 + 132) = 0x100000000;
  *((_DWORD *)v1 + 35) = 3;
  *((_OWORD *)v1 + 9) = xmmword_2166F7470;
  *((_QWORD *)v1 + 20) = 0;
  *((_QWORD *)v1 + 21) = "Gain 3";
  *((_QWORD *)v1 + 22) = 0x500000003;
  *(_QWORD *)(v1 + 188) = 0x100000000;
  *((_DWORD *)v1 + 49) = 3;
  *(_OWORD *)(v1 + 200) = xmmword_2166F7470;
  *((_QWORD *)v1 + 27) = 0;
  *((_QWORD *)v1 + 28) = "Gain 4";
  *((_QWORD *)v1 + 29) = 0x500000004;
  *(_QWORD *)(v1 + 244) = 0x100000000;
  *((_DWORD *)v1 + 63) = 3;
  *((_OWORD *)v1 + 16) = xmmword_2166F7470;
  *((_QWORD *)v1 + 34) = 0;
  *((_QWORD *)v1 + 35) = "Gain 5";
  *((_QWORD *)v1 + 36) = 0x500000005;
  *((_DWORD *)v1 + 75) = 0;
  *((_QWORD *)v1 + 38) = 0x300000001;
  *((_QWORD *)v1 + 39) = 0;
  *((_OWORD *)v1 + 20) = xmmword_2166F7480;
  *((_QWORD *)v1 + 42) = "Gain 6";
  *((_QWORD *)v1 + 43) = 0x500000006;
  *((_DWORD *)v1 + 89) = 0;
  *((_QWORD *)v1 + 45) = 0x300000001;
  *((_OWORD *)v1 + 23) = xmmword_2166F7470;
  *((_QWORD *)v1 + 48) = 0;
  *((_QWORD *)v1 + 49) = "Gain 7";
  *((_QWORD *)v1 + 50) = 0x500000007;
  *((_DWORD *)v1 + 103) = 0;
  *((_QWORD *)v1 + 52) = 0x300000001;
  *((_QWORD *)v1 + 53) = 0;
  *((_OWORD *)v1 + 27) = xmmword_2166F7480;
  v2 = (uint64_t *)operator new();
  v24[0] = &off_24D57EF58;
  v25 = v24;
  Phase::Controller::VoicePoolEntry::VoicePoolEntry((uint64_t)v2, "MatrixMixer1x8", 8, (uint64_t)v1, (uint64_t)v24);
  v3 = v25;
  if (v25 == v24)
  {
    v4 = 4;
    v3 = v24;
  }
  else
  {
    if (!v25)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  std::string::basic_string[abi:ne180100]<0>(&v22, "Input");
  Phase::Controller::VoicePoolEntry::AddInput(v2, &v22);
  if (v23 < 0)
    operator delete((void *)v22);
  std::string::basic_string[abi:ne180100]<0>(&v20, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, &v20);
  if (v21 < 0)
    operator delete((void *)v20);
  std::string::basic_string[abi:ne180100]<0>(__p, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)__p);
  if (v19 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(v16, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v16);
  if (v17 < 0)
    operator delete(v16[0]);
  std::string::basic_string[abi:ne180100]<0>(v14, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v14);
  if (v15 < 0)
    operator delete(v14[0]);
  std::string::basic_string[abi:ne180100]<0>(v12, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v12);
  if (v13 < 0)
    operator delete(v12[0]);
  std::string::basic_string[abi:ne180100]<0>(v10, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v10);
  if (v11 < 0)
    operator delete(v10[0]);
  std::string::basic_string[abi:ne180100]<0>(v8, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v8);
  if (v9 < 0)
    operator delete(v8[0]);
  std::string::basic_string[abi:ne180100]<0>(v6, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v6);
  if (v7 < 0)
    operator delete(v6[0]);
  return v2;
}

void sub_21660C2C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Phase::DspLayer::MatrixMixer1x8::~MatrixMixer1x8(Phase::DspLayer::MatrixMixer1x8 *this)
{
  Phase::DspLayer::VoicePool::~VoicePool(this);
  JUMPOUT(0x2199F9D70);
}

void `anonymous namespace'::MatrixMixer1x8Slice::~MatrixMixer1x8Slice(_anonymous_namespace_::MatrixMixer1x8Slice *this)
{
  JUMPOUT(0x2199F9D70);
}

double `anonymous namespace'::MatrixMixer1x8Slice::Reset(_OWORD *a1)
{
  double result;

  __asm { FMOV            V0.4S, #1.0 }
  a1[1] = _Q0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[266] = 0u;
  a1[267] = 0u;
  a1[268] = 0u;
  a1[269] = 0u;
  a1[270] = 0u;
  a1[271] = 0u;
  a1[272] = 0u;
  a1[273] = 0u;
  (*(void (**)(_OWORD *))(*(_QWORD *)a1 + 48))(a1);
  result = 0.0;
  a1[548] = 0u;
  a1[547] = 0u;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x8Slice::Reset(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  _DWORD *v7;
  uint64_t result;

  v7 = (_DWORD *)(a1 + 4 * a3);
  v7[4] = 1065353216;
  v7[8] = 0;
  v7[12] = 0;
  v7[16] = 0;
  v7[20] = 0;
  v7[24] = 0;
  v7[28] = 0;
  v7[32] = 0;
  v7[36] = 0;
  v7[1064] = 0;
  v7[1068] = 0;
  v7[1072] = 0;
  v7[1076] = 0;
  v7[1080] = 0;
  v7[1084] = 0;
  v7[1088] = 0;
  v7[1092] = 0;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  *(_QWORD *)(a1 + 8 * a3 + 8752) = a4;
  return result;
}

double `anonymous namespace'::MatrixMixer1x8Slice::GetParameter(_anonymous_namespace_::MatrixMixer1x8Slice *this, int a2, int a3)
{
  float *v3;
  double result;

  switch(a2)
  {
    case 0:
      v3 = (float *)((char *)this + 4 * a3 + 16);
      goto LABEL_10;
    case 1:
      v3 = (float *)((char *)this + 4 * a3 + 32);
      goto LABEL_10;
    case 2:
      v3 = (float *)((char *)this + 4 * a3 + 48);
      goto LABEL_10;
    case 3:
      v3 = (float *)((char *)this + 4 * a3 + 64);
      goto LABEL_10;
    case 4:
      v3 = (float *)((char *)this + 4 * a3 + 80);
      goto LABEL_10;
    case 5:
      v3 = (float *)((char *)this + 4 * a3 + 96);
      goto LABEL_10;
    case 6:
      v3 = (float *)((char *)this + 4 * a3 + 112);
      goto LABEL_10;
    case 7:
      v3 = (float *)((char *)this + 4 * a3 + 128);
LABEL_10:
      result = *v3;
      break;
    default:
      return result;
  }
  return result;
}

float `anonymous namespace'::MatrixMixer1x8Slice::SetParameter(_anonymous_namespace_::MatrixMixer1x8Slice *this, int a2, int a3, double a4)
{
  switch(a2)
  {
    case 0:
      *(float *)&a4 = a4;
      *((_DWORD *)this + a3 + 4) = LODWORD(a4);
      break;
    case 1:
      *(float *)&a4 = a4;
      *((_DWORD *)this + a3 + 8) = LODWORD(a4);
      break;
    case 2:
      *(float *)&a4 = a4;
      *((_DWORD *)this + a3 + 12) = LODWORD(a4);
      break;
    case 3:
      *(float *)&a4 = a4;
      *((_DWORD *)this + a3 + 16) = LODWORD(a4);
      break;
    case 4:
      *(float *)&a4 = a4;
      *((_DWORD *)this + a3 + 20) = LODWORD(a4);
      break;
    case 5:
      *(float *)&a4 = a4;
      *((_DWORD *)this + a3 + 24) = LODWORD(a4);
      break;
    case 6:
      *(float *)&a4 = a4;
      *((_DWORD *)this + a3 + 28) = LODWORD(a4);
      break;
    case 7:
      *(float *)&a4 = a4;
      *((_DWORD *)this + a3 + 32) = LODWORD(a4);
      break;
    default:
      return *(float *)&a4;
  }
  return *(float *)&a4;
}

__n128 `anonymous namespace'::MatrixMixer1x8Slice::UpdateParameters(__n128 *a1)
{
  __n128 result;
  __n128 v3;
  __n128 v4;
  __n128 v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;
  __n128 v9;
  __n128 v10;
  __n128 v11;
  __n128 v12;
  __n128 v13;
  __n128 v14;
  __n128 v15;
  __n128 v16;
  __n128 v17;
  __n128 v18;

  v17 = a1[267];
  v18 = a1[266];
  v7 = a1[1];
  v15 = a1[268];
  v16 = a1[2];
  v14 = a1[269];
  v6 = a1[3];
  v12 = a1[270];
  v13 = a1[4];
  v10 = a1[6];
  v11 = a1[271];
  v8 = a1[273];
  v9 = a1[272];
  v3 = a1[7];
  v4 = a1[8];
  v5 = a1[5];
  memcpy(&a1[274], &a1[9], 0x1010uLL);
  a1[531] = v18;
  a1[532] = v7;
  a1[533] = v17;
  a1[534] = v16;
  a1[535] = v15;
  a1[536] = v6;
  a1[537] = v14;
  a1[538] = v13;
  a1[539] = v12;
  a1[540] = v5;
  a1[541] = v11;
  a1[542] = v10;
  a1[543] = v9;
  a1[544] = v3;
  a1[545] = v8;
  result = v4;
  a1[546] = v4;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x8Slice::UpdateParameters(uint64_t result, uint64_t a2, int a3)
{
  _DWORD *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  _DWORD *v21;
  _DWORD *v22;

  v3 = (_DWORD *)(result + 4 * a3);
  v4 = v3[1064];
  v5 = v3[4];
  v6 = v3[1068];
  v7 = v3[8];
  v8 = v3[1072];
  v9 = v3[12];
  v10 = v3[1076];
  v11 = v3[16];
  v12 = v3[1080];
  v13 = v3[20];
  v14 = v3[1084];
  v15 = v3[24];
  v16 = v3[1088];
  v17 = v3[28];
  v18 = v3[1092];
  v19 = v3[32];
  v20 = v3[36];
  v3[1096] = v20;
  if ((int)v20 >= 1)
  {
    v21 = (_DWORD *)(result + 4 * a3);
    do
    {
      v21[1100] = v21[40];
      v21[1104] = v21[44];
      v21 += 8;
      --v20;
    }
    while (v20);
  }
  v22 = (_DWORD *)(result + 4 * a3);
  v22[2124] = v4;
  v22[2128] = v5;
  v22[2132] = v6;
  v22[2136] = v7;
  v22[2140] = v8;
  v22[2144] = v9;
  v22[2148] = v10;
  v22[2152] = v11;
  v22[2156] = v12;
  v22[2160] = v13;
  v22[2164] = v14;
  v22[2168] = v15;
  v22[2172] = v16;
  v22[2176] = v17;
  v22[2180] = v18;
  v22[2184] = v19;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x8Slice::Run(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int32x4_t v4;
  int64x2_t v5;
  uint64_t v6;
  float32x4_t *v7;
  float32x4_t v8;
  int32x4_t v9;
  int32x4_t v10;
  int8x16_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int v19;
  unint64_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  int8x16_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  int8x16_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  int8x16_t v36;

  v4 = (int32x4_t)vandq_s8(*(int8x16_t *)(result + 4384), (int8x16_t)vcgtq_s32(vdupq_n_s32(a4), (int32x4_t)xmmword_2166F76B0));
  v5 = (int64x2_t)vcgtzq_s32(v4);
  if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0])
  {
    v6 = *(_QWORD *)(a2 + 56);
    v7 = (float32x4_t *)(result + 4416);
    v8 = 0uLL;
    v9 = 0uLL;
    v10.i64[0] = 0x100000001;
    v10.i64[1] = 0x100000001;
    do
    {
      v11.i32[0] = *(_DWORD *)(v6 + 4 * v7[-1].i32[0]);
      v11.i32[1] = *(_DWORD *)(v6 + 4 * v7[-1].i32[1]);
      v11.i32[2] = *(_DWORD *)(v6 + 4 * v7[-1].i32[2]);
      v11.i32[3] = *(_DWORD *)(v6 + 4 * v7[-1].i32[3]);
      v8 = vmlaq_f32(v8, (float32x4_t)vandq_s8((int8x16_t)v5, v11), *v7);
      v9 = vaddq_s32(v9, v10);
      v5 = (int64x2_t)vcgtq_s32(v4, v9);
      v7 += 2;
    }
    while (vorrq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0]);
  }
  else
  {
    v8 = 0uLL;
  }
  v12 = *(float32x4_t *)(result + 8544);
  v13 = *(float32x4_t *)(result + 8576);
  v14 = *(float32x4_t *)(result + 8608);
  v15 = *(float32x4_t *)(result + 8640);
  v16 = *(float32x4_t *)(result + 8672);
  v17 = *(float32x4_t *)(result + 8704);
  v18 = *(float32x4_t *)(result + 8736);
  HIDWORD(v20) = a4 - 1;
  LODWORD(v20) = a4 - 1;
  v19 = v20 >> 1;
  v21 = vmulq_f32(*(float32x4_t *)(result + 8512), v8);
  v22 = vandq_s8((int8x16_t)v21, vorrq_s8((int8x16_t)vcltzq_f32(v21), (int8x16_t)vcgezq_f32(v21)));
  switch(v19)
  {
    case 0:
      goto LABEL_10;
    case 1:
      goto LABEL_9;
    case 3:
      goto LABEL_8;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8508)) = v22.i32[3];
LABEL_8:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8504)) = v22.i32[2];
LABEL_9:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8500)) = v22.i32[1];
LABEL_10:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8496)) = v22.i32[0];
      break;
    default:
      break;
  }
  v23 = vmulq_f32(v12, v8);
  v24 = vandq_s8((int8x16_t)v23, vorrq_s8((int8x16_t)vcltzq_f32(v23), (int8x16_t)vcgezq_f32(v23)));
  switch(v19)
  {
    case 0:
      goto LABEL_15;
    case 1:
      goto LABEL_14;
    case 3:
      goto LABEL_13;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8540)) = v24.i32[3];
LABEL_13:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8536)) = v24.i32[2];
LABEL_14:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8532)) = v24.i32[1];
LABEL_15:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8528)) = v24.i32[0];
      break;
    default:
      break;
  }
  v25 = vmulq_f32(v13, v8);
  v26 = vandq_s8((int8x16_t)v25, vorrq_s8((int8x16_t)vcltzq_f32(v25), (int8x16_t)vcgezq_f32(v25)));
  switch(v19)
  {
    case 0:
      goto LABEL_20;
    case 1:
      goto LABEL_19;
    case 3:
      goto LABEL_18;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8572)) = v26.i32[3];
LABEL_18:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8568)) = v26.i32[2];
LABEL_19:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8564)) = v26.i32[1];
LABEL_20:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8560)) = v26.i32[0];
      break;
    default:
      break;
  }
  v27 = vmulq_f32(v14, v8);
  v28 = vandq_s8((int8x16_t)v27, vorrq_s8((int8x16_t)vcltzq_f32(v27), (int8x16_t)vcgezq_f32(v27)));
  switch(v19)
  {
    case 0:
      goto LABEL_25;
    case 1:
      goto LABEL_24;
    case 3:
      goto LABEL_23;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8604)) = v28.i32[3];
LABEL_23:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8600)) = v28.i32[2];
LABEL_24:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8596)) = v28.i32[1];
LABEL_25:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8592)) = v28.i32[0];
      break;
    default:
      break;
  }
  v29 = vmulq_f32(v15, v8);
  v30 = vandq_s8((int8x16_t)v29, vorrq_s8((int8x16_t)vcltzq_f32(v29), (int8x16_t)vcgezq_f32(v29)));
  switch(v19)
  {
    case 0:
      goto LABEL_30;
    case 1:
      goto LABEL_29;
    case 3:
      goto LABEL_28;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8636)) = v30.i32[3];
LABEL_28:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8632)) = v30.i32[2];
LABEL_29:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8628)) = v30.i32[1];
LABEL_30:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8624)) = v30.i32[0];
      break;
    default:
      break;
  }
  v31 = vmulq_f32(v16, v8);
  v32 = vandq_s8((int8x16_t)v31, vorrq_s8((int8x16_t)vcltzq_f32(v31), (int8x16_t)vcgezq_f32(v31)));
  switch(v19)
  {
    case 0:
      goto LABEL_35;
    case 1:
      goto LABEL_34;
    case 3:
      goto LABEL_33;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8668)) = v32.i32[3];
LABEL_33:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8664)) = v32.i32[2];
LABEL_34:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8660)) = v32.i32[1];
LABEL_35:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8656)) = v32.i32[0];
      break;
    default:
      break;
  }
  v33 = vmulq_f32(v17, v8);
  v34 = vandq_s8((int8x16_t)v33, vorrq_s8((int8x16_t)vcltzq_f32(v33), (int8x16_t)vcgezq_f32(v33)));
  switch(v19)
  {
    case 0:
      goto LABEL_40;
    case 1:
      goto LABEL_39;
    case 3:
      goto LABEL_38;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8700)) = v34.i32[3];
LABEL_38:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8696)) = v34.i32[2];
LABEL_39:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8692)) = v34.i32[1];
LABEL_40:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8688)) = v34.i32[0];
      break;
    default:
      break;
  }
  v35 = vmulq_f32(v18, v8);
  v36 = vandq_s8((int8x16_t)v35, vorrq_s8((int8x16_t)vcltzq_f32(v35), (int8x16_t)vcgezq_f32(v35)));
  switch(v19)
  {
    case 0:
      goto LABEL_45;
    case 1:
      goto LABEL_44;
    case 3:
      goto LABEL_43;
    case 7:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8732)) = v36.i32[3];
LABEL_43:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8728)) = v36.i32[2];
LABEL_44:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8724)) = v36.i32[1];
LABEL_45:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * *(int *)(result + 8720)) = v36.i32[0];
      break;
    default:
      return result;
  }
  return result;
}

float `anonymous namespace'::MatrixMixer1x8Slice::CopyVoiceState(_anonymous_namespace_::MatrixMixer1x8Slice *this, Phase::DspLayer::VoicePoolSlice *a2, int a3, int a4)
{
  _DWORD *v4;
  _DWORD *v5;
  uint64_t v6;
  _DWORD *v7;
  int *v8;
  int v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _DWORD *v13;
  int *v14;
  int v15;
  float result;

  v4 = (_DWORD *)((char *)a2 + 4 * a3);
  v5 = (_DWORD *)((char *)this + 4 * a4);
  v5[4] = v4[4];
  v5[8] = v4[8];
  v5[12] = v4[12];
  v5[16] = v4[16];
  v5[20] = v4[20];
  v5[24] = v4[24];
  v5[28] = v4[28];
  v5[32] = v4[32];
  v6 = v4[36];
  v5[36] = v6;
  if ((int)v6 >= 1)
  {
    v7 = (_DWORD *)((char *)this + 4 * a4 + 176);
    v8 = (int *)((char *)a2 + 4 * a3 + 176);
    do
    {
      *(v7 - 4) = *(v8 - 4);
      v9 = *v8;
      v8 += 8;
      *v7 = v9;
      v7 += 8;
      --v6;
    }
    while (v6);
  }
  v10 = (char *)this + 4 * a4;
  v11 = (char *)a2 + 4 * a3;
  v12 = *((unsigned int *)v11 + 1096);
  *((_DWORD *)v10 + 1096) = v12;
  if ((int)v12 >= 1)
  {
    v13 = v10 + 4416;
    v14 = (int *)(v11 + 4416);
    do
    {
      *(v13 - 4) = *(v14 - 4);
      v15 = *v14;
      v14 += 8;
      *v13 = v15;
      v13 += 8;
      --v12;
    }
    while (v12);
  }
  *((_DWORD *)v10 + 1064) = *((_DWORD *)v11 + 1064);
  *((_DWORD *)v10 + 1068) = *((_DWORD *)v11 + 1068);
  *((_DWORD *)v10 + 1072) = *((_DWORD *)v11 + 1072);
  *((_DWORD *)v10 + 1076) = *((_DWORD *)v11 + 1076);
  *((_DWORD *)v10 + 1080) = *((_DWORD *)v11 + 1080);
  *((_DWORD *)v10 + 1084) = *((_DWORD *)v11 + 1084);
  *((_DWORD *)v10 + 1088) = *((_DWORD *)v11 + 1088);
  *((_DWORD *)v10 + 1092) = *((_DWORD *)v11 + 1092);
  *((_DWORD *)v10 + 2124) = *((_DWORD *)v11 + 2124);
  *((_DWORD *)v10 + 2128) = *((_DWORD *)v11 + 2128);
  *((_DWORD *)v10 + 2132) = *((_DWORD *)v11 + 2132);
  *((_DWORD *)v10 + 2136) = *((_DWORD *)v11 + 2136);
  *((_DWORD *)v10 + 2140) = *((_DWORD *)v11 + 2140);
  *((_DWORD *)v10 + 2144) = *((_DWORD *)v11 + 2144);
  *((_DWORD *)v10 + 2148) = *((_DWORD *)v11 + 2148);
  *((_DWORD *)v10 + 2152) = *((_DWORD *)v11 + 2152);
  *((_DWORD *)v10 + 2156) = *((_DWORD *)v11 + 2156);
  *((_DWORD *)v10 + 2160) = *((_DWORD *)v11 + 2160);
  *((_DWORD *)v10 + 2164) = *((_DWORD *)v11 + 2164);
  *((_DWORD *)v10 + 2168) = *((_DWORD *)v11 + 2168);
  *((_DWORD *)v10 + 2172) = *((_DWORD *)v11 + 2172);
  *((_DWORD *)v10 + 2176) = *((_DWORD *)v11 + 2176);
  *((_DWORD *)v10 + 2180) = *((_DWORD *)v11 + 2180);
  result = *((float *)v11 + 2184);
  *((float *)v10 + 2184) = result;
  *((_QWORD *)this + a4 + 1094) = *((_QWORD *)a2 + a3 + 1094);
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x8Slice::AddInput(_anonymous_namespace_::MatrixMixer1x8Slice *this, int a2, int a3, int a4, float a5)
{
  uint64_t result;
  char *v7;
  uint64_t v8;
  char *v9;

  if (a2)
    return 8;
  v7 = (char *)this + 144;
  v8 = *((int *)this + a3 + 36);
  if ((int)v8 > 127)
    return 6;
  result = 0;
  v9 = (char *)this + 32 * v8 + 4 * a3;
  *((_DWORD *)v9 + 40) = a4;
  *((float *)v9 + 44) = a5;
  *(_DWORD *)&v7[4 * a3] = v8 + 1;
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x8Slice::RemoveInput(_anonymous_namespace_::MatrixMixer1x8Slice *this, int a2, int a3, int a4)
{
  if (a2)
    return 8;
  else
    return Phase::DspLayer::VoiceConnectionList<128>::RemoveConnection((uint64_t)this + 144, a3, a4);
}

uint64_t `anonymous namespace'::MatrixMixer1x8Slice::SetInputGain(_anonymous_namespace_::MatrixMixer1x8Slice *this, int a2, int a3, int a4, float a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  float *i;

  if (a2)
    return 8;
  v6 = *((unsigned int *)this + a3 + 36);
  if ((int)v6 < 1)
    return 7;
  v7 = 0;
  for (i = (float *)((char *)this + 4 * a3 + 176); *((_DWORD *)i - 4) != a4; i += 8)
  {
    if (v6 == ++v7)
      return 7;
  }
  if ((v7 & 0x80000000) != 0)
    return 7;
  result = 0;
  *i = a5;
  return result;
}

void `anonymous namespace'::MatrixMixer1x8Slice::GetInputs(_anonymous_namespace_::MatrixMixer1x8Slice *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (a2)
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    *(_QWORD *)(a4 + 16) = 0;
  }
  else
  {
    Phase::DspLayer::VoiceConnectionList<128>::GetConnections((uint64_t)this + 144, a3, (char **)a4);
  }
}

uint64_t `anonymous namespace'::MatrixMixer1x8Slice::ClearInputs(_anonymous_namespace_::MatrixMixer1x8Slice *this, int a2)
{
  *((_DWORD *)this + a2 + 36) = 0;
  return 0;
}

uint64_t `anonymous namespace'::MatrixMixer1x8Slice::GetMaximumInputConnectionCount(_anonymous_namespace_::MatrixMixer1x8Slice *this, int a2)
{
  return (a2 == 0) << 7;
}

unint64_t `anonymous namespace'::MatrixMixer1x8Slice::GetOutput(_anonymous_namespace_::MatrixMixer1x8Slice *this, int a2, int a3)
{
  char *v3;
  uint64_t v4;
  unint64_t result;

  switch(a2)
  {
    case 0:
      v3 = (char *)this + 4 * a3;
      v4 = 4256;
      goto LABEL_11;
    case 1:
      v3 = (char *)this + 4 * a3;
      v4 = 4272;
      goto LABEL_11;
    case 2:
      v3 = (char *)this + 4 * a3;
      v4 = 4288;
      goto LABEL_11;
    case 3:
      v3 = (char *)this + 4 * a3;
      v4 = 4304;
      goto LABEL_11;
    case 4:
      v3 = (char *)this + 4 * a3;
      v4 = 4320;
      goto LABEL_11;
    case 5:
      v3 = (char *)this + 4 * a3;
      v4 = 4336;
      goto LABEL_11;
    case 6:
      v3 = (char *)this + 4 * a3;
      v4 = 4352;
      goto LABEL_11;
    case 7:
      v3 = (char *)this + 4 * a3;
      v4 = 4368;
LABEL_11:
      result = (unint64_t)*(unsigned int *)&v3[v4] << 32;
      break;
    default:
      result = 0xFFFFFFFF00000008;
      break;
  }
  return result;
}

uint64_t `anonymous namespace'::MatrixMixer1x8Slice::SetOutput(_anonymous_namespace_::MatrixMixer1x8Slice *this, int a2, int a3, int a4)
{
  char *v4;
  uint64_t v5;
  uint64_t result;

  switch(a2)
  {
    case 0:
      v4 = (char *)this + 4 * a3;
      v5 = 4256;
      goto LABEL_11;
    case 1:
      v4 = (char *)this + 4 * a3;
      v5 = 4272;
      goto LABEL_11;
    case 2:
      v4 = (char *)this + 4 * a3;
      v5 = 4288;
      goto LABEL_11;
    case 3:
      v4 = (char *)this + 4 * a3;
      v5 = 4304;
      goto LABEL_11;
    case 4:
      v4 = (char *)this + 4 * a3;
      v5 = 4320;
      goto LABEL_11;
    case 5:
      v4 = (char *)this + 4 * a3;
      v5 = 4336;
      goto LABEL_11;
    case 6:
      v4 = (char *)this + 4 * a3;
      v5 = 4352;
      goto LABEL_11;
    case 7:
      v4 = (char *)this + 4 * a3;
      v5 = 4368;
LABEL_11:
      result = 0;
      *(_DWORD *)&v4[v5] = a4;
      break;
    default:
      result = 8;
      break;
  }
  return result;
}

void std::__function::__func<Phase::DspLayer::MatrixMixer1x8::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::MatrixMixer1x8::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<Phase::DspLayer::MatrixMixer1x8::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::MatrixMixer1x8::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57EF58;
  return result;
}

void std::__function::__func<Phase::DspLayer::MatrixMixer1x8::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::MatrixMixer1x8::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57EF58;
}

uint64_t std::__function::__func<Phase::DspLayer::MatrixMixer1x8::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::MatrixMixer1x8::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::operator()(uint64_t a1, Phase::DspLayer::VoiceEngine **a2, int *a3)
{
  Phase::DspLayer::VoiceEngine *v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v12;
  __int128 v14;

  v3 = *a2;
  v4 = *a3;
  v5 = operator new();
  Phase::DspLayer::VoicePool::VoicePool((Phase::DspLayer::VoicePool *)v5, "MatrixMixer1x8", v3, v4, 8784);
  *(_QWORD *)v5 = &off_24D57EE60;
  if (*(int *)(v5 + 40) >= 1)
  {
    v6 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    v14 = _Q0;
    do
    {
      v12 = *(_QWORD *)(v5 + 24) + *(int *)(v5 + 16) * (uint64_t)v6;
      *(_QWORD *)v12 = &off_24D57EE80;
      *(_QWORD *)(v12 + 8) = 0;
      bzero((void *)(v12 + 160), 0x1000uLL);
      bzero((void *)(v12 + 4384), 0x1010uLL);
      *(_OWORD *)(v12 + 16) = v14;
      *(_OWORD *)(v12 + 32) = 0u;
      *(_OWORD *)(v12 + 48) = 0u;
      *(_OWORD *)(v12 + 64) = 0u;
      *(_OWORD *)(v12 + 80) = 0u;
      *(_OWORD *)(v12 + 96) = 0u;
      *(_OWORD *)(v12 + 112) = 0u;
      *(_OWORD *)(v12 + 128) = 0u;
      *(_OWORD *)(v12 + 144) = 0u;
      *(_OWORD *)(v12 + 4256) = 0u;
      *(_OWORD *)(v12 + 4272) = 0u;
      *(_OWORD *)(v12 + 4288) = 0u;
      *(_OWORD *)(v12 + 4304) = 0u;
      *(_OWORD *)(v12 + 4320) = 0u;
      *(_OWORD *)(v12 + 4336) = 0u;
      *(_OWORD *)(v12 + 4352) = 0u;
      *(_OWORD *)(v12 + 4368) = 0u;
      *(_OWORD *)(v12 + 8768) = 0u;
      *(_OWORD *)(v12 + 8752) = 0u;
      ++v6;
    }
    while (v6 < *(_DWORD *)(v5 + 40));
  }
  return v5;
}

void sub_21660D1EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199F9D70](v1, 0x10F1C408EBD29CELL);
  _Unwind_Resume(a1);
}

void Phase::sGetStdStringFromNsString(Phase *this@<X0>, _QWORD *a2@<X8>)
{
  Phase *v4;

  v4 = objc_retainAutorelease(this);
  std::string::basic_string[abi:ne180100](a2, (void *)-[Phase UTF8String](v4, "UTF8String"), -[Phase lengthOfBytesUsingEncoding:](v4, "lengthOfBytesUsingEncoding:", 4));

}

void sub_21660D268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void Phase::MdlMeshAsset::Initialize(Phase::MdlMeshAsset *this, void *a2)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  unint64_t i;
  void *v9;
  unint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  id v14;
  void *v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  void **v19;
  void *v20;
  void *v21;
  NSObject *v22;
  std::runtime_error *exception;
  id v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v4 = v3;
  else
    v4 = 0;
  v24 = v4;

  if (!v24)
  {
    v22 = objc_retainAutorelease(**(id **)Phase::Logger::GetInstancePtr(0));
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v26 = "MdlMeshAsset.mm";
      v27 = 1024;
      v28 = 161;
      _os_log_impl(&dword_2164CC000, v22, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [inMesh == nil is true]: \"Input pointer is not an MDLMesh instance!\"", buf, 0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Input pointer is not an MDLMesh instance!");
  }
  v5 = (void *)MEMORY[0x24BDBCEB8];
  objc_msgSend(v24, "submeshes");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "arrayWithCapacity:", objc_msgSend(v6, "count"));
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  for (i = 0; ; ++i)
  {
    objc_msgSend(v24, "submeshes");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v10 = objc_msgSend(v9, "count");

    if (i >= v10)
      break;
    objc_msgSend(v24, "submeshes");
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "objectAtIndexedSubscript:", i);
    v12 = (void *)objc_claimAutoreleasedReturnValue();

    v13 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDDE6F8]), "initWithMDLSubmesh:indexType:geometryType:", v12, objc_msgSend(v12, "indexType"), objc_msgSend(v12, "geometryType"));
    objc_msgSend(v7, "setObject:atIndexedSubscript:", v13, i);

  }
  v14 = objc_alloc(MEMORY[0x24BDDE6E0]);
  objc_msgSend(v24, "vertexBuffers");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v16 = objc_msgSend(v24, "vertexCount");
  objc_msgSend(v24, "vertexDescriptor");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = objc_msgSend(v14, "initWithVertexBuffers:vertexCount:descriptor:submeshes:", v15, v16, v17, v7);
  v19 = (void **)*((_QWORD *)this + 1);
  v20 = *v19;
  *v19 = (void *)v18;

  objc_msgSend(v24, "transform");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(**((id **)this + 1), "setTransform:", v21);

}

void sub_21660D534(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

Phase::MdlMeshAsset *Phase::MdlMeshAsset::MdlMeshAsset(Phase::MdlMeshAsset *this, const Phase::MdlMeshAsset *a2)
{
  _QWORD *v4;
  void **v5;

  *(_DWORD *)this = 1;
  v4 = (_QWORD *)operator new();
  *((_QWORD *)this + 1) = v4;
  *v4 = 0;
  v5 = (void **)*((_QWORD *)a2 + 1);
  if (v5 && *v5)
    Phase::MdlMeshAsset::Initialize(this, *v5);
  return this;
}

void sub_21660D64C(_Unwind_Exception *a1)
{
  id **v1;

  std::unique_ptr<Phase::details::MdlMeshAssetImplementation>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t Phase::MdlMeshAsset::GetName(id **this)
{
  void *v1;
  void *v2;
  uint64_t v3;

  objc_msgSend(*this[1], "name");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = v1;
  if (v1)
    v3 = objc_msgSend(objc_retainAutorelease(v1), "UTF8String");
  else
    v3 = 0;

  return v3;
}

void sub_21660D6C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void Phase::MdlMeshAsset::SetVertexDescriptor(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v11;
  uint64_t v12;
  id v13;
  id v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  void *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  void *v23;
  void *v24;
  __int128 v26;
  id v27;

  v27 = objc_alloc_init(MEMORY[0x24BDDE718]);
  v3 = *a2;
  if (a2[1] != *a2)
  {
    v4 = 0;
    v5 = 32;
    __asm { FMOV            V0.4S, #1.0 }
    do
    {
      v11 = v3 + v5;
      switch(*(_BYTE *)(v3 + v5 - 8))
      {
        case '-':
          *(_QWORD *)&v26 = *(unsigned int *)(v3 + v5 + 24);
          v12 = 786433;
          break;
        case '.':
          *(_QWORD *)&v26 = *(_QWORD *)(v3 + v5 + 24);
          v12 = 786434;
          break;
        case '/':
          *(_QWORD *)&v26 = *(_QWORD *)(v3 + v5 + 24);
          v12 = 786435;
          break;
        case '0':
          v26 = *(_OWORD *)(v3 + v5 + 24);
          v12 = 786436;
          break;
        default:
          v12 = 0;
          *(_QWORD *)&v26 = 0;
          break;
      }
      v13 = objc_alloc(MEMORY[0x24BDDE708]);
      v14 = objc_alloc(MEMORY[0x24BDD17C8]);
      v15 = *(char *)(v3 + v5 - 9);
      if (v15 >= 0)
        v16 = v11 - 32;
      else
        v16 = *(_QWORD *)(v11 - 32);
      if (v15 >= 0)
        v17 = *(unsigned __int8 *)(v3 + v5 - 9);
      else
        v17 = *(_QWORD *)(v3 + v5 - 24);
      v18 = (void *)objc_msgSend(v14, "initWithBytes:length:encoding:", v16, v17, 1);
      v19 = (void *)objc_msgSend(v13, "initWithName:format:offset:bufferIndex:", v18, v12, *(_QWORD *)(v3 + v5), *(_QWORD *)(v3 + v5 + 8));

      objc_msgSend(v19, "setTime:", *(double *)(v3 + v5 + 16));
      objc_msgSend(v19, "setInitializationValue:", *(double *)&v26);
      objc_msgSend(v27, "addOrReplaceAttribute:", v19);

      ++v4;
      v3 = *a2;
      v5 += 72;
    }
    while (0x8E38E38E38E38E39 * ((a2[1] - *a2) >> 3) > v4);
  }
  v20 = a2[3];
  if (a2[4] != v20)
  {
    v21 = 0;
    do
    {
      v22 = *(_QWORD *)(v20 + 8 * v21);
      objc_msgSend(v27, "layouts");
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v23, "objectAtIndexedSubscript:", v21);
      v24 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v24, "setStride:", v22);

      ++v21;
      v20 = a2[3];
    }
    while (v21 < (a2[4] - v20) >> 3);
  }
  objc_msgSend(**(id **)(a1 + 8), "setVertexDescriptor:", v27);

}

void sub_21660D960(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{

  _Unwind_Resume(a1);
}

uint64_t Phase::MdlMeshAsset::GetVertexBuffer(id **this, uint64_t a2)
{
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;

  objc_msgSend(*this[1], "vertexBuffers");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "objectAtIndexedSubscript:", a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "map");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "bytes");

  return v6;
}

void sub_21660DA18(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

uint64_t Phase::MdlMeshAsset::GetSubmeshCount(id **this)
{
  void *v1;
  uint64_t v2;

  objc_msgSend(*this[1], "submeshes");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = objc_msgSend(v1, "count");

  return v2;
}

void sub_21660DA80(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void *Phase::MdlMeshAsset::GetSubmesh(id **this, uint64_t a2)
{
  void *v3;
  void *v4;

  objc_msgSend(*this[1], "submeshes");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "objectAtIndexedSubscript:", a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

void sub_21660DADC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void Phase::MdlMeshAsset::SetTopology(uint64_t a1, int a2)
{
  unint64_t v3;
  uint64_t v4;
  void *v5;
  unint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  void *v10;
  void *v11;

  v3 = 0;
  if ((a2 - 1) < 5)
    v4 = (a2 - 1) + 1;
  else
    v4 = 0;
  while (1)
  {
    objc_msgSend(**(id **)(a1 + 8), "submeshes");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v6 = objc_msgSend(v5, "count");

    if (v3 >= v6)
      break;
    objc_msgSend(**(id **)(a1 + 8), "submeshes");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v7, "objectAtIndexedSubscript:", v3);
    v8 = (void *)objc_claimAutoreleasedReturnValue();

    if (objc_msgSend(v8, "geometryType") != v4)
    {
      v9 = objc_msgSend(v8, "indexType");
      v10 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDDE6F8]), "initWithMDLSubmesh:indexType:geometryType:", v8, v9, v4);
      objc_msgSend(**(id **)(a1 + 8), "submeshes");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "setObject:atIndexedSubscript:", v10, v3);

    }
    ++v3;
  }
}

void sub_21660DBF4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t Phase::MdlMeshAsset::Submesh::GetIndexBuffer(id *this)
{
  void *v1;
  void *v2;
  uint64_t v3;

  objc_msgSend(*this, "indexBuffer");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "map");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "bytes");

  return v3;
}

void sub_21660DC84(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t Phase::MdlMeshAsset::Submesh::GetIndexBufferFormat(id *this)
{
  unint64_t v1;
  char v2;

  v1 = __ROR8__(objc_msgSend(*this, "indexType"), 3);
  if (v1 >= 5)
    v2 = 0;
  else
    v2 = 0x300020100uLL >> (8 * v1);
  return v2 & 3;
}

id **std::unique_ptr<Phase::details::MdlMeshAssetImplementation>::reset[abi:ne180100](id **result, id *a2)
{
  id *v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {

    JUMPOUT(0x2199F9D70);
  }
  return result;
}

uint64_t Phase::MallocAligned(Phase *this, size_t a2)
{
  uint8x8_t v3;
  size_t v4;
  NSObject *v6;
  std::logic_error *exception;
  NSObject *v8;
  std::logic_error *v9;
  _BYTE v10[12];
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (!this)
  {
    v6 = **(NSObject ***)(Phase::Logger::GetInstancePtr(0) + 176);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v10 = 136315394;
      *(_QWORD *)&v10[4] = "Memory.cpp";
      v11 = 1024;
      v12 = 56;
      _os_log_impl(&dword_2164CC000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: inSizeInBytes > 0 is false.", v10, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::domain_error::domain_error[abi:ne180100](exception, "PRECONDITION: inSizeInBytes > 0 is false.");
  }
  v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] != 1)
  {
    v8 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 176);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v10 = 136315394;
      *(_QWORD *)&v10[4] = "Memory.cpp";
      v11 = 1024;
      v12 = 58;
      _os_log_impl(&dword_2164CC000, v8, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: (inAlignment > 0) && IsPowerOfTwo(static_cast<uint64_t>(inAlignment)) is false.", v10, 0x12u);
    }
    v9 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::domain_error::domain_error[abi:ne180100](v9, "PRECONDITION: (inAlignment > 0) && IsPowerOfTwo(static_cast<uint64_t>(inAlignment)) is false.");
  }
  *(_QWORD *)v10 = 0;
  v4 = Phase::AlignUp<unsigned long>(this, a2);
  if (malloc_type_posix_memalign((void **)v10, a2, v4, 0xC9CCEEE9uLL))
    return 0;
  else
    return *(_QWORD *)v10;
}

void sub_21660DEFC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::AlignUp<unsigned long>(Phase::Logger *a1, uint64_t a2)
{
  uint8x8_t v2;
  NSObject *v4;
  std::logic_error *exception;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] != 1)
  {
    v4 = **(NSObject ***)(Phase::Logger::GetInstancePtr(a1) + 96);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6 = 136315394;
      v7 = "MathFunctions.h";
      v8 = 1024;
      v9 = 648;
      _os_log_impl(&dword_2164CC000, v4, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: IsPowerOfTwo(alignment) is false.", (uint8_t *)&v6, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "PRECONDITION: IsPowerOfTwo(alignment) is false.");
  }
  return ((unint64_t)a1 + a2 - 1) & -a2;
}

void sub_21660E02C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void Phase::Memset8(Phase *this, void *a2, size_t a3)
{
  NSObject *v3;
  std::logic_error *exception;
  void *__pattern8;
  uint8_t buf[4];
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  __pattern8 = a2;
  if ((a3 & 0x8000000000000000) != 0)
  {
    v3 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 176);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v7 = "Memory.cpp";
      v8 = 1024;
      v9 = 214;
      _os_log_impl(&dword_2164CC000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: inSizeInBytes >= 0 is false.", buf, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::domain_error::domain_error[abi:ne180100](exception, "PRECONDITION: inSizeInBytes >= 0 is false.");
  }
  memset_pattern8(this, &__pattern8, a3);
}

void sub_21660E140(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

BOOL Phase::MemCompare8(Phase *this, const void *a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  const void **v6;
  const void *v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BOOL8 result;
  unint64_t v20;
  const void *v21;
  NSObject *v22;
  std::logic_error *exception;
  int v24;
  const char *v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  if (a3 < 0)
  {
    v22 = **(NSObject ***)(Phase::Logger::GetInstancePtr(this) + 176);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      v24 = 136315394;
      v25 = "Memory.cpp";
      v26 = 1024;
      v27 = 221;
      _os_log_impl(&dword_2164CC000, v22, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: inSizeInBytes >= 0 is false.", (uint8_t *)&v24, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::domain_error::domain_error[abi:ne180100](exception, "PRECONDITION: inSizeInBytes >= 0 is false.");
  }
  v3 = a3 + 7;
  v4 = (unint64_t)(a3 + 7) >> 3;
  v5 = (a3 + 7) & 0xFFFFFFFFFFFFFFC0;
  v6 = (const void **)((char *)this + v5);
  while (v5)
  {
    v7 = *(const void **)this;
    v8 = (const void *)*((_QWORD *)this + 1);
    v9 = *((_QWORD *)this + 2);
    v10 = *((_QWORD *)this + 3);
    v11 = *((_QWORD *)this + 4);
    v12 = *((_QWORD *)this + 5);
    v13 = *((_QWORD *)this + 6);
    v14 = *((_QWORD *)this + 7);
    this = (Phase *)((char *)this + 64);
    v5 -= 64;
    if (v7 != a2 || v9 != v10 || v7 != v8 || v11 != v12 || v13 != v14)
      return 0;
  }
  v20 = 8 * v4 - (v3 & 0xFFFFFFFFFFFFFFC0);
  do
  {
    result = v20 == 0;
    if (!v20)
      break;
    v21 = *v6++;
    v20 -= 8;
  }
  while (v21 == a2);
  return result;
}

void sub_21660E2BC(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t Phase::SetMetaParameterValue(_QWORD *a1, int a2, uint64_t a3, double a4)
{
  double v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (a2 != 2)
  {
    if (a2 != 1)
      return 0;
    v6 = fmin(fmax(*(double *)&a3, *(double *)(*a1 + 32)), *(double *)(*a1 + 40));
    v10[0] = &unk_24D5770F0;
    v10[1] = Phase::CurveFunction::Linear<double>;
    v11 = v10;
    Phase::Fader<double>::SetInternal((uint64_t)(a1 + 1), (uint64_t)v10, v6, a4);
    v7 = v11;
    if (v11 == v10)
    {
      v8 = 4;
      v7 = v10;
    }
    else
    {
      if (!v11)
      {
LABEL_10:
        a1[7] = a1[6];
        return 1;
      }
      v8 = 5;
    }
    (*(void (**)(void))(*v7 + 8 * v8))();
    goto LABEL_10;
  }
  a1[7] = a3;
  return 1;
}

void sub_21660E3C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t Phase::GlobalMetaParameterManager::SetGlobalMetaParameter(uint64_t a1, unint64_t a2, int a3, uint64_t a4, double a5)
{
  unint64_t v5;
  _QWORD *v10;
  id *v11;
  id *v12;
  id *v13;
  id WeakRetained;
  void *v15;
  id v16;
  id v17;
  PHASEGlobalMetaParameterAsset *v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t v21;
  uint8x8_t v22;
  id **v24;
  id *i;
  unint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  float v29;
  float v30;
  _BOOL8 v31;
  unint64_t v32;
  unint64_t v33;
  size_t v34;
  _QWORD *v35;
  unint64_t v36;
  id v37;
  _QWORD *v38;
  unint64_t v39;
  _QWORD v40[2];
  char v41;

  v39 = a2;
  v10 = (_QWORD *)(a1 + 48);
  v11 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>((_QWORD *)(a1 + 48), &v39);
  if (v11)
  {
    v12 = v11;
    v13 = v11 + 3;
    WeakRetained = objc_loadWeakRetained(v11 + 3);
    if (WeakRetained)
    {
      v15 = WeakRetained;
      v16 = objc_loadWeakRetained(v13);
      if (objc_msgSend(v16, "getMetaParameter"))
      {
        v17 = objc_loadWeakRetained(v13);
        v5 = *(unsigned int *)(objc_msgSend(v17, "getMetaParameter") + 12);

        if ((_DWORD)v5 == a3)
          goto LABEL_52;
      }
      else
      {

      }
    }
  }
  objc_msgSend(*(id *)(a1 + 40), "getGlobalMetaParameter:", v39);
  v18 = (PHASEGlobalMetaParameterAsset *)objc_claimAutoreleasedReturnValue();
  if (!v18)
    goto LABEL_15;
  v19 = std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>(v10, &v39);
  if (v19)
  {
    std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>>>::remove(v10, v19, (uint64_t)v40);
    std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,void *>>>>::reset[abi:ne180100]((uint64_t)v40, 0);
  }
  if ((Phase::GlobalMetaParameterManager::RegisterGlobalMetaParam((Phase::GlobalMetaParameterManager *)a1, v18) & 1) == 0
    || (v12 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>(v10, &v39)) == 0)
  {
LABEL_15:

    return 0;
  }
  v20 = v39;
  v21 = *(_QWORD *)(a1 + 56);
  if (v21)
  {
    v22 = (uint8x8_t)vcnt_s8((int8x8_t)v21);
    v22.i16[0] = vaddlv_u8(v22);
    if (v22.u32[0] > 1uLL)
    {
      v5 = v39;
      if (v21 <= v39)
        v5 = v39 % v21;
    }
    else
    {
      v5 = (v21 - 1) & v39;
    }
    v24 = *(id ***)(*v10 + 8 * v5);
    if (v24)
    {
      for (i = *v24; i; i = (id *)*i)
      {
        v26 = (unint64_t)i[1];
        if (v26 == v39)
        {
          if (i[2] == (id)v39)
            goto LABEL_51;
        }
        else
        {
          if (v22.u32[0] > 1uLL)
          {
            if (v26 >= v21)
              v26 %= v21;
          }
          else
          {
            v26 &= v21 - 1;
          }
          if (v26 != v5)
            break;
        }
      }
    }
  }
  v27 = operator new(0x20uLL);
  v28 = (_QWORD *)(a1 + 64);
  v40[0] = v27;
  v40[1] = a1 + 64;
  *v27 = 0;
  v27[1] = v20;
  v27[2] = v20;
  v27[3] = 0;
  v41 = 1;
  v29 = (float)(unint64_t)(*(_QWORD *)(a1 + 72) + 1);
  v30 = *(float *)(a1 + 80);
  if (!v21 || (float)(v30 * (float)v21) < v29)
  {
    v31 = 1;
    if (v21 >= 3)
      v31 = (v21 & (v21 - 1)) != 0;
    v32 = v31 | (2 * v21);
    v33 = vcvtps_u32_f32(v29 / v30);
    if (v32 <= v33)
      v34 = v33;
    else
      v34 = v32;
    std::__hash_table<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>>>::__rehash<true>((uint64_t)v10, v34);
    v21 = *(_QWORD *)(a1 + 56);
    if ((v21 & (v21 - 1)) != 0)
    {
      if (v21 <= v20)
        v5 = v20 % v21;
      else
        v5 = v20;
    }
    else
    {
      v5 = (v21 - 1) & v20;
    }
  }
  v35 = *(_QWORD **)(*v10 + 8 * v5);
  if (v35)
  {
    *(_QWORD *)v40[0] = *v35;
    *v35 = v40[0];
  }
  else
  {
    *(_QWORD *)v40[0] = *v28;
    *v28 = v40[0];
    *(_QWORD *)(*v10 + 8 * v5) = v28;
    if (*(_QWORD *)v40[0])
    {
      v36 = *(_QWORD *)(*(_QWORD *)v40[0] + 8);
      if ((v21 & (v21 - 1)) != 0)
      {
        if (v36 >= v21)
          v36 %= v21;
      }
      else
      {
        v36 &= v21 - 1;
      }
      *(_QWORD *)(*v10 + 8 * v36) = v40[0];
    }
  }
  i = (id *)v40[0];
  v40[0] = 0;
  ++*(_QWORD *)(a1 + 72);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,void *>>>>::reset[abi:ne180100]((uint64_t)v40, 0);
LABEL_51:
  objc_storeWeak(i + 3, v18);

LABEL_52:
  v37 = objc_loadWeakRetained(v12 + 3);
  v38 = (_QWORD *)objc_msgSend(v37, "getMetaParamState");

  return Phase::SetMetaParameterValue(v38, a3, a4, a5);
}

void sub_21660E76C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);

  _Unwind_Resume(a1);
}

uint64_t Phase::GlobalMetaParameterManager::RegisterGlobalMetaParam(Phase::GlobalMetaParameterManager *this, PHASEGlobalMetaParameterAsset *a2)
{
  PHASEGlobalMetaParameterAsset *v3;
  PHASEGlobalMetaParameterAsset *v4;
  uint64_t *v5;
  uint64_t v6;
  _QWORD *v7;
  char v8;
  char v9;
  uint64_t v10;
  id location;
  unint64_t v13;
  id v14;

  v3 = a2;
  v4 = v3;
  if (!v3)
    goto LABEL_4;
  v5 = -[PHASEGlobalMetaParameterAsset getMetaParamState](v3, "getMetaParamState");
  v6 = -[PHASEGlobalMetaParameterAsset getMetaParameter](v4, "getMetaParameter");
  *v5 = v6;
  v5[7] = *(_QWORD *)(v6 + 48);
  Phase::Fader<double>::SetDefaultValue((uint64_t)(v5 + 1), *(double *)(v6 + 48));
  v7 = (_QWORD *)((char *)this + 48);
  if (std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>(v7, (unint64_t *)v6))
  {
    goto LABEL_4;
  }
  objc_initWeak(&location, v4);
  v13 = *(_QWORD *)v6;
  objc_copyWeak(&v14, &location);
  std::__hash_table<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>>((uint64_t)v7, &v13, (uint64_t)&v13);
  v9 = v8;
  objc_destroyWeak(&v14);
  objc_destroyWeak(&location);
  if ((v9 & 1) != 0)
    v10 = 1;
  else
LABEL_4:
    v10 = 0;

  return v10;
}

void sub_21660E890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
  void *v10;
  id *v11;

  objc_destroyWeak(v11);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

uint64_t Phase::GlobalMetaParameterManager::GetGlobalMetaParameterState(Phase::GlobalMetaParameterManager *this, unint64_t a2, MetaParamState *a3)
{
  _QWORD *v5;
  id *v6;
  PHASEGlobalMetaParameterAsset *WeakRetained;
  PHASEGlobalMetaParameterAsset *v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  unint64_t v13;

  v13 = a2;
  v5 = (_QWORD *)((char *)this + 48);
  v6 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>((_QWORD *)this + 6, &v13);
  if (v6)
    goto LABEL_2;
  objc_msgSend(*((id *)this + 5), "getGlobalMetaParameter:", v13);
  v8 = (PHASEGlobalMetaParameterAsset *)objc_claimAutoreleasedReturnValue();
  if (!v8 || (Phase::GlobalMetaParameterManager::RegisterGlobalMetaParam(this, v8) & 1) == 0)
    goto LABEL_10;
  v6 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>(v5, &v13);

  if (v6)
  {
LABEL_2:
    WeakRetained = (PHASEGlobalMetaParameterAsset *)objc_loadWeakRetained(v6 + 3);
    v8 = WeakRetained;
    if (WeakRetained)
    {
      v9 = -[PHASEGlobalMetaParameterAsset getMetaParamState](WeakRetained, "getMetaParamState");
      a3->param = *(MetaParameter **)v9;
      if ((MetaParamState *)v9 != a3)
        std::vector<Phase::Envelope<double>::SegmentInternal,std::allocator<Phase::Envelope<double>::SegmentInternal>>::__assign_with_size[abi:ne180100]<Phase::Envelope<double>::SegmentInternal*,Phase::Envelope<double>::SegmentInternal*>((uint64_t)&a3->mFader, *(_QWORD **)(v9 + 8), *(_QWORD **)(v9 + 16), (uint64_t)(*(_QWORD *)(v9 + 16) - *(_QWORD *)(v9 + 8)) >> 6);
      v10 = *(_OWORD *)(v9 + 32);
      a3->mFader.mValue = *(double *)(v9 + 48);
      *(_OWORD *)&a3->mFader.mOffset = v10;
      a3->currentInputValue.stringVal = *(_QWORD *)(v9 + 56);
      v11 = 1;
      goto LABEL_11;
    }
LABEL_10:
    v11 = 0;
LABEL_11:

    return v11;
  }
  return 0;
}

void sub_21660E9C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void Phase::GlobalMetaParameterManager::Update(Phase::GlobalMetaParameterManager *this, double a2)
{
  id *v4;
  _QWORD *v5;
  id WeakRetained;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  id *v10;
  _BYTE v11[24];

  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::ExecuteCommands((uint64_t)this);
  if (a2 > 0.0)
  {
    v4 = (id *)*((_QWORD *)this + 8);
    if (v4)
    {
      v5 = (_QWORD *)((char *)this + 48);
      do
      {
        WeakRetained = objc_loadWeakRetained(v4 + 3);
        v7 = WeakRetained;
        if (WeakRetained)
        {
          v8 = objc_msgSend(WeakRetained, "getMetaParamState");
          v9 = v8;
          if (*(_DWORD *)(*(_QWORD *)v8 + 12) == 1)
          {
            Phase::Fader<double>::Update(v8 + 8, a2);
            *(_QWORD *)(v9 + 56) = *(_QWORD *)(v9 + 48);
          }
          v4 = (id *)*v4;
        }
        else
        {
          v10 = (id *)*v4;
          std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>>>::remove(v5, v4, (uint64_t)v11);
          std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,void *>>>>::reset[abi:ne180100]((uint64_t)v11, 0);
          v4 = v10;
        }

      }
      while (v4);
    }
  }
}

void sub_21660EAA4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  id *v2;

  v2 = *(id **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      objc_destroyWeak(v2 + 3);
    operator delete(v2);
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  void *v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  _QWORD *v20;
  unint64_t v21;
  _QWORD v23[2];
  char v24;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v6 >= v7)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = (_QWORD *)*v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (v10[2] == v6)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v12 = a1 + 16;
  v13 = operator new(0x20uLL);
  v23[0] = v13;
  v23[1] = a1 + 16;
  *(_QWORD *)v13 = 0;
  *((_QWORD *)v13 + 1) = v6;
  *((_QWORD *)v13 + 2) = *(_QWORD *)a3;
  objc_moveWeak((id *)v13 + 3, (id *)(a3 + 8));
  v24 = 1;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    v16 = 1;
    if (v7 >= 3)
      v16 = (v7 & (v7 - 1)) != 0;
    v17 = v16 | (2 * v7);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>>>::__rehash<true>(a1, v19);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v20)
  {
    *(_QWORD *)v23[0] = *v20;
    *v20 = v23[0];
  }
  else
  {
    *(_QWORD *)v23[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v23[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = v12;
    if (*(_QWORD *)v23[0])
    {
      v21 = *(_QWORD *)(*(_QWORD *)v23[0] + 8);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v21 >= v7)
          v21 %= v7;
      }
      else
      {
        v21 &= v7 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v21) = v23[0];
    }
  }
  v10 = (_QWORD *)v23[0];
  v23[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,void *>>>>::reset[abi:ne180100]((uint64_t)v23, 0);
  return v10;
}

void sub_21660ED40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,PHASEGlobalMetaParameterAsset * {__weak}>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::MorphDirectionalMetadata(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, float a4@<S0>, float a5@<S1>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  int64x2_t v33;
  uint64_t v34;
  int64x2_t v35;
  uint64_t v36;
  int64x2_t v37;
  uint64_t v38;
  int64x2_t v39;
  uint64_t v40;
  int64x2_t v41;
  uint64_t v42;
  int64x2_t v43;
  uint64_t v44;
  int64x2_t v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  int64x2_t v50;
  uint64_t v51;
  float *v52;
  float *v53;
  uint64_t v54;
  int64x2_t *v55;
  float *v56;
  uint64_t v57;

  *(_DWORD *)a3 = 3;
  *(_BYTE *)(a3 + 4) = 1;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 204) = 0;
  *(_QWORD *)(a3 + 48) = 0;
  *(_QWORD *)(a3 + 56) = 0;
  *(_QWORD *)(a3 + 40) = 0;
  *(_QWORD *)(a3 + 96) = 0;
  *(_QWORD *)(a3 + 104) = 0;
  *(_QWORD *)(a3 + 88) = 0;
  *(_QWORD *)(a3 + 136) = 0;
  *(_QWORD *)(a3 + 144) = 0;
  *(_QWORD *)(a3 + 184) = 0;
  *(_QWORD *)(a3 + 192) = 0;
  *(_QWORD *)(a3 + 176) = 0;
  *(_WORD *)(a3 + 200) = 0;
  if (*(_QWORD *)(a1 + 104))
  {
    if (!*(_BYTE *)(a1 + 201))
      Phase::SpatialModeler::SortMetadataByDelay<float>(a1);
    if (!*(_BYTE *)(a2 + 201))
      Phase::SpatialModeler::SortMetadataByDelay<float>(a2);
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 8);
    switch(v10)
    {
      case 31:
        v50 = 0uLL;
        v51 = 0;
        v47 = 0;
        v48 = 0;
        v49 = 0;
        Phase::SpatialModeler::convertDirectionalMetadataToRayTracingPlaneWaveList<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(a1, (char **)&v50);
        Phase::SpatialModeler::convertDirectionalMetadataToRayTracingPlaneWaveList<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(a2, &v47);
        v36 = 0;
        v35 = 0uLL;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::__init_with_size[abi:ne180100]<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave*,Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave*>(&v35, v50.i64[0], v50.i64[1], 0x8E38E38E38E38E39 * ((v50.i64[1] - v50.i64[0]) >> 4));
        v33 = 0uLL;
        v34 = 0;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::__init_with_size[abi:ne180100]<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave*,Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave*>(&v33, (uint64_t)v47, v48, 0x8E38E38E38E38E39 * ((v48 - (uint64_t)v47) >> 4));
        if (a4 == 0.0 && a5 == 1.0)
        {
          v45 = v33;
          v46 = v34;
          v34 = 0;
          v33 = 0uLL;
        }
        else if (a4 == 1.0 && a5 == 0.0)
        {
          v45 = v35;
          v46 = v36;
          v36 = 0;
          v35 = 0uLL;
        }
        else
        {
          v45 = 0uLL;
          v46 = 0;
          v55 = 0;
          v56 = 0;
          v57 = 0;
          v52 = 0;
          v53 = 0;
          v54 = 0;
          Phase::SpatialModeler::PrecalculateDbLevels<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(v35.i64[0], v35.i64[1], (float **)&v55);
          Phase::SpatialModeler::PrecalculateDbLevels<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(v33.i64[0], v33.i64[1], &v52);
          if (v35.i64[1] == v35.i64[0] || v33.i64[1] == v33.i64[0])
          {
            Phase::SpatialModeler::TerminateAndWeightRemainder_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(v35.i64[0], v35.i64[1], v33.i64[0], v33.i64[1], &v45, a4, a5);
          }
          else
          {
            do
            {
              if (v33.i64[1] == v33.i64[0])
                break;
              Phase::SpatialModeler::FindPairAndMerge<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(&v35, &v55, v33.i64, &v52, &v45, a4, a5);
              Phase::SpatialModeler::TerminateAndWeightRemainder_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(v35.i64[0], v35.i64[1], v33.i64[0], v33.i64[1], &v45, a4, a5);
              v13 = v35.i64[1];
              v14 = v35.i64[0];
              if (v35.i64[1] == v35.i64[0])
                break;
              if (v33.i64[1] != v33.i64[0])
              {
                Phase::SpatialModeler::FindPairAndMerge<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(&v33, &v52, v35.i64, &v55, &v45, a5, a4);
                Phase::SpatialModeler::TerminateAndWeightRemainder_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(v35.i64[0], v35.i64[1], v33.i64[0], v33.i64[1], &v45, a4, a5);
                v13 = v35.i64[1];
                v14 = v35.i64[0];
              }
            }
            while (v13 != v14);
          }
          if (v52)
          {
            v53 = v52;
            operator delete(v52);
          }
          if (v55)
          {
            v56 = (float *)v55;
            operator delete(v55);
          }
        }
        v23 = v50.i64[0];
        if (v50.i64[0])
        {
          v24 = (void *)v50.i64[0];
          if (v50.i64[1] != v50.i64[0])
          {
            v25 = v50.i64[1] - 144;
            v26 = (uint64_t *)(v50.i64[1] - 144);
            do
            {
              v27 = *v26;
              v26 -= 18;
              (*(void (**)(uint64_t))(v27 + 16))(v25);
              v22 = v25 == v23;
              v25 = (uint64_t)v26;
            }
            while (!v22);
            v24 = (void *)v50.i64[0];
          }
          v50.i64[1] = v23;
          operator delete(v24);
        }
        v50 = v45;
        v51 = v46;
        v46 = 0;
        v45 = 0uLL;
        v55 = &v45;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
        v55 = &v33;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
        v55 = &v35;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
        Phase::SpatialModeler::convertRayTracingPlaneWaveListToDirectionalMetadata<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>((uint64_t)&v50, (uint64_t *)a3, 0);
        Phase::SpatialModeler::SortMetadataByDelay<float>(a3);
        v55 = (int64x2_t *)&v47;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
        v55 = &v50;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
        break;
      case 10:
        v50 = 0uLL;
        v51 = 0;
        v47 = 0;
        v48 = 0;
        v49 = 0;
        Phase::SpatialModeler::convertDirectionalMetadataToRayTracingPlaneWaveList<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(a1, (char **)&v50);
        Phase::SpatialModeler::convertDirectionalMetadataToRayTracingPlaneWaveList<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(a2, &v47);
        v40 = 0;
        v39 = 0uLL;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::__init_with_size[abi:ne180100]<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave*,Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave*>(&v39, v50.i64[0], v50.i64[1], (v50.i64[1] - v50.i64[0]) >> 6);
        v37 = 0uLL;
        v38 = 0;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::__init_with_size[abi:ne180100]<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave*,Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave*>(&v37, (uint64_t)v47, v48, (v48 - (uint64_t)v47) >> 6);
        if (a4 == 0.0 && a5 == 1.0)
        {
          v45 = v37;
          v46 = v38;
          v38 = 0;
          v37 = 0uLL;
        }
        else if (a4 == 1.0 && a5 == 0.0)
        {
          v45 = v39;
          v46 = v40;
          v40 = 0;
          v39 = 0uLL;
        }
        else
        {
          v45 = 0uLL;
          v46 = 0;
          v55 = 0;
          v56 = 0;
          v57 = 0;
          v52 = 0;
          v53 = 0;
          v54 = 0;
          Phase::SpatialModeler::PrecalculateDbLevels<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(v39.i64[0], v39.i64[1], (float **)&v55);
          Phase::SpatialModeler::PrecalculateDbLevels<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(v37.i64[0], v37.i64[1], &v52);
          if (v39.i64[1] == v39.i64[0] || v37.i64[1] == v37.i64[0])
          {
            Phase::SpatialModeler::TerminateAndWeightRemainder_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(v39.i64[0], v39.i64[1], v37.i64[0], v37.i64[1], &v45, a4, a5);
          }
          else
          {
            do
            {
              if (v37.i64[1] == v37.i64[0])
                break;
              Phase::SpatialModeler::FindPairAndMerge<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(&v39, &v55, v37.i64, &v52, &v45, a4, a5);
              Phase::SpatialModeler::TerminateAndWeightRemainder_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(v39.i64[0], v39.i64[1], v37.i64[0], v37.i64[1], &v45, a4, a5);
              v15 = v39.i64[1];
              v16 = v39.i64[0];
              if (v39.i64[1] == v39.i64[0])
                break;
              if (v37.i64[1] != v37.i64[0])
              {
                Phase::SpatialModeler::FindPairAndMerge<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(&v37, &v52, v39.i64, &v55, &v45, a5, a4);
                Phase::SpatialModeler::TerminateAndWeightRemainder_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(v39.i64[0], v39.i64[1], v37.i64[0], v37.i64[1], &v45, a4, a5);
                v15 = v39.i64[1];
                v16 = v39.i64[0];
              }
            }
            while (v15 != v16);
          }
          if (v52)
          {
            v53 = v52;
            operator delete(v52);
          }
          if (v55)
          {
            v56 = (float *)v55;
            operator delete(v55);
          }
        }
        v28 = v50.i64[0];
        if (v50.i64[0])
        {
          v29 = (void *)v50.i64[0];
          if (v50.i64[1] != v50.i64[0])
          {
            v30 = v50.i64[1] - 64;
            v31 = (uint64_t *)(v50.i64[1] - 64);
            do
            {
              v32 = *v31;
              v31 -= 8;
              (*(void (**)(uint64_t))(v32 + 16))(v30);
              v22 = v30 == v28;
              v30 = (uint64_t)v31;
            }
            while (!v22);
            v29 = (void *)v50.i64[0];
          }
          v50.i64[1] = v28;
          operator delete(v29);
        }
        v50 = v45;
        v51 = v46;
        v46 = 0;
        v45 = 0uLL;
        v55 = &v45;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
        v55 = &v37;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
        v55 = &v39;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
        Phase::SpatialModeler::convertRayTracingPlaneWaveListToDirectionalMetadata<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>((uint64_t)&v50, (uint64_t *)a3, 0);
        Phase::SpatialModeler::SortMetadataByDelay<float>(a3);
        v55 = (int64x2_t *)&v47;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
        v55 = &v50;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
        break;
      case 3:
        v50 = 0uLL;
        v51 = 0;
        v47 = 0;
        v48 = 0;
        v49 = 0;
        Phase::SpatialModeler::convertDirectionalMetadataToRayTracingPlaneWaveList<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(a1, (char **)&v50);
        Phase::SpatialModeler::convertDirectionalMetadataToRayTracingPlaneWaveList<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(a2, &v47);
        v44 = 0;
        v43 = 0uLL;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__init_with_size[abi:ne180100]<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band*,Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band*>(&v43, v50.i64[0], v50.i64[1], (v50.i64[1] - v50.i64[0]) >> 5);
        v41 = 0uLL;
        v42 = 0;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__init_with_size[abi:ne180100]<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band*,Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band*>(&v41, (uint64_t)v47, v48, (v48 - (uint64_t)v47) >> 5);
        if (a4 == 0.0 && a5 == 1.0)
        {
          v45 = v41;
          v46 = v42;
          v42 = 0;
          v41 = 0uLL;
        }
        else if (a4 == 1.0 && a5 == 0.0)
        {
          v45 = v43;
          v46 = v44;
          v44 = 0;
          v43 = 0uLL;
        }
        else
        {
          v45 = 0uLL;
          v46 = 0;
          v55 = 0;
          v56 = 0;
          v57 = 0;
          v52 = 0;
          v53 = 0;
          v54 = 0;
          Phase::SpatialModeler::PrecalculateDbLevels<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(v43.i64[0], v43.i64[1], (float **)&v55);
          Phase::SpatialModeler::PrecalculateDbLevels<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(v41.i64[0], v41.i64[1], &v52);
          if (v43.i64[1] == v43.i64[0] || v41.i64[1] == v41.i64[0])
          {
            Phase::SpatialModeler::TerminateAndWeightRemainder_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(v43.i64[0], v43.i64[1], v41.i64[0], v41.i64[1], &v45, a4, a5);
          }
          else
          {
            do
            {
              if (v41.i64[1] == v41.i64[0])
                break;
              Phase::SpatialModeler::FindPairAndMerge<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(&v43, &v55, v41.i64, &v52, &v45, a4, a5);
              Phase::SpatialModeler::TerminateAndWeightRemainder_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(v43.i64[0], v43.i64[1], v41.i64[0], v41.i64[1], &v45, a4, a5);
              v11 = v43.i64[1];
              v12 = v43.i64[0];
              if (v43.i64[1] == v43.i64[0])
                break;
              if (v41.i64[1] != v41.i64[0])
              {
                Phase::SpatialModeler::FindPairAndMerge<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(&v41, &v52, v43.i64, &v55, &v45, a5, a4);
                Phase::SpatialModeler::TerminateAndWeightRemainder_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(v43.i64[0], v43.i64[1], v41.i64[0], v41.i64[1], &v45, a4, a5);
                v11 = v43.i64[1];
                v12 = v43.i64[0];
              }
            }
            while (v11 != v12);
          }
          if (v52)
          {
            v53 = v52;
            operator delete(v52);
          }
          if (v55)
          {
            v56 = (float *)v55;
            operator delete(v55);
          }
        }
        v17 = v50.i64[0];
        if (v50.i64[0])
        {
          v18 = (void *)v50.i64[0];
          if (v50.i64[1] != v50.i64[0])
          {
            v19 = v50.i64[1] - 32;
            v20 = (uint64_t *)(v50.i64[1] - 32);
            do
            {
              v21 = *v20;
              v20 -= 4;
              (*(void (**)(uint64_t))(v21 + 16))(v19);
              v22 = v19 == v17;
              v19 = (uint64_t)v20;
            }
            while (!v22);
            v18 = (void *)v50.i64[0];
          }
          v50.i64[1] = v17;
          operator delete(v18);
        }
        v50 = v45;
        v51 = v46;
        v46 = 0;
        v45 = 0uLL;
        v55 = &v45;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
        v55 = &v41;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
        v55 = &v43;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
        Phase::SpatialModeler::convertRayTracingPlaneWaveListToDirectionalMetadata<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>((uint64_t)&v50, (uint64_t *)a3, 0);
        Phase::SpatialModeler::SortMetadataByDelay<float>(a3);
        v55 = (int64x2_t *)&v47;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
        v55 = &v50;
        std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
        break;
    }
  }
}

void sub_21660F630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  uint64_t *v33;
  uint64_t v34;
  void *v36;
  void *v37;

  v36 = *(void **)(v34 - 112);
  if (v36)
  {
    *(_QWORD *)(v34 - 104) = v36;
    operator delete(v36);
  }
  v37 = *(void **)(v34 - 88);
  if (v37)
  {
    *(_QWORD *)(v34 - 80) = v37;
    operator delete(v37);
  }
  *(_QWORD *)(v34 - 88) = &a33;
  std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__destroy_vector::operator()[abi:ne180100]((void ***)(v34 - 88));
  *(_QWORD *)(v34 - 88) = &a25;
  std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__destroy_vector::operator()[abi:ne180100]((void ***)(v34 - 88));
  *(_QWORD *)(v34 - 88) = &a29;
  std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__destroy_vector::operator()[abi:ne180100]((void ***)(v34 - 88));
  *(_QWORD *)(v34 - 88) = v34 - 168;
  std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__destroy_vector::operator()[abi:ne180100]((void ***)(v34 - 88));
  *(_QWORD *)(v34 - 88) = v34 - 144;
  std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__destroy_vector::operator()[abi:ne180100]((void ***)(v34 - 88));
  Phase::SpatialModeler::DirectionalMetadataOutput<float>::~DirectionalMetadataOutput(v33);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::convertDirectionalMetadataToRayTracingPlaneWaveList<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(uint64_t a1, char **a2)
{
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  char *v14;
  unint64_t v15;
  uint64_t v16;
  char *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  unint64_t v29;
  __int128 v30;
  int64x2_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  float *v45;
  float *v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  float v50;
  float v51;
  float *v52;
  float *v53;
  unint64_t v54;
  float v55;
  unint64_t v56;
  uint64_t v57;
  int64x2_t v58;
  char *v59;
  _QWORD *v60;

  if (*(_DWORD *)(a1 + 204))
    std::terminate();
  v4 = *(unint64_t **)(a1 + 104);
  if (!v4 || ((v5 = *v4, v6 = v4[1], *v4) ? (v7 = v6 == 0) : (v7 = 1), v7))
  {
    v9 = *a2;
    v8 = a2[1];
    if (v8 != *a2)
    {
      v10 = v8 - 32;
      v11 = v8 - 32;
      do
      {
        v12 = *(_QWORD *)v11;
        v11 -= 32;
        (*(void (**)(char *))(v12 + 16))(v10);
        v7 = v10 == v9;
        v10 = v11;
      }
      while (!v7);
    }
    a2[1] = v9;
  }
  else
  {
    v14 = *a2;
    v13 = a2[1];
    v15 = (v13 - *a2) >> 5;
    v56 = v5;
    if (v5 <= v15)
    {
      if (v5 < v15)
      {
        v32 = v6;
        v33 = &v14[32 * v5];
        if (v13 != v33)
        {
          v34 = v13 - 32;
          v35 = v13 - 32;
          do
          {
            v36 = *(_QWORD *)v35;
            v35 -= 32;
            (*(void (**)(char *))(v36 + 16))(v34);
            v7 = v34 == v33;
            v34 = v35;
          }
          while (!v7);
        }
        a2[1] = v33;
        v5 = v56;
        v6 = v32;
      }
    }
    else
    {
      v16 = (uint64_t)(a2 + 2);
      v17 = a2[2];
      if (v5 - v15 <= (v17 - v13) >> 5)
      {
        v37 = &v13[32 * (v5 - v15)];
        do
        {
          *(_QWORD *)v13 = off_24D57CBF8;
          *((_QWORD *)v13 + 1) = 0;
          *((_QWORD *)v13 + 2) = 0;
          *((_QWORD *)v13 + 3) = 0;
          v13 += 32;
        }
        while (v13 != v37);
        a2[1] = v37;
      }
      else
      {
        if (v5 >> 59)
          std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
        v18 = v6;
        v19 = v17 - v14;
        v20 = (v17 - v14) >> 4;
        if (v20 <= v5)
          v20 = v5;
        v21 = v5;
        if (v19 >= 0x7FFFFFFFFFFFFFE0)
          v22 = 0x7FFFFFFFFFFFFFFLL;
        else
          v22 = v20;
        v60 = a2 + 2;
        v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::GraphDescriptionNode>>(v16, v22);
        v25 = &v23[32 * v15];
        v26 = &v23[32 * v21];
        v27 = v25;
        do
        {
          *(_QWORD *)v27 = off_24D57CBF8;
          *((_QWORD *)v27 + 1) = 0;
          *((_QWORD *)v27 + 2) = 0;
          *((_QWORD *)v27 + 3) = 0;
          v27 += 32;
        }
        while (v27 != v26);
        v28 = *a2;
        v29 = (unint64_t)a2[1];
        if ((char *)v29 == *a2)
        {
          v31 = vdupq_n_s64(v29);
        }
        else
        {
          do
          {
            *((_QWORD *)v25 - 4) = off_24D57CBF8;
            v25 -= 32;
            v30 = *(_OWORD *)(v29 - 24);
            *((_QWORD *)v25 + 3) = *(_QWORD *)(v29 - 8);
            *(_OWORD *)(v25 + 8) = v30;
            v29 -= 32;
          }
          while ((char *)v29 != v28);
          v31 = *(int64x2_t *)a2;
        }
        *a2 = v25;
        a2[1] = v26;
        v58 = v31;
        v38 = a2[2];
        a2[2] = &v23[32 * v24];
        v59 = v38;
        v57 = v31.i64[0];
        std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::~__split_buffer((uint64_t)&v57);
        v5 = v56;
        v6 = v18;
      }
    }
    v39 = 0;
    v40 = *(_QWORD *)(a1 + 8);
    v41 = *a2;
    v42 = *(_QWORD *)(a1 + 56);
    v43 = *(_QWORD *)(a1 + 144);
    v44 = *(_QWORD *)(a1 + 104);
    v45 = (float *)(v44 + 16);
    v46 = (float *)(v41 + 20);
    v47 = 4 * *(_QWORD *)(v44 + 8);
    do
    {
      v48 = v40 + 12 * v39;
      v49 = &v41[32 * v39];
      *((float *)v49 + 2) = 90.0 - *(float *)(v48 + 4);
      v50 = (float)((float)(180.0 - *(float *)(v48 + 8))
                  - (float)(floorf((float)(180.0 - *(float *)(v48 + 8)) / 360.0) * 360.0))
          + 0.0;
      if (v50 >= 360.0)
      {
        v50 = nextafterf(360.0, 0.0);
        v5 = v56;
      }
      *((float *)v49 + 3) = v50;
      *((_DWORD *)v49 + 4) = *(_DWORD *)(v42 + 4 * v39);
      v51 = (float)(1 - 2 * *(unsigned __int8 *)(v43 + v39));
      v52 = v45;
      v53 = v46;
      v54 = v6;
      do
      {
        v55 = *v52++;
        *v53++ = v55 * v51;
        --v54;
      }
      while (v54);
      ++v39;
      v46 += 8;
      v45 = (float *)((char *)v45 + v47);
    }
    while (v39 != v5);
  }
}

void Phase::SpatialModeler::convertDirectionalMetadataToRayTracingPlaneWaveList<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(uint64_t a1, char **a2)
{
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  char *v14;
  unint64_t v15;
  uint64_t v16;
  char *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  unint64_t v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  int64x2_t v33;
  unint64_t v34;
  char *v35;
  char *v36;
  char *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  float *v47;
  float *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  float v52;
  float v53;
  float *v54;
  float *v55;
  unint64_t v56;
  float v57;
  unint64_t v58;
  uint64_t v59;
  int64x2_t v60;
  char *v61;
  _QWORD *v62;

  if (*(_DWORD *)(a1 + 204))
    std::terminate();
  v4 = *(unint64_t **)(a1 + 104);
  if (!v4 || ((v5 = *v4, v6 = v4[1], *v4) ? (v7 = v6 == 0) : (v7 = 1), v7))
  {
    v9 = *a2;
    v8 = a2[1];
    if (v8 != *a2)
    {
      v10 = v8 - 64;
      v11 = v8 - 64;
      do
      {
        v12 = *(_QWORD *)v11;
        v11 -= 64;
        (*(void (**)(char *))(v12 + 16))(v10);
        v7 = v10 == v9;
        v10 = v11;
      }
      while (!v7);
    }
    a2[1] = v9;
  }
  else
  {
    v14 = *a2;
    v13 = a2[1];
    v15 = (v13 - *a2) >> 6;
    v58 = v5;
    if (v5 <= v15)
    {
      if (v5 < v15)
      {
        v34 = v6;
        v35 = &v14[64 * v5];
        if (v13 != v35)
        {
          v36 = v13 - 64;
          v37 = v13 - 64;
          do
          {
            v38 = *(_QWORD *)v37;
            v37 -= 64;
            (*(void (**)(char *))(v38 + 16))(v36);
            v7 = v36 == v35;
            v36 = v37;
          }
          while (!v7);
        }
        a2[1] = v35;
        v5 = v58;
        v6 = v34;
      }
    }
    else
    {
      v16 = (uint64_t)(a2 + 2);
      v17 = a2[2];
      if (v5 - v15 <= (v17 - v13) >> 6)
      {
        v39 = &v13[64 * (v5 - v15)];
        do
        {
          *(_QWORD *)v13 = off_24D57CC28;
          *(_OWORD *)(v13 + 8) = 0uLL;
          *(_OWORD *)(v13 + 24) = 0uLL;
          *(_OWORD *)(v13 + 40) = 0uLL;
          *((_DWORD *)v13 + 14) = 0;
          v13 += 64;
        }
        while (v13 != v39);
        a2[1] = v39;
      }
      else
      {
        if (v5 >> 58)
          std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
        v18 = v6;
        v19 = v17 - v14;
        v20 = (v17 - v14) >> 5;
        if (v20 <= v5)
          v20 = v5;
        v21 = v5;
        if (v19 >= 0x7FFFFFFFFFFFFFC0)
          v22 = 0x3FFFFFFFFFFFFFFLL;
        else
          v22 = v20;
        v62 = a2 + 2;
        v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Envelope<double>::SegmentInternal>>(v16, v22);
        v25 = &v23[64 * v15];
        v26 = &v23[64 * v21];
        v27 = v25;
        do
        {
          *(_QWORD *)v27 = off_24D57CC28;
          *(_OWORD *)(v27 + 8) = 0uLL;
          *(_OWORD *)(v27 + 24) = 0uLL;
          *(_OWORD *)(v27 + 40) = 0uLL;
          *((_DWORD *)v27 + 14) = 0;
          v27 += 64;
        }
        while (v27 != v26);
        v28 = *a2;
        v29 = (unint64_t)a2[1];
        if ((char *)v29 == *a2)
        {
          v33 = vdupq_n_s64(v29);
        }
        else
        {
          do
          {
            *((_QWORD *)v25 - 8) = off_24D57CC28;
            v25 -= 64;
            v30 = *(_OWORD *)(v29 - 56);
            v31 = *(_OWORD *)(v29 - 40);
            v32 = *(_OWORD *)(v29 - 24);
            *((_DWORD *)v25 + 14) = *(_DWORD *)(v29 - 8);
            *(_OWORD *)(v25 + 40) = v32;
            *(_OWORD *)(v25 + 24) = v31;
            *(_OWORD *)(v25 + 8) = v30;
            v29 -= 64;
          }
          while ((char *)v29 != v28);
          v33 = *(int64x2_t *)a2;
        }
        *a2 = v25;
        a2[1] = v26;
        v60 = v33;
        v40 = a2[2];
        a2[2] = &v23[64 * v24];
        v61 = v40;
        v59 = v33.i64[0];
        std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::~__split_buffer((uint64_t)&v59);
        v5 = v58;
        v6 = v18;
      }
    }
    v41 = 0;
    v42 = *(_QWORD *)(a1 + 8);
    v43 = *a2;
    v44 = *(_QWORD *)(a1 + 56);
    v45 = *(_QWORD *)(a1 + 144);
    v46 = *(_QWORD *)(a1 + 104);
    v47 = (float *)(v46 + 16);
    v48 = (float *)(v43 + 20);
    v49 = 4 * *(_QWORD *)(v46 + 8);
    do
    {
      v50 = v42 + 12 * v41;
      v51 = &v43[64 * v41];
      *((float *)v51 + 2) = 90.0 - *(float *)(v50 + 4);
      v52 = (float)((float)(180.0 - *(float *)(v50 + 8))
                  - (float)(floorf((float)(180.0 - *(float *)(v50 + 8)) / 360.0) * 360.0))
          + 0.0;
      if (v52 >= 360.0)
      {
        v52 = nextafterf(360.0, 0.0);
        v5 = v58;
      }
      *((float *)v51 + 3) = v52;
      *((_DWORD *)v51 + 4) = *(_DWORD *)(v44 + 4 * v41);
      v53 = (float)(1 - 2 * *(unsigned __int8 *)(v45 + v41));
      v54 = v47;
      v55 = v48;
      v56 = v6;
      do
      {
        v57 = *v54++;
        *v55++ = v57 * v53;
        --v56;
      }
      while (v56);
      ++v41;
      v48 += 16;
      v47 = (float *)((char *)v47 + v49);
    }
    while (v41 != v5);
  }
}

void Phase::SpatialModeler::convertDirectionalMetadataToRayTracingPlaneWaveList<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(uint64_t a1, char **a2)
{
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  char *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  char *v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  unint64_t v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  int64x2_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;
  char *v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  float *v51;
  float *v52;
  uint64_t v53;
  uint64_t v54;
  float v55;
  char *v56;
  float v57;
  float *v58;
  float *v59;
  unint64_t v60;
  float v61;
  unint64_t v62;
  uint64_t v63;
  int64x2_t v64;
  char *v65;
  _QWORD *v66;

  if (*(_DWORD *)(a1 + 204))
    std::terminate();
  v4 = *(unint64_t **)(a1 + 104);
  if (!v4 || ((v5 = *v4, v6 = v4[1], *v4) ? (v7 = v6 == 0) : (v7 = 1), v7))
  {
    v9 = *a2;
    v8 = a2[1];
    if (v8 != *a2)
    {
      v10 = v8 - 144;
      v11 = v8 - 144;
      do
      {
        v12 = *(_QWORD *)v11;
        v11 -= 144;
        (*(void (**)(char *))(v12 + 16))(v10);
        v7 = v10 == v9;
        v10 = v11;
      }
      while (!v7);
    }
    a2[1] = v9;
  }
  else
  {
    v14 = *a2;
    v13 = a2[1];
    v15 = 0x8E38E38E38E38E39 * ((v13 - *a2) >> 4);
    v16 = v5 - v15;
    v62 = v5;
    if (v5 <= v15)
    {
      if (v5 < v15)
      {
        v38 = v6;
        v39 = &v14[144 * v5];
        if (v13 != v39)
        {
          v40 = v13 - 144;
          v41 = v13 - 144;
          do
          {
            v42 = *(_QWORD *)v41;
            v41 -= 144;
            (*(void (**)(char *))(v42 + 16))(v40);
            v7 = v40 == v39;
            v40 = v41;
          }
          while (!v7);
        }
        a2[1] = v39;
        v5 = v62;
        v6 = v38;
      }
    }
    else
    {
      v17 = (uint64_t)(a2 + 2);
      v18 = a2[2];
      if (0x8E38E38E38E38E39 * ((v18 - v13) >> 4) >= v16)
      {
        v43 = &v13[144 * v16];
        do
        {
          *(_QWORD *)v13 = off_24D57CC58;
          *(_OWORD *)(v13 + 8) = 0uLL;
          *(_OWORD *)(v13 + 24) = 0uLL;
          *(_OWORD *)(v13 + 40) = 0uLL;
          *(_OWORD *)(v13 + 56) = 0uLL;
          *(_OWORD *)(v13 + 72) = 0uLL;
          *(_OWORD *)(v13 + 88) = 0uLL;
          *(_OWORD *)(v13 + 104) = 0uLL;
          *(_OWORD *)(v13 + 120) = 0uLL;
          *((_QWORD *)v13 + 17) = 0;
          v13 += 144;
        }
        while (v13 != v43);
        a2[1] = v43;
      }
      else
      {
        if (v5 > 0x1C71C71C71C71C7)
          std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
        v19 = v6;
        v20 = 0x8E38E38E38E38E39 * ((v18 - v14) >> 4);
        v21 = 2 * v20;
        if (2 * v20 <= v5)
          v21 = v5;
        v22 = v5;
        if (v20 >= 0xE38E38E38E38E3)
          v23 = 0x1C71C71C71C71C7;
        else
          v23 = v21;
        v66 = a2 + 2;
        v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>>(v17, v23);
        v26 = &v24[144 * v15];
        v27 = &v24[144 * v22];
        v28 = v26;
        do
        {
          *(_QWORD *)v28 = off_24D57CC58;
          *(_OWORD *)(v28 + 8) = 0uLL;
          *(_OWORD *)(v28 + 24) = 0uLL;
          *(_OWORD *)(v28 + 40) = 0uLL;
          *(_OWORD *)(v28 + 56) = 0uLL;
          *(_OWORD *)(v28 + 72) = 0uLL;
          *(_OWORD *)(v28 + 88) = 0uLL;
          *(_OWORD *)(v28 + 104) = 0uLL;
          *(_OWORD *)(v28 + 120) = 0uLL;
          *((_QWORD *)v28 + 17) = 0;
          v28 += 144;
        }
        while (v28 != v27);
        v29 = *a2;
        v30 = (unint64_t)a2[1];
        if ((char *)v30 == *a2)
        {
          v37 = vdupq_n_s64(v30);
        }
        else
        {
          do
          {
            *((_QWORD *)v26 - 18) = off_24D57CC58;
            v26 -= 144;
            *(_OWORD *)(v26 + 8) = *(_OWORD *)(v30 - 136);
            v31 = *(_OWORD *)(v30 - 120);
            v32 = *(_OWORD *)(v30 - 104);
            v33 = *(_OWORD *)(v30 - 88);
            *(_OWORD *)(v26 + 72) = *(_OWORD *)(v30 - 72);
            *(_OWORD *)(v26 + 56) = v33;
            *(_OWORD *)(v26 + 40) = v32;
            *(_OWORD *)(v26 + 24) = v31;
            v34 = *(_OWORD *)(v30 - 56);
            v35 = *(_OWORD *)(v30 - 40);
            v36 = *(_OWORD *)(v30 - 24);
            *((_QWORD *)v26 + 17) = *(_QWORD *)(v30 - 8);
            *(_OWORD *)(v26 + 120) = v36;
            *(_OWORD *)(v26 + 104) = v35;
            *(_OWORD *)(v26 + 88) = v34;
            v30 -= 144;
          }
          while ((char *)v30 != v29);
          v37 = *(int64x2_t *)a2;
        }
        *a2 = v26;
        a2[1] = v27;
        v64 = v37;
        v44 = a2[2];
        a2[2] = &v24[144 * v25];
        v65 = v44;
        v63 = v37.i64[0];
        std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::~__split_buffer((uint64_t)&v63);
        v5 = v62;
        v6 = v19;
      }
    }
    v45 = 0;
    v46 = *(_QWORD *)(a1 + 8);
    v47 = *a2;
    v48 = *(_QWORD *)(a1 + 56);
    v49 = *(_QWORD *)(a1 + 144);
    v50 = *(_QWORD *)(a1 + 104);
    v51 = (float *)(v50 + 16);
    v52 = (float *)(v47 + 20);
    v53 = 4 * *(_QWORD *)(v50 + 8);
    do
    {
      v54 = v46 + 12 * v45;
      *(float *)&v47[144 * v45 + 8] = 90.0 - *(float *)(v54 + 4);
      v55 = (float)((float)(180.0 - *(float *)(v54 + 8))
                  - (float)(floorf((float)(180.0 - *(float *)(v54 + 8)) / 360.0) * 360.0))
          + 0.0;
      if (v55 >= 360.0)
      {
        v55 = nextafterf(360.0, 0.0);
        v5 = v62;
      }
      v56 = &v47[144 * v45];
      *((float *)v56 + 3) = v55;
      *((_DWORD *)v56 + 4) = *(_DWORD *)(v48 + 4 * v45);
      v57 = (float)(1 - 2 * *(unsigned __int8 *)(v49 + v45));
      v58 = v51;
      v59 = v52;
      v60 = v6;
      do
      {
        v61 = *v58++;
        *v59++ = v61 * v57;
        --v60;
      }
      while (v60);
      ++v45;
      v52 += 36;
      v51 = (float *)((char *)v51 + v53);
    }
    while (v45 != v5);
  }
}

void Phase::SpatialModeler::PrecalculateDbLevels<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(uint64_t a1, uint64_t a2, float **a3)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  float v8;
  unint64_t v9;
  float *v10;
  float *v11;
  float *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  float *v18;
  int v19;
  float __C;

  a3[1] = *a3;
  if (a1 != a2)
  {
    v5 = a1;
    v6 = (uint64_t)(a3 + 2);
    do
    {
      __C = 0.0;
      v7 = (**(uint64_t (***)(uint64_t))v5)(v5);
      vDSP_measqv((const float *)(v5 + 20), 1, &__C, v7);
      v8 = log10f(__C + 1.1755e-38) * 10.0;
      v10 = a3[1];
      v9 = (unint64_t)a3[2];
      if ((unint64_t)v10 >= v9)
      {
        v12 = *a3;
        v13 = v10 - *a3;
        v14 = v13 + 1;
        if ((unint64_t)(v13 + 1) >> 62)
          std::vector<float>::__throw_length_error[abi:ne180100]();
        v15 = v9 - (_QWORD)v12;
        if (v15 >> 1 > v14)
          v14 = v15 >> 1;
        if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL)
          v16 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v16 = v14;
        if (v16)
        {
          v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v6, v16);
          v12 = *a3;
          v10 = a3[1];
        }
        else
        {
          v17 = 0;
        }
        v18 = (float *)&v17[4 * v13];
        *v18 = v8;
        v11 = v18 + 1;
        while (v10 != v12)
        {
          v19 = *((_DWORD *)v10-- - 1);
          *((_DWORD *)v18-- - 1) = v19;
        }
        *a3 = v18;
        a3[1] = v11;
        a3[2] = (float *)&v17[4 * v16];
        if (v12)
          operator delete(v12);
      }
      else
      {
        *v10 = v8;
        v11 = v10 + 1;
      }
      a3[1] = v11;
      v5 += 32;
    }
    while (v5 != a2);
  }
}

uint64_t Phase::SpatialModeler::TerminateAndWeightRemainder_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int64x2_t *a5, float a6, float a7)
{
  uint64_t v9;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  __int128 v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  __int128 v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  __int128 v27;
  int64x2_t v28;
  uint64_t v29;
  unint64_t v31;
  unint64_t v32;
  __int128 v33;
  char *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  __int128 v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  __int128 v45;
  int64x2_t v46;
  uint64_t v47;
  uint64_t v48;
  int64x2_t v49;
  uint64_t v50;
  int64x2_t *v51;

  v9 = a3;
  if (a2 == result)
  {
    if (a3 != a4)
    {
      do
      {
        result = Phase::SpatialModeler::WeightSingleReflection_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>((float *)v9, a7);
        v31 = a5->u64[1];
        v32 = a5[1].u64[0];
        if (v31 >= v32)
        {
          v35 = (uint64_t)(v31 - a5->i64[0]) >> 5;
          v36 = v35 + 1;
          if ((unint64_t)(v35 + 1) >> 59)
LABEL_43:
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          v37 = v32 - a5->i64[0];
          if (v37 >> 4 > v36)
            v36 = v37 >> 4;
          if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFE0)
            v38 = 0x7FFFFFFFFFFFFFFLL;
          else
            v38 = v36;
          v51 = a5 + 1;
          if (v38)
            v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::GraphDescriptionNode>>((uint64_t)a5[1].i64, v38);
          else
            v39 = 0;
          v40 = &v39[32 * v35];
          *(_QWORD *)v40 = off_24D57CBF8;
          v41 = *(_OWORD *)(v9 + 8);
          *((_QWORD *)v40 + 3) = *(_QWORD *)(v9 + 24);
          *(_OWORD *)(v40 + 8) = v41;
          v42 = a5->i64[0];
          v43 = a5->u64[1];
          if (v43 == a5->i64[0])
          {
            v46 = vdupq_n_s64(v43);
            v44 = &v39[32 * v35];
          }
          else
          {
            v44 = &v39[32 * v35];
            do
            {
              *((_QWORD *)v44 - 4) = off_24D57CBF8;
              v44 -= 32;
              v45 = *(_OWORD *)(v43 - 24);
              *((_QWORD *)v44 + 3) = *(_QWORD *)(v43 - 8);
              *(_OWORD *)(v44 + 8) = v45;
              v43 -= 32;
            }
            while (v43 != v42);
            v46 = *a5;
          }
          v34 = v40 + 32;
          a5->i64[0] = (uint64_t)v44;
          a5->i64[1] = (uint64_t)(v40 + 32);
          v49 = v46;
          v47 = a5[1].i64[0];
          a5[1].i64[0] = (uint64_t)&v39[32 * v38];
          v50 = v47;
          v48 = v46.i64[0];
          result = std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::~__split_buffer((uint64_t)&v48);
        }
        else
        {
          *(_QWORD *)v31 = off_24D57CBF8;
          v33 = *(_OWORD *)(v9 + 8);
          *(_QWORD *)(v31 + 24) = *(_QWORD *)(v9 + 24);
          *(_OWORD *)(v31 + 8) = v33;
          v34 = (char *)(v31 + 32);
        }
        a5->i64[1] = (uint64_t)v34;
        v9 += 32;
      }
      while (v9 != a4);
    }
  }
  else if (a4 == a3)
  {
    v12 = result;
    do
    {
      result = Phase::SpatialModeler::WeightSingleReflection_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>((float *)v12, a6);
      v13 = a5->u64[1];
      v14 = a5[1].u64[0];
      if (v13 >= v14)
      {
        v17 = (uint64_t)(v13 - a5->i64[0]) >> 5;
        v18 = v17 + 1;
        if ((unint64_t)(v17 + 1) >> 59)
          goto LABEL_43;
        v19 = v14 - a5->i64[0];
        if (v19 >> 4 > v18)
          v18 = v19 >> 4;
        if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFE0)
          v20 = 0x7FFFFFFFFFFFFFFLL;
        else
          v20 = v18;
        v51 = a5 + 1;
        if (v20)
          v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::GraphDescriptionNode>>((uint64_t)a5[1].i64, v20);
        else
          v21 = 0;
        v22 = &v21[32 * v17];
        *(_QWORD *)v22 = off_24D57CBF8;
        v23 = *(_OWORD *)(v12 + 8);
        *((_QWORD *)v22 + 3) = *(_QWORD *)(v12 + 24);
        *(_OWORD *)(v22 + 8) = v23;
        v24 = a5->i64[0];
        v25 = a5->u64[1];
        if (v25 == a5->i64[0])
        {
          v28 = vdupq_n_s64(v25);
          v26 = &v21[32 * v17];
        }
        else
        {
          v26 = &v21[32 * v17];
          do
          {
            *((_QWORD *)v26 - 4) = off_24D57CBF8;
            v26 -= 32;
            v27 = *(_OWORD *)(v25 - 24);
            *((_QWORD *)v26 + 3) = *(_QWORD *)(v25 - 8);
            *(_OWORD *)(v26 + 8) = v27;
            v25 -= 32;
          }
          while (v25 != v24);
          v28 = *a5;
        }
        v16 = v22 + 32;
        a5->i64[0] = (uint64_t)v26;
        a5->i64[1] = (uint64_t)(v22 + 32);
        v49 = v28;
        v29 = a5[1].i64[0];
        a5[1].i64[0] = (uint64_t)&v21[32 * v20];
        v50 = v29;
        v48 = v28.i64[0];
        result = std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::~__split_buffer((uint64_t)&v48);
      }
      else
      {
        *(_QWORD *)v13 = off_24D57CBF8;
        v15 = *(_OWORD *)(v12 + 8);
        *(_QWORD *)(v13 + 24) = *(_QWORD *)(v12 + 24);
        *(_OWORD *)(v13 + 8) = v15;
        v16 = (char *)(v13 + 32);
      }
      a5->i64[1] = (uint64_t)v16;
      v12 += 32;
    }
    while (v12 != a2);
  }
  return result;
}

uint64_t Phase::SpatialModeler::FindPairAndMerge<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(_QWORD *a1, _QWORD *a2, uint64_t *a3, _QWORD *a4, int64x2_t *a5, float a6, float a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  float v16;
  uint64_t v17;
  uint64_t v18;
  float v19;
  float v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  float v26;
  unint64_t v27;
  unint64_t v28;
  float *v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float *v34;
  float v35;
  float v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  BOOL v49;
  float v50;
  float v51;
  float v52;
  float v53;
  __n128 v54;
  float v55;
  int v56;
  uint64_t result;
  unint64_t v58;
  unint64_t v59;
  __int128 v60;
  char *v61;
  _QWORD *v62;
  uint64_t *v63;
  _QWORD *v64;
  _QWORD *v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  char *v70;
  char *v71;
  __int128 v72;
  uint64_t v73;
  unint64_t v74;
  char *v75;
  __int128 v76;
  int64x2_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  _QWORD *v82;
  _QWORD *v83;
  uint64_t v84;
  BOOL v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  _QWORD *v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  float v102;
  __int128 v103;
  uint64_t v104;
  uint64_t __B;
  int64x2_t v106;
  uint64_t v107;
  int64x2_t *v108;

  v10 = *a2;
  v11 = a2[1];
  v12 = v11 - *a2;
  if (v11 == *a2)
  {
    v14 = 0;
  }
  else
  {
    v13 = 0;
    v14 = 0;
    v15 = v12 >> 2;
    if (v15 <= 1)
      v15 = 1;
    v16 = -3.4028e38;
    do
    {
      if (*(float *)(v10 + 4 * v13) > v16)
      {
        v14 = v13;
        v16 = *(float *)(v10 + 4 * v13);
      }
      ++v13;
    }
    while (v15 != v13);
  }
  v17 = *a1;
  v18 = *a1 + 32 * v14;
  v19 = *(float *)(v10 + 4 * v14);
  v20 = *(float *)(v18 + 16);
  v21 = *a3;
  v22 = a3[1];
  v23 = *a4;
  v24 = Phase::SpatialModeler::GetNearestReflectionIndex<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(*a3, v22, v20);
  v25 = *(float *)(v21 + 32 * v24 + 16);
  v26 = v25 + 0.1;
  v27 = Phase::SpatialModeler::GetNearestReflectionIndex<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(v21, v22, v25 + -0.1);
  v28 = Phase::SpatialModeler::GetNearestReflectionIndex<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(v21, v22, v26);
  if (v27 <= v28)
  {
    v29 = (float *)(v21 + 32 * v27 + 16);
    v30 = 3.4028e38;
    do
    {
      v31 = *v29;
      v29 += 8;
      v32 = (float)((float)(*(float *)(v23 + 4 * v27) - v19) * (float)(*(float *)(v23 + 4 * v27) - v19))
          + (float)((float)((float)(v31 - v20) / 0.01) * (float)((float)(v31 - v20) / 0.01));
      if (v32 < v30)
      {
        v24 = v27;
        v30 = v32;
      }
      ++v27;
    }
    while (v27 <= v28);
  }
  HIDWORD(v103) = 0;
  v104 = 0;
  v33 = *(float *)(v18 + 12);
  v34 = (float *)(v21 + 32 * v24);
  v35 = v34[3];
  if (vabds_f32(v33, v35) > 180.0)
  {
    if (v33 >= v35)
      v35 = v35 + 360.0;
    else
      v33 = v33 + 360.0;
  }
  v36 = (float)(v35 * a7) + (float)(v33 * a6);
  if (v36 > 360.0)
    v36 = v36 + -360.0;
  *((float *)&v103 + 1) = v36;
  v37 = v17 + 32 * v14;
  *(float *)&v103 = (float)(v34[2] * a7) + (float)(*(float *)(v37 + 8) * a6);
  *((float *)&v103 + 2) = (float)(v34[4] * a7) + (float)(v20 * a6);
  if ((**(int (***)(uint64_t))v18)(v18) >= 1)
  {
    v38 = 0;
    v39 = v21 + 32 * v24 + 20;
    v40 = v37 + 20;
    v41 = 0.0;
    v42 = 1.0;
    do
    {
      v43 = *(float *)(v40 + 4 * v38);
      v44 = fabsf(v43);
      v45 = *(float *)(v39 + 4 * v38);
      v46 = fabsf(v45);
      if (v45 == 0.0)
        v47 = COERCE_FLOAT(1);
      else
        v47 = v46;
      if (v45 < 0.0)
        v48 = -1.0;
      else
        v48 = 1.0;
      v102 = v48;
      v49 = v43 < 0.0;
      if (v43 == 0.0)
        v50 = COERCE_FLOAT(1);
      else
        v50 = v44;
      if (v49)
        v51 = -1.0;
      else
        v51 = 1.0;
      v52 = (float)((float)((float)(logf(v50) * 8.6859) / 10.0) * 10.0) * a6;
      v53 = (float)((float)((float)(logf(v47) * 8.6859) / 10.0) * 10.0) * a7;
      *((float *)&v103 + v38 + 3) = expf((float)((float)((float)(v52 + v53) * 10.0) / 10.0) * 0.11513);
      if (v52 <= v41)
        v54.n128_f32[0] = v42;
      else
        v54.n128_f32[0] = v51;
      if (v52 <= v41)
        v55 = v41;
      else
        v55 = v52;
      if (v53 <= v55)
        v42 = v54.n128_f32[0];
      else
        v42 = v102;
      if (v53 <= v55)
        v41 = v55;
      else
        v41 = v53;
      ++v38;
    }
    while (v38 < (**(int (***)(uint64_t, __n128))v18)(v18, v54));
    *(float *)&__B = v42;
    if (v42 < 0.0)
    {
      v56 = (**(uint64_t (***)(uint64_t))v18)(v18);
      vDSP_vsmul((const float *)&v103 + 3, 1, (const float *)&__B, (float *)&v103 + 3, 1, v56);
    }
  }
  result = (uint64_t)a5[1].i64;
  v58 = a5[1].u64[0];
  v59 = a5->u64[1];
  if (v59 >= v58)
  {
    v66 = (uint64_t)(v59 - a5->i64[0]) >> 5;
    v67 = v66 + 1;
    v65 = a1;
    if ((unint64_t)(v66 + 1) >> 59)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v68 = v58 - a5->i64[0];
    if (v68 >> 4 > v67)
      v67 = v68 >> 4;
    if ((unint64_t)v68 >= 0x7FFFFFFFFFFFFFE0)
      v69 = 0x7FFFFFFFFFFFFFFLL;
    else
      v69 = v67;
    v108 = a5 + 1;
    if (v69)
      v70 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::GraphDescriptionNode>>(result, v69);
    else
      v70 = 0;
    v71 = &v70[32 * v66];
    *(_QWORD *)v71 = off_24D57CBF8;
    v72 = v103;
    *((_QWORD *)v71 + 3) = v104;
    *(_OWORD *)(v71 + 8) = v72;
    v73 = a5->i64[0];
    v74 = a5->u64[1];
    if (v74 == a5->i64[0])
    {
      v77 = vdupq_n_s64(v74);
      v75 = &v70[32 * v66];
    }
    else
    {
      v75 = &v70[32 * v66];
      do
      {
        *((_QWORD *)v75 - 4) = off_24D57CBF8;
        v75 -= 32;
        v76 = *(_OWORD *)(v74 - 24);
        *((_QWORD *)v75 + 3) = *(_QWORD *)(v74 - 8);
        *(_OWORD *)(v75 + 8) = v76;
        v74 -= 32;
      }
      while (v74 != v73);
      v77 = *a5;
    }
    v61 = v71 + 32;
    a5->i64[0] = (uint64_t)v75;
    a5->i64[1] = (uint64_t)(v71 + 32);
    v106 = v77;
    v78 = a5[1].i64[0];
    a5[1].i64[0] = (uint64_t)&v70[32 * v69];
    v107 = v78;
    __B = v77.i64[0];
    result = std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::~__split_buffer((uint64_t)&__B);
    v63 = a3;
    v62 = a4;
    v64 = a2;
  }
  else
  {
    *(_QWORD *)v59 = off_24D57CBF8;
    v60 = v103;
    *(_QWORD *)(v59 + 24) = v104;
    *(_OWORD *)(v59 + 8) = v60;
    v61 = (char *)(v59 + 32);
    v63 = a3;
    v62 = a4;
    v64 = a2;
    v65 = a1;
  }
  a5->i64[1] = (uint64_t)v61;
  v79 = v65[1];
  v80 = *v65 + 32 * v14;
  v81 = v80 + 32;
  if (v80 + 32 != v79)
  {
    do
    {
      *(_OWORD *)(v81 - 24) = *(_OWORD *)(v81 + 8);
      *(_QWORD *)(v81 - 8) = *(_QWORD *)(v81 + 24);
      v81 += 32;
      v80 += 32;
    }
    while (v81 != v79);
    v81 = v65[1];
  }
  if (v81 != v80)
  {
    v82 = (_QWORD *)(v81 - 32);
    v83 = (_QWORD *)(v81 - 32);
    do
    {
      v84 = *v83;
      v83 -= 4;
      result = (*(uint64_t (**)(_QWORD *))(v84 + 16))(v82);
      v85 = v82 == (_QWORD *)v80;
      v82 = v83;
    }
    while (!v85);
  }
  v65[1] = v80;
  v86 = v64[1];
  v87 = *v64 + 4 * v14;
  v88 = v86 - (v87 + 4);
  if (v86 != v87 + 4)
    result = (uint64_t)memmove((void *)(*v64 + 4 * v14), (const void *)(v87 + 4), v86 - (v87 + 4));
  v64[1] = v87 + v88;
  v89 = v63[1];
  v90 = *v63 + 32 * v24;
  v91 = v90 + 32;
  if (v90 + 32 != v89)
  {
    do
    {
      *(_OWORD *)(v91 - 24) = *(_OWORD *)(v91 + 8);
      *(_QWORD *)(v91 - 8) = *(_QWORD *)(v91 + 24);
      v91 += 32;
      v90 += 32;
    }
    while (v91 != v89);
    v91 = v63[1];
  }
  if (v91 != v90)
  {
    v92 = (_QWORD *)(v91 - 32);
    v93 = (_QWORD *)(v91 - 32);
    do
    {
      v94 = *v93;
      v93 -= 4;
      result = (*(uint64_t (**)(_QWORD *))(v94 + 16))(v92);
      v85 = v92 == (_QWORD *)v90;
      v92 = v93;
    }
    while (!v85);
  }
  v63[1] = v90;
  v95 = v62[1];
  v96 = *v62 + 4 * v24;
  v97 = v95 - (v96 + 4);
  if (v95 != v96 + 4)
    result = (uint64_t)memmove((void *)v96, (const void *)(v96 + 4), v95 - (v96 + 4));
  v62[1] = v96 + v97;
  return result;
}

uint64_t Phase::SpatialModeler::WeightSingleReflection_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(float *a1, float a2)
{
  float v3;
  uint64_t result;
  uint64_t v5;

  v3 = expf((float)((float)((float)((float)(a2 * 60.0) + -60.0) * 10.0) / 10.0) * 0.11513);
  result = (**(uint64_t (***)(float *))a1)(a1);
  if ((int)result >= 1)
  {
    v5 = 0;
    do
    {
      a1[v5 + 5] = v3 * a1[v5 + 5];
      ++v5;
      result = (**(uint64_t (***)(float *))a1)(a1);
    }
    while (v5 < (int)result);
  }
  return result;
}

uint64_t Phase::SpatialModeler::GetNearestReflectionIndex<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(uint64_t a1, uint64_t a2, float a3)
{
  unint64_t v3;
  int v4;
  int v5;
  int v6;
  float v7;
  float v8;
  float v9;
  float v10;
  BOOL v11;
  float v12;
  int v13;
  float v14;
  float v15;
  uint64_t v16;
  float v17;
  float v18;
  float v19;
  float v20;
  BOOL v21;
  BOOL v22;
  float v23;

  v3 = (unint64_t)(a2 - a1) >> 5;
  v4 = v3 - 1;
  if ((int)v3 >= 3)
  {
    v5 = 0;
    v6 = v3 - 1;
    while (1)
    {
      v7 = *(float *)(a1 + 32 * v5 + 16);
      v8 = *(float *)(a1 + 32 * v6 + 16);
      v9 = v7 - v8;
      if ((float)(v7 - v8) < 0.0)
        v9 = -(float)(v7 - v8);
      v10 = fminf(fmaxf((float)(a3 - v7) / (float)(v8 - v7), 0.0), 1.0);
      v11 = v7 <= a3;
      if (v7 >= a3)
        v12 = 0.5;
      else
        v12 = 1.0;
      if (!v11)
        v12 = 0.0;
      if (v9 > 0.00000011921)
        v12 = v10;
      v13 = llroundf((float)(v12 * (float)v6) + (float)((float)(1.0 - v12) * (float)v5));
      v14 = *(float *)(a1 + 32 * v13 + 16);
      if (v14 == a3)
      {
        LODWORD(v16) = v13;
        goto LABEL_23;
      }
      if (v14 >= a3)
      {
        v16 = (v13 - 1);
        if (v13 < 1)
        {
          LODWORD(v16) = 0;
          v13 = 0;
          goto LABEL_23;
        }
        v6 = v13 - 1;
        if (*(float *)(a1 + 32 * v16 + 16) < a3)
          goto LABEL_23;
      }
      else
      {
        if (v4 <= v13)
        {
          LODWORD(v16) = v4;
          goto LABEL_22;
        }
        v5 = v13 + 1;
        v15 = *(float *)(a1 + 32 * (v13 + 1) + 16);
        LODWORD(v16) = v13++;
        if (v15 > a3)
          goto LABEL_23;
      }
      LODWORD(v16) = v5;
      v13 = v6;
      if (v6 <= v5 + 1)
        goto LABEL_23;
    }
  }
  LODWORD(v16) = 0;
LABEL_22:
  v13 = v4;
LABEL_23:
  v17 = *(float *)(a1 + 32 * (int)v16 + 16);
  v18 = *(float *)(a1 + 32 * v13 + 16);
  v19 = v17 - v18;
  if ((float)(v17 - v18) < 0.0)
    v19 = -(float)(v17 - v18);
  v20 = fminf(fmaxf((float)(a3 - v17) / (float)(v18 - v17), 0.0), 1.0);
  v21 = v17 < a3;
  v22 = v17 <= a3;
  v23 = 0.5;
  if (v21)
    v23 = 1.0;
  if (!v22)
    v23 = 0.0;
  if (v19 > 0.00000011921)
    v23 = v20;
  return (int)llroundf((float)(v23 * (float)(int)v16) + (float)((float)(1.0 - v23) * (float)v13));
}

_QWORD *std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__init_with_size[abi:ne180100]<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band*,Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v4;
  uint64_t v7;
  _QWORD *v8;
  __int128 v9;

  if (a4)
  {
    v4 = result;
    if (a4 >> 59)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    result = std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::GraphDescriptionNode>>((uint64_t)(result + 2), a4);
    *v4 = result;
    v4[1] = result;
    v4[2] = &result[4 * v7];
    if (a2 != a3)
    {
      v8 = result;
      do
      {
        *v8 = off_24D57CBF8;
        v9 = *(_OWORD *)(a2 + 8);
        v8[3] = *(_QWORD *)(a2 + 24);
        *(_OWORD *)(v8 + 1) = v9;
        a2 += 32;
        result += 4;
        v8 += 4;
      }
      while (a2 != a3);
    }
    v4[1] = result;
  }
  return result;
}

void sub_216610F14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::PrecalculateDbLevels<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(uint64_t a1, uint64_t a2, float **a3)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  float v8;
  unint64_t v9;
  float *v10;
  float *v11;
  float *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  float *v18;
  int v19;
  float __C;

  a3[1] = *a3;
  if (a1 != a2)
  {
    v5 = a1;
    v6 = (uint64_t)(a3 + 2);
    do
    {
      __C = 0.0;
      v7 = (**(uint64_t (***)(uint64_t))v5)(v5);
      vDSP_measqv((const float *)(v5 + 20), 1, &__C, v7);
      v8 = log10f(__C + 1.1755e-38) * 10.0;
      v10 = a3[1];
      v9 = (unint64_t)a3[2];
      if ((unint64_t)v10 >= v9)
      {
        v12 = *a3;
        v13 = v10 - *a3;
        v14 = v13 + 1;
        if ((unint64_t)(v13 + 1) >> 62)
          std::vector<float>::__throw_length_error[abi:ne180100]();
        v15 = v9 - (_QWORD)v12;
        if (v15 >> 1 > v14)
          v14 = v15 >> 1;
        if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL)
          v16 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v16 = v14;
        if (v16)
        {
          v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v6, v16);
          v12 = *a3;
          v10 = a3[1];
        }
        else
        {
          v17 = 0;
        }
        v18 = (float *)&v17[4 * v13];
        *v18 = v8;
        v11 = v18 + 1;
        while (v10 != v12)
        {
          v19 = *((_DWORD *)v10-- - 1);
          *((_DWORD *)v18-- - 1) = v19;
        }
        *a3 = v18;
        a3[1] = v11;
        a3[2] = (float *)&v17[4 * v16];
        if (v12)
          operator delete(v12);
      }
      else
      {
        *v10 = v8;
        v11 = v10 + 1;
      }
      a3[1] = v11;
      v5 += 64;
    }
    while (v5 != a2);
  }
}

uint64_t Phase::SpatialModeler::TerminateAndWeightRemainder_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int64x2_t *a5, float a6, float a7)
{
  uint64_t v9;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  char *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  int64x2_t v34;
  uint64_t v35;
  unint64_t v37;
  unint64_t v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  char *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  char *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  int64x2_t v58;
  uint64_t v59;
  uint64_t v60;
  int64x2_t v61;
  uint64_t v62;
  int64x2_t *v63;

  v9 = a3;
  if (a2 == result)
  {
    if (a3 != a4)
    {
      do
      {
        result = Phase::SpatialModeler::WeightSingleReflection_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>((float *)v9, a7);
        v37 = a5->u64[1];
        v38 = a5[1].u64[0];
        if (v37 >= v38)
        {
          v43 = (uint64_t)(v37 - a5->i64[0]) >> 6;
          v44 = v43 + 1;
          if ((unint64_t)(v43 + 1) >> 58)
LABEL_43:
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          v45 = v38 - a5->i64[0];
          if (v45 >> 5 > v44)
            v44 = v45 >> 5;
          if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFC0)
            v46 = 0x3FFFFFFFFFFFFFFLL;
          else
            v46 = v44;
          v63 = a5 + 1;
          if (v46)
            v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Envelope<double>::SegmentInternal>>((uint64_t)a5[1].i64, v46);
          else
            v47 = 0;
          v48 = &v47[64 * v43];
          *(_QWORD *)v48 = off_24D57CC28;
          v49 = *(_OWORD *)(v9 + 8);
          v50 = *(_OWORD *)(v9 + 24);
          v51 = *(_OWORD *)(v9 + 40);
          *((_DWORD *)v48 + 14) = *(_DWORD *)(v9 + 56);
          *(_OWORD *)(v48 + 40) = v51;
          *(_OWORD *)(v48 + 24) = v50;
          *(_OWORD *)(v48 + 8) = v49;
          v52 = a5->i64[0];
          v53 = a5->u64[1];
          if (v53 == a5->i64[0])
          {
            v58 = vdupq_n_s64(v53);
            v54 = &v47[64 * v43];
          }
          else
          {
            v54 = &v47[64 * v43];
            do
            {
              *((_QWORD *)v54 - 8) = off_24D57CC28;
              v54 -= 64;
              v55 = *(_OWORD *)(v53 - 56);
              v56 = *(_OWORD *)(v53 - 40);
              v57 = *(_OWORD *)(v53 - 24);
              *((_DWORD *)v54 + 14) = *(_DWORD *)(v53 - 8);
              *(_OWORD *)(v54 + 40) = v57;
              *(_OWORD *)(v54 + 24) = v56;
              *(_OWORD *)(v54 + 8) = v55;
              v53 -= 64;
            }
            while (v53 != v52);
            v58 = *a5;
          }
          v42 = v48 + 64;
          a5->i64[0] = (uint64_t)v54;
          a5->i64[1] = (uint64_t)(v48 + 64);
          v61 = v58;
          v59 = a5[1].i64[0];
          a5[1].i64[0] = (uint64_t)&v47[64 * v46];
          v62 = v59;
          v60 = v58.i64[0];
          result = std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::~__split_buffer((uint64_t)&v60);
        }
        else
        {
          *(_QWORD *)v37 = off_24D57CC28;
          v39 = *(_OWORD *)(v9 + 8);
          v40 = *(_OWORD *)(v9 + 24);
          v41 = *(_OWORD *)(v9 + 40);
          *(_DWORD *)(v37 + 56) = *(_DWORD *)(v9 + 56);
          *(_OWORD *)(v37 + 40) = v41;
          *(_OWORD *)(v37 + 24) = v40;
          *(_OWORD *)(v37 + 8) = v39;
          v42 = (char *)(v37 + 64);
        }
        a5->i64[1] = (uint64_t)v42;
        v9 += 64;
      }
      while (v9 != a4);
    }
  }
  else if (a4 == a3)
  {
    v12 = result;
    do
    {
      result = Phase::SpatialModeler::WeightSingleReflection_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>((float *)v12, a6);
      v13 = a5->u64[1];
      v14 = a5[1].u64[0];
      if (v13 >= v14)
      {
        v19 = (uint64_t)(v13 - a5->i64[0]) >> 6;
        v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) >> 58)
          goto LABEL_43;
        v21 = v14 - a5->i64[0];
        if (v21 >> 5 > v20)
          v20 = v21 >> 5;
        if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFC0)
          v22 = 0x3FFFFFFFFFFFFFFLL;
        else
          v22 = v20;
        v63 = a5 + 1;
        if (v22)
          v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Envelope<double>::SegmentInternal>>((uint64_t)a5[1].i64, v22);
        else
          v23 = 0;
        v24 = &v23[64 * v19];
        *(_QWORD *)v24 = off_24D57CC28;
        v25 = *(_OWORD *)(v12 + 8);
        v26 = *(_OWORD *)(v12 + 24);
        v27 = *(_OWORD *)(v12 + 40);
        *((_DWORD *)v24 + 14) = *(_DWORD *)(v12 + 56);
        *(_OWORD *)(v24 + 40) = v27;
        *(_OWORD *)(v24 + 24) = v26;
        *(_OWORD *)(v24 + 8) = v25;
        v28 = a5->i64[0];
        v29 = a5->u64[1];
        if (v29 == a5->i64[0])
        {
          v34 = vdupq_n_s64(v29);
          v30 = &v23[64 * v19];
        }
        else
        {
          v30 = &v23[64 * v19];
          do
          {
            *((_QWORD *)v30 - 8) = off_24D57CC28;
            v30 -= 64;
            v31 = *(_OWORD *)(v29 - 56);
            v32 = *(_OWORD *)(v29 - 40);
            v33 = *(_OWORD *)(v29 - 24);
            *((_DWORD *)v30 + 14) = *(_DWORD *)(v29 - 8);
            *(_OWORD *)(v30 + 40) = v33;
            *(_OWORD *)(v30 + 24) = v32;
            *(_OWORD *)(v30 + 8) = v31;
            v29 -= 64;
          }
          while (v29 != v28);
          v34 = *a5;
        }
        v18 = v24 + 64;
        a5->i64[0] = (uint64_t)v30;
        a5->i64[1] = (uint64_t)(v24 + 64);
        v61 = v34;
        v35 = a5[1].i64[0];
        a5[1].i64[0] = (uint64_t)&v23[64 * v22];
        v62 = v35;
        v60 = v34.i64[0];
        result = std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::~__split_buffer((uint64_t)&v60);
      }
      else
      {
        *(_QWORD *)v13 = off_24D57CC28;
        v15 = *(_OWORD *)(v12 + 8);
        v16 = *(_OWORD *)(v12 + 24);
        v17 = *(_OWORD *)(v12 + 40);
        *(_DWORD *)(v13 + 56) = *(_DWORD *)(v12 + 56);
        *(_OWORD *)(v13 + 40) = v17;
        *(_OWORD *)(v13 + 24) = v16;
        *(_OWORD *)(v13 + 8) = v15;
        v18 = (char *)(v13 + 64);
      }
      a5->i64[1] = (uint64_t)v18;
      v12 += 64;
    }
    while (v12 != a2);
  }
  return result;
}

uint64_t Phase::SpatialModeler::FindPairAndMerge<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(_QWORD *a1, _QWORD *a2, uint64_t *a3, _QWORD *a4, int64x2_t *a5, float a6, float a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  float v16;
  uint64_t v17;
  uint64_t v18;
  float v19;
  float v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  float v26;
  unint64_t v27;
  unint64_t v28;
  float *v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float *v34;
  float v35;
  float v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  BOOL v49;
  float v50;
  float v51;
  float v52;
  float v53;
  __n128 v54;
  float v55;
  int v56;
  uint64_t result;
  unint64_t v58;
  unint64_t v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  char *v63;
  _QWORD *v64;
  uint64_t *v65;
  _QWORD *v66;
  _QWORD *v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  char *v72;
  char *v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  uint64_t v77;
  unint64_t v78;
  char *v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  int64x2_t v83;
  uint64_t v84;
  _QWORD *v85;
  _QWORD *v86;
  _QWORD *v87;
  _QWORD *v88;
  _QWORD *v89;
  uint64_t v90;
  BOOL v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  _QWORD *v98;
  _QWORD *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  float v108;
  _BYTE v109[52];
  uint64_t __B;
  int64x2_t v111;
  uint64_t v112;
  int64x2_t *v113;

  v10 = *a2;
  v11 = a2[1];
  v12 = v11 - *a2;
  if (v11 == *a2)
  {
    v14 = 0;
  }
  else
  {
    v13 = 0;
    v14 = 0;
    v15 = v12 >> 2;
    if (v15 <= 1)
      v15 = 1;
    v16 = -3.4028e38;
    do
    {
      if (*(float *)(v10 + 4 * v13) > v16)
      {
        v14 = v13;
        v16 = *(float *)(v10 + 4 * v13);
      }
      ++v13;
    }
    while (v15 != v13);
  }
  v17 = *a1;
  v18 = *a1 + (v14 << 6);
  v19 = *(float *)(v10 + 4 * v14);
  v20 = *(float *)(v18 + 16);
  v21 = *a3;
  v22 = a3[1];
  v23 = *a4;
  v24 = Phase::SpatialModeler::GetNearestReflectionIndex<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(*a3, v22, v20);
  v25 = *(float *)(v21 + (v24 << 6) + 16);
  v26 = v25 + 0.1;
  v27 = Phase::SpatialModeler::GetNearestReflectionIndex<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(v21, v22, v25 + -0.1);
  v28 = Phase::SpatialModeler::GetNearestReflectionIndex<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(v21, v22, v26);
  if (v27 <= v28)
  {
    v29 = (float *)(v21 + (v27 << 6) + 16);
    v30 = 3.4028e38;
    do
    {
      v31 = *v29;
      v29 += 16;
      v32 = (float)((float)(*(float *)(v23 + 4 * v27) - v19) * (float)(*(float *)(v23 + 4 * v27) - v19))
          + (float)((float)((float)(v31 - v20) / 0.01) * (float)((float)(v31 - v20) / 0.01));
      if (v32 < v30)
      {
        v24 = v27;
        v30 = v32;
      }
      ++v27;
    }
    while (v27 <= v28);
  }
  memset(&v109[8], 0, 44);
  v33 = *(float *)(v18 + 12);
  v34 = (float *)(v21 + (v24 << 6));
  v35 = v34[3];
  if (vabds_f32(v33, v35) > 180.0)
  {
    if (v33 >= v35)
      v35 = v35 + 360.0;
    else
      v33 = v33 + 360.0;
  }
  v36 = (float)(v35 * a7) + (float)(v33 * a6);
  if (v36 > 360.0)
    v36 = v36 + -360.0;
  *(float *)&v109[4] = v36;
  v37 = v17 + (v14 << 6);
  *(float *)v109 = (float)(v34[2] * a7) + (float)(*(float *)(v37 + 8) * a6);
  *(float *)&v109[8] = (float)(v34[4] * a7) + (float)(v20 * a6);
  if ((**(int (***)(uint64_t))v18)(v18) >= 1)
  {
    v38 = 0;
    v39 = v21 + (v24 << 6) + 20;
    v40 = v37 + 20;
    v41 = 0.0;
    v42 = 1.0;
    do
    {
      v43 = *(float *)(v40 + 4 * v38);
      v44 = fabsf(v43);
      v45 = *(float *)(v39 + 4 * v38);
      v46 = fabsf(v45);
      if (v45 == 0.0)
        v47 = COERCE_FLOAT(1);
      else
        v47 = v46;
      if (v45 < 0.0)
        v48 = -1.0;
      else
        v48 = 1.0;
      v108 = v48;
      v49 = v43 < 0.0;
      if (v43 == 0.0)
        v50 = COERCE_FLOAT(1);
      else
        v50 = v44;
      if (v49)
        v51 = -1.0;
      else
        v51 = 1.0;
      v52 = (float)((float)((float)(logf(v50) * 8.6859) / 10.0) * 10.0) * a6;
      v53 = (float)((float)((float)(logf(v47) * 8.6859) / 10.0) * 10.0) * a7;
      *(float *)&v109[4 * v38 + 12] = expf((float)((float)((float)(v52 + v53) * 10.0) / 10.0) * 0.11513);
      if (v52 <= v41)
        v54.n128_f32[0] = v42;
      else
        v54.n128_f32[0] = v51;
      if (v52 <= v41)
        v55 = v41;
      else
        v55 = v52;
      if (v53 <= v55)
        v42 = v54.n128_f32[0];
      else
        v42 = v108;
      if (v53 <= v55)
        v41 = v55;
      else
        v41 = v53;
      ++v38;
    }
    while (v38 < (**(int (***)(uint64_t, __n128))v18)(v18, v54));
    *(float *)&__B = v42;
    if (v42 < 0.0)
    {
      v56 = (**(uint64_t (***)(uint64_t))v18)(v18);
      vDSP_vsmul((const float *)&v109[12], 1, (const float *)&__B, (float *)&v109[12], 1, v56);
    }
  }
  result = (uint64_t)a5[1].i64;
  v58 = a5[1].u64[0];
  v59 = a5->u64[1];
  if (v59 >= v58)
  {
    v68 = (uint64_t)(v59 - a5->i64[0]) >> 6;
    v69 = v68 + 1;
    v67 = a1;
    if ((unint64_t)(v68 + 1) >> 58)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v70 = v58 - a5->i64[0];
    if (v70 >> 5 > v69)
      v69 = v70 >> 5;
    if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFC0)
      v71 = 0x3FFFFFFFFFFFFFFLL;
    else
      v71 = v69;
    v113 = a5 + 1;
    if (v71)
      v72 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Envelope<double>::SegmentInternal>>(result, v71);
    else
      v72 = 0;
    v73 = &v72[64 * v68];
    *(_QWORD *)v73 = off_24D57CC28;
    v74 = *(_OWORD *)v109;
    v75 = *(_OWORD *)&v109[16];
    v76 = *(_OWORD *)&v109[32];
    *((_DWORD *)v73 + 14) = *(_DWORD *)&v109[48];
    *(_OWORD *)(v73 + 40) = v76;
    *(_OWORD *)(v73 + 24) = v75;
    *(_OWORD *)(v73 + 8) = v74;
    v77 = a5->i64[0];
    v78 = a5->u64[1];
    if (v78 == a5->i64[0])
    {
      v83 = vdupq_n_s64(v78);
      v79 = &v72[64 * v68];
    }
    else
    {
      v79 = &v72[64 * v68];
      do
      {
        *((_QWORD *)v79 - 8) = off_24D57CC28;
        v79 -= 64;
        v80 = *(_OWORD *)(v78 - 56);
        v81 = *(_OWORD *)(v78 - 40);
        v82 = *(_OWORD *)(v78 - 24);
        *((_DWORD *)v79 + 14) = *(_DWORD *)(v78 - 8);
        *(_OWORD *)(v79 + 40) = v82;
        *(_OWORD *)(v79 + 24) = v81;
        *(_OWORD *)(v79 + 8) = v80;
        v78 -= 64;
      }
      while (v78 != v77);
      v83 = *a5;
    }
    v63 = v73 + 64;
    a5->i64[0] = (uint64_t)v79;
    a5->i64[1] = (uint64_t)(v73 + 64);
    v111 = v83;
    v84 = a5[1].i64[0];
    a5[1].i64[0] = (uint64_t)&v72[64 * v71];
    v112 = v84;
    __B = v83.i64[0];
    result = std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::~__split_buffer((uint64_t)&__B);
    v65 = a3;
    v64 = a4;
    v66 = a2;
  }
  else
  {
    *(_QWORD *)v59 = off_24D57CC28;
    v60 = *(_OWORD *)v109;
    v61 = *(_OWORD *)&v109[16];
    v62 = *(_OWORD *)&v109[32];
    *(_DWORD *)(v59 + 56) = *(_DWORD *)&v109[48];
    *(_OWORD *)(v59 + 40) = v62;
    *(_OWORD *)(v59 + 24) = v61;
    *(_OWORD *)(v59 + 8) = v60;
    v63 = (char *)(v59 + 64);
    v65 = a3;
    v64 = a4;
    v66 = a2;
    v67 = a1;
  }
  a5->i64[1] = (uint64_t)v63;
  v85 = (_QWORD *)v67[1];
  v86 = (_QWORD *)(*v67 + (v14 << 6));
  v87 = v86 + 8;
  if (v86 + 8 != v85)
  {
    do
    {
      *(_OWORD *)(v87 - 7) = *(_OWORD *)(v87 + 1);
      *(_OWORD *)(v87 - 5) = *(_OWORD *)(v87 + 3);
      *(_OWORD *)(v87 - 3) = *(_OWORD *)(v87 + 5);
      *((_DWORD *)v87 - 2) = *((_DWORD *)v87 + 14);
      v87 += 8;
      v86 += 8;
    }
    while (v87 != v85);
    v87 = (_QWORD *)v67[1];
  }
  if (v87 != v86)
  {
    v88 = v87 - 8;
    v89 = v87 - 8;
    do
    {
      v90 = *v89;
      v89 -= 8;
      result = (*(uint64_t (**)(_QWORD *))(v90 + 16))(v88);
      v91 = v88 == v86;
      v88 = v89;
    }
    while (!v91);
  }
  v67[1] = v86;
  v92 = v66[1];
  v93 = *v66 + 4 * v14;
  v94 = v92 - (v93 + 4);
  if (v92 != v93 + 4)
    result = (uint64_t)memmove((void *)(*v66 + 4 * v14), (const void *)(v93 + 4), v92 - (v93 + 4));
  v66[1] = v93 + v94;
  v95 = v65[1];
  v96 = *v65 + (v24 << 6);
  v97 = v96 + 64;
  if (v96 + 64 != v95)
  {
    do
    {
      *(_OWORD *)(v97 - 56) = *(_OWORD *)(v97 + 8);
      *(_OWORD *)(v97 - 40) = *(_OWORD *)(v97 + 24);
      *(_OWORD *)(v97 - 24) = *(_OWORD *)(v97 + 40);
      *(_DWORD *)(v97 - 8) = *(_DWORD *)(v97 + 56);
      v97 += 64;
      v96 += 64;
    }
    while (v97 != v95);
    v97 = v65[1];
  }
  if (v97 != v96)
  {
    v98 = (_QWORD *)(v97 - 64);
    v99 = (_QWORD *)(v97 - 64);
    do
    {
      v100 = *v99;
      v99 -= 8;
      result = (*(uint64_t (**)(_QWORD *))(v100 + 16))(v98);
      v91 = v98 == (_QWORD *)v96;
      v98 = v99;
    }
    while (!v91);
  }
  v65[1] = v96;
  v101 = v64[1];
  v102 = *v64 + 4 * v24;
  v103 = v101 - (v102 + 4);
  if (v101 != v102 + 4)
    result = (uint64_t)memmove((void *)v102, (const void *)(v102 + 4), v101 - (v102 + 4));
  v64[1] = v102 + v103;
  return result;
}

uint64_t Phase::SpatialModeler::GetNearestReflectionIndex<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(uint64_t a1, uint64_t a2, float a3)
{
  unint64_t v3;
  int v4;
  int v5;
  int v6;
  float v7;
  float v8;
  float v9;
  float v10;
  BOOL v11;
  float v12;
  int v13;
  float v14;
  float v15;
  uint64_t v16;
  float v17;
  float v18;
  float v19;
  float v20;
  BOOL v21;
  BOOL v22;
  float v23;

  v3 = (unint64_t)(a2 - a1) >> 6;
  v4 = v3 - 1;
  if ((int)v3 >= 3)
  {
    v5 = 0;
    v6 = v3 - 1;
    while (1)
    {
      v7 = *(float *)(a1 + ((uint64_t)v5 << 6) + 16);
      v8 = *(float *)(a1 + ((uint64_t)v6 << 6) + 16);
      v9 = v7 - v8;
      if ((float)(v7 - v8) < 0.0)
        v9 = -(float)(v7 - v8);
      v10 = fminf(fmaxf((float)(a3 - v7) / (float)(v8 - v7), 0.0), 1.0);
      v11 = v7 <= a3;
      if (v7 >= a3)
        v12 = 0.5;
      else
        v12 = 1.0;
      if (!v11)
        v12 = 0.0;
      if (v9 > 0.00000011921)
        v12 = v10;
      v13 = llroundf((float)(v12 * (float)v6) + (float)((float)(1.0 - v12) * (float)v5));
      v14 = *(float *)(a1 + ((uint64_t)v13 << 6) + 16);
      if (v14 == a3)
      {
        LODWORD(v16) = v13;
        goto LABEL_23;
      }
      if (v14 >= a3)
      {
        v16 = (v13 - 1);
        if (v13 < 1)
        {
          LODWORD(v16) = 0;
          v13 = 0;
          goto LABEL_23;
        }
        v6 = v13 - 1;
        if (*(float *)(a1 + (v16 << 6) + 16) < a3)
          goto LABEL_23;
      }
      else
      {
        if (v4 <= v13)
        {
          LODWORD(v16) = v4;
          goto LABEL_22;
        }
        v5 = v13 + 1;
        v15 = *(float *)(a1 + ((v13 + 1) << 6) + 16);
        LODWORD(v16) = v13++;
        if (v15 > a3)
          goto LABEL_23;
      }
      LODWORD(v16) = v5;
      v13 = v6;
      if (v6 <= v5 + 1)
        goto LABEL_23;
    }
  }
  LODWORD(v16) = 0;
LABEL_22:
  v13 = v4;
LABEL_23:
  v17 = *(float *)(a1 + ((uint64_t)(int)v16 << 6) + 16);
  v18 = *(float *)(a1 + ((uint64_t)v13 << 6) + 16);
  v19 = v17 - v18;
  if ((float)(v17 - v18) < 0.0)
    v19 = -(float)(v17 - v18);
  v20 = fminf(fmaxf((float)(a3 - v17) / (float)(v18 - v17), 0.0), 1.0);
  v21 = v17 < a3;
  v22 = v17 <= a3;
  v23 = 0.5;
  if (v21)
    v23 = 1.0;
  if (!v22)
    v23 = 0.0;
  if (v19 > 0.00000011921)
    v23 = v20;
  return (int)llroundf((float)(v23 * (float)(int)v16) + (float)((float)(1.0 - v23) * (float)v13));
}

_QWORD *std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::__init_with_size[abi:ne180100]<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave*,Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v4;
  uint64_t v7;
  _QWORD *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;

  if (a4)
  {
    v4 = result;
    if (a4 >> 58)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    result = std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Envelope<double>::SegmentInternal>>((uint64_t)(result + 2), a4);
    *v4 = result;
    v4[1] = result;
    v4[2] = &result[8 * v7];
    if (a2 != a3)
    {
      v8 = result;
      do
      {
        *v8 = off_24D57CC28;
        v9 = *(_OWORD *)(a2 + 8);
        v10 = *(_OWORD *)(a2 + 24);
        v11 = *(_OWORD *)(a2 + 40);
        *((_DWORD *)v8 + 14) = *(_DWORD *)(a2 + 56);
        *(_OWORD *)(v8 + 5) = v11;
        *(_OWORD *)(v8 + 3) = v10;
        *(_OWORD *)(v8 + 1) = v9;
        a2 += 64;
        result += 8;
        v8 += 8;
      }
      while (a2 != a3);
    }
    v4[1] = result;
  }
  return result;
}

void sub_216611C2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::PrecalculateDbLevels<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(uint64_t a1, uint64_t a2, float **a3)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  float v8;
  unint64_t v9;
  float *v10;
  float *v11;
  float *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  float *v18;
  int v19;
  float __C;

  a3[1] = *a3;
  if (a1 != a2)
  {
    v5 = a1;
    v6 = (uint64_t)(a3 + 2);
    do
    {
      __C = 0.0;
      v7 = (**(uint64_t (***)(uint64_t))v5)(v5);
      vDSP_measqv((const float *)(v5 + 20), 1, &__C, v7);
      v8 = log10f(__C + 1.1755e-38) * 10.0;
      v10 = a3[1];
      v9 = (unint64_t)a3[2];
      if ((unint64_t)v10 >= v9)
      {
        v12 = *a3;
        v13 = v10 - *a3;
        v14 = v13 + 1;
        if ((unint64_t)(v13 + 1) >> 62)
          std::vector<float>::__throw_length_error[abi:ne180100]();
        v15 = v9 - (_QWORD)v12;
        if (v15 >> 1 > v14)
          v14 = v15 >> 1;
        if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL)
          v16 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v16 = v14;
        if (v16)
        {
          v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v6, v16);
          v12 = *a3;
          v10 = a3[1];
        }
        else
        {
          v17 = 0;
        }
        v18 = (float *)&v17[4 * v13];
        *v18 = v8;
        v11 = v18 + 1;
        while (v10 != v12)
        {
          v19 = *((_DWORD *)v10-- - 1);
          *((_DWORD *)v18-- - 1) = v19;
        }
        *a3 = v18;
        a3[1] = v11;
        a3[2] = (float *)&v17[4 * v16];
        if (v12)
          operator delete(v12);
      }
      else
      {
        *v10 = v8;
        v11 = v10 + 1;
      }
      a3[1] = v11;
      v5 += 144;
    }
    while (v5 != a2);
  }
}

uint64_t Phase::SpatialModeler::TerminateAndWeightRemainder_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int64x2_t *a5, float a6, float a7)
{
  uint64_t v9;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  char *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  int64x2_t v43;
  uint64_t v44;
  unint64_t v46;
  unint64_t v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  char *v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  char *v59;
  char *v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;
  unint64_t v68;
  char *v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  int64x2_t v76;
  uint64_t v77;
  uint64_t v78;
  int64x2_t v79;
  uint64_t v80;
  int64x2_t *v81;

  v9 = a3;
  if (a2 == result)
  {
    if (a3 != a4)
    {
      do
      {
        result = Phase::SpatialModeler::WeightSingleReflection_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>((float *)v9, a7);
        v46 = a5->u64[1];
        v47 = a5[1].u64[0];
        if (v46 >= v47)
        {
          v55 = 0x8E38E38E38E38E39 * ((uint64_t)(v46 - a5->i64[0]) >> 4);
          v56 = v55 + 1;
          if (v55 + 1 > 0x1C71C71C71C71C7)
LABEL_43:
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          v57 = 0x8E38E38E38E38E39 * ((uint64_t)(v47 - a5->i64[0]) >> 4);
          if (2 * v57 > v56)
            v56 = 2 * v57;
          if (v57 >= 0xE38E38E38E38E3)
            v58 = 0x1C71C71C71C71C7;
          else
            v58 = v56;
          v81 = a5 + 1;
          if (v58)
            v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>>((uint64_t)a5[1].i64, v58);
          else
            v59 = 0;
          v60 = &v59[144 * v55];
          *(_QWORD *)v60 = off_24D57CC58;
          *(_OWORD *)(v60 + 8) = *(_OWORD *)(v9 + 8);
          v61 = *(_OWORD *)(v9 + 24);
          v62 = *(_OWORD *)(v9 + 40);
          v63 = *(_OWORD *)(v9 + 56);
          *(_OWORD *)(v60 + 72) = *(_OWORD *)(v9 + 72);
          *(_OWORD *)(v60 + 56) = v63;
          *(_OWORD *)(v60 + 40) = v62;
          *(_OWORD *)(v60 + 24) = v61;
          v64 = *(_OWORD *)(v9 + 88);
          v65 = *(_OWORD *)(v9 + 104);
          v66 = *(_OWORD *)(v9 + 120);
          *((_QWORD *)v60 + 17) = *(_QWORD *)(v9 + 136);
          *(_OWORD *)(v60 + 120) = v66;
          *(_OWORD *)(v60 + 104) = v65;
          *(_OWORD *)(v60 + 88) = v64;
          v67 = a5->i64[0];
          v68 = a5->u64[1];
          if (v68 == a5->i64[0])
          {
            v76 = vdupq_n_s64(v68);
            v69 = &v59[144 * v55];
          }
          else
          {
            v69 = &v59[144 * v55];
            do
            {
              *((_QWORD *)v69 - 18) = off_24D57CC58;
              v69 -= 144;
              *(_OWORD *)(v69 + 8) = *(_OWORD *)(v68 - 136);
              v70 = *(_OWORD *)(v68 - 120);
              v71 = *(_OWORD *)(v68 - 104);
              v72 = *(_OWORD *)(v68 - 88);
              *(_OWORD *)(v69 + 72) = *(_OWORD *)(v68 - 72);
              *(_OWORD *)(v69 + 56) = v72;
              *(_OWORD *)(v69 + 40) = v71;
              *(_OWORD *)(v69 + 24) = v70;
              v73 = *(_OWORD *)(v68 - 56);
              v74 = *(_OWORD *)(v68 - 40);
              v75 = *(_OWORD *)(v68 - 24);
              *((_QWORD *)v69 + 17) = *(_QWORD *)(v68 - 8);
              *(_OWORD *)(v69 + 120) = v75;
              *(_OWORD *)(v69 + 104) = v74;
              *(_OWORD *)(v69 + 88) = v73;
              v68 -= 144;
            }
            while (v68 != v67);
            v76 = *a5;
          }
          v54 = v60 + 144;
          a5->i64[0] = (uint64_t)v69;
          a5->i64[1] = (uint64_t)(v60 + 144);
          v79 = v76;
          v77 = a5[1].i64[0];
          a5[1].i64[0] = (uint64_t)&v59[144 * v58];
          v80 = v77;
          v78 = v76.i64[0];
          result = std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::~__split_buffer((uint64_t)&v78);
        }
        else
        {
          *(_QWORD *)v46 = off_24D57CC58;
          *(_OWORD *)(v46 + 8) = *(_OWORD *)(v9 + 8);
          v48 = *(_OWORD *)(v9 + 24);
          v49 = *(_OWORD *)(v9 + 40);
          v50 = *(_OWORD *)(v9 + 56);
          *(_OWORD *)(v46 + 72) = *(_OWORD *)(v9 + 72);
          *(_OWORD *)(v46 + 56) = v50;
          *(_OWORD *)(v46 + 40) = v49;
          *(_OWORD *)(v46 + 24) = v48;
          v51 = *(_OWORD *)(v9 + 88);
          v52 = *(_OWORD *)(v9 + 104);
          v53 = *(_OWORD *)(v9 + 120);
          *(_QWORD *)(v46 + 136) = *(_QWORD *)(v9 + 136);
          *(_OWORD *)(v46 + 120) = v53;
          *(_OWORD *)(v46 + 104) = v52;
          *(_OWORD *)(v46 + 88) = v51;
          v54 = (char *)(v46 + 144);
        }
        a5->i64[1] = (uint64_t)v54;
        v9 += 144;
      }
      while (v9 != a4);
    }
  }
  else if (a4 == a3)
  {
    v12 = result;
    do
    {
      result = Phase::SpatialModeler::WeightSingleReflection_dBDomain<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>((float *)v12, a6);
      v13 = a5->u64[1];
      v14 = a5[1].u64[0];
      if (v13 >= v14)
      {
        v22 = 0x8E38E38E38E38E39 * ((uint64_t)(v13 - a5->i64[0]) >> 4);
        v23 = v22 + 1;
        if (v22 + 1 > 0x1C71C71C71C71C7)
          goto LABEL_43;
        v24 = 0x8E38E38E38E38E39 * ((uint64_t)(v14 - a5->i64[0]) >> 4);
        if (2 * v24 > v23)
          v23 = 2 * v24;
        if (v24 >= 0xE38E38E38E38E3)
          v25 = 0x1C71C71C71C71C7;
        else
          v25 = v23;
        v81 = a5 + 1;
        if (v25)
          v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>>((uint64_t)a5[1].i64, v25);
        else
          v26 = 0;
        v27 = &v26[144 * v22];
        *(_QWORD *)v27 = off_24D57CC58;
        *(_OWORD *)(v27 + 8) = *(_OWORD *)(v12 + 8);
        v28 = *(_OWORD *)(v12 + 24);
        v29 = *(_OWORD *)(v12 + 40);
        v30 = *(_OWORD *)(v12 + 56);
        *(_OWORD *)(v27 + 72) = *(_OWORD *)(v12 + 72);
        *(_OWORD *)(v27 + 56) = v30;
        *(_OWORD *)(v27 + 40) = v29;
        *(_OWORD *)(v27 + 24) = v28;
        v31 = *(_OWORD *)(v12 + 88);
        v32 = *(_OWORD *)(v12 + 104);
        v33 = *(_OWORD *)(v12 + 120);
        *((_QWORD *)v27 + 17) = *(_QWORD *)(v12 + 136);
        *(_OWORD *)(v27 + 120) = v33;
        *(_OWORD *)(v27 + 104) = v32;
        *(_OWORD *)(v27 + 88) = v31;
        v34 = a5->i64[0];
        v35 = a5->u64[1];
        if (v35 == a5->i64[0])
        {
          v43 = vdupq_n_s64(v35);
          v36 = &v26[144 * v22];
        }
        else
        {
          v36 = &v26[144 * v22];
          do
          {
            *((_QWORD *)v36 - 18) = off_24D57CC58;
            v36 -= 144;
            *(_OWORD *)(v36 + 8) = *(_OWORD *)(v35 - 136);
            v37 = *(_OWORD *)(v35 - 120);
            v38 = *(_OWORD *)(v35 - 104);
            v39 = *(_OWORD *)(v35 - 88);
            *(_OWORD *)(v36 + 72) = *(_OWORD *)(v35 - 72);
            *(_OWORD *)(v36 + 56) = v39;
            *(_OWORD *)(v36 + 40) = v38;
            *(_OWORD *)(v36 + 24) = v37;
            v40 = *(_OWORD *)(v35 - 56);
            v41 = *(_OWORD *)(v35 - 40);
            v42 = *(_OWORD *)(v35 - 24);
            *((_QWORD *)v36 + 17) = *(_QWORD *)(v35 - 8);
            *(_OWORD *)(v36 + 120) = v42;
            *(_OWORD *)(v36 + 104) = v41;
            *(_OWORD *)(v36 + 88) = v40;
            v35 -= 144;
          }
          while (v35 != v34);
          v43 = *a5;
        }
        v21 = v27 + 144;
        a5->i64[0] = (uint64_t)v36;
        a5->i64[1] = (uint64_t)(v27 + 144);
        v79 = v43;
        v44 = a5[1].i64[0];
        a5[1].i64[0] = (uint64_t)&v26[144 * v25];
        v80 = v44;
        v78 = v43.i64[0];
        result = std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::~__split_buffer((uint64_t)&v78);
      }
      else
      {
        *(_QWORD *)v13 = off_24D57CC58;
        *(_OWORD *)(v13 + 8) = *(_OWORD *)(v12 + 8);
        v15 = *(_OWORD *)(v12 + 24);
        v16 = *(_OWORD *)(v12 + 40);
        v17 = *(_OWORD *)(v12 + 56);
        *(_OWORD *)(v13 + 72) = *(_OWORD *)(v12 + 72);
        *(_OWORD *)(v13 + 56) = v17;
        *(_OWORD *)(v13 + 40) = v16;
        *(_OWORD *)(v13 + 24) = v15;
        v18 = *(_OWORD *)(v12 + 88);
        v19 = *(_OWORD *)(v12 + 104);
        v20 = *(_OWORD *)(v12 + 120);
        *(_QWORD *)(v13 + 136) = *(_QWORD *)(v12 + 136);
        *(_OWORD *)(v13 + 120) = v20;
        *(_OWORD *)(v13 + 104) = v19;
        *(_OWORD *)(v13 + 88) = v18;
        v21 = (char *)(v13 + 144);
      }
      a5->i64[1] = (uint64_t)v21;
      v12 += 144;
    }
    while (v12 != a2);
  }
  return result;
}

uint64_t Phase::SpatialModeler::FindPairAndMerge<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(_QWORD *a1, _QWORD *a2, uint64_t *a3, _QWORD *a4, int64x2_t *a5, float a6, float a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  float v16;
  uint64_t v17;
  uint64_t v18;
  float v19;
  float v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  float v26;
  unint64_t v27;
  unint64_t v28;
  float *v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  BOOL v48;
  float v49;
  float v50;
  float v51;
  float v52;
  __n128 v53;
  float v54;
  int v55;
  uint64_t result;
  unint64_t v57;
  unint64_t v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  char *v65;
  _QWORD *v66;
  uint64_t *v67;
  _QWORD *v68;
  _QWORD *v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  char *v74;
  char *v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  uint64_t v82;
  unint64_t v83;
  char *v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  int64x2_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  _QWORD *v96;
  _QWORD *v97;
  uint64_t v98;
  BOOL v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  _QWORD *v106;
  _QWORD *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  float v116;
  _BYTE v117[136];
  uint64_t __B;
  int64x2_t v119;
  uint64_t v120;
  int64x2_t *v121;

  v10 = *a2;
  v11 = a2[1];
  v12 = v11 - *a2;
  if (v11 == *a2)
  {
    v14 = 0;
  }
  else
  {
    v13 = 0;
    v14 = 0;
    v15 = v12 >> 2;
    if (v15 <= 1)
      v15 = 1;
    v16 = -3.4028e38;
    do
    {
      if (*(float *)(v10 + 4 * v13) > v16)
      {
        v14 = v13;
        v16 = *(float *)(v10 + 4 * v13);
      }
      ++v13;
    }
    while (v15 != v13);
  }
  v17 = *a1;
  v18 = *a1 + 144 * v14;
  v19 = *(float *)(v10 + 4 * v14);
  v20 = *(float *)(v18 + 16);
  v21 = *a3;
  v22 = a3[1];
  v23 = *a4;
  v24 = Phase::SpatialModeler::GetNearestReflectionIndex<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(*a3, v22, v20);
  v25 = *(float *)(v21 + 144 * v24 + 16);
  v26 = v25 + 0.1;
  v27 = Phase::SpatialModeler::GetNearestReflectionIndex<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(v21, v22, v25 + -0.1);
  v28 = Phase::SpatialModeler::GetNearestReflectionIndex<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(v21, v22, v26);
  if (v27 <= v28)
  {
    v29 = (float *)(v21 + 144 * v27 + 16);
    v30 = 3.4028e38;
    do
    {
      v31 = *v29;
      v29 += 36;
      v32 = (float)((float)(*(float *)(v23 + 4 * v27) - v19) * (float)(*(float *)(v23 + 4 * v27) - v19))
          + (float)((float)((float)(v31 - v20) / 0.01) * (float)((float)(v31 - v20) / 0.01));
      if (v32 < v30)
      {
        v24 = v27;
        v30 = v32;
      }
      ++v27;
    }
    while (v27 <= v28);
  }
  memset(&v117[8], 0, 128);
  v33 = *(float *)(v17 + 144 * v14 + 12);
  v34 = *(float *)(v21 + 144 * v24 + 12);
  if (vabds_f32(v33, v34) > 180.0)
  {
    if (v33 >= v34)
      v34 = v34 + 360.0;
    else
      v33 = v33 + 360.0;
  }
  v35 = (float)(v34 * a7) + (float)(v33 * a6);
  if (v35 > 360.0)
    v35 = v35 + -360.0;
  *(float *)&v117[4] = v35;
  v36 = v21 + 144 * v24;
  *(float *)v117 = (float)(*(float *)(v36 + 8) * a7) + (float)(*(float *)(v17 + 144 * v14 + 8) * a6);
  *(float *)&v117[8] = (float)(*(float *)(v36 + 16) * a7) + (float)(v20 * a6);
  if ((**(int (***)(uint64_t))v18)(v18) >= 1)
  {
    v37 = 0;
    v38 = v21 + 144 * v24 + 20;
    v39 = v17 + 144 * v14 + 20;
    v40 = 0.0;
    v41 = 1.0;
    do
    {
      v42 = *(float *)(v39 + 4 * v37);
      v43 = fabsf(v42);
      v44 = *(float *)(v38 + 4 * v37);
      v45 = fabsf(v44);
      if (v44 == 0.0)
        v46 = COERCE_FLOAT(1);
      else
        v46 = v45;
      if (v44 < 0.0)
        v47 = -1.0;
      else
        v47 = 1.0;
      v116 = v47;
      v48 = v42 < 0.0;
      if (v42 == 0.0)
        v49 = COERCE_FLOAT(1);
      else
        v49 = v43;
      if (v48)
        v50 = -1.0;
      else
        v50 = 1.0;
      v51 = (float)((float)((float)(logf(v49) * 8.6859) / 10.0) * 10.0) * a6;
      v52 = (float)((float)((float)(logf(v46) * 8.6859) / 10.0) * 10.0) * a7;
      *(float *)&v117[4 * v37 + 12] = expf((float)((float)((float)(v51 + v52) * 10.0) / 10.0) * 0.11513);
      if (v51 <= v40)
        v53.n128_f32[0] = v41;
      else
        v53.n128_f32[0] = v50;
      if (v51 <= v40)
        v54 = v40;
      else
        v54 = v51;
      if (v52 <= v54)
        v41 = v53.n128_f32[0];
      else
        v41 = v116;
      if (v52 <= v54)
        v40 = v54;
      else
        v40 = v52;
      ++v37;
    }
    while (v37 < (**(int (***)(uint64_t, __n128))v18)(v18, v53));
    *(float *)&__B = v41;
    if (v41 < 0.0)
    {
      v55 = (**(uint64_t (***)(uint64_t))v18)(v18);
      vDSP_vsmul((const float *)&v117[12], 1, (const float *)&__B, (float *)&v117[12], 1, v55);
    }
  }
  result = (uint64_t)a5[1].i64;
  v57 = a5[1].u64[0];
  v58 = a5->u64[1];
  if (v58 >= v57)
  {
    v70 = 0x8E38E38E38E38E39 * ((uint64_t)(v58 - a5->i64[0]) >> 4);
    v71 = v70 + 1;
    v69 = a1;
    if (v70 + 1 > 0x1C71C71C71C71C7)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v72 = 0x8E38E38E38E38E39 * ((uint64_t)(v57 - a5->i64[0]) >> 4);
    if (2 * v72 > v71)
      v71 = 2 * v72;
    if (v72 >= 0xE38E38E38E38E3)
      v73 = 0x1C71C71C71C71C7;
    else
      v73 = v71;
    v121 = a5 + 1;
    if (v73)
      v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>>(result, v73);
    else
      v74 = 0;
    v75 = &v74[144 * v70];
    *(_QWORD *)v75 = off_24D57CC58;
    *(_OWORD *)(v75 + 8) = *(_OWORD *)v117;
    v76 = *(_OWORD *)&v117[16];
    v77 = *(_OWORD *)&v117[32];
    v78 = *(_OWORD *)&v117[48];
    *(_OWORD *)(v75 + 72) = *(_OWORD *)&v117[64];
    *(_OWORD *)(v75 + 56) = v78;
    *(_OWORD *)(v75 + 40) = v77;
    *(_OWORD *)(v75 + 24) = v76;
    v79 = *(_OWORD *)&v117[80];
    v80 = *(_OWORD *)&v117[96];
    v81 = *(_OWORD *)&v117[112];
    *((_QWORD *)v75 + 17) = *(_QWORD *)&v117[128];
    *(_OWORD *)(v75 + 120) = v81;
    *(_OWORD *)(v75 + 104) = v80;
    *(_OWORD *)(v75 + 88) = v79;
    v82 = a5->i64[0];
    v83 = a5->u64[1];
    if (v83 == a5->i64[0])
    {
      v91 = vdupq_n_s64(v83);
      v84 = &v74[144 * v70];
    }
    else
    {
      v84 = &v74[144 * v70];
      do
      {
        *((_QWORD *)v84 - 18) = off_24D57CC58;
        v84 -= 144;
        *(_OWORD *)(v84 + 8) = *(_OWORD *)(v83 - 136);
        v85 = *(_OWORD *)(v83 - 120);
        v86 = *(_OWORD *)(v83 - 104);
        v87 = *(_OWORD *)(v83 - 88);
        *(_OWORD *)(v84 + 72) = *(_OWORD *)(v83 - 72);
        *(_OWORD *)(v84 + 56) = v87;
        *(_OWORD *)(v84 + 40) = v86;
        *(_OWORD *)(v84 + 24) = v85;
        v88 = *(_OWORD *)(v83 - 56);
        v89 = *(_OWORD *)(v83 - 40);
        v90 = *(_OWORD *)(v83 - 24);
        *((_QWORD *)v84 + 17) = *(_QWORD *)(v83 - 8);
        *(_OWORD *)(v84 + 120) = v90;
        *(_OWORD *)(v84 + 104) = v89;
        *(_OWORD *)(v84 + 88) = v88;
        v83 -= 144;
      }
      while (v83 != v82);
      v91 = *a5;
    }
    v65 = v75 + 144;
    a5->i64[0] = (uint64_t)v84;
    a5->i64[1] = (uint64_t)(v75 + 144);
    v119 = v91;
    v92 = a5[1].i64[0];
    a5[1].i64[0] = (uint64_t)&v74[144 * v73];
    v120 = v92;
    __B = v91.i64[0];
    result = std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::~__split_buffer((uint64_t)&__B);
    v67 = a3;
    v66 = a4;
    v68 = a2;
  }
  else
  {
    *(_QWORD *)v58 = off_24D57CC58;
    *(_OWORD *)(v58 + 8) = *(_OWORD *)v117;
    v59 = *(_OWORD *)&v117[16];
    v60 = *(_OWORD *)&v117[32];
    v61 = *(_OWORD *)&v117[48];
    *(_OWORD *)(v58 + 72) = *(_OWORD *)&v117[64];
    *(_OWORD *)(v58 + 56) = v61;
    *(_OWORD *)(v58 + 40) = v60;
    *(_OWORD *)(v58 + 24) = v59;
    v62 = *(_OWORD *)&v117[80];
    v63 = *(_OWORD *)&v117[96];
    v64 = *(_OWORD *)&v117[112];
    *(_QWORD *)(v58 + 136) = *(_QWORD *)&v117[128];
    *(_OWORD *)(v58 + 120) = v64;
    *(_OWORD *)(v58 + 104) = v63;
    *(_OWORD *)(v58 + 88) = v62;
    v65 = (char *)(v58 + 144);
    v67 = a3;
    v66 = a4;
    v68 = a2;
    v69 = a1;
  }
  a5->i64[1] = (uint64_t)v65;
  v93 = v69[1];
  v94 = *v69 + 144 * v14;
  v95 = v94 + 144;
  if (v94 + 144 != v93)
  {
    do
    {
      *(_OWORD *)(v95 - 56) = *(_OWORD *)(v95 + 88);
      *(_OWORD *)(v95 - 40) = *(_OWORD *)(v95 + 104);
      *(_OWORD *)(v95 - 24) = *(_OWORD *)(v95 + 120);
      *(_QWORD *)(v95 - 8) = *(_QWORD *)(v95 + 136);
      *(_OWORD *)(v95 - 120) = *(_OWORD *)(v95 + 24);
      *(_OWORD *)(v95 - 104) = *(_OWORD *)(v95 + 40);
      *(_OWORD *)(v95 - 88) = *(_OWORD *)(v95 + 56);
      *(_OWORD *)(v95 - 72) = *(_OWORD *)(v95 + 72);
      *(_OWORD *)(v95 - 136) = *(_OWORD *)(v95 + 8);
      v95 += 144;
      v94 += 144;
    }
    while (v95 != v93);
    v95 = v69[1];
  }
  if (v95 != v94)
  {
    v96 = (_QWORD *)(v95 - 144);
    v97 = (_QWORD *)(v95 - 144);
    do
    {
      v98 = *v97;
      v97 -= 18;
      result = (*(uint64_t (**)(_QWORD *))(v98 + 16))(v96);
      v99 = v96 == (_QWORD *)v94;
      v96 = v97;
    }
    while (!v99);
  }
  v69[1] = v94;
  v100 = v68[1];
  v101 = *v68 + 4 * v14;
  v102 = v100 - (v101 + 4);
  if (v100 != v101 + 4)
    result = (uint64_t)memmove((void *)(*v68 + 4 * v14), (const void *)(v101 + 4), v100 - (v101 + 4));
  v68[1] = v101 + v102;
  v103 = v67[1];
  v104 = *v67 + 144 * v24;
  v105 = v104 + 144;
  if (v104 + 144 != v103)
  {
    do
    {
      *(_OWORD *)(v105 - 56) = *(_OWORD *)(v105 + 88);
      *(_OWORD *)(v105 - 40) = *(_OWORD *)(v105 + 104);
      *(_OWORD *)(v105 - 24) = *(_OWORD *)(v105 + 120);
      *(_QWORD *)(v105 - 8) = *(_QWORD *)(v105 + 136);
      *(_OWORD *)(v105 - 120) = *(_OWORD *)(v105 + 24);
      *(_OWORD *)(v105 - 104) = *(_OWORD *)(v105 + 40);
      *(_OWORD *)(v105 - 88) = *(_OWORD *)(v105 + 56);
      *(_OWORD *)(v105 - 72) = *(_OWORD *)(v105 + 72);
      *(_OWORD *)(v105 - 136) = *(_OWORD *)(v105 + 8);
      v105 += 144;
      v104 += 144;
    }
    while (v105 != v103);
    v105 = v67[1];
  }
  if (v105 != v104)
  {
    v106 = (_QWORD *)(v105 - 144);
    v107 = (_QWORD *)(v105 - 144);
    do
    {
      v108 = *v107;
      v107 -= 18;
      result = (*(uint64_t (**)(_QWORD *))(v108 + 16))(v106);
      v99 = v106 == (_QWORD *)v104;
      v106 = v107;
    }
    while (!v99);
  }
  v67[1] = v104;
  v109 = v66[1];
  v110 = *v66 + 4 * v24;
  v111 = v109 - (v110 + 4);
  if (v109 != v110 + 4)
    result = (uint64_t)memmove((void *)v110, (const void *)(v110 + 4), v109 - (v110 + 4));
  v66[1] = v110 + v111;
  return result;
}

uint64_t Phase::SpatialModeler::GetNearestReflectionIndex<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(uint64_t a1, uint64_t a2, float a3)
{
  int v3;
  uint64_t v4;
  int v5;
  float v6;
  float v7;
  float v8;
  float v9;
  BOOL v10;
  float v11;
  int v12;
  float v13;
  int v14;
  float v15;
  float v16;
  float v17;
  float v18;
  BOOL v19;
  BOOL v20;
  float v21;

  v3 = 954437177 * ((unint64_t)(a2 - a1) >> 4);
  if (v3 >= 3)
  {
    LODWORD(v4) = 0;
    v5 = v3 - 1;
    while (1)
    {
      v6 = *(float *)(a1 + 144 * (int)v4 + 16);
      v7 = *(float *)(a1 + 144 * v5 + 16);
      v8 = v6 - v7;
      if ((float)(v6 - v7) < 0.0)
        v8 = -(float)(v6 - v7);
      v9 = fminf(fmaxf((float)(a3 - v6) / (float)(v7 - v6), 0.0), 1.0);
      v10 = v6 <= a3;
      if (v6 >= a3)
        v11 = 0.5;
      else
        v11 = 1.0;
      if (!v10)
        v11 = 0.0;
      if (v8 > 0.00000011921)
        v11 = v9;
      v12 = llroundf((float)(v11 * (float)v5) + (float)((float)(1.0 - v11) * (float)(int)v4));
      v13 = *(float *)(a1 + 144 * v12 + 16);
      if (v13 == a3)
      {
        v14 = v12;
        goto LABEL_23;
      }
      if (v13 >= a3)
      {
        v5 = v12 - 1;
        if (v12 < 1)
        {
          v14 = 0;
          v12 = 0;
          goto LABEL_23;
        }
        v14 = v12 - 1;
        if (*(float *)(a1 + 144 * v5 + 16) < a3)
          goto LABEL_23;
      }
      else
      {
        if (v3 - 1 <= v12)
        {
          v14 = v3 - 1;
          goto LABEL_22;
        }
        v4 = v12 + 1;
        v14 = v12++;
        if (*(float *)(a1 + 144 * v4 + 16) > a3)
          goto LABEL_23;
      }
      v14 = v4;
      v12 = v5;
      if (v5 <= (int)v4 + 1)
        goto LABEL_23;
    }
  }
  v14 = 0;
LABEL_22:
  v12 = v3 - 1;
LABEL_23:
  v15 = *(float *)(a1 + 144 * v14 + 16);
  v16 = *(float *)(a1 + 144 * v12 + 16);
  v17 = v15 - v16;
  if ((float)(v15 - v16) < 0.0)
    v17 = -(float)(v15 - v16);
  v18 = fminf(fmaxf((float)(a3 - v15) / (float)(v16 - v15), 0.0), 1.0);
  v19 = v15 < a3;
  v20 = v15 <= a3;
  v21 = 0.5;
  if (v19)
    v21 = 1.0;
  if (!v20)
    v21 = 0.0;
  if (v17 > 0.00000011921)
    v21 = v18;
  return (int)llroundf((float)(v21 * (float)v14) + (float)((float)(1.0 - v21) * (float)v12));
}

_QWORD *std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::__init_with_size[abi:ne180100]<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave*,Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v4;
  uint64_t v7;
  _QWORD *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  if (a4)
  {
    v4 = result;
    if (a4 >= 0x1C71C71C71C71C8)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    result = std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>>((uint64_t)(result + 2), a4);
    *v4 = result;
    v4[1] = result;
    v4[2] = &result[18 * v7];
    if (a2 != a3)
    {
      v8 = result;
      do
      {
        *v8 = off_24D57CC58;
        *(_OWORD *)(v8 + 1) = *(_OWORD *)(a2 + 8);
        v9 = *(_OWORD *)(a2 + 24);
        v10 = *(_OWORD *)(a2 + 40);
        v11 = *(_OWORD *)(a2 + 56);
        *(_OWORD *)(v8 + 9) = *(_OWORD *)(a2 + 72);
        *(_OWORD *)(v8 + 7) = v11;
        *(_OWORD *)(v8 + 5) = v10;
        *(_OWORD *)(v8 + 3) = v9;
        v12 = *(_OWORD *)(a2 + 88);
        v13 = *(_OWORD *)(a2 + 104);
        v14 = *(_OWORD *)(a2 + 120);
        v8[17] = *(_QWORD *)(a2 + 136);
        *(_OWORD *)(v8 + 15) = v14;
        *(_OWORD *)(v8 + 13) = v13;
        *(_OWORD *)(v8 + 11) = v12;
        a2 += 144;
        result += 18;
        v8 += 18;
      }
      while (a2 != a3);
    }
    v4[1] = result;
  }
  return result;
}

void sub_216612C10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

Phase::DspLayer::NullMixer *Phase::DspLayer::NullMixer::NullMixer(Phase::DspLayer::NullMixer *this, Phase::DspLayer::VoiceEngine *a2, int a3)
{
  Phase::DspLayer::VoicePool *v4;
  int v5;
  _QWORD *v6;

  v4 = Phase::DspLayer::VoicePool::VoicePool(this, "NullMixer", a2, a3, 32880);
  *(_QWORD *)v4 = &off_24D57EFA0;
  if (*((int *)v4 + 10) >= 1)
  {
    v5 = 0;
    do
    {
      v6 = (_QWORD *)(*((_QWORD *)this + 3) + *((int *)this + 4) * (uint64_t)v5);
      *v6 = &off_24D57EFC0;
      v6[1] = 0;
      bzero(v6 + 2, 0x8060uLL);
      ++v5;
    }
    while (v5 < *((_DWORD *)this + 10));
  }
  return this;
}

uint64_t *Phase::DspLayer::NullMixer::GetNewRegistryEntry(Phase::DspLayer::NullMixer *this)
{
  void *v1;
  uint64_t *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v6[2];
  char v7;
  void *__p[2];
  char v9;
  _QWORD v10[3];
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v1 = malloc_type_malloc(0, 0x1050040B063AAFAuLL);
  v2 = (uint64_t *)operator new();
  v10[0] = &off_24D57F098;
  v11 = v10;
  Phase::Controller::VoicePoolEntry::VoicePoolEntry((uint64_t)v2, "NullMixer", 0, (uint64_t)v1, (uint64_t)v10);
  v3 = v11;
  if (v11 == v10)
  {
    v4 = 4;
    v3 = v10;
  }
  else
  {
    if (!v11)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  std::string::basic_string[abi:ne180100]<0>(__p, "Input");
  Phase::Controller::VoicePoolEntry::AddInput(v2, (__int128 *)__p);
  if (v9 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(v6, "Output");
  Phase::Controller::VoicePoolEntry::AddOutput(v2, (__int128 *)v6);
  if (v7 < 0)
    operator delete(v6[0]);
  return v2;
}

void sub_216612DF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Phase::DspLayer::NullMixer::~NullMixer(Phase::DspLayer::NullMixer *this)
{
  Phase::DspLayer::VoicePool::~VoicePool(this);
  JUMPOUT(0x2199F9D70);
}

void `anonymous namespace'::NullMixerSlice::~NullMixerSlice(_anonymous_namespace_::NullMixerSlice *this)
{
  JUMPOUT(0x2199F9D70);
}

double `anonymous namespace'::NullMixerSlice::Reset(_OWORD *a1)
{
  double result;

  a1[1] = 0u;
  a1[1026] = 0u;
  (*(void (**)(_OWORD *))(*(_QWORD *)a1 + 48))(a1);
  result = 0.0;
  a1[2054] = 0u;
  a1[2053] = 0u;
  return result;
}

uint64_t `anonymous namespace'::NullMixerSlice::Reset(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t result;

  v7 = a1 + 4 * a3;
  *(_DWORD *)(v7 + 16) = 0;
  *(_DWORD *)(v7 + 16416) = 0;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  *(_QWORD *)(a1 + 8 * a3 + 32848) = a4;
  return result;
}

uint64_t `anonymous namespace'::NullMixerSlice::GetParameter(_anonymous_namespace_::NullMixerSlice *this)
{
  return 9;
}

uint64_t `anonymous namespace'::NullMixerSlice::SetParameter(_anonymous_namespace_::NullMixerSlice *this, double a2)
{
  return 9;
}

__n128 `anonymous namespace'::NullMixerSlice::UpdateParameters(__n128 *a1)
{
  __n128 result;
  __n128 v3;

  v3 = a1[1026];
  memcpy(&a1[1027], &a1[1], 0x4010uLL);
  result = v3;
  a1[2052] = v3;
  return result;
}

uint64_t `anonymous namespace'::NullMixerSlice::UpdateParameters(uint64_t result, uint64_t a2, int a3)
{
  unsigned int *v3;
  unsigned int v4;
  uint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  int v8;

  v3 = (unsigned int *)(result + 4 * a3);
  v4 = v3[4104];
  v5 = v3[4];
  v3[4108] = v5;
  if ((int)v5 >= 1)
  {
    v6 = (_DWORD *)(result + 4 * a3);
    v7 = v6 + 4116;
    do
    {
      v8 = v6[8];
      v6 += 8;
      *(v7 - 4) = v8;
      *v7 = v6[4];
      v7 += 8;
      --v5;
    }
    while (v5);
  }
  *(_DWORD *)(result + 4 * a3 + 32832) = v4;
  return result;
}

int8x16_t *`anonymous namespace'::NullMixerSlice::Run(int8x16_t *result, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int32x4_t v4;
  int64x2_t v5;
  uint64_t v6;
  float32x4_t *v7;
  float32x4_t v8;
  int32x4_t v9;
  int32x4_t v10;
  int8x16_t v11;
  unint64_t v12;
  int8x16_t v13;

  v4 = (int32x4_t)vandq_s8(result[1027], (int8x16_t)vcgtq_s32(vdupq_n_s32(a4), (int32x4_t)xmmword_2166F76B0));
  v5 = (int64x2_t)vcgtzq_s32(v4);
  if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0])
  {
    v6 = *(_QWORD *)(a2 + 56);
    v7 = (float32x4_t *)&result[1029];
    v8 = 0uLL;
    v9 = 0uLL;
    v10.i64[0] = 0x100000001;
    v10.i64[1] = 0x100000001;
    do
    {
      v11.i32[0] = *(_DWORD *)(v6 + 4 * v7[-1].i32[0]);
      v11.i32[1] = *(_DWORD *)(v6 + 4 * v7[-1].i32[1]);
      v11.i32[2] = *(_DWORD *)(v6 + 4 * v7[-1].i32[2]);
      v11.i32[3] = *(_DWORD *)(v6 + 4 * v7[-1].i32[3]);
      v8 = vmlaq_f32(v8, (float32x4_t)vandq_s8((int8x16_t)v5, v11), *v7);
      v9 = vaddq_s32(v9, v10);
      v5 = (int64x2_t)vcgtq_s32(v4, v9);
      v7 += 2;
    }
    while (vorrq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0]);
  }
  else
  {
    v8 = 0uLL;
  }
  HIDWORD(v12) = a4 - 1;
  LODWORD(v12) = a4 - 1;
  v13 = vandq_s8((int8x16_t)v8, vorrq_s8((int8x16_t)vcltzq_f32(v8), (int8x16_t)vcgezq_f32(v8)));
  switch((v12 >> 1))
  {
    case 0u:
      goto LABEL_10;
    case 1u:
      goto LABEL_9;
    case 3u:
      goto LABEL_8;
    case 7u:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * result[2052].i32[3]) = v13.i32[3];
LABEL_8:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * result[2052].i32[2]) = v13.i32[2];
LABEL_9:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * result[2052].i32[1]) = v13.i32[1];
LABEL_10:
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * result[2052].i32[0]) = v13.i32[0];
      break;
    default:
      return result;
  }
  return result;
}

uint64_t `anonymous namespace'::NullMixerSlice::CopyVoiceState(uint64_t this, Phase::DspLayer::VoicePoolSlice *a2, int a3, int a4)
{
  uint64_t v4;
  _DWORD *v5;
  int *v6;
  int v7;
  _DWORD *v8;
  _DWORD *v9;
  uint64_t v10;
  _DWORD *v11;
  int *v12;
  int v13;

  v4 = *((unsigned int *)a2 + a3 + 4);
  *(_DWORD *)(this + 4 * a4 + 16) = v4;
  if ((int)v4 >= 1)
  {
    v5 = (_DWORD *)(this + 4 * a4 + 48);
    v6 = (int *)((char *)a2 + 4 * a3 + 48);
    do
    {
      *(v5 - 4) = *(v6 - 4);
      v7 = *v6;
      v6 += 8;
      *v5 = v7;
      v5 += 8;
      --v4;
    }
    while (v4);
  }
  v8 = (_DWORD *)(this + 4 * a4);
  v9 = (_DWORD *)((char *)a2 + 4 * a3);
  v10 = v9[4108];
  v8[4108] = v10;
  if ((int)v10 >= 1)
  {
    v11 = v8 + 4116;
    v12 = v9 + 4116;
    do
    {
      *(v11 - 4) = *(v12 - 4);
      v13 = *v12;
      v12 += 8;
      *v11 = v13;
      v11 += 8;
      --v10;
    }
    while (v10);
  }
  v8[4104] = v9[4104];
  v8[8208] = v9[8208];
  *(_QWORD *)(this + 8 * a4 + 32848) = *((_QWORD *)a2 + a3 + 4106);
  return this;
}

uint64_t `anonymous namespace'::NullMixerSlice::AddInput(_anonymous_namespace_::NullMixerSlice *this, int a2, int a3, int a4, float a5)
{
  uint64_t result;
  char *v7;
  uint64_t v8;
  char *v9;

  if (a2)
    return 8;
  v7 = (char *)this + 16;
  v8 = *((int *)this + a3 + 4);
  if ((int)v8 > 511)
    return 6;
  result = 0;
  v9 = (char *)this + 32 * v8 + 4 * a3;
  *((_DWORD *)v9 + 8) = a4;
  *((float *)v9 + 12) = a5;
  *(_DWORD *)&v7[4 * a3] = v8 + 1;
  return result;
}

uint64_t `anonymous namespace'::NullMixerSlice::RemoveInput(_anonymous_namespace_::NullMixerSlice *this, int a2, int a3, int a4)
{
  uint64_t result;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *i;
  uint64_t v9;
  char *v10;

  if (a2)
    return 8;
  v5 = (char *)this + 16;
  v6 = *((unsigned int *)this + a3 + 4);
  if ((int)v6 < 1)
    return 7;
  v7 = 0;
  for (i = (_DWORD *)((char *)this + 4 * a3 + 32); *i != a4; i += 8)
  {
    if (v6 == ++v7)
      return 7;
  }
  if ((v7 & 0x80000000) != 0)
    return 7;
  v9 = (v6 - 1);
  if ((int)v9 > (int)v7)
  {
    v10 = (char *)this + 32 * v9 + 4 * a3;
    *i = *((_DWORD *)v10 + 8);
    i[4] = *((_DWORD *)v10 + 12);
  }
  result = 0;
  *(_DWORD *)&v5[4 * a3] = v9;
  return result;
}

uint64_t `anonymous namespace'::NullMixerSlice::SetInputGain(_anonymous_namespace_::NullMixerSlice *this, int a2, int a3, int a4, float a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  float *i;

  if (a2)
    return 8;
  v6 = *((unsigned int *)this + a3 + 4);
  if ((int)v6 < 1)
    return 7;
  v7 = 0;
  for (i = (float *)((char *)this + 4 * a3 + 48); *((_DWORD *)i - 4) != a4; i += 8)
  {
    if (v6 == ++v7)
      return 7;
  }
  if ((v7 & 0x80000000) != 0)
    return 7;
  result = 0;
  *i = a5;
  return result;
}

void `anonymous namespace'::NullMixerSlice::GetInputs(_anonymous_namespace_::NullMixerSlice *this@<X0>, int a2@<W1>, int a3@<W2>, char **a4@<X8>)
{
  char *v7;
  char *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  char *v14;
  char *v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;

  if (a2)
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
  }
  else
  {
    v7 = (char *)this + 4 * a3;
    v9 = *((int *)v7 + 4);
    v8 = v7 + 16;
    a4[1] = 0;
    a4[2] = 0;
    *a4 = 0;
    std::vector<std::pair<int,float>>::reserve((void **)a4, v9);
    v10 = v9;
    if ((int)v9 >= 1)
    {
      v11 = 0;
      v12 = a3;
      v13 = a4 + 2;
      v14 = a4[1];
      do
      {
        v15 = &v8[32 * v11 + 16];
        v16 = (_DWORD *)((char *)this + 32 * v11 + 4 * v12 + 48);
        if ((unint64_t)v14 >= *v13)
        {
          v17 = (v14 - *a4) >> 3;
          if ((unint64_t)(v17 + 1) >> 61)
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          v18 = *v13 - (_QWORD)*a4;
          v19 = v18 >> 2;
          if (v18 >> 2 <= (unint64_t)(v17 + 1))
            v19 = v17 + 1;
          if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
            v20 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v20 = v19;
          v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)(a4 + 2), v20);
          v23 = &v21[8 * v17];
          *(_DWORD *)v23 = *(_DWORD *)v15;
          *((_DWORD *)v23 + 1) = *v16;
          v25 = *a4;
          v24 = a4[1];
          v26 = v23;
          if (v24 != *a4)
          {
            do
            {
              v27 = *((_QWORD *)v24 - 1);
              v24 -= 8;
              *((_QWORD *)v26 - 1) = v27;
              v26 -= 8;
            }
            while (v24 != v25);
            v24 = *a4;
          }
          v14 = v23 + 8;
          *a4 = v26;
          a4[1] = v23 + 8;
          a4[2] = &v21[8 * v22];
          if (v24)
            operator delete(v24);
        }
        else
        {
          *(_DWORD *)v14 = *(_DWORD *)v15;
          *((_DWORD *)v14 + 1) = *v16;
          v14 += 8;
        }
        a4[1] = v14;
        ++v11;
      }
      while (v11 != v10);
    }
  }
}

void sub_21661347C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t `anonymous namespace'::NullMixerSlice::ClearInputs(_anonymous_namespace_::NullMixerSlice *this, int a2)
{
  *((_DWORD *)this + a2 + 4) = 0;
  return 0;
}

uint64_t `anonymous namespace'::NullMixerSlice::GetMaximumInputConnectionCount(_anonymous_namespace_::NullMixerSlice *this, int a2)
{
  return (a2 == 0) << 9;
}

unint64_t `anonymous namespace'::NullMixerSlice::GetOutput(_anonymous_namespace_::NullMixerSlice *this, int a2, int a3)
{
  if (a2)
    return 0xFFFFFFFF00000008;
  else
    return (unint64_t)*((unsigned int *)this + a3 + 4104) << 32;
}

uint64_t `anonymous namespace'::NullMixerSlice::SetOutput(_anonymous_namespace_::NullMixerSlice *this, int a2, int a3, int a4)
{
  uint64_t result;

  if (a2)
    return 8;
  result = 0;
  *((_DWORD *)this + a3 + 4104) = a4;
  return result;
}

void std::__function::__func<Phase::DspLayer::NullMixer::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::NullMixer::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::~__func()
{
  JUMPOUT(0x2199F9D70);
}

_QWORD *std::__function::__func<Phase::DspLayer::NullMixer::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::NullMixer::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24D57F098;
  return result;
}

void std::__function::__func<Phase::DspLayer::NullMixer::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::NullMixer::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24D57F098;
}

Phase::DspLayer::NullMixer *std::__function::__func<Phase::DspLayer::NullMixer::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::NullMixer::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::operator()(uint64_t a1, Phase::DspLayer::VoiceEngine **a2, int *a3)
{
  Phase::DspLayer::VoiceEngine *v3;
  int v4;
  Phase::DspLayer::NullMixer *v5;

  v3 = *a2;
  v4 = *a3;
  v5 = (Phase::DspLayer::NullMixer *)operator new();
  Phase::DspLayer::NullMixer::NullMixer(v5, v3, v4);
  return v5;
}

void sub_2166135B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2199F9D70](v1, 0x10F1C408EBD29CELL);
  _Unwind_Resume(a1);
}

uint64_t Phase::DspLayer::IConvolver::FilterState::Copy(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;

  v2 = *(int *)(a2 + 16);
  if ((_DWORD)v2 != *(_DWORD *)(a1 + 16))
    return 0;
  v5 = *(void **)(a1 + 8);
  if (!v5
    || (v6 = *(const void **)(a2 + 8)) == 0
    || (memcpy(v5, v6, 4 * v2), v7 = *(unsigned int *)(a1 + 16), (_DWORD)v7 != *(_DWORD *)(a1 + 20))
    && *(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 20))
  {
    v8 = *(int *)(a1 + 20);
    v9 = *(_DWORD *)(a2 + 20);
    if ((_DWORD)v8 == v9)
    {
      memcpy(*(void **)a1, *(const void **)a2, 4 * v8);
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
      return *(unsigned int *)(a1 + 20);
    }
    else
    {
      v10 = *(_DWORD *)(a2 + 24);
      if ((int)v8 >= v10)
        v11 = *(_DWORD *)(a2 + 24);
      else
        v11 = *(_DWORD *)(a1 + 20);
      v12 = v10 - v11;
      v13 = v9 - v10;
      v14 = v8 - v11;
      if (v14 >= v13)
        v15 = v13;
      else
        v15 = v14;
      v7 = (v15 + v11);
      memcpy(*(void **)a1, (const void *)(*(_QWORD *)a2 + 4 * (v9 - v15)), 4 * v15);
      memcpy((void *)(*(_QWORD *)a1 + 4 * v15), (const void *)(*(_QWORD *)a2 + 4 * v12), 4 * v11);
      *(_DWORD *)(a1 + 24) = (int)v7 % *(_DWORD *)(a1 + 20);
    }
  }
  return v7;
}

Phase::DspLayer::NUPReblockerIn *Phase::DspLayer::NUPReblockerIn::NUPReblockerIn(Phase::DspLayer::NUPReblockerIn *this, int a2)
{
  float *v4;

  v4 = (float *)malloc_type_malloc(4 * a2, 0x100004052888210uLL);
  *(_QWORD *)this = v4;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = a2;
  if (a2 <= 0)
    __assert_rtn("NUPReblockerIn", "NUPReblockerIn.cpp", 17, "n > 0");
  if (!v4)
    __assert_rtn("NUPReblockerIn", "NUPReblockerIn.cpp", 18, "mBuffer != nullptr");
  vDSP_vclr(v4, 1, a2);
  return this;
}

void *Phase::DspLayer::NUPReblockerIn::Copy(Phase::DspLayer::NUPReblockerIn *this, const void **a2)
{
  uint64_t v4;
  vDSP_Length v5;
  void *v6;
  void *result;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;

  v4 = *((int *)a2 + 3);
  v5 = *((int *)this + 3);
  v6 = *(void **)this;
  if ((_DWORD)v4 == (_DWORD)v5)
  {
    result = memcpy(v6, *a2, 4 * v4);
    v8 = *((_DWORD *)a2 + 2);
  }
  else
  {
    vDSP_vclr((float *)v6, 1, v5);
    v9 = *((_DWORD *)this + 3);
    v11 = *((_DWORD *)a2 + 2);
    v10 = *((_DWORD *)a2 + 3);
    if (v9 >= v11)
      v12 = *((_DWORD *)a2 + 2);
    else
      v12 = *((_DWORD *)this + 3);
    if ((int)(v9 - v12) >= v10 - v11)
      v13 = v10 - v11;
    else
      v13 = v9 - v12;
    if ((v12 & 0x80000000) != 0)
      __assert_rtn("Copy", "NUPReblockerIn.cpp", 64, "newFramesToCopy >= 0");
    if ((v13 & 0x80000000) != 0)
      __assert_rtn("Copy", "NUPReblockerIn.cpp", 65, "oldFramesToCopy >= 0");
    v14 = v11 - v12;
    if (((v11 - v12) & 0x80000000) != 0)
      __assert_rtn("Copy", "NUPReblockerIn.cpp", 66, "newFramesSrcOffset >= 0");
    v15 = v10 - v13;
    if ((v15 & 0x80000000) != 0)
      __assert_rtn("Copy", "NUPReblockerIn.cpp", 67, "oldFramesSrcOffset >= 0");
    if ((int)(v13 + v12) > v9)
      __assert_rtn("Copy", "NUPReblockerIn.cpp", 68, "totalFramesCopied <= mBufferLength");
    if (!*a2)
      __assert_rtn("Copy", "NUPReblockerIn.cpp", 73, "src != nullptr");
    if (!*(_QWORD *)this)
      __assert_rtn("Copy", "NUPReblockerIn.cpp", 74, "dest != nullptr");
    memcpy(*(void **)this, (char *)*a2 + 4 * v15, 4 * v13);
    if (!*a2)
      __assert_rtn("Copy", "NUPReblockerIn.cpp", 81, "src != nullptr");
    if (!*(_QWORD *)this)
      __assert_rtn("Copy", "NUPReblockerIn.cpp", 82, "dest != nullptr");
    result = memcpy((void *)(*(_QWORD *)this + 4 * v13), (char *)*a2 + 4 * v14, 4 * v12);
    v8 = (int)(v13 + v12) % *((_DWORD *)this + 3);
  }
  *((_DWORD *)this + 2) = v8;
  return result;
}

Phase::DspLayer::NUPReblockerOut *Phase::DspLayer::NUPReblockerOut::NUPReblockerOut(Phase::DspLayer::NUPReblockerOut *this, int a2)
{
  float *v4;

  v4 = (float *)malloc_type_malloc(4 * a2, 0x100004052888210uLL);
  *(_QWORD *)this = v4;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = a2;
  if (a2 <= 0)
    __assert_rtn("NUPReblockerOut", "NUPReblockerOut.cpp", 17, "n > 0");
  if (!v4)
    __assert_rtn("NUPReblockerOut", "NUPReblockerOut.cpp", 18, "mBuffer != nullptr");
  vDSP_vclr(v4, 1, a2);
  return this;
}

void Phase::DspLayer::NUPReblockerOut::addBlock(float **this, const float *__B, int a3)
{
  uint64_t v5;
  vDSP_Length v6;
  float *v7;
  int v8;
  const float *v9;
  vDSP_Length v10;

  v5 = *((int *)this + 2);
  v6 = *((int *)this + 3) - v5;
  v7 = &(*this)[v5];
  v8 = a3 - v6;
  if (a3 <= (int)v6)
  {
    v10 = a3;
    v9 = __B;
  }
  else
  {
    vDSP_vadd(v7, 1, __B, 1, v7, 1, v6);
    v7 = *this;
    v9 = &__B[v6];
    v10 = v8;
  }
  vDSP_vadd(v7, 1, v9, 1, v7, 1, v10);
}

uint64_t Phase::DspLayer::NUPSConvolver::NUPSConvolver(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v7;
  Phase::DspLayer::NUPReblockerOut *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int *v12;
  int v13;
  int v14;
  Phase::DspLayer::UPConvolver *v15;
  int v16;
  int v17;
  Phase::DspLayer::UPConvolver *v18;
  Phase::DspLayer::UPConvolver *v19;
  int v20;

  *(_QWORD *)a1 = &off_24D57F0E0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = a4;
  *(_QWORD *)(a1 + 24) = 0;
  Phase::DspLayer::NUPReblockerIn::NUPReblockerIn((Phase::DspLayer::NUPReblockerIn *)(a1 + 32), *(_DWORD *)(*(_QWORD *)(a2 + 8) - 4));
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((_QWORD *)(a1 + 56), *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
  *(_QWORD *)(a1 + 48) = malloc_type_malloc(8 * *(int *)(a1 + 8), 0x2004093837F09uLL);
  if (*(int *)(a1 + 8) >= 1)
  {
    v7 = 0;
    do
    {
      v8 = (Phase::DspLayer::NUPReblockerOut *)operator new();
      Phase::DspLayer::NUPReblockerOut::NUPReblockerOut(v8, *(_DWORD *)(*(_QWORD *)(a1 + 64) - 4));
      *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v7++) = v8;
    }
    while (v7 < *(int *)(a1 + 8));
  }
  v9 = *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 12) = v9 >> 2;
  *(_QWORD *)(a1 + 24) = malloc_type_malloc((uint64_t)(v9 << 30) >> 29, 0x2004093837F09uLL);
  if (*(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56) == 4)
  {
    v10 = 0;
  }
  else
  {
    v11 = 0;
    do
    {
      v12 = (int *)(*(_QWORD *)a2 + 4 * v11);
      v13 = *v12;
      v14 = v12[1];
      v15 = (Phase::DspLayer::UPConvolver *)operator new();
      v16 = v14 - v13;
      Phase::DspLayer::UPConvolver::UPConvolver(v15, v13, v16, *(_DWORD *)(a1 + 8));
      v10 = v11 + 1;
      *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v11) = v15;
      a3 -= v16;
      v11 = v10;
    }
    while (((uint64_t)(*(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56)) >> 2) - 1 > v10);
  }
  v17 = *(_DWORD *)(*(_QWORD *)a2 + 4 * v10);
  v18 = (Phase::DspLayer::UPConvolver *)operator new();
  v19 = v18;
  if (v17 <= a3)
    v20 = a3;
  else
    v20 = v17;
  Phase::DspLayer::UPConvolver::UPConvolver(v18, v17, v20, *(_DWORD *)(a1 + 8));
  *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v10) = v19;
  return a1;
}

void sub_216613CA8(_Unwind_Exception *a1)
{
  void **v1;
  uint64_t v2;
  void **v3;
  uint64_t v4;
  void *v6;

  MEMORY[0x2199F9D70](v4, 0x10E1C4077BC1CF2);
  v6 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v2 + 64) = v6;
    operator delete(v6);
  }
  free(*v1);
  _Unwind_Resume(a1);
}

void Phase::DspLayer::NUPSConvolver::~NUPSConvolver(Phase::DspLayer::NUPSConvolver *this)
{
  int v2;
  uint64_t i;
  uint64_t v4;
  int v5;
  uint64_t j;
  void **v7;
  void *v8;

  *(_QWORD *)this = &off_24D57F0E0;
  v2 = *((_DWORD *)this + 3);
  if (v2 >= 1)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = *(_QWORD *)(*((_QWORD *)this + 3) + 8 * i);
      if (v4)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
        v2 = *((_DWORD *)this + 3);
      }
    }
  }
  v5 = *((_DWORD *)this + 2);
  if (v5 >= 1)
  {
    for (j = 0; j < v5; ++j)
    {
      v7 = *(void ***)(*((_QWORD *)this + 6) + 8 * j);
      if (v7)
      {
        free(*v7);
        MEMORY[0x2199F9D70](v7, 0x1080C40FC6463CFLL);
        v5 = *((_DWORD *)this + 2);
      }
    }
  }
  free(*((void **)this + 3));
  free(*((void **)this + 6));
  v8 = (void *)*((_QWORD *)this + 7);
  if (v8)
  {
    *((_QWORD *)this + 8) = v8;
    operator delete(v8);
  }
  free(*((void **)this + 4));
}

{
  Phase::DspLayer::NUPSConvolver::~NUPSConvolver(this);
  JUMPOUT(0x2199F9D70);
}

uint64_t Phase::DspLayer::NUPSConvolver::GetBlockSize(Phase::DspLayer::NUPSConvolver *this)
{
  return (*(uint64_t (**)(_QWORD))(***((_QWORD ***)this + 3) + 56))(**((_QWORD **)this + 3));
}

uint64_t Phase::DspLayer::NUPSConvolver::GetFilterLength(Phase::DspLayer::NUPSConvolver *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (*((int *)this + 4) < 1)
    return 0;
  v2 = 0;
  LODWORD(v3) = 0;
  do
  {
    v4 = *(_QWORD *)(*((_QWORD *)this + 3) + 8 * v2);
    v3 = (*(unsigned int (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4) + v3;
    ++v2;
  }
  while (v2 < *((int *)this + 4));
  return v3;
}

uint64_t Phase::DspLayer::NUPSConvolver::GetMaxFilterLength(Phase::DspLayer::NUPSConvolver *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (*((int *)this + 3) < 1)
    return 0;
  v2 = 0;
  LODWORD(v3) = 0;
  do
  {
    v4 = *(_QWORD *)(*((_QWORD *)this + 3) + 8 * v2);
    v3 = (*(unsigned int (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4) + v3;
    ++v2;
  }
  while (v2 < *((int *)this + 3));
  return v3;
}

uint64_t Phase::DspLayer::NUPSConvolver::GetNumOutputChannels(Phase::DspLayer::NUPSConvolver *this)
{
  return *((unsigned int *)this + 2);
}

uint64_t Phase::DspLayer::NUPSConvolver::Reset(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (*(int *)(this + 16) >= 1)
  {
    v1 = this;
    v2 = 0;
    do
    {
      v3 = *(_QWORD *)(*(_QWORD *)(v1 + 24) + 8 * v2);
      this = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 32))(v3);
      ++v2;
    }
    while (v2 < *(int *)(v1 + 16));
  }
  return this;
}

uint64_t Phase::DspLayer::NUPSConvolver::SetFilter(Phase::DspLayer::NUPSConvolver *this, uint64_t a2, float *a3, int a4)
{
  uint64_t result;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if ((a2 & 0x80000000) != 0)
    return 2;
  if (*((_DWORD *)this + 2) <= (int)a2)
    return 2;
  if (a4 < 1 || (*(int (**)(Phase::DspLayer::NUPSConvolver *))(*(_QWORD *)this + 48))(this) < a4)
    return 1;
  *((_DWORD *)this + 4) = 0;
  if (*((int *)this + 3) < 2)
  {
    v10 = 0;
    v9 = 0;
  }
  else
  {
    v9 = 0;
    v10 = 0;
    do
    {
      v11 = *(_QWORD *)(*((_QWORD *)this + 3) + 8 * v9);
      v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 48))(v11);
      v13 = v12;
      if (a4 - v10 >= v12)
        v14 = v12;
      else
        v14 = (a4 - v10);
      v15 = *(_QWORD *)(*((_QWORD *)this + 3) + 8 * v9);
      (*(void (**)(uint64_t, uint64_t, float *, uint64_t))(*(_QWORD *)v15 + 16))(v15, a2, &a3[v10], v14);
      v10 += v13;
      v16 = *((int *)this + 3);
      ++*((_DWORD *)this + 4);
      ++v9;
    }
    while (v9 < v16 - 1 && v10 < a4);
    if (v10 >= a4)
      return 0;
  }
  v17 = *(_QWORD *)(*((_QWORD *)this + 3) + 8 * v9);
  (*(void (**)(uint64_t, uint64_t, float *, _QWORD))(*(_QWORD *)v17 + 16))(v17, a2, &a3[v10], (a4 - v10));
  result = 0;
  ++*((_DWORD *)this + 4);
  return result;
}

void Phase::DspLayer::NUPSConvolver::Process(Phase::DspLayer::NUPSConvolver *this, float *a2, float **a3)
{
  int v6;
  vDSP_Length v7;
  size_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  const float *v16;
  size_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  size_t v37;
  uint64_t v38;
  const float **v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  const float *v52;
  const float *v53;
  const float *v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v6 = (*(uint64_t (**)(_QWORD))(***((_QWORD ***)this + 3) + 56))(**((_QWORD **)this + 3));
  v7 = v6;
  v8 = 4 * v6;
  memcpy((void *)(*((_QWORD *)this + 4) + 4 * *((int *)this + 10)), a2, v8);
  v9 = *((_DWORD *)this + 11);
  v10 = *((_DWORD *)this + 10) + v6;
  if (v10 < v9)
    v9 = 0;
  *((_DWORD *)this + 10) = v10 - v9;
  v11 = *(_QWORD *)(*((_QWORD *)this + 3) + 8 * *((int *)this + 4) - 8);
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 56))(v11);
  v13 = v12;
  v14 = *((_DWORD *)this + 2);
  MEMORY[0x24BDAC7A8](v12);
  v16 = (const float *)((char *)&v52 - v15);
  bzero((char *)&v52 - v15, v17);
  v52 = v16;
  if (v14 == 2)
  {
    v53 = v16;
    v54 = &v16[v13];
    if (*((int *)this + 4) >= 1)
    {
      v27 = 0;
      do
      {
        v28 = *(_QWORD *)(*((_QWORD *)this + 3) + 8 * v27);
        v29 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 56))(v28);
        v30 = *((_DWORD *)this + 10);
        if (v30 % v29)
          break;
        v31 = v29;
        v32 = v30 - v29;
        if (v32 < 0)
          v32 += *((_DWORD *)this + 11);
        v33 = *(_QWORD *)(*((_QWORD *)this + 3) + 8 * v27);
        (*(void (**)(uint64_t, uint64_t, const float **))(*(_QWORD *)v33 + 24))(v33, *((_QWORD *)this + 4) + 4 * v32, &v53);
        Phase::DspLayer::NUPReblockerOut::addBlock(**((float ****)this + 6), v53, v31);
        Phase::DspLayer::NUPReblockerOut::addBlock(*(float ***)(*((_QWORD *)this + 6) + 8), v54, v31);
        ++v27;
      }
      while (v27 < *((int *)this + 4));
    }
    memcpy(*a3, (const void *)(***((_QWORD ***)this + 6) + 4 * *(int *)(**((_QWORD **)this + 6) + 8)), v8);
    memcpy(a3[1], (const void *)(**(_QWORD **)(*((_QWORD *)this + 6) + 8)+ 4 * *(int *)(*(_QWORD *)(*((_QWORD *)this + 6) + 8) + 8)), v8);
    v34 = **((_QWORD **)this + 6);
    vDSP_vclr((float *)(*(_QWORD *)v34 + 4 * *(int *)(v34 + 8)), 1, v7);
    *(_DWORD *)(v34 + 8) = (*(_DWORD *)(v34 + 12) - 1) & (*(_DWORD *)(v34 + 8) + v7);
    v26 = *(_QWORD *)(*((_QWORD *)this + 6) + 8);
    goto LABEL_19;
  }
  if (v14 == 1)
  {
    if (*((int *)this + 4) >= 1)
    {
      v19 = 0;
      do
      {
        v20 = *(_QWORD *)(*((_QWORD *)this + 3) + 8 * v19);
        v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 56))(v20);
        v22 = *((_DWORD *)this + 10);
        if (v22 % v21)
          break;
        v23 = v21;
        v24 = v22 - v21;
        if (v24 < 0)
          v24 += *((_DWORD *)this + 11);
        v25 = *(_QWORD *)(*((_QWORD *)this + 3) + 8 * v19);
        (*(void (**)(uint64_t, uint64_t, const float **))(*(_QWORD *)v25 + 24))(v25, *((_QWORD *)this + 4) + 4 * v24, &v52);
        Phase::DspLayer::NUPReblockerOut::addBlock(**((float ****)this + 6), v52, v23);
        ++v19;
      }
      while (v19 < *((int *)this + 4));
    }
    memcpy(*a3, (const void *)(***((_QWORD ***)this + 6) + 4 * *(int *)(**((_QWORD **)this + 6) + 8)), v8);
    v26 = **((_QWORD **)this + 6);
LABEL_19:
    vDSP_vclr((float *)(*(_QWORD *)v26 + 4 * *(int *)(v26 + 8)), 1, v7);
    *(_DWORD *)(v26 + 8) = (*(_DWORD *)(v26 + 12) - 1) & (*(_DWORD *)(v26 + 8) + v7);
    return;
  }
  MEMORY[0x24BDAC7A8](v18);
  v36 = (char *)&v52 - ((v35 + 15) & 0xFFFFFFFF0);
  if (v35 >= 0x200)
    v37 = 512;
  else
    v37 = v35;
  bzero((char *)&v52 - ((v35 + 15) & 0xFFFFFFFF0), v37);
  LODWORD(v38) = *((_DWORD *)this + 2);
  if ((int)v38 >= 1)
  {
    v39 = (const float **)v36;
    v40 = *((unsigned int *)this + 2);
    do
    {
      *v39++ = v16;
      v16 += v13;
      --v40;
    }
    while (v40);
  }
  if (*((int *)this + 4) >= 1)
  {
    v41 = 0;
    while (1)
    {
      v42 = *(_QWORD *)(*((_QWORD *)this + 3) + 8 * v41);
      v43 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v42 + 56))(v42);
      v44 = *((_DWORD *)this + 10);
      if (v44 % v43)
        break;
      v45 = v43;
      v46 = v44 - v43;
      if (v46 < 0)
        v46 += *((_DWORD *)this + 11);
      v47 = *(_QWORD *)(*((_QWORD *)this + 3) + 8 * v41);
      (*(void (**)(uint64_t, uint64_t, char *))(*(_QWORD *)v47 + 24))(v47, *((_QWORD *)this + 4) + 4 * v46, v36);
      LODWORD(v38) = *((_DWORD *)this + 2);
      if ((int)v38 >= 1)
      {
        v48 = 0;
        do
        {
          Phase::DspLayer::NUPReblockerOut::addBlock(*(float ***)(*((_QWORD *)this + 6) + 8 * v48), *(const float **)&v36[8 * v48], v45);
          ++v48;
          v38 = *((int *)this + 2);
        }
        while (v48 < v38);
      }
      if (++v41 >= *((int *)this + 4))
        goto LABEL_38;
    }
    LODWORD(v38) = *((_DWORD *)this + 2);
  }
LABEL_38:
  if ((int)v38 >= 1)
  {
    v49 = 0;
    do
    {
      v50 = *(_QWORD *)(*((_QWORD *)this + 6) + 8 * v49);
      memcpy(a3[v49], (const void *)(*(_QWORD *)v50 + 4 * *(int *)(v50 + 8)), v8);
      v51 = *(_QWORD *)(*((_QWORD *)this + 6) + 8 * v49);
      vDSP_vclr((float *)(*(_QWORD *)v51 + 4 * *(int *)(v51 + 8)), 1, v7);
      *(_DWORD *)(v51 + 8) = (*(_DWORD *)(v51 + 12) - 1) & (*(_DWORD *)(v51 + 8) + v7);
      ++v49;
    }
    while (v49 < *((int *)this + 2));
  }
}

void Phase::DspLayer::NUPSConvolver::GetFilterState(Phase::DspLayer::NUPSConvolver *this)
{
  __assert_rtn("GetFilterState", "NUPSConvolver.cpp", 262, "false");
}

uint64_t Phase::DspLayer::NUPSConvolver::GetNumPartitions(Phase::DspLayer::NUPSConvolver *this)
{
  return *((unsigned int *)this + 4);
}

uint64_t Phase::DspLayer::NUPSConvolver::GetPartition(Phase::DspLayer::NUPSConvolver *this, int a2)
{
  if (*((_DWORD *)this + 4) >= a2)
    return *(_QWORD *)(*((_QWORD *)this + 3) + 8 * a2);
  else
    return 0;
}

uint64_t Phase::DspLayer::NUPSConvolver::GetReblockerIn(Phase::DspLayer::NUPSConvolver *this)
{
  return (uint64_t)this + 32;
}

uint64_t Phase::DspLayer::NUPSConvolver::CopyStates(Phase::DspLayer::NUPSConvolver *this, Phase::DspLayer::IConvolver *a2)
{
  const void **v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;

  v4 = (const void **)(*(uint64_t (**)(Phase::DspLayer::IConvolver *))(*(_QWORD *)a2 + 96))(a2);
  if (v4)
    Phase::DspLayer::NUPReblockerIn::Copy((Phase::DspLayer::NUPSConvolver *)((char *)this + 32), v4);
  v5 = (*(uint64_t (**)(Phase::DspLayer::IConvolver *))(*(_QWORD *)a2 + 72))(a2);
  v6 = (*(uint64_t (**)(Phase::DspLayer::NUPSConvolver *))(*(_QWORD *)this + 72))(this);
  if (v6 >= v5)
    v7 = v5;
  else
    v7 = v6;
  if (v7 < 1)
    return 0;
  v8 = 0;
  v9 = 0;
  do
  {
    v10 = (*(uint64_t (**)(Phase::DspLayer::IConvolver *, uint64_t))(*(_QWORD *)a2 + 80))(a2, v8);
    v11 = (*(uint64_t (**)(Phase::DspLayer::NUPSConvolver *, uint64_t))(*(_QWORD *)this + 80))(this, v8);
    if (v11)
      v12 = v10 == 0;
    else
      v12 = 1;
    if (!v12)
    {
      v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 88))(v11);
      v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 88))(v10);
      v9 = Phase::DspLayer::IConvolver::FilterState::Copy(v13, v14) + v9;
    }
    v8 = (v8 + 1);
  }
  while (v7 != (_DWORD)v8);
  return v9;
}

uint64_t Phase::ParserSetParseError(uint64_t a1, uint64_t a2, char *__src, const char *a4, const char *a5, ...)
{
  char *v8;
  va_list va;

  va_start(va, a5);
  *(_QWORD *)a1 = a2;
  v8 = (char *)(a1 + 136);
  strncpy((char *)(a1 + 8), __src, 0x80uLL);
  strncpy(v8, a4, 0x80uLL);
  return vsnprintf((char *)(a1 + 264), 0x100uLL, a5, va);
}

uint64_t Phase::BuildActionTree(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  id v8;
  id v9;
  unsigned int v10;
  unsigned __int8 *v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  void *v17;
  unsigned __int8 *v18;
  id v19;
  __CFString *v20;
  NSString *v21;
  id v22;
  __CFString *v23;
  __CFString *v24;
  void *v25;
  int DistanceModelType;
  BOOL v27;
  id v28;
  id v29;
  _DWORD *v30;
  BOOL v31;
  id v32;
  __CFString *v33;
  void *v34;
  id v35;
  uint64_t v36;
  uint64_t v37;
  _DWORD *v38;
  uint64_t m;
  void *v40;
  int v41;
  __CFString *v42;
  __CFString *v43;
  char v44;
  id v45;
  void *v46;
  uint64_t v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  _QWORD *v52;
  id v53;
  __CFString *v54;
  void *v55;
  int SpatialCategory;
  char OptionalChildDictionary;
  id v58;
  uint64_t v59;
  int *v60;
  uint64_t v61;
  Phase *v62;
  int v63;
  NSString *v64;
  _QWORD *v65;
  NSString *v66;
  Phase *v67;
  _QWORD *v68;
  char *v69;
  char *v70;
  char *v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  char *v75;
  char *v76;
  char *v77;
  char OptionalChildArray;
  id v79;
  void *v80;
  uint64_t v81;
  unsigned int v82;
  uint64_t v83;
  uint64_t i;
  void *v85;
  int v86;
  __CFString *v87;
  __CFString *v88;
  __CFString *v89;
  __CFString *v90;
  const char *v91;
  __CFString *v92;
  char *v93;
  const char *v94;
  const char *v95;
  void *v96;
  __CFString *v97;
  __CFString *v98;
  __CFString *v99;
  __CFString *v100;
  __CFString *v101;
  __CFString *v102;
  const char *v103;
  __CFString *v104;
  void *v105;
  char v106;
  id v107;
  id v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t j;
  void *v112;
  void *v113;
  void *v114;
  void *v115;
  BOOL v116;
  id v117;
  uint64_t v118;
  uint64_t v119;
  void *v120;
  void *v121;
  Phase *v122;
  NSString *v123;
  int NodeType;
  void *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  void *v129;
  id v130;
  id v131;
  id v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t k;
  int v136;
  id v137;
  id v138;
  Phase::Logger *v139;
  NSObject *v140;
  int v141;
  void *v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  int *v155;
  unint64_t v156;
  _DWORD *v157;
  int v158;
  uint64_t v159;
  id v160;
  uint64_t v161;
  uint64_t v162;
  void *v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  Phase *v167;
  Phase *v168;
  uint64_t v169;
  uint64_t v170;
  char *v171;
  void *v172;
  id v173;
  id v174;
  void *v175;
  id v176;
  id v177;
  id v178;
  uint64_t v179;
  char *v180;
  id v181;
  uint64_t v182;
  id obj;
  id obja;
  id v185;
  id v186;
  id v187;
  uint64_t v188;
  void *v189;
  id v190;
  id v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  id v196;
  id v197;
  _OWORD v198[2];
  int v199;
  id v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  char v209;
  _BYTE v210[7];
  uint64_t v211;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  __int128 v215;
  __int128 v216;
  __int128 v217;
  __int128 v218;
  __int128 v219;
  __int128 v220;
  __int128 v221;
  __int128 v222;
  __int128 v223;
  __int128 v224;
  __int128 v225;
  __int128 v226;
  __int128 v227;
  char *v228;
  char v229;
  __int128 v230;
  __int128 v231;
  __int128 v232;
  __int128 v233;
  __int128 v234;
  __int128 v235;
  __int128 v236;
  __int128 v237;
  uint8_t buf[32];
  __int128 v239;
  __int128 v240;
  _QWORD __src[743];
  char v242[128];
  _BYTE v243[128];
  void *v244[2];
  char v245;
  uint64_t v246;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v188 = v4;
  v6 = v5;
  v7 = v1;
  v246 = *MEMORY[0x24BDAC8D0];
  v9 = v8;
  v187 = v3;
  v189 = v9;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    Phase::ParserSetParseError(v7, 1346924643, "<ActionTreeStruct>", "", "Actiontree object must be a structure");
    v14 = 0;
    goto LABEL_265;
  }
  v182 = v6;
  v226 = 0u;
  v227 = 0u;
  v224 = 0u;
  v225 = 0u;
  v222 = 0u;
  v223 = 0u;
  v220 = 0u;
  v221 = 0u;
  v228 = 0;
  v219 = 0u;
  v218 = 0u;
  v217 = 0u;
  v216 = 0u;
  v215 = 0u;
  v214 = 0u;
  v213 = 0u;
  v212 = 0u;
  v229 = 1;
  if ((Phase::ReadString(v7, v9, CFSTR("Name"), (uint64_t)&v209, 0x80uLL, v188) & 1) == 0)
    goto LABEL_263;
  v10 = v209;
  if (v209)
  {
    v11 = v210;
    v12 = 0xCBF29CE484222325;
    do
    {
      v12 = 0x100000001B3 * (v12 ^ v10);
      v13 = *v11++;
      v10 = v13;
    }
    while (v13);
  }
  else
  {
    v12 = 0;
  }
  v211 = v12;
  objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("Submixes"));
  v185 = (id)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    Phase::ParserSetParseError(v7, 1346924643, "", (const char *)objc_msgSend(CFSTR("Submixes"), "UTF8String"), "Submix array object must be an array");

    goto LABEL_263;
  }
  memset(v198, 0, sizeof(v198));
  v199 = 1065353216;
  v201 = 0u;
  v202 = 0u;
  v203 = 0u;
  v204 = 0u;
  obj = v185;
  v15 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v201, v243, 16);
  if (!v15)
  {
    v86 = 1;
    goto LABEL_178;
  }
  v179 = *(_QWORD *)v202;
LABEL_12:
  v16 = 0;
  v171 = (char *)v15;
  while (2)
  {
    if (*(_QWORD *)v202 != v179)
      objc_enumerationMutation(obj);
    v180 = v16;
    v17 = *(void **)(*((_QWORD *)&v201 + 1) + 8 * (_QWORD)v16);
    bzero(__src, 0x1738uLL);
    if ((Phase::ReadString(v7, v17, CFSTR("Name"), (uint64_t)v242, 0x80uLL, 0) & 1) == 0)
    {
      *(_OWORD *)(v7 + 72) = xmmword_216739539;
      *(_OWORD *)(v7 + 88) = unk_216739549;
      *(_OWORD *)(v7 + 104) = xmmword_216739559;
      *(_OWORD *)(v7 + 120) = unk_216739569;
      *(_OWORD *)(v7 + 8) = *(_OWORD *)"<SubmixStruct>";
      *(_OWORD *)(v7 + 24) = unk_216739509;
      *(_OWORD *)(v7 + 40) = xmmword_216739519;
      *(_OWORD *)(v7 + 56) = unk_216739529;
      goto LABEL_177;
    }
    std::string::basic_string[abi:ne180100]<0>(v244, v242);
    v18 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(v198, (unsigned __int8 *)v244);
    if (v245 < 0)
      operator delete(v244[0]);
    if (v18)
    {
      Phase::ParserSetParseError(v7, 1346924646, &v209, v242, "Mixer array contains multiple mixers named the same thing");
      goto LABEL_177;
    }
    std::string::basic_string[abi:ne180100]<0>(v244, v242);
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>((uint64_t)v198, (unsigned __int8 *)v244, (uint64_t)v244);
    if (v245 < 0)
      operator delete(v244[0]);
    if ((Phase::ReadPhaseId(v7, v17, CFSTR("Name"), __src, v188) & 1) == 0)
      goto LABEL_145;
    v19 = v17;
    v20 = CFSTR("Type");
    objc_msgSend(v19, "objectForKeyedSubscript:", CFSTR("Type"));
    v21 = (NSString *)objc_claimAutoreleasedReturnValue();
    if (!v21)
    {
      v88 = objc_retainAutorelease(CFSTR("Type"));
      Phase::ParserSetParseError(v7, 1346924642, "", (const char *)objc_msgSend(CFSTR("Type"), "UTF8String"), "");
      goto LABEL_144;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      v89 = objc_retainAutorelease(CFSTR("Type"));
      Phase::ParserSetParseError(v7, 1346924643, "", (const char *)objc_msgSend(CFSTR("Type"), "UTF8String"), "Field should be a string");
      goto LABEL_144;
    }
    __src[1] = GetMixerType(v21);
    if (!__src[1])
    {
      v90 = objc_retainAutorelease(CFSTR("Type"));
      v91 = (const char *)objc_msgSend(CFSTR("Type"), "UTF8String");
      v92 = objc_retainAutorelease(CFSTR("Type"));
      objc_msgSend(CFSTR("Type"), "UTF8String");
      -[NSString UTF8String](objc_retainAutorelease(v21), "UTF8String");
      Phase::ParserSetParseError(v7, 1346924643, "", v91, "Field is bad %s - %s");
LABEL_144:

LABEL_145:
      strncpy((char *)(v7 + 8), v242, 0x80uLL);
      goto LABEL_177;
    }

    if ((Phase::ReadFloatTypeWithDefault<double>(v7, v19, CFSTR("Gain"), (double *)&__src[2], 1.0, 0.0, 1.0) & 1) == 0
      || (Phase::ReadParamIdx(v7, v19, CFSTR("GainParameterName"), (Phase *)&v209, (_BYTE *)&__src[3] + 2, v188) & 1) == 0)
    {
      goto LABEL_145;
    }
    LOWORD(__src[3]) = 0;
    switch(__src[1])
    {
      case 0:
        goto LABEL_177;
      case 1:
        v22 = v19;
        memset(&__src[4], 0, 416);
        v23 = (__CFString *)v22;
        v24 = CFSTR("DistanceModelType");
        -[__CFString objectForKeyedSubscript:](v23, "objectForKeyedSubscript:", CFSTR("DistanceModelType"));
        v25 = (void *)objc_claimAutoreleasedReturnValue();
        if (!v25)
        {
          LOBYTE(__src[4]) = 0;
          v42 = CFSTR("DistanceModelType");
          v43 = v23;
          goto LABEL_50;
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          v97 = objc_retainAutorelease(CFSTR("DistanceModelType"));
          Phase::ParserSetParseError(v7, 1346924643, "", (const char *)objc_msgSend(CFSTR("DistanceModelType"), "UTF8String"), "Field should be a string");

          goto LABEL_163;
        }
        DistanceModelType = GetDistanceModelType((NSString *)v25);
        LOBYTE(__src[4]) = DistanceModelType;

        if (DistanceModelType != 2)
        {
          if (DistanceModelType != 1
            || (Phase::ReadFloatTypeWithDefault<double>(v7, v23, CFSTR("RolloffFactor"), (double *)&__src[5], 1.0, 0.0, 1.79769313e308) & 1) != 0)
          {
            goto LABEL_51;
          }
          goto LABEL_163;
        }
        LODWORD(__src[6]) = 0;
        v200 = 0;
        OptionalChildArray = Phase::GetOptionalChildArray(v7, v23, CFSTR("EnvelopeSegments"), &v200);
        v79 = v200;
        v80 = v79;
        if ((OptionalChildArray & 1) == 0)
        {
          Phase::ParserSetParseError(v7, 1346924643, v242, (const char *)objc_msgSend(CFSTR("EnvelopeSegments"), "UTF8String"), "Submix envelope segment array object must be an array");

          goto LABEL_164;
        }
        v207 = 0u;
        v208 = 0u;
        v205 = 0u;
        v206 = 0u;
        v42 = (__CFString *)v79;
        v81 = -[__CFString countByEnumeratingWithState:objects:count:](v42, "countByEnumeratingWithState:objects:count:", &v205, v244, 16);
        if (!v81)
          goto LABEL_132;
        v82 = 0;
        v83 = *(_QWORD *)v206;
        do
        {
          for (i = 0; i != v81; ++i)
          {
            if (*(_QWORD *)v206 != v83)
              objc_enumerationMutation(v42);
            v85 = *(void **)(*((_QWORD *)&v205 + 1) + 8 * i);
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0)
            {
              Phase::ParserSetParseError(v7, 1346924643, v242, (const char *)objc_msgSend(CFSTR("EnvelopeSegments"), "UTF8String"), "Submix envelope segment object must be a dictionary");
              goto LABEL_160;
            }
            if (v82 >= 0x11)
            {
              Phase::ParserSetParseError(v7, 1346924646, v242, (const char *)objc_msgSend(CFSTR("EnvelopeSegments"), "UTF8String"), "Too many submix envelope segments.  Max = %d");
LABEL_160:

LABEL_164:
              goto LABEL_177;
            }
            if ((Phase::ReadFloatTypeWithDefault<double>(v7, v85, CFSTR("Distance"), (double *)&__src[3 * v82 + 7], 1.79769313e308, 0.0, 1.79769313e308) & 1) == 0|| (Phase::ReadFloatTypeWithDefault<double>(v7, v85, CFSTR("Gain"), (double *)&__src[3 * v82 + 8], 1.0, 0.0, 1.0) & 1) == 0|| (Phase::ReadEnumWithDefault<PHASECurveType>(v7, v85, &__src[3 * v82 + 9]) & 1) == 0)
            {
              strncpy((char *)(v7 + 8), v242, 0x80uLL);
              goto LABEL_160;
            }
            v82 = ++LODWORD(__src[6]);
          }
          v81 = -[__CFString countByEnumeratingWithState:objects:count:](v42, "countByEnumeratingWithState:objects:count:", &v205, v244, 16);
        }
        while (v81);
LABEL_132:
        v43 = v42;
LABEL_50:

LABEL_51:
        if ((Phase::ReadFloatTypeWithDefault<double>(v7, v23, CFSTR("FadeOutCullDistance"), (double *)&__src[55], 1.79769313e308, 1.0, 1.79769313e308) & 1) == 0)
        {
LABEL_163:
          strncpy((char *)(v7 + 8), v242, 0x80uLL);
          goto LABEL_164;
        }

        if (!Phase::ParseDirectivityModelParams(v7, v23, v242, (double *)&__src[56], 1)
          || !Phase::ParseDirectivityModelParams(v7, v23, v242, (double *)&__src[182], 0))
        {
          goto LABEL_177;
        }
        if ((Phase::ReadFloatTypeWithDefault<double>(v7, v23, CFSTR("ListenerDopplerFactor"), (double *)&__src[308], 1.0, 0.0, 1.79769313e308) & 1) == 0|| (Phase::ReadFloatTypeWithDefault<double>(v7, v23, CFSTR("SourceDopplerFactor"), (double *)&__src[309], 1.0, 0.0, 1.79769313e308) & 1) == 0)
        {
          goto LABEL_145;
        }
        LODWORD(__src[310]) = 0;
        HIDWORD(__src[318]) = 0;
        v197 = 0;
        v44 = Phase::GetOptionalChildArray(v7, v23, CFSTR("SpatialCategories"), &v197);
        v45 = v197;
        v46 = v45;
        if ((v44 & 1) == 0)
        {
          Phase::ParserSetParseError(v7, 1346924643, v242, (const char *)objc_msgSend(CFSTR("SpatialCategories"), "UTF8String"), "Submix spatial categories object must be an array");

          goto LABEL_177;
        }
        v240 = 0u;
        v239 = 0u;
        memset(buf, 0, sizeof(buf));
        v177 = v45;
        v47 = objc_msgSend(v177, "countByEnumeratingWithState:objects:count:", buf, &v234, 16);
        if (!v47)
        {
LABEL_96:

          goto LABEL_100;
        }
        v48 = 0;
        v49 = **(_QWORD **)&buf[16];
        v161 = **(_QWORD **)&buf[16];
LABEL_59:
        v50 = 0;
        v162 = v47;
        while (1)
        {
          if (**(_QWORD **)&buf[16] != v49)
            objc_enumerationMutation(v177);
          v51 = *(void **)(*(_QWORD *)&buf[8] + 8 * v50);
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0)
          {
            Phase::ParserSetParseError(v7, 1346924643, v242, (const char *)objc_msgSend(CFSTR("SpatialCategories"), "UTF8String"), "Submix spatial categories object must be a dictionary");
            goto LABEL_176;
          }
          if (v48 >= 9)
          {
            Phase::ParserSetParseError(v7, 1346924646, v242, (const char *)objc_msgSend(CFSTR("SpatialCategories"), "UTF8String"), "Too many spatial categories. Max = %d");
            goto LABEL_176;
          }
          if ((Phase::ReadString(v7, v51, CFSTR("Category"), (uint64_t)v244, 0x80uLL, 0) & 1) == 0)
          {
            strncpy((char *)(v7 + 8), v242, 0x80uLL);
            *(_OWORD *)(v7 + 200) = xmmword_2167395BA;
            *(_OWORD *)(v7 + 216) = unk_2167395CA;
            *(_OWORD *)(v7 + 232) = xmmword_2167395DA;
            *(_OWORD *)(v7 + 248) = unk_2167395EA;
            strcpy((char *)(v7 + 136), "<SpatialCategoryStruct>");
            *(_QWORD *)(v7 + 160) = unk_216739592;
            *(_OWORD *)(v7 + 168) = xmmword_21673959A;
            *(_OWORD *)(v7 + 184) = unk_2167395AA;
            goto LABEL_176;
          }
          v164 = v50;
          v52 = &__src[53 * v48];
          *((_DWORD *)v52 + 647) = 0;
          v53 = v51;
          v54 = CFSTR("Category");
          objc_msgSend(v53, "objectForKeyedSubscript:", CFSTR("Category"));
          v55 = (void *)objc_claimAutoreleasedReturnValue();
          if (!v55)
          {
            v100 = objc_retainAutorelease(CFSTR("Category"));
            Phase::ParserSetParseError(v7, 1346924642, "", (const char *)objc_msgSend(CFSTR("Category"), "UTF8String"), "");
LABEL_174:

LABEL_175:
            strncpy((char *)(v7 + 8), v242, 0x80uLL);
            goto LABEL_176;
          }
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0)
          {
            v101 = objc_retainAutorelease(CFSTR("Category"));
            Phase::ParserSetParseError(v7, 1346924643, "", (const char *)objc_msgSend(CFSTR("Category"), "UTF8String"), "Field should be a string");
            goto LABEL_174;
          }
          SpatialCategory = GetSpatialCategory((NSString *)v55);
          *((_DWORD *)v52 + 638) = SpatialCategory;
          if (!SpatialCategory)
          {
            v102 = objc_retainAutorelease(CFSTR("Category"));
            v103 = (const char *)objc_msgSend(CFSTR("Category"), "UTF8String");
            v104 = objc_retainAutorelease(CFSTR("Category"));
            objc_msgSend(CFSTR("Category"), "UTF8String");
            objc_msgSend(objc_retainAutorelease(v55), "UTF8String");
            Phase::ParserSetParseError(v7, 1346924643, "", v103, "Field is bad %s - %s");
            goto LABEL_174;
          }

          if ((Phase::ReadFloatTypeWithDefault<double>(v7, v53, CFSTR("Send"), (double *)&__src[53 * v48 + 320], 1.0, 0.0, 1.0) & 1) == 0|| (Phase::ReadFloatTypeWithDefault<double>(v7, v53, CFSTR("SendHF"), (double *)&__src[53 * v48 + 321], 1.0, 0.0, 1.0) & 1) == 0|| (Phase::ReadFloatTypeWithDefault<double>(v7, v53, CFSTR("SendLF"),
                  (double *)&__src[53 * v48 + 322],
                  1.0,
                  0.0,
                  1.0) & 1) == 0
            || (Phase::ReadParamIdx(v7, v53, CFSTR("SendParameterName"), (Phase *)&v209, &__src[53 * v48 + 323], v188) & 1) == 0
            || (Phase::ReadParamIdx(v7, v53, CFSTR("SendHFParameterName"), (Phase *)&v209, (_BYTE *)&__src[53 * v48 + 323] + 1, v188) & 1) == 0|| (Phase::ReadParamIdx(v7, v53, CFSTR("SendLFParameterName"), (Phase *)&v209, (_BYTE *)&__src[53 * v48 + 323] + 2, v188) & 1) == 0)
          {
            goto LABEL_175;
          }
          v196 = 0;
          OptionalChildDictionary = Phase::GetOptionalChildDictionary(v7, v53, CFSTR("TweakParams"), &v196);
          v58 = v196;
          v163 = v58;
          if ((OptionalChildDictionary & 1) == 0)
          {
            Phase::ParserSetParseError(v7, 1346924643, v242, (const char *)v244, "Submix category tweak param object must be a dictionary");
            goto LABEL_157;
          }
          v194 = 0u;
          v195 = 0u;
          v192 = 0u;
          v193 = 0u;
          v174 = v58;
          v59 = objc_msgSend(v174, "countByEnumeratingWithState:objects:count:", &v192, &v230, 16);
          if (v59)
            break;
LABEL_94:

          v48 = ++HIDWORD(__src[318]);
          v50 = v164 + 1;
          v49 = v161;
          if (v164 + 1 == v162)
          {
            v47 = objc_msgSend(v177, "countByEnumeratingWithState:objects:count:", buf, &v234, 16);
            if (!v47)
              goto LABEL_96;
            goto LABEL_59;
          }
        }
        v60 = (int *)v52 + 647;
        v166 = *(_QWORD *)v193;
        while (2)
        {
          v61 = 0;
LABEL_78:
          if (*(_QWORD *)v193 != v166)
            objc_enumerationMutation(v174);
          v62 = *(Phase **)(*((_QWORD *)&v192 + 1) + 8 * v61);
          v63 = *v60;
          if (v188 && (Phase::AddStringToPool(v7, v188, *(void **)(*((_QWORD *)&v192 + 1) + 8 * v61)) & 1) == 0)
          {
LABEL_151:
            v94 = (const char *)-[Phase UTF8String](objc_retainAutorelease(v62), "UTF8String");
            v93 = (char *)(v7 + 8);
LABEL_152:
            strncpy(v93, v94, 0x80uLL);
            goto LABEL_156;
          }
          v65 = &__src[53 * v48 + 324 + 3 * v63];
          if (!-[Phase hasPrefix:](v62, "hasPrefix:", CFSTR("metaparam_")))
          {
            if (v188 && (Phase::AddStringToPool(v7, v188, v62) & 1) == 0)
              goto LABEL_151;
            *v65 = Phase::GetStringHashId(v62, v64);
            if ((Phase::ReadFloatTypeWithDefault<double>(v7, v174, v62, (double *)&__src[53 * v48 + 325 + 3 * v63], 1.0, -INFINITY, INFINITY) & 1) == 0)
            {
              v93 = (char *)(v7 + 8);
              v94 = v242;
              goto LABEL_152;
            }
            LOBYTE(__src[53 * v48 + 326 + 3 * v63]) = -1;
            goto LABEL_92;
          }
          -[Phase substringFromIndex:](v62, "substringFromIndex:", objc_msgSend(CFSTR("metaparam_"), "length"));
          v67 = (Phase *)objc_claimAutoreleasedReturnValue();
          if (!v188)
            goto LABEL_86;
          if ((Phase::AddStringToPool(v7, v188, v62) & 1) == 0)
            goto LABEL_154;
          if ((Phase::AddStringToPool(v7, v188, v67) & 1) != 0)
          {
LABEL_86:
            *v65 = Phase::GetStringHashId(v67, v66);
            v68 = &__src[53 * v48 + 3 * v63];
            v68[325] = 0;
            if (!Phase::ReadParamIdx(v7, v174, v62, (Phase *)&v209, (_BYTE *)v68 + 2608, v188))
            {
              v95 = v242;
              goto LABEL_155;
            }

LABEL_92:
            ++*v60;
            if (v59 == ++v61)
            {
              v59 = objc_msgSend(v174, "countByEnumeratingWithState:objects:count:", &v192, &v230, 16);
              if (!v59)
                goto LABEL_94;
              continue;
            }
            goto LABEL_78;
          }
          break;
        }
        v62 = v67;
LABEL_154:
        v95 = (const char *)-[Phase UTF8String](objc_retainAutorelease(v62), "UTF8String");
LABEL_155:
        strncpy((char *)(v7 + 8), v95, 0x80uLL);

LABEL_156:
LABEL_157:

LABEL_176:
LABEL_177:
        v86 = 0;
LABEL_178:

        std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v198);
        if (!v86)
          goto LABEL_263;
        objc_msgSend(v189, "objectForKeyedSubscript:", CFSTR("Parameters"));
        v105 = (void *)objc_claimAutoreleasedReturnValue();
        v106 = Phase::BuildParameters(v7, v105, (char **)&v218, v188);

        if ((v106 & 1) == 0)
          goto LABEL_263;
        objc_msgSend(v189, "objectForKeyedSubscript:", CFSTR("Nodes"));
        v107 = (id)objc_claimAutoreleasedReturnValue();
        v108 = v187;
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          Phase::ParserSetParseError(v7, 1346924643, &v209, (const char *)objc_msgSend(CFSTR("Nodes"), "UTF8String"), "Field should be an array");

          goto LABEL_263;
        }
        v178 = v108;
        v186 = objc_alloc_init(MEMORY[0x24BDBCED8]);
        obja = objc_alloc_init(MEMORY[0x24BDBCEF0]);
        v237 = 0u;
        v236 = 0u;
        v235 = 0u;
        v234 = 0u;
        v181 = v107;
        v109 = objc_msgSend(v181, "countByEnumeratingWithState:objects:count:", &v234, __src, 16);
        if (!v109)
          goto LABEL_194;
        v110 = *(_QWORD *)v235;
        do
        {
          for (j = 0; j != v109; ++j)
          {
            if (*(_QWORD *)v235 != v110)
              objc_enumerationMutation(v181);
            v112 = *(void **)(*((_QWORD *)&v234 + 1) + 8 * j);
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0)
            {
              Phase::ParserSetParseError(v7, 1346924643, &v209, (const char *)objc_msgSend(CFSTR("Nodes"), "UTF8String"), "Member of array is not a structure");
              goto LABEL_237;
            }
            objc_msgSend(v112, "objectForKeyedSubscript:", CFSTR("Name"));
            v113 = (void *)objc_claimAutoreleasedReturnValue();
            if (!v113 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
            {
              Phase::ParserSetParseError(v7, 1346924646, &v209, (const char *)objc_msgSend(CFSTR("Name"), "UTF8String"), "Node has a missing or bad node name");

LABEL_237:
              v136 = 0;
              v132 = v181;
              goto LABEL_251;
            }
            objc_msgSend(v112, "objectForKeyedSubscript:", CFSTR("Type"));
            v114 = (void *)objc_claimAutoreleasedReturnValue();
            if (!v114 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
            {
              Phase::ParserSetParseError(v7, 1346924646, &v209, (const char *)objc_msgSend(objc_retainAutorelease(v113), "UTF8String"), "Node has a missing or bad type");
LABEL_236:

              goto LABEL_237;
            }
            objc_msgSend(v186, "objectForKey:", v113);
            v115 = (void *)objc_claimAutoreleasedReturnValue();
            v116 = v115 == 0;

            if (!v116)
            {
              Phase::ParserSetParseError(v7, 1346924646, &v209, (const char *)objc_msgSend(objc_retainAutorelease(v113), "UTF8String"), "Node array contains multiple nodes named the same thing");
              goto LABEL_236;
            }
            objc_msgSend(v186, "setObject:forKeyedSubscript:", v112, v113);
            objc_msgSend(obja, "addObject:", v113);

          }
          v109 = objc_msgSend(v181, "countByEnumeratingWithState:objects:count:", &v234, __src, 16);
        }
        while (v109);
LABEL_194:

        v232 = 0u;
        v233 = 0u;
        v230 = 0u;
        v231 = 0u;
        v117 = v181;
        v172 = v117;
        v118 = objc_msgSend(v117, "countByEnumeratingWithState:objects:count:", &v230, v244, 16);
        if (!v118)
        {
LABEL_222:

          Phase::MsgBuffer::Init((Phase::MsgBuffer *)((char *)&v219 + 8));
          v203 = 0u;
          v204 = 0u;
          v201 = 0u;
          v202 = 0u;
          v132 = obja;
          v133 = objc_msgSend(v132, "countByEnumeratingWithState:objects:count:", &v201, v242, 16);
          if (v133)
          {
            v134 = *(_QWORD *)v202;
            while (2)
            {
              for (k = 0; k != v133; ++k)
              {
                if (*(_QWORD *)v202 != v134)
                  objc_enumerationMutation(v132);
                if ((Phase::TraverseNode(v7, *(void **)(*((_QWORD *)&v201 + 1) + 8 * k), v186, (_QWORD *)&v219 + 1, (Phase *)&v209, v188, v178, 1) & 1) == 0)
                {
                  v136 = 0;
                  goto LABEL_251;
                }
              }
              v133 = objc_msgSend(v132, "countByEnumeratingWithState:objects:count:", &v201, v242, 16);
              v136 = 1;
              if (v133)
                continue;
              break;
            }
          }
          else
          {
            v136 = 1;
          }
          goto LABEL_251;
        }
        v169 = *(_QWORD *)v231;
LABEL_196:
        v119 = 0;
        v165 = v118;
LABEL_197:
        if (*(_QWORD *)v231 != v169)
          objc_enumerationMutation(v117);
        v170 = v119;
        v120 = *(void **)(*((_QWORD *)&v230 + 1) + 8 * v119);
        objc_msgSend(v120, "objectForKeyedSubscript:", CFSTR("Name"));
        v121 = (void *)objc_claimAutoreleasedReturnValue();
        v175 = v121;
        if (!v121 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
        {
          Phase::ParserSetParseError(v7, 1346924646, &v209, (const char *)objc_msgSend(CFSTR("Name"), "UTF8String"), "Node has a missing or bad node name");

          goto LABEL_250;
        }
        objc_msgSend(v120, "objectForKeyedSubscript:", CFSTR("Type"));
        v122 = (Phase *)objc_claimAutoreleasedReturnValue();
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          NodeType = Phase::GetNodeType(v122, v123);
          objc_msgSend(v120, "objectForKeyedSubscript:", CFSTR("Children"));
          v125 = (void *)objc_claimAutoreleasedReturnValue();
          if (!v125)
            goto LABEL_220;
          v167 = v122;
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0)
          {
            objc_msgSend(v120, "objectForKeyedSubscript:", CFSTR("Name"));
            v160 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            Phase::ParserSetParseError(v7, 1346924643, (char *)objc_msgSend(v160, "UTF8String"), (const char *)objc_msgSend(CFSTR("Children"), "UTF8String"), "Children field must be an array");

            goto LABEL_250;
          }
          v207 = 0u;
          v208 = 0u;
          v205 = 0u;
          v206 = 0u;
          v176 = v125;
          v126 = objc_msgSend(v176, "countByEnumeratingWithState:objects:count:", &v205, v243, 16);
          if (!v126)
            goto LABEL_219;
          v127 = *(_QWORD *)v206;
LABEL_206:
          v128 = 0;
          while (1)
          {
            if (*(_QWORD *)v206 != v127)
              objc_enumerationMutation(v176);
            v129 = *(void **)(*((_QWORD *)&v205 + 1) + 8 * v128);
            if ((NodeType - 2) >= 3)
            {
              if (NodeType != 5)
                break;
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) == 0)
              {
                objc_msgSend(v120, "objectForKeyedSubscript:", CFSTR("Name"));
                v131 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                Phase::ParserSetParseError(v7, 1346924643, (char *)objc_msgSend(v131, "UTF8String"), (const char *)objc_msgSend(CFSTR("Children"), "UTF8String"), "Child list must be an array of strings");
                goto LABEL_249;
              }
              v130 = v129;
            }
            else
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) == 0)
              {
                objc_msgSend(v120, "objectForKeyedSubscript:", CFSTR("Name"));
                v131 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                Phase::ParserSetParseError(v7, 1346924643, (char *)objc_msgSend(v131, "UTF8String"), (const char *)objc_msgSend(CFSTR("Children"), "UTF8String"), "Child object must be a struct");
                goto LABEL_249;
              }
              objc_msgSend(v129, "objectForKeyedSubscript:", CFSTR("SubTreeNodeName"));
              v130 = (id)objc_claimAutoreleasedReturnValue();
            }
            v131 = v130;
            if (!v130)
              break;
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0)
            {
              objc_msgSend(v120, "objectForKeyedSubscript:", CFSTR("Name"));
              v137 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
              Phase::ParserSetParseError(v7, 1346924646, (char *)objc_msgSend(v137, "UTF8String"), "", "SubtreeNodeName is not a valid string");

              goto LABEL_249;
            }
            objc_msgSend(obja, "removeObject:", v131);

            if (v126 == ++v128)
            {
              v126 = objc_msgSend(v176, "countByEnumeratingWithState:objects:count:", &v205, v243, 16);
              if (v126)
                goto LABEL_206;
LABEL_219:

              v122 = v167;
LABEL_220:

              v117 = v172;
              v119 = v170 + 1;
              if (v170 + 1 == v165)
              {
                v118 = objc_msgSend(v172, "countByEnumeratingWithState:objects:count:", &v230, v244, 16);
                if (!v118)
                  goto LABEL_222;
                goto LABEL_196;
              }
              goto LABEL_197;
            }
          }
          objc_msgSend(v120, "objectForKeyedSubscript:", CFSTR("Name"));
          v131 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          Phase::ParserSetParseError(v7, 1346924641, (char *)objc_msgSend(v131, "UTF8String"), "", "SubtreeNodeName was not found");
LABEL_249:

          goto LABEL_250;
        }
        v168 = v122;
        v138 = objc_retainAutorelease(v121);
        v139 = (Phase::Logger *)Phase::ParserSetParseError(v7, 1346924643, &v209, (const char *)objc_msgSend(v138, "UTF8String"), "NodeType is not a valid string");
        v140 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstancePtr(v139) + 16));
        if (os_log_type_enabled(v140, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "ParserCore.mm";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 2116;
          _os_log_impl(&dword_2164CC000, v140, OS_LOG_TYPE_ERROR, "%25s:%-5d NodeType is not a valid string", buf, 0x12u);
        }

LABEL_250:
        v136 = 0;
        v132 = v172;
LABEL_251:

        if (!v136)
        {
LABEL_263:
          v14 = 0;
          goto LABEL_264;
        }
        v141 = DWORD2(v220);
        *(_QWORD *)v182 = v211;
        *(_DWORD *)(v182 + 80) = v141;
        v142 = (void *)operator new[]();
        v143 = *(_QWORD *)(v182 + 88);
        *(_QWORD *)(v182 + 88) = v142;
        if (v143)
        {
          MEMORY[0x2199F9D4C](v143, 0x1000C8077774924);
          v142 = *(void **)(v182 + 88);
        }
        memcpy(v142, *((const void **)&v219 + 1), *((size_t *)&v220 + 1));
        v144 = *((_QWORD *)&v227 + 1);
        if (*((_QWORD *)&v227 + 1) == (_QWORD)v227)
        {
          v151 = *(_QWORD *)(v182 + 104);
          *(_QWORD *)(v182 + 104) = 0;
          if (v151)
          {
            MEMORY[0x2199F9D4C](v151, 0x1000C809937E4EELL);
            v147 = *((_QWORD *)&v227 + 1);
            v144 = v227;
          }
          else
          {
            v147 = v144;
          }
        }
        else
        {
          is_mul_ok(0x74CD59ED64F3F0D7 * ((uint64_t)(*((_QWORD *)&v227 + 1) - v227) >> 3), 0x1738uLL);
          v145 = operator new[]();
          v146 = *(_QWORD *)(v182 + 104);
          *(_QWORD *)(v182 + 104) = v145;
          if (v146)
            MEMORY[0x2199F9D4C](v146, 0x1000C809937E4EELL);
          v147 = *((_QWORD *)&v227 + 1);
          v144 = v227;
          if (*((_QWORD *)&v227 + 1) == (_QWORD)v227)
          {
            v144 = *((_QWORD *)&v227 + 1);
          }
          else
          {
            v148 = 0;
            if ((unint64_t)(0x74CD59ED64F3F0D7 * ((uint64_t)(*((_QWORD *)&v227 + 1) - v227) >> 3)) <= 1)
              v149 = 1;
            else
              v149 = 0x74CD59ED64F3F0D7 * ((uint64_t)(*((_QWORD *)&v227 + 1) - v227) >> 3);
            do
            {
              memcpy((void *)(*(_QWORD *)(v182 + 104) + v148), (const void *)(v144 + v148), 0x1738uLL);
              v148 += 5944;
              --v149;
            }
            while (v149);
          }
        }
        *(_DWORD *)(v182 + 96) = 1693708503 * ((unint64_t)(v147 - v144) >> 3);
        Phase::BuildObjArray<Phase::MetaParameter>((uint64_t *)&v218, (uint64_t *)(v182 + 72));
        *(_DWORD *)(v182 + 64) = 1332920885 * ((*((_QWORD *)&v218 + 1) - (_QWORD)v218) >> 4);
        Phase::BuildObjArray<unsigned long long>((uint64_t)&v212, (uint64_t *)(v182 + 16));
        *(_DWORD *)(v182 + 8) = (*((_QWORD *)&v212 + 1) - (_QWORD)v212) >> 3;
        Phase::BuildObjArray<unsigned long long>((uint64_t)&v213 + 8, (uint64_t *)(v182 + 32));
        *(_DWORD *)(v182 + 24) = ((_QWORD)v214 - *((_QWORD *)&v213 + 1)) >> 3;
        Phase::BuildObjArray<unsigned long long>((uint64_t)&v215, (uint64_t *)(v182 + 48));
        v152 = v182;
        *(_DWORD *)(v182 + 40) = (*((_QWORD *)&v215 + 1) - (_QWORD)v215) >> 3;
        if ((_QWORD)v217 == *((_QWORD *)&v216 + 1))
        {
          v159 = *(_QWORD *)(v182 + 56);
          *(_QWORD *)(v182 + 56) = 0;
          if (v159)
            MEMORY[0x2199F9D4C](v159, 0x1000C8052888210);
        }
        else
        {
          v153 = operator new[]();
          v152 = v182;
          v154 = *(_QWORD *)(v182 + 56);
          *(_QWORD *)(v182 + 56) = v153;
          if (v154)
            MEMORY[0x2199F9D4C](v154, 0x1000C8052888210);
          v155 = (int *)*((_QWORD *)&v216 + 1);
          if ((_QWORD)v217 != *((_QWORD *)&v216 + 1))
          {
            v156 = (uint64_t)(v217 - *((_QWORD *)&v216 + 1)) >> 2;
            v157 = *(_DWORD **)(v182 + 56);
            if (v156 <= 1)
              v156 = 1;
            do
            {
              v158 = *v155++;
              *v157++ = v158;
              --v156;
            }
            while (v156);
          }
        }
        *(_BYTE *)(v152 + 112) = v229;
        v14 = 1;
LABEL_264:
        Phase::ActionTreeBuilder::~ActionTreeBuilder((Phase::ActionTreeBuilder *)&v209);
LABEL_265:

        return v14;
      case 2:
        v190 = 0;
        v31 = Phase::ReadAVAudioChannelLayout(v7, v19, &v190);
        v177 = v190;
        if (!v31)
          goto LABEL_138;
        v32 = v19;
        v33 = CFSTR("Orientation");
        objc_msgSend(v32, "objectForKeyedSubscript:", CFSTR("Orientation"));
        v34 = (void *)objc_claimAutoreleasedReturnValue();
        if (!v34)
        {
          *(_OWORD *)((char *)&__src[4] + 4) = xmmword_2166F7280;

          goto LABEL_98;
        }
        v173 = v32;
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          v98 = objc_retainAutorelease(CFSTR("Orientation"));
          Phase::ParserSetParseError(v7, 1346924643, "", (const char *)objc_msgSend(CFSTR("Orientation"), "UTF8String"), "Field should be a quaternion (4 float array).");
LABEL_167:

          goto LABEL_138;
        }
        if (objc_msgSend(v34, "count") != 4)
        {
          v99 = objc_retainAutorelease(CFSTR("Orientation"));
          Phase::ParserSetParseError(v7, 1346924646, "", (const char *)objc_msgSend(CFSTR("Orientation"), "UTF8String"), "Invalid quaternion size");
          goto LABEL_167;
        }
        v207 = 0u;
        v208 = 0u;
        v205 = 0u;
        v206 = 0u;
        v35 = v34;
        v36 = objc_msgSend(v35, "countByEnumeratingWithState:objects:count:", &v205, v244, 16);
        if (!v36)
          goto LABEL_48;
        v37 = *(_QWORD *)v206;
        v38 = (_DWORD *)&__src[4] + 1;
        do
        {
          for (m = 0; m != v36; ++m)
          {
            if (*(_QWORD *)v206 != v37)
              objc_enumerationMutation(v35);
            v40 = *(void **)(*((_QWORD *)&v205 + 1) + 8 * m);
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0)
            {
              v87 = objc_retainAutorelease(CFSTR("Orientation"));
              Phase::ParserSetParseError(v7, 1346924646, "", (const char *)objc_msgSend(CFSTR("Orientation"), "UTF8String"), "Invalid quaternion coefficient type");

LABEL_138:
              strncpy((char *)(v7 + 8), v242, 0x80uLL);

              goto LABEL_177;
            }
            objc_msgSend(v40, "floatValue");
            *v38++ = v41;
          }
          v36 = objc_msgSend(v35, "countByEnumeratingWithState:objects:count:", &v205, v244, 16);
        }
        while (v36);
LABEL_48:

LABEL_98:
        v30 = (_DWORD *)objc_msgSend(v177, "layout");
LABEL_99:
        LODWORD(__src[4]) = *v30;
LABEL_100:

LABEL_101:
        v69 = (char *)*((_QWORD *)&v227 + 1);
        if (*((_QWORD *)&v227 + 1) >= (unint64_t)v228)
        {
          v71 = (char *)v227;
          v72 = 0x74CD59ED64F3F0D7 * ((uint64_t)(*((_QWORD *)&v227 + 1) - v227) >> 3);
          v73 = v72 + 1;
          if ((unint64_t)(v72 + 1) > 0xB068BE30ED0CBLL)
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          if (0xE99AB3DAC9E7E1AELL * ((uint64_t)&v228[-v227] >> 3) > v73)
            v73 = 0xE99AB3DAC9E7E1AELL * ((uint64_t)&v228[-v227] >> 3);
          if ((unint64_t)(0x74CD59ED64F3F0D7 * ((uint64_t)&v228[-v227] >> 3)) >= 0x58345F1876865)
            v74 = 0xB068BE30ED0CBLL;
          else
            v74 = v73;
          if (v74)
          {
            if (v74 > 0xB068BE30ED0CBLL)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v75 = (char *)operator new(5944 * v74);
          }
          else
          {
            v75 = 0;
          }
          v76 = &v75[5944 * v72];
          memcpy(v76, __src, 0x1738uLL);
          v77 = v76;
          while (v69 != v71)
          {
            v69 -= 5944;
            v77 -= 5944;
            memcpy(v77, v69, 0x1738uLL);
          }
          v70 = v76 + 5944;
          *(_QWORD *)&v227 = v77;
          *((_QWORD *)&v227 + 1) = v76 + 5944;
          v228 = &v75[5944 * v74];
          if (v71)
            operator delete(v71);
        }
        else
        {
          memcpy(*((void **)&v227 + 1), __src, 0x1738uLL);
          v70 = v69 + 5944;
        }
        *((_QWORD *)&v227 + 1) = v70;
        v16 = v180 + 1;
        if (v180 + 1 != v171)
          continue;
        v15 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v201, v243, 16);
        v86 = 1;
        if (!v15)
          goto LABEL_178;
        goto LABEL_12;
      case 3:
        v191 = 0;
        v27 = Phase::ReadAVAudioChannelLayout(v7, v19, &v191);
        v28 = v191;
        if (!v27)
        {
          v96 = v28;
          strncpy((char *)(v7 + 8), v242, 0x80uLL);

          goto LABEL_177;
        }
        v29 = v28;
        v30 = (_DWORD *)objc_msgSend(v28, "layout");
        v177 = v29;
        goto LABEL_99;
      default:
        goto LABEL_101;
    }
  }
}

