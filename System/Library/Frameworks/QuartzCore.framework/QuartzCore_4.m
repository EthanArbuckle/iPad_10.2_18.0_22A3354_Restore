const void **X::CFRef<__CFData const*>::operator=(const void **a1, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = *a1;
  if (v3 != cf)
  {
    if (v3)
      CFRelease(v3);
    *a1 = cf;
    CFRetain(cf);
  }
  return a1;
}

void X::small_vector_base<unsigned int>::push_back(uint64_t a1, _DWORD *a2)
{
  _DWORD *v4;
  unint64_t v5;

  v4 = *(_DWORD **)(a1 + 8);
  v5 = (((uint64_t)v4 - *(_QWORD *)a1) >> 2) + 1;
  if (*(_QWORD *)(a1 + 24) < v5)
  {
    X::small_vector_base<unsigned int>::grow((int **)a1, v5);
    v4 = *(_DWORD **)(a1 + 8);
  }
  *v4 = *a2;
  *(_QWORD *)(a1 + 8) = v4 + 1;
}

void X::small_vector_base<unsigned int>::grow(int **a1, unint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _DWORD *v11;
  int *v12;
  int *v13;
  _DWORD *v14;
  int *v15;
  int v16;

  v3 = *a1;
  v4 = a1[1];
  v5 = a1[2];
  v6 = ((unint64_t)a1[3] + 1) | (((unint64_t)a1[3] + 1) >> 1);
  v7 = v6 | (v6 >> 2) | ((v6 | (v6 >> 2)) >> 4);
  v8 = v7 | (v7 >> 8) | ((v7 | (v7 >> 8)) >> 16);
  v9 = v8 | HIDWORD(v8);
  if (v9 + 1 > a2)
    v10 = v9 + 1;
  else
    v10 = a2;
  v11 = malloc_type_malloc(4 * v10, 0x100004052888210uLL);
  v12 = *a1;
  v13 = a1[1];
  if (*a1 != v13)
  {
    v14 = v11;
    v15 = *a1;
    do
    {
      v16 = *v15++;
      *v14++ = v16;
    }
    while (v15 != v13);
  }
  if (v3 != v5)
    free(v12);
  *a1 = v11;
  a1[1] = (_DWORD *)((char *)v11 + (char *)v4 - (char *)v3);
  a1[3] = (int *)v10;
}

void CA::Render::Updater::UnionRectOp::~UnionRectOp(CA::Render::Updater::UnionRectOp *this)
{
  JUMPOUT(0x186DBD990);
}

__n128 CA::Render::Updater::UnionRectOp::copy(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  __n128 result;

  v3 = x_heap_malloc_small_(a2, 0x38uLL);
  if (v3)
  {
    *(_WORD *)(v3 + 16) = 1;
    *(_BYTE *)(v3 + 18) = 0;
    *(_QWORD *)v3 = &off_1E15992A8;
  }
  *(_OWORD *)(v3 + 24) = *(_OWORD *)(a1 + 24);
  result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v3 + 40) = result;
  return result;
}

void CA::Render::Updater::UnionRectOp::map_bounds(CA::Render::Updater::UnionRectOp *this, CA::Render::Updater::LayerShapes *a2, const CA::Bounds *a3)
{
  float64x2_t v3;
  float64x2_t v4;
  int64x2_t v5;
  int64x2_t v6;
  int32x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  int8x16_t v12;
  int8x16_t v13;
  float64x2_t v14;
  int32x4_t v15;
  int32x4_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v3 = *((float64x2_t *)a2 + 1);
  v4 = *(float64x2_t *)((char *)this + 40);
  v5 = vclezq_f64(v3);
  v6 = vclezq_f64(v4);
  v7 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64(v6, v5), (int8x16_t)vzip2q_s64(v6, v5))));
  if ((v7.i8[4] & 1) != 0)
  {
    if ((v7.i8[0] & 1) != 0)
      goto LABEL_7;
    v8 = *(float64x2_t *)((char *)this + 24);
  }
  else
  {
    if ((v7.i8[0] & 1) != 0)
      goto LABEL_7;
    v9 = *(float64x2_t *)((char *)this + 24);
    v10 = vaddq_f64(*(float64x2_t *)a2, v3);
    v8 = vminnmq_f64(*(float64x2_t *)a2, v9);
    v4 = vsubq_f64(vmaxnmq_f64(v10, vaddq_f64(v9, v4)), v8);
  }
  *(float64x2_t *)a2 = v8;
  *((float64x2_t *)a2 + 1) = v4;
LABEL_7:
  if (*((_QWORD *)a2 + 8))
  {
    v11 = *(float64x2_t *)((char *)this + 40);
    v12 = (int8x16_t)vceqzq_f64(v11);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v12, 1), v12).u64[0] & 0x8000000000000000) != 0
      || (v13 = vorrq_s8((int8x16_t)vcltzq_f64(v11), (int8x16_t)vcgezq_f64(v11)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v13), 1), v13).u64[0] & 0x8000000000000000) != 0))
    {
      v16 = 0uLL;
    }
    else
    {
      v14 = *(float64x2_t *)((char *)this + 24);
      v15 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v14, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      v16 = vuzp1q_s32(v15, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v14, v11), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v15));
    }
    CA::shape_union((CA::Shape **)a2 + 8, (CA::Shape **)&v16, a3);
  }
}

void CA::Render::Update::invalidate(CA::Shape **this, const CA::Bounds *a2)
{
  const CA::Shape *v3;
  _OWORD v4[3];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  memset(v4, 0, sizeof(v4));
  CA::Shape::operator=((uint64_t)v4, a2);
  CA::shape_union(this + 2, (CA::Shape **)v4, v3);
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(unint64_t a1)
{
  if (a1 >> 62)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(4 * a1);
}

void CA::Render::Update::print_trees(CA::Render::Update *this)
{
  const CA::Render::Object *v2;
  NSObject *v3;
  const char *v4;
  char *v5;
  uint64_t i;
  char *v7;
  int v8;
  uint64_t v9;
  char *v10;
  int v11;
  unsigned int v12;
  int v14;
  NSObject *v15;
  const char *v16;
  void **v17;
  uint64_t v18;
  uint64_t v19;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  _BYTE v25[10];
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v18 = 0;
  v19 = 0;
  CA::Shape::get_bounds(*((_QWORD *)this + 2), (int *)&v18);
  x_log_begin();
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v3 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      v4 = (const char *)*((_QWORD *)this + 9);
      *(_DWORD *)buf = 134219008;
      v21 = v4;
      v22 = 1024;
      v23 = v18;
      v24 = 1024;
      *(_DWORD *)v25 = HIDWORD(v18);
      *(_WORD *)&v25[4] = 1024;
      *(_DWORD *)&v25[6] = v19;
      v26 = 1024;
      v27 = HIDWORD(v19);
      _os_log_impl(&dword_184457000, v3, OS_LOG_TYPE_DEFAULT, "\n** Render tree at time %f (bounds %d,%d %dx%d) **\n\n", buf, 0x24u);
    }
  }
  v5 = (char *)this + 216;
  for (i = *((_QWORD *)this + 28); (char *)i != v5; i = *(_QWORD *)(i + 8))
    CA::Render::show_object(*(CA::Render **)(i + 32), v2);
  v17 = (void **)x_stream_pop_(0);
  v7 = x_stream_get(v17);
  v8 = 0;
  while (2)
  {
    v9 = 0;
    v10 = &v7[v8];
    v11 = -1;
    while (1)
    {
      if (v10[v9] == 10)
      {
        v11 = v9;
        goto LABEL_14;
      }
      if (!v10[v9])
        break;
LABEL_14:
      ++v9;
      v12 = 32512;
      if (v9 == 32512)
        goto LABEL_15;
    }
    v12 = v9;
LABEL_15:
    if (v11 <= -1 || v10[v12] == 0)
      v14 = v12;
    else
      v14 = v11 + 1;
    if (v14 > 0)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v15 = x_log_category_CADebug;
        if (os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136315650;
          if (v8)
            v16 = "continued...\n";
          else
            v16 = "";
          v21 = v16;
          v22 = 1040;
          v23 = v14;
          v24 = 2080;
          *(_QWORD *)v25 = &v7[v8];
          _os_log_impl(&dword_184457000, v15, OS_LOG_TYPE_INFO, "%s%.*s", buf, 0x1Cu);
        }
      }
      v8 += v14;
      continue;
    }
    break;
  }
  x_log_end_free_(v17);
}

uint64_t CA::Render::Update::subtract_corner_radii_clipping_from_shape(uint64_t this, CA::Shape **a2, CA::Shape **a3)
{
  CA::Shape **v3;
  uint64_t v4;
  float v5;
  float v6;
  double v7;
  double v8;
  double v9;
  uint64_t v11;
  CA::Shape *v12[3];

  v12[2] = *(CA::Shape **)MEMORY[0x1E0C80C00];
  if (this)
  {
    if ((*(_BYTE *)(this + 40) & 0x40) == 0)
      return 0;
    v3 = a2;
    v4 = *(_QWORD *)(this + 128);
    v5 = 0.0;
    v6 = 0.0;
    if (v4)
      v6 = *(float *)(v4 + 228);
    if ((*(_BYTE *)(this + 38) & 0xF) != 0)
      v5 = v6;
    if (v4 && *(_QWORD *)(v4 + 72))
    {
      v11 = this;
      CA::Render::Layer::max_corner_radii(v4);
      v3 = a2;
      this = v11;
      v5 = v9;
    }
    if (v5 <= 0.0)
      return 0;
    v7 = *(double *)(this + 80);
    v8 = v5;
    if (v7 >= *(double *)(this + 88))
      v7 = *(double *)(this + 88);
    if (v7 * 0.5 < v8)
    {
      v12[0] = 0;
      v12[1] = 0;
      CA::shape_intersect(v3, v12, (const CA::Bounds *)a3);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return this;
}

uint64_t CA::Render::LayerNode::hit_test_sublayers_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  const char *v9;
  uint64_t v10;

  v3 = a1 + 96;
  v4 = *(_QWORD *)(a1 + 104);
  if (v4 == a1 + 96)
    return 0;
  while (1)
  {
    if (*(_QWORD *)(*(_QWORD *)(v4 + 32) + 144) || (*(_BYTE *)(v4 + 27) & 4) != 0)
    {
      v8 = CA::Render::LayerNode::hit_test_(v4, a2, a3);
      if (v8)
        break;
    }
    v4 = *(_QWORD *)(v4 + 8);
    if (v4 == v3)
      return 0;
  }
  v10 = v8;
  CA::Render::print_hit_test(*(CA::Render **)(a1 + 32), (const CA::Render::Layer *)"accepting", "hit sublayer", v9);
  return v10;
}

uint64_t CA::Render::LayerNode::hit_test_(uint64_t a1, float64x2_t *a2, unsigned int a3, const char *a4)
{
  uint64_t v6;
  const double *v7;
  const char *v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  const char *v12;
  uint64_t v13;
  int v14;
  CA::Mat4Impl *v15;
  double *v16;
  uint64_t result;
  uint64_t v18;
  float v19;
  double v20;
  uint64_t v21;
  _BOOL4 v22;
  float64x2_t v23;
  const char *v24;
  float32x4_t *v25;
  float v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  uint64_t v33;
  float64x2_t v34;
  uint64_t *v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t v38;
  int v39;
  const char *v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  int v44;
  double v45;
  float64x2_t v46;
  CGPoint v47;
  CGRect v48;
  float64x2_t v49;
  CGFloat width;
  CGFloat height;
  float64x2_t v52;
  _BYTE buf[32];
  __int16 v54;
  const char *v55;
  __int16 v56;
  const char *v57;
  uint64_t v58;
  CGRect v59;
  CGRect v60;

  v58 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 32);
  v52 = *a2;
  CA::Render::print_hit_test((CA::Render *)v6, (const CA::Render::Layer *)"entering", 0, a4);
  v10 = *(_QWORD *)(a1 + 24);
  if ((v10 & 0x200) != 0)
  {
    v12 = "kCAContextIgnoresHitTest";
LABEL_7:
    CA::Render::print_hit_test((CA::Render *)v6, (const CA::Render::Layer *)"rejecting", v12, v8);
    return 0;
  }
  v11 = *(_QWORD *)(v6 + 40);
  if ((v11 & 0x80000000) == 0)
  {
    if (byte_1ECDC6AAF)
    {
      if (x_log_hook_p())
        goto LABEL_79;
      v37 = x_log_category_render;
      if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        return 0;
      v38 = *(_QWORD *)(v6 + 120);
      if (v38)
      {
        v39 = *(_DWORD *)(v38 + 24);
        v38 += 28;
        if (!v39)
          v38 = 0;
      }
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = "rejecting";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v6;
      *(_WORD *)&buf[22] = 2080;
      *(_QWORD *)&buf[24] = v38;
      v54 = 2080;
      v55 = " - ";
      v56 = 2080;
      v40 = "allowsHitTesting = NO";
      goto LABEL_95;
    }
    return 0;
  }
  v13 = ((*(_QWORD *)(a1 + 24) & 0x18) != 0) | a3;
  if (((*(_QWORD *)(a1 + 24) & 0x18) != 0) | a3 & 1)
  {
    if ((v10 & 0x400000) == 0)
    {
      if (byte_1ECDC6AAF)
      {
        if (x_log_hook_p())
          goto LABEL_79;
        v37 = x_log_category_render;
        if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
          return 0;
        v43 = *(_QWORD *)(v6 + 120);
        if (v43)
        {
          v44 = *(_DWORD *)(v43 + 24);
          v43 += 28;
          if (!v44)
            v43 = 0;
        }
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = "rejecting";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v6;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = v43;
        v54 = 2080;
        v55 = " - ";
        v56 = 2080;
        v40 = "culled above and hitTestsAsOpaque = NO";
        goto LABEL_95;
      }
      return 0;
    }
    v14 = 0;
    if ((v11 & 0x100) != 0)
      goto LABEL_19;
  }
  else
  {
    v14 = (a3 >> 1) & 1;
    if ((v11 & 0x100) != 0)
    {
LABEL_19:
      if (byte_1ECDC6AAF)
      {
        if (x_log_hook_p())
        {
LABEL_79:
          x_log_();
          return 0;
        }
        v37 = x_log_category_render;
        if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
          return 0;
        v41 = *(_QWORD *)(v6 + 120);
        if (v41)
        {
          v42 = *(_DWORD *)(v41 + 24);
          v41 += 28;
          if (!v42)
            v41 = 0;
        }
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = "rejecting";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v6;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = v41;
        v54 = 2080;
        v55 = " - ";
        v56 = 2080;
        v40 = "hidden = YES or opacity = 0";
LABEL_95:
        v57 = v40;
        _os_log_impl(&dword_184457000, v37, OS_LOG_TYPE_DEFAULT, "HitTest: %s layer %p \"%s\"%s%s", buf, 0x34u);
      }
      return 0;
    }
  }
  LOBYTE(v9) = *(_BYTE *)(v6 + 32);
  if ((float)((float)v9 * 0.0039216) <= 0.0)
    goto LABEL_19;
  v15 = *(CA::Mat4Impl **)(a1 + 56);
  if (v15)
  {
    CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)buf, v15, v7);
    CA::Mat4Impl::mat4_unapply_inverse_to_point2((float64x2_t *)buf, v52.f64, v16);
  }
  else
  {
    v52 = vsubq_f64(v52, *(float64x2_t *)(a1 + 64));
  }
  v46 = *(float64x2_t *)(v6 + 80);
  v47 = *(CGPoint *)(v6 + 64);
  *(CGPoint *)buf = v47;
  *(float64x2_t *)&buf[16] = v46;
  v18 = *(_QWORD *)(v6 + 128);
  v19 = 0.0;
  if (v18)
    v19 = *(float *)(v18 + 228);
  v20 = v19;
  if ((v11 & 0x40) != 0 && (CA_CGRoundRectContainsPoint((double *)buf, v19, v52.f64[0], v52.f64[1]) & 1) == 0)
  {
    v12 = "masksToBounds = YES and not in bounds";
    goto LABEL_7;
  }
  v21 = *(_QWORD *)(a1 + 128);
  if (v21)
  {
    v22 = CA::Render::LayerNode::hit_test_(v21, &v52, 0) == 0;
    v11 = *(_QWORD *)(v6 + 40);
    if (v22 != ((v11 >> 7) & 1))
    {
      v12 = "mask not hit";
      goto LABEL_7;
    }
  }
  if ((v14 & 1) == 0)
  {
    result = CA::Render::LayerNode::hit_test_sublayers_(a1, (uint64_t)&v52, v13);
    if (result)
      return result;
    v11 = *(_QWORD *)(v6 + 40);
  }
  if ((v11 & 0x8000000000) != 0)
  {
    v23 = vaddq_f64(v46, (float64x2_t)v47);
    if ((vmovn_s64(vcgtq_f64(v23, (float64x2_t)v47)).u8[0] & 1) != 0
      && v46.f64[1] + v47.y > v47.y
      && (vmovn_s64((int64x2_t)vbicq_s8(vmvnq_s8((int8x16_t)vcgtq_f64((float64x2_t)v47, v52)), (int8x16_t)vcgeq_f64(v52, v23))).u32[0] & 1) != 0&& v52.f64[1] >= v47.y&& v52.f64[1] < v46.f64[1] + v47.y)
    {
      v24 = "hitTestsAsOpaque = YES and in bounds";
LABEL_77:
      CA::Render::print_hit_test((CA::Render *)v6, (const CA::Render::Layer *)"accepting", v24, v8);
      return a1;
    }
  }
  if ((v13 & 1) != 0)
  {
    v12 = "culled above";
    goto LABEL_7;
  }
  if ((v11 & 0x40000000000) != 0)
    goto LABEL_44;
  v25 = *(float32x4_t **)(v6 + 128);
  if (v25)
  {
    if (!v25[5].i64[0])
    {
LABEL_49:
      if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(v25[15])))) & 1) != 0
        || v25[8].i64[0])
      {
        v26 = v25[14].f32[3];
        if (v26 > 0.0)
        {
          v27 = v26;
          v28 = v25[14].f32[2];
          v59.size.width = v46.f64[0];
          v59.origin = v47;
          v59.size.height = v46.f64[1];
          v60 = CGRectInset(v59, -v28, -v28);
          v49.f64[0] = v60.origin.x;
          v49.f64[1] = v60.origin.y;
          width = v60.size.width;
          height = v60.size.height;
          v48 = CGRectInset(v60, v27, v27);
          v29 = v28 + v20;
          v30 = v29 >= 0.0 ? v29 : 0.0;
          v31 = v52.f64[1];
          v45 = v52.f64[0];
          if (CA_CGRoundRectContainsPoint(v49.f64, v30, v52.f64[0], v52.f64[1]))
          {
            v32 = v29 - v27;
            if (v29 - v27 < 0.0)
              v32 = 0.0;
            if (!CA_CGRoundRectContainsPoint(&v48.origin.x, v32, v45, v31))
            {
              v24 = "within border";
              goto LABEL_77;
            }
          }
        }
      }
      goto LABEL_59;
    }
LABEL_44:
    if (CA_CGRoundRectContainsPoint((double *)buf, v20, v52.f64[0], v52.f64[1]))
    {
      v24 = "within background color";
      goto LABEL_77;
    }
    v25 = *(float32x4_t **)(v6 + 128);
    if (!v25)
      goto LABEL_59;
    goto LABEL_49;
  }
LABEL_59:
  v33 = *(_QWORD *)(a1 + 48);
  if (v33)
  {
    if ((*(_DWORD *)(v6 + 36) & 0xF000) != 0x9000 || (*(_BYTE *)(v6 + 44) & 1) != 0)
    {
      if (CA::Render::hit_test_contents(v6, v33, *(_DWORD *)(a1 + 24) & 1, v52.f64[0], v52.f64[1]))
      {
LABEL_67:
        v24 = "within contents";
        goto LABEL_77;
      }
    }
    else
    {
      v34 = vaddq_f64(v46, (float64x2_t)v47);
      if ((vmovn_s64(vcgtq_f64(v34, (float64x2_t)v47)).u8[0] & 1) != 0
        && v46.f64[1] + v47.y > v47.y
        && (vmovn_s64((int64x2_t)vbicq_s8(vmvnq_s8((int8x16_t)vcgtq_f64((float64x2_t)v47, v52)), (int8x16_t)vcgeq_f64(v52, v34))).u32[0] & 1) != 0&& v52.f64[1] >= v47.y&& v52.f64[1] < v46.f64[1] + v47.y)
      {
        goto LABEL_67;
      }
    }
  }
  v35 = *(uint64_t **)(v6 + 128);
  if (v35)
  {
    v36 = *v35;
    if (*v35)
    {
      v49 = v52;
      if ((*(unsigned int (**)(uint64_t, uint64_t, float64x2_t *))(*(_QWORD *)v36 + 224))(v36, v6, &v49))
      {
        v24 = "subclass";
        goto LABEL_77;
      }
    }
  }
  if (!v14 || (result = CA::Render::LayerNode::hit_test_sublayers_(a1, (uint64_t)&v52, v13)) == 0)
  {
    v12 = "no hits";
    goto LABEL_7;
  }
  return result;
}

double CA::Transform::unapply_simple<double>(uint64_t a1, double *a2, double *a3)
{
  double result;
  char v4;
  double v5;

  *a2 = *a2 - *(double *)(a1 + 96);
  result = *a3 - *(double *)(a1 + 104);
  *a3 = result;
  v4 = *(_BYTE *)(a1 + 144);
  if ((v4 & 1) != 0)
  {
    result = -result;
    *a3 = result;
    v4 = *(_BYTE *)(a1 + 144);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else if ((*(_BYTE *)(a1 + 144) & 2) == 0)
  {
    goto LABEL_3;
  }
  result = -*a2;
  *a2 = result;
  v4 = *(_BYTE *)(a1 + 144);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0)
      return result;
LABEL_9:
    *a2 = *a2 * *(double *)(a1 + 136);
    result = *a3 * *(double *)(a1 + 136);
    *a3 = result;
    return result;
  }
LABEL_8:
  v5 = *a2;
  *a2 = *a3;
  result = -v5;
  *a3 = result;
  if ((*(_BYTE *)(a1 + 144) & 8) != 0)
    goto LABEL_9;
  return result;
}

uint64_t CA::Render::HitTestTree::append_root_node(CA::Render::HitTestTree *this, const CA::Render::LayerNode *a2, unsigned int a3, int a4, unsigned int *a5)
{
  int v6;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t result;
  unsigned __int16 v14;
  uint64_t v15;

  v6 = a4;
  v15 = *MEMORY[0x1E0C80C00];
  v10 = *((_QWORD *)a2 + 5);
  if (v10)
  {
    v11 = *(_QWORD *)(v10 + 24);
    if (v11)
    {
      v12 = *(unsigned __int16 *)(v11 + 552);
      v6 = (v12 >> 1) & 4 | a4;
      if ((v12 & 0x10) != 0)
        std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)this + 24, a3, a3);
    }
  }
  v14 = 0;
  result = CA::Render::HitTestTree::append_layer_node(this, a2, 0, a3, v6, &v14);
  if ((_DWORD)result)
    ++*a5;
  return result;
}

uint64_t CA::Render::HitTestTree::append_layer_node(CA::Render::HitTestTree *this, const CA::Render::LayerNode *a2, int a3, unsigned int a4, int a5, unsigned __int16 *a6)
{
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  BOOL v14;
  int v15;
  uint64_t v16;
  _BOOL4 v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  size_t v21;
  unsigned int v22;
  char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  BOOL v43;
  char v44;
  uint64_t result;
  unint64_t v46;
  uint64_t v47;
  __int128 v48;
  __int128 *v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  unsigned int v56;
  float32x4_t *v57;
  float v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int *v61;
  float v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  unsigned int v69;
  unsigned __int16 v70;
  unsigned int *v71;
  int v72;
  uint64_t v73;
  int v74;
  unsigned __int16 *v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  BOOL v79;
  char v80;
  unsigned int *v81;
  unsigned int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unsigned int v86;
  __int16 v87;
  unsigned int v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unsigned int *v92;
  unsigned int v93;
  unsigned int v94;
  int v96;
  unsigned __int16 v97;
  uint64_t v98;

  v98 = *MEMORY[0x1E0C80C00];
  v10 = *((_QWORD *)a2 + 3);
  v11 = *((_QWORD *)a2 + 4);
  v12 = ((v10 & 0x18) != 0) | a5;
  v13 = ((v10 & 0x18) != 0) | a5 & 1u;
  if (*((_DWORD *)a2 + 29))
    v14 = (v10 & 0x200) == 0;
  else
    v14 = 0;
  if (v14)
  {
    v16 = *(_QWORD *)(v11 + 40);
    v17 = (v10 & 0x400000) == 0;
    if (!(_DWORD)v13)
      v17 = (int)v16 >= 0;
    v15 = (int)v16 >= 0 || v17;
  }
  else
  {
    v15 = 1;
  }
  v18 = *(_QWORD *)(v11 + 144);
  if (!a4)
  {
    if (v18)
    {
      if ((*(_BYTE *)(v18 + 99) & 4) != 0)
        v44 = 0;
      else
        v44 = v15;
      if ((v44 & 1) == 0)
        goto LABEL_12;
    }
    else if ((v15 & 1) == 0)
    {
      goto LABEL_12;
    }
    return 0;
  }
LABEL_12:
  v20 = *((unsigned int *)this + 1);
  v19 = *((unsigned int *)this + 2);
  if (v20 + 240 <= v19)
  {
    v23 = (char *)*((_QWORD *)this + 2);
  }
  else
  {
    v21 = (2 * v19);
    *((_DWORD *)this + 2) = v21;
    v22 = v12;
    v23 = (char *)malloc_type_realloc(*((void **)this + 2), v21, 0x52D4E5F1uLL);
    v12 = v22;
    *((_QWORD *)this + 2) = v23;
  }
  v96 = *(_DWORD *)(v11 + 12);
  v24 = &v23[v20];
  *((_OWORD *)v24 + 3) = 0u;
  *((_OWORD *)v24 + 4) = 0u;
  *((_OWORD *)v24 + 1) = 0u;
  *((_OWORD *)v24 + 2) = 0u;
  *(_OWORD *)v24 = 0u;
  *(_DWORD *)v24 = v20 - a3;
  v25 = 0x10000000000;
  if (!v15)
    v25 = 0;
  v26 = v25 | (*((_DWORD *)a2 + 29) << 24);
  *((_QWORD *)v24 + 1) = v26;
  v27 = v26 & 0xFFFFFDFFFFFFFFFFLL | (((*(_QWORD *)(v11 + 40) >> 6) & 1) << 41);
  *((_QWORD *)v24 + 1) = v27;
  v28 = v27 & 0xFFFFF7FFFFFFFFFFLL | (((*(_QWORD *)(v11 + 40) >> 39) & 1) << 43);
  *((_QWORD *)v24 + 1) = v28;
  v29 = (v13 << 45) | ((*((_QWORD *)a2 + 3) & 1) << 44) | v28;
  *((_QWORD *)v24 + 1) = v29;
  v30 = v29 | ((unint64_t)(*((_QWORD *)a2 + 16) != 0) << 47);
  *((_QWORD *)v24 + 1) = v30;
  if ((*(_BYTE *)(v11 + 45) & 4) != 0 || (v31 = *(_QWORD *)(v11 + 128)) != 0 && (v31 = *(_QWORD *)(v31 + 80)) != 0)
    v31 = 0x1000000000000;
  v32 = v31 | v30;
  *((_QWORD *)v24 + 1) = v32;
  v33 = *(_QWORD *)(v11 + 96);
  v34 = v32 | ((unint64_t)(v33 != 0) << 49);
  *((_QWORD *)v24 + 1) = v34;
  if (v33)
  {
    if ((*(_DWORD *)(v11 + 36) & 0xF000) != 0x9000
      || (*(_BYTE *)(v11 + 44) & 1) != 0
      || (v35 = *(_QWORD *)(v11 + 128)) != 0 && *(_QWORD *)(v35 + 32))
    {
      v33 = 0;
    }
    else
    {
      v33 = 0x4000000000000;
    }
  }
  v36 = v33 | v34;
  *((_QWORD *)v24 + 1) = v36;
  v37 = *(_QWORD *)(v11 + 128);
  if (v37)
  {
    v37 = *(_QWORD *)(v37 + 96);
    if (v37)
    {
      v38 = *(unsigned int *)(v37 + 16);
      if ((_DWORD)v38)
      {
        v39 = (uint64_t *)(v37 + 24);
        v40 = 8 * v38 - 8;
        do
        {
          v41 = *v39++;
          v42 = *(_DWORD *)(v41 + 24);
          v43 = v42 != 98 || v40 == 0;
          v40 -= 8;
        }
        while (!v43);
        v37 = (unint64_t)(v42 != 98) << 46;
      }
      else
      {
        v37 = 0;
      }
    }
  }
  v46 = v36 & 0xFFFFBFFFFFFFFFFFLL | v37;
  *((_QWORD *)v24 + 1) = v46;
  v47 = (*((_QWORD *)a2 + 3) << 33) & 0x800000000000000 | v46;
  *((_QWORD *)v24 + 1) = v47;
  *((_DWORD *)v24 + 6) = a4;
  if ((v96 & 0x400) != 0 && v18)
    *((_DWORD *)v24 + 7) = *(_DWORD *)(v18 + 84);
  *((_OWORD *)v24 + 2) = *((_OWORD *)a2 + 11);
  v48 = *(_OWORD *)(v11 + 80);
  *((_OWORD *)v24 + 3) = *((_OWORD *)a2 + 12);
  *((_OWORD *)v24 + 4) = v48;
  if (*((_QWORD *)a2 + 7))
  {
    v47 |= 0x8000000000000uLL;
    *((_QWORD *)v24 + 1) = v47;
    v49 = (__int128 *)*((_QWORD *)a2 + 7);
    v50 = *v49;
    v51 = v49[1];
    v52 = v49[3];
    *((_OWORD *)v24 + 7) = v49[2];
    *((_OWORD *)v24 + 8) = v52;
    *((_OWORD *)v24 + 5) = v50;
    *((_OWORD *)v24 + 6) = v51;
    v53 = v49[4];
    v54 = v49[5];
    v55 = v49[7];
    *((_OWORD *)v24 + 11) = v49[6];
    *((_OWORD *)v24 + 12) = v55;
    *((_OWORD *)v24 + 9) = v53;
    *((_OWORD *)v24 + 10) = v54;
    v56 = 16;
  }
  else if (*((double *)a2 + 8) == 0.0 && *((double *)a2 + 9) == 0.0)
  {
    v56 = 0;
  }
  else
  {
    v47 |= 0x10000000000000uLL;
    *((_QWORD *)v24 + 1) = v47;
    *((_OWORD *)v24 + 5) = *((_OWORD *)a2 + 4);
    v56 = 2;
  }
  v57 = *(float32x4_t **)(v11 + 128);
  if (!v57)
    goto LABEL_74;
  if (v57[14].f32[3] > 0.0
    && ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(v57[15])))) & 1) != 0 || v57[8].i64[0]))
  {
    *((_QWORD *)v24 + 1) = v47 | 0x20000000000000;
    v57 = *(float32x4_t **)(v11 + 128);
    if (!v57)
    {
      v60 = 0;
      v61 = (unsigned int *)&v24[8 * v56];
      v56 |= 1u;
      *((_QWORD *)v61 + 10) = 0;
      goto LABEL_75;
    }
    v58 = v57[14].f32[2];
    v59 = v56 | 1;
    *(double *)&v24[8 * v56 + 80] = v57[14].f32[3];
    if (v58 == 0.0)
    {
      v56 |= 1u;
      v47 |= 0x20000000000000uLL;
    }
    else
    {
      v47 |= 0x60000000000000uLL;
      *((_QWORD *)v24 + 1) = v47;
      v56 += 2;
      v57 = *(float32x4_t **)(v11 + 128);
      *(double *)&v24[8 * v59 + 80] = v58;
      if (!v57)
        goto LABEL_74;
    }
  }
  v62 = v57[14].f32[1];
  if (v62 > 0.0)
  {
    *((_QWORD *)v24 + 1) = v47 | 0x80000000000000;
    *(double *)&v24[8 * v56 + 80] = v62;
    v57 = *(float32x4_t **)(v11 + 128);
    if (!v57)
    {
      v60 = 0;
      ++v56;
      goto LABEL_75;
    }
    ++v56;
  }
  v63 = v57->i64[0];
  if (!v57->i64[0])
    goto LABEL_74;
  v64 = *(unsigned __int8 *)(v63 + 12);
  if (v64 == 40)
  {
    v60 = *(_DWORD *)(v63 + 40);
    v85 = *(_QWORD *)(v63 + 56);
    if (v85)
    {
      v86 = *(_DWORD *)(v85 + 12);
      v12 = (v86 >> 8) & 4 | v12 & 0xFFFFFFFB;
      if ((v86 & 0x800) != 0)
        goto LABEL_126;
    }
  }
  else
  {
    if (v64 != 30)
    {
LABEL_74:
      v60 = 0;
      goto LABEL_75;
    }
    v60 = *(_DWORD *)(v63 + 16);
    v65 = *(_QWORD *)(v63 + 72);
    if (!v65)
    {
      LOWORD(v12) = v12 & 0xFFFB;
      goto LABEL_75;
    }
    v66 = *(unsigned __int16 *)(v65 + 552);
    v12 = (v66 >> 1) & 4 | v12 & 0xFFFFFFFB;
    if ((v66 & 0x10) != 0)
    {
LABEL_126:
      v87 = v12;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)this + 24, v60, v60);
      LOWORD(v12) = v87;
    }
  }
LABEL_75:
  if ((v12 & 4) != 0)
  {
    if ((*(_BYTE *)(v11 + 39) & 2) != 0 || (v67 = *(unsigned int *)v24, (_DWORD)v67) && (v24[-v67 + 15] & 2) != 0)
      *((_QWORD *)v24 + 1) |= 0x200000000000000uLL;
  }
  if (*(double *)(v11 + 64) == 0.0)
  {
    v68 = *((_QWORD *)v24 + 1);
    if (*(double *)(v11 + 72) == 0.0)
      goto LABEL_84;
  }
  else
  {
    v68 = *((_QWORD *)v24 + 1);
  }
  v68 |= 0x100000000000000uLL;
  *((_QWORD *)v24 + 1) = v68;
  v69 = v56 + 1;
  *(_QWORD *)&v24[8 * v56 + 80] = *(_QWORD *)(v11 + 64);
  v56 += 2;
  *(_QWORD *)&v24[8 * v69 + 80] = *(_QWORD *)(v11 + 72);
LABEL_84:
  v70 = v12;
  if ((*((_BYTE *)a2 + 26) & 4) != 0)
  {
    v68 |= 0x40000000000uLL;
    *((_QWORD *)v24 + 1) = v68;
    v71 = (unsigned int *)&v24[8 * v56];
    LOBYTE(v56) = v56 + 1;
    *((double *)v71 + 10) = *((float *)a2 + 68);
  }
  v97 = 0;
  v72 = (8 * (_BYTE)v56 + 80) & 0xF8;
  *((_QWORD *)v24 + 1) = v68 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)(v72 >> 3) << 35);
  *((_DWORD *)this + 1) += v72;
  if (v24[13] < 0
    && (CA::Render::HitTestTree::append_layer_node(this, *((const CA::Render::LayerNode **)a2 + 16), v20, v60, v12, &v97) & 1) == 0)
  {
    if ((*(_BYTE *)(v11 + 40) & 0x80) == 0)
    {
      result = 0;
      *((_DWORD *)this + 1) -= *(unsigned __int8 *)(*((_QWORD *)this + 2) + v20 + 12);
      return result;
    }
    *((_QWORD *)v24 + 1) &= ~0x800000000000uLL;
  }
  v73 = *((_QWORD *)a2 + 13);
  if ((const CA::Render::LayerNode *)v73 == (const CA::Render::LayerNode *)((char *)a2 + 96))
  {
    v74 = 0;
    v75 = a6;
  }
  else
  {
    v74 = 0;
    v75 = a6;
    do
    {
      if (*(_QWORD *)(*(_QWORD *)(v73 + 32) + 144) || (*(_BYTE *)(v73 + 27) & 4) != 0)
        v74 += CA::Render::HitTestTree::append_layer_node(this, (const CA::Render::LayerNode *)v73, v20, v60, v70, &v97);
      v73 = *(_QWORD *)(v73 + 8);
    }
    while ((const CA::Render::LayerNode *)v73 != (const CA::Render::LayerNode *)((char *)a2 + 96));
  }
  v76 = *((_QWORD *)this + 2) + v20;
  *(_DWORD *)(v76 + 4) = *((_DWORD *)this + 1) - v20;
  v77 = *(_QWORD *)(v76 + 8);
  *(_QWORD *)(v76 + 8) = v77 & 0xFFFFFFFFFF000000 | *(_QWORD *)&v74 & 0xFFFFFFLL;
  v78 = *(_QWORD **)(v11 + 128);
  if (v78 && *v78
    || (v70 & 2) != 0
    || ((v77 & 0x6000000000000) != 0x2000000000000 ? (v79 = (v96 & 0x400) == 0) : (v79 = 0),
        !v79 || (*(_BYTE *)(v11 + 40) & 0x80) != 0 || (v80 = v97, (v97 & 0x20) != 0) || (v77 & 0x20000000000000) != 0))
  {
    v81 = (unsigned int *)(v11 + 8);
    do
      v82 = __ldaxr(v81);
    while (__stlxr(v82 + 1, v81));
    if (!v82)
    {
      v11 = 0;
      do
        v88 = __ldaxr(v81);
      while (__stlxr(v88 - 1, v81));
    }
    *(_QWORD *)(v76 + 16) = v11;
    v80 = v97;
    if ((v97 & 0x20) == 0)
      goto LABEL_111;
LABEL_118:
    *v75 |= 0x20u;
    v83 = *(_QWORD *)(v76 + 8);
    if ((v83 & 0x800000000000) != 0)
    {
      v89 = v76 + BYTE4(v83);
      if (!*(_QWORD *)(v89 + 16))
      {
        v90 = *((_QWORD *)a2 + 16);
        if (v90)
        {
          v91 = *(_QWORD *)(v90 + 32);
          if (v91)
          {
            v92 = (unsigned int *)(v91 + 8);
            do
              v93 = __ldaxr(v92);
            while (__stlxr(v93 + 1, v92));
            if (!v93)
            {
              v91 = 0;
              do
                v94 = __ldaxr(v92);
              while (__stlxr(v94 - 1, v92));
            }
            *(_QWORD *)(v89 + 16) = v91;
          }
        }
      }
    }
    goto LABEL_119;
  }
  if ((v97 & 0x20) != 0)
    goto LABEL_118;
LABEL_111:
  if (*((_QWORD *)this + 6)
    && std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((_QWORD *)this + 3, *(_DWORD *)(v76 + 24)))
  {
    *v75 |= 0x20u;
  }
LABEL_119:
  v84 = *(_QWORD *)(v76 + 8);
  if ((v80 & 0x10) != 0 || (v84 & 0x200000000000000) != 0)
  {
    *(_QWORD *)(v76 + 8) = v84 | 0x400000000000000;
    *v75 |= 0x10u;
  }
  return 1;
}

unsigned int *CA::Render::HitTestTree::get_secure_superlayers_validation_start_node(uint64_t a1, unsigned int *a2)
{
  unsigned int v3;
  uint64_t v4;

  while (1)
  {
    v3 = a2[6];
    if (v3)
      break;
    v4 = *a2;
    a2 = (unsigned int *)((char *)a2 - v4);
    if (!(_DWORD)v4)
      return 0;
  }
  if (std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((_QWORD *)(a1 + 24), v3))
  {
    return a2;
  }
  else
  {
    return 0;
  }
}

uint64_t CA::Render::HitTestTree::Node::subtree_occludes_slot(int32x2_t *this, unsigned int a2, int32x2_t *a3)
{
  int32x2_t v3;
  uint32x2_t v4;
  int32x2_t v6;
  uint32x2_t v7;
  int32x2_t *v8;
  int32x2_t v9;
  int32x2_t v10;
  int32x2_t v11;
  uint32x2_t v12;
  int32x2_t v13;
  int32x2_t v15;
  uint32x2_t v16;
  uint32x2_t v17;
  uint64_t result;
  unsigned int v19;
  unsigned int *v20;
  double *v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  uint64_t v28;
  NSObject *v29;
  _BOOL4 v30;
  int32x2_t v31;
  const char *v32;
  uint64_t v33;
  __int32 v34;
  __int32 v35;
  __int32 v36;
  __int32 v37;
  __int32 v38;
  __int32 v39;
  __int32 v40;
  __int32 v41;
  uint64_t v42;
  uint8_t buf[4];
  unsigned int v44;
  __int16 v45;
  __int32 v46;
  __int16 v47;
  __int32 v48;
  __int16 v49;
  __int32 v50;
  __int16 v51;
  __int32 v52;
  __int16 v53;
  int32x2_t v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  __int32 v58;
  __int16 v59;
  __int32 v60;
  __int16 v61;
  __int32 v62;
  __int16 v63;
  __int32 v64;
  __int16 v65;
  double v66;
  __int16 v67;
  double v68;
  __int16 v69;
  double v70;
  __int16 v71;
  double v72;
  __int16 v73;
  double v74;
  __int16 v75;
  double v76;
  __int16 v77;
  int v78;
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  v3 = this[5];
  v4 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v3);
  if ((vpmax_u32(v4, v4).u32[0] & 0x80000000) != 0)
    return 0;
  v6 = a3[1];
  v7 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v6);
  if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) != 0)
    return 0;
  v8 = this;
  v9 = this[4];
  v10 = vadd_s32(v9, v3);
  v11 = vadd_s32(*a3, v6);
  v12 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, vsub_s32(vmin_s32(v10, v11), vmax_s32(v9, *a3)));
  if ((vpmax_u32(v12, v12).u32[0] & 0x80000000) != 0)
    return 0;
  v13 = this[1];
  if ((*(_QWORD *)&v13 & 0x200000000000000) != 0)
    return 0;
  if ((*(_QWORD *)&v13 & 0x400000000000000) != 0)
  {
    v15 = this[7];
    v16 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v15);
    if ((vpmax_u32(v16, v16).u32[0] & 0x80000000) != 0
      || (v17 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, vsub_s32(vmin_s32(vadd_s32(this[6], v15), v11), vmax_s32(this[6], *a3))), (vpmax_u32(v17, v17).u32[0] & 0x80000000) != 0))
    {
      if ((*(_QWORD *)&v13 & 0xFFFFFFLL) != 0)
      {
        v19 = 0;
        v20 = (unsigned int *)((char *)this + v13.u8[4]);
        do
        {
          result = CA::Render::HitTestTree::Node::subtree_occludes_slot((CA::Render::HitTestTree::Node *)v20, a2, (const CA::Bounds *)a3);
          if ((result & 1) != 0)
            break;
          v20 = (unsigned int *)((char *)v20 + v20[1]);
          ++v19;
        }
        while (v19 < (v8[1].i32[0] & 0xFFFFFFu));
        return result;
      }
      return 0;
    }
  }
  if (!byte_1ECDC6AAF)
    return 1;
  v21 = (double *)this[2];
  if (v21)
  {
    v23 = v21[8];
    v22 = v21[9];
    v25 = v21[10];
    v24 = v21[11];
    v26 = v21[6];
    v27 = v21[7];
  }
  else
  {
    v24 = -1.0;
    v25 = -1.0;
    v22 = -1.0;
    v23 = -1.0;
    v26 = -1.0;
    v27 = -1.0;
  }
  if (x_log_hook_p())
  {
    do
    {
      if (v8[3].i32[0])
        break;
      v28 = v8->u32[0];
      v8 = (int32x2_t *)((char *)v8 - v28);
    }
    while ((_DWORD)v28);
    x_log_();
    return 1;
  }
  v29 = x_log_category_render;
  v30 = os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_INFO);
  result = 1;
  if (v30)
  {
    v31 = v8[2];
    v32 = "No Name";
    if (v31)
    {
      v33 = *(_QWORD *)(*(_QWORD *)&v31 + 120);
      if (v33)
        v32 = (const char *)(v33 + 28);
    }
    v34 = a3->i32[0];
    v35 = a3->i32[1];
    v37 = a3[1].i32[0];
    v36 = a3[1].i32[1];
    v38 = v8[4].i32[0];
    v39 = v8[4].i32[1];
    v40 = v8[5].i32[0];
    v41 = v8[5].i32[1];
    do
    {
      LODWORD(v42) = v8[3].i32[0];
      if ((_DWORD)v42)
        break;
      v42 = v8->u32[0];
      v8 = (int32x2_t *)((char *)v8 - v42);
    }
    while ((_DWORD)v42);
    *(_DWORD *)buf = 67113474;
    v44 = a2;
    v45 = 1024;
    v46 = v34;
    v47 = 1024;
    v48 = v35;
    v49 = 1024;
    v50 = v37;
    v51 = 1024;
    v52 = v36;
    v53 = 2048;
    v54 = v31;
    v55 = 2080;
    v56 = v32;
    v57 = 1024;
    v58 = v38;
    v59 = 1024;
    v60 = v39;
    v61 = 1024;
    v62 = v40;
    v63 = 1024;
    v64 = v41;
    v65 = 2048;
    v66 = v26;
    v67 = 2048;
    v68 = v27;
    v69 = 2048;
    v70 = v23;
    v71 = 2048;
    v72 = v22;
    v73 = 2048;
    v74 = v25;
    v75 = 2048;
    v76 = v24;
    v77 = 1024;
    v78 = v42;
    _os_log_impl(&dword_184457000, v29, OS_LOG_TYPE_INFO, "Slot <%d> [%d %d %d %d] occluded by layer <%p> (%s) [%d %d %d %d] [%f %f] [%f %f %f %f] from context 0x%x", buf, 0x8Eu);
    return 1;
  }
  return result;
}

uint64_t CA::Render::HitTestTree::Node::subtract_subtree_occlusion_from_shape(int32x2_t *this, int32x2_t *a2, CA::Shape **a3)
{
  int32x2_t v7;
  uint32x2_t v8;
  int32x2_t v9;
  uint32x2_t v10;
  int32x2_t v11;
  int32x2_t v12;
  int32x2_t v13;
  uint32x2_t v14;
  int32x2_t v15;
  uint32x2_t v16;
  uint32x2_t v17;
  int32x2_t v18;
  unsigned int v19;
  unsigned int *v20;
  NSObject *v21;
  int32x2_t v22;
  const char *v23;
  uint64_t v24;
  __int32 v25;
  __int32 v26;
  __int32 v27;
  __int32 v28;
  uint64_t v29;
  __int32 v30;
  __int32 v31;
  __int32 v32;
  __int32 v33;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  int32x2_t v37;
  __int16 v38;
  __int32 v39;
  __int16 v40;
  __int32 v41;
  __int16 v42;
  __int32 v43;
  __int16 v44;
  __int32 v45;
  __int16 v46;
  __int32 v47;
  __int16 v48;
  __int32 v49;
  __int16 v50;
  __int32 v51;
  __int16 v52;
  __int32 v53;
  __int16 v54;
  uint64_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  if ((*a3 & 1) == 0 && *((int *)*a3 + 1) > 256)
    return 1;
  v7 = this[5];
  v8 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v7);
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) == 0)
  {
    v9 = a2[1];
    v10 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v9);
    if ((vpmax_u32(v10, v10).u32[0] & 0x80000000) == 0)
    {
      v11 = this[4];
      v12 = vadd_s32(v11, v7);
      v13 = vadd_s32(*a2, v9);
      v14 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, vsub_s32(vmin_s32(v12, v13), vmax_s32(v11, *a2)));
      if ((vpmax_u32(v14, v14).u32[0] & 0x80000000) == 0 && (this[1].i8[7] & 2) == 0)
      {
        v15 = this[7];
        v16 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v15);
        if ((vpmax_u32(v16, v16).u32[0] & 0x80000000) != 0)
          goto LABEL_15;
        v17 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, vsub_s32(vmin_s32(vadd_s32(this[6], v15), v13), vmax_s32(this[6], *a2)));
        if ((vpmax_u32(v17, v17).u32[0] & 0x80000000) != 0)
          goto LABEL_15;
        CA::shape_subtract(a3, (CA::Shape **)&this[6], (const CA::Bounds *)a3);
        if (byte_1ECDC6B02)
        {
          if (x_log_hook_p())
          {
            CA::Shape::area(*a3);
            x_log_();
          }
          else
          {
            v21 = x_log_category_security_analysis;
            if (os_log_type_enabled((os_log_t)x_log_category_security_analysis, OS_LOG_TYPE_INFO))
            {
              v22 = this[2];
              v23 = "No Name";
              if (v22)
              {
                v24 = *(_QWORD *)(*(_QWORD *)&v22 + 120);
                if (v24)
                  v23 = (const char *)(v24 + 28);
              }
              v25 = this[6].i32[0];
              v26 = this[6].i32[1];
              v27 = this[7].i32[0];
              v28 = this[7].i32[1];
              v30 = a2->i32[0];
              v31 = a2->i32[1];
              v32 = a2[1].i32[0];
              v33 = a2[1].i32[1];
              v29 = CA::Shape::area(*a3);
              *(_DWORD *)buf = 136317698;
              v35 = v23;
              v36 = 2048;
              v37 = v22;
              v38 = 1024;
              v39 = v25;
              v40 = 1024;
              v41 = v26;
              v42 = 1024;
              v43 = v27;
              v44 = 1024;
              v45 = v28;
              v46 = 1024;
              v47 = v30;
              v48 = 1024;
              v49 = v31;
              v50 = 1024;
              v51 = v32;
              v52 = 1024;
              v53 = v33;
              v54 = 2048;
              v55 = v29;
              _os_log_impl(&dword_184457000, v21, OS_LOG_TYPE_INFO, "Layer (%s) <%p> [%d %d %d %d] occludes view [%d %d %d %d] unoccluded area is now %ld", buf, 0x50u);
            }
          }
        }
        if (this[6].i32[0] != this[4].i32[0]
          || this[6].i32[1] != this[4].i32[1]
          || this[7].i32[0] != this[5].i32[0]
          || this[7].i32[1] != this[5].i32[1])
        {
LABEL_15:
          v18 = this[1];
          if ((*(_QWORD *)&v18 & 0xFFFFFFLL) != 0)
          {
            v19 = 0;
            v20 = (unsigned int *)((char *)this + v18.u8[4]);
            do
            {
              CA::Render::HitTestTree::Node::subtract_subtree_occlusion_from_shape((CA::Render::HitTestTree::Node *)v20, (const CA::Bounds *)a2, a3);
              v20 = (unsigned int *)((char *)v20 + v20[1]);
              ++v19;
            }
            while (v19 < (this[1].i32[0] & 0xFFFFFFu));
          }
        }
        return 1;
      }
    }
  }
  return 0;
}

uint64_t std::__split_buffer<X::Ref<CA::Render::Handle>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int *v4;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    v5 = *(unsigned int **)(v2 - 8);
    v2 -= 8;
    v4 = v5;
    *(_QWORD *)(a1 + 16) = v2;
    if (v5)
    {
      v6 = v4 + 2;
      do
      {
        v7 = __ldaxr(v6);
        v8 = v7 - 1;
      }
      while (__stlxr(v8, v6));
      if (!v8)
        (*(void (**)(unsigned int *))(*(_QWORD *)v4 + 16))(v4);
      v2 = *(_QWORD *)(a1 + 16);
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

CA::Render::Update *CARenderUpdateBegin(const CA::Bounds *a1, unint64_t a2, const CVTimeStamp *a3, int a4, uint64_t a5, double a6, float64x2_t a7)
{
  return CARenderUpdateBegin2(a1, a2, a3, 0, a4, a5, 0, a6, a7);
}

CA::Render::Update *CARenderUpdateBegin2(const CA::Bounds *a1, unint64_t a2, const CVTimeStamp *a3, unsigned int a4, int a5, uint64_t a6, unsigned int a7, double a8, float64x2_t a9)
{
  int v10;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float64x2_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  float64x2_t v28;
  int32x4_t v29;
  CA::Render::Update *v30;
  int32x4_t v32;
  uint64_t v33;

  v10 = a5;
  v33 = *MEMORY[0x1E0C80C00];
  if (!a5)
    v10 = CA::Render::Update::_update_counter[0];
  v16 = *(int8x16_t *)(a6 + 16);
  a9.f64[0] = 0.0;
  v17 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a9, (float64x2_t)v16).i64[0], 0);
  v18.i64[1] = *(_QWORD *)(a6 + 24);
  *(double *)v18.i64 = -*(double *)v16.i64;
  v19 = vbslq_s8(v17, v18, v16);
  v20 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a9, (float64x2_t)vdupq_laneq_s64((int64x2_t)v16, 1)).i64[0], 0);
  v21.i64[0] = v19.i64[0];
  v21.i64[1] = *(_QWORD *)&vnegq_f64(*(float64x2_t *)&v16).f64[1];
  v22 = (float64x2_t)vbslq_s8(v20, v21, v19);
  v23 = (int8x16_t)vceqzq_f64(v22);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v23, 1), v23).u64[0] & 0x8000000000000000) != 0
    || (v24 = vorrq_s8((int8x16_t)vcltzq_f64(v22), (int8x16_t)vcgezq_f64(v22)),
        v25 = (int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v24), 1),
        (vornq_s8(v25, v24).u64[0] & 0x8000000000000000) != 0))
  {
    v32 = 0uLL;
  }
  else
  {
    v25.i64[0] = 0x8000000000000000;
    v26.i64[0] = *(_OWORD *)&vaddq_f64(*(float64x2_t *)a6, (float64x2_t)vbslq_s8(v17, v16, v25));
    v27.i64[0] = v26.i64[0];
    v27.i64[1] = *(_QWORD *)(a6 + 8);
    v26.i64[1] = *(_QWORD *)&vaddq_f64(*(float64x2_t *)&v16, *(float64x2_t *)a6).f64[1];
    v28 = (float64x2_t)vbslq_s8(v20, v26, v27);
    v29 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v28, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    v32 = vuzp1q_s32(v29, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v28, v22), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v29));
  }
  v30 = (CA::Render::Update *)operator new();
  return CA::Render::Update::Update(v30, a1, a2, a8, a3, a4, v10, v10, (const CA::Bounds *)&v32, a7);
}

uint64_t CARenderUpdateAllocateSeed()
{
  unsigned int v0;
  uint64_t result;

  do
  {
    v0 = __ldaxr(CA::Render::Update::_update_counter);
    result = v0 + 1;
  }
  while (__stlxr(result, CA::Render::Update::_update_counter));
  return result;
}

uint64_t CARenderPresentAcquire(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t *v8;
  uint64_t **v9;
  BOOL v10;
  unint64_t v11;
  uint64_t **v12;
  uint64_t **v13;
  uint64_t *v14;
  uint64_t *v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD **v18;
  uint64_t **v20;
  uint64_t *v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v24 = 0;
  v25 = 0;
  v23 = &v24;
  std::__tree<CA::Render::Object *>::swap((uint64_t *)(a1 + 856), (uint64_t)&v23);
  if (v25)
  {
    v2 = operator new();
    v3 = *(_DWORD *)(a1 + 248);
    v4 = *(_QWORD *)(a1 + 72);
    v21 = 0;
    v22 = 0;
    v20 = &v21;
    v5 = v23;
    if (v23 != &v24)
    {
      do
      {
        v6 = v21;
        v7 = &v21;
        if (v20 == &v21)
          goto LABEL_9;
        v8 = v21;
        v9 = &v21;
        if (v21)
        {
          do
          {
            v7 = (uint64_t **)v8;
            v8 = (uint64_t *)v8[1];
          }
          while (v8);
        }
        else
        {
          do
          {
            v7 = (uint64_t **)v9[2];
            v10 = *v7 == (uint64_t *)v9;
            v9 = v7;
          }
          while (v10);
        }
        v11 = v5[4];
        if ((unint64_t)v7[4] < v11)
        {
LABEL_9:
          if (v21)
            v12 = v7;
          else
            v12 = &v21;
          if (v21)
            v13 = v7 + 1;
          else
            v13 = &v21;
        }
        else
        {
          v12 = &v21;
          v13 = &v21;
          if (v21)
          {
            v13 = &v21;
            while (1)
            {
              while (1)
              {
                v12 = (uint64_t **)v6;
                v16 = v6[4];
                if (v11 >= v16)
                  break;
                v6 = *v12;
                v13 = v12;
                if (!*v12)
                  goto LABEL_16;
              }
              if (v16 >= v11)
                break;
              v13 = v12 + 1;
              v6 = v12[1];
              if (!v6)
                goto LABEL_16;
            }
          }
        }
        if (!*v13)
        {
LABEL_16:
          v14 = (uint64_t *)operator new(0x28uLL);
          v14[4] = v5[4];
          *v14 = 0;
          v14[1] = 0;
          v14[2] = (uint64_t)v12;
          *v13 = v14;
          if (*v20)
          {
            v20 = (uint64_t **)*v20;
            v15 = *v13;
          }
          else
          {
            v15 = v14;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v21, v15);
          ++v22;
        }
        v17 = (_QWORD *)v5[1];
        if (v17)
        {
          do
          {
            v18 = (_QWORD **)v17;
            v17 = (_QWORD *)*v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            v18 = (_QWORD **)v5[2];
            v10 = *v18 == v5;
            v5 = v18;
          }
          while (!v10);
        }
        v5 = v18;
      }
      while (v18 != &v24);
    }
    *(_DWORD *)v2 = v3;
    *(_QWORD *)(v2 + 8) = v4;
    *(_QWORD *)(v2 + 32) = 0;
    *(_QWORD *)(v2 + 24) = 0;
    *(_QWORD *)(v2 + 16) = v2 + 24;
    std::__tree<CA::Render::Object *>::swap((uint64_t *)(v2 + 16), (uint64_t)&v20);
    std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(v21);
  }
  else
  {
    v2 = 0;
  }
  std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(v24);
  return v2;
}

uint64_t CARenderPresentRelease(uint64_t result, double a2, double a3)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  int v7;
  double v8;
  CA::Render::ImageQueue *v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  _QWORD *v14;
  _QWORD *v15;
  BOOL v16;

  if (result)
  {
    v3 = result;
    v4 = *(_QWORD **)(result + 16);
    v5 = (_QWORD *)(result + 24);
    if (v4 != (_QWORD *)(result + 24))
    {
      v7 = *(_DWORD *)result;
      v8 = a2 - a3;
      do
      {
        v9 = (CA::Render::ImageQueue *)v4[4];
        if (*((_BYTE *)v9 + 12) != 25)
          __assert_rtn("CARenderPresentRelease", "render-updater.cpp", 16418, "obj->type () == Render::kTypeImageQueue");
        CA::Render::ImageQueue::did_display(v9, v7, a2, v8, 0.0);
        v10 = (unsigned int *)v4[4];
        if (v10)
        {
          v11 = v10 + 2;
          do
          {
            v12 = __ldaxr(v11);
            v13 = v12 - 1;
          }
          while (__stlxr(v13, v11));
          if (!v13)
            (*(void (**)(unsigned int *))(*(_QWORD *)v10 + 16))(v10);
        }
        v14 = (_QWORD *)v4[1];
        if (v14)
        {
          do
          {
            v15 = v14;
            v14 = (_QWORD *)*v14;
          }
          while (v14);
        }
        else
        {
          do
          {
            v15 = (_QWORD *)v4[2];
            v16 = *v15 == (_QWORD)v4;
            v4 = v15;
          }
          while (!v16);
        }
        v4 = v15;
      }
      while (v15 != v5);
    }
    std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(*(_QWORD **)(v3 + 24));
    JUMPOUT(0x186DBD990);
  }
  return result;
}

uint64_t CARenderUpdateSetIsolated(uint64_t result, int a2)
{
  int v2;
  unint64_t v3;

  v2 = 4;
  if (!a2)
    v2 = 0;
  v3 = *(_DWORD *)(result + 1064) & 0xFFFFFFFB | ((unint64_t)*(unsigned __int16 *)(result + 1068) << 32);
  *(_DWORD *)(result + 1064) = *(_DWORD *)(result + 1064) & 0xFFFFFFFB | v2;
  *(_WORD *)(result + 1068) = WORD2(v3);
  return result;
}

uint64_t CARenderUpdateSetAllowsHostedContexts(uint64_t result, int a2)
{
  int v2;
  unint64_t v3;

  v2 = 0x8000;
  if (!a2)
    v2 = 0;
  v3 = *(_DWORD *)(result + 1064) & 0xFFFF7FFF | ((unint64_t)*(unsigned __int16 *)(result + 1068) << 32);
  *(_DWORD *)(result + 1064) = *(_DWORD *)(result + 1064) & 0xFFFF7FFF | v2;
  *(_WORD *)(result + 1068) = WORD2(v3);
  return result;
}

uint64_t CARenderUpdateSetSkipsBackdropCollect(uint64_t result, int a2)
{
  int v2;
  unint64_t v3;

  v2 = 0x10000;
  if (!a2)
    v2 = 0;
  v3 = *(_DWORD *)(result + 1064) & 0xFFFEFFFF | ((unint64_t)*(unsigned __int16 *)(result + 1068) << 32);
  *(_DWORD *)(result + 1064) = *(_DWORD *)(result + 1064) & 0xFFFEFFFF | v2;
  *(_WORD *)(result + 1068) = WORD2(v3);
  return result;
}

uint64_t CARenderUpdateSetVBLTime(uint64_t result, double a2)
{
  *(double *)(result + 104) = a2;
  return result;
}

uint64_t CARenderUpdateSetInterval(uint64_t result, double a2)
{
  *(double *)(result + 112) = a2;
  return result;
}

void CARenderUpdateSetExcludedLayerIdentifiers(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = *(CFTypeRef *)(a1 + 912);
  if (v3 != cf)
  {
    if (v3)
      CFRelease(v3);
    *(_QWORD *)(a1 + 912) = cf;
    if (cf)
      CFRetain(cf);
  }
}

uint64_t CARenderUpdateInvalidateDetachedLayers(uint64_t result)
{
  *(_DWORD *)(result + 1064) |= 0x20000u;
  return result;
}

void CARenderUpdateAddContext(CA::Render::Update *a1, CA::Render::Context *this)
{
  uint64_t v4;
  CA::Render::Layer *v5;
  CA::Render::LayerNode *v6;
  const CA::Shape *v7;
  int64x2_t v8;

  v4 = CA::Render::Context::root_layer_handle(this);
  if (v4)
    v5 = *(CA::Render::Layer **)(v4 + 16);
  else
    v5 = 0;
  CA::Render::Update::add_context(a1, this, v5, 0);
  CA::Render::Update::added_all_contexts(a1, v6, v7, v8);
}

void CARenderUpdateAddContext3(CA::Render::Update *a1, CA::Render::Context *this)
{
  uint64_t v4;
  CA::Render::Layer *v5;

  v4 = CA::Render::Context::root_layer_handle(this);
  if (v4)
    v5 = *(CA::Render::Layer **)(v4 + 16);
  else
    v5 = 0;
  CA::Render::Update::add_context(a1, this, v5, 0);
}

void CARenderUpdateRemoveContextNode(uint64_t a1, CA::Render::Context *this)
{
  uint64_t v3;
  CA::Render::LayerNode *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int *i;
  _QWORD *v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;

  v3 = CA::Render::Context::root_layer_handle(this);
  if (v3)
  {
    v5 = *(_QWORD *)(v3 + 16);
    if (v5)
    {
      if ((*(_DWORD *)(a1 + 1064) & 4) == 0)
      {
        v6 = *(_QWORD *)(v5 + 144);
        if (v6)
        {
          v7 = *(unsigned int **)(v6 + 40);
          if (v7)
          {
            for (i = *(unsigned int **)(a1 + 224); i != (unsigned int *)(a1 + 216); i = (unsigned int *)*((_QWORD *)i + 1))
            {
              if (i == v7)
              {
                v10 = *(_QWORD *)v7;
                v9 = (_QWORD *)*((_QWORD *)v7 + 1);
                *(_QWORD *)(v10 + 8) = v9;
                *v9 = v10;
                *(_QWORD *)v7 = v7;
                *((_QWORD *)v7 + 1) = v7;
                v11 = v7 + 4;
                do
                {
                  v12 = __ldaxr(v11);
                  v13 = v12 - 1;
                }
                while (__stlxr(v13, v11));
                if (!v13)
                  CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v7, v4);
                return;
              }
            }
          }
        }
      }
    }
  }
}

uint64_t CARenderUpdateGetFlags(uint64_t a1)
{
  unsigned int v1;
  int v2;
  int v3;

  v1 = *(_DWORD *)(a1 + 268);
  v2 = v1 & 6 | ((v1 & 1) << 22) | (v1 >> 5) & 8 | (16 * ((v1 >> 3) & 3)) | 0x40;
  if ((v1 & 0x38000) == 0)
    v2 = *(_DWORD *)(a1 + 268) & 6 | ((*(_DWORD *)(a1 + 268) & 1) << 22) | (*(_DWORD *)(a1 + 268) >> 5) & 8 | (16 * ((*(_DWORD *)(a1 + 268) >> 3) & 3));
  v3 = (v1 >> 6) & 0x100 | (v1 >> 5) & 0x80 | (v1 >> 11) & 0x1000 | (v1 >> 5 << 13) | (v1 >> 9) & 0x70000 | (v1 >> 10) & 0x180000 | v2;
  if ((v1 & 0x80000000) != 0)
    v3 |= 0x200000u;
  return v3 | (16 * v1) & 0x800000;
}

int8x8_t CARenderUpdateAddFlags(uint64_t a1, unsigned int a2)
{
  uint32x4_t v2;
  int8x16_t v3;
  int8x16_t v4;
  unsigned int v5;
  int8x16_t v6;
  int8x8_t result;

  v2 = (uint32x4_t)vdupq_n_s32(a2);
  v4.i64[0] = vshlq_u32(v2, (uint32x4_t)xmmword_18474E380).u64[0];
  v3 = (int8x16_t)vshlq_u32(v2, (uint32x4_t)xmmword_18474E390);
  v3.i32[3] = vshlq_u32(v2, (uint32x4_t)xmmword_18474E3B0).i32[3];
  v4.i64[1] = vshlq_u32(v2, (uint32x4_t)xmmword_18474E3A0).i64[1];
  v5 = v3.i16[0] & 0x100 | a2 & 6 | (a2 >> 1) & 0x18;
  if ((a2 & 0x40) != 0)
    v5 |= 0x38000u;
  v6 = vorrq_s8(vandq_s8(v3, (int8x16_t)xmmword_18474E3D0), vandq_s8(v4, (int8x16_t)xmmword_18474E3C0));
  result = vorr_s8(*(int8x8_t *)v6.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  *(_DWORD *)(a1 + 268) |= result.i32[0] | result.i32[1] | v5;
  return result;
}

void CARenderUpdateAddRect(uint64_t a1, uint64_t a2, double a3, float64x2_t a4)
{
  int8x16_t v5;
  int8x16_t v6;
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x16_t v10;
  float64x2_t v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  float64x2_t v17;
  int32x4_t v18;
  const CA::Shape *v19;
  int32x4_t v20;
  CA::Shape *v21[2];
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v5 = *(int8x16_t *)(a2 + 16);
  a4.f64[0] = 0.0;
  v6 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a4, (float64x2_t)v5).i64[0], 0);
  v7.i64[1] = *(_QWORD *)(a2 + 24);
  *(double *)v7.i64 = -*(double *)v5.i64;
  v8 = vbslq_s8(v6, v7, v5);
  v9 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a4, (float64x2_t)vdupq_laneq_s64((int64x2_t)v5, 1)).i64[0], 0);
  v10.i64[0] = v8.i64[0];
  v10.i64[1] = *(_QWORD *)&vnegq_f64(*(float64x2_t *)&v5).f64[1];
  v11 = (float64x2_t)vbslq_s8(v9, v10, v8);
  v12 = (int8x16_t)vceqzq_f64(v11);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v12, 1), v12).u64[0] & 0x8000000000000000) != 0
    || (v13 = vorrq_s8((int8x16_t)vcltzq_f64(v11), (int8x16_t)vcgezq_f64(v11)),
        v14 = (int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v13), 1),
        (vornq_s8(v14, v13).u64[0] & 0x8000000000000000) != 0))
  {
    v20 = 0uLL;
  }
  else
  {
    v14.i64[0] = 0x8000000000000000;
    v15.i64[0] = *(_OWORD *)&vaddq_f64(*(float64x2_t *)a2, (float64x2_t)vbslq_s8(v6, v5, v14));
    v16.i64[0] = v15.i64[0];
    v16.i64[1] = *(_QWORD *)(a2 + 8);
    v15.i64[1] = *(_QWORD *)&vaddq_f64(*(float64x2_t *)&v5, *(float64x2_t *)a2).f64[1];
    v17 = (float64x2_t)vbslq_s8(v9, v15, v16);
    v18 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v17, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    v20 = vuzp1q_s32(v18, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v17, v11), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v18));
  }
  v22 = 0u;
  v23 = 0u;
  *(_OWORD *)v21 = 0u;
  CA::Shape::operator=((uint64_t)v21, &v20);
  CA::shape_union((CA::Shape **)(a1 + 16), v21, v19);
}

unint64_t CARenderUpdateSetRect(uint64_t a1, uint64_t a2, double a3, float64x2_t a4)
{
  int8x16_t v5;
  int8x16_t v6;
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x16_t v10;
  float64x2_t v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  float64x2_t v17;
  int32x4_t v18;
  const CA::Bounds *v19;
  unint64_t result;
  int32x4_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v5 = *(int8x16_t *)(a2 + 16);
  a4.f64[0] = 0.0;
  v6 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a4, (float64x2_t)v5).i64[0], 0);
  v7.i64[1] = *(_QWORD *)(a2 + 24);
  *(double *)v7.i64 = -*(double *)v5.i64;
  v8 = vbslq_s8(v6, v7, v5);
  v9 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a4, (float64x2_t)vdupq_laneq_s64((int64x2_t)v5, 1)).i64[0], 0);
  v10.i64[0] = v8.i64[0];
  v10.i64[1] = *(_QWORD *)&vnegq_f64(*(float64x2_t *)&v5).f64[1];
  v11 = (float64x2_t)vbslq_s8(v9, v10, v8);
  v12 = (int8x16_t)vceqzq_f64(v11);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v12, 1), v12).u64[0] & 0x8000000000000000) != 0
    || (v13 = vorrq_s8((int8x16_t)vcltzq_f64(v11), (int8x16_t)vcgezq_f64(v11)),
        v14 = (int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v13), 1),
        (vornq_s8(v14, v13).u64[0] & 0x8000000000000000) != 0))
  {
    v21 = 0uLL;
  }
  else
  {
    v14.i64[0] = 0x8000000000000000;
    v15.i64[0] = *(_OWORD *)&vaddq_f64(*(float64x2_t *)a2, (float64x2_t)vbslq_s8(v6, v5, v14));
    v16.i64[0] = v15.i64[0];
    v16.i64[1] = *(_QWORD *)(a2 + 8);
    v15.i64[1] = *(_QWORD *)&vaddq_f64(*(float64x2_t *)&v5, *(float64x2_t *)a2).f64[1];
    v17 = (float64x2_t)vbslq_s8(v9, v15, v16);
    v18 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v17, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    v21 = vuzp1q_s32(v18, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v17, v11), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v18));
  }
  CA::Shape::unref(*(CA::Shape **)(a1 + 16));
  result = CA::Shape::new_shape((CA::Shape *)&v21, v19);
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

void CARenderUpdateAddRegion(uint64_t a1)
{
  CA::Shape **v2;
  const CA::Shape *v3;
  CA::Shape *v4;

  v2 = (CA::Shape **)CA::Shape::new_shape();
  if (v2)
  {
    v4 = (CA::Shape *)v2;
    CA::shape_union((CA::Shape **)(a1 + 16), v2, v3);
    CA::Shape::unref(v4);
  }
}

void CARenderUpdateSetRegion(CA::Render::Update *a1)
{
  const CA::Shape *v2;
  CA::Shape *v3;

  v2 = (const CA::Shape *)CA::Shape::new_shape();
  if (v2)
  {
    v3 = v2;
    CA::Render::Update::set_shape(a1, v2);
    CA::Shape::unref(v3);
  }
}

uint64_t CARenderUpdateCopyRegion(uint64_t a1)
{
  uint64_t v1;
  int v2;

  v1 = *(_QWORD *)(a1 + 16);
  if ((v1 & 1) != 0)
  {
    if (v1 == 1)
      goto LABEL_6;
LABEL_7:
    CGSNewRegionWithRect();
    return 0;
  }
  v2 = *(_DWORD *)(v1 + 4);
  if (v2 == 12)
    goto LABEL_7;
  if (v2 == 6)
  {
LABEL_6:
    CGSNewEmptyRegion();
    return 0;
  }
  CGSNewRegionWithData();
  return 0;
}

int8x16_t CARenderUpdateGetBounds(uint64_t a1, int32x4_t a2, int32x4_t a3)
{
  unsigned __int32 v3;
  int8x16_t v4;
  uint64_t v5;
  int64x2_t v6;

  if (*(_DWORD *)(a1 + 200) <= *(_DWORD *)(a1 + 204))
    v3 = *(_DWORD *)(a1 + 204);
  else
    v3 = *(_DWORD *)(a1 + 200);
  a2.i32[0] = 1073741822;
  a3.i32[0] = v3;
  v4 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(a3, a2), 0);
  v5 = *(_QWORD *)(a1 + 192);
  v6.i64[0] = (int)v5;
  v6.i64[1] = SHIDWORD(v5);
  return vbslq_s8(v4, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v6));
}

uint64_t CARenderUpdateGetSeed(uint64_t a1)
{
  return *(unsigned int *)(a1 + 248);
}

double CARenderUpdateGetTime(uint64_t a1)
{
  return *(double *)(a1 + 72);
}

uint64_t CARenderUpdateGetTimeStamp(uint64_t a1)
{
  return *(_QWORD *)(a1 + 160);
}

double CARenderUpdateGetNextTime(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

_QWORD *CARenderUpdateResetNextTime(_QWORD *result)
{
  result[11] = 0;
  result[12] = 0;
  result[10] = 0x7FF0000000000000;
  return result;
}

double CARenderUpdateGetBeginTime(uint64_t a1)
{
  double result;

  result = *(double *)(a1 + 768);
  if (result == 1.79769313e308)
    return 0.0;
  return result;
}

uint64_t CARenderUpdateSetStartTime(uint64_t result, double a2)
{
  *(double *)(result + 120) = a2;
  return result;
}

uint64_t CARenderUpdateGetPrepareLayerCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 752);
}

uint64_t CARenderUpdateGetPrepareLayer0Count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 756);
}

CA::Render::Update *CARenderUpdateFinish(CA::Render::Update *result, CA::Render::LayerNode *a2)
{
  if (result)
  {
    CA::Render::Update::~Update(result, a2);
    JUMPOUT(0x186DBD990);
  }
  return result;
}

void CARenderUpdateSetEDRAttributes(_OWORD *a1, float a2, float a3, float a4)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v4 = a1[23];
  v8 = a1[22];
  v9 = v4;
  v5 = a1[27];
  v12 = a1[26];
  v13 = v5;
  v6 = a1[29];
  v14 = a1[28];
  v15 = v6;
  v7 = a1[25];
  v10 = a1[24];
  v11 = v7;
  *(_QWORD *)&v9 = __PAIR64__(LODWORD(a2), LODWORD(a4));
  *((float *)&v8 + 3) = a3;
  CA::Render::Update::set_display_attributes((uint64_t)a1, (float *)&v8);
}

__n128 CARenderUpdateSetDisplayType(_OWORD *a1, int a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __n128 result;
  _OWORD v7[3];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = a1[27];
  v9 = a1[26];
  v10 = v2;
  v3 = a1[29];
  v11 = a1[28];
  v12 = v3;
  v4 = a1[23];
  v7[0] = a1[22];
  v7[1] = v4;
  v5 = a1[25];
  v7[2] = a1[24];
  v8 = v5;
  HIDWORD(v8) = a2;
  CA::Render::Update::set_display_attributes((uint64_t)a1, (float *)v7);
  return result;
}

void CARenderUpdateSetDisplayAttributes(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  __int128 v4;
  float v5;
  NSObject *v6;
  unsigned int v7;
  uint8_t buf[8];
  _BYTE v9[24];
  __int128 v10;
  uint64_t v11;
  _OWORD v12[3];
  _BYTE v13[20];
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    v3 = *(_DWORD *)a2;
    if ((*(_DWORD *)a2 - 5) > 0xFFFFFFFB)
    {
      *(_QWORD *)&v9[16] = 0x3F80000000000000;
      memset(v12, 0, sizeof(v12));
      *(_OWORD *)v9 = 0u;
      v10 = xmmword_18474E020;
      v11 = 0;
      LOWORD(v12[0]) = 0;
      *(_DWORD *)v13 = 1065353216;
      *(_OWORD *)&v13[4] = 0uLL;
      v14 = -1;
      *(_QWORD *)buf = *(_QWORD *)(a2 + 4);
      v4 = *(_OWORD *)(a2 + 12);
      *(_OWORD *)&v9[4] = v4;
      DWORD1(v12[0]) = *(_DWORD *)(a2 + 28);
      DWORD2(v12[0]) = 1;
      if (*(float *)&v4 > 0.0 && *((float *)&v4 + 2) > 0.0)
      {
        v5 = *(float *)&v4 / (*((float *)&v4 + 2) * 100.0);
        *(float *)&v9[20] = v5;
      }
      if (v3 >= 2)
      {
        BYTE6(v11) = *(_BYTE *)(a2 + 32);
        if (v3 != 2)
        {
          DWORD2(v12[0]) = *(_DWORD *)(a2 + 36);
          if (v3 >= 4)
            *(_OWORD *)v13 = *(_OWORD *)(a2 + 40);
        }
      }
      CA::Render::Update::set_display_attributes(a1, (float *)buf);
    }
    else if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v6 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        v7 = *(_DWORD *)a2;
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v7;
        _os_log_impl(&dword_184457000, v6, OS_LOG_TYPE_ERROR, "Invalid display attributes version %d", buf, 8u);
      }
    }
  }
}

uint64_t CARenderUpdateSetTonemapAccelerator(uint64_t result, int a2)
{
  *(_DWORD *)(result + 480) = a2;
  return result;
}

uint64_t CARenderUpdateSetProtectionOptions(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 288) |= a2;
  return result;
}

uint64_t CARenderUpdateGetProtectionOptions(uint64_t a1)
{
  return *(_QWORD *)(a1 + 288);
}

uint64_t CAMachPortCreate(int a1)
{
  uint64_t result;

  if (!a1)
    return 0;
  if (!CAMachPortGetTypeID::type)
    CAMachPortGetTypeID::type = _CFRuntimeRegisterClass();
  result = _CFRuntimeCreateInstance();
  if (result)
    *(_DWORD *)(result + 16) = a1;
  return result;
}

uint64_t caMachPortFinalize(uint64_t result)
{
  mach_port_name_t v1;

  if (result)
  {
    v1 = *(_DWORD *)(result + 16);
    if (v1)
      return mach_port_deallocate(*MEMORY[0x1E0C83DA0], v1);
  }
  return result;
}

BOOL caMachPortEqual(_DWORD *a1, _DWORD *a2)
{
  return a1[4] == a2[4];
}

uint64_t caMachPortHash(unsigned int *a1)
{
  return a1[4];
}

CFStringRef caMachPortCopyFormatDescription(const void *a1, const __CFDictionary *a2)
{
  const __CFAllocator *v4;

  v4 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, a2, CFSTR("<CAMachPort %p>"), a1);
}

CFStringRef caMachPortCopyDebugDescription(CFStringRef result)
{
  CFStringRef v1;
  const __CFAllocator *v2;

  if (result)
  {
    v1 = result;
    v2 = CFGetAllocator(result);
    return CFStringCreateWithFormat(v2, 0, CFSTR("<CAMachPort %p mach_port = %u>"), v1, LODWORD(v1->data));
  }
  return result;
}

uint64_t CAMachPortGetTypeID()
{
  uint64_t result;

  result = CAMachPortGetTypeID::type;
  if (!CAMachPortGetTypeID::type)
  {
    result = _CFRuntimeRegisterClass();
    CAMachPortGetTypeID::type = result;
  }
  return result;
}

uint64_t CAMachPortGetPort(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 16);
  return result;
}

uint32x2_t CA::Render::convert_cgcolor(CA::Render *this, CGColor *a2, CGColorSpace *a3, float *a4, CA::Render::Pattern **a5)
{
  float32x2_t v6;
  int v7;
  int v8;
  uint32x2_t result;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v10 = 0uLL;
  CA::Render::convert_cgcolor_to_float(this, a2, (CGColorSpace *)&v10, a4, a5);
  v6 = (float32x2_t)vdup_n_s32(0x437F0000u);
  v7 = (int)(float)((float)(*(float *)&v10 * 255.0) + 0.5) & ~((int)(float)((float)(*(float *)&v10 * 255.0) + 0.5) >> 31);
  v8 = (int)(float)((float)(*((float *)&v10 + 3) * 255.0) + 0.5) & ~((int)(float)((float)(*((float *)&v10 + 3) * 255.0)
                                                                                + 0.5) >> 31);
  if (v7 >= 255)
    v7 = 255;
  if (v8 >= 255)
    v8 = 255;
  result = vshl_u32((uint32x2_t)vmin_s32(vmax_s32(vcvt_s32_f32(vmla_f32((float32x2_t)0x3F0000003F000000, v6, *(float32x2_t *)((char *)&v10 + 4))), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x800000010);
  *(_DWORD *)a3 = result.i32[0] | (v7 << 24) | v8 | result.i32[1];
  return result;
}

unsigned int *`anonymous namespace'::render_object_finalize(_anonymous_namespace_ *this, const void *a2)
{
  unsigned int *result;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  result = (unsigned int *)*((_QWORD *)this + 2);
  if (result)
  {
    v3 = result + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)result + 16))(result);
  }
  return result;
}

CFStringRef `anonymous namespace'::render_object_copy_format_description(_anonymous_namespace_ *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  const __CFAllocator *v5;

  v5 = CFGetAllocator(this);
  return CFStringCreateWithFormat(v5, a2, CFSTR("<CARenderObject %p>"), this);
}

CFStringRef `anonymous namespace'::render_object_copy_debug_description(_anonymous_namespace_ *this, const void *a2)
{
  const __CFAllocator *v3;

  v3 = CFGetAllocator(this);
  return CFStringCreateWithFormat(v3, 0, CFSTR("<CARenderObject %p>"), this);
}

uint64_t CA::Render::numeric_value_count(CA::Render *this, const void *a2)
{
  CFTypeID v3;
  uint64_t v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  CA::Render *ValueAtIndex;
  const void *v10;

  if (CA::Render::initialize_types(void)::once[0] != -1)
    dispatch_once(CA::Render::initialize_types(void)::once, &__block_literal_global_4814);
  v3 = CFGetTypeID(this);
  if (v3 == CA::Render::color_type && !CGColorGetPattern(this))
    return 4;
  if (v3 == CA::Render::number_type || v3 == CA::Render::BOOL_type)
    return 1;
  if (v3 != CA::Render::array_type)
    return 0;
  Count = CFArrayGetCount(this);
  if (!Count)
    return 0;
  v7 = Count;
  v8 = 0;
  v5 = 0;
  do
  {
    ValueAtIndex = (CA::Render *)CFArrayGetValueAtIndex(this, v8);
    v5 += CA::Render::numeric_value_count(ValueAtIndex, v10);
    ++v8;
  }
  while (v7 != v8);
  return v5;
}

uint64_t CA::Render::copy_numeric_value(CA::Render *this, CGColorSpace *a2, CGColorSpace *a3, double *a4)
{
  CFTypeID v7;
  uint64_t v8;
  double v9;
  __int128 v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  CA::Render *ValueAtIndex;
  double *v15;
  float64x2_t v17;
  __int128 v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (CA::Render::initialize_types(void)::once[0] != -1)
    dispatch_once(CA::Render::initialize_types(void)::once, &__block_literal_global_4814);
  v7 = CFGetTypeID(this);
  if (v7 == CA::Render::color_type)
  {
    if (!CGColorGetPattern(this))
    {
      v17 = 0u;
      v18 = 0u;
      CA_CGColorGetRGBComponents(this, a2, v17.f64);
      v10 = v18;
      *(float64x2_t *)a3 = vmulq_n_f64(v17, *((double *)&v18 + 1));
      *((double *)a3 + 2) = *(double *)&v10 * *((double *)&v10 + 1);
      *((_QWORD *)a3 + 3) = *((_QWORD *)&v10 + 1);
      return 4;
    }
    return 0;
  }
  if (v7 == CA::Render::number_type)
  {
    if (this)
    {
      v17.f64[0] = 0.0;
      CFNumberGetValue(this, kCFNumberDoubleType, &v17);
      v9 = v17.f64[0];
    }
    else
    {
      v9 = 0.0;
    }
LABEL_20:
    *(double *)a3 = v9;
    return 1;
  }
  if (v7 == CA::Render::BOOL_type)
  {
    v9 = 0.0;
    if ((CA::Render *)*MEMORY[0x1E0C9AE40] != this)
      v9 = 1.0;
    goto LABEL_20;
  }
  if (v7 != CA::Render::array_type)
    return 0;
  Count = CFArrayGetCount(this);
  if (!Count)
    return 0;
  v12 = Count;
  v13 = 0;
  v8 = 0;
  do
  {
    ValueAtIndex = (CA::Render *)CFArrayGetValueAtIndex(this, v13);
    v8 += CA::Render::copy_numeric_value(ValueAtIndex, a2, (CGColorSpace *)((char *)a3 + 8 * v8), v15);
    ++v13;
  }
  while (v12 != v13);
  return v8;
}

void CARenderCollect(int a1)
{
  uint64_t v2;
  double v3;

  if ((a1 & 0x80000000) == 0)
  {
    v2 = mach_absolute_time();
    v3 = CATimeWithHostTime(v2);
    CA::Render::collect((CA::Render *)(a1 != 0), v3);
  }
}

uint64_t CARenderGetGlobalFeatureFlags()
{
  return global_feature_flags;
}

uint64_t CARenderSetGlobalFeatureFlags(uint64_t result)
{
  global_feature_flags = result;
  return result;
}

uint64_t CA::fo_removed_context(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v7;
  double v8;

  if (!a3 || !a4)
    __assert_rtn("fo_removed_context", "CAContextInternal.mm", 355, "server_id != 0 && client_id != 0");
  v7 = mach_absolute_time();
  v8 = CATimeWithHostTime(v7);
  return CA::Context::send_deferrals(a3, a4, a2, 0, v8);
}

CFArrayRef CA::Context::retain_objc_contexts(CA::Context *this)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _DWORD **v5;
  _DWORD *v6;
  size_t v7;
  char *v8;
  CFIndex v9;
  _DWORD *v10;
  id *v11;
  id Weak;
  CFArrayRef v13;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_lock);
  if ((CA::all_contexts(void)::contexts_data_initialized & 1) == 0)
  {
    v13 = 0;
    CA::all_contexts(void)::contexts_data = 0;
    qword_1ECDC6558 = 0;
    qword_1ECDC6560 = 0;
    CA::all_contexts(void)::contexts_data_initialized = 1;
    goto LABEL_18;
  }
  v2 = (_QWORD *)CA::all_contexts(void)::contexts_data;
  v3 = qword_1ECDC6558;
  if (CA::all_contexts(void)::contexts_data == qword_1ECDC6558)
    goto LABEL_17;
  v4 = 0;
  v5 = (_DWORD **)CA::all_contexts(void)::contexts_data;
  do
  {
    v6 = *v5++;
    if (*v6)
      ++v4;
  }
  while (v5 != (_DWORD **)qword_1ECDC6558);
  if (!v4)
  {
LABEL_17:
    v13 = 0;
    goto LABEL_18;
  }
  MEMORY[0x1E0C80A78](v1);
  v8 = (char *)v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v8, v7);
  v9 = 0;
  do
  {
    v10 = (_DWORD *)*v2;
    if (!*(_DWORD *)*v2)
      goto LABEL_13;
    v11 = (id *)(v10 + 20);
    if (*((_BYTE *)v10 + 88))
    {
      Weak = objc_loadWeak(v11);
      if (!Weak)
        goto LABEL_13;
LABEL_12:
      *(_QWORD *)&v8[8 * v9++] = Weak;
      goto LABEL_13;
    }
    Weak = *v11;
    if (Weak)
      goto LABEL_12;
LABEL_13:
    ++v2;
  }
  while (v2 != (_QWORD *)v3);
  v13 = CFArrayCreate(0, (const void **)v8, v9, MEMORY[0x1E0C9B378]);
LABEL_18:
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
  return v13;
}

void sub_18463CD88(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
  _Unwind_Resume(a1);
}

int *CA::Context::retain_context_with_client_id(CA::Context *this)
{
  int v1;
  int **i;
  int *v3;
  int v4;

  v1 = (int)this;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Context::_lock);
  if ((CA::all_contexts(void)::contexts_data_initialized & 1) != 0)
  {
    for (i = (int **)CA::all_contexts(void)::contexts_data; ; ++i)
    {
      if (i == (int **)qword_1ECDC6558)
      {
        v3 = 0;
        goto LABEL_9;
      }
      v3 = *i;
      v4 = **i;
      if (v4)
      {
        if (v3[1] == v1)
          break;
      }
    }
    *v3 = v4 + 1;
  }
  else
  {
    v3 = 0;
    CA::all_contexts(void)::contexts_data = 0;
    qword_1ECDC6558 = 0;
    qword_1ECDC6560 = 0;
    CA::all_contexts(void)::contexts_data_initialized = 1;
  }
LABEL_9:
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Context::_lock);
  return v3;
}

void CA::Context::Generic::~Generic(CA::Context::Generic *this)
{
  JUMPOUT(0x186DBD990);
}

void CA::Context::ping(CA::Context *this)
{
  pthread_mutex_t *v2;
  unsigned int v3;
  mach_port_t reply_port;
  mach_msg_return_t v5;
  mach_error_t v6;
  NSObject *v7;
  int v8;
  char *v9;
  _BYTE msg[36];
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v2 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  if (*((_QWORD *)this + 13))
  {
    pthread_mutex_unlock(v2);
    CA::Render::post_notification(0xCu, 0, 0, 0);
    return;
  }
  v3 = *((_DWORD *)this + 40);
  if (v3 && (*((_BYTE *)this + 241) & 2) == 0)
  {
    v11 = 0;
    *(_OWORD *)&msg[20] = 0u;
    *(_DWORD *)&msg[4] = 0;
    reply_port = mig_get_reply_port();
    *(_QWORD *)&msg[8] = __PAIR64__(reply_port, v3);
    *(_DWORD *)msg = 5395;
    *(_QWORD *)&msg[16] = 0x9D0800000000;
    if (MEMORY[0x1E0C85B60])
    {
      voucher_mach_msg_set((mach_msg_header_t *)msg);
      reply_port = *(_DWORD *)&msg[12];
    }
    v5 = mach_msg((mach_msg_header_t *)msg, 3, 0x18u, 0x2Cu, reply_port, 0, 0);
    v6 = v5;
    if ((v5 - 268435458) <= 0xE && ((1 << (v5 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(*(mach_port_t *)&msg[12]);
      goto LABEL_22;
    }
    if (v5)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    }
    else
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v6 = -308;
      }
      else if (*(_DWORD *)&msg[20] == 40300)
      {
        v6 = -300;
        if ((*(_DWORD *)msg & 0x80000000) == 0 && *(_DWORD *)&msg[4] == 36 && !*(_DWORD *)&msg[8])
        {
          v6 = *(_DWORD *)&msg[32];
          if (!*(_DWORD *)&msg[32])
            goto LABEL_31;
        }
      }
      else
      {
        v6 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
LABEL_22:
    if (v6)
    {
      if (v6 == 268435459)
      {
        *((_BYTE *)this + 241) |= 2u;
      }
      else if (v6 == -81182719)
      {
        x_log_crash("Unentitled call to server!");
        abort();
      }
      if (x_log_hook_p())
      {
        mach_error_string(v6);
        x_log_();
      }
      else
      {
        v7 = x_log_category_api;
        if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
        {
          v8 = *((_DWORD *)this + 1);
          v9 = mach_error_string(v6);
          *(_DWORD *)msg = 67109634;
          *(_DWORD *)&msg[4] = v8;
          *(_WORD *)&msg[8] = 1024;
          *(_DWORD *)&msg[10] = v6;
          *(_WORD *)&msg[14] = 2080;
          *(_QWORD *)&msg[16] = v9;
          _os_log_impl(&dword_184457000, v7, OS_LOG_TYPE_ERROR, "Failed to ping server (client=0x%x) [0x%x %s]", msg, 0x18u);
        }
      }
    }
  }
LABEL_31:
  pthread_mutex_unlock(v2);
}

void sub_18463D110(_Unwind_Exception *a1)
{
  pthread_mutex_t *v1;

  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

CFTypeRef CA::Context::retain_layer(CA::Context *this)
{
  pthread_mutex_t *v2;
  const void *v3;
  CFTypeRef v4;

  v2 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  v3 = (const void *)*((_QWORD *)this + 12);
  if (v3)
    v4 = CFRetain(v3);
  else
    v4 = 0;
  pthread_mutex_unlock(v2);
  return v4;
}

void sub_18463D174(_Unwind_Exception *a1)
{
  pthread_mutex_t *v1;

  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::Context::new_image_slot(CA::Context *this, CA::Render *a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  uint64_t v10;
  uint64_t v11;
  unsigned int v13;
  mach_port_t reply_port;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  NSObject *v18;
  int v19;
  char *v20;
  uint64_t msg;
  unint64_t msg_8;
  __int128 msg_16;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v10 = *((_QWORD *)this + 13);
  if (v10)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v10 + 72));
    v11 = CA::Render::Context::new_image_slot(*((CA::Render::Context **)this + 13), a2, a3, a4, a5);
    pthread_mutex_unlock((pthread_mutex_t *)(*((_QWORD *)this + 13) + 72));
    return v11;
  }
  if ((*((_BYTE *)this + 241) & 2) != 0)
    return 0;
  v13 = *((_DWORD *)this + 40);
  *((_QWORD *)&msg_16 + 1) = *MEMORY[0x1E0C804E8];
  v24 = __PAIR64__(a3, a2);
  v25 = __PAIR64__(a5, a4);
  reply_port = mig_get_reply_port();
  msg = 5395;
  msg_8 = __PAIR64__(reply_port, v13);
  *(_QWORD *)&msg_16 = 0x9D1400000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    reply_port = HIDWORD(msg_8);
  }
  v15 = mach_msg((mach_msg_header_t *)&msg, 3, 0x30u, 0x30u, reply_port, 0, 0);
  v16 = v15;
  if ((v15 - 268435458) <= 0xE && ((1 << (v15 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(HIDWORD(msg_8));
    if (!(_DWORD)v16)
      return v16;
    goto LABEL_28;
  }
  if ((_DWORD)v15)
  {
    mig_dealloc_reply_port(HIDWORD(msg_8));
LABEL_28:
    if ((_DWORD)v16 == 268435459)
    {
      *((_BYTE *)this + 241) |= 2u;
    }
    else if ((_DWORD)v16 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    if (x_log_hook_p())
    {
      mach_error_string(v16);
      x_log_();
    }
    else
    {
      v18 = x_log_category_api;
      if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
      {
        v19 = *((_DWORD *)this + 1);
        v20 = mach_error_string(v16);
        LODWORD(msg) = 67110658;
        HIDWORD(msg) = (_DWORD)a2;
        LOWORD(msg_8) = 1024;
        *(_DWORD *)((char *)&msg_8 + 2) = a3;
        HIWORD(msg_8) = 1024;
        LODWORD(msg_16) = a4;
        WORD2(msg_16) = 1024;
        *(_DWORD *)((char *)&msg_16 + 6) = a5;
        WORD5(msg_16) = 1024;
        HIDWORD(msg_16) = v19;
        LOWORD(v24) = 1024;
        *(_DWORD *)((char *)&v24 + 2) = v16;
        HIWORD(v24) = 2080;
        v25 = (unint64_t)v20;
        _os_log_impl(&dword_184457000, v18, OS_LOG_TYPE_ERROR, "Failed to create %dx%d image slot (alpha=%d wide=%d) (client=0x%x) [0x%x %s]", (uint8_t *)&msg, 0x30u);
      }
    }
    return 0;
  }
  if (DWORD1(msg_16) == 71)
  {
    v16 = 4294966988;
    goto LABEL_27;
  }
  if (DWORD1(msg_16) != 40312)
  {
    v16 = 4294966995;
    goto LABEL_27;
  }
  if ((msg & 0x80000000) != 0)
    goto LABEL_26;
  if (HIDWORD(msg) != 40)
  {
    if (HIDWORD(msg) == 36)
    {
      if ((_DWORD)msg_8)
        v17 = 1;
      else
        v17 = (_DWORD)v24 == 0;
      if (v17)
        v16 = 4294966996;
      else
        v16 = v24;
      goto LABEL_27;
    }
LABEL_26:
    v16 = 4294966996;
    goto LABEL_27;
  }
  if ((_DWORD)msg_8)
    goto LABEL_26;
  v16 = v24;
  if (!(_DWORD)v24)
    return HIDWORD(v24);
LABEL_27:
  mach_msg_destroy((mach_msg_header_t *)&msg);
  if ((_DWORD)v16)
    goto LABEL_28;
  return v16;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long long>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v1 + 24);
    operator delete(v1);
  }
}

void CA::WindowServer::IOMFBFlipBook::~IOMFBFlipBook(CA::WindowServer::IOMFBFlipBook *this)
{
  malloc_zone_t *malloc_zone;

  CA::WindowServer::IOMFBFlipBook::~IOMFBFlipBook(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

{
  uint64_t v2;
  CA::OGL::DebugRenderer *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  *(_QWORD *)this = off_1E158D9B0;
  CA::Render::remove_observer(0x47u, 0, (uint64_t)CA::WindowServer::IOMFBFlipBook::get_display_debug_properties, (uint64_t)this);
  v2 = *((_QWORD *)this + 37);
  if (v2)
    MEMORY[0x186DBD990](v2, 0x1020C4007B5AB7FLL);
  v3 = (CA::OGL::DebugRenderer *)*((_QWORD *)this + 38);
  if (v3)
  {
    CA::OGL::DebugRenderer::~DebugRenderer(v3);
    MEMORY[0x186DBD990]();
  }
  *(_QWORD *)this = off_1E1590D20;
  CA::WindowServer::FlipBook::free_surfaces((os_unfair_lock_s *)this);
  v4 = (void *)*((_QWORD *)this + 19);
  if (v4)
  {
    *((_QWORD *)this + 20) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 16);
  if (v5)
  {
    *((_QWORD *)this + 17) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 13);
  if (v6)
  {
    *((_QWORD *)this + 14) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 10);
  if (v7)
  {
    *((_QWORD *)this + 11) = v7;
    operator delete(v7);
  }
}

void CA::WindowServer::IOMFBFlipBook::_enter(uint64_t a1, __int16 a2)
{
  NSObject *v4;
  __int16 v5;
  const __CFString *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  char v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v4 = x_log_category_flipbook;
    if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v16) = 0;
      _os_log_impl(&dword_184457000, v4, OS_LOG_TYPE_DEFAULT, "IOMFBFlipBook::_enter", (uint8_t *)&v16, 2u);
    }
  }
  v17 = 0;
  v16 = 0;
  v5 = a2;
  CA::WindowServer::FlipBookStateChangeNotifier::FlipBookStateChangeNotifier((uint64_t)&v16, a2);
  if ((a2 & 0xFF00) == 0x100)
  {
    CA::IOMobileFramebuffer::swap_wait((CA::IOMobileFramebuffer *)(*(_QWORD *)(a1 + 16) + 25536));
    CA::WindowServer::IOMFBDisplay::set_aot_service_property(*(CA::WindowServer::IOMFBDisplay **)(a1 + 16), 1);
  }
  v7 = *(_QWORD **)(a1 + 296);
  if (v7)
  {
    if (CADeviceUseCIF10::once != -1)
      dispatch_once(&CADeviceUseCIF10::once, &__block_literal_global_9735);
    v8 = 0;
    if (CADeviceUseCIF10::enable_cif10)
      v9 = 1999843442;
    else
      v9 = 1111970369;
    v10 = *(_QWORD *)(*v7 + 16);
    v11 = 1;
    do
    {
      v12 = v11;
      v13 = &v7[v8];
      v13[2] = CA::Render::create_iosurface_with_pixel_format((CA::Render *)v9, *(_DWORD *)(v10 + 176), *(_DWORD *)(v10 + 180), 4u, 0, CFSTR("CA Server Flipbook Framebuffer"), v6);
      v14 = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*v7 + 88))(*v7);
      v15 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)*v14 + 672))(*v14, 1, 0, 0, v13[2]);
      v11 = 0;
      v13[4] = v15;
      v8 = 1;
    }
    while ((v12 & 1) != 0);
  }
  CA::WindowServer::FlipBook::_enter(a1, v5);
  if ((_BYTE)v17)
  {
    BYTE4(v16) = 0;
    CA::Render::post_notification(0x3Du, 0, (uint64_t)&v16, 0);
  }
}

void CA::WindowServer::IOMFBFlipBook::_exit(uint64_t a1, __int16 a2)
{
  NSObject *v4;
  _QWORD *v5;
  uint64_t v6;
  char v7;
  char v8;
  _QWORD *v9;
  const void *v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v4 = x_log_category_flipbook;
    if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      _os_log_impl(&dword_184457000, v4, OS_LOG_TYPE_DEFAULT, "IOMFBFlipBook::_exit", (uint8_t *)&v12, 2u);
    }
  }
  v13 = 0;
  v12 = 0;
  CA::WindowServer::FlipBookStateChangeNotifier::FlipBookStateChangeNotifier((uint64_t)&v12, a2);
  CA::WindowServer::FlipBook::_exit(a1);
  v5 = *(_QWORD **)(a1 + 296);
  if (v5)
  {
    v6 = 0;
    v7 = 1;
    do
    {
      v8 = v7;
      v9 = &v5[v6];
      v10 = (const void *)v9[2];
      if (v10)
      {
        CFRelease(v10);
        v11 = (uint64_t *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*v5 + 88))(*v5);
        CA::OGL::Context::release_surface(*v11, v9[4]);
        v9[2] = 0;
        v9[4] = 0;
      }
      v7 = 0;
      v6 = 1;
    }
    while ((v8 & 1) != 0);
  }
  CA::WindowServer::IOMFBDisplay::set_aot_service_property(*(CA::WindowServer::IOMFBDisplay **)(a1 + 16), 0);
  if ((_BYTE)v13)
  {
    BYTE4(v12) = 0;
    CA::Render::post_notification(0x3Du, 0, (uint64_t)&v12, 0);
  }
}

void CA::WindowServer::IOMFBFlipBook::_suspend(uint64_t a1, __int16 a2)
{
  NSObject *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v4 = x_log_category_flipbook;
    if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v5) = 0;
      _os_log_impl(&dword_184457000, v4, OS_LOG_TYPE_DEFAULT, "IOMFBFlipBook::_suspend", (uint8_t *)&v5, 2u);
    }
  }
  v6 = 0;
  v5 = 0;
  CA::WindowServer::FlipBookStateChangeNotifier::FlipBookStateChangeNotifier((uint64_t)&v5, a2);
  CA::WindowServer::FlipBook::_suspend(a1);
  CA::WindowServer::IOMFBDisplay::set_aot_service_property(*(CA::WindowServer::IOMFBDisplay **)(a1 + 16), 0);
  if ((_BYTE)v6)
  {
    BYTE4(v5) = 0;
    CA::Render::post_notification(0x3Du, 0, (uint64_t)&v5, 0);
  }
}

void CA::WindowServer::IOMFBFlipBook::_resume(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v4 = x_log_category_flipbook;
    if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v5) = 0;
      _os_log_impl(&dword_184457000, v4, OS_LOG_TYPE_DEFAULT, "IOMFBFlipBook::_resume", (uint8_t *)&v5, 2u);
    }
  }
  v6 = 0;
  v5 = 0;
  CA::WindowServer::FlipBookStateChangeNotifier::FlipBookStateChangeNotifier((uint64_t)&v5, a2);
  if ((a2 & 0xFF00) == 0x100)
    CA::WindowServer::IOMFBDisplay::set_aot_service_property(*(CA::WindowServer::IOMFBDisplay **)(a1 + 16), 1);
  CA::WindowServer::FlipBook::_resume((uint64_t *)a1, a2 & 0xFFFFFF);
  if ((_BYTE)v6)
  {
    BYTE4(v5) = 0;
    CA::Render::post_notification(0x3Du, 0, (uint64_t)&v5, 0);
  }
}

uint64_t CA::WindowServer::IOMFBFlipBook::suspended_on_frame(uint64_t this, char a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(this + 296);
  if (v2)
    *(_BYTE *)(v2 + 8) = a2;
  return this;
}

void CA::WindowServer::IOMFBFlipBook::resume_frame(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  int v9;
  int v10;
  CA::Shape *v11;
  CA::Shape *v12;
  _DWORD *v13;
  int v14;
  int v15;
  _DWORD v16[4];
  _DWORD v17[4];
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v4 = x_log_category_flipbook;
    if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *(_QWORD *)(a2 + 32);
      v6 = *(_QWORD *)(a2 + 40);
      *(_DWORD *)buf = 134218240;
      v25 = v5;
      v26 = 2048;
      v27 = v6;
      _os_log_impl(&dword_184457000, v4, OS_LOG_TYPE_DEFAULT, "resume frame seed %llu timestamp %llu", buf, 0x16u);
    }
  }
  if (use_dcp_blitter(void)::once[0] != -1)
    dispatch_once(use_dcp_blitter(void)::once, &__block_literal_global_4974);
  if (use_dcp_blitter(void)::ret)
  {
    v7 = *(_QWORD **)(a1 + 296);
    v8 = *(_QWORD *)(a2 + 8);
    v9 = *(_DWORD *)(a2 + 76);
    v10 = *(_DWORD *)(a2 + 80);
    v21 = 0;
    v22 = v9;
    v23 = v10;
    v18 = *(_QWORD *)(a2 + 68);
    v19 = v9;
    v20 = v10;
    v11 = (CA::Shape *)&v21;
    v12 = (CA::Shape *)&v18;
  }
  else
  {
    v13 = *(_DWORD **)(a1 + 16);
    v7 = *(_QWORD **)(a1 + 296);
    v8 = *(_QWORD *)(a2 + 24);
    v14 = v13[43];
    v17[0] = v13[42];
    v17[1] = v14;
    v15 = v13[44];
    LODWORD(v13) = v13[45];
    v17[2] = v15;
    v17[3] = (_DWORD)v13;
    v16[0] = v17[0];
    v16[1] = v14;
    v16[2] = v15;
    v16[3] = (_DWORD)v13;
    v11 = (CA::Shape *)v17;
    v12 = (CA::Shape *)v16;
  }
  CA::WindowServer::IOMFBFlipBook::Blitter::blit(v7, v8, v11, v12);
}

void CA::WindowServer::IOMFBFlipBook::resume_completed(CA::WindowServer::IOMFBFlipBook *this)
{
  unsigned __int8 *v1;
  _DWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  _DWORD v7[4];
  _DWORD v8[4];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v1 = (unsigned __int8 *)*((_QWORD *)this + 37);
  v2 = *(_DWORD **)(*(_QWORD *)v1 + 16);
  v3 = v1[8];
  v1[8] = (v3 & 1) == 0;
  v4 = *(_QWORD *)&v1[8 * v3 + 32];
  v5 = v2[43];
  v8[0] = v2[42];
  v8[1] = v5;
  v6 = v2[44];
  LODWORD(v2) = v2[45];
  v8[2] = v6;
  v8[3] = (_DWORD)v2;
  v7[0] = v8[0];
  v7[1] = v5;
  v7[2] = v6;
  v7[3] = (_DWORD)v2;
  CA::WindowServer::IOMFBFlipBook::Blitter::blit(v1, v4, (CA::Shape *)v8, (CA::Shape *)v7);
  v1[8] = v3;
}

uint64_t CA::WindowServer::IOMFBFlipBook::set_power_saving_state(CA::WindowServer::IOMFBFlipBook *this, unsigned int a2)
{
  return CA::WindowServer::IOMFBDisplay::set_aot_power_saving_mode_enabled(*((_QWORD *)this + 2), a2);
}

uint64_t CA::WindowServer::FlipBook::renderer(CA::WindowServer::FlipBook *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 2) + 312);
}

void CA::WindowServer::IOMFBFlipBook::swap_frame(uint64_t a1, uint64_t a2, uint64_t a3, int32x4_t a4, int32x4_t a5)
{
  uint64_t v5;
  CA::IOMobileFramebuffer **v9;
  int v10;
  int v11;
  int v12;
  int8x16_t v13;
  uint64_t v14;
  int64x2_t v15;
  int8x16_t v16;
  double v17;
  double v18;
  uint64_t v19;
  const CA::Bounds *v20;
  int v21;
  const CA::Bounds *v22;
  CA::Shape *v23;
  double Width;
  size_t Height;
  int32x2_t v26;
  int32x2_t v27;
  int v28;
  int v29;
  int32x2_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int64x2_t v35;
  uint64_t v36;
  int v38;
  IOSurfaceID ID;
  NSObject *v40;
  int v41;
  malloc_zone_t *malloc_zone;
  char *v43;
  char *v44;
  os_unfair_lock_s *v45;
  _QWORD *v46;
  _QWORD *v47;
  unint64_t v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  _QWORD *v56;
  unint64_t v57;
  _QWORD *v58;
  _QWORD *v59;
  uint64_t v60;
  int64x2_t v61;
  uint64_t v62;
  _QWORD *v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  int64x2_t v70;
  double v71;
  void *v72;
  uint64_t v73;
  _WORD *v74;
  const CA::Bounds *v75;
  CA::Shape **v76;
  const CA::Shape *v77;
  const int *v78;
  const CA::Bounds *v79;
  unint64_t v80;
  CA::Shape *v81;
  uint32x4_t v82;
  float64x2_t v89;
  unint64_t v90;
  const CA::Shape *v91;
  const int *v92;
  CA::Shape *v93;
  CA::Shape *v94;
  float64x2_t v95;
  int32x2_t v96;
  uint16x4_t v97;
  CA::Shape *v98;
  _OWORD v99[2];
  uint64_t v100;
  int v101;
  int v102;
  uint64_t v103;
  int v104;
  int v105;
  __int128 v106;
  int32x2_t v107;
  int v108;
  int v109;
  CA::Shape *v110;
  unsigned int v111;
  int8x16_t v112;
  double v113;
  double v114;
  uint64_t v115;
  uint8_t buf[32];
  _QWORD *v117;
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 16);
  if (!*(_BYTE *)(v5 + 28081))
    __assert_rtn("swap_frame", "windowserver-iomfb-flipbook.cpp", 211, "display_iomfb ()->frame_info_enabled ()");
  v9 = (CA::IOMobileFramebuffer **)(v5 + 25536);
  v10 = *(_DWORD *)(v5 + 160);
  v11 = *(_DWORD *)(v5 + 164);
  if (v10 <= v11)
    v12 = *(_DWORD *)(v5 + 164);
  else
    v12 = *(_DWORD *)(v5 + 160);
  a4.i32[0] = 1073741822;
  a5.i32[0] = v12;
  v13 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(a5, a4), 0);
  v14 = *(_QWORD *)(v5 + 152);
  v15.i64[0] = (int)v14;
  v15.i64[1] = SHIDWORD(v14);
  v16 = vbslq_s8(v13, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v15));
  v17 = (double)v10;
  if (v12 > 1073741822)
    v17 = 1.79769313e308;
  v112 = v16;
  if (v12 <= 1073741822)
    v18 = (double)v11;
  else
    v18 = 1.79769313e308;
  v113 = v17;
  v114 = v18;
  v111 = 0;
  CA::IOMobileFramebuffer::swap_begin((CA::IOMobileFramebuffer *)(v5 + 25536), &v111);
  *(_DWORD *)(a2 + 48) = v111;
  v19 = *(_QWORD *)(a2 + 40);
  LODWORD(v99[0]) = 1;
  *(_QWORD *)buf = v19;
  IOMobileFramebufferSwapSetTimestamps();
  v21 = *(_DWORD *)(a1 + 292);
  if (v21)
  {
    if (v21 != 1)
      goto LABEL_38;
    v110 = 0;
    if (!*(_QWORD *)(a3 + 8))
    {
      v98 = 0;
      goto LABEL_29;
    }
    v110 = (CA::Shape *)CA::Shape::new_shape((CA::Shape *)(a2 + 52), v20);
    CA::shape_subtract(&v110, (CA::Shape **)(a2 + 68), v22);
    v23 = v110;
    v98 = v110;
    if ((v110 & 1) != 0)
    {
      if (v110 == (CA::Shape *)1)
      {
        v98 = (CA::Shape *)1;
        goto LABEL_29;
      }
    }
    else
    {
      v23 = v110;
      if (*((_DWORD *)v110 + 1) == 6)
        goto LABEL_29;
    }
    v99[0] = 0uLL;
    *(_QWORD *)&buf[8] = 0;
    *(_QWORD *)&buf[16] = 0;
    *(_QWORD *)buf = v23;
    while (CA::ShapeIterator::iterate((uint64_t *)buf, (int *)v99))
    {
      v26 = *(int32x2_t *)&v99[0];
      v27 = *(int32x2_t *)(a2 + 52);
      v28 = DWORD2(v99[0]);
      v29 = HIDWORD(v99[0]);
      if (use_dcp_blitter(void)::once[0] != -1)
      {
        v96 = *(int32x2_t *)&v99[0];
        dispatch_once(use_dcp_blitter(void)::once, &__block_literal_global_4974);
        v26 = v96;
      }
      v30 = vsub_s32(v26, v27);
      if (use_dcp_blitter(void)::ret)
      {
        IOMobileFramebufferSwapSetBlit();
      }
      else
      {
        v31 = *(_QWORD **)(a1 + 296);
        v32 = *(_QWORD *)(a3 + 8);
        v107 = v30;
        v108 = v28;
        v109 = v29;
        v106 = v99[0];
        CA::WindowServer::IOMFBFlipBook::Blitter::blit(v31, v32, (CA::Shape *)&v107, (CA::Shape *)&v106);
      }
    }
LABEL_29:
    if (use_dcp_blitter(void)::once[0] != -1)
      dispatch_once(use_dcp_blitter(void)::once, &__block_literal_global_4974);
    if (use_dcp_blitter(void)::ret)
    {
      IOMobileFramebufferSwapSetBlit();
      v33 = *(_QWORD *)(a1 + 16);
      if (byte_1ECDC6AE8)
      {
        CA::WindowServer::IOMFBFlipBook::draw_debug_overlay((CA::WindowServer::Display **)a1, a2, *(_QWORD *)(a2 + 16), v111);
        v71 = (double)*(int *)(v33 + 176);
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = 0;
        *(double *)&buf[16] = v71;
        *(_QWORD *)&buf[24] = 0x4041000000000000;
        CA::IOMobileFramebuffer::swap_set_blit(*v9, *(__IOSurface **)(a2 + 16), (const CA::Rect *)buf, (const CA::Rect *)buf);
      }
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = 0;
      v34 = *(_QWORD *)(v33 + 176);
      v35.i64[0] = (int)v34;
      v35.i64[1] = SHIDWORD(v34);
      *(float64x2_t *)&buf[16] = vcvtq_f64_s64(v35);
      CA::IOMobileFramebuffer::swap_set_layer((CA::IOMobileFramebuffer *)(v5 + 25536), 0, *(IOSurfaceRef *)(*(_QWORD *)(a1 + 296) + 8 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 296) + 8) + 16), (const CA::Rect *)buf, (const CA::Rect *)&v112);
      *(_BYTE *)(a2 + 96) = *(_BYTE *)(a2 + 96) & 0xFE | *(_BYTE *)(*(_QWORD *)(a1 + 296) + 8) & 1;
      goto LABEL_35;
    }
    v63 = *(_QWORD **)(a1 + 296);
    v64 = *(_QWORD *)(a2 + 68);
    v65 = *(_QWORD *)(a2 + 8);
    v66 = *(_DWORD *)(a2 + 76);
    v67 = *(_DWORD *)(a2 + 80);
    v103 = 0;
    v104 = v66;
    v105 = v67;
    v100 = v64;
    v101 = v66;
    v102 = v67;
    CA::WindowServer::IOMFBFlipBook::Blitter::blit(v63, v65, (CA::Shape *)&v103, (CA::Shape *)&v100);
    CA::WindowServer::IOMFBFlipBook::Blitter::present_to(*(unsigned __int8 **)(a1 + 296), *(_QWORD *)(a2 + 24));
    *(_BYTE *)(a2 + 96) = *(_BYTE *)(a2 + 96) & 0xFE | *(_BYTE *)(*(_QWORD *)(a1 + 296) + 8) & 1;
    if (!byte_1ECDC6AA3)
    {
LABEL_66:
      v68 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = 0;
      v69 = *(_QWORD *)(v68 + 176);
      v70.i64[0] = (int)v69;
      v70.i64[1] = SHIDWORD(v69);
      *(float64x2_t *)&buf[16] = vcvtq_f64_s64(v70);
      CA::IOMobileFramebuffer::swap_set_layer((CA::IOMobileFramebuffer *)v9, 0, *(IOSurfaceRef *)(a2 + 16), (const CA::Rect *)buf, (const CA::Rect *)&v112);
LABEL_35:
      if (v98)
        CA::Shape::unref(v98);
      *(_BYTE *)(*(_QWORD *)(a1 + 296) + 8) = (*(_BYTE *)(*(_QWORD *)(a1 + 296) + 8) & 1) == 0;
      goto LABEL_38;
    }
    v72 = (void *)MEMORY[0x186DBE2E4]();
    v73 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1);
    v74 = *(_WORD **)v73;
    v74[408] = *(_WORD *)(*(_QWORD *)v73 + 816) | 2;
    (*(void (**)(_WORD *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v74 + 32))(v74, *(_QWORD *)(a2 + 16), 0, 0);
    if (!v98)
    {
      v80 = CA::Shape::new_shape((CA::Shape *)(a2 + 68), v75);
      v98 = 0;
      goto LABEL_80;
    }
    v76 = (CA::Shape **)CA::Shape::intersect(v98, (const CA::Bounds *)(a2 + 68));
    *(_QWORD *)buf = 0x3804000038043804;
    CA::OGL::Context::paint_region((uint64_t)v74, (uint64_t)v76, (uint64_t *)buf, 1);
    CA::shape_subtract(&v110, v76, v77, v78);
    v98 = v110;
    if ((v110 & 1) != 0)
    {
      if (v110 == (CA::Shape *)1)
      {
LABEL_77:
        v90 = CA::Shape::new_shape((CA::Shape *)(a2 + 68), v79);
        *(_QWORD *)&v99[0] = v90;
        if (v76)
        {
          CA::shape_subtract((CA::Shape **)v99, v76, v91, v92);
          v93 = *(CA::Shape **)&v99[0];
          *(_QWORD *)buf = 0x3804000000003804;
          CA::OGL::Context::paint_region((uint64_t)v74, *(uint64_t *)&v99[0], (uint64_t *)buf, 1);
          CA::Shape::unref(v93);
          v94 = (CA::Shape *)v76;
LABEL_81:
          CA::Shape::unref(v94);
          (*(void (**)(_WORD *, uint64_t))(*(_QWORD *)v74 + 408))(v74, 1);
          (*(void (**)(_WORD *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v74 + 32))(v74, 0, 0, 0);
          v74[408] &= ~2u;
          objc_autoreleasePoolPop(v72);
          goto LABEL_66;
        }
        v80 = v90;
LABEL_80:
        *(_QWORD *)buf = 0x3804000000003804;
        CA::OGL::Context::paint_region((uint64_t)v74, v80, (uint64_t *)buf, 1);
        v94 = (CA::Shape *)v80;
        goto LABEL_81;
      }
    }
    else if (*((_DWORD *)v110 + 1) == 6)
    {
      goto LABEL_77;
    }
    v99[0] = 0uLL;
    *(_QWORD *)&buf[8] = 0;
    *(_QWORD *)&buf[16] = 0;
    *(_QWORD *)buf = v110;
    v97 = (uint16x4_t)939786240;
    v95 = (float64x2_t)vdupq_n_s64(0x3FECCCCCCCCCCCCDuLL);
    while (CA::ShapeIterator::iterate((uint64_t *)buf, (int *)v99))
    {
      v81 = (CA::Shape *)CA::Shape::new_shape((CA::Shape *)v99, v79);
      v82 = vmovl_u16(v97);
      LOWORD(v115) = v82.i16[0];
      WORD1(v115) = v82.i16[2];
      HIDWORD(v115) = 939786240;
      CA::OGL::Context::paint_region((uint64_t)v74, (uint64_t)v81, &v115, 1);
      _KR10_4 = v97.i32[0];
      __asm
      {
        FCVT            D0, H0
        FCVT            D1, H1
      }
      _Q1.f64[1] = _D0;
      v89 = vmulq_f64(_Q1, v95);
      *(float32x2_t *)&v89.f64[0] = vcvt_f32_f64(v89);
      v97 = (uint16x4_t)vcvt_f16_f32((float32x4_t)v89);
      CA::Shape::unref(v81);
    }
    goto LABEL_77;
  }
  if (byte_1ECDC6AE8)
    CA::WindowServer::IOMFBFlipBook::draw_debug_overlay((CA::WindowServer::Display **)a1, a2, *(_QWORD *)a2, v111);
  Width = (double)IOSurfaceGetWidth(*(IOSurfaceRef *)a2);
  Height = IOSurfaceGetHeight(*(IOSurfaceRef *)a2);
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  *(double *)&buf[16] = Width;
  *(double *)&buf[24] = (double)Height;
  CA::IOMobileFramebuffer::swap_set_layer((CA::IOMobileFramebuffer *)(v5 + 25536), 0, *(IOSurfaceRef *)a2, (const CA::Rect *)buf, (const CA::Rect *)&v112);
LABEL_38:
  v36 = -2;
  do
  {
    memset(buf, 0, sizeof(buf));
    memset(v99, 0, sizeof(v99));
    CA::IOMobileFramebuffer::swap_set_layer((CA::IOMobileFramebuffer *)v9, v36 + 3, 0, (const CA::Rect *)buf, (const CA::Rect *)v99);
  }
  while (!__CFADD__(v36++, 1));
  v38 = IOMobileFramebufferSwapEnd();
  ID = IOSurfaceGetID(*(IOSurfaceRef *)a2);
  kdebug_trace();
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v40 = x_log_category_flipbook;
    if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
    {
      v41 = *(_DWORD *)(a2 + 48);
      *(_DWORD *)buf = 67109632;
      *(_DWORD *)&buf[4] = ID;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v41;
      *(_WORD *)&buf[14] = 1024;
      *(_DWORD *)&buf[16] = v38;
      _os_log_impl(&dword_184457000, v40, OS_LOG_TYPE_DEFAULT, "swapped surface 0x%x in swap %u, ret %u", buf, 0x14u);
    }
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v43 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xC8uLL, 0x743898A5uLL);
  v44 = v43;
  if (v43)
  {
    *((_QWORD *)v43 + 13) = 0;
    *((_QWORD *)v43 + 10) = 0;
    *((_QWORD *)v43 + 9) = v43 + 80;
    *((_QWORD *)v43 + 11) = 0;
    *((_QWORD *)v43 + 12) = v43 + 104;
    *((_QWORD *)v43 + 14) = 0;
    *((_QWORD *)v43 + 15) = v43 + 152;
    *((_QWORD *)v43 + 16) = v43 + 152;
    *((_QWORD *)v43 + 17) = v43 + 152;
    *((_QWORD *)v43 + 18) = 4;
  }
  *(_DWORD *)v43 = *(_DWORD *)(a2 + 48);
  *(_WORD *)(v43 + 197) &= ~0x100u;
  v45 = (os_unfair_lock_s *)(*(_QWORD *)(a1 + 16) + 25908);
  os_unfair_lock_lock(v45);
  v46 = *(_QWORD **)(a1 + 16);
  v47 = (_QWORD *)v46[3240];
  v48 = v46[3241];
  if ((unint64_t)v47 >= v48)
  {
    v50 = v46[3239];
    v51 = ((uint64_t)v47 - v50) >> 3;
    if ((unint64_t)(v51 + 1) >> 61)
      abort();
    v52 = v48 - v50;
    v53 = v52 >> 2;
    if (v52 >> 2 <= (unint64_t)(v51 + 1))
      v53 = v51 + 1;
    if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8)
      v54 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v54 = v53;
    v117 = v46 + 3241;
    if (v54)
      v54 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v54);
    else
      v55 = 0;
    v56 = (_QWORD *)(v54 + 8 * v51);
    v57 = v54 + 8 * v55;
    *(_QWORD *)&buf[24] = v57;
    *v56 = v44;
    v49 = v56 + 1;
    *(_QWORD *)&buf[16] = v56 + 1;
    v58 = (_QWORD *)v46[3240];
    v59 = (_QWORD *)v46[3239];
    if (v58 == v59)
    {
      v61 = vdupq_n_s64((unint64_t)v58);
    }
    else
    {
      do
      {
        v60 = *--v58;
        *v58 = 0;
        *--v56 = v60;
      }
      while (v58 != v59);
      v61 = *(int64x2_t *)(v46 + 3239);
      v57 = *(_QWORD *)&buf[24];
      v49 = *(_QWORD **)&buf[16];
    }
    v46[3239] = v56;
    v46[3240] = v49;
    *(int64x2_t *)&buf[8] = v61;
    v62 = v46[3241];
    v46[3241] = v57;
    *(_QWORD *)&buf[24] = v62;
    *(_QWORD *)buf = v61.i64[0];
    std::__split_buffer<std::unique_ptr<CA::WindowServer::IOMFBDisplay::FrameInfo>>::~__split_buffer((uint64_t)buf);
  }
  else
  {
    *v47 = v44;
    v49 = v47 + 1;
  }
  v46[3240] = v49;
  os_unfair_lock_unlock(v45);
}

BOOL CA::WindowServer::IOMFBFlipBook::cancel_frame(uint64_t a1, uint64_t a2)
{
  int v3;
  NSObject *v4;
  int v5;
  uint8_t buf[4];
  int v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (!*(_DWORD *)(a2 + 48))
    __assert_rtn("cancel_frame", "windowserver-iomfb-flipbook.cpp", 399, "frame.swap_id != 0");
  v3 = IOMobileFramebufferSwapCancel();
  IOSurfaceGetID(*(IOSurfaceRef *)a2);
  kdebug_trace();
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v4 = x_log_category_flipbook;
    if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *(_DWORD *)(a2 + 48);
      *(_DWORD *)buf = 67109376;
      v8 = v5;
      v9 = 1024;
      v10 = v3;
      _os_log_impl(&dword_184457000, v4, OS_LOG_TYPE_DEFAULT, "IOMFBFlipBook::cancel_frame(swap_id %u) = 0x%x", buf, 0xEu);
    }
  }
  return v3 == 0;
}

void CA::WindowServer::IOMFBFlipBook::cancel_all_swaps(CA::WindowServer::IOMFBFlipBook *this)
{
  int v1;
  NSObject *v2;
  uint8_t buf[4];
  int v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v1 = IOMobileFramebufferSwapCancelAll();
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v2 = x_log_category_flipbook;
    if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      v4 = v1;
      _os_log_impl(&dword_184457000, v2, OS_LOG_TYPE_DEFAULT, "IOMFBFlipBook::cancel_all_swaps() = 0x%x", buf, 8u);
    }
  }
}

BOOL CA::WindowServer::IOMFBFlipBook::swapped_frame_displayed_p(uint64_t a1)
{
  return CA::IOMobileFramebuffer::swap_wait((CA::IOMobileFramebuffer *)(*(_QWORD *)(a1 + 16) + 25536)) == 0;
}

uint64_t CA::WindowServer::IOMFBFlipBook::supports_individual_frame_cancels(CA::WindowServer::IOMFBFlipBook *this)
{
  return 1;
}

BOOL CA::WindowServer::IOMFBFlipBook::needs_debug_surface(CA::WindowServer::IOMFBFlipBook *this)
{
  int v1;

  v1 = *((_DWORD *)this + 73);
  if (byte_1ECDC6AA3 && !v1)
    return 1;
  if (v1 != 1)
    return byte_1ECDC6AE8 != 0;
  if (use_dcp_blitter(void)::once[0] != -1)
    dispatch_once(use_dcp_blitter(void)::once, &__block_literal_global_4974);
  return !use_dcp_blitter(void)::ret || byte_1ECDC6AE8 != 0;
}

__n128 CA::WindowServer::IOMFBFlipBook::debug_surface_bounds@<Q0>(CA::WindowServer::IOMFBFlipBook *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result;

  result = *(__n128 *)(*((_QWORD *)this + 2) + 168);
  *a2 = result;
  return result;
}

uint64_t CA::WindowServer::IOMFBFlipBook::get_destination_surface(CA::WindowServer::IOMFBFlipBook *this, unsigned int a2)
{
  uint64_t result;
  uint64_t v4;

  result = 0;
  if (a2 <= 1)
  {
    v4 = *((_QWORD *)this + 37);
    if (v4)
      return *(_QWORD *)(v4 + 8 * a2 + 16);
  }
  return result;
}

void ___ZL15use_dcp_blitterv_block_invoke()
{
  BOOL v1;

  if (initialized[0] != -1)
    dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
  v1 = *(float *)&dword_1ECDC69F8 != 3 && byte_1ECDC6AA3 == 0;
  use_dcp_blitter(void)::ret = v1;
}

uint64_t CA::IOMobileFramebuffer::swap_wait(CA::IOMobileFramebuffer *this)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)this + 8))
    return IOMobileFramebufferSwapWait();
  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  BMMonitorBlockExecutionWithSignature();
  v1 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v1;
}

uint64_t ___ZN2CA19IOMobileFramebuffer9swap_waitEjj_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = IOMobileFramebufferSwapWait();
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t CA::IOMobileFramebuffer::swap_begin(CA::IOMobileFramebuffer *this, unsigned int *a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 8))
  {
    v5 = 0;
    v6 = &v5;
    v7 = 0x2000000000;
    v8 = 0;
    BMMonitorBlockExecutionWithSignature();
    v3 = *((unsigned int *)v6 + 6);
    _Block_object_dispose(&v5, 8);
  }
  else
  {
    v3 = IOMobileFramebufferSwapBegin();
    if (!(_DWORD)v3)
      *((_BYTE *)this + 16) = 0;
  }
  return v3;
}

void CA::WindowServer::IOMFBFlipBook::draw_debug_overlay(CA::WindowServer::Display **a1, uint64_t a2, uint64_t a3, int a4)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  const __CFString *v11;
  const char *CString;
  float v18;
  double v19;
  int v20;
  CA::OGL::DebugRenderer *v21;
  CA::OGL::DebugRenderer *v22;
  uint64_t v23;
  CA::WindowServer::Display *v24;
  uint64_t v25;
  size_t v26;
  uint64_t i;
  float v28[2];
  _OWORD v29[9];
  uint64_t v30;
  _OWORD __str[3];
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  _QWORD v35[9];
  _QWORD v36[123];

  v36[122] = *MEMORY[0x1E0C80C00];
  v8 = (void *)MEMORY[0x186DBE2E4]();
  v9 = (*((uint64_t (**)(CA::WindowServer::Display **))*a1 + 11))(a1);
  v10 = *(_QWORD *)v9;
  *(_WORD *)(v10 + 816) = *(_WORD *)(*(_QWORD *)v9 + 816) | 2;
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v10 + 32))(v10, a3, 0, 0);
  *(_QWORD *)(v10 + 176) = CA::WindowServer::Display::ogl_display(a1[2]);
  v36[0] = 0;
  v36[61] = 0;
  CA::OGL::Context::prepare_context(v10, (uint64_t)v36);
  v35[4] = 0x3C003C003C003C00;
  memset(&v35[5], 0, 24);
  v35[0] = 0;
  v35[8] = 0x4013F800000;
  v35[2] = 0;
  v35[3] = &CA::identity_transform;
  v35[1] = &CA::Shape::_infinite_shape;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v10 + 1008))(v10, v35);
  v11 = CACreateDateStringFromHostContinuousTime(*(_QWORD *)(a2 + 40), CFSTR("HH:mm:ss"));
  v34 = 0;
  v33 = 0;
  v32 = 0;
  memset(__str, 0, sizeof(__str));
  CString = CA_CFStringGetCString(v11, (char *)&v33, 10);
  snprintf((char *)__str, 0x32uLL, "TIME %s  SWAP %x", CString, a4);
  v29[0] = xmmword_18474DF40;
  v29[1] = 0u;
  v29[2] = xmmword_18474DF50;
  memset(&v29[3], 0, 32);
  v29[5] = xmmword_18474DF40;
  v29[6] = 0u;
  v29[7] = xmmword_18474DF50;
  __asm { FMOV            V0.2D, #1.0 }
  v29[8] = _Q0;
  v18 = (float)*((int *)a1[2] + 44);
  *(float *)&v19 = (float)(v18 + (float)((float)strnlen((const char *)__str, 0x32uLL) * -28.0)) * 0.5;
  v20 = (int)*(float *)&v19;
  v21 = a1[38];
  if (!v21)
  {
    v22 = (CA::OGL::DebugRenderer *)operator new();
    v21 = CA::OGL::DebugRenderer::DebugRenderer(v22, 1024);
    a1[38] = v21;
  }
  v30 = 0;
  *((_QWORD *)v21 + 8) = *((_QWORD *)v21 + 6);
  *((_QWORD *)v21 + 10) = 0x3C002A662A662A66;
  v23 = (uint64_t)a1[38];
  *(_QWORD *)(v23 + 16) = 0;
  v28[0] = v18;
  v28[1] = 34.0;
  CA::OGL::DebugRenderer::draw_rectangle_with_fill(v23, v28, v19);
  v24 = a1[38];
  *((_QWORD *)v24 + 3) = 0x4200000041E00000;
  *((_QWORD *)v24 + 10) = 0x3C00366636663666;
  v25 = (uint64_t)a1[38];
  *(float *)(v25 + 16) = (float)v20;
  *(_DWORD *)(v25 + 20) = 1065353216;
  v26 = strlen((const char *)__str);
  CA::OGL::DebugRenderer::draw_string(v25, (const char *)__str, v26);
  CA::OGL::DebugRenderer::render((uint64_t)a1[38], (CA::OGL::Context *)v10, (const CA::Transform *)v29);
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v10 + 1016))(v10, v35);
  (*(void (**)(uint64_t))(*(_QWORD *)v10 + 416))(v10);
  (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v10 + 32))(v10, 0, 0, 0);
  *(_WORD *)(v10 + 816) &= ~2u;
  *(_QWORD *)(v10 + 176) = 0;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v10 + 40))(v10, a3);
  if (v11)
    CFRelease(v11);
  for (i = 61; i != -61; i -= 61)
  {
    if (v36[i])
      __assert_rtn("~ContextState", "ogl-context.h", 551, "!next && \"Imbalanced ContextState push/pop\"");
  }
  objc_autoreleasePoolPop(v8);
}

void CA::WindowServer::IOMFBFlipBook::Blitter::blit(_QWORD *a1, uint64_t a2, CA::Shape *a3, CA::Shape *a4)
{
  void *v7;
  uint64_t *v8;
  const CA::Bounds *v9;
  uint64_t v10;
  CA::Shape *v11;
  const CA::Bounds *v12;
  CA::Shape *v13;

  v7 = (void *)MEMORY[0x186DBE2E4]();
  v8 = (uint64_t *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 88))(*a1);
  if (*((_DWORD *)a3 + 2) != *((_DWORD *)a4 + 2))
    __assert_rtn("blit", "windowserver-iomfb-flipbook.cpp", 611, "src_bounds.w == dst_bounds.w");
  if (*((_DWORD *)a3 + 3) != *((_DWORD *)a4 + 3))
    __assert_rtn("blit", "windowserver-iomfb-flipbook.cpp", 612, "src_bounds.h == dst_bounds.h");
  v10 = *v8;
  v11 = (CA::Shape *)CA::Shape::new_shape(a4, v9);
  v13 = (CA::Shape *)CA::Shape::new_shape(a3, v12);
  CA::OGL::Context::copy_surface_region(v10);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v10 + 408))(v10, 1);
  CA::Shape::unref(v11);
  CA::Shape::unref(v13);
  objc_autoreleasePoolPop(v7);
}

uint64_t CA::IOMobileFramebuffer::swap_set_blit(CA::IOMobileFramebuffer *this, __IOSurface *a2, const CA::Rect *a3, const CA::Rect *a4)
{
  return IOMobileFramebufferSwapSetBlit();
}

void CA::WindowServer::IOMFBFlipBook::Blitter::present_to(unsigned __int8 *a1, uint64_t a2)
{
  void *v4;
  _QWORD *v5;
  uint64_t v6;

  v4 = (void *)MEMORY[0x186DBE2E4]();
  v5 = (_QWORD *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)a1 + 88))(*(_QWORD *)a1);
  v6 = *v5;
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)*v5 + 720))(*v5, a2, *(_QWORD *)&a1[8 * a1[8] + 32], 0, 0, 0, 0);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 408))(v6, 1);
  objc_autoreleasePoolPop(v4);
}

uint64_t std::__split_buffer<std::unique_ptr<CA::WindowServer::IOMFBDisplay::FrameInfo>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    std::unique_ptr<CA::WindowServer::IOMFBDisplay::FrameInfo>::reset[abi:nn180100]((CA::WindowServer::IOMFBDisplay::FrameInfo **)(i - 8), 0);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::unique_ptr<CA::WindowServer::IOMFBDisplay::FrameInfo>::reset[abi:nn180100](CA::WindowServer::IOMFBDisplay::FrameInfo **a1, CA::WindowServer::IOMFBDisplay::FrameInfo *a2)
{
  CA::WindowServer::IOMFBDisplay::FrameInfo *v2;
  malloc_zone_t *malloc_zone;

  v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    CA::WindowServer::IOMFBDisplay::FrameInfo::~FrameInfo(v2);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v2);
  }
}

uint64_t ___ZN2CA19IOMobileFramebuffer10swap_beginEPj_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  result = IOMobileFramebufferSwapBegin();
  if (!(_DWORD)result)
    *(_BYTE *)(v2 + 16) = 0;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t CA::WindowServer::FlipBookStateChangeNotifier::FlipBookStateChangeNotifier(uint64_t a1, __int16 a2)
{
  int v3;

  *(_BYTE *)(a1 + 8) = 0;
  v3 = HIBYTE(a2) - a2;
  if (v3 < 0)
    v3 = a2 - HIBYTE(a2);
  if (v3 == 1)
  {
    *(_DWORD *)a1 = 0;
    *(_WORD *)(a1 + 4) = 1;
    *(_BYTE *)(a1 + 6) = HIBYTE(a2) == 1;
    *(_BYTE *)(a1 + 8) = 1;
    CA::Render::post_notification(0x3Du, 0, a1, 0);
  }
  return a1;
}

void CA::WindowServer::IOMFBFlipBook::get_display_debug_properties(CA::WindowServer::IOMFBFlipBook *this, CA::Render::Object *a2, __CFDictionary **a3, void *a4)
{
  char *v5;

  if (*(_DWORD *)a3 == *(_DWORD *)(*((_QWORD *)a2 + 2) + 24))
  {
    if (*((_DWORD *)a2 + 73))
      v5 = "DirtyRegionOnly";
    else
      v5 = "FullSize";
    CA_CFDictionarySetCString(a3[1], CFSTR("flipBookType"), v5);
    if (use_dcp_blitter(void)::once[0] != -1)
      dispatch_once(use_dcp_blitter(void)::once, &__block_literal_global_4974);
    if (use_dcp_blitter(void)::ret)
      CFDictionarySetValue(a3[1], CFSTR("flipBookUsesDCPBlitter"), (const void *)*MEMORY[0x1E0C9AE50]);
  }
}

void CA::CG::IOSurfaceDataProvider::copy_data(CA::CG::IOSurfaceDataProvider *this)
{
  CA::CG::Queue **v2;
  int v3;
  unsigned int v4;
  __IOSurface *v5;
  CA::Render *AllocSize;
  void *v7;
  unint64_t v8;
  void *v9;
  void *BaseAddress;
  NSObject *v11;
  IOSurfaceID ID;
  unint64_t v13;
  uint8_t buf[4];
  IOSurfaceID v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = (CA::CG::Queue **)*((_QWORD *)this + 2);
  if (v2 && !*((_QWORD *)this + 3) && !*((_BYTE *)this + 48))
  {
    v3 = BYTE9(xmmword_1ECDC6A90);
    if (BYTE9(xmmword_1ECDC6A90))
    {
      kdebug_trace();
      v2 = (CA::CG::Queue **)*((_QWORD *)this + 2);
    }
    v4 = *((_DWORD *)this + 11);
    if (v4 && v2[9])
    {
      CA::CG::Queue::wait_queue(v2[9], v4);
      v2 = (CA::CG::Queue **)*((_QWORD *)this + 2);
    }
    v5 = (__IOSurface *)(*((uint64_t (**)(CA::CG::Queue **))*v2 + 3))(v2);
    AllocSize = (CA::Render *)IOSurfaceGetAllocSize(v5);
    v13 = 0;
    v7 = CA::Render::aligned_malloc(AllocSize, &v13, 0);
    v8 = v13;
    *((_QWORD *)this + 3) = v7;
    *((_QWORD *)this + 4) = v8;
    if (v7)
    {
      v9 = v7;
      if (IOSurfaceLock(v5, 1u, 0))
      {
        if (x_log_hook_p())
        {
          IOSurfaceGetID(v5);
          x_log_();
        }
        else
        {
          v11 = x_log_category_cg;
          if (os_log_type_enabled((os_log_t)x_log_category_cg, OS_LOG_TYPE_ERROR))
          {
            ID = IOSurfaceGetID(v5);
            *(_DWORD *)buf = 67109120;
            v15 = ID;
            _os_log_impl(&dword_184457000, v11, OS_LOG_TYPE_ERROR, "CoreAnimation: failed to lock IOSurface %x\n", buf, 8u);
          }
        }
      }
      else
      {
        BaseAddress = IOSurfaceGetBaseAddress(v5);
        memcpy(v9, BaseAddress, (size_t)AllocSize);
        IOSurfaceUnlock(v5, 1u, 0);
      }
    }
    if (v3)
      kdebug_trace();
  }
}

void CA::CG::IOSurfaceDataProvider::~IOSurfaceDataProvider(CA::CG::IOSurfaceDataProvider *this, uint64_t a2, void *a3)
{
  malloc_zone_t *malloc_zone;

  CA::CG::AccelDataProvider::~AccelDataProvider(this, a2, a3);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

CGAffineTransform *CAML::parse_affine_matrix(CGAffineTransform *this, CAML::Context *a2, char *a3, CAML *a4, const char *a5)
{
  __int128 v5;
  __int128 v6;
  uint64_t v10;
  CAML *v11;
  CAML *v12;
  size_t v13;
  unsigned int v14;
  char *v15;
  const char *v16;
  CAML *v17;
  const char *v18;
  const char *v19;
  unint64_t v20;
  int v21;
  const char *v23;
  CAML *v24;
  int v25;
  int v26;
  BOOL v32;
  CGFloat a;
  __int128 v34;
  CGAffineTransform *p_t1;
  CGAffineTransform *p_t2;
  CGFloat b;
  BOOL v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v45;
  double v46;
  uint64_t v47;
  double v48;
  double v49;
  __int128 v50;
  __int128 v51;
  CAML::Context *v52;
  _OWORD v53[3];
  _QWORD v54[3];
  __int128 v55;
  uint64_t v56;
  CGAffineTransform v57;
  CGAffineTransform v58;
  CGAffineTransform v59;
  CGAffineTransform t2;
  CGAffineTransform t1;
  CGAffineTransform v62;
  char v63[8];
  CGAffineTransform v64;
  _OWORD __dst[2];
  uint64_t v66;

  v52 = (CAML::Context *)this;
  v66 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)v63 = a2;
  v5 = *MEMORY[0x1E0C9BAA8];
  v6 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 32);
  *((_OWORD *)a3 + 1) = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
  *((_OWORD *)a3 + 2) = v6;
  *(_OWORD *)a3 = v5;
  if (a2 < a4)
  {
    v10 = MEMORY[0x1E0C80978];
    memset(__dst, 0, sizeof(__dst));
    memset(&v64, 0, sizeof(v64));
    v11 = a2;
    do
    {
      if (!*(_BYTE *)v11)
        return this;
      v12 = CAML::skip_whitespace(v11, a4, a3);
      v13 = 0;
      *(_QWORD *)v63 = v12;
      do
      {
        if (*(_QWORD *)v63 < (unint64_t)a4)
        {
          v14 = *(char *)(*(_QWORD *)v63 + v13);
          if (!*(_BYTE *)(*(_QWORD *)v63 + v13))
            break;
          if ((v14 & 0x80000000) != 0)
          {
            if (!__maskrune(v14, 0x100uLL))
              break;
          }
          else if ((*(_DWORD *)(v10 + 4 * v14 + 60) & 0x100) == 0)
          {
            break;
          }
        }
        ++v13;
      }
      while (v13 != 31);
      v15 = *(char **)v63;
      memcpy(__dst, *(const void **)v63, v13);
      *((_BYTE *)__dst + v13) = 0;
      *(_QWORD *)v63 = &v15[v13];
      v17 = CAML::skip_whitespace((CAML *)&v15[v13], a4, v16);
      v11 = v17;
      *(_QWORD *)v63 = v17;
      if (v17 < a4 && *(_BYTE *)v17 == 40)
      {
        v11 = CAML::skip_whitespace((CAML *)((char *)v17 + 1), a4, v18);
        *(_QWORD *)v63 = v11;
      }
      if (v11 >= a4)
      {
        v20 = 0;
      }
      else
      {
        v20 = 0;
        do
        {
          v21 = *(unsigned __int8 *)v11;
          if (!*(_BYTE *)v11)
            break;
          if (v21 == 41 || v20 > 5)
          {
            if (v21 == 41)
            {
              v11 = CAML::skip_whitespace((CAML *)((char *)v11 + 1), a4, v18);
              *(_QWORD *)v63 = v11;
            }
            break;
          }
          *(&v64.a + v20) = CAML::parse_real(v11, v63, (char **)a4, v19);
          v24 = CAML::skip_whitespace(*(CAML **)v63, a4, v23);
          v11 = v24;
          *(_QWORD *)v63 = v24;
          if (v24 < a4)
          {
            v25 = *(unsigned __int8 *)v24;
            if (v25 == 59 || v25 == 44)
            {
              v11 = CAML::skip_whitespace((CAML *)((char *)v24 + 1), a4, v18);
              *(_QWORD *)v63 = v11;
            }
          }
          ++v20;
        }
        while (v11 < a4);
      }
      if (v11 < a4)
      {
        v26 = *(unsigned __int8 *)v11;
        if (v26 == 59 || v26 == 44)
        {
          v11 = CAML::skip_whitespace((CAML *)((char *)v11 + 1), a4, v18);
          *(_QWORD *)v63 = v11;
        }
      }
      if (LODWORD(__dst[0]) == 1920229741 && *(_DWORD *)((char *)__dst + 3) == 7891314)
      {
        if (v20 != 6)
          return (CGAffineTransform *)CAML::Context::error(v52, "Invalid transform: %s (position %ld)", (const char *)a2, v11 - a2);
        t1 = v64;
        v34 = *((_OWORD *)a3 + 1);
        *(_OWORD *)&t2.a = *(_OWORD *)a3;
        *(_OWORD *)&t2.c = v34;
        *(_OWORD *)&t2.tx = *((_OWORD *)a3 + 2);
        p_t1 = &t1;
        p_t2 = &t2;
      }
      else
      {
        if (*(_QWORD *)&__dst[0] == 0x74616C736E617274 && WORD4(__dst[0]) == 101 && v20 != 0 && v20 <= 2)
        {
          if (v20 >= 2)
          {
            b = v64.b;
          }
          else
          {
            v64.b = 0.0;
            b = 0.0;
          }
          v40 = *((_OWORD *)a3 + 1);
          *(_OWORD *)&v59.a = *(_OWORD *)a3;
          *(_OWORD *)&v59.c = v40;
          *(_OWORD *)&v59.tx = *((_OWORD *)a3 + 2);
          this = CGAffineTransformTranslate(&v62, &v59, v64.a, b);
          goto LABEL_77;
        }
        v32 = LODWORD(__dst[0]) == 1818321779 && WORD2(__dst[0]) == 101;
        if (v32 && v20 - 1 <= 1)
        {
          if (v20 == 1)
          {
            v64.b = v64.a;
            a = v64.a;
          }
          else
          {
            a = v64.b;
          }
          v41 = *((_OWORD *)a3 + 1);
          *(_OWORD *)&v58.a = *(_OWORD *)a3;
          *(_OWORD *)&v58.c = v41;
          *(_OWORD *)&v58.tx = *((_OWORD *)a3 + 2);
          this = CGAffineTransformScale(&v62, &v58, v64.a, a);
          goto LABEL_77;
        }
        v38 = LODWORD(__dst[0]) == 1635020658 && *(_DWORD *)((char *)__dst + 3) == 6648929;
        if (v38 && v20 == 1)
        {
          v39 = *((_OWORD *)a3 + 1);
          *(_OWORD *)&v57.a = *(_OWORD *)a3;
          *(_OWORD *)&v57.c = v39;
          *(_OWORD *)&v57.tx = *((_OWORD *)a3 + 2);
          this = CGAffineTransformRotate(&v62, &v57, v64.a);
          goto LABEL_77;
        }
        if ((LODWORD(__dst[0]) != 2003135347 || WORD2(__dst[0]) != 88)
          && (LODWORD(__dst[0]) != 2003135347 || WORD2(__dst[0]) != 89))
        {
          return (CGAffineTransform *)CAML::Context::error(v52, "Invalid transform: %s (position %ld)", (const char *)a2, v11 - a2);
        }
        if (v20 != 1)
          return (CGAffineTransform *)CAML::Context::error(v52, "Invalid transform: %s (position %ld)", (const char *)a2, v11 - a2);
        v45 = *MEMORY[0x1E0C9BAA8];
        v46 = *(double *)(MEMORY[0x1E0C9BAA8] + 8);
        v51 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 24);
        v47 = *(_QWORD *)(MEMORY[0x1E0C9BAA8] + 40);
        v48 = tan(v64.a);
        if (BYTE4(__dst[0]) == 89)
          v49 = v48;
        else
          v49 = v46;
        if (BYTE4(__dst[0]) == 89)
          v48 = 0.0;
        v54[0] = v45;
        *(double *)&v54[1] = v49;
        *(double *)&v54[2] = v48;
        v55 = v51;
        v56 = v47;
        v50 = *((_OWORD *)a3 + 1);
        v53[0] = *(_OWORD *)a3;
        v53[1] = v50;
        v53[2] = *((_OWORD *)a3 + 2);
        p_t1 = (CGAffineTransform *)v54;
        p_t2 = (CGAffineTransform *)v53;
      }
      this = CGAffineTransformConcat(&v62, p_t1, p_t2);
LABEL_77:
      v42 = *(_OWORD *)&v62.c;
      *(_OWORD *)a3 = *(_OWORD *)&v62.a;
      *((_OWORD *)a3 + 1) = v42;
      *((_OWORD *)a3 + 2) = *(_OWORD *)&v62.tx;
    }
    while (v11 < a4);
  }
  return this;
}

CGImageSource *CAML::create_image_from_url(CFURLRef url, const __CFURL *a2)
{
  int v2;
  uint64_t *v4;
  const __CFDictionary *v5;
  CGImageSource *result;
  CGImageSource *v7;
  CGImageRef ImageAtIndex;

  v2 = (int)a2;
  if (CAML::create_image_from_url(__CFURL const*,BOOL)::once[0] != -1)
    dispatch_once(CAML::create_image_from_url(__CFURL const*,BOOL)::once, &__block_literal_global_5091);
  v4 = &CAML::create_image_from_url(__CFURL const*,BOOL)::options_hdr;
  if (!v2)
    v4 = &CAML::create_image_from_url(__CFURL const*,BOOL)::options_sdr;
  v5 = (const __CFDictionary *)*v4;
  result = CGImageSourceCreateWithURL(url, (CFDictionaryRef)*v4);
  if (result)
  {
    v7 = result;
    ImageAtIndex = CGImageSourceCreateImageAtIndex(result, 0, v5);
    CFRelease(v7);
    return ImageAtIndex;
  }
  return result;
}

CFDictionaryRef ___ZN4CAML21create_image_from_urlEPK7__CFURLb_block_invoke()
{
  void *v0;
  const CFDictionaryKeyCallBacks *v1;
  const CFDictionaryValueCallBacks *v2;
  CFDictionaryRef v3;
  void *v4;
  void *v5;
  CFDictionaryRef result;
  void *v7[4];
  void *v8[4];
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  keys[0] = CFSTR("kCGGenerateFlexGTC");
  values = (void *)*MEMORY[0x1E0C9AE50];
  v0 = values;
  v1 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v2 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  v3 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v4 = (void *)*MEMORY[0x1E0CBD288];
  v8[0] = *(void **)MEMORY[0x1E0CBD1E8];
  v8[1] = v4;
  v5 = (void *)*MEMORY[0x1E0CBD1A8];
  v8[2] = *(void **)MEMORY[0x1E0CBD1A0];
  v8[3] = v5;
  v7[0] = v0;
  v7[1] = v0;
  v7[2] = *(void **)MEMORY[0x1E0CBD1B0];
  v7[3] = v3;
  CAML::create_image_from_url(__CFURL const*,BOOL)::options_hdr = (uint64_t)CFDictionaryCreate(0, (const void **)v8, (const void **)v7, 4, v1, v2);
  result = CFDictionaryCreate(0, (const void **)v8, (const void **)v7, 2, v1, v2);
  CAML::create_image_from_url(__CFURL const*,BOOL)::options_sdr = (uint64_t)result;
  return result;
}

double CA::Transform::Transform(CA::Transform *this)
{
  CA::Transform::rotate90(void)::t = xmmword_18474DF40;
  unk_1EDD11D60 = 0u;
  xmmword_1EDD11D70 = xmmword_18474DF50;
  unk_1EDD11D80 = 0u;
  xmmword_1EDD11D90 = 0u;
  unk_1EDD11DA0 = xmmword_18474DF40;
  xmmword_1EDD11DB0 = 0u;
  unk_1EDD11DC0 = xmmword_18474DF50;
  __asm { FMOV            V0.2D, #1.0 }
  xmmword_1EDD11DD0 = _Q0;
  byte_1EDD11DE0 = byte_1EDD11DE0 & 0xE0 | 4;
  return CA::Transform::set_2x2((CA::Transform *)&CA::Transform::rotate90(void)::t);
}

float64_t CA::Transform::rotate90(CA::Transform *this, uint64_t a2, uint64_t a3, const double *a4)
{
  unsigned __int8 v4;
  int v6;
  CA::Transform *v7;

  if ((v4 & 1) == 0)
  {
    v7 = this;
    this = v7;
    if (v6)
    {
      CA::Transform::Transform(v7);
      this = v7;
    }
  }
  return CA::Transform::concat_left(this, (float64x2_t *)&CA::Transform::rotate90(void)::t, a3, a4);
}

uint64_t CA::Transform::apply_to_point4(uint64_t this, float32x2_t *a2, float32x2_t *a3, const float *a4, uint64_t a5)
{
  float64x2_t v5;
  float64x2_t v6;
  float64x2_t v7;
  float32x2_t *v8;

  if ((*(_BYTE *)(this + 144) & 0x10) != 0)
  {
    for (; a5; --a5)
    {
      *(float32x4_t *)a2->f32 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)this), *(float64x2_t *)(this + 16)), COERCE_FLOAT(*(_OWORD *)a3->f32)), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(this + 32)), *(float64x2_t *)(this + 48)), *a3, 1), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(this + 64)), *(float64x2_t *)(this + 80)), *(float32x4_t *)a3->f32, 2), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(this + 96)),
                                    *(float64x2_t *)(this + 112)),
                                  *(float32x4_t *)a3->f32,
                                  3);
      a2 += 2;
      a3 = (float32x2_t *)((char *)a4 + (_QWORD)a3);
    }
  }
  else
  {
    v5 = *(float64x2_t *)(this + 96);
    v6.f64[0] = *(float64_t *)this;
    v7.f64[1] = *(float64_t *)(this + 40);
    if (a2 == a3)
    {
      if (a5)
      {
        v6.f64[1] = *(float64_t *)(this + 8);
        v7.f64[0] = *(float64_t *)(this + 32);
        do
        {
          *a2 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(v5, v6, COERCE_FLOAT(*a2)), v7, COERCE_FLOAT(HIDWORD(*(unint64_t *)a2))));
          a2 += 2;
          --a5;
        }
        while (a5);
      }
    }
    else if (a5)
    {
      v6.f64[1] = *(float64_t *)(this + 8);
      v7.f64[0] = *(float64_t *)(this + 32);
      v8 = a3 + 1;
      do
      {
        *a2 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(v5, v6, COERCE_FLOAT(*(_QWORD *)&v8[-1])), v7, COERCE_FLOAT(HIDWORD(*(_QWORD *)&v8[-1]))));
        a2[1] = *v8;
        a2 += 2;
        v8 = (float32x2_t *)((char *)a4 + (_QWORD)v8);
        --a5;
      }
      while (a5);
    }
  }
  return this;
}

CA::OGL::Context *sw_new_context(void *a1, void *a2)
{
  malloc_zone_t *malloc_zone;
  CA::OGL::Context *v3;
  CA::OGL::Context *v4;

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v3 = (CA::OGL::Context *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x5000uLL, 0x743898A5uLL);
  v4 = v3;
  if (v3)
  {
    bzero(v3, 0x5000uLL);
    CA::OGL::Context::Context(v4);
    *(_QWORD *)v4 = off_1E1595D70;
  }
  return v4;
}

CA::OGL::Context *new_null_context(void *a1, void *a2)
{
  malloc_zone_t *malloc_zone;
  CA::OGL::Context *v3;
  CA::OGL::Context *v4;

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v3 = (CA::OGL::Context *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x738uLL, 0x743898A5uLL);
  v4 = v3;
  if (v3)
  {
    bzero(v3, 0x738uLL);
    CA::OGL::Context::Context(v4);
    *(_QWORD *)v4 = off_1E1594478;
  }
  return v4;
}

void CA::OGL::NullContext::~NullContext(CA::OGL::NullContext *this)
{
  malloc_zone_t *malloc_zone;

  CA::OGL::Context::~Context(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

uint64_t CA::OGL::NullContext::get()
{
  return 0;
}

uint64_t CA::OGL::NullContext::bind_image_impl()
{
  return 0;
}

uint64_t CA::OGL::NullContext::image_surface()
{
  return 0;
}

uint64_t CA::OGL::NullContext::new_image(CA::OGL::NullContext *this)
{
  return 0;
}

uint64_t CA::OGL::NullContext::create_surface(CA::OGL::NullContext *this, int a2, const CA::Bounds *a3)
{
  return 0;
}

uint64_t CA::OGL::NullContext::create_surface_from_data(CA::OGL::NullContext *this, void *a2)
{
  return 0;
}

uint64_t CA::OGL::NullContext::create_surface_from_iosurface(CA::OGL::NullContext *this, int a2, int a3, int a4, __IOSurface *a5)
{
  return 0;
}

uint64_t CA::OGL::NullContext::create_null_surface(CA::OGL::NullContext *this)
{
  return 0;
}

uint64_t CA::OGL::NullContext::needs_destination_group(CA::OGL::NullContext *this)
{
  return 0;
}

uint64_t CA::OGL::NullContext::set_surface()
{
  return 1;
}

uint64_t CA::OGL::NullContext::make_buffer_current(CA::OGL::NullContext *this, CA::WindowServer::Surface *a2)
{
  return 1;
}

uint64_t CA::OGL::NullContext::function_supported(CA::OGL::NullContext *this)
{
  return 1;
}

uint64_t CA::OGL::NullContext::set_destination(CA::OGL::NullContext *this, void *a2, uint64_t a3, unint64_t a4, void *a5, uint64_t a6, int a7, int a8, int a9, int a10)
{
  return 1;
}

uint64_t CA::OGL::NullContext::sw_renderer_p(CA::OGL::NullContext *this)
{
  return 1;
}

CA::OGL::GLESContext *gles_new_context(void **a1, void *a2)
{
  malloc_zone_t *malloc_zone;
  CA::OGL::GLESContext *result;

  if (*(_DWORD *)a1 != 3)
    return 0;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  result = (CA::OGL::GLESContext *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x898uLL, 0x743898A5uLL);
  if (result)
    return CA::OGL::GLESContext::GLESContext(result, a1[1]);
  return result;
}

uint64_t metal_new_context(void *a1, void *a2, int a3)
{
  return CA::OGL::new_metal_context(a1, a2, 0, a3, 0, CFSTR("com.apple.coreanimation.CARenderOGL"));
}

_QWORD *CARenderOGLNew_(uint64_t (**a1)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  malloc_zone_t *malloc_zone;
  _QWORD *v7;
  _QWORD *v8;

  v4 = (*a1)(a2, a3, a4);
  if (!v4)
    return 0;
  v5 = v4;
  *(_WORD *)(v4 + 816) |= 2u;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v7 = malloc_type_zone_malloc(malloc_zone, 0x68uLL, 0x8BB15036uLL);
  v8 = v7;
  if (v7)
  {
    v7[1] = 0;
    v7[2] = 0;
    *v7 = v5;
    v7[6] = malloc_type_malloc(0x40000uLL, 0xA44586FDuLL);
    v8[7] = 0;
    *((_DWORD *)v8 + 24) = 1;
    *((_WORD *)v8 + 50) = 0;
  }
  return v8;
}

_QWORD *CARenderOGLNew(uint64_t (**a1)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return CARenderOGLNew_(a1, a2, 0, a3);
}

uint64_t CARenderOGLGetGLContext(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 168);
}

_QWORD *CARenderOGLSetGLContext(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;

  v2 = (_QWORD *)*result;
  if (*(_QWORD *)(*result + 168) != a2)
  {
    result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*v2 + 1096))(*result);
    v2[21] = a2;
  }
  return result;
}

uint64_t CARenderOGLGetFeatureFlags(uint64_t a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 416);
}

uint64_t CARenderOGLSetFeatureFlags(uint64_t *a1, int a2)
{
  uint64_t result;
  int v3;

  result = *a1;
  v3 = *(_DWORD *)(result + 208);
  *(_DWORD *)(result + 208) = a2;
  *(_DWORD *)(result + 416) = global_feature_flags | a2;
  if (((v3 ^ a2) & 0x2000200) != 0)
    return CA::OGL::Context::update_color_program_cache(result);
  return result;
}

uint64_t CARenderOGLGetColorSpace(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 144);
}

uint64_t CARenderOGLGetFlags(uint64_t a1)
{
  return (*(unsigned __int16 *)(*(_QWORD *)a1 + 816) >> 7) & 1;
}

CGColorSpace *CARenderOGLSetColorSpace(CA::OGL::Context **a1, CGColorSpace *a2)
{
  if (initialized[0] != -1)
    dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
  if (*(float *)&dword_1ECDC69D4)
    a2 = (CGColorSpace *)CAGetColorSpace(*(float *)&dword_1ECDC69D4);
  return CA::OGL::Context::set_colorspace(*a1, a2);
}

uint64_t CARenderOGLPurge(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*a1 + 224))(*a1, 1);
}

uint64_t CARenderOGLCollect(CA::OGL::Renderer *a1, const CA::Render::Update *a2)
{
  uint64_t v4;
  double v5;

  v4 = mach_absolute_time();
  v5 = CATimeWithHostTime(v4);
  CA::Render::collect(0, v5);
  return CA::OGL::Renderer::collect(a1, a2, v5);
}

void CARenderOGLDestroy(CA::OGL::Renderer *a1)
{
  uint64_t v2;
  malloc_zone_t *malloc_zone;

  v2 = *(_QWORD *)a1;
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)a1 + 224))(*(_QWORD *)a1, 1);
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  CA::OGL::Renderer::~Renderer(a1);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, a1);
}

uint64_t CARenderOGLWarmup(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 176))(*a1, 0);
}

void CARenderOGLPrepareUpdateShape(CA::OGL::Renderer *a1, uint64_t a2)
{
  CA::OGL::Renderer::prepare_clip_shape(a1, *(const CA::Render::Update **)(a2 + 16));
}

void CARenderOGLSetUpdateRect(CA::OGL::Renderer *a1, uint64_t a2, double a3, float64x2_t a4)
{
  int8x16_t v5;
  int8x16_t v6;
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x16_t v10;
  float64x2_t v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  float64x2_t v17;
  int32x4_t v18;
  CA::Shape *v19;
  int32x4_t v20;
  _OWORD v21[3];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v5 = *(int8x16_t *)(a2 + 16);
    a4.f64[0] = 0.0;
    v6 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a4, (float64x2_t)v5).i64[0], 0);
    v7.i64[1] = *(_QWORD *)(a2 + 24);
    *(double *)v7.i64 = -*(double *)v5.i64;
    v8 = vbslq_s8(v6, v7, v5);
    v9 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a4, (float64x2_t)vdupq_laneq_s64((int64x2_t)v5, 1)).i64[0], 0);
    v10.i64[0] = v8.i64[0];
    v10.i64[1] = *(_QWORD *)&vnegq_f64(*(float64x2_t *)&v5).f64[1];
    v11 = (float64x2_t)vbslq_s8(v9, v10, v8);
    v12 = (int8x16_t)vceqzq_f64(v11);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v12, 1), v12).u64[0] & 0x8000000000000000) != 0
      || (v13 = vorrq_s8((int8x16_t)vcltzq_f64(v11), (int8x16_t)vcgezq_f64(v11)),
          v14 = (int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v13), 1),
          (vornq_s8(v14, v13).u64[0] & 0x8000000000000000) != 0))
    {
      v20 = 0uLL;
    }
    else
    {
      v14.i64[0] = 0x8000000000000000;
      v15.i64[0] = *(_OWORD *)&vaddq_f64(*(float64x2_t *)a2, (float64x2_t)vbslq_s8(v6, v5, v14));
      v16.i64[0] = v15.i64[0];
      v16.i64[1] = *(_QWORD *)(a2 + 8);
      v15.i64[1] = *(_QWORD *)&vaddq_f64(*(float64x2_t *)&v5, *(float64x2_t *)a2).f64[1];
      v17 = (float64x2_t)vbslq_s8(v9, v15, v16);
      v18 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v17, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      v20 = vuzp1q_s32(v18, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v17, v11), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v18));
    }
    memset(v21, 0, sizeof(v21));
    CA::Shape::operator=((uint64_t)v21, &v20);
    CA::OGL::Renderer::set_clip_shape(a1, (CA::Shape *)v21);
  }
  else
  {
    v19 = (CA::Shape *)*((_QWORD *)a1 + 2);
    if (v19)
    {
      CA::Shape::unref(v19);
      *((_QWORD *)a1 + 2) = 0;
    }
  }
}

uint64_t CARenderOGLSetDisplay(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)result + 176) = a2;
  return result;
}

uint64_t CARenderOGLSetDestinationOffset(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 80))(*a1);
}

uint64_t CARenderOGLRender(CA::OGL *a1, CA::OGL::Renderer *a2)
{
  CA::Render::Update *v4;

  kdebug_trace();
  CA::OGL::render(a1, a2, v4);
  CA::Render::collect(0, *(double *)(*(_QWORD *)a1 + 224));
  CA::OGL::Renderer::collect(a1, a2, *(double *)(*(_QWORD *)a1 + 224));
  return kdebug_trace();
}

uint64_t CARenderOGLFlush(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*a1 + 408))(*a1, 1);
}

uint64_t CARenderOGLFinish(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 416))(*a1);
}

uint64_t CARenderOGLSetDestinationTexture(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 16))(*a1);
}

uint64_t CARenderOGLSetDestinationIOSurface(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, a2, a3, 0);
}

float CARenderOGLComputeSurfaceAPL(uint64_t *a1, uint64_t a2, int a3, uint64_t a4)
{
  char v5;
  uint64_t v6;
  uint64_t v7;
  float v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = 1057417593;
  v10 = 0;
  v11 = 0x3E851EB83E5A1CACLL;
  if (a4)
  {
    v11 = *(_QWORD *)a4;
    LODWORD(v12) = *(_DWORD *)(a4 + 8);
  }
  if (a3)
    v5 = 8;
  else
    v5 = 0;
  BYTE4(v12) = v5;
  v6 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)*a1 + 672))(*a1, 1, 0, 0);
  v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)*a1 + 872))(*a1, v6, &v10);
  (*(void (**)(uint64_t))(*(_QWORD *)*a1 + 416))(*a1);
  CA::OGL::Context::release_surface(*a1, v6);
  v8 = *(float *)(*(_QWORD *)v7 + 32);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)*a1 + 832))(*a1, v7);
  return v8;
}

uint64_t CARenderOGLSetHDRScalingFactor(uint64_t a1, float a2)
{
  _QWORD *v2;
  __n128 v3;
  uint64_t v4;

  v2 = *(_QWORD **)a1;
  v3.n128_f32[0] = powf(a2, *(float *)(*(_QWORD *)a1 + 152));
  v4 = v2[31];
  if (v4)
    *(_DWORD *)(v4 + 64) = v3.n128_u32[0];
  return (*(uint64_t (**)(_QWORD *, __n128))(*v2 + 1048))(v2, v3);
}

uint64_t CARenderOGLSetEDRScalingFactor(_QWORD **a1, float a2)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = *a1;
  v3 = v2[31];
  if (v3)
    *(float *)(v3 + 64) = a2;
  return (*(uint64_t (**)(_QWORD *))(*v2 + 1048))(v2);
}

uint64_t CARenderSoftwareSetDestination(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 1064))(*a1);
}

uint64_t CARenderGLESSetBounds(uint64_t result, uint64_t a2, double a3, float64x2_t a4)
{
  float64x2_t v4;
  int8x16_t v5;
  int8x16_t v6;
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  float64x2_t v10;
  int64x2_t v11;
  unint64_t v12;
  int32x4_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  int32x4_t v21;

  v4 = *(float64x2_t *)(a2 + 16);
  a4.f64[0] = 0.0;
  v5 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a4, v4).i64[0], 0);
  v6.i64[1] = *(_QWORD *)(a2 + 24);
  *(double *)v6.i64 = -v4.f64[0];
  v7 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a4, (float64x2_t)vdupq_laneq_s64((int64x2_t)v4, 1)).i64[0], 0);
  v8 = vbslq_s8(v5, v6, (int8x16_t)v4);
  v9.i64[0] = v8.i64[0];
  v9.i64[1] = *(_QWORD *)&vnegq_f64(v4).f64[1];
  v10 = (float64x2_t)vbslq_s8(v7, v9, v8);
  v11 = vceqzq_f64(v10);
  v12 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v11, 1), (int8x16_t)v11).u64[0];
  v13 = 0uLL;
  if ((v12 & 0x8000000000000000) == 0)
  {
    v14 = vorrq_s8((int8x16_t)vcltzq_f64(v10), (int8x16_t)vcgezq_f64(v10));
    v15 = vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v14), 1), v14);
    if ((v15.i64[0] & 0x8000000000000000) == 0)
    {
      v15.i64[0] = 0x8000000000000000;
      v16.i64[0] = *(_OWORD *)&vaddq_f64(*(float64x2_t *)a2, (float64x2_t)vbslq_s8(v5, (int8x16_t)v4, v15));
      v17.i64[0] = v16.i64[0];
      v17.i64[1] = *(_QWORD *)(a2 + 8);
      v16.i64[1] = *(_QWORD *)&vaddq_f64(v4, *(float64x2_t *)a2).f64[1];
      v18 = (float64x2_t)vbslq_s8(v7, v16, v17);
      v19 = vmaxnmq_f64(v18, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000));
      v20 = vminnmq_f64(vaddq_f64(v18, v10), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
      v21 = (int32x4_t)vcvtmq_s64_f64(v19);
      v13 = vuzp1q_s32(v21, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v20), (int64x2_t)v21));
    }
  }
  *(int32x4_t *)(*(_QWORD *)result + 184) = v13;
  return result;
}

uint64_t CARenderMTLGetState(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 112))(*a1);
}

uint64_t CARenderMTLSetState(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 104))(*a1);
}

uint64_t CARenderMTLCompileShader(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 120))(*a1);
}

uint64_t CARenderMTLLoadPipeline(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 128))(*a1);
}

uint64_t CARenderMTLSetDestinationTextures(_QWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 24))(*a1, 1, a2, a3, a4, 0);
}

uint64_t CARenderMTLSetAsyncCompileQueue(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 64))(*a1);
}

uint64_t `anonymous namespace'::_CARenderServerSnapshotDisplay(_anonymous_namespace_ *this, const __CFString *a2, void *cf, const void *a4, int a5, int a6, __int128 *a7, const CATransform3D *a8, uint64_t a9, unint64_t a10, unsigned int *a11, unsigned int a12)
{
  int v12;
  mach_port_t v15;
  CFTypeID v16;
  CFTypeID TypeID;
  CFTypeID v18;
  int v20;

  v20 = (int)a8;
  v12 = (int)a4;
  v15 = this;
  v16 = CFGetTypeID(cf);
  TypeID = IOSurfaceGetTypeID();
  v18 = CFGetTypeID(cf);
  if (v18 == CFNumberGetTypeID())
    return CARenderServerCaptureDisplayWithTransform_(v15, a2, objc_msgSend(cf, "intValue"), v12, a5, a6, a7, a9, a10, (int)a11);
  if (v16 == TypeID)
    return CARenderServerRenderDisplay_(v15, a2, cf, v12, a5, a6, a7, v20, a9, a10, (int)a11);
  return 0;
}

uint64_t `anonymous namespace'::get_context_list_info(_anonymous_namespace_ *this, NSArray *a2, unsigned int *a3, CATransform3D *a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  char *v12;
  void *v13;
  void *v14;
  __int128 v15;
  __int128 v16;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _BYTE v27[128];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v28 = 0u;
  v29 = 0u;
  v30 = 0u;
  v31 = 0u;
  result = -[_anonymous_namespace_ countByEnumeratingWithState:objects:count:](this, "countByEnumeratingWithState:objects:count:", &v28, v27, 16);
  if (result)
  {
    v7 = result;
    v8 = 0;
    v9 = *(_QWORD *)v29;
    do
    {
      v10 = 0;
      v11 = &a3[32 * v8];
      v18 = v8;
      v12 = (char *)a2 + 4 * v8;
      do
      {
        if (*(_QWORD *)v29 != v9)
          objc_enumerationMutation(this);
        v13 = *(void **)(*((_QWORD *)&v28 + 1) + 8 * v10);
        *(_DWORD *)&v12[4 * v10] = objc_msgSend((id)objc_msgSend(v13, "objectForKey:", CFSTR("contextId")), "unsignedIntValue");
        if (a3)
        {
          v14 = (void *)objc_msgSend(v13, "objectForKey:", CFSTR("transform"));
          if (v14)
          {
            objc_msgSend(v14, "CATransform3DValue");
            *((_OWORD *)v11 + 4) = v23;
            *((_OWORD *)v11 + 5) = v24;
            *((_OWORD *)v11 + 6) = v25;
            *((_OWORD *)v11 + 7) = v26;
            *(_OWORD *)v11 = v19;
            *((_OWORD *)v11 + 1) = v20;
            v15 = v21;
            v16 = v22;
          }
          else
          {
            *((_OWORD *)v11 + 4) = *(_OWORD *)&CATransform3DIdentity.m31;
            *((_OWORD *)v11 + 5) = *(_OWORD *)&CATransform3DIdentity.m33;
            *((_OWORD *)v11 + 6) = *(_OWORD *)&CATransform3DIdentity.m41;
            *((_OWORD *)v11 + 7) = *(_OWORD *)&CATransform3DIdentity.m43;
            *(_OWORD *)v11 = *(_OWORD *)&CATransform3DIdentity.m11;
            *((_OWORD *)v11 + 1) = *(_OWORD *)&CATransform3DIdentity.m13;
            v15 = *(_OWORD *)&CATransform3DIdentity.m21;
            v16 = *(_OWORD *)&CATransform3DIdentity.m23;
          }
          *((_OWORD *)v11 + 2) = v15;
          *((_OWORD *)v11 + 3) = v16;
        }
        ++v10;
        v11 += 32;
      }
      while (v7 != v10);
      v8 = v18 + v10;
      result = -[_anonymous_namespace_ countByEnumeratingWithState:objects:count:](this, "countByEnumeratingWithState:objects:count:", &v28, v27, 16);
      v7 = result;
    }
    while (result);
  }
  return result;
}

uint64_t CARenderServerCreateSnapshots(mach_port_t a1, unint64_t a2, __IOSurface **a3, void *a4)
{
  void *v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  const __CFString *v15;
  unsigned int v16;
  int v17;
  __IOSurface *iosurface_with_pixel_format;
  __IOSurface *v19;
  NSDictionary *v20;
  uint64_t v21;
  const __CFString *v22;
  __IOSurface *v23;
  NSDictionary *v24;
  unsigned int v26;
  mach_port_t v27;

  v8 = (void *)MEMORY[0x186DBE2E4]();
  v9 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", CFSTR("sizeWidth")), "unsignedIntValue");
  v10 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", CFSTR("sizeHeight")), "unsignedIntValue");
  v11 = 0;
  if (!v9)
    goto LABEL_30;
  v12 = v10;
  if (!v10)
    goto LABEL_30;
  if (!(a2 | (unint64_t)a3))
  {
    v11 = 0;
    goto LABEL_30;
  }
  if (a2)
    *(_QWORD *)a2 = 0;
  if (a3)
    *a3 = 0;
  if (objc_msgSend((id)objc_msgSend(a4, "objectForKey:", CFSTR("formatWideGamut")), "BOOLValue"))
  {
    if (objc_msgSend((id)objc_msgSend(a4, "objectForKey:", CFSTR("formatOpaque")), "BOOLValue"))
      v13 = 1999843442;
    else
      v13 = 1647534392;
  }
  else
  {
    v13 = 1111970369;
  }
  v14 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", CFSTR("mapCacheAttribute")), "unsignedIntValue");
  v16 = v14;
  if (v14)
  {
    if (v14 == 1)
      v17 = 32;
    else
      v17 = 0;
    if (v14 == 2)
      v16 = v17 | 0x10;
    else
      v16 = v17;
  }
  if (!a2)
  {
LABEL_29:
    v11 = 1;
    goto LABEL_30;
  }
  v26 = v13;
  iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format((CA::Render *)v13, v9, v12, v16, 0, CFSTR("CA Snapshot (Unprotected)"), v15);
  if (!iosurface_with_pixel_format)
  {
    *(_QWORD *)a2 = 0;
    goto LABEL_29;
  }
  v19 = iosurface_with_pixel_format;
  v27 = a1;
  v20 = (NSDictionary *)objc_msgSend(a4, "mutableCopy");
  -[NSDictionary setObject:forKey:](v20, "setObject:forKey:", v19, CFSTR("destination"));
  v21 = CARenderServerSnapshot_(a1, v20);

  *(_QWORD *)a2 = v19;
  v11 = 1;
  if (a3 && (v21 & 0x7FFFFFFFFFFFFFFFLL) != 0)
  {
    v23 = CA::Render::create_iosurface_with_pixel_format((CA::Render *)v26, v9, v12, v16 | 2, v21 & 0x7FFFFFFFFFFFFFFFLL, CFSTR("CA Snapshot (Protected)"), v22);
    if (v23)
    {
      v24 = (NSDictionary *)objc_msgSend(a4, "mutableCopy");
      -[NSDictionary setObject:forKey:](v24, "setObject:forKey:", v23, CFSTR("destination"));
      CARenderServerSnapshot_(v27, v24);

    }
    *a3 = v23;
  }
LABEL_30:
  objc_autoreleasePoolPop(v8);
  return v11;
}

void sub_184640C78(_Unwind_Exception *a1)
{
  void *v1;

  objc_autoreleasePoolPop(v1);
  _Unwind_Resume(a1);
}

void CARenderServerDumpVMRegions(void)
{
  NSObject *v0;
  uint64_t v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  int *v8;
  uint64_t i;
  char *v10;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;
  void *v15;
  NSObject *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t j;
  void *v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  _BYTE v30[128];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint8_t buf[4];
  uint64_t v36;
  _BYTE v37[128];
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v0 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_184457000, v0, OS_LOG_TYPE_ERROR, "Dumping VM regions!", buf, 2u);
    }
  }
  v1 = VMUGetFlagsForAllVMRegionStatistics() | 0x90181;
  v2 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0DAFEE0]), "initWithTask:options:", *MEMORY[0x1E0C83DA0], v1);
  v38 = 0u;
  v39 = 0u;
  v40 = 0u;
  v41 = 0u;
  v29 = v2;
  v3 = (void *)objc_msgSend(v2, "regions");
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v38, v37, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v39;
    v7 = (_QWORD *)MEMORY[0x1E0DAFF18];
    v8 = (int *)MEMORY[0x1E0DAFF00];
    do
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v39 != v6)
          objc_enumerationMutation(v3);
        v10 = *(char **)(*((_QWORD *)&v38 + 1) + 8 * i);
        if ((objc_msgSend(v10, "isSubmap", v28) & 1) == 0
          && (objc_msgSend((id)objc_msgSend(v10, "type"), "hasPrefix:", *v7) & 1) == 0)
        {
          v11 = &v10[*v8];
          v12 = *(_QWORD *)v11;
          v13 = *((_QWORD *)v11 + 1) + *(_QWORD *)v11;
          v14 = v12 >> 31 < 3 || v13 > 0x300000000;
          if (v14 || *(_QWORD *)&v10[*MEMORY[0x1E0DAFEE8]] + *(_QWORD *)&v10[*MEMORY[0x1E0DAFF08]])
          {
            v15 = (void *)objc_msgSend(v10, "descriptionWithOptions:maximumLength:", v1, 0);
            if (x_log_hook_p())
            {
              v28 = objc_msgSend(v15, "UTF8String");
              x_log_();
            }
            else
            {
              v16 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
              {
                v17 = objc_msgSend(v15, "UTF8String");
                *(_DWORD *)buf = 136315138;
                v36 = v17;
                _os_log_impl(&dword_184457000, v16, OS_LOG_TYPE_ERROR, "%s", buf, 0xCu);
              }
            }
          }
        }
      }
      v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v38, v37, 16);
    }
    while (v5);
  }
  v18 = (void *)objc_msgSend((id)objc_msgSend(v29, "descriptionForRegionTotals:", v1, v28), "componentsSeparatedByString:", CFSTR("\n"));
  if (x_log_hook_p())
  {
    x_log_();
    v19 = &unk_1ECDC6000;
  }
  else
  {
    v19 = &unk_1ECDC6000;
    v20 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_184457000, v20, OS_LOG_TYPE_ERROR, "SUMMARY:\n", buf, 2u);
    }
  }
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v21 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v31, v30, 16);
  if (v21)
  {
    v22 = v21;
    v23 = *(_QWORD *)v32;
    do
    {
      for (j = 0; j != v22; ++j)
      {
        if (*(_QWORD *)v32 != v23)
          objc_enumerationMutation(v18);
        v25 = *(void **)(*((_QWORD *)&v31 + 1) + 8 * j);
        if (x_log_hook_p())
        {
          objc_msgSend(v25, "UTF8String");
          x_log_();
        }
        else
        {
          v26 = *((_QWORD *)v19 + 56);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            v27 = objc_msgSend(v25, "UTF8String");
            *(_DWORD *)buf = 136315138;
            v36 = v27;
            _os_log_impl(&dword_184457000, v26, OS_LOG_TYPE_ERROR, "%s\n", buf, 0xCu);
          }
        }
      }
      v22 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v31, v30, 16);
    }
    while (v22);
  }

}

uint64_t CA::WindowServer::Surface::lock(CA::WindowServer::Surface *this, unsigned __int8 **a2, unint64_t *a3)
{
  return 0;
}

void CA::WindowServer::SharedEvent::~SharedEvent(CA::WindowServer::SharedEvent *this)
{
  void *v2;
  void *v3;
  uint64_t v4;
  __IOSurface *v5;
  NSObject *v6;
  __IOSurface *v7;
  uint8_t buf[4];
  IOSurfaceID ID;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (initialized[0] != -1)
    dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
  if (BYTE6(xmmword_1ECDC6AF0))
  {
    if (x_log_hook_p())
    {
      v5 = (__IOSurface *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 160))(*(_QWORD *)this);
      IOSurfaceGetID(v5);
      x_log_();
    }
    else
    {
      v6 = x_log_category_sharedevent;
      if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEBUG))
      {
        v7 = (__IOSurface *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 160))(*(_QWORD *)this);
        *(_DWORD *)buf = 67109120;
        ID = IOSurfaceGetID(v7);
        _os_log_impl(&dword_184457000, v6, OS_LOG_TYPE_DEBUG, "IOSurfaceID: 0x%x  Dealloc", buf, 8u);
      }
    }
  }
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)

  *((_QWORD *)this + 1) = 0;
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)

  *((_QWORD *)this + 3) = 0;
  v4 = *((_QWORD *)this + 8);
  if (v4)
    MEMORY[0x186DBD990](v4, 0x1000C4055D675C7);
}

BOOL CA::WindowServer::SharedEvent::is_complete_with_timeout(CA::WindowServer::SharedEvent *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = (void *)*((_QWORD *)this + 1);
  if (!v2)
    return 1;
  v3 = objc_msgSend(v2, "signaledValue");
  v4 = v3;
  v5 = *((_QWORD *)this + 2);
  if (v3 != v5)
  {
    if (*((_QWORD *)this + 6) != v3)
    {
      *((_QWORD *)this + 6) = v3;
      goto LABEL_8;
    }
    v6 = mach_continuous_time();
    if (CATimeWithHostTime(v6 - *((_QWORD *)this + 7)) > 10.0)
    {
      CA::WindowServer::SharedEvent::force_complete(this, 1);
      v4 = objc_msgSend(*((id *)this + 1), "signaledValue");
      *((_QWORD *)this + 6) = v4;
LABEL_8:
      *((_QWORD *)this + 7) = mach_continuous_time();
    }
  }
  return v4 == v5;
}

void *CA::WindowServer::SharedEvent::force_complete(CA::WindowServer::SharedEvent *this, int a2)
{
  void *result;
  unint64_t v5;
  char *v6;
  const char *v7;
  const char *CString;
  __IOSurface *v9;
  NSObject *v10;
  const char *v11;
  const char *v12;
  __IOSurface *v13;
  IOSurfaceID v14;
  NSObject *v15;
  int *v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  int *v21;
  unint64_t v22;
  BOOL v23;
  BOOL v24;
  const char *v25;
  const char *v26;
  __IOSurface *v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  NSObject *v35;
  unint64_t v36;
  unint64_t v37;
  void *v38;
  uint64_t v39;
  char *v40;
  const char *v41;
  char *ID;
  char *v43;
  char *v44;
  uint64_t v45;
  char v46;
  uint8_t v47[4];
  char *v48;
  _OWORD v49[8];
  uint8_t buf[24];
  __int128 v51;
  char *v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  result = (void *)*((_QWORD *)this + 1);
  if (result)
  {
    result = (void *)objc_msgSend(result, "signaledValue");
    if (result != *((void **)this + 2))
    {
      v5 = objc_msgSend(*((id *)this + 1), "signaledValue");
      v6 = (char *)*((_QWORD *)this + 2);
      memset(v49, 0, sizeof(v49));
      if (x_log_hook_p())
      {
        if (a2)
          v7 = "True";
        else
          v7 = "False";
        CString = CA_CFStringGetCString(*(const __CFString **)(*(_QWORD *)this + 232), (char *)v49, 128);
        v9 = (__IOSurface *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 160))(*(_QWORD *)this);
        v43 = (char *)v5;
        v44 = v6;
        v41 = CString;
        ID = (char *)IOSurfaceGetID(v9);
        v40 = (char *)v7;
        x_log_();
      }
      else
      {
        v10 = x_log_category_sharedevent;
        if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEFAULT))
        {
          if (a2)
            v11 = "True";
          else
            v11 = "False";
          v12 = CA_CFStringGetCString(*(const __CFString **)(*(_QWORD *)this + 232), (char *)v49, 128);
          v13 = (__IOSurface *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 160))(*(_QWORD *)this);
          v14 = IOSurfaceGetID(v13);
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v11;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v12;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v51) = v14;
          WORD2(v51) = 2048;
          *(_QWORD *)((char *)&v51 + 6) = v5;
          HIWORD(v51) = 2048;
          v52 = v6;
          _os_log_impl(&dword_184457000, v10, OS_LOG_TYPE_DEFAULT, "force_complete () force_immediately: %s  IOSurfaceName: %s  IOSurfaceID: 0x%x  Value Completed: 0x%llx  Last Value Requested: 0x%llx", buf, 0x30u);
        }
      }
      if (a2)
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          v15 = x_log_category_sharedevent;
          if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_184457000, v15, OS_LOG_TYPE_ERROR, "shared event signal not complete and forcing immediate\n", buf, 2u);
          }
        }
      }
      v16 = (int *)*((_QWORD *)this + 8);
      if (v16)
      {
        v46 = a2;
        memset(buf, 0, sizeof(buf));
        if (*v16 <= 0x40)
          LOBYTE(v17) = 64;
        else
          v17 = *v16;
        if (*v16 >= 0x40)
          v18 = 64;
        else
          v18 = *v16;
        if (v18)
        {
          v19 = 0;
          v20 = *(_QWORD *)this;
          do
          {
            v21 = &v16[8 * (v17 & 0x3F)];
            v22 = *((_QWORD *)v21 + 4);
            v19 |= v22 == v5;
            if ((v19 & 1) != 0)
            {
              v23 = v22 >= v5;
              v24 = v22 == v5;
              v25 = "Not Completed";
              if (!v23)
                v25 = "Completed";
              if (v24)
                v26 = "Last Completed";
              else
                v26 = v25;
              v27 = (__IOSurface *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 160))(v20);
              v28 = (const char *)IOSurfaceGetID(v27);
              v44 = CA::WindowServer::SharedEvent::AccessString[v21[6]];
              v45 = *((_QWORD *)v21 + 4);
              ID = CA::WindowServer::SharedEvent::UsageString[v21[4]];
              v43 = CA::WindowServer::SharedEvent::OperationString[v21[5]];
              v41 = v28;
              x_stream_printf((uint64_t)buf, "%s IOSurfaceID: 0x%x  usage: %s  operation: %s  access: %s  value: 0x%llx\n", v29, v30, v31, v32, v33, v34, (uint64_t)v26);
            }
            LOBYTE(v17) = v17 + 1;
            --v18;
          }
          while (v18);
        }
        if (x_log_hook_p())
        {
          v40 = x_stream_get(buf);
          x_log_();
          LOBYTE(a2) = v46;
        }
        else
        {
          v35 = x_log_category_sharedevent;
          LOBYTE(a2) = v46;
          if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v47 = 136315138;
            v48 = x_stream_get(buf);
            _os_log_impl(&dword_184457000, v35, OS_LOG_TYPE_DEFAULT, "%s\n", v47, 0xCu);
          }
        }
        if (*(_QWORD *)buf)
          free(*(void **)buf);
      }
      v36 = v5 + 1;
      if ((a2 & 1) != 0)
        return (void *)objc_msgSend(*((id *)this + 1), "setSignaledValue:", v36, v40, v41, ID, v43, v44, v45);
      v37 = *((_QWORD *)this + 2);
      if (v36 >= v37)
      {
        return (void *)objc_msgSend(*((id *)this + 1), "setSignaledValue:", v36, v40, v41, ID, v43, v44, v45);
      }
      else
      {
        v38 = (void *)*((_QWORD *)this + 1);
        v39 = *((_QWORD *)this + 3);
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = ___ZN2CA11SurfaceUtil43CASurfaceAsyncWaitAndSignalSharedEventValueEPNS0_24CASurfaceSharedEventRef_EPNS0_29CASurfaceSharedEventListener_Eyy_block_invoke;
        *(_QWORD *)&v51 = &__block_descriptor_48_e33_v24__0__IOSurfaceSharedEvent_8Q16l;
        *((_QWORD *)&v51 + 1) = v37 - 1;
        v52 = (char *)v37;
        return (void *)objc_msgSend(v38, "notifyListener:atValue:block:", v39);
      }
    }
  }
  return result;
}

uint64_t CA::WindowServer::SharedEvent::get_wait_value(uint64_t a1, int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;

  v3 = 16;
  if (a3 == 1)
    v3 = 40;
  v4 = *(_QWORD *)(a1 + v3);
  if (*(_QWORD *)(a1 + 64))
    CA::WindowServer::SharedEvent::History::add(*(_DWORD **)(a1 + 64), *(_QWORD *)a1, a2, 1, a3, v4);
  return v4;
}

_DWORD *CA::WindowServer::SharedEvent::History::add(_DWORD *result, uint64_t a2, int a3, int a4, int a5, uint64_t a6)
{
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  __IOSurface *v15;
  __IOSurface *v16;
  NSObject *v17;
  __IOSurface *v18;
  IOSurfaceID ID;
  char *v20;
  char *v21;
  char *v22;
  uint8_t buf[4];
  IOSurfaceID v24;
  __int16 v25;
  char *v26;
  __int16 v27;
  char *v28;
  __int16 v29;
  char *v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (a3 != 1)
  {
    v11 = result;
    if (initialized[0] != -1)
      dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
    if (BYTE6(xmmword_1ECDC6AF0))
    {
      if (x_log_hook_p())
      {
        v16 = (__IOSurface *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 160))(a2);
        IOSurfaceGetID(v16);
        x_log_();
      }
      else
      {
        v17 = x_log_category_sharedevent;
        if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_INFO))
        {
          v18 = (__IOSurface *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 160))(a2);
          ID = IOSurfaceGetID(v18);
          v20 = CA::WindowServer::SharedEvent::UsageString[a3];
          v21 = CA::WindowServer::SharedEvent::OperationString[a4];
          v22 = CA::WindowServer::SharedEvent::AccessString[a5];
          *(_DWORD *)buf = 67110146;
          v24 = ID;
          v25 = 2080;
          v26 = v20;
          v27 = 2080;
          v28 = v21;
          v29 = 2080;
          v30 = v22;
          v31 = 2048;
          v32 = a6;
          _os_log_impl(&dword_184457000, v17, OS_LOG_TYPE_INFO, "IOSurfaceID: 0x%x  usage: %s  operation: %s  access: %s  value: %#llx", buf, 0x30u);
        }
      }
    }
    v12 = *v11 & 0x3FLL;
    v13 = mach_continuous_time();
    v14 = &v11[8 * v12];
    *((_QWORD *)v14 + 1) = v13;
    v14[4] = a3;
    v14[5] = a4;
    v14[6] = a5;
    *((_QWORD *)v14 + 4) = a6;
    ++*v11;
    v15 = (__IOSurface *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 160))(a2);
    return (_DWORD *)IOSurfaceGetID(v15);
  }
  return result;
}

uint64_t CA::WindowServer::SharedEvent::inc_signal_value(uint64_t a1, int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 16) + 1;
  *(_QWORD *)(a1 + 16) = v3;
  if ((a2 - 8) > 5)
  {
    v4 = 0;
  }
  else
  {
    v4 = v3;
    if (*(_QWORD *)(a1 + 32))
      goto LABEL_6;
  }
  *(_QWORD *)(a1 + 32) = v4;
LABEL_6:
  if (a3 == 2)
    *(_QWORD *)(a1 + 40) = v3;
  if (*(_QWORD *)(a1 + 64))
    CA::WindowServer::SharedEvent::History::add(*(_DWORD **)(a1 + 64), *(_QWORD *)a1, a2, 2, a3, v3);
  return v3;
}

uint64_t CA::WindowServer::Surface::bits_per_pixel(CA::WindowServer::Surface *this)
{
  uint64_t v1;
  int v2;
  unsigned __int16 v3;
  int v4;
  unsigned __int16 v5;
  int v6;
  unsigned __int16 v7;
  int v8;
  unsigned __int16 v9;
  int v10;

  if ((int)this > 1534354995)
  {
    if ((int)this <= 1886680623)
    {
      if ((int)this > 1647534391)
      {
        if ((int)this > 1885745711)
        {
          if ((int)this <= 1886676527)
          {
            if ((_DWORD)this != 1885745712)
            {
              if ((_DWORD)this != 1885745714)
              {
                v2 = 1885746228;
                goto LABEL_121;
              }
              return 22;
            }
            return 16;
          }
          if ((_DWORD)this == 1886676528)
            return 20;
          if ((_DWORD)this == 1886676530)
            return 26;
          if ((_DWORD)this != 1886676532)
            return 0;
          return 39;
        }
        if ((int)this > 1882468911)
        {
          if ((_DWORD)this != 1882468912)
          {
            if ((_DWORD)this != 1882468914)
            {
              v2 = 1882469428;
              goto LABEL_121;
            }
            return 22;
          }
          return 16;
        }
        if ((_DWORD)this == 1647534392)
          return 40;
        v2 = 1815162994;
        goto LABEL_121;
      }
      if ((int)this <= 1534617137)
      {
        if ((int)this <= 1534359089)
        {
          if ((_DWORD)this != 1534354996)
          {
            v6 = 1534359088;
            goto LABEL_134;
          }
        }
        else
        {
          if ((_DWORD)this == 1534359090)
            return 32;
          if ((_DWORD)this != 1534359092)
          {
            v6 = 1534617136;
            goto LABEL_134;
          }
        }
        return 48;
      }
      if ((int)this <= 1534621231)
      {
        if ((_DWORD)this == 1534617138)
          return 32;
        v9 = 26164;
      }
      else
      {
        if ((_DWORD)this == 1534621232)
          return 24;
        if ((_DWORD)this == 1534621234)
          return 32;
        v9 = 30260;
      }
      v4 = v9 | 0x5B780000;
LABEL_126:
      if ((_DWORD)this != v4)
        return 0;
      return 48;
    }
    if ((int)this <= 1999908960)
    {
      if ((int)this <= 1952855091)
      {
        if ((int)this <= 1886680627)
        {
          if ((_DWORD)this != 1886680624)
          {
            v10 = 1886680626;
            goto LABEL_109;
          }
          return 20;
        }
        if ((_DWORD)this == 1886680628)
          return 39;
        if ((_DWORD)this != 1952854576)
        {
          v2 = 1952854578;
          goto LABEL_121;
        }
        return 24;
      }
      if ((int)this <= 1953903153)
      {
        if ((_DWORD)this != 1952855092)
        {
          v6 = 1953903152;
          goto LABEL_134;
        }
      }
      else
      {
        if ((_DWORD)this == 1953903154)
          return 32;
        if ((_DWORD)this != 1953903668)
        {
          v2 = 1999843442;
          goto LABEL_121;
        }
      }
    }
    else
    {
      if ((int)this > 2019963439)
      {
        if ((int)this > 2019964015)
        {
          if ((_DWORD)this == 2019964016)
            return 32;
          if ((_DWORD)this == 2037741171)
            return 16;
          v8 = 2037741158;
          goto LABEL_130;
        }
        if ((_DWORD)this == 2019963440)
          return 24;
        if ((_DWORD)this == 2019963442)
          return 32;
        v4 = 2019963956;
        goto LABEL_126;
      }
      if ((int)this <= 2016686641)
      {
        if ((_DWORD)this == 1999908961)
          return 64;
        v6 = 2016686640;
        goto LABEL_134;
      }
      if ((_DWORD)this == 2016686642)
        return 32;
      if ((_DWORD)this != 2016687156)
      {
        v2 = 2016687216;
        goto LABEL_121;
      }
    }
    return 48;
  }
  v1 = 12;
  if ((int)this > 645428783)
  {
    if ((int)this > 1111970368)
    {
      if ((int)this <= 1530422835)
      {
        if ((int)this <= 1380411456)
        {
          if ((_DWORD)this == 1111970369)
            return 32;
          v8 = 1278555701;
LABEL_130:
          if ((_DWORD)this != v8)
            return 0;
          return 16;
        }
        if ((_DWORD)this == 1380411457)
          return 64;
        if ((_DWORD)this == 1530422832)
          return v1;
        v3 = 26162;
      }
      else
      {
        if ((int)this > 1530426931)
        {
          if ((_DWORD)this == 1530426932 || (_DWORD)this == 1534354992)
            return 24;
          v2 = 1534354994;
          goto LABEL_121;
        }
        if ((_DWORD)this == 1530422836)
          return 24;
        if ((_DWORD)this == 1530426928)
          return v1;
        v3 = 30258;
      }
      v8 = v3 | 0x5B380000;
      goto LABEL_130;
    }
    if ((int)this <= 875704933)
    {
      if ((int)this <= 645428787)
      {
        if ((_DWORD)this != 645428784)
        {
          if ((_DWORD)this != 645428786)
            return 0;
          return 22;
        }
        return 16;
      }
      if ((_DWORD)this == 645428788)
        return 32;
      if ((_DWORD)this != 875704422 && (_DWORD)this != 875704438)
        return 0;
      return v1;
    }
    if ((int)this <= 875836467)
    {
      if ((_DWORD)this == 875704934)
        return 16;
      v8 = 875704950;
      goto LABEL_130;
    }
    if ((_DWORD)this == 875836468)
      return 16;
    if ((_DWORD)this == 875836518)
      return 24;
    v6 = 875836534;
LABEL_134:
    if ((_DWORD)this != v6)
      return 0;
    return 24;
  }
  if ((int)this > 645162543)
  {
    if ((int)this > 645166643)
    {
      if ((int)this <= 645424687)
      {
        if ((_DWORD)this != 645166644)
        {
          if ((_DWORD)this != 645346162)
          {
            if ((_DWORD)this != 645346401)
              return 0;
            return 64;
          }
          return 32;
        }
        return 39;
      }
      if ((_DWORD)this != 645424688)
      {
        if ((_DWORD)this != 645424690)
        {
          v2 = 645424692;
          goto LABEL_121;
        }
        return 22;
      }
      return 16;
    }
    if ((int)this <= 645162547)
    {
      if ((_DWORD)this != 645162544)
      {
        v7 = 26162;
        goto LABEL_108;
      }
      return 20;
    }
    if ((_DWORD)this != 645162548)
    {
      if ((_DWORD)this != 645166640)
      {
        v7 = 30258;
LABEL_108:
        v10 = v7 | 0x26740000;
LABEL_109:
        if ((_DWORD)this != v10)
          return 0;
        return 26;
      }
      return 20;
    }
    return 39;
  }
  if ((int)this > 641234483)
  {
    if ((int)this > 642934848)
    {
      if ((_DWORD)this != 642934849)
      {
        if ((_DWORD)this != 643969848)
        {
          v2 = 644624754;
          goto LABEL_121;
        }
        return 40;
      }
      return 64;
    }
    if ((_DWORD)this == 641234484)
      return 24;
    v2 = 641877825;
LABEL_121:
    if ((_DWORD)this == v2)
      return 32;
    return 0;
  }
  if ((int)this <= 641230387)
  {
    if ((_DWORD)this == 641230384)
      return v1;
    v5 = 26162;
    goto LABEL_98;
  }
  if ((_DWORD)this == 641230388)
    return 24;
  if ((_DWORD)this != 641234480)
  {
    v5 = 30258;
LABEL_98:
    v8 = v5 | 0x26380000;
    goto LABEL_130;
  }
  return v1;
}

uint64_t ___ZN2CA12WindowServer19accelerator_runloopEv_block_invoke()
{
  _opaque_pthread_t *v0;
  _QWORD v2[2];
  pthread_cond_t v3;
  pthread_mutex_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  memset(&v4, 0, sizeof(v4));
  pthread_mutex_init(&v4, 0);
  memset(&v3, 0, sizeof(v3));
  pthread_cond_init(&v3, 0);
  v2[0] = &v4;
  v2[1] = &v3;
  v0 = x_thread_create((uint64_t)_ZZZN2CA12WindowServer19accelerator_runloopEvEUb_EN3__08__invokeEPv, (uint64_t)v2, 0);
  CA::Render::Server::set_thread_priority(v0, (_opaque_pthread_t *)0xFFFFFFFFLL);
  pthread_mutex_lock(&v4);
  while (!CA::WindowServer::accelerator_runloop(void)::runloop)
    pthread_cond_wait(&v3, &v4);
  pthread_mutex_unlock(&v4);
  pthread_cond_destroy(&v3);
  return pthread_mutex_destroy(&v4);
}

void _ZZZN2CA12WindowServer19accelerator_runloopEvEUb_EN3__08__invokeEPv(uint64_t a1)
{
  int v2;
  int v3;
  NSObject *v4;
  CFAbsoluteTime Current;
  __CFRunLoopTimer *v6;
  int v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = pthread_setname_np("com.apple.coreanimation.msr_runloop");
  if (v2)
  {
    v3 = v2;
    v4 = x_log_category_utilities;
    if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
    {
      v7 = 136315394;
      v8 = "com.apple.coreanimation.msr_runloop";
      v9 = 1024;
      v10 = v3;
      _os_log_error_impl(&dword_184457000, v4, OS_LOG_TYPE_ERROR, "pthread_setname_np(%s) returned %d\n", (uint8_t *)&v7, 0x12u);
    }
  }
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  CA::WindowServer::accelerator_runloop(void)::runloop = (uint64_t)CFRunLoopGetCurrent();
  Current = CFAbsoluteTimeGetCurrent();
  v6 = CFRunLoopTimerCreate(0, Current + 3153600000.0, 3153600000.0, 0, 0, (CFRunLoopTimerCallBack)_ZZZZN2CA12WindowServer19accelerator_runloopEvEUb_ENK3__0clEPvENUlP16__CFRunLoopTimerS2_E_8__invokeES4_S2_, 0);
  CFRunLoopAddTimer((CFRunLoopRef)CA::WindowServer::accelerator_runloop(void)::runloop, v6, (CFRunLoopMode)*MEMORY[0x1E0C9B280]);
  pthread_cond_signal(*(pthread_cond_t **)(a1 + 8));
  pthread_mutex_unlock(*(pthread_mutex_t **)a1);
  CFRunLoopRun();
}

void sub_1846426E4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::OGL::SWContext::~SWContext(CA::OGL::SWContext *this)
{
  malloc_zone_t *malloc_zone;

  CA::OGL::Context::~Context(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

uint64_t CA::OGL::SWContext::get(uint64_t a1, int a2)
{
  uint64_t result;

  result = 1;
  switch(a2)
  {
    case 1:
    case 2:
      result = 4096;
      break;
    case 3:
      result = 3;
      break;
    case 4:
    case 7:
      result = 0x4000;
      break;
    case 5:
      goto LABEL_7;
    case 6:
    case 8:
      return result;
    default:
      if (a2 != 21)
      {
        if (a2 == 28)
          result = 0;
        else
LABEL_7:
          result = a2 == 28 || a2 == 16;
      }
      break;
  }
  return result;
}

void CA::OGL::SWContext::draw_elements(uint64_t this, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _QWORD *a8)
{
  uint64_t v13;
  unsigned __int8 *v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  char *v32;
  unsigned int v33;
  int *v34;
  unsigned int *v35;
  int v36;
  uint64_t v37;
  _QWORD *v38;
  _BYTE *v39;
  _BYTE *v40;
  unsigned __int8 v41;
  uint64_t v42;
  CA::Render *v43;
  char *v44;
  __IOSurface *v45;
  uint64_t ProtectionOptions;
  _QWORD *v47;
  int v48;
  char *v49;
  unint64_t v50;
  unint64_t v51;
  CA::Render *v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  unsigned int v56;
  unsigned int v57;
  int v58;
  OSType PixelFormat;
  unsigned int v60;
  unint64_t v61;
  CA::Render *v62;
  CGImage *v63;
  __IOSurface *v64;
  __IOSurface *v65;
  unint64_t v66;
  int v67;
  void *v68;
  char *v69;
  CA::OGL::SW *v70;
  uint64_t v71;
  _BYTE *v72;
  unsigned __int8 v73;
  unsigned __int8 v74;
  unsigned __int8 v75;
  unsigned __int8 v76;
  unsigned __int8 v77;
  size_t v78;
  char *v79;
  const void *v80;
  CA::Render::Surface *v81;
  const __CFData *v82;
  void *v83;
  void *v84;
  CGColorSpace *ColorSpace;
  uint64_t v86;
  unsigned int *v87;
  _BYTE *v88;
  unsigned int *v89;
  uint64_t v90;
  char *v91;
  uint64_t v92;
  _BYTE *v93;
  _BYTE *v94;
  int32x2_t *v95;
  int32x2_t v96;
  char *v97;
  unsigned __int8 v98;
  unsigned __int8 v99;
  char *v100;
  unsigned __int8 v101;
  unsigned __int8 v102;
  unsigned __int8 v103;
  unsigned __int8 v104;
  uint64_t v105;
  char *v106;
  unsigned __int8 v107;
  unsigned __int8 v108;
  unsigned __int8 v109;
  BOOL v110;
  char *v111;
  uint64_t v112;
  int8x16_t v113;
  void *v114;
  void *v115;
  void *v116;
  void *v117;
  void *v118;
  void *v119;
  void *v120;
  void *v121;
  int v122;
  char *v123;
  uint64_t v124;
  int8x16_t v125;
  int v126;
  char *v127;
  uint64_t v128;
  int8x16_t v129;
  int v130;
  char *v131;
  uint64_t v132;
  int8x16_t v133;
  int v134;
  char *v135;
  uint64_t v136;
  int8x16_t v137;
  int v138;
  char *v139;
  uint64_t v140;
  int8x16_t v141;
  int v142;
  char *v143;
  uint64_t v144;
  int8x16_t v145;
  _QWORD *v146;
  uint64_t v147;
  uint64_t v148;
  unsigned int v149;
  uint64_t v150;
  unint64_t v151;
  CA::OGL::Context *v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  unint64_t v156;
  unint64_t v157;
  float64x2_t *v158;
  _QWORD *v159;
  uint64_t v160;
  unsigned int v161;
  _QWORD *v162;
  void (*v163)(_QWORD);
  size_t v164;
  size_t BytesPerRowOfPlane;
  unsigned int v166;
  CA::Render *c;
  CGContextRef ca;
  CGContext *cb;
  size_t bytesPerRow;
  OSType bytesPerRowa;
  void *bytesPerRowb;
  CGImageRef image;
  CGImageRef imagea;
  CGImage *imageb;
  size_t width;
  size_t widtha;
  CA::Render::Surface *v178;
  CA::Render::Surface *v179;
  size_t height;
  unsigned int heighta;
  __IOSurface *buffer;
  CGImageSource *buffera;
  IOSurfaceRef bufferb;
  int8x16_t v185;
  int8x16_t v186;
  int8x16_t v187;
  int8x16_t v188;
  int8x16_t v189;
  int8x16_t v190;
  int8x16_t v191;
  int8x16_t v192;
  int8x16_t v193;
  int8x16_t v194;
  int8x16_t v195;
  int8x16_t v196;
  int64x2_t v197;
  int8x16_t v198;
  int8x16_t v199;
  const __CFAllocator *bytesDeallocator;
  void **v201;
  unsigned int v202;
  unsigned int v203;
  uint64_t v204;
  uint64_t v205;
  _QWORD *v206;
  CA::OGL::Context *v207;
  unsigned __int8 *v208;
  unsigned __int8 *v209;
  unint64_t v210;
  vImage_Buffer dest;
  vImage_Buffer srcCbCr;
  vImage_Buffer srcYp;
  uint8_t permuteMap[4];
  _QWORD v215[3];
  _QWORD *v216;
  int v217[4];
  _OWORD v218[17];
  __int128 v219;
  __int128 v220;
  __int128 v221;
  vImage_YpCbCrToARGB outInfo;
  uint64_t v223;
  CGRect v224;

  v13 = this;
  v223 = *MEMORY[0x1E0C80C00];
  v220 = 0u;
  v221 = 0u;
  v219 = 0u;
  memset(v218, 0, sizeof(v218));
  v14 = *(unsigned __int8 **)(this + 16);
  v15 = *(_QWORD *)(this + 256);
  if (v15 != *(_QWORD *)(this + 248))
    goto LABEL_2;
  if (v15)
    LODWORD(v15) = (*(unsigned __int8 *)(v15 + 72) >> 1) & 0x1F;
  if (*(_DWORD *)(this + 244) != (_DWORD)v15)
LABEL_2:
    this = CA::OGL::Context::prepare_destination_((CA::OGL::Context *)this);
  if ((*(_WORD *)(v13 + 816) & 0x200) != 0)
  {
    this = *(_QWORD *)(v13 + 176);
    if (this)
    {
      *(_WORD *)(v13 + 816) &= ~0x200u;
    }
  }
  v16 = *(_DWORD *)(v13 + 1888);
  LODWORD(v219) = v16;
  v17 = *(_DWORD *)(v13 + 1896);
  DWORD1(v219) = v17;
  v18 = *(_DWORD *)(v13 + 1892);
  DWORD2(v219) = v18;
  v19 = *(_DWORD *)(v13 + 1900);
  HIDWORD(v219) = v19;
  if (*(_BYTE *)(v13 + 64))
  {
    v20 = *(_DWORD *)(v13 + 32);
    v21 = *(_DWORD *)(v13 + 36);
    v22 = *(_DWORD *)(v13 + 40) + v20;
    v23 = *(_DWORD *)(v13 + 44) + v21;
    if (v16 <= v20)
      v16 = *(_DWORD *)(v13 + 32);
    LODWORD(v219) = v16;
    if (v17 <= v21)
      v17 = v21;
    DWORD1(v219) = v17;
    if (v18 >= v22)
      v18 = v22;
    DWORD2(v219) = v18;
    if (v19 >= v23)
      v19 = v23;
    HIDWORD(v219) = v19;
  }
  v202 = a2;
  v203 = a3;
  v204 = a4;
  v205 = a5;
  v206 = a8;
  v217[0] = v16;
  v217[1] = v17;
  v217[2] = v18 - v16;
  v217[3] = v19 - v17;
  v207 = (CA::OGL::Context *)v13;
  if (v14[480])
  {
    v24 = CA::OGL::tex_image_count[v14[16]];
    v25 = ~(-1 << v24);
    DWORD1(v220) = v25;
    *(_QWORD *)&v218[0] = v13;
    LODWORD(v220) = 0;
    if (v24)
    {
      v26 = 0;
      v209 = v14 + 17;
      bytesDeallocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
      v199 = (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,CA::Vec4<float>,true,true,true,true>);
      __asm { FMOV            V8.2S, #1.0 }
      v197 = vdupq_n_s64(2uLL);
      v198 = (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,CA::Vec4<float>,true,true,false,true>);
      v195 = (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::square_sampler<false>);
      v196 = (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::square_sampler<true>);
      v193 = (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::circle_sampler<false,false>);
      v194 = (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::circle_sampler<true,false>);
      v191 = (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::circle_sampler<false,true>);
      v192 = (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::circle_sampler<true,true>);
      v189 = (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::uneven_circle_sampler<false,false>);
      v190 = (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::uneven_circle_sampler<true,false>);
      v187 = (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::uneven_circle_sampler<false,true>);
      v188 = (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::uneven_circle_sampler<true,true>);
      v185 = (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::gaussian_sampler<false>);
      v186 = (int8x16_t)vdupq_n_s64((unint64_t)CA::OGL::SW::gaussian_sampler<true>);
      v208 = v14;
      while (1)
      {
        if ((v25 & 1) == 0)
          goto LABEL_146;
        v32 = (char *)v218 + 88 * v26;
        v33 = v209[v26];
        *((_DWORD *)v32 + 4) = -1;
        v34 = (int *)(v32 + 16);
        v35 = (unsigned int *)(v34 - 2);
        v36 = *(unsigned __int16 *)&v14[2 * v26 + 144];
        v37 = *(_QWORD *)&v14[8 * v26 + 176];
        *((_QWORD *)v34 + 8) = 0;
        v38 = v34 + 16;
        v39 = (char *)v34 + 57;
        *((_WORD *)v34 + 28) = 0;
        v40 = v34 + 14;
        if ((v36 - 1) < 2)
          break;
        if (v36 == 3)
        {
          *(_QWORD *)v35 = *(_QWORD *)(v37 + 88);
          v47 = (_QWORD *)v218 + 11 * v26;
          v47[3] = *(_QWORD *)(v37 + 80);
          *v40 = 8 * ((*(_BYTE *)(v37 + 120) & 0xF) != 0);
          *v39 = 8 * (*(unsigned __int8 *)(v37 + 120) > 0xFu);
          v47[4] = *(_QWORD *)(v37 + 40);
          if ((*(_DWORD *)(v37 + 68) & 7) != 0)
            v48 = 1;
          else
            v48 = 9;
          *v34 = v48;
          this = (uint64_t)&CA::OGL::SW::sampler_functions::samplers[16 * v48];
          v47[7] = this;
        }
        else if (v36 == 4)
        {
          *((_QWORD *)&v218[2] + 11 * v26) = 0x100000001;
          switch(v37)
          {
            case 1:
              if ((v41 & 1) == 0)
              {
                v39 = (char *)v34 + 57;
                if (v122)
                {
                  v123 = (char *)malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  v124 = 0;
                  v125 = (int8x16_t)xmmword_18474E1C0;
                  do
                  {
                    *(int8x16_t *)&v123[v124] = vbslq_s8((int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v125, (int8x16_t)vdupq_n_s64(4uLL))), v195, v196);
                    v125 = (int8x16_t)vaddq_s64((int64x2_t)v125, vdupq_n_s64(2uLL));
                    v124 += 16;
                  }
                  while (v124 != 128);
                  CA::OGL::SW::square_samplers(void)::s = (uint64_t)v123;
                  v39 = (char *)v34 + 57;
                }
              }
              this = CA::OGL::SW::square_samplers(void)::s;
              goto LABEL_87;
            case 2:
              if ((v73 & 1) == 0)
              {
                v39 = (char *)v34 + 57;
                if (v126)
                {
                  v127 = (char *)malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  v128 = 0;
                  v129 = (int8x16_t)xmmword_18474E1C0;
                  do
                  {
                    *(int8x16_t *)&v127[v128] = vbslq_s8((int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v129, (int8x16_t)vdupq_n_s64(4uLL))), v193, v194);
                    v129 = (int8x16_t)vaddq_s64((int64x2_t)v129, vdupq_n_s64(2uLL));
                    v128 += 16;
                  }
                  while (v128 != 128);
                  CA::OGL::SW::circle_samplers(void)::s = (uint64_t)v127;
                  v39 = (char *)v34 + 57;
                }
              }
              this = CA::OGL::SW::circle_samplers(void)::s;
              goto LABEL_87;
            case 3:
              if ((v74 & 1) == 0)
              {
                v39 = (char *)v34 + 57;
                if (v130)
                {
                  v131 = (char *)malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  v132 = 0;
                  v133 = (int8x16_t)xmmword_18474E1C0;
                  do
                  {
                    *(int8x16_t *)&v131[v132] = vbslq_s8((int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v133, (int8x16_t)vdupq_n_s64(4uLL))), v191, v192);
                    v133 = (int8x16_t)vaddq_s64((int64x2_t)v133, vdupq_n_s64(2uLL));
                    v132 += 16;
                  }
                  while (v132 != 128);
                  CA::OGL::SW::supercircle_samplers(void)::s = (uint64_t)v131;
                  v39 = (char *)v34 + 57;
                }
              }
              this = CA::OGL::SW::supercircle_samplers(void)::s;
              goto LABEL_87;
            case 4:
              if ((v75 & 1) == 0)
              {
                v39 = (char *)v34 + 57;
                if (v134)
                {
                  v135 = (char *)malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  v136 = 0;
                  v137 = (int8x16_t)xmmword_18474E1C0;
                  do
                  {
                    *(int8x16_t *)&v135[v136] = vbslq_s8((int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v137, (int8x16_t)vdupq_n_s64(4uLL))), v189, v190);
                    v137 = (int8x16_t)vaddq_s64((int64x2_t)v137, vdupq_n_s64(2uLL));
                    v136 += 16;
                  }
                  while (v136 != 128);
                  CA::OGL::SW::uneven_circle_samplers(void)::s = (uint64_t)v135;
                  v39 = (char *)v34 + 57;
                }
              }
              this = CA::OGL::SW::uneven_circle_samplers(void)::s;
              goto LABEL_87;
            case 5:
              if ((v76 & 1) == 0)
              {
                v39 = (char *)v34 + 57;
                if (v138)
                {
                  v139 = (char *)malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  v140 = 0;
                  v141 = (int8x16_t)xmmword_18474E1C0;
                  do
                  {
                    *(int8x16_t *)&v139[v140] = vbslq_s8((int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v141, (int8x16_t)vdupq_n_s64(4uLL))), v187, v188);
                    v141 = (int8x16_t)vaddq_s64((int64x2_t)v141, vdupq_n_s64(2uLL));
                    v140 += 16;
                  }
                  while (v140 != 128);
                  CA::OGL::SW::uneven_supercircle_samplers(void)::s = (uint64_t)v139;
                  v39 = (char *)v34 + 57;
                }
              }
              this = CA::OGL::SW::uneven_supercircle_samplers(void)::s;
LABEL_87:
              *((_QWORD *)&v218[3] + 11 * v26 + 1) = this;
              LODWORD(v220) = v220 | 1;
              break;
            case 6:
              if ((v77 & 1) == 0)
              {
                v35 = (unsigned int *)(v34 - 2);
                v39 = (char *)v34 + 57;
                if (v142)
                {
                  v143 = (char *)malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  v144 = 0;
                  v145 = (int8x16_t)xmmword_18474E1C0;
                  do
                  {
                    *(int8x16_t *)&v143[v144] = vbslq_s8((int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v145, (int8x16_t)vdupq_n_s64(4uLL))), v185, v186);
                    v145 = (int8x16_t)vaddq_s64((int64x2_t)v145, vdupq_n_s64(2uLL));
                    v144 += 16;
                  }
                  while (v144 != 128);
                  CA::OGL::SW::gaussian_samplers(void)::s = (uint64_t)v143;
                  v39 = (char *)v34 + 57;
                  v35 = (unsigned int *)(v34 - 2);
                }
              }
              this = CA::OGL::SW::gaussian_samplers(void)::s;
              *((_QWORD *)&v218[3] + 11 * v26 + 1) = CA::OGL::SW::gaussian_samplers(void)::s;
              *(_QWORD *)v35 = &CA::OGL::gaussian_table;
              break;
            default:
              this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
              v39 = (char *)v34 + 57;
              goto LABEL_113;
          }
        }
        else
        {
          v49 = (char *)v218 + 88 * v26;
          *((_QWORD *)v49 + 4) = 0x100000001;
          this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
          v39 = (char *)v34 + 57;
          *((_QWORD *)v49 + 7) = this;
        }
LABEL_114:
        v95 = (int32x2_t *)v218 + 11 * v26;
        v96 = v95[4];
        v95[5] = vadd_s32(vshl_n_s32(v96, 0x10uLL), (int32x2_t)-1);
        v95[6] = (int32x2_t)vdiv_f32(_D8, vcvt_f32_u32((uint32x2_t)v96));
        if (*v40 != *v39)
          LODWORD(v220) = v220 | 1;
        if (v33 > 0x26)
          goto LABEL_128;
        if (((1 << v33) & 0xF000000) != 0)
        {
          if (*v34 == 25)
          {
            if ((v98 & 1) == 0)
            {
              if ((_DWORD)this)
              {
                v111 = (char *)malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                v112 = 0;
                v113 = (int8x16_t)xmmword_18474E1C0;
                do
                {
                  *(int8x16_t *)&v111[v112] = vbslq_s8((int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v113, (int8x16_t)vdupq_n_s64(4uLL))), v198, v199);
                  v113 = (int8x16_t)vaddq_s64((int64x2_t)v113, v197);
                  v112 += 16;
                }
                while (v112 != 128);
                CA::OGL::SW::prepare_texture(CA::OGL::SWContext &,CA::OGL::SW::Texture *,unsigned int,unsigned long,CA::OGL::ImageFunction,unsigned int *)::Lh_samplers = (uint64_t)v111;
              }
            }
            switch(v33)
            {
              case 0x18u:
                if ((v99 & 1) == 0
                {
                  v114 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  memset_pattern16(v114, off_1E159E130, 0x80uLL);
                  CA::OGL::SW::render_samplers<CA::Vec4<float>>(CA::OGL::ImageFunction)::s = (uint64_t)v114;
                }
                this = CA::OGL::SW::render_samplers<CA::Vec4<float>>(CA::OGL::ImageFunction)::s;
                break;
              case 0x19u:
                if ((v102 & 1) == 0
                {
                  v116 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  memset_pattern16(v116, off_1E159E120, 0x80uLL);
                  CA::OGL::SW::render_samplers<CA::Vec4<float>>(CA::OGL::ImageFunction)::s = (uint64_t)v116;
                }
                this = CA::OGL::SW::render_samplers<CA::Vec4<float>>(CA::OGL::ImageFunction)::s;
                break;
              case 0x1Au:
                if ((v103 & 1) == 0
                {
                  v117 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  memset_pattern16(v117, off_1E159E110, 0x80uLL);
                  CA::OGL::SW::render_samplers<CA::Vec4<float>>(CA::OGL::ImageFunction)::s = (uint64_t)v117;
                }
                this = CA::OGL::SW::render_samplers<CA::Vec4<float>>(CA::OGL::ImageFunction)::s;
                break;
              case 0x1Bu:
                if ((v104 & 1) == 0
                {
                  v118 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  memset_pattern16(v118, off_1E159E100, 0x80uLL);
                  CA::OGL::SW::render_samplers<CA::Vec4<float>>(CA::OGL::ImageFunction)::s = (uint64_t)v118;
                }
                this = CA::OGL::SW::render_samplers<CA::Vec4<float>>(CA::OGL::ImageFunction)::s;
                break;
              default:
                this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
                break;
            }
            v105 = CA::OGL::SW::prepare_texture(CA::OGL::SWContext &,CA::OGL::SW::Texture *,unsigned int,unsigned long,CA::OGL::ImageFunction,unsigned int *)::Lh_samplers;
            v106 = (char *)v218 + 88 * v26;
            *((_QWORD *)v106 + 7) = this;
            *((_QWORD *)v106 + 8) = v105;
          }
          else
          {
            v100 = (char *)v218 + 88 * v26;
            *((_QWORD *)v100 + 8) = this;
            switch(v33)
            {
              case 0x18u:
                if ((v101 & 1) == 0
                {
                  v115 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  memset_pattern16(v115, off_1E159E170, 0x80uLL);
                  CA::OGL::SW::render_samplers<unsigned int>(CA::OGL::ImageFunction)::s = (uint64_t)v115;
                }
                this = CA::OGL::SW::render_samplers<unsigned int>(CA::OGL::ImageFunction)::s;
                break;
              case 0x19u:
                if ((v107 & 1) == 0
                {
                  v119 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  memset_pattern16(v119, off_1E159E160, 0x80uLL);
                  CA::OGL::SW::render_samplers<unsigned int>(CA::OGL::ImageFunction)::s = (uint64_t)v119;
                }
                this = CA::OGL::SW::render_samplers<unsigned int>(CA::OGL::ImageFunction)::s;
                break;
              case 0x1Au:
                if ((v108 & 1) == 0
                {
                  v120 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  memset_pattern16(v120, off_1E159E150, 0x80uLL);
                  CA::OGL::SW::render_samplers<unsigned int>(CA::OGL::ImageFunction)::s = (uint64_t)v120;
                }
                this = CA::OGL::SW::render_samplers<unsigned int>(CA::OGL::ImageFunction)::s;
                break;
              case 0x1Bu:
                if ((v109 & 1) == 0
                {
                  v121 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
                  memset_pattern16(v121, off_1E159E140, 0x80uLL);
                  CA::OGL::SW::render_samplers<unsigned int>(CA::OGL::ImageFunction)::s = (uint64_t)v121;
                }
                this = CA::OGL::SW::render_samplers<unsigned int>(CA::OGL::ImageFunction)::s;
                break;
              default:
                this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
                break;
            }
            *((_QWORD *)v100 + 7) = this;
          }
          goto LABEL_146;
        }
        if (((1 << v33) & 0x4000200003) != 0)
        {
          v97 = (char *)v218 + 88 * v26;
        }
        else
        {
LABEL_128:
          this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
          v97 = (char *)v218 + 88 * v26;
          *((_QWORD *)v97 + 7) = this;
        }
        *((_QWORD *)v97 + 8) = 0;
LABEL_146:
        ++v26;
        v110 = v25 > 1;
        v25 >>= 1;
        if (!v110)
          goto LABEL_193;
      }
      *v40 = 8 * ((*(_DWORD *)(v37 + 52) & 0xF0000) != 0);
      *v39 = 8 * ((*(_DWORD *)(v37 + 52) & 0xF00000) != 0);
      v42 = *(_QWORD *)(v37 + 8);
      if (!v42 || !*(_BYTE *)(v37 + 112))
      {
        v45 = *(__IOSurface **)(v37 + 72);
        if (v45)
        {
          v201 = (void **)(v34 - 2);
          ProtectionOptions = IOSurfaceGetProtectionOptions();
          v14 = v208;
          if (ProtectionOptions)
            goto LABEL_36;
          v58 = *(_DWORD *)(v37 + 80);
          *v34 = v58;
          if (v58 == -1)
          {
            if (*(_QWORD *)(v37 + 88))
              goto LABEL_68;
            v179 = *(CA::Render::Surface **)(v37 + 8);
            buffer = *(__IOSurface **)(v37 + 72);
            PixelFormat = IOSurfaceGetPixelFormat(buffer);
            if ((PixelFormat | 0x10) == 0x34323076)
            {
              bytesPerRowa = PixelFormat;
              heighta = IOSurfaceGetWidth(buffer);
              v60 = IOSurfaceGetHeight(buffer);
              v61 = CA::Render::format_rowbytes((CA::Render *)1, heighta);
              widtha = v61;
              if (is_mul_ok(v61, v60))
                v62 = (CA::Render *)(v61 * v60);
              else
                v62 = 0;
              v210 = 0;
              v63 = (CGImage *)CA::Render::aligned_malloc(v62, &v210, 0);
              if (v63)
              {
                imagea = v63;
                if (!IOSurfaceLock(buffer, 1u, 0))
                {
                  if ((bytesPerRowa | 0x10) == 0x34323076)
                  {
                    bytesPerRowb = IOSurfaceGetBaseAddressOfPlane(buffer, 0);
                    BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(buffer, 0);
                    ca = (CGContextRef)IOSurfaceGetBaseAddressOfPlane(buffer, 1uLL);
                    v164 = IOSurfaceGetBytesPerRowOfPlane(buffer, 1uLL);
                    v166 = CA::Render::Surface::ycbcr_matrix(v179, v64);
                    CA::Render::Surface::chroma_location((__IOSurface **)v179, v65);
                    if (bytesPerRowb)
                    {
                      if (ca && v166 <= 6)
                      {
                        memset(&outInfo, 0, sizeof(outInfo));
                        vImageConvert_YpCbCrToARGB_GenerateConversion((const vImage_YpCbCrToARGBMatrix *)&CA::convert_ycbcr420_to_argb8888_host(void const*,long,void const*,long,void *,long,long,long,int,int)::ycbcr_matrices+ v166, (const vImage_YpCbCrPixelRange *)&CA::convert_ycbcr420_to_argb8888_host(void const*,long,void const*,long,void *,long,long,long,int,int)::ycbcr_ranges+ v166, &outInfo, kvImage420Yp8_CbCr8, kvImageARGB8888, 0);
                        srcYp.data = bytesPerRowb;
                        srcYp.height = v60;
                        srcYp.width = heighta;
                        srcYp.rowBytes = BytesPerRowOfPlane;
                        srcCbCr.data = ca;
                        srcCbCr.height = v60;
                        srcCbCr.width = heighta;
                        srcCbCr.rowBytes = v164;
                        dest.data = imagea;
                        dest.height = v60;
                        dest.width = heighta;
                        dest.rowBytes = widtha;
                        *(_DWORD *)permuteMap = 66051;
                        vImageConvert_420Yp8_CbCr8ToARGB8888(&srcYp, &srcCbCr, &dest, &outInfo, permuteMap, 0xFFu, 0x10u);
                      }
                    }
                  }
                  IOSurfaceUnlock(buffer, 1u, 0);
                }
                v66 = v210;
                *(_QWORD *)(v37 + 88) = imagea;
                *(_QWORD *)(v37 + 96) = v66;
                *(_QWORD *)(v37 + 104) = widtha;
              }
              v14 = v208;
            }
            if (*(_QWORD *)(v37 + 88))
            {
LABEL_68:
              CA::OGL::Context::add_buffered_image(v207, v37);
              *v34 = 1;
            }
          }
          if (v36 == 2)
          {
            v67 = CA::Render::format_opaque_format((CA::Render *)*v34);
            if ((v67 & 0x80000000) == 0)
              *v34 = v67;
          }
          v68 = *(void **)(v37 + 88);
          if (v68)
          {
            *v201 = v68;
            *((_QWORD *)&v218[1] + 11 * v26 + 1) = *(_QWORD *)(v37 + 104);
            *v38 = 0;
            *((_QWORD *)v34 + 9) = 0;
          }
          else
          {
            ProtectionOptions = IOSurfaceLock(v45, 1u, 0);
            if ((_DWORD)ProtectionOptions)
            {
LABEL_36:
              this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)ProtectionOptions);
              *((_QWORD *)&v218[3] + 11 * v26 + 1) = this;
              v39 = (char *)v34 + 57;
              goto LABEL_114;
            }
            *v201 = IOSurfaceGetBaseAddress(v45);
            v78 = IOSurfaceGetBytesPerRow(v45);
            v79 = (char *)v218 + 88 * v26;
            *((_QWORD *)v79 + 3) = v78;
            *v38 = CA::OGL::SW::unlock_iosurface;
            *((_QWORD *)v79 + 11) = v45;
          }
          v69 = (char *)v218 + 88 * v26;
          *((_DWORD *)v69 + 8) = IOSurfaceGetWidth(v45);
          v70 = (CA::OGL::SW *)IOSurfaceGetHeight(v45);
          *((_DWORD *)v69 + 9) = (_DWORD)v70;
          v71 = *v34;
          if (v71 > 0x1C)
            this = CA::OGL::SW::incomplete_samplers(v70);
          else
            this = (uint64_t)&CA::OGL::SW::sampler_functions::samplers[16 * v71];
          v39 = (char *)v34 + 57;
        }
        else
        {
          if (*(_BYTE *)(v42 + 12) != 9)
          {
            this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
            v39 = (char *)v34 + 57;
LABEL_110:
            *((_QWORD *)&v218[3] + 11 * v26 + 1) = this;
            v14 = v208;
            goto LABEL_114;
          }
          if ((*(_BYTE *)(v42 + 176) & 1) != 0)
          {
            if (*(_QWORD *)(v37 + 88))
              goto LABEL_102;
            v50 = *(unsigned int *)(v42 + 20);
            width = *(unsigned int *)(v42 + 16);
            v51 = CA::Render::format_rowbytes((CA::Render *)1, *(_DWORD *)(v42 + 16));
            v52 = (CA::Render *)(v51 * v50);
            height = v50;
            if (!is_mul_ok(v51, v50))
              v52 = 0;
            c = v52;
            bytesPerRow = v51;
            v53 = *(_QWORD *)(v42 + 96);
            v54 = **(_QWORD **)(v42 + 128);
            image = **(CGImageRef **)(v42 + 136);
            v55 = (char *)malloc_type_malloc((size_t)image + 68, 0x580F6D12uLL);
            *((_DWORD *)v55 + 2) = 169478669;
            *(_QWORD *)v55 = 0xBB31312058544BABLL;
            v178 = (CA::Render::Surface *)v55;
            *(_OWORD *)(v55 + 12) = xmmword_18474E400;
            v56 = *(_DWORD *)(v42 + 156) - 1;
            if (v56 > 0x1B)
              v57 = 0;
            else
              v57 = dword_18475D688[v56];
            v80 = (const void *)(v53 + v54);
            v81 = (CA::Render::Surface *)v55;
            *((_DWORD *)v55 + 7) = v57;
            *((_DWORD *)v55 + 8) = 6408;
            *((_DWORD *)v55 + 9) = width;
            *((_DWORD *)v55 + 10) = height;
            *(_OWORD *)(v55 + 44) = xmmword_18474E410;
            *((_DWORD *)v55 + 15) = 0;
            *((_DWORD *)v55 + 16) = (_DWORD)image;
            memcpy(v55 + 68, v80, (size_t)image);
            *(_QWORD *)outInfo.opaque = 0;
            v82 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)v178, (CFIndex)image + 68, bytesDeallocator);
            buffera = CGImageSourceCreateWithData(v82, 0);
            CFRelease(v82);
            if (buffera)
            {
              imageb = CGImageSourceCreateImageAtIndex(buffera, 0, 0);
              CFRelease(buffera);
              if (imageb)
              {
                v83 = CA::Render::aligned_malloc(c, (unint64_t *)outInfo.opaque, 0);
                if (v83)
                {
                  v84 = v83;
                  bufferb = (IOSurfaceRef)v83;
                  ColorSpace = CGImageGetColorSpace(imageb);
                  cb = CGBitmapContextCreate(v84, width, height, 8uLL, bytesPerRow, ColorSpace, 0x2002u);
                  v224.size.width = (double)width;
                  v224.size.height = (double)height;
                  v224.origin.x = 0.0;
                  v224.origin.y = 0.0;
                  CGContextDrawImage(cb, v224, imageb);
                  CGImageRelease(imageb);
                  CGContextRelease(cb);
                  v86 = *(_QWORD *)outInfo.opaque;
                  *(_QWORD *)(v37 + 88) = bufferb;
                  *(_QWORD *)(v37 + 96) = v86;
                  *(_QWORD *)(v37 + 104) = bytesPerRow;
                  v81 = v178;
                }
                else
                {
                  CGImageRelease(imageb);
                }
              }
            }
            free(v81);
            v39 = (char *)v34 + 57;
            v35 = (unsigned int *)(v34 - 2);
            if (*(_QWORD *)(v37 + 88))
            {
LABEL_102:
              v87 = v35;
              this = (uint64_t)CA::OGL::Context::add_buffered_image(v207, v37);
              v35 = v87;
              v39 = (char *)v34 + 57;
              *v34 = 1;
            }
          }
          if (v36 == 2)
          {
            v88 = v39;
            v89 = v35;
            this = CA::Render::format_opaque_format((CA::Render *)*v34);
            v35 = v89;
            v39 = v88;
            if ((this & 0x80000000) == 0)
              *v34 = this;
          }
          v90 = *(_QWORD *)(v37 + 88);
          if (!v90)
          {
            v93 = v39;
            this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
            v39 = v93;
            goto LABEL_110;
          }
          v91 = (char *)v218 + 88 * v26;
          *((_QWORD *)v91 + 4) = *(_QWORD *)(v42 + 16);
          *(_QWORD *)v35 = v90;
          *((_QWORD *)v91 + 3) = *(_QWORD *)(v37 + 104);
          v92 = *v34;
          if (v92 > 0x1C)
          {
            v94 = v39;
            this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
            v39 = v94;
          }
          else
          {
            this = (uint64_t)&CA::OGL::SW::sampler_functions::samplers[16 * v92];
          }
          v14 = v208;
        }
        goto LABEL_113;
      }
      *(_QWORD *)v35 = *(_QWORD *)(v42 + 96);
      v43 = (CA::Render *)*(unsigned __int8 *)(v42 + 152);
      *v34 = (int)v43;
      v44 = (char *)v218 + 88 * v26;
      *((_QWORD *)v44 + 3) = *(_QWORD *)(v42 + 160);
      *((_QWORD *)v44 + 4) = *(_QWORD *)(v42 + 16);
      if (v36 != 2 || (this = CA::Render::format_opaque_format(v43), v39 = (char *)v34 + 57, (this & 0x80000000) != 0))
      {
        v14 = v208;
        if (v43 > 0x1C)
        {
          v72 = v39;
          this = CA::OGL::SW::incomplete_samplers((CA::OGL::SW *)this);
          v39 = v72;
          goto LABEL_113;
        }
      }
      else
      {
        *v34 = this;
        LODWORD(v43) = this;
        v14 = v208;
      }
      this = (uint64_t)&CA::OGL::SW::sampler_functions::samplers[16 * (int)v43];
LABEL_113:
      *((_QWORD *)&v218[3] + 11 * v26 + 1) = this;
      goto LABEL_114;
    }
  }
  else
  {
    *(_QWORD *)&v218[0] = v13;
    *(_QWORD *)&v220 = 0;
  }
LABEL_193:
  BYTE8(v221) = v14[481] & 1;
  if (BYTE8(v221))
  {
    v154 = v14[480];
    v147 = v205;
    v146 = v206;
    v148 = v204;
    v149 = v203;
    v150 = v202;
    if (v154 > 0x37)
      v155 = 0;
    else
      v155 = (uint64_t)*(&off_1E159E180 + v154);
    v152 = v207;
    *((_QWORD *)&v220 + 1) = v155;
    HIDWORD(v156) = bswap32(CA::OGL::ExtendedColor::word32((CA::OGL::ExtendedColor *)(v14 + 288)));
    LODWORD(v156) = HIDWORD(v156);
    LODWORD(v221) = v156 >> 8;
    HIDWORD(v156) = bswap32(CA::OGL::ExtendedColor::word32((CA::OGL::ExtendedColor *)(v14 + 296)));
    LODWORD(v156) = HIDWORD(v156);
    DWORD1(v221) = v156 >> 8;
    if (!v155)
      BYTE8(v221) = 0;
  }
  else
  {
    v147 = v205;
    v146 = v206;
    v148 = v204;
    v149 = v203;
    v150 = v202;
    if ((v14[16] & 0xFE) == 0x10)
    {
      v151 = v14[480];
      v152 = v207;
      if (v151 > 0x37)
        v153 = 0;
      else
        v153 = (uint64_t)*(&off_1E159E180 + v151);
      *((_QWORD *)&v220 + 1) = v153;
      HIDWORD(v157) = bswap32(CA::OGL::ExtendedColor::word32((CA::OGL::ExtendedColor *)(v14 + 288)));
      LODWORD(v157) = HIDWORD(v157);
      LODWORD(v221) = v157 >> 8;
      if (!v153)
        *((_QWORD *)&v220 + 1) = CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Copy,false>::blend;
    }
    else
    {
      *((_QWORD *)&v220 + 1) = 0;
      v152 = v207;
    }
  }
  v158 = (float64x2_t *)*((_QWORD *)v152 + 100);
  v215[0] = &off_1E159A408;
  v215[1] = v218;
  v216 = v215;
  CA::OGL::clip_primitives(v150, v149, v148, v147, v217, v146, v158, 0, 0, (uint64_t)v215, 0);
  v159 = v216;
  if (v216 == v215)
  {
    v160 = 4;
    v159 = v215;
  }
  else
  {
    if (!v216)
      goto LABEL_211;
    v160 = 5;
  }
  (*(void (**)(void))(*v159 + 8 * v160))();
LABEL_211:
  v161 = DWORD1(v220);
  if (DWORD1(v220))
  {
    v162 = (_QWORD *)&v218[5] + 1;
    do
    {
      if ((v161 & 1) != 0)
      {
        v163 = (void (*)(_QWORD))*(v162 - 1);
        if (v163)
          v163(*v162);
      }
      v162 += 11;
      v110 = v161 > 1;
      v161 >>= 1;
    }
    while (v110);
  }
  CA::OGL::Context::marked_destination(v152);
  ++*((_DWORD *)v152 + 172);
}

void CA::OGL::SWContext::draw_elements(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  CA::OGL::SWContext::draw_elements(a1, a2, a3, a4, a5, a6, a7, 0);
}

double CA::OGL::SWContext::bind_square(CA::OGL::SWContext *this, unsigned int a2, BOOL a3, BOOL a4, float *a5)
{
  uint64_t v7;
  unsigned int v8;
  double result;

  v7 = *((_QWORD *)this + 2);
  v8 = CA::OGL::state_image_texture_unit(v7, a2);
  *(_WORD *)(v7 + 2 * v8 + 144) = 4;
  *(_QWORD *)(v7 + 8 * v8 + 176) = 1;
  *(_QWORD *)a5 = 0x3F800000BF800000;
  result = 0.00781250185;
  *(_OWORD *)(v7 + 16 * a2 + 96) = xmmword_18474E210;
  return result;
}

double CA::OGL::SWContext::bind_circle(CA::OGL::SWContext *this, unsigned int a2, int a3, BOOL a4, BOOL a5, float *a6)
{
  uint64_t v8;
  unsigned int v9;
  double result;

  v8 = *((_QWORD *)this + 2);
  v9 = CA::OGL::state_image_texture_unit(v8, a2);
  *(_WORD *)(v8 + 2 * v9 + 144) = 4;
  *(_QWORD *)(v8 + 8 * v9 + 176) = 2;
  *(_QWORD *)a6 = 0x3F800000BF800000;
  result = 0.00781250185;
  *(_OWORD *)(v8 + 16 * a2 + 96) = xmmword_18474E210;
  return result;
}

double CA::OGL::SWContext::bind_supercircle(CA::OGL::SWContext *this, unsigned int a2, int a3, BOOL a4, BOOL a5, float *a6, unsigned int a7, float *a8)
{
  uint64_t v10;
  unsigned int v11;
  double result;

  v10 = *((_QWORD *)this + 2);
  v11 = CA::OGL::state_image_texture_unit(v10, a2);
  *(_WORD *)(v10 + 2 * v11 + 144) = 4;
  *(_QWORD *)(v10 + 8 * v11 + 176) = 3;
  *(_QWORD *)a6 = 0x3F800000BF800000;
  result = 0.00781250185;
  *(_OWORD *)(v10 + 16 * a2 + 96) = xmmword_18474E210;
  return result;
}

__n128 CA::OGL::SWContext::bind_uneven_circle(uint64_t a1, unsigned int a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  __n128 result;

  v7 = *(_QWORD *)(a1 + 16);
  v8 = CA::OGL::state_image_texture_unit(v7, a2);
  *(_WORD *)(v7 + 2 * v8 + 144) = 4;
  *(_QWORD *)(v7 + 8 * v8 + 176) = 4;
  *a4 = 0x3F80000000000000;
  *(_OWORD *)(v7 + 16 * a2 + 96) = xmmword_18474E210;
  v9 = v7 + 48 * a2;
  *(_OWORD *)(v9 + 384) = *(_OWORD *)a3;
  result = *(__n128 *)(a3 + 16);
  *(__n128 *)(v9 + 400) = result;
  return result;
}

__n128 CA::OGL::SWContext::bind_uneven_supercircle(uint64_t a1, unsigned int a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  __n128 result;

  v7 = *(_QWORD *)(a1 + 16);
  v8 = CA::OGL::state_image_texture_unit(v7, a2);
  *(_WORD *)(v7 + 2 * v8 + 144) = 4;
  *(_QWORD *)(v7 + 8 * v8 + 176) = 5;
  *a4 = 0x3F80000000000000;
  *(_OWORD *)(v7 + 16 * a2 + 96) = xmmword_18474E210;
  v9 = v7 + 48 * a2;
  *(_OWORD *)(v9 + 384) = *(_OWORD *)a3;
  result = *(__n128 *)(a3 + 16);
  *(__n128 *)(v9 + 400) = result;
  return result;
}

double CA::OGL::SWContext::bind_gaussian(CA::OGL::SWContext *this, unsigned int a2, float *a3)
{
  uint64_t v5;
  unsigned int v6;
  double result;

  v5 = *((_QWORD *)this + 2);
  v6 = CA::OGL::state_image_texture_unit(v5, a2);
  *(_WORD *)(v5 + 2 * v6 + 144) = 4;
  *(_QWORD *)(v5 + 8 * v6 + 176) = 6;
  *(_QWORD *)a3 = 0x3F80000000000000;
  result = 0.00781250185;
  *(_OWORD *)(v5 + 16 * a2 + 96) = xmmword_18474E210;
  return result;
}

uint64_t CA::OGL::SWContext::bind_image_impl(CA::OGL::Context *this, unsigned int a2, CFTypeRef *a3, __int16 a4, int a5, int a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  CFTypeRef *v16;
  uint64_t v17;
  int v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  NSObject *v22;
  uint8_t buf[4];
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (a3[11] == this && (v15 = (uint64_t)a3[10]) != 0
    || (v15 = CA::OGL::Context::lookup_image_(this, (CA::Render::Texture *)a3, 1)) != 0)
  {
    v16 = CA::OGL::SWContext::retain_image(v15, a3);
    if (v16)
    {
      v17 = *(_QWORD *)(v15 + 64);
      if (v17)
      {
LABEL_10:
        if (*((_DWORD *)v16 + 3) & 0x1000 | a4 & 0x200)
          v20 = 2;
        else
          v20 = 1;
        *(_WORD *)(v15 + 52) = v20;
        *(_WORD *)(v15 + 58) |= 0x100u;
        v21 = *((_QWORD *)this + 2);
        *(_WORD *)(v21 + 2 * a2 + 144) = v20;
        *(_QWORD *)(v21 + 8 * a2 + 176) = v17;
        *(_BYTE *)(v15 + 54) = (((a5 != 0) << 16) | ((a6 != 0) << 20)) >> 16;
        *(_OWORD *)a8 = xmmword_18474E220;
        if (((a4 & 0x800) == 0) != (*((_BYTE *)v16 + 13) & 8) >> 3)
        {
          *(_DWORD *)(a8 + 4) = 1065353216;
          *(_DWORD *)(a8 + 12) = 0;
        }
        return v15;
      }
      v19 = *((_DWORD *)v16 + 4);
      v18 = *((_DWORD *)v16 + 5);
      if (v19 <= 0x4000 && v18 <= 0x4000)
      {
        *(_QWORD *)(v15 + 64) = v15;
        v17 = v15;
        goto LABEL_10;
      }
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v22 = x_log_category_ogl;
        if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109376;
          v25 = v19;
          v26 = 1024;
          v27 = v18;
          _os_log_impl(&dword_184457000, v22, OS_LOG_TYPE_DEFAULT, "CoreAnimation: %d by %d image is too large for software renderer, ignoring\n", buf, 0xEu);
        }
      }
    }
    return 0;
  }
  return v15;
}

void *CA::OGL::SWContext::image_surface(uint64_t a1, uint64_t a2, CFTypeRef *this)
{
  void *result;
  uint64_t v6;
  int v7;
  __IOSurface *v8;
  CA::WindowServer::IOSurface *v9;

  result = CA::OGL::SWContext::retain_image(a2, this);
  if (result)
  {
    v6 = (uint64_t)result;
    result = *(void **)(a2 + 32);
    if (!result)
    {
      v7 = *(unsigned __int8 *)(v6 + 12);
      if (v7 == 23)
      {
        v8 = CA::Render::Image::retain_iosurface((CA::Render::Image *)v6);
        if (!v8)
          return *(void **)(a2 + 32);
      }
      else
      {
        if (v7 != 51)
          return 0;
        v8 = *(__IOSurface **)(v6 + 112);
        if (!v8)
          return 0;
        CFRetain(*(CFTypeRef *)(v6 + 112));
      }
      v9 = *(CA::WindowServer::IOSurface **)(a1 + 176);
      if (v9)
        v9 = (CA::WindowServer::IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(_QWORD *)v9 + 16))(v9);
      result = CA::WindowServer::IOSurface::wrap_buffer(v9, v8, 0, 1);
      *(_QWORD *)(a2 + 32) = result;
    }
  }
  return result;
}

double CA::OGL::SWContext::new_image(CA::OGL::SWContext *this)
{
  malloc_zone_t *malloc_zone;
  _QWORD *v2;
  double result;

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v2 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x78uLL, 0x743898A5uLL);
  if (v2)
  {
    v2[14] = 0;
    result = 0.0;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *(_OWORD *)v2 = 0u;
  }
  return result;
}

void CA::OGL::SWContext::delete_image(uint64_t a1, uint64_t a2, void *a3)
{
  const void *v4;
  CA::Render *v5;
  CA::WindowServer::Surface *v6;
  CA::WindowServer::Surface *v7;

  v4 = *(const void **)(a2 + 72);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a2 + 72) = 0;
  }
  v5 = *(CA::Render **)(a2 + 88);
  if (v5)
  {
    CA::Render::aligned_free(v5, *(_QWORD *)(a2 + 96), a3);
    *(_QWORD *)(a2 + 88) = 0;
  }
  v6 = *(CA::WindowServer::Surface **)(a2 + 32);
  if (v6)
  {
    CA::WindowServer::Surface::unref(v6);
    *(_QWORD *)(a2 + 32) = 0;
  }
  v7 = *(CA::WindowServer::Surface **)(a2 + 40);
  if (v7)
  {
    CA::WindowServer::Surface::unref(v7);
    *(_QWORD *)(a2 + 40) = 0;
  }
  *(_BYTE *)(a2 + 112) = 0;
}

char *CA::OGL::SWContext::create_surface(CA::OGL::SWContext *this, int a2, const CA::Bounds *a3, char a4)
{
  int v4;
  unint64_t v6;
  char *result;
  char v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  char *v15;
  char *v16;
  CA::Render *v17;
  malloc_zone_t *malloc_zone;
  void *v19;
  int v20;
  int v21;
  void *v22;
  void *v23[2];

  v23[1] = *(void **)MEMORY[0x1E0C80C00];
  v4 = *((_DWORD *)a3 + 2);
  if (v4 < 1)
    return 0;
  v6 = *((unsigned int *)a3 + 3);
  if ((int)v6 < 1)
    return 0;
  result = 0;
  if (a2 == 1 && v4 <= 0x4000 && v6 <= 0x4000)
  {
    v23[0] = 0;
    v9 = a4 | 7;
    if ((a4 & 7) == 0)
      v9 = a4;
    v10 = v9 & 0xF;
    LODWORD(v11) = 4 * v4;
    if (v10 == 8)
      v11 = v4;
    else
      v11 = v11;
    v12 = (v11 + 15) & 0x1FFFFFFF0;
    v13 = v12 * v6;
    if (!is_mul_ok(v12, v6))
      v13 = 0;
    v15 = (char *)*((_QWORD *)this + 10);
    v14 = (_QWORD *)((char *)this + 80);
    result = v15;
    if (v15)
    {
      if (v13 <= *((_QWORD *)result + 13))
      {
LABEL_18:
        *v14 = *((_QWORD *)result + 1);
        *(_DWORD *)result = 1;
        *((_DWORD *)result + 6) = v4;
        *((_DWORD *)result + 7) = v6;
        *((_QWORD *)result + 4) = *(_QWORD *)a3;
        *((_DWORD *)result + 10) = v4;
        *((_DWORD *)result + 11) = v6;
        *(_WORD *)(result + 75) &= ~0x200u;
        *((_QWORD *)result + 10) = v12;
        *((_DWORD *)result + 17) = v10;
        result[72] |= 1u;
        return result;
      }
      while (1)
      {
        v16 = result;
        result = (char *)*((_QWORD *)result + 1);
        if (!result)
          break;
        if (v13 <= *((_QWORD *)result + 13))
        {
          v14 = v16 + 8;
          goto LABEL_18;
        }
      }
    }
    result = (char *)CA::Render::aligned_malloc((CA::Render *)v13, (unint64_t *)v23, 0);
    if (result)
    {
      v17 = (CA::Render *)result;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      result = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x80uLL, 0x743898A5uLL);
      if (result)
      {
        *(_DWORD *)result = 1;
        v20 = *((_DWORD *)a3 + 2);
        *((_DWORD *)result + 6) = v20;
        v21 = *((_DWORD *)a3 + 3);
        *((_DWORD *)result + 7) = v21;
        *((_QWORD *)result + 4) = *(_QWORD *)a3;
        *((_DWORD *)result + 10) = v20;
        *((_DWORD *)result + 11) = v21;
        *((_DWORD *)result + 17) = v10;
        result[72] |= 1u;
        v22 = v23[0];
        *((void **)result + 12) = v23[0];
        *((_QWORD *)result + 13) = v22;
        *((_QWORD *)result + 10) = v12;
        *((_QWORD *)result + 11) = v17;
        *(_WORD *)(result + 75) |= 0xD0u;
        result[74] = result[74] & 0xE0 | 4;
        return result;
      }
      CA::Render::aligned_free(v17, (size_t)v23[0], v19);
      return 0;
    }
  }
  return result;
}

char *CA::OGL::SWContext::create_surface_from_data(CA::OGL::SWContext *this, void *a2, uint64_t a3, int a4, int a5, int a6, int a7, int a8)
{
  char *result;
  uint64_t v10;
  malloc_zone_t *malloc_zone;
  int v18;
  char v19;

  result = 0;
  if (a6 >= 1)
  {
    v10 = (a7 - 1);
    if (a7 >= 1)
    {
      result = 0;
      if (a6 <= 0x4000 && a7 <= 0x4000)
      {
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        result = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x80uLL, 0x743898A5uLL);
        if (result)
        {
          *(_DWORD *)result = 1;
          *((_DWORD *)result + 6) = a6;
          *((_DWORD *)result + 7) = a7;
          *((_DWORD *)result + 8) = a4;
          *((_DWORD *)result + 9) = a5;
          *((_DWORD *)result + 10) = a6;
          *((_DWORD *)result + 11) = a7;
          if (a8)
            v18 = 8;
          else
            v18 = 15;
          *((_DWORD *)result + 17) = v18;
          result[72] |= 1u;
          if (a8)
            v19 = 0;
          else
            v19 = 2;
          *((_QWORD *)result + 12) = 0;
          *((_QWORD *)result + 13) = (a6 << v19) + v10 * a3;
          *((_QWORD *)result + 10) = a3;
          *((_QWORD *)result + 11) = a2;
          *(_WORD *)(result + 75) |= 0x190u;
        }
      }
    }
  }
  return result;
}

char *CA::OGL::SWContext::create_surface_from_iosurface(CA::OGL::SWContext *this, int a2, int a3, int a4, IOSurfaceRef buffer)
{
  char *v8;
  void *BaseAddress;
  size_t BytesPerRow;
  int Width;
  CA::OGL::SWContext *Height;
  char *surface_from_data;

  if (a2 != 1)
    return 0;
  v8 = 0;
  if (!IOSurfaceLock(buffer, 0, 0))
  {
    BaseAddress = IOSurfaceGetBaseAddress(buffer);
    BytesPerRow = IOSurfaceGetBytesPerRow(buffer);
    Width = IOSurfaceGetWidth(buffer);
    Height = (CA::OGL::SWContext *)IOSurfaceGetHeight(buffer);
    surface_from_data = CA::OGL::SWContext::create_surface_from_data(Height, BaseAddress, BytesPerRow, a3, a4, Width, (int)Height, 0);
    v8 = surface_from_data;
    if (surface_from_data)
    {
      *((_QWORD *)surface_from_data + 14) = buffer;
      CFRetain(buffer);
    }
  }
  return v8;
}

void CA::OGL::SWContext::reuse_surface(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  int v4;

  *(_OWORD *)(a2 + 32) = *(_OWORD *)a3;
  *(_WORD *)(a2 + 75) &= 0xFFF0u;
  v3 = *(_QWORD *)(a3 + 8);
  *(_QWORD *)(a2 + 24) = v3;
  if ((*(_DWORD *)(a2 + 68) & 0xF) == 8)
    v4 = v3;
  else
    v4 = 4 * v3;
  *(_QWORD *)(a2 + 80) = (v4 + 15) & 0xFFFFFFFFFFFFFFF0;
}

void CA::OGL::SWContext::copy_destination(CA::OGL::Context *this, uint64_t a2, int32x2_t *a3, uint64_t a4, int32x2_t *a5, int32x2_t *a6, _BYTE *a7)
{
  uint64_t v13;
  uint64_t v14;
  int32x2_t *v15;
  int32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;
  int32x2_t v19;
  int32x2_t v20;
  int32x2_t v21;
  int32x2_t v22;
  int32x2_t v23;
  int32x2_t v24;
  int32x2_t v25;
  int32x2_t v26;
  int32x2_t v27;

  v13 = *((_QWORD *)this + 32);
  if (v13 != *((_QWORD *)this + 31))
    goto LABEL_2;
  if (v13)
    LODWORD(v13) = (*(unsigned __int8 *)(v13 + 72) >> 1) & 0x1F;
  if (*((_DWORD *)this + 61) != (_DWORD)v13)
LABEL_2:
    CA::OGL::Context::prepare_destination_(this);
  if ((*((_WORD *)this + 408) & 0x200) != 0)
  {
    v14 = *((_QWORD *)this + 22);
    if (v14)
    {
      *((_WORD *)this + 408) &= ~0x200u;
    }
  }
  if (a4)
  {
    v15 = a5 + 1;
    do
    {
      v16.i32[0] = *((_DWORD *)this + 472);
      v16.i32[1] = *((_DWORD *)this + 474);
      v17 = vsub_s32(v15[-1], v16);
      v18 = vmax_s32(v17, 0);
      v19 = vmin_s32(v17, 0);
      v20 = vsub_s32(*a6, v19);
      v21 = vmin_s32(v20, 0);
      v22 = vsub_s32(v18, v21);
      v23 = vsub_s32(*v15, vadd_s32(v19, v21));
      v24 = vmax_s32(v20, 0);
      v20.i32[0] = *((_DWORD *)this + 473);
      v20.i32[1] = *((_DWORD *)this + 475);
      v25 = vsub_s32(v20, v16);
      v26 = (int32x2_t)vbsl_s8((int8x8_t)vcgt_s32(vadd_s32(v22, v23), v25), (int8x8_t)vsub_s32(v25, v22), (int8x8_t)v23);
      v27 = vcgt_s32((int32x2_t)0x100000001, (int32x2_t)vbsl_s8((int8x8_t)vcgt_s32(vadd_s32(v26, v24), a3[3]), (int8x8_t)vsub_s32(a3[3], v24), (int8x8_t)v26));
      if (((v27.i32[0] | v27.i32[1]) & 1) == 0)
      {
        if (*((_DWORD *)this + 470) != 32 || !*((_QWORD *)this + 231))
          break;
        CGBlt_copyBytes();
      }
      ++a6;
      v15 += 2;
      --a4;
    }
    while (a4);
  }
  CA::OGL::Context::marked_surface((uint64_t)this, (uint64_t)a3);
  *a7 = 0;
}

double CA::OGL::SWContext::create_null_surface(CA::OGL::SWContext *this)
{
  malloc_zone_t *malloc_zone;
  char *v2;
  double result;

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v2 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x80uLL, 0x743898A5uLL);
  *(_DWORD *)v2 = 1;
  *(_OWORD *)(v2 + 24) = xmmword_18474E420;
  *(_QWORD *)&result = 0x100000001;
  *((_QWORD *)v2 + 5) = 0x100000001;
  *((_DWORD *)v2 + 17) = 15;
  v2[72] |= 1u;
  *((_QWORD *)v2 + 12) = 0;
  *((_QWORD *)v2 + 13) = 0;
  *((_QWORD *)v2 + 10) = 4;
  *((_QWORD *)v2 + 11) = &CA::OGL::SWContext::create_null_surface(void)::pixel;
  v2[120] = 0;
  *(_WORD *)(v2 + 75) |= 0x80u;
  return result;
}

void CA::OGL::SWContext::finalize_surface(uint64_t a1, uint64_t a2, void *a3)
{
  size_t v4;
  __IOSurface *v5;
  malloc_zone_t *malloc_zone;

  v4 = *(_QWORD *)(a2 + 96);
  if (v4)
    CA::Render::aligned_free(*(CA::Render **)(a2 + 88), v4, a3);
  v5 = *(__IOSurface **)(a2 + 112);
  if (v5)
  {
    IOSurfaceUnlock(v5, 0, 0);
    CFRelease(*(CFTypeRef *)(a2 + 112));
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, (void *)a2);
}

uint64_t CA::OGL::SWContext::needs_destination_group(CA::OGL::SWContext *this)
{
  return 0;
}

uint64_t CA::OGL::SWContext::bind_surface_impl(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6)
{
  uint64_t v6;

  v6 = *(_QWORD *)(result + 16);
  *(_WORD *)(v6 + 2 * a4 + 144) = 3;
  *(_QWORD *)(v6 + 8 * a4 + 176) = a2;
  *(_BYTE *)(a2 + 120) = (a5 != 0) | (16 * (a6 != 0));
  return result;
}

uint64_t CA::OGL::SWContext::set_surface(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;

  if (a2)
  {
    v3 = *(_DWORD *)(a2 + 68);
    if ((v3 & 7) != 0)
    {
      v4 = *(_QWORD *)(a2 + 80);
      *(_QWORD *)(a1 + 1848) = *(_QWORD *)(a2 + 88);
      *(_QWORD *)(a1 + 1864) = v4;
      if ((v3 & 8) != 0)
      {
        v6 = *(_QWORD *)(a2 + 80);
        v5 = *(_QWORD *)(a2 + 88);
      }
      else
      {
        v5 = 0;
        v6 = 0;
      }
      *(_QWORD *)(a1 + 1856) = v5;
      v10 = 0x400000020;
    }
    else
    {
      *(_QWORD *)(a1 + 1848) = 0;
      *(_QWORD *)(a1 + 1864) = 0;
      v6 = *(_QWORD *)(a2 + 80);
      *(_QWORD *)(a1 + 1856) = *(_QWORD *)(a2 + 88);
      v10 = 0;
    }
    *(_QWORD *)(a1 + 1872) = v6;
    *(_QWORD *)(a1 + 1880) = v10;
    v11 = *(_DWORD *)(a2 + 32);
    v12 = *(_DWORD *)(a2 + 36);
    *(_DWORD *)(a1 + 1888) = v11;
    *(_DWORD *)(a1 + 1896) = v12;
    v13 = *(_DWORD *)(a2 + 44);
    *(_DWORD *)(a1 + 1892) = *(_DWORD *)(a2 + 40) + v11;
    *(_DWORD *)(a1 + 1900) = v13 + v12;
    if ((*(_BYTE *)(a2 + 75) & 0x20) != 0)
    {
      bzero(*(void **)(a2 + 88), *(_QWORD *)(a2 + 104));
      *(_WORD *)(a2 + 75) = *(_WORD *)(a2 + 75) & 0xFF1F | 0xC0;
    }
  }
  else
  {
    v7 = *(_OWORD *)(a1 + 1920);
    *(_OWORD *)(a1 + 1848) = *(_OWORD *)(a1 + 1904);
    *(_OWORD *)(a1 + 1864) = v7;
    *(_QWORD *)(a1 + 1880) = *(_QWORD *)(a1 + 1936);
    v8 = *(_DWORD *)(a1 + 1944);
    *(_DWORD *)(a1 + 1888) = v8;
    v9 = *(_DWORD *)(a1 + 1948);
    *(_DWORD *)(a1 + 1896) = v9;
    *(_DWORD *)(a1 + 1892) = *(_DWORD *)(a1 + 1952) + v8;
    *(_DWORD *)(a1 + 1900) = *(_DWORD *)(a1 + 1956) + v9;
  }
  return 1;
}

void CA::OGL::SWContext::blur_surface(CA::OGL::SWContext *this, uint64_t a2, uint64_t a3, uint64_t a4, float a5, float a6, double a7, double a8, float64x2_t a9)
{
  BOOL v12;
  BOOL v13;
  int32x2_t v14;
  unsigned __int32 v15;
  uint64_t v16;
  int8x16_t v17;
  int v18;
  int v19;
  int32x2_t v20;
  int8x16_t v22;
  char v24;
  char *surface;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  float32x2_t v30;
  float32x2_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  float v35;
  float v36;
  uint64_t v37;
  uint64_t v38;
  float64x2_t v39;
  float64x2_t v40;
  __int128 v41;
  int32x2_t v42;
  float32x2_t v43;
  int32x2_t v44;
  float32x2_t v45;
  uint64_t v46;
  int8x16_t v47;
  _OWORD v48[8];
  _QWORD v49[3];
  __int128 v50;
  __int128 v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (*(_OWORD *)(a3 + 16) == 0
    && !a4
    && ((LODWORD(a7) = 1.0, a5 == 1.0) ? (v12 = a6 == 1.0) : (v12 = 0),
        v12 ? (v13 = *(_QWORD *)(a3 + 32) == 0) : (v13 = 0),
        v13))
  {
    v14 = (int32x2_t)vand_s8((int8x8_t)vcvt_s32_f32(vrndp_f32(vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)vdup_n_s32(0x40347A2Bu), *(float32x2_t *)a3))), (int8x8_t)vmovn_s64(vcgtq_f64(vcvtq_f64_f32(*(float32x2_t *)a3), (float64x2_t)vdupq_n_s64(0x3FE3333333333333uLL))));
    v15 = v14.i32[0];
    if ((v14.i32[0] & 0x80000000) == 0)
    {
      v16 = v14.u32[1];
      if ((v14.i32[1] & 0x80000000) == 0)
      {
        v17 = *(int8x16_t *)(a2 + 32);
        v47 = v17;
        v18 = v17.i32[2];
        if (v17.i32[2] <= v17.i32[3])
          v19 = v17.i32[3];
        else
          v19 = v17.i32[2];
        if (v17.i32[2] >= v17.i32[3])
          v18 = v17.i32[3];
        v20 = (int32x2_t)vextq_s8(v17, v17, 8uLL).u64[0];
        if (v19 <= 1073741822 && v18 >= 1)
        {
          *(int32x2_t *)v17.i8 = vsub_s32(*(int32x2_t *)v17.i8, v14);
          v20 = vadd_s32(vadd_s32(v14, v14), v20);
          v22.i64[0] = v17.i64[0];
          v22.u64[1] = (unint64_t)v20;
          v47 = v22;
          if (v20.i32[0] < 1 || v20.i32[1] <= 0)
          {
            v20 = 0;
            v47.i64[1] = 0;
          }
        }
        v42 = *(int32x2_t *)v17.i8;
        v44 = v20;
        v24 = 8;
        if (*(unsigned __int8 *)(*((_QWORD *)this + 2) + 16) - 11 >= 2)
        {
          if ((*(_BYTE *)(a2 + 68) & 7) != 0)
            v24 = 15;
          else
            v24 = 8;
        }
        surface = CA::OGL::SWContext::create_surface(this, 1, (const CA::Bounds *)&v47, v24);
        if (surface)
        {
          v26 = (uint64_t)surface;
          CA::OGL::Context::push_surface((uint64_t)this, (uint64_t)surface, 1u, 64, 0);
          v27 = *((_QWORD *)this + 32);
          if (v27 != *((_QWORD *)this + 31))
            goto LABEL_34;
          if (v27)
            LODWORD(v27) = (*(unsigned __int8 *)(v27 + 72) >> 1) & 0x1F;
          if (*((_DWORD *)this + 61) != (_DWORD)v27)
LABEL_34:
            CA::OGL::Context::prepare_destination_(this);
          if ((*((_WORD *)this + 408) & 0x200) != 0)
          {
            v28 = *((_QWORD *)this + 22);
            if (v28)
            {
              *((_WORD *)this + 408) &= ~0x200u;
            }
          }
          if ((*(_BYTE *)(v26 + 68) & 7) != 0)
          {
            CGBlt_copyBytes();
            v29 = 4;
          }
          else
          {
            if ((*(_BYTE *)(a2 + 68) & 7) != 0)
              CA::convert_bgra8888_to_mask(*(char **)(a2 + 88), *(char **)(a2 + 80), (char *)(*(_QWORD *)(v26 + 88) + *(_QWORD *)(v26 + 80) * v16 + v15), *(char **)(v26 + 80), *(int *)(a2 + 40), *(int *)(a2 + 44));
            else
              CGBlt_copyBytes();
            v29 = 1;
          }
          CA::OGL::Context::marked_destination(this);
          CA::OGL::Context::pop_surface(this);
          v30 = vcvt_f32_s32(vadd_s32(v44, v42));
          v31 = *(float32x2_t *)(a3 + 8);
          v43 = vadd_f32(v31, vcvt_f32_s32(v42));
          v45 = vadd_f32(v31, v30);
          CA::OGL::Context::bind_surface((uint64_t)this, v26, 0, 0, 0, 0.0);
          v51 = 0u;
          v32 = *(_QWORD *)(*((_QWORD *)this + 29) + 8);
          v49[0] = this;
          v49[1] = v32;
          v50 = 0u;
          v49[2] = 0;
          WORD4(v50) = 256;
          CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)v49);
          while (CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)v49, (int32x2_t *)&v47))
          {
            CA::OGL::Context::array_rect(this, v43.f32[0], v43.f32[1], v45.f32[0], v45.f32[1]);
            v33 = *(_QWORD *)(*((_QWORD *)this + 2) + 8);
            v34 = *((_QWORD *)this + 15) + 48 * *((_QWORD *)this + 16);
            *(_QWORD *)(v34 - 160) = v33;
            *(_QWORD *)(v34 - 112) = v33;
            *(_QWORD *)(v34 - 64) = v33;
            *(_QWORD *)(v34 - 16) = v33;
            v35 = (float)*(int *)(v26 + 40);
            v36 = (float)*(int *)(v26 + 44);
            v37 = *((_QWORD *)this + 15) + 48 * *((_QWORD *)this + 16);
            *(_QWORD *)(v37 - 176) = 0;
            *(float *)(v37 - 128) = v35;
            *(_DWORD *)(v37 - 124) = 0;
            *(float *)(v37 - 80) = v35;
            *(float *)(v37 - 76) = v36;
            *(_DWORD *)(v37 - 32) = 0;
            *(float *)(v37 - 28) = v36;
          }
          CA::OGL::Context::unbind_surface(this, v26, 0);
          CA::OGL::Context::release_surface((uint64_t)this, v26);
          v38 = *((_QWORD *)this + 2);
          if (*(_BYTE *)(v38 + 16) == 12)
          {
            v39 = vcvtq_f64_f32(v43);
            v48[0] = v39;
            v48[1] = xmmword_18474DF50;
            v40 = vcvtq_f64_f32(v45);
            *(float64_t *)&v41 = v40.f64[0];
            *((_QWORD *)&v41 + 1) = *(_QWORD *)&v39.f64[1];
            v48[2] = v41;
            v48[3] = xmmword_18474DF50;
            v48[4] = v40;
            v48[5] = xmmword_18474DF50;
            v39.f64[1] = v40.f64[1];
            v48[6] = v39;
            v48[7] = xmmword_18474DF50;
            v46 = *(_QWORD *)(v38 + 8);
            CA::OGL::emit_quad_surround((uint64_t)this, (const double *)v48, &v46);
          }
        }
      }
    }
  }
  else
  {
    CA::OGL::Context::blur_surface((uint64_t)this, (const CA::Bounds *)a2, a3, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t CA::OGL::SWContext::clear_region(uint64_t a1, uint64_t a2, CA::OGL::ExtendedColor *a3)
{
  uint64_t v6;
  int32x2_t v7;
  int32x2_t v8;
  uint32x2_t v9;
  int32x2_t v10;
  uint64_t result;
  uint32x2_t v12;
  int32x2_t v13;
  int32x2_t v14;
  uint32x2_t v15;
  __int128 v16;
  uint64_t v17;
  int32x2_t v18;
  unsigned __int32 v19;
  __int128 v20;
  uint64_t v21[4];

  v21[3] = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 256);
  if (v6 != *(_QWORD *)(a1 + 248))
    goto LABEL_2;
  if (v6)
    LODWORD(v6) = (*(unsigned __int8 *)(v6 + 72) >> 1) & 0x1F;
  if (*(_DWORD *)(a1 + 244) != (_DWORD)v6)
LABEL_2:
    CA::OGL::Context::prepare_destination_((CA::OGL::Context *)a1);
  CA::OGL::ExtendedColor::word32(a3);
  v7.i32[0] = *(_DWORD *)(a1 + 1888);
  v7.i32[1] = *(_DWORD *)(a1 + 1896);
  v8.i32[0] = *(_DWORD *)(a1 + 1892) - v7.i32[0];
  v8.i32[1] = *(_DWORD *)(a1 + 1900) - v7.i32[1];
  v20 = 0uLL;
  v21[1] = 0;
  v21[2] = 0;
  v21[0] = a2;
  v9 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v8);
  v10 = vadd_s32(v7, v8);
  v18 = v7;
  v19 = vpmax_u32(v9, v9).u32[0];
  while (1)
  {
    result = CA::ShapeIterator::iterate(v21, (int *)&v20);
    if (!(_DWORD)result)
      break;
    v12 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v20 + 8));
    if ((vpmax_u32(v12, v12).u32[0] & 0x80000000) == 0)
    {
      if ((v19 & 0x80000000) != 0
        || (v13 = vmax_s32(*(int32x2_t *)&v20, v18),
            v14 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)&v20, *(int32x2_t *)((char *)&v20 + 8)), v10), v13),
            v15 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v14),
            (vpmax_u32(v15, v15).u32[0] & 0x80000000) != 0))
      {
        *((_QWORD *)&v20 + 1) = 0;
      }
      else
      {
        *(int32x2_t *)&v16 = v13;
        *((int32x2_t *)&v16 + 1) = v14;
        v20 = v16;
        if (*(_QWORD *)(a1 + 1848))
          CGBlt_fillBytes();
        v17 = *(_QWORD *)(a1 + 1856);
        if (v17)
        {
          if (v17 != *(_QWORD *)(a1 + 1848))
            CGBlt_fillBytes();
        }
      }
    }
  }
  return result;
}

BOOL CA::OGL::SWContext::make_buffer_current(CA::OGL::SWContext *this, CA::WindowServer::Surface *a2)
{
  CA::WindowServer::Surface *v3;
  int v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 result;
  int v10;
  NSObject *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  char *v24;
  uint8_t buf[4];
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v3 = (CA::WindowServer::Surface *)*((_QWORD *)this + 245);
  if (v3 == a2)
    return 1;
  v23 = 0;
  v24 = 0;
  if (v3)
  {
    (*(void (**)(CA::WindowServer::Surface *))(*(_QWORD *)v3 + 144))(v3);
    *((_QWORD *)this + 245) = 0;
  }
  if (!a2
    || !(*(unsigned int (**)(CA::WindowServer::Surface *, char **, uint64_t *))(*(_QWORD *)a2 + 136))(a2, &v24, &v23))
  {
    return 1;
  }
  v5 = *((_DWORD *)a2 + 16);
  if (v5 <= 1278226487)
  {
    if (v5 == 1093677112)
      return 0;
    if (v5 == 1111970369)
    {
      v7 = v23;
      v6 = v24;
      v8 = 32;
      goto LABEL_16;
    }
  }
  else
  {
    switch(v5)
    {
      case 1278226488:
        v6 = 0;
        v7 = 0;
        v8 = 8;
        goto LABEL_16;
      case 1278555445:
        v6 = 0;
        v7 = 0;
        v8 = 15;
        goto LABEL_16;
      case 1278555701:
        v6 = 0;
        v7 = 0;
        v8 = 16;
LABEL_16:
        CA::OGL::SWContext::set_destination(this, v24, v23, v8, v6, v7, *((_DWORD *)this + 46), *((_DWORD *)this + 47), *((_DWORD *)this + 48), *((_DWORD *)this + 49));
        *((_QWORD *)this + 245) = a2;
        return 1;
    }
  }
  if (x_log_hook_p())
  {
    v10 = *((_DWORD *)a2 + 16);
    if (v10 < 0)
    {
      __maskrune(HIBYTE(*((_DWORD *)a2 + 16)), 0x40000uLL);
      v10 = *((_DWORD *)a2 + 16);
    }
    if (BYTE2(v10) > 0x7Fu)
    {
      __maskrune(BYTE2(v10), 0x40000uLL);
      v10 = *((_DWORD *)a2 + 16);
    }
    if (BYTE1(v10) > 0x7Fu)
    {
      __maskrune(BYTE1(v10), 0x40000uLL);
      v10 = *((_DWORD *)a2 + 16);
    }
    if (v10 > 0x7Fu)
      __maskrune(v10, 0x40000uLL);
    x_log_();
    return 0;
  }
  v11 = x_log_category_ogl;
  result = os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_ERROR);
  if (result)
  {
    v12 = *((unsigned int *)a2 + 16);
    v13 = v12 >> 24;
    v14 = MEMORY[0x1E0C80978];
    if ((v12 & 0x80000000) != 0)
    {
      v15 = __maskrune(v13, 0x40000uLL);
      LODWORD(v12) = *((_DWORD *)a2 + 16);
    }
    else
    {
      v15 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v13 + 60) & 0x40000;
    }
    if (v15)
      v16 = (int)v12 >> 24;
    else
      v16 = 32;
    if (BYTE2(v12) <= 0x7Fu)
    {
      v17 = *(_DWORD *)(v14 + 4 * BYTE2(v12) + 60) & 0x40000;
    }
    else
    {
      v17 = __maskrune(BYTE2(v12), 0x40000uLL);
      LODWORD(v12) = *((_DWORD *)a2 + 16);
    }
    if (v17)
      v18 = (int)((_DWORD)v12 << 8) >> 24;
    else
      v18 = 32;
    if (BYTE1(v12) <= 0x7Fu)
    {
      v19 = *(_DWORD *)(v14 + 4 * BYTE1(v12) + 60) & 0x40000;
    }
    else
    {
      v19 = __maskrune(BYTE1(v12), 0x40000uLL);
      LODWORD(v12) = *((_DWORD *)a2 + 16);
    }
    if (v19)
      v20 = (__int16)v12 >> 8;
    else
      v20 = 32;
    if (v12 <= 0x7Fu)
      v21 = *(_DWORD *)(v14 + 4 * v12 + 60) & 0x40000;
    else
      v21 = __maskrune(v12, 0x40000uLL);
    if (v21)
      v22 = *((char *)a2 + 64);
    else
      v22 = 32;
    *(_DWORD *)buf = 67109888;
    v26 = v16;
    v27 = 1024;
    v28 = v18;
    v29 = 1024;
    v30 = v20;
    v31 = 1024;
    v32 = v22;
    _os_log_impl(&dword_184457000, v11, OS_LOG_TYPE_ERROR, "SW renderer invalid destination format %c%c%c%c", buf, 0x1Au);
    return 0;
  }
  return result;
}

uint64_t CA::OGL::SWContext::function_supported(CA::OGL::SWContext *this)
{
  uint64_t v1;
  unsigned int v2;
  BOOL v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  char i;
  char v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v14;
  int v15;

  v1 = *((_QWORD *)this + 2);
  v2 = *(unsigned __int8 *)(v1 + 16);
  v3 = v2 > 0x37;
  v4 = (1 << v2) & 0xBF80000213BFEBLL;
  if (!v3 && v4 != 0)
  {
    result = 0;
    v7 = v1 + 17;
    v8 = v1 + 19;
    for (i = 1; ; i = 0)
    {
      v10 = i;
      v11 = *(unsigned __int8 *)(v7 + result);
      v3 = v11 > 0x26;
      v12 = (1 << v11) & 0x4000200003;
      if (v3 || v12 == 0)
        break;
      v14 = *(unsigned __int8 *)(v8 + result);
      v3 = v14 > 5;
      v15 = (1 << v14) & 0x2B;
      if (v3 || v15 == 0)
        break;
      result = 1;
      if ((v10 & 1) == 0)
        return result;
    }
  }
  return 0;
}

float CA::OGL::SWContext::function_uniform(CA::OGL::SWContext *this, unsigned int a2, uint64_t a3, uint64_t a4, float *a5)
{
  int v5;
  float *v6;
  float v7;
  float result;
  uint64_t i;
  uint64_t v11;
  float *v12;
  float v13;
  float *v14;
  float v15;

  v5 = *(unsigned __int8 *)(*((_QWORD *)this + 2) + 16);
  switch(*(_BYTE *)(*((_QWORD *)this + 2) + 16))
  {
    case '/':
      goto LABEL_16;
    case '0':
    case '1':
      if (a2 <= 1 && a3 == 4 && a4 == 1 || a2 == 2 && a3 == 1 && a4 == 1)
      {
        v6 = (float *)((char *)this + 16 * a2 + 1968);
        do
        {
          v7 = *a5++;
          result = v7;
          *v6++ = v7;
          --a3;
        }
        while (a3);
      }
      break;
    case '2':
    case '3':
    case '5':
    case '6':
      return result;
    case '4':
      v11 = a4 * a3;
      if (a4 * a3)
      {
        v12 = (float *)((char *)this + 1968);
        do
        {
          v13 = *a5++;
          result = v13;
          *v12++ = v13;
          --v11;
        }
        while (v11);
      }
      break;
    case '7':
      if (a3)
      {
        v14 = (float *)((char *)this + 16 * a2 + 1968);
        do
        {
          v15 = *a5++;
          result = v15;
          *v14++ = v15;
          --a3;
        }
        while (a3);
      }
      break;
    default:
      if (v5 == 20 || v5 == 24)
      {
LABEL_16:
        if (a3 == 4 && a4 == 5)
        {
          for (i = 0; i != 20; ++i)
          {
            result = a5[i];
            *(float *)((char *)this + i * 4 + 1968) = result;
          }
        }
      }
      break;
  }
  return result;
}

uint64_t CA::OGL::SWContext::set_destination(CA::OGL::SWContext *this, char *a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6, int a7, int a8, int a9, int a10)
{
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;

  if (a2)
  {
    if ((*((_DWORD *)this + 104) & 1) != 0)
      v10 = 0;
    else
      v10 = (a10 - 1) * a3;
    v11 = &a2[v10];
    if ((*((_DWORD *)this + 104) & 1) != 0)
      v12 = a3;
    else
      v12 = -a3;
    v13 = (unint64_t)(a4 + 7) >> 3;
  }
  else
  {
    LODWORD(v13) = 0;
    LODWORD(a4) = 0;
    v12 = 0;
    v11 = 0;
  }
  *((_QWORD *)this + 238) = v11;
  *((_QWORD *)this + 240) = v12;
  *((_DWORD *)this + 484) = a4;
  *((_DWORD *)this + 485) = v13;
  if (a5)
  {
    if (a5 == a2)
    {
      *((_QWORD *)this + 239) = v11;
      a6 = v12;
      a5 = v11;
    }
    else if ((*((_BYTE *)this + 416) & 1) != 0)
    {
      *((_QWORD *)this + 239) = a5;
    }
    else
    {
      a5 += (a10 - 1) * a6;
      *((_QWORD *)this + 239) = a5;
      a6 = -a6;
    }
  }
  else
  {
    a6 = 0;
    *((_QWORD *)this + 239) = 0;
  }
  *((_QWORD *)this + 241) = a6;
  *((_DWORD *)this + 486) = a7;
  *((_DWORD *)this + 487) = a8;
  *((_DWORD *)this + 488) = a9;
  *((_DWORD *)this + 489) = a10;
  *((_QWORD *)this + 231) = v11;
  *((_QWORD *)this + 232) = a5;
  *((_QWORD *)this + 233) = v12;
  *((_QWORD *)this + 234) = a6;
  *((_DWORD *)this + 470) = a4;
  *((_DWORD *)this + 471) = v13;
  *((_DWORD *)this + 472) = a7;
  *((_DWORD *)this + 474) = a8;
  *((_DWORD *)this + 473) = a9 + a7;
  *((_DWORD *)this + 475) = a10 + a8;
  return 1;
}

uint64_t CA::OGL::SWContext::sw_renderer_p(CA::OGL::SWContext *this)
{
  return 1;
}

CFTypeRef *CA::OGL::SWContext::retain_image(uint64_t a1, CFTypeRef *this)
{
  int v4;
  CFTypeRef v5;
  unsigned int *v6;
  unsigned int v7;

  while (1)
  {
    v4 = *((unsigned __int8 *)this + 12);
    if (v4 != 38)
      break;
    this = (CFTypeRef *)CA::Render::PixelBuffer::image((CA::Render::PixelBuffer *)this);
    if (!this)
      return this;
  }
  switch(v4)
  {
    case 9:
      if (!*(_QWORD *)(a1 + 8))
      {
        *(_QWORD *)(a1 + 8) = this;
        (*((void (**)(CFTypeRef *))*this + 22))(this);
      }
      break;
    case 23:
      *(_BYTE *)(a1 + 112) = 1;
      if (!*(_QWORD *)(a1 + 8))
      {
        *(_QWORD *)(a1 + 8) = this;
        v6 = (unsigned int *)this + 37;
        do
          v7 = __ldaxr(v6);
        while (__stlxr(v7 + 1, v6));
      }
      break;
    case 51:
      if (!*(_QWORD *)(a1 + 8))
      {
        *(_QWORD *)(a1 + 8) = this;
        (*((void (**)(CFTypeRef *))*this + 22))(this);
      }
      if (!*(_QWORD *)(a1 + 72))
      {
        v5 = this[14];
        if (v5)
          CFRetain(this[14]);
        *(_QWORD *)(a1 + 72) = v5;
        *(_DWORD *)(a1 + 80) = (*((uint64_t (**)(CFTypeRef *))*this + 13))(this);
      }
      break;
  }
  return this;
}

void *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Copy,false>::blend(void *a1, int a2, void *__src, uint64_t a4)
{
  return memcpy(a1, __src, 4 * a4);
}

void std::__function::__func<CA::OGL::SWContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0,std::allocator<CA::OGL::SWContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0>,BOOL ()(CA::OGL::Vertex*,unsigned int)>::~__func()
{
  JUMPOUT(0x186DBD990);
}

_QWORD *std::__function::__func<CA::OGL::SWContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0,std::allocator<CA::OGL::SWContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0>,BOOL ()(CA::OGL::Vertex*,unsigned int)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E159A408;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CA::OGL::SWContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0,std::allocator<CA::OGL::SWContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0>,BOOL ()(CA::OGL::Vertex*,unsigned int)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E159A408;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<CA::OGL::SWContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0,std::allocator<CA::OGL::SWContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0>,BOOL ()(CA::OGL::Vertex*,unsigned int)>::operator()(uint64_t a1, uint64_t *a2, unsigned __int32 *a3)
{
  CA::OGL::SW::draw_polygon(*a2, *a3, *(int **)(a1 + 8));
  return 1;
}

void CA::OGL::SW::draw_polygon(uint64_t a1, unsigned __int32 a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  float32x4_t *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  float *v17;
  float *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  float v22;
  float v23;
  float32x4_t *v24;
  unsigned int v26;
  unsigned int v27;
  float *v28;
  float *v29;
  float *v30;
  BOOL v31;
  float32x4_t *v32;
  float16x4_t *v33;
  float16x4_t v34;
  int v35;
  float *f32;
  float v37;
  float v38;
  float v39;
  uint64_t v40;
  float *v41;
  float v42;
  int v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  int v51;
  int v52;
  char v53;
  uint64_t v54;
  float32x4_t *v55;
  float v56;
  float *v57;
  unsigned int v58;
  unsigned int v59;
  signed int v60;
  signed int v61;
  int v62;
  unsigned int v63;
  size_t v64;
  unsigned int v65;
  uint64_t v66;
  _QWORD block[6];
  unsigned int v68;
  int v69;
  float v70;
  int v71;
  unsigned int v72;
  int v73;
  signed int v74;
  int v75;
  unsigned int v76;
  char v77;
  __int16 v78;
  char v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(*(_QWORD *)a3 + 16);
  v7 = a2 - 1;
  MEMORY[0x1E0C80A78](a1);
  v10 = (float32x4_t *)(((unint64_t)&v65 - v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v10)
  {
    bzero((char *)&v65 - v9, v8);
    v10->i32[0] = a2;
    if ((a3[73] & 1) != 0)
      v11 = 779;
    else
      v11 = 11;
    v10->i32[1] = v11;
    v12 = a3[73];
    v13 = v11 | 0xC00;
    if ((v12 & 2) == 0)
      v13 = v11;
    v14 = v13 | 0x3000;
    if ((v12 & 4) == 0)
      v14 = v13;
    if ((v12 & 6) != 0)
    {
      v10->i32[1] = v14;
      v11 = v14;
    }
    v15 = *(_QWORD *)(a1 + 32);
    if (!*(_BYTE *)(v6 + 480))
      v15 = 0;
    v66 = v15;
    if (!a2)
      goto LABEL_35;
    v16 = 0;
    v17 = (float *)(a1 + 20);
    v18 = &v10[3].f32[1];
    v19 = a2;
    do
    {
      v20 = (uint64_t *)(a1 + 48 * v16);
      v21 = *v20;
      v22 = *((float *)v20 + 3);
      v23 = 1.0;
      if (v22 != 1.0)
      {
        v11 = v14 | 4;
        v10->i32[1] = v14 | 4;
        v14 |= 4u;
        v23 = 1.0 / v22;
      }
      v24 = &v10[4 * v16];
      v24[1].i64[0] = v21;
      v24[1].f32[2] = v22;
      v24[1].f32[3] = v23;
      v24[2] = 0uLL;
      v24[3] = 0uLL;
      v24[4] = 0uLL;
      if ((v14 & 0xF0) == 0 && *(_QWORD *)(a1 + 48 * v16 + 32) != v15 && *(_BYTE *)(v6 + 480) != 0)
      {
        v26 = *(unsigned __int8 *)(v6 + 16);
        if (v26 <= 0x10 && ((1 << v26) & 0x138E9) != 0)
        {
          v11 = v14 | 0xF0;
          v10->i32[1] = v14 | 0xF0;
          v14 |= 0xF0u;
        }
      }
      v27 = a3[73];
      if (v27)
      {
        v28 = (float *)(v6 + 108);
        v29 = v18;
        v30 = v17;
        do
        {
          if ((v27 & 1) != 0)
          {
            *(v29 - 1) = *(v28 - 1) + (float)(*(v28 - 3) * *(v30 - 1));
            *v29 = *v28 + (float)(*(v28 - 2) * *v30);
          }
          v30 += 2;
          v29 += 2;
          v28 += 4;
          v31 = v27 > 1;
          v27 >>= 1;
        }
        while (v31);
      }
      ++v16;
      v17 += 12;
      v18 += 16;
    }
    while (v16 != a2);
    if ((v14 & 0xF0) != 0)
    {
      v32 = v10 + 2;
      v33 = (float16x4_t *)(a1 + 32);
      do
      {
        v34 = *v33;
        v33 += 6;
        *v32 = vcvtq_f32_f16(v34);
        v32 += 4;
        --v19;
      }
      while (v19);
    }
    else
    {
LABEL_35:
      LOWORD(v66) = WORD2(v15);
      WORD1(v66) = WORD1(v15);
      WORD2(v66) = v15;
      HIWORD(v66) = HIWORD(v15);
    }
    v35 = CA::OGL::ExtendedColor::word32((CA::OGL::ExtendedColor *)&v66);
    f32 = v10[4 * v7].f32;
    v37 = f32[4];
    v38 = f32[5];
    if ((v11 & 8) != 0)
    {
      v39 = f32[7];
      v37 = v39 * v37;
      v38 = v39 * v38;
    }
    if (a2)
    {
      v40 = 0;
      v41 = &v10[1].f32[3];
      v42 = 0.0;
      v43 = -1;
      v44 = INFINITY;
      v45 = -INFINITY;
      v46 = -INFINITY;
      v47 = INFINITY;
      do
      {
        v48 = *(v41 - 3);
        v49 = *(v41 - 2);
        if ((v11 & 8) != 0)
        {
          v48 = *v41 * v48;
          v49 = *v41 * v49;
        }
        v42 = (float)(v42 - (float)(v48 * v38)) + (float)(v49 * v37);
        if (v49 < v44)
        {
          v43 = v40;
          v44 = v49;
        }
        if (v49 > v45)
          v45 = v49;
        if (v48 < v47)
          v47 = v48;
        ++v40;
        if (v48 > v46)
          v46 = v48;
        v41 += 16;
        v38 = v49;
        v37 = v48;
      }
      while (a2 != v40);
      v50 = v42 * 0.5;
    }
    else
    {
      v43 = -1;
      v50 = 0.0;
      v46 = -INFINITY;
      v47 = INFINITY;
      v44 = INFINITY;
      v45 = -INFINITY;
    }
    if (fabsf(v50) >= 0.00005)
    {
      v51 = a3[69];
      if (v45 >= (float)v51)
      {
        v52 = a3[71];
        if (v44 < (float)v52 && v46 >= (float)a3[68] && v47 < (float)a3[70])
        {
          if ((v11 & 4) != 0)
          {
            if (a2)
            {
              v54 = 0;
              do
              {
                if ((v11 & 0xFFFFFF03) != 0)
                {
                  v55 = &v10[4 * v54];
                  v56 = v55[1].f32[3];
                  v57 = v55[1].f32;
                  v58 = v11 & 0xFFFFFF03;
                  do
                  {
                    if ((v58 & 1) != 0)
                      *v57 = *v57 * v56;
                    ++v57;
                    v31 = v58 > 1;
                    v58 >>= 1;
                  }
                  while (v31);
                }
                ++v54;
              }
              while (v54 != a2);
            }
            v11 &= ~4u;
            v10->i32[1] = v11;
            v53 = 1;
          }
          else
          {
            v53 = 0;
          }
          v59 = vcvtps_s32_f32(v44 + -0.5);
          if ((float)(v44 - ceilf(v44 + -0.5)) == 0.5)
            ++v59;
          v65 = v59;
          v60 = vcvtms_s32_f32(v44);
          v61 = vcvtps_s32_f32(v45);
          block[0] = MEMORY[0x1E0C809B0];
          if (v51 > v60)
            v60 = v51;
          block[1] = 0x40000000;
          block[2] = ___ZN2CA3OGL2SW12scan_convertEPKNS1_11RenderStateEPNS1_4PolyEj_block_invoke;
          block[3] = &__block_descriptor_tmp_5353;
          if (v52 >= v61)
            v52 = v61;
          v62 = v52 - v60 + 3;
          block[4] = a3;
          block[5] = v10;
          if (v52 >= v60)
            v62 = v52 - v60;
          v63 = v62 >> 2;
          if (v52 - v60 <= 7)
            v64 = 1;
          else
            v64 = v63;
          v68 = v11 & 0xFFFFFFFD;
          v69 = v35;
          v70 = v50;
          v71 = v43;
          v72 = v59;
          v73 = 4;
          v74 = v60;
          v75 = v52;
          v76 = v59;
          v77 = v53;
          v78 = 0;
          v79 = 0;
          dispatch_apply(v64, 0, block);
        }
      }
    }
  }
}

uint64_t ___ZN2CA3OGL2SW12scan_convertEPKNS1_11RenderStateEPNS1_4PolyEj_block_invoke(uint64_t result, double a2, float32x4_t a3, double a4, double a5, double a6)
{
  uint64_t v6;
  int *v7;
  float32x4_t v8;
  uint64_t v9;
  signed int v10;
  unsigned int v11;
  signed int v12;
  unsigned int *v13;
  int v14;
  __int128 v15;
  int v16;
  signed int v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  float *v23;
  float v24;
  float *v25;
  float v26;
  float v27;
  float v28;
  float32x4_t *v29;
  float32x4_t *v30;
  unsigned int v31;
  float v32;
  float32_t v33;
  BOOL v34;
  int v35;
  float v36;
  int v37;
  float v38;
  float v39;
  float v40;
  float *v41;
  float32x4_t *v42;
  float32x4_t *v43;
  unsigned int v44;
  float *v45;
  float v46;
  float32_t v47;
  BOOL v48;
  signed int v49;
  int v50;
  int v51;
  int v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int v59;
  int v60;
  int v61;
  unsigned int v62;
  float v63;
  float32x4_t *v64;
  float32x4_t *v65;
  signed int v66;
  signed int v67;
  int v68;
  signed int v69;
  signed int v70;
  BOOL v71;
  int v72;
  unsigned int v73;
  float v74;
  _DWORD *v75;
  float *v76;
  float *v77;
  float32x4_t *v78;
  unsigned int v79;
  float v80;
  _OWORD *v81;
  const unsigned int *v82;
  uint64_t v83;
  unsigned int v84;
  unsigned int v85;
  uint64_t v86;
  _DWORD *v87;
  float *v88;
  _DWORD *v89;
  float *v90;
  unsigned int v91;
  float v92;
  _DWORD *v93;
  float *v94;
  unsigned __int32 *v95;
  unsigned int v96;
  _DWORD *v97;
  float *v98;
  unsigned __int32 *v99;
  unsigned int v100;
  int v101;
  unsigned int *v102;
  uint64_t v103;
  uint64_t v104;
  int v105;
  signed int v106;
  uint64_t *v107;
  _OWORD v108[4];
  _OWORD v109[4];
  _OWORD v110[4];
  _OWORD v111[4];
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  _OWORD v128[4];
  _OWORD v129[4];
  _OWORD v130[4];
  _OWORD v131[4];
  uint64_t v132;

  v132 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(result + 32);
  v107 = (uint64_t *)(result + 32);
  v7 = *(int **)(result + 40);
  v8.i32[1] = 0;
  v126 = 0u;
  v127 = 0u;
  v124 = 0u;
  v125 = 0u;
  v122 = 0u;
  v123 = 0u;
  v120 = 0u;
  v121 = 0u;
  v118 = 0u;
  v119 = 0u;
  v116 = 0u;
  v117 = 0u;
  v114 = 0u;
  v115 = 0u;
  v112 = 0u;
  v113 = 0u;
  v9 = *v7;
  if ((int)v9 >= 1)
  {
    v10 = *(_DWORD *)(result + 64);
    v101 = *(_DWORD *)(result + 76);
    if (v10 < v101)
    {
      v11 = *(_DWORD *)(result + 48);
      v12 = v10 - 1;
      v13 = (unsigned int *)(result + 80);
      v14 = *(_DWORD *)(result + 60);
      v15 = 0uLL;
      v16 = *(_DWORD *)(result + 64);
      v17 = v10 - 1;
      v18 = v14;
      v19 = v16;
      v103 = v6;
      v104 = result;
      v102 = (unsigned int *)v7;
      while (1)
      {
        if (v17 <= v19)
        {
          do
          {
            v21 = v18;
            if (v18 < 1)
              v21 = *v7;
            v22 = v21 - 1;
            v23 = (float *)&v7[16 * (uint64_t)(v21 - 1) + 4];
            v24 = v23[1];
            v25 = (float *)&v7[16 * (uint64_t)v18 + 4];
            v26 = v25[1];
            *(float *)&a6 = 1.0 / (float)(v24 - v26);
            if ((float)(v24 - v26) == 0.0)
              v27 = 1.0;
            else
              v27 = 1.0 / (float)(v24 - v26);
            if (v11)
            {
              v28 = (float)((float)v19 + 0.5) - v26;
              v29 = &v124;
              v30 = &v116;
              v31 = v11;
              do
              {
                if ((v31 & 1) != 0)
                {
                  v32 = *v25;
                  v33 = (float)(*v23 - *v25) * v27;
                  v30->f32[0] = v33;
                  *(float *)&a6 = v32 + (float)(v33 * v28);
                  v29->i32[0] = LODWORD(a6);
                }
                ++v25;
                ++v23;
                v29 = (float32x4_t *)((char *)v29 + 4);
                v30 = (float32x4_t *)((char *)v30 + 4);
                v34 = v31 > 1;
                v31 >>= 1;
              }
              while (v34);
            }
            v20 = (v9 - 1);
            v17 = vcvtms_s32_f32(v24 + 0.5);
            v34 = v19 < v17 || (int)v9 <= 1;
            LODWORD(v9) = v9 - 1;
            v18 = v22;
          }
          while (!v34);
          v18 = v22;
        }
        else
        {
          v20 = v9;
        }
        if (v12 > v19 || (int)v20 < 1)
        {
          v9 = v20;
        }
        else
        {
          v35 = *v7;
          v36 = *(float *)&v7[16 * (uint64_t)v14 + 5];
          do
          {
            if (v14 + 1 < v35)
              v37 = v14 + 1;
            else
              v37 = 0;
            v38 = *(float *)&v7[16 * (uint64_t)v37 + 5];
            *(float *)&a6 = 1.0 / (float)(v38 - v36);
            if ((float)(v38 - v36) == 0.0)
              v39 = 1.0;
            else
              v39 = 1.0 / (float)(v38 - v36);
            if (v11)
            {
              v40 = (float)((float)v19 + 0.5) - v36;
              v41 = (float *)&v7[16 * (uint64_t)v37 + 4];
              v42 = &v120;
              v43 = &v112;
              v44 = v11;
              v45 = (float *)&v7[16 * (uint64_t)v14 + 4];
              do
              {
                if ((v44 & 1) != 0)
                {
                  v46 = *v45;
                  v47 = (float)(*v41 - *v45) * v39;
                  v43->f32[0] = v47;
                  *(float *)&a6 = v46 + (float)(v47 * v40);
                  v42->i32[0] = LODWORD(a6);
                }
                ++v45;
                ++v41;
                v42 = (float32x4_t *)((char *)v42 + 4);
                v43 = (float32x4_t *)((char *)v43 + 4);
                v34 = v44 > 1;
                v44 >>= 1;
              }
              while (v34);
            }
            v12 = vcvtms_s32_f32(v38 + 0.5);
            v9 = (v20 - 1);
            v48 = v19 < v12 || (int)v20 <= 1;
            v36 = v38;
            LODWORD(v20) = v20 - 1;
            v14 = v37;
          }
          while (!v48);
          v14 = v37;
        }
        v49 = v17 >= v12 ? v12 : v17;
        v50 = v49 >= v101 ? v101 : v49;
        v105 = v50;
        v106 = v49;
        if (v19 < v50)
          break;
LABEL_127:
        if ((int)v9 < 1 || v19 >= v101)
          return result;
      }
      while (v19 < v10)
      {
LABEL_51:
        if (v19 >= v16)
        {
          v63 = v124.f32[0];
          if (v124.f32[0] <= v120.f32[0])
            a3.f32[0] = v124.f32[0];
          else
            a3.f32[0] = v120.f32[0];
          if (v124.f32[0] <= v120.f32[0])
            v64 = &v124;
          else
            v64 = &v120;
          if (v124.f32[0] > v120.f32[0])
          {
            v65 = &v124;
          }
          else
          {
            v63 = v120.f32[0];
            v65 = &v120;
          }
          v66 = vcvtps_s32_f32(a3.f32[0] + -0.5);
          *(float *)&a5 = floorf(v63 + -0.5);
          v67 = vcvtms_s32_f32(v63 + -0.5) - ((float)(v63 - *(float *)&a5) == 0.5);
          if (*(_DWORD *)(v6 + 272) <= v66)
            v68 = v66;
          else
            v68 = *(_DWORD *)(v6 + 272);
          v69 = *(_DWORD *)(v6 + 280);
          if (v67 >= v69)
            v70 = v69 - 1;
          else
            v70 = v67;
          v71 = __OFSUB__(v70, v68);
          v72 = v70 - v68;
          if (v72 < 0 == v71)
          {
            v111[2] = v15;
            v111[3] = v15;
            v111[0] = v15;
            v111[1] = v15;
            v110[2] = v15;
            v110[3] = v15;
            v110[0] = v15;
            v110[1] = v15;
            v109[2] = v15;
            v109[3] = v15;
            v109[0] = v15;
            v109[1] = v15;
            v108[2] = v15;
            v108[3] = v15;
            v108[0] = v15;
            v108[1] = v15;
            if (*(_BYTE *)(result + 84))
              v73 = v11 & 0xFFFFFFFA | 4;
            else
              v73 = v11 & 0xFFFFFFFE;
            v74 = v63 - a3.f32[0];
            *(float *)&a4 = 1.0 / v74;
            if (v74 == 0.0)
              *(float *)&a4 = 1.0;
            v8.f32[0] = (float)v68 + 0.5;
            if (v73)
            {
              v75 = v111;
              a3.f32[0] = v8.f32[0] - a3.f32[0];
              v76 = (float *)v110;
              v77 = (float *)v65;
              v78 = v64;
              v79 = v73;
              do
              {
                if ((v79 & 1) != 0)
                {
                  LODWORD(a6) = v78->i32[0];
                  v80 = (float)(*v77 - v78->f32[0]) * *(float *)&a4;
                  *v76 = v80;
                  *(float *)&a5 = *(float *)&a6 + (float)(v80 * a3.f32[0]);
                  *v75 = LODWORD(a5);
                }
                v78 = (float32x4_t *)((char *)v78 + 4);
                ++v77;
                ++v75;
                ++v76;
                v34 = v79 > 1;
                v79 >>= 1;
              }
              while (v34);
            }
            if ((*(_BYTE *)(v6 + 288) & 1) != 0)
            {
              v83 = 0;
              v131[2] = v15;
              v131[3] = v15;
              v131[0] = v15;
              v131[1] = v15;
              v84 = v73 | 1;
              v85 = v73 | 1;
              do
              {
                if ((v85 & 1) != 0)
                  *(float *)((char *)v131 + v83 * 4) = v116.f32[v83] + v64->f32[v83];
                ++v83;
                v34 = v85 > 1;
                v85 >>= 1;
              }
              while (v34);
              v86 = 0;
              v130[2] = v15;
              v130[3] = v15;
              v130[0] = v15;
              v130[1] = v15;
              do
              {
                if ((v84 & 1) != 0)
                  *(float *)((char *)v130 + v86 * 4) = v112.f32[v86] + v65->f32[v86];
                ++v86;
                v34 = v84 > 1;
                v84 >>= 1;
              }
              while (v34);
              LODWORD(a4) = v131[0];
              *(float *)&a5 = 1.0 / (float)(*(float *)v130 - *(float *)v131);
              if ((float)(*(float *)v130 - *(float *)v131) == 0.0)
                a3.f32[0] = 1.0;
              else
                a3.f32[0] = 1.0 / (float)(*(float *)v130 - *(float *)v131);
              if (v73)
              {
                v8.f32[0] = v8.f32[0] - *(float *)v131;
                v129[2] = v15;
                v129[3] = v15;
                v129[0] = v15;
                v129[1] = v15;
                v128[0] = v15;
                v128[1] = v15;
                v87 = v131;
                v88 = (float *)v130;
                v89 = v129;
                v90 = (float *)v128;
                v91 = v73;
                v128[2] = v15;
                v128[3] = v15;
                do
                {
                  if ((v91 & 1) != 0)
                  {
                    LODWORD(a5) = *v87;
                    v92 = (float)(*v88 - *(float *)v87) * a3.f32[0];
                    *v90 = v92;
                    *(float *)&a4 = *(float *)&a5 + (float)(v92 * v8.f32[0]);
                    *v89 = LODWORD(a4);
                  }
                  ++v87;
                  ++v88;
                  ++v89;
                  ++v90;
                  v34 = v91 > 1;
                  v91 >>= 1;
                }
                while (v34);
                v93 = v109;
                v94 = (float *)v129;
                v95 = (unsigned __int32 *)v111;
                v96 = v73;
                do
                {
                  if ((v96 & 1) != 0)
                  {
                    a3.i32[0] = *v95;
                    v8.f32[0] = *v94 - *(float *)v95;
                    *v93 = v8.i32[0];
                  }
                  ++v93;
                  ++v94;
                  ++v95;
                  v34 = v96 > 1;
                  v96 >>= 1;
                }
                while (v34);
                v97 = v108;
                v98 = (float *)v128;
                v99 = (unsigned __int32 *)v110;
                v100 = v73;
                do
                {
                  if ((v100 & 1) != 0)
                  {
                    a3.i32[0] = *v99;
                    v8.f32[0] = *v98 - *(float *)v99;
                    *v97 = v8.i32[0];
                  }
                  ++v97;
                  ++v98;
                  ++v99;
                  v34 = v100 > 1;
                  v100 >>= 1;
                }
                while (v34);
              }
              v82 = (const unsigned int *)v108;
              v81 = v109;
            }
            else
            {
              v81 = 0;
              v82 = 0;
            }
            CA::OGL::SW::scanline(v107, v68, v19, (const CA::ColorProgram::Program *)(v72 + 1), (float *)v111, (uint64_t)v110, (uint64_t)v81, v82, *(double *)v8.i64, *(double *)a3.i64, a4, a5, a6, v73);
            v6 = v103;
            result = v104;
            v15 = 0uLL;
            v7 = (int *)v102;
            v50 = v105;
            v49 = v106;
          }
          v124 = vaddq_f32(v124, v116);
          v125 = vaddq_f32(v125, v117);
          v126 = vaddq_f32(v126, v118);
          v127 = vaddq_f32(v127, v119);
          v120 = vaddq_f32(v120, v112);
          v121 = vaddq_f32(v121, v113);
          HIDWORD(a4) = v122.i32[1];
          HIDWORD(a5) = v123.i32[1];
          v8 = vaddq_f32(v122, v114);
          a3 = vaddq_f32(v123, v115);
          ++v19;
          v122 = v8;
          v123 = a3;
        }
        else
        {
          if (v49 >= v16)
            v51 = v16;
          else
            v51 = v49;
          v8 = v124;
          a3 = v120;
          v52 = v51 - v19;
          if (v51 > v19)
          {
            HIDWORD(a4) = v116.i32[1];
            HIDWORD(a5) = v117.i32[1];
            a6 = *(double *)v118.i64;
            v54 = v125;
            v53 = v126;
            v55 = v127;
            v57 = v121;
            v56 = v122;
            v58 = v123;
            do
            {
              v8 = vaddq_f32(v8, v116);
              v54 = vaddq_f32(v54, v117);
              v53 = vaddq_f32(v53, v118);
              v55 = vaddq_f32(v55, v119);
              a3 = vaddq_f32(a3, v112);
              v57 = vaddq_f32(v57, v113);
              v56 = vaddq_f32(v56, v114);
              v58 = vaddq_f32(v58, v115);
              --v52;
            }
            while (v52);
            v125 = v54;
            v126 = v53;
            v127 = v55;
            v121 = v57;
            v122 = v56;
            v19 = v51;
            v123 = v58;
          }
          v124 = v8;
          v120 = a3;
        }
        if (v19 >= v50)
          goto LABEL_127;
      }
      while (1)
      {
        v59 = *(_DWORD *)(result + 80);
        v60 = *(_DWORD *)(result + 76);
        if (v59 >= v60)
          break;
        v61 = *(_DWORD *)(result + 68);
        if (v59 <= *(_DWORD *)(result + 72))
          v16 = *(_DWORD *)(result + 72);
        else
          v16 = *(_DWORD *)(result + 80);
        if (v16 + v61 >= v60)
          v10 = *(_DWORD *)(result + 76);
        else
          v10 = v16 + v61;
        while (1)
        {
          v62 = __ldaxr(v13);
          if (v62 != v59)
            break;
          if (!__stlxr(v10, v13))
            goto LABEL_51;
        }
        __clrex();
      }
    }
  }
  return result;
}

void CA::OGL::SW::scanline(uint64_t *a1, int a2, int a3, const CA::ColorProgram::Program *a4, float *a5, uint64_t a6, uint64_t a7, const unsigned int *a8, double a9, double a10, double a11, double a12, double a13, unsigned int a14)
{
  uint64_t v15;
  float *v16;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  uint64_t v22;
  BOOL v23;
  unsigned __int8 *v24;
  _BYTE *v25;
  BOOL v26;
  unsigned int *v27;
  int v28;
  char v29;
  BOOL v31;
  uint64_t v34;
  uint64_t v35;
  unsigned int *v36;
  uint64_t v37;
  unsigned __int8 *v38;
  char v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  unsigned int *v44;
  unsigned int *v45;
  unsigned __int8 *v46;
  int v47;
  _BYTE *v48;
  unsigned int *v49;
  float **v50;
  unsigned __int8 *v51;
  _BYTE *v52;
  unsigned int *v53;
  float **v54;
  int v55;
  unsigned int *v56;
  float **v57;
  int v58;
  uint64_t v59;
  unsigned int *v60;
  unsigned int *v61;
  unsigned int v62;
  unint64_t v63;
  unint64_t v64;
  int *v65;
  unsigned int *v66;
  uint64_t v67;
  int v68;
  uint64_t *v69;
  uint64_t *v70;
  size_t v71;
  unsigned int *v72;
  _DWORD *v73;
  unint64_t v74;
  unint64_t v75;
  uint64_t v76;
  int v77;
  unsigned int *v78;
  unsigned int *v79;
  uint64_t v80;
  unsigned int v81;
  unsigned int *v82;
  unsigned int *v83;
  uint64_t v84;
  unsigned __int8 *v85;
  int v86;
  unsigned int *v87;
  uint64_t v88;
  unsigned __int8 *v89;
  unsigned int *v90;
  unsigned int v91;
  unsigned int *v92;
  uint64_t v93;
  unsigned int *v94;
  int v95;
  unsigned int *v96;
  uint64_t v97;
  unsigned __int8 *v98;
  int v99;
  unsigned int *v100;
  unsigned int v101;
  float *v102;
  float *v103;
  unsigned int v104;
  BOOL v105;
  float *v106;
  float *v107;
  unsigned int v108;
  BOOL v109;
  uint64_t v110;
  unsigned int v111;
  float v112;
  float v113;
  float v114;
  float v115;
  signed int v116;
  int32x2_t v117;
  unsigned __int32 *v118;
  unsigned int *v119;
  uint64_t v120;
  unsigned int v121;
  float v122;
  float v123;
  float v124;
  float v125;
  signed int v126;
  int32x2_t v127;
  unsigned int *v128;
  unsigned int *v129;
  unsigned __int8 *v130;
  unsigned int *v131;
  uint64_t v132;
  unsigned int v133;
  unsigned int v134;
  unsigned int v135;
  unsigned int v136;
  unint64_t v137;
  unint64_t v138;
  unsigned int *v139;
  unsigned int *v140;
  int *v141;
  unsigned int *v142;
  uint64_t v143;
  unsigned int v144;
  unsigned int v145;
  unsigned int v146;
  uint64_t v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  unsigned int *v151;
  uint64_t *v152;
  unsigned int v153;
  unsigned int *v154;
  unsigned int *v155;
  unsigned int *v156;
  uint64_t v157;
  uint64_t v158;
  unsigned int v159;
  unsigned int v160;
  unint64_t v161;
  unsigned int *v162;
  unsigned int *v163;
  unsigned int *v164;
  uint64_t v165;
  unsigned int v166;
  unsigned int v167;
  unsigned int v168;
  unsigned int v169;
  int v170;
  unsigned int *v171;
  unsigned int *v172;
  uint64_t v173;
  unsigned __int8 *v174;
  unsigned int v175;
  unint64_t v176;
  unint64_t v177;
  unsigned int *v178;
  unsigned int *v179;
  uint64_t v180;
  int *v181;
  uint64_t v182;
  unsigned int v183;
  int v184;
  unint64_t v185;
  CA::OGL::SW *v186;
  void (*v187)(unsigned int *, unsigned int *, const unsigned int *, const unsigned int *, _QWORD);
  unsigned int *v188;
  uint64_t *v189;
  unsigned int *v190;
  unsigned int *v191;
  uint64_t v192;
  unsigned int v193;
  float v194;
  float v195;
  float v196;
  float v197;
  signed int v198;
  int32x2_t v199;
  float32x2_t v200;
  unsigned int *v201;
  unsigned int *v202;
  uint64_t v203;
  unsigned int v204;
  float v205;
  float v206;
  int8x8_t v207;
  float v208;
  unsigned int v209;
  float v210;
  float32x2_t v211;
  float32x2_t v212;
  char *v213;
  uint64_t v214;
  char *v215;
  unsigned int v216;
  float v217;
  unsigned int *v218;
  unsigned int *v219;
  uint64_t v220;
  unsigned int v221;
  float v222;
  float v223;
  float v224;
  int v225;
  unsigned int *v226;
  unsigned int *v227;
  uint64_t v228;
  unsigned int v229;
  unsigned int v230;
  float v231;
  float v232;
  int v233;
  float v234;
  float v235;
  float v236;
  float32x2_t v237;
  float32x2_t v238;
  float32x2_t v239;
  float v240;
  float v241;
  float v242;
  __int32 *v243;
  unsigned int *v244;
  uint64_t v245;
  float v246;
  unsigned __int8 v247;
  unsigned int v248;
  float v249;
  float v250;
  float v251;
  int8x8_t v252;
  uint32x2_t v253;
  float v254;
  float v255;
  int v256;
  float v257;
  float32x2_t v258;
  uint32x2_t v259;
  int v260;
  unsigned int *v261;
  int *v262;
  uint64_t v263;
  int v264;
  float v265;
  float v266;
  float v267;
  float v268;
  float v269;
  float v270;
  float v271;
  float v272;
  float v273;
  float v274;
  float v275;
  float v276;
  float v277;
  float v278;
  float v279;
  float v280;
  float v281;
  float v282;
  float32x2_t v283;
  float v284;
  float v285;
  float v286;
  int v287;
  uint32x2_t v288;
  char *v289;
  uint64_t v290;
  char *v291;
  unsigned int v292;
  unsigned int v293;
  unsigned int v294;
  unsigned int v295;
  float v296;
  float v297;
  int *v298;
  _DWORD *v299;
  uint64_t v300;
  uint64_t v301;
  uint32x2_t *v302;
  uint64_t *v303;
  uint64_t v304;
  unint64_t v305;
  unint64_t v306;
  unint64_t v307;
  unint64_t v308;
  unint64_t v309;
  unsigned int v310;
  int v311;
  uint32x2_t v312;
  unsigned int v313;
  unsigned int v314;
  int8x8_t v315;
  int v316;
  signed int v317;
  double v318;
  int32x2_t v319;
  uint32x2_t v320;
  unsigned int v321;
  double v322;
  unsigned int v323;
  signed int v324;
  int32x2_t v325;
  unsigned int v326;
  unsigned int v327;
  __int32 v328;
  __int32 v329;
  unsigned int v330;
  __int32 v331;
  double v332;
  int32x2_t v333;
  unsigned int v334;
  unsigned int v335;
  int v336;
  unsigned int v337;
  int v338;
  unsigned int v339;
  unsigned int v340;
  unsigned int v341;
  int32x2_t v342;
  unsigned int v343;
  int v344;
  int v345;
  const unsigned int *v346;
  unsigned __int32 *v347;
  unsigned int v348;
  int v349;
  int v350;
  unsigned int *v351;
  unsigned int *v352;
  unsigned __int8 *v353;
  uint64_t v354;
  unsigned int v355;
  int8x8_t v356;
  uint64_t v357;
  unint64_t v358;
  unsigned int v359;
  int v360;
  int v361;
  unsigned int *v362;
  unsigned int *v363;
  int *v364;
  uint64_t v365;
  unsigned int v366;
  int8x8_t v367;
  uint64_t v368;
  int v369;
  unint64_t v370;
  unsigned int v371;
  unsigned int v372;
  unsigned int *v373;
  unsigned int *v374;
  uint64_t v375;
  unsigned int v376;
  unint64_t v377;
  unsigned int *v378;
  unsigned int *v379;
  uint64_t v380;
  unsigned int v381;
  unint64_t v382;
  unint64_t v383;
  unsigned int *v384;
  unsigned __int8 *v385;
  uint64_t v386;
  unint64_t v387;
  unint64_t v388;
  unsigned int *v389;
  int *v390;
  uint64_t v391;
  int v392;
  unint64_t v393;
  int v394;
  uint64_t v395;
  _BYTE *v396;
  unsigned int *v397;
  float **v398;
  _BYTE v399[1008];
  unsigned __int8 *v400;
  unsigned int *v401;
  float *v402;
  uint64_t v403;
  char *v404;
  char *v405;
  float32x2_t *v406;
  uint64_t v407;
  uint64_t v408;
  int v409;
  int v410;
  uint64_t v411;
  uint64_t v412;
  unsigned __int8 *v413;
  int v414;
  void (*v415)(unsigned int *, const unsigned int *, const unsigned int *, unint64_t, const unsigned int *);
  unsigned int *v416;
  unsigned __int8 *v417;
  int v418;
  float *v419;
  unsigned __int8 *v420;
  _BYTE *v421;
  float *v422;
  uint64_t v423;
  uint64_t v424;
  unsigned int v425;
  unsigned int *v426;
  uint64_t v427;
  unsigned int v428;
  uint64_t __pattern4;
  uint64_t v430;
  void *v431;
  void *v432;
  void *v433;
  void *v434;
  char v435;
  int v436;
  char v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;

  v419 = (float *)a8;
  v15 = a6;
  v16 = a5;
  v439 = *MEMORY[0x1E0C80C00];
  v427 = *a1;
  v19 = *(_QWORD *)v427;
  v20 = *(_QWORD *)(*(_QWORD *)v427 + 1848);
  if (v20)
    v21 = (unsigned int *)(v20
                         + *(_QWORD *)(v19 + 1864) * (a3 - (uint64_t)*(int *)(v19 + 1896))
                         + ((a2 - *(_DWORD *)(v19 + 1888)) * *(_DWORD *)(v19 + 1884)));
  else
    v21 = 0;
  v22 = *(_QWORD *)(v19 + 1856);
  if (v22)
    v23 = v22 == v20;
  else
    v23 = 1;
  if (v23)
    v24 = 0;
  else
    v24 = (unsigned __int8 *)(v22
                            + *(_QWORD *)(v19 + 1872) * (a3 - (uint64_t)*(int *)(v19 + 1896))
                            - *(int *)(v19 + 1888)
                            + a2);
  v425 = a14;
  v25 = *(_BYTE **)(v19 + 16);
  v424 = v19;
  v421 = v25;
  if (v21 && (*(_DWORD *)(v19 + 1880) == 32 ? (v26 = v24 == 0) : (v26 = 0), v26))
  {
    v27 = 0;
  }
  else
  {
    MEMORY[0x1E0C80A78](a1);
    v27 = (unsigned int *)v399;
    bzero(v399, 0x400uLL);
    v25 = v421;
  }
  v28 = *(_DWORD *)(v427 + 292);
  v414 = v28;
  if (v28)
  {
    v29 = v425;
    if ((v28 & 1) != 0)
    {
      v420 = (unsigned __int8 *)(v427 + 8);
      if (*(_BYTE *)(v427 + 312))
        v31 = 0;
      else
        v31 = (v425 & 0xF0) == 0;
      if (v31 && v27 == 0 && v28 == 1)
      {
        v394 = v25[16];
        if (v394 == 1 || v394 == 3 && *((_DWORD *)a1 + 5) == -1)
        {
          v395 = a7;
          v396 = v25;
          CA::OGL::SW::sample_texture(v424, (uint64_t)v420, 0, v425, (uint64_t)v16, v15, v395, (uint64_t)v419, v25[19], a4, (uint64_t)v21);
          v398 = (float **)*((_QWORD *)v396 + 5);
          if (v398)
            CA::OGL::SW::tex_color_match(v398, a4, v21, v397);
          return;
        }
      }
    }
    else
    {
      v420 = 0;
    }
  }
  else
  {
    v420 = 0;
    v29 = v425;
    if (!v27 && !*(_BYTE *)(v427 + 312) && v25[16] != 13)
    {
      if ((v425 & 0xF0) != 0)
        CA::OGL::SW::sample_color(v425, v16, v15, a4, (uint64_t)v21);
      else
        CGBlt_fillBytes();
      return;
    }
  }
  v422 = (float *)a7;
  v34 = v427 + 88 * (v25[17] != 38) + 8;
  v411 = v34;
  if ((v414 & 2) != 0)
    v35 = v34;
  else
    v35 = 0;
  v412 = v35;
  v418 = v29 & 0xF0;
  if ((v29 & 0xF0) != 0)
  {
    MEMORY[0x1E0C80A78](a1);
    bzero(&v400 - 130, 0x40FuLL);
    v36 = (unsigned int *)(((unint64_t)&v400 - 1025) & 0xFFFFFFFFFFFFFFF0);
  }
  else
  {
    v36 = (unsigned int *)a1 + 5;
  }
  v416 = v36;
  v37 = v424;
  if (*(_BYTE *)(v427 + 312))
  {
    MEMORY[0x1E0C80A78](a1);
    v426 = (unsigned int *)v399;
    bzero(v399, 0x400uLL);
  }
  else
  {
    v426 = 0;
  }
  v38 = v420;
  if (v420)
  {
    MEMORY[0x1E0C80A78](a1);
    bzero(&v400 - 130, 0x40FuLL);
    v38 = (unsigned __int8 *)(((unint64_t)&v400 - 1025) & 0xFFFFFFFFFFFFFFF0);
  }
  v417 = v38;
  v39 = v414;
  if ((v414 & 2) != 0)
  {
    MEMORY[0x1E0C80A78](a1);
    bzero(&v400 - 130, 0x40FuLL);
    v39 = v414;
    v413 = (unsigned __int8 *)(((unint64_t)&v400 - 1025) & 0xFFFFFFFFFFFFFFF0);
  }
  else
  {
    v413 = 0;
  }
  v40 = v425;
  if ((int)a4 >= 1)
  {
    v406 = (float32x2_t *)(v37 + 1968);
    v415 = (void (*)(unsigned int *, const unsigned int *, const unsigned int *, unint64_t, const unsigned int *))(v427 + 304);
    v405 = &v435;
    v404 = &v437;
    v41 = (int)a4;
    while (1)
    {
      v423 = v41 - 256;
      if (v41 >= 256)
        v42 = 256;
      else
        v42 = v41;
      if ((int)v41 >= 256)
        v43 = 256;
      else
        v43 = v41;
      if (v27)
        v44 = v27;
      else
        v44 = v21;
      v45 = v426;
      if (!*(_BYTE *)(v427 + 312))
        v45 = v44;
      v426 = v45;
      v46 = v421;
      if (v420)
      {
        if (*(_DWORD *)(v427 + 292) == 1)
        {
          v47 = v421[16];
          if (v47 == 1 || !v418 && v47 == 3 && *v416 == -1)
          {
            v48 = v421;
            CA::OGL::SW::sample_texture(v424, (uint64_t)v420, 0, v40, (uint64_t)v16, v15, (uint64_t)v422, (uint64_t)v419, v421[19], v43, (uint64_t)v426);
            v50 = (float **)*((_QWORD *)v48 + 5);
            if (v50)
              CA::OGL::SW::tex_color_match(v50, (const CA::ColorProgram::Program *)v43, v426, v49);
            goto LABEL_101;
          }
        }
        v51 = v24;
        v52 = v421;
        if (v421[17] == 38)
          memcpy(v417, v21, 4 * v43);
        else
          CA::OGL::SW::sample_texture(v424, (uint64_t)v420, 0, v40, (uint64_t)v16, v15, (uint64_t)v422, (uint64_t)v419, v421[19], v43, (uint64_t)v417);
        v54 = (float **)*((_QWORD *)v52 + 5);
        v40 = v425;
        v46 = v52;
        v24 = v51;
        v39 = v414;
        if (v54)
        {
          CA::OGL::SW::tex_color_match(v54, (const CA::ColorProgram::Program *)v43, (unsigned int *)v417, v53);
          v46 = v421;
          v40 = v425;
        }
      }
      if ((v39 & 2) != 0)
      {
        v55 = v46[20];
        if (v55 != 4)
        {
          if (v46[18] == 38)
            memcpy(v413, v21, 4 * v43);
          else
            CA::OGL::SW::sample_texture(v424, v411, 1u, v40, (uint64_t)v16, v15, (uint64_t)v422, (uint64_t)v419, v55, v43, (uint64_t)v413);
          v46 = v421;
          v57 = (float **)*((_QWORD *)v421 + 6);
          v40 = v425;
          if (v57)
          {
            CA::OGL::SW::tex_color_match(v57, (const CA::ColorProgram::Program *)v43, (unsigned int *)v413, v56);
            v46 = v421;
            v40 = v425;
          }
        }
      }
      v58 = v46[16];
      if (v58 == 13)
      {
        if (!v418)
        {
          v74 = *v416;
          v75 = ((((v74 | (v74 << 24)) & 0xFF00FF00FF00FFLL) + ((v74 | (v74 << 24)) & 0xFF00FF00FF00FFLL) * (v74 >> 24)) >> 8) & 0xFF00FF00FF00FFLL;
          LODWORD(__pattern4) = v74 & 0xFF000000 | ((v75 >> 24) | v75) & 0xFFFFFF;
LABEL_100:
          memset_pattern4(v426, &__pattern4, (4 * v43));
          goto LABEL_101;
        }
        CA::OGL::SW::sample_color(v40, v16, v15, v43, (uint64_t)v416);
        if ((_DWORD)v43)
        {
          v59 = v43;
          v60 = v416;
          v61 = v426;
          do
          {
            v62 = *v60++;
            v63 = (v62 | ((unint64_t)v62 << 24)) & 0xFF00FF00FF00FFLL;
            v64 = ((v63 + v63 * ((unint64_t)v62 >> 24)) >> 8) & 0xFF00FF00FF00FFLL;
            *v61++ = (v64 >> 24) | v64;
            --v59;
          }
          while (v59);
          v65 = (int *)v426;
          v66 = v416;
          v67 = v43;
          do
          {
            v68 = *v65;
            *v65 &= 0xFFFFFFu;
            *v65++ = v68 & 0xFFFFFF | (*((unsigned __int8 *)v66++ + 3) << 24);
            --v67;
          }
          while (v67);
        }
      }
      else
      {
        if (!v46[16])
        {
          if (v418)
          {
            CA::OGL::SW::sample_color(v40, v16, v15, v43, (uint64_t)v426);
            goto LABEL_101;
          }
          LODWORD(__pattern4) = *v416;
          goto LABEL_100;
        }
        if (*(_DWORD *)(v427 + 292))
        {
          if (v418)
          {
            CA::OGL::SW::sample_color(v425, v16, v15, v43, (uint64_t)v416);
            v58 = v421[16];
          }
          v69 = &qword_18474D000;
          v70 = &qword_18474D000;
          switch(v58)
          {
            case 1:
              v71 = 4 * v43;
              v72 = v426;
              v73 = v417;
              goto LABEL_157;
            case 2:
              v110 = 0;
              v73 = v417;
              do
              {
                v111 = v73[v110];
                v112 = (float)HIBYTE(v111);
                v113 = v112 * 0.0039216;
                v115 = 255.0 / v112;
                if (v113 <= 0.001)
                  v115 = 1000.0;
                v114 = (float)v73[v110];
                v116 = (float)(v115 * v114) & ~((int)(float)(v115 * v114) >> 31);
                if (v116 >= 255)
                  v116 = 255;
                v117 = (int32x2_t)vshl_u32((uint32x2_t)vmin_s32(vmax_s32((int32x2_t)vcvt_u32_f32(vmul_n_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v111), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), v115)), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x800000010);
                v73[v110++] = vorr_s8((int8x8_t)v117, (int8x8_t)vdup_lane_s32(v117, 1)).u32[0] | v116 | 0xFF000000;
              }
              while (v42 != (_DWORD)v110);
              v71 = 4 * v43;
              v72 = v426;
LABEL_157:
              memcpy(v72, v73, v71);
              break;
            case 3:
              if (v418)
              {
                v118 = v426;
                v119 = (unsigned int *)v417;
                goto LABEL_168;
              }
              v346 = (const unsigned int *)*v416;
              v347 = v426;
              v119 = (unsigned int *)v417;
              goto LABEL_322;
            case 4:
              v120 = 0;
              v119 = (unsigned int *)v417;
              do
              {
                v121 = v119[v120];
                v122 = (float)HIBYTE(v121);
                v123 = v122 * 0.0039216;
                v125 = 255.0 / v122;
                if (v123 <= 0.001)
                  v125 = 1000.0;
                v124 = (float)v119[v120];
                v126 = (float)(v125 * v124) & ~((int)(float)(v125 * v124) >> 31);
                if (v126 >= 255)
                  v126 = 255;
                v127 = (int32x2_t)vshl_u32((uint32x2_t)vmin_s32(vmax_s32((int32x2_t)vcvt_u32_f32(vmul_n_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v121), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), v125)), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x800000010);
                v119[v120++] = vorr_s8((int8x8_t)v127, (int8x8_t)vdup_lane_s32(v127, 1)).u32[0] | v126 | 0xFF000000;
              }
              while (v42 != (_DWORD)v120);
              if (v418)
              {
                v118 = v426;
LABEL_168:
                CA::OGL::SW::tex_multiply_color(v118, v119, v416, (const unsigned int *)v43);
              }
              else
              {
                v346 = (const unsigned int *)*v416;
                v347 = v426;
LABEL_322:
                CA::OGL::SW::tex_multiply_color(v347, v119, v346, v43);
              }
              break;
            case 5:
              if (v418)
              {
                if ((_DWORD)v43)
                {
                  v128 = v426;
                  v129 = (unsigned int *)v417;
                  v130 = v413;
                  v131 = v416;
                  v132 = v43;
                  do
                  {
                    v134 = *v131++;
                    v133 = v134;
                    v135 = *v129++;
                    HIDWORD(a12) = 255;
                    a9 = COERCE_DOUBLE(vand_s8((int8x8_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v135 >> 8), (int8x8_t)0xFF0000FF00), vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v133), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (int32x2_t)0x100000001)), (int8x8_t)0x1FF0001FF0000));
                    v136 = (((v135 >> 8) & 0xFF0000) + ((v135 >> 8) & 0xFF0000) * HIBYTE(v133)) & 0xFF000000 | ((v135 * v133 + v135) >> 8);
                    v137 = (v136 | LODWORD(a9) | HIDWORD(a9) | ((unint64_t)(v136 | LODWORD(a9) | HIDWORD(a9)) << 24)) & 0xFF00FF00FF00FFLL;
                    v138 = ((v137 + v137 * v130[3]) >> 8) & 0xFF00FF00FF00FFLL;
                    *v128++ = (v138 >> 24) | v138;
                    v130 += 4;
                    --v132;
                  }
                  while (v132);
                }
              }
              else if ((_DWORD)v43)
              {
                v348 = *v416 >> 8;
                v349 = *v416 + 1;
                v350 = (v348 & 0xFF0000) + 0x10000;
                a9 = COERCE_DOUBLE(vadd_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v348), (int8x8_t)0xFF0000FF00), (int32x2_t)0x100000100));
                v351 = v426;
                v352 = (unsigned int *)v417;
                v353 = v413;
                v354 = v43;
                do
                {
                  v355 = *v352++;
                  v356 = vand_s8((int8x8_t)vmul_s32(*(int32x2_t *)&a9, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v355), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)0x1FF0001FF0000);
                  v357 = (v350 * HIBYTE(v355)) & 0xFF000000 | ((v355 * v349) >> 8) | v356.i32[0] | v356.i32[1];
                  v358 = ((((v357 | (v357 << 24)) & 0xFF00FF00FF00FFLL)
                         + ((v357 | (v357 << 24)) & 0xFF00FF00FF00FFLL) * (unint64_t)v353[3]) >> 8) & 0xFF00FF00FF00FFLL;
                  *v351++ = (v358 >> 24) | v358;
                  v353 += 4;
                  --v354;
                }
                while (v354);
              }
              break;
            case 6:
              if (v418)
              {
                if ((_DWORD)v43)
                {
                  v139 = v426;
                  v140 = (unsigned int *)v417;
                  v141 = (int *)v413;
                  v142 = v416;
                  v143 = v43;
                  do
                  {
                    v145 = *v140++;
                    v144 = v145;
                    v146 = *v142++;
                    a9 = COERCE_DOUBLE(vand_s8((int8x8_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v144 >> 8), (int8x8_t)0xFF0000FF00), vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v146), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (int32x2_t)0x100000001)), (int8x8_t)0x1FF0001FF0000));
                    v147 = (((v144 >> 8) & 0xFF0000) + ((v144 >> 8) & 0xFF0000) * HIBYTE(v146)) & 0xFF000000 | ((v144 * v146 + v144) >> 8) | LODWORD(a9) | HIDWORD(a9);
                    v148 = *v141++;
                    v149 = ((((v147 | (v147 << 24)) & 0xFF00FF00FF00FFLL)
                           * (unint64_t)((~v148 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
                    *v139++ = (v149 >> 24) | v149;
                    --v143;
                  }
                  while (v143);
                }
              }
              else if ((_DWORD)v43)
              {
                v359 = *v416 >> 8;
                v360 = *v416 + 1;
                v361 = (v359 & 0xFF0000) + 0x10000;
                a9 = COERCE_DOUBLE(vadd_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v359), (int8x8_t)0xFF0000FF00), (int32x2_t)0x100000100));
                v362 = v426;
                v363 = (unsigned int *)v417;
                v364 = (int *)v413;
                v365 = v43;
                do
                {
                  v366 = *v363++;
                  v367 = vand_s8((int8x8_t)vmul_s32(*(int32x2_t *)&a9, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v366), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)0x1FF0001FF0000);
                  v368 = (v361 * HIBYTE(v366)) & 0xFF000000 | ((v366 * v360) >> 8) | v367.i32[0] | v367.i32[1];
                  v369 = *v364++;
                  v370 = ((((v368 | (v368 << 24)) & 0xFF00FF00FF00FFLL)
                         * (unint64_t)((~v369 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
                  *v362++ = (v370 >> 24) | v370;
                  --v365;
                }
                while (v365);
              }
              break;
            case 7:
              LOBYTE(a9) = *((_BYTE *)v416 + 3);
              v150 = (float)((float)((float)LODWORD(a9) * 1.0039) + 0.5);
              v151 = v426;
              v152 = &v440;
              goto LABEL_182;
            case 8:
              *(float *)&a9 = (float)(*((float *)v421 + 6) * 256.0) + 0.5;
              v150 = *(float *)&a9;
              if (v418)
              {
                v151 = v426;
                v152 = &v441;
LABEL_182:
                CA::OGL::SW::tex_interpolate(v151, (unsigned int *)*(v152 - 32), (unsigned int *)v417, (const unsigned int *)v150, v43);
              }
              else if ((_DWORD)v43)
              {
                v371 = *v416 & 0xFF00FF;
                v372 = (*v416 >> 8) & 0xFF00FF;
                v373 = v426;
                v374 = (unsigned int *)v417;
                v375 = v43;
                do
                {
                  v376 = *v374++;
                  *v373++ = (v371 + ((((v376 & 0xFF00FF) - v371) * v150) >> 8)) & 0xFF00FF | ((v372 << 8) + (((v376 >> 8) & 0xFF00FF) - v372) * v150) & 0xFF00FF00;
                  --v375;
                }
                while (v375);
              }
              break;
            case 9:
              *(float *)&a9 = (float)(*((float *)v421 + 6) * 256.0) + 0.5;
              v153 = *(float *)&a9;
              if (v418)
              {
                if ((_DWORD)v43)
                {
                  v154 = v426;
                  v155 = v416;
                  v156 = (unsigned int *)v417;
                  v157 = v43;
                  do
                  {
                    v159 = *v155++;
                    v158 = v159;
                    v160 = *v156++;
                    v161 = ((((v158 | (v158 << 24)) & 0xFF00FF00FF00FFLL)
                           + ((v158 | (v158 << 24)) & 0xFF00FF00FF00FFLL) * ((unint64_t)v160 >> 24)) >> 8) & 0xFF00FF00FF00FFLL;
                    LODWORD(v161) = (v161 >> 24) | v161;
                    *v154++ = ((v161 & 0xFF00FF) + ((((v160 & 0xFF00FF) - (v161 & 0xFF00FF)) * v153) >> 8)) & 0xFF00FF | ((((v160 >> 8) & 0xFF00FF) - ((v161 >> 8) & 0xFF00FF)) * v153 + (((v161 >> 8) & 0xFF00FF) << 8)) & 0xFF00FF00;
                    --v157;
                  }
                  while (v157);
                }
              }
              else if ((_DWORD)v43)
              {
                v377 = (*v416 | ((unint64_t)*v416 << 24)) & 0xFF00FF00FF00FFLL;
                v378 = v426;
                v379 = (unsigned int *)v417;
                v380 = v43;
                do
                {
                  v381 = *v379++;
                  v382 = ((v377 + v377 * ((unint64_t)v381 >> 24)) >> 8) & 0xFF00FF00FF00FFLL;
                  LODWORD(v382) = (v382 >> 24) | v382;
                  *v378++ = ((v382 & 0xFF00FF) + ((((v381 & 0xFF00FF) - (v382 & 0xFF00FF)) * v153) >> 8)) & 0xFF00FF | ((((v381 >> 8) & 0xFF00FF) - ((v382 >> 8) & 0xFF00FF)) * v153 + (((v382 >> 8) & 0xFF00FF) << 8)) & 0xFF00FF00;
                  --v380;
                }
                while (v380);
              }
              break;
            case 10:
              if ((_DWORD)v43)
              {
                v162 = v426;
                v163 = (unsigned int *)v413;
                v164 = (unsigned int *)v417;
                v165 = v43;
                do
                {
                  v167 = *v163++;
                  v166 = v167;
                  v168 = *v164++;
                  v169 = (v168 & 0xFF00FF) + (v166 & 0xFF00FF);
                  v170 = ((v168 >> 8) & 0xFF00FF) + ((v166 >> 8) & 0xFF00FF);
                  *v162++ = (v170 << 8) & 0xFF00FF00 | v169 & 0xFF00FF | (15 * (v170 & 0x1000100 | (v169 >> 8) & 0x10001)) | (240 * (v170 & 0x1000100 | (v169 >> 8) & 0x10001));
                  --v165;
                }
                while (v165);
              }
              break;
            case 11:
              if (v418)
              {
                v171 = v426;
                v172 = v416;
                v173 = v43;
                v174 = v417;
                do
                {
                  v175 = *v172++;
                  v176 = (v175 | ((unint64_t)v175 << 24)) & 0xFF00FF00FF00FFLL;
                  v177 = ((v176 + v176 * v174[3]) >> 8) & 0xFF00FF00FF00FFLL;
                  *v171++ = (v177 >> 24) | v177;
                  v174 += 4;
                  --v173;
                }
                while (v173);
              }
              else
              {
                v383 = (*v416 | ((unint64_t)*v416 << 24)) & 0xFF00FF00FF00FFLL;
                v384 = v426;
                v385 = v417;
                v386 = v43;
                do
                {
                  v387 = ((v383 + v383 * v385[3]) >> 8) & 0xFF00FF00FF00FFLL;
                  *v384++ = (v387 >> 24) | v387;
                  v385 += 4;
                  --v386;
                }
                while (v386);
              }
              break;
            case 12:
              if (v418)
              {
                v178 = v426;
                v179 = v416;
                v180 = v43;
                v181 = (int *)v417;
                do
                {
                  v183 = *v179++;
                  v182 = v183;
                  v184 = *v181++;
                  v185 = ((((v182 | (v182 << 24)) & 0xFF00FF00FF00FFLL)
                         * (unint64_t)((~v184 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
                  *v178++ = (v185 >> 24) | v185;
                  --v180;
                }
                while (v180);
              }
              else
              {
                v388 = (*v416 | ((unint64_t)*v416 << 24)) & 0xFF00FF00FF00FFLL;
                v389 = v426;
                v390 = (int *)v417;
                v391 = v43;
                do
                {
                  v392 = *v390++;
                  v393 = ((v388 * ((~v392 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
                  *v389++ = (v393 >> 24) | v393;
                  --v391;
                }
                while (v391);
              }
              break;
            case 15:
              if (v27)
                CA::OGL::SW::convert_in(v27, v21, v24, (void *)*(unsigned int *)(v424 + 1880), v43);
              CA::OGL::SW::tex_blend_dest((CA::OGL::SW *)v426, v44, (unsigned int *)v413, (const unsigned int *)v417, (const unsigned int *)v43);
              break;
            case 16:
              if (v27)
                CA::OGL::SW::convert_in(v27, v21, v24, (void *)*(unsigned int *)(v424 + 1880), v43);
              if (v418)
              {
                v186 = (CA::OGL::SW *)v426;
                v187 = *(void (**)(unsigned int *, unsigned int *, const unsigned int *, const unsigned int *, _QWORD))(v427 + 296);
                v188 = v44;
                v189 = &v441;
LABEL_210:
                CA::OGL::SW::tex_blend_image(v186, v188, (const unsigned int *)*(v189 - 32), (const unsigned int *)v417, (const unsigned int *)v43, v187, v415, a8);
              }
              else
              {
                CA::OGL::SW::tex_blend_color((CA::OGL::SW *)v426, v44, (const unsigned int *)*v416, (const unsigned int *)v417, (const unsigned int *)v43, *(void (**)(void *, unsigned int *, void *, const unsigned int *, _QWORD))(v427 + 296), v415, a8);
              }
              break;
            case 17:
              if (v27)
                CA::OGL::SW::convert_in(v27, v21, v24, (void *)*(unsigned int *)(v424 + 1880), v43);
              v186 = (CA::OGL::SW *)v426;
              v187 = *(void (**)(unsigned int *, unsigned int *, const unsigned int *, const unsigned int *, _QWORD))(v427 + 296);
              v188 = v44;
              v189 = &v440;
              goto LABEL_210;
            case 20:
              v190 = v426;
              v191 = (unsigned int *)v417;
              goto LABEL_219;
            case 24:
              v192 = 0;
              v191 = (unsigned int *)v417;
              do
              {
                v193 = v191[v192];
                v194 = (float)HIBYTE(v193);
                v195 = v194 * 0.0039216;
                v197 = 255.0 / v194;
                if (v195 <= 0.001)
                  v197 = 1000.0;
                v196 = (float)v191[v192];
                v198 = (float)(v197 * v196) & ~((int)(float)(v197 * v196) >> 31);
                if (v198 >= 255)
                  v198 = 255;
                v199 = (int32x2_t)vshl_u32((uint32x2_t)vmin_s32(vmax_s32((int32x2_t)vcvt_u32_f32(vmul_n_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v193), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), v197)), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x800000010);
                v191[v192++] = vorr_s8((int8x8_t)v199, (int8x8_t)vdup_lane_s32(v199, 1)).u32[0] | v198 | 0xFF000000;
              }
              while (v42 != (_DWORD)v192);
              v190 = v426;
LABEL_219:
              CA::OGL::SW::tex_color_matrix_4x4_bias(v190, v191, (const unsigned int *)v43, v406, a5);
              break;
            case 25:
              if ((_DWORD)v43)
              {
                LODWORD(a9) = *((_DWORD *)v421 + 6);
                v200 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a9, 0);
                v201 = v426;
                v202 = (unsigned int *)v417;
                v203 = v43;
                do
                {
                  v204 = *v202;
                  if (*v202 + 1 >= 0x1000001)
                  {
                    v205 = (float)HIBYTE(v204);
                    *(float *)&a12 = v205 * 0.0039216;
                    v206 = 1.0 / v205;
                    v207 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v204), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
                    v208 = (float)(1.0 / v205) * (float)*v202;
                    v209 = (float)(v205 + 0.5);
                    v210 = *(float *)&a12 + (float)((float)(*(float *)&a12 - v208) * *(float *)&a9);
                    v211 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a12, 0);
                    a13 = COERCE_DOUBLE(vmul_n_f32(vcvt_f32_u32((uint32x2_t)vand_s8(v207, (int8x8_t)0xFF000000FFLL)), v206));
                    v212 = vdiv_f32(vmul_f32(*(float32x2_t *)&a13, (float32x2_t)vdup_n_s32(0x437F0000u)), vmla_f32(v211, v200, vsub_f32(v211, *(float32x2_t *)&a13)));
                    HIDWORD(a13) = 1056964608;
                    a12 = COERCE_DOUBLE(vshl_u32(vcvt_u32_f32(vadd_f32(v212, (float32x2_t)0x3F0000003F000000)), (uint32x2_t)0x800000010));
                    v204 = (float)((float)((float)(v208 * 255.0) / v210) + 0.5) | (v209 << 24) | LODWORD(a12) | HIDWORD(a12);
                  }
                  *v201++ = v204;
                  ++v202;
                  --v203;
                }
                while (v203);
              }
              break;
            case 47:
              if (v27)
                CA::OGL::SW::convert_in(v27, v21, v24, (void *)*(unsigned int *)(v424 + 1880), v43);
              CA::OGL::SW::tex_vibrant_color_matrix((CA::OGL::SW *)v426, v44, (unsigned int *)v417, (const unsigned int *)v43, v406, (const float *)a6);
              break;
            case 48:
              if (v27)
                CA::OGL::SW::convert_in(v27, v21, v24, (void *)*(unsigned int *)(v424 + 1880), v43);
              CA::OGL::SW::tex_vibrant_dark((CA::OGL::SW *)v426, v44, (unsigned int *)v417, (const unsigned int *)v43, (float *)v406, (const float *)a6);
              break;
            case 49:
              if (v27)
                CA::OGL::SW::convert_in(v27, v21, v24, (void *)*(unsigned int *)(v424 + 1880), v43);
              CA::OGL::SW::tex_vibrant_light((CA::OGL::SW *)v426, v44, (unsigned int *)v417, (const unsigned int *)v43, (float *)v406, (const float *)a6);
              break;
            case 50:
              v400 = v24;
              v401 = v21;
              v402 = v16;
              v403 = v15;
              LODWORD(a9) = *((_DWORD *)v421 + 6);
              v213 = v405;
              *((_QWORD *)v405 + 6) = 0;
              *((_OWORD *)v213 + 1) = 0u;
              *((_OWORD *)v213 + 2) = 0u;
              *(_OWORD *)v213 = 0u;
              v214 = v412;
              __pattern4 = v412;
              v430 = 0;
              v431 = &CA::OGL::SW::tex_luminance_map(unsigned int *,unsigned int const*,CA::OGL::SW::Texture const*,unsigned long,unsigned int)::dummy;
              v432 = &CA::OGL::SW::tex_luminance_map(unsigned int *,unsigned int const*,CA::OGL::SW::Texture const*,unsigned long,unsigned int)::dummy;
              v433 = &CA::OGL::SW::tex_luminance_map(unsigned int *,unsigned int const*,CA::OGL::SW::Texture const*,unsigned long,unsigned int)::dummy;
              v434 = &CA::OGL::SW::tex_luminance_map(unsigned int *,unsigned int const*,CA::OGL::SW::Texture const*,unsigned long,unsigned int)::dummy;
              v438 = 0;
              v215 = v404;
              *(_QWORD *)v404 = 0;
              *((_DWORD *)v215 + 2) = 0;
              if ((_DWORD)v43)
              {
                v216 = (float)((float)(*(float *)&a9 * 256.0) + 0.5);
                v217 = (float)*(unsigned int *)(v214 + 24) * 0.0039216;
                v218 = v426;
                v219 = (unsigned int *)v417;
                v220 = v43;
                do
                {
                  v221 = *v219++;
                  v436 = (int)(float)(v217
                                    * (float)(4725 * v221
                                            + 46884 * BYTE1(v221)
                                            + 13926 * BYTE2(v221)));
                  (*(void (**)(uint64_t *, uint64_t, unsigned int *, uint64_t))(*(_QWORD *)(v214 + 48) + 80))(&__pattern4, 1, v218, 10);
                  v214 = v412;
                  *v218 = ((v221 & 0xFF00FF) + ((((*v218 & 0xFF00FF) - (v221 & 0xFF00FF)) * v216) >> 8)) & 0xFF00FF | ((((*v218 >> 8) & 0xFF00FF) - ((v221 >> 8) & 0xFF00FF)) * v216 + (((v221 >> 8) & 0xFF00FF) << 8)) & 0xFF00FF00;
                  ++v218;
                  --v220;
                }
                while (v220);
              }
              v15 = v403;
              v16 = v402;
              v21 = v401;
              v24 = v400;
              v39 = v414;
              break;
            case 51:
              if ((_DWORD)v43)
              {
                LODWORD(a9) = *((_DWORD *)v421 + 6);
                v222 = *((float *)v421 + 7);
                v223 = *((float *)v421 + 8);
                v224 = *((float *)v421 + 9);
                v225 = *(unsigned __int8 *)v416 + 1;
                v226 = v426;
                v227 = (unsigned int *)v417;
                v228 = v43;
                do
                {
                  v230 = *v227++;
                  v229 = v230;
                  v231 = (float)((float)((float)v230 * 0.00028275)
                               + (float)((float)BYTE1(v230) * 0.0028055))
                       + (float)((float)BYTE2(v230) * 0.00083333);
                  v232 = (float)(v224
                               + (float)((float)(v223 + (float)((float)(v222 + (float)(v231 * *(float *)&a9)) * v231))
                                       * v231))
                       * 255.0;
                  v233 = (int)v232 & ~((int)v232 >> 31);
                  if (v233 >= 255)
                    v233 = 255;
                  *v226++ = ((v229 & 0xFF00FF) + (((v233 - (v229 & 0xFF00FF) + (v233 << 16)) * v225) >> 8)) & 0xFF00FF | ((v233 - ((v229 >> 8) & 0xFF00FF) + 16711680) * v225 + (((v229 >> 8) & 0xFF00FF) << 8)) & 0xFF00FF00;
                  --v228;
                }
                while (v228);
              }
              break;
            case 52:
              if ((_DWORD)v43)
              {
                LODWORD(a9) = *(_DWORD *)(v424 + 1980);
                v234 = *(float *)(v424 + 1996);
                v235 = *(float *)(v424 + 2012);
                v236 = *(float *)(v424 + 2028);
                a13 = *(double *)(v424 + 1968);
                v237 = *(float32x2_t *)(v424 + 1984);
                v238 = *(float32x2_t *)(v424 + 2000);
                v239 = *(float32x2_t *)(v424 + 2016);
                v240 = *(float *)(v424 + 1976);
                v241 = *(float *)(v424 + 1992);
                v242 = *(float *)(v424 + 2008);
                v243 = (__int32 *)v426;
                v244 = (unsigned int *)v417;
                v245 = v43;
                v246 = *(float *)(v424 + 2024);
                do
                {
                  v248 = *v244++;
                  v247 = v248;
                  v249 = (float)HIBYTE(v248);
                  v250 = v249 * 0.0039216;
                  v251 = 1.0 / v249;
                  v252 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v248), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
                  if (v250 <= 0.005)
                    v251 = 0.78431;
                  v253 = (uint32x2_t)vand_s8(v252, (int8x8_t)0xFF000000FFLL);
                  v254 = v251 * (float)v247;
                  v255 = (float)(v236
                               + (float)((float)(v235 + (float)((float)(v234 + (float)(v250 * *(float *)&a9)) * v250))
                                       * v250))
                       * 255.0;
                  v256 = (int)v255 & ~((int)v255 >> 31);
                  if (v256 >= 255)
                    v256 = 255;
                  v257 = v246 + (float)((float)(v242 + (float)((float)(v241 + (float)(v240 * v254)) * v254)) * v254);
                  v258 = vmul_n_f32(vcvt_f32_u32(v253), v251);
                  v259 = vshl_u32((uint32x2_t)vmin_s32(vmax_s32(vcvt_s32_f32(vmla_n_f32((float32x2_t)0x3F0000003F000000, vmla_f32(v239, v258, vmla_f32(v238, v258, vmla_f32(v237, v258, *(float32x2_t *)&a13))), (float)v256)), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x800000010);
                  if (((int)(float)((float)(v257 * (float)v256) + 0.5) & ~((int)(float)((float)(v257 * (float)v256)
                                                                                       + 0.5) >> 31)) >= 255)
                    v260 = 255;
                  else
                    v260 = (int)(float)((float)(v257 * (float)v256) + 0.5) & ~((int)(float)((float)(v257 * (float)v256)
                                                                                          + 0.5) >> 31);
                  *v243++ = v260 | v259.i32[0] | (v256 << 24) | v259.i32[1];
                  --v245;
                }
                while (v245);
              }
              break;
            case 53:
              if ((_DWORD)v43)
              {
                LODWORD(a9) = *((_DWORD *)v421 + 6);
                v261 = v426;
                v262 = (int *)v417;
                v263 = v43;
                do
                {
                  v264 = *v262;
                  v265 = (float)HIBYTE(*v262);
                  v266 = 1.0 / v265;
                  if (!HIBYTE(*v262))
                    v266 = 200.0;
                  v267 = v266 * (float)BYTE2(v264);
                  v268 = v266 * (float)BYTE1(v264);
                  v269 = v266 * (float)*v262;
                  if (v268 <= v269)
                    v270 = v266 * (float)*v262;
                  else
                    v270 = v266 * (float)BYTE1(v264);
                  if (v268 >= v269)
                    v271 = v269;
                  else
                    v271 = v268;
                  if (v267 > v270)
                    v270 = v267;
                  if (v267 < v271)
                    v271 = v267;
                  v272 = v270 - v271;
                  v273 = 0.16667 / v272;
                  if (v272 <= 0.005)
                    v273 = 33.333;
                  if (v267 == v270)
                  {
                    v274 = v273 * (float)(v268 - v269);
                  }
                  else
                  {
                    if (v268 == v270)
                    {
                      v275 = v269 - v267;
                      v276 = 0.33333;
                    }
                    else
                    {
                      v275 = v267 - v268;
                      v276 = 0.66667;
                    }
                    v274 = v276 + (float)(v273 * v275);
                  }
                  v277 = v274 + *(float *)&a9;
                  v278 = (float)(fabsf(fminf((float)(v274 + *(float *)&a9) - floorf(v274 + *(float *)&a9), 1.0) + -0.5)
                               * 6.0)
                       + -1.0;
                  v279 = 1.0;
                  v280 = 0.0;
                  if (v278 >= 0.0)
                    v280 = v278;
                  if (v278 <= 1.0)
                    v281 = v280;
                  else
                    v281 = 1.0;
                  v282 = (float)(fabsf(fminf((float)(v277 + -0.33333) - floorf(v277 + -0.33333), 1.0) + -0.5) * 6.0)
                       + -1.0;
                  v283.i32[0] = 1.0;
                  if (v282 <= 1.0)
                  {
                    v283.i32[0] = 0;
                    if (v282 >= 0.0)
                      v283.f32[0] = v282;
                  }
                  v284 = (float)(fabsf(fminf((float)(v277 + -0.66667) - floorf(v277 + -0.66667), 1.0) + -0.5) * 6.0)
                       + -1.0;
                  if (v284 <= 1.0)
                  {
                    v279 = 0.0;
                    if (v284 >= 0.0)
                      v279 = v284;
                  }
                  v285 = v272 / fmaxf(v270, 0.005);
                  v283.f32[1] = v281;
                  v286 = v270 * v265;
                  v287 = (int)(float)(v286 * (float)((float)(1.0 - v285) + (float)(v279 * v285))) & ~((int)(float)(v286 * (float)((float)(1.0 - v285) + (float)(v279 * v285))) >> 31);
                  if (v287 >= 255)
                    v287 = 255;
                  *(float *)&a13 = 1.0 - v285;
                  v288 = vshl_u32((uint32x2_t)vmin_s32(vmax_s32(vcvt_s32_f32(vmul_n_f32(vmla_n_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a13, 0), v283, v285), v286)), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x1000000008);
                  *v261++ = v287 | v288.i32[0] | v264 & 0xFF000000 | v288.i32[1];
                  ++v262;
                  --v263;
                }
                while (v263);
              }
              break;
            case 55:
              v402 = v16;
              v403 = v15;
              v400 = v24;
              v401 = v21;
              v289 = v405;
              *((_QWORD *)v405 + 6) = 0;
              BYTE1(a9) = 0;
              BYTE2(a9) = 0;
              BYTE3(a9) = 0;
              BYTE4(a9) = 0;
              BYTE5(a9) = 0;
              BYTE6(a9) = 0;
              HIBYTE(a9) = 0;
              *((_OWORD *)v289 + 1) = 0u;
              *((_OWORD *)v289 + 2) = 0u;
              *(_OWORD *)v289 = 0u;
              v290 = v412;
              __pattern4 = v412;
              v430 = 0;
              v431 = &CA::OGL::SW::tex_home_affordance_map(unsigned int *,unsigned int const*,CA::OGL::SW::Texture const*,unsigned long,float const*)::dummy;
              v432 = &CA::OGL::SW::tex_home_affordance_map(unsigned int *,unsigned int const*,CA::OGL::SW::Texture const*,unsigned long,float const*)::dummy;
              v433 = &CA::OGL::SW::tex_home_affordance_map(unsigned int *,unsigned int const*,CA::OGL::SW::Texture const*,unsigned long,float const*)::dummy;
              v434 = &CA::OGL::SW::tex_home_affordance_map(unsigned int *,unsigned int const*,CA::OGL::SW::Texture const*,unsigned long,float const*)::dummy;
              v438 = 0;
              v291 = v404;
              *(_QWORD *)v404 = 0;
              *((_DWORD *)v291 + 2) = 0;
              if ((_DWORD)v43)
              {
                v292 = (float)((float)(*(float *)(v424 + 2000) * 256.0) + 0.5);
                v293 = (float)((float)(*(float *)(v424 + 1984) * 256.0) + 0.5);
                v294 = ((float)((float)(*(float *)(v424 + 1972) * 255.0) + 0.5) << 8) | ((float)((float)(*(float *)(v424 + 1968) * 255.0) + 0.5) << 16) | (float)((float)(*(float *)(v424 + 1976) * 255.0) + 0.5);
                v295 = v294 | ((float)((float)(*(float *)(v424 + 1980) * 255.0) + 0.5) << 24);
                v296 = (float)*(unsigned int *)(v290 + 24);
                v410 = v294 & 0xFF00FF;
                v409 = (v295 >> 8) & 0xFF00FF;
                v408 = v293 + 1;
                v297 = v296 * 0.0039216;
                v407 = v292 + 1;
                v298 = (int *)v426;
                v299 = v417;
                v300 = v43;
                do
                {
                  v428 = 0;
                  v301 = *v299;
                  v436 = (int)(float)(v297
                                    * (float)(4725 * *v299
                                            + 46884 * BYTE1(v301)
                                            + 13926 * BYTE2(v301)));
                  v302 = (uint32x2_t *)v70;
                  v303 = v69;
                  (*(void (**)(uint64_t *, uint64_t, unsigned int *, uint64_t))(*(_QWORD *)(v290 + 48) + 80))(&__pattern4, 1, &v428, 10);
                  v69 = v303;
                  v304 = ((((v428 >> 8) & 0xFF00FF) + v409) << 8) & 0xFF00FF00 | ((v428 & 0xFF00FF) + v410) & 0xFF00FF | (15 * ((((v428 >> 8) & 0xFF00FF) + v409) & 0x1000100 | (((v428 & 0xFF00FF) + v410) >> 8) & 0x10001)) | (240 * ((((v428 >> 8) & 0xFF00FF) + v409) & 0x1000100 | (((v428 & 0xFF00FF) + v410) >> 8) & 0x10001));
                  v305 = ((((v304 | (v304 << 24)) & 0xFF00FF00FF00FFuLL) * v408) >> 8) & 0xFF00FF00FF00FFLL;
                  v306 = (((v301 | (v301 << 24)) & 0xFF00FF00FF00FFLL)
                        * (unint64_t)((~(v305 >> 24) >> 24) + 1)) >> 8;
                  v307 = (((v306 & 0xFF00FF00FF00FFLL) >> 24) | v306 & 0xFF00FF)
                       + ((v305 >> 24) | v305);
                  v308 = ((((v307 | (v307 << 24)) & 0xFF00FF00FF00FFLL) * v407) >> 8) & 0xFF00FF00FF00FFLL;
                  v309 = v308 >> 24;
                  v310 = (v308 >> 24) | v308;
                  v311 = BYTE3(v309);
                  v312 = (uint32x2_t)v303[157];
                  v313 = BYTE3(v307);
                  a12 = COERCE_DOUBLE(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v307), v312), (int8x8_t)0xFF000000FFLL));
                  v314 = v307;
                  v315 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v310), v312);
                  v316 = v311 + 1;
                  v317 = (BYTE3(v307) * (v311 + 1)) >> 8;
                  v318 = 0.0;
                  v319 = (int32x2_t)vand_s8(v315, (int8x8_t)0xFF000000FFLL);
                  v320 = (uint32x2_t)vmul_s32(vdup_n_s32(BYTE3(v307) ^ 0xFF), vadd_s32(v319, (int32x2_t)0x100000001));
                  v321 = ((v313 ^ 0xFF) + (v313 ^ 0xFF) * v310) >> 8;
                  if (BYTE3(v307) == 255)
                    v321 = 0;
                  v322 = COERCE_DOUBLE(vshr_n_u32(v320, 8uLL));
                  if (v313 != 255)
                    v317 += ((BYTE3(v307) ^ 0xFF) * (v311 + 1)) >> 8;
                  v323 = v311 ^ 0xFF;
                  v324 = v317 + ((v323 + v323 * v313) >> 8);
                  v325 = vadd_s32(*(int32x2_t *)&a12, (int32x2_t)0x100000001);
                  if (v313 != 255)
                    v318 = v322;
                  a13 = COERCE_DOUBLE(vdup_n_s32(v323));
                  v326 = v321 + ((v323 + v323 * v307) >> 8);
                  v327 = v313 + 1;
                  if (v311 != 255)
                    v321 = v326;
                  v328 = v319.i32[0];
                  v329 = v319.i32[1];
                  a6 = v327 * v319.i32[0];
                  if (v311 != 255)
                    v317 = v324;
                  v330 = (a6 >> 8) + ((LODWORD(a12) * (v316 - v319.i32[0])) >> 8);
                  a5 = (float *)((v327 * v319.i32[1]) >> 8);
                  v331 = (_DWORD)a5 + ((HIDWORD(a12) * (v316 - v319.i32[1])) >> 8);
                  v332 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v318, (uint32x2_t)vmul_s32(v325, *(int32x2_t *)&a13), 8uLL));
                  if (v311 == 255)
                    *(double *)&v333 = v318;
                  else
                    *(double *)&v333 = v332;
                  v334 = v307 >> 25;
                  v335 = v327 * v311;
                  v336 = 2 * v330 - (v335 >> 8);
                  v337 = ((LODWORD(a12) + LODWORD(a12) * v328) >> 7) & 0x3FE;
                  v338 = 2 * v331 - (v335 >> 8);
                  if (v334 < LODWORD(a12))
                    v337 = v336;
                  v70 = (uint64_t *)v302;
                  v339 = 2
                       * (((v327 * v310) >> 8) + ((int)(v314 * (v316 - v310)) >> 8))
                       - (v335 >> 8);
                  if (v334 >= HIDWORD(a12))
                    v340 = ((HIDWORD(a12) + HIDWORD(a12) * v329) >> 7) & 0x3FE;
                  else
                    v340 = v338;
                  v341 = ((v314 + v314 * v310) >> 7) & 0x3FE;
                  v342.i32[0] = v337;
                  if (v334 >= v314)
                    v343 = v341;
                  else
                    v343 = v339;
                  v342.i32[1] = v340;
                  v344 = v343 + v321;
                  if (v344 >= v317)
                    v344 = v317;
                  a9 = COERCE_DOUBLE(vshl_u32((uint32x2_t)vmax_s32(vmin_s32(vadd_s32(v342, v333), vdup_n_s32(v317)), 0), v302[14]));
                  v345 = LODWORD(a9) | (v317 << 24);
                  v290 = v412;
                  *v298++ = v345 | v344 & ~(v344 >> 31) | HIDWORD(a9);
                  ++v299;
                  --v300;
                }
                while (v300);
              }
              v21 = v401;
              v24 = v400;
              v39 = v414;
              v15 = v403;
              v16 = v402;
              break;
            default:
              break;
          }
        }
      }
LABEL_101:
      v76 = v424;
      if (*(_BYTE *)(v427 + 312))
      {
        if (v27)
          CA::OGL::SW::convert_in(v27, v21, v24, (void *)*(unsigned int *)(v424 + 1880), v43);
        (*(void (**)(unsigned int *, unsigned int *, unsigned int *, uint64_t, _QWORD))(v427 + 296))(v44, v44, v426, v43, v415);
      }
      v40 = v425;
      if (v27)
      {
        v77 = *(_DWORD *)(v76 + 1880);
        if (v77 <= 14)
        {
          if (v77)
          {
            if (v77 == 8)
            {
              v82 = v27;
              v83 = v21;
              v84 = v43;
              if (v24)
              {
                v85 = v24;
                if ((_DWORD)v43)
                {
                  do
                  {
                    *v85++ = *((_BYTE *)v82 + 3);
                    v86 = *v82++;
                    *(_BYTE *)v83 = (unsigned __int16)(21 * v86 + 173 * BYTE1(v86) + 62 * BYTE2(v86)) >> 8;
                    v83 = (unsigned int *)((char *)v83 + 1);
                    --v84;
                  }
                  while (v84);
                }
              }
              else if ((_DWORD)v43)
              {
                do
                {
                  v99 = *v82++;
                  *(_BYTE *)v83 = (unsigned __int16)(21 * v99 + 173 * BYTE1(v99) + 62 * BYTE2(v99)) >> 8;
                  v83 = (unsigned int *)((char *)v83 + 1);
                  --v84;
                }
                while (v84);
              }
            }
          }
          else if ((_DWORD)v43)
          {
            v96 = v27;
            v97 = v43;
            v98 = v24;
            do
            {
              *v98++ = *((_BYTE *)v96++ + 3);
              --v97;
            }
            while (v97);
          }
        }
        else
        {
          switch(v77)
          {
            case 15:
              v87 = v27;
              v88 = v43;
              if (v24)
              {
                v89 = v24;
                v90 = v21;
                if ((_DWORD)v43)
                {
                  do
                  {
                    *v89++ = *((_BYTE *)v87 + 3);
                    v91 = *v87++;
                    *(_WORD *)v90 = (v91 >> 6) & 0x3E0 | (v91 >> 3) | (v91 >> 9) & 0x7C00;
                    v90 = (unsigned int *)((char *)v90 + 2);
                    --v88;
                  }
                  while (v88);
                }
              }
              else
              {
                v100 = v21;
                if ((_DWORD)v43)
                {
                  do
                  {
                    v101 = *v87++;
                    *(_WORD *)v100 = (v101 >> 6) & 0x3E0 | (v101 >> 3) | (v101 >> 9) & 0x7C00;
                    v100 = (unsigned int *)((char *)v100 + 2);
                    --v88;
                  }
                  while (v88);
                }
              }
              break;
            case 16:
              v92 = v27;
              v93 = v43;
              v94 = v21;
              if ((_DWORD)v43)
              {
                do
                {
                  v95 = *v92++;
                  *(_WORD *)v94 = HIWORD(v95) & 0xFF00 | ((21 * v95
                                                         + 173 * BYTE1(v95)
                                                         + 62 * BYTE2(v95)) >> 8);
                  v94 = (unsigned int *)((char *)v94 + 2);
                  --v93;
                }
                while (v93);
              }
              break;
            case 32:
              v78 = v27;
              v79 = v21;
              v80 = v43;
              if ((_DWORD)v43)
              {
                do
                {
                  v81 = *v78++;
                  *v79++ = v81;
                  --v80;
                }
                while (v80);
              }
              break;
          }
        }
      }
      if ((int)v41 < 257)
        return;
      v21 = (unsigned int *)((char *)v21 + (*(_DWORD *)(v76 + 1884) * v43));
      if (v24)
        v24 += v43;
      else
        v24 = 0;
      v41 = v423;
      if ((_DWORD)v40)
      {
        *(float *)&a9 = (float)(int)v43;
        v102 = (float *)v15;
        v103 = v16;
        v104 = v40;
        do
        {
          if ((v104 & 1) != 0)
            *v103 = *v103 + (float)(*v102 * *(float *)&a9);
          ++v103;
          ++v102;
          v105 = v104 > 1;
          v104 >>= 1;
        }
        while (v105);
        if (v422)
        {
          v106 = v419;
          v107 = v422;
          v108 = v40;
          do
          {
            if ((v108 & 1) != 0)
              *v107 = *v107 + (float)(*v106 * *(float *)&a9);
            ++v107;
            ++v106;
            v109 = v108 >= 2;
            v108 >>= 1;
          }
          while (v109);
        }
      }
    }
  }
}

uint64_t CA::OGL::SW::sample_color(uint64_t result, float *a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  int32x2_t v5;
  int32x4_t v6;
  unsigned int v7;
  signed int v8;
  signed int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  uint64x2_t v16;
  _DWORD *v17;
  unsigned int v18;
  int32x2_t v19;
  unint64_t v20;
  uint64x2_t v21;
  const float *v22;
  int32x4_t v23;
  int32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  int32x4_t v28;
  int32x4_t v29;
  int32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t v39;
  int8x16_t v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int8x16_t v45;
  int32x2_t v46;
  int64x2_t v47;

  v7 = (int)(float)(a2[4] * 16712000.0);
  v8 = (int)(float)(a2[5] * 16712000.0);
  v9 = (int)(float)(a2[6] * 16712000.0);
  v10 = (int)(float)(a2[7] * 16712000.0);
  v11 = (int)(float)(*(float *)(a3 + 16) * 16712000.0);
  v12 = (int)(float)(*(float *)(a3 + 20) * 16712000.0);
  v13 = (int)(float)(*(float *)(a3 + 24) * 16712000.0);
  v14 = (int)(float)(*(float *)(a3 + 28) * 16712000.0);
  if ((result & 4) != 0)
  {
    if (a4)
    {
      v20 = 0;
      v21 = (uint64x2_t)vdupq_n_s64((unint64_t)a4 - 1);
      v5.i32[0] = *(_DWORD *)(a3 + 12);
      v22 = a2 + 3;
      v23 = vmlaq_s32(vdupq_n_s32(v10), vdupq_n_s32(v14), (int32x4_t)xmmword_18474E1B0);
      v24 = vdupq_n_s32(4 * v14);
      v25 = vmlaq_s32(vdupq_n_s32(v9), vdupq_n_s32(v13), (int32x4_t)xmmword_18474E1B0);
      v26 = vdupq_n_s32(4 * v13);
      v27 = vmlaq_s32(vdupq_n_s32(v8), vdupq_n_s32(v12), (int32x4_t)xmmword_18474E1B0);
      v28 = vdupq_n_s32(4 * v12);
      v29 = vmlaq_s32(vdupq_n_s32(v7), vdupq_n_s32(v11), (int32x4_t)xmmword_18474E1B0);
      v30 = vdupq_n_s32(4 * v11);
      v31 = vld1q_dup_f32(v22);
      v32 = vmlaq_n_f32(v31, (float32x4_t)xmmword_18474E430, *(float *)v5.i32);
      *(float *)v5.i32 = *(float *)v5.i32 * 4.0;
      v33 = (float32x4_t)vdupq_lane_s32(v5, 0);
      __asm { FMOV            V19.4S, #1.0 }
      v39.i64[0] = 0xFF000000FF000000;
      v39.i64[1] = 0xFF000000FF000000;
      v40.i64[0] = 0xFFFF0000FFFF0000;
      v40.i64[1] = 0xFFFF0000FFFF0000;
      do
      {
        v41 = (int8x16_t)vdupq_n_s64(v20);
        *(int32x2_t *)v6.i8 = vmovn_s64((int64x2_t)vcgeq_u64(v21, (uint64x2_t)vorrq_s8(v41, (int8x16_t)xmmword_18474E1C0)));
        v42 = vdivq_f32(_Q19, v32);
        v43 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v42, _Q19), (int8x16_t)_Q19, (int8x16_t)v42);
        v44 = (float32x4_t)vbicq_s8((int8x16_t)v43, (int8x16_t)vcltzq_f32(v43));
        v45 = vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vshrq_n_s32(vcvtq_s32_f32(vmulq_f32(v44, vcvtq_f32_s32(v25))), 0x10uLL), vandq_s8((int8x16_t)vcvtq_s32_f32(vmulq_f32(v44, vcvtq_f32_s32(v29))), v40)), vandq_s8((int8x16_t)vshlq_n_s32(vcvtq_s32_f32(vmulq_f32(v44, vcvtq_f32_s32(v23))), 8uLL), v39)), (int8x16_t)(*(_OWORD *)&vshrq_n_s32(vcvtq_s32_f32(vmulq_f32(v44, vcvtq_f32_s32(v27))), 8uLL) & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00)));
        if ((vmovn_s32(v6).u8[0] & 1) != 0)
          *(_DWORD *)(a5 + 4 * v20) = v45.i32[0];
        v46 = (int32x2_t)vmovn_s32(v6);
        if ((v46.i8[2] & 1) != 0)
          *(_DWORD *)(a5 + 4 * v20 + 4) = v45.i32[1];
        v47 = (int64x2_t)vcgeq_u64(v21, (uint64x2_t)vorrq_s8(v41, (int8x16_t)xmmword_18474E440));
        v6 = vmovn_hight_s64(v46, v47);
        if ((vmovn_s32(v6).i32[1] & 1) != 0)
          *(_DWORD *)(a5 + 4 * v20 + 8) = v45.i32[2];
        if ((vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v47, v47)).i8[6] & 1) != 0)
          *(_DWORD *)(a5 + 4 * v20 + 12) = v45.i32[3];
        v20 += 4;
        v23 = vaddq_s32(v23, v24);
        v25 = vaddq_s32(v25, v26);
        v27 = vaddq_s32(v27, v28);
        v29 = vaddq_s32(v29, v30);
        v32 = vaddq_f32(v32, v33);
      }
      while (((a4 + 3) & 0x1FFFFFFFCLL) != v20);
    }
  }
  else if (a4)
  {
    v15 = 0;
    v16 = (uint64x2_t)vdupq_n_s64((unint64_t)a4 - 1);
    v17 = (_DWORD *)(a5 + 4);
    result = v14 << 8;
    v18 = v10 << 8;
    do
    {
      v19 = vmovn_s64((int64x2_t)vcgeq_u64(v16, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v15), (int8x16_t)xmmword_18474E1C0)));
      if ((v19.i8[0] & 1) != 0)
        *(v17 - 1) = v7 & 0xFFFF0000 | (v8 >> 16 << 8) | (v9 >> 16) | v18 & 0xFF000000;
      if ((v19.i8[4] & 1) != 0)
        *v17 = (v11 + v7) & 0xFFFF0000 | ((int)(v12 + v8) >> 16 << 8) | ((int)(v13 + v9) >> 16) | (result + v18) & 0xFF000000;
      v15 += 2;
      v7 += 2 * v11;
      v17 += 2;
      v18 += v14 << 9;
      v9 += 2 * v13;
      v8 += 2 * v12;
    }
    while (((a4 + 1) & 0x1FFFFFFFELL) != v15);
  }
  return result;
}

uint64_t CA::OGL::SW::sample_texture(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9, unsigned int a10, uint64_t a11)
{
  __n128 v13;
  __n128 *v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  float v18;
  float v19;
  int v20;
  float *v21;
  float *v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  uint64_t v28;
  uint64_t v29;
  float v30;
  uint64_t v31;
  float v32;
  float v33;
  uint64_t v34;
  uint64_t v35;
  float v36;
  unsigned int v37;
  unsigned int v38;
  int v39;
  int v40;
  _BOOL4 v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  signed int v49;
  unsigned int v50;
  signed int v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  unint64_t v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  uint64_t result;
  uint64_t v64;
  unsigned int v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  __int128 v71;
  __int128 v72;
  _BYTE v73[24];
  __n128 *v74;
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  v13.n128_u32[1] = 0;
  v13.n128_u64[1] = 0;
  memset(v73, 0, sizeof(v73));
  v71 = 0u;
  v72 = 0u;
  v64 = a2;
  v65 = a3;
  v66 = a4;
  v67 = a5;
  v68 = a6;
  v69 = a7;
  v70 = a8;
  LOBYTE(v71) = a9;
  v14 = *(__n128 **)(a1 + 16);
  v74 = v14 + 24;
  if (a9 == 5 || a9 == 3)
  {
    v13 = v14[23];
    *(__n128 *)&v73[4] = v13;
  }
  v15 = *(unsigned __int8 *)(a2 + 64);
  if (v15 == *(unsigned __int8 *)(a2 + 65))
  {
    v16 = *(_DWORD *)(a2 + 28);
    v17 = 2 * a3;
    v18 = (float)*(unsigned int *)(a2 + 24);
    v19 = (float)v16;
    v20 = a4 & 4;
  }
  else
  {
    v17 = 2 * a3;
    v21 = (float *)(a6 + 4 * v17 + 32);
    v22 = (float *)(a7 + 4 * v17 + 32);
    v20 = a4 & 4;
    if ((a4 & 4) != 0)
    {
      v26 = 1.0 / *(float *)(a5 + 12);
      v24 = fabsf(*v22 * v26) + fabsf(*v21 * v26);
      v25 = fabsf(*(float *)(a6 + 4 * v17 + 36) * v26);
      v23 = *(float *)(a7 + 4 * v17 + 36) * v26;
    }
    else
    {
      v23 = *(float *)(a7 + 4 * v17 + 36);
      v24 = fabsf(*v22) + fabsf(*v21);
      v25 = fabsf(*(float *)(a6 + 4 * v17 + 36));
    }
    v27 = fabsf(v23) + v25;
    v18 = (float)*(unsigned int *)(a2 + 24);
    v16 = *(_DWORD *)(a2 + 28);
    v19 = (float)v16;
    v28 = 64;
    if ((float)((float)((float)(v24 * v18) + (float)(v27 * (float)v16)) * 0.5) < 0.99)
      v28 = 65;
    v15 = *(unsigned __int8 *)(a2 + v28);
  }
  v29 = a5 + 4 * v17;
  v30 = *(float *)(v29 + 32) * v18;
  v31 = a6 + 4 * v17;
  v32 = *(float *)(v31 + 36);
  v33 = *(float *)(v31 + 32) * v18;
  v34 = a11;
  v35 = a10;
  v13.n128_f32[0] = *(float *)(v29 + 36) * v19;
  v36 = v32 * v19;
  v37 = vcvts_n_s32_f32(v30, 0x10uLL);
  v38 = vcvts_n_s32_f32(v13.n128_f32[0], 0x10uLL);
  v39 = vcvts_n_s32_f32(v33, 0x10uLL);
  *(_QWORD *)((char *)&v71 + 4) = __PAIR64__(v39, v37);
  v40 = vcvts_n_s32_f32(v36, 0x10uLL);
  HIDWORD(v71) = v38;
  LODWORD(v72) = v40;
  v42 = v32 != 0.0 && v16 != 1;
  v43 = v15 | v42;
  if (v20 || a9)
  {
    v43 |= 6u;
  }
  else
  {
    v44 = a10 - 1;
    v45 = v37 + (a10 - 1) * v39;
    if (v39 >= 0)
      v46 = v37;
    else
      v46 = v37 + (a10 - 1) * v39;
    if (v39 < 0)
      v45 = v37;
    if (v40 >= 0)
      v47 = v38;
    else
      v47 = v38 + (a10 - 1) * v40;
    if (v40 >= 0)
      v48 = v38 + (a10 - 1) * v40;
    else
      v48 = v38;
    v49 = v45 + 0x8000;
    if ((v43 & 8) != 0)
      v46 -= 0x8000;
    else
      v49 = v45;
    if ((v43 & 8) != 0)
      v50 = v47 - 0x8000;
    else
      v50 = v47;
    if ((v43 & 8) != 0)
      v51 = v48 + 0x8000;
    else
      v51 = v48;
    if ((v46 & 0x80000000) != 0 || v49 > *(_DWORD *)(a2 + 32) || (v50 & 0x80000000) != 0 || v51 > *(_DWORD *)(a2 + 36))
      goto LABEL_56;
    v52 = -v30;
    if (v30 >= 0.0)
      v52 = v30;
    if (v52 > 8192.0)
      goto LABEL_56;
    v53 = -v13.n128_f32[0];
    if (v13.n128_f32[0] >= 0.0)
      v53 = v13.n128_f32[0];
    if (v53 > 8192.0)
      goto LABEL_56;
    v54 = v30 + (float)(v33 * (float)v44);
    v55 = -v54;
    if (v54 >= 0.0)
      v55 = v54;
    if (v55 > 8192.0)
      goto LABEL_56;
    v56 = v13.n128_f32[0] + (float)(v36 * (float)v44);
    v13.n128_f32[0] = -v56;
    if (v56 >= 0.0)
      v13.n128_f32[0] = v56;
    if (v13.n128_f32[0] > 8192.0)
LABEL_56:
      v43 |= 2u;
  }
  v57 = v14[22].n128_u64[1];
  if (v57)
  {
    v58 = -1.0;
    if (!*(_BYTE *)(v57 + 4))
      v58 = 1.0;
    *((float *)&v72 + 1) = v58;
    DWORD2(v72) = *(_DWORD *)(v57 + 16);
    v13.n128_u32[0] = 0.5;
    v59 = -0.5;
    switch(*(_DWORD *)v57)
    {
      case 1:
        v13.n128_u32[0] = *(_DWORD *)(v57 + 8);
        HIDWORD(v72) = v13.n128_u32[0];
        break;
      case 2:
        goto LABEL_65;
      case 3:
        v13.n128_u32[0] = 0;
        v59 = -1.0;
        goto LABEL_65;
      case 4:
        v13.n128_u32[0] = 1.0;
        v59 = 0.0;
LABEL_65:
        v60 = *(float *)(v57 + 8);
        v61 = *(float *)(v57 + 12);
        v62 = v60 + (float)(v61 * v59);
        v13.n128_f32[0] = v60 + (float)(v61 * v13.n128_f32[0]);
        *((float *)&v72 + 3) = v62;
        *(_DWORD *)v73 = v13.n128_u32[0];
        if (v13.n128_f32[0] <= v62)
        {
          HIDWORD(v72) = v13.n128_u32[0];
          *(float *)v73 = v62;
        }
        break;
      default:
        break;
    }
  }
  result = (*(uint64_t (**)(uint64_t *, _QWORD, uint64_t, __n128))(*(_QWORD *)(a2 + 48) + 8 * v43))(&v64, a10, a11, v13);
  if (*(_BYTE *)(*(_QWORD *)(a1 + 16) + a3 + 17) == 21 && a10)
  {
    do
    {
      *(_DWORD *)v34 = 16843009 * *(unsigned __int8 *)(v34 + 3);
      v34 += 4;
      --v35;
    }
    while (v35);
  }
  return result;
}

void CA::OGL::SW::tex_color_match(float **this, const CA::ColorProgram::Program *a2, unsigned int *a3, unsigned int *a4)
{
  unsigned int v6;
  size_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  unsigned int *v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  float32x2_t v21;
  float v22;
  float v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  float *v27;
  int8x16_t v28;
  float v29;
  float v30;
  float v31;
  float v32;
  __int128 *v33;
  unsigned int v34;
  float v35;
  float v36;
  float v37;
  unsigned int v38;
  uint64_t i;
  float v40;
  int8x16_t v41;
  unsigned int v42;
  uint64_t j;
  float *v44;
  float v45;
  float v46;
  float v47;
  float v48;
  int8x16_t v49;
  unsigned int v50;
  uint64_t v51;
  float *v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  int8x16_t v58;
  unsigned int v59;
  uint64_t v60;
  float *v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  int8x16_t v68;
  unsigned int v69;
  uint64_t v70;
  float *v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  int8x16_t v80;
  unsigned int v81;
  uint64_t k;
  uint64_t v83;
  float v84;
  float v85;
  int8x16_t v86;
  unsigned int v87;
  uint64_t m;
  uint64_t v89;
  float v90;
  int8x16_t v91;
  unsigned int v92;
  uint64_t n;
  uint64_t v94;
  unsigned int v95;
  uint64_t ii;
  uint64_t v97;
  BOOL v98;
  unsigned int v99;
  uint64_t jj;
  float v101;
  float v102;
  int8x16_t v103;
  unsigned int v104;
  uint64_t kk;
  float v106;
  int8x16_t v107;
  unsigned int v108;
  unsigned int *v109;
  uint64_t v110;
  unint64_t v111;
  float v112;
  float v113;
  float v114;
  float v115;
  unsigned int v116;
  float v117;
  unsigned int v118;
  float v119;
  uint64_t v120;
  unint64_t v121;
  unint64_t v122;
  uint64_t v123;
  uint64_t v124;
  unsigned int *v125;
  int v126;
  float *v127;
  int v128;
  int v129;
  int v130;
  unsigned int v131;
  unsigned int v132;
  double v133;
  float v134;
  float v135;
  float v136;
  float v137;
  float v138;
  float v139;
  float v140;
  float v141;
  float v142;
  int8x16_t v143;
  uint64_t v144;

  v144 = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](this);
  v9 = (char *)&v123 - v8;
  if (v6)
  {
    v10 = v6;
    v11 = (unint64_t)(v9 + 15) & 0xFFFFFFFFFFFFFFF0;
    bzero(v9, v7);
    v132 = 0;
    *(int32x2_t *)v14.i8 = vdup_n_s32(0x3B808081u);
    v15.i32[1] = 255;
    v16 = a3;
    v17 = v10;
    do
    {
      v19 = *v16++;
      v18 = v19;
      v20 = HIBYTE(v19);
      if (HIBYTE(v19))
      {
        v21 = vmul_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v18), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL)), *(float32x2_t *)v14.i8);
        v22 = (float)v18 * 0.0039216;
        if (v20 != 255)
        {
          v23 = 255.0 / (float)v20;
          v21 = vmul_n_f32(v21, v23);
          v22 = v22 * v23;
        }
        v24 = v132;
        *(_DWORD *)(v11 + 4 * v132) = v21.i32[1];
        *(_DWORD *)(v11 + 4 * (v24 + 1)) = v21.i32[0];
        *(float *)(v11 + 4 * (v24 + 2)) = v22;
        v132 = v24 + 3;
      }
      --v17;
    }
    while (v17);
    if (v132)
    {
      v124 = v10;
      v125 = a3;
      v25 = *((_DWORD *)this + 9) & 0x7FFFFFFF;
      v26 = v132;
      if (v25)
      {
        v27 = this[6];
        v28.i64[0] = 0x8000000080000000;
        v28.i64[1] = 0x8000000080000000;
        v29 = 0.0031308;
        v30 = 0.41667;
        v31 = -0.055;
        v32 = 1.055;
        v142 = 12.92;
        v141 = 0.052133;
        v140 = 0.94787;
        v139 = 2.4;
        v138 = 0.077399;
        v137 = -3.1309;
        v136 = 5.5918;
        v135 = 0.28467;
        v134 = 0.33333;
        v12.i32[1] = -1076742140;
        v133 = -0.284668922;
        v33 = &xmmword_18474E000;
        *(float *)&v126 = 0.0031308;
        *(float *)&v129 = -0.055;
        v130 = 1054168405;
        *(float *)&v128 = 1.055;
        do
        {
          switch(v25 & 0x1F)
          {
            case 1u:
              v34 = 0;
              do
              {
                v35 = *(float *)(v11 + 4 * v34);
                v36 = *(float *)(v11 + 4 * (v34 + 1));
                v37 = *(float *)(v11 + 4 * (v34 + 2));
                *(float *)(v11 + 4 * v34) = (float)((float)(v27[9] + (float)(*v27 * v35)) + (float)(v27[3] * v36))
                                            + (float)(v27[6] * v37);
                *(float *)(v11 + 4 * (v34 + 1)) = (float)((float)(v27[10] + (float)(v27[1] * v35))
                                                          + (float)(v27[4] * v36))
                                                  + (float)(v27[7] * v37);
                *(float *)(v11 + 4 * (v34 + 2)) = (float)((float)(v27[11] + (float)(v27[2] * v35))
                                                          + (float)(v27[5] * v36))
                                                  + (float)(v27[8] * v37);
                v34 += 3;
              }
              while (v34 < v26);
              v27 += 12;
              break;
            case 2u:
              v131 = v25;
              v38 = 0;
              do
              {
                for (i = 0; i != 3; ++i)
                {
                  v40 = v27[i];
                  v12.i32[0] = *(_DWORD *)(v11 + 4 * (v38 + i));
                  v143 = v12;
                  *(float *)v41.i32 = powf(fabsf(*(float *)v12.i32), v40);
                  v28.i64[0] = 0x8000000080000000;
                  v28.i64[1] = 0x8000000080000000;
                  v14 = v143;
                  v12 = vbslq_s8(v28, v41, v143);
                  *(_DWORD *)(v11 + 4 * (v38 + i)) = v12.i32[0];
                }
                v38 += 3;
              }
              while (v38 < v26);
              v27 += 3;
              goto LABEL_82;
            case 3u:
              v131 = v25;
              v42 = 0;
              do
              {
                for (j = 0; j != 3; ++j)
                {
                  v44 = &v27[j];
                  v45 = *v44;
                  v46 = v44[3];
                  v47 = v44[6];
                  v12.i32[0] = *(_DWORD *)(v11 + 4 * (v42 + j));
                  v143 = v12;
                  v48 = fabsf(*(float *)v12.i32);
                  *(float *)v49.i32 = powf(v47 + (float)(v48 * v46), v45);
                  v28.i64[0] = 0x8000000080000000;
                  v28.i64[1] = 0x8000000080000000;
                  if (v48 < (float)((float)-v47 / v46))
                    *(float *)v49.i32 = 0.0;
                  v14 = v143;
                  v12 = vbslq_s8(v28, v49, v143);
                  *(_DWORD *)(v11 + 4 * (v42 + j)) = v12.i32[0];
                }
                v42 += 3;
              }
              while (v42 < v26);
              v27 += 9;
              v25 = v131;
              goto LABEL_49;
            case 4u:
              v131 = v25;
              v50 = 0;
              do
              {
                v51 = 0;
                v52 = v27 + 6;
                do
                {
                  v53 = *(v52 - 6);
                  v54 = *(v52 - 3);
                  v55 = *v52;
                  v56 = v52[3];
                  v12.i32[0] = *(_DWORD *)(v11 + 4 * (v50 + v51));
                  v143 = v12;
                  v57 = fabsf(*(float *)v12.i32);
                  *(float *)v58.i32 = powf(v55 + (float)(v57 * v54), v53);
                  v28.i64[0] = 0x8000000080000000;
                  v28.i64[1] = 0x8000000080000000;
                  if (v57 < (float)((float)-v55 / v54))
                    *(float *)v58.i32 = 0.0;
                  *(float *)v58.i32 = *(float *)v58.i32 + v56;
                  v14 = v143;
                  v12 = vbslq_s8(v28, v58, v143);
                  *(_DWORD *)(v11 + 4 * (v50 + v51++)) = v12.i32[0];
                  ++v52;
                }
                while (v51 != 3);
                v50 += 3;
                v26 = v132;
              }
              while (v50 < v132);
              v27 += 12;
              v25 = v131;
              goto LABEL_48;
            case 5u:
              v131 = v25;
              v59 = 0;
              do
              {
                v60 = 0;
                v61 = v27 + 6;
                do
                {
                  v62 = *(v61 - 6);
                  v63 = *(v61 - 3);
                  v64 = *v61;
                  v65 = v61[3];
                  v66 = v61[6];
                  v13.i32[0] = *(_DWORD *)(v11 + 4 * (v59 + v60));
                  v143 = v13;
                  v67 = fabsf(*(float *)v13.i32);
                  *(float *)v68.i32 = powf(v64 + (float)(v67 * v63), v62);
                  v28.i64[0] = 0x8000000080000000;
                  v28.i64[1] = 0x8000000080000000;
                  if (v67 < v66)
                    *(float *)v68.i32 = v67 * v65;
                  v14 = v143;
                  v12 = vbslq_s8(v28, v68, v143);
                  *(_DWORD *)(v11 + 4 * (v59 + v60++)) = v12.i32[0];
                  ++v61;
                }
                while (v60 != 3);
                v59 += 3;
                v26 = v132;
              }
              while (v59 < v132);
              v27 += 15;
              v25 = v131;
              v29 = *(float *)&v126;
              goto LABEL_50;
            case 6u:
              v131 = v25;
              v69 = 0;
              do
              {
                v70 = 0;
                v71 = v27 + 9;
                do
                {
                  v72 = *(v71 - 9);
                  v73 = *(v71 - 6);
                  v74 = *(v71 - 3);
                  v75 = *v71;
                  v76 = v71[3];
                  v77 = v71[6];
                  v78 = v71[9];
                  v13.i32[0] = *(_DWORD *)(v11 + 4 * (v69 + v70));
                  v143 = v13;
                  v79 = fabsf(*(float *)v13.i32);
                  *(float *)v80.i32 = powf(v74 + (float)(v79 * v73), v72);
                  v28.i64[0] = 0x8000000080000000;
                  v28.i64[1] = 0x8000000080000000;
                  *(float *)v80.i32 = *(float *)v80.i32 + v77;
                  if (v79 < v76)
                    *(float *)v80.i32 = v78 + (float)(v79 * v75);
                  v14 = v143;
                  v12 = vbslq_s8(v28, v80, v143);
                  *(_DWORD *)(v11 + 4 * (v69 + v70++)) = v12.i32[0];
                  ++v71;
                }
                while (v70 != 3);
                v69 += 3;
                v26 = v132;
              }
              while (v69 < v132);
              v27 += 21;
              v25 = v131;
LABEL_48:
              v29 = *(float *)&v126;
LABEL_49:
              v30 = *(float *)&v130;
LABEL_50:
              v32 = *(float *)&v128;
              v31 = *(float *)&v129;
              goto LABEL_83;
            case 0xBu:
              v131 = v25;
              v81 = 0;
              do
              {
                for (k = 0; k != 3; ++k)
                {
                  v83 = v81 + k;
                  v14.i32[0] = *(_DWORD *)(v11 + 4 * v83);
                  v84 = fabsf(*(float *)v14.i32);
                  if (v84 <= v29)
                  {
                    *(float *)v12.i32 = *(float *)v14.i32 * v142;
                  }
                  else
                  {
                    v143 = v14;
                    v85 = powf(v84, v30);
                    v28.i64[0] = 0x8000000080000000;
                    v28.i64[1] = 0x8000000080000000;
                    *(float *)v86.i32 = v31 + (float)(v85 * v32);
                    v14 = v143;
                    v12 = vbslq_s8(v28, v86, v143);
                  }
                  *(_DWORD *)(v11 + 4 * v83) = v12.i32[0];
                }
                v81 += 3;
              }
              while (v81 < v26);
              goto LABEL_82;
            case 0xCu:
              v131 = v25;
              v87 = 0;
              do
              {
                for (m = 0; m != 3; ++m)
                {
                  v89 = v87 + m;
                  v14.i32[0] = *(_DWORD *)(v11 + 4 * v89);
                  v90 = fabsf(*(float *)v14.i32);
                  if (v90 <= 0.04045)
                  {
                    *(float *)v12.i32 = *(float *)v14.i32 * v138;
                  }
                  else
                  {
                    v143 = v14;
                    *(float *)v91.i32 = powf(v141 + (float)(v90 * v140), v139);
                    v28.i64[0] = 0x8000000080000000;
                    v28.i64[1] = 0x8000000080000000;
                    v14 = v143;
                    v12 = vbslq_s8(v28, v91, v143);
                  }
                  *(_DWORD *)(v11 + 4 * v89) = v12.i32[0];
                }
                v87 += 3;
              }
              while (v87 < v26);
              goto LABEL_82;
            case 0xDu:
              v131 = v25;
              v92 = 0;
              do
              {
                for (n = 0; n != 3; ++n)
                {
                  v94 = v92 + n;
                  v15.i32[0] = *(_DWORD *)(v11 + 4 * v94);
                  if (fabsf(*(float *)v15.i32) <= 0.5)
                  {
                    *(float *)v12.i32 = (float)(*(float *)v15.i32 * *(float *)v15.i32) * v134;
                  }
                  else
                  {
                    v143 = v15;
                    *(float *)v12.i32 = expf(v137 + (float)(*(float *)v15.i32 * v136));
                    v15 = v143;
                    v28.i64[0] = 0x8000000080000000;
                    v28.i64[1] = 0x8000000080000000;
                    *(double *)v12.i64 = (float)(*(float *)v12.i32 + v135) * 0.0833333333;
                    *(float *)v12.i32 = *(double *)v12.i64;
                  }
                  *(float *)v12.i32 = *(float *)v12.i32 * 12.0;
                  v12 = vbslq_s8(v28, v12, v15);
                  *(_DWORD *)(v11 + 4 * v94) = v12.i32[0];
                }
                v92 += 3;
              }
              while (v92 < v26);
              goto LABEL_82;
            case 0xEu:
              v131 = v25;
              v95 = 0;
              do
              {
                for (ii = 0; ii != 3; ++ii)
                {
                  v97 = v95 + ii;
                  *(double *)v12.i64 = *(float *)(v11 + 4 * v97) * 0.0833333333;
                  *(float *)v15.i32 = *(double *)v12.i64;
                  *(float *)v12.i32 = fabsf(*(float *)v15.i32);
                  if (*(float *)v12.i32 <= 0.083333)
                  {
                    *(float *)v12.i32 = sqrtf(*(float *)v12.i32 * 3.0);
                  }
                  else
                  {
                    v143 = v15;
                    *(double *)v12.i64 = log(v133 + *(float *)v12.i32 * 12.0);
                    v28.i64[0] = 0x8000000080000000;
                    v28.i64[1] = 0x8000000080000000;
                    v14.i32[1] = 1071770313;
                    *(double *)v12.i64 = *(double *)v12.i64 * 0.178832769 + 0.559910715;
                    v15 = v143;
                    *(float *)v12.i32 = *(double *)v12.i64;
                  }
                  v12 = vbslq_s8(v28, v12, v15);
                  *(_DWORD *)(v11 + 4 * v97) = v12.i32[0];
                }
                v95 += 3;
              }
              while (v95 < v26);
LABEL_82:
              v25 = v131;
LABEL_83:
              v33 = &xmmword_18474E000;
              break;
            case 0xFu:
              v131 = v25;
              v127 = v27;
              v99 = 0;
              do
              {
                for (jj = 0; jj != 3; ++jj)
                {
                  v12.i32[0] = *(_DWORD *)(v11 + 4 * (v99 + jj));
                  v143 = v12;
                  v101 = powf(fabsf(*(float *)v12.i32), 0.012683);
                  v102 = powf((float)(v101 + -0.83594) / (float)((float)(v101 * -18.688) + 18.852), 6.2774);
                  v28.i64[0] = 0x8000000080000000;
                  v28.i64[1] = 0x8000000080000000;
                  *(float *)v103.i32 = v102 * 100.0;
                  v14 = v143;
                  v12 = vbslq_s8(v28, v103, v143);
                  *(_DWORD *)(v11 + 4 * (v99 + jj)) = v12.i32[0];
                }
                v99 += 3;
                v26 = v132;
              }
              while (v99 < v132);
              v27 = v127;
              v33 = &xmmword_18474E000;
              goto LABEL_96;
            case 0x10u:
              v131 = v25;
              v127 = v27;
              v104 = 0;
              do
              {
                for (kk = 0; kk != 3; ++kk)
                {
                  *(double *)v12.i64 = *(float *)(v11 + 4 * (v104 + kk)) * 0.01;
                  *(float *)v12.i32 = *(double *)v12.i64;
                  v143 = v12;
                  v106 = powf(fabsf(*(float *)v12.i32), 0.1593);
                  *(float *)v107.i32 = powf((float)((float)(v106 * 18.852) + 0.83594)/ (float)((float)(v106 * *((float *)v33 + 753)) + 1.0), 78.844);
                  v28.i64[0] = 0x8000000080000000;
                  v28.i64[1] = 0x8000000080000000;
                  v14 = v143;
                  v12 = vbslq_s8(v28, v107, v143);
                  *(_DWORD *)(v11 + 4 * (v104 + kk)) = v12.i32[0];
                }
                v104 += 3;
                v26 = v132;
              }
              while (v104 < v132);
              v27 = v127;
              v30 = *(float *)&v130;
LABEL_96:
              v25 = v131;
              break;
            default:
              break;
          }
          v98 = v25 > 0x1F;
          v25 >>= 5;
        }
        while (v98);
      }
      v108 = 0;
      v109 = v125;
      v110 = v124;
      do
      {
        v111 = *v109;
        if ((_DWORD)v111)
        {
          v112 = *(float *)(v11 + 4 * v108);
          v113 = *(float *)(v11 + 4 * (v108 + 1));
          v114 = *(float *)(v11 + 4 * (v108 + 2));
          if (v112 > 1.0)
            v112 = 1.0;
          if (v113 > 1.0)
            v113 = 1.0;
          if (v114 > 1.0)
            v114 = 1.0;
          if (v112 >= 0.0)
            v115 = (float)(v112 * 255.0) + 0.5;
          else
            v115 = 0.5;
          v116 = v115;
          v117 = (float)(v113 * 255.0) + 0.5;
          if (v113 < 0.0)
            v117 = 0.5;
          v118 = v117;
          v119 = (float)(v114 * 255.0) + 0.5;
          if (v114 < 0.0)
            v119 = 0.5;
          v120 = (v116 << 16) | (v118 << 8) | v119 | 0xFF000000;
          v121 = v111 >> 24;
          if ((_DWORD)v121 != 255)
          {
            v122 = ((((v120 | (v120 << 24)) & 0xFF00FF00FF00FFLL) + ((v120 | (v120 << 24)) & 0xFF00FF00FF00FFLL) * v121) >> 8) & 0xFF00FF00FF00FFLL;
            LODWORD(v120) = (v122 >> 24) | v122;
          }
          v108 += 3;
          *v109 = v120;
        }
        ++v109;
        --v110;
      }
      while (v110);
    }
  }
}

unsigned __int32 *CA::OGL::SW::tex_multiply_color(unsigned __int32 *this, unsigned int *a2, const unsigned int *a3, uint64_t a4)
{
  int32x2_t v4;
  unsigned int v5;
  int8x8_t v6;

  if (a4)
  {
    v4 = vadd_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(a3 >> 8), (int8x8_t)0xFF0000FF00), (int32x2_t)0x100000100);
    do
    {
      v5 = *a2++;
      v6 = vand_s8((int8x8_t)vmul_s32(v4, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v5), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)0x1FF0001FF0000);
      *this++ = ((((a3 >> 8) & 0xFF0000) + 0x10000) * HIBYTE(v5)) & 0xFF000000 | ((v5
                                                                                               * (a3
                                                                                                + 1)) >> 8) | v6.i32[0] | v6.i32[1];
      --a4;
    }
    while (a4);
  }
  return this;
}

unsigned __int32 *CA::OGL::SW::tex_multiply_color(unsigned __int32 *this, unsigned int *a2, unsigned int *a3, const unsigned int *a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  int8x8_t v7;

  for (; a4; a4 = (const unsigned int *)((char *)a4 - 1))
  {
    v5 = *a2++;
    v4 = v5;
    v6 = *a3++;
    v7 = vand_s8((int8x8_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v4 >> 8), (int8x8_t)0xFF0000FF00), vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (int32x2_t)0x100000001)), (int8x8_t)0x1FF0001FF0000);
    *this++ = (((v4 >> 8) & 0xFF0000) + ((v4 >> 8) & 0xFF0000) * HIBYTE(v6)) & 0xFF000000 | ((v4
                                                                                            * v6
                                                                                            + v4) >> 8) | v7.i32[0] | v7.i32[1];
  }
  return this;
}

unsigned int *CA::OGL::SW::tex_interpolate(unsigned int *this, unsigned int *a2, unsigned int *a3, const unsigned int *a4, uint64_t a5)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;

  for (; a5; --a5)
  {
    v6 = *a2++;
    v5 = v6;
    v7 = *a3++;
    *this++ = ((v5 & 0xFF00FF) + ((((v7 & 0xFF00FF) - (v5 & 0xFF00FF)) * a4) >> 8)) & 0xFF00FF | ((((v7 >> 8) & 0xFF00FF) - ((v5 >> 8) & 0xFF00FF)) * (_DWORD)a4 + (((v5 >> 8) & 0xFF00FF) << 8)) & 0xFF00FF00;
  }
  return this;
}

unsigned int *CA::OGL::SW::convert_in(unsigned int *this, unsigned int *a2, unsigned __int8 *a3, void *a4, uint64_t a5)
{
  unsigned int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;

  if ((int)a4 <= 14)
  {
    if ((_DWORD)a4)
    {
      if ((_DWORD)a4 == 8)
      {
        if (a3)
        {
          for (; a5; --a5)
          {
            v7 = *a3++;
            v6 = v7;
            v8 = *(unsigned __int8 *)a2;
            a2 = (unsigned int *)((char *)a2 + 1);
            *this++ = (v8 << 8) | (v6 << 24) | v8 | (((v8 << 8) | (v6 << 24) | v8) << 8);
          }
        }
        else
        {
          for (; a5; --a5)
          {
            v15 = *(unsigned __int8 *)a2;
            a2 = (unsigned int *)((char *)a2 + 1);
            *this++ = (65793 * v15) | 0xFF000000;
          }
        }
      }
    }
    else
    {
      for (; a5; --a5)
      {
        v14 = *a3++;
        *this++ = v14 | (v14 << 8) | ((v14 | (v14 << 8)) << 16);
      }
    }
  }
  else if ((_DWORD)a4 == 15)
  {
    if (a3)
    {
      for (; a5; --a5)
      {
        v10 = *a3++;
        v9 = v10;
        v11 = *(unsigned __int16 *)a2;
        a2 = (unsigned int *)((char *)a2 + 2);
        v12 = (v11 << 6) & 0xF800 | (8 * (v11 & 0x1F)) | (((v11 >> 10) & 0x1F) << 19);
        *this++ = (v12 >> 3) & 0x70707 | (v9 << 24) | v12;
      }
    }
    else
    {
      for (; a5; --a5)
      {
        v16 = *(unsigned __int16 *)a2;
        a2 = (unsigned int *)((char *)a2 + 2);
        v17 = (v16 << 6) & 0xF800 | (8 * (v16 & 0x1F)) | (((v16 >> 10) & 0x1F) << 19);
        *this++ = v17 | (v17 >> 3) & 0x70707 | 0xFF000000;
      }
    }
  }
  else if ((_DWORD)a4 == 32)
  {
    if (a3)
    {
      for (; a5; --a5)
      {
        v13 = *a2++;
        *this++ = v13;
      }
    }
    else
    {
      for (; a5; --a5)
      {
        v18 = *a2++;
        *this++ = v18 | 0xFF000000;
      }
    }
  }
  else if ((_DWORD)a4 == 16 && a5)
  {
    do
    {
      v5 = *(unsigned __int16 *)a2;
      a2 = (unsigned int *)((char *)a2 + 2);
      *this++ = (65792 * v5) | (v5 >> 8 << 24) | v5;
      --a5;
    }
    while (a5);
  }
  return this;
}

unsigned int *CA::OGL::SW::tex_blend_dest(CA::OGL::SW *this, unsigned int *a2, unsigned int *a3, const unsigned int *a4, const unsigned int *a5)
{
  size_t v10;
  size_t v11;
  void *v12;
  _QWORD v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  v10 = 4 * (_QWORD)a5;
  MEMORY[0x1E0C80A78](this);
  bzero((char *)v14 - ((v10 + 30) & 0xFFFFFFFFFFFFFFF0), v11);
  v12 = (void *)(((unint64_t)&v14[1] - ((v10 + 30) & 0xFFFFFFFFFFFFFFF0) + 7) & 0xFFFFFFFFFFFFFFF0);
  memcpy(v12, a2, v10);
  return CA::OGL::SW::tex_mix((unsigned int *)this, a3, (unsigned int *)v12, a4, a5);
}

unsigned int *CA::OGL::SW::tex_blend_color(CA::OGL::SW *this, unsigned int *a2, const unsigned int *a3, const unsigned int *a4, const unsigned int *a5, void (*a6)(void *, unsigned int *, void *, const unsigned int *, _QWORD), void (*a7)(unsigned int *, const unsigned int *, const unsigned int *, unint64_t, const unsigned int *), const unsigned int *a8)
{
  int v12;
  uint64_t v15;
  size_t v16;
  void *v17;
  _BYTE v19[4];
  int __pattern4;
  uint64_t v21;

  v12 = (int)a3;
  v21 = *MEMORY[0x1E0C80C00];
  v15 = 4 * (_QWORD)a5;
  MEMORY[0x1E0C80A78](this);
  bzero(&v19[-((v15 + 30) & 0xFFFFFFFFFFFFFFF0)], v16);
  v17 = (void *)((unint64_t)&v19[-((v15 + 30) & 0xFFFFFFFFFFFFFFF0) + 15] & 0xFFFFFFFFFFFFFFF0);
  __pattern4 = v12;
  memset_pattern4(v17, &__pattern4, v15 & 0xFFFFFFFC);
  a6(v17, a2, v17, a5, a7);
  return CA::OGL::SW::tex_mix((unsigned int *)this, a2, (unsigned int *)v17, a4, a5);
}

unsigned int *CA::OGL::SW::tex_blend_image(CA::OGL::SW *this, unsigned int *a2, const unsigned int *a3, const unsigned int *a4, const unsigned int *a5, void (*a6)(unsigned int *, unsigned int *, const unsigned int *, const unsigned int *, _QWORD), void (*a7)(unsigned int *, const unsigned int *, const unsigned int *, unint64_t, const unsigned int *), const unsigned int *a8)
{
  uint64_t v15;
  char *v16;
  size_t v17;
  unsigned int *v18;
  _QWORD v20[2];

  v20[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](this);
  v16 = (char *)v20 - ((v15 + 30) & 0xFFFFFFFFFFFFFFF0);
  bzero(v16, v17);
  v18 = (unsigned int *)((unint64_t)(v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  a6(v18, a2, a3, a5, a7);
  return CA::OGL::SW::tex_mix((unsigned int *)this, a2, v18, a4, a5);
}

unsigned int *CA::OGL::SW::tex_color_matrix_4x4_bias(unsigned int *this, unsigned int *a2, const unsigned int *a3, float32x2_t *a4, const float *a5)
{
  float32x2_t v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float32x2_t v19;
  float v20;
  float v21;
  float v22;
  float32x2_t v23;
  float32x2_t v24;
  unsigned __int32 v25;
  uint32x2_t v26;

  if (a3)
  {
    __asm { FMOV            V3.2S, #1.0 }
    v10 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      v11 = *a2;
      v12 = HIBYTE(*a2);
      if (v12)
      {
        v14 = (float)v12 * 0.0039216;
        v15 = 1.0 / (float)v12;
        v16 = v15 * (float)BYTE2(v11);
        v17 = v15 * (float)BYTE1(v11);
        v18 = v15 * (float)*a2;
        v19 = vmla_n_f32(vmla_n_f32(vmla_n_f32(vmla_n_f32(a4[9], a4[1], v16), a4[3], v17), a4[5], v18), a4[7], v14);
        v20 = v19.f32[1];
        v21 = vmuls_lane_f32(v19.f32[0], v19, 1);
        if (v21 > 1.0)
          v21 = 1.0;
        if (v19.f32[1] > 1.0)
          v20 = 1.0;
        _NF = v20 < 0.0;
        v22 = (float)(v20 * 255.0) + 0.5;
        if (_NF)
          v22 = 0.5;
        v23 = vmul_lane_f32(vmla_n_f32(vmla_n_f32(vmla_n_f32(vmla_n_f32(a4[8], *a4, v16), a4[2], v17), a4[4], v18), a4[6], v14), v19, 1);
        v24 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v23, _D3), (int8x8_t)_D3, (int8x8_t)v23);
        v26 = vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v24), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v10, v24))), (uint32x2_t)0x800000010);
        v25 = v26.i32[0] | (v22 << 24);
        *(float *)v26.i32 = (float)(v21 * 255.0) + 0.5;
        if (v21 < 0.0)
          *(float *)v26.i32 = 0.5;
        v13 = v25 | v26.i32[1] | *(float *)v26.i32;
      }
      else
      {
        v13 = 0;
      }
      *this++ = v13;
      ++a2;
      a3 = (const unsigned int *)((char *)a3 - 1);
    }
    while (a3);
  }
  return this;
}

unsigned int *CA::OGL::SW::tex_vibrant_color_matrix(CA::OGL::SW *this, unsigned int *a2, unsigned int *a3, const unsigned int *a4, float32x2_t *a5, const float *a6)
{
  uint64_t v11;
  char *v12;
  size_t v13;
  unsigned int *v14;
  const float *v15;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](this);
  v12 = (char *)v17 - ((v11 + 30) & 0xFFFFFFFFFFFFFFF0);
  bzero(v12, v13);
  v14 = (unsigned int *)((unint64_t)(v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  CA::OGL::SW::tex_color_matrix_4x4_bias(v14, a2, a4, a5, v15);
  return CA::OGL::SW::tex_mix((unsigned int *)this, a2, v14, a3, a4);
}

unsigned __int32 *CA::OGL::SW::tex_vibrant_dark(CA::OGL::SW *this, unsigned int *a2, unsigned int *a3, const unsigned int *a4, float *a5, const float *a6)
{
  unsigned int *v9;
  const unsigned int *v10;
  const unsigned int *v11;
  float v12;
  uint64_t v13;
  char *v14;
  size_t v15;
  unsigned __int32 *v16;
  unsigned __int32 *result;
  unsigned int v18;
  const unsigned int *v19;
  const unsigned int *v20;
  unsigned int *v21;
  unsigned int v22;
  int32x2_t v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  signed int v27;
  unsigned int v28;
  int32x2_t v29;
  int32x2_t v30;
  int v31;
  int v32;
  unsigned int v33;
  signed int v34;
  signed int v35;
  int v36;
  int32x2_t v37;
  int v38;
  uint32x2_t v39;
  const unsigned int *v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  int32x2_t v44;
  unsigned int v45;
  unsigned int v46;
  int v47;
  signed int v48;
  unsigned int v49;
  int32x2_t v50;
  int32x2_t v51;
  int v52;
  int v53;
  unsigned int v54;
  int v55;
  int v56;
  int v57;
  int32x2_t v58;
  int v59;
  uint32x2_t v60;
  unsigned int v61;
  const unsigned int *v62;
  unsigned __int32 v63;
  uint64_t v64;
  uint64_t v65;

  v9 = (unsigned int *)this;
  v65 = *MEMORY[0x1E0C80C00];
  v10 = (const unsigned int *)(((float)((float)(a5[1] * 255.0) + 0.5) << 8) | ((float)((float)(*a5 * 255.0) + 0.5) << 16) | (float)((float)(a5[2] * 255.0) + 0.5) | ((float)((float)(a5[3] * 255.0) + 0.5) << 24));
  v11 = (const unsigned int *)(((float)((float)(a5[5] * 255.0) + 0.5) << 8) | ((float)((float)(a5[4] * 255.0) + 0.5) << 16) | (float)((float)(a5[6] * 255.0) + 0.5) | ((float)((float)(a5[7] * 255.0) + 0.5) << 24));
  v12 = a5[8];
  MEMORY[0x1E0C80A78](this);
  v14 = (char *)&v64 - ((v13 + 30) & 0xFFFFFFFFFFFFFFF0);
  bzero(v14, v15);
  v16 = (unsigned __int32 *)((unint64_t)(v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v12 == 0.0)
  {
    result = CA::OGL::SW::tex_multiply_color(v16, a3, v10, (uint64_t)a4);
    if (a4)
    {
      v40 = 0;
      do
      {
        v41 = v16[(_QWORD)v40];
        v42 = a2[(_QWORD)v40];
        v43 = HIBYTE(v41);
        v44 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v41), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
        v45 = v41;
        v46 = HIBYTE(v42);
        v47 = HIBYTE(v41) + 1;
        v48 = (HIBYTE(v42) * v47) >> 8;
        if (HIBYTE(v42) == 255)
        {
          v49 = 0;
          v50 = 0;
        }
        else
        {
          v48 += ((v46 ^ 0xFF) * v47) >> 8;
          v50 = (int32x2_t)vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(v46 ^ 0xFF), vadd_s32(v44, (int32x2_t)0x100000001)), 8uLL);
          v49 = ((v46 ^ 0xFF) + (v46 ^ 0xFF) * v45) >> 8;
        }
        v51 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v42), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
        v52 = a2[(_QWORD)v40];
        if (v43 != 255)
        {
          v53 = v43 ^ 0xFF;
          v48 += (v53 + v53 * v46) >> 8;
          v50 = (int32x2_t)vsra_n_u32((uint32x2_t)v50, (uint32x2_t)vmul_s32(vadd_s32(v51, (int32x2_t)0x100000001), vdup_n_s32(v43 ^ 0xFF)), 8uLL);
          v49 += (v53 + v53 * v52) >> 8;
        }
        v54 = v47 * v43;
        v55 = v43;
        if (v43 > v44.i32[0])
        {
          v55 = (int)(255 * ((v51.i32[0] + v51.i32[0] * (v54 >> 8)) >> 8)) / (int)(v43 - v44.i32[0]);
          if (v55 >= (int)v43)
            v55 = v43;
        }
        v56 = v43;
        if (v43 > v44.i32[1])
        {
          v56 = (int)(255 * ((v51.i32[1] + v51.i32[1] * (v54 >> 8)) >> 8)) / (int)(v43 - v44.i32[1]);
          if (v56 >= (int)v43)
            v56 = v43;
        }
        v57 = (int)(255 * ((v52 + v52 * (v54 >> 8)) >> 8)) / (int)(v43 - v45);
        if (v57 >= (int)v43)
          v57 = v43;
        if (v43 > v45)
          v43 = v57;
        v58 = vadd_s32((int32x2_t)__PAIR64__(v56, v55), v50);
        v59 = v43 + v49;
        if (v59 >= v48)
          v59 = v48;
        v60 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(v58, vdup_n_s32(v48)), 0), (uint32x2_t)0x800000010);
        v9[(_QWORD)v40] = v60.i32[0] | (v48 << 24) | v59 & ~(v59 >> 31) | v60.i32[1];
        v40 = (const unsigned int *)((char *)v40 + 1);
      }
      while (a4 != v40);
      CA::OGL::SW::tex_multiply_color(v16, a3, v11, (uint64_t)a4);
      do
      {
        v63 = *v16++;
        HIDWORD(v64) = *v9;
        result = CA::OGL::SW::Blend::LightenSover::f((_DWORD *)&v64 + 1, (unsigned int *)v63, v61, v62);
        *v9++ = HIDWORD(v64);
        a4 = (const unsigned int *)((char *)a4 - 1);
      }
      while (a4);
    }
  }
  else
  {
    result = CA::OGL::SW::tex_multiply_color(v16, a3, v11, (uint64_t)a4);
    if (a4)
    {
      v20 = 0;
      do
      {
        v21 = (unsigned int *)v16[(_QWORD)v20];
        HIDWORD(v64) = a2[(_QWORD)v20];
        CA::OGL::SW::Blend::LightenSover::f((_DWORD *)&v64 + 1, v21, v18, v19);
        v9[(_QWORD)v20] = HIDWORD(v64);
        v20 = (const unsigned int *)((char *)v20 + 1);
      }
      while (a4 != v20);
      result = CA::OGL::SW::tex_multiply_color(v16, a3, v10, (uint64_t)a4);
      do
      {
        v22 = HIBYTE(*v16);
        v23 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v16), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
        v24 = *v16;
        v25 = HIBYTE(*v9);
        v26 = v22 + 1;
        v27 = (v25 * (v22 + 1)) >> 8;
        if (v25 == 255)
        {
          v28 = 0;
          v29 = 0;
        }
        else
        {
          v27 += ((v25 ^ 0xFF) * v26) >> 8;
          v29 = (int32x2_t)vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(v25 ^ 0xFF), vadd_s32(v23, (int32x2_t)0x100000001)), 8uLL);
          v28 = ((v25 ^ 0xFF) + (v25 ^ 0xFF) * v24) >> 8;
        }
        v30 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v9), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
        v31 = *v9;
        if (v22 != 255)
        {
          v32 = v22 ^ 0xFF;
          v27 += (v32 + v32 * v25) >> 8;
          v29 = (int32x2_t)vsra_n_u32((uint32x2_t)v29, (uint32x2_t)vmul_s32(vadd_s32(v30, (int32x2_t)0x100000001), vdup_n_s32(v22 ^ 0xFF)), 8uLL);
          v28 += (v32 + v32 * v31) >> 8;
        }
        v33 = v26 * v22;
        v34 = HIBYTE(*v16);
        if (v22 > v23.i32[0])
        {
          v34 = (int)(255 * ((v30.i32[0] + v30.i32[0] * (v33 >> 8)) >> 8)) / (int)(v22 - v23.i32[0]);
          if (v34 >= (int)v22)
            v34 = HIBYTE(*v16);
        }
        v35 = HIBYTE(*v16);
        if (v22 > v23.i32[1])
        {
          v35 = (int)(255 * ((v30.i32[1] + v30.i32[1] * (v33 >> 8)) >> 8)) / (int)(v22 - v23.i32[1]);
          if (v35 >= (int)v22)
            v35 = HIBYTE(*v16);
        }
        v36 = (int)(255 * ((v31 + v31 * (v33 >> 8)) >> 8)) / (int)(v22 - v24);
        if (v36 >= (int)v22)
          v36 = HIBYTE(*v16);
        if (v22 > v24)
          v22 = v36;
        v37 = vadd_s32((int32x2_t)__PAIR64__(v35, v34), v29);
        v38 = v22 + v28;
        if (v38 >= v27)
          v38 = v27;
        v39 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(v37, vdup_n_s32(v27)), 0), (uint32x2_t)0x800000010);
        *v9++ = v39.i32[0] | (v27 << 24) | v38 & ~(v38 >> 31) | v39.i32[1];
        ++v16;
        a4 = (const unsigned int *)((char *)a4 - 1);
      }
      while (a4);
    }
  }
  return result;
}

void *CA::OGL::SW::tex_vibrant_light(CA::OGL::SW *this, unsigned int *a2, unsigned int *a3, const unsigned int *a4, float *a5, const float *a6)
{
  CA::OGL::SW *v9;
  const unsigned int *v10;
  const unsigned int *v11;
  float v12;
  uint64_t v13;
  char *v14;
  size_t v15;
  unsigned __int32 *v16;
  void *result;
  unsigned int v18;
  const unsigned int *v19;
  const unsigned int *v20;
  unsigned int *v21;
  unsigned int v22;
  const unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  const unsigned int *v26;
  unsigned __int32 v27;
  uint64_t v28;
  uint64_t v29;

  v9 = this;
  v29 = *MEMORY[0x1E0C80C00];
  v10 = (const unsigned int *)(((float)((float)(a5[1] * 255.0) + 0.5) << 8) | ((float)((float)(*a5 * 255.0) + 0.5) << 16) | (float)((float)(a5[2] * 255.0) + 0.5) | ((float)((float)(a5[3] * 255.0) + 0.5) << 24));
  v11 = (const unsigned int *)(((float)((float)(a5[5] * 255.0) + 0.5) << 8) | ((float)((float)(a5[4] * 255.0) + 0.5) << 16) | (float)((float)(a5[6] * 255.0) + 0.5) | ((float)((float)(a5[7] * 255.0) + 0.5) << 24));
  v12 = a5[8];
  MEMORY[0x1E0C80A78](this);
  v14 = (char *)&v28 - ((v13 + 30) & 0xFFFFFFFFFFFFFFF0);
  bzero(v14, v15);
  v16 = (unsigned __int32 *)((unint64_t)(v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v12 == 0.0)
  {
    result = CA::OGL::SW::tex_multiply_color(v16, a3, v10, (uint64_t)a4);
    if (a4)
    {
      v23 = 0;
      do
      {
        v24 = v16[(_QWORD)v23];
        HIDWORD(v28) = a2[(_QWORD)v23];
        CA::OGL::SW::Blend::SeparableMode<CA::OGL::SW::Blend::ColorBurn>::f((int *)&v28 + 1, v24);
        *((_DWORD *)v9 + (_QWORD)v23) = HIDWORD(v28);
        v23 = (const unsigned int *)((char *)v23 + 1);
      }
      while (a4 != v23);
      CA::OGL::SW::tex_multiply_color(v16, a3, v11, (uint64_t)a4);
      do
      {
        v27 = *v16++;
        HIDWORD(v28) = *(_DWORD *)v9;
        result = CA::OGL::SW::Blend::DarkenSover::f((_DWORD *)&v28 + 1, (unsigned int *)v27, v25, v26);
        *(_DWORD *)v9 = HIDWORD(v28);
        v9 = (CA::OGL::SW *)((char *)v9 + 4);
        a4 = (const unsigned int *)((char *)a4 - 1);
      }
      while (a4);
    }
  }
  else
  {
    result = CA::OGL::SW::tex_multiply_color(v16, a3, v11, (uint64_t)a4);
    if (a4)
    {
      v20 = 0;
      do
      {
        v21 = (unsigned int *)v16[(_QWORD)v20];
        HIDWORD(v28) = a2[(_QWORD)v20];
        CA::OGL::SW::Blend::DarkenSover::f((_DWORD *)&v28 + 1, v21, v18, v19);
        *((_DWORD *)v9 + (_QWORD)v20) = HIDWORD(v28);
        v20 = (const unsigned int *)((char *)v20 + 1);
      }
      while (a4 != v20);
      CA::OGL::SW::tex_multiply_color(v16, a3, v10, (uint64_t)a4);
      do
      {
        v22 = *v16++;
        HIDWORD(v28) = *(_DWORD *)v9;
        result = CA::OGL::SW::Blend::SeparableMode<CA::OGL::SW::Blend::ColorBurn>::f((int *)&v28 + 1, v22);
        *(_DWORD *)v9 = HIDWORD(v28);
        v9 = (CA::OGL::SW *)((char *)v9 + 4);
        a4 = (const unsigned int *)((char *)a4 - 1);
      }
      while (a4);
    }
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::DarkenSover::f(_DWORD *this, unsigned int *a2, unsigned int a3, const unsigned int *a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;

  v4 = *this;
  v5 = 19 * *this + 183 * BYTE1(v4) + 54 * BYTE2(v4);
  v6 = (v5 >> 8) * (v5 >> 8) + (v5 >> 8);
  v7 = ((((a2 | ((unint64_t)a2 << 24)) & 0xFF00FF00FF00FFLL)
       * ((((v6 >> 8) * (v6 >> 8) + (v6 >> 8)) >> 8) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
  v8 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * (unint64_t)((~(v7 >> 24) >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
  *this = ((v8 >> 24) | v8) + ((v7 >> 24) | v7);
  return this;
}

int *CA::OGL::SW::Blend::SeparableMode<CA::OGL::SW::Blend::ColorBurn>::f(int *result, unsigned int a2)
{
  unsigned int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  signed int v10;
  signed int v11;
  signed int v12;
  signed int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;

  v2 = HIBYTE(a2);
  v3 = BYTE2(a2);
  v4 = BYTE1(a2);
  v5 = a2;
  v6 = *result;
  v7 = HIBYTE(*result);
  v8 = v2 + 1;
  v9 = (v7 * (v2 + 1)) >> 8;
  if (v7 == 255)
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = (255 * (v2 + 1)) >> 8;
  }
  else
  {
    v14 = v7 ^ 0xFF;
    v13 = v9 + (((v7 ^ 0xFF) * v8) >> 8);
    v10 = (v14 + v14 * v3) >> 8;
    v11 = (v14 + v14 * v4) >> 8;
    v12 = (v14 + v14 * v5) >> 8;
  }
  v15 = BYTE2(v6);
  v16 = BYTE1(v6);
  v17 = *result;
  if (v2 != 255)
  {
    v18 = v2 ^ 0xFF;
    v13 += (v18 + v18 * v7) >> 8;
    v10 += (v18 + v18 * v15) >> 8;
    v11 += (v18 + v18 * v16) >> 8;
    v12 += (v18 + v18 * v17) >> 8;
  }
  if (v3)
    v10 = v10 + v9 - ((int)(((v8 * v2) >> 8) * ((int)(255 * (v7 - v15)) / v3) + ((v8 * v2) >> 8)) >> 8);
  if (v4)
    v11 = v11 + v9 - ((int)(((v8 * v2) >> 8) * ((int)(255 * (v7 - v16)) / v4) + ((v8 * v2) >> 8)) >> 8);
  if (v5)
    v12 = v12 + v9 - ((int)(((v8 * v2) >> 8) * ((int)(255 * (v7 - v17)) / v5) + ((v8 * v2) >> 8)) >> 8);
  if (v11 >= v13)
    v19 = v13;
  else
    v19 = v11;
  v20 = v19 & ~(v19 >> 31);
  if (v10 >= v13)
    v21 = v13;
  else
    v21 = v10;
  v22 = v21 & ~(v21 >> 31);
  if (v12 >= v13)
    v23 = v13;
  else
    v23 = v12;
  *result = (v22 << 16) | (v13 << 24) | (v20 << 8) | v23 & ~(v23 >> 31);
  return result;
}

_DWORD *CA::OGL::SW::Blend::LightenSover::f(_DWORD *this, unsigned int *a2, unsigned int a3, const unsigned int *a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;

  v4 = *this;
  v5 = 19 * *this + 183 * BYTE1(v4) + 54 * BYTE2(v4);
  v6 = (255 - (v5 >> 8)) * (256 - (v5 >> 8));
  v7 = ((((a2 | ((unint64_t)a2 << 24)) & 0xFF00FF00FF00FFLL)
       * ((((v6 >> 8) * (v6 >> 8) + (v6 >> 8)) >> 8) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
  v8 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * (unint64_t)((~(v7 >> 24) >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
  *this = ((v8 >> 24) | v8) + ((v7 >> 24) | v7);
  return this;
}

unsigned int *CA::OGL::SW::tex_mix(unsigned int *this, unsigned int *a2, unsigned int *a3, const unsigned int *a4, const unsigned int *a5)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;

  for (; a5; a5 = (const unsigned int *)((char *)a5 - 1))
  {
    v6 = *a2++;
    v5 = v6;
    v7 = *a3++;
    *this++ = ((v5 & 0xFF00FF) + (((*((unsigned __int8 *)a4 + 3) + 1) * ((v7 & 0xFF00FF) - (v5 & 0xFF00FF))) >> 8)) & 0xFF00FF | ((((v7 >> 8) & 0xFF00FF) - ((v5 >> 8) & 0xFF00FF)) * (*((unsigned __int8 *)a4 + 3) + 1) + (((v5 >> 8) & 0xFF00FF) << 8)) & 0xFF00FF00;
    ++a4;
  }
  return this;
}

void CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Clear,false>::blend(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
    bzero(a1, 4 * a4);
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Dest,false>::blend(_DWORD *result, int *a2, uint64_t a3, uint64_t a4)
{
  int v4;

  for (; a4; --a4)
  {
    v4 = *a2++;
    *result++ = v4;
  }
  return result;
}

vImage_Error CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Sover,true>::blend(void *a1, void *a2, void *a3, vImagePixelCount a4)
{
  vImage_Buffer dest;
  vImage_Buffer srcBottom;
  vImage_Buffer srcTop;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  srcTop.data = a3;
  srcTop.height = 1;
  srcTop.width = a4;
  srcTop.rowBytes = 4 * a4;
  srcBottom.data = a2;
  srcBottom.height = 1;
  srcBottom.width = a4;
  srcBottom.rowBytes = 4 * a4;
  dest.data = a1;
  dest.height = 1;
  dest.width = a4;
  dest.rowBytes = 4 * a4;
  return vImagePremultipliedAlphaBlend_BGRA8888(&srcTop, &srcBottom, &dest, 0x10u);
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Sin,true>::blend(_DWORD *result, uint64_t a2, unsigned int *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;

  if (a4 >= 2)
  {
    do
    {
      v4 = *a3;
      v5 = a3[1];
      a3 += 2;
      v6 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL)
           + ((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * (unint64_t)*(unsigned __int8 *)(a2 + 3)) >> 8) & 0xFF00FF00FF00FFLL;
      v7 = ((((v5 | (v5 << 24)) & 0xFF00FF00FF00FFLL)
           + ((v5 | (v5 << 24)) & 0xFF00FF00FF00FFLL) * (unint64_t)*(unsigned __int8 *)(a2 + 7)) >> 8) & 0xFF00FF00FF00FFLL;
      *result = (v6 >> 24) | v6;
      result[1] = (v7 >> 24) | v7;
      result += 2;
      a4 -= 2;
      a2 += 8;
    }
    while (a4 > 1);
  }
  if (a4)
  {
    v8 = (*a3 | ((unint64_t)*a3 << 24)) & 0xFF00FF00FF00FFLL;
    v9 = ((v8 + v8 * *(unsigned __int8 *)(a2 + 3)) >> 8) & 0xFF00FF00FF00FFLL;
    *result = (v9 >> 24) | v9;
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Sout,false>::blend(_DWORD *result, int *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  unint64_t v7;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * (unint64_t)((~v6 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = (v7 >> 24) | v7;
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Satop,false>::blend(_DWORD *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = ~(_DWORD)v4 >> 24;
    v8 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL)
         + ((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * ((unint64_t)v6 >> 24)) >> 8) & 0xFF00FF00FF00FFLL;
    v9 = ((((v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL) * (v7 + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = ((v9 >> 24) | v9) + ((v8 >> 24) | v8);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Dover,false>::blend(_DWORD *result, int *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  unint64_t v7;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * (unint64_t)((~v6 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = v6 + ((v7 >> 24) | v7);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Din,false>::blend(_DWORD *result, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;

  for (; a4; --a4)
  {
    v4 = *a2++;
    v5 = (v4 | ((unint64_t)v4 << 24)) & 0xFF00FF00FF00FFLL;
    v6 = ((v5 + v5 * *(unsigned __int8 *)(a3 + 3)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = (v6 >> 24) | v6;
    a3 += 4;
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Dout,false>::blend(_DWORD *result, unsigned int *a2, int *a3, uint64_t a4)
{
  int v4;
  int v5;
  unsigned int v6;
  unint64_t v7;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = ((((v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL) * ((~v4 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = (v7 >> 24) | v7;
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Datop,false>::blend(_DWORD *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = (v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL;
    v8 = ((v7 + v7 * (v4 >> 24)) >> 8) & 0xFF00FF00FF00FFLL;
    v9 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * ((~v6 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = ((v8 >> 24) | v8) + ((v9 >> 24) | v9);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Xor,false>::blend(_DWORD *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = ~(_DWORD)v4 >> 24;
    v8 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * (unint64_t)((~v6 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    v9 = ((((v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL) * (v7 + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = ((v9 >> 24) | v9) + ((v8 >> 24) | v8);
  }
  return result;
}

uint8x16_t *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Add,true>::blend(uint8x16_t *result, uint8x16_t *a2, uint8x16_t *a3, unint64_t a4)
{
  uint8x16_t v4;
  uint8x16_t v5;
  uint8x16_t v6;
  unsigned __int32 v7;
  __int32 v8;
  unsigned __int32 v9;
  unsigned int v10;
  int v11;

  if (a4 >= 4)
  {
    do
    {
      v4 = *a3++;
      v5 = v4;
      v6 = *a2++;
      *result++ = vqaddq_u8(v5, v6);
      a4 -= 4;
    }
    while (a4 > 3);
  }
  for (; a4; --a4)
  {
    v8 = a3->i32[0];
    a3 = (uint8x16_t *)((char *)a3 + 4);
    v7 = v8;
    v9 = a2->i32[0];
    a2 = (uint8x16_t *)((char *)a2 + 4);
    v10 = (v9 & 0xFF00FF) + (v7 & 0xFF00FF);
    v11 = ((v9 >> 8) & 0xFF00FF) + ((v7 >> 8) & 0xFF00FF);
    result->i32[0] = (v11 << 8) & 0xFF00FF00 | v10 & 0xFF00FF | (15 * (v11 & 0x1000100 | (v10 >> 8) & 0x10001)) | (240 * (v11 & 0x1000100 | (v10 >> 8) & 0x10001));
    result = (uint8x16_t *)((char *)result + 4);
  }
  return result;
}

unsigned __int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::SubS,false>::blend(unsigned __int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  uint32x2_t v7;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = vshl_u32((uint32x2_t)vmax_s32(vsub_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), 0), (uint32x2_t)0x800000010);
    *result++ = (v6 - v4) & ~((v6 - v4) >> 31) | (((HIBYTE(v6) - HIBYTE(v4)) & ~((int)(HIBYTE(v6) - HIBYTE(v4)) >> 31)) << 24) | v7.i32[0] | v7.i32[1];
  }
  return result;
}

unsigned __int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::SubD,false>::blend(unsigned __int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  uint32x2_t v7;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = vshl_u32((uint32x2_t)vmax_s32(vsub_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), 0), (uint32x2_t)0x800000010);
    *result++ = (v4 - v6) & ~((v4 - v6) >> 31) | (((HIBYTE(v4) - HIBYTE(v6)) & ~((int)(HIBYTE(v4) - HIBYTE(v6)) >> 31)) << 24) | v7.i32[0] | v7.i32[1];
  }
  return result;
}

unsigned __int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Mul,false>::blend(unsigned __int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  int8x8_t v7;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = vand_s8((int8x8_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v4 >> 8), (int8x8_t)0xFF0000FF00), vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (int32x2_t)0x100000001)), (int8x8_t)0x1FF0001FF0000);
    *result++ = (((v4 >> 8) & 0xFF0000) + ((v4 >> 8) & 0xFF0000) * HIBYTE(v6)) & 0xFF000000 | ((v4
                                                                                              * v6
                                                                                              + v4) >> 8) | v7.i32[0] | v7.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Screen,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int8x8_t v9;
  int v10;
  unsigned int v11;
  signed int v12;
  int32x2_t v13;
  signed int v14;
  double v15;
  unsigned int v16;
  BOOL v17;
  unsigned int v18;
  int32x2_t v19;
  signed int v20;
  uint32x2_t v21;
  unsigned int v22;
  unsigned int v23;
  double v24;
  uint32x2_t v25;
  int32x2_t v26;
  int32x2_t v27;
  int v28;
  uint32x2_t v29;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = HIBYTE(v4);
    v8 = HIBYTE(v6);
    v9 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
    v10 = v6;
    v11 = HIBYTE(v4) + 1;
    v12 = (HIBYTE(v6) * v11) >> 8;
    v13 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v14 = v12 + (((HIBYTE(v6) ^ 0xFF) * v11) >> 8);
    v15 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v13, (int32x2_t)0x100000001)), 8uLL));
    v16 = ((v8 ^ 0xFF) + (v8 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255)
      v16 = 0;
    if (v8 == 255)
      v15 = 0.0;
    else
      v12 = v14;
    v17 = v7 == 255;
    v18 = v7 ^ 0xFF;
    v19 = (int32x2_t)vand_s8(v9, (int8x8_t)0xFF000000FFLL);
    v20 = v12 + (((v8 + 1) * v18) >> 8);
    v21 = (uint32x2_t)vmul_s32(vadd_s32(v19, (int32x2_t)0x100000001), vdup_n_s32(v18));
    v22 = v16 + ((v18 + v18 * v10) >> 8);
    v23 = v8 + 1;
    if (v17)
      v22 = v16;
    if (!v17)
      v12 = v20;
    v24 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v15, v21, 8uLL));
    v25 = (uint32x2_t)vmul_s32(v19, vdup_n_s32(v11));
    v26 = vdup_n_s32(v23);
    if (!v17)
      v15 = v24;
    v27 = vsub_s32(v26, v19);
    v28 = ((int)((v23 - v10) * v4) >> 8) + ((v10 * v11) >> 8) + v22;
    if (v28 >= v12)
      v28 = v12;
    v29 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(vadd_s32((int32x2_t)vsra_n_u32((uint32x2_t)vshr_n_s32(vmul_s32(v27, v13), 8uLL), v25, 8uLL), *(int32x2_t *)&v15), vdup_n_s32(v12)), 0), (uint32x2_t)0x800000010);
    *result++ = v28 & ~(v28 >> 31) | (v12 << 24) | v29.i32[0] | v29.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Min,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int v10;
  uint32x2_t v11;
  unsigned int v12;
  uint32x2_t v13;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v7 = *a2++;
    v6 = v7;
    v8 = v4;
    v9 = HIBYTE(v7);
    v10 = v7;
    if (v4 >= v7)
      v8 = v10;
    v11 = (uint32x2_t)vdup_n_s32(v4);
    if (HIBYTE(v4) >= HIBYTE(v6))
      v12 = v9;
    else
      v12 = HIBYTE(v4);
    v13 = vshl_u32(vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32(v11, (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), (uint32x2_t)0x800000010);
    *result++ = v13.i32[0] | (v12 << 24) | v8 | v13.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::LinearDodge,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  signed int v11;
  int32x2_t v12;
  signed int v13;
  int32x2_t v14;
  double v15;
  unsigned int v16;
  signed int v17;
  BOOL v18;
  uint32x2_t v19;
  unsigned int v20;
  unsigned int v21;
  double v22;
  uint32x2_t v23;
  uint32x2_t v24;
  unsigned int v25;
  signed int v26;
  uint32x2_t v27;
  uint32x2_t v28;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = HIBYTE(v4);
    v8 = HIBYTE(v6);
    v9 = v6;
    v10 = HIBYTE(v4) + 1;
    v11 = (HIBYTE(v6) * v10) >> 8;
    v12 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v13 = v11 + (((HIBYTE(v6) ^ 0xFF) * v10) >> 8);
    v14 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v15 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v12, (int32x2_t)0x100000001)), 8uLL));
    v16 = ((v8 ^ 0xFF) + (v8 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255)
      v16 = 0;
    if (v8 == 255)
      v15 = 0.0;
    else
      v11 = v13;
    v17 = v11 + (((v8 + 1) * (v7 ^ 0xFF)) >> 8);
    v18 = v7 == 255;
    v19 = (uint32x2_t)vmul_s32(vadd_s32(v14, (int32x2_t)0x100000001), vdup_n_s32(v7 ^ 0xFF));
    v20 = v16 + (((v7 ^ 0xFF) + (v7 ^ 0xFF) * v9) >> 8);
    v21 = v8 + 1;
    if (v18)
      v20 = v16;
    if (!v18)
      v11 = v17;
    v22 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v15, v19, 8uLL));
    v23 = (uint32x2_t)vmul_s32(v14, vdup_n_s32(v10));
    v24 = (uint32x2_t)vmul_s32(vdup_n_s32(v21), v12);
    v25 = v9 * v10;
    if (!v18)
      v15 = v22;
    v26 = ((v21 * v4) >> 8) + (v25 >> 8) + v20;
    v27 = (uint32x2_t)vmin_s32(vadd_s32((int32x2_t)vsra_n_u32(vshr_n_u32(v23, 8uLL), v24, 8uLL), *(int32x2_t *)&v15), vdup_n_s32(v11));
    if (v26 >= v11)
      v26 = v11;
    v28 = vshl_u32(v27, (uint32x2_t)0x800000010);
    *result++ = v26 | (v11 << 24) | v28.i32[0] | v28.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Exclusion,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  signed int v11;
  int32x2_t v12;
  signed int v13;
  int32x2_t v14;
  double v15;
  unsigned int v16;
  BOOL v17;
  unsigned int v18;
  signed int v19;
  uint32x2_t v20;
  unsigned int v21;
  unsigned int v22;
  int32x2_t v23;
  double v24;
  uint32x2_t v25;
  int32x2_t v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  uint32x2_t v30;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = HIBYTE(v4);
    v8 = HIBYTE(v6);
    v9 = v6;
    v10 = HIBYTE(v4) + 1;
    v11 = (HIBYTE(v6) * v10) >> 8;
    v12 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v13 = v11 + (((HIBYTE(v6) ^ 0xFF) * v10) >> 8);
    v14 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v15 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v12, (int32x2_t)0x100000001)), 8uLL));
    v16 = ((v8 ^ 0xFF) + (v8 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255)
      v16 = 0;
    if (v8 == 255)
      v15 = 0.0;
    else
      v11 = v13;
    v17 = v7 == 255;
    v18 = v7 ^ 0xFF;
    v19 = v11 + (((v8 + 1) * v18) >> 8);
    v20 = (uint32x2_t)vmul_s32(vadd_s32(v14, (int32x2_t)0x100000001), vdup_n_s32(v18));
    v21 = v16 + ((v18 + v18 * v9) >> 8);
    v22 = v8 + 1;
    if (v17)
      v21 = v16;
    v23 = vdup_n_s32(v10);
    v24 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v15, v20, 8uLL));
    if (!v17)
      v11 = v19;
    v25 = (uint32x2_t)vmul_s32(v14, v23);
    v26 = vadd_s32(v14, v14);
    v27 = v9 * v10;
    v28 = v22 - 2 * v9;
    if (!v17)
      v15 = v24;
    v29 = ((int)(v28 * v4) >> 8) + (v27 >> 8) + v21;
    if (v29 >= v11)
      v29 = v11;
    v30 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(vadd_s32((int32x2_t)vsra_n_u32((uint32x2_t)vshr_n_s32(vmul_s32(vsub_s32(vdup_n_s32(v22), v26), v12), 8uLL), v25, 8uLL), *(int32x2_t *)&v15), vdup_n_s32(v11)), 0), (uint32x2_t)0x800000010);
    *result++ = v29 & ~(v29 >> 31) | (v11 << 24) | v30.i32[0] | v30.i32[1];
  }
  return result;
}

unsigned int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::SoverMulD,false>::blend(unsigned int *result, unsigned int *a2, int *a3, uint64_t a4)
{
  int v4;
  int v5;
  unsigned int v6;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    *result++ = ((v4 & 0xFF00FF) + ((((v6 & 0xFF00FF) - (v4 & 0xFF00FF)) * (HIBYTE(v6) + 1)) >> 8)) & 0xFF00FF | ((v4 & 0xFF00) + (BYTE1(v6) - (unsigned __int16)BYTE1(v4)) * (HIBYTE(v6) + 1)) & 0xFF00 | 0xFF000000;
  }
  return result;
}

int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::AlphaCopy,false>::blend(int *result, int *a2, uint64_t a3, uint64_t a4)
{
  int v4;

  for (; a4; --a4)
  {
    v4 = *a2++;
    *result++ = v4 & 0xFFFFFF | (*(unsigned __int8 *)(a3 + 3) << 24);
    a3 += 4;
  }
  return result;
}

unsigned int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::AlphaMul,false>::blend(unsigned int *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    *result++ = ((((v4 >> 8) & 0xFF0000) + 0x10000) * HIBYTE(v6)) & 0xFF000000 | v6 & 0xFFFFFF;
  }
  return result;
}

int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::PlusD,true>::blend(int *result, unsigned int *a2, unsigned int *a3, unint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int8x8_t v11;
  int8x8_t v12;
  signed int v13;
  int v14;
  unsigned int v15;
  int v16;
  uint32x2_t v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  int8x8_t v25;
  int8x8_t v26;
  signed int v27;
  int v28;
  unsigned int v29;
  int v30;
  uint32x2_t v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  int8x8_t v39;
  int8x8_t v40;
  signed int v41;
  int v42;
  unsigned int v43;
  int v44;
  uint32x2_t v45;

  if (a4 >= 2)
  {
    do
    {
      v4 = *a3;
      v5 = *a2;
      if ((*a2 & *a3) >> 24 == 255)
      {
        v6 = ~v5;
        v7 = (~v5 & 0xFF00FF) + (~v4 & 0xFF00FF);
        v8 = ((v6 >> 8) & 0xFF00FF) + ((~v4 >> 8) & 0xFF00FF);
        v9 = ~((v8 << 8) & 0x7F00FF00 | v7 & 0xFF00FF | (15 * (v8 & 0x1000100 | (v7 >> 8) & 0x10001)) | (240 * (v8 & 0x1000100 | (v7 >> 8) & 0x10001)));
      }
      else
      {
        v10 = HIBYTE(v4);
        v11 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
        v12 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v5), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
        v13 = HIBYTE(v5) + HIBYTE(v4);
        v14 = v10 - (*a3 + v5) + HIBYTE(v5);
        if (v13 >= 255)
          v15 = 255;
        else
          v15 = v13;
        v16 = v14 & ~(v14 >> 31);
        if (v16 >= 255)
          v16 = 255;
        v17 = vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v15), vmin_s32(vmax_s32(vsub_s32(vdup_n_s32(v13), vadd_s32((int32x2_t)vand_s8(v12, (int8x8_t)0xFF000000FFLL), (int32x2_t)vand_s8(v11, (int8x8_t)0xFF000000FFLL))), 0), (int32x2_t)0xFF000000FFLL)), (uint32x2_t)0x800000010);
        v9 = (v15 - v16) | (v15 << 24) | v17.i32[0] | v17.i32[1];
      }
      v18 = a3[1];
      v19 = a2[1];
      if ((v19 & v18) >> 24 == 255)
      {
        v20 = ~v19;
        v21 = (~v19 & 0xFF00FF) + (~v18 & 0xFF00FF);
        v22 = ((v20 >> 8) & 0xFF00FF) + ((~v18 >> 8) & 0xFF00FF);
        v23 = ~((v22 << 8) & 0x7F00FF00 | v21 & 0xFF00FF | (15 * (v22 & 0x1000100 | (v21 >> 8) & 0x10001)) | (240 * (v22 & 0x1000100 | (v21 >> 8) & 0x10001)));
      }
      else
      {
        v24 = HIBYTE(v18);
        v25 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v18), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
        v26 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v19), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
        v27 = HIBYTE(v19) + HIBYTE(v18);
        v28 = v24 - (a3[1] + v19) + HIBYTE(v19);
        if (v27 >= 255)
          v29 = 255;
        else
          v29 = v27;
        v30 = v28 & ~(v28 >> 31);
        if (v30 >= 255)
          v30 = 255;
        v31 = vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v29), vmin_s32(vmax_s32(vsub_s32(vdup_n_s32(v27), vadd_s32((int32x2_t)vand_s8(v26, (int8x8_t)0xFF000000FFLL), (int32x2_t)vand_s8(v25, (int8x8_t)0xFF000000FFLL))), 0), (int32x2_t)0xFF000000FFLL)), (uint32x2_t)0x800000010);
        v23 = (v29 - v30) | (v29 << 24) | v31.i32[0] | v31.i32[1];
      }
      a4 -= 2;
      *result = v9;
      result[1] = v23;
      result += 2;
      a2 += 2;
      a3 += 2;
    }
    while (a4 > 1);
  }
  if (a4)
  {
    v32 = *a3;
    v33 = *a2;
    if ((*a2 & *a3) >> 24 == 255)
    {
      v34 = ~v33;
      v35 = (~v33 & 0xFF00FF) + (~v32 & 0xFF00FF);
      v36 = ((v34 >> 8) & 0xFF00FF) + ((~v32 >> 8) & 0xFF00FF);
      v37 = ~((v36 << 8) & 0x7F00FF00 | v35 & 0xFF00FF | (15 * (v36 & 0x1000100 | (v35 >> 8) & 0x10001)) | (240 * (v36 & 0x1000100 | (v35 >> 8) & 0x10001)));
    }
    else
    {
      v38 = HIBYTE(v32);
      v39 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v32), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
      v40 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v33), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
      v41 = HIBYTE(v33) + HIBYTE(v32);
      v42 = v38 - (*a3 + v33) + HIBYTE(v33);
      if (v41 >= 255)
        v43 = 255;
      else
        v43 = v41;
      v44 = v42 & ~(v42 >> 31);
      if (v44 >= 255)
        v44 = 255;
      v45 = vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v43), vmin_s32(vmax_s32(vsub_s32(vdup_n_s32(v41), vadd_s32((int32x2_t)vand_s8(v40, (int8x8_t)0xFF000000FFLL), (int32x2_t)vand_s8(v39, (int8x8_t)0xFF000000FFLL))), 0), (int32x2_t)0xFF000000FFLL)), (uint32x2_t)0x800000010);
      v37 = (v43 - v44) | (v43 << 24) | v45.i32[0] | v45.i32[1];
    }
    *result = v37;
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Multiply,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int32x2_t v10;
  int v11;
  int32x2_t v12;
  unsigned int v13;
  signed int v14;
  unsigned int v15;
  double v16;
  unsigned int v17;
  BOOL v18;
  signed int v19;
  int32x2_t v20;
  uint32x2_t v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  double v25;
  signed int v26;
  uint32x2_t v27;
  uint32x2_t v28;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = HIBYTE(v4);
    v8 = v4;
    v9 = HIBYTE(v6);
    v10 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v11 = v6;
    v12 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v13 = (HIBYTE(v6) * (v7 + 1)) >> 8;
    v14 = v13 + (((HIBYTE(v6) ^ 0xFF) * (v7 + 1)) >> 8);
    v15 = ((v9 ^ 0xFF) + (v9 ^ 0xFF) * v8) >> 8;
    v16 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v10, (int32x2_t)0x100000001)), 8uLL));
    if (HIBYTE(v6) == 255)
      v15 = 0;
    if (v9 == 255)
    {
      v14 = v13;
      v16 = 0.0;
    }
    v17 = v7 ^ 0xFF;
    v18 = v7 == 255;
    v19 = v14 + ((v17 + v17 * v9) >> 8);
    v20 = vadd_s32(v12, (int32x2_t)0x100000001);
    v21 = (uint32x2_t)vmul_s32(v20, vdup_n_s32(v17));
    v22 = v15 + (((v11 + 1) * v17) >> 8);
    v23 = v11 + 1;
    if (v18)
      v24 = v15;
    else
      v24 = v22;
    v25 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v16, v21, 8uLL));
    if (!v18)
    {
      v14 = v19;
      v16 = v25;
    }
    v26 = v24 + ((v23 * v8) >> 8);
    v27 = (uint32x2_t)vmin_s32((int32x2_t)vsra_n_u32(*(uint32x2_t *)&v16, (uint32x2_t)vmul_s32(v20, v10), 8uLL), vdup_n_s32(v14));
    if (v26 >= v14)
      v26 = v14;
    v28 = vshl_u32(v27, (uint32x2_t)0x800000010);
    *result++ = v26 | (v14 << 24) | v28.i32[0] | v28.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Overlay,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  int v5;
  int32x2_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int32x2_t v10;
  signed int v11;
  int32x2_t v12;
  int32x2_t v13;
  unsigned int v14;
  uint32x2_t v15;
  int v16;
  signed int v17;
  int32x2_t v18;
  double v19;
  int32x2_t v20;
  unsigned int v21;
  unsigned __int32 v22;
  unsigned int v23;
  unsigned __int32 v24;
  unsigned int v25;
  __int32 v26;
  __int32 v27;
  unsigned int v28;
  unsigned int v29;
  double v30;
  int32x2_t v31;
  unsigned int v32;
  BOOL v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  int32x2_t v44;
  uint32x2_t v45;

  for (; a4; --a4)
  {
    v4 = HIBYTE(*a3);
    v5 = *a3;
    v6 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v7 = HIBYTE(*a2);
    v8 = *a2;
    v9 = v4 + 1;
    v10 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*a2), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v11 = (v7 * (v4 + 1)) >> 8;
    v12 = vadd_s32(v6, (int32x2_t)0x100000001);
    v13 = vdup_n_s32(v7 ^ 0xFF);
    v14 = ((v7 ^ 0xFF) + (v7 ^ 0xFF) * v5) >> 8;
    if (v7 == 255)
      v14 = 0;
    v15 = (uint32x2_t)vmul_s32(v13, v12);
    if (v7 != 255)
      v11 += ((v7 ^ 0xFF) * (v4 + 1)) >> 8;
    v16 = v4 ^ 0xFF;
    v17 = v11 + ((v16 + v16 * v7) >> 8);
    v18 = vadd_s32(v10, (int32x2_t)0x100000001);
    v19 = COERCE_DOUBLE(vshr_n_u32(v15, 8uLL));
    v20 = vdup_n_s32(v4 ^ 0xFF);
    v21 = v16 + v16 * v8;
    v22 = v10.u32[1];
    if (v7 == 255)
      v19 = 0.0;
    v23 = v14 + (v21 >> 8);
    v24 = v10.i32[0];
    v25 = v7 + 1;
    v26 = v6.i32[0];
    v27 = v6.i32[1];
    if (v4 != 255)
      v14 = v23;
    v28 = ((v25 * v6.i32[0]) >> 8) + ((int)(v10.i32[0] * (v9 - v6.i32[0])) >> 8);
    if (v4 != 255)
      v11 = v17;
    v29 = ((v25 * v6.i32[1]) >> 8) + ((int)(v10.i32[1] * (v9 - v6.i32[1])) >> 8);
    v30 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v19, (uint32x2_t)vmul_s32(v18, v20), 8uLL));
    if (v4 == 255)
      *(double *)&v31 = v19;
    else
      *(double *)&v31 = v30;
    v32 = *a2 >> 25;
    v33 = v32 >= v24;
    v34 = v25 * v4;
    v35 = 2 * v28 - (v34 >> 8);
    v36 = ((v24 + v24 * v26) >> 7) & 0x3FE;
    v37 = 2 * v29;
    if (v33)
      v35 = v36;
    v38 = v37 - (v34 >> 8);
    v39 = 2 * (((v25 * v5) >> 8) + ((int)(v8 * (v9 - v5)) >> 8));
    if (v32 >= v22)
      v40 = ((v22 + v22 * v27) >> 7) & 0x3FE;
    else
      v40 = v38;
    v41 = v39 - (v34 >> 8);
    v42 = ((v8 + v8 * v5) >> 7) & 0x3FE;
    if (v32 < v8)
      v42 = v41;
    v43 = v42 + v14;
    v44 = vadd_s32((int32x2_t)__PAIR64__(v40, v35), v31);
    if (v43 >= v11)
      v43 = v11;
    v45 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(v44, vdup_n_s32(v11)), 0), (uint32x2_t)0x800000010);
    *result++ = v45.i32[0] | (v11 << 24) | v43 & ~(v43 >> 31) | v45.i32[1];
    ++a2;
    ++a3;
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Darken,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int8x8_t v9;
  int v10;
  unsigned int v11;
  signed int v12;
  int32x2_t v13;
  signed int v14;
  double v15;
  unsigned int v16;
  BOOL v17;
  unsigned int v18;
  int32x2_t v19;
  signed int v20;
  uint32x2_t v21;
  unsigned int v22;
  unsigned int v23;
  double v24;
  int32x2_t v25;
  int32x2_t v26;
  uint32x2_t v27;
  uint32x2_t v28;
  signed int v29;
  signed int v30;
  uint32x2_t v31;
  uint32x2_t v32;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = HIBYTE(v4);
    v8 = HIBYTE(v6);
    v9 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
    v10 = v6;
    v11 = HIBYTE(v4) + 1;
    v12 = (HIBYTE(v6) * v11) >> 8;
    v13 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v14 = v12 + (((HIBYTE(v6) ^ 0xFF) * v11) >> 8);
    v15 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v13, (int32x2_t)0x100000001)), 8uLL));
    v16 = ((v8 ^ 0xFF) + (v8 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255)
      v16 = 0;
    if (v8 == 255)
      v15 = 0.0;
    else
      v12 = v14;
    v17 = v7 == 255;
    v18 = v7 ^ 0xFF;
    v19 = (int32x2_t)vand_s8(v9, (int8x8_t)0xFF000000FFLL);
    v20 = v12 + (((v8 + 1) * v18) >> 8);
    v21 = (uint32x2_t)vmul_s32(vadd_s32(v19, (int32x2_t)0x100000001), vdup_n_s32(v18));
    v22 = v16 + ((v18 + v18 * v10) >> 8);
    v23 = v8 + 1;
    if (v17)
      v22 = v16;
    v24 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v15, v21, 8uLL));
    if (!v17)
      v12 = v20;
    v25 = vdup_n_s32(v23);
    v26 = vdup_n_s32(v11);
    if (!v17)
      v15 = v24;
    v27 = (uint32x2_t)vmul_s32(v25, v13);
    v28 = (uint32x2_t)vmul_s32(v19, v26);
    v29 = (v23 * v4) >> 8;
    if (v29 >= (int)((v10 * v11) >> 8))
      v29 = (v10 * v11) >> 8;
    v30 = v22 + v29;
    v31 = (uint32x2_t)vmin_s32(vadd_s32(*(int32x2_t *)&v15, vmin_s32((int32x2_t)vshr_n_u32(v27, 8uLL), (int32x2_t)vshr_n_u32(v28, 8uLL))), vdup_n_s32(v12));
    if (v30 >= v12)
      v30 = v12;
    v32 = vshl_u32(v31, (uint32x2_t)0x800000010);
    *result++ = v30 | (v12 << 24) | v32.i32[0] | v32.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Lighten,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int8x8_t v9;
  int v10;
  unsigned int v11;
  signed int v12;
  int32x2_t v13;
  signed int v14;
  double v15;
  unsigned int v16;
  BOOL v17;
  unsigned int v18;
  int32x2_t v19;
  signed int v20;
  uint32x2_t v21;
  unsigned int v22;
  unsigned int v23;
  double v24;
  int32x2_t v25;
  int32x2_t v26;
  uint32x2_t v27;
  uint32x2_t v28;
  signed int v29;
  signed int v30;
  uint32x2_t v31;
  uint32x2_t v32;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = HIBYTE(v4);
    v8 = HIBYTE(v6);
    v9 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
    v10 = v6;
    v11 = HIBYTE(v4) + 1;
    v12 = (HIBYTE(v6) * v11) >> 8;
    v13 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v14 = v12 + (((HIBYTE(v6) ^ 0xFF) * v11) >> 8);
    v15 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v13, (int32x2_t)0x100000001)), 8uLL));
    v16 = ((v8 ^ 0xFF) + (v8 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255)
      v16 = 0;
    if (v8 == 255)
      v15 = 0.0;
    else
      v12 = v14;
    v17 = v7 == 255;
    v18 = v7 ^ 0xFF;
    v19 = (int32x2_t)vand_s8(v9, (int8x8_t)0xFF000000FFLL);
    v20 = v12 + (((v8 + 1) * v18) >> 8);
    v21 = (uint32x2_t)vmul_s32(vadd_s32(v19, (int32x2_t)0x100000001), vdup_n_s32(v18));
    v22 = v16 + ((v18 + v18 * v10) >> 8);
    v23 = v8 + 1;
    if (v17)
      v22 = v16;
    v24 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v15, v21, 8uLL));
    if (!v17)
      v12 = v20;
    v25 = vdup_n_s32(v23);
    v26 = vdup_n_s32(v11);
    if (!v17)
      v15 = v24;
    v27 = (uint32x2_t)vmul_s32(v25, v13);
    v28 = (uint32x2_t)vmul_s32(v19, v26);
    v29 = (v23 * v4) >> 8;
    if (v29 <= (int)((v10 * v11) >> 8))
      v29 = (v10 * v11) >> 8;
    v30 = v22 + v29;
    v31 = (uint32x2_t)vmin_s32(vadd_s32(*(int32x2_t *)&v15, vmax_s32((int32x2_t)vshr_n_u32(v27, 8uLL), (int32x2_t)vshr_n_u32(v28, 8uLL))), vdup_n_s32(v12));
    if (v30 >= v12)
      v30 = v12;
    v32 = vshl_u32(v31, (uint32x2_t)0x800000010);
    *result++ = v30 | (v12 << 24) | v32.i32[0] | v32.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::ColorDodge,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  int32x2_t v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  signed int v9;
  unsigned int v10;
  int32x2_t v11;
  int32x2_t v12;
  int v13;
  int v14;
  unsigned int v15;
  signed int v16;
  signed int v17;
  int v18;
  int32x2_t v19;
  int v20;
  uint32x2_t v21;

  for (; a4; --a4)
  {
    v4 = HIBYTE(*a3);
    v5 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v6 = *a3;
    v7 = HIBYTE(*a2);
    v8 = v4 + 1;
    v9 = (v7 * (v4 + 1)) >> 8;
    if (v7 == 255)
    {
      v10 = 0;
      v11 = 0;
    }
    else
    {
      v9 += ((v7 ^ 0xFF) * v8) >> 8;
      v11 = (int32x2_t)vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(v7 ^ 0xFF), vadd_s32(v5, (int32x2_t)0x100000001)), 8uLL);
      v10 = ((v7 ^ 0xFF) + (v7 ^ 0xFF) * v6) >> 8;
    }
    v12 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*a2), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v13 = *a2;
    if (v4 != 255)
    {
      v14 = v4 ^ 0xFF;
      v9 += (v14 + v14 * v7) >> 8;
      v11 = (int32x2_t)vsra_n_u32((uint32x2_t)v11, (uint32x2_t)vmul_s32(vadd_s32(v12, (int32x2_t)0x100000001), vdup_n_s32(v4 ^ 0xFF)), 8uLL);
      v10 += (v14 + v14 * v13) >> 8;
    }
    v15 = v8 * v4;
    v16 = HIBYTE(*a3);
    if (v4 > v5.i32[0])
    {
      v16 = (int)(255 * ((v12.i32[0] + v12.i32[0] * (v15 >> 8)) >> 8)) / (int)(v4 - v5.i32[0]);
      if (v16 >= (int)v4)
        v16 = HIBYTE(*a3);
    }
    v17 = HIBYTE(*a3);
    if (v4 > v5.i32[1])
    {
      v17 = (int)(255 * ((v12.i32[1] + v12.i32[1] * (v15 >> 8)) >> 8)) / (int)(v4 - v5.i32[1]);
      if (v17 >= (int)v4)
        v17 = HIBYTE(*a3);
    }
    v18 = (int)(255 * ((v13 + v13 * (v15 >> 8)) >> 8)) / (int)(v4 - v6);
    if (v18 >= (int)v4)
      v18 = HIBYTE(*a3);
    if (v4 > v6)
      v4 = v18;
    v19 = vadd_s32((int32x2_t)__PAIR64__(v17, v16), v11);
    v20 = v4 + v10;
    if (v20 >= v9)
      v20 = v9;
    v21 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(v19, vdup_n_s32(v9)), 0), (uint32x2_t)0x800000010);
    *result++ = v21.i32[0] | (v9 << 24) | v20 & ~(v20 >> 31) | v21.i32[1];
    ++a2;
    ++a3;
  }
  return result;
}

int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::ColorBurn,false>::blend(int *result, int *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v4;
  int *v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v4 = a4;
    v7 = result;
    do
    {
      v9 = *a3++;
      v8 = v9;
      v10 = *a2++;
      v11 = v10;
      result = CA::OGL::SW::Blend::SeparableMode<CA::OGL::SW::Blend::ColorBurn>::f(&v11, v8);
      *v7++ = v11;
      --v4;
    }
    while (v4);
  }
  return result;
}

int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::SoftLight,false>::blend(int *result, _DWORD *a2, _DWORD *a3, uint64_t a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  signed int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  signed int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  signed int v23;
  signed int v24;
  signed int v25;
  int v26;
  int v27;
  int v28;
  int v29;

  for (; a4; --a4)
  {
    v4 = HIBYTE(*a3);
    v5 = BYTE2(*a3);
    v6 = BYTE1(*a3);
    v7 = *a3;
    v8 = HIBYTE(*a2);
    v9 = BYTE2(*a2);
    v10 = BYTE1(*a2);
    v11 = *a2;
    v12 = v8 ^ 0xFF;
    v13 = ((v8 * (v4 + 1)) >> 8) + (((v8 ^ 0xFF) * (v4 + 1)) >> 8);
    v14 = (v12 + v12 * v5) >> 8;
    v15 = (v12 + v12 * v6) >> 8;
    v16 = (v12 + v12 * v7) >> 8;
    if (v8 == 255)
    {
      v14 = 0;
      v15 = 0;
      v16 = 0;
      v13 = (255 * (v4 + 1)) >> 8;
    }
    v17 = v4 ^ 0xFF;
    v18 = v13 + ((v17 + v17 * v8) >> 8);
    v19 = v14 + ((v17 + v17 * v9) >> 8);
    v20 = v15 + ((v17 + v17 * v10) >> 8);
    v21 = v16 + ((v17 + v17 * v11) >> 8);
    if (v4 == 255)
    {
      v19 = v14;
      v22 = v15;
    }
    else
    {
      v22 = v20;
    }
    if (v4 != 255)
    {
      v16 = v21;
      v13 = v18;
    }
    v23 = v19 + (((v9 + v9 * v5) >> 7) & 0x3FE);
    if (v8)
    {
      v23 -= (int)(255 * v9 / v8 + 255 * v9 / v8 * ((v9 + v9 * (2 * v5 - v4)) >> 8)) >> 8;
      v24 = v22
          + (((v10 + v10 * v6) >> 7) & 0x3FE)
          - ((int)(255 * v10 / v8 + 255 * v10 / v8 * ((v10 + v10 * (2 * v6 - v4)) >> 8)) >> 8);
      v25 = v16
          + (((v11 + v11 * v7) >> 7) & 0x3FE)
          - ((int)(255 * v11 / v8 + 255 * v11 / v8 * ((v11 + v11 * (2 * v7 - v4)) >> 8)) >> 8);
    }
    else
    {
      v24 = v22 + (((v10 + v10 * v6) >> 7) & 0x3FE);
      v25 = v16 + (((v11 + v11 * v7) >> 7) & 0x3FE);
    }
    if (v24 >= v13)
      v26 = v13;
    else
      v26 = v24;
    v27 = v26 & ~(v26 >> 31);
    if (v23 >= v13)
      v28 = v13;
    else
      v28 = v23;
    v29 = v28 & ~(v28 >> 31);
    if (v25 >= v13)
      v25 = v13;
    *result++ = (v29 << 16) | (v13 << 24) | (v27 << 8) | v25 & ~(v25 >> 31);
    ++a2;
    ++a3;
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::HardLight,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int32x2_t v9;
  unsigned int v10;
  int v11;
  int v12;
  int32x2_t v13;
  signed int v14;
  signed int v15;
  int32x2_t v16;
  int32x2_t v17;
  unsigned int v18;
  uint32x2_t v19;
  unsigned int v20;
  int32x2_t v21;
  unsigned __int32 v22;
  double v23;
  unsigned __int32 v24;
  __int32 v25;
  double v26;
  __int32 v27;
  int v28;
  BOOL v29;
  int v30;
  int32x2_t v31;
  signed int v32;
  uint32x2_t v33;
  double v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  int32x2_t v45;
  uint32x2_t v46;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = HIBYTE(v4);
    v8 = v4;
    v9 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v10 = HIBYTE(v6);
    v11 = v6;
    v12 = HIBYTE(v4) + 1;
    v13 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v14 = (HIBYTE(v6) * v12) >> 8;
    v15 = v14 + (((HIBYTE(v6) ^ 0xFF) * v12) >> 8);
    v16 = vadd_s32(v9, (int32x2_t)0x100000001);
    v17 = vdup_n_s32(HIBYTE(v6) ^ 0xFF);
    v18 = ((v10 ^ 0xFF) + (v10 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255)
      v18 = 0;
    v19 = (uint32x2_t)vmul_s32(v17, v16);
    if (v10 != 255)
      v14 = v15;
    v20 = v7 ^ 0xFF;
    v21 = vadd_s32(v13, (int32x2_t)0x100000001);
    v22 = v9.u32[1];
    v23 = COERCE_DOUBLE(vshr_n_u32(v19, 8uLL));
    v24 = v9.i32[0];
    v25 = v13.i32[1];
    if (v10 == 255)
      v26 = 0.0;
    else
      v26 = v23;
    v27 = v13.i32[0];
    v28 = (v12 - v24) * (v10 - v13.i32[0]);
    v29 = v7 == 255;
    v30 = (v12 - v22) * (v10 - v13.i32[1]);
    if (v7 != 255)
      v18 += (v20 + v20 * v11) >> 8;
    v31 = vdup_n_s32(v20);
    v32 = v14 + ((v20 + v20 * v10) >> 8);
    v33 = (uint32x2_t)vmul_s32(v21, v31);
    if (v7 != 255)
      v14 = v32;
    v34 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v26, v33, 8uLL));
    v35 = v4 >> 25;
    v36 = (v7 + v7 * v10) >> 8;
    if (!v29)
      v26 = v34;
    v37 = v36 - (char)(v28 >> 7);
    v38 = ((v27 + v27 * v24) >> 7) & 0x3FE;
    if (v35 >= v24)
      v37 = v38;
    v39 = 2 * (v12 - v8) * (v10 - v11);
    if (v35 >= v22)
      v40 = ((v25 + v25 * v22) >> 7) & 0x3FE;
    else
      v40 = v36 - (char)(v30 >> 7);
    v41 = v36 - (v39 >> 8);
    v42 = ((v11 + v11 * v8) >> 7) & 0x3FE;
    if (v35 >= v8)
      v43 = v42;
    else
      v43 = v41;
    v44 = v43 + v18;
    v45 = vadd_s32((int32x2_t)__PAIR64__(v40, v37), *(int32x2_t *)&v26);
    if (v44 >= v14)
      v44 = v14;
    v46 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(v45, vdup_n_s32(v14)), 0), (uint32x2_t)0x800000010);
    *result++ = v46.i32[0] | (v14 << 24) | v44 & ~(v44 >> 31) | v46.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Difference,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int32x2_t v11;
  signed int v12;
  signed int v13;
  int32x2_t v14;
  double v15;
  unsigned int v16;
  unsigned int v17;
  BOOL v18;
  unsigned int v19;
  signed int v20;
  uint32x2_t v21;
  unsigned int v22;
  unsigned int v23;
  uint32x2_t v24;
  int32x2_t v25;
  double v26;
  uint32x2_t v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  signed int v31;
  uint32x2_t v32;
  uint32x2_t v33;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = HIBYTE(v4);
    v8 = HIBYTE(v6);
    v9 = v6;
    v10 = HIBYTE(v4) + 1;
    v11 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v12 = (HIBYTE(v6) * v10) >> 8;
    v13 = v12 + (((HIBYTE(v6) ^ 0xFF) * v10) >> 8);
    v14 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v15 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v11, (int32x2_t)0x100000001)), 8uLL));
    v16 = ((v8 ^ 0xFF) + (v8 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255)
      v16 = 0;
    if (v8 == 255)
      v15 = 0.0;
    else
      v12 = v13;
    v17 = v7 ^ 0xFF;
    v18 = v7 == 255;
    v19 = v8 + 1;
    v20 = v12 + (((v8 + 1) * v17) >> 8);
    v21 = (uint32x2_t)vmul_s32(vadd_s32(v14, (int32x2_t)0x100000001), vdup_n_s32(v17));
    v22 = v16 + ((v17 + v17 * v9) >> 8);
    if (v18)
    {
      v23 = v16;
    }
    else
    {
      v19 = v8 + 1;
      v23 = v22;
    }
    v24 = (uint32x2_t)vmul_s32(v14, vdup_n_s32(v10));
    v25 = vdup_n_s32(v19);
    v26 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v15, v21, 8uLL));
    if (!v18)
      v12 = v20;
    v27 = (uint32x2_t)vmul_s32(v25, v11);
    v28 = (v9 * v10) >> 8;
    v29 = v19 * v4;
    if (!v18)
      v15 = v26;
    v30 = v28 - (v29 >> 8);
    if (v30 < 0)
      v30 = -v30;
    v31 = v23 + v30;
    v32 = (uint32x2_t)vmin_s32((int32x2_t)vaba_u32(*(uint32x2_t *)&v15, vshr_n_u32(v27, 8uLL), vshr_n_u32(v24, 8uLL)), vdup_n_s32(v12));
    if (v31 >= v12)
      v31 = v12;
    v33 = vshl_u32(v32, (uint32x2_t)0x800000010);
    *result++ = v31 | (v12 << 24) | v33.i32[0] | v33.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Subtract,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int32x2_t v11;
  signed int v12;
  signed int v13;
  double v14;
  int32x2_t v15;
  unsigned int v16;
  unsigned int v17;
  BOOL v18;
  unsigned int v19;
  signed int v20;
  uint32x2_t v21;
  unsigned int v22;
  double v23;
  unsigned int v24;
  int32x2_t v25;
  uint32x2_t v26;
  uint32x2_t v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  uint32x2_t v31;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = HIBYTE(v4);
    v8 = HIBYTE(v6);
    v9 = v6;
    v10 = HIBYTE(v4) + 1;
    v11 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v12 = (HIBYTE(v6) * v10) >> 8;
    v13 = v12 + (((HIBYTE(v6) ^ 0xFF) * v10) >> 8);
    v14 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v11, (int32x2_t)0x100000001)), 8uLL));
    v15 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v16 = ((v8 ^ 0xFF) + (v8 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255)
      v16 = 0;
    if (v8 == 255)
      v14 = 0.0;
    else
      v12 = v13;
    v17 = v7 ^ 0xFF;
    v18 = v7 == 255;
    v19 = v8 + 1;
    v20 = v12 + (((v8 + 1) * v17) >> 8);
    v21 = (uint32x2_t)vmul_s32(vadd_s32(v15, (int32x2_t)0x100000001), vdup_n_s32(v17));
    v22 = v16 + ((v17 + v17 * v9) >> 8);
    if (!v18)
      v19 = v8 + 1;
    v23 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v14, v21, 8uLL));
    if (v18)
      v24 = v16;
    else
      v24 = v22;
    v25 = vdup_n_s32(v10);
    v26 = (uint32x2_t)vmul_s32(vdup_n_s32(v19), v11);
    if (!v18)
      v12 = v20;
    v27 = (uint32x2_t)vmul_s32(v15, v25);
    v28 = v19 * v4;
    v29 = v24 - ((v9 * v10) >> 8);
    if (!v18)
      v14 = v23;
    v30 = v29 + (v28 >> 8);
    if (v30 >= v12)
      v30 = v12;
    v31 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(vadd_s32(vsub_s32((int32x2_t)vshr_n_u32(v26, 8uLL), (int32x2_t)vshr_n_u32(v27, 8uLL)), *(int32x2_t *)&v14), vdup_n_s32(v12)), 0), (uint32x2_t)0x800000010);
    *result++ = v30 & ~(v30 >> 31) | (v12 << 24) | v31.i32[0] | v31.i32[1];
  }
  return result;
}

int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Divide,false>::blend(int *result, int *a2, _DWORD *a3, uint64_t a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  signed int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  BOOL v18;
  int v19;
  signed int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  signed int v35;
  signed int v36;
  signed int v37;

  for (; a4; --a4)
  {
    v4 = *a2;
    v5 = HIBYTE(*a3);
    v6 = BYTE2(*a3);
    v7 = BYTE1(*a3);
    v8 = *a3;
    v9 = HIBYTE(*a2);
    v10 = v5 + 1;
    v11 = (v9 * (v5 + 1)) >> 8;
    if (v9 == 255)
    {
      v12 = 0;
      v13 = 0;
      v14 = 0;
    }
    else
    {
      v15 = v9 ^ 0xFF;
      v11 += ((v9 ^ 0xFF) * v10) >> 8;
      v12 = (v15 + v15 * v6) >> 8;
      v13 = (v15 + v15 * v7) >> 8;
      v14 = (v15 + v15 * v8) >> 8;
    }
    v16 = BYTE2(v4);
    v17 = BYTE1(v4);
    v18 = v5 == 255;
    v19 = v5 ^ 0xFF;
    v20 = v11 + (((v9 + 1) * v19) >> 8);
    v21 = v13 + ((v19 + v19 * BYTE1(v4)) >> 8);
    v22 = v14 + ((v19 + v19 * *a2) >> 8);
    v23 = v9 + 1;
    if (v18)
      v24 = v12;
    else
      v24 = v12 + ((v19 + v19 * BYTE2(v4)) >> 8);
    if (v18)
      v25 = v13;
    else
      v25 = v21;
    if (v18)
      v26 = v14;
    else
      v26 = v22;
    if (!v18)
      v11 = v20;
    v27 = v23 * v6;
    if ((v16 * v10) < 0x100)
    {
      if (v27 <= 0xFF)
        v28 = 0;
      else
        v28 = 255;
    }
    else
    {
      v28 = (unsigned __int16)(255 * (v27 >> 8)) / ((v16 * v10) >> 8);
    }
    v29 = v23 * v7;
    v30 = v17 * v10;
    if (v30 < 0x100)
    {
      if (v29 <= 0xFF)
        v31 = 0;
      else
        v31 = 255;
    }
    else
    {
      v31 = (unsigned __int16)(255 * (v29 >> 8)) / (v30 >> 8);
    }
    v32 = v23 * v8;
    v33 = *a2 * v10;
    if (v33 < 0x100)
    {
      if (v32 <= 0xFF)
        v34 = 0;
      else
        v34 = 255;
    }
    else
    {
      v34 = (unsigned __int16)(255 * (v32 >> 8)) / (v33 >> 8);
    }
    v35 = v31 + v25;
    if ((int)(v31 + v25) >= v11)
      v35 = v11;
    v36 = v28 + v24;
    if ((int)(v28 + v24) >= v11)
      v36 = v11;
    v37 = v34 + v26;
    if (v37 >= v11)
      v37 = v11;
    *result++ = (v36 << 16) | (v11 << 24) | (v35 << 8) | v37;
    ++a2;
    ++a3;
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::LinearBurn,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int32x2_t v11;
  signed int v12;
  signed int v13;
  int32x2_t v14;
  double v15;
  unsigned int v16;
  unsigned int v17;
  uint32x2_t v18;
  BOOL v19;
  unsigned int v20;
  double v21;
  int32x2_t v22;
  uint32x2_t v23;
  int32x2_t v24;
  unsigned int v25;
  int v26;
  int32x2_t v27;
  uint32x2_t v28;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = HIBYTE(v4);
    v8 = HIBYTE(v6);
    v9 = v6;
    v10 = HIBYTE(v4) + 1;
    v11 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v12 = (HIBYTE(v6) * v10) >> 8;
    v13 = v12 + (((HIBYTE(v6) ^ 0xFF) * v10) >> 8);
    v14 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v15 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v11, (int32x2_t)0x100000001)), 8uLL));
    v16 = ((v8 ^ 0xFF) + (v8 ^ 0xFF) * v4) >> 8;
    if (HIBYTE(v6) == 255)
      v16 = 0;
    if (v8 != 255)
      v12 = v13;
    v17 = v7 ^ 0xFF;
    if (v8 == 255)
      v15 = 0.0;
    v18 = (uint32x2_t)vmul_s32(vadd_s32(v14, (int32x2_t)0x100000001), vdup_n_s32(v17));
    v19 = v7 == 255;
    v20 = v16 + ((v17 + v17 * v9) >> 8);
    if (v19)
      v20 = v16;
    else
      v12 += (v17 + v17 * v8) >> 8;
    v21 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v15, v18, 8uLL));
    v22 = vdup_n_s32(v10);
    v23 = (uint32x2_t)vmul_s32(v14, v22);
    v24 = vsub_s32(v22, v11);
    v25 = v9 * v10;
    if (!v19)
      v15 = v21;
    v26 = v20 - ((int)(v8 * (v10 - v4)) >> 8) + (v25 >> 8);
    v27 = vsub_s32((int32x2_t)vshr_n_u32(v23, 8uLL), vshr_n_s32(vmul_s32(vdup_n_s32(v8), v24), 8uLL));
    if (v26 >= v12)
      v26 = v12;
    v28 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(vadd_s32(v27, *(int32x2_t *)&v15), vdup_n_s32(v12)), 0), (uint32x2_t)0x800000010);
    *result++ = v26 & ~(v26 >> 31) | (v12 << 24) | v28.i32[0] | v28.i32[1];
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::LinearLight,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  int32x2_t v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  int32x2_t v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  double v16;
  unsigned int v17;
  BOOL v18;
  signed int v19;
  uint32x2_t v20;
  unsigned int v21;
  int32x2_t v22;
  double v23;
  uint32x2_t v24;
  int32x2_t v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  int32x2_t v29;
  uint32x2_t v30;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = HIBYTE(v4);
    v8 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v4), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v9 = HIBYTE(v6);
    v10 = v6;
    v11 = HIBYTE(v4) + 1;
    v12 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
    v13 = (HIBYTE(v6) * v11) >> 8;
    v14 = v13 + (((HIBYTE(v6) ^ 0xFF) * v11) >> 8);
    v15 = ((v9 ^ 0xFF) + (v9 ^ 0xFF) * v4) >> 8;
    v16 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(HIBYTE(v6) ^ 0xFF), vadd_s32(v8, (int32x2_t)0x100000001)), 8uLL));
    if (HIBYTE(v6) == 255)
      v15 = 0;
    if (v9 == 255)
      v16 = 0.0;
    else
      v13 = v14;
    v17 = v7 ^ 0xFF;
    v18 = v7 == 255;
    v19 = v13 + ((v17 + v17 * v9) >> 8);
    v20 = (uint32x2_t)vmul_s32(vadd_s32(v12, (int32x2_t)0x100000001), vdup_n_s32(v17));
    v21 = v15 + ((v17 + v17 * v10) >> 8);
    if (!v18)
      v15 = v21;
    v22 = vdup_n_s32(v11);
    v23 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v16, v20, 8uLL));
    if (v18)
      v19 = v13;
    v24 = (uint32x2_t)vmul_s32(v12, v22);
    v25 = vadd_s32(v8, v8);
    v26 = v10 * v11;
    v27 = v11 - 2 * v4;
    if (!v18)
      v16 = v23;
    v28 = v15 - ((int)(v9 * v27) >> 8) + (v26 >> 8);
    v29 = vsub_s32((int32x2_t)vshr_n_u32(v24, 8uLL), vshr_n_s32(vmul_s32(vdup_n_s32(v9), vsub_s32(v22, v25)), 8uLL));
    if (v28 >= v19)
      v28 = v19;
    v30 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(vadd_s32(v29, *(int32x2_t *)&v16), vdup_n_s32(v19)), 0), (uint32x2_t)0x800000010);
    *result++ = v28 & ~(v28 >> 31) | (v19 << 24) | v30.i32[0] | v30.i32[1];
  }
  return result;
}

int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::PinLight,false>::blend(int *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  BOOL v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  signed int v28;
  unsigned int v29;
  unsigned int v30;
  signed int v31;
  signed int v32;
  signed int v33;
  unsigned int v34;
  unsigned int v35;
  BOOL v36;
  signed int v37;
  signed int v38;
  signed int v39;
  signed int v40;
  signed int v41;
  signed int v42;
  signed int v43;
  signed int v44;
  signed int v45;
  signed int v46;
  signed int v47;
  int v48;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = HIBYTE(v4);
    v8 = BYTE2(v4);
    v9 = BYTE1(v4);
    v10 = v4;
    v11 = HIBYTE(v6);
    v12 = BYTE2(v6);
    v13 = BYTE1(v6);
    v14 = v6;
    v15 = HIBYTE(v4) + 1;
    v16 = (HIBYTE(v6) * v15) >> 8;
    v17 = HIBYTE(v6) ^ 0xFF;
    v18 = (v17 + v17 * BYTE2(v4)) >> 8;
    v19 = v16 + ((v17 * v15) >> 8);
    v20 = (v17 + v17 * BYTE1(v4)) >> 8;
    v21 = (v17 + v17 * v4) >> 8;
    if (HIBYTE(v6) == 255)
      v18 = 0;
    if (v11 == 255)
    {
      v20 = 0;
      v21 = 0;
      v19 = v16;
    }
    v22 = v7 == 255;
    v23 = v7 ^ 0xFF;
    v24 = (v11 + 1) * v23;
    v25 = v18 + ((v23 + v23 * v12) >> 8);
    v26 = v20 + ((v23 + v23 * v13) >> 8);
    v27 = v21 + ((v23 + v23 * v14) >> 8);
    v28 = v19 + (v24 >> 8);
    v29 = v11 + 1;
    if (v22)
    {
      v27 = v21;
    }
    else
    {
      v18 = v25;
      v20 = v26;
    }
    v30 = v12 * v15;
    if (v22)
      v31 = v19;
    else
      v31 = v28;
    v32 = v30 >> 8;
    v33 = ((v29 * BYTE2(v4)) >> 7) & 0x3FE;
    v34 = v4 >> 25;
    v35 = v33 - v16;
    if (v32 > (int)(v33 - v16))
      v35 = v32;
    if (v32 >= v33)
      v32 = v33;
    v36 = v34 > v8;
    v37 = (v13 * v15) >> 8;
    v38 = ((v29 * v9) >> 7) & 0x3FE;
    v39 = v38 - v16;
    if (!v36)
      v32 = v35;
    if (v37 > v39)
      v39 = v37;
    if (v37 >= v38)
      v37 = ((v29 * v9) >> 7) & 0x3FE;
    v36 = v34 > v9;
    v40 = (v14 * v15) >> 8;
    v41 = ((v29 * v10) >> 7) & 0x3FE;
    v42 = v41 - v16;
    if (v36)
      v43 = v37;
    else
      v43 = v39;
    if (v40 > v42)
      v42 = v40;
    if (v40 >= v41)
      v40 = ((v29 * v10) >> 7) & 0x3FE;
    if (v34 > v10)
      v44 = v40;
    else
      v44 = v42;
    v45 = v43 + v20;
    if ((int)(v43 + v20) >= v31)
      v45 = v31;
    v46 = v32 + v18;
    if ((int)(v32 + v18) >= v31)
      v46 = v31;
    v47 = v44 + v27;
    v48 = (v46 << 16) | (v31 << 24) | (v45 << 8);
    if (v47 >= v31)
      v47 = v31;
    *result++ = v48 | v47;
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::VibrantDarkSover,false>::blend(__int32 *result, unsigned int *a2, _DWORD *a3, const unsigned int *a4, _DWORD *a5)
{
  const unsigned int *v6;
  __int32 *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  int32x2_t v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  double v26;
  int32x2_t v27;
  int v28;
  int v29;
  signed int v30;
  double v31;
  unsigned int v32;
  unsigned int v33;
  signed int v34;
  unsigned int v35;
  int v36;
  int v37;
  signed int v38;
  unsigned int v39;
  int v40;
  int32x2_t v41;
  int v42;
  uint32x2_t v43;
  __int32 v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v6 = a4;
    v9 = result;
    do
    {
      v10 = *a3 >> 8;
      v11 = BYTE1(*a3);
      v12 = *a3;
      v13 = (v11 * BYTE1(*a5) + v10) & 0x1FF00;
      v14 = v12 * *a5 + v12;
      v15 = v10 & 0xFF0000;
      v16 = v10 & 0xFF00;
      v17 = (v15 + v15 * HIBYTE(*a5)) & 0xFF000000 | (v16 + v16 * BYTE2(*a5)) & 0x1FF0000;
      v18 = v13 | (v14 >> 8) | v17;
      v19 = HIBYTE(v17);
      v20 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v18), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
      v21 = BYTE1(v14);
      v22 = HIBYTE(*a2);
      v23 = v19 + 1;
      v24 = (v22 * (v19 + 1)) >> 8;
      if (v22 == 255)
      {
        v25 = 0;
        v26 = 0.0;
      }
      else
      {
        v24 += ((v22 ^ 0xFF) * v23) >> 8;
        v26 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(v22 ^ 0xFF), vadd_s32(v20, (int32x2_t)0x100000001)), 8uLL));
        v25 = ((v22 ^ 0xFF) + (v22 ^ 0xFF) * v21) >> 8;
      }
      v27 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*a2), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
      v28 = *a2;
      v29 = v19 ^ 0xFF;
      v30 = v24 + ((v29 + v29 * v22) >> 8);
      v31 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v26, (uint32x2_t)vmul_s32(vadd_s32(v27, (int32x2_t)0x100000001), vdup_n_s32(v19 ^ 0xFF)), 8uLL));
      v32 = v25 + ((v29 + v29 * v28) >> 8);
      if (v19 == 255)
        v33 = v25;
      else
        v33 = v32;
      if (v19 == 255)
        v34 = v24;
      else
        v34 = v30;
      if (v19 != 255)
        v26 = v31;
      v35 = v23 * v19;
      v36 = v19;
      if (v19 > v20.i32[0])
      {
        v36 = (int)(255 * ((v27.i32[0] + v27.i32[0] * (v35 >> 8)) >> 8)) / (int)(v19 - v20.i32[0]);
        if (v36 >= (int)v19)
          v36 = v19;
      }
      v37 = v19;
      v38 = v19 - v20.i32[1];
      if (v19 > v20.i32[1])
      {
        v39 = v27.i32[1] + v27.i32[1] * (v35 >> 8);
        a4 = (const unsigned int *)(v39 >> 8 << 8);
        v37 = (int)(255 * (v39 >> 8)) / v38;
        if (v37 >= (int)v19)
          v37 = v19;
      }
      v40 = (int)(255 * ((v28 + v28 * (v35 >> 8)) >> 8)) / (int)(v19 - v21);
      if (v40 >= (int)v19)
        v40 = v19;
      if (v19 > v21)
        v19 = v40;
      v41 = vadd_s32((int32x2_t)__PAIR64__(v37, v36), *(int32x2_t *)&v26);
      v42 = v19 + v33;
      if (v42 >= v34)
        v42 = v34;
      v43 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(v41, vdup_n_s32(v34)), 0), (uint32x2_t)0x800000010);
      v44 = v43.i32[0] | (v34 << 24) | v42 & ~(v42 >> 31) | v43.i32[1];
      result = CA::OGL::SW::Blend::LightenSover::f(&v44, (unsigned int *)((v15 + v15 * HIBYTE(a5[1])) & 0xFF000000 | ((v12+ v12* a5[1]) >> 8) | (v16 + v16 * BYTE2(a5[1])) & 0x1FF0000 | (v11 + v11 * BYTE1(a5[1])) & 0x1FF00), v38, a4);
      *v9++ = v44;
      ++a2;
      ++a3;
      v6 = (const unsigned int *)((char *)v6 - 1);
    }
    while (v6);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::VibrantLightSover,false>::blend(_DWORD *result, int *a2, unsigned int *a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v6;
  _DWORD *v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  unsigned int v16;
  const unsigned int *v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v6 = a4;
    v9 = result;
    do
    {
      v11 = *a3++;
      v10 = v11;
      v12 = *a2++;
      v13 = *a5;
      v18 = v12;
      v14 = (v10 >> 8) & 0xFF0000;
      v15 = (v10 >> 8) & 0xFF00;
      CA::OGL::SW::Blend::SeparableMode<CA::OGL::SW::Blend::ColorBurn>::f(&v18, (v14 + v14 * HIBYTE(v13)) & 0xFF000000 | ((v10 * v13+ v10) >> 8) | (v15 + v15 * BYTE2(v13)) & 0x1FF0000 | (BYTE1(v10) * BYTE1(v13) + BYTE1(v10)) & 0x1FF00);
      result = CA::OGL::SW::Blend::DarkenSover::f(&v18, (unsigned int *)((v14 + v14 * HIBYTE(a5[1])) & 0xFF000000 | ((v10* a5[1]+ v10) >> 8) | (v15 + v15 * BYTE2(a5[1])) & 0x1FF0000 | (BYTE1(v10) * BYTE1(a5[1]) + BYTE1(v10)) & 0x1FF00), v16, v17);
      *v9++ = v18;
      --v6;
    }
    while (v6);
  }
  return result;
}

__int32 *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::VibrantDarkSoverRev,false>::blend(__int32 *result, unsigned int *a2, unsigned int *a3, const unsigned int *a4, _DWORD *a5)
{
  unsigned int *v5;
  __int32 *v7;
  unsigned int v8;
  int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int32x2_t v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  signed int v19;
  unsigned int v20;
  double v21;
  int32x2_t v22;
  int v23;
  signed int v24;
  double v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  int32x2_t v31;
  int v32;
  uint32x2_t v33;
  const unsigned int *v35;
  unsigned int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v5 = a3;
    v7 = result;
    do
    {
      v35 = a4;
      v8 = *v5;
      v36 = *a2;
      v9 = (v8 >> 8) & 0xFF0000;
      v10 = (v8 >> 8) & 0xFF00;
      result = CA::OGL::SW::Blend::LightenSover::f(&v36, (unsigned int *)((v9 + v9 * HIBYTE(a5[1])) & 0xFF000000 | ((v8* a5[1]+ v8) >> 8) | (v10 + v10 * BYTE2(a5[1])) & 0x1FF0000 | (BYTE1(v8) * BYTE1(a5[1]) + BYTE1(v8)) & 0x1FF00), a3, a4);
      v11 = v8 * *a5 + v8;
      v12 = (v9 + v9 * HIBYTE(*a5)) & 0xFF000000 | (v10 + v10 * BYTE2(*a5)) & 0x1FF0000;
      v13 = (BYTE1(v8) * BYTE1(*a5) + BYTE1(v8)) & 0x1FF00 | (v11 >> 8) | v12;
      v14 = HIBYTE(v12);
      v15 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v13), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
      v16 = BYTE1(v11);
      v17 = HIBYTE(v36);
      v18 = v14 + 1;
      v19 = (HIBYTE(v36) * (v14 + 1)) >> 8;
      if (HIBYTE(v36) == 255)
      {
        v20 = 0;
        v21 = 0.0;
      }
      else
      {
        v19 += ((v17 ^ 0xFF) * v18) >> 8;
        v21 = COERCE_DOUBLE(vshr_n_u32((uint32x2_t)vmul_s32(vdup_n_s32(v17 ^ 0xFF), vadd_s32(v15, (int32x2_t)0x100000001)), 8uLL));
        v20 = ((v17 ^ 0xFF) + (v17 ^ 0xFF) * BYTE1(v11)) >> 8;
      }
      v22 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v36), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
      v23 = v14 ^ 0xFF;
      v24 = v19 + ((v23 + v23 * v17) >> 8);
      v25 = COERCE_DOUBLE(vsra_n_u32(*(uint32x2_t *)&v21, (uint32x2_t)vmul_s32(vadd_s32(v22, (int32x2_t)0x100000001), vdup_n_s32(v14 ^ 0xFF)), 8uLL));
      v26 = v20 + ((v23 + v23 * v36) >> 8);
      if (v14 == 255)
      {
        v26 = v20;
      }
      else
      {
        v19 = v24;
        v21 = v25;
      }
      v27 = v18 * v14;
      v28 = v14;
      if (v14 > v15.i32[0])
      {
        v28 = (int)(255 * ((v22.i32[0] + v22.i32[0] * (v27 >> 8)) >> 8)) / (int)(v14 - v15.i32[0]);
        if (v28 >= (int)v14)
          v28 = v14;
      }
      v29 = v14;
      if (v14 > v15.i32[1])
      {
        v29 = (int)(255 * ((v22.i32[1] + v22.i32[1] * (v27 >> 8)) >> 8)) / (int)(v14 - v15.i32[1]);
        if (v29 >= (int)v14)
          v29 = v14;
      }
      v30 = (int)(255 * ((v36 + v36 * (v27 >> 8)) >> 8)) / (int)(v14 - BYTE1(v11));
      if (v30 >= (int)v14)
        v30 = v14;
      if (v14 > v16)
        v14 = v30;
      v31 = vadd_s32((int32x2_t)__PAIR64__(v29, v28), *(int32x2_t *)&v21);
      v32 = v14 + v26;
      if (v32 >= v19)
        v32 = v19;
      v33 = vshl_u32((uint32x2_t)vmax_s32(vmin_s32(v31, vdup_n_s32(v19)), 0), (uint32x2_t)0x800000010);
      *v7++ = v33.i32[0] | (v19 << 24) | v32 & ~(v32 >> 31) | v33.i32[1];
      ++a2;
      ++v5;
      a4 = (const unsigned int *)((char *)v35 - 1);
    }
    while (v35 != (const unsigned int *)1);
  }
  return result;
}

int *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::VibrantLightSoverRev,false>::blend(int *result, int *a2, unsigned int *a3, const unsigned int *a4, _DWORD *a5)
{
  const unsigned int *v6;
  unsigned int *v7;
  int *v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v6 = a4;
    v7 = a3;
    v9 = result;
    do
    {
      v11 = *v7++;
      v10 = v11;
      v12 = *a2++;
      v13 = a5[1];
      v16 = v12;
      v14 = (v10 >> 8) & 0xFF0000;
      v15 = (v10 >> 8) & 0xFF00;
      CA::OGL::SW::Blend::DarkenSover::f(&v16, (unsigned int *)((v14 + v14 * HIBYTE(v13)) & 0xFF000000 | ((v10 * v13+ v10) >> 8) | (v15 + v15 * BYTE2(v13)) & 0x1FF0000 | (BYTE1(v10) * BYTE1(v13) + BYTE1(v10)) & 0x1FF00), a3, a4);
      result = CA::OGL::SW::Blend::SeparableMode<CA::OGL::SW::Blend::ColorBurn>::f(&v16, (v14 + v14 * HIBYTE(*a5)) & 0xFF000000 | ((v10 * *a5+ v10) >> 8) | (v15 + v15 * BYTE2(*a5)) & 0x1FF0000 | (BYTE1(v10) * BYTE1(*a5) + BYTE1(v10)) & 0x1FF00);
      *v9++ = v16;
      v6 = (const unsigned int *)((char *)v6 - 1);
    }
    while (v6);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::DarkenSover,false>::blend(_DWORD *result, int *a2, unsigned int *a3, const unsigned int *a4)
{
  const unsigned int *v4;
  unsigned int *v5;
  _DWORD *v7;
  unsigned int *v8;
  unsigned int v9;
  int v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v4 = a4;
    v5 = a3;
    v7 = result;
    do
    {
      v9 = *v5++;
      v8 = (unsigned int *)v9;
      v10 = *a2++;
      v11 = v10;
      result = CA::OGL::SW::Blend::DarkenSover::f(&v11, v8, a3, a4);
      *v7++ = v11;
      v4 = (const unsigned int *)((char *)v4 - 1);
    }
    while (v4);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::LightenSover,false>::blend(_DWORD *result, int *a2, unsigned int *a3, const unsigned int *a4)
{
  const unsigned int *v4;
  unsigned int *v5;
  _DWORD *v7;
  unsigned int *v8;
  unsigned int v9;
  int v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v4 = a4;
    v5 = a3;
    v7 = result;
    do
    {
      v9 = *v5++;
      v8 = (unsigned int *)v9;
      v10 = *a2++;
      v11 = v10;
      result = CA::OGL::SW::Blend::LightenSover::f(&v11, v8, a3, a4);
      *v7++ = v11;
      v4 = (const unsigned int *)((char *)v4 - 1);
    }
    while (v4);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Hue,false>::blend(_DWORD *result, unsigned int *a2, int *a3, uint64_t a4)
{
  int v4;
  int v5;
  unsigned int v6;
  unint64_t v7;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = ((((v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL) * ((~v4 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = v4 + ((v7 >> 24) | v7);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Saturation,false>::blend(_DWORD *result, unsigned int *a2, int *a3, uint64_t a4)
{
  int v4;
  int v5;
  unsigned int v6;
  unint64_t v7;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = ((((v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL) * ((~v4 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = v4 + ((v7 >> 24) | v7);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Color,false>::blend(_DWORD *result, unsigned int *a2, int *a3, uint64_t a4)
{
  int v4;
  int v5;
  unsigned int v6;
  unint64_t v7;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = ((((v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL) * ((~v4 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = v4 + ((v7 >> 24) | v7);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::Luminosity,false>::blend(_DWORD *result, unsigned int *a2, int *a3, uint64_t a4)
{
  int v4;
  int v5;
  unsigned int v6;
  unint64_t v7;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = ((((v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL) * ((~v4 >> 24) + 1)) >> 8) & 0xFF00FF00FF00FFLL;
    *result++ = v4 + ((v7 >> 24) | v7);
  }
  return result;
}

_DWORD *CA::OGL::SW::Blend::Mode<CA::OGL::SW::Blend::SoverMulDMulSa,false>::blend(_DWORD *result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;

  for (; a4; --a4)
  {
    v5 = *a3++;
    v4 = v5;
    v6 = *a2++;
    v7 = BYTE3(v4);
    v8 = (unint64_t)v6 >> 24;
    v9 = ((((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) + ((v4 | (v4 << 24)) & 0xFF00FF00FF00FFLL) * v8) >> 8) & 0xFF00FF00FF00FFLL;
    v10 = ((((v6 | ((unint64_t)v6 << 24)) & 0xFF00FF00FF00FFLL) * (256 - ((v8 + v8 * v7) >> 8))) >> 8) & 0xFF00FF00FF00FFLL;
    LODWORD(v9) = (v9 >> 24) | v9;
    LODWORD(v10) = (v10 >> 24) | v10;
    v11 = (v10 & 0xFF00FF) + (v9 & 0xFF00FF);
    LODWORD(v9) = ((v10 >> 8) & 0xFF00FF) + ((v9 >> 8) & 0xFF00FF);
    *result++ = v11 & 0xFF00FF | (v9 << 8) | (15 * (v9 & 0x1000100 | (v11 >> 8) & 0x10001)) | (240 * (v9 & 0x1000100 | (v11 >> 8) & 0x10001)) | 0xFF000000;
  }
  return result;
}

uint64_t CA::OGL::SW::incomplete_samplers(CA::OGL::SW *this)
{
  unsigned __int8 v1;
  _QWORD *v2;
  void *v4;

  v2 = &unk_1EDD11000;
  {
    v4 = malloc_type_malloc(0x80uLL, 0x80040B8603338uLL);
    memset_pattern16(v4, off_1E159E0F0, 0x80uLL);
    CA::OGL::SW::incomplete_samplers(void)::samplers = (uint64_t)v4;
    v2 = (_QWORD *)&unk_1EDD11000;
  }
  return v2[470];
}

uint64_t CA::OGL::SW::unlock_iosurface(CA::OGL::SW *this, void *a2)
{
  return IOSurfaceUnlock(this, 1u, 0);
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,CA::Vec4<float>,true,true,false,true>(int *a1, int a2, float32x4_t *a3)
{
  int v4;
  int v5;
  int v6;
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  int32x4_t v26;
  int32x4_t v27;
  int32x4_t v28;
  int32x4_t v29;
  float v30;
  float v31;
  float32x4_t v32;
  float v33;
  float32x4_t v34;
  float32x4_t v35;
  int v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  float v42;
  float v43;
  float32x4_t v44;
  float32x4_t v45;
  int32x4_t v46;

  if (a2)
  {
    v4 = a2;
    v40 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v41 = **(_QWORD **)a1;
    v5 = a1[15];
    v6 = a1[13];
    v36 = a1[14];
    v37 = a1[16];
    v38 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v39 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    __asm { FMOV            V0.4S, #1.0 }
    v46 = _Q0;
    do
    {
      --v4;
      v12 = v39 - 0x8000;
      if (v6 < v39 - 0x8000)
        v12 = v6;
      if (v12 <= -32768)
        v12 = -32768;
      v13 = v12 + 0x8000;
      if (v6 <= 0x8000)
        v14 = 0x8000;
      else
        v14 = v6;
      v15 = v14 - 0x8000;
      if (v15 >= v39)
        v16 = v39;
      else
        v16 = v15;
      v17 = v38 - 0x8000;
      if (v5 < v38 - 0x8000)
        v17 = v5;
      if (v17 <= -32768)
        v17 = -32768;
      v18 = v17 + 0x8000;
      if (v5 <= 0x8000)
        v19 = 0x8000;
      else
        v19 = v5;
      v20 = v19 - 0x8000;
      if (v20 >= v38)
        v21 = v38;
      else
        v21 = v20;
      v22 = v41 + v40 * ((uint64_t)v21 >> 16);
      v23 = v41 + v40 * HIWORD(v18);
      v24 = ((uint64_t)v16 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v25 = (v13 >> 15) & 0x1FFFE;
      v43 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v22 + v24));
      v26 = v46;
      *(float *)v26.i32 = v43;
      v27 = vzip1q_s32(v26, v26);
      *(float *)&v27.i32[2] = v43;
      v45 = (float32x4_t)v27;
      v42 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v22 + v25));
      v28 = v46;
      *(float *)v28.i32 = v42;
      v29 = vzip1q_s32(v28, v28);
      *(float *)&v29.i32[2] = v42;
      v44 = (float32x4_t)v29;
      v30 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v23 + v24));
      v31 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v23 + v25));
      v32 = (float32x4_t)vzip1q_s32((int32x4_t)COERCE_UNSIGNED_INT(v30 - v43), (int32x4_t)COERCE_UNSIGNED_INT(v30 - v43));
      v32.f32[2] = v30 - v43;
      v33 = (float)BYTE1(v21) * 0.0039062;
      v34 = vmlaq_n_f32(v45, v32, v33);
      v35 = (float32x4_t)vzip1q_s32((int32x4_t)COERCE_UNSIGNED_INT(v31 - v42), (int32x4_t)COERCE_UNSIGNED_INT(v31 - v42));
      v35.f32[2] = v31 - v42;
      v6 += v36;
      *a3++ = vmlaq_n_f32(v34, vmlaq_n_f32(vsubq_f32(v44, v34), v35, v33), (float)BYTE1(v16) * 0.0039062);
      v5 += v37;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,CA::Vec4<float>,true,true,true,true>(uint64_t **a1, int a2, float32x4_t *a3)
{
  int v4;
  float v5;
  float v6;
  int v7;
  int v8;
  int v9;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  int32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  unsigned int v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  int32x4_t v46;
  int32x4_t v47;
  int32x4_t v48;
  int32x4_t v49;
  float v50;
  float v51;
  float v52;
  float32x4_t v53;
  unsigned int v54;
  float32x4_t v55;
  float32x4_t v56;
  float *v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  float v66;
  float v67;
  float32x4_t v68;
  float32x4_t v69;
  int32x4_t v70;

  if (a2)
  {
    v4 = a2;
    v64 = (*a1)[2];
    v65 = **a1;
    v58 = (float *)*a1;
    v5 = *((float *)a1[3] + 3);
    v6 = *((float *)a1[2] + 3);
    v7 = *((_DWORD *)a1 + 15);
    v61 = *((_DWORD *)a1 + 16);
    v62 = *((_DWORD *)*a1 + 9);
    v8 = *((_DWORD *)a1 + 13);
    v60 = *((_DWORD *)a1 + 14);
    v63 = *((_DWORD *)*a1 + 8);
    v9 = *((unsigned __int8 *)a1 + 48) - 1;
    __asm { FMOV            V0.4S, #1.0 }
    v70 = _Q0;
    v15 = (float32x2_t)vdup_n_s32(0x37800000u);
    v16 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v17 = (float32x2_t)vdup_n_s32(0x47800000u);
    v59 = v9;
    do
    {
      v18.f32[0] = (float)(1.0 / v6) * (float)v8;
      v18.f32[1] = (float)(1.0 / v6) * (float)v7;
      v19 = vcvt_s32_f32(v18);
      switch(v9)
      {
        case 0:
          v20 = vmul_f32(*(float32x2_t *)(v58 + 10), vcvt_f32_s32(v19));
          v21 = vmul_f32(v20, v20);
          v22 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 1), v21);
          v21.f32[0] = fmaxf(vaddv_f32(v21), 0.00001);
          v21.i32[0] = vmul_f32(v22, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 0))).u32[0];
          v21.i32[1] = 0.5;
          v23 = vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v58 + 6)));
          goto LABEL_8;
        case 1:
          v24 = atan2f(v58[11] * (float)v19.i32[1], v58[10] * (float)v19.i32[0]);
          v25.i32[1] = 1056964608;
          v25.f32[0] = (float)(v24 * -10430.0) + 32768.0;
          v23 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v58 + 6)));
          goto LABEL_8;
        case 2:
          v26 = vmul_f32(vcvt_f32_s32(v19), vmul_f32(v15, *(float32x2_t *)(v58 + 10)));
          v23 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v26, vrndm_f32(v26)), v16)), vmul_f32(v17, vcvt_f32_u32(*(uint32x2_t *)(v58 + 6))));
          goto LABEL_8;
        case 4:
          v27 = vcvt_f32_s32(v19);
          v28 = vcvt_f32_s32(*(int32x2_t *)(v58 + 8));
          v29 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v28);
          v30 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v28);
          v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, v30), (int8x8_t)v30, (int8x8_t)v27);
          v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29, v31), (int8x8_t)v29, (int8x8_t)v31);
LABEL_8:
          v19 = vcvt_s32_f32(v23);
          break;
        default:
          break;
      }
      --v4;
      v32 = v19.i32[0];
      v33 = v63 - 0x8000;
      if (v19.i32[0] < v63 - 0x8000)
        v33 = v19.i32[0];
      if (v33 <= -32768)
        v33 = -32768;
      v34 = v33 + 0x8000;
      if (v19.i32[0] <= 0x8000)
        v32 = 0x8000;
      v35 = v32 - 0x8000;
      if (v35 >= v63)
        v36 = v63;
      else
        v36 = v35;
      v37 = v19.i32[1];
      v38 = v62 - 0x8000;
      if (v19.i32[1] < v62 - 0x8000)
        v38 = v19.i32[1];
      if (v38 <= -32768)
        v38 = -32768;
      v39 = v38 + 0x8000;
      if (v19.i32[1] <= 0x8000)
        v37 = 0x8000;
      v40 = v37 - 0x8000;
      if (v40 >= v62)
        v41 = v62;
      else
        v41 = v40;
      v42 = v65 + v64 * ((uint64_t)v41 >> 16);
      v43 = v65 + v64 * HIWORD(v39);
      v44 = ((uint64_t)v36 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v45 = (v34 >> 15) & 0x1FFFE;
      v67 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v42 + v44));
      v46 = v70;
      *(float *)v46.i32 = v67;
      v47 = vzip1q_s32(v46, v46);
      *(float *)&v47.i32[2] = v67;
      v69 = (float32x4_t)v47;
      v66 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v42 + v45));
      v48 = v70;
      *(float *)v48.i32 = v66;
      v49 = vzip1q_s32(v48, v48);
      *(float *)&v49.i32[2] = v66;
      v68 = (float32x4_t)v49;
      v50 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v43 + v44));
      v51 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v43 + v45));
      v52 = (float)BYTE1(v41) * 0.0039062;
      v53 = (float32x4_t)vzip1q_s32((int32x4_t)COERCE_UNSIGNED_INT(v50 - v67), (int32x4_t)COERCE_UNSIGNED_INT(v50 - v67));
      v53.f32[2] = v50 - v67;
      *(float *)&v54 = v51 - v66;
      v55 = vmlaq_n_f32(v69, v53, v52);
      v56 = (float32x4_t)vzip1q_s32((int32x4_t)v54, (int32x4_t)v54);
      v56.i32[2] = v54;
      v6 = v6 + v5;
      v8 += v60;
      v7 += v61;
      *a3++ = vmlaq_n_f32(v55, vmlaq_n_f32(vsubq_f32(v68, v55), v56, v52), (float)BYTE1(v36) * 0.0039062);
      v9 = v59;
    }
    while (v4);
  }
}

uint64_t CA::OGL::SW::render_sampler<unsigned int,false,false>(float *a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v8;
  char *v9;
  size_t v10;
  uint64_t result;
  float v12;
  float v13;
  float v14;
  float v15;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v9 = (char *)v16 - v8;
  bzero((char *)v16 - v8, v10);
  result = (*(uint64_t (**)(float *, uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)a1 + 56)
                                                                        + 8 * a4))(a1, a2, v9, a4);
  if ((_DWORD)a2)
  {
    v13 = a1[19];
    v14 = a1[17] * 0.0039216;
    do
    {
      LOBYTE(v12) = v9[2];
      v15 = (float)(v13 - (float)(v14 * (float)LODWORD(v12))) + 0.5;
      if (v15 > 1.0)
        v15 = 1.0;
      if (v15 >= 0.0)
        v12 = (float)(v15 * 255.0) + 0.5;
      else
        v12 = 0.5;
      *a3++ = v12 | (v12 << 8) | ((v12 | (v12 << 8)) << 16);
      v9 += 4;
      LODWORD(a2) = a2 - 1;
    }
    while ((_DWORD)a2);
  }
  return result;
}

float CA::OGL::SW::render_sampler<unsigned int,false,true>(float *a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v8;
  char *v9;
  size_t v10;
  float result;
  float v12;
  float v13;
  float v14;
  float v15;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v9 = (char *)v16 - v8;
  bzero((char *)v16 - v8, v10);
  (*(void (**)(float *, uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)a1 + 56) + 8 * a4))(a1, a2, v9, a4);
  if ((_DWORD)a2)
  {
    result = a1[19];
    v13 = a1[17] * 0.0039216;
    v14 = 1.0 / a1[18];
    do
    {
      LOBYTE(v12) = v9[2];
      v15 = (float)((float)(result - (float)(v13 * (float)LODWORD(v12))) * v14) + 0.5;
      if (v15 > 1.0)
        v15 = 1.0;
      if (v15 < 0.0)
        v15 = 0.0;
      v12 = (float)((float)((float)(v15 * v15) * -255.0) * (float)((float)(v15 * 2.0) + -3.0)) + 0.5;
      *a3++ = v12 | (v12 << 8) | ((v12 | (v12 << 8)) << 16);
      v9 += 4;
      LODWORD(a2) = a2 - 1;
    }
    while ((_DWORD)a2);
  }
  return result;
}

uint64_t CA::OGL::SW::render_sampler<unsigned int,true,false>(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v8;
  char *v9;
  size_t v10;
  uint64_t result;
  int32x2_t v12;
  float32x2_t v13;
  float v14;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int8x8_t v23;
  float32x2_t v24;
  _QWORD v25[2];

  v25[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v9 = (char *)v25 - v8;
  bzero((char *)v25 - v8, v10);
  result = (*(uint64_t (**)(uint64_t, uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)a1 + 56)
                                                                        + 8 * a4))(a1, a2, v9, a4);
  if ((_DWORD)a2)
  {
    v13 = *(float32x2_t *)(a1 + 76);
    v14 = *(float *)(a1 + 68) * 0.0039216;
    __asm { FMOV            V3.2S, #1.0 }
    v20 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      v12.i8[0] = v9[2];
      *(float *)v12.i32 = v14 * (float)v12.u32[0];
      v21 = vadd_f32(vsub_f32(v13, (float32x2_t)vdup_lane_s32(v12, 0)), (float32x2_t)0x3F0000003F000000);
      v22 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v21, _D3), (int8x8_t)_D3, (int8x8_t)v21);
      v23.i32[0] = vsub_f32(_D3, v22).u32[0];
      v23.i32[1] = vmul_f32(v22, v20).i32[1];
      v24 = (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v22), (int8x8_t)1065353216, v23);
      v12 = (int32x2_t)vmul_lane_f32(v24, v24, 1);
      *(float *)v12.i32 = *(float *)v12.i32 + 0.5;
      *a3++ = *(float *)v12.i32 | (*(float *)v12.i32 << 8) | ((*(float *)v12.i32 | (*(float *)v12.i32 << 8)) << 16);
      v9 += 4;
      LODWORD(a2) = a2 - 1;
    }
    while ((_DWORD)a2);
  }
  return result;
}

uint64_t CA::OGL::SW::render_sampler<unsigned int,true,true>(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v8;
  char *v9;
  size_t v10;
  uint64_t result;
  int32x2_t v12;
  float32x2_t v14;
  float v15;
  float32x2_t v16;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  _QWORD v29[2];

  v29[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v9 = (char *)v29 - v8;
  bzero((char *)v29 - v8, v10);
  result = (*(uint64_t (**)(uint64_t, uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)a1 + 56)
                                                                        + 8 * a4))(a1, a2, v9, a4);
  if ((_DWORD)a2)
  {
    v14 = *(float32x2_t *)(a1 + 76);
    *(float *)v12.i32 = 1.0 / *(float *)(a1 + 72);
    v15 = *(float *)(a1 + 68) * 0.0039216;
    v16 = (float32x2_t)vdup_lane_s32(v12, 0);
    __asm
    {
      FMOV            V4.2S, #1.0
      FMOV            V6.2S, #3.0
    }
    do
    {
      _D7.i8[0] = v9[2];
      *(float *)_D7.i32 = v15 * (float)_D7.u32[0];
      v23 = vmla_f32((float32x2_t)0x3F0000003F000000, v16, vsub_f32(v14, (float32x2_t)vdup_lane_s32(_D7, 0)));
      v24 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v23, _D4), (int8x8_t)_D4, (int8x8_t)v23);
      v25 = (float32x2_t)vbic_s8((int8x8_t)v24, (int8x8_t)vcltz_f32(v24));
      v26 = vmla_f32(_D6, (float32x2_t)0xC0000000C0000000, v25);
      v25.i32[1] = vmul_f32(v25, v25).i32[1];
      _D16 = vmul_f32(v25, v26);
      v25.i32[1] = 1132396544;
      _D7 = (int32x2_t)vmul_f32(_D16, v25);
      _D16.f32[0] = 1.0 - *(float *)_D7.i32;
      __asm { FMLA            S17, S16, V7.S[1] }
      *a3++ = _S17 | (_S17 << 8) | ((_S17 | (_S17 << 8)) << 16);
      v9 += 4;
      LODWORD(a2) = a2 - 1;
    }
    while ((_DWORD)a2);
  }
  return result;
}

uint64_t CA::OGL::SW::render_sampler<CA::Vec4<float>,false,false>(float *a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v8;
  float *v9;
  size_t v10;
  uint64_t result;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v9 = (float *)&v17[-2 * v8];
  bzero(v9, v10);
  result = (*(uint64_t (**)(float *, uint64_t, float *, uint64_t))(*(_QWORD *)(*(_QWORD *)a1 + 56)
                                                                         + 8 * a4))(a1, a2, v9, a4);
  if ((_DWORD)a2)
  {
    v12 = a1[17];
    v13 = a1[19];
    do
    {
      v14 = *v9;
      v9 += 4;
      v15 = (float)(v13 - (float)(v14 * v12)) + 0.5;
      if (v15 > 1.0)
        v15 = 1.0;
      if (v15 >= 0.0)
        v16 = (float)(v15 * 255.0) + 0.5;
      else
        v16 = 0.5;
      *a3++ = v16 | (v16 << 8) | ((v16 | (v16 << 8)) << 16);
      LODWORD(a2) = a2 - 1;
    }
    while ((_DWORD)a2);
  }
  return result;
}

float CA::OGL::SW::render_sampler<CA::Vec4<float>,false,true>(float *a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v8;
  float *v9;
  size_t v10;
  float result;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v9 = (float *)&v17[-2 * v8];
  bzero(v9, v10);
  (*(void (**)(float *, uint64_t, float *, uint64_t))(*(_QWORD *)(*(_QWORD *)a1 + 56) + 8
                                                                                                 * a4))(a1, a2, v9, a4);
  if ((_DWORD)a2)
  {
    result = a1[19];
    v12 = a1[17];
    v13 = 1.0 / a1[18];
    do
    {
      v14 = *v9;
      v9 += 4;
      v15 = (float)((float)(result - (float)(v14 * v12)) * v13) + 0.5;
      if (v15 > 1.0)
        v15 = 1.0;
      if (v15 < 0.0)
        v15 = 0.0;
      v16 = (float)((float)((float)(v15 * v15) * -255.0) * (float)((float)(v15 * 2.0) + -3.0)) + 0.5;
      *a3++ = v16 | (v16 << 8) | ((v16 | (v16 << 8)) << 16);
      LODWORD(a2) = a2 - 1;
    }
    while ((_DWORD)a2);
  }
  return result;
}

uint64_t CA::OGL::SW::render_sampler<CA::Vec4<float>,true,false>(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v8;
  float *v9;
  size_t v10;
  uint64_t result;
  int32x2_t v12;
  float v13;
  float32x2_t v14;
  float32x2_t v20;
  float v21;
  float32x2_t v22;
  float32x2_t v23;
  int8x8_t v24;
  float32x2_t v25;
  _QWORD v26[2];

  v26[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v9 = (float *)&v26[-2 * v8];
  bzero(v9, v10);
  result = (*(uint64_t (**)(uint64_t, uint64_t, float *, uint64_t))(*(_QWORD *)(*(_QWORD *)a1 + 56)
                                                                         + 8 * a4))(a1, a2, v9, a4);
  if ((_DWORD)a2)
  {
    v13 = *(float *)(a1 + 68);
    v14 = *(float32x2_t *)(a1 + 76);
    __asm { FMOV            V3.2S, #1.0 }
    v20 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      v21 = *v9;
      v9 += 4;
      *(float *)v12.i32 = v21 * v13;
      v22 = vadd_f32(vsub_f32(v14, (float32x2_t)vdup_lane_s32(v12, 0)), (float32x2_t)0x3F0000003F000000);
      v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, _D3), (int8x8_t)_D3, (int8x8_t)v22);
      v24.i32[0] = vsub_f32(_D3, v23).u32[0];
      v24.i32[1] = vmul_f32(v23, v20).i32[1];
      v25 = (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v23), (int8x8_t)1065353216, v24);
      v12 = (int32x2_t)vmul_lane_f32(v25, v25, 1);
      *a3++ = (float)(*(float *)v12.i32 + 0.5) | ((float)(*(float *)v12.i32 + 0.5) << 8) | (((float)(*(float *)v12.i32 + 0.5) | ((float)(*(float *)v12.i32 + 0.5) << 8)) << 16);
      LODWORD(a2) = a2 - 1;
    }
    while ((_DWORD)a2);
  }
  return result;
}

uint64_t CA::OGL::SW::render_sampler<CA::Vec4<float>,true,true>(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v8;
  float *v9;
  size_t v10;
  uint64_t result;
  int32x2_t v12;
  float32x2_t v14;
  float v15;
  float32x2_t v16;
  float v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  _QWORD v30[2];

  v30[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v9 = (float *)&v30[-2 * v8];
  bzero(v9, v10);
  result = (*(uint64_t (**)(uint64_t, uint64_t, float *, uint64_t))(*(_QWORD *)(*(_QWORD *)a1 + 56)
                                                                         + 8 * a4))(a1, a2, v9, a4);
  if ((_DWORD)a2)
  {
    v14 = *(float32x2_t *)(a1 + 76);
    v15 = *(float *)(a1 + 68);
    *(float *)v12.i32 = 1.0 / *(float *)(a1 + 72);
    v16 = (float32x2_t)vdup_lane_s32(v12, 0);
    __asm
    {
      FMOV            V4.2S, #1.0
      FMOV            V6.2S, #3.0
    }
    do
    {
      v23 = *v9;
      v9 += 4;
      *(float *)_D7.i32 = v23 * v15;
      v24 = vmla_f32((float32x2_t)0x3F0000003F000000, v16, vsub_f32(v14, (float32x2_t)vdup_lane_s32(_D7, 0)));
      v25 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v24, _D4), (int8x8_t)_D4, (int8x8_t)v24);
      v26 = (float32x2_t)vbic_s8((int8x8_t)v25, (int8x8_t)vcltz_f32(v25));
      v27 = vmla_f32(_D6, (float32x2_t)0xC0000000C0000000, v26);
      v26.i32[1] = vmul_f32(v26, v26).i32[1];
      _D16 = vmul_f32(v26, v27);
      v26.i32[1] = 1132396544;
      _D7 = (int32x2_t)vmul_f32(_D16, v26);
      _D16.f32[0] = 1.0 - *(float *)_D7.i32;
      __asm { FMLA            S17, S16, V7.S[1] }
      *a3++ = _S17 | (_S17 << 8) | ((_S17 | (_S17 << 8)) << 16);
      LODWORD(a2) = a2 - 1;
    }
    while ((_DWORD)a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::gaussian_sampler<false>(uint64_t **result, int a2, unsigned int *a3)
{
  uint64_t v3;
  float32x2_t v4;
  uint64_t v5;
  float32x2_t v6;
  uint32x2_t v7;
  unsigned int v8;

  if (a2)
  {
    v3 = (2 * *((_DWORD *)result + 2));
    v4 = *(float32x2_t *)((char *)result[3] + 4 * v3 + 32);
    v5 = **result;
    v6 = *(float32x2_t *)((char *)result[2] + 4 * v3 + 32);
    do
    {
      v7 = vmin_u32(vcvt_u32_f32(vmla_f32((float32x2_t)0x3F0000003F000000, (float32x2_t)0x4400000044000000, v6)), (uint32x2_t)0x100000001);
      v8 = *(unsigned __int8 *)(v5 + v7.u32[0])
         + *(unsigned __int8 *)(v5 + v7.u32[0]) * *(unsigned __int8 *)(v5 + v7.u32[1]);
      v6 = vadd_f32(v6, v4);
      *a3++ = v8 & 0x1FF00 | (v8 >> 8) | ((v8 & 0x1FF00 | (v8 >> 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::gaussian_sampler<true>(uint64_t **result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  float32x2_t v6;
  float v7;
  uint64_t v8;
  float v9;
  float32x2_t v10;
  uint32x2_t v11;
  unsigned int v12;

  if (a2)
  {
    v3 = (2 * *((_DWORD *)result + 2));
    v5 = result[2];
    v4 = result[3];
    v6 = *(float32x2_t *)((char *)v4 + 4 * v3 + 32);
    v7 = *((float *)v4 + 3);
    v8 = **result;
    v9 = *((float *)v5 + 3);
    v10 = *(float32x2_t *)((char *)v5 + 4 * v3 + 32);
    do
    {
      v11 = vmin_u32(vcvt_u32_f32(vmla_n_f32((float32x2_t)0x3F0000003F000000, v10, 512.0 / v9)), (uint32x2_t)0x100000001);
      v12 = *(unsigned __int8 *)(v8 + v11.u32[0])
          + *(unsigned __int8 *)(v8 + v11.u32[0]) * *(unsigned __int8 *)(v8 + v11.u32[1]);
      v9 = v9 + v7;
      v10 = vadd_f32(v10, v6);
      *a3++ = v12 & 0x1FF00 | (v12 >> 8) | ((v12 & 0x1FF00 | (v12 >> 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::uneven_circle_sampler<false,true>(uint64_t result, unsigned int a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  int32x2_t v9;
  int32x2_t v10;
  int32x2_t v11;
  int32x2_t v12;
  int32x2_t v13;
  int32x2_t v14;
  int32x2_t v15;
  int32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;
  int32x2_t v19;
  int32x2_t v20;
  int32x2_t v21;
  int32x2_t v22;
  int32x2_t v23;
  int32x2_t v24;
  unint64_t v25;
  unsigned int v26;
  __int32 *v27;
  uint64_t v28;
  uint64_t v29;
  const float *v30;
  const float *v31;
  uint64_t v32;
  const float *v33;
  const float *v34;
  uint64x2_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int8x16_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v53;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  int8x16_t v101;
  int32x4_t v102;
  int32x4_t v103;
  float32x4_t v104;
  int8x16_t v105;
  float32x4_t v106;
  float32x4_t v107;
  int32x4_t v108;
  uint32x4_t v109;
  float32x4_t v110;
  uint32x4_t v111;
  float32x4_t v112;
  uint32x4_t v113;
  float32x4_t v114;
  int32x4_t v115;
  uint32x4_t v116;
  int32x2_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float v142;
  float v143;
  float v144;
  float v145;
  float v146;

  if (a2)
  {
    v25 = 0;
    v26 = *(_DWORD *)(result + 8);
    v27 = (__int32 *)(*(_QWORD *)(result + 104) + 48 * v26);
    LODWORD(a7) = v27[6];
    LODWORD(a5) = v27[7];
    *(float *)v20.i32 = 1.0 / *(float *)&a5;
    *(float *)v21.i32 = 1.0 / *(float *)&a7;
    LODWORD(a6) = v27[4];
    LODWORD(a8) = v27[5];
    *(float *)v22.i32 = 1.0 / *(float *)&a8;
    v10.i32[0] = v27[2];
    LODWORD(a9) = v27[3];
    *(float *)v23.i32 = 1.0 / *(float *)&a9;
    *(float *)v24.i32 = 1.0 / *(float *)v10.i32;
    v14.i32[0] = *v27;
    v12.i32[0] = v27[1];
    LODWORD(v27) = 2 * v26;
    v28 = *(_QWORD *)(result + 40) + 8 * v26;
    *(float *)v9.i32 = 1.0 / *(float *)v12.i32;
    v15.i32[0] = *(_DWORD *)(v28 + 32);
    v16.i32[0] = *(_DWORD *)(v28 + 36);
    v29 = *(_QWORD *)(result + 24) + 4 * v27;
    v11.i32[0] = *(_DWORD *)(v29 + 32);
    v13.i32[0] = *(_DWORD *)(v29 + 36);
    *(float *)v17.i32 = fabsf(*(float *)v13.i32);
    *(float *)v18.i32 = fabsf(*(float *)v11.i32);
    v30 = (const float *)(*(_QWORD *)(result + 16) + 4 * v27);
    v31 = v30 + 8;
    v30 += 9;
    v32 = *(_QWORD *)(result + 32) + 4 * v27;
    v33 = (const float *)(v32 + 32);
    v34 = (const float *)(v32 + 36);
    v35 = (uint64x2_t)vdupq_n_s64((unint64_t)a2 - 1);
    v36 = vld1q_dup_f32(v31);
    v37 = vmlaq_n_f32(v36, (float32x4_t)xmmword_18474E430, *(float *)v11.i32);
    *(float *)v11.i32 = *(float *)v11.i32 * 4.0;
    v141 = (float32x4_t)vdupq_lane_s32(v11, 0);
    v38 = vld1q_dup_f32(v30);
    v39 = vmlaq_n_f32(v38, (float32x4_t)xmmword_18474E430, *(float *)v13.i32);
    *(float *)v13.i32 = *(float *)v13.i32 * 4.0;
    v140 = (float32x4_t)vdupq_lane_s32(v13, 0);
    v40 = vld1q_dup_f32(v33);
    v41 = vmlaq_n_f32(v40, (float32x4_t)xmmword_18474E430, *(float *)v15.i32);
    *(float *)v15.i32 = *(float *)v15.i32 * 4.0;
    v139 = (float32x4_t)vdupq_lane_s32(v15, 0);
    v42 = vld1q_dup_f32(v34);
    *(float *)v19.i32 = *(float *)v16.i32 * 4.0;
    v137 = (float32x4_t)vdupq_lane_s32(v18, 0);
    v138 = (float32x4_t)vdupq_lane_s32(v19, 0);
    v43 = vmlaq_n_f32(v42, (float32x4_t)xmmword_18474E430, *(float *)v16.i32);
    *(float *)v16.i32 = 1.0 / *(float *)v14.i32;
    v135 = 1.0 / *(float *)v14.i32;
    v136 = (float32x4_t)vdupq_lane_s32(v17, 0);
    v142 = 1.0 / *(float *)v12.i32;
    v143 = 1.0 / *(float *)v10.i32;
    v133 = (float32x4_t)vdupq_lane_s32(v9, 0);
    v134 = (float32x4_t)vdupq_lane_s32(v16, 0);
    v131 = (float32x4_t)vdupq_lane_s32(v23, 0);
    v132 = (float32x4_t)vdupq_lane_s32(v24, 0);
    v129 = (float32x4_t)vdupq_lane_s32(v12, 0);
    v130 = (float32x4_t)vdupq_lane_s32(v14, 0);
    v127 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
    v128 = (float32x4_t)vdupq_lane_s32(v10, 0);
    v125 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
    v126 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a6, 0);
    v123 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 0);
    v124 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a7, 0);
    *(float *)&a4 = 1.0 / *(float *)&a6;
    v122 = 1.0 / *(float *)&a6;
    v144 = 1.0 / *(float *)&a8;
    v145 = 1.0 / *(float *)&a7;
    v120 = (float32x4_t)vdupq_lane_s32(v22, 0);
    v121 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
    v119 = (float32x4_t)vdupq_lane_s32(v21, 0);
    v146 = 1.0 / *(float *)&a5;
    v118 = (float32x4_t)vdupq_lane_s32(v20, 0);
    v44.i64[0] = 0x3F0000003F000000;
    v44.i64[1] = 0x3F0000003F000000;
    v45.i64[0] = 0xFF000000FFLL;
    v45.i64[1] = 0xFF000000FFLL;
    do
    {
      v46 = vaddq_f32(vabsq_f32(v41), v137);
      v47 = vaddq_f32(vabsq_f32(v43), v136);
      __asm { FMOV            V0.4S, #-1.0 }
      v53 = vminnmq_f32(vmlaq_f32(_Q0, v134, v37), (float32x4_t)0);
      __asm { FMOV            V20.4S, #1.0 }
      v55 = vsubq_f32(_Q20, v39);
      v56 = vminnmq_f32(vmlaq_f32(_Q0, v133, v55), (float32x4_t)0);
      v57 = vsubq_f32(_Q20, v37);
      v58 = vminnmq_f32(vmlaq_f32(_Q0, v132, v57), (float32x4_t)0);
      v59 = vminnmq_f32(vmlaq_f32(_Q0, v131, v55), (float32x4_t)0);
      v60 = vminnmq_f32(vmlaq_f32(_Q0, v121, v57), (float32x4_t)0);
      v61 = vminnmq_f32(vmlaq_f32(_Q0, v120, v39), (float32x4_t)0);
      v62 = vminnmq_f32(vmlaq_f32(_Q0, v119, v37), (float32x4_t)0);
      v63 = vminnmq_f32(vmlaq_f32(_Q0, v118, v39), (float32x4_t)0);
      v64 = vminnmq_f32(v130, vmulq_n_f32(v46, v135));
      v65 = vminnmq_f32(v129, vmulq_n_f32(v47, v142));
      v66 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v64, v65), (int8x16_t)v64, (int8x16_t)v65);
      v67 = vabsq_f32(v56);
      v68 = vabsq_f32(v53);
      v69 = vdivq_f32(vminnmq_f32(v68, v67), vmaxnmq_f32(v68, v67));
      v70 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v69, _Q20), (int8x16_t)_Q20, (int8x16_t)v69);
      v71 = (float32x4_t)vdupq_n_s32(0x3F6D11E0u);
      v72 = (float32x4_t)vdupq_n_s32(0xC049FC11);
      v73 = (float32x4_t)vdupq_n_s32(0x406909C0u);
      v74 = (float32x4_t)vdupq_n_s32(0xBFA24ECF);
      v75 = (float32x4_t)vdupq_n_s32(0xBE897CE5);
      v76 = vmlaq_f32(_Q20, vmlaq_f32(v75, v70, vmlaq_f32(v74, v70, vmlaq_f32(v73, v70, vmlaq_f32(v72, v71, v70)))), vmulq_f32(v70, v70));
      v77 = vminnmq_f32(v128, vmulq_n_f32(v46, v143));
      v78 = vminnmq_f32(v127, vmulq_n_f32(v47, 1.0 / *(float *)&a9));
      v79 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v77, v78), (int8x16_t)v77, (int8x16_t)v78);
      v80 = vabsq_f32(v59);
      v81 = vabsq_f32(v58);
      v82 = vdivq_f32(vminnmq_f32(v81, v80), vmaxnmq_f32(v81, v80));
      v83 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v82, _Q20), (int8x16_t)_Q20, (int8x16_t)v82);
      v84 = vmlaq_f32(_Q20, vmlaq_f32(v75, v83, vmlaq_f32(v74, v83, vmlaq_f32(v73, v83, vmlaq_f32(v72, v71, v83)))), vmulq_f32(v83, v83));
      v85 = vminnmq_f32(v126, vmulq_n_f32(v46, v122));
      v86 = vminnmq_f32(v125, vmulq_n_f32(v47, v144));
      v87 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v85, v86), (int8x16_t)v85, (int8x16_t)v86);
      v88 = vabsq_f32(v61);
      v89 = vabsq_f32(v60);
      v90 = vdivq_f32(vminnmq_f32(v89, v88), vmaxnmq_f32(v89, v88));
      v91 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v90, _Q20), (int8x16_t)_Q20, (int8x16_t)v90);
      v92 = vmlaq_f32(_Q20, vmlaq_f32(v75, v91, vmlaq_f32(v74, v91, vmlaq_f32(v73, v91, vmlaq_f32(v72, v71, v91)))), vmulq_f32(v91, v91));
      v93 = vminnmq_f32(v124, vmulq_n_f32(v46, v145));
      v94 = vminnmq_f32(v123, vmulq_n_f32(v47, v146));
      v95 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v93, v94), (int8x16_t)v93, (int8x16_t)v94);
      v96 = vabsq_f32(v63);
      v97 = vabsq_f32(v62);
      v98 = vdivq_f32(vminnmq_f32(v97, v96), vmaxnmq_f32(v97, v96));
      v99 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v98, _Q20), (int8x16_t)_Q20, (int8x16_t)v98);
      v100 = vmlaq_f32(_Q20, vmlaq_f32(v75, v99, vmlaq_f32(v74, v99, vmlaq_f32(v73, v99, vmlaq_f32(v72, v71, v99)))), vmulq_f32(v99, v99));
      v101 = (int8x16_t)vdupq_n_s64(v25);
      v102 = (int32x4_t)vcgeq_u64(v35, (uint64x2_t)vorrq_s8(v101, (int8x16_t)xmmword_18474E440));
      v103 = (int32x4_t)vcgeq_u64(v35, (uint64x2_t)vorrq_s8(v101, (int8x16_t)xmmword_18474E1C0));
      v104 = vmlaq_f32(vmulq_f32(v53, v53), v56, v56);
      v105 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q20, v66), v104);
      v106 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      v107 = vdivq_f32(vmulq_f32(vaddq_f32(vmlaq_f32(vnegq_f32(vsqrtq_f32(v104)), v44, v66), vdivq_f32(_Q20, v76)), v106), v66);
      v108 = vuzp1q_s32(v103, v102);
      v109 = (uint32x4_t)vbslq_s8(vandq_s8((int8x16_t)v108, v105), v45, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(v107, v44)), (int32x4_t)0), (uint32x4_t)v45));
      v110 = vmlaq_f32(vmulq_f32(v59, v59), v58, v58);
      v111 = (uint32x4_t)vbslq_s8(vandq_s8((int8x16_t)v108, (int8x16_t)vcgtq_f32(vsubq_f32(_Q20, v79), v110)), v45, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vaddq_f32(vmlaq_f32(vnegq_f32(vsqrtq_f32(v110)), v44, v79), vdivq_f32(_Q20, v84)), v106), v79), v44)), (int32x4_t)0), (uint32x4_t)v45));
      v112 = vmlaq_f32(vmulq_f32(v61, v61), v60, v60);
      v113 = (uint32x4_t)vbslq_s8(vandq_s8((int8x16_t)v108, (int8x16_t)vcgtq_f32(vsubq_f32(_Q20, v87), v112)), v45, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vaddq_f32(vmlaq_f32(vnegq_f32(vsqrtq_f32(v112)), v44, v87), vdivq_f32(_Q20, v92)), v106), v87), v44)), (int32x4_t)0), (uint32x4_t)v45));
      v114 = vmlaq_f32(vmulq_f32(v63, v63), v62, v62);
      v115 = (int32x4_t)vminq_u32(v113, (uint32x4_t)vbslq_s8(vandq_s8((int8x16_t)v108, (int8x16_t)vcgtq_f32(vsubq_f32(_Q20, v95), v114)), v45, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vaddq_f32(vmlaq_f32(vnegq_f32(vsqrtq_f32(v114)), v44, v95), vdivq_f32(_Q20, v100)), v106), v95), v44)),
                                                                   (int32x4_t)0),
                                                     (uint32x4_t)v45)));
      v116 = vminq_u32(vminq_u32(v109, v111), (uint32x4_t)v115);
      if ((vmovn_s32(v108).u8[0] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v25) = 16843009 * v116.i32[0];
      *(int32x2_t *)v115.i8 = vmovn_s64((int64x2_t)v103);
      *(int16x4_t *)v115.i8 = vmovn_s32(v115);
      if ((v115.i8[2] & 1) != 0)
      {
        result = (16843009 * v116.i32[1]);
        *(_DWORD *)(a3 + 4 * v25 + 4) = result;
      }
      v117 = (int32x2_t)vmovn_s32(vmovn_hight_s64(*(int32x2_t *)v115.i8, (int64x2_t)v102));
      if ((v117.i8[4] & 1) != 0)
      {
        result = (16843009 * v116.i32[2]);
        *(_DWORD *)(a3 + 4 * v25 + 8) = result;
      }
      if ((vmovn_s32(vmovn_hight_s64(v117, *(int64x2_t *)&v102)).i8[6] & 1) != 0)
      {
        result = (16843009 * v116.i32[3]);
        *(_DWORD *)(a3 + 4 * v25 + 12) = result;
      }
      v25 += 4;
      v37 = vaddq_f32(v37, v141);
      v39 = vaddq_f32(v39, v140);
      v41 = vaddq_f32(v41, v139);
      v43 = vaddq_f32(v43, v138);
    }
    while (((a2 + 3) & 0x1FFFFFFFCLL) != v25);
  }
  return result;
}

uint64_t CA::OGL::SW::uneven_circle_sampler<true,true>(uint64_t result, unsigned int a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  int32x2_t v11;
  int32x2_t v12;
  int32x2_t v13;
  int32x2_t v14;
  int32x2_t v15;
  int32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;
  int32x2_t v19;
  int32x2_t v20;
  int32x2_t v21;
  int32x2_t v22;
  unint64_t v23;
  unsigned int v24;
  __int32 *v25;
  uint64_t v26;
  const float *v27;
  uint64_t v28;
  float v29;
  uint64_t v30;
  const float *v31;
  const float *v32;
  const float *v33;
  uint64_t v34;
  const float *v35;
  const float *v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  int8x16_t v49;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  int8x16_t v108;
  uint64x2_t v109;
  int32x4_t v110;
  int32x4_t v111;
  float32x4_t v112;
  int8x16_t v113;
  float32x4_t v114;
  float32x4_t v115;
  int32x4_t v116;
  float32x4_t v117;
  uint32x4_t v118;
  float32x4_t v119;
  uint32x4_t v120;
  float32x4_t v121;
  uint32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  uint64x2_t v146;
  float v147;
  float v148;
  float v149;
  float v150;
  float v151;
  float v152;
  float v153;

  if (a2)
  {
    v23 = 0;
    v24 = *(_DWORD *)(result + 8);
    v25 = (__int32 *)(*(_QWORD *)(result + 104) + 48 * v24);
    LODWORD(a6) = v25[6];
    LODWORD(a5) = v25[7];
    *(float *)v11.i32 = 1.0 / *(float *)&a5;
    *(float *)v18.i32 = 1.0 / *(float *)&a6;
    LODWORD(a9) = v25[4];
    LODWORD(a8) = v25[5];
    *(float *)v19.i32 = 1.0 / *(float *)&a8;
    *(float *)v20.i32 = 1.0 / *(float *)&a9;
    LODWORD(a7) = v25[2];
    LODWORD(a10) = v25[3];
    *(float *)v21.i32 = 1.0 / *(float *)&a10;
    v12.i32[0] = *v25;
    LODWORD(a11) = v25[1];
    v27 = *(const float **)(result + 16);
    v26 = *(_QWORD *)(result + 24);
    v14.i32[0] = *(_DWORD *)(v26 + 12);
    v24 *= 2;
    *(float *)v22.i32 = 1.0 / *(float *)&a11;
    v28 = *(_QWORD *)(result + 40) + 4 * v24;
    v29 = *(float *)(v28 + 32);
    v16.i32[0] = *(_DWORD *)(v28 + 36);
    v30 = v26 + 4 * v24;
    v15.i32[0] = *(_DWORD *)(v30 + 32);
    v17.i32[0] = *(_DWORD *)(v30 + 36);
    v31 = &v27[v24];
    v32 = v31 + 8;
    v33 = v31 + 9;
    v34 = *(_QWORD *)(result + 32) + 4 * v24;
    v35 = (const float *)(v34 + 32);
    v36 = (const float *)(v34 + 36);
    v27 += 3;
    v146 = (uint64x2_t)vdupq_n_s64((unint64_t)a2 - 1);
    v37 = vld1q_dup_f32(v32);
    *(float *)v13.i32 = *(float *)v15.i32 * 4.0;
    v145 = (float32x4_t)vdupq_lane_s32(v13, 0);
    v147 = *(float *)v15.i32;
    v148 = *(float *)v17.i32;
    v38 = vmlaq_n_f32(v37, (float32x4_t)xmmword_18474E430, *(float *)v15.i32);
    v39 = vld1q_dup_f32(v33);
    *(float *)v15.i32 = *(float *)v17.i32 * 4.0;
    v144 = (float32x4_t)vdupq_lane_s32(v15, 0);
    v40 = vmlaq_n_f32(v39, (float32x4_t)xmmword_18474E430, *(float *)v17.i32);
    v41 = vld1q_dup_f32(v35);
    *(float *)v17.i32 = v29 * 4.0;
    v42 = vdupq_lane_s32(v17, 0);
    v143 = (float32x4_t)v42;
    v43 = vmlaq_n_f32(v41, (float32x4_t)xmmword_18474E430, v29);
    v44 = vld1q_dup_f32(v36);
    *(float *)v42.i32 = *(float *)v16.i32 * 4.0;
    v142 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.i8, 0);
    v45 = vmlaq_n_f32(v44, (float32x4_t)xmmword_18474E430, *(float *)v16.i32);
    v46 = vld1q_dup_f32(v27);
    *(float *)v16.i32 = *(float *)v14.i32 * 4.0;
    v47 = vmlaq_n_f32(v46, (float32x4_t)xmmword_18474E430, *(float *)v14.i32);
    *(float *)v14.i32 = 1.0 / *(float *)v12.i32;
    v140 = 1.0 / *(float *)v12.i32;
    v141 = (float32x4_t)vdupq_lane_s32(v16, 0);
    v149 = 1.0 / *(float *)&a11;
    v138 = (float32x4_t)vdupq_lane_s32(v22, 0);
    v139 = (float32x4_t)vdupq_lane_s32(v14, 0);
    v136 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a11, 0);
    v137 = (float32x4_t)vdupq_lane_s32(v12, 0);
    v134 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a10, 0);
    v135 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a7, 0);
    v132 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
    v133 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
    v130 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 0);
    v131 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a6, 0);
    *(float *)&a4 = 1.0 / *(float *)&a7;
    v129 = 1.0 / *(float *)&a7;
    v150 = 1.0 / *(float *)&a9;
    v127 = (float32x4_t)vdupq_lane_s32(v21, 0);
    v128 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
    v151 = 1.0 / *(float *)&a8;
    v152 = 1.0 / *(float *)&a6;
    v125 = (float32x4_t)vdupq_lane_s32(v19, 0);
    v126 = (float32x4_t)vdupq_lane_s32(v20, 0);
    v124 = (float32x4_t)vdupq_lane_s32(v18, 0);
    v153 = 1.0 / *(float *)&a5;
    v123 = (float32x4_t)vdupq_lane_s32(v11, 0);
    v48.i64[0] = 0x3F0000003F000000;
    v48.i64[1] = 0x3F0000003F000000;
    v49.i64[0] = 0xFF000000FFLL;
    v49.i64[1] = 0xFF000000FFLL;
    __asm { FMOV            V22.4S, #1.0 }
    do
    {
      v55 = vdivq_f32(_Q22, v47);
      v56 = vmulq_f32(v38, v55);
      v57 = vmulq_f32(v40, v55);
      v58 = vaddq_f32(vabsq_f32(vmulq_f32(v43, v55)), vabsq_f32(vmulq_n_f32(v55, v147)));
      v59 = vaddq_f32(vabsq_f32(vmulq_n_f32(v55, v148)), vabsq_f32(vmulq_f32(v45, v55)));
      __asm { FMOV            V0.4S, #-1.0 }
      v61 = vminnmq_f32(vmlaq_f32(_Q0, v139, v56), (float32x4_t)0);
      v62 = vsubq_f32(_Q22, v57);
      v63 = vminnmq_f32(vmlaq_f32(_Q0, v138, v62), (float32x4_t)0);
      v64 = vsubq_f32(_Q22, v56);
      v65 = vminnmq_f32(vmlaq_f32(_Q0, v128, v64), (float32x4_t)0);
      v66 = vminnmq_f32(vmlaq_f32(_Q0, v127, v62), (float32x4_t)0);
      v67 = vminnmq_f32(vmlaq_f32(_Q0, v126, v64), (float32x4_t)0);
      v68 = vminnmq_f32(vmlaq_f32(_Q0, v125, v57), (float32x4_t)0);
      v69 = vminnmq_f32(vmlaq_f32(_Q0, v124, v56), (float32x4_t)0);
      v70 = vminnmq_f32(vmlaq_f32(_Q0, v123, v57), (float32x4_t)0);
      v71 = vminnmq_f32(v137, vmulq_n_f32(v58, v140));
      v72 = vminnmq_f32(v136, vmulq_n_f32(v59, v149));
      v73 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v71, v72), (int8x16_t)v71, (int8x16_t)v72);
      v74 = vabsq_f32(v63);
      v75 = vabsq_f32(v61);
      v76 = vdivq_f32(vminnmq_f32(v75, v74), vmaxnmq_f32(v75, v74));
      v77 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v76, _Q22), (int8x16_t)_Q22, (int8x16_t)v76);
      v78 = (float32x4_t)vdupq_n_s32(0x3F6D11E0u);
      v79 = (float32x4_t)vdupq_n_s32(0xC049FC11);
      v80 = (float32x4_t)vdupq_n_s32(0x406909C0u);
      v81 = (float32x4_t)vdupq_n_s32(0xBFA24ECF);
      v82 = (float32x4_t)vdupq_n_s32(0xBE897CE5);
      v83 = vmlaq_f32(_Q22, vmlaq_f32(v82, v77, vmlaq_f32(v81, v77, vmlaq_f32(v80, v77, vmlaq_f32(v79, v78, v77)))), vmulq_f32(v77, v77));
      v84 = vminnmq_f32(v135, vmulq_n_f32(v58, v129));
      v85 = vminnmq_f32(v134, vmulq_n_f32(v59, 1.0 / *(float *)&a10));
      v86 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v84, v85), (int8x16_t)v84, (int8x16_t)v85);
      v87 = vabsq_f32(v66);
      v88 = vabsq_f32(v65);
      v89 = vdivq_f32(vminnmq_f32(v88, v87), vmaxnmq_f32(v88, v87));
      v90 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v89, _Q22), (int8x16_t)_Q22, (int8x16_t)v89);
      v91 = vmlaq_f32(_Q22, vmlaq_f32(v82, v90, vmlaq_f32(v81, v90, vmlaq_f32(v80, v90, vmlaq_f32(v79, v78, v90)))), vmulq_f32(v90, v90));
      v92 = vminnmq_f32(v133, vmulq_n_f32(v58, v150));
      v93 = vminnmq_f32(v132, vmulq_n_f32(v59, v151));
      v94 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v92, v93), (int8x16_t)v92, (int8x16_t)v93);
      v95 = vabsq_f32(v68);
      v96 = vabsq_f32(v67);
      v97 = vdivq_f32(vminnmq_f32(v96, v95), vmaxnmq_f32(v96, v95));
      v98 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v97, _Q22), (int8x16_t)_Q22, (int8x16_t)v97);
      v99 = vmlaq_f32(_Q22, vmlaq_f32(v82, v98, vmlaq_f32(v81, v98, vmlaq_f32(v80, v98, vmlaq_f32(v79, v78, v98)))), vmulq_f32(v98, v98));
      v100 = vminnmq_f32(v131, vmulq_n_f32(v58, v152));
      v101 = vminnmq_f32(v130, vmulq_n_f32(v59, v153));
      v102 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v100, v101), (int8x16_t)v100, (int8x16_t)v101);
      v103 = vabsq_f32(v70);
      v104 = vabsq_f32(v69);
      v105 = vdivq_f32(vminnmq_f32(v104, v103), vmaxnmq_f32(v104, v103));
      v106 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v105, _Q22), (int8x16_t)_Q22, (int8x16_t)v105);
      v107 = vmlaq_f32(_Q22, vmlaq_f32(v82, v106, vmlaq_f32(v81, v106, vmlaq_f32(v80, v106, vmlaq_f32(v79, v78, v106)))), vmulq_f32(v106, v106));
      v108 = (int8x16_t)vdupq_n_s64(v23);
      v109 = (uint64x2_t)vorrq_s8(v108, (int8x16_t)xmmword_18474E1C0);
      v110 = (int32x4_t)vcgeq_u64(v146, (uint64x2_t)vorrq_s8(v108, (int8x16_t)xmmword_18474E440));
      v111 = (int32x4_t)vcgeq_u64(v146, v109);
      v112 = vmlaq_f32(vmulq_f32(v61, v61), v63, v63);
      v113 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q22, v73), v112);
      v114 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      v115 = vdivq_f32(vmulq_f32(vaddq_f32(vmlaq_f32(vnegq_f32(vsqrtq_f32(v112)), v48, v73), vdivq_f32(_Q22, v83)), v114), v73);
      v116 = vuzp1q_s32(v111, v110);
      v117 = vmlaq_f32(vmulq_f32(v66, v66), v65, v65);
      v118 = (uint32x4_t)vbslq_s8(vandq_s8((int8x16_t)v116, (int8x16_t)vcgtq_f32(vsubq_f32(_Q22, v86), v117)), v49, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vaddq_f32(vmlaq_f32(vnegq_f32(vsqrtq_f32(v117)), v48, v86), vdivq_f32(_Q22, v91)), v114), v86), v48)), (int32x4_t)0), (uint32x4_t)v49));
      v119 = vmlaq_f32(vmulq_f32(v68, v68), v67, v67);
      v120 = (uint32x4_t)vbslq_s8(vandq_s8((int8x16_t)v116, (int8x16_t)vcgtq_f32(vsubq_f32(_Q22, v94), v119)), v49, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vaddq_f32(vmlaq_f32(vnegq_f32(vsqrtq_f32(v119)), v48, v94), vdivq_f32(_Q22, v99)), v114), v94), v48)), (int32x4_t)0), (uint32x4_t)v49));
      v121 = vmlaq_f32(vmulq_f32(v70, v70), v69, v69);
      v122 = vminq_u32(vminq_u32((uint32x4_t)vbslq_s8(vandq_s8((int8x16_t)v116, v113), v49, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(v115, v48)), (int32x4_t)0), (uint32x4_t)v49)), v118), vminq_u32(v120, (uint32x4_t)vbslq_s8(vandq_s8((int8x16_t)v116, (int8x16_t)vcgtq_f32(vsubq_f32(_Q22, v102), v121)), v49, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(
                                                                  vaddq_f32(vmlaq_f32(vnegq_f32(vsqrtq_f32(v121)), v48, v102), vdivq_f32(_Q22, v107)), v114), v102), v48)), (int32x4_t)0), (uint32x4_t)v49))));
      if ((vmovn_s32(v116).u8[0] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v23) = 16843009 * v122.i32[0];
      *(int32x2_t *)v111.i8 = vmovn_s64((int64x2_t)v111);
      *(int16x4_t *)v111.i8 = vmovn_s32(v111);
      if ((v111.i8[2] & 1) != 0)
      {
        result = (16843009 * v122.i32[1]);
        *(_DWORD *)(a3 + 4 * v23 + 4) = result;
      }
      if ((vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v111, *(int64x2_t *)&v110)).i32[1] & 1) != 0)
      {
        result = (16843009 * v122.i32[2]);
        *(_DWORD *)(a3 + 4 * v23 + 8) = result;
      }
      if ((vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v110, *(int64x2_t *)&v110)).i8[6] & 1) != 0)
      {
        result = (16843009 * v122.i32[3]);
        *(_DWORD *)(a3 + 4 * v23 + 12) = result;
      }
      v23 += 4;
      v38 = vaddq_f32(v38, v145);
      v40 = vaddq_f32(v40, v144);
      v43 = vaddq_f32(v43, v143);
      v45 = vaddq_f32(v45, v142);
      v47 = vaddq_f32(v47, v141);
    }
    while (((a2 + 3) & 0x1FFFFFFFCLL) != v23);
  }
  return result;
}

uint64_t CA::OGL::SW::uneven_circle_sampler<false,false>(uint64_t result, unsigned int a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  int32x2_t v9;
  int32x2_t v10;
  int32x2_t v11;
  int32x2_t v12;
  int32x2_t v13;
  int32x2_t v14;
  int32x2_t v15;
  int32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;
  int32x2_t v19;
  int32x2_t v20;
  int32x2_t v21;
  int32x2_t v22;
  unint64_t v23;
  unsigned int v24;
  __int32 *v25;
  uint64_t v26;
  float v27;
  float v28;
  uint64_t v29;
  float v30;
  float v31;
  const float *v32;
  uint64x2_t v33;
  const float *v34;
  uint64_t v35;
  const float *v36;
  const float *v37;
  float32x4_t v38;
  int32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  int32x4_t v48;
  float32x4_t v49;
  float v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int8x16_t v54;
  int8x16_t v55;
  uint64x2_t v56;
  int32x4_t v57;
  int32x4_t v58;
  int32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v67;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  int8x16_t v79;
  float32x4_t v80;
  uint32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  int8x16_t v90;
  float32x4_t v91;
  int8x16_t v92;
  float32x4_t v93;
  int8x16_t v94;
  float32x4_t v95;
  uint32x4_t v96;
  float32x4_t v97;
  int8x16_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  int8x16_t v102;
  int8x16_t v103;
  int8x16_t v104;
  float32x4_t v105;
  float32x4_t v106;
  uint32x4_t v107;
  float32x4_t v108;
  int8x16_t v109;
  uint32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float v131;
  float v132;

  if (a2)
  {
    v23 = 0;
    v24 = *(_DWORD *)(result + 8);
    v25 = (__int32 *)(*(_QWORD *)(result + 104) + 48 * v24);
    LODWORD(a6) = v25[6];
    LODWORD(a4) = v25[7];
    *(float *)v19.i32 = 1.0 / *(float *)&a6;
    LODWORD(a8) = v25[4];
    LODWORD(a7) = v25[5];
    *(float *)v20.i32 = 1.0 / *(float *)&a7;
    *(float *)v21.i32 = 1.0 / *(float *)&a8;
    v12.i32[0] = v25[2];
    LODWORD(a9) = v25[3];
    *(float *)v22.i32 = 1.0 / *(float *)&a9;
    *(float *)v9.i32 = 1.0 / *(float *)v12.i32;
    v14.i32[0] = *v25;
    v13.i32[0] = v25[1];
    LODWORD(v25) = 2 * v24;
    v26 = *(_QWORD *)(result + 40) + 8 * v24;
    *(float *)v10.i32 = 1.0 / *(float *)v13.i32;
    v27 = *(float *)(v26 + 32);
    v28 = *(float *)(v26 + 36);
    v29 = *(_QWORD *)(result + 24) + 4 * v25;
    v30 = *(float *)(v29 + 32);
    v31 = *(float *)(v29 + 36);
    *(float *)v15.i32 = fabsf(v31);
    *(float *)v16.i32 = fabsf(v30);
    v32 = (const float *)(*(_QWORD *)(result + 16) + 4 * v25);
    v33 = (uint64x2_t)vdupq_n_s64((unint64_t)a2 - 1);
    v34 = v32 + 8;
    v32 += 9;
    v35 = *(_QWORD *)(result + 32) + 4 * v25;
    v36 = (const float *)(v35 + 32);
    v37 = (const float *)(v35 + 36);
    v38 = vld1q_dup_f32(v34);
    *(float *)v18.i32 = v30 * 4.0;
    v39 = vdupq_lane_s32(v18, 0);
    v130 = (float32x4_t)v39;
    v40 = vmlaq_n_f32(v38, (float32x4_t)xmmword_18474E430, v30);
    v41 = vld1q_dup_f32(v32);
    *(float *)v39.i32 = v31 * 4.0;
    v42 = vdupq_lane_s32(*(int32x2_t *)v39.i8, 0);
    v129 = (float32x4_t)v42;
    v43 = vmlaq_n_f32(v41, (float32x4_t)xmmword_18474E430, v31);
    v44 = vld1q_dup_f32(v36);
    *(float *)v42.i32 = v27 * 4.0;
    v45 = vmlaq_n_f32(v44, (float32x4_t)xmmword_18474E430, v27);
    v46 = vld1q_dup_f32(v37);
    *(float *)v17.i32 = v28 * 4.0;
    v127 = (float32x4_t)vdupq_lane_s32(v17, 0);
    v128 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.i8, 0);
    v47 = vmlaq_n_f32(v46, (float32x4_t)xmmword_18474E430, v28);
    v48 = vdupq_lane_s32(v15, 0);
    v125 = (float32x4_t)v48;
    v126 = (float32x4_t)vdupq_lane_s32(v16, 0);
    *(float *)v48.i32 = 1.0 / *(float *)v14.i32;
    v124 = 1.0 / *(float *)v14.i32;
    v131 = 1.0 / *(float *)v13.i32;
    v132 = 1.0 / *(float *)v12.i32;
    v122 = (float32x4_t)vdupq_lane_s32(v10, 0);
    v123 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.i8, 0);
    v120 = (float32x4_t)vdupq_lane_s32(v22, 0);
    v121 = (float32x4_t)vdupq_lane_s32(v9, 0);
    v118 = (float32x4_t)vdupq_lane_s32(v14, 0);
    v119 = (float32x4_t)vdupq_lane_s32(v21, 0);
    v116 = (float32x4_t)vdupq_lane_s32(v12, 0);
    v117 = (float32x4_t)vdupq_lane_s32(v13, 0);
    v114 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
    v115 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
    v112 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a6, 0);
    v113 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a7, 0);
    *(float *)v11.i32 = 1.0 / *(float *)&a4;
    v111 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
    v49 = (float32x4_t)vdupq_lane_s32(v20, 0);
    v50 = 1.0 / *(float *)&a6;
    v51 = (float32x4_t)vdupq_lane_s32(v19, 0);
    v52 = (float32x4_t)vdupq_lane_s32(v11, 0);
    v53.i64[0] = 0x3F0000003F000000;
    v53.i64[1] = 0x3F0000003F000000;
    v54.i64[0] = 0xFF000000FFLL;
    v54.i64[1] = 0xFF000000FFLL;
    do
    {
      v55 = (int8x16_t)vdupq_n_s64(v23);
      v56 = (uint64x2_t)vorrq_s8(v55, (int8x16_t)xmmword_18474E1C0);
      v57 = (int32x4_t)vcgeq_u64(v33, (uint64x2_t)vorrq_s8(v55, (int8x16_t)xmmword_18474E440));
      v58 = (int32x4_t)vcgeq_u64(v33, v56);
      v59 = vuzp1q_s32(v58, v57);
      v60 = vaddq_f32(vabsq_f32(v45), v126);
      v61 = vaddq_f32(vabsq_f32(v47), v125);
      __asm { FMOV            V26.4S, #-1.0 }
      v67 = vminnmq_f32(vmlaq_f32(_Q26, v123, v40), (float32x4_t)0);
      __asm { FMOV            V24.4S, #1.0 }
      v69 = vsubq_f32(_Q24, v43);
      v70 = vminnmq_f32(vmlaq_f32(_Q26, v122, v69), (float32x4_t)0);
      v71 = vsubq_f32(_Q24, v40);
      v72 = vminnmq_f32(vmlaq_f32(_Q26, v121, v71), (float32x4_t)0);
      v73 = vminnmq_f32(vmlaq_f32(_Q26, v120, v69), (float32x4_t)0);
      v74 = vmlaq_f32(_Q26, v119, v71);
      v75 = vminnmq_f32(v118, vmulq_n_f32(v60, v124));
      v76 = vminnmq_f32(v117, vmulq_n_f32(v61, v131));
      v77 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v75, v76), (int8x16_t)v75, (int8x16_t)v76);
      v78 = vmlaq_f32(vmulq_f32(v67, v67), v70, v70);
      v79 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q24, v77), v78);
      v80 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      v81 = (uint32x4_t)vbicq_s8(vbslq_s8(vandq_s8((int8x16_t)v59, v79), v54, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(vmlaq_f32(_Q24, v53, v77), vsqrtq_f32(v78)), v80), v77), v53)), (int32x4_t)0), (uint32x4_t)v54)), vandq_s8(vbicq_s8((int8x16_t)v59, v79), (int8x16_t)vcgtq_f32(v78, vaddq_f32(v77, _Q24))));
      v82 = vminnmq_f32(v116, vmulq_n_f32(v60, v132));
      v83 = vminnmq_f32(v115, vmulq_n_f32(v61, 1.0 / *(float *)&a9));
      v84 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v82, v83), (int8x16_t)v82, (int8x16_t)v83);
      v85 = vmlaq_f32(vmulq_f32(v73, v73), v72, v72);
      v86 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q24, v84), v85);
      v87 = vminnmq_f32(v114, vmulq_n_f32(v60, 1.0 / *(float *)&a8));
      v88 = vminnmq_f32(v113, vmulq_n_f32(v61, 1.0 / *(float *)&a7));
      v89 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v87, v88), (int8x16_t)v87, (int8x16_t)v88);
      v90 = (int8x16_t)vcgtq_f32(v85, vaddq_f32(v84, _Q24));
      v91 = vdivq_f32(vmulq_f32(vsubq_f32(vmlaq_f32(_Q24, v53, v84), vsqrtq_f32(v85)), v80), v84);
      v92 = vandq_s8(vbicq_s8((int8x16_t)v59, v86), v90);
      v93 = vminnmq_f32(v74, (float32x4_t)0);
      v94 = vbslq_s8(vandq_s8((int8x16_t)v59, v86), v54, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(v91, v53)), (int32x4_t)0), (uint32x4_t)v54));
      v95 = vminnmq_f32(vmlaq_f32(_Q26, v49, v43), (float32x4_t)0);
      v96 = (uint32x4_t)vbicq_s8(v94, v92);
      v97 = vmlaq_f32(vmulq_f32(v95, v95), v93, v93);
      v98 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q24, v89), v97);
      v99 = vminnmq_f32(v112, vmulq_n_f32(v60, v50));
      v100 = vminnmq_f32(v111, vmulq_n_f32(v61, *(float *)v11.i32));
      v101 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v99, v100), (int8x16_t)v99, (int8x16_t)v100);
      v102 = (int8x16_t)vcgtq_f32(v97, vaddq_f32(v89, _Q24));
      v103 = vbicq_s8((int8x16_t)v59, v98);
      v104 = vbslq_s8(vandq_s8((int8x16_t)v59, v98), v54, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(vmlaq_f32(_Q24, v53, v89), vsqrtq_f32(v97)), v80), v89), v53)), (int32x4_t)0), (uint32x4_t)v54));
      v105 = vminnmq_f32(vmlaq_f32(_Q26, v51, v40), (float32x4_t)0);
      v106 = vminnmq_f32(vmlaq_f32(_Q26, v52, v43), (float32x4_t)0);
      v107 = (uint32x4_t)vbicq_s8(v104, vandq_s8(v103, v102));
      v108 = vmlaq_f32(vmulq_f32(v106, v106), v105, v105);
      v109 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q24, v101), v108);
      v110 = vminq_u32(vminq_u32(v81, v96), vminq_u32(v107, (uint32x4_t)vbicq_s8(vbslq_s8(vandq_s8((int8x16_t)v59, v109), v54, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(vmlaq_f32(_Q24, v53, v101), vsqrtq_f32(v108)), v80), v101), v53)),
                                                            (int32x4_t)0),
                                              (uint32x4_t)v54)),
                               vandq_s8(vbicq_s8((int8x16_t)v59, v109), (int8x16_t)vcgtq_f32(v108, vaddq_f32(v101, _Q24))))));
      if ((vmovn_s32(v59).u8[0] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v23) = 16843009 * v110.i32[0];
      *(int32x2_t *)v58.i8 = vmovn_s64((int64x2_t)v58);
      *(int16x4_t *)v58.i8 = vmovn_s32(v58);
      if ((v58.i8[2] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v23 + 4) = 16843009 * v110.i32[1];
      if ((vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v58, *(int64x2_t *)&v57)).i32[1] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v23 + 8) = 16843009 * v110.i32[2];
      if ((vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v57, *(int64x2_t *)&v57)).i8[6] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v23 + 12) = 16843009 * v110.i32[3];
      v23 += 4;
      v40 = vaddq_f32(v40, v130);
      v43 = vaddq_f32(v43, v129);
      v45 = vaddq_f32(v45, v128);
      v47 = vaddq_f32(v47, v127);
    }
    while (((a2 + 3) & 0x1FFFFFFFCLL) != v23);
  }
  return result;
}

uint64_t CA::OGL::SW::uneven_circle_sampler<true,false>(uint64_t result, unsigned int a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  int32x2_t v11;
  int32x2_t v12;
  int32x2_t v13;
  int32x2_t v14;
  int32x2_t v15;
  int32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;
  int32x2_t v19;
  int32x2_t v20;
  int32x2_t v21;
  int32x2_t v22;
  unint64_t v23;
  unsigned int v24;
  __int32 *v25;
  uint64_t v26;
  const float *v27;
  uint64_t v28;
  float v29;
  uint64_t v30;
  const float *v31;
  const float *v32;
  const float *v33;
  uint64x2_t v34;
  const float *v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int32x4_t v47;
  float v48;
  float v49;
  float32x4_t v50;
  int8x16_t v51;
  int8x16_t v52;
  uint64x2_t v53;
  int32x4_t v54;
  int32x4_t v55;
  int32x4_t v56;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  int8x16_t v82;
  int8x16_t v83;
  float32x4_t v84;
  float32x4_t v85;
  uint32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  int8x16_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t v95;
  float32x4_t v96;
  int8x16_t v97;
  int8x16_t v98;
  float32x4_t v99;
  float32x4_t v100;
  uint32x4_t v101;
  float32x4_t v102;
  int8x16_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  int8x16_t v107;
  int8x16_t v108;
  int8x16_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  int8x16_t v113;
  int32x4_t v114;
  uint32x4_t v115;
  int32x2_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float v139;
  float v140;
  float v141;

  if (a2)
  {
    v23 = 0;
    v24 = *(_DWORD *)(result + 8);
    v25 = (__int32 *)(*(_QWORD *)(result + 104) + 48 * v24);
    LODWORD(a6) = v25[6];
    LODWORD(a4) = v25[7];
    *(float *)v19.i32 = 1.0 / *(float *)&a6;
    LODWORD(a8) = v25[4];
    LODWORD(a7) = v25[5];
    *(float *)v21.i32 = 1.0 / *(float *)&a8;
    LODWORD(a10) = v25[2];
    LODWORD(a9) = v25[3];
    *(float *)v22.i32 = 1.0 / *(float *)&a9;
    *(float *)v11.i32 = 1.0 / *(float *)&a10;
    v13.i32[0] = *v25;
    LODWORD(a11) = v25[1];
    v27 = *(const float **)(result + 16);
    v26 = *(_QWORD *)(result + 24);
    v15.i32[0] = *(_DWORD *)(v26 + 12);
    v24 *= 2;
    *(float *)v12.i32 = 1.0 / *(float *)&a11;
    v28 = *(_QWORD *)(result + 40) + 4 * v24;
    v18.i32[0] = *(_DWORD *)(v28 + 32);
    v29 = *(float *)(v28 + 36);
    v30 = v26 + 4 * v24;
    v16.i32[0] = *(_DWORD *)(v30 + 32);
    v17.i32[0] = *(_DWORD *)(v30 + 36);
    v31 = &v27[v24];
    v32 = v31 + 8;
    v31 += 9;
    v33 = (const float *)(*(_QWORD *)(result + 32) + 4 * v24);
    v34 = (uint64x2_t)vdupq_n_s64((unint64_t)a2 - 1);
    v35 = v33 + 8;
    v33 += 9;
    v27 += 3;
    v36 = vld1q_dup_f32(v32);
    *(float *)v14.i32 = *(float *)v16.i32 * 4.0;
    v138 = (float32x4_t)vdupq_lane_s32(v14, 0);
    v139 = *(float *)v16.i32;
    v37 = vld1q_dup_f32(v31);
    v38 = vmlaq_n_f32(v36, (float32x4_t)xmmword_18474E430, *(float *)v16.i32);
    *(float *)v16.i32 = *(float *)v17.i32 * 4.0;
    v39 = vdupq_lane_s32(v16, 0);
    v40 = vld1q_dup_f32(v35);
    v140 = *(float *)v17.i32;
    v141 = 1.0 / *(float *)&a11;
    v41 = vmlaq_n_f32(v37, (float32x4_t)xmmword_18474E430, *(float *)v17.i32);
    *(float *)v17.i32 = *(float *)v18.i32 * 4.0;
    v136 = (float32x4_t)vdupq_lane_s32(v17, 0);
    v137 = (float32x4_t)v39;
    v42 = vld1q_dup_f32(v33);
    v43 = vmlaq_n_f32(v40, (float32x4_t)xmmword_18474E430, *(float *)v18.i32);
    *(float *)v18.i32 = v29 * 4.0;
    v44 = vld1q_dup_f32(v27);
    v45 = vmlaq_n_f32(v42, (float32x4_t)xmmword_18474E430, v29);
    v46 = vmlaq_n_f32(v44, (float32x4_t)xmmword_18474E430, *(float *)v15.i32);
    *(float *)v15.i32 = *(float *)v15.i32 * 4.0;
    v47 = vdupq_lane_s32(v15, 0);
    v134 = (float32x4_t)v47;
    v135 = (float32x4_t)vdupq_lane_s32(v18, 0);
    *(float *)v47.i32 = 1.0 / *(float *)v13.i32;
    v132 = (float32x4_t)vdupq_lane_s32(v12, 0);
    v133 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.i8, 0);
    v130 = (float32x4_t)vdupq_lane_s32(v13, 0);
    v131 = (float32x4_t)vdupq_lane_s32(v11, 0);
    v128 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a10, 0);
    v129 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a11, 0);
    v126 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
    v127 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
    v124 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a6, 0);
    v125 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a7, 0);
    *(float *)&a5 = 1.0 / *(float *)&a4;
    v121 = (float32x4_t)vdupq_lane_s32(v22, 0);
    v122 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
    v123 = 1.0 / *(float *)&a8;
    *(float *)&a7 = 1.0 / *(float *)&a7;
    v20.i32[0] = SLODWORD(a7);
    v119 = (float32x4_t)vdupq_lane_s32(v20, 0);
    v120 = (float32x4_t)vdupq_lane_s32(v21, 0);
    v48 = 1.0 / *(float *)&a6;
    v49 = 1.0 / *(float *)&a4;
    v117 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 0);
    v118 = (float32x4_t)vdupq_lane_s32(v19, 0);
    v50.i64[0] = 0x3F0000003F000000;
    v50.i64[1] = 0x3F0000003F000000;
    v51.i64[0] = 0xFF000000FFLL;
    v51.i64[1] = 0xFF000000FFLL;
    do
    {
      v52 = (int8x16_t)vdupq_n_s64(v23);
      v53 = (uint64x2_t)vorrq_s8(v52, (int8x16_t)xmmword_18474E1C0);
      v54 = (int32x4_t)vcgeq_u64(v34, (uint64x2_t)vorrq_s8(v52, (int8x16_t)xmmword_18474E440));
      v55 = (int32x4_t)vcgeq_u64(v34, v53);
      v56 = vuzp1q_s32(v55, v54);
      __asm { FMOV            V2.4S, #1.0 }
      v62 = vdivq_f32(_Q2, v46);
      v63 = vmulq_f32(v38, v62);
      v64 = vmulq_f32(v41, v62);
      v65 = vaddq_f32(vabsq_f32(vmulq_f32(v43, v62)), vabsq_f32(vmulq_n_f32(v62, v139)));
      v66 = vaddq_f32(vabsq_f32(vmulq_n_f32(v62, v140)), vabsq_f32(vmulq_f32(v45, v62)));
      __asm { FMOV            V29.4S, #-1.0 }
      v68 = vminnmq_f32(vmlaq_f32(_Q29, v133, v63), (float32x4_t)0);
      v69 = vsubq_f32(_Q2, v64);
      v70 = vminnmq_f32(vmlaq_f32(_Q29, v132, v69), (float32x4_t)0);
      v71 = vsubq_f32(_Q2, v63);
      v72 = vminnmq_f32(vmlaq_f32(_Q29, v131, v71), (float32x4_t)0);
      v73 = vminnmq_f32(vmlaq_f32(_Q29, v121, v69), (float32x4_t)0);
      v74 = vmlaq_f32(_Q29, v120, v71);
      v75 = vmlaq_f32(_Q29, v119, v64);
      v76 = vmlaq_f32(_Q29, v118, v63);
      v77 = vmlaq_f32(_Q29, v117, v64);
      v78 = vminnmq_f32(v130, vmulq_n_f32(v65, 1.0 / *(float *)v13.i32));
      v79 = vminnmq_f32(v129, vmulq_n_f32(v66, v141));
      v80 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v78, v79), (int8x16_t)v78, (int8x16_t)v79);
      v81 = vmlaq_f32(vmulq_f32(v68, v68), v70, v70);
      v82 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q2, v80), v81);
      v83 = (int8x16_t)vcgtq_f32(v81, vaddq_f32(v80, _Q2));
      v84 = vsqrtq_f32(v81);
      v85 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      v86 = (uint32x4_t)vbicq_s8(vbslq_s8(vandq_s8((int8x16_t)v56, v82), v51, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(vmlaq_f32(_Q2, v50, v80), v84), v85), v80), v50)), (int32x4_t)0), (uint32x4_t)v51)), vandq_s8(vbicq_s8((int8x16_t)v56, v82), v83));
      v87 = vminnmq_f32(v128, vmulq_n_f32(v65, 1.0 / *(float *)&a10));
      v88 = vminnmq_f32(v127, vmulq_n_f32(v66, 1.0 / *(float *)&a9));
      v89 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v87, v88), (int8x16_t)v87, (int8x16_t)v88);
      v90 = vmlaq_f32(vmulq_f32(v73, v73), v72, v72);
      v91 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q2, v89), v90);
      v92 = vminnmq_f32(v126, vmulq_n_f32(v65, v123));
      v93 = vminnmq_f32(v125, vmulq_n_f32(v66, *(float *)&a7));
      v94 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v92, v93), (int8x16_t)v92, (int8x16_t)v93);
      v95 = (int8x16_t)vcgtq_f32(v90, vaddq_f32(v89, _Q2));
      v96 = vdivq_f32(vmulq_f32(vsubq_f32(vmlaq_f32(_Q2, v50, v89), vsqrtq_f32(v90)), v85), v89);
      v97 = vandq_s8(vbicq_s8((int8x16_t)v56, v91), v95);
      v98 = vbslq_s8(vandq_s8((int8x16_t)v56, v91), v51, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(v96, v50)), (int32x4_t)0), (uint32x4_t)v51));
      v99 = vminnmq_f32(v74, (float32x4_t)0);
      v100 = vminnmq_f32(v75, (float32x4_t)0);
      v101 = (uint32x4_t)vbicq_s8(v98, v97);
      v102 = vmlaq_f32(vmulq_f32(v100, v100), v99, v99);
      v103 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q2, v94), v102);
      v104 = vminnmq_f32(v124, vmulq_n_f32(v65, v48));
      v105 = vminnmq_f32(v122, vmulq_n_f32(v66, v49));
      v106 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v104, v105), (int8x16_t)v104, (int8x16_t)v105);
      v107 = (int8x16_t)vcgtq_f32(v102, vaddq_f32(v94, _Q2));
      v108 = vbicq_s8((int8x16_t)v56, v103);
      v109 = vbslq_s8(vandq_s8((int8x16_t)v56, v103), v51, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(vmlaq_f32(_Q2, v50, v94), vsqrtq_f32(v102)), v85), v94), v50)), (int32x4_t)0), (uint32x4_t)v51));
      v110 = vminnmq_f32(v76, (float32x4_t)0);
      v111 = vminnmq_f32(v77, (float32x4_t)0);
      v112 = vmlaq_f32(vmulq_f32(v111, v111), v110, v110);
      v113 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q2, v106), v112);
      v114 = (int32x4_t)vminq_u32(v86, v101);
      v115 = vminq_u32((uint32x4_t)v114, vminq_u32((uint32x4_t)vbicq_s8(v109, vandq_s8(v108, v107)), (uint32x4_t)vbicq_s8(vbslq_s8(vandq_s8((int8x16_t)v56, v113), v51, (int8x16_t)vminq_u32((uint32x4_t)vmaxq_s32(vcvtq_s32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(vmlaq_f32(_Q2, v50, v106), vsqrtq_f32(v112)), v85), v106), v50)),
                                                            (int32x4_t)0),
                                              (uint32x4_t)v51)),
                               vandq_s8(vbicq_s8((int8x16_t)v56, v113), (int8x16_t)vcgtq_f32(v112, vaddq_f32(v106, _Q2))))));
      if ((vmovn_s32(v56).u8[0] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v23) = 16843009 * v115.i32[0];
      *(int32x2_t *)v114.i8 = vmovn_s64((int64x2_t)v55);
      *(int16x4_t *)v114.i8 = vmovn_s32(v114);
      if ((v114.i8[2] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v23 + 4) = 16843009 * v115.i32[1];
      v116 = (int32x2_t)vmovn_s32(vmovn_hight_s64(*(int32x2_t *)v114.i8, (int64x2_t)v54));
      if ((v116.i8[4] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v23 + 8) = 16843009 * v115.i32[2];
      if ((vmovn_s32(vmovn_hight_s64(v116, *(int64x2_t *)&v54)).i8[6] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v23 + 12) = 16843009 * v115.i32[3];
      v23 += 4;
      v38 = vaddq_f32(v38, v138);
      v41 = vaddq_f32(v41, v137);
      v43 = vaddq_f32(v43, v136);
      v45 = vaddq_f32(v45, v135);
      v46 = vaddq_f32(v46, v134);
    }
    while (((a2 + 3) & 0x1FFFFFFFCLL) != v23);
  }
  return result;
}

float CA::OGL::SW::circle_sampler<false,true>(uint64_t a1, int a2, _DWORD *a3, float result)
{
  uint64_t v4;
  uint64_t v5;
  float v6;
  uint64_t v7;
  float v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  float v17;
  int v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  unsigned int v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;

  if (a2)
  {
    v4 = (2 * *(_DWORD *)(a1 + 8));
    v5 = *(_QWORD *)(a1 + 24) + 4 * v4;
    result = *(float *)(v5 + 32);
    v6 = *(float *)(v5 + 36);
    v7 = *(_QWORD *)(a1 + 40) + 4 * v4;
    v8 = *(float *)(v7 + 32);
    v9 = *(float *)(v7 + 36);
    v10 = *(_QWORD *)(a1 + 32) + 4 * v4;
    v12 = *(float *)(v10 + 32);
    v11 = *(float *)(v10 + 36);
    v13 = *(_QWORD *)(a1 + 16) + 4 * v4;
    v15 = *(float *)(v13 + 32);
    v14 = *(float *)(v13 + 36);
    v16 = fabsf(result);
    v17 = fabsf(v6);
    v18 = *(unsigned __int8 *)(a1 + 48);
    do
    {
      v19 = v15;
      v20 = v14;
      if (v18 == 5)
      {
        v19 = *(float *)(a1 + 92);
        v20 = *(float *)(a1 + 96);
        if (v19 >= v15)
          v19 = v15;
        if (*(float *)(a1 + 84) > v19)
          v19 = *(float *)(a1 + 84);
        if (v20 >= v14)
          v20 = v14;
        if (*(float *)(a1 + 88) > v20)
          v20 = *(float *)(a1 + 88);
      }
      v21 = fabsf(v12) + v16;
      v22 = fabsf(v11) + v17;
      if (v21 <= v22)
        v21 = v22;
      v23 = (float)(v19 * v19) + (float)(v20 * v20);
      if (v23 >= (float)(1.0 - v21))
      {
        v25 = fabsf(v20);
        v26 = fabsf(v19);
        v27 = sqrtf(v23);
        v28 = fminf(v26, v25) / fmaxf(v26, v25);
        if (v28 > 1.0)
          v28 = 1.0;
        v29 = (float)((float)((float)((float)(1.0
                                            / (float)((float)((float)(v28 * v28)
                                                            * (float)((float)((float)((float)((float)((float)((float)((float)(v28 * 0.92605) + -3.156) * v28) + 3.6412)
                                                                                            * v28)
                                                                                    + -1.268)
                                                                            * v28)
                                                                    + -0.26853))
                                                    + 1.0))
                                    - (float)(v27 - (float)(v21 * 0.5)))
                            * 255.0)
                    / v21)
            + 0.5;
        v24 = (int)v29 & ~((int)v29 >> 31);
        if (v24 >= 0xFF)
          v24 = 255;
      }
      else
      {
        v24 = 255;
      }
      v15 = v15 + result;
      v14 = v14 + v6;
      v12 = v12 + v8;
      v11 = v11 + v9;
      *a3++ = 16843009 * v24;
      --a2;
    }
    while (a2);
  }
  return result;
}

float CA::OGL::SW::circle_sampler<true,true>(uint64_t a1, int a2, _DWORD *a3, float result)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  float v15;
  float v16;
  uint64_t v17;
  float v18;
  float v19;
  int v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  unsigned int v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;

  if (a2)
  {
    v4 = (2 * *(_DWORD *)(a1 + 8));
    v6 = *(_QWORD *)(a1 + 16);
    v5 = *(_QWORD *)(a1 + 24);
    v7 = v5 + 4 * v4;
    result = *(float *)(v7 + 32);
    v8 = *(float *)(v7 + 36);
    v9 = *(_QWORD *)(a1 + 40) + 4 * v4;
    v10 = *(float *)(v9 + 32);
    v11 = *(float *)(v9 + 36);
    v12 = *(float *)(v5 + 12);
    v13 = *(float *)(v6 + 12);
    v14 = *(_QWORD *)(a1 + 32) + 4 * v4;
    v16 = *(float *)(v14 + 32);
    v15 = *(float *)(v14 + 36);
    v17 = v6 + 4 * v4;
    v19 = *(float *)(v17 + 32);
    v18 = *(float *)(v17 + 36);
    v20 = *(unsigned __int8 *)(a1 + 48);
    do
    {
      v21 = 1.0 / v13;
      v22 = v19 * (float)(1.0 / v13);
      v23 = v18 * (float)(1.0 / v13);
      if (v20 == 5)
      {
        if (*(float *)(a1 + 92) < v22)
          v22 = *(float *)(a1 + 92);
        if (*(float *)(a1 + 84) > v22)
          v22 = *(float *)(a1 + 84);
        if (*(float *)(a1 + 96) < v23)
          v23 = *(float *)(a1 + 96);
        if (*(float *)(a1 + 88) > v23)
          v23 = *(float *)(a1 + 88);
      }
      v24 = fabsf(v21 * result) + fabsf(v21 * v16);
      v25 = fabsf(v21 * v8) + fabsf(v21 * v15);
      if (v24 > v25)
        v25 = v24;
      v26 = (float)(v22 * v22) + (float)(v23 * v23);
      if (v26 >= (float)(1.0 - v25))
      {
        v28 = fabsf(v23);
        v29 = fabsf(v22);
        v30 = sqrtf(v26);
        v31 = fminf(v29, v28) / fmaxf(v29, v28);
        if (v31 > 1.0)
          v31 = 1.0;
        v32 = (float)((float)((float)((float)(1.0
                                            / (float)((float)((float)(v31 * v31)
                                                            * (float)((float)((float)((float)((float)((float)((float)((float)(v31 * 0.92605) + -3.156) * v31) + 3.6412)
                                                                                            * v31)
                                                                                    + -1.268)
                                                                            * v31)
                                                                    + -0.26853))
                                                    + 1.0))
                                    - (float)(v30 - (float)(v25 * 0.5)))
                            * 255.0)
                    / v25)
            + 0.5;
        v27 = (int)v32 & ~((int)v32 >> 31);
        if (v27 >= 0xFF)
          v27 = 255;
      }
      else
      {
        v27 = 255;
      }
      v13 = v13 + v12;
      v19 = v19 + result;
      v18 = v18 + v8;
      v16 = v16 + v10;
      v15 = v15 + v11;
      *a3++ = 16843009 * v27;
      --a2;
    }
    while (a2);
  }
  return result;
}

float CA::OGL::SW::circle_sampler<false,false>(uint64_t a1, int a2, _DWORD *a3, float result)
{
  uint64_t v4;
  uint64_t v5;
  float v6;
  uint64_t v7;
  float v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  float v17;
  int v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  unsigned int v24;
  float v25;

  if (a2)
  {
    v4 = (2 * *(_DWORD *)(a1 + 8));
    v5 = *(_QWORD *)(a1 + 24) + 4 * v4;
    result = *(float *)(v5 + 32);
    v6 = *(float *)(v5 + 36);
    v7 = *(_QWORD *)(a1 + 40) + 4 * v4;
    v8 = *(float *)(v7 + 32);
    v9 = *(float *)(v7 + 36);
    v10 = *(_QWORD *)(a1 + 32) + 4 * v4;
    v12 = *(float *)(v10 + 32);
    v11 = *(float *)(v10 + 36);
    v13 = *(_QWORD *)(a1 + 16) + 4 * v4;
    v15 = *(float *)(v13 + 32);
    v14 = *(float *)(v13 + 36);
    v16 = fabsf(result);
    v17 = fabsf(v6);
    v18 = *(unsigned __int8 *)(a1 + 48);
    do
    {
      v19 = v15;
      v20 = v14;
      if (v18 == 5)
      {
        v19 = *(float *)(a1 + 92);
        v20 = *(float *)(a1 + 96);
        if (v19 >= v15)
          v19 = v15;
        if (*(float *)(a1 + 84) > v19)
          v19 = *(float *)(a1 + 84);
        if (v20 >= v14)
          v20 = v14;
        if (*(float *)(a1 + 88) > v20)
          v20 = *(float *)(a1 + 88);
      }
      v21 = fabsf(v12) + v16;
      v22 = fabsf(v11) + v17;
      if (v21 <= v22)
        v21 = v22;
      v23 = (float)(v19 * v19) + (float)(v20 * v20);
      if (v23 >= (float)(1.0 - v21))
      {
        if (v23 <= (float)(v21 + 1.0))
        {
          v25 = (float)((float)((float)((float)((float)(v21 * 0.5) + 1.0) - sqrtf(v23)) * 255.0) / v21) + 0.5;
          v24 = (int)v25 & ~((int)v25 >> 31);
          if (v24 >= 0xFF)
            v24 = 255;
        }
        else
        {
          v24 = 0;
        }
      }
      else
      {
        v24 = 255;
      }
      v15 = v15 + result;
      v14 = v14 + v6;
      v12 = v12 + v8;
      v11 = v11 + v9;
      *a3++ = 16843009 * v24;
      --a2;
    }
    while (a2);
  }
  return result;
}

float CA::OGL::SW::circle_sampler<true,false>(uint64_t a1, int a2, _DWORD *a3, float result)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  float v15;
  float v16;
  uint64_t v17;
  float v18;
  float v19;
  int v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  unsigned int v27;
  float v28;

  if (a2)
  {
    v4 = (2 * *(_DWORD *)(a1 + 8));
    v6 = *(_QWORD *)(a1 + 16);
    v5 = *(_QWORD *)(a1 + 24);
    v7 = v5 + 4 * v4;
    result = *(float *)(v7 + 32);
    v8 = *(float *)(v7 + 36);
    v9 = *(_QWORD *)(a1 + 40) + 4 * v4;
    v10 = *(float *)(v9 + 32);
    v11 = *(float *)(v9 + 36);
    v12 = *(float *)(v5 + 12);
    v13 = *(float *)(v6 + 12);
    v14 = *(_QWORD *)(a1 + 32) + 4 * v4;
    v16 = *(float *)(v14 + 32);
    v15 = *(float *)(v14 + 36);
    v17 = v6 + 4 * v4;
    v19 = *(float *)(v17 + 32);
    v18 = *(float *)(v17 + 36);
    v20 = *(unsigned __int8 *)(a1 + 48);
    do
    {
      v21 = 1.0 / v13;
      v22 = v19 * (float)(1.0 / v13);
      v23 = v18 * (float)(1.0 / v13);
      if (v20 == 5)
      {
        if (*(float *)(a1 + 92) < v22)
          v22 = *(float *)(a1 + 92);
        if (*(float *)(a1 + 84) > v22)
          v22 = *(float *)(a1 + 84);
        if (*(float *)(a1 + 96) < v23)
          v23 = *(float *)(a1 + 96);
        if (*(float *)(a1 + 88) > v23)
          v23 = *(float *)(a1 + 88);
      }
      v24 = fabsf(v21 * result) + fabsf(v21 * v16);
      v25 = fabsf(v21 * v8) + fabsf(v21 * v15);
      if (v24 > v25)
        v25 = v24;
      v26 = (float)(v22 * v22) + (float)(v23 * v23);
      if (v26 >= (float)(1.0 - v25))
      {
        if (v26 <= (float)(v25 + 1.0))
        {
          v28 = (float)((float)((float)((float)((float)(v25 * 0.5) + 1.0) - sqrtf(v26)) * 255.0) / v25) + 0.5;
          v27 = (int)v28 & ~((int)v28 >> 31);
          if (v27 >= 0xFF)
            v27 = 255;
        }
        else
        {
          v27 = 0;
        }
      }
      else
      {
        v27 = 255;
      }
      v13 = v13 + v12;
      v19 = v19 + result;
      v18 = v18 + v8;
      v16 = v16 + v10;
      v15 = v15 + v11;
      *a3++ = 16843009 * v27;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::square_sampler<false>(uint64_t result, unsigned int a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  int32x2_t v10;
  int32x2_t v11;
  int32x2_t v12;
  unint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  const float *v17;
  uint64x2_t v18;
  const float *v19;
  uint64_t v20;
  const float *v21;
  const float *v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v43;
  int8x16_t v44;
  int32x4_t v45;
  int8x16_t v46;
  int8x16_t v47;
  uint64x2_t v48;
  int32x4_t v49;
  int32x4_t v50;
  int32x4_t v51;
  unsigned __int8 v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int8x16_t v57;
  float32x4_t v58;
  int32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  int8x16_t v62;
  float32x4_t v63;
  int32x4_t v64;
  int32x4_t v65;
  uint32x4_t v66;
  int8x16_t v67;

  if (a2)
  {
    v13 = 0;
    v14 = 2 * *(_DWORD *)(result + 8);
    v15 = *(_QWORD *)(result + 40) + 4 * v14;
    LODWORD(a10) = *(_DWORD *)(v15 + 32);
    v10.i32[0] = *(_DWORD *)(v15 + 36);
    v16 = *(_QWORD *)(result + 24) + 4 * v14;
    LODWORD(a6) = *(_DWORD *)(v16 + 32);
    LODWORD(a8) = *(_DWORD *)(v16 + 36);
    *(float *)v12.i32 = fabsf(*(float *)&a8);
    *(float *)v11.i32 = fabsf(*(float *)&a6);
    v17 = (const float *)(*(_QWORD *)(result + 16) + 4 * v14);
    v18 = (uint64x2_t)vdupq_n_s64((unint64_t)a2 - 1);
    v19 = v17 + 8;
    v17 += 9;
    v20 = *(_QWORD *)(result + 32) + 4 * v14;
    v21 = (const float *)(v20 + 32);
    v22 = (const float *)(v20 + 36);
    v23 = vld1q_dup_f32(v19);
    v24 = vmlaq_n_f32(v23, (float32x4_t)xmmword_18474E430, *(float *)&a6);
    *(float *)&a6 = *(float *)&a6 * 4.0;
    v25 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a6, 0);
    v26 = vld1q_dup_f32(v17);
    v27 = vmlaq_n_f32(v26, (float32x4_t)xmmword_18474E430, *(float *)&a8);
    *(float *)&a8 = *(float *)&a8 * 4.0;
    v28 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
    v29 = vld1q_dup_f32(v21);
    v30 = vmlaq_n_f32(v29, (float32x4_t)xmmword_18474E430, *(float *)&a10);
    *(float *)&a10 = *(float *)&a10 * 4.0;
    v31 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a10, 0);
    v32 = vld1q_dup_f32(v22);
    v33 = vmlaq_n_f32(v32, (float32x4_t)xmmword_18474E430, *(float *)v10.i32);
    *(float *)v10.i32 = *(float *)v10.i32 * 4.0;
    v34 = (float32x4_t)vdupq_lane_s32(v10, 0);
    v35 = (float32x4_t)vdupq_lane_s32(v11, 0);
    v36 = (float32x4_t)vdupq_lane_s32(v12, 0);
    v37.i64[0] = 0x3F0000003F000000;
    v37.i64[1] = 0x3F0000003F000000;
    __asm { FMOV            V22.4S, #1.0 }
    v43 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    v44.i64[0] = 0xFF000000FFLL;
    v44.i64[1] = 0xFF000000FFLL;
    v45.i64[0] = 0x100000001;
    v45.i64[1] = 0x100000001;
    v46.i64[0] = 0x10000000100;
    v46.i64[1] = 0x10000000100;
    do
    {
      v47 = (int8x16_t)vdupq_n_s64(v13);
      v48 = (uint64x2_t)vorrq_s8(v47, (int8x16_t)xmmword_18474E1C0);
      v49 = (int32x4_t)vcgeq_u64(v18, (uint64x2_t)vorrq_s8(v47, (int8x16_t)xmmword_18474E440));
      v50 = (int32x4_t)vcgeq_u64(v18, v48);
      v51 = vuzp1q_s32(v50, v49);
      v52 = vmovn_s32(v51).u8[0];
      v53 = vaddq_f32(vabsq_f32(v30), v35);
      v54 = vaddq_f32(vabsq_f32(v33), v36);
      v55 = vabsq_f32(v24);
      v56 = vmulq_f32(v53, v37);
      v57 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q22, v56), v55);
      v58 = vaddq_f32(v56, _Q22);
      v59 = (int32x4_t)vbicq_s8(vbslq_s8(vandq_s8((int8x16_t)v51, v57), v44, (int8x16_t)vcvtq_u32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(v58, v55), v43), v53), v37))), vandq_s8(vbicq_s8((int8x16_t)v51, v57), (int8x16_t)vcgtq_f32(v55, v58)));
      v60 = vabsq_f32(v27);
      v61 = vmulq_f32(v54, v37);
      v62 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q22, v61), v60);
      v63 = vaddq_f32(v61, _Q22);
      v64 = (int32x4_t)vcvtq_u32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(v63, v60), v43), v54), v37));
      v65 = (int32x4_t)vandq_s8(vbicq_s8((int8x16_t)v51, v62), (int8x16_t)vcgtq_f32(v60, v63));
      v66 = (uint32x4_t)vmulq_s32(vsubq_s32((int32x4_t)vbicq_s8(vbslq_s8(vandq_s8((int8x16_t)v51, v62), v46, (int8x16_t)vaddq_s32(v64, v45)), (int8x16_t)v65), v65), v59);
      v67 = vorrq_s8((int8x16_t)vshrq_n_u32(v66, 8uLL), (int8x16_t)(*(_OWORD *)&v66 & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00)));
      if ((v52 & 1) != 0)
        *(_DWORD *)(a3 + 4 * v13) = v67.i32[0] | (v67.i32[0] << 16);
      *(int32x2_t *)v50.i8 = vmovn_s64((int64x2_t)v50);
      *(int16x4_t *)v50.i8 = vmovn_s32(v50);
      if ((v50.i8[2] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v13 + 4) = v67.i32[1] | (v67.i32[1] << 16);
      if ((vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v50, *(int64x2_t *)&v49)).i32[1] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v13 + 8) = v67.i32[2] | (v67.i32[2] << 16);
      if ((vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v49, *(int64x2_t *)&v49)).i8[6] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v13 + 12) = v67.i32[3] | (v67.i32[3] << 16);
      v13 += 4;
      v24 = vaddq_f32(v24, v25);
      v27 = vaddq_f32(v27, v28);
      v30 = vaddq_f32(v30, v31);
      v33 = vaddq_f32(v33, v34);
    }
    while (((a2 + 3) & 0x1FFFFFFFCLL) != v13);
  }
  return result;
}

uint64_t CA::OGL::SW::square_sampler<true>(uint64_t result, unsigned int a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  int32x2_t v10;
  int32x2_t v11;
  int32x2_t v12;
  unint64_t v13;
  uint64_t v14;
  const float *v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  float v19;
  float v20;
  const float *v21;
  const float *v22;
  const float *v23;
  uint64x2_t v24;
  const float *v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v46;
  float32x4_t v47;
  int8x16_t v48;
  int32x4_t v49;
  int8x16_t v50;
  int8x16_t v51;
  uint64x2_t v52;
  int32x4_t v53;
  int32x4_t v54;
  int32x4_t v55;
  unsigned __int8 v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int8x16_t v64;
  float32x4_t v65;
  int32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int8x16_t v69;
  float32x4_t v70;
  int32x4_t v71;
  int32x4_t v72;
  uint32x4_t v73;
  int8x16_t v74;

  if (a2)
  {
    v13 = 0;
    v15 = *(const float **)(result + 16);
    v14 = *(_QWORD *)(result + 24);
    v12.i32[0] = *(_DWORD *)(v14 + 12);
    v16 = 2 * *(_DWORD *)(result + 8);
    v17 = *(_QWORD *)(result + 40) + 4 * v16;
    v10.i32[0] = *(_DWORD *)(v17 + 32);
    v11.i32[0] = *(_DWORD *)(v17 + 36);
    v18 = v14 + 4 * v16;
    v20 = *(float *)(v18 + 32);
    v19 = *(float *)(v18 + 36);
    v21 = &v15[v16];
    v22 = v21 + 8;
    v21 += 9;
    v23 = (const float *)(*(_QWORD *)(result + 32) + 4 * v16);
    v24 = (uint64x2_t)vdupq_n_s64((unint64_t)a2 - 1);
    v25 = v23 + 8;
    v23 += 9;
    v15 += 3;
    v26 = vld1q_dup_f32(v22);
    v27 = vmlaq_n_f32(v26, (float32x4_t)xmmword_18474E430, v20);
    *(float *)&a8 = v20 * 4.0;
    v28 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
    v29 = vld1q_dup_f32(v21);
    v30 = vmlaq_n_f32(v29, (float32x4_t)xmmword_18474E430, v19);
    *(float *)&a10 = v19 * 4.0;
    v31 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a10, 0);
    v32 = vld1q_dup_f32(v25);
    v33 = vmlaq_n_f32(v32, (float32x4_t)xmmword_18474E430, *(float *)v10.i32);
    *(float *)v10.i32 = *(float *)v10.i32 * 4.0;
    v34 = (float32x4_t)vdupq_lane_s32(v10, 0);
    v35 = vld1q_dup_f32(v23);
    v36 = vmlaq_n_f32(v35, (float32x4_t)xmmword_18474E430, *(float *)v11.i32);
    *(float *)v11.i32 = *(float *)v11.i32 * 4.0;
    v37 = (float32x4_t)vdupq_lane_s32(v11, 0);
    v38 = vld1q_dup_f32(v15);
    v39 = vmlaq_n_f32(v38, (float32x4_t)xmmword_18474E430, *(float *)v12.i32);
    *(float *)v12.i32 = *(float *)v12.i32 * 4.0;
    v40 = (float32x4_t)vdupq_lane_s32(v12, 0);
    __asm { FMOV            V23.4S, #1.0 }
    v46.i64[0] = 0x3F0000003F000000;
    v46.i64[1] = 0x3F0000003F000000;
    v47 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    v48.i64[0] = 0xFF000000FFLL;
    v48.i64[1] = 0xFF000000FFLL;
    v49.i64[0] = 0x100000001;
    v49.i64[1] = 0x100000001;
    v50.i64[0] = 0x10000000100;
    v50.i64[1] = 0x10000000100;
    do
    {
      v51 = (int8x16_t)vdupq_n_s64(v13);
      v52 = (uint64x2_t)vorrq_s8(v51, (int8x16_t)xmmword_18474E1C0);
      v53 = (int32x4_t)vcgeq_u64(v24, (uint64x2_t)vorrq_s8(v51, (int8x16_t)xmmword_18474E440));
      v54 = (int32x4_t)vcgeq_u64(v24, v52);
      v55 = vuzp1q_s32(v54, v53);
      v56 = vmovn_s32(v55).u8[0];
      v57 = vdivq_f32(_Q23, v39);
      v58 = vmulq_f32(v27, v57);
      v59 = vmulq_f32(v30, v57);
      v60 = vaddq_f32(vabsq_f32(vmulq_f32(v33, v57)), vabsq_f32(vmulq_n_f32(v57, v20)));
      v61 = vaddq_f32(vabsq_f32(vmulq_n_f32(v57, v19)), vabsq_f32(vmulq_f32(v36, v57)));
      v62 = vabsq_f32(v58);
      v63 = vmulq_f32(v60, v46);
      v64 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q23, v63), v62);
      v65 = vaddq_f32(v63, _Q23);
      v66 = (int32x4_t)vbicq_s8(vbslq_s8(vandq_s8((int8x16_t)v55, v64), v48, (int8x16_t)vcvtq_u32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(v65, v62), v47), v60), v46))), vandq_s8(vbicq_s8((int8x16_t)v55, v64), (int8x16_t)vcgtq_f32(v62, v65)));
      v67 = vabsq_f32(v59);
      v68 = vmulq_f32(v61, v46);
      v69 = (int8x16_t)vcgtq_f32(vsubq_f32(_Q23, v68), v67);
      v70 = vaddq_f32(v68, _Q23);
      v71 = (int32x4_t)vcvtq_u32_f32(vaddq_f32(vdivq_f32(vmulq_f32(vsubq_f32(v70, v67), v47), v61), v46));
      v72 = (int32x4_t)vandq_s8(vbicq_s8((int8x16_t)v55, v69), (int8x16_t)vcgtq_f32(v67, v70));
      v73 = (uint32x4_t)vmulq_s32(vsubq_s32((int32x4_t)vbicq_s8(vbslq_s8(vandq_s8((int8x16_t)v55, v69), v50, (int8x16_t)vaddq_s32(v71, v49)), (int8x16_t)v72), v72), v66);
      v74 = vorrq_s8((int8x16_t)vshrq_n_u32(v73, 8uLL), (int8x16_t)(*(_OWORD *)&v73 & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00)));
      if ((v56 & 1) != 0)
        *(_DWORD *)(a3 + 4 * v13) = v74.i32[0] | (v74.i32[0] << 16);
      *(int32x2_t *)v54.i8 = vmovn_s64((int64x2_t)v54);
      *(int16x4_t *)v54.i8 = vmovn_s32(v54);
      if ((v54.i8[2] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v13 + 4) = v74.i32[1] | (v74.i32[1] << 16);
      if ((vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v54, *(int64x2_t *)&v53)).i32[1] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v13 + 8) = v74.i32[2] | (v74.i32[2] << 16);
      if ((vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v53, *(int64x2_t *)&v53)).i8[6] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v13 + 12) = v74.i32[3] | (v74.i32[3] << 16);
      v13 += 4;
      v27 = vaddq_f32(v27, v28);
      v30 = vaddq_f32(v30, v31);
      v33 = vaddq_f32(v33, v34);
      v36 = vaddq_f32(v36, v37);
      v39 = vaddq_f32(v39, v40);
    }
    while (((a2 + 3) & 0x1FFFFFFFCLL) != v13);
  }
  return result;
}

void *CA::OGL::SW::incomplete_sampler(int a1, unsigned int a2, void *__b)
{
  void *result;

  if (a2)
    return memset(__b, 255, 4 * a2);
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Rev,unsigned int,true,true,false,false>(int *result, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      v10 += v9;
      v8 += v7;
      *a3++ = bswap32(*(_DWORD *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Rev,unsigned int,true,true,true,false>(uint64_t **a1, int a2, _DWORD *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  __int32 v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  __int32 v35;
  int v36;
  __int32 v37;
  int v38;
  uint64_t v39;
  int v40;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v40 = v13;
    v38 = v17;
    v39 = v8;
    v37 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v38;
          v8 = v39;
          v13 = v40;
          v9 = v37;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = bswap32(*(_DWORD *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      --v4;
    }
    while (v4);
  }
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Rev,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  int8x8_t v22;
  int8x8_t v23;
  uint8x8_t v24;
  int8x16_t v25;
  int8x8_t result;

  if (a2)
  {
    v3 = **(_QWORD **)a1;
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v5 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v6 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v8 = a1[15];
    v7 = a1[16];
    v10 = a1[13];
    v9 = a1[14];
    do
    {
      if (v10 >= v5 - 0x8000)
        v11 = v5 - 0x8000;
      else
        v11 = v10;
      if (v11 <= -32768)
        v11 = -32768;
      if (v10 <= 0x8000)
        v12 = 0x8000;
      else
        v12 = v10;
      v13 = v12 - 0x8000;
      if (v13 >= v5)
        v13 = v5;
      if (v8 >= v6 - 0x8000)
        v14 = v6 - 0x8000;
      else
        v14 = v8;
      if (v14 <= -32768)
        v14 = -32768;
      v15 = v14 + 0x8000;
      if (v8 <= 0x8000)
        v16 = 0x8000;
      else
        v16 = v8;
      v17 = v16 - 0x8000;
      if (v17 >= v6)
        v17 = v6;
      v18 = v3 + v4 * ((uint64_t)v17 >> 16);
      v19 = v3 + v4 * HIWORD(v15);
      v20 = ((uint64_t)v13 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v21 = ((v11 + 0x8000) >> 14) & 0x3FFFC;
      v22.i32[0] = *(_DWORD *)(v18 + v20);
      v23.i32[0] = *(_DWORD *)(v19 + v20);
      v23.i32[1] = *(_DWORD *)(v19 + v21);
      v22.i32[1] = *(_DWORD *)(v18 + v21);
      v24 = (uint8x8_t)vrev32_s8(v22);
      v25 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vrev32_s8(v23), v24), vdupq_n_s16((v17 >> 1) & 0x7F80)), v24);
      *(int16x4_t *)v25.i8 = vadd_s16(*(int16x4_t *)v25.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL), *(int16x4_t *)v25.i8), vdup_n_s16((v13 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v25.i8, *(int8x8_t *)v25.i8);
      v10 += v9;
      v8 += v7;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Rev,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  uint32x2_t *v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  int8x8_t v51;
  uint8x8_t v52;
  int8x8_t v53;
  int8x16_t v54;
  int v55;
  uint64_t **v56;
  int v57;
  int v58;
  int v59;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = *((unsigned __int8 *)result + 48) - 1;
    v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    v58 = v8;
    v59 = v12;
    v57 = v8 - 0x8000;
    v55 = v18;
    v56 = result;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          v24 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v23));
          v25 = vmul_f32(v24, v24);
          v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          v27 = vmul_f32(v25, vcvt_f32_u32(v5[3]));
          goto LABEL_8;
        case 1:
          v28 = v5;
          v29 = v9;
          v30 = v14;
          v31 = atan2f(*(float *)&v5[5].i32[1] * (float)v23.i32[1], *(float *)v5[5].i32 * (float)v23.i32[0]);
          v18 = v55;
          result = v56;
          v16 = v57;
          v8 = v58;
          v14 = v30;
          v12 = v59;
          v9 = v29;
          v5 = v28;
          v32.i32[1] = 1056964608;
          v32.f32[0] = (float)(v31 * -10430.0) + 32768.0;
          v27 = vmul_f32(v32, vcvt_f32_u32(v28[3]));
          goto LABEL_8;
        case 2:
          v33 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, (float32x2_t)v5[5]));
          v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v33, vrndm_f32(v33)), v20)), vmul_f32(v21, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v34 = vcvt_f32_s32(v23);
          v35 = vcvt_f32_s32((int32x2_t)v5[4]);
          v36 = vmul_f32(*(float32x2_t *)((char *)result + 84), v35);
          v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v35);
          v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v34, v37), (int8x8_t)v37, (int8x8_t)v34);
          v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v36, v38), (int8x8_t)v36, (int8x8_t)v38);
LABEL_8:
          v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      v39 = v23.i32[0];
      if (v23.i32[0] >= v16)
        v40 = v16;
      else
        v40 = v23.i32[0];
      if (v40 <= -32768)
        v40 = -32768;
      v41 = v40 + 0x8000;
      if (v23.i32[0] <= 0x8000)
        v39 = 0x8000;
      v42 = v39 - 0x8000;
      v43 = v23.i32[1];
      if (v42 >= v8)
        v42 = v8;
      if (v23.i32[1] >= v17)
        v44 = v17;
      else
        v44 = v23.i32[1];
      if (v44 <= -32768)
        v44 = -32768;
      v45 = v44 + 0x8000;
      if (v23.i32[1] <= 0x8000)
        v43 = 0x8000;
      v46 = v43 - 0x8000;
      if (v46 >= (int)v9)
        v46 = v9;
      v47 = v6 + v7 * ((uint64_t)v46 >> 16);
      v48 = v6 + v7 * HIWORD(v45);
      v49 = ((uint64_t)v42 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v50 = (v41 >> 14) & 0x3FFFC;
      v51.i32[0] = *(_DWORD *)(v47 + v49);
      v51.i32[1] = *(_DWORD *)(v47 + v50);
      v52 = (uint8x8_t)vrev32_s8(v51);
      v53.i32[0] = *(_DWORD *)(v48 + v49);
      v53.i32[1] = *(_DWORD *)(v48 + v50);
      v54 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vrev32_s8(v53), v52), vdupq_n_s16((v46 >> 1) & 0x7F80)), v52);
      *(int16x4_t *)v54.i8 = vadd_s16(*(int16x4_t *)v54.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL), *(int16x4_t *)v54.i8), vdup_n_s16((v42 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v54.i8, *(int8x8_t *)v54.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,false,false,false,false>(uint64_t result, int a2, _DWORD *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  int v6;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 52);
    v3 = *(_DWORD *)(result + 56);
    v5 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      v6 = *(_DWORD *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v4 += v3;
      *a3++ = v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,true,false,false,false>(_DWORD *result, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v6 = result[15];
    v5 = result[16];
    v8 = result[13];
    v7 = result[14];
    do
    {
      v9 = *(_DWORD *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v8 += v7;
      v6 += v5;
      *a3++ = v9;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,false,true,false,false>(_DWORD *result, int a2, _DWORD *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;

  if (a2)
  {
    v3 = result[14];
    v4 = result[13];
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(_QWORD *)result + 36))
      v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v7 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5)
        v8 = v5;
      v4 += v3;
      *a3++ = *(_DWORD *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,true,true,false,false>(int *result, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      v10 += v9;
      v8 += v7;
      *a3++ = *(_DWORD *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,true,true,true,false>(uint64_t **a1, int a2, _DWORD *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  __int32 v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  __int32 v35;
  int v36;
  __int32 v37;
  int v38;
  uint64_t v39;
  int v40;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v40 = v13;
    v38 = v17;
    v39 = v8;
    v37 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v38;
          v8 = v39;
          v13 = v40;
          v9 = v37;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = *(_DWORD *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      --v4;
    }
    while (v4);
  }
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  uint8x8_t v15;
  uint8x8_t v16;
  int8x16_t v17;

  if (a2)
  {
    v4 = result[14];
    v5 = result[15];
    v6 = *(_QWORD *)(*(_QWORD *)result + 16);
    v7 = **(_QWORD **)result;
    v8 = v5 + 0x8000;
    v9 = v5 - 0x8000;
    v10 = v7 + v6 * ((uint64_t)(v5 - 0x8000) >> 16);
    v11 = v7 + v6 * ((uint64_t)v8 >> 16);
    a4.i32[0] = (v9 >> 1) & 0x7F80;
    v12 = result[13] - 0x8000;
    do
    {
      v13 = ((uint64_t)v12 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v14 = ((uint64_t)(v12 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v15.i32[0] = *(_DWORD *)(v10 + v13);
      v15.i32[1] = *(_DWORD *)(v10 + v14);
      v16.i32[0] = *(_DWORD *)(v11 + v13);
      v16.i32[1] = *(_DWORD *)(v11 + v14);
      v17 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8(v16, v15), a4, 0), v15);
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v17.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL), *(int16x4_t *)v17.i8), vdup_n_s16((v12 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      v12 += v4;
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  uint8x8_t v14;
  int8x16_t v15;
  int8x8_t result;

  if (a2)
  {
    v3 = **(_QWORD **)a1;
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v5 = a1[16];
    v6 = a1[14];
    v7 = a1[13] - 0x8000;
    v8 = a1[15] - 0x8000;
    do
    {
      v9 = v3 + v4 * ((uint64_t)v8 >> 16);
      v10 = v3 + v4 * ((uint64_t)(v8 + 0x10000) >> 16);
      v11 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v12 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v13.i32[0] = *(_DWORD *)(v9 + v11);
      v14.i32[0] = *(_DWORD *)(v10 + v11);
      v13.i32[1] = *(_DWORD *)(v9 + v12);
      v14.i32[1] = *(_DWORD *)(v10 + v12);
      v15 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v14, v13), vdupq_n_s16((v8 >> 1) & 0x7F80)), v13);
      *(int16x4_t *)v15.i8 = vadd_s16(*(int16x4_t *)v15.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL), *(int16x4_t *)v15.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v15.i8, *(int8x8_t *)v15.i8);
      *a3++ = result.i32[0];
      v7 += v6;
      v8 += v5;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint8x8_t v21;
  uint8x8_t v22;
  int8x16_t v23;

  if (a2)
  {
    v4 = result[14];
    v5 = result[15];
    v6 = result[13];
    v7 = *(_DWORD *)(*(_QWORD *)result + 32);
    v8 = *(_DWORD *)(*(_QWORD *)result + 36);
    v9 = *(_QWORD *)(*(_QWORD *)result + 16);
    v10 = **(_QWORD **)result;
    if (v5 >= v8 - 0x8000)
      v11 = v8 - 0x8000;
    else
      v11 = result[15];
    if (v11 <= -32768)
      v11 = -32768;
    if (v5 <= 0x8000)
      v5 = 0x8000;
    v12 = v5 - 0x8000;
    if (v12 >= v8)
      v13 = *(_DWORD *)(*(_QWORD *)result + 36);
    else
      v13 = v12;
    v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    v15 = v10 + v9 * ((v11 + 0x8000) >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    do
    {
      if (v6 >= v7 - 0x8000)
        v16 = v7 - 0x8000;
      else
        v16 = v6;
      if (v16 <= -32768)
        v16 = -32768;
      v17 = v16 + 0x8000;
      if (v6 <= 0x8000)
        v18 = 0x8000;
      else
        v18 = v6;
      v19 = v18 - 0x8000;
      if (v19 >= v7)
        v19 = v7;
      result = (_DWORD *)(((uint64_t)v19 >> 14) & 0xFFFFFFFFFFFFFFFCLL);
      v20 = (v17 >> 14) & 0x3FFFC;
      v21.i32[0] = *(_DWORD *)((char *)result + v14);
      v21.i32[1] = *(_DWORD *)(v14 + v20);
      v22.i32[0] = *(_DWORD *)((char *)result + v15);
      v22.i32[1] = *(_DWORD *)(v15 + v20);
      v23 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8(v22, v21), a4, 0), v21);
      v6 += v4;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v23.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL), *(int16x4_t *)v23.i8), vdup_n_s16((v19 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint8x8_t v22;
  uint8x8_t v23;
  int8x16_t v24;
  int8x8_t result;

  if (a2)
  {
    v3 = **(_QWORD **)a1;
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v5 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v6 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v8 = a1[15];
    v7 = a1[16];
    v10 = a1[13];
    v9 = a1[14];
    do
    {
      if (v10 >= v5 - 0x8000)
        v11 = v5 - 0x8000;
      else
        v11 = v10;
      if (v11 <= -32768)
        v11 = -32768;
      if (v10 <= 0x8000)
        v12 = 0x8000;
      else
        v12 = v10;
      v13 = v12 - 0x8000;
      if (v13 >= v5)
        v13 = v5;
      if (v8 >= v6 - 0x8000)
        v14 = v6 - 0x8000;
      else
        v14 = v8;
      if (v14 <= -32768)
        v14 = -32768;
      if (v8 <= 0x8000)
        v15 = 0x8000;
      else
        v15 = v8;
      v16 = v15 - 0x8000;
      v17 = v14 + 0x8000;
      if (v16 >= v6)
        v16 = v6;
      v18 = v3 + v4 * ((uint64_t)v16 >> 16);
      v19 = v3 + v4 * HIWORD(v17);
      v20 = ((uint64_t)v13 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v21 = ((v11 + 0x8000) >> 14) & 0x3FFFC;
      v22.i32[0] = *(_DWORD *)(v18 + v20);
      v23.i32[0] = *(_DWORD *)(v19 + v20);
      v22.i32[1] = *(_DWORD *)(v18 + v21);
      v23.i32[1] = *(_DWORD *)(v19 + v21);
      v24 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v23, v22), vdupq_n_s16((v16 >> 1) & 0x7F80)), v22);
      *(int16x4_t *)v24.i8 = vadd_s16(*(int16x4_t *)v24.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL), *(int16x4_t *)v24.i8), vdup_n_s16((v13 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v24.i8, *(int8x8_t *)v24.i8);
      v10 += v9;
      v8 += v7;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ARGB8_Host,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  uint32x2_t *v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint8x8_t v51;
  uint8x8_t v52;
  int8x16_t v53;
  int v54;
  uint64_t **v55;
  int v56;
  int v57;
  int v58;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = *((unsigned __int8 *)result + 48) - 1;
    v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    v57 = v8;
    v58 = v12;
    v56 = v8 - 0x8000;
    v54 = v18;
    v55 = result;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          v24 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v23));
          v25 = vmul_f32(v24, v24);
          v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          v27 = vmul_f32(v25, vcvt_f32_u32(v5[3]));
          goto LABEL_8;
        case 1:
          v28 = v5;
          v29 = v9;
          v30 = v14;
          v31 = atan2f(*(float *)&v5[5].i32[1] * (float)v23.i32[1], *(float *)v5[5].i32 * (float)v23.i32[0]);
          v18 = v54;
          result = v55;
          v16 = v56;
          v8 = v57;
          v14 = v30;
          v12 = v58;
          v9 = v29;
          v5 = v28;
          v32.i32[1] = 1056964608;
          v32.f32[0] = (float)(v31 * -10430.0) + 32768.0;
          v27 = vmul_f32(v32, vcvt_f32_u32(v28[3]));
          goto LABEL_8;
        case 2:
          v33 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, (float32x2_t)v5[5]));
          v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v33, vrndm_f32(v33)), v20)), vmul_f32(v21, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v34 = vcvt_f32_s32(v23);
          v35 = vcvt_f32_s32((int32x2_t)v5[4]);
          v36 = vmul_f32(*(float32x2_t *)((char *)result + 84), v35);
          v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v35);
          v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v34, v37), (int8x8_t)v37, (int8x8_t)v34);
          v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v36, v38), (int8x8_t)v36, (int8x8_t)v38);
LABEL_8:
          v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      v39 = v23.i32[0];
      if (v23.i32[0] >= v16)
        v40 = v16;
      else
        v40 = v23.i32[0];
      if (v40 <= -32768)
        v40 = -32768;
      v41 = v40 + 0x8000;
      if (v23.i32[0] <= 0x8000)
        v39 = 0x8000;
      v42 = v39 - 0x8000;
      if (v42 >= v8)
        v42 = v8;
      v43 = v23.i32[1];
      if (v23.i32[1] >= v17)
        v44 = v17;
      else
        v44 = v23.i32[1];
      if (v44 <= -32768)
        v44 = -32768;
      v45 = v44 + 0x8000;
      if (v23.i32[1] <= 0x8000)
        v43 = 0x8000;
      v46 = v43 - 0x8000;
      if (v46 >= (int)v9)
        v46 = v9;
      v47 = v6 + v7 * ((uint64_t)v46 >> 16);
      v48 = v6 + v7 * HIWORD(v45);
      v49 = ((uint64_t)v42 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v50 = (v41 >> 14) & 0x3FFFC;
      v51.i32[0] = *(_DWORD *)(v47 + v49);
      v51.i32[1] = *(_DWORD *)(v47 + v50);
      v52.i32[0] = *(_DWORD *)(v48 + v49);
      v52.i32[1] = *(_DWORD *)(v48 + v50);
      v53 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v52, v51), vdupq_n_s16((v46 >> 1) & 0x7F80)), v51);
      *(int16x4_t *)v53.i8 = vadd_s16(*(int16x4_t *)v53.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v53, v53, 8uLL), *(int16x4_t *)v53.i8), vdup_n_s16((v42 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v53.i8, *(int8x8_t *)v53.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Rev,unsigned int,true,true,false,false>(int *result, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      v10 += v9;
      v8 += v7;
      *a3++ = bswap32(*(_DWORD *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) | 0xFF);
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Rev,unsigned int,true,true,true,false>(uint64_t **a1, int a2, _DWORD *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  __int32 v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  __int32 v35;
  int v36;
  __int32 v37;
  int v38;
  uint64_t v39;
  int v40;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v40 = v13;
    v38 = v17;
    v39 = v8;
    v37 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v38;
          v8 = v39;
          v13 = v40;
          v9 = v37;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = bswap32(*(_DWORD *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) | 0xFF);
      --v4;
    }
    while (v4);
  }
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Rev,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  int8x8_t v23;
  int8x8_t v24;
  uint8x8_t v25;
  int8x16_t v26;
  int8x8_t result;

  if (a2)
  {
    v3 = **(_QWORD **)a1;
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v5 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v6 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v8 = a1[15];
    v7 = a1[16];
    v10 = a1[13];
    v9 = a1[14];
    do
    {
      if (v10 >= v5 - 0x8000)
        v11 = v5 - 0x8000;
      else
        v11 = v10;
      if (v11 <= -32768)
        v11 = -32768;
      v12 = v11 + 0x8000;
      if (v10 <= 0x8000)
        v13 = 0x8000;
      else
        v13 = v10;
      v14 = v13 - 0x8000;
      if (v14 >= v5)
        v14 = v5;
      if (v8 >= v6 - 0x8000)
        v15 = v6 - 0x8000;
      else
        v15 = v8;
      if (v15 <= -32768)
        v15 = -32768;
      v16 = v15 + 0x8000;
      if (v8 <= 0x8000)
        v17 = 0x8000;
      else
        v17 = v8;
      v18 = v17 - 0x8000;
      if (v18 >= v6)
        v18 = v6;
      v19 = v3 + v4 * ((uint64_t)v18 >> 16);
      v20 = v3 + v4 * HIWORD(v16);
      v21 = (v12 >> 14) & 0x3FFFC;
      v22 = ((uint64_t)v14 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v23.i32[0] = *(_DWORD *)(v20 + v22) | 0xFF;
      v23.i32[1] = *(_DWORD *)(v20 + v21) | 0xFF;
      v24.i32[0] = *(_DWORD *)(v19 + v22) | 0xFF;
      v24.i32[1] = *(_DWORD *)(v19 + v21) | 0xFF;
      v25 = (uint8x8_t)vrev32_s8(v24);
      v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vrev32_s8(v23), v25), vdupq_n_s16((v18 >> 1) & 0x7F80)), v25);
      *(int16x4_t *)v26.i8 = vadd_s16(*(int16x4_t *)v26.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v14 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v26.i8, *(int8x8_t *)v26.i8);
      v10 += v9;
      v8 += v7;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Rev,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  uint32x2_t *v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  int8x8_t v51;
  uint8x8_t v52;
  int8x8_t v53;
  int8x16_t v54;
  int v55;
  uint64_t **v56;
  int v57;
  int v58;
  int v59;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = *((unsigned __int8 *)result + 48) - 1;
    v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    v58 = v8;
    v59 = v12;
    v57 = v8 - 0x8000;
    v55 = v18;
    v56 = result;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          v24 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v23));
          v25 = vmul_f32(v24, v24);
          v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          v27 = vmul_f32(v25, vcvt_f32_u32(v5[3]));
          goto LABEL_8;
        case 1:
          v28 = v5;
          v29 = v9;
          v30 = v14;
          v31 = atan2f(*(float *)&v5[5].i32[1] * (float)v23.i32[1], *(float *)v5[5].i32 * (float)v23.i32[0]);
          v18 = v55;
          result = v56;
          v16 = v57;
          v8 = v58;
          v14 = v30;
          v12 = v59;
          v9 = v29;
          v5 = v28;
          v32.i32[1] = 1056964608;
          v32.f32[0] = (float)(v31 * -10430.0) + 32768.0;
          v27 = vmul_f32(v32, vcvt_f32_u32(v28[3]));
          goto LABEL_8;
        case 2:
          v33 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, (float32x2_t)v5[5]));
          v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v33, vrndm_f32(v33)), v20)), vmul_f32(v21, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v34 = vcvt_f32_s32(v23);
          v35 = vcvt_f32_s32((int32x2_t)v5[4]);
          v36 = vmul_f32(*(float32x2_t *)((char *)result + 84), v35);
          v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v35);
          v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v34, v37), (int8x8_t)v37, (int8x8_t)v34);
          v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v36, v38), (int8x8_t)v36, (int8x8_t)v38);
LABEL_8:
          v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      v39 = v23.i32[0];
      if (v23.i32[0] >= v16)
        v40 = v16;
      else
        v40 = v23.i32[0];
      if (v40 <= -32768)
        v40 = -32768;
      v41 = v40 + 0x8000;
      if (v23.i32[0] <= 0x8000)
        v39 = 0x8000;
      v42 = v39 - 0x8000;
      if (v42 >= v8)
        v42 = v8;
      v43 = v23.i32[1];
      if (v23.i32[1] >= v17)
        v44 = v17;
      else
        v44 = v23.i32[1];
      if (v44 <= -32768)
        v44 = -32768;
      v45 = v44 + 0x8000;
      if (v23.i32[1] <= 0x8000)
        v43 = 0x8000;
      v46 = v43 - 0x8000;
      if (v46 >= (int)v9)
        v46 = v9;
      v47 = v6 + v7 * ((uint64_t)v46 >> 16);
      v48 = v6 + v7 * HIWORD(v45);
      v49 = ((uint64_t)v42 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v50 = (v41 >> 14) & 0x3FFFC;
      v51.i32[0] = *(_DWORD *)(v47 + v49) | 0xFF;
      v51.i32[1] = *(_DWORD *)(v47 + v50) | 0xFF;
      v52 = (uint8x8_t)vrev32_s8(v51);
      v53.i32[0] = *(_DWORD *)(v48 + v49) | 0xFF;
      v53.i32[1] = *(_DWORD *)(v48 + v50) | 0xFF;
      v54 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vrev32_s8(v53), v52), vdupq_n_s16((v46 >> 1) & 0x7F80)), v52);
      *(int16x4_t *)v54.i8 = vadd_s16(*(int16x4_t *)v54.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL), *(int16x4_t *)v54.i8), vdup_n_s16((v42 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v54.i8, *(int8x8_t *)v54.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  unsigned int v6;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 52);
    v3 = *(_DWORD *)(result + 56);
    v5 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      v6 = *(_DWORD *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) | 0xFF000000;
      v4 += v3;
      *a3++ = v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v6 = result[15];
    v5 = result[16];
    v8 = result[13];
    v7 = result[14];
    do
    {
      v9 = *(_DWORD *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) | 0xFF000000;
      v8 += v7;
      v6 += v5;
      *a3++ = v9;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;

  if (a2)
  {
    v3 = result[14];
    v4 = result[13];
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(_QWORD *)result + 36))
      v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v7 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5)
        v8 = v5;
      v4 += v3;
      *a3++ = *(_DWORD *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      v10 += v9;
      v8 += v7;
      *a3++ = *(_DWORD *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  __int32 v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  __int32 v35;
  int v36;
  __int32 v37;
  int v38;
  uint64_t v39;
  int v40;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v40 = v13;
    v38 = v17;
    v39 = v8;
    v37 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v38;
          v8 = v39;
          v13 = v40;
          v9 = v37;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = *(_DWORD *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  uint8x8_t v15;
  uint8x8_t v16;
  int8x16_t v17;

  if (a2)
  {
    v4 = result[14];
    v5 = result[15];
    v6 = *(_QWORD *)(*(_QWORD *)result + 16);
    v7 = **(_QWORD **)result;
    v8 = v5 + 0x8000;
    v9 = v5 - 0x8000;
    v10 = v7 + v6 * ((uint64_t)(v5 - 0x8000) >> 16);
    v11 = v7 + v6 * ((uint64_t)v8 >> 16);
    a4.i32[0] = (v9 >> 1) & 0x7F80;
    v12 = result[13] - 0x8000;
    do
    {
      v13 = ((uint64_t)v12 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v14 = ((uint64_t)(v12 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v15.i32[0] = *(_DWORD *)(v11 + v13) | 0xFF000000;
      v15.i32[1] = *(_DWORD *)(v11 + v14) | 0xFF000000;
      v16.i32[0] = *(_DWORD *)(v10 + v13) | 0xFF000000;
      v16.i32[1] = *(_DWORD *)(v10 + v14) | 0xFF000000;
      v17 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8(v15, v16), a4, 0), v16);
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v17.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL), *(int16x4_t *)v17.i8), vdup_n_s16((v12 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      v12 += v4;
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  uint8x8_t v14;
  int8x16_t v15;
  int8x8_t result;

  if (a2)
  {
    v3 = **(_QWORD **)a1;
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v5 = a1[16];
    v6 = a1[14];
    v7 = a1[13] - 0x8000;
    v8 = a1[15] - 0x8000;
    do
    {
      v9 = v3 + v4 * ((uint64_t)v8 >> 16);
      v10 = v3 + v4 * ((uint64_t)(v8 + 0x10000) >> 16);
      v11 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v12 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v13.i32[0] = *(_DWORD *)(v9 + v11) | 0xFF000000;
      v13.i32[1] = *(_DWORD *)(v9 + v12) | 0xFF000000;
      v14.i32[0] = *(_DWORD *)(v10 + v11) | 0xFF000000;
      v14.i32[1] = *(_DWORD *)(v10 + v12) | 0xFF000000;
      v15 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v14, v13), vdupq_n_s16((v8 >> 1) & 0x7F80)), v13);
      *(int16x4_t *)v15.i8 = vadd_s16(*(int16x4_t *)v15.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL), *(int16x4_t *)v15.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v15.i8, *(int8x8_t *)v15.i8);
      *a3++ = result.i32[0];
      v7 += v6;
      v8 += v5;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  uint8x8_t v21;
  uint8x8_t v22;
  int8x16_t v23;

  if (a2)
  {
    v4 = result[14];
    v5 = result[15];
    v6 = result[13];
    v7 = *(_DWORD *)(*(_QWORD *)result + 32);
    v8 = *(_DWORD *)(*(_QWORD *)result + 36);
    v9 = *(_QWORD *)(*(_QWORD *)result + 16);
    v10 = **(_QWORD **)result;
    if (v5 >= v8 - 0x8000)
      v11 = v8 - 0x8000;
    else
      v11 = result[15];
    if (v11 <= -32768)
      v11 = -32768;
    if (v5 <= 0x8000)
      v5 = 0x8000;
    v12 = v5 - 0x8000;
    if (v12 >= v8)
      v13 = *(_DWORD *)(*(_QWORD *)result + 36);
    else
      v13 = v12;
    v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    v15 = v10 + v9 * ((v11 + 0x8000) >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    do
    {
      if (v6 >= v7 - 0x8000)
        v16 = v7 - 0x8000;
      else
        v16 = v6;
      if (v16 <= -32768)
        v16 = -32768;
      if (v6 <= 0x8000)
        v17 = 0x8000;
      else
        v17 = v6;
      v18 = v16 + 0x8000;
      v19 = v17 - 0x8000;
      if (v19 >= v7)
        v19 = v7;
      result = (_DWORD *)(((uint64_t)v19 >> 14) & 0xFFFFFFFFFFFFFFFCLL);
      v20 = (v18 >> 14) & 0x3FFFC;
      v21.i32[0] = *(_DWORD *)((char *)result + v15) | 0xFF000000;
      v21.i32[1] = *(_DWORD *)(v15 + v20) | 0xFF000000;
      v22.i32[0] = *(_DWORD *)((char *)result + v14) | 0xFF000000;
      v22.i32[1] = *(_DWORD *)(v14 + v20) | 0xFF000000;
      v23 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8(v21, v22), a4, 0), v22);
      v6 += v4;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v23.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL), *(int16x4_t *)v23.i8), vdup_n_s16((v19 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint8x8_t v22;
  uint8x8_t v23;
  int8x16_t v24;
  int8x8_t result;

  if (a2)
  {
    v3 = **(_QWORD **)a1;
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v5 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v6 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v8 = a1[15];
    v7 = a1[16];
    v10 = a1[13];
    v9 = a1[14];
    do
    {
      if (v10 >= v5 - 0x8000)
        v11 = v5 - 0x8000;
      else
        v11 = v10;
      if (v11 <= -32768)
        v11 = -32768;
      if (v10 <= 0x8000)
        v12 = 0x8000;
      else
        v12 = v10;
      v13 = v12 - 0x8000;
      if (v13 >= v5)
        v13 = v5;
      if (v8 >= v6 - 0x8000)
        v14 = v6 - 0x8000;
      else
        v14 = v8;
      if (v14 <= -32768)
        v14 = -32768;
      v15 = v14 + 0x8000;
      if (v8 <= 0x8000)
        v16 = 0x8000;
      else
        v16 = v8;
      v17 = v16 - 0x8000;
      if (v17 >= v6)
        v17 = v6;
      v18 = v3 + v4 * ((uint64_t)v17 >> 16);
      v19 = v3 + v4 * HIWORD(v15);
      v20 = ((uint64_t)v13 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v21 = ((v11 + 0x8000) >> 14) & 0x3FFFC;
      v22.i32[0] = *(_DWORD *)(v19 + v20) | 0xFF000000;
      v22.i32[1] = *(_DWORD *)(v19 + v21) | 0xFF000000;
      v23.i32[0] = *(_DWORD *)(v18 + v20) | 0xFF000000;
      v23.i32[1] = *(_DWORD *)(v18 + v21) | 0xFF000000;
      v24 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v22, v23), vdupq_n_s16((v17 >> 1) & 0x7F80)), v23);
      *(int16x4_t *)v24.i8 = vadd_s16(*(int16x4_t *)v24.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL), *(int16x4_t *)v24.i8), vdup_n_s16((v13 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v24.i8, *(int8x8_t *)v24.i8);
      v10 += v9;
      v8 += v7;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XRGB8_Host,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  uint32x2_t *v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint8x8_t v51;
  uint8x8_t v52;
  int8x16_t v53;
  int v54;
  uint64_t **v55;
  int v56;
  int v57;
  int v58;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = *((unsigned __int8 *)result + 48) - 1;
    v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    v57 = v8;
    v58 = v12;
    v56 = v8 - 0x8000;
    v54 = v18;
    v55 = result;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          v24 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v23));
          v25 = vmul_f32(v24, v24);
          v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          v27 = vmul_f32(v25, vcvt_f32_u32(v5[3]));
          goto LABEL_8;
        case 1:
          v28 = v5;
          v29 = v9;
          v30 = v14;
          v31 = atan2f(*(float *)&v5[5].i32[1] * (float)v23.i32[1], *(float *)v5[5].i32 * (float)v23.i32[0]);
          v18 = v54;
          result = v55;
          v16 = v56;
          v8 = v57;
          v14 = v30;
          v12 = v58;
          v9 = v29;
          v5 = v28;
          v32.i32[1] = 1056964608;
          v32.f32[0] = (float)(v31 * -10430.0) + 32768.0;
          v27 = vmul_f32(v32, vcvt_f32_u32(v28[3]));
          goto LABEL_8;
        case 2:
          v33 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, (float32x2_t)v5[5]));
          v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v33, vrndm_f32(v33)), v20)), vmul_f32(v21, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v34 = vcvt_f32_s32(v23);
          v35 = vcvt_f32_s32((int32x2_t)v5[4]);
          v36 = vmul_f32(*(float32x2_t *)((char *)result + 84), v35);
          v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v35);
          v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v34, v37), (int8x8_t)v37, (int8x8_t)v34);
          v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v36, v38), (int8x8_t)v36, (int8x8_t)v38);
LABEL_8:
          v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      v39 = v23.i32[0];
      if (v23.i32[0] >= v16)
        v40 = v16;
      else
        v40 = v23.i32[0];
      if (v40 <= -32768)
        v40 = -32768;
      v41 = v40 + 0x8000;
      if (v23.i32[0] <= 0x8000)
        v39 = 0x8000;
      v42 = v39 - 0x8000;
      v43 = v23.i32[1];
      if (v42 >= v8)
        v42 = v8;
      if (v23.i32[1] >= v17)
        v44 = v17;
      else
        v44 = v23.i32[1];
      if (v44 <= -32768)
        v44 = -32768;
      v45 = v44 + 0x8000;
      if (v23.i32[1] <= 0x8000)
        v43 = 0x8000;
      v46 = v43 - 0x8000;
      if (v46 >= (int)v9)
        v46 = v9;
      v47 = v6 + v7 * ((uint64_t)v46 >> 16);
      v48 = v6 + v7 * HIWORD(v45);
      v49 = ((uint64_t)v42 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v50 = (v41 >> 14) & 0x3FFFC;
      v51.i32[0] = *(_DWORD *)(v48 + v49) | 0xFF000000;
      v51.i32[1] = *(_DWORD *)(v48 + v50) | 0xFF000000;
      v52.i32[0] = *(_DWORD *)(v47 + v49) | 0xFF000000;
      v52.i32[1] = *(_DWORD *)(v47 + v50) | 0xFF000000;
      v53 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v51, v52), vdupq_n_s16((v46 >> 1) & 0x7F80)), v52);
      *(int16x4_t *)v53.i8 = vadd_s16(*(int16x4_t *)v53.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v53, v53, 8uLL), *(int16x4_t *)v53.i8), vdup_n_s16((v42 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v53.i8, *(int8x8_t *)v53.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Rev,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      v13 = bswap32(*(unsigned __int16 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      result = (int *)((v13 >> 10) & 0xF800);
      v14 = (v13 >> 13) & 0xF8 | result | (v13 >> 7) & 0xF80000;
      v10 += v9;
      v8 += v7;
      *a3++ = v14 | (v14 >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Rev,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  __int32 v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  __int32 v35;
  int v36;
  unsigned int v37;
  unsigned int v38;
  __int32 v39;
  int v40;
  uint64_t v41;
  int v42;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v42 = v13;
    v40 = v17;
    v41 = v8;
    v39 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v40;
          v8 = v41;
          v13 = v42;
          v9 = v39;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v37 = bswap32(*(unsigned __int16 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      v38 = (v37 >> 13) & 0xF8 | (v37 >> 10) & 0xF800 | (v37 >> 7) & 0xF80000;
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = v38 | (v38 >> 3) & 0x7070707 | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Rev,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, int8x8_t a10)
{
  int8x8_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int8x8_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint32x2_t v33;
  uint32x2_t v34;
  uint32x2_t v35;
  uint32x2_t v36;
  int8x8_t v37;
  int8x8_t v38;
  int8x8_t v39;
  unint64_t v40;
  int8x16_t v41;

  if (a2)
  {
    v11 = **(_QWORD **)result;
    v12 = *(_QWORD *)(*(_QWORD *)result + 16);
    v13 = *(_DWORD *)(*(_QWORD *)result + 32);
    v14 = *(_DWORD *)(*(_QWORD *)result + 36);
    v16 = *(_DWORD *)(result + 60);
    v15 = *(_DWORD *)(result + 64);
    v18 = *(_DWORD *)(result + 52);
    v17 = *(_DWORD *)(result + 56);
    result = 4294934528;
    v19 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      if (v18 >= v13 - 0x8000)
        v20 = v13 - 0x8000;
      else
        v20 = v18;
      if (v20 <= -32768)
        v21 = -32768;
      else
        v21 = v20;
      if (v18 <= 0x8000)
        v22 = 0x8000;
      else
        v22 = v18;
      v23 = v22 - 0x8000;
      if (v23 >= v13)
        v23 = v13;
      if (v16 >= v14 - 0x8000)
        v24 = v14 - 0x8000;
      else
        v24 = v16;
      if (v24 <= -32768)
        v24 = -32768;
      if (v16 <= 0x8000)
        v25 = 0x8000;
      else
        v25 = v16;
      v26 = v25 - 0x8000;
      v27 = v24 + 0x8000;
      if (v26 >= v14)
        v28 = v14;
      else
        v28 = v26;
      v29 = v11 + v12 * ((uint64_t)v28 >> 16);
      v30 = v11 + v12 * HIWORD(v27);
      v31 = ((uint64_t)v23 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v32 = ((v21 + 0x8000) >> 15) & 0x1FFFE;
      a10.i16[0] = *(_WORD *)(v29 + v31);
      a10.i16[2] = *(_WORD *)(v29 + v32);
      v33 = (uint32x2_t)vrev32_s8(a10);
      v34 = vshr_n_u32(v33, 0x10uLL);
      v10.i16[0] = *(_WORD *)(v30 + v31);
      v10.i16[2] = *(_WORD *)(v30 + v32);
      v35 = (uint32x2_t)vrev32_s8(v10);
      v36 = vshr_n_u32(v35, 0x10uLL);
      v37 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v34, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v34, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshr_n_u32(v33, 7uLL), (int8x8_t)0xF8000000F80000));
      v38 = vorr_s8(vand_s8((int8x8_t)vshl_u32(v36, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v36, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8));
      v10 = vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v37, 3uLL), v19);
      v39 = vorr_s8(v38, vand_s8((int8x8_t)vshr_n_u32(v35, 7uLL), (int8x8_t)0xF8000000F80000));
      v40 = *(_QWORD *)&vorr_s8(v37, v10) | 0xFF000000FF000000;
      v41 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(v39, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v39, 3uLL), v19)) | 0xFF000000FF000000), (uint8x8_t)v40), vdupq_n_s16((v28 >> 1) & 0x7F80)), (uint8x8_t)v40);
      a10 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v41.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL), *(int16x4_t *)v41.i8), vdup_n_s16((v23 >> 1) & 0x7F80))), (int8x8_t)0x300000006);
      v18 += v17;
      v16 += v15;
      *a3++ = a10.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Rev,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  float v18;
  int v19;
  int8x8_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  uint32x2_t *v27;
  uint64_t v28;
  uint64_t v29;
  float v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  int v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint32x2_t v50;
  uint32x2_t v51;
  int8x8_t v52;
  int8x8_t v53;
  int8x8_t v54;
  uint32x2_t v55;
  uint32x2_t v56;
  int8x8_t v57;
  int8x16_t v58;
  float32x2_t v59;
  float32x2_t v60;
  float32x2_t v61;
  int v62;
  uint64_t **v63;
  int v64;
  int v65;
  int v66;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = 1.0;
    v19 = *((unsigned __int8 *)result + 48) - 1;
    v20 = (int8x8_t)vdup_n_s32(0x70707u);
    v60 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v61 = (float32x2_t)vdup_n_s32(0x37800000u);
    v59 = (float32x2_t)vdup_n_s32(0x47800000u);
    v65 = v8;
    v66 = v12;
    v64 = v8 - 0x8000;
    v62 = v19;
    v63 = result;
    do
    {
      v21.f32[0] = (float)(v18 / v11) * (float)v15;
      v21.f32[1] = (float)(v18 / v11) * (float)v13;
      v22 = vcvt_s32_f32(v21);
      switch(v19)
      {
        case 0:
          v23 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(v5[3]));
          goto LABEL_8;
        case 1:
          v27 = v5;
          v28 = v9;
          v29 = v14;
          v30 = atan2f(*(float *)&v5[5].i32[1] * (float)v22.i32[1], *(float *)v5[5].i32 * (float)v22.i32[0]);
          v19 = v62;
          result = v63;
          v18 = 1.0;
          v16 = v64;
          v8 = v65;
          v14 = v29;
          v12 = v66;
          v9 = v28;
          v5 = v27;
          v31.i32[1] = 1056964608;
          v31.f32[0] = (float)(v30 * -10430.0) + 32768.0;
          v26 = vmul_f32(v31, vcvt_f32_u32(v27[3]));
          goto LABEL_8;
        case 2:
          v32 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v61, (float32x2_t)v5[5]));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v32, vrndm_f32(v32)), v60)), vmul_f32(v59, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v33 = vcvt_f32_s32(v22);
          v34 = vcvt_f32_s32((int32x2_t)v5[4]);
          v35 = vmul_f32(*(float32x2_t *)((char *)result + 84), v34);
          v36 = vmul_f32(*(float32x2_t *)((char *)result + 92), v34);
          v37 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v33, v36), (int8x8_t)v36, (int8x8_t)v33);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v37), (int8x8_t)v35, (int8x8_t)v37);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v38 = v22.i32[0];
      if (v22.i32[0] >= v16)
        v39 = v16;
      else
        v39 = v22.i32[0];
      if (v39 <= -32768)
        v39 = -32768;
      v40 = v39 + 0x8000;
      if (v22.i32[0] <= 0x8000)
        v38 = 0x8000;
      v41 = v38 - 0x8000;
      if (v41 >= v8)
        v41 = v8;
      v42 = v22.i32[1];
      if (v22.i32[1] >= v17)
        v43 = v17;
      else
        v43 = v22.i32[1];
      if (v43 <= -32768)
        v43 = -32768;
      v44 = v43 + 0x8000;
      if (v22.i32[1] <= 0x8000)
        v42 = 0x8000;
      v45 = v42 - 0x8000;
      if (v45 >= (int)v9)
        v45 = v9;
      v46 = v6 + v7 * ((uint64_t)v45 >> 16);
      v47 = v6 + v7 * HIWORD(v44);
      v48 = ((uint64_t)v41 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v49 = (v40 >> 15) & 0x1FFFE;
      v22.i16[0] = *(_WORD *)(v46 + v48);
      v22.i16[2] = *(_WORD *)(v46 + v49);
      v50 = (uint32x2_t)vrev32_s8((int8x8_t)v22);
      v51 = vshr_n_u32(v50, 0x10uLL);
      v52 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v51, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v51, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshr_n_u32(v50, 7uLL), (int8x8_t)0xF8000000F80000));
      v53 = vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v52, 3uLL), v20);
      v54 = vorr_s8(v52, v53);
      v53.i16[0] = *(_WORD *)(v47 + v48);
      v53.i16[2] = *(_WORD *)(v47 + v49);
      v55 = (uint32x2_t)vrev32_s8(v53);
      v56 = vshr_n_u32(v55, 0x10uLL);
      v57 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v56, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v56, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshr_n_u32(v55, 7uLL), (int8x8_t)0xF8000000F80000));
      v58 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(v57, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v57, 3uLL), v20)) | 0xFF000000FF000000), (uint8x8_t)(*(_QWORD *)&v54 | 0xFF000000FF000000)), vdupq_n_s16((v45 >> 1) & 0x7F80)), (uint8x8_t)(*(_QWORD *)&v54 | 0xFF000000FF000000));
      *(int16x4_t *)v58.i8 = vadd_s16(*(int16x4_t *)v58.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v58, v58, 8uLL), *(int16x4_t *)v58.i8), vdup_n_s16((v41 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v58.i8, *(int8x8_t *)v58.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 52);
    v3 = *(_DWORD *)(result + 56);
    v5 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      v6 = *(unsigned __int16 *)(v5 + (((uint64_t)v4 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      v7 = (v6 << 6) & 0xF800 | (8 * (v6 & 0x1F)) | (((v6 >> 10) & 0x1F) << 19);
      v4 += v3;
      *a3++ = v7 | (v7 >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v6 = result[15];
    v5 = result[16];
    v8 = result[13];
    v7 = result[14];
    do
    {
      v9 = *(unsigned __int16 *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      v10 = (v9 << 6) & 0xF800 | (8 * (v9 & 0x1F)) | (((v9 >> 10) & 0x1F) << 19);
      v8 += v7;
      v6 += v5;
      *a3++ = v10 | (v10 >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  unsigned int v10;

  if (a2)
  {
    v3 = result[14];
    v4 = result[13];
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(_QWORD *)result + 36))
      v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v7 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5)
        v8 = v5;
      v9 = *(unsigned __int16 *)(v7 + (((uint64_t)v8 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      v10 = (v9 << 6) & 0xF800 | (8 * (v9 & 0x1F)) | (((v9 >> 10) & 0x1F) << 19);
      v4 += v3;
      *a3++ = v10 | (v10 >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      v13 = *(unsigned __int16 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      result = (int *)((v13 << 6) & 0xF800 | (8 * (v13 & 0x1F)) | (((v13 >> 10) & 0x1F) << 19));
      v10 += v9;
      v8 += v7;
      *a3++ = result | (result >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  __int32 v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  __int32 v35;
  int v36;
  unsigned int v37;
  unsigned int v38;
  __int32 v39;
  int v40;
  uint64_t v41;
  int v42;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v42 = v13;
    v40 = v17;
    v41 = v8;
    v39 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v40;
          v8 = v41;
          v13 = v42;
          v9 = v39;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v37 = *(unsigned __int16 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      v38 = (v37 << 6) & 0xF800 | (8 * (v37 & 0x1F)) | (((v37 >> 10) & 0x1F) << 19);
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = v38 | (v38 >> 3) & 0x7070707 | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int32x2_t v4;
  int32x2_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int8x8_t v15;
  unint64_t v16;
  unint64_t v17;
  uint32x2_t v18;
  uint32x2_t v19;
  int8x8_t v20;
  int8x8_t v21;
  unint64_t v22;
  int8x16_t v23;

  if (a2)
  {
    v6 = result[14];
    v7 = result[15];
    v8 = *(_QWORD *)(*(_QWORD *)result + 16);
    v9 = **(_QWORD **)result;
    v10 = v7 + 0x8000;
    v11 = v7 - 0x8000;
    v12 = v9 + v8 * ((uint64_t)(v7 - 0x8000) >> 16);
    v13 = v9 + v8 * ((uint64_t)v10 >> 16);
    a4.i32[0] = (v11 >> 1) & 0x7F80;
    v14 = result[13] - 0x8000;
    v15 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      v16 = ((uint64_t)v14 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v17 = ((uint64_t)(v14 + 0x10000) >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v4.i16[0] = *(_WORD *)(v12 + v16);
      v4.i16[2] = *(_WORD *)(v12 + v17);
      v18 = (uint32x2_t)vand_s8((int8x8_t)v4, (int8x8_t)0xFFFF0000FFFFLL);
      v5.i16[0] = *(_WORD *)(v13 + v16);
      v5.i16[2] = *(_WORD *)(v13 + v17);
      v19 = (uint32x2_t)vand_s8((int8x8_t)v5, (int8x8_t)0xFFFF0000FFFFLL);
      v20 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v18, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v18, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v4, 9uLL), (int8x8_t)0xF8000000F80000));
      v5 = vshl_n_s32(v5, 9uLL);
      v21 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v19, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v19, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)v5, (int8x8_t)0xF8000000F80000));
      v22 = *(_QWORD *)&vorr_s8(v20, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v20, 3uLL), v15)) | 0xFF000000FF000000;
      v23 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(v21, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v21, 3uLL), v15)) | 0xFF000000FF000000), (uint8x8_t)v22), a4, 0), (uint8x8_t)v22);
      v4 = (int32x2_t)vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v23.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL), *(int16x4_t *)v23.i8), vdup_n_s16((v14 >> 1) & 0x7F80))), (int8x8_t)a4);
      *a3++ = v4.i32[0];
      v14 += v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,true,false,false,true>(_DWORD *result, int a2, _DWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, int8x8_t a11)
{
  int32x2_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int8x8_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint32x2_t v23;
  uint32x2_t v24;
  int8x8_t v25;
  int8x8_t v26;
  unint64_t v27;
  int8x16_t v28;

  if (a2)
  {
    v12 = **(_QWORD **)result;
    v13 = *(_QWORD *)(*(_QWORD *)result + 16);
    v14 = result[16];
    v15 = result[14];
    v16 = result[13] - 0x8000;
    v17 = result[15] - 0x8000;
    v18 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      v19 = v12 + v13 * ((uint64_t)v17 >> 16);
      v20 = v12 + v13 * ((uint64_t)(v17 + 0x10000) >> 16);
      v21 = ((uint64_t)v16 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      result = (_DWORD *)(v19 + v21);
      v22 = ((uint64_t)(v16 + 0x10000) >> 15) & 0xFFFFFFFFFFFFFFFELL;
      a11.i16[0] = *(_WORD *)(v19 + v21);
      a11.i16[2] = *(_WORD *)(v19 + v22);
      v23 = (uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL);
      v11.i16[0] = *(_WORD *)(v20 + v21);
      v11.i16[2] = *(_WORD *)(v20 + v22);
      v24 = (uint32x2_t)vand_s8((int8x8_t)v11, (int8x8_t)0xFFFF0000FFFFLL);
      v25 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v23, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v23, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32((int32x2_t)a11, 9uLL), (int8x8_t)0xF8000000F80000));
      v26 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v24, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v24, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v11, 9uLL), (int8x8_t)0xF8000000F80000));
      v27 = *(_QWORD *)&vorr_s8(v25, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v25, 3uLL), v18)) | 0xFF000000FF000000;
      v28 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(v26, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v26, 3uLL), v18)) | 0xFF000000FF000000), (uint8x8_t)v27), vdupq_n_s16((v17 >> 1) & 0x7F80)), (uint8x8_t)v27);
      a11 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v28.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL), *(int16x4_t *)v28.i8), vdup_n_s16((v16 >> 1) & 0x7F80))), (int8x8_t)0xFFFF0000FFFFLL);
      *a3++ = a11.i32[0];
      v16 += v15;
      v17 += v14;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int32x2_t v4;
  int32x2_t v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int8x8_t v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  unint64_t v23;
  __int16 *v24;
  uint64_t v25;
  uint32x2_t v26;
  uint32x2_t v27;
  int8x8_t v28;
  int8x8_t v29;
  unint64_t v30;
  int8x16_t v31;

  if (a2)
  {
    v6 = result[14];
    v7 = result[15];
    v8 = result[13];
    v9 = *(_DWORD *)(*(_QWORD *)result + 32);
    v10 = *(_DWORD *)(*(_QWORD *)result + 36);
    v11 = *(_QWORD *)(*(_QWORD *)result + 16);
    v12 = **(_QWORD **)result;
    if (v7 >= v10 - 0x8000)
      v13 = v10 - 0x8000;
    else
      v13 = result[15];
    if (v13 <= -32768)
      v13 = -32768;
    if (v7 <= 0x8000)
      v7 = 0x8000;
    v14 = v7 - 0x8000;
    if (v14 >= v10)
      v15 = *(_DWORD *)(*(_QWORD *)result + 36);
    else
      v15 = v14;
    v16 = v12 + v11 * ((uint64_t)v15 >> 16);
    v17 = v12 + v11 * ((v13 + 0x8000) >> 16);
    a4.i32[0] = (v15 >> 1) & 0x7F80;
    v18 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      if (v8 >= v9 - 0x8000)
        v19 = v9 - 0x8000;
      else
        v19 = v8;
      if (v19 <= -32768)
        v19 = -32768;
      if (v8 <= 0x8000)
        v20 = 0x8000;
      else
        v20 = v8;
      v21 = v20 - 0x8000;
      v22 = v19 + 0x8000;
      if (v21 >= v9)
        v21 = v9;
      v23 = ((uint64_t)v21 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v24 = (__int16 *)(v16 + v23);
      result = (_DWORD *)(v17 + v23);
      v25 = (v22 >> 15) & 0x1FFFE;
      v4.i16[0] = *v24;
      v4.i16[2] = *(_WORD *)(v16 + v25);
      v26 = (uint32x2_t)vand_s8((int8x8_t)v4, (int8x8_t)0xFFFF0000FFFFLL);
      v5.i16[0] = *(_WORD *)result;
      v5.i16[2] = *(_WORD *)(v17 + v25);
      v27 = (uint32x2_t)vand_s8((int8x8_t)v5, (int8x8_t)0xFFFF0000FFFFLL);
      v28 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v26, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v26, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v4, 9uLL), (int8x8_t)0xF8000000F80000));
      v5 = vshl_n_s32(v5, 9uLL);
      v29 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v27, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v27, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)v5, (int8x8_t)0xF8000000F80000));
      v30 = *(_QWORD *)&vorr_s8(v28, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v28, 3uLL), v18)) | 0xFF000000FF000000;
      v31 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(v29, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v29, 3uLL), v18)) | 0xFF000000FF000000), (uint8x8_t)v30), a4, 0), (uint8x8_t)v30);
      v4 = (int32x2_t)vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v31.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL), *(int16x4_t *)v31.i8), vdup_n_s16((v21 >> 1) & 0x7F80))), (int8x8_t)a4);
      v8 += v6;
      *a3++ = v4.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, int8x8_t a11)
{
  int32x2_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int8x8_t v20;
  int v21;
  unsigned int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint32x2_t v33;
  uint32x2_t v34;
  int8x8_t v35;
  int8x8_t v36;
  unint64_t v37;
  int8x16_t v38;

  if (a2)
  {
    v12 = **(_QWORD **)result;
    v13 = *(_QWORD *)(*(_QWORD *)result + 16);
    v14 = *(_DWORD *)(*(_QWORD *)result + 32);
    v15 = *(_DWORD *)(*(_QWORD *)result + 36);
    v17 = *(_DWORD *)(result + 60);
    v16 = *(_DWORD *)(result + 64);
    v19 = *(_DWORD *)(result + 52);
    v18 = *(_DWORD *)(result + 56);
    result = 4294934528;
    v20 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      if (v19 >= v14 - 0x8000)
        v21 = v14 - 0x8000;
      else
        v21 = v19;
      if (v21 <= -32768)
        v21 = -32768;
      v22 = v21 + 0x8000;
      if (v19 <= 0x8000)
        v23 = 0x8000;
      else
        v23 = v19;
      v24 = v23 - 0x8000;
      if (v24 >= v14)
        v24 = v14;
      if (v17 >= v15 - 0x8000)
        v25 = v15 - 0x8000;
      else
        v25 = v17;
      if (v25 <= -32768)
        v25 = -32768;
      v26 = v25 + 0x8000;
      if (v17 <= 0x8000)
        v27 = 0x8000;
      else
        v27 = v17;
      v28 = v27 - 0x8000;
      if (v28 >= v15)
        v28 = v15;
      v29 = v12 + v13 * ((uint64_t)v28 >> 16);
      v30 = v12 + v13 * HIWORD(v26);
      v31 = ((uint64_t)v24 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v32 = (v22 >> 15) & 0x1FFFE;
      a11.i16[0] = *(_WORD *)(v29 + v31);
      a11.i16[2] = *(_WORD *)(v29 + v32);
      v33 = (uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL);
      v11.i16[0] = *(_WORD *)(v30 + v31);
      v11.i16[2] = *(_WORD *)(v30 + v32);
      v34 = (uint32x2_t)vand_s8((int8x8_t)v11, (int8x8_t)0xFFFF0000FFFFLL);
      v35 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v33, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v33, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32((int32x2_t)a11, 9uLL), (int8x8_t)0xF8000000F80000));
      v36 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v34, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v34, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v11, 9uLL), (int8x8_t)0xF8000000F80000));
      v11 = (int32x2_t)vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v36, 3uLL), v20);
      v37 = *(_QWORD *)&vorr_s8(v35, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v35, 3uLL), v20)) | 0xFF000000FF000000;
      v38 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(v36, (int8x8_t)v11) | 0xFF000000FF000000), (uint8x8_t)v37), vdupq_n_s16((v28 >> 1) & 0x7F80)), (uint8x8_t)v37);
      a11 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v38.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL), *(int16x4_t *)v38.i8), vdup_n_s16((v24 >> 1) & 0x7F80))), (int8x8_t)0xFFFF0000FFFFLL);
      v19 += v18;
      v17 += v16;
      *a3++ = a11.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGB5_Host,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float v18;
  int v19;
  int8x8_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  uint32x2_t *v27;
  uint64_t v28;
  uint64_t v29;
  float v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  int v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint32x2_t v50;
  int8x8_t v51;
  int32x2_t v52;
  int8x8_t v53;
  uint32x2_t v54;
  int8x8_t v55;
  int8x16_t v56;
  float32x2_t v57;
  float32x2_t v58;
  float32x2_t v59;
  int v60;
  int v61;
  uint64_t **v62;
  int v63;
  int v64;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((unsigned int *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((_DWORD *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = 1.0;
    v19 = *((unsigned __int8 *)result + 48) - 1;
    v20 = (int8x8_t)vdup_n_s32(0x70707u);
    v58 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v59 = (float32x2_t)vdup_n_s32(0x37800000u);
    v57 = (float32x2_t)vdup_n_s32(0x47800000u);
    v63 = v14;
    v64 = v8;
    v62 = result;
    v61 = v9 - 0x8000;
    v60 = v19;
    do
    {
      v21.f32[0] = (float)(v18 / v11) * (float)v15;
      v21.f32[1] = (float)(v18 / v11) * (float)v13;
      v22 = vcvt_s32_f32(v21);
      switch(v19)
      {
        case 0:
          v23 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(v5[3]));
          goto LABEL_8;
        case 1:
          v27 = v5;
          v28 = v9;
          v29 = v12;
          v30 = atan2f(*(float *)&v5[5].i32[1] * (float)v22.i32[1], *(float *)v5[5].i32 * (float)v22.i32[0]);
          v19 = v60;
          v18 = 1.0;
          v17 = v61;
          v14 = v63;
          v8 = v64;
          v12 = v29;
          v9 = v28;
          v5 = v27;
          result = v62;
          v31.i32[1] = 1056964608;
          v31.f32[0] = (float)(v30 * -10430.0) + 32768.0;
          v26 = vmul_f32(v31, vcvt_f32_u32(v27[3]));
          goto LABEL_8;
        case 2:
          v32 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v59, (float32x2_t)v5[5]));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v32, vrndm_f32(v32)), v58)), vmul_f32(v57, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v33 = vcvt_f32_s32(v22);
          v34 = vcvt_f32_s32((int32x2_t)v5[4]);
          v35 = vmul_f32(*(float32x2_t *)((char *)result + 84), v34);
          v36 = vmul_f32(*(float32x2_t *)((char *)result + 92), v34);
          v37 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v33, v36), (int8x8_t)v36, (int8x8_t)v33);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v37), (int8x8_t)v35, (int8x8_t)v37);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v38 = v22.i32[0];
      if (v22.i32[0] >= v16)
        v39 = v16;
      else
        v39 = v22.i32[0];
      if (v39 <= -32768)
        v39 = -32768;
      v40 = v39 + 0x8000;
      if (v22.i32[0] <= 0x8000)
        v38 = 0x8000;
      v41 = v38 - 0x8000;
      if (v41 >= v8)
        v41 = v8;
      v42 = v22.i32[1];
      if (v22.i32[1] >= v17)
        v43 = v17;
      else
        v43 = v22.i32[1];
      if (v43 <= -32768)
        v43 = -32768;
      v44 = v43 + 0x8000;
      if (v22.i32[1] <= 0x8000)
        v42 = 0x8000;
      v45 = v42 - 0x8000;
      if (v45 >= (int)v9)
        v45 = v9;
      v46 = v6 + v7 * ((uint64_t)v45 >> 16);
      v47 = v6 + v7 * HIWORD(v44);
      v48 = ((uint64_t)v41 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v49 = (v40 >> 15) & 0x1FFFE;
      v22.i16[0] = *(_WORD *)(v46 + v48);
      v22.i16[2] = *(_WORD *)(v46 + v49);
      v50 = (uint32x2_t)vand_s8((int8x8_t)v22, (int8x8_t)0xFFFF0000FFFFLL);
      v51 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v50, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v50, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v22, 9uLL), (int8x8_t)0xF8000000F80000));
      v52 = (int32x2_t)vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v51, 3uLL), v20);
      v53 = vorr_s8(v51, (int8x8_t)v52);
      v52.i16[0] = *(_WORD *)(v47 + v48);
      v52.i16[2] = *(_WORD *)(v47 + v49);
      v54 = (uint32x2_t)vand_s8((int8x8_t)v52, (int8x8_t)0xFFFF0000FFFFLL);
      v55 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v54, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v54, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v52, 9uLL), (int8x8_t)0xF8000000F80000));
      v56 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(v55, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v55, 3uLL), v20)) | 0xFF000000FF000000), (uint8x8_t)(*(_QWORD *)&v53 | 0xFF000000FF000000)), vdupq_n_s16((v45 >> 1) & 0x7F80)), (uint8x8_t)(*(_QWORD *)&v53 | 0xFF000000FF000000));
      *(int16x4_t *)v56.i8 = vadd_s16(*(int16x4_t *)v56.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v56, v56, 8uLL), *(int16x4_t *)v56.i8), vdup_n_s16((v41 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v56.i8, *(int8x8_t *)v56.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

unsigned int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::CbYCrY8,unsigned int,true,true,false,false>(unsigned int *result, int a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (unsigned __int8 *)a3;
    v4 = a2;
    v5 = **(_QWORD **)result;
    v6 = *(_QWORD *)(*(_QWORD *)result + 16);
    v7 = *(_DWORD *)(*(_QWORD *)result + 32);
    v8 = *(_DWORD *)(*(_QWORD *)result + 36);
    v10 = result[15];
    v9 = result[16];
    v12 = result[13];
    v11 = result[14];
    do
    {
      --v4;
      v15 = 0;
      v13 = v12 & ~(v12 >> 31);
      if (v13 >= v7)
        v13 = v7;
      v14 = v10 & ~(v10 >> 31);
      if (v14 >= v8)
        v14 = v8;
      result = CA::OGL::SW::Format::CbYCrY8::load_1(&v15, v5 + v6 * ((uint64_t)v14 >> 16) + (int)((v13 >> 15) & 0xFFFFFFFE), a3);
      v12 += v11;
      v10 += v9;
      *(_DWORD *)v3 = v15;
      v3 += 4;
    }
    while (v4);
  }
  return result;
}

unsigned int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::CbYCrY8,unsigned int,true,true,true,false>(unsigned int *result, int a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v4;
  float *v5;
  int v6;
  int v7;
  float v8;
  float v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  int32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  int v32;
  int v33;
  unsigned int *v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;

  v34 = result;
  v38 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (unsigned __int8 *)a3;
    v4 = a2;
    v5 = *(float **)result;
    v35 = *(_QWORD *)(*(_QWORD *)result + 16);
    v36 = **(_QWORD **)result;
    v6 = *(_DWORD *)(*(_QWORD *)result + 32);
    v7 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = *(float *)(*((_QWORD *)result + 3) + 12);
    v9 = *(float *)(*((_QWORD *)result + 2) + 12);
    v11 = result[15];
    v10 = result[16];
    v13 = result[13];
    v12 = result[14];
    v14 = *((unsigned __int8 *)result + 48) - 1;
    v15 = (float32x2_t)vdup_n_s32(0x37800000u);
    v16 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v17 = (float32x2_t)vdup_n_s32(0x47800000u);
    do
    {
      v37 = 0;
      v18.f32[0] = (float)(1.0 / v9) * (float)v13;
      v18.f32[1] = (float)(1.0 / v9) * (float)v11;
      v19 = vcvt_s32_f32(v18);
      switch(v14)
      {
        case 0:
          v20 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v19));
          v21 = vmul_f32(v20, v20);
          v22 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 1), v21);
          v21.f32[0] = fmaxf(vaddv_f32(v21), 0.00001);
          v21.i32[0] = vmul_f32(v22, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 0))).u32[0];
          v21.i32[1] = 0.5;
          v23 = vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          v24 = atan2f(v5[11] * (float)v19.i32[1], v5[10] * (float)v19.i32[0]);
          v25.i32[1] = 1056964608;
          v25.f32[0] = (float)(v24 * -10430.0) + 32768.0;
          v23 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          v26 = vmul_f32(vcvt_f32_s32(v19), vmul_f32(v15, *(float32x2_t *)(v5 + 10)));
          v23 = vmul_f32(vmla_f32(*(float32x2_t *)(v34 + 23), *(float32x2_t *)(v34 + 21), vminnm_f32(vsub_f32(v26, vrndm_f32(v26)), v16)), vmul_f32(v17, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          v27 = vcvt_f32_s32(v19);
          v28 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          v29 = vmul_f32(*(float32x2_t *)(v34 + 21), v28);
          v30 = vmul_f32(*(float32x2_t *)(v34 + 23), v28);
          v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, v30), (int8x8_t)v30, (int8x8_t)v27);
          v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29, v31), (int8x8_t)v29, (int8x8_t)v31);
LABEL_8:
          v19 = vcvt_s32_f32(v23);
          break;
        default:
          break;
      }
      --v4;
      v32 = v19.i32[0] & ~(v19.i32[0] >> 31);
      if (v32 >= v6)
        v32 = v6;
      v33 = v19.i32[1] & ~(v19.i32[1] >> 31);
      if (v33 >= v7)
        v33 = v7;
      result = CA::OGL::SW::Format::CbYCrY8::load_1(&v37, v36 + v35 * ((uint64_t)v33 >> 16) + (int)((v32 >> 15) & 0xFFFFFFFE), a3);
      v9 = v9 + v8;
      v13 += v12;
      v11 += v10;
      *(_DWORD *)v3 = v37;
      v3 += 4;
    }
    while (v4);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::CbYCrY8,unsigned int,true,true,false,true>(int *a1, int a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  signed int v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  const unsigned __int8 *v24;
  const unsigned __int8 *v25;
  const unsigned __int8 *v26;
  int8x16_t v27;
  int8x8_t result;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD v36[2];

  v36[1] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (unsigned __int8 *)a3;
    v4 = a2;
    v33 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v34 = **(_QWORD **)a1;
    v5 = a1[15];
    v31 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v32 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v30 = a1[16];
    v6 = a1[13];
    v29 = a1[14];
    do
    {
      --v4;
      v7 = v32 - 0x8000;
      if (v6 < v32 - 0x8000)
        v7 = v6;
      if (v7 <= -32768)
        v7 = -32768;
      v8 = v7 + 0x8000;
      if (v6 <= 0x8000)
        v9 = 0x8000;
      else
        v9 = v6;
      v10 = v9 - 0x8000;
      if (v10 >= v32)
        v11 = v32;
      else
        v11 = v10;
      if (v5 >= v31 - 0x8000)
        v12 = v31 - 0x8000;
      else
        v12 = v5;
      if (v12 <= -32768)
        v12 = -32768;
      v13 = v12 + 0x8000;
      if (v5 <= 0x8000)
        v14 = 0x8000;
      else
        v14 = v5;
      v15 = v14 - 0x8000;
      if (v15 >= v31)
        v16 = v31;
      else
        v16 = v15;
      v17 = v34 + v33 * ((uint64_t)v16 >> 16);
      v18 = v34 + v33 * HIWORD(v13);
      v19 = (v11 >> 15) & 0xFFFFFFFE;
      v20 = v18 + v19;
      v35 = 0;
      v36[0] = 0;
      v21 = (v8 >> 15) & 0x1FFFE;
      v22 = v17 + v21;
      v23 = v18 + v21;
      CA::OGL::SW::Format::CbYCrY8::load_1((unsigned int *)v36 + 1, v17 + v19, a3);
      CA::OGL::SW::Format::CbYCrY8::load_1((unsigned int *)v36, v22, v24);
      CA::OGL::SW::Format::CbYCrY8::load_1((unsigned int *)&v35 + 1, v20, v25);
      CA::OGL::SW::Format::CbYCrY8::load_1((unsigned int *)&v35, v23, v26);
      v27 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)__PAIR64__(v35, HIDWORD(v35)), (uint8x8_t)__PAIR64__(v36[0], HIDWORD(v36[0]))), vdupq_n_s16((v16 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v36[0], HIDWORD(v36[0])));
      *(int16x4_t *)v27.i8 = vadd_s16(*(int16x4_t *)v27.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), *(int16x4_t *)v27.i8), vdup_n_s16((v11 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v27.i8, *(int8x8_t *)v27.i8);
      v6 += v29;
      v5 += v30;
      *(_DWORD *)v3 = result.i32[0];
      v3 += 4;
    }
    while (v4);
  }
  return result;
}

unsigned int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::CbYCrY8,unsigned int,true,true,true,true>(unsigned int *result, int a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v4;
  float v5;
  float v6;
  int v7;
  int v8;
  int v9;
  float32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  int32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  int v27;
  int v28;
  unsigned int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  signed int v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  const unsigned __int8 *v44;
  const unsigned __int8 *v45;
  const unsigned __int8 *v46;
  int8x16_t v47;
  unsigned int *v48;
  float *v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  int v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD v58[3];

  v48 = result;
  v58[1] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (unsigned __int8 *)a3;
    v4 = a2;
    v55 = *(_QWORD *)(*(_QWORD *)result + 16);
    v56 = **(_QWORD **)result;
    v49 = *(float **)result;
    v5 = *(float *)(*((_QWORD *)result + 3) + 12);
    v6 = *(float *)(*((_QWORD *)result + 2) + 12);
    v7 = result[15];
    v52 = result[16];
    v53 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[13];
    v51 = result[14];
    v54 = *(_DWORD *)(*(_QWORD *)result + 32);
    v9 = *((unsigned __int8 *)result + 48) - 1;
    v10 = (float32x2_t)vdup_n_s32(0x37800000u);
    v11 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v12 = (float32x2_t)vdup_n_s32(0x47800000u);
    v50 = v9;
    do
    {
      v13.f32[0] = (float)(1.0 / v6) * (float)v8;
      v13.f32[1] = (float)(1.0 / v6) * (float)v7;
      v14 = vcvt_s32_f32(v13);
      switch(v9)
      {
        case 0:
          v15 = vmul_f32(*(float32x2_t *)(v49 + 10), vcvt_f32_s32(v14));
          v16 = vmul_f32(v15, v15);
          v17 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 1), v16);
          v16.f32[0] = fmaxf(vaddv_f32(v16), 0.00001);
          v16.i32[0] = vmul_f32(v17, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 0))).u32[0];
          v16.i32[1] = 0.5;
          v18 = vmul_f32(v16, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6)));
          goto LABEL_8;
        case 1:
          v19 = atan2f(v49[11] * (float)v14.i32[1], v49[10] * (float)v14.i32[0]);
          v20.i32[1] = 1056964608;
          v20.f32[0] = (float)(v19 * -10430.0) + 32768.0;
          v18 = vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6)));
          goto LABEL_8;
        case 2:
          v21 = vmul_f32(vcvt_f32_s32(v14), vmul_f32(v10, *(float32x2_t *)(v49 + 10)));
          v18 = vmul_f32(vmla_f32(*(float32x2_t *)(v48 + 23), *(float32x2_t *)(v48 + 21), vminnm_f32(vsub_f32(v21, vrndm_f32(v21)), v11)), vmul_f32(v12, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6))));
          goto LABEL_8;
        case 4:
          v22 = vcvt_f32_s32(v14);
          v23 = vcvt_f32_s32(*(int32x2_t *)(v49 + 8));
          v24 = vmul_f32(*(float32x2_t *)(v48 + 21), v23);
          v25 = vmul_f32(*(float32x2_t *)(v48 + 23), v23);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, v25), (int8x8_t)v25, (int8x8_t)v22);
          v18 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v24, v26), (int8x8_t)v24, (int8x8_t)v26);
LABEL_8:
          v14 = vcvt_s32_f32(v18);
          break;
        default:
          break;
      }
      --v4;
      v27 = v14.i32[0];
      v28 = v54 - 0x8000;
      if (v14.i32[0] < v54 - 0x8000)
        v28 = v14.i32[0];
      if (v28 <= -32768)
        v28 = -32768;
      v29 = v28 + 0x8000;
      if (v14.i32[0] <= 0x8000)
        v27 = 0x8000;
      v30 = v27 - 0x8000;
      if (v30 >= v54)
        v31 = v54;
      else
        v31 = v30;
      v32 = v14.i32[1];
      if (v14.i32[1] >= v53 - 0x8000)
        v33 = v53 - 0x8000;
      else
        v33 = v14.i32[1];
      if (v33 <= -32768)
        v33 = -32768;
      v34 = v33 + 0x8000;
      if (v14.i32[1] <= 0x8000)
        v32 = 0x8000;
      v35 = v32 - 0x8000;
      if (v35 >= v53)
        v36 = v53;
      else
        v36 = v35;
      v37 = v56 + v55 * ((uint64_t)v36 >> 16);
      v38 = v56 + v55 * HIWORD(v34);
      v39 = (v31 >> 15) & 0xFFFFFFFE;
      v40 = v38 + v39;
      v57 = 0;
      v58[0] = 0;
      v41 = (v29 >> 15) & 0x1FFFE;
      v42 = v37 + v41;
      v43 = v38 + v41;
      CA::OGL::SW::Format::CbYCrY8::load_1((unsigned int *)v58 + 1, v37 + v39, a3);
      CA::OGL::SW::Format::CbYCrY8::load_1((unsigned int *)v58, v42, v44);
      CA::OGL::SW::Format::CbYCrY8::load_1((unsigned int *)&v57 + 1, v40, v45);
      result = CA::OGL::SW::Format::CbYCrY8::load_1((unsigned int *)&v57, v43, v46);
      v47 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)__PAIR64__(v57, HIDWORD(v57)), (uint8x8_t)__PAIR64__(v58[0], HIDWORD(v58[0]))), vdupq_n_s16((v36 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v58[0], HIDWORD(v58[0])));
      *(int16x4_t *)v47.i8 = vadd_s16(*(int16x4_t *)v47.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL), *(int16x4_t *)v47.i8), vdup_n_s16((v31 >> 1) & 0x7F80)));
      v6 = v6 + v5;
      v8 += v51;
      v7 += v52;
      *(_DWORD *)v3 = vuzp1_s8(*(int8x8_t *)v47.i8, *(int8x8_t *)v47.i8).u32[0];
      v3 += 4;
      v9 = v50;
    }
    while (v4);
  }
  return result;
}

unsigned int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::YCbYCr8,unsigned int,true,true,false,false>(unsigned int *result, int a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (unsigned __int8 *)a3;
    v4 = a2;
    v5 = **(_QWORD **)result;
    v6 = *(_QWORD *)(*(_QWORD *)result + 16);
    v7 = *(_DWORD *)(*(_QWORD *)result + 32);
    v8 = *(_DWORD *)(*(_QWORD *)result + 36);
    v10 = result[15];
    v9 = result[16];
    v12 = result[13];
    v11 = result[14];
    do
    {
      --v4;
      v15 = 0;
      v13 = v12 & ~(v12 >> 31);
      if (v13 >= v7)
        v13 = v7;
      v14 = v10 & ~(v10 >> 31);
      if (v14 >= v8)
        v14 = v8;
      result = CA::OGL::SW::Format::YCbYCr8::load_1(&v15, v5 + v6 * ((uint64_t)v14 >> 16) + (int)((v13 >> 15) & 0xFFFFFFFE), a3);
      v12 += v11;
      v10 += v9;
      *(_DWORD *)v3 = v15;
      v3 += 4;
    }
    while (v4);
  }
  return result;
}

unsigned int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::YCbYCr8,unsigned int,true,true,true,false>(unsigned int *result, int a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v4;
  float *v5;
  int v6;
  int v7;
  float v8;
  float v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  int32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  int v32;
  int v33;
  unsigned int *v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;

  v34 = result;
  v38 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (unsigned __int8 *)a3;
    v4 = a2;
    v5 = *(float **)result;
    v35 = *(_QWORD *)(*(_QWORD *)result + 16);
    v36 = **(_QWORD **)result;
    v6 = *(_DWORD *)(*(_QWORD *)result + 32);
    v7 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = *(float *)(*((_QWORD *)result + 3) + 12);
    v9 = *(float *)(*((_QWORD *)result + 2) + 12);
    v11 = result[15];
    v10 = result[16];
    v13 = result[13];
    v12 = result[14];
    v14 = *((unsigned __int8 *)result + 48) - 1;
    v15 = (float32x2_t)vdup_n_s32(0x37800000u);
    v16 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v17 = (float32x2_t)vdup_n_s32(0x47800000u);
    do
    {
      v37 = 0;
      v18.f32[0] = (float)(1.0 / v9) * (float)v13;
      v18.f32[1] = (float)(1.0 / v9) * (float)v11;
      v19 = vcvt_s32_f32(v18);
      switch(v14)
      {
        case 0:
          v20 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v19));
          v21 = vmul_f32(v20, v20);
          v22 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 1), v21);
          v21.f32[0] = fmaxf(vaddv_f32(v21), 0.00001);
          v21.i32[0] = vmul_f32(v22, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 0))).u32[0];
          v21.i32[1] = 0.5;
          v23 = vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          v24 = atan2f(v5[11] * (float)v19.i32[1], v5[10] * (float)v19.i32[0]);
          v25.i32[1] = 1056964608;
          v25.f32[0] = (float)(v24 * -10430.0) + 32768.0;
          v23 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          v26 = vmul_f32(vcvt_f32_s32(v19), vmul_f32(v15, *(float32x2_t *)(v5 + 10)));
          v23 = vmul_f32(vmla_f32(*(float32x2_t *)(v34 + 23), *(float32x2_t *)(v34 + 21), vminnm_f32(vsub_f32(v26, vrndm_f32(v26)), v16)), vmul_f32(v17, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          v27 = vcvt_f32_s32(v19);
          v28 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          v29 = vmul_f32(*(float32x2_t *)(v34 + 21), v28);
          v30 = vmul_f32(*(float32x2_t *)(v34 + 23), v28);
          v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, v30), (int8x8_t)v30, (int8x8_t)v27);
          v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29, v31), (int8x8_t)v29, (int8x8_t)v31);
LABEL_8:
          v19 = vcvt_s32_f32(v23);
          break;
        default:
          break;
      }
      --v4;
      v32 = v19.i32[0] & ~(v19.i32[0] >> 31);
      if (v32 >= v6)
        v32 = v6;
      v33 = v19.i32[1] & ~(v19.i32[1] >> 31);
      if (v33 >= v7)
        v33 = v7;
      result = CA::OGL::SW::Format::YCbYCr8::load_1(&v37, v36 + v35 * ((uint64_t)v33 >> 16) + (int)((v32 >> 15) & 0xFFFFFFFE), a3);
      v9 = v9 + v8;
      v13 += v12;
      v11 += v10;
      *(_DWORD *)v3 = v37;
      v3 += 4;
    }
    while (v4);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::YCbYCr8,unsigned int,true,true,false,true>(int *a1, int a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  signed int v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  const unsigned __int8 *v24;
  const unsigned __int8 *v25;
  const unsigned __int8 *v26;
  int8x16_t v27;
  int8x8_t result;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD v36[2];

  v36[1] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (unsigned __int8 *)a3;
    v4 = a2;
    v33 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v34 = **(_QWORD **)a1;
    v5 = a1[15];
    v31 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v32 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v30 = a1[16];
    v6 = a1[13];
    v29 = a1[14];
    do
    {
      --v4;
      v7 = v32 - 0x8000;
      if (v6 < v32 - 0x8000)
        v7 = v6;
      if (v7 <= -32768)
        v7 = -32768;
      v8 = v7 + 0x8000;
      if (v6 <= 0x8000)
        v9 = 0x8000;
      else
        v9 = v6;
      v10 = v9 - 0x8000;
      if (v10 >= v32)
        v11 = v32;
      else
        v11 = v10;
      if (v5 >= v31 - 0x8000)
        v12 = v31 - 0x8000;
      else
        v12 = v5;
      if (v12 <= -32768)
        v12 = -32768;
      v13 = v12 + 0x8000;
      if (v5 <= 0x8000)
        v14 = 0x8000;
      else
        v14 = v5;
      v15 = v14 - 0x8000;
      if (v15 >= v31)
        v16 = v31;
      else
        v16 = v15;
      v17 = v34 + v33 * ((uint64_t)v16 >> 16);
      v18 = v34 + v33 * HIWORD(v13);
      v19 = (v11 >> 15) & 0xFFFFFFFE;
      v20 = v18 + v19;
      v35 = 0;
      v36[0] = 0;
      v21 = (v8 >> 15) & 0x1FFFE;
      v22 = v17 + v21;
      v23 = v18 + v21;
      CA::OGL::SW::Format::YCbYCr8::load_1((unsigned int *)v36 + 1, v17 + v19, a3);
      CA::OGL::SW::Format::YCbYCr8::load_1((unsigned int *)v36, v22, v24);
      CA::OGL::SW::Format::YCbYCr8::load_1((unsigned int *)&v35 + 1, v20, v25);
      CA::OGL::SW::Format::YCbYCr8::load_1((unsigned int *)&v35, v23, v26);
      v27 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)__PAIR64__(v35, HIDWORD(v35)), (uint8x8_t)__PAIR64__(v36[0], HIDWORD(v36[0]))), vdupq_n_s16((v16 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v36[0], HIDWORD(v36[0])));
      *(int16x4_t *)v27.i8 = vadd_s16(*(int16x4_t *)v27.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), *(int16x4_t *)v27.i8), vdup_n_s16((v11 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v27.i8, *(int8x8_t *)v27.i8);
      v6 += v29;
      v5 += v30;
      *(_DWORD *)v3 = result.i32[0];
      v3 += 4;
    }
    while (v4);
  }
  return result;
}

unsigned int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::YCbYCr8,unsigned int,true,true,true,true>(unsigned int *result, int a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v4;
  float v5;
  float v6;
  int v7;
  int v8;
  int v9;
  float32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  int32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  int v27;
  int v28;
  unsigned int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  signed int v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  const unsigned __int8 *v44;
  const unsigned __int8 *v45;
  const unsigned __int8 *v46;
  int8x16_t v47;
  unsigned int *v48;
  float *v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  int v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD v58[3];

  v48 = result;
  v58[1] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (unsigned __int8 *)a3;
    v4 = a2;
    v55 = *(_QWORD *)(*(_QWORD *)result + 16);
    v56 = **(_QWORD **)result;
    v49 = *(float **)result;
    v5 = *(float *)(*((_QWORD *)result + 3) + 12);
    v6 = *(float *)(*((_QWORD *)result + 2) + 12);
    v7 = result[15];
    v52 = result[16];
    v53 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[13];
    v51 = result[14];
    v54 = *(_DWORD *)(*(_QWORD *)result + 32);
    v9 = *((unsigned __int8 *)result + 48) - 1;
    v10 = (float32x2_t)vdup_n_s32(0x37800000u);
    v11 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v12 = (float32x2_t)vdup_n_s32(0x47800000u);
    v50 = v9;
    do
    {
      v13.f32[0] = (float)(1.0 / v6) * (float)v8;
      v13.f32[1] = (float)(1.0 / v6) * (float)v7;
      v14 = vcvt_s32_f32(v13);
      switch(v9)
      {
        case 0:
          v15 = vmul_f32(*(float32x2_t *)(v49 + 10), vcvt_f32_s32(v14));
          v16 = vmul_f32(v15, v15);
          v17 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 1), v16);
          v16.f32[0] = fmaxf(vaddv_f32(v16), 0.00001);
          v16.i32[0] = vmul_f32(v17, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 0))).u32[0];
          v16.i32[1] = 0.5;
          v18 = vmul_f32(v16, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6)));
          goto LABEL_8;
        case 1:
          v19 = atan2f(v49[11] * (float)v14.i32[1], v49[10] * (float)v14.i32[0]);
          v20.i32[1] = 1056964608;
          v20.f32[0] = (float)(v19 * -10430.0) + 32768.0;
          v18 = vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6)));
          goto LABEL_8;
        case 2:
          v21 = vmul_f32(vcvt_f32_s32(v14), vmul_f32(v10, *(float32x2_t *)(v49 + 10)));
          v18 = vmul_f32(vmla_f32(*(float32x2_t *)(v48 + 23), *(float32x2_t *)(v48 + 21), vminnm_f32(vsub_f32(v21, vrndm_f32(v21)), v11)), vmul_f32(v12, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6))));
          goto LABEL_8;
        case 4:
          v22 = vcvt_f32_s32(v14);
          v23 = vcvt_f32_s32(*(int32x2_t *)(v49 + 8));
          v24 = vmul_f32(*(float32x2_t *)(v48 + 21), v23);
          v25 = vmul_f32(*(float32x2_t *)(v48 + 23), v23);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, v25), (int8x8_t)v25, (int8x8_t)v22);
          v18 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v24, v26), (int8x8_t)v24, (int8x8_t)v26);
LABEL_8:
          v14 = vcvt_s32_f32(v18);
          break;
        default:
          break;
      }
      --v4;
      v27 = v14.i32[0];
      v28 = v54 - 0x8000;
      if (v14.i32[0] < v54 - 0x8000)
        v28 = v14.i32[0];
      if (v28 <= -32768)
        v28 = -32768;
      v29 = v28 + 0x8000;
      if (v14.i32[0] <= 0x8000)
        v27 = 0x8000;
      v30 = v27 - 0x8000;
      if (v30 >= v54)
        v31 = v54;
      else
        v31 = v30;
      v32 = v14.i32[1];
      if (v14.i32[1] >= v53 - 0x8000)
        v33 = v53 - 0x8000;
      else
        v33 = v14.i32[1];
      if (v33 <= -32768)
        v33 = -32768;
      v34 = v33 + 0x8000;
      if (v14.i32[1] <= 0x8000)
        v32 = 0x8000;
      v35 = v32 - 0x8000;
      if (v35 >= v53)
        v36 = v53;
      else
        v36 = v35;
      v37 = v56 + v55 * ((uint64_t)v36 >> 16);
      v38 = v56 + v55 * HIWORD(v34);
      v39 = (v31 >> 15) & 0xFFFFFFFE;
      v40 = v38 + v39;
      v57 = 0;
      v58[0] = 0;
      v41 = (v29 >> 15) & 0x1FFFE;
      v42 = v37 + v41;
      v43 = v38 + v41;
      CA::OGL::SW::Format::YCbYCr8::load_1((unsigned int *)v58 + 1, v37 + v39, a3);
      CA::OGL::SW::Format::YCbYCr8::load_1((unsigned int *)v58, v42, v44);
      CA::OGL::SW::Format::YCbYCr8::load_1((unsigned int *)&v57 + 1, v40, v45);
      result = CA::OGL::SW::Format::YCbYCr8::load_1((unsigned int *)&v57, v43, v46);
      v47 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)__PAIR64__(v57, HIDWORD(v57)), (uint8x8_t)__PAIR64__(v58[0], HIDWORD(v58[0]))), vdupq_n_s16((v36 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v58[0], HIDWORD(v58[0])));
      *(int16x4_t *)v47.i8 = vadd_s16(*(int16x4_t *)v47.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL), *(int16x4_t *)v47.i8), vdup_n_s16((v31 >> 1) & 0x7F80)));
      v6 = v6 + v5;
      v8 += v51;
      v7 += v52;
      *(_DWORD *)v3 = vuzp1_s8(*(int8x8_t *)v47.i8, *(int8x8_t *)v47.i8).u32[0];
      v3 += 4;
      v9 = v50;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,false,false,false,false>(uint64_t result, int a2, int *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  int v6;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 52);
    v3 = *(_DWORD *)(result + 56);
    v5 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      v6 = *(unsigned __int8 *)(v5 + (v4 >> 16)) << 24;
      v4 += v3;
      *a3++ = v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,true,false,false,false>(int *result, int a2, int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v6 = result[15];
    v5 = result[16];
    v8 = result[13];
    v7 = result[14];
    do
    {
      v9 = *(unsigned __int8 *)(v3 + v4 * ((uint64_t)v6 >> 16) + (v8 >> 16)) << 24;
      v8 += v7;
      v6 += v5;
      *a3++ = v9;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,false,true,false,false>(_DWORD *result, int a2, _DWORD *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;

  if (a2)
  {
    v3 = result[14];
    v4 = result[13];
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(_QWORD *)result + 36))
      v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v7 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5)
        v8 = v5;
      v4 += v3;
      *a3++ = *(unsigned __int8 *)(v7 + (v8 >> 16)) << 24;
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,true,true,false,false>(int *result, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      v10 += v9;
      v8 += v7;
      *a3++ = *(unsigned __int8 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (v11 >> 16)) << 24;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, _DWORD *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  int v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  int v40;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v40 = v13;
    v38 = v17;
    v39 = v8;
    v37 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v38;
          v8 = v39;
          v13 = v40;
          v9 = v37;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = *(unsigned __int8 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (v35 >> 16)) << 24;
      --v4;
    }
    while (v4);
  }
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, int32x2_t a5, int32x2_t a6)
{
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint8x8_t v16;
  int8x16_t v17;

  if (a2)
  {
    v6 = result[14];
    v7 = result[15];
    v8 = *(_QWORD *)(*(_QWORD *)result + 16);
    v9 = **(_QWORD **)result;
    v10 = v7 + 0x8000;
    v11 = v7 - 0x8000;
    v12 = v9 + v8 * ((uint64_t)(v7 - 0x8000) >> 16);
    v13 = v9 + v8 * ((uint64_t)v10 >> 16);
    a4.i32[0] = (v11 >> 1) & 0x7F80;
    v14 = result[13] - 0x8000;
    do
    {
      v15 = (v14 + 0x10000) >> 16;
      a5.i8[0] = *(_BYTE *)(v12 + (v14 >> 16));
      a5.i8[4] = *(_BYTE *)(v12 + v15);
      a6.i8[0] = *(_BYTE *)(v13 + (v14 >> 16));
      a6.i8[4] = *(_BYTE *)(v13 + v15);
      v16 = (uint8x8_t)vshl_n_s32(a5, 0x18uLL);
      v17 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vshl_n_s32(a6, 0x18uLL), v16), a4, 0), v16);
      a6 = (int32x2_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL), *(int16x4_t *)v17.i8), vdup_n_s16((v14 >> 1) & 0x7F80));
      a5 = (int32x2_t)vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v17.i8, (int16x4_t)a6), (int8x8_t)a4);
      *a3++ = a5.i32[0];
      v14 += v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

int32x2_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3, int32x2_t result, int32x2_t a5)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint8x8_t v14;
  int8x16_t v15;

  if (a2)
  {
    v5 = **(_QWORD **)a1;
    v6 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v7 = a1[16];
    v8 = a1[14];
    v9 = a1[13] - 0x8000;
    v10 = a1[15] - 0x8000;
    do
    {
      v11 = v5 + v6 * ((uint64_t)v10 >> 16);
      v12 = v5 + v6 * ((uint64_t)(v10 + 0x10000) >> 16);
      v13 = (v9 + 0x10000) >> 16;
      result.i8[0] = *(_BYTE *)(v11 + (v9 >> 16));
      result.i8[4] = *(_BYTE *)(v11 + v13);
      a5.i8[0] = *(_BYTE *)(v12 + (v9 >> 16));
      a5.i8[4] = *(_BYTE *)(v12 + v13);
      v14 = (uint8x8_t)vshl_n_s32(result, 0x18uLL);
      v15 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vshl_n_s32(a5, 0x18uLL), v14), vdupq_n_s16((v10 >> 1) & 0x7F80)), v14);
      a5 = (int32x2_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL), *(int16x4_t *)v15.i8), vdup_n_s16((v9 >> 1) & 0x7F80));
      *(int16x4_t *)v15.i8 = vadd_s16(*(int16x4_t *)v15.i8, (int16x4_t)a5);
      result = (int32x2_t)vuzp1_s8(*(int8x8_t *)v15.i8, *(int8x8_t *)v15.i8);
      *a3++ = result.i32[0];
      v9 += v8;
      v10 += v7;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, int32x2_t a5, int32x2_t a6)
{
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unint64_t v19;
  int v20;
  int v21;
  uint8x8_t v22;
  int8x16_t v23;

  if (a2)
  {
    v6 = result[14];
    v7 = result[15];
    v8 = result[13];
    v9 = *(_DWORD *)(*(_QWORD *)result + 32);
    v10 = *(_DWORD *)(*(_QWORD *)result + 36);
    v11 = *(_QWORD *)(*(_QWORD *)result + 16);
    v12 = **(_QWORD **)result;
    if (v7 >= v10 - 0x8000)
      v13 = v10 - 0x8000;
    else
      v13 = result[15];
    if (v13 <= -32768)
      v13 = -32768;
    if (v7 <= 0x8000)
      v7 = 0x8000;
    v14 = v7 - 0x8000;
    if (v14 >= v10)
      v15 = *(_DWORD *)(*(_QWORD *)result + 36);
    else
      v15 = v14;
    v16 = v12 + v11 * ((uint64_t)v15 >> 16);
    v17 = v12 + v11 * ((v13 + 0x8000) >> 16);
    a4.i32[0] = (v15 >> 1) & 0x7F80;
    do
    {
      if (v8 >= v9 - 0x8000)
        v18 = v9 - 0x8000;
      else
        v18 = v8;
      if (v18 <= -32768)
        v18 = -32768;
      v19 = (v18 + 0x8000);
      if (v8 <= 0x8000)
        v20 = 0x8000;
      else
        v20 = v8;
      v21 = v20 - 0x8000;
      if (v21 >= v9)
        v21 = v9;
      result = (_DWORD *)(v17 + (v21 >> 16));
      a5.i8[0] = *(_BYTE *)(v16 + (v21 >> 16));
      a5.i8[4] = *(_BYTE *)(v16 + (v19 >> 16));
      a6.i8[0] = *(_BYTE *)result;
      a6.i8[4] = *(_BYTE *)(v17 + (v19 >> 16));
      v22 = (uint8x8_t)vshl_n_s32(a5, 0x18uLL);
      v23 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vshl_n_s32(a6, 0x18uLL), v22), a4, 0), v22);
      a6 = (int32x2_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL), *(int16x4_t *)v23.i8), vdup_n_s16((v21 >> 1) & 0x7F80));
      a5 = (int32x2_t)vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v23.i8, (int16x4_t)a6), (int8x8_t)a4);
      v8 += v6;
      *a3++ = a5.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

int32x2_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3, int32x2_t result, int32x2_t a5)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unint64_t v17;
  int v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint8x8_t v23;
  int8x16_t v24;

  if (a2)
  {
    v5 = **(_QWORD **)a1;
    v6 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v7 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v8 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v10 = a1[15];
    v9 = a1[16];
    v12 = a1[13];
    v11 = a1[14];
    do
    {
      if (v12 >= v7 - 0x8000)
        v13 = v7 - 0x8000;
      else
        v13 = v12;
      if (v13 <= -32768)
        v13 = -32768;
      if (v12 <= 0x8000)
        v14 = 0x8000;
      else
        v14 = v12;
      v15 = v14 - 0x8000;
      if (v15 >= v7)
        v15 = v7;
      if (v10 >= v8 - 0x8000)
        v16 = v8 - 0x8000;
      else
        v16 = v10;
      v17 = (v13 + 0x8000);
      if (v16 <= -32768)
        v16 = -32768;
      if (v10 <= 0x8000)
        v18 = 0x8000;
      else
        v18 = v10;
      v19 = v18 - 0x8000;
      v20 = v16 + 0x8000;
      if (v19 >= v8)
        v19 = v8;
      v21 = v5 + v6 * ((uint64_t)v19 >> 16);
      v22 = v5 + v6 * HIWORD(v20);
      result.i8[0] = *(_BYTE *)(v21 + (v15 >> 16));
      a5.i8[0] = *(_BYTE *)(v22 + (v15 >> 16));
      a5.i8[4] = *(_BYTE *)(v22 + (v17 >> 16));
      result.i8[4] = *(_BYTE *)(v21 + (v17 >> 16));
      v23 = (uint8x8_t)vshl_n_s32(result, 0x18uLL);
      v24 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vshl_n_s32(a5, 0x18uLL), v23), vdupq_n_s16((v19 >> 1) & 0x7F80)), v23);
      a5 = (int32x2_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL), *(int16x4_t *)v24.i8), vdup_n_s16((v15 >> 1) & 0x7F80));
      *(int16x4_t *)v24.i8 = vadd_s16(*(int16x4_t *)v24.i8, (int16x4_t)a5);
      result = (int32x2_t)vuzp1_s8(*(int8x8_t *)v24.i8, *(int8x8_t *)v24.i8);
      v12 += v11;
      v10 += v9;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::S8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  uint32x2_t *v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  int v38;
  int v39;
  unint64_t v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint8x8_t v48;
  int8x16_t v49;
  int v50;
  uint64_t **v51;
  int v52;
  int v53;
  int v54;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = *((unsigned __int8 *)result + 48) - 1;
    v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    v53 = v8;
    v54 = v12;
    v52 = v8 - 0x8000;
    v50 = v18;
    v51 = result;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          v24 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v23));
          v25 = vmul_f32(v24, v24);
          v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v22 = vcvt_f32_u32(v5[3]);
          v25.i32[1] = 0.5;
          v27 = vmul_f32(v25, v22);
          goto LABEL_8;
        case 1:
          v28 = v5;
          v29 = v9;
          v30 = v14;
          v31 = atan2f(*(float *)&v5[5].i32[1] * (float)v23.i32[1], *(float *)v5[5].i32 * (float)v23.i32[0]);
          v18 = v50;
          result = v51;
          v16 = v52;
          v8 = v53;
          v14 = v30;
          v12 = v54;
          v9 = v29;
          v5 = v28;
          v22 = vcvt_f32_u32(v28[3]);
          v32.i32[1] = 1056964608;
          v32.f32[0] = (float)(v31 * -10430.0) + 32768.0;
          v27 = vmul_f32(v32, v22);
          goto LABEL_8;
        case 2:
          v33 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, (float32x2_t)v5[5]));
          v22 = *(float32x2_t *)((char *)result + 84);
          v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), v22, vminnm_f32(vsub_f32(v33, vrndm_f32(v33)), v20)), vmul_f32(v21, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v34 = vcvt_f32_s32(v23);
          v35 = vcvt_f32_s32((int32x2_t)v5[4]);
          v22 = vmul_f32(*(float32x2_t *)((char *)result + 84), v35);
          v36 = vmul_f32(*(float32x2_t *)((char *)result + 92), v35);
          v37 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v34, v36), (int8x8_t)v36, (int8x8_t)v34);
          v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, v37), (int8x8_t)v22, (int8x8_t)v37);
LABEL_8:
          v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      v38 = v23.i32[0];
      if (v23.i32[0] >= v16)
        v39 = v16;
      else
        v39 = v23.i32[0];
      if (v39 <= -32768)
        v39 = -32768;
      v40 = (v39 + 0x8000);
      if (v23.i32[0] <= 0x8000)
        v38 = 0x8000;
      v41 = v38 - 0x8000;
      if (v41 >= v8)
        v41 = v8;
      v42 = v23.i32[1];
      if (v23.i32[1] >= v17)
        v43 = v17;
      else
        v43 = v23.i32[1];
      if (v43 <= -32768)
        v43 = -32768;
      v44 = v43 + 0x8000;
      if (v23.i32[1] <= 0x8000)
        v42 = 0x8000;
      v45 = v42 - 0x8000;
      if (v45 >= (int)v9)
        v45 = v9;
      v46 = v6 + v7 * ((uint64_t)v45 >> 16);
      v47 = v6 + v7 * HIWORD(v44);
      v23.i8[0] = *(_BYTE *)(v46 + (v41 >> 16));
      v23.i8[4] = *(_BYTE *)(v46 + (v40 >> 16));
      v48 = (uint8x8_t)vshl_n_s32(v23, 0x18uLL);
      v22.i8[0] = *(_BYTE *)(v47 + (v41 >> 16));
      v22.i8[4] = *(_BYTE *)(v47 + (v40 >> 16));
      v49 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vshl_n_s32((int32x2_t)v22, 0x18uLL), v48), vdupq_n_s16((v45 >> 1) & 0x7F80)), v48);
      *(int16x4_t *)v49.i8 = vadd_s16(*(int16x4_t *)v49.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v49, v49, 8uLL), *(int16x4_t *)v49.i8), vdup_n_s16((v41 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v49.i8, *(int8x8_t *)v49.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,false,false,false,false>(uint64_t result, int a2, int *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  int v6;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 52);
    v3 = *(_DWORD *)(result + 56);
    v5 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      v6 = *(unsigned __int8 *)(v5 + (v4 >> 16));
      v4 += v3;
      *a3++ = v6 | (v6 << 8) | ((v6 | (v6 << 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,true,false,false,false>(int *result, int a2, int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v6 = result[15];
    v5 = result[16];
    v8 = result[13];
    v7 = result[14];
    do
    {
      v9 = *(unsigned __int8 *)(v3 + v4 * ((uint64_t)v6 >> 16) + (v8 >> 16));
      v8 += v7;
      v6 += v5;
      *a3++ = v9 | (v9 << 8) | ((v9 | (v9 << 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,false,true,false,false>(_DWORD *result, int a2, int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;

  if (a2)
  {
    v3 = result[14];
    v4 = result[13];
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(_QWORD *)result + 36))
      v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v7 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5)
        v8 = v5;
      v9 = *(unsigned __int8 *)(v7 + (v8 >> 16));
      v4 += v3;
      *a3++ = v9 | (v9 << 8) | ((v9 | (v9 << 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,true,true,false,false>(int *result, int a2, int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      v13 = *(unsigned __int8 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (v11 >> 16));
      v10 += v9;
      v8 += v7;
      *a3++ = v13 | (v13 << 8) | ((v13 | (v13 << 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, int *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  int v41;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v41 = v13;
    v39 = v17;
    v40 = v8;
    v38 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v39;
          v8 = v40;
          v13 = v41;
          v9 = v38;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v37 = *(unsigned __int8 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (v35 >> 16));
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = v37 | (v37 << 8) | ((v37 | (v37 << 8)) << 16);
      --v4;
    }
    while (v4);
  }
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, int8x8_t a6)
{
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;
  uint8x8_t v19;
  int8x16_t v20;

  if (a2)
  {
    v6 = result[14];
    v7 = result[15];
    v8 = *(_QWORD *)(*(_QWORD *)result + 16);
    v9 = **(_QWORD **)result;
    v10 = v7 + 0x8000;
    v11 = v7 - 0x8000;
    v12 = v9 + v8 * ((uint64_t)(v7 - 0x8000) >> 16);
    v13 = v9 + v8 * ((uint64_t)v10 >> 16);
    a4.i32[0] = (v11 >> 1) & 0x7F80;
    v14 = result[13] - 0x8000;
    do
    {
      v15 = (v14 + 0x10000) >> 16;
      a6.i8[0] = *(_BYTE *)(v12 + (v14 >> 16));
      a6.i8[4] = *(_BYTE *)(v12 + v15);
      v16 = (int32x2_t)vand_s8(a6, (int8x8_t)0xFF000000FFLL);
      v17 = vsli_n_s32((int32x2_t)a6, v16, 8uLL);
      v16.i8[0] = *(_BYTE *)(v13 + (v14 >> 16));
      v16.i8[4] = *(_BYTE *)(v13 + v15);
      v18 = vsli_n_s32(v16, (int32x2_t)vand_s8((int8x8_t)v16, (int8x8_t)0xFF000000FFLL), 8uLL);
      v19 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v17, 0x10uLL), (int8x8_t)v17);
      v20 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v18, 0x10uLL), (int8x8_t)v18), v19), a4, 0), v19);
      a6 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v20.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL), *(int16x4_t *)v20.i8), vdup_n_s16((v14 >> 1) & 0x7F80))), (int8x8_t)a4);
      *a3++ = a6.i32[0];
      v14 += v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,true,false,false,true>(_DWORD *result, int a2, _DWORD *a3, double a4, int32x2_t a5, double a6, int32x2_t a7)
{
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int32x2_t v16;
  int32x2_t v17;
  uint8x8_t v18;
  int8x16_t v19;

  if (a2)
  {
    v7 = **(_QWORD **)result;
    v8 = *(_QWORD *)(*(_QWORD *)result + 16);
    v9 = result[16];
    v10 = result[14];
    v11 = result[13] - 0x8000;
    v12 = result[15] - 0x8000;
    do
    {
      v13 = v7 + v8 * ((uint64_t)v12 >> 16);
      v14 = v7 + v8 * ((uint64_t)(v12 + 0x10000) >> 16);
      result = (_DWORD *)(v13 + (v11 >> 16));
      v15 = (v11 + 0x10000) >> 16;
      a5.i8[0] = *(_BYTE *)result;
      a5.i8[4] = *(_BYTE *)(v13 + v15);
      a7.i8[0] = *(_BYTE *)(v14 + (v11 >> 16));
      v16 = vsli_n_s32(a5, (int32x2_t)vand_s8((int8x8_t)a5, (int8x8_t)0xFF000000FFLL), 8uLL);
      a7.i8[4] = *(_BYTE *)(v14 + v15);
      v17 = vsli_n_s32(a7, (int32x2_t)vand_s8((int8x8_t)a7, (int8x8_t)0xFF000000FFLL), 8uLL);
      v18 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v16, 0x10uLL), (int8x8_t)v16);
      v19 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v17, 0x10uLL), (int8x8_t)v17), v18), vdupq_n_s16((v12 >> 1) & 0x7F80)), v18);
      a7 = (int32x2_t)vdup_n_s16((v11 >> 1) & 0x7F80);
      a5 = (int32x2_t)vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v19.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL), *(int16x4_t *)v19.i8), (int16x4_t)a7)), (int8x8_t)0xFF000000FFLL);
      *a3++ = a5.i32[0];
      v11 += v10;
      v12 += v9;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, int8x8_t a6)
{
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unint64_t v19;
  int v20;
  int v21;
  int32x2_t v22;
  int32x2_t v23;
  int32x2_t v24;
  uint8x8_t v25;
  int8x16_t v26;

  if (a2)
  {
    v6 = result[14];
    v7 = result[15];
    v8 = result[13];
    v9 = *(_DWORD *)(*(_QWORD *)result + 32);
    v10 = *(_DWORD *)(*(_QWORD *)result + 36);
    v11 = *(_QWORD *)(*(_QWORD *)result + 16);
    v12 = **(_QWORD **)result;
    if (v7 >= v10 - 0x8000)
      v13 = v10 - 0x8000;
    else
      v13 = result[15];
    if (v13 <= -32768)
      v13 = -32768;
    if (v7 <= 0x8000)
      v7 = 0x8000;
    v14 = v7 - 0x8000;
    if (v14 >= v10)
      v15 = *(_DWORD *)(*(_QWORD *)result + 36);
    else
      v15 = v14;
    v16 = v12 + v11 * ((uint64_t)v15 >> 16);
    v17 = v12 + v11 * ((v13 + 0x8000) >> 16);
    a4.i32[0] = (v15 >> 1) & 0x7F80;
    do
    {
      if (v8 >= v9 - 0x8000)
        v18 = v9 - 0x8000;
      else
        v18 = v8;
      if (v18 <= -32768)
        v18 = -32768;
      v19 = (v18 + 0x8000);
      if (v8 <= 0x8000)
        v20 = 0x8000;
      else
        v20 = v8;
      v21 = v20 - 0x8000;
      if (v21 >= v9)
        v21 = v9;
      result = (_DWORD *)(v17 + (v21 >> 16));
      a6.i8[0] = *(_BYTE *)(v16 + (v21 >> 16));
      a6.i8[4] = *(_BYTE *)(v16 + (v19 >> 16));
      v22 = (int32x2_t)vand_s8(a6, (int8x8_t)0xFF000000FFLL);
      v23 = vsli_n_s32((int32x2_t)a6, v22, 8uLL);
      v22.i8[0] = *(_BYTE *)result;
      v22.i8[4] = *(_BYTE *)(v17 + (v19 >> 16));
      v24 = vsli_n_s32(v22, (int32x2_t)vand_s8((int8x8_t)v22, (int8x8_t)0xFF000000FFLL), 8uLL);
      v25 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v23, 0x10uLL), (int8x8_t)v23);
      v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v24, 0x10uLL), (int8x8_t)v24), v25), a4, 0), v25);
      a6 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v26.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v21 >> 1) & 0x7F80))), (int8x8_t)a4);
      v8 += v6;
      *a3++ = a6.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, int32x2_t a5, double a6, int32x2_t a7)
{
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unint64_t v19;
  int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  int32x2_t v25;
  int32x2_t v26;
  uint8x8_t v27;
  int8x16_t v28;

  if (a2)
  {
    v7 = **(_QWORD **)result;
    v8 = *(_QWORD *)(*(_QWORD *)result + 16);
    v9 = *(_DWORD *)(*(_QWORD *)result + 32);
    v10 = *(_DWORD *)(*(_QWORD *)result + 36);
    v12 = *(_DWORD *)(result + 60);
    v11 = *(_DWORD *)(result + 64);
    v14 = *(_DWORD *)(result + 52);
    v13 = *(_DWORD *)(result + 56);
    result = 4294934528;
    do
    {
      if (v14 >= v9 - 0x8000)
        v15 = v9 - 0x8000;
      else
        v15 = v14;
      if (v15 <= -32768)
        v15 = -32768;
      if (v14 <= 0x8000)
        v16 = 0x8000;
      else
        v16 = v14;
      v17 = v16 - 0x8000;
      if (v17 >= v9)
        v17 = v9;
      if (v12 >= v10 - 0x8000)
        v18 = v10 - 0x8000;
      else
        v18 = v12;
      v19 = (v15 + 0x8000);
      if (v18 <= -32768)
        v18 = -32768;
      if (v12 <= 0x8000)
        v20 = 0x8000;
      else
        v20 = v12;
      v21 = v20 - 0x8000;
      v22 = v18 + 0x8000;
      if (v21 >= v10)
        v21 = v10;
      v23 = v7 + v8 * ((uint64_t)v21 >> 16);
      v24 = v7 + v8 * HIWORD(v22);
      a5.i8[0] = *(_BYTE *)(v23 + (v17 >> 16));
      a5.i8[4] = *(_BYTE *)(v23 + (v19 >> 16));
      a7.i8[0] = *(_BYTE *)(v24 + (v17 >> 16));
      v25 = vsli_n_s32(a5, (int32x2_t)vand_s8((int8x8_t)a5, (int8x8_t)0xFF000000FFLL), 8uLL);
      a7.i8[4] = *(_BYTE *)(v24 + (v19 >> 16));
      v26 = vsli_n_s32(a7, (int32x2_t)vand_s8((int8x8_t)a7, (int8x8_t)0xFF000000FFLL), 8uLL);
      v27 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v25, 0x10uLL), (int8x8_t)v25);
      v28 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v26, 0x10uLL), (int8x8_t)v26), v27), vdupq_n_s16((v21 >> 1) & 0x7F80)), v27);
      a7 = (int32x2_t)vdup_n_s16((v17 >> 1) & 0x7F80);
      a5 = (int32x2_t)vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v28.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL), *(int16x4_t *)v28.i8), (int16x4_t)a7)), (int8x8_t)0xFF000000FFLL);
      v14 += v13;
      v12 += v11;
      *a3++ = a5.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::A8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3, double a4, double a5, double a6)
{
  int v7;
  uint32x2_t *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  float v13;
  float v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  int v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  int32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  uint32x2_t *v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  float32x2_t v39;
  float32x2_t v40;
  int v41;
  int v42;
  unint64_t v43;
  int v44;
  int v45;
  int v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  int32x2_t v51;
  uint8x8_t v52;
  int32x2_t v53;
  int8x16_t v54;
  int v55;
  uint64_t **v56;
  int v57;
  int v58;
  int v59;

  if (a2)
  {
    v7 = a2;
    v8 = (uint32x2_t *)*result;
    v9 = **result;
    v10 = (*result)[2];
    v11 = *((_DWORD *)*result + 8);
    v12 = *((unsigned int *)*result + 9);
    v13 = *((float *)result[3] + 3);
    v14 = *((float *)result[2] + 3);
    v16 = *((_DWORD *)result + 15);
    v15 = *((_DWORD *)result + 16);
    v18 = *((_DWORD *)result + 13);
    v17 = *((unsigned int *)result + 14);
    v19 = v11 - 0x8000;
    v20 = v12 - 0x8000;
    v21 = *((unsigned __int8 *)result + 48) - 1;
    v22 = (float32x2_t)vdup_n_s32(0x37800000u);
    v23 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v24 = (float32x2_t)vdup_n_s32(0x47800000u);
    v58 = v11;
    v59 = v15;
    v57 = v11 - 0x8000;
    v55 = v21;
    v56 = result;
    do
    {
      *(float *)&a6 = (float)v16;
      v25.f32[0] = (float)(1.0 / v14) * (float)v18;
      v25.f32[1] = (float)(1.0 / v14) * (float)v16;
      v26 = vcvt_s32_f32(v25);
      switch(v21)
      {
        case 0:
          v27 = vmul_f32((float32x2_t)v8[5], vcvt_f32_s32(v26));
          v28 = vmul_f32(v27, v27);
          v29 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 1), v28);
          v28.f32[0] = fmaxf(vaddv_f32(v28), 0.00001);
          v28.i32[0] = vmul_f32(v29, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 0))).u32[0];
          LODWORD(a6) = 0.5;
          v28.i32[1] = 0.5;
          v30 = vmul_f32(v28, vcvt_f32_u32(v8[3]));
          goto LABEL_8;
        case 1:
          v31 = v8;
          v32 = v12;
          v33 = v17;
          v34 = atan2f(*(float *)&v8[5].i32[1] * (float)v26.i32[1], *(float *)v8[5].i32 * (float)v26.i32[0]);
          v21 = v55;
          result = v56;
          v19 = v57;
          v11 = v58;
          v17 = v33;
          v15 = v59;
          v12 = v32;
          v8 = v31;
          HIDWORD(a6) = 1056964608;
          *(float *)&a6 = (float)(v34 * -10430.0) + 32768.0;
          v30 = vmul_f32(*(float32x2_t *)&a6, vcvt_f32_u32(v31[3]));
          goto LABEL_8;
        case 2:
          v35 = vmul_f32(vcvt_f32_s32(v26), vmul_f32(v22, (float32x2_t)v8[5]));
          a6 = COERCE_DOUBLE(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v35, vrndm_f32(v35)), v23)));
          v30 = vmul_f32(*(float32x2_t *)&a6, vmul_f32(v24, vcvt_f32_u32(v8[3])));
          goto LABEL_8;
        case 4:
          v36 = vcvt_f32_s32(v26);
          v37 = vcvt_f32_s32((int32x2_t)v8[4]);
          v38 = vmul_f32(*(float32x2_t *)((char *)result + 84), v37);
          v39 = vmul_f32(*(float32x2_t *)((char *)result + 92), v37);
          v40 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v36, v39), (int8x8_t)v39, (int8x8_t)v36);
          a6 = COERCE_DOUBLE(vcgt_f32(v38, v40));
          v30 = (float32x2_t)vbsl_s8(*(int8x8_t *)&a6, (int8x8_t)v38, (int8x8_t)v40);
LABEL_8:
          v26 = vcvt_s32_f32(v30);
          break;
        default:
          break;
      }
      v41 = v26.i32[0];
      if (v26.i32[0] >= v19)
        v42 = v19;
      else
        v42 = v26.i32[0];
      if (v42 <= -32768)
        v42 = -32768;
      v43 = (v42 + 0x8000);
      if (v26.i32[0] <= 0x8000)
        v41 = 0x8000;
      v44 = v41 - 0x8000;
      if (v44 >= v11)
        v44 = v11;
      v45 = v26.i32[1];
      if (v26.i32[1] >= v20)
        v46 = v20;
      else
        v46 = v26.i32[1];
      if (v46 <= -32768)
        v46 = -32768;
      v47 = v46 + 0x8000;
      if (v26.i32[1] <= 0x8000)
        v45 = 0x8000;
      v48 = v45 - 0x8000;
      if (v48 >= (int)v12)
        v48 = v12;
      v49 = v9 + v10 * ((uint64_t)v48 >> 16);
      v50 = v9 + v10 * HIWORD(v47);
      v26.i8[0] = *(_BYTE *)(v49 + (v44 >> 16));
      v26.i8[4] = *(_BYTE *)(v49 + (v43 >> 16));
      v51 = vsli_n_s32(v26, (int32x2_t)vand_s8((int8x8_t)v26, (int8x8_t)0xFF000000FFLL), 8uLL);
      LOBYTE(a6) = *(_BYTE *)(v50 + (v44 >> 16));
      v52 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v51, 0x10uLL), (int8x8_t)v51);
      BYTE4(a6) = *(_BYTE *)(v50 + (v43 >> 16));
      v53 = vsli_n_s32(*(int32x2_t *)&a6, (int32x2_t)vand_s8(*(int8x8_t *)&a6, (int8x8_t)0xFF000000FFLL), 8uLL);
      v54 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v53, 0x10uLL), (int8x8_t)v53), v52), vdupq_n_s16((v48 >> 1) & 0x7F80)), v52);
      a6 = COERCE_DOUBLE(vdup_n_s16((v44 >> 1) & 0x7F80));
      *(int16x4_t *)v54.i8 = vadd_s16(*(int16x4_t *)v54.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL), *(int16x4_t *)v54.i8), *(int16x4_t *)&a6));
      v14 = v14 + v13;
      v18 += v17;
      v16 += v15;
      *a3++ = vuzp1_s8(*(int8x8_t *)v54.i8, *(int8x8_t *)v54.i8).u32[0];
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  unsigned int v6;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 52);
    v3 = *(_DWORD *)(result + 56);
    v5 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      v6 = (65793 * *(unsigned __int8 *)(v5 + (v4 >> 16))) | 0xFF000000;
      v4 += v3;
      *a3++ = v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,true,false,false,false>(int *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v6 = result[15];
    v5 = result[16];
    v8 = result[13];
    v7 = result[14];
    do
    {
      v9 = (65793 * *(unsigned __int8 *)(v3 + v4 * ((uint64_t)v6 >> 16) + (v8 >> 16))) | 0xFF000000;
      v8 += v7;
      v6 += v5;
      *a3++ = v9;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;

  if (a2)
  {
    v3 = result[14];
    v4 = result[13];
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(_QWORD *)result + 36))
      v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v7 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5)
        v8 = v5;
      v4 += v3;
      *a3++ = (65793 * *(unsigned __int8 *)(v7 + (v8 >> 16))) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      result = (int *)(v3 + v4 * ((uint64_t)v12 >> 16));
      v10 += v9;
      v8 += v7;
      *a3++ = (65793 * *((unsigned __int8 *)result + (v11 >> 16))) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v10 = *((_DWORD *)*a1 + 8);
    v9 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v39 = v13;
    v37 = v17;
    v38 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v37;
          v8 = v38;
          v13 = v39;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10)
        v35 = v10;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9)
        v36 = v9;
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = (65793 * *(unsigned __int8 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (v35 >> 16))) | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, double a6, int8x8_t a7, int8x8_t a8)
{
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int32x2_t v17;
  int v18;
  unint64_t v19;
  int8x16_t v20;

  if (a2)
  {
    v8 = result[14];
    v9 = result[15];
    v10 = *(_QWORD *)(*(_QWORD *)result + 16);
    v11 = **(_QWORD **)result;
    v12 = v9 + 0x8000;
    v13 = v9 - 0x8000;
    v14 = v11 + v10 * ((uint64_t)(v9 - 0x8000) >> 16);
    v15 = v11 + v10 * ((uint64_t)v12 >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    v16 = result[13] - 0x8000;
    v17 = vdup_n_s32(0x10101u);
    do
    {
      v18 = (v16 + 0x10000) >> 16;
      a7.i8[0] = *(_BYTE *)(v14 + (v16 >> 16));
      a7.i8[4] = *(_BYTE *)(v14 + v18);
      a8.i8[0] = *(_BYTE *)(v15 + (v16 >> 16));
      a8.i8[4] = *(_BYTE *)(v15 + v18);
      v19 = *(_QWORD *)&vmul_s32((int32x2_t)vand_s8(a7, (int8x8_t)0xFF000000FFLL), v17) | 0xFF000000FF000000;
      v20 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vmul_s32((int32x2_t)vand_s8(a8, (int8x8_t)0xFF000000FFLL), v17) | 0xFF000000FF000000), (uint8x8_t)v19), a4, 0), (uint8x8_t)v19);
      a8 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL), *(int16x4_t *)v20.i8), vdup_n_s16((v16 >> 1) & 0x7F80));
      a7 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v20.i8, (int16x4_t)a8), (int8x8_t)a4);
      *a3++ = a7.i32[0];
      v16 += v8;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,true,false,false,true>(_DWORD *result, int a2, _DWORD *a3, double a4, double a5, int8x8_t a6, int8x8_t a7)
{
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int32x2_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  int8x16_t v18;

  if (a2)
  {
    v7 = **(_QWORD **)result;
    v8 = *(_QWORD *)(*(_QWORD *)result + 16);
    v9 = result[16];
    v10 = result[14];
    v11 = result[13] - 0x8000;
    v12 = result[15] - 0x8000;
    v13 = vdup_n_s32(0x10101u);
    do
    {
      v14 = v7 + v8 * ((uint64_t)v12 >> 16);
      v15 = v7 + v8 * ((uint64_t)(v12 + 0x10000) >> 16);
      result = (_DWORD *)(v14 + (v11 >> 16));
      v16 = (v11 + 0x10000) >> 16;
      a6.i8[0] = *(_BYTE *)result;
      a6.i8[4] = *(_BYTE *)(v14 + v16);
      a7.i8[0] = *(_BYTE *)(v15 + (v11 >> 16));
      a7.i8[4] = *(_BYTE *)(v15 + v16);
      v17 = *(_QWORD *)&vmul_s32((int32x2_t)vand_s8(a6, (int8x8_t)0xFF000000FFLL), v13) | 0xFF000000FF000000;
      v18 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vmul_s32((int32x2_t)vand_s8(a7, (int8x8_t)0xFF000000FFLL), v13) | 0xFF000000FF000000), (uint8x8_t)v17), vdupq_n_s16((v12 >> 1) & 0x7F80)), (uint8x8_t)v17);
      a7 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), *(int16x4_t *)v18.i8), vdup_n_s16((v11 >> 1) & 0x7F80));
      a6 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v18.i8, (int16x4_t)a7), (int8x8_t)0xFF000000FFLL);
      *a3++ = a6.i32[0];
      v11 += v10;
      v12 += v9;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, double a6, int8x8_t a7, int8x8_t a8)
{
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int32x2_t v20;
  int v21;
  int v22;
  int v23;
  unint64_t v24;
  unint64_t v25;
  int8x16_t v26;

  if (a2)
  {
    v8 = result[14];
    v9 = result[15];
    v10 = result[13];
    v11 = *(_DWORD *)(*(_QWORD *)result + 32);
    v12 = *(_DWORD *)(*(_QWORD *)result + 36);
    v13 = *(_QWORD *)(*(_QWORD *)result + 16);
    v14 = **(_QWORD **)result;
    if (v9 >= v12 - 0x8000)
      v15 = v12 - 0x8000;
    else
      v15 = result[15];
    if (v15 <= -32768)
      v15 = -32768;
    if (v9 <= 0x8000)
      v9 = 0x8000;
    v16 = v9 - 0x8000;
    if (v16 >= v12)
      v17 = *(_DWORD *)(*(_QWORD *)result + 36);
    else
      v17 = v16;
    v18 = v14 + v13 * ((uint64_t)v17 >> 16);
    v19 = v14 + v13 * ((v15 + 0x8000) >> 16);
    a4.i32[0] = (v17 >> 1) & 0x7F80;
    v20 = vdup_n_s32(0x10101u);
    do
    {
      if (v10 >= v11 - 0x8000)
        v21 = v11 - 0x8000;
      else
        v21 = v10;
      if (v21 <= -32768)
        v21 = -32768;
      if (v10 <= 0x8000)
        v22 = 0x8000;
      else
        v22 = v10;
      v23 = v22 - 0x8000;
      if (v23 >= v11)
        v23 = v11;
      v24 = (v21 + 0x8000);
      result = (_DWORD *)(v19 + (v23 >> 16));
      a7.i8[0] = *(_BYTE *)(v18 + (v23 >> 16));
      a7.i8[4] = *(_BYTE *)(v18 + (v24 >> 16));
      a8.i8[0] = *(_BYTE *)result;
      a8.i8[4] = *(_BYTE *)(v19 + (v24 >> 16));
      v25 = *(_QWORD *)&vmul_s32((int32x2_t)vand_s8(a7, (int8x8_t)0xFF000000FFLL), v20) | 0xFF000000FF000000;
      v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vmul_s32((int32x2_t)vand_s8(a8, (int8x8_t)0xFF000000FFLL), v20) | 0xFF000000FF000000), (uint8x8_t)v25), a4, 0), (uint8x8_t)v25);
      a8 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v23 >> 1) & 0x7F80));
      a7 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v26.i8, (int16x4_t)a8), (int8x8_t)a4);
      v10 += v8;
      *a3++ = a7.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, int8x8_t a6, int8x8_t a7)
{
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int32x2_t v15;
  int v16;
  int v17;
  int v18;
  unint64_t v19;
  int v20;
  int v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  int8x16_t v27;

  if (a2)
  {
    v7 = **(_QWORD **)result;
    v8 = *(_QWORD *)(*(_QWORD *)result + 16);
    v9 = *(_DWORD *)(*(_QWORD *)result + 32);
    v10 = *(_DWORD *)(*(_QWORD *)result + 36);
    v12 = *(_DWORD *)(result + 60);
    v11 = *(_DWORD *)(result + 64);
    v14 = *(_DWORD *)(result + 52);
    v13 = *(_DWORD *)(result + 56);
    result = 4294934528;
    v15 = vdup_n_s32(0x10101u);
    do
    {
      if (v14 >= v9 - 0x8000)
        v16 = v9 - 0x8000;
      else
        v16 = v14;
      if (v16 <= -32768)
        v16 = -32768;
      if (v14 <= 0x8000)
        v17 = 0x8000;
      else
        v17 = v14;
      v18 = v17 - 0x8000;
      if (v18 >= v9)
        v18 = v9;
      v19 = (v16 + 0x8000);
      if (v12 >= v10 - 0x8000)
        v20 = v10 - 0x8000;
      else
        v20 = v12;
      if (v20 <= -32768)
        v20 = -32768;
      if (v12 <= 0x8000)
        v21 = 0x8000;
      else
        v21 = v12;
      v22 = v20 + 0x8000;
      v23 = v21 - 0x8000;
      if (v23 >= v10)
        v23 = v10;
      v24 = v7 + v8 * ((uint64_t)v23 >> 16);
      v25 = v7 + v8 * HIWORD(v22);
      a6.i8[0] = *(_BYTE *)(v24 + (v18 >> 16));
      a7.i8[0] = *(_BYTE *)(v25 + (v18 >> 16));
      a6.i8[4] = *(_BYTE *)(v24 + (v19 >> 16));
      a7.i8[4] = *(_BYTE *)(v25 + (v19 >> 16));
      v26 = *(_QWORD *)&vmul_s32((int32x2_t)vand_s8(a6, (int8x8_t)0xFF000000FFLL), v15) | 0xFF000000FF000000;
      v27 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vmul_s32((int32x2_t)vand_s8(a7, (int8x8_t)0xFF000000FFLL), v15) | 0xFF000000FF000000), (uint8x8_t)v26), vdupq_n_s16((v23 >> 1) & 0x7F80)), (uint8x8_t)v26);
      a7 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), *(int16x4_t *)v27.i8), vdup_n_s16((v18 >> 1) & 0x7F80));
      a6 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v27.i8, (int16x4_t)a7), (int8x8_t)0xFF000000FFLL);
      v14 += v13;
      v12 += v11;
      *a3++ = a6.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::L8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  int32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  uint32x2_t *v29;
  uint64_t v30;
  uint64_t v31;
  float v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  int v39;
  int v40;
  unint64_t v41;
  int v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  int8x16_t v50;
  int v51;
  uint64_t **v52;
  int v53;
  int v54;
  int v55;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = *((unsigned __int8 *)result + 48) - 1;
    v19 = vdup_n_s32(0x10101u);
    v20 = (float32x2_t)vdup_n_s32(0x37800000u);
    v21 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v22 = (float32x2_t)vdup_n_s32(0x47800000u);
    v54 = v8;
    v55 = v12;
    v53 = v8 - 0x8000;
    v51 = v18;
    v52 = result;
    do
    {
      v23.f32[0] = (float)(1.0 / v11) * (float)v15;
      v23.f32[1] = (float)(1.0 / v11) * (float)v13;
      v24 = vcvt_s32_f32(v23);
      switch(v18)
      {
        case 0:
          v25 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v24));
          v26 = vmul_f32(v25, v25);
          v27 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v26, 1), v26);
          v26.f32[0] = fmaxf(vaddv_f32(v26), 0.00001);
          v26.i32[0] = vmul_f32(v27, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v26, 0))).u32[0];
          v23 = vcvt_f32_u32(v5[3]);
          v26.i32[1] = 0.5;
          v28 = vmul_f32(v26, v23);
          goto LABEL_8;
        case 1:
          v29 = v5;
          v30 = v9;
          v31 = v14;
          v32 = atan2f(*(float *)&v5[5].i32[1] * (float)v24.i32[1], *(float *)v5[5].i32 * (float)v24.i32[0]);
          v18 = v51;
          result = v52;
          v16 = v53;
          v8 = v54;
          v14 = v31;
          v12 = v55;
          v9 = v30;
          v5 = v29;
          v23 = vcvt_f32_u32(v29[3]);
          v33.i32[1] = 1056964608;
          v33.f32[0] = (float)(v32 * -10430.0) + 32768.0;
          v28 = vmul_f32(v33, v23);
          goto LABEL_8;
        case 2:
          v34 = vmul_f32(vcvt_f32_s32(v24), vmul_f32(v20, (float32x2_t)v5[5]));
          v23 = *(float32x2_t *)((char *)result + 84);
          v28 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), v23, vminnm_f32(vsub_f32(v34, vrndm_f32(v34)), v21)), vmul_f32(v22, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v35 = vcvt_f32_s32(v24);
          v36 = vcvt_f32_s32((int32x2_t)v5[4]);
          v23 = vmul_f32(*(float32x2_t *)((char *)result + 84), v36);
          v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v36);
          v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v37), (int8x8_t)v37, (int8x8_t)v35);
          v28 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v23, v38), (int8x8_t)v23, (int8x8_t)v38);
LABEL_8:
          v24 = vcvt_s32_f32(v28);
          break;
        default:
          break;
      }
      v39 = v24.i32[0];
      if (v24.i32[0] >= v16)
        v40 = v16;
      else
        v40 = v24.i32[0];
      if (v40 <= -32768)
        v40 = -32768;
      v41 = (v40 + 0x8000);
      if (v24.i32[0] <= 0x8000)
        v39 = 0x8000;
      v42 = v39 - 0x8000;
      if (v42 >= v8)
        v42 = v8;
      v43 = v24.i32[1];
      if (v24.i32[1] >= v17)
        v44 = v17;
      else
        v44 = v24.i32[1];
      if (v44 <= -32768)
        v44 = -32768;
      v45 = v44 + 0x8000;
      if (v24.i32[1] <= 0x8000)
        v43 = 0x8000;
      v46 = v43 - 0x8000;
      if (v46 >= (int)v9)
        v46 = v9;
      v47 = v6 + v7 * ((uint64_t)v46 >> 16);
      v48 = v6 + v7 * HIWORD(v45);
      v24.i8[0] = *(_BYTE *)(v47 + (v42 >> 16));
      v24.i8[4] = *(_BYTE *)(v47 + (v41 >> 16));
      v23.i8[0] = *(_BYTE *)(v48 + (v42 >> 16));
      v23.i8[4] = *(_BYTE *)(v48 + (v41 >> 16));
      v49 = *(_QWORD *)&vmul_s32((int32x2_t)vand_s8((int8x8_t)v24, (int8x8_t)0xFF000000FFLL), v19) | 0xFF000000FF000000;
      v50 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vmul_s32((int32x2_t)vand_s8((int8x8_t)v23, (int8x8_t)0xFF000000FFLL), v19) | 0xFF000000FF000000), (uint8x8_t)v49), vdupq_n_s16((v46 >> 1) & 0x7F80)), (uint8x8_t)v49);
      *(int16x4_t *)v50.i8 = vadd_s16(*(int16x4_t *)v50.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL), *(int16x4_t *)v50.i8), vdup_n_s16((v42 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v50.i8, *(int8x8_t *)v50.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,false,false,false,false>(uint64_t result, int a2, _DWORD *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  unint64_t v6;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 52);
    v3 = *(_DWORD *)(result + 56);
    v5 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      HIDWORD(v6) = bswap32(*(_DWORD *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      LODWORD(v6) = HIDWORD(v6);
      v4 += v3;
      *a3++ = v6 >> 8;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,true,false,false,false>(_DWORD *result, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unint64_t v9;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v6 = result[15];
    v5 = result[16];
    v8 = result[13];
    v7 = result[14];
    do
    {
      HIDWORD(v9) = bswap32(*(_DWORD *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      LODWORD(v9) = HIDWORD(v9);
      v8 += v7;
      v6 += v5;
      *a3++ = v9 >> 8;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,false,true,false,false>(_DWORD *result, int a2, _DWORD *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  unint64_t v9;

  if (a2)
  {
    v3 = result[14];
    v4 = result[13];
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(_QWORD *)result + 36))
      v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v7 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5)
        v8 = v5;
      HIDWORD(v9) = bswap32(*(_DWORD *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      LODWORD(v9) = HIDWORD(v9);
      v4 += v3;
      *a3++ = v9 >> 8;
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,true,true,false,false>(int *result, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unint64_t v13;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      HIDWORD(v13) = bswap32(*(_DWORD *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      LODWORD(v13) = HIDWORD(v13);
      v10 += v9;
      v8 += v7;
      *a3++ = v13 >> 8;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, _DWORD *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  __int32 v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  __int32 v35;
  int v36;
  unint64_t v37;
  __int32 v38;
  int v39;
  uint64_t v40;
  int v41;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v41 = v13;
    v39 = v17;
    v40 = v8;
    v38 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v39;
          v8 = v40;
          v13 = v41;
          v9 = v38;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      HIDWORD(v37) = bswap32(*(_DWORD *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      LODWORD(v37) = HIDWORD(v37);
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = v37 >> 8;
      --v4;
    }
    while (v4);
  }
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  unsigned int v15;
  unint64_t v16;
  unsigned int v17;
  uint8x8_t v18;
  int8x16_t v19;

  if (a2)
  {
    v4 = result[14];
    v5 = result[15];
    v6 = *(_QWORD *)(*(_QWORD *)result + 16);
    v7 = **(_QWORD **)result;
    v8 = v5 + 0x8000;
    v9 = v5 - 0x8000;
    v10 = v7 + v6 * ((uint64_t)(v5 - 0x8000) >> 16);
    v11 = v7 + v6 * ((uint64_t)v8 >> 16);
    a4.i32[0] = (v9 >> 1) & 0x7F80;
    v12 = result[13] - 0x8000;
    do
    {
      v13 = ((uint64_t)v12 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v14 = ((uint64_t)(v12 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      HIDWORD(v16) = bswap32(*(_DWORD *)(v10 + v13));
      LODWORD(v16) = HIDWORD(v16);
      v15 = v16 >> 8;
      HIDWORD(v16) = bswap32(*(_DWORD *)(v11 + v13));
      LODWORD(v16) = HIDWORD(v16);
      LODWORD(v13) = v16 >> 8;
      HIDWORD(v16) = bswap32(*(_DWORD *)(v10 + v14));
      LODWORD(v16) = HIDWORD(v16);
      v17 = v16 >> 8;
      HIDWORD(v16) = bswap32(*(_DWORD *)(v11 + v14));
      LODWORD(v16) = HIDWORD(v16);
      v18.i32[0] = v13;
      v18.i32[1] = v16 >> 8;
      v19 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8(v18, (uint8x8_t)__PAIR64__(v17, v15)), a4, 0), (uint8x8_t)__PAIR64__(v17, v15));
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v19.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL), *(int16x4_t *)v19.i8), vdup_n_s16((v12 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      v12 += v4;
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int v12;
  unint64_t v13;
  uint64_t v14;
  uint8x8_t v15;
  int8x16_t v16;
  int8x8_t result;

  if (a2)
  {
    v3 = **(_QWORD **)a1;
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v5 = a1[16];
    v6 = a1[14];
    v7 = a1[13] - 0x8000;
    v8 = a1[15] - 0x8000;
    do
    {
      v9 = v3 + v4 * ((uint64_t)v8 >> 16);
      v10 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v11 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      HIDWORD(v13) = bswap32(*(_DWORD *)(v9 + v10));
      LODWORD(v13) = HIDWORD(v13);
      v12 = v13 >> 8;
      v14 = v3 + v4 * ((uint64_t)(v8 + 0x10000) >> 16);
      HIDWORD(v13) = bswap32(*(_DWORD *)(v14 + v10));
      LODWORD(v13) = HIDWORD(v13);
      LODWORD(v10) = v13 >> 8;
      LODWORD(v9) = bswap32(*(_DWORD *)(v9 + v11));
      LODWORD(v11) = bswap32(*(_DWORD *)(v14 + v11));
      HIDWORD(v13) = v9;
      LODWORD(v13) = v9;
      LODWORD(v14) = v13 >> 8;
      HIDWORD(v13) = v11;
      LODWORD(v13) = v11;
      v15.i32[0] = v10;
      v15.i32[1] = v13 >> 8;
      v16 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v15, (uint8x8_t)__PAIR64__(v14, v12)), vdupq_n_s16((v8 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v14, v12));
      *(int16x4_t *)v16.i8 = vadd_s16(*(int16x4_t *)v16.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), *(int16x4_t *)v16.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v16.i8, *(int8x8_t *)v16.i8);
      *a3++ = result.i32[0];
      v7 += v6;
      v8 += v5;
      --a2;
    }
    while (a2);
  }
  return result;
}

unint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,false,true,false,true>(unint64_t result, int a2, _DWORD *a3, int16x4_t a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unint64_t v23;
  unsigned int v24;
  uint8x8_t v25;
  int8x16_t v26;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 56);
    v5 = *(_DWORD *)(result + 60);
    v6 = *(_DWORD *)(result + 52);
    v7 = *(_DWORD *)(*(_QWORD *)result + 32);
    v8 = *(_DWORD *)(*(_QWORD *)result + 36);
    v9 = *(_QWORD *)(*(_QWORD *)result + 16);
    v10 = **(_QWORD **)result;
    if (v5 >= v8 - 0x8000)
      v11 = v8 - 0x8000;
    else
      v11 = *(_DWORD *)(result + 60);
    if (v11 <= -32768)
      v11 = -32768;
    if (v5 <= 0x8000)
      v5 = 0x8000;
    v12 = v5 - 0x8000;
    if (v12 >= v8)
      v13 = *(_DWORD *)(*(_QWORD *)result + 36);
    else
      v13 = v12;
    v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    v15 = v10 + v9 * ((v11 + 0x8000) >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    do
    {
      if (v6 >= v7 - 0x8000)
        v16 = v7 - 0x8000;
      else
        v16 = v6;
      if (v16 <= -32768)
        v16 = -32768;
      v17 = v16 + 0x8000;
      if (v6 <= 0x8000)
        v18 = 0x8000;
      else
        v18 = v6;
      v19 = v18 - 0x8000;
      if (v19 >= v7)
        v19 = v7;
      v20 = ((uint64_t)v19 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v21 = (v17 >> 14) & 0x3FFFC;
      HIDWORD(v23) = bswap32(*(_DWORD *)(v14 + v21));
      LODWORD(v23) = HIDWORD(v23);
      v22 = v23 >> 8;
      HIDWORD(v23) = bswap32(*(_DWORD *)(v14 + v20));
      LODWORD(v23) = HIDWORD(v23);
      v24 = v23 >> 8;
      HIDWORD(v23) = bswap32(*(_DWORD *)(v15 + v20));
      LODWORD(v23) = HIDWORD(v23);
      result = (v23 >> 8);
      HIDWORD(v23) = bswap32(*(_DWORD *)(v15 + v21));
      LODWORD(v23) = HIDWORD(v23);
      v25.i32[0] = result;
      v25.i32[1] = v23 >> 8;
      v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8(v25, (uint8x8_t)__PAIR64__(v22, v24)), a4, 0), (uint8x8_t)__PAIR64__(v22, v24));
      v6 += v4;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v26.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v19 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unint64_t v24;
  unsigned int v25;
  uint8x8_t v26;
  int8x16_t v27;
  int8x8_t result;

  if (a2)
  {
    v3 = **(_QWORD **)a1;
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v5 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v6 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v8 = a1[15];
    v7 = a1[16];
    v10 = a1[13];
    v9 = a1[14];
    do
    {
      if (v10 >= v5 - 0x8000)
        v11 = v5 - 0x8000;
      else
        v11 = v10;
      if (v11 <= -32768)
        v11 = -32768;
      v12 = v11 + 0x8000;
      if (v10 <= 0x8000)
        v13 = 0x8000;
      else
        v13 = v10;
      v14 = v13 - 0x8000;
      if (v14 >= v5)
        v14 = v5;
      if (v8 >= v6 - 0x8000)
        v15 = v6 - 0x8000;
      else
        v15 = v8;
      if (v15 <= -32768)
        v15 = -32768;
      v16 = v15 + 0x8000;
      if (v8 <= 0x8000)
        v17 = 0x8000;
      else
        v17 = v8;
      v18 = v17 - 0x8000;
      if (v18 >= v6)
        v18 = v6;
      v19 = v3 + v4 * ((uint64_t)v18 >> 16);
      v20 = v3 + v4 * HIWORD(v16);
      v21 = ((uint64_t)v14 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v22 = (v12 >> 14) & 0x3FFFC;
      v23 = bswap32(*(_DWORD *)(v19 + v21));
      HIDWORD(v24) = bswap32(*(_DWORD *)(v20 + v21));
      LODWORD(v24) = HIDWORD(v24);
      LODWORD(v21) = v24 >> 8;
      HIDWORD(v24) = v23;
      LODWORD(v24) = v23;
      v25 = v24 >> 8;
      LODWORD(v19) = bswap32(*(_DWORD *)(v19 + v22));
      LODWORD(v22) = bswap32(*(_DWORD *)(v20 + v22));
      HIDWORD(v24) = v19;
      LODWORD(v24) = v19;
      LODWORD(v20) = v24 >> 8;
      HIDWORD(v24) = v22;
      LODWORD(v24) = v22;
      v26.i32[0] = v21;
      v26.i32[1] = v24 >> 8;
      v27 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v26, (uint8x8_t)__PAIR64__(v20, v25)), vdupq_n_s16((v18 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v20, v25));
      *(int16x4_t *)v27.i8 = vadd_s16(*(int16x4_t *)v27.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), *(int16x4_t *)v27.i8), vdup_n_s16((v14 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v27.i8, *(int8x8_t *)v27.i8);
      v10 += v9;
      v8 += v7;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  uint32x2_t *v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  unint64_t v48;
  unsigned int v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint8x8_t v53;
  int8x16_t v54;
  int v55;
  uint64_t **v56;
  int v57;
  int v58;
  int v59;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = *((unsigned __int8 *)result + 48) - 1;
    v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    v58 = v8;
    v59 = v12;
    v57 = v8 - 0x8000;
    v55 = v18;
    v56 = result;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          v24 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v23));
          v25 = vmul_f32(v24, v24);
          v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          v27 = vmul_f32(v25, vcvt_f32_u32(v5[3]));
          goto LABEL_8;
        case 1:
          v28 = v5;
          v29 = v9;
          v30 = v14;
          v31 = atan2f(*(float *)&v5[5].i32[1] * (float)v23.i32[1], *(float *)v5[5].i32 * (float)v23.i32[0]);
          v18 = v55;
          result = v56;
          v16 = v57;
          v8 = v58;
          v14 = v30;
          v12 = v59;
          v9 = v29;
          v5 = v28;
          v32.i32[1] = 1056964608;
          v32.f32[0] = (float)(v31 * -10430.0) + 32768.0;
          v27 = vmul_f32(v32, vcvt_f32_u32(v28[3]));
          goto LABEL_8;
        case 2:
          v33 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, (float32x2_t)v5[5]));
          v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v33, vrndm_f32(v33)), v20)), vmul_f32(v21, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v34 = vcvt_f32_s32(v23);
          v35 = vcvt_f32_s32((int32x2_t)v5[4]);
          v36 = vmul_f32(*(float32x2_t *)((char *)result + 84), v35);
          v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v35);
          v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v34, v37), (int8x8_t)v37, (int8x8_t)v34);
          v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v36, v38), (int8x8_t)v36, (int8x8_t)v38);
LABEL_8:
          v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      v39 = v23.i32[0];
      if (v23.i32[0] >= v16)
        v40 = v16;
      else
        v40 = v23.i32[0];
      if (v40 <= -32768)
        v40 = -32768;
      v41 = v40 + 0x8000;
      if (v23.i32[0] <= 0x8000)
        v39 = 0x8000;
      v42 = v39 - 0x8000;
      if (v42 >= v8)
        v42 = v8;
      v43 = v23.i32[1];
      if (v23.i32[1] >= v17)
        v44 = v17;
      else
        v44 = v23.i32[1];
      if (v44 <= -32768)
        v44 = -32768;
      v45 = v44 + 0x8000;
      if (v23.i32[1] <= 0x8000)
        v43 = 0x8000;
      v46 = v43 - 0x8000;
      if (v46 >= (int)v9)
        v46 = v9;
      v47 = v6 + v7 * ((uint64_t)v46 >> 16);
      v48 = ((uint64_t)v42 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      HIDWORD(v50) = bswap32(*(_DWORD *)(v47 + v48));
      LODWORD(v50) = HIDWORD(v50);
      v49 = v50 >> 8;
      v51 = (v41 >> 14) & 0x3FFFC;
      HIDWORD(v50) = bswap32(*(_DWORD *)(v47 + v51));
      LODWORD(v50) = HIDWORD(v50);
      LODWORD(v47) = v50 >> 8;
      v52 = v6 + v7 * HIWORD(v45);
      HIDWORD(v50) = bswap32(*(_DWORD *)(v52 + v48));
      LODWORD(v50) = HIDWORD(v50);
      LODWORD(v48) = v50 >> 8;
      HIDWORD(v50) = bswap32(*(_DWORD *)(v52 + v51));
      LODWORD(v50) = HIDWORD(v50);
      v53.i32[0] = v48;
      v53.i32[1] = v50 >> 8;
      v54 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v53, (uint8x8_t)__PAIR64__(v47, v49)), vdupq_n_s16((v46 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v47, v49));
      *(int16x4_t *)v54.i8 = vadd_s16(*(int16x4_t *)v54.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL), *(int16x4_t *)v54.i8), vdup_n_s16((v42 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v54.i8, *(int8x8_t *)v54.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  unsigned int v6;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 52);
    v3 = *(_DWORD *)(result + 56);
    v5 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      v6 = bswap32(*(_DWORD *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      v4 += v3;
      *a3++ = (v6 >> 8) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v6 = result[15];
    v5 = result[16];
    v8 = result[13];
    v7 = result[14];
    do
    {
      v9 = bswap32(*(_DWORD *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL)));
      v8 += v7;
      v6 += v5;
      *a3++ = (v9 >> 8) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;

  if (a2)
  {
    v3 = result[14];
    v4 = result[13];
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(_QWORD *)result + 36))
      v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v7 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5)
        v8 = v5;
      v4 += v3;
      *a3++ = (bswap32(*(_DWORD *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL))) >> 8) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      v10 += v9;
      v8 += v7;
      *a3++ = (bswap32(*(_DWORD *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL))) >> 8) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  __int32 v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  __int32 v35;
  int v36;
  __int32 v37;
  int v38;
  uint64_t v39;
  int v40;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v40 = v13;
    v38 = v17;
    v39 = v8;
    v37 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v38;
          v8 = v39;
          v13 = v40;
          v9 = v37;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = (bswap32(*(_DWORD *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL))) >> 8) | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  int8x8_t v15;
  int8x8_t v16;
  unint64_t v17;
  int8x16_t v18;

  if (a2)
  {
    v4 = result[14];
    v5 = result[15];
    v6 = *(_QWORD *)(*(_QWORD *)result + 16);
    v7 = **(_QWORD **)result;
    v8 = v5 + 0x8000;
    v9 = v5 - 0x8000;
    v10 = v7 + v6 * ((uint64_t)(v5 - 0x8000) >> 16);
    v11 = v7 + v6 * ((uint64_t)v8 >> 16);
    a4.i32[0] = (v9 >> 1) & 0x7F80;
    v12 = result[13] - 0x8000;
    do
    {
      v13 = ((uint64_t)v12 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v14 = ((uint64_t)(v12 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v15.i32[0] = *(_DWORD *)(v10 + v13);
      v15.i32[1] = *(_DWORD *)(v10 + v14);
      v16.i32[0] = *(_DWORD *)(v11 + v13);
      v16.i32[1] = *(_DWORD *)(v11 + v14);
      v17 = *(_QWORD *)&vshr_n_u32((uint32x2_t)vrev32_s8(v15), 8uLL) | 0xFF000000FF000000;
      v18 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vshr_n_u32((uint32x2_t)vrev32_s8(v16), 8uLL) | 0xFF000000FF000000), (uint8x8_t)v17), a4, 0), (uint8x8_t)v17);
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v18.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), *(int16x4_t *)v18.i8), vdup_n_s16((v12 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      v12 += v4;
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  int8x8_t v13;
  int8x8_t v14;
  unint64_t v15;
  int8x16_t v16;
  int8x8_t result;

  if (a2)
  {
    v3 = **(_QWORD **)a1;
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v5 = a1[16];
    v6 = a1[14];
    v7 = a1[13] - 0x8000;
    v8 = a1[15] - 0x8000;
    do
    {
      v9 = v3 + v4 * ((uint64_t)v8 >> 16);
      v10 = v3 + v4 * ((uint64_t)(v8 + 0x10000) >> 16);
      v11 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v12 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v13.i32[0] = *(_DWORD *)(v9 + v11);
      v13.i32[1] = *(_DWORD *)(v9 + v12);
      v14.i32[0] = *(_DWORD *)(v10 + v11);
      v14.i32[1] = *(_DWORD *)(v10 + v12);
      v15 = *(_QWORD *)&vshr_n_u32((uint32x2_t)vrev32_s8(v13), 8uLL) | 0xFF000000FF000000;
      v16 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vshr_n_u32((uint32x2_t)vrev32_s8(v14), 8uLL) | 0xFF000000FF000000), (uint8x8_t)v15), vdupq_n_s16((v8 >> 1) & 0x7F80)), (uint8x8_t)v15);
      *(int16x4_t *)v16.i8 = vadd_s16(*(int16x4_t *)v16.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), *(int16x4_t *)v16.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v16.i8, *(int8x8_t *)v16.i8);
      *a3++ = result.i32[0];
      v7 += v6;
      v8 += v5;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  int8x8_t v21;
  int8x8_t v22;
  unint64_t v23;
  int8x16_t v24;

  if (a2)
  {
    v4 = result[14];
    v5 = result[15];
    v6 = result[13];
    v7 = *(_DWORD *)(*(_QWORD *)result + 32);
    v8 = *(_DWORD *)(*(_QWORD *)result + 36);
    v9 = *(_QWORD *)(*(_QWORD *)result + 16);
    v10 = **(_QWORD **)result;
    if (v5 >= v8 - 0x8000)
      v11 = v8 - 0x8000;
    else
      v11 = result[15];
    if (v11 <= -32768)
      v11 = -32768;
    if (v5 <= 0x8000)
      v5 = 0x8000;
    v12 = v5 - 0x8000;
    if (v12 >= v8)
      v13 = *(_DWORD *)(*(_QWORD *)result + 36);
    else
      v13 = v12;
    v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    v15 = v10 + v9 * ((v11 + 0x8000) >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    do
    {
      if (v6 >= v7 - 0x8000)
        v16 = v7 - 0x8000;
      else
        v16 = v6;
      if (v16 <= -32768)
        v16 = -32768;
      v17 = v16 + 0x8000;
      if (v6 <= 0x8000)
        v18 = 0x8000;
      else
        v18 = v6;
      v19 = v18 - 0x8000;
      if (v19 >= v7)
        v19 = v7;
      result = (_DWORD *)(((uint64_t)v19 >> 14) & 0xFFFFFFFFFFFFFFFCLL);
      v20 = (v17 >> 14) & 0x3FFFC;
      v21.i32[0] = *(_DWORD *)((char *)result + v14);
      v21.i32[1] = *(_DWORD *)(v14 + v20);
      v22.i32[0] = *(_DWORD *)((char *)result + v15);
      v22.i32[1] = *(_DWORD *)(v15 + v20);
      v23 = *(_QWORD *)&vshr_n_u32((uint32x2_t)vrev32_s8(v21), 8uLL) | 0xFF000000FF000000;
      v24 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vshr_n_u32((uint32x2_t)vrev32_s8(v22), 8uLL) | 0xFF000000FF000000), (uint8x8_t)v23), a4, 0), (uint8x8_t)v23);
      v6 += v4;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v24.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL), *(int16x4_t *)v24.i8), vdup_n_s16((v19 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  int8x8_t v22;
  int8x8_t v23;
  unint64_t v24;
  int8x16_t v25;
  int8x8_t result;

  if (a2)
  {
    v3 = **(_QWORD **)a1;
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v5 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v6 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v8 = a1[15];
    v7 = a1[16];
    v10 = a1[13];
    v9 = a1[14];
    do
    {
      if (v10 >= v5 - 0x8000)
        v11 = v5 - 0x8000;
      else
        v11 = v10;
      if (v11 <= -32768)
        v11 = -32768;
      if (v10 <= 0x8000)
        v12 = 0x8000;
      else
        v12 = v10;
      v13 = v12 - 0x8000;
      if (v13 >= v5)
        v13 = v5;
      if (v8 >= v6 - 0x8000)
        v14 = v6 - 0x8000;
      else
        v14 = v8;
      if (v14 <= -32768)
        v14 = -32768;
      if (v8 <= 0x8000)
        v15 = 0x8000;
      else
        v15 = v8;
      v16 = v15 - 0x8000;
      v17 = v14 + 0x8000;
      if (v16 >= v6)
        v16 = v6;
      v18 = v3 + v4 * ((uint64_t)v16 >> 16);
      v19 = v3 + v4 * HIWORD(v17);
      v20 = ((uint64_t)v13 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v21 = ((v11 + 0x8000) >> 14) & 0x3FFFC;
      v22.i32[0] = *(_DWORD *)(v18 + v20);
      v23.i32[0] = *(_DWORD *)(v19 + v20);
      v22.i32[1] = *(_DWORD *)(v18 + v21);
      v23.i32[1] = *(_DWORD *)(v19 + v21);
      v24 = *(_QWORD *)&vshr_n_u32((uint32x2_t)vrev32_s8(v22), 8uLL) | 0xFF000000FF000000;
      v25 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vshr_n_u32((uint32x2_t)vrev32_s8(v23), 8uLL) | 0xFF000000FF000000), (uint8x8_t)v24), vdupq_n_s16((v16 >> 1) & 0x7F80)), (uint8x8_t)v24);
      *(int16x4_t *)v25.i8 = vadd_s16(*(int16x4_t *)v25.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL), *(int16x4_t *)v25.i8), vdup_n_s16((v13 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v25.i8, *(int8x8_t *)v25.i8);
      v10 += v9;
      v8 += v7;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  uint32x2_t *v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  int8x8_t v51;
  int8x8_t v52;
  unint64_t v53;
  int8x16_t v54;
  int v55;
  uint64_t **v56;
  int v57;
  int v58;
  int v59;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = *((unsigned __int8 *)result + 48) - 1;
    v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    v58 = v8;
    v59 = v12;
    v57 = v8 - 0x8000;
    v55 = v18;
    v56 = result;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          v24 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v23));
          v25 = vmul_f32(v24, v24);
          v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          v27 = vmul_f32(v25, vcvt_f32_u32(v5[3]));
          goto LABEL_8;
        case 1:
          v28 = v5;
          v29 = v9;
          v30 = v14;
          v31 = atan2f(*(float *)&v5[5].i32[1] * (float)v23.i32[1], *(float *)v5[5].i32 * (float)v23.i32[0]);
          v18 = v55;
          result = v56;
          v16 = v57;
          v8 = v58;
          v14 = v30;
          v12 = v59;
          v9 = v29;
          v5 = v28;
          v32.i32[1] = 1056964608;
          v32.f32[0] = (float)(v31 * -10430.0) + 32768.0;
          v27 = vmul_f32(v32, vcvt_f32_u32(v28[3]));
          goto LABEL_8;
        case 2:
          v33 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, (float32x2_t)v5[5]));
          v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v33, vrndm_f32(v33)), v20)), vmul_f32(v21, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v34 = vcvt_f32_s32(v23);
          v35 = vcvt_f32_s32((int32x2_t)v5[4]);
          v36 = vmul_f32(*(float32x2_t *)((char *)result + 84), v35);
          v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v35);
          v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v34, v37), (int8x8_t)v37, (int8x8_t)v34);
          v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v36, v38), (int8x8_t)v36, (int8x8_t)v38);
LABEL_8:
          v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      v39 = v23.i32[0];
      if (v23.i32[0] >= v16)
        v40 = v16;
      else
        v40 = v23.i32[0];
      if (v40 <= -32768)
        v40 = -32768;
      v41 = v40 + 0x8000;
      if (v23.i32[0] <= 0x8000)
        v39 = 0x8000;
      v42 = v39 - 0x8000;
      if (v42 >= v8)
        v42 = v8;
      v43 = v23.i32[1];
      if (v23.i32[1] >= v17)
        v44 = v17;
      else
        v44 = v23.i32[1];
      if (v44 <= -32768)
        v44 = -32768;
      v45 = v44 + 0x8000;
      if (v23.i32[1] <= 0x8000)
        v43 = 0x8000;
      v46 = v43 - 0x8000;
      if (v46 >= (int)v9)
        v46 = v9;
      v47 = v6 + v7 * ((uint64_t)v46 >> 16);
      v48 = v6 + v7 * HIWORD(v45);
      v49 = ((uint64_t)v42 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v50 = (v41 >> 14) & 0x3FFFC;
      v51.i32[0] = *(_DWORD *)(v47 + v49);
      v51.i32[1] = *(_DWORD *)(v47 + v50);
      v52.i32[0] = *(_DWORD *)(v48 + v49);
      v52.i32[1] = *(_DWORD *)(v48 + v50);
      v53 = *(_QWORD *)&vshr_n_u32((uint32x2_t)vrev32_s8(v51), 8uLL) | 0xFF000000FF000000;
      v54 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vshr_n_u32((uint32x2_t)vrev32_s8(v52), 8uLL) | 0xFF000000FF000000), (uint8x8_t)v53), vdupq_n_s16((v46 >> 1) & 0x7F80)), (uint8x8_t)v53);
      *(int16x4_t *)v54.i8 = vadd_s16(*(int16x4_t *)v54.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL), *(int16x4_t *)v54.i8), vdup_n_s16((v42 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v54.i8, *(int8x8_t *)v54.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBAh,unsigned int,true,true,false,false>(int *a1, int a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (unsigned __int8 *)a3;
    v4 = a2;
    v5 = **(_QWORD **)a1;
    v6 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v7 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v8 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v10 = a1[15];
    v9 = a1[16];
    v12 = a1[13];
    v11 = a1[14];
    do
    {
      --v4;
      v15 = 0;
      v13 = v12 & ~(v12 >> 31);
      if (v13 >= v7)
        v13 = v7;
      v14 = v10 & ~(v10 >> 31);
      if (v14 >= v8)
        v14 = v8;
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)&v15, (unsigned int *)(v5 + v6 * ((uint64_t)v14 >> 16) + (int)((v13 >> 13) & 0xFFFFFFF8)), a3);
      v12 += v11;
      v10 += v9;
      *(_DWORD *)v3 = v15;
      v3 += 4;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBAh,unsigned int,true,true,true,false>(uint64_t **a1, int a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v4;
  float *v5;
  int v6;
  int v7;
  float v8;
  float v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  int32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  int v32;
  int v33;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (unsigned __int8 *)a3;
    v4 = a2;
    v5 = (float *)*a1;
    v35 = (*a1)[2];
    v36 = **a1;
    v6 = *((_DWORD *)*a1 + 8);
    v7 = *((_DWORD *)*a1 + 9);
    v8 = *((float *)a1[3] + 3);
    v9 = *((float *)a1[2] + 3);
    v11 = *((_DWORD *)a1 + 15);
    v10 = *((_DWORD *)a1 + 16);
    v13 = *((_DWORD *)a1 + 13);
    v12 = *((_DWORD *)a1 + 14);
    v14 = *((unsigned __int8 *)a1 + 48) - 1;
    v15 = (float32x2_t)vdup_n_s32(0x37800000u);
    v16 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v17 = (float32x2_t)vdup_n_s32(0x47800000u);
    do
    {
      v37 = 0;
      v18.f32[0] = (float)(1.0 / v9) * (float)v13;
      v18.f32[1] = (float)(1.0 / v9) * (float)v11;
      v19 = vcvt_s32_f32(v18);
      switch(v14)
      {
        case 0:
          v20 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v19));
          v21 = vmul_f32(v20, v20);
          v22 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 1), v21);
          v21.f32[0] = fmaxf(vaddv_f32(v21), 0.00001);
          v21.i32[0] = vmul_f32(v22, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 0))).u32[0];
          v21.i32[1] = 0.5;
          v23 = vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          v24 = atan2f(v5[11] * (float)v19.i32[1], v5[10] * (float)v19.i32[0]);
          v25.i32[1] = 1056964608;
          v25.f32[0] = (float)(v24 * -10430.0) + 32768.0;
          v23 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          v26 = vmul_f32(vcvt_f32_s32(v19), vmul_f32(v15, *(float32x2_t *)(v5 + 10)));
          v23 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v26, vrndm_f32(v26)), v16)), vmul_f32(v17, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          v27 = vcvt_f32_s32(v19);
          v28 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          v29 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v28);
          v30 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v28);
          v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, v30), (int8x8_t)v30, (int8x8_t)v27);
          v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29, v31), (int8x8_t)v29, (int8x8_t)v31);
LABEL_8:
          v19 = vcvt_s32_f32(v23);
          break;
        default:
          break;
      }
      --v4;
      v32 = v19.i32[0] & ~(v19.i32[0] >> 31);
      if (v32 >= v6)
        v32 = v6;
      v33 = v19.i32[1] & ~(v19.i32[1] >> 31);
      if (v33 >= v7)
        v33 = v7;
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)&v37, (unsigned int *)(v36 + v35 * ((uint64_t)v33 >> 16) + (int)((v32 >> 13) & 0xFFFFFFF8)), a3);
      v9 = v9 + v8;
      v13 += v12;
      v11 += v10;
      *(_DWORD *)v3 = v37;
      v3 += 4;
    }
    while (v4);
  }
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBAh,unsigned int,true,true,false,true>(int *a1, int a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  signed int v19;
  unsigned int *v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned int *v23;
  const unsigned __int8 *v24;
  const unsigned __int8 *v25;
  const unsigned __int8 *v26;
  int8x16_t v27;
  int8x8_t result;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD v36[2];

  v36[1] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (unsigned __int8 *)a3;
    v4 = a2;
    v33 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v34 = **(_QWORD **)a1;
    v5 = a1[15];
    v31 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v32 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v30 = a1[16];
    v6 = a1[13];
    v29 = a1[14];
    do
    {
      --v4;
      v7 = v32 - 0x8000;
      if (v6 < v32 - 0x8000)
        v7 = v6;
      if (v7 <= -32768)
        v7 = -32768;
      v8 = v7 + 0x8000;
      if (v6 <= 0x8000)
        v9 = 0x8000;
      else
        v9 = v6;
      v10 = v9 - 0x8000;
      if (v10 >= v32)
        v11 = v32;
      else
        v11 = v10;
      if (v5 >= v31 - 0x8000)
        v12 = v31 - 0x8000;
      else
        v12 = v5;
      if (v12 <= -32768)
        v12 = -32768;
      v13 = v12 + 0x8000;
      if (v5 <= 0x8000)
        v14 = 0x8000;
      else
        v14 = v5;
      v15 = v14 - 0x8000;
      if (v15 >= v31)
        v16 = v31;
      else
        v16 = v15;
      v17 = v34 + v33 * ((uint64_t)v16 >> 16);
      v18 = v34 + v33 * HIWORD(v13);
      v19 = (v11 >> 13) & 0xFFFFFFF8;
      v20 = (unsigned int *)(v18 + v19);
      v35 = 0;
      v36[0] = 0;
      v21 = (v8 >> 13) & 0x7FFF8;
      v22 = (unsigned int *)(v17 + v21);
      v23 = (unsigned int *)(v18 + v21);
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)((char *)v36 + 4), (unsigned int *)(v17 + v19), a3);
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)v36, v22, v24);
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)((char *)&v35 + 4), v20, v25);
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)&v35, v23, v26);
      v27 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)__PAIR64__(v35, HIDWORD(v35)), (uint8x8_t)__PAIR64__(v36[0], HIDWORD(v36[0]))), vdupq_n_s16((v16 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v36[0], HIDWORD(v36[0])));
      *(int16x4_t *)v27.i8 = vadd_s16(*(int16x4_t *)v27.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), *(int16x4_t *)v27.i8), vdup_n_s16((v11 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v27.i8, *(int8x8_t *)v27.i8);
      v6 += v29;
      v5 += v30;
      *(_DWORD *)v3 = result.i32[0];
      v3 += 4;
    }
    while (v4);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBAh,unsigned int,true,true,true,true>(uint64_t **a1, int a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v4;
  float v5;
  float v6;
  int v7;
  int v8;
  int v9;
  float32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  int32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  int v27;
  int v28;
  unsigned int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  signed int v39;
  unsigned int *v40;
  uint64_t v41;
  unsigned int *v42;
  unsigned int *v43;
  const unsigned __int8 *v44;
  const unsigned __int8 *v45;
  const unsigned __int8 *v46;
  int8x16_t v47;
  float *v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD v58[3];

  v58[1] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (unsigned __int8 *)a3;
    v4 = a2;
    v55 = (*a1)[2];
    v56 = **a1;
    v49 = (float *)*a1;
    v5 = *((float *)a1[3] + 3);
    v6 = *((float *)a1[2] + 3);
    v7 = *((_DWORD *)a1 + 15);
    v52 = *((_DWORD *)a1 + 16);
    v53 = *((_DWORD *)*a1 + 9);
    v8 = *((_DWORD *)a1 + 13);
    v51 = *((_DWORD *)a1 + 14);
    v54 = *((_DWORD *)*a1 + 8);
    v9 = *((unsigned __int8 *)a1 + 48) - 1;
    v10 = (float32x2_t)vdup_n_s32(0x37800000u);
    v11 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v12 = (float32x2_t)vdup_n_s32(0x47800000u);
    v50 = v9;
    do
    {
      v13.f32[0] = (float)(1.0 / v6) * (float)v8;
      v13.f32[1] = (float)(1.0 / v6) * (float)v7;
      v14 = vcvt_s32_f32(v13);
      switch(v9)
      {
        case 0:
          v15 = vmul_f32(*(float32x2_t *)(v49 + 10), vcvt_f32_s32(v14));
          v16 = vmul_f32(v15, v15);
          v17 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 1), v16);
          v16.f32[0] = fmaxf(vaddv_f32(v16), 0.00001);
          v16.i32[0] = vmul_f32(v17, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 0))).u32[0];
          v16.i32[1] = 0.5;
          v18 = vmul_f32(v16, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6)));
          goto LABEL_8;
        case 1:
          v19 = atan2f(v49[11] * (float)v14.i32[1], v49[10] * (float)v14.i32[0]);
          v20.i32[1] = 1056964608;
          v20.f32[0] = (float)(v19 * -10430.0) + 32768.0;
          v18 = vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6)));
          goto LABEL_8;
        case 2:
          v21 = vmul_f32(vcvt_f32_s32(v14), vmul_f32(v10, *(float32x2_t *)(v49 + 10)));
          v18 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v21, vrndm_f32(v21)), v11)), vmul_f32(v12, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6))));
          goto LABEL_8;
        case 4:
          v22 = vcvt_f32_s32(v14);
          v23 = vcvt_f32_s32(*(int32x2_t *)(v49 + 8));
          v24 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v23);
          v25 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v23);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, v25), (int8x8_t)v25, (int8x8_t)v22);
          v18 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v24, v26), (int8x8_t)v24, (int8x8_t)v26);
LABEL_8:
          v14 = vcvt_s32_f32(v18);
          break;
        default:
          break;
      }
      --v4;
      v27 = v14.i32[0];
      v28 = v54 - 0x8000;
      if (v14.i32[0] < v54 - 0x8000)
        v28 = v14.i32[0];
      if (v28 <= -32768)
        v28 = -32768;
      v29 = v28 + 0x8000;
      if (v14.i32[0] <= 0x8000)
        v27 = 0x8000;
      v30 = v27 - 0x8000;
      if (v30 >= v54)
        v31 = v54;
      else
        v31 = v30;
      v32 = v14.i32[1];
      if (v14.i32[1] >= v53 - 0x8000)
        v33 = v53 - 0x8000;
      else
        v33 = v14.i32[1];
      if (v33 <= -32768)
        v33 = -32768;
      v34 = v33 + 0x8000;
      if (v14.i32[1] <= 0x8000)
        v32 = 0x8000;
      v35 = v32 - 0x8000;
      if (v35 >= v53)
        v36 = v53;
      else
        v36 = v35;
      v37 = v56 + v55 * ((uint64_t)v36 >> 16);
      v38 = v56 + v55 * HIWORD(v34);
      v39 = (v31 >> 13) & 0xFFFFFFF8;
      v40 = (unsigned int *)(v38 + v39);
      v57 = 0;
      v58[0] = 0;
      v41 = (v29 >> 13) & 0x7FFF8;
      v42 = (unsigned int *)(v37 + v41);
      v43 = (unsigned int *)(v38 + v41);
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)((char *)v58 + 4), (unsigned int *)(v37 + v39), a3);
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)v58, v42, v44);
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)((char *)&v57 + 4), v40, v45);
      CA::OGL::SW::Format::RGBAh::load_1((CA::OGL::SW::Format::RGBAh *)&v57, v43, v46);
      v47 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)__PAIR64__(v57, HIDWORD(v57)), (uint8x8_t)__PAIR64__(v58[0], HIDWORD(v58[0]))), vdupq_n_s16((v36 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v58[0], HIDWORD(v58[0])));
      *(int16x4_t *)v47.i8 = vadd_s16(*(int16x4_t *)v47.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL), *(int16x4_t *)v47.i8), vdup_n_s16((v31 >> 1) & 0x7F80)));
      v6 = v6 + v5;
      v8 += v51;
      v7 += v52;
      *(_DWORD *)v3 = vuzp1_s8(*(int8x8_t *)v47.i8, *(int8x8_t *)v47.i8).u32[0];
      v3 += 4;
      v9 = v50;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBAf,unsigned int,true,true,false,false>(int *result, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  float32x2_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float32x2_t *v19;
  float32x2_t v20;
  int32x2_t v21;
  float32x2_t v22;
  int8x8_t v23;
  int8x8_t v24;
  int8x8_t v25;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    __asm { FMOV            V0.2S, #1.0 }
    v14 = (float32x2_t)vdup_n_s32(0x437F0000u);
    v16 = result[13];
    v15 = result[14];
    do
    {
      v17 = v16 & ~(v16 >> 31);
      if (v17 >= v5)
        v17 = v5;
      v18 = v8 & ~(v8 >> 31);
      if (v18 >= v6)
        v18 = v6;
      result = (int *)(v3 + v4 * ((uint64_t)v18 >> 16));
      v19 = (float32x2_t *)((char *)result + (((uint64_t)v17 >> 12) & 0xFFFFFFFFFFFFFFF0));
      v20 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v19, _D0), (int8x8_t)_D0, (int8x8_t)*v19);
      v21 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v20), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v20))), (uint32x2_t)0x800000010);
      v22 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v19[1], _D0), (int8x8_t)_D0, (int8x8_t)v19[1]);
      v23 = vorr_s8((int8x8_t)vdup_lane_s32(v21, 1), (int8x8_t)v21);
      v24 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v22), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v22)));
      v25 = vorr_s8(v24, v23);
      v23.i32[1] = 24;
      v16 += v15;
      v8 += v7;
      *a3++ = vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v24, (uint32x2_t)v23), 1), v25).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBAf,unsigned int,true,true,true,false>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  float *v5;
  uint64_t v6;
  uint64_t v7;
  __int32 v8;
  int v9;
  float v10;
  float v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  int32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  __int32 v39;
  int v40;
  float32x2_t *v41;
  float32x2_t v42;
  int32x2_t v43;
  int8x8_t v44;
  float32x2_t v45;
  int8x8_t v46;
  float32x2_t v47;
  int v48;
  uint64_t **v49;
  int v50;

  if (a2)
  {
    v4 = a2;
    v5 = (float *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((_DWORD *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((_DWORD *)result + 14);
    v16 = *((unsigned __int8 *)result + 48) - 1;
    __asm { FMOV            V11.2S, #1.0 }
    v22 = (float32x2_t)vdup_n_s32(0x437F0000u);
    v47 = (float32x2_t)vdup_n_s32(0x37800000u);
    v23 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v24 = (float32x2_t)vdup_n_s32(0x47800000u);
    v50 = v12;
    v48 = v16;
    v49 = result;
    do
    {
      v25.f32[0] = (float)(1.0 / v11) * (float)v15;
      v25.f32[1] = (float)(1.0 / v11) * (float)v13;
      v26 = vcvt_s32_f32(v25);
      switch(v16)
      {
        case 0:
          v27 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v26));
          v28 = vmul_f32(v27, v27);
          v29 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 1), v28);
          v28.f32[0] = fmaxf(vaddv_f32(v28), 0.00001);
          v28.i32[0] = vmul_f32(v29, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 0))).u32[0];
          v28.i32[1] = 0.5;
          v30 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          v31 = atan2f(v5[11] * (float)v26.i32[1], v5[10] * (float)v26.i32[0]);
          v16 = v48;
          result = v49;
          v12 = v50;
          v32.i32[1] = 1056964608;
          v32.f32[0] = (float)(v31 * -10430.0) + 32768.0;
          v30 = vmul_f32(v32, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          v33 = vmul_f32(vcvt_f32_s32(v26), vmul_f32(v47, *(float32x2_t *)(v5 + 10)));
          v30 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v33, vrndm_f32(v33)), v23)), vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          v34 = vcvt_f32_s32(v26);
          v35 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          v36 = vmul_f32(*(float32x2_t *)((char *)result + 84), v35);
          v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v35);
          v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v34, v37), (int8x8_t)v37, (int8x8_t)v34);
          v30 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v36, v38), (int8x8_t)v36, (int8x8_t)v38);
LABEL_8:
          v26 = vcvt_s32_f32(v30);
          break;
        default:
          break;
      }
      v39 = v26.i32[0] & ~(v26.i32[0] >> 31);
      if (v39 >= v8)
        v39 = v8;
      v40 = v26.i32[1] & ~(v26.i32[1] >> 31);
      if (v40 >= v9)
        v40 = v9;
      v41 = (float32x2_t *)(v6 + v7 * ((uint64_t)v40 >> 16) + (((uint64_t)v39 >> 12) & 0xFFFFFFFFFFFFFFF0));
      v42 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v41, _D11), (int8x8_t)_D11, (int8x8_t)*v41);
      v43 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v42), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v22, v42))), (uint32x2_t)0x800000010);
      v44 = vorr_s8((int8x8_t)vdup_lane_s32(v43, 1), (int8x8_t)v43);
      v45 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v41[1], _D11), (int8x8_t)_D11, (int8x8_t)v41[1]);
      v46 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v45), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v22, v45)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v46, (uint32x2_t)(v44.u32[0] | 0x1800000000)), 1), vorr_s8(v46, v44)).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBAf,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  float32x2_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  float32x2_t *v29;
  uint64_t v30;
  float32x2_t *v31;
  float32x2_t *v32;
  float32x2_t *v33;
  float32x2_t v34;
  uint32x2_t v35;
  float32x2_t v36;
  int8x8_t v37;
  float32x2_t v38;
  int32x2_t v39;
  int32x2_t v40;
  float32x2_t v41;
  int32x2_t v42;
  int8x8_t v43;
  int32x2_t v44;
  int8x8_t v45;
  float32x2_t v46;
  int32x2_t v47;
  int32x2_t v48;
  float32x2_t v49;
  float32x2_t v50;
  int32x2_t v51;
  int8x8_t v52;
  int32x2_t v53;
  int8x8_t v54;
  int32x2_t v55;
  float32x2_t v56;
  int32x2_t v57;
  int8x8_t v58;
  uint8x8_t v59;
  int8x16_t v60;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = *(_DWORD *)(result + 60);
    v7 = *(_DWORD *)(result + 64);
    v10 = *(_DWORD *)(result + 52);
    v9 = *(_DWORD *)(result + 56);
    result = 4294934528;
    __asm { FMOV            V0.2S, #1.0 }
    v16 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      if (v10 >= v5 - 0x8000)
        v17 = v5 - 0x8000;
      else
        v17 = v10;
      if (v17 <= -32768)
        v18 = -32768;
      else
        v18 = v17;
      if (v10 <= 0x8000)
        v19 = 0x8000;
      else
        v19 = v10;
      v20 = v19 - 0x8000;
      if (v20 >= v5)
        v20 = v5;
      if (v8 >= v6 - 0x8000)
        v21 = v6 - 0x8000;
      else
        v21 = v8;
      if (v21 <= -32768)
        v21 = -32768;
      if (v8 <= 0x8000)
        v22 = 0x8000;
      else
        v22 = v8;
      v23 = v22 - 0x8000;
      v24 = v21 + 0x8000;
      if (v23 >= v6)
        v25 = v6;
      else
        v25 = v23;
      v26 = v3 + v4 * ((uint64_t)v25 >> 16);
      v27 = v3 + v4 * HIWORD(v24);
      v28 = ((uint64_t)v20 >> 12) & 0xFFFFFFFFFFFFFFF0;
      v29 = (float32x2_t *)(v27 + v28);
      v30 = ((v18 + 0x8000) >> 12) & 0xFFFF0;
      v31 = (float32x2_t *)(v26 + v28);
      v32 = (float32x2_t *)(v26 + v30);
      v33 = (float32x2_t *)(v27 + v30);
      v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v31, _D0), (int8x8_t)_D0, (int8x8_t)*v31);
      v35 = vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v34), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v34)));
      v36 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v31[1], _D0), (int8x8_t)_D0, (int8x8_t)v31[1]);
      v37 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v36), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v36)));
      v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v32, _D0), (int8x8_t)_D0, (int8x8_t)*v32);
      v39 = (int32x2_t)vshl_u32(v35, (uint32x2_t)0x800000010);
      v40 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v38), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v38))), (uint32x2_t)0x800000010);
      v41 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32[1], _D0), (int8x8_t)_D0, (int8x8_t)v32[1]);
      v42 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32(v39, 1), (int8x8_t)v39);
      v43 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v41), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v41)));
      v44 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32(v40, 1), (int8x8_t)v40);
      v45 = (int8x8_t)vzip1_s32(v42, v44);
      v46 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v29, _D0), (int8x8_t)_D0, (int8x8_t)*v29);
      v47 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v46), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v46))), (uint32x2_t)0x800000010);
      v48 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32(v47, 1), (int8x8_t)v47);
      v42.i32[1] = 24;
      v49 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29[1], _D0), (int8x8_t)_D0, (int8x8_t)v29[1]);
      v44.i32[1] = 24;
      v50 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v33, _D0), (int8x8_t)_D0, (int8x8_t)*v33);
      v51 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v50), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v50))), (uint32x2_t)0x800000010);
      v52 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v49), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v49)));
      v53 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32(v51, 1), (int8x8_t)v51);
      v54 = (int8x8_t)vzip1_s32(v48, v53);
      v48.i32[1] = 24;
      v55 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v52, (uint32x2_t)v48), 1), v52);
      v56 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v33[1], _D0), (int8x8_t)_D0, (int8x8_t)v33[1]);
      v57 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v37, (uint32x2_t)v42), 1), v37);
      v58 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v56), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v56)));
      v53.i32[1] = 24;
      v59 = (uint8x8_t)vorr_s8((int8x8_t)vzip1_s32(v57, (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v43, (uint32x2_t)v44), 1), v43)), v45);
      v60 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vzip1_s32(v55, (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v58, (uint32x2_t)v53), 1), v58)), v54), v59), vdupq_n_s16((v25 >> 1) & 0x7F80)), v59);
      v10 += v9;
      v8 += v7;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v60.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v60, v60, 8uLL), *(int16x4_t *)v60.i8), vdup_n_s16((v20 >> 1) & 0x7F80))), (int8x8_t)_D0).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBAf,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  float *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  float32x2_t v24;
  float32x2_t v25;
  int32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  float v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  float32x2_t v39;
  float32x2_t v40;
  float32x2_t v41;
  float32x2_t v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  int v47;
  int v48;
  unsigned int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  float32x2_t *v54;
  float32x2_t *v55;
  uint64_t v56;
  float32x2_t *v57;
  float32x2_t v58;
  int32x2_t v59;
  float32x2_t *v60;
  int32x2_t v61;
  float32x2_t v62;
  int8x8_t v63;
  float32x2_t v64;
  int32x2_t v65;
  int32x2_t v66;
  int8x8_t v67;
  float32x2_t v68;
  int8x8_t v69;
  uint8x8_t v70;
  float32x2_t v71;
  int32x2_t v72;
  int32x2_t v73;
  float32x2_t v74;
  int8x8_t v75;
  float32x2_t v76;
  int32x2_t v77;
  int32x2_t v78;
  int8x8_t v79;
  int32x2_t v80;
  float32x2_t v81;
  int8x8_t v82;
  int8x16_t v83;
  int v84;
  uint64_t **v85;
  int v86;
  int v87;
  int v88;

  if (a2)
  {
    v4 = a2;
    v5 = (float *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = (v9 - 0x8000);
    v18 = *((unsigned __int8 *)result + 48) - 1;
    __asm { FMOV            V11.2S, #1.0 }
    v24 = (float32x2_t)vdup_n_s32(0x437F0000u);
    v87 = v8;
    v88 = v12;
    v86 = v8 - 0x8000;
    v84 = v18;
    v85 = result;
    do
    {
      v25.f32[0] = (float)(1.0 / v11) * (float)v15;
      v25.f32[1] = (float)(1.0 / v11) * (float)v13;
      v26 = vcvt_s32_f32(v25);
      switch(v18)
      {
        case 0:
          v27 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v26));
          v28 = vmul_f32(v27, v27);
          v29 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 1), v28);
          v28.f32[0] = fmaxf(vaddv_f32(v28), 0.00001);
          v28.i32[0] = vmul_f32(v29, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 0))).u32[0];
          v28.i32[1] = 0.5;
          v30 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          v31 = v7;
          v32 = v9;
          v33 = v14;
          v34 = v17;
          v35 = atan2f(v5[11] * (float)v26.i32[1], v5[10] * (float)v26.i32[0]);
          v18 = v84;
          result = v85;
          v17 = v34;
          v16 = v86;
          v8 = v87;
          v14 = v33;
          v12 = v88;
          v9 = v32;
          v7 = v31;
          v36.i32[1] = 1056964608;
          v36.f32[0] = (float)(v35 * -10430.0) + 32768.0;
          v30 = vmul_f32(v36, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          v37 = vmul_f32(vcvt_f32_s32(v26), vmul_f32((float32x2_t)vdup_n_s32(0x37800000u), *(float32x2_t *)(v5 + 10)));
          v30 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v37, vrndm_f32(v37)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu))), vmul_f32((float32x2_t)vdup_n_s32(0x47800000u), vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          v38 = vcvt_f32_s32(v26);
          v39 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          v40 = vmul_f32(*(float32x2_t *)((char *)result + 84), v39);
          v41 = vmul_f32(*(float32x2_t *)((char *)result + 92), v39);
          v42 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v38, v41), (int8x8_t)v41, (int8x8_t)v38);
          v30 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v40, v42), (int8x8_t)v40, (int8x8_t)v42);
LABEL_8:
          v26 = vcvt_s32_f32(v30);
          break;
        default:
          break;
      }
      v43 = v26.i32[0];
      if (v26.i32[0] >= v16)
        v44 = v16;
      else
        v44 = v26.i32[0];
      if (v44 <= -32768)
        v44 = -32768;
      v45 = v44 + 0x8000;
      if (v26.i32[0] <= 0x8000)
        v43 = 0x8000;
      v46 = v43 - 0x8000;
      if (v46 >= v8)
        v46 = v8;
      v47 = v26.i32[1];
      if (v26.i32[1] >= (int)v17)
        v48 = v17;
      else
        v48 = v26.i32[1];
      if (v48 <= -32768)
        v48 = -32768;
      v49 = v48 + 0x8000;
      if (v26.i32[1] <= 0x8000)
        v47 = 0x8000;
      v50 = v47 - 0x8000;
      if (v50 >= (int)v9)
        v50 = v9;
      v51 = v6 + v7 * ((uint64_t)v50 >> 16);
      v52 = v6 + v7 * HIWORD(v49);
      v53 = ((uint64_t)v46 >> 12) & 0xFFFFFFFFFFFFFFF0;
      v54 = (float32x2_t *)(v51 + v53);
      v55 = (float32x2_t *)(v52 + v53);
      v56 = (v45 >> 12) & 0xFFFF0;
      v57 = (float32x2_t *)(v51 + v56);
      v58 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v54, _D11), (int8x8_t)_D11, (int8x8_t)*v54);
      v59 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v58), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v24, v58))), (uint32x2_t)0x800000010);
      v60 = (float32x2_t *)(v52 + v56);
      v61 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32(v59, 1), (int8x8_t)v59);
      v62 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v54[1], _D11), (int8x8_t)_D11, (int8x8_t)v54[1]);
      v63 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v62), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v24, v62)));
      v64 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v57, _D11), (int8x8_t)_D11, (int8x8_t)*v57);
      v65 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v64), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v24, v64))), (uint32x2_t)0x800000010);
      v66 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32(v65, 1), (int8x8_t)v65);
      v67 = (int8x8_t)vzip1_s32(v61, v66);
      v61.i32[1] = 24;
      v68 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v57[1], _D11), (int8x8_t)_D11, (int8x8_t)v57[1]);
      v69 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v68), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v24, v68)));
      v66.i32[1] = 24;
      v70 = (uint8x8_t)vorr_s8((int8x8_t)vzip1_s32((int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v63, (uint32x2_t)v61), 1), v63), (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v69, (uint32x2_t)v66), 1), v69)), v67);
      v71 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v55, _D11), (int8x8_t)_D11, (int8x8_t)*v55);
      v72 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v71), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v24, v71))), (uint32x2_t)0x800000010);
      v73 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32(v72, 1), (int8x8_t)v72);
      v74 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v55[1], _D11), (int8x8_t)_D11, (int8x8_t)v55[1]);
      v75 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v74), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v24, v74)));
      v76 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v60, _D11), (int8x8_t)_D11, (int8x8_t)*v60);
      v77 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v76), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v24, v76))), (uint32x2_t)0x800000010);
      v78 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32(v77, 1), (int8x8_t)v77);
      v79 = (int8x8_t)vzip1_s32(v73, v78);
      v73.i32[1] = 24;
      v80 = (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v75, (uint32x2_t)v73), 1), v75);
      v81 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v60[1], _D11), (int8x8_t)_D11, (int8x8_t)v60[1]);
      v78.i32[1] = 24;
      v82 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v81), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v24, v81)));
      v83 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vzip1_s32(v80, (int32x2_t)vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v82, (uint32x2_t)v78), 1), v82)), v79), v70), vdupq_n_s16((v50 >> 1) & 0x7F80)), v70);
      *(int16x4_t *)v83.i8 = vadd_s16(*(int16x4_t *)v83.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v83, v83, 8uLL), *(int16x4_t *)v83.i8), vdup_n_s16((v46 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v83.i8, *(int8x8_t *)v83.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,false,false,false,false>(uint64_t result, int a2, _DWORD *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  unint64_t v6;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 52);
    v3 = *(_DWORD *)(result + 56);
    v5 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      HIDWORD(v6) = *(_DWORD *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      LODWORD(v6) = HIDWORD(v6);
      v4 += v3;
      *a3++ = v6 >> 8;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,true,false,false,false>(_DWORD *result, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unint64_t v9;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v6 = result[15];
    v5 = result[16];
    v8 = result[13];
    v7 = result[14];
    do
    {
      HIDWORD(v9) = *(_DWORD *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      LODWORD(v9) = HIDWORD(v9);
      v8 += v7;
      v6 += v5;
      *a3++ = v9 >> 8;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,false,true,false,false>(_DWORD *result, int a2, _DWORD *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  unint64_t v9;

  if (a2)
  {
    v3 = result[14];
    v4 = result[13];
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(_QWORD *)result + 36))
      v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v7 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5)
        v8 = v5;
      HIDWORD(v9) = *(_DWORD *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      LODWORD(v9) = HIDWORD(v9);
      v4 += v3;
      *a3++ = v9 >> 8;
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,true,true,false,false>(int *result, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unint64_t v13;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      HIDWORD(v13) = *(_DWORD *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      LODWORD(v13) = HIDWORD(v13);
      v10 += v9;
      v8 += v7;
      *a3++ = v13 >> 8;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, _DWORD *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  __int32 v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  __int32 v35;
  int v36;
  unint64_t v37;
  __int32 v38;
  int v39;
  uint64_t v40;
  int v41;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v41 = v13;
    v39 = v17;
    v40 = v8;
    v38 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v39;
          v8 = v40;
          v13 = v41;
          v9 = v38;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      HIDWORD(v37) = *(_DWORD *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      LODWORD(v37) = HIDWORD(v37);
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = v37 >> 8;
      --v4;
    }
    while (v4);
  }
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  unsigned int v15;
  unint64_t v16;
  unsigned int v17;
  uint8x8_t v18;
  int8x16_t v19;

  if (a2)
  {
    v4 = result[14];
    v5 = result[15];
    v6 = *(_QWORD *)(*(_QWORD *)result + 16);
    v7 = **(_QWORD **)result;
    v8 = v5 + 0x8000;
    v9 = v5 - 0x8000;
    v10 = v7 + v6 * ((uint64_t)(v5 - 0x8000) >> 16);
    v11 = v7 + v6 * ((uint64_t)v8 >> 16);
    a4.i32[0] = (v9 >> 1) & 0x7F80;
    v12 = result[13] - 0x8000;
    do
    {
      v13 = ((uint64_t)v12 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v14 = ((uint64_t)(v12 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      HIDWORD(v16) = *(_DWORD *)(v10 + v13);
      LODWORD(v16) = HIDWORD(v16);
      v15 = v16 >> 8;
      HIDWORD(v16) = *(_DWORD *)(v10 + v14);
      LODWORD(v16) = HIDWORD(v16);
      v17 = v16 >> 8;
      HIDWORD(v16) = *(_DWORD *)(v11 + v13);
      LODWORD(v16) = HIDWORD(v16);
      LODWORD(v13) = v16 >> 8;
      HIDWORD(v16) = *(_DWORD *)(v11 + v14);
      LODWORD(v16) = HIDWORD(v16);
      v18.i32[0] = v13;
      v18.i32[1] = v16 >> 8;
      v19 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8(v18, (uint8x8_t)__PAIR64__(v17, v15)), a4, 0), (uint8x8_t)__PAIR64__(v17, v15));
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v19.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL), *(int16x4_t *)v19.i8), vdup_n_s16((v12 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      v12 += v4;
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned int v13;
  unint64_t v14;
  uint8x8_t v15;
  int8x16_t v16;
  int8x8_t result;

  if (a2)
  {
    v3 = **(_QWORD **)a1;
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v5 = a1[16];
    v6 = a1[14];
    v7 = a1[13] - 0x8000;
    v8 = a1[15] - 0x8000;
    do
    {
      v9 = v3 + v4 * ((uint64_t)v8 >> 16);
      v10 = v3 + v4 * ((uint64_t)(v8 + 0x10000) >> 16);
      v11 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v12 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      HIDWORD(v14) = *(_DWORD *)(v9 + v11);
      LODWORD(v14) = HIDWORD(v14);
      v13 = v14 >> 8;
      HIDWORD(v14) = *(_DWORD *)(v10 + v11);
      LODWORD(v14) = HIDWORD(v14);
      LODWORD(v11) = v14 >> 8;
      HIDWORD(v14) = *(_DWORD *)(v9 + v12);
      LODWORD(v14) = HIDWORD(v14);
      LODWORD(v9) = v14 >> 8;
      HIDWORD(v14) = *(_DWORD *)(v10 + v12);
      LODWORD(v14) = HIDWORD(v14);
      v15.i32[0] = v11;
      v15.i32[1] = v14 >> 8;
      v16 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v15, (uint8x8_t)__PAIR64__(v9, v13)), vdupq_n_s16((v8 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v9, v13));
      *(int16x4_t *)v16.i8 = vadd_s16(*(int16x4_t *)v16.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), *(int16x4_t *)v16.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v16.i8, *(int8x8_t *)v16.i8);
      *a3++ = result.i32[0];
      v7 += v6;
      v8 += v5;
      --a2;
    }
    while (a2);
  }
  return result;
}

unint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,false,true,false,true>(unint64_t result, int a2, _DWORD *a3, int16x4_t a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unint64_t v23;
  unsigned int v24;
  uint8x8_t v25;
  int8x16_t v26;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 56);
    v5 = *(_DWORD *)(result + 60);
    v6 = *(_DWORD *)(result + 52);
    v7 = *(_DWORD *)(*(_QWORD *)result + 32);
    v8 = *(_DWORD *)(*(_QWORD *)result + 36);
    v9 = *(_QWORD *)(*(_QWORD *)result + 16);
    v10 = **(_QWORD **)result;
    if (v5 >= v8 - 0x8000)
      v11 = v8 - 0x8000;
    else
      v11 = *(_DWORD *)(result + 60);
    if (v11 <= -32768)
      v11 = -32768;
    if (v5 <= 0x8000)
      v5 = 0x8000;
    v12 = v5 - 0x8000;
    if (v12 >= v8)
      v13 = *(_DWORD *)(*(_QWORD *)result + 36);
    else
      v13 = v12;
    v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    v15 = v10 + v9 * ((v11 + 0x8000) >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    do
    {
      if (v6 >= v7 - 0x8000)
        v16 = v7 - 0x8000;
      else
        v16 = v6;
      if (v16 <= -32768)
        v16 = -32768;
      v17 = v16 + 0x8000;
      if (v6 <= 0x8000)
        v18 = 0x8000;
      else
        v18 = v6;
      v19 = v18 - 0x8000;
      if (v19 >= v7)
        v19 = v7;
      v20 = ((uint64_t)v19 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v21 = (v17 >> 14) & 0x3FFFC;
      HIDWORD(v23) = *(_DWORD *)(v14 + v21);
      LODWORD(v23) = HIDWORD(v23);
      v22 = v23 >> 8;
      HIDWORD(v23) = *(_DWORD *)(v14 + v20);
      LODWORD(v23) = HIDWORD(v23);
      v24 = v23 >> 8;
      HIDWORD(v23) = *(_DWORD *)(v15 + v20);
      LODWORD(v23) = HIDWORD(v23);
      result = (v23 >> 8);
      HIDWORD(v23) = *(_DWORD *)(v15 + v21);
      LODWORD(v23) = HIDWORD(v23);
      v25.i32[0] = result;
      v25.i32[1] = v23 >> 8;
      v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8(v25, (uint8x8_t)__PAIR64__(v22, v24)), a4, 0), (uint8x8_t)__PAIR64__(v22, v24));
      v6 += v4;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v26.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v19 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  unint64_t v24;
  uint8x8_t v25;
  int8x16_t v26;
  int8x8_t result;

  if (a2)
  {
    v3 = **(_QWORD **)a1;
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v5 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v6 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v8 = a1[15];
    v7 = a1[16];
    v10 = a1[13];
    v9 = a1[14];
    do
    {
      if (v10 >= v5 - 0x8000)
        v11 = v5 - 0x8000;
      else
        v11 = v10;
      if (v11 <= -32768)
        v11 = -32768;
      if (v10 <= 0x8000)
        v12 = 0x8000;
      else
        v12 = v10;
      v13 = v12 - 0x8000;
      if (v13 >= v5)
        v13 = v5;
      if (v8 >= v6 - 0x8000)
        v14 = v6 - 0x8000;
      else
        v14 = v8;
      if (v14 <= -32768)
        v14 = -32768;
      if (v8 <= 0x8000)
        v15 = 0x8000;
      else
        v15 = v8;
      v16 = v15 - 0x8000;
      v17 = v14 + 0x8000;
      if (v16 >= v6)
        v16 = v6;
      v18 = v3 + v4 * ((uint64_t)v16 >> 16);
      v19 = v3 + v4 * HIWORD(v17);
      v20 = ((uint64_t)v13 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v21 = ((v11 + 0x8000) >> 14) & 0x3FFFC;
      v22 = *(_DWORD *)(v18 + v20);
      LODWORD(v18) = *(_DWORD *)(v18 + v21);
      HIDWORD(v24) = v22;
      LODWORD(v24) = v22;
      v23 = v24 >> 8;
      HIDWORD(v24) = *(_DWORD *)(v19 + v20);
      LODWORD(v24) = HIDWORD(v24);
      LODWORD(v20) = v24 >> 8;
      LODWORD(v21) = *(_DWORD *)(v19 + v21);
      HIDWORD(v24) = v18;
      LODWORD(v24) = v18;
      LODWORD(v19) = v24 >> 8;
      HIDWORD(v24) = v21;
      LODWORD(v24) = v21;
      v25.i32[0] = v20;
      v25.i32[1] = v24 >> 8;
      v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v25, (uint8x8_t)__PAIR64__(v19, v23)), vdupq_n_s16((v16 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v19, v23));
      *(int16x4_t *)v26.i8 = vadd_s16(*(int16x4_t *)v26.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v13 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v26.i8, *(int8x8_t *)v26.i8);
      v10 += v9;
      v8 += v7;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::ABGR8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  uint32x2_t *v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unsigned int v51;
  unint64_t v52;
  uint8x8_t v53;
  int8x16_t v54;
  int v55;
  uint64_t **v56;
  int v57;
  int v58;
  int v59;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = *((unsigned __int8 *)result + 48) - 1;
    v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    v58 = v8;
    v59 = v12;
    v57 = v8 - 0x8000;
    v55 = v18;
    v56 = result;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          v24 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v23));
          v25 = vmul_f32(v24, v24);
          v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          v27 = vmul_f32(v25, vcvt_f32_u32(v5[3]));
          goto LABEL_8;
        case 1:
          v28 = v5;
          v29 = v9;
          v30 = v14;
          v31 = atan2f(*(float *)&v5[5].i32[1] * (float)v23.i32[1], *(float *)v5[5].i32 * (float)v23.i32[0]);
          v18 = v55;
          result = v56;
          v16 = v57;
          v8 = v58;
          v14 = v30;
          v12 = v59;
          v9 = v29;
          v5 = v28;
          v32.i32[1] = 1056964608;
          v32.f32[0] = (float)(v31 * -10430.0) + 32768.0;
          v27 = vmul_f32(v32, vcvt_f32_u32(v28[3]));
          goto LABEL_8;
        case 2:
          v33 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, (float32x2_t)v5[5]));
          v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v33, vrndm_f32(v33)), v20)), vmul_f32(v21, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v34 = vcvt_f32_s32(v23);
          v35 = vcvt_f32_s32((int32x2_t)v5[4]);
          v36 = vmul_f32(*(float32x2_t *)((char *)result + 84), v35);
          v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v35);
          v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v34, v37), (int8x8_t)v37, (int8x8_t)v34);
          v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v36, v38), (int8x8_t)v36, (int8x8_t)v38);
LABEL_8:
          v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      v39 = v23.i32[0];
      if (v23.i32[0] >= v16)
        v40 = v16;
      else
        v40 = v23.i32[0];
      if (v40 <= -32768)
        v40 = -32768;
      v41 = v40 + 0x8000;
      if (v23.i32[0] <= 0x8000)
        v39 = 0x8000;
      v42 = v39 - 0x8000;
      if (v42 >= v8)
        v42 = v8;
      v43 = v23.i32[1];
      if (v23.i32[1] >= v17)
        v44 = v17;
      else
        v44 = v23.i32[1];
      if (v44 <= -32768)
        v44 = -32768;
      v45 = v44 + 0x8000;
      if (v23.i32[1] <= 0x8000)
        v43 = 0x8000;
      v46 = v43 - 0x8000;
      if (v46 >= (int)v9)
        v46 = v9;
      v47 = v6 + v7 * ((uint64_t)v46 >> 16);
      v48 = v6 + v7 * HIWORD(v45);
      v49 = ((uint64_t)v42 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v50 = (v41 >> 14) & 0x3FFFC;
      HIDWORD(v52) = *(_DWORD *)(v47 + v49);
      LODWORD(v52) = HIDWORD(v52);
      v51 = v52 >> 8;
      HIDWORD(v52) = *(_DWORD *)(v47 + v50);
      LODWORD(v52) = HIDWORD(v52);
      LODWORD(v47) = v52 >> 8;
      HIDWORD(v52) = *(_DWORD *)(v48 + v49);
      LODWORD(v52) = HIDWORD(v52);
      LODWORD(v49) = v52 >> 8;
      HIDWORD(v52) = *(_DWORD *)(v48 + v50);
      LODWORD(v52) = HIDWORD(v52);
      v53.i32[0] = v49;
      v53.i32[1] = v52 >> 8;
      v54 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v53, (uint8x8_t)__PAIR64__(v47, v51)), vdupq_n_s16((v46 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v47, v51));
      *(int16x4_t *)v54.i8 = vadd_s16(*(int16x4_t *)v54.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL), *(int16x4_t *)v54.i8), vdup_n_s16((v42 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v54.i8, *(int8x8_t *)v54.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  unsigned int v6;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 52);
    v3 = *(_DWORD *)(result + 56);
    v5 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      v6 = (*(_DWORD *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) >> 8) | 0xFF000000;
      v4 += v3;
      *a3++ = v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v6 = result[15];
    v5 = result[16];
    v8 = result[13];
    v7 = result[14];
    do
    {
      v9 = (*(_DWORD *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) >> 8) | 0xFF000000;
      v8 += v7;
      v6 += v5;
      *a3++ = v9;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;

  if (a2)
  {
    v3 = result[14];
    v4 = result[13];
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(_QWORD *)result + 36))
      v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v7 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5)
        v8 = v5;
      v4 += v3;
      *a3++ = (*(_DWORD *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) >> 8) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      v10 += v9;
      v8 += v7;
      *a3++ = (*(_DWORD *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) >> 8) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  __int32 v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  __int32 v35;
  int v36;
  __int32 v37;
  int v38;
  uint64_t v39;
  int v40;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v40 = v13;
    v38 = v17;
    v39 = v8;
    v37 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v38;
          v8 = v39;
          v13 = v40;
          v9 = v37;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = (*(_DWORD *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL)) >> 8) | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  uint32x2_t v15;
  uint32x2_t v16;
  unint64_t v17;
  int8x16_t v18;

  if (a2)
  {
    v4 = result[14];
    v5 = result[15];
    v6 = *(_QWORD *)(*(_QWORD *)result + 16);
    v7 = **(_QWORD **)result;
    v8 = v5 + 0x8000;
    v9 = v5 - 0x8000;
    v10 = v7 + v6 * ((uint64_t)(v5 - 0x8000) >> 16);
    v11 = v7 + v6 * ((uint64_t)v8 >> 16);
    a4.i32[0] = (v9 >> 1) & 0x7F80;
    v12 = result[13] - 0x8000;
    do
    {
      v13 = ((uint64_t)v12 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v14 = ((uint64_t)(v12 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v15.i32[0] = *(_DWORD *)(v10 + v13);
      v15.i32[1] = *(_DWORD *)(v10 + v14);
      v16.i32[0] = *(_DWORD *)(v11 + v13);
      v16.i32[1] = *(_DWORD *)(v11 + v14);
      v17 = *(_QWORD *)&vshr_n_u32(v15, 8uLL) | 0xFF000000FF000000;
      v18 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vshr_n_u32(v16, 8uLL) | 0xFF000000FF000000), (uint8x8_t)v17), a4, 0), (uint8x8_t)v17);
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v18.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), *(int16x4_t *)v18.i8), vdup_n_s16((v12 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      v12 += v4;
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint32x2_t v13;
  uint32x2_t v14;
  unint64_t v15;
  int8x16_t v16;
  int8x8_t result;

  if (a2)
  {
    v3 = **(_QWORD **)a1;
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v5 = a1[16];
    v6 = a1[14];
    v7 = a1[13] - 0x8000;
    v8 = a1[15] - 0x8000;
    do
    {
      v9 = v3 + v4 * ((uint64_t)v8 >> 16);
      v10 = v3 + v4 * ((uint64_t)(v8 + 0x10000) >> 16);
      v11 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v12 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v13.i32[0] = *(_DWORD *)(v9 + v12);
      v13.i32[1] = *(_DWORD *)(v9 + v11);
      v14.i32[0] = *(_DWORD *)(v10 + v12);
      v14.i32[1] = *(_DWORD *)(v10 + v11);
      v15 = *(_QWORD *)&vshr_n_u32(v13, 8uLL) | 0xFF000000FF000000;
      v16 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vshr_n_u32(v14, 8uLL) | 0xFF000000FF000000), (uint8x8_t)v15), vdupq_n_s16((v8 >> 1) & 0x7F80)), (uint8x8_t)v15);
      *(int16x4_t *)v16.i8 = vadd_s16(*(int16x4_t *)v16.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), *(int16x4_t *)v16.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v16.i8, *(int8x8_t *)v16.i8);
      *a3++ = result.i32[0];
      v7 += v6;
      v8 += v5;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint32x2_t v21;
  uint32x2_t v22;
  unint64_t v23;
  int8x16_t v24;

  if (a2)
  {
    v4 = result[14];
    v5 = result[15];
    v6 = result[13];
    v7 = *(_DWORD *)(*(_QWORD *)result + 32);
    v8 = *(_DWORD *)(*(_QWORD *)result + 36);
    v9 = *(_QWORD *)(*(_QWORD *)result + 16);
    v10 = **(_QWORD **)result;
    if (v5 >= v8 - 0x8000)
      v11 = v8 - 0x8000;
    else
      v11 = result[15];
    if (v11 <= -32768)
      v11 = -32768;
    if (v5 <= 0x8000)
      v5 = 0x8000;
    v12 = v5 - 0x8000;
    if (v12 >= v8)
      v13 = *(_DWORD *)(*(_QWORD *)result + 36);
    else
      v13 = v12;
    v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    v15 = v10 + v9 * ((v11 + 0x8000) >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    do
    {
      if (v6 >= v7 - 0x8000)
        v16 = v7 - 0x8000;
      else
        v16 = v6;
      if (v16 <= -32768)
        v16 = -32768;
      v17 = v16 + 0x8000;
      if (v6 <= 0x8000)
        v18 = 0x8000;
      else
        v18 = v6;
      v19 = v18 - 0x8000;
      if (v19 >= v7)
        v19 = v7;
      v20 = (v17 >> 14) & 0x3FFFC;
      result = (_DWORD *)(((uint64_t)v19 >> 14) & 0xFFFFFFFFFFFFFFFCLL);
      v21.i32[0] = *(_DWORD *)((char *)result + v14);
      v21.i32[1] = *(_DWORD *)(v14 + v20);
      v22.i32[0] = *(_DWORD *)((char *)result + v15);
      v22.i32[1] = *(_DWORD *)(v15 + v20);
      v23 = *(_QWORD *)&vshr_n_u32(v21, 8uLL) | 0xFF000000FF000000;
      v24 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vshr_n_u32(v22, 8uLL) | 0xFF000000FF000000), (uint8x8_t)v23), a4, 0), (uint8x8_t)v23);
      v6 += v4;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v24.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL), *(int16x4_t *)v24.i8), vdup_n_s16((v19 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint32x2_t v23;
  uint32x2_t v24;
  unint64_t v25;
  int8x16_t v26;
  int8x8_t result;

  if (a2)
  {
    v3 = **(_QWORD **)a1;
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v5 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v6 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v8 = a1[15];
    v7 = a1[16];
    v10 = a1[13];
    v9 = a1[14];
    do
    {
      if (v10 >= v5 - 0x8000)
        v11 = v5 - 0x8000;
      else
        v11 = v10;
      if (v11 <= -32768)
        v11 = -32768;
      v12 = v11 + 0x8000;
      if (v10 <= 0x8000)
        v13 = 0x8000;
      else
        v13 = v10;
      v14 = v13 - 0x8000;
      if (v14 >= v5)
        v14 = v5;
      if (v8 >= v6 - 0x8000)
        v15 = v6 - 0x8000;
      else
        v15 = v8;
      if (v15 <= -32768)
        v15 = -32768;
      v16 = v15 + 0x8000;
      if (v8 <= 0x8000)
        v17 = 0x8000;
      else
        v17 = v8;
      v18 = v17 - 0x8000;
      if (v18 >= v6)
        v18 = v6;
      v19 = v3 + v4 * ((uint64_t)v18 >> 16);
      v20 = v3 + v4 * HIWORD(v16);
      v21 = (v12 >> 14) & 0x3FFFC;
      v22 = ((uint64_t)v14 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v23.i32[0] = *(_DWORD *)(v19 + v22);
      v23.i32[1] = *(_DWORD *)(v19 + v21);
      v24.i32[0] = *(_DWORD *)(v20 + v22);
      v24.i32[1] = *(_DWORD *)(v20 + v21);
      v25 = *(_QWORD *)&vshr_n_u32(v23, 8uLL) | 0xFF000000FF000000;
      v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vshr_n_u32(v24, 8uLL) | 0xFF000000FF000000), (uint8x8_t)v25), vdupq_n_s16((v18 >> 1) & 0x7F80)), (uint8x8_t)v25);
      *(int16x4_t *)v26.i8 = vadd_s16(*(int16x4_t *)v26.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v14 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v26.i8, *(int8x8_t *)v26.i8);
      v10 += v9;
      v8 += v7;
      *a3++ = result.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::XBGR8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  uint32x2_t *v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint32x2_t v51;
  uint32x2_t v52;
  unint64_t v53;
  int8x16_t v54;
  int v55;
  uint64_t **v56;
  int v57;
  int v58;
  int v59;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = *((unsigned __int8 *)result + 48) - 1;
    v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    v58 = v8;
    v59 = v12;
    v57 = v8 - 0x8000;
    v55 = v18;
    v56 = result;
    do
    {
      v22.f32[0] = (float)(1.0 / v11) * (float)v15;
      v22.f32[1] = (float)(1.0 / v11) * (float)v13;
      v23 = vcvt_s32_f32(v22);
      switch(v18)
      {
        case 0:
          v24 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v23));
          v25 = vmul_f32(v24, v24);
          v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          v27 = vmul_f32(v25, vcvt_f32_u32(v5[3]));
          goto LABEL_8;
        case 1:
          v28 = v5;
          v29 = v9;
          v30 = v14;
          v31 = atan2f(*(float *)&v5[5].i32[1] * (float)v23.i32[1], *(float *)v5[5].i32 * (float)v23.i32[0]);
          v18 = v55;
          result = v56;
          v16 = v57;
          v8 = v58;
          v14 = v30;
          v12 = v59;
          v9 = v29;
          v5 = v28;
          v32.i32[1] = 1056964608;
          v32.f32[0] = (float)(v31 * -10430.0) + 32768.0;
          v27 = vmul_f32(v32, vcvt_f32_u32(v28[3]));
          goto LABEL_8;
        case 2:
          v33 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, (float32x2_t)v5[5]));
          v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v33, vrndm_f32(v33)), v20)), vmul_f32(v21, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v34 = vcvt_f32_s32(v23);
          v35 = vcvt_f32_s32((int32x2_t)v5[4]);
          v36 = vmul_f32(*(float32x2_t *)((char *)result + 84), v35);
          v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v35);
          v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v34, v37), (int8x8_t)v37, (int8x8_t)v34);
          v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v36, v38), (int8x8_t)v36, (int8x8_t)v38);
LABEL_8:
          v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      v39 = v23.i32[0];
      if (v23.i32[0] >= v16)
        v40 = v16;
      else
        v40 = v23.i32[0];
      if (v40 <= -32768)
        v40 = -32768;
      v41 = v40 + 0x8000;
      if (v23.i32[0] <= 0x8000)
        v39 = 0x8000;
      v42 = v39 - 0x8000;
      if (v42 >= v8)
        v42 = v8;
      v43 = v23.i32[1];
      if (v23.i32[1] >= v17)
        v44 = v17;
      else
        v44 = v23.i32[1];
      if (v44 <= -32768)
        v44 = -32768;
      v45 = v44 + 0x8000;
      if (v23.i32[1] <= 0x8000)
        v43 = 0x8000;
      v46 = v43 - 0x8000;
      if (v46 >= (int)v9)
        v46 = v9;
      v47 = v6 + v7 * ((uint64_t)v46 >> 16);
      v48 = v6 + v7 * HIWORD(v45);
      v49 = ((uint64_t)v42 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v50 = (v41 >> 14) & 0x3FFFC;
      v51.i32[0] = *(_DWORD *)(v47 + v49);
      v51.i32[1] = *(_DWORD *)(v47 + v50);
      v52.i32[0] = *(_DWORD *)(v48 + v49);
      v52.i32[1] = *(_DWORD *)(v48 + v50);
      v53 = *(_QWORD *)&vshr_n_u32(v51, 8uLL) | 0xFF000000FF000000;
      v54 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vshr_n_u32(v52, 8uLL) | 0xFF000000FF000000), (uint8x8_t)v53), vdupq_n_s16((v46 >> 1) & 0x7F80)), (uint8x8_t)v53);
      *(int16x4_t *)v54.i8 = vadd_s16(*(int16x4_t *)v54.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL), *(int16x4_t *)v54.i8), vdup_n_s16((v42 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v54.i8, *(int8x8_t *)v54.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBXh,unsigned int,true,true,false,false>(int *a1, int a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (unsigned __int8 *)a3;
    v4 = a2;
    v5 = **(_QWORD **)a1;
    v6 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v7 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v8 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v10 = a1[15];
    v9 = a1[16];
    v12 = a1[13];
    v11 = a1[14];
    do
    {
      --v4;
      v15 = 0;
      v13 = v12 & ~(v12 >> 31);
      if (v13 >= v7)
        v13 = v7;
      v14 = v10 & ~(v10 >> 31);
      if (v14 >= v8)
        v14 = v8;
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)&v15, (unsigned int *)(v5 + v6 * ((uint64_t)v14 >> 16) + (int)((v13 >> 13) & 0xFFFFFFF8)), a3);
      v12 += v11;
      v10 += v9;
      *(_DWORD *)v3 = v15;
      v3 += 4;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBXh,unsigned int,true,true,true,false>(uint64_t **a1, int a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v4;
  float *v5;
  int v6;
  int v7;
  float v8;
  float v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  int32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  int v32;
  int v33;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (unsigned __int8 *)a3;
    v4 = a2;
    v5 = (float *)*a1;
    v35 = (*a1)[2];
    v36 = **a1;
    v6 = *((_DWORD *)*a1 + 8);
    v7 = *((_DWORD *)*a1 + 9);
    v8 = *((float *)a1[3] + 3);
    v9 = *((float *)a1[2] + 3);
    v11 = *((_DWORD *)a1 + 15);
    v10 = *((_DWORD *)a1 + 16);
    v13 = *((_DWORD *)a1 + 13);
    v12 = *((_DWORD *)a1 + 14);
    v14 = *((unsigned __int8 *)a1 + 48) - 1;
    v15 = (float32x2_t)vdup_n_s32(0x37800000u);
    v16 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v17 = (float32x2_t)vdup_n_s32(0x47800000u);
    do
    {
      v37 = 0;
      v18.f32[0] = (float)(1.0 / v9) * (float)v13;
      v18.f32[1] = (float)(1.0 / v9) * (float)v11;
      v19 = vcvt_s32_f32(v18);
      switch(v14)
      {
        case 0:
          v20 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v19));
          v21 = vmul_f32(v20, v20);
          v22 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 1), v21);
          v21.f32[0] = fmaxf(vaddv_f32(v21), 0.00001);
          v21.i32[0] = vmul_f32(v22, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 0))).u32[0];
          v21.i32[1] = 0.5;
          v23 = vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          v24 = atan2f(v5[11] * (float)v19.i32[1], v5[10] * (float)v19.i32[0]);
          v25.i32[1] = 1056964608;
          v25.f32[0] = (float)(v24 * -10430.0) + 32768.0;
          v23 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          v26 = vmul_f32(vcvt_f32_s32(v19), vmul_f32(v15, *(float32x2_t *)(v5 + 10)));
          v23 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v26, vrndm_f32(v26)), v16)), vmul_f32(v17, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          v27 = vcvt_f32_s32(v19);
          v28 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          v29 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v28);
          v30 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v28);
          v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, v30), (int8x8_t)v30, (int8x8_t)v27);
          v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29, v31), (int8x8_t)v29, (int8x8_t)v31);
LABEL_8:
          v19 = vcvt_s32_f32(v23);
          break;
        default:
          break;
      }
      --v4;
      v32 = v19.i32[0] & ~(v19.i32[0] >> 31);
      if (v32 >= v6)
        v32 = v6;
      v33 = v19.i32[1] & ~(v19.i32[1] >> 31);
      if (v33 >= v7)
        v33 = v7;
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)&v37, (unsigned int *)(v36 + v35 * ((uint64_t)v33 >> 16) + (int)((v32 >> 13) & 0xFFFFFFF8)), a3);
      v9 = v9 + v8;
      v13 += v12;
      v11 += v10;
      *(_DWORD *)v3 = v37;
      v3 += 4;
    }
    while (v4);
  }
}

int8x8_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBXh,unsigned int,true,true,false,true>(int *a1, int a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  signed int v19;
  unsigned int *v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned int *v23;
  const unsigned __int8 *v24;
  const unsigned __int8 *v25;
  const unsigned __int8 *v26;
  int8x16_t v27;
  int8x8_t result;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD v36[2];

  v36[1] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (unsigned __int8 *)a3;
    v4 = a2;
    v33 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v34 = **(_QWORD **)a1;
    v5 = a1[15];
    v31 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v32 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v30 = a1[16];
    v6 = a1[13];
    v29 = a1[14];
    do
    {
      --v4;
      v7 = v32 - 0x8000;
      if (v6 < v32 - 0x8000)
        v7 = v6;
      if (v7 <= -32768)
        v7 = -32768;
      v8 = v7 + 0x8000;
      if (v6 <= 0x8000)
        v9 = 0x8000;
      else
        v9 = v6;
      v10 = v9 - 0x8000;
      if (v10 >= v32)
        v11 = v32;
      else
        v11 = v10;
      if (v5 >= v31 - 0x8000)
        v12 = v31 - 0x8000;
      else
        v12 = v5;
      if (v12 <= -32768)
        v12 = -32768;
      v13 = v12 + 0x8000;
      if (v5 <= 0x8000)
        v14 = 0x8000;
      else
        v14 = v5;
      v15 = v14 - 0x8000;
      if (v15 >= v31)
        v16 = v31;
      else
        v16 = v15;
      v17 = v34 + v33 * ((uint64_t)v16 >> 16);
      v18 = v34 + v33 * HIWORD(v13);
      v19 = (v11 >> 13) & 0xFFFFFFF8;
      v20 = (unsigned int *)(v18 + v19);
      v35 = 0;
      v36[0] = 0;
      v21 = (v8 >> 13) & 0x7FFF8;
      v22 = (unsigned int *)(v17 + v21);
      v23 = (unsigned int *)(v18 + v21);
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)((char *)v36 + 4), (unsigned int *)(v17 + v19), a3);
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)v36, v22, v24);
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)((char *)&v35 + 4), v20, v25);
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)&v35, v23, v26);
      v27 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)__PAIR64__(v35, HIDWORD(v35)), (uint8x8_t)__PAIR64__(v36[0], HIDWORD(v36[0]))), vdupq_n_s16((v16 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v36[0], HIDWORD(v36[0])));
      *(int16x4_t *)v27.i8 = vadd_s16(*(int16x4_t *)v27.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), *(int16x4_t *)v27.i8), vdup_n_s16((v11 >> 1) & 0x7F80)));
      result = vuzp1_s8(*(int8x8_t *)v27.i8, *(int8x8_t *)v27.i8);
      v6 += v29;
      v5 += v30;
      *(_DWORD *)v3 = result.i32[0];
      v3 += 4;
    }
    while (v4);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBXh,unsigned int,true,true,true,true>(uint64_t **a1, int a2, const unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  int v4;
  float v5;
  float v6;
  int v7;
  int v8;
  int v9;
  float32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  int32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  int v27;
  int v28;
  unsigned int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  signed int v39;
  unsigned int *v40;
  uint64_t v41;
  unsigned int *v42;
  unsigned int *v43;
  const unsigned __int8 *v44;
  const unsigned __int8 *v45;
  const unsigned __int8 *v46;
  int8x16_t v47;
  float *v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD v58[3];

  v58[1] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (unsigned __int8 *)a3;
    v4 = a2;
    v55 = (*a1)[2];
    v56 = **a1;
    v49 = (float *)*a1;
    v5 = *((float *)a1[3] + 3);
    v6 = *((float *)a1[2] + 3);
    v7 = *((_DWORD *)a1 + 15);
    v52 = *((_DWORD *)a1 + 16);
    v53 = *((_DWORD *)*a1 + 9);
    v8 = *((_DWORD *)a1 + 13);
    v51 = *((_DWORD *)a1 + 14);
    v54 = *((_DWORD *)*a1 + 8);
    v9 = *((unsigned __int8 *)a1 + 48) - 1;
    v10 = (float32x2_t)vdup_n_s32(0x37800000u);
    v11 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v12 = (float32x2_t)vdup_n_s32(0x47800000u);
    v50 = v9;
    do
    {
      v13.f32[0] = (float)(1.0 / v6) * (float)v8;
      v13.f32[1] = (float)(1.0 / v6) * (float)v7;
      v14 = vcvt_s32_f32(v13);
      switch(v9)
      {
        case 0:
          v15 = vmul_f32(*(float32x2_t *)(v49 + 10), vcvt_f32_s32(v14));
          v16 = vmul_f32(v15, v15);
          v17 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 1), v16);
          v16.f32[0] = fmaxf(vaddv_f32(v16), 0.00001);
          v16.i32[0] = vmul_f32(v17, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 0))).u32[0];
          v16.i32[1] = 0.5;
          v18 = vmul_f32(v16, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6)));
          goto LABEL_8;
        case 1:
          v19 = atan2f(v49[11] * (float)v14.i32[1], v49[10] * (float)v14.i32[0]);
          v20.i32[1] = 1056964608;
          v20.f32[0] = (float)(v19 * -10430.0) + 32768.0;
          v18 = vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6)));
          goto LABEL_8;
        case 2:
          v21 = vmul_f32(vcvt_f32_s32(v14), vmul_f32(v10, *(float32x2_t *)(v49 + 10)));
          v18 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v21, vrndm_f32(v21)), v11)), vmul_f32(v12, vcvt_f32_u32(*(uint32x2_t *)(v49 + 6))));
          goto LABEL_8;
        case 4:
          v22 = vcvt_f32_s32(v14);
          v23 = vcvt_f32_s32(*(int32x2_t *)(v49 + 8));
          v24 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v23);
          v25 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v23);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, v25), (int8x8_t)v25, (int8x8_t)v22);
          v18 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v24, v26), (int8x8_t)v24, (int8x8_t)v26);
LABEL_8:
          v14 = vcvt_s32_f32(v18);
          break;
        default:
          break;
      }
      --v4;
      v27 = v14.i32[0];
      v28 = v54 - 0x8000;
      if (v14.i32[0] < v54 - 0x8000)
        v28 = v14.i32[0];
      if (v28 <= -32768)
        v28 = -32768;
      v29 = v28 + 0x8000;
      if (v14.i32[0] <= 0x8000)
        v27 = 0x8000;
      v30 = v27 - 0x8000;
      if (v30 >= v54)
        v31 = v54;
      else
        v31 = v30;
      v32 = v14.i32[1];
      if (v14.i32[1] >= v53 - 0x8000)
        v33 = v53 - 0x8000;
      else
        v33 = v14.i32[1];
      if (v33 <= -32768)
        v33 = -32768;
      v34 = v33 + 0x8000;
      if (v14.i32[1] <= 0x8000)
        v32 = 0x8000;
      v35 = v32 - 0x8000;
      if (v35 >= v53)
        v36 = v53;
      else
        v36 = v35;
      v37 = v56 + v55 * ((uint64_t)v36 >> 16);
      v38 = v56 + v55 * HIWORD(v34);
      v39 = (v31 >> 13) & 0xFFFFFFF8;
      v40 = (unsigned int *)(v38 + v39);
      v57 = 0;
      v58[0] = 0;
      v41 = (v29 >> 13) & 0x7FFF8;
      v42 = (unsigned int *)(v37 + v41);
      v43 = (unsigned int *)(v38 + v41);
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)((char *)v58 + 4), (unsigned int *)(v37 + v39), a3);
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)v58, v42, v44);
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)((char *)&v57 + 4), v40, v45);
      CA::OGL::SW::Format::RGBXh::load_1((CA::OGL::SW::Format::RGBXh *)&v57, v43, v46);
      v47 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)__PAIR64__(v57, HIDWORD(v57)), (uint8x8_t)__PAIR64__(v58[0], HIDWORD(v58[0]))), vdupq_n_s16((v36 >> 1) & 0x7F80)), (uint8x8_t)__PAIR64__(v58[0], HIDWORD(v58[0])));
      *(int16x4_t *)v47.i8 = vadd_s16(*(int16x4_t *)v47.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL), *(int16x4_t *)v47.i8), vdup_n_s16((v31 >> 1) & 0x7F80)));
      v6 = v6 + v5;
      v8 += v51;
      v7 += v52;
      *(_DWORD *)v3 = vuzp1_s8(*(int8x8_t *)v47.i8, *(int8x8_t *)v47.i8).u32[0];
      v3 += 4;
      v9 = v50;
    }
    while (v4);
  }
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA8,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned __int8 *v13;
  int v14;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      v13 = (unsigned __int8 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      v14 = *v13;
      result = (int *)((v14 << 8) | (v14 << 16));
      v10 += v9;
      v8 += v7;
      *a3++ = result | (v13[1] << 24) | v14;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, int *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  __int32 v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  __int32 v35;
  int v36;
  unsigned __int8 *v37;
  __int32 v38;
  int v39;
  uint64_t v40;
  int v41;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v41 = v13;
    v39 = v17;
    v40 = v8;
    v38 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v39;
          v8 = v40;
          v13 = v41;
          v9 = v38;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v37 = (unsigned __int8 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = (*v37 << 8) | (*v37 << 16) | (v37[1] << 24) | *v37;
      --v4;
    }
    while (v4);
  }
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA8,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, double a6, int8x8_t a7, int32x2_t a8, int8x8_t a9)
{
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  __int8 *v28;
  __int8 *v29;
  uint64_t v30;
  __int8 *v31;
  __int8 *v32;
  int8x8_t v33;
  int32x2_t v34;
  int8x8_t v35;
  int8x8_t v36;
  uint8x8_t v37;
  int8x16_t v38;

  if (a2)
  {
    v9 = **(_QWORD **)result;
    v10 = *(_QWORD *)(*(_QWORD *)result + 16);
    v11 = *(_DWORD *)(*(_QWORD *)result + 32);
    v12 = *(_DWORD *)(*(_QWORD *)result + 36);
    v14 = *(_DWORD *)(result + 60);
    v13 = *(_DWORD *)(result + 64);
    v16 = *(_DWORD *)(result + 52);
    v15 = *(_DWORD *)(result + 56);
    result = 4294934528;
    do
    {
      if (v16 >= v11 - 0x8000)
        v17 = v11 - 0x8000;
      else
        v17 = v16;
      if (v17 <= -32768)
        v17 = -32768;
      v18 = v17 + 0x8000;
      if (v16 <= 0x8000)
        v19 = 0x8000;
      else
        v19 = v16;
      v20 = v19 - 0x8000;
      if (v20 >= v11)
        v20 = v11;
      if (v14 >= v12 - 0x8000)
        v21 = v12 - 0x8000;
      else
        v21 = v14;
      if (v21 <= -32768)
        v21 = -32768;
      v22 = v21 + 0x8000;
      if (v14 <= 0x8000)
        v23 = 0x8000;
      else
        v23 = v14;
      v24 = v23 - 0x8000;
      if (v24 >= v12)
        v24 = v12;
      v25 = v9 + v10 * ((uint64_t)v24 >> 16);
      v26 = v9 + v10 * HIWORD(v22);
      v27 = ((uint64_t)v20 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v28 = (__int8 *)(v26 + v27);
      v29 = (__int8 *)(v25 + v27);
      v30 = (v18 >> 15) & 0x1FFFE;
      v31 = (__int8 *)(v25 + v30);
      v32 = (__int8 *)(v26 + v30);
      a7.i8[0] = *v29;
      a8.i8[0] = v29[1];
      a7.i8[4] = *v31;
      a9.i8[0] = *v28;
      a8.i8[4] = v31[1];
      a9.i8[4] = *v32;
      v33 = vand_s8(a9, (int8x8_t)0xFF000000FFLL);
      v34 = (int32x2_t)vshl_u32((uint32x2_t)v33, (uint32x2_t)0x1000000008);
      v35 = vand_s8(a7, (int8x8_t)0xFF000000FFLL);
      v36 = vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v33, (uint32x2_t)0x800000010), (int8x8_t)v34);
      v34.i8[0] = v28[1];
      v34.i8[4] = v32[1];
      v37 = (uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v35, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v35, (uint32x2_t)0x1000000008)), vorr_s8((int8x8_t)vshl_n_s32(a8, 0x18uLL), v35));
      v38 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(v36, vorr_s8((int8x8_t)vshl_n_s32(v34, 0x18uLL), v33)), v37), vdupq_n_s16((v24 >> 1) & 0x7F80)), v37);
      a9 = (int8x8_t)vdup_n_s16((v20 >> 1) & 0x7F80);
      a8 = (int32x2_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL), *(int16x4_t *)v38.i8), (int16x4_t)a9);
      a7 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v38.i8, (int16x4_t)a8), (int8x8_t)0xFF000000FFLL);
      v16 += v15;
      v14 += v13;
      *a3++ = a7.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  uint32x2_t *v27;
  uint64_t v28;
  uint64_t v29;
  float v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  int v37;
  int v38;
  unsigned int v39;
  int v40;
  int v41;
  int v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  __int8 *v48;
  __int8 *v49;
  uint64_t v50;
  __int8 *v51;
  __int8 *v52;
  int8x8_t v53;
  int8x8_t v54;
  int32x2_t v55;
  uint8x8_t v56;
  int8x8_t v57;
  int8x16_t v58;
  float32x2_t v59;
  int v60;
  uint64_t **v61;
  int v62;
  int v63;
  int v64;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = *((unsigned __int8 *)result + 48) - 1;
    v59 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v63 = v8;
    v64 = v12;
    v62 = v8 - 0x8000;
    v60 = v18;
    v61 = result;
    do
    {
      v21.f32[0] = (float)(1.0 / v11) * (float)v15;
      v21.f32[1] = (float)(1.0 / v11) * (float)v13;
      v22 = vcvt_s32_f32(v21);
      switch(v18)
      {
        case 0:
          v23 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v21 = vcvt_f32_u32(v5[3]);
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, v21);
          goto LABEL_8;
        case 1:
          v27 = v5;
          v28 = v9;
          v29 = v14;
          v30 = atan2f(*(float *)&v5[5].i32[1] * (float)v22.i32[1], *(float *)v5[5].i32 * (float)v22.i32[0]);
          v18 = v60;
          result = v61;
          v16 = v62;
          v8 = v63;
          v14 = v29;
          v12 = v64;
          v9 = v28;
          v5 = v27;
          v21 = vcvt_f32_u32(v27[3]);
          v31.i32[1] = 1056964608;
          v31.f32[0] = (float)(v30 * -10430.0) + 32768.0;
          v26 = vmul_f32(v31, v21);
          goto LABEL_8;
        case 2:
          v32 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v59, (float32x2_t)v5[5]));
          v21 = *(float32x2_t *)((char *)result + 84);
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), v21, vminnm_f32(vsub_f32(v32, vrndm_f32(v32)), v19)), vmul_f32(v20, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v33 = vcvt_f32_s32(v22);
          v34 = vcvt_f32_s32((int32x2_t)v5[4]);
          v21 = vmul_f32(*(float32x2_t *)((char *)result + 84), v34);
          v35 = vmul_f32(*(float32x2_t *)((char *)result + 92), v34);
          v36 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v33, v35), (int8x8_t)v35, (int8x8_t)v33);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v21, v36), (int8x8_t)v21, (int8x8_t)v36);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v37 = v22.i32[0];
      if (v22.i32[0] >= v16)
        v38 = v16;
      else
        v38 = v22.i32[0];
      if (v38 <= -32768)
        v38 = -32768;
      v39 = v38 + 0x8000;
      if (v22.i32[0] <= 0x8000)
        v37 = 0x8000;
      v40 = v37 - 0x8000;
      if (v40 >= v8)
        v40 = v8;
      v41 = v22.i32[1];
      if (v22.i32[1] >= v17)
        v42 = v17;
      else
        v42 = v22.i32[1];
      if (v42 <= -32768)
        v42 = -32768;
      v43 = v42 + 0x8000;
      if (v22.i32[1] <= 0x8000)
        v41 = 0x8000;
      v44 = v41 - 0x8000;
      if (v44 >= (int)v9)
        v44 = v9;
      v45 = v6 + v7 * ((uint64_t)v44 >> 16);
      v46 = v6 + v7 * HIWORD(v43);
      v47 = ((uint64_t)v40 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v48 = (__int8 *)(v45 + v47);
      v49 = (__int8 *)(v46 + v47);
      v50 = (v39 >> 15) & 0x1FFFE;
      v51 = (__int8 *)(v45 + v50);
      v52 = (__int8 *)(v46 + v50);
      v22.i8[0] = *v48;
      v22.i8[4] = *v51;
      v53 = vand_s8((int8x8_t)v22, (int8x8_t)0xFF000000FFLL);
      v21.i8[0] = v48[1];
      v21.i8[4] = v51[1];
      v54 = (int8x8_t)vshl_n_s32((int32x2_t)v21, 0x18uLL);
      v55 = (int32x2_t)vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v53, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v53, (uint32x2_t)0x1000000008));
      v56 = (uint8x8_t)vorr_s8((int8x8_t)v55, vorr_s8(v54, v53));
      v54.i8[0] = *v49;
      v54.i8[4] = *v52;
      v55.i8[0] = v49[1];
      v55.i8[4] = v52[1];
      v57 = vand_s8(v54, (int8x8_t)0xFF000000FFLL);
      v58 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v57, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v57, (uint32x2_t)0x1000000008)), vorr_s8((int8x8_t)vshl_n_s32(v55, 0x18uLL), v57)), v56), vdupq_n_s16((v44 >> 1) & 0x7F80)), v56);
      *(int16x4_t *)v58.i8 = vadd_s16(*(int16x4_t *)v58.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v58, v58, 8uLL), *(int16x4_t *)v58.i8), vdup_n_s16((v40 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v58.i8, *(int8x8_t *)v58.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LX8,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      result = (int *)(v3 + v4 * ((uint64_t)v12 >> 16));
      v10 += v9;
      v8 += v7;
      *a3++ = (65793 * *((unsigned __int8 *)result + (((uint64_t)v11 >> 15) & 0xFFFFFFFFFFFFFFFELL))) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LX8,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  __int32 v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  __int32 v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v10 = *((_DWORD *)*a1 + 8);
    v9 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v39 = v13;
    v37 = v17;
    v38 = v8;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v37;
          v8 = v38;
          v13 = v39;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v10)
        v35 = v10;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v9)
        v36 = v9;
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = (65793
             * *(unsigned __int8 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 15) & 0xFFFFFFFFFFFFFFFELL))) | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LX8,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, int8x8_t a6, int8x8_t a7)
{
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int32x2_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  unsigned int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  int8x16_t v28;

  if (a2)
  {
    v7 = **(_QWORD **)result;
    v8 = *(_QWORD *)(*(_QWORD *)result + 16);
    v9 = *(_DWORD *)(*(_QWORD *)result + 32);
    v10 = *(_DWORD *)(*(_QWORD *)result + 36);
    v12 = *(_DWORD *)(result + 60);
    v11 = *(_DWORD *)(result + 64);
    v14 = *(_DWORD *)(result + 52);
    v13 = *(_DWORD *)(result + 56);
    result = 4294934528;
    v15 = vdup_n_s32(0x10101u);
    do
    {
      if (v14 >= v9 - 0x8000)
        v16 = v9 - 0x8000;
      else
        v16 = v14;
      if (v16 <= -32768)
        v16 = -32768;
      if (v14 <= 0x8000)
        v17 = 0x8000;
      else
        v17 = v14;
      v18 = v17 - 0x8000;
      if (v18 >= v9)
        v18 = v9;
      if (v12 >= v10 - 0x8000)
        v19 = v10 - 0x8000;
      else
        v19 = v12;
      if (v19 <= -32768)
        v19 = -32768;
      v20 = v19 + 0x8000;
      if (v12 <= 0x8000)
        v21 = 0x8000;
      else
        v21 = v12;
      v22 = v21 - 0x8000;
      if (v22 >= v10)
        v22 = v10;
      v23 = v7 + v8 * ((uint64_t)v22 >> 16);
      v24 = v7 + v8 * HIWORD(v20);
      v25 = ((uint64_t)v18 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v26 = ((v16 + 0x8000) >> 15) & 0x1FFFE;
      a6.i8[0] = *(_BYTE *)(v23 + v25);
      a7.i8[0] = *(_BYTE *)(v24 + v25);
      a6.i8[4] = *(_BYTE *)(v23 + v26);
      a7.i8[4] = *(_BYTE *)(v24 + v26);
      v27 = *(_QWORD *)&vmul_s32((int32x2_t)vand_s8(a6, (int8x8_t)0xFF000000FFLL), v15) | 0xFF000000FF000000;
      v28 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vmul_s32((int32x2_t)vand_s8(a7, (int8x8_t)0xFF000000FFLL), v15) | 0xFF000000FF000000), (uint8x8_t)v27), vdupq_n_s16((v22 >> 1) & 0x7F80)), (uint8x8_t)v27);
      a7 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL), *(int16x4_t *)v28.i8), vdup_n_s16((v18 >> 1) & 0x7F80));
      a6 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v28.i8, (int16x4_t)a7), (int8x8_t)0xFF000000FFLL);
      v14 += v13;
      v12 += v11;
      *a3++ = a6.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LX8,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  int32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  uint32x2_t *v29;
  uint64_t v30;
  uint64_t v31;
  float v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  int8x16_t v52;
  int v53;
  uint64_t **v54;
  int v55;
  int v56;
  int v57;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = *((unsigned __int8 *)result + 48) - 1;
    v19 = vdup_n_s32(0x10101u);
    v20 = (float32x2_t)vdup_n_s32(0x37800000u);
    v21 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v22 = (float32x2_t)vdup_n_s32(0x47800000u);
    v56 = v8;
    v57 = v12;
    v55 = v8 - 0x8000;
    v53 = v18;
    v54 = result;
    do
    {
      v23.f32[0] = (float)(1.0 / v11) * (float)v15;
      v23.f32[1] = (float)(1.0 / v11) * (float)v13;
      v24 = vcvt_s32_f32(v23);
      switch(v18)
      {
        case 0:
          v25 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v24));
          v26 = vmul_f32(v25, v25);
          v27 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v26, 1), v26);
          v26.f32[0] = fmaxf(vaddv_f32(v26), 0.00001);
          v26.i32[0] = vmul_f32(v27, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v26, 0))).u32[0];
          v23 = vcvt_f32_u32(v5[3]);
          v26.i32[1] = 0.5;
          v28 = vmul_f32(v26, v23);
          goto LABEL_8;
        case 1:
          v29 = v5;
          v30 = v9;
          v31 = v14;
          v32 = atan2f(*(float *)&v5[5].i32[1] * (float)v24.i32[1], *(float *)v5[5].i32 * (float)v24.i32[0]);
          v18 = v53;
          result = v54;
          v16 = v55;
          v8 = v56;
          v14 = v31;
          v12 = v57;
          v9 = v30;
          v5 = v29;
          v23 = vcvt_f32_u32(v29[3]);
          v33.i32[1] = 1056964608;
          v33.f32[0] = (float)(v32 * -10430.0) + 32768.0;
          v28 = vmul_f32(v33, v23);
          goto LABEL_8;
        case 2:
          v34 = vmul_f32(vcvt_f32_s32(v24), vmul_f32(v20, (float32x2_t)v5[5]));
          v23 = *(float32x2_t *)((char *)result + 84);
          v28 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), v23, vminnm_f32(vsub_f32(v34, vrndm_f32(v34)), v21)), vmul_f32(v22, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v35 = vcvt_f32_s32(v24);
          v36 = vcvt_f32_s32((int32x2_t)v5[4]);
          v23 = vmul_f32(*(float32x2_t *)((char *)result + 84), v36);
          v37 = vmul_f32(*(float32x2_t *)((char *)result + 92), v36);
          v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v37), (int8x8_t)v37, (int8x8_t)v35);
          v28 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v23, v38), (int8x8_t)v23, (int8x8_t)v38);
LABEL_8:
          v24 = vcvt_s32_f32(v28);
          break;
        default:
          break;
      }
      v39 = v24.i32[0];
      if (v24.i32[0] >= v16)
        v40 = v16;
      else
        v40 = v24.i32[0];
      if (v40 <= -32768)
        v40 = -32768;
      v41 = v40 + 0x8000;
      if (v24.i32[0] <= 0x8000)
        v39 = 0x8000;
      v42 = v39 - 0x8000;
      v43 = v24.i32[1];
      if (v42 >= v8)
        v42 = v8;
      if (v24.i32[1] >= v17)
        v44 = v17;
      else
        v44 = v24.i32[1];
      if (v44 <= -32768)
        v44 = -32768;
      v45 = v44 + 0x8000;
      if (v24.i32[1] <= 0x8000)
        v43 = 0x8000;
      v46 = v43 - 0x8000;
      if (v46 >= (int)v9)
        v46 = v9;
      v47 = v6 + v7 * ((uint64_t)v46 >> 16);
      v48 = v6 + v7 * HIWORD(v45);
      v49 = ((uint64_t)v42 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v50 = (v41 >> 15) & 0x1FFFE;
      v24.i8[0] = *(_BYTE *)(v47 + v49);
      v24.i8[4] = *(_BYTE *)(v47 + v50);
      v23.i8[0] = *(_BYTE *)(v48 + v49);
      v23.i8[4] = *(_BYTE *)(v48 + v50);
      v51 = *(_QWORD *)&vmul_s32((int32x2_t)vand_s8((int8x8_t)v24, (int8x8_t)0xFF000000FFLL), v19) | 0xFF000000FF000000;
      v52 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vmul_s32((int32x2_t)vand_s8((int8x8_t)v23, (int8x8_t)0xFF000000FFLL), v19) | 0xFF000000FF000000), (uint8x8_t)v51), vdupq_n_s16((v46 >> 1) & 0x7F80)), (uint8x8_t)v51);
      *(int16x4_t *)v52.i8 = vadd_s16(*(int16x4_t *)v52.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL), *(int16x4_t *)v52.i8), vdup_n_s16((v42 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v52.i8, *(int8x8_t *)v52.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 52);
    v3 = *(_DWORD *)(result + 56);
    v5 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      v6 = *(unsigned __int16 *)(v5 + (((uint64_t)v4 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      v7 = (32 * v6) & 0xF800 | (8 * ((v6 >> 1) & 0x1F)) & 0xFF07FFFF | ((unsigned __int16)v6 >> 11 << 19);
      v4 += v3;
      *a3++ = v7 | (v7 >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v6 = result[15];
    v5 = result[16];
    v8 = result[13];
    v7 = result[14];
    do
    {
      v9 = *(unsigned __int16 *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      v10 = (32 * v9) & 0xF800 | (8 * ((v9 >> 1) & 0x1F)) & 0xFF07FFFF | ((unsigned __int16)v9 >> 11 << 19);
      v8 += v7;
      v6 += v5;
      *a3++ = v10 | (v10 >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  unsigned int v10;

  if (a2)
  {
    v3 = result[14];
    v4 = result[13];
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(_QWORD *)result + 36))
      v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v7 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5)
        v8 = v5;
      v9 = *(unsigned __int16 *)(v7 + (((uint64_t)v8 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      v10 = (32 * v9) & 0xF800 | (8 * ((v9 >> 1) & 0x1F)) & 0xFF07FFFF | ((unsigned __int16)v9 >> 11 << 19);
      v4 += v3;
      *a3++ = v10 | (v10 >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      v13 = *(unsigned __int16 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      result = (int *)(v13 >> 1);
      v14 = (32 * v13) & 0xF800 | (8 * (result & 0x1F)) | ((unsigned __int16)v13 >> 11 << 19);
      v10 += v9;
      v8 += v7;
      *a3++ = v14 | (v14 >> 3) & 0x7070707 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  __int32 v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  __int32 v35;
  int v36;
  unsigned int v37;
  unsigned int v38;
  __int32 v39;
  int v40;
  uint64_t v41;
  int v42;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v42 = v13;
    v40 = v17;
    v41 = v8;
    v39 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v40;
          v8 = v41;
          v13 = v42;
          v9 = v39;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v37 = *(unsigned __int16 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 15) & 0xFFFFFFFFFFFFFFFELL));
      v38 = (32 * v37) & 0xF800 | (8 * ((v37 >> 1) & 0x1F)) & 0xFF07FFFF | ((unsigned __int16)v37 >> 11 << 19);
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = v38 | (v38 >> 3) & 0x7070707 | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int32x2_t v4;
  int32x2_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int8x8_t v15;
  unint64_t v16;
  unint64_t v17;
  uint32x2_t v18;
  uint32x2_t v19;
  int8x8_t v20;
  int8x8_t v21;
  unint64_t v22;
  int8x16_t v23;

  if (a2)
  {
    v6 = result[14];
    v7 = result[15];
    v8 = *(_QWORD *)(*(_QWORD *)result + 16);
    v9 = **(_QWORD **)result;
    v10 = v7 + 0x8000;
    v11 = v7 - 0x8000;
    v12 = v9 + v8 * ((uint64_t)(v7 - 0x8000) >> 16);
    v13 = v9 + v8 * ((uint64_t)v10 >> 16);
    a4.i32[0] = (v11 >> 1) & 0x7F80;
    v14 = result[13] - 0x8000;
    v15 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      v16 = ((uint64_t)v14 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v17 = ((uint64_t)(v14 + 0x10000) >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v4.i16[0] = *(_WORD *)(v12 + v16);
      v4.i16[2] = *(_WORD *)(v12 + v17);
      v18 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v4, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      v5.i16[0] = *(_WORD *)(v13 + v16);
      v5.i16[2] = *(_WORD *)(v13 + v17);
      v19 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v5, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      v20 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v18, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v18, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v4, 8uLL), (int8x8_t)0xF8000000F80000));
      v5 = vshl_n_s32(v5, 8uLL);
      v21 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v19, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v19, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)v5, (int8x8_t)0xF8000000F80000));
      v22 = *(_QWORD *)&vorr_s8(v20, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v20, 3uLL), v15)) | 0xFF000000FF000000;
      v23 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(v21, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v21, 3uLL), v15)) | 0xFF000000FF000000), (uint8x8_t)v22), a4, 0), (uint8x8_t)v22);
      v4 = (int32x2_t)vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v23.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL), *(int16x4_t *)v23.i8), vdup_n_s16((v14 >> 1) & 0x7F80))), (int8x8_t)a4);
      *a3++ = v4.i32[0];
      v14 += v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,true,false,false,true>(_DWORD *result, int a2, _DWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, int8x8_t a11)
{
  int32x2_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int8x8_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint32x2_t v23;
  uint32x2_t v24;
  int8x8_t v25;
  int8x8_t v26;
  unint64_t v27;
  int8x16_t v28;

  if (a2)
  {
    v12 = **(_QWORD **)result;
    v13 = *(_QWORD *)(*(_QWORD *)result + 16);
    v14 = result[16];
    v15 = result[14];
    v16 = result[13] - 0x8000;
    v17 = result[15] - 0x8000;
    v18 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      v19 = v12 + v13 * ((uint64_t)v17 >> 16);
      v20 = v12 + v13 * ((uint64_t)(v17 + 0x10000) >> 16);
      v21 = ((uint64_t)v16 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      result = (_DWORD *)(v19 + v21);
      v22 = ((uint64_t)(v16 + 0x10000) >> 15) & 0xFFFFFFFFFFFFFFFELL;
      a11.i16[0] = *(_WORD *)(v19 + v21);
      a11.i16[2] = *(_WORD *)(v19 + v22);
      v23 = vshr_n_u32((uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      v11.i16[0] = *(_WORD *)(v20 + v21);
      v11.i16[2] = *(_WORD *)(v20 + v22);
      v24 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v11, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      v25 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v23, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v23, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32((int32x2_t)a11, 8uLL), (int8x8_t)0xF8000000F80000));
      v26 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v24, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v24, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v11, 8uLL), (int8x8_t)0xF8000000F80000));
      v27 = *(_QWORD *)&vorr_s8(v25, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v25, 3uLL), v18)) | 0xFF000000FF000000;
      v28 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(v26, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v26, 3uLL), v18)) | 0xFF000000FF000000), (uint8x8_t)v27), vdupq_n_s16((v17 >> 1) & 0x7F80)), (uint8x8_t)v27);
      a11 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v28.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL), *(int16x4_t *)v28.i8), vdup_n_s16((v16 >> 1) & 0x7F80))), (int8x8_t)0xFFFF0000FFFFLL);
      *a3++ = a11.i32[0];
      v16 += v15;
      v17 += v14;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int32x2_t v4;
  int32x2_t v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int8x8_t v18;
  int v19;
  unsigned int v20;
  int v21;
  int v22;
  unint64_t v23;
  __int16 *v24;
  uint64_t v25;
  uint32x2_t v26;
  uint32x2_t v27;
  int8x8_t v28;
  int8x8_t v29;
  unint64_t v30;
  int8x16_t v31;

  if (a2)
  {
    v6 = result[14];
    v7 = result[15];
    v8 = result[13];
    v9 = *(_DWORD *)(*(_QWORD *)result + 32);
    v10 = *(_DWORD *)(*(_QWORD *)result + 36);
    v11 = *(_QWORD *)(*(_QWORD *)result + 16);
    v12 = **(_QWORD **)result;
    if (v7 >= v10 - 0x8000)
      v13 = v10 - 0x8000;
    else
      v13 = result[15];
    if (v13 <= -32768)
      v13 = -32768;
    if (v7 <= 0x8000)
      v7 = 0x8000;
    v14 = v7 - 0x8000;
    if (v14 >= v10)
      v15 = *(_DWORD *)(*(_QWORD *)result + 36);
    else
      v15 = v14;
    v16 = v12 + v11 * ((uint64_t)v15 >> 16);
    v17 = v12 + v11 * ((v13 + 0x8000) >> 16);
    a4.i32[0] = (v15 >> 1) & 0x7F80;
    v18 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      if (v8 >= v9 - 0x8000)
        v19 = v9 - 0x8000;
      else
        v19 = v8;
      if (v19 <= -32768)
        v19 = -32768;
      v20 = v19 + 0x8000;
      if (v8 <= 0x8000)
        v21 = 0x8000;
      else
        v21 = v8;
      v22 = v21 - 0x8000;
      if (v22 >= v9)
        v22 = v9;
      v23 = ((uint64_t)v22 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v24 = (__int16 *)(v16 + v23);
      v25 = (v20 >> 15) & 0x1FFFE;
      result = (_DWORD *)(v17 + v23);
      v4.i16[0] = *v24;
      v4.i16[2] = *(_WORD *)(v16 + v25);
      v26 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v4, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      v5.i16[0] = *(_WORD *)result;
      v5.i16[2] = *(_WORD *)(v17 + v25);
      v27 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v5, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      v28 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v26, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v26, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v4, 8uLL), (int8x8_t)0xF8000000F80000));
      v5 = vshl_n_s32(v5, 8uLL);
      v29 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v27, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v27, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)v5, (int8x8_t)0xF8000000F80000));
      v30 = *(_QWORD *)&vorr_s8(v28, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v28, 3uLL), v18)) | 0xFF000000FF000000;
      v31 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(v29, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v29, 3uLL), v18)) | 0xFF000000FF000000), (uint8x8_t)v30), a4, 0), (uint8x8_t)v30);
      v4 = (int32x2_t)vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v31.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL), *(int16x4_t *)v31.i8), vdup_n_s16((v22 >> 1) & 0x7F80))), (int8x8_t)a4);
      v8 += v6;
      *a3++ = v4.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, int8x8_t a11)
{
  int32x2_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int8x8_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  unsigned int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint32x2_t v34;
  uint32x2_t v35;
  int8x8_t v36;
  int8x8_t v37;
  unint64_t v38;
  int8x16_t v39;

  if (a2)
  {
    v12 = **(_QWORD **)result;
    v13 = *(_QWORD *)(*(_QWORD *)result + 16);
    v14 = *(_DWORD *)(*(_QWORD *)result + 32);
    v15 = *(_DWORD *)(*(_QWORD *)result + 36);
    v17 = *(_DWORD *)(result + 60);
    v16 = *(_DWORD *)(result + 64);
    v19 = *(_DWORD *)(result + 52);
    v18 = *(_DWORD *)(result + 56);
    result = 4294934528;
    v20 = (int8x8_t)vdup_n_s32(0x70707u);
    do
    {
      if (v19 >= v14 - 0x8000)
        v21 = v14 - 0x8000;
      else
        v21 = v19;
      if (v21 <= -32768)
        v22 = -32768;
      else
        v22 = v21;
      if (v19 <= 0x8000)
        v23 = 0x8000;
      else
        v23 = v19;
      v24 = v23 - 0x8000;
      if (v24 >= v14)
        v24 = v14;
      if (v17 >= v15 - 0x8000)
        v25 = v15 - 0x8000;
      else
        v25 = v17;
      if (v25 <= -32768)
        v25 = -32768;
      if (v17 <= 0x8000)
        v26 = 0x8000;
      else
        v26 = v17;
      v27 = v26 - 0x8000;
      v28 = v25 + 0x8000;
      if (v27 >= v15)
        v29 = v15;
      else
        v29 = v27;
      v30 = v12 + v13 * ((uint64_t)v29 >> 16);
      v31 = v12 + v13 * HIWORD(v28);
      v32 = ((uint64_t)v24 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v33 = ((v22 + 0x8000) >> 15) & 0x1FFFE;
      a11.i16[0] = *(_WORD *)(v30 + v32);
      a11.i16[2] = *(_WORD *)(v30 + v33);
      v34 = vshr_n_u32((uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      v11.i16[0] = *(_WORD *)(v31 + v32);
      v11.i16[2] = *(_WORD *)(v31 + v33);
      v35 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v11, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      v36 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v34, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v34, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32((int32x2_t)a11, 8uLL), (int8x8_t)0xF8000000F80000));
      v37 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v35, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v35, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v11, 8uLL), (int8x8_t)0xF8000000F80000));
      v11 = (int32x2_t)vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v37, 3uLL), v20);
      v38 = *(_QWORD *)&vorr_s8(v36, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v36, 3uLL), v20)) | 0xFF000000FF000000;
      v39 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(v37, (int8x8_t)v11) | 0xFF000000FF000000), (uint8x8_t)v38), vdupq_n_s16((v29 >> 1) & 0x7F80)), (uint8x8_t)v38);
      a11 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v39.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL), *(int16x4_t *)v39.i8), vdup_n_s16((v24 >> 1) & 0x7F80))), (int8x8_t)0xFFFF0000FFFFLL);
      v19 += v18;
      v17 += v16;
      *a3++ = a11.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA5,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float v18;
  int v19;
  int8x8_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  uint32x2_t *v27;
  uint64_t v28;
  uint64_t v29;
  float v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  int v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint32x2_t v50;
  int8x8_t v51;
  int32x2_t v52;
  int8x8_t v53;
  uint32x2_t v54;
  int8x8_t v55;
  int8x16_t v56;
  float32x2_t v57;
  float32x2_t v58;
  float32x2_t v59;
  int v60;
  int v61;
  uint64_t **v62;
  int v63;
  int v64;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((unsigned int *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((_DWORD *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = 1.0;
    v19 = *((unsigned __int8 *)result + 48) - 1;
    v20 = (int8x8_t)vdup_n_s32(0x70707u);
    v58 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v59 = (float32x2_t)vdup_n_s32(0x37800000u);
    v57 = (float32x2_t)vdup_n_s32(0x47800000u);
    v63 = v14;
    v64 = v8;
    v62 = result;
    v61 = v9 - 0x8000;
    v60 = v19;
    do
    {
      v21.f32[0] = (float)(v18 / v11) * (float)v15;
      v21.f32[1] = (float)(v18 / v11) * (float)v13;
      v22 = vcvt_s32_f32(v21);
      switch(v19)
      {
        case 0:
          v23 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(v5[3]));
          goto LABEL_8;
        case 1:
          v27 = v5;
          v28 = v9;
          v29 = v12;
          v30 = atan2f(*(float *)&v5[5].i32[1] * (float)v22.i32[1], *(float *)v5[5].i32 * (float)v22.i32[0]);
          v19 = v60;
          v18 = 1.0;
          v17 = v61;
          v14 = v63;
          v8 = v64;
          v12 = v29;
          v9 = v28;
          v5 = v27;
          result = v62;
          v31.i32[1] = 1056964608;
          v31.f32[0] = (float)(v30 * -10430.0) + 32768.0;
          v26 = vmul_f32(v31, vcvt_f32_u32(v27[3]));
          goto LABEL_8;
        case 2:
          v32 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v59, (float32x2_t)v5[5]));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v32, vrndm_f32(v32)), v58)), vmul_f32(v57, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v33 = vcvt_f32_s32(v22);
          v34 = vcvt_f32_s32((int32x2_t)v5[4]);
          v35 = vmul_f32(*(float32x2_t *)((char *)result + 84), v34);
          v36 = vmul_f32(*(float32x2_t *)((char *)result + 92), v34);
          v37 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v33, v36), (int8x8_t)v36, (int8x8_t)v33);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v35, v37), (int8x8_t)v35, (int8x8_t)v37);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v38 = v22.i32[0];
      if (v22.i32[0] >= v16)
        v39 = v16;
      else
        v39 = v22.i32[0];
      if (v39 <= -32768)
        v39 = -32768;
      v40 = v39 + 0x8000;
      if (v22.i32[0] <= 0x8000)
        v38 = 0x8000;
      v41 = v38 - 0x8000;
      if (v41 >= v8)
        v41 = v8;
      v42 = v22.i32[1];
      if (v22.i32[1] >= v17)
        v43 = v17;
      else
        v43 = v22.i32[1];
      if (v43 <= -32768)
        v43 = -32768;
      v44 = v43 + 0x8000;
      if (v22.i32[1] <= 0x8000)
        v42 = 0x8000;
      v45 = v42 - 0x8000;
      if (v45 >= (int)v9)
        v45 = v9;
      v46 = v6 + v7 * ((uint64_t)v45 >> 16);
      v47 = v6 + v7 * HIWORD(v44);
      v48 = ((uint64_t)v41 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v49 = (v40 >> 15) & 0x1FFFE;
      v22.i16[0] = *(_WORD *)(v46 + v48);
      v22.i16[2] = *(_WORD *)(v46 + v49);
      v50 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v22, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      v51 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v50, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v50, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v22, 8uLL), (int8x8_t)0xF8000000F80000));
      v52 = (int32x2_t)vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v51, 3uLL), v20);
      v53 = vorr_s8(v51, (int8x8_t)v52);
      v52.i16[0] = *(_WORD *)(v47 + v48);
      v52.i16[2] = *(_WORD *)(v47 + v49);
      v54 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v52, (int8x8_t)0xFFFF0000FFFFLL), 1uLL);
      v55 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v54, (uint32x2_t)0x300000006), (int8x8_t)0xF80000F800), vand_s8((int8x8_t)vshl_u32(v54, (uint32x2_t)0x600000003), (int8x8_t)0xF800000000F8)), vand_s8((int8x8_t)vshl_n_s32(v52, 8uLL), (int8x8_t)0xF8000000F80000));
      v56 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(v55, vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)v55, 3uLL), v20)) | 0xFF000000FF000000), (uint8x8_t)(*(_QWORD *)&v53 | 0xFF000000FF000000)), vdupq_n_s16((v45 >> 1) & 0x7F80)), (uint8x8_t)(*(_QWORD *)&v53 | 0xFF000000FF000000));
      *(int16x4_t *)v56.i8 = vadd_s16(*(int16x4_t *)v56.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v56, v56, 8uLL), *(int16x4_t *)v56.i8), vdup_n_s16((v41 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v56.i8, *(int8x8_t *)v56.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,false,false,false,false>(uint64_t result, int a2, int *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  unsigned __int16 *v6;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 52);
    v3 = *(_DWORD *)(result + 56);
    v5 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      v6 = (unsigned __int16 *)(v5 + (((uint64_t)v4 >> 13) & 0xFFFFFFFFFFFFFFF8));
      v4 += v3;
      *a3++ = (*v6 << 8) & 0xFF0000 | (HIBYTE(v6[3]) << 24) | (*((unsigned __int8 *)v6 + 3) << 8) | *((unsigned __int8 *)v6 + 5);
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,true,false,false,false>(_DWORD *result, int a2, int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned __int16 *v9;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v6 = result[15];
    v5 = result[16];
    v8 = result[13];
    v7 = result[14];
    do
    {
      v9 = (unsigned __int16 *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 13) & 0xFFFFFFFFFFFFFFF8));
      v8 += v7;
      v6 += v5;
      *a3++ = (*v9 << 8) & 0xFF0000 | (HIBYTE(v9[3]) << 24) | (*((unsigned __int8 *)v9 + 3) << 8) | *((unsigned __int8 *)v9 + 5);
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,false,true,false,false>(_DWORD *result, int a2, int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  unsigned __int16 *v9;

  if (a2)
  {
    v3 = result[14];
    v4 = result[13];
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(_QWORD *)result + 36))
      v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v7 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5)
        v8 = v5;
      v9 = (unsigned __int16 *)(v7 + (((uint64_t)v8 >> 13) & 0xFFFFFFFFFFFFFFF8));
      v4 += v3;
      *a3++ = (*v9 << 8) & 0xFF0000 | (HIBYTE(v9[3]) << 24) | (*((unsigned __int8 *)v9 + 3) << 8) | *((unsigned __int8 *)v9 + 5);
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,true,true,false,false>(int *result, int a2, int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned __int16 *v13;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      v13 = (unsigned __int16 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 13) & 0xFFFFFFFFFFFFFFF8));
      result = (int *)*((unsigned __int8 *)v13 + 3);
      v10 += v9;
      v8 += v7;
      *a3++ = (*v13 << 8) & 0xFF0000 | (HIBYTE(v13[3]) << 24) | ((_DWORD)result << 8) | *((unsigned __int8 *)v13 + 5);
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,true,true,true,false>(uint64_t **a1, int a2, int *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  __int32 v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  __int32 v35;
  int v36;
  unsigned __int16 *v37;
  __int32 v38;
  int v39;
  uint64_t v40;
  int v41;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v41 = v13;
    v39 = v17;
    v40 = v8;
    v38 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v39;
          v8 = v40;
          v13 = v41;
          v9 = v38;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v37 = (unsigned __int16 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 13) & 0xFFFFFFFFFFFFFFF8));
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = (*v37 << 8) & 0xFF0000 | (HIBYTE(v37[3]) << 24) | (*((unsigned __int8 *)v37 + 3) << 8) | *((unsigned __int8 *)v37 + 5);
      --v4;
    }
    while (v4);
  }
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, double a6, double a7, double a8, double a9, double a10, int8x8_t a11)
{
  int16x4_t v11;
  int16x4_t v12;
  int8x8_t v13;
  int8x8_t v14;
  int8x8_t v15;
  int8x8_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  unint64_t v26;
  __int16 *v27;
  __int16 *v28;
  unint64_t v29;
  __int16 *v30;
  _WORD *v31;
  int8x8_t v32;
  int8x8_t v33;
  int8x8_t v34;
  int8x8_t v35;
  uint8x8_t v36;
  int8x16_t v37;

  if (a2)
  {
    v17 = result[14];
    v18 = result[15];
    v19 = *(_QWORD *)(*(_QWORD *)result + 16);
    v20 = **(_QWORD **)result;
    v21 = v18 + 0x8000;
    v22 = v18 - 0x8000;
    v23 = v20 + v19 * ((uint64_t)(v18 - 0x8000) >> 16);
    v24 = v20 + v19 * ((uint64_t)v21 >> 16);
    a4.i32[0] = (v22 >> 1) & 0x7F80;
    v25 = result[13] - 0x8000;
    do
    {
      v26 = ((uint64_t)v25 >> 13) & 0xFFFFFFFFFFFFFFF8;
      v27 = (__int16 *)(v23 + v26);
      v28 = (__int16 *)(v24 + v26);
      v29 = ((uint64_t)(v25 + 0x10000) >> 13) & 0xFFFFFFFFFFFFFFF8;
      v30 = (__int16 *)(v23 + v29);
      v31 = (_WORD *)(v24 + v29);
      a11.i16[0] = v27[3];
      a11.i16[2] = *v30;
      v11.i16[0] = v27[1];
      v11.i16[2] = v30[1];
      v12.i16[0] = v27[2];
      v12.i16[2] = v30[2];
      v13.i16[0] = *v27;
      v13.i16[2] = v30[3];
      result = v31 + 2;
      v14.i16[0] = v28[3];
      v14.i16[2] = *v31;
      v15.i16[0] = v28[1];
      v15.i16[2] = v31[1];
      v16.i16[0] = v28[2];
      v32 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v13, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000), vand_s8((int8x8_t)v11, (int8x8_t)0xFF000000FF00));
      v33 = vand_s8(v15, (int8x8_t)0xFF000000FF00);
      v16.i16[2] = v31[2];
      v15.i16[0] = *v28;
      v34 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000), (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v12, (int8x8_t)0xFFFF0000FFFFLL), 8uLL));
      v15.i16[2] = v31[3];
      v35 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v15, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000), v33);
      v14 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v14, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000);
      v13 = vorr_s8(v14, (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(v16, (int8x8_t)0xFFFF0000FFFFLL), 8uLL));
      v36 = (uint8x8_t)vorr_s8(v32, v34);
      v37 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(v35, v13), v36), a4, 0), v36);
      v12 = vdup_n_s16((v25 >> 1) & 0x7F80);
      v11 = vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL), *(int16x4_t *)v37.i8), v12);
      a11 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v37.i8, v11), (int8x8_t)a4);
      *a3++ = a11.i32[0];
      v25 += v17;
      --a2;
    }
    while (a2);
  }
  return result;
}

_WORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,true,false,false,true>(_WORD *result, int a2, _DWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, int8x8_t a10, int8x8_t a11)
{
  int16x4_t v11;
  int16x8_t v12;
  int8x8_t v13;
  int8x8_t v14;
  int8x8_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  __int16 *v25;
  __int16 *v26;
  unint64_t v27;
  __int16 *v28;
  __int16 *v29;
  int8x8_t v30;
  int8x8_t v31;
  int8x8_t v32;
  int8x8_t v33;
  uint32x2_t v34;
  uint8x8_t v35;
  int8x8_t v36;
  int8x16_t v37;

  if (a2)
  {
    v16 = **(_QWORD **)result;
    v17 = *(_QWORD *)(*(_QWORD *)result + 16);
    v18 = *((_DWORD *)result + 16);
    v19 = *((_DWORD *)result + 14);
    v20 = *((_DWORD *)result + 13) - 0x8000;
    v21 = *((_DWORD *)result + 15) - 0x8000;
    do
    {
      v22 = v16 + v17 * ((uint64_t)v21 >> 16);
      v23 = v16 + v17 * ((uint64_t)(v21 + 0x10000) >> 16);
      v24 = ((uint64_t)v20 >> 13) & 0xFFFFFFFFFFFFFFF8;
      v25 = (__int16 *)(v22 + v24);
      v26 = (__int16 *)(v23 + v24);
      v27 = ((uint64_t)(v20 + 0x10000) >> 13) & 0xFFFFFFFFFFFFFFF8;
      v28 = (__int16 *)(v22 + v27);
      v29 = (__int16 *)(v23 + v27);
      a10.i16[0] = v25[3];
      a11.i16[0] = v25[1];
      a10.i16[2] = *v28;
      a11.i16[2] = v28[1];
      v11.i16[0] = v25[2];
      v11.i16[2] = v28[2];
      v12.i16[0] = *v25;
      v12.i16[2] = v28[3];
      v13.i16[0] = v26[3];
      result = v29 + 2;
      v13.i16[2] = *v29;
      v14.i16[0] = v26[1];
      v14.i16[2] = v29[1];
      v15.i16[0] = v26[2];
      v30 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(*(int8x8_t *)v12.i8, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000), vand_s8(a11, (int8x8_t)0xFF000000FF00));
      v31 = vand_s8(v14, (int8x8_t)0xFF000000FF00);
      v15.i16[2] = v29[2];
      v14.i16[0] = *v26;
      v32 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(a10, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000), (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v11, (int8x8_t)0xFFFF0000FFFFLL), 8uLL));
      v14.i16[2] = v29[3];
      v33 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v14, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000), v31);
      v34 = (uint32x2_t)vand_s8(v13, (int8x8_t)0xFFFF0000FFFFLL);
      v13 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(v15, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v35 = (uint8x8_t)vorr_s8(v30, v32);
      v36 = vorr_s8(vand_s8((int8x8_t)vshl_u32(v34, (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000), v13);
      v12 = vdupq_n_s16((v21 >> 1) & 0x7F80);
      v37 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(v33, v36), v35), v12), v35);
      v11 = vdup_n_s16((v20 >> 1) & 0x7F80);
      a11 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL), *(int16x4_t *)v37.i8), v11);
      a10 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v37.i8, (int16x4_t)a11), (int8x8_t)0xFFFF0000FFFFLL);
      *a3++ = a10.i32[0];
      v20 += v19;
      v21 += v18;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, double a6, double a7, double a8, double a9, double a10, int8x8_t a11)
{
  int16x4_t v11;
  int16x4_t v12;
  int8x8_t v13;
  int8x8_t v14;
  int8x8_t v15;
  int8x8_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  unsigned int v31;
  int v32;
  unint64_t v33;
  __int16 *v34;
  __int16 *v35;
  uint64_t v36;
  __int16 *v37;
  int8x8_t v38;
  uint8x8_t v39;
  int8x16_t v40;

  if (a2)
  {
    v17 = result[14];
    v18 = result[15];
    v19 = result[13];
    v20 = *(_DWORD *)(*(_QWORD *)result + 32);
    v21 = *(_DWORD *)(*(_QWORD *)result + 36);
    v22 = *(_QWORD *)(*(_QWORD *)result + 16);
    v23 = **(_QWORD **)result;
    if (v18 >= v21 - 0x8000)
      v24 = v21 - 0x8000;
    else
      v24 = result[15];
    if (v24 <= -32768)
      v24 = -32768;
    if (v18 <= 0x8000)
      v18 = 0x8000;
    v25 = v18 - 0x8000;
    if (v25 >= v21)
      v26 = *(_DWORD *)(*(_QWORD *)result + 36);
    else
      v26 = v25;
    v27 = v23 + v22 * ((uint64_t)v26 >> 16);
    v28 = v23 + v22 * ((v24 + 0x8000) >> 16);
    a4.i32[0] = (v26 >> 1) & 0x7F80;
    do
    {
      if (v19 >= v20 - 0x8000)
        v29 = v20 - 0x8000;
      else
        v29 = v19;
      if (v29 <= -32768)
        v29 = -32768;
      if (v19 <= 0x8000)
        v30 = 0x8000;
      else
        v30 = v19;
      v31 = v29 + 0x8000;
      v32 = v30 - 0x8000;
      if (v30 - 0x8000 >= v20)
        v32 = v20;
      v33 = ((uint64_t)v32 >> 13) & 0xFFFFFFFFFFFFFFF8;
      v34 = (__int16 *)(v27 + v33);
      v35 = (__int16 *)(v28 + v33);
      v36 = (v31 >> 13) & 0x7FFF8;
      v37 = (__int16 *)(v27 + v36);
      result = (_DWORD *)(v28 + v36);
      a11.i16[0] = v34[3];
      a11.i16[2] = *v37;
      v11.i16[0] = v34[1];
      v11.i16[2] = v37[1];
      v12.i16[0] = v34[2];
      v12.i16[2] = v37[2];
      v13.i16[0] = *v34;
      v13.i16[2] = v37[3];
      v14.i16[0] = v35[3];
      v14.i16[2] = *(_WORD *)result;
      v15.i16[0] = v35[1];
      v15.i16[2] = *((_WORD *)result + 1);
      v15 = vand_s8(v15, (int8x8_t)0xFF000000FF00);
      v16.i16[0] = *v35;
      v16.i16[2] = *((_WORD *)result + 3);
      v16 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v16, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000);
      v38 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v13, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000), vand_s8((int8x8_t)v11, (int8x8_t)0xFF000000FF00));
      v13 = vorr_s8(v16, v15);
      v15.i16[0] = v35[2];
      v15.i16[2] = *((_WORD *)result + 2);
      v14 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v14, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000);
      v39 = (uint8x8_t)vorr_s8(v38, vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000), (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v12, (int8x8_t)0xFFFF0000FFFFLL), 8uLL)));
      v40 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(v13, vorr_s8(v14, (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(v15, (int8x8_t)0xFFFF0000FFFFLL), 8uLL))), v39), a4, 0), v39);
      v12 = vdup_n_s16((v32 >> 1) & 0x7F80);
      v11 = vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v40, v40, 8uLL), *(int16x4_t *)v40.i8), v12);
      a11 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v40.i8, v11), (int8x8_t)a4);
      v19 += v17;
      *a3++ = a11.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, int8x8_t a10, int8x8_t a11)
{
  int16x4_t v11;
  int16x8_t v12;
  int8x8_t v13;
  int8x8_t v14;
  int8x8_t v15;
  int8x8_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  __int16 *v36;
  __int16 *v37;
  uint64_t v38;
  __int16 *v39;
  __int16 *v40;
  int8x8_t v41;
  uint8x8_t v42;
  int8x16_t v43;

  if (a2)
  {
    v17 = **(_QWORD **)result;
    v18 = *(_QWORD *)(*(_QWORD *)result + 16);
    v19 = *(_DWORD *)(*(_QWORD *)result + 32);
    v20 = *(_DWORD *)(*(_QWORD *)result + 36);
    v22 = *(_DWORD *)(result + 60);
    v21 = *(_DWORD *)(result + 64);
    v24 = *(_DWORD *)(result + 52);
    v23 = *(_DWORD *)(result + 56);
    result = 4294934528;
    do
    {
      if (v24 >= v19 - 0x8000)
        v25 = v19 - 0x8000;
      else
        v25 = v24;
      if (v25 <= -32768)
        v26 = -32768;
      else
        v26 = v25;
      if (v24 <= 0x8000)
        v27 = 0x8000;
      else
        v27 = v24;
      v28 = v27 - 0x8000;
      if (v28 >= v19)
        v28 = v19;
      if (v22 >= v20 - 0x8000)
        v29 = v20 - 0x8000;
      else
        v29 = v22;
      if (v29 <= -32768)
        v29 = -32768;
      v30 = v29 + 0x8000;
      if (v22 <= 0x8000)
        v31 = 0x8000;
      else
        v31 = v22;
      v32 = v31 - 0x8000;
      if (v32 >= v20)
        v32 = v20;
      v33 = v17 + v18 * ((uint64_t)v32 >> 16);
      v34 = v17 + v18 * HIWORD(v30);
      v35 = ((uint64_t)v28 >> 13) & 0xFFFFFFFFFFFFFFF8;
      v36 = (__int16 *)(v33 + v35);
      v37 = (__int16 *)(v34 + v35);
      v38 = ((v26 + 0x8000) >> 13) & 0x7FFF8;
      v39 = (__int16 *)(v34 + v38);
      v40 = (__int16 *)(v33 + v38);
      a10.i16[0] = v36[3];
      a11.i16[0] = *v36;
      v11.i16[0] = v36[1];
      v12.i16[0] = v36[2];
      v13.i16[0] = v37[3];
      a10.i16[2] = *v40;
      v13.i16[2] = *v39;
      v14.i16[0] = v37[1];
      v11.i16[2] = v40[1];
      v14.i16[2] = v39[1];
      v15.i16[0] = v37[2];
      v12.i16[2] = v40[2];
      v15.i16[2] = v39[2];
      v16.i16[0] = *v37;
      v16.i16[2] = v39[3];
      v16 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v16, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000);
      v14 = vorr_s8(v16, vand_s8(v14, (int8x8_t)0xFF000000FF00));
      v15 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(v15, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v13 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v13, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000), v15);
      a11.i16[2] = v40[3];
      v41 = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(a10, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000), (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(*(int8x8_t *)v12.i8, (int8x8_t)0xFFFF0000FFFFLL), 8uLL));
      v12 = vdupq_n_s16((v32 >> 1) & 0x7F80);
      v42 = (uint8x8_t)vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000), vand_s8((int8x8_t)v11, (int8x8_t)0xFF000000FF00)), v41);
      v43 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(v14, v13), v42), v12), v42);
      v11 = vdup_n_s16((v28 >> 1) & 0x7F80);
      a11 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL), *(int16x4_t *)v43.i8), v11);
      a10 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v43.i8, (int16x4_t)a11), (int8x8_t)0xFFFF0000FFFFLL);
      v24 += v23;
      v22 += v21;
      *a3++ = a10.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBA16,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3, double a4, double a5, double a6, int8x8_t a7, int8x8_t a8)
{
  int v9;
  float *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float v15;
  float v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  float v23;
  int v24;
  float32x2_t v25;
  int32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  uint64_t **v31;
  float *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  float v37;
  float32x2_t v38;
  float32x2_t v39;
  float32x2_t v40;
  float32x2_t v41;
  float32x2_t v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  int v47;
  int v48;
  unsigned int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  __int16 *v54;
  __int16 *v55;
  uint64_t v56;
  __int16 *v57;
  __int16 *v58;
  int8x8_t v59;
  int8x8_t v60;
  int8x8_t v61;
  uint8x8_t v62;
  int8x16_t v63;
  float32x2_t v64;
  float32x2_t v65;
  float32x2_t v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;

  if (a2)
  {
    v9 = a2;
    v10 = (float *)*result;
    v11 = **result;
    v12 = (*result)[2];
    v13 = *((unsigned int *)*result + 8);
    v14 = *((unsigned int *)*result + 9);
    v15 = *((float *)result[3] + 3);
    v16 = *((float *)result[2] + 3);
    v18 = *((_DWORD *)result + 15);
    v17 = *((_DWORD *)result + 16);
    v20 = *((_DWORD *)result + 13);
    v19 = *((_DWORD *)result + 14);
    v21 = v13 - 0x8000;
    v22 = v14 - 0x8000;
    v23 = 1.0;
    v24 = *((unsigned __int8 *)result + 48) - 1;
    v65 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v66 = (float32x2_t)vdup_n_s32(0x37800000u);
    v64 = (float32x2_t)vdup_n_s32(0x47800000u);
    v70 = v19;
    v71 = v17;
    v68 = v14 - 0x8000;
    v69 = v13 - 0x8000;
    v67 = v24;
    do
    {
      *(float *)&a6 = (float)v18;
      v25.f32[0] = (float)(v23 / v16) * (float)v20;
      v25.f32[1] = (float)(v23 / v16) * (float)v18;
      v26 = vcvt_s32_f32(v25);
      switch(v24)
      {
        case 0:
          v27 = vmul_f32(*(float32x2_t *)(v10 + 10), vcvt_f32_s32(v26));
          v28 = vmul_f32(v27, v27);
          v29 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 1), v28);
          v28.f32[0] = fmaxf(vaddv_f32(v28), 0.00001);
          v28.i32[0] = vmul_f32(v29, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v28, 0))).u32[0];
          v25 = vcvt_f32_u32(*(uint32x2_t *)(v10 + 6));
          LODWORD(a6) = 0.5;
          v28.i32[1] = 0.5;
          v30 = vmul_f32(v28, v25);
          goto LABEL_8;
        case 1:
          v31 = result;
          v32 = v10;
          v33 = v11;
          v34 = v12;
          v35 = v13;
          v36 = v14;
          v37 = atan2f(v10[11] * (float)v26.i32[1], v10[10] * (float)v26.i32[0]);
          v23 = 1.0;
          v14 = v36;
          v13 = v35;
          v19 = v70;
          v17 = v71;
          v12 = v34;
          v11 = v33;
          v10 = v32;
          v22 = v68;
          v21 = v69;
          result = v31;
          v24 = v67;
          v25 = vcvt_f32_u32(*(uint32x2_t *)(v10 + 6));
          HIDWORD(a6) = 1056964608;
          *(float *)&a6 = (float)(v37 * -10430.0) + 32768.0;
          v30 = vmul_f32(*(float32x2_t *)&a6, v25);
          goto LABEL_8;
        case 2:
          v38 = vmul_f32(vcvt_f32_s32(v26), vmul_f32(v66, *(float32x2_t *)(v10 + 10)));
          a6 = COERCE_DOUBLE(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v38, vrndm_f32(v38)), v65)));
          v25 = v64;
          v30 = vmul_f32(*(float32x2_t *)&a6, vmul_f32(v64, vcvt_f32_u32(*(uint32x2_t *)(v10 + 6))));
          goto LABEL_8;
        case 4:
          v39 = vcvt_f32_s32(v26);
          v40 = vcvt_f32_s32(*(int32x2_t *)(v10 + 8));
          v25 = vmul_f32(*(float32x2_t *)((char *)result + 84), v40);
          v41 = vmul_f32(*(float32x2_t *)((char *)result + 92), v40);
          a7 = (int8x8_t)vcgt_f32(v39, v41);
          v42 = (float32x2_t)vbsl_s8(a7, (int8x8_t)v41, (int8x8_t)v39);
          a6 = COERCE_DOUBLE(vcgt_f32(v25, v42));
          v30 = (float32x2_t)vbsl_s8(*(int8x8_t *)&a6, (int8x8_t)v25, (int8x8_t)v42);
LABEL_8:
          v26 = vcvt_s32_f32(v30);
          break;
        default:
          break;
      }
      v43 = v26.i32[0];
      if (v26.i32[0] >= v21)
        v44 = v21;
      else
        v44 = v26.i32[0];
      if (v44 <= -32768)
        v44 = -32768;
      v45 = v44 + 0x8000;
      if (v26.i32[0] <= 0x8000)
        v43 = 0x8000;
      v46 = v43 - 0x8000;
      v47 = v26.i32[1];
      if (v46 >= (int)v13)
        v46 = v13;
      if (v26.i32[1] >= v22)
        v48 = v22;
      else
        v48 = v26.i32[1];
      if (v48 <= -32768)
        v48 = -32768;
      v49 = v48 + 0x8000;
      if (v26.i32[1] <= 0x8000)
        v47 = 0x8000;
      v50 = v47 - 0x8000;
      if (v50 >= (int)v14)
        v50 = v14;
      v51 = v11 + v12 * ((uint64_t)v50 >> 16);
      v52 = v11 + v12 * HIWORD(v49);
      v53 = ((uint64_t)v46 >> 13) & 0xFFFFFFFFFFFFFFF8;
      v54 = (__int16 *)(v51 + v53);
      v55 = (__int16 *)(v52 + v53);
      v56 = (v45 >> 13) & 0x7FFF8;
      v57 = (__int16 *)(v51 + v56);
      v58 = (__int16 *)(v52 + v56);
      v26.i16[0] = v54[3];
      v26.i16[2] = *v57;
      v25.i16[0] = v54[1];
      v25.i16[2] = v57[1];
      LOWORD(a6) = v54[2];
      WORD2(a6) = v57[2];
      a7.i16[0] = *v54;
      a7.i16[2] = v57[3];
      v59 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(*(int8x8_t *)&a6, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v60 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(a7, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000);
      v61 = vorr_s8(v60, vand_s8((int8x8_t)v25, (int8x8_t)0xFF000000FF00));
      v62 = (uint8x8_t)vorr_s8(v61, vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8((int8x8_t)v26, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000), v59));
      v61.i16[0] = v55[3];
      v61.i16[2] = *v58;
      v59.i16[0] = v55[1];
      v59.i16[2] = v58[1];
      v60.i16[0] = v55[2];
      v60.i16[2] = v58[2];
      a7 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(v60, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      a8.i16[0] = *v55;
      a8.i16[2] = v58[3];
      a8 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(a8, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF0000);
      v63 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8(a8, vand_s8(v59, (int8x8_t)0xFF000000FF00)), vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v61, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0x800000010), (int8x8_t)0xFFFF0000FF000000), a7)), v62), vdupq_n_s16((v50 >> 1) & 0x7F80)), v62);
      a6 = COERCE_DOUBLE(vdup_n_s16((v46 >> 1) & 0x7F80));
      *(int16x4_t *)v63.i8 = vadd_s16(*(int16x4_t *)v63.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v63, v63, 8uLL), *(int16x4_t *)v63.i8), *(int16x4_t *)&a6));
      v16 = v16 + v15;
      v20 += v19;
      v18 += v17;
      *a3++ = vuzp1_s8(*(int8x8_t *)v63.i8, *(int8x8_t *)v63.i8).u32[0];
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  unsigned int v6;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 52);
    v3 = *(_DWORD *)(result + 56);
    v5 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      v6 = (*(unsigned __int16 *)(v5 + (((uint64_t)v4 >> 13) & 0xFFFFFFFFFFFFFFF8)) << 8) & 0xFF0000 | (*(unsigned __int8 *)(v5 + (((uint64_t)v4 >> 13) & 0xFFFFFFFFFFFFFFF8) + 3) << 8) | *(unsigned __int8 *)(v5 + (((uint64_t)v4 >> 13) & 0xFFFFFFFFFFFFFFF8) + 5) | 0xFF000000;
      v4 += v3;
      *a3++ = v6;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned __int16 *v9;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v6 = result[15];
    v5 = result[16];
    v8 = result[13];
    v7 = result[14];
    do
    {
      v9 = (unsigned __int16 *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 13) & 0xFFFFFFFFFFFFFFF8));
      v8 += v7;
      v6 += v5;
      *a3++ = (*v9 << 8) & 0xFF0000 | (*((unsigned __int8 *)v9 + 3) << 8) | *((unsigned __int8 *)v9 + 5) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;

  if (a2)
  {
    v3 = result[14];
    v4 = result[13];
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(_QWORD *)result + 36))
      v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v7 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5)
        v8 = v5;
      v4 += v3;
      *a3++ = (*(unsigned __int16 *)(v7 + (((uint64_t)v8 >> 13) & 0xFFFFFFFFFFFFFFF8)) << 8) & 0xFF0000 | (*(unsigned __int8 *)(v7 + (((uint64_t)v8 >> 13) & 0xFFFFFFFFFFFFFFF8) + 3) << 8) | *(unsigned __int8 *)(v7 + (((uint64_t)v8 >> 13) & 0xFFFFFFFFFFFFFFF8) + 5) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned __int16 *v13;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      v13 = (unsigned __int16 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 13) & 0xFFFFFFFFFFFFFFF8));
      result = (int *)*((unsigned __int8 *)v13 + 3);
      v10 += v9;
      v8 += v7;
      *a3++ = (*v13 << 8) & 0xFF0000 | ((_DWORD)result << 8) | *((unsigned __int8 *)v13 + 5) | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  __int32 v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  __int32 v35;
  int v36;
  unsigned __int16 *v37;
  __int32 v38;
  int v39;
  uint64_t v40;
  int v41;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v41 = v13;
    v39 = v17;
    v40 = v8;
    v38 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v39;
          v8 = v40;
          v13 = v41;
          v9 = v38;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v37 = (unsigned __int16 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 13) & 0xFFFFFFFFFFFFFFF8));
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = (*v37 << 8) & 0xFF0000 | (*((unsigned __int8 *)v37 + 3) << 8) | *((unsigned __int8 *)v37 + 5) | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, double a6, int8x8_t a7, int8x8_t a8, int8x8_t a9, int8x8_t a10, int8x8_t a11)
{
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  unint64_t v20;
  __int16 *v21;
  __int16 *v22;
  unint64_t v23;
  _WORD *v24;
  __int16 *v25;
  int8x8_t v26;
  int8x8_t v27;
  int8x8_t v28;
  int8x16_t v29;

  if (a2)
  {
    v11 = result[14];
    v12 = result[15];
    v13 = *(_QWORD *)(*(_QWORD *)result + 16);
    v14 = **(_QWORD **)result;
    v15 = v12 + 0x8000;
    v16 = v12 - 0x8000;
    v17 = v14 + v13 * ((uint64_t)(v12 - 0x8000) >> 16);
    v18 = v14 + v13 * ((uint64_t)v15 >> 16);
    a4.i32[0] = (v16 >> 1) & 0x7F80;
    v19 = result[13] - 0x8000;
    do
    {
      v20 = ((uint64_t)v19 >> 13) & 0xFFFFFFFFFFFFFFF8;
      v21 = (__int16 *)(v17 + v20);
      v22 = (__int16 *)(v18 + v20);
      v23 = ((uint64_t)(v19 + 0x10000) >> 13) & 0xFFFFFFFFFFFFFFF8;
      v24 = (_WORD *)(v17 + v23);
      v25 = (__int16 *)(v18 + v23);
      result = v24 + 1;
      a7.i16[0] = *v21;
      a7.i16[2] = *v24;
      a8.i16[0] = v21[1];
      a8.i16[2] = v24[1];
      a9.i16[0] = v21[2];
      a9.i16[2] = v24[2];
      v26 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(a9, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      a10.i16[0] = *v22;
      a10.i16[2] = *v25;
      a10 = vand_s8(a10, (int8x8_t)0xFFFF0000FFFFLL);
      a11.i16[0] = v22[1];
      a11.i16[2] = v25[1];
      a11 = vand_s8(a11, (int8x8_t)0xFF000000FF00);
      v27 = vorr_s8(vand_s8(a8, (int8x8_t)0xFF000000FF00), v26);
      v26.i16[0] = v22[2];
      v26.i16[2] = v25[2];
      v28 = vorr_s8((int8x8_t)(*(_QWORD *)&vshl_n_s32((int32x2_t)vand_s8(a7, (int8x8_t)0xFFFF0000FFFFLL), 8uLL) & 0xFFFF00FFFFFF00FFLL), v27);
      v29 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8((int8x8_t)(*(_QWORD *)&vshl_n_s32((int32x2_t)a10, 8uLL) & 0xFFFF00FFFFFF00FFLL), vorr_s8(a11, (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(v26, (int8x8_t)0xFFFF0000FFFFLL), 8uLL))) | 0xFF000000FF000000), (uint8x8_t)(*(_QWORD *)&v28 | 0xFF000000FF000000)), a4, 0), (uint8x8_t)(*(_QWORD *)&v28 | 0xFF000000FF000000));
      a9 = (int8x8_t)vdup_n_s16((v19 >> 1) & 0x7F80);
      a8 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL), *(int16x4_t *)v29.i8), (int16x4_t)a9);
      a7 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v29.i8, (int16x4_t)a8), (int8x8_t)a4);
      *a3++ = a7.i32[0];
      v19 += v11;
      --a2;
    }
    while (a2);
  }
  return result;
}

_WORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,true,false,false,true>(_WORD *result, int a2, _DWORD *a3, double a4, double a5, int8x8_t a6, int8x8_t a7, int8x8_t a8, int8x8_t a9, int8x8_t a10)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  __int16 *v19;
  __int16 *v20;
  unint64_t v21;
  __int16 *v22;
  __int16 *v23;
  int8x8_t v24;
  int8x8_t v25;
  int8x8_t v26;
  int8x16_t v27;

  if (a2)
  {
    v10 = **(_QWORD **)result;
    v11 = *(_QWORD *)(*(_QWORD *)result + 16);
    v12 = *((_DWORD *)result + 16);
    v13 = *((_DWORD *)result + 14);
    v14 = *((_DWORD *)result + 13) - 0x8000;
    v15 = *((_DWORD *)result + 15) - 0x8000;
    do
    {
      v16 = v10 + v11 * ((uint64_t)v15 >> 16);
      v17 = v10 + v11 * ((uint64_t)(v15 + 0x10000) >> 16);
      v18 = ((uint64_t)v14 >> 13) & 0xFFFFFFFFFFFFFFF8;
      v19 = (__int16 *)(v16 + v18);
      v20 = (__int16 *)(v17 + v18);
      v21 = ((uint64_t)(v14 + 0x10000) >> 13) & 0xFFFFFFFFFFFFFFF8;
      v22 = (__int16 *)(v16 + v21);
      v23 = (__int16 *)(v17 + v21);
      a6.i16[0] = *v19;
      a6.i16[2] = *v22;
      a7.i16[0] = v19[1];
      a7.i16[2] = v22[1];
      a8.i16[0] = v19[2];
      a8.i16[2] = v22[2];
      result = v23 + 1;
      a9.i16[0] = *v20;
      a9.i16[2] = *v23;
      a10.i16[0] = v20[1];
      a10.i16[2] = v23[1];
      v24 = vorr_s8(vand_s8(a7, (int8x8_t)0xFF000000FF00), (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(a8, (int8x8_t)0xFFFF0000FFFFLL), 8uLL));
      v25 = vand_s8(a10, (int8x8_t)0xFF000000FF00);
      a10.i16[0] = v20[2];
      a10.i16[2] = v23[2];
      v26 = vorr_s8((int8x8_t)(*(_QWORD *)&vshl_n_s32((int32x2_t)vand_s8(a6, (int8x8_t)0xFFFF0000FFFFLL), 8uLL) & 0xFFFF00FFFFFF00FFLL), v24);
      a9 = (int8x8_t)(*(_QWORD *)&vshl_n_s32((int32x2_t)vand_s8(a9, (int8x8_t)0xFFFF0000FFFFLL), 8uLL) & 0xFFFF00FFFFFF00FFLL);
      v27 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(a9, vorr_s8(v25, (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(a10, (int8x8_t)0xFFFF0000FFFFLL), 8uLL))) | 0xFF000000FF000000), (uint8x8_t)(*(_QWORD *)&v26 | 0xFF000000FF000000)), vdupq_n_s16((v15 >> 1) & 0x7F80)), (uint8x8_t)(*(_QWORD *)&v26 | 0xFF000000FF000000));
      a8 = (int8x8_t)vdup_n_s16((v14 >> 1) & 0x7F80);
      a7 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), *(int16x4_t *)v27.i8), (int16x4_t)a8);
      a6 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v27.i8, (int16x4_t)a7), (int8x8_t)0xFFFF0000FFFFLL);
      *a3++ = a6.i32[0];
      v14 += v13;
      v15 += v12;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, double a6, int8x8_t a7, int8x8_t a8, int8x8_t a9, int8x8_t a10, int8x8_t a11)
{
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  unint64_t v27;
  __int16 *v28;
  __int16 *v29;
  uint64_t v30;
  __int16 *v31;
  int8x8_t v32;
  int8x8_t v33;
  int8x8_t v34;
  int8x16_t v35;

  if (a2)
  {
    v11 = result[14];
    v12 = result[15];
    v13 = result[13];
    v14 = *(_DWORD *)(*(_QWORD *)result + 32);
    v15 = *(_DWORD *)(*(_QWORD *)result + 36);
    v16 = *(_QWORD *)(*(_QWORD *)result + 16);
    v17 = **(_QWORD **)result;
    if (v12 >= v15 - 0x8000)
      v18 = v15 - 0x8000;
    else
      v18 = result[15];
    if (v18 <= -32768)
      v18 = -32768;
    if (v12 <= 0x8000)
      v12 = 0x8000;
    v19 = v12 - 0x8000;
    if (v19 >= v15)
      v20 = *(_DWORD *)(*(_QWORD *)result + 36);
    else
      v20 = v19;
    v21 = v17 + v16 * ((uint64_t)v20 >> 16);
    v22 = v17 + v16 * ((v18 + 0x8000) >> 16);
    a4.i32[0] = (v20 >> 1) & 0x7F80;
    do
    {
      if (v13 >= v14 - 0x8000)
        v23 = v14 - 0x8000;
      else
        v23 = v13;
      if (v23 <= -32768)
        v23 = -32768;
      if (v13 <= 0x8000)
        v24 = 0x8000;
      else
        v24 = v13;
      v25 = v23 + 0x8000;
      v26 = v24 - 0x8000;
      if (v24 - 0x8000 >= v14)
        v26 = v14;
      v27 = ((uint64_t)v26 >> 13) & 0xFFFFFFFFFFFFFFF8;
      v28 = (__int16 *)(v21 + v27);
      v29 = (__int16 *)(v22 + v27);
      v30 = (v25 >> 13) & 0x7FFF8;
      v31 = (__int16 *)(v21 + v30);
      result = (_DWORD *)(v22 + v30);
      a7.i16[0] = *v28;
      a7.i16[2] = *v31;
      a8.i16[0] = v28[1];
      a8.i16[2] = v31[1];
      a9.i16[0] = v28[2];
      a9.i16[2] = v31[2];
      v32 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(a9, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      a10.i16[0] = *v29;
      a10.i16[2] = *(_WORD *)result;
      a10 = vand_s8(a10, (int8x8_t)0xFFFF0000FFFFLL);
      a11.i16[0] = v29[1];
      a11.i16[2] = *((_WORD *)result + 1);
      a11 = vand_s8(a11, (int8x8_t)0xFF000000FF00);
      v33 = vorr_s8(vand_s8(a8, (int8x8_t)0xFF000000FF00), v32);
      v32.i16[0] = v29[2];
      v32.i16[2] = *((_WORD *)result + 2);
      v34 = vorr_s8((int8x8_t)(*(_QWORD *)&vshl_n_s32((int32x2_t)vand_s8(a7, (int8x8_t)0xFFFF0000FFFFLL), 8uLL) & 0xFFFF00FFFFFF00FFLL), v33);
      v35 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8((int8x8_t)(*(_QWORD *)&vshl_n_s32((int32x2_t)a10, 8uLL) & 0xFFFF00FFFFFF00FFLL), vorr_s8(a11, (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(v32, (int8x8_t)0xFFFF0000FFFFLL), 8uLL))) | 0xFF000000FF000000), (uint8x8_t)(*(_QWORD *)&v34 | 0xFF000000FF000000)), a4, 0), (uint8x8_t)(*(_QWORD *)&v34 | 0xFF000000FF000000));
      a9 = (int8x8_t)vdup_n_s16((v26 >> 1) & 0x7F80);
      a8 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL), *(int16x4_t *)v35.i8), (int16x4_t)a9);
      a7 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v35.i8, (int16x4_t)a8), (int8x8_t)a4);
      v13 += v11;
      *a3++ = a7.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, int8x8_t a6, int8x8_t a7, int8x8_t a8, int8x8_t a9, int8x8_t a10)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  __int16 *v30;
  __int16 *v31;
  uint64_t v32;
  __int16 *v33;
  __int16 *v34;
  int8x8_t v35;
  int8x16_t v36;

  if (a2)
  {
    v10 = **(_QWORD **)result;
    v11 = *(_QWORD *)(*(_QWORD *)result + 16);
    v12 = *(_DWORD *)(*(_QWORD *)result + 32);
    v13 = *(_DWORD *)(*(_QWORD *)result + 36);
    v15 = *(_DWORD *)(result + 60);
    v14 = *(_DWORD *)(result + 64);
    v17 = *(_DWORD *)(result + 52);
    v16 = *(_DWORD *)(result + 56);
    result = 4294934528;
    do
    {
      if (v17 >= v12 - 0x8000)
        v18 = v12 - 0x8000;
      else
        v18 = v17;
      if (v18 <= -32768)
        v19 = -32768;
      else
        v19 = v18;
      if (v17 <= 0x8000)
        v20 = 0x8000;
      else
        v20 = v17;
      v21 = v20 - 0x8000;
      if (v21 >= v12)
        v21 = v12;
      if (v15 >= v13 - 0x8000)
        v22 = v13 - 0x8000;
      else
        v22 = v15;
      if (v22 <= -32768)
        v22 = -32768;
      v23 = v22 + 0x8000;
      if (v15 <= 0x8000)
        v24 = 0x8000;
      else
        v24 = v15;
      v25 = v24 - 0x8000;
      if (v25 >= v13)
        v25 = v13;
      v26 = v19 + 0x8000;
      v27 = v10 + v11 * ((uint64_t)v25 >> 16);
      v28 = v10 + v11 * HIWORD(v23);
      v29 = ((uint64_t)v21 >> 13) & 0xFFFFFFFFFFFFFFF8;
      v30 = (__int16 *)(v27 + v29);
      v31 = (__int16 *)(v28 + v29);
      v32 = (v26 >> 13) & 0x7FFF8;
      v33 = (__int16 *)(v28 + v32);
      v34 = (__int16 *)(v27 + v32);
      a6.i16[0] = *v30;
      a6.i16[2] = *v34;
      a7.i16[0] = v30[1];
      a7.i16[2] = v34[1];
      a8.i16[0] = v30[2];
      a8.i16[2] = v34[2];
      a9.i16[0] = v31[1];
      a9.i16[2] = v33[1];
      a10.i16[0] = v31[2];
      a10.i16[2] = v33[2];
      a10 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(a10, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      a9 = vorr_s8(vand_s8(a9, (int8x8_t)0xFF000000FF00), a10);
      a10.i16[0] = *v31;
      a10.i16[2] = *v33;
      v35 = vorr_s8((int8x8_t)(*(_QWORD *)&vshl_n_s32((int32x2_t)vand_s8(a6, (int8x8_t)0xFFFF0000FFFFLL), 8uLL) & 0xFFFF00FFFFFF00FFLL), vorr_s8(vand_s8(a7, (int8x8_t)0xFF000000FF00), (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(a8, (int8x8_t)0xFFFF0000FFFFLL), 8uLL)));
      v36 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8((int8x8_t)(*(_QWORD *)&vshl_n_s32((int32x2_t)vand_s8(a10, (int8x8_t)0xFFFF0000FFFFLL), 8uLL) & 0xFFFF00FFFFFF00FFLL), a9) | 0xFF000000FF000000), (uint8x8_t)(*(_QWORD *)&v35 | 0xFF000000FF000000)), vdupq_n_s16((v25 >> 1) & 0x7F80)), (uint8x8_t)(*(_QWORD *)&v35 | 0xFF000000FF000000));
      a8 = (int8x8_t)vdup_n_s16((v21 >> 1) & 0x7F80);
      a7 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL), *(int16x4_t *)v36.i8), (int16x4_t)a8);
      a6 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v36.i8, (int16x4_t)a7), (int8x8_t)0xFFFF0000FFFFLL);
      v17 += v16;
      v15 += v14;
      *a3++ = a6.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::RGBX16,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3, double a4, double a5, double a6, int8x8_t a7)
{
  int v8;
  uint32x2_t *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  float v14;
  float v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  int32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  uint64_t **v32;
  uint32x2_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  float v37;
  float32x2_t v38;
  float32x2_t v39;
  float32x2_t v40;
  float32x2_t v41;
  float32x2_t v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  int v47;
  int v48;
  unsigned int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  __int16 *v54;
  __int16 *v55;
  uint64_t v56;
  __int16 *v57;
  __int16 *v58;
  int8x8_t v59;
  int8x8_t v60;
  int8x8_t v61;
  int8x16_t v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;

  if (a2)
  {
    v8 = a2;
    v9 = (uint32x2_t *)*result;
    v10 = **result;
    v11 = (*result)[2];
    v12 = *((_DWORD *)*result + 8);
    v13 = *((unsigned int *)*result + 9);
    v14 = *((float *)result[3] + 3);
    v15 = *((float *)result[2] + 3);
    v17 = *((_DWORD *)result + 15);
    v16 = *((_DWORD *)result + 16);
    v19 = *((_DWORD *)result + 13);
    v18 = *((unsigned int *)result + 14);
    v20 = v12 - 0x8000;
    v21 = v13 - 0x8000;
    v22 = *((unsigned __int8 *)result + 48) - 1;
    v23 = (float32x2_t)vdup_n_s32(0x37800000u);
    v24 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v25 = (float32x2_t)vdup_n_s32(0x47800000u);
    v66 = v12;
    v67 = v16;
    v64 = v13 - 0x8000;
    v65 = v12 - 0x8000;
    v63 = v22;
    do
    {
      *(float *)&a6 = (float)v17;
      v26.f32[0] = (float)(1.0 / v15) * (float)v19;
      v26.f32[1] = (float)(1.0 / v15) * (float)v17;
      v27 = vcvt_s32_f32(v26);
      switch(v22)
      {
        case 0:
          v28 = vmul_f32((float32x2_t)v9[5], vcvt_f32_s32(v27));
          v29 = vmul_f32(v28, v28);
          v30 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v29, 1), v29);
          v29.f32[0] = fmaxf(vaddv_f32(v29), 0.00001);
          v29.i32[0] = vmul_f32(v30, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v29, 0))).u32[0];
          v26 = vcvt_f32_u32(v9[3]);
          LODWORD(a6) = 0.5;
          v29.i32[1] = 0.5;
          v31 = vmul_f32(v29, v26);
          goto LABEL_8;
        case 1:
          v32 = result;
          v33 = v9;
          v34 = v10;
          v35 = v13;
          v36 = v18;
          v37 = atan2f(*(float *)&v9[5].i32[1] * (float)v27.i32[1], *(float *)v9[5].i32 * (float)v27.i32[0]);
          v18 = v36;
          v21 = v64;
          v20 = v65;
          v12 = v66;
          v16 = v67;
          v13 = v35;
          v22 = v63;
          v10 = v34;
          v9 = v33;
          result = v32;
          v26 = vcvt_f32_u32(v33[3]);
          HIDWORD(a6) = 1056964608;
          *(float *)&a6 = (float)(v37 * -10430.0) + 32768.0;
          v31 = vmul_f32(*(float32x2_t *)&a6, v26);
          goto LABEL_8;
        case 2:
          v38 = vmul_f32(vcvt_f32_s32(v27), vmul_f32(v23, (float32x2_t)v9[5]));
          v26 = *(float32x2_t *)((char *)result + 84);
          a6 = COERCE_DOUBLE(vmla_f32(*(float32x2_t *)((char *)result + 92), v26, vminnm_f32(vsub_f32(v38, vrndm_f32(v38)), v24)));
          v31 = vmul_f32(*(float32x2_t *)&a6, vmul_f32(v25, vcvt_f32_u32(v9[3])));
          goto LABEL_8;
        case 4:
          v39 = vcvt_f32_s32(v27);
          v40 = vcvt_f32_s32((int32x2_t)v9[4]);
          v26 = vmul_f32(*(float32x2_t *)((char *)result + 84), v40);
          v41 = vmul_f32(*(float32x2_t *)((char *)result + 92), v40);
          a7 = (int8x8_t)vcgt_f32(v39, v41);
          v42 = (float32x2_t)vbsl_s8(a7, (int8x8_t)v41, (int8x8_t)v39);
          a6 = COERCE_DOUBLE(vcgt_f32(v26, v42));
          v31 = (float32x2_t)vbsl_s8(*(int8x8_t *)&a6, (int8x8_t)v26, (int8x8_t)v42);
LABEL_8:
          v27 = vcvt_s32_f32(v31);
          break;
        default:
          break;
      }
      v43 = v27.i32[0];
      if (v27.i32[0] >= v20)
        v44 = v20;
      else
        v44 = v27.i32[0];
      if (v44 <= -32768)
        v44 = -32768;
      v45 = v44 + 0x8000;
      if (v27.i32[0] <= 0x8000)
        v43 = 0x8000;
      v46 = v43 - 0x8000;
      v47 = v27.i32[1];
      if (v46 >= v12)
        v46 = v12;
      if (v27.i32[1] >= v21)
        v48 = v21;
      else
        v48 = v27.i32[1];
      if (v48 <= -32768)
        v48 = -32768;
      v49 = v48 + 0x8000;
      if (v27.i32[1] <= 0x8000)
        v47 = 0x8000;
      v50 = v47 - 0x8000;
      if (v50 >= (int)v13)
        v50 = v13;
      v51 = v10 + v11 * ((uint64_t)v50 >> 16);
      v52 = v10 + v11 * HIWORD(v49);
      v53 = ((uint64_t)v46 >> 13) & 0xFFFFFFFFFFFFFFF8;
      v54 = (__int16 *)(v51 + v53);
      v55 = (__int16 *)(v52 + v53);
      v56 = (v45 >> 13) & 0x7FFF8;
      v57 = (__int16 *)(v51 + v56);
      v58 = (__int16 *)(v52 + v56);
      v27.i16[0] = *v54;
      v27.i16[2] = *v57;
      v26.i16[0] = v54[1];
      v26.i16[2] = v57[1];
      LOWORD(a6) = v54[2];
      WORD2(a6) = v57[2];
      v59 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(*(int8x8_t *)&a6, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v60 = vorr_s8(vand_s8((int8x8_t)v26, (int8x8_t)0xFF000000FF00), v59);
      v61 = vorr_s8((int8x8_t)(*(_QWORD *)&vshl_n_s32((int32x2_t)vand_s8((int8x8_t)v27, (int8x8_t)0xFFFF0000FFFFLL), 8uLL) & 0xFFFF00FFFFFF00FFLL), v60);
      v60.i16[0] = *v55;
      v60.i16[2] = *v58;
      v59.i16[0] = v55[1];
      v59.i16[2] = v58[1];
      a7.i16[0] = v55[2];
      a7.i16[2] = v58[2];
      a7 = (int8x8_t)vshr_n_u32((uint32x2_t)vand_s8(a7, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v62 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8((int8x8_t)(*(_QWORD *)&vshl_n_s32((int32x2_t)vand_s8(v60, (int8x8_t)0xFFFF0000FFFFLL), 8uLL) & 0xFFFF00FFFFFF00FFLL), vorr_s8(vand_s8(v59, (int8x8_t)0xFF000000FF00), a7)) | 0xFF000000FF000000), (uint8x8_t)(*(_QWORD *)&v61 | 0xFF000000FF000000)), vdupq_n_s16((v50 >> 1) & 0x7F80)), (uint8x8_t)(*(_QWORD *)&v61 | 0xFF000000FF000000));
      a6 = COERCE_DOUBLE(vdup_n_s16((v46 >> 1) & 0x7F80));
      *(int16x4_t *)v62.i8 = vadd_s16(*(int16x4_t *)v62.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v62, v62, 8uLL), *(int16x4_t *)v62.i8), *(int16x4_t *)&a6));
      v15 = v15 + v14;
      v19 += v18;
      v17 += v16;
      *a3++ = vuzp1_s8(*(int8x8_t *)v62.i8, *(int8x8_t *)v62.i8).u32[0];
      --v8;
    }
    while (v8);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,false,false,false,false>(uint64_t a1, int a2, unsigned int *a3)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  float v8;
  float v9;

  if (a2)
  {
    v4 = a2;
    v6 = *(_DWORD *)(a1 + 52);
    v5 = *(_DWORD *)(a1 + 56);
    v7 = **(_QWORD **)a1 + *(_QWORD *)(*(_QWORD *)a1 + 16) * *(__int16 *)(a1 + 62);
    do
    {
      --v4;
      v8 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v7
                                                                        + (((uint64_t)v6 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v8 > 1.0)
        v8 = 1.0;
      if (v8 >= 0.0)
        v9 = (float)(v8 * 255.0) + 0.5;
      else
        v9 = 0.5;
      v6 += v5;
      *a3++ = v9 | (v9 << 8) | ((v9 | (v9 << 8)) << 16);
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,true,false,false,false>(_DWORD *a1, int a2, unsigned int *a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  float v11;
  float v12;

  if (a2)
  {
    v4 = a2;
    v5 = **(_QWORD **)a1;
    v6 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v8 = a1[15];
    v7 = a1[16];
    v10 = a1[13];
    v9 = a1[14];
    do
    {
      --v4;
      v11 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v5
                                                                         + v6 * ((uint64_t)v8 >> 16)
                                                                         + (((uint64_t)v10 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v11 > 1.0)
        v11 = 1.0;
      if (v11 >= 0.0)
        v12 = (float)(v11 * 255.0) + 0.5;
      else
        v12 = 0.5;
      v10 += v9;
      v8 += v7;
      *a3++ = v12 | (v12 << 8) | ((v12 | (v12 << 8)) << 16);
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,false,true,false,false>(_DWORD *a1, int a2, unsigned int *a3)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  float v11;
  float v12;

  if (a2)
  {
    v4 = a2;
    v5 = a1[14];
    v6 = a1[13];
    v7 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v8 = a1[15] & ~((int)a1[15] >> 31);
    if (v8 >= *(_DWORD *)(*(_QWORD *)a1 + 36))
      v8 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v9 = **(_QWORD **)a1 + *(_QWORD *)(*(_QWORD *)a1 + 16) * ((uint64_t)v8 >> 16);
    do
    {
      --v4;
      v10 = v6 & ~(v6 >> 31);
      if (v10 >= v7)
        v10 = v7;
      v11 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v9
                                                                         + (((uint64_t)v10 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v11 > 1.0)
        v11 = 1.0;
      if (v11 >= 0.0)
        v12 = (float)(v11 * 255.0) + 0.5;
      else
        v12 = 0.5;
      v6 += v5;
      *a3++ = v12 | (v12 << 8) | ((v12 | (v12 << 8)) << 16);
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,true,true,false,false>(int *a1, int a2, unsigned int *a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  float v15;
  float v16;

  if (a2)
  {
    v4 = a2;
    v5 = **(_QWORD **)a1;
    v6 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v7 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v8 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v10 = a1[15];
    v9 = a1[16];
    v12 = a1[13];
    v11 = a1[14];
    do
    {
      --v4;
      v13 = v12 & ~(v12 >> 31);
      if (v13 >= v7)
        v13 = v7;
      v14 = v10 & ~(v10 >> 31);
      if (v14 >= v8)
        v14 = v8;
      v15 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v5
                                                                         + v6 * ((uint64_t)v14 >> 16)
                                                                         + (((uint64_t)v13 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v15 > 1.0)
        v15 = 1.0;
      if (v15 >= 0.0)
        v16 = (float)(v15 * 255.0) + 0.5;
      else
        v16 = 0.5;
      v12 += v11;
      v10 += v9;
      *a3++ = v16 | (v16 << 8) | ((v16 | (v16 << 8)) << 16);
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  int v4;
  float *v5;
  __int32 v6;
  int v7;
  float v8;
  float v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  float v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  int32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  __int32 v33;
  int v34;
  float v35;
  float v36;
  uint64_t v38;
  uint64_t v39;

  if (a2)
  {
    v4 = a2;
    v5 = (float *)*a1;
    v38 = (*a1)[2];
    v39 = **a1;
    v6 = *((_DWORD *)*a1 + 8);
    v7 = *((_DWORD *)*a1 + 9);
    v8 = *((float *)a1[3] + 3);
    v9 = *((float *)a1[2] + 3);
    v11 = *((_DWORD *)a1 + 15);
    v10 = *((_DWORD *)a1 + 16);
    v13 = *((_DWORD *)a1 + 13);
    v12 = *((_DWORD *)a1 + 14);
    v14 = *((unsigned __int8 *)a1 + 48) - 1;
    v15 = 0.5;
    v16 = (float32x2_t)vdup_n_s32(0x37800000u);
    v17 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v18 = (float32x2_t)vdup_n_s32(0x47800000u);
    do
    {
      v19.f32[0] = (float)(1.0 / v9) * (float)v13;
      v19.f32[1] = (float)(1.0 / v9) * (float)v11;
      v20 = vcvt_s32_f32(v19);
      switch(v14)
      {
        case 0:
          v21 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v20));
          v22 = vmul_f32(v21, v21);
          v23 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v22, 1), v22);
          v22.f32[0] = fmaxf(vaddv_f32(v22), 0.00001);
          v22.i32[0] = vmul_f32(v23, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v22, 0))).u32[0];
          v22.f32[1] = v15;
          v24 = vmul_f32(v22, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          v25 = atan2f(v5[11] * (float)v20.i32[1], v5[10] * (float)v20.i32[0]);
          v26.i32[1] = 1056964608;
          v26.f32[0] = (float)(v25 * -10430.0) + 32768.0;
          v24 = vmul_f32(v26, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          v27 = vmul_f32(vcvt_f32_s32(v20), vmul_f32(v16, *(float32x2_t *)(v5 + 10)));
          v24 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v27, vrndm_f32(v27)), v17)), vmul_f32(v18, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          v28 = vcvt_f32_s32(v20);
          v29 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          v30 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v29);
          v31 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v29);
          v32 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v28, v31), (int8x8_t)v31, (int8x8_t)v28);
          v24 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v32), (int8x8_t)v30, (int8x8_t)v32);
LABEL_8:
          v20 = vcvt_s32_f32(v24);
          break;
        default:
          break;
      }
      --v4;
      v33 = v20.i32[0] & ~(v20.i32[0] >> 31);
      if (v33 >= v6)
        v33 = v6;
      v34 = v20.i32[1] & ~(v20.i32[1] >> 31);
      if (v34 >= v7)
        v34 = v7;
      v35 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v39
                                                                         + v38 * ((uint64_t)v34 >> 16)
                                                                         + (((uint64_t)v33 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v35 > 1.0)
        v35 = 1.0;
      v15 = 0.5;
      if (v35 >= 0.0)
        v36 = (float)(v35 * 255.0) + 0.5;
      else
        v36 = 0.5;
      v9 = v9 + v8;
      v13 += v12;
      v11 += v10;
      *a3++ = v36 | (v36 << 8) | ((v36 | (v36 << 8)) << 16);
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,false,false,false,true>(_DWORD *a1, int a2, _DWORD *a3, int16x4_t a4)
{
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  float32x2_t v19;
  unint64_t v20;
  unint64_t v21;
  float v22;
  float32x2_t v23;
  int32x2_t v24;
  int32x2_t v25;
  uint8x8_t v26;
  float v27;
  float32x2_t v28;
  int32x2_t v29;
  int32x2_t v30;
  int8x16_t v31;
  int16x4_t v32;
  float v33;
  float v34;

  if (a2)
  {
    v5 = a2;
    v7 = a1[14];
    v6 = a1[15];
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v9 = **(_QWORD **)a1;
    v10 = v6 + 0x8000;
    v6 -= 0x8000;
    v11 = v9 + v8 * ((uint64_t)(int)v6 >> 16);
    v12 = v9 + v8 * ((uint64_t)(int)v10 >> 16);
    a4.i32[0] = (v6 >> 1) & 0x7F80;
    v32 = a4;
    v13 = a1[13] - 0x8000;
    __asm { FMOV            V8.2S, #1.0 }
    v19 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v5;
      v20 = ((uint64_t)v13 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v21 = ((uint64_t)(v13 + 0x10000) >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v33 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v11 + v20));
      v22 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v11 + v21));
      v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v22), LODWORD(v33)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v22), LODWORD(v33)));
      v24 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v23), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v23)));
      v25 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v24, 8uLL), (int8x8_t)v24);
      v26 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v25, 0x10uLL), (int8x8_t)v25);
      v34 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v12 + v20));
      v27 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v12 + v21));
      v28 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v27), LODWORD(v34)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v27), LODWORD(v34)));
      v29 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v28), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v28)));
      v30 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v29, 8uLL), (int8x8_t)v29);
      v31 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v30, 0x10uLL), (int8x8_t)v30), v26), v32, 0), v26);
      *(int16x4_t *)v31.i8 = vadd_s16(*(int16x4_t *)v31.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL), *(int16x4_t *)v31.i8), vdup_n_s16((v13 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v31.i8, *(int8x8_t *)v31.i8).u32[0];
      v13 += v7;
    }
    while (v5);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  float32x2_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  float v19;
  float32x2_t v20;
  int32x2_t v21;
  int32x2_t v22;
  uint8x8_t v23;
  float v24;
  float32x2_t v25;
  int32x2_t v26;
  int32x2_t v27;
  int8x16_t v28;
  int v29;
  int v30;
  float v31;
  float v32;

  if (a2)
  {
    v4 = a2;
    v5 = **(_QWORD **)a1;
    v6 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v29 = a1[14];
    v30 = a1[16];
    v7 = a1[13] - 0x8000;
    v8 = a1[15] - 0x8000;
    __asm { FMOV            V8.2S, #1.0 }
    v14 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v4;
      v15 = v5 + v6 * ((uint64_t)v8 >> 16);
      v16 = v5 + v6 * ((uint64_t)(v8 + 0x10000) >> 16);
      v17 = ((uint64_t)v7 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v18 = ((uint64_t)(v7 + 0x10000) >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v31 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v17));
      v19 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v18));
      v20 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v19), LODWORD(v31)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v19), LODWORD(v31)));
      v21 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v20), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v20)));
      v22 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v21, 8uLL), (int8x8_t)v21);
      v23 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v22, 0x10uLL), (int8x8_t)v22);
      v32 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v16 + v17));
      v24 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v16 + v18));
      v25 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v24), LODWORD(v32)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v24), LODWORD(v32)));
      v26 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v25), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v25)));
      v27 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v26, 8uLL), (int8x8_t)v26);
      v28 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v27, 0x10uLL), (int8x8_t)v27), v23), vdupq_n_s16((v8 >> 1) & 0x7F80)), v23);
      *(int16x4_t *)v28.i8 = vadd_s16(*(int16x4_t *)v28.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL), *(int16x4_t *)v28.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v28.i8, *(int8x8_t *)v28.i8).u32[0];
      v7 += v29;
      v8 += v30;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,false,true,false,true>(_DWORD *a1, int a2, _DWORD *a3, int16x4_t a4)
{
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  float32x2_t v22;
  int v23;
  unsigned int v24;
  int v25;
  int v26;
  int v27;
  unint64_t v28;
  uint64_t v29;
  float v30;
  float32x2_t v31;
  int32x2_t v32;
  int32x2_t v33;
  uint8x8_t v34;
  float v35;
  float32x2_t v36;
  int32x2_t v37;
  int32x2_t v38;
  int8x16_t v39;
  int16x4_t v40;
  int v41;
  float v42;
  float v43;

  if (a2)
  {
    v5 = a2;
    v6 = a1[15];
    v41 = a1[14];
    v7 = a1[13];
    v9 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v8 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v10 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v11 = **(_QWORD **)a1;
    v12 = v8 - 0x8000;
    if (v6 < v8 - 0x8000)
      v12 = a1[15];
    if (v12 <= -32768)
      v12 = -32768;
    v13 = v12 + 0x8000;
    if (v6 <= 0x8000)
      v6 = 0x8000;
    v14 = v6 - 0x8000;
    if (v14 >= v8)
      v14 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v15 = v11 + v10 * ((uint64_t)v14 >> 16);
    v16 = v11 + v10 * HIWORD(v13);
    a4.i32[0] = (v14 >> 1) & 0x7F80;
    v40 = a4;
    __asm { FMOV            V8.2S, #1.0 }
    v22 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v5;
      if (v7 >= v9 - 0x8000)
        v23 = v9 - 0x8000;
      else
        v23 = v7;
      if (v23 <= -32768)
        v23 = -32768;
      v24 = v23 + 0x8000;
      if (v7 <= 0x8000)
        v25 = 0x8000;
      else
        v25 = v7;
      v26 = v25 - 0x8000;
      if (v26 >= v9)
        v27 = v9;
      else
        v27 = v26;
      v28 = ((uint64_t)v27 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v29 = (v24 >> 15) & 0x1FFFE;
      v42 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v28));
      v30 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v29));
      v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v30), LODWORD(v42)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v30), LODWORD(v42)));
      v32 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v31), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v22, v31)));
      v33 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v32, 8uLL), (int8x8_t)v32);
      v34 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v33, 0x10uLL), (int8x8_t)v33);
      v43 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v16 + v28));
      v35 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v16 + v29));
      v36 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v35), LODWORD(v43)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v35), LODWORD(v43)));
      v37 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v36), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v22, v36)));
      v38 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v37, 8uLL), (int8x8_t)v37);
      v39 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v38, 0x10uLL), (int8x8_t)v38), v34), v40, 0), v34);
      *(int16x4_t *)v39.i8 = vadd_s16(*(int16x4_t *)v39.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL), *(int16x4_t *)v39.i8), vdup_n_s16((v27 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v39.i8, *(int8x8_t *)v39.i8).u32[0];
      v7 += v41;
    }
    while (v5);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  int v4;
  int v5;
  int v6;
  float32x2_t v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  float v27;
  float32x2_t v28;
  int32x2_t v29;
  int32x2_t v30;
  uint8x8_t v31;
  float v32;
  float32x2_t v33;
  int32x2_t v34;
  int32x2_t v35;
  int8x16_t v36;
  int v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  float v43;
  float v44;

  if (a2)
  {
    v4 = a2;
    v41 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v42 = **(_QWORD **)a1;
    v5 = a1[15];
    v6 = a1[13];
    v37 = a1[14];
    v38 = a1[16];
    v39 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v40 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    __asm { FMOV            V8.2S, #1.0 }
    v12 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v4;
      v13 = v40 - 0x8000;
      if (v6 < v40 - 0x8000)
        v13 = v6;
      if (v13 <= -32768)
        v13 = -32768;
      v14 = v13 + 0x8000;
      if (v6 <= 0x8000)
        v15 = 0x8000;
      else
        v15 = v6;
      v16 = v15 - 0x8000;
      if (v16 >= v40)
        v17 = v40;
      else
        v17 = v16;
      v18 = v39 - 0x8000;
      if (v5 < v39 - 0x8000)
        v18 = v5;
      if (v18 <= -32768)
        v18 = -32768;
      v19 = v18 + 0x8000;
      if (v5 <= 0x8000)
        v20 = 0x8000;
      else
        v20 = v5;
      v21 = v20 - 0x8000;
      if (v21 >= v39)
        v22 = v39;
      else
        v22 = v21;
      v23 = v42 + v41 * ((uint64_t)v22 >> 16);
      v24 = v42 + v41 * HIWORD(v19);
      v25 = ((uint64_t)v17 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v26 = (v14 >> 15) & 0x1FFFE;
      v43 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v23 + v25));
      v27 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v23 + v26));
      v28 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v27), LODWORD(v43)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v27), LODWORD(v43)));
      v29 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v28), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v12, v28)));
      v30 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v29, 8uLL), (int8x8_t)v29);
      v31 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v30, 0x10uLL), (int8x8_t)v30);
      v44 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v24 + v25));
      v32 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v24 + v26));
      v33 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v32), LODWORD(v44)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v32), LODWORD(v44)));
      v34 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v33), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v12, v33)));
      v35 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v34, 8uLL), (int8x8_t)v34);
      v36 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v35, 0x10uLL), (int8x8_t)v35), v31), vdupq_n_s16((v22 >> 1) & 0x7F80)), v31);
      *(int16x4_t *)v36.i8 = vadd_s16(*(int16x4_t *)v36.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL), *(int16x4_t *)v36.i8), vdup_n_s16((v17 >> 1) & 0x7F80)));
      v6 += v37;
      *a3++ = vuzp1_s8(*(int8x8_t *)v36.i8, *(int8x8_t *)v36.i8).u32[0];
      v5 += v38;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Ah,unsigned int,true,true,true,true>(uint64_t **a1, int a2, _DWORD *a3)
{
  int v4;
  float v5;
  float v6;
  int v7;
  int v8;
  int v9;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  int32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  unsigned int v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  float v46;
  float32x2_t v47;
  int32x2_t v48;
  int32x2_t v49;
  uint8x8_t v50;
  float v51;
  float32x2_t v52;
  int32x2_t v53;
  int32x2_t v54;
  int8x16_t v55;
  float32x2_t v56;
  float *v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  float v66;
  float v67;

  if (a2)
  {
    v4 = a2;
    v64 = (*a1)[2];
    v65 = **a1;
    v58 = (float *)*a1;
    v5 = *((float *)a1[3] + 3);
    v6 = *((float *)a1[2] + 3);
    v7 = *((_DWORD *)a1 + 15);
    v61 = *((_DWORD *)a1 + 16);
    v62 = *((_DWORD *)*a1 + 9);
    v8 = *((_DWORD *)a1 + 13);
    v60 = *((_DWORD *)a1 + 14);
    v63 = *((_DWORD *)*a1 + 8);
    v9 = *((unsigned __int8 *)a1 + 48) - 1;
    __asm { FMOV            V11.2S, #1.0 }
    v15 = (float32x2_t)vdup_n_s32(0x437F0000u);
    v56 = (float32x2_t)vdup_n_s32(0x37800000u);
    v16 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v17 = (float32x2_t)vdup_n_s32(0x47800000u);
    v59 = v9;
    do
    {
      v18.f32[0] = (float)(1.0 / v6) * (float)v8;
      v18.f32[1] = (float)(1.0 / v6) * (float)v7;
      v19 = vcvt_s32_f32(v18);
      switch(v9)
      {
        case 0:
          v20 = vmul_f32(*(float32x2_t *)(v58 + 10), vcvt_f32_s32(v19));
          v21 = vmul_f32(v20, v20);
          v22 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 1), v21);
          v21.f32[0] = fmaxf(vaddv_f32(v21), 0.00001);
          v21.i32[0] = vmul_f32(v22, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v21, 0))).u32[0];
          v21.i32[1] = 0.5;
          v23 = vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v58 + 6)));
          goto LABEL_8;
        case 1:
          v24 = atan2f(v58[11] * (float)v19.i32[1], v58[10] * (float)v19.i32[0]);
          v25.i32[1] = 1056964608;
          v25.f32[0] = (float)(v24 * -10430.0) + 32768.0;
          v23 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v58 + 6)));
          goto LABEL_8;
        case 2:
          v26 = vmul_f32(vcvt_f32_s32(v19), vmul_f32(v56, *(float32x2_t *)(v58 + 10)));
          v23 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v26, vrndm_f32(v26)), v16)), vmul_f32(v17, vcvt_f32_u32(*(uint32x2_t *)(v58 + 6))));
          goto LABEL_8;
        case 4:
          v27 = vcvt_f32_s32(v19);
          v28 = vcvt_f32_s32(*(int32x2_t *)(v58 + 8));
          v29 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v28);
          v30 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v28);
          v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, v30), (int8x8_t)v30, (int8x8_t)v27);
          v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29, v31), (int8x8_t)v29, (int8x8_t)v31);
LABEL_8:
          v19 = vcvt_s32_f32(v23);
          break;
        default:
          break;
      }
      --v4;
      v32 = v19.i32[0];
      v33 = v63 - 0x8000;
      if (v19.i32[0] < v63 - 0x8000)
        v33 = v19.i32[0];
      if (v33 <= -32768)
        v33 = -32768;
      v34 = v33 + 0x8000;
      if (v19.i32[0] <= 0x8000)
        v32 = 0x8000;
      v35 = v32 - 0x8000;
      if (v35 >= v63)
        v36 = v63;
      else
        v36 = v35;
      v37 = v19.i32[1];
      v38 = v62 - 0x8000;
      if (v19.i32[1] < v62 - 0x8000)
        v38 = v19.i32[1];
      if (v38 <= -32768)
        v38 = -32768;
      v39 = v38 + 0x8000;
      if (v19.i32[1] <= 0x8000)
        v37 = 0x8000;
      v40 = v37 - 0x8000;
      if (v40 >= v62)
        v41 = v62;
      else
        v41 = v40;
      v42 = v65 + v64 * ((uint64_t)v41 >> 16);
      v43 = v65 + v64 * HIWORD(v39);
      v44 = ((uint64_t)v36 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v45 = (v34 >> 15) & 0x1FFFE;
      v66 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v42 + v44));
      v46 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v42 + v45));
      v47 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v46), LODWORD(v66)), _D11), (int8x8_t)_D11, (int8x8_t)__PAIR64__(LODWORD(v46), LODWORD(v66)));
      v48 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v47), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v15, v47)));
      v49 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v48, 8uLL), (int8x8_t)v48);
      v50 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v49, 0x10uLL), (int8x8_t)v49);
      v67 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v43 + v44));
      v51 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v43 + v45));
      v52 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v51), LODWORD(v67)), _D11), (int8x8_t)_D11, (int8x8_t)__PAIR64__(LODWORD(v51), LODWORD(v67)));
      v53 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v52), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v15, v52)));
      v54 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v53, 8uLL), (int8x8_t)v53);
      v55 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v54, 0x10uLL), (int8x8_t)v54), v50), vdupq_n_s16((v41 >> 1) & 0x7F80)), v50);
      *(int16x4_t *)v55.i8 = vadd_s16(*(int16x4_t *)v55.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL), *(int16x4_t *)v55.i8), vdup_n_s16((v36 >> 1) & 0x7F80)));
      v6 = v6 + v5;
      v8 += v60;
      v7 += v61;
      *a3++ = vuzp1_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)v55.i8).u32[0];
      v9 = v59;
    }
    while (v4);
  }
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  float v6;
  float v7;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 52);
    v3 = *(_DWORD *)(result + 56);
    v5 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      v6 = *(float *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v6 > 1.0)
        v6 = 1.0;
      if (v6 >= 0.0)
        v7 = (float)(v6 * 255.0) + 0.5;
      else
        v7 = 0.5;
      v4 += v3;
      *a3++ = v7 | (v7 << 8) | ((v7 | (v7 << 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  float v9;
  float v10;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v6 = result[15];
    v5 = result[16];
    v8 = result[13];
    v7 = result[14];
    do
    {
      v9 = *(float *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v9 > 1.0)
        v9 = 1.0;
      if (v9 >= 0.0)
        v10 = (float)(v9 * 255.0) + 0.5;
      else
        v10 = 0.5;
      v8 += v7;
      v6 += v5;
      *a3++ = v10 | (v10 << 8) | ((v10 | (v10 << 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  float v9;
  float v10;

  if (a2)
  {
    v3 = result[14];
    v4 = result[13];
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(_QWORD *)result + 36))
      v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v7 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5)
        v8 = v5;
      v9 = *(float *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v9 > 1.0)
        v9 = 1.0;
      if (v9 >= 0.0)
        v10 = (float)(v9 * 255.0) + 0.5;
      else
        v10 = 0.5;
      v4 += v3;
      *a3++ = v10 | (v10 << 8) | ((v10 | (v10 << 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  float v13;
  float v14;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      result = (int *)(v3 + v4 * ((uint64_t)v12 >> 16));
      v13 = *(float *)((char *)result + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v13 > 1.0)
        v13 = 1.0;
      if (v13 >= 0.0)
        v14 = (float)(v13 * 255.0) + 0.5;
      else
        v14 = 0.5;
      v10 += v9;
      v8 += v7;
      *a3++ = v14 | (v14 << 8) | ((v14 | (v14 << 8)) << 16);
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  __int32 v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  __int32 v36;
  int v37;
  float v38;
  float v39;
  int v40;
  uint64_t v41;
  int v42;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v10 = *((_DWORD *)*a1 + 8);
    v9 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = 0.5;
    v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    v42 = v13;
    v40 = v17;
    v41 = v8;
    do
    {
      v22.f32[0] = (float)(1.0 / v12) * (float)v16;
      v22.f32[1] = (float)(1.0 / v12) * (float)v14;
      v23 = vcvt_s32_f32(v22);
      switch(v17)
      {
        case 0:
          v24 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v23));
          v25 = vmul_f32(v24, v24);
          v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.f32[1] = v18;
          v27 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v28 = atan2f(v6[11] * (float)v23.i32[1], v6[10] * (float)v23.i32[0]);
          v18 = 0.5;
          v17 = v40;
          v8 = v41;
          v13 = v42;
          v29.i32[1] = 1056964608;
          v29.f32[0] = (float)(v28 * -10430.0) + 32768.0;
          v27 = vmul_f32(v29, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v30 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, *(float32x2_t *)(v6 + 10)));
          v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v30, vrndm_f32(v30)), v20)), vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v31 = vcvt_f32_s32(v23);
          v32 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v32);
          v34 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v32);
          v35 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v31, v34), (int8x8_t)v34, (int8x8_t)v31);
          v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v33, v35), (int8x8_t)v33, (int8x8_t)v35);
LABEL_8:
          v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      v36 = v23.i32[0] & ~(v23.i32[0] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v37 = v23.i32[1] & ~(v23.i32[1] >> 31);
      if (v37 >= v9)
        v37 = v9;
      v38 = *(float *)(v7 + v8 * ((uint64_t)v37 >> 16) + (((uint64_t)v36 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v38 > 1.0)
        v38 = 1.0;
      if (v38 >= 0.0)
        v39 = v18 + (float)(v38 * 255.0);
      else
        v39 = v18;
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = v39 | (v39 << 8) | ((v39 | (v39 << 8)) << 16);
      --v4;
    }
    while (v4);
  }
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  float32x2_t v18;
  unint64_t v19;
  unint64_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int32x2_t v23;
  float32x2_t v24;
  int32x2_t v25;
  float32x2_t v26;
  int32x2_t v27;
  int32x2_t v28;
  uint8x8_t v29;
  int8x16_t v30;

  if (a2)
  {
    v4 = result[14];
    v5 = result[15];
    v6 = *(_QWORD *)(*(_QWORD *)result + 16);
    v7 = **(_QWORD **)result;
    v8 = v5 + 0x8000;
    v9 = v5 - 0x8000;
    v10 = v7 + v6 * ((uint64_t)(v5 - 0x8000) >> 16);
    v11 = v7 + v6 * ((uint64_t)v8 >> 16);
    a4.i32[0] = (v9 >> 1) & 0x7F80;
    v12 = result[13] - 0x8000;
    __asm { FMOV            V1.2S, #1.0 }
    v18 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      v19 = ((uint64_t)v12 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v20 = ((uint64_t)(v12 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v21.i32[0] = *(_DWORD *)(v10 + v19);
      v21.i32[1] = *(_DWORD *)(v10 + v20);
      v22 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v21, _D1), (int8x8_t)_D1, (int8x8_t)v21);
      v23 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v22), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v18, v22)));
      v24.i32[0] = *(_DWORD *)(v11 + v19);
      v24.i32[1] = *(_DWORD *)(v11 + v20);
      v25 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v23, 8uLL), (int8x8_t)v23);
      v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v24, _D1), (int8x8_t)_D1, (int8x8_t)v24);
      v27 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v26), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v18, v26)));
      v28 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v27, 8uLL), (int8x8_t)v27);
      v29 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v25, 0x10uLL), (int8x8_t)v25);
      v30 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v28, 0x10uLL), (int8x8_t)v28), v29), a4, 0), v29);
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v30.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL), *(int16x4_t *)v30.i8), vdup_n_s16((v12 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      v12 += v4;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,true,false,false,true>(_DWORD *result, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  float32x2_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  float32x2_t v19;
  float32x2_t v20;
  int32x2_t v21;
  float32x2_t v22;
  int32x2_t v23;
  float32x2_t v24;
  int32x2_t v25;
  int32x2_t v26;
  uint8x8_t v27;
  int8x16_t v28;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = result[16];
    v6 = result[14];
    v7 = result[13] - 0x8000;
    v8 = result[15] - 0x8000;
    __asm { FMOV            V0.2S, #1.0 }
    v14 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      v15 = v3 + v4 * ((uint64_t)v8 >> 16);
      v16 = v3 + v4 * ((uint64_t)(v8 + 0x10000) >> 16);
      v17 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v18 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      result = (_DWORD *)(v15 + v17);
      v19.i32[0] = *(_DWORD *)(v15 + v18);
      v19.i32[1] = *(_DWORD *)(v15 + v17);
      v20 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v19, _D0), (int8x8_t)_D0, (int8x8_t)v19);
      v21 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v20), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v20)));
      v22.i32[0] = *(_DWORD *)(v16 + v18);
      v22.i32[1] = *(_DWORD *)(v16 + v17);
      v23 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v21, 8uLL), (int8x8_t)v21);
      v24 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, _D0), (int8x8_t)_D0, (int8x8_t)v22);
      v25 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v24), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v24)));
      v26 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v25, 8uLL), (int8x8_t)v25);
      v27 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v23, 0x10uLL), (int8x8_t)v23);
      v28 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v26, 0x10uLL), (int8x8_t)v26), v27), vdupq_n_s16((v8 >> 1) & 0x7F80)), v27);
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v28.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL), *(int16x4_t *)v28.i8), vdup_n_s16((v7 >> 1) & 0x7F80))), (int8x8_t)_D0).u32[0];
      v7 += v6;
      v8 += v5;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  float32x2_t v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  float32x2_t v27;
  float32x2_t v28;
  int32x2_t v29;
  float32x2_t v30;
  int32x2_t v31;
  float32x2_t v32;
  int32x2_t v33;
  int32x2_t v34;
  uint8x8_t v35;
  int8x16_t v36;

  if (a2)
  {
    v4 = result[14];
    v5 = result[15];
    v6 = result[13];
    v7 = *(_DWORD *)(*(_QWORD *)result + 32);
    v8 = *(_DWORD *)(*(_QWORD *)result + 36);
    v9 = *(_QWORD *)(*(_QWORD *)result + 16);
    v10 = **(_QWORD **)result;
    if (v5 >= v8 - 0x8000)
      v11 = v8 - 0x8000;
    else
      v11 = result[15];
    if (v11 <= -32768)
      v11 = -32768;
    if (v5 <= 0x8000)
      v5 = 0x8000;
    v12 = v5 - 0x8000;
    if (v12 >= v8)
      v13 = *(_DWORD *)(*(_QWORD *)result + 36);
    else
      v13 = v12;
    v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    v15 = v10 + v9 * ((v11 + 0x8000) >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    __asm { FMOV            V1.2S, #1.0 }
    v21 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      if (v6 >= v7 - 0x8000)
        v22 = v7 - 0x8000;
      else
        v22 = v6;
      if (v22 <= -32768)
        v22 = -32768;
      v23 = v22 + 0x8000;
      if (v6 <= 0x8000)
        v24 = 0x8000;
      else
        v24 = v6;
      v25 = v24 - 0x8000;
      if (v25 >= v7)
        v25 = v7;
      v26 = (v23 >> 14) & 0x3FFFC;
      result = (_DWORD *)(((uint64_t)v25 >> 14) & 0xFFFFFFFFFFFFFFFCLL);
      v27.i32[0] = *(_DWORD *)((char *)result + v14);
      v27.i32[1] = *(_DWORD *)(v14 + v26);
      v28 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, _D1), (int8x8_t)_D1, (int8x8_t)v27);
      v29 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v28), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v21, v28)));
      v30.i32[0] = *(_DWORD *)((char *)result + v15);
      v30.i32[1] = *(_DWORD *)(v15 + v26);
      v31 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v29, 8uLL), (int8x8_t)v29);
      v32 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, _D1), (int8x8_t)_D1, (int8x8_t)v30);
      v33 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v32), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v21, v32)));
      v34 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v33, 8uLL), (int8x8_t)v33);
      v35 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v31, 0x10uLL), (int8x8_t)v31);
      v36 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v34, 0x10uLL), (int8x8_t)v34), v35), a4, 0), v35);
      v6 += v4;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v36.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL), *(int16x4_t *)v36.i8), vdup_n_s16((v25 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  float32x2_t v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  float32x2_t v29;
  float32x2_t v30;
  int32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  int32x2_t v34;
  int32x2_t v35;
  int32x2_t v36;
  uint8x8_t v37;
  int8x16_t v38;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = *(_DWORD *)(result + 60);
    v7 = *(_DWORD *)(result + 64);
    v10 = *(_DWORD *)(result + 52);
    v9 = *(_DWORD *)(result + 56);
    result = 4294934528;
    __asm { FMOV            V0.2S, #1.0 }
    v16 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      if (v10 >= v5 - 0x8000)
        v17 = v5 - 0x8000;
      else
        v17 = v10;
      if (v17 <= -32768)
        v17 = -32768;
      v18 = v17 + 0x8000;
      if (v10 <= 0x8000)
        v19 = 0x8000;
      else
        v19 = v10;
      v20 = v19 - 0x8000;
      if (v20 >= v5)
        v20 = v5;
      if (v8 >= v6 - 0x8000)
        v21 = v6 - 0x8000;
      else
        v21 = v8;
      if (v21 <= -32768)
        v21 = -32768;
      v22 = v21 + 0x8000;
      if (v8 <= 0x8000)
        v23 = 0x8000;
      else
        v23 = v8;
      v24 = v23 - 0x8000;
      if (v24 >= v6)
        v24 = v6;
      v25 = v3 + v4 * ((uint64_t)v24 >> 16);
      v26 = v3 + v4 * HIWORD(v22);
      v27 = (v18 >> 14) & 0x3FFFC;
      v28 = ((uint64_t)v20 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v29.i32[0] = *(_DWORD *)(v25 + v28);
      v29.i32[1] = *(_DWORD *)(v25 + v27);
      v30 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29, _D0), (int8x8_t)_D0, (int8x8_t)v29);
      v31 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v30), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v30)));
      v32.i32[0] = *(_DWORD *)(v26 + v28);
      v32.i32[1] = *(_DWORD *)(v26 + v27);
      v33 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, _D0), (int8x8_t)_D0, (int8x8_t)v32);
      v34 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v31, 8uLL), (int8x8_t)v31);
      v35 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v33), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v33)));
      v36 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v35, 8uLL), (int8x8_t)v35);
      v37 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v34, 0x10uLL), (int8x8_t)v34);
      v38 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v36, 0x10uLL), (int8x8_t)v36), v37), vdupq_n_s16((v24 >> 1) & 0x7F80)), v37);
      v10 += v9;
      v8 += v7;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v38.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL), *(int16x4_t *)v38.i8), vdup_n_s16((v20 >> 1) & 0x7F80))), (int8x8_t)_D0).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Af,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  int32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  uint32x2_t *v34;
  uint64_t v35;
  uint64_t v36;
  float v37;
  float32x2_t v38;
  float32x2_t v39;
  float32x2_t v40;
  float32x2_t v41;
  float32x2_t v42;
  float32x2_t v43;
  float32x2_t v44;
  int v45;
  int v46;
  unsigned int v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  float32x2_t v57;
  float32x2_t v58;
  int32x2_t v59;
  int32x2_t v60;
  uint8x8_t v61;
  float32x2_t v62;
  float32x2_t v63;
  int32x2_t v64;
  int32x2_t v65;
  int8x16_t v66;
  int v67;
  uint64_t **v68;
  int v69;
  int v70;
  int v71;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = *((unsigned __int8 *)result + 48) - 1;
    __asm { FMOV            V11.2S, #1.0 }
    v24 = (float32x2_t)vdup_n_s32(0x437F0000u);
    v25 = (float32x2_t)vdup_n_s32(0x37800000u);
    v26 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v27 = (float32x2_t)vdup_n_s32(0x47800000u);
    v70 = v8;
    v71 = v12;
    v69 = v8 - 0x8000;
    v67 = v18;
    v68 = result;
    do
    {
      v28.f32[0] = (float)(1.0 / v11) * (float)v15;
      v28.f32[1] = (float)(1.0 / v11) * (float)v13;
      v29 = vcvt_s32_f32(v28);
      switch(v18)
      {
        case 0:
          v30 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v29));
          v31 = vmul_f32(v30, v30);
          v32 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v31, 1), v31);
          v31.f32[0] = fmaxf(vaddv_f32(v31), 0.00001);
          v31.i32[0] = vmul_f32(v32, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v31, 0))).u32[0];
          v31.i32[1] = 0.5;
          v33 = vmul_f32(v31, vcvt_f32_u32(v5[3]));
          goto LABEL_8;
        case 1:
          v34 = v5;
          v35 = v9;
          v36 = v14;
          v37 = atan2f(*(float *)&v5[5].i32[1] * (float)v29.i32[1], *(float *)v5[5].i32 * (float)v29.i32[0]);
          v18 = v67;
          result = v68;
          v16 = v69;
          v8 = v70;
          v14 = v36;
          v12 = v71;
          v9 = v35;
          v5 = v34;
          v38.i32[1] = 1056964608;
          v38.f32[0] = (float)(v37 * -10430.0) + 32768.0;
          v33 = vmul_f32(v38, vcvt_f32_u32(v34[3]));
          goto LABEL_8;
        case 2:
          v39 = vmul_f32(vcvt_f32_s32(v29), vmul_f32(v25, (float32x2_t)v5[5]));
          v33 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v39, vrndm_f32(v39)), v26)), vmul_f32(v27, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v40 = vcvt_f32_s32(v29);
          v41 = vcvt_f32_s32((int32x2_t)v5[4]);
          v42 = vmul_f32(*(float32x2_t *)((char *)result + 84), v41);
          v43 = vmul_f32(*(float32x2_t *)((char *)result + 92), v41);
          v44 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v40, v43), (int8x8_t)v43, (int8x8_t)v40);
          v33 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v42, v44), (int8x8_t)v42, (int8x8_t)v44);
LABEL_8:
          v29 = vcvt_s32_f32(v33);
          break;
        default:
          break;
      }
      v45 = v29.i32[0];
      if (v29.i32[0] >= v16)
        v46 = v16;
      else
        v46 = v29.i32[0];
      if (v46 <= -32768)
        v46 = -32768;
      v47 = v46 + 0x8000;
      if (v29.i32[0] <= 0x8000)
        v45 = 0x8000;
      v48 = v45 - 0x8000;
      if (v48 >= v8)
        v48 = v8;
      v49 = v29.i32[1];
      if (v29.i32[1] >= v17)
        v50 = v17;
      else
        v50 = v29.i32[1];
      if (v50 <= -32768)
        v50 = -32768;
      v51 = v50 + 0x8000;
      if (v29.i32[1] <= 0x8000)
        v49 = 0x8000;
      v52 = v49 - 0x8000;
      if (v52 >= (int)v9)
        v52 = v9;
      v53 = v6 + v7 * ((uint64_t)v52 >> 16);
      v54 = v6 + v7 * HIWORD(v51);
      v55 = ((uint64_t)v48 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v56 = (v47 >> 14) & 0x3FFFC;
      v57.i32[0] = *(_DWORD *)(v53 + v55);
      v57.i32[1] = *(_DWORD *)(v53 + v56);
      v58 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v57, _D11), (int8x8_t)_D11, (int8x8_t)v57);
      v59 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v58), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v24, v58)));
      v60 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v59, 8uLL), (int8x8_t)v59);
      v61 = (uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v60, 0x10uLL), (int8x8_t)v60);
      v62.i32[0] = *(_DWORD *)(v54 + v55);
      v62.i32[1] = *(_DWORD *)(v54 + v56);
      v63 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v62, _D11), (int8x8_t)_D11, (int8x8_t)v62);
      v64 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v63), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v24, v63)));
      v65 = (int32x2_t)vorr_s8((int8x8_t)vshl_n_s32(v64, 8uLL), (int8x8_t)v64);
      v66 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8((int8x8_t)vshl_n_s32(v65, 0x10uLL), (int8x8_t)v65), v61), vdupq_n_s16((v52 >> 1) & 0x7F80)), v61);
      *(int16x4_t *)v66.i8 = vadd_s16(*(int16x4_t *)v66.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v66, v66, 8uLL), *(int16x4_t *)v66.i8), vdup_n_s16((v48 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v66.i8, *(int8x8_t *)v66.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,false,false,false,false>(uint64_t a1, int a2, unsigned int *a3)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  float v8;
  float v9;

  if (a2)
  {
    v4 = a2;
    v6 = *(_DWORD *)(a1 + 52);
    v5 = *(_DWORD *)(a1 + 56);
    v7 = **(_QWORD **)a1 + *(_QWORD *)(*(_QWORD *)a1 + 16) * *(__int16 *)(a1 + 62);
    do
    {
      --v4;
      v8 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v7
                                                                        + (((uint64_t)v6 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v8 > 1.0)
        v8 = 1.0;
      if (v8 >= 0.0)
        v9 = (float)(v8 * 255.0) + 0.5;
      else
        v9 = 0.5;
      v6 += v5;
      *a3++ = (v9 << 16) | (v9 << 8) | v9 | 0xFF000000;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,true,false,false,false>(_DWORD *a1, int a2, unsigned int *a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  float v11;
  float v12;

  if (a2)
  {
    v4 = a2;
    v5 = **(_QWORD **)a1;
    v6 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v8 = a1[15];
    v7 = a1[16];
    v10 = a1[13];
    v9 = a1[14];
    do
    {
      --v4;
      v11 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v5
                                                                         + v6 * ((uint64_t)v8 >> 16)
                                                                         + (((uint64_t)v10 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v11 > 1.0)
        v11 = 1.0;
      if (v11 >= 0.0)
        v12 = (float)(v11 * 255.0) + 0.5;
      else
        v12 = 0.5;
      v10 += v9;
      v8 += v7;
      *a3++ = (v12 << 16) | (v12 << 8) | v12 | 0xFF000000;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,false,true,false,false>(_DWORD *a1, int a2, unsigned int *a3)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  float v11;
  float v12;

  if (a2)
  {
    v4 = a2;
    v5 = a1[14];
    v6 = a1[13];
    v7 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v8 = a1[15] & ~((int)a1[15] >> 31);
    if (v8 >= *(_DWORD *)(*(_QWORD *)a1 + 36))
      v8 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v9 = **(_QWORD **)a1 + *(_QWORD *)(*(_QWORD *)a1 + 16) * ((uint64_t)v8 >> 16);
    do
    {
      --v4;
      v10 = v6 & ~(v6 >> 31);
      if (v10 >= v7)
        v10 = v7;
      v11 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v9
                                                                         + (((uint64_t)v10 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v11 > 1.0)
        v11 = 1.0;
      if (v11 >= 0.0)
        v12 = (float)(v11 * 255.0) + 0.5;
      else
        v12 = 0.5;
      v6 += v5;
      *a3++ = (v12 << 16) | (v12 << 8) | v12 | 0xFF000000;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,true,true,false,false>(int *a1, int a2, unsigned int *a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  float v15;
  float v16;

  if (a2)
  {
    v4 = a2;
    v5 = **(_QWORD **)a1;
    v6 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v7 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v8 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v10 = a1[15];
    v9 = a1[16];
    v12 = a1[13];
    v11 = a1[14];
    do
    {
      --v4;
      v13 = v12 & ~(v12 >> 31);
      if (v13 >= v7)
        v13 = v7;
      v14 = v10 & ~(v10 >> 31);
      if (v14 >= v8)
        v14 = v8;
      v15 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v5
                                                                         + v6 * ((uint64_t)v14 >> 16)
                                                                         + (((uint64_t)v13 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v15 > 1.0)
        v15 = 1.0;
      if (v15 >= 0.0)
        v16 = (float)(v15 * 255.0) + 0.5;
      else
        v16 = 0.5;
      v12 += v11;
      v10 += v9;
      *a3++ = (v16 << 16) | (v16 << 8) | v16 | 0xFF000000;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  int v4;
  float *v5;
  __int32 v6;
  int v7;
  float v8;
  float v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  float v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  int32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  __int32 v33;
  int v34;
  float v35;
  float v36;
  uint64_t v38;
  uint64_t v39;

  if (a2)
  {
    v4 = a2;
    v5 = (float *)*a1;
    v38 = (*a1)[2];
    v39 = **a1;
    v6 = *((_DWORD *)*a1 + 8);
    v7 = *((_DWORD *)*a1 + 9);
    v8 = *((float *)a1[3] + 3);
    v9 = *((float *)a1[2] + 3);
    v11 = *((_DWORD *)a1 + 15);
    v10 = *((_DWORD *)a1 + 16);
    v13 = *((_DWORD *)a1 + 13);
    v12 = *((_DWORD *)a1 + 14);
    v14 = *((unsigned __int8 *)a1 + 48) - 1;
    v15 = 0.5;
    v16 = (float32x2_t)vdup_n_s32(0x37800000u);
    v17 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v18 = (float32x2_t)vdup_n_s32(0x47800000u);
    do
    {
      v19.f32[0] = (float)(1.0 / v9) * (float)v13;
      v19.f32[1] = (float)(1.0 / v9) * (float)v11;
      v20 = vcvt_s32_f32(v19);
      switch(v14)
      {
        case 0:
          v21 = vmul_f32(*(float32x2_t *)(v5 + 10), vcvt_f32_s32(v20));
          v22 = vmul_f32(v21, v21);
          v23 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v22, 1), v22);
          v22.f32[0] = fmaxf(vaddv_f32(v22), 0.00001);
          v22.i32[0] = vmul_f32(v23, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v22, 0))).u32[0];
          v22.f32[1] = v15;
          v24 = vmul_f32(v22, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 1:
          v25 = atan2f(v5[11] * (float)v20.i32[1], v5[10] * (float)v20.i32[0]);
          v26.i32[1] = 1056964608;
          v26.f32[0] = (float)(v25 * -10430.0) + 32768.0;
          v24 = vmul_f32(v26, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6)));
          goto LABEL_8;
        case 2:
          v27 = vmul_f32(vcvt_f32_s32(v20), vmul_f32(v16, *(float32x2_t *)(v5 + 10)));
          v24 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v27, vrndm_f32(v27)), v17)), vmul_f32(v18, vcvt_f32_u32(*(uint32x2_t *)(v5 + 6))));
          goto LABEL_8;
        case 4:
          v28 = vcvt_f32_s32(v20);
          v29 = vcvt_f32_s32(*(int32x2_t *)(v5 + 8));
          v30 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v29);
          v31 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v29);
          v32 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v28, v31), (int8x8_t)v31, (int8x8_t)v28);
          v24 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v32), (int8x8_t)v30, (int8x8_t)v32);
LABEL_8:
          v20 = vcvt_s32_f32(v24);
          break;
        default:
          break;
      }
      --v4;
      v33 = v20.i32[0] & ~(v20.i32[0] >> 31);
      if (v33 >= v6)
        v33 = v6;
      v34 = v20.i32[1] & ~(v20.i32[1] >> 31);
      if (v34 >= v7)
        v34 = v7;
      v35 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v39
                                                                         + v38 * ((uint64_t)v34 >> 16)
                                                                         + (((uint64_t)v33 >> 15) & 0xFFFFFFFFFFFFFFFELL)));
      if (v35 > 1.0)
        v35 = 1.0;
      v15 = 0.5;
      if (v35 >= 0.0)
        v36 = (float)(v35 * 255.0) + 0.5;
      else
        v36 = 0.5;
      v9 = v9 + v8;
      v13 += v12;
      v11 += v10;
      *a3++ = (v36 << 16) | (v36 << 8) | v36 | 0xFF000000;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,false,false,false,true>(_DWORD *a1, int a2, _DWORD *a3, int16x4_t a4)
{
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  float32x2_t v14;
  unint64_t v20;
  unint64_t v21;
  float v22;
  float32x2_t v23;
  int8x8_t v24;
  int8x8_t v25;
  float v26;
  float32x2_t v27;
  int8x8_t v28;
  int8x16_t v29;
  int16x4_t v30;
  float v31;
  float v32;

  if (a2)
  {
    v5 = a2;
    v7 = a1[14];
    v6 = a1[15];
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v9 = **(_QWORD **)a1;
    v10 = v6 + 0x8000;
    v6 -= 0x8000;
    v11 = v9 + v8 * ((uint64_t)(int)v6 >> 16);
    v12 = v9 + v8 * ((uint64_t)(int)v10 >> 16);
    a4.i32[0] = (v6 >> 1) & 0x7F80;
    v30 = a4;
    v13 = a1[13] - 0x8000;
    v14 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V9.2S, #1.0 }
    do
    {
      --v5;
      v20 = ((uint64_t)v13 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v21 = ((uint64_t)(v13 + 0x10000) >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v31 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v11 + v20));
      v22 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v11 + v21));
      v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v22), LODWORD(v31)), _D9), (int8x8_t)_D9, (int8x8_t)__PAIR64__(LODWORD(v22), LODWORD(v31)));
      v24 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v23), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v23)));
      v25 = vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v24, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v24, (uint32x2_t)0x1000000008)), v24);
      v32 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v12 + v20));
      v26 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v12 + v21));
      v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v26), LODWORD(v32)), _D9), (int8x8_t)_D9, (int8x8_t)__PAIR64__(LODWORD(v26), LODWORD(v32)));
      v28 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v27), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v27)));
      v29 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v28, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v28, (uint32x2_t)0x1000000008)), v28) | 0xFF000000FF000000), (uint8x8_t)(*(_QWORD *)&v25 | 0xFF000000FF000000)), v30, 0), (uint8x8_t)(*(_QWORD *)&v25 | 0xFF000000FF000000));
      *(int16x4_t *)v29.i8 = vadd_s16(*(int16x4_t *)v29.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL), *(int16x4_t *)v29.i8), vdup_n_s16((v13 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v29.i8, *(int8x8_t *)v29.i8).u32[0];
      v13 += v7;
    }
    while (v5);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  float32x2_t v9;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  float v19;
  float32x2_t v20;
  int8x8_t v21;
  int8x8_t v22;
  float v23;
  float32x2_t v24;
  int8x8_t v25;
  int8x16_t v26;
  int v27;
  int v28;
  float v29;
  float v30;

  if (a2)
  {
    v4 = a2;
    v5 = **(_QWORD **)a1;
    v6 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v27 = a1[14];
    v28 = a1[16];
    v7 = a1[13] - 0x8000;
    v8 = a1[15] - 0x8000;
    v9 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V9.2S, #1.0 }
    do
    {
      --v4;
      v15 = v5 + v6 * ((uint64_t)v8 >> 16);
      v16 = v5 + v6 * ((uint64_t)(v8 + 0x10000) >> 16);
      v17 = ((uint64_t)v7 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v18 = ((uint64_t)(v7 + 0x10000) >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v29 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v17));
      v19 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v18));
      v20 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v19), LODWORD(v29)), _D9), (int8x8_t)_D9, (int8x8_t)__PAIR64__(LODWORD(v19), LODWORD(v29)));
      v21 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v20), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v9, v20)));
      v22 = vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v21, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v21, (uint32x2_t)0x1000000008)), v21);
      v30 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v16 + v17));
      v23 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v16 + v18));
      v24 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v23), LODWORD(v30)), _D9), (int8x8_t)_D9, (int8x8_t)__PAIR64__(LODWORD(v23), LODWORD(v30)));
      v25 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v24), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v9, v24)));
      v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v25, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v25, (uint32x2_t)0x1000000008)), v25) | 0xFF000000FF000000), (uint8x8_t)(*(_QWORD *)&v22 | 0xFF000000FF000000)), vdupq_n_s16((v8 >> 1) & 0x7F80)), (uint8x8_t)(*(_QWORD *)&v22 | 0xFF000000FF000000));
      *(int16x4_t *)v26.i8 = vadd_s16(*(int16x4_t *)v26.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v26.i8, *(int8x8_t *)v26.i8).u32[0];
      v7 += v27;
      v8 += v28;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,false,true,false,true>(_DWORD *a1, int a2, _DWORD *a3, int16x4_t a4)
{
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  float32x2_t v17;
  int v23;
  unsigned int v24;
  int v25;
  int v26;
  int v27;
  unint64_t v28;
  uint64_t v29;
  float v30;
  float32x2_t v31;
  int8x8_t v32;
  int8x8_t v33;
  float v34;
  float32x2_t v35;
  int8x8_t v36;
  int8x16_t v37;
  int16x4_t v38;
  int v39;
  float v40;
  float v41;

  if (a2)
  {
    v5 = a2;
    v6 = a1[15];
    v39 = a1[14];
    v7 = a1[13];
    v9 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v8 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v10 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v11 = **(_QWORD **)a1;
    v12 = v8 - 0x8000;
    if (v6 < v8 - 0x8000)
      v12 = a1[15];
    if (v12 <= -32768)
      v12 = -32768;
    v13 = v12 + 0x8000;
    if (v6 <= 0x8000)
      v6 = 0x8000;
    v14 = v6 - 0x8000;
    if (v14 >= v8)
      v14 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v15 = v11 + v10 * ((uint64_t)v14 >> 16);
    v16 = v11 + v10 * HIWORD(v13);
    a4.i32[0] = (v14 >> 1) & 0x7F80;
    v38 = a4;
    v17 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V9.2S, #1.0 }
    do
    {
      --v5;
      if (v7 >= v9 - 0x8000)
        v23 = v9 - 0x8000;
      else
        v23 = v7;
      if (v23 <= -32768)
        v23 = -32768;
      v24 = v23 + 0x8000;
      if (v7 <= 0x8000)
        v25 = 0x8000;
      else
        v25 = v7;
      v26 = v25 - 0x8000;
      if (v26 >= v9)
        v27 = v9;
      else
        v27 = v26;
      v28 = ((uint64_t)v27 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v29 = (v24 >> 15) & 0x1FFFE;
      v40 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v28));
      v30 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v29));
      v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v30), LODWORD(v40)), _D9), (int8x8_t)_D9, (int8x8_t)__PAIR64__(LODWORD(v30), LODWORD(v40)));
      v32 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v31), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v17, v31)));
      v33 = vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v32, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v32, (uint32x2_t)0x1000000008)), v32);
      v41 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v16 + v28));
      v34 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v16 + v29));
      v35 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v34), LODWORD(v41)), _D9), (int8x8_t)_D9, (int8x8_t)__PAIR64__(LODWORD(v34), LODWORD(v41)));
      v36 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v35), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v17, v35)));
      v37 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v36, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v36, (uint32x2_t)0x1000000008)), v36) | 0xFF000000FF000000), (uint8x8_t)(*(_QWORD *)&v33 | 0xFF000000FF000000)), v38, 0), (uint8x8_t)(*(_QWORD *)&v33 | 0xFF000000FF000000));
      *(int16x4_t *)v37.i8 = vadd_s16(*(int16x4_t *)v37.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL), *(int16x4_t *)v37.i8), vdup_n_s16((v27 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v37.i8, *(int8x8_t *)v37.i8).u32[0];
      v7 += v39;
    }
    while (v5);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  int v4;
  int v5;
  int v6;
  float32x2_t v7;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  float v27;
  float32x2_t v28;
  int8x8_t v29;
  int8x8_t v30;
  float v31;
  float32x2_t v32;
  int8x8_t v33;
  int8x16_t v34;
  int v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  float v41;
  float v42;

  if (a2)
  {
    v4 = a2;
    v39 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v40 = **(_QWORD **)a1;
    v5 = a1[15];
    v6 = a1[13];
    v35 = a1[14];
    v36 = a1[16];
    v37 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v38 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v7 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V9.2S, #1.0 }
    do
    {
      --v4;
      v13 = v38 - 0x8000;
      if (v6 < v38 - 0x8000)
        v13 = v6;
      if (v13 <= -32768)
        v13 = -32768;
      v14 = v13 + 0x8000;
      if (v6 <= 0x8000)
        v15 = 0x8000;
      else
        v15 = v6;
      v16 = v15 - 0x8000;
      if (v16 >= v38)
        v17 = v38;
      else
        v17 = v16;
      v18 = v37 - 0x8000;
      if (v5 < v37 - 0x8000)
        v18 = v5;
      if (v18 <= -32768)
        v18 = -32768;
      v19 = v18 + 0x8000;
      if (v5 <= 0x8000)
        v20 = 0x8000;
      else
        v20 = v5;
      v21 = v20 - 0x8000;
      if (v21 >= v37)
        v22 = v37;
      else
        v22 = v21;
      v23 = v40 + v39 * ((uint64_t)v22 >> 16);
      v24 = v40 + v39 * HIWORD(v19);
      v25 = ((uint64_t)v17 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v26 = (v14 >> 15) & 0x1FFFE;
      v41 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v23 + v25));
      v27 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v23 + v26));
      v28 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v27), LODWORD(v41)), _D9), (int8x8_t)_D9, (int8x8_t)__PAIR64__(LODWORD(v27), LODWORD(v41)));
      v29 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v28), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v7, v28)));
      v30 = vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v29, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v29, (uint32x2_t)0x1000000008)), v29);
      v42 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v24 + v25));
      v31 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v24 + v26));
      v32 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v31), LODWORD(v42)), _D9), (int8x8_t)_D9, (int8x8_t)__PAIR64__(LODWORD(v31), LODWORD(v42)));
      v33 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v32), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v7, v32)));
      v34 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v33, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v33, (uint32x2_t)0x1000000008)), v33) | 0xFF000000FF000000), (uint8x8_t)(*(_QWORD *)&v30 | 0xFF000000FF000000)), vdupq_n_s16((v22 >> 1) & 0x7F80)), (uint8x8_t)(*(_QWORD *)&v30 | 0xFF000000FF000000));
      *(int16x4_t *)v34.i8 = vadd_s16(*(int16x4_t *)v34.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL), *(int16x4_t *)v34.i8), vdup_n_s16((v17 >> 1) & 0x7F80)));
      v6 += v35;
      *a3++ = vuzp1_s8(*(int8x8_t *)v34.i8, *(int8x8_t *)v34.i8).u32[0];
      v5 += v36;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lh,unsigned int,true,true,true,true>(uint64_t **a1, int a2, _DWORD *a3)
{
  int v4;
  float v5;
  float v6;
  int v7;
  int v8;
  int v9;
  float32x2_t v15;
  float32x2_t v16;
  int32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  int v30;
  int v31;
  unsigned int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  unsigned int v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  float v44;
  float32x2_t v45;
  int8x8_t v46;
  int8x8_t v47;
  float v48;
  float32x2_t v49;
  int8x8_t v50;
  int8x16_t v51;
  float32x2_t v52;
  float32x2_t v53;
  float32x2_t v54;
  float *v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  float v64;
  float v65;

  if (a2)
  {
    v4 = a2;
    v62 = (*a1)[2];
    v63 = **a1;
    v56 = (float *)*a1;
    v5 = *((float *)a1[3] + 3);
    v6 = *((float *)a1[2] + 3);
    v7 = *((_DWORD *)a1 + 15);
    v59 = *((_DWORD *)a1 + 16);
    v60 = *((_DWORD *)*a1 + 9);
    v8 = *((_DWORD *)a1 + 13);
    v58 = *((_DWORD *)a1 + 14);
    v61 = *((_DWORD *)*a1 + 8);
    v9 = *((unsigned __int8 *)a1 + 48) - 1;
    __asm { FMOV            V11.2S, #1.0 }
    v15 = (float32x2_t)vdup_n_s32(0x437F0000u);
    v53 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v54 = (float32x2_t)vdup_n_s32(0x37800000u);
    v52 = (float32x2_t)vdup_n_s32(0x47800000u);
    v57 = v9;
    do
    {
      v16.f32[0] = (float)(1.0 / v6) * (float)v8;
      v16.f32[1] = (float)(1.0 / v6) * (float)v7;
      v17 = vcvt_s32_f32(v16);
      switch(v9)
      {
        case 0:
          v18 = vmul_f32(*(float32x2_t *)(v56 + 10), vcvt_f32_s32(v17));
          v19 = vmul_f32(v18, v18);
          v20 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v19, 1), v19);
          v19.f32[0] = fmaxf(vaddv_f32(v19), 0.00001);
          v19.i32[0] = vmul_f32(v20, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v19, 0))).u32[0];
          v19.i32[1] = 0.5;
          v21 = vmul_f32(v19, vcvt_f32_u32(*(uint32x2_t *)(v56 + 6)));
          goto LABEL_8;
        case 1:
          v22 = atan2f(v56[11] * (float)v17.i32[1], v56[10] * (float)v17.i32[0]);
          v23.i32[1] = 1056964608;
          v23.f32[0] = (float)(v22 * -10430.0) + 32768.0;
          v21 = vmul_f32(v23, vcvt_f32_u32(*(uint32x2_t *)(v56 + 6)));
          goto LABEL_8;
        case 2:
          v24 = vmul_f32(vcvt_f32_s32(v17), vmul_f32(v54, *(float32x2_t *)(v56 + 10)));
          v21 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v24, vrndm_f32(v24)), v53)), vmul_f32(v52, vcvt_f32_u32(*(uint32x2_t *)(v56 + 6))));
          goto LABEL_8;
        case 4:
          v25 = vcvt_f32_s32(v17);
          v26 = vcvt_f32_s32(*(int32x2_t *)(v56 + 8));
          v27 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v26);
          v28 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v26);
          v29 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v25, v28), (int8x8_t)v28, (int8x8_t)v25);
          v21 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, v29), (int8x8_t)v27, (int8x8_t)v29);
LABEL_8:
          v17 = vcvt_s32_f32(v21);
          break;
        default:
          break;
      }
      --v4;
      v30 = v17.i32[0];
      v31 = v61 - 0x8000;
      if (v17.i32[0] < v61 - 0x8000)
        v31 = v17.i32[0];
      if (v31 <= -32768)
        v31 = -32768;
      v32 = v31 + 0x8000;
      if (v17.i32[0] <= 0x8000)
        v30 = 0x8000;
      v33 = v30 - 0x8000;
      if (v33 >= v61)
        v34 = v61;
      else
        v34 = v33;
      v35 = v17.i32[1];
      v36 = v60 - 0x8000;
      if (v17.i32[1] < v60 - 0x8000)
        v36 = v17.i32[1];
      if (v36 <= -32768)
        v36 = -32768;
      v37 = v36 + 0x8000;
      if (v17.i32[1] <= 0x8000)
        v35 = 0x8000;
      v38 = v35 - 0x8000;
      if (v38 >= v60)
        v39 = v60;
      else
        v39 = v38;
      v40 = v63 + v62 * ((uint64_t)v39 >> 16);
      v41 = v63 + v62 * HIWORD(v37);
      v42 = ((uint64_t)v34 >> 15) & 0xFFFFFFFFFFFFFFFELL;
      v43 = (v32 >> 15) & 0x1FFFE;
      v64 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v40 + v42));
      v44 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v40 + v43));
      v45 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v44), LODWORD(v64)), _D11), (int8x8_t)_D11, (int8x8_t)__PAIR64__(LODWORD(v44), LODWORD(v64)));
      v46 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v45), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v15, v45)));
      v47 = vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v46, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v46, (uint32x2_t)0x1000000008)), v46);
      v65 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v41 + v42));
      v48 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v41 + v43));
      v49 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v48), LODWORD(v65)), _D11), (int8x8_t)_D11, (int8x8_t)__PAIR64__(LODWORD(v48), LODWORD(v65)));
      v50 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v49), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v15, v49)));
      v51 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v50, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v50, (uint32x2_t)0x1000000008)), v50) | 0xFF000000FF000000), (uint8x8_t)(*(_QWORD *)&v47 | 0xFF000000FF000000)), vdupq_n_s16((v39 >> 1) & 0x7F80)), (uint8x8_t)(*(_QWORD *)&v47 | 0xFF000000FF000000));
      *(int16x4_t *)v51.i8 = vadd_s16(*(int16x4_t *)v51.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v51, v51, 8uLL), *(int16x4_t *)v51.i8), vdup_n_s16((v34 >> 1) & 0x7F80)));
      v6 = v6 + v5;
      v8 += v58;
      v7 += v59;
      *a3++ = vuzp1_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)v51.i8).u32[0];
      v9 = v57;
    }
    while (v4);
  }
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  float v6;
  float v7;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 52);
    v3 = *(_DWORD *)(result + 56);
    v5 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      v6 = *(float *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v6 > 1.0)
        v6 = 1.0;
      if (v6 >= 0.0)
        v7 = (float)(v6 * 255.0) + 0.5;
      else
        v7 = 0.5;
      v4 += v3;
      *a3++ = (v7 << 16) | (v7 << 8) | v7 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  float v9;
  float v10;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v6 = result[15];
    v5 = result[16];
    v8 = result[13];
    v7 = result[14];
    do
    {
      v9 = *(float *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v9 > 1.0)
        v9 = 1.0;
      if (v9 >= 0.0)
        v10 = (float)(v9 * 255.0) + 0.5;
      else
        v10 = 0.5;
      v8 += v7;
      v6 += v5;
      *a3++ = (v10 << 16) | (v10 << 8) | v10 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  float v9;
  float v10;

  if (a2)
  {
    v3 = result[14];
    v4 = result[13];
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(_QWORD *)result + 36))
      v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v7 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5)
        v8 = v5;
      v9 = *(float *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v9 > 1.0)
        v9 = 1.0;
      if (v9 >= 0.0)
        v10 = (float)(v9 * 255.0) + 0.5;
      else
        v10 = 0.5;
      v4 += v3;
      *a3++ = (v10 << 16) | (v10 << 8) | v10 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  float v13;
  float v14;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      v13 = *(float *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v13 > 1.0)
        v13 = 1.0;
      if (v13 >= 0.0)
        v14 = (float)(v13 * 255.0) + 0.5;
      else
        v14 = 0.5;
      result = (int *)((v14 << 16) | (v14 << 8));
      v10 += v9;
      v8 += v7;
      *a3++ = result | v14 | 0xFF000000;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  __int32 v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  __int32 v36;
  int v37;
  float v38;
  float v39;
  int v40;
  uint64_t v41;
  int v42;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v10 = *((_DWORD *)*a1 + 8);
    v9 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = 0.5;
    v19 = (float32x2_t)vdup_n_s32(0x37800000u);
    v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    v42 = v13;
    v40 = v17;
    v41 = v8;
    do
    {
      v22.f32[0] = (float)(1.0 / v12) * (float)v16;
      v22.f32[1] = (float)(1.0 / v12) * (float)v14;
      v23 = vcvt_s32_f32(v22);
      switch(v17)
      {
        case 0:
          v24 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v23));
          v25 = vmul_f32(v24, v24);
          v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.f32[1] = v18;
          v27 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v28 = atan2f(v6[11] * (float)v23.i32[1], v6[10] * (float)v23.i32[0]);
          v18 = 0.5;
          v17 = v40;
          v8 = v41;
          v13 = v42;
          v29.i32[1] = 1056964608;
          v29.f32[0] = (float)(v28 * -10430.0) + 32768.0;
          v27 = vmul_f32(v29, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v30 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v19, *(float32x2_t *)(v6 + 10)));
          v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v30, vrndm_f32(v30)), v20)), vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v31 = vcvt_f32_s32(v23);
          v32 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v32);
          v34 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v32);
          v35 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v31, v34), (int8x8_t)v34, (int8x8_t)v31);
          v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v33, v35), (int8x8_t)v33, (int8x8_t)v35);
LABEL_8:
          v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      v36 = v23.i32[0] & ~(v23.i32[0] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v37 = v23.i32[1] & ~(v23.i32[1] >> 31);
      if (v37 >= v9)
        v37 = v9;
      v38 = *(float *)(v7 + v8 * ((uint64_t)v37 >> 16) + (((uint64_t)v36 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      if (v38 > 1.0)
        v38 = 1.0;
      if (v38 >= 0.0)
        v39 = v18 + (float)(v38 * 255.0);
      else
        v39 = v18;
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = (v39 << 16) | (v39 << 8) | v39 | 0xFF000000;
      --v4;
    }
    while (v4);
  }
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  float32x2_t v13;
  unint64_t v19;
  unint64_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int8x8_t v23;
  float32x2_t v24;
  float32x2_t v25;
  int8x8_t v26;
  unint64_t v27;
  int8x16_t v28;

  if (a2)
  {
    v4 = result[14];
    v5 = result[15];
    v6 = *(_QWORD *)(*(_QWORD *)result + 16);
    v7 = **(_QWORD **)result;
    v8 = v5 + 0x8000;
    v9 = v5 - 0x8000;
    v10 = v7 + v6 * ((uint64_t)(v5 - 0x8000) >> 16);
    v11 = v7 + v6 * ((uint64_t)v8 >> 16);
    a4.i32[0] = (v9 >> 1) & 0x7F80;
    v12 = result[13] - 0x8000;
    v13 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V2.2S, #1.0 }
    do
    {
      v19 = ((uint64_t)v12 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v20 = ((uint64_t)(v12 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v21.i32[0] = *(_DWORD *)(v10 + v19);
      v21.i32[1] = *(_DWORD *)(v10 + v20);
      v22 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v21, _D2), (int8x8_t)_D2, (int8x8_t)v21);
      v23 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v22), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v13, v22)));
      v24.i32[0] = *(_DWORD *)(v11 + v19);
      v24.i32[1] = *(_DWORD *)(v11 + v20);
      v25 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v24, _D2), (int8x8_t)_D2, (int8x8_t)v24);
      v26 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v25), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v13, v25)));
      v27 = *(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v23, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v23, (uint32x2_t)0x1000000008)), v23) | 0xFF000000FF000000;
      v28 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v26, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v26, (uint32x2_t)0x1000000008)), v26) | 0xFF000000FF000000), (uint8x8_t)v27), a4, 0), (uint8x8_t)v27);
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v28.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL), *(int16x4_t *)v28.i8), vdup_n_s16((v12 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      v12 += v4;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,true,false,false,true>(_DWORD *result, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  float32x2_t v9;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  float32x2_t v19;
  float32x2_t v20;
  int8x8_t v21;
  float32x2_t v22;
  float32x2_t v23;
  int8x8_t v24;
  unint64_t v25;
  int8x16_t v26;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = result[16];
    v6 = result[14];
    v7 = result[13] - 0x8000;
    v8 = result[15] - 0x8000;
    v9 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V1.2S, #1.0 }
    do
    {
      v15 = v3 + v4 * ((uint64_t)v8 >> 16);
      v16 = v3 + v4 * ((uint64_t)(v8 + 0x10000) >> 16);
      v17 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v18 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      result = (_DWORD *)(v15 + v18);
      v19.i32[0] = *(_DWORD *)(v15 + v17);
      v19.i32[1] = *(_DWORD *)(v15 + v18);
      v20 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v19, _D1), (int8x8_t)_D1, (int8x8_t)v19);
      v21 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v20), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v9, v20)));
      v22.i32[0] = *(_DWORD *)(v16 + v17);
      v22.i32[1] = *(_DWORD *)(v16 + v18);
      v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v22, _D1), (int8x8_t)_D1, (int8x8_t)v22);
      v24 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v23), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v9, v23)));
      v25 = *(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v21, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v21, (uint32x2_t)0x1000000008)), v21) | 0xFF000000FF000000;
      v26 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v24, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v24, (uint32x2_t)0x1000000008)), v24) | 0xFF000000FF000000), (uint8x8_t)v25), vdupq_n_s16((v8 >> 1) & 0x7F80)), (uint8x8_t)v25);
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v26.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), *(int16x4_t *)v26.i8), vdup_n_s16((v7 >> 1) & 0x7F80))), (int8x8_t)v9).u32[0];
      v7 += v6;
      v8 += v5;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  float32x2_t v16;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  float32x2_t v27;
  float32x2_t v28;
  int8x8_t v29;
  float32x2_t v30;
  float32x2_t v31;
  int8x8_t v32;
  unint64_t v33;
  int8x16_t v34;

  if (a2)
  {
    v4 = result[14];
    v5 = result[15];
    v6 = result[13];
    v7 = *(_DWORD *)(*(_QWORD *)result + 32);
    v8 = *(_DWORD *)(*(_QWORD *)result + 36);
    v9 = *(_QWORD *)(*(_QWORD *)result + 16);
    v10 = **(_QWORD **)result;
    if (v5 >= v8 - 0x8000)
      v11 = v8 - 0x8000;
    else
      v11 = result[15];
    if (v11 <= -32768)
      v11 = -32768;
    if (v5 <= 0x8000)
      v5 = 0x8000;
    v12 = v5 - 0x8000;
    if (v12 >= v8)
      v13 = *(_DWORD *)(*(_QWORD *)result + 36);
    else
      v13 = v12;
    v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    v15 = v10 + v9 * ((v11 + 0x8000) >> 16);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    v16 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V2.2S, #1.0 }
    do
    {
      if (v6 >= v7 - 0x8000)
        v22 = v7 - 0x8000;
      else
        v22 = v6;
      if (v22 <= -32768)
        v22 = -32768;
      v23 = v22 + 0x8000;
      if (v6 <= 0x8000)
        v24 = 0x8000;
      else
        v24 = v6;
      v25 = v24 - 0x8000;
      if (v25 >= v7)
        v25 = v7;
      result = (_DWORD *)(((uint64_t)v25 >> 14) & 0xFFFFFFFFFFFFFFFCLL);
      v26 = (v23 >> 14) & 0x3FFFC;
      v27.i32[0] = *(_DWORD *)((char *)result + v14);
      v27.i32[1] = *(_DWORD *)(v14 + v26);
      v28 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, _D2), (int8x8_t)_D2, (int8x8_t)v27);
      v29 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v28), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v28)));
      v30.i32[0] = *(_DWORD *)((char *)result + v15);
      v30.i32[1] = *(_DWORD *)(v15 + v26);
      v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, _D2), (int8x8_t)_D2, (int8x8_t)v30);
      v32 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v31), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v31)));
      v33 = *(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v29, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v29, (uint32x2_t)0x1000000008)), v29) | 0xFF000000FF000000;
      v34 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v32, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v32, (uint32x2_t)0x1000000008)), v32) | 0xFF000000FF000000), (uint8x8_t)v33), a4, 0), (uint8x8_t)v33);
      v6 += v4;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v34.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL), *(int16x4_t *)v34.i8), vdup_n_s16((v25 >> 1) & 0x7F80))), (int8x8_t)a4).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  float32x2_t v11;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  float32x2_t v29;
  float32x2_t v30;
  int8x8_t v31;
  float32x2_t v32;
  float32x2_t v33;
  int8x8_t v34;
  unint64_t v35;
  int8x16_t v36;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = *(_DWORD *)(result + 60);
    v7 = *(_DWORD *)(result + 64);
    v10 = *(_DWORD *)(result + 52);
    v9 = *(_DWORD *)(result + 56);
    result = 4294934528;
    v11 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V1.2S, #1.0 }
    do
    {
      if (v10 >= v5 - 0x8000)
        v17 = v5 - 0x8000;
      else
        v17 = v10;
      if (v17 <= -32768)
        v18 = -32768;
      else
        v18 = v17;
      if (v10 <= 0x8000)
        v19 = 0x8000;
      else
        v19 = v10;
      v20 = v19 - 0x8000;
      if (v20 >= v5)
        v20 = v5;
      if (v8 >= v6 - 0x8000)
        v21 = v6 - 0x8000;
      else
        v21 = v8;
      if (v21 <= -32768)
        v21 = -32768;
      if (v8 <= 0x8000)
        v22 = 0x8000;
      else
        v22 = v8;
      v23 = v22 - 0x8000;
      v24 = v21 + 0x8000;
      if (v23 >= v6)
        v23 = v6;
      v25 = v3 + v4 * ((uint64_t)v23 >> 16);
      v26 = v3 + v4 * HIWORD(v24);
      v27 = ((uint64_t)v20 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v28 = ((v18 + 0x8000) >> 14) & 0x3FFFC;
      v29.i32[0] = *(_DWORD *)(v25 + v27);
      v29.i32[1] = *(_DWORD *)(v25 + v28);
      v30 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v29, _D1), (int8x8_t)_D1, (int8x8_t)v29);
      v31 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v30), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v11, v30)));
      v32.i32[0] = *(_DWORD *)(v26 + v27);
      v32.i32[1] = *(_DWORD *)(v26 + v28);
      v33 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, _D1), (int8x8_t)_D1, (int8x8_t)v32);
      v34 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v33), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v11, v33)));
      v35 = *(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v31, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v31, (uint32x2_t)0x1000000008)), v31) | 0xFF000000FF000000;
      v36 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v34, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v34, (uint32x2_t)0x1000000008)), v34) | 0xFF000000FF000000), (uint8x8_t)v35), vdupq_n_s16((v23 >> 1) & 0x7F80)), (uint8x8_t)v35);
      v10 += v9;
      v8 += v7;
      *a3++ = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v36.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL), *(int16x4_t *)v36.i8), vdup_n_s16((v20 >> 1) & 0x7F80))), (int8x8_t)v11).u32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::Lf,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  int32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  uint32x2_t *v32;
  uint64_t v33;
  uint64_t v34;
  float v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  float32x2_t v39;
  float32x2_t v40;
  float32x2_t v41;
  float32x2_t v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  int v47;
  int v48;
  unsigned int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  float32x2_t v55;
  float32x2_t v56;
  int8x8_t v57;
  float32x2_t v58;
  float32x2_t v59;
  int8x8_t v60;
  unint64_t v61;
  int8x16_t v62;
  float32x2_t v63;
  float32x2_t v64;
  int v65;
  uint64_t **v66;
  int v67;
  int v68;
  int v69;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = v9 - 0x8000;
    v18 = *((unsigned __int8 *)result + 48) - 1;
    __asm { FMOV            V11.2S, #1.0 }
    v24 = (float32x2_t)vdup_n_s32(0x437F0000u);
    v63 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v64 = (float32x2_t)vdup_n_s32(0x37800000u);
    v25 = (float32x2_t)vdup_n_s32(0x47800000u);
    v68 = v8;
    v69 = v12;
    v67 = v8 - 0x8000;
    v65 = v18;
    v66 = result;
    do
    {
      v26.f32[0] = (float)(1.0 / v11) * (float)v15;
      v26.f32[1] = (float)(1.0 / v11) * (float)v13;
      v27 = vcvt_s32_f32(v26);
      switch(v18)
      {
        case 0:
          v28 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v27));
          v29 = vmul_f32(v28, v28);
          v30 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v29, 1), v29);
          v29.f32[0] = fmaxf(vaddv_f32(v29), 0.00001);
          v29.i32[0] = vmul_f32(v30, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v29, 0))).u32[0];
          v29.i32[1] = 0.5;
          v31 = vmul_f32(v29, vcvt_f32_u32(v5[3]));
          goto LABEL_8;
        case 1:
          v32 = v5;
          v33 = v9;
          v34 = v14;
          v35 = atan2f(*(float *)&v5[5].i32[1] * (float)v27.i32[1], *(float *)v5[5].i32 * (float)v27.i32[0]);
          v18 = v65;
          result = v66;
          v16 = v67;
          v8 = v68;
          v14 = v34;
          v12 = v69;
          v9 = v33;
          v5 = v32;
          v36.i32[1] = 1056964608;
          v36.f32[0] = (float)(v35 * -10430.0) + 32768.0;
          v31 = vmul_f32(v36, vcvt_f32_u32(v32[3]));
          goto LABEL_8;
        case 2:
          v37 = vmul_f32(vcvt_f32_s32(v27), vmul_f32(v64, (float32x2_t)v5[5]));
          v31 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), *(float32x2_t *)((char *)result + 84), vminnm_f32(vsub_f32(v37, vrndm_f32(v37)), v63)), vmul_f32(v25, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v38 = vcvt_f32_s32(v27);
          v39 = vcvt_f32_s32((int32x2_t)v5[4]);
          v40 = vmul_f32(*(float32x2_t *)((char *)result + 84), v39);
          v41 = vmul_f32(*(float32x2_t *)((char *)result + 92), v39);
          v42 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v38, v41), (int8x8_t)v41, (int8x8_t)v38);
          v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v40, v42), (int8x8_t)v40, (int8x8_t)v42);
LABEL_8:
          v27 = vcvt_s32_f32(v31);
          break;
        default:
          break;
      }
      v43 = v27.i32[0];
      if (v27.i32[0] >= v16)
        v44 = v16;
      else
        v44 = v27.i32[0];
      if (v44 <= -32768)
        v44 = -32768;
      v45 = v44 + 0x8000;
      if (v27.i32[0] <= 0x8000)
        v43 = 0x8000;
      v46 = v43 - 0x8000;
      if (v46 >= v8)
        v46 = v8;
      v47 = v27.i32[1];
      if (v27.i32[1] >= v17)
        v48 = v17;
      else
        v48 = v27.i32[1];
      if (v48 <= -32768)
        v48 = -32768;
      v49 = v48 + 0x8000;
      if (v27.i32[1] <= 0x8000)
        v47 = 0x8000;
      v50 = v47 - 0x8000;
      if (v50 >= (int)v9)
        v50 = v9;
      v51 = v6 + v7 * ((uint64_t)v50 >> 16);
      v52 = v6 + v7 * HIWORD(v49);
      v53 = ((uint64_t)v46 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v54 = (v45 >> 14) & 0x3FFFC;
      v55.i32[0] = *(_DWORD *)(v51 + v53);
      v55.i32[1] = *(_DWORD *)(v51 + v54);
      v56 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v55, _D11), (int8x8_t)_D11, (int8x8_t)v55);
      v57 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v56), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v24, v56)));
      v58.i32[0] = *(_DWORD *)(v52 + v53);
      v58.i32[1] = *(_DWORD *)(v52 + v54);
      v59 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v58, _D11), (int8x8_t)_D11, (int8x8_t)v58);
      v60 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v59), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v24, v59)));
      v61 = *(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v57, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v57, (uint32x2_t)0x1000000008)), v57) | 0xFF000000FF000000;
      v62 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)(*(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v60, (uint32x2_t)0x800000010), (int8x8_t)vshl_u32((uint32x2_t)v60, (uint32x2_t)0x1000000008)), v60) | 0xFF000000FF000000), (uint8x8_t)v61), vdupq_n_s16((v50 >> 1) & 0x7F80)), (uint8x8_t)v61);
      *(int16x4_t *)v62.i8 = vadd_s16(*(int16x4_t *)v62.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v62, v62, 8uLL), *(int16x4_t *)v62.i8), vdup_n_s16((v46 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v62.i8, *(int8x8_t *)v62.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,false,false,false,false>(uint64_t result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  uint64_t v5;
  unsigned __int16 *v6;

  if (a2)
  {
    v4 = *(_DWORD *)(result + 52);
    v3 = *(_DWORD *)(result + 56);
    v5 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * *(__int16 *)(result + 62);
    do
    {
      v6 = (unsigned __int16 *)(v5 + (((uint64_t)v4 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v4 += v3;
      *a3++ = (v6[1] << 16) & 0xFF000000 | (HIBYTE(*v6) << 16) | (HIBYTE(*v6) << 8) | HIBYTE(*v6);
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,true,false,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned __int16 *v9;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v6 = result[15];
    v5 = result[16];
    v8 = result[13];
    v7 = result[14];
    do
    {
      v9 = (unsigned __int16 *)(v3 + v4 * ((uint64_t)v6 >> 16) + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v8 += v7;
      v6 += v5;
      *a3++ = (v9[1] << 16) & 0xFF000000 | (HIBYTE(*v9) << 16) | (HIBYTE(*v9) << 8) | HIBYTE(*v9);
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,false,true,false,false>(_DWORD *result, int a2, unsigned int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  unsigned __int16 *v9;

  if (a2)
  {
    v3 = result[14];
    v4 = result[13];
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = result[15] & ~((int)result[15] >> 31);
    if (v6 >= *(_DWORD *)(*(_QWORD *)result + 36))
      v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v7 = **(_QWORD **)result + *(_QWORD *)(*(_QWORD *)result + 16) * ((uint64_t)v6 >> 16);
    do
    {
      v8 = v4 & ~(v4 >> 31);
      if (v8 >= v5)
        v8 = v5;
      v9 = (unsigned __int16 *)(v7 + (((uint64_t)v8 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v4 += v3;
      *a3++ = (v9[1] << 16) & 0xFF000000 | (HIBYTE(*v9) << 16) | (HIBYTE(*v9) << 8) | HIBYTE(*v9);
      --a2;
    }
    while (a2);
  }
  return result;
}

int *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,true,true,false,false>(int *result, int a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned __int16 *v13;
  unsigned int v14;

  if (a2)
  {
    v3 = **(_QWORD **)result;
    v4 = *(_QWORD *)(*(_QWORD *)result + 16);
    v5 = *(_DWORD *)(*(_QWORD *)result + 32);
    v6 = *(_DWORD *)(*(_QWORD *)result + 36);
    v8 = result[15];
    v7 = result[16];
    v10 = result[13];
    v9 = result[14];
    do
    {
      v11 = v10 & ~(v10 >> 31);
      if (v11 >= v5)
        v11 = v5;
      v12 = v8 & ~(v8 >> 31);
      if (v12 >= v6)
        v12 = v6;
      v13 = (unsigned __int16 *)(v3 + v4 * ((uint64_t)v12 >> 16) + (((uint64_t)v11 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v14 = *v13;
      result = (int *)(v14 >> 8);
      v10 += v9;
      v8 += v7;
      *a3++ = (v13[1] << 16) & 0xFF000000 | ((_DWORD)result << 16) | ((_DWORD)result << 8) | (v14 >> 8);
      --a2;
    }
    while (a2);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,true,true,true,false>(uint64_t **a1, int a2, unsigned int *a3)
{
  int v4;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  __int32 v9;
  int v10;
  float v11;
  float v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  __int32 v35;
  int v36;
  unsigned __int16 *v37;
  __int32 v38;
  int v39;
  uint64_t v40;
  int v41;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v7 = **a1;
    v8 = (*a1)[2];
    v9 = *((_DWORD *)*a1 + 8);
    v10 = *((_DWORD *)*a1 + 9);
    v11 = *((float *)a1[3] + 3);
    v12 = *((float *)a1[2] + 3);
    v14 = *((_DWORD *)a1 + 15);
    v13 = *((_DWORD *)a1 + 16);
    v16 = *((_DWORD *)a1 + 13);
    v15 = *((_DWORD *)a1 + 14);
    v17 = *((unsigned __int8 *)a1 + 48) - 1;
    v18 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v41 = v13;
    v39 = v17;
    v40 = v8;
    v38 = v9;
    do
    {
      v21.f32[0] = (float)(1.0 / v12) * (float)v16;
      v21.f32[1] = (float)(1.0 / v12) * (float)v14;
      v22 = vcvt_s32_f32(v21);
      switch(v17)
      {
        case 0:
          v23 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v27 = atan2f(v6[11] * (float)v22.i32[1], v6[10] * (float)v22.i32[0]);
          v17 = v39;
          v8 = v40;
          v13 = v41;
          v9 = v38;
          v28.i32[1] = 1056964608;
          v28.f32[0] = (float)(v27 * -10430.0) + 32768.0;
          v26 = vmul_f32(v28, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v29 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v18, *(float32x2_t *)(v6 + 10)));
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v29, vrndm_f32(v29)), v19)), vmul_f32(v20, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v30 = vcvt_f32_s32(v22);
          v31 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v32 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v31);
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v31);
          v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v30, v33), (int8x8_t)v33, (int8x8_t)v30);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v32, v34), (int8x8_t)v32, (int8x8_t)v34);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v35 = v22.i32[0] & ~(v22.i32[0] >> 31);
      if (v35 >= v9)
        v35 = v9;
      v36 = v22.i32[1] & ~(v22.i32[1] >> 31);
      if (v36 >= v10)
        v36 = v10;
      v37 = (unsigned __int16 *)(v7 + v8 * ((uint64_t)v36 >> 16) + (((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v12 = v12 + v11;
      v16 += v15;
      v14 += v13;
      *a3++ = (v37[1] << 16) & 0xFF000000 | (HIBYTE(*v37) << 16) | (HIBYTE(*v37) << 8) | HIBYTE(*v37);
      --v4;
    }
    while (v4);
  }
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,false,false,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, double a6, double a7, int8x8_t a8, int8x8_t a9, double a10, int8x8_t a11)
{
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  unint64_t v20;
  __int16 *v21;
  __int16 *v22;
  unint64_t v23;
  __int16 *v24;
  __int16 *v25;
  uint32x2_t v26;
  int32x2_t v27;
  int8x8_t v28;
  int8x8_t v29;
  int8x8_t v30;
  uint32x2_t v31;
  int8x8_t v32;
  int32x2_t v33;
  int8x8_t v34;
  int8x8_t v35;
  uint8x8_t v36;
  int8x16_t v37;

  if (a2)
  {
    v11 = result[14];
    v12 = result[15];
    v13 = *(_QWORD *)(*(_QWORD *)result + 16);
    v14 = **(_QWORD **)result;
    v15 = v12 + 0x8000;
    v16 = v12 - 0x8000;
    v17 = v14 + v13 * ((uint64_t)(v12 - 0x8000) >> 16);
    v18 = v14 + v13 * ((uint64_t)v15 >> 16);
    a4.i32[0] = (v16 >> 1) & 0x7F80;
    v19 = result[13] - 0x8000;
    do
    {
      v20 = ((uint64_t)v19 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v21 = (__int16 *)(v17 + v20);
      v22 = (__int16 *)(v18 + v20);
      v23 = ((uint64_t)(v19 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v24 = (__int16 *)(v17 + v23);
      v25 = (__int16 *)(v18 + v23);
      a8.i16[0] = v21[1];
      a8.i16[2] = *v24;
      a9.i16[0] = *v21;
      a9.i16[2] = v24[1];
      v26 = vshr_n_u32((uint32x2_t)vand_s8(a8, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v27 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(a9, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v28 = (int8x8_t)vshl_u32((uint32x2_t)v27, (uint32x2_t)0x1800000010);
      a11.i16[0] = v22[1];
      v29 = (int8x8_t)vshl_u32(v26, (uint32x2_t)0x1000000018);
      a11.i16[2] = *v25;
      v30 = vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL);
      v27.i32[1] = v26.i32[1];
      v31 = vshr_n_u32((uint32x2_t)v30, 8uLL);
      v30.i16[0] = *v22;
      v30.i16[2] = v25[1];
      v32 = vorr_s8(v28, v29);
      v33 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(v30, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v34 = vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v33, (uint32x2_t)0x1800000010), (int8x8_t)vshl_u32(v31, (uint32x2_t)0x1000000018));
      v33.i32[1] = v31.i32[1];
      v35 = (int8x8_t)vshl_n_s32(v33, 8uLL);
      a11 = vorr_s8(v34, (int8x8_t)v33);
      v36 = (uint8x8_t)vorr_s8(vorr_s8(v32, (int8x8_t)v27), (int8x8_t)vshl_n_s32(v27, 8uLL));
      v37 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(a11, v35), v36), a4, 0), v36);
      a9 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL), *(int16x4_t *)v37.i8), vdup_n_s16((v19 >> 1) & 0x7F80));
      a8 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v37.i8, (int16x4_t)a9), (int8x8_t)a4);
      *a3++ = a8.i32[0];
      v19 += v11;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,true,false,false,true>(uint64_t **result, int a2, _DWORD *a3, double a4, double a5, double a6, int8x8_t a7, int8x8_t a8, double a9, double a10, int8x8_t a11)
{
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  __int16 *v20;
  unint64_t v21;
  __int16 *v22;
  __int16 *v23;
  uint32x2_t v24;
  int32x2_t v25;
  int8x8_t v26;
  int8x8_t v27;
  uint32x2_t v28;
  int8x8_t v29;
  uint32x2_t v30;
  int32x2_t v31;
  uint8x8_t v32;
  int8x16_t v33;

  if (a2)
  {
    v11 = **result;
    v12 = (*result)[2];
    v13 = *((_DWORD *)result + 16);
    v14 = *((_DWORD *)result + 14);
    v15 = *((_DWORD *)result + 13) - 0x8000;
    v16 = *((_DWORD *)result + 15) - 0x8000;
    do
    {
      v17 = v11 + v12 * ((uint64_t)v16 >> 16);
      v18 = v11 + v12 * ((uint64_t)(v16 + 0x10000) >> 16);
      v19 = ((uint64_t)v15 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      result = (uint64_t **)(v17 + v19);
      v20 = (__int16 *)(v18 + v19);
      v21 = ((uint64_t)(v15 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v22 = (__int16 *)(v17 + v21);
      v23 = (__int16 *)(v18 + v21);
      a7.i16[0] = *((_WORD *)result + 1);
      a7.i16[2] = *v22;
      a8.i16[0] = *(_WORD *)result;
      a8.i16[2] = v22[1];
      v24 = vshr_n_u32((uint32x2_t)vand_s8(a7, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v25 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(a8, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v26 = (int8x8_t)vshl_u32((uint32x2_t)v25, (uint32x2_t)0x1800000010);
      v27 = (int8x8_t)vshl_u32(v24, (uint32x2_t)0x1000000018);
      a11.i16[0] = v20[1];
      a11.i16[2] = *v23;
      v25.i32[1] = v24.i32[1];
      v28 = (uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL);
      a11.i16[0] = *v20;
      a11.i16[2] = v23[1];
      v29 = vorr_s8(v26, v27);
      v30 = vshr_n_u32(v28, 8uLL);
      v31 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      a11 = vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v31, (uint32x2_t)0x1800000010), (int8x8_t)vshl_u32(v30, (uint32x2_t)0x1000000018));
      v31.i32[1] = v30.i32[1];
      v32 = (uint8x8_t)vorr_s8(vorr_s8(v29, (int8x8_t)v25), (int8x8_t)vshl_n_s32(v25, 8uLL));
      v33 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8(a11, (int8x8_t)v31), (int8x8_t)vshl_n_s32(v31, 8uLL)), v32), vdupq_n_s16((v16 >> 1) & 0x7F80)), v32);
      a8 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL), *(int16x4_t *)v33.i8), vdup_n_s16((v15 >> 1) & 0x7F80));
      a7 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v33.i8, (int16x4_t)a8), (int8x8_t)0xFFFF0000FFFFLL);
      *a3++ = a7.i32[0];
      v15 += v14;
      v16 += v13;
      --a2;
    }
    while (a2);
  }
  return result;
}

_DWORD *CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,false,true,false,true>(_DWORD *result, int a2, _DWORD *a3, int16x4_t a4, double a5, double a6, double a7, int8x8_t a8, int8x8_t a9, double a10, int8x8_t a11)
{
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  unint64_t v27;
  __int16 *v28;
  __int16 *v29;
  uint64_t v30;
  __int16 *v31;
  uint32x2_t v32;
  int32x2_t v33;
  int8x8_t v34;
  int8x8_t v35;
  int8x8_t v36;
  uint32x2_t v37;
  int8x8_t v38;
  int32x2_t v39;
  int8x8_t v40;
  int8x8_t v41;
  uint8x8_t v42;
  int8x16_t v43;

  if (a2)
  {
    v11 = result[14];
    v12 = result[15];
    v13 = result[13];
    v14 = *(_DWORD *)(*(_QWORD *)result + 32);
    v15 = *(_DWORD *)(*(_QWORD *)result + 36);
    v16 = *(_QWORD *)(*(_QWORD *)result + 16);
    v17 = **(_QWORD **)result;
    if (v12 >= v15 - 0x8000)
      v18 = v15 - 0x8000;
    else
      v18 = result[15];
    if (v18 <= -32768)
      v18 = -32768;
    if (v12 <= 0x8000)
      v12 = 0x8000;
    v19 = v12 - 0x8000;
    if (v19 >= v15)
      v20 = *(_DWORD *)(*(_QWORD *)result + 36);
    else
      v20 = v19;
    v21 = v17 + v16 * ((uint64_t)v20 >> 16);
    v22 = v17 + v16 * ((v18 + 0x8000) >> 16);
    a4.i32[0] = (v20 >> 1) & 0x7F80;
    do
    {
      if (v13 >= v14 - 0x8000)
        v23 = v14 - 0x8000;
      else
        v23 = v13;
      if (v23 <= -32768)
        v23 = -32768;
      if (v13 <= 0x8000)
        v24 = 0x8000;
      else
        v24 = v13;
      v25 = v23 + 0x8000;
      v26 = v24 - 0x8000;
      if (v24 - 0x8000 >= v14)
        v26 = v14;
      v27 = ((uint64_t)v26 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v28 = (__int16 *)(v21 + v27);
      v29 = (__int16 *)(v22 + v27);
      v30 = (v25 >> 14) & 0x3FFFC;
      v31 = (__int16 *)(v21 + v30);
      result = (_DWORD *)(v22 + v30);
      a8.i16[0] = v28[1];
      a8.i16[2] = *v31;
      a9.i16[0] = *v28;
      a9.i16[2] = v31[1];
      v32 = vshr_n_u32((uint32x2_t)vand_s8(a8, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v33 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(a9, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v34 = (int8x8_t)vshl_u32((uint32x2_t)v33, (uint32x2_t)0x1800000010);
      a11.i16[0] = v29[1];
      v35 = (int8x8_t)vshl_u32(v32, (uint32x2_t)0x1000000018);
      a11.i16[2] = *(_WORD *)result;
      v36 = vand_s8(a11, (int8x8_t)0xFFFF0000FFFFLL);
      v33.i32[1] = v32.i32[1];
      v37 = vshr_n_u32((uint32x2_t)v36, 8uLL);
      v36.i16[0] = *v29;
      v36.i16[2] = *((_WORD *)result + 1);
      v38 = vorr_s8(v34, v35);
      v39 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(v36, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v40 = vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v39, (uint32x2_t)0x1800000010), (int8x8_t)vshl_u32(v37, (uint32x2_t)0x1000000018));
      v39.i32[1] = v37.i32[1];
      v41 = (int8x8_t)vshl_n_s32(v39, 8uLL);
      a11 = vorr_s8(v40, (int8x8_t)v39);
      v42 = (uint8x8_t)vorr_s8(vorr_s8(v38, (int8x8_t)v33), (int8x8_t)vshl_n_s32(v33, 8uLL));
      v43 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(a11, v41), v42), a4, 0), v42);
      a9 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL), *(int16x4_t *)v43.i8), vdup_n_s16((v26 >> 1) & 0x7F80));
      a8 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v43.i8, (int16x4_t)a9), (int8x8_t)a4);
      v13 += v11;
      *a3++ = a8.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,true,true,false,true>(uint64_t result, int a2, _DWORD *a3, double a4, double a5, double a6, int8x8_t a7, int8x8_t a8, int8x8_t a9, int16x8_t a10)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  __int16 *v29;
  unsigned __int16 *v30;
  uint64_t v31;
  __int16 *v32;
  __int16 *v33;
  int32x2_t v34;
  uint32x2_t v35;
  uint32x2_t v36;
  int32x2_t v37;
  int8x8_t v38;
  int8x8_t v39;
  int8x8_t v40;
  int8x8_t v41;
  uint8x8_t v42;
  uint8x8_t v43;
  int8x16_t v44;

  if (a2)
  {
    v10 = **(_QWORD **)result;
    v11 = *(_QWORD *)(*(_QWORD *)result + 16);
    v12 = *(_DWORD *)(*(_QWORD *)result + 32);
    v13 = *(_DWORD *)(*(_QWORD *)result + 36);
    v15 = *(_DWORD *)(result + 60);
    v14 = *(_DWORD *)(result + 64);
    v17 = *(_DWORD *)(result + 52);
    v16 = *(_DWORD *)(result + 56);
    result = 4294934528;
    do
    {
      if (v17 >= v12 - 0x8000)
        v18 = v12 - 0x8000;
      else
        v18 = v17;
      if (v18 <= -32768)
        v19 = -32768;
      else
        v19 = v18;
      if (v17 <= 0x8000)
        v20 = 0x8000;
      else
        v20 = v17;
      v21 = v20 - 0x8000;
      if (v21 >= v12)
        v21 = v12;
      if (v15 >= v13 - 0x8000)
        v22 = v13 - 0x8000;
      else
        v22 = v15;
      if (v22 <= -32768)
        v22 = -32768;
      v23 = v22 + 0x8000;
      if (v15 <= 0x8000)
        v24 = 0x8000;
      else
        v24 = v15;
      v25 = v24 - 0x8000;
      if (v25 >= v13)
        v25 = v13;
      v26 = v10 + v11 * ((uint64_t)v25 >> 16);
      v27 = v10 + v11 * HIWORD(v23);
      v28 = ((uint64_t)v21 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v29 = (__int16 *)(v26 + v28);
      v30 = (unsigned __int16 *)(v27 + v28);
      v31 = ((v19 + 0x8000) >> 14) & 0x3FFFC;
      v32 = (__int16 *)(v27 + v31);
      v33 = (__int16 *)(v26 + v31);
      a7.i16[0] = v29[1];
      a7.i16[2] = *v33;
      a8.i16[0] = *v29;
      a8.i16[2] = v33[1];
      a9.i16[0] = v30[1];
      a9.i16[2] = *v32;
      v34 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(a8, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v35 = vshr_n_u32((uint32x2_t)vand_s8(a9, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      a10.i16[0] = *v30;
      v36 = vshr_n_u32((uint32x2_t)vand_s8(a7, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      a10.i16[2] = v32[1];
      v37 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(*(int8x8_t *)a10.i8, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v38 = vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v37, (uint32x2_t)0x1800000010), (int8x8_t)vshl_u32(v35, (uint32x2_t)0x1000000018));
      v39 = (int8x8_t)vshl_u32((uint32x2_t)v34, (uint32x2_t)0x1800000010);
      v34.i32[1] = v36.i32[1];
      v37.i32[1] = v35.i32[1];
      v40 = (int8x8_t)vshl_n_s32(v34, 8uLL);
      v41 = vorr_s8(vorr_s8(v39, (int8x8_t)vshl_u32(v36, (uint32x2_t)0x1000000018)), (int8x8_t)v34);
      v42 = (uint8x8_t)vorr_s8(vorr_s8(v38, (int8x8_t)v37), (int8x8_t)vshl_n_s32(v37, 8uLL));
      a10 = vdupq_n_s16((v25 >> 1) & 0x7F80);
      v43 = (uint8x8_t)vorr_s8(v41, v40);
      v44 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8(v42, v43), a10), v43);
      a9 = (int8x8_t)vdup_n_s16((v21 >> 1) & 0x7F80);
      a8 = (int8x8_t)vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v44, v44, 8uLL), *(int16x4_t *)v44.i8), (int16x4_t)a9);
      a7 = vuzp1_s8((int8x8_t)vadd_s16(*(int16x4_t *)v44.i8, (int16x4_t)a8), (int8x8_t)0xFFFF0000FFFFLL);
      v17 += v16;
      v15 += v14;
      *a3++ = a7.i32[0];
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t **CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LA16,unsigned int,true,true,true,true>(uint64_t **result, int a2, _DWORD *a3)
{
  int v4;
  uint32x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  uint32x2_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  int v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  __int16 *v49;
  __int16 *v50;
  uint64_t v51;
  __int16 *v52;
  __int16 *v53;
  uint32x2_t v54;
  int32x2_t v55;
  int8x8_t v56;
  int8x8_t v57;
  int8x8_t v58;
  uint8x8_t v59;
  uint32x2_t v60;
  int32x2_t v61;
  int8x8_t v62;
  int8x16_t v63;
  float32x2_t v64;
  int v65;
  uint64_t **v66;
  int v67;
  int v68;
  int v69;

  if (a2)
  {
    v4 = a2;
    v5 = (uint32x2_t *)*result;
    v6 = **result;
    v7 = (*result)[2];
    v8 = *((_DWORD *)*result + 8);
    v9 = *((unsigned int *)*result + 9);
    v10 = *((float *)result[3] + 3);
    v11 = *((float *)result[2] + 3);
    v13 = *((_DWORD *)result + 15);
    v12 = *((_DWORD *)result + 16);
    v15 = *((_DWORD *)result + 13);
    v14 = *((unsigned int *)result + 14);
    v16 = v8 - 0x8000;
    v17 = (v9 - 0x8000);
    v18 = *((unsigned __int8 *)result + 48) - 1;
    v64 = (float32x2_t)vdup_n_s32(0x37800000u);
    v19 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v20 = (float32x2_t)vdup_n_s32(0x47800000u);
    v68 = v8;
    v69 = v12;
    v67 = v8 - 0x8000;
    v65 = v18;
    v66 = result;
    do
    {
      v21.f32[0] = (float)(1.0 / v11) * (float)v15;
      v21.f32[1] = (float)(1.0 / v11) * (float)v13;
      v22 = vcvt_s32_f32(v21);
      switch(v18)
      {
        case 0:
          v23 = vmul_f32((float32x2_t)v5[5], vcvt_f32_s32(v22));
          v24 = vmul_f32(v23, v23);
          v25 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 1), v24);
          v24.f32[0] = fmaxf(vaddv_f32(v24), 0.00001);
          v24.i32[0] = vmul_f32(v25, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v24, 0))).u32[0];
          v21 = vcvt_f32_u32(v5[3]);
          v24.i32[1] = 0.5;
          v26 = vmul_f32(v24, v21);
          goto LABEL_8;
        case 1:
          v27 = v5;
          v28 = v9;
          v29 = v14;
          v30 = v17;
          v31 = atan2f(*(float *)&v5[5].i32[1] * (float)v22.i32[1], *(float *)v5[5].i32 * (float)v22.i32[0]);
          v17 = v30;
          v16 = v67;
          v8 = v68;
          v14 = v29;
          v18 = v65;
          result = v66;
          v12 = v69;
          v9 = v28;
          v5 = v27;
          v21 = vcvt_f32_u32(v27[3]);
          v32.i32[1] = 1056964608;
          v32.f32[0] = (float)(v31 * -10430.0) + 32768.0;
          v26 = vmul_f32(v32, v21);
          goto LABEL_8;
        case 2:
          v33 = vmul_f32(vcvt_f32_s32(v22), vmul_f32(v64, (float32x2_t)v5[5]));
          v21 = *(float32x2_t *)((char *)result + 84);
          v26 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)result + 92), v21, vminnm_f32(vsub_f32(v33, vrndm_f32(v33)), v19)), vmul_f32(v20, vcvt_f32_u32(v5[3])));
          goto LABEL_8;
        case 4:
          v34 = vcvt_f32_s32(v22);
          v35 = vcvt_f32_s32((int32x2_t)v5[4]);
          v21 = vmul_f32(*(float32x2_t *)((char *)result + 84), v35);
          v36 = vmul_f32(*(float32x2_t *)((char *)result + 92), v35);
          v37 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v34, v36), (int8x8_t)v36, (int8x8_t)v34);
          v26 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v21, v37), (int8x8_t)v21, (int8x8_t)v37);
LABEL_8:
          v22 = vcvt_s32_f32(v26);
          break;
        default:
          break;
      }
      v38 = v22.i32[0];
      if (v22.i32[0] >= v16)
        v39 = v16;
      else
        v39 = v22.i32[0];
      if (v39 <= -32768)
        v39 = -32768;
      v40 = v39 + 0x8000;
      if (v22.i32[0] <= 0x8000)
        v38 = 0x8000;
      v41 = v38 - 0x8000;
      v42 = v22.i32[1];
      if (v41 >= v8)
        v41 = v8;
      if (v22.i32[1] >= (int)v17)
        v43 = v17;
      else
        v43 = v22.i32[1];
      if (v43 <= -32768)
        v43 = -32768;
      v44 = v43 + 0x8000;
      if (v22.i32[1] <= 0x8000)
        v42 = 0x8000;
      v45 = v42 - 0x8000;
      if (v45 >= (int)v9)
        v45 = v9;
      v46 = v6 + v7 * ((uint64_t)v45 >> 16);
      v47 = v6 + v7 * HIWORD(v44);
      v48 = ((uint64_t)v41 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v49 = (__int16 *)(v46 + v48);
      v50 = (__int16 *)(v47 + v48);
      v51 = (v40 >> 14) & 0x3FFFC;
      v52 = (__int16 *)(v46 + v51);
      v53 = (__int16 *)(v47 + v51);
      v22.i16[0] = v49[1];
      v22.i16[2] = *v52;
      v54 = vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v22, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v21.i16[0] = *v49;
      v21.i16[2] = v52[1];
      v55 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v21, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v56 = vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v55, (uint32x2_t)0x1800000010), (int8x8_t)vshl_u32(v54, (uint32x2_t)0x1000000018));
      v55.i32[1] = v54.i32[1];
      v57 = (int8x8_t)vshl_n_s32(v55, 8uLL);
      v58 = vorr_s8(v56, (int8x8_t)v55);
      v59 = (uint8x8_t)vorr_s8(v58, v57);
      v58.i16[0] = v50[1];
      v58.i16[2] = *v53;
      v56.i16[0] = *v50;
      v60 = vshr_n_u32((uint32x2_t)vand_s8(v58, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v56.i16[2] = v53[1];
      v61 = (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8(v56, (int8x8_t)0xFFFF0000FFFFLL), 8uLL);
      v62 = vorr_s8((int8x8_t)vshl_u32((uint32x2_t)v61, (uint32x2_t)0x1800000010), (int8x8_t)vshl_u32(v60, (uint32x2_t)0x1000000018));
      v61.i32[1] = v60.i32[1];
      v63 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8(v62, (int8x8_t)v61), (int8x8_t)vshl_n_s32(v61, 8uLL)), v59), vdupq_n_s16((v45 >> 1) & 0x7F80)), v59);
      *(int16x4_t *)v63.i8 = vadd_s16(*(int16x4_t *)v63.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v63, v63, 8uLL), *(int16x4_t *)v63.i8), vdup_n_s16((v41 >> 1) & 0x7F80)));
      v11 = v11 + v10;
      v15 += v14;
      v13 += v12;
      *a3++ = vuzp1_s8(*(int8x8_t *)v63.i8, *(int8x8_t *)v63.i8).u32[0];
      --v4;
    }
    while (v4);
  }
  return result;
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,false,false,false,false>(uint64_t a1, int a2, __int32 *a3)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  float32x2_t v13;
  unsigned __int16 *v14;
  float v15;
  float32x2_t v16;
  uint32x2_t v17;
  uint32x2_t v18;
  float v19;

  if (a2)
  {
    v4 = a2;
    v6 = *(_DWORD *)(a1 + 52);
    v5 = *(_DWORD *)(a1 + 56);
    v7 = **(_QWORD **)a1 + *(_QWORD *)(*(_QWORD *)a1 + 16) * *(__int16 *)(a1 + 62);
    __asm { FMOV            V8.2S, #1.0 }
    v13 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v4;
      v14 = (unsigned __int16 *)(v7 + (((uint64_t)v6 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v19 = CA::HalfFloat::to_float((CA::HalfFloat *)*v14);
      v15 = CA::HalfFloat::to_float((CA::HalfFloat *)v14[1]);
      v16 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v15), LODWORD(v19)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v15), LODWORD(v19)));
      v17 = vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v16), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v13, v16)));
      v18 = vshl_u32(v17, (uint32x2_t)0x1800000010);
      v6 += v5;
      *a3++ = v18.i32[0] | (v17.i32[0] << 8) | v17.i32[0] | v18.i32[1];
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,true,false,false,false>(_DWORD *a1, int a2, __int32 *a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  float32x2_t v16;
  unsigned __int16 *v17;
  float v18;
  float32x2_t v19;
  uint32x2_t v20;
  uint32x2_t v21;
  float v22;

  if (a2)
  {
    v4 = a2;
    v5 = **(_QWORD **)a1;
    v6 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v8 = a1[15];
    v7 = a1[16];
    v10 = a1[13];
    v9 = a1[14];
    __asm { FMOV            V8.2S, #1.0 }
    v16 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v4;
      v17 = (unsigned __int16 *)(v5 + v6 * ((uint64_t)v8 >> 16) + (((uint64_t)v10 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v22 = CA::HalfFloat::to_float((CA::HalfFloat *)*v17);
      v18 = CA::HalfFloat::to_float((CA::HalfFloat *)v17[1]);
      v19 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v18), LODWORD(v22)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v18), LODWORD(v22)));
      v20 = vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v19), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v16, v19)));
      v21 = vshl_u32(v20, (uint32x2_t)0x1800000010);
      v10 += v9;
      *a3++ = v21.i32[0] | (v20.i32[0] << 8) | v20.i32[0] | v21.i32[1];
      v8 += v7;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,false,true,false,false>(_DWORD *a1, int a2, __int32 *a3)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  float32x2_t v15;
  int v16;
  unsigned __int16 *v17;
  float v18;
  float32x2_t v19;
  uint32x2_t v20;
  uint32x2_t v21;
  float v22;

  if (a2)
  {
    v4 = a2;
    v5 = a1[14];
    v6 = a1[13];
    v7 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v8 = a1[15] & ~((int)a1[15] >> 31);
    if (v8 >= *(_DWORD *)(*(_QWORD *)a1 + 36))
      v8 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v9 = **(_QWORD **)a1 + *(_QWORD *)(*(_QWORD *)a1 + 16) * ((uint64_t)v8 >> 16);
    __asm { FMOV            V8.2S, #1.0 }
    v15 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v4;
      v16 = v6 & ~(v6 >> 31);
      if (v16 >= v7)
        v16 = v7;
      v17 = (unsigned __int16 *)(v9 + (((uint64_t)v16 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v22 = CA::HalfFloat::to_float((CA::HalfFloat *)*v17);
      v18 = CA::HalfFloat::to_float((CA::HalfFloat *)v17[1]);
      v19 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v18), LODWORD(v22)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v18), LODWORD(v22)));
      v20 = vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v19), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v15, v19)));
      v21 = vshl_u32(v20, (uint32x2_t)0x1800000010);
      v6 += v5;
      *a3++ = v21.i32[0] | (v20.i32[0] << 8) | v20.i32[0] | v21.i32[1];
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,true,true,false,false>(int *a1, int a2, __int32 *a3)
{
  int v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  float32x2_t v17;
  int v18;
  int v19;
  unsigned __int16 *v20;
  float v21;
  float32x2_t v22;
  uint32x2_t v23;
  uint32x2_t v24;
  uint64_t v25;
  float v26;

  if (a2)
  {
    v4 = a2;
    v25 = **(_QWORD **)a1;
    v5 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v6 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v7 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v9 = a1[15];
    v8 = a1[16];
    v11 = a1[13];
    v10 = a1[14];
    __asm { FMOV            V8.2S, #1.0 }
    v17 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v4;
      v18 = v11 & ~(v11 >> 31);
      if (v18 >= v6)
        v18 = v6;
      v19 = v9 & ~(v9 >> 31);
      if (v19 >= v7)
        v19 = v7;
      v20 = (unsigned __int16 *)(v25 + v5 * ((uint64_t)v19 >> 16) + (((uint64_t)v18 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v26 = CA::HalfFloat::to_float((CA::HalfFloat *)*v20);
      v21 = CA::HalfFloat::to_float((CA::HalfFloat *)v20[1]);
      v22 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v21), LODWORD(v26)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v21), LODWORD(v26)));
      v23 = vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v22), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v17, v22)));
      v24 = vshl_u32(v23, (uint32x2_t)0x1800000010);
      v11 += v10;
      *a3++ = v24.i32[0] | (v23.i32[0] << 8) | v23.i32[0] | v24.i32[1];
      v9 += v8;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,true,true,true,false>(uint64_t **a1, int a2, __int32 *a3)
{
  int v4;
  float *v6;
  __int32 v7;
  int v8;
  float v9;
  float v10;
  int v11;
  int v12;
  int v13;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  __int32 v36;
  int v37;
  unsigned __int16 *v38;
  float v39;
  float32x2_t v40;
  uint32x2_t v41;
  uint32x2_t v42;
  float32x2_t v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  float v48;

  if (a2)
  {
    v4 = a2;
    v6 = (float *)*a1;
    v46 = (*a1)[2];
    v47 = **a1;
    v7 = *((_DWORD *)*a1 + 8);
    v8 = *((_DWORD *)*a1 + 9);
    v9 = *((float *)a1[3] + 3);
    v10 = *((float *)a1[2] + 3);
    v11 = *((_DWORD *)a1 + 15);
    v12 = *((_DWORD *)a1 + 13);
    v44 = *((_DWORD *)a1 + 14);
    v45 = *((_DWORD *)a1 + 16);
    v13 = *((unsigned __int8 *)a1 + 48) - 1;
    __asm { FMOV            V11.2S, #1.0 }
    v19 = (float32x2_t)vdup_n_s32(0x437F0000u);
    v43 = (float32x2_t)vdup_n_s32(0x37800000u);
    v20 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
    v21 = (float32x2_t)vdup_n_s32(0x47800000u);
    do
    {
      v22.f32[0] = (float)(1.0 / v10) * (float)v12;
      v22.f32[1] = (float)(1.0 / v10) * (float)v11;
      v23 = vcvt_s32_f32(v22);
      switch(v13)
      {
        case 0:
          v24 = vmul_f32(*(float32x2_t *)(v6 + 10), vcvt_f32_s32(v23));
          v25 = vmul_f32(v24, v24);
          v26 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 1), v25);
          v25.f32[0] = fmaxf(vaddv_f32(v25), 0.00001);
          v25.i32[0] = vmul_f32(v26, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v25, 0))).u32[0];
          v25.i32[1] = 0.5;
          v27 = vmul_f32(v25, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 1:
          v28 = atan2f(v6[11] * (float)v23.i32[1], v6[10] * (float)v23.i32[0]);
          v29.i32[1] = 1056964608;
          v29.f32[0] = (float)(v28 * -10430.0) + 32768.0;
          v27 = vmul_f32(v29, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6)));
          goto LABEL_8;
        case 2:
          v30 = vmul_f32(vcvt_f32_s32(v23), vmul_f32(v43, *(float32x2_t *)(v6 + 10)));
          v27 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v30, vrndm_f32(v30)), v20)), vmul_f32(v21, vcvt_f32_u32(*(uint32x2_t *)(v6 + 6))));
          goto LABEL_8;
        case 4:
          v31 = vcvt_f32_s32(v23);
          v32 = vcvt_f32_s32(*(int32x2_t *)(v6 + 8));
          v33 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v32);
          v34 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v32);
          v35 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v31, v34), (int8x8_t)v34, (int8x8_t)v31);
          v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v33, v35), (int8x8_t)v33, (int8x8_t)v35);
LABEL_8:
          v23 = vcvt_s32_f32(v27);
          break;
        default:
          break;
      }
      --v4;
      v36 = v23.i32[0] & ~(v23.i32[0] >> 31);
      if (v36 >= v7)
        v36 = v7;
      v37 = v23.i32[1] & ~(v23.i32[1] >> 31);
      if (v37 >= v8)
        v37 = v8;
      v38 = (unsigned __int16 *)(v47 + v46 * ((uint64_t)v37 >> 16) + (((uint64_t)v36 >> 14) & 0xFFFFFFFFFFFFFFFCLL));
      v48 = CA::HalfFloat::to_float((CA::HalfFloat *)*v38);
      v39 = CA::HalfFloat::to_float((CA::HalfFloat *)v38[1]);
      v40 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v39), LODWORD(v48)), _D11), (int8x8_t)_D11, (int8x8_t)__PAIR64__(LODWORD(v39), LODWORD(v48)));
      v41 = vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v40), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v40)));
      v42 = vshl_u32(v41, (uint32x2_t)0x1800000010);
      v10 = v10 + v9;
      v12 += v44;
      v11 += v45;
      *a3++ = v42.i32[0] | (v41.i32[0] << 8) | v41.i32[0] | v42.i32[1];
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,false,false,false,true>(_DWORD *a1, int a2, _DWORD *a3, int16x4_t a4)
{
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  float32x2_t v19;
  unint64_t v20;
  uint64_t v21;
  unsigned __int16 *v22;
  unint64_t v23;
  unsigned __int16 *v24;
  unsigned __int16 *v25;
  float v26;
  float32x2_t v27;
  int32x2_t v28;
  int32x2_t v29;
  float v30;
  float32x2_t v31;
  int32x2_t v32;
  int32x2_t v33;
  int32x2_t v34;
  uint8x8_t v35;
  float v36;
  float32x2_t v37;
  int32x2_t v38;
  int32x2_t v39;
  float v40;
  float32x2_t v41;
  int32x2_t v42;
  int32x2_t v43;
  int32x2_t v44;
  int8x16_t v45;
  int16x4_t v46;
  float v47;
  float v48;
  float v49;
  float v50;

  if (a2)
  {
    v5 = a2;
    v7 = a1[14];
    v6 = a1[15];
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v9 = **(_QWORD **)a1;
    v10 = v6 + 0x8000;
    v6 -= 0x8000;
    v11 = v9 + v8 * ((uint64_t)(int)v6 >> 16);
    v12 = v9 + v8 * ((uint64_t)(int)v10 >> 16);
    a4.i32[0] = (v6 >> 1) & 0x7F80;
    v46 = a4;
    v13 = a1[13] - 0x8000;
    __asm { FMOV            V8.2S, #1.0 }
    v19 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v5;
      v20 = ((uint64_t)v13 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v21 = v11 + v20;
      v22 = (unsigned __int16 *)(v12 + v20);
      v23 = ((uint64_t)(v13 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v24 = (unsigned __int16 *)(v11 + v23);
      v25 = (unsigned __int16 *)(v12 + v23);
      v47 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v11 + v20));
      v26 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v21 + 2));
      v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v26), LODWORD(v47)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v26), LODWORD(v47)));
      v28 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v27), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v27)));
      v29 = (int32x2_t)vshl_u32((uint32x2_t)v28, (uint32x2_t)0x1800000010);
      v48 = CA::HalfFloat::to_float((CA::HalfFloat *)*v24);
      v30 = CA::HalfFloat::to_float((CA::HalfFloat *)v24[1]);
      v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v30), LODWORD(v48)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v30), LODWORD(v48)));
      v32 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v31), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v31)));
      v33 = (int32x2_t)vshl_u32((uint32x2_t)v32, (uint32x2_t)0x1800000010);
      v34 = vzip1_s32(v28, v32);
      v35 = (uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v29, v33), (int8x8_t)vshl_n_s32(v34, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v29, v33), (int8x8_t)v34));
      v49 = CA::HalfFloat::to_float((CA::HalfFloat *)*v22);
      v36 = CA::HalfFloat::to_float((CA::HalfFloat *)v22[1]);
      v37 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v36), LODWORD(v49)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v36), LODWORD(v49)));
      v38 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v37), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v37)));
      v39 = (int32x2_t)vshl_u32((uint32x2_t)v38, (uint32x2_t)0x1800000010);
      v50 = CA::HalfFloat::to_float((CA::HalfFloat *)*v25);
      v40 = CA::HalfFloat::to_float((CA::HalfFloat *)v25[1]);
      v41 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v40), LODWORD(v50)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v40), LODWORD(v50)));
      v42 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v41), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v19, v41)));
      v43 = (int32x2_t)vshl_u32((uint32x2_t)v42, (uint32x2_t)0x1800000010);
      v44 = vzip1_s32(v38, v42);
      v45 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v39, v43), (int8x8_t)vshl_n_s32(v44, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v39, v43), (int8x8_t)v44)), v35), v46, 0), v35);
      *(int16x4_t *)v45.i8 = vadd_s16(*(int16x4_t *)v45.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL), *(int16x4_t *)v45.i8), vdup_n_s16((v13 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v45.i8, *(int8x8_t *)v45.i8).u32[0];
      v13 += v7;
    }
    while (v5);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,true,false,false,true>(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  float32x2_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned __int16 *v19;
  unint64_t v20;
  unsigned __int16 *v21;
  unsigned __int16 *v22;
  float v23;
  float32x2_t v24;
  int32x2_t v25;
  int32x2_t v26;
  float v27;
  float32x2_t v28;
  int32x2_t v29;
  int32x2_t v30;
  int32x2_t v31;
  uint8x8_t v32;
  float v33;
  float32x2_t v34;
  int32x2_t v35;
  int32x2_t v36;
  float v37;
  float32x2_t v38;
  int32x2_t v39;
  int32x2_t v40;
  int32x2_t v41;
  int8x16_t v42;
  int v43;
  int v44;
  float v45;
  float v46;
  float v47;
  float v48;

  if (a2)
  {
    v4 = a2;
    v5 = **(_QWORD **)a1;
    v6 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v43 = a1[14];
    v44 = a1[16];
    v7 = a1[13] - 0x8000;
    v8 = a1[15] - 0x8000;
    __asm { FMOV            V8.2S, #1.0 }
    v14 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v4;
      v15 = v5 + v6 * ((uint64_t)v8 >> 16);
      v16 = v5 + v6 * ((uint64_t)(v8 + 0x10000) >> 16);
      v17 = ((uint64_t)v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v18 = v15 + v17;
      v19 = (unsigned __int16 *)(v16 + v17);
      v20 = ((uint64_t)(v7 + 0x10000) >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v21 = (unsigned __int16 *)(v15 + v20);
      v22 = (unsigned __int16 *)(v16 + v20);
      v45 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v15 + v17));
      v23 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v18 + 2));
      v24 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v23), LODWORD(v45)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v23), LODWORD(v45)));
      v25 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v24), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v24)));
      v26 = (int32x2_t)vshl_u32((uint32x2_t)v25, (uint32x2_t)0x1800000010);
      v46 = CA::HalfFloat::to_float((CA::HalfFloat *)*v21);
      v27 = CA::HalfFloat::to_float((CA::HalfFloat *)v21[1]);
      v28 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v27), LODWORD(v46)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v27), LODWORD(v46)));
      v29 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v28), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v28)));
      v30 = (int32x2_t)vshl_u32((uint32x2_t)v29, (uint32x2_t)0x1800000010);
      v31 = vzip1_s32(v25, v29);
      v32 = (uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v26, v30), (int8x8_t)vshl_n_s32(v31, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v26, v30), (int8x8_t)v31));
      v47 = CA::HalfFloat::to_float((CA::HalfFloat *)*v19);
      v33 = CA::HalfFloat::to_float((CA::HalfFloat *)v19[1]);
      v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v33), LODWORD(v47)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v33), LODWORD(v47)));
      v35 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v34), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v34)));
      v36 = (int32x2_t)vshl_u32((uint32x2_t)v35, (uint32x2_t)0x1800000010);
      v48 = CA::HalfFloat::to_float((CA::HalfFloat *)*v22);
      v37 = CA::HalfFloat::to_float((CA::HalfFloat *)v22[1]);
      v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v37), LODWORD(v48)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v37), LODWORD(v48)));
      v39 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v38), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v14, v38)));
      v40 = (int32x2_t)vshl_u32((uint32x2_t)v39, (uint32x2_t)0x1800000010);
      v41 = vzip1_s32(v35, v39);
      v42 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v36, v40), (int8x8_t)vshl_n_s32(v41, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v36, v40), (int8x8_t)v41)), v32), vdupq_n_s16((v8 >> 1) & 0x7F80)), v32);
      *(int16x4_t *)v42.i8 = vadd_s16(*(int16x4_t *)v42.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v42, v42, 8uLL), *(int16x4_t *)v42.i8), vdup_n_s16((v7 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v42.i8, *(int8x8_t *)v42.i8).u32[0];
      v7 += v43;
      v8 += v44;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,false,true,false,true>(_DWORD *a1, int a2, _DWORD *a3, int16x4_t a4)
{
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  float32x2_t v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  int v26;
  unint64_t v27;
  uint64_t v28;
  unsigned __int16 *v29;
  uint64_t v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  float v33;
  float32x2_t v34;
  int32x2_t v35;
  int32x2_t v36;
  float v37;
  float32x2_t v38;
  int32x2_t v39;
  int32x2_t v40;
  int32x2_t v41;
  uint8x8_t v42;
  float v43;
  float32x2_t v44;
  int32x2_t v45;
  int32x2_t v46;
  float v47;
  float32x2_t v48;
  int32x2_t v49;
  int32x2_t v50;
  int32x2_t v51;
  int8x16_t v52;
  int16x4_t v53;
  int v54;
  int v55;
  float v56;
  float v57;
  float v58;
  float v59;

  if (a2)
  {
    v5 = a2;
    v6 = a1[15];
    v55 = a1[14];
    v7 = a1[13];
    v8 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v9 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v10 = **(_QWORD **)a1;
    v54 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    v11 = v8 - 0x8000;
    if (v6 < v8 - 0x8000)
      v11 = a1[15];
    if (v11 <= -32768)
      v11 = -32768;
    v12 = v11 + 0x8000;
    if (v6 <= 0x8000)
      v6 = 0x8000;
    v13 = v6 - 0x8000;
    if (v13 >= v8)
      v13 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v14 = v10 + v9 * ((uint64_t)v13 >> 16);
    v15 = v10 + v9 * HIWORD(v12);
    a4.i32[0] = (v13 >> 1) & 0x7F80;
    v53 = a4;
    __asm { FMOV            V8.2S, #1.0 }
    v21 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v5;
      v22 = v54 - 0x8000;
      if (v7 < v54 - 0x8000)
        v22 = v7;
      if (v22 <= -32768)
        v22 = -32768;
      v23 = v22 + 0x8000;
      if (v7 <= 0x8000)
        v24 = 0x8000;
      else
        v24 = v7;
      v25 = v24 - 0x8000;
      if (v25 >= v54)
        v26 = v54;
      else
        v26 = v25;
      v27 = ((uint64_t)v26 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v28 = v14 + v27;
      v29 = (unsigned __int16 *)(v15 + v27);
      v30 = (v23 >> 14) & 0x3FFFC;
      v31 = (unsigned __int16 *)(v14 + v30);
      v32 = (unsigned __int16 *)(v15 + v30);
      v56 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v14 + v27));
      v33 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v28 + 2));
      v34 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v33), LODWORD(v56)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v33), LODWORD(v56)));
      v35 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v34), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v21, v34)));
      v36 = (int32x2_t)vshl_u32((uint32x2_t)v35, (uint32x2_t)0x1800000010);
      v57 = CA::HalfFloat::to_float((CA::HalfFloat *)*v31);
      v37 = CA::HalfFloat::to_float((CA::HalfFloat *)v31[1]);
      v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v37), LODWORD(v57)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v37), LODWORD(v57)));
      v39 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v38), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v21, v38)));
      v40 = (int32x2_t)vshl_u32((uint32x2_t)v39, (uint32x2_t)0x1800000010);
      v41 = vzip1_s32(v35, v39);
      v42 = (uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v36, v40), (int8x8_t)vshl_n_s32(v41, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v36, v40), (int8x8_t)v41));
      v58 = CA::HalfFloat::to_float((CA::HalfFloat *)*v29);
      v43 = CA::HalfFloat::to_float((CA::HalfFloat *)v29[1]);
      v44 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v43), LODWORD(v58)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v43), LODWORD(v58)));
      v45 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v44), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v21, v44)));
      v46 = (int32x2_t)vshl_u32((uint32x2_t)v45, (uint32x2_t)0x1800000010);
      v59 = CA::HalfFloat::to_float((CA::HalfFloat *)*v32);
      v47 = CA::HalfFloat::to_float((CA::HalfFloat *)v32[1]);
      v48 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v47), LODWORD(v59)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v47), LODWORD(v59)));
      v49 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v48), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v21, v48)));
      v50 = (int32x2_t)vshl_u32((uint32x2_t)v49, (uint32x2_t)0x1800000010);
      v51 = vzip1_s32(v45, v49);
      v52 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_lane_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v46, v50), (int8x8_t)vshl_n_s32(v51, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v46, v50), (int8x8_t)v51)), v42), v53, 0), v42);
      *(int16x4_t *)v52.i8 = vadd_s16(*(int16x4_t *)v52.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL), *(int16x4_t *)v52.i8), vdup_n_s16((v26 >> 1) & 0x7F80)));
      *a3++ = vuzp1_s8(*(int8x8_t *)v52.i8, *(int8x8_t *)v52.i8).u32[0];
      v7 += v55;
    }
    while (v5);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,true,true,false,true>(int *a1, int a2, _DWORD *a3)
{
  int v4;
  int v5;
  int v6;
  float32x2_t v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unsigned __int16 *v27;
  uint64_t v28;
  unsigned __int16 *v29;
  unsigned __int16 *v30;
  float v31;
  float32x2_t v32;
  int32x2_t v33;
  int32x2_t v34;
  float v35;
  float32x2_t v36;
  int32x2_t v37;
  int32x2_t v38;
  int32x2_t v39;
  uint8x8_t v40;
  float v41;
  float32x2_t v42;
  int32x2_t v43;
  int32x2_t v44;
  float v45;
  float32x2_t v46;
  int32x2_t v47;
  int32x2_t v48;
  int32x2_t v49;
  int8x16_t v50;
  int v51;
  int v52;
  int v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  float v57;
  float v58;
  float v59;
  float v60;

  if (a2)
  {
    v4 = a2;
    v55 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    v56 = **(_QWORD **)a1;
    v5 = a1[15];
    v6 = a1[13];
    v51 = a1[14];
    v52 = a1[16];
    v53 = *(_DWORD *)(*(_QWORD *)a1 + 36);
    v54 = *(_DWORD *)(*(_QWORD *)a1 + 32);
    __asm { FMOV            V8.2S, #1.0 }
    v12 = (float32x2_t)vdup_n_s32(0x437F0000u);
    do
    {
      --v4;
      v13 = v54 - 0x8000;
      if (v6 < v54 - 0x8000)
        v13 = v6;
      if (v13 <= -32768)
        v13 = -32768;
      v14 = v13 + 0x8000;
      if (v6 <= 0x8000)
        v15 = 0x8000;
      else
        v15 = v6;
      v16 = v15 - 0x8000;
      if (v16 >= v54)
        v17 = v54;
      else
        v17 = v16;
      v18 = v53 - 0x8000;
      if (v5 < v53 - 0x8000)
        v18 = v5;
      if (v18 <= -32768)
        v18 = -32768;
      v19 = v18 + 0x8000;
      if (v5 <= 0x8000)
        v20 = 0x8000;
      else
        v20 = v5;
      v21 = v20 - 0x8000;
      if (v21 >= v53)
        v22 = v53;
      else
        v22 = v21;
      v23 = v56 + v55 * ((uint64_t)v22 >> 16);
      v24 = v56 + v55 * HIWORD(v19);
      v25 = ((uint64_t)v17 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v26 = v23 + v25;
      v27 = (unsigned __int16 *)(v24 + v25);
      v28 = (v14 >> 14) & 0x3FFFC;
      v29 = (unsigned __int16 *)(v23 + v28);
      v30 = (unsigned __int16 *)(v24 + v28);
      v57 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v23 + v25));
      v31 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v26 + 2));
      v32 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v31), LODWORD(v57)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v31), LODWORD(v57)));
      v33 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v32), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v12, v32)));
      v34 = (int32x2_t)vshl_u32((uint32x2_t)v33, (uint32x2_t)0x1800000010);
      v58 = CA::HalfFloat::to_float((CA::HalfFloat *)*v29);
      v35 = CA::HalfFloat::to_float((CA::HalfFloat *)v29[1]);
      v36 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v35), LODWORD(v58)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v35), LODWORD(v58)));
      v37 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v36), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v12, v36)));
      v38 = (int32x2_t)vshl_u32((uint32x2_t)v37, (uint32x2_t)0x1800000010);
      v39 = vzip1_s32(v33, v37);
      v40 = (uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v34, v38), (int8x8_t)vshl_n_s32(v39, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v34, v38), (int8x8_t)v39));
      v59 = CA::HalfFloat::to_float((CA::HalfFloat *)*v27);
      v41 = CA::HalfFloat::to_float((CA::HalfFloat *)v27[1]);
      v42 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v41), LODWORD(v59)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v41), LODWORD(v59)));
      v43 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v42), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v12, v42)));
      v44 = (int32x2_t)vshl_u32((uint32x2_t)v43, (uint32x2_t)0x1800000010);
      v60 = CA::HalfFloat::to_float((CA::HalfFloat *)*v30);
      v45 = CA::HalfFloat::to_float((CA::HalfFloat *)v30[1]);
      v46 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v45), LODWORD(v60)), _D8), (int8x8_t)_D8, (int8x8_t)__PAIR64__(LODWORD(v45), LODWORD(v60)));
      v47 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v46), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v12, v46)));
      v48 = (int32x2_t)vshl_u32((uint32x2_t)v47, (uint32x2_t)0x1800000010);
      v49 = vzip1_s32(v43, v47);
      v50 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v44, v48), (int8x8_t)vshl_n_s32(v49, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v44, v48), (int8x8_t)v49)), v40), vdupq_n_s16((v22 >> 1) & 0x7F80)), v40);
      *(int16x4_t *)v50.i8 = vadd_s16(*(int16x4_t *)v50.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL), *(int16x4_t *)v50.i8), vdup_n_s16((v17 >> 1) & 0x7F80)));
      v6 += v51;
      *a3++ = vuzp1_s8(*(int8x8_t *)v50.i8, *(int8x8_t *)v50.i8).u32[0];
      v5 += v52;
    }
    while (v4);
  }
}

void CA::OGL::SW::image_sampler<CA::OGL::SW::Format::LAh,unsigned int,true,true,true,true>(uint64_t **a1, int a2, _DWORD *a3)
{
  int v4;
  float v5;
  float v6;
  int v7;
  int v8;
  int v9;
  float32x2_t v15;
  float32x2_t v16;
  int32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  int v30;
  int v31;
  unsigned int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  unsigned int v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unsigned __int16 *v44;
  uint64_t v45;
  unsigned __int16 *v46;
  unsigned __int16 *v47;
  float v48;
  float32x2_t v49;
  int32x2_t v50;
  int32x2_t v51;
  float v52;
  float32x2_t v53;
  int32x2_t v54;
  int32x2_t v55;
  int32x2_t v56;
  uint8x8_t v57;
  float v58;
  float32x2_t v59;
  int32x2_t v60;
  int32x2_t v61;
  float v62;
  float32x2_t v63;
  int32x2_t v64;
  int32x2_t v65;
  int32x2_t v66;
  int8x16_t v67;
  float *v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  float v77;
  float v78;
  float v79;
  float v80;

  if (a2)
  {
    v4 = a2;
    v75 = (*a1)[2];
    v76 = **a1;
    v69 = (float *)*a1;
    v5 = *((float *)a1[3] + 3);
    v6 = *((float *)a1[2] + 3);
    v7 = *((_DWORD *)a1 + 15);
    v72 = *((_DWORD *)a1 + 16);
    v73 = *((_DWORD *)*a1 + 9);
    v8 = *((_DWORD *)a1 + 13);
    v71 = *((_DWORD *)a1 + 14);
    v74 = *((_DWORD *)*a1 + 8);
    v9 = *((unsigned __int8 *)a1 + 48) - 1;
    __asm { FMOV            V11.2S, #1.0 }
    v15 = (float32x2_t)vdup_n_s32(0x437F0000u);
    v70 = v9;
    do
    {
      v16.f32[0] = (float)(1.0 / v6) * (float)v8;
      v16.f32[1] = (float)(1.0 / v6) * (float)v7;
      v17 = vcvt_s32_f32(v16);
      switch(v9)
      {
        case 0:
          v18 = vmul_f32(*(float32x2_t *)(v69 + 10), vcvt_f32_s32(v17));
          v19 = vmul_f32(v18, v18);
          v20 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v19, 1), v19);
          v19.f32[0] = fmaxf(vaddv_f32(v19), 0.00001);
          v19.i32[0] = vmul_f32(v20, vrsqrte_f32((float32x2_t)vdup_lane_s32((int32x2_t)v19, 0))).u32[0];
          v19.i32[1] = 0.5;
          v21 = vmul_f32(v19, vcvt_f32_u32(*(uint32x2_t *)(v69 + 6)));
          goto LABEL_8;
        case 1:
          v22 = atan2f(v69[11] * (float)v17.i32[1], v69[10] * (float)v17.i32[0]);
          v23.i32[1] = 1056964608;
          v23.f32[0] = (float)(v22 * -10430.0) + 32768.0;
          v21 = vmul_f32(v23, vcvt_f32_u32(*(uint32x2_t *)(v69 + 6)));
          goto LABEL_8;
        case 2:
          v24 = vmul_f32(vcvt_f32_s32(v17), vmul_f32((float32x2_t)vdup_n_s32(0x37800000u), *(float32x2_t *)(v69 + 10)));
          v21 = vmul_f32(vmla_f32(*(float32x2_t *)((char *)a1 + 92), *(float32x2_t *)((char *)a1 + 84), vminnm_f32(vsub_f32(v24, vrndm_f32(v24)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu))), vmul_f32((float32x2_t)vdup_n_s32(0x47800000u), vcvt_f32_u32(*(uint32x2_t *)(v69 + 6))));
          goto LABEL_8;
        case 4:
          v25 = vcvt_f32_s32(v17);
          v26 = vcvt_f32_s32(*(int32x2_t *)(v69 + 8));
          v27 = vmul_f32(*(float32x2_t *)((char *)a1 + 84), v26);
          v28 = vmul_f32(*(float32x2_t *)((char *)a1 + 92), v26);
          v29 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v25, v28), (int8x8_t)v28, (int8x8_t)v25);
          v21 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v27, v29), (int8x8_t)v27, (int8x8_t)v29);
LABEL_8:
          v17 = vcvt_s32_f32(v21);
          break;
        default:
          break;
      }
      --v4;
      v30 = v17.i32[0];
      v31 = v74 - 0x8000;
      if (v17.i32[0] < v74 - 0x8000)
        v31 = v17.i32[0];
      if (v31 <= -32768)
        v31 = -32768;
      v32 = v31 + 0x8000;
      if (v17.i32[0] <= 0x8000)
        v30 = 0x8000;
      v33 = v30 - 0x8000;
      v34 = v17.i32[1];
      if (v33 >= v74)
        v35 = v74;
      else
        v35 = v33;
      v36 = v73 - 0x8000;
      if (v17.i32[1] < v73 - 0x8000)
        v36 = v17.i32[1];
      if (v36 <= -32768)
        v36 = -32768;
      v37 = v36 + 0x8000;
      if (v17.i32[1] <= 0x8000)
        v34 = 0x8000;
      v38 = v34 - 0x8000;
      if (v38 >= v73)
        v39 = v73;
      else
        v39 = v38;
      v40 = v76 + v75 * ((uint64_t)v39 >> 16);
      v41 = v76 + v75 * HIWORD(v37);
      v42 = ((uint64_t)v35 >> 14) & 0xFFFFFFFFFFFFFFFCLL;
      v43 = v40 + v42;
      v44 = (unsigned __int16 *)(v41 + v42);
      v45 = (v32 >> 14) & 0x3FFFC;
      v46 = (unsigned __int16 *)(v40 + v45);
      v47 = (unsigned __int16 *)(v41 + v45);
      v77 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v40 + v42));
      v48 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)(v43 + 2));
      v49 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v48), LODWORD(v77)), _D11), (int8x8_t)_D11, (int8x8_t)__PAIR64__(LODWORD(v48), LODWORD(v77)));
      v50 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v49), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v15, v49)));
      v51 = (int32x2_t)vshl_u32((uint32x2_t)v50, (uint32x2_t)0x1800000010);
      v78 = CA::HalfFloat::to_float((CA::HalfFloat *)*v46);
      v52 = CA::HalfFloat::to_float((CA::HalfFloat *)v46[1]);
      v53 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v52), LODWORD(v78)), _D11), (int8x8_t)_D11, (int8x8_t)__PAIR64__(LODWORD(v52), LODWORD(v78)));
      v54 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v53), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v15, v53)));
      v55 = (int32x2_t)vshl_u32((uint32x2_t)v54, (uint32x2_t)0x1800000010);
      v56 = vzip1_s32(v50, v54);
      v57 = (uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v51, v55), (int8x8_t)vshl_n_s32(v56, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v51, v55), (int8x8_t)v56));
      v79 = CA::HalfFloat::to_float((CA::HalfFloat *)*v44);
      v58 = CA::HalfFloat::to_float((CA::HalfFloat *)v44[1]);
      v59 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v58), LODWORD(v79)), _D11), (int8x8_t)_D11, (int8x8_t)__PAIR64__(LODWORD(v58), LODWORD(v79)));
      v60 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v59), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v15, v59)));
      v61 = (int32x2_t)vshl_u32((uint32x2_t)v60, (uint32x2_t)0x1800000010);
      v80 = CA::HalfFloat::to_float((CA::HalfFloat *)*v47);
      v62 = CA::HalfFloat::to_float((CA::HalfFloat *)v47[1]);
      v63 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v62), LODWORD(v80)), _D11), (int8x8_t)_D11, (int8x8_t)__PAIR64__(LODWORD(v62), LODWORD(v80)));
      v64 = (int32x2_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v63), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v15, v63)));
      v65 = (int32x2_t)vshl_u32((uint32x2_t)v64, (uint32x2_t)0x1800000010);
      v66 = vzip1_s32(v60, v64);
      v67 = (int8x16_t)vaddw_u8((uint16x8_t)vqrdmulhq_s16((int16x8_t)vsubl_u8((uint8x8_t)vorr_s8(vorr_s8((int8x8_t)vzip1_s32(v61, v65), (int8x8_t)vshl_n_s32(v66, 8uLL)), vorr_s8((int8x8_t)vzip2_s32(v61, v65), (int8x8_t)v66)), v57), vdupq_n_s16((v39 >> 1) & 0x7F80)), v57);
      *(int16x4_t *)v67.i8 = vadd_s16(*(int16x4_t *)v67.i8, vqrdmulh_s16(vsub_s16((int16x4_t)*(_OWORD *)&vextq_s8(v67, v67, 8uLL), *(int16x4_t *)v67.i8), vdup_n_s16((v35 >> 1) & 0x7F80)));
      v6 = v6 + v5;
      v8 += v71;
      v7 += v72;
      *a3++ = vuzp1_s8(*(int8x8_t *)v67.i8, *(int8x8_t *)v67.i8).u32[0];
      v9 = v70;
    }
    while (v4);
  }
}

int8x8_t CA::OGL::SW::Format::RGBXh::load_1(CA::OGL::SW::Format::RGBXh *this, unsigned int *a2, const unsigned __int8 *a3)
{
  float v5;
  float32x2_t v6;
  float v7;
  unsigned int v8;
  float32x2_t v14;
  int32x2_t v15;
  int8x8_t result;
  float v17;
  float v18;

  v18 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)a2);
  v17 = CA::HalfFloat::to_float((CA::HalfFloat *)*((unsigned __int16 *)a2 + 1));
  v5 = CA::HalfFloat::to_float((CA::HalfFloat *)*((unsigned __int16 *)a2 + 2));
  v6 = (float32x2_t)vdup_n_s32(0x437F0000u);
  if (v5 > 1.0)
    v5 = 1.0;
  if (v5 >= 0.0)
    v7 = (float)(v5 * 255.0) + 0.5;
  else
    v7 = 0.5;
  v8 = v7;
  __asm { FMOV            V0.2S, #1.0 }
  v14 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v17), LODWORD(v18)), _D0), (int8x8_t)_D0, (int8x8_t)__PAIR64__(LODWORD(v17), LODWORD(v18)));
  v15 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v14), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v6, v14))), (uint32x2_t)0x800000010);
  result = vorr_s8((int8x8_t)v15, (int8x8_t)vdup_lane_s32(v15, 1));
  *(_DWORD *)this = result.i32[0] | v8 | 0xFF000000;
  return result;
}

int8x8_t CA::OGL::SW::Format::RGBAh::load_1(CA::OGL::SW::Format::RGBAh *this, unsigned int *a2, const unsigned __int8 *a3)
{
  float v5;
  float32x2_t v11;
  float32x2_t v12;
  int32x2_t v13;
  float32x2_t v14;
  int8x8_t v15;
  float32x2_t v16;
  int8x8_t v17;
  int8x8_t result;
  float v19;
  float v20;
  float v21;

  v20 = CA::HalfFloat::to_float((CA::HalfFloat *)*(unsigned __int16 *)a2);
  v19 = CA::HalfFloat::to_float((CA::HalfFloat *)*((unsigned __int16 *)a2 + 1));
  v21 = CA::HalfFloat::to_float((CA::HalfFloat *)*((unsigned __int16 *)a2 + 2));
  v5 = CA::HalfFloat::to_float((CA::HalfFloat *)*((unsigned __int16 *)a2 + 3));
  __asm { FMOV            V1.2S, #1.0 }
  v11 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(LODWORD(v20), LODWORD(v19)), _D1), (int8x8_t)_D1, (int8x8_t)__PAIR64__(LODWORD(v20), LODWORD(v19)));
  v12 = (float32x2_t)vdup_n_s32(0x437F0000u);
  v13 = (int32x2_t)vshl_u32(vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v11), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v12, v11))), (uint32x2_t)0x1000000008);
  v14 = (float32x2_t)__PAIR64__(LODWORD(v5), LODWORD(v21));
  v15 = vorr_s8((int8x8_t)v13, (int8x8_t)vdup_lane_s32(v13, 1));
  v16 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v14, _D1), (int8x8_t)_D1, (int8x8_t)v14);
  v17 = (int8x8_t)vcvt_u32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v16), (int8x8_t)0x3F0000003F000000, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v12, v16)));
  result = vorr_s8((int8x8_t)vdup_lane_s32((int32x2_t)vshl_u32((uint32x2_t)v17, (uint32x2_t)(v15.u32[0] | 0x1800000000)), 1), vorr_s8(v17, v15));
  *(_DWORD *)this = result.i32[0];
  return result;
}

unsigned int *CA::OGL::SW::Format::YCbYCr8::load_1(unsigned int *this, unint64_t a2, const unsigned __int8 *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;

  v3 = *(unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFDLL) + 1) - 128;
  v4 = *(unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFDLL) + 3) - 128;
  v5 = 38155 * *(unsigned __int8 *)a2 - 610480;
  v6 = (v5 + 52299 * v4) >> 15;
  if (v6 >= 255)
    v6 = 255;
  if (v6 >= 0)
    v7 = (v6 << 16) | 0xFF000000;
  else
    v7 = -16777216;
  v8 = (v5 - 12836 * v3 - 26638 * v4) >> 15;
  if (v8 >= 255)
    v8 = 255;
  if (v8 >= 0)
    v9 = v8 << 8;
  else
    v9 = 0;
  v10 = (v5 + 66101 * v3) >> 15;
  if (v10 >= 255)
    v10 = 255;
  *this = v9 | v10 & ~(v10 >> 31) | v7;
  return this;
}

unsigned int *CA::OGL::SW::Format::CbYCrY8::load_1(unsigned int *this, unint64_t a2, const unsigned __int8 *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;

  v3 = *(unsigned __int8 *)(a2 & 0xFFFFFFFFFFFFFFFDLL) - 128;
  v4 = *(unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFDLL) + 2) - 128;
  v5 = 38155 * *(unsigned __int8 *)(a2 + 1) - 610480;
  v6 = (v5 + 52299 * v4) >> 15;
  if (v6 >= 255)
    v6 = 255;
  if (v6 >= 0)
    v7 = (v6 << 16) | 0xFF000000;
  else
    v7 = -16777216;
  v8 = (v5 - 12836 * v3 - 26638 * v4) >> 15;
  if (v8 >= 255)
    v8 = 255;
  if (v8 >= 0)
    v9 = v8 << 8;
  else
    v9 = 0;
  v10 = (v5 + 66101 * v3) >> 15;
  if (v10 >= 255)
    v10 = 255;
  *this = v9 | v10 & ~(v10 >> 31) | v7;
  return this;
}

_QWORD *CA::Transaction::reset_animators(_QWORD *this)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;

  v1 = this[1];
  if (v1)
  {
    v2 = this;
    do
    {
      if (*(_QWORD *)v1)
        _Block_release(*(const void **)v1);
      v1 = *(_QWORD *)(v1 + 8);
    }
    while (v1);
    this = (_QWORD *)v2[1];
    if (this)
    {
      do
      {
        v3 = (_QWORD *)this[1];
        free(this);
        this = v3;
      }
      while (v3);
    }
    v2[1] = 0;
  }
  return this;
}

void CA::Transaction::release_thread(CA::Transaction *this, void *a2, uint64_t a3)
{
  uint64_t v4;
  _BOOL8 v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  unint64_t StatusReg;
  void *v10;
  int *v11;
  int *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *i;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  __CFRunLoopObserver *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  malloc_zone_t *malloc_zone;
  _QWORD *v31;
  uint64_t v32;
  unint64_t v33;
  NSObject *v34;
  char **v35;
  unint64_t v36;
  NSObject *v37;
  char *v38;
  char *v39;
  int v40;
  uint64_t v41;
  char *v42;
  int v43;
  unsigned int v44;
  int v46;
  NSObject *v47;
  const char *v48;
  void **v49;
  uint64_t v50;
  _QWORD v51[3];
  _QWORD *v52;
  _BYTE buf[12];
  __int16 v54;
  int v55;
  __int16 v56;
  char *v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)this + 13);
  if (!*(_DWORD *)v4)
    goto LABEL_8;
  kdebug_trace();
  if (!CA::Transaction::_debug_transactions)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v8 = x_log_category_api;
      v5 = os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT);
      if (v5)
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_184457000, v8, OS_LOG_TYPE_DEFAULT, "CoreAnimation: warning, deleted thread with uncommitted CATransaction; set CA_DEBUG_TRANSACTIONS=1 in environm"
          "ent to log backtraces, or set CA_ASSERT_MAIN_THREAD_TRANSACTIONS=1 to abort when an implicit transaction isn't"
          " created on a main thread.\n",
          buf,
          2u);
      }
    }
    goto LABEL_7;
  }
LABEL_59:
  x_log_begin();
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v34 = x_log_category_api;
    if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_184457000, v34, OS_LOG_TYPE_DEFAULT, "CoreAnimation: warning, deleted thread with uncommitted CATransaction; created by:\n",
        buf,
        2u);
    }
  }
  v35 = backtrace_symbols(*(void *const **)(v4 + 240), *(unsigned __int16 *)(v4 + 206));
  if (v35)
  {
    if (*(_WORD *)(v4 + 206))
    {
      v36 = 0;
      do
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          v37 = x_log_category_api;
          if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
          {
            v38 = v35[v36];
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v38;
            _os_log_impl(&dword_184457000, v37, OS_LOG_TYPE_DEFAULT, "%s\n", buf, 0xCu);
          }
        }
        ++v36;
      }
      while (v36 < *(unsigned __int16 *)(v4 + 206));
    }
    free(v35);
  }
  v49 = (void **)x_stream_pop_(0);
  v39 = x_stream_get(v49);
  v40 = 0;
  while (2)
  {
    v41 = 0;
    v42 = &v39[v40];
    v43 = -1;
    while (1)
    {
      if (v42[v41] == 10)
      {
        v43 = v41;
        goto LABEL_78;
      }
      if (!v42[v41])
        break;
LABEL_78:
      ++v41;
      v44 = 32512;
      if (v41 == 32512)
        goto LABEL_79;
    }
    v44 = v41;
LABEL_79:
    if (v43 <= -1 || v42[v44] == 0)
      v46 = v44;
    else
      v46 = v43 + 1;
    if (v46 >= 1)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v47 = x_log_category_api;
        if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          if (v40)
            v48 = "continued...\n";
          else
            v48 = "";
          *(_QWORD *)&buf[4] = v48;
          v54 = 1040;
          v55 = v46;
          v56 = 2080;
          v57 = &v39[v40];
          _os_log_impl(&dword_184457000, v47, OS_LOG_TYPE_DEFAULT, "%s%.*s", buf, 0x1Cu);
        }
      }
      v40 += v46;
      continue;
    }
    break;
  }
  x_log_end_free_(v49);
LABEL_7:
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  *(_QWORD *)(StatusReg + 576) = this;
  v10 = (void *)MEMORY[0x186DBE2E4](v5, v6, v7);
  CA::Transaction::commit(this);
  objc_autoreleasePoolPop(v10);
  *(_QWORD *)(StatusReg + 576) = 0;
  kdebug_trace();
LABEL_8:
  v11 = (int *)*((_QWORD *)this + 6);
  if (v11)
  {
    v12 = 0;
    while (2)
    {
      if (*((_QWORD *)v11 + 3))
      {
        if (v12)
        {
          v13 = 0;
          v14 = 1 << *v11;
          do
          {
            for (i = *(_QWORD **)(*((_QWORD *)v11 + 2) + 8 * v13); i; i = (_QWORD *)*i)
              hash_table_modify(v12, i[2], i[3], 0);
            ++v13;
          }
          while (v13 != v14);
          x_hash_table_remove_all(*((_QWORD **)this + 6));
        }
        else
        {
          *((_QWORD *)this + 6) = 0;
          v12 = v11;
        }
        v16 = 0;
        v51[0] = &off_1E159A2D8;
        v52 = v51;
        v17 = 1 << *v12;
        do
        {
          v18 = *(_QWORD **)(*((_QWORD *)v12 + 2) + 8 * v16);
          if (v18)
          {
            while (1)
            {
              v19 = v18[3];
              *(_QWORD *)buf = v18[2];
              v50 = v19;
              if (!v52)
                break;
              (*(void (**)(_QWORD *, _BYTE *, uint64_t *))(*v52 + 48))(v52, buf, &v50);
              v18 = (_QWORD *)*v18;
              if (!v18)
                goto LABEL_22;
            }
            std::__throw_bad_function_call[abi:nn180100]();
            goto LABEL_59;
          }
LABEL_22:
          ++v16;
        }
        while (v16 != v17);
        v20 = v52;
        if (v52 == v51)
        {
          v20 = v51;
          v21 = 4;
LABEL_27:
          (*(void (**)(_QWORD *, void *, uint64_t))(*v20 + 8 * v21))(v20, a2, a3);
        }
        else if (v52)
        {
          v21 = 5;
          goto LABEL_27;
        }
        x_hash_table_remove_all(v12);
        v11 = (int *)*((_QWORD *)this + 6);
        if (v11)
          continue;
LABEL_29:
        x_hash_table_free(v12);
      }
      else
      {
        x_hash_table_free(v11);
        if (v12)
          goto LABEL_29;
      }
      break;
    }
  }
  v22 = (__CFRunLoopObserver *)*((_QWORD *)this + 8);
  if (v22)
  {
    CFRunLoopObserverInvalidate(v22);
    CFRelease(*((CFTypeRef *)this + 8));
  }
  if (*(_QWORD *)(v4 + 16))
    CA::Transaction::free_command_list(*(_QWORD **)(v4 + 16));
  v23 = *(_QWORD **)(v4 + 64);
  if (v23)
    CA::Transaction::free_commit_handlers_list(v23);
  v24 = *(_QWORD **)(v4 + 72);
  if (v24)
    CA::Transaction::free_commit_handlers_list(v24);
  v25 = *(_QWORD **)(v4 + 80);
  if (v25)
    CA::Transaction::free_commit_handlers_list(v25);
  v26 = *(_QWORD **)(v4 + 88);
  if (v26)
    CA::Transaction::free_commit_handlers_list(v26);
  v27 = *(_QWORD **)(v4 + 96);
  if (v27)
    CA::Transaction::free_commit_handlers_list(v27);
  v28 = *(_QWORD **)(v4 + 104);
  if (v28)
    CA::Transaction::free_commit_handlers_list(v28);
  v29 = *(_QWORD **)(v4 + 48);
  if (v29)
  {
    CA::Transaction::free_batch_handlers_list(v29);
    *(_QWORD *)(v4 + 48) = 0;
  }
  if (*(_QWORD *)(v4 + 24))
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    v31 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
    *v31 = *(_QWORD *)(v4 + 24);
    v31[1] = 0;
    while (1)
    {
      v32 = CA::Transaction::global_deleted[0];
      v31[1] = CA::Transaction::global_deleted[0];
      while (1)
      {
        v33 = __ldaxr(CA::Transaction::global_deleted);
        if (v33 != v32)
          break;
        if (!__stlxr((unint64_t)v31, CA::Transaction::global_deleted))
          goto LABEL_55;
      }
      __clrex();
    }
  }
LABEL_55:
  CA::Transaction::reset_animators(this);
  free(this);
}

void sub_184666728(_Unwind_Exception *a1)
{
  kdebug_trace();
  _Unwind_Resume(a1);
}

void CA::Transaction::free_commit_handlers_list(_QWORD *a1)
{
  _QWORD *v1;
  const void **v2;
  _QWORD *v3;

  v1 = a1;
  v2 = (const void **)a1;
  do
  {
    _Block_release(*v2);
    v2 = (const void **)v2[1];
  }
  while (v2);
  if (v1)
  {
    do
    {
      v3 = (_QWORD *)v1[1];
      free(v1);
      v1 = v3;
    }
    while (v3);
  }
}

void CA::Transaction::free_batch_handlers_list(_QWORD *a1)
{
  _QWORD *v1;
  const void **v2;
  _QWORD *v3;

  if (a1)
  {
    v1 = a1;
    v2 = (const void **)a1;
    do
    {
      _Block_release(*v2);
      v2 = (const void **)v2[1];
    }
    while (v2);
    do
    {
      v3 = (_QWORD *)v1[1];
      free(v1);
      v1 = v3;
    }
    while (v3);
  }
}

void std::__function::__func<CA::Transaction::release_thread(void *)::$_0,std::allocator<CA::Transaction::release_thread(void *)::$_0>,void ()(CA::Layer *,CA::Layer *)>::~__func()
{
  JUMPOUT(0x186DBD990);
}

_QWORD *std::__function::__func<CA::Transaction::release_thread(void *)::$_0,std::allocator<CA::Transaction::release_thread(void *)::$_0>,void ()(CA::Layer *,CA::Layer *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E159A2D8;
  return result;
}

void std::__function::__func<CA::Transaction::release_thread(void *)::$_0,std::allocator<CA::Transaction::release_thread(void *)::$_0>,void ()(CA::Layer *,CA::Layer *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E159A2D8;
}

void std::__function::__func<CA::Transaction::release_thread(void *)::$_0,std::allocator<CA::Transaction::release_thread(void *)::$_0>,void ()(CA::Layer *,CA::Layer *)>::operator()(uint64_t a1, unsigned int **a2)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  malloc_zone_t *malloc_zone;

  v2 = *a2;
LABEL_2:
  v3 = *v2;
  if (*v2)
  {
    do
    {
      v4 = __ldaxr(v2);
      if (v4 != v3)
      {
        __clrex();
        goto LABEL_2;
      }
    }
    while (__stlxr(v3 - 1, v2));
    if (v3 == 1)
    {
      CA::Layer::destroy((CA::Layer *)v2);
      CA::Layer::~Layer((CA::AttrList **)v2);
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v2);
    }
  }
}

void CA::CA_ABORT_ON_NON_MAIN_THREAD_TRANSACTION_PUSH(CA *this)
{
  x_log_crash("CoreAnimation: CA_ASSERT_MAIN_THREAD_TRANSACTIONS is set and an implicit transaction wasn't created on a main thread.\n");
  abort();
}

void CA::HDRProcessorInternal::~HDRProcessorInternal(CA::HDRProcessorInternal *this)
{
  CA::HDRProcessorInternal::~HDRProcessorInternal(this);
  JUMPOUT(0x186DBD990);
}

{
  uint64_t v2;
  unsigned int **v3;
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  const void *v11;

  *(_QWORD *)this = &off_1E1590F00;
  v2 = *((_QWORD *)this + 7);
  if (v2)
  {
    do
    {
      v3 = *(unsigned int ***)v2;
      if (*(_QWORD *)v2)
      {
        v4 = *v3;
        if (*v3)
        {
          v5 = v4 + 2;
          do
          {
            v6 = __ldaxr(v5);
            v7 = v6 - 1;
          }
          while (__stlxr(v7, v5));
          if (!v7)
            (*(void (**)(unsigned int *))(*(_QWORD *)v4 + 16))(v4);
        }
        MEMORY[0x186DBD990](v3, 0x20C4093837F09);
      }
      v2 = *(_QWORD *)(v2 + 8);
    }
    while (v2);
    v8 = (_QWORD *)*((_QWORD *)this + 7);
    if (v8)
    {
      do
      {
        v9 = (_QWORD *)v8[1];
        free(v8);
        v8 = v9;
      }
      while (v9);
    }
  }

  v10 = *((_QWORD *)this + 13);
  if (v10)
  {
    CA::IOSAManager::unref(v10);
    *((_QWORD *)this + 13) = 0;
  }

  v11 = (const void *)*((_QWORD *)this + 10);
  if (v11)
    CFRelease(v11);
}

uint64_t CA::HDRProcessorInternal::tonemap_surface(uint64_t a1, __IOSurface *a2, __IOSurface *a3, uint64_t *a4, uint64_t *a5, uint64_t a6, uint64_t a7, int a8, unint64_t a9, char a10, _DWORD *a11)
{
  const char *v18;
  unsigned int v19;
  uint64_t v20;
  double v21;
  unsigned int v22;
  BOOL v23;
  id started;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  char *v28;
  float v30;
  char v31;
  _OWORD v32[2];
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v34 = 0;
  v33 = 0;
  memset(v32, 0, sizeof(v32));
  CA::HDRProcessorInternal::get_config((uint64_t)v32, a2, a3, a6, &v34, a8, &v31, (CA::Render *)0x42475241);
  if (a7)
  {
    if (*(_BYTE *)(a1 + 89))
    {
      HIDWORD(v33) = 1;
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 20));
      if (!*(_QWORD *)(a1 + 104) || !*(_QWORD *)(a1 + 40))
        CA::HDRProcessorInternal::get_or_create_hdr_processor_instance(a1, (__CFRunLoop *)1, (uint64_t)v32);
      v19 = *(_DWORD *)(a6 + 60);
      v20 = mach_absolute_time();
      v21 = CATimeWithHostTime(v20);
      if (CA::HDRProcessorInternal::should_switch_accelerator(a1, a3, a2, v19, 0, 0, 0, 0, v21 + *(double *)(a7 + 112) * 2.0))*(_DWORD *)(a7 + 480) = 2;
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 20));
    }
    v22 = *(_DWORD *)(a7 + 480);
  }
  else
  {
    v22 = 2;
  }
  if (CADeviceHasHardwareAcceleratedHDR::once != -1)
    dispatch_once(&CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_93);
  if (CADeviceHasHardwareAcceleratedHDR::has_capability)
  {
    v23 = v22 < 2;
    if (v22 == 3)
      v23 = 1;
    *(_BYTE *)(a1 + 89) = v23;
    if (v22 <= 3 && v22 != 2)
    {
      started = 0;
      goto LABEL_21;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 89) = 0;
  }
  started = CA::HDRProcessorInternal::start_command_buffer((id *)a1, a9, v18);
LABEL_21:
  if (a7)
    v25 = CA::HDRProcessorInternal::tonemap_surface_internal(a1, a2, a3, a7, a4, a5, (uint64_t)v32, &v30, v34, a6, v22, a10, started, 0, 0, 0, 0, *(_QWORD *)(a7 + 896), *(_BYTE *)(a7 + 1064) & 3,
            a11);
  else
    v25 = CA::HDRProcessorInternal::tonemap_surface_internal(a1, a2, a3, 0, a4, a5, (uint64_t)v32, &v30, v34, a6, v22, a10, started, 0, 0, 0, 0, 0, 0,
            a11);
  v26 = v25;
  if (started)
    CA::HDRProcessorInternal::commit_command_buffer(started, 0);
  if (initialized[0] != -1)
    dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
  if (*(float *)&dword_1ECDC6934)
  {
    if (*(float *)&dword_1ECDC6934 > 0.0)
      *(float *)&dword_1ECDC6934 = *(float *)&dword_1ECDC6934 + -1.0;
    v27 = CAIOSurfaceWriteToFileWithSuffix(a3, "hdr-tonemap-src");
    free(v27);
    v28 = CAIOSurfaceWriteToFileWithSuffix(a2, "hdr-tonemap-dst");
    free(v28);
  }
  return v26;
}

void sub_184667320(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::HDRProcessorInternal::create_surface_with_forward_dm(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, int a5, int a6, int a7, unsigned int a8, float a9, char a10, char a11)
{
  unsigned int v17;
  char v18;
  BOOL v19;
  unsigned __int8 v20;
  __int128 *v21;
  OSType PixelFormat;
  int v23;
  BOOL v24;
  int v25;
  size_t Width;
  size_t Height;
  CA::ScalerUtil::ScalerLimits *ProtectionOptions;
  float v29;
  double v30;
  double v31;
  CA::Render *v32;
  OSType v33;
  __IOSurface *v34;
  __IOSurface *v35;
  unsigned int v36;
  uint64_t v37;
  double v38;
  int v39;
  __IOSurface *v40;
  uint64_t v41;
  CA::Render *v42;
  unsigned int v43;
  int v44;
  int v45;
  uint64_t v46;
  const __CFString *v47;
  int v48;
  int v49;
  uint64_t v50;
  unsigned int *v51;
  unsigned int v52;
  __IOSurface *iosurface_with_pixel_format;
  int v54;
  OSType v55;
  unsigned int v56;
  int v57;
  CA::Render *v58;
  unsigned int v59;
  const __CFString *v60;
  __IOSurface *v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  CA::Render *v65;
  int v66;
  __IOSurface *v67;
  const void *v68;
  malloc_zone_t *malloc_zone;
  void *v70;
  uint64_t v71;
  _QWORD *v72;
  unsigned int *v73;
  unsigned int v74;
  uint64_t v75;
  malloc_zone_t *v76;
  _QWORD *v77;
  __int16 v78;
  id started;
  uint64_t v80;
  const char *v81;
  unsigned int v82;
  void *v83;
  char v84;
  CGColorSpace *v85;
  CGColorSpace *v86;
  __IOSurface *v87;
  __CFRunLoop *v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  IOSurfaceID v92;
  __IOSurface *v93;
  CFTypeRef v94;
  const void **v95;
  __IOSurface *v96;
  uint64_t v97;
  int v98;
  unsigned int v99;
  NSObject *v100;
  IOSurfaceID v101;
  unsigned int *v102;
  unsigned int v103;
  CGColorSpace *v105;
  unsigned int v106;
  int v107;
  float v108;
  float v109;
  float v110;
  float v111;
  __int16 v112;
  char *v113;
  char *v114;
  unsigned int v115;
  NSObject *v116;
  NSObject *v117;
  IOSurfaceID v118;
  uint64_t ID;
  double v120;
  int v121;
  uint64_t v122;
  CGColorSpace **v123;
  int v124;
  uint64_t v125;
  uint64_t v126;
  unsigned int v127;
  void *contexta;
  uint64_t v132;
  _QWORD aBlock[5];
  float v134;
  char v135;
  char v136;
  unsigned int v137;
  uint64_t **v138;
  unsigned int v139;
  __int128 v140;
  CA::Render *v141[2];
  uint64_t v142;
  unsigned int v143[2];
  unsigned int v144[3];
  _DWORD v145[3];
  __int128 v146;
  uint64_t v147;
  __int128 v148;
  __int128 v149;
  uint64_t v150;
  uint8_t v151[32];
  unsigned int *v152;
  unsigned int *v153;
  uint64_t v154;
  uint8_t buf[4];
  IOSurfaceID v156;
  __int16 v157;
  IOSurfaceID v158;
  _QWORD v159[7];

  v159[4] = *MEMORY[0x1E0C80C00];
  if ((a10 & 1) != 0)
    v17 = 1;
  else
    v17 = *(_DWORD *)(a3 + 480);
  if (CADeviceHasHardwareAcceleratedHDR::once != -1)
    dispatch_once(&CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_93);
  v18 = CADeviceHasHardwareAcceleratedHDR::has_capability;
  if (CADeviceHasHardwareAcceleratedHDR::has_capability)
  {
    v19 = v17 < 2 || v17 == 3;
    v18 = v19;
  }
  *(_BYTE *)(a1 + 89) = v18;
  *(_QWORD *)&v145[1] = *(_QWORD *)(a2 + 112);
  if ((v20 & 1) == 0
  {
    CA::HDRProcessorInternal::create_surface_with_forward_dm(CA::Render::Surface const*,CA::Render::Update *,CA::Render::DisplayAttributes const*,BOOL,float,CA::Render::TextureFlags,BOOL,BOOL,BOOL,BOOL)::sdr_attrs = xmmword_18474E470;
    *(_OWORD *)algn_1EDD120F0 = xmmword_18474E480;
    xmmword_1EDD12100 = xmmword_18474E020;
    qword_1EDD12110 = 0;
    word_1EDD12118 = 0;
    unk_1EDD1211C = 0x100000001;
    unk_1EDD12124 = 0u;
    unk_1EDD12134 = 0u;
    byte_1EDD12144 = 0;
    dword_1EDD12148 = 1065353216;
    unk_1EDD12154 = 0;
    unk_1EDD1214C = 0;
    dword_1EDD1215C = -1;
  }
  if (a7)
    v21 = &CA::HDRProcessorInternal::create_surface_with_forward_dm(CA::Render::Surface const*,CA::Render::Update *,CA::Render::DisplayAttributes const*,BOOL,float,CA::Render::TextureFlags,BOOL,BOOL,BOOL,BOOL)::sdr_attrs;
  else
    v21 = a4;
  v132 = (uint64_t)v21;
  PixelFormat = IOSurfaceGetPixelFormat(*(IOSurfaceRef *)&v145[1]);
  v125 = a3;
  if (initialized[0] != -1)
    dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
  v127 = *(float *)&dword_1ECDC6934;
  v23 = dword_1ECDC6A04;
  v124 = a7;
  v123 = (CGColorSpace **)a2;
  if (CA::Render::fourcc_compressed_of_type((CA::Render *)dword_1ECDC6A04, 0, 0) == v23)
  {
    if (CADeviceSupportsUniversalCompression::once[0] != -1)
      dispatch_once(CADeviceSupportsUniversalCompression::once, &__block_literal_global_27);
    if (CADeviceSupportsUniversalCompression::universal)
    {
      if (*(_BYTE *)(a1 + 89))
        v24 = v127 == 0;
      else
        v24 = 0;
      v25 = v24;
    }
    else
    {
      v25 = 0;
    }
  }
  else
  {
    v25 = 1;
  }
  v145[0] = CA::HDRProcessorInternal::output_pixel_format(a1, v132, v17, *(IOSurfaceRef *)&v145[1], v25);
  Width = IOSurfaceGetWidth(*(IOSurfaceRef *)&v145[1]);
  Height = IOSurfaceGetHeight(*(IOSurfaceRef *)&v145[1]);
  ProtectionOptions = (CA::ScalerUtil::ScalerLimits *)IOSurfaceGetProtectionOptions();
  v126 = (uint64_t)ProtectionOptions;
  if (*(_BYTE *)(a1 + 89))
  {
    CA::ScalerUtil::ScalerLimits::limits(ProtectionOptions);
    v29 = *(float *)&xmmword_1EDD11090;
    if (*(float *)&xmmword_1EDD11090 <= *((float *)&xmmword_1EDD11090 + 1))
      v29 = *((float *)&xmmword_1EDD11090 + 1);
    v30 = a9;
    if (a9 > 1.0)
      v30 = 1.0;
    if (v30 >= v29)
      a9 = v30;
    else
      a9 = v29;
  }
  if (byte_1ECDC6AED && a8 && a9 != 1.0)
  {
    if (x_log_hook_p())
    {
      v120 = a9;
      ID = IOSurfaceGetID(*(IOSurfaceRef *)&v145[1]);
      x_log_();
    }
    else
    {
      v116 = x_log_category_filmgrain;
      if (os_log_type_enabled((os_log_t)x_log_category_filmgrain, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)v151 = 67109376;
        *(_DWORD *)&v151[4] = IOSurfaceGetID(*(IOSurfaceRef *)&v145[1]);
        *(_WORD *)&v151[8] = 2048;
        *(double *)&v151[10] = a9;
        _os_log_impl(&dword_184457000, v116, OS_LOG_TYPE_INFO, "[0x%x] combine scale + FG in next MSR pass (scale: %f)", v151, 0x12u);
      }
    }
  }
  v31 = (float)(a9 * (float)Height) + 0.5;
  *(_QWORD *)v143 = ((unint64_t)v31 + 1) & 0xFFFFFFFFFFFFFFFELL;
  *(_QWORD *)v144 = ((unint64_t)((float)(a9 * (float)Width) + 0.5) + 1) & 0xFFFFFFFFFFFFFFFELL;
  if ((a6 & 4) != 0)
  {
    *(_QWORD *)v143 = ((unint64_t)((float)(a9 * (float)Width) + 0.5) + 1) & 0xFFFFFFFFFFFFFFFELL;
    *(_QWORD *)v144 = ((unint64_t)v31 + 1) & 0xFFFFFFFFFFFFFFFELL;
  }
  if (*(_QWORD *)(a1 + 80) && (a10 & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 20));
    if (!*(_QWORD *)(a1 + 104) || !*(_QWORD *)(a1 + 40))
    {
      v152 = 0;
      memset(v151, 0, sizeof(v151));
      v32 = (CA::Render *)IOSurfaceGetPixelFormat(*(IOSurfaceRef *)(a1 + 80));
      CA::HDRProcessorInternal::get_config((uint64_t)&v140, 0, *(__IOSurface **)&v145[1], v132, &v148, 0, v159, v32);
      v152 = (unsigned int *)(v142 | 0x100000000);
      *(_OWORD *)v151 = v140;
      *(_OWORD *)&v151[16] = *(_OWORD *)v141;
      *(_DWORD *)v151 = IOSurfaceGetWidth(*(IOSurfaceRef *)(a1 + 80));
      *(_DWORD *)&v151[4] = IOSurfaceGetHeight(*(IOSurfaceRef *)(a1 + 80));
      CA::HDRProcessorInternal::get_or_create_hdr_processor_instance(a1, (__CFRunLoop *)1, (uint64_t)v151);
    }
    v33 = PixelFormat;
    if (CADeviceSupportsToneMapAcceleratorSwitching::once[0] != -1)
      dispatch_once(CADeviceSupportsToneMapAcceleratorSwitching::once, &__block_literal_global_179);
    if (!CADeviceSupportsToneMapAcceleratorSwitching::accelerator_switching)
      goto LABEL_69;
    if (CADeviceHasHardwareAcceleratedHDR::once != -1)
      dispatch_once(&CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_93);
    if (v17 == 2 && CADeviceHasHardwareAcceleratedHDR::has_capability)
      goto LABEL_55;
    v40 = *(__IOSurface **)(a1 + 80);
    if (!v40)
      goto LABEL_69;
    v121 = v145[0];
    v41 = *(_QWORD *)v144;
    v122 = *(_QWORD *)v143;
    v42 = (CA::Render *)IOSurfaceGetPixelFormat(v40);
    if (initialized[0] != -1)
      dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
    if (((v43 = *(float *)&dword_1ECDC6934,
           v44 = CA::Render::fourcc_compressed_of_type(v42, 0, 0),
           v45 = v44,
           !v43)
       || v44 == (_DWORD)v42)
      && IOSurfaceGetWidth(v40) == v41
      && IOSurfaceGetHeight(v40) == v122
      && v45 == v121
      && (IOSurfaceGetProtectionOptions(), IOSurfaceSupportsProtectionOptions()))
    {
LABEL_55:
      v34 = *(__IOSurface **)&v145[1];
      v35 = *(__IOSurface **)(a1 + 80);
      v36 = *(_DWORD *)(v125 + 412);
      v37 = mach_absolute_time();
      v38 = CATimeWithHostTime(v37);
      PixelFormat = v33;
      if (!CA::HDRProcessorInternal::should_switch_accelerator(a1, v34, v35, v36, a6, a8, v17, 1, v38 + *(double *)(v125 + 112) * 2.0))
      {
LABEL_71:
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 20));
        goto LABEL_72;
      }
      if (v17 == 2)
        v39 = 1;
      else
        v39 = 2;
      *(_DWORD *)(v125 + 480) = v39;
    }
    else
    {
LABEL_69:
      PixelFormat = v33;
      if (!a11)
        goto LABEL_71;
      memset(v151, 0, 24);
      CA::HDRProcessorInternal::get_msr_estimate(v151, a1, *(uint64_t *)&v145[1], *(_QWORD *)(a1 + 80), a6, a8);
      if (*(float *)v151 <= 0.975)
        goto LABEL_71;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 20));
    return 0;
  }
LABEL_72:
  v139 = 0;
  v138 = 0;
  *(_QWORD *)v151 = &v139;
  *(_QWORD *)&v151[8] = &v138;
  *(_QWORD *)&v151[16] = &v145[1];
  *(_QWORD *)&v151[24] = v145;
  v152 = v144;
  v153 = v143;
  v154 = a1;
  v46 = *(_QWORD *)(a1 + 64);
  if (!v46
    || (CA::HDRProcessorInternal::create_surface_with_forward_dm(CA::Render::Surface const*,CA::Render::Update *,CA::Render::DisplayAttributes const*,BOOL,float,CA::Render::TextureFlags,BOOL,BOOL,BOOL,BOOL)::$_0::operator()((uint64_t)v151, *(uint64_t **)(v46 + 8), 0), !v138)|| !*(_DWORD *)(a1 + 72))
  {
    CA::HDRProcessorInternal::create_surface_with_forward_dm(CA::Render::Surface const*,CA::Render::Update *,CA::Render::DisplayAttributes const*,BOOL,float,CA::Render::TextureFlags,BOOL,BOOL,BOOL,BOOL)::$_0::operator()((uint64_t)v151, *(uint64_t **)(a1 + 56), *(uint64_t **)(a1 + 64));
  }
  if (v139 < 2)
  {
    v49 = 3;
  }
  else
  {
    v48 = *(_DWORD *)(a1 + 72);
    if (!v48)
      goto LABEL_81;
    v49 = v48 - 1;
  }
  *(_DWORD *)(a1 + 72) = v49;
LABEL_81:
  if (v138)
  {
    v50 = **v138;
    if (v50)
    {
      v51 = (unsigned int *)(v50 + 8);
      do
        v52 = __ldaxr(v51);
      while (__stlxr(v52 + 1, v51));
      iosurface_with_pixel_format = *(__IOSurface **)(v50 + 112);
      *(_QWORD *)(a1 + 64) = v138;
      v54 = 1;
      goto LABEL_130;
    }
    *(_QWORD *)(a1 + 64) = v138;
  }
  if ((v25 & 1) != 0)
  {
    v55 = HIBYTE(PixelFormat);
    if (HIBYTE(PixelFormat) == 45)
    {
      v56 = 0;
    }
    else if (v55 == 124)
    {
      v56 = 2;
    }
    else if (v55 == 47)
    {
      v56 = 1;
    }
    else
    {
      v56 = -1;
    }
    v58 = (CA::Render *)v145[0];
    if (v145[0] == 1882469428)
      v56 = -1;
    if (v56 > 2)
      v57 = 2;
    else
      v57 = dword_1847524AC[v56];
  }
  else
  {
    v57 = 0;
    v58 = (CA::Render *)v145[0];
  }
  v59 = (MEMORY[0xFFFFFC020] >> 9) & 4 | v57;
  iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format(v58, v144[0], v143[0], v59, v126, CFSTR("CA Forward DM"), v47);
  v61 = *(__IOSurface **)(a1 + 80);
  if (v61)
  {
    v62 = v145[0];
    v63 = *(_QWORD *)v143;
    v64 = *(_QWORD *)v144;
    v65 = (CA::Render *)IOSurfaceGetPixelFormat(*(IOSurfaceRef *)(a1 + 80));
    if (initialized[0] != -1)
      dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
    if ((!*(float *)&dword_1ECDC6934
       || CA::Render::fourcc_compressed_of_type(v65, 0, 0) == (_DWORD)v65)
      && IOSurfaceGetWidth(v61) == v64)
    {
      v66 = CA::Render::fourcc_compressed_of_type(v65, 0, 0);
      if (IOSurfaceGetHeight(v61) == v63 && v66 == v62)
      {
        IOSurfaceGetProtectionOptions();
        if ((IOSurfaceSupportsProtectionOptions() & 1) != 0)
          goto LABEL_118;
      }
    }
  }
  if (!*(_BYTE *)(a1 + 89))
  {
LABEL_118:
    if (iosurface_with_pixel_format)
      goto LABEL_119;
    return 0;
  }
  if (CADeviceSupportsToneMapAcceleratorSwitching::once[0] != -1)
    dispatch_once(CADeviceSupportsToneMapAcceleratorSwitching::once, &__block_literal_global_179);
  if (CADeviceSupportsToneMapAcceleratorSwitching::accelerator_switching)
  {
    v67 = CA::Render::create_iosurface_with_pixel_format((CA::Render *)v145[0], v144[0], v143[0], v59, v126, CFSTR("CA Estimate Surface"), v60);
    v68 = *(const void **)(a1 + 80);
    if (v68)
      CFRelease(v68);
    *(_QWORD *)(a1 + 80) = v67;
    goto LABEL_118;
  }
  v96 = *(__IOSurface **)(a1 + 80);
  if (v96 == iosurface_with_pixel_format)
    goto LABEL_118;
  if (v96)
    CFRelease(v96);
  *(_QWORD *)(a1 + 80) = iosurface_with_pixel_format;
  if (!iosurface_with_pixel_format)
    return 0;
  CFRetain(iosurface_with_pixel_format);
LABEL_119:
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v70 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x158uLL, 0x743898A5uLL);
  v50 = (uint64_t)v70;
  if (!v70)
  {
    v71 = *(_QWORD *)(a1 + 56);
    v72 = (_QWORD *)operator new();
LABEL_125:
    v75 = 0;
    goto LABEL_126;
  }
  CA::Render::Surface::Surface((uint64_t)v70, iosurface_with_pixel_format, -1, 63, 0, 0, 0);
  v71 = *(_QWORD *)(a1 + 56);
  v72 = (_QWORD *)operator new();
  v73 = (unsigned int *)(v50 + 8);
  do
    v74 = __ldaxr(v73);
  while (__stlxr(v74 + 1, v73));
  if (!v74)
  {
    do
      v115 = __ldaxr(v73);
    while (__stlxr(v115 - 1, v73));
    goto LABEL_125;
  }
  v75 = v50;
LABEL_126:
  *v72 = v75;
  v76 = (malloc_zone_t *)get_malloc_zone();
  v77 = malloc_type_zone_malloc(v76, 0x10uLL, 0x8BB15036uLL);
  *v77 = v72;
  v77[1] = v71;
  *(_QWORD *)(a1 + 56) = v77;
  *(_QWORD *)(a1 + 64) = v77;
  CFRelease(iosurface_with_pixel_format);
  v54 = 0;
  if ((*((unsigned int (**)(CGColorSpace **))*v123 + 16))(v123))
    v78 = 8;
  else
    v78 = 0;
  *(_WORD *)(v50 + 336) = *(_WORD *)(v50 + 336) & 0xFFF7 | v78;
LABEL_130:
  v137 = 0;
  v142 = 0;
  v140 = 0u;
  *(_OWORD *)v141 = 0u;
  v136 = 0;
  CA::HDRProcessorInternal::get_config((uint64_t)&v148, iosurface_with_pixel_format, *(__IOSurface **)&v145[1], v132, &v137, 0, &v136, (CA::Render *)0x42475241);
  v140 = v148;
  *(_OWORD *)v141 = v149;
  v142 = v150;
  if (CADeviceSupportsToneMapAcceleratorSwitching::once[0] != -1)
    dispatch_once(CADeviceSupportsToneMapAcceleratorSwitching::once, &__block_literal_global_179);
  v82 = a8;
  if (CADeviceSupportsToneMapAcceleratorSwitching::accelerator_switching)
  {
    if (CADeviceHasHardwareAcceleratedHDR::once != -1)
      dispatch_once(&CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_93);
    if (v17 == 2 && CADeviceHasHardwareAcceleratedHDR::has_capability)
      v141[1] = *(CA::Render **)MEMORY[0x1E0CA8D80];
  }
  if (*(_BYTE *)(a1 + 89))
  {
    v83 = 0;
  }
  else
  {
    started = CA::HDRProcessorInternal::start_command_buffer((id *)a1, v126, v81);
    v83 = started;
    v82 = a8;
  }
  if (v127)
  {
    a5 = 0;
    if (*(float *)&dword_1ECDC6934 > 0.0)
      *(float *)&dword_1ECDC6934 = *(float *)&dword_1ECDC6934 + -1.0;
  }
  v135 = 0;
  v134 = (float)HIDWORD(v140);
  v84 = v124 & v82;
  if ((v124 & v82) == 1)
  {
    v85 = v123[6];
    if (v85)
    {
      CA::Render::Texture::set_colorspace((CA::Render::Texture *)v50, v123[6]);
      CA::Render::iosurface_set_colorspace(iosurface_with_pixel_format, v85, v86);
    }
    v87 = *(__IOSurface **)&v145[1];
    contexta = (void *)MEMORY[0x186DBE2E4](started, v80);
    if (*(_BYTE *)(a1 + 89) && !*(_QWORD *)(a1 + 104))
    {
      if (CA::WindowServer::accelerator_runloop(void)::once != -1)
        dispatch_once(&CA::WindowServer::accelerator_runloop(void)::once, &__block_literal_global_5307);
      *(_QWORD *)(a1 + 104) = CA::IOSAManager::create_new_iosa_manager((CA::IOSAManager *)CA::WindowServer::accelerator_runloop(void)::runloop, v88);
    }
    v89 = dword_1ECDC6B10;
    v90 = *MEMORY[0x1E0D3A328];
    *(_QWORD *)&v148 = MEMORY[0x1E0C9AAA0];
    v91 = *MEMORY[0x1E0D3A330];
    v159[0] = v90;
    v159[1] = v91;
    *((_QWORD *)&v148 + 1) = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", a6 & 7, ID, *(_QWORD *)&v120);
    v159[2] = *MEMORY[0x1E0D3A240];
    *(_QWORD *)&v149 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 1);
    v159[3] = *MEMORY[0x1E0D3A218];
    *((_QWORD *)&v149 + 1) = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", v89 == 0);
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v148, v159, 4);
    v147 = 0;
    v146 = xmmword_1E159E3D0;
    v92 = IOSurfaceAcceleratorTransformSurface();
    if ((a5 & 1) == 0)
      ((void (*)(_QWORD, _QWORD, uint64_t))v146)(*((_QWORD *)&v146 + 1), 0, v147);
    if (v92)
    {
      if (x_log_hook_p())
      {
        IOSurfaceGetID(v87);
        x_log_();
      }
      else
      {
        v100 = x_log_category_utilities;
        if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
        {
          v101 = IOSurfaceGetID(v87);
          *(_DWORD *)buf = 67109376;
          v156 = v92;
          v157 = 1024;
          v158 = v101;
          _os_log_impl(&dword_184457000, v100, OS_LOG_TYPE_ERROR, "MSR failed err=0x%x sur=0x%x", buf, 0xEu);
        }
      }
      objc_autoreleasePoolPop(contexta);
      goto LABEL_191;
    }
    if (byte_1ECDC6AED)
    {
      if (x_log_hook_p())
      {
        IOSurfaceGetID(v87);
        x_log_();
      }
      else
      {
        v117 = x_log_category_filmgrain;
        if (os_log_type_enabled((os_log_t)x_log_category_filmgrain, OS_LOG_TYPE_INFO))
        {
          v118 = IOSurfaceGetID(v87);
          *(_DWORD *)buf = 67109120;
          v156 = v118;
          _os_log_impl(&dword_184457000, v117, OS_LOG_TYPE_INFO, "[0x%x] [SDR] MSR Successfully applied film grain", buf, 8u);
        }
      }
    }
    objc_autoreleasePoolPop(contexta);
  }
  else if ((CA::HDRProcessorInternal::tonemap_surface_internal(a1, iosurface_with_pixel_format, *(__IOSurface **)&v145[1], v125, 0, 0, (uint64_t)&v140, &v134, v137, v132, v17, a5, v83, &v135, a6, SHIWORD(a6), v82, 0, 0,
               0) & 1) == 0)
  {
LABEL_191:

    v102 = (unsigned int *)(v50 + 8);
    do
      v103 = __ldaxr(v102);
    while (__stlxr(v103 - 1, v102));
    if (v103 == 1)
      (*(void (**)(uint64_t))(*(_QWORD *)v50 + 16))(v50);
    return 0;
  }
  if (*(_BYTE *)(v125 + 405))
  {
    v94 = IOSurfaceCopyValue(*(IOSurfaceRef *)&v145[1], (CFStringRef)_kHDRProcessingDolbyVisionRPUDataKey);
    if (!v94)
      goto LABEL_173;
    v95 = (const void **)(v50 + 144);
    goto LABEL_172;
  }
  if (*(_BYTE *)(v125 + 407))
  {
    v94 = IOSurfaceCopyValue(iosurface_with_pixel_format, (CFStringRef)_kHDRProcessingDolbyVisionHDMIDataKey);
    if (v94)
    {
      v95 = (const void **)(v50 + 152);
LABEL_172:
      X::CFRef<__CFData const*>::operator=(v95, v94);
      CFRelease(v94);
    }
  }
LABEL_173:
  if (v54)
    CA::Render::Surface::reload_iosurface_color_attributes((CA::Render::Surface *)v50, v93);
  if (v83)
  {
    CA::HDRProcessorInternal::commit_command_buffer(v83, a5);
    if (a5)
    {
      aBlock[0] = MEMORY[0x1E0C809B0];
      aBlock[1] = 3221225472;
      aBlock[2] = ___ZN2CA20HDRProcessorInternal30create_surface_with_forward_dmEPKNS_6Render7SurfaceEPNS1_6UpdateEPKNS1_17DisplayAttributesEbfNS1_12TextureFlagsEbbbb_block_invoke;
      aBlock[3] = &unk_1E159E3F0;
      aBlock[4] = v83;
      v97 = *(_QWORD *)(v50 + 312);
      if (v97)
      {
        (*(void (**)(uint64_t, uint64_t))(v97 + 16))(v97, 1);
        _Block_release(*(const void **)(v50 + 312));
        *(_QWORD *)(v50 + 312) = 0;
      }
      *(_QWORD *)(v50 + 312) = _Block_copy(aBlock);
    }
  }
  v98 = CA::Render::fourcc_compressed_of_type((CA::Render *)LODWORD(v141[0]), 0, 0);
  if ((v84 & 1) == 0)
  {
    switch(v136)
    {
      case 16:
        if ((CA::Render *)*MEMORY[0x1E0CA8D80] == v141[1])
        {
          v99 = 13;
        }
        else if ((CA::Render *)*MEMORY[0x1E0CA8D98] == v141[1])
        {
          v99 = 7;
        }
        else
        {
          if ((CA::Render *)*MEMORY[0x1E0CA8D88] != v141[1])
            goto LABEL_213;
          v99 = 18;
        }
        break;
      case 13:
        if ((CA::Render *)*MEMORY[0x1E0CA8D80] == v141[1])
        {
          v99 = 14;
        }
        else if ((CA::Render *)*MEMORY[0x1E0CA8D98] == v141[1])
        {
          v99 = 5;
        }
        else
        {
          if ((CA::Render *)*MEMORY[0x1E0CA8D88] != v141[1])
            goto LABEL_213;
          v99 = 29;
        }
        break;
      case 8:
        if ((CA::Render *)*MEMORY[0x1E0CA8D88] == v141[1])
        {
          v99 = 26;
        }
        else if ((CA::Render *)*MEMORY[0x1E0CA8D98] == v141[1])
        {
          v99 = 15;
        }
        else
        {
          if ((CA::Render *)*MEMORY[0x1E0CA8D80] != v141[1])
            goto LABEL_213;
          v99 = 10;
        }
        break;
      default:
        goto LABEL_213;
    }
    v105 = (CGColorSpace *)CAGetColorSpace(v99);
    if (v105)
      CA::Render::Texture::set_colorspace((CA::Render::Texture *)v50, v105);
  }
LABEL_213:
  v106 = *(_DWORD *)(v132 + 60);
  if (v106 <= 6)
  {
    v107 = 1 << v106;
    if ((v107 & 0x1C) != 0)
    {
      if (v98 != 1919365992 && v98 != 1380411457)
        goto LABEL_230;
      (*(void (**)(uint64_t))(*(_QWORD *)v50 + 152))(v50);
      if (*(_BYTE *)(a1 + 89)
        && *(_DWORD *)(v132 + 60) == 2
        && !(*(unsigned __int8 *)(v132 + 53) | BYTE4(xmmword_1ECDC6A90)))
      {
        v109 = *(float *)(v132 + 28);
        v110 = v109 * 0.1;
        v19 = v109 == 0.0;
        v108 = 0.2;
        if (!v19)
          v108 = v110;
      }
      else if ((*(_WORD *)(v50 + 336) & 4) == 0)
      {
        v108 = (float)HIDWORD(v140);
      }
    }
    else
    {
      v108 = 1.0;
      if ((v107 & 0x61) != 0 && (v98 != 1919365992 && v98 != 1380411457 || *(_BYTE *)(a1 + 89)))
        v108 = 1.0 / *(float *)(v132 + 20);
    }
    CA::Render::Surface::set_edr_factor(v50, v108);
  }
LABEL_230:
  if (v136 == 16)
  {
    v111 = *(float *)(v132 + 28);
    if (v111 == 0.0)
      v111 = 1.0;
    if (v135)
      v111 = (float)(v134 * v111) / *(float *)(v132 + 12);
    CA::Render::Surface::set_edr_factor(v50, v111);
  }
  if (v17 == 2)
    v112 = 272;
  else
    v112 = 16;
  *(_WORD *)(v50 + 336) = v112 | *(_WORD *)(v50 + 336) & 0xFECF;
  *(_DWORD *)(v50 + 12) &= 0xFFFFF8FF;
  if (v127)
  {
    v113 = CAIOSurfaceWriteToFileWithSuffix(*(__IOSurface **)&v145[1], "hdr-tonemap-src");
    free(v113);
    v114 = CAIOSurfaceWriteToFileWithSuffix(iosurface_with_pixel_format, "hdr-tonemap-dst");
    free(v114);
  }
  return v50;
}

void sub_184668638(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *context)
{
  objc_autoreleasePoolPop(context);
  _Unwind_Resume(a1);
}

uint64_t CA::HDRProcessorInternal::configure_display_pipe_tonemap(os_unfair_lock_s *a1, __IOSurface *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  const char *v19;
  NSObject *v20;
  uint32_t v21;
  uint64_t v22;
  CA::Render *v23;
  unsigned int v24;
  uint64_t v25;
  float v26;
  os_unfair_lock_s *v27;
  id v28;
  double v29;
  unsigned int v30;
  float v31;
  void *v32;
  uint64_t v33;
  double v34;
  double v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t *v40;
  uint64_t v41;
  NSObject *v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  void *hdr_processor_instance;
  uint64_t v47;
  NSObject *v48;
  NSObject *v49;
  OSType PixelFormat;
  unsigned int v52;
  int v53;
  NSObject *v54;
  OSType v55;
  unsigned int v56;
  int v57;
  unsigned int v58;
  int v59;
  unsigned int v60;
  int v61;
  unsigned int v62;
  int v63;
  signed int v64;
  unsigned int v65;
  int v66;
  char v67;
  unsigned int v68;
  int v69;
  char v70;
  unsigned int v71;
  int v72;
  int v73;
  size_t Height;
  size_t Width;
  IOSurfaceID ID;
  int v77;
  uint64_t v78;
  uint64_t v79;
  id v80;
  const __CFDictionary *cf;
  _QWORD v82[7];
  char v83;
  __int128 v84;
  __int128 v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  int v96;
  _BYTE buf[40];
  int v98;
  __int16 v99;
  int v100;
  __int16 v101;
  int v102;
  __int16 v103;
  int v104;
  __int16 v105;
  int v106;
  __int16 v107;
  uint64_t v108;
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  if (hdrprocessing_init_once != -1)
    dispatch_once_f(&hdrprocessing_init_once, 0, (dispatch_function_t)load_hdrprocessing_symbols);
  if (hdr_handle)
  {
    v15 = (void *)MEMORY[0x186DBE2E4]();
    IOSurfaceGetPixelFormat(a2);
    v96 = 0;
    v94 = 0u;
    v95 = 0u;
    v92 = 0u;
    v93 = 0u;
    v90 = 0u;
    v91 = 0u;
    v89 = 0u;
    v88 = 116;
    if (IOSurfaceGetBulkAttachments())
    {
      v16 = 0;
LABEL_89:
      objc_autoreleasePoolPop(v15);
      return v16;
    }
    cf = IOSurfaceCopyAllValues(a2);
    if (CFDictionaryGetValue(cf, (const void *)_kHDRProcessingDolbyVisionRPUDataKey))
    {
      if (x_log_hook_p())
      {
LABEL_7:
        x_log_();
        goto LABEL_86;
      }
      v18 = x_log_category_utilities;
      if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
        goto LABEL_86;
      *(_WORD *)buf = 0;
      v19 = "HDR surface with RPUData unsupported for display tone map";
      v20 = v18;
      v21 = 2;
LABEL_17:
      _os_log_impl(&dword_184457000, v20, OS_LOG_TYPE_ERROR, v19, buf, v21);
      goto LABEL_86;
    }
    if (BYTE12(v92) != 18)
    {
      if (BYTE12(v92) == 16 && BYTE11(v92) <= 0xCu && ((1 << SBYTE11(v92)) & 0x1202) != 0)
      {
        v17 = &_kHDRProcessingSourceContentTypeHDR10;
        goto LABEL_20;
      }
      if (!CA_CFDictionaryGetBool(cf, CFSTR("isHLG")))
      {
        if (x_log_hook_p())
          goto LABEL_7;
        v41 = x_log_category_utilities;
        if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
          goto LABEL_86;
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = BYTE12(v92);
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = BYTE11(v92);
        v19 = "HDR surface with transfer index %d color index %d unsupported for display tone map";
        v20 = v41;
        v21 = 14;
        goto LABEL_17;
      }
    }
    v17 = &_kHDRProcessingSourceContentTypeHLG;
LABEL_20:
    v22 = *v17;
    if (!*v17)
      goto LABEL_86;
    v23 = (CA::Render *)CA::HDRProcessorInternal::output_pixel_format((uint64_t)a1, a4, 3u, a2, 1);
    v77 = CA::Render::fourcc_compressed_of_type(v23, 0, 0);
    v87 = 0;
    v86 = 0;
    v84 = 0u;
    v85 = 0u;
    v83 = 0;
    CA::HDRProcessorInternal::get_config((uint64_t)buf, 0, a2, a4, &v87, 0, &v83, v23);
    v84 = *(_OWORD *)buf;
    v85 = *(_OWORD *)&buf[16];
    v86 = *(_QWORD *)&buf[32];
    if (*MEMORY[0x1E0CA8D88] == *(_QWORD *)&buf[24])
    {
      v24 = 26;
    }
    else if (*MEMORY[0x1E0CA8D98] == *(_QWORD *)&buf[24])
    {
      v24 = 15;
    }
    else
    {
      if (*MEMORY[0x1E0CA8D80] != *(_QWORD *)&buf[24])
        goto LABEL_32;
      v24 = 10;
    }
    v25 = CAGetColorSpace(v24);
    if (a5 && v25)
      *a5 = v25;
LABEL_32:
    v26 = *(float *)(a4 + 12);
    HIDWORD(v86) = 2;
    HIDWORD(v84) = v26;
    v27 = a1 + 5;
    os_unfair_lock_lock(a1 + 5);
    if (!CA::HDRProcessorInternal::get_or_create_hdr_processor_instance((uint64_t)a1, (__CFRunLoop *)2, (uint64_t)&v84))
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v42 = x_log_category_utilities;
        if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184457000, v42, OS_LOG_TYPE_ERROR, "Failed to create HDRProcessor for display", buf, 2u);
        }
      }
      goto LABEL_82;
    }
    os_unfair_lock_unlock(a1 + 5);
    v80 = objc_alloc_init(MEMORY[0x1E0C99E08]);
    v28 = objc_alloc_init(MEMORY[0x1E0C99E08]);
    objc_msgSend(v28, "setObject:forKeyedSubscript:", v22, _kHDRProcessingSourceContentTypeKey);
    objc_msgSend(v80, "setObject:forKeyedSubscript:", v28, _kHDRProcessingSourceContentKey);

    if (_hdrp_version >= 1)
      objc_msgSend(v80, "setObject:forKeyedSubscript:", &unk_1E15D6ED0, _kHDRProcessingApiInterfaceVersionKey);
    v30 = *(_DWORD *)(a4 + 60);
    v79 = 3;
    v31 = 100.0;
    if (v30 > 6)
    {
      v27 = a1 + 5;
      v32 = v80;
    }
    else
    {
      v27 = a1 + 5;
      v32 = v80;
      if (((1 << v30) & 0x61) != 0)
      {
        if (*(float *)(a4 + 12) == 0.0)
          v31 = 100.0;
        else
          v31 = *(float *)(a4 + 12);
        LODWORD(v29) = *(_DWORD *)(a4 + 20);
        v33 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v29);
        objc_msgSend(v80, "setObject:forKeyedSubscript:", v33, _kHDRProcessingMaximumExtendedDynamicRangeColorComponentValueKey);
        if (v77 == 1380411457 || v77 == 1919365992 || v83 == 16)
        {
          objc_msgSend(v80, "setObject:forKeyedSubscript:", &unk_1E15DACE0, _kHDRProcessingEDRFactorKey);
        }
        else
        {
          *(float *)&v34 = 1.0 / *(float *)(a4 + 20);
          v43 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v34);
          objc_msgSend(v80, "setObject:forKeyedSubscript:", v43, _kHDRProcessingEDRFactorKey);
        }
        LODWORD(v35) = *(_DWORD *)(a4 + 16);
        v36 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v35);
        objc_msgSend(v80, "setObject:forKeyedSubscript:", v36, _kHDRProcessingAmbientLightInNitsKey);
        if (*(_BYTE *)(a4 + 48))
          objc_msgSend(v80, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AAB0], _kHDRProcessingDisplaySupportsAmbientAdaptationKey);
        if (*(unsigned __int8 *)(a4 + 54) | BYTE12(xmmword_1ECDC6A90))
        {
          v37 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", 1);
          objc_msgSend(v80, "setObject:forKeyedSubscript:", v37, _kHDRProcessingOperationEnum);
          v38 = 1;
        }
        else
        {
          v38 = 3;
        }
        v79 = v38;
        v30 = *(_DWORD *)(a4 + 60);
        if (v30 <= 6 && ((1 << v30) & 0x61) != 0)
        {
          v39 = *(_DWORD *)(a4 + 64);
          v40 = &_kHDRProcessingDisplayPipelineCompensationTypeNone;
          if (v39 == 1 || byte_1ECDC6A8E)
            goto LABEL_65;
          if (v39 == 3)
          {
            v40 = &_kHDRProcessingDisplayPipelineCompensationTypeHeadroomDependent;
            goto LABEL_65;
          }
          if (v39 == 2)
          {
            v40 = &_kHDRProcessingDisplayPipelineCompensationTypePurePower;
LABEL_65:
            objc_msgSend(v80, "setObject:forKeyedSubscript:", *v40, _kHDRProcessingDisplayPipelineCompensationType);
            v30 = *(_DWORD *)(a4 + 60);
          }
        }
      }
    }
    if (v30 == 2 && !(*(unsigned __int8 *)(a4 + 53) | BYTE4(xmmword_1ECDC6A90)))
      v31 = 1000.0;
    *(float *)&v29 = v31;
    v44 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v29);
    objc_msgSend(v32, "setObject:forKeyedSubscript:", v44, _kHDRProcessingCurrentMaxPanelNitsKey);
    v45 = forward_display_params_from_attributes(a4, 1);
    if (v45)
      objc_msgSend(v32, "setObject:forKeyedSubscript:", v45, _kHDRProcessingDisplayKey);
    if (!BYTE12(xmmword_1ECDC6AB0))
      goto LABEL_72;
    v78 = objc_msgSend((id)objc_msgSend(v32, "debugDescription", v45), "UTF8String");
    if (x_log_hook_p())
    {
      IOSurfaceGetID(a2);
      IOSurfaceGetWidth(a2);
      IOSurfaceGetHeight(a2);
      PixelFormat = IOSurfaceGetPixelFormat(a2);
      v52 = HIBYTE(PixelFormat);
      if ((PixelFormat & 0x80000000) != 0)
        v53 = __maskrune(v52, 0x40000uLL);
      else
        v53 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v52 + 60) & 0x40000;
      if (v53)
        IOSurfaceGetPixelFormat(a2);
      v58 = (IOSurfaceGetPixelFormat(a2) >> 16);
      if (v58 <= 0x7F)
        v59 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v58 + 60) & 0x40000;
      else
        v59 = __maskrune(v58, 0x40000uLL);
      if (v59)
        IOSurfaceGetPixelFormat(a2);
      v60 = ((unsigned __int16)IOSurfaceGetPixelFormat(a2) >> 8);
      if (v60 <= 0x7F)
        v61 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v60 + 60) & 0x40000;
      else
        v61 = __maskrune(v60, 0x40000uLL);
      if (v61)
        IOSurfaceGetPixelFormat(a2);
      v62 = IOSurfaceGetPixelFormat(a2);
      if (v62 <= 0x7F)
        v63 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v62 + 60) & 0x40000;
      else
        v63 = __maskrune(v62, 0x40000uLL);
      if (v63)
        IOSurfaceGetPixelFormat(a2);
      x_log_();
    }
    else
    {
      v54 = x_log_category_utilities;
      v27 = a1 + 5;
      v32 = v80;
      if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEFAULT))
      {
LABEL_72:
        os_unfair_lock_lock(v27);
        hdr_processor_instance = CA::HDRProcessorInternal::get_or_create_hdr_processor_instance((uint64_t)a1, (__CFRunLoop *)2, (uint64_t)&v84);
        if (hdr_processor_instance)
        {
          v82[0] = MEMORY[0x1E0C809B0];
          v82[1] = 3221225472;
          v82[2] = ___ZN2CA20HDRProcessorInternal30configure_display_pipe_tonemapEP11__IOSurfacejPKNS_6Render17DisplayAttributesEPP12CGColorSpaceU13block_pointerFvP18IOMFBToneMapConfigEU13block_pointerFv13IOMFBCurveLocPK14IOMFBCurveDataEU13block_pointerFv14IOMFBICCMatLocPK16IOMFBColorMatrixE_block_invoke;
          v82[3] = &unk_1E159E418;
          v82[4] = a6;
          v82[5] = a7;
          v82[6] = a8;
          v47 = objc_msgSend(hdr_processor_instance, "iterateDisplayConfigWithType:operation:inputSurface:options:config:", 0, v79, a2, v32, v82);
          os_unfair_lock_unlock(v27);
          if (v47 == -17000)
          {

            v16 = 1;
            goto LABEL_87;
          }
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            v49 = x_log_category_utilities;
            if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134218496;
              *(_QWORD *)&buf[4] = v47;
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = a2;
              *(_WORD *)&buf[22] = 2048;
              *(_QWORD *)&buf[24] = v32;
              _os_log_impl(&dword_184457000, v49, OS_LOG_TYPE_ERROR, "HDRProcessor error (%ld) (src:%p, md:%p)", buf, 0x20u);
            }
          }

LABEL_86:
          v16 = 0;
LABEL_87:
          if (cf)
            CFRelease(cf);
          goto LABEL_89;
        }
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          v48 = x_log_category_utilities;
          if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_184457000, v48, OS_LOG_TYPE_ERROR, "Failed to create HDRProcessor for display", buf, 2u);
          }
        }

LABEL_82:
        os_unfair_lock_unlock(v27);
        goto LABEL_86;
      }
      ID = IOSurfaceGetID(a2);
      Width = IOSurfaceGetWidth(a2);
      Height = IOSurfaceGetHeight(a2);
      v55 = IOSurfaceGetPixelFormat(a2);
      v56 = HIBYTE(v55);
      if ((v55 & 0x80000000) != 0)
        v57 = __maskrune(v56, 0x40000uLL);
      else
        v57 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v56 + 60) & 0x40000;
      if (v57)
        v64 = IOSurfaceGetPixelFormat(a2) & 0xFF000000;
      else
        v64 = 0x20000000;
      v65 = (IOSurfaceGetPixelFormat(a2) >> 16);
      if (v65 <= 0x7F)
        v66 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v65 + 60) & 0x40000;
      else
        v66 = __maskrune(v65, 0x40000uLL);
      if (v66)
        v67 = IOSurfaceGetPixelFormat(a2) >> 16;
      else
        v67 = 32;
      v68 = ((unsigned __int16)IOSurfaceGetPixelFormat(a2) >> 8);
      if (v68 <= 0x7F)
        v69 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v68 + 60) & 0x40000;
      else
        v69 = __maskrune(v68, 0x40000uLL);
      if (v69)
        v70 = (unsigned __int16)IOSurfaceGetPixelFormat(a2) >> 8;
      else
        v70 = 32;
      v71 = IOSurfaceGetPixelFormat(a2);
      if (v71 <= 0x7F)
        v72 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v71 + 60) & 0x40000;
      else
        v72 = __maskrune(v71, 0x40000uLL);
      if (v72)
        v73 = (char)IOSurfaceGetPixelFormat(a2);
      else
        v73 = 32;
      *(_DWORD *)buf = 134220290;
      *(_QWORD *)&buf[4] = a1;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = ID;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = Width;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = Height;
      *(_WORD *)&buf[38] = 1024;
      v98 = v64 >> 24;
      v99 = 1024;
      v100 = v67;
      v101 = 1024;
      v102 = v70;
      v103 = 1024;
      v104 = v73;
      v105 = 1024;
      v106 = v79;
      v107 = 2080;
      v108 = v78;
      _os_log_impl(&dword_184457000, v54, OS_LOG_TYPE_DEFAULT, "HDRProcessor %p accelerator Display src surface 0x%x [%zu x %zu] (%c%c%c%c) operation 0x%x metadata: %s\n", buf, 0x4Eu);
    }
    v27 = a1 + 5;
    v32 = v80;
    goto LABEL_72;
  }
  return 0;
}

void sub_1846692D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,CFTypeRef cf)
{
  void *v26;

  if (cf)
    CFRelease(cf);
  objc_autoreleasePoolPop(v26);
  _Unwind_Resume(a1);
}

BOOL CA::HDRProcessorInternal::prefers_async(CA::HDRProcessorInternal *this, const CA::Render::Update *a2)
{
  unsigned int v2;
  _BOOL4 v4;

  v2 = *((_DWORD *)a2 + 120);
  if (CADeviceHasHardwareAcceleratedHDR::once != -1)
    dispatch_once(&CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_93);
  v4 = v2 < 2 || v2 == 3;
  return CADeviceHasHardwareAcceleratedHDR::has_capability && v4;
}

void load_hdrprocessing_symbols(void)
{
  void *v0;
  uint64_t *v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t *v71;
  uint64_t v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  uint64_t *v77;
  uint64_t v78;
  uint64_t *v79;
  uint64_t v80;
  uint64_t *v81;
  uint64_t v82;
  uint64_t *v83;
  uint64_t v84;
  uint64_t *v85;
  uint64_t v86;
  uint64_t *v87;
  uint64_t v88;
  uint64_t *v89;
  uint64_t v90;
  uint64_t *v91;
  uint64_t v92;
  uint64_t *v93;
  uint64_t v94;
  uint64_t *v95;
  uint64_t v96;
  uint64_t *v97;
  uint64_t v98;
  uint64_t *v99;
  uint64_t v100;
  uint64_t *v101;
  uint64_t v102;
  uint64_t *v103;
  uint64_t v104;
  uint64_t *v105;
  uint64_t v106;
  uint64_t *v107;
  uint64_t v108;
  uint64_t *v109;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v112;
  uint64_t *v113;
  uint64_t v114;
  uint64_t *v115;
  uint64_t v116;
  uint64_t *v117;
  uint64_t v118;
  uint64_t *v119;
  uint64_t v120;
  uint64_t *v121;
  uint64_t v122;
  uint64_t *v123;
  uint64_t v124;
  uint64_t *v125;
  uint64_t v126;
  uint64_t *v127;
  uint64_t v128;
  uint64_t *v129;
  uint64_t v130;
  uint64_t *v131;
  uint64_t v132;
  uint64_t *v133;
  uint64_t v134;
  uint64_t *v135;
  uint64_t v136;
  uint64_t *v137;
  uint64_t v138;
  uint64_t *v139;
  uint64_t v140;
  void *v141;

  v0 = dlopen("/System/Library/PrivateFrameworks/HDRProcessing.framework/HDRProcessing", 5);
  hdr_handle = (uint64_t)v0;
  if (v0)
  {
    v1 = (uint64_t *)dlsym(v0, "kHDRProcessingDolbyVisionRPUDataKey");
    if (v1)
      v2 = *v1;
    else
      v2 = 0;
    _kHDRProcessingDolbyVisionRPUDataKey = v2;
    v3 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingMaximumExtendedDynamicRangeColorComponentValueKey");
    if (v3)
      v4 = *v3;
    else
      v4 = 0;
    _kHDRProcessingMaximumExtendedDynamicRangeColorComponentValueKey = v4;
    v5 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingEDRFactorKey");
    if (v5)
      v6 = *v5;
    else
      v6 = 0;
    _kHDRProcessingEDRFactorKey = v6;
    v7 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingCurrentMaxPanelNitsKey");
    if (v7)
      v8 = *v7;
    else
      v8 = 0;
    _kHDRProcessingCurrentMaxPanelNitsKey = v8;
    v9 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingAmbientLightInNitsKey");
    if (v9)
      v10 = *v9;
    else
      v10 = 0;
    _kHDRProcessingAmbientLightInNitsKey = v10;
    v11 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDolbyVisionBackwardDMMaximumValueKey");
    if (v11)
      v12 = *v11;
    else
      v12 = 0;
    _kHDRProcessingDolbyVisionBackwardDMMaximumValueKey = v12;
    v13 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingUILayerScaleFactor");
    if (v13)
      v14 = *v13;
    else
      v14 = 0;
    _kHDRProcessingUILayerScaleFactor = v14;
    v15 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingSDRMaxBrightnessInNits");
    if (v15)
      v16 = *v15;
    else
      v16 = 0;
    _kHDRProcessingSDRMaxBrightnessInNits = v16;
    v17 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingSourceContentKey");
    if (v17)
      v18 = *v17;
    else
      v18 = 0;
    _kHDRProcessingSourceContentKey = v18;
    v19 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingSourceContentTypeKey");
    if (v19)
      v20 = *v19;
    else
      v20 = 0;
    _kHDRProcessingSourceContentTypeKey = v20;
    v21 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingSourceContentTypeDolbyVision");
    if (v21)
      v22 = *v21;
    else
      v22 = 0;
    _kHDRProcessingSourceContentTypeDolbyVision = v22;
    v23 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingSourceContentTypeHLG");
    if (v23)
      v24 = *v23;
    else
      v24 = 0;
    _kHDRProcessingSourceContentTypeHLG = v24;
    v25 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingSourceContentTypeHDR10");
    if (v25)
      v26 = *v25;
    else
      v26 = 0;
    _kHDRProcessingSourceContentTypeHDR10 = v26;
    v27 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingSourceContentBitDepthKey");
    if (v27)
      v28 = *v27;
    else
      v28 = 0;
    _kHDRProcessingSourceContentBitDepthKey = v28;
    v29 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingSourceContentSDRMaxBrightnessInNitsKey");
    if (v29)
      v30 = *v29;
    else
      v30 = 0;
    _kHDRProcessingSourceContentSDRMaxBrightnessInNitsKey = v30;
    v31 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingSourceContentHDRMaxBrightnessInNitsKey");
    if (v31)
      v32 = *v31;
    else
      v32 = 0;
    _kHDRProcessingSourceContentHDRMaxBrightnessInNitsKey = v32;
    v33 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDestinationDisplayTypeDolbyVisionTV");
    if (v33)
      v34 = *v33;
    else
      v34 = 0;
    _kHDRProcessingDestinationDisplayTypeDolbyVisionTV = v34;
    v35 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDestinationDisplayTypeLowLatencyDolbyVisionTV");
    if (v35)
      v36 = *v35;
    else
      v36 = 0;
    _kHDRProcessingDestinationDisplayTypeLowLatencyDolbyVisionTV = v36;
    v37 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDestinationDisplayTypeHDR10TV");
    if (v37)
      v38 = *v37;
    else
      v38 = 0;
    _kHDRProcessingDestinationDisplayTypeHDR10TV = v38;
    v39 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDestinationDisplayTypeInternalPanel");
    if (v39)
      v40 = *v39;
    else
      v40 = 0;
    _kHDRProcessingDestinationDisplayTypeInternalPanel = v40;
    v41 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDestinationDisplayTypeInternalPanelOLED");
    if (v41)
      v42 = *v41;
    else
      v42 = 0;
    _kHDRProcessingDestinationDisplayTypeInternalPanelOLED = v42;
    v43 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDestinationDisplayTypeInternalPanelLCD");
    if (v43)
      v44 = *v43;
    else
      v44 = 0;
    _kHDRProcessingDestinationDisplayTypeInternalPanelLCD = v44;
    v45 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDestinationDisplayTypeInternalPanel0DBL");
    if (v45)
      v46 = *v45;
    else
      v46 = 0;
    _kHDRProcessingDestinationDisplayTypeInternalPanel0DBL = v46;
    v47 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDestinationDisplayTypeInternalPanel2DBL");
    if (v47)
      v48 = *v47;
    else
      v48 = 0;
    _kHDRProcessingDestinationDisplayTypeInternalPanel2DBL = v48;
    v49 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDestinationDisplayTypeInternalPanelMac");
    if (v49)
      v50 = *v49;
    else
      v50 = 0;
    _kHDRProcessingDestinationDisplayTypeInternalPanelMac = v50;
    v51 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDestinationDisplayTypeReferenceDisplay");
    if (v51)
      v52 = *v51;
    else
      v52 = 0;
    _kHDRProcessingDestinationDisplayTypeReferenceDisplay = v52;
    v53 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDestinationDisplayTypeKey");
    if (v53)
      v54 = *v53;
    else
      v54 = 0;
    _kHDRProcessingDestinationDisplayTypeKey = v54;
    v55 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDestinationDisplayTypeSDRTV");
    if (v55)
      v56 = *v55;
    else
      v56 = 0;
    _kHDRProcessingDestinationDisplayTypeSDRTV = v56;
    v57 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayDiagonalSizeInInchesKey");
    if (v57)
      v58 = *v57;
    else
      v58 = 0;
    _kHDRProcessingDisplayDiagonalSizeInInchesKey = v58;
    v59 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayMaximumBrightnessInNitsKey");
    if (v59)
      v60 = *v59;
    else
      v60 = 0;
    _kHDRProcessingDisplayMaximumBrightnessInNitsKey = v60;
    v61 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayAverageBrightnessInNitsKey");
    if (v61)
      v62 = *v61;
    else
      v62 = 0;
    _kHDRProcessingDisplayAverageBrightnessInNitsKey = v62;
    v63 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayMinimumBrightnessInNitsKey");
    if (v63)
      v64 = *v63;
    else
      v64 = 0;
    _kHDRProcessingDisplayMinimumBrightnessInNitsKey = v64;
    v65 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayKey");
    if (v65)
      v66 = *v65;
    else
      v66 = 0;
    _kHDRProcessingDisplayKey = v66;
    v67 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayContrastRatioKey");
    if (v67)
      v68 = *v67;
    else
      v68 = 0;
    _kHDRProcessingDisplayContrastRatioKey = v68;
    v69 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayDolbyVisionDMVersionKey");
    if (v69)
      v70 = *v69;
    else
      v70 = 0;
    _kHDRProcessingDisplayDolbyVisionDMVersionKey = v70;
    v71 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingForwardDMDictinaryKey");
    if (v71)
      v72 = *v71;
    else
      v72 = 0;
    _kHDRProcessingForwardDMDictinaryKey = v72;
    v73 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDolbyVisionBackwardDMDictinary");
    if (v73)
      v74 = *v73;
    else
      v74 = 0;
    _kHDRProcessingDolbyVisionBackwardDMDictinary = v74;
    v75 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayColorFormatKey");
    if (v75)
      v76 = *v75;
    else
      v76 = 0;
    _kHDRProcessingDisplayColorFormatKey = v76;
    v77 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayColorFormat_IPT422_12BITS");
    if (v77)
      v78 = *v77;
    else
      v78 = 0;
    _kHDRProcessingDisplayColorFormat_IPT422_12BITS = v78;
    v79 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayColorFormat_YUV422_12BITS_DP");
    if (v79)
      v80 = *v79;
    else
      v80 = 0;
    _kHDRProcessingDisplayColorFormat_YUV422_12BITS_DP = v80;
    v81 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayColorFormat_YUV422_12BITS_HDMI");
    if (v81)
      v82 = *v81;
    else
      v82 = 0;
    _kHDRProcessingDisplayColorFormat_YUV422_12BITS_HDMI = v82;
    v83 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayChromaticityBx");
    if (v83)
      v84 = *v83;
    else
      v84 = 0;
    _kHDRProcessingDisplayChromaticityBx = v84;
    v85 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayChromaticityBy");
    if (v85)
      v86 = *v85;
    else
      v86 = 0;
    _kHDRProcessingDisplayChromaticityBy = v86;
    v87 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayChromaticityGx");
    if (v87)
      v88 = *v87;
    else
      v88 = 0;
    _kHDRProcessingDisplayChromaticityGx = v88;
    v89 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayChromaticityGy");
    if (v89)
      v90 = *v89;
    else
      v90 = 0;
    _kHDRProcessingDisplayChromaticityGy = v90;
    v91 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayChromaticityRx");
    if (v91)
      v92 = *v91;
    else
      v92 = 0;
    _kHDRProcessingDisplayChromaticityRx = v92;
    v93 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayChromaticityRy");
    if (v93)
      v94 = *v93;
    else
      v94 = 0;
    _kHDRProcessingDisplayChromaticityRy = v94;
    v95 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayChromaticityWx");
    if (v95)
      v96 = *v95;
    else
      v96 = 0;
    _kHDRProcessingDisplayChromaticityWx = v96;
    v97 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayChromaticityWy");
    if (v97)
      v98 = *v97;
    else
      v98 = 0;
    _kHDRProcessingDisplayChromaticityWy = v98;
    v99 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplaySupportsAmbientAdaptationKey");
    if (v99)
      v100 = *v99;
    else
      v100 = 0;
    _kHDRProcessingDisplaySupportsAmbientAdaptationKey = v100;
    v101 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingOperationEnum");
    if (v101)
      v102 = *v101;
    else
      v102 = 0;
    _kHDRProcessingOperationEnum = v102;
    v103 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayPipelineCompensationType");
    if (v103)
      v104 = *v103;
    else
      v104 = 0;
    _kHDRProcessingDisplayPipelineCompensationType = v104;
    v105 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayPipelineCompensationTypeNone");
    if (v105)
      v106 = *v105;
    else
      v106 = 0;
    _kHDRProcessingDisplayPipelineCompensationTypeNone = v106;
    v107 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayPipelineCompensationTypePurePower");
    if (v107)
      v108 = *v107;
    else
      v108 = 0;
    _kHDRProcessingDisplayPipelineCompensationTypePurePower = v108;
    v109 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayPipelineCompensationTypeHeadroomDependent");
    if (v109)
      v110 = *v109;
    else
      v110 = 0;
    _kHDRProcessingDisplayPipelineCompensationTypeHeadroomDependent = v110;
    v111 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingOrientationKey");
    if (v111)
      v112 = *v111;
    else
      v112 = 0;
    _kHDRProcessingOrientationKey = v112;
    v113 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayAveragePixelThresholdKey");
    if (v113)
      v114 = *v113;
    else
      v114 = 0;
    _kHDRProcessingDisplayAveragePixelThresholdKey = v114;
    v115 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayAveragePixelWeightR");
    if (v115)
      v116 = *v115;
    else
      v116 = 0;
    _kHDRProcessingDisplayAveragePixelWeightR = v116;
    v117 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayAveragePixelWeightG");
    if (v117)
      v118 = *v117;
    else
      v118 = 0;
    _kHDRProcessingDisplayAveragePixelWeightG = v118;
    v119 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplayAveragePixelWeightB");
    if (v119)
      v120 = *v119;
    else
      v120 = 0;
    _kHDRProcessingDisplayAveragePixelWeightB = v120;
    v121 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDisplaySustainedBrightnessInNitsKey");
    if (v121)
      v122 = *v121;
    else
      v122 = 0;
    _kHDRProcessingDisplaySustainedBrightnessInNitsKey = v122;
    v123 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDestinationKey");
    if (v123)
      v124 = *v123;
    else
      v124 = 0;
    _kHDRProcessingDestinationKey = v124;
    v125 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingPixelFormatKey");
    if (v125)
      v126 = *v125;
    else
      v126 = 0;
    _kHDRProcessingPixelFormatKey = v126;
    v127 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingSurfaceAttributesKey");
    if (v127)
      v128 = *v127;
    else
      v128 = 0;
    _kHDRProcessingSurfaceAttributesKey = v128;
    v129 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingApiInterfaceVersionKey");
    if (v129)
      v130 = *v129;
    else
      v130 = 0;
    _kHDRProcessingApiInterfaceVersionKey = v130;
    v131 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingVersion");
    if (v131)
      v132 = *v131;
    else
      v132 = 0;
    _kHDRProcessingVersion = v132;
    v133 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingDolbyVisionHDMIDataKey");
    if (v133)
      v134 = *v133;
    else
      v134 = 0;
    _kHDRProcessingDolbyVisionHDMIDataKey = v134;
    v135 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingEdrRangeTypeNormalized");
    if (v135)
      v136 = *v135;
    else
      v136 = 0;
    _kHDRProcessingEdrRangeTypeNormalized = v136;
    v137 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingEdrRangeTypeNonNormalized");
    if (v137)
      v138 = *v137;
    else
      v138 = 0;
    _kHDRProcessingEdrRangeTypeNonNormalized = v138;
    v139 = (uint64_t *)dlsym((void *)hdr_handle, "kHDRProcessingEdrRangeTypeKey");
    if (v139)
      v140 = *v139;
    else
      v140 = 0;
    _kHDRProcessingEdrRangeTypeKey = v140;
    if (_kHDRProcessingVersion)
      _hdrp_version = CFStringGetIntValue((CFStringRef)_kHDRProcessingVersion);
    v141 = (void *)MEMORY[0x186DBE2E4]();
    hdr_processor_class = (uint64_t)(id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB34D0], "bundleWithPath:", CFSTR("/System/Library/PrivateFrameworks/HDRProcessing.framework")), "classNamed:", CFSTR("HDRProcessor"));
    _hdrp_supports_new_init = objc_msgSend((id)hdr_processor_class, "instancesRespondToSelector:", sel_initProcessingEngine_config_);
    _hdrp_supports_pixel_format_query = objc_msgSend((id)hdr_processor_class, "instancesRespondToSelector:", sel_isFormatSupported_inputFormat_outputFormat_device_);
    objc_autoreleasePoolPop(v141);
  }
}

uint64_t CA::HDRProcessorInternal::output_pixel_format(uint64_t a1, uint64_t a2, unsigned int a3, IOSurfaceRef buffer, int a5)
{
  uint64_t v10;
  CFTypeRef v11;
  CA::Render *PixelFormat;
  int v13;
  _BYTE *v14;
  unsigned int v15;
  unsigned int v16;
  BOOL v17;
  unsigned int v18;

  if (initialized[0] != -1)
    dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
  if (!dword_1ECDC6A04)
  {
    if (CADeviceSupportsToneMapAcceleratorSwitching::once[0] != -1)
      dispatch_once(CADeviceSupportsToneMapAcceleratorSwitching::once, &__block_literal_global_179);
    v10 = 1380411457;
    if (CADeviceSupportsToneMapAcceleratorSwitching::accelerator_switching)
    {
      if (CADeviceHasHardwareAcceleratedHDR::once != -1)
        dispatch_once(&CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_93);
      if (a3 == 2 && CADeviceHasHardwareAcceleratedHDR::has_capability)
      {
        v11 = IOSurfaceCopyValue(buffer, (CFStringRef)_kHDRProcessingDolbyVisionRPUDataKey);
        if (!v11)
          return v10;
        CFRelease(v11);
      }
    }
    PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(buffer);
    if (CADeviceHasHardwareAcceleratedHDR::once != -1)
      dispatch_once(&CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_93);
    v13 = CADeviceHasHardwareAcceleratedHDR::has_capability;
    if (CADeviceHasHardwareAcceleratedHDR::has_capability)
    {
      v13 = a3 < 2;
      if (a3 == 3)
        v13 = 1;
      *(_BYTE *)(a1 + 89) = v13;
      v14 = (_BYTE *)(a1 + 89);
      if (a3 <= 3 && a3 != 2)
      {
        if ((_DWORD)PixelFormat == 642934849 || (_DWORD)PixelFormat == 1380411457)
          return v10;
        if ((_DWORD)PixelFormat == 2033463606)
          return 2033463606;
      }
    }
    else
    {
      *(_BYTE *)(a1 + 89) = 0;
      v14 = (_BYTE *)(a1 + 89);
    }
    v15 = *(_DWORD *)(a2 + 60);
    if (v15 - 2 >= 5)
    {
      if (v15 > 1)
        return 0;
      if (!v13)
        return 1999843442;
      v10 = 1882468912;
      if ((CA::Render::fourcc_is_420(PixelFormat) & 1) == 0)
      {
        if ((CA::Render::fourcc_is_422(PixelFormat) & 1) != 0)
        {
          return 1882468914;
        }
        else
        {
          v10 = 1882469428;
          if ((CA::Render::fourcc_is_444(PixelFormat) & 1) == 0)
          {
            if (CA::Render::fourcc_is_rgb(PixelFormat))
              return 1882469428;
            else
              return 1882468912;
          }
        }
      }
      return v10;
    }
    if (CADeviceIsVirtualized::once[0] != -1)
      dispatch_once(CADeviceIsVirtualized::once, &__block_literal_global_204);
    if (!CADeviceIsVirtualized::is_virtualized)
    {
      if (!*v14)
        return 1919365992;
      if (CADevicePrefersHDR444::once != -1)
        dispatch_once(&CADevicePrefersHDR444::once, &__block_literal_global_280);
      if (CADevicePrefersHDR444::b)
      {
LABEL_33:
        if (a5)
          return 1886680628;
        else
          return 1953903668;
      }
      if (CA::Render::fourcc_is_420(PixelFormat))
      {
        v16 = 1886680624;
        v17 = a5 == 0;
        v18 = 1953903152;
      }
      else
      {
        if (!CA::Render::fourcc_is_422(PixelFormat))
        {
          v10 = 1953903152;
          if ((CA::Render::fourcc_is_444(PixelFormat) & 1) == 0
            && !CA::Render::fourcc_is_rgb(PixelFormat))
          {
            return v10;
          }
          goto LABEL_33;
        }
        v16 = 1886680626;
        v18 = 1953903154;
        v17 = a5 == 0;
      }
      if (v17)
        return v18;
      else
        return v16;
    }
    return v10;
  }
  return CA::Render::fourcc_compressed_of_type((CA::Render *)dword_1ECDC6A04, 0, 0);
}

void CA::HDRProcessorInternal::get_config(uint64_t a1, __IOSurface *a2, __IOSurface *a3, uint64_t a4, _DWORD *a5, int a6, _BYTE *a7, CA::Render *PixelFormat)
{
  __IOSurface *v15;
  int v16;
  CA::Render *v17;
  int v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned __int16 v22;
  unsigned int v23;
  int BulkAttachments;
  CFTypeRef v25;
  int v26;
  NSObject *v27;
  uint64_t *v28;
  int v29;
  uint64_t v30;
  uint8_t buf[8];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (a2)
    v15 = a2;
  else
    v15 = a3;
  *(_DWORD *)a1 = IOSurfaceGetWidth(v15);
  *(_DWORD *)(a1 + 4) = IOSurfaceGetHeight(v15);
  if (a2)
    PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(a2);
  *(_DWORD *)(a1 + 16) = (_DWORD)PixelFormat;
  v30 = *MEMORY[0x1E0CA8D88];
  *(_QWORD *)(a1 + 24) = *MEMORY[0x1E0CA8D88];
  *a5 = 3;
  v16 = CA::Render::fourcc_compressed_of_type(PixelFormat, 0, 0);
  v17 = (CA::Render *)IOSurfaceGetPixelFormat(a3);
  v18 = CA::Render::fourcc_compressed_of_type(v17, 0, 0);
  v19 = *(_DWORD *)(a4 + 60);
  if (v19 == 4)
  {
    v20 = *(float *)(a4 + 4);
  }
  else
  {
    v20 = 100;
    if (v19 == 1 && *(_BYTE *)(a4 + 50))
    {
      if (initialized[0] != -1)
      {
        v29 = v18;
        dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
        v18 = v29;
      }
      v20 = *(float *)&dword_1ECDC698C;
      if (!*(float *)&dword_1ECDC698C)
        v20 = 200;
    }
  }
  *(_DWORD *)(a1 + 12) = v20;
  LOBYTE(v21) = 13;
  if (v16 <= 1919365991)
  {
    if (v16 <= 1882468913)
    {
      if (v16 != 1380411457)
      {
        if (v16 != 1815162994)
        {
          v22 = 12848;
          goto LABEL_29;
        }
        goto LABEL_30;
      }
      *(_QWORD *)(a1 + 24) = *MEMORY[0x1E0CA8D98];
      LOBYTE(v21) = 8;
      goto LABEL_47;
    }
    if ((v16 - 1886680624) > 4 || ((1 << (v16 - 48)) & 0x15) == 0)
    {
      if (v16 != 1882468914)
      {
        v22 = 13364;
LABEL_29:
        if (v16 != (v22 | 0x70340000))
          goto LABEL_47;
      }
LABEL_30:
      *(_QWORD *)(a1 + 24) = *MEMORY[0x1E0CA8D98];
      goto LABEL_47;
    }
    goto LABEL_39;
  }
  if (v16 > 1953903667)
  {
    if (v16 > 2016686639)
    {
      if (v16 != 2016686640)
      {
        if (v16 != 2033463606)
          goto LABEL_47;
        v23 = *(_DWORD *)(a4 + 60);
        if (v23 <= 1)
          goto LABEL_30;
        goto LABEL_40;
      }
    }
    else if (v16 != 1953903668)
    {
      if (v16 == 1999843442 && v18 == 1380411457)
        *a5 = 2;
      goto LABEL_47;
    }
LABEL_39:
    v23 = *(_DWORD *)(a4 + 60);
LABEL_40:
    *(_QWORD *)(a1 + 24) = *MEMORY[0x1E0CA8D80];
    if ((v23 > 6 || ((1 << v23) & 0x73) == 0) && !*(_BYTE *)(a4 + 50))
      *a5 = 1;
    LOBYTE(v21) = 16;
    if (*(_BYTE *)(a4 + 53) && v18 == 1380411457)
      *a5 = 4;
    goto LABEL_47;
  }
  if (v16 == 1919365992)
  {
    LOBYTE(v21) = 8;
    goto LABEL_47;
  }
  if (v16 == 1953903152 || v16 == 1953903154)
    goto LABEL_39;
LABEL_47:
  BulkAttachments = IOSurfaceGetBulkAttachments();
  if (a6)
  {
    *(_QWORD *)buf = 116;
    if (!IOSurfaceGetBulkAttachments())
      LOBYTE(v21) = 0;
  }
  else if (*(_BYTE *)(a4 + 54))
  {
    if (!BulkAttachments)
    {
      v25 = IOSurfaceCopyValue(a3, (CFStringRef)_kHDRProcessingDolbyVisionRPUDataKey);
      if (v25)
        CFRelease(v25);
    }
  }
  if (initialized[0] != -1)
    dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
  if (*(float *)&dword_1ECDC69FC)
  {
    switch(*(float *)&dword_1ECDC69FC)
    {
      case 1u:
        goto LABEL_79;
      case 2u:
      case 3u:
      case 4u:
      case 7u:
      case 8u:
      case 0xAu:
        break;
      case 5u:
        v28 = (uint64_t *)MEMORY[0x1E0CA8D78];
        goto LABEL_78;
      case 6u:
        v28 = (uint64_t *)MEMORY[0x1E0CA8DA0];
        goto LABEL_78;
      case 9u:
        v28 = (uint64_t *)MEMORY[0x1E0CA8D80];
        goto LABEL_78;
      case 0xBu:
        v28 = (uint64_t *)MEMORY[0x1E0CA8D70];
        goto LABEL_78;
      case 0xCu:
        v28 = (uint64_t *)MEMORY[0x1E0CA8D98];
        goto LABEL_78;
      default:
        if (*(float *)&dword_1ECDC69FC != 22)
          break;
        v28 = (uint64_t *)MEMORY[0x1E0CA8D90];
LABEL_78:
        v30 = *v28;
LABEL_79:
        *(_QWORD *)(a1 + 24) = v30;
        break;
    }
  }
  if (*(float *)&dword_1ECDC6A00)
  {
    v21 = *(float *)&dword_1ECDC6A00;
    if (!a2)
      goto LABEL_67;
  }
  else if (!a2)
  {
    goto LABEL_67;
  }
  v26 = IOSurfaceSetBulkAttachments2();
  if (v26)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v27 = x_log_category_utilities;
      if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v26;
        _os_log_impl(&dword_184457000, v27, OS_LOG_TYPE_ERROR, "Error setting bulk attachments: 0x%x", buf, 8u);
      }
    }
  }
LABEL_67:
  *a7 = v21;
}

void *CA::HDRProcessorInternal::get_or_create_hdr_processor_instance(uint64_t a1, __CFRunLoop *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v7;
  void *result;
  int v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  _BOOL4 v15;
  BOOL v16;
  unsigned int v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;

  v3 = a1 + 96;
  v4 = a1 + 48;
  if ((_DWORD)a2 == 2)
    v4 = a1 + 112;
  if ((_DWORD)a2 != 1)
    v3 = v4;
  if (_hdrp_supports_new_init)
    v5 = a1 + 40;
  else
    v5 = v3;
  if (!a3)
    __assert_rtn("get_or_create_hdr_processor_instance", "CAHDRProcessing.mm", 1019, "config");
  v7 = (int)a2;
  result = *(void **)v5;
  if (!*(_QWORD *)v5)
  {
LABEL_15:

    if (!v7 || _hdrp_supports_new_init)
    {
      CA::HDRProcessorInternal::initialize_metal((CA::HDRProcessorInternal *)a1);
      if (!*(_QWORD *)(a1 + 24))
      {
        result = 0;
        *(_QWORD *)v5 = 0;
        return result;
      }
      if (_hdrp_supports_new_init)
        v14 = *(_QWORD *)(a1 + 24);
      else
        v14 = 0;
    }
    else
    {
      v14 = 0;
    }
    result = (void *)CA::create_hdrprocessor(v14, a3);
    *(_QWORD *)v5 = result;
    v12 = *(_DWORD *)(a3 + 36);
    goto LABEL_23;
  }
  v10 = *(_DWORD *)(a1 + 120);
  v11 = 2;
  if (v10 != 2)
    v11 = v10 == 1;
  v12 = *(_DWORD *)(a3 + 36);
  if (v10 == v12)
  {
    v13 = a1 + 40 * v11;
    if (*(_DWORD *)(v13 + 144) == *(_DWORD *)(a3 + 16) && *(_QWORD *)(v13 + 152) == *(_QWORD *)(a3 + 24))
      return result;
    goto LABEL_15;
  }
LABEL_23:
  v15 = v12 == 1;
  v16 = v12 == 2;
  v17 = 2;
  if (!v16)
    v17 = v15;
  v18 = a1 + 40 * v17;
  v19 = *(_OWORD *)a3;
  v20 = *(_OWORD *)(a3 + 16);
  *(_QWORD *)(v18 + 160) = *(_QWORD *)(a3 + 32);
  *(_OWORD *)(v18 + 128) = v19;
  *(_OWORD *)(v18 + 144) = v20;
  LODWORD(v18) = *(_DWORD *)(a3 + 36);
  *(_DWORD *)(a1 + 120) = v18;
  if ((_DWORD)v18 == 1 && *(_BYTE *)(a1 + 89) && !*(_QWORD *)(a1 + 104))
  {
    if (CA::WindowServer::accelerator_runloop(void)::once != -1)
      dispatch_once(&CA::WindowServer::accelerator_runloop(void)::once, &__block_literal_global_5307);
    *(_QWORD *)(a1 + 104) = CA::IOSAManager::create_new_iosa_manager((CA::IOSAManager *)CA::WindowServer::accelerator_runloop(void)::runloop, a2);
    return *(void **)v5;
  }
  return result;
}

void *forward_display_params_from_attributes(uint64_t a1, int a2)
{
  uint64_t v4;
  int v5;
  void *v6;
  uint64_t *v7;
  double v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  double v16;
  uint64_t v17;
  double v18;
  uint64_t v19;
  double v20;
  uint64_t v21;
  double v22;
  uint64_t v23;
  double v24;
  uint64_t v25;
  double v26;
  uint64_t v27;
  double v28;
  uint64_t v29;
  uint64_t v30;
  double v31;
  uint64_t v32;
  double v33;
  uint64_t v34;
  double v35;
  uint64_t v36;
  uint64_t v37;

  v4 = objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v5 = *(_DWORD *)(a1 + 60);
  v6 = (void *)v4;
  v7 = &_kHDRProcessingDestinationDisplayTypeSDRTV;
  switch(v5)
  {
    case 0:
      if (_hdrp_version <= 0)
      {
        if (!_kHDRProcessingDestinationDisplayTypeInternalPanelLCD)
          goto LABEL_20;
        if (CADeviceHasLCDPanel::once[0] != -1)
          dispatch_once(CADeviceHasLCDPanel::once, &__block_literal_global_69);
        if (CADeviceHasLCDPanel::has_lcd | BYTE11(xmmword_1ECDC6A90))
          v7 = &_kHDRProcessingDestinationDisplayTypeInternalPanelLCD;
        else
LABEL_20:
          v7 = &_kHDRProcessingDestinationDisplayTypeInternalPanel;
      }
      else
      {
        if (!_kHDRProcessingDestinationDisplayTypeInternalPanelLCD)
          goto LABEL_14;
        if (CADeviceHasLCDPanel::once[0] != -1)
          dispatch_once(CADeviceHasLCDPanel::once, &__block_literal_global_69);
        if (CADeviceHasLCDPanel::has_lcd | BYTE11(xmmword_1ECDC6A90))
          v7 = &_kHDRProcessingDestinationDisplayTypeInternalPanel0DBL;
        else
LABEL_14:
          v7 = &_kHDRProcessingDestinationDisplayTypeInternalPanelOLED;
      }
      goto LABEL_21;
    case 1:
      goto LABEL_21;
    case 2:
      v7 = &_kHDRProcessingDestinationDisplayTypeHDR10TV;
      goto LABEL_21;
    case 3:
      v7 = &_kHDRProcessingDestinationDisplayTypeDolbyVisionTV;
      goto LABEL_21;
    case 4:
      v7 = &_kHDRProcessingDestinationDisplayTypeLowLatencyDolbyVisionTV;
      goto LABEL_21;
    case 5:
    case 6:
      if (_hdrp_version >= 1)
        v7 = &_kHDRProcessingDestinationDisplayTypeInternalPanel2DBL;
      else
        v7 = &_kHDRProcessingDestinationDisplayTypeReferenceDisplay;
LABEL_21:
      objc_msgSend(v6, "setObject:forKeyedSubscript:", *v7, _kHDRProcessingDestinationDisplayTypeKey);
      if (_kHDRProcessingEdrRangeTypeKey)
        v9 = a2 == 0;
      else
        v9 = 1;
      if (v9)
        goto LABEL_27;
      if (v5 || !*(_BYTE *)(a1 + 57))
      {
        objc_msgSend(v6, "setObject:forKeyedSubscript:", _kHDRProcessingEdrRangeTypeNonNormalized);
LABEL_27:
        switch(v5)
        {
          case 0:
          case 6:
            goto LABEL_38;
          case 1:
          case 5:
            if (_hdrp_version >= 1)
              goto LABEL_41;
            goto LABEL_35;
          case 2:
            goto LABEL_34;
          case 3:
          case 4:
            if (*(int *)(a1 + 124) >= 1 && _kHDRProcessingDisplayDolbyVisionDMVersionKey)
            {
              v10 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:");
              objc_msgSend(v6, "setObject:forKeyedSubscript:", v10, _kHDRProcessingDisplayDolbyVisionDMVersionKey);
            }
LABEL_34:
            LODWORD(v8) = *(_DWORD *)a1;
            v11 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v8);
            objc_msgSend(v6, "setObject:forKeyedSubscript:", v11, _kHDRProcessingDisplayMinimumBrightnessInNitsKey);
            LODWORD(v12) = *(_DWORD *)(a1 + 4);
            v13 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v12);
            objc_msgSend(v6, "setObject:forKeyedSubscript:", v13, _kHDRProcessingDisplayMaximumBrightnessInNitsKey);
            objc_msgSend(v6, "setObject:forKeyedSubscript:", &unk_1E15D6F48, _kHDRProcessingDisplayAverageBrightnessInNitsKey);
            if (_hdrp_version > 0)
              goto LABEL_41;
LABEL_35:
            v14 = &unk_1E15D6F18;
            break;
          default:
            return 0;
        }
        goto LABEL_40;
      }
      objc_msgSend(v6, "setObject:forKeyedSubscript:", _kHDRProcessingEdrRangeTypeNormalized);
LABEL_38:
      if (_hdrp_version < 1)
      {
        v14 = &unk_1E15D6F30;
LABEL_40:
        objc_msgSend(v6, "setObject:forKeyedSubscript:", v14, _kHDRProcessingDisplayDiagonalSizeInInchesKey);
      }
LABEL_41:
      if (*(_BYTE *)(a1 + 100) && _kHDRProcessingDisplayChromaticityBx)
      {
        LODWORD(v8) = *(_DWORD *)(a1 + 84);
        v15 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v8);
        objc_msgSend(v6, "setObject:forKeyedSubscript:", v15, _kHDRProcessingDisplayChromaticityBx);
        LODWORD(v16) = *(_DWORD *)(a1 + 88);
        v17 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v16);
        objc_msgSend(v6, "setObject:forKeyedSubscript:", v17, _kHDRProcessingDisplayChromaticityBy);
        LODWORD(v18) = *(_DWORD *)(a1 + 76);
        v19 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v18);
        objc_msgSend(v6, "setObject:forKeyedSubscript:", v19, _kHDRProcessingDisplayChromaticityGx);
        LODWORD(v20) = *(_DWORD *)(a1 + 80);
        v21 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v20);
        objc_msgSend(v6, "setObject:forKeyedSubscript:", v21, _kHDRProcessingDisplayChromaticityGy);
        LODWORD(v22) = *(_DWORD *)(a1 + 68);
        v23 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v22);
        objc_msgSend(v6, "setObject:forKeyedSubscript:", v23, _kHDRProcessingDisplayChromaticityRx);
        LODWORD(v24) = *(_DWORD *)(a1 + 72);
        v25 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v24);
        objc_msgSend(v6, "setObject:forKeyedSubscript:", v25, _kHDRProcessingDisplayChromaticityRy);
        LODWORD(v26) = *(_DWORD *)(a1 + 92);
        v27 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v26);
        objc_msgSend(v6, "setObject:forKeyedSubscript:", v27, _kHDRProcessingDisplayChromaticityWx);
        LODWORD(v28) = *(_DWORD *)(a1 + 96);
        v29 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v28);
        objc_msgSend(v6, "setObject:forKeyedSubscript:", v29, _kHDRProcessingDisplayChromaticityWy);
      }
      if (_kHDRProcessingDisplayAveragePixelThresholdKey)
      {
        if (_kHDRProcessingDisplayAveragePixelWeightR)
        {
          if (_kHDRProcessingDisplayAveragePixelWeightG)
          {
            if (_kHDRProcessingDisplayAveragePixelWeightB)
            {
              if (*(float *)(a1 + 104) != 1.0)
              {
                v30 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:");
                objc_msgSend(v6, "setObject:forKeyedSubscript:", v30, _kHDRProcessingDisplayAveragePixelThresholdKey);
                LODWORD(v31) = *(_DWORD *)(a1 + 108);
                v32 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v31);
                objc_msgSend(v6, "setObject:forKeyedSubscript:", v32, _kHDRProcessingDisplayAveragePixelWeightR);
                LODWORD(v33) = *(_DWORD *)(a1 + 112);
                v34 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v33);
                objc_msgSend(v6, "setObject:forKeyedSubscript:", v34, _kHDRProcessingDisplayAveragePixelWeightG);
                LODWORD(v35) = *(_DWORD *)(a1 + 116);
                v36 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v35);
                objc_msgSend(v6, "setObject:forKeyedSubscript:", v36, _kHDRProcessingDisplayAveragePixelWeightB);
                if (*(float *)(a1 + 120) > 0.0)
                {
                  if (_kHDRProcessingDisplaySustainedBrightnessInNitsKey)
                  {
                    v37 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:");
                    objc_msgSend(v6, "setObject:forKeyedSubscript:", v37, _kHDRProcessingDisplaySustainedBrightnessInNitsKey);
                  }
                }
              }
            }
          }
        }
      }
      return v6;
    default:
      return 0;
  }
}

void ___ZN2CA20HDRProcessorInternal30configure_display_pipe_tonemapEP11__IOSurfacejPKNS_6Render17DisplayAttributesEPP12CGColorSpaceU13block_pointerFvP18IOMFBToneMapConfigEU13block_pointerFv13IOMFBCurveLocPK14IOMFBCurveDataEU13block_pointerFv14IOMFBICCMatLocPK16IOMFBColorMatrixE_block_invoke(_QWORD *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  NSObject *v6;
  uint8_t buf[4];
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a2 == 2)
  {
    v5 = a1[5];
LABEL_7:
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 16))(v5, a3, a4);
    return;
  }
  if (a2 == 1)
  {
    v5 = a1[6];
    goto LABEL_7;
  }
  if (a2)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v6 = x_log_category_utilities;
      if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        v8 = a2;
        _os_log_impl(&dword_184457000, v6, OS_LOG_TYPE_ERROR, "unexpected HDRProcessingDisplayConfigType: %u", buf, 8u);
      }
    }
  }
  else
  {
    (*(void (**)(_QWORD, uint64_t))(a1[4] + 16))(a1[4], a4);
  }
}

void CA::HDRProcessorInternal::initialize_metal(CA::HDRProcessorInternal *this)
{
  id v2;
  void *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;

  if (!*((_BYTE *)this + 88))
  {
    *((_BYTE *)this + 88) = 1;
    v2 = MTLCreateSystemDefaultDevice();
    *((_QWORD *)this + 3) = v2;
    v3 = (void *)objc_msgSend(v2, "newCommandQueue");
    *((_QWORD *)this + 4) = v3;
    objc_msgSend(v3, "setLabel:", CFSTR("com.apple.QuartzCore-HDRProcessing"));
    if (CA::_root_queue_once != -1)
      dispatch_once(&CA::_root_queue_once, &__block_literal_global_18816);
    v4 = CA::_root_queue;
    if (CA::_root_queue)
    {
      v5 = dispatch_queue_create_with_target_V2("com.apple.coreanimation.hdr_submission", 0, (dispatch_queue_t)CA::_root_queue);
      v6 = dispatch_queue_create_with_target_V2("com.apple.coreanimation.hdr_completion", 0, v4);
      objc_msgSend(*((id *)this + 4), "setSubmissionQueue:", v5);
      objc_msgSend(*((id *)this + 4), "setCompletionQueue:", v6);
      dispatch_release(v5);
      dispatch_release(v6);
    }
  }
}

uint64_t CA::create_hdrprocessor(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  id v6;

  if (_hdrp_supports_new_init)
  {
    result = objc_msgSend(objc_alloc((Class)hdr_processor_class), "initProcessingEngine:config:", a1, a2);
    if (!result)
    {
LABEL_8:
      x_log_crash("Error initializing HDRProcessor.");
      abort();
    }
  }
  else
  {
    v5 = *(_DWORD *)(a2 + 36);
    v6 = objc_alloc((Class)hdr_processor_class);
    if (v5)
    {
      result = objc_msgSend(v6, "initWithConfig:", a2);
      if (!result)
        goto LABEL_8;
    }
    else
    {
      result = objc_msgSend(v6, "initWithDevice:config:", a1, a2);
      if (!result)
        goto LABEL_8;
    }
  }
  return result;
}

uint64_t CA::HDRProcessorInternal::should_switch_accelerator(uint64_t a1, IOSurfaceRef buffer, __IOSurface *a3, unsigned int a4, char a5, uint64_t a6, int a7, char a8, double a9)
{
  CA::Render *PixelFormat;
  int v19;
  const __CFDictionary *v20;
  uint64_t v21;
  uint64_t result;
  CA::Render *v23;
  CA::Render *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  double v28;
  double v29;
  NSObject *v30;
  const char *v31;
  uint64_t v32;
  double v33;
  NSObject *v34;
  uint8_t v35[8];
  uint64_t v36;
  unint64_t v37;
  uint8_t buf[32];
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  int v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(buffer);
  v19 = CA::Render::fourcc_compressed_of_type(PixelFormat, 0, 0);
  v44 = 0;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v39 = 0u;
  memset(buf, 0, sizeof(buf));
  if (IOSurfaceGetBulkAttachments())
  {
    v21 = 0;
  }
  else
  {
    v20 = IOSurfaceCopyAllValues(buffer);
    if (CFDictionaryGetValue(v20, (const void *)_kHDRProcessingDolbyVisionRPUDataKey) && (BYTE12(v40) & 0xFD) == 0x10)
    {
      v21 = _kHDRProcessingSourceContentTypeDolbyVision;
      if (!v20)
        goto LABEL_17;
      goto LABEL_16;
    }
    if (BYTE12(v40) == 18)
      goto LABEL_12;
    if (BYTE12(v40) != 16 || BYTE11(v40) > 0xCu || ((1 << SBYTE11(v40)) & 0x1202) == 0)
    {
      if (CA_CFDictionaryGetBool(v20, CFSTR("isHLG")))
      {
LABEL_12:
        v21 = _kHDRProcessingSourceContentTypeHLG;
        if (!v20)
          goto LABEL_17;
        goto LABEL_16;
      }
      if (v19 != 1380411457)
      {
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          v34 = x_log_category_utilities;
          if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)v35 = 67109376;
            *(_DWORD *)&v35[4] = BYTE12(v40);
            LOWORD(v36) = 1024;
            *(_DWORD *)((char *)&v36 + 2) = BYTE11(v40);
            _os_log_impl(&dword_184457000, v34, OS_LOG_TYPE_ERROR, "Unknown HDR surface with transfer index %d color index %d", v35, 0xEu);
          }
        }
        v21 = 0;
        if (!v20)
          goto LABEL_17;
        goto LABEL_16;
      }
    }
    v21 = _kHDRProcessingSourceContentTypeHDR10;
    if (v20)
LABEL_16:
      CFRelease(v20);
  }
LABEL_17:
  if (CADeviceSupportsToneMapAcceleratorSwitching::once[0] != -1)
    dispatch_once(CADeviceSupportsToneMapAcceleratorSwitching::once, &__block_literal_global_179);
  result = 0;
  if (CADeviceSupportsToneMapAcceleratorSwitching::accelerator_switching)
  {
    if (!byte_1ECDC6A8D)
    {
      result = 0;
      if (a4 <= 6 && ((1 << a4) & 0x61) != 0)
      {
        if (v21 != _kHDRProcessingSourceContentTypeHDR10 && v21 != _kHDRProcessingSourceContentTypeHLG)
          return 0;
        v23 = (CA::Render *)IOSurfaceGetPixelFormat(a3);
        v24 = (CA::Render *)IOSurfaceGetPixelFormat(buffer);
        if ((a8 & 1) != 0
          || !_hdrp_supports_pixel_format_query
          || (v25 = CA::Render::fourcc_compressed_of_type(v24, 0, 0),
              v26 = objc_msgSend(*(id *)(a1 + 40), "isFormatSupported:inputFormat:outputFormat:device:", 0, v25, CA::Render::fourcc_compressed_of_type(v23, 0, 0), *(_QWORD *)(a1 + 24)), result = 0, v26))
        {
          *(_QWORD *)v35 = 0;
          v36 = 0;
          v37 = 0;
          CA::HDRProcessorInternal::get_msr_estimate(v35, a1, (uint64_t)buffer, (uint64_t)a3, a5, a6);
          v27 = mach_absolute_time();
          v28 = CATimeWithHostTime(v27);
          v29 = v28 + (double)(v37 + v36) * 0.000001;
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            v30 = x_log_category_utilities;
            if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEBUG))
            {
              v31 = "beat";
              if (v29 > a9)
                v31 = "missed";
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v31;
              *(_WORD *)&buf[12] = 2048;
              *(double *)&buf[14] = a9;
              *(_WORD *)&buf[22] = 2048;
              *(double *)&buf[24] = v29;
              LOWORD(v39) = 2048;
              *(double *)((char *)&v39 + 2) = (float)(*(float *)v35 * 100.0);
              _os_log_impl(&dword_184457000, v30, OS_LOG_TYPE_DEBUG, "IOSA %s deadline: %f, with completion estimate: %f.\nCurrent MSR utilization: %.2f%%", buf, 0x2Au);
            }
          }
          v32 = mach_absolute_time();
          if (a7 == 2)
          {
            v33 = CATimeWithHostTime(v32);
            if ((double)v37 / ((a9 - v33) * 1000000.0) + *(float *)v35 < 0.9)
              return 1;
          }
          else if (*(float *)v35 > 0.975)
          {
            return 1;
          }
          return 0;
        }
      }
    }
  }
  return result;
}

void sub_18466B810(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t CA::HDRProcessorInternal::get_msr_estimate(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  _QWORD v17[5];
  _QWORD v18[6];

  v18[5] = *MEMORY[0x1E0C80C00];
  v9 = malloc_type_calloc(1uLL, 0x28uLL, 0x10000407607B2BCuLL);
  *(_DWORD *)v9 = 3;
  v9[2] = 0;
  v9[3] = 0;
  v9[1] = 0;
  *((_DWORD *)v9 + 8) = 0;
  v10 = objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytesNoCopy:length:freeWhenDone:", v9, 40, 1);
  v11 = *MEMORY[0x1E0D3A210];
  v16 = v10;
  v17[0] = v11;
  v12 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v16, 1);
  v13 = *MEMORY[0x1E0D3A250];
  v18[0] = v12;
  v18[1] = MEMORY[0x1E0C9AAB0];
  v14 = *MEMORY[0x1E0D3A328];
  v17[1] = v13;
  v17[2] = v14;
  v18[2] = MEMORY[0x1E0C9AAA0];
  v17[3] = *MEMORY[0x1E0D3A330];
  v18[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", a5 & 7);
  v17[4] = *MEMORY[0x1E0D3A240];
  v18[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", a6);
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v18, v17, 5);
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  return IOSurfaceAcceleratorGetTransformEstimation();
}

uint64_t CA::HDRProcessorInternal::create_surface_with_forward_dm(CA::Render::Surface const*,CA::Render::Update *,CA::Render::DisplayAttributes const*,BOOL,float,CA::Render::TextureFlags,BOOL,BOOL,BOOL,BOOL)::$_0::operator()(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  unsigned int *v9;
  _QWORD *v10;
  unsigned int *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  __IOSurface *v15;
  uint64_t v16;
  uint64_t v17;
  CA::Render *PixelFormat;
  int v19;
  BOOL v20;
  int v21;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = result;
    v6 = *(_QWORD *)(result + 48);
    do
    {
      v8 = *v4;
      v7 = (uint64_t *)v4[1];
      result = IOSurfaceIsInUse(*(IOSurfaceRef *)(*(_QWORD *)*v4 + 112));
      if (!(_DWORD)result)
      {
        v9 = *(unsigned int **)v8;
        if (*(_DWORD *)(*(_QWORD *)v8 + 8) == 1)
        {
          v10 = *(_QWORD **)(v5 + 8);
          ++**(_DWORD **)v5;
          if (*v10)
            goto LABEL_6;
          v15 = (__IOSurface *)*((_QWORD *)v9 + 14);
          if (!v15)
            goto LABEL_6;
          v21 = **(_DWORD **)(v5 + 24);
          v16 = **(_QWORD **)(v5 + 32);
          v17 = **(_QWORD **)(v5 + 40);
          PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(v15);
          if (initialized[0] != -1)
            dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
          if ((!*(float *)&dword_1ECDC6934
             || CA::Render::fourcc_compressed_of_type(PixelFormat, 0, 0) == (_DWORD)PixelFormat)
            && IOSurfaceGetWidth(v15) == v16
            && ((v19 = CA::Render::fourcc_compressed_of_type(PixelFormat, 0, 0), IOSurfaceGetHeight(v15) == v17)
              ? (v20 = v19 == v21)
              : (v20 = 0),
                v20 && (IOSurfaceGetProtectionOptions(), result = IOSurfaceSupportsProtectionOptions(), (_DWORD)result)))
          {
            **(_QWORD **)(v5 + 8) = v4;
            if (*(_DWORD *)(v6 + 72))
              return result;
          }
          else
          {
LABEL_6:
            --**(_DWORD **)v5;
            *(_QWORD *)(v6 + 56) = x_list_remove(*(_QWORD **)(v6 + 56), v8);
            v11 = *(unsigned int **)v8;
            if (*(_QWORD *)v8)
            {
              v12 = v11 + 2;
              do
              {
                v13 = __ldaxr(v12);
                v14 = v13 - 1;
              }
              while (__stlxr(v14, v12));
              if (!v14)
                (*(void (**)(unsigned int *))(*(_QWORD *)v11 + 16))(v11);
            }
            result = MEMORY[0x186DBD990](v8, 0x20C4093837F09);
          }
        }
      }
      v4 = v7;
    }
    while (v7 != a3);
  }
  return result;
}

id CA::HDRProcessorInternal::start_command_buffer(id *this, uint64_t a2, const char *a3)
{
  id v5;
  id v6;
  NSObject *v7;
  __int16 v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  CA::HDRProcessorInternal::initialize_metal((CA::HDRProcessorInternal *)this);
  v5 = (id)objc_msgSend(this[4], "commandBuffer");
  v6 = v5;
  if (v5)
  {
    objc_msgSend(v5, "setProtectionOptions:", a2);
  }
  else if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v7 = x_log_category_utilities;
    if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
    {
      v9 = 0;
      _os_log_impl(&dword_184457000, v7, OS_LOG_TYPE_ERROR, "command buffer allocation failed!\n", (uint8_t *)&v9, 2u);
    }
  }
  return v6;
}

uint64_t CA::HDRProcessorInternal::tonemap_surface_internal(uint64_t a1, __IOSurface *a2, __IOSurface *a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7, float *a8, unsigned int a9, uint64_t a10, unsigned int a11, char a12, void *a13, _BYTE *a14, char a15, __int16 a16, char a17, uint64_t a18, char a19, _DWORD *a20)
{
  void *v27;
  CA::Render *PixelFormat;
  int v29;
  CA::Render *v30;
  int v31;
  int BulkAttachments;
  int v33;
  const __CFDictionary *v34;
  const void *Value;
  const void *v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  BOOL v40;
  _DWORD *v41;
  uint64_t v42;
  void *hdr_processor_instance;
  _DWORD *v45;
  const char *v46;
  NSObject *v47;
  float v48;
  unsigned int v49;
  float v50;
  int (*v51)(const void *);
  double v52;
  float v53;
  float v54;
  float v55;
  uint64_t v56;
  double v57;
  uint64_t v58;
  double v59;
  uint64_t v60;
  os_unfair_lock_s *v61;
  double v62;
  os_unfair_lock_s *v63;
  NSObject *v64;
  const char *v65;
  os_unfair_lock_s *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned int v70;
  int v71;
  uint64_t *v72;
  void *v73;
  double v74;
  CFTypeRef v75;
  double v76;
  const void *v77;
  float v78;
  uint64_t v79;
  uint64_t v80;
  __CFDictionary *Mutable;
  __CFDictionary *v82;
  float v83;
  float v84;
  NSObject *v85;
  NSObject *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  id v93;
  _QWORD *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  _DWORD *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  NSObject *v102;
  const char *v103;
  NSObject *v104;
  uint64_t v105;
  _DWORD *v106;
  int v107;
  uint64_t v108;
  unsigned int *v109;
  unsigned int v110;
  uint64_t v111;
  int v112;
  void *v113;
  int v114;
  NSObject *v115;
  NSObject *v116;
  IOSurfaceID ID;
  uint64_t v118;
  const char *v119;
  OSType v120;
  unsigned int v121;
  int v122;
  OSType v123;
  unsigned int v124;
  int v125;
  OSType v126;
  unsigned int v127;
  int v128;
  char v129;
  unsigned int v130;
  int v131;
  char v132;
  unsigned int v133;
  int v134;
  char v135;
  uint64_t v136;
  size_t v137;
  size_t v138;
  OSType v139;
  unsigned int v140;
  int v141;
  signed int v142;
  unsigned int v143;
  int v144;
  char v145;
  unsigned int v146;
  int v147;
  char v148;
  unsigned int v149;
  int v150;
  char v151;
  OSType v152;
  unsigned int v153;
  int v154;
  char v155;
  unsigned int v156;
  int v157;
  char v158;
  unsigned int v159;
  int v160;
  char v161;
  size_t v162;
  size_t v163;
  OSType v164;
  unsigned int v165;
  int v166;
  signed int v167;
  unsigned int v168;
  int v169;
  char v170;
  unsigned int v171;
  int v172;
  char v173;
  unsigned int v174;
  int v175;
  char v176;
  int v177;
  NSObject *v178;
  IOSurfaceID v179;
  char *v180;
  const char *v181;
  uint64_t v182;
  size_t v183;
  size_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  size_t v192;
  size_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  IOSurfaceID v202;
  char v203;
  char v204;
  char v205;
  char v206;
  int v207;
  int v208;
  size_t v209;
  size_t Height;
  size_t v211;
  size_t Width;
  IOSurfaceID v213;
  uint64_t v214;
  uint64_t v215;
  __IOSurface *buffer;
  uint64_t v217;
  unsigned int v218;
  _BYTE *v219;
  id v220;
  void *v221;
  uint64_t v222;
  uint64_t *v223;
  uint64_t *v224;
  const __CFDictionary *v225;
  uint64_t v226;
  uint64_t v227;
  id v228;
  id v229[2];
  __int128 v230;
  __int128 v231;
  __int128 v232;
  __int128 v233;
  __int128 v234;
  __int128 v235;
  __int128 v236;
  int v237;
  __int128 v238;
  __int128 v239;
  __int128 v240;
  __int128 v241;
  __int128 v242;
  __int128 v243;
  __int128 v244;
  int v245;
  uint64_t v246;
  _QWORD v247[10];
  _QWORD v248[10];
  _BYTE buf[24];
  _BYTE v250[30];
  __int16 v251;
  int v252;
  __int16 v253;
  int v254;
  __int16 v255;
  int v256;
  __int16 v257;
  int v258;
  __int16 v259;
  int v260;
  __int16 v261;
  IOSurfaceID v262;
  __int16 v263;
  size_t v264;
  __int16 v265;
  size_t v266;
  __int16 v267;
  int v268;
  __int16 v269;
  int v270;
  __int16 v271;
  int v272;
  __int16 v273;
  int v274;
  __int16 v275;
  int v276;
  __int16 v277;
  int v278;
  __int16 v279;
  int v280;
  __int16 v281;
  uint64_t v282;
  uint8_t v283[8];
  uint8_t *v284;
  uint64_t v285;
  void *v286;
  uint64_t v287;

  v287 = *MEMORY[0x1E0C80C00];
  if (hdrprocessing_init_once != -1)
  {
    v118 = a4;
    dispatch_once_f(&hdrprocessing_init_once, 0, (dispatch_function_t)load_hdrprocessing_symbols);
    a4 = v118;
  }
  if (hdr_handle)
  {
    v226 = a7;
    v227 = a1;
    v223 = a5;
    v224 = a6;
    v222 = a4;
    v27 = (void *)MEMORY[0x186DBE2E4]();
    PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(a2);
    v29 = CA::Render::fourcc_compressed_of_type(PixelFormat, 0, 0);
    v30 = (CA::Render *)IOSurfaceGetPixelFormat(a3);
    v31 = CA::Render::fourcc_compressed_of_type(v30, 0, 0);
    v245 = 0;
    v243 = 0u;
    v244 = 0u;
    v241 = 0u;
    v242 = 0u;
    v239 = 0u;
    v240 = 0u;
    v238 = 0u;
    v237 = 0;
    v235 = 0u;
    v236 = 0u;
    v233 = 0u;
    v234 = 0u;
    v231 = 0u;
    v232 = 0u;
    v230 = 0u;
    v229[1] = (id)116;
    BulkAttachments = IOSurfaceGetBulkAttachments();
    v33 = IOSurfaceGetBulkAttachments();
    v34 = 0;
    if (v33 | BulkAttachments)
      goto LABEL_31;
    v225 = IOSurfaceCopyAllValues(a3);
    Value = CFDictionaryGetValue(v225, (const void *)_kHDRProcessingDolbyVisionRPUDataKey);
    v34 = v225;
    v36 = Value;
    v221 = v27;
    if (Value && (BYTE12(v241) & 0xFD) == 0x10)
    {
      v37 = &_kHDRProcessingSourceContentTypeDolbyVision;
    }
    else if (BYTE12(v241) == 18)
    {
      v37 = &_kHDRProcessingSourceContentTypeHLG;
    }
    else if (BYTE12(v241) == 16 && BYTE11(v241) <= 0xCu && ((1 << SBYTE11(v241)) & 0x1202) != 0)
    {
      v37 = &_kHDRProcessingSourceContentTypeHDR10;
    }
    else
    {
      if (CA_CFDictionaryGetBool(v225, CFSTR("isHLG")))
      {
        v37 = &_kHDRProcessingSourceContentTypeHLG;
      }
      else
      {
        if (v31 != 1380411457)
        {
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            v85 = x_log_category_utilities;
            if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109376;
              *(_DWORD *)&buf[4] = BYTE12(v241);
              *(_WORD *)&buf[8] = 1024;
              *(_DWORD *)&buf[10] = BYTE11(v241);
              _os_log_impl(&dword_184457000, v85, OS_LOG_TYPE_ERROR, "Unknown HDR surface with transfer index %d color index %d", buf, 0xEu);
            }
          }
          v34 = v225;
          goto LABEL_31;
        }
        v37 = &_kHDRProcessingSourceContentTypeHDR10;
      }
      v34 = v225;
    }
    v39 = *v37;
    if (*v37)
    {
      if (CADeviceHasHardwareAcceleratedHDR::once != -1)
        dispatch_once(&CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_93);
      buffer = a2;
      if (CADeviceHasHardwareAcceleratedHDR::has_capability)
      {
        v40 = a11 < 2;
        if (a11 == 3)
          v40 = 1;
        *(_BYTE *)(v227 + 89) = v40;
        v219 = (_BYTE *)(v227 + 89);
        if (a11 <= 3 && a11 != 2)
        {
          v41 = a20;
          v42 = 1;
          goto LABEL_40;
        }
        v41 = a20;
      }
      else
      {
        v41 = a20;
        *(_BYTE *)(v227 + 89) = 0;
        v219 = (_BYTE *)(v227 + 89);
      }
      v42 = 0;
LABEL_40:
      *(_DWORD *)(v226 + 36) = v42;
      os_unfair_lock_lock((os_unfair_lock_t)(v227 + 20));
      v218 = v42;
      hdr_processor_instance = CA::HDRProcessorInternal::get_or_create_hdr_processor_instance(v227, (__CFRunLoop *)v42, v226);
      v45 = v41;
      if (!hdr_processor_instance)
      {
        if (x_log_hook_p())
        {
          x_log_();
          v27 = v221;
          v63 = (os_unfair_lock_s *)(v227 + 20);
        }
        else
        {
          v64 = x_log_category_utilities;
          v27 = v221;
          v63 = (os_unfair_lock_s *)(v227 + 20);
          if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
          {
            v65 = "GPU";
            if (v218)
              v65 = "MSR";
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v65;
            _os_log_impl(&dword_184457000, v64, OS_LOG_TYPE_ERROR, "Failed to create HDRProcessor for %s", buf, 0xCu);
          }
        }
        if (v41)
          *v41 = -17001;
        v66 = v63;
        goto LABEL_206;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v227 + 20));
      v228 = objc_alloc_init(MEMORY[0x1E0C99E08]);
      if (_hdrp_version >= 1)
        objc_msgSend(v228, "setObject:forKeyedSubscript:", &unk_1E15D6ED0, _kHDRProcessingApiInterfaceVersionKey);
      v220 = objc_alloc_init(MEMORY[0x1E0C99E08]);
      v46 = (const char *)buffer;
      objc_msgSend(v220, "setObject:forKeyedSubscript:", v39, _kHDRProcessingSourceContentTypeKey);
      if (_kHDRProcessingSourceContentHDRMaxBrightnessInNitsKey)
        objc_msgSend(v220, "setObject:forKeyedSubscript:", &unk_1E15D6EE8);
      v47 = a10;
      v217 = a9;
      v48 = *(float *)(a10 + 20);
      v49 = *(_DWORD *)(a10 + 60);
      if (v49 > 6 || ((1 << v49) & 0x61) == 0)
      {
        if (*(_BYTE *)(a10 + 50))
        {
          v67 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", *(unsigned int *)(v226 + 12));
          v61 = (os_unfair_lock_s *)(v227 + 20);
          objc_msgSend(v228, "setObject:forKeyedSubscript:", v67, _kHDRProcessingCurrentMaxPanelNitsKey);
          objc_msgSend(v228, "setObject:forKeyedSubscript:", &unk_1E15D6F00, _kHDRProcessingAmbientLightInNitsKey);
        }
        else
        {
          v61 = (os_unfair_lock_s *)(v227 + 20);
        }
        goto LABEL_101;
      }
      v50 = *(float *)(a10 + 12);
      if (CADeviceSupportsTwilight::once[0] != -1)
        dispatch_once(CADeviceSupportsTwilight::once, &__block_literal_global_220);
      if (CADeviceSupportsTwilight::twilight && v36 && *(_BYTE *)(a10 + 49) && !byte_1ECDC6AE4)
      {
        *(_QWORD *)v283 = 0;
        v284 = v283;
        v285 = 0x2020000000;
        v51 = (int (*)(const void *))getCMGetDMVersionLevelFromRPUSymbolLoc(void)::ptr;
        v286 = getCMGetDMVersionLevelFromRPUSymbolLoc(void)::ptr;
        if (!getCMGetDMVersionLevelFromRPUSymbolLoc(void)::ptr)
        {
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 3221225472;
          *(_QWORD *)&buf[16] = ___ZL38getCMGetDMVersionLevelFromRPUSymbolLocv_block_invoke;
          *(_QWORD *)v250 = &unk_1E159E440;
          *(_QWORD *)&v250[8] = v283;
          ___ZL38getCMGetDMVersionLevelFromRPUSymbolLocv_block_invoke((uint64_t)buf);
          v51 = (int (*)(const void *))*((_QWORD *)v284 + 3);
        }
        _Block_object_dispose(v283, 8);
        if (!v51)
        {
          v180 = dlerror();
          v124 = abort_report_np();
          __break(1u);
          goto LABEL_269;
        }
        if (v51(v36) <= 3)
        {
          v52 = v48 * 0.125 + -1.0;
          if (v52 > 1.0)
            v52 = 1.0;
          if (v52 < 0.0)
            v52 = 0.0;
          v53 = v52;
          v54 = (float)((float)(v53 * -2.0) + 6.0) * v48;
          if (v50 <= v54)
            v50 = v54;
          if (a14)
            *a14 = 1;
        }
      }
      v55 = 100.0;
      if (v50 != 0.0)
        v55 = v50;
      *(_DWORD *)(v226 + 12) = v55;
      *a8 = v55;
      v56 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:");
      objc_msgSend(v228, "setObject:forKeyedSubscript:", v56, _kHDRProcessingCurrentMaxPanelNitsKey);
      *(float *)&v57 = v48;
      v58 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v57);
      objc_msgSend(v228, "setObject:forKeyedSubscript:", v58, _kHDRProcessingMaximumExtendedDynamicRangeColorComponentValueKey);
      if (v29 != 1919365992)
      {
        if (v29 == 1380411457)
        {
          if (*v219)
          {
LABEL_70:
            *(float *)&v59 = 1.0 / v48;
            v60 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v59);
            v61 = (os_unfair_lock_s *)(v227 + 20);
            objc_msgSend(v228, "setObject:forKeyedSubscript:", v60, _kHDRProcessingEDRFactorKey);
LABEL_84:
            LODWORD(v62) = *(_DWORD *)(a10 + 16);
            v68 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v62);
            objc_msgSend(v228, "setObject:forKeyedSubscript:", v68, _kHDRProcessingAmbientLightInNitsKey);
            if (*(_BYTE *)(a10 + 48) && _kHDRProcessingDisplaySupportsAmbientAdaptationKey)
              objc_msgSend(v228, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AAB0]);
            if (*(unsigned __int8 *)(a10 + 54) | BYTE12(xmmword_1ECDC6A90))
            {
              v69 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", 1);
              objc_msgSend(v228, "setObject:forKeyedSubscript:", v69, _kHDRProcessingOperationEnum);
              v217 = 1;
            }
            v70 = *(_DWORD *)(a10 + 60);
            if (v70 <= 6 && ((1 << v70) & 0x61) != 0)
            {
              v71 = *(_DWORD *)(a10 + 64);
              v72 = &_kHDRProcessingDisplayPipelineCompensationTypeNone;
              if (v71 == 1 || byte_1ECDC6A8E)
                goto LABEL_100;
              if (v71 == 3)
              {
                v72 = &_kHDRProcessingDisplayPipelineCompensationTypeHeadroomDependent;
                goto LABEL_100;
              }
              if (v71 == 2)
              {
                v72 = &_kHDRProcessingDisplayPipelineCompensationTypePurePower;
LABEL_100:
                objc_msgSend(v228, "setObject:forKeyedSubscript:", *v72, _kHDRProcessingDisplayPipelineCompensationType);
              }
            }
LABEL_101:
            if (v39 == _kHDRProcessingSourceContentTypeDolbyVision && v36)
              objc_msgSend(v228, "setObject:forKeyedSubscript:", v36, _kHDRProcessingDolbyVisionRPUDataKey);
            v73 = forward_display_params_from_attributes(a10, 0);
            if (v73)
              objc_msgSend(v228, "setObject:forKeyedSubscript:", v73, _kHDRProcessingDisplayKey);
            if (v31 == 1380411457 && BYTE12(v241) != 16)
            {
              v75 = IOSurfaceCopyValue(a3, CFSTR("SDRBrightnessInNits"));
              v77 = v75;
              if (v75)
              {
                v78 = CA_CFFloatValue(v75);
                CFRelease(v77);
              }
              else
              {
                v78 = 100.0;
              }
              *(float *)&v76 = v78;
              v79 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v76);
              objc_msgSend(v220, "setObject:forKeyedSubscript:", v79, _kHDRProcessingSourceContentSDRMaxBrightnessInNitsKey);
            }
            if (*(_BYTE *)(a10 + 53))
            {
              if ((_DWORD)v217 == 4)
              {
                if (initialized[0] != -1)
                  dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
                *(float *)&v74 = truncf(*(float *)&dword_1ECDC698C);
                if (!*(float *)&dword_1ECDC698C)
                  *(float *)&v74 = 200.0;
                v80 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v74);
                objc_msgSend(v220, "setObject:forKeyedSubscript:", v80, _kHDRProcessingSourceContentSDRMaxBrightnessInNitsKey);
                if (!a18 && a19 != 2 && (*(_DWORD *)(a10 + 60) - 3) <= 1)
                {
                  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                  v82 = Mutable;
                  if (Mutable)
                  {
                    v83 = flt_18474D6A8[a19 == 0];
                    v84 = flt_18474D6B0[a19 == 0];
                    CA_CFDictionarySetFloat(Mutable, (const void *)*MEMORY[0x1E0CBC000], 0.015);
                    CA_CFDictionarySetFloat(v82, (const void *)*MEMORY[0x1E0CBBFF8], v83);
                    CA_CFDictionarySetFloat(v82, (const void *)*MEMORY[0x1E0CBBFF0], v84);
                    CA_CFDictionarySetInt(v82, (const void *)*MEMORY[0x1E0CBBFE8], 16);
                    IOSurfaceSetValue(buffer, (CFStringRef)*MEMORY[0x1E0CBBFE0], v82);
                    CFRelease(v82);
                  }
                  else if (x_log_hook_p())
                  {
                    x_log_();
                  }
                  else
                  {
                    v86 = x_log_category_utilities;
                    if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_impl(&dword_184457000, v86, OS_LOG_TYPE_DEFAULT, "CoreAnimation: unable to set static PQ stats, no dictionary created.", buf, 2u);
                    }
                  }
                }
              }
              if (BYTE12(v241) == 18)
              {
                LODWORD(v74) = *(_DWORD *)(a10 + 4);
                v87 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v74);
                objc_msgSend(v228, "setObject:forKeyedSubscript:", v87, _kHDRProcessingCurrentMaxPanelNitsKey);
                v217 = 3;
              }
              if (a18)
                objc_msgSend(v228, "setObject:forKeyedSubscript:", a18, _kHDRProcessingDolbyVisionRPUDataKey);
            }
            objc_msgSend(v228, "setObject:forKeyedSubscript:", v220, _kHDRProcessingSourceContentKey);

            if (*v219)
            {
              v27 = v221;
              v88 = v227;
              if (*(_DWORD *)(a10 + 60) != 2 || *(unsigned __int8 *)(a10 + 53) | BYTE4(xmmword_1ECDC6A90))
              {
LABEL_139:
                IOSurfaceGetID(a3);
                IOSurfaceGetID(buffer);
                if (BYTE9(xmmword_1ECDC6A90))
                  kdebug_trace();
                if (*(_DWORD *)(a10 + 60))
                  IOSurfaceRemoveValue(buffer, (CFStringRef)*MEMORY[0x1E0CBBFB0]);
                if (!BYTE12(xmmword_1ECDC6AB0))
                {
LABEL_144:
                  os_unfair_lock_lock(v61);
                  if (!CA::HDRProcessorInternal::get_or_create_hdr_processor_instance(v88, (__CFRunLoop *)v218, v226))
                  {
                    if (x_log_hook_p())
                    {
                      x_log_();
                    }
                    else
                    {
                      v102 = x_log_category_utilities;
                      if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
                      {
                        v103 = "GPU";
                        if (v218)
                          v103 = "MSR";
                        *(_DWORD *)buf = 136315138;
                        *(_QWORD *)&buf[4] = v103;
                        _os_log_impl(&dword_184457000, v102, OS_LOG_TYPE_ERROR, "Failed to create HDRProcessor for %s", buf, 0xCu);
                      }
                    }
                    if (v45)
                      *v45 = -17001;

                    goto LABEL_205;
                  }
                  if (*v219)
                  {
                    v229[0] = 0;
                    v89 = 40;
                    if (!_hdrp_supports_new_init)
                      v89 = 96;
                    v90 = objc_msgSend(*(id *)(v88 + v89), "generateMSRColorConfigWithOperation:inputSurface:outputSurface:metadata:histogram:config:", v217, a3, v46, v228, 0, v229, v180, v181, v182, v183, v184, v185, v186, v187, v188, v189, v190,
                            v191,
                            v192,
                            v193,
                            v194,
                            v195,
                            v196,
                            v197,
                            v198,
                            v199,
                            v200,
                            v201);
                    os_unfair_lock_unlock(v61);
                    v91 = objc_msgSend(v229[0], "bytes");
                    v92 = objc_msgSend(v229[0], "length");
                    v93 = v229[0];
                    if (v90 != -17000)
                    {
                      if (x_log_hook_p())
                      {
                        x_log_();
                      }
                      else
                      {
                        v104 = x_log_category_utilities;
                        if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)buf = 134218752;
                          *(_QWORD *)&buf[4] = v90;
                          *(_WORD *)&buf[12] = 2048;
                          *(_QWORD *)&buf[14] = a3;
                          *(_WORD *)&buf[22] = 2048;
                          *(_QWORD *)v250 = v46;
                          *(_WORD *)&v250[8] = 2048;
                          *(_QWORD *)&v250[10] = v228;
                          _os_log_impl(&dword_184457000, v104, OS_LOG_TYPE_ERROR, "HDRProcessor error (%ld) (src:%p, dst:%p, md:%p)", buf, 0x2Au);
                        }
                      }
                      if (v45)
                        *v45 = v90;

                      goto LABEL_204;
                    }
                    v94 = malloc_type_malloc(0x28uLL, 0x10000407607B2BCuLL);
                    *(_DWORD *)v94 = 3;
                    v94[1] = v91;
                    *((_DWORD *)v94 + 4) = v92;
                    *(_QWORD *)((char *)v94 + 28) = 0;
                    *(_QWORD *)((char *)v94 + 20) = 0;
                    v95 = (uint64_t)v223;
                    v96 = objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytesNoCopy:length:freeWhenDone:", v94, 40, 1);
                    if (v224)
                    {
                      v97 = v224[5];
                      v98 = (_DWORD *)v224[8];
                      if (v98)
                        CA::WindowServer::SharedEvent::History::add(v98, *v224, 6, 1, 1, v224[5]);
                      v99 = CA::WindowServer::SharedEvent::inc_signal_value((uint64_t)v224, 6, 1);
                    }
                    else
                    {
                      v97 = 0;
                      v99 = 0;
                    }
                    if (v223)
                    {
                      v105 = v223[2];
                      v106 = (_DWORD *)v223[8];
                      if (v106)
                        CA::WindowServer::SharedEvent::History::add(v106, *v223, 7, 1, 2, v223[2]);
                      v95 = CA::WindowServer::SharedEvent::inc_signal_value((uint64_t)v223, 7, 2);
                    }
                    else
                    {
                      v105 = 0;
                    }
                    v107 = dword_1ECDC6B10;
                    v247[0] = *MEMORY[0x1E0D3A210];
                    v246 = v96;
                    v248[0] = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v246, 1);
                    v248[1] = MEMORY[0x1E0C9AAB0];
                    v108 = *MEMORY[0x1E0D3A328];
                    v247[1] = *MEMORY[0x1E0D3A250];
                    v247[2] = v108;
                    v248[2] = MEMORY[0x1E0C9AAA0];
                    v247[3] = *MEMORY[0x1E0D3A330];
                    v248[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", a15 & 7);
                    v247[4] = *MEMORY[0x1E0D3A240];
                    v248[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:");
                    v247[5] = *MEMORY[0x1E0D3A2C8];
                    v248[5] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", v97);
                    v247[6] = *MEMORY[0x1E0D3A2C0];
                    v248[6] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", v99);
                    v247[7] = *MEMORY[0x1E0D3A2B0];
                    v248[7] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", v105);
                    v247[8] = *MEMORY[0x1E0D3A2A8];
                    v248[8] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", v95);
                    v247[9] = *MEMORY[0x1E0D3A218];
                    v248[9] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", v107 == 0);
                    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v248, v247, 10);
                    v109 = (unsigned int *)(*(_QWORD *)(v227 + 104) + 24);
                    do
                      v110 = __ldaxr(v109);
                    while (__stlxr(v110 + 1, v109));
                    v111 = *(_QWORD *)(v227 + 104);
                    *(_QWORD *)buf = CA::release_hdr_iosa_param;
                    *(_QWORD *)&buf[8] = v111;
                    *(id *)&buf[16] = v229[0];
                    v61 = (os_unfair_lock_s *)(v227 + 20);
                    v112 = IOSurfaceAcceleratorTransformSurface();
                    v114 = v112;
                    if (v222)
                      ++*(_DWORD *)(v222 + 488);
                    if (!a12 || v112)
                    {
                      (*(void (**)(CA *, void *, void *, void *))buf)(*(CA **)&buf[8], 0, *(void **)&buf[16], v113);
                      if (v114)
                      {
                        if (x_log_hook_p())
                        {
                          IOSurfaceGetID(a3);
                          x_log_();
                        }
                        else
                        {
                          v116 = x_log_category_utilities;
                          if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
                          {
                            ID = IOSurfaceGetID(a3);
                            *(_DWORD *)v283 = 67109376;
                            *(_DWORD *)&v283[4] = v114;
                            LOWORD(v284) = 1024;
                            *(_DWORD *)((char *)&v284 + 2) = ID;
                            _os_log_impl(&dword_184457000, v116, OS_LOG_TYPE_ERROR, "MSR failed err=0x%x sur=0x%x", v283, 0xEu);
                          }
                        }
                        if (v45)
                          *v45 = v114;

LABEL_204:
                        os_unfair_lock_lock(v61);
LABEL_205:
                        v66 = v61;
LABEL_206:
                        os_unfair_lock_unlock(v66);
                        v38 = 0;
LABEL_207:
                        v34 = v225;
                        if (!v225)
                          goto LABEL_35;
                        goto LABEL_34;
                      }
                    }
                    if (byte_1ECDC6AED && a17)
                    {
                      if (x_log_hook_p())
                      {
                        v27 = v221;
                        v61 = (os_unfair_lock_s *)(v227 + 20);
                        IOSurfaceGetID(a3);
                        x_log_();
                      }
                      else
                      {
                        v178 = x_log_category_filmgrain;
                        v27 = v221;
                        v61 = (os_unfair_lock_s *)(v227 + 20);
                        if (os_log_type_enabled((os_log_t)x_log_category_filmgrain, OS_LOG_TYPE_INFO))
                        {
                          v179 = IOSurfaceGetID(a3);
                          *(_DWORD *)v283 = 67109120;
                          *(_DWORD *)&v283[4] = v179;
                          _os_log_impl(&dword_184457000, v178, OS_LOG_TYPE_INFO, "[0x%x] [HDR] MSR Successfully applied film grain", v283, 8u);
                          v27 = v221;
                          v61 = (os_unfair_lock_s *)(v227 + 20);
                        }
                      }
                    }
                  }
                  else
                  {
                    CA::shared_event_submit(*(void **)(v88 + 24), a13, (uint64_t)v224, 1, 1);
                    CA::shared_event_submit(*(void **)(v88 + 24), a13, (uint64_t)v223, 1, 2);
                    v100 = 40;
                    if (!_hdrp_supports_new_init)
                      v100 = 48;
                    v101 = objc_msgSend(*(id *)(v88 + v100), "encodeToCommandBuffer:inputSurfaceLayer0:inputSurfacelayer1:outputSurface:metadata:", a13, a3, 0, v46, v228, v180, v181, v182, v183, v184, v185, v186, v187, v188, v189, v190, v191,
                             v192,
                             v193,
                             v194,
                             v195,
                             v196,
                             v197,
                             v198,
                             v199,
                             v200,
                             v201);
                    os_unfair_lock_unlock(v61);
                    CA::shared_event_submit(*(void **)(v88 + 24), a13, (uint64_t)v224, 0, 1);
                    CA::shared_event_submit(*(void **)(v88 + 24), a13, (uint64_t)v223, 0, 2);
                    if (v222)
                      ++*(_DWORD *)(v222 + 492);
                    if (v101 != -17000)
                    {
                      if (x_log_hook_p())
                      {
                        x_log_();
                      }
                      else
                      {
                        v115 = x_log_category_utilities;
                        if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)buf = 134219008;
                          *(_QWORD *)&buf[4] = v101;
                          *(_WORD *)&buf[12] = 2048;
                          *(_QWORD *)&buf[14] = a13;
                          *(_WORD *)&buf[22] = 2048;
                          *(_QWORD *)v250 = a3;
                          *(_WORD *)&v250[8] = 2048;
                          *(_QWORD *)&v250[10] = v46;
                          *(_WORD *)&v250[18] = 2048;
                          *(_QWORD *)&v250[20] = v228;
                          _os_log_impl(&dword_184457000, v115, OS_LOG_TYPE_ERROR, "HDRProcessor error (%ld) (cmd:%p, src:%p, dst:%p, md:%p)", buf, 0x34u);
                        }
                      }
                      if (v45)
                        *v45 = v101;

                      goto LABEL_204;
                    }
                  }
                  os_unfair_lock_lock(v61);
                  os_unfair_lock_unlock(v61);

                  v38 = 1;
                  goto LABEL_207;
                }
                v220 = v45;
                v215 = objc_msgSend((id)objc_msgSend(v228, "debugDescription"), "UTF8String");
                if (x_log_hook_p())
                {
                  if (*v219)
                    v119 = "MSR";
                  else
                    v119 = "GPU";
                  v214 = IOSurfaceGetID(a3);
                  Width = IOSurfaceGetWidth(a3);
                  Height = IOSurfaceGetHeight(a3);
                  v120 = IOSurfaceGetPixelFormat(a3);
                  v121 = HIBYTE(v120);
                  if ((v120 & 0x80000000) != 0)
                    v122 = __maskrune(v121, 0x40000uLL);
                  else
                    v122 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v121 + 60) & 0x40000;
                  if (v122)
                    v126 = IOSurfaceGetPixelFormat(a3) & 0xFF000000;
                  else
                    v126 = 0x20000000;
                  v207 = v126;
                  v127 = (IOSurfaceGetPixelFormat(a3) >> 16);
                  if (v127 <= 0x7F)
                    v128 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v127 + 60) & 0x40000;
                  else
                    v128 = __maskrune(v127, 0x40000uLL);
                  if (v128)
                    v129 = IOSurfaceGetPixelFormat(a3) >> 16;
                  else
                    v129 = 32;
                  v205 = v129;
                  v130 = ((unsigned __int16)IOSurfaceGetPixelFormat(a3) >> 8);
                  if (v130 <= 0x7F)
                    v131 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v130 + 60) & 0x40000;
                  else
                    v131 = __maskrune(v130, 0x40000uLL);
                  if (v131)
                    v132 = (unsigned __int16)IOSurfaceGetPixelFormat(a3) >> 8;
                  else
                    v132 = 32;
                  v203 = v132;
                  v133 = IOSurfaceGetPixelFormat(a3);
                  if (v133 <= 0x7F)
                    v134 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v133 + 60) & 0x40000;
                  else
                    v134 = __maskrune(v133, 0x40000uLL);
                  if (v134)
                    v135 = IOSurfaceGetPixelFormat(a3);
                  else
                    v135 = 32;
                  v136 = IOSurfaceGetID(buffer);
                  v137 = IOSurfaceGetWidth(buffer);
                  v138 = IOSurfaceGetHeight(buffer);
                  v139 = IOSurfaceGetPixelFormat(buffer);
                  v140 = HIBYTE(v139);
                  if ((v139 & 0x80000000) != 0)
                    v141 = __maskrune(v140, 0x40000uLL);
                  else
                    v141 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v140 + 60) & 0x40000;
                  if (v141)
                    v142 = IOSurfaceGetPixelFormat(buffer) & 0xFF000000;
                  else
                    v142 = 0x20000000;
                  v143 = (IOSurfaceGetPixelFormat(buffer) >> 16);
                  if (v143 <= 0x7F)
                    v144 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v143 + 60) & 0x40000;
                  else
                    v144 = __maskrune(v143, 0x40000uLL);
                  if (v144)
                    v145 = IOSurfaceGetPixelFormat(buffer) >> 16;
                  else
                    v145 = 32;
                  v146 = ((unsigned __int16)IOSurfaceGetPixelFormat(buffer) >> 8);
                  if (v146 <= 0x7F)
                    v147 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v146 + 60) & 0x40000;
                  else
                    v147 = __maskrune(v146, 0x40000uLL);
                  if (v147)
                    v148 = (unsigned __int16)IOSurfaceGetPixelFormat(buffer) >> 8;
                  else
                    v148 = 32;
                  v149 = IOSurfaceGetPixelFormat(buffer);
                  if (v149 <= 0x7F)
                    v150 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v149 + 60) & 0x40000;
                  else
                    v150 = __maskrune(v149, 0x40000uLL);
                  if (v150)
                    v151 = IOSurfaceGetPixelFormat(buffer);
                  else
                    v151 = 32;
                  v200 = v217;
                  v201 = v215;
                  v198 = BYTE11(v233);
                  v199 = BYTE12(v233);
                  v196 = v148;
                  v197 = v151;
                  v194 = (v142 >> 24);
                  v195 = v145;
                  v192 = v137;
                  v193 = v138;
                  v190 = BYTE12(v241);
                  v191 = v136;
                  v188 = v135;
                  v189 = BYTE11(v241);
                  v186 = v205;
                  v187 = v203;
                  v184 = Height;
                  v185 = (v207 >> 24);
                  v182 = v214;
                  v183 = Width;
                  v88 = v227;
                  v180 = (char *)v227;
                  v181 = v119;
                  x_log_();
LABEL_316:
                  v45 = v220;
                  v27 = v221;
                  v61 = (os_unfair_lock_s *)(v227 + 20);
                  v46 = (const char *)buffer;
                  goto LABEL_144;
                }
                v47 = x_log_category_utilities;
                v27 = v221;
                v61 = (os_unfair_lock_s *)(v227 + 20);
                v88 = v227;
                v46 = (const char *)buffer;
                if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_DEFAULT))
                  goto LABEL_144;
                if (*v219)
                  v46 = "MSR";
                else
                  v46 = "GPU";
                v213 = IOSurfaceGetID(a3);
                v211 = IOSurfaceGetWidth(a3);
                v209 = IOSurfaceGetHeight(a3);
                v123 = IOSurfaceGetPixelFormat(a3);
                v124 = HIBYTE(v123);
                if ((v123 & 0x80000000) == 0)
                {
                  v125 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v124 + 60) & 0x40000;
LABEL_270:
                  if (v125)
                    v152 = IOSurfaceGetPixelFormat(a3) & 0xFF000000;
                  else
                    v152 = 0x20000000;
                  v208 = v152;
                  v153 = (IOSurfaceGetPixelFormat(a3) >> 16);
                  if (v153 <= 0x7F)
                    v154 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v153 + 60) & 0x40000;
                  else
                    v154 = __maskrune(v153, 0x40000uLL);
                  if (v154)
                    v155 = IOSurfaceGetPixelFormat(a3) >> 16;
                  else
                    v155 = 32;
                  v206 = v155;
                  v156 = ((unsigned __int16)IOSurfaceGetPixelFormat(a3) >> 8);
                  if (v156 <= 0x7F)
                    v157 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v156 + 60) & 0x40000;
                  else
                    v157 = __maskrune(v156, 0x40000uLL);
                  if (v157)
                    v158 = (unsigned __int16)IOSurfaceGetPixelFormat(a3) >> 8;
                  else
                    v158 = 32;
                  v204 = v158;
                  v159 = IOSurfaceGetPixelFormat(a3);
                  if (v159 <= 0x7F)
                    v160 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v159 + 60) & 0x40000;
                  else
                    v160 = __maskrune(v159, 0x40000uLL);
                  if (v160)
                    v161 = IOSurfaceGetPixelFormat(a3);
                  else
                    v161 = 32;
                  v202 = IOSurfaceGetID(buffer);
                  v162 = IOSurfaceGetWidth(buffer);
                  v163 = IOSurfaceGetHeight(buffer);
                  v164 = IOSurfaceGetPixelFormat(buffer);
                  v165 = HIBYTE(v164);
                  if ((v164 & 0x80000000) != 0)
                    v166 = __maskrune(v165, 0x40000uLL);
                  else
                    v166 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v165 + 60) & 0x40000;
                  if (v166)
                    v167 = IOSurfaceGetPixelFormat(buffer) & 0xFF000000;
                  else
                    v167 = 0x20000000;
                  v168 = (IOSurfaceGetPixelFormat(buffer) >> 16);
                  if (v168 <= 0x7F)
                    v169 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v168 + 60) & 0x40000;
                  else
                    v169 = __maskrune(v168, 0x40000uLL);
                  if (v169)
                    v170 = IOSurfaceGetPixelFormat(buffer) >> 16;
                  else
                    v170 = 32;
                  v171 = ((unsigned __int16)IOSurfaceGetPixelFormat(buffer) >> 8);
                  if (v171 <= 0x7F)
                    v172 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v171 + 60) & 0x40000;
                  else
                    v172 = __maskrune(v171, 0x40000uLL);
                  if (v172)
                    v173 = (unsigned __int16)IOSurfaceGetPixelFormat(buffer) >> 8;
                  else
                    v173 = 32;
                  v174 = IOSurfaceGetPixelFormat(buffer);
                  if (v174 <= 0x7F)
                    v175 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v174 + 60) & 0x40000;
                  else
                    v175 = __maskrune(v174, 0x40000uLL);
                  if (v175)
                    v176 = IOSurfaceGetPixelFormat(buffer);
                  else
                    v176 = 32;
                  *(_DWORD *)buf = 134223362;
                  v177 = v161;
                  v88 = v227;
                  *(_QWORD *)&buf[4] = v227;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = v46;
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)v250 = v213;
                  *(_WORD *)&v250[4] = 2048;
                  *(_QWORD *)&v250[6] = v211;
                  *(_WORD *)&v250[14] = 2048;
                  *(_QWORD *)&v250[16] = v209;
                  *(_WORD *)&v250[24] = 1024;
                  *(_DWORD *)&v250[26] = v208 >> 24;
                  v251 = 1024;
                  v252 = v206;
                  v253 = 1024;
                  v254 = v204;
                  v255 = 1024;
                  v256 = v177;
                  v257 = 1024;
                  v258 = BYTE11(v241);
                  v259 = 1024;
                  v260 = BYTE12(v241);
                  v261 = 1024;
                  v262 = v202;
                  v263 = 2048;
                  v264 = v162;
                  v265 = 2048;
                  v266 = v163;
                  v267 = 1024;
                  v268 = v167 >> 24;
                  v269 = 1024;
                  v270 = v170;
                  v271 = 1024;
                  v272 = v173;
                  v273 = 1024;
                  v274 = v176;
                  v275 = 1024;
                  v276 = BYTE11(v233);
                  v277 = 1024;
                  v278 = BYTE12(v233);
                  v279 = 1024;
                  v280 = v217;
                  v281 = 2080;
                  v282 = v215;
                  _os_log_impl(&dword_184457000, v47, OS_LOG_TYPE_DEFAULT, "HDRProcessor %p accelerator %s src surface 0x%x [%zu x %zu] (%c%c%c%c) Primaries: 0x%x, TransferFunction: 0x%x dst surface 0x%x [%zu x %zu] (%c%c%c%c) Primaries: 0x%x, TransferFunction: 0x%x operation 0x%x metadata: %s\n", buf, 0xA2u);
                  goto LABEL_316;
                }
LABEL_269:
                v125 = __maskrune(v124, 0x40000uLL);
                goto LABEL_270;
              }
              objc_msgSend(v228, "setObject:forKeyedSubscript:", &unk_1E15D6E70, _kHDRProcessingCurrentMaxPanelNitsKey);
              v217 = 3;
            }
            v27 = v221;
            v88 = v227;
            goto LABEL_139;
          }
        }
        else if (BYTE12(v233) != 16)
        {
          goto LABEL_70;
        }
      }
      objc_msgSend(v228, "setObject:forKeyedSubscript:", &unk_1E15DACE0, _kHDRProcessingEDRFactorKey);
      v61 = (os_unfair_lock_s *)(v227 + 20);
      goto LABEL_84;
    }
    v27 = v221;
LABEL_31:
    v38 = 0;
    if (a20)
      *a20 = -17006;
    if (!v34)
      goto LABEL_35;
LABEL_34:
    CFRelease(v34);
LABEL_35:
    objc_autoreleasePoolPop(v27);
    return v38;
  }
  v38 = 0;
  if (a20)
    *a20 = -17010;
  return v38;
}

void sub_18466D978(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,os_unfair_lock_t lock,uint64_t a46,void *context,uint64_t a48,uint64_t a49,uint64_t a50,CFTypeRef cf)
{
  os_unfair_lock_lock(lock);
  os_unfair_lock_unlock(lock);
  if (cf)
    CFRelease(cf);
  objc_autoreleasePoolPop(context);
  _Unwind_Resume(a1);
}

void CA::HDRProcessorInternal::commit_command_buffer(void *a1, int a2)
{
  NSObject *v3;
  dispatch_time_t v4;
  id v5;
  _QWORD block[6];

  block[5] = *MEMORY[0x1E0C80C00];
  v5 = a1;
  if (CA::_root_queue_once == -1)
  {
    if (a2)
    {
LABEL_3:
      v3 = CA::_root_queue;
      v4 = dispatch_time(0, 14000000);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ___ZN2CA20HDRProcessorInternal21commit_command_bufferEPU27objcproto16MTLCommandBuffer11objc_objectb_block_invoke;
      block[3] = &unk_1E15ABB78;
      block[4] = v5;
      dispatch_after(v4, v3, block);
      return;
    }
  }
  else
  {
    dispatch_once(&CA::_root_queue_once, &__block_literal_global_18816);
    a1 = v5;
    if (a2)
      goto LABEL_3;
  }
  if ((objc_msgSend(a1, "commitAndWaitUntilSubmitted") & 1) == 0)
    objc_msgSend(v5, "waitUntilScheduled");

}

void ___ZN2CA20HDRProcessorInternal30create_surface_with_forward_dmEPKNS_6Render7SurfaceEPNS1_6UpdateEPKNS1_17DisplayAttributesEbfNS1_12TextureFlagsEbbbb_block_invoke(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
    objc_msgSend(*(id *)(a1 + 32), "waitUntilScheduled");

}

uint64_t ___ZN2CA20HDRProcessorInternal21commit_command_bufferEPU27objcproto16MTLCommandBuffer11objc_objectb_block_invoke(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "commit");
}

void CA::release_hdr_iosa_param(CA *this, void *a2, void *a3, void *a4)
{
  CA::IOSAManager::unref((uint64_t)this);

}

void CA::shared_event_submit(void *a1, void *a2, uint64_t a3, int a4, int a5)
{
  void *v8;
  uint64_t v11;
  void *v12;
  NSObject *v13;
  const char *v14;
  id v15;
  uint8_t buf[8];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (!a3)
    return;
  if (!a2)
  {
    if (x_log_hook_p())
      goto LABEL_19;
    v13 = x_log_category_sharedevent;
    if (!os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_ERROR))
      return;
    *(_WORD *)buf = 0;
    v14 = "Invalid command buffer";
    goto LABEL_26;
  }
  v8 = *(void **)(a3 + 8);
  if (!v8)
  {
    if (x_log_hook_p())
      goto LABEL_19;
    v13 = x_log_category_sharedevent;
    if (!os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_ERROR))
      return;
    *(_WORD *)buf = 0;
    v14 = "Invalid metal shared event";
    goto LABEL_26;
  }
  v11 = objc_msgSend(v8, "newSharedEventHandle");
  if (!v11)
  {
    if (x_log_hook_p())
      goto LABEL_19;
    v13 = x_log_category_sharedevent;
    if (!os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_ERROR))
      return;
    *(_WORD *)buf = 0;
    v14 = "Invalid metal shared event handle";
    goto LABEL_26;
  }
  v12 = (void *)v11;
  v15 = (id)objc_msgSend(a1, "newSharedEventWithHandle:", v11);

  if (!v15)
  {
    if (x_log_hook_p())
    {
LABEL_19:
      x_log_();
      return;
    }
    v13 = x_log_category_sharedevent;
    if (!os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_ERROR))
      return;
    *(_WORD *)buf = 0;
    v14 = "Invalid metal shared event with handle";
LABEL_26:
    _os_log_impl(&dword_184457000, v13, OS_LOG_TYPE_ERROR, v14, buf, 2u);
    return;
  }
  if (a4)
    objc_msgSend(a2, "encodeWaitForEvent:value:", v15, CA::WindowServer::SharedEvent::get_wait_value(a3, 15, a5));
  else
    objc_msgSend(a2, "encodeSignalEvent:value:", v15, CA::WindowServer::SharedEvent::inc_signal_value(a3, 15, a5));

}

void sub_18466E064(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 80);
  if (v3)
    CFRelease(v3);
  _Unwind_Resume(exception_object);
}

void CA::prewarm_hdrprocessor_metal(CA *this)
{
  id v1;
  void *v2;
  uint64_t v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (CADeviceSupportsHDRProcessing::once[0] != -1)
    dispatch_once(CADeviceSupportsHDRProcessing::once, &__block_literal_global_122);
  if (CADeviceSupportsHDRProcessing::supports_hdr)
  {
    v1 = MTLCreateSystemDefaultDevice();
    if (v1)
    {
      v2 = v1;
      v5 = 0u;
      v4 = 0u;
      v3 = 0x87000000F00;
      *(_QWORD *)&v5 = *MEMORY[0x1E0CA8D88];
      *(_QWORD *)((char *)&v4 + 4) = 0x7267336800000064;

    }
  }
}

BOOL CA::CAHDRProcessor::iomfb_hdr10plus_convert_sei_to_metadata(CA::CAHDRProcessor *this, const __CFData *a2, void *a3)
{
  const char *v5;
  id v6;
  _BOOL8 result;
  id v8;
  NSObject *v9;
  uint8_t buf[4];
  id v11;
  __int16 v12;
  CA::CAHDRProcessor *v13;
  __int16 v14;
  const __CFData *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (hdrprocessing_init_once != -1)
    dispatch_once_f(&hdrprocessing_init_once, 0, (dispatch_function_t)load_hdrprocessing_symbols);
  if (hdr_handle)
  {
    v5 = NSSelectorFromString(CFSTR("parseHDR10PlusSEI:outputMetadata:"));
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v6 = objc_msgSend((id)hdr_processor_class, v5, this, a2);
      if (v6 == (id)-17000)
        return 1;
      v8 = v6;
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v9 = x_log_category_utilities;
        result = os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR);
        if (!result)
          return result;
        *(_DWORD *)buf = 134218496;
        v11 = v8;
        v12 = 2048;
        v13 = this;
        v14 = 2048;
        v15 = a2;
        _os_log_impl(&dword_184457000, v9, OS_LOG_TYPE_ERROR, "HDRProcessor error (%ld) converting hdr10plus SEI to metadata (sei:%p, metadata:%p)", buf, 0x20u);
      }
    }
  }
  return 0;
}

BOOL CA::CAHDRProcessor::can_display_tonemap(CA::CAHDRProcessor *this, CA::Render::Surface *a2)
{
  const __CFDictionary *v3;
  _BOOL8 Bool;

  if (IOSurfaceGetBulkAttachments())
    return 0;
  v3 = IOSurfaceCopyAllValues(this);
  if (CFDictionaryGetValue(v3, (const void *)_kHDRProcessingDolbyVisionRPUDataKey))
  {
    Bool = 0;
    if (!v3)
      return Bool;
    goto LABEL_7;
  }
  Bool = CA_CFDictionaryGetBool(v3, CFSTR("isHLG"));
  if (v3)
LABEL_7:
    CFRelease(v3);
  return Bool;
}

void sub_18466E3D8(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t CA::CAHDRProcessor::should_invalidate_tonemapping(CA::CAHDRProcessor *this, float a2, float a3, float a4, float a5)
{
  unsigned int v5;
  BOOL v6;
  float v7;

  v5 = BYTE11(xmmword_1ECDC6AB0);
  if (BYTE11(xmmword_1ECDC6AB0))
    return 1;
  if (a2 != 0.0 && a3 != 0.0)
    v5 = vabds_f32(a2, a3) > (float)(fminf(a2, a3) * 0.01);
  v6 = a3 == 1.0 && a2 == 1.0;
  v7 = 0.05;
  if (v6)
    v7 = 0.01;
  if (vabds_f32(a4, a5) > (float)(v7 * a4))
    return 1;
  else
    return v5;
}

void native_window_release(_CAEAGLNativeWindow *this, void *a2)
{
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  const void *v18;
  NSObject *v19;
  const void *v20;

  v3 = (unsigned int *)((char *)this + 128);
  do
  {
    v4 = __ldaxr(v3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, v3));
  if (!v5)
  {
    CA::Render::remove_every_observer(this, a2);
    if (*((_QWORD *)this + 18))
    {
      pthread_setspecific(collect_slot, this);
      CAImageQueueInvalidate(*((_QWORD *)this + 18));
      pthread_setspecific(collect_slot, 0);
    }
    v6 = *((_QWORD *)this + 22);
    if (v6)
    {
      do
      {
        v7 = *(_QWORD **)v6;
        if (*(_QWORD *)v6)
        {
          v8 = *((_QWORD *)this + 18);
          if (v8)
          {
            v9 = v7[3];
            if (v9)
              CAImageQueueUnregisterBuffer(v8, v9);
          }
          v10 = (const void *)v7[5];
          if (v10)
            CFRelease(v10);
          free(v7);
        }
        v6 = *(_QWORD *)(v6 + 8);
      }
      while (v6);
      v11 = (_QWORD *)*((_QWORD *)this + 22);
      if (v11)
      {
        do
        {
          v12 = (_QWORD *)v11[1];
          free(v11);
          v11 = v12;
        }
        while (v12);
      }
    }
    v13 = (_QWORD *)*((_QWORD *)this + 13);
    if (v13)
    {
      do
      {
        v14 = (_QWORD *)v13[1];
        free(v13);
        v13 = v14;
      }
      while (v14);
    }
    v15 = (_QWORD *)*((_QWORD *)this + 24);
    if (v15)
    {
      v16 = *((_QWORD *)this + 18);
      if (v16)
      {
        v17 = v15[3];
        if (v17)
          CAImageQueueUnregisterBuffer(v16, v17);
      }
      v18 = (const void *)v15[5];
      if (v18)
        CFRelease(v18);
      free(v15);
    }
    v19 = *((_QWORD *)this + 29);
    if (v19)
      dispatch_release(v19);
    v20 = (const void *)*((_QWORD *)this + 18);
    if (v20)
      CFRelease(v20);
    free(this);
  }
}

uint64_t native_window_attach(uint64_t a1, int a2, _OWORD *a3)
{
  os_unfair_lock_s *v6;
  unsigned int *v7;
  void *v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  unsigned int v14;
  uint32_t v15;
  uint32_t v16;
  uint64_t v17;
  unsigned int *v19;
  unsigned int v20;

  v6 = (os_unfair_lock_s *)(a1 + 136);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 136));
  v7 = (unsigned int *)(a1 + 132);
  if ((*(_DWORD *)(a1 + 132) & 2) != 0)
    goto LABEL_8;
  v8 = *(void **)(a1 + 152);
  if (!v8)
    goto LABEL_8;
  objc_msgSend(v8, "bounds");
  v10 = v9;
  v12 = v11;
  objc_msgSend(*(id *)(a1 + 152), "contentsScale");
  do
    v14 = __ldaxr(v7);
  while (__stlxr(v14 | 2, v7));
  v15 = (v13 * v10);
  v16 = (v13 * v12);
  *(_DWORD *)(a1 + 208) = v15;
  *(_DWORD *)(a1 + 212) = v16;
  CAImageQueueSetSize(*(os_unfair_lock_s **)(a1 + 144), v15, v16);
  *(_DWORD *)(a1 + 184) = a2;
  if (a3)
  {
    *(_OWORD *)(a1 + 64) = *a3;
    *(_OWORD *)(a1 + 80) = a3[1];
  }
  if ((*v7 & 2) != 0)
  {
    v19 = (unsigned int *)(a1 + 128);
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 + 1, v19));
    v17 = 1;
  }
  else
  {
LABEL_8:
    v17 = 0;
  }
  os_unfair_lock_unlock(v6);
  return v17;
}

void sub_18466F1D8(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void native_window_detach(_EAGLNativeWindowObject *a1)
{
  os_unfair_lock_s *p_var2;
  unsigned int *p_var1;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  void *var7;
  malloc_zone_t *malloc_zone;
  _QWORD *v9;
  unsigned int *var5;
  unsigned int v11;
  unsigned int v12;
  void *v13;
  malloc_zone_t *v14;
  _QWORD *v15;
  unsigned int v16;
  _QWORD *var6;
  _QWORD *v18;
  void *v19;

  p_var2 = (os_unfair_lock_s *)&a1[2].var2;
  os_unfair_lock_lock((os_unfair_lock_t)&a1[2].var2);
  p_var1 = &a1[2].var1;
  if ((a1[2].var1 & 2) != 0)
  {
    v4 = *(unsigned int **)&a1[3].var0;
    if (v4)
    {
      do
      {
        v5 = __ldaxr(v4);
        v6 = v5 - 1;
      }
      while (__stlxr(v6, v4));
      if (!v6)
      {
        var7 = a1[2].var7;
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        v9 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
        *v9 = v4;
        v9[1] = var7;
        a1[2].var7 = v9;
      }
      *(_QWORD *)&a1[3].var0 = 0;
    }
    var5 = (unsigned int *)a1[3].var5;
    if (var5)
    {
      do
      {
        v11 = __ldaxr(var5);
        v12 = v11 - 1;
      }
      while (__stlxr(v12, var5));
      if (!v12)
      {
        v13 = a1[2].var7;
        v14 = (malloc_zone_t *)get_malloc_zone();
        v15 = malloc_type_zone_malloc(v14, 0x10uLL, 0x8BB15036uLL);
        *v15 = var5;
        v15[1] = v13;
        a1[2].var7 = v15;
      }
      a1[3].var5 = 0;
    }
    do
      v16 = __ldaxr(p_var1);
    while (__stlxr(v16 & 0xFFFFFFFC, p_var1));
    a1[3].var3 = 0;
    LODWORD(a1[2].var8) = 0;
    a1[3].var5 = 0;
    a1[1].var2 = 0;
    a1[1].var3 = 0;
    *(_QWORD *)&a1[1].var0 = 0;
    var6 = a1[1].var6;
    if (var6)
    {
      do
      {
        v18 = (_QWORD *)var6[1];
        free(var6);
        var6 = v18;
      }
      while (v18);
    }
    a1[1].var6 = 0;
    a1[1].var8 = 0;
    native_window_collect_(a1, 1);
    os_unfair_lock_unlock(p_var2);
    native_window_release((_CAEAGLNativeWindow *)a1, v19);
  }
  else
  {
    os_unfair_lock_unlock(p_var2);
  }
}

void sub_18466F328(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t native_window_swap(_EAGLNativeWindowObject *a1, double a2)
{
  int v4;
  os_unfair_lock_s *p_var2;
  unsigned int *p_var1;
  uint64_t v7;
  double v8;
  int v9;
  int v11;
  unsigned int v12;
  int v13;
  char v14;
  void *var3;
  uint64_t v16;
  void *var5;
  double v18;
  unsigned int v19;
  CA::Transaction *v20;
  CA::Layer **var4;
  CA::Transaction *v22;
  unsigned int v23;
  unsigned int v24;
  unint64_t v25;
  __int128 v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (a2 == 0.0)
    v4 = (LOBYTE(a1[4].var0) >> 3) & 1;
  else
    v4 = 0;
  p_var2 = (os_unfair_lock_s *)&a1[2].var2;
  os_unfair_lock_lock((os_unfair_lock_t)&a1[2].var2);
  p_var1 = &a1[2].var1;
  if ((a1[2].var1 & 2) == 0 || (v7 = *(_QWORD *)&a1[3].var0) == 0)
  {
    os_unfair_lock_unlock(p_var2);
    return 0;
  }
  *(_QWORD *)&a1[3].var0 = 0;
  if (a2 <= 0.0005)
  {
    if ((a1[4].var0 & 4) != 0)
      v9 = 1073741828;
    else
      v9 = 1073741826;
    if ((a1[4].var0 & 4) != 0)
      v4 = 0;
    v8 = 0.0;
    goto LABEL_18;
  }
  v8 = a2 + -0.0005;
  if ((a1[4].var0 & 4) != 0)
    v4 = 0;
  v9 = 0x40000000;
  if (v8 == 0.0)
  {
LABEL_18:
    if (CADeviceSupportsAPT::once != -1)
      dispatch_once(&CADeviceSupportsAPT::once, &__block_literal_global_37);
    if (CADeviceSupportsAPT::supports_apt && !CADeviceDisableMinimumFrameDuration())
    {
      v4 = 0;
      v9 = -1073741824;
      v8 = 0.014;
    }
  }
  v11 = v9 | 0x20;
  if (!v4)
    v11 = v9;
  v12 = v11 | a1[4].var0 & 1;
  if (!(v11 & 1 | a1[4].var0 & 1))
  {
    v13 = v11 | 1;
    if (!CA::Render::fourcc_has_alpha((CA::Render *)*(unsigned int *)(v7 + 12)))
      v12 = v13;
  }
  v14 = image_queue_rotation_from_logical_rotation(CAMetalLayerRotation,BOOL)::invert_table[*(_DWORD *)(v7 + 16) & 7];
  var3 = a1[2].var3;
  v16 = *(_QWORD *)(v7 + 24);
  var5 = a1[2].var5;
  v18 = *(double *)(v7 + 32);
  v26 = xmmword_18474E240;
  if (CAImageQueueInsertImage_((uint64_t)var3, 3, v16, v12, v14, &v26, (uint64_t)release_sample, v7, v8, *(double *)&var5, v18, 0.0, 0.0))
  {
    a1[3].var2 = (void *)v7;
    if ((v12 & 2) != 0)
    {
      do
        v23 = __ldaxr(p_var1);
      while (__stlxr(v23 & 0xFFFFFFFB, p_var1));
    }
    else if ((v12 & 4) != 0)
    {
      do
        v19 = __ldaxr(p_var1);
      while (__stlxr(v19 | 4, p_var1));
      os_unfair_lock_unlock(p_var2);
      v20 = (CA::Transaction *)+[CATransaction lock](CATransaction, "lock");
      if (v4)
        v20 = (CA::Transaction *)+[CATransaction setLowLatency:](CATransaction, "setLowLatency:", 1);
      if (*(double *)&a1[2].var5 != 0.0)
        v20 = (CA::Transaction *)+[CATransaction setInputTime:](CATransaction, "setInputTime:");
      var4 = (CA::Layer **)a1[2].var4;
      if (var4)
      {
        v22 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
        if (!v22)
          v22 = (CA::Transaction *)CA::Transaction::create(v20);
        CA::Layer::set_commit_needed(var4[2], v22, 0);
      }
      +[CATransaction unlock](CATransaction, "unlock");
      goto LABEL_45;
    }
  }
  else
  {
    v24 = pthread_setspecific(collect_slot, a1);
    release_sample(v24, v25, (unsigned int *)v7);
    pthread_setspecific(collect_slot, 0);
  }
  os_unfair_lock_unlock(p_var2);
LABEL_45:
  a1[2].var5 = 0;
  return 1;
}

void sub_18466F5F4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t native_window_swap_zero_time(_EAGLNativeWindowObject *a1, double a2)
{
  return native_window_swap(a1, 0.0);
}

uint64_t native_window_begin_iosurface(_EAGLNativeWindowObject *a1)
{
  os_unfair_lock_s *p_var2;
  unsigned int *p_var1;
  unsigned int *preflight_buffer;
  void *var5;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  int var4;
  uint64_t v11;
  char v12;
  unsigned int *p_var7;
  double v14;
  uint64_t v15;
  uint64_t v16;
  const __CFString *v17;
  uint64_t v18;
  double v19;
  double v20;
  void *v21;
  unsigned int v22;
  dispatch_time_t v24;
  unsigned int v25;
  unsigned int v26;
  void **var7;
  void *v28;
  void *v29;
  malloc_zone_t *malloc_zone;
  int v31;
  malloc_zone_t *v32;
  _QWORD *v33;
  unsigned int v34;
  uint64_t v35;
  void *var3;
  uint64_t v37;
  const void *v38;
  int v39;
  __IOSurface *v40;
  uint32_t oldState;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  p_var2 = (os_unfair_lock_s *)&a1[2].var2;
  os_unfair_lock_lock((os_unfair_lock_t)&a1[2].var2);
  p_var1 = &a1[2].var1;
  if ((a1[2].var1 & 2) == 0 || *(_QWORD *)&a1[3].var0)
  {
LABEL_3:
    os_unfair_lock_unlock(p_var2);
    return 0;
  }
  if ((*p_var1 & 1) != 0)
  {
    do
      v9 = __ldaxr(p_var1);
    while (__stlxr(v9 & 0xFFFFFFFE, p_var1));
    var4 = (int)a1[3].var4;
    LODWORD(a1[3].var4) = 0;
    var5 = a1[3].var5;
    if (var5)
    {
      *(_QWORD *)&a1[3].var0 = var5;
      a1[3].var5 = 0;
      pthread_setspecific(collect_slot, a1);
      CAImageQueueCollect_((uint64_t)a1[2].var3, 0, 0);
      pthread_setspecific(collect_slot, 0);
      call_create_buffer((_CAEAGLNativeWindow *)a1, (CAEAGLBuffer *)var5);
      v11 = mach_absolute_time();
      *((double *)var5 + 4) = CATimeWithHostTime(v11);
      IOSurfaceGetID(*((IOSurfaceRef *)var5 + 5));
      kdebug_trace();
LABEL_13:
      os_unfair_lock_unlock(p_var2);
      goto LABEL_70;
    }
  }
  else
  {
    if ((*p_var1 & 8) == 0)
    {
      preflight_buffer = get_preflight_buffer((_CAEAGLNativeWindow *)a1, a1[3].var3, HIDWORD(a1[3].var3), 0, (CA::Render *)LODWORD(a1[2].var8));
      var5 = preflight_buffer;
      do
        v7 = __ldaxr(preflight_buffer);
      while (__stlxr(v7 + 1, preflight_buffer));
      *(_QWORD *)&a1[3].var0 = preflight_buffer;
      pthread_setspecific(collect_slot, a1);
      CAImageQueueCollect_((uint64_t)a1[2].var3, 0, 0);
      pthread_setspecific(collect_slot, 0);
      call_create_buffer((_CAEAGLNativeWindow *)a1, (CAEAGLBuffer *)var5);
      v8 = mach_absolute_time();
      *((double *)var5 + 4) = CATimeWithHostTime(v8);
      IOSurfaceGetID(*((IOSurfaceRef *)var5 + 5));
      kdebug_trace();
      goto LABEL_13;
    }
    var4 = 0;
  }
  if ((*p_var1 & 8) == 0)
    CAImageQueueConsumeUnconsumed_((uint64_t)a1[2].var3, 0);
  v12 = 0;
  p_var7 = (unsigned int *)&a1[3].var7;
  v14 = 0.0;
  while (1)
  {
    pthread_setspecific(collect_slot, a1);
    v15 = CAImageQueueCollect_((uint64_t)a1[2].var3, 0, 0);
    pthread_setspecific(collect_slot, 0);
    if (v15)
      break;
    os_unfair_lock_unlock(p_var2);
    v18 = mach_absolute_time();
    v19 = CATimeWithHostTime(v18);
    v20 = v19;
    if (v14 == 0.0)
    {
      v14 = v19;
    }
    else if (v12 & 1 | (v19 <= v14 + 0.05) || (dyld_program_sdk_at_least() & 1) != 0)
    {
      if (v20 > *(double *)&a1[2].var6 + v14)
      {
        os_unfair_lock_lock(p_var2);
        goto LABEL_3;
      }
    }
    else
    {
      v21 = (void *)MEMORY[0x186DBE2E4]();
      +[CATransaction flush](CATransaction, "flush");
      objc_autoreleasePoolPop(v21);
      v12 = 1;
    }
    kdebug_trace();
    while (1)
    {
      v22 = __ldaxr(p_var7);
      if (v22 != 2)
        break;
      if (!__stlxr(0, p_var7))
        goto LABEL_38;
    }
LABEL_30:
    __clrex();
    do
    {
      if (__ldaxr(p_var7))
      {
        __clrex();
LABEL_36:
        while (1)
        {
          v25 = __ldaxr(p_var7);
          if (v25 != 2)
            goto LABEL_30;
          if (!__stlxr(0, p_var7))
            goto LABEL_38;
        }
      }
    }
    while (__stlxr(1u, p_var7));
    v24 = dispatch_time(0, (uint64_t)(*(double *)&a1[2].var6 * 1000000000.0));
    if (!dispatch_semaphore_wait((dispatch_semaphore_t)a1[3].var6, v24))
      goto LABEL_36;
    while (1)
    {
      v26 = __ldaxr(p_var7);
      if (v26 != 1)
        break;
      if (!__stlxr(0, p_var7))
        goto LABEL_38;
    }
    __clrex();
    dispatch_semaphore_wait((dispatch_semaphore_t)a1[3].var6, 0xFFFFFFFFFFFFFFFFLL);
LABEL_38:
    kdebug_trace();
    os_unfair_lock_lock(p_var2);
  }
  var7 = (void **)a1[2].var7;
  if (var7)
  {
    v28 = 0;
    while (1)
    {
      var5 = *var7;
      v29 = var7[1];
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, var7);
      a1[2].var7 = v29;
      if (*((_DWORD *)var5 + 1) == LODWORD(a1[3].var3)
        && *((_DWORD *)var5 + 2) == HIDWORD(a1[3].var3)
        && *((_DWORD *)var5 + 4) == var4
        && *((_DWORD *)var5 + 3) == LODWORD(a1[2].var8))
      {
        break;
      }
      if (LODWORD(a1[1].var7) - *((_DWORD *)var5 + 5) < 1)
      {
        v28 = var5;
      }
      else
      {
        release_buffer((_CAEAGLNativeWindow *)a1, (CAEAGLBuffer *)var5);
        v29 = a1[2].var7;
      }
      var7 = (void **)v29;
      if (!v29)
      {
        if (!v28)
          goto LABEL_56;
        var5 = 0;
        v29 = 0;
        v31 = 1;
        goto LABEL_55;
      }
    }
    if (!v28)
      goto LABEL_73;
    v31 = 0;
LABEL_55:
    v32 = (malloc_zone_t *)get_malloc_zone();
    v33 = malloc_type_zone_malloc(v32, 0x10uLL, 0x8BB15036uLL);
    *v33 = v28;
    v33[1] = v29;
    a1[2].var7 = v33;
    if (v31)
      goto LABEL_56;
LABEL_73:
    if (*((_BYTE *)var5 + 48))
    {
      v40 = (__IOSurface *)*((_QWORD *)var5 + 5);
      oldState = 0;
      IOSurfaceSetPurgeable(v40, 0, &oldState);
      *((_BYTE *)var5 + 48) = 0;
    }
  }
  else
  {
LABEL_56:
    var5 = allocate_buffer(a1[3].var3, HIDWORD(a1[3].var3), var4, (CA::Render *)LODWORD(a1[2].var8), (_CAImageQueue *)a1[2].var3, v16, v17);
  }
  if ((call_create_buffer((_CAEAGLNativeWindow *)a1, (CAEAGLBuffer *)var5) & 1) != 0)
  {
    *(_QWORD *)&a1[3].var0 = var5;
    if (var5)
    {
      do
        v34 = __ldaxr((unsigned int *)var5);
      while (__stlxr(v34 + 1, (unsigned int *)var5));
      v35 = mach_absolute_time();
      *((double *)var5 + 4) = CATimeWithHostTime(v35);
      IOSurfaceGetID(*((IOSurfaceRef *)var5 + 5));
    }
  }
  else
  {
    if (var5)
    {
      var3 = a1[2].var3;
      if (var3)
      {
        v37 = *((_QWORD *)var5 + 3);
        if (v37)
          CAImageQueueUnregisterBuffer((uint64_t)var3, v37);
      }
      v38 = (const void *)*((_QWORD *)var5 + 5);
      if (v38)
        CFRelease(v38);
      free(var5);
    }
    var5 = 0;
    *(_QWORD *)&a1[3].var0 = 0;
  }
  kdebug_trace();
  os_unfair_lock_unlock(p_var2);
  if (!var5)
    return 0;
LABEL_70:
  v39 = LODWORD(a1[1].var7) + 1;
  LODWORD(a1[1].var7) = v39;
  *((_DWORD *)var5 + 5) = v39;
  return *((_QWORD *)var5 + 5);
}

void sub_18466FBD8()
{
  os_unfair_lock_s *v0;

  objc_end_catch();
  os_unfair_lock_lock(v0);
  JUMPOUT(0x18466FC08);
}

void native_window_collect(_EAGLNativeWindowObject *a1)
{
  os_unfair_lock_s *p_var2;

  p_var2 = (os_unfair_lock_s *)&a1[2].var2;
  os_unfair_lock_lock((os_unfair_lock_t)&a1[2].var2);
  native_window_collect_(a1, 0);
  os_unfair_lock_unlock(p_var2);
}

void sub_18466FC50(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t native_window_begin_properties(_EAGLNativeWindowObject *a1)
{
  os_unfair_lock_s *p_var2;
  unsigned int *p_var1;
  uint64_t v4;
  uint64_t v6;
  unsigned int v7;
  unsigned int *var5;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  void *var7;
  malloc_zone_t *malloc_zone;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  void *var4;
  unsigned int v18;
  _DWORD *var2;
  _DWORD *preflight_buffer;
  unsigned int v21;
  unsigned int v22;

  p_var2 = (os_unfair_lock_s *)&a1[2].var2;
  os_unfair_lock_lock((os_unfair_lock_t)&a1[2].var2);
  p_var1 = &a1[2].var1;
  if ((a1[2].var1 & 2) == 0 || *(_QWORD *)&a1[3].var0)
  {
    v4 = 0;
    goto LABEL_4;
  }
  if ((a1[4].var0 & 2) != 0)
  {
    v6 = *((_QWORD *)a1[2].var3 + 6);
    if (v6)
    {
      if (*(_DWORD *)(*(_QWORD *)(v6 + 24) + 32))
      {
        do
          v7 = __ldaxr(p_var1);
        while (__stlxr(v7 | 8, p_var1));
        var5 = (unsigned int *)a1[3].var5;
        if (!var5)
          goto LABEL_17;
        do
        {
LABEL_13:
          v10 = __ldaxr(var5);
          v11 = v10 - 1;
        }
        while (__stlxr(v11, var5));
        if (!v11)
        {
          var7 = a1[2].var7;
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          v14 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
          *v14 = var5;
          v14[1] = var7;
          a1[2].var7 = v14;
        }
        a1[3].var5 = 0;
        goto LABEL_17;
      }
    }
  }
  do
    v9 = __ldaxr(p_var1);
  while (__stlxr(v9 & 0xFFFFFFF7, p_var1));
  var5 = (unsigned int *)a1[3].var5;
  if (var5)
    goto LABEL_13;
  var2 = a1[3].var2;
  if (var2)
  {
    preflight_buffer = get_preflight_buffer((_CAEAGLNativeWindow *)a1, a1[3].var3, HIDWORD(a1[3].var3), var2[4], (CA::Render *)LODWORD(a1[2].var8));
    LODWORD(a1[3].var4) = preflight_buffer[4];
    do
      v21 = __ldaxr(p_var1);
    while (__stlxr(v21 | 1, p_var1));
    a1[3].var5 = preflight_buffer;
    do
      v22 = __ldaxr(preflight_buffer);
    while (__stlxr(v22 + 1, preflight_buffer));
    v4 = preflight_buffer[4];
    goto LABEL_4;
  }
LABEL_17:
  v15 = *((_QWORD *)a1[2].var3 + 6);
  if (v15)
  {
    v16 = atomic_load((unint64_t *)(*(_QWORD *)(v15 + 24) + 8));
    if ((v16 & 0x800000000000000) == 0)
      goto LABEL_22;
    if (CADeviceUseCompression::once != -1)
      dispatch_once(&CADeviceUseCompression::once, &__block_literal_global_15);
    if (!CADeviceUseCompression::enable_compression)
      LODWORD(v15) = *(_BYTE *)(*(_QWORD *)(*((_QWORD *)a1[2].var3 + 6) + 24) + 92) & 7;
    else
LABEL_22:
      LODWORD(v15) = 0;
  }
  if (LODWORD(a1[2].var8) == 1111970369)
    v4 = v15 | 0x10;
  else
    v4 = v15;
  var4 = a1[1].var4;
  if (var4)
  {
    if ((((uint64_t (*)(_QWORD, _QWORD, _QWORD, uint64_t))var4)(*(_QWORD *)&a1[1].var0, LODWORD(a1[3].var3), HIDWORD(a1[3].var3), v4) & 1) != 0)v4 = v4;
    else
      v4 &= 0x10u;
  }
  LODWORD(a1[3].var4) = v4;
  do
    v18 = __ldaxr(p_var1);
  while (__stlxr(v18 | 1, p_var1));
LABEL_4:
  os_unfair_lock_unlock(p_var2);
  return v4;
}

void sub_18466FE5C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t native_window_estimated_size(_EAGLNativeWindowObject *a1)
{
  os_unfair_lock_s *p_var2;
  uint64_t v3;
  int var3;
  int var3_high;
  int var4;
  int var8;
  int v8;
  int v9;
  int v10;
  int v11;

  p_var2 = (os_unfair_lock_s *)&a1[2].var2;
  os_unfair_lock_lock((os_unfair_lock_t)&a1[2].var2);
  if ((a1[2].var1 & 2) == 0)
  {
    v3 = 0;
    goto LABEL_21;
  }
  var3 = (int)a1[3].var3;
  var3_high = HIDWORD(a1[3].var3);
  var4 = (int)a1[3].var4;
  var8 = (int)a1[2].var8;
  if (var8 <= 1278555700)
  {
    if (var8 != 875836468)
    {
      if (var8 == 1111970369)
      {
        v8 = 4;
        goto LABEL_14;
      }
      if (var8 != 1278555445)
        goto LABEL_11;
    }
LABEL_12:
    v8 = 2;
    goto LABEL_14;
  }
  if (var8 == 1278555701)
    goto LABEL_12;
  v8 = 8;
  if (var8 != 1380411457 && var8 != 1999908961)
LABEL_11:
    v8 = 0;
LABEL_14:
  if ((var4 & 4) != 0)
    v9 = HIDWORD(a1[3].var3);
  else
    v9 = (int)a1[3].var3;
  v10 = MEMORY[0x186DBD30C](*MEMORY[0x1E0CBBF08], (v8 * v9));
  if ((var4 & 4) != 0)
    v11 = var3;
  else
    v11 = var3_high;
  v3 = MEMORY[0x186DBD30C](*MEMORY[0x1E0CBBEE0], ((v10 + 255) & 0xFFFFFF00) * v11);
LABEL_21:
  os_unfair_lock_unlock(p_var2);
  return v3;
}

void sub_18466FFA4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void will_suspend_callback(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v3;
  uint64_t *i;
  uint64_t v5;
  __IOSurface *v6;
  uint32_t oldState;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v3 = (os_unfair_lock_s *)(a2 + 136);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 136));
  pthread_setspecific(collect_slot, (const void *)a2);
  CAImageQueueConsumeUnconsumed_(*(_QWORD *)(a2 + 144), 1);
  CAImageQueueCollect_(*(_QWORD *)(a2 + 144), 0, 0);
  pthread_setspecific(collect_slot, 0);
  for (i = *(uint64_t **)(a2 + 176); i; i = (uint64_t *)i[1])
  {
    v5 = *i;
    *(_BYTE *)(v5 + 48) = 1;
    v6 = *(__IOSurface **)(v5 + 40);
    oldState = 0;
    IOSurfaceSetPurgeable(v6, 1u, &oldState);
  }
  os_unfair_lock_unlock(v3);
}

void sub_184670088(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

intptr_t layer_collectable_signal(_CAImageQueue *a1, dispatch_semaphore_t *a2)
{
  unsigned int *v2;
  unsigned int v3;
  intptr_t result;

  v2 = (unsigned int *)(a2 + 30);
  do
    v3 = __ldaxr(v2);
  while (__stlxr(2u, v2));
  if (v3 == 1)
    return dispatch_semaphore_signal(a2[29]);
  return result;
}

_DWORD *get_preflight_buffer(_CAEAGLNativeWindow *a1, unsigned int a2, unsigned int a3, int a4, CA::Render *a5)
{
  uint64_t v10;
  const __CFString *v11;
  uint64_t *v12;
  _DWORD *buffer;
  uint64_t v14;
  uint64_t v15;
  const void *v16;

  pthread_setspecific(collect_slot, a1);
  CAImageQueueConsumeUnconsumed_(*((_QWORD *)a1 + 18), 0);
  CAImageQueueCollect_(*((_QWORD *)a1 + 18), 0, 0);
  pthread_setspecific(collect_slot, 0);
  v12 = (uint64_t *)*((_QWORD *)a1 + 22);
  if (v12)
  {
    while (1)
    {
      buffer = (_DWORD *)*v12;
      if (*(_DWORD *)(*v12 + 4) == a2 && buffer[2] == a3 && buffer[4] == a4 && buffer[3] == (_DWORD)a5)
        break;
      v12 = (uint64_t *)v12[1];
      if (*((_DWORD *)a1 + 28) - buffer[5] >= 1)
      {
        *((_QWORD *)a1 + 22) = x_list_remove(*((_QWORD **)a1 + 22), (uint64_t)buffer);
        release_buffer(a1, (CAEAGLBuffer *)buffer);
      }
      if (!v12)
        goto LABEL_9;
    }
    *((_QWORD *)a1 + 22) = x_list_remove(*((_QWORD **)a1 + 22), *v12);
  }
  else
  {
LABEL_9:
    buffer = allocate_buffer(a2, a3, a4, a5, *((_CAImageQueue **)a1 + 18), v10, v11);
    if ((call_create_buffer(a1, (CAEAGLBuffer *)buffer) & 1) == 0 && buffer)
    {
      v14 = *((_QWORD *)a1 + 18);
      if (v14)
      {
        v15 = *((_QWORD *)buffer + 3);
        if (v15)
          CAImageQueueUnregisterBuffer(v14, v15);
      }
      v16 = (const void *)*((_QWORD *)buffer + 5);
      if (v16)
        CFRelease(v16);
      free(buffer);
      return 0;
    }
  }
  return buffer;
}

void release_buffer(_CAEAGLNativeWindow *a1, CAEAGLBuffer *a2)
{
  CAEAGLBuffer **v4;
  CAEAGLBuffer **v5;
  CAEAGLBuffer **v6;
  CAEAGLBuffer *v7;
  malloc_zone_t *malloc_zone;
  void (*v9)(_QWORD, _QWORD);
  uint64_t v10;
  uint64_t v11;
  const void *v12;

  v5 = (CAEAGLBuffer **)((char *)a1 + 104);
  v4 = (CAEAGLBuffer **)*((_QWORD *)a1 + 13);
  if (v4)
  {
    if (*v4 == a2)
    {
LABEL_6:
      v7 = v4[1];
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v4);
      *v5 = v7;
      --*((_QWORD *)a1 + 15);
      v9 = (void (*)(_QWORD, _QWORD))*((_QWORD *)a1 + 10);
      if (v9)
        v9(*((_QWORD *)a1 + 8), *((_QWORD *)a2 + 5));
    }
    else
    {
      while (1)
      {
        v6 = v4;
        v4 = (CAEAGLBuffer **)v4[1];
        if (!v4)
          break;
        if (*v4 == a2)
        {
          v5 = v6 + 1;
          goto LABEL_6;
        }
      }
    }
  }
  if (*((CAEAGLBuffer **)a1 + 25) == a2)
  {
    *((_QWORD *)a1 + 25) = 0;
    if (!a2)
      return;
  }
  else if (!a2)
  {
    return;
  }
  v10 = *((_QWORD *)a1 + 18);
  if (v10)
  {
    v11 = *((_QWORD *)a2 + 3);
    if (v11)
      CAImageQueueUnregisterBuffer(v10, v11);
  }
  v12 = (const void *)*((_QWORD *)a2 + 5);
  if (v12)
    CFRelease(v12);
  free(a2);
}

_DWORD *allocate_buffer(unsigned int a1, unsigned int a2, int a3, CA::Render *this, _CAImageQueue *a5, uint64_t a6, const __CFString *a7)
{
  int v8;
  unsigned int v10;
  int v12;
  __IOSurface *iosurface_with_pixel_format;
  _DWORD *v14;

  v8 = (int)this;
  v10 = a2;
  if ((a3 & 4) != 0)
  {
    v12 = a1;
  }
  else
  {
    a2 = a1;
    v12 = v10;
  }
  iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format(this, a2, v12, (MEMORY[0xFFFFFC020] >> 9) & 4, 0, CFSTR("CAEAGLLayer Drawable"), a7);
  v14 = malloc_type_calloc(1uLL, 0x38uLL, 0x10200404E9E88B7uLL);
  v14[1] = a1;
  v14[2] = v10;
  v14[3] = v8;
  v14[4] = a3;
  *((_QWORD *)v14 + 5) = iosurface_with_pixel_format;
  if (a5)
    *((_QWORD *)v14 + 3) = CAImageQueueRegisterIOSurfaceBuffer((_anonymous_namespace_ *)a5, iosurface_with_pixel_format, 0);
  return v14;
}

uint64_t call_create_buffer(_CAEAGLNativeWindow *a1, CAEAGLBuffer *a2)
{
  uint64_t (*v3)(_QWORD, _QWORD);
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  malloc_zone_t *malloc_zone;
  _QWORD *v9;

  if (!a2)
    return 1;
  v3 = (uint64_t (*)(_QWORD, _QWORD))*((_QWORD *)a1 + 9);
  if (v3)
  {
    v5 = *((_QWORD *)a1 + 13);
    if (v5)
    {
      while (*(CAEAGLBuffer **)v5 != a2)
      {
        v5 = *(_QWORD *)(v5 + 8);
        if (!v5)
          goto LABEL_6;
      }
    }
    else
    {
LABEL_6:
      result = v3(*((_QWORD *)a1 + 8), *((_QWORD *)a2 + 5));
      if (!(_DWORD)result)
        return result;
      v7 = *((_QWORD *)a1 + 13);
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      v9 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
      *v9 = a2;
      v9[1] = v7;
      *((_QWORD *)a1 + 13) = v9;
      ++*((_QWORD *)a1 + 15);
    }
  }
  return 1;
}

void native_window_collect_(_EAGLNativeWindowObject *a1, int a2)
{
  CAEAGLBuffer **var7;
  CAEAGLBuffer **v5;
  CAEAGLBuffer **v6;

  pthread_setspecific(collect_slot, a1);
  CAImageQueueCollect_((uint64_t)a1[2].var3, a2, 0);
  pthread_setspecific(collect_slot, 0);
  var7 = (CAEAGLBuffer **)a1[2].var7;
  if (var7)
  {
    a1[2].var7 = 0;
    v5 = var7;
    do
    {
      release_buffer((_CAEAGLNativeWindow *)a1, *v5);
      v5 = (CAEAGLBuffer **)v5[1];
    }
    while (v5);
    do
    {
      v6 = (CAEAGLBuffer **)var7[1];
      free(var7);
      var7 = v6;
    }
    while (v6);
  }
}

void release_sample(unsigned int a1, unint64_t a2, unsigned int *a3)
{
  unsigned int v4;
  unsigned int v5;
  _CAEAGLNativeWindow *v6;
  _CAEAGLNativeWindow *v7;
  uint64_t v8;
  malloc_zone_t *malloc_zone;
  _QWORD *v10;
  const void *v11;

  do
  {
    v4 = __ldaxr(a3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, a3));
  if (!v5)
  {
    v6 = (_CAEAGLNativeWindow *)pthread_getspecific(collect_slot);
    if (v6)
    {
      v7 = v6;
      if (*((_QWORD *)v6 + 15) > *((_QWORD *)v6 + 31)
        && (*((_DWORD *)v6 + 33) & 8) != 0
        && (int)(*((_DWORD *)v6 + 28) - a3[5]) >= 1)
      {
        release_buffer(v6, (CAEAGLBuffer *)a3);
      }
      else
      {
        v8 = *((_QWORD *)v6 + 22);
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        v10 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
        *v10 = a3;
        v10[1] = v8;
        *((_QWORD *)v7 + 22) = v10;
      }
    }
    else if (a3)
    {
      v11 = (const void *)*((_QWORD *)a3 + 5);
      if (v11)
        CFRelease(v11);
      free(a3);
    }
  }
}

CFStringRef displayTimerCopyFormatDescription(const void *a1, const __CFDictionary *a2)
{
  const __CFAllocator *v4;

  v4 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, a2, CFSTR("<CADisplayTimer %p>"), a1);
}

CFStringRef displayTimerCopyDebugDescription(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CADisplayTimer %p>"), a1);
}

void CA::Render::BackdropLayer::show(CA::Render::BackdropLayer *this, int a2, char a3)
{
  _BOOL4 v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  int v12;
  _BOOL4 v13;
  NSObject *v14;
  const char *v15;
  NSObject *v16;
  double v17;
  NSObject *v18;
  double v19;
  NSObject *v20;
  double v21;
  double v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v36;
  NSObject *v37;
  const char *v38;
  float v39;
  uint64_t v40;
  uint8_t buf[4];
  _BYTE v42[10];
  _BYTE v43[10];
  uint64_t v44;
  __int16 v45;
  uint64_t v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v6 = x_log_hook_p();
  if ((a3 & 1) == 0)
  {
    if (v6)
    {
      x_log_();
    }
    else
    {
      v7 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        v8 = *((_QWORD *)this + 2);
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)v42 = v8;
        _os_log_impl(&dword_184457000, v7, OS_LOG_TYPE_DEFAULT, "(backdrop-layer %ld", buf, 0xCu);
      }
    }
    if ((*((_BYTE *)this + 13) & 1) == 0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v9 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184457000, v9, OS_LOG_TYPE_DEFAULT, "(enabled false)", buf, 2u);
        }
      }
    }
    if (*((_QWORD *)this + 3))
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v10 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          v11 = *((_QWORD *)this + 3) + 28;
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)v42 = v11;
          _os_log_impl(&dword_184457000, v10, OS_LOG_TYPE_DEFAULT, "(group \"%s\")", buf, 0xCu);
        }
      }
    }
    if (*((_BYTE *)this + 80))
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      v12 = *((unsigned __int8 *)this + 80);
      v13 = x_log_hook_p();
      if (v12 == 2)
      {
        if (v13)
          goto LABEL_21;
        v14 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v15 = "(groupNamespace global)";
LABEL_26:
          _os_log_impl(&dword_184457000, v14, OS_LOG_TYPE_DEFAULT, v15, buf, 2u);
        }
      }
      else
      {
        if (v13)
        {
LABEL_21:
          x_log_();
          goto LABEL_27;
        }
        v14 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v15 = "(groupNamespace hostingNamespacedContext)";
          goto LABEL_26;
        }
      }
    }
LABEL_27:
    if (*((float *)this + 8) != 1.0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v16 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          v17 = *((float *)this + 8);
          *(_DWORD *)buf = 134217984;
          *(double *)v42 = v17;
          _os_log_impl(&dword_184457000, v16, OS_LOG_TYPE_DEFAULT, "(scale %g)", buf, 0xCu);
        }
      }
    }
    if (*((float *)this + 10) != 0.0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v18 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          v19 = *((float *)this + 10);
          *(_DWORD *)buf = 134217984;
          *(double *)v42 = v19;
          _os_log_impl(&dword_184457000, v18, OS_LOG_TYPE_DEFAULT, "(zoom %g)", buf, 0xCu);
        }
      }
    }
    if (*((float *)this + 9) != 0.0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v20 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          v21 = *((float *)this + 9);
          *(_DWORD *)buf = 134217984;
          *(double *)v42 = v21;
          _os_log_impl(&dword_184457000, v20, OS_LOG_TYPE_DEFAULT, "(marginWidth %g)", buf, 0xCu);
        }
      }
    }
    v22 = *((double *)this + 8);
    if (v22 >= *((double *)this + 9))
      v22 = *((double *)this + 9);
    if (v22 > 0.0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v23 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          v24 = *((_QWORD *)this + 6);
          v25 = *((_QWORD *)this + 7);
          v26 = *((_QWORD *)this + 8);
          v27 = *((_QWORD *)this + 9);
          *(_DWORD *)buf = 134218752;
          *(_QWORD *)v42 = v24;
          *(_WORD *)&v42[8] = 2048;
          *(_QWORD *)v43 = v25;
          *(_WORD *)&v43[8] = 2048;
          v44 = v26;
          v45 = 2048;
          v46 = v27;
          _os_log_impl(&dword_184457000, v23, OS_LOG_TYPE_DEFAULT, "(backdropRect [%g %g; %g %g])", buf, 0x2Au);
        }
      }
    }
    if ((*((_BYTE *)this + 13) & 0x10) != 0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v28 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184457000, v28, OS_LOG_TYPE_DEFAULT, "(captureOnly true)", buf, 2u);
        }
      }
    }
    if ((*((_BYTE *)this + 13) & 2) != 0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v29 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184457000, v29, OS_LOG_TYPE_DEFAULT, "(allowsInPlaceFiltering true)", buf, 2u);
        }
      }
    }
    if ((*((_BYTE *)this + 13) & 0x20) != 0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v30 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184457000, v30, OS_LOG_TYPE_DEFAULT, "(reducesCaptureBitDepth true)", buf, 2u);
        }
      }
    }
    if ((*((_BYTE *)this + 14) & 1) != 0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v31 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184457000, v31, OS_LOG_TYPE_DEFAULT, "(ignoresScreenClip true)", buf, 2u);
        }
      }
    }
    if ((*((_BYTE *)this + 13) & 4) != 0)
    {
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v32 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184457000, v32, OS_LOG_TYPE_DEFAULT, "(tracksLuma true)", buf, 2u);
        }
      }
    }
    v33 = *((_QWORD *)this + 11);
    if (v33)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v33 + 36));
      v34 = *(_QWORD *)(v33 + 40);
      if (v34)
      {
        os_unfair_lock_lock((os_unfair_lock_t)(v34 + 40));
        v35 = *(_QWORD *)(v34 + 48);
        if (v35)
        {
          v40 = 0;
          v39 = 0.0;
          (*(void (**)(uint64_t, char *, uint64_t *, float *))(*(_QWORD *)v35 + 24))(v35, (char *)&v40 + 4, &v40, &v39);
          CA::Render::show_newline((CA::Render *)(a2 + 1));
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            v36 = x_log_category_render;
            if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 67109632;
              *(_DWORD *)v42 = HIDWORD(v40);
              *(_WORD *)&v42[4] = 1024;
              *(_DWORD *)&v42[6] = v40;
              *(_WORD *)v43 = 2048;
              *(double *)&v43[2] = v39;
              _os_log_impl(&dword_184457000, v36, OS_LOG_TYPE_DEFAULT, "(buffer [%d x %d] scale %g)", buf, 0x18u);
            }
          }
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(v34 + 40));
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v33 + 36));
    }
    if (x_log_hook_p())
    {
      x_log_();
      return;
    }
    v37 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v38 = ")";
LABEL_87:
      _os_log_impl(&dword_184457000, v37, OS_LOG_TYPE_DEFAULT, v38, buf, 2u);
      return;
    }
    return;
  }
  if (v6)
  {
    x_log_();
    return;
  }
  v37 = x_log_category_render;
  if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    v38 = "backdrop-layer";
    goto LABEL_87;
  }
}

uint64_t CA::Render::BackdropLayer::get_property(CA::Render::BackdropLayer *this, uint64_t a2, const unsigned int *a3, unint64_t a4, double *a5, double **a6)
{
  int v6;
  BOOL v7;
  float v9;
  double v10;
  double v11;
  double v12;

  if (a4 >= 4)
  {
    if (a6)
      *a6 = a5;
    if (!a2)
      return a2;
    if (a2 == 1)
    {
      a2 = 0;
      v6 = *a3;
      if (*(int *)a3 > 365)
      {
        switch(v6)
        {
          case 366:
            v9 = *((float *)this + 9);
            break;
          case 475:
            v9 = *((float *)this + 8);
            break;
          case 605:
            v9 = *((float *)this + 10);
            break;
          default:
            return a2;
        }
        v12 = v9;
      }
      else
      {
        switch(v6)
        {
          case 51:
            v10 = *((double *)this + 6);
            *a5 = v10;
            v11 = *((double *)this + 7);
            a5[1] = v11;
            a5[2] = *((double *)this + 8) + v10;
            a5[3] = *((double *)this + 9) + v11;
            return 4;
          case 80:
            v7 = (*((_DWORD *)this + 3) & 0x1000) == 0;
            break;
          case 208:
            v7 = (*((_DWORD *)this + 3) & 0x100) == 0;
            break;
          default:
            return a2;
        }
        v12 = 0.0;
        if (!v7)
          v12 = 1.0;
      }
      *a5 = v12;
      return 1;
    }
    if (*a3 == 51)
      return CA::Render::get_rect_property((CA::Render::BackdropLayer *)((char *)this + 48), (const CA::Rect *)(a2 - 1), (int *)a3 + 1, (unsigned int *)a5, a5);
  }
  return 0;
}

double *CA::Render::BackdropLayer::get_backdrop_bounds(CA::Render::BackdropLayer *this, const CA::Render::Layer *a2, CA::Rect *a3)
{
  double v3;
  double v4;
  double v5;
  char *v6;
  char *v7;
  uint64_t v8;

  v3 = *((double *)this + 8);
  v4 = *((double *)this + 9);
  if (v3 >= v4)
    v5 = *((double *)this + 9);
  else
    v5 = *((double *)this + 8);
  if (v5 > 0.0)
  {
    v6 = (char *)this + 48;
    v7 = (char *)this + 56;
  }
  else
  {
    v6 = (char *)a2 + 64;
    v7 = (char *)a2 + 72;
    v3 = *((double *)a2 + 10);
    v4 = *((double *)a2 + 11);
  }
  v8 = *(_QWORD *)v7;
  *(_QWORD *)a3 = *(_QWORD *)v6;
  *((_QWORD *)a3 + 1) = v8;
  *((double *)a3 + 2) = v3;
  *((double *)a3 + 3) = v4;
  return CA::BoundsImpl::inset((double *)a3, (float)-*((float *)this + 9), (float)-*((float *)this + 9));
}

void std::__introsort<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *,false>(uint64_t a1, __int128 *a2, uint64_t a3, char a4)
{
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _OWORD *v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  __int128 *v34;
  __int128 *v35;
  unsigned int v36;
  __int128 *v37;
  unsigned int v38;
  __int128 *v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  BOOL v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  unint64_t v50;
  unsigned int v51;
  __int128 *v52;
  __int128 *v53;
  unsigned int v54;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 *v61;
  BOOL v63;
  uint64_t v64;
  _QWORD *v65;
  __int128 *v66;
  uint64_t v67;
  uint64_t v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  unsigned int v84;
  uint64_t v85;
  uint64_t v86;
  int64_t v87;
  int64_t v88;
  int64_t v89;
  uint64_t v90;
  unint64_t v91;
  unsigned int v92;
  unsigned int v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  unint64_t v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  uint64_t v107;
  uint64_t v108;
  unsigned int v109;
  unsigned int v110;
  int64_t v111;
  uint64_t v112;
  __int128 *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  unsigned int v131;
  unsigned int v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 *v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  unint64_t v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  unint64_t v155;
  __int128 *v156;
  uint64_t v157;
  uint64_t v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  unint64_t v165;
  unint64_t v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  uint64_t v173;
  unint64_t v174;
  __int128 *v175;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  __int128 v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  uint64_t v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  __int128 v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;

LABEL_1:
  v175 = (__int128 *)((char *)a2 - 168);
  v7 = a1;
  while (2)
  {
    a1 = v7;
    v8 = (uint64_t)a2 - v7;
    v9 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)((uint64_t)a2 - v7) >> 3);
    switch(v9)
    {
      case 0:
      case 1:
        return;
      case 2:
        if (*(_DWORD *)(*((_QWORD *)a2 - 20) + 112) < *(_DWORD *)(*(_QWORD *)(v7 + 8) + 112))
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((__int128 *)v7, v175);
        return;
      case 3:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(v7, v7 + 168, (uint64_t)v175);
        return;
      case 4:
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(v7, v7 + 168, v7 + 336, (uint64_t)v175);
        return;
      case 5:
        std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *,0>(v7, v7 + 168, v7 + 336, v7 + 504, (uint64_t)v175);
        return;
      default:
        if (v8 <= 4031)
        {
          v61 = (__int128 *)(v7 + 168);
          v63 = (__int128 *)v7 == a2 || v61 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v63)
            {
              v64 = 0;
              v65 = (_QWORD *)v7;
              do
              {
                v66 = v61;
                v67 = v65[22];
                if (*(_DWORD *)(v67 + 112) < *(_DWORD *)(v65[1] + 112))
                {
                  v68 = *(_QWORD *)v66;
                  v69 = *(_OWORD *)(v65 + 23);
                  v70 = *(_OWORD *)(v65 + 25);
                  v71 = *(_OWORD *)(v65 + 27);
                  v72 = *(_OWORD *)(v65 + 29);
                  v73 = *(_OWORD *)(v65 + 33);
                  v198 = *(_OWORD *)(v65 + 35);
                  v205 = *(_OWORD *)(v65 + 37);
                  v74 = *(_OWORD *)(v65 + 31);
                  v219 = v65[41];
                  v75 = v64;
                  v212 = *(_OWORD *)(v65 + 39);
                  while (1)
                  {
                    v76 = v75;
                    v77 = v7 + v75;
                    v78 = *(_OWORD *)(v77 + 16);
                    *(_OWORD *)(v77 + 168) = *(_OWORD *)v77;
                    *(_OWORD *)(v77 + 184) = v78;
                    v79 = *(_OWORD *)(v77 + 48);
                    *(_OWORD *)(v77 + 200) = *(_OWORD *)(v77 + 32);
                    *(_OWORD *)(v77 + 216) = v79;
                    v80 = *(_OWORD *)(v77 + 80);
                    *(_OWORD *)(v77 + 232) = *(_OWORD *)(v77 + 64);
                    *(_OWORD *)(v77 + 248) = v80;
                    v81 = *(_OWORD *)(v77 + 112);
                    *(_OWORD *)(v77 + 264) = *(_OWORD *)(v77 + 96);
                    v82 = *(_OWORD *)(v77 + 128);
                    v83 = *(_OWORD *)(v77 + 144);
                    *(_QWORD *)(v77 + 328) = *(_QWORD *)(v77 + 160);
                    *(_OWORD *)(v77 + 296) = v82;
                    *(_OWORD *)(v77 + 312) = v83;
                    *(_OWORD *)(v77 + 280) = v81;
                    if (!v76)
                      break;
                    v84 = *(_DWORD *)(*(_QWORD *)(v77 - 160) + 112);
                    v75 = v76 - 168;
                    if (*(_DWORD *)(v67 + 112) >= v84)
                    {
                      v85 = v7 + v76 + 112;
                      v86 = v7 + v75 + 168;
                      goto LABEL_74;
                    }
                  }
                  v85 = v77 + 112;
                  v86 = v7;
LABEL_74:
                  *(_QWORD *)v86 = v68;
                  *(_QWORD *)(v86 + 8) = v67;
                  *(_OWORD *)(v86 + 16) = v69;
                  *(_OWORD *)(v86 + 32) = v70;
                  *(_OWORD *)(v86 + 48) = v71;
                  *(_OWORD *)(v86 + 64) = v72;
                  *(_OWORD *)(v86 + 80) = v74;
                  *(_OWORD *)(v86 + 96) = v73;
                  *(_QWORD *)(v85 + 48) = v219;
                  *(_OWORD *)(v85 + 16) = v205;
                  *(_OWORD *)(v85 + 32) = v212;
                  *(_OWORD *)v85 = v198;
                }
                v61 = (__int128 *)((char *)v66 + 168);
                v64 += 168;
                v65 = v66;
              }
              while ((__int128 *)((char *)v66 + 168) != a2);
            }
          }
          else if (!v63)
          {
            v155 = v7 + 64;
            do
            {
              v156 = v61;
              v157 = *(_QWORD *)(a1 + 176);
              if (*(_DWORD *)(v157 + 112) < *(_DWORD *)(*(_QWORD *)(a1 + 8) + 112))
              {
                v158 = *(_QWORD *)v156;
                v159 = *(_OWORD *)(a1 + 184);
                v160 = *(_OWORD *)(a1 + 200);
                v161 = *(_OWORD *)(a1 + 216);
                v162 = *(_OWORD *)(a1 + 232);
                v163 = *(_OWORD *)(a1 + 264);
                v201 = *(_OWORD *)(a1 + 280);
                v208 = *(_OWORD *)(a1 + 296);
                v164 = *(_OWORD *)(a1 + 248);
                v222 = *(_QWORD *)(a1 + 328);
                v165 = v155;
                v215 = *(_OWORD *)(a1 + 312);
                do
                {
                  v166 = v165;
                  v167 = *(_OWORD *)(v165 - 48);
                  *(_OWORD *)(v165 + 104) = *(_OWORD *)(v165 - 64);
                  *(_OWORD *)(v165 + 120) = v167;
                  v168 = *(_OWORD *)(v165 - 16);
                  *(_OWORD *)(v165 + 136) = *(_OWORD *)(v165 - 32);
                  *(_OWORD *)(v165 + 152) = v168;
                  v169 = *(_OWORD *)(v165 + 16);
                  *(_OWORD *)(v165 + 168) = *(_OWORD *)v165;
                  *(_OWORD *)(v165 + 184) = v169;
                  v170 = *(_OWORD *)(v165 + 48);
                  *(_OWORD *)(v165 + 200) = *(_OWORD *)(v165 + 32);
                  v171 = *(_OWORD *)(v165 + 64);
                  v172 = *(_OWORD *)(v165 + 80);
                  *(_QWORD *)(v165 + 264) = *(_QWORD *)(v165 + 96);
                  *(_OWORD *)(v165 + 248) = v172;
                  *(_OWORD *)(v165 + 232) = v171;
                  *(_OWORD *)(v165 + 216) = v170;
                  v173 = *(_QWORD *)(v165 - 224);
                  v165 -= 168;
                }
                while (*(_DWORD *)(v157 + 112) < *(_DWORD *)(v173 + 112));
                v174 = v166 + 48;
                *(_QWORD *)(v165 + 104) = v158;
                *(_QWORD *)(v165 + 112) = v157;
                *(_OWORD *)(v165 + 120) = v159;
                *(_OWORD *)(v165 + 136) = v160;
                *(_OWORD *)(v165 + 152) = v161;
                *(_OWORD *)(v165 + 168) = v162;
                *(_OWORD *)(v165 + 184) = v164;
                *(_OWORD *)(v165 + 200) = v163;
                *(_QWORD *)(v174 + 48) = v222;
                *(_OWORD *)(v174 + 16) = v208;
                *(_OWORD *)(v174 + 32) = v215;
                *(_OWORD *)v174 = v201;
              }
              v61 = (__int128 *)((char *)v156 + 168);
              v155 += 168;
              a1 = (uint64_t)v156;
            }
            while ((__int128 *)((char *)v156 + 168) != a2);
          }
          return;
        }
        if (!a3)
        {
          if ((__int128 *)v7 != a2)
          {
            v87 = (unint64_t)(v9 - 2) >> 1;
            v88 = v87;
            do
            {
              v89 = v88;
              if (v87 >= v88)
              {
                v90 = (2 * v88) | 1;
                v91 = v7 + 168 * v90;
                if (2 * v88 + 2 < v9)
                {
                  v92 = *(_DWORD *)(*(_QWORD *)(v7 + 168 * v90 + 8) + 112);
                  v93 = *(_DWORD *)(*(_QWORD *)(v91 + 176) + 112);
                  v91 += 168 * (v92 < v93);
                  if (v92 < v93)
                    v90 = 2 * v88 + 2;
                }
                v94 = *(_QWORD *)(v7 + 168 * v88 + 8);
                if (*(_DWORD *)(*(_QWORD *)(v91 + 8) + 112) >= *(_DWORD *)(v94 + 112))
                {
                  v95 = v7 + 168 * v89;
                  v96 = *(_QWORD *)v95;
                  v97 = *(_OWORD *)(v95 + 16);
                  v98 = *(_OWORD *)(v95 + 32);
                  v99 = *(_OWORD *)(v95 + 48);
                  v100 = *(_OWORD *)(v95 + 64);
                  v101 = *(_OWORD *)(v95 + 80);
                  v102 = *(_OWORD *)(v95 + 96);
                  v220 = *(_QWORD *)(v95 + 160);
                  v206 = *(_OWORD *)(v95 + 128);
                  v213 = *(_OWORD *)(v95 + 144);
                  v199 = *(_OWORD *)(v95 + 112);
                  do
                  {
                    v103 = v91;
                    *(_OWORD *)v95 = *(_OWORD *)v91;
                    *(_OWORD *)(v95 + 16) = *(_OWORD *)(v91 + 16);
                    *(_OWORD *)(v95 + 32) = *(_OWORD *)(v91 + 32);
                    *(_OWORD *)(v95 + 48) = *(_OWORD *)(v91 + 48);
                    *(_OWORD *)(v95 + 64) = *(_OWORD *)(v91 + 64);
                    *(_OWORD *)(v95 + 80) = *(_OWORD *)(v91 + 80);
                    *(_OWORD *)(v95 + 96) = *(_OWORD *)(v91 + 96);
                    v104 = *(_OWORD *)(v91 + 112);
                    v105 = *(_OWORD *)(v91 + 128);
                    v106 = *(_OWORD *)(v91 + 144);
                    *(_QWORD *)(v95 + 160) = *(_QWORD *)(v91 + 160);
                    *(_OWORD *)(v95 + 128) = v105;
                    *(_OWORD *)(v95 + 144) = v106;
                    *(_OWORD *)(v95 + 112) = v104;
                    if (v87 < v90)
                      break;
                    v107 = (2 * v90) | 1;
                    v91 = v7 + 168 * v107;
                    v108 = 2 * v90 + 2;
                    if (v108 < v9)
                    {
                      v109 = *(_DWORD *)(*(_QWORD *)(v7 + 168 * v107 + 8) + 112);
                      v110 = *(_DWORD *)(*(_QWORD *)(v91 + 176) + 112);
                      v91 += 168 * (v109 < v110);
                      if (v109 < v110)
                        v107 = v108;
                    }
                    v95 = v103;
                    v90 = v107;
                  }
                  while (*(_DWORD *)(*(_QWORD *)(v91 + 8) + 112) >= *(_DWORD *)(v94 + 112));
                  *(_QWORD *)v103 = v96;
                  *(_QWORD *)(v103 + 8) = v94;
                  *(_OWORD *)(v103 + 16) = v97;
                  *(_OWORD *)(v103 + 32) = v98;
                  *(_OWORD *)(v103 + 48) = v99;
                  *(_OWORD *)(v103 + 64) = v100;
                  *(_OWORD *)(v103 + 80) = v101;
                  *(_OWORD *)(v103 + 96) = v102;
                  *(_OWORD *)(v103 + 112) = v199;
                  *(_OWORD *)(v103 + 128) = v206;
                  *(_OWORD *)(v103 + 144) = v213;
                  *(_QWORD *)(v103 + 160) = v220;
                }
              }
              v88 = v89 - 1;
            }
            while (v89);
            v111 = ((unint64_t)a2 - v7) / 0xA8;
            do
            {
              v112 = 0;
              v113 = a2;
              v189 = *(_OWORD *)v7;
              v115 = *(_QWORD *)(v7 + 16);
              v114 = *(_QWORD *)(v7 + 24);
              v117 = *(_QWORD *)(v7 + 32);
              v116 = *(_QWORD *)(v7 + 40);
              v119 = *(_QWORD *)(v7 + 48);
              v118 = *(_QWORD *)(v7 + 56);
              v121 = *(_QWORD *)(v7 + 64);
              v120 = *(_QWORD *)(v7 + 72);
              v123 = *(_QWORD *)(v7 + 80);
              v122 = *(_QWORD *)(v7 + 88);
              v125 = *(_QWORD *)(v7 + 96);
              v124 = *(_QWORD *)(v7 + 104);
              v194 = *(_QWORD *)(v7 + 160);
              v126 = v7;
              v192 = *(_OWORD *)(v7 + 128);
              v193 = *(_OWORD *)(v7 + 144);
              v191 = *(_OWORD *)(v7 + 112);
              do
              {
                v127 = v112 + 1;
                v128 = v126 + 168 * (v112 + 1);
                v129 = (2 * v112) | 1;
                v130 = 2 * v112 + 2;
                if (v130 < v111)
                {
                  v131 = *(_DWORD *)(*(_QWORD *)(v126 + 168 * v127 + 8) + 112);
                  v132 = *(_DWORD *)(*(_QWORD *)(v128 + 176) + 112);
                  v128 += 168 * (v131 < v132);
                  if (v131 < v132)
                    v129 = v130;
                }
                *(_OWORD *)v126 = *(_OWORD *)v128;
                *(_OWORD *)(v126 + 16) = *(_OWORD *)(v128 + 16);
                *(_OWORD *)(v126 + 32) = *(_OWORD *)(v128 + 32);
                *(_OWORD *)(v126 + 48) = *(_OWORD *)(v128 + 48);
                *(_OWORD *)(v126 + 64) = *(_OWORD *)(v128 + 64);
                *(_OWORD *)(v126 + 80) = *(_OWORD *)(v128 + 80);
                *(_OWORD *)(v126 + 96) = *(_OWORD *)(v128 + 96);
                v133 = *(_OWORD *)(v128 + 112);
                v134 = *(_OWORD *)(v128 + 128);
                v135 = *(_OWORD *)(v128 + 144);
                *(_QWORD *)(v126 + 160) = *(_QWORD *)(v128 + 160);
                *(_OWORD *)(v126 + 128) = v134;
                *(_OWORD *)(v126 + 144) = v135;
                *(_OWORD *)(v126 + 112) = v133;
                v126 = v128;
                v112 = v129;
              }
              while (v129 <= (uint64_t)((unint64_t)(v111 - 2) >> 1));
              v136 = (__int128 *)(v128 + 112);
              a2 = (__int128 *)((char *)a2 - 168);
              if ((__int128 *)v128 == (__int128 *)((char *)v113 - 168))
              {
                *(_OWORD *)v128 = v189;
                *(_QWORD *)(v128 + 16) = v115;
                *(_QWORD *)(v128 + 24) = v114;
                *(_QWORD *)(v128 + 32) = v117;
                *(_QWORD *)(v128 + 40) = v116;
                *(_QWORD *)(v128 + 48) = v119;
                *(_QWORD *)(v128 + 56) = v118;
                *(_QWORD *)(v128 + 64) = v121;
                *(_QWORD *)(v128 + 72) = v120;
                *(_QWORD *)(v128 + 80) = v123;
                *(_QWORD *)(v128 + 88) = v122;
                *(_QWORD *)(v128 + 96) = v125;
                *(_QWORD *)(v128 + 104) = v124;
                *(_QWORD *)(v128 + 160) = v194;
                *(_OWORD *)(v128 + 128) = v192;
                *(_OWORD *)(v128 + 144) = v193;
                *v136 = v191;
              }
              else
              {
                *(_OWORD *)v128 = *a2;
                *(_OWORD *)(v128 + 16) = *(__int128 *)((char *)v113 - 152);
                *(_OWORD *)(v128 + 32) = *(__int128 *)((char *)v113 - 136);
                *(_OWORD *)(v128 + 48) = *(__int128 *)((char *)v113 - 120);
                *(_OWORD *)(v128 + 64) = *(__int128 *)((char *)v113 - 104);
                *(_OWORD *)(v128 + 80) = *(__int128 *)((char *)v113 - 88);
                *(_OWORD *)(v128 + 96) = *(__int128 *)((char *)v113 - 72);
                v137 = *(__int128 *)((char *)v113 - 40);
                v138 = *(__int128 *)((char *)v113 - 24);
                v139 = *(__int128 *)((char *)v113 - 56);
                *(_QWORD *)(v128 + 160) = *((_QWORD *)v113 - 1);
                *(_OWORD *)(v128 + 128) = v137;
                *(_OWORD *)(v128 + 144) = v138;
                *v136 = v139;
                *a2 = v189;
                *((_QWORD *)v113 - 19) = v115;
                *((_QWORD *)v113 - 18) = v114;
                *((_QWORD *)v113 - 17) = v117;
                *((_QWORD *)v113 - 16) = v116;
                *((_QWORD *)v113 - 15) = v119;
                *((_QWORD *)v113 - 14) = v118;
                *((_QWORD *)v113 - 13) = v121;
                *((_QWORD *)v113 - 12) = v120;
                *((_QWORD *)v113 - 11) = v123;
                *((_QWORD *)v113 - 10) = v122;
                *((_QWORD *)v113 - 9) = v125;
                *((_QWORD *)v113 - 8) = v124;
                *((_QWORD *)v113 - 1) = v194;
                *(__int128 *)((char *)v113 - 24) = v193;
                *(__int128 *)((char *)v113 - 40) = v192;
                *(__int128 *)((char *)v113 - 56) = v191;
                v140 = v128 - v7 + 168;
                if (v140 >= 169)
                {
                  v141 = (v140 / 0xA8uLL - 2) >> 1;
                  v142 = *(_QWORD *)(v128 + 8);
                  if (*(_DWORD *)(*(_QWORD *)(v7 + 168 * v141 + 8) + 112) < *(_DWORD *)(v142 + 112))
                  {
                    v143 = *(_QWORD *)v128;
                    v144 = *(_OWORD *)(v128 + 16);
                    v145 = *(_OWORD *)(v128 + 32);
                    v146 = *(_OWORD *)(v128 + 48);
                    v147 = *(_OWORD *)(v128 + 64);
                    v148 = *(_OWORD *)(v128 + 80);
                    v149 = *(_OWORD *)(v128 + 96);
                    v221 = *(_QWORD *)(v128 + 160);
                    v207 = *(_OWORD *)(v128 + 128);
                    v214 = *(_OWORD *)(v128 + 144);
                    v200 = *v136;
                    do
                    {
                      v150 = v128;
                      v128 = v7 + 168 * v141;
                      *(_OWORD *)v150 = *(_OWORD *)v128;
                      *(_OWORD *)(v150 + 16) = *(_OWORD *)(v128 + 16);
                      *(_OWORD *)(v150 + 32) = *(_OWORD *)(v128 + 32);
                      *(_OWORD *)(v150 + 48) = *(_OWORD *)(v128 + 48);
                      *(_OWORD *)(v150 + 64) = *(_OWORD *)(v128 + 64);
                      *(_OWORD *)(v150 + 80) = *(_OWORD *)(v128 + 80);
                      *(_OWORD *)(v150 + 96) = *(_OWORD *)(v128 + 96);
                      v151 = *(_OWORD *)(v128 + 112);
                      v152 = *(_OWORD *)(v128 + 128);
                      v153 = *(_OWORD *)(v128 + 144);
                      *(_QWORD *)(v150 + 160) = *(_QWORD *)(v128 + 160);
                      *(_OWORD *)(v150 + 128) = v152;
                      *(_OWORD *)(v150 + 144) = v153;
                      *(_OWORD *)(v150 + 112) = v151;
                      if (!v141)
                        break;
                      v141 = (v141 - 1) >> 1;
                    }
                    while (*(_DWORD *)(*(_QWORD *)(v7 + 168 * v141 + 8) + 112) < *(_DWORD *)(v142 + 112));
                    *(_QWORD *)v128 = v143;
                    *(_QWORD *)(v128 + 8) = v142;
                    *(_OWORD *)(v128 + 16) = v144;
                    *(_OWORD *)(v128 + 32) = v145;
                    *(_OWORD *)(v128 + 48) = v146;
                    *(_OWORD *)(v128 + 64) = v147;
                    *(_OWORD *)(v128 + 80) = v148;
                    *(_OWORD *)(v128 + 96) = v149;
                    *(_QWORD *)(v128 + 160) = v221;
                    *(_OWORD *)(v128 + 128) = v207;
                    *(_OWORD *)(v128 + 144) = v214;
                    *(_OWORD *)(v128 + 112) = v200;
                  }
                }
              }
            }
            while (v111-- > 2);
          }
          return;
        }
        v10 = (unint64_t)v9 >> 1;
        v11 = (_OWORD *)(v7 + 168 * ((unint64_t)v9 >> 1));
        if ((unint64_t)v8 < 0x5401)
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>((uint64_t)v11, a1, (uint64_t)v175);
        }
        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1, (uint64_t)v11, (uint64_t)v175);
          v12 = 168 * v10;
          v13 = a1 + 168 * v10;
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1 + 168, v13 - 168, (uint64_t)(a2 - 21));
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1 + 336, a1 + 168 + v12, (uint64_t)a2 - 504);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(v13 - 168, (uint64_t)v11, a1 + 168 + v12);
          v190 = *(_OWORD *)a1;
          v216 = *(_QWORD *)(a1 + 160);
          v202 = *(_OWORD *)(a1 + 128);
          v209 = *(_OWORD *)(a1 + 144);
          v195 = *(_OWORD *)(a1 + 112);
          v14 = *(_OWORD *)(a1 + 16);
          v15 = *(_OWORD *)(a1 + 32);
          v16 = *(_OWORD *)(a1 + 48);
          v17 = *(_OWORD *)(a1 + 64);
          v18 = *(_OWORD *)(a1 + 80);
          v19 = *(_OWORD *)(a1 + 96);
          v20 = *(_OWORD *)(v13 + 16);
          v21 = *(_OWORD *)(v13 + 32);
          *(_OWORD *)a1 = *v11;
          *(_OWORD *)(a1 + 16) = v20;
          v22 = *(_OWORD *)(v13 + 48);
          v23 = *(_OWORD *)(v13 + 64);
          *(_OWORD *)(a1 + 32) = v21;
          *(_OWORD *)(a1 + 48) = v22;
          v24 = *(_OWORD *)(v13 + 80);
          v25 = *(_OWORD *)(v13 + 96);
          *(_OWORD *)(a1 + 64) = v23;
          *(_OWORD *)(a1 + 80) = v24;
          v26 = *(_OWORD *)(v13 + 112);
          v27 = *(_OWORD *)(v13 + 128);
          v28 = *(_OWORD *)(v13 + 144);
          *(_QWORD *)(a1 + 160) = *(_QWORD *)(v13 + 160);
          *(_OWORD *)(a1 + 128) = v27;
          *(_OWORD *)(a1 + 144) = v28;
          *(_OWORD *)(a1 + 96) = v25;
          *(_OWORD *)(a1 + 112) = v26;
          *v11 = v190;
          *(_OWORD *)(v13 + 16) = v14;
          *(_OWORD *)(v13 + 32) = v15;
          *(_OWORD *)(v13 + 48) = v16;
          *(_OWORD *)(v13 + 64) = v17;
          *(_OWORD *)(v13 + 80) = v18;
          *(_OWORD *)(v13 + 96) = v19;
          *(_QWORD *)(v13 + 160) = v216;
          *(_OWORD *)(v13 + 128) = v202;
          *(_OWORD *)(v13 + 144) = v209;
          *(_OWORD *)(v13 + 112) = v195;
        }
        --a3;
        if ((a4 & 1) == 0)
        {
          v29 = *(_QWORD *)(a1 + 8);
          v30 = *(_DWORD *)(v29 + 112);
          if (*(_DWORD *)(*(_QWORD *)(a1 - 160) + 112) < v30)
            goto LABEL_11;
          v47 = *(_QWORD *)a1;
          v186 = *(_OWORD *)(a1 + 32);
          v188 = *(_OWORD *)(a1 + 16);
          v182 = *(_OWORD *)(a1 + 64);
          v184 = *(_OWORD *)(a1 + 48);
          v178 = *(_OWORD *)(a1 + 96);
          v180 = *(_OWORD *)(a1 + 80);
          v197 = *(_OWORD *)(a1 + 112);
          v204 = *(_OWORD *)(a1 + 128);
          v211 = *(_OWORD *)(a1 + 144);
          v218 = *(_QWORD *)(a1 + 160);
          if (v30 >= *(_DWORD *)(*((_QWORD *)a2 - 20) + 112))
          {
            v50 = a1 + 168;
            do
            {
              v7 = v50;
              if (v50 >= (unint64_t)a2)
                break;
              v51 = *(_DWORD *)(*(_QWORD *)(v50 + 8) + 112);
              v50 += 168;
            }
            while (v30 >= v51);
          }
          else
          {
            v48 = a1;
            do
            {
              v7 = v48 + 168;
              v49 = *(_DWORD *)(*(_QWORD *)(v48 + 176) + 112);
              v48 += 168;
            }
            while (v30 >= v49);
          }
          v52 = a2;
          if (v7 < (unint64_t)a2)
          {
            v53 = a2;
            do
            {
              v52 = (__int128 *)((char *)v53 - 168);
              v54 = *(_DWORD *)(*((_QWORD *)v53 - 20) + 112);
              v53 = (__int128 *)((char *)v53 - 168);
            }
            while (v30 < v54);
          }
          while (v7 < (unint64_t)v52)
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((__int128 *)v7, v52);
            v55 = *(_DWORD *)(v29 + 112);
            do
            {
              v56 = *(_QWORD *)(v7 + 176);
              v7 += 168;
            }
            while (v55 >= *(_DWORD *)(v56 + 112));
            do
            {
              v57 = *((_QWORD *)v52 - 20);
              v52 = (__int128 *)((char *)v52 - 168);
            }
            while (v55 < *(_DWORD *)(v57 + 112));
          }
          if (v7 - 168 != a1)
          {
            *(_OWORD *)a1 = *(_OWORD *)(v7 - 168);
            *(_OWORD *)(a1 + 16) = *(_OWORD *)(v7 - 152);
            *(_OWORD *)(a1 + 32) = *(_OWORD *)(v7 - 136);
            *(_OWORD *)(a1 + 48) = *(_OWORD *)(v7 - 120);
            *(_OWORD *)(a1 + 64) = *(_OWORD *)(v7 - 104);
            *(_OWORD *)(a1 + 80) = *(_OWORD *)(v7 - 88);
            *(_OWORD *)(a1 + 96) = *(_OWORD *)(v7 - 72);
            v58 = *(_OWORD *)(v7 - 56);
            v59 = *(_OWORD *)(v7 - 40);
            v60 = *(_OWORD *)(v7 - 24);
            *(_QWORD *)(a1 + 160) = *(_QWORD *)(v7 - 8);
            *(_OWORD *)(a1 + 128) = v59;
            *(_OWORD *)(a1 + 144) = v60;
            *(_OWORD *)(a1 + 112) = v58;
          }
          a4 = 0;
          *(_QWORD *)(v7 - 168) = v47;
          *(_QWORD *)(v7 - 160) = v29;
          *(_OWORD *)(v7 - 152) = v188;
          *(_OWORD *)(v7 - 136) = v186;
          *(_OWORD *)(v7 - 120) = v184;
          *(_OWORD *)(v7 - 104) = v182;
          *(_OWORD *)(v7 - 88) = v180;
          *(_OWORD *)(v7 - 72) = v178;
          *(_QWORD *)(v7 - 8) = v218;
          *(_OWORD *)(v7 - 24) = v211;
          *(_OWORD *)(v7 - 40) = v204;
          *(_OWORD *)(v7 - 56) = v197;
          continue;
        }
        v29 = *(_QWORD *)(a1 + 8);
        v30 = *(_DWORD *)(v29 + 112);
LABEL_11:
        v31 = *(_QWORD *)a1;
        v185 = *(_OWORD *)(a1 + 32);
        v187 = *(_OWORD *)(a1 + 16);
        v181 = *(_OWORD *)(a1 + 64);
        v183 = *(_OWORD *)(a1 + 48);
        v177 = *(_OWORD *)(a1 + 96);
        v179 = *(_OWORD *)(a1 + 80);
        v196 = *(_OWORD *)(a1 + 112);
        v203 = *(_OWORD *)(a1 + 128);
        v217 = *(_QWORD *)(a1 + 160);
        v32 = a1;
        v210 = *(_OWORD *)(a1 + 144);
        do
        {
          v33 = v32;
          v32 += 168;
        }
        while (*(_DWORD *)(*(_QWORD *)(v33 + 176) + 112) < v30);
        v34 = a2;
        if (v33 == a1)
        {
          v37 = a2;
          while (v32 < (unint64_t)v37)
          {
            v35 = (__int128 *)((char *)v37 - 168);
            v38 = *(_DWORD *)(*((_QWORD *)v37 - 20) + 112);
            v37 = (__int128 *)((char *)v37 - 168);
            if (v38 < v30)
              goto LABEL_21;
          }
          v35 = v37;
        }
        else
        {
          do
          {
            v35 = (__int128 *)((char *)v34 - 168);
            v36 = *(_DWORD *)(*((_QWORD *)v34 - 20) + 112);
            v34 = (__int128 *)((char *)v34 - 168);
          }
          while (v36 >= v30);
        }
LABEL_21:
        v7 = v32;
        if (v32 < (unint64_t)v35)
        {
          v39 = v35;
          do
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((__int128 *)v7, v39);
            v40 = *(_DWORD *)(v29 + 112);
            do
            {
              v41 = *(_QWORD *)(v7 + 176);
              v7 += 168;
            }
            while (*(_DWORD *)(v41 + 112) < v40);
            do
            {
              v42 = *((_QWORD *)v39 - 20);
              v39 = (__int128 *)((char *)v39 - 168);
            }
            while (*(_DWORD *)(v42 + 112) >= v40);
          }
          while (v7 < (unint64_t)v39);
        }
        if (v7 - 168 != a1)
        {
          *(_OWORD *)a1 = *(_OWORD *)(v7 - 168);
          *(_OWORD *)(a1 + 16) = *(_OWORD *)(v7 - 152);
          *(_OWORD *)(a1 + 32) = *(_OWORD *)(v7 - 136);
          *(_OWORD *)(a1 + 48) = *(_OWORD *)(v7 - 120);
          *(_OWORD *)(a1 + 64) = *(_OWORD *)(v7 - 104);
          *(_OWORD *)(a1 + 80) = *(_OWORD *)(v7 - 88);
          *(_OWORD *)(a1 + 96) = *(_OWORD *)(v7 - 72);
          v43 = *(_OWORD *)(v7 - 56);
          v44 = *(_OWORD *)(v7 - 40);
          v45 = *(_OWORD *)(v7 - 24);
          *(_QWORD *)(a1 + 160) = *(_QWORD *)(v7 - 8);
          *(_OWORD *)(a1 + 128) = v44;
          *(_OWORD *)(a1 + 144) = v45;
          *(_OWORD *)(a1 + 112) = v43;
        }
        *(_QWORD *)(v7 - 168) = v31;
        *(_QWORD *)(v7 - 160) = v29;
        *(_OWORD *)(v7 - 152) = v187;
        *(_OWORD *)(v7 - 136) = v185;
        *(_OWORD *)(v7 - 120) = v183;
        *(_OWORD *)(v7 - 104) = v181;
        *(_OWORD *)(v7 - 88) = v179;
        *(_OWORD *)(v7 - 72) = v177;
        *(_QWORD *)(v7 - 8) = v217;
        *(_OWORD *)(v7 - 24) = v210;
        *(_OWORD *)(v7 - 40) = v203;
        *(_OWORD *)(v7 - 56) = v196;
        if (v32 < (unint64_t)v35)
        {
LABEL_32:
          std::__introsort<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *,false>(a1, v7 - 168, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v46 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1, v7 - 168);
        if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(v7, (uint64_t)a2))
        {
          if (v46)
            continue;
          goto LABEL_32;
        }
        a2 = (__int128 *)(v7 - 168);
        if (!v46)
          goto LABEL_1;
        return;
    }
  }
}

__n128 std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>(__int128 *a1, __int128 *a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __n128 result;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __n128 v15;
  uint64_t v16;

  v2 = a1[1];
  v3 = a1[6];
  v12 = *a1;
  v13 = a1[7];
  v14 = a1[8];
  v15 = (__n128)a1[9];
  v16 = *((_QWORD *)a1 + 20);
  v4 = a1[2];
  v5 = a1[3];
  v6 = a1[4];
  v7 = a1[5];
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  a1[4] = a2[4];
  a1[5] = a2[5];
  a1[6] = a2[6];
  v8 = a2[7];
  v9 = a2[8];
  v10 = a2[9];
  *((_QWORD *)a1 + 20) = *((_QWORD *)a2 + 20);
  a1[8] = v9;
  a1[9] = v10;
  a1[7] = v8;
  *a2 = v12;
  a2[1] = v2;
  a2[2] = v4;
  a2[3] = v5;
  a2[4] = v6;
  a2[5] = v7;
  *((_QWORD *)a2 + 20) = v16;
  result = v15;
  a2[8] = v14;
  a2[9] = (__int128)v15;
  a2[6] = v3;
  a2[7] = v13;
  return result;
}

double std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  double result;
  __int128 *v9;

  v5 = a1;
  v6 = *(_DWORD *)(*(_QWORD *)(a2 + 8) + 112);
  v7 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 112);
  if (v6 < *(_DWORD *)(*(_QWORD *)(a1 + 8) + 112))
  {
    if (v7 >= v6)
    {
      *(_QWORD *)&result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((__int128 *)a1, (__int128 *)a2).n128_u64[0];
      if (*(_DWORD *)(*(_QWORD *)(a3 + 8) + 112) >= *(_DWORD *)(*(_QWORD *)(a2 + 8) + 112))
        return result;
      a1 = a2;
    }
    v9 = (__int128 *)a3;
    goto LABEL_9;
  }
  if (v7 < v6)
  {
    *(_QWORD *)&result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((__int128 *)a2, (__int128 *)a3).n128_u64[0];
    if (*(_DWORD *)(*(_QWORD *)(a2 + 8) + 112) < *(_DWORD *)(*(_QWORD *)(v5 + 8) + 112))
    {
      a1 = v5;
      v9 = (__int128 *)a2;
LABEL_9:
      *(_QWORD *)&result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((__int128 *)a1, v9).n128_u64[0];
    }
  }
  return result;
}

double std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double result;

  result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1, a2, a3);
  if (*(_DWORD *)(*(_QWORD *)(a4 + 8) + 112) < *(_DWORD *)(*(_QWORD *)(a3 + 8) + 112))
  {
    *(_QWORD *)&result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((__int128 *)a3, (__int128 *)a4).n128_u64[0];
    if (*(_DWORD *)(*(_QWORD *)(a3 + 8) + 112) < *(_DWORD *)(*(_QWORD *)(a2 + 8) + 112))
    {
      *(_QWORD *)&result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((__int128 *)a2, (__int128 *)a3).n128_u64[0];
      if (*(_DWORD *)(*(_QWORD *)(a2 + 8) + 112) < *(_DWORD *)(*(_QWORD *)(a1 + 8) + 112))
        *(_QWORD *)&result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((__int128 *)a1, (__int128 *)a2).n128_u64[0];
    }
  }
  return result;
}

double std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double result;

  result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1, a2, a3, a4);
  if (*(_DWORD *)(*(_QWORD *)(a5 + 8) + 112) < *(_DWORD *)(*(_QWORD *)(a4 + 8) + 112))
  {
    *(_QWORD *)&result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((__int128 *)a4, (__int128 *)a5).n128_u64[0];
    if (*(_DWORD *)(*(_QWORD *)(a4 + 8) + 112) < *(_DWORD *)(*(_QWORD *)(a3 + 8) + 112))
    {
      *(_QWORD *)&result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((__int128 *)a3, (__int128 *)a4).n128_u64[0];
      if (*(_DWORD *)(*(_QWORD *)(a3 + 8) + 112) < *(_DWORD *)(*(_QWORD *)(a2 + 8) + 112))
      {
        *(_QWORD *)&result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((__int128 *)a2, (__int128 *)a3).n128_u64[0];
        if (*(_DWORD *)(*(_QWORD *)(a2 + 8) + 112) < *(_DWORD *)(*(_QWORD *)(a1 + 8) + 112))
          *(_QWORD *)&result = std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((__int128 *)a1, (__int128 *)a2).n128_u64[0];
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _BOOL8 result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;

  v4 = 0xCF3CF3CF3CF3CF3DLL * ((a2 - a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(_DWORD *)(*(_QWORD *)(a2 - 160) + 112) < *(_DWORD *)(*(_QWORD *)(a1 + 8) + 112))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((__int128 *)a1, (__int128 *)(a2 - 168));
        return 1;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1, a1 + 168, a2 - 168);
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1, a1 + 168, a1 + 336, a2 - 168);
      return 1;
    case 5uLL:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *,0>(a1, a1 + 168, a1 + 336, a1 + 504, a2 - 168);
      return 1;
    default:
      v6 = a1 + 336;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1, a1 + 168, a1 + 336);
      v7 = a1 + 504;
      if (a1 + 504 == a2)
        return 1;
      v8 = 0;
      v9 = 0;
      break;
  }
  while (1)
  {
    v10 = *(_QWORD *)(v7 + 8);
    if (*(_DWORD *)(v10 + 112) < *(_DWORD *)(*(_QWORD *)(v6 + 8) + 112))
    {
      v11 = *(_QWORD *)v7;
      v12 = *(_OWORD *)(v7 + 16);
      v13 = *(_OWORD *)(v7 + 32);
      v14 = *(_OWORD *)(v7 + 48);
      v15 = *(_OWORD *)(v7 + 64);
      v16 = *(_OWORD *)(v7 + 80);
      v17 = *(_OWORD *)(v7 + 96);
      v30 = *(_OWORD *)(v7 + 112);
      v31 = *(_OWORD *)(v7 + 128);
      v33 = *(_QWORD *)(v7 + 160);
      v18 = v8;
      v32 = *(_OWORD *)(v7 + 144);
      while (1)
      {
        v19 = v18;
        v20 = a1 + v18;
        v21 = *(_OWORD *)(v20 + 352);
        *(_OWORD *)(v20 + 504) = *(_OWORD *)(v20 + 336);
        *(_OWORD *)(v20 + 520) = v21;
        v22 = *(_OWORD *)(v20 + 384);
        *(_OWORD *)(v20 + 536) = *(_OWORD *)(v20 + 368);
        *(_OWORD *)(v20 + 552) = v22;
        v23 = *(_OWORD *)(v20 + 416);
        *(_OWORD *)(v20 + 568) = *(_OWORD *)(v20 + 400);
        *(_OWORD *)(v20 + 584) = v23;
        v24 = *(_OWORD *)(v20 + 448);
        *(_OWORD *)(v20 + 600) = *(_OWORD *)(v20 + 432);
        v25 = *(_OWORD *)(v20 + 464);
        v26 = *(_OWORD *)(v20 + 480);
        *(_QWORD *)(v20 + 664) = *(_QWORD *)(v20 + 496);
        *(_OWORD *)(v20 + 632) = v25;
        *(_OWORD *)(v20 + 648) = v26;
        *(_OWORD *)(v20 + 616) = v24;
        if (v19 == -336)
          break;
        v27 = *(_DWORD *)(*(_QWORD *)(v20 + 176) + 112);
        v18 = v19 - 168;
        if (*(_DWORD *)(v10 + 112) >= v27)
        {
          v28 = a1 + v18 + 504;
          v29 = a1 + v19 + 448;
          goto LABEL_12;
        }
      }
      v29 = v20 + 448;
      v28 = a1;
LABEL_12:
      *(_QWORD *)v28 = v11;
      *(_QWORD *)(v28 + 8) = v10;
      *(_OWORD *)(v28 + 16) = v12;
      *(_OWORD *)(v28 + 32) = v13;
      *(_OWORD *)(v28 + 48) = v14;
      *(_OWORD *)(v28 + 64) = v15;
      *(_OWORD *)(v28 + 80) = v16;
      *(_OWORD *)(v28 + 96) = v17;
      *(_OWORD *)v29 = v30;
      *(_OWORD *)(v29 + 16) = v31;
      *(_OWORD *)(v29 + 32) = v32;
      ++v9;
      *(_QWORD *)(v29 + 48) = v33;
      if (v9 == 8)
        return v7 + 168 == a2;
    }
    v6 = v7;
    v8 += 168;
    v7 += 168;
    if (v7 == a2)
      return 1;
  }
}

void CA::Render::Transition::show(CA::Render::Transition *this, int a2, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  CA::Render *v8;
  NSObject *v9;
  uint8_t buf[4];
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if ((a3 & 1) == 0)
  {
    if (x_log_hook_p())
    {
      -[__CFString cStringUsingEncoding:]((id)CAAtomGetString(*((_DWORD *)this + 4)), "cStringUsingEncoding:", 4);
      x_log_();
    }
    else
    {
      v6 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        v7 = -[__CFString cStringUsingEncoding:]((id)CAAtomGetString(*((_DWORD *)this + 4)), "cStringUsingEncoding:", 4);
        *(_DWORD *)buf = 136315138;
        v11 = v7;
        _os_log_impl(&dword_184457000, v6, OS_LOG_TYPE_DEFAULT, "(transition %s", buf, 0xCu);
      }
    }
    if (*((_QWORD *)this + 5))
    {
      v8 = (CA::Render *)(a2 + 1);
      CA::Render::show_newline(v8);
      (*(void (**)(_QWORD, CA::Render *, uint64_t))(**((_QWORD **)this + 5) + 40))(*((_QWORD *)this + 5), v8, a3);
    }
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v9 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_184457000, v9, OS_LOG_TYPE_DEFAULT, ")", buf, 2u);
      }
    }
  }
}

uint64_t CA::Render::BuiltinTransition::apply(CA::Render::BuiltinTransition *this, const CA::Render::TransitionAnimation *a2, CA::Render::Layer *a3, int a4, float a5)
{
  int v8;
  CA::Render *v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  CA::Render::KeyValueArray *v21;
  float v22;
  float v23;
  float v24;
  double v25;
  double v26;
  double v27;
  double v28;
  CA::Render *v29;
  CA::Render::Layer *v30;
  CA::Render *v31;
  uint64_t v32;
  CA::Render::Array *v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  malloc_zone_t *malloc_zone;
  _DWORD *v39;
  _DWORD *v40;
  _DWORD *v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  char v45;
  uint64_t v46;
  _DWORD *v47;
  unsigned int *v48;
  unsigned int *v49;
  unsigned int v50;
  unsigned int v51;
  uint64_t v52;
  unsigned int *v53;
  int64x2_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v8 = *((_DWORD *)a2 + 24);
  v9 = (CA::Render *)*((_QWORD *)a2 + 16);
  if (a4 != 384 && a4 != 464 && a4 != 441)
    return 0;
  if (!v8)
    v8 = 235;
  v10 = *((double *)a3 + 10);
  v11 = a5;
  v12 = round(v10 * a5);
  v13 = -v10;
  v14 = 0.0;
  if ((v8 - 235) >= 2)
  {
    v12 = 0.0;
    v13 = 0.0;
  }
  if (v8 == 237 || (v15 = 0.0, v8 == 234))
  {
    v16 = *((double *)a3 + 11);
    v14 = round(v16 * v11);
    v15 = -v16;
  }
  v17 = v8 == 236 ? -v12 : v12;
  v18 = v8 == 236 ? -v13 : v13;
  v19 = v8 == 237 ? -v14 : v14;
  v20 = v8 == 237 ? -v15 : v15;
  v21 = (CA::Render::KeyValueArray *)*((_QWORD *)a2 + 15);
  if (v21 && !CA::Render::KeyValueArray::get_int_key(v21, (const CA::Render::KeyValueArray *)0xD7, 1))
  {
    v24 = 1.0;
    v22 = 1.0;
  }
  else
  {
    v22 = a5 + a5;
    if (a5 >= 0.5)
      v22 = 1.0;
    if (a5 <= 0.5)
    {
      v24 = 1.0;
    }
    else
    {
      v23 = 2.0 - v11 * 2.0;
      v24 = v23;
    }
  }
  v25 = 0.0;
  if (a4 == 384)
    v26 = 0.0;
  else
    v26 = v17;
  if (a4 == 384)
    v27 = 0.0;
  else
    v27 = v19;
  v28 = v17 + v18;
  if (a4 == 464)
    v28 = 0.0;
  else
    v25 = v20 + v19;
  v29 = CA::Render::layer_apply(a3, a2, v22, v28, v25);
  v55.i64[0] = (uint64_t)v29;
  v31 = CA::Render::layer_apply(v9, v30, v24, v26, v27);
  v55.i64[1] = (uint64_t)v31;
  if (a4 == 384)
  {
    v55.i64[0] = (uint64_t)v31;
    v55.i64[1] = (uint64_t)v29;
  }
  v32 = vaddvq_s64((int64x2_t)vbslq_s8((int8x16_t)vceqzq_s64(v55), (int8x16_t)xmmword_18474E040, (int8x16_t)xmmword_18474E490));
  v33 = (CA::Render::Array *)v32;
  if (!v32)
    return 0;
  if (v32 == 1)
  {
    v34 = 0;
    v35 = 0;
    while (1)
    {
      v36 = v55.i64[v35];
      if (v36)
        break;
      v37 = v34;
      v34 = 1;
      v35 = 1;
      if ((v37 & 1) != 0)
        goto LABEL_47;
    }
  }
  else
  {
LABEL_47:
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    v39 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x98uLL, 0x743898A5uLL);
    v36 = (uint64_t)v39;
    if (v39)
    {
      v39[2] = 1;
      v39[3] = 29;
      ++dword_1ECDC7C9C;
      *(_QWORD *)v39 = off_1E15989E0;
      *((_QWORD *)v39 + 2) = 0;
      *((_QWORD *)v39 + 3) = 0;
      v39[8] = 16843007;
      v39[9] = v39[9] & 0x80000000 | 0xF9F11;
      *((_QWORD *)v39 + 5) = *((_QWORD *)v39 + 5) & 0xFFFF800000000000 | 0x1030C0004C00;
      *((_OWORD *)v39 + 3) = 0u;
      *((_OWORD *)v39 + 4) = 0u;
      *((_OWORD *)v39 + 5) = 0u;
      *((_QWORD *)v39 + 12) = 0;
      *((_OWORD *)v39 + 7) = 0u;
      *((_OWORD *)v39 + 8) = 0u;
      *((_QWORD *)v39 + 18) = 0;
    }
    v40 = CA::Render::Array::new_array(v33, 0, 0, 0);
    v41 = v40;
    v42 = 0;
    v43 = 0;
    v44 = 0;
    do
    {
      v45 = v42;
      v46 = v55.i64[v43];
      if (v46)
      {
        v47 = &v40[2 * v44++];
        *((_QWORD *)v47 + 3) = v46;
      }
      v42 = 1;
      v43 = 1;
    }
    while ((v45 & 1) == 0);
    v48 = *(unsigned int **)(v36 + 104);
    if (v48)
    {
      v49 = v48 + 2;
      do
      {
        v50 = __ldaxr(v49);
        v51 = v50 - 1;
      }
      while (__stlxr(v51, v49));
      if (!v51)
        (*(void (**)(unsigned int *))(*(_QWORD *)v48 + 16))(v48);
    }
    *(_QWORD *)(v36 + 104) = v41;
  }
  if ((CA::Render::Layer *)v36 != a3)
  {
    v52 = *((_QWORD *)a3 + 16);
    if (v52)
      v53 = *(unsigned int **)(v52 + 8);
    else
      v53 = 0;
    CA::Render::Layer::set_timing((unsigned int *)v36, v53);
  }
  return v36;
}

uint64_t CA::Render::BuiltinTransition::implements_apply(CA::Render::BuiltinTransition *this)
{
  return 1;
}

double CA::Render::TransitionSubclass::DOD@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

double CA::Render::TransitionSubclass::ROI(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _OWORD *a6, _OWORD *a7)
{
  double result;

  result = 0.0;
  *a7 = 0u;
  a7[1] = 0u;
  *a6 = 0u;
  a6[1] = 0u;
  return result;
}

uint64_t CA::Render::TransitionSubclass::is_ogl_transition(CA::Render::TransitionSubclass *this)
{
  return 0;
}

CA::Render *CA::Render::layer_apply(CA::Render *this, CA::Render::Layer *a2, float a3, double a4, double a5)
{
  CA::Render *v5;
  uint64_t v9;
  _BOOL4 v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  malloc_zone_t *malloc_zone;
  double *v15;
  double *v16;
  unsigned int *v17;
  const double *v18;
  unsigned int v19;
  double v20;
  int v21;
  unsigned int v22;

  v5 = this;
  if (this)
  {
    v9 = *((_QWORD *)this + 16);
    if (v9)
      v10 = *(_QWORD *)(v9 + 8) == 0;
    else
      v10 = 1;
    if (a3 == 1.0 && a4 == 0.0 && a5 == 0.0 && v10)
    {
      v11 = (unsigned int *)((char *)this + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 + 1, v11));
      if (!v12)
      {
        v5 = 0;
        do
          v13 = __ldaxr(v11);
        while (__stlxr(v13 - 1, v11));
      }
    }
    else
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      v15 = (double *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x98uLL, 0x743898A5uLL);
      if (v15)
      {
        v16 = v15;
        v17 = (unsigned int *)CA::Render::Layer::Layer((uint64_t)v15, v5);
        CA::Render::Layer::set_timing(v17, 0);
        v19 = 1.0;
        if (a3 != 1.0)
        {
          LOBYTE(v19) = *((_BYTE *)v5 + 32);
          *((_BYTE *)v16 + 32) = (int)(float)((float)((float)v19 * a3) + 0.5);
        }
        if (a4 != 0.0 || a5 != 0.0)
        {
          v20 = *((double *)v5 + 7) + a5;
          v16[6] = *((double *)v5 + 6) + a4;
          v16[7] = v20;
        }
        v21 = *((_DWORD *)v16 + 3);
        if ((v21 & 0x1000) != 0 || !CA::Render::Layer::is_containerable((CA::Render::Layer *)v16, v18))
          v22 = v21 & 0xFFFFF7FF;
        else
          v22 = v21 | 0x800;
        *((_DWORD *)v16 + 3) = v22;
        return (CA::Render *)v16;
      }
      else
      {
        return 0;
      }
    }
  }
  return v5;
}

void CAML::ObjCContext::errorv(id *this, const char *a2, va_list a3)
{
  id *v4;
  NSObject *v5;
  int v6;
  NSObject *v7;
  char *v8;
  int v9;
  uint64_t v10;
  char *v11;
  int v12;
  unsigned int v13;
  int v15;
  NSObject *v16;
  const char *v17;
  void **v18;
  id *v19;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v4 = this;
  v27 = *MEMORY[0x1E0C80C00];
  if ((char)this[14] < 0)
  {
    objc_msgSend(this[12], "CAMLParser:formatErrorString:arguments:lineNumber:", this[10], a2, a3, *(int *)(*((_QWORD *)this[1] + 7) + 52));
    goto LABEL_34;
  }
  x_log_begin();
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v5 = x_log_category_api;
    if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*((_QWORD *)v4[1] + 7) + 52);
      *(_DWORD *)buf = 67109120;
      LODWORD(v22) = v6;
      _os_log_impl(&dword_184457000, v5, OS_LOG_TYPE_DEFAULT, "CAML error:%d: ", buf, 8u);
    }
  }
  x_logv();
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v7 = x_log_category_api;
    if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_184457000, v7, OS_LOG_TYPE_DEFAULT, "\n", buf, 2u);
    }
  }
  v19 = v4;
  v18 = (void **)x_stream_pop_(0);
  v8 = x_stream_get(v18);
  v9 = 0;
  while (2)
  {
    v10 = 0;
    v11 = &v8[v9];
    v12 = -1;
    while (1)
    {
      if (v11[v10] == 10)
      {
        v12 = v10;
        goto LABEL_17;
      }
      if (!v11[v10])
        break;
LABEL_17:
      ++v10;
      v13 = 32512;
      if (v10 == 32512)
        goto LABEL_18;
    }
    v13 = v10;
LABEL_18:
    if (v12 <= -1 || v11[v13] == 0)
      v15 = v13;
    else
      v15 = v12 + 1;
    if (v15 > 0)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v16 = x_log_category_api;
        if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          if (v9)
            v17 = "continued...\n";
          else
            v17 = "";
          v22 = v17;
          v23 = 1040;
          v24 = v15;
          v25 = 2080;
          v26 = &v8[v9];
          _os_log_impl(&dword_184457000, v16, OS_LOG_TYPE_ERROR, "%s%.*s", buf, 0x1Cu);
        }
      }
      v9 += v15;
      continue;
    }
    break;
  }
  x_log_end_free_(v18);
  v4 = v19;
LABEL_34:
  CAML::Context::errorv((CAML::Context *)v4, a2, a3);
}

void CAML::ObjCContext::start_script(CAML::ObjCContext *this, const char **a2)
{
  const char *v3;
  char *v4;
  _QWORD *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  const void *v11;
  _QWORD v12[2];
  _QWORD v13[3];

  v13[2] = *MEMORY[0x1E0C80C00];
  v3 = CAML::Context::parse_src_attribute((CFURLRef *)this, a2);
  if (!v3)
  {
    CAML::Context::push_state((uint64_t)this, 7, 0, 0, 0);
    return;
  }
  v4 = (char *)v3;
  v5 = CAML::Context::push_state((uint64_t)this, 0, 0, 0, 0);
  v11 = 0;
  if ((*((_BYTE *)this + 112) & 0x10) != 0)
  {
    v6 = (void *)MEMORY[0x186DBE2E4](v5);
    v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithContentsOfURL:encoding:error:", v4, 4, &v11);
    v8 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Unable to load CAPackage from URL: %@"), v4);
    if (v11)
    {
      v9 = *MEMORY[0x1E0CB3388];
      v12[0] = *MEMORY[0x1E0CB2D50];
      v12[1] = v9;
      v13[0] = v8;
      v13[1] = v11;
      v10 = (const void *)objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", CFSTR("CoreAnimationErrorDomain"), 2, objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v13, v12, 2));
      v11 = v10;
      if (!v7)
      {
        if (v10)
        {
          CAML::Context::set_error(this, v10);
LABEL_12:
          objc_autoreleasePoolPop(v6);
          goto LABEL_13;
        }
LABEL_11:
        CAML::Context::error(this, "Unable to open script: %s", (const char *)objc_msgSend((id)objc_msgSend(v4, "absoluteString"), "UTF8String"));
        goto LABEL_12;
      }
    }
    else if (!v7)
    {
      goto LABEL_11;
    }
    objc_msgSend(*((id *)this + 12), "CAMLParser:evaluateScriptElement:sourceURL:lineNumber:", *((_QWORD *)this + 10), v7, v4, 1);

    goto LABEL_12;
  }
  CAML::Context::error(this, "Delegate does not support <script>.");
LABEL_13:
  CFRelease(v4);
}

void sub_184673B94(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void CAML::ObjCContext::end_script(id *this, char *a2, uint64_t a3)
{
  const char *v4;
  void *v7;
  void *v8;

  if (!a3)
  {
    v4 = "Null <script> contents";
    goto LABEL_5;
  }
  if (((_BYTE)this[14] & 0x10) == 0)
  {
    v4 = "Delegate does not support <script>.";
LABEL_5:
    CAML::Context::error((CAML::Context *)this, v4);
    return;
  }
  v7 = (void *)MEMORY[0x186DBE2E4]();
  v8 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithBytes:length:encoding:", a2, a3, 4);
  objc_msgSend(this[12], "CAMLParser:evaluateScriptElement:sourceURL:lineNumber:", this[10], v8, this[3], *(unsigned int *)(*((_QWORD *)this[1] + 7) + 52));

  objc_autoreleasePoolPop(v7);
}

void sub_184673C60(_Unwind_Exception *a1)
{
  void *v1;

  objc_autoreleasePoolPop(v1);
  _Unwind_Resume(a1);
}

const void *CAML::ObjCContext::will_load_resource(CAML::ObjCContext *this, const __CFURL *key)
{
  const __CFDictionary *v4;
  const void *result;

  v4 = (const __CFDictionary *)*((_QWORD *)this + 9);
  if (!v4 || (result = CFDictionaryGetValue(v4, key)) == 0)
  {
    if ((*((_BYTE *)this + 112) & 1) != 0)
      return (const void *)objc_msgSend(*((id *)this + 12), "CAMLParser:resourceForURL:", *((_QWORD *)this + 10), key);
    else
      return 0;
  }
  return result;
}

void CAML::ObjCContext::did_load_resource(id *this, const __CFURL *a2, const void *a3)
{
  void *v6;

  CAML::Context::did_load_resource((CAML::Context *)this, a2, a3);
  if (a3)
  {
    if (((_BYTE)this[14] & 2) != 0)
    {
      v6 = (void *)MEMORY[0x186DBE2E4]();
      objc_msgSend(this[12], "CAMLParser:didLoadResource:fromURL:", this[10], a3, a2);
      objc_autoreleasePoolPop(v6);
    }
  }
}

void sub_184673D38(_Unwind_Exception *a1)
{
  void *v1;

  objc_autoreleasePoolPop(v1);
  _Unwind_Resume(a1);
}

const void *CAML::ObjCContext::failed_to_load_resource(CAML::ObjCContext *this, const __CFURL *a2)
{
  const void *v2;
  void *v5;
  const void *v6;

  if ((*((_BYTE *)this + 112) & 4) == 0)
    return 0;
  v5 = (void *)MEMORY[0x186DBE2E4]();
  v6 = (const void *)objc_msgSend(*((id *)this + 12), "CAMLParser:didFailToLoadResourceFromURL:", *((_QWORD *)this + 10), a2);
  v2 = v6;
  if (v6)
    CFRetain(v6);
  objc_autoreleasePoolPop(v5);
  return v2;
}

void sub_184673DB8(_Unwind_Exception *a1)
{
  void *v1;

  objc_autoreleasePoolPop(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::Render::Server::set_thread_priority(_opaque_pthread_t *this, _opaque_pthread_t *a2)
{
  int v3;
  int v5;
  sched_param v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v3 = (_DWORD)a2 + 55;
  v6 = 0;
  v5 = 0;
  pthread_getschedparam(this, &v5, &v6);
  v5 = 4;
  v6.sched_priority = v3;
  return pthread_setschedparam(this, 4, &v6);
}

uint64_t CA::Render::Server::port_set_qlimit(uint64_t name)
{
  unsigned int *v2;
  mach_msg_type_number_t v4;
  integer_t port_info_out;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4 = 1;
  port_info_out = 0;
  v2 = (unsigned int *)MEMORY[0x1E0C83DA0];
  mach_port_get_attributes(*MEMORY[0x1E0C83DA0], name, 1, &port_info_out, &v4);
  port_info_out = 3;
  return MEMORY[0x186DBE098](*v2, name, 1, &port_info_out, 1);
}

uint64_t CA::Render::Server::timer_port(CA::Render::Server *this)
{
  uint64_t result;
  CA::Render::Server *v2;
  mach_port_name_t v3;
  ipc_space_t v5;
  mach_port_name_t v6;

  result = CA::Render::Server::_timer_port;
  if (!CA::Render::Server::_timer_port)
  {
    v2 = (CA::Render::Server *)mk_timer_create();
    if (!(_DWORD)v2)
    {
      x_log_crash("CoreAnimation: mk_timer_create returned error!\n");
      abort();
    }
    v3 = v2;
    while (!__ldaxr((unsigned int *)&CA::Render::Server::_timer_port))
    {
      if (!__stlxr(v2, (unsigned int *)&CA::Render::Server::_timer_port))
      {
        v5 = *MEMORY[0x1E0C83DA0];
        v6 = CA::Render::Server::port_set(v2);
        mach_port_move_member(v5, v3, v6);
        return CA::Render::Server::_timer_port;
      }
    }
    __clrex();
    mk_timer_destroy();
    return CA::Render::Server::_timer_port;
  }
  return result;
}

uint64_t CA::Render::Server::add_dead_name_watch(CA::Render::Server *this, mach_port_t *a2, unsigned int *a3, BOOL (*a4)(unsigned int))
{
  mach_port_name_t v6;
  CA::Render::Server *v7;
  unint64_t v8;
  uint8x8_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  int8x8_t prime;
  void *v19;
  void *v20;
  uint64_t v21;
  _QWORD **v22;
  unint64_t v23;
  uint8x8_t v24;
  unint64_t v25;
  uint8x8_t v26;
  uint64_t v27;
  _QWORD *i;
  unint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  unint64_t v33;
  ipc_space_t v34;
  CA::Render::Server *v35;
  mach_port_t v36;
  void *v38;

  v6 = this;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Server::_dead_name_watch_list_lock);
  CA::Render::Server::dead_name_watch_list(v7);
  v8 = *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
  if (*((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1))
  {
    v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 8));
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v10 = v6;
      if (*((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1) <= (unint64_t)v6)
        v10 = (unint64_t)v6 % *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
    }
    else
    {
      v10 = (DWORD2(CA::Render::Server::dead_name_watch_list(void)::watch_list) - 1) & v6;
    }
    v11 = *(_QWORD **)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v10);
    if (v11)
    {
      v12 = (_QWORD *)*v11;
      if (*v11)
      {
        do
        {
          v13 = v12[1];
          if (v13 == v6)
          {
            if (*((_DWORD *)v12 + 4) == v6)
              goto LABEL_74;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v13 >= *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1))
                v13 %= *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
            }
            else
            {
              v13 &= *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1) - 1;
            }
            if (v13 != v10)
              break;
          }
          v12 = (_QWORD *)*v12;
        }
        while (v12);
      }
    }
  }
  else
  {
    v10 = 0;
  }
  v12 = operator new(0x20uLL);
  *v12 = 0;
  v12[1] = v6;
  *((_DWORD *)v12 + 4) = v6;
  v12[3] = 0;
  v14 = (float)(unint64_t)(qword_1EDD11CE8 + 1);
  if (!v8 || (float)(*(float *)&dword_1EDD11CF0 * (float)v8) < v14)
  {
    v15 = 1;
    if (v8 >= 3)
      v15 = (v8 & (v8 - 1)) != 0;
    v16 = v15 | (2 * v8);
    v17 = vcvtps_u32_f32(v14 / *(float *)&dword_1EDD11CF0);
    if (v16 <= v17)
      prime = (int8x8_t)v17;
    else
      prime = (int8x8_t)v16;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v8 = *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
    }
    if (*(_QWORD *)&prime > v8)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v8)
    {
      v25 = vcvtps_u32_f32((float)(unint64_t)qword_1EDD11CE8 / *(float *)&dword_1EDD11CF0);
      if (v8 < 3 || (v26 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        v25 = std::__next_prime(v25);
      }
      else
      {
        v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2)
          v25 = v27;
      }
      if (*(_QWORD *)&prime <= v25)
        prime = (int8x8_t)v25;
      if (*(_QWORD *)&prime >= v8)
      {
        v8 = *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v19 = operator new(8 * *(_QWORD *)&prime);
          v20 = (void *)CA::Render::Server::dead_name_watch_list(void)::watch_list;
          *(_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list = v19;
          if (v20)
            operator delete(v20);
          v21 = 0;
          *((int8x8_t *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1) = prime;
          do
            *(_QWORD *)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v21++) = 0;
          while (*(_QWORD *)&prime != v21);
          v22 = (_QWORD **)qword_1EDD11CE0;
          if (qword_1EDD11CE0)
          {
            v23 = *(_QWORD *)(qword_1EDD11CE0 + 8);
            v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(_QWORD *)&prime)
                v23 %= *(_QWORD *)&prime;
            }
            else
            {
              v23 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v23) = &qword_1EDD11CE0;
            for (i = *v22; i; v23 = v29)
            {
              v29 = i[1];
              if (v24.u32[0] > 1uLL)
              {
                if (v29 >= *(_QWORD *)&prime)
                  v29 %= *(_QWORD *)&prime;
              }
              else
              {
                v29 &= *(_QWORD *)&prime - 1;
              }
              if (v29 != v23)
              {
                if (!*(_QWORD *)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v29))
                {
                  *(_QWORD *)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v29) = v22;
                  goto LABEL_55;
                }
                *v22 = (_QWORD *)*i;
                *i = **(_QWORD **)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v29);
                **(_QWORD **)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v29) = i;
                i = v22;
              }
              v29 = v23;
LABEL_55:
              v22 = (_QWORD **)i;
              i = (_QWORD *)*i;
            }
          }
          v8 = (unint64_t)prime;
          goto LABEL_59;
        }
        v38 = (void *)CA::Render::Server::dead_name_watch_list(void)::watch_list;
        *(_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list = 0;
        if (v38)
          operator delete(v38);
        v8 = 0;
        *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1) = 0;
      }
    }
LABEL_59:
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v6)
        v10 = v6 % v8;
      else
        v10 = v6;
    }
    else
    {
      v10 = ((_DWORD)v8 - 1) & v6;
    }
  }
  v30 = CA::Render::Server::dead_name_watch_list(void)::watch_list;
  v31 = *(_QWORD **)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v10);
  if (v31)
  {
    *v12 = *v31;
LABEL_72:
    *v31 = v12;
    goto LABEL_73;
  }
  v32 = qword_1EDD11CE0;
  *v12 = qword_1EDD11CE0;
  qword_1EDD11CE0 = (uint64_t)v12;
  *(_QWORD *)(v30 + 8 * v10) = &qword_1EDD11CE0;
  if (v32)
  {
    v33 = *(_QWORD *)(v32 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v33 >= v8)
        v33 %= v8;
    }
    else
    {
      v33 &= v8 - 1;
    }
    v31 = (_QWORD *)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v33);
    goto LABEL_72;
  }
LABEL_73:
  ++qword_1EDD11CE8;
LABEL_74:
  v12[3] = a3;
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Server::_dead_name_watch_list_lock);
  v34 = *MEMORY[0x1E0C83DA0];
  v36 = CA::Render::Server::notify_port(v35);
  return mach_port_request_notification(v34, v6, 72, 0, v36, 0x15u, a2);
}

void CA::Render::Server::remove_dead_name_watch(CA::Render::Server *this)
{
  unsigned int v1;
  CA::Render::Server *v2;
  uint64_t *v3;

  v1 = this;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Server::_dead_name_watch_list_lock);
  CA::Render::Server::dead_name_watch_list(v2);
  v3 = std::__hash_table<std::__hash_value_type<unsigned int,BOOL (*)>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,BOOL (*)>>>::find<unsigned int>(v1);
  if (v3)
    std::__hash_table<std::__hash_value_type<unsigned int,BOOL (*)>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,BOOL (*)>>>::erase(v3);
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Server::_dead_name_watch_list_lock);
}

void std::__hash_table<std::__hash_value_type<unsigned int,BOOL (*)(unsigned int)>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)(unsigned int)>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,BOOL (*)(unsigned int)>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,BOOL (*)(unsigned int)>>>::erase(void *__p)
{
  unint64_t v1;
  unint64_t v2;
  uint8x8_t v3;
  uint64_t *v4;
  uint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;

  v1 = *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
  v2 = *((_QWORD *)__p + 1);
  v3 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 8));
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    if (v2 >= *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1))
      v2 %= *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
  }
  else
  {
    v2 &= *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1) - 1;
  }
  v4 = *(uint64_t **)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v2);
  do
  {
    v5 = v4;
    v4 = (uint64_t *)*v4;
  }
  while (v4 != __p);
  if (v5 == &qword_1EDD11CE0)
    goto LABEL_18;
  v6 = v5[1];
  if (v3.u32[0] > 1uLL)
  {
    if (v6 >= *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1))
      v6 %= *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
  }
  else
  {
    v6 &= *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1) - 1;
  }
  if (v6 != v2)
  {
LABEL_18:
    if (!*(_QWORD *)__p)
      goto LABEL_19;
    v7 = *(_QWORD *)(*(_QWORD *)__p + 8);
    if (v3.u32[0] > 1uLL)
    {
      if (v7 >= *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1))
        v7 %= *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1);
    }
    else
    {
      v7 &= *((_QWORD *)&CA::Render::Server::dead_name_watch_list(void)::watch_list + 1) - 1;
    }
    if (v7 != v2)
LABEL_19:
      *(_QWORD *)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v2) = 0;
  }
  v8 = *(_QWORD *)__p;
  if (*(_QWORD *)__p)
  {
    v9 = *(_QWORD *)(v8 + 8);
    if (v3.u32[0] > 1uLL)
    {
      if (v9 >= v1)
        v9 %= v1;
    }
    else
    {
      v9 &= v1 - 1;
    }
    if (v9 != v2)
    {
      *(_QWORD *)(CA::Render::Server::dead_name_watch_list(void)::watch_list + 8 * v9) = v5;
      v8 = *(_QWORD *)__p;
    }
  }
  *v5 = v8;
  *(_QWORD *)__p = 0;
  --qword_1EDD11CE8;
  operator delete(__p);
}

BOOL CA::Render::Server::register_name(CA::Render::Server *this, const char *a2)
{
  const char *v2;
  mach_port_t v3;
  kern_return_t v4;
  _BOOL8 v5;
  kern_return_t v6;
  NSObject *v7;
  CA::Render::Server *v8;
  ipc_space_t v9;
  mach_port_t v10;
  mach_port_name_t v11;
  uint64_t v12;
  uint64_t v13;
  malloc_zone_t *malloc_zone;
  _QWORD *v15;
  NSObject *v16;
  mach_port_t sp;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  kern_return_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (this)
    v2 = (const char *)this;
  else
    v2 = "com.apple.CARenderServer";
  v3 = *MEMORY[0x1E0C81720];
  if ((*MEMORY[0x1E0C81720] - 1) >= 0xFFFFFFFE)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v7 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_184457000, v7, OS_LOG_TYPE_ERROR, "unable to find bootstrap server", buf, 2u);
      }
    }
    return 0;
  }
  else
  {
    sp = 0;
    v4 = bootstrap_check_in(v3, v2, &sp);
    v5 = v4 == 0;
    if (v4)
    {
      v6 = v4;
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v16 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v20 = v2;
          v21 = 1024;
          v22 = v6;
          _os_log_impl(&dword_184457000, v16, OS_LOG_TYPE_ERROR, "unable to register bootstrap port %s: %x\n", buf, 0x12u);
        }
      }
    }
    else
    {
      v8 = (CA::Render::Server *)CA::Render::Server::port_set_qlimit(sp);
      v9 = *MEMORY[0x1E0C83DA0];
      v10 = sp;
      v11 = CA::Render::Server::port_set(v8);
      mach_port_move_member(v9, v10, v11);
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Server::_checked_in_lock);
      v12 = CA::Render::Server::_checked_in_ports;
      v13 = sp;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      v15 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
      *v15 = v13;
      v15[1] = v12;
      CA::Render::Server::_checked_in_ports = (uint64_t)v15;
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Server::_checked_in_lock);
    }
  }
  return v5;
}

BOOL CA::Render::Server::start(CA::Render::Server *this)
{
  uint64_t v1;
  _opaque_pthread_t *v2;
  _BOOL8 v3;
  char v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (CA::Render::memory_once[0] != -1)
    dispatch_once_f(CA::Render::memory_once, 0, (dispatch_function_t)CA::Render::init_memory_warnings_);
  pthread_mutex_lock(&CA::Render::Server::_mutex);
  v1 = CA::Render::Server::_thread;
  if (!CA::Render::Server::_thread)
  {
    v5 = 0;
    v2 = x_thread_create((uint64_t)CA::Render::Server::server_thread, (uint64_t)&v5, 1);
    if (v2)
    {
      CA::Render::Server::set_thread_priority(v2, 0);
      while (!v5)
        pthread_cond_wait(&CA::Render::Server::_cond, &CA::Render::Server::_mutex);
    }
    v1 = CA::Render::Server::_thread;
  }
  v3 = v1 != 0;
  pthread_mutex_unlock(&CA::Render::Server::_mutex);
  return v3;
}

void CA::Render::Server::ca_mach_msg_error_0(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_1(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_2(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_3(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_4(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_5(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_6(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_7(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_8(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_9(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_a(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_b(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_c(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_d(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_e(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

void CA::Render::Server::ca_mach_msg_error_f(CA::Render::Server *this, int a2)
{
  if (a2 == 32)
  {
    x_log_crash("CoreAnimation: mach_msg returned error!\n");
    abort();
  }
  ((void (*)(void))CA::Render::Server::error_jump_table[((int)this >> a2) & 0xF])();
  abort();
}

uint64_t CA::Render::Server::release_vm(mach_vm_address_t address, mach_vm_size_t size, void *a3)
{
  return mach_vm_deallocate(*MEMORY[0x1E0C83DA0], address, size);
}

void CA::Render::Server::stop(CA::Render::Server *this)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  int v4;
  __int128 v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  CA::Render::Server::kick_server(this);
  if (CA::Render::Server::_server_port[0])
  {
    MEMORY[0x1E0C80A78](v1);
    v3 = 0x1C00000013;
    v4 = v2;
    v5 = xmmword_18474E4B0;
    mach_msg((mach_msg_header_t *)&v3, 1, 0x1Cu, 0, 0, 0, 0);
    pthread_mutex_lock(&CA::Render::Server::_mutex);
    while (CA::Render::Server::_thread)
      pthread_cond_wait(&CA::Render::Server::_cond, &CA::Render::Server::_mutex);
    pthread_mutex_unlock(&CA::Render::Server::_mutex);
  }
}

dispatch_queue_t ___Z13dealloc_queuev_block_invoke()
{
  NSObject *v0;
  dispatch_queue_t result;

  v0 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  result = dispatch_queue_create("CA::Render::DeallocQueue", v0);
  dealloc_queue(void)::queue = (uint64_t)result;
  return result;
}

uint64_t CASGetClientProcessId(CA::Render::Context *a1, audit_token_t *a2, CA::Render::Server *this)
{
  uint64_t v6;
  const audit_token_t *v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int *v10;
  unsigned int v11;
  pid_t v12;
  int v13;
  unsigned int *v14;
  unsigned int v15;

  v6 = 4213784577;
  a2->val[0] = 0;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v7) & 0x20000) == 0)
  {
    v8 = CA::Render::Context::context_by_client_port(a1);
    if (v8)
    {
      v9 = (unsigned int *)v8;
      v10 = (unsigned int *)(v8 + 228);
      v11 = atomic_load((unsigned int *)(v8 + 228));
      if (!v11)
      {
        if (*(_DWORD *)(v8 + 252))
          v12 = 0;
        else
          v12 = getpid();
        while (1)
        {
          v11 = __ldaxr(v10);
          if (v11)
            break;
          if (!__stlxr(v12, v10))
          {
            v13 = 1;
            goto LABEL_13;
          }
        }
        v13 = 0;
        __clrex();
LABEL_13:
        if (v13)
          v11 = v12;
      }
      a2->val[0] = v11;
      v14 = v9 + 2;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (v15 == 1)
        (*(void (**)(unsigned int *))(*(_QWORD *)v9 + 16))(v9);
      v6 = 0;
    }
    else
    {
      v6 = 56;
    }
  }
  if ((_DWORD)a1)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], (mach_port_name_t)a1);
  return v6;
}

uint64_t CASSetMessageFile(const char *a1, CA::Render::Server *this)
{
  uint64_t v4;
  const audit_token_t *v5;
  const audit_token_t *v6;
  _OWORD v8[16];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v4 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, (const audit_token_t *)this) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v5) & 0x20000) == 0)
  {
    if ((CA::Render::Server::audit_token_cache_lookup(this, v6) & 0x100) != 0)
    {
      memset(v8, 0, sizeof(v8));
      strlcpy((char *)v8, a1, 0x100uLL);
      return 0;
    }
    else
    {
      return 53;
    }
  }
  return v4;
}

uint64_t CASSetDebugMessage(const char *a1, const audit_token_t *a2, CA::Render::Server *this)
{
  int v4;
  uint64_t v6;
  const audit_token_t *v7;
  const audit_token_t *v8;
  _OWORD v10[16];
  uint64_t v11;

  v4 = (int)a2;
  v11 = *MEMORY[0x1E0C80C00];
  v6 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v7) & 0x20000) == 0)
  {
    if ((CA::Render::Server::audit_token_cache_lookup(this, v8) & 0x100) != 0)
    {
      memset(v10, 0, sizeof(v10));
      strlcpy((char *)v10, a1, 0x100uLL);
      CASetDebugMessage((char *)v10, v4);
      return 0;
    }
    else
    {
      return 53;
    }
  }
  return v6;
}

uint64_t CASSetLUTFile(const char *a1, CA::Render::Server *this)
{
  uint64_t v4;
  const audit_token_t *v5;
  const audit_token_t *v6;
  _OWORD v8[16];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v4 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, (const audit_token_t *)this) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v5) & 0x20000) == 0)
  {
    if ((CA::Render::Server::audit_token_cache_lookup(this, v6) & 0x100) != 0)
    {
      memset(v8, 0, sizeof(v8));
      strlcpy((char *)v8, a1, 0x100uLL);
      CASetLUTFile((const char *)v8);
      return 0;
    }
    else
    {
      return 53;
    }
  }
  return v4;
}

uint64_t CASRenderDisplaySurface(const char *a1, _anonymous_namespace_ *a2, unsigned int *a3, mach_port_t a4, int a5, int a6, int a7, CA::Mat4Impl *a8, double a9, int a10, unsigned int a11, unint64_t *a12, CA::Render::Server *a13)
{
  uint64_t v21;
  mach_vm_size_t v22;
  const audit_token_t *v23;
  CFStringRef v24;
  __IOSurface *v25;
  __IOSurface *v26;
  __IOSurface *v27;
  BOOL v28;
  ipc_space_t *v29;
  void (**v32)(CA::Render::RenderSurface *__hidden);
  int Width;
  int Height;
  __IOSurface *v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v21 = 4213784577;
  v22 = 4 * a3;
  if ((CA::Render::Server::audit_token_cache_lookup(a13, (const audit_token_t *)a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a13, v23) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01
      && (v24 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20])) != 0)
    {
      CFRelease(v24);
      v42 = 0;
      v40 = 0u;
      v41 = 0u;
      v38 = 0u;
      v39 = 0u;
      v36 = 0u;
      v37 = 0u;
      v25 = IOSurfaceLookupFromMachPort(a4);
      if (v25)
      {
        v32 = &off_1E1597280;
        v35 = v25;
        v26 = v25;
        Width = IOSurfaceGetWidth(v25);
        Height = IOSurfaceGetHeight(v26);
        *(_QWORD *)&v37 = &v32;
        HIDWORD(v40) = a5;
        v27 = v26;
        v28 = IOSurfaceGetProtectionOptions() != 0;
        CFRelease(v27);
      }
      else
      {
        v21 = 5;
      }
    }
    else
    {
      v21 = 4;
    }
  }
  v29 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)a2, v22);
  if (a4)
    mach_port_deallocate(*v29, a4);
  return v21;
}

uint64_t `anonymous namespace'::render_display(const char *a1, _anonymous_namespace_ *a2, unsigned int *a3, int a4, int a5, CA::Mat4Impl *this, int a7, BOOL *a8, double a9, unint64_t *a10, _anonymous_namespace_ *a11, uint64_t a12, char a13)
{
  char v21;
  _OWORD *v22;
  uint64_t v23;
  uint64_t v24;
  double v25;
  char v26;
  const void *v27;
  char v28;
  _OWORD v30[9];
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v31 = 0;
  memset(v30, 0, sizeof(v30));
  CA::Transform::set((uint64_t)v30, this, 1);
  if ((a13 & 1) != 0)
  {
    *(_DWORD *)a12 = 0;
    *(_BYTE *)(a12 + 4) = 1;
    v21 = *(_BYTE *)(a12 + 96) & 0xFB;
  }
  else
  {
    if ((a13 & 2) == 0)
      *(_DWORD *)(a12 + 68) = 0x10000;
    v21 = *(_BYTE *)(a12 + 96) | 4;
  }
  *(_BYTE *)(a12 + 96) = v21;
  *(_QWORD *)(a12 + 8) = CFStringCreateWithCString(0, a1, 0x8000100u);
  *(_DWORD *)(a12 + 44) = a4;
  *(_DWORD *)(a12 + 48) = a5;
  *(double *)(a12 + 56) = a9;
  *(_QWORD *)(a12 + 24) = a3;
  *(_QWORD *)(a12 + 32) = a2;
  v22 = v30;
  if (*(double *)v30 == 0.0)
  {
    v23 = 1;
    do
    {
      if (v23 == 16)
        goto LABEL_11;
      v24 = v23;
      v25 = *((double *)v30 + v23++);
    }
    while (v25 == 0.0);
    if ((unint64_t)(v24 - 1) >= 0xF)
    {
LABEL_11:
      v22 = 0;
      goto LABEL_13;
    }
    v22 = v30;
  }
LABEL_13:
  *(_DWORD *)(a12 + 64) = a7;
  *(_QWORD *)(a12 + 80) = v22;
  *(_QWORD *)(a12 + 88) = 0;
  v26 = *(_BYTE *)(a12 + 96) & 0xCD;
  *(_BYTE *)(a12 + 7) = ((unsigned __int16)a8 & 0x400) != 0;
  *(_BYTE *)(a12 + 96) = v26 | BYTE1(a8) & 0x10 | (a8 >> 10) & 2;
  if (*(_QWORD *)(a12 + 16))
    CA::Render::post_notification(0x13u, 0, a12, 0);
  v27 = *(const void **)(a12 + 8);
  if (v27)
    CFRelease(v27);
  v28 = *(_BYTE *)(a12 + 96);
  if (a10)
  {
    *a10 = *(_QWORD *)(a12 + 88) | ((unint64_t)(*(_BYTE *)(a12 + 96) & 0x20) << 58);
    v28 = *(_BYTE *)(a12 + 96);
  }
  if ((v28 & 0x20) != 0)
    return 0;
  else
    return 5;
}

float `anonymous namespace'::get_max_context_level(_anonymous_namespace_ *this, unsigned int *a2)
{
  unsigned int v2;
  size_t v4;
  char *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  CA::Render::Context *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int *v14;
  float *v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t i;
  unsigned int *v24;
  unsigned int *v25;
  unsigned int v26;
  unsigned int v27;
  _QWORD v29[2];

  v29[1] = *MEMORY[0x1E0C80C00];
  if (!(_DWORD)a2)
  {
    v6 = 2139095040;
    return *(float *)&v6;
  }
  v2 = a2;
  v4 = 8 * a2;
  if (a2 <= 0x200)
  {
    MEMORY[0x1E0C80A78](this);
    v5 = (char *)v29 - ((v4 + 15) & 0xFFFFFFFF0);
    bzero(v5, v4);
    goto LABEL_6;
  }
  v5 = (char *)malloc_type_malloc(8 * a2, 0xE5FF92F3uLL);
  bzero(v5, v4);
  if (!v5)
  {
    v6 = -8388608;
    return *(float *)&v6;
  }
LABEL_6:
  v7 = 0;
  while (1)
  {
    v8 = CA::Render::Context::context_by_id((CA::Render::Context *)*((unsigned int *)this + v7));
    *(_QWORD *)&v5[8 * v7] = v8;
    if (!v8)
      break;
    if (v2 == ++v7)
      goto LABEL_11;
  }
  if ((_DWORD)v7 != v2)
  {
    v10 = -INFINITY;
    goto LABEL_33;
  }
LABEL_11:
  v9 = 0;
  v10 = -INFINITY;
  do
  {
    v11 = *(CA::Render::Context **)&v5[8 * v9];
    v12 = (unsigned int *)((char *)v11 + 8);
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 + 1, v12));
    if (!v13)
    {
      do
      {
        v11 = 0;
        v22 = __ldaxr(v12);
      }
      while (__stlxr(v22 - 1, v12));
    }
    v14 = 0;
    do
    {
      v15 = (float *)v11;
      v11 = (CA::Render::Context *)CA::Render::Context::retain_host_context(v11);
      if (v14)
      {
        v16 = v14 + 2;
        do
        {
          v17 = __ldaxr(v16);
          v18 = v17 - 1;
        }
        while (__stlxr(v18, v16));
        if (!v18)
          (*(void (**)(unsigned int *))(*(_QWORD *)v14 + 16))(v14);
      }
      v14 = (unsigned int *)v15;
    }
    while (v11);
    if (v15[48] > v10)
      v10 = v15[48];
    v19 = (unsigned int *)(v15 + 2);
    do
    {
      v20 = __ldaxr(v19);
      v21 = v20 - 1;
    }
    while (__stlxr(v21, v19));
    if (!v21)
      (*(void (**)(float *))(*(_QWORD *)v15 + 16))(v15);
    ++v9;
  }
  while (v9 != v2);
LABEL_33:
  for (i = 0; i != v2; ++i)
  {
    v24 = *(unsigned int **)&v5[8 * i];
    if (v24)
    {
      v25 = v24 + 2;
      do
      {
        v26 = __ldaxr(v25);
        v27 = v26 - 1;
      }
      while (__stlxr(v27, v25));
      if (!v27)
        (*(void (**)(unsigned int *))(*(_QWORD *)v24 + 16))(v24);
      *(_QWORD *)&v5[8 * i] = 0;
    }
  }
  if (v2 >= 0x201)
    free(v5);
  return v10;
}

void CA::Render::RenderSurface::~RenderSurface(CA::Render::RenderSurface *this)
{
  JUMPOUT(0x186DBD990);
}

uint64_t CASRenderDisplayShmem(const char *a1, _anonymous_namespace_ *a2, unsigned int *a3, int a4, int a5, uint64_t a6, mem_entry_name_port_t a7, mach_vm_size_t a8, double a9, int a10, int a11, int a12, CA::Mat4Impl *a13, int a14, unsigned int a15, unint64_t *a16, CA::Render::Server *a17)
{
  uint64_t v25;
  mach_vm_size_t v26;
  const audit_token_t *v27;
  CFStringRef v28;
  void (***v29)(_anonymous_namespace_::MIGRenderBuffer *__hidden);
  _DWORD *v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int v33;
  ipc_space_t *v34;
  void (**v37)(_anonymous_namespace_::MIGRenderBuffer *__hidden);
  int v38;
  int v39;
  uint64_t v40;
  _DWORD *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  uint64_t v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v25 = 4213784577;
  v26 = 4 * a3;
  if ((CA::Render::Server::audit_token_cache_lookup(a17, (const audit_token_t *)a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a17, v27) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01)
    {
      v28 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
      if (v28)
      {
        CFRelease(v28);
        v48 = 0;
        v46 = 0u;
        v47 = 0u;
        v44 = 0u;
        v45 = 0u;
        v42 = 0u;
        v43 = 0u;
        v37 = &off_1E158C098;
        v38 = a4;
        v39 = a5;
        v40 = a6;
        v41 = CA::Render::Shmem::new_shmem(a7, a8, 1, a10);
        v29 = &v37;
        if (!v41)
          v29 = 0;
        *(_QWORD *)&v43 = v29;
        v37 = &off_1E158C098;
        v30 = v41;
        if (v41)
        {
          v31 = v41 + 2;
          do
          {
            v32 = __ldaxr(v31);
            v33 = v32 - 1;
          }
          while (__stlxr(v33, v31));
          if (!v33)
            (*(void (**)(_DWORD *))(*(_QWORD *)v30 + 16))(v30);
        }
        mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)a2, v26);
        return v25;
      }
    }
    v25 = 4;
  }
  v34 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)a2, v26);
  if (a7)
    mach_port_deallocate(*v34, a7);
  return v25;
}

void `anonymous namespace'::MIGRenderBuffer::~MIGRenderBuffer(_anonymous_namespace_::MIGRenderBuffer *this)
{
  unsigned int *v1;
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  *(_QWORD *)this = &off_1E158C098;
  v1 = (unsigned int *)*((_QWORD *)this + 3);
  if (v1)
  {
    v2 = v1 + 2;
    do
    {
      v3 = __ldaxr(v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, v2));
    if (!v4)
      (*(void (**)(unsigned int *))(*(_QWORD *)v1 + 16))(v1);
  }
}

{
  unsigned int *v1;
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  *(_QWORD *)this = &off_1E158C098;
  v1 = (unsigned int *)*((_QWORD *)this + 3);
  if (v1)
  {
    v2 = v1 + 2;
    do
    {
      v3 = __ldaxr(v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, v2));
    if (!v4)
      (*(void (**)(unsigned int *))(*(_QWORD *)v1 + 16))(v1);
  }
  JUMPOUT(0x186DBD990);
}

uint64_t CA::Render::RenderTarget::is_iosurface(CA::Render::RenderTarget *this)
{
  return 0;
}

uint64_t CASRenderDisplayLayerShmem(const char *a1, CA::Render::Context *a2, uint64_t a3, int a4, int a5, uint64_t a6, mem_entry_name_port_t a7, mach_vm_size_t a8, double a9, int a10, int a11, int a12, CA::Mat4Impl *a13, unsigned int a14, unint64_t *a15, CA::Render::Server *a16)
{
  uint64_t v25;
  const audit_token_t *v26;
  CFStringRef v27;
  void (***v28)(_anonymous_namespace_::MIGRenderBuffer *__hidden);
  _DWORD *v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;
  void (**v34)(_anonymous_namespace_::MIGRenderBuffer *__hidden);
  int v35;
  int v36;
  uint64_t v37;
  _DWORD *v38;
  _OWORD v39[2];
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v25 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(a16, (const audit_token_t *)a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a16, v26) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01)
    {
      v27 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
      if (v27)
      {
        CFRelease(v27);
        v43 = 0;
        v41 = 0u;
        v42 = 0u;
        v40 = 0u;
        memset(v39, 0, sizeof(v39));
        v34 = &off_1E158C098;
        v35 = a4;
        v36 = a5;
        v37 = a6;
        v38 = CA::Render::Shmem::new_shmem(a7, a8, 1, a10);
        v28 = &v34;
        if (!v38)
          v28 = 0;
        *(_QWORD *)&v40 = v28;
        v34 = &off_1E158C098;
        v29 = v38;
        if (v38)
        {
          v30 = v38 + 2;
          do
          {
            v31 = __ldaxr(v30);
            v32 = v31 - 1;
          }
          while (__stlxr(v32, v30));
          if (!v32)
            (*(void (**)(_DWORD *))(*(_QWORD *)v29 + 16))(v29);
        }
        return v25;
      }
    }
    v25 = 4;
  }
  if (a7)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], a7);
  return v25;
}

uint64_t CASRenderDisplayContextListSurface(const char *a1, const audit_token_t *a2, unsigned int a3, mach_port_t a4, int a5, int a6, CA::Mat4Impl *a7, unsigned int a8, double a9, unsigned int a10, unint64_t *a11, CA::Render::Server *a12)
{
  uint64_t v19;
  mach_vm_size_t v20;
  mach_vm_size_t v21;
  const audit_token_t *v22;
  CFStringRef v23;
  __IOSurface *v24;
  __IOSurface *v25;
  BOOL v26;
  vm_map_t *v27;
  __IOSurface *cf;
  void (**v32)(CA::Render::RenderSurface *__hidden);
  int Width;
  int Height;
  __IOSurface *v35;
  _OWORD v36[2];
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v19 = 4213784577;
  v20 = 4 * a3;
  v21 = (unint64_t)a8 << 7;
  if ((CA::Render::Server::audit_token_cache_lookup(a12, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a12, v22) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01
      && (v23 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20])) != 0)
    {
      CFRelease(v23);
      v39 = 0u;
      v40 = 0u;
      v37 = 0u;
      v38 = 0u;
      memset(v36, 0, sizeof(v36));
      v24 = IOSurfaceLookupFromMachPort(a4);
      if (v24)
      {
        v32 = &off_1E1597280;
        v35 = v24;
        v25 = v24;
        cf = v24;
        Width = IOSurfaceGetWidth(v24);
        Height = IOSurfaceGetHeight(v25);
        *(_QWORD *)&v37 = &v32;
        v26 = IOSurfaceGetProtectionOptions() != 0;
        CFRelease(cf);
      }
      else
      {
        v19 = 5;
      }
    }
    else
    {
      v19 = 4;
    }
  }
  v27 = (vm_map_t *)MEMORY[0x1E0C83DA0];
  mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)a7, v21);
  mach_vm_deallocate(*v27, (mach_vm_address_t)a2, v20);
  if (a4)
    mach_port_deallocate(*v27, a4);
  return v19;
}

uint64_t `anonymous namespace'::render_display_context_list(const char *a1, uint64_t a2, unsigned int a3, int a4, int a5, CA::Mat4Impl *a6, unsigned int a7, BOOL *a8, double a9, unint64_t *a10, _anonymous_namespace_ *a11, uint64_t a12, char a13)
{
  size_t v22;
  char *v23;
  char *v24;
  size_t v25;
  char *v26;
  _BYTE *v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  CFStringRef v39;
  int v40;
  char v41;
  uint64_t v42;
  unsigned int *v43;
  unsigned int *v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t v48;
  const char *v49;
  int v50;
  int v51;
  uint64_t v52;
  _OWORD v53[9];
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  if (a3 > 0x200)
  {
    v24 = (char *)malloc_type_malloc(8 * a3, 0x79E90E77uLL);
    v23 = v24;
  }
  else
  {
    MEMORY[0x1E0C80A78](a1);
    v23 = (char *)&v48 - ((v22 + 15) & 0xFFFFFFFF0);
    bzero(v23, v22);
  }
  if (a7 <= 0x1A)
  {
    MEMORY[0x1E0C80A78](v24);
    v26 = (char *)&v48 - ((v25 + 15) & 0x1FFFFFFFFF0);
    bzero(v26, v25);
    if (v23)
      goto LABEL_6;
LABEL_19:
    v38 = 5;
    goto LABEL_43;
  }
  v26 = (char *)malloc_type_malloc(152 * a7, 0xC8972095uLL);
  if (!v23)
    goto LABEL_19;
LABEL_6:
  v49 = a1;
  v50 = a4;
  v51 = a5;
  v52 = a7;
  if (a7)
  {
    v27 = v26 + 144;
    v28 = v52;
    do
    {
      CA::Transform::set((uint64_t)v53, a6, 1);
      v29 = v53[1];
      v30 = v53[2];
      v31 = v53[3];
      *((_OWORD *)v27 - 9) = v53[0];
      *((_OWORD *)v27 - 8) = v29;
      *((_OWORD *)v27 - 7) = v30;
      *((_OWORD *)v27 - 6) = v31;
      v32 = v53[5];
      v33 = v53[6];
      v34 = v53[7];
      *((_OWORD *)v27 - 5) = v53[4];
      *((_OWORD *)v27 - 4) = v32;
      *((_OWORD *)v27 - 3) = v33;
      *((_OWORD *)v27 - 2) = v34;
      *((_OWORD *)v27 - 1) = v53[8];
      *v27 = *v27 & 0xE0 | v54 & 0x1F;
      v27 += 152;
      a6 = (CA::Mat4Impl *)((char *)a6 + 128);
      --v28;
    }
    while (v28);
  }
  if (a3)
  {
    v35 = 0;
    while (1)
    {
      v36 = CA::Render::Context::context_by_id((CA::Render::Context *)*(unsigned int *)(a2 + 4 * v35));
      *(_QWORD *)&v23[8 * v35] = v36;
      if (!v36)
        break;
      if (a3 == ++v35)
      {
        LODWORD(v35) = a3;
        break;
      }
    }
    if ((a13 & 1) == 0)
      goto LABEL_15;
  }
  else
  {
    LODWORD(v35) = 0;
    if ((a13 & 1) == 0)
    {
LABEL_15:
      if ((a13 & 2) == 0)
        *(_DWORD *)(a12 + 56) = 0x10000;
      v37 = *(_BYTE *)(a12 + 88) | 1;
      goto LABEL_22;
    }
  }
  *(_DWORD *)a12 = 0;
  *(_BYTE *)(a12 + 4) = 1;
  v37 = *(_BYTE *)(a12 + 88) & 0xFE;
LABEL_22:
  *(_BYTE *)(a12 + 88) = v37;
  v38 = 5;
  if (a3 && (_DWORD)v35 == a3)
  {
    v39 = CFStringCreateWithCString(0, v49, 0x8000100u);
    *(_QWORD *)(a12 + 8) = v39;
    *(_QWORD *)(a12 + 16) = a3;
    *(_QWORD *)(a12 + 24) = v23;
    v40 = v51;
    *(_DWORD *)(a12 + 40) = v50;
    *(_DWORD *)(a12 + 44) = v40;
    *(double *)(a12 + 48) = a9;
    *(_QWORD *)(a12 + 64) = v52;
    *(_QWORD *)(a12 + 72) = v26;
    *(_QWORD *)(a12 + 80) = 0;
    LOBYTE(v40) = *(_BYTE *)(a12 + 88) & 0xC9;
    *(_BYTE *)(a12 + 7) = ((unsigned __int16)a8 & 0x400) != 0;
    *(_BYTE *)(a12 + 88) = BYTE1(a8) & 0x10 | (a8 >> 5) & 4 | (a8 >> 10) & 2 | v40;
    if (*(_QWORD *)(a12 + 32))
    {
      CA::Render::post_notification(0x15u, 0, a12, 0);
      v39 = *(CFStringRef *)(a12 + 8);
    }
    if (v39)
      CFRelease(v39);
    v41 = *(_BYTE *)(a12 + 88);
    if (a10)
    {
      *a10 = *(_QWORD *)(a12 + 80) | ((unint64_t)(*(_BYTE *)(a12 + 88) & 0x20) << 58);
      v41 = *(_BYTE *)(a12 + 88);
    }
    if ((v41 & 0x20) != 0)
      v38 = 0;
    else
      v38 = 5;
  }
  if ((_DWORD)v35)
  {
    v42 = 0;
    do
    {
      v43 = *(unsigned int **)&v23[8 * v42];
      if (v43)
      {
        v44 = v43 + 2;
        do
        {
          v45 = __ldaxr(v44);
          v46 = v45 - 1;
        }
        while (__stlxr(v46, v44));
        if (!v46)
          (*(void (**)(unsigned int *))(*(_QWORD *)v43 + 16))(v43);
      }
      ++v42;
    }
    while (v42 != v35);
  }
  if (a3 > 0x200)
    free(v23);
LABEL_43:
  if (a7 >= 0x1B && v26)
    free(v26);
  return v38;
}

uint64_t CASRenderDisplayContextListShmem(const char *a1, const audit_token_t *a2, unsigned int a3, int a4, int a5, uint64_t a6, mem_entry_name_port_t a7, mach_vm_size_t a8, double a9, int a10, int a11, int a12, CA::Mat4Impl *a13, unsigned int a14, unsigned int a15, unint64_t *a16, CA::Render::Server *a17)
{
  uint64_t v22;
  mach_vm_size_t v23;
  const audit_token_t *v24;
  CFStringRef v25;
  void (***v26)(_anonymous_namespace_::MIGRenderBuffer *__hidden);
  _DWORD *v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int v30;
  vm_map_t *v31;
  void (**v37)(_anonymous_namespace_::MIGRenderBuffer *__hidden);
  int v38;
  int v39;
  uint64_t v40;
  _DWORD *v41;
  _OWORD v42[2];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v22 = 4213784577;
  v23 = 4 * a3;
  if ((CA::Render::Server::audit_token_cache_lookup(a17, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a17, v24) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01
      && (v25 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20])) != 0)
    {
      CFRelease(v25);
      v45 = 0u;
      v46 = 0u;
      v43 = 0u;
      v44 = 0u;
      memset(v42, 0, sizeof(v42));
      v37 = &off_1E158C098;
      v38 = a4;
      v39 = a5;
      v40 = a6;
      v41 = CA::Render::Shmem::new_shmem(a7, a8, 1, a10);
      v26 = &v37;
      if (!v41)
        v26 = 0;
      *(_QWORD *)&v43 = v26;
      v37 = &off_1E158C098;
      v27 = v41;
      if (v41)
      {
        v28 = v41 + 2;
        do
        {
          v29 = __ldaxr(v28);
          v30 = v29 - 1;
        }
        while (__stlxr(v30, v28));
        if (!v30)
          (*(void (**)(_DWORD *))(*(_QWORD *)v27 + 16))(v27);
      }
      a7 = 0;
    }
    else
    {
      v22 = 4;
    }
  }
  v31 = (vm_map_t *)MEMORY[0x1E0C83DA0];
  mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)a13, (unint64_t)a14 << 7);
  mach_vm_deallocate(*v31, (mach_vm_address_t)a2, v23);
  if (a7)
    mach_port_deallocate(*v31, a7);
  return v22;
}

uint64_t CASCaptureDisplay(const char *a1, _anonymous_namespace_ *a2, unsigned int *a3, _anonymous_namespace_ *a4, int a5, int a6, int a7, int a8, double a9, CA::Mat4Impl *a10, int a11, unsigned int a12, CA::Render::Server *a13)
{
  uint64_t v22;
  const audit_token_t *v23;
  CFStringRef v24;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  int v31;
  int v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v22 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(a13, (const audit_token_t *)a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a13, v23) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01
      && (v24 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20])) != 0)
    {
      CFRelease(v24);
      v34 = 8;
      v30 = 0;
      v33 = 0u;
      v28 = 0u;
      v29 = 0u;
      v26 = 0u;
      v27 = 0u;
      v31 = a6;
      v32 = a5;
      if ((_QWORD)v27)
        (*(void (**)(_QWORD))(*(_QWORD *)v27 + 8))(v27);
    }
    else
    {
      v22 = 4;
    }
  }
  mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)a2, 4 * a3);
  return v22;
}

_QWORD *`anonymous namespace'::retain_slot_buffer(_anonymous_namespace_ *this)
{
  uint64_t v1;
  unsigned int *v2;
  int v3;
  malloc_zone_t *v4;
  _QWORD *v5;
  _QWORD *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int *v9;
  malloc_zone_t *malloc_zone;
  _QWORD *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int *v14;
  malloc_zone_t *v15;
  _QWORD *v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int *v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;

  v1 = CA::Render::Context::copy_slot(this);
  if (!v1)
    return 0;
  v2 = (unsigned int *)v1;
  v3 = *(unsigned __int8 *)(v1 + 12);
  switch(v3)
  {
    case 51:
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      v11 = malloc_type_zone_malloc(malloc_zone, 0x20uLL, 0x8BB15036uLL);
      v6 = v11;
      if (v11)
      {
        *v11 = off_1E158C058;
        v12 = v2 + 2;
        do
          v13 = __ldaxr(v12);
        while (__stlxr(v13 + 1, v12));
        v14 = v2;
        if (!v13)
        {
          v14 = 0;
          do
            v26 = __ldaxr(v12);
          while (__stlxr(v26 - 1, v12));
        }
        v11[2] = *((_QWORD *)v2 + 14);
        v11[3] = v14;
        v11[1] = *((_QWORD *)v2 + 2);
      }
      goto LABEL_23;
    case 23:
      if (*(_QWORD *)(v1 + 120))
      {
        v15 = (malloc_zone_t *)get_malloc_zone();
        v16 = malloc_type_zone_malloc(v15, 0x28uLL, 0x8BB15036uLL);
        v6 = v16;
        if (v16)
        {
          *v16 = off_1E158C120;
          v17 = v2 + 2;
          do
            v18 = __ldaxr(v17);
          while (__stlxr(v18 + 1, v17));
          v19 = v2;
          if (!v18)
          {
            v19 = 0;
            do
              v27 = __ldaxr(v17);
            while (__stlxr(v27 - 1, v17));
          }
          v16[4] = v19;
          v16[1] = *((_QWORD *)v2 + 2);
          v20 = *((_QWORD *)v2 + 15);
          v16[2] = *((_QWORD *)v2 + 20);
          v16[3] = v20;
        }
        goto LABEL_23;
      }
      break;
    case 11:
      v4 = (malloc_zone_t *)get_malloc_zone();
      v5 = malloc_type_zone_malloc(v4, 0x20uLL, 0x8BB15036uLL);
      v6 = v5;
      if (v5)
      {
        *v5 = off_1E158C160;
        v7 = v2 + 2;
        do
          v8 = __ldaxr(v7);
        while (__stlxr(v8 + 1, v7));
        v9 = v2;
        if (!v8)
        {
          v9 = 0;
          do
            v25 = __ldaxr(v7);
          while (__stlxr(v25 - 1, v7));
        }
        v5[1] = *((_QWORD *)v2 + 3);
        v5[2] = 0;
        v5[3] = v9;
      }
      goto LABEL_23;
  }
  v6 = 0;
LABEL_23:
  v21 = v2 + 2;
  do
  {
    v22 = __ldaxr(v21);
    v23 = v22 - 1;
  }
  while (__stlxr(v23, v21));
  if (!v23)
    (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 16))(v2);
  return v6;
}

void `anonymous namespace'::SlotRenderBuffer::~SlotRenderBuffer(_anonymous_namespace_::SlotRenderBuffer *this)
{
  unsigned int *v1;
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  *(_QWORD *)this = off_1E158C120;
  v1 = (unsigned int *)*((_QWORD *)this + 4);
  if (v1)
  {
    v2 = v1 + 2;
    do
    {
      v3 = __ldaxr(v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, v2));
    if (!v4)
      (*(void (**)(unsigned int *))(*(_QWORD *)v1 + 16))(v1);
  }
}

{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  malloc_zone_t *malloc_zone;

  *(_QWORD *)this = off_1E158C120;
  v2 = (unsigned int *)*((_QWORD *)this + 4);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 16))(v2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

void `anonymous namespace'::SlotIOSurface::~SlotIOSurface(_anonymous_namespace_::SlotIOSurface *this)
{
  unsigned int *v1;
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  *(_QWORD *)this = off_1E158C058;
  v1 = (unsigned int *)*((_QWORD *)this + 3);
  if (v1)
  {
    v2 = v1 + 2;
    do
    {
      v3 = __ldaxr(v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, v2));
    if (!v4)
      (*(void (**)(unsigned int *))(*(_QWORD *)v1 + 16))(v1);
  }
}

{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  malloc_zone_t *malloc_zone;

  *(_QWORD *)this = off_1E158C058;
  v2 = (unsigned int *)*((_QWORD *)this + 3);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 16))(v2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

uint64_t `anonymous namespace'::SlotIOSurface::set_edr_factor(_anonymous_namespace_::SlotIOSurface *this, float a2)
{
  *(_WORD *)(*((_QWORD *)this + 3) + 336) = *(_WORD *)(*((_QWORD *)this + 3) + 336) & 0xFFEF | (16 * (a2 != 1.0));
  return CA::Render::Surface::set_edr_factor(*((_QWORD *)this + 3), a2);
}

void `anonymous namespace'::DeferredImageSlotIOSurface::~DeferredImageSlotIOSurface(_anonymous_namespace_::DeferredImageSlotIOSurface *this)
{
  unsigned int *v1;
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  *(_QWORD *)this = off_1E158C160;
  v1 = (unsigned int *)*((_QWORD *)this + 3);
  if (v1)
  {
    v2 = v1 + 2;
    do
    {
      v3 = __ldaxr(v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, v2));
    if (!v4)
      (*(void (**)(unsigned int *))(*(_QWORD *)v1 + 16))(v1);
  }
}

{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  malloc_zone_t *malloc_zone;

  *(_QWORD *)this = off_1E158C160;
  v2 = (unsigned int *)*((_QWORD *)this + 3);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 16))(v2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

void `anonymous namespace'::DeferredImageSlotIOSurface::realize_buffer(_anonymous_namespace_::DeferredImageSlotIOSurface *this, uint64_t a2, unsigned int a3, int a4, CGColorSpace *a5, uint64_t a6, const __CFString *a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  CA::Render *v23;
  __IOSurface *iosurface_with_pixel_format;
  __IOSurface *v25;
  malloc_zone_t *malloc_zone;
  CA::Render::Texture *v27;
  CA::Render::Texture *v28;
  unsigned int *v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int *v33;
  unsigned int v34;
  CA::Render::Texture *v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  unsigned int v40;

  v11 = *((_QWORD *)this + 3);
  v12 = *(_QWORD *)(v11 + 16);
  if (v12)
  {
    v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 240))(v12);
    v14 = *(unsigned int **)(v11 + 16);
    if ((a2 & ~v13) != 0)
    {
      if (v14)
      {
        v15 = v14 + 2;
        do
        {
          v16 = __ldaxr(v15);
          v17 = v16 - 1;
        }
        while (__stlxr(v17, v15));
        if (!v17)
          (*(void (**)(unsigned int *))(*(_QWORD *)v14 + 16))(v14);
        *(_QWORD *)(v11 + 16) = 0;
      }
    }
    else if (v14)
    {
      goto LABEL_48;
    }
  }
  if (*(_BYTE *)(v11 + 32))
    v18 = 35;
  else
    v18 = 33;
  if (*(_BYTE *)(v11 + 32))
    v19 = 1;
  else
    v19 = 3;
  if (*(_BYTE *)(v11 + 33))
    v20 = v18;
  else
    v20 = v19;
  if (a4)
    v21 = 13;
  else
    v21 = v20;
  if (v21 == 3)
    v22 = 1;
  else
    v22 = v21;
  if (((0x61CB910CuLL >> v22) & 1) == 0)
  {
    v23 = (CA::Render *)dword_184750604[v22];
    if (initialized[0] != -1)
      dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
    iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format(v23, *(_DWORD *)(v11 + 24), *(_DWORD *)(v11 + 28), 2 * (*(float *)&dword_1ECDC6948 == 0), a2, CFSTR("CA Image Slot"), a7);
    if (iosurface_with_pixel_format)
    {
      v25 = iosurface_with_pixel_format;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      v27 = (CA::Render::Texture *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x158uLL, 0x743898A5uLL);
      if (v27)
      {
        v28 = v27;
        CA::Render::Surface::Surface((uint64_t)v27, v25, v21, 0, 0, 0, 0);
        if (a5)
          CA::Render::Texture::set_colorspace(v28, a5);
        v29 = *(unsigned int **)(v11 + 16);
        if (v29 != (unsigned int *)v28)
        {
          if (v29)
          {
            v30 = v29 + 2;
            do
            {
              v31 = __ldaxr(v30);
              v32 = v31 - 1;
            }
            while (__stlxr(v32, v30));
            if (!v32)
              (*(void (**)(unsigned int *))(*(_QWORD *)v29 + 16))(v29);
          }
          v33 = (unsigned int *)((char *)v28 + 8);
          do
            v34 = __ldaxr(v33);
          while (__stlxr(v34 + 1, v33));
          v35 = v28;
          if (!v34)
          {
            v35 = 0;
            do
              v40 = __ldaxr(v33);
            while (__stlxr(v40 - 1, v33));
          }
          *(_QWORD *)(v11 + 16) = v35;
        }
        IOSurfaceSetOwnershipIdentity();
        v36 = (unsigned int *)((char *)v28 + 8);
        do
        {
          v37 = __ldaxr(v36);
          v38 = v37 - 1;
        }
        while (__stlxr(v38, v36));
        if (!v38)
          (*(void (**)(CA::Render::Texture *))(*(_QWORD *)v28 + 16))(v28);
      }
      else
      {
        CFRelease(v25);
      }
    }
  }
LABEL_48:
  v39 = *(_QWORD *)(*((_QWORD *)this + 3) + 16);
  if (v39)
    v39 = *(_QWORD *)(v39 + 112);
  *((_QWORD *)this + 2) = v39;
}

uint64_t `anonymous namespace'::DeferredImageSlotIOSurface::set_edr_factor(_anonymous_namespace_::DeferredImageSlotIOSurface *this, float a2)
{
  uint64_t result;

  result = *(_QWORD *)(*((_QWORD *)this + 3) + 16);
  if (result)
  {
    *(_WORD *)(result + 336) = *(_WORD *)(result + 336) & 0xFFEF | (16 * (a2 != 1.0));
    return CA::Render::Surface::set_edr_factor(result, a2);
  }
  return result;
}

uint64_t CASCaptureDisplayLayer(const char *a1, CA::Render::Context *a2, uint64_t a3, _anonymous_namespace_ *a4, int a5, int a6, int a7, CA::Mat4Impl *a8, double a9, unsigned int a10, CA::Render::Server *a11)
{
  uint64_t v20;
  const audit_token_t *v21;
  CFStringRef v22;
  _OWORD v24[2];
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v20 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(a11, (const audit_token_t *)a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a11, v21) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01
      && (v22 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20])) != 0)
    {
      CFRelease(v22);
      v28 = 128;
      v26 = 0u;
      v27 = 0u;
      v25 = 0u;
      memset(v24, 0, sizeof(v24));
      HIDWORD(v26) = a5;
      if ((_QWORD)v25)
        (*(void (**)(_QWORD))(*(_QWORD *)v25 + 8))(v25);
    }
    else
    {
      return 4;
    }
  }
  return v20;
}

uint64_t CASCaptureDisplayContextList(const char *a1, const audit_token_t *a2, unsigned int a3, _anonymous_namespace_ *a4, int a5, int a6, int a7, CA::Mat4Impl *a8, double a9, unsigned int a10, unsigned int a11, CA::Render::Server *a12)
{
  uint64_t v20;
  const audit_token_t *v21;
  CFStringRef v22;
  vm_map_t *v23;
  _OWORD v26[2];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v20 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(a12, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a12, v21) & 0x20000) == 0)
  {
    if (strnlen(a1, 0x100uLL) - 256 >= 0xFFFFFF01
      && (v22 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20])) != 0)
    {
      CFRelease(v22);
      v29 = 0u;
      v30 = 0u;
      v27 = 0u;
      v28 = 0u;
      memset(v26, 0, sizeof(v26));
      BYTE8(v30) = 8;
      HIDWORD(v28) = a5;
      if ((_QWORD)v27)
        (*(void (**)(_QWORD))(*(_QWORD *)v27 + 8))(v27);
    }
    else
    {
      v20 = 4;
    }
  }
  v23 = (vm_map_t *)MEMORY[0x1E0C83DA0];
  mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)a8, (unint64_t)a10 << 7);
  mach_vm_deallocate(*v23, (mach_vm_address_t)a2, 4 * a3);
  return v20;
}

uint64_t CASSetDisplayProperties(int a1, const audit_token_t *a2, int a3, uint64_t a4, int a5, char a6, unsigned int a7, int a8, float a9, float a10, int a11, unsigned __int8 a12, unsigned int a13, mach_port_name_t a14, CA::Render::Server *a15)
{
  int v23;
  uint64_t v24;
  const audit_token_t *v25;
  const audit_token_t *v26;
  char v27;
  unsigned int v28;
  __int128 v30;
  __int128 v31;
  float v32;
  int v33;
  int v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (a14 - 1 > 0xFFFFFFFD)
    return 5;
  v23 = (int)a2;
  v24 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(a15, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(a15, v25) & 0x20000) == 0)
  {
    if (initialized[0] != -1)
      dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
    v24 = 5;
    if (!a3 && !byte_1ECDC6AA2)
    {
      v27 = CA::Render::Server::audit_token_cache_lookup(a15, v26);
      v28 = a13 & 0xFFFFFFCF;
      v30 = 0u;
      v31 = 0u;
      if ((v27 & 2) != 0)
        v28 = a13;
      LODWORD(v30) = v23;
      *((_QWORD *)&v30 + 1) = a4;
      LODWORD(v31) = a5;
      BYTE4(v31) = a6;
      *((_QWORD *)&v31 + 1) = __PAIR64__(LODWORD(a9), a7);
      v32 = a10;
      v33 = a8;
      v34 = a12;
      v35 = v28;
      v36 = a14;
      CA::Render::post_notification(0x20u, 0, (uint64_t)&v30, 0);
      v24 = 0;
    }
  }
  mach_port_deallocate(*MEMORY[0x1E0C83DA0], a14);
  return v24;
}

uint64_t CASSetDisplayPresetProperties(int a1, const audit_token_t *a2, mach_port_name_t a3, CA::Render::Server *this, double a5, double a6, double a7, double a8)
{
  unsigned __int8 v14;
  uint64_t v16;
  const audit_token_t *v17;
  const audit_token_t *v18;
  _DWORD v20[2];
  double v21;
  double v22;
  double v23;
  double v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (a3 - 1 > 0xFFFFFFFD)
    return 5;
  v14 = a2;
  v16 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v17) & 0x20000) == 0)
  {
    if ((CA::Render::Server::audit_token_cache_lookup(this, v18) & 0x4000) == 0)
      goto LABEL_8;
    if (initialized[0] != -1)
      dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
    if (!byte_1ECDC6AA2)
    {
      v20[0] = a1;
      v20[1] = v14;
      v21 = a5;
      v22 = a6;
      v23 = a7;
      v24 = a8;
      v25 = a3;
      CA::Render::post_notification(0x21u, 0, (uint64_t)v20, 0);
      v16 = 0;
    }
    else
    {
LABEL_8:
      v16 = 5;
    }
  }
  mach_port_deallocate(*MEMORY[0x1E0C83DA0], a3);
  return v16;
}

uint64_t CASSetDisplayLatency(int a1, const audit_token_t *a2, uint64_t a3, CA::Render::Server *this, double a5)
{
  uint64_t v10;
  const audit_token_t *v11;
  __int128 v12;
  __int128 v13;
  _DWORD v15[2];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  double v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v10 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v11) & 0x20000) == 0)
  {
    if (LOBYTE(a2->val[0]))
    {
      v15[0] = 0;
      v15[1] = a1;
      v12 = *(_OWORD *)&a2->val[4];
      v16 = *(_OWORD *)a2->val;
      v17 = v12;
      v13 = *(_OWORD *)&a2[1].val[4];
      v18 = *(_OWORD *)a2[1].val;
      v19 = v13;
      v20 = a3;
      v21 = a5;
      CA::Render::post_notification(0x23u, 0, (uint64_t)v15, 0);
      if (LOBYTE(v15[0]))
        return 0;
      else
        return 56;
    }
    else
    {
      return 5;
    }
  }
  return v10;
}

uint64_t CASRegisterForDisallowedLayersNotification(mach_port_name_t a1, const audit_token_t *a2, CA::Render::Server *this)
{
  int v4;
  uint64_t v6;
  const audit_token_t *v7;
  const audit_token_t *v8;
  _DWORD v10[2];
  int v11;
  uint64_t v12;

  v4 = (int)a2;
  v12 = *MEMORY[0x1E0C80C00];
  v6 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v7) & 0x20000) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v8) & 0x10000) != 0)
  {
    if (a1 - 1 > 0xFFFFFFFD)
    {
      return 4;
    }
    else
    {
      v10[1] = a1;
      v11 = 0;
      v10[0] = v4;
      CA::Render::post_notification(0x24u, 0, (uint64_t)v10, 0);
      v6 = 0;
      if (!(_BYTE)v11)
      {
        mach_port_deallocate(*MEMORY[0x1E0C83DA0], a1);
        return 56;
      }
    }
  }
  return v6;
}

uint64_t CASUnregisterForDisallowedLayersNotification(int a1, const audit_token_t *a2, int a3, CA::Render::Server *this)
{
  mach_port_name_t v6;
  uint64_t v8;
  const audit_token_t *v9;
  const audit_token_t *v10;
  _DWORD v12[2];
  int v13;
  uint64_t v14;

  v6 = a2;
  v14 = *MEMORY[0x1E0C80C00];
  v8 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v9) & 0x20000) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v10) & 0x10000) != 0)
  {
    if (v6 - 1 > 0xFFFFFFFD)
      return 5;
    v12[1] = a1;
    v13 = 0;
    v12[0] = a3;
    CA::Render::post_notification(0x25u, 0, (uint64_t)v12, 0);
    v8 = 0;
    if (!(_BYTE)v13)
    {
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], v6);
      return 5;
    }
  }
  return v8;
}

uint64_t CASContentStreamModify(mach_port_name_t a1, const audit_token_t *a2, uint64_t a3, CA::Render::Server *this)
{
  mach_port_name_t v6;
  uint64_t v8;
  char v9;
  const audit_token_t *v10;
  ipc_space_t *v11;
  const audit_token_t *v12;
  uint64_t v14;
  mach_port_name_t v15;
  mach_port_name_t v16;
  uint64_t v17;
  uint64_t v18;

  v6 = a2;
  v18 = *MEMORY[0x1E0C80C00];
  v8 = 4213784577;
  v9 = CA::Render::Server::audit_token_cache_lookup(this, a2);
  v11 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  if (v9 < 0
    || (CA::Render::Server::audit_token_cache_lookup(this, v10) & 0x20000) != 0
    || (CA::Render::Server::audit_token_cache_lookup(this, v12) & 0x8000) == 0)
  {
    goto LABEL_11;
  }
  if (*(_BYTE *)(a3 + 65) != 1)
    goto LABEL_7;
  if (!v6)
  {
    v8 = 4;
    if (!a1)
      return v8;
    goto LABEL_14;
  }
  if (*(_DWORD *)a3)
  {
LABEL_7:
    v17 = 0;
    v14 = a3;
    v15 = a1;
    v16 = v6;
    CA::Render::post_notification(0x40u, 0, (uint64_t)&v14, 0);
    if (BYTE1(v17))
      v8 = 0;
    else
      v8 = 5;
    if ((_BYTE)v17)
      return v8;
LABEL_11:
    if (!v6)
      goto LABEL_13;
    goto LABEL_12;
  }
  v8 = 4;
LABEL_12:
  mach_port_deallocate(*v11, v6);
LABEL_13:
  if (a1)
LABEL_14:
    mach_port_deallocate(*v11, a1);
  return v8;
}

uint64_t CASContentStreamStartStop(CA::Render::ContentStream *a1, const audit_token_t *a2, unsigned int a3, unsigned int a4, unsigned int a5, CA::Render::Server *this)
{
  uint64_t v12;
  const audit_token_t *v13;
  const audit_token_t *v14;
  char *stream_and_lock;
  char *v16;
  __int128 v17;
  __int128 v18;
  mach_vm_size_t v19;
  ipc_space_t *v20;
  _QWORD v22[2];
  _OWORD v23[3];
  _BYTE v24[32];
  __int128 v25;
  _OWORD v26[2];
  void *v27[2];
  __int128 v28;
  _OWORD v29[2];
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v12 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v13) & 0x20000) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v14) & 0x8000) != 0)
  {
    stream_and_lock = (char *)CA::Render::ContentStream::get_or_create_stream_and_lock(a1, 0, 0);
    if (stream_and_lock)
    {
      if (a5 + a4 != a3)
        __assert_rtn("CASContentStreamStartStop", "render-server.cpp", 5048, "included_count + excluded_count == contexts_count");
      v16 = stream_and_lock;
      X::small_vector_base<unsigned int>::resize((uint64_t)(stream_and_lock + 136), a4);
      X::small_vector_base<unsigned int>::resize((uint64_t)(v16 + 200), a5);
      memcpy(*((void **)v16 + 17), a2, 4 * a4);
      memcpy(*((void **)v16 + 25), &a2->val[a4], 4 * a5);
      v16[400] = a3 != 0;
      v30 = 0;
      memset(v29, 0, sizeof(v29));
      *(_OWORD *)v27 = 0u;
      v28 = 0u;
      memset(v26, 0, sizeof(v26));
      *(_OWORD *)&v24[16] = 0u;
      v25 = 0u;
      v17 = *((_OWORD *)v16 + 7);
      v23[2] = *((_OWORD *)v16 + 6);
      *(_OWORD *)v24 = v17;
      *(_DWORD *)&v24[15] = *(_DWORD *)(v16 + 127);
      v18 = *((_OWORD *)v16 + 5);
      v23[0] = *((_OWORD *)v16 + 4);
      v23[1] = v18;
      *(_QWORD *)&v24[24] = (char *)v26 + 8;
      *(_QWORD *)&v25 = (char *)v26 + 8;
      *((_QWORD *)&v25 + 1) = (char *)v26 + 8;
      *(_QWORD *)&v26[0] = 8;
      X::small_vector_base<unsigned int>::append<unsigned int const*>((uint64_t)&v24[24], *((int **)v16 + 17), *((int **)v16 + 18));
      v27[1] = (char *)v29 + 8;
      *(_QWORD *)&v28 = (char *)v29 + 8;
      *((_QWORD *)&v28 + 1) = (char *)v29 + 8;
      *(_QWORD *)&v29[0] = 8;
      X::small_vector_base<unsigned int>::append<unsigned int const*>((uint64_t)&v27[1], *((int **)v16 + 25), *((int **)v16 + 26));
      pthread_mutex_unlock((pthread_mutex_t *)v16);
      v22[0] = v23;
      v22[1] = a3 != 0;
      if (!DWORD1(v23[0]))
        __assert_rtn("CASContentStreamStartStop", "render-server.cpp", 5065, "!\"implicit display not yet implemented\"");
      CA::Render::post_notification(0x3Fu, 0, (uint64_t)v22, 0);
      if (v27[1] != *((void **)&v28 + 1))
        free(v27[1]);
      if (*(_QWORD *)&v24[24] != *((_QWORD *)&v25 + 1))
        free(*(void **)&v24[24]);
      v12 = 0;
    }
    else
    {
      v12 = 56;
    }
  }
  v19 = 4 * a3;
  v20 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)a2, v19);
  if ((_DWORD)a1)
    mach_port_deallocate(*v20, (mach_port_name_t)a1);
  return v12;
}

void X::small_vector_base<unsigned int>::append<unsigned int const*>(uint64_t a1, int *a2, int *a3)
{
  int *v4;
  unint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  _DWORD *v9;
  int v10;

  v4 = a2;
  v6 = a3 - a2;
  v7 = *(_DWORD **)(a1 + 8);
  v8 = (uint64_t)v7 - *(_QWORD *)a1;
  if (v6 > *(_QWORD *)(a1 + 24) - (v8 >> 2))
  {
    X::small_vector_base<unsigned int>::grow((int **)a1, (v8 >> 2) + v6);
    v7 = *(_DWORD **)(a1 + 8);
  }
  if (v4 != a3)
  {
    v9 = v7;
    do
    {
      v10 = *v4++;
      *v9++ = v10;
    }
    while (v4 != a3);
  }
  *(_QWORD *)(a1 + 8) = &v7[v6];
}

uint64_t CASContentStreamReleaseSurf(CA::Render::ContentStream *a1, const audit_token_t *a2, CA::Render::Server *this)
{
  int v4;
  uint64_t v6;
  const audit_token_t *v7;
  const audit_token_t *v8;
  CA::Render::ContentStream *stream_and_lock;
  pthread_mutex_t *v10;
  _BOOL4 v11;

  v4 = (int)a2;
  v6 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v7) & 0x20000) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v8) & 0x8000) != 0)
  {
    stream_and_lock = (CA::Render::ContentStream *)CA::Render::ContentStream::get_or_create_stream_and_lock(a1, 0, 0);
    if (!stream_and_lock)
    {
      v6 = 56;
      if (!(_DWORD)a1)
        return v6;
      goto LABEL_9;
    }
    v10 = (pthread_mutex_t *)stream_and_lock;
    v11 = CA::Render::ContentStream::reuse_surface(stream_and_lock, v4);
    pthread_mutex_unlock(v10);
    if (v11)
      v6 = 0;
    else
      v6 = 5;
  }
  if ((_DWORD)a1)
LABEL_9:
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], (mach_port_name_t)a1);
  return v6;
}

uint64_t CASSetDisplayState(int a1, const audit_token_t *a2, unsigned __int8 a3, char a4, CA::Render::Server *this)
{
  int v8;
  uint64_t v10;
  const audit_token_t *v11;
  const audit_token_t *v12;
  _DWORD v14[2];
  int v15;
  uint64_t v16;

  v8 = (int)a2;
  v16 = *MEMORY[0x1E0C80C00];
  v10 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v11) & 0x20000) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v12) & 0x10000) != 0)
  {
    v14[1] = a1;
    v14[0] = v8;
    v15 = a3;
    BYTE1(v15) = a4;
    CA::Render::post_notification(0x42u, 0, (uint64_t)v14, 0);
    return 0;
  }
  return v10;
}

uint64_t _CreateDisplayPowerAssertion(int a1, const audit_token_t *a2, mach_port_name_t a3, int a4, unsigned __int8 a5, CA::Render::Server *this, audit_token_t *a7)
{
  int v11;
  uint64_t v13;
  const audit_token_t *v14;
  const audit_token_t *v15;
  _DWORD v17[4];
  int v18;
  uint64_t v19;

  v11 = (int)a2;
  v19 = *MEMORY[0x1E0C80C00];
  v13 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v14) & 0x20000) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v15) & 0x10000) != 0)
  {
    v17[3] = a4;
    v17[0] = a1;
    v17[1] = v11;
    v17[2] = a3;
    v18 = a5;
    CA::Render::post_notification(0x43u, 0, (uint64_t)v17, 0);
    v13 = 0;
    if (!BYTE1(v18))
    {
      if (a3)
        mach_port_deallocate(*MEMORY[0x1E0C83DA0], a3);
      return 5;
    }
  }
  return v13;
}

uint64_t CASDestroyDisplayPowerAssertion(int a1, const audit_token_t *a2, CA::Render::Server *this)
{
  mach_port_name_t v4;
  uint64_t v6;
  const audit_token_t *v7;
  const audit_token_t *v8;
  _DWORD v10[2];
  int v11;
  uint64_t v12;

  v4 = a2;
  v12 = *MEMORY[0x1E0C80C00];
  v6 = 4213784577;
  if ((CA::Render::Server::audit_token_cache_lookup(this, a2) & 0x80) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v7) & 0x20000) == 0
    && (CA::Render::Server::audit_token_cache_lookup(this, v8) & 0x10000) != 0)
  {
    v10[1] = v4;
    v11 = 0;
    v10[0] = a1;
    CA::Render::post_notification(0x44u, 0, (uint64_t)v10, 0);
    if (v4)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], v4);
    if ((_BYTE)v11)
      return 0;
    else
      return 5;
  }
  return v6;
}

char *CA::convert_bgra8888_to_mask(char *this, char *a2, char *a3, char *a4, uint64_t a5, uint64_t a6)
{
  char *v6;
  uint64_t v7;
  char *v8;
  char v9;
  char v10;
  char v11;
  char v12;
  BOOL v13;
  char *v14;
  unint64_t v15;
  char v16;

  if (a6 >= 1)
  {
    do
    {
      v6 = a3;
      v7 = a5;
      v8 = this;
      if (a5 >= 4)
      {
        do
        {
          v9 = v8[3];
          v10 = v8[7];
          v11 = v8[11];
          v12 = v8[15];
          v8 += 16;
          *v6 = v9;
          v6[1] = v10;
          v6[2] = v11;
          v6[3] = v12;
          v6 += 4;
          v13 = (unint64_t)v7 > 7;
          v7 -= 4;
        }
        while (v13);
      }
      if (v7 >= 1)
      {
        v14 = v8 + 3;
        v15 = v7 + 1;
        do
        {
          v16 = *v14;
          v14 += 4;
          *v6++ = v16;
          --v15;
        }
        while (v15 > 1);
      }
      this = &a2[(_QWORD)this];
      a3 = &a4[(_QWORD)a3];
      v13 = a6-- <= 1;
    }
    while (!v13);
  }
  return this;
}

void CA::Render::PixelBuffer::~PixelBuffer(CA::Render::PixelBuffer *this)
{
  malloc_zone_t *malloc_zone;

  CA::Render::PixelBuffer::~PixelBuffer(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

{
  const void *v2;
  const void *v3;
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;

  *(_QWORD *)this = off_1E1596528;
  v2 = (const void *)*((_QWORD *)this + 15);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 17);
  if (v3)
    CFRelease(v3);
  v4 = (unsigned int *)*((_QWORD *)this + 16);
  if (v4)
  {
    v5 = v4 + 2;
    do
    {
      v6 = __ldaxr(v5);
      v7 = v6 - 1;
    }
    while (__stlxr(v7, v5));
    if (!v7)
      (*(void (**)(unsigned int *))(*(_QWORD *)v4 + 16))(v4);
  }
  v8 = (unsigned int *)*((_QWORD *)this + 12);
  if (v8)
  {
    v9 = v8 + 2;
    do
    {
      v10 = __ldaxr(v9);
      v11 = v10 - 1;
    }
    while (__stlxr(v11, v9));
    if (!v11)
      (*(void (**)(unsigned int *))(*(_QWORD *)v8 + 16))(v8);
  }
  --dword_1ECDC7CC0;
  CA::Render::Texture::~Texture((CGColorSpaceRef *)this);
}

void CA::Render::PixelBuffer::finalize(CA::Render::PixelBuffer *this)
{
  CA::Render::post_notification(3u, (unint64_t)this, 0, 1);
  if (this)
    (*(void (**)(CA::Render::PixelBuffer *))(*(_QWORD *)this + 8))(this);
}

double CA::Render::PixelBuffer::encode(CA::Render::PixelBuffer *this, CA::Render::Encoder *a2)
{
  int v4;
  _DWORD *v5;
  uint64_t v6;
  unint64_t v7;
  _DWORD *v8;
  int v9;
  uint64_t v10;
  unint64_t v11;
  _DWORD *v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  unint64_t v17;
  _DWORD *v18;
  int v19;
  double result;

  v4 = *((_DWORD *)this + 3) >> 8;
  v5 = (_DWORD *)*((_QWORD *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((_QWORD *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    v5 = (_DWORD *)*((_QWORD *)a2 + 4);
  }
  *v5 = v4;
  v6 = *((_QWORD *)a2 + 4);
  v7 = *((_QWORD *)a2 + 5);
  v8 = (_DWORD *)(v6 + 4);
  *((_QWORD *)a2 + 4) = v6 + 4;
  v9 = *((_DWORD *)this + 4);
  if (v6 + 8 > v7)
  {
    CA::Render::Encoder::grow(a2, 4);
    v8 = (_DWORD *)*((_QWORD *)a2 + 4);
  }
  *v8 = v9;
  v10 = *((_QWORD *)a2 + 4);
  v11 = *((_QWORD *)a2 + 5);
  v12 = (_DWORD *)(v10 + 4);
  *((_QWORD *)a2 + 4) = v10 + 4;
  v13 = *((_DWORD *)this + 5);
  if (v10 + 8 > v11)
  {
    CA::Render::Encoder::grow(a2, 4);
    v12 = (_DWORD *)*((_QWORD *)a2 + 4);
  }
  *v12 = v13;
  *((_QWORD *)a2 + 4) += 4;
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 12));
  v14 = *((_QWORD *)this + 13);
  v15 = (_QWORD *)*((_QWORD *)a2 + 4);
  if ((unint64_t)(v15 + 1) > *((_QWORD *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 8);
    v15 = (_QWORD *)*((_QWORD *)a2 + 4);
  }
  *v15 = v14;
  v16 = *((_QWORD *)a2 + 4);
  v17 = *((_QWORD *)a2 + 5);
  v18 = (_DWORD *)(v16 + 8);
  *((_QWORD *)a2 + 4) = v16 + 8;
  v19 = *((_DWORD *)this + 28);
  if (v16 + 12 > v17)
  {
    CA::Render::Encoder::grow(a2, 4);
    v18 = (_DWORD *)*((_QWORD *)a2 + 4);
  }
  *v18 = v19;
  *((_QWORD *)a2 + 4) += 4;
  CA::Render::Encoder::encode_cfobject(a2, *((const void **)this + 15));
  *(_QWORD *)&result = CA::Render::Texture::encode((CGColorSpaceRef *)this, a2).n128_u64[0];
  return result;
}

void CA::Render::PixelBuffer::show(CA::Render::PixelBuffer *this, unsigned int a2, char a3)
{
  unint64_t v5;
  _BOOL4 v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  const char *v20;
  NSObject *v21;
  uint32_t v22;
  uint64_t v23;
  int v24;
  int v25;
  uint8_t buf[4];
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v5 = *((unsigned int *)this + 28);
  v6 = x_log_hook_p();
  if ((a3 & 1) != 0)
  {
    if (v6)
    {
LABEL_15:
      x_log_();
      return;
    }
    v23 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      v24 = *((_DWORD *)this + 4);
      v25 = *((_DWORD *)this + 5);
      *(_DWORD *)buf = 67109376;
      v27 = v24;
      v28 = 1024;
      v29 = v25;
      v20 = "(pixel-buffer [%d %d])";
      v21 = v23;
      v22 = 14;
LABEL_38:
      _os_log_impl(&dword_184457000, v21, OS_LOG_TYPE_DEFAULT, v20, buf, v22);
    }
  }
  else
  {
    if (v6)
    {
      if ((v5 & 0x80000000) != 0)
        __maskrune(v5 >> 24, 0x40000uLL);
      if (BYTE2(v5) > 0x7Fu)
        __maskrune(BYTE2(v5), 0x40000uLL);
      if (BYTE1(v5) > 0x7Fu)
        __maskrune(BYTE1(v5), 0x40000uLL);
      if (v5 > 0x7Fu)
        __maskrune(v5, 0x40000uLL);
      goto LABEL_15;
    }
    v7 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      v8 = v5 >> 24;
      v9 = MEMORY[0x1E0C80978];
      if ((v5 & 0x80000000) != 0)
        v10 = __maskrune(v8, 0x40000uLL);
      else
        v10 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v8 + 60) & 0x40000;
      if (v10)
        v11 = (int)v5 >> 24;
      else
        v11 = 32;
      if (BYTE2(v5) <= 0x7Fu)
        v12 = *(_DWORD *)(v9 + 4 * BYTE2(v5) + 60) & 0x40000;
      else
        v12 = __maskrune(BYTE2(v5), 0x40000uLL);
      if (v12)
        v13 = SBYTE2(v5);
      else
        v13 = 32;
      if (BYTE1(v5) <= 0x7Fu)
        v14 = *(_DWORD *)(v9 + 4 * BYTE1(v5) + 60) & 0x40000;
      else
        v14 = __maskrune(BYTE1(v5), 0x40000uLL);
      if (v14)
        v15 = SBYTE1(v5);
      else
        v15 = 32;
      if (v5 <= 0x7Fu)
        v16 = *(_DWORD *)(v9 + 4 * v5 + 60) & 0x40000;
      else
        v16 = __maskrune(v5, 0x40000uLL);
      v17 = (char)v5;
      v18 = *((_DWORD *)this + 4);
      v19 = *((_DWORD *)this + 5);
      if (!v16)
        v17 = 32;
      *(_DWORD *)buf = 67110400;
      v27 = v11;
      v28 = 1024;
      v29 = v13;
      v30 = 1024;
      v31 = v15;
      v32 = 1024;
      v33 = v17;
      v34 = 1024;
      v35 = v18;
      v36 = 1024;
      v37 = v19;
      v20 = "(pixel-buffer %c%c%c%c [%d %d])";
      v21 = v7;
      v22 = 38;
      goto LABEL_38;
    }
  }
}

uint64_t CA::Render::PixelBuffer::image_format(CA::Render::PixelBuffer *this)
{
  return CA::Render::fourcc_to_format((CA::Render *)*((unsigned int *)this + 28));
}

uint64_t CA::Render::PixelBuffer::implicitly_opaque(CA::Render::PixelBuffer *this)
{
  return CA::Render::fourcc_has_alpha((CA::Render *)*((unsigned int *)this + 28)) ^ 1;
}

uint64_t CA::Render::Texture::copy_tiled_texture(CA::Render::Texture *this)
{
  return 0;
}

uint64_t CA::Render::Texture::get_tiled_texture_size(CA::Render::Texture *this, unsigned int *a2, unsigned int *a3)
{
  return 0;
}

float CA::Render::Texture::opacity_at(CA::Render::Texture *this)
{
  return 1.0;
}

void CA::Render::release_cvpixelbuffer(CA::Render *this, CVPixelBufferRef pixelBuffer, void *a3)
{
  CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
  CVPixelBufferRelease(pixelBuffer);
}

CA::Render::Texture *CA::Render::PixelBuffer::image(CA::Render::PixelBuffer *this)
{
  CA::Render::Texture *result;
  CGColorSpace **v3;
  uint64_t v4;
  const unint64_t *v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  result = (CA::Render::Texture *)*((_QWORD *)this + 16);
  if (!result)
  {
    v3 = (CGColorSpace **)*((_QWORD *)this + 12);
    if (!v3)
      goto LABEL_10;
    v4 = CA::Render::fourcc_to_format((CA::Render *)*((unsigned int *)this + 28));
    if ((v4 & 0x80000000) != 0)
      return 0;
    result = CA::Render::Image::new_image((CA::Render::Image *)v4, *((_DWORD *)this + 4), *((_DWORD *)this + 5), 1u, *((CGColorSpace **)this + 6), v3, (CA::Render::PixelBuffer *)((char *)this + 104), v5);
    if (!result)
    {
LABEL_10:
      result = (CA::Render::Texture *)*((_QWORD *)this + 16);
      if (!result)
        return result;
      goto LABEL_11;
    }
    *((_DWORD *)result + 3) |= *((_DWORD *)this + 3) & 0x1800;
    v6 = (unsigned int *)*((_QWORD *)this + 16);
    *((_QWORD *)this + 16) = result;
    if (v6)
    {
      v7 = v6 + 2;
      do
      {
        v8 = __ldaxr(v7);
        v9 = v8 - 1;
      }
      while (__stlxr(v9, v7));
      if (!v9)
        (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 16))(v6);
      goto LABEL_10;
    }
  }
LABEL_11:
  *((_DWORD *)result + 9) = *((_DWORD *)this + 9);
  return result;
}

CA::Render::Texture *CA::Render::PixelBuffer::decode(CA::Render::PixelBuffer *this, CA::Render::Decoder *a2)
{
  int v3;
  int v4;
  unsigned int v5;
  malloc_zone_t *malloc_zone;
  CA::Render::Texture *v7;
  CA::Render::Texture *v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int *v20;
  unsigned int v21;

  v3 = CA::Render::Decoder::decode_int32(this);
  v4 = CA::Render::Decoder::decode_int32(this);
  v5 = CA::Render::Decoder::decode_int32(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v7 = (CA::Render::Texture *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x90uLL, 0x743898A5uLL);
  v8 = v7;
  if (v7)
  {
    CA::Render::Texture::Texture(v7, v4, v5);
    v9 = *((_DWORD *)v8 + 3) & 0xFFFFFF00 | 0x26;
    ++dword_1ECDC7CC0;
    *(_QWORD *)v8 = off_1E1596528;
    *((_QWORD *)v8 + 12) = 0;
    *((_QWORD *)v8 + 16) = 0;
  }
  else
  {
    v9 = MEMORY[0xC];
  }
  *((_DWORD *)v8 + 3) = v9 | (v3 << 8);
  v10 = CA::Render::Decoder::decode_object(this, 47);
  v11 = (unsigned int *)*((_QWORD *)v8 + 12);
  *((_QWORD *)v8 + 12) = v10;
  if (v11)
  {
    v12 = v11 + 2;
    do
    {
      v13 = __ldaxr(v12);
      v14 = v13 - 1;
    }
    while (__stlxr(v14, v12));
    if (!v14)
      (*(void (**)(unsigned int *))(*(_QWORD *)v11 + 16))(v11);
  }
  *((_QWORD *)v8 + 13) = CA::Render::Decoder::decode_size_t(this);
  *((_DWORD *)v8 + 28) = CA::Render::Decoder::decode_int32(this);
  CFDictionaryGetTypeID();
  *((_QWORD *)v8 + 15) = CA::Render::Decoder::decode_cfobject(this);
  *((_QWORD *)v8 + 17) = 0;
  CA::Render::Texture::decode(v8, this);
  v15 = *((_QWORD *)v8 + 13);
  if (is_mul_ok(v15, v5))
    v16 = v15 * v5;
  else
    v16 = 0;
  v17 = CA::Render::fourcc_to_format((CA::Render *)*((unsigned int *)v8 + 28));
  if ((v17 & 0x80000000) == 0)
  {
    v18 = v15 - (dword_184750480[v17] * v4);
    v16 -= v18 & ~(v18 >> 63);
  }
  if (!v4 || !v5 || (v5 | v4) >> 24 || (v19 = *((_QWORD *)v8 + 12)) == 0 || *(_QWORD *)(v19 + 16) < v16)
  {
    v20 = (unsigned int *)((char *)v8 + 8);
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (v21 == 1)
      (*(void (**)(CA::Render::Texture *))(*(_QWORD *)v8 + 16))(v8);
    return 0;
  }
  return v8;
}

void CA::OGL::`anonymous namespace'::FlipTransition::DOD(CA::OGL::_anonymous_namespace_::FlipTransition *this@<X0>, const CA::Render::Transition *a2@<X1>, const CA::Rect *a3@<X2>, float64x2_t *a4@<X3>, const CA::Rect *a5@<X4>, const CA::Rect *a6@<X5>, uint64_t a7@<X8>)
{
  double *v10;
  const CA::Rect *v11;
  __int128 v12;
  float64x2_t v13[8];
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = 0;
  memset(v13, 0, sizeof(v13));
  if (BYTE4(v14))
    v11 = a5;
  else
    v11 = a6;
  v12 = *((_OWORD *)v11 + 1);
  *(_OWORD *)a7 = *(_OWORD *)v11;
  *(_OWORD *)(a7 + 16) = v12;
  CA::Mat4Impl::mat4_apply_to_rect(v13, (int8x16_t *)a7, v10);
}

__n128 CA::OGL::`anonymous namespace'::FlipTransition::ROI(uint64_t a1, uint64_t a2, __n128 *a3, uint64_t a4, uint64_t a5, __n128 *a6, __n128 *a7)
{
  __n128 result;

  *a6 = *a3;
  a6[1] = a3[1];
  *a7 = *a3;
  result = a3[1];
  a7[1] = result;
  return result;
}

void CA::OGL::`anonymous namespace'::FlipTransition::render(uint64_t a1, uint64_t a2, CA::OGL::Context *a3, float64x2_t *a4, CA::Transform *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12;
  _WORD *v18;
  _OWORD v20[9];
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v30 = 0;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  if (BYTE4(v30))
    v12 = a6;
  else
    v12 = a7;
  if (v12)
  {
    _S0 = v30;
    __asm { FCVT            H0, S0 }
    v18 = (_WORD *)*((_QWORD *)a3 + 2);
    v18[4] = _S0;
    v18[5] = _S0;
    v18[6] = _S0;
    v18[7] = 15360;
    *(_BYTE *)(*((_QWORD *)a3 + 2) + 481) |= 1u;
    v20[0] = v22;
    v20[1] = v23;
    v20[2] = v24;
    v20[3] = v25;
    v20[4] = v26;
    v20[5] = v27;
    v20[6] = v28;
    v20[7] = v29;
    __asm { FMOV            V0.2D, #1.0 }
    v20[8] = _Q0;
    v21 = 16;
    CA::OGL::fill_surface_rect(a3, v12, a5, (uint64_t)v20, *a4, a4[1]);
    *(_BYTE *)(*((_QWORD *)a3 + 2) + 481) &= ~1u;
  }
}

uint64_t CA::OGL::`anonymous namespace'::FlipTransition::source_requirement()
{
  return 3;
}

void CA::OGL::`anonymous namespace'::FlipTransition::set_state(uint64_t a1, uint64_t a2, uint64_t a3, double *a4, float64x2_t *a5)
{
  float v7;
  BOOL v8;
  float v9;
  int v10;
  double v11;
  unsigned int v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  uint64_t v19;
  CA::Render::KeyValueArray **v20;
  CA::Render::KeyValueArray *v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  float64x2_t v26;
  float64x2_t v27;
  float64x2_t v28;
  float64x2_t v29;
  const double *v30;
  float64x2_t v31;
  double *v32;
  const double *v33;
  float64x2_t v34;
  double v35;
  double v36;
  double v37;
  _OWORD v38[5];
  uint64_t v39;
  double v40;
  __int128 v41;
  __int128 v42;
  double v43[17];

  v43[16] = *(double *)MEMORY[0x1E0C80C00];
  v7 = *(float *)(a3 + 48);
  v8 = v7 < 0.5;
  v9 = v7 + v7;
  if (v7 >= 0.5)
  {
    v9 = 2.0 - (float)(v7 + v7);
    v7 = v7 + 1.0;
  }
  *(_BYTE *)(a2 + 132) = v8;
  *(float *)(a2 + 128) = (float)(v9 * -0.75) + 1.0;
  v10 = *(_DWORD *)(a3 + 20);
  if (!v10)
    v10 = 237;
  v11 = v7 * 3.14159265;
  if (v10 == 237 || v10 == 235)
    v11 = -v11;
  v12 = v10 - 235;
  if (v12 >= 2)
    v13 = 1.0;
  else
    v13 = 0.0;
  v35 = 0.0;
  if (v12 >= 2)
    v14 = 0.0;
  else
    v14 = 1.0;
  v15 = *a4;
  v16 = a4[1];
  v17 = a4[2];
  v18 = a4[3];
  v19 = *(_QWORD *)(a3 + 32);
  if (v19)
    v20 = (CA::Render::KeyValueArray **)(v19 + 40);
  else
    v20 = (CA::Render::KeyValueArray **)(a3 + 24);
  v21 = *v20;
  if (CA::Render::KeyValueArray::get_int_key(*v20, (const CA::Render::KeyValueArray *)4, *(unsigned __int8 *)(a1 + 8)))v35 = fabs(sin(v11)) * 0.5 * (v17 * v14 + v18 * v13);
  v37 = v16 + v18 * 0.5;
  v36 = v15 + v17 * 0.5;
  v38[0] = xmmword_18474DF40;
  v38[1] = 0u;
  v38[2] = xmmword_18474DF50;
  memset(&v38[3], 0, 32);
  v39 = 0x3FF0000000000000;
  v41 = 0u;
  v42 = xmmword_18474DF50;
  v40 = -1.0
      / (CA::Render::KeyValueArray::get_float_key(v21, (const CA::Render::KeyValueArray *)0x10E, 3.0)
       * (0.5
        * (v18 + v17)));
  v22 = *a5;
  v23 = a5[1];
  v24 = a5[2];
  v25 = a5[3];
  *(float64x2_t *)a2 = *a5;
  *(float64x2_t *)(a2 + 16) = v23;
  *(float64x2_t *)(a2 + 32) = v24;
  *(float64x2_t *)(a2 + 48) = v25;
  v26 = a5[4];
  v27 = a5[5];
  v28 = a5[6];
  v29 = a5[7];
  *(float64x2_t *)(a2 + 64) = v26;
  *(float64x2_t *)(a2 + 80) = v27;
  *(float64x2_t *)(a2 + 96) = vmlaq_f64(vmlaq_n_f64(vmlaq_n_f64(v28, v22, v36), v24, v37), (float64x2_t)0, v26);
  *(float64x2_t *)(a2 + 112) = vmlaq_f64(vmlaq_n_f64(vmlaq_n_f64(v29, v23, v36), v25, v37), (float64x2_t)0, v27);
  CA::Mat4Impl::mat4_concat((float64x2_t *)a2, (double *)v38, (const double *)a2, v30);
  v31 = vmlsq_lane_f64(vmlaq_f64(vmlaq_f64(*(float64x2_t *)(a2 + 112), (float64x2_t)0, *(float64x2_t *)(a2 + 16)), (float64x2_t)0, *(float64x2_t *)(a2 + 48)), *(float64x2_t *)(a2 + 80), v35, 0);
  *(float64x2_t *)(a2 + 96) = vmlsq_lane_f64(vmlaq_f64(vmlaq_f64(*(float64x2_t *)(a2 + 96), (float64x2_t)0, *(float64x2_t *)a2), (float64x2_t)0, *(float64x2_t *)(a2 + 32)), *(float64x2_t *)(a2 + 64), v35, 0);
  *(float64x2_t *)(a2 + 112) = v31;
  CA::Mat4Impl::mat4_set_rotation((CA::Mat4Impl *)v43, v32, -v11, v13, v14, 0.0);
  CA::Mat4Impl::mat4_concat((float64x2_t *)a2, v43, (const double *)a2, v33);
  v34 = vmlaq_f64(vmlsq_lane_f64(vmlsq_lane_f64(*(float64x2_t *)(a2 + 112), *(float64x2_t *)(a2 + 16), v36, 0), *(float64x2_t *)(a2 + 48), v37, 0), (float64x2_t)0, *(float64x2_t *)(a2 + 80));
  *(float64x2_t *)(a2 + 96) = vmlaq_f64(vmlsq_lane_f64(vmlsq_lane_f64(*(float64x2_t *)(a2 + 96), *(float64x2_t *)a2, v36, 0), *(float64x2_t *)(a2 + 32), v37, 0), (float64x2_t)0, *(float64x2_t *)(a2 + 64));
  *(float64x2_t *)(a2 + 112) = v34;
}

void CA::Render::ImageProvider::~ImageProvider(CA::Render::ImageProvider *this)
{
  malloc_zone_t *malloc_zone;

  CA::Render::ImageProvider::~ImageProvider(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *i;
  _QWORD *v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  _QWORD *v11;
  uint64_t *v12;
  malloc_zone_t *malloc_zone;
  CA::Render::ImageProvider *v14;
  CA::Render::ImageProvider *v15;
  malloc_zone_t *v16;
  unsigned int *v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int v20;

  *(_QWORD *)this = off_1E1597040;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
  v2 = 0;
  v3 = *((_QWORD *)this + 18);
  v4 = 1 << *(_DWORD *)v3;
  do
  {
    for (i = *(_QWORD **)(*(_QWORD *)(v3 + 16) + 8 * v2); i; i = (_QWORD *)*i)
    {
      v6 = (_QWORD *)i[3];
      v7 = (unsigned int *)v6[3];
      if (v7)
      {
        v8 = v7 + 2;
        do
        {
          v9 = __ldaxr(v8);
          v10 = v9 - 1;
        }
        while (__stlxr(v10, v8));
        if (!v10)
          (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 16))(v7);
        v11 = (_QWORD *)v6[1];
        if (v11)
          *v11 = *v6;
        if (*v6)
          v12 = (uint64_t *)(*v6 + 8);
        else
          v12 = &CA::Render::subimage_head;
        *v12 = (uint64_t)v11;
      }
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v6);
    }
    ++v2;
  }
  while (v2 != v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
  x_hash_table_free(*((_QWORD **)this + 18));
  v14 = (CA::Render::ImageProvider *)*((_QWORD *)this + 20);
  if (v14 != (CA::Render::ImageProvider *)((char *)this + 152))
  {
    do
    {
      v15 = (CA::Render::ImageProvider *)*((_QWORD *)v14 + 1);
      v16 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v16, v14);
      v14 = v15;
    }
    while (v15 != (CA::Render::ImageProvider *)((char *)this + 152));
  }
  --dword_1ECDC7C88;
  *(_QWORD *)this = off_1E1596C08;
  v17 = (unsigned int *)*((_QWORD *)this + 15);
  if (v17)
  {
    v18 = v17 + 2;
    do
    {
      v19 = __ldaxr(v18);
      v20 = v19 - 1;
    }
    while (__stlxr(v20, v18));
    if (!v20)
      (*(void (**)(unsigned int *))(*(_QWORD *)v17 + 16))(v17);
  }
  CA::Render::Texture::~Texture((CGColorSpaceRef *)this);
}

void CA::Render::ImageProvider::show(CA::Render::ImageProvider *this, int a2, uint64_t a3)
{
  _BOOL4 v6;
  NSObject *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  CA::Render *v14;
  NSObject *v15;
  uint64_t v16;
  const char *v17;
  NSObject *v18;
  uint32_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  const char *v23;
  NSObject *v24;
  uint32_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint8_t buf[4];
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v6 = x_log_hook_p();
  if ((a3 & 1) == 0)
  {
    if (v6)
    {
      x_log_();
    }
    else
    {
      v7 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        v8 = *((_DWORD *)this + 4);
        v9 = *((_DWORD *)this + 5);
        v10 = *((_DWORD *)this + 24);
        v11 = *((_DWORD *)this + 25);
        v12 = *((_DWORD *)this + 26);
        v13 = *((_DWORD *)this + 27);
        *(_DWORD *)buf = 67110400;
        v30 = v8;
        v31 = 1024;
        v32 = v9;
        v33 = 1024;
        v34 = v10;
        v35 = 1024;
        v36 = v11;
        v37 = 1024;
        v38 = v12;
        v39 = 1024;
        v40 = v13;
        _os_log_impl(&dword_184457000, v7, OS_LOG_TYPE_DEFAULT, "(image-provider [%d %d] [%d %d] [%d %d]", buf, 0x26u);
      }
    }
    if (*((_QWORD *)this + 15))
    {
      v14 = (CA::Render *)(a2 + 1);
      CA::Render::show_newline(v14);
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v15 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_184457000, v15, OS_LOG_TYPE_DEFAULT, "(fillColor ", buf, 2u);
        }
      }
      (*(void (**)(_QWORD, CA::Render *, uint64_t))(**((_QWORD **)this + 15) + 40))(*((_QWORD *)this + 15), v14, a3);
      if (x_log_hook_p())
      {
LABEL_15:
        x_log_();
        goto LABEL_21;
      }
      v16 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        v17 = ")";
        v18 = v16;
        v19 = 2;
LABEL_20:
        _os_log_impl(&dword_184457000, v18, OS_LOG_TYPE_DEFAULT, v17, buf, v19);
      }
    }
    else
    {
      if (!*((_DWORD *)this + 28))
        goto LABEL_21;
      CA::Render::show_newline((CA::Render *)(a2 + 1));
      if (x_log_hook_p())
        goto LABEL_15;
      v20 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        v21 = *((_DWORD *)this + 28);
        *(_DWORD *)buf = 67109120;
        v30 = v21;
        v17 = "(fillColor #%08x ";
        v18 = v20;
        v19 = 8;
        goto LABEL_20;
      }
    }
LABEL_21:
    if (x_log_hook_p())
    {
LABEL_22:
      x_log_();
      return;
    }
    v22 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v23 = ")";
      v24 = v22;
      v25 = 2;
LABEL_25:
      _os_log_impl(&dword_184457000, v24, OS_LOG_TYPE_DEFAULT, v23, buf, v25);
      return;
    }
    return;
  }
  if (v6)
    goto LABEL_22;
  v26 = x_log_category_render;
  if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
  {
    v27 = *((_DWORD *)this + 4);
    v28 = *((_DWORD *)this + 5);
    *(_DWORD *)buf = 67109376;
    v30 = v27;
    v31 = 1024;
    v32 = v28;
    v23 = "<image-provider [%d %d]>";
    v24 = v26;
    v25 = 14;
    goto LABEL_25;
  }
}

uint64_t CA::Render::ImageProvider::implicitly_opaque(CA::Render::ImageProvider *this)
{
  return *((unsigned __int8 *)this + 128);
}

uint64_t CA::Render::ImageProvider::copy_subtexture(CA::Render::ImageProvider *this, __int32 a2, __int32 a3, __int32 a4, __int32 a5, int a6, char a7, int a8, double a9, float *a10, unsigned int *a11)
{
  int v12;
  uint64_t v16;
  int32x2_t *v17;
  uint64_t v18;
  unsigned int v19;
  BOOL v20;
  int32x2_t v21;
  unsigned int *v22;
  unsigned int v23;
  float v24;
  int32x2_t *v25;
  uint64_t *v26;
  int32x2_t **v27;
  int32x2_t *v29;
  uint64_t *v30;
  unsigned int *v31;
  unsigned int *v32;
  unsigned int v33;
  BOOL v34;
  int32x2_t *v35;
  uint64_t *v36;
  unsigned int *v37;
  unsigned int v38;
  malloc_zone_t *malloc_zone;
  unsigned int v40;
  __int32 v41[3];
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if ((a2 & 0x80000000) == 0 && *((_DWORD *)this + 26) > a2)
  {
    v12 = *((_DWORD *)this + 34);
    if (v12 < 1 || v12 >= a6)
    {
      *((_DWORD *)this + 50) = a8;
      *((double *)this + 24) = a9;
      v41[0] = a2;
      v41[1] = a3;
      v41[2] = a4;
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
      v16 = x_hash_table_lookup(*((_QWORD *)this + 18), (uint64_t)v41, 0);
      v17 = (int32x2_t *)v16;
      if (!v16)
      {
LABEL_58:
        v21 = 0;
LABEL_59:
        CA::Render::ImageProvider::add_needed((int32x2_t *)this, v41, a5, v17);
        os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
        CA::Render::ImageProvider::signal_client(this);
        return (uint64_t)v21;
      }
      v18 = *(_QWORD *)(v16 + 24);
      v19 = v17[6].u32[1];
      if (v18)
        v20 = (v19 & 0x20000) == 0;
      else
        v20 = 1;
      if (!v20)
      {
        if (!(*(unsigned int (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 192))(v18, 0))
        {
          v29 = (int32x2_t *)v17[1];
          if (v29)
            *v29 = *v17;
          if (*v17)
            v30 = (uint64_t *)(*(_QWORD *)v17 + 8);
          else
            v30 = &CA::Render::subimage_head;
          *v30 = (uint64_t)v29;
          v31 = (unsigned int *)v17[3];
          v32 = v31 + 2;
          do
          {
            v33 = __ldaxr(v32);
            v34 = --v33 == 0;
          }
          while (__stlxr(v33, v32));
          goto LABEL_54;
        }
        v19 = v17[6].i32[1] & 0xFFFDFFFF;
        v17[6].i32[1] = v19;
      }
      if ((v19 & 0x40000) == 0 || v17[8].i32[0] == *((_DWORD *)this + 28))
      {
        v17[10] = *(int32x2_t *)((char *)this + 192);
        if ((a7 & 1) != 0)
          v17[9] = (int32x2_t)0xD4B249AD2594C37DLL;
        v21 = v17[3];
        if (v21)
        {
          v22 = (unsigned int *)(*(_QWORD *)&v21 + 8);
          do
            v23 = __ldaxr(v22);
          while (__stlxr(v23 + 1, v22));
          if (!v23)
          {
            v21 = 0;
            do
              v40 = __ldaxr(v22);
            while (__stlxr(v40 - 1, v22));
          }
          v24 = 1.0;
          if ((v17[6].i8[4] & 4) == 0)
          {
            v24 = (*((double *)this + 24) - *(double *)&v17[9]) / *((float *)this + 33);
            if (v24 > 1.0)
              v24 = 1.0;
            if (v24 < 0.0)
              v24 = 0.0;
          }
          *a10 = v24;
          v25 = (int32x2_t *)v17[1];
          if (v25)
            *v25 = *v17;
          if (*v17)
            v26 = (uint64_t *)(*(_QWORD *)v17 + 8);
          else
            v26 = &CA::Render::subimage_head;
          *v26 = (uint64_t)v25;
          *v17 = 0;
          v27 = (int32x2_t **)CA::Render::subimage_head;
          v17[1] = (int32x2_t)CA::Render::subimage_head;
          if (v27)
            *v27 = v17;
          CA::Render::subimage_head = (uint64_t)v17;
        }
        *a11 = v17[7].u32[0];
        goto LABEL_59;
      }
      v35 = (int32x2_t *)v17[1];
      if (v35)
        *v35 = *v17;
      if (*v17)
        v36 = (uint64_t *)(*(_QWORD *)v17 + 8);
      else
        v36 = &CA::Render::subimage_head;
      *v36 = (uint64_t)v35;
      v31 = (unsigned int *)v17[3];
      if (!v31)
        goto LABEL_57;
      v37 = v31 + 2;
      do
      {
        v38 = __ldaxr(v37);
        v34 = --v38 == 0;
      }
      while (__stlxr(v38, v37));
LABEL_54:
      if (v34)
        (*(void (**)(unsigned int *))(*(_QWORD *)v31 + 16))(v31);
LABEL_57:
      x_hash_table_remove_ptr(*((_QWORD *)this + 18), (uint64_t)&v17[5]);
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v17);
      v17 = 0;
      goto LABEL_58;
    }
  }
  return 0;
}

CA::Render::Texture *CA::Render::ImageProvider::generate_subtexture(CA::Render::ImageProvider *this, int a2, int a3, int a4, int a5, unsigned int a6, double a7, unsigned int *a8)
{
  uint64_t v14;
  CA::Render::Texture *v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  BOOL v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  unsigned int **v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int *v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  unsigned int v46;
  unsigned int v47;
  CA::Render::Shmem *v48;
  _DWORD *v49;
  _DWORD *v50;
  unint64_t v51;
  int v52;
  CA::Render::Shmem *v53;
  int v54;
  uint64_t v55;
  char v56;
  uint64_t v57;
  int v58;
  char v59;
  char v60;
  char v61;
  uint64_t v62;
  unsigned int v63;
  unint64_t v64;
  char *v65;
  unint64_t v66;
  int v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  unint64_t v74;
  unsigned int v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint32x4_t v81;
  unsigned __int128 v82;
  unsigned int *v83;
  unsigned int v84;
  unsigned int v85;
  int v86;
  int v87;
  int v88;
  uint64_t v89;
  char v90;
  uint64_t v91;
  char v92;
  char v93;
  char v94;
  unsigned int *v95;
  unsigned int *v96;
  unsigned int v97;
  unsigned int v98;
  unsigned int v100;
  int v101;
  unsigned int *v102;
  int v103;
  int v104;
  int v106;
  char v107;
  int v108;
  unint64_t v109;
  char v110;
  CA::Render::Shmem *v111;
  unsigned int v112;
  int v113;
  char v115;
  uint64_t v116;
  _OWORD v117[2];
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 0;
  *(_QWORD *)&v117[0] = __PAIR64__(a3, a2);
  DWORD2(v117[0]) = a4;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
  v14 = x_hash_table_lookup(*((_QWORD *)this + 18), (uint64_t)v117, 0);
  if (v14 && (*(_DWORD *)(v14 + 52) & 0x20002) == 2)
  {
    v15 = *(CA::Render::Texture **)(v14 + 24);
    if (v15)
    {
      v16 = (unsigned int *)((char *)v15 + 8);
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 + 1, v16));
      if (!v17)
      {
        v15 = 0;
        do
          v100 = __ldaxr(v16);
        while (__stlxr(v100 - 1, v16));
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    return v15;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
  v112 = a2 - 1;
  v102 = a8;
  v101 = a2;
  if (a2 >= 1 && *((_DWORD *)this + 26) >= a2)
  {
    v20 = *((_DWORD *)this + 27);
    v21 = __OFSUB__(v112, v20);
    v22 = v112 - v20;
    v23 = *((_DWORD *)this + 4);
    v24 = *((_DWORD *)this + 5);
    v25 = v23 >> v22;
    v26 = v23 << -(char)v22;
    if (v22 < 0 != v21)
      v18 = v26;
    else
      v18 = v25;
    v27 = v24 << -(char)v22;
    v28 = v24 >> v22;
    if (v22 >= 0)
      v19 = v28;
    else
      v19 = v27;
  }
  else
  {
    v18 = 0;
    v19 = 0;
  }
  v29 = 0;
  v30 = 0;
  v103 = a3;
  v104 = a4;
  v31 = 2 * a3;
  v106 = 2 * a4;
  v107 = 0;
  memset(v117, 0, sizeof(v117));
  v110 = 0;
  v109 = -1;
  do
  {
    v32 = 0;
    v33 = 0;
    v108 = v30;
    v34 = v30 + v106;
    do
    {
      v35 = (unsigned int **)&v117[v29] + v32;
      *v35 = 0;
      if (*((_DWORD *)this + 24) * (v33 + v31) < v18 && *((_DWORD *)this + 25) * v34 < v19)
      {
        v116 = 0;
        v36 = (unsigned int *)(*(uint64_t (**)(CA::Render::ImageProvider *, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, double, char *, uint64_t *))(*(_QWORD *)this + 256))(this, v112, v31 | v32, v106 | v29, 0xFFFFFFFFLL, 1, 0, a6, a7, (char *)&v116 + 4, &v116);
        if (!v36)
          goto LABEL_35;
        if (*((_BYTE *)v36 + 12) != 23 || (v37 = *((unsigned __int8 *)v36 + 152), (v37 & 0xFFFFFFFD) != 1))
        {
          v40 = v36 + 2;
          do
            v41 = __ldaxr(v40);
          while (__stlxr(v41 - 1, v40));
          if (v41 == 1)
            (*(void (**)(unsigned int *))(*(_QWORD *)v36 + 16))(v36);
LABEL_35:
          v110 = 1;
          goto LABEL_36;
        }
        if (v109 >= v37)
          v38 = *((unsigned __int8 *)v36 + 152);
        else
          v38 = v109;
        v39 = HIDWORD(v109);
        if (HIDWORD(v109) >= v116)
          v39 = v116;
        v109 = __PAIR64__(v39, v38);
        *v35 = v36;
        v107 = 1;
      }
LABEL_36:
      ++v33;
      v32 = 1;
    }
    while (v33 != 2);
    v30 = v108 + 1;
    v29 = 1;
  }
  while (v108 != 1);
  if ((v107 & 1) == 0)
    return 0;
  v42 = *((_DWORD *)this + 24);
  v43 = *((_DWORD *)this + 25);
  v45 = v103;
  v44 = v104;
  if (v42 * v103 + v42 <= v18 >> 1)
    v46 = *((_DWORD *)this + 24);
  else
    v46 = (v18 >> 1) - v42 * v103;
  if (v43 * v104 + v43 <= v19 >> 1)
    v47 = *((_DWORD *)this + 25);
  else
    v47 = (v19 >> 1) - v43 * v104;
  if ((v110 & 1) == 0)
  {
    v53 = (CA::Render::Shmem *)CA::Render::Shmem::new_bitmap((CA::Render::Shmem *)v109, v46, v47, 0, 0, 1u);
    if (v53)
    {
      v111 = v53;
      v50 = (_DWORD *)*((_QWORD *)v53 + 3);
      goto LABEL_56;
    }
LABEL_95:
    v15 = 0;
    v88 = 6;
    v86 = v101;
    v87 = HIDWORD(v109);
    goto LABEL_96;
  }
  if (*((_QWORD *)this + 15))
    goto LABEL_95;
  v48 = *((_BYTE *)this + 112) == 0xFF ? (CA::Render::Shmem *)v109 : (CA::Render::Shmem *)1;
  v49 = CA::Render::Shmem::new_bitmap(v48, v46, v47, 0, 0, 1u);
  if (!v49)
    goto LABEL_95;
  v50 = (_DWORD *)*((_QWORD *)v49 + 3);
  v111 = (CA::Render::Shmem *)v49;
  if (*((_DWORD *)this + 28))
  {
    HIDWORD(v51) = *((_DWORD *)this + 28);
    LODWORD(v51) = HIDWORD(v51);
    CA::Render::ShmemBitmap::fill_pixels((uint64_t)v50, (v51 >> 8), 0);
    v52 = 262150;
    goto LABEL_57;
  }
LABEL_56:
  v52 = 6;
LABEL_57:
  v113 = v52;
  v54 = 0;
  v55 = 0;
  v56 = 1;
  while (2)
  {
    v57 = 0;
    v115 = v56;
    v58 = v54 & a5;
    v59 = v54 | a5;
    v60 = 1;
    while (2)
    {
      v61 = v60;
      v62 = *((_QWORD *)&v117[v55] + v57);
      if (v62)
      {
        v63 = v50[4] <= 1u ? 1 : v50[4];
        v64 = CA::Render::format_rowbytes((CA::Render *)v50[3], v63);
        v65 = (char *)v50 + (int)v50[2];
        if (v58)
        {
          v66 = (unint64_t)*((unsigned int *)this + 25) >> 1;
          v65 += v64 * v66;
          v67 = v47 - v66;
        }
        else if ((v59 & 1) != 0)
        {
          v67 = v47;
        }
        else
        {
          v68 = *((_DWORD *)this + 25);
          v67 = v47;
          if (v47 > v68 >> 1)
          {
            v67 = v68 >> 1;
            v65 += v64 * (v47 - (v68 >> 1));
          }
        }
        if ((v61 & 1) != 0)
        {
          v69 = v46;
        }
        else
        {
          v70 = *((_DWORD *)this + 24);
          v65 += (2 * v70) & 0xFFFFFFFC;
          v69 = v46 - (v70 >> 1);
        }
        if ((int)v69 >= 1 && v67 >= 1)
        {
          v71 = *(_QWORD *)(v62 + 160);
          v72 = *(_QWORD *)(v62 + 96);
          v74 = *(unsigned int *)(v62 + 16);
          v73 = *(_DWORD *)(v62 + 20);
          v75 = v74 >> 1;
          if (v69 < v74 >> 1)
            v75 = v69;
          if (*(_BYTE *)(v62 + 152) == 3)
            v76 = -16777216;
          else
            v76 = 0;
          if (v67 < v73 >> 1)
          {
LABEL_82:
            v77 = 2 * v71;
            v78 = v72 + v71;
            v79 = v74 >> 1;
            if (v79 < v69)
              v69 = v79;
            do
            {
              if (v75)
              {
                v80 = 0;
                do
                {
                  v81.i64[0] = *(_QWORD *)(v72 + 8 * v80);
                  v81.i64[1] = *(_QWORD *)(v78 + 8 * v80);
                  v82 = *(_OWORD *)&vshrq_n_u32(v81, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL);
                  v81.i16[0] = v81.u8[0];
                  v81.i16[1] = BYTE2(*(_QWORD *)(v72 + 8 * v80));
                  v81.i16[2] = BYTE4(*(_QWORD *)(v72 + 8 * v80));
                  v81.i16[3] = BYTE6(*(_QWORD *)(v72 + 8 * v80));
                  v81.i16[4] = v81.u8[8];
                  v81.i16[5] = BYTE2(*(_QWORD *)(v78 + 8 * v80));
                  v81.i16[6] = BYTE4(*(_QWORD *)(v78 + 8 * v80));
                  v81.i16[7] = BYTE6(*(_QWORD *)(v78 + 8 * v80));
                  *(_DWORD *)&v65[4 * v80++] = (vaddvq_s32((int32x4_t)v81) >> 2) & 0xFF00FF | v76 | (vaddvq_s32((int32x4_t)v82) << 6) & 0xFF00FF00;
                }
                while (v69 != (_DWORD)v80);
              }
              v65 += v64;
              v72 += v77;
              v78 += v77;
              --v67;
            }
            while (v67);
          }
          else if (v73 >= 2)
          {
            v67 = v73 >> 1;
            goto LABEL_82;
          }
        }
      }
      v60 = 0;
      v57 = 1;
      if ((v61 & 1) != 0)
        continue;
      break;
    }
    v56 = 0;
    v54 = 1;
    v55 = 1;
    if ((v115 & 1) != 0)
      continue;
    break;
  }
  v15 = CA::Render::Shmem::copy_image(v111, 0);
  v83 = (unsigned int *)((char *)v111 + 8);
  do
  {
    v84 = __ldaxr(v83);
    v85 = v84 - 1;
  }
  while (__stlxr(v85, v83));
  v45 = v103;
  v44 = v104;
  v86 = v101;
  v87 = HIDWORD(v109);
  if (!v85)
    (*(void (**)(CA::Render::Shmem *))(*(_QWORD *)v111 + 16))(v111);
  v88 = v113;
LABEL_96:
  CA::Render::ImageProvider::set_subimage(this, v86, v45, v44, v15, v88, v87);
  v89 = 0;
  v90 = 1;
  do
  {
    v91 = 0;
    v92 = v90;
    v93 = 1;
    do
    {
      v94 = v93;
      v95 = (unsigned int *)*((_QWORD *)&v117[v89] + v91);
      if (v95)
      {
        v96 = v95 + 2;
        do
        {
          v97 = __ldaxr(v96);
          v98 = v97 - 1;
        }
        while (__stlxr(v98, v96));
        if (!v98)
          (*(void (**)(unsigned int *))(*(_QWORD *)v95 + 16))(v95);
      }
      v93 = 0;
      v91 = 1;
    }
    while ((v94 & 1) != 0);
    v90 = 0;
    v89 = 1;
  }
  while ((v92 & 1) != 0);
  *v102 = v87;
  return v15;
}

void CA::Render::ImageProvider::prefetch_subtexture(CA::Render::ImageProvider *this, __int32 a2, __int32 a3, __int32 a4, __int32 a5, double a6)
{
  uint64_t v8;
  double v9;
  _QWORD *v10;
  uint64_t *v11;
  uint64_t *v12;
  __int32 v13[3];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if ((a2 & 0x80000000) == 0 && *((_DWORD *)this + 26) > a2)
  {
    v13[0] = a2;
    v13[1] = a3;
    v13[2] = a4;
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    v8 = x_hash_table_lookup(*((_QWORD *)this + 18), (uint64_t)v13, 0);
    if (v8)
    {
      v9 = *(double *)(v8 + 80);
      if (v9 <= *((double *)this + 24))
        v9 = *((double *)this + 24);
      *(double *)(v8 + 80) = v9;
      if (*(_QWORD *)(v8 + 24))
      {
        v10 = *(_QWORD **)(v8 + 8);
        if (v10)
          *v10 = *(_QWORD *)v8;
        if (*(_QWORD *)v8)
          v11 = (uint64_t *)(*(_QWORD *)v8 + 8);
        else
          v11 = &CA::Render::subimage_head;
        *v11 = (uint64_t)v10;
        *(_QWORD *)v8 = 0;
        v12 = (uint64_t *)CA::Render::subimage_head;
        *(_QWORD *)(v8 + 8) = CA::Render::subimage_head;
        if (v12)
          *v12 = v8;
        CA::Render::subimage_head = v8;
      }
    }
    CA::Render::ImageProvider::add_needed((int32x2_t *)this, v13, a5, (int32x2_t *)v8);
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    CA::Render::ImageProvider::signal_client(this);
  }
}

uint64_t CA::Render::ImageProvider::prefetch_border(CA::Render::ImageProvider *this)
{
  return *((unsigned int *)this + 35);
}

int32x2_t *CA::Render::ImageProvider::add_needed(int32x2_t *result, __int32 *a2, __int32 a3, int32x2_t *a4)
{
  int32x2_t *v7;
  __int32 v8;
  __int32 v9;
  __int32 v10;
  BOOL v11;
  int v12;
  unsigned __int32 v13;
  unsigned int v14;
  unsigned int v15;
  __int32 v16;
  unsigned __int32 v17;
  unsigned int v18;
  int32x2_t *v19;
  malloc_zone_t *malloc_zone;
  __int32 v21;
  int32x2_t v22;
  __int32 v23;
  int32x2_t *v24;
  __int32 v25;
  __int32 v26;
  unsigned int v27;
  int32x2_t v28;
  int32x2_t *v29;
  int32x2_t v30;

  if ((a3 & 0x80000000) == 0)
  {
    v7 = result;
    if (!a4 || (a4[6].i32[1] & 0x10002) != 0)
    {
      v8 = *a2;
      if ((*a2 & 0x80000000) == 0 && result[13].i32[0] > v8)
      {
        v9 = a2[1];
        v10 = result[13].i32[1];
        v11 = __OFSUB__(v8, v10);
        v12 = v8 - v10;
        v13 = result[2].u32[0];
        v14 = v13 >> v12;
        v15 = v13 << -(char)v12;
        if (v12 < 0 == v11)
          v15 = v14;
        if (result[12].i32[0] * v9 < v15)
        {
          v16 = a2[2];
          v17 = result[2].u32[1];
          v18 = v12 < 0 ? v17 << -(char)v12 : v17 >> v12;
          if (result[12].i32[1] * v16 < v18)
          {
            v19 = result + 19;
            for (result = (int32x2_t *)result[20]; ; result = (int32x2_t *)result[1])
            {
              if (result == v19)
              {
                malloc_zone = (malloc_zone_t *)get_malloc_zone();
                result = (int32x2_t *)malloc_type_zone_malloc(malloc_zone, 0x30uLL, 0x8BB15036uLL);
                *result = (int32x2_t)result;
                result[1] = (int32x2_t)result;
                v21 = a2[2];
                result[2] = *(int32x2_t *)a2;
                result[3].i32[0] = v21;
                goto LABEL_20;
              }
              if (result[2].i32[0] == v8 && result[2].i32[1] == v9 && result[3].i32[0] == v16)
                break;
            }
            v30 = *result;
            v29 = (int32x2_t *)result[1];
            *(_QWORD *)(*(_QWORD *)&v30 + 8) = v29;
            *v29 = v30;
            *result = (int32x2_t)result;
            result[1] = (int32x2_t)result;
LABEL_20:
            result[3].i32[1] = a3;
            if (a4)
              v22 = a4[7];
            else
              v22 = 0;
            result[4] = vrev64_s32(v22);
            v23 = v7[25].i32[0];
            result[5].i32[0] = v23;
            v24 = (int32x2_t *)v7[20];
            if (v24 != v19)
            {
              v25 = result[2].i32[0];
              while (1)
              {
                v26 = v24[2].i32[0];
                if (v26 < v25)
                  break;
                if (v26 <= v25)
                {
                  v27 = v24[4].u32[1];
                  if (v27 > v22.i32[0] || v27 >= v22.i32[0] && v24[3].i32[1] >= a3)
                    break;
                }
                v24 = (int32x2_t *)v24[1];
                if (v24 == v19)
                  goto LABEL_33;
              }
              v19 = v24;
            }
LABEL_33:
            v28 = *v19;
            *v19 = (int32x2_t)result;
            *result = v28;
            result[1] = (int32x2_t)v19;
            *(_QWORD *)(*(_QWORD *)&v28 + 8) = result;
            v7[25].i32[1] = v23;
          }
        }
      }
    }
  }
  return result;
}

void CA::Render::ImageProvider::signal_client(CA::Render::ImageProvider *this)
{
  uint64_t v2;
  mach_port_t v3;
  int v4;
  uint64_t v5;
  mach_msg_return_t v6;
  mach_msg_header_t msg;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
  if (*((_DWORD *)this + 52) == *((_DWORD *)this + 51) || (v2 = *((_QWORD *)this + 21)) == 0)
    v3 = 0;
  else
    v3 = *(_DWORD *)(v2 + 256);
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
  v4 = *((_DWORD *)this + 51);
  if (*((_DWORD *)this + 52) != v4)
  {
    v5 = *((_QWORD *)this + 22);
    if (v3)
    {
      v8 = *MEMORY[0x1E0C804E8];
      v9 = v5;
      v10 = v4;
      *(_QWORD *)&msg.msgh_bits = 19;
      msg.msgh_voucher_port = 0;
      msg.msgh_id = 40408;
      msg.msgh_remote_port = v3;
      msg.msgh_local_port = 0;
      if (MEMORY[0x1E0C85B60])
        voucher_mach_msg_set(&msg);
      v6 = mach_msg(&msg, 17, 0x2Cu, 0, 0, 0, 0);
      if ((v6 - 268435459) <= 1)
      {
        if ((msg.msgh_bits & 0x1F00) == 0x1100)
          mach_port_deallocate(*MEMORY[0x1E0C83DA0], msg.msgh_local_port);
        mach_msg_destroy(&msg);
        return;
      }
      if (v6)
        return;
    }
    else
    {
      CAImageProviderSignal(v5, v4);
    }
    *((_DWORD *)this + 52) = *((_DWORD *)this + 51);
  }
}

void CA::Render::ImageProvider::set_subimage(CA::Render::ImageProvider *this, int a2, int a3, int a4, CA::Render::Texture *a5, int a6, int a7)
{
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  malloc_zone_t *malloc_zone;
  uint64_t v15;
  unsigned int *v16;
  unsigned int *v17;
  unsigned int v18;
  CA::Render::Texture *v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  double v24;
  float v25;
  double v26;
  _QWORD *v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t v32;
  malloc_zone_t *v33;
  unsigned int *v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  _DWORD v38[5];

  *(_QWORD *)&v38[3] = *MEMORY[0x1E0C80C00];
  if (a5)
  {
    v12 = *((unsigned int *)a5 + 4);
    v11 = *((unsigned int *)a5 + 5);
    if (a2 < 0)
      return;
  }
  else
  {
    v12 = 0;
    v11 = 0;
    if (a2 < 0)
      return;
  }
  if (*((_DWORD *)this + 26) > a2 && v12 <= *((unsigned int *)this + 24) && v11 <= *((unsigned int *)this + 25))
  {
    v38[0] = a2;
    v38[1] = a3;
    v38[2] = a4;
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    v13 = x_hash_table_lookup(*((_QWORD *)this + 18), (uint64_t)v38, 0);
    if (!v13)
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      v13 = (uint64_t)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x58uLL, 0x743898A5uLL);
      *(_DWORD *)(v13 + 48) = v38[2];
      *(_QWORD *)(v13 + 40) = *(_QWORD *)v38;
      *(_QWORD *)(v13 + 16) = this;
      v15 = mach_absolute_time();
      *(double *)(v13 + 80) = CATimeWithHostTime(v15);
      hash_table_modify(*((int **)this + 18), v13 + 40, v13, 0);
    }
    v16 = *(unsigned int **)(v13 + 24);
    if (a5)
    {
      v17 = (unsigned int *)((char *)a5 + 8);
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 + 1, v17));
      v19 = a5;
      if (!v18)
      {
        v19 = 0;
        do
          v37 = __ldaxr(v17);
        while (__stlxr(v37 - 1, v17));
      }
      *(_QWORD *)(v13 + 24) = v19;
      v20 = (*(uint64_t (**)(CA::Render::Texture *))(*(_QWORD *)a5 + 168))(a5);
    }
    else
    {
      v20 = 0;
      *(_QWORD *)(v13 + 24) = 0;
    }
    *(_QWORD *)(v13 + 32) = v20;
    *(_DWORD *)(v13 + 52) = a6;
    v21 = *(_DWORD *)(v13 + 60);
    if (a7)
    {
      *(_DWORD *)(v13 + 56) = a7;
      if (v21 != a7)
        *(_DWORD *)(v13 + 52) = a6 | 0x10000;
      if ((a6 & 0x40000) == 0)
        goto LABEL_20;
    }
    else
    {
      *(_DWORD *)(v13 + 56) = v21;
      if ((a6 & 0x40000) == 0)
      {
LABEL_20:
        v22 = 0;
        goto LABEL_23;
      }
    }
    v22 = *((_DWORD *)this + 28);
LABEL_23:
    *(_DWORD *)(v13 + 64) = v22;
    if ((a6 & 4) != 0 || v16)
    {
      *(_QWORD *)(v13 + 72) = 0xD4B249AD2594C37DLL;
      if (v16)
      {
        v27 = *(_QWORD **)(v13 + 8);
        if (v27)
          *v27 = *(_QWORD *)v13;
        if (*(_QWORD *)v13)
          v28 = (uint64_t *)(*(_QWORD *)v13 + 8);
        else
          v28 = &CA::Render::subimage_head;
        *v28 = (uint64_t)v27;
      }
    }
    else
    {
      v23 = mach_absolute_time();
      v24 = CATimeWithHostTime(v23);
      *(double *)(v13 + 72) = v24;
      v25 = *((float *)this + 33);
      if (v25 > 0.0)
      {
        v26 = v24 + v25;
        if (*((double *)this + 23) > v26)
          v26 = *((double *)this + 23);
        *((double *)this + 23) = v26;
      }
    }
    if (a5)
    {
      *(_QWORD *)v13 = 0;
      v29 = (uint64_t *)CA::Render::subimage_head;
      *(_QWORD *)(v13 + 8) = CA::Render::subimage_head;
      if (v29)
        *v29 = v13;
      CA::Render::subimage_head = v13;
    }
    if ((a6 & 2) == 0)
    {
      v30 = (uint64_t *)*((_QWORD *)this + 20);
      while (v30 != (uint64_t *)((char *)this + 152))
      {
        v31 = v30;
        v30 = (uint64_t *)v30[1];
        if ((*((_DWORD *)this + 50) - *((_DWORD *)v31 + 10)) > 4
          || (*(_DWORD *)(v13 + 52) & 0x10002) == 0
          && *((_DWORD *)v31 + 4) == v38[0]
          && *(uint64_t *)((char *)v31 + 20) == *(_QWORD *)&v38[1])
        {
          v32 = *v31;
          *(_QWORD *)(v32 + 8) = v30;
          *v30 = v32;
          *v31 = (uint64_t)v31;
          v31[1] = (uint64_t)v31;
          v33 = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(v33, v31);
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    if (v16)
    {
      v34 = v16 + 2;
      do
      {
        v35 = __ldaxr(v34);
        v36 = v35 - 1;
      }
      while (__stlxr(v36, v34));
      if (!v36)
        (*(void (**)(unsigned int *))(*(_QWORD *)v16 + 16))(v16);
    }
  }
}

uint64_t CA::Render::Texture::implicitly_opaque(CA::Render::Texture *this)
{
  return 0;
}

uint64_t CA::Render::TiledTexture::generate_subtexture(CA::Render::TiledTexture *this, int a2, unsigned int a3, unsigned int a4, BOOL a5, unsigned int a6, double a7, unsigned int *a8)
{
  return 0;
}

uint64_t CA::Render::TiledTexture::prefetch_border(CA::Render::TiledTexture *this)
{
  return 0;
}

unint64_t CA::Render::key_hash(_DWORD *a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v1 = ((a1[1] << 10) ^ (*a1 << 20)) ^ a1[2];
  v2 = (~(v1 << 32) + v1) ^ ((unint64_t)(~(v1 << 32) + v1) >> 22);
  v3 = 9 * ((v2 + ~(v2 << 13)) ^ ((v2 + ~(v2 << 13)) >> 8));
  v4 = (v3 ^ (v3 >> 15)) + ~((v3 ^ (v3 >> 15)) << 27);
  return v4 ^ (v4 >> 31);
}

BOOL CA::Render::key_compare(_DWORD *a1, _DWORD *a2)
{
  return *a1 != *a2 || a1[1] != a2[1] || a1[2] != a2[2];
}

void CA::Render::ImageProvider::create(CA::Render::ImageProvider *this, CA::Render::Context *a2, unsigned int a3, unsigned int a4, unsigned int a5, int a6, int a7, int a8, float a9, int a10, char a11, BOOL a12, int a13, unsigned int a14, CA::Render::Pattern *a15)
{
  unsigned int v23;
  int v24;
  BOOL v25;
  int v26;
  malloc_zone_t *malloc_zone;
  CA::Render::Texture *v28;
  CA::Render::Texture *v29;
  CA::Render::Texture *v30;
  _QWORD *v31;

  if (a6 && a7 && ((a10 | a8) & 0x80000000) == 0)
  {
    if (a4 >= a5)
      v23 = a5;
    else
      v23 = a4;
    v24 = 1;
    if (v23 >= 2)
    {
      do
      {
        ++v24;
        v25 = v23 > 3;
        v23 >>= 1;
      }
      while (v25);
    }
    v26 = v24 + a10;
    if (!__OFADD__(v24, a10))
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      v28 = (CA::Render::Texture *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xD8uLL, 0x743898A5uLL);
      if (v28)
      {
        v29 = v28;
        if (v26 >= a8)
          v26 = a8;
        v30 = CA::Render::Texture::Texture(v28, a4, a5);
        *((_DWORD *)v30 + 24) = a6;
        *((_DWORD *)v30 + 25) = a7;
        *((_DWORD *)v30 + 26) = v26;
        *((_DWORD *)v30 + 27) = a10;
        *((_DWORD *)v30 + 28) = 0;
        *((_QWORD *)v30 + 15) = 0;
        *((_BYTE *)v30 + 12) = 24;
        ++dword_1ECDC7C88;
        *(_QWORD *)v30 = off_1E1597040;
        *((_BYTE *)v30 + 128) = a11;
        *((float *)v30 + 33) = a9;
        *((_DWORD *)v30 + 34) = 0;
        *((_DWORD *)v30 + 35) = a13;
        v31 = x_hash_table_new_((unint64_t (*)(uint64_t))CA::Render::key_hash, (BOOL (*)(uint64_t, uint64_t))CA::Render::key_compare, 0, 0, 0, 0);
        *((_QWORD *)v29 + 23) = 0;
        *((_QWORD *)v29 + 24) = 0;
        *((_QWORD *)v29 + 25) = 0;
        *((_QWORD *)v29 + 26) = 0x100000000;
        *((_QWORD *)v29 + 18) = v31;
        *((_QWORD *)v29 + 19) = (char *)v29 + 152;
        *((_QWORD *)v29 + 20) = (char *)v29 + 152;
        if (*((_BYTE *)v29 + 128))
          *((_DWORD *)v29 + 3) |= 0x1000u;
        *((_QWORD *)v29 + 21) = this;
        *((_QWORD *)v29 + 22) = a2;
        CA::Render::TiledTexture::set_fill_color(v29, a14, (Pattern *)a15);
        CA::Render::Context::set_object(this, (unint64_t)a2, a3, v29);
      }
    }
  }
}

void CA::Render::ImageProvider::invalidate(CA::Render::ImageProvider *this, int a2, int a3, int a4, int a5, int a6, char a7)
{
  unsigned int v7;
  unsigned int v8;
  signed int v9;
  signed int v10;
  int v11;
  int v12;
  int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  BOOL v32;
  int v33;
  int v34;
  BOOL v35;
  int v36;
  int v37;
  int v38;
  BOOL v39;
  BOOL v40;
  _QWORD *v41;
  uint64_t *v42;
  _QWORD *v43;
  unsigned int *v44;
  unsigned int *v45;
  unsigned int v46;
  unsigned int v47;

  v7 = a2 & ~(a2 >> 31);
  v8 = a3 & ~(a3 >> 31);
  v9 = *((_DWORD *)this + 4);
  v10 = *((_DWORD *)this + 5);
  if ((int)((a2 & (a2 >> 31)) + a4 + v7) <= v9)
    v11 = (a2 & (a2 >> 31)) + a4;
  else
    v11 = v9 - v7;
  if ((int)((a3 & (a3 >> 31)) + a5 + v8) <= v10)
    v12 = (a3 & (a3 >> 31)) + a5;
  else
    v12 = v10 - v8;
  if (v11 >= 1 && v12 >= 1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    v17 = *((_DWORD *)this + 53);
    if (a6 == -1 && (a7 & 1) == 0)
      *((_DWORD *)this + 53) = ++v17;
    v18 = *((_DWORD *)this + 24);
    v19 = *((_DWORD *)this + 25);
    v20 = v7 / v18;
    v21 = v8 / v19;
    v22 = (v7 + v11 - 1) / v18;
    v23 = *((_DWORD *)this + 27);
    v24 = (v8 + v12 - 1) / v19;
    if (v23 >= 1)
    {
      do
      {
        v20 *= 2;
        v21 *= 2;
        v22 = (2 * v22) | 1;
        v24 = (2 * v24) | 1;
        --v23;
      }
      while (v23);
    }
    v25 = 0;
    v26 = 0;
    v27 = *((_QWORD *)this + 18);
    v28 = 1 << *(_DWORD *)v27;
    do
    {
      v29 = *(_QWORD **)(*(_QWORD *)(v27 + 16) + 8 * v26);
      if (v29)
      {
        v30 = v25;
        do
        {
          v25 = (_QWORD *)v29[3];
          v31 = v25[3];
          if (v31)
            v32 = (a7 & 1) == 0;
          else
            v32 = 1;
          if (!v32)
            goto LABEL_41;
          v33 = *((_DWORD *)v25 + 10);
          if (a6 != -1 && v33 != a6)
            goto LABEL_41;
          v34 = *((_DWORD *)v25 + 11);
          v35 = v34 >= v20 >> v33 && v34 <= v22 >> v33;
          if (v35
            && ((v36 = *((_DWORD *)v25 + 12), v37 = v21 >> v33, v38 = v24 >> v33, v36 >= v37)
              ? (v39 = v36 <= v38)
              : (v39 = 0),
                v39
             && ((*((_DWORD *)v25 + 15) = v17, *((_DWORD *)v25 + 13) |= 0x10000u, v31)
               ? (v40 = (a7 & 2) == 0)
               : (v40 = 1),
                 !v40)))
          {
            v41 = (_QWORD *)v25[1];
            if (v41)
              *v41 = *v25;
            if (*v25)
              v42 = (uint64_t *)(*v25 + 8);
            else
              v42 = &CA::Render::subimage_head;
            *v42 = (uint64_t)v41;
            *v25 = v30;
          }
          else
          {
LABEL_41:
            v25 = v30;
          }
          v29 = (_QWORD *)*v29;
          v30 = v25;
        }
        while (v29);
      }
      ++v26;
    }
    while (v26 != v28);
    if (v25)
    {
      v43 = v25;
      do
      {
        x_hash_table_remove_ptr(*((_QWORD *)this + 18), (uint64_t)(v43 + 5));
        v43 = (_QWORD *)*v43;
      }
      while (v43);
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
      do
      {
        v44 = (unsigned int *)v25[3];
        if (v44)
        {
          v45 = v44 + 2;
          do
          {
            v46 = __ldaxr(v45);
            v47 = v46 - 1;
          }
          while (__stlxr(v47, v45));
          if (!v47)
            (*(void (**)(unsigned int *))(*(_QWORD *)v44 + 16))(v44);
        }
        v25 = (_QWORD *)*v25;
      }
      while (v25);
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    }
  }
}

void CA::Render::ImageProvider::set_image_size(CA::Render::ImageProvider *this, CA::Render::Context *a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  int *v7;
  int *v8;
  unsigned int v9;
  unsigned int v10;
  int v12;
  int v13;
  int v14;
  int v15;

  v7 = (int *)CA::Render::Context::lookup_object((uint64_t)this, (int)a2, a3, 0, 24, 0);
  if (v7)
  {
    v8 = v7;
    v10 = v7[4];
    v9 = v7[5];
    if (a4 != v10 || a5 != v9)
    {
      if (a4 <= v10)
      {
        v14 = a5 - v9;
        if (a5 > v9)
        {
          v12 = 0;
          v13 = v7[5];
          v15 = a4;
          goto LABEL_11;
        }
      }
      else
      {
        CA::Render::ImageProvider::invalidate((CA::Render::ImageProvider *)v7, v7[4], 0, a4 - v10, a5, -1, 0);
        if (a5 > v9)
        {
          CA::Render::ImageProvider::invalidate((CA::Render::ImageProvider *)v8, 0, v9, a5 - v9, a4, -1, 0);
          v7 = v8;
          v12 = v10;
          v13 = v9;
          v14 = a4 - v10;
          v15 = a5 - v9;
LABEL_11:
          CA::Render::ImageProvider::invalidate((CA::Render::ImageProvider *)v7, v12, v13, v14, v15, -1, 0);
        }
      }
      v8[4] = a4;
      v8[5] = a5;
    }
  }
}

CA::Render::TiledTexture *CA::Render::ImageProvider::set_fill_color(CA::Render::ImageProvider *this, CA::Render::Context *a2, uint64_t a3, int a4, Pattern *a5)
{
  CA::Render::TiledTexture *result;

  result = (CA::Render::TiledTexture *)CA::Render::Context::lookup_object((uint64_t)this, (int)a2, a3, 0, 24, 0);
  if (result)
    return (CA::Render::TiledTexture *)CA::Render::TiledTexture::set_fill_color(result, a4, a5);
  return result;
}

void CA::Render::ImageProvider::set_subimage(CA::Render::ImageProvider *this, CA::Render::Context *a2, uint64_t a3, int a4, int a5, int a6, CA::Render::Texture *a7, int a8, unsigned int a9)
{
  CA::Render::ImageProvider *v14;
  int v15;
  int v16;
  int v17;
  CA::Render::Texture *v18;

  v14 = (CA::Render::ImageProvider *)CA::Render::Context::lookup_object((uint64_t)this, (int)a2, a3, 0, 24, 0);
  if (v14)
  {
    if (a7)
    {
      if (*((_BYTE *)a7 + 12) == 24)
        return;
      v15 = a4;
      v16 = a5;
      v17 = a6;
      v18 = a7;
    }
    else
    {
      v15 = a4;
      v16 = a5;
      v17 = a6;
      v18 = 0;
    }
    CA::Render::ImageProvider::set_subimage(v14, v15, v16, v17, v18, a8, a9);
  }
}

void CA::Render::ImageProvider::invalidate(CA::Render::ImageProvider *this, CA::Render::Context *a2, uint64_t a3, int a4, int a5, int a6, int a7, int a8, char a9)
{
  CA::Render::ImageProvider *v14;

  v14 = (CA::Render::ImageProvider *)CA::Render::Context::lookup_object((uint64_t)this, (int)a2, a3, 0, 24, 0);
  if (v14)
    CA::Render::ImageProvider::invalidate(v14, a4, a5, a6, a7, a8, a9);
}

uint64_t CA::Render::ImageProvider::needed_subimage(CA::Render::ImageProvider *this, CA::Render::Context *a2, uint64_t a3, unsigned int *a4, unsigned int *a5, unsigned int *a6, unsigned int *a7)
{
  uint64_t result;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  malloc_zone_t *malloc_zone;

  result = CA::Render::Context::lookup_object((uint64_t)this, (int)a2, a3, 0, 24, 0);
  if (result)
  {
    v12 = result;
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    v13 = (_QWORD *)(v12 + 152);
    v14 = *(_QWORD **)(v12 + 160);
    if (v14 == v13)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
      return 0;
    }
    else
    {
      v16 = *v14;
      v15 = (_QWORD *)v14[1];
      *(_QWORD *)(v16 + 8) = v15;
      *v15 = v16;
      *v14 = v14;
      v14[1] = v14;
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
      *a4 = *((_DWORD *)v14 + 4);
      *a5 = *((_DWORD *)v14 + 5);
      *a6 = *((_DWORD *)v14 + 6);
      *a7 = *((_DWORD *)v14 + 8);
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v14);
      return 1;
    }
  }
  return result;
}

uint64_t CARenderServerGetDebugOption(mach_port_name_t a1, int a2)
{
  mach_port_name_t v4;
  uint64_t result;
  mach_port_t reply_port;
  mach_msg_return_t v7;
  int v8;
  BOOL v9;
  int v10;
  int msg;
  _BYTE msg_4[44];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = a1;
  if (a1 || (result = CARenderServerGetServerPort(0), (v4 = result) != 0))
  {
    memset(&msg_4[16], 0, 28);
    *(_OWORD *)msg_4 = 0u;
    *(_QWORD *)&msg_4[20] = *MEMORY[0x1E0C804E8];
    *(_DWORD *)&msg_4[28] = a2;
    reply_port = mig_get_reply_port();
    *(_DWORD *)&msg_4[4] = v4;
    *(_DWORD *)&msg_4[8] = reply_port;
    msg = 5395;
    *(_QWORD *)&msg_4[12] = 0x9D4300000000;
    if (MEMORY[0x1E0C85B60])
    {
      voucher_mach_msg_set((mach_msg_header_t *)&msg);
      reply_port = *(_DWORD *)&msg_4[8];
    }
    v7 = mach_msg((mach_msg_header_t *)&msg, 3, 0x24u, 0x30u, reply_port, 0, 0);
    v8 = v7;
    if ((v7 - 268435458) <= 0xE && ((1 << (v7 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(*(mach_port_t *)&msg_4[8]);
      goto LABEL_27;
    }
    if (v7)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg_4[8]);
      goto LABEL_26;
    }
    if (*(_DWORD *)&msg_4[16] == 71)
    {
      v8 = -308;
    }
    else if (*(_DWORD *)&msg_4[16] == 40359)
    {
      if ((msg & 0x80000000) == 0)
      {
        if (*(_DWORD *)msg_4 == 40)
        {
          if (!*(_DWORD *)&msg_4[4])
          {
            v8 = *(_DWORD *)&msg_4[28];
            if (!*(_DWORD *)&msg_4[28])
            {
              v10 = *(_DWORD *)&msg_4[32];
              if (a1)
                return v10 != 0;
              goto LABEL_28;
            }
            goto LABEL_25;
          }
        }
        else if (*(_DWORD *)msg_4 == 36)
        {
          if (*(_DWORD *)&msg_4[4])
            v9 = 1;
          else
            v9 = *(_DWORD *)&msg_4[28] == 0;
          if (v9)
            v8 = -300;
          else
            v8 = *(_DWORD *)&msg_4[28];
          goto LABEL_25;
        }
      }
      v8 = -300;
    }
    else
    {
      v8 = -301;
    }
LABEL_25:
    mach_msg_destroy((mach_msg_header_t *)&msg);
LABEL_26:
    if (v8 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
LABEL_27:
    v10 = 0;
    if (a1)
      return v10 != 0;
LABEL_28:
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v4);
    return v10 != 0;
  }
  return result;
}

void CARenderServerSetDebugOption(mach_port_name_t a1, int a2, int a3)
{
  mach_port_name_t ServerPort;
  mach_port_t reply_port;
  mach_msg_return_t v8;
  int v9;
  _BYTE msg[36];
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (a1 || (ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    memset(&msg[4], 0, 32);
    v11 = 0;
    *(_QWORD *)&msg[24] = *MEMORY[0x1E0C804E8];
    *(_DWORD *)&msg[32] = a2;
    LODWORD(v11) = a3;
    reply_port = mig_get_reply_port();
    *(_DWORD *)&msg[8] = ServerPort;
    *(_DWORD *)&msg[12] = reply_port;
    *(_DWORD *)msg = 5395;
    *(_QWORD *)&msg[16] = 0x9D4400000000;
    if (MEMORY[0x1E0C85B60])
    {
      voucher_mach_msg_set((mach_msg_header_t *)msg);
      reply_port = *(_DWORD *)&msg[12];
    }
    v8 = mach_msg((mach_msg_header_t *)msg, 3, 0x28u, 0x2Cu, reply_port, 0, 0);
    v9 = v8;
    if ((v8 - 268435458) <= 0xE && ((1 << (v8 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(*(mach_port_t *)&msg[12]);
LABEL_21:
      if (!a1)
        mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
      return;
    }
    if (v8)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    }
    else
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v9 = -308;
      }
      else if (*(_DWORD *)&msg[20] == 40360)
      {
        v9 = -300;
        if ((*(_DWORD *)msg & 0x80000000) == 0 && *(_DWORD *)&msg[4] == 36 && !*(_DWORD *)&msg[8])
        {
          v9 = *(_DWORD *)&msg[32];
          if (!*(_DWORD *)&msg[32])
            goto LABEL_21;
        }
      }
      else
      {
        v9 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
    if (v9 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_21;
  }
}

void CARenderServerClearDebugOptions(mach_port_name_t a1)
{
  mach_port_name_t ServerPort;
  mach_port_t reply_port;
  mach_msg_return_t v4;
  int v5;
  _BYTE msg[36];
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (a1 || (ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    v7 = 0;
    *(_DWORD *)&msg[4] = 0;
    *(_OWORD *)&msg[20] = 0u;
    reply_port = mig_get_reply_port();
    *(_DWORD *)&msg[8] = ServerPort;
    *(_DWORD *)&msg[12] = reply_port;
    *(_DWORD *)msg = 5395;
    *(_QWORD *)&msg[16] = 0x9D4500000000;
    if (MEMORY[0x1E0C85B60])
    {
      voucher_mach_msg_set((mach_msg_header_t *)msg);
      reply_port = *(_DWORD *)&msg[12];
    }
    v4 = mach_msg((mach_msg_header_t *)msg, 3, 0x18u, 0x2Cu, reply_port, 0, 0);
    v5 = v4;
    if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(*(mach_port_t *)&msg[12]);
LABEL_21:
      if (!a1)
        mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
      return;
    }
    if (v4)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    }
    else
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v5 = -308;
      }
      else if (*(_DWORD *)&msg[20] == 40361)
      {
        v5 = -300;
        if ((*(_DWORD *)msg & 0x80000000) == 0 && *(_DWORD *)&msg[4] == 36 && !*(_DWORD *)&msg[8])
        {
          v5 = *(_DWORD *)&msg[32];
          if (!*(_DWORD *)&msg[32])
            goto LABEL_21;
        }
      }
      else
      {
        v5 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
    if (v5 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_21;
  }
}

void CARenderServerClearColorDebugOptions(mach_port_name_t a1)
{
  mach_port_name_t ServerPort;
  mach_port_t reply_port;
  mach_msg_return_t v4;
  int v5;
  _BYTE msg[36];
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (a1 || (ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    v7 = 0;
    *(_DWORD *)&msg[4] = 0;
    *(_OWORD *)&msg[20] = 0u;
    reply_port = mig_get_reply_port();
    *(_DWORD *)&msg[8] = ServerPort;
    *(_DWORD *)&msg[12] = reply_port;
    *(_DWORD *)msg = 5395;
    *(_QWORD *)&msg[16] = 0x9D4600000000;
    if (MEMORY[0x1E0C85B60])
    {
      voucher_mach_msg_set((mach_msg_header_t *)msg);
      reply_port = *(_DWORD *)&msg[12];
    }
    v4 = mach_msg((mach_msg_header_t *)msg, 3, 0x18u, 0x2Cu, reply_port, 0, 0);
    v5 = v4;
    if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(*(mach_port_t *)&msg[12]);
LABEL_21:
      if (!a1)
        mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
      return;
    }
    if (v4)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    }
    else
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v5 = -308;
      }
      else if (*(_DWORD *)&msg[20] == 40362)
      {
        v5 = -300;
        if ((*(_DWORD *)msg & 0x80000000) == 0 && *(_DWORD *)&msg[4] == 36 && !*(_DWORD *)&msg[8])
        {
          v5 = *(_DWORD *)&msg[32];
          if (!*(_DWORD *)&msg[32])
            goto LABEL_21;
        }
      }
      else
      {
        v5 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
    if (v5 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_21;
  }
}

uint64_t CARenderServerGetDebugFlags(mach_port_t a1)
{
  mach_port_t ServerPort;
  mach_port_t reply_port;
  mach_msg_return_t v4;
  mach_port_t msgh_remote_port;
  BOOL v6;
  uint64_t msgh_local_port;
  mach_msg_header_t msg[2];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (!a1)
  {
    ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort)
      return 0;
  }
  *(_OWORD *)&msg[1].msgh_remote_port = 0u;
  *(_OWORD *)&msg[0].msgh_id = 0u;
  msg[0].msgh_size = 0;
  reply_port = mig_get_reply_port();
  msg[0].msgh_remote_port = ServerPort;
  msg[0].msgh_local_port = reply_port;
  msg[0].msgh_bits = 5395;
  *(_QWORD *)&msg[0].msgh_voucher_port = 0x9D4700000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(msg);
    reply_port = msg[0].msgh_local_port;
  }
  v4 = mach_msg(msg, 3, 0x18u, 0x30u, reply_port, 0, 0);
  msgh_remote_port = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg[0].msgh_local_port);
    goto LABEL_28;
  }
  if (v4)
  {
    mig_dealloc_reply_port(msg[0].msgh_local_port);
    goto LABEL_27;
  }
  if (msg[0].msgh_id == 71)
  {
    msgh_remote_port = -308;
  }
  else if (msg[0].msgh_id == 40363)
  {
    if ((msg[0].msgh_bits & 0x80000000) == 0)
    {
      if (msg[0].msgh_size == 40)
      {
        if (!msg[0].msgh_remote_port)
        {
          msgh_remote_port = msg[1].msgh_remote_port;
          if (!msg[1].msgh_remote_port)
          {
            msgh_local_port = msg[1].msgh_local_port;
            if (a1)
              return msgh_local_port;
            goto LABEL_29;
          }
          goto LABEL_26;
        }
      }
      else if (msg[0].msgh_size == 36)
      {
        if (msg[0].msgh_remote_port)
          v6 = 1;
        else
          v6 = msg[1].msgh_remote_port == 0;
        if (v6)
          msgh_remote_port = -300;
        else
          msgh_remote_port = msg[1].msgh_remote_port;
        goto LABEL_26;
      }
    }
    msgh_remote_port = -300;
  }
  else
  {
    msgh_remote_port = -301;
  }
LABEL_26:
  mach_msg_destroy(msg);
LABEL_27:
  if (msgh_remote_port == -81182719)
  {
    x_log_crash("Unentitled call to server!");
    abort();
  }
LABEL_28:
  msgh_local_port = 0;
  if (!a1)
LABEL_29:
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
  return msgh_local_port;
}

void CARenderServerSetDebugFlags(mach_port_name_t a1, int a2, int a3)
{
  mach_port_name_t ServerPort;
  mach_port_t reply_port;
  mach_msg_return_t v8;
  int v9;
  _BYTE msg[36];
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (a1 || (ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    memset(&msg[4], 0, 32);
    v11 = 0;
    *(_QWORD *)&msg[24] = *MEMORY[0x1E0C804E8];
    *(_DWORD *)&msg[32] = a2;
    LODWORD(v11) = a3;
    reply_port = mig_get_reply_port();
    *(_DWORD *)&msg[8] = ServerPort;
    *(_DWORD *)&msg[12] = reply_port;
    *(_DWORD *)msg = 5395;
    *(_QWORD *)&msg[16] = 0x9D4800000000;
    if (MEMORY[0x1E0C85B60])
    {
      voucher_mach_msg_set((mach_msg_header_t *)msg);
      reply_port = *(_DWORD *)&msg[12];
    }
    v8 = mach_msg((mach_msg_header_t *)msg, 3, 0x28u, 0x2Cu, reply_port, 0, 0);
    v9 = v8;
    if ((v8 - 268435458) <= 0xE && ((1 << (v8 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(*(mach_port_t *)&msg[12]);
LABEL_21:
      if (!a1)
        mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
      return;
    }
    if (v8)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    }
    else
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v9 = -308;
      }
      else if (*(_DWORD *)&msg[20] == 40364)
      {
        v9 = -300;
        if ((*(_DWORD *)msg & 0x80000000) == 0 && *(_DWORD *)&msg[4] == 36 && !*(_DWORD *)&msg[8])
        {
          v9 = *(_DWORD *)&msg[32];
          if (!*(_DWORD *)&msg[32])
            goto LABEL_21;
        }
      }
      else
      {
        v9 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
    if (v9 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_21;
  }
}

float CARenderServerGetDebugValueFloat(mach_port_name_t a1, int a2)
{
  mach_port_name_t ServerPort;
  mach_port_t reply_port;
  mach_msg_return_t v6;
  int v7;
  float v8;
  BOOL v9;
  int msg;
  _BYTE msg_4[44];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (!a1)
  {
    ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort)
      return 0.0;
  }
  memset(&msg_4[16], 0, 28);
  *(_OWORD *)msg_4 = 0u;
  *(_QWORD *)&msg_4[20] = *MEMORY[0x1E0C804E8];
  *(_DWORD *)&msg_4[28] = a2;
  reply_port = mig_get_reply_port();
  *(_DWORD *)&msg_4[4] = ServerPort;
  *(_DWORD *)&msg_4[8] = reply_port;
  msg = 5395;
  *(_QWORD *)&msg_4[12] = 0x9D4900000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    reply_port = *(_DWORD *)&msg_4[8];
  }
  v6 = mach_msg((mach_msg_header_t *)&msg, 3, 0x24u, 0x30u, reply_port, 0, 0);
  v7 = v6;
  if ((v6 - 268435458) > 0xE || ((1 << (v6 - 2)) & 0x4003) == 0)
  {
    if (v6)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg_4[8]);
      goto LABEL_28;
    }
    if (*(_DWORD *)&msg_4[16] == 71)
    {
      v7 = -308;
    }
    else if (*(_DWORD *)&msg_4[16] == 40365)
    {
      if ((msg & 0x80000000) == 0)
      {
        if (*(_DWORD *)msg_4 == 40)
        {
          if (!*(_DWORD *)&msg_4[4])
          {
            v7 = *(_DWORD *)&msg_4[28];
            if (!*(_DWORD *)&msg_4[28])
            {
              v8 = *(float *)&msg_4[32];
              if (a1)
                return v8;
              goto LABEL_30;
            }
            goto LABEL_27;
          }
        }
        else if (*(_DWORD *)msg_4 == 36)
        {
          if (*(_DWORD *)&msg_4[4])
            v9 = 1;
          else
            v9 = *(_DWORD *)&msg_4[28] == 0;
          if (v9)
            v7 = -300;
          else
            v7 = *(_DWORD *)&msg_4[28];
          goto LABEL_27;
        }
      }
      v7 = -300;
    }
    else
    {
      v7 = -301;
    }
LABEL_27:
    mach_msg_destroy((mach_msg_header_t *)&msg);
LABEL_28:
    v8 = 0.0;
    if (v7 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    if (!a1)
      goto LABEL_30;
    return v8;
  }
  mig_put_reply_port(*(mach_port_t *)&msg_4[8]);
  v8 = 0.0;
  if (!a1)
LABEL_30:
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
  return v8;
}

uint64_t CARenderServerGetDebugValue(mach_port_name_t a1, int a2)
{
  return CARenderServerGetDebugValueFloat(a1, a2);
}

void CARenderServerSetDebugValueFloat(mach_port_name_t a1, int a2, float a3)
{
  mach_port_name_t ServerPort;
  mach_port_t reply_port;
  mach_msg_return_t v8;
  int v9;
  _BYTE msg[36];
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (a1 || (ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    memset(&msg[4], 0, 32);
    v11 = 0;
    *(_QWORD *)&msg[24] = *MEMORY[0x1E0C804E8];
    *(_DWORD *)&msg[32] = a2;
    *(float *)&v11 = a3;
    reply_port = mig_get_reply_port();
    *(_DWORD *)&msg[8] = ServerPort;
    *(_DWORD *)&msg[12] = reply_port;
    *(_DWORD *)msg = 5395;
    *(_QWORD *)&msg[16] = 0x9D4A00000000;
    if (MEMORY[0x1E0C85B60])
    {
      voucher_mach_msg_set((mach_msg_header_t *)msg);
      reply_port = *(_DWORD *)&msg[12];
    }
    v8 = mach_msg((mach_msg_header_t *)msg, 3, 0x28u, 0x2Cu, reply_port, 0, 0);
    v9 = v8;
    if ((v8 - 268435458) <= 0xE && ((1 << (v8 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(*(mach_port_t *)&msg[12]);
LABEL_21:
      if (!a1)
        mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
      return;
    }
    if (v8)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    }
    else
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v9 = -308;
      }
      else if (*(_DWORD *)&msg[20] == 40366)
      {
        v9 = -300;
        if ((*(_DWORD *)msg & 0x80000000) == 0 && *(_DWORD *)&msg[4] == 36 && !*(_DWORD *)&msg[8])
        {
          v9 = *(_DWORD *)&msg[32];
          if (!*(_DWORD *)&msg[32])
            goto LABEL_21;
        }
      }
      else
      {
        v9 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
    if (v9 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_21;
  }
}

void CARenderServerSetDebugValue(mach_port_name_t a1, int a2, unsigned int a3)
{
  CARenderServerSetDebugValueFloat(a1, a2, (float)a3);
}

void CARenderServerDebugBrightness(int a1, double a2)
{
  int ServerPort;
  mach_port_name_t v4;

  if (a1)
  {
    _CASDebugBrightness(a1, a2);
  }
  else
  {
    ServerPort = CARenderServerGetServerPort(0);
    if (ServerPort)
    {
      v4 = ServerPort;
      _CASDebugBrightness(ServerPort, a2);
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], v4);
    }
  }
}

void CARenderServerDebugPreset(int a1, int a2)
{
  int ServerPort;
  mach_port_name_t v4;

  if (a1)
  {
    _CASDebugPreset(a1, a2);
  }
  else
  {
    ServerPort = CARenderServerGetServerPort(0);
    if (ServerPort)
    {
      v4 = ServerPort;
      _CASDebugPreset(ServerPort, a2);
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], v4);
    }
  }
}

void CARenderServerDebugFrameInfo(int a1)
{
  int ServerPort;
  mach_port_name_t v2;

  if (a1)
  {
    _CASDebugFrameInfo(a1);
  }
  else
  {
    ServerPort = CARenderServerGetServerPort(0);
    if (ServerPort)
    {
      v2 = ServerPort;
      _CASDebugFrameInfo(ServerPort);
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], v2);
    }
  }
}

void CARenderServerSetMessageFile(mach_port_name_t a1, char *__source)
{
  mach_port_name_t ServerPort;
  mach_port_t v5;
  mach_msg_size_t v6;
  mach_port_t reply_port;
  mach_msg_return_t v8;
  mach_port_t msgh_remote_port;
  _OWORD v10[16];
  mach_msg_header_t msg[12];
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (a1 || (ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    memset(v10, 0, sizeof(v10));
    strlcpy((char *)v10, __source, 0x100uLL);
    v12 = 0;
    memset(msg, 0, sizeof(msg));
    *(_QWORD *)&msg[1].msgh_bits = *MEMORY[0x1E0C804E8];
    if (MEMORY[0x1E0C84128])
      v5 = mig_strncpy_zerofill((char *)&msg[1].msgh_voucher_port, (const char *)v10, 256);
    else
      v5 = mig_strncpy((char *)&msg[1].msgh_voucher_port, (const char *)v10, 256);
    msg[1].msgh_local_port = v5;
    msg[1].msgh_remote_port = 0;
    v6 = ((v5 + 3) & 0xFFFFFFFC) + 40;
    reply_port = mig_get_reply_port();
    msg[0].msgh_bits = 5395;
    *(_QWORD *)&msg[0].msgh_remote_port = __PAIR64__(reply_port, ServerPort);
    *(_QWORD *)&msg[0].msgh_voucher_port = 0x9D4E00000000;
    if (MEMORY[0x1E0C85B60])
    {
      voucher_mach_msg_set(msg);
      reply_port = msg[0].msgh_local_port;
    }
    v8 = mach_msg(msg, 3, v6, 0x2Cu, reply_port, 0, 0);
    msgh_remote_port = v8;
    if ((v8 - 268435458) <= 0xE && ((1 << (v8 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(msg[0].msgh_local_port);
LABEL_23:
      if (!a1)
        mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
      return;
    }
    if (v8)
    {
      mig_dealloc_reply_port(msg[0].msgh_local_port);
    }
    else
    {
      if (msg[0].msgh_id == 71)
      {
        msgh_remote_port = -308;
      }
      else if (msg[0].msgh_id == 40370)
      {
        msgh_remote_port = -300;
        if ((msg[0].msgh_bits & 0x80000000) == 0 && *(_QWORD *)&msg[0].msgh_size == 36)
        {
          msgh_remote_port = msg[1].msgh_remote_port;
          if (!msg[1].msgh_remote_port)
            goto LABEL_23;
        }
      }
      else
      {
        msgh_remote_port = -301;
      }
      mach_msg_destroy(msg);
    }
    if (msgh_remote_port == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_23;
  }
}

void CARenderServerSetDebugMessage(mach_port_name_t a1, char *__source, int a3)
{
  mach_port_name_t ServerPort;
  __int128 v7;
  int v8;
  int v9;
  mach_msg_size_t v10;
  mach_port_t reply_port;
  mach_msg_return_t v12;
  int v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _BYTE msg[32];
  _OWORD v31[15];
  _OWORD v32[2];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (a1 || (ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    v7 = 0uLL;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    if (__source)
    {
      strlcpy((char *)&v14, __source, 0x100uLL);
      v7 = 0uLL;
    }
    *(_OWORD *)((char *)v32 + 12) = v7;
    if ((a3 & 0xF) != 0)
      v8 = a3;
    else
      v8 = -1;
    v31[14] = v7;
    v32[0] = v7;
    v31[12] = v7;
    v31[13] = v7;
    v31[10] = v7;
    v31[11] = v7;
    v31[8] = v7;
    v31[9] = v7;
    v31[6] = v7;
    v31[7] = v7;
    v31[4] = v7;
    v31[5] = v7;
    v31[2] = v7;
    v31[3] = v7;
    v31[0] = v7;
    v31[1] = v7;
    *(_OWORD *)msg = v7;
    *(_OWORD *)&msg[16] = v7;
    *(_QWORD *)&msg[24] = *MEMORY[0x1E0C804E8];
    if (MEMORY[0x1E0C84128])
      v9 = mig_strncpy_zerofill((char *)v31 + 8, (const char *)&v14, 256);
    else
      v9 = mig_strncpy((char *)v31 + 8, (const char *)&v14, 256);
    DWORD1(v31[0]) = v9;
    LODWORD(v31[0]) = 0;
    v10 = ((v9 + 3) & 0xFFFFFFFC) + 44;
    *(_DWORD *)((char *)v31 + ((v9 + 3) & 0xFFFFFFFC) + 8) = v8;
    reply_port = mig_get_reply_port();
    *(_DWORD *)msg = 5395;
    *(_QWORD *)&msg[8] = __PAIR64__(reply_port, ServerPort);
    *(_QWORD *)&msg[16] = 0x9D4F00000000;
    if (MEMORY[0x1E0C85B60])
    {
      voucher_mach_msg_set((mach_msg_header_t *)msg);
      reply_port = *(_DWORD *)&msg[12];
    }
    v12 = mach_msg((mach_msg_header_t *)msg, 3, v10, 0x2Cu, reply_port, 0, 0);
    v13 = v12;
    if ((v12 - 268435458) <= 0xE && ((1 << (v12 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(*(mach_port_t *)&msg[12]);
LABEL_28:
      if (!a1)
        mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
      return;
    }
    if (v12)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    }
    else
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v13 = -308;
      }
      else if (*(_DWORD *)&msg[20] == 40371)
      {
        v13 = -300;
        if ((*(_DWORD *)msg & 0x80000000) == 0 && *(_QWORD *)&msg[4] == 36)
        {
          v13 = v31[0];
          if (!LODWORD(v31[0]))
            goto LABEL_28;
        }
      }
      else
      {
        v13 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
    if (v13 == -81182719)
    {
      x_log_crash("Unentitled call to server!", v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29);
      abort();
    }
    goto LABEL_28;
  }
}

void CARenderServerSetOverdriveLUTFile(mach_port_name_t a1, char *__source)
{
  mach_port_name_t ServerPort;
  mach_port_t v5;
  mach_msg_size_t v6;
  mach_port_t reply_port;
  mach_msg_return_t v8;
  mach_port_t msgh_remote_port;
  _OWORD v10[16];
  mach_msg_header_t msg[12];
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (a1 || (ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    memset(v10, 0, sizeof(v10));
    strlcpy((char *)v10, __source, 0x100uLL);
    v12 = 0;
    memset(msg, 0, sizeof(msg));
    *(_QWORD *)&msg[1].msgh_bits = *MEMORY[0x1E0C804E8];
    if (MEMORY[0x1E0C84128])
      v5 = mig_strncpy_zerofill((char *)&msg[1].msgh_voucher_port, (const char *)v10, 256);
    else
      v5 = mig_strncpy((char *)&msg[1].msgh_voucher_port, (const char *)v10, 256);
    msg[1].msgh_local_port = v5;
    msg[1].msgh_remote_port = 0;
    v6 = ((v5 + 3) & 0xFFFFFFFC) + 40;
    reply_port = mig_get_reply_port();
    msg[0].msgh_bits = 5395;
    *(_QWORD *)&msg[0].msgh_remote_port = __PAIR64__(reply_port, ServerPort);
    *(_QWORD *)&msg[0].msgh_voucher_port = 0x9D5000000000;
    if (MEMORY[0x1E0C85B60])
    {
      voucher_mach_msg_set(msg);
      reply_port = msg[0].msgh_local_port;
    }
    v8 = mach_msg(msg, 3, v6, 0x2Cu, reply_port, 0, 0);
    msgh_remote_port = v8;
    if ((v8 - 268435458) <= 0xE && ((1 << (v8 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(msg[0].msgh_local_port);
LABEL_23:
      if (!a1)
        mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
      return;
    }
    if (v8)
    {
      mig_dealloc_reply_port(msg[0].msgh_local_port);
    }
    else
    {
      if (msg[0].msgh_id == 71)
      {
        msgh_remote_port = -308;
      }
      else if (msg[0].msgh_id == 40372)
      {
        msgh_remote_port = -300;
        if ((msg[0].msgh_bits & 0x80000000) == 0 && *(_QWORD *)&msg[0].msgh_size == 36)
        {
          msgh_remote_port = msg[1].msgh_remote_port;
          if (!msg[1].msgh_remote_port)
            goto LABEL_23;
        }
      }
      else
      {
        msgh_remote_port = -301;
      }
      mach_msg_destroy(msg);
    }
    if (msgh_remote_port == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_23;
  }
}

void CARenderServerSetAXMatrix(mach_port_t a1, __int128 *a2)
{
  mach_port_t ServerPort;
  __int128 v5;
  mach_port_t reply_port;
  mach_msg_return_t v7;
  int v8;
  mach_msg_header_t v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (a1 || (ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    v5 = a2[1];
    v11 = *a2;
    v12 = v5;
    v13 = *((_QWORD *)a2 + 4);
    v10 = *MEMORY[0x1E0C804E8];
    reply_port = mig_get_reply_port();
    *(_QWORD *)&v9.msgh_bits = 5395;
    v9.msgh_remote_port = ServerPort;
    v9.msgh_local_port = reply_port;
    *(_QWORD *)&v9.msgh_voucher_port = 0x9D5100000000;
    if (MEMORY[0x1E0C85B60])
    {
      voucher_mach_msg_set(&v9);
      reply_port = v9.msgh_local_port;
    }
    v7 = mach_msg(&v9, 3, 0x48u, 0x2Cu, reply_port, 0, 0);
    v8 = v7;
    if ((v7 - 268435458) <= 0xE && ((1 << (v7 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(v9.msgh_local_port);
LABEL_20:
      if (!a1)
        mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
      return;
    }
    if (v7)
    {
      mig_dealloc_reply_port(v9.msgh_local_port);
    }
    else
    {
      if (v9.msgh_id == 71)
      {
        v8 = -308;
      }
      else if (v9.msgh_id == 40373)
      {
        v8 = -300;
        if ((v9.msgh_bits & 0x80000000) == 0 && *(_QWORD *)&v9.msgh_size == 36)
        {
          v8 = v11;
          if (!(_DWORD)v11)
            goto LABEL_20;
        }
      }
      else
      {
        v8 = -301;
      }
      mach_msg_destroy(&v9);
    }
    if (v8 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_20;
  }
}

void CARenderServerSetScreenTelemetryParameters()
{
  NSObject *v0;
  uint8_t v1[8];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v0 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v1 = 0;
      _os_log_impl(&dword_184457000, v0, OS_LOG_TYPE_ERROR, "CARenderServerSetScreenTelemetryParameters is deprecated!", v1, 2u);
    }
  }
}

_BYTE *CARenderServerGetInfo(mach_port_name_t a1, int a2, uint64_t a3)
{
  mach_port_name_t ServerPort;
  mach_port_t reply_port;
  mach_msg_return_t v8;
  int v9;
  _BYTE *v10;
  unsigned int v11;
  const void *v12;
  size_t v14;
  _BYTE *v15;
  int msg;
  _BYTE msg_4[60];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (!a1)
  {
    ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort)
      return 0;
  }
  memset(&msg_4[16], 0, 44);
  *(_OWORD *)msg_4 = 0u;
  *(_QWORD *)&msg_4[20] = *MEMORY[0x1E0C804E8];
  *(_DWORD *)&msg_4[28] = a2;
  *(_QWORD *)&msg_4[32] = a3;
  reply_port = mig_get_reply_port();
  *(_DWORD *)&msg_4[4] = ServerPort;
  *(_DWORD *)&msg_4[8] = reply_port;
  msg = 5395;
  *(_QWORD *)&msg_4[12] = 0x9D5200000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    reply_port = *(_DWORD *)&msg_4[8];
  }
  v8 = mach_msg((mach_msg_header_t *)&msg, 3, 0x2Cu, 0x40u, reply_port, 0, 0);
  v9 = v8;
  if ((v8 - 268435458) <= 0xE && ((1 << (v8 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg_4[8]);
  }
  else
  {
    if (v8)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg_4[8]);
    }
    else
    {
      if (*(_DWORD *)&msg_4[16] == 71)
      {
        v9 = -308;
      }
      else if (*(_DWORD *)&msg_4[16] == 40374)
      {
        if (msg < 0)
        {
          v9 = -300;
          if (*(_DWORD *)&msg_4[20] == 1 && *(_DWORD *)msg_4 == 56 && !*(_DWORD *)&msg_4[4] && msg_4[35] == 1)
          {
            v11 = *(_DWORD *)&msg_4[36];
            if (*(_DWORD *)&msg_4[36] == *(_DWORD *)&msg_4[48])
            {
              v9 = 0;
              v12 = *(const void **)&msg_4[24];
              goto LABEL_31;
            }
          }
        }
        else if (*(_DWORD *)msg_4 == 36)
        {
          v9 = -300;
          if (*(_DWORD *)&msg_4[28])
          {
            if (*(_DWORD *)&msg_4[4])
              v9 = -300;
            else
              v9 = *(_DWORD *)&msg_4[28];
          }
        }
        else
        {
          v9 = -300;
        }
      }
      else
      {
        v9 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)&msg);
    }
    if (v9 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
  }
  v12 = 0;
  v11 = 0;
LABEL_31:
  if (v9)
  {
    v10 = 0;
    if (!a1)
LABEL_33:
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
  }
  else
  {
    v14 = v11;
    v15 = malloc_type_malloc(v11 + 1, 0xCA7C6B99uLL);
    v10 = v15;
    if (v15)
    {
      memcpy(v15, v12, v14);
      v10[v14] = 0;
    }
    mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)v12, v14);
    if (!a1)
      goto LABEL_33;
  }
  return v10;
}

CFPropertyListRef CARenderServerCopyUpdateHistograms(mach_port_name_t a1, int a2)
{
  mach_port_name_t ServerPort;
  mach_port_t reply_port;
  mach_msg_return_t v6;
  int v7;
  unsigned int v8;
  const UInt8 *v9;
  const __CFAllocator *v10;
  const __CFData *v11;
  CFPropertyListRef v12;
  int msg;
  _BYTE msg_4[60];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (!a1)
  {
    ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort)
      return 0;
  }
  memset(&msg_4[16], 0, 44);
  *(_OWORD *)msg_4 = 0u;
  *(_QWORD *)&msg_4[20] = *MEMORY[0x1E0C804E8];
  *(_DWORD *)&msg_4[28] = a2;
  reply_port = mig_get_reply_port();
  *(_DWORD *)&msg_4[4] = ServerPort;
  *(_DWORD *)&msg_4[8] = reply_port;
  msg = 5395;
  *(_QWORD *)&msg_4[12] = 0x9D3D00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    reply_port = *(_DWORD *)&msg_4[8];
  }
  v6 = mach_msg((mach_msg_header_t *)&msg, 3, 0x24u, 0x40u, reply_port, 0, 0);
  v7 = v6;
  if ((v6 - 268435458) <= 0xE && ((1 << (v6 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg_4[8]);
  }
  else
  {
    if (v6)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg_4[8]);
    }
    else
    {
      if (*(_DWORD *)&msg_4[16] == 71)
      {
        v7 = -308;
      }
      else if (*(_DWORD *)&msg_4[16] == 40353)
      {
        if (msg < 0)
        {
          v7 = -300;
          if (*(_DWORD *)&msg_4[20] == 1 && *(_DWORD *)msg_4 == 56 && !*(_DWORD *)&msg_4[4] && msg_4[35] == 1)
          {
            v8 = *(_DWORD *)&msg_4[36];
            if (*(_DWORD *)&msg_4[36] == *(_DWORD *)&msg_4[48])
            {
              v7 = 0;
              v9 = *(const UInt8 **)&msg_4[24];
              goto LABEL_30;
            }
          }
        }
        else if (*(_DWORD *)msg_4 == 36)
        {
          v7 = -300;
          if (*(_DWORD *)&msg_4[28])
          {
            if (*(_DWORD *)&msg_4[4])
              v7 = -300;
            else
              v7 = *(_DWORD *)&msg_4[28];
          }
        }
        else
        {
          v7 = -300;
        }
      }
      else
      {
        v7 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)&msg);
    }
    if (v7 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
  }
  v9 = 0;
  v8 = 0;
LABEL_30:
  if (!a1)
  {
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
    if (!v7)
      goto LABEL_34;
    return 0;
  }
  if (v7)
    return 0;
LABEL_34:
  v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE18];
  v11 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE18], v9, v8);
  mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)v9, v8);
  if (!v11)
    return 0;
  v12 = CFPropertyListCreateWithData(v10, v11, 0, 0, 0);
  CFRelease(v11);
  return v12;
}

CFPropertyListRef CARenderServerCopyODStatistics(mach_port_name_t a1)
{
  mach_port_name_t ServerPort;
  mach_port_t reply_port;
  mach_msg_return_t v4;
  int v5;
  unsigned int v6;
  const UInt8 *v7;
  const __CFAllocator *v8;
  const __CFData *v9;
  CFPropertyListRef v10;
  int msg;
  int msg_4;
  mach_port_name_t msg_8;
  mach_port_t msg_12;
  _BYTE msg_16[48];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (!a1)
  {
    ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort)
      return 0;
  }
  memset(&msg_16[4], 0, 44);
  msg_4 = 0;
  reply_port = mig_get_reply_port();
  msg_8 = ServerPort;
  msg_12 = reply_port;
  msg = 5395;
  *(_QWORD *)msg_16 = 0x9D3E00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    reply_port = msg_12;
  }
  v4 = mach_msg((mach_msg_header_t *)&msg, 3, 0x18u, 0x40u, reply_port, 0, 0);
  v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg_12);
  }
  else
  {
    if (v4)
    {
      mig_dealloc_reply_port(msg_12);
    }
    else
    {
      if (*(_DWORD *)&msg_16[4] == 71)
      {
        v5 = -308;
      }
      else if (*(_DWORD *)&msg_16[4] == 40354)
      {
        if (msg < 0)
        {
          v5 = -300;
          if (*(_DWORD *)&msg_16[8] == 1 && msg_4 == 56 && !msg_8 && msg_16[23] == 1)
          {
            v6 = *(_DWORD *)&msg_16[24];
            if (*(_DWORD *)&msg_16[24] == *(_DWORD *)&msg_16[36])
            {
              v5 = 0;
              v7 = *(const UInt8 **)&msg_16[12];
              goto LABEL_30;
            }
          }
        }
        else if (msg_4 == 36)
        {
          v5 = -300;
          if (*(_DWORD *)&msg_16[16])
          {
            if (msg_8)
              v5 = -300;
            else
              v5 = *(_DWORD *)&msg_16[16];
          }
        }
        else
        {
          v5 = -300;
        }
      }
      else
      {
        v5 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)&msg);
    }
    if (v5 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
  }
  v7 = 0;
  v6 = 0;
LABEL_30:
  if (!a1)
  {
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
    if (!v5)
      goto LABEL_34;
    return 0;
  }
  if (v5)
    return 0;
LABEL_34:
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE18];
  v9 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE18], v7, v6);
  mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)v7, v6);
  if (!v9)
    return 0;
  v10 = CFPropertyListCreateWithData(v8, v9, 0, 0, 0);
  CFRelease(v9);
  return v10;
}

CFIndex CARenderServerGetStatistics(mach_port_name_t a1, _QWORD *a2)
{
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex Count;
  void *v6;
  uint64_t v7;
  CFIndex v8;
  const __CFString *v9;
  const __CFDictionary *ValueAtIndex;
  const __CFString *Value;
  const void *v12;
  int Int;
  const __CFString *v14;
  int v15;
  CFIndex v16;
  int v17;
  char **v18;
  const char *CString;
  int v21;
  int v22;
  _QWORD *v23;
  int v24;
  int v25;
  _OWORD v26[16];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  *a2 = 0;
  v3 = (const __CFArray *)CARenderServerCopyDictionaries(a1);
  if (!v3)
    return 0;
  v4 = v3;
  Count = CFArrayGetCount(v3);
  v6 = malloc_type_malloc(8 * Count, 0x10040436913F5uLL);
  *a2 = v6;
  if (v6)
  {
    v23 = a2;
    if (Count)
    {
      v7 = 0;
      v8 = 0;
      v9 = CFSTR("kCADisplayDeviceName");
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v4, v8);
        Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("kCADisplayName"));
        v12 = CFDictionaryGetValue(ValueAtIndex, v9);
        if (Value && v12)
        {
          memset(v26, 0, sizeof(v26));
          Int = CA_CFDictionaryGetInt(ValueAtIndex, CFSTR("kCADisplayFrameCount"));
          v25 = CA_CFDictionaryGetInt(ValueAtIndex, CFSTR("kCADisplaySkippedFrameCount"));
          v24 = CA_CFDictionaryGetInt(ValueAtIndex, CFSTR("kCADisplayClonedFrameCount"));
          v14 = v9;
          v15 = CA_CFDictionaryGetInt(ValueAtIndex, CFSTR("kCADisplaySkippedClonedFrameCount"));
          v16 = Count;
          v17 = Int - CA_CFDictionaryGetInt(ValueAtIndex, CFSTR("kCADisplayDirtyFrameCount"));
          v18 = (char **)(*v23 + v7);
          CString = CA_CFStringGetCString(Value, (char *)v26, 256);
          v21 = v15;
          v22 = v17;
          Count = v16;
          v9 = v14;
          asprintf(v18, "%s display:\n\tTotal Frames:\t\t%d\n\tSkipped Frames:\t\t%d\n\tTotal Cloned Frames:\t%d\n\tSkipped Cloned Frames:\t%d\n\tNon-Dirty Frames:\t%d\n\n", CString, Int, v25, v24, v21, v22);
        }
        ++v8;
        v7 += 8;
      }
      while (Count != v8);
    }
  }
  else
  {
    Count = 0;
  }
  CFRelease(v4);
  return Count;
}

uint64_t CARenderServerGetClientPort(mach_port_name_t a1, int a2)
{
  mach_port_name_t ServerPort;
  mach_port_t reply_port;
  mach_msg_return_t v6;
  int v7;
  uint64_t v8;
  int msg;
  _BYTE msg_4[44];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (!a1)
  {
    ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort)
      return 0;
  }
  memset(&msg_4[16], 0, 28);
  *(_OWORD *)msg_4 = 0u;
  *(_QWORD *)&msg_4[20] = *MEMORY[0x1E0C804E8];
  *(_DWORD *)&msg_4[28] = a2;
  reply_port = mig_get_reply_port();
  *(_DWORD *)&msg_4[4] = ServerPort;
  *(_DWORD *)&msg_4[8] = reply_port;
  msg = 5395;
  *(_QWORD *)&msg_4[12] = 0x9D0E00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    reply_port = *(_DWORD *)&msg_4[8];
  }
  v6 = mach_msg((mach_msg_header_t *)&msg, 3, 0x24u, 0x30u, reply_port, 0, 0);
  v7 = v6;
  if ((v6 - 268435458) <= 0xE && ((1 << (v6 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg_4[8]);
  }
  else
  {
    if (v6)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg_4[8]);
    }
    else
    {
      if (*(_DWORD *)&msg_4[16] == 71)
      {
        v7 = -308;
      }
      else if (*(_DWORD *)&msg_4[16] == 40306)
      {
        if (msg < 0)
        {
          v7 = -300;
          if (*(_DWORD *)&msg_4[20] == 1
            && *(_DWORD *)msg_4 == 40
            && !*(_DWORD *)&msg_4[4]
            && *(unsigned __int16 *)&msg_4[34] << 16 == 1114112)
          {
            v8 = *(unsigned int *)&msg_4[24];
            goto LABEL_30;
          }
        }
        else if (*(_DWORD *)msg_4 == 36)
        {
          v7 = -300;
          if (*(_DWORD *)&msg_4[28])
          {
            if (*(_DWORD *)&msg_4[4])
              v7 = -300;
            else
              v7 = *(_DWORD *)&msg_4[28];
          }
        }
        else
        {
          v7 = -300;
        }
      }
      else
      {
        v7 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)&msg);
    }
    if (v7 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
  }
  v8 = 0;
LABEL_30:
  if (!a1)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
  return v8;
}

uint64_t CARenderServerGetClientProcessId(mach_port_t a1, int a2)
{
  mach_port_t ServerPort;
  mach_port_t reply_port;
  mach_msg_return_t v6;
  int v7;
  BOOL v8;
  uint64_t v9;
  mach_msg_header_t msg;
  int v12;
  int v13;
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (!a1)
  {
    ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort)
      return 0;
  }
  v14 = 0u;
  msg.msgh_size = 0;
  v12 = 1;
  v13 = a2;
  DWORD1(v14) = 1245184;
  reply_port = mig_get_reply_port();
  msg.msgh_remote_port = ServerPort;
  msg.msgh_local_port = reply_port;
  msg.msgh_bits = -2147478253;
  *(_QWORD *)&msg.msgh_voucher_port = 0x9D0F00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    reply_port = msg.msgh_local_port;
  }
  v6 = mach_msg(&msg, 3, 0x28u, 0x30u, reply_port, 0, 0);
  v7 = v6;
  if ((v6 - 268435458) <= 0xE && ((1 << (v6 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg.msgh_local_port);
    goto LABEL_28;
  }
  if (v6)
  {
    mig_dealloc_reply_port(msg.msgh_local_port);
    goto LABEL_27;
  }
  if (msg.msgh_id == 71)
  {
    v7 = -308;
  }
  else if (msg.msgh_id == 40307)
  {
    if ((msg.msgh_bits & 0x80000000) == 0)
    {
      if (msg.msgh_size == 40)
      {
        if (!msg.msgh_remote_port)
        {
          v7 = v14;
          if (!(_DWORD)v14)
          {
            v9 = DWORD1(v14);
            if (a1)
              return v9;
            goto LABEL_29;
          }
          goto LABEL_26;
        }
      }
      else if (msg.msgh_size == 36)
      {
        if (msg.msgh_remote_port)
          v8 = 1;
        else
          v8 = (_DWORD)v14 == 0;
        if (v8)
          v7 = -300;
        else
          v7 = v14;
        goto LABEL_26;
      }
    }
    v7 = -300;
  }
  else
  {
    v7 = -301;
  }
LABEL_26:
  mach_msg_destroy(&msg);
LABEL_27:
  if (v7 == -81182719)
  {
    x_log_crash("Unentitled call to server!");
    abort();
  }
LABEL_28:
  v9 = 0;
  if (!a1)
LABEL_29:
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
  return v9;
}

uint64_t CARenderServerRenderDisplay_(mach_port_t a1, const __CFString *a2, void *cf, int a4, int a5, int a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, int a11)
{
  CFTypeID v19;
  mach_port_t ServerPort;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  mach_port_t MachPort;
  uint64_t v30;
  double v31;
  int v32;
  mach_msg_size_t v34;
  char *v35;
  mach_port_t reply_port;
  mach_msg_return_t v37;
  int v38;
  uint64_t v39;
  BOOL v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  mach_port_t v49;
  char buffer[16];
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  mach_msg_header_t msg;
  int v67;
  uint64_t v68;
  uint64_t v69;
  mach_port_t v70;
  __int128 v71;
  _OWORD v72[26];
  uint64_t v73;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  v19 = CFGetTypeID(cf);
  if (v19 != IOSurfaceGetTypeID())
    return 0;
  v64 = 0u;
  v65 = 0u;
  v62 = 0u;
  v63 = 0u;
  v60 = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  *(_OWORD *)buffer = 0u;
  v51 = 0u;
  if (!a2)
    return 0;
  if (!CFStringGetCString(a2, buffer, 256, 0x8000100u))
    return 0;
  ServerPort = a1;
  if (!a1)
  {
    ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort)
      return 0;
  }
  v49 = ServerPort;
  v21 = 0uLL;
  v22 = 0uLL;
  v23 = 0uLL;
  v24 = 0uLL;
  v25 = 0uLL;
  v26 = 0uLL;
  v27 = 0uLL;
  v28 = 0uLL;
  if (a7)
  {
    v21 = *a7;
    v22 = a7[1];
    v23 = a7[2];
    v24 = a7[3];
    v25 = a7[4];
    v26 = a7[5];
    v27 = a7[6];
    v28 = a7[7];
  }
  v41 = v28;
  v42 = v27;
  v43 = v26;
  v44 = v25;
  v45 = v24;
  v46 = v23;
  v47 = v22;
  v48 = v21;
  MachPort = IOSurfaceCreateMachPort((IOSurfaceRef)cf);
  v30 = mach_absolute_time();
  v31 = CATimeWithHostTime(v30);
  v73 = 0;
  memset(v72, 0, sizeof(v72));
  v71 = 0u;
  memset(&msg, 0, sizeof(msg));
  v67 = 2;
  v68 = a10;
  HIDWORD(v69) = 4 * a9;
  LODWORD(v69) = 16777472;
  v70 = MachPort;
  DWORD1(v71) = 1245184;
  *((_QWORD *)&v71 + 1) = *MEMORY[0x1E0C804E8];
  if (MEMORY[0x1E0C84128])
    v32 = mig_strncpy_zerofill((char *)v72 + 8, buffer, 256);
  else
    v32 = mig_strncpy((char *)v72 + 8, buffer, 256);
  DWORD1(v72[0]) = v32;
  LODWORD(v72[0]) = 0;
  v34 = ((v32 + 3) & 0xFFFFFFFC) + 232;
  v35 = (char *)&msg + ((v32 + 3) & 0xFFFFFFFC);
  *((_DWORD *)v35 + 18) = a9;
  *((_DWORD *)v35 + 19) = a4;
  *((_DWORD *)v35 + 20) = a5;
  *((_DWORD *)v35 + 21) = a6;
  *((double *)v35 + 11) = v31;
  *((_OWORD *)v35 + 6) = v48;
  *((_OWORD *)v35 + 7) = v47;
  *((_OWORD *)v35 + 8) = v46;
  *((_OWORD *)v35 + 9) = v45;
  *((_OWORD *)v35 + 10) = v44;
  *((_OWORD *)v35 + 11) = v43;
  *((_OWORD *)v35 + 12) = v42;
  *((_OWORD *)v35 + 13) = v41;
  *((_DWORD *)v35 + 56) = a11;
  *((_DWORD *)v35 + 57) = a8;
  reply_port = mig_get_reply_port();
  msg.msgh_local_port = reply_port;
  msg.msgh_bits = -2147478253;
  msg.msgh_remote_port = v49;
  *(_QWORD *)&msg.msgh_voucher_port = 0x9D1C00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    reply_port = msg.msgh_local_port;
  }
  v37 = mach_msg(&msg, 3, v34, 0x34u, reply_port, 0, 0);
  v38 = v37;
  if ((v37 - 268435458) <= 0xE && ((1 << (v37 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg.msgh_local_port);
    v39 = 0;
    goto LABEL_17;
  }
  if (v37)
  {
    mig_dealloc_reply_port(msg.msgh_local_port);
    goto LABEL_40;
  }
  if (msg.msgh_id == 71)
  {
    v38 = -308;
  }
  else if (msg.msgh_id == 40320)
  {
    if ((msg.msgh_bits & 0x80000000) == 0)
    {
      if (msg.msgh_size == 44)
      {
        if (!msg.msgh_remote_port)
        {
          v38 = HIDWORD(v68);
          if (!HIDWORD(v68))
          {
            v39 = v69;
LABEL_17:
            mach_port_deallocate(*MEMORY[0x1E0C83DA0], MachPort);
            if (a1)
              goto LABEL_19;
            goto LABEL_18;
          }
          goto LABEL_39;
        }
      }
      else if (msg.msgh_size == 36)
      {
        if (msg.msgh_remote_port)
          v40 = 1;
        else
          v40 = HIDWORD(v68) == 0;
        if (v40)
          v38 = -300;
        else
          v38 = HIDWORD(v68);
        goto LABEL_39;
      }
    }
    v38 = -300;
  }
  else
  {
    v38 = -301;
  }
LABEL_39:
  mach_msg_destroy(&msg);
LABEL_40:
  mach_port_deallocate(*MEMORY[0x1E0C83DA0], MachPort);
  if (v38 == -81182719)
  {
    x_log_crash("Unentitled call to server!");
    abort();
  }
  v39 = 0;
  if (a1)
    goto LABEL_19;
LABEL_18:
  mach_port_deallocate(*MEMORY[0x1E0C83DA0], v49);
LABEL_19:
  if (v38)
    return 0;
  else
    return v39;
}

BOOL CARenderServerCaptureDisplayLayerWithTransformTimeOffsetAndFlags_(mach_port_t a1, CFStringRef theString, int a3, uint64_t a4, int a5, int a6, int a7, __int128 *a8, double a9, int a10)
{
  mach_port_t ServerPort;
  int v19;
  uint64_t v20;
  double v21;
  int v22;
  mach_msg_size_t v24;
  char *v25;
  mach_port_t reply_port;
  mach_msg_return_t v27;
  int v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  char buffer[16];
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  mach_msg_header_t msg;
  int v54;
  int v55;
  __int128 v56;
  _OWORD v57[27];
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (!theString)
    return 0;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  *(_OWORD *)buffer = 0u;
  v38 = 0u;
  if (!CFStringGetCString(theString, buffer, 256, 0x8000100u))
    return 0;
  ServerPort = a1;
  if (!a1)
  {
    ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort)
      return 0;
  }
  if ((a10 & 0x10) == 0)
    a4 = CA::Render::Object::render_id(*(CA::Render::Object **)(a4 + 16));
  v35 = a8[1];
  v36 = *a8;
  v33 = a8[3];
  v34 = a8[2];
  v31 = a8[5];
  v32 = a8[4];
  v29 = a8[7];
  v30 = a8[6];
  v19 = CA::MachPortUtil::task_identity_port(void)::task;
  if (!CA::MachPortUtil::task_identity_port(void)::task)
  {
    task_create_identity_token(*MEMORY[0x1E0C83DA0], (task_id_token_t *)&CA::MachPortUtil::task_identity_port(void)::task);
    v19 = CA::MachPortUtil::task_identity_port(void)::task;
  }
  v20 = mach_absolute_time();
  v21 = CATimeWithHostTime(v20) + a9;
  memset(v57, 0, 428);
  v56 = 0u;
  memset(&msg, 0, sizeof(msg));
  v54 = 1;
  v55 = v19;
  DWORD1(v56) = 1245184;
  *((_QWORD *)&v56 + 1) = *MEMORY[0x1E0C804E8];
  if (MEMORY[0x1E0C84128])
    v22 = mig_strncpy_zerofill((char *)v57 + 8, buffer, 256);
  else
    v22 = mig_strncpy((char *)v57 + 8, buffer, 256);
  DWORD1(v57[0]) = v22;
  LODWORD(v57[0]) = 0;
  v24 = ((v22 + 3) & 0xFFFFFFFC) + 220;
  v25 = (char *)&msg + ((v22 + 3) & 0xFFFFFFFC);
  *((_DWORD *)v25 + 14) = a3;
  *(_QWORD *)(v25 + 60) = a4;
  *((_DWORD *)v25 + 17) = a5;
  *((_DWORD *)v25 + 18) = a6;
  *((_DWORD *)v25 + 19) = a7;
  *((double *)v25 + 10) = v21;
  *(_OWORD *)(v25 + 88) = v36;
  *(_OWORD *)(v25 + 104) = v35;
  *(_OWORD *)(v25 + 120) = v34;
  *(_OWORD *)(v25 + 136) = v33;
  *(_OWORD *)(v25 + 152) = v32;
  *(_OWORD *)(v25 + 168) = v31;
  *(_OWORD *)(v25 + 184) = v30;
  *(_OWORD *)(v25 + 200) = v29;
  *((_DWORD *)v25 + 54) = a10;
  reply_port = mig_get_reply_port();
  msg.msgh_local_port = reply_port;
  msg.msgh_bits = -2147478253;
  msg.msgh_remote_port = ServerPort;
  *(_QWORD *)&msg.msgh_voucher_port = 0x9D2200000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    reply_port = msg.msgh_local_port;
  }
  v27 = mach_msg(&msg, 3, v24, 0x2Cu, reply_port, 0, 0);
  v28 = v27;
  if ((v27 - 268435458) <= 0xE && ((1 << (v27 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg.msgh_local_port);
    goto LABEL_31;
  }
  if (v27)
  {
    mig_dealloc_reply_port(msg.msgh_local_port);
    goto LABEL_30;
  }
  if (msg.msgh_id == 71)
  {
    v28 = -308;
LABEL_29:
    mach_msg_destroy(&msg);
LABEL_30:
    if (v28 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_31;
  }
  if (msg.msgh_id != 40326)
  {
    v28 = -301;
    goto LABEL_29;
  }
  v28 = -300;
  if ((msg.msgh_bits & 0x80000000) != 0)
    goto LABEL_29;
  if (msg.msgh_size != 36)
    goto LABEL_29;
  if (msg.msgh_remote_port)
    goto LABEL_29;
  v28 = v56;
  if ((_DWORD)v56)
    goto LABEL_29;
LABEL_31:
  if (!a1)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
  return v28 == 0;
}

BOOL CARenderServerCaptureDisplayWithTransform_(mach_port_t a1, CFStringRef theString, int a3, int a4, int a5, int a6, __int128 *a7, int a8, uint64_t a9, int a10)
{
  mach_port_t ServerPort;
  __int128 v18;
  int v20;
  uint64_t v21;
  double v22;
  int v23;
  mach_msg_size_t v24;
  char *v25;
  mach_port_t reply_port;
  mach_msg_return_t v27;
  int v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  char buffer[16];
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  mach_msg_header_t msg;
  int v54;
  uint64_t v55;
  int v56;
  int v57;
  int v58;
  __int128 v59;
  _OWORD v60[27];
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if (!theString)
    return 0;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  *(_OWORD *)buffer = 0u;
  v38 = 0u;
  if (!CFStringGetCString(theString, buffer, 256, 0x8000100u))
    return 0;
  ServerPort = a1;
  if (!a1)
  {
    ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort)
      return 0;
  }
  if (a7)
  {
    v35 = a7[1];
    v36 = *a7;
    v33 = a7[3];
    v34 = a7[2];
    v31 = a7[5];
    v32 = a7[4];
    v30 = a7[6];
    v18 = a7[7];
  }
  else
  {
    v18 = 0uLL;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v30 = 0u;
  }
  v29 = v18;
  v20 = CA::MachPortUtil::task_identity_port(void)::task;
  if (!CA::MachPortUtil::task_identity_port(void)::task)
  {
    task_create_identity_token(*MEMORY[0x1E0C83DA0], (task_id_token_t *)&CA::MachPortUtil::task_identity_port(void)::task);
    v20 = CA::MachPortUtil::task_identity_port(void)::task;
  }
  v21 = mach_absolute_time();
  v22 = CATimeWithHostTime(v21);
  memset(v60, 0, 428);
  v59 = 0u;
  memset(&msg, 0, sizeof(msg));
  v54 = 2;
  v55 = a9;
  v57 = 4 * a8;
  v56 = 16777472;
  v58 = v20;
  DWORD1(v59) = 1245184;
  *((_QWORD *)&v59 + 1) = *MEMORY[0x1E0C804E8];
  if (MEMORY[0x1E0C84128])
    v23 = mig_strncpy_zerofill((char *)v60 + 8, buffer, 256);
  else
    v23 = mig_strncpy((char *)v60 + 8, buffer, 256);
  DWORD1(v60[0]) = v23;
  LODWORD(v60[0]) = 0;
  v24 = ((v23 + 3) & 0xFFFFFFFC) + 236;
  v25 = (char *)&msg + ((v23 + 3) & 0xFFFFFFFC);
  *((_DWORD *)v25 + 18) = a8;
  *((_DWORD *)v25 + 19) = a3;
  *((_DWORD *)v25 + 20) = a4;
  *((_DWORD *)v25 + 21) = a5;
  *((_DWORD *)v25 + 22) = a6;
  *(double *)(v25 + 92) = v22;
  *(_OWORD *)(v25 + 100) = v36;
  *(_OWORD *)(v25 + 116) = v35;
  *(_OWORD *)(v25 + 132) = v34;
  *(_OWORD *)(v25 + 148) = v33;
  *(_OWORD *)(v25 + 164) = v32;
  *(_OWORD *)(v25 + 180) = v31;
  *(_OWORD *)(v25 + 196) = v30;
  *(_OWORD *)(v25 + 212) = v29;
  *((_DWORD *)v25 + 57) = a10;
  *((_DWORD *)v25 + 58) = 1024;
  reply_port = mig_get_reply_port();
  msg.msgh_local_port = reply_port;
  msg.msgh_bits = -2147478253;
  msg.msgh_remote_port = ServerPort;
  *(_QWORD *)&msg.msgh_voucher_port = 0x9D2300000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&msg);
    reply_port = msg.msgh_local_port;
  }
  v27 = mach_msg(&msg, 3, v24, 0x2Cu, reply_port, 0, 0);
  v28 = v27;
  if ((v27 - 268435458) <= 0xE && ((1 << (v27 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg.msgh_local_port);
    goto LABEL_32;
  }
  if (v27)
  {
    mig_dealloc_reply_port(msg.msgh_local_port);
    goto LABEL_31;
  }
  if (msg.msgh_id == 71)
  {
    v28 = -308;
LABEL_30:
    mach_msg_destroy(&msg);
LABEL_31:
    if (v28 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_32;
  }
  if (msg.msgh_id != 40327)
  {
    v28 = -301;
    goto LABEL_30;
  }
  v28 = -300;
  if ((msg.msgh_bits & 0x80000000) != 0)
    goto LABEL_30;
  if (msg.msgh_size != 36)
    goto LABEL_30;
  if (msg.msgh_remote_port)
    goto LABEL_30;
  v28 = HIDWORD(v55);
  if (HIDWORD(v55))
    goto LABEL_30;
LABEL_32:
  if (!a1)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
  return v28 == 0;
}

BOOL _CARenderServerCaptureDisplayContextList(mach_port_t a1, CFStringRef theString, int a3, uint64_t a4, int a5, int a6, int a7, unint64_t a8, uint64_t a9, int a10)
{
  uint64_t CString;
  mach_port_t v18;
  size_t v20;
  __int128 *v21;
  _OWORD *v22;
  unint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  int v31;
  uint64_t v32;
  double v33;
  int v34;
  mach_port_t v35;
  uint64_t v36;
  mach_msg_size_t v37;
  char *v38;
  mach_port_t reply_port;
  mach_msg_return_t v40;
  int v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  mach_port_t v45;
  char *v46;
  _OWORD v47[16];
  mach_msg_header_t v48;
  int v49;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  char *v56;
  __int128 v57;
  _DWORD v58[72];
  uint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  if (!theString)
    return 0;
  memset(v47, 0, sizeof(v47));
  CString = CFStringGetCString(theString, (char *)v47, 256, 0x8000100u);
  if (!(_DWORD)CString)
    return 0;
  v18 = a1;
  if (!a1)
  {
    CString = CARenderServerGetServerPort(0);
    v18 = CString;
    if (!(_DWORD)CString)
      return 0;
  }
  if (a8 >> 57)
    return 0;
  v44 = a8 << 7;
  if (a8 << 7 > 0x1000)
  {
    v46 = (char *)malloc_type_malloc(a8 << 7, 0xD2115DE8uLL);
  }
  else
  {
    MEMORY[0x1E0C80A78](CString);
    v46 = (char *)&v43 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v46, v20);
  }
  v45 = v18;
  if (a8)
  {
    v21 = (__int128 *)(a9 + 64);
    v22 = v46 + 64;
    v23 = a8;
    do
    {
      v24 = *(v21 - 3);
      v25 = *(v21 - 2);
      v26 = *(v21 - 1);
      v27 = *v21;
      v28 = v21[1];
      v29 = v21[2];
      v30 = v21[3];
      *(v22 - 4) = *(v21 - 4);
      *(v22 - 3) = v24;
      *(v22 - 2) = v25;
      *(v22 - 1) = v26;
      *v22 = v27;
      v22[1] = v28;
      v21 += 8;
      v22[2] = v29;
      v22[3] = v30;
      v22 += 8;
      --v23;
    }
    while (v23);
  }
  v31 = CA::MachPortUtil::task_identity_port(void)::task;
  if (!CA::MachPortUtil::task_identity_port(void)::task)
  {
    task_create_identity_token(*MEMORY[0x1E0C83DA0], (task_id_token_t *)&CA::MachPortUtil::task_identity_port(void)::task);
    v31 = CA::MachPortUtil::task_identity_port(void)::task;
  }
  v32 = mach_absolute_time();
  v33 = CATimeWithHostTime(v32);
  v59 = 0;
  memset(v58, 0, sizeof(v58));
  v54 = 0;
  v57 = 0u;
  memset(&v48, 0, sizeof(v48));
  v49 = 3;
  v50 = a4;
  v52 = 4 * a3;
  v51 = 16777472;
  v53 = v31;
  v55 = 1245184;
  v56 = v46;
  DWORD1(v57) = (_DWORD)a8 << 7;
  LODWORD(v57) = 16777472;
  *((_QWORD *)&v57 + 1) = *MEMORY[0x1E0C804E8];
  if (MEMORY[0x1E0C84128])
    v34 = mig_strncpy_zerofill((char *)&v58[2], (const char *)v47, 256);
  else
    v34 = mig_strncpy((char *)&v58[2], (const char *)v47, 256);
  v35 = v45;
  v58[1] = v34;
  v58[0] = 0;
  v36 = (v34 + 3) & 0xFFFFFFFC;
  v37 = v36 + 120;
  v38 = (char *)&v48 + v36;
  *((_DWORD *)v38 + 22) = a3;
  *((_DWORD *)v38 + 23) = a5;
  *((_DWORD *)v38 + 24) = a6;
  *((_DWORD *)v38 + 25) = a7;
  *((double *)v38 + 13) = v33;
  *((_DWORD *)v38 + 28) = a8;
  *((_DWORD *)v38 + 29) = a10;
  reply_port = mig_get_reply_port();
  v48.msgh_local_port = reply_port;
  v48.msgh_bits = -2147478253;
  v48.msgh_remote_port = v35;
  *(_QWORD *)&v48.msgh_voucher_port = 0x9D2400000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&v48);
    reply_port = v48.msgh_local_port;
  }
  v40 = mach_msg(&v48, 3, v37, 0x2Cu, reply_port, 0, 0);
  v41 = v40;
  if ((v40 - 268435458) > 0xE || ((1 << (v40 - 2)) & 0x4003) == 0)
  {
    if (v40)
    {
      mig_dealloc_reply_port(v48.msgh_local_port);
    }
    else
    {
      if (v48.msgh_id == 71)
      {
        v41 = -308;
      }
      else if (v48.msgh_id == 40328)
      {
        v41 = -300;
        if ((v48.msgh_bits & 0x80000000) == 0 && v48.msgh_size == 36 && !v48.msgh_remote_port)
        {
          v41 = HIDWORD(v50);
          if (!HIDWORD(v50))
            goto LABEL_23;
        }
      }
      else
      {
        v41 = -301;
      }
      mach_msg_destroy(&v48);
    }
    v42 = v44;
    if (v41 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_37;
  }
  mig_put_reply_port(v48.msgh_local_port);
LABEL_23:
  v42 = v44;
LABEL_37:
  if (v42 > 0x1000)
    free(v46);
  if (!a1)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v35);
  return v41 == 0;
}

uint64_t _CARenderServerRenderDisplayContextList(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, void *cf, int a6, int a7, unint64_t a8, uint64_t a9, int a10)
{
  CFTypeID v18;
  uint64_t CString;
  mach_port_t v20;
  size_t v22;
  __int128 *v23;
  _OWORD *v24;
  unint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  mach_port_t MachPort;
  uint64_t v34;
  double v35;
  mach_port_name_t v36;
  int v37;
  uint64_t v38;
  mach_msg_size_t v39;
  char *v40;
  mach_port_t reply_port;
  mach_msg_return_t v42;
  int v43;
  uint64_t v44;
  BOOL v45;
  unint64_t v46;
  char *v47;
  _OWORD v48[16];
  mach_msg_header_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  mach_port_t v53;
  int v54;
  int v55;
  char *v56;
  __int128 v57;
  _DWORD v58[74];
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v18 = CFGetTypeID(cf);
  if (v18 != IOSurfaceGetTypeID())
    return 0;
  memset(v48, 0, sizeof(v48));
  if (!a2)
    return 0;
  CString = CFStringGetCString(a2, (char *)v48, 256, 0x8000100u);
  if (!(_DWORD)CString)
    return 0;
  v20 = a1;
  if (!a1)
  {
    CString = CARenderServerGetServerPort(0);
    v20 = CString;
    if (!(_DWORD)CString)
      return 0;
  }
  if (a8 >> 57)
    return 0;
  v46 = a8 << 7;
  if (a8 << 7 > 0x1000)
  {
    v47 = (char *)malloc_type_malloc(a8 << 7, 0x140AC244uLL);
  }
  else
  {
    MEMORY[0x1E0C80A78](CString);
    v47 = (char *)&v46 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v47, v22);
  }
  if (a8)
  {
    v23 = (__int128 *)(a9 + 64);
    v24 = v47 + 64;
    v25 = a8;
    do
    {
      v26 = *(v23 - 3);
      v27 = *(v23 - 2);
      v28 = *(v23 - 1);
      v29 = *v23;
      v30 = v23[1];
      v31 = v23[2];
      v32 = v23[3];
      *(v24 - 4) = *(v23 - 4);
      *(v24 - 3) = v26;
      *(v24 - 2) = v27;
      *(v24 - 1) = v28;
      *v24 = v29;
      v24[1] = v30;
      v23 += 8;
      v24[2] = v31;
      v24[3] = v32;
      v24 += 8;
      --v25;
    }
    while (v25);
  }
  MachPort = IOSurfaceCreateMachPort((IOSurfaceRef)cf);
  v34 = mach_absolute_time();
  v35 = CATimeWithHostTime(v34);
  memset(v58, 0, 292);
  v54 = 0;
  v57 = 0u;
  memset(&v49, 0, sizeof(v49));
  v50 = 3;
  v51 = a4;
  v36 = MachPort;
  HIDWORD(v52) = 4 * a3;
  LODWORD(v52) = 16777472;
  v53 = MachPort;
  v55 = 1245184;
  v56 = v47;
  DWORD1(v57) = (_DWORD)a8 << 7;
  LODWORD(v57) = 16777472;
  *((_QWORD *)&v57 + 1) = *MEMORY[0x1E0C804E8];
  if (MEMORY[0x1E0C84128])
    v37 = mig_strncpy_zerofill((char *)&v58[2], (const char *)v48, 256);
  else
    v37 = mig_strncpy((char *)&v58[2], (const char *)v48, 256);
  v58[1] = v37;
  v58[0] = 0;
  v38 = (v37 + 3) & 0xFFFFFFFC;
  v39 = v38 + 116;
  v40 = (char *)&v49 + v38;
  *((_DWORD *)v40 + 22) = a3;
  *((_DWORD *)v40 + 23) = a6;
  *((_DWORD *)v40 + 24) = a7;
  *(double *)(v40 + 100) = v35;
  *((_DWORD *)v40 + 27) = a8;
  *((_DWORD *)v40 + 28) = a10;
  reply_port = mig_get_reply_port();
  v49.msgh_local_port = reply_port;
  v49.msgh_bits = -2147478253;
  v49.msgh_remote_port = v20;
  *(_QWORD *)&v49.msgh_voucher_port = 0x9D2000000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set(&v49);
    reply_port = v49.msgh_local_port;
  }
  v42 = mach_msg(&v49, 3, v39, 0x34u, reply_port, 0, 0);
  v43 = v42;
  if ((v42 - 268435458) > 0xE || ((1 << (v42 - 2)) & 0x4003) == 0)
  {
    if (v42)
    {
      mig_dealloc_reply_port(v49.msgh_local_port);
LABEL_41:
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], v36);
      if (v43 == -81182719)
      {
        x_log_crash("Unentitled call to server!");
        abort();
      }
      v44 = 0;
      goto LABEL_43;
    }
    if (v49.msgh_id == 71)
    {
      v43 = -308;
    }
    else if (v49.msgh_id == 40324)
    {
      if ((v49.msgh_bits & 0x80000000) == 0)
      {
        if (v49.msgh_size == 44)
        {
          if (!v49.msgh_remote_port)
          {
            v43 = HIDWORD(v51);
            if (!HIDWORD(v51))
            {
              v44 = v52;
              goto LABEL_22;
            }
            goto LABEL_40;
          }
        }
        else if (v49.msgh_size == 36)
        {
          if (v49.msgh_remote_port)
            v45 = 1;
          else
            v45 = HIDWORD(v51) == 0;
          if (v45)
            v43 = -300;
          else
            v43 = HIDWORD(v51);
          goto LABEL_40;
        }
      }
      v43 = -300;
    }
    else
    {
      v43 = -301;
    }
LABEL_40:
    mach_msg_destroy(&v49);
    goto LABEL_41;
  }
  mig_put_reply_port(v49.msgh_local_port);
  v44 = 0;
LABEL_22:
  mach_port_deallocate(*MEMORY[0x1E0C83DA0], v36);
LABEL_43:
  if (v46 > 0x1000)
    free(v47);
  if (!a1)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v20);
  if (v43)
    return 0;
  else
    return v44;
}

BOOL CARenderServerRenderLayer(mach_port_t a1, int a2, uint64_t a3, void *cf, int a5, int a6)
{
  return CARenderServerRenderDisplayLayerWithTransformTimeOffsetAndFlags_(a1, CFSTR("defaultDisplay"), a2, a3, cf, a5, a6, (__int128 *)&CATransform3DIdentity, 0.0, 0) != 0;
}

BOOL CARenderServerRenderDisplayLayerWithTransformTimeOffsetAndFlags(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, void *a5, int a6, int a7, __int128 *a8, double a9, int a10)
{
  return CARenderServerRenderDisplayLayerWithTransformTimeOffsetAndFlags_(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) != 0;
}

BOOL CARenderServerRenderLayerWithTransform(mach_port_t a1, int a2, uint64_t a3, void *cf, int a5, int a6, __int128 *a7)
{
  return CARenderServerRenderDisplayLayerWithTransformTimeOffsetAndFlags_(a1, CFSTR("defaultDisplay"), a2, a3, cf, a5, a6, a7, 0.0, 0) != 0;
}

BOOL CARenderServerRenderLayerWithTransformAndTimeOffset(mach_port_t a1, int a2, uint64_t a3, void *cf, int a5, int a6, __int128 *a7, double a8)
{
  return CARenderServerRenderDisplayLayerWithTransformTimeOffsetAndFlags_(a1, CFSTR("defaultDisplay"), a2, a3, cf, a5, a6, a7, a8, 0) != 0;
}

BOOL CARenderServerRenderDisplay(mach_port_t a1, const __CFString *a2, void *a3, int a4, int a5)
{
  return CARenderServerRenderDisplay_(a1, a2, a3, 0, a4, a5, 0, 0, 0, 0, 0) != 0;
}

BOOL CARenderServerRenderDisplayClientList(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, void *a5, int a6, int a7)
{
  return _CARenderServerRenderDisplayContextList(a1, a2, a3, a4, a5, a6, a7, 1uLL, (uint64_t)&CATransform3DIdentity, 0) != 0;
}

BOOL CARenderServerRenderDisplayClientListWithTransform(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, void *a5, int a6, int a7, uint64_t a8)
{
  return _CARenderServerRenderDisplayContextList(a1, a2, a3, a4, a5, a6, a7, 1uLL, a8, 0) != 0;
}

BOOL CARenderServerRenderDisplayClientListWithTransformList(mach_port_t a1, const __CFString *a2, unint64_t a3, uint64_t a4, void *a5, int a6, int a7, uint64_t a8)
{
  return _CARenderServerRenderDisplayContextList(a1, a2, a3, a4, a5, a6, a7, a3, a8, 0) != 0;
}

BOOL CARenderServerRenderDisplayLayerWithTransformAndTimeOffset(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, void *a5, int a6, int a7, __int128 *a8, double a9)
{
  return CARenderServerRenderDisplayLayerWithTransformTimeOffsetAndFlags_(a1, a2, a3, a4, a5, a6, a7, a8, a9, 0) != 0;
}

BOOL CARenderServerCaptureLayer(mach_port_t a1, int a2, uint64_t a3, int a4, int a5, int a6)
{
  return CARenderServerCaptureDisplayLayerWithTransformTimeOffsetAndFlags_(a1, CFSTR("defaultDisplay"), a2, a3, a4, a5, a6, (__int128 *)&CATransform3DIdentity, 0.0, 1024);
}

BOOL CARenderServerCaptureDisplayLayerWithTransformTimeOffsetAndFlags(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, int a5, int a6, int a7, __int128 *a8, double a9, int a10)
{
  return CARenderServerCaptureDisplayLayerWithTransformTimeOffsetAndFlags_(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 | 0x400);
}

BOOL CARenderServerCaptureLayerWithTransform(mach_port_t a1, int a2, uint64_t a3, int a4, int a5, int a6, __int128 *a7)
{
  return CARenderServerCaptureDisplayLayerWithTransformTimeOffsetAndFlags_(a1, CFSTR("defaultDisplay"), a2, a3, a4, a5, a6, a7, 0.0, 1024);
}

BOOL CARenderServerCaptureLayerWithTransformAndTimeOffset(mach_port_t a1, int a2, uint64_t a3, int a4, int a5, int a6, __int128 *a7, double a8)
{
  return CARenderServerCaptureDisplayLayerWithTransformTimeOffsetAndFlags_(a1, CFSTR("defaultDisplay"), a2, a3, a4, a5, a6, a7, a8, 1024);
}

BOOL CARenderServerCaptureDisplay(mach_port_t a1, const __CFString *a2, int a3, int a4, int a5)
{
  return CARenderServerCaptureDisplayWithTransform_(a1, a2, a3, 0, a4, a5, 0, 0, 0, 0);
}

BOOL CARenderServerCaptureDisplayWithTransform(mach_port_t a1, const __CFString *a2, int a3, int a4, int a5, __int128 *a6)
{
  return CARenderServerCaptureDisplayWithTransform_(a1, a2, a3, 0, a4, a5, a6, 0, 0, 0);
}

BOOL CARenderServerCaptureDisplayClientList(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, int a5, int a6, int a7)
{
  return _CARenderServerCaptureDisplayContextList(a1, a2, a3, a4, a5, a6, a7, 1uLL, (uint64_t)&CATransform3DIdentity, 1024);
}

BOOL CARenderServerCaptureDisplayClientListWithTransform(mach_port_t a1, const __CFString *a2, int a3, uint64_t a4, int a5, int a6, int a7, uint64_t a8)
{
  return _CARenderServerCaptureDisplayContextList(a1, a2, a3, a4, a5, a6, a7, 1uLL, a8, 1024);
}

BOOL CARenderServerCaptureDisplayClientListWithTransformList(mach_port_t a1, const __CFString *a2, unint64_t a3, uint64_t a4, int a5, int a6, int a7, uint64_t a8)
{
  return _CARenderServerCaptureDisplayContextList(a1, a2, a3, a4, a5, a6, a7, a3, a8, 1024);
}

void CARenderServerSetCacheAsynchronousSurfaces(int a1, int a2)
{
  int ServerPort;
  mach_port_t reply_port;
  mach_msg_return_t v5;
  _BYTE msg[36];
  uint64_t v7;
  uint64_t v8;

  ServerPort = a1;
  v8 = *MEMORY[0x1E0C80C00];
  if (a1 || (ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    memset(&msg[4], 0, 32);
    v7 = 0;
    *(_QWORD *)&msg[24] = *MEMORY[0x1E0C804E8];
    *(_DWORD *)&msg[32] = a2;
    reply_port = mig_get_reply_port();
    *(_DWORD *)&msg[8] = ServerPort;
    *(_DWORD *)&msg[12] = reply_port;
    *(_DWORD *)msg = 5395;
    *(_QWORD *)&msg[16] = 0x9D2500000000;
    if (MEMORY[0x1E0C85B60])
    {
      voucher_mach_msg_set((mach_msg_header_t *)msg);
      reply_port = *(_DWORD *)&msg[12];
    }
    v5 = mach_msg((mach_msg_header_t *)msg, 3, 0x24u, 0x2Cu, reply_port, 0, 0);
    if ((v5 - 268435458) <= 0xE && ((1 << (v5 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(*(mach_port_t *)&msg[12]);
    }
    else if (v5)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    }
    else if (*(_DWORD *)&msg[20] != 40329
           || (*(_DWORD *)msg & 0x80000000) != 0
           || *(_DWORD *)&msg[4] != 36
           || *(_DWORD *)&msg[8]
           || *(_DWORD *)&msg[32])
    {
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
  }
}

void CARenderServerFlushIRDC(mach_port_t ServerPort)
{
  mach_msg_header_t v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  if (CADeviceNeedsIRDCFlush::once != -1)
    dispatch_once(&CADeviceNeedsIRDCFlush::once, &__block_literal_global_288);
  if (CADeviceNeedsIRDCFlush::b)
  {
    if (ServerPort || (ServerPort = CARenderServerGetServerPort(0)) != 0)
    {
      v2.msgh_size = 0;
      v2.msgh_bits = 19;
      v2.msgh_remote_port = ServerPort;
      v2.msgh_local_port = 0;
      *(_QWORD *)&v2.msgh_voucher_port = 0x9D2600000000;
      if (MEMORY[0x1E0C85B60])
        voucher_mach_msg_set(&v2);
      mach_msg(&v2, 1, 0x18u, 0, 0, 0, 0);
    }
  }
}

void CARenderServerPostPowerLog(mach_port_name_t a1)
{
  mach_port_name_t ServerPort;
  mach_port_t reply_port;
  mach_msg_return_t v4;
  int v5;
  _BYTE msg[36];
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (a1 || (ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    v7 = 0;
    *(_DWORD *)&msg[4] = 0;
    *(_OWORD *)&msg[20] = 0u;
    reply_port = mig_get_reply_port();
    *(_DWORD *)&msg[8] = ServerPort;
    *(_DWORD *)&msg[12] = reply_port;
    *(_DWORD *)msg = 5395;
    *(_QWORD *)&msg[16] = 0x9D3F00000000;
    if (MEMORY[0x1E0C85B60])
    {
      voucher_mach_msg_set((mach_msg_header_t *)msg);
      reply_port = *(_DWORD *)&msg[12];
    }
    v4 = mach_msg((mach_msg_header_t *)msg, 3, 0x18u, 0x2Cu, reply_port, 0, 0);
    v5 = v4;
    if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(*(mach_port_t *)&msg[12]);
LABEL_21:
      if (!a1)
        mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
      return;
    }
    if (v4)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    }
    else
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v5 = -308;
      }
      else if (*(_DWORD *)&msg[20] == 40355)
      {
        v5 = -300;
        if ((*(_DWORD *)msg & 0x80000000) == 0 && *(_DWORD *)&msg[4] == 36 && !*(_DWORD *)&msg[8])
        {
          v5 = *(_DWORD *)&msg[32];
          if (!*(_DWORD *)&msg[32])
            goto LABEL_21;
        }
      }
      else
      {
        v5 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
    if (v5 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_21;
  }
}

void CARenderServerPurgeServer(mach_port_name_t a1)
{
  mach_port_name_t ServerPort;
  mach_port_t reply_port;
  mach_msg_return_t v4;
  int v5;
  _BYTE msg[36];
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (a1 || (ServerPort = CARenderServerGetServerPort(0)) != 0)
  {
    v7 = 0;
    *(_DWORD *)&msg[4] = 0;
    *(_OWORD *)&msg[20] = 0u;
    reply_port = mig_get_reply_port();
    *(_DWORD *)&msg[8] = ServerPort;
    *(_DWORD *)&msg[12] = reply_port;
    *(_DWORD *)msg = 5395;
    *(_QWORD *)&msg[16] = 0x9D3C00000000;
    if (MEMORY[0x1E0C85B60])
    {
      voucher_mach_msg_set((mach_msg_header_t *)msg);
      reply_port = *(_DWORD *)&msg[12];
    }
    v4 = mach_msg((mach_msg_header_t *)msg, 3, 0x18u, 0x2Cu, reply_port, 0, 0);
    v5 = v4;
    if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(*(mach_port_t *)&msg[12]);
LABEL_21:
      if (!a1)
        mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
      return;
    }
    if (v4)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    }
    else
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v5 = -308;
      }
      else if (*(_DWORD *)&msg[20] == 40352)
      {
        v5 = -300;
        if ((*(_DWORD *)msg & 0x80000000) == 0 && *(_DWORD *)&msg[4] == 36 && !*(_DWORD *)&msg[8])
        {
          v5 = *(_DWORD *)&msg[32];
          if (!*(_DWORD *)&msg[32])
            goto LABEL_21;
        }
      }
      else
      {
        v5 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
    if (v5 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
    goto LABEL_21;
  }
}

CFPropertyListRef CARenderServerGetPerformanceInfo(mach_port_name_t a1)
{
  mach_port_name_t ServerPort;
  mach_port_t reply_port;
  mach_msg_return_t v4;
  int v5;
  unsigned int v6;
  const UInt8 *v7;
  const __CFAllocator *v8;
  const __CFData *v9;
  CFPropertyListRef v10;
  int msg;
  int msg_4;
  mach_port_name_t msg_8;
  mach_port_t msg_12;
  _BYTE msg_16[48];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  ServerPort = a1;
  if (!a1)
  {
    ServerPort = CARenderServerGetServerPort(0);
    if (!ServerPort)
      return 0;
  }
  memset(&msg_16[4], 0, 44);
  msg_4 = 0;
  reply_port = mig_get_reply_port();
  msg_8 = ServerPort;
  msg_12 = reply_port;
  msg = 5395;
  *(_QWORD *)msg_16 = 0x9D4000000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    reply_port = msg_12;
  }
  v4 = mach_msg((mach_msg_header_t *)&msg, 3, 0x18u, 0x40u, reply_port, 0, 0);
  v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg_12);
  }
  else
  {
    if (v4)
    {
      mig_dealloc_reply_port(msg_12);
    }
    else
    {
      if (*(_DWORD *)&msg_16[4] == 71)
      {
        v5 = -308;
      }
      else if (*(_DWORD *)&msg_16[4] == 40356)
      {
        if (msg < 0)
        {
          v5 = -300;
          if (*(_DWORD *)&msg_16[8] == 1 && msg_4 == 56 && !msg_8 && msg_16[23] == 1)
          {
            v6 = *(_DWORD *)&msg_16[24];
            if (*(_DWORD *)&msg_16[24] == *(_DWORD *)&msg_16[36])
            {
              v5 = 0;
              v7 = *(const UInt8 **)&msg_16[12];
              goto LABEL_30;
            }
          }
        }
        else if (msg_4 == 36)
        {
          v5 = -300;
          if (*(_DWORD *)&msg_16[16])
          {
            if (msg_8)
              v5 = -300;
            else
              v5 = *(_DWORD *)&msg_16[16];
          }
        }
        else
        {
          v5 = -300;
        }
      }
      else
      {
        v5 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)&msg);
    }
    if (v5 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
  }
  v7 = 0;
  v6 = 0;
LABEL_30:
  if (!a1)
  {
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], ServerPort);
    if (!v5)
      goto LABEL_34;
    return 0;
  }
  if (v5)
    return 0;
LABEL_34:
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE18];
  v9 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE18], v7, v6);
  mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)v7, v6);
  if (!v9)
    return 0;
  v10 = CFPropertyListCreateWithData(v8, v9, 0, 0, 0);
  CFRelease(v9);
  return v10;
}

uint64_t CARenderServerGetDisplayLogicalBounds(int a1, int a2, void *a3)
{
  int v5;
  uint64_t result;
  mach_port_t reply_port;
  mach_msg_return_t v8;
  int v9;
  unsigned int v10;
  const void *v11;
  mach_vm_size_t v12;
  int msg;
  _BYTE msg_4[60];
  uint64_t v15;

  v5 = a1;
  v15 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    result = CARenderServerGetServerPort(0);
    v5 = result;
    if (!(_DWORD)result)
      return result;
  }
  memset(&msg_4[16], 0, 44);
  *(_OWORD *)msg_4 = 0u;
  *(_QWORD *)&msg_4[20] = *MEMORY[0x1E0C804E8];
  *(_DWORD *)&msg_4[28] = a2;
  reply_port = mig_get_reply_port();
  *(_DWORD *)&msg_4[4] = v5;
  *(_DWORD *)&msg_4[8] = reply_port;
  msg = 5395;
  *(_QWORD *)&msg_4[12] = 0x9D2A00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&msg);
    reply_port = *(_DWORD *)&msg_4[8];
  }
  v8 = mach_msg((mach_msg_header_t *)&msg, 3, 0x24u, 0x40u, reply_port, 0, 0);
  v9 = v8;
  if ((v8 - 268435458) <= 0xE && ((1 << (v8 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg_4[8]);
  }
  else
  {
    if (v8)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg_4[8]);
    }
    else
    {
      if (*(_DWORD *)&msg_4[16] == 71)
      {
        v9 = -308;
      }
      else if (*(_DWORD *)&msg_4[16] == 40334)
      {
        if (msg < 0)
        {
          v9 = -300;
          if (*(_DWORD *)&msg_4[20] == 1 && *(_DWORD *)msg_4 == 56 && !*(_DWORD *)&msg_4[4] && msg_4[35] == 1)
          {
            v10 = *(_DWORD *)&msg_4[36];
            if (*(_DWORD *)&msg_4[36] == *(_DWORD *)&msg_4[48])
            {
              v9 = 0;
              v11 = *(const void **)&msg_4[24];
              goto LABEL_30;
            }
          }
        }
        else if (*(_DWORD *)msg_4 == 36)
        {
          v9 = -300;
          if (*(_DWORD *)&msg_4[28])
          {
            if (*(_DWORD *)&msg_4[4])
              v9 = -300;
            else
              v9 = *(_DWORD *)&msg_4[28];
          }
        }
        else
        {
          v9 = -300;
        }
      }
      else
      {
        v9 = -301;
      }
      mach_msg_destroy((mach_msg_header_t *)&msg);
    }
    if (v9 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
  }
  v11 = 0;
  v10 = 0;
LABEL_30:
  result = v9 == 0;
  if (a3)
  {
    if (!v9)
    {
      v12 = v10;
      memcpy(a3, v11, v10);
      mach_vm_deallocate(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)v11, v12);
      return 1;
    }
  }
  return result;
}

uint64_t CARenderServerGetVsyncOffSupportsRGBCompression(mach_port_t a1)
{
  mach_port_t v1;
  uint64_t result;
  mach_port_t reply_port;
  mach_msg_return_t v4;
  mach_msg_header_t msg[2];
  uint64_t v6;

  v1 = a1;
  v6 = *MEMORY[0x1E0C80C00];
  if (a1 || (result = CARenderServerGetServerPort(0), (v1 = result) != 0))
  {
    *(_OWORD *)&msg[1].msgh_remote_port = 0u;
    *(_OWORD *)&msg[0].msgh_id = 0u;
    msg[0].msgh_size = 0;
    reply_port = mig_get_reply_port();
    msg[0].msgh_remote_port = v1;
    msg[0].msgh_local_port = reply_port;
    msg[0].msgh_bits = 5395;
    *(_QWORD *)&msg[0].msgh_voucher_port = 0x9D2C00000000;
    if (MEMORY[0x1E0C85B60])
    {
      voucher_mach_msg_set(msg);
      reply_port = msg[0].msgh_local_port;
    }
    v4 = mach_msg(msg, 3, 0x18u, 0x30u, reply_port, 0, 0);
    if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(msg[0].msgh_local_port);
    }
    else if (v4)
    {
      mig_dealloc_reply_port(msg[0].msgh_local_port);
    }
    else
    {
      if (msg[0].msgh_id == 40336
        && (msg[0].msgh_bits & 0x80000000) == 0
        && msg[0].msgh_size == 40
        && !msg[0].msgh_remote_port
        && !msg[1].msgh_remote_port)
      {
        return LOBYTE(msg[1].msgh_local_port) != 0;
      }
      mach_msg_destroy(msg);
    }
    return 0;
  }
  return result;
}

BOOL CARenderServerIsRunning()
{
  return CA::Render::Server::_thread != 0;
}

void CARenderServerSetRootQueue(uint64_t a1)
{
  _QWORD v1[6];

  v1[5] = *MEMORY[0x1E0C80C00];
  v1[0] = MEMORY[0x1E0C809B0];
  v1[1] = 3221225472;
  v1[2] = __CASetRootQueue_block_invoke;
  v1[3] = &unk_1E15ABB78;
  v1[4] = a1;
  if (CA::_root_queue_once != -1)
    dispatch_once(&CA::_root_queue_once, v1);
}

CFDataRef CARenderClientGetArchivedLayerTree(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  ipc_space_t *v4;
  kern_return_t v5;
  mach_error_t v6;
  mach_msg_return_t v7;
  NSObject *v8;
  char *v9;
  CFDataRef v10;
  const __CFAllocator *v12;
  CFAllocatorContext context;
  mach_port_name_t name;
  _BYTE msg[36];
  int v16;
  CFIndex length;
  int v18;
  uint64_t v19;

  MEMORY[0x1E0C80A78](a1);
  v19 = *MEMORY[0x1E0C80C00];
  if (v1)
  {
    v2 = v1;
    v3 = BYTE1(xmmword_1ECDC6AD0);
    name = 0;
    v4 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
    v5 = mach_port_allocate(*MEMORY[0x1E0C83DA0], 1u, &name);
    if (v5)
    {
      v6 = v5;
      if (x_log_hook_p())
      {
        mach_error_string(v6);
        x_log_();
      }
      else
      {
        v8 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
        {
          v9 = mach_error_string(v6);
          *(_DWORD *)msg = 136315394;
          *(_QWORD *)&msg[4] = v9;
          *(_WORD *)&msg[12] = 1024;
          *(_DWORD *)&msg[14] = v6;
          _os_log_impl(&dword_184457000, v8, OS_LOG_TYPE_ERROR, "Failed to allocate reply port: %s [0x%x]", msg, 0x12u);
        }
      }
      return 0;
    }
    *(_OWORD *)&msg[20] = 0u;
    *(_DWORD *)&msg[28] = name;
    v16 = 1376256;
    *(_OWORD *)&msg[4] = 0u;
    length = *MEMORY[0x1E0C804E8];
    v18 = v3;
    *(_DWORD *)msg = -2147483629;
    *(_DWORD *)&msg[8] = v2;
    *(_QWORD *)&msg[20] = 0x100009DDALL;
    if (MEMORY[0x1E0C85B60])
      voucher_mach_msg_set((mach_msg_header_t *)msg);
    v7 = mach_msg((mach_msg_header_t *)msg, 17, 0x34u, 0, 0, 0, 0);
    if ((v7 - 268435459) > 1)
    {
      if (!v7)
      {
        bzero(msg, 0x1000uLL);
        v10 = 0;
        if (mach_msg((mach_msg_header_t *)msg, 2, 0, 0x1000u, name, 0, 0))
          goto LABEL_16;
        if (*(_DWORD *)&msg[20] != 1195461716)
          goto LABEL_16;
        v10 = 0;
        if ((*(_DWORD *)msg & 0x80000000) == 0 || *(_DWORD *)&msg[24] != 1)
          goto LABEL_16;
        if (HIBYTE(v16) == 1)
        {
          context.version = 0;
          memset(&context.retain, 0, 40);
          context.info = (void *)length;
          context.deallocate = (CFAllocatorDeallocateCallBack)deallocate_vm_region;
          context.preferredSize = 0;
          v12 = CFAllocatorCreate(0, &context);
          v10 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)&msg[28], length, v12);
          CFRelease(v12);
          goto LABEL_16;
        }
      }
    }
    else
    {
      if ((*(_WORD *)msg & 0x1F00) == 0x1100)
        mach_port_deallocate(*v4, *(mach_port_name_t *)&msg[12]);
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
    v10 = 0;
LABEL_16:
    mach_port_mod_refs(*v4, name, 1u, -1);
    return v10;
  }
  return 0;
}

uint64_t deallocate_vm_region(mach_vm_address_t address, mach_vm_size_t size)
{
  return mach_vm_deallocate(*MEMORY[0x1E0C83DA0], address, size);
}

CFDataRef CARenderServerGetLocalArchivedLayerTree(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  int v4;
  int v5;
  ipc_space_t *v6;
  kern_return_t v7;
  mach_error_t v8;
  CFDataRef v9;
  NSObject *v10;
  char *v11;
  const __CFAllocator *v13;
  CFAllocatorContext context;
  mach_port_name_t name;
  _BYTE msg[36];
  int v17;
  CFIndex length;
  int v19;
  int v20;
  uint64_t v21;

  MEMORY[0x1E0C80A78](a1);
  v21 = *MEMORY[0x1E0C80C00];
  if (!v1)
    return 0;
  v3 = v2;
  v4 = v1;
  v5 = BYTE1(xmmword_1ECDC6AD0);
  name = 0;
  v6 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  v7 = mach_port_allocate(*MEMORY[0x1E0C83DA0], 1u, &name);
  if (v7)
  {
    v8 = v7;
    if (x_log_hook_p())
    {
      mach_error_string(v8);
      x_log_();
    }
    else
    {
      v10 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        v11 = mach_error_string(v8);
        *(_DWORD *)msg = 136315394;
        *(_QWORD *)&msg[4] = v11;
        *(_WORD *)&msg[12] = 1024;
        *(_DWORD *)&msg[14] = v8;
        _os_log_impl(&dword_184457000, v10, OS_LOG_TYPE_ERROR, "Failed to allocate reply port: %s [0x%x]", msg, 0x12u);
      }
    }
    return 0;
  }
  *(_OWORD *)&msg[20] = 0u;
  *(_OWORD *)&msg[4] = 0u;
  *(_DWORD *)&msg[28] = name;
  v17 = 1376256;
  length = *MEMORY[0x1E0C804E8];
  v19 = v3;
  v20 = v5;
  *(_DWORD *)msg = -2147483629;
  *(_DWORD *)&msg[8] = v4;
  *(_QWORD *)&msg[20] = 0x100009D62;
  if (MEMORY[0x1E0C85B60])
    voucher_mach_msg_set((mach_msg_header_t *)msg);
  if (mach_msg((mach_msg_header_t *)msg, 1, 0x38u, 0, 0, 0, 0))
    goto LABEL_8;
  bzero(msg, 0x1000uLL);
  v9 = 0;
  if (mach_msg((mach_msg_header_t *)msg, 2, 0, 0x1000u, name, 0, 0))
    goto LABEL_9;
  if (*(_DWORD *)&msg[20] != 1195461716)
    goto LABEL_9;
  v9 = 0;
  if ((*(_DWORD *)msg & 0x80000000) == 0 || *(_DWORD *)&msg[24] != 1)
    goto LABEL_9;
  if (HIBYTE(v17) != 1)
  {
LABEL_8:
    v9 = 0;
  }
  else
  {
    context.version = 0;
    memset(&context.retain, 0, 40);
    context.info = (void *)length;
    context.deallocate = (CFAllocatorDeallocateCallBack)deallocate_vm_region;
    context.preferredSize = 0;
    v13 = CFAllocatorCreate(0, &context);
    v9 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)&msg[28], length, v13);
    CFRelease(v13);
  }
LABEL_9:
  mach_port_mod_refs(*v6, name, 1u, -1);
  return v9;
}

uint64_t CARenderServerDebugDisplayStateOldInterface(int a1, char a2)
{
  mach_port_t reply_port;
  uint64_t v4;
  uint64_t v5;
  _BYTE msg[36];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)&msg[20] = 0u;
  v8 = 0;
  *(_OWORD *)&msg[4] = 0u;
  *(_QWORD *)&msg[24] = *MEMORY[0x1E0C804E8];
  msg[32] = a2;
  *(_WORD *)&msg[33] = 0;
  msg[35] = 0;
  reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)msg = 5395;
  *(_QWORD *)&msg[16] = 0x9D6000000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    reply_port = *(_DWORD *)&msg[12];
  }
  v4 = mach_msg((mach_msg_header_t *)msg, 3, 0x24u, 0x2Cu, reply_port, 0, 0);
  v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
    return v5;
  }
  if ((_DWORD)v4)
  {
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
    return v5;
  }
  if (*(_DWORD *)&msg[20] == 71)
  {
    v5 = 4294966988;
LABEL_17:
    mach_msg_destroy((mach_msg_header_t *)msg);
    return v5;
  }
  if (*(_DWORD *)&msg[20] != 40388)
  {
    v5 = 4294966995;
    goto LABEL_17;
  }
  v5 = 4294966996;
  if ((*(_DWORD *)msg & 0x80000000) != 0)
    goto LABEL_17;
  if (*(_DWORD *)&msg[4] != 36)
    goto LABEL_17;
  if (*(_DWORD *)&msg[8])
    goto LABEL_17;
  v5 = *(unsigned int *)&msg[32];
  if (*(_DWORD *)&msg[32])
    goto LABEL_17;
  return v5;
}

uint64_t CAMetalTextureGetBytesPerRow(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;

  v2 = objc_msgSend(a1, "pixelFormat");
  v3 = 32;
  if ((unint64_t)(v2 - 70) > 0x2D)
    goto LABEL_5;
  if (((1 << (v2 - 70)) & 0xC03) != 0)
    goto LABEL_6;
  if (v2 == 115)
  {
    v3 = 64;
  }
  else
  {
LABEL_5:
    if ((unint64_t)(v2 - 554) >= 2)
      return 0;
  }
LABEL_6:
  v4 = (void *)objc_msgSend(a1, "device");
  v5 = objc_msgSend(a1, "pixelFormat");
  v6 = objc_msgSend(a1, "width");
  v7 = objc_msgSend(v4, "minimumLinearTextureAlignmentForPixelFormat:", v5);
  v8 = 8 * v7 - 1;
  v9 = v8 + v6 * v3;
  if ((v8 & (8 * v7)) != 0)
    return v9 / (8 * v7) * 8 * v7;
  else
    return v9 & (-8 * v7);
}

uint64_t CAMetalTextureGetBytes(void *a1, _QWORD *a2, unint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t BytesPerRow;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  _QWORD v13[7];

  v13[6] = *MEMORY[0x1E0C80C00];
  v6 = objc_msgSend(a1, "width");
  v7 = objc_msgSend(a1, "height");
  BytesPerRow = CAMetalTextureGetBytesPerRow(a1);
  if (!BytesPerRow)
    return 0;
  v9 = BytesPerRow;
  v10 = BytesPerRow * v7;
  v11 = CA::Render::aligned_malloc((CA::Render *)(BytesPerRow * v7), a3, 0);
  memset(v13, 0, 24);
  v13[3] = v6;
  v13[4] = v7;
  v13[5] = 1;
  objc_msgSend(a1, "getBytes:bytesPerRow:fromRegion:mipmapLevel:", v11, v9, v13, 0);
  *a2 = v11;
  return v10;
}

uint64_t CAMetalTextureGetPixelFormat(void *a1)
{
  uint64_t v1;
  unsigned __int16 v3;

  v1 = objc_msgSend(a1, "pixelFormat");
  if (v1 <= 114)
  {
    if ((unint64_t)(v1 - 70) < 2)
    {
      v3 = 16961;
      return v3 | 0x52470000u;
    }
    if ((unint64_t)(v1 - 80) < 2)
      return 1111970369;
  }
  else
  {
    if ((unint64_t)(v1 - 550) < 2)
      return 1647534392;
    if ((unint64_t)(v1 - 554) < 2)
      return 1999843442;
    if (v1 == 115)
    {
      v3 = 26689;
      return v3 | 0x52470000u;
    }
  }
  return 0;
}

void CA::WindowServer::FlipBook::_enter(uint64_t a1, __int16 a2)
{
  if ((*(_BYTE *)(a1 + 24) & 3) != 0)
    __assert_rtn("_enter", "windowserver-flipbook.cpp", 805, "_state == kFlipBookStateDisabled");
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a1 + 24) & 0xFC | 1;
  if ((a2 & 0xFF00) != 0x200)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8));
    CA::WindowServer::FlipBook::swap_enqueued_locked((_QWORD *)a1);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 8));
  }
}

void CA::WindowServer::FlipBook::_exit(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;

  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 112))(a1);
  *(_BYTE *)(a1 + 24) &= 0xFCu;
  CA::WindowServer::FlipBook::invalidate_context((CA::Render::Context *)*(unsigned int *)(a1 + 48));
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8));
  v2 = *(_QWORD **)(a1 + 80);
  v3 = *(_QWORD **)(a1 + 88);
  if (v2 != v3)
  {
    do
    {
      CA::WindowServer::FlipBook::reuse_frame((_QWORD *)a1, v2);
      v2 += 13;
    }
    while (v2 != v3);
    v2 = *(_QWORD **)(a1 + 80);
  }
  *(_QWORD *)(a1 + 88) = v2;
  CA::WindowServer::FlipBook::collect((CA::WindowServer::FlipBook *)a1);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 8));
}

CA::Render::Context *CA::WindowServer::FlipBook::_suspend(uint64_t a1)
{
  CA::Render::Context *result;
  unsigned __int8 v3;
  unint64_t v4[2];

  v4[1] = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 24) & 3) != 1)
    __assert_rtn("_suspend", "windowserver-flipbook.cpp", 844, "_state == kFlipBookStateActive");
  v4[0] = 0;
  v3 = 0;
  CA::WindowServer::FlipBook::cancel((CA::WindowServer::FlipBook *)a1, v4, &v3, 0, 1);
  if (v4[0])
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 48))(a1, v3);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 112))(a1);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a1 + 24) & 0xFC | 2;
  result = CA::WindowServer::FlipBook::invalidate_context((CA::Render::Context *)*(unsigned int *)(a1 + 48));
  *(_DWORD *)(a1 + 48) = 0;
  return result;
}

void CA::WindowServer::FlipBook::_resume(uint64_t *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  __int128 *v13;
  __int128 *v14;
  unint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  unint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  void *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  int v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  char v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if ((a1[3] & 3) != 2)
    __assert_rtn("_resume", "windowserver-flipbook.cpp", 864, "_state == kFlipBookStateSuspended");
  if ((a2 & 0xFF00) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)a1 + 2);
    v11 = (_QWORD *)a1[19];
    v12 = (_QWORD *)a1[20];
    if (v11 != v12)
    {
      do
      {
        CA::WindowServer::FlipBook::reuse_frame(a1, v11);
        v11 += 13;
      }
      while (v11 != v12);
      v11 = (_QWORD *)a1[19];
    }
    a1[20] = (uint64_t)v11;
    *((_BYTE *)a1 + 24) = a1[3] & 0xFC | 1;
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 2);
    return;
  }
  v4 = mach_continuous_time();
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 2);
  v5 = a1[19];
  v6 = a1[20];
  if (v5 == v6)
    goto LABEL_30;
  if (*(_QWORD *)(v5 + 40) >= v4)
  {
    v10 = 0;
  }
  else
  {
    v7 = v5 + 104;
    do
    {
      v8 = v7;
      if (v7 == v6)
        break;
      v9 = *(_QWORD *)(v7 + 40);
      v7 += 104;
    }
    while (v9 < v4);
    v10 = *(_QWORD *)(v8 - 72);
  }
  v13 = (__int128 *)(v5 - 104);
  do
  {
    v14 = (__int128 *)((char *)v13 + 104);
    v15 = *((_QWORD *)v13 + 17);
    if (v15 < v10)
    {
      (*(void (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, (uint64_t)v13 + 104);
      CA::WindowServer::FlipBook::reuse_frame(a1, (_QWORD *)v13 + 13);
      goto LABEL_28;
    }
    if (v15 == v10)
    {
      v16 = *a1;
      if ((a2 & 0x10000) != 0)
      {
        (*(void (**)(uint64_t *, uint64_t))(v16 + 56))(a1, (uint64_t)v13 + 104);
        CA::WindowServer::FlipBook::reuse_frame(a1, (_QWORD *)v13 + 13);
        (*(void (**)(uint64_t *))(*a1 + 64))(a1);
        goto LABEL_28;
      }
      (*(void (**)(uint64_t *))(v16 + 64))(a1);
      *((_QWORD *)v13 + 18) = v4;
      v33 = 0;
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      v30 = 0;
      v34 &= 0xFCu;
      (*(void (**)(uint64_t *, uint64_t, __int128 *))(*a1 + 96))(a1, (uint64_t)v13 + 104, &v27);
      v33 = 0;
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      v30 = 0;
      v34 &= 0xFCu;
      (*(void (**)(uint64_t *, uint64_t, __int128 *))(*a1 + 96))(a1, (uint64_t)v13 + 104, &v27);
      v33 = 0;
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      v30 = 0;
      v34 &= 0xFCu;
      (*(void (**)(uint64_t *, uint64_t, __int128 *))(*a1 + 96))(a1, (uint64_t)v13 + 104, &v27);
      v33 = 0;
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      v30 = 0;
      v34 &= 0xFCu;
      (*(void (**)(uint64_t *, uint64_t, __int128 *))(*a1 + 96))(a1, (uint64_t)v13 + 104, &v27);
      v33 = 0;
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      v30 = 0;
      v34 &= 0xFCu;
      (*(void (**)(uint64_t *, uint64_t, __int128 *))(*a1 + 96))(a1, (uint64_t)v13 + 104, &v27);
      v33 = 0;
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      v30 = 0;
      v34 &= 0xFCu;
      (*(void (**)(uint64_t *, uint64_t, __int128 *))(*a1 + 96))(a1, (uint64_t)v13 + 104, &v27);
LABEL_22:
      v33 = 0;
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      v30 = 0;
      v34 &= 0xFCu;
      goto LABEL_23;
    }
    if (v14 == (__int128 *)a1[19])
      goto LABEL_22;
    v17 = *v13;
    v18 = v13[1];
    v19 = v13[2];
    v30 = *((_DWORD *)v13 + 12);
    v28 = v18;
    v29 = v19;
    v27 = v17;
    v31 = *(__int128 *)((char *)v13 + 52);
    v32 = *(__int128 *)((char *)v13 + 68);
    v20 = *((_QWORD *)v13 + 11);
    v34 = *((_BYTE *)v13 + 96);
    v33 = v20;
LABEL_23:
    (*(void (**)(uint64_t *, uint64_t, __int128 *))(*a1 + 96))(a1, (uint64_t)v13 + 104, &v27);
    v21 = a1[17];
    if (v21 >= a1[18])
    {
      v26 = std::vector<CA::WindowServer::FlipBook::Frame>::__push_back_slow_path<CA::WindowServer::FlipBook::Frame const&>((void **)a1 + 16, (__int128 *)((char *)v13 + 104));
    }
    else
    {
      v22 = *v14;
      v23 = *(__int128 *)((char *)v13 + 120);
      v24 = *(__int128 *)((char *)v13 + 136);
      *(_DWORD *)(v21 + 48) = *((_DWORD *)v13 + 38);
      *(_OWORD *)(v21 + 16) = v23;
      *(_OWORD *)(v21 + 32) = v24;
      *(_OWORD *)v21 = v22;
      *(_OWORD *)(v21 + 52) = *(__int128 *)((char *)v13 + 156);
      *(_OWORD *)(v21 + 68) = *(__int128 *)((char *)v13 + 172);
      v25 = *((_QWORD *)v13 + 24);
      *(_BYTE *)(v21 + 96) = *((_BYTE *)v13 + 200);
      *(_QWORD *)(v21 + 88) = v25;
      v26 = (void *)(v21 + 104);
    }
    a1[17] = (uint64_t)v26;
LABEL_28:
    v13 = (__int128 *)((char *)v13 + 104);
  }
  while ((__int128 *)((char *)v14 + 104) != (__int128 *)a1[20]);
  v5 = a1[19];
LABEL_30:
  a1[20] = v5;
  CA::WindowServer::FlipBook::swap_enqueued_locked(a1);
  *((_BYTE *)a1 + 24) = a1[3] & 0xFC | 1;
  os_unfair_lock_unlock((os_unfair_lock_t)a1 + 2);
}

uint64_t CA::WindowServer::FlipBook::swapped_frame_displayed_p()
{
  return 0;
}

uint64_t CA::WindowServer::FlipBook::supports_individual_frame_cancels(CA::WindowServer::FlipBook *this)
{
  return 0;
}

BOOL CA::WindowServer::FlipBook::needs_debug_surface(CA::WindowServer::FlipBook *this)
{
  return byte_1ECDC6AA3 && *((_DWORD *)this + 73) == 0;
}

__n128 CA::WindowServer::FlipBook::debug_surface_bounds@<Q0>(CA::WindowServer::FlipBook *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result;

  result = *(__n128 *)(*((_QWORD *)this + 2) + 168);
  *a2 = result;
  return result;
}

uint64_t CA::WindowServer::FlipBook::get_destination_surface(CA::WindowServer::FlipBook *this)
{
  return 0;
}

void CA::WindowServer::FlipBook::reuse_frame(_QWORD *a1, _QWORD *a2)
{
  if (*a2 == a1[22])
    __assert_rtn("reuse_frame", "windowserver-flipbook.cpp", 1517, "frame.surface != _apl_scratch_buffer.surface");
  CA::WindowServer::FlipBook::free_surface(a1, a2);
}

_QWORD *CA::WindowServer::FlipBook::swap_enqueued_locked(_QWORD *this)
{
  uint64_t v1;
  __int128 *v2;
  NSObject *v3;
  IOSurfaceID ID;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  char v9;
  unint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint8_t buf[16];
  __int128 v16;
  __int128 v17;
  int v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  char v22;
  uint64_t v23;

  v1 = (uint64_t)this;
  v23 = *MEMORY[0x1E0C80C00];
  v2 = (__int128 *)this[10];
  if (v2 != (__int128 *)this[11])
  {
    do
    {
      if (x_log_hook_p())
      {
        IOSurfaceGetID(*(IOSurfaceRef *)v2);
        x_log_();
      }
      else
      {
        v3 = x_log_category_flipbook;
        if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
        {
          ID = IOSurfaceGetID(*(IOSurfaceRef *)v2);
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = ID;
          _os_log_impl(&dword_184457000, v3, OS_LOG_TYPE_DEFAULT, "previously enqueued surface: 0x%x", buf, 8u);
        }
      }
      if (*(_DWORD *)(v1 + 292) == 1
        && (v5 = CA::WindowServer::FlipBook::previous_frame_with_seed((CA::WindowServer::FlipBook *)v1, *((_QWORD *)v2 + 4) - 1)) != 0)
      {
        v6 = *(_OWORD *)v5;
        v7 = *(_OWORD *)(v5 + 16);
        v8 = *(_OWORD *)(v5 + 32);
        v18 = *(_DWORD *)(v5 + 48);
        v16 = v7;
        v17 = v8;
        *(_OWORD *)buf = v6;
        v19 = *(_OWORD *)(v5 + 52);
        v20 = *(_OWORD *)(v5 + 68);
        v9 = *(_BYTE *)(v5 + 96);
        v21 = *(_QWORD *)(v5 + 88);
        v22 = v9;
      }
      else
      {
        v21 = 0;
        *(_OWORD *)buf = 0u;
        v16 = 0u;
        v17 = 0u;
        v18 = 0;
        v22 &= 0xFCu;
      }
      (*(void (**)(uint64_t, __int128 *, uint8_t *))(*(_QWORD *)v1 + 96))(v1, v2, buf);
      v10 = *(_QWORD *)(v1 + 136);
      if (v10 >= *(_QWORD *)(v1 + 144))
      {
        this = std::vector<CA::WindowServer::FlipBook::Frame>::__push_back_slow_path<CA::WindowServer::FlipBook::Frame const&>((void **)(v1 + 128), v2);
      }
      else
      {
        v11 = *v2;
        v12 = v2[1];
        v13 = v2[2];
        *(_DWORD *)(v10 + 48) = *((_DWORD *)v2 + 12);
        *(_OWORD *)(v10 + 16) = v12;
        *(_OWORD *)(v10 + 32) = v13;
        *(_OWORD *)v10 = v11;
        *(_OWORD *)(v10 + 52) = *(__int128 *)((char *)v2 + 52);
        *(_OWORD *)(v10 + 68) = *(__int128 *)((char *)v2 + 68);
        v14 = *((_QWORD *)v2 + 11);
        *(_BYTE *)(v10 + 96) = *((_BYTE *)v2 + 96);
        *(_QWORD *)(v10 + 88) = v14;
        this = (_QWORD *)(v10 + 104);
      }
      *(_QWORD *)(v1 + 136) = this;
      v2 = (__int128 *)((char *)v2 + 104);
    }
    while (v2 != *(__int128 **)(v1 + 88));
    v2 = *(__int128 **)(v1 + 80);
  }
  *(_QWORD *)(v1 + 88) = v2;
  return this;
}

void *std::vector<CA::WindowServer::FlipBook::Frame>::__push_back_slow_path<CA::WindowServer::FlipBook::Frame const&>(void **a1, __int128 *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  void *v14;
  char *v15;
  char *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;

  v2 = 0x4EC4EC4EC4EC4EC5 * (((_BYTE *)a1[1] - (_BYTE *)*a1) >> 3);
  v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x276276276276276)
    abort();
  if (0x9D89D89D89D89D8ALL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3) > v3)
    v3 = 0x9D89D89D89D89D8ALL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3);
  if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3)) >= 0x13B13B13B13B13BLL)
    v6 = 0x276276276276276;
  else
    v6 = v3;
  if (v6)
    v6 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::WindowServer::FlipBook::Frame>>(v6);
  else
    v7 = 0;
  v8 = v6 + 104 * v2;
  v9 = v6 + 104 * v7;
  v10 = *a2;
  v11 = a2[1];
  v12 = a2[2];
  *(_DWORD *)(v8 + 48) = *((_DWORD *)a2 + 12);
  *(_OWORD *)(v8 + 16) = v11;
  *(_OWORD *)(v8 + 32) = v12;
  *(_OWORD *)v8 = v10;
  *(_OWORD *)(v8 + 52) = *(__int128 *)((char *)a2 + 52);
  *(_OWORD *)(v8 + 68) = *(__int128 *)((char *)a2 + 68);
  v13 = *((_QWORD *)a2 + 11);
  *(_BYTE *)(v8 + 96) = *((_BYTE *)a2 + 96);
  *(_QWORD *)(v8 + 88) = v13;
  v14 = (void *)(v8 + 104);
  v16 = (char *)*a1;
  v15 = (char *)a1[1];
  if (v15 != *a1)
  {
    do
    {
      v17 = *(_OWORD *)(v15 - 104);
      v18 = *(_OWORD *)(v15 - 88);
      v19 = *(_OWORD *)(v15 - 72);
      *(_DWORD *)(v8 - 56) = *((_DWORD *)v15 - 14);
      *(_OWORD *)(v8 - 72) = v19;
      *(_OWORD *)(v8 - 88) = v18;
      *(_OWORD *)(v8 - 104) = v17;
      *(_OWORD *)(v8 - 52) = *(_OWORD *)(v15 - 52);
      *(_OWORD *)(v8 - 36) = *(_OWORD *)(v15 - 36);
      v20 = *((_QWORD *)v15 - 2);
      *(_BYTE *)(v8 - 8) = *(v15 - 8);
      *(_QWORD *)(v8 - 16) = v20;
      v8 -= 104;
      v15 -= 104;
    }
    while (v15 != v16);
    v15 = (char *)*a1;
  }
  *a1 = (void *)v8;
  a1[1] = v14;
  a1[2] = (void *)v9;
  if (v15)
    operator delete(v15);
  return v14;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CA::WindowServer::FlipBook::Frame>>(unint64_t a1)
{
  if (a1 >= 0x276276276276277)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(104 * a1);
}

uint64_t CA::WindowServer::FlipBook::previous_frame_with_seed(CA::WindowServer::FlipBook *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = *((_QWORD *)this + 17);
  if (*((_QWORD *)this + 16) != v2 && *(_QWORD *)(v2 - 72) == a2)
    return v2 - 104;
  v2 = *((_QWORD *)this + 11);
  if (*((_QWORD *)this + 10) != v2 && *(_QWORD *)(v2 - 72) == a2)
    return v2 - 104;
  v4 = *((_QWORD *)this + 20);
  if (*((_QWORD *)this + 19) == v4)
    return 0;
  if (*(_QWORD *)(v4 - 72) == a2)
    return v4 - 104;
  return 0;
}

void CA::WindowServer::FlipBook::free_surface(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = *(_QWORD *)(*(uint64_t (**)(_QWORD *))(*a1 + 88))(a1);
  a1[9] -= a2[11];
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *a2);
  CFRelease((CFTypeRef)*a2);
  v5 = a2[1];
  if (v5)
    CA::OGL::Context::release_surface_async(v4, v5);
  if (a2[2])
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    CFRelease((CFTypeRef)a2[2]);
    v6 = a2[3];
    if (v6)
      CA::OGL::Context::release_surface_async(v4, v6);
  }
}

void CA::WindowServer::FlipBook::cancel(CA::WindowServer::FlipBook *this, unint64_t *a2, unsigned __int8 *a3, unsigned int *a4, int a5)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  NSObject *v18;
  unint64_t v19;
  double v20;
  double v21;
  uint64_t v22;
  __int128 *v23;
  __int128 **v24;
  __int128 *v25;
  __int128 *v26;
  _BYTE *v27;
  _BYTE *v28;
  __int128 *v29;
  __int128 *v30;
  uint64_t v31;
  double v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  unint64_t v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  double v49;
  double v50;
  uint64_t v51;
  uint64_t v52;
  __int128 *v53;
  __int128 *v54;
  __int128 *v55;
  __int128 v56;
  __int128 *v57;
  __int128 *v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;
  double v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  os_unfair_lock_s *v70;
  double v71;
  double v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  uint8_t buf[4];
  uint64_t v77;
  __int16 v78;
  double v79;
  __int16 v80;
  char *v81;
  __int16 v82;
  int v83;
  __int16 v84;
  uint64_t v85;
  __int16 v86;
  uint64_t v87;
  __int16 v88;
  double v89;
  __int16 v90;
  char *v91;
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  *a2 = 0;
  *a3 = 0;
  if ((*((_BYTE *)this + 24) & 3) == 2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 2);
    v6 = (_QWORD *)*((_QWORD *)this + 19);
    v7 = (_QWORD *)*((_QWORD *)this + 20);
    v8 = v7 - v6;
    if (v7 != v6)
    {
      do
      {
        CA::WindowServer::FlipBook::reuse_frame(this, v6);
        v6 += 13;
      }
      while (v6 != v7);
      v7 = (_QWORD *)*((_QWORD *)this + 19);
    }
    *((_QWORD *)this + 20) = v7;
    if (x_log_hook_p())
    {
      v9 = *((_QWORD *)this + 9);
      if (v9 >= 0x400)
      {
        v32 = 1.0;
        do
          v32 = v32 * 0.0009765625;
        while (v32 * (double)v9 >= 1024.0);
      }
      x_log_();
    }
    else
    {
      v18 = x_log_category_flipbook;
      if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
      {
        v19 = *((_QWORD *)this + 9);
        v20 = (double)v19;
        if (v19 >= 0x400)
        {
          v66 = 1.0;
          do
          {
            v66 = v66 * 0.0009765625;
            v21 = v66 * v20;
          }
          while (v66 * v20 >= 1024.0);
        }
        else
        {
          v21 = (double)v19;
        }
        v67 = v19 > 0x3FF;
        if ((v19 & 0xFFFFFFFFFFF00000) != 0)
          ++v67;
        if ((v19 & 0xFFFFFFFFC0000000) != 0)
          ++v67;
        if (v19 >> 40)
          ++v67;
        if (v19 >> 50)
          ++v67;
        if (v19 >> 60)
          v68 = v67 + 1;
        else
          v68 = v67;
        v69 = off_1E15AAF00[v68];
        *(_DWORD *)buf = 134218498;
        v77 = 0x4EC4EC4EC4EC4EC5 * v8;
        v78 = 2048;
        v79 = v21;
        v80 = 2080;
        v81 = v69;
        _os_log_impl(&dword_184457000, v18, OS_LOG_TYPE_DEFAULT, "FlipBook::cancel(), cancelled %zu suppressed frames, memory usage = %.2lf %s", buf, 0x20u);
      }
    }
    v70 = (os_unfair_lock_s *)((char *)this + 8);
LABEL_123:
    os_unfair_lock_unlock(v70);
    return;
  }
  (*(void (**)(CA::WindowServer::FlipBook *, _QWORD))(*(_QWORD *)this + 72))(this, 0);
  if (((*(uint64_t (**)(CA::WindowServer::FlipBook *))(*(_QWORD *)this + 128))(this) & 1) != 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 2);
    v14 = *((_QWORD *)this + 17);
    v15 = 0x4EC4EC4EC4EC4EC5 * ((v14 - *((_QWORD *)this + 16)) >> 3);
    v75 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*((_QWORD *)this + 11) - *((_QWORD *)this + 10)) >> 3);
    *((_QWORD *)this + 7) = 0;
    do
    {
      v16 = v14;
      if (v14 == *((_QWORD *)this + 16))
      {
        v17 = 0;
        goto LABEL_28;
      }
      v14 -= 104;
    }
    while (((*(uint64_t (**)(CA::WindowServer::FlipBook *, uint64_t))(*(_QWORD *)this + 104))(this, v16 - 104) & 1) != 0);
    *a2 = *(_QWORD *)(v16 - 72);
    *a3 = *(_BYTE *)(v16 - 8) & 1;
    v17 = *(_DWORD *)(v16 - 56);
    if (a4)
    {
      if (CADeviceHasInternalBuild::once != -1)
        dispatch_once(&CADeviceHasInternalBuild::once, &__block_literal_global_107);
      if (CADeviceHasInternalBuild::internal)
        CA::WindowServer::FlipBook::copy_surface((uint64_t)this, *(IOSurfaceRef *)v14, *(_BYTE *)(v16 - 8), a4);
    }
    *((_QWORD *)this + 7) = *(_QWORD *)(v16 - 64);
    v14 = *((_QWORD *)this + 16);
LABEL_28:
    v29 = (__int128 *)*((_QWORD *)this + 17);
    if (a5)
    {
      if (v16 == v14)
        v30 = (__int128 *)v14;
      else
        v30 = (__int128 *)(v16 - 104);
      v31 = 0x4EC4EC4EC4EC4EC5 * (((char *)v29 - (char *)v30) >> 3);
      std::vector<CA::WindowServer::FlipBook::Frame>::__insert_with_size[abi:nn180100]<std::__wrap_iter<CA::WindowServer::FlipBook::Frame*>,std::__wrap_iter<CA::WindowServer::FlipBook::Frame*>>((unint64_t *)this + 19, *((_QWORD *)this + 20), v30, v29, v31);
      std::vector<CA::WindowServer::FlipBook::Frame>::erase((uint64_t)this + 128, (uint64_t)v30, *((_QWORD *)this + 17));
      v14 = *((_QWORD *)this + 16);
      v29 = (__int128 *)*((_QWORD *)this + 17);
    }
    else
    {
      v31 = 0;
    }
    while ((__int128 *)v14 != v29)
    {
      if (*(_QWORD *)(v14 + 32) <= *a2)
      {
        v14 += 104;
      }
      else
      {
        CA::WindowServer::FlipBook::reuse_frame(this, (_QWORD *)v14);
        v33 = *((_QWORD *)this + 17);
        v29 = (__int128 *)v14;
        if (v14 + 104 != v33)
        {
          v34 = v14;
          do
          {
            v29 = (__int128 *)(v34 + 104);
            v35 = *(_OWORD *)(v34 + 120);
            *(_OWORD *)v34 = *(_OWORD *)(v34 + 104);
            *(_OWORD *)(v34 + 16) = v35;
            *(_OWORD *)(v34 + 32) = *(_OWORD *)(v34 + 136);
            *(_DWORD *)(v34 + 48) = *(_DWORD *)(v34 + 152);
            *(_OWORD *)(v34 + 52) = *(_OWORD *)(v34 + 156);
            *(_QWORD *)(v34 + 88) = *(_QWORD *)(v34 + 192);
            *(_BYTE *)(v34 + 96) = *(_BYTE *)(v34 + 200);
            v36 = v34 + 208;
            *(_OWORD *)(v34 + 68) = *(_OWORD *)(v34 + 172);
            v34 += 104;
          }
          while (v36 != v33);
        }
        *((_QWORD *)this + 17) = v29;
        ++v31;
      }
    }
    v38 = *((_QWORD *)this + 10);
    v37 = *((_QWORD *)this + 11);
    if (a5)
    {
      if (v38 != v37)
      {
        v39 = (char *)*((_QWORD *)this + 20);
        do
        {
          if ((unint64_t)v39 >= *((_QWORD *)this + 21))
          {
            v39 = (char *)std::vector<CA::WindowServer::FlipBook::Frame>::__push_back_slow_path<CA::WindowServer::FlipBook::Frame const&>((void **)this + 19, (__int128 *)v38);
          }
          else
          {
            v40 = *(_OWORD *)v38;
            v41 = *(_OWORD *)(v38 + 16);
            v42 = *(_OWORD *)(v38 + 32);
            *((_DWORD *)v39 + 12) = *(_DWORD *)(v38 + 48);
            *((_OWORD *)v39 + 1) = v41;
            *((_OWORD *)v39 + 2) = v42;
            *(_OWORD *)v39 = v40;
            *(_OWORD *)(v39 + 52) = *(_OWORD *)(v38 + 52);
            *(_OWORD *)(v39 + 68) = *(_OWORD *)(v38 + 68);
            v43 = *(_QWORD *)(v38 + 88);
            v39[96] = *(_BYTE *)(v38 + 96);
            *((_QWORD *)v39 + 11) = v43;
            v39 += 104;
          }
          *((_QWORD *)this + 20) = v39;
          v38 += 104;
        }
        while (v38 != *((_QWORD *)this + 11));
      }
    }
    else if (v38 != v37)
    {
      do
      {
        CA::WindowServer::FlipBook::reuse_frame(this, (_QWORD *)v38);
        v38 += 104;
      }
      while (v38 != *((_QWORD *)this + 11));
    }
    *((_QWORD *)this + 11) = *((_QWORD *)this + 10);
    if (x_log_hook_p())
    {
      v44 = *((_QWORD *)this + 9);
      if (v44 >= 0x400)
      {
        v71 = 1.0;
        do
          v71 = v71 * 0.0009765625;
        while (v71 * (double)v44 >= 1024.0);
      }
      x_log_();
    }
    else
    {
      v45 = x_log_category_flipbook;
      if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
      {
        v46 = *a2;
        v47 = *((_QWORD *)this + 7);
        v48 = *((_QWORD *)this + 9);
        v49 = (double)v48;
        if (v48 >= 0x400)
        {
          v72 = 1.0;
          v51 = v75;
          do
          {
            v72 = v72 * 0.0009765625;
            v50 = v72 * v49;
          }
          while (v72 * v49 >= 1024.0);
        }
        else
        {
          v50 = (double)v48;
          v51 = v75;
        }
        v73 = v48 > 0x3FF;
        if ((v48 & 0xFFFFFFFFFFF00000) != 0)
          ++v73;
        if ((v48 & 0xFFFFFFFFC0000000) != 0)
          ++v73;
        if (v48 >> 40)
          ++v73;
        if (v48 >> 50)
          ++v73;
        if (v48 >> 60)
          ++v73;
        v74 = off_1E15AAF00[v73];
        *(_DWORD *)buf = 134219778;
        v77 = v31;
        v78 = 2048;
        v79 = *(double *)&v15;
        v80 = 2048;
        v81 = (char *)v51;
        v82 = 1024;
        v83 = v17;
        v84 = 2048;
        v85 = v46;
        v86 = 2048;
        v87 = v47;
        v88 = 2048;
        v89 = v50;
        v90 = 2080;
        v91 = v74;
        _os_log_impl(&dword_184457000, v45, OS_LOG_TYPE_DEFAULT, "FlipBook::cancel(), cancelled %zu/%zu swapped frames and %zu enqueued frames, last frame = swap %u (seed %llu, timestamp %llu), memory usage = %.2lf %s", buf, 0x4Eu);
      }
    }
    CA::WindowServer::FlipBook::collect(this);
    v70 = (os_unfair_lock_s *)((char *)this + 8);
    goto LABEL_123;
  }
  (*(void (**)(CA::WindowServer::FlipBook *))(*(_QWORD *)this + 112))(this);
  *a2 = 0;
  *a3 = 0;
  v22 = mach_continuous_time();
  *((_QWORD *)this + 7) = 0;
  os_unfair_lock_lock((os_unfair_lock_t)this + 2);
  v25 = (__int128 *)*((_QWORD *)this + 16);
  v23 = (__int128 *)*((_QWORD *)this + 17);
  v24 = (__int128 **)((char *)this + 128);
  if (v25 == v23)
  {
    v23 = (__int128 *)*((_QWORD *)this + 16);
    v26 = v23;
  }
  else
  {
    v26 = (__int128 *)*((_QWORD *)this + 16);
    if (*((_QWORD *)v25 + 5) < v22)
    {
      v27 = v25 + 6;
      while (1)
      {
        v28 = v27;
        *a2 = *((_QWORD *)v27 - 8);
        *a3 = *v27 & 1;
        v26 = (__int128 *)(v27 + 8);
        v23 = (__int128 *)*((_QWORD *)this + 17);
        if (v26 == v23)
          break;
        v27 = v28 + 104;
        if (*((_QWORD *)v28 + 6) >= v22)
        {
          v26 = (__int128 *)(v28 + 8);
          goto LABEL_107;
        }
      }
      v23 = v26;
LABEL_107:
      v25 = *v24;
      if (!a5)
        goto LABEL_66;
      goto LABEL_62;
    }
  }
  if (a5)
  {
LABEL_62:
    if (v26 == v25)
      v52 = 0;
    else
      v52 = -1;
    v53 = (__int128 *)((char *)v26 + 104 * v52);
    std::vector<CA::WindowServer::FlipBook::Frame>::__insert_with_size[abi:nn180100]<std::__wrap_iter<CA::WindowServer::FlipBook::Frame*>,std::__wrap_iter<CA::WindowServer::FlipBook::Frame*>>((unint64_t *)this + 19, *((_QWORD *)this + 20), v53, v23, 0x4EC4EC4EC4EC4EC5 * (((char *)v23 - (char *)v53) >> 3));
    std::vector<CA::WindowServer::FlipBook::Frame>::erase((uint64_t)this + 128, (uint64_t)v53, *((_QWORD *)this + 17));
    v25 = (__int128 *)*((_QWORD *)this + 16);
    v23 = (__int128 *)*((_QWORD *)this + 17);
  }
LABEL_66:
  if (v25 == v23)
  {
    v58 = v23;
  }
  else
  {
    do
    {
      if (*((_QWORD *)v25 + 4) == *a2)
      {
        v25 = (__int128 *)((char *)v25 + 104);
      }
      else
      {
        CA::WindowServer::FlipBook::reuse_frame(this, v25);
        v54 = (__int128 *)*((_QWORD *)this + 17);
        v23 = v25;
        if ((__int128 *)((char *)v25 + 104) != v54)
        {
          v55 = v25;
          do
          {
            v23 = (__int128 *)((char *)v55 + 104);
            v56 = *(__int128 *)((char *)v55 + 120);
            *v55 = *(__int128 *)((char *)v55 + 104);
            v55[1] = v56;
            v55[2] = *(__int128 *)((char *)v55 + 136);
            *((_DWORD *)v55 + 12) = *((_DWORD *)v55 + 38);
            *(__int128 *)((char *)v55 + 52) = *(__int128 *)((char *)v55 + 156);
            *((_QWORD *)v55 + 11) = *((_QWORD *)v55 + 24);
            *((_BYTE *)v55 + 96) = *((_BYTE *)v55 + 200);
            v57 = v55 + 13;
            *(__int128 *)((char *)v55 + 68) = *(__int128 *)((char *)v55 + 172);
            v55 = (__int128 *)((char *)v55 + 104);
          }
          while (v57 != v54);
        }
        *((_QWORD *)this + 17) = v23;
      }
    }
    while (v25 != v23);
    v58 = *v24;
  }
  if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v23 - (char *)v58) >> 3)) >= 2)
    __assert_rtn("cancel_all", "windowserver-flipbook.cpp", 303, "_swapped.size () <= 1");
  v60 = *((_QWORD *)this + 10);
  v59 = *((_QWORD *)this + 11);
  if (a5)
  {
    if (v60 != v59)
    {
      v61 = (char *)*((_QWORD *)this + 20);
      do
      {
        if ((unint64_t)v61 >= *((_QWORD *)this + 21))
        {
          v61 = (char *)std::vector<CA::WindowServer::FlipBook::Frame>::__push_back_slow_path<CA::WindowServer::FlipBook::Frame const&>((void **)this + 19, (__int128 *)v60);
        }
        else
        {
          v62 = *(_OWORD *)v60;
          v63 = *(_OWORD *)(v60 + 16);
          v64 = *(_OWORD *)(v60 + 32);
          *((_DWORD *)v61 + 12) = *(_DWORD *)(v60 + 48);
          *((_OWORD *)v61 + 1) = v63;
          *((_OWORD *)v61 + 2) = v64;
          *(_OWORD *)v61 = v62;
          *(_OWORD *)(v61 + 52) = *(_OWORD *)(v60 + 52);
          *(_OWORD *)(v61 + 68) = *(_OWORD *)(v60 + 68);
          v65 = *(_QWORD *)(v60 + 88);
          v61[96] = *(_BYTE *)(v60 + 96);
          *((_QWORD *)v61 + 11) = v65;
          v61 += 104;
        }
        *((_QWORD *)this + 20) = v61;
        v60 += 104;
      }
      while (v60 != *((_QWORD *)this + 11));
    }
  }
  else if (v60 != v59)
  {
    do
    {
      CA::WindowServer::FlipBook::reuse_frame(this, (_QWORD *)v60);
      v60 += 104;
    }
    while (v60 != *((_QWORD *)this + 11));
  }
  *((_QWORD *)this + 11) = *((_QWORD *)this + 10);
  CA::WindowServer::FlipBook::collect(this);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 2);
}

CA::Render::Context *CA::WindowServer::FlipBook::invalidate_context(CA::Render::Context *this)
{
  CA::Render::Context *v1;
  CA::Render::Context *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  if ((_DWORD)this)
  {
    this = (CA::Render::Context *)CA::Render::Context::context_by_id(this);
    if (this)
    {
      v2 = this;
      this = (CA::Render::Context *)CA::WindowServer::FlipBook::invalidate_context(this, v1);
      v3 = (unsigned int *)((char *)v2 + 8);
      do
      {
        v4 = __ldaxr(v3);
        v5 = v4 - 1;
      }
      while (__stlxr(v5, v3));
      if (!v5)
        return (CA::Render::Context *)(*(uint64_t (**)(CA::Render::Context *))(*(_QWORD *)v2 + 16))(v2);
    }
  }
  return this;
}

uint64_t CA::WindowServer::FlipBook::invalidate_context(CA::WindowServer::FlipBook *this, CA::Render::Context *a2)
{
  pthread_mutex_t *v3;
  uint64_t v4;

  v3 = (pthread_mutex_t *)((char *)this + 72);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 72));
  v4 = CA::Render::Context::root_layer_handle(this);
  if (v4)
  {
    *(_QWORD *)(v4 + 96) |= 7uLL;
    *(_DWORD *)(v4 + 12) |= 0x400u;
  }
  return pthread_mutex_unlock(v3);
}

void CA::WindowServer::FlipBook::copy_surface(uint64_t a1, IOSurfaceRef buffer, char a3, mach_port_t *a4)
{
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  float *v11;
  const __CFString *v12;
  __IOSurface *iosurface_with_pixel_format;
  float *v14;

  if (*(_DWORD *)(a1 + 292) == 1)
    buffer = (IOSurfaceRef)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 152))(a1, a3 & 1);
  if (buffer)
  {
    v7 = *(_QWORD *)(a1 + 16);
    v8 = *(_DWORD *)(v7 + 176);
    v9 = *(_DWORD *)(v7 + 180);
    if (CADeviceUseCIF10::once != -1)
      dispatch_once(&CADeviceUseCIF10::once, &__block_literal_global_9735);
    if (CADeviceUseCIF10::enable_cif10)
      v10 = 1999843442;
    else
      v10 = 1111970369;
    v11 = CA::WindowServer::IOSurface::wrap_buffer(*(CA::WindowServer::IOSurface **)(a1 + 16), buffer, 0, 0);
    iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format((CA::Render *)v10, v8, v9, 0, 0, 0, v12);
    v14 = CA::WindowServer::IOSurface::wrap_buffer(*(CA::WindowServer::IOSurface **)(a1 + 16), iosurface_with_pixel_format, 0, 0);
    (*(void (**)(float *, float *, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)v14 + 176))(v14, v11, 4096, 0, 0, 0, 0, 1.0);
    *a4 = IOSurfaceCreateMachPort(iosurface_with_pixel_format);
    CA::WindowServer::Surface::unref((CA::WindowServer::Surface *)v11);
    CA::WindowServer::Surface::unref((CA::WindowServer::Surface *)v14);
    CFRelease(iosurface_with_pixel_format);
  }
}

__n128 std::vector<CA::WindowServer::FlipBook::Frame>::__insert_with_size[abi:nn180100]<std::__wrap_iter<CA::WindowServer::FlipBook::Frame*>,std::__wrap_iter<CA::WindowServer::FlipBook::Frame*>>(unint64_t *a1, uint64_t a2, __int128 *a3, __int128 *a4, uint64_t a5)
{
  __int128 *v6;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  __int128 *v17;
  __int128 *v18;
  unint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __n128 result;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  __int128 *v48;
  unint64_t v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  uint64_t v63;

  if (a5 < 1)
    return result;
  v6 = a3;
  v9 = (char *)*a1;
  v8 = a1[1];
  v10 = (uint64_t)(a2 - *a1) / 104;
  v11 = *a1 + 104 * v10;
  v12 = a1[2];
  if (0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v12 - v8) >> 3) >= a5)
  {
    if (0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v8 - v11) >> 3) >= a5)
    {
      v17 = (__int128 *)((char *)a3 + 104 * a5);
      v19 = a1[1];
    }
    else
    {
      v17 = (__int128 *)((char *)a3 + 8 * ((uint64_t)(v8 - v11) >> 3));
      if (v17 == a4)
      {
        v19 = a1[1];
      }
      else
      {
        v18 = (__int128 *)((char *)a3 + 8 * ((uint64_t)(v8 - v11) >> 3));
        v19 = a1[1];
        do
        {
          v20 = *v18;
          v21 = v18[1];
          v22 = v18[2];
          *(_DWORD *)(v19 + 48) = *((_DWORD *)v18 + 12);
          *(_OWORD *)(v19 + 16) = v21;
          *(_OWORD *)(v19 + 32) = v22;
          *(_OWORD *)v19 = v20;
          *(_OWORD *)(v19 + 52) = *(__int128 *)((char *)v18 + 52);
          result = *(__n128 *)((char *)v18 + 68);
          *(__n128 *)(v19 + 68) = result;
          v24 = *((_QWORD *)v18 + 11);
          *(_BYTE *)(v19 + 96) = *((_BYTE *)v18 + 96);
          *(_QWORD *)(v19 + 88) = v24;
          v19 += 104;
          v18 = (__int128 *)((char *)v18 + 104);
        }
        while (v18 != a4);
      }
      a1[1] = v19;
      if ((uint64_t)(v8 - v11) < 1)
        return result;
    }
    v47 = v11 + 104 * a5;
    v48 = (__int128 *)(v19 - 104 * a5);
    v49 = v19;
    if ((unint64_t)v48 < v8)
    {
      v49 = v19;
      do
      {
        v50 = *v48;
        v51 = v48[1];
        v52 = v48[2];
        *(_DWORD *)(v49 + 48) = *((_DWORD *)v48 + 12);
        *(_OWORD *)(v49 + 16) = v51;
        *(_OWORD *)(v49 + 32) = v52;
        *(_OWORD *)v49 = v50;
        *(_OWORD *)(v49 + 52) = *(__int128 *)((char *)v48 + 52);
        result = *(__n128 *)((char *)v48 + 68);
        *(__n128 *)(v49 + 68) = result;
        v53 = *((_QWORD *)v48 + 11);
        *(_BYTE *)(v49 + 96) = *((_BYTE *)v48 + 96);
        *(_QWORD *)(v49 + 88) = v53;
        v49 += 104;
        v48 = (__int128 *)((char *)v48 + 104);
      }
      while ((unint64_t)v48 < v8);
    }
    a1[1] = v49;
    if (v19 != v47)
    {
      v54 = 8 * ((uint64_t)(v19 - v47) >> 3);
      v55 = v19 - 52;
      do
      {
        v56 = *(_OWORD *)(v11 + v54 - 104);
        v57 = *(_OWORD *)(v11 + v54 - 88);
        v58 = *(_OWORD *)(v11 + v54 - 72);
        *(_DWORD *)(v55 - 4) = *(_DWORD *)(v11 + v54 - 56);
        *(_OWORD *)(v55 - 20) = v58;
        *(_OWORD *)(v55 - 36) = v57;
        *(_OWORD *)(v55 - 52) = v56;
        *(_OWORD *)v55 = *(_OWORD *)(v11 + v54 - 52);
        result = *(__n128 *)(v11 + v54 - 36);
        *(__n128 *)(v55 + 16) = result;
        v59 = *(_QWORD *)(v11 + v54 - 16);
        *(_BYTE *)(v55 + 44) = *(_BYTE *)(v11 + v54 - 8);
        *(_QWORD *)(v55 + 36) = v59;
        v55 -= 104;
        v54 -= 104;
      }
      while (v54);
    }
    if (v17 != a3)
    {
      do
      {
        v60 = *v6;
        v61 = v6[1];
        v62 = v6[2];
        *(_DWORD *)(v11 + 48) = *((_DWORD *)v6 + 12);
        *(_OWORD *)(v11 + 16) = v61;
        *(_OWORD *)(v11 + 32) = v62;
        *(_OWORD *)v11 = v60;
        *(_OWORD *)(v11 + 52) = *(__int128 *)((char *)v6 + 52);
        result = *(__n128 *)((char *)v6 + 68);
        *(__n128 *)(v11 + 68) = result;
        v63 = *((_QWORD *)v6 + 11);
        *(_BYTE *)(v11 + 96) = *((_BYTE *)v6 + 96);
        *(_QWORD *)(v11 + 88) = v63;
        v6 = (__int128 *)((char *)v6 + 104);
        v11 += 104;
      }
      while (v6 != v17);
    }
  }
  else
  {
    v13 = a5 + 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v8 - (_QWORD)v9) >> 3);
    if (v13 > 0x276276276276276)
      abort();
    v14 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v12 - (_QWORD)v9) >> 3);
    if (2 * v14 > v13)
      v13 = 2 * v14;
    if (v14 >= 0x13B13B13B13B13BLL)
      v15 = 0x276276276276276;
    else
      v15 = v13;
    if (v15)
      v15 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::WindowServer::FlipBook::Frame>>(v15);
    else
      v16 = 0;
    v25 = v15 + 104 * v10;
    v26 = v25 + 104 * a5;
    v27 = v25;
    do
    {
      v28 = *v6;
      v29 = v6[1];
      v30 = v6[2];
      *(_DWORD *)(v27 + 48) = *((_DWORD *)v6 + 12);
      *(_OWORD *)(v27 + 16) = v29;
      *(_OWORD *)(v27 + 32) = v30;
      *(_OWORD *)v27 = v28;
      *(_OWORD *)(v27 + 52) = *(__int128 *)((char *)v6 + 52);
      result = *(__n128 *)((char *)v6 + 68);
      *(__n128 *)(v27 + 68) = result;
      v31 = *((_QWORD *)v6 + 11);
      *(_BYTE *)(v27 + 96) = *((_BYTE *)v6 + 96);
      *(_QWORD *)(v27 + 88) = v31;
      v27 += 104;
      v6 = (__int128 *)((char *)v6 + 104);
    }
    while (v27 != v26);
    v32 = (char *)*a1;
    if (v11 != *a1)
    {
      v33 = 104 * v10;
      v34 = v15;
      do
      {
        v35 = v34 + v33;
        v36 = *(_OWORD *)&v9[v33 - 104];
        v37 = *(_OWORD *)&v9[v33 - 88];
        v38 = *(_OWORD *)&v9[v33 - 72];
        *(_DWORD *)(v35 - 56) = *(_DWORD *)&v9[v33 - 56];
        *(_OWORD *)(v35 - 72) = v38;
        *(_OWORD *)(v35 - 88) = v37;
        *(_OWORD *)(v35 - 104) = v36;
        *(_OWORD *)(v35 - 52) = *(_OWORD *)&v9[v33 - 52];
        result = *(__n128 *)&v9[v33 - 36];
        *(__n128 *)(v35 - 36) = result;
        v39 = *(_QWORD *)&v9[v33 - 16];
        *(_BYTE *)(v35 - 8) = v9[v33 - 8];
        *(_QWORD *)(v35 - 16) = v39;
        v34 -= 104;
        v9 -= 104;
      }
      while (&v9[v33] != v32);
      v25 = v34 + 104 * v10;
    }
    v40 = v15 + 104 * v16;
    v41 = a1[1];
    while (v11 != v41)
    {
      v42 = *(_OWORD *)v11;
      v43 = *(_OWORD *)(v11 + 16);
      v44 = *(_OWORD *)(v11 + 32);
      *(_DWORD *)(v26 + 48) = *(_DWORD *)(v11 + 48);
      *(_OWORD *)(v26 + 16) = v43;
      *(_OWORD *)(v26 + 32) = v44;
      *(_OWORD *)v26 = v42;
      *(_OWORD *)(v26 + 52) = *(_OWORD *)(v11 + 52);
      result = *(__n128 *)(v11 + 68);
      *(__n128 *)(v26 + 68) = result;
      v45 = *(_QWORD *)(v11 + 88);
      *(_BYTE *)(v26 + 96) = *(_BYTE *)(v11 + 96);
      *(_QWORD *)(v26 + 88) = v45;
      v26 += 104;
      v11 += 104;
    }
    v46 = (void *)*a1;
    *a1 = v25;
    a1[1] = v26;
    a1[2] = v40;
    if (v46)
      operator delete(v46);
  }
  return result;
}

uint64_t std::vector<CA::WindowServer::FlipBook::Frame>::erase(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  char v8;

  if (a2 != a3)
  {
    v3 = *(_QWORD *)(result + 8);
    if (a3 != v3)
    {
      v4 = 8 * ((a3 - a2) >> 3);
      do
      {
        v5 = *(_OWORD *)(a2 + v4);
        v6 = *(_OWORD *)(a2 + v4 + 16);
        v7 = *(_OWORD *)(a2 + v4 + 32);
        *(_DWORD *)(a2 + 48) = *(_DWORD *)(a2 + v4 + 48);
        *(_OWORD *)(a2 + 16) = v6;
        *(_OWORD *)(a2 + 32) = v7;
        *(_OWORD *)a2 = v5;
        *(_OWORD *)(a2 + 52) = *(_OWORD *)(a2 + v4 + 52);
        *(_OWORD *)(a2 + 68) = *(_OWORD *)(a2 + v4 + 68);
        v8 = *(_BYTE *)(a2 + v4 + 96);
        *(_QWORD *)(a2 + 88) = *(_QWORD *)(a2 + v4 + 88);
        *(_BYTE *)(a2 + 96) = v8;
        a2 += 104;
      }
      while (a2 + v4 != v3);
    }
    *(_QWORD *)(result + 8) = a2;
  }
  return result;
}

void CA::WindowServer::FlipBook::free_surfaces(os_unfair_lock_s *this)
{
  uint64_t v2;
  double v3;
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  NSObject *v28;
  uint64_t v29;
  double v30;
  unint64_t v31;
  double v32;
  double v33;
  double v34;
  double v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  os_unfair_lock_s *lock;
  uint8_t buf[4];
  uint64_t v43;
  __int16 v44;
  double v45;
  __int16 v46;
  double v47;
  __int16 v48;
  char *v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  lock = this + 2;
  os_unfair_lock_lock(this + 2);
  v2 = mach_absolute_time();
  v3 = CATimeWithHostTime(v2);
  v4 = *(char **)&this[20]._os_unfair_lock_opaque;
  v5 = *(char **)&this[22]._os_unfair_lock_opaque;
  v6 = *(_QWORD *)&this[26]._os_unfair_lock_opaque;
  v7 = *(_QWORD *)&this[28]._os_unfair_lock_opaque;
  v9 = *(_QWORD *)&this[32]._os_unfair_lock_opaque;
  v8 = *(_QWORD *)&this[34]._os_unfair_lock_opaque;
  v39 = *(_QWORD *)&this[38]._os_unfair_lock_opaque;
  v40 = *(_QWORD *)&this[40]._os_unfair_lock_opaque;
  v10 = v5 - v4;
  if (v5 == v4)
  {
    v12 = *(_QWORD **)&this[28]._os_unfair_lock_opaque;
    v11 = *(_QWORD **)&this[26]._os_unfair_lock_opaque;
  }
  else
  {
    do
    {
      CA::WindowServer::FlipBook::free_surface(this, v4);
      v4 += 104;
    }
    while (v4 != v5);
    v5 = *(char **)&this[20]._os_unfair_lock_opaque;
    v11 = *(_QWORD **)&this[26]._os_unfair_lock_opaque;
    v12 = *(_QWORD **)&this[28]._os_unfair_lock_opaque;
  }
  v13 = v7 - v6;
  v14 = v10 >> 3;
  *(_QWORD *)&this[22]._os_unfair_lock_opaque = v5;
  if (v11 != v12)
  {
    do
    {
      CA::WindowServer::FlipBook::free_surface(this, v11);
      v11 += 13;
    }
    while (v11 != v12);
    v12 = *(_QWORD **)&this[26]._os_unfair_lock_opaque;
  }
  v15 = v8 - v9;
  v16 = 0x4EC4EC4EC4EC4EC5 * v14;
  v17 = v13 >> 3;
  *(_QWORD *)&this[28]._os_unfair_lock_opaque = v12;
  v18 = *(_QWORD **)&this[32]._os_unfair_lock_opaque;
  v19 = *(_QWORD **)&this[34]._os_unfair_lock_opaque;
  if (v18 != v19)
  {
    do
    {
      CA::WindowServer::FlipBook::free_surface(this, v18);
      v18 += 13;
    }
    while (v18 != v19);
    v18 = *(_QWORD **)&this[32]._os_unfair_lock_opaque;
  }
  v20 = v16 + 0x4EC4EC4EC4EC4EC5 * v17;
  v21 = v15 >> 3;
  *(_QWORD *)&this[34]._os_unfair_lock_opaque = v18;
  v22 = *(_QWORD **)&this[38]._os_unfair_lock_opaque;
  v23 = *(_QWORD **)&this[40]._os_unfair_lock_opaque;
  if (v22 != v23)
  {
    do
    {
      CA::WindowServer::FlipBook::free_surface(this, v22);
      v22 += 13;
    }
    while (v22 != v23);
    v22 = *(_QWORD **)&this[38]._os_unfair_lock_opaque;
  }
  v24 = v20 + 0x4EC4EC4EC4EC4EC5 * v21;
  v25 = *(_QWORD *)&this[44]._os_unfair_lock_opaque;
  *(_QWORD *)&this[40]._os_unfair_lock_opaque = v22;
  if (v25)
  {
    CA::WindowServer::FlipBook::free_surface(this, &this[44]._os_unfair_lock_opaque);
    *(_QWORD *)&this[66]._os_unfair_lock_opaque = 0;
    LOBYTE(this[68]._os_unfair_lock_opaque) = 0;
    *(_OWORD *)&this[44]._os_unfair_lock_opaque = 0u;
    *(_OWORD *)&this[48]._os_unfair_lock_opaque = 0u;
    *(_OWORD *)&this[52]._os_unfair_lock_opaque = 0u;
    this[56]._os_unfair_lock_opaque = 0;
  }
  if (x_log_hook_p())
  {
    v26 = mach_absolute_time();
    CATimeWithHostTime(v26);
    v27 = *(_QWORD *)&this[18]._os_unfair_lock_opaque;
    if (v27 >= 0x400)
    {
      v34 = 1.0;
      do
        v34 = v34 * 0.0009765625;
      while (v34 * (double)v27 >= 1024.0);
    }
    x_log_();
  }
  else
  {
    v28 = x_log_category_flipbook;
    if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
    {
      v29 = mach_absolute_time();
      v30 = (CATimeWithHostTime(v29) - v3) * 1000.0;
      v31 = *(_QWORD *)&this[18]._os_unfair_lock_opaque;
      v32 = (double)v31;
      if (v31 >= 0x400)
      {
        v35 = 1.0;
        do
        {
          v35 = v35 * 0.0009765625;
          v33 = v35 * v32;
        }
        while (v35 * v32 >= 1024.0);
      }
      else
      {
        v33 = (double)v31;
      }
      v36 = v31 > 0x3FF;
      if ((v31 & 0xFFFFFFFFFFF00000) != 0)
        ++v36;
      if ((v31 & 0xFFFFFFFFC0000000) != 0)
        ++v36;
      if (v31 >> 40)
        ++v36;
      if (v31 >> 50)
        ++v36;
      if (v31 >> 60)
        v37 = v36 + 1;
      else
        v37 = v36;
      v38 = off_1E15AAF00[v37];
      *(_DWORD *)buf = 134218754;
      v43 = v24 + 0x4EC4EC4EC4EC4EC5 * ((v40 - v39) >> 3);
      v44 = 2048;
      v45 = v30;
      v46 = 2048;
      v47 = v33;
      v48 = 2080;
      v49 = v38;
      _os_log_impl(&dword_184457000, v28, OS_LOG_TYPE_DEFAULT, "%zu surfaces freed in %g ms, memory usage = %.2lf %s", buf, 0x2Au);
    }
  }
  os_unfair_lock_unlock(lock);
}

void CA::WindowServer::FlipBook::recycle(os_unfair_lock_s *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  NSObject *v7;
  uint8_t buf[4];
  unsigned int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (CADeviceSupportsDCP::once[0] != -1)
    dispatch_once(CADeviceSupportsDCP::once, &__block_literal_global_214);
  if (CADeviceSupportsDCP::has_dcp)
  {
    v2 = mach_continuous_time();
    os_unfair_lock_lock(this + 2);
    v3 = *(_QWORD *)&this[32]._os_unfair_lock_opaque;
    v4 = *(_QWORD *)&this[34]._os_unfair_lock_opaque;
    if (v4 == v3)
    {
LABEL_9:
      os_unfair_lock_unlock(this + 2);
      return;
    }
    while (1)
    {
      v5 = v4 - 104;
      if (*(_QWORD *)(v4 - 64) < v2)
      {
        if (((*(uint64_t (**)(os_unfair_lock_s *, uint64_t))(*(_QWORD *)&this->_os_unfair_lock_opaque + 120))(this, v4 - 104) & 1) != 0)
        {
          v6 = *(_DWORD *)(v4 - 56);
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            v7 = x_log_category_flipbook;
            if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 67109120;
              v9 = v6;
              _os_log_impl(&dword_184457000, v7, OS_LOG_TYPE_DEFAULT, "manually recycling swaps prior to %u", buf, 8u);
            }
          }
          os_unfair_lock_unlock(this + 2);
          if (v6)
            CA::WindowServer::FlipBook::swap_completed(this, v6);
          return;
        }
        v3 = *(_QWORD *)&this[32]._os_unfair_lock_opaque;
      }
      v4 -= 104;
      if (v5 == v3)
        goto LABEL_9;
    }
  }
}

void CA::WindowServer::FlipBook::next_frame(CA::WindowServer::FlipBook *this, uint64_t a2, unint64_t a3, unint64_t a4)
{
  char *v8;
  os_unfair_lock_s *v9;
  uint64_t v10;
  uint64_t v11;
  const __CFString *v12;
  uint64_t v13;
  __int128 v14;
  char v15;
  __IOSurface *v16;
  __int128 v17;
  _OWORD v18[3];
  int v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  char v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 12) = 0;
  v8 = (char *)this + 88;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  v9 = (os_unfair_lock_s *)(a2 + 8);
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 8));
  v13 = *(_QWORD *)(a2 + 112);
  if (v13 == *(_QWORD *)(a2 + 104))
  {
    if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(_QWORD *)(a2 + 88) - *(_QWORD *)(a2 + 80)) >> 3)
                          + 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(_QWORD *)(a2 + 136) - *(_QWORD *)(a2 + 128)) >> 3)) < *(_QWORD *)(a2 + 64))
    {
      CA::WindowServer::FlipBook::allocate_frame((CA::WindowServer::FlipBook *)v18, a2, a3, a4, v10, v11, v12);
      v17 = v18[1];
      *(_OWORD *)this = v18[0];
      *((_OWORD *)this + 1) = v17;
      *((_OWORD *)this + 2) = v18[2];
      *((_DWORD *)this + 12) = v19;
      *(_OWORD *)((char *)this + 52) = v20;
      *(_OWORD *)((char *)this + 68) = v21;
      *(_QWORD *)v8 = v22;
      v8[8] = v23;
    }
  }
  else
  {
    if (*(_DWORD *)(a2 + 292) == 1)
      __assert_rtn("next_frame", "windowserver-flipbook.cpp", 1460, "type () != kFlipBookType_DirtyRegionOnly");
    v14 = *(_OWORD *)(v13 - 88);
    *(_OWORD *)this = *(_OWORD *)(v13 - 104);
    *((_OWORD *)this + 1) = v14;
    *((_OWORD *)this + 2) = *(_OWORD *)(v13 - 72);
    *((_DWORD *)this + 12) = *(_DWORD *)(v13 - 56);
    *(_OWORD *)((char *)this + 52) = *(_OWORD *)(v13 - 52);
    *(_OWORD *)((char *)this + 68) = *(_OWORD *)(v13 - 36);
    v8[8] = *(_BYTE *)(v13 - 8);
    *(_QWORD *)v8 = *(_QWORD *)(v13 - 16);
    *(_QWORD *)(a2 + 112) = v13 - 104;
    v15 = *((_BYTE *)this + 96);
    if ((v15 & 2) != 0)
    {
      IOSurfaceSetPurgeable(*(IOSurfaceRef *)this, 0, 0);
      v16 = (__IOSurface *)*((_QWORD *)this + 2);
      if (v16)
        IOSurfaceSetPurgeable(v16, 0, 0);
      *((_BYTE *)this + 96) = v15 & 0xFD;
    }
  }
  os_unfair_lock_unlock(v9);
}

uint64_t CA::WindowServer::FlipBook::allocate_frame(CA::WindowServer::FlipBook *this, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, const __CFString *a7)
{
  unsigned int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  __IOSurface *iosurface_with_pixel_format;
  _QWORD *v15;
  size_t AllocSize;
  unint64_t v17;
  NSObject *v18;
  IOSurfaceID ID;
  unint64_t v20;
  double v21;
  double v22;
  double v23;
  double v24;
  uint64_t v25;
  char *v26;
  uint64_t result;
  const __CFString *v28;
  unsigned int v29;
  __IOSurface *v30;
  _QWORD *v31;
  uint64_t buf;
  uint64_t v33;
  int v34;
  __int16 v35;
  double v36;
  __int16 v37;
  char *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 12) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 1) = 0u;
  if (*(_DWORD *)(a2 + 292))
  {
    if (a3 <= 0x40)
      v9 = 64;
    else
      v9 = a3;
    if (a4 <= 0x40)
      v10 = 64;
    else
      v10 = a4;
  }
  else
  {
    v11 = *(_QWORD *)(a2 + 16);
    v9 = *(_DWORD *)(v11 + 176);
    v10 = *(_DWORD *)(v11 + 180);
  }
  if (CADeviceUseCIF10::once != -1)
    dispatch_once(&CADeviceUseCIF10::once, &__block_literal_global_9735);
  if (CADeviceUseCIF10::enable_cif10)
    v12 = 1999843442;
  else
    v12 = 1111970369;
  v13 = 2 * (*(_DWORD *)(a2 + 292) != 1);
  iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format((CA::Render *)v12, v9, v10, v13, 0, CFSTR("CA Server Flipbook Frame"), a7);
  *(_QWORD *)this = iosurface_with_pixel_format;
  v15 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 88))(a2);
  *((_QWORD *)this + 1) = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD, __IOSurface *))(*(_QWORD *)*v15 + 672))(*v15, 1, 0, 0, iosurface_with_pixel_format);
  *((_DWORD *)this + 13) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 15) = v9;
  *((_DWORD *)this + 16) = v10;
  AllocSize = IOSurfaceGetAllocSize(iosurface_with_pixel_format);
  *((_QWORD *)this + 11) = AllocSize;
  *(_QWORD *)(a2 + 72) += AllocSize;
  if (x_log_hook_p())
  {
    IOSurfaceGetID(iosurface_with_pixel_format);
    v17 = *(_QWORD *)(a2 + 72);
    if (v17 >= 0x400)
    {
      v23 = 1.0;
      do
        v23 = v23 * 0.0009765625;
      while (v23 * (double)v17 >= 1024.0);
    }
    x_log_();
  }
  else
  {
    v18 = x_log_category_flipbook;
    if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
    {
      ID = IOSurfaceGetID(iosurface_with_pixel_format);
      v20 = *(_QWORD *)(a2 + 72);
      v21 = (double)v20;
      if (v20 >= 0x400)
      {
        v24 = 1.0;
        do
        {
          v24 = v24 * 0.0009765625;
          v22 = v24 * v21;
        }
        while (v24 * v21 >= 1024.0);
      }
      else
      {
        v22 = (double)v20;
      }
      v25 = v20 > 0x3FF;
      if ((v20 & 0xFFFFFFFFFFF00000) != 0)
        ++v25;
      if ((v20 & 0xFFFFFFFFC0000000) != 0)
        ++v25;
      if (v20 >> 40)
        ++v25;
      if (v20 >> 50)
        ++v25;
      if (v20 >> 60)
        ++v25;
      v26 = off_1E15AAF00[v25];
      LODWORD(buf) = 67110146;
      HIDWORD(buf) = ID;
      LOWORD(v33) = 1024;
      *(_DWORD *)((char *)&v33 + 2) = v9;
      HIWORD(v33) = 1024;
      v34 = v10;
      v35 = 2048;
      v36 = v22;
      v37 = 2080;
      v38 = v26;
      _os_log_impl(&dword_184457000, v18, OS_LOG_TYPE_DEFAULT, "allocated surface 0x%x, %dx%d for the flipbook, memory usage = %.2lf %s", (uint8_t *)&buf, 0x28u);
    }
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 136))(a2);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)a2 + 144))(&buf, a2);
    if (*(_DWORD *)(a2 + 292) == 1)
      v29 = v13 | 4;
    else
      v29 = v13;
    v30 = CA::Render::create_iosurface_with_pixel_format((CA::Render *)v12, v33, SHIDWORD(v33), v29, 0, CFSTR("CA Server Flipbook Frame DEBUG"), v28);
    *((_QWORD *)this + 2) = v30;
    v31 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 88))(a2);
    result = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD, __IOSurface *))(*(_QWORD *)*v31 + 672))(*v31, 1, 0, 0, v30);
    *((_QWORD *)this + 3) = result;
  }
  return result;
}

void CA::WindowServer::FlipBook::transition_to_state(unsigned __int8 *a1, unsigned int a2, int a3)
{
  os_unfair_lock_s *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  NSObject *v11;
  char *v12;
  char *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint8_t buf[4];
  char *v20;
  __int16 v21;
  char *v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v6 = (os_unfair_lock_s *)(a1 + 12);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 3);
  v7 = a1[24];
  v8 = v7;
  if ((v7 & 4) != 0 && (v8 = v7 & 0xFFFFFFFB, a1[24] = v7 & 0xFB, a2 == 1) && (v7 & 3) == 0)
  {
    v9 = 2;
  }
  else if (a2)
  {
    v9 = a2;
  }
  else
  {
    v9 = (v8 >> 4) & 2;
  }
  v10 = v8 & 3;
  if ((_DWORD)v10 == v9)
    goto LABEL_37;
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v11 = x_log_category_flipbook;
    if (os_log_type_enabled((os_log_t)x_log_category_flipbook, OS_LOG_TYPE_DEFAULT))
    {
      v12 = CA::WindowServer::FlipBook::transition_to_state(CA::WindowServer::FlipBookState,BOOL)::state_to_name[a1[24] & 3];
      v13 = CA::WindowServer::FlipBook::transition_to_state(CA::WindowServer::FlipBookState,BOOL)::state_to_name[v9];
      *(_DWORD *)buf = 136315650;
      v20 = v12;
      v21 = 2080;
      v22 = v13;
      v23 = 1024;
      v24 = a3;
      _os_log_impl(&dword_184457000, v11, OS_LOG_TYPE_DEFAULT, "flipbook transition from %s to %s, has_live_frame %i", buf, 0x1Cu);
    }
  }
  if ((v9 & 0xFFFFFFFD) == 0)
  {
    (*(void (**)(unsigned __int8 *, _QWORD))(*(_QWORD *)a1 + 72))(a1, 0);
    (*(void (**)(unsigned __int8 *, _QWORD))(*(_QWORD *)a1 + 80))(a1, 0);
  }
  v14 = a1[24];
  if (v9 > (v14 & 3))
  {
    if ((v14 & 3) == 0)
    {
      v15 = 0x10000;
      if (!a3)
        v15 = 0;
      (*(void (**)(unsigned __int8 *, unint64_t))(*(_QWORD *)a1 + 16))(a1, v15 | ((unint64_t)v9 << 8) | v10);
      v14 = a1[24];
    }
    if (v9 >= 2 && (v14 & 3) == 1)
    {
      v16 = 512;
      if (a3)
        v16 = 66048;
      (*(void (**)(unsigned __int8 *, uint64_t))(*(_QWORD *)a1 + 32))(a1, v16 | v10);
      goto LABEL_37;
    }
    goto LABEL_35;
  }
  if (v9 <= 1 && (v14 & 3) == 2)
  {
    v17 = 0x10000;
    if (!a3)
      v17 = 0;
    (*(void (**)(unsigned __int8 *, unint64_t))(*(_QWORD *)a1 + 40))(a1, v17 | ((unint64_t)v9 << 8) | v10);
    v14 = a1[24];
  }
  if (v9 || (v14 & 3) != 1)
  {
LABEL_35:
    if (v9 == 1)
    {
      (*(void (**)(unsigned __int8 *, _QWORD))(*(_QWORD *)a1 + 72))(a1, (v14 >> 3) & 1);
      (*(void (**)(unsigned __int8 *, _QWORD))(*(_QWORD *)a1 + 80))(a1, (a1[24] >> 4) & 1);
    }
    goto LABEL_37;
  }
  v18 = 0x10000;
  if (!a3)
    v18 = 0;
  (*(void (**)(unsigned __int8 *, uint64_t))(*(_QWORD *)a1 + 24))(a1, v18 | v10);
LABEL_37:
  os_unfair_lock_unlock(v6);
}

void CA::OGL::MetalContext::~MetalContext(CA::OGL::MetalContext *this)
{
  malloc_zone_t *malloc_zone;

  CA::OGL::MetalContext::~MetalContext(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

{
  _QWORD *v2;
  uint64_t v3;
  void *v4;
  malloc_zone_t *malloc_zone;
  uint64_t v6;
  void *v7;
  malloc_zone_t *v8;
  unint64_t v9;
  void *v10;
  malloc_zone_t *v11;
  void *v12;
  void *v13;
  uint64_t i;
  uint64_t j;
  uint64_t k;
  id *m;
  uint64_t v18;
  uint64_t *v19;
  void *v20;
  malloc_zone_t *v21;
  uint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  id *v25;
  uint64_t v26;
  id *v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  id *v31;
  uint64_t v32;
  id *v33;
  _QWORD *v34;
  _QWORD *v35;
  _QWORD *v36;
  BOOL v37;
  malloc_zone_t *v38;
  unsigned int v39;
  unsigned int v40;
  id *v41;
  uint64_t v42;
  id *v43;
  uint64_t v44;
  void *v45;

  CA::OGL::MetalContext::flush(this, 1);
  objc_msgSend(*((id *)this + 365), "waitUntilCompleted");

  *((_QWORD *)this + 365) = 0;
  CA::OGL::MetalContext::stop_idle_collect_timer(this);
  os_unfair_lock_lock((os_unfair_lock_t)this + 690);
  v2 = (_QWORD *)*((_QWORD *)this + 346);
  if (v2)
  {
    x_hash_table_free(v2);
    *((_QWORD *)this + 346) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 690);

  v3 = *((_QWORD *)this + 350);
  if (v3)
  {
    CA::OGL::MetalContext::delete_image((uint64_t)this, v3);
    v4 = (void *)*((_QWORD *)this + 350);
    if (v4)
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v4);
    }
  }
  v6 = *((_QWORD *)this + 351);
  if (v6)
  {
    CA::OGL::MetalContext::delete_image((uint64_t)this, v6);
    v7 = (void *)*((_QWORD *)this + 351);
    if (v7)
    {
      v8 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v8, v7);
    }
  }
  if (*((_QWORD *)this + 352))
  {
    v9 = 0;
    do
    {
      CA::OGL::MetalContext::delete_image((uint64_t)this, *(_QWORD *)(*((_QWORD *)this + 353) + 8 * v9));
      v10 = *(void **)(*((_QWORD *)this + 353) + 8 * v9);
      if (v10)
      {
        v11 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v11, v10);
      }
      ++v9;
    }
    while (v9 < *((_QWORD *)this + 352));
    free(*((void **)this + 353));
  }
  v12 = (void *)*((_QWORD *)this + 354);
  if (v12)
    free(v12);
  v13 = (void *)*((_QWORD *)this + 356);
  if (v13)
    free(v13);
  dispatch_sync(*((dispatch_queue_t *)this + 494), &__block_literal_global_45);
  CA::OGL::MetalContext::purge_shaders(this);
  dispatch_release(*((dispatch_object_t *)this + 262));
  for (i = 2112; i != 2136; i += 8)

  for (j = 2600; j != 2632; j += 8)
  for (k = 4016; k != 4032; k += 8)

  for (m = (id *)((char *)this + 2576); ; m[3])
  {
    m = (id *)*m;
    if (!m)
      break;
  }

  v18 = *((_QWORD *)this + 499);
  if (v18)
  {
    v19 = *(uint64_t **)(v18 + 48);
    if (v19)
    {
      CA::OGL::MetalBufferPool::retire_metal_buffer(*((_QWORD *)this + 499), *v19);
      v20 = *(void **)(v18 + 48);
      if (v20)
      {
        v21 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v21, v20);
      }
    }
    v22 = *(_QWORD *)(v18 + 248);
    if (*(_QWORD *)(v18 + 256) != v22)
    {
      v23 = *(_QWORD *)(v18 + 272);
      v24 = (_QWORD *)(v22 + 8 * (v23 >> 9));
      v25 = (id *)(*v24 + 8 * (v23 & 0x1FF));
      v26 = *(_QWORD *)(v22 + (((*(_QWORD *)(v18 + 280) + v23) >> 6) & 0x3FFFFFFFFFFFFF8))
          + 8 * ((*(_QWORD *)(v18 + 280) + v23) & 0x1FF);
      while (v25 != (id *)v26)
      {

        if ((id *)((char *)v25 - *v24) == (id *)4096)
        {
          v27 = (id *)v24[1];
          ++v24;
          v25 = v27;
        }
      }
    }
    v28 = *(_QWORD *)(v18 + 296);
    if (*(_QWORD *)(v18 + 304) != v28)
    {
      v29 = *(_QWORD *)(v18 + 320);
      v30 = (_QWORD *)(v28 + 8 * (v29 >> 9));
      v31 = (id *)(*v30 + 8 * (v29 & 0x1FF));
      v32 = *(_QWORD *)(v28 + (((*(_QWORD *)(v18 + 328) + v29) >> 6) & 0x3FFFFFFFFFFFFF8))
          + 8 * ((*(_QWORD *)(v18 + 328) + v29) & 0x1FF);
      while (v31 != (id *)v32)
      {

        if ((id *)((char *)v31 - *v30) == (id *)4096)
        {
          v33 = (id *)v30[1];
          ++v30;
          v31 = v33;
        }
      }
    }
    v34 = *(_QWORD **)(v18 + 336);
    if (v34 != (_QWORD *)(v18 + 344))
    {
      do
      {

        v35 = (_QWORD *)v34[1];
        if (v35)
        {
          do
          {
            v36 = v35;
            v35 = (_QWORD *)*v35;
          }
          while (v35);
        }
        else
        {
          do
          {
            v36 = (_QWORD *)v34[2];
            v37 = *v36 == (_QWORD)v34;
            v34 = v36;
          }
          while (!v37);
        }
        v34 = v36;
      }
      while (v36 != (_QWORD *)(v18 + 344));
    }

    std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(*(_QWORD **)(v18 + 344));
    std::deque<objc_object  {objcproto9MTLBuffer}*>::~deque[abi:nn180100](v18 + 288);
    std::deque<objc_object  {objcproto9MTLBuffer}*>::~deque[abi:nn180100](v18 + 240);
    v38 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v38, (void *)v18);
  }
  dispatch_release(*((dispatch_object_t *)this + 494));
  do
  {
    v39 = __ldaxr(CA::OGL::MetalContext::_context_count);
    v40 = v39 - 1;
  }
  while (__stlxr(v40, CA::OGL::MetalContext::_context_count));
  if (!v40)
  {
    pthread_mutex_lock(&CA::OGL::MetalContext::_library_lock);
    v41 = (id *)CA::OGL::MetalContext::_libraries;
    v42 = qword_1EDD0FC48;
    if (CA::OGL::MetalContext::_libraries != (_UNKNOWN *)qword_1EDD0FC48)
    {
      do

      while (v41 != (id *)v42);
      v41 = (id *)CA::OGL::MetalContext::_libraries;
    }
    qword_1EDD0FC48 = (uint64_t)v41;
    pthread_mutex_unlock(&CA::OGL::MetalContext::_library_lock);
    pthread_mutex_lock(&CA::OGL::MetalContext::_library_lock);
    v43 = (id *)CA::OGL::MetalContext::_binary_archives;
    v44 = qword_1EDD0FC18;
    if (CA::OGL::MetalContext::_binary_archives != (_UNKNOWN *)qword_1EDD0FC18)
    {
      do

      while (v43 != (id *)v44);
      v43 = (id *)CA::OGL::MetalContext::_binary_archives;
    }
    qword_1EDD0FC18 = (uint64_t)v43;
    pthread_mutex_unlock(&CA::OGL::MetalContext::_library_lock);
  }
  v45 = (void *)*((_QWORD *)this + 377);
  if (v45)
  {
    *((_QWORD *)this + 378) = v45;
    operator delete(v45);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)this + 2696);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)this + 2560);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)this + 2056);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 1992));
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)this + 1952);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 1888));
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)this + 1848);
  CA::OGL::Context::~Context(this);
}

void CA::OGL::MetalContext::free_destination_textures(CA::OGL::MetalContext *this, unsigned int a2, void **a3)
{
  uint64_t v4;
  void *v5;

  if (a2)
  {
    v4 = a2;
    do
    {
      v5 = *a3++;

      --v4;
    }
    while (v4);
  }
}

void CA::OGL::MetalContext::set_async_compile_queue(dispatch_object_t *this, NSObject *a2)
{
  if (this[262] != a2)
  {
    CA::OGL::MetalContext::stop_pipeline_queue((CA::OGL::MetalContext *)this);
    dispatch_release(this[262]);
    this[262] = a2;
    dispatch_retain(a2);
  }
}

float CA::OGL::MetalContext::destination_offset(CA::OGL::MetalContext *this)
{
  return (float)*((int *)this + 698);
}

uint64_t CA::OGL::MetalContext::set_metal_state(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  void *v11;
  void *v12;
  double v13;
  double v14;
  double v15;
  double v16;
  __int16 v17;
  _QWORD v19[6];

  v19[5] = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 2928))
    __assert_rtn("set_metal_state", "ogl-metal.mm", 10183, "_command_buffer == nil");
  if (*(_QWORD *)(a1 + 2936))
    __assert_rtn("set_metal_state", "ogl-metal.mm", 10184, "_encoder == nil");
  v4 = *(void **)(a1 + 3008);
  if (v4)
  {

    *(_QWORD *)(a1 + 3008) = 0;
  }
  v5 = *(_QWORD *)(a1 + 248);
  *(_QWORD *)(a1 + 3272) = v5;
  if (*(_QWORD *)a2)
  {
    *(_QWORD *)(a1 + 2928) = *(_QWORD *)a2;
    v6 = *(_QWORD *)(a2 + 32);
    if (v6 != a1)
    {
      *(_QWORD *)(a1 + 3256) = *(_QWORD *)(a2 + 24);
      *(_QWORD *)(a1 + 3264) = v6;
    }
    if ((*(_BYTE *)(a2 + 16) & 1) == 0)
    {
      v7 = *(_QWORD *)(a1 + 3992);
      v8 = (unint64_t *)(a1 + 3976);
      do
      {
        v9 = __ldaxr(v8);
        v10 = v9 + 1;
      }
      while (__stlxr(v10, v8));
      *(_QWORD *)(v7 + 16) = v10;
      *(_DWORD *)(v7 + 40) = 0;
      v11 = *(void **)(a1 + 2928);
      v19[0] = MEMORY[0x1E0C809B0];
      v19[1] = 3221225472;
      v19[2] = ___ZN2CA3OGL12MetalContext26prepare_new_command_bufferEv_block_invoke;
      v19[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
      v19[4] = a1;
      objc_msgSend(v11, "addCompletedHandler:", v19);
    }
    v12 = *(void **)(a2 + 8);
    if (v12)
    {
      if ((*(_WORD *)(v5 + 75) & 0x20) != 0)
        __assert_rtn("set_metal_state", "ogl-metal.mm", 10208, "!surf->needs_clear");
      *(_QWORD *)(a1 + 2936) = v12;
      *(_QWORD *)(a1 + 2960) = objc_msgSend(v12, "methodForSelector:", sel_setRenderPipelineState_);
      *(_QWORD *)(a1 + 2968) = objc_msgSend(*(id *)(a1 + 2936), "methodForSelector:", sel_setFragmentTexture_atIndex_);
      *(_QWORD *)(a1 + 2976) = objc_msgSend(*(id *)(a1 + 2936), "methodForSelector:", sel_setFragmentSamplerState_atIndex_);
      *(_QWORD *)(a1 + 2984) = objc_msgSend(*(id *)(a1 + 2936), "methodForSelector:", sel_setScissorRect_);
      *(_QWORD *)(a1 + 2992) = objc_msgSend(*(id *)(a1 + 2936), "methodForSelector:", sel_drawPrimitives_vertexStart_vertexCount_instanceCount_);
      if (*(_WORD *)(v5 + 214))
      {
        v17 = *(_WORD *)(a1 + 3280);
        if ((v17 & 2) == 0 || byte_1ECDC6AC0)
          goto LABEL_17;
      }
      else
      {
        if (byte_1ECDC6AC0)
        {
LABEL_17:
          CA::OGL::MetalContext::stop_encoders((CA::OGL::MetalContext *)a1);
          return CA::OGL::MetalBufferPool::set_encoder(*(_QWORD *)(a1 + 3992), *(objc_object **)(a1 + 2936));
        }
        v17 = *(_WORD *)(a1 + 3280);
      }
      *(_WORD *)(a1 + 3280) = v17 | 1;
      *(_DWORD *)(a1 + 3248) = 0;
      CA::OGL::MetalContext::update_encoder_state(a1, v5, *(_DWORD *)(a2 + 16), v13, v14, v15, v16);
    }
  }
  return CA::OGL::MetalBufferPool::set_encoder(*(_QWORD *)(a1 + 3992), *(objc_object **)(a1 + 2936));
}

double CA::OGL::MetalContext::get_metal_state(CA::OGL::MetalContext *this, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  __int128 v6;
  void *v7;
  void *v8;
  double result;

  v4 = (void *)*((_QWORD *)this + 376);
  if (v4)
  {

    *((_QWORD *)this + 376) = 0;
  }
  v5 = *((_QWORD *)this + 32);
  if (v5
    && (*(_WORD *)(v5 + 214) && (*((_WORD *)this + 1640) & 2) == 0 || byte_1ECDC6AC0 || *((_QWORD *)this + 409) != v5))
  {
    CA::OGL::MetalContext::stop_encoders(this);
  }
  v6 = *((_OWORD *)this + 183);
  *(_OWORD *)a2 = v6;
  *(_DWORD *)(a2 + 16) = *((_DWORD *)this + 812);
  v7 = (void *)v6;
  if ((_QWORD)v6)
  {
    v8 = (void *)*((_QWORD *)this + 365);
    if ((void *)v6 != v8)
    {

      *((_QWORD *)this + 365) = *((id *)this + 366);
      v7 = (void *)*((_QWORD *)this + 366);
    }
    *(_QWORD *)(a2 + 24) = CA::OGL::MetalContext_FlushSharedState;
    *(_QWORD *)(a2 + 32) = this;
  }
  else
  {
    *(_QWORD *)(a2 + 24) = 0;
    *(_QWORD *)(a2 + 32) = 0;
  }
  CA::OGL::MetalContext::copy_submitted_callbacks((uint64_t)this, v7);
  *((_WORD *)this + 1640) &= ~1u;
  *((_QWORD *)this + 366) = 0;
  *((_QWORD *)this + 367) = 0;
  result = 0.0;
  *((_OWORD *)this + 185) = 0u;
  *((_OWORD *)this + 186) = 0u;
  *((_QWORD *)this + 374) = 0;
  *((_QWORD *)this + 407) = 0;
  *((_QWORD *)this + 409) = 0;
  *((_QWORD *)this + 408) = 0;
  return result;
}

BOOL CA::OGL::MetalContext::compile_shader(void **this, char *a2)
{
  void *v4;
  int v5;
  void *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  id *vertex_shader;
  NSObject *v11;
  uint8_t *v12;
  NSObject *v13;
  void *v14;
  uint64_t v15;
  char *v16;
  NSObject *v17;
  NSObject *v18;
  _BOOL8 v19;
  NSObject *v20;
  malloc_zone_t *malloc_zone;
  unsigned int v23;
  int v24;
  uint64_t v25;
  __int16 v26;
  char *v27;
  char __str[8];
  uint8_t buf[40];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v4 = (void *)MEMORY[0x186DBE2E4]();
  x_set_log_file((FILE *)*MEMORY[0x1E0C80C20]);
  v5 = *a2;
  if ((v5 - 85) < 2)
  {
    v24 = 0;
    *(_QWORD *)buf = a2;
    CA::OGL::MetalContext::decode_segment((_BYTE **)buf, (uint64_t)&v24, byte_1E15A4DB8, 7u);
    if (x_log_hook_p())
    {
      objc_msgSend((id)CA::OGL::MetalContext::VertexShader::Spec::encode_segment((CA::OGL::MetalContext::VertexShader::Spec *)&v24), "UTF8String");
      x_log_();
    }
    else
    {
      v8 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
      {
        v9 = objc_msgSend((id)CA::OGL::MetalContext::VertexShader::Spec::encode_segment((CA::OGL::MetalContext::VertexShader::Spec *)&v24), "UTF8String");
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v9;
        _os_log_impl(&dword_184457000, v8, OS_LOG_TYPE_DEFAULT, "Compiling vertex shader: %s\n", buf, 0xCu);
      }
    }
    vertex_shader = (id *)CA::OGL::MetalContext::create_vertex_shader(this, (const CA::OGL::MetalContext::VertexShader::Spec *)&v24, 0);
    if (x_log_hook_p())
      goto LABEL_24;
    v11 = x_log_category_ogl_metal;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
      goto LABEL_34;
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = vertex_shader;
    v12 = buf;
    goto LABEL_33;
  }
  if (v5 == 84)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    *(_DWORD *)&buf[15] = 0;
    CA::OGL::MetalContext::FragmentShader::Spec::decode_name((CA::OGL::MetalContext::FragmentShader::Spec *)buf, a2);
    if (x_log_hook_p())
    {
      objc_msgSend((id)CA::OGL::MetalContext::FragmentShader::Spec::name((CA::OGL::MetalContext::FragmentShader::Spec *)buf), "UTF8String");
      x_log_();
    }
    else
    {
      v17 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
      {
        v24 = 136315138;
        v25 = objc_msgSend((id)CA::OGL::MetalContext::FragmentShader::Spec::name((CA::OGL::MetalContext::FragmentShader::Spec *)buf), "UTF8String");
        _os_log_impl(&dword_184457000, v17, OS_LOG_TYPE_DEFAULT, "Compiling fragment shader: %s\n", (uint8_t *)&v24, 0xCu);
      }
    }
    vertex_shader = (id *)CA::OGL::MetalContext::create_fragment_shader(this, (const CA::OGL::MetalContext::FragmentShader::Spec *)buf, 0);
    if (x_log_hook_p())
    {
LABEL_24:
      x_log_();
      goto LABEL_34;
    }
    v11 = x_log_category_ogl_metal;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
    {
LABEL_34:
      if (vertex_shader)
      {

        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(malloc_zone, vertex_shader);
      }
      goto LABEL_36;
    }
    v24 = 134217984;
    v25 = (uint64_t)vertex_shader;
    v12 = (uint8_t *)&v24;
LABEL_33:
    _os_log_impl(&dword_184457000, v11, OS_LOG_TYPE_DEFAULT, "Resulting function: %p\n", v12, 0xCu);
    goto LABEL_34;
  }
  if (v5 == 80)
  {
    memset(buf, 0, 32);
    CA::OGL::MetalContext::Pipeline::Spec::decode_name((CA::OGL::MetalContext::Pipeline::Spec *)buf, a2);
    if (x_log_hook_p())
    {
      v6 = (void *)MEMORY[0x1E0CB3940];
      v7 = CA::OGL::MetalContext::Pipeline::Spec::encode_segment((CA::OGL::MetalContext::Pipeline::Spec *)buf);
      objc_msgSend((id)objc_msgSend(v6, "stringWithFormat:", CFSTR("%@_%@"), v7, CA::OGL::MetalContext::FragmentShader::Spec::name((CA::OGL::MetalContext::FragmentShader::Spec *)buf)), "UTF8String");
      x_log_();
    }
    else
    {
      v13 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
      {
        v14 = (void *)MEMORY[0x1E0CB3940];
        v15 = CA::OGL::MetalContext::Pipeline::Spec::encode_segment((CA::OGL::MetalContext::Pipeline::Spec *)buf);
        v24 = 136315138;
        v25 = objc_msgSend((id)objc_msgSend(v14, "stringWithFormat:", CFSTR("%@_%@"), v15, CA::OGL::MetalContext::FragmentShader::Spec::name((CA::OGL::MetalContext::FragmentShader::Spec *)buf)), "UTF8String");
        _os_log_impl(&dword_184457000, v13, OS_LOG_TYPE_DEFAULT, "Compiling render pipeline: %s\n", (uint8_t *)&v24, 0xCu);
      }
    }
    v23 = 32;
    vertex_shader = (id *)CA::OGL::MetalContext::create_pipeline_state((uint64_t)this, (CA::OGL::MetalContext::Pipeline::Spec *)buf, &v23, 0);
    *(_QWORD *)__str = 0;
    CA::OGL::MetalContext::format_new_pipeline_flags_string((CA::OGL::MetalContext *)v23, __str, v16);
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v20 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
      {
        v24 = 134218242;
        v25 = (uint64_t)vertex_shader;
        v26 = 2080;
        v27 = __str;
        _os_log_impl(&dword_184457000, v20, OS_LOG_TYPE_DEFAULT, "Resulting pipeline state: %p (flags=%s)\n", (uint8_t *)&v24, 0x16u);
      }
    }

LABEL_36:
    v19 = vertex_shader != 0;
    goto LABEL_37;
  }
  if (x_log_hook_p())
  {
    x_log_();
LABEL_27:
    v19 = 0;
    goto LABEL_37;
  }
  v18 = x_log_category_ogl_metal;
  v19 = 0;
  if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = a2;
    _os_log_impl(&dword_184457000, v18, OS_LOG_TYPE_DEFAULT, "Unrecognized shader spec: %s\n", buf, 0xCu);
    goto LABEL_27;
  }
LABEL_37:
  objc_autoreleasePoolPop(v4);
  return v19;
}

uint64_t CA::OGL::MetalContext::load_pipeline(id *this, const char *a2)
{
  void *v4;
  char **v5;
  char v6;
  const __CFString *v7;
  const __CFString *v8;
  MTLGPUFamily v9;
  MTLGPUFamily v10;
  uint64_t *v11;
  uint64_t v12;
  void *v13;
  char *v14;
  void *pipeline_state;
  uint64_t v16;
  void *v17;
  const __CFString *v19;
  const __CFString *v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    v11 = &qword_1E159E708;
    v12 = 21200;
    while (1)
    {
      v13 = (void *)MEMORY[0x186DBE2E4]();
      if ((!*((_BYTE *)v11 - 8) || objc_msgSend(this[363], "supportsFamily:", *v11))
        && (!*((_BYTE *)v11 + 8) || (objc_msgSend(this[363], "supportsFamily:", v11[2]) & 1) == 0))
      {
        v21 = 0u;
        v22 = 0u;
        v14 = (char *)*(v11 - 2);
        CA::OGL::MetalContext::Pipeline::Spec::decode_name((CA::OGL::MetalContext::Pipeline::Spec *)&v21, v14);
        if ((BYTE7(v22) & 1) == 0)
        {
          pipeline_state = (void *)CA::OGL::MetalContext::load_pipeline_state((CA::OGL::MetalContext *)this, (NSString *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v14));
          if (!pipeline_state)
          {
            NSLog(CFSTR("Failed to load precompiled pipeline: %s\n"), v14);
            objc_autoreleasePoolPop(v13);
            return 0;
          }

        }
      }
      objc_autoreleasePoolPop(v13);
      v11 += 5;
      v12 -= 40;
      if (!v12)
        return 1;
    }
  }
  if (CA::OGL::MetalContext::get_offline_compilation_index(void)::index_once[0] != -1)
    dispatch_once(CA::OGL::MetalContext::get_offline_compilation_index(void)::index_once, &__block_literal_global_2276);
  v4 = (void *)objc_msgSend((id)CA::OGL::MetalContext::get_offline_compilation_index(void)::index, "objectForKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a2));
  if (!v4)
  {
    NSLog(CFSTR("Pipeline %s does not exist in offline compilation manifest\n"), a2);
    return 0;
  }
  v5 = &(&CA::OGL::MetalContext::offline_compilation_manifest)[5 * (int)objc_msgSend(v4, "intValue")];
  v6 = *((_BYTE *)v5 + 24);
  v7 = (const __CFString *)v5[4];
  if (((_BYTE)v5[1] & 1) != 0)
  {
    v8 = (const __CFString *)v5[2];
    if ((objc_msgSend(this[363], "supportsFamily:", v8) & 1) == 0)
    {
      v20 = CA::OGL::mtl_gpu_family_name(v8, v9);
      NSLog(CFSTR("Pipeline %s requires %@\n"), a2, v20);
      return 0;
    }
  }
  if ((v6 & 1) != 0 && objc_msgSend(this[363], "supportsFamily:", v7))
  {
    v19 = CA::OGL::mtl_gpu_family_name(v7, v10);
    NSLog(CFSTR("Pipeline %s excludes %@\n"), a2, v19);
    return 0;
  }
  v16 = CA::OGL::MetalContext::load_pipeline_state((CA::OGL::MetalContext *)this, (NSString *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a2));
  if (!v16)
  {
    NSLog(CFSTR("Failed to load precompiled pipeline: %s\n"), a2);
    return 0;
  }
  v17 = (void *)v16;
  NSLog(CFSTR("Pipeline %s loaded successfully\n"), a2);

  return 1;
}

void CA::OGL::MetalContext::warmup_shaders(id *this)
{
  os_signpost_id_t v2;
  NSObject *v3;
  uint64_t v4;
  double v5;
  int v6;
  unsigned int v7;
  int v8;
  void *v9;
  void *v10;
  uint64_t v11;
  int can_generate_mipmaps_for_format;
  MTLPixelFormat v13;
  void *v14;
  id v15;
  MTLPixelFormat v16;
  void *v17;
  uint64_t v18;
  CA::OGL::MetalContext *v19;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  uint64_t j;
  unsigned int v26;
  uint64_t tile_pipeline;
  unint64_t v28;
  unint64_t v29;
  void *v30;
  int64x2_t v31;
  int k;
  id v33;
  id v34;
  char v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t i;
  uint64_t v42;
  void *v43;
  uint64_t *v44;
  uint64_t v45;
  malloc_zone_t *malloc_zone;
  CA::OGL::MetalContext::Pipeline *v47;
  CA::OGL::MetalContext::Pipeline *v48;
  dispatch_queue_t *v49;
  CA::OGL::MetalContext::Pipeline *v50;
  uint64_t v51;
  NSObject *v52;
  os_signpost_id_t v53;
  void *v54;
  id v55;
  uint64_t v56;
  CA::OGL::MetalContext *v57;
  id v58;
  id v59;
  int v60;
  void *context;
  uint64_t v62;
  int64x2_t v63;
  id v64;
  uint64_t v65;
  int64x2_t v66;
  _QWORD block[5];
  int64x2_t v68;
  uint64_t v69;
  int64x2_t v70;
  uint64_t v71;
  _QWORD v72[3];
  _QWORD v73[3];
  int64x2_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  _QWORD v78[3];
  BOOL v79;
  MTLPixelFormat v80;
  _QWORD v81[7];
  __int128 v82;
  __int128 v83;
  __int128 v84;
  uint64_t v85;
  int v86;
  __int128 v87;
  __int128 v88;
  _QWORD buf[2];
  __int128 v90;
  __int128 v91;
  uint64_t v92;
  uint64_t v93;

  v93 = *MEMORY[0x1E0C80C00];
  v2 = os_signpost_id_generate((os_log_t)x_log_category_ogl_metal);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = x_log_category_ogl_metal;
    if (os_signpost_enabled((os_log_t)x_log_category_ogl_metal))
    {
      LOWORD(buf[0]) = 0;
      _os_signpost_emit_with_name_impl(&dword_184457000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "WarmupShaders", (const char *)&unk_18479AB47, (uint8_t *)buf, 2u);
    }
  }
  v4 = mach_absolute_time();
  v5 = CATimeWithHostTime(v4);
  v92 = 0;
  v90 = 0u;
  v91 = 0u;
  *(_OWORD *)buf = 0u;
  if (CADeviceUseCIF10::once != -1)
    dispatch_once(&CADeviceUseCIF10::once, &__block_literal_global_9735);
  v6 = CADeviceUseCIF10::enable_cif10;
  v53 = v2;
  if (CADeviceUseCIF10::enable_cif10)
  {
    if (CADeviceUseCompression::once != -1)
      dispatch_once(&CADeviceUseCompression::once, &__block_literal_global_15);
    if (CADeviceUseCompression::enable_compression)
    {
      buf[0] = 552;
      v7 = 1;
    }
    else
    {
      v7 = 0;
    }
    v8 = v7 + 1;
    *(_QWORD *)((unint64_t)buf | (8 * v7)) = 115;
    if (CADeviceIsVirtualized::once[0] != -1)
      dispatch_once(CADeviceIsVirtualized::once, &__block_literal_global_204);
    if (!CADeviceIsVirtualized::is_virtualized)
    {
      buf[v8] = 550;
      v8 = v7 | 2;
    }
    v6 = v8 + 1;
    buf[v8] = 554;
  }
  *(_OWORD *)&buf[v6] = xmmword_18474E4C0;
  v56 = (v6 + 3);
  buf[v6 + 2] = 30;
  v54 = (void *)MEMORY[0x186DBE2E4]();
  v9 = (void *)objc_msgSend((id)objc_msgSend(this[363], "newCommandQueue"), "commandBuffer");
  v10 = (void *)objc_msgSend(MEMORY[0x1E0CC6B50], "renderPassDescriptor");
  objc_msgSend(v10, "setFineGrainedBackgroundVisibilityEnabled:", 1);
  v55 = (id)objc_msgSend(this[363], "newBufferWithLength:options:", 1024, 0);
  v11 = 0;
  v66 = vdupq_n_s64(8uLL);
  v63 = vdupq_n_s64(0x20uLL);
  v57 = (CA::OGL::MetalContext *)this;
  do
  {
    context = (void *)MEMORY[0x186DBE2E4]();
    v62 = v11;
    v80 = buf[v11];
    v79 = 0;
    can_generate_mipmaps_for_format = CA::OGL::MetalContext::can_generate_mipmaps_for_format((CA::OGL::MetalContext *)this, &v80, &v79);
    v13 = v80;
    v60 = can_generate_mipmaps_for_format;
    v14 = (void *)objc_msgSend(MEMORY[0x1E0CC6BB0], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", v80, 776, 24);
    objc_msgSend(v14, "setUsage:", 5);
    objc_msgSend(v14, "setStorageMode:", 2);
    v15 = (id)objc_msgSend(this[363], "newTextureWithDescriptor:", v14);
    objc_msgSend(v14, "setAllowGPUOptimizedContents:", 0);
    v58 = (id)objc_msgSend(this[363], "newTextureWithDescriptor:", v14);
    objc_msgSend(v14, "setAllowGPUOptimizedContents:", 1);
    v59 = v15;
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v10, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setTexture:", v15);
    if (((_WORD)this[410] & 8) != 0)
    {
      v35 = 1;
      while (1)
      {
        v36 = v35;
        if ((uint64_t)v13 <= (uint64_t)(MTLPixelFormatBGRA8Unorm_sRGB|0x8))
          break;
        v37 = 110;
        if (v13 != MTLPixelFormatRGB10A2Unorm && v13 != MTLPixelFormatBGR10A2Unorm)
        {
          if (v13 != MTLPixelFormatBGR10_XR)
            goto LABEL_58;
          if (CADeviceIsVirtualized::once[0] != -1)
            dispatch_once(CADeviceIsVirtualized::once, &__block_literal_global_204);
          if (CADeviceIsVirtualized::is_virtualized)
            v37 = 115;
          else
            v37 = 550;
        }
LABEL_59:
        v38 = CA::OGL::non_srgb_pixel_format(v37, v16);
        if ((v36 & 1) != 0)
        {
          v39 = 0;
        }
        else
        {
          v39 = 2;
          if (v38 != 125 && v38 != 115)
            goto LABEL_19;
        }
        objc_msgSend(v14, "setPixelFormat:", v38);
        objc_msgSend(v14, "setStorageMode:", 3);
        objc_msgSend((id)objc_msgSend((id)objc_msgSend(v10, "colorAttachments"), "objectAtIndexedSubscript:", 1), "setTexture:", (id)objc_msgSend(this[363], "newTextureWithDescriptor:", v14));
        objc_msgSend((id)objc_msgSend((id)objc_msgSend(v10, "colorAttachments"), "objectAtIndexedSubscript:", 1), "setLoadAction:", v39);
        v40 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(v10, "colorAttachments"), "objectAtIndexedSubscript:", 1), "setStoreAction:", 0);
        for (i = 0; i != 3; ++i)
        {
          v42 = qword_184752500[i];
          v43 = (void *)MEMORY[0x186DBE2E4](v40);
          objc_msgSend((id)objc_msgSend((id)objc_msgSend(v10, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setLoadAction:", v42);
          objc_msgSend((id)objc_msgSend(v9, "renderCommandEncoderWithDescriptor:", v10), "endEncoding");
          objc_autoreleasePoolPop(v43);
        }
        v35 = 0;
        if ((v36 & 1) == 0)
          goto LABEL_19;
      }
      switch(v13)
      {
        case MTLPixelFormatR8Unorm:
          v37 = 30;
          goto LABEL_59;
        case MTLPixelFormatBGR5A1Unorm:
          v37 = 80;
          goto LABEL_59;
        case MTLPixelFormatRG16Uint:
          v37 = 113;
          goto LABEL_59;
      }
LABEL_58:
      v37 = v13;
      goto LABEL_59;
    }
LABEL_19:
    if ((*((_BYTE *)this + 2678) & 0x20) != 0)
    {
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v10, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setLoadAction:", 1);
      v17 = (void *)objc_msgSend(v9, "renderCommandEncoderWithDescriptor:", v10);
      objc_msgSend(v14, "setUsage:", 7);
      objc_msgSend(v14, "setStorageMode:", 2);
      v64 = (id)objc_msgSend(this[363], "newTextureWithDescriptor:", v14);
      v65 = v13;
      v18 = 0;
      v19 = (CA::OGL::MetalContext *)this;
      do
      {
        v20 = byte_184752518[v18];
        v21 = *((unsigned __int8 *)&CA::OGL::MetalContext::tile_shader_type_info
              + 16 * byte_184752518[v18]
              + 8);
        LODWORD(v87) = 0;
        v22 = objc_msgSend(v17, "tileWidth") / v21;
        v23 = objc_msgSend(v17, "tileHeight") / v21;
        objc_msgSend(v17, "setRenderPipelineState:", CA::OGL::MetalContext::get_tile_pipeline((uint64_t)v19, v20, v65));
        objc_msgSend(v17, "setTileTexture:atIndex:", v64, 0);
        objc_msgSend(v17, "setTileBytes:length:atIndex:", &v87, 4, 0);
        v78[0] = v22;
        v78[1] = v23;
        v78[2] = 1;
        objc_msgSend(v17, "dispatchThreadsPerTile:", v78);
        ++v18;
      }
      while (v18 != 3);
      v24 = *((_DWORD *)v19 + 669);
      v13 = v65;
      if ((v24 & 0x800000) != 0)
      {
        for (j = 0; j != 7; ++j)
        {
          v26 = byte_18475251B[j];
          v77 = 0;
          v76 = 0;
          objc_msgSend(v17, "setRenderPipelineState:", CA::OGL::MetalContext::get_tile_pipeline((uint64_t)v57, v26, v65));
          objc_msgSend(v17, "setTileTexture:atIndex:", v64, 0);
          objc_msgSend(v17, "setTileBytes:length:atIndex:", &v76, 12, 0);
          objc_msgSend(v17, "setTileBytes:length:atIndex:", &v87, 54, 1);
          v74 = v63;
          v75 = 1;
          objc_msgSend(v17, "dispatchThreadsPerTile:", &v74);
        }
        v24 = *((_DWORD *)v57 + 669);
      }
      if ((v24 & 0x1000000) != 0)
      {
        tile_pipeline = CA::OGL::MetalContext::get_tile_pipeline((uint64_t)v57, 0xBu, v65);
        v28 = (unint64_t)objc_msgSend(v17, "tileWidth") >> 1;
        v29 = (unint64_t)objc_msgSend(v17, "tileHeight") >> 1;
        *(_QWORD *)&v87 = 2097184;
        objc_msgSend(v17, "setRenderPipelineState:", tile_pipeline);
        objc_msgSend(v17, "setTileBuffer:offset:atIndex:", v55, 0, 2);
        objc_msgSend(v17, "setTileBytes:length:atIndex:", &v87, 8, 0);
        v73[0] = v28;
        v73[1] = v29;
        v73[2] = 1;
        objc_msgSend(v17, "dispatchThreadsPerTile:", v73);
      }
      objc_msgSend(v17, "endEncoding");
    }
    v30 = (void *)objc_msgSend(v9, "blitCommandEncoder");
    v31 = v66;
    if (v13 != 550)
    {
      for (k = 0; k != 4; ++k)
      {
        if ((k & 1) != 0)
          v33 = v58;
        else
          v33 = v59;
        memset(v72, 0, sizeof(v72));
        v70 = v31;
        v71 = 1;
        if ((k & 2) != 0)
          v34 = v58;
        else
          v34 = v59;
        v68 = v31;
        v69 = 0;
        objc_msgSend(v30, "copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:", v33, 0, 0, v72, &v70, v34, 0, 0, &v68);
        v31 = v66;
      }
    }
    if (v60)
      objc_msgSend(v30, "generateMipmapsForTexture:", v59, *(double *)v31.i64);
    objc_msgSend(v30, "endEncoding", *(double *)v31.i64);
    objc_autoreleasePoolPop(context);
    v11 = v62 + 1;
    this = (id *)v57;
  }
  while (v62 + 1 != v56);
  objc_autoreleasePoolPop(v54);
  v44 = &qword_1E159E708;
  v45 = 21200;
  do
  {
    if ((!*((_BYTE *)v44 - 8) || objc_msgSend(*((id *)v57 + 363), "supportsFamily:", *v44))
      && (!*((_BYTE *)v44 + 8) || (objc_msgSend(*((id *)v57 + 363), "supportsFamily:", v44[2]) & 1) == 0))
    {
      v87 = 0u;
      v88 = 0u;
      CA::OGL::MetalContext::Pipeline::Spec::decode_name((CA::OGL::MetalContext::Pipeline::Spec *)&v87, (char *)*(v44 - 2));
      if (((WORD4(v88) | (BYTE10(v88) << 16)) & 0x20000) == 0)
      {
        if ((BYTE1(v88) & 4) != 0)
        {
          if (byte_1ECDC6AA6)
            goto LABEL_80;
        }
        else if ((CA::OGL::MetalContext::texture_function_info[8 * (BYTE14(v87) & 0x7F) - (BYTE14(v87) & 0x7F)] & 0x3F) == 0)
        {
          goto LABEL_80;
        }
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        v47 = (CA::OGL::MetalContext::Pipeline *)malloc_type_zone_malloc(malloc_zone, 0x18uLL, 0x8BB15036uLL);
        v48 = v47;
        if (v47)
        {
          *(_QWORD *)v47 = 0;
          *((_QWORD *)v47 + 1) = 0;
          *((_WORD *)v47 + 8) = 257;
          v49 = (dispatch_queue_t *)v57;
          v50 = v48;
        }
        else
        {
          MEMORY[0x10] = 1;
          v49 = (dispatch_queue_t *)v57;
          v50 = 0;
        }
        CA::OGL::MetalContext::dispatch_async_pipeline(v49, (const CA::OGL::MetalContext::Pipeline::Spec *)&v87, v50, 1);
        std::__hash_table<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::__unordered_map_hasher<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::__unordered_map_equal<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::allocator<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>>>::__emplace_unique_key_args<CA::OGL::MetalContext::Pipeline::Spec,std::piecewise_construct_t const&,std::tuple<CA::OGL::MetalContext::Pipeline::Spec const&>,std::tuple<>>((float *)v57 + 514, &v87, &v87)[6] = v48;
      }
    }
LABEL_80:
    v44 += 5;
    v45 -= 40;
  }
  while (v45);
  if (CADeviceHasHardwareAcceleratedHDR::once != -1)
    dispatch_once(&CADeviceHasHardwareAcceleratedHDR::once, &__block_literal_global_93);
  v51 = MEMORY[0x1E0C809B0];
  if (!CADeviceHasHardwareAcceleratedHDR::has_capability)
  {
    v52 = *((_QWORD *)v57 + 262);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___ZN2CA3OGL12MetalContext14warmup_shadersEb_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = v57;
    dispatch_async(v52, block);
  }
  v81[0] = v51;
  v81[1] = 3221225472;
  v81[2] = ___ZN2CA3OGL12MetalContext14warmup_shadersEb_block_invoke_2;
  v81[3] = &__block_descriptor_116_e5_v8__0l;
  v81[4] = v57;
  v81[5] = v53;
  *(double *)&v81[6] = v5;
  v86 = v56;
  v82 = *(_OWORD *)buf;
  v83 = v90;
  v84 = v91;
  v85 = v92;
  dispatch_barrier_sync(*((dispatch_queue_t *)v57 + 262), v81);
}

unint64_t CA::OGL::MetalContext::subimage_max_rowbytes(CA::OGL::MetalContext *this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unint64_t result;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;

  if ((*((_BYTE *)this + 2678) & 0x10) == 0)
    return *((_QWORD *)this + 333);
  if (a2 == -1)
    v7 = 1;
  else
    v7 = a2;
  result = CA::Render::format_rowbytes((CA::Render *)v7, a3);
  if (result)
  {
    v8 = result + 16;
    if (a4 >= 0x100)
      v8 = result;
    if (a4 <= 0x7F)
      v8 = result + 32;
    if (a4 <= 0x3F)
      v8 = result + 64;
    v9 = *((_QWORD *)this + 333);
    if (v8 <= v9 || v9 == 0)
      return v8;
    else
      return *((_QWORD *)this + 333);
  }
  return result;
}

void CA::OGL::MetalContext::draw_elements(CA::OGL::Context *a1, int a2, unsigned int a3, unsigned __int16 *a4, char *a5, int a6, int a7)
{
  CA::OGL::MetalContext::draw_elements(a1, a2, a3, a4, a5, a6, a7, 0);
}

void CA::OGL::MetalContext::draw_points(CA::OGL::Context *a1, int a2, unsigned int a3, char *a4)
{
  if (*(unsigned __int8 *)(*((_QWORD *)a1 + 2) + 16) - 82 <= 9)
    __assert_rtn("draw_points", "ogl-metal.mm", 8059, "get_texture_function() < OGL_TEX_PATH_FIRST || get_texture_function() > OGL_TEX_PATH_LAST");
  CA::OGL::MetalContext::draw(a1, 0, a3, 1u, a4, 0x10uLL, 4u, a2, a3, 0, 0, 0);
}

void CA::OGL::MetalContext::stroke_lines(CA::OGL::Context *a1, unsigned int a2, char *a3)
{
  if (*(_BYTE *)(*((_QWORD *)a1 + 2) + 16) != 80)
    __assert_rtn("stroke_lines", "ogl-metal.mm", 8067, "get_texture_function () == OGL_TEX_STROKE_LINE");
  CA::OGL::MetalContext::draw(a1, 4, 4u, a2 >> 1, a3, 8uLL, 8u, 0, a2, 0, 0, 0);
}

void CA::OGL::MetalContext::draw_path_cubics(CA::OGL::Context *a1, int a2, char *a3)
{
  int v3;
  char v4;

  v3 = *(unsigned __int8 *)(*((_QWORD *)a1 + 2) + 16);
  if ((v3 - 84) <= 0xFFFFFFFD)
    __assert_rtn("draw_path_cubics", "ogl-metal.mm", 8076, "get_texture_function () == OGL_TEX_PATH_CUBIC_0 || get_texture_function () == OGL_TEX_PATH_CUBIC_1");
  if (v3 == 82)
    v4 = 1;
  else
    v4 = 3;
  CA::OGL::MetalContext::draw(a1, 4, 4u, a2 << v4, a3, 0x28uLL, 8u, 0, a2, 0, 0, 0);
}

void CA::OGL::MetalContext::draw_path_rects(CA::OGL::Context *a1, unsigned int a2, char *a3)
{
  if (*(_BYTE *)(*((_QWORD *)a1 + 2) + 16) != 84)
    __assert_rtn("draw_path_rects", "ogl-metal.mm", 8086, "get_texture_function () == OGL_TEX_PATH_RECT");
  CA::OGL::MetalContext::draw(a1, 4, 4u, a2, a3, 0x14uLL, 4u, 0, a2, 0, 0, 0);
}

void CA::OGL::MetalContext::draw_path_lines(CA::OGL::Context *a1, int a2, char *a3)
{
  if (*(_BYTE *)(*((_QWORD *)a1 + 2) + 16) != 85)
    __assert_rtn("draw_path_lines", "ogl-metal.mm", 8094, "get_texture_function () == OGL_TEX_PATH_STROKE_LINE");
  CA::OGL::MetalContext::draw(a1, 4, 4u, a2 - 1, a3, 8uLL, 8u, 0, a2, 0, 0, 0);
}

void CA::OGL::MetalContext::draw_path_curves(CA::OGL::Context *a1, int a2, int a3, char *a4)
{
  if (*(_BYTE *)(*((_QWORD *)a1 + 2) + 16) != 86)
    __assert_rtn("draw_path_curves", "ogl-metal.mm", 8103, "get_texture_function () == OGL_TEX_PATH_STROKE_CURVE");
  CA::OGL::MetalContext::draw(a1, 4, 4u, a3 + 32 * a2, a4, 8uLL, 8u, 0, 2 * a3 + 4 * a2, 0, 0, 0);
}

void CA::OGL::MetalContext::draw_path_joins(CA::OGL::Context *a1, unsigned int a2, char *a3)
{
  if (*(unsigned __int8 *)(*((_QWORD *)a1 + 2) + 16) - 87 >= 2)
    __assert_rtn("draw_path_joins", "ogl-metal.mm", 8119, "get_texture_function () == OGL_TEX_PATH_STROKE_MITER_JOIN || get_texture_function () == OGL_TEX_PATH_STROKE_ROUND_JOIN");
  CA::OGL::MetalContext::draw(a1, 4, 4u, a2, a3, 0x18uLL, 8u, 0, a2, 0, 0, 0);
}

void CA::OGL::MetalContext::draw_apl_dimming_factor(CA::OGL::Context *a1, unsigned int a2, char *a3, uint64_t a4)
{
  if (*(_BYTE *)(*((_QWORD *)a1 + 2) + 16) != 99)
    __assert_rtn("draw_apl_dimming_factor", "ogl-metal.mm", 8156, "get_texture_function () == OGL_TEX_APL_DIMMING");
  CA::OGL::MetalContext::draw(a1, 4, a2, 1u, a3, 0x30uLL, 0x10u, 0, a2, 0, 0, a4);
}

uint64_t CA::OGL::MetalContext::insert_event_marker(id *this, const char *a2)
{
  return objc_msgSend(this[367], "insertDebugSignpost:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a2));
}

uint64_t CA::OGL::MetalContext::push_group_marker(id *this, const char *a2)
{
  return objc_msgSend(this[367], "pushDebugGroup:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a2));
}

uint64_t CA::OGL::MetalContext::pop_group_marker(id *this)
{
  return objc_msgSend(this[367], "popDebugGroup");
}

void CA::OGL::MetalContext::bind_overdrive(void **this, unsigned int a2, unsigned int a3, float a4, float a5, CA::OGL *a6, float a7, int *a8, float *a9, float *a10)
{
  CA::OGL::MetalContext *v10;
  float *v11;
  CA::OGL::MetalContext *v18;
  unint64_t v19;
  void *v20;
  const uint8_t *v21;
  size_t v22;
  __int128 v23;
  void *v24;
  uint64_t v25;
  __int128 v26;
  CA::OGL::MetalContext *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  CA::OGL::MetalContext *v36;
  unsigned int v37;
  int v38;
  uint64_t v39;
  size_t v40;
  CA::OGL::MetalContext *v41;
  BOOL v42;
  char v43;
  uint64_t v44;
  unint64_t v45;
  float32x2_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  id v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  CA::OGL::MetalContext *v57;
  uint64_t v58;
  unsigned int v59;
  unsigned int v60;
  float32x2_t v61;
  uint32x2_t v62;
  void *v63;
  unint64_t v64;
  uint64_t v65;
  void *v66;
  float *v67;
  int v68;
  int *v69;
  unint64_t v70;
  uint64_t v71;
  float v72;
  unint64_t v73;
  float v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  float v78;
  float v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v85;
  unint64_t *v87;
  void *v88;
  malloc_zone_t *malloc_zone;
  void *v90;
  void *v91;
  uint64_t v92;
  unsigned int v93;
  unsigned int v94;
  float *v95;
  void *v96;
  int *v97;
  unint64_t v98;
  uint64_t v99;
  float *v100;
  unint64_t v101;
  CA::OGL::MetalContext *v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  id v106;
  __int128 v107;
  _QWORD v108[6];
  uint64_t v109;
  _QWORD v110[3];

  v100 = a10;
  v11 = a9;
  v97 = a8;
  v18 = (CA::OGL::MetalContext *)this;
  v110[1] = *MEMORY[0x1E0C80C00];
  if (ca_debug_lut_changed == 1)
  {
    v10 = (CA::OGL::MetalContext *)this;
    if (this[352])
    {
      v85 = 0;
      v87 = (unint64_t *)(this + 352);
      do
      {
        CA::OGL::MetalContext::delete_image((uint64_t)this, *((_QWORD *)this[353] + v85));
        v88 = (void *)*((_QWORD *)this[353] + v85);
        if (v88)
        {
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(malloc_zone, v88);
        }
        ++v85;
      }
      while (v85 < *v87);
      v10 = (CA::OGL::MetalContext *)this;
      free(this[353]);
      *v87 = 0;
      v87[1] = 0;
    }
    v90 = (void *)*((_QWORD *)v10 + 354);
    if (v90)
    {
      free(v90);
      *((_QWORD *)v10 + 354) = 0;
    }
    v91 = (void *)*((_QWORD *)v10 + 356);
    v11 = a9;
    v18 = v10;
    if (v91)
    {
      free(v91);
      *((_QWORD *)v10 + 356) = 0;
    }
    ca_debug_lut_changed = 0;
  }
  v19 = *((_QWORD *)v18 + 352);
  if (!v19)
  {
    v96 = (void *)MEMORY[0x186DBE2E4]();
    v109 = 0;
    v110[0] = 0;
    v102 = v18;
    if (lut_file)
    {
      v20 = (void *)objc_msgSend(MEMORY[0x1E0C99D50], "dataWithContentsOfFile:options:error:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:"), 1, 0);
      v21 = (const uint8_t *)objc_msgSend(v20, "bytes");
      v22 = objc_msgSend(v20, "length");
      LODWORD(v23) = 0;
      v107 = v23;
      if (v22 != 1310772)
      {
        v24 = malloc_type_malloc(0x140034uLL, 0x1FCEBB42uLL);
        if (compression_decode_buffer((uint8_t *)v24, 0x140034uLL, v21, v22, 0, COMPRESSION_LZFSE) == 1310772)
          v20 = (void *)objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytesNoCopy:length:", v24, 1310772);
        else
          free(v24);
      }
    }
    else
    {
      if (a7 == 0.0)
        goto LABEL_44;
      LODWORD(v10) = vcvtms_s32_f32(a7);
      v20 = (void *)CA::OGL::overdrive_texture_data(a6, (uint64_t)v10);
      LODWORD(v25) = vcvtps_s32_f32(a7);
      *(float *)&v26 = a7 - floorf(a7);
      v107 = v26;
      if ((_DWORD)v10 != (_DWORD)v25)
      {
        v106 = (id)CA::OGL::overdrive_texture_data(a6, v25);
        if (!v20)
          goto LABEL_44;
LABEL_13:
        if (!objc_msgSend(v20, "length"))
          goto LABEL_44;
        objc_msgSend(v20, "getBytes:range:", (char *)v110 + 4, 0, 4);
        v27 = v102;
        objc_msgSend(v20, "getBytes:range:", v110, 4, 4);
        objc_msgSend(v20, "getBytes:range:", (char *)&v109 + 4, 8, 4);
        objc_msgSend(v20, "getBytes:range:", &v109, 12, 4);
        v28 = malloc_type_malloc(4 * HIDWORD(v109), 0x100004052888210uLL);
        *((_QWORD *)v102 + 356) = v28;
        objc_msgSend(v20, "getBytes:range:", v28, 16, (4 * HIDWORD(v109)));
        v29 = malloc_type_malloc(4 * v109, 0x100004052888210uLL);
        *((_QWORD *)v27 + 354) = v29;
        objc_msgSend(v20, "getBytes:range:", v29, (4 * HIDWORD(v109) + 16), (4 * v109));
        v95 = v11;
        v30 = objc_msgSend(v20, "bytes");
        v93 = a2;
        v94 = a3;
        v32 = v109;
        v31 = HIDWORD(v109);
        v33 = objc_msgSend(v106, "bytes");
        v35 = v109;
        v34 = HIDWORD(v109);
        *((_QWORD *)v27 + 355) = HIDWORD(v109);
        v36 = (CA::OGL::MetalContext *)malloc_type_malloc(8 * v35, 0x2004093837F09uLL);
        *((_QWORD *)v27 + 353) = v36;
        v38 = v109;
        v37 = HIDWORD(v109);
        *((_QWORD *)v27 + 352) = v109;
        v39 = (LODWORD(v110[0]) * HIDWORD(v110[0]));
        if (v106)
        {
          if (v39 > 0x400)
          {
            v36 = (CA::OGL::MetalContext *)malloc_type_malloc(4 * (LODWORD(v110[0]) * HIDWORD(v110[0])), 0x49260F68uLL);
            v41 = v36;
            if (!(_DWORD)v109)
            {
LABEL_41:
              a3 = v94;
              a2 = v93;
              v11 = v95;
              if (v41 && v39 > 0x400)
                free(v41);
LABEL_44:
              objc_autoreleasePoolPop(v96);
              v18 = v102;
              v19 = *((_QWORD *)v102 + 352);
              if (!v19)
                return;
              goto LABEL_45;
            }
          }
          else
          {
            MEMORY[0x1E0C80A78](v36);
            v41 = (CA::OGL::MetalContext *)((char *)&v92 - ((v40 + 15) & 0x7FFFFFFF0));
            bzero(v41, v40);
            if (!v38)
              goto LABEL_41;
          }
        }
        else
        {
          v41 = 0;
          if (!v38)
            goto LABEL_41;
        }
        v99 = v30 + 4 * v31 + 4 * v32 + 16;
        v98 = v37 * (unint64_t)v39;
        if (v106)
          v42 = (_DWORD)v39 == 0;
        else
          v42 = 1;
        v43 = v42;
        v44 = 4 * v34;
        v45 = 0;
        v46 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v107, 0);
        v47 = 4 * v31 + 4 * v32 + v30;
        v48 = 4 * v39;
        v104 = v47 + 16;
        v105 = v44 + 4 * v35 + v33 + 16;
        v101 = 4 * v37 * (unint64_t)v39;
        do
        {
          CA::OGL::MetalContext::new_image(v36);
          v50 = v49;
          v51 = *(_DWORD *)(v49 + 52);
          *(_BYTE *)(v49 + 56) = *(_BYTE *)(v49 + 56) & 0xC0 | 0x17;
          *(_WORD *)(v49 + 58) &= 0xFFE7u;
          *(_WORD *)(v49 + 123) &= ~0x10u;
          *(_DWORD *)(v49 + 48) = -1098907648;
          *(_DWORD *)(v49 + 52) = v51 & 0xC000FFFF | 0x110000;
          v52 = objc_alloc_init(MEMORY[0x1E0CC6BB0]);
          objc_msgSend(v52, "setTextureType:", 7);
          objc_msgSend(v52, "setWidth:", HIDWORD(v110[0]));
          objc_msgSend(v52, "setHeight:", LODWORD(v110[0]));
          objc_msgSend(v52, "setDepth:", HIDWORD(v109));
          objc_msgSend(v52, "setPixelFormat:", 555);
          objc_msgSend(v52, "setUsage:", 1);
          *(_QWORD *)(v50 + 88) = v52;
          *(_QWORD *)(v50 + 64) = objc_msgSend(*((id *)v102 + 363), "newTextureWithDescriptor:", v52);
          v36 = (CA::OGL::MetalContext *)objc_msgSend(*(id *)(v50 + 64), "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("com.apple.coreanimation.od-texture-%zu"), v45));
          v103 = v45;
          if (HIDWORD(v109))
          {
            v53 = 0;
            v54 = v104;
            v55 = v99 + 4 * v98 * v103;
            v56 = v105;
            do
            {
              if (v106)
                v57 = v41;
              else
                v57 = (CA::OGL::MetalContext *)(v55 + 4 * v53 * v39);
              if ((v43 & 1) == 0)
              {
                v58 = 0;
                do
                {
                  v59 = *(_DWORD *)(v54 + v58);
                  v60 = *(_DWORD *)(v56 + v58);
                  if (v59 != v60)
                  {
                    v61 = vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v59), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003));
                    v62 = vshl_u32(vcvt_u32_f32(vmla_f32(v61, v46, vsub_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v60), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003)), v61))), (uint32x2_t)0x140000000ALL);
                    v59 = v62.i32[0] | (float)((float)(*(_DWORD *)(v54 + v58) & 0x3FF)
                                                           + (float)((float)((float)(*(_DWORD *)(v56 + v58) & 0x3FF)
                                                                           - (float)(*(_DWORD *)(v54 + v58) & 0x3FF))
                                                                   * *(float *)&v107)) | v62.i32[1] | 0xC0000000;
                  }
                  *(_DWORD *)((char *)v41 + v58) = v59;
                  v58 += 4;
                }
                while (v48 != v58);
                v57 = v41;
              }
              v63 = *(void **)(v50 + 64);
              v108[0] = 0;
              v108[1] = 0;
              v108[2] = v53;
              v108[3] = HIDWORD(v110[0]);
              v108[4] = LODWORD(v110[0]);
              v108[5] = 1;
              v36 = (CA::OGL::MetalContext *)objc_msgSend(v63, "replaceRegion:mipmapLevel:withBytes:bytesPerRow:", v108, 0, v57, (4 * HIDWORD(v110[0])));
              ++v53;
              v56 += v48;
              v54 += v48;
            }
            while (v53 < HIDWORD(v109));
          }
          *(_BYTE *)(v50 + 122) = 1;
          *(_WORD *)(v50 + 123) = *(_WORD *)(v50 + 123) & 0xFFF0 | 2;
          v64 = v103;
          *(_QWORD *)(*((_QWORD *)v102 + 353) + 8 * v103) = v50;
          v45 = v64 + 1;
          v105 += v101;
          v104 += v101;
        }
        while (v45 < v109);
        goto LABEL_41;
      }
    }
    v106 = 0;
    if (!v20)
      goto LABEL_44;
    goto LABEL_13;
  }
LABEL_45:
  v65 = **((_QWORD **)v18 + 353);
  v66 = *(void **)(v65 + 88);
  v67 = v100;
  if (v66)
  {
    v68 = objc_msgSend(v66, "width");
    v69 = v97;
    *v97 = v68;
    v69[1] = objc_msgSend(*(id *)(v65 + 88), "height");
    v69[2] = objc_msgSend(*(id *)(v65 + 88), "depth");
    v19 = *((_QWORD *)v18 + 352);
  }
  *v11 = 0.0;
  *v67 = 0.0;
  if (v19 < 2)
  {
    v73 = 0;
    v70 = 0;
  }
  else
  {
    v70 = 0;
    v71 = *((_QWORD *)v18 + 354);
    while (1)
    {
      v72 = *(float *)(v71 + 4 * v70);
      if (v72 > a5)
        break;
      if (v19 == ++v70)
        goto LABEL_54;
    }
    if (v70 == v19)
    {
LABEL_54:
      v73 = v19 - 1;
      v74 = 1.0;
      v70 = v73;
LABEL_55:
      *v67 = v74;
      goto LABEL_56;
    }
    if (v70)
    {
      v73 = v70 - 1;
      v74 = (float)(a5 - *(float *)(v71 + 4 * (v70 - 1))) / (float)(v72 - *(float *)(v71 + 4 * (v70 - 1)));
      goto LABEL_55;
    }
    v73 = 0;
  }
LABEL_56:
  v75 = *((_QWORD *)v18 + 355);
  if (v75 >= 2)
  {
    v76 = 0;
    v77 = *((_QWORD *)v18 + 356);
    while (1)
    {
      v78 = *(float *)(v77 + 4 * v76);
      if (v78 > a4)
        break;
      if (v75 == ++v76)
      {
        v79 = 1.0;
        goto LABEL_64;
      }
    }
    v79 = 1.0;
    if (v76 != v75)
    {
      if (!v76)
        goto LABEL_65;
      v79 = (float)((float)((float)(unint64_t)(v76 - 1) + 0.5)
                  + (float)((float)(a4 - *(float *)(v77 + 4 * (v76 - 1)))
                          / (float)(v78 - *(float *)(v77 + 4 * (v76 - 1)))))
          / (float)v75;
    }
LABEL_64:
    *v11 = v79;
  }
LABEL_65:
  v80 = *((_QWORD *)v18 + 353);
  v81 = *(_QWORD *)(v80 + 8 * v73);
  v82 = *((_QWORD *)v18 + 2);
  *(_WORD *)(v82 + 144 + 2 * a2) = 0;
  *(_QWORD *)(v82 + 176 + 8 * a2) = v81;
  v83 = *(_QWORD *)(v80 + 8 * v70);
  *(_WORD *)(v82 + 144 + 2 * a3) = 0;
  *(_QWORD *)(v82 + 176 + 8 * a3) = v83;
  *(_OWORD *)(v82 + 96 + 16 * a2) = xmmword_18474E210;
  *(_OWORD *)(v82 + 96 + 16 * a3) = xmmword_18474E210;
}

void sub_1846851A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_autoreleasePoolPop(*(void **)(v1 - 312));
  _Unwind_Resume(a1);
}

_QWORD *CA::OGL::MetalContext::bind_luma_boost(_QWORD *this, unsigned int a2, double a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  float v8;
  float v9;
  float v10;
  float v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t *v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int16x4_t v19;
  int8x16_t v20;
  uint64_t v21;
  int v22;
  __int16 v23;
  id v24;
  void *v25;
  void *v26;
  _QWORD v27[3];
  __int128 v28;
  uint64_t v29;
  _OWORD v30[8];
  _OWORD v31[32];
  uint64_t v32;

  v4 = this;
  v32 = *MEMORY[0x1E0C80C00];
  v5 = this[357];
  if (!v5)
  {
    v7 = 0;
    memset(v31, 0, sizeof(v31));
    LODWORD(a3) = 0;
    memset(v30, 0, sizeof(v30));
    do
    {
      v8 = (float)v7 * 0.007874;
      v9 = (float)((float)(1.0 - v8) * (float)(1.0 - v8)) * v8;
      v10 = v9
          + (float)((float)(v8 * v8) * v8)
          + (v8 * v8 + v8 * v8 + (float)(1.0 - v8) * (float)(1.0 - v8) * 0.5) * (float)(1.0 - v8);
      v11 = (float)(v10 - v8) * v9;
      *((float *)v31 + v7) = v11;
      if (v11 >= *(float *)&a3)
        *(float *)&a3 = v11;
      ++v7;
    }
    while (v7 != 128);
    v12 = 0;
    *(float *)&a3 = 255.0 / *(float *)&a3;
    v13 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0);
    v14 = (float32x4_t *)v31;
    do
    {
      v15.i64[0] = 0x3F0000003F000000;
      v15.i64[1] = 0x3F0000003F000000;
      v16.i64[0] = 0x3F0000003F000000;
      v16.i64[1] = 0x3F0000003F000000;
      v17.i64[0] = 0x3F0000003F000000;
      v17.i64[1] = 0x3F0000003F000000;
      v18.i64[0] = 0x3F0000003F000000;
      v18.i64[1] = 0x3F0000003F000000;
      v19 = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v18, v14[1], v13)));
      *(int16x4_t *)v18.f32 = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v17, *v14, v13)));
      *(int16x4_t *)&v18.u32[2] = v19;
      *(int16x4_t *)v20.i8 = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v16, v14[2], v13)));
      v20.u64[1] = (unint64_t)vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v15, v14[3], v13)));
      v30[v12++] = vuzp1q_s8((int8x16_t)v18, v20);
      v14 += 4;
    }
    while (v12 != 8);
    CA::OGL::MetalContext::new_image((CA::OGL::MetalContext *)this);
    v5 = v21;
    v22 = *(_DWORD *)(v21 + 52);
    *(_BYTE *)(v21 + 56) = *(_BYTE *)(v21 + 56) & 0xC0 | 0x17;
    *(_WORD *)(v21 + 58) &= 0xFFE7u;
    v23 = *(_WORD *)(v21 + 123);
    *(_DWORD *)(v21 + 48) = -1098907648;
    *(_DWORD *)(v21 + 52) = v22 & 0xC000FFFF | 0x110000;
    *(_BYTE *)(v21 + 122) = 1;
    *(_WORD *)(v21 + 123) = v23 & 0xFFE0 | 2;
    v24 = objc_alloc_init(MEMORY[0x1E0CC6BB0]);
    objc_msgSend(v24, "setTextureType:", 2);
    objc_msgSend(v24, "setWidth:", 128);
    objc_msgSend(v24, "setHeight:", 1);
    objc_msgSend(v24, "setPixelFormat:", 10);
    objc_msgSend(v24, "setUsage:", 1);
    *(_QWORD *)(v5 + 88) = v24;
    v25 = (void *)objc_msgSend((id)v4[363], "newTextureWithDescriptor:", v24);
    *(_QWORD *)(v5 + 64) = v25;
    objc_msgSend(v25, "setLabel:", CFSTR("com.apple.coreanimation.luma-boost-texture"));
    v26 = *(void **)(v5 + 64);
    memset(v27, 0, sizeof(v27));
    v28 = xmmword_18474E4D0;
    v29 = 1;
    this = (_QWORD *)objc_msgSend(v26, "replaceRegion:mipmapLevel:withBytes:bytesPerRow:", v27, 0, v30, 128);
    v4[357] = v5;
  }
  v6 = v4[2];
  *(_WORD *)(v6 + 2 * a2 + 144) = 0;
  *(_QWORD *)(v6 + 8 * a2 + 176) = v5;
  return this;
}

void CA::OGL::MetalContext::bind_color_cube(CA::OGL::MetalContext *this, unsigned int a2, CA::Render::Texture *a3)
{
  uint64_t v6;
  __IOSurface **v7;
  __n128 v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  __int16 v13;
  __int16 v14;
  int v16;

  if (*((CA::OGL::MetalContext **)a3 + 11) == this && (v6 = *((_QWORD *)a3 + 10)) != 0
    || (v6 = CA::OGL::Context::lookup_image_(this, a3, 1)) != 0)
  {
    v7 = CA::OGL::MetalContext::retain_image((uint64_t)this, v6, (unsigned __int8 *)a3, 0);
    v9 = (uint64_t)v7;
    if (*(_BYTE *)(v6 + 122))
    {
      if (*(_DWORD *)(v6 + 16) == *((_DWORD *)v7 + 9))
      {
        v10 = *((_QWORD *)this + 2);
        *(_WORD *)(v10 + 2 * a2 + 144) = *(_DWORD *)(v6 + 52);
        *(_QWORD *)(v10 + 8 * a2 + 176) = v6;
        return;
      }
    }
    else
    {
      v11 = *((_DWORD *)v7 + 4);
      v12 = *((_DWORD *)v7 + 5);
      v13 = (*((uint64_t (**)(__IOSurface **))*v7 + 18))(v7);
      *(_WORD *)(v6 + 120) = v13;
      v14 = *(_WORD *)(v6 + 123) | 0x400;
      *(_WORD *)(v6 + 123) = v14;
      if (v12 >= 2 && v13 == 1)
      {
        if (v12 != v11 * v11)
        {
          v16 = v11 * v11 * v11;
          LOWORD(v11) = v11 * v11;
          if (v12 != v16)
            return;
        }
        *(_WORD *)(v6 + 120) = v11;
      }
      *(_WORD *)(v6 + 123) = v14 & 0xFFF7;
    }
    CA::OGL::MetalContext::update_texture((uint64_t)this, v6, v9, a2, 0, v8);
  }
}

void CA::OGL::MetalContext::bind_table_image(CA::OGL::MetalContext *this, unsigned int a2, CA::Render::Image *a3)
{
  unint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  uint64_t v9;

  if (*((CA::OGL::MetalContext **)a3 + 11) == this && (v6 = *((_QWORD *)a3 + 10)) != 0
    || (v6 = CA::OGL::Context::lookup_image_(this, a3, 1)) != 0)
  {
    if (!*(_QWORD *)(v6 + 8))
    {
      *(_QWORD *)(v6 + 8) = a3;
      v7 = (unsigned int *)((char *)a3 + 148);
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 + 1, v7));
    }
    if (*(_BYTE *)(v6 + 122))
    {
      if (*(_DWORD *)(v6 + 16) == *((_DWORD *)a3 + 9))
      {
        v9 = *((_QWORD *)this + 2);
        *(_WORD *)(v9 + 2 * a2 + 144) = *(_DWORD *)(v6 + 52);
        *(_QWORD *)(v9 + 8 * a2 + 176) = v6;
        return;
      }
    }
    else
    {
      *(_WORD *)(v6 + 123) &= ~8u;
    }
    CA::OGL::MetalContext::update_image((uint64_t)this, v6, (uint64_t)a3, a2, 0);
  }
}

unsigned int *CA::OGL::MetalContext::create_lut_texture(CA::OGL::MetalContext *this, const CA::Render::Vector *a2, int a3)
{
  unsigned int v5;
  unsigned int v6;
  double v7;
  unsigned int v8;
  unint64_t v9;
  uint64_t v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  unint64_t v19;
  unint64_t v20;
  CA::Render *v21;
  CGColorSpace *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _WORD *v26;
  uint64_t v27;
  uint64_t v28;
  CA::Render::Texture *v33;
  unsigned int *v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  void *v39;
  void (*v40)(const void *, void *);
  unint64_t v41;
  uint8_t buf[4];
  unsigned int v43;
  __int16 v44;
  unsigned int v45;
  __int16 v46;
  unsigned int v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if (a3 != 3)
    return 0;
  v5 = *((_DWORD *)a2 + 4);
  v6 = v5 >> 2;
  v7 = cbrt((double)(v5 >> 2));
  if (v5 < 0x20
    || ((v8 = v7, v9 = v8 * v8, v7 <= 0x80) ? (_ZF = (_DWORD)v9 * v8 == v6) : (_ZF = 0), !_ZF))
  {
    if (x_log_hook_p())
    {
LABEL_8:
      x_log_();
      return 0;
    }
    v11 = x_log_category_ogl_metal;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 67109120;
    v43 = v6;
    v12 = "Invalid 3D lut input data with pixel count of %u";
    v13 = v11;
    v14 = 8;
LABEL_11:
    _os_log_impl(&dword_184457000, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
    return 0;
  }
  v15 = (uint64_t *)*((_QWORD *)this + 43);
  if (v15)
  {
    v16 = *v15;
    v17 = v15[1];
    while (v16 != v17)
    {
      if (*(const CA::Render::Vector **)v16 == a2)
      {
        *(_WORD *)(v16 + 26) = *(_WORD *)(v16 + 24);
        v18 = *(unsigned int **)(v16 + 16);
        if (v18)
          return v18;
        break;
      }
      v16 += 32;
    }
  }
  v19 = CA::Render::format_rowbytes((CA::Render *)0xD, v7);
  v20 = v19;
  v40 = 0;
  v41 = v19;
  if (is_mul_ok(v19, v9))
    v21 = (CA::Render *)(v19 * v9);
  else
    v21 = 0;
  v22 = (CGColorSpace *)CA::Render::aligned_malloc(v21, (unint64_t *)&v40, 0);
  if (!v22)
    return 0;
  if (!v8)
    goto LABEL_42;
  v23 = 0;
  v24 = v9 <= 1 ? 1 : v9;
  v25 = 24;
  do
  {
    v26 = (_WORD *)((char *)v22 + 2 * (v20 >> 1) * v23);
    v27 = v25;
    v28 = 4 * v8;
    do
    {
      _D0 = *(_QWORD *)((char *)a2 + v27);
      __asm { FCVT            H0, D0 }
      *v26++ = _D0;
      v27 += 8;
      --v28;
    }
    while (v28);
    ++v23;
    v25 += 32 * v8;
  }
  while (v23 != v24);
  v33 = CA::Render::Image::new_image((CA::Render::Image *)0xD, v8, v8 * v8, 1u, 0, v22, &v41, (const unint64_t *)CA::Render::aligned_free, v40, v39);
  if (!v33)
  {
LABEL_42:
    if (x_log_hook_p())
      goto LABEL_8;
    v37 = x_log_category_ogl_metal;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 67109632;
    v43 = v8;
    v44 = 1024;
    v45 = v8;
    v46 = 1024;
    v47 = v8;
    v12 = "Unable to allocate 3D LUT texture of size %ux%ux%u";
    v13 = v37;
    v14 = 20;
    goto LABEL_11;
  }
  v18 = (unsigned int *)v33;
  CA::OGL::Context::add_transient_render_texture(this, (uint64_t)a2, a2, v33);
  v34 = v18 + 2;
  do
  {
    v35 = __ldaxr(v34);
    v36 = v35 - 1;
  }
  while (__stlxr(v36, v34));
  if (!v36)
    (*(void (**)(unsigned int *))(*(_QWORD *)v18 + 16))(v18);
  return v18;
}

CA::Render::Texture *CA::OGL::MetalContext::create_lut_texture(CA::OGL::MetalContext *this, const CA::Render::Interpolator *a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  CA::Render::Texture *v6;
  int v7;
  uint64_t v8;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  id v16;
  objc_object *v17;
  uint64_t v18;
  uint64_t v19;
  malloc_zone_t *malloc_zone;
  CA::Render::MetalTexture *v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  _QWORD v25[6];
  _QWORD v26[7];

  v26[6] = *MEMORY[0x1E0C80C00];
  if (a3 != 3)
    return 0;
  v4 = *((_QWORD *)a2 + 3);
  if (!v4)
    return 0;
  v5 = *((_QWORD *)a2 + 4);
  if (!v5)
    return 0;
  v6 = 0;
  v7 = *(unsigned __int8 *)(v4 + 12);
  if (v7 == 23)
    v8 = *((_QWORD *)a2 + 3);
  else
    v8 = 0;
  if (*(_BYTE *)(v5 + 12) == 23 && v7 == 23)
  {
    v11 = (uint64_t *)*((_QWORD *)this + 43);
    if (v11)
    {
      v12 = *v11;
      v13 = v11[1];
      while (v12 != v13)
      {
        if (*(_QWORD *)v12 == (v8 | ((unint64_t)v5 << 32)))
        {
          *(_WORD *)(v12 + 26) = *(_WORD *)(v12 + 24);
          v6 = *(CA::Render::Texture **)(v12 + 16);
          if (v6)
            return v6;
          break;
        }
        v12 += 32;
      }
    }
    v15 = *(unsigned int *)(v8 + 16);
    v16 = objc_alloc_init(MEMORY[0x1E0CC6BB0]);
    objc_msgSend(v16, "setTextureType:", 7);
    objc_msgSend(v16, "setWidth:", v15);
    objc_msgSend(v16, "setHeight:", v15);
    objc_msgSend(v16, "setDepth:", 2 * v15);
    objc_msgSend(v16, "setPixelFormat:", 115);
    objc_msgSend(v16, "setUsage:", 1);
    v17 = (objc_object *)objc_msgSend(*((id *)this + 363), "newTextureWithDescriptor:", v16);
    -[objc_object setLabel:](v17, "setLabel:", CFSTR("com.apple.coreanimation.interpolated_3d_lut"));

    v18 = *(unsigned int *)(v8 + 160);
    memset(v26, 0, 24);
    v26[3] = v15;
    v26[4] = v15;
    v26[5] = v15;
    -[objc_object replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:](v17, "replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:", v26, 0, 0, *(_QWORD *)(v8 + 96), v18, v18 * (unint64_t)v15);
    v19 = *(unsigned int *)(v5 + 160);
    v25[0] = 0;
    v25[1] = 0;
    v25[2] = v15;
    v25[3] = v15;
    v25[4] = v15;
    v25[5] = v15;
    -[objc_object replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:](v17, "replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:", v25, 0, 0, *(_QWORD *)(v5 + 96), v19, v19 * (unint64_t)v15);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    v21 = (CA::Render::MetalTexture *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x70uLL, 0x743898A5uLL);
    if (!v21)
    {

      __assert_rtn("add_transient_render_texture", "ogl-context.cpp", 2464, "key && img && !lookup_transient_render_texture (key, false)");
    }
    v6 = v21;
    CA::Render::MetalTexture::MetalTexture(v21, v17);

    CA::OGL::Context::add_transient_render_texture(this, v8 | ((unint64_t)v5 << 32), a2, v6);
    v22 = (unsigned int *)((char *)v6 + 8);
    do
    {
      v23 = __ldaxr(v22);
      v24 = v23 - 1;
    }
    while (__stlxr(v24, v22));
    if (!v24)
      (*(void (**)(CA::Render::Texture *))(*(_QWORD *)v6 + 16))(v6);
  }
  return v6;
}

uint64_t CA::OGL::MetalContext::bind_lut_texture(CA::OGL::MetalContext *this, unsigned int a2, CA::Render::Texture *a3)
{
  uint64_t v6;

  if (*((CA::OGL::MetalContext **)a3 + 11) == this && (v6 = *((_QWORD *)a3 + 10)) != 0
    || (v6 = CA::OGL::Context::lookup_image_(this, a3, 1)) != 0)
  {
    CA::OGL::MetalContext::bind_color_cube(this, a2, a3);
    *(_BYTE *)(*((_QWORD *)this + 2) + 308) = a2;
  }
  return v6;
}

uint64_t CA::OGL::MetalContext::can_render_to_format(CA::OGL::MetalContext *this, CA::Render *a2)
{
  CA::OGL::four_cc_to_mtl_format(a2, *((_DWORD *)this + 669));
  MTLPixelFormatGetInfoForDevice();
  return 0;
}

char *CA::OGL::MetalContext::create_reinterpreted_surface(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  malloc_zone_t *malloc_zone;
  MTLPixelFormat v8;
  char *v9;
  int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;

  v6 = objc_msgSend(*(id *)(a2 + 96), "pixelFormat");
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v9 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xF0uLL, 0x743898A5uLL);
  *(_DWORD *)v9 = 1;
  *(_OWORD *)(v9 + 24) = *(_OWORD *)(a2 + 24);
  *((_QWORD *)v9 + 5) = *(_QWORD *)(a2 + 40);
  *((_QWORD *)v9 + 6) = *(_QWORD *)(a2 + 48);
  *((_DWORD *)v9 + 16) = *(_DWORD *)(a2 + 64);
  v9[72] = v9[72] & 0xFE | *(_BYTE *)(a2 + 72) & 1;
  v10 = *(_WORD *)(v9 + 75) & 0xFFF0 | *(_WORD *)(a2 + 75) & 0xF;
  *(_WORD *)(v9 + 75) = *(_WORD *)(v9 + 75) & 0xFFF0 | *(_WORD *)(a2 + 75) & 0xF;
  v11 = *(_WORD *)(a2 + 75) & 0x10 | v10 & 0xFFFFFFEF | 0x100;
  *(_WORD *)(v9 + 75) = *(_WORD *)(a2 + 75) & 0x10 | v10 & 0xFFEF | 0x100;
  *(_OWORD *)(v9 + 184) = *(_OWORD *)(a2 + 184);
  v12 = *((_WORD *)v9 + 116) & 0xFFF0 | *(_WORD *)(a2 + 232) & 0xF;
  *((_WORD *)v9 + 116) = *((_WORD *)v9 + 116) & 0xFFF0 | *(_WORD *)(a2 + 232) & 0xF;
  v13 = v12 & 0xFFFFFEFF | ((HIBYTE(*(unsigned __int16 *)(a2 + 232)) & 1) << 8);
  *((_WORD *)v9 + 116) = v13;
  *(_DWORD *)(v9 + 214) = *(_DWORD *)(a2 + 214);
  v14 = v13 & 0xFFFFFDFF | (((*(unsigned __int16 *)(a2 + 232) >> 9) & 1) << 9);
  *((_WORD *)v9 + 116) = v14;
  *((_WORD *)v9 + 116) = v14 & 0xFBFF | *(_WORD *)(a2 + 232) & 0x400;
  v15 = v11 & 0xFFFFFFDF | (32 * ((*(unsigned __int16 *)(a2 + 75) >> 5) & 1));
  *(_WORD *)(v9 + 75) = v15;
  LOWORD(v15) = v15 & 0xFFBF | (((*(_WORD *)(a2 + 75) >> 6) & 1) << 6);
  *(_WORD *)(v9 + 75) = v15;
  *(_WORD *)(v9 + 75) = v15 & 0xFF7F | *(_WORD *)(a2 + 75) & 0x80;
  v16 = *(_DWORD *)(a2 + 68);
  if (a3)
  {
    v17 = v16 | 0x80;
    v18 = CA::OGL::srgb_pixel_format(v6, v8);
  }
  else
  {
    v17 = v16 & 0xFFFFFF7F;
    v18 = CA::OGL::non_srgb_pixel_format(v6, v8);
  }
  v19 = v18;
  *((_DWORD *)v9 + 17) = v17;
  v20 = (void *)objc_msgSend(*(id *)(a2 + 96), "newTextureViewWithPixelFormat:", v18);
  *((_QWORD *)v9 + 12) = v20;
  *((_QWORD *)v9 + 15) = v19;
  if (v20)
  {
    objc_msgSend(v20, "setLabel:", CFSTR("com.apple.coreanimation.reinterpreted-surface"));
    if ((__int16)(*(_WORD *)(a2 + 232) << 12) > 4096)
    {
      v21 = 0;
      v22 = a2 + 104;
      do
      {
        v23 = &v9[8 * v21];
        *((_QWORD *)v23 + 13) = *(id *)(v22 + 8 * v21);
        *((_QWORD *)v23 + 16) = objc_msgSend(*(id *)(v22 + 8 * v21), "pixelFormat");
        v24 = v21 + 2;
        ++v21;
      }
      while (v24 < *(unsigned __int16 *)(a2 + 232) << 28 >> 28);
    }
  }
  else
  {
    CA::OGL::MetalContext::finalize_surface(a1, (uint64_t)v9);
    return 0;
  }
  return v9;
}

double CA::OGL::MetalContext::create_null_surface(CA::OGL::MetalContext *this)
{
  malloc_zone_t *malloc_zone;
  char *v2;
  double result;
  __int16 v4;

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v2 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xF0uLL, 0x743898A5uLL);
  *(_DWORD *)v2 = 1;
  result = 0.0;
  *((_OWORD *)v2 + 2) = xmmword_18474E230;
  *((_DWORD *)v2 + 17) = 15;
  v2[72] |= 1u;
  v4 = *((_WORD *)v2 + 116) & 0xFFC0;
  v2[73] = v2[73] & 0xC0 | 0x13;
  *(_WORD *)(v2 + 75) |= 0x80u;
  *((_WORD *)v2 + 116) = v4 | 0x31;
  return result;
}

uint64_t CA::OGL::MetalContext::calculate_average_luma(CA::OGL::MetalContext *this, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  _QWORD *external_buffer;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t tile_pipeline;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  void *v24;
  float v25;
  float64_t v26;
  void *v27;
  char *surface;
  uint64_t v29;
  int v30;
  int64x2_t v31;
  int8x16_t v32;
  int32x2_t v33;
  int32x4_t v34;
  int32x4_t v35;
  int8x16_t v36;
  uint64_t v37;
  void *v38;
  char *v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  float v45;
  void *v46;
  int v48;
  uint64_t v49;
  _QWORD v50[7];
  float v51;
  _QWORD v52[3];
  int64x2_t v53;
  uint64_t v54;
  _QWORD v55[3];
  __int128 v56;
  uint64_t (*v57)(uint64_t);
  void *v58;
  _QWORD *v59;
  uint64_t v60;
  int v61;
  int v62;
  float v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int8x16_t v67;
  int8x16_t v68;
  __int128 *v69;
  _WORD v70[4];
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a2 + 48))
    __assert_rtn("calculate_average_luma", "ogl-metal.mm", 15574, "!surf->protection_options");
  if (*((_QWORD *)this + 380))
    return 0;
  v7 = *((_DWORD *)this + 669);
  if ((v7 & 0x200000) == 0 || (v7 & 0x1000000) == 0 || BYTE7(xmmword_1ECDC6AD0))
    goto LABEL_26;
  CA::OGL::Context::push_surface((uint64_t)this, a2, 0, 64, 0);
  v8 = *((_QWORD *)this + 32);
  if (v8 != *((_QWORD *)this + 31))
    goto LABEL_8;
  if (v8)
    LODWORD(v8) = (*(unsigned __int8 *)(v8 + 72) >> 1) & 0x1F;
  if (*((_DWORD *)this + 61) != (_DWORD)v8)
LABEL_8:
    CA::OGL::Context::prepare_destination_(this);
  if ((*((_WORD *)this + 408) & 0x200) != 0)
  {
    v9 = *((_QWORD *)this + 22);
    if (v9)
    {
      *((_WORD *)this + 408) &= ~0x200u;
    }
  }
  if (!CA::OGL::MetalContext::start_render_encoder(this)
    || (v10 = objc_msgSend(*((id *)this + 367), "tileWidth"),
        v11 = objc_msgSend(*((id *)this + 367), "tileHeight"),
        v12 = (v10 + *(_DWORD *)(a2 + 184) - 1) / v10,
        v13 = (v11 + *(_DWORD *)(a2 + 188) - 1) / v11 * v12,
        (external_buffer = CA::OGL::MetalBufferPool::create_external_buffer(*((CA::OGL::MetalBufferPool **)this + 499), v13 << 6, 8uLL, 0)) == 0))
  {
    CA::OGL::Context::pop_surface(this);
    goto LABEL_26;
  }
  v15 = (uint64_t)external_buffer;
  v48 = 8 * v13;
  v16 = (_QWORD *)external_buffer[4];
  v17 = *((unsigned int *)external_buffer + 10);
  tile_pipeline = CA::OGL::MetalContext::get_tile_pipeline((uint64_t)this, 0xBu, *(_QWORD *)(a2 + 120));
  v19 = v10 >= 0 ? v10 : v10 + 1;
  v20 = (uint64_t)v19 >> 1;
  v21 = v11 >= 0 ? v11 : v11 + 1;
  v22 = (uint64_t)v21 >> 1;
  v23 = *(_DWORD *)(a2 + 44);
  v70[0] = *(_DWORD *)(a2 + 40);
  v70[1] = v23;
  v70[2] = v12;
  v70[3] = 0;
  objc_msgSend(*((id *)this + 367), "setRenderPipelineState:", tile_pipeline);
  objc_msgSend(*((id *)this + 367), "setTileBuffer:offset:atIndex:", v16, v17, 2);
  objc_msgSend(*((id *)this + 367), "setTileBytes:length:atIndex:", v70, 8, 0);
  v24 = (void *)*((_QWORD *)this + 367);
  v64 = v20;
  v65 = v22;
  v4 = 1;
  v66 = 1;
  objc_msgSend(v24, "dispatchThreadsPerTile:", &v64);
  *((_QWORD *)this + 414) = tile_pipeline;
  v25 = powf(*(float *)(a2 + 64), -1.0 / *((float *)this + 38));
  v26 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&v56 = MEMORY[0x1E0C809B0];
  *((_QWORD *)&v56 + 1) = 3221225472;
  v57 = ___ZN2CA3OGL12MetalContext27tile_calculate_average_lumaEPNS0_7SurfaceEU13block_pointerFvfE_block_invoke;
  v58 = &unk_1E15A6628;
  v61 = v48;
  v62 = v17;
  v63 = v25;
  v59 = v16;
  v60 = a3;
  CA::OGL::MetalBufferPool::release_external_buffer(*((_QWORD *)this + 499), v15);
  CA::OGL::Context::pop_surface(this);
  v27 = (void *)*((_QWORD *)this + 366);
  *(float64_t *)v67.i64 = v26;
  v67.i64[1] = 3221225472;
  v68.i64[0] = (uint64_t)___ZN2CA3OGL12MetalContext22add_completed_callbackEU13block_pointerFvvE_block_invoke;
  v68.i64[1] = (uint64_t)&unk_1E15A6600;
  v69 = &v56;
  objc_msgSend(v27, "addCompletedHandler:", &v67);
  if (!*((_QWORD *)this + 366))
  {
LABEL_26:
    v64 = 0;
    v49 = *(_QWORD *)(a2 + 40);
    v65 = v49;
    surface = CA::OGL::MetalContext::create_surface(this, MTLPixelFormatA8Unorm, (int32x2_t *)&v64, 1446991);
    if (!surface)
      return 0;
    v29 = (uint64_t)surface;
    *(_WORD *)(surface + 75) |= 0x1000u;
    v30 = v49;
    if ((int)v49 <= SHIDWORD(v49))
      v30 = HIDWORD(v49);
    v31.i64[0] = (int)v49;
    v31.i64[1] = SHIDWORD(v49);
    v32 = (int8x16_t)vcvtq_f64_s64(v31);
    v33 = vdup_n_s32(v30 > 1073741822);
    v31.i64[0] = v33.u32[0];
    v31.i64[1] = v33.u32[1];
    v34 = (int32x4_t)vcltzq_s64(vshlq_n_s64(v31, 0x3FuLL));
    v35 = (int32x4_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    v36 = vbslq_s8((int8x16_t)v34, (int8x16_t)v35, v32);
    v34.i32[0] = v30;
    v35.i32[0] = 1073741822;
    v67 = vandq_s8((int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v34, v35), 0));
    v68 = v36;
    v37 = 1;
    CA::OGL::MetalContext::copy_surface((uint64_t)this, (uint64_t)surface, a2, 1, 0, (float64x2_t *)&v67, (float64x2_t *)&v67);
    v38 = *(void **)(v29 + 96);
    if (CA::OGL::MetalContext::start_blit_encoder(this, 0))
    {
      objc_msgSend(*((id *)this + 368), "generateMipmapsForTexture:", v38);
      v56 = xmmword_18474E230;
      v39 = CA::OGL::MetalContext::create_surface(this, MTLPixelFormatA8Unorm, (int32x2_t *)&v56, 1971279);
      if (!v39)
      {
LABEL_33:
        v37 = 0;
        goto LABEL_34;
      }
      v40 = (uint64_t)v39;
      *(_WORD *)(v39 + 75) |= 0x1000u;
      v41 = (void *)*((_QWORD *)this + 368);
      v42 = *(_QWORD *)(v29 + 96);
      v43 = objc_msgSend(v38, "mipmapLevelCount");
      v37 = 1;
      v53 = vdupq_n_s64(1uLL);
      v54 = 1;
      memset(v55, 0, sizeof(v55));
      v44 = *(_QWORD *)(v40 + 96);
      memset(v52, 0, sizeof(v52));
      objc_msgSend(v41, "copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:", v42, 0, v43 - 1, v55, &v53, v44, 0, 0, v52);
      v45 = powf(*(float *)(v40 + 64), -1.0 / *((float *)this + 38));
      v50[0] = MEMORY[0x1E0C809B0];
      v50[1] = 3221225472;
      v50[2] = ___ZN2CA3OGL12MetalContext22calculate_average_lumaEPNS0_7SurfaceEU13block_pointerFvfE_block_invoke;
      v50[3] = &unk_1E15A6650;
      v50[5] = this;
      v50[6] = v40;
      v51 = v45;
      v50[4] = a3;
      v46 = (void *)*((_QWORD *)this + 366);
      *(_QWORD *)&v56 = MEMORY[0x1E0C809B0];
      *((_QWORD *)&v56 + 1) = 3221225472;
      v57 = ___ZN2CA3OGL12MetalContext22add_completed_callbackEU13block_pointerFvvE_block_invoke;
      v58 = &unk_1E15A6600;
      v59 = v50;
      objc_msgSend(v46, "addCompletedHandler:", &v56);
      if (!*((_QWORD *)this + 366))
      {
        CA::OGL::Context::release_surface((uint64_t)this, v40);
        goto LABEL_33;
      }
    }
LABEL_34:
    CA::OGL::Context::release_surface((uint64_t)this, v29);
    return v37;
  }
  return v4;
}

_QWORD *CA::OGL::MetalContext::compute_surface_apl_dimming_factor(uint64_t a1, int32x2_t *a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD *external_buffer;
  unsigned int v8;
  int v9;
  void *compute_pipeline;
  uint64_t v11;
  unsigned __int32 v12;
  unint64_t v13;
  unint64_t v14;
  int32x2_t v15;
  float32x2_t v16;
  int8x8_t v17;
  unsigned int v18;
  float32x2_t v19;
  int32x2_t v20;
  int32x2_t v21;
  unsigned int v22;
  unsigned __int32 v23;
  _QWORD *v24;
  uint64_t v25;
  unsigned int v26;
  void *gamma_lut_buffer;
  unsigned int v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  _WORD *v32;
  _WORD *v33;
  __int16 v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  NSObject *v39;
  uint64_t v40;
  void *v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  NSObject *v45;
  uint64_t v46;
  void *v47;
  void *v48;
  __int128 v49;
  void *v50;
  int v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  unsigned int v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int64x2_t v60;
  int64x2_t v61;
  uint64_t v62;
  _QWORD v63[3];
  __int128 v64;
  uint64_t v65;
  unsigned int v66;
  uint64_t v67;
  unsigned int v68;
  uint8_t buf[16];
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v6 = (uint64_t)a2[6];
  external_buffer = CA::OGL::MetalBufferPool::create_external_buffer(*(CA::OGL::MetalBufferPool **)(a1 + 3992), 0x30u, 4uLL, v6);
  if (!external_buffer)
    return external_buffer;
  if (byte_1ECDC6AE6)
  {
    CA::OGL::MetalContext::compute_surface_apl_dimming_factor(CA::OGL::Surface *,CA::OGL::APLFilterParams const&)::$_0::operator()(a1, (uint64_t)external_buffer);
    return external_buffer;
  }
  if ((*(_BYTE *)(a3 + 20) & 0x10) != 0 && (*(_BYTE *)(a1 + 2678) & 0x40) != 0)
  {
    v9 = 0;
    v8 = 2;
  }
  else
  {
    v8 = 0;
    v9 = 1;
  }
  compute_pipeline = (void *)CA::OGL::MetalContext::get_compute_pipeline(a1, v8);
  v11 = CA::OGL::MetalContext::get_compute_pipeline(a1, 1u);
  if (!CA::OGL::MetalContext::start_compute_encoder((CA::OGL::MetalContext *)a1, *(_QWORD *)(a1 + 3040)))
  {
LABEL_39:
    v40 = external_buffer[2];
    if (v40)
    {
      if (!CA::OGL::MetalContext::start_blit_encoder((CA::OGL::MetalContext *)a1, v40))
        return external_buffer;
      *(_QWORD *)buf = 0;
      LODWORD(v67) = 0;
      v41 = CA::OGL::MetalBufferPool::alloc_bytes(*(CA::OGL::MetalBufferPool **)(a1 + 3992), *((_DWORD *)external_buffer + 2), 4u, buf, (unsigned int *)&v67);
      if (!v41)
        return external_buffer;
      memset_pattern16(v41, &unk_18474EA00, 0x30uLL);
      v42 = *(void **)(a1 + 2944);
      v43 = *(_QWORD *)buf;
      v44 = v67;
LABEL_43:
      objc_msgSend(v42, "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:", v43, v44, external_buffer[4], *((unsigned int *)external_buffer + 10), external_buffer[1]);
      return external_buffer;
    }
LABEL_54:
    memset_pattern16((void *)*external_buffer, &unk_18474EA00, 0x30uLL);
    return external_buffer;
  }
  v54 = v11;
  objc_msgSend(*(id *)(a1 + 2952), "setComputePipelineState:", compute_pipeline);
  v12 = objc_msgSend(compute_pipeline, "threadExecutionWidth");
  v13 = objc_msgSend(compute_pipeline, "maxTotalThreadsPerThreadgroup");
  v14 = objc_msgSend(compute_pipeline, "threadExecutionWidth");
  v15.i32[0] = v12;
  v16 = vcvt_f32_s32(a2[5]);
  v17 = (int8x8_t)vrndp_f32(vmul_f32(v16, (float32x2_t)0x3F0000003F000000));
  v52 = v9;
  if (v9)
    v18 = -1;
  else
    v18 = 0;
  v19 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v18), (int8x8_t)v16, v17);
  v19.i32[0] = ceilf(0.125 * v19.f32[0]);
  v20 = (int32x2_t)vcvt_u32_f32(v19);
  v15.i32[1] = v13 / v14;
  v21 = vadd_s32(vadd_s32(v15, (int32x2_t)-1), v20);
  v53 = v13 / v14;
  v22 = v21.i32[1] / (v13 / v14);
  v20.i32[0] = v21.i32[0] / v12;
  v56 = v21.i32[0] / v12;
  v23 = vmul_s32(v20, vdup_n_s32(v22)).u32[0];
  v24 = CA::OGL::MetalBufferPool::create_external_buffer(*(CA::OGL::MetalBufferPool **)(a1 + 3992), 16 * v23, 0x10uLL, v6);
  v25 = (uint64_t)v24;
  if (v24)
  {
    v58 = v24[4];
    v26 = *((_DWORD *)v24 + 10);
  }
  else
  {
    v58 = 0;
    v26 = 0;
  }
  gamma_lut_buffer = *(void **)(a1 + 4000);
  if (!gamma_lut_buffer)
  {
    gamma_lut_buffer = CA::OGL::create_gamma_lut_buffer(*(void **)(a1 + 2904));
    *(_QWORD *)(a1 + 4000) = gamma_lut_buffer;
  }
  if (!v58 || !gamma_lut_buffer)
  {
    if (v25)
      CA::OGL::MetalBufferPool::release_external_buffer(*(_QWORD *)(a1 + 3992), v25);
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v39 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_184457000, v39, OS_LOG_TYPE_ERROR, "Failed to allocate Metal buffer\n", buf, 2u);
      }
    }
    goto LABEL_39;
  }
  if (v23 >= 8)
    v28 = 8;
  else
    v28 = v23;
  v29 = (v23 / v28 - 1) | (((unint64_t)(v23 / v28) - 1) >> 1);
  v30 = v29 | (v29 >> 2) | ((v29 | (v29 >> 2)) >> 4);
  v31 = v30 | (v30 >> 8) | ((v30 | (v30 >> 8)) >> 16);
  v55 = (v31 | HIDWORD(v31)) + 1;
  if (v55 >= objc_msgSend(compute_pipeline, "maxTotalThreadsPerThreadgroup"))
    LODWORD(v55) = objc_msgSend(compute_pipeline, "maxTotalThreadsPerThreadgroup");
  v67 = 0;
  v66 = 0;
  v32 = CA::OGL::MetalBufferPool::alloc_bytes(*(CA::OGL::MetalBufferPool **)(a1 + 3992), 0x30u, 0x10u, &v67, &v66);
  if (!v32)
  {
    if (v25)
      CA::OGL::MetalBufferPool::release_external_buffer(*(_QWORD *)(a1 + 3992), v25);
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v45 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_184457000, v45, OS_LOG_TYPE_ERROR, "Failed to allocate uniform Metal buffer\n", buf, 2u);
      }
    }
    v46 = external_buffer[2];
    if (v46)
    {
      if (!CA::OGL::MetalContext::start_blit_encoder((CA::OGL::MetalContext *)a1, v46))
        return external_buffer;
      *(_QWORD *)buf = 0;
      v68 = 0;
      v47 = CA::OGL::MetalBufferPool::alloc_bytes(*(CA::OGL::MetalBufferPool **)(a1 + 3992), *((_DWORD *)external_buffer + 2), 4u, buf, &v68);
      if (!v47)
        return external_buffer;
      memset_pattern16(v47, &unk_18474EA00, 0x30uLL);
      v42 = *(void **)(a1 + 2944);
      v43 = *(_QWORD *)buf;
      v44 = v68;
      goto LABEL_43;
    }
    goto LABEL_54;
  }
  v33 = v32;
  v57 = __PAIR64__(v22, v56);
  v34 = a2[5].i16[0];
  v32[16] = v34;
  v32[17] = a2[5].i16[2];
  v32[16] = v34;
  if (v52)
    v35 = 1;
  else
    v35 = 4;
  *((_BYTE *)v32 + 44) = v35;
  *(_QWORD *)v32 = *(_QWORD *)a3;
  *((_OWORD *)v32 + 1) = *(_OWORD *)(a3 + 8);
  *((_DWORD *)v32 + 9) = (v23 + v55 - 1) / v55;
  *((_DWORD *)v32 + 10) = v23;
  *((_BYTE *)v32 + 45) = (*(_BYTE *)(a3 + 20) & 8) != 0;
  *((_BYTE *)v32 + 46) = 0;
  v36 = *(_QWORD *)(a1 + 176);
  if (v36)
  {
    v37 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v36 + 16))(v36);
    if (v37)
    {
      if ((*(_BYTE *)(a3 + 20) & 4) != 0)
      {
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v37 + 864))(v37))
        {
          if ((*(_WORD *)(a1 + 816) & 2) != 0)
            v38 = (*(unsigned __int8 *)(a3 + 20) >> 1) & 1;
          else
            LOBYTE(v38) = 1;
        }
        else
        {
          LOBYTE(v38) = 0;
        }
        *((_BYTE *)v33 + 46) = v38;
      }
    }
  }
  objc_msgSend(*(id *)(a1 + 2952), "setTexture:atIndex:", *(_QWORD *)&a2[12], 0);
  objc_msgSend(*(id *)(a1 + 2952), "setBuffer:offset:atIndex:", v67, v66, 0);
  objc_msgSend(*(id *)(a1 + 2952), "setBuffer:offset:atIndex:", v58, v26, 2);
  objc_msgSend(*(id *)(a1 + 2952), "setBuffer:offset:atIndex:", *(_QWORD *)(a1 + 4000), 0, 4);
  objc_msgSend(*(id *)(a1 + 2952), "setThreadgroupMemoryLength:atIndex:", 16 * v12 * v53, 0);
  v48 = *(void **)(a1 + 2952);
  *(_QWORD *)&v49 = v57;
  *((_QWORD *)&v49 + 1) = HIDWORD(v57);
  v64 = v49;
  v65 = 1;
  v63[0] = v12;
  v63[1] = v53;
  v63[2] = 1;
  objc_msgSend(v48, "dispatchThreadgroups:threadsPerThreadgroup:", &v64, v63);
  objc_msgSend(*(id *)(a1 + 2952), "setComputePipelineState:", v54);
  objc_msgSend(*(id *)(a1 + 2952), "setBuffer:offset:atIndex:", v58, v26, 1);
  objc_msgSend(*(id *)(a1 + 2952), "setBuffer:offset:atIndex:", external_buffer[4], *((unsigned int *)external_buffer + 10), 2);
  objc_msgSend(*(id *)(a1 + 2952), "setThreadgroupMemoryLength:atIndex:", 16 * v55, 0);
  v50 = *(void **)(a1 + 2952);
  v60 = vdupq_n_s64(1uLL);
  v61 = v60;
  v62 = 1;
  v59 = v55;
  objc_msgSend(v50, "dispatchThreadgroups:threadsPerThreadgroup:", &v61, &v59);
  if (v25)
    CA::OGL::MetalBufferPool::release_external_buffer(*(_QWORD *)(a1 + 3992), v25);
  return external_buffer;
}

void CA::OGL::MetalContext::shared_event_wait_read(CA::OGL::MetalContext *this, CA::WindowServer::SharedEvent *a2)
{
  CA::OGL::MetalContext::shared_event_submit(this, (uint64_t)a2, (const char *)1, 1);
}

void CA::OGL::MetalContext::shared_event_signal_read(CA::OGL::MetalContext *this, CA::WindowServer::SharedEvent *a2)
{
  CA::OGL::MetalContext::shared_event_submit(this, (uint64_t)a2, 0, 1);
}

void CA::OGL::MetalContext::shared_event_wait_write(CA::OGL::MetalContext *this, CA::WindowServer::SharedEvent *a2)
{
  CA::OGL::MetalContext::shared_event_submit(this, (uint64_t)a2, (const char *)1, 2);
}

void CA::OGL::MetalContext::shared_event_signal_write(CA::OGL::MetalContext *this, CA::WindowServer::SharedEvent *a2)
{
  CA::OGL::MetalContext::shared_event_submit(this, (uint64_t)a2, 0, 2);
}

void CA::OGL::MetalContext::clear_surface(CA::OGL::MetalContext *this, CA::WindowServer::Surface *a2)
{
  uint64_t v2;
  uint64_t v3;
  double v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t i;
  _QWORD v10[9];
  char v11;
  _BYTE v12[976];
  uint64_t v13;

  v4 = MEMORY[0x1E0C80A78](this);
  v13 = *MEMORY[0x1E0C80C00];
  if (v3)
  {
    v5 = v3;
    v6 = v2;
    v7 = (void *)MEMORY[0x186DBE2E4](v4);
    if (CA::OGL::MetalContext::make_buffer_current((CA::OGL::MetalContext *)v6, (CA::WindowServer::Surface *)v5))
    {
      bzero(v12, 0x3D0uLL);
      CA::OGL::Context::prepare_context(v6, (uint64_t)v12);
      *(_QWORD *)(v6 + 120) = &v11;
      *(_QWORD *)(v6 + 136) = 128;
      v10[4] = 0x3C003C003C003C00;
      memset(&v10[5], 0, 24);
      v10[8] = 0x4013F800000;
      v10[2] = 0;
      v10[3] = &CA::identity_transform;
      v10[0] = 0;
      v10[1] = &CA::Shape::_infinite_shape;
      CA::OGL::MetalContext::begin_rendering(v6, (uint64_t)v10);
      CA::OGL::MetalContext::shared_event_submit((CA::OGL::MetalContext *)v6, *(_QWORD *)(v5 + 16), (const char *)1, 2);
      *(_BYTE *)(*(_QWORD *)(v6 + 16) + 481) &= ~1u;
      *(_BYTE *)(*(_QWORD *)(v6 + 16) + 16) = 0;
      *(_QWORD *)(v6 + 128) = 0;
      *(_QWORD *)(v6 + 96) = v6 + 818;
      *(_OWORD *)(v6 + 104) = xmmword_18474E060;
      CA::OGL::Context::array_rect((_QWORD *)v6, 0.0, 0.0, (float)*(unsigned int *)(v5 + 56), (float)*(unsigned int *)(v5 + 60));
      v8 = *(_QWORD *)(v6 + 120) + 48 * *(_QWORD *)(v6 + 128);
      *(_QWORD *)(v8 - 160) = 0x3C00000000000000;
      *(_QWORD *)(v8 - 112) = 0x3C00000000000000;
      *(_QWORD *)(v8 - 64) = 0x3C00000000000000;
      *(_QWORD *)(v8 - 16) = 0x3C00000000000000;
      CA::OGL::Context::array_flush(v6);
      CA::OGL::MetalContext::shared_event_submit((CA::OGL::MetalContext *)v6, *(_QWORD *)(v5 + 16), 0, 2);
      CA::OGL::MetalContext::end_rendering(v6);
      CA::OGL::MetalContext::make_buffer_current((CA::OGL::MetalContext *)v6, 0);
      CA::OGL::MetalContext::flush((CA::OGL::MetalContext *)v6, 1);
      objc_msgSend(*(id *)(v6 + 2920), "waitUntilCompleted");

      *(_QWORD *)(v6 + 2920) = 0;
      for (i = 488; i != -488; i -= 488)
      {
        if (*(_QWORD *)&v12[i])
          __assert_rtn("~ContextState", "ogl-context.h", 551, "!next && \"Imbalanced ContextState push/pop\"");
      }
    }
    objc_autoreleasePoolPop(v7);
  }
}

BOOL CA::OGL::MetalContext::backward_dm(uint64_t a1, _QWORD *a2, _QWORD *a3, double *a4, double *a5, _QWORD *a6, double *a7, double *a8, uint64_t *a9, _OWORD *a10, uint64_t a11)
{
  uint64_t v18;
  unint64_t v19;
  __IOSurface *v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  objc_class *v27;
  uint64_t v28;
  uint64_t v29;
  id v30;
  void *v31;
  double v32;
  uint64_t v33;
  double v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  double v38;
  uint64_t v39;
  double v40;
  uint64_t v41;
  double v42;
  uint64_t v43;
  double v44;
  uint64_t v45;
  double v46;
  uint64_t v47;
  double v48;
  uint64_t v49;
  double v50;
  uint64_t v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  const char *v58;
  uint64_t v59;
  NSObject *v60;
  _BOOL8 v61;
  double v63;
  int v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  uint64_t *v69;
  double v70;
  double v71;
  double v72;
  unsigned int v73;
  unsigned int v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  double *v81;
  unint64_t v82;
  unint64_t v83;
  uint64_t v84;
  size_t v85;
  uint64_t v86;
  unsigned int v87;
  double v88;
  double v89;
  double v90;
  uint64_t v91;
  unsigned int v92;
  unsigned int v93;
  unint64_t v94;
  unsigned int v95;
  double v96;
  double v97;
  double v98;
  uint64_t v99;
  size_t v100;
  double v101;
  double v102;
  double v103;
  unsigned int v104;
  unsigned int v105;
  uint64_t v117;
  NSObject *v118;
  char *v119;
  double *v120;
  CA::Render *Width;
  unsigned int Height;
  unsigned int v123;
  const __CFString *v124;
  __IOSurface *v125;
  float v126;
  float v127;
  float v128;
  float v129;
  uint64_t v130;
  unint64_t v131;
  unint64_t v132;
  uint64_t v133;
  id *v134;
  double *v135;
  unint64_t v136;
  double *v137;
  __IOSurface *buffer;
  _BYTE buf[32];
  int v140;
  uint8_t v141[16];
  __int128 v142;
  uint64_t v143;

  v143 = *MEMORY[0x1E0C80C00];
  if (CADeviceSupportsHDRProcessing::once[0] != -1)
  {
    v120 = a7;
    dispatch_once(CADeviceSupportsHDRProcessing::once, &__block_literal_global_122);
    a7 = v120;
  }
  if (!CADeviceSupportsHDRProcessing::supports_hdr)
    return 0;
  if (a2 && a2[2])
    __assert_rtn("backward_dm", "ogl-metal.mm", 16342, "!dst || !dst->shared_event ()");
  if (a3 && a3[2])
    __assert_rtn("backward_dm", "ogl-metal.mm", 16343, "!srcVideo || !srcVideo->shared_event ()");
  v137 = a7;
  if (!a6)
  {
    v18 = 0;
    if (a3)
      goto LABEL_11;
LABEL_14:
    v19 = 0;
    if (a2)
      goto LABEL_12;
    goto LABEL_15;
  }
  if (a6[2])
    __assert_rtn("backward_dm", "ogl-metal.mm", 16344, "!srcUI || !srcUI->shared_event ()");
  v18 = (*(uint64_t (**)(_QWORD *))(*a6 + 160))(a6);
  if (!a3)
    goto LABEL_14;
LABEL_11:
  v19 = (*(uint64_t (**)(_QWORD *))(*a3 + 160))(a3);
  if (a2)
  {
LABEL_12:
    v20 = (__IOSurface *)(*(uint64_t (**)(_QWORD *))(*a2 + 160))(a2);
    goto LABEL_16;
  }
LABEL_15:
  v20 = 0;
LABEL_16:
  v21 = CA::OGL::MetalContext::backward_dm(CA::WindowServer::Surface *,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::OGL::ExtendedColor const&,CA::Mat4<float> const*,CA::Render::DisplayAttributes const*)::debug_iosurface;
  if (byte_1ECDC6A84)
  {
    if (!CA::OGL::MetalContext::backward_dm(CA::WindowServer::Surface *,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::OGL::ExtendedColor const&,CA::Mat4<float> const*,CA::Render::DisplayAttributes const*)::debug_iosurface)
    {
      Width = (CA::Render *)IOSurfaceGetWidth(v20);
      Height = IOSurfaceGetHeight(v20);
      CA::OGL::MetalContext::backward_dm(CA::WindowServer::Surface *,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::OGL::ExtendedColor const&,CA::Mat4<float> const*,CA::Render::DisplayAttributes const*)::debug_iosurface = (uint64_t)CA::Render::create_iosurface((CA::Render *)0x23, Width, Height, 0, v123, v124);
      CA::OGL::fillB3A8SurfaceWithColor((CA::OGL *)CA::OGL::MetalContext::backward_dm(CA::WindowServer::Surface *,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::OGL::ExtendedColor const&,CA::Mat4<float> const*,CA::Render::DisplayAttributes const*)::debug_iosurface, v125, v126, v127, v128, v129);
      v21 = CA::OGL::MetalContext::backward_dm(CA::WindowServer::Surface *,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::OGL::ExtendedColor const&,CA::Mat4<float> const*,CA::Render::DisplayAttributes const*)::debug_iosurface;
    }
  }
  else
  {
    if (CA::OGL::MetalContext::backward_dm(CA::WindowServer::Surface *,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::OGL::ExtendedColor const&,CA::Mat4<float> const*,CA::Render::DisplayAttributes const*)::debug_iosurface)
    {
      CFRelease((CFTypeRef)CA::OGL::MetalContext::backward_dm(CA::WindowServer::Surface *,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::OGL::ExtendedColor const&,CA::Mat4<float> const*,CA::Render::DisplayAttributes const*)::debug_iosurface);
      CA::OGL::MetalContext::backward_dm(CA::WindowServer::Surface *,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::WindowServer::Surface *,CA::Rect &,CA::Rect &,CA::OGL::ExtendedColor const&,CA::Mat4<float> const*,CA::Render::DisplayAttributes const*)::debug_iosurface = 0;
    }
    v21 = v18;
  }
  if (!(v21 | v19) || !v20)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v60 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_184457000, v60, OS_LOG_TYPE_ERROR, "Backward DM has no inputs\n", buf, 2u);
      }
    }
    return 0;
  }
  v135 = a8;
  v22 = IOSurfaceGetWidth(v20);
  buffer = v20;
  v23 = IOSurfaceGetHeight(v20);
  v24 = v23;
  v136 = v19;
  if (!*(_DWORD *)(a1 + 3104)
    && !*(_DWORD *)(a1 + 3108)
    && *(_DWORD *)(a1 + 3112) == v22
    && *(_DWORD *)(a1 + 3116) == v23
    && *(float *)(a1 + 3124) == *(float *)(a11 + 4)
    && *(_DWORD *)(a1 + 3180) == *(_DWORD *)(a11 + 60)
    && CA::Render::Chromaticity::operator==(a1 + 3188, a11 + 68))
  {
    v134 = (id *)(a1 + 3088);
    if (*(_QWORD *)(a1 + 3088))
      goto LABEL_45;
  }
  else
  {
    v134 = (id *)(a1 + 3088);

    *(_QWORD *)(a1 + 3088) = 0;
    *(_QWORD *)(a1 + 3104) = 0;
    *(_DWORD *)(a1 + 3112) = v22;
    *(_DWORD *)(a1 + 3116) = v24;
  }
  v25 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB34D0], "bundleWithPath:", CFSTR("/System/Library/PrivateFrameworks/HDRProcessing.framework")), "classNamed:", CFSTR("HDRBackwardDisplayManagement"));
  v26 = *(_DWORD *)(a11 + 60) - 2;
  if (v26 > 2)
    goto LABEL_112;
  v27 = (objc_class *)v25;
  v28 = *off_1E159E490[v26];
  v29 = *off_1E159E478[v26];
  v30 = objc_alloc(MEMORY[0x1E0C99E08]);
  v31 = (void *)objc_msgSend(v30, "initWithObjectsAndKeys:", v29, _kHDRProcessingDisplayColorFormatKey, v28, _kHDRProcessingDestinationDisplayTypeKey, 0);
  if (*(float *)(a11 + 4) != 0.0)
  {
    v33 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:");
    objc_msgSend(v31, "setObject:forKeyedSubscript:", v33, _kHDRProcessingDisplayMaximumBrightnessInNitsKey);
    LODWORD(v34) = *(_DWORD *)a11;
    v35 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v34);
    objc_msgSend(v31, "setObject:forKeyedSubscript:", v35, _kHDRProcessingDisplayMinimumBrightnessInNitsKey);
  }
  if (*(int *)(a11 + 124) >= 1 && _kHDRProcessingDisplayDolbyVisionDMVersionKey)
  {
    v36 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:");
    objc_msgSend(v31, "setObject:forKeyedSubscript:", v36, _kHDRProcessingDisplayDolbyVisionDMVersionKey);
  }
  if (*(_BYTE *)(a11 + 100) && _kHDRProcessingDisplayChromaticityBx)
  {
    LODWORD(v32) = *(_DWORD *)(a11 + 84);
    v37 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v32);
    objc_msgSend(v31, "setObject:forKeyedSubscript:", v37, _kHDRProcessingDisplayChromaticityBx);
    LODWORD(v38) = *(_DWORD *)(a11 + 88);
    v39 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v38);
    objc_msgSend(v31, "setObject:forKeyedSubscript:", v39, _kHDRProcessingDisplayChromaticityBy);
    LODWORD(v40) = *(_DWORD *)(a11 + 76);
    v41 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v40);
    objc_msgSend(v31, "setObject:forKeyedSubscript:", v41, _kHDRProcessingDisplayChromaticityGx);
    LODWORD(v42) = *(_DWORD *)(a11 + 80);
    v43 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v42);
    objc_msgSend(v31, "setObject:forKeyedSubscript:", v43, _kHDRProcessingDisplayChromaticityGy);
    LODWORD(v44) = *(_DWORD *)(a11 + 68);
    v45 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v44);
    objc_msgSend(v31, "setObject:forKeyedSubscript:", v45, _kHDRProcessingDisplayChromaticityRx);
    LODWORD(v46) = *(_DWORD *)(a11 + 72);
    v47 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v46);
    objc_msgSend(v31, "setObject:forKeyedSubscript:", v47, _kHDRProcessingDisplayChromaticityRy);
    LODWORD(v48) = *(_DWORD *)(a11 + 92);
    v49 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v48);
    objc_msgSend(v31, "setObject:forKeyedSubscript:", v49, _kHDRProcessingDisplayChromaticityWx);
    LODWORD(v50) = *(_DWORD *)(a11 + 96);
    v51 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v50);
    objc_msgSend(v31, "setObject:forKeyedSubscript:", v51, _kHDRProcessingDisplayChromaticityWy);
  }
  if (!v31)
  {
LABEL_112:
    x_log_crash("FATAL: Could not create backwardDM display properties!");
    goto LABEL_114;
  }
  *(_QWORD *)(a1 + 3088) = objc_msgSend([v27 alloc], "initWithDevice:displayProperties:", *(_QWORD *)(a1 + 2904), v31);
  v52 = *(_OWORD *)(a11 + 32);
  v53 = *(_OWORD *)(a11 + 48);
  v54 = *(_OWORD *)(a11 + 16);
  *(_OWORD *)(a1 + 3120) = *(_OWORD *)a11;
  *(_OWORD *)(a1 + 3168) = v53;
  *(_OWORD *)(a1 + 3152) = v52;
  *(_OWORD *)(a1 + 3136) = v54;
  v55 = *(_OWORD *)(a11 + 96);
  v56 = *(_OWORD *)(a11 + 112);
  v57 = *(_OWORD *)(a11 + 80);
  *(_OWORD *)(a1 + 3184) = *(_OWORD *)(a11 + 64);
  *(_OWORD *)(a1 + 3232) = v56;
  *(_OWORD *)(a1 + 3216) = v55;
  *(_OWORD *)(a1 + 3200) = v57;
  CFRelease(v31);
  if (!*(_QWORD *)(a1 + 3088))
  {
    x_log_crash("Failed to initialize HDRBackwardDisplayManagement!");
LABEL_114:
    abort();
  }
LABEL_45:
  CA::OGL::MetalContext::stop_encoders((CA::OGL::MetalContext *)a1);
  if (a2)
    v59 = (*(uint64_t (**)(_QWORD *))(*a2 + 216))(a2);
  else
    v59 = 0;
  if (!CA::OGL::MetalContext::start_command_buffer((CA::OGL::MetalContext *)a1, v59, v58))
    return 0;
  if (BYTE9(xmmword_1ECDC6A90))
  {
    if (v21)
      IOSurfaceGetID((IOSurfaceRef)v21);
    if (v19)
      IOSurfaceGetID((IOSurfaceRef)v19);
    IOSurfaceGetID(buffer);
    kdebug_trace();
  }
  if (initialized[0] != -1)
    dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
  v64 = dword_1ECDC698C;
  if (*(float *)&dword_1ECDC698C == 0.0)
    v64 = *(_DWORD *)(a11 + 4);
  if (v19)
    objc_msgSend(*(id *)(a1 + 3096), "setObject:forKeyedSubscript:", IOSurfaceCopyAllValues((IOSurfaceRef)v19), _kHDRProcessingDolbyVisionBackwardDMDictinary);
  LODWORD(v63) = v64;
  v65 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v63);
  objc_msgSend(*(id *)(a1 + 3096), "setObject:forKeyedSubscript:", v65, _kHDRProcessingSDRMaxBrightnessInNits);
  if (a10)
  {
    v66 = a10[1];
    v67 = a10[2];
    *(_OWORD *)v141 = *a10;
    v142 = v66;
    *(_DWORD *)buf = *(_DWORD *)v141;
    *(_QWORD *)&v68 = *(_QWORD *)&v141[4];
    *((_QWORD *)&v68 + 1) = v66;
    *(_DWORD *)&buf[20] = DWORD2(v66);
    *(_OWORD *)&buf[4] = v68;
    *(_QWORD *)&buf[24] = v67;
    v140 = DWORD2(v67);
    objc_msgSend(*v134, "setAccessibilityMatrix:", buf);
  }
  v69 = a9;
  if (v19)
  {
    v70 = a4[2];
    v71 = a4[3];
    if (v70 >= v71)
      v72 = a4[3];
    else
      v72 = a4[2];
    if (v72 > 0.0)
    {
      v19 = a4[1];
      v76 = v70 | ((unint64_t)v71 << 32);
      v75 = *a4 & 0xFFFFFFFE;
    }
    else
    {
      v73 = IOSurfaceGetWidth((IOSurfaceRef)v19);
      v74 = IOSurfaceGetHeight((IOSurfaceRef)v19);
      v19 = 0;
      v75 = 0;
      v76 = v73 | ((unint64_t)v74 << 32);
    }
    v88 = a5[2];
    v89 = a5[3];
    if (v88 >= v89)
      v90 = a5[3];
    else
      v90 = a5[2];
    if (v90 > 0.0)
    {
      v95 = *a5;
      v78 = a5[1];
      v94 = v88 | ((unint64_t)v89 << 32);
      v79 = v95 & 0xFFFFFFFE;
    }
    else
    {
      v91 = v75;
      v92 = IOSurfaceGetWidth(buffer);
      v93 = IOSurfaceGetHeight(buffer);
      v75 = v91;
      v78 = 0;
      v79 = 0;
      v94 = v92 | ((unint64_t)v93 << 32);
    }
    v81 = v137;
    v80 = v76 & 0xFFFFFFFFFFFFFFFELL;
    v77 = v94 & 0xFFFFFFFFFFFFFFFELL;
    if (v21)
      goto LABEL_78;
LABEL_69:
    v82 = 0;
    v83 = 0;
    v84 = 0;
    v85 = 0;
    v86 = 0;
    v87 = 0;
    goto LABEL_91;
  }
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v75 = 0;
  v81 = v137;
  if (!v21)
    goto LABEL_69;
LABEL_78:
  v133 = v75;
  v96 = v81[2];
  v97 = v81[3];
  if (v96 >= v97)
    v98 = v81[3];
  else
    v98 = v81[2];
  v131 = v80;
  v132 = v77;
  v130 = v79;
  if (v98 > 0.0)
  {
    v87 = *v81;
    v86 = v81[1];
    v99 = v96;
    v100 = v97;
  }
  else
  {
    v99 = IOSurfaceGetWidth((IOSurfaceRef)v21);
    v100 = IOSurfaceGetHeight((IOSurfaceRef)v21);
    v86 = 0;
    v87 = 0;
  }
  v85 = v99 | (v100 << 32);
  v101 = v135[2];
  v102 = v135[3];
  if (v101 >= v102)
    v103 = v135[3];
  else
    v103 = v135[2];
  if (v103 > 0.0)
  {
    v84 = *v135;
    v82 = v101 | ((unint64_t)v102 << 32);
    v83 = (unint64_t)v135[1] << 32;
  }
  else
  {
    v104 = IOSurfaceGetWidth(buffer);
    v105 = IOSurfaceGetHeight(buffer);
    v83 = 0;
    v84 = 0;
    v82 = v104 | ((unint64_t)v105 << 32);
  }
  v75 = v133;
  v69 = a9;
  v80 = v131;
  v77 = v132;
  v79 = v130;
LABEL_91:
  _D0 = *v69;
  _H1 = WORD1(*v69);
  __asm
  {
    FCVT            D1, H1
    FCVT            D0, H0
  }
  *((_QWORD *)&_Q0 + 1) = _D1;
  LODWORD(_D1) = *((_DWORD *)v69 + 1);
  _H2 = WORD1(_D1);
  __asm
  {
    FCVT            D2, H2
    FCVT            D1, H1
  }
  *((_QWORD *)&_Q1 + 1) = _D2;
  *(_OWORD *)buf = _Q0;
  *(_OWORD *)&buf[16] = _Q1;
  v117 = objc_msgSend(*(id *)(a1 + 3088), "encodeToCommandBuffer:video:videoSrcRegion:videoDstRegion:ui:uiSrcRegion:uiDstRegion:backgroundColor:output:frameProperties:", *(_QWORD *)(a1 + 2928), v136, v75 | (v19 << 32), v80, v79 | (v78 << 32), v77, v21, v87 | (unint64_t)(v86 << 32), v85, v84 | v83, v82, buf, buffer, *(_QWORD *)(a1 + 3096));
  objc_msgSend(*(id *)(a1 + 3096), "removeObjectForKey:", _kHDRProcessingDolbyVisionBackwardDMDictinary);
  v61 = v117 == -17000;
  if (v117 != -17000)
  {
    if (x_log_hook_p())
    {
      if ((unint64_t)(v117 + 17008) >= 8)
        snprintf(CA::OGL::hdr_processing_error_str(HDRError)::err_buffer, 0x20uLL, "%d", v117);
      x_log_();
    }
    else
    {
      v118 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        if ((unint64_t)(v117 + 17008) >= 8)
        {
          v119 = CA::OGL::hdr_processing_error_str(HDRError)::err_buffer;
          snprintf(CA::OGL::hdr_processing_error_str(HDRError)::err_buffer, 0x20uLL, "%d", v117);
        }
        else
        {
          v119 = off_1E15A67D8[v117 + 17008];
        }
        *(_DWORD *)v141 = 136315138;
        *(_QWORD *)&v141[4] = v119;
        _os_log_impl(&dword_184457000, v118, OS_LOG_TYPE_ERROR, "Backward DM failed to convert surface: %s\n", v141, 0xCu);
      }
    }
  }
  return v61;
}

uint64_t CA::OGL::MetalContext::surface_pixel_size(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  char v4;
  unint64_t v5;

  if ((*(_BYTE *)(a2 + 69) & 8) != 0 || (*(_BYTE *)(a2 + 72) & 1) == 0)
    return 0;
  v3 = *(_QWORD *)(a2 + 120);
  v4 = v3 - 70;
  if (v3 - 70 <= 0x37)
  {
    if (((1 << v4) & 0x1100C03) != 0)
      return 4;
    if (((1 << v4) & 0x210000000000) != 0)
      return 8;
    if (v3 == 125)
      return 16;
  }
  if (v3 <= 0x2B)
  {
    if (((1 << v3) & 0xA00C0000000) != 0)
      return 2;
    if (((1 << v3) & 0xC02) != 0)
      return 1;
  }
  v5 = v3 - 550;
  if (v5 > 5)
    return 4;
  if (((1 << v5) & 3) == 0)
  {
    if (((1 << v5) & 0xC) != 0)
      return 8;
    return 4;
  }
  return 5;
}

double CA::OGL::MetalContext::last_command_buffer_duration(CA::OGL::MetalContext *this)
{
  return *((double *)this + 504);
}

uint64_t CA::OGL::fillB3A8SurfaceWithColor(CA::OGL *this, __IOSurface *a2, float a3, float a4, float a5, float a6)
{
  void *BaseAddressOfPlane;
  size_t BytesPerRowOfPlane;
  size_t Height;
  void *v10;
  size_t v11;
  size_t v12;
  int v14;
  int __pattern4;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  IOSurfaceLock(this, 0, 0);
  __pattern4 = -537525888;
  BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(this, 0);
  if ((IOSurfaceGetBytesPerRow(this) & 3) != 0)
    __assert_rtn("fillB3A8SurfaceWithColor", "ogl-metal.mm", 16186, "IOSurfaceGetBytesPerRow (surface) % 4 == 0");
  BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(this, 0);
  Height = IOSurfaceGetHeight(this);
  memset_pattern4(BaseAddressOfPlane, &__pattern4, Height * BytesPerRowOfPlane);
  v14 = -2139062144;
  v10 = IOSurfaceGetBaseAddressOfPlane(this, 1uLL);
  v11 = IOSurfaceGetBytesPerRowOfPlane(this, 1uLL);
  v12 = IOSurfaceGetHeight(this);
  memset_pattern4(v10, &v14, v12 * v11);
  return IOSurfaceUnlock(this, 0, 0);
}

void CA::OGL::MetalContext::issue_cache_drop_hints(CA::OGL::MetalContext *this)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  size_t v6;
  char *v7;
  __int128 v8;
  int v9;
  void *v10;
  __int16 v11;
  int v12;
  uint64_t v13;
  _BOOL4 v14;
  int v15;
  uint64_t v16;
  int v17;
  void *v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  char *Name;
  __int128 v24;
  uint8_t buf[4];
  uint64_t v26;
  __int16 v27;
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 10);
  if (v2)
  {
    v3 = -1;
    v4 = *((_QWORD *)this + 10);
    do
    {
      v5 = v3;
      v4 = *(_QWORD *)(v4 + 8);
      ++v3;
    }
    while (v4);
    v6 = 8 * (v5 + 2);
    if (v3 > 0x1FF)
    {
      v7 = (char *)malloc_type_malloc(8 * (v5 + 2), 0x80040B8603338uLL);
      v2 = *((_QWORD *)this + 10);
      if (!v2)
        goto LABEL_28;
      goto LABEL_9;
    }
  }
  else
  {
    v6 = 0;
  }
  MEMORY[0x1E0C80A78](this);
  v7 = (char *)&v20 - ((v6 + 15) & 0xFFFFFFFF0);
  bzero(v7, v6);
  if (!v2)
    goto LABEL_28;
LABEL_9:
  v9 = 0;
  v10 = &unk_1ECDC6000;
  *(_QWORD *)&v8 = 134219010;
  do
  {
    v11 = *(_WORD *)(v2 + 232);
    if ((v11 & 0x40) != 0 && *(_QWORD *)(v2 + 152) == *((_QWORD *)this + 366))
    {
      if (byte_1ECDC6AAB && (*(_BYTE *)(v2 + 72) & 1) != 0)
      {
        v24 = v8;
        if (x_log_hook_p())
        {
          Name = (char *)MTLPixelFormatGetName();
          v12 = strncmp(Name, "MTLPixelFormat", 0xEuLL);
          v13 = 14;
          if (v12)
            v13 = 0;
          Name += v13;
          v22 = (const char *)objc_msgSend(*(id *)(v2 + 96), "width");
          objc_msgSend(*(id *)(v2 + 96), "height");
          x_log_();
          v10 = &unk_1ECDC6000;
          v8 = v24;
        }
        else
        {
          Name = (char *)x_log_category_ogl_metal;
          v14 = os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEBUG);
          v10 = &unk_1ECDC6000;
          v8 = v24;
          if (v14)
          {
            v22 = (const char *)MTLPixelFormatGetName();
            v15 = strncmp(v22, "MTLPixelFormat", 0xEuLL);
            v16 = 14;
            if (v15)
              v16 = 0;
            v22 += v16;
            v21 = objc_msgSend(*(id *)(v2 + 96), "width");
            v17 = objc_msgSend(*(id *)(v2 + 96), "height");
            *(_DWORD *)buf = v24;
            v26 = v2;
            v27 = 1024;
            v28 = 0;
            v29 = 2080;
            v30 = v22;
            v31 = 1024;
            v32 = v21;
            v33 = 1024;
            v34 = v17;
            _os_log_impl(&dword_184457000, (os_log_t)Name, OS_LOG_TYPE_DEBUG, "> drop surface %p texture %d %s %dx%d\n", buf, 0x28u);
            v8 = v24;
            v10 = &unk_1ECDC6000;
          }
        }
      }
      *(_QWORD *)&v7[8 * v9] = *(_QWORD *)(v2 + 144);
      v11 = *(_WORD *)(v2 + 232);
      ++v9;
    }
    *(_WORD *)(v2 + 232) = v11 & 0xFFBF;
    v2 = *(_QWORD *)(v2 + 8);
  }
  while (v2);
  if (v9 > 0)
  {
    if (byte_1ECDC6AAB)
    {
      v18 = v10;
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v19 = *((_QWORD *)v18 + 51);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 67109120;
          LODWORD(v26) = v9;
          _os_log_impl(&dword_184457000, v19, OS_LOG_TYPE_DEBUG, "issuing drop hints for %d surfaces", buf, 8u);
        }
      }
    }
    objc_msgSend(*((id *)this + 366), "encodeCacheHintFinalize:resourceGroups:count:", 1, v7, v9, *(double *)&v8);
  }
LABEL_28:
  if (v6 > 0x1000)
    free(v7);
}

uint64_t ___ZN2CA3OGLL15layer_flags_strEj_block_invoke()
{
  uint64_t result;

  result = objc_opt_new();
  CA::OGL::layer_flags_str::str_cache = result;
  return result;
}

void CA::OGL::MetalContext::shared_event_submit(CA::OGL::MetalContext *this, uint64_t a2, const char *a3, int a4)
{
  int v5;
  uint64_t v8;
  NSObject *v9;
  const char *v10;
  uint8_t *v11;
  __int16 v12;
  __int16 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v5 = (int)a3;
    if (*((_QWORD *)this + 366))
      CA::OGL::MetalContext::stop_encoders(this);
    else
      CA::OGL::MetalContext::start_command_buffer(this, *((_QWORD *)this + 380), a3);
    if (*((_QWORD *)this + 366))
    {
      v8 = *(_QWORD *)(a2 + 8);
      if (v8)
      {
        if (v5)
          objc_msgSend(*((id *)this + 366), "encodeWaitForEvent:value:", v8, CA::WindowServer::SharedEvent::get_wait_value(a2, 14, a4));
        else
          objc_msgSend(*((id *)this + 366), "encodeSignalEvent:value:", v8, CA::WindowServer::SharedEvent::inc_signal_value(a2, 14, a4));
        return;
      }
      if (x_log_hook_p())
      {
LABEL_12:
        x_log_();
        return;
      }
      v9 = x_log_category_sharedevent;
      if (!os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_ERROR))
        return;
      v12 = 0;
      v10 = "Invalid metal shared event";
      v11 = (uint8_t *)&v12;
    }
    else
    {
      if (x_log_hook_p())
        goto LABEL_12;
      v9 = x_log_category_sharedevent;
      if (!os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_ERROR))
        return;
      v13 = 0;
      v10 = "Invalid command buffer";
      v11 = (uint8_t *)&v13;
    }
    _os_log_impl(&dword_184457000, v9, OS_LOG_TYPE_ERROR, v10, v11, 2u);
  }
}

uint64_t CA::OGL::MetalContext::compute_surface_apl_dimming_factor(CA::OGL::Surface *,CA::OGL::APLFilterParams const&)::$_0::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v5;
  unsigned int v7;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 16);
  if (v3)
  {
    if (CA::OGL::MetalContext::start_blit_encoder((CA::OGL::MetalContext *)a1, v3))
    {
      v8[0] = 0;
      v7 = 0;
      v5 = CA::OGL::MetalBufferPool::alloc_bytes(*(CA::OGL::MetalBufferPool **)(a1 + 3992), *(_DWORD *)(a2 + 8), 4u, v8, &v7);
      if (v5)
      {
        memset_pattern16(v5, &unk_18474EA00, 0x30uLL);
        objc_msgSend(*(id *)(a1 + 2944), "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:", v8[0], v7, *(_QWORD *)(a2 + 32), *(unsigned int *)(a2 + 40), *(_QWORD *)(a2 + 8));
      }
    }
  }
  else
  {
    memset_pattern16(*(void **)a2, &unk_18474EA00, 0x30uLL);
  }
  return a2;
}

uint64_t CA::OGL::MetalContext::get_compute_pipeline(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t result;
  __CFString *v5;
  void *shader_function;
  void *v7;
  uint64_t *v8;
  const char *v9;
  const char *v10;
  const char *v11;
  const char *v12;
  NSObject *v13;
  NSObject *v14;
  CA::OGL::MetalContext *v15;
  unint64_t v16;
  id v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  char __str[2047];
  char v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = a1 + 8 * a2;
  result = *(_QWORD *)(v3 + 2600);
  if (!result)
  {
    v17 = 0;
    v5 = CA::OGL::MetalContext::get_compute_pipeline(CA::OGL::MetalContext::ComputeShaderType)::compute_fct_names[a2];
    shader_function = CA::OGL::MetalContext::load_shader_function(a1, *(void **)(a1 + 3288), v5, 0, 0, 0, (uint64_t)&v17);
    if (shader_function)
    {
      v7 = shader_function;
      v8 = (uint64_t *)(v3 + 2600);
      *v8 = objc_msgSend(*(id *)(a1 + 2904), "newComputePipelineStateWithFunction:error:", shader_function, &v17);

      result = *v8;
      if (*v8)
        return result;
      bzero(__str, 0x7FFuLL);
      v11 = (const char *)-[__CFString UTF8String](v5, "UTF8String");
      if (v17)
        v12 = (const char *)objc_msgSend((id)objc_msgSend(v17, "localizedDescription"), "UTF8String");
      else
        v12 = "";
      snprintf(__str, 0x800uLL, "pipeline with function=%s\n%s", v11, v12);
      v23 = 0;
      if (!x_log_hook_p())
      {
        v14 = x_log_category_ogl_metal;
        if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v19 = "Metal failed to build compute pipeline";
          v20 = 2080;
          v21 = __str;
          _os_log_impl(&dword_184457000, v14, OS_LOG_TYPE_ERROR, "%s: %s\n", buf, 0x16u);
        }
        goto LABEL_19;
      }
    }
    else
    {
      bzero(__str, 0x7FFuLL);
      v9 = (const char *)-[__CFString UTF8String](v5, "UTF8String");
      if (v17)
        v10 = (const char *)objc_msgSend((id)objc_msgSend(v17, "localizedDescription"), "UTF8String");
      else
        v10 = "";
      snprintf(__str, 0x800uLL, "function=%s\n%s", v9, v10);
      v23 = 0;
      if (!x_log_hook_p())
      {
        v13 = x_log_category_ogl_metal;
        if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v19 = "Metal failed to load compute shader";
          v20 = 2080;
          v21 = __str;
          _os_log_impl(&dword_184457000, v13, OS_LOG_TYPE_ERROR, "%s: %s\n", buf, 0x16u);
        }
        goto LABEL_19;
      }
    }
    x_log_();
LABEL_19:
    strlen(__str);
    v15 = (CA::OGL::MetalContext *)abort_with_payload();
    return CA::OGL::MetalContext::start_compute_encoder(v15, v16);
  }
  return result;
}

BOOL CA::OGL::MetalContext::start_compute_encoder(CA::OGL::MetalContext *this, uint64_t a2)
{
  const char *v4;
  _BOOL8 result;
  id v6;
  uint64_t v7;
  NSObject *v8;
  uint8_t v9[8];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 369))
    return 1;
  CA::OGL::MetalContext::stop_encoders(this);
  result = CA::OGL::MetalContext::start_command_buffer(this, a2, v4);
  if (!result)
    return result;
  v6 = (id)objc_msgSend(*((id *)this + 366), "computeCommandEncoderWithDispatchType:", 0);
  *((_QWORD *)this + 369) = v6;
  if (v6)
  {
    if (BYTE3(xmmword_1ECDC6AF0))
      v7 = mach_continuous_time();
    else
      v7 = 0;
    *((_QWORD *)this + 382) = v7;
    return 1;
  }
  if (x_log_hook_p())
  {
    x_log_();
    return 0;
  }
  v8 = x_log_category_ogl_metal;
  result = os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)v9 = 0;
    _os_log_impl(&dword_184457000, v8, OS_LOG_TYPE_ERROR, "Unable to start compute command encoder\n", v9, 2u);
    return 0;
  }
  return result;
}

void *CA::OGL::MetalBufferPool::alloc_bytes(CA::OGL::MetalBufferPool *this, unsigned int a2, unsigned int a3, _QWORD *a4, unsigned int *a5)
{
  _QWORD *v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  void *result;
  int v18;

  if ((a3 & (a3 - 1)) != 0)
    __assert_rtn("get_buffer", "ogl-metal.mm", 3133, "x_power_of_two (alignment)");
  v9 = (_QWORD *)((char *)this + 24);
  v10 = *((_QWORD *)this + 1);
  if (v10)
  {
    v11 = *((_DWORD *)this + 11);
    if (v11 <= a3)
      v11 = a3;
    v12 = *((_DWORD *)this + 6);
    v13 = *((_DWORD *)this + 7);
    v14 = (v11 + v12 - 1) & -v11;
    if (v13 != v14 && v13 >= v14 + a2 || v12 == 0)
      goto LABEL_15;
    CA::OGL::MetalBufferPool::retire_metal_buffer((uint64_t)this, v10);
    *((_QWORD *)this + 1) = 0;
    *v9 = 0;
    v9[1] = 0;
  }
  result = CA::OGL::MetalBufferPool::allocate_buffer((os_unfair_lock_s *)this, a2);
  *((_QWORD *)this + 1) = result;
  if (!result)
    return result;
  ++*((_DWORD *)this + 10);
  *((_QWORD *)this + 4) = objc_msgSend(result, "contents");
  v18 = objc_msgSend(*((id *)this + 1), "length");
  v14 = 0;
  *((_DWORD *)this + 7) = v18;
LABEL_15:
  *(_DWORD *)v9 = v14 + a2;
  if (a4)
    *a4 = *((_QWORD *)this + 1);
  if (a5)
    *a5 = v14;
  return (void *)(*((_QWORD *)this + 4) + v14);
}

void *CA::OGL::create_gamma_lut_buffer(void *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;
  uint64_t i;
  float v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int v16;
  int v17;
  _WORD *v18;
  int8x16_t v20;
  int8x16_t v21;

  v1 = (void *)objc_msgSend(a1, "newBufferWithLength:options:", 0x20000, 0);
  v2 = v1;
  if (v1)
  {
    objc_msgSend(v1, "setLabel:", CFSTR("com.apple.coreanimation.gamma-lut"));
    v3 = objc_msgSend(v2, "contents");
    for (i = 0; i != 0x8000; ++i)
    {
      _Q0.i16[0] = 2 * i;
      __asm { FCVT            S0, H0 }
      v11 = fabsf(*(float *)_Q0.i32);
      v21 = _Q0;
      if (v11 <= 0.04045)
      {
        *(float *)_Q1.i32 = *(float *)_Q0.i32 * 0.077399;
      }
      else
      {
        *(float *)v12.i32 = powf((float)(v11 * 0.94787) + 0.052133, 2.4);
        v13.i64[0] = 0x8000000080000000;
        v13.i64[1] = 0x8000000080000000;
        _Q1 = vbslq_s8(v13, v12, v21);
        _Q0 = v21;
      }
      if (v11 <= 0.0031308)
      {
        *(float *)_Q0.i32 = *(float *)_Q0.i32 * 12.92;
      }
      else
      {
        v20 = _Q1;
        *(float *)v14.i32 = (float)(powf(v11, 0.41667) * 1.055) + -0.055;
        v15.i64[0] = 0x8000000080000000;
        v15.i64[1] = 0x8000000080000000;
        _Q0 = vbslq_s8(v15, v14, v21);
        _Q1 = v20;
      }
      v16 = _Q1.i32[0] & 0x7FFFFFFF;
      __asm { FCVT            H1, S1 }
      v17 = _Q0.i32[0] & 0x7FFFFFFF;
      __asm { FCVT            H0, S0 }
      if (v16 >= 2139095040)
        *(float *)_Q1.i32 = 0.0;
      v18 = (_WORD *)(v3 + 2 * i);
      *v18 = _Q1.i16[0];
      if (v17 >= 2139095040)
        *(float *)_Q0.i32 = 0.0;
      v18[0x8000] = _Q0.i16[0];
    }
  }
  return v2;
}

void std::deque<objc_object  {objcproto9MTLBuffer}*>::__maybe_remove_back_spare[abi:nn180100](_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v2 = a1[1];
  v1 = a1[2];
  if (v1 == v2)
    v3 = 0;
  else
    v3 = ((v1 - v2) << 6) - 1;
  if ((unint64_t)(v3 - (a1[5] + a1[4])) >= 0x400)
  {
    operator delete(*(void **)(v1 - 8));
    a1[2] -= 8;
  }
}

uint64_t ___ZN2CA3OGL12MetalContext22calculate_average_lumaEPNS0_7SurfaceEU13block_pointerFvfE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  float v7;
  float v8;
  float v9;
  float v10;
  _QWORD v12[3];
  int64x2_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(void **)(*(_QWORD *)(a1 + 48) + 96);
  v15 = 0;
  memset(v12, 0, sizeof(v12));
  v13 = vdupq_n_s64(1uLL);
  v14 = 1;
  objc_msgSend(v3, "getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:", &v15, 4, 4, v12, 0, 0);
  if (HIBYTE(v15))
  {
    LOBYTE(v4) = BYTE2(v15);
    v5 = 1046066128;
    LOBYTE(v5) = BYTE1(v15);
    *(float *)&v6 = (float)v5;
    v7 = (float)((float)v4 * 0.2126) + (float)(*(float *)&v6 * 0.7152);
    LOBYTE(v6) = v15;
    v8 = (float)(v7 + (float)((float)v6 * 0.0722)) / (float)HIBYTE(v15);
    if (v8 > 1.0)
      v8 = 1.0;
    if (v8 >= 0.0)
      v9 = v8;
    else
      v9 = 0.0;
  }
  else
  {
    v9 = -1.0;
  }
  v10 = *(float *)(a1 + 56);
  CA::OGL::Context::release_surface_async(v2, *(_QWORD *)(a1 + 48));
  return (*(uint64_t (**)(float))(*(_QWORD *)(a1 + 32) + 16))(v10 * v9);
}

uint64_t ___ZN2CA3OGL12MetalContext27tile_calculate_average_lumaEPNS0_7SurfaceEU13block_pointerFvfE_block_invoke(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  float32x4_t *v4;
  unint64_t v5;
  int32x4_t v6;
  int32x4_t v7;
  int32x4_t v8;
  int32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float v15;
  __n128 v16;

  v2 = *(unsigned int *)(a1 + 48);
  v3 = objc_msgSend(*(id *)(a1 + 32), "contents");
  if ((int)v2 < 8)
  {
    v6 = 0uLL;
    v7 = 0uLL;
    v8 = 0uLL;
    v9 = 0uLL;
  }
  else
  {
    v4 = (float32x4_t *)(v3 + *(unsigned int *)(a1 + 52));
    v5 = v2 >> 3;
    v6 = 0uLL;
    v7 = 0uLL;
    v8 = 0uLL;
    v9 = 0uLL;
    do
    {
      v11 = v4[2];
      v10 = v4[3];
      v12 = *v4;
      v13 = v4[1];
      v4 += 4;
      v7 = (int32x4_t)vaddq_f32(v13, (float32x4_t)v7);
      v6 = (int32x4_t)vaddq_f32(v12, (float32x4_t)v6);
      v8 = (int32x4_t)vaddq_f32(v11, (float32x4_t)v8);
      v9 = (int32x4_t)vaddq_f32(v10, (float32x4_t)v9);
      --v5;
    }
    while (v5);
  }
  v14 = vaddq_f32((float32x4_t)vrev64q_s32(vuzp2q_s32(v8, v9)), (float32x4_t)vrev64q_s32(vuzp2q_s32(v6, v7)));
  v16 = (__n128)vpaddq_f32(v14, v14);
  v15 = vaddv_f32((float32x2_t)v16.n128_u64[0]);
  v16.n128_u32[0] = -1.0;
  if (v15 > 0.0)
    v16.n128_f32[0] = (float)(*(float *)(a1 + 56)
                            * (float)((float)((float)((float)(*(float *)v6.i32 + *(float *)&v6.i32[2])
                                                    + (float)(*(float *)&v7.i32[2] + *(float *)v7.i32))
                                            + (float)((float)(*(float *)&v8.i32[2] + *(float *)v8.i32)
                                                    + *(float *)&v9.i32[2]))
                                    + *(float *)v9.i32))
                    / v15;
  return (*(uint64_t (**)(__n128))(*(_QWORD *)(a1 + 40) + 16))(v16);
}

const char *CA::OGL::MetalContext::metal_pixel_format_name(CA::OGL::MetalContext *this, MTLPixelFormat a2)
{
  const char *Name;
  uint64_t v3;

  Name = (const char *)MTLPixelFormatGetName();
  if (!strncmp(Name, "MTLPixelFormat", 0xEuLL))
    v3 = 14;
  else
    v3 = 0;
  return &Name[v3];
}

uint64_t CA::OGL::srgb_pixel_format(uint64_t this, MTLPixelFormat a2)
{
  if (this <= 79)
  {
    switch(this)
    {
      case 10:
        return 11;
      case 30:
        return 31;
      case 70:
        return 71;
    }
  }
  else if (this > 551)
  {
    if (this == 552)
    {
      return 553;
    }
    else if (this == 554)
    {
      return 555;
    }
  }
  else if (this == 80)
  {
    return 81;
  }
  else if (this == 550)
  {
    return 551;
  }
  return this;
}

uint64_t CA::OGL::overdrive_texture_data(CA::OGL *this, uint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  const uint8_t *v8;
  size_t v9;
  uint8_t *v10;
  NSObject *v12;
  uint8_t buf[4];
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = (void *)objc_msgSend(MEMORY[0x1E0CB34D0], "bundleForClass:", objc_opt_class());
  v5 = (void *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("odt_%d_%d"), this, a2);
  v6 = objc_msgSend(v4, "pathForResource:ofType:", v5, CFSTR("dat"));
  if (v6)
  {
    v7 = (void *)objc_msgSend(MEMORY[0x1E0C99D50], "dataWithContentsOfFile:options:error:", v6, 1, 0);
    v8 = (const uint8_t *)objc_msgSend(v7, "bytes");
    v9 = objc_msgSend(v7, "length");
    v10 = (uint8_t *)malloc_type_malloc(0x140034uLL, 0x779E88A6uLL);
    if (compression_decode_buffer(v10, 0x140034uLL, v8, v9, 0, COMPRESSION_LZFSE) == 1310772)
      return objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytesNoCopy:length:", v10, 1310772);
    free(v10);
  }
  else if (x_log_hook_p())
  {
    objc_msgSend(v5, "UTF8String");
    x_log_();
  }
  else
  {
    v12 = x_log_category_ogl_metal;
    if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      v14 = objc_msgSend(v5, "UTF8String");
      _os_log_impl(&dword_184457000, v12, OS_LOG_TYPE_ERROR, "LUT file \"%s.dat\" not found!\n", buf, 0xCu);
    }
  }
  return 0;
}

void ___ZN2CA3OGL12MetalContext5flushEb_block_invoke(uint64_t a1, void *a2)
{
  NSObject *v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  double v10;
  uint64_t v11;
  uint64_t v12;
  double v13;
  _DWORD v14[2];
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v4 = CA::OGL::MetalContext::_perf_log;
  if (os_signpost_enabled((os_log_t)CA::OGL::MetalContext::_perf_log))
  {
    v5 = *(_QWORD *)(a1 + 40);
    v6 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v7 = *(_DWORD *)(a1 + 56);
    v8 = *(_DWORD *)(a1 + 60);
    v9 = *(_QWORD *)(a1 + 48);
    objc_msgSend(a2, "kernelStartTime");
    v11 = CAHostTimeWithTime(v10) + v9;
    v12 = *(_QWORD *)(a1 + 48);
    objc_msgSend(a2, "kernelEndTime");
    v14[0] = 67241472;
    v14[1] = v6;
    v15 = 1026;
    v16 = v7;
    v17 = 1026;
    v18 = v8;
    v19 = 2050;
    v20 = v5;
    v21 = 2050;
    v22 = v11;
    v23 = 2050;
    v24 = CAHostTimeWithTime(v13) + v12;
    _os_signpost_emit_with_name_impl(&dword_184457000, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Scheduling", "context=%{public,name=context}u update=0x%{public,name=update}x cmdbuf=%{public,name=cmdbuf}u thread=%{public,name=thread}llx begin=%{public,signpost.description:begin_time}llu end=%{public,signpost.description:end_time}llu", (uint8_t *)v14, 0x32u);
  }
}

void ___ZN2CA3OGL12MetalContext5flushEb_block_invoke_67(uint64_t a1, void *a2)
{
  uint64_t v4;
  uint64_t v5;
  double v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  _BYTE v25[34];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 40);
  objc_msgSend(a2, "GPUEndTime");
  v7 = CAHostTimeWithTime(v6) + v4;
  v8 = CA::OGL::MetalContext::_perf_log;
  if (os_signpost_enabled((os_log_t)CA::OGL::MetalContext::_perf_log))
  {
    v9 = *(_DWORD *)(v5 + 8);
    v10 = *(_DWORD *)(a1 + 64);
    v11 = *(_DWORD *)(a1 + 68);
    v12 = *(_QWORD *)(a1 + 40);
    v13 = *(_QWORD *)(a1 + 48);
    objc_msgSend(a2, "GPUStartTime");
    v20 = 67241472;
    v21 = v9;
    v22 = 1026;
    v23 = v10;
    v24 = 1026;
    *(_DWORD *)v25 = v11;
    *(_WORD *)&v25[4] = 2050;
    *(_QWORD *)&v25[6] = v13;
    *(_WORD *)&v25[14] = 2050;
    *(_QWORD *)&v25[16] = CAHostTimeWithTime(v14) + v12;
    *(_WORD *)&v25[24] = 2050;
    *(_QWORD *)&v25[26] = v7;
    _os_signpost_emit_with_name_impl(&dword_184457000, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Executing", "context=%{public,name=context}u update=0x%{public,name=update}x cmdbuf=%{public,name=cmdbuf}u thread=%{public,name=thread}llx begin=%{public,signpost.description:begin_time}llu end=%{public,signpost.description:end_time}llu", (uint8_t *)&v20, 0x32u);
  }
  v15 = *(_QWORD *)(a1 + 56);
  if (v15)
  {
    v16 = CA::OGL::MetalContext::_perf_log;
    if (os_signpost_enabled((os_log_t)CA::OGL::MetalContext::_perf_log))
    {
      v17 = *(_DWORD *)(v5 + 8);
      v18 = *(_DWORD *)(a1 + 64);
      v19 = *(_QWORD *)(a1 + 48);
      v20 = 67241216;
      v21 = v17;
      v22 = 1026;
      v23 = v18;
      v24 = 2050;
      *(_QWORD *)v25 = v19;
      *(_WORD *)&v25[8] = 2050;
      *(_QWORD *)&v25[10] = v15;
      *(_WORD *)&v25[18] = 2050;
      *(_QWORD *)&v25[20] = v7;
      _os_signpost_emit_with_name_impl(&dword_184457000, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "RenderToCompletion", "context=%{public,name=context}u update=0x%{public,name=update}x thread=%{public,name=thread}llx begin=%{public,signpost.description:begin_time}llu end=%{public,signpost.description:end_time}llu", (uint8_t *)&v20, 0x2Cu);
    }
  }
}

double ___ZN2CA3OGL12MetalContext5flushEb_block_invoke_69(uint64_t a1, void *a2)
{
  uint64_t v3;
  double v4;
  double v5;
  double v6;
  double result;

  v3 = *(_QWORD *)(a1 + 32);
  objc_msgSend(a2, "GPUEndTime");
  v5 = v4;
  objc_msgSend(a2, "GPUStartTime");
  result = v5 - v6;
  *(double *)(v3 + 4032) = result;
  return result;
}

uint64_t ___ZN2CA3OGL12MetalContext5flushEb_block_invoke_2(uint64_t a1)
{
  uint64_t result;

  result = objc_msgSend(*(id *)(a1 + 32), "commitAndWaitUntilSubmitted");
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = result;
  return result;
}

uint64_t ___ZN2CA3OGL12MetalContext24copy_submitted_callbacksEPU27objcproto16MTLCommandBuffer11objc_object_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void std::deque<objc_object  {objcproto9MTLBuffer}*>::__maybe_remove_front_spare[abi:nn180100](uint64_t a1)
{
  if (*(_QWORD *)(a1 + 32) >= 0x400uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(_QWORD *)(a1 + 8) += 8;
    *(_QWORD *)(a1 + 32) -= 512;
  }
}

uint64_t *std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 != v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v18 = v7[1];
      *(_QWORD *)v12 = v18;
      if (v18)
        *(_QWORD *)(v18 + 16) = v12;
      v7[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
      v7[1] = v12;
      *(_QWORD *)(v12 + 16) = v7;
      if (result == (uint64_t *)v12)
        result = v7;
      v7 = *(uint64_t **)v12;
    }
    v19 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v19 + 24))
      goto LABEL_68;
    v20 = (uint64_t *)v7[1];
    if (v20 && !*((_BYTE *)v20 + 24))
    {
      if (v19 && !*((_BYTE *)v19 + 24))
      {
LABEL_68:
        v20 = v7;
      }
      else
      {
        *((_BYTE *)v20 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v26 = *v20;
        v7[1] = *v20;
        if (v26)
          *(_QWORD *)(v26 + 16) = v7;
        v20[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
        *v20 = (uint64_t)v7;
        v7[2] = (uint64_t)v20;
        v19 = v7;
      }
      v23 = v20[2];
      *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v19 + 24) = 1;
      v24 = *(uint64_t **)v23;
      v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
      *(_QWORD *)v23 = v27;
      if (v27)
        *(_QWORD *)(v27 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      v24[1] = v23;
      goto LABEL_72;
    }
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v13 = *(uint64_t **)(v12 + 8);
    v14 = *v13;
    *(_QWORD *)(v12 + 8) = *v13;
    if (v14)
      *(_QWORD *)(v14 + 16) = v12;
    v13[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
    *v13 = v12;
    *(_QWORD *)(v12 + 16) = v13;
    if (result == (uint64_t *)*v7)
      result = v7;
    v7 = *(uint64_t **)(*v7 + 8);
  }
  v15 = (_QWORD *)*v7;
  if (!*v7 || *((_BYTE *)v15 + 24))
  {
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_59;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
    goto LABEL_49;
  }
  v16 = (uint64_t *)v7[1];
  if (v16 && !*((_BYTE *)v16 + 24))
  {
LABEL_59:
    v15 = v7;
  }
  else
  {
    *((_BYTE *)v15 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v22 = v15[1];
    *v7 = v22;
    if (v22)
      *(_QWORD *)(v22 + 16) = v7;
    v15[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
    v15[1] = v7;
    v7[2] = (uint64_t)v15;
    v16 = v7;
  }
  v23 = v15[2];
  *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v16 + 24) = 1;
  v24 = *(uint64_t **)(v23 + 8);
  v25 = *v24;
  *(_QWORD *)(v23 + 8) = *v24;
  if (v25)
    *(_QWORD *)(v25 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  *v24 = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

void std::__function::__func<CA::OGL::MetalContext::draw(MTLPrimitiveType,unsigned int,unsigned int,void const*,unsigned long,unsigned long,unsigned int,unsigned int,unsigned short const*,CA::OGL::ClipPlane const*,CA::OGL::MetalBufferPool::MetalBuffer const*)::$_0,std::allocator<CA::OGL::MetalContext::draw(MTLPrimitiveType,unsigned int,unsigned int,void const*,unsigned long,unsigned long,unsigned int,unsigned int,unsigned short const*,CA::OGL::ClipPlane const*,CA::OGL::MetalBufferPool::MetalBuffer const*)::$_0>,BOOL ()(CA::OGL::Vertex *,unsigned int)>::~__func()
{
  JUMPOUT(0x186DBD990);
}

_QWORD *std::__function::__func<CA::OGL::MetalContext::draw(MTLPrimitiveType,unsigned int,unsigned int,void const*,unsigned long,unsigned long,unsigned int,unsigned int,unsigned short const*,CA::OGL::ClipPlane const*,CA::OGL::MetalBufferPool::MetalBuffer const*)::$_0,std::allocator<CA::OGL::MetalContext::draw(MTLPrimitiveType,unsigned int,unsigned int,void const*,unsigned long,unsigned long,unsigned int,unsigned int,unsigned short const*,CA::OGL::ClipPlane const*,CA::OGL::MetalBufferPool::MetalBuffer const*)::$_0>,BOOL ()(CA::OGL::Vertex *,unsigned int)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E159A320;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CA::OGL::MetalContext::draw(MTLPrimitiveType,unsigned int,unsigned int,void const*,unsigned long,unsigned long,unsigned int,unsigned int,unsigned short const*,CA::OGL::ClipPlane const*,CA::OGL::MetalBufferPool::MetalBuffer const*)::$_0,std::allocator<CA::OGL::MetalContext::draw(MTLPrimitiveType,unsigned int,unsigned int,void const*,unsigned long,unsigned long,unsigned int,unsigned int,unsigned short const*,CA::OGL::ClipPlane const*,CA::OGL::MetalBufferPool::MetalBuffer const*)::$_0>,BOOL ()(CA::OGL::Vertex *,unsigned int)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E159A320;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<CA::OGL::MetalContext::draw(MTLPrimitiveType,unsigned int,unsigned int,void const*,unsigned long,unsigned long,unsigned int,unsigned int,unsigned short const*,CA::OGL::ClipPlane const*,CA::OGL::MetalBufferPool::MetalBuffer const*)::$_0,std::allocator<CA::OGL::MetalContext::draw(MTLPrimitiveType,unsigned int,unsigned int,void const*,unsigned long,unsigned long,unsigned int,unsigned int,unsigned short const*,CA::OGL::ClipPlane const*,CA::OGL::MetalBufferPool::MetalBuffer const*)::$_0>,BOOL ()(CA::OGL::Vertex *,unsigned int)>::operator()(uint64_t a1, const void **a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *a3;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = CA::OGL::MetalBufferPool::encode_vertex_arg(*(CA::OGL::MetalBufferPool **)(v4 + 3992), 1, *a2, 48 * (int)v3, 0x10u);
  if ((_DWORD)v5)
    (*(void (**)(_QWORD, char *, uint64_t, _QWORD, uint64_t, uint64_t))(v4 + 2992))(*(_QWORD *)(v4 + 2936), sel_drawPrimitives_vertexStart_vertexCount_instanceCount_, 3, 0, v3, 1);
  return v5;
}

uint64_t CA::OGL::MetalContext::encode_noise_texture(CA::OGL::MetalContext *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const unsigned __int8 *a6, BOOL a7, const char *a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;

  if (!*((_QWORD *)this + 479))
  {
    v9 = *((_QWORD *)this + 351);
    if (v9)
    {
      v10 = 0;
    }
    else
    {
      result = CA::OGL::MetalContext::create_texture((id *)this, 80, 1uLL, (MTLPixelFormat)&noise_data, (uint64_t)"noise", a6, a7, a8);
      *((_QWORD *)this + 351) = result;
      if (!result)
        return result;
      *(_WORD *)(result + 123) &= ~8u;
      *(_DWORD *)(*((_QWORD *)this + 351) + 52) &= 0xFF0FFFFF;
      *(_DWORD *)(*((_QWORD *)this + 351) + 52) &= 0xFFF0FFFF;
      v9 = *((_QWORD *)this + 351);
      v10 = *((_QWORD *)this + 479);
    }
    v12 = *(_QWORD *)(v9 + 64);
    if (v10 != v12)
    {
      *((_QWORD *)this + 479) = v12;
      (*((void (**)(_QWORD, char *))this + 371))(*((_QWORD *)this + 367), sel_setFragmentTexture_atIndex_);
    }
  }
  return 1;
}

uint64_t CA::OGL::MetalContext::encode_noise_scale(CA::OGL::MetalContext *this, const CA::OGL::MetalContext::FragmentShader::Spec *a2)
{
  int v3;
  float v4;
  uint64_t result;
  __int16 __src;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = *(_DWORD *)(*((_QWORD *)this + 31) + 120);
  if (v3 > 93)
  {
    if ((v3 - 550) < 6)
    {
      v4 = 0.0039216;
      goto LABEL_14;
    }
    if (v3 != 94)
    {
      if (v3 == 115)
      {
        v4 = 0.00012207;
        goto LABEL_14;
      }
      goto LABEL_13;
    }
LABEL_12:
    v4 = 0.001955;
    goto LABEL_14;
  }
  if (v3 == 41 || v3 == 43)
  {
    v4 = 0.064516;
    goto LABEL_14;
  }
  if (v3 == 90)
    goto LABEL_12;
LABEL_13:
  v4 = 0.0078431;
LABEL_14:
  _S8 = *(float *)(*((_QWORD *)this + 2) + 352) * v4;
  if (*((float *)this + 841) == _S8)
    return 1;
  __asm { FCVT            H0, S8 }
  __src = _H0;
  result = CA::OGL::MetalBufferPool::encode_fragment_arg(*((CA::OGL::MetalBufferPool **)this + 499), 5, &__src, 2u, 2u);
  if ((_DWORD)result)
    *((float *)this + 841) = _S8;
  return result;
}

uint64_t CA::OGL::MetalContext::encode_edr_resolve(CA::OGL::MetalContext *this, const CA::OGL::MetalContext::FragmentShader::Spec *a2)
{
  uint64_t v3;
  float v4;
  uint64_t result;
  __int16 __src;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = *((_QWORD *)this + 2);
  v4 = 1.0;
  if ((*(_BYTE *)(v3 + 305) & 1) != 0)
    v4 = *(float *)(v3 + 312);
  _S8 = powf(*(float *)(*((_QWORD *)this + 31) + 64) * v4, 1.0 / *((float *)this + 38));
  if (*((float *)this + 842) == _S8)
    return 1;
  __asm { FCVT            H0, S8 }
  __src = _H0;
  result = CA::OGL::MetalBufferPool::encode_fragment_arg(*((CA::OGL::MetalBufferPool **)this + 499), 6, &__src, 2u, 2u);
  if ((_DWORD)result)
    *((float *)this + 842) = _S8;
  return result;
}

uint64_t CA::OGL::MetalContext::encode_gamma_luts(CA::OGL::MetalContext *this)
{
  char v1;
  uint64_t v3;
  uint64_t result;

  v1 = *((_BYTE *)this + 3360);
  if ((v1 & 4) == 0)
  {
    v3 = *((_QWORD *)this + 500);
    if (!v3)
    {
      result = (uint64_t)CA::OGL::create_gamma_lut_buffer(*((void **)this + 363));
      *((_QWORD *)this + 500) = result;
      if (!result)
        return result;
      v3 = result;
      v1 = *((_BYTE *)this + 3360);
    }
    *((_BYTE *)this + 3360) = v1 | 4;
    objc_msgSend(*((id *)this + 367), "setFragmentBuffer:offset:atIndex:", v3, 0, 7);
  }
  return 1;
}

void CA::OGL::MetalContext::Pipeline::wait_for_completion(CA::OGL::MetalContext::Pipeline *this)
{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    dispatch_block_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
    _Block_release(*((const void **)this + 1));
    *((_QWORD *)this + 1) = 0;
  }
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_0::__invoke(uint64_t a1, char a2)
{
  uint64_t result;
  __int16 v3;

  *(_DWORD *)a1 = *(_DWORD *)a1 & 0xFFFFFFC0 | a2 & 0x3F;
  v3 = *(_WORD *)(a1 + 4);
  result = a1 + 4;
  *(_BYTE *)(result + 2) = *(_BYTE *)(result + 2);
  *(_WORD *)result = v3;
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_1::__invoke(uint64_t result, char a2)
{
  __int16 v2;
  unsigned int v3;

  v2 = *(_WORD *)(result + 4);
  v3 = *(_DWORD *)result & 0xFFFFFE3F;
  *(_BYTE *)(result + 6) = *(_BYTE *)(result + 6);
  *(_WORD *)(result + 4) = v2;
  *(_DWORD *)result = v3 | ((a2 & 7) << 6);
  return result;
}

uint64_t CA::OGL::MetalContext::get_TextureFilter_decoder(CA::OGL::MetalContext *this)
{
  if (CA::OGL::MetalContext::get_TextureFilter_decoder(void)::once[0] != -1)
    dispatch_once(CA::OGL::MetalContext::get_TextureFilter_decoder(void)::once, &__block_literal_global_2002);
  return CA::OGL::MetalContext::get_TextureFilter_decoder(void)::decoder;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_2::__invoke(uint64_t result, char a2)
{
  __int16 v2;
  unsigned int v3;

  v2 = *(_WORD *)(result + 4);
  v3 = *(_DWORD *)result & 0xFFFFE1FF;
  *(_BYTE *)(result + 6) = *(_BYTE *)(result + 6);
  *(_WORD *)(result + 4) = v2;
  *(_DWORD *)result = v3 | ((a2 & 0xF) << 9);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_3::__invoke(uint64_t result, char a2)
{
  __int16 v2;
  unsigned int v3;

  v2 = *(_WORD *)(result + 4);
  v3 = *(_DWORD *)result & 0xFFFF1FFF;
  *(_BYTE *)(result + 6) = *(_BYTE *)(result + 6);
  *(_WORD *)(result + 4) = v2;
  *(_DWORD *)result = v3 | ((a2 & 7) << 13);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_4::__invoke(uint64_t result, char a2)
{
  __int16 v2;
  unsigned int v3;

  v2 = *(_WORD *)(result + 4);
  v3 = *(_DWORD *)result & 0xFFF8FFFF;
  *(_BYTE *)(result + 6) = *(_BYTE *)(result + 6);
  *(_WORD *)(result + 4) = v2;
  *(_DWORD *)result = v3 | ((a2 & 7) << 16);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_5::__invoke(uint64_t result, char a2)
{
  __int16 v2;
  unsigned int v3;

  v2 = *(_WORD *)(result + 4);
  v3 = *(_DWORD *)result & 0xFF07FFFF;
  *(_BYTE *)(result + 6) = *(_BYTE *)(result + 6);
  *(_WORD *)(result + 4) = v2;
  *(_DWORD *)result = v3 | ((a2 & 0x1F) << 19);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_6::__invoke(uint64_t result, char a2)
{
  __int16 v2;
  unsigned int v3;

  v2 = *(_WORD *)(result + 4);
  v3 = *(_DWORD *)result & 0xE0FFFFFF;
  *(_BYTE *)(result + 6) = *(_BYTE *)(result + 6);
  *(_WORD *)(result + 4) = v2;
  *(_DWORD *)result = v3 | ((a2 & 0x1F) << 24);
  return result;
}

unsigned int *CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_7::__invoke(unsigned int *result, char a2)
{
  int v2;
  unint64_t v3;

  v2 = *((unsigned __int8 *)result + 6);
  v3 = (*result | ((unint64_t)(*((unsigned __int16 *)result + 2) | (v2 << 16)) << 32)) & 0xFFFFFFFC1FFFFFFFLL | ((unint64_t)(a2 & 0x1F) << 29);
  *((_BYTE *)result + 6) = v2;
  *result = v3;
  *((_WORD *)result + 2) = WORD2(v3);
  return result;
}

unsigned int *CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_8::__invoke(unsigned int *result, char a2)
{
  int v2;
  unint64_t v3;

  v2 = *((unsigned __int8 *)result + 6);
  v3 = (*result | ((unint64_t)(*((unsigned __int16 *)result + 2) | (v2 << 16)) << 32)) & 0xFFFFFF83FFFFFFFFLL;
  *((_BYTE *)result + 6) = v2;
  *result = v3;
  *((_WORD *)result + 2) = (v3 | ((unint64_t)(a2 & 0x1F) << 34)) >> 32;
  return result;
}

unsigned int *CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_9::__invoke(unsigned int *result, char a2)
{
  int v2;
  unint64_t v3;

  v2 = *((unsigned __int8 *)result + 6);
  v3 = (*result | ((unint64_t)(*((unsigned __int16 *)result + 2) | (v2 << 16)) << 32)) & 0xFFFFF07FFFFFFFFFLL;
  *((_BYTE *)result + 6) = v2;
  *result = v3;
  *((_WORD *)result + 2) = (v3 | ((unint64_t)(a2 & 0x1F) << 39)) >> 32;
  return result;
}

unsigned int *CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_10::__invoke(unsigned int *result, char a2)
{
  unint64_t v2;

  v2 = (*result | ((unint64_t)(*((unsigned __int16 *)result + 2) | (*((unsigned __int8 *)result + 6) << 16)) << 32)) & 0xFFFE0FFFFFFFFFFFLL | ((unint64_t)(a2 & 0x1F) << 44);
  *result = *result;
  *((_WORD *)result + 2) = WORD2(v2);
  *((_BYTE *)result + 6) = BYTE6(v2);
  return result;
}

unsigned int *CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_11::__invoke(unsigned int *result, int a2)
{
  unint64_t v2;

  v2 = (*result | ((unint64_t)(*((unsigned __int16 *)result + 2) | (*((unsigned __int8 *)result + 6) << 16)) << 32)) & 0xFFFDFFFFFFFFFFFFLL;
  *((_WORD *)result + 2) = *((_WORD *)result + 2);
  *result = v2;
  *((_BYTE *)result + 6) = (v2 | ((unint64_t)(a2 != 0) << 49)) >> 48;
  return result;
}

uint64_t CA::OGL::MetalContext::get_DestinationFunction_decoder(CA::OGL::MetalContext *this)
{
  if (CA::OGL::MetalContext::get_DestinationFunction_decoder(void)::once[0] != -1)
    dispatch_once(CA::OGL::MetalContext::get_DestinationFunction_decoder(void)::once, &__block_literal_global_1807);
  return CA::OGL::MetalContext::get_DestinationFunction_decoder(void)::decoder;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_6::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xFFFB | (4 * (a2 != 0));
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_11::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xFF7F | ((a2 != 0) << 7);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_12::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xFEFF | ((a2 != 0) << 8);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_13::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xFDFF | ((a2 != 0) << 9);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_14::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xFBFF | ((a2 != 0) << 10);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_16::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xEFFF | ((a2 != 0) << 12);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_17::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xDFFF | ((a2 != 0) << 13);
  return result;
}

_WORD *CA::OGL::MetalContext::Pipeline::Spec::decode_segment(char const**)::$_0::__invoke(uint64_t a1, __int16 a2)
{
  _WORD *result;
  __int16 v3;

  v3 = *(_WORD *)(a1 + 24);
  result = (_WORD *)(a1 + 24);
  *result = v3 & 0xFC00 | a2 & 0x3FF;
  return result;
}

uint64_t CA::OGL::MetalContext::Pipeline::Spec::decode_segment(char const**)::$_1::__invoke(uint64_t a1, __int16 a2)
{
  uint64_t result;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a1 + 24);
  result = a1 + 24;
  v4 = v3 & 0xFFFF03FF | (*(unsigned __int8 *)(result + 2) << 16);
  *(_WORD *)result = v3 & 0x3FF | (a2 << 10);
  *(_BYTE *)(result + 2) = BYTE2(v4);
  return result;
}

uint64_t CA::OGL::MetalContext::Pipeline::Spec::decode_segment(char const**)::$_2::__invoke(uint64_t result, int a2)
{
  *(_BYTE *)(result + 23) = *(_BYTE *)(result + 23) & 0xFE | (a2 != 0);
  return result;
}

uint64_t CA::OGL::MetalContext::Pipeline::Spec::decode_segment(char const**)::$_3::__invoke(uint64_t a1, int a2)
{
  uint64_t result;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a1 + 24);
  result = a1 + 24;
  v4 = (v3 | (*(unsigned __int8 *)(result + 2) << 16)) & 0xFFFEFFFF;
  *(_WORD *)result = v3;
  *(_BYTE *)(result + 2) = (v4 | ((a2 != 0) << 16)) >> 16;
  return result;
}

uint64_t CA::OGL::MetalContext::Pipeline::Spec::decode_segment(char const**)::$_4::__invoke(uint64_t a1, int a2)
{
  uint64_t result;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a1 + 24);
  result = a1 + 24;
  v4 = (v3 | (*(unsigned __int8 *)(result + 2) << 16)) & 0xFFFDFFFF;
  *(_WORD *)result = v3;
  *(_BYTE *)(result + 2) = (v4 | ((a2 != 0) << 17)) >> 16;
  return result;
}

uint64_t CA::OGL::MetalContext::purge_shaders(CA::OGL::MetalContext *this)
{
  uint64_t i;
  _QWORD *j;
  id *v4;
  malloc_zone_t *malloc_zone;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t k;
  _QWORD *m;
  id *v11;
  malloc_zone_t *v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t n;

  if (*((_QWORD *)this + 336))
  {
    for (i = 0; i != 2048; i += 8)

    free(*((void **)this + 336));
    *((_QWORD *)this + 336) = 0;
  }
  CA::OGL::MetalContext::stop_pipeline_queue(this);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1888));
  for (j = (_QWORD *)*((_QWORD *)this + 233); j; j = (_QWORD *)*j)
  {
    v4 = (id *)j[5];
    if (v4)
    {

      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v4);
    }
  }
  if (*((_QWORD *)this + 234))
  {
    v6 = (_QWORD *)*((_QWORD *)this + 233);
    if (v6)
    {
      do
      {
        v7 = (_QWORD *)*v6;
        operator delete(v6);
        v6 = v7;
      }
      while (v7);
    }
    *((_QWORD *)this + 233) = 0;
    v8 = *((_QWORD *)this + 232);
    if (v8)
    {
      for (k = 0; k != v8; ++k)
        *(_QWORD *)(*((_QWORD *)this + 231) + 8 * k) = 0;
    }
    *((_QWORD *)this + 234) = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 1888));
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1992));
  for (m = (_QWORD *)*((_QWORD *)this + 246); m; m = (_QWORD *)*m)
  {
    v11 = (id *)m[3];
    if (v11)
    {

      v12 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v12, v11);
    }
  }
  if (*((_QWORD *)this + 247))
  {
    v13 = (_QWORD *)*((_QWORD *)this + 246);
    if (v13)
    {
      do
      {
        v14 = (_QWORD *)*v13;
        operator delete(v13);
        v13 = v14;
      }
      while (v14);
    }
    *((_QWORD *)this + 246) = 0;
    v15 = *((_QWORD *)this + 245);
    if (v15)
    {
      for (n = 0; n != v15; ++n)
        *(_QWORD *)(*((_QWORD *)this + 244) + 8 * n) = 0;
    }
    *((_QWORD *)this + 247) = 0;
  }
  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 1992));
}

void CA::OGL::MetalContext::stop_pipeline_queue(CA::OGL::MetalContext *this)
{
  unsigned __int8 *v2;
  _QWORD *i;
  unint64_t *v4;
  void *v5;
  const void *v6;
  malloc_zone_t *malloc_zone;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t j;

  v2 = (unsigned __int8 *)this + 2104;
  atomic_store(1u, (unsigned __int8 *)this + 2104);
  dispatch_barrier_sync(*((dispatch_queue_t *)this + 262), &__block_literal_global_64_6757);
  atomic_store(0, v2);
  for (i = (_QWORD *)*((_QWORD *)this + 259); i; i = (_QWORD *)*i)
  {
    v4 = (unint64_t *)i[6];
    if (v4)
    {
      v5 = (void *)atomic_load(v4);

      v6 = (const void *)v4[1];
      if (v6)
        _Block_release(v6);
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v4);
    }
  }
  if (*((_QWORD *)this + 260))
  {
    v8 = (_QWORD *)*((_QWORD *)this + 259);
    if (v8)
    {
      do
      {
        v9 = (_QWORD *)*v8;
        operator delete(v8);
        v8 = v9;
      }
      while (v9);
    }
    *((_QWORD *)this + 259) = 0;
    v10 = *((_QWORD *)this + 258);
    if (v10)
    {
      for (j = 0; j != v10; ++j)
        *(_QWORD *)(*((_QWORD *)this + 257) + 8 * j) = 0;
    }
    *((_QWORD *)this + 260) = 0;
  }
}

void ___ZN2CA3OGL12MetalContext14warmup_shadersEb_block_invoke(uint64_t a1)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)(*(_QWORD *)(a1 + 32) + 2104));
  if ((v1 & 1) == 0 && CA::CAHDRProcessor::warmup_shaders(void)::once[0] != -1)
    dispatch_once_f(CA::CAHDRProcessor::warmup_shaders(void)::once, 0, (dispatch_function_t)CA::prewarm_hdrprocessor_metal);
}

void ___ZN2CA3OGL12MetalContext14warmup_shadersEb_block_invoke_2(uint64_t a1)
{
  os_signpost_id_t v2;
  uint64_t v3;
  NSObject *v4;
  unsigned __int8 v5;
  uint64_t v6;
  double v7;
  const char *v8;
  const char *v9;
  const char *v10;
  const char *v11;
  const char *v12;
  const char *v13;
  NSObject *v14;
  double v15;
  const char *Name;
  uint64_t v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  const char *v22;
  uint64_t v23;
  const char *v24;
  const char *v25;
  uint64_t v26;
  const char *v27;
  const char *v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  uint64_t v32;
  const char *v33;
  uint8_t buf[4];
  double v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  const char *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 40);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = x_log_category_ogl_metal;
    if (os_signpost_enabled((os_log_t)x_log_category_ogl_metal))
    {
      v5 = atomic_load((unsigned __int8 *)(v3 + 2104));
      *(_DWORD *)buf = 67240192;
      LODWORD(v35) = v5 & 1;
      _os_signpost_emit_with_name_impl(&dword_184457000, v4, OS_SIGNPOST_INTERVAL_END, v2, "WarmupShaders", "cancelled=%{public, name=cancelled}u", buf, 8u);
    }
  }
  v6 = mach_absolute_time();
  v7 = CATimeWithHostTime(v6);
  if (!x_log_hook_p())
  {
    v14 = x_log_category_ogl_metal;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_INFO))
      return;
    v15 = v7 - *(double *)(a1 + 48);
    if (*(int *)(a1 + 112) < 1)
    {
      v30 = "N/A";
      v24 = "N/A";
      v18 = "N/A";
    }
    else
    {
      Name = (const char *)MTLPixelFormatGetName();
      if (!strncmp(Name, "MTLPixelFormat", 0xEuLL))
        v17 = 14;
      else
        v17 = 0;
      v18 = &Name[v17];
      if (*(int *)(a1 + 112) >= 2)
      {
        v19 = (const char *)MTLPixelFormatGetName();
        if (!strncmp(v19, "MTLPixelFormat", 0xEuLL))
          v20 = 14;
        else
          v20 = 0;
        v21 = &v19[v20];
        if (*(int *)(a1 + 112) < 3)
        {
          v30 = "N/A";
          v24 = "N/A";
        }
        else
        {
          v22 = (const char *)MTLPixelFormatGetName();
          if (!strncmp(v22, "MTLPixelFormat", 0xEuLL))
            v23 = 14;
          else
            v23 = 0;
          v24 = &v22[v23];
          if (*(int *)(a1 + 112) >= 4)
          {
            v25 = (const char *)MTLPixelFormatGetName();
            if (!strncmp(v25, "MTLPixelFormat", 0xEuLL))
              v26 = 14;
            else
              v26 = 0;
            v27 = &v25[v26];
            if (*(int *)(a1 + 112) >= 5)
            {
              v28 = (const char *)MTLPixelFormatGetName();
              if (!strncmp(v28, "MTLPixelFormat", 0xEuLL))
                v29 = 14;
              else
                v29 = 0;
              v30 = &v28[v29];
              if (*(int *)(a1 + 112) < 6)
              {
                v33 = "N/A";
              }
              else
              {
                v31 = (const char *)MTLPixelFormatGetName();
                if (!strncmp(v31, "MTLPixelFormat", 0xEuLL))
                  v32 = 14;
                else
                  v32 = 0;
                v33 = &v31[v32];
              }
              goto LABEL_45;
            }
            v30 = "N/A";
LABEL_44:
            v33 = "N/A";
LABEL_45:
            *(_DWORD *)buf = 134219522;
            v35 = v15;
            v36 = 2080;
            v37 = v18;
            v38 = 2080;
            v39 = v21;
            v40 = 2080;
            v41 = v24;
            v42 = 2080;
            v43 = v27;
            v44 = 2080;
            v45 = v30;
            v46 = 2080;
            v47 = v33;
            _os_log_impl(&dword_184457000, v14, OS_LOG_TYPE_INFO, "Render pipeline warmup took %0.2fs, MTLPixelFormats: {%s, %s, %s, %s, %s, %s}\n", buf, 0x48u);
            return;
          }
          v30 = "N/A";
        }
LABEL_43:
        v27 = "N/A";
        goto LABEL_44;
      }
      v30 = "N/A";
      v24 = "N/A";
    }
    v21 = "N/A";
    goto LABEL_43;
  }
  if (*(int *)(a1 + 112) >= 1)
  {
    v8 = (const char *)MTLPixelFormatGetName();
    strncmp(v8, "MTLPixelFormat", 0xEuLL);
    if (*(int *)(a1 + 112) >= 2)
    {
      v9 = (const char *)MTLPixelFormatGetName();
      strncmp(v9, "MTLPixelFormat", 0xEuLL);
      if (*(int *)(a1 + 112) >= 3)
      {
        v10 = (const char *)MTLPixelFormatGetName();
        strncmp(v10, "MTLPixelFormat", 0xEuLL);
        if (*(int *)(a1 + 112) >= 4)
        {
          v11 = (const char *)MTLPixelFormatGetName();
          strncmp(v11, "MTLPixelFormat", 0xEuLL);
          if (*(int *)(a1 + 112) >= 5)
          {
            v12 = (const char *)MTLPixelFormatGetName();
            strncmp(v12, "MTLPixelFormat", 0xEuLL);
            if (*(int *)(a1 + 112) >= 6)
            {
              v13 = (const char *)MTLPixelFormatGetName();
              strncmp(v13, "MTLPixelFormat", 0xEuLL);
            }
          }
        }
      }
    }
  }
  x_log_();
}

void CA::OGL::MetalContext::mark_cache_drop_hints(CA::OGL::MetalContext *this)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  size_t v6;
  char *v7;
  __int128 v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  char *Name;
  __int128 v22;
  uint8_t buf[4];
  uint64_t v24;
  __int16 v25;
  int v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 10);
  if (v2)
  {
    v3 = -1;
    v4 = *((_QWORD *)this + 10);
    do
    {
      v5 = v3;
      v4 = *(_QWORD *)(v4 + 8);
      ++v3;
    }
    while (v4);
    v6 = 8 * (v5 + 2);
    if (v3 > 0x1FF)
    {
      v7 = (char *)malloc_type_malloc(8 * (v5 + 2), 0x80040B8603338uLL);
      v2 = *((_QWORD *)this + 10);
      if (!v2)
        goto LABEL_29;
      goto LABEL_9;
    }
  }
  else
  {
    v6 = 0;
  }
  MEMORY[0x1E0C80A78](this);
  v7 = (char *)&v18 - ((v6 + 15) & 0xFFFFFFFF0);
  bzero(v7, v6);
  if (!v2)
    goto LABEL_29;
LABEL_9:
  v9 = 0;
  *(_QWORD *)&v8 = 134219010;
  v22 = v8;
  do
  {
    if (*(_QWORD *)(v2 + 144)
      || (v10 = objc_msgSend(*((id *)this + 363), "newResourceGroupFromResources:count:", v2 + 96, *(_BYTE *)(v2 + 72) & 1), (*(_QWORD *)(v2 + 144) = v10) != 0))
    {
      if (byte_1ECDC6AAB && (*(_BYTE *)(v2 + 72) & 1) != 0)
      {
        if (x_log_hook_p())
        {
          Name = (char *)MTLPixelFormatGetName();
          v12 = strncmp(Name, "MTLPixelFormat", 0xEuLL);
          v13 = 14;
          if (v12)
            v13 = 0;
          Name += v13;
          v20 = (const char *)objc_msgSend(*(id *)(v2 + 96), "width");
          objc_msgSend(*(id *)(v2 + 96), "height");
          x_log_();
        }
        else
        {
          Name = (char *)x_log_category_ogl_metal;
          if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEBUG))
          {
            v20 = (const char *)MTLPixelFormatGetName();
            v14 = strncmp(v20, "MTLPixelFormat", 0xEuLL);
            v15 = 14;
            if (v14)
              v15 = 0;
            v20 += v15;
            v19 = objc_msgSend(*(id *)(v2 + 96), "width");
            v16 = objc_msgSend(*(id *)(v2 + 96), "height");
            *(_DWORD *)buf = v22;
            v24 = v2;
            v25 = 1024;
            v26 = 0;
            v27 = 2080;
            v28 = v20;
            v29 = 1024;
            v30 = v19;
            v31 = 1024;
            v32 = v16;
            _os_log_impl(&dword_184457000, (os_log_t)Name, OS_LOG_TYPE_DEBUG, "> mark surface %p texture %d %s %dx%d\n", buf, 0x28u);
          }
        }
      }
      *(_QWORD *)&v7[8 * v9] = *(_QWORD *)(v2 + 144);
      v11 = *((_QWORD *)this + 366);
      ++v9;
    }
    else
    {
      v11 = 0;
    }
    *(_QWORD *)(v2 + 152) = v11;
    *(_WORD *)(v2 + 232) &= ~0x40u;
    v2 = *(_QWORD *)(v2 + 8);
  }
  while (v2);
  if (v9 > 0)
  {
    if (byte_1ECDC6AAB)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v17 = x_log_category_ogl_metal;
        if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 67109120;
          LODWORD(v24) = v9;
          _os_log_impl(&dword_184457000, v17, OS_LOG_TYPE_DEBUG, "marking %d surfaces for cache drop hints", buf, 8u);
        }
      }
    }
    objc_msgSend(*((id *)this + 366), "encodeCacheHintTag:resourceGroups:count:", 1, v7, v9);
  }
LABEL_29:
  if (v6 > 0x1000)
    free(v7);
}

const __CFString *CA::OGL::mtl_gpu_family_name(const __CFString *this, MTLGPUFamily a2)
{
  char *v2;

  if ((uint64_t)this > 2001)
  {
    if ((uint64_t)this <= 3001)
    {
      if (this == (const __CFString *)2002)
        return CFSTR("mac2");
      if (this == (const __CFString *)3001)
        return CFSTR("common1");
    }
    else
    {
      if (this == (const __CFString *)3002)
        return CFSTR("common2");
      if (this == (const __CFString *)3003)
        return CFSTR("common3");
      if (this == (const __CFString *)5001)
        return CFSTR("metal3");
    }
    return (const __CFString *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("unknown:%u"), this);
  }
  else
  {
    v2 = (char *)&this[-32].data + 7;
    this = CFSTR("apple1");
    switch((unint64_t)v2)
    {
      case 0uLL:
        return this;
      case 1uLL:
        this = CFSTR("apple2");
        break;
      case 2uLL:
        this = CFSTR("apple3");
        break;
      case 3uLL:
        this = CFSTR("apple4");
        break;
      case 4uLL:
        this = CFSTR("apple5");
        break;
      case 5uLL:
        this = CFSTR("apple6");
        break;
      case 6uLL:
        this = CFSTR("apple7");
        break;
      case 7uLL:
        this = CFSTR("apple8");
        break;
      case 8uLL:
        this = CFSTR("apple9");
        break;
      default:
        return (const __CFString *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("unknown:%u"), this);
    }
  }
  return this;
}

uint64_t CA::OGL::MetalContext::get_VertexShaderType_decoder(CA::OGL::MetalContext *this)
{
  if (CA::OGL::MetalContext::get_VertexShaderType_decoder(void)::once != -1)
    dispatch_once(&CA::OGL::MetalContext::get_VertexShaderType_decoder(void)::once, &__block_literal_global_2088);
  return CA::OGL::MetalContext::get_VertexShaderType_decoder(void)::decoder;
}

uint64_t CA::OGL::MetalContext::VertexShader::Spec::decode_segment(char const**)::$_0::__invoke(uint64_t result, char a2)
{
  *(_WORD *)(result + 2) = *(_WORD *)(result + 2) & 0xFFE0 | a2 & 0x1F;
  return result;
}

_BYTE *CA::OGL::MetalContext::VertexShader::Spec::decode_segment(char const**)::$_1::__invoke(_BYTE *result, char a2)
{
  *result = *result & 0xFC | a2 & 3;
  return result;
}

uint64_t CA::OGL::MetalContext::VertexShader::Spec::decode_segment(char const**)::$_2::__invoke(uint64_t result, char a2)
{
  *(_BYTE *)(result + 1) = *(_BYTE *)(result + 1) & 0xFC | a2 & 3;
  return result;
}

uint64_t CA::OGL::MetalContext::VertexShader::Spec::decode_segment(char const**)::$_3::__invoke(uint64_t result, char a2)
{
  *(_WORD *)(result + 2) = *(_WORD *)(result + 2) & 0xFF9F | (32 * (a2 & 3));
  return result;
}

uint64_t CA::OGL::MetalContext::VertexShader::Spec::decode_segment(char const**)::$_4::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 2) = *(_WORD *)(result + 2) & 0xFF7F | ((a2 != 0) << 7);
  return result;
}

uint64_t CA::OGL::MetalContext::VertexShader::Spec::decode_segment(char const**)::$_5::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 2) = *(_WORD *)(result + 2) & 0xFEFF | ((a2 != 0) << 8);
  return result;
}

uint64_t CA::OGL::MetalContext::VertexShader::Spec::decode_segment(char const**)::$_6::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 2) = *(_WORD *)(result + 2) & 0xFDFF | ((a2 != 0) << 9);
  return result;
}

void CA::OGL::MetalContext_FlushSharedState(CA::OGL::MetalContext *a1)
{
  CA::OGL::MetalContext::flush(a1, 0);
}

void sub_18468AF40(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::tuple<unsigned short,unsigned short>>::destroy(*(_QWORD **)(v1 + 344));
  std::deque<objc_object  {objcproto9MTLBuffer}*>::~deque[abi:nn180100](v1 + 288);
  std::deque<objc_object  {objcproto9MTLBuffer}*>::~deque[abi:nn180100](v1 + 240);
  _Unwind_Resume(a1);
}

uint64_t std::deque<objc_object  {objcproto9MTLBuffer}*>::~deque[abi:nn180100](uint64_t a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
  *(_QWORD *)(a1 + 40) = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = *(void ***)(a1 + 16);
      v2 = (void **)(*(_QWORD *)(a1 + 8) + 8);
      *(_QWORD *)(a1 + 8) = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 256;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    v6 = 512;
LABEL_7:
    *(_QWORD *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    v9 = *(_QWORD *)(a1 + 8);
    v8 = *(_QWORD *)(a1 + 16);
    if (v8 != v9)
      *(_QWORD *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void CAML::Context::errorv(CAML::Context *this, const char *a2, va_list a3)
{
  char *v6;
  int v7;
  size_t v8;
  char *v9;
  const __CFDictionary *v10;
  void *values;
  void *keys;
  char __str[1024];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!*((_QWORD *)this + 4))
  {
    v6 = __str;
    bzero(__str, 0x400uLL);
    v7 = vsnprintf(__str, 0x400uLL, a2, a3);
    v8 = v7 + 1;
    if (v8 >= 0x401)
    {
      v9 = (char *)malloc_type_malloc(v7 + 1, 0xFAF74C40uLL);
      if (!v9)
        return;
      v6 = v9;
      vsnprintf(v9, v8, a2, a3);
    }
    keys = CFSTR("message");
    values = (void *)CFStringCreateWithCString(0, v6, 0x8000100u);
    if (values)
    {
      v10 = CFDictionaryCreate(0, (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFRelease(values);
      *((_QWORD *)this + 4) = CFErrorCreate(0, CFSTR("CAML"), 1, v10);
      CFRelease(v10);
    }
    if (v6 != __str)
      free(v6);
  }
}

uint64_t CAML::Context::start_script(CAML::Context *this, const char **a2)
{
  return CAML::Context::error(this, "<script> element not supported");
}

const __CFDictionary *CAML::Context::will_load_resource(CAML::Context *this, const __CFURL *a2)
{
  const __CFDictionary *result;

  result = (const __CFDictionary *)*((_QWORD *)this + 9);
  if (result)
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  return result;
}

void CAML::Context::did_load_resource(CAML::Context *this, const __CFURL *key, const void *value)
{
  __CFDictionary *Mutable;

  Mutable = (__CFDictionary *)*((_QWORD *)this + 9);
  if (!Mutable)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *((_QWORD *)this + 9) = Mutable;
  }
  CFDictionarySetValue(Mutable, key, value);
}

uint64_t CAML::Context::failed_to_load_resource(CAML::Context *this, const __CFURL *a2)
{
  return 0;
}

uint64_t CAML::Context::error(CAML::Context *this, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  return (*(uint64_t (**)(CAML::Context *, const char *, uint64_t *))(*(_QWORD *)this + 24))(this, a2, (uint64_t *)va);
}

void CAML::`anonymous namespace'::entity_free(void **this, void *a2)
{
  malloc_zone_t *malloc_zone;

  free(this[2]);
  free(this[12]);
  free(this[13]);
  free(this[10]);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

xmlEntityPtr CAML::`anonymous namespace'::sax_get_entity(CAML::_anonymous_namespace_ *this, xmlChar *name, const unsigned __int8 *a3)
{
  uint64_t v4;
  xmlEntityPtr result;

  v4 = *((_QWORD *)this + 7);
  if (!v4)
    return xmlGetPredefinedEntity(name);
  result = (xmlEntityPtr)x_hash_table_lookup(v4, (uint64_t)name, 0);
  if (!result)
    return xmlGetPredefinedEntity(name);
  return result;
}

uint64_t CAML::`anonymous namespace'::sax_entity_decl(CAML::_anonymous_namespace_ *this, const char *a2, const unsigned __int8 *a3, const char *a4, const char *a5, const char *a6, unsigned __int8 *a7)
{
  int v10;
  malloc_zone_t *malloc_zone;
  _DWORD *v14;
  char *v15;
  int *v16;

  v10 = (int)a3;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v14 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x88uLL, 0x743898A5uLL);
  v14[2] = 17;
  v14[23] = v10;
  v15 = strdup(a2);
  *((_QWORD *)v14 + 2) = v15;
  if (a4)
    *((_QWORD *)v14 + 12) = strdup(a4);
  if (a5)
    *((_QWORD *)v14 + 13) = strdup(a5);
  *((_QWORD *)v14 + 10) = strdup(a6);
  v14[22] = strlen(a6);
  v16 = (int *)*((_QWORD *)this + 7);
  if (!v16)
  {
    *((_QWORD *)this + 7) = v16;
  }
  return hash_table_modify(v16, (uint64_t)v15, (uint64_t)v14, 1);
}

uint64_t CAML::`anonymous namespace'::sax_warning(CAML::_anonymous_namespace_ *this, void *a2, const char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  return (*(uint64_t (**)(CAML::_anonymous_namespace_ *, void *, uint64_t *))(*(_QWORD *)this + 16))(this, a2, (uint64_t *)va);
}

uint64_t CAML::`anonymous namespace'::sax_error(CAML::_anonymous_namespace_ *this, void *a2, const char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  return (*(uint64_t (**)(CAML::_anonymous_namespace_ *, void *, uint64_t *))(*(_QWORD *)this + 24))(this, a2, (uint64_t *)va);
}

void CAML::`anonymous namespace'::object_attribute(CAML::_anonymous_namespace_ *this, CAML::Context *a2, const CAML::Type *cStr, const char *a4, uint64_t a5, void (*a6)(CAML::Context *, CAML::State *))
{
  int v7;
  CFStringRef v10;
  const __CFDictionary *v11;
  uint64_t *Value;
  const void *v13;
  uint64_t v14;
  CAML::_anonymous_namespace_ *v15;
  int v16;
  CAML::Context *v17;
  CAML::State *v18;

  v7 = (int)a4;
  v10 = CFStringCreateWithCString(0, (const char *)cStr, 0x8000100u);
  v11 = (const __CFDictionary *)*((_QWORD *)this + 8);
  if (!v11 || (Value = (uint64_t *)CFDictionaryGetValue(v11, v10)) == 0)
  {
    CFRelease(v10);
    goto LABEL_8;
  }
  v14 = *Value;
  v13 = (const void *)Value[1];
  CFRelease(v10);
  if (!v13)
  {
LABEL_8:
LABEL_9:
    CAML::Context::push_state((uint64_t)this, 0, 0, 0, 0);
    return;
  }
  if (!a2)
  {
    v15 = this;
    v16 = v7;
    v17 = 0;
    goto LABEL_11;
  }
  if (!(*(unsigned int (**)(CAML::_anonymous_namespace_ *, CAML::Context *, uint64_t))(*(_QWORD *)this + 40))(this, a2, v14))
  {
    goto LABEL_9;
  }
  v15 = this;
  v16 = v7;
  v17 = a2;
LABEL_11:
  v18 = (CAML::State *)CAML::Context::push_state((uint64_t)v15, 0, v16, (uint64_t)v17, a5);
  CAML::State::set_value(v18, v13);
}

void CAML::`anonymous namespace'::set_set(CAML::_anonymous_namespace_ *this, CAML::Context *a2, CAML::State *a3)
{
  const void *v3;

  v3 = (const void *)*((_QWORD *)a2 + 8);
  if (v3)
    CFSetAddValue(*(CFMutableSetRef *)(*((_QWORD *)this + 6) + 64), v3);
}

CFTypeRef CAML::Context::set_error(CAML::Context *this, CFTypeRef cf)
{
  const void *v4;
  CFTypeRef result;

  v4 = (const void *)*((_QWORD *)this + 4);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)this + 4) = 0;
  }
  result = CFRetain(cf);
  *((_QWORD *)this + 4) = result;
  return result;
}

uint64_t CA::OGL::emitter_cells_have_offscreens(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = *(unsigned int *)(result + 16);
    if ((_DWORD)v1)
    {
      v2 = result + 24;
      v3 = 8 * v1;
      while ((*(_BYTE *)(*(_QWORD *)v2 + 13) & 4) == 0
           && !CA::OGL::emitter_cells_have_offscreens(*(_QWORD *)(*(_QWORD *)v2 + 40)))
      {
        v2 += 8;
        v3 -= 8;
        if (!v3)
          return 0;
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint32x2_t *CA::OGL::render_emitter_cells(uint32x2_t *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint32x2_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float64x2_t v16;
  uint32x2_t *v17;
  unint64_t v18;
  unsigned int v19;
  int v20;
  int v21;
  unsigned int v22;
  double *v23;
  uint32x2_t v24;
  uint64x2_t v25;
  float64x2_t v26;
  uint64_t v27;
  float32x2_t v28;
  float64x2_t v29;
  float v30;
  double v31;
  _QWORD *v32;
  int64x2_t v33;
  int8x16_t v34;
  int32x4_t v35;
  _OWORD *v36;
  uint64_t v37;
  uint64_t v38;
  __int16 v39;
  int v40;
  __int16 v41;
  uint64_t v42;
  int v43;
  size_t v44;
  char *v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  int v49;
  float v50;
  float v51;
  uint64_t v52;
  int v53;
  int v54;
  char v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  size_t v59;
  malloc_zone_t *malloc_zone;
  CA::OGL *rect;
  double *v62;
  CA::OGL *v63;
  float32x4_t *v64;
  __int32 v65;
  float32x2_t *v66;
  double scale;
  _QWORD *v68;
  uint64_t v69;
  uint64_t *v70;
  int v71;
  int32x4_t v72;
  int32x4_t v73;
  float32x4_t *v74;
  char *v75;
  unint64_t v76;
  float32x4_t v77;
  float32x4_t *v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  __int32 v83;
  int8x16_t v84;
  int8x16_t v85;
  int8x16_t v86;
  float v87;
  float v88;
  float v89;
  float32x2_t v90;
  float32x2_t v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float v99;
  int v100;
  uint64_t v101;
  double v102;
  int8x16_t v103;
  float64x2_t v104;
  float64x2_t v105;
  float64x2_t v106;
  uint64_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float v111;
  float v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float32_t v118;
  float32_t v119;
  float32x4_t v120;
  float32x4_t v121;
  unsigned int v122;
  float32x4_t *v123;
  uint64_t v124;
  float32x4_t *v125;
  uint64_t v126;
  float32x4_t *v127;
  unint64_t v128;
  float64x2_t v129;
  _QWORD *v130;
  float v131;
  float v132;
  float v133;
  float32x2_t v134;
  float32x2_t v135;
  uint64_t i;
  int32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  int32x4_t v140;
  unsigned int v141;
  unsigned int v142;
  int32x4_t v143;
  uint64_t v144;
  uint64_t v145;
  unint64_t v146;
  char *v147;
  float v148;
  uint64_t v149;
  float32x4_t v150;
  float32x4_t *v151;
  float v152;
  char *v153;
  uint64_t v154;
  int32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  unsigned __int32 v158;
  unsigned __int32 *v159;
  unsigned int v160;
  int8x8_t v161;
  float32x4_t *v162;
  uint64_t v163;
  float32x4_t *v164;
  malloc_zone_t *v165;
  uint64_t PerfHud;
  uint64_t v167;
  uint64_t v168;
  _BYTE *v169;
  uint64_t *v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  _OWORD *v174;
  int v175;
  uint64_t v176;
  _QWORD *v177;
  float32x4_t *v178;
  float32x4_t *v179;
  uint32x2_t *v180;
  unint64_t v181;
  char *v182;
  uint64_t v183;
  uint64_t v184;
  float v185;
  float v186;
  CA::OGL::ExtendedColor *v187;
  uint32x2_t v188;
  __int128 v189;
  uint64_t v190;
  uint64_t v191;
  int v192;
  int v193;
  float64x2_t v194;
  float32x4_t v195;
  uint64_t v196;
  float32x4_t v197;
  uint64_t v198;
  int v199;
  uint64_t v200;
  int32x2_t v201[2];
  int32x4_t v202;
  _QWORD v203[2];
  uint64_t v204;
  _BYTE v205[24];
  _BYTE v206[56];
  uint64_t v207;
  __int128 v208;
  float64x2_t *v209;
  uint64_t v210;
  _QWORD v211[3];
  int v212;
  int v213;
  float32x4_t v214;
  float32x4_t v215;
  float32x4_t v216;
  float32x4_t v217;
  float32x4_t v218;
  uint64_t v219;

  v196 = a3;
  v219 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v5 = a5;
    v6 = a4;
    if (*(_DWORD *)(a4 + 16) == *(_DWORD *)(a5 + 8))
    {
      v7 = result;
      v8 = (uint64_t)*result;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)result + 16) + 16) = 3;
      if (*(_DWORD *)(a5 + 8))
      {
        v9 = a2;
        v10 = 0;
        v168 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 24);
        v187 = (CA::OGL::ExtendedColor *)&v210;
        v179 = &v216;
        v170 = &v204;
        v190 = v8 + 818;
        v177 = v211;
        v178 = &v217;
        v169 = v205;
        __asm { FMOV            V0.4S, #1.0 }
        v197 = _Q0;
        v195 = (float32x4_t)vdupq_n_s32(0x437F0000u);
        v188 = (uint32x2_t)0xFFFFFFF8FFFFFFF0;
        v189 = xmmword_18474E060;
        v186 = 0.15915;
        v185 = 6.2832;
        v171 = a4;
        v172 = a5;
        v173 = a2;
        v180 = result;
        while (1)
        {
          v183 = v10;
          v191 = *(_QWORD *)(v6 + 8 * v10 + 24);
          if ((*(_BYTE *)(v191 + 13) & 1) != 0)
            break;
LABEL_152:
          v10 = v183 + 1;
          if (v183 + 1 >= (unint64_t)*(unsigned int *)(v5 + 8))
            goto LABEL_179;
        }
        v184 = *(_QWORD *)(*(_QWORD *)v5 + 8 * v183);
        if (BYTE5(xmmword_1ECDC6A70))
        {
          PerfHud = CA::OGL::GetPerfHud((CA::OGL *)result);
          if (PerfHud)
            ++*(_QWORD *)(PerfHud + 472);
        }
        result = *(uint32x2_t **)(v191 + 24);
        if (!result)
          goto LABEL_146;
        result = (uint32x2_t *)(*(uint64_t (**)(uint32x2_t *))(*(_QWORD *)result + 80))(result);
        if (!result)
          goto LABEL_146;
        v17 = result;
        v18 = *(unsigned int *)(v191 + 12);
        v19 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[(v18 >> 9) & 3];
        v20 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[(v18 >> 11) & 3];
        v21 = *(_DWORD *)(v191 + 212);
        if ((*(_DWORD *)(v8 + 416) & 2) != 0)
          v22 = 2111;
        else
          v22 = 63;
        if ((*(_QWORD *)(*(_QWORD *)(v9 + 16) + 24) & 1) != 0)
          v23 = (double *)(v22 ^ 0x800);
        else
          v23 = (double *)v22;
        v24 = result[2];
        v25.i64[0] = v24.u32[0];
        v25.i64[1] = v24.u32[1];
        v26 = vcvtq_f64_u64(v25);
        v214 = 0uLL;
        v27 = *(_QWORD *)(v191 + 32);
        if (v27)
        {
          v28 = vcvt_f32_f64(*(float64x2_t *)(v27 + 24));
          v29 = *(float64x2_t *)(v27 + 40);
          v214 = vcvt_hight_f32_f64((int32x2_t)v28, v29);
          v16 = vcvtq_f64_f32(vsub_f32(vcvt_f32_f64(v29), v28));
          v26 = vmulq_f64(v16, v26);
          v23 = (double *)(v23 | 0x400);
        }
        *(float32x2_t *)&v16.f64[0] = vcvt_f32_f64(v26);
        v30 = *(float *)(v191 + 216);
        _ZF = v30 == 1.0;
        v31 = COERCE_DOUBLE(vmul_n_f32(*(float32x2_t *)&v16.f64[0], 1.0 / v30));
        if (!_ZF)
          v16.f64[0] = v31;
        v194 = v16;
        v213 = 0;
        v210 = 0x3C003C003C003C00;
        v32 = v177;
        v177[1] = 0;
        v32[2] = 0;
        *v32 = 0;
        v208 = 0uLL;
        v207 = 0;
        v212 = 1065353216;
        v33 = vceqzq_f64(v26);
        v199 = v21;
        if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v33, 1), (int8x16_t)v33).u64[0] & 0x8000000000000000) != 0
          || (v34 = vorrq_s8((int8x16_t)vcltzq_f64(v26), (int8x16_t)vcgezq_f64(v26)),
              (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v34), 1), v34).u64[0] & 0x8000000000000000) != 0))
        {
          v202 = 0uLL;
        }
        else
        {
          v35 = (int32x4_t)vcvtmq_s64_f64((float64x2_t)0);
          v202 = vuzp1q_s32(v35, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(v26, (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v35));
        }
        memset(v206, 0, 48);
        CA::Shape::operator=((uint64_t)v206, &v202);
        *(_QWORD *)&v208 = v206;
        v209 = (float64x2_t *)&CA::identity_transform;
        LOWORD(v213) = 1283;
        v207 = CA::OGL::Context::set_gstate(v8, (uint64_t)&v207);
        v36 = CA::OGL::Context::bind_image(v8, 0, v17, v23, v19, v20, 0, 0, *(float *)&v199, &v214, 0);
        result = (uint32x2_t *)CA::OGL::Context::set_gstate(v8, **(_QWORD **)(v8 + 232));
        v7 = v180;
        if (!v36)
        {
LABEL_146:
          if (*(_QWORD *)(v191 + 40))
          {
            v144 = *(unsigned int *)(v184 + 16);
            if ((_DWORD)v144)
            {
              v145 = *(_QWORD *)(v184 + 8);
              do
              {
                if (*(float *)(v145 + 24) != 0.0)
                {
                  --v144;
                  result = (uint32x2_t *)CA::OGL::render_emitter_cells(v7, v9, v196, *(_QWORD *)(v191 + 40), v145);
                }
                v145 += 128;
              }
              while (v144);
            }
          }
          goto LABEL_152;
        }
        v37 = *(_QWORD *)(v8 + 232);
        v208 = *(_OWORD *)(v37 + 8);
        v38 = *(_QWORD *)(v37 + 32);
        v209 = *(float64x2_t **)(v37 + 24);
        v210 = v38;
        *(_OWORD *)v177 = *(_OWORD *)(v37 + 40);
        v211[2] = *(_QWORD *)(v37 + 56);
        LOWORD(v213) = *(unsigned __int8 *)(v37 + 68) | (BYTE1(v213) << 8);
        v212 = *(_DWORD *)(v37 + 64);
        LOWORD(v213) = *(_WORD *)(v37 + 68) & 0x100 | v213 & 0xFEFF;
        v39 = v213 & 0xFBFF | *(_WORD *)(v37 + 68) & 0x400;
        v40 = *(_DWORD *)(v196 + 72);
        v41 = 16;
        if (v40 > 374)
        {
          if (v40 != 478)
          {
            if (v40 == 375)
LABEL_29:
              v41 = 18;
            else
LABEL_34:
              v41 = 3;
          }
        }
        else
        {
          switch(v40)
          {
            case 'R':
              break;
            case 'S':
              v41 = 32;
              goto LABEL_35;
            case 'T':
              goto LABEL_29;
            case 'U':
              goto LABEL_35;
            default:
              if (v40 != 2)
                goto LABEL_34;
              break;
          }
          LOWORD(v213) = v39 & 0xFF00 | 0xC;
          if ((v168 & 0x400) != 0
            || !(*(unsigned int (**)(uint32x2_t, uint64_t))(**(_QWORD **)v7 + 184))(*v7, 33))
          {
LABEL_36:
            v42 = CA::OGL::Context::set_gstate(v8, (uint64_t)&v207);
            v207 = v42;
            v176 = *(unsigned int *)(v184 + 16);
            v43 = *(_DWORD *)(v196 + 72);
            if ((v43 - 396) < 2 || v43 == 50)
            {
              if (v176 > 0x80)
              {
                v45 = (char *)malloc_type_malloc(32 * v176, 0x70D7DFAuLL);
                if (!v45)
                {
LABEL_145:
                  CA::OGL::Context::set_gstate(v8, **(_QWORD **)(v8 + 232));
                  result = (uint32x2_t *)(*(uint64_t (**)(uint64_t, _OWORD *, _QWORD))(*(_QWORD *)v8 + 520))(v8, v36, 0);
                  goto LABEL_146;
                }
              }
              else
              {
                MEMORY[0x1E0C80A78](v42);
                v45 = (char *)&v168 - ((v44 + 15) & 0x3FFFFFFFF0);
                bzero(v45, v44);
              }
              v46 = *(unsigned int *)(v184 + 16);
              v182 = v45;
              v47 = v45;
              if ((_DWORD)v46)
              {
                v48 = *(_QWORD *)(v184 + 8);
                v47 = v182;
                do
                {
                  if (*(float *)(v48 + 24) != 0.0)
                  {
                    v49 = *(_DWORD *)(v196 + 72);
                    if (v49 == 396)
                    {
                      v50 = *(double *)(v48 + 16);
                    }
                    else if (v49 == 50)
                    {
                      v50 = *(float *)(v48 + 40);
                    }
                    else
                    {
                      v51 = *(double *)(v48 + 16);
                      v50 = -v51;
                    }
                    --v46;
                    *(_DWORD *)v47 = ((SLODWORD(v50) >> 31) | 0x80000000) ^ LODWORD(v50);
                    *((_QWORD *)v47 + 1) = v48;
                    v47 += 16;
                  }
                  v48 += 128;
                }
                while (v46);
              }
              v52 = (v47 - v182) >> 4;
              CA::radix_sort(v52);
            }
            else
            {
              v182 = 0;
              v52 = v176;
            }
            v181 = v52;
            if (!v52)
            {
LABEL_142:
              if (v182 && v176 >= 0x81)
                free(v182);
              goto LABEL_145;
            }
            v174 = v36;
            v53 = *(_DWORD *)(v191 + 64);
            v199 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v196 + 176))(v196);
            if (v53 == 427)
            {
              v199 = 3;
              v56 = 1;
              v54 = 1;
            }
            else if (v53 == 521)
            {
              v54 = v199 ^ 1;
              if (v181 < 0x81)
                v55 = 1;
              else
                v55 = v199;
              if ((v55 & 1) != 0)
              {
                v175 = 0;
                v56 = 0;
LABEL_66:
                v57 = *(_QWORD *)(v8 + 16);
                if (*(unsigned __int8 *)(v57 + 480) >= 2u)
                  *(_BYTE *)(v57 + 481) |= 1u;
                v201[0] = 0;
                v201[1] = 0;
                if (v56 && (*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 184))(v8, 11))
                {
                  v58 = 768;
                  if (v181 < 0x300)
                    v58 = v181;
                  v198 = v58;
                  v59 = 16 * v58;
                  malloc_zone = (malloc_zone_t *)get_malloc_zone();
                  rect = (CA::OGL *)malloc_type_zone_malloc(malloc_zone, v59, 0x8BB15036uLL);
                  v63 = rect;
                  if (rect)
                  {
                    v64 = *(float32x4_t **)(v184 + 8);
                    v65 = *(_DWORD *)(v191 + 224);
                    v66 = *(float32x2_t **)(v8 + 16);
                    v66[12] = vsub_f32(*(float32x2_t *)&v214.u32[2], *(float32x2_t *)v214.f32);
                    v66[13].i32[0] = v65;
                    v66[13].i32[1] = 0;
                    if ((LOBYTE(v209[9].f64[0]) & 0x10) != 0)
                      scale = CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v209, 0, 0, v62);
                    else
                      scale = v209[8].f64[0];
                    v146 = v181;
                    v147 = v182;
                    v199 = 0;
                    v148 = scale * *(float *)v194.f64;
                    *(float *)v194.f64 = v148;
                    do
                    {
                      v149 = 0;
                      v150 = 0uLL;
                      while (v146)
                      {
                        v151 = v64;
                        while (1)
                        {
                          if (v147)
                          {
                            v64 = v151;
                            v151 = (float32x4_t *)*((_QWORD *)v147 + 1);
                            v147 += 16;
                            --v146;
                            goto LABEL_166;
                          }
                          v64 = v151 + 8;
                          v152 = v151[1].f32[2];
                          if (v152 != 0.0)
                          {
                            --v146;
                            if (v151[3].f32[3] < v152)
                              break;
                          }
                          v147 = 0;
                          v151 += 8;
                          if (!v146)
                          {
                            v147 = 0;
                            goto LABEL_170;
                          }
                        }
                        v147 = 0;
LABEL_166:
                        v153 = (char *)v63 + 16 * v149;
                        v154 = v210;
                        v200 = v210;
                        *(_QWORD *)v153 = v151[2].i64[0];
                        *((float *)v153 + 2) = v151[5].f32[1] * *(float *)v194.f64;
                        v155 = (int32x4_t)vmaxq_f32(vminq_f32(v151[4], v197), v150);
                        v156 = (float32x4_t)vdupq_laneq_s32(v155, 3);
                        v156.i32[3] = 1.0;
                        v157.i64[0] = 0x3F0000003F000000;
                        v157.i64[1] = 0x3F0000003F000000;
                        *(int16x4_t *)v155.i8 = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v157, v156, vmulq_f32((float32x4_t)v155, v195))));
                        v158 = vuzp1_s8(*(int8x8_t *)v155.i8, *(int8x8_t *)v155.i8).u32[0];
                        *((_DWORD *)v153 + 3) = v158;
                        v159 = (unsigned __int32 *)(v153 + 12);
                        if (v154 != 0x3C003C003C003C00)
                        {
                          v160 = CA::OGL::ExtendedColor::word32((CA::OGL::ExtendedColor *)&v200);
                          v150 = 0uLL;
                          v161 = vand_s8((int8x8_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v158 >> 8), (int8x8_t)0xFF0000FF00), vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v160), v188), (int8x8_t)0xFF000000FFLL), (int32x2_t)0x100000001)), (int8x8_t)0x1FF0001FF0000);
                          *v159 = (((v158 >> 8) & 0xFF0000) + ((v158 >> 8) & 0xFF0000) * HIBYTE(v160)) & 0xFF000000 | ((v158 * v160 + v158) >> 8) | v161.i32[0] | v161.i32[1];
                        }
                        ++v149;
                        v7 = v180;
                        if (v149 == v198)
                        {
                          v149 = v198;
                          break;
                        }
                      }
LABEL_170:
                      v162 = v178;
                      v178->i64[0] = 0;
                      v162->i64[1] = 0;
                      v162[1].i64[0] = 0;
                      v163 = *(_QWORD *)(*(_QWORD *)(v8 + 232) + 8);
                      v215.i64[0] = v8;
                      v215.i64[1] = v163;
                      v164 = v179;
                      v179->i64[0] = 0;
                      v164->i64[1] = 0;
                      v164[1].i16[0] = 0;
                      CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)&v215);
                      while (CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)&v215, v201))(*(void (**)(uint64_t, _QWORD, uint64_t, CA::OGL *))(*(_QWORD *)v8 + 304))(v8, 0, v149, v63);
                      v199 += v149;
                    }
                    while (v146);
                    v165 = (malloc_zone_t *)get_malloc_zone();
                    malloc_zone_free(v165, v63);
                    v6 = v171;
                    v5 = v172;
                    v36 = v174;
                    LODWORD(v63) = v199;
                    goto LABEL_138;
                  }
LABEL_137:
                  v36 = v174;
LABEL_138:
                  v9 = v173;
                  if (BYTE5(xmmword_1ECDC6A70))
                  {
                    v167 = CA::OGL::GetPerfHud(rect);
                    if (v167)
                      *(_QWORD *)(v167 + 480) += v63;
                  }
                  if (v175)
                  {
                    *(_QWORD *)(v8 + 800) = 0;
                    ++*(_DWORD *)(v8 + 240);
                  }
                  *(_BYTE *)(*(_QWORD *)(v8 + 16) + 481) &= ~1u;
                  goto LABEL_142;
                }
                v68 = v169;
                *((_QWORD *)v169 + 1) = 0;
                v68[2] = 0;
                *v68 = 0;
                v69 = *(_QWORD *)(*(_QWORD *)(v8 + 232) + 8);
                v203[0] = v8;
                v203[1] = v69;
                v70 = v170;
                *v170 = 0;
                v70[1] = 0;
                *((_BYTE *)v70 + 16) = 0;
                v205[1] = 1;
                CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)v203);
                LODWORD(v63) = 0;
                v71 = v175;
                if (v199 != 1)
                  v71 = 1;
                v192 = v54 & (v175 ^ 1);
                v193 = v71;
LABEL_78:
                rect = (CA::OGL *)CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)v203, v201);
                if (!(_DWORD)rect)
                {
                  v6 = v171;
                  v5 = v172;
                  v7 = v180;
                  goto LABEL_137;
                }
                v74 = *(float32x4_t **)(v184 + 8);
                v76 = v181;
                v75 = v182;
                v77 = 0uLL;
                while (!v75)
                {
                  v78 = v74 + 8;
                  v88 = v74[1].f32[2];
                  v75 = 0;
                  if (v88 != 0.0)
                  {
                    --v76;
                    if (v74[3].f32[3] < v88)
                      goto LABEL_82;
                  }
LABEL_134:
                  v74 = v78;
                  if (!v76)
                    goto LABEL_78;
                }
                v78 = v74;
                v74 = (float32x4_t *)*((_QWORD *)v75 + 1);
                v75 += 16;
                --v76;
LABEL_82:
                v198 = (uint64_t)v78;
                v79 = 4;
                if (*(_DWORD *)(v8 + 92))
                  v79 = 6;
                v80 = *(_QWORD *)(v8 + 128);
                if ((unint64_t)(v80 + 4) > *(_QWORD *)(v8 + 136)
                  || (v81 = *(_QWORD *)(v8 + 112)) != 0 && *(_QWORD *)(v8 + 104) + v79 > v81)
                {
                  *(_WORD *)(v8 + 816) |= 0x20u;
                  CA::OGL::Context::array_flush(v8);
                  v77 = 0uLL;
                  LODWORD(v80) = 0;
                  *(_QWORD *)(v8 + 128) = 0;
                  *(_QWORD *)(v8 + 96) = v190;
                  *(_OWORD *)(v8 + 104) = v189;
                }
                v82 = *(_QWORD *)(v8 + 120);
                v217 = v77;
                v218 = v77;
                v215 = v77;
                v216 = v77;
                v72.i64[0] = v74[2].i64[0];
                v83 = 1.0;
                v84.i64[0] = v72.i64[0];
                v84.i32[2] = v74[2].i32[2];
                v84.i32[3] = 1.0;
                if ((v193 & 1) == 0)
                {
                  if ((LOBYTE(v209[9].f64[0]) & 0x10) != 0)
                  {
                    v73 = (int32x4_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*v209), v209[1]);
                    v84 = (int8x16_t)vmlaq_laneq_f32(vmlaq_lane_f32(vmlaq_n_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v209[6]), v209[7]), (float32x4_t)v73, *(float *)v72.i32), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v209[2]), v209[3]), *(float32x2_t *)v72.i8, 1), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v209[4]), v209[5]), (float32x4_t)v84, 2);
                  }
                  else
                  {
                    if ((LOBYTE(v209[9].f64[0]) & 8) != 0)
                    {
                      v73.i64[0] = *(_QWORD *)&v209[8].f64[0];
                      *(float32x2_t *)v72.i8 = vcvt_f32_f64(vmulq_n_f64(vcvtq_f64_f32(*(float32x2_t *)v72.i8), *(double *)v73.i64));
                      v72.i64[1] = vextq_s8(v84, v84, 8uLL).u64[0];
                      v84 = (int8x16_t)v72;
                    }
                    if ((LOBYTE(v209[9].f64[0]) & 4) != 0)
                    {
                      v73.i64[1] = v84.i64[1];
                      *(float *)v73.i32 = -*(float *)&v84.i32[1];
                      v73.i32[1] = v84.i32[0];
                      v84 = (int8x16_t)v73;
                    }
                    v72.i32[0] = 0;
                    v73.i32[0] = LOBYTE(v209[9].f64[0]) & 2;
                    v85 = v84;
                    *(float *)v85.i32 = -*(float *)v84.i32;
                    v86 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v73, v72), 0), v84, v85);
                    v87 = *(float *)&v86.i32[1];
                    if ((LOBYTE(v209[9].f64[0]) & 1) != 0)
                      v87 = -*(float *)&v86.i32[1];
                    v73 = (int32x4_t)vextq_s8(v86, v86, 8uLL);
                    *(float *)&v86.i32[1] = v87;
                    v72 = (int32x4_t)v209[6];
                    *(float32x2_t *)v84.i8 = vcvt_f32_f64(vaddq_f64((float64x2_t)v72, vcvtq_f64_f32(*(float32x2_t *)v86.i8)));
                    v84.i64[1] = v73.i64[0];
                  }
                  v83 = v84.i32[3];
                }
                v89 = v74[5].f32[2];
                v90 = vmul_n_f32(*(float32x2_t *)&v194.f64[0], v74[5].f32[1]);
                *(float32x2_t *)v215.f32 = vmul_f32(v90, (float32x2_t)0xBF000000BF000000);
                v215.i32[3] = v83;
                v216.i32[3] = v83;
                v91 = vmul_f32(v90, (float32x2_t)0x3F0000003F000000);
                *(float32x2_t *)v217.f32 = v91;
                v91.i32[1] = v215.i32[1];
                *(float32x2_t *)v216.f32 = v91;
                v217.i32[3] = v83;
                *(float32x2_t *)v218.f32 = vmul_f32(v90, (float32x2_t)0x3F000000BF000000);
                v218.i32[3] = v83;
                v92 = *(float *)(v196 + 124) + v89;
                if (v92 < -3.1416 || v92 > 3.1416)
                  v92 = (float)((float)((float)((float)(v92 * v186) + 0.5) - floorf((float)(v92 * v186) + 0.5)) * v185)
                      + -3.1416;
                v93 = v92 * v92;
                v94 = (float)((float)((float)((float)((float)(v92 * v92) * 0.0054654) + -0.15346) * (float)(v92 * v92))
                            + 0.98442)
                    * v92;
                v95 = (float)((float)((float)((float)(v93 * -0.00096967) + 0.039228) * v93) + -0.49535) * v93;
                v96 = v95 + 0.99861;
                if (v199 == 2
                  && ((v98 = v74[7].f32[0], v97 = v74[7].f32[1], v99 = v74[7].f32[2], fabsf(v98) >= 0.001)
                   || fabsf(v97) >= 0.001
                   || fabsf(v99 + -1.0) >= 0.001))
                {
                  v100 = (int)v63;
                  v107 = 0;
                  v108.i64[0] = v74[7].i64[0];
                  v108.i64[1] = v74[7].u32[2];
                  v109 = vmulq_f32(v108, v108);
                  v110 = vmlaq_n_f32(v109, vsubq_f32(v197, v109), v96);
                  v111 = 0.0013933 - v95;
                  v112 = (float)(v97 * v98) * v111;
                  v113 = (float)(v99 * v97) * v111;
                  v114 = (float)(v99 * v98) * v111;
                  v115 = v94 * v98;
                  v116 = v94 * v97;
                  v117 = v94 * v99;
                  v118 = v112 + v117;
                  v119 = v114 - v116;
                  *(float *)v72.i32 = v112 - v117;
                  *(float *)v73.i32 = v114 + v116;
                  v72.i32[1] = v110.i32[1];
                  *(float *)&v73.i32[1] = v113 - v115;
                  v73.i32[2] = v110.i32[2];
                  v120 = v110;
                  v120.f32[1] = v118;
                  v120.f32[2] = v119;
                  *(float *)&v72.i32[2] = v113 + v115;
                  do
                  {
                    v121 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v120, v215.f32[v107]), (float32x4_t)v72, v215.f32[v107 + 1]), (float32x4_t)v73, v215.f32[v107 + 2]);
                    v121.i32[3] = v215.i32[v107 + 3];
                    *(float32x4_t *)((char *)&v215 + v107 * 4) = v121;
                    v107 += 4;
                  }
                  while (v107 != 16);
                }
                else
                {
                  v100 = (int)v63;
                  v101 = 0;
                  v102 = v94;
                  do
                  {
                    v103 = (int8x16_t)vcvtq_f64_f32(*(float32x2_t *)&v215.f32[v101]);
                    v104 = vmulq_n_f64((float64x2_t)vextq_s8(v103, v103, 8uLL), v102);
                    v105 = vmulq_n_f64((float64x2_t)v103, v96);
                    *(_QWORD *)&v106.f64[0] = *(_OWORD *)&vsubq_f64(v105, v104);
                    v106.f64[1] = vaddq_f64(v105, v104).f64[1];
                    *(float32x2_t *)&v215.f32[v101] = vcvt_f32_f64(v106);
                    v101 += 4;
                  }
                  while (v101 != 16);
                }
                v84.i32[3] = 0;
                v215 = vaddq_f32(v215, (float32x4_t)v84);
                v216 = vaddq_f32(v216, (float32x4_t)v84);
                v122 = v80;
                v123 = (float32x4_t *)(v82 + 48 * v80);
                v217 = vaddq_f32(v217, (float32x4_t)v84);
                v218 = vaddq_f32(v218, (float32x4_t)v84);
                if ((v192 & 1) != 0)
                {
                  if ((LOBYTE(v209[9].f64[0]) & 0x1F) != 0)
                  {
                    CA::Transform::apply_to_point4((uint64_t)v209, (float32x2_t *)&v215, (float32x2_t *)&v215, (const float *)0x10, 4);
                    v77 = 0uLL;
                    v124 = 0;
                    v125 = v123;
                    do
                    {
                      *v125 = *(float32x4_t *)((char *)&v215 + v124);
                      v125 += 3;
                      v124 += 16;
                    }
                    while (v124 != 64);
                  }
                  else
                  {
                    v128 = 0;
                    v129 = v209[6];
                    v130 = (_QWORD *)(v82 + 48 * v122 + 8);
                    do
                    {
                      *(v130 - 1) = vcvt_f32_f64(vaddq_f64(v129, vcvtq_f64_f32(*(float32x2_t *)&v215.f32[v128 / 4])));
                      *v130 = v215.i64[v128 / 8 + 1];
                      v130 += 6;
                      v128 += 16;
                    }
                    while (v128 != 64);
                  }
                }
                else
                {
                  v126 = 0;
                  v127 = v123;
                  do
                  {
                    *v127 = *(float32x4_t *)((char *)&v215 + v126);
                    v127 += 3;
                    v126 += 16;
                  }
                  while (v126 != 64);
                }
                *(_QWORD *)(v82 + 48 * v122 + 16) = v214.i64[0];
                v123[4].i32[0] = v214.i32[2];
                v123[4].i32[1] = v214.i32[1];
                v123[7].i64[0] = v214.i64[1];
                v123[10].i32[0] = v214.i32[0];
                v123[10].i32[1] = v214.i32[3];
                v131 = v74[5].f32[0];
                if (v131 != 0.0)
                {
                  v132 = *(float *)(v191 + 224);
                  v133 = floorf(v131 / v132);
                  v134.f32[0] = floorf(v131 - (float)(v133 * v132));
                  v134.f32[1] = v133;
                  v135 = vmul_f32(v134, vsub_f32(*(float32x2_t *)&v214.u32[2], *(float32x2_t *)v214.f32));
                  for (i = 1; i != 13; i += 3)
                    *(float32x2_t *)v123[i].f32 = vadd_f32(*(float32x2_t *)v123[i].f32, v135);
                }
                v137 = (int32x4_t)vmaxq_f32(vminq_f32(v74[4], v197), v77);
                v138 = (float32x4_t)vdupq_laneq_s32(v137, 3);
                v138.i32[3] = 1.0;
                v139.i64[0] = 0x3F0000003F000000;
                v139.i64[1] = 0x3F0000003F000000;
                v140 = vcvtq_s32_f32(vmlaq_f32(v139, v138, vmulq_f32((float32x4_t)v137, v195)));
                *(int16x4_t *)v140.i8 = vmovn_s32(v140);
                v141 = vuzp1_s8(*(int8x8_t *)v140.i8, *(int8x8_t *)v140.i8).u32[0];
                if (v210 != 0x3C003C003C003C00)
                {
                  v142 = CA::OGL::ExtendedColor::word32(v187);
                  v77 = 0uLL;
                  *(int8x8_t *)v140.i8 = vand_s8((int8x8_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v141 >> 8), (int8x8_t)0xFF0000FF00), vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v142), v188), (int8x8_t)0xFF000000FFLL), (int32x2_t)0x100000001)), (int8x8_t)0x1FF0001FF0000);
                  v141 = (((v141 >> 8) & 0xFF0000) + ((v141 >> 8) & 0xFF0000) * HIBYTE(v142)) & 0xFF000000 | ((v141 * v142 + v141) >> 8) | v140.i32[0] | v140.i32[1];
                }
                v140.i32[0] = v141;
                v140.i32[1] = v141 >> 8;
                v140.i32[2] = HIWORD(v141);
                v73.i64[0] = 0xFF000000FFLL;
                v73.i64[1] = 0xFF000000FFLL;
                v143 = (int32x4_t)vandq_s8((int8x16_t)v140, (int8x16_t)v73);
                v143.i32[3] = vshrq_n_u32((uint32x4_t)vdupq_n_s32(v141), 0x18uLL).i32[3];
                v72 = vdupq_n_s32(0x3B808081u);
                *(float16x4_t *)v143.i8 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_s32(v143), (float32x4_t)v72));
                *(_QWORD *)(v82 + 48 * v122 + 32) = v143.i64[0];
                v123[5].i64[0] = v143.i64[0];
                v123[8].i64[0] = v143.i64[0];
                v123[11].i64[0] = v143.i64[0];
                if (!v199)
                {
                  v123[9].i32[2] = 0;
                  v123[6].i32[2] = 0;
                  v123[3].i32[2] = 0;
                  *(_DWORD *)(v82 + 48 * v122 + 8) = 0;
                }
                if (*(_QWORD *)(v8 + 96))
                {
                  CA::OGL::Context::array_indices(v8, *(_DWORD *)(v8 + 128));
                  v77 = 0uLL;
                }
                *(_QWORD *)(v8 + 128) += 4;
                LODWORD(v63) = v100 + 1;
                v78 = (float32x4_t *)v198;
                goto LABEL_134;
              }
              v56 = 0;
              v199 = 0;
            }
            else
            {
              v56 = 0;
              v175 = 0;
              v199 = 2;
              v54 = 1;
              if (v181 < 0x81)
                goto LABEL_66;
            }
            *(_QWORD *)(v8 + 800) = v209;
            ++*(_DWORD *)(v8 + 240);
            v175 = 1;
            goto LABEL_66;
          }
          v41 = 56;
          v39 = v213;
        }
LABEL_35:
        LOWORD(v213) = v39 & 0xFF00 | v41;
        goto LABEL_36;
      }
LABEL_179:
      *(_BYTE *)(*(_QWORD *)(v8 + 16) + 16) = 0;
    }
  }
  return result;
}

void sub_18468CAF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DBD990](v1, 0x10A0C40DF5EECE8);
  _Unwind_Resume(a1);
}

void sub_18468CBA4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_18468CC40(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::FrameRateRangeGroup::remove(int8x8_t *this, CAFrameRateRange a2)
{
  unint64_t v3;
  unsigned int v4;
  unsigned int v5;
  int8x8_t *v6;
  float *v7;
  uint64_t v8;
  uint64_t v9;
  int8x8_t v10;
  int8x8_t v11;
  uint64_t v12;
  float *v13;
  int8x8_t v14;
  unint64_t v15;
  uint8x8_t v16;
  NSObject *v17;
  float *v18;
  float *v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  CAFrameRateRange v24;
  uint8_t buf[8];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v24 = a2;
  v3 = CA::FrameRateRangeGroup::fps_range_to_frame_interval_range((CA::FrameRateRangeGroup *)this, a2);
  v5 = v4;
  v6 = this + 7;
  v7 = std::__hash_table<std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,std::__unordered_map_hasher<CAFrameRateRange,std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,CAFrameRateRangeHasher,std::equal_to<CAFrameRateRange>,true>,std::__unordered_map_equal<CAFrameRateRange,std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,std::equal_to<CAFrameRateRange>,CAFrameRateRangeHasher,true>,std::allocator<std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>>>::find<CAFrameRateRange>(&this[7], &v24.minimum);
  if (v7)
  {
    v8 = *((_QWORD *)v7 + 6);
    if (!v8 || *((_DWORD *)v7 + 8) != (_DWORD)v3 || *(_QWORD *)(v7 + 9) != __PAIR64__(v5, HIDWORD(v3)))
      __assert_rtn("remove", "CAFrameRateRangeGroup.mm", 178, "info.count > 0 && info.range == range");
    v9 = v8 - 1;
    if (v9)
    {
      *((_QWORD *)v7 + 6) = v9;
    }
    else
    {
      v11 = this[12];
      v10 = this[13];
      if (*(_QWORD *)&v11 != *(_QWORD *)&v10)
      {
        while (**(_DWORD **)&v11 != (_DWORD)v3 || *(_QWORD *)(*(_QWORD *)&v11 + 4) != __PAIR64__(v5, HIDWORD(v3)))
        {
          *(_QWORD *)&v11 += 12;
          if (*(_QWORD *)&v11 == *(_QWORD *)&v10)
          {
            v11 = this[13];
            break;
          }
        }
      }
      if (*(_QWORD *)&v11 == *(_QWORD *)&v10)
        __assert_rtn("remove", "CAFrameRateRangeGroup.mm", 183, "it != _ranges.end ()");
      v12 = *(_QWORD *)&v10 - (*(_QWORD *)&v11 + 12);
      if (*(_QWORD *)&v10 != *(_QWORD *)&v11 + 12)
        memmove(*(void **)&v11, (const void *)(*(_QWORD *)&v11 + 12), *(_QWORD *)&v10 - (*(_QWORD *)&v11 + 12));
      this[13] = (int8x8_t)(*(_QWORD *)&v11 + v12);
      v13 = std::__hash_table<std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,std::__unordered_map_hasher<CAFrameRateRange,std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,CAFrameRateRangeHasher,std::equal_to<CAFrameRateRange>,true>,std::__unordered_map_equal<CAFrameRateRange,std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,std::equal_to<CAFrameRateRange>,CAFrameRateRangeHasher,true>,std::allocator<std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>>>::find<CAFrameRateRange>(&this[7], &v24.minimum);
      if (v13)
      {
        v14 = this[8];
        v15 = *((_QWORD *)v13 + 1);
        v16 = (uint8x8_t)vcnt_s8(v14);
        v16.i16[0] = vaddlv_u8(v16);
        if (v16.u32[0] > 1uLL)
        {
          if (v15 >= *(_QWORD *)&v14)
            v15 %= *(_QWORD *)&v14;
        }
        else
        {
          v15 &= *(_QWORD *)&v14 - 1;
        }
        v18 = *(float **)(*(_QWORD *)v6 + 8 * v15);
        do
        {
          v19 = v18;
          v18 = *(float **)v18;
        }
        while (v18 != v13);
        if (v19 == (float *)&this[9])
          goto LABEL_38;
        v20 = *((_QWORD *)v19 + 1);
        if (v16.u32[0] > 1uLL)
        {
          if (v20 >= *(_QWORD *)&v14)
            v20 %= *(_QWORD *)&v14;
        }
        else
        {
          v20 &= *(_QWORD *)&v14 - 1;
        }
        if (v20 != v15)
        {
LABEL_38:
          if (!*(_QWORD *)v13)
            goto LABEL_39;
          v21 = *(_QWORD *)(*(_QWORD *)v13 + 8);
          if (v16.u32[0] > 1uLL)
          {
            if (v21 >= *(_QWORD *)&v14)
              v21 %= *(_QWORD *)&v14;
          }
          else
          {
            v21 &= *(_QWORD *)&v14 - 1;
          }
          if (v21 != v15)
LABEL_39:
            *(_QWORD *)(*(_QWORD *)v6 + 8 * v15) = 0;
        }
        v22 = *(_QWORD *)v13;
        if (*(_QWORD *)v13)
        {
          v23 = *(_QWORD *)(v22 + 8);
          if (v16.u32[0] > 1uLL)
          {
            if (v23 >= *(_QWORD *)&v14)
              v23 %= *(_QWORD *)&v14;
          }
          else
          {
            v23 &= *(_QWORD *)&v14 - 1;
          }
          if (v23 != v15)
          {
            *(_QWORD *)(*(_QWORD *)v6 + 8 * v23) = v19;
            v22 = *(_QWORD *)v13;
          }
        }
        *(_QWORD *)v19 = v22;
        *(_QWORD *)v13 = 0;
        --*(_QWORD *)&this[10];
        operator delete(v13);
      }
    }
  }
  else if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v17 = x_log_category_utilities;
    if (os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_184457000, v17, OS_LOG_TYPE_ERROR, "Unmatched FrameRateRangeGroup remove.", buf, 2u);
    }
  }
}

float *std::__hash_table<std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,std::__unordered_map_hasher<CAFrameRateRange,std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,CAFrameRateRangeHasher,std::equal_to<CAFrameRateRange>,true>,std::__unordered_map_equal<CAFrameRateRange,std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>,std::equal_to<CAFrameRateRange>,CAFrameRateRangeHasher,true>,std::allocator<std::__hash_value_type<CAFrameRateRange,CA::FrameRateRangeGroup::RangeInfo>>>::find<CAFrameRateRange>(_QWORD *a1, float *a2)
{
  int8x8_t v2;
  float v3;
  float v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  float **v8;
  float *result;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = a2[1];
  v4 = a2[2];
  v5 = ((uint64_t)(int)v3 << 16) | ((unint64_t)(int)*a2 << 32) | (int)v4;
  v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = ((uint64_t)(int)v3 << 16) | ((unint64_t)(int)*a2 << 32) | (int)v4;
    if (v5 >= *(_QWORD *)&v2)
      v7 = v5 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = v5 & (*(_QWORD *)&v2 - 1);
  }
  v8 = *(float ***)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  for (result = *v8; result; result = *(float **)result)
  {
    v10 = *((_QWORD *)result + 1);
    if (v10 == v5)
    {
      if (result[4] == *a2 && result[5] == v3 && result[6] == v4)
        return result;
    }
    else
    {
      if (v6.u32[0] > 1uLL)
      {
        if (v10 >= *(_QWORD *)&v2)
          v10 %= *(_QWORD *)&v2;
      }
      else
      {
        v10 &= *(_QWORD *)&v2 - 1;
      }
      if (v10 != v7)
        return 0;
    }
  }
  return result;
}

void CA::Render::LayerNode::MapRects::apply(uint64_t a1, float64x2_t *this, double *a3)
{
  uint64_t v5;
  unint64_t v6;

  if (*(_QWORD *)(a1 + 8))
  {
    v5 = 0;
    v6 = 0;
    do
    {
      CA::Mat4Impl::mat4_apply_to_rect(this, (int8x16_t *)(*(_QWORD *)(a1 + 16) + v5), a3);
      ++v6;
      v5 += 32;
    }
    while (v6 < *(_QWORD *)(a1 + 8));
  }
}

double CA::Render::LayerNode::MapTransform::apply(uint64_t a1, const double *a2, uint64_t a3, const double *a4)
{
  double result;

  *(_QWORD *)&result = *(_OWORD *)&CA::Mat4Impl::mat4_concat((float64x2_t *)*(_QWORD *)(a1 + 8), (double *)*(_QWORD *)(a1 + 8), a2, a4);
  return result;
}

double CA::Render::LayerNode::MapTransform::unapply(uint64_t a1, double *a2, uint64_t a3, const double *a4)
{
  double result;

  *(_QWORD *)&result = *(_OWORD *)&CA::Mat4Impl::mat4_concat((float64x2_t *)*(_QWORD *)(a1 + 8), a2, (const double *)*(_QWORD *)(a1 + 8), a4);
  return result;
}

void CA::Render::LayerNode::set_frame_transform(CA::Render::LayerNode *this, const CA::Transform *a2)
{
  _OWORD *v4;
  malloc_zone_t *malloc_zone;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  malloc_zone_t *v12;

  v4 = (_OWORD *)*((_QWORD *)this + 7);
  if ((*((_BYTE *)a2 + 144) & 0x1F) != 0)
  {
    if (!v4)
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      v4 = malloc_type_zone_malloc(malloc_zone, 0x80uLL, 0x8BB15036uLL);
      *((_QWORD *)this + 7) = v4;
    }
    v6 = *((_OWORD *)a2 + 1);
    v7 = *((_OWORD *)a2 + 2);
    v8 = *((_OWORD *)a2 + 3);
    *v4 = *(_OWORD *)a2;
    v4[1] = v6;
    v4[2] = v7;
    v4[3] = v8;
    v9 = *((_OWORD *)a2 + 5);
    v10 = *((_OWORD *)a2 + 6);
    v11 = *((_OWORD *)a2 + 7);
    v4[4] = *((_OWORD *)a2 + 4);
    v4[5] = v9;
    v4[6] = v10;
    v4[7] = v11;
  }
  else
  {
    if (v4)
    {
      v12 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v12, v4);
      *((_QWORD *)this + 7) = 0;
    }
    *((_QWORD *)this + 8) = *((_QWORD *)a2 + 12);
    *((_QWORD *)this + 9) = *((_QWORD *)a2 + 13);
    *((_QWORD *)this + 10) = 0;
  }
  *((_QWORD *)this + 3) |= 0x20000uLL;
}

void sub_18468D358(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_18468D454(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_18468D7C4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_18468D8A0(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

xpc_object_t encode_batch_handle_port(unint64_t a1, uint64_t a2, int a3)
{
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  xpc_object_t v10;

  do
  {
    do
    {
      v5 = __ldaxr(next_batch_encode_count(void)::last_encode_count);
      v6 = __stlxr(v5 + 1, next_batch_encode_count(void)::last_encode_count);
      v7 = v5 + 1;
      v8 = v5 == -1;
    }
    while (v6);
  }
  while (v8);
  v9 = v7 | ((uint64_t)getpid() << 32);
  kdebug_trace();
  v10 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v10, "e", v9);
  if (a2)
    xpc_dictionary_set_uint64(v10, "f", a2);
  if ((a3 - 1) <= 0xFFFFFFFD)
    xpc_dictionary_set_mach_send();
  return v10;
}

CFStringRef CA::Render::key_path_copy_string(unint64_t this, void *const *a2)
{
  unint64_t v2;
  CFIndex v3;
  size_t v4;
  const void **v5;
  unsigned int *v6;
  CFIndex v7;
  const void **v8;
  unsigned int v9;
  unsigned int v10;
  const __CFString *String;
  void *v12;
  const __CFArray *v13;
  const void *v14;
  unint64_t v16;
  const __CFString *v17;
  _QWORD v18[2];

  v2 = this;
  v18[1] = *MEMORY[0x1E0C80C00];
  if (!this)
    return (CFStringRef)v2;
  if ((this & 1) == 0)
  {
    v3 = *(unsigned int *)this;
    MEMORY[0x1E0C80A78](this);
    v5 = (const void **)((char *)v18 - ((v4 + 15) & 0xFFFFFFFF0));
    bzero(v5, v4);
    if ((_DWORD)v3)
    {
      v6 = (unsigned int *)(v2 + 4);
      v7 = v3;
      v8 = v5;
      do
      {
        v10 = *v6++;
        v9 = v10;
        if ((v10 & 0x40000000) != 0)
        {
          v12 = (void *)CFStringCreateWithFormat(0, 0, CFSTR("@index(%d)"), v9 & 0xBFFFFFFF);
        }
        else
        {
          String = CAAtomGetString(v9);
          v12 = (void *)CFRetain(String);
        }
        *v8++ = v12;
        --v7;
      }
      while (v7);
    }
    v13 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE18], v5, v3, 0);
    v2 = (unint64_t)CFStringCreateByCombiningStrings(0, v13, CFSTR("."));
    CFRelease(v13);
    if ((_DWORD)v3)
    {
      do
      {
        v14 = *v5++;
        CFRelease(v14);
        --v3;
      }
      while (v3);
    }
    return (CFStringRef)v2;
  }
  v16 = this >> 1;
  if (((v2 >> 1) & 0x40000000) != 0)
    return CFStringCreateWithFormat(0, 0, CFSTR("@index(%d)"), v16 & 0xBFFFFFFF);
  v17 = CAAtomGetString(v16);
  return (CFStringRef)CFRetain(v17);
}

void CA::Render::Path::show(CA::Render::Path *this, int a2, char a3)
{
  NSObject *v5;
  _BYTE *v6;
  CA::Render *v7;
  unsigned __int8 *v8;
  uint64_t *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  NSObject *v32;
  uint8_t buf[4];
  uint64_t v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if ((a3 & 1) == 0)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v5 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_184457000, v5, OS_LOG_TYPE_DEFAULT, "(path", buf, 2u);
      }
    }
    v6 = (_BYTE *)*((_QWORD *)this + 5);
    if (*v6 != 5)
    {
      v7 = (CA::Render *)(a2 + 1);
      v8 = v6 + 1;
      v9 = (uint64_t *)*((_QWORD *)this + 4);
      do
      {
        CA::Render::show_newline(v7);
        switch(*(v8 - 1))
        {
          case 0u:
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              v10 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_impl(&dword_184457000, v10, OS_LOG_TYPE_DEFAULT, "h", buf, 2u);
              }
            }
            break;
          case 1u:
            if (x_log_hook_p())
              goto LABEL_14;
            v11 = x_log_category_render;
            if (!os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
              goto LABEL_26;
            v12 = *v9;
            v13 = v9[1];
            *(_DWORD *)buf = 134218240;
            v34 = v12;
            v35 = 2048;
            v36 = v13;
            v14 = v11;
            v15 = "%g %g m";
            goto LABEL_25;
          case 2u:
            if (x_log_hook_p())
            {
LABEL_14:
              x_log_();
            }
            else
            {
              v16 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
              {
                v17 = *v9;
                v18 = v9[1];
                *(_DWORD *)buf = 134218240;
                v34 = v17;
                v35 = 2048;
                v36 = v18;
                v14 = v16;
                v15 = "%g %g l";
LABEL_25:
                _os_log_impl(&dword_184457000, v14, OS_LOG_TYPE_DEFAULT, v15, buf, 0x16u);
              }
            }
LABEL_26:
            v9 += 2;
            break;
          case 3u:
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              v19 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
              {
                v20 = *v9;
                v21 = v9[1];
                v22 = v9[2];
                v23 = v9[3];
                *(_DWORD *)buf = 134218752;
                v34 = v20;
                v35 = 2048;
                v36 = v21;
                v37 = 2048;
                v38 = v22;
                v39 = 2048;
                v40 = v23;
                _os_log_impl(&dword_184457000, v19, OS_LOG_TYPE_DEFAULT, "%g %g %g %g q", buf, 0x2Au);
              }
            }
            v9 += 4;
            break;
          case 4u:
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              v24 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
              {
                v25 = *v9;
                v26 = v9[1];
                v27 = v9[2];
                v28 = v9[3];
                v29 = v9[4];
                v30 = v9[5];
                *(_DWORD *)buf = 134219264;
                v34 = v25;
                v35 = 2048;
                v36 = v26;
                v37 = 2048;
                v38 = v27;
                v39 = 2048;
                v40 = v28;
                v41 = 2048;
                v42 = v29;
                v43 = 2048;
                v44 = v30;
                _os_log_impl(&dword_184457000, v24, OS_LOG_TYPE_DEFAULT, "%g %g %g %g %g %g c", buf, 0x3Eu);
              }
            }
            v9 += 6;
            break;
          default:
            break;
        }
        v31 = *v8++;
      }
      while (v31 != 5);
    }
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v32 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_184457000, v32, OS_LOG_TYPE_DEFAULT, ")", buf, 2u);
      }
    }
  }
}

uint64_t CA::Render::Path::interpolate(CA::Render::Path *this, int a2, int a3, float64x2_t *a4, float64x2_t *a5, float64x2_t *a6, long double *a7, unint64_t a8, float a9, float a10)
{
  uint64_t result;
  _BYTE *v21;
  int v22;
  float64x2_t *v24;
  float64x2_t *v25;
  _BYTE *v26;
  int v27;
  float64x2_t *v28;
  float64x2_t *v29;
  float64x2_t v30;
  float64x2_t v31;
  float64x2_t v32;
  float64x2_t v33;
  float64x2_t v34;
  float64x2_t v35;
  float64x2_t v36;
  double v37;
  float64x2_t v38;
  double v39;
  double v40;
  float64x2_t v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  uint64_t v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  uint64_t v58;
  uint64_t v59;
  double v60;
  double v61;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double v69;
  double v70;
  double v71;
  double v72;
  double v73;
  long double v77;
  int v78;
  float64x2_t *v79;
  unsigned __int8 *v80;
  int v81;
  float64x2_t v82;
  float64x2_t *v83;
  _OWORD v84[14];
  uint64_t v85;
  _OWORD v86[14];
  uint64_t v87;
  _OWORD v88[14];
  uint64_t v89;
  _OWORD v90[14];
  uint64_t v91;
  _OWORD v92[14];
  uint64_t v93;
  _OWORD v94[14];
  uint64_t v95;
  _OWORD v96[14];
  uint64_t v97;
  _OWORD v98[14];
  uint64_t v99;
  _OWORD v100[14];
  uint64_t v101;
  _OWORD v102[14];
  uint64_t v103;
  _OWORD v104[14];
  uint64_t v105;
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  if (!a3 || (result = (uint64_t)CA::Render::Path::keyframe_lengths(this)) != 0)
  {
    v21 = (_BYTE *)*((_QWORD *)this + 5);
    v22 = *v21;
    if (*v21)
      _ZF = v22 == 5;
    else
      _ZF = 1;
    if (_ZF)
      return 0;
    v24 = (float64x2_t *)*((_QWORD *)this + 4);
    v83 = a6;
    if (v22 == 1)
    {
      if (a5)
        *a5 = *v24;
      v25 = v24++;
    }
    else
    {
      v25 = 0;
    }
    v26 = v21 + 1;
    if (a2 >= 1)
    {
      v27 = 0;
      v28 = v25;
      while (2)
      {
        switch(*v26)
        {
          case 0:
            goto LABEL_19;
          case 1:
            v28 = v24;
            v25 = v24++;
            goto LABEL_20;
          case 2:
            v25 = v24++;
            goto LABEL_19;
          case 3:
            v25 = v24 + 1;
            v24 += 2;
            goto LABEL_19;
          case 4:
            v25 = v24 + 2;
            v24 += 3;
LABEL_19:
            ++v27;
LABEL_20:
            ++v26;
            if (v27 < a2)
              continue;
            if (!v25)
              return 0;
            goto LABEL_24;
          default:
            return 0;
        }
      }
    }
    v28 = v25;
    if (!v25)
    {
      return 0;
    }
    else
    {
LABEL_24:
      while (*v26 == 1)
      {
        v28 = v24;
        v25 = v24++;
        ++v26;
      }
      switch(*v26)
      {
        case 0:
          *a4 = vmlaq_n_f64(*v25, vsubq_f64(*v28, *v25), a9);
          if (a7)
            *a7 = atan2(v28->f64[1] - v25->f64[1], v28->f64[0] - v25->f64[0]);
          v29 = v28;
          if (!a8)
            goto LABEL_81;
          goto LABEL_35;
        case 2:
          *a4 = vmlaq_n_f64(*v25, vsubq_f64(*v24, *v25), a9);
          if (a7)
            *a7 = atan2(v24->f64[1] - v25->f64[1], v24->f64[0] - v25->f64[0]);
          v29 = v24;
          if (!a8)
            goto LABEL_81;
LABEL_35:
          v30 = vsubq_f64(*v29, *v25);
          goto LABEL_80;
        case 3:
          v31 = *v25;
          v32 = v24[1];
          v33 = vaddq_f64(*v24, *v24);
          v34 = (float64x2_t)vdupq_n_s64(0x3FD5555555555555uLL);
          v35 = vmulq_f64(vaddq_f64(v33, *v25), v34);
          v36 = vmulq_f64(vaddq_f64(v33, v32), v34);
          if (!a3)
            goto LABEL_74;
          goto LABEL_39;
        case 4:
          v31 = *v25;
          v35 = *v24;
          v36 = v24[1];
          v32 = v24[2];
          if (!a3)
            goto LABEL_74;
LABEL_39:
          v37 = *(double *)(*((_QWORD *)this + 8) + 8 * a2) * a9;
          v105 = 0;
          memset(v104, 0, sizeof(v104));
          v103 = 0;
          memset(v102, 0, sizeof(v102));
          v101 = 0;
          memset(v100, 0, sizeof(v100));
          v99 = 0;
          memset(v98, 0, sizeof(v98));
          v97 = 0;
          memset(v96, 0, sizeof(v96));
          v95 = 0;
          memset(v94, 0, sizeof(v94));
          v93 = 0;
          memset(v92, 0, sizeof(v92));
          v91 = 0;
          memset(v90, 0, sizeof(v90));
          memset(v88, 0, sizeof(v88));
          memset(v86, 0, sizeof(v86));
          memset(v84, 0, sizeof(v84));
          a9 = 0.0;
          v89 = 0;
          v87 = 0;
          v85 = 0;
          if (v37 == 0.0)
            goto LABEL_74;
          v38 = vsubq_f64(v32, v36);
          v39 = v36.f64[1];
          v40 = v32.f64[1];
          v41 = vsubq_f64(v35, v31);
          v42 = vaddvq_f64(vmulq_f64(v41, v41));
          v43 = vmulq_f64(v38, v38).f64[0] + (v32.f64[1] - v36.f64[1]) * (v32.f64[1] - v36.f64[1]);
          v44 = v42 <= 0.0 ? 1.79769313e308 : 1.0 / sqrt(v42);
          v45 = v44 * v42;
          v46 = v43 <= 0.0 ? 1.79769313e308 : 1.0 / sqrt(v43);
          v47 = v46 * v43;
          if (COERCE__INT64(fabs(v46 * v43 + v45)) > 0x7FEFFFFFFFFFFFFFLL)
            goto LABEL_74;
          LODWORD(v48) = 0;
          v49 = v31.f64[1];
          v50 = v35.f64[1];
          v51 = 0.0;
          v52 = v35.f64[0];
          v53 = v36.f64[0];
          v54 = v32.f64[0];
          v55 = v31.f64[0];
          v56 = 0.0;
          v57 = 1.0;
          break;
        default:
          return 0;
      }
      while (1)
      {
        v58 = (int)v48;
        if ((int)v48 <= 29)
          LODWORD(v48) = 29;
        if (v58 <= 29)
          v59 = 29;
        else
          v59 = v58;
        while (1)
        {
          v60 = (v53 - v52) * (v53 - v52) + (v39 - v50) * (v39 - v50);
          v61 = v60 <= 0.0 ? 1.79769313e308 : 1.0 / sqrt(v60);
          v62 = (v40 - v49) * (v40 - v49) + (v54 - v55) * (v54 - v55);
          v63 = v62 <= 0.0 ? 1.79769313e308 : 1.0 / sqrt(v62);
          v64 = v61 * v60;
          v65 = v63 * v62;
          v66 = v47 + v45 + v64;
          if (v59 == v58)
            break;
          v67 = vabdd_f64(v45, v64) + vabdd_f64(v64, v47);
          if (v66 - v65 <= v57 && v67 < 1.0)
          {
            LODWORD(v48) = v58;
            break;
          }
          v57 = v57 * 0.5;
          *((double *)v84 + v58) = v57;
          *((double *)v98 + v58) = v54;
          *((double *)v86 + v58) = v40;
          *((double *)v100 + v58) = (v54 + v53) * 0.5;
          *((double *)v88 + v58) = (v40 + v39) * 0.5;
          *((double *)v102 + v58) = (v52 + v53 * 2.0 + v54) * 0.25;
          *((double *)v90 + v58) = (v50 + v39 * 2.0 + v40) * 0.25;
          v54 = (v54 + (v53 + v52) * 3.0 + v55) * 0.125;
          *((double *)v104 + v58) = v54;
          v40 = (v49 + (v39 + v50) * 3.0 + v40) * 0.125;
          *((double *)v92 + v58) = v40;
          v53 = (v53 + v52 * 2.0 + v55) * 0.25;
          *((double *)v94 + v58) = v47 * 0.5;
          v39 = (v49 + v50 * 2.0 + v39) * 0.25;
          v69 = (v40 - v39) * (v40 - v39) + (v54 - v53) * (v54 - v53);
          if (v69 <= 0.0)
            v70 = 1.79769313e308;
          else
            v70 = 1.0 / sqrt(v69);
          v52 = (v55 + v52) * 0.5;
          v50 = (v50 + v49) * 0.5;
          v45 = v45 * 0.5;
          v47 = v70 * v69;
          *((double *)v96 + v58++) = v47;
        }
        v71 = (v65 + v66) * 0.5;
        v72 = v71 + v51;
        if (v71 + v51 >= v37)
        {
          a9 = fmin(v57 * (v37 - v51) / v71 + v56, 1.0);
          goto LABEL_74;
        }
        if (!(_DWORD)v48)
          break;
        v48 = (int)v48 - 1;
        v56 = v57 + v56;
        v55 = *((double *)v104 + v48);
        v49 = *((double *)v92 + v48);
        v52 = *((double *)v102 + v48);
        v50 = *((double *)v90 + v48);
        v53 = *((double *)v100 + v48);
        v39 = *((double *)v88 + v48);
        v54 = *((double *)v98 + v48);
        v40 = *((double *)v86 + v48);
        v45 = *((double *)v96 + v48);
        v51 = v72;
        v47 = *((double *)v94 + v48);
        v57 = *((double *)v84 + v48);
      }
      a9 = 1.0;
LABEL_74:
      v73 = 1.0 - a9;
      *a4 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v32, a9 * a9 * a9), v35, v73 * v73 * (a9 * 3.0)), v31, v73 * v73 * v73), v36, a9 * 3.0 * a9 * v73);
      if ((unint64_t)a7 | a8)
      {
        __asm { FMOV            V16.2D, #3.0 }
        v30 = vmlaq_n_f64(vmlaq_n_f64(vmulq_f64(vsubq_f64(v35, v31), _Q16), vaddq_f64(vsubq_f64(v36, vaddq_f64(v35, v35)), v31), a9 * 6.0), vmlaq_f64(vsubq_f64(v32, v31), _Q16, vsubq_f64(v35, v36)), a9 * a9 * 3.0);
        if (a7)
        {
          v82 = v30;
          v77 = atan2(v30.f64[1], v30.f64[0]);
          v30 = v82;
          *a7 = v77;
        }
        if (a3)
          v30 = vmulq_n_f64(v30, *(double *)(*((_QWORD *)this + 8) + 8 * a2) / sqrt(vaddvq_f64(vmulq_f64(v30, v30))));
        if (a8)
LABEL_80:
          *(float64x2_t *)a8 = vmulq_n_f64(v30, a10);
      }
LABEL_81:
      if (v83)
      {
        v78 = *v26;
        if (v78 == 5)
        {
          v79 = v83;
        }
        else
        {
          v80 = v26 + 1;
          v79 = v83;
          do
          {
            switch(v78)
            {
              case 0:
                v25 = v28;
                break;
              case 1:
                v28 = v24;
                goto LABEL_88;
              case 2:
LABEL_88:
                v25 = v24++;
                break;
              case 3:
                v25 = v24 + 1;
                v24 += 2;
                break;
              case 4:
                v25 = v24 + 2;
                v24 += 3;
                break;
              default:
                break;
            }
            v81 = *v80++;
            v78 = v81;
          }
          while (v81 != 5);
        }
        *v79 = *v25;
      }
      return 1;
    }
  }
  return result;
}

void std::vector<unsigned char>::push_back[abi:nn180100](unint64_t *a1, char a2)
{
  unint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  unint64_t v9;
  unint64_t v10;
  size_t v11;
  unint64_t v12;
  char *v13;
  _BYTE *v14;
  char v15;

  v5 = (_BYTE *)a1[1];
  v4 = a1[2];
  if ((unint64_t)v5 >= v4)
  {
    v7 = *a1;
    v8 = &v5[-*a1];
    v9 = (unint64_t)(v8 + 1);
    if ((uint64_t)(v8 + 1) < 0)
      abort();
    v10 = v4 - v7;
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
      v12 = (unint64_t)operator new(v11);
    else
      v12 = 0;
    v13 = (char *)(v12 + v11);
    v8[v12] = a2;
    v6 = (uint64_t)&v8[v12 + 1];
    if (v5 == (_BYTE *)v7)
    {
      v12 += (unint64_t)v8;
    }
    else
    {
      v14 = &v5[~v7];
      do
      {
        v15 = *--v5;
        (v14--)[v12] = v15;
      }
      while (v5 != (_BYTE *)v7);
      v5 = (_BYTE *)*a1;
    }
    *a1 = v12;
    a1[1] = v6;
    a1[2] = (unint64_t)v13;
    if (v5)
      operator delete(v5);
  }
  else
  {
    *v5 = a2;
    v6 = (uint64_t)(v5 + 1);
  }
  a1[1] = v6;
}

float64x2_t CA::Render::point_interpolate(float64x2_t *this, double *a2, const double *a3, const double *a4, float64x2_t a5, float64x2_t a6, double a7, double a8, double a9)
{
  float v9;
  float v10;
  float32x2_t v11;
  float32x2_t v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  int32x2_t v25;
  float v26;
  float32x2_t v27;
  float64x2_t result;

  v9 = a8;
  if (v9 < -3.1416 || v9 > 3.1416)
    v9 = (float)((float)((float)((float)(v9 * 0.15915) + 0.5) - floorf((float)(v9 * 0.15915) + 0.5)) * 6.2832) + -3.1416;
  v10 = a9;
  if (v10 < -3.1416 || v10 > 3.1416)
    v10 = (float)((float)((float)((float)(v10 * 0.15915) + 0.5) - floorf((float)(v10 * 0.15915) + 0.5)) * 6.2832)
        + -3.1416;
  v11 = vcvt_f32_f64(a6);
  v12 = vcvt_f32_f64(a5);
  v13 = (float)((float)((float)((float)(0.039228 - (float)((float)(v9 * v9) * 0.00096967)) * (float)(v9 * v9)) + -0.49535)
              * (float)(v9 * v9))
      + 0.99861;
  v14 = 1.0 - a7;
  v15 = v14 * v14;
  v16 = a7 * (v14 + v14);
  v17 = vsub_f32(v11, v12);
  v18 = vmul_n_f32((float32x2_t)vrev64_s32((int32x2_t)v17), (float)((float)((float)((float)((float)(v9 * v9) * 0.0054654) + -0.15346) * (float)(v9 * v9)) + 0.98442) * v9);
  v19 = vmul_n_f32(v17, (float)((float)((float)((float)(0.039228 - (float)((float)(v10 * v10) * 0.00096967)) * (float)(v10 * v10))+ -0.49535)* (float)(v10 * v10))+ 0.99861);
  v20 = vsub_f32(v19, v18);
  v21 = (float32x2_t)vdup_lane_s32((int32x2_t)v20, 0);
  v20.i32[1] = vadd_f32(v19, v18).i32[1];
  v22 = vsub_f32(v12, v11);
  v23 = vmul_n_f32((float32x2_t)vrev64_s32((int32x2_t)v22), (float)((float)((float)((float)((float)(v10 * v10) * 0.0054654) + -0.15346) * (float)(v10 * v10)) + 0.98442)* v10);
  v24 = vmul_n_f32(v22, v13);
  v25.i32[0] = vsub_f32(v24, v23).u32[0];
  v25.i32[1] = vadd_f32(v24, v23).i32[1];
  v26 = a7 * a7;
  v21.i32[0] = v22.i32[1];
  v22.i32[1] = v20.i32[1];
  v27 = vmla_f32(vneg_f32(vmul_f32(v22, (float32x2_t)vrev64_s32(v25))), (float32x2_t)v25, v21);
  result = vcvtq_f64_f32(vmla_n_f32(vmla_n_f32(vmul_n_f32(v12, v15), v11, v26), vmla_n_f32(v12, v20, vdiv_f32(v27, (float32x2_t)vdup_lane_s32((int32x2_t)v27, 1)).f32[0]), v16));
  *this = result;
  return result;
}

uint64_t CA::Render::InterpolatedFunction::function_type(CA::Render::InterpolatedFunction *this)
{
  return 2;
}

uint64_t CA::Render::InterpolatedFunction::input_count(CA::Render::InterpolatedFunction *this)
{
  return 1;
}

uint64_t CA::Render::InterpolatedFunction::output_count(CA::Render::InterpolatedFunction *this)
{
  return *((unsigned int *)this + 6);
}

uint64_t CA::Render::Function::name(CA::Render::Function *this)
{
  return 0xFFFFFFFFLL;
}

BOOL CA::Render::InterpolatedFunction::apply(CA::Render::InterpolatedFunction *this, uint64_t a2, const double *a3, uint64_t a4, double *a5, uint64_t a6, double (*a7)(unsigned int, const unsigned int *, unint64_t, void *), void *a8)
{
  unint64_t v8;
  size_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  float v25;
  float *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  float v31;
  unint64_t v32;
  const void *v33;
  uint64_t v34;
  float *v35;
  float *v36;
  float *v37;
  float v38;
  float v39;
  float v40;
  float *v41;
  float v42;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v8 = *((unsigned int *)this + 6);
  if (v8 <= 0x40)
  {
    MEMORY[0x1E0C80A78](this);
    v15 = (char *)&v44 - ((v14 + 15) & 0x7FFFFFFF0);
    v46 = v16;
    bzero(v15, v14);
    v17 = v46;
    if (a2)
    {
      v18 = 0;
      v19 = *((_QWORD *)this + 2);
      v44 = v19 - 1;
      v45 = v19 - 2;
      v20 = v8;
      v21 = v8;
      v22 = v8;
      v23 = v8;
      v24 = v8;
      while (1)
      {
        if (v19 < 2)
          goto LABEL_40;
        v25 = *a3;
        v26 = (float *)*((_QWORD *)this + 5);
        if (!v26)
          break;
        if (*v26 < v25)
        {
          if ((*((_BYTE *)this + 13) & 1) != 0)
          {
            v27 = 1;
            if (v45 >= 3)
            {
              v28 = v44;
              v29 = v45;
              v27 = 1;
              do
              {
                v30 = v27 + (v29 >> 1);
                if (v26[v30] <= v25)
                  v27 = v30;
                else
                  v28 = v30;
                v29 = v28 - v27;
              }
              while (v28 - v27 > 2);
            }
          }
          else
          {
            v27 = 1;
          }
          if (v27 < v19)
          {
            while (v26[v27] <= v25)
            {
              if (v19 == ++v27)
              {
                v32 = v44;
                goto LABEL_32;
              }
            }
          }
          v32 = v27 - 1;
          if (v27 == v19)
          {
LABEL_32:
            if (v23)
            {
              v33 = (const void *)(*((_QWORD *)this + 4) + 4 * v32 * v23);
              v24 = v23;
LABEL_34:
              memmove(v15, v33, 4 * v24);
              v17 = v46;
LABEL_40:
              v20 = 0;
              if (v8)
              {
                v41 = (float *)v15;
                do
                {
                  v42 = *v41++;
                  *(double *)((char *)a5 + v20) = v42;
                  v20 += 8;
                }
                while (8 * v8 != v20);
                v20 = v8;
                v21 = v8;
                v22 = v8;
                v23 = v8;
                v24 = v8;
                goto LABEL_48;
              }
LABEL_44:
              v21 = 0;
LABEL_45:
              v22 = 0;
LABEL_46:
              v23 = 0;
            }
            v24 = 0;
            goto LABEL_48;
          }
          v25 = (float)(v25 - v26[v32]) / (float)(v26[v27] - v26[v32]);
          if (!v20)
            goto LABEL_44;
          goto LABEL_38;
        }
        if (v24)
        {
          v33 = (const void *)*((_QWORD *)this + 4);
          goto LABEL_34;
        }
LABEL_48:
        a3 = (const double *)((char *)a3 + a4);
        a5 = (double *)((char *)a5 + v17);
        if (++v18 == a2)
          return v8 < 0x41;
      }
      if (v25 <= 0.0)
      {
        if (v22)
        {
          v33 = (const void *)*((_QWORD *)this + 4);
          v24 = v22;
          goto LABEL_34;
        }
        goto LABEL_46;
      }
      if (v25 >= 1.0)
      {
        if (v21)
        {
          v33 = (const void *)(*((_QWORD *)this + 4) + 4 * v44 * v21);
          v24 = v21;
          goto LABEL_34;
        }
        goto LABEL_45;
      }
      if (v19 < 3)
      {
        v32 = 0;
        if (!v20)
          goto LABEL_44;
      }
      else
      {
        v31 = *((float *)this + 7) * v25;
        v32 = (unint64_t)v31;
        v25 = v31 - truncf(v31);
        if (!v20)
          goto LABEL_44;
      }
LABEL_38:
      v34 = *((_QWORD *)this + 4);
      v35 = (float *)(v34 + 4 * v32 * v20);
      v36 = (float *)(v34 + (4 * v32 + 4) * v20);
      v37 = (float *)v15;
      do
      {
        v38 = *v35++;
        v39 = v38;
        v40 = *v36++;
        *v37++ = v39 + (float)((float)(v40 - v39) * v25);
        --v20;
      }
      while (v20);
      goto LABEL_40;
    }
  }
  return v8 < 0x41;
}

void CA::Render::NamedFunction::~NamedFunction(CA::Render::NamedFunction *this, const CA::Render::Object *a2)
{
  --dword_1ECDC7C70;
  *(_QWORD *)this = off_1E1598C30;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0)
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
}

{
  malloc_zone_t *malloc_zone;

  --dword_1ECDC7C70;
  *(_QWORD *)this = off_1E1598C30;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0)
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

void CA::Render::NamedFunction::show(CA::Render::NamedFunction *this)
{
  NSObject *v2;
  char *v3;
  uint8_t buf[4];
  char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v2 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      v3 = off_1E15A6898[*((int *)this + 4)];
      *(_DWORD *)buf = 136315138;
      v5 = v3;
      _os_log_impl(&dword_184457000, v2, OS_LOG_TYPE_DEFAULT, "(function %s)", buf, 0xCu);
    }
  }
}

void CA::Render::Gradient::~Gradient(void **this)
{
  malloc_zone_t *malloc_zone;

  CA::Render::InterpolatedFunction::~InterpolatedFunction(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

uint64_t CA::Render::Gradient::function_type(CA::Render::Gradient *this)
{
  return 3;
}

uint64_t CA::Render::InterpolatedFunction::set_location(uint64_t this, unint64_t a2, float a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(this + 40);
  if (v3 && *(_QWORD *)(this + 16) > a2)
  {
    *(float *)(v3 + 4 * a2) = a3;
    if (a2)
    {
      if (*(float *)(v3 + 4 * a2 - 4) > a3)
        *(_DWORD *)(this + 12) &= ~0x100u;
    }
    *(_DWORD *)(this + 12) |= 0x200u;
  }
  return this;
}

CA::Render::Gradient *CA::Render::Gradient::Gradient(CA::Render::Gradient *this, unint64_t a2, int a3)
{
  *((_DWORD *)this + 2) = 1;
  ++dword_1ECDC7C70;
  *(_QWORD *)this = off_1E1598230;
  *((_QWORD *)this + 2) = a2;
  *((_DWORD *)this + 6) = 4;
  *((float *)this + 7) = (float)a2 + -1.0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 3) = (a3 << 8) | 0x12;
  CA::Render::InterpolatedFunction::allocate_storage(this);
  *(_QWORD *)this = off_1E15994C8;
  return this;
}

uint64_t CA::Render::Gradient::set_colors(uint64_t this, const double *a2)
{
  float32x4_t *v2;
  uint64_t v3;
  char v4;
  float64x2_t v5;
  float64x2_t v6;
  unsigned int v7;

  v2 = *(float32x4_t **)(this + 32);
  if (v2)
  {
    v3 = *(_QWORD *)(this + 16);
    if (!v3)
      goto LABEL_6;
    v4 = 1;
    do
    {
      v6 = *(float64x2_t *)a2;
      v5 = *(float64x2_t *)(a2 + 2);
      a2 += 4;
      *v2 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v6), v5);
      v4 &= v2->f32[3] >= 1.0;
      ++v2;
      --v3;
    }
    while (v3);
    if ((v4 & 1) == 0)
      v7 = *(_DWORD *)(this + 12) & 0xFFFFF7FF;
    else
LABEL_6:
      v7 = *(_DWORD *)(this + 12) | 0x800;
    *(_DWORD *)(this + 12) = v7;
  }
  return this;
}

uint64_t CA::Render::Gradient::set_color(uint64_t this, unint64_t a2, const double *a3)
{
  uint64_t v3;
  float32x4_t *v4;

  v3 = *(_QWORD *)(this + 32);
  if (v3 && *(_QWORD *)(this + 16) > a2)
  {
    v4 = (float32x4_t *)(v3 + 16 * a2);
    *v4 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)a3), *(float64x2_t *)(a3 + 2));
    if (v4->f32[3] < 1.0)
      *(_DWORD *)(this + 12) &= ~0x800u;
  }
  return this;
}

void CA::Render::Image::TiledImage::~TiledImage(CA::Render::Image::TiledImage *this)
{
  malloc_zone_t *malloc_zone;

  CA::Render::Image::TiledImage::~TiledImage(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t **i;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  v2 = 0;
  *(_QWORD *)this = off_1E1598798;
  v3 = *((_QWORD *)this + 18);
  v4 = 1 << *(_DWORD *)v3;
  do
  {
    for (i = *(uint64_t ***)(*(_QWORD *)(v3 + 16) + 8 * v2); i; i = (uint64_t **)*i)
      CA::Render::Image::TiledImage::free_tile(i[2], (unsigned int *)i[3]);
    ++v2;
  }
  while (v2 != v4);
  x_hash_table_free(*((_QWORD **)this + 18));
  --CA::Render::Object::_instance_counts[0];
  *(_QWORD *)this = off_1E1596C08;
  v6 = (unsigned int *)*((_QWORD *)this + 15);
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldaxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 16))(v6);
  }
  CA::Render::Texture::~Texture((CGColorSpaceRef *)this);
}

uint64_t CA::Render::Image::TiledImage::finalize(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;

  v2 = this + 38;
  os_unfair_lock_lock(this + 38);
  v3 = *(_QWORD *)&this[34]._os_unfair_lock_opaque;
  if (v3)
  {
    CA::Render::remove_observer(3u, v3, (uint64_t)CA::Render::Image::TiledImage::will_deallocate, (uint64_t)this);
    *(_QWORD *)&this[34]._os_unfair_lock_opaque = 0;
  }
  os_unfair_lock_unlock(v2);
  return (*(uint64_t (**)(os_unfair_lock_s *))(*(_QWORD *)&this->_os_unfair_lock_opaque + 8))(this);
}

uint64_t CA::Render::Image::TiledImage::image_format(CA::Render::Image::TiledImage *this)
{
  return *(unsigned __int8 *)(*((_QWORD *)this + 17) + 152);
}

uint64_t CA::Render::Image::TiledImage::copy_subtexture(CA::Render::Image::TiledImage *this, unsigned int a2, unsigned int a3, int a4, int a5, int a6, unsigned int a7, unsigned int a8, double a9, float *a10, unsigned int *a11)
{
  os_unfair_lock_s *v15;
  uint64_t v16;
  int v17;
  int v18;
  malloc_zone_t *malloc_zone;
  _DWORD *v20;
  unint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v25;
  _DWORD v26[4];
  unint64_t v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v27 = __PAIR64__(a3, a2);
  v28 = a4;
  v15 = (os_unfair_lock_s *)((char *)this + 152);
  os_unfair_lock_lock((os_unfair_lock_t)this + 38);
  v16 = x_hash_table_lookup(*((_QWORD *)this + 18), (uint64_t)&v27, 0);
  if (!v16)
  {
    v17 = *((_DWORD *)this + 24);
    v18 = *((_DWORD *)this + 25);
    v26[0] = v17 * a3;
    v26[1] = v18 * a4;
    v26[2] = v17;
    v26[3] = v18;
    v16 = (uint64_t)CA::Render::Image::copy_subimage(*((CA::Render::Image **)this + 17), a2, (const CA::Bounds *)v26, *((_QWORD *)this + 20), *((_BYTE *)this + 168) == 0);
    if (!v16)
    {
      os_unfair_lock_unlock(v15);
      goto LABEL_8;
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    v20 = malloc_type_zone_malloc(malloc_zone, 0xCuLL, 0x8BB15036uLL);
    v21 = v27;
    v20[2] = v28;
    *(_QWORD *)v20 = v21;
    hash_table_modify(*((int **)this + 18), (uint64_t)v20, v16, 0);
  }
  v22 = (unsigned int *)(v16 + 8);
  do
    v23 = __ldaxr(v22);
  while (__stlxr(v23 + 1, v22));
  if (!v23)
  {
    do
      v25 = __ldaxr(v22);
    while (__stlxr(v25 - 1, v22));
  }
  os_unfair_lock_unlock(v15);
  *(_DWORD *)(v16 + 36) = *(_DWORD *)(*((_QWORD *)this + 17) + 36);
LABEL_8:
  *a10 = 1.0;
  *a11 = 0;
  return v16;
}

void CA::Render::Image::TiledImage::will_deallocate(CA::Render::Image::TiledImage *this, os_unfair_lock_s *a2, void *a3, void *a4)
{
  os_unfair_lock_s *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t **i;

  v5 = a2 + 38;
  os_unfair_lock_lock(a2 + 38);
  v6 = 0;
  *(_QWORD *)&a2[34]._os_unfair_lock_opaque = 0;
  v7 = *(_QWORD *)&a2[36]._os_unfair_lock_opaque;
  v8 = 1 << *(_DWORD *)v7;
  do
  {
    for (i = *(uint64_t ***)(*(_QWORD *)(v7 + 16) + 8 * v6); i; i = (uint64_t **)*i)
      CA::Render::Image::TiledImage::free_tile(i[2], (unsigned int *)i[3]);
    ++v6;
  }
  while (v6 != v8);
  x_hash_table_remove_all(*(_QWORD **)&a2[36]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v5);
}

void CA::Render::Image::TiledImage::free_tile(void *a1, unsigned int *a2)
{
  malloc_zone_t *malloc_zone;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, a1);
  v5 = a2 + 2;
  do
  {
    v6 = __ldaxr(v5);
    v7 = v6 - 1;
  }
  while (__stlxr(v7, v5));
  if (!v7)
    (*(void (**)(unsigned int *))(*(_QWORD *)a2 + 16))(a2);
}

unint64_t CA::Render::Image::TiledImage::Key::hash(_DWORD *a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v1 = ((a1[1] << 10) ^ (*a1 << 20)) ^ a1[2];
  v2 = (~(v1 << 32) + v1) ^ ((unint64_t)(~(v1 << 32) + v1) >> 22);
  v3 = 9 * ((v2 + ~(v2 << 13)) ^ ((v2 + ~(v2 << 13)) >> 8));
  v4 = (v3 ^ (v3 >> 15)) + ~((v3 ^ (v3 >> 15)) << 27);
  return v4 ^ (v4 >> 31);
}

BOOL CA::Render::Image::TiledImage::Key::compare(_DWORD *a1, _DWORD *a2)
{
  return *a1 != *a2 || a1[1] != a2[1] || a1[2] != a2[2];
}

uint64_t CA::Render::Image::copy_tiled_texture(CA::Render::Image *this, uint64_t a2, int a3)
{
  uint64_t v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  BOOL v14;
  malloc_zone_t *malloc_zone;
  CA::Render::Texture *v16;
  int v17;
  CA::Render::Texture *v18;
  unint64_t v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v23;

  if (CA::Render::tiled_image_mutex_once[0] != -1)
    dispatch_once_f(CA::Render::tiled_image_mutex_once, 0, (dispatch_function_t)CA::Render::Image::tiled_image_mutex_init);
  pthread_mutex_lock(&CA::Render::Image::_tiled_image_lock);
  v6 = *((_QWORD *)this + 16);
  if (v6)
  {
    while (*(_QWORD *)(v6 + 160) != a2 || *(unsigned __int8 *)(v6 + 168) != a3)
    {
      v6 = *(_QWORD *)(v6 + 128);
      if (!v6)
        goto LABEL_7;
    }
    goto LABEL_31;
  }
LABEL_7:
  v7 = *((_DWORD *)this + 4);
  if (v7 >= 0x40)
    v8 = 64;
  else
    v8 = 32;
  if (v7 >= 0x40)
    v9 = 1024;
  else
    v9 = 2048;
  if (v7 <= 0x7F)
  {
    v10 = v9;
  }
  else
  {
    v8 = 128;
    v10 = 512;
  }
  if (v7 <= 0xFF)
    v11 = v8;
  else
    v11 = 256;
  if (v7 <= 0xFF)
    v12 = v10;
  else
    v12 = 256;
  while (v12 > *((_DWORD *)this + 5))
  {
    v13 = v12 >> 1;
    v11 *= 2;
    v14 = v12 > 0x41;
    v12 >>= 1;
    if (!v14)
      goto LABEL_26;
  }
  v13 = v12;
LABEL_26:
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v16 = (CA::Render::Texture *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xB0uLL, 0x743898A5uLL);
  v6 = (uint64_t)v16;
  if (v16)
  {
    v17 = *((unsigned __int8 *)this + 153);
    v18 = CA::Render::Texture::Texture(v16, *((_DWORD *)this + 4), *((_DWORD *)this + 5));
    *(_DWORD *)(v6 + 96) = v11;
    *(_DWORD *)(v6 + 100) = v13;
    *(_DWORD *)(v6 + 108) = 0;
    *(_DWORD *)(v6 + 112) = 0;
    *(_DWORD *)(v6 + 104) = v17;
    *(_QWORD *)(v6 + 120) = 0;
    *(_DWORD *)(v6 + 12) &= 0xFFFFFF00;
    ++CA::Render::Object::_instance_counts[0];
    *(_QWORD *)v6 = off_1E1598798;
    *(_QWORD *)(v6 + 136) = this;
    *(_DWORD *)(v6 + 152) = 0;
    *(_QWORD *)(v6 + 160) = a2;
    *(_BYTE *)(v6 + 168) = a3;
    CA::Render::Texture::set_colorspace(v18, *((CGColorSpace **)this + 6));
    *(_QWORD *)(v6 + 144) = x_hash_table_new_((unint64_t (*)(uint64_t))CA::Render::Image::TiledImage::Key::hash, (BOOL (*)(uint64_t, uint64_t))CA::Render::Image::TiledImage::Key::compare, 0, 0, 0, 0);
    CA::Render::add_observer(3u, *(_QWORD *)(v6 + 136), (uint64_t)CA::Render::Image::TiledImage::will_deallocate, v6, 0);
    v19 = *((unsigned __int8 *)this + 152);
    if (v19 > 0x23 || ((0xC99B4EB03uLL >> v19) & 1) == 0)
      *(_DWORD *)(v6 + 12) |= 0x1000u;
    *(_QWORD *)(v6 + 128) = *((_QWORD *)this + 16);
    *((_QWORD *)this + 16) = v6;
LABEL_31:
    v20 = (unsigned int *)(v6 + 8);
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 + 1, v20));
    if (!v21)
    {
      v6 = 0;
      do
        v23 = __ldaxr(v20);
      while (__stlxr(v23 - 1, v20));
    }
  }
  pthread_mutex_unlock(&CA::Render::Image::_tiled_image_lock);
  return v6;
}

uint64_t CA::Render::Image::tiled_image_mutex_init(CA::Render::Image *this)
{
  return x_thread_init_mutex(&CA::Render::Image::_tiled_image_lock, 1);
}

uint64_t CA::Render::Image::get_tiled_texture_size(CA::Render::Image *this, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;

  v3 = *((_DWORD *)this + 4);
  if (v3 >= 0x40)
    v4 = 64;
  else
    v4 = 32;
  if (v3 >= 0x40)
    v5 = 1024;
  else
    v5 = 2048;
  if (v3 <= 0x7F)
    v6 = v4;
  else
    v6 = 128;
  if (v3 <= 0x7F)
    v7 = v5;
  else
    v7 = 512;
  if (v3 <= 0xFF)
    v8 = v6;
  else
    v8 = 256;
  if (v3 <= 0xFF)
    v9 = v7;
  else
    v9 = 256;
  while (v9 > *((_DWORD *)this + 5))
  {
    v10 = v9 >> 1;
    v8 *= 2;
    v11 = v9 > 0x41;
    v9 >>= 1;
    if (!v11)
      goto LABEL_23;
  }
  v10 = v9;
LABEL_23:
  *a2 = v8;
  *a3 = v10;
  return 1;
}

uint64_t CAImageProviderMaxLOD(unsigned int a1, unsigned int a2)
{
  unsigned int v2;
  uint64_t result;
  BOOL v4;

  if (a1 >= a2)
    v2 = a2;
  else
    v2 = a1;
  result = 1;
  if (v2 >= 2)
  {
    do
    {
      result = (result + 1);
      v4 = v2 > 3;
      v2 >>= 1;
    }
    while (v4);
  }
  return result;
}

uint64_t CAImageProviderCreate(unsigned int a1, unsigned int a2, int a3, int a4, int a5, int a6, int a7, double a8)
{
  unsigned int v15;
  unsigned int v16;
  BOOL v17;
  int v18;
  uint64_t Instance;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  BOOL v23;
  unsigned int v24;
  char v25;
  float v26;

  if (a1 >= a2)
    v15 = a2;
  else
    v15 = a1;
  v16 = 1;
  if (v15 >= 2)
  {
    do
    {
      ++v16;
      v17 = v15 > 3;
      v15 >>= 1;
    }
    while (v17);
  }
  if (a5 - a6 <= v16)
    v18 = a5;
  else
    v18 = v16 + a6;
  if (!CAImageProviderGetTypeID::type)
    CAImageProviderGetTypeID::type = _CFRuntimeRegisterClass();
  Instance = _CFRuntimeCreateInstance();
  v20 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 240) = 0u;
    *(_OWORD *)(Instance + 256) = 0u;
    *(_OWORD *)(Instance + 208) = 0u;
    *(_OWORD *)(Instance + 224) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    do
    {
      v21 = __ldaxr(CA::Render::next_sequence(void)::sequence);
      v22 = __stlxr(v21 + 1, CA::Render::next_sequence(void)::sequence);
      v23 = __CFADD__(v21, 1);
      v24 = v21 + 1;
      v25 = v23;
    }
    while (v22 || (v25 & 1) != 0);
    *(_DWORD *)(Instance + 20) = v24;
    pthread_mutex_init((pthread_mutex_t *)(Instance + 88), 0);
    pthread_cond_init((pthread_cond_t *)(v20 + 152), 0);
    *(_QWORD *)(v20 + 200) = v20 + 200;
    *(_QWORD *)(v20 + 208) = v20 + 200;
    *(_DWORD *)(v20 + 216) = a7;
    *(_DWORD *)(v20 + 220) = a1;
    *(_DWORD *)(v20 + 224) = a2;
    *(_DWORD *)(v20 + 228) = a3;
    *(_DWORD *)(v20 + 232) = a4;
    *(_DWORD *)(v20 + 236) = v18;
    *(_DWORD *)(v20 + 240) = a6;
    v26 = a8;
    *(float *)(v20 + 244) = v26;
    *(_QWORD *)(v20 + 56) = ++CAImageProviderCreate::id;
    if (CAImageProviderCreate::once != -1)
      dispatch_once(&CAImageProviderCreate::once, &__block_literal_global_7408);
  }
  return v20;
}

uint64_t imageProviderFinalize(char *a1)
{
  void *v2;
  CA::Transaction *v3;
  _QWORD *v4;
  _QWORD *v5;

  if (*((_QWORD *)a1 + 8))
    CAImageProviderSetCallback((uint64_t)a1, 0, 0);
  v2 = (void *)*((_QWORD *)a1 + 5);
  if (v2)
    CFRelease(v2);
  v3 = CA::Transaction::ensure_compat((CA::Transaction *)v2);
  CA::Transaction::add_deleted_id(*((CA::Transaction **)v3 + 13), *((_QWORD *)a1 + 7), *((_DWORD *)a1 + 5), 0);
  CGColorRelease(*((CGColorRef *)a1 + 32));
  v4 = (_QWORD *)*((_QWORD *)a1 + 4);
  if (v4)
  {
    do
    {
      v5 = (_QWORD *)v4[1];
      free(v4);
      v4 = v5;
    }
    while (v5);
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 88));
  return pthread_cond_destroy((pthread_cond_t *)(a1 + 152));
}

CFStringRef imageProviderCopyFormatDescription(unsigned int *a1, const __CFDictionary *a2)
{
  const __CFAllocator *v4;

  v4 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, a2, CFSTR("<CAImageProvider %p: %u x %u>"), a1, a1[55], a1[56]);
}

CFStringRef imageProviderCopyDebugDescription(unsigned int *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CAImageProvider %p: %u x %u>"), a1, a1[55], a1[56]);
}

void CAImageProviderSetCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  malloc_zone_t *malloc_zone;
  _QWORD *v9;
  int v10;
  timespec v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)&provider_lock);
  v6 = *(_QWORD *)(a1 + 64);
  if (v6 == a2 && *(_QWORD *)(a1 + 72) == a3)
    goto LABEL_13;
  if (a2)
  {
    if (!v6)
    {
      v7 = provider_list;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      v9 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
      *v9 = a1;
      v9[1] = v7;
      provider_list = (uint64_t)v9;
      CFRetain((CFTypeRef)a1);
      v10 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 64) = a2;
      *(_QWORD *)(a1 + 72) = a3;
      os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
      if (v10)
        _CAImageProviderSignal(a1, *(_DWORD *)(a1 + 48));
      return;
    }
    goto LABEL_12;
  }
  if (!v6)
  {
LABEL_12:
    *(_QWORD *)(a1 + 64) = a2;
    *(_QWORD *)(a1 + 72) = a3;
LABEL_13:
    os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
    return;
  }
  provider_list = (uint64_t)x_list_remove((_QWORD *)provider_list, a1);
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = a3;
  os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 88));
  while (*(_DWORD *)(a1 + 80))
  {
    v11 = (timespec)xmmword_18474E590;
    pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 152), (pthread_mutex_t *)(a1 + 88), &v11);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 88));
  CFRelease((CFTypeRef)a1);
}

void _CAImageProviderSignal(uint64_t a1, int a2)
{
  void *v4;
  int v5;
  unsigned int v6;
  size_t v7;
  int v8[2];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)&provider_lock);
  *(_DWORD *)(a1 + 48) = a2;
  if (*(_QWORD *)(a1 + 64))
  {
    v5 = *(_DWORD *)(a1 + 216);
    if ((v5 & 2) != 0)
    {
      if (!provider_main_thread_count)
      {
        CA::call_at_time((CA *)CAImageProviderMainThread, (void (*)(double, void *))&provider_main_thread_count, 0.0, v4);
        ++provider_main_thread_count;
      }
    }
    else
    {
      if ((v5 & 4) != 0)
      {
        v6 = x_cpu_count::n_cpus;
        if (!x_cpu_count::n_cpus)
        {
          *(_QWORD *)v8 = 0x300000006;
          v7 = 4;
          sysctl(v8, 2u, &x_cpu_count::n_cpus, &v7, 0, 0);
          v6 = x_cpu_count::n_cpus;
          if (x_cpu_count::n_cpus <= 0)
          {
            v6 = 1;
            x_cpu_count::n_cpus = 1;
          }
        }
      }
      else
      {
        v6 = 1;
      }
      for (; provider_bg_thread_count < v6; ++provider_bg_thread_count)
        dispatch_async_f((dispatch_queue_t)provider_queue, &provider_bg_thread_count, (dispatch_function_t)CAImageProviderBackgroundThread);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
}

void CAImageProviderMainThread(double a1, unsigned int *a2)
{
  CAImageProviderThread(a2, 0);
}

void CAImageProviderBackgroundThread(unsigned int *a1)
{
  CAImageProviderThread(a1, 1);
}

void CAImageProviderThread(unsigned int *a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  CA::Transaction *v11;
  int *v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  pthread_mutex_t *v18;
  char v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  mach_port_t reply_port;
  mach_msg_return_t v26;
  int v27;
  BOOL v28;
  os_unfair_lock_s *v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  _OWORD *v33;
  _QWORD *v34;
  uint64_t v35;
  unsigned int v36;
  unsigned int v37;
  const void *v38;
  void *v39;
  CA::Transaction *v40;
  unint64_t StatusReg;
  void (*v43)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t);
  unsigned int v44[2];
  unsigned int v45[2];
  _BYTE msg[52];
  uint64_t v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)&provider_lock);
  *(_QWORD *)v44 = 0;
  *(_QWORD *)v45 = 0;
  v3 = &unk_1EDD14000;
  v4 = (_QWORD *)provider_list;
  if (provider_list)
  {
    v5 = 0;
    v6 = 0;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    while (1)
    {
      do
      {
        v7 = *v4;
        if (*(_DWORD *)(*v4 + 48) > v5
          && *(_QWORD *)(v7 + 64)
          && (((*(_DWORD *)(v7 + 216) >> 1) & 1) == 0) == (_DWORD)a2)
        {
          v6 = *v4;
          v5 = *(_DWORD *)(*v4 + 48);
        }
        v4 = (_QWORD *)v4[1];
      }
      while (v4);
      if (!v6)
        goto LABEL_71;
      CFRetain((CFTypeRef)v6);
      v8 = *(_QWORD *)(v6 + 72);
      v43 = *(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(v6 + 64);
      v9 = (unsigned int *)(v6 + 80);
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 + 1, v9));
      os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
      CA::Transaction::begin_transaction(v11);
      v12 = CA::Context::retain_context_with_id((CA::Context *)*(unsigned int *)(v6 + 24));
      if (!v12)
        goto LABEL_46;
      v13 = v12;
      v14 = CA::Context::retain_render_ctx((CA::Context *)v12);
      if (!v14)
        break;
      v15 = v14;
      v16 = v3;
      v17 = a2;
      v18 = (pthread_mutex_t *)(v14 + 72);
      pthread_mutex_lock((pthread_mutex_t *)(v14 + 72));
      v19 = CA::Render::ImageProvider::needed_subimage(*(CA::Render::ImageProvider **)(v15 + 136), (CA::Render::Context *)*(unsigned int *)(v15 + 148), *(_QWORD *)(v6 + 56), &v45[1], v45, &v44[1], v44);
      pthread_mutex_unlock(v18);
      v20 = (unsigned int *)(v15 + 8);
      do
      {
        v21 = __ldaxr(v20);
        v22 = v21 - 1;
      }
      while (__stlxr(v22, v20));
      a2 = v17;
      if (!v22)
        (*(void (**)(uint64_t))(*(_QWORD *)v15 + 16))(v15);
      CA::Context::unref((CA::Context *)v13, 0);
      v3 = v16;
      if ((v19 & 1) != 0)
      {
LABEL_49:
        *(_DWORD *)&msg[16] = v45[1];
        *(_DWORD *)&msg[20] = v45[0];
        *(_DWORD *)&msg[24] = v44[1];
        *(_DWORD *)&msg[28] = v44[0];
        *(_QWORD *)msg = msg;
        *(_QWORD *)&msg[8] = msg;
        os_unfair_lock_lock((os_unfair_lock_t)(v6 + 16));
        v30 = (uint64_t *)(v6 + 200);
        v31 = *(_QWORD *)(v6 + 208);
        if (v31 == v6 + 200)
        {
LABEL_54:
          v32 = *v30;
          *v30 = (uint64_t)msg;
          *(_QWORD *)msg = v32;
          *(_QWORD *)&msg[8] = v6 + 200;
          *(_QWORD *)(v32 + 8) = msg;
          os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 16));
          if ((_DWORD)a2)
          {
            v33 = *(_OWORD **)(StatusReg + 576);
            if (!v33)
              v33 = CA::Transaction::create(0);
            *((_BYTE *)v33 + 116) |= 4u;
          }
          v43(v6, v45[1], v45[0], v44[1], v44[0], v8);
          os_unfair_lock_lock((os_unfair_lock_t)(v6 + 16));
          v35 = *(_QWORD *)msg;
          v34 = *(_QWORD **)&msg[8];
          *(_QWORD *)(*(_QWORD *)msg + 8) = *(_QWORD *)&msg[8];
          *v34 = v35;
          *(_QWORD *)msg = msg;
          *(_QWORD *)&msg[8] = msg;
        }
        else
        {
          while (*(_DWORD *)&msg[16] != *(_DWORD *)(v31 + 16)
               || *(_DWORD *)&msg[20] != *(_DWORD *)(v31 + 20)
               || *(_QWORD *)&msg[24] != *(_QWORD *)(v31 + 24))
          {
            v31 = *(_QWORD *)(v31 + 8);
            if ((uint64_t *)v31 == v30)
              goto LABEL_54;
          }
        }
        v29 = (os_unfair_lock_s *)(v6 + 16);
        goto LABEL_60;
      }
LABEL_46:
      os_unfair_lock_lock((os_unfair_lock_t)(v6 + 16));
      if (*(_DWORD *)(v6 + 48) == v5)
        *(_DWORD *)(v6 + 48) = 0;
      v29 = (os_unfair_lock_s *)(v6 + 16);
LABEL_60:
      os_unfair_lock_unlock(v29);
      do
      {
        v36 = __ldaxr(v9);
        v37 = v36 - 1;
      }
      while (__stlxr(v37, v9));
      if (!v37)
        pthread_cond_broadcast((pthread_cond_t *)(v6 + 152));
      CFRelease((CFTypeRef)v6);
      v39 = (void *)MEMORY[0x186DBE2E4]();
      v40 = *(CA::Transaction **)(StatusReg + 576);
      if (v40 && **((_DWORD **)v40 + 13))
        CA::Transaction::pop(v40, v38);
      objc_autoreleasePoolPop(v39);
      os_unfair_lock_lock((os_unfair_lock_t)&provider_lock);
      v5 = 0;
      v6 = 0;
      *(_QWORD *)v44 = 0;
      *(_QWORD *)v45 = 0;
      v4 = (_QWORD *)v3[18];
      if (!v4)
        goto LABEL_71;
    }
    v23 = v13[40];
    if (!v23)
    {
      CA::Context::unref((CA::Context *)v13, 0);
      goto LABEL_46;
    }
    v24 = *(_QWORD *)(v6 + 56);
    v47 = 0;
    memset(&msg[4], 0, 48);
    *(_QWORD *)&msg[24] = *MEMORY[0x1E0C804E8];
    *(_QWORD *)&msg[32] = v24;
    reply_port = mig_get_reply_port();
    *(_DWORD *)&msg[8] = v23;
    *(_DWORD *)&msg[12] = reply_port;
    *(_DWORD *)msg = 5395;
    *(_QWORD *)&msg[16] = 0x9D5300000000;
    if (MEMORY[0x1E0C85B60])
    {
      voucher_mach_msg_set((mach_msg_header_t *)msg);
      reply_port = *(_DWORD *)&msg[12];
    }
    v26 = mach_msg((mach_msg_header_t *)msg, 3, 0x28u, 0x3Cu, reply_port, 0, 0);
    v27 = v26;
    if ((v26 - 268435458) <= 0xE && ((1 << (v26 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(*(mach_port_t *)&msg[12]);
      goto LABEL_45;
    }
    if (v26)
    {
      mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
      goto LABEL_44;
    }
    if (*(_DWORD *)&msg[20] == 71)
    {
      v27 = -308;
    }
    else if (*(_DWORD *)&msg[20] == 40375)
    {
      if ((*(_DWORD *)msg & 0x80000000) == 0)
      {
        if (*(_DWORD *)&msg[4] == 52)
        {
          if (!*(_DWORD *)&msg[8])
          {
            v27 = *(_DWORD *)&msg[32];
            if (!*(_DWORD *)&msg[32])
            {
              v45[0] = *(_DWORD *)&msg[40];
              v45[1] = *(_DWORD *)&msg[36];
              v44[0] = *(_DWORD *)&msg[48];
              v44[1] = *(_DWORD *)&msg[44];
              goto LABEL_45;
            }
            goto LABEL_43;
          }
        }
        else if (*(_DWORD *)&msg[4] == 36)
        {
          if (*(_DWORD *)&msg[8])
            v28 = 1;
          else
            v28 = *(_DWORD *)&msg[32] == 0;
          if (v28)
            v27 = -300;
          else
            v27 = *(_DWORD *)&msg[32];
          goto LABEL_43;
        }
      }
      v27 = -300;
    }
    else
    {
      v27 = -301;
    }
LABEL_43:
    mach_msg_destroy((mach_msg_header_t *)msg);
LABEL_44:
    if (v27 == -81182719)
    {
      x_log_crash("Unentitled call to server!");
      abort();
    }
LABEL_45:
    CA::Context::unref((CA::Context *)v13, 0);
    if (!v27)
      goto LABEL_49;
    goto LABEL_46;
  }
LABEL_71:
  --*a1;
  os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
}

uint64_t CAImageProviderGetTypeID()
{
  uint64_t result;

  result = CAImageProviderGetTypeID::type;
  if (!CAImageProviderGetTypeID::type)
  {
    result = _CFRuntimeRegisterClass();
    CAImageProviderGetTypeID::type = result;
  }
  return result;
}

uint64_t CAImageProviderGetFlags(uint64_t a1)
{
  return *(unsigned int *)(a1 + 216);
}

void CAImageProviderSetImageSize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFArrayRef cfarray;
  const void *v5;

  if (*(_DWORD *)(a1 + 220) != (_DWORD)a2 || *(_DWORD *)(a1 + 224) != (_DWORD)a3)
  {
    *(_DWORD *)(a1 + 220) = a2;
    *(_DWORD *)(a1 + 224) = a3;
    if (*(_DWORD *)(a1 + 24))
    {
      cfarray = create_cfarray(2, a2, a2, 2, a3, 0);
      CA::Transaction::add_command((CA::Transaction *)0x10, *(_DWORD *)(a1 + 24), *(_QWORD *)(a1 + 56), cfarray, v5);
      CFRelease(cfarray);
    }
  }
}

CFArrayRef create_cfarray(int a1, uint64_t a2, ...)
{
  unsigned int v2;
  CFIndex v3;
  void *v4;
  void **v5;
  void **v6;
  void *v7;
  void **v8;
  CFArrayRef v9;
  uint64_t i;
  int valuePtr;
  void **v13;
  void *values[2];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;

  v2 = 0;
  v3 = 0;
  v30 = *MEMORY[0x1E0C80C00];
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  *(_OWORD *)values = 0u;
  v15 = 0u;
  valuePtr = 0;
  v13 = (void **)&a2;
  v4 = (void *)*MEMORY[0x1E0C9B0D0];
  while (1)
  {
    if (a1 == 1)
    {
      v6 = v13++;
      v7 = *v6;
      if (!v7)
        v7 = v4;
      values[v3] = v7;
      goto LABEL_10;
    }
    if (a1 != 2)
      break;
    v5 = v13++;
    valuePtr = *(_DWORD *)v5;
    v2 |= 1 << v3;
    values[v3] = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
LABEL_10:
    ++v3;
LABEL_11:
    v8 = v13++;
    a1 = *(_DWORD *)v8;
  }
  if (a1)
    goto LABEL_11;
  v9 = CFArrayCreate(0, (const void **)values, v3, MEMORY[0x1E0C9B378]);
  if (v3)
  {
    for (i = 0; i != v3; ++i)
    {
      if (((v2 >> i) & 1) != 0)
        CFRelease(values[i]);
    }
  }
  return v9;
}

uint64_t CAImageProviderGetImageWidth(uint64_t a1)
{
  return *(unsigned int *)(a1 + 220);
}

uint64_t CAImageProviderGetImageHeight(uint64_t a1)
{
  return *(unsigned int *)(a1 + 224);
}

uint64_t CAImageProviderGetSubImageWidth(uint64_t a1)
{
  return *(unsigned int *)(a1 + 228);
}

uint64_t CAImageProviderGetSubImageHeight(uint64_t a1)
{
  return *(unsigned int *)(a1 + 232);
}

uint64_t CAImageProviderGetLODCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 236);
}

uint64_t CAImageProviderGetLODBias(uint64_t a1)
{
  return *(unsigned int *)(a1 + 240);
}

uint64_t CAImageProviderGetLODWidth(_DWORD *a1, unsigned int a2)
{
  unsigned int v2;
  int v3;

  if (a1[59] <= a2)
    return 0;
  v2 = a1[55];
  v3 = a2 - a1[60];
  if (v3 < 0)
    return v2 << (*((_BYTE *)a1 + 240) - a2);
  else
    return v2 >> v3;
}

uint64_t CAImageProviderGetLODHeight(_DWORD *a1, unsigned int a2)
{
  unsigned int v2;
  int v3;

  if (a1[59] <= a2)
    return 0;
  v2 = a1[56];
  v3 = a2 - a1[60];
  if (v3 < 0)
    return v2 << (*((_BYTE *)a1 + 240) - a2);
  else
    return v2 >> v3;
}

float64x2_t CAImageProviderGetLODScale(uint64_t a1, unsigned int a2)
{
  uint32x2_t v2;
  int8x8_t v3;
  uint64x2_t v4;
  float64x2_t v5;

  if (*(_DWORD *)(a1 + 236) <= a2)
  {
    return *(float64x2_t *)MEMORY[0x1E0C9D820];
  }
  else
  {
    v2 = *(uint32x2_t *)(a1 + 220);
    v3 = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32((int)(a2 - *(_DWORD *)(a1 + 240)) < 0), 0x1FuLL)), (int8x8_t)vshl_u32(v2, (uint32x2_t)vdup_n_s32(*(_DWORD *)(a1 + 240) - a2)), (int8x8_t)vshl_u32(v2, (uint32x2_t)vneg_s32(vdup_n_s32(a2 - *(_DWORD *)(a1 + 240)))));
    v4.i64[0] = v3.u32[0];
    v4.i64[1] = v3.u32[1];
    v5 = vcvtq_f64_u64(v4);
    v4.i64[0] = v2.u32[0];
    v4.i64[1] = v2.u32[1];
    return vdivq_f64(v5, vcvtq_f64_u64(v4));
  }
}

void CAImageProviderSetSubImageWithSeed(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  CFArrayRef cfarray;
  const void *v9;
  CFArrayRef v10;
  int v11;
  CA::Transaction *v12;
  int v13;
  __CFArray *Mutable;

  cfarray = create_cfarray(2, a2, a2, 2, a3, 2, a4, 1, a5, 2, a6, 2, a7, 0);
  v10 = cfarray;
  v11 = *(_DWORD *)(a1 + 24);
  if (v11)
  {
    CA::Transaction::add_command((CA::Transaction *)0x13, v11, *(_QWORD *)(a1 + 56), cfarray, v9);
  }
  else
  {
    v12 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
    if (!v12)
      v12 = (CA::Transaction *)CA::Transaction::create(cfarray);
    v13 = *((_DWORD *)v12 + 25);
    *((_DWORD *)v12 + 25) = v13 + 1;
    if (!v13)
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
    Mutable = *(__CFArray **)(a1 + 40);
    if (!Mutable)
    {
      Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      *(_QWORD *)(a1 + 40) = Mutable;
    }
    CFArrayAppendValue(Mutable, v10);
    CA::Transaction::unlock(v12);
  }
  CFRelease(v10);
  CAImageProviderChanged(a1);
}

void CAImageProviderChanged(uint64_t a1)
{
  os_unfair_lock_s *v2;
  CFTypeRef v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  int v7;
  uint64_t v8;
  const void *v9;
  _QWORD v10[2];

  v10[1] = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 32))
  {
    v2 = (os_unfair_lock_s *)(a1 + 16);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
    v4 = *(_QWORD *)(a1 + 32);
    if (v4)
    {
      v5 = 0;
      do
      {
        v6 = v5;
        MEMORY[0x1E0C80A78](v3);
        v5 = &v10[-2];
        v10[-2] = 0;
        v10[-1] = 0;
        v3 = CFRetain(*(CFTypeRef *)v4);
        v10[-2] = v3;
        v10[-1] = v6;
        v4 = *(_QWORD *)(v4 + 8);
      }
      while (v4);
      os_unfair_lock_unlock(v2);
      do
      {
        v7 = *(_DWORD *)(a1 + 24);
        v8 = CA::Render::Object::render_id(*(CA::Render::Object **)(*v5 + 16));
        CA::Transaction::add_command((CA::Transaction *)2, v7, v8, 0, v9);
        CFRelease((CFTypeRef)*v5);
        v5 = (_QWORD *)v5[1];
      }
      while (v5);
    }
    else
    {
      os_unfair_lock_unlock(v2);
    }
  }
}

void CAImageProviderSetSubImage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CAImageProviderSetSubImageWithSeed(a1, a2, a3, a4, a5, a6, 0);
}

void CAImageProviderInvalidate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CAImageProviderInvalidateLOD(a1, a2, a3, a4, a5, 0xFFFFFFFFLL, 0);
}

void CAImageProviderInvalidateLOD(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  CA::Transaction *v14;
  int v15;
  const void *v16;
  uint64_t v17;
  CFArrayRef cfarray;
  const void *v19;

  v14 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (!v14)
    v14 = (CA::Transaction *)CA::Transaction::create((CA::Transaction *)a1);
  v15 = *((_DWORD *)v14 + 25);
  *((_DWORD *)v14 + 25) = v15 + 1;
  if (!v15)
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  v16 = *(const void **)(a1 + 40);
  *(_QWORD *)(a1 + 40) = 0;
  CA::Transaction::unlock(v14);
  if (v16)
    CFRelease(v16);
  if (*(_DWORD *)(a1 + 24))
  {
    cfarray = create_cfarray(2, v17, a2, 2, a3, 2, a4, 2, a5, 2, a6, 2, a7, 0);
    CA::Transaction::add_command((CA::Transaction *)0x14, *(_DWORD *)(a1 + 24), *(_QWORD *)(a1 + 56), cfarray, v19);
    CFRelease(cfarray);
  }
}

void CAImageProviderDraw(uint64_t a1, int a2, int a3, int a4, int a5, int a6)
{
  unsigned int v7;
  unsigned int v8;
  signed int v9;
  signed int v10;
  int v11;
  int v12;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  unsigned int v20;
  int v21;
  int i;
  void (*v23)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD);
  unsigned int *v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  BOOL v28;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  int v34;

  if (*(_QWORD *)(a1 + 64))
  {
    v7 = a2 & ~(a2 >> 31);
    v8 = a3 & ~(a3 >> 31);
    v9 = *(_DWORD *)(a1 + 220);
    v10 = *(_DWORD *)(a1 + 224);
    v11 = v9 - v7;
    if ((int)((a2 & (a2 >> 31)) + a4 + v7) <= v9)
      v11 = (a2 & (a2 >> 31)) + a4;
    if ((int)((a3 & (a3 >> 31)) + a5 + v8) <= v10)
      v12 = (a3 & (a3 >> 31)) + a5;
    else
      v12 = v10 - v8;
    if (v11 >= 1 && v12 >= 1)
    {
      v15 = *(_DWORD *)(a1 + 228);
      v16 = *(_DWORD *)(a1 + 232);
      v17 = v7 / v15;
      v18 = v8 / v16;
      v19 = (v7 + v11 - 1) / v15;
      v20 = v8 + v12 - 1;
      v21 = *(_DWORD *)(a1 + 240);
      for (i = v20 / v16; v21; --v21)
      {
        v17 = (2 * v17);
        v18 = (2 * v18);
        v19 = (2 * v19) | 1;
        i = (2 * i) | 1;
      }
      os_unfair_lock_lock((os_unfair_lock_t)&provider_lock);
      v23 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(a1 + 64);
      v24 = (unsigned int *)(a1 + 80);
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 + 1, v24));
      if (v23)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
        v26 = *(_DWORD *)(a1 + 236);
        if (v26)
        {
          v27 = 0;
          v34 = a6;
          do
          {
            v28 = (_DWORD)v27 == a6 || a6 == -1;
            if (v28 && (int)v18 <= i)
            {
              v30 = v18;
              do
              {
                v31 = v17;
                if ((int)v17 <= v19)
                {
                  do
                  {
                    v23(a1, v27, v31, v30, 0, *(_QWORD *)(a1 + 72));
                    v31 = (v31 + 1);
                  }
                  while (v19 + 1 != (_DWORD)v31);
                }
                v28 = (_DWORD)v30 == i;
                v30 = (v30 + 1);
              }
              while (!v28);
              v26 = *(_DWORD *)(a1 + 236);
              a6 = v34;
            }
            v17 = ((int)v17 >> 1);
            v18 = ((int)v18 >> 1);
            v19 >>= 1;
            i >>= 1;
            v27 = (v27 + 1);
          }
          while (v27 < v26);
        }
        os_unfair_lock_lock((os_unfair_lock_t)&provider_lock);
        v24 = (unsigned int *)(a1 + 80);
      }
      do
      {
        v32 = __ldaxr(v24);
        v33 = v32 - 1;
      }
      while (__stlxr(v33, v24));
      if (!v33)
        pthread_cond_broadcast((pthread_cond_t *)(a1 + 152));
      os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
    }
  }
}

_DWORD *CAImageProviderCopyRenderValue(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t StatusReg;
  uint64_t v4;
  uint64_t v5;
  __CFString *cfarray;
  void *v8;
  CA::Transaction *v9;
  CA::Transaction *v10;
  int v11;
  const __CFArray *v12;
  uint64_t v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex i;
  CA::Render::Encoder *v17;
  __CFString *ValueAtIndex;
  void *v19;
  __CFString *v20;
  void *v21;
  malloc_zone_t *malloc_zone;
  _DWORD *result;
  uint64_t v24;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v4 = *(_QWORD *)(StatusReg + 576);
  if (!v4)
    return 0;
  v5 = *(_QWORD *)(v4 + 40);
  if (!v5 || !*(_QWORD *)(v5 + 208))
    return 0;
  if (*(_DWORD *)(a1 + 24) != *(_DWORD *)(v5 + 8))
  {
    LODWORD(v2) = vcvtd_n_s64_f64(*(float *)(a1 + 244), 0x10uLL);
    cfarray = (__CFString *)create_cfarray(2, a2, *(unsigned int *)(a1 + 20), 2, *(unsigned int *)(a1 + 220), 2, *(unsigned int *)(a1 + 224), 2, *(unsigned int *)(a1 + 228), 2, *(unsigned int *)(a1 + 232), 2, *(unsigned int *)(a1 + 236), 2, *(unsigned int *)(a1 + 240), 2, *(_DWORD *)(a1 + 216) & 1, 2, v2,
                              2,
                              *(unsigned int *)(a1 + 248),
                              1,
                              *(_QWORD *)(a1 + 256),
                              0);
    CA::Context::commit_command((CA::Context *)0xF, *(CA::Render::Encoder **)(a1 + 56), cfarray, *(const void **)(v5 + 208), v8);
    CFRelease(cfarray);
    v10 = *(CA::Transaction **)(StatusReg + 576);
    if (!v10)
      v10 = (CA::Transaction *)CA::Transaction::create(v9);
    v11 = *((_DWORD *)v10 + 25);
    *((_DWORD *)v10 + 25) = v11 + 1;
    if (!v11)
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
    v12 = *(const __CFArray **)(a1 + 40);
    *(_QWORD *)(a1 + 40) = 0;
    CA::Transaction::unlock(v10);
    if (v12)
    {
      Count = CFArrayGetCount(v12);
      if (Count)
      {
        v15 = Count;
        for (i = 0; i != v15; ++i)
        {
          v17 = *(CA::Render::Encoder **)(a1 + 56);
          ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(v12, i);
          CA::Context::commit_command((CA::Context *)0x13, v17, ValueAtIndex, *(const void **)(v5 + 208), v19);
        }
      }
      CFRelease(v12);
    }
    if (*(_DWORD *)(a1 + 264))
    {
      v20 = (__CFString *)create_cfarray(2, v13, *(unsigned int *)(a1 + 264), 0);
      CA::Context::commit_command((CA::Context *)0x12, *(CA::Render::Encoder **)(a1 + 56), v20, *(const void **)(v5 + 208), v21);
      CFRelease(v20);
    }
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(v5 + 8);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  result = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x18uLL, 0x743898A5uLL);
  if (result)
  {
    v24 = *(_QWORD *)(a1 + 56);
    result[2] = 1;
    ++dword_1ECDC7CD4;
    *(_QWORD *)result = off_1E1598A58;
    *((_QWORD *)result + 2) = v24;
    result[3] = 299;
  }
  return result;
}

void CAImageProviderRemoveLayer(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  *(_QWORD *)(a1 + 32) = x_list_remove(*(_QWORD **)(a1 + 32), a2);
  os_unfair_lock_unlock(v4);
}

void CAImageProviderSignal(uint64_t a1, int a2)
{
  CFTypeRef *v4;
  CFTypeRef v5;

  os_unfair_lock_lock((os_unfair_lock_t)&provider_lock);
  v4 = (CFTypeRef *)provider_list;
  if (provider_list)
  {
    while (1)
    {
      v5 = *v4;
      if (*((_QWORD *)*v4 + 7) == a1)
        break;
      v4 = (CFTypeRef *)v4[1];
      if (!v4)
        goto LABEL_4;
    }
    CFRetain(*v4);
    os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
    _CAImageProviderSignal((uint64_t)v5, a2);
    CFRelease(v5);
  }
  else
  {
LABEL_4:
    os_unfair_lock_unlock((os_unfair_lock_t)&provider_lock);
  }
}

void CAImageProviderSetFillColor(uint64_t a1, CGColor *a2)
{
  CGColor *v3;
  uint64_t v5;
  CFArrayRef cfarray;
  const void *v7;

  v3 = *(CGColor **)(a1 + 256);
  if (v3 != a2)
  {
    CGColorRelease(v3);
    *(_QWORD *)(a1 + 256) = CGColorRetain(a2);
    if (*(_DWORD *)(a1 + 24))
    {
      cfarray = create_cfarray(1, v5, a2, 0);
      CA::Transaction::add_command((CA::Transaction *)0x11, *(_DWORD *)(a1 + 24), *(_QWORD *)(a1 + 56), cfarray, v7);
      CFRelease(cfarray);
    }
  }
}

uint64_t CAImageProviderGetFillColor(uint64_t a1)
{
  return *(_QWORD *)(a1 + 256);
}

void CA::CG::ColorMatrixStyle::~ColorMatrixStyle(CA::CG::Renderer **this, const void *a2)
{
  *this = (CA::CG::Renderer *)off_1E1593750;
  CA::CG::Renderer::release_object(this[2], a2);
}

{
  malloc_zone_t *malloc_zone;

  *this = (CA::CG::Renderer *)off_1E1593750;
  CA::CG::Renderer::release_object(this[2], a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

uint64_t CA::CG::ColorMatrixStyle::visit(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 24))(a2, a1);
}

_DWORD *CA::CG::ColorMatrixStyle::copy(CA::CG::ColorMatrixStyle *this)
{
  malloc_zone_t *malloc_zone;
  _DWORD *v3;
  _DWORD *v4;
  int v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v3 = malloc_type_zone_malloc(malloc_zone, 0xA0uLL, 0x8BB15036uLL);
  v4 = v3;
  if (v3)
  {
    *(_QWORD *)v3 = off_1E1593750;
    v5 = *((_DWORD *)this + 3);
    v3[2] = 0;
    v3[3] = v5;
    *((_QWORD *)v3 + 2) = CGStyleRetain();
    v6 = *(_OWORD *)((char *)this + 56);
    v7 = *(_OWORD *)((char *)this + 40);
    *(_OWORD *)(v4 + 6) = *(_OWORD *)((char *)this + 24);
    *(_OWORD *)(v4 + 10) = v7;
    *(_OWORD *)(v4 + 14) = v6;
    v4[18] = *((_DWORD *)this + 18);
    v4[2] = 1;
    *(_QWORD *)v4 = off_1E1592568;
    *(_OWORD *)(v4 + 19) = *(_OWORD *)((char *)this + 76);
    v8 = *(_OWORD *)((char *)this + 108);
    v9 = *(_OWORD *)((char *)this + 124);
    v10 = *(_OWORD *)((char *)this + 140);
    *(_OWORD *)(v4 + 23) = *(_OWORD *)((char *)this + 92);
    *(_OWORD *)(v4 + 35) = v10;
    *(_OWORD *)(v4 + 31) = v9;
    *(_OWORD *)(v4 + 27) = v8;
  }
  return v4;
}

uint64_t CA::OGL::GLContext::get(uint64_t a1, int a2)
{
  uint64_t result;

  result = 0;
  switch(a2)
  {
    case 8:
      return result;
    case 9:
    case 13:
    case 14:
      goto LABEL_5;
    case 10:
    case 11:
    case 12:
      result = 1;
      break;
    case 15:
      result = 27;
      break;
    default:
      if (a2)
LABEL_5:
        result = a2 == 28 || a2 == 16;
      else
        result = (*(uint64_t (**)(_QWORD))(MEMORY[0x820] + 824))(*MEMORY[0x820]);
      break;
  }
  return result;
}

const char *CA::OGL::GLContext::get_error_string(CA::OGL::GLContext *this, int a2)
{
  const char *v2;

  switch(a2)
  {
    case 1280:
      v2 = "GL_INVALID_ENUM";
      break;
    case 1281:
      v2 = "GL_INVALID_VALUE";
      break;
    case 1282:
      v2 = "GL_INVALID_OPERATION";
      break;
    case 1283:
      v2 = "GL_STACK_OVERFLOW";
      break;
    case 1284:
      v2 = "GL_STACK_UNDERFLOW";
      break;
    case 1285:
      v2 = "GL_OUT_OF_MEMORY";
      break;
    case 1286:
      v2 = "GL_INVALID_FRAMEBUFFER_OPERATION;";
      break;
    default:
      if (a2)
      {
        v2 = CA::OGL::Context::get_error_string(int)const::buf;
        snprintf(CA::OGL::Context::get_error_string(int)const::buf, 0xCuLL, "0x%x", a2);
      }
      else
      {
        v2 = "GL_NO_ERROR";
      }
      break;
  }
  return v2;
}

void CA::OGL::GLContext::collect(CA::OGL::GLContext *this, char a2)
{
  CA::OGL::Context::collect(this, a2);
  if ((a2 & 1) != 0 || (*((_WORD *)this + 408) & 0x400) == 0)
    (*(void (**)(CA::OGL::GLContext *))(*(_QWORD *)this + 1144))(this);
}

uint64_t CA::OGL::GLContext::purge(CA::OGL::GLContext *this, int a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *i;
  unsigned int *v9;
  malloc_zone_t *malloc_zone;
  uint64_t v11;
  char *v12;

  if (a2)
  {
    v4 = (_QWORD *)*((_QWORD *)this + 260);
    if (*((_QWORD *)this + 231))
    {
      *((_QWORD *)this + 231) = 0;
      ((void (*)(_QWORD, _QWORD))v4[601])(*v4, 0);
    }
    v5 = *((_QWORD *)this + 236);
    if (v5)
    {
      v6 = 0;
      v7 = 1 << *(_DWORD *)v5;
      do
      {
        for (i = *(_QWORD **)(*(_QWORD *)(v5 + 16) + 8 * v6); i; i = (_QWORD *)*i)
        {
          v9 = (unsigned int *)i[3];
          (*(void (**)(_QWORD, _QWORD))(*((_QWORD *)this + 260) + 4736))(**((_QWORD **)this + 260), v9[14]);
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(malloc_zone, v9);
        }
        ++v6;
      }
      while (v6 != v7);
      x_hash_table_free(*((_QWORD **)this + 236));
      *((_QWORD *)this + 236) = 0;
    }
    v11 = 0;
    v12 = (char *)this + 1856;
    do
    {
      if (*(_DWORD *)&v12[v11])
      {
        ((void (*)(_QWORD))v4[592])(*v4);
        *(_DWORD *)&v12[v11] = 0;
      }
      v11 += 4;
    }
    while (v11 != 32);
  }
  return CA::OGL::Context::purge(this, a2);
}

uint64_t CA::OGL::GLContext::init_state(CA::OGL::GLContext *this)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v2 = (_QWORD *)*((_QWORD *)this + 260);
  if (!*((_QWORD *)this + 31))
  {
    ((void (*)(_QWORD, uint64_t, char *))v2[105])(*v2, 2978, (char *)this + 1896);
    *((_OWORD *)this + 128) = *(_OWORD *)((char *)this + 1896);
    *((_BYTE *)this + 2092) &= ~1u;
    if (*((CA::OGL::GLContext **)this + 255) != (CA::OGL::GLContext *)((char *)this + 1912))
    {
      *((_QWORD *)this + 255) = (char *)this + 1912;
      ++*((_DWORD *)this + 60);
    }
  }
  v3 = 0;
  *(_BYTE *)(*((_QWORD *)this + 3) + 16) = 0;
  *(_BYTE *)(*((_QWORD *)this + 3) + 17) = 0;
  *(_BYTE *)(*((_QWORD *)this + 3) + 18) = 0;
  *(_BYTE *)(*((_QWORD *)this + 3) + 19) = 0;
  *(_BYTE *)(*((_QWORD *)this + 3) + 20) = 0;
  v4 = *((_QWORD *)this + 3);
  *(_BYTE *)(v4 + 480) = 1;
  v5 = v4 + 96;
  do
  {
    *(_OWORD *)(v5 + v3) = xmmword_18474E210;
    v3 += 16;
  }
  while (v3 != 48);
  *((_BYTE *)this + 65) &= ~1u;
  *((_QWORD *)this + 7) = -1;
  ((void (*)(_QWORD, uint64_t))v2[64])(*v2, 3024);
  ((void (*)(_QWORD, float, float, float, float))v2[13])(*v2, 0.0, 0.0, 0.0, 0.0);
  *((_DWORD *)this + 461) = 0;
  result = ((uint64_t (*)(_QWORD, uint64_t))v2[343])(*v2, 33984);
  *((_DWORD *)this + 518) = 0;
  return result;
}

uint64_t CA::OGL::GLContext::restore_state(CA::OGL::GLContext *this, __n128 a2)
{
  _QWORD *v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  __int128 v14;
  char v15;
  unsigned __int8 v16;
  uint64_t v17;
  __int128 *v18;
  float v19;
  uint64_t v20;
  char v21;
  int v22;
  unsigned int v23;
  __int128 v25;
  uint64_t v26;

  v3 = (_QWORD *)*((_QWORD *)this + 260);
  if (*((_DWORD *)this + 518))
  {
    ((void (*)(_QWORD, _QWORD))v3[514])(*v3, 0);
    ((void (*)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))v3[512])(*v3, 0, 4, 5126, 0, 0, 0);
    ((void (*)(_QWORD, uint64_t))v3[514])(*v3, 1);
    ((void (*)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))v3[512])(*v3, 1, 4, 5121, 0, 0, 0);
    ((void (*)(_QWORD, uint64_t))v3[514])(*v3, 2);
    ((void (*)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))v3[512])(*v3, 2, 2, 5126, 0, 0, 0);
    ((void (*)(_QWORD, uint64_t))v3[514])(*v3, 3);
    ((void (*)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))v3[512])(*v3, 3, 2, 5126, 0, 0, 0);
    *((_DWORD *)this + 518) = 0;
  }
  if (*((_QWORD *)this + 231))
  {
    *((_QWORD *)this + 231) = 0;
    (*(void (**)(_QWORD, _QWORD))(*((_QWORD *)this + 260) + 4808))(**((_QWORD **)this + 260), 0);
  }
  v4 = *((_QWORD *)this + 3);
  v5 = *((_DWORD *)this + 22);
  if (v5 >= 0xD)
    v6 = 13;
  else
    v6 = v5;
  v7 = *((unsigned int *)this + 461);
  if ((_DWORD)v6)
  {
    v8 = 0;
    v9 = v4 + 144;
    do
    {
      v10 = *(unsigned __int16 *)(v9 + 2 * v8);
      if (*(_WORD *)(v9 + 2 * v8))
      {
        v11 = v9 + 8 * v8;
        if (*(_QWORD *)(v11 + 32))
        {
          if (v8 != v7)
          {
            ((void (*)(_QWORD, _QWORD))v3[343])(*v3, (v8 + 33984));
            v10 = *(unsigned __int16 *)(v9 + 2 * v8);
            v7 = v8;
          }
          ((void (*)(_QWORD, uint64_t, _QWORD))v3[6])(*v3, v10, 0);
          *(_QWORD *)(v11 + 32) = 0;
        }
        *(_WORD *)(v9 + 2 * v8) = 0;
      }
      ++v8;
    }
    while (v6 != v8);
  }
  v12 = 0;
  v13 = 1;
  v14 = xmmword_18474E210;
  do
  {
    v15 = v13;
    if ((v16 & 1) == 0)
    {
      v26 = v12;
      v21 = v15;
      v25 = v14;
      v14 = v25;
      v15 = v21;
      v12 = v26;
      if (v22)
      {
        CA::OGL::GLContext::restore_state(void)::identity = v25;
        v14 = v25;
        v15 = v21;
        v12 = v26;
      }
    }
    v17 = v4 + 16 * v12;
    v19 = *(float *)(v17 + 96);
    v18 = (__int128 *)(v17 + 96);
    a2.n128_f32[0] = v19;
    if (v19 != *(float *)&CA::OGL::GLContext::restore_state(void)::identity
      || (a2.n128_u32[0] = *(_DWORD *)(v4 + 16 * v12 + 100),
          a2.n128_f32[0] != *((float *)&CA::OGL::GLContext::restore_state(void)::identity + 1))
      || (v20 = v4 + 16 * v12,
          a2.n128_u32[0] = *(_DWORD *)(v20 + 104),
          a2.n128_f32[0] != *((float *)&CA::OGL::GLContext::restore_state(void)::identity + 2))
      || (a2.n128_u32[0] = *(_DWORD *)(v20 + 108),
          a2.n128_f32[0] != *((float *)&CA::OGL::GLContext::restore_state(void)::identity + 3)))
    {
      *v18 = v14;
    }
    v13 = 0;
    v12 = 1;
  }
  while ((v15 & 1) != 0);
  if (v7)
  {
    ((void (*)(_QWORD, uint64_t, __n128))v3[343])(*v3, 33984, a2);
    *((_DWORD *)this + 461) = 0;
  }
  v23 = *(unsigned __int8 *)(v4 + 480);
  if (v23 != 1)
  {
    CA::OGL::GLContext::load_blend_func((uint64_t)this, 1u, v23);
    *(_BYTE *)(v4 + 480) = 1;
  }
  if ((*(_BYTE *)(v4 + 481) & 1) != 0)
  {
    ((void (*)(_QWORD, uint64_t))v3[64])(*v3, 3042);
    *(_BYTE *)(v4 + 481) &= ~1u;
  }
  if ((*((_BYTE *)this + 65) & 1) != 0)
  {
    ((void (*)(_QWORD, uint64_t))v3[64])(*v3, 3089);
    *((_BYTE *)this + 65) &= ~1u;
  }
  memset_pattern16((char *)this + 48, &unk_18474EA10, 0x10uLL);
  ((void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v3[252])(*v3, 0, 0, 0, 0);
  return ((uint64_t (*)(_QWORD, uint64_t))v3[73])(*v3, 3024);
}

void CA::OGL::GLContext::draw_elements(uint64_t **this, uint64_t a2, uint64_t a3, const float *a4, uint64_t a5, float64x2_t a6, __n128 a7, uint64_t a8, uint64_t a9, _QWORD *a10)
{
  CA::OGL::Context *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  float64x2_t *v19;
  uint64_t v20;
  uint64_t v21;
  const float *v22;
  float64x2_t v23;
  __n128 v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  _BYTE v28[12312];
  _QWORD v29[3];
  _QWORD *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a2)
  {
    v15 = (CA::OGL::Context *)this;
    v16 = this[260];
    v17 = CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::primitive_modes[a2];
    v18 = this[32];
    if (v18 != this[31])
      goto LABEL_3;
    if (v18)
      LODWORD(v18) = (*((unsigned __int8 *)v18 + 72) >> 1) & 0x1F;
    if (*((_DWORD *)this + 61) != (_DWORD)v18)
LABEL_3:
      this = (uint64_t **)CA::OGL::Context::prepare_destination_((CA::OGL::Context *)this);
    if ((*((_WORD *)v15 + 408) & 0x200) != 0)
    {
      this = (uint64_t **)*((_QWORD *)v15 + 22);
      if (this)
      {
        *((_WORD *)v15 + 408) &= ~0x200u;
      }
    }
    if (!a10)
    {
      CA::OGL::GLContext::update_state(v15, a2, a3, a4, a6, a7);
      CA::OGL::GLContext::init_client_state((uint64_t)v15, a5);
      v27 = *v16;
      if (a4)
        ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, const float *))v16[68])(v27, v17, a3, 5123, a4);
      else
        ((void (*)(uint64_t, uint64_t, _QWORD, uint64_t))v16[66])(v27, v17, 0, a3);
      goto LABEL_23;
    }
    v19 = (float64x2_t *)*((_QWORD *)v15 + 100);
    if (v19)
    {
      *((_QWORD *)v15 + 100) = 0;
      ++*((_DWORD *)v15 + 60);
    }
    MEMORY[0x1E0C80A78](this);
    bzero(v28, 0x300FuLL);
    CA::OGL::GLContext::update_state(v15, v20, v21, v22, v23, v24);
    CA::OGL::GLContext::init_client_state((uint64_t)v15, (uint64_t)v28);
    v29[0] = &off_1E159A3C0;
    v29[1] = v15;
    v30 = v29;
    CA::OGL::clip_primitives(a2, a3, (uint64_t)a4, a5, 0, a10, v19, v28, 0x100u, (uint64_t)v29, 1u);
    v25 = v30;
    if (v30 == v29)
    {
      v26 = 4;
      v25 = v29;
    }
    else
    {
      if (!v30)
        goto LABEL_20;
      v26 = 5;
    }
    (*(void (**)(void))(*v25 + 8 * v26))();
LABEL_20:
    if (v19)
    {
      *((_QWORD *)v15 + 100) = v19;
      ++*((_DWORD *)v15 + 60);
    }
LABEL_23:
    CA::OGL::GLContext::unload_state((uint64_t)v15);
    CA::OGL::Context::marked_destination(v15);
    ++*((_DWORD *)v15 + 172);
  }
}

void CA::OGL::GLContext::draw_lines(CA::OGL::Context *this, uint64_t a2, uint64_t a3, const float *a4, float64x2_t a5, __n128 a6)
{
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;

  v10 = *((_QWORD *)this + 32);
  if (v10 != *((_QWORD *)this + 31))
    goto LABEL_2;
  if (v10)
    LODWORD(v10) = (*(unsigned __int8 *)(v10 + 72) >> 1) & 0x1F;
  if (*((_DWORD *)this + 61) != (_DWORD)v10)
LABEL_2:
    CA::OGL::Context::prepare_destination_(this);
  if ((*((_WORD *)this + 408) & 0x200) != 0)
  {
    v11 = *((_QWORD *)this + 22);
    if (v11)
    {
      *((_WORD *)this + 408) &= ~0x200u;
    }
  }
  CA::OGL::GLContext::update_state(this, a2, a3, a4, a5, a6);
  if (*((const float **)this + 258) != a4 || *((_DWORD *)this + 518) != 2)
  {
    v12 = (_QWORD *)*((_QWORD *)this + 260);
    ((void (*)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, uint64_t, const float *))v12[512])(*v12, 0, 2, 5126, 0, 16, a4);
    ((void (*)(_QWORD, _QWORD))v12[513])(*v12, 0);
    ((void (*)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, const float *))v12[512])(*v12, 1, 4, 5131, 1, 16, a4 + 2);
    ((void (*)(_QWORD, uint64_t))v12[513])(*v12, 1);
    ((void (*)(_QWORD, uint64_t))v12[514])(*v12, 2);
    ((void (*)(_QWORD, uint64_t))v12[514])(*v12, 3);
    ((void (*)(_QWORD, uint64_t))v12[514])(*v12, 4);
    *((_QWORD *)this + 258) = a4;
    *((_DWORD *)this + 518) = 2;
  }
  (*(void (**)(_QWORD, uint64_t, uint64_t, uint64_t))(*((_QWORD *)this + 260) + 528))(**((_QWORD **)this + 260), 1, a2, a3);
  CA::OGL::GLContext::unload_state((uint64_t)this);
  CA::OGL::Context::marked_destination(this);
  ++*((_DWORD *)this + 172);
}

void CA::OGL::GLContext::draw_points(CA::OGL::Context *this, uint64_t a2, uint64_t a3, const float *a4, float64x2_t a5, __n128 a6)
{
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;

  v10 = *((_QWORD *)this + 32);
  if (v10 != *((_QWORD *)this + 31))
    goto LABEL_2;
  if (v10)
    LODWORD(v10) = (*(unsigned __int8 *)(v10 + 72) >> 1) & 0x1F;
  if (*((_DWORD *)this + 61) != (_DWORD)v10)
LABEL_2:
    CA::OGL::Context::prepare_destination_(this);
  if ((*((_WORD *)this + 408) & 0x200) != 0)
  {
    v11 = *((_QWORD *)this + 22);
    if (v11)
    {
      *((_WORD *)this + 408) &= ~0x200u;
    }
  }
  *((_BYTE *)this + 2092) |= 2u;
  CA::OGL::GLContext::update_state(this, a2, a3, a4, a5, a6);
  *((_BYTE *)this + 2092) &= ~2u;
  if (*((const float **)this + 258) != a4 || *((_DWORD *)this + 518) != 3)
  {
    v12 = (_QWORD *)*((_QWORD *)this + 260);
    ((void (*)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, uint64_t, const float *))v12[512])(*v12, 0, 2, 5126, 0, 16, a4);
    ((void (*)(_QWORD, _QWORD))v12[513])(*v12, 0);
    ((void (*)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, const float *))v12[512])(*v12, 4, 1, 5126, 0, 16, a4 + 2);
    ((void (*)(_QWORD, uint64_t))v12[513])(*v12, 4);
    ((void (*)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, const float *))v12[512])(*v12, 1, 4, 5121, 1, 16, a4 + 3);
    ((void (*)(_QWORD, uint64_t))v12[513])(*v12, 1);
    ((void (*)(_QWORD, uint64_t))v12[514])(*v12, 2);
    ((void (*)(_QWORD, uint64_t))v12[514])(*v12, 3);
    *((_QWORD *)this + 258) = a4;
    *((_DWORD *)this + 518) = 3;
  }
  (*(void (**)(_QWORD, _QWORD, uint64_t, uint64_t))(*((_QWORD *)this + 260) + 528))(**((_QWORD **)this + 260), 0, a2, a3);
  CA::OGL::GLContext::unload_state((uint64_t)this);
  CA::OGL::Context::marked_destination(this);
  ++*((_DWORD *)this + 172);
}

uint64_t CA::OGL::GLContext::flush(CA::OGL::GLContext *this)
{
  return (*(uint64_t (**)(_QWORD))(*((_QWORD *)this + 260) + 728))(**((_QWORD **)this + 260));
}

uint64_t CA::OGL::GLContext::insert_event_marker(CA::OGL::GLContext *this, const char *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, const char *))(*((_QWORD *)this + 260) + 6536))(**((_QWORD **)this + 260), 0, a2);
}

uint64_t CA::OGL::GLContext::push_group_marker(CA::OGL::GLContext *this, const char *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, const char *))(*((_QWORD *)this + 260) + 6544))(**((_QWORD **)this + 260), 0, a2);
}

uint64_t CA::OGL::GLContext::pop_group_marker(CA::OGL::GLContext *this)
{
  return (*(uint64_t (**)(_QWORD))(*((_QWORD *)this + 260) + 6552))(**((_QWORD **)this + 260));
}

CA::OGL::Context *CA::OGL::GLContext::bind_color_cube(CA::OGL::Context *this, uint64_t a2, CA::Render::Texture *a3)
{
  CA::OGL::Context *v5;
  CA::OGL::Context *v6;
  unsigned int *v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;

  v5 = this;
  if (*((CA::OGL::Context **)a3 + 11) == this && (v6 = (CA::OGL::Context *)*((_QWORD *)a3 + 10)) != 0
    || (this = (CA::OGL::Context *)CA::OGL::Context::lookup_image_(this, a3, 1), (v6 = this) != 0))
  {
    if (*((_BYTE *)a3 + 12) == 23)
    {
      if (!*((_QWORD *)v6 + 1))
      {
        *((_QWORD *)v6 + 1) = a3;
        v7 = (unsigned int *)((char *)a3 + 148);
        do
          v8 = __ldaxr(v7);
        while (__stlxr(v8 + 1, v7));
      }
      v9 = *((_DWORD *)v6 + 13);
      if ((_WORD)v9)
      {
        if (!*((_BYTE *)v6 + 72))
          return this;
        if (*((_DWORD *)v6 + 4) == *((_DWORD *)a3 + 9))
        {
          v10 = *((unsigned int *)v6 + 16);
          v11 = *((_QWORD *)v5 + 2);
          *(_WORD *)(v11 + 2 * a2 + 144) = v9;
          *(_QWORD *)(v11 + 8 * a2 + 176) = v10;
          return this;
        }
      }
      else
      {
        v12 = 3553;
        if (*((_DWORD *)a3 + 5) != 1)
        {
          v13 = (*(uint64_t (**)(CA::OGL::Context *, uint64_t))(*(_QWORD *)v5 + 184))(v5, 16);
          v9 = *((_DWORD *)v6 + 13);
          if (v13)
            v12 = 32879;
          else
            v12 = 3553;
        }
        *((_DWORD *)v6 + 13) = v9 & 0xFFFF0000 | v12;
        *((_WORD *)v6 + 29) |= 0x100u;
      }
      return (CA::OGL::Context *)(*(uint64_t (**)(CA::OGL::Context *, CA::OGL::Context *, CA::Render::Texture *, uint64_t, _QWORD))(*(_QWORD *)v5 + 1184))(v5, v6, a3, a2, 0);
    }
  }
  return this;
}

CA::OGL::Context *CA::OGL::GLContext::bind_table_image(CA::OGL::Context *this, unsigned int a2, CA::Render::Image *a3)
{
  CA::OGL::Context *v5;
  CA::OGL::Context *v6;
  unsigned int *v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;

  v5 = this;
  if (*((CA::OGL::Context **)a3 + 11) == this && (v6 = (CA::OGL::Context *)*((_QWORD *)a3 + 10)) != 0
    || (this = (CA::OGL::Context *)CA::OGL::Context::lookup_image_(this, a3, 1), (v6 = this) != 0))
  {
    if (!*((_QWORD *)v6 + 1))
    {
      *((_QWORD *)v6 + 1) = a3;
      v7 = (unsigned int *)((char *)a3 + 148);
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 + 1, v7));
    }
    v9 = *((_DWORD *)v6 + 13);
    if ((_WORD)v9)
    {
      if (!*((_BYTE *)v6 + 72))
        return this;
      if (*((_DWORD *)v6 + 4) == *((_DWORD *)a3 + 9))
      {
        v10 = *((unsigned int *)v6 + 16);
        v11 = *((_QWORD *)v5 + 2);
        *(_WORD *)(v11 + 2 * a2 + 144) = v9;
        *(_QWORD *)(v11 + 8 * a2 + 176) = v10;
        return this;
      }
    }
    else
    {
      *((_DWORD *)v6 + 13) = v9 & 0xFFFF0000 | 0xDE1;
      *((_WORD *)v6 + 29) |= 0x100u;
    }
    return (CA::OGL::Context *)(*(uint64_t (**)(CA::OGL::Context *))(*(_QWORD *)v5 + 1184))(v5);
  }
  return this;
}

uint64_t CA::OGL::GLContext::needs_destination_group(CA::OGL::GLContext *this)
{
  if ((*(unsigned int (**)(CA::OGL::GLContext *, uint64_t))(*(_QWORD *)this + 184))(this, 18))
    return 0;
  else
    return (*(unsigned int (**)(CA::OGL::GLContext *, char *))(*(_QWORD *)this + 1136))(this, (char *)this + 1896) ^ 1;
}

BOOL CA::OGL::GLContext::state_requires_disjoint_primitives(CA::OGL::GLContext *this)
{
  unsigned __int8 *v1;

  v1 = (unsigned __int8 *)*((_QWORD *)this + 2);
  return ((CA::OGL::tex_fragment_shader_flags[v1[16]] & 0x10) != 0 || (v1[481] & 1) != 0 && v1[480] >= 0x1Au)
      && (*(unsigned int (**)(CA::OGL::GLContext *, uint64_t))(*(_QWORD *)this + 184))(this, 18) == 0;
}

uint64_t CA::OGL::GLContext::clear_region(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24[4];

  v24[3] = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD **)(a1 + 2080);
  v7 = *(_QWORD *)(a1 + 256);
  if (v7 != *(_QWORD *)(a1 + 248))
    goto LABEL_2;
  if (v7)
    LODWORD(v7) = (*(unsigned __int8 *)(v7 + 72) >> 1) & 0x1F;
  if (*(_DWORD *)(a1 + 244) != (_DWORD)v7)
LABEL_2:
    CA::OGL::Context::prepare_destination_((CA::OGL::Context *)a1);
  if ((*(_WORD *)(a1 + 816) & 0x200) != 0)
  {
    v8 = *(_QWORD *)(a1 + 176);
    if (v8)
    {
      *(_WORD *)(a1 + 816) &= ~0x200u;
    }
  }
  if (*a3)
  {
    _H3 = HIWORD(*a3);
    _H2 = WORD2(*a3);
    _H1 = WORD1(*a3);
    _H0 = *a3;
    __asm
    {
      FCVT            S0, H0
      FCVT            S1, H1
      FCVT            S2, H2
      FCVT            S3, H3
    }
    ((void (*)(_QWORD, float, float, float, float))v6[13])(*v6, _S0, _S1, _S2, _S3);
  }
  ((void (*)(_QWORD, uint64_t))v6[73])(*v6, 3089);
  v22 = 0;
  v23 = 0;
  v24[1] = 0;
  v24[2] = 0;
  v24[0] = a2;
  while (CA::ShapeIterator::iterate(v24, (int *)&v22))
  {
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 1120))(a1, &v22);
    ((void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v6[252])(*v6, v22, HIDWORD(v22), v23, HIDWORD(v23));
    ((void (*)(_QWORD, uint64_t))v6[11])(*v6, 0x4000);
  }
  result = ((uint64_t (*)(_QWORD, uint64_t))v6[64])(*v6, 3089);
  if (*a3)
    return ((uint64_t (*)(_QWORD, float, float, float, float))v6[13])(*v6, 0.0, 0.0, 0.0, 0.0);
  return result;
}

BOOL CA::OGL::GLContext::function_supported(CA::OGL::GLContext *this)
{
  uint64_t v1;
  _BOOL8 result;

  v1 = *((_QWORD *)this + 2);
  result = 1;
  switch(*(_BYTE *)(v1 + 16))
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x65:
      return result;
    case 0x1A:
    case 0x1B:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x21:
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
      result = *(unsigned __int8 *)(v1 + 17) == 0;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

void CA::OGL::GLContext::function_uniform(CA::OGL::GLContext *this, uint64_t a2, uint64_t a3, const float *a4, const float *a5, float64x2_t a6, __n128 a7)
{
  unsigned int v8;
  uint64_t v10;
  uint64_t v11;

  v8 = a2;
  CA::OGL::GLContext::update_shader(this, a6, a7, a2, a3, a4);
  if (v8 <= 6)
  {
    v10 = *((_QWORD *)this + 231);
    if (v10)
    {
      if (*(_DWORD *)(v10 + 4 * v8 + 144) != -1)
      {
        switch(a3)
        {
          case 1:
            v11 = 4888;
            goto LABEL_10;
          case 2:
            v11 = 4896;
            goto LABEL_10;
          case 3:
            v11 = 4904;
            goto LABEL_10;
          case 4:
            v11 = 4912;
LABEL_10:
            (*(void (**)(_QWORD))(*((_QWORD *)this + 260) + v11))(**((_QWORD **)this + 260));
            break;
          default:
            return;
        }
      }
    }
  }
}

void CA::OGL::GLContext::update_shader(CA::OGL::GLContext *this, float64x2_t a2, __n128 a3, uint64_t a4, uint64_t a5, const float *a6)
{
  CA::OGL::GLContext *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  _DWORD *v17;
  uint64_t *v18;
  uint64_t v19;
  __int16 v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  _BOOL4 v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  unsigned int v35;
  char v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  char v42;
  char v43;
  uint64_t v44;
  _BYTE *v45;
  uint64_t v46;
  _BYTE *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  __int16 v51;
  __int16 v52;
  _BYTE *v53;
  _QWORD *v54;
  char *shader;
  unsigned int v56;
  __n128 *v57;
  float *v58;
  float *v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  float32x2_t v63;
  float32x2_t v64;
  unsigned int v65;
  unint64_t v66;
  unsigned int *v67;
  uint64_t v68;
  unsigned int v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unsigned int v74;
  BOOL v75;
  uint64_t v76;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  float v81;
  uint64_t v82;
  uint64_t v83;
  float v84;
  float v85;
  unint64_t v86;
  int v87;
  float v88;
  uint64_t v89;
  char v90;
  char v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v107;
  uint64_t v108;
  __int128 v109;
  float v110;
  uint64_t v111;
  char v112;
  char v113;
  uint64_t v114;
  _OWORD *v115;
  float v116;
  float v117;
  uint64_t v118;
  _OWORD *v119;
  float v120;
  uint64_t v121;
  uint64_t v122;
  _BYTE v123[88];
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  uint64_t v144;
  _QWORD v145[4];

  v6 = this;
  v145[1] = *MEMORY[0x1E0C80C00];
  v7 = (_QWORD *)*((_QWORD *)this + 260);
  v8 = *((_QWORD *)this + 2);
  v9 = *((_QWORD *)this + 231);
  if (!v9)
  {
    if (*(_BYTE *)(v8 + 16) == 101)
      return;
LABEL_26:
    v24 = *(_QWORD *)(v8 + 16);
    v25 = CA::OGL::tex_image_count[v24];
    if (CA::OGL::tex_image_count[v24])
    {
      v26 = 0;
      v27 = 0;
      do
      {
        v27 += CA::OGL::image_plane_count[*(unsigned __int8 *)(v8 + v26 + 17)];
        v28 = *(_QWORD *)(v8 + 8 * v26 + 40);
        if (v28)
        {
          v29 = *(_QWORD *)(v28 + 80);
          _ZF = v29 == 0;
          v30 = v29 != 0;
          v31 = *(_DWORD *)(v28 + 56);
          if (_ZF)
            v32 = 1;
          else
            v32 = 2;
          if (v31)
            v33 = v32;
          else
            v33 = v30;
          v27 += v33;
        }
        ++v26;
      }
      while (v25 != v26);
    }
    else
    {
      v27 = 0;
    }
    v142 = 0u;
    v143 = 0u;
    v140 = 0u;
    v141 = 0u;
    v138 = 0u;
    v139 = 0u;
    v136 = 0u;
    v137 = 0u;
    v135 = 0u;
    v144 = 0;
    v134 = 0u;
    v133 = 0u;
    v132 = 0u;
    v131 = 0u;
    v130 = 0u;
    v129 = 0u;
    v128 = 0u;
    v127 = 0u;
    v126 = 0u;
    v125 = 0u;
    v124 = 0u;
    memset(&v123[8], 0, 80);
    *(_QWORD *)v123 = v24;
    DWORD1(v134) = -1;
    v34 = *(unsigned __int8 *)(v8 + 481);
    v35 = *(unsigned __int8 *)(v8 + 480);
    if (((v34 & 1) == 0 || v35 <= 0x19) && *(_BYTE *)(v8 + 480) && (v24 & 0xFE) != 0x10)
      LOWORD(v35) = 58;
    HIDWORD(v134) = -1;
    v123[38] = (*((unsigned __int16 *)this + 408) >> 12) & 7;
    *(_WORD *)&v123[36] = (v34 >> 1) & 1 | ((_WORD)v35 << 8);
    BYTE6(v124) = (*((_BYTE *)this + 2092) & 2) != 0;
    v123[39] = *(_BYTE *)(v8 + 304);
    if ((int)v27 < 1 || (memcpy(&v123[8], (const void *)(v8 + 144), 2 * v27), v27 <= 0xC))
      bzero(&v123[2 * v27 + 8], 2 * (12 - v27) + 2);
    v36 = v123[36];
    if ((*(_WORD *)&v123[36] & 0xFF00) != 0x3A00 || (CA::OGL::tex_fragment_shader_flags[v123[0]] & 0x10) != 0)
      goto LABEL_51;
    v145[0] = v24;
    if (!(_DWORD)v25)
      goto LABEL_58;
    if ((v24 & 0xFF00) == 0x2600)
    {
LABEL_51:
      if ((*(unsigned int (**)(CA::OGL::GLContext *, uint64_t))(*(_QWORD *)v6 + 184))(v6, 18))
      {
        DWORD2(v134) = 1;
        goto LABEL_58;
      }
      v37 = *(_QWORD *)v6;
      if (*((_QWORD *)v6 + 31))
      {
        v38 = (*(uint64_t (**)(CA::OGL::GLContext *))(v37 + 1152))(v6);
        if (!v38)
          goto LABEL_58;
      }
      else
      {
        v38 = (*(uint64_t (**)(CA::OGL::GLContext *))(v37 + 1160))(v6);
        if (!v38)
          goto LABEL_58;
      }
      *(_WORD *)&v123[2 * v27 + 8] = v38;
      *(_QWORD *)((char *)&v134 + 4) = v27++ | 0x100000000;
      v36 = v123[36];
      goto LABEL_58;
    }
    v86 = 0;
    while (v25 - 1 != v86)
    {
      v87 = *((unsigned __int8 *)v145 + v86++ + 2);
      if (v87 == 38)
      {
        if (v86 < v25)
          goto LABEL_51;
        break;
      }
    }
LABEL_58:
    v39 = (uint64_t)v6;
    if ((v36 & 1) != 0)
    {
      *(_WORD *)&v123[2 * v27 + 8] = 3553;
      HIDWORD(v134) = v27++;
    }
    v40 = 0;
    v41 = CA::OGL::tex_image_count[v123[0]];
    v136 = 0u;
    v137 = 0u;
    v138 = 0u;
    v139 = 0u;
    v42 = 1;
    do
    {
      v43 = v42;
      if (v40 < v41 && (v44 = *(_QWORD *)(v8 + 8 * v40 + 40)) != 0)
      {
        v45 = &v123[32 * v40];
        *((_DWORD *)v45 + 70) = *(_DWORD *)(v44 + 36);
        *((_WORD *)v45 + 147) = *(_DWORD *)(v44 + 40);
        v46 = *(_QWORD *)(v44 + 80);
        if (v46)
          LODWORD(v46) = *(_DWORD *)(v44 + 92);
        v47 = v45 + 280;
        *((_WORD *)v45 + 144) = v46;
        v48 = *(_QWORD *)(v44 + 64);
        if (v48)
        {
          *((_WORD *)v47 + 2) = *(_DWORD *)(v48 + 20);
          *((_WORD *)v47 + 3) = *(_DWORD *)(v48 + 16);
        }
        v49 = v8 + v40;
        v47[18] = *(_BYTE *)(v49 + 56);
        v47[19] = *(_BYTE *)(v49 + 58);
        v50 = *(_QWORD *)(v44 + 80);
        _ZF = v50 == 0;
        v51 = v50 != 0;
        if (_ZF)
          v52 = 1;
        else
          v52 = 2;
        if (*(_DWORD *)(v44 + 56))
          v51 = v52;
        *((_WORD *)v47 + 8) = v51;
        *((_WORD *)v47 + 5) = CGColorSpaceGetNumberOfComponents(*(CGColorSpaceRef *)(v44 + 16));
        *((_WORD *)v47 + 6) = CGColorSpaceGetNumberOfComponents(*(CGColorSpaceRef *)(v44 + 24));
      }
      else
      {
        v53 = &v123[32 * v40];
        *((_DWORD *)v53 + 70) = 0;
        *((_WORD *)v53 + 147) = 0;
      }
      v42 = 0;
      v40 = 1;
    }
    while ((v43 & 1) != 0);
    v6 = (CA::OGL::GLContext *)v39;
    v54 = *(_QWORD **)(v39 + 1888);
    if (!v54)
    {
      v54 = x_hash_table_new_((unint64_t (*)(uint64_t))CA::OGL::gl_shader_hash, (BOOL (*)(uint64_t, uint64_t))CA::OGL::gl_shader_compare, 0, 0, 0, 0);
      *(_QWORD *)(v39 + 1888) = v54;
    }
    v9 = x_hash_table_lookup((uint64_t)v54, (uint64_t)v123, 0);
    if (!v9)
    {
      shader = CA::OGL::GLContext::create_shader(v39, v123, v27);
      if (!shader)
      {
        if (!*(_QWORD *)(v39 + 1848))
          return;
        goto LABEL_24;
      }
      v9 = (uint64_t)shader;
      hash_table_modify(*(int **)(v39 + 1888), v9, v9, 0);
    }
    if (*(_QWORD *)(v39 + 1848) == v9)
      goto LABEL_83;
    v56 = *(_DWORD *)(v9 + 56);
LABEL_82:
    ((void (*)(_QWORD, _QWORD))v7[601])(*v7, v56);
    *((_QWORD *)v6 + 231) = v9;
LABEL_83:
    if (!v9)
      return;
    goto LABEL_84;
  }
  if (*(_DWORD *)v9 != *(_DWORD *)(v8 + 16) || *(_DWORD *)(v9 + 4) != *(_DWORD *)(v8 + 20))
  {
LABEL_23:
    if (*(_DWORD *)(v8 + 16) == 101)
    {
LABEL_24:
      v9 = 0;
      v56 = 0;
      goto LABEL_82;
    }
    goto LABEL_26;
  }
  v10 = *(unsigned __int8 *)(v9 + 34);
  if (*(_BYTE *)(v9 + 34))
  {
    v11 = (unsigned __int16 *)(v9 + 8);
    v12 = (unsigned __int16 *)(v8 + 144);
    do
    {
      v14 = *v12++;
      v13 = v14;
      v15 = *v11++;
      if (v13 != v15)
        goto LABEL_23;
    }
    while (--v10);
  }
  v16 = *(unsigned __int8 *)(v9 + 35);
  if (*(_BYTE *)(v9 + 35))
  {
    v17 = (_DWORD *)(v9 + 280);
    v18 = (uint64_t *)(v8 + 40);
    do
    {
      v19 = *v18;
      if (*v18)
        LODWORD(v19) = *(_DWORD *)(v19 + 36);
      if (*v17 != (_DWORD)v19)
        goto LABEL_23;
      v17 += 8;
      ++v18;
    }
    while (--v16);
  }
  v20 = *(_WORD *)(v9 + 36);
  v21 = *(unsigned __int8 *)(v8 + 481);
  v22 = *(unsigned __int8 *)(v8 + 480);
  if (((v21 & 1) == 0 || v22 <= 0x19) && *(_BYTE *)(v8 + 480) && (*(_DWORD *)v9 & 0xFE) != 0x10)
    v22 = 58;
  _ZF = v22 == HIBYTE(v20) && (v20 & 1) == ((v21 >> 1) & 1);
  if (!_ZF || *(_BYTE *)(v9 + 94) != ((*((unsigned __int8 *)this + 2092) >> 1) & 1))
    goto LABEL_23;
LABEL_84:
  if (*(_BYTE *)(v9 + 92))
  {
    v57 = (__n128 *)(v8 + 24);
    if (*(float *)(v9 + 60) != *(float *)(v8 + 24)
      || *(float *)(v9 + 64) != *(float *)(v8 + 28)
      || *(float *)(v9 + 68) != *(float *)(v8 + 32)
      || *(float *)(v9 + 72) != *(float *)(v8 + 36))
    {
      ((void (*)(_QWORD, _QWORD, uint64_t, uint64_t))v7[614])(*v7, *(unsigned int *)(v9 + 144), 1, v8 + 24);
      a2 = *(float64x2_t *)v57;
      *(__n128 *)(v9 + 60) = *v57;
    }
  }
  if (*(_BYTE *)(v9 + 93)
    && (*(float *)(v9 + 76) != *(float *)(v8 + 368)
     || *(float *)(v9 + 80) != *(float *)(v8 + 372)
     || *(float *)(v9 + 84) != *(float *)(v8 + 376)
     || *(float *)(v9 + 88) != *(float *)(v8 + 380)))
  {
    ((void (*)(_QWORD, _QWORD, uint64_t, uint64_t))v7[614])(*v7, *(unsigned int *)(v9 + 148), 1, v8 + 368);
    a2 = *(float64x2_t *)(v8 + 368);
    *(float64x2_t *)(v9 + 76) = a2;
  }
  if (*(_DWORD *)(v9 + 408) != *((_DWORD *)v6 + 60))
  {
    if (*(_DWORD *)(v9 + 232) != -1)
    {
      BYTE4(a2.f64[0]) = 0;
      BYTE5(a2.f64[0]) = 0;
      BYTE6(a2.f64[0]) = 0;
      HIBYTE(a2.f64[0]) = 0;
      LOBYTE(a2.f64[1]) = 0;
      BYTE1(a2.f64[1]) = 0;
      BYTE2(a2.f64[1]) = 0;
      BYTE3(a2.f64[1]) = 0;
      BYTE4(a2.f64[1]) = 0;
      BYTE5(a2.f64[1]) = 0;
      BYTE6(a2.f64[1]) = 0;
      HIBYTE(a2.f64[1]) = 0;
      memset(v123, 0, 64);
      v58 = (float *)*((_QWORD *)v6 + 255);
      v59 = (float *)*((_QWORD *)v6 + 100);
      if (v59)
      {
        a2 = CA::Mat4Impl::mat4_concat((float32x4_t *)v123, v59, (const double *)*((_QWORD *)v6 + 255), a6);
        v58 = (float *)v123;
      }
      if (*(float *)(v9 + 168) == *v58)
      {
        v82 = 0;
        while (v82 != 15)
        {
          v83 = v82 + 1;
          v84 = *(float *)(v9 + 172 + 4 * v82);
          v85 = v58[++v82];
          if (v84 != v85)
          {
            if ((unint64_t)(v83 - 1) <= 0xE)
              goto LABEL_101;
            break;
          }
        }
      }
      else
      {
LABEL_101:
        v60 = *((_OWORD *)v58 + 1);
        v61 = *((_OWORD *)v58 + 2);
        v62 = *((_OWORD *)v58 + 3);
        *(_OWORD *)(v9 + 168) = *(_OWORD *)v58;
        *(_OWORD *)(v9 + 184) = v60;
        *(_OWORD *)(v9 + 200) = v61;
        *(_OWORD *)(v9 + 216) = v62;
        ((void (*)(_QWORD, _QWORD, uint64_t, _QWORD))v7[621])(*v7, *(unsigned int *)(v9 + 232), 1, 0);
      }
    }
    if ((*(_DWORD *)(v9 + 272) & 0x80000000) == 0)
    {
      v63 = vmul_f32(vcvt_f32_s32(*(int32x2_t *)((char *)v6 + 2056)), (float32x2_t)0x3F0000003F000000);
      v64 = vadd_f32(v63, vcvt_f32_s32(*(int32x2_t *)((char *)v6 + 2048)));
      *(float32x2_t *)v123 = v63;
      *(float32x2_t *)&v123[8] = v64;
      ((void (*)(_QWORD))v7[614])(*v7);
    }
    *(_DWORD *)(v9 + 408) = *((_DWORD *)v6 + 60);
  }
  v65 = *(unsigned __int8 *)(v9 + 35);
  if (*(_BYTE *)(v9 + 35))
  {
    v66 = 0;
    v67 = (unsigned int *)(v9 + 304);
    do
    {
      if (*((_WORD *)v67 - 5))
      {
        v68 = *(_QWORD *)(v8 + 40 + 8 * v66);
        v69 = *(_DWORD *)(v68 + 8);
        if (*(v67 - 1) != v69)
        {
          v70 = *(unsigned int *)(v68 + 40);
          if ((_DWORD)v70)
          {
            ((void (*)(_QWORD, _QWORD, uint64_t, _QWORD))v7[614])(*v7, *v67, v70, *(_QWORD *)(v68 + 48));
            v69 = *(_DWORD *)(v68 + 8);
            v65 = *(unsigned __int8 *)(v9 + 35);
          }
          *(v67 - 1) = v69;
        }
      }
      ++v66;
      v67 += 8;
    }
    while (v66 < v65);
    if (v65)
    {
      v71 = 0;
      v72 = 0;
      v73 = 396;
      do
      {
        v74 = *(unsigned __int8 *)(v8 + v72 + 17);
        v75 = v74 > 0x28;
        v76 = (1 << v74) & 0x18000400000;
        if (!v75 && v76 != 0)
        {
          if ((*(_DWORD *)(v9 + v73 - 16) & 0x80000000) == 0)
          {
            v78 = v8 + v72;
            if (*(unsigned __int8 *)(v9 + v72 + 344) != *(unsigned __int8 *)(v8 + v72 + 60))
            {
              ((void (*)(_QWORD))v7[620])(*v7);
              ((void (*)(_QWORD, _QWORD, uint64_t, char *))v7[613])(*v7, *(unsigned int *)(v9 + v73 - 8), 1, &CA::OGL::ycbcr_matrices[48 * *(unsigned __int8 *)(v78 + 60) + 36]);
              *(_BYTE *)(v9 + v72 + 344) = *(_BYTE *)(v78 + 60);
            }
          }
          if ((*(_DWORD *)(v9 + v73) & 0x80000000) == 0)
          {
            v79 = v9 + v71;
            if (*(float *)(v9 + v71 + 348) != *(float *)(v8 + v71 + 64)
              || *(float *)(v79 + 352) != *(float *)(v8 + v71 + 68)
              || *(float *)(v9 + v71 + 356) != *(float *)(v8 + v71 + 72)
              || *(float *)(v9 + v71 + 360) != *(float *)(v8 + v71 + 76))
            {
              *(_OWORD *)(v79 + 348) = *(_OWORD *)(v8 + v71 + 64);
              ((void (*)(_QWORD, _QWORD, uint64_t))v7[614])(*v7, *(unsigned int *)(v9 + v73), 1);
            }
          }
        }
        ++v72;
        v71 += 16;
        v73 += 4;
      }
      while (v72 < *(unsigned __int8 *)(v9 + 35));
    }
  }
  if ((*(_DWORD *)(v9 + 404) & 0x80000000) == 0)
  {
    v80 = *(_QWORD *)(*((_QWORD *)v6 + 2) + 360);
    if (v80)
    {
      *(_QWORD *)&v123[8] = 0;
      v81 = -1.0;
      if (!*(_BYTE *)(v80 + 4))
        v81 = 1.0;
      *(_QWORD *)v123 = __PAIR64__(*(_DWORD *)(v80 + 16), LODWORD(v81));
      LODWORD(a2.f64[0]) = 0.5;
      a3.n128_u32[0] = -0.5;
      switch(*(_DWORD *)v80)
      {
        case 1:
          LODWORD(a2.f64[0]) = *(_DWORD *)(v80 + 8);
          *(_DWORD *)&v123[8] = LODWORD(a2.f64[0]);
          break;
        case 2:
          goto LABEL_149;
        case 3:
          LODWORD(a2.f64[0]) = 0;
          a3.n128_u32[0] = -1.0;
          goto LABEL_149;
        case 4:
          LODWORD(a2.f64[0]) = 1.0;
          a3.n128_u32[0] = 0;
LABEL_149:
          v88 = *(float *)(v80 + 12);
          a3.n128_f32[0] = *(float *)(v80 + 8) + (float)(v88 * a3.n128_f32[0]);
          *(_DWORD *)&v123[8] = a3.n128_u32[0];
          *(float *)a2.f64 = *(float *)(v80 + 8) + (float)(v88 * *(float *)a2.f64);
          *(_DWORD *)&v123[12] = LODWORD(a2.f64[0]);
          if (*(float *)a2.f64 <= a3.n128_f32[0])
            *(_QWORD *)&v123[8] = __PAIR64__(a3.n128_u32[0], LODWORD(a2.f64[0]));
          break;
        default:
          break;
      }
      ((void (*)(_QWORD, __n128, __n128))v7[614])(*v7, (__n128)a2, a3);
    }
  }
  v89 = 0;
  v90 = 1;
  do
  {
    v91 = v90;
    v92 = v9 + 8 * v89;
    v94 = *(_QWORD *)(v92 + 40);
    v93 = (_QWORD *)(v92 + 40);
    v95 = *(_QWORD *)(v8 + 8 * v89 + 288);
    if (v94 != v95 && (*(_DWORD *)(v9 + 4 * v89 + 236) & 0x80000000) == 0)
    {
      *v93 = v95;
      _H0 = v95;
      __asm { FCVT            S0, H0 }
      _H1 = WORD1(v95);
      __asm { FCVT            S1, H1 }
      _H2 = WORD2(v95);
      __asm { FCVT            S2, H2 }
      _H3 = HIWORD(v95);
      __asm { FCVT            S3, H3 }
      ((void (*)(_QWORD, float, float, float, float))v7[606])(*v7, _S0, _S1, _S2, _S3);
    }
    v90 = 0;
    v89 = 1;
  }
  while ((v91 & 1) != 0);
  if ((*(_DWORD *)(v9 + 252) & 0x80000000) == 0)
  {
    v107 = *((_QWORD *)v6 + 31);
    if (v107)
    {
      if (*(_DWORD *)(v9 + 256))
      {
        v108 = 0;
        do
        {
          (*(void (**)(CA::OGL::GLContext *, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, float))(*(_QWORD *)v6 + 776))(v6, v107, v108, (v108 + *(_DWORD *)(v9 + 252)), 0, 0, 0.0);
          v108 = (v108 + 1);
        }
        while (v108 < *(_DWORD *)(v9 + 256));
      }
      *(_QWORD *)&v109 = 0x3F0000003F000000;
      if ((*(_WORD *)(v107 + 75) & 0x10) == 0)
        *(float32x2_t *)&v109 = vmul_f32(vcvt_f32_s32(*(int32x2_t *)(v107 + 24)), (float32x2_t)0x3F0000003F000000);
      *((_QWORD *)&v109 + 1) = v109;
      *(_OWORD *)(*((_QWORD *)v6 + 2) + 128) = v109;
    }
    else
    {
      (*(void (**)(CA::OGL::GLContext *))(*(_QWORD *)v6 + 1168))(v6);
    }
    if ((*(_DWORD *)(v9 + 268) & 0x80000000) == 0
      && (*(float *)(v9 + 128) != *(float *)(v8 + 128)
       || *(float *)(v9 + 132) != *(float *)(v8 + 132)
       || *(float *)(v9 + 136) != *(float *)(v8 + 136)
       || *(float *)(v9 + 140) != *(float *)(v8 + 140)))
    {
      *(_OWORD *)(v9 + 128) = *(_OWORD *)(v8 + 128);
      ((void (*)(_QWORD))v7[614])(*v7);
    }
  }
  if ((*(_DWORD *)(v9 + 260) & 0x80000000) == 0)
    (*(void (**)(CA::OGL::GLContext *))(*(_QWORD *)v6 + 1128))(v6);
  if ((*(_DWORD *)(v9 + 264) & 0x80000000) == 0)
  {
    v110 = *((float *)v6 + 522) * (*(float *)(*((_QWORD *)v6 + 2) + 352) + *(float *)(*((_QWORD *)v6 + 2) + 352));
    ((void (*)(_QWORD, float))v7[603])(*v7, v110);
  }
  v111 = 0;
  v112 = 1;
  do
  {
    v113 = v112;
    if ((*(_DWORD *)(v9 + 4 * v111 + 244) & 0x80000000) == 0)
    {
      v114 = v9 + 16 * v111;
      v116 = *(float *)(v114 + 96);
      v115 = (_OWORD *)(v114 + 96);
      v117 = v116;
      v118 = v8 + 16 * v111;
      v120 = *(float *)(v118 + 96);
      v119 = (_OWORD *)(v118 + 96);
      if (v117 != v120
        || *(float *)(v9 + 16 * v111 + 100) != *(float *)(v8 + 16 * v111 + 100)
        || (v121 = v9 + 16 * v111, v122 = v8 + 16 * v111, *(float *)(v121 + 104) != *(float *)(v122 + 104))
        || *(float *)(v121 + 108) != *(float *)(v122 + 108))
      {
        *v115 = *v119;
        ((void (*)(_QWORD))v7[614])(*v7);
      }
    }
    v112 = 0;
    v111 = 1;
  }
  while ((v113 & 1) != 0);
}

uint64_t CA::OGL::gl_shader_hash(unsigned int *a1)
{
  uint64_t v1;
  unsigned int v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  char v9;

  v1 = 0;
  v2 = *((unsigned __int16 *)a1 + 18);
  v3 = 33 * *a1 + a1[1] + (v2 >> 8);
  v4 = (v2 & 1) == 0;
  v5 = 33;
  if (v4)
    v5 = 0;
  v6 = 33 * *((unsigned __int8 *)a1 + 94) + *((unsigned __int8 *)a1 + 38) + 33 * (v3 + v5);
  do
  {
    v6 = 33 * v6 + *(unsigned __int16 *)((char *)a1 + v1 + 8);
    v1 += 2;
  }
  while (v1 != 26);
  v7 = 0;
  v8 = 1;
  do
  {
    v9 = v8;
    v6 = 33 * v6 + a1[8 * v7 + 70];
    v7 = 1;
    v8 = 0;
  }
  while ((v9 & 1) != 0);
  return v6;
}

uint64_t CA::OGL::gl_shader_compare(uint64_t a1, uint64_t a2)
{
  _BOOL8 v3;
  uint64_t v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (*(_DWORD *)a1 == *(_DWORD *)a2
    && *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4)
    && ((*(_WORD *)(a2 + 36) ^ *(_WORD *)(a1 + 36)) & 0xFF01) == 0
    && !((((*(unsigned __int16 *)(a2 + 36) | (*(unsigned __int8 *)(a2 + 38) << 16)) ^ (*(unsigned __int16 *)(a1 + 36) | (*(unsigned __int8 *)(a1 + 38) << 16))) & 0xFFFFFFu) >> 16)
    && *(unsigned __int8 *)(a1 + 94) == *(unsigned __int8 *)(a2 + 94))
  {
    v5 = 0;
    while (*(unsigned __int16 *)(a1 + 8 + v5) == *(unsigned __int16 *)(a2 + 8 + v5))
    {
      v5 += 2;
      if (v5 == 26)
      {
        v6 = 0;
        v7 = 1;
        do
        {
          v8 = a1 + 32 * v6;
          v9 = a2 + 32 * v6;
          v11 = *(_QWORD *)(v8 + 280);
          v10 = *(_QWORD *)(v8 + 288);
          v13 = *(_QWORD *)(v9 + 280);
          v12 = *(_QWORD *)(v9 + 288);
          v3 = v11 != v13 || v10 != v12;
          if ((v7 & 1) == 0)
            break;
          v7 = 0;
          v6 = 1;
        }
        while (!v3);
        return v3;
      }
    }
  }
  return 1;
}

char *CA::OGL::GLContext::create_shader(uint64_t a1, unsigned __int8 *a2, int a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  BOOL v10;
  int v11;
  unsigned int v12;
  void *v13;
  _BYTE *v14;
  uint64_t v15;
  int v16;
  unsigned __int8 *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t i;
  int v27;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned __int8 *v35;
  int v36;
  uint64_t j;
  int v38;
  int k;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unsigned __int8 *v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  int v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  NSObject *v65;
  int v66;
  int v67;
  const char *v68;
  int v69;
  char *v70;
  char *v71;
  char *v72;
  char *v73;
  int v74;
  int v75;
  char v76;
  _DWORD *v77;
  const char *v78;
  unsigned int v79;
  _DWORD *v80;
  NSObject *v81;
  int v82;
  int v83;
  void (*v84)(uint64_t, _QWORD, uint64_t, __int128 *, _QWORD);
  uint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  unsigned int v88;
  uint64_t v89;
  uint64_t i1;
  malloc_zone_t *malloc_zone;
  char *v92;
  char *v93;
  __int16 v94;
  uint64_t v95;
  _WORD *v96;
  __int16 *v97;
  __int16 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  uint64_t v103;
  _DWORD *v104;
  char **v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  int v109;
  int v110;
  uint64_t v111;
  __n128 v112;
  uint64_t v113;
  char v114;
  char v115;
  char *v116;
  int v117;
  uint64_t v118;
  char v119;
  char v120;
  char *v121;
  int v122;
  int v123;
  int v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t v129;
  unsigned int v130;
  char v131;
  int v132;
  unsigned int v133;
  unsigned __int16 *v134;
  uint64_t v135;
  int v136;
  const char *v137;
  int v138;
  unsigned __int8 v139;
  int v140;
  int v141;
  int v142;
  int v143;
  uint64_t v144;
  uint64_t v145;
  unsigned __int16 *v146;
  uint8_t *v147;
  uint64_t v148;
  int v149;
  int v150;
  const char *v151;
  const char *v152;
  int v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  int v160;
  uint64_t v161;
  int v162;
  int v163;
  uint64_t v164;
  int v165;
  uint64_t *v166;
  int v167;
  uint64_t v168;
  uint64_t v169;
  unsigned __int16 *v170;
  int v171;
  uint64_t m;
  unsigned int v173;
  BOOL v174;
  uint64_t v175;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  unsigned int v183;
  char *v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  char *v191;
  uint64_t v192;
  int v193;
  int n;
  const char **v195;
  unsigned int v196;
  size_t v197;
  const char **v198;
  unint64_t v199;
  size_t v200;
  unsigned int v201;
  char *v202;
  size_t v203;
  int v204;
  char *v205;
  size_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  char *v213;
  int v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  int v219;
  int v220;
  int v221;
  int ii;
  int v223;
  int jj;
  int v225;
  int kk;
  int v227;
  int mm;
  int v229;
  int nn;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  int v264;
  uint64_t v265;
  unsigned __int8 *v266;
  int v267;
  unsigned __int8 *v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  char *v276;
  unsigned int v277;
  int v278;
  uint64_t v279;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  uint64_t v409;
  uint64_t v410;
  uint64_t v411;
  uint64_t v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  uint64_t v425;
  uint64_t v426;
  char *v427;
  uint64_t v428;
  uint64_t v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  unsigned int v446;
  uint64_t v447;
  const char *v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  uint64_t v456;
  uint64_t v457;
  uint64_t v458;
  uint64_t v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  uint64_t v464;
  uint64_t v465;
  uint64_t v466;
  uint64_t v467;
  uint64_t v468;
  uint64_t v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  uint64_t v474;
  uint64_t v475;
  uint64_t v476;
  uint64_t v477;
  uint64_t v478;
  uint64_t v479;
  uint64_t v480;
  uint64_t v481;
  uint64_t v482;
  uint64_t v483;
  uint64_t v484;
  uint64_t v485;
  uint64_t v486;
  uint64_t v487;
  uint64_t v488;
  uint64_t v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  uint64_t v495;
  uint64_t v496;
  uint64_t v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  uint64_t v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  uint64_t v506;
  uint64_t v507;
  uint64_t v508;
  uint64_t v509;
  uint64_t v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  uint64_t v514;
  uint64_t v515;
  uint64_t v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  uint64_t v521;
  uint64_t v522;
  uint64_t v523;
  int v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  uint64_t v528;
  uint64_t v529;
  uint64_t v530;
  uint64_t v531;
  uint64_t v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  uint64_t v540;
  uint64_t v541;
  uint64_t v542;
  uint64_t v543;
  uint64_t v544;
  uint64_t v545;
  uint64_t v546;
  uint64_t v547;
  uint64_t v548;
  uint64_t v549;
  uint64_t v550;
  uint64_t v551;
  uint64_t v552;
  uint64_t v553;
  uint64_t v554;
  uint64_t v555;
  unsigned int v556;
  uint64_t v558;
  uint64_t v559;
  uint64_t v560;
  uint64_t v561;
  uint64_t v562;
  uint64_t v563;
  uint64_t v564;
  uint64_t v565;
  uint64_t v566;
  uint64_t v567;
  uint64_t v568;
  uint64_t v569;
  __int16 v570;
  int v571;
  int v572;
  int v573;
  uint64_t v574;
  char v575;
  uint64_t v576;
  uint64_t v577;
  int v578;
  int v579;
  uint64_t v580;
  uint64_t v581;
  uint64_t v582;
  int v583;
  int v584;
  unsigned int v585;
  int v586;
  unsigned int v587;
  void *v588;
  char *v589;
  void *v590;
  int v591;
  unsigned int v593;
  int v594;
  uint64_t v595;
  _QWORD *v596;
  uint64_t v597;
  unsigned __int8 *v598;
  int v599;
  char v600;
  unsigned __int8 *v601;
  uint64_t v602;
  _QWORD v603[2];
  __int128 v604;
  uint64_t v605;
  uint8_t buf[16];
  _OWORD v607[5];
  uint64_t v608;
  _QWORD v609[2];
  uint64_t v610;
  uint64_t v611;
  _QWORD v612[3];

  v4 = a1;
  v612[1] = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD **)(a1 + 2080);
  if (*(_QWORD *)(a1 + 1848))
  {
    *(_QWORD *)(a1 + 1848) = 0;
    ((void (*)(_QWORD, _QWORD))v5[601])(*v5, 0);
  }
  v6 = *a2;
  v7 = CA::OGL::tex_image_count[v6];
  if (a2[94])
    v8 = 7;
  else
    v8 = CA::OGL::tex_vertex_shader_indices[v6];
  v9 = byte_1ECDC6A6C;
  if (v8)
    v10 = 1;
  else
    v10 = (_DWORD)v7 == 0;
  v595 = *a2;
  v596 = v5;
  v597 = v4;
  v598 = a2;
  if (v10)
  {
LABEL_11:
    if (a2[94])
    {
LABEL_12:
      v11 = 0;
    }
    else
    {
      v12 = *(_DWORD *)(v4 + 4 * CA::OGL::tex_vertex_shader_indices[v6] + 1856);
      v11 = 1;
      if (v12)
        goto LABEL_101;
    }
  }
  else
  {
    v15 = 0;
    while (1)
    {
      v11 = 0;
      v16 = a2[v15 + 1];
      if (v16 == 22 || v16 == 40)
        break;
      if (((a2[39] >> v15) & 1) != 0)
        goto LABEL_12;
      if (v7 == ++v15)
        goto LABEL_11;
    }
  }
  v12 = ((uint64_t (*)(_QWORD, uint64_t))v5[595])(*v5, 35633);
  v588 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 1112))(v4);
  *(_QWORD *)&v604 = v588;
  v593 = v8;
  if (!v8)
  {
    if (v11)
      v17 = 0;
    else
      v17 = a2;
    memset(buf, 0, sizeof(buf));
    *(_QWORD *)&v607[0] = 0;
    if (v17)
    {
      v18 = *v17;
      v599 = CA::OGL::tex_fragment_shader_flags[v18];
      v19 = CA::OGL::tex_image_count[v18];
    }
    else
    {
      v19 = 0;
      LOBYTE(v599) = -1;
    }
    x_stream_write((uint64_t)buf, "uniform highp mat4 vertex_matrix;\n", 0x22uLL);
    x_stream_write((uint64_t)buf, "uniform highp vec4 texmat0, texmat1, texmat2;\n", 0x2EuLL);
    v585 = v12;
    v583 = v9;
    if (v17)
    {
      if ((*((_DWORD *)v17 + 63) & 0x80000000) == 0)
        x_stream_write((uint64_t)buf, "uniform highp vec4 texmatD;\n", 0x1CuLL);
      if ((*((_DWORD *)v17 + 65) & 0x80000000) != 0)
      {
LABEL_35:
        if (v17 && v19)
        {
          for (i = 0; i != v19; ++i)
          {
            v27 = v17[i + 1];
            if (v27 == 40 || v27 == 22)
              x_stream_printf((uint64_t)buf, "uniform highp vec4 chroma_matrix%d;\n", v20, v21, v22, v23, v24, v25, i);
          }
        }
        v579 = v19;
        x_stream_write((uint64_t)buf, "attribute highp vec4 vertex_position;\n", 0x26uLL);
        x_stream_write((uint64_t)buf, "attribute lowp vec4 vertex_color;\n", 0x22uLL);
        x_stream_write((uint64_t)buf, "attribute highp vec2 vertex_texcoord0, vertex_texcoord1;\n", 0x39uLL);
        x_stream_write((uint64_t)buf, "attribute mediump vec3 vertex_normal;\n", 0x26uLL);
        if ((v599 & 1) != 0)
          x_stream_write((uint64_t)buf, "varying lowp vec4 color;\n", 0x19uLL);
        v35 = v17;
        if (v17)
        {
          v36 = v11;
          if (v579)
          {
            for (j = 0; j != v579; ++j)
            {
              if (((v35[39] >> j) & 1) != 0)
                v38 = 4 * byte_184755BDC[v35[j + 1]];
              else
                v38 = byte_184755BDC[v35[j + 1]];
              if (v38)
              {
                for (k = 0; k != v38; ++k)
                  x_stream_printf((uint64_t)buf, "varying highp vec2 texcoord%d_%d;\n", v29, v30, v31, v32, v33, v34, j);
              }
            }
          }
          v12 = v585;
          if ((*((_DWORD *)v35 + 63) & 0x80000000) == 0)
            x_stream_write((uint64_t)buf, "varying highp vec3 texcoordD;\n", 0x1EuLL);
          v6 = v595;
          v11 = v36;
          if ((*((_DWORD *)v35 + 65) & 0x80000000) != 0)
          {
LABEL_63:
            x_stream_write((uint64_t)buf, "\nvoid main() {\n", 0xFuLL);
            x_stream_write((uint64_t)buf, "  gl_Position = vertex_matrix * vertex_position;\n", 0x31uLL);
            if ((v599 & 1) != 0)
              x_stream_write((uint64_t)buf, "  color = vertex_color;\n", 0x18uLL);
            if (v35)
            {
              v52 = v35;
              v581 = v7;
              if (v579)
              {
                v53 = 0;
                while (1)
                {
                  v54 = v52[v53 + 1];
                  if (((0x4200080000uLL >> v54) & 1) == 0)
                    break;
LABEL_84:
                  ++v53;
                  v52 = v35;
                  if (v53 == v579)
                    goto LABEL_85;
                }
                v55 = 0;
                if (byte_184755BDC[v54] <= 1u)
                  v56 = 1;
                else
                  v56 = byte_184755BDC[v54];
                while (1)
                {
                  if ((_DWORD)v54 == 40 || (_DWORD)v54 == 22)
                  {
                    if (!v55)
                      goto LABEL_82;
                    x_stream_printf((uint64_t)buf, "  texcoord%d_%d = texcoord%d_0 * chroma_matrix%d.xy + chroma_matrix%d.zw;\n",
                      v46,
                      v47,
                      v48,
                      v49,
                      v50,
                      v51,
                      v53);
                  }
                  else
                  {
                    if (((1 << v53) & v35[39]) != 0)
                    {
                      v57 = 0;
                      v58 = (char *)&unk_1847540E4;
                      do
                      {
                        x_stream_printf((uint64_t)buf, "  texcoord%d_%d = (vertex_texcoord%d + vec2(%g, %g)) * texmat%d.xy + texmat%d.zw;\n",
                          v46,
                          v47,
                          v48,
                          v49,
                          v50,
                          v51,
                          v53);
                        ++v57;
                        v58 += 8;
                      }
                      while (v57 != 4);
                      goto LABEL_83;
                    }
                    if (!v55)
                    {
LABEL_82:
                      x_stream_printf((uint64_t)buf, "  texcoord%d_0 = vertex_texcoord%d * texmat%d.xy + texmat%d.zw;\n",
                        v46,
                        v47,
                        v48,
                        v49,
                        v50,
                        v51,
                        v53);
                      goto LABEL_83;
                    }
                    x_stream_printf((uint64_t)buf, "  texcoord%d_%d = texcoord%d_0;\n",
                      v46,
                      v47,
                      v48,
                      v49,
                      v50,
                      v51,
                      v53);
                  }
LABEL_83:
                  if (++v55 == v56)
                    goto LABEL_84;
                }
              }
LABEL_85:
              if ((*((_DWORD *)v52 + 63) & 0x80000000) == 0)
                x_stream_write((uint64_t)buf, "  texcoordD = vec3(gl_Position.xy * texmatD.xy + texmatD.zw * gl_Position.w, gl_Position.w);\n",
                  0x5DuLL);
              v6 = v595;
              v7 = v581;
              v12 = v585;
              v9 = v583;
              if ((*((_DWORD *)v52 + 65) & 0x80000000) != 0)
              {
LABEL_91:
                x_stream_write((uint64_t)buf, "}\n", 2uLL);
                v14 = x_stream_finish((uint64_t)buf);
                v13 = v14;
                goto LABEL_92;
              }
            }
            else
            {
              x_stream_printf((uint64_t)buf, "  texcoord%d_0 = vertex_texcoord%d * texmat%d.xy + texmat%d.zw;\n",
                v46,
                v47,
                v48,
                v49,
                v50,
                v51,
                0);
              x_stream_printf((uint64_t)buf, "  texcoord%d_0 = vertex_texcoord%d * texmat%d.xy + texmat%d.zw;\n",
                v59,
                v60,
                v61,
                v62,
                v63,
                v64,
                1);
              x_stream_write((uint64_t)buf, "  texcoordD = vec3(gl_Position.xy * texmatD.xy + texmatD.zw * gl_Position.w, gl_Position.w);\n",
                0x5DuLL);
            }
            x_stream_write((uint64_t)buf, "  texcoordN = vec3(gl_Position.xy * texmatW.xy + texmatW.zw * gl_Position.w, gl_Position.w * float(NOISE_SIZE));\n",
              0x71uLL);
            goto LABEL_91;
          }
        }
        else
        {
          x_stream_printf((uint64_t)buf, "varying highp vec2 texcoord%d_0;\n", v29, v30, v31, v32, v33, v34, 0);
          x_stream_printf((uint64_t)buf, "varying highp vec2 texcoord%d_0;\n", v40, v41, v42, v43, v44, v45, 1);
          x_stream_write((uint64_t)buf, "varying highp vec3 texcoordD;\n", 0x1EuLL);
          v12 = v585;
        }
        x_stream_write((uint64_t)buf, "varying highp vec3 texcoordN;\n", 0x1EuLL);
        goto LABEL_63;
      }
    }
    else
    {
      x_stream_write((uint64_t)buf, "uniform highp vec4 texmatD;\n", 0x1CuLL);
    }
    x_stream_write((uint64_t)buf, "uniform highp vec4 texmatW;\n", 0x1CuLL);
    goto LABEL_35;
  }
  v13 = 0;
  v14 = (_BYTE *)CA::OGL::vertex_shaders[v8];
LABEL_92:
  *((_QWORD *)&v604 + 1) = v14;
  if (v9)
  {
    if (x_log_hook_p())
    {
      v558 = *(unsigned int *)a2;
      x_log_();
    }
    else
    {
      v65 = x_log_category_CADebug;
      if (os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_INFO))
      {
        v66 = *(_DWORD *)a2;
        v67 = *((_DWORD *)a2 + 1);
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v66;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v67;
        *(_WORD *)&buf[14] = 2080;
        *(_QWORD *)&v607[0] = v588;
        WORD4(v607[0]) = 2080;
        *(_QWORD *)((char *)v607 + 10) = v14;
        _os_log_impl(&dword_184457000, v65, OS_LOG_TYPE_INFO, "%08x %08x vertex shader:\n---\n%s%s---\n", buf, 0x22u);
      }
    }
  }
  v5 = v596;
  ((void (*)(_QWORD, _QWORD, uint64_t, __int128 *, _QWORD))v596[596])(*v596, v12, 2, &v604, 0);
  ((void (*)(_QWORD, _QWORD))v5[597])(*v5, v12);
  if (v13)
    free(v13);
  v4 = v597;
  if (v11)
    *(_DWORD *)(v597 + 4 * v593 + 1856) = v12;
LABEL_101:
  if (v6 > 0x2E || ((1 << v6) & 0x7A3FEC000000) == 0)
  {
    v125 = *a2;
    if (v125 > 0x65 || !CA::OGL::tex_fragment_shaders[v125])
      return 0;
    v126 = v4;
    v584 = v9;
    v587 = v12;
    v575 = v11;
    v127 = CA::OGL::tex_image_count[*a2];
    v611 = 0;
    v612[0] = 0;
    v609[1] = 0;
    v610 = 0;
    v609[0] = 0;
    if (v127)
    {
      v128 = 0;
      v129 = 0;
      v130 = 0;
      v131 = 0;
      v132 = 0;
      v133 = a2[39];
      v134 = (unsigned __int16 *)(a2 + 296);
      do
      {
        v135 = a2[v128 + 1];
        v136 = CA::OGL::image_fragment_shader_flags[v135];
        if ((v136 & 1) != 0)
          v137 = "mediump";
        else
          v137 = "lowp";
        v609[v128] = v137;
        v138 = CA::OGL::image_plane_count[v135];
        *((_DWORD *)v612 + v128) = v138;
        v139 = a2[v128 + 3];
        v140 = byte_184755BDC[v135];
        if (((v133 >> v128) & 1) != 0)
          v140 *= 4;
        *((_DWORD *)&v612[-1] + v128) = v140;
        *((_DWORD *)&v610 + v128) = v138;
        if (*((_DWORD *)v134 - 4))
        {
          v138 += *v134;
          *((_DWORD *)&v610 + v128) = v138;
        }
        v129 |= 1 << v135;
        v130 |= 1 << v139;
        v131 |= v136;
        v132 += v138;
        ++v128;
        v134 += 16;
        a2 = v598;
      }
      while (v127 != v128);
    }
    else
    {
      v132 = 0;
      v131 = 0;
      v130 = 0;
      v129 = 0;
    }
    if ((*((_DWORD *)a2 + 63) & 0x80000000) == 0)
      v132 += *((_DWORD *)a2 + 64);
    v12 = v587;
    v144 = v132 + (*((_DWORD *)a2 + 65) >= 0);
    if ((int)v144 > 13)
    {
      v594 = 0;
      v68 = 0;
      LOBYTE(v11) = v575;
      v4 = v126;
      goto LABEL_469;
    }
    v608 = 0;
    *(_OWORD *)buf = 0u;
    memset(v607, 0, sizeof(v607));
    v145 = v144;
    if ((int)v144 >= 1)
    {
      v146 = (unsigned __int16 *)(a2 + 8);
      v147 = buf;
      v148 = v145;
      do
      {
        v150 = *v146++;
        v149 = v150;
        if (v150 == 32879)
          v151 = "3D";
        else
          v151 = "2DRect";
        if (v149 == 3553)
          v152 = "2D";
        else
          v152 = v151;
        *(_QWORD *)v147 = v152;
        v147 += 8;
        --v148;
      }
      while (v148);
    }
    v604 = 0uLL;
    v605 = 0;
    if ((v131 & 2) != 0)
      x_stream_write((uint64_t)&v604, "#extension GL_OES_standard_derivatives : require\n\n", 0x32uLL);
    if (*((_DWORD *)a2 + 64) && (*((_DWORD *)a2 + 63) & 0x80000000) != 0)
      x_stream_write((uint64_t)&v604, "#extension GL_EXT_shader_framebuffer_fetch : require\n\n", 0x36uLL);
    v153 = CA::OGL::tex_fragment_shader_flags[*a2];
    v600 = CA::OGL::blend_modes[a2[37]];
    x_stream_write((uint64_t)&v604, "uniform highp vec4 texmat0, texmat1, texmat2;\n", 0x2EuLL);
    v570 = v153;
    if ((v153 & 4) != 0)
      x_stream_printf((uint64_t)&v604, "uniform lowp vec4 function_arg;\n", v154, v155, v156, v157, v158, v159, v558);
    v160 = a2[3];
    if (v160 == 5 || v160 == 3)
      x_stream_printf((uint64_t)&v604, "uniform lowp vec4 coord_arg;\n", v154, v155, v156, v157, v158, v159, v558);
    if ((*((_DWORD *)a2 + 65) & 0x80000000) == 0)
      x_stream_write((uint64_t)&v604, "uniform mediump float noise_scale;\n", 0x23uLL);
    v594 = v145;
    v582 = v7;
    v577 = v127;
    if ((_DWORD)v127)
    {
      v161 = 0;
      v162 = 0;
      do
      {
        v163 = *((_DWORD *)&v610 + v161);
        if (v163 >= 1)
        {
          v164 = v609[v161];
          v165 = v162;
          do
          {
            x_stream_printf((uint64_t)&v604, "uniform %s sampler%s texture%d;\n",
              v154,
              v155,
              v156,
              v157,
              v158,
              v159,
              v164);
            ++v165;
            --v163;
          }
          while (v163);
          v162 = v165;
        }
        ++v161;
      }
      while (v161 != v127);
    }
    else
    {
      v162 = 0;
    }
    if (v162 < v594)
    {
      v166 = (uint64_t *)&buf[8 * v162];
      v167 = v162;
      do
      {
        v168 = *v166++;
        x_stream_printf((uint64_t)&v604, "uniform lowp sampler%s texture%d;\n", v154, v155, v156, v157, v158, v159, v168);
        ++v167;
      }
      while (v594 != v167);
    }
    if ((v600 & 4) != 0)
    {
      x_stream_write((uint64_t)&v604, "uniform lowp vec4 blend_color0;\n", 0x20uLL);
      x_stream_write((uint64_t)&v604, "uniform lowp vec4 blend_color1;\n", 0x20uLL);
    }
    if ((_DWORD)v127)
    {
      v169 = 0;
      v170 = (unsigned __int16 *)(v598 + 294);
      do
      {
        v171 = *v170;
        v170 += 16;
        if (v171)
          x_stream_printf((uint64_t)&v604, "uniform mediump vec4 colorP%d[%d];\n",
            v154,
            v155,
            v156,
            v157,
            v158,
            v159,
            v169);
        ++v169;
      }
      while (v127 != v169);
      if ((v129 & 0x18000400000) != 0)
      {
        for (m = 0; m != v127; ++m)
        {
          v173 = v598[m + 1];
          v174 = v173 > 0x28;
          v175 = (1 << v173) & 0x18000400000;
          if (!v174 && v175 != 0)
          {
            x_stream_printf((uint64_t)&v604, "uniform mediump mat3 ycbcr_matrix%d;\n",
              v154,
              v155,
              v156,
              v157,
              v158,
              v159,
              m);
            x_stream_printf((uint64_t)&v604, "uniform mediump vec3 ycbcr_bias%d;\n",
              v177,
              v178,
              v179,
              v180,
              v181,
              v182,
              m);
          }
        }
      }
    }
    if ((v131 & 4) != 0)
      x_stream_printf((uint64_t)&v604, "uniform mediump vec4 render_state;\n", v154, v155, v156, v157, v158, v159, v558);
    v183 = *v598;
    if (v183 > 0x16)
    {
      LOBYTE(v11) = v575;
      if (*v598 > 0x2Fu)
      {
        v7 = v582;
        switch(v183)
        {
          case '0':
            x_stream_printf((uint64_t)&v604, "uniform lowp vec4 color_dodge;\n",
              v154,
              v155,
              v156,
              v157,
              v158,
              v159,
              v558);
            v191 = "uniform lowp vec4 color_lighten;\n";
            break;
          case '1':
            x_stream_printf((uint64_t)&v604, "uniform lowp vec4 color_burn;\n", v154, v155, v156, v157, v158, v159, v558);
            v191 = "uniform lowp vec4 color_darken;\n";
            break;
          case '4':
            v184 = "uniform lowp vec4 curves[4];\n";
            goto LABEL_262;
          default:
            goto LABEL_263;
        }
        x_stream_printf((uint64_t)&v604, v191, v185, v186, v187, v188, v189, v190, v559);
        v184 = "uniform lowp float reversed;\n";
LABEL_262:
        x_stream_printf((uint64_t)&v604, v184, v154, v155, v156, v157, v158, v159, v558);
        goto LABEL_263;
      }
      v7 = v582;
      if (v183 != 23)
      {
        if (v183 != 24)
          goto LABEL_263;
LABEL_258:
        v184 = "uniform lowp vec4 color_matrix[5];\n";
        goto LABEL_262;
      }
LABEL_257:
      v184 = "uniform lowp vec3 color_matrix[4];\n";
      goto LABEL_262;
    }
    v184 = "uniform lowp vec3 color_matrix[3];\n";
    LOBYTE(v11) = v575;
    if (*v598 > 0x13u)
    {
      v7 = v582;
      if (v183 == 20)
        goto LABEL_258;
      if (v183 == 22)
        goto LABEL_262;
    }
    else
    {
      v7 = v582;
      if (v183 == 18)
        goto LABEL_262;
      if (v183 == 19)
        goto LABEL_257;
    }
LABEL_263:
    if ((v570 & 1) != 0)
      x_stream_printf((uint64_t)&v604, "varying lowp vec4 color;\n", v154, v155, v156, v157, v158, v159, v558);
    if ((_DWORD)v127)
    {
      v192 = 0;
      do
      {
        v193 = *((_DWORD *)&v612[-1] + v192);
        if (v193 >= 1)
        {
          for (n = 0; n != v193; ++n)
            x_stream_printf((uint64_t)&v604, "varying highp vec2 texcoord%d_%d;\n",
              v154,
              v155,
              v156,
              v157,
              v158,
              v159,
              v192);
        }
        ++v192;
        v127 = v577;
      }
      while (v192 != v577);
    }
    a2 = v598;
    if ((*((_DWORD *)v598 + 63) & 0x80000000) == 0)
      x_stream_write((uint64_t)&v604, "varying highp vec3 texcoordD;\n", 0x1EuLL);
    v5 = v596;
    if ((*((_DWORD *)v598 + 65) & 0x80000000) == 0)
      x_stream_write((uint64_t)&v604, "varying highp vec3 texcoordN;\n", 0x1EuLL);
    if (v130)
    {
      v195 = (const char **)&CA::OGL::coord_fragment_functions;
      v196 = -3;
      do
      {
        if ((v130 & 1) != 0 && v196 >= 0xFFFFFFFE)
        {
          v197 = strlen(*v195);
          x_stream_write((uint64_t)&v604, (void *)*v195, v197);
        }
        ++v195;
        ++v196;
        v174 = v130 > 1;
        v130 >>= 1;
      }
      while (v174);
    }
    if (v129)
    {
      v198 = (const char **)&CA::OGL::image_fragment_functions;
      v199 = v129;
      do
      {
        if ((v199 & 1) != 0 && *v198)
        {
          v200 = strlen(*v198);
          x_stream_write((uint64_t)&v604, (void *)*v198, v200);
        }
        ++v198;
        v174 = v199 > 1;
        v199 >>= 1;
      }
      while (v174);
    }
    if (v600 & 0x10 | v570 & 0x20)
    {
      x_stream_write((uint64_t)&v604, "\nlowp vec4 mixLin(lowp vec4 D, lowp vec4 S, lowp vec4 M) {\n  D.rgb = D.rgb / max(D.a, .005);\n"
        "  D.rgb = D.rgb*D.rgb;\n"
        "  S.rgb = S.rgb / max(S.a, .005);\n"
        "  S.rgb = S.rgb*S.rgb;\n"
        "  lowp vec4 R = mix(D, S, M);\n"
        "  R.rgb = sqrt(max(R.rgb, 0.))*R.a;\n"
        "  return R;\n"
        "}\n",
        0xFDuLL);
      if ((v600 & 0x40) == 0)
      {
LABEL_289:
        if ((v600 & 0x20) == 0)
          goto LABEL_291;
        goto LABEL_290;
      }
    }
    else if ((v600 & 0x40) == 0)
    {
      goto LABEL_289;
    }
    x_stream_write((uint64_t)&v604, "\nlowp vec4 vibrantLightenSover(lowp vec4 S, lowp vec4 D) {\n  lowp float y = 1. - dot(D.rgb, vec3(.2125, .7154, .0721));\n"
      "  S = S * (y * y) * (y * y);\n"
      "  return D*(1. - S.a) + S;\n"
      "}\n"
      "\n"
      "lowp vec4 vibrantColorDodge(lowp vec4 S, lowp vec4 D) {\n"
      "  lowp vec4 R = D*(1. - S.a) + S*(1. - D.a);\n"
      "  R.rgb += mix(S.aaa, D.rgb*S.a*S.a/max(S.a - S.rgb, .005),\n"
      "               step(.005, S.a - S.rgb));\n"
      "  R.a += D.a*S.a;\n"
      "  R.rgb = clamp(R.rgb, 0.0, R.a);\n"
      "  return R;\n"
      "}\n"
      "\n"
      "lowp vec4 vibrantDark(lowp vec4 s0, lowp vec4 d0) {\n"
      "  return vibrantLightenSover(s0 * blend_color1,\n"
      "                             vibrantColorDodge(s0 * blend_color0, d0));\n"
      "}\n"
      "\n"
      "lowp vec4 vibrantDarkReversed(lowp vec4 s0, lowp vec4 d0) {\n"
      "  return vibrantColorDodge(s0 * blend_color0,\n"
      "                           vibrantLightenSover(s0 * blend_color1, d0));\n"
      "}\n",
      0x323uLL);
    x_stream_write((uint64_t)&v604, "\nlowp vec4 vibrantDarkenSover(lowp vec4 S, lowp vec4 D) {\n  lowp float y = dot(D.rgb, vec3(.2125, .7154, .0721));\n"
      "  S = S * (y * y) * (y * y);\n"
      "  return D*(1. - S.a) + S;\n"
      "}\n"
      "\n"
      "lowp vec4 vibrantColorBurn(lowp vec4 S, lowp vec4 D) {\n"
      "  lowp vec4 R = D*(1. - S.a) + S*(1. - D.a);\n"
      "  lowp float dasa = D.a*S.a;\n"
      "  R.rgb += step(.005, S.rgb)\n"
      "           * (dasa - S.a*S.a*(D.a - D.rgb)/max(S.rgb, .005));\n"
      "  R.a += dasa;\n"
      "  R.rgb = clamp(R.rgb, 0.0, R.a);\n"
      "  return R;\n"
      "}\n"
      "\n"
      "lowp vec4 vibrantLight(lowp vec4 s0, lowp vec4 d0) {\n"
      "  return vibrantDarkenSover(s0 * blend_color1,\n"
      "                            vibrantColorBurn(s0 * blend_color0, d0));\n"
      "}\n"
      "\n"
      "lowp vec4 vibrantLightReversed(lowp vec4 s0, lowp vec4 d0) {\n"
      "  return vibrantColorBurn(s0 * blend_color0,\n"
      "                          vibrantDarkenSover(s0 * blend_color1, d0));\n"
      "}\n",
      0x328uLL);
    if ((v600 & 0x20) == 0)
    {
LABEL_291:
      v201 = *v598;
      if (v201 > 0x2F)
      {
        switch(*v598)
        {
          case '0':
            v202 = "\n"
                   "lowp vec4 vibrantLightenSover(lowp vec4 S, lowp vec4 D) {\n"
                   "  lowp float y = 1. - dot(D.rgb, vec3(.2125, .7154, .0721));\n"
                   "  S = S * (y * y) * (y * y);\n"
                   "  return D*(1. - S.a) + S;\n"
                   "}\n"
                   "\n"
                   "lowp vec4 vibrantColorDodge(lowp vec4 S, lowp vec4 D) {\n"
                   "  lowp vec4 R = D*(1. - S.a) + S*(1. - D.a);\n"
                   "  R.rgb += mix(S.aaa, D.rgb*S.a*S.a/max(S.a - S.rgb, .005),\n"
                   "               step(.005, S.a - S.rgb));\n"
                   "  R.a += D.a*S.a;\n"
                   "  R.rgb = clamp(R.rgb, 0.0, R.a);\n"
                   "  return R;\n"
                   "}\n"
                   "\n"
                   "lowp vec4 vibrantDark(lowp vec4 s0, lowp vec4 d0) {\n"
                   "  if (reversed != 0.0)\n"
                   "    return vibrantColorDodge(s0 * color_dodge,\n"
                   "                               vibrantLightenSover(s0 * color_lighten, d0));\n"
                   "  else\n"
                   "    return vibrantLightenSover(s0 * color_lighten,\n"
                   "                               vibrantColorDodge(s0 * color_dodge, d0));\n"
                   "}\n";
            goto LABEL_302;
          case '1':
            v202 = "\n"
                   "lowp vec4 vibrantDarkenSover(lowp vec4 S, lowp vec4 D) {\n"
                   "  lowp float y = dot(D.rgb, vec3(.2125, .7154, .0721));\n"
                   "  S = S * (y * y) * (y * y);\n"
                   "  return D*(1. - S.a) + S;\n"
                   "}\n"
                   "\n"
                   "lowp vec4 vibrantColorBurn(lowp vec4 S, lowp vec4 D) {\n"
                   "  lowp vec4 R = D*(1. - S.a) + S*(1. - D.a);\n"
                   "  lowp float dasa = D.a*S.a;\n"
                   "  R.rgb += step(.005, S.rgb)\n"
                   "           * (dasa - S.a*S.a*(D.a - D.rgb)/max(S.rgb, .005));\n"
                   "  R.a += dasa;\n"
                   "  R.rgb = clamp(R.rgb, 0.0, R.a);\n"
                   "  return R;\n"
                   "}\n"
                   "\n"
                   "lowp vec4 vibrantLight(lowp vec4 s0, lowp vec4 d0) {\n"
                   "  if (reversed != 0.0)\n"
                   "    return vibrantColorBurn(s0 * color_burn,\n"
                   "                              vibrantDarkenSover(s0 * color_darken, d0));\n"
                   "  else\n"
                   "    return vibrantDarkenSover(s0 * color_darken,\n"
                   "                              vibrantColorBurn(s0 * color_burn, d0));\n"
                   "}\n";
LABEL_302:
            v203 = 780;
            goto LABEL_308;
          case '3':
            v202 = "\n"
                   "lowp vec4 luminanceCurve(lowp vec4 s0, lowp vec4 p, lowp float a) {\n"
                   "  lowp float x = dot(s0.rgb, vec3(.2125, .7154, .0721));\n"
                   "  x = clamp((((p.x * x) + p.y) * x + p.z) * x + p.w, 0.0, 1.0);\n"
                   "  return vec4(mix (s0.rgb, vec3 (x, x, x), a), s0.a);\n"
                   "}\n";
            v203 = 246;
            goto LABEL_308;
          case '4':
            v202 = "\n"
                   "lowp vec4 colorCurves(lowp vec4 s) {\n"
                   "  lowp float inv_a = 1.0 / max(s.a, 0.005);\n"
                   "  s.rgb *= inv_a;\n"
                   "  lowp vec4 r = (((curves[0] * s) + curves[1]) * s + curves[2]) * s + curves[3];  r.a = clamp(r.a, 0."
                   ", 1.);\n"
                   "  return vec4 (r.rgb * r.a, r.a);\n"
                   "}\n";
            goto LABEL_307;
          default:
            goto LABEL_309;
        }
      }
      switch(v201)
      {
        case 0x14u:
          v202 = "\n"
                 "lowp vec4 colorMatrix4x4Bias(lowp vec4 s) {\n"
                 "  s.rgb = s.rgb / max(s.a, .005);\n"
                 "  s = s.r * color_matrix[0] + s.g * color_matrix[1]\n"
                 "    + s.b * color_matrix[2] + s.a * color_matrix[3]\n"
                 "    + color_matrix[4];\n"
                 "  s.rgb = s.rgb * s.a;\n"
                 "  return s;\n"
                 "}\n";
          v203 = 243;
          break;
        case 0x18u:
          v202 = "\n"
                 "lowp vec4 colorMatrix4x4BiasDivideAlpha(lowp vec4 s) {\n"
                 "  s = vec4(s.rgb / s.a, 1.0);\n"
                 "  s = s.r * color_matrix[0] + s.g * color_matrix[1]\n"
                 "    + s.b * color_matrix[2] + color_matrix[3]\n"
                 "    + color_matrix[4];\n"
                 "  s.rgb = s.rgb * s.a;\n"
                 "  return s;\n"
                 "}\n";
LABEL_307:
          v203 = 244;
          break;
        case 0x19u:
          v202 = "\n"
                 "lowp vec4 perlinBias(lowp vec4 s, lowp float a) {\n"
                 "  s.rgb = s.rgb / (a * (s.a - s.rgb) + s.a);\n"
                 "  return s;\n"
                 "}\n";
          v203 = 110;
          break;
        default:
          goto LABEL_309;
      }
LABEL_308:
      x_stream_write((uint64_t)&v604, v202, v203);
LABEL_309:
      v204 = v598[37];
      if (v204 == 50)
      {
        v205 = "\n"
               "lowp vec4 lightenSover(lowp vec4 S, lowp vec4 D) {\n"
               "  lowp float y = 1. - dot(D.rgb, vec3(.2125, .7154, .0721));\n"
               "  S = S * (y * y) * (y * y);\n"
               "  return D*(1. - S.a) + S;\n"
               "}\n";
        v206 = 171;
      }
      else
      {
        if (v204 != 49)
        {
LABEL_314:
          x_stream_printf((uint64_t)&v604, "\nvoid main(void) {\n", v154, v155, v156, v157, v158, v159, v558);
          if ((CA::OGL::GLContext::assemble_fragment_shader(CA::OGL::GLShader const*,int *)::initialized & 1) == 0)
          {
            v213 = getenv("CA_EMPTY_SHADERS");
            if (v213)
              CA::OGL::GLContext::assemble_fragment_shader(CA::OGL::GLShader const*,int *)::empty_shaders = atoi(v213) != 0;
            CA::OGL::GLContext::assemble_fragment_shader(CA::OGL::GLShader const*,int *)::initialized = 1;
          }
          if (CA::OGL::GLContext::assemble_fragment_shader(CA::OGL::GLShader const*,int *)::empty_shaders)
          {
            x_stream_write((uint64_t)&v604, "  gl_FragData[0] = vec4(0.0);\n", 0x1EuLL);
            x_stream_write((uint64_t)&v604, "  return;\n}\n", 0xCuLL);
            v68 = x_stream_finish((uint64_t)&v604);
            v12 = v587;
            v9 = v584;
            v4 = v597;
            goto LABEL_469;
          }
          if ((_DWORD)v127 && v598[94])
            x_stream_write((uint64_t)&v604, "highp vec2 texcoord0_0 = vec2(gl_PointCoord.s, 1.0 - gl_PointCoord.t);\n",
              0x47uLL);
          if (v598[37] << 8 != 14848 || (v570 & 0x10) != 0 || (v129 & 0x4000000000) != 0)
          {
            v214 = *((_DWORD *)v598 + 64);
            if ((*((_DWORD *)v598 + 63) & 0x80000000) != 0)
            {
              if (v214)
              {
                v216 = 0;
                do
                {
                  x_stream_printf((uint64_t)&v604, "  lowp vec4 d%d = gl_LastFragData[%d];\n",
                    v207,
                    v208,
                    v209,
                    v210,
                    v211,
                    v212,
                    v216);
                  v216 = (v216 + 1);
                }
                while (v216 < *((_DWORD *)v598 + 64));
              }
            }
            else if (v214)
            {
              v215 = 0;
              do
              {
                x_stream_printf((uint64_t)&v604, "  lowp vec4 d%d = texture%sProj(texture%d, texcoordD);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v215);
                v215 = (v215 + 1);
              }
              while (v215 < *((_DWORD *)v598 + 64));
            }
          }
          v603[0] = 0;
          v603[1] = 0;
          v602 = 0;
          v217 = v597;
          if (!(_DWORD)v127)
          {
LABEL_455:
            if ((v570 & 0xC0) != 0)
            {
              if ((v570 & 0x80) != 0)
                x_stream_write((uint64_t)&v604, "  lowp vec4 s1 = color;\n", 0x18uLL);
              x_stream_write((uint64_t)&v604, "  lowp vec4 s2;\n", 0x10uLL);
              x_stream_write((uint64_t)&v604, "  {\n", 4uLL);
              x_stream_write((uint64_t)&v604, "    lowp vec4 S = s1, D = d0;\n", 0x1EuLL);
              CA::OGL::GLContext::inline_blend_function((uint64_t)&v604, a2[37], v511, v512, v513, v514, v515, v516);
              x_stream_write((uint64_t)&v604, "    s2 = R; s1 = d0;\n", 0x15uLL);
              x_stream_write((uint64_t)&v604, "  }\n", 4uLL);
            }
            v517 = v217;
            x_stream_printf((uint64_t)&v604, "  gl_FragData[0] = %s;\n",
              v207,
              v208,
              v209,
              v210,
              v211,
              v212,
              (uint64_t)CA::OGL::tex_fragment_shaders[*a2]);
            if (a2[37] << 8 != 14848 && (v570 & 0x1C0) == 0)
            {
              v524 = *((_DWORD *)a2 + 64);
              if (v524)
              {
                v525 = 0;
                do
                {
                  x_stream_write((uint64_t)&v604, "  {\n", 4uLL);
                  x_stream_printf((uint64_t)&v604, "    lowp vec4 S = gl_FragData[%d];\n",
                    v526,
                    v527,
                    v528,
                    v529,
                    v530,
                    v531,
                    v525);
                  x_stream_printf((uint64_t)&v604, "    lowp vec4 D = d%d;\n", v532, v533, v534, v535, v536, v537, v525);
                  CA::OGL::GLContext::inline_blend_function((uint64_t)&v604, a2[37], v538, v539, v540, v541, v542, v543);
                  x_stream_printf((uint64_t)&v604, "    gl_FragData[%d] = R;\n",
                    v544,
                    v545,
                    v546,
                    v547,
                    v548,
                    v549,
                    v525);
                  x_stream_write((uint64_t)&v604, "  }\n", 4uLL);
                  v525 = (v525 + 1);
                }
                while (v524 != (_DWORD)v525);
              }
            }
            if ((*((_DWORD *)a2 + 65) & 0x80000000) == 0)
            {
              x_stream_write((uint64_t)&v604, "  {\n", 4uLL);
              x_stream_printf((uint64_t)&v604, "    mediump vec3 n = texture%sProj(texture%d, texcoordN).xyz;\n",
                v550,
                v551,
                v552,
                v553,
                v554,
                v555,
                *(_QWORD *)&buf[8 * *((int *)a2 + 65)]);
              x_stream_write((uint64_t)&v604, "    n = (n - .5) * noise_scale;\n", 0x20uLL);
              x_stream_write((uint64_t)&v604, "    lowp vec3 c = gl_FragData[0].rgb + n*gl_FragData[0].a;\n", 0x3BuLL);
              x_stream_write((uint64_t)&v604, "    gl_FragData[0].rgb = clamp(c, 0., gl_FragData[0].a);\n", 0x39uLL);
              x_stream_write((uint64_t)&v604, "  }\n", 4uLL);
            }
            v556 = *((unsigned __int16 *)a2 + 18) | (a2[38] << 16);
            v5 = v596;
            LOBYTE(v11) = v575;
            v12 = v587;
            v9 = v584;
            if (v556 >= 0x10000)
              x_stream_printf((uint64_t)&v604, "gl_FragData[0] = %s;\n",
                v518,
                v519,
                v520,
                v521,
                v522,
                v523,
                CA::OGL::destination_shaders[HIWORD(v556)]);
            x_stream_write((uint64_t)&v604, "}\n", 2uLL);
            v68 = x_stream_finish((uint64_t)&v604);
            v4 = v517;
LABEL_469:
            v75 = 1;
            if (!v68)
              return 0;
            goto LABEL_116;
          }
          v218 = 0;
          v219 = 0;
          v220 = 0;
          do
          {
            switch(a2[v218 + 3])
            {
              case 0u:
                v603[v218] = "texcoord";
                break;
              case 1u:
                v603[v218] = "tc";
                v221 = *((_DWORD *)&v612[-1] + v218);
                if (v221 >= 1)
                {
                  for (ii = 0; ii != v221; ++ii)
                    x_stream_printf((uint64_t)&v604, "  mediump vec2 tc%d_%d = radialCoord(texcoord%d_%d);\n",
                      v207,
                      v208,
                      v209,
                      v210,
                      v211,
                      v212,
                      v218);
                }
                break;
              case 2u:
                v603[v218] = "tc";
                v223 = *((_DWORD *)&v612[-1] + v218);
                if (v223 >= 1)
                {
                  for (jj = 0; jj != v223; ++jj)
                    x_stream_printf((uint64_t)&v604, "  mediump vec2 tc%d_%d = conicCoord(texcoord%d_%d);\n",
                      v207,
                      v208,
                      v209,
                      v210,
                      v211,
                      v212,
                      v218);
                }
                break;
              case 3u:
                v603[v218] = "tc";
                v225 = *((_DWORD *)&v612[-1] + v218);
                if (v225 >= 1)
                {
                  for (kk = 0; kk != v225; ++kk)
                    x_stream_printf((uint64_t)&v604, "  mediump vec2 tc%d_%d = fract(texcoord%d_%d) * coord_arg.xy + coord_arg.zw;\n",
                      v207,
                      v208,
                      v209,
                      v210,
                      v211,
                      v212,
                      v218);
                }
                break;
              case 4u:
                if (!v218)
                  __assert_rtn("assemble_fragment_shader", "ogl-gl.cpp", 2210, "i > 0");
                if (v598[v218] && v598[v218] != 38)
                  __assert_rtn("assemble_fragment_shader", "ogl-gl.cpp", 2212, "key->function.f.image_func[i - 1] == OGL_IMAGE_IDENTITY || key->function.f.image_func[i - 1] == OGL_IMAGE_DEST");
                v603[v218] = "tlum";
                v227 = *((_DWORD *)&v612[-1] + v218);
                if (v227 >= 1)
                {
                  for (mm = 0; mm != v227; ++mm)
                    x_stream_printf((uint64_t)&v604, "  mediump vec2 tlum%d_%d = vec2(dot(%c%d.rgb, vec3(.2125, .7154, .0721)) * texcoord%d_%d.y + texcoord%d_%d.x, 0.5);\n",
                      v207,
                      v208,
                      v209,
                      v210,
                      v211,
                      v212,
                      v218);
                }
                break;
              case 5u:
                v603[v218] = "tc";
                v229 = *((_DWORD *)&v612[-1] + v218);
                if (v229 >= 1)
                {
                  for (nn = 0; nn != v229; ++nn)
                    x_stream_printf((uint64_t)&v604, "  mediump vec2 tc%d_%d = clamp(texcoord%d_%d, coord_arg.xy, coord_arg.zw);\n",
                      v207,
                      v208,
                      v209,
                      v210,
                      v211,
                      v212,
                      v218);
                }
                break;
              default:
                break;
            }
            v231 = *((unsigned int *)v612 + v218);
            a2 = v598;
            if ((int)v231 + v219 > v594)
              break;
            v571 = v598[v218 + 1];
            v573 = v219;
            if ((int)v231 >= 1)
            {
              v232 = 0;
              v590 = (void *)v609[v218];
              v578 = 1 << v218;
              if (v598[v218 + 1])
                v233 = 116;
              else
                v233 = 115;
              v576 = v218;
              do
              {
                if ((v578 & a2[39]) != 0)
                {
                  x_stream_printf((uint64_t)&v604, "  %s vec4 %c%d;\n",
                    v207,
                    v208,
                    v209,
                    v210,
                    v211,
                    v212,
                    (uint64_t)v590);
                  x_stream_write((uint64_t)&v604, "  {\n", 4uLL);
                  x_stream_write((uint64_t)&v604, "    highp vec4 f;\n", 0x12uLL);
                  if (*(_WORD *)&v598[2 * v573 + 8 + 2 * v232] == 3553)
                    x_stream_printf((uint64_t)&v604, "    f.xy = fract(%s%d_0 / texmat%d.xy);\n",
                      v234,
                      v235,
                      v236,
                      v237,
                      v238,
                      v239,
                      v603[v218]);
                  else
                    x_stream_printf((uint64_t)&v604, "    f.xy = fract(%s%d_0);\n",
                      v234,
                      v235,
                      v236,
                      v237,
                      v238,
                      v239,
                      v603[v218]);
                  x_stream_write((uint64_t)&v604, "    f.zw = vec2(1.) - f.xy;\n", 0x1CuLL);
                  x_stream_write((uint64_t)&v604, "    f = f.xzxz * f.yyww;\n", 0x19uLL);
                  x_stream_printf((uint64_t)&v604, "    %c%d = texture%s (texture%d, %s%d_%d) * f.w;\n",
                    v240,
                    v241,
                    v242,
                    v243,
                    v244,
                    v245,
                    v233);
                  x_stream_printf((uint64_t)&v604, "    %c%d = texture%s (texture%d, %s%d_%d) * f.z + %c%d;\n",
                    v246,
                    v247,
                    v248,
                    v249,
                    v250,
                    v251,
                    v233);
                  x_stream_printf((uint64_t)&v604, "    %c%d = texture%s (texture%d, %s%d_%d) * f.y + %c%d;\n",
                    v252,
                    v253,
                    v254,
                    v255,
                    v256,
                    v257,
                    v233);
                  x_stream_printf((uint64_t)&v604, "    %c%d = texture%s (texture%d, %s%d_%d) * f.x + %c%d;\n",
                    v258,
                    v259,
                    v260,
                    v261,
                    v262,
                    v263,
                    v233);
                  x_stream_write((uint64_t)&v604, "  }\n", 4uLL);
                  v7 = v582;
                  a2 = v598;
                  v218 = v576;
                }
                else
                {
                  x_stream_printf((uint64_t)&v604, "  %s vec4 %c%d = texture%s(texture%d, %s%d_%d);\n",
                    v207,
                    v208,
                    v209,
                    v210,
                    v211,
                    v212,
                    (uint64_t)v590);
                }
                ++v232;
              }
              while (v231 != v232);
            }
            *((_DWORD *)&v603[-1] + v218) = v220;
            v264 = v571 ? v231 : 0;
            v220 += v264;
            v219 = *((_DWORD *)&v610 + v218++) + v573;
            v127 = v577;
          }
          while (v218 != v577);
          v265 = 0;
          v217 = v597;
          while (1)
          {
            switch(a2[v265 + 1])
            {
              case 1u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = vec4(t%d.rgb, 1.);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 2u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = t%d.yxwz;\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 3u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = vec4(t%d.yxw, 1.);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 4u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = t%d.zyxw;\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 5u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = vec4(t%d.zyx, 1.);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 6u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = t%d.wzyx;\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 7u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = vec4(t%d.wzy, 1.);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 8u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = vec4(0., 0., 0., t%d.a);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 9u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = squareImage(%s%d_0);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 0xAu:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = circleImage(%s%d_0);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 0xBu:
              case 0xCu:
              case 0xDu:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = supercircleImage(%s%d_0);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 0x13u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = vec4(0.);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 0x14u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = vec4(t%d.r);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 0x15u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = vec4(t%d.a);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 0x16u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = vec4(clamp(ycbcr_matrix%d * vec3(t%d.r + ycbcr_bias%d.x, t%d.rg + ycbcr_bias%d.yz), 0., 1.), 1.);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 0x17u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = t%d*vec4(2.0) + vec4(-0.75);\n  s%d = vec4(s%d.zyx, 1.0);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 0x18u:
              case 0x19u:
              case 0x1Au:
              case 0x1Bu:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = renderImage(t%d.r);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 0x1Cu:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = vec4(1.) - t%d;\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 0x1Eu:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = vec4(t%d.rrr, 1.h);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 0x1Fu:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = t%d.rrrg;\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 0x21u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = vec4(1.0);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 0x22u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = t%d.gggg;\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 0x23u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = t%d.bbbb;\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 0x26u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = d0;\n", v207, v208, v209, v210, v211, v212, v265);
                break;
              case 0x27u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = vec4(clamp(ycbcr_matrix%d * vec3(t%d.yzw + ycbcr_bias%d.xyz), 0., 1.)*t%d.x , t%d.x);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              case 0x28u:
                x_stream_printf((uint64_t)&v604, "  lowp vec4 s%d = vec4(clamp(ycbcr_matrix%d * vec3(t%d.g + ycbcr_bias%d.x, t%d.rb + ycbcr_bias%d.yz), 0., 1.), 1.);\n",
                  v207,
                  v208,
                  v209,
                  v210,
                  v211,
                  v212,
                  v265);
                break;
              default:
                break;
            }
            v266 = &a2[32 * v265];
            v267 = *((_DWORD *)v266 + 70);
            if (!v267)
              goto LABEL_454;
            v268 = v266 + 280;
            v269 = v265;
            x_stream_write((uint64_t)&v604, "  {\n", 4uLL);
            v601 = v268;
            v574 = v265;
            if (*((_WORD *)v268 + 4) == 5)
              break;
            x_stream_printf((uint64_t)&v604, "    lowp vec3 c = s%d.rgb, t;\n", v270, v271, v272, v273, v274, v275, v265);
            v276 = "    c = c / max(s%d.a, .005);\n";
            if ((v267 & 0x80000000) == 0)
              goto LABEL_410;
LABEL_411:
            v572 = v267;
            v277 = v267 & 0x7FFFFFFF;
            if (v277)
            {
              v278 = 0;
              v591 = *((unsigned __int16 *)v268 + 5);
              v580 = v265;
              do
              {
                v279 = v277 & 0x1F;
                if ((v277 & 0x1F) > 7 || (_DWORD)v279 == 1)
                  v591 = *((unsigned __int16 *)v601 + 6);
                switch(v277 & 0x1F)
                {
                  case 1u:
                    x_stream_printf((uint64_t)&v604, "    c = c.r * colorP%d[%d].rgb + c.g * colorP%d[%d].rgb + c.b * colorP%d[%d].rgb + colorP%d[%d].rgb;\n",
                      v270,
                      v271,
                      v272,
                      v273,
                      v274,
                      v275,
                      v269);
                    break;
                  case 2u:
                    x_stream_printf((uint64_t)&v604, "    t = abs(c);\n", v270, v271, v272, v273, v274, v275, v560);
                    if (v591 > 3)
                    {
                      x_stream_printf((uint64_t)&v604, "    t = pow(t, colorP%d[%d].rgba);\n",
                        v281,
                        v282,
                        v283,
                        v284,
                        v285,
                        v286,
                        v269);
                      x_stream_printf((uint64_t)&v604, "    c.a = c.a < 0.0 ? t.a * -1.0 : t.a;",
                        v463,
                        v464,
                        v465,
                        v466,
                        v467,
                        v468,
                        v567);
                    }
                    else
                    {
                      x_stream_printf((uint64_t)&v604, "    t = pow(t, colorP%d[%d].rgb);\n",
                        v281,
                        v282,
                        v283,
                        v284,
                        v285,
                        v286,
                        v269);
                    }
                    v427 = "    c.r = c.r < 0.0 ? t.r * -1.0 : t.r; c.g = c.g < 0.0 ? t.g * -1.0 : t.g; c.b = c.b < 0.0 ?"
                           " t.b * -1.0 : t.b;\n";
                    goto LABEL_448;
                  case 3u:
                    x_stream_printf((uint64_t)&v604, "    t = abs(c);\n", v270, v271, v272, v273, v274, v275, v560);
                    x_stream_printf((uint64_t)&v604, "    t.r = t.r < -colorP%d[%d].r / colorP%d[%d].r ? 0.0 : pow (colorP%d[%d].r * t.r + colorP%d[%d].r, colorP%d[%d].r)\n", v293, v294, v295, v296, v297, v298, v269);
                    x_stream_printf((uint64_t)&v604, "    t.g = t.g < -colorP%d[%d].g / colorP%d[%d].g ? 0.0 : pow (colorP%d[%d].g * t.g + colorP%d[%d].g, colorP%d[%d].g)\n", v299, v300, v301, v302, v303, v304, v269);
                    x_stream_printf((uint64_t)&v604, "    t.b = t.b < -colorP%d[%d].b / colorP%d[%d].b ? 0.0 : pow (colorP%d[%d].b * t.b + colorP%d[%d].b, colorP%d[%d].b)\n", v305, v306, v307, v308, v309, v310, v269);
                    if (v591 == 4)
                    {
                      x_stream_printf((uint64_t)&v604, "    t.a = t.a < -colorP%d[%d].a / colorP%d[%d].a ? 0.0 : pow (colorP%d[%d].a * t.a + colorP%d[%d].a, colorP%d[%d].a)\n", v311, v312, v313, v314, v315, v316, v269);
                      x_stream_printf((uint64_t)&v604, "    c.a = c.a < 0.0 ? t.a * -1.0 : t.a;",
                        v317,
                        v318,
                        v319,
                        v320,
                        v321,
                        v322,
                        v563);
                    }
                    goto LABEL_436;
                  case 4u:
                    x_stream_printf((uint64_t)&v604, "    t = abs(c);\n", v270, v271, v272, v273, v274, v275, v560);
                    x_stream_printf((uint64_t)&v604, "    t.r = t.r < -colorP%d[%d].r / colorP%d[%d].r ? colorP%d[%d].r : pow (colorP%d[%d].r * t.r + colorP%d[%d].r, colorP%d[%d].r) + colorP%d[%d].r\n", v323, v324, v325, v326, v327, v328, v269);
                    x_stream_printf((uint64_t)&v604, "    t.g = t.g < -colorP%d[%d].g / colorP%d[%d].g ? colorP%d[%d].g : pow (colorP%d[%d].g * t.g + colorP%d[%d].g, colorP%d[%d].g) + colorP%d[%d].g\n", v329, v330, v331, v332, v333, v334, v269);
                    x_stream_printf((uint64_t)&v604, "    t.b = t.b < -colorP%d[%d].b / colorP%d[%d].b ? colorP%d[%d].b : pow (colorP%d[%d].b * t.b + colorP%d[%d].b, colorP%d[%d].b) + colorP%d[%d].b\n", v335, v336, v337, v338, v339, v340, v269);
                    if (v591 == 4)
                    {
                      x_stream_printf((uint64_t)&v604, "    t.a = t.a < -colorP%d[%d].a / colorP%d[%d].a ? colorP%d[%d].a : pow (colorP%d[%d].a * t.a + colorP%d[%d].a, colorP%d[%d].a) + colorP%d[%d].a\n", v311, v312, v313, v314, v315, v316, v269);
                      x_stream_printf((uint64_t)&v604, "    c.a = c.a < 0.0 ? t.a * -1.0 : t.a;",
                        v341,
                        v342,
                        v343,
                        v344,
                        v345,
                        v346,
                        v564);
                    }
                    goto LABEL_436;
                  case 5u:
                    x_stream_printf((uint64_t)&v604, "    t = abs(c);\n", v270, v271, v272, v273, v274, v275, v560);
                    x_stream_printf((uint64_t)&v604, "    t.r = t.r < colorP%d[%d].r ? colorP%d[%d].r * t.r : pow(colorP%d[%d].r * t.r + colorP%d[%d].r,colorP%d[%d].r);\n",
                      v347,
                      v348,
                      v349,
                      v350,
                      v351,
                      v352,
                      v269);
                    x_stream_printf((uint64_t)&v604, "    t.g = t.g < colorP%d[%d].g ? colorP%d[%d].g * t.g : pow(colorP%d[%d].g * t.g + colorP%d[%d].g,colorP%d[%d].g);\n",
                      v353,
                      v354,
                      v355,
                      v356,
                      v357,
                      v358,
                      v269);
                    x_stream_printf((uint64_t)&v604, "    t.b = t.b < colorP%d[%d].b ? colorP%d[%d].b * t.b : pow(colorP%d[%d].b * t.b + colorP%d[%d].b,colorP%d[%d].b);\n",
                      v359,
                      v360,
                      v361,
                      v362,
                      v363,
                      v364,
                      v269);
                    if (v591 != 4)
                      goto LABEL_436;
                    x_stream_printf((uint64_t)&v604, "    t.a = t.a < colorP%d[%d].a ? colorP%d[%d].a * t.a : pow(colorP%d[%d].a * t.a + colorP%d[%d].a,colorP%d[%d].a);\n",
                      v311,
                      v312,
                      v313,
                      v314,
                      v315,
                      v316,
                      v269);
                    goto LABEL_435;
                  case 6u:
                    x_stream_printf((uint64_t)&v604, "    t = abs(c);\n", v270, v271, v272, v273, v274, v275, v560);
                    x_stream_printf((uint64_t)&v604, "    t.r = t.r < colorP%d[%d].r ? colorP%d[%d].r * t.r + colorP%d[%d].r : pow (colorP%d[%d].r * t.r + colorP%d[%d].r, colorP%d[%d].r) + colorP%d[%d].r;\n",
                      v428,
                      v429,
                      v430,
                      v431,
                      v432,
                      v433,
                      v580);
                    x_stream_printf((uint64_t)&v604, "    t.g = t.g < colorP%d[%d].g ? colorP%d[%d].g * t.g + colorP%d[%d].g : pow (colorP%d[%d].g * t.g + colorP%d[%d].g, colorP%d[%d].g) + colorP%d[%d].g;\n",
                      v434,
                      v435,
                      v436,
                      v437,
                      v438,
                      v439,
                      v580);
                    v269 = v580;
                    x_stream_printf((uint64_t)&v604, "    t.b = t.b < colorP%d[%d].b ? colorP%d[%d].b * t.b + colorP%d[%d].b : pow (colorP%d[%d].b * t.b + colorP%d[%d].b, colorP%d[%d].b) + colorP%d[%d].b;\n",
                      v440,
                      v441,
                      v442,
                      v443,
                      v444,
                      v445,
                      v580);
                    if (v591 != 4)
                      goto LABEL_436;
                    x_stream_printf((uint64_t)&v604, "    t.a = t.a < colorP%d[%d].a ? colorP%d[%d].a * t.a + colorP%d[%d].a : pow (colorP%d[%d].a * t.a + colorP%d[%d].a, colorP%d[%d].a) + colorP%d[%d].a;\n",
                      v311,
                      v312,
                      v313,
                      v314,
                      v315,
                      v316,
                      v580);
LABEL_435:
                    x_stream_printf((uint64_t)&v604, "    c.a = c.a < 0.0 ? t.a * -1.0 : t.a;",
                      v365,
                      v366,
                      v367,
                      v368,
                      v369,
                      v370,
                      v565);
LABEL_436:
                    x_stream_printf((uint64_t)&v604, "    c.r = c.r < 0.0 ? t.r * -1.0: t.r; c.g = c.g < 0.0 ? t.g * -1.0 : t.g; c.b = c.b < 0.0 ? t.b * -1.0 : t.b;\n",
                      v311,
                      v312,
                      v313,
                      v314,
                      v315,
                      v316,
                      v562);
                    break;
                  case 7u:
                    v446 = v591 - 1;
                    if (v591 >= 1)
                    {
                      if (v446 >= 3)
                        v446 = 3;
                      v447 = v446 + 1;
                      v448 = "xyzw";
                      do
                      {
                        v449 = *v448++;
                        x_stream_printf((uint64_t)&v604, "    c.%c = texture2D(texture%d, vec2(c.%c*colorP%d[%d].%c, colorP%d[%d].%c)).r;\n",
                          v270,
                          v271,
                          v272,
                          v273,
                          v274,
                          v275,
                          v449);
                        --v447;
                      }
                      while (v447);
                    }
                    break;
                  case 8u:
                    v371 = v601[19];
                    x_stream_printf((uint64_t)&v604, "    mediump vec2 c_st = vec2(c.r * colorP%d[%d].x + colorP%d[%d].y, 0.5);\n",
                      v270,
                      v271,
                      v272,
                      v273,
                      v274,
                      v275,
                      v269);
                    x_stream_printf((uint64_t)&v604, "    c = texture2D(texture%d, c_st).rgb;\n",
                      v372,
                      v373,
                      v374,
                      v375,
                      v376,
                      v377,
                      v371);
                    break;
                  case 9u:
                    v450 = v601[19];
                    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)v597 + 184))(v597, 16))
                    {
                      x_stream_printf((uint64_t)&v604, "    c = c * colorP%d[%d].x + colorP%d[%d].y;\n",
                        v451,
                        v452,
                        v453,
                        v454,
                        v455,
                        v456,
                        v269);
                      x_stream_printf((uint64_t)&v604, "    c = texture3D(texture%d, c).rgb;\n",
                        v457,
                        v458,
                        v459,
                        v460,
                        v461,
                        v462,
                        v450);
                    }
                    else
                    {
                      x_stream_printf((uint64_t)&v604, "    c.b = c.b * colorP%d[%d].z;\n",
                        v451,
                        v452,
                        v453,
                        v454,
                        v455,
                        v456,
                        v269);
                      x_stream_printf((uint64_t)&v604, "    lowp float b_mix = fract(c.b);\n",
                        v469,
                        v470,
                        v471,
                        v472,
                        v473,
                        v474,
                        v568);
                      x_stream_printf((uint64_t)&v604, "    c.b = floor(c.b) * colorP%d[%d].w;\n",
                        v475,
                        v476,
                        v477,
                        v478,
                        v479,
                        v480,
                        v269);
                      x_stream_printf((uint64_t)&v604, "    mediump vec2 c_st = vec2(c.r, c.g);\n",
                        v481,
                        v482,
                        v483,
                        v484,
                        v485,
                        v486,
                        v569);
                      x_stream_printf((uint64_t)&v604, "    c_st.r = c_st.r * colorP%d[%d].x + colorP%d[%d].y;\n",
                        v487,
                        v488,
                        v489,
                        v490,
                        v491,
                        v492,
                        v269);
                      x_stream_printf((uint64_t)&v604, "    c_st.g = c_st.g * colorP%d[%d].x * colorP%d[%d].w + colorP%d[%d].y * colorP%d[%d].w + c.b;\n",
                        v493,
                        v494,
                        v495,
                        v496,
                        v497,
                        v498,
                        v269);
                      x_stream_printf((uint64_t)&v604, "    lowp vec3 c0 = texture2D(texture%d, c_st).rgb;\n",
                        v499,
                        v500,
                        v501,
                        v502,
                        v503,
                        v504,
                        v450);
                      x_stream_printf((uint64_t)&v604, "    lowp vec3 c1 = texture2D(texture%d, c_st + vec2(0., colorP%d[%d].w)).rgb;\n",
                        v505,
                        v506,
                        v507,
                        v508,
                        v509,
                        v510,
                        v450);
                      v427 = "    c = mix(c0, c1, b_mix);\n";
LABEL_448:
                      x_stream_printf((uint64_t)&v604, v427, v287, v288, v289, v290, v291, v292, v561);
                    }
                    break;
                  case 0xAu:
                    v378 = v601[19];
                    x_stream_printf((uint64_t)&v604, "    mediump vec3 c_stp = c.rgb;\n",
                      v270,
                      v271,
                      v272,
                      v273,
                      v274,
                      v275,
                      v560);
                    x_stream_printf((uint64_t)&v604, "    c.a = c.a * colorP%d[%d].z;\n",
                      v379,
                      v380,
                      v381,
                      v382,
                      v383,
                      v384,
                      v269);
                    x_stream_printf((uint64_t)&v604, "    lowp float a_mix = fract(c.a);\n",
                      v385,
                      v386,
                      v387,
                      v388,
                      v389,
                      v390,
                      v566);
                    x_stream_printf((uint64_t)&v604, "    c.a = floor(c.a) * colorP%d[%d].w;\n",
                      v391,
                      v392,
                      v393,
                      v394,
                      v395,
                      v396,
                      v269);
                    x_stream_printf((uint64_t)&v604, "    c_stp.r = c_stp.r * colorP%d[%d].x + colorP%d[%d].y;\n",
                      v397,
                      v398,
                      v399,
                      v400,
                      v401,
                      v402,
                      v269);
                    x_stream_printf((uint64_t)&v604, "    c_stp.g = c_stp.g * colorP%d[%d].x + colorP%d[%d].y;\n",
                      v403,
                      v404,
                      v405,
                      v406,
                      v407,
                      v408,
                      v269);
                    x_stream_printf((uint64_t)&v604, "    c_stp.b = c_stp.b * colorP%d[%d].x * colorP%d[%d].w + colorP%d[%d].y * colorP%d[%d].w + c.a;\n",
                      v409,
                      v410,
                      v411,
                      v412,
                      v413,
                      v414,
                      v269);
                    x_stream_printf((uint64_t)&v604, "    lowp vec3 c0 = texture3D(texture%d, c_stp).rgb;\n",
                      v415,
                      v416,
                      v417,
                      v418,
                      v419,
                      v420,
                      v378);
                    x_stream_printf((uint64_t)&v604, "    lowp vec3 c1 = texture3D(texture%d, c_stp + vec3(0., 0., colorP%d[%d].w)).rgb;\n",
                      v421,
                      v422,
                      v423,
                      v424,
                      v425,
                      v426,
                      v378);
                    v427 = "    c = vec4(mix(c0, c1, a_mix), 1.);\n";
                    goto LABEL_448;
                  default:
                    break;
                }
                v278 += CA::ColorProgram::kOpcodeParamCount[v279];
                v174 = v277 > 0x1F;
                v277 >>= 5;
              }
              while (v174);
            }
            if (v572 < 0)
              x_stream_printf((uint64_t)&v604, "    s%d = vec4(c.rgb, 1.);\n", v270, v271, v272, v273, v274, v275, v269);
            else
              x_stream_printf((uint64_t)&v604, "    s%d.rgb = c * s%d.a;\n", v270, v271, v272, v273, v274, v275, v269);
            a2 = v598;
            v127 = v577;
            v265 = v574;
            x_stream_write((uint64_t)&v604, "  }\n", 4uLL);
            v217 = v597;
            v7 = v582;
LABEL_454:
            if (++v265 == v127)
              goto LABEL_455;
          }
          v276 = "    lowp vec4 c = s%d, t;\n";
          if ((v267 & 0x80000000) == 0)
            __assert_rtn("inline_color_shader", "ogl-gl.cpp", 1608, "opaque && \"4DLUT must be opaque!\"");
LABEL_410:
          x_stream_printf((uint64_t)&v604, v276, v270, v271, v272, v273, v274, v275, v265);
          goto LABEL_411;
        }
        v205 = "\n"
               "lowp vec4 darkenSover(lowp vec4 S, lowp vec4 D) {\n"
               "  lowp float y = dot(D.rgb, vec3(.2125, .7154, .0721));\n"
               "  S = S * (y * y) * (y * y);\n"
               "  return D*(1. - S.a) + S;\n"
               "}\n";
        v206 = 165;
      }
      x_stream_write((uint64_t)&v604, v205, v206);
      goto LABEL_314;
    }
LABEL_290:
    x_stream_write((uint64_t)&v604, "\nlowp vec3 colorSort(lowp vec3 c) {\n  lowp vec3 cs = (c.r > c.g) ? c : c.grb;\n"
      "  cs = (cs.g > cs.b) ? cs : cs.rbg;\n"
      "  cs = (cs.r > cs.g) ? cs : cs.grb;\n"
      "  return cs;\n"
      "}\n"
      "\n"
      "lowp float lum(lowp vec3 c) {\n"
      "  return dot(c, vec3(0.3, 0.59, 0.11));\n"
      "}\n"
      "\n"
      "lowp vec3 clipColor(lowp vec3 c) {\n"
      "  lowp float l = lum(c);\n"
      "  lowp vec3 cs = colorSort(c);\n"
      "  c = cs.b < 0.0 ? l + (c - l) * (l / (l - cs.b)) : c;\n"
      "  c = cs.r > 1.0 ? l + (c - l) * ((1.0 - l) / (cs.r - l)) : c;\n"
      "  return c;\n"
      "}\n"
      "\n"
      "lowp vec3 setLum(lowp vec3 c, lowp float l) {\n"
      "  lowp float d = l - lum(c);\n"
      "  return clipColor(c + d);\n"
      "}\n"
      "\n"
      "lowp float sat(lowp vec3 c) {\n"
      "  lowp vec3 cs = colorSort(c);\n"
      "  return cs.r - cs.b;\n"
      "}\n"
      "\n"
      "lowp vec3 setSat(lowp vec3 c, lowp float s) {\n"
      "  lowp vec3 cs = colorSort(c);\n"
      "  lowp vec3 fmax = cs.r == c.r ? vec3(1.,0.,0.) :    cs.r == c.g ? vec3(0.,1.,0.) : vec3(0.,0.,1.);\n"
      "  c = c - fmax * c;\n"
      "  lowp vec3 fmid = cs.g == c.r ? vec3(1.,0.,0.) :    cs.g == c.g ? vec3(0.,1.,0.) : vec3(0.,0.,1.);\n"
      "  c = cs.r > cs.b ? fmax * s + fmid * ((cs.g - cs.b) * s / (cs.r - cs.b)) :    vec3(0.0);\n"
      "  return c;\n"
      "}\n",
      0x41FuLL);
    goto LABEL_291;
  }
  v68 = CA::OGL::tex_fragment_shaders[v6];
  if ((v6 - 44) >= 3)
    v69 = 1;
  else
    v69 = 2;
  v594 = v69;
  if (*((_WORD *)a2 + 4) == 3553)
  {
    v70 = strdup(v68);
    if (v70)
    {
      v71 = v70;
      while (1)
      {
        v72 = strstr(v70, "2DRect");
        if (!v72)
          break;
        v73 = v72;
        v74 = v72[6];
        v70 = v72 + 6;
        if ((v74 | 8) == 0x28)
          v73[2] = 32;
        *(_WORD *)(v73 + 3) = 8224;
        v73[5] = 32;
      }
      v75 = 1;
      v68 = v71;
      a2 = v598;
      goto LABEL_116;
    }
    return 0;
  }
  v75 = 0;
  if (!v68)
    return 0;
LABEL_116:
  v586 = v75;
  v76 = v11;
  v77 = a2;
  v78 = v68;
  v79 = ((uint64_t (*)(_QWORD, uint64_t))v5[595])(*v5, 35632);
  v604 = 0uLL;
  *(_QWORD *)&v604 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 1112))(v4);
  *((_QWORD *)&v604 + 1) = v78;
  v589 = (char *)v78;
  v80 = v77;
  if (v9)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v81 = x_log_category_CADebug;
      if (os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_INFO))
      {
        v82 = *v77;
        v83 = v77[1];
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v82;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v83;
        *(_WORD *)&buf[14] = 2080;
        *(_QWORD *)&v607[0] = v604;
        WORD4(v607[0]) = 2080;
        *(_QWORD *)((char *)v607 + 10) = *((_QWORD *)&v604 + 1);
        _os_log_impl(&dword_184457000, v81, OS_LOG_TYPE_INFO, "%08x %08x fragment shader:\n---\n%s%s---\n", buf, 0x22u);
      }
    }
  }
  v84 = (void (*)(uint64_t, _QWORD, uint64_t, __int128 *, _QWORD))v5[596];
  v85 = *v5;
  v86 = v5;
  v87 = v79;
  v84(v85, v79, 2, &v604, 0);
  ((void (*)(_QWORD, _QWORD))v86[597])(*v86, v79);
  v88 = ((uint64_t (*)(_QWORD))v86[598])(*v86);
  v89 = v88;
  ((void (*)(_QWORD, _QWORD, _QWORD))v86[599])(*v86, v88, v12);
  ((void (*)(_QWORD, _QWORD, uint64_t))v86[599])(*v86, v88, v87);
  for (i1 = 0; i1 != 5; ++i1)
    ((void (*)(_QWORD, _QWORD, uint64_t, char *))v86[631])(*v86, v88, i1, CA::OGL::vertex_attribute_names[i1]);
  ((void (*)(_QWORD, _QWORD))v86[600])(*v86, v88);
  if ((v76 & 1) == 0)
    ((void (*)(_QWORD, _QWORD))v86[592])(*v86, v12);
  ((void (*)(_QWORD, uint64_t))v86[592])(*v86, v87);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v92 = (char *)malloc_type_zone_malloc(malloc_zone, 0x1A0uLL, 0x8BB15036uLL);
  v93 = v92;
  *(_DWORD *)v92 = *v80;
  *((_DWORD *)v92 + 1) = v80[1];
  v94 = *((_WORD *)v92 + 18) | (*((unsigned __int8 *)v80 + 37) << 8);
  *((_WORD *)v92 + 18) = v94;
  *((_WORD *)v92 + 18) = v94 & 0xFF00 | v80[9] & 1;
  *((_DWORD *)v92 + 65) = v80[65];
  if (a3 < 1)
    goto LABEL_129;
  v95 = a3;
  v96 = v92 + 8;
  v97 = (__int16 *)(v80 + 2);
  do
  {
    v98 = *v97++;
    *v96++ = v98;
    --v95;
  }
  while (v95);
  if (a3 <= 12)
LABEL_129:
    bzero(&v92[2 * a3 + 8], 2 * (12 - a3) + 2);
  v93[34] = a3;
  v93[35] = v7;
  v99 = *(_OWORD *)(v80 + 70);
  v100 = *(_OWORD *)(v80 + 74);
  v101 = *(_OWORD *)(v80 + 82);
  *(_OWORD *)(v93 + 312) = *(_OWORD *)(v80 + 78);
  *(_OWORD *)(v93 + 328) = v101;
  *(_OWORD *)(v93 + 280) = v99;
  *(_OWORD *)(v93 + 296) = v100;
  *((_DWORD *)v93 + 14) = v88;
  *(_OWORD *)(v93 + 60) = 0u;
  *(_OWORD *)(v93 + 76) = 0u;
  v93[94] = *((_BYTE *)v80 + 94);
  *((_DWORD *)v93 + 102) = 0;
  *((_OWORD *)v93 + 7) = 0u;
  *((_OWORD *)v93 + 8) = 0u;
  *((_OWORD *)v93 + 6) = 0u;
  *(_OWORD *)(v93 + 216) = 0u;
  *(_OWORD *)(v93 + 200) = 0u;
  *(_OWORD *)(v93 + 184) = 0u;
  *(_OWORD *)(v93 + 168) = 0u;
  ((void (*)(_QWORD, _QWORD))v596[601])(*v596, v88);
  if (v594 >= 1)
  {
    v102 = 0;
    do
    {
      *(_OWORD *)buf = 0u;
      v607[0] = 0u;
      snprintf((char *)buf, 0x20uLL, "texture%d", v102);
      v103 = ((uint64_t (*)(_QWORD, _QWORD, uint8_t *))v596[626])(*v596, v88, buf);
      ((void (*)(_QWORD, uint64_t, uint64_t))v596[607])(*v596, v103, v102);
      v102 = (v102 + 1);
    }
    while (v594 != (_DWORD)v102);
  }
  *(_QWORD *)(v93 + 252) = *(_QWORD *)(v598 + 252);
  v93[38] = v598[38];
  *((_DWORD *)v93 + 58) = ((uint64_t (*)(_QWORD, _QWORD, const char *))v596[626])(*v596, v88, "vertex_matrix");
  *((_DWORD *)v93 + 59) = ((uint64_t (*)(_QWORD, _QWORD, const char *))v596[626])(*v596, v88, "blend_color0");
  *((_DWORD *)v93 + 60) = ((uint64_t (*)(_QWORD, _QWORD, const char *))v596[626])(*v596, v88, "blend_color1");
  if (!(_DWORD)v7)
    goto LABEL_476;
  v104 = v93 + 244;
  v105 = CA::OGL::GLContext::create_shader(CA::OGL::ContextState const*,CA::OGL::GLShader const*,int)::names;
  v106 = v7;
  do
  {
    v107 = (uint64_t)*v105++;
    *v104++ = ((uint64_t (*)(_QWORD, _QWORD, uint64_t))v596[626])(*v596, v88, v107);
    --v106;
  }
  while (v106);
  if (v7 <= 1)
  {
LABEL_476:
    do
    {
      v108 = v7;
      *(_DWORD *)&v93[4 * v7 + 244] = -1;
      v7 = 1;
    }
    while (!v108);
  }
  if ((*((_DWORD *)v93 + 63) & 0x80000000) != 0)
    v109 = -1;
  else
    v109 = ((uint64_t (*)(_QWORD, _QWORD, const char *))v596[626])(*v596, v88, "texmatD");
  *((_DWORD *)v93 + 67) = v109;
  if ((*((_DWORD *)v93 + 65) & 0x80000000) != 0)
  {
    v110 = -1;
    *((_DWORD *)v93 + 66) = -1;
  }
  else
  {
    *((_DWORD *)v93 + 66) = ((uint64_t (*)(_QWORD, _QWORD, const char *))v596[626])(*v596, v88, "noise_scale");
    v110 = ((uint64_t (*)(_QWORD, _QWORD, const char *))v596[626])(*v596, v88, "texmatW");
  }
  *((_DWORD *)v93 + 68) = v110;
  v111 = 96;
  v112 = (__n128)xmmword_18474E5A0;
  do
  {
    *(_OWORD *)&v93[v111] = xmmword_18474E5A0;
    v111 += 16;
  }
  while (v111 != 144);
  v113 = 0;
  v114 = 1;
  do
  {
    v115 = v114;
    v116 = &v93[32 * v113];
    *((_DWORD *)v116 + 75) = 0;
    if (*((_WORD *)v116 + 147))
    {
      v117 = ((uint64_t (*)(_QWORD, _QWORD, char *, __n128))v596[626])(*v596, v88, CA::OGL::GLContext::create_shader(CA::OGL::ContextState const*,CA::OGL::GLShader const*,int)::names[v113], v112);
      v112 = (__n128)xmmword_18474E5A0;
    }
    else
    {
      v117 = -1;
    }
    v114 = 0;
    *((_DWORD *)v116 + 76) = v117;
    v113 = 1;
  }
  while ((v115 & 1) != 0);
  v118 = 0;
  v119 = 1;
  do
  {
    v120 = v119;
    v93[v118 + 344] = 0;
    *(__n128 *)&v93[16 * v118 + 348] = v112;
    v121 = &v93[4 * v118];
    *((_DWORD *)v121 + 95) = ((uint64_t (*)(_QWORD, uint64_t, char *))v596[626])(*v596, v89, CA::OGL::GLContext::create_shader(CA::OGL::ContextState const*,CA::OGL::GLShader const*,int)::ycbcr_names[v118]);
    *((_DWORD *)v121 + 97) = ((uint64_t (*)(_QWORD, uint64_t, char *))v596[626])(*v596, v89, CA::OGL::GLContext::create_shader(CA::OGL::ContextState const*,CA::OGL::GLShader const*,int)::ycbcr_bias_names[v118]);
    v122 = ((uint64_t (*)(_QWORD, uint64_t, char *))v596[626])(*v596, v89, CA::OGL::GLContext::create_shader(CA::OGL::ContextState const*,CA::OGL::GLShader const*,int)::chroma_names[v118]);
    v112 = (__n128)xmmword_18474E5A0;
    v119 = 0;
    *((_DWORD *)v121 + 99) = v122;
    v118 = 1;
  }
  while ((v120 & 1) != 0);
  *((_DWORD *)v93 + 101) = ((uint64_t (*)(_QWORD, _QWORD, const char *, __n128))v596[626])(*v596, v89, "render_state", xmmword_18474E5A0);
  *((_WORD *)v93 + 46) = 0;
  switch((int)v595)
  {
    case 18:
    case 19:
    case 20:
    case 22:
    case 23:
    case 24:
      v123 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "color_matrix");
      goto LABEL_155;
    case 26:
    case 27:
    case 30:
    case 31:
      goto LABEL_157;
    case 29:
      v123 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "axis");
      goto LABEL_155;
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
      *((_DWORD *)v93 + 38) = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "divide");
LABEL_157:
      *((_DWORD *)v93 + 36) = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "offset");
      v124 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "weight");
      goto LABEL_158;
    case 43:
      *((_DWORD *)v93 + 36) = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "minmax");
      v124 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "bgcolor");
LABEL_158:
      *((_DWORD *)v93 + 37) = v124;
      break;
    case 44:
      *((_DWORD *)v93 + 36) = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "minmax");
      *((_DWORD *)v93 + 37) = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "bgcolor");
      v141 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "map");
      goto LABEL_180;
    case 45:
      *((_DWORD *)v93 + 36) = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "minmax_dir");
      *((_DWORD *)v93 + 37) = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "bgcolor");
      *((_DWORD *)v93 + 38) = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "map");
      *((_DWORD *)v93 + 39) = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "args");
      break;
    case 46:
      v123 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "map");
      goto LABEL_155;
    case 48:
      *((_DWORD *)v93 + 36) = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "color_dodge");
      v142 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "color_lighten");
      goto LABEL_179;
    case 49:
      *((_DWORD *)v93 + 36) = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "color_burn");
      v142 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "color_darken");
LABEL_179:
      *((_DWORD *)v93 + 37) = v142;
      v141 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "reversed");
LABEL_180:
      *((_DWORD *)v93 + 38) = v141;
      break;
    case 52:
      v123 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "curves");
LABEL_155:
      *((_DWORD *)v93 + 36) = v123;
      break;
    default:
      *((_DWORD *)v93 + 36) = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "function_arg");
      v143 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v596[626])(*v596, v89, "coord_arg");
      *((_DWORD *)v93 + 37) = v143;
      v93[92] = *((_DWORD *)v93 + 36) >= 0;
      v93[93] = v143 >= 0;
      break;
  }
  if (v586)
    free(v589);
  ((void (*)(_QWORD, _QWORD))v596[601])(*v596, 0);
  *(_QWORD *)(v597 + 1848) = 0;
  ++*(_DWORD *)(v597 + 700);
  return v93;
}

char *CA::OGL::GLContext::inline_blend_function(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *result;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;

  v9 = a2;
  if (((0x787FC001FFFFFFFuLL >> a2) & 1) != 0)
  {
    if (((0x701840008C00000uLL >> a2) & 1) != 0)
      LOBYTE(v9) = 3;
    result = x_stream_printf(a1, "%Wlowp vec4 R = %s;\n", a3, a4, a5, a6, a7, a8, 4);
  }
  else
  {
    x_stream_printf(a1, "%Wlowp vec4 R = D*(1. - S.a) + S*(1. - D.a);\n", a3, a4, a5, a6, a7, a8, 4);
    x_stream_printf(a1, "%Wlowp float DaSa = D.a*S.a;\n", v10, v11, v12, v13, v14, v15, 4);
    if ((unint64_t)(v9 - 55) >= 0xFFFFFFFFFFFFFFFCLL)
    {
      x_stream_printf(a1, "%WS = S/max(S.a, 0.005);\n", v16, v17, v18, v19, v20, v21, 4);
      x_stream_printf(a1, "%WD = D/max(D.a, 0.005);\n", v30, v31, v32, v33, v34, v35, 4);
      v22 = "%WR.rgb += %s * DaSa;\n";
    }
    else
    {
      v22 = "%WR.rgb += %s;\n";
    }
    x_stream_printf(a1, v22, v16, v17, v18, v19, v20, v21, 4);
    result = x_stream_printf(a1, "%WR.a += DaSa;\n", v36, v37, v38, v39, v40, v41, 4);
  }
  if (((0x7FFFE9CFFFFFFFFuLL >> v9) & 1) == 0)
    return x_stream_printf(a1, "%WR.rgb = min(R.rgb, R.a);\n", v24, v25, v26, v27, v28, v29, 4);
  return result;
}

void CA::OGL::GLContext::update_state(CA::OGL::GLContext *this, uint64_t a2, uint64_t a3, const float *a4, float64x2_t a5, __n128 a6)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  char v24;
  unsigned int v25;
  _BYTE *v26;
  void (**v27)(_QWORD, uint64_t);
  unsigned int v28;
  void (**v29)(_QWORD, uint64_t);
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v7 = (_QWORD *)*((_QWORD *)this + 260);
  v8 = *((_QWORD *)this + 2);
  v32 = *((_QWORD *)this + 3);
  CA::OGL::GLContext::update_shader(this, a5, a6, a2, a3, a4);
  v9 = *((unsigned int *)this + 461);
  v10 = *((_QWORD *)this + 231);
  if (v10)
  {
    v11 = *(unsigned __int8 *)(v10 + 34);
  }
  else
  {
    v11 = *((_DWORD *)this + 22);
    if (v11 >= 0xD)
      v11 = 13;
  }
  v12 = v32;
  if (v11)
  {
    v13 = 0;
    v14 = v8 + 176;
    v15 = v32 + 176;
    v16 = v11;
    do
    {
      v17 = v12 + 2 * v13;
      v18 = *(unsigned __int16 *)(v17 + 144);
      v19 = v8 + 2 * v13;
      v20 = *(unsigned __int16 *)(v19 + 144);
      v21 = *(_QWORD *)(v15 + 8 * v13);
      if ((_DWORD)v18 != v20)
      {
        if (v21)
        {
          if (v13 != v9)
          {
            ((void (*)(_QWORD, _QWORD))v7[343])(*v7, (v13 + 33984));
            v18 = *(unsigned __int16 *)(v17 + 144);
            v9 = v13;
          }
          ((void (*)(_QWORD, uint64_t, _QWORD))v7[6])(*v7, v18, 0);
          *(_QWORD *)(v15 + 8 * v13) = 0;
          LOWORD(v20) = *(_WORD *)(v19 + 144);
          v12 = v32;
        }
        v21 = 0;
        *(_WORD *)(v17 + 144) = v20;
      }
      v22 = *(_QWORD *)(v14 + 8 * v13);
      if (v22 != v21)
      {
        if (v13 != v9)
        {
          ((void (*)(_QWORD, _QWORD))v7[343])(*v7, (v13 + 33984));
          v22 = *(_QWORD *)(v14 + 8 * v13);
          v9 = v13;
        }
        ((void (*)(_QWORD, _QWORD, uint64_t))v7[6])(*v7, *(unsigned __int16 *)(v19 + 144), v22);
        *(_QWORD *)(v15 + 8 * v13) = *(_QWORD *)(v14 + 8 * v13);
        v12 = v32;
      }
      ++v13;
    }
    while (v16 != v13);
  }
  *((_DWORD *)this + 461) = v9;
  v23 = *(unsigned __int8 *)(v8 + 480);
  v24 = (v23 < 0x1A) & *(_BYTE *)(v8 + 481);
  if (!v24)
  {
    if ((*(_BYTE *)(v12 + 481) & 1) == 0)
      goto LABEL_26;
    v26 = (_BYTE *)(v12 + 481);
    v27 = (void (**)(_QWORD, uint64_t))(v7 + 64);
    goto LABEL_25;
  }
  v25 = *(unsigned __int8 *)(v12 + 480);
  if (v23 != v25)
  {
    CA::OGL::GLContext::load_blend_func((uint64_t)this, v23, v25);
    v12 = v32;
    *(_BYTE *)(v32 + 480) = *(_BYTE *)(v8 + 480);
  }
  if ((*(_BYTE *)(v12 + 481) & 1) == 0)
  {
    v26 = (_BYTE *)(v12 + 481);
    v27 = (void (**)(_QWORD, uint64_t))(v7 + 73);
LABEL_25:
    (*v27)(*v7, 3042);
    *v26 = *v26 & 0xFE | v24;
  }
LABEL_26:
  if (*((_BYTE *)this + 64))
  {
    v28 = *((_DWORD *)this + 9);
    if (*((_DWORD *)this + 8) == *((_DWORD *)this + 12)
      && v28 == *((_DWORD *)this + 13)
      && *((_DWORD *)this + 10) == *((_DWORD *)this + 14)
      && *((_DWORD *)this + 11) == *((_DWORD *)this + 15))
    {
      if ((*((_BYTE *)this + 65) & 1) != 0)
        goto LABEL_39;
      goto LABEL_35;
    }
    v33 = *((_DWORD *)this + 8);
    v34 = v28;
    v35 = *((_QWORD *)this + 5);
    (*(void (**)(CA::OGL::GLContext *, unsigned int *))(*(_QWORD *)this + 1120))(this, &v33);
    ((void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v7[252])(*v7, v33, v34, v35, HIDWORD(v35));
    *((_OWORD *)this + 3) = *((_OWORD *)this + 2);
    if (*((_BYTE *)this + 64) != (*((_BYTE *)this + 65) & 1))
    {
      if (*((_BYTE *)this + 64))
      {
LABEL_35:
        v29 = (void (**)(_QWORD, uint64_t))(v7 + 73);
LABEL_38:
        (*v29)(*v7, 3089);
        *((_BYTE *)this + 65) = *((_BYTE *)this + 65) & 0xFE | *((_BYTE *)this + 64);
        goto LABEL_39;
      }
LABEL_37:
      v29 = (void (**)(_QWORD, uint64_t))(v7 + 64);
      goto LABEL_38;
    }
  }
  else if ((*((_BYTE *)this + 65) & 1) != 0)
  {
    goto LABEL_37;
  }
LABEL_39:
  v30 = *((_QWORD *)this + 231);
  if (v30 && (*(_DWORD *)(v30 + 252) & 0x80000000) == 0 && *(_DWORD *)(v30 + 256))
  {
    v31 = 0;
    do
    {
      (*(void (**)(CA::OGL::GLContext *, _QWORD))(*(_QWORD *)this + 1176))(this, v31 + *(_DWORD *)(v30 + 252));
      ++v31;
      v30 = *((_QWORD *)this + 231);
    }
    while (v31 < *(_DWORD *)(v30 + 256));
  }
}

uint64_t CA::OGL::GLContext::unload_state(uint64_t this)
{
  _DWORD *v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;

  v1 = *(_DWORD **)(this + 1848);
  if (v1)
  {
    v2 = v1[65];
    if ((v2 & 0x80000000) == 0)
    {
      v3 = *(_QWORD *)(this + 16);
      *(_WORD *)(v3 + 2 * v2 + 144) = 0;
      *(_QWORD *)(v3 + 8 * v2 + 176) = 0;
    }
    v4 = v1[63];
    if ((v4 & 0x80000000) == 0)
    {
      v5 = v1[64];
      if ((_DWORD)v5)
      {
        v6 = *(_QWORD *)(this + 16);
        do
        {
          *(_WORD *)(v6 + 2 * v4 + 144) = 0;
          *(_QWORD *)(v6 + 8 * v4++ + 176) = 0;
          --v5;
        }
        while (v5);
      }
    }
  }
  return this;
}

uint64_t CA::OGL::GLContext::load_blend_func(uint64_t result, unsigned int a2, unsigned int a3)
{
  unsigned int v3;
  unsigned int v4;
  uint64_t *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;

  if (a2 <= 0x14)
    v3 = a2;
  else
    v3 = 3;
  if (a3 <= 0x14)
    v4 = a3;
  else
    v4 = 3;
  if (v3 != v4)
  {
    v5 = *(uint64_t **)(result + 2080);
    if (CA::OGL::GLContext::load_blend_func(CA::OGL::BlendFunction,CA::OGL::BlendFunction)::functions[3 * v3] != CA::OGL::GLContext::load_blend_func(CA::OGL::BlendFunction,CA::OGL::BlendFunction)::functions[3 * v4])
      ((void (*)(_QWORD))v5[339])(*v5);
    v6 = *v5;
    v7 = (char *)&CA::OGL::GLContext::load_blend_func(CA::OGL::BlendFunction,CA::OGL::BlendFunction)::functions[3 * v3];
    v8 = *((unsigned int *)v7 + 1);
    v9 = *((unsigned int *)v7 + 2);
    if (v3 > 0x12)
      return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v5[337])(v6, v8, v9, 1, 771);
    else
      return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v5[8])(v6, v8, v9);
  }
  return result;
}

uint64_t CA::OGL::GLContext::init_client_state(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;

  v3 = result;
  if (*(_QWORD *)(result + 2064) != a2 || *(_DWORD *)(result + 2072) != 1)
  {
    v4 = *(_QWORD **)(result + 2080);
    ((void (*)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t))v4[512])(*v4, 0, 4, 5126, 0, 48, a2);
    ((void (*)(_QWORD, _QWORD))v4[513])(*v4, 0);
    ((void (*)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v4[512])(*v4, 1, 4, 5131, 1, 48, a2 + 32);
    ((void (*)(_QWORD, uint64_t))v4[513])(*v4, 1);
    ((void (*)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t))v4[512])(*v4, 2, 2, 5126, 0, 48, a2 + 16);
    ((void (*)(_QWORD, uint64_t))v4[513])(*v4, 2);
    ((void (*)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t))v4[512])(*v4, 3, 2, 5126, 0, 48, a2 + 24);
    ((void (*)(_QWORD, uint64_t))v4[513])(*v4, 3);
    result = ((uint64_t (*)(_QWORD, uint64_t))v4[514])(*v4, 4);
    *(_QWORD *)(v3 + 2064) = a2;
    *(_DWORD *)(v3 + 2072) = 1;
  }
  return result;
}

void std::__function::__func<CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0,std::allocator<CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0>,BOOL ()(CA::OGL::Vertex*,unsigned int)>::~__func()
{
  JUMPOUT(0x186DBD990);
}

_QWORD *std::__function::__func<CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0,std::allocator<CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0>,BOOL ()(CA::OGL::Vertex*,unsigned int)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E159A3C0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0,std::allocator<CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0>,BOOL ()(CA::OGL::Vertex*,unsigned int)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E159A3C0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0,std::allocator<CA::OGL::GLContext::draw_elements(CA::OGL::PrimitiveMode,unsigned int,unsigned short const*,CA::OGL::Vertex const*,unsigned int,unsigned int,CA::OGL::ClipPlane const*)::$_0>,BOOL ()(CA::OGL::Vertex*,unsigned int)>::operator()(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 2080) + 528))(**(_QWORD **)(*(_QWORD *)(a1 + 8) + 2080), 4, 0, *a3);
  return 1;
}

uint64_t CA::OGL::GLContext::check_extension(CA::OGL::GLContext *this, char *a2, const char *a3, const char *a4)
{
  char *v7;
  const char *v8;
  const char *v9;
  uint64_t result;
  NSObject *v11;
  _BOOL4 v12;
  uint8_t buf[4];
  const char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (CA::OGL::GLContext::check_extension(char const*,char const*,char const*)::initialized == 1)
  {
    v7 = (char *)CA::OGL::GLContext::check_extension(char const*,char const*,char const*)::disabled_extensions;
  }
  else
  {
    v7 = getenv("CA_DISABLED_EXTENSIONS");
    CA::OGL::GLContext::check_extension(char const*,char const*,char const*)::disabled_extensions = (uint64_t)v7;
    CA::OGL::GLContext::check_extension(char const*,char const*,char const*)::initialized = 1;
  }
  if (CA::OGL::search_extension_list(v7, a3, a3))
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v11 = x_log_category_ogl_opengl;
      v12 = os_log_type_enabled((os_log_t)x_log_category_ogl_opengl, OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v12)
        return result;
      *(_DWORD *)buf = 136315138;
      v14 = a3;
      _os_log_impl(&dword_184457000, v11, OS_LOG_TYPE_DEFAULT, "CoreAnimation: disabling OpenGL extension %s\n", buf, 0xCu);
    }
    return 0;
  }
  else if ((CA::OGL::search_extension_list((char *)this, a3, v8) & 1) != 0)
  {
    return 1;
  }
  else
  {
    return (uint64_t)CA::OGL::search_extension_list(a2, a3, v9);
  }
}

char *CA::OGL::search_extension_list(char *this, const char *a2, const char *a3)
{
  char *v4;

  if (this)
  {
    v4 = this;
    this = strstr(this, a2);
    if (this)
    {
      if (this <= v4 || *(this - 1) == 32)
        return (char *)((this[strlen(a2)] & 0xDF) == 0);
      else
        return 0;
    }
  }
  return this;
}

uint64_t CA::OGL::GLContext::projection_matrix(uint64_t this, float a2, float a3, float a4, float a5, int a6)
{
  float v6;
  float v7;
  float v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float *v17;
  uint64_t v18;
  uint64_t v19;
  float v20;
  float v21;

  if (a6)
    v6 = a5;
  else
    v6 = a2;
  if (a6)
    v7 = a4;
  else
    v7 = a3;
  if (a6)
    a4 = a2;
  else
    a3 = a5;
  v8 = 1.0 / (float)(v7 - v6);
  v9 = 1.0 / (float)(a3 - a4);
  v10 = 1912;
  if (*(_QWORD *)(this + 248))
  {
    v10 = 1976;
    v11 = this + 1976;
  }
  else
  {
    v11 = this + 1912;
  }
  v12 = v8 + v8;
  if (a6)
    v13 = 0.0;
  else
    v13 = v8 + v8;
  *(float *)(this + v10) = v13;
  if (!a6)
    v12 = 0.0;
  v14 = -(float)((float)(v7 + v6) * v8);
  v15 = v9 + v9;
  if (a6)
    v16 = v9 + v9;
  else
    v16 = 0.0;
  *(float *)(v11 + 4) = v16;
  if (a6)
    v15 = 0.0;
  *(float *)(v11 + 16) = v12;
  *(float *)(v11 + 20) = v15;
  *(float *)(v11 + 48) = v14;
  *(float *)(v11 + 52) = -(float)((float)(a3 + a4) * v9);
  *(_QWORD *)(v11 + 8) = 0;
  *(_QWORD *)(v11 + 32) = 0;
  *(_QWORD *)(v11 + 40) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_QWORD *)(v11 + 56) = 0x3F80000000000000;
  v17 = *(float **)(this + 2040);
  if (v17 && (float *)v11 != v17 && *v17 == v13)
  {
    v18 = 1;
    while (v18 != 16)
    {
      v19 = v18;
      v20 = v17[v18];
      v21 = *(float *)(v11 + 4 * v18++);
      if (v20 != v21)
      {
        if ((unint64_t)(v19 - 1) <= 0xE)
          goto LABEL_26;
        break;
      }
    }
  }
  else
  {
LABEL_26:
    ++*(_DWORD *)(this + 240);
  }
  *(_QWORD *)(this + 2040) = v11;
  return this;
}

uint64_t CA::OGL::GLContext::update_texture(uint64_t this, unsigned int a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  _WORD *v10;
  int v11;
  uint64_t v12;
  int v13;
  _WORD *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;

  v3 = *(_QWORD **)(this + 2080);
  v4 = *(_QWORD *)(this + 16);
  v5 = *(_QWORD *)(this + 24);
  if (*(_DWORD *)(this + 1844) != a2)
  {
    v6 = this;
    this = ((uint64_t (*)(_QWORD, _QWORD))v3[343])(*v3, a2 + 33984);
    *(_DWORD *)(v6 + 1844) = a2;
  }
  v7 = a2;
  v8 = v5 + 2 * a2;
  v11 = *(unsigned __int16 *)(v8 + 144);
  v10 = (_WORD *)(v8 + 144);
  v9 = v11;
  v12 = v4 + 2 * a2;
  v15 = *(unsigned __int16 *)(v12 + 144);
  v14 = (_WORD *)(v12 + 144);
  v13 = v15;
  v16 = v5 + 8 * a2;
  v19 = *(_QWORD *)(v16 + 176);
  v18 = (_QWORD *)(v16 + 176);
  v17 = v19;
  if (v9 != v13)
  {
    if (v17)
    {
      this = ((uint64_t (*)(_QWORD))v3[6])(*v3);
      *v18 = 0;
      LOWORD(v13) = *v14;
    }
    v17 = 0;
    *v10 = v13;
  }
  v20 = v4 + 8 * v7;
  v22 = *(_QWORD *)(v20 + 176);
  v21 = (_QWORD *)(v20 + 176);
  if (v22 != v17)
  {
    this = ((uint64_t (*)(_QWORD, _QWORD))v3[6])(*v3, (unsigned __int16)*v14);
    *v18 = *v21;
  }
  return this;
}

void CA::ASEScalerStatistics::~ASEScalerStatistics(id *this)
{
  *this = &off_1E1590EC8;

}

{
  *this = &off_1E1590EC8;

  JUMPOUT(0x186DBD990);
}

_QWORD *CA::ASEScalerStatistics::create_iosa_params(CA::ASEScalerStatistics *this, __IOSurface *a2, __IOSurface *a3)
{
  id *v6;
  int v7;
  void *v8;
  BOOL v9;
  uint64_t v10;
  pthread_mutex_t *v11;
  uint64_t v12;
  id v13;
  uint64_t v14;
  int v15;
  _QWORD *result;
  uint64_t v17;
  const char *v18;
  NSObject *v19;
  uint32_t v20;
  uint64_t v21;
  __int128 v22;
  uint8_t buf[4];
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v6 = (id *)malloc_type_calloc(1uLL, 0x1B0uLL, 0x10800408F598EA5uLL);
  if (((*((_BYTE *)this + 12) - 1) & 0xFC) != 0)
    v7 = 4;
  else
    v7 = (*((_BYTE *)this + 12) - 1) + 1;
  LODWORD(v22) = 1;
  DWORD1(v22) = v7;
  DWORD2(v22) = IOSurfaceGetWidth(a2);
  HIDWORD(v22) = IOSurfaceGetHeight(a2);
  v8 = (void *)*((_QWORD *)this + 10);
  if (v8
    && ((_QWORD)v22 == *((_QWORD *)this + 11) ? (v9 = *((_QWORD *)&v22 + 1) == *((_QWORD *)this + 12)) : (v9 = 0), v9)
    || (v8,
        v10 = objc_msgSend(objc_alloc(MEMORY[0x1E0CF21C0]), "initWithConfig:", &v22),
        *((_QWORD *)this + 10) = v10,
        *(_OWORD *)((char *)this + 88) = v22,
        v10))
  {
    objc_msgSend(*((id *)this + 10), "setDestinationWidth:", IOSurfaceGetWidth(a3));
    objc_msgSend(*((id *)this + 10), "setDestinationHeight:", IOSurfaceGetHeight(a3));
    v11 = (pthread_mutex_t *)((char *)this + 16);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
    v12 = objc_msgSend(*((id *)this + 10), "processFrameWithInput:outputData:", (char *)this + 104, v6 + 5);
    v13 = v6[5];
    v14 = objc_msgSend(v6[5], "bytes");
    v15 = objc_msgSend(v6[5], "length");
    pthread_mutex_unlock(v11);
    if (v12 == -18000)
    {
      *(_DWORD *)v6 = 4;
      v6[1] = (id)v14;
      *((_DWORD *)v6 + 4) = v15;
      *((_DWORD *)v6 + 5) = 1;
      v6[3] = v6 + 6;
      *((_DWORD *)v6 + 8) = 380;
      result = (_QWORD *)operator new();
      *result = v6;
      return result;
    }
    if (x_log_hook_p())
      goto LABEL_15;
    v17 = x_log_category_utilities;
    if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
      goto LABEL_21;
    *(_DWORD *)buf = 134217984;
    v24 = v12;
    v18 = "ASEProcessing error: %ld";
    v19 = v17;
    v20 = 12;
LABEL_20:
    _os_log_impl(&dword_184457000, v19, OS_LOG_TYPE_ERROR, v18, buf, v20);
    goto LABEL_21;
  }
  if (!x_log_hook_p())
  {
    v21 = x_log_category_utilities;
    if (!os_log_type_enabled((os_log_t)x_log_category_utilities, OS_LOG_TYPE_ERROR))
      goto LABEL_21;
    *(_WORD *)buf = 0;
    v18 = "Could not create ASEProcessor";
    v19 = v21;
    v20 = 2;
    goto LABEL_20;
  }
LABEL_15:
  x_log_();
LABEL_21:
  free(v6);
  return 0;
}

void sub_184697C10(_Unwind_Exception *a1)
{
  pthread_mutex_t *v1;

  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::ASEScalerStatistics::update_with_stats(uint64_t this, void *a2)
{
  uint64_t v3;
  pthread_mutex_t *v4;

  if (a2)
  {
    v3 = this;
    v4 = (pthread_mutex_t *)(this + 16);
    pthread_mutex_lock((pthread_mutex_t *)(this + 16));
    memcpy((void *)(v3 + 104), a2, 0x17CuLL);
    return pthread_mutex_unlock(v4);
  }
  return this;
}

uint64_t ___ZN2CA16ScalerStatistics14should_enhanceEmmmm_block_invoke()
{
  uint64_t result;

  objc_opt_class();
  result = objc_opt_respondsToSelector();
  CA::ScalerStatistics::should_enhance(unsigned long,unsigned long,unsigned long,unsigned long)::exists = result & 1;
  return result;
}

void CA::CG::ContextDelegate::draw_lines_(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, unint64_t a5)
{
  const double *Info;
  CGColor *StrokeColor;
  CA::CG::DrawOp **v11;
  uint64_t v12;
  CA::CG::DrawOp *v13;

  if (a5)
  {
    Info = (const double *)CGContextDelegateGetInfo();
    StrokeColor = (CGColor *)CGGStateGetStrokeColor();
    v11 = (CA::CG::DrawOp **)(*(uint64_t (**)(const double *))(*(_QWORD *)Info + 16))(Info);
    if (v11)
    {
      v12 = (uint64_t)v11;
      v13 = CA::CG::ContextDelegate::draw_lines(Info, v11, a2, a3, StrokeColor, a4, a5, 0);
      CA::CG::ContextDelegate::submit((uint64_t)Info, v12, (uint64_t)v13, a2, a3);
    }
  }
}

uint64_t CA::CG::ContextDelegate::draw_shading_(uint64_t a1, uint64_t a2, uint64_t a3, CGShading *a4)
{
  const double *Info;
  CA::CG::Queue *v8;
  uint64_t v9;
  unint64_t *v10;
  uint64_t v11;
  int Type;
  unsigned int v13;
  BOOL v14;
  int v15;
  uint64_t Descriptor;

  if (CGShadingGetType())
  {
    Info = (const double *)CGContextDelegateGetInfo();
    v8 = (CA::CG::Queue *)(*(uint64_t (**)(const double *))(*(_QWORD *)Info + 16))(Info);
    if (v8)
    {
      v9 = (uint64_t)v8;
      v10 = CA::CG::Queue::alloc(v8, 120);
      if (v10)
      {
        v11 = (uint64_t)v10;
        *(_QWORD *)CA::CG::DrawOp::DrawOp((uint64_t)v10, Info, a2, a3, 0, 10240) = off_1E1591428;
        *(_QWORD *)(v11 + 112) = CGShadingRetain(a4);
        Type = CGShadingGetType();
        if ((Type - 1) <= 1)
        {
          v13 = *(_DWORD *)(v11 + 56);
          v14 = v13 > 9;
          v15 = (1 << v13) & 0x29B;
          if (!v14 && v15 != 0 && Type == 1)
          {
            Descriptor = CGShadingGetDescriptor();
            if (!*(_BYTE *)(Descriptor + 16) || !*(_BYTE *)(Descriptor + 40))
              *(_DWORD *)(v11 + 100) |= 0x100u;
          }
        }
        CA::CG::ContextDelegate::submit((uint64_t)Info, v9, v11, a2, a3);
      }
    }
  }
  else
  {
    CGShadingDrawInContextDelegate();
  }
  return 0;
}

uint64_t CA::CG::ContextDelegate::draw_radial_gradient_(double a1, double a2, double a3, double a4, double a5, double a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, char a11)
{
  const double *Info;
  CA::CG::Queue *v22;
  uint64_t v23;
  unint64_t *v24;
  uint64_t v25;
  uint64_t v26;

  Info = (const double *)CGContextDelegateGetInfo();
  v22 = (CA::CG::Queue *)(*(uint64_t (**)(const double *))(*(_QWORD *)Info + 16))(Info);
  if (v22)
  {
    v23 = (uint64_t)v22;
    v24 = CA::CG::Queue::alloc(v22, 168);
    if (v24)
    {
      v25 = (uint64_t)v24;
      v26 = CA::CG::DrawGradient::DrawGradient((uint64_t)v24, Info, a8, a9, a10, a11);
      *(_QWORD *)v26 = off_1E1592CE0;
      *(double *)(v26 + 120) = a1;
      *(double *)(v26 + 128) = a2;
      *(double *)(v26 + 136) = a4;
      *(double *)(v26 + 144) = a5;
      *(double *)(v26 + 152) = a3;
      *(double *)(v26 + 160) = a6;
      CA::CG::ContextDelegate::submit((uint64_t)Info, v23, v25, a8, a9);
    }
  }
  return 0;
}

uint64_t CA::CG::ContextDelegate::draw_images_(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, CGImageRef *a5, _OWORD *a6, uint64_t a7)
{
  uint64_t v7;
  const double *Info;
  uint64_t v13;
  CA::CG::Queue *v14;
  _OWORD *v15;
  CGColor *FillColor;
  unint64_t *v17;
  uint64_t v18;
  _OWORD *v19;
  int InterpolationQuality;
  int v21;
  int MinInterpolationQuality;
  int MaxInterpolationQuality;
  char v26;
  int v27;
  __int128 v28;
  __int128 v29;
  int v30;
  uint64_t v32;
  CGImage *image;

  if (a7)
  {
    v7 = a7;
    Info = (const double *)CGContextDelegateGetInfo();
    v13 = (*(uint64_t (**)(const double *))(*(_QWORD *)Info + 16))(Info);
    if (v13)
    {
      v14 = (CA::CG::Queue *)v13;
      v15 = a6;
      v32 = v13;
      do
      {
        if (CGImageIsMask(*a5))
          FillColor = (CGColor *)CGGStateGetFillColor();
        else
          FillColor = 0;
        image = *a5;
        v17 = CA::CG::Queue::alloc(v14, 192);
        if (v17)
        {
          v18 = (uint64_t)v17;
          if (a6)
            v19 = v15;
          else
            v19 = a4;
          *(_QWORD *)CA::CG::DrawOp::DrawOp((uint64_t)v17, Info, a2, a3, FillColor, 0) = off_1E1591F28;
          InterpolationQuality = CGGStateGetInterpolationQuality();
          if (InterpolationQuality)
            v21 = InterpolationQuality;
          else
            v21 = 4;
          MinInterpolationQuality = CGRenderingStateGetMinInterpolationQuality();
          if (v21 < MinInterpolationQuality && MinInterpolationQuality != 0)
            v21 = MinInterpolationQuality;
          MaxInterpolationQuality = CGRenderingStateGetMaxInterpolationQuality();
          if (v21 <= MaxInterpolationQuality || MaxInterpolationQuality == 0)
            v26 = v21;
          else
            v26 = MaxInterpolationQuality;
          *(_BYTE *)(v18 + 112) = v26;
          CGGStateGetEDRTargetHeadroom();
          *(_DWORD *)(v18 + 116) = v27;
          *(_QWORD *)(v18 + 120) = CGImageRetain(image);
          v28 = a4[1];
          *(_OWORD *)(v18 + 128) = *a4;
          *(_OWORD *)(v18 + 144) = v28;
          v29 = v19[1];
          *(_OWORD *)(v18 + 160) = *v19;
          *(_OWORD *)(v18 + 176) = v29;
          v30 = *(_DWORD *)(v18 + 100);
          if ((v30 & 2) == 0)
            *(_DWORD *)(v18 + 100) = v30 | 0x2000;
          v14 = (CA::CG::Queue *)v32;
          CA::CG::ContextDelegate::submit((uint64_t)Info, v32, v18, a2, a3);
        }
        v15 += 2;
        a4 += 2;
        ++a5;
        --v7;
      }
      while (v7);
    }
  }
  return 0;
}

uint64_t CA::CG::ContextDelegate::draw_image_from_rect_(double a1, double a2, double a3, double a4, double a5, double a6, float64x2_t a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, CGImage *AlternateImage)
{
  const double *Info;
  uint64_t v16;
  CA::CG::Queue *v17;
  CGColor *FillColor;
  unsigned int Width;
  unsigned int Height;
  int8x16_t v21;
  float64x2_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float64x2_t v26;
  float64x2_t v27;
  int8x16_t v28;
  unint64_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int32x4_t v32;
  int32x2_t v33;
  uint32x2_t v34;
  uint32x2_t v35;
  int32x2_t v36;
  int32x2_t v37;
  int32x2_t v38;
  uint32x2_t v39;
  unint64_t *v41;
  uint64_t v42;
  __int128 v43;
  unint64_t *v44;
  int32x2_t v49;
  int32x2_t v51;
  __int128 v52;
  __int128 v53;
  double v54;
  double v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  *(double *)&v53 = a1;
  *((double *)&v53 + 1) = a2;
  v54 = a3;
  v55 = a4;
  Info = (const double *)CGContextDelegateGetInfo();
  v16 = (*(uint64_t (**)(const double *))(*(_QWORD *)Info + 16))(Info);
  if (v16)
  {
    v17 = (CA::CG::Queue *)v16;
    if (CGImageIsMask(AlternateImage))
      FillColor = (CGColor *)CGGStateGetFillColor();
    else
      FillColor = 0;
    Width = CGImageGetWidth(AlternateImage);
    Height = CGImageGetHeight(AlternateImage);
    *(double *)v21.i64 = a5;
    *(double *)&v21.i64[1] = a6;
    v22.f64[0] = 0.0;
    v23.i64[0] = *(_QWORD *)&a7.f64[0];
    *(double *)&v23.i64[1] = a8;
    v24 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(v22, a7).i64[0], 0);
    *(double *)&v25.i64[1] = a8;
    *(double *)v25.i64 = -a7.f64[0];
    v26 = (float64x2_t)vbslq_s8(v24, v25, v23);
    *(double *)&v25.i64[1] = a6;
    *(double *)v25.i64 = a7.f64[0] + a5;
    v27 = (float64x2_t)vbslq_s8(v24, v25, v21);
    if (a8 < 0.0)
    {
      v27.f64[1] = a8 + a6;
      v26.f64[1] = -a8;
    }
    v28 = (int8x16_t)vceqzq_f64(v26);
    v29 = vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v28, 1), v28).u64[0];
    v30 = 0uLL;
    if ((v29 & 0x8000000000000000) == 0)
    {
      v31 = vorrq_s8((int8x16_t)vcltzq_f64(v26), (int8x16_t)vcgezq_f64(v26));
      if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v31), 1), v31).u64[0] & 0x8000000000000000) == 0)
      {
        v32 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v27, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        v30 = (int8x16_t)vuzp1q_s32(v32, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v27, v26), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v32));
      }
    }
    v33 = (int32x2_t)vextq_s8(v30, v30, 8uLL).u64[0];
    v34 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v33);
    if ((vpmax_u32(v34, v34).u32[0] & 0x80000000) == 0)
    {
      v35 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)__PAIR64__(Height, Width));
      if ((vpmax_u32(v35, v35).u32[0] & 0x80000000) == 0)
      {
        v36 = vadd_s32(*(int32x2_t *)v30.i8, v33);
        v37 = vmax_s32(*(int32x2_t *)v30.i8, 0);
        v38 = vsub_s32(vmin_s32(v36, (int32x2_t)__PAIR64__(Height, Width)), v37);
        v39 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v38);
        if ((vpmax_u32(v39, v39).u32[0] & 0x80000000) == 0)
        {
          if (v38.i32[0] == Width && v38.i32[1] == Height)
          {
            if (CGImageGetEPSRep())
              AlternateImage = (CGImage *)CGImageEPSRepGetAlternateImage();
            v44 = CA::CG::Queue::alloc(v17, 160);
            v42 = (uint64_t)v44;
            if (v44)
              CA::CG::DrawImage::DrawImage((uint64_t)v44, Info, a10, a11, FillColor, &v53, AlternateImage);
          }
          else
          {
            v49 = v38;
            v51 = v37;
            v41 = CA::CG::Queue::alloc(v17, 176);
            v42 = (uint64_t)v41;
            if (v41)
            {
              *(int32x2_t *)&v43 = v51;
              *((int32x2_t *)&v43 + 1) = v49;
              v52 = v43;
              CA::CG::DrawImage::DrawImage((uint64_t)v41, Info, a10, a11, FillColor, &v53, AlternateImage);
              *(_QWORD *)v42 = off_1E15917D8;
              *(_OWORD *)(v42 + 160) = v52;
            }
          }
          CA::CG::ContextDelegate::submit((uint64_t)Info, (uint64_t)v17, v42, a10, a11);
        }
      }
    }
  }
  return 0;
}

uint64_t CA::CG::ContextDelegate::begin_transparency_layer_(uint64_t a1, float64_t a2, float64_t a3, double a4, double a5)
{
  uint64_t Info;
  int32x4_t v11;
  double v12;
  double v13;
  double v14;
  const CGAffineTransform *CTM;
  uint64_t *v16;
  uint64_t v17;
  int8x16_t v18;
  float64x2_t v19;
  int8x16_t v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  uint64_t v25;
  int v26;
  int8x16_t v27;
  int64x2_t v28;
  int8x16_t v29;
  int32x2_t v30;
  float64x2_t v31;
  int8x16_t v32;
  int32x4_t v33;
  uint64_t v34;
  int64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;
  int8x16_t v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  float64x2_t v43;
  double v44;
  int8x16_t v45;
  int8x16_t v46;
  int32x4_t v47;
  int32x4_t v48;
  int8x16_t v49;
  uint64_t v50;
  int64x2_t v51;
  float64x2_t v52;
  float64x2_t v53;
  float64x2_t v54;
  float64x2_t v55;
  int8x16_t v56;
  double *updated;
  malloc_zone_t *malloc_zone;
  char *v59;
  unsigned int *v60;
  unsigned int *v61;
  int v62;
  float64x2_t v63;
  unsigned int v64;
  __int16 v65;
  uint64_t v66;
  malloc_zone_t *v67;
  _QWORD *v68;
  uint64_t v69;
  malloc_zone_t *v70;
  uint64_t v71;
  uint64_t v72;
  CA::CG::TransparencyLayer *v73;
  unsigned int v74;
  float64x2_t v76;
  float64x2_t v77;
  float64x2_t v78;
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  Info = CGContextDelegateGetInfo();
  v77.f64[0] = a2;
  v77.f64[1] = a3;
  v78.f64[0] = a4;
  v78.f64[1] = a5;
  if (a4 < 0.0)
  {
    v12 = a4 + a2;
    a4 = -a4;
    v77.f64[0] = v12;
    v78.f64[0] = a4;
  }
  if (a5 < 0.0)
  {
    v13 = a5 + a3;
    a5 = -a5;
    v77.f64[1] = v13;
    v78.f64[1] = a5;
  }
  if (a4 <= a5)
    v14 = a5;
  else
    v14 = a4;
  if (v14 < 1.79769313e308)
  {
    CTM = (const CGAffineTransform *)CGGStateGetCTM();
    CA::Rect::apply_transform(&v77, CTM);
  }
  v16 = *(uint64_t **)(Info + 328);
  if (v16 && (v17 = *v16) != 0)
  {
    v18 = (int8x16_t)vclezq_f64(v78);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v18, 1), v18).u64[0] & 0x8000000000000000) == 0)
    {
      v19 = *(float64x2_t *)(v17 + 24);
      v20 = (int8x16_t)vclezq_f64(v19);
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v20, 1), v20).u64[0] & 0x8000000000000000) == 0)
      {
        v21 = *(float64x2_t *)(v17 + 8);
        v22 = vaddq_f64(v77, v78);
        v23 = vaddq_f64(v21, v19);
        v24 = vmaxnmq_f64(v77, v21);
        goto LABEL_20;
      }
      goto LABEL_22;
    }
    v76 = v78;
  }
  else
  {
    v25 = *(_QWORD *)(Info + 24);
    v26 = HIDWORD(v25);
    if ((int)v25 > SHIDWORD(v25))
      v26 = v25;
    v27 = (int8x16_t)vclezq_f64(v78);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v27, 1), v27).u64[0] & 0x8000000000000000) == 0)
    {
      v28.i64[0] = (int)v25;
      v28.i64[1] = SHIDWORD(v25);
      v29 = (int8x16_t)vcvtq_f64_s64(v28);
      v30 = vdup_n_s32(v26 > 1073741822);
      v28.i64[0] = v30.u32[0];
      v28.i64[1] = v30.u32[1];
      v31 = (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v28, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v29);
      v32 = (int8x16_t)vclezq_f64(v31);
      v33 = (int32x4_t)vdupq_laneq_s64((int64x2_t)v32, 1);
      if ((vorrq_s8((int8x16_t)v33, v32).u64[0] & 0x8000000000000000) == 0)
      {
        v34 = *(_QWORD *)(Info + 16);
        v35.i64[0] = (int)v34;
        v35.i64[1] = SHIDWORD(v34);
        v33.i32[0] = v26;
        v11.i32[0] = 1073741822;
        v36 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v33, v11), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v35));
        v22 = vaddq_f64(v77, v78);
        v23 = vaddq_f64(v36, v31);
        v24 = vmaxnmq_f64(v77, v36);
LABEL_20:
        v37 = vsubq_f64(vminnmq_f64(v22, v23), v24);
        v38 = (int8x16_t)vclezq_f64(v37);
        if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v38, 1), v38).u64[0] & 0x8000000000000000) == 0)
        {
          v76 = v37;
          v77 = v24;
          v78 = v37;
          goto LABEL_25;
        }
      }
LABEL_22:
      v78 = 0uLL;
      v76 = 0u;
      goto LABEL_25;
    }
    v76 = v78;
  }
LABEL_25:
  v39 = CA::CG::ContextDelegate::clip_stack(Info);
  if (v39)
  {
    v40 = *(_DWORD *)(v39 + 48);
    v41 = *(_DWORD *)(v39 + 52);
    if (v40 <= v41)
      v42 = *(_DWORD *)(v39 + 52);
    else
      v42 = *(_DWORD *)(v39 + 48);
    v43.f64[0] = (double)v40;
    v44 = (double)v41;
    if (v42 > 1073741822)
    {
      v43.f64[0] = 1.79769313e308;
      v44 = 1.79769313e308;
    }
    if (fmax(v43.f64[0], v44) < 1.79769313e308)
    {
      v45 = (int8x16_t)vclezq_f64(v76);
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v45, 1), v45).u64[0] & 0x8000000000000000) == 0)
      {
        v43.f64[1] = v44;
        v46 = (int8x16_t)vclezq_f64(v43);
        v47 = (int32x4_t)vdupq_laneq_s64((int64x2_t)v46, 1);
        v48 = (int32x4_t)vorrq_s8((int8x16_t)v47, v46);
        if (v48.i64[0] < 0)
          goto LABEL_36;
        v48.i32[0] = 1073741822;
        v47.i32[0] = v42;
        v49 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v47, v48), 0);
        v50 = *(_QWORD *)(v39 + 40);
        v51.i64[0] = (int)v50;
        v51.i64[1] = SHIDWORD(v50);
        v52 = (float64x2_t)vbslq_s8(v49, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v51));
        v53 = vaddq_f64(v52, v43);
        v54 = vmaxnmq_f64(v77, v52);
        v55 = vsubq_f64(vminnmq_f64(vaddq_f64(v77, v76), v53), v54);
        v56 = (int8x16_t)vclezq_f64(v55);
        if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v56, 1), v56).u64[0] & 0x8000000000000000) != 0)
        {
LABEL_36:
          v78 = 0uLL;
        }
        else
        {
          v77 = v54;
          v78 = v55;
        }
      }
    }
  }
  updated = CA::CG::ContextDelegate::update_style(Info);
  if (updated)
    (*(void (**)(double *, float64x2_t *))(*(_QWORD *)updated + 24))(updated, &v77);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v59 = (char *)malloc_type_zone_malloc(malloc_zone, 0xC8uLL, 0x8BB15036uLL);
  v60 = (unsigned int *)v59;
  if (v59)
  {
    v61 = *(unsigned int **)(Info + 312);
    v62 = *(_DWORD *)(Info + 304);
    *(_DWORD *)v59 = 0;
    v63 = v78;
    *(float64x2_t *)(v59 + 8) = v77;
    *(float64x2_t *)(v59 + 24) = v63;
    *((_QWORD *)v59 + 5) = 0;
    *((_QWORD *)v59 + 6) = 0;
    if (v61)
    {
      do
        v64 = __ldaxr(v61);
      while (__stlxr(v64 + 1, v61));
    }
    *((_QWORD *)v59 + 23) = v61;
    *((_DWORD *)v59 + 48) = v62;
    v59[196] = v59[196] & 0xF0 | 4;
    *(_DWORD *)v59 = 1;
    *((_QWORD *)v59 + 17) = 0x3C003C003C003C00;
    *((_QWORD *)v59 + 19) = 0;
    *((_QWORD *)v59 + 20) = 0;
    *((_QWORD *)v59 + 18) = 0;
    v65 = *((_WORD *)v59 + 86);
    *((_QWORD *)v59 + 13) = 0;
    *((_QWORD *)v59 + 14) = 0;
    *((_DWORD *)v59 + 42) = 1065353216;
    *((_QWORD *)v59 + 15) = 0;
    *((_QWORD *)v59 + 16) = &CA::identity_transform;
    *((_QWORD *)v59 + 14) = v59 + 56;
    *((_WORD *)v59 + 86) = v65 & 0xF800 | 0x503;
    v66 = *(_QWORD *)(Info + 328);
    v67 = (malloc_zone_t *)get_malloc_zone();
    v68 = malloc_type_zone_malloc(v67, 0x10uLL, 0x8BB15036uLL);
    *v68 = v60;
    v68[1] = v66;
  }
  else
  {
    v69 = *(_QWORD *)(Info + 328);
    v70 = (malloc_zone_t *)get_malloc_zone();
    v68 = malloc_type_zone_malloc(v70, 0x10uLL, 0x8BB15036uLL);
    *v68 = 0;
    v68[1] = v69;
  }
  *(_QWORD *)(Info + 328) = v68;
  v71 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)Info + 16))(Info);
  if (v71)
  {
    v72 = v71;
    v73 = *(CA::CG::TransparencyLayer **)(v71 + 16);
    if (v73 != (CA::CG::TransparencyLayer *)v60)
    {
      if (v73)
        CA::CG::TransparencyLayer::unref(v73);
      if (v60)
      {
        do
          v74 = __ldaxr(v60);
        while (__stlxr(v74 + 1, v60));
      }
      *(_QWORD *)(v72 + 16) = v60;
    }
  }
  return a1;
}

uint64_t CA::CG::ContextDelegate::end_transparency_layer_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Info;
  _QWORD *v7;
  const double *v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int **v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t v18;
  CA::CG::TransparencyLayer *v19;
  unsigned int v20;
  uint64_t v21;
  CA::CG::Queue *v22;
  double *updated;
  uint64_t v24;
  double *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t *v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v33;
  unsigned int *v34;
  unsigned int v35;
  uint64_t v36;
  char v37;
  char v38;
  float16x4_t *v39;
  const CA::CG::ClipStack *v40;
  CA::CG::DrawOp *v41;
  double v42;
  float v43;

  Info = CGContextDelegateGetInfo();
  v7 = *(_QWORD **)(Info + 328);
  if (v7)
  {
    v8 = (const double *)Info;
    v9 = *v7;
    v10 = *(unsigned int **)(*v7 + 184);
    v11 = *(unsigned int **)(Info + 312);
    if (v11 != v10)
    {
      if (v11)
      {
        do
        {
          v12 = __ldaxr(v11);
          v13 = v12 - 1;
        }
        while (__stlxr(v13, v11));
        if (!v13)
          CA::CG::ClipStack::destroy_clip_stack((void (***)(char *))v11);
      }
      if (v10)
      {
        do
          v14 = __ldaxr(v10);
        while (__stlxr(v14 + 1, v10));
      }
      *((_QWORD *)v8 + 39) = v10;
      v7 = (_QWORD *)*((_QWORD *)v8 + 41);
    }
    *((_DWORD *)v8 + 76) = *(_DWORD *)(v9 + 192);
    v15 = (unsigned int **)x_list_remove_head(v7);
    *((_QWORD *)v8 + 41) = v15;
    if (v15)
      v16 = *v15;
    else
      v16 = 0;
    v17 = (*(uint64_t (**)(const double *))(*(_QWORD *)v8 + 16))(v8);
    if (v17)
    {
      v18 = v17;
      v19 = *(CA::CG::TransparencyLayer **)(v17 + 16);
      if (v19 != (CA::CG::TransparencyLayer *)v16)
      {
        if (v19)
          CA::CG::TransparencyLayer::unref(v19);
        if (v16)
        {
          do
            v20 = __ldaxr(v16);
          while (__stlxr(v20 + 1, v16));
        }
        *(_QWORD *)(v18 + 16) = v16;
      }
    }
    v21 = (*(uint64_t (**)(const double *))(*(_QWORD *)v8 + 16))(v8);
    if (v21)
    {
      v22 = (CA::CG::Queue *)v21;
      updated = CA::CG::ContextDelegate::update_style((uint64_t)v8);
      if ((*(_BYTE *)(v9 + 196) & 2) != 0)
        goto LABEL_34;
      v24 = *((_QWORD *)v22 + 5);
      if (!v24)
        goto LABEL_34;
      v25 = updated;
      if (updated)
      {
        if (*(_QWORD *)(v24 + 104))
          goto LABEL_34;
      }
      if (CGGStateGetCompositeOperation() != 2)
        goto LABEL_34;
      v26 = *((_QWORD *)v22 + 5);
      if (*(_DWORD *)(v26 + 56) != 2 || (*(_BYTE *)(v26 + 101) & 0x10) != 0)
        goto LABEL_34;
      v27 = *(_QWORD *)(v26 - 8);
      if (!v27 || v27 != v9)
        goto LABEL_34;
      if (*(_QWORD *)(v26 + 72))
        goto LABEL_34;
      v33 = *(_QWORD *)(v26 + 104);
      if (v33)
      {
        if (*(_QWORD *)(v33 + 72))
          goto LABEL_34;
      }
      CA::CG::TransparencyLayer::unref((CA::CG::TransparencyLayer *)v9);
      v34 = (unsigned int *)*((_QWORD *)v22 + 2);
      if (v34)
      {
        do
          v35 = __ldaxr(v34);
        while (__stlxr(v35 + 1, v34));
        *(_QWORD *)(v26 - 8) = v34;
        v36 = *((_QWORD *)v22 + 2);
        v37 = *(_BYTE *)(v36 + 196);
        v38 = (v37 + 1) & 3;
        if ((v37 & 2) != 0)
          v38 = 2;
        *(_BYTE *)(v36 + 196) = v38 | v37 & 0xFC;
      }
      else
      {
        *(_QWORD *)(v26 - 8) = 0;
      }
      v39 = (float16x4_t *)*((_QWORD *)v22 + 5);
      if (!v39)
      {
LABEL_34:
        v29 = CA::CG::Queue::alloc(v22, 120);
        if (v29)
        {
          v30 = (uint64_t)v29;
          *(_QWORD *)CA::CG::DrawOp::DrawOp((uint64_t)v29, v8, a2, a3, 0, 0x2000) = off_1E1592FD8;
          do
            v31 = __ldaxr((unsigned int *)v9);
          while (__stlxr(v31 + 1, (unsigned int *)v9));
          *(_QWORD *)(v30 + 112) = v9;
          CA::CG::ContextDelegate::submit((uint64_t)v8, (uint64_t)v22, v30, a2, a3);
        }
      }
      else
      {
        v40 = (const CA::CG::ClipStack *)CA::CG::ContextDelegate::clip_stack((uint64_t)v8);
        CA::CG::DrawOp::set_clip_stack((CA::CG::DrawOp *)v39, v40);
        v41 = (CA::CG::DrawOp *)v39[13];
        if (v41)
          CA::CG::DrawOp::set_clip_stack(v41, v40);
        CGGStateGetAlpha();
        v43 = v42;
        if (v43 != 1.0)
          v39[11] = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v39[11]), v43));
        if (v25)
          CA::CG::ContextDelegate::resolve_style((uint64_t)v8, (uint64_t)v39, a2, a3, v25);
      }
    }
    CA::CG::TransparencyLayer::unref((CA::CG::TransparencyLayer *)v9);
  }
  return a1;
}

uint64_t CA::CG::ContextDelegate::get_layer_(double a1, double a2, float64x2_t a3, double a4)
{
  CGColorSpace **Info;
  unsigned int v5;
  const __CFString *v6;
  uint64_t v7;
  float64x2_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int8x16_t v12;
  float64x2_t v13;
  float64x2_t v14;
  int8x16_t v15;
  int32x4_t v16;
  int8x16_t v17;
  float64x2_t v18;
  int32x4_t v19;
  __IOSurface *iosurface;
  __IOSurface *v21;
  malloc_zone_t *malloc_zone;
  CA::CG::IOSurfaceDrawable *v23;
  unsigned int *v24;
  uint64_t v25;
  uint64_t v26;
  CA::CG::ContextDelegate *v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v36;

  Info = (CGColorSpace **)CGContextDelegateGetInfo();
  v7 = (*((uint64_t (**)(CGColorSpace **))*Info + 3))(Info);
  if (!v7)
    return v7;
  *(double *)v9.i64 = a1;
  *(double *)&v9.i64[1] = a2;
  v8.f64[0] = 0.0;
  v10.i64[0] = *(_QWORD *)&a3.f64[0];
  *(double *)&v10.i64[1] = a4;
  v11 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(v8, a3).i64[0], 0);
  *(double *)&v12.i64[1] = a4;
  *(double *)v12.i64 = -a3.f64[0];
  v13 = (float64x2_t)vbslq_s8(v11, v12, v10);
  *(double *)&v12.i64[1] = a2;
  *(double *)v12.i64 = a3.f64[0] + a1;
  v14 = (float64x2_t)vbslq_s8(v11, v12, v9);
  if (a4 < 0.0)
  {
    v14.f64[1] = a4 + a2;
    v13.f64[1] = -a4;
  }
  v15 = (int8x16_t)vceqzq_f64(v13);
  v16 = 0uLL;
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v15, 1), v15).u64[0] & 0x8000000000000000) == 0)
  {
    v17 = vorrq_s8((int8x16_t)vcltzq_f64(v13), (int8x16_t)vcgezq_f64(v13));
    if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v17), 1), v17).u64[0] & 0x8000000000000000) == 0)
    {
      v18 = vminnmq_f64(vaddq_f64(v14, v13), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
      v19 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v14, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      v16 = vuzp1q_s32(v19, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v18), (int64x2_t)v19));
    }
  }
  v36 = v16.i64[0];
  iosurface = CA::Render::create_iosurface((CA::Render *)1, (CA::Render *)v16.u32[2], v16.u32[3], CFSTR("CA Whippet GetLayer"), v5, v6);
  if (!iosurface)
    return 0;
  v21 = iosurface;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v23 = (CA::CG::IOSurfaceDrawable *)malloc_type_zone_malloc(malloc_zone, 0x70uLL, 0x8BB15036uLL);
  v24 = (unsigned int *)v23;
  if (!v23)
  {
    CFRelease(v21);
    v25 = MEMORY[0x48];
LABEL_14:
    *(_QWORD *)(v25 + 200) = v7;
    goto LABEL_15;
  }
  CA::CG::IOSurfaceDrawable::IOSurfaceDrawable(v23, v21, 1, 8194, Info[4], v36, HIDWORD(v36), 0, 0);
  CFRelease(v21);
  v25 = *((_QWORD *)v24 + 9);
  if (v25)
    goto LABEL_14;
  v25 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v24 + 72))(v24);
  *((_QWORD *)v24 + 9) = v25;
  if (v25)
    goto LABEL_14;
LABEL_15:
  v26 = operator new();
  *(_OWORD *)v26 = 0u;
  *(_OWORD *)(v26 + 16) = 0u;
  *(_OWORD *)(v26 + 32) = 0u;
  *(_OWORD *)(v26 + 48) = 0u;
  *(_OWORD *)(v26 + 64) = 0u;
  *(_OWORD *)(v26 + 80) = 0u;
  *(_OWORD *)(v26 + 96) = 0u;
  *(_OWORD *)(v26 + 112) = 0u;
  *(_OWORD *)(v26 + 128) = 0u;
  *(_OWORD *)(v26 + 144) = 0u;
  *(_OWORD *)(v26 + 160) = 0u;
  *(_OWORD *)(v26 + 176) = 0u;
  *(_OWORD *)(v26 + 192) = 0u;
  *(_OWORD *)(v26 + 208) = 0u;
  *(_OWORD *)(v26 + 224) = 0u;
  *(_OWORD *)(v26 + 240) = 0u;
  *(_OWORD *)(v26 + 256) = 0u;
  *(_OWORD *)(v26 + 272) = 0u;
  *(_OWORD *)(v26 + 288) = 0u;
  *(_OWORD *)(v26 + 304) = 0u;
  *(_OWORD *)(v26 + 320) = 0u;
  *(_QWORD *)(v26 + 336) = 0;
  v27 = CA::CG::ContextDelegate::ContextDelegate((CA::CG::ContextDelegate *)v26);
  *((_QWORD *)v27 + 42) = 0;
  *(_QWORD *)v27 = &off_1E1593368;
  CA::CG::AccelContextDelegate<CA::CG::IOSurfaceDrawable>::set_drawable(v27, (uint64_t)v24);
  v7 = *(_QWORD *)(v26 + 8);
  CGGStateCreate();
  CGContextDelegateOperation();
  CGGStateRelease();
  if (v24)
  {
    v28 = v24 + 2;
    do
    {
      v29 = __ldaxr(v28);
      v30 = v29 - 1;
    }
    while (__stlxr(v30, v28));
    if (!v30)
    {
      (**(void (***)(unsigned int *))v24)(v24);
      (*(void (**)(unsigned int *))(*(_QWORD *)v24 + 16))(v24);
    }
  }
  return v7;
}

uint64_t CA::CG::ContextDelegate::draw_layer_()
{
  CA::CG::IOSurfaceDrawable *v0;
  uint64_t v1;
  CGImageRef v2;
  CGImage *v3;
  uint64_t v4;

  v0 = *(CA::CG::IOSurfaceDrawable **)(CGContextDelegateGetInfo() + 336);
  if (!v0)
    return 1004;
  v1 = *((_QWORD *)v0 + 9);
  if (v1)
    CA::CG::Queue::flush(v1, 3, 1);
  v2 = CA::CG::IOSurfaceDrawable::copy_cgimage(v0);
  if (!v2)
    return 1004;
  v3 = v2;
  v4 = CGContextDelegateDrawImage();
  CGImageRelease(v3);
  return v4;
}

uint64_t CA::CG::ContextDelegate::draw_conic_gradient_(double a1, double a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, const void *a7)
{
  const double *Info;
  CA::CG::Queue *v14;
  uint64_t v15;
  unint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  Info = (const double *)CGContextDelegateGetInfo();
  v14 = (CA::CG::Queue *)(*(uint64_t (**)(const double *))(*(_QWORD *)Info + 16))(Info);
  if (v14)
  {
    v15 = (uint64_t)v14;
    v16 = CA::CG::Queue::alloc(v14, 144);
    if (v16)
    {
      v17 = (uint64_t)v16;
      v18 = CA::CG::DrawGradient::DrawGradient((uint64_t)v16, Info, a5, a6, a7, 0);
      *(_QWORD *)v18 = off_1E1592868;
      *(double *)(v18 + 120) = a1;
      *(double *)(v18 + 128) = a2;
      *(double *)(v18 + 136) = a3;
      CA::CG::ContextDelegate::submit((uint64_t)Info, v15, v17, a5, a6);
    }
  }
  return 0;
}

uint64_t CA::CG::ContextDelegate::fill_path(const double *a1, CA::CG::Queue *a2, uint64_t a3, uint64_t a4, CGColor *a5, const CGPath *a6, int a7, int a8, double *a9, char a10, char a11)
{
  uint64_t v19;
  unint64_t *v20;
  int v21;
  CGSize v22;
  void (**v23)(CA::CG::FillPath *__hidden);
  unint64_t *v24;
  int v25;
  CGSize v26;
  __int128 *CTM;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  unint64_t *v31;
  int v32;
  CGSize v33;
  __int128 v34;
  __int128 v35;
  unint64_t *v36;
  uint64_t v37;
  CGSize size;
  double *updated;
  uint64_t v40;
  int32x4_t v41;
  int32x4_t v42;
  uint64_t v43;
  int64x2_t v44;
  int64x2_t v45;
  int v46;
  int64x2_t v47;
  int32x2_t v48;
  int64x2_t v49;
  int64x2_t v50;
  const CGPath *v51;
  uint64_t v52;
  int8x16_t v53;
  float64x2_t v54;
  int8x16_t v55;
  int8x16_t v56;
  int8x16_t v57;
  float64x2_t v58;
  float64x2_t v59;
  int64x2_t v60;
  int64x2_t v61;
  int64x2_t v62;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  CGSize v67;
  double v68;
  double v69;
  double v70;
  double v71;
  const CGPath *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  float64x2_t v82;
  CGPathRef v83;
  const CGPath *v84;
  unint64_t *v85;
  int v86;
  int v87;
  double v89;
  float64x2_t v90;
  float64x2_t cornerWidth;
  CGFloat cornerWidtha;
  _OWORD v93[2];
  float64x2_t v94;
  float64x2_t v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  CGRect rect;
  uint64_t (**v103)();
  float32x2_t *v104;
  uint64_t v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  float64x2_t v110;
  double v111;
  double v112;
  float64x2_t v113;
  double v114;
  double v115;
  double v116;
  double v117;
  double v118;
  double v119;
  double v120;
  CGRect rect1;
  CGFloat MidY;
  CGPathRef path;
  uint64_t v124;
  CGRect BoundingBox;
  CGRect v126;
  CGRect v127;
  CGRect v128;
  CGRect v129;
  CGRect v130;
  CGRect v131;
  CGRect v132;

  v124 = *MEMORY[0x1E0C80C00];
  if (!CGPathIsPrimitive())
    goto LABEL_35;
  memset(&rect, 0, sizeof(rect));
  v94 = 0uLL;
  v108 = 0u;
  v109 = 0u;
  v106 = 0u;
  v107 = 0u;
  if (a8 && !CGGStateGetStyle())
  {
    v100 = 0u;
    v101 = 0u;
    v99 = 0u;
    CTM = (__int128 *)CGGStateGetCTM();
    v29 = CTM[1];
    v28 = CTM[2];
    v96 = *CTM;
    v97 = v29;
    v98 = v28;
    if (CGPathIsRectWithTransform())
    {
      CGGStateSetCTM();
      v30 = CA::CG::ContextDelegate::fill_rects((int)a1, a2, a3, a4, (int)a5, (int)&rect, 1, 0, a11);
    }
    else
    {
      if (CGPathIsEllipseWithTransform())
      {
        CGGStateSetCTM();
        v36 = CA::CG::Queue::alloc(a2, 144);
        if (!v36)
          goto LABEL_35;
        v19 = (uint64_t)v36;
        v37 = CA::CG::DrawOp::DrawOp((uint64_t)v36, a1, a3, a4, a5, 0);
        *(_QWORD *)v37 = off_1E1591358;
        size = rect.size;
        *(CGPoint *)(v37 + 112) = rect.origin;
        *(CGSize *)(v37 + 128) = size;
        *(_QWORD *)v37 = off_1E15914F8;
        goto LABEL_34;
      }
      if (CGPathIsRoundedRectWithTransform())
      {
        CGGStateSetCTM();
        v94 = vabsq_f64(v94);
        CA::CG::ContextDelegate::fill_rounded_rect(a1, a2, a3, a4, a5, &rect, (__n128 *)&v94);
      }
      else
      {
        if (!CGPathIsUnevenCornersRoundedRectWithTransform())
          goto LABEL_35;
        CGGStateSetCTM();
        CA::CG::ContextDelegate::fill_uneven_rounded_rect(a1, a2, a3, a4, a5, &rect, (uint64_t)&v106);
      }
    }
    v19 = v30;
    if (!v30)
      goto LABEL_35;
LABEL_34:
    CGGStateSetCTM();
    return v19;
  }
  if (CGPathIsRect(a6, &rect))
    return CA::CG::ContextDelegate::fill_rects((int)a1, a2, a3, a4, (int)a5, (int)&rect, 1, a8, a11);
  if (CGPathIsEllipse())
  {
    v20 = CA::CG::Queue::alloc(a2, 144);
    v19 = (uint64_t)v20;
    if (!v20)
      return v19;
    if (a8)
      v21 = 4;
    else
      v21 = 0;
    CA::CG::DrawOp::DrawOp((uint64_t)v20, a1, a3, a4, a5, v21);
    *(_QWORD *)v19 = off_1E1591358;
    v22 = rect.size;
    *(CGPoint *)(v19 + 112) = rect.origin;
    *(CGSize *)(v19 + 128) = v22;
    v23 = off_1E15914F8;
LABEL_104:
    *(_QWORD *)v19 = v23;
    return v19;
  }
  if (CGPathIsRoundedRect())
  {
    v94 = vabsq_f64(v94);
    v24 = CA::CG::Queue::alloc(a2, 160);
    v19 = (uint64_t)v24;
    if (!v24)
      return v19;
    if (a8)
      v25 = 4;
    else
      v25 = 0;
    CA::CG::DrawOp::DrawOp((uint64_t)v24, a1, a3, a4, a5, v25);
    *(_QWORD *)v19 = off_1E1592300;
    v26 = rect.size;
    *(CGPoint *)(v19 + 112) = rect.origin;
    *(CGSize *)(v19 + 128) = v26;
    *(float64x2_t *)(v19 + 144) = v94;
    v23 = off_1E1592498;
    goto LABEL_104;
  }
  if (CGPathIsUnevenCornersRoundedRectWithTransform())
  {
    v31 = CA::CG::Queue::alloc(a2, 208);
    v19 = (uint64_t)v31;
    if (v31)
    {
      if (a8)
        v32 = 4;
      else
        v32 = 0;
      CA::CG::DrawOp::DrawOp((uint64_t)v31, a1, a3, a4, a5, v32);
      *(_QWORD *)v19 = off_1E1593180;
      v33 = rect.size;
      *(CGPoint *)(v19 + 112) = rect.origin;
      *(CGSize *)(v19 + 128) = v33;
      v34 = v107;
      *(_OWORD *)(v19 + 144) = v106;
      *(_OWORD *)(v19 + 160) = v34;
      v35 = v109;
      *(_OWORD *)(v19 + 176) = v108;
      *(_OWORD *)(v19 + 192) = v35;
    }
    return v19;
  }
LABEL_35:
  updated = CA::CG::ContextDelegate::update_style((uint64_t)a1);
  if (!updated)
  {
LABEL_96:
    v85 = CA::CG::Queue::alloc(a2, 152);
    v19 = (uint64_t)v85;
    if (!v85)
      return v19;
    if (a8)
      v86 = 4;
    else
      v86 = 0;
    if (a7)
      v87 = 0x1000000;
    else
      v87 = 0;
    CA::CG::DrawPath::DrawPath((uint64_t)v85, a1, a3, a4, a5, a6, v86 | v87, a9, a10);
    v23 = off_1E1593958;
    goto LABEL_104;
  }
  v104 = 0;
  v105 = 0;
  v103 = off_1E159A518;
  (*(void (**)(double *, uint64_t (***)()))(*(_QWORD *)updated + 32))(updated, &v103);
  v40 = CA::CG::ContextDelegate::clip_stack((uint64_t)a1);
  if (v40)
  {
    v43 = *(_QWORD *)(v40 + 40);
    v41.i64[0] = *(_QWORD *)(v40 + 48);
    v44.i64[0] = (int)v43;
    v44.i64[1] = SHIDWORD(v43);
    v45 = v44;
    v46 = v41.i32[1];
    v44.i64[0] = v41.i32[0];
    v44.i64[1] = v41.i32[1];
    v47 = v44;
    if (v41.i32[0] > v41.i32[1])
      v46 = *(_QWORD *)(v40 + 48);
    v41.i32[0] = v46;
    v42.i32[0] = 1073741822;
    cornerWidth = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v41, v42), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v45));
    v48 = vdup_n_s32(v46 > 1073741822);
    v49.i64[0] = v48.u32[0];
    v49.i64[1] = v48.u32[1];
    v50 = (int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v49, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), (int8x16_t)vcvtq_f64_s64(v47));
  }
  else
  {
    v50 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    cornerWidth = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
  }
  v51 = a6;
  v90 = (float64x2_t)v50;
  if ((a8 & 1) == 0)
  {
    v52 = CGGStateGetCTM();
    v51 = (const CGPath *)MEMORY[0x186DBC64C](a6, v52);
  }
  if (!v104 || !a7)
    goto LABEL_94;
  BoundingBox = CGPathGetBoundingBox(v51);
  v53.i64[0] = *(_QWORD *)&BoundingBox.origin.x;
  v53.i64[1] = *(_QWORD *)&BoundingBox.origin.y;
  v54.f64[0] = 0.0;
  v55.i64[0] = *(_QWORD *)&BoundingBox.size.width;
  v55.i64[1] = *(_QWORD *)&BoundingBox.size.height;
  v56 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(v54, (float64x2_t)BoundingBox.size).i64[0], 0);
  v57.i64[1] = *(_QWORD *)&BoundingBox.origin.y;
  *(double *)v57.i64 = BoundingBox.size.width + BoundingBox.origin.x;
  v58 = (float64x2_t)vbslq_s8(v56, v57, v53);
  v53.i64[1] = *(_QWORD *)&BoundingBox.size.height;
  *(double *)v53.i64 = -BoundingBox.size.width;
  v59 = (float64x2_t)vbslq_s8(v56, v53, v55);
  if (BoundingBox.size.height < 0.0)
  {
    v58.f64[1] = BoundingBox.size.height + BoundingBox.origin.y;
    v59.f64[1] = -BoundingBox.size.height;
  }
  v60 = vclezq_f64(v90);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v60, 1), (int8x16_t)v60).u64[0] & 0x8000000000000000) == 0)
  {
    v61 = vclezq_f64(v59);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v61, 1), (int8x16_t)v61).u64[0] & 0x8000000000000000) == 0)
    {
      v62 = vclezq_f64(vsubq_f64(vminnmq_f64(vaddq_f64(cornerWidth, v90), vaddq_f64(v58, v59)), vmaxnmq_f64(cornerWidth, v58)));
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v62, 1), (int8x16_t)v62).u64[0] & 0x8000000000000000) == 0)
      {
LABEL_94:
        if ((a8 & 1) == 0)
          CGPathRelease(v51);
        goto LABEL_96;
      }
    }
  }
  v95 = v90;
  v94 = vsubq_f64(cornerWidth, vcvtq_f64_f32(*v104));
  CA::BoundsImpl::inset(v94.f64, *(float *)&v105 * -2.7, *(float *)&v105 * -2.7);
  bzero(&v106, 0x230uLL);
  v93[0] = v94;
  v93[1] = v95;
  *(_QWORD *)&v99 = MEMORY[0x1E0C809B0];
  *((_QWORD *)&v99 + 1) = 0x40000000;
  *(_QWORD *)&v100 = ___ZN2CA2CG19PathInverseDetector6detectEPK6CGPathNS_4RectE_block_invoke;
  *((_QWORD *)&v100 + 1) = &__block_descriptor_tmp_13887;
  *(_QWORD *)&v101 = &v106;
  CGPathApplyWithBlock2();
  if ((_DWORD)v106 != 2)
    goto LABEL_92;
  x = rect1.origin.x;
  y = rect1.origin.y;
  rect = rect1;
  width = rect1.size.width;
  height = rect1.size.height;
  if (rect1.size.width < 0.0)
  {
    rect.origin.x = rect1.size.width + rect1.origin.x;
    rect.size.width = -rect1.size.width;
  }
  if (rect1.size.height < 0.0)
  {
    rect.origin.y = rect1.size.height + rect1.origin.y;
    rect.size.height = -rect1.size.height;
  }
  if (!CA::BoundsImpl::contains(&rect.origin.x, (double *)v93))
    goto LABEL_92;
  v67 = *(CGSize *)(MEMORY[0x1E0C9D648] + 16);
  rect.origin = (CGPoint)*MEMORY[0x1E0C9D648];
  rect.size = v67;
  if (!CA::CG::PathInverseDetector::detect_rect((CA::CG::PathInverseDetector *)&v106, &rect))
    goto LABEL_60;
  v68 = rect.origin.y;
  v69 = rect.size.width;
  v70 = rect.size.height;
  v126.origin.x = x;
  v126.origin.y = y;
  v71 = rect.origin.x;
  v126.size.width = width;
  v126.size.height = height;
  if (!CGRectContainsRect(v126, rect))
  {
LABEL_60:
    v73 = *((_QWORD *)&v106 + 1);
    if (*((_QWORD *)&v106 + 1) == 5)
    {
      if ((_BYTE)v107)
        goto LABEL_84;
      v74 = 0;
      while (v74 != 5)
      {
        v75 = v74 + 1;
        v76 = *((unsigned __int8 *)&v107 + v74 + 1);
        v77 = dword_18475E8BC[++v74];
        if (v77 != v76)
        {
          if ((unint64_t)(v75 - 1) < 5)
            goto LABEL_84;
          break;
        }
      }
      if (v113.f64[1] != v118 || v111 != v115)
        goto LABEL_84;
      v71 = v113.f64[0];
      v68 = v112;
      v69 = v117 - v113.f64[0];
      v70 = v116 - v112;
      rect.origin.x = v113.f64[0];
      rect.origin.y = v112;
      rect.size.width = v117 - v113.f64[0];
      rect.size.height = v116 - v112;
      v131.origin.x = v113.f64[0];
      v131.origin.y = v112;
      v131.size.width = v117 - v113.f64[0];
      v131.size.height = v116 - v112;
      if (CGRectContainsRect(rect1, v131))
      {
        v128.origin.x = v71;
        v128.origin.y = v68;
        v128.size.width = v69;
        v128.size.height = v70;
        v72 = CGPathCreateWithEllipseInRect(v128, 0);
        goto LABEL_59;
      }
      v73 = *((_QWORD *)&v106 + 1);
    }
    if (v73 == 9 && !(_BYTE)v107)
    {
      v78 = 0;
      while (v78 != 9)
      {
        v79 = v78 + 1;
        v80 = *((unsigned __int8 *)&v107 + v78 + 1);
        v81 = dword_18475E8D4[++v78];
        if (v81 != v80)
        {
          if ((unint64_t)(v79 - 1) < 9)
            goto LABEL_84;
          break;
        }
      }
      v82 = vabdq_f64(v110, v113);
      v71 = v110.f64[0] >= v119 ? v119 : v110.f64[0];
      v68 = v120 >= v114 ? v114 : v120;
      v69 = vabdd_f64(v110.f64[0], v119);
      v70 = vabdd_f64(v120, v114);
      rect.origin.x = v71;
      rect.origin.y = v68;
      rect.size.width = v69;
      rect.size.height = v70;
      if (v82.f64[0] + v82.f64[0] <= v69)
      {
        v89 = v82.f64[1];
        if (v89 + v89 <= v70)
        {
          cornerWidtha = v82.f64[0];
          v132.origin.x = v71;
          v132.origin.y = v68;
          v132.size.width = v69;
          v132.size.height = v70;
          if (CGRectContainsRect(rect1, v132))
          {
            v130.origin.x = v71;
            v130.origin.y = v68;
            v130.size.width = v69;
            v130.size.height = v70;
            v72 = CGPathCreateWithRoundedRect(v130, cornerWidtha, v89, 0);
            goto LABEL_59;
          }
        }
LABEL_85:
        LODWORD(v106) = 3;
        goto LABEL_86;
      }
    }
LABEL_84:
    v71 = rect.origin.x;
    v68 = rect.origin.y;
    v69 = rect.size.width;
    v70 = rect.size.height;
    goto LABEL_85;
  }
  v127.origin.x = v71;
  v127.origin.y = v68;
  v127.size.width = v69;
  v127.size.height = v70;
  v72 = CGPathCreateWithRect(v127, 0);
LABEL_59:
  path = v72;
LABEL_86:
  v129.origin.x = v71;
  v129.origin.y = v68;
  v129.size.width = v69;
  v129.size.height = v70;
  MidY = CGRectGetMidY(v129);
  *((_QWORD *)&v106 + 1) = 0;
  if ((_DWORD)v106 == 3
    || (*(_QWORD *)&v96 = MEMORY[0x1E0C809B0],
        *((_QWORD *)&v96 + 1) = 0x40000000,
        *(_QWORD *)&v97 = ___ZN2CA2CG19PathInverseDetector6detectEPK6CGPathNS_4RectE_block_invoke_2,
        *((_QWORD *)&v97 + 1) = &__block_descriptor_tmp_1_13888,
        *(_QWORD *)&v98 = &v106,
        CGPathApplyWithBlock2(),
        (_DWORD)v106 != 2))
  {
LABEL_92:
    v84 = path;
LABEL_93:
    CGPathRelease(v84);
    goto LABEL_94;
  }
  v83 = path;
  if (!path)
  {
    v84 = 0;
    goto LABEL_93;
  }
  if ((a8 & 1) == 0)
    CGPathRelease(v51);
  v19 = CA::CG::ContextDelegate::fill_path(a1, a2, a3, a4, a5, v83, 1, 1, 0, 257);
  *(_DWORD *)(v19 + 100) |= 0x400u;
  CGPathRelease(path);
  return v19;
}

unint64_t *CA::CG::ContextDelegate::stroke_path(const double *a1, CA::CG::Queue *a2, uint64_t a3, uint64_t a4, CGColor *a5, const CGPath *a6, int a7)
{
  unint64_t *v15;
  unint64_t *v16;
  int v17;
  _QWORD *v18;
  uint64_t v19;
  int LineJoin;
  unint64_t *v22;
  int v23;
  CGSize size;
  BOOL v25;
  int v26;
  int v27;
  int LineCap;
  uint64_t CTM;
  __int128 v30;
  int64x2_t v31;
  float64x2_t v32;
  float64x2_t v33;
  int8x16_t v34;
  unsigned int v35;
  int32x2_t v36;
  int64x2_t v37;
  float64x2_t v38;
  float64x2_t v39;
  float64x2_t v40;
  int8x16_t v41;
  unsigned int v42;
  int32x2_t v43;
  int64x2_t v44;
  int64x2_t v45;
  CGFloat v46;
  double v47;
  double v48;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  unint64_t *v53;
  CGFloat v54;
  CGFloat v55;
  float64x2_t sx;
  uint64_t v57;
  CGAffineTransform v58;
  CGAffineTransform t2;
  CGAffineTransform t1;
  CGAffineTransform v61;
  int64x2_t v62;
  int64x2_t v63;
  __int128 v64;
  float64x2_t v65;
  float64x2_t v66;
  __int128 v67;
  double v68;
  unint64_t v69;
  double v70;
  unint64_t v71[2];
  float64x2_t v72;
  CGRect rect;
  __int128 v74[2];
  uint64_t v75;
  CGRect v76;
  CGRect v77;

  v75 = *MEMORY[0x1E0C80C00];
  memset(&rect, 0, sizeof(rect));
  memset(v74, 0, sizeof(v74));
  v72 = 0uLL;
  v71[0] = 0;
  v71[1] = 0;
  v69 = 0;
  v70 = 0.0;
  v68 = 0.0;
  if (!CGPathIsLine())
  {
    if (!CGPathIsPrimitive() || CGGStateGetLineDash())
      goto LABEL_6;
    LineJoin = CGGStateGetLineJoin();
    if (CGGStateGetStyle())
    {
      if (!LineJoin && CGPathIsRect(a6, &rect))
        return CA::CG::ContextDelegate::stroke_rects(a1, a2, a3, a4, a5, (uint64_t)&rect, 1uLL, a7);
      if (CGPathIsEllipse())
      {
        v22 = CA::CG::Queue::alloc(a2, 184);
        v15 = v22;
        if (!v22)
          return v15;
        if (a7)
          v23 = 4;
        else
          v23 = 0;
        CA::CG::DrawOp::DrawOp((uint64_t)v22, a1, a3, a4, a5, v23);
        *v15 = (unint64_t)off_1E1591358;
        size = rect.size;
        *((_OWORD *)v15 + 7) = rect.origin;
        *((CGSize *)v15 + 8) = size;
        *v15 = (unint64_t)off_1E1591E20;
        v19 = (uint64_t)(v15 + 18);
        goto LABEL_11;
      }
      if (CGPathIsRoundedRect())
      {
        v72 = vabsq_f64(v72);
        return CA::CG::ContextDelegate::stroke_rounded_rect(a1, a2, a3, a4, a5, &rect, &v72, a7);
      }
LABEL_6:
      v16 = CA::CG::Queue::alloc(a2, 192);
      v15 = v16;
      if (!v16)
        return v15;
      if (a7)
        v17 = 4;
      else
        v17 = 0;
      v18 = (_QWORD *)CA::CG::DrawPath::DrawPath((uint64_t)v16, a1, a3, a4, a5, a6, v17, 0, 1);
      *v18 = off_1E1591288;
      v19 = (uint64_t)(v18 + 19);
LABEL_11:
      CA::CG::StrokeState::StrokeState(v19);
      return v15;
    }
    v66 = 0u;
    v67 = 0u;
    v65 = 0u;
    if (LineJoin || (CGPathIsRectWithTransform() & 1) == 0)
    {
      if ((CGPathIsEllipseWithTransform() & 1) != 0)
      {
        v25 = 0;
        v27 = 0;
        v57 = 0;
        v26 = 1;
      }
      else if ((CGPathIsRoundedRectWithTransform() & 1) != 0)
      {
        v25 = 0;
        v27 = 0;
        v26 = 0;
        v57 = 0x100000000;
      }
      else if (CGPathIsArc())
      {
        if (v68 == 0.0)
          return 0;
        LineCap = CGGStateGetLineCap();
        v27 = 0;
        v26 = 0;
        v57 = LineCap == 0;
        v25 = LineCap != 0;
      }
      else
      {
        v27 = 0;
        v26 = 0;
        v57 = 0;
        v25 = 1;
      }
    }
    else
    {
      v25 = 0;
      v26 = 0;
      v57 = 0;
      v27 = 1;
    }
    CTM = CGGStateGetCTM();
    v31 = *(int64x2_t *)(CTM + 16);
    v30 = *(_OWORD *)(CTM + 32);
    v62 = *(int64x2_t *)CTM;
    v63 = v31;
    v64 = v30;
    if ((a7 & 1) == 0)
    {
      *(float64x2_t *)&t1.a = v65;
      *(float64x2_t *)&t1.c = v66;
      *(_OWORD *)&t1.tx = v67;
      *(int64x2_t *)&t2.a = v62;
      *(int64x2_t *)&t2.c = v63;
      *(_OWORD *)&t2.tx = v64;
      CGAffineTransformConcat(&v61, &t1, &t2);
      v65 = *(float64x2_t *)&v61.a;
      v66 = *(float64x2_t *)&v61.c;
      v67 = *(_OWORD *)&v61.tx;
    }
    if (v25 || -(v66.f64[0] * v65.f64[1] - v66.f64[1] * v65.f64[0]) == 0.0)
      goto LABEL_6;
    v32 = (float64x2_t)vzip1q_s64(v62, v63);
    v33 = (float64x2_t)vzip2q_s64(v62, v63);
    v34 = (int8x16_t)vmlaq_f64(vmulq_f64(v32, v32), v33, v33);
    v35 = *(double *)v34.i64 != 1.0;
    if (*(double *)&v34.i64[1] != 1.0)
      v35 = 1;
    v36 = vdup_n_s32(v35);
    v37.i64[0] = v36.u32[0];
    v37.i64[1] = v36.u32[1];
    v38 = (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v37, 0x3FuLL)), (int8x16_t)vsqrtq_f64((float64x2_t)v34), v34);
    v39 = (float64x2_t)vzip1q_s64((int64x2_t)v65, (int64x2_t)v66);
    v40 = (float64x2_t)vzip2q_s64((int64x2_t)v65, (int64x2_t)v66);
    v41 = (int8x16_t)vmlaq_f64(vmulq_f64(v39, v39), v40, v40);
    v42 = *(double *)v41.i64 != 1.0;
    if (*(double *)&v41.i64[1] != 1.0)
      v42 = 1;
    v43 = vdup_n_s32(v42);
    v44.i64[0] = v43.u32[0];
    v44.i64[1] = v43.u32[1];
    v45 = (int64x2_t)vdivq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v44, 0x3FuLL)), (int8x16_t)vsqrtq_f64((float64x2_t)v41), v41), v38);
    v46 = *(double *)&v45.i64[1];
    v47 = *(double *)v45.i64 / *(double *)&v45.i64[1];
    if (*(double *)v45.i64 / *(double *)&v45.i64[1] < 0.0)
      v47 = -(*(double *)v45.i64 / *(double *)&v45.i64[1]);
    v48 = 1.0 - v47;
    if (v47 + -1.0 >= 0.0)
      v48 = v47 + -1.0;
    if (v48 >= 0.001)
      goto LABEL_6;
    v65 = vdivq_f64(v65, (float64x2_t)vdupq_lane_s64(v45.i64[0], 0));
    v66 = vdivq_f64(v66, (float64x2_t)vdupq_laneq_s64(v45, 1));
    sx = (float64x2_t)v45;
    CGGStateSetCTM();
    x = rect.origin.x;
    y = rect.origin.y;
    width = rect.size.width;
    height = rect.size.height;
    CGAffineTransformMakeScale(&v58, sx.f64[0], v46);
    v76.origin.x = x;
    v76.origin.y = y;
    v76.size.width = width;
    v76.size.height = height;
    v77 = CGRectApplyAffineTransform(v76, &v58);
    rect = v77;
    if (v27)
    {
      v53 = CA::CG::ContextDelegate::stroke_rects(a1, a2, a3, a4, a5, (uint64_t)&rect, 1uLL, 0);
      goto LABEL_60;
    }
    if (v26)
    {
      v53 = CA::CG::ContextDelegate::stroke_ellipse(a1, a2, a3, a4, a5, &rect);
      goto LABEL_60;
    }
    if (HIDWORD(v57))
    {
      v72 = vabsq_f64(vmulq_f64(v72, sx));
      v54 = v72.f64[0] + v72.f64[0];
      if (v54 <= CGRectGetWidth(v77))
      {
        v55 = v72.f64[1] + v72.f64[1];
        if (v55 <= CGRectGetHeight(rect))
        {
          v53 = CA::CG::ContextDelegate::stroke_rounded_rect(a1, a2, a3, a4, a5, &rect, &v72, 0);
          goto LABEL_60;
        }
      }
    }
    else if ((_DWORD)v57)
    {
      v61.a = v70 * sx.f64[0];
      v53 = CA::CG::ContextDelegate::stroke_arc(a1, a2, a3, a4, a5, v71, (unint64_t *)&v61, &v69, (unint64_t *)&v68);
LABEL_60:
      v15 = v53;
      CGGStateSetCTM();
      if (v15)
        return v15;
      goto LABEL_6;
    }
    CGGStateSetCTM();
    goto LABEL_6;
  }
  return (unint64_t *)CA::CG::ContextDelegate::draw_lines(a1, (CA::CG::DrawOp **)a2, a3, a4, a5, v74, 2uLL, a7);
}

CA::CG::DrawOp *CA::CG::ContextDelegate::draw_lines(const double *a1, CA::CG::DrawOp **this, uint64_t a3, uint64_t a4, CGColor *a5, __int128 *a6, unint64_t a7, int a8)
{
  uint64_t v16;
  unint64_t *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  CA::CG::DrawOp *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  __int128 v26;

  v16 = 16 * a7;
  v17 = CA::CG::Queue::alloc((CA::CG::Queue *)this, 16 * a7 + 160);
  v18 = v17;
  v19 = 0;
  v20 = a7;
  do
  {
    *(_OWORD *)&v17[v19 / 8 + 20] = a6[v19 / 0x10];
    v19 += 16;
    --v20;
  }
  while (v20);
  if (a8)
    v21 = 4;
  else
    v21 = 0;
  CA::CG::DrawOp::DrawOp((uint64_t)v17, a1, a3, a4, a5, v21);
  *v18 = (unint64_t)off_1E1593BE8;
  CA::CG::StrokeState::StrokeState((uint64_t)(v18 + 14));
  v18[19] = a7;
  v22 = this[5];
  if (v22
    && !*((_QWORD *)v22 + 13)
    && !CGGStateGetStyle()
    && (*(unsigned int (**)(CA::CG::DrawOp *, unint64_t *))(*(_QWORD *)v22 + 104))(v22, v18)
    && CA::CG::Queue::cancel_and_grow((CA::CG::Queue *)this, (CA::CG::DrawOp *)v18, v22, v16))
  {
    v23 = *((_QWORD *)v22 + 19);
    v24 = 16 * v23 + 160;
    v25 = a7;
    do
    {
      v26 = *a6++;
      *(_OWORD *)((char *)v22 + v24) = v26;
      v24 += 16;
      --v25;
    }
    while (v25);
    *((_QWORD *)v22 + 19) = v23 + a7;
    return v22;
  }
  return (CA::CG::DrawOp *)v18;
}

unint64_t *CA::CG::ContextDelegate::stroke_rects(const double *a1, CA::CG::Queue *this, uint64_t a3, uint64_t a4, CGColor *a5, uint64_t a6, unint64_t a7, int a8)
{
  unint64_t *v15;
  unint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  __int128 v20;
  int v21;

  v15 = CA::CG::Queue::alloc(this, 32 * a7 + 160);
  v16 = v15;
  v17 = 0;
  v18 = a7;
  do
  {
    v19 = &v15[v17];
    v20 = *(_OWORD *)(a6 + v17 * 8 + 16);
    *((_OWORD *)v19 + 10) = *(_OWORD *)(a6 + v17 * 8);
    *((_OWORD *)v19 + 11) = v20;
    v17 += 4;
    --v18;
  }
  while (v18);
  if (a8)
    v21 = 4;
  else
    v21 = 0;
  CA::CG::DrawOp::DrawOp((uint64_t)v15, a1, a3, a4, a5, v21 | ((a7 == 1) << 24));
  v16[14] = a7;
  *v16 = (unint64_t)off_1E1591610;
  CA::CG::StrokeState::StrokeState((uint64_t)(v16 + 15));
  return v16;
}

unint64_t *CA::CG::ContextDelegate::stroke_ellipse(const double *a1, CA::CG::Queue *this, uint64_t a3, uint64_t a4, CGColor *a5, _OWORD *a6)
{
  unint64_t *v11;
  unint64_t *v12;
  __int128 v13;

  v11 = CA::CG::Queue::alloc(this, 184);
  v12 = v11;
  if (v11)
  {
    CA::CG::DrawOp::DrawOp((uint64_t)v11, a1, a3, a4, a5, 0);
    *v12 = (unint64_t)off_1E1591358;
    v13 = a6[1];
    *((_OWORD *)v12 + 7) = *a6;
    *((_OWORD *)v12 + 8) = v13;
    *v12 = (unint64_t)off_1E1591E20;
    CA::CG::StrokeState::StrokeState((uint64_t)(v12 + 18));
  }
  return v12;
}

unint64_t *CA::CG::ContextDelegate::stroke_rounded_rect(const double *a1, CA::CG::Queue *this, uint64_t a3, uint64_t a4, CGColor *a5, _OWORD *a6, _OWORD *a7, int a8)
{
  unint64_t *v15;
  unint64_t *v16;
  int v17;
  __int128 v18;

  v15 = CA::CG::Queue::alloc(this, 200);
  v16 = v15;
  if (v15)
  {
    if (a8)
      v17 = 4;
    else
      v17 = 0;
    CA::CG::DrawOp::DrawOp((uint64_t)v15, a1, a3, a4, a5, v17);
    *v16 = (unint64_t)off_1E1592300;
    v18 = a6[1];
    *((_OWORD *)v16 + 7) = *a6;
    *((_OWORD *)v16 + 8) = v18;
    *((_OWORD *)v16 + 9) = *a7;
    *v16 = (unint64_t)off_1E1592B50;
    CA::CG::StrokeState::StrokeState((uint64_t)(v16 + 20));
  }
  return v16;
}

unint64_t *CA::CG::ContextDelegate::stroke_arc(const double *a1, CA::CG::Queue *this, uint64_t a3, uint64_t a4, CGColor *a5, unint64_t *a6, unint64_t *a7, unint64_t *a8, unint64_t *a9)
{
  unint64_t *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;

  v16 = CA::CG::Queue::alloc(this, 192);
  v17 = v16;
  if (v16)
  {
    v18 = *a6;
    v19 = a6[1];
    v20 = *a7;
    v21 = *a8;
    v22 = *a9;
    CA::CG::DrawOp::DrawOp((uint64_t)v16, a1, a3, a4, a5, 0);
    *v17 = (unint64_t)off_1E158A6A0;
    CA::CG::StrokeState::StrokeState((uint64_t)(v17 + 14));
    v17[19] = v18;
    v17[20] = v19;
    v17[21] = v20;
    v17[22] = v21;
    v17[23] = v22;
  }
  return v17;
}

uint64_t CA::CG::DrawEllipse::debug_color(CA::CG::DrawEllipse *this)
{
  return 1109371872;
}

uint64_t CA::CG::DrawRoundedRect::debug_color(CA::CG::DrawRoundedRect *this)
{
  return 1249126880;
}

__n128 CA::CG::ContextDelegate::fill_rounded_rect(const double *a1, CA::CG::Queue *this, uint64_t a3, uint64_t a4, CGColor *a5, _OWORD *a6, __n128 *a7)
{
  unint64_t *v13;
  __n128 result;
  uint64_t v15;
  __int128 v16;

  v13 = CA::CG::Queue::alloc(this, 160);
  if (v13)
  {
    v15 = CA::CG::DrawOp::DrawOp((uint64_t)v13, a1, a3, a4, a5, 0);
    *(_QWORD *)v15 = off_1E1592300;
    v16 = a6[1];
    *(_OWORD *)(v15 + 112) = *a6;
    *(_OWORD *)(v15 + 128) = v16;
    result = *a7;
    *(__n128 *)(v15 + 144) = *a7;
    *(_QWORD *)v15 = off_1E1592498;
  }
  return result;
}

__n128 CA::CG::ContextDelegate::fill_uneven_rounded_rect(const double *a1, CA::CG::Queue *this, uint64_t a3, uint64_t a4, CGColor *a5, _OWORD *a6, uint64_t a7)
{
  unint64_t *v13;
  __n128 result;
  uint64_t v15;
  __int128 v16;

  v13 = CA::CG::Queue::alloc(this, 208);
  if (v13)
  {
    v15 = CA::CG::DrawOp::DrawOp((uint64_t)v13, a1, a3, a4, a5, 0);
    *(_QWORD *)v15 = off_1E1593180;
    v16 = a6[1];
    *(_OWORD *)(v15 + 112) = *a6;
    *(_OWORD *)(v15 + 128) = v16;
    *(_OWORD *)(v15 + 144) = *(_OWORD *)a7;
    *(_OWORD *)(v15 + 160) = *(_OWORD *)(a7 + 16);
    *(_OWORD *)(v15 + 176) = *(_OWORD *)(a7 + 32);
    result = *(__n128 *)(a7 + 48);
    *(__n128 *)(v15 + 192) = result;
  }
  return result;
}

float CA::CG::ContextDelegate::fill_path(CA::CG::Queue *,CGRenderingState *,CGGState *,CGColor *,CGPath const*,BOOL,BOOL,CGRect const*,BOOL,BOOL)::ShadowParamDetector::visit(uint64_t a1, uint64_t a2)
{
  float result;

  *(_QWORD *)(a1 + 8) = a2 + 80;
  result = *(float *)(a2 + 76);
  *(float *)(a1 + 16) = result;
  return result;
}

uint64_t CA::CG::AccelContextDelegate<CA::CG::IOSurfaceDrawable>::gpu_registry_id(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 336) + 72);
  if (v1)
    return *(_QWORD *)(v1 + 200);
  else
    return 0;
}

void CA::CG::AccelContextDelegate<CA::CG::IOSurfaceDrawable>::~AccelContextDelegate(CA::CG::ContextDelegate *this)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *(_QWORD *)this = &off_1E1592F18;
  v2 = (unsigned int *)*((_QWORD *)this + 42);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      (**(void (***)(unsigned int *))v2)(v2);
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 16))(v2);
    }
  }
  CA::CG::ContextDelegate::~ContextDelegate((CGColorSpaceRef *)this);
}

{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *(_QWORD *)this = &off_1E1592F18;
  v2 = (unsigned int *)*((_QWORD *)this + 42);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      (**(void (***)(unsigned int *))v2)(v2);
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 16))(v2);
    }
  }
  CA::CG::ContextDelegate::~ContextDelegate((CGColorSpaceRef *)this);
  JUMPOUT(0x186DBD990);
}

void CA::CG::DrawOp::set_clip_stack(CA::CG::DrawOp *this, const CA::CG::ClipStack *a2)
{
  unsigned int *v3;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;

  v3 = (unsigned int *)*((_QWORD *)this + 9);
  if (v3 != (unsigned int *)a2)
  {
    if (v3)
    {
      do
      {
        v5 = __ldaxr(v3);
        v6 = v5 - 1;
      }
      while (__stlxr(v6, v3));
      if (!v6)
        CA::CG::ClipStack::destroy_clip_stack((void (***)(char *))v3);
    }
    if (a2)
    {
      do
        v7 = __ldaxr((unsigned int *)a2);
      while (__stlxr(v7 + 1, (unsigned int *)a2));
    }
    *((_QWORD *)this + 9) = a2;
  }
}

uint64_t CA::CG::DrawGlyphs::debug_color(CA::CG::DrawGlyphs *this)
{
  return 3912966880;
}

uint64_t CA::MachPortUtil::ClientIPC::create(mach_port_context_t context, const char *a2)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  _QWORD v11[5];
  mach_port_name_t v12;
  _QWORD handler[4];
  mach_port_name_t v14;
  mach_port_name_t name;
  mach_port_options_t options;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)context || *(_QWORD *)(context + 8) || *(_QWORD *)(context + 16))
    __assert_rtn("create", "CAMachPortUtil.cpp", 67, "_port == MACH_PORT_NULL && !_queue && !_source");
  name = 0;
  *(_OWORD *)&options.flags = xmmword_18475F108;
  options.reserved[1] = 0;
  v4 = mach_port_construct(*MEMORY[0x1E0C83DA0], &options, context, &name);
  if (!(_DWORD)v4 && name + 1 >= 2)
  {
    v5 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
    v6 = dispatch_queue_create(a2, v5);
    *(_QWORD *)(context + 8) = v6;
    v7 = dispatch_source_create(MEMORY[0x1E0C80D98], name, 0, v6);
    *(_QWORD *)(context + 16) = v7;
    v8 = MEMORY[0x1E0C809B0];
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 0x40000000;
    handler[2] = ___ZN2CA12MachPortUtil9ClientIPC6createEPKc_block_invoke;
    handler[3] = &__block_descriptor_tmp_4_8148;
    v14 = name;
    dispatch_source_set_event_handler(v7, handler);
    v9 = *(NSObject **)(context + 16);
    v11[0] = v8;
    v11[1] = 0x40000000;
    v11[2] = ___ZN2CA12MachPortUtil9ClientIPC6createEPKc_block_invoke_2;
    v11[3] = &__block_descriptor_tmp_5_8149;
    v12 = name;
    v11[4] = context;
    dispatch_source_set_cancel_handler(v9, v11);
    *(_DWORD *)context = name;
  }
  return v4;
}

void ___ZN2CA12MachPortUtil9ClientIPC6createEPKc_block_invoke(uint64_t a1)
{
  mach_port_name_t v1;
  _QWORD *v2;
  mach_msg_return_t v3;
  uint64_t (*v4)();
  mach_error_t v5;
  NSObject *v6;
  char *v7;
  uint8_t buf[4];
  char *v9;
  uint64_t v10;
  _BYTE v11[12];
  int v12;
  _BYTE msg[32];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = *(_DWORD *)(a1 + 32);
  v2 = (_QWORD *)MEMORY[0x1E0C804E8];
  while (1)
  {
    v22 = 0;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    memset(msg, 0, sizeof(msg));
    v3 = mach_msg((mach_msg_header_t *)msg, 258, 0, 0xA4u, v1, 0, 0);
    if (v3)
      break;
    v12 = 0;
    *(_DWORD *)&v11[8] = 0;
    *(_DWORD *)buf = msg[0] & 0x1F;
    LODWORD(v9) = 36;
    *(_QWORD *)v11 = (*(_DWORD *)&msg[20] + 100);
    HIDWORD(v9) = *(_DWORD *)&msg[8];
    v10 = 0;
    if ((*(_DWORD *)&msg[20] - 40414) >= 0xFFFFFFF2
      && (v4 = CACCARenderClient_subsystem[5 * (*(_DWORD *)&msg[20] - 40400) + 5]) != 0)
    {
      ((void (*)(_BYTE *, uint8_t *))v4)(msg, buf);
    }
    else
    {
      *(_QWORD *)&v11[4] = *v2;
      v12 = -303;
      mach_msg_destroy((mach_msg_header_t *)msg);
    }
  }
  v5 = v3;
  if (v3 != 268451843)
  {
    if (x_log_hook_p())
    {
      mach_error_string(v5);
      x_log_();
    }
    else
    {
      v6 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        v7 = mach_error_string(v5);
        *(_DWORD *)buf = 136315394;
        v9 = v7;
        LOWORD(v10) = 1024;
        *(_DWORD *)((char *)&v10 + 2) = v5;
        _os_log_impl(&dword_184457000, v6, OS_LOG_TYPE_ERROR, "CARenderServerProcessClientMessage mach_msg failed with %s [0x%x]", buf, 0x12u);
      }
    }
  }
}

uint64_t ___ZN2CA12MachPortUtil9ClientIPC6createEPKc_block_invoke_2(uint64_t a1)
{
  return mach_port_destruct(*MEMORY[0x1E0C83DA0], *(_DWORD *)(a1 + 40), -1, *(_QWORD *)(a1 + 32));
}

void CA::MachPortUtil::ClientIPC::destroy(CA::MachPortUtil::ClientIPC *this)
{
  NSObject *v2;
  NSObject *v3;

  v2 = *((_QWORD *)this + 2);
  if (v2)
  {
    dispatch_activate(v2);
    dispatch_source_cancel(*((dispatch_source_t *)this + 2));
    dispatch_release(*((dispatch_object_t *)this + 2));
    *((_QWORD *)this + 2) = 0;
  }
  v3 = *((_QWORD *)this + 1);
  if (v3)
  {
    dispatch_release(v3);
    *((_QWORD *)this + 1) = 0;
  }
  *(_DWORD *)this = 0;
}

uint64_t CA_CLIENT_MACH_PORT_ALLOCATE_FAILED(uint64_t result, int a2)
{
  int v2;
  char *v3;

  if ((a2 - 1) >= 0xFFFFFFFE)
  {
    v2 = result;
    v3 = mach_error_string(result);
    x_log_crash("Client mach port creation failed 0x%x : %s", v2, v3);
    abort();
  }
  return result;
}

uint64_t CA::WindowServer::IOSurface::ycbcr_matrix(CA::WindowServer::IOSurface *this)
{
  uint64_t result;
  unsigned int *v3;

  result = *((unsigned int *)this + 66);
  if ((_DWORD)result == -1)
  {
    v3 = (unsigned int *)((char *)this + 264);
    if (IOSurfaceGetYCbCrMatrix())
    {
      result = 0;
      *v3 = 0;
    }
    else
    {
      return *v3;
    }
  }
  return result;
}

uint64_t CA::WindowServer::IOSurface::set_ycbcr_matrix(uint64_t this, int a2)
{
  if (*(_DWORD *)(this + 264) != a2)
  {
    *(_DWORD *)(this + 264) = a2;
    return IOSurfaceSetYCbCrMatrix();
  }
  return this;
}

uint64_t CA::WindowServer::IOSurface::transfer_function(CA::WindowServer::IOSurface *this)
{
  uint64_t result;

  result = *((unsigned int *)this + 67);
  if ((_DWORD)result == -1)
  {
    if (IOSurfaceGetBulkAttachments())
      result = 0;
    else
      result = 0;
    *((_DWORD *)this + 67) = 0;
  }
  return result;
}

uint64_t CA::WindowServer::IOSurface::set_transfer_function(uint64_t this, int a2)
{
  int v2;
  uint64_t v3;

  if (a2)
    v2 = a2;
  else
    v2 = 13;
  if (*(_DWORD *)(this + 268) != v2)
  {
    v3 = this;
    this = IOSurfaceSetBulkAttachments2();
    *(_DWORD *)(v3 + 268) = v2;
  }
  return this;
}

uint64_t CA::WindowServer::IOSurface::is_linear(CA::WindowServer::IOSurface *this)
{
  return *((unsigned __int8 *)this + 288);
}

uint64_t CA::WindowServer::IOSurface::copy_hdr_static_metadata(uint64_t this, const CA::WindowServer::Surface *a2)
{
  if (a2)
  {
    if (*(_QWORD *)(this + 240))
    {
      this = (*(uint64_t (**)(const CA::WindowServer::Surface *))(*(_QWORD *)a2 + 160))(a2);
      if (this)
      {
        this = (*(uint64_t (**)(const CA::WindowServer::Surface *))(*(_QWORD *)a2 + 40))(a2);
        if ((_DWORD)this == 16)
        {
          (*(void (**)(const CA::WindowServer::Surface *))(*(_QWORD *)a2 + 160))(a2);
          this = IOSurfaceGetBulkAttachments();
          if (!(_DWORD)this)
            return IOSurfaceSetBulkAttachments2();
        }
      }
    }
  }
  return this;
}

void CA::WindowServer::IOSurface::copy_avd_histogram_info(CA::WindowServer::IOSurface *this, const CA::WindowServer::Surface *a2)
{
  __IOSurface *v4;
  CFTypeRef v5;
  const void *v6;
  NSObject *v7;
  const char *v8;
  uint8_t *v9;
  __int16 v10;
  uint8_t buf[2];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (!a2
    || !*((_QWORD *)this + 30)
    || !(*(uint64_t (**)(const CA::WindowServer::Surface *))(*(_QWORD *)a2 + 160))(a2))
  {
    if (!x_log_hook_p())
    {
      v7 = x_log_category_windowserver;
      if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
        return;
      *(_WORD *)buf = 0;
      v8 = "Failed to copy avd histogram info, invalid buffer";
      v9 = buf;
      goto LABEL_10;
    }
LABEL_7:
    x_log_();
    return;
  }
  v4 = (__IOSurface *)(*(uint64_t (**)(const CA::WindowServer::Surface *))(*(_QWORD *)a2 + 160))(a2);
  v5 = IOSurfaceCopyValue(v4, CFSTR("kIOSurfacePixelMetadata"));
  if (v5)
  {
    v6 = v5;
    IOSurfaceSetValue(*((IOSurfaceRef *)this + 30), CFSTR("kIOSurfacePixelMetadata"), v5);
    CFRelease(v6);
    return;
  }
  if (x_log_hook_p())
    goto LABEL_7;
  v7 = x_log_category_windowserver;
  if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
  {
    v10 = 0;
    v8 = "Failed to copy avd histogram info, missing histogram";
    v9 = (uint8_t *)&v10;
LABEL_10:
    _os_log_impl(&dword_184457000, v7, OS_LOG_TYPE_ERROR, v8, v9, 2u);
  }
}

uint64_t CA::WindowServer::IOSurface::lock(CA::WindowServer::IOSurface *this, unsigned __int8 **a2, unint64_t *a3)
{
  int v6;
  uint64_t result;

  v6 = *((_DWORD *)this + 64);
  *((_DWORD *)this + 64) = v6 + 1;
  if (v6 || !IOSurfaceLock(*((IOSurfaceRef *)this + 30), 0, 0))
  {
    *a2 = (unsigned __int8 *)IOSurfaceGetBaseAddress(*((IOSurfaceRef *)this + 30));
    *a3 = IOSurfaceGetBytesPerRow(*((IOSurfaceRef *)this + 30));
    return 1;
  }
  else
  {
    result = 0;
    --*((_DWORD *)this + 64);
  }
  return result;
}

uint64_t CA::WindowServer::IOSurface::unlock(uint64_t this)
{
  int v1;

  v1 = *(_DWORD *)(this + 256) - 1;
  *(_DWORD *)(this + 256) = v1;
  if (!v1)
  {
    IOSurfaceUnlock(*(IOSurfaceRef *)(this + 240), 0, 0);
    return IOSurfaceFlushProcessorCaches();
  }
  return this;
}

BOOL CA::WindowServer::IOSurface::clear_iosurface(CA::WindowServer::IOSurface *this, CA::WindowServer::Surface *a2, __int16 a3, CA::Rect *a4)
{
  uint64_t v7;
  __CFRunLoop *v8;
  uint64_t v9;
  BOOL v10;
  __IOSurface *v11;
  int v12;
  __CFDictionary *v13;
  uint64_t v14;
  int v15;
  const __CFDictionary *v16;
  void *v17;
  CFIndex v18;
  const __CFDictionary *v19;
  CFIndex Count;
  CFMutableDictionaryRef MutableCopy;
  const void *v22;
  _OWORD *v23;
  unint64_t i;
  uint64_t v25;
  uint64_t v26;
  __IOSurface *v27;
  __IOSurface *v28;
  double v29;
  unsigned int Width;
  unsigned int Height;
  _BOOL8 v32;
  int v34;
  NSObject *v35;
  NSObject *v36;
  __IOSurface *v37;
  NSObject *v38;
  __IOSurface *v39;
  IOSurfaceID ID;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int valuePtr;
  void *values;
  CFTypeRef cf;
  CFTypeRef v47;
  CFTypeRef v48;
  uint64_t v49;
  void *keys;
  __int128 v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v7 = (*(uint64_t (**)(CA::WindowServer::Surface *))(*(_QWORD *)a2 + 160))(a2);
  v9 = *((_QWORD *)this + 1);
  if (v9)
    v10 = v7 == 0;
  else
    v10 = 1;
  if (v10)
    return 0;
  v11 = (__IOSurface *)v7;
  v12 = a3 & 0x1000;
  v13 = (__CFDictionary *)*((_QWORD *)this + 2);
  if (BYTE6(xmmword_1ECDC6AF0))
  {
    if (x_log_hook_p())
    {
      v37 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(_QWORD *)this + 160))(this);
      IOSurfaceGetID(v37);
      x_log_();
    }
    else
    {
      v38 = x_log_category_sharedevent;
      if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEBUG))
      {
        v39 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(_QWORD *)this + 160))(this);
        ID = IOSurfaceGetID(v39);
        v41 = *((_QWORD *)this + 2);
        LODWORD(keys) = 67109376;
        HIDWORD(keys) = ID;
        LOWORD(v51) = 2048;
        *(_QWORD *)((char *)&v51 + 2) = v41;
        _os_log_impl(&dword_184457000, v38, OS_LOG_TYPE_DEBUG, "IOSurfaceID: 0x%x  clear_iosurface (DST) SharedEvent: %p", (uint8_t *)&keys, 0x12u);
      }
    }
  }
  v14 = 0;
  if (v13)
    v15 = 192;
  else
    v15 = 128;
  while (*(_DWORD *)(v9 + v14 + 336) != v15)
  {
    v14 += 16;
    if (v14 == 64)
      goto LABEL_13;
  }
  v16 = *(const __CFDictionary **)(v9 + v14 + 328);
  if (v16)
    goto LABEL_23;
LABEL_13:
  v49 = 0;
  v43 = 0;
  valuePtr = 255;
  v42 = 0;
  v17 = (void *)*MEMORY[0x1E0D3A350];
  v53 = 0;
  keys = v17;
  values = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *(_QWORD *)&v51 = *MEMORY[0x1E0D3A368];
  cf = CFNumberCreate(0, kCFNumberIntType, &v43);
  *((_QWORD *)&v51 + 1) = *MEMORY[0x1E0D3A360];
  v47 = CFNumberCreate(0, kCFNumberIntType, (char *)&v42 + 4);
  v52 = *MEMORY[0x1E0D3A358];
  v48 = CFNumberCreate(0, kCFNumberIntType, &v42);
  if (v12)
  {
    v18 = 4;
  }
  else
  {
    v53 = *MEMORY[0x1E0D3A288];
    v49 = *MEMORY[0x1E0C9AE50];
    v18 = 5;
  }
  v19 = CFDictionaryCreate(0, (const void **)&keys, (const void **)&values, v18, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v16 = v19;
  if (v13)
  {
    Count = CFDictionaryGetCount(v19);
    MutableCopy = CFDictionaryCreateMutableCopy(0, Count + 3, v16);
    CFRelease(v16);
    v16 = MutableCopy;
  }
  v22 = *(const void **)(v9 + 376);
  if (v22)
    CFRelease(v22);
  v23 = (_OWORD *)(v9 + 376);
  for (i = 4; i > 1; --i)
  {
    *v23 = *(v23 - 1);
    --v23;
  }
  *(_QWORD *)(v9 + 328) = v16;
  *(_DWORD *)(v9 + 336) = v15;
  *(_DWORD *)(v9 + 340) = 0;
  CFRelease(values);
  CFRelease(cf);
  CFRelease(v47);
  CFRelease(v48);
LABEL_23:
  v25 = CA::WindowServer::Display::copy_iosa_manager((CA::WindowServer::Display *)v9, v8);
  v26 = *(_QWORD *)(v25 + 16);
  v27 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(_QWORD *)this + 160))(this);
  if (!v26)
  {
    CA::IOSAManager::unref(v25);
    return 0;
  }
  v28 = v27;
  if (a4)
  {
    v29 = *((double *)a4 + 3);
    Width = *((double *)a4 + 2);
    Height = v29;
  }
  else
  {
    Width = IOSurfaceGetWidth(v27);
    Height = IOSurfaceGetHeight(v28);
  }
  if (IOSurfaceGetWidth(v11) < Width)
    IOSurfaceGetWidth(v11);
  if (IOSurfaceGetHeight(v11) < Height)
    IOSurfaceGetHeight(v11);
  if (v13)
    CA::WindowServer::dict_shared_event_set_value(v16, v13, 0, 0);
  v34 = IOSurfaceAcceleratorBlitSurface();
  v32 = v34 == 0;
  if (v34)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v35 = x_log_category_windowserver;
      if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
      {
        LODWORD(keys) = 67109120;
        HIDWORD(keys) = v34;
        _os_log_impl(&dword_184457000, v35, OS_LOG_TYPE_ERROR, "IOSurfaceAcceleratorBlitSurface returned: 0x%x", (uint8_t *)&keys, 8u);
      }
    }
    if (v13)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v36 = x_log_category_sharedevent;
        if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(keys) = 0;
          _os_log_impl(&dword_184457000, v36, OS_LOG_TYPE_DEFAULT, "clear_iosurface error, ensure shared event signal is complete for destination", (uint8_t *)&keys, 2u);
        }
      }
      CA::WindowServer::SharedEvent::force_complete(v13, 0);
    }
  }
  if (v25 && v34 | v12)
    CA::IOSAManager::unref(v25);
  return v32;
}

uint64_t CA::WindowServer::IOSurface::copy_iosurface(CA::WindowServer::IOSurface *this, CA::WindowServer::Surface *a2, uint64_t a3, int a4, CA::Rect *a5, CA::Rect *a6, CA::ScalerStatistics *a7, float a8)
{
  __IOSurface *v14;
  uint64_t v15;
  __IOSurface *v17;
  size_t Width;
  __CFRunLoop *v19;
  size_t Height;
  uint64_t v21;
  __int16 v22;
  __int16 v23;
  __CFDictionary *v24;
  __CFDictionary *v25;
  uint64_t v26;
  __int16 v27;
  BOOL v28;
  int v29;
  unsigned int v30;
  int v31;
  __CFDictionary *v32;
  void **v33;
  void **v34;
  void **v35;
  void *v36;
  CFNumberRef v37;
  uint64_t v38;
  void *v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  const __CFDictionary *v44;
  __CFDictionary *v45;
  const __CFDictionary *v46;
  CFIndex Count;
  CFMutableDictionaryRef MutableCopy;
  const void *v49;
  __CFDictionary *v50;
  _OWORD *v51;
  unint64_t i;
  __IOSurface *v53;
  uint64_t v54;
  _QWORD *v55;
  _QWORD *v56;
  uint64_t v57;
  const void *v58;
  const __CFArray *Value;
  __CFData *ValueAtIndex;
  CFMutableArrayRef Mutable;
  UInt8 *MutableBytePtr;
  uint64_t v63;
  __int128 v64;
  unsigned int *v65;
  unsigned int v66;
  double v67;
  double v68;
  NSObject *v69;
  uint64_t ProtectionOptions;
  uint64_t v71;
  uint64_t v72;
  double v74;
  unsigned int v75;
  uint64_t v76;
  double v77;
  double v78;
  void **v79;
  size_t v80;
  uint64_t v81;
  uint64_t v82;
  double v83;
  signed int v84;
  signed int v85;
  unint64_t v86;
  unint64_t v87;
  CA::Render *PixelFormat;
  int v89;
  double v90;
  double v91;
  double v92;
  double v93;
  int v94;
  unsigned __int16 v95;
  int v96;
  uint64_t v97;
  __int128 v98;
  __IOSurface *v99;
  size_t v100;
  size_t v101;
  unint64_t v102;
  uint64x2_t v103;
  uint64x2_t v109;
  float64x2_t v110;
  char v111;
  double v112;
  char v113;
  double v114;
  double v115;
  char v116;
  __IOSurface *v117;
  uint64_t v118;
  uint64_t v119;
  NSObject *v120;
  uint64_t v121;
  const char *v122;
  NSObject *v123;
  uint32_t v124;
  uint64_t v125;
  __CFDictionary *v126;
  NSObject *v127;
  NSObject *v128;
  char *v129;
  char *v130;
  __IOSurface *v131;
  __IOSurface *v132;
  __IOSurface *v133;
  _BOOL4 v134;
  OSType v135;
  unsigned int v136;
  int v137;
  NSObject *v138;
  __IOSurface *v139;
  IOSurfaceID ID;
  uint64_t v141;
  __IOSurface *v142;
  NSObject *v143;
  _BOOL4 v144;
  __IOSurface *v145;
  IOSurfaceID v146;
  uint64_t v147;
  OSType v148;
  unsigned int v149;
  int v150;
  const char *v151;
  OSType v152;
  unsigned int v153;
  int v154;
  uint64_t v155;
  const char *v156;
  OSType v157;
  unsigned int v158;
  uint64_t v159;
  int v160;
  unsigned int v161;
  int v162;
  unsigned int v163;
  int v164;
  unsigned int v165;
  int v166;
  OSType v167;
  unsigned int v168;
  int v169;
  unsigned int v170;
  int v171;
  unsigned int v172;
  int v173;
  unsigned int v174;
  int v175;
  unsigned int v176;
  int v177;
  unsigned int v178;
  int v179;
  unsigned int v180;
  int v181;
  OSType v182;
  unsigned int v183;
  int v184;
  unsigned int v185;
  int v186;
  unsigned int v187;
  int v188;
  unsigned int v189;
  int v190;
  int v191;
  unsigned int v192;
  int v193;
  int v194;
  unsigned int v195;
  int v196;
  int v197;
  unsigned int v198;
  int v199;
  int v200;
  OSType v201;
  unsigned int v202;
  int v203;
  int v204;
  unsigned int v205;
  int v206;
  int v207;
  unsigned int v208;
  int v209;
  int v210;
  unsigned int v211;
  int v212;
  int v213;
  IOSurfaceID v214;
  double v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  const char *CStringPtr;
  const char *v220;
  NSObject *v221;
  uint32_t v222;
  int v223;
  unsigned int v224;
  int v225;
  int v226;
  unsigned int v227;
  int v228;
  int v229;
  unsigned int v230;
  int v231;
  int v232;
  IOSurfaceID v233;
  OSType v234;
  unsigned int v235;
  int v236;
  int v237;
  unsigned int v238;
  int v239;
  int v240;
  unsigned int v241;
  int v242;
  int v243;
  unsigned int v244;
  int v245;
  int v246;
  IOSurfaceID v247;
  const char *v248;
  int v249;
  int v250;
  int v251;
  int v252;
  BOOL v253;
  int v254;
  __IOSurface *v255;
  __IOSurface *v256;
  int v257;
  int v258;
  unsigned int v259;
  double *v260;
  int v261;
  __CFDictionary *v262;
  IOSurfaceID v263;
  int v264;
  size_t v265;
  size_t v266;
  int v267;
  size_t v268;
  size_t v269;
  size_t v270;
  uint64_t v271;
  __CFDictionary *v272;
  CA::WindowServer::SharedEvent *v273;
  CA::WindowServer::SharedEvent *v274;
  __CFDictionary *theDict;
  CFDictionaryRef theDicta;
  CFDictionaryRef theDictb;
  int v278;
  float64x2_t v279;
  int v280;
  CFStringRef theStringa[2];
  const __CFString *theStringb;
  uint64_t v284;
  _QWORD *v285;
  int valuePtr;
  int v287;
  __int128 v288;
  __int128 v289;
  _QWORD keys[8];
  IOSurfaceID v291;
  __int16 v292;
  int v293;
  __int16 v294;
  int v295;
  __int16 v296;
  int v297;
  __int16 v298;
  int v299;
  __int16 v300;
  double v301;
  __int16 v302;
  double v303;
  __int16 v304;
  IOSurfaceID v305;
  __int16 v306;
  _BYTE v307[18];
  __int16 v308;
  uint64_t v309;
  __int16 v310;
  uint64_t v311;
  __int16 v312;
  int v313;
  __int16 v314;
  const char *v315;
  void *values[2];
  __int128 v317;
  __int128 v318;
  __int128 v319;
  uint64_t v320;

  v320 = *MEMORY[0x1E0C80C00];
  v287 = a4;
  v14 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::Surface *, float))(*(_QWORD *)a2 + 160))(a2, a8);
  v15 = *((_QWORD *)this + 1);
  if (v15)
    _ZF = v14 == 0;
  else
    _ZF = 1;
  if (_ZF)
    return 0;
  v17 = v14;
  Width = IOSurfaceGetWidth(v14);
  Height = IOSurfaceGetHeight(v17);
  if ((a3 & 0x100) == 0
    && !(*(unsigned int (**)(uint64_t, size_t, size_t, _QWORD, _QWORD))(*(_QWORD *)v15 + 144))(v15, Width, Height, *((unsigned int *)this + 14), *((unsigned int *)this + 15)))
  {
    return 0;
  }
  if (a4 && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 160))(v15) & 1) == 0)
    v287 = 0;
  v21 = CA::WindowServer::Display::copy_iosa_manager((CA::WindowServer::Display *)v15, v19);
  if (!*(_QWORD *)(v21 + 16))
  {
LABEL_71:
    CA::IOSAManager::unref(v21);
    return 0;
  }
  v265 = Height;
  v268 = Width;
  v260 = (double *)a6;
  v22 = a3 & 7;
  valuePtr = a3 & 7;
  if ((a3 & 0x200) != 0)
    v22 = a3 & 7 | 8;
  if ((a3 & 0x2000) != 0)
    v23 = v22 | 0x10;
  else
    v23 = v22;
  v278 = a3 & 0x2000;
  v24 = (__CFDictionary *)*((_QWORD *)a2 + 2);
  v25 = (__CFDictionary *)*((_QWORD *)this + 2);
  v271 = a3;
  v272 = v25;
  v262 = v24;
  if (BYTE6(xmmword_1ECDC6AF0))
  {
    if (x_log_hook_p())
    {
      v131 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::Surface *))(*(_QWORD *)a2 + 160))(a2);
      IOSurfaceGetID(v131);
      x_log_();
    }
    else
    {
      v138 = x_log_category_sharedevent;
      if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEBUG))
      {
        v139 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::Surface *))(*(_QWORD *)a2 + 160))(a2);
        ID = IOSurfaceGetID(v139);
        v141 = *((_QWORD *)a2 + 2);
        LODWORD(keys[0]) = 67109376;
        HIDWORD(keys[0]) = ID;
        LOWORD(keys[1]) = 2048;
        *(_QWORD *)((char *)&keys[1] + 2) = v141;
        _os_log_impl(&dword_184457000, v138, OS_LOG_TYPE_DEBUG, "IOSurfaceID: 0x%x  copy_iosurface (SRC) SharedEvent: %p", (uint8_t *)keys, 0x12u);
      }
    }
    if (x_log_hook_p())
    {
      v142 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(_QWORD *)this + 160))(this);
      IOSurfaceGetID(v142);
      x_log_();
      v25 = v272;
      v24 = v262;
    }
    else
    {
      v143 = x_log_category_sharedevent;
      v144 = os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEBUG);
      v25 = v272;
      v24 = v262;
      if (v144)
      {
        v145 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(_QWORD *)this + 160))(this);
        v146 = IOSurfaceGetID(v145);
        v147 = *((_QWORD *)this + 2);
        LODWORD(keys[0]) = 67109376;
        HIDWORD(keys[0]) = v146;
        LOWORD(keys[1]) = 2048;
        *(_QWORD *)((char *)&keys[1] + 2) = v147;
        _os_log_impl(&dword_184457000, v143, OS_LOG_TYPE_DEBUG, "IOSurfaceID: 0x%x  copy_iosurface (DST) SharedEvent: %p", (uint8_t *)keys, 0x12u);
        v24 = v262;
        v25 = v272;
      }
    }
  }
  v26 = 0;
  v27 = v23 | 0x20;
  v28 = v24 == 0;
  if (!v24)
    v27 = v23;
  v29 = ((unsigned __int16)(a3 & 0x2000) >> 13) + 3;
  if (v28)
    v29 = (unsigned __int16)(a3 & 0x2000) >> 13;
  if (v25)
  {
    v27 |= 0x40u;
    v30 = v29 + 3;
  }
  else
  {
    v30 = v29;
  }
  v31 = (unsigned __int16)(v27 | ((_WORD)v287 << 8));
  while (*(_DWORD *)(v15 + v26 + 336) != v31)
  {
    v26 += 16;
    if (v26 == 64)
    {
      v32 = 0;
      goto LABEL_29;
    }
  }
  v32 = *(__CFDictionary **)(v15 + v26 + 328);
LABEL_29:
  v33 = (void **)MEMORY[0x1E0C9AE50];
  v34 = (void **)MEMORY[0x1E0C9AE40];
  if ((_BYTE)dword_1ECDC6B10)
    v35 = (void **)MEMORY[0x1E0C9AE40];
  else
    v35 = (void **)MEMORY[0x1E0C9AE50];
  theDict = v32;
  if (!v32)
  {
    v255 = v17;
    v36 = *v35;
    memset(&keys[1], 0, 56);
    v318 = 0u;
    v319 = 0u;
    *(_OWORD *)values = 0u;
    v317 = 0u;
    keys[0] = *MEMORY[0x1E0D3A330];
    v37 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    v38 = *MEMORY[0x1E0D3A348];
    v39 = *v33;
    v40 = *v34;
    if ((v271 & 0x200) != 0)
      v40 = v39;
    values[0] = v37;
    values[1] = v40;
    v41 = *MEMORY[0x1E0D3A208];
    keys[1] = v38;
    keys[2] = v41;
    *(_QWORD *)&v317 = CFNumberCreate(0, kCFNumberIntType, &v287);
    if (v278)
    {
      v42 = *MEMORY[0x1E0D3A290];
      keys[3] = *MEMORY[0x1E0D3A238];
      keys[4] = v42;
      *((_QWORD *)&v317 + 1) = v39;
      *(_QWORD *)&v318 = v39;
      keys[5] = *MEMORY[0x1E0D3A220];
      *((_QWORD *)&v318 + 1) = v39;
      v43 = 6;
    }
    else
    {
      v43 = 3;
    }
    keys[v43] = *MEMORY[0x1E0D3A218];
    values[v43] = v36;
    v44 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, (v43 + 1), MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v45 = v44;
    if (v30)
    {
      v46 = v44;
      Count = CFDictionaryGetCount(v44);
      MutableCopy = CFDictionaryCreateMutableCopy(0, Count + v30, v46);
      CFRelease(v46);
      v45 = MutableCopy;
    }
    v17 = v255;
    v49 = *(const void **)(v15 + 376);
    if (v49)
    {
      v50 = v45;
      CFRelease(v49);
      v45 = v50;
    }
    v51 = (_OWORD *)(v15 + 376);
    for (i = 4; i > 1; --i)
    {
      *v51 = *(v51 - 1);
      --v51;
    }
    theDict = v45;
    *(_QWORD *)(v15 + 328) = v45;
    *(_DWORD *)(v15 + 336) = v31;
    *(_DWORD *)(v15 + 340) = 0;
    CFRelease(values[0]);
    CFRelease((CFTypeRef)v317);
  }
  v53 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(_QWORD *)this + 160))(this);
  v54 = v271;
  v253 = (v271 & 0x1000) == 0;
  if (initialized[0] != -1)
    dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
  if (*(float *)&dword_1ECDC6938)
    v253 = 0;
  v284 = v21;
  v285 = 0;
  v259 = *(float *)&dword_1ECDC6938;
  if (!v278 || !a7)
  {
    if (!v278)
      goto LABEL_60;
    goto LABEL_55;
  }
  v55 = (_QWORD *)(*(uint64_t (**)(CA::ScalerStatistics *, __IOSurface *, __IOSurface *))(*(_QWORD *)a7 + 16))(a7, v17, v53);
  if (!v55)
  {
LABEL_55:
    CFDictionaryRemoveValue(theDict, (const void *)*MEMORY[0x1E0D3A210]);
    goto LABEL_60;
  }
  v56 = v55;
  v256 = v17;
  v57 = *v55;
  v58 = (const void *)*MEMORY[0x1E0D3A210];
  Value = (const __CFArray *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E0D3A210]);
  if (Value)
  {
    ValueAtIndex = (__CFData *)CFArrayGetValueAtIndex(Value, 0);
  }
  else
  {
    Mutable = CFArrayCreateMutable(0, 1, MEMORY[0x1E0C9B378]);
    CFDictionarySetValue(theDict, v58, Mutable);
    CFRelease(Mutable);
    ValueAtIndex = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 40);
    CFDataSetLength(ValueAtIndex, 40);
    CFArraySetValueAtIndex(Mutable, 0, ValueAtIndex);
    CFRelease(ValueAtIndex);
  }
  MutableBytePtr = CFDataGetMutableBytePtr(ValueAtIndex);
  v63 = *(_QWORD *)(v57 + 32);
  v64 = *(_OWORD *)(v57 + 16);
  *(_OWORD *)MutableBytePtr = *(_OWORD *)v57;
  *((_OWORD *)MutableBytePtr + 1) = v64;
  *((_QWORD *)MutableBytePtr + 4) = v63;
  v65 = (unsigned int *)((char *)a7 + 8);
  do
    v66 = __ldaxr(v65);
  while (__stlxr(v66 + 1, v65));
  v56[1] = a7;
  v285 = v56;
  v17 = v256;
  v54 = v271;
LABEL_60:
  IOSurfaceGetProtectionOptions();
  if ((IOSurfaceSupportsProtectionOptions() & 1) == 0)
  {
    if (x_log_hook_p())
    {
      IOSurfaceGetProtectionOptions();
      IOSurfaceGetProtectionOptions();
      x_log_();
    }
    else
    {
      v69 = x_log_category_windowserver;
      if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
      {
        ProtectionOptions = IOSurfaceGetProtectionOptions();
        v71 = IOSurfaceGetProtectionOptions();
        LODWORD(keys[0]) = 134218240;
        *(_QWORD *)((char *)keys + 4) = ProtectionOptions;
        WORD2(keys[1]) = 2048;
        *(_QWORD *)((char *)&keys[1] + 6) = v71;
        _os_log_impl(&dword_184457000, v69, OS_LOG_TYPE_ERROR, "protection mismatch src: 0x%llx  dst: 0x%llx", (uint8_t *)keys, 0x16u);
      }
    }
    goto LABEL_71;
  }
  if (v262)
    CA::WindowServer::dict_shared_event_set_value(theDict, v262, (CA::WindowServer::SharedEvent *)1, 1);
  if (v272)
    CA::WindowServer::dict_shared_event_set_value(theDict, v272, (CA::WindowServer::SharedEvent *)1, 0);
  v317 = 0u;
  v318 = 0u;
  *(_OWORD *)values = 0u;
  if (a5)
  {
    v67 = *((double *)a5 + 2);
    v68 = *((double *)a5 + 3);
  }
  else
  {
    v67 = (double)IOSurfaceGetWidth(v53);
    v68 = (double)IOSurfaceGetHeight(v53);
  }
  v74 = v67 * (4095.0 * v68) / (float)(*(_DWORD *)(v15 + 180) * *(_DWORD *)(v15 + 176));
  v75 = (int)(trunc(v74) * 0.25);
  if (v278)
    v76 = (int)v74;
  else
    v76 = v75;
  (*(void (**)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t))(*(_QWORD *)v15 + 384))(v15, 0, 0, v76, 4);
  if ((unint64_t)a5 | (unint64_t)v260)
  {
    if (v260)
    {
      v265 = (unint64_t)v260[3];
      v268 = (unint64_t)v260[2];
      v77 = *v260;
      v78 = v260[1];
    }
    else
    {
      v268 = IOSurfaceGetWidth(v17);
      v265 = IOSurfaceGetHeight(v17);
      v77 = 0.0;
      v78 = 0.0;
    }
    PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(v17);
    if ((int)PixelFormat > 645410930)
    {
      if ((_DWORD)PixelFormat == 645410931 || (_DWORD)PixelFormat == 645411443)
        goto LABEL_95;
      v89 = 645411955;
    }
    else
    {
      if ((_DWORD)PixelFormat == 645148787 || (_DWORD)PixelFormat == 645149299)
        goto LABEL_95;
      v89 = 645149811;
    }
    if ((_DWORD)PixelFormat == v89)
      goto LABEL_95;
    v94 = CA::Render::fourcc_compressed_of_type(PixelFormat, 0, 0);
    v90 = 0.0;
    if (v94 > 1885746227)
    {
      if ((v94 - 1886676528) <= 4 && ((1 << (v94 - 48)) & 0x15) != 0
        || (v94 - 1886680624) <= 4 && ((1 << (v94 - 48)) & 0x15) != 0)
      {
        goto LABEL_95;
      }
      v95 = 13364;
    }
    else
    {
      if (v94 <= 1882469427)
      {
        if (v94 == 1882468912)
          goto LABEL_95;
        v96 = 1882468914;
        goto LABEL_111;
      }
      if (v94 == 1882469428 || v94 == 1885745712)
        goto LABEL_95;
      v95 = 12850;
    }
    v96 = v95 | 0x70660000;
LABEL_111:
    if (v94 != v96)
    {
      v91 = 0.0;
      if (a5)
        goto LABEL_96;
      goto LABEL_113;
    }
LABEL_95:
    v90 = (double)((int)v77 % 6);
    v91 = (double)((int)v78 % 6);
    v77 = v77 - v90;
    v78 = v78 - v91;
    v265 = ((unint64_t)(v91 + (double)v265) + 1) & 0xFFFFFFFFFFFFFFFELL;
    v268 = ((unint64_t)((double)v268 + v90) + 1) & 0xFFFFFFFFFFFFFFFELL;
    if (a5)
    {
LABEL_96:
      v92 = *(double *)a5 - v90;
      v93 = *((double *)a5 + 1) - v91;
LABEL_114:
      LODWORD(v86) = v92;
      LODWORD(v87) = v93;
      v84 = v67;
      v85 = v68;
      values[0] = (void *)vcvtd_n_u64_f64(v77, 0x10uLL);
      values[1] = (void *)vcvtd_n_u64_f64(v78, 0x10uLL);
      *(_QWORD *)&v317 = v268 << 16;
      goto LABEL_115;
    }
LABEL_113:
    v92 = -v90;
    v93 = -v91;
    goto LABEL_114;
  }
  if ((v54 & 0x8000) == 0)
  {
    v79 = 0;
    v80 = v265;
    goto LABEL_116;
  }
  v81 = *((unsigned int *)this + 14);
  v82 = *((unsigned int *)this + 15);
  v83 = (double)v81 / (double)v268;
  if (v83 >= (double)v82 / (double)v265)
    v83 = (double)v82 / (double)v265;
  v84 = vcvtmd_s64_f64(v83 * (double)v268 + 0.5);
  v85 = vcvtmd_s64_f64(v83 * (double)v265 + 0.5);
  v86 = (unint64_t)(v81 - v84) >> 1;
  v87 = (unint64_t)(v82 - v85) >> 1;
  values[0] = 0;
  values[1] = 0;
  *(_QWORD *)&v317 = v268 << 16;
LABEL_115:
  v80 = v265;
  *((_QWORD *)&v317 + 1) = v265 << 16;
  *(_QWORD *)&v318 = __PAIR64__(v87, v86);
  v79 = values;
  *((_QWORD *)&v318 + 1) = __PAIR64__(v85, v84);
LABEL_116:
  v97 = 3758097090;
  if (!(*(unsigned int (**)(uint64_t, size_t, size_t, unint64_t, unint64_t, BOOL, _QWORD))(*(_QWORD *)v15 + 152))(v15, v268, v80, (unint64_t)v67, (unint64_t)v68, v278 != 0, (v54 >> 2) & 1))
  {
LABEL_163:
    v126 = v272;
    if (v262)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v127 = x_log_category_sharedevent;
        if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(keys[0]) = 0;
          _os_log_impl(&dword_184457000, v127, OS_LOG_TYPE_DEFAULT, "copy_iosurface error, ensure shared event signal is complete for source", (uint8_t *)keys, 2u);
        }
      }
      CA::WindowServer::SharedEvent::force_complete(v262, 0);
      v126 = v272;
    }
    if (v126)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v128 = x_log_category_sharedevent;
        if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(keys[0]) = 0;
          _os_log_impl(&dword_184457000, v128, OS_LOG_TYPE_DEFAULT, "copy_iosurface error, ensure shared event signal is complete for destination", (uint8_t *)keys, 2u);
        }
      }
      CA::WindowServer::SharedEvent::force_complete(v272, 0);
    }
    v72 = 0;
    goto LABEL_176;
  }
  if ((v54 & 0x10000) == 0 || !v79)
    goto LABEL_135;
  v98 = v318;
  v99 = (__IOSurface *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(_QWORD *)this + 160))(this);
  v100 = IOSurfaceGetWidth(v99);
  v101 = IOSurfaceGetHeight(v99);
  v102 = v101;
  if (v101 * v100 < 0x7A120)
    goto LABEL_129;
  v103.i64[0] = DWORD2(v98);
  v103.i64[1] = HIDWORD(v98);
  _Q2 = vcvtq_f64_u64(v103);
  __asm { FMLS            D0, D2, V2.D[1] }
  if ((double)(v101 * v100) * 0.85 < trunc(_D0))
  {
LABEL_129:
    if (((*(uint64_t (**)(CA::WindowServer::IOSurface *, CA::WindowServer::Surface *, uint64_t, _QWORD))(*(_QWORD *)this + 168))(this, a2, v54, 0) & 1) != 0)goto LABEL_135;
    if (x_log_hook_p())
    {
      x_log_();
LABEL_162:
      v97 = 3758097090;
      goto LABEL_163;
    }
    v117 = v17;
    v121 = x_log_category_windowserver;
    if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
    {
      LODWORD(keys[0]) = 134218240;
      *(_QWORD *)((char *)keys + 4) = v100;
      WORD2(keys[1]) = 2048;
      *(_QWORD *)((char *)&keys[1] + 6) = v102;
      v122 = "Full clear failed IOSurface: %zux%zu";
      v123 = v121;
      v124 = 22;
LABEL_160:
      _os_log_impl(&dword_184457000, v123, OS_LOG_TYPE_ERROR, v122, (uint8_t *)keys, v124);
      goto LABEL_161;
    }
    goto LABEL_161;
  }
  v109.i64[0] = v98;
  v109.i64[1] = DWORD1(v98);
  v110 = vcvtq_f64_u64(v109);
  v288 = 0u;
  v289 = 0u;
  v279 = v110;
  *(float64x2_t *)theStringa = _Q2;
  if (v110.f64[0] > 0.0)
  {
    v288 = 0uLL;
    *(float64_t *)&v289 = v110.f64[0];
    *((double *)&v289 + 1) = (double)v101;
    v111 = (*(uint64_t (**)(CA::WindowServer::IOSurface *, CA::WindowServer::Surface *, uint64_t, __int128 *))(*(_QWORD *)this + 168))(this, a2, v54, &v288);
    v110 = v279;
    _Q2 = *(float64x2_t *)theStringa;
    if ((v111 & 1) == 0)
    {
      v117 = v17;
      if (x_log_hook_p())
        goto LABEL_152;
      v125 = x_log_category_windowserver;
      if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
      {
        LODWORD(keys[0]) = 134219264;
        *(_QWORD *)((char *)keys + 4) = v288;
        WORD2(keys[1]) = 2048;
        *(_QWORD *)((char *)&keys[1] + 6) = *((_QWORD *)&v288 + 1);
        HIWORD(keys[2]) = 2048;
        keys[3] = v289;
        LOWORD(keys[4]) = 2048;
        *(_QWORD *)((char *)&keys[4] + 2) = *((_QWORD *)&v289 + 1);
        WORD1(keys[5]) = 2048;
        *(_QWORD *)((char *)&keys[5] + 4) = v100;
        WORD2(keys[6]) = 2048;
        *(_QWORD *)((char *)&keys[6] + 6) = v102;
        v122 = "Left clear failed %f,%f %fx%f  IOSurface: %zux%zu";
LABEL_159:
        v123 = v125;
        v124 = 62;
        goto LABEL_160;
      }
LABEL_161:
      v17 = v117;
      goto LABEL_162;
    }
  }
  v112 = v110.f64[1];
  if (v110.f64[1] > 0.0)
  {
    v288 = *(unint64_t *)&v110.f64[0];
    *(float64_t *)&v289 = _Q2.f64[0];
    *((_QWORD *)&v289 + 1) = *(_QWORD *)&v110.f64[1];
    v113 = (*(uint64_t (**)(CA::WindowServer::IOSurface *, CA::WindowServer::Surface *, uint64_t, __int128 *))(*(_QWORD *)this + 168))(this, a2, v54, &v288);
    v110 = v279;
    _Q2 = *(float64x2_t *)theStringa;
    if ((v113 & 1) == 0)
    {
      v117 = v17;
      if (x_log_hook_p())
        goto LABEL_152;
      v125 = x_log_category_windowserver;
      if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
        goto LABEL_161;
      LODWORD(keys[0]) = 134219264;
      *(_QWORD *)((char *)keys + 4) = v288;
      WORD2(keys[1]) = 2048;
      *(_QWORD *)((char *)&keys[1] + 6) = *((_QWORD *)&v288 + 1);
      HIWORD(keys[2]) = 2048;
      keys[3] = v289;
      LOWORD(keys[4]) = 2048;
      *(_QWORD *)((char *)&keys[4] + 2) = *((_QWORD *)&v289 + 1);
      WORD1(keys[5]) = 2048;
      *(_QWORD *)((char *)&keys[5] + 4) = v100;
      WORD2(keys[6]) = 2048;
      *(_QWORD *)((char *)&keys[6] + 6) = v102;
      v122 = "Top clear failed %f,%f %fx%f  IOSurface: %zux%zu";
      goto LABEL_159;
    }
  }
  v114 = vaddq_f64(_Q2, v110).f64[0];
  if (v114 >= (double)v100)
  {
    v115 = (double)v102;
  }
  else
  {
    v288 = *(unint64_t *)&v114;
    v115 = (double)v102;
    *(double *)&v289 = (double)v100 - v114;
    *((double *)&v289 + 1) = (double)v102;
    v116 = (*(uint64_t (**)(CA::WindowServer::IOSurface *, CA::WindowServer::Surface *, uint64_t, __int128 *))(*(_QWORD *)this + 168))(this, a2, v54, &v288);
    v110.f64[0] = v279.f64[0];
    _Q2 = *(float64x2_t *)theStringa;
    if ((v116 & 1) == 0)
    {
      v117 = v17;
      if (x_log_hook_p())
        goto LABEL_152;
      v125 = x_log_category_windowserver;
      if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
        goto LABEL_161;
      LODWORD(keys[0]) = 134219264;
      *(_QWORD *)((char *)keys + 4) = v288;
      WORD2(keys[1]) = 2048;
      *(_QWORD *)((char *)&keys[1] + 6) = *((_QWORD *)&v288 + 1);
      HIWORD(keys[2]) = 2048;
      keys[3] = v289;
      LOWORD(keys[4]) = 2048;
      *(_QWORD *)((char *)&keys[4] + 2) = *((_QWORD *)&v289 + 1);
      WORD1(keys[5]) = 2048;
      *(_QWORD *)((char *)&keys[5] + 4) = v100;
      WORD2(keys[6]) = 2048;
      *(_QWORD *)((char *)&keys[6] + 6) = v102;
      v122 = "Right clear failed %f,%f %fx%f  IOSurface: %zux%zu";
      goto LABEL_159;
    }
  }
  if (_Q2.f64[1] + v112 < v115)
  {
    *(float64_t *)&v288 = v110.f64[0];
    *((double *)&v288 + 1) = _Q2.f64[1] + v112;
    *(float64_t *)&v289 = _Q2.f64[0];
    *((double *)&v289 + 1) = v115 - (_Q2.f64[1] + v112);
    if (((*(uint64_t (**)(CA::WindowServer::IOSurface *, CA::WindowServer::Surface *, uint64_t, __int128 *))(*(_QWORD *)this + 168))(this, a2, v54, &v288) & 1) == 0)
    {
      v117 = v17;
      if (x_log_hook_p())
      {
LABEL_152:
        x_log_();
        goto LABEL_161;
      }
      v125 = x_log_category_windowserver;
      if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
        goto LABEL_161;
      LODWORD(keys[0]) = 134219264;
      *(_QWORD *)((char *)keys + 4) = v288;
      WORD2(keys[1]) = 2048;
      *(_QWORD *)((char *)&keys[1] + 6) = *((_QWORD *)&v288 + 1);
      HIWORD(keys[2]) = 2048;
      keys[3] = v289;
      LOWORD(keys[4]) = 2048;
      *(_QWORD *)((char *)&keys[4] + 2) = *((_QWORD *)&v289 + 1);
      WORD1(keys[5]) = 2048;
      *(_QWORD *)((char *)&keys[5] + 4) = v100;
      WORD2(keys[6]) = 2048;
      *(_QWORD *)((char *)&keys[6] + 6) = v102;
      v122 = "Bottom clear failed %f,%f %fx%f  IOSurface: %zux%zud";
      goto LABEL_159;
    }
  }
LABEL_135:
  v97 = IOSurfaceAcceleratorTransformSurface();
  if ((_DWORD)v97)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v118 = v97;
      v119 = x_log_category_windowserver;
      if (os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_ERROR))
      {
        LODWORD(keys[0]) = 67109120;
        HIDWORD(keys[0]) = v118;
        v120 = v119;
        v97 = v118;
        _os_log_impl(&dword_184457000, v120, OS_LOG_TYPE_ERROR, "IOSurfaceAcceleratorTransformSurface returned: 0x%x", (uint8_t *)keys, 8u);
      }
      else
      {
        v97 = v118;
      }
    }
    goto LABEL_163;
  }
  v72 = 1;
  if (!v253)
LABEL_176:
    ((void (*)(uint64_t, uint64_t, _QWORD *))CA::WindowServer::msr_transfer_complete)(v284, v97, v285);
  if (byte_1ECDC6AAD)
  {
    v280 = v97;
    v132 = v53;
    v133 = v17;
    theStringb = CFCopyDescription(theDict);
    v134 = x_log_hook_p();
    if (v260)
    {
      if (v134)
      {
        v135 = IOSurfaceGetPixelFormat(v17);
        v136 = HIBYTE(v135);
        if ((v135 & 0x80000000) != 0)
          v137 = __maskrune(v136, 0x40000uLL);
        else
          v137 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v136 + 60) & 0x40000;
        if (v137)
          IOSurfaceGetPixelFormat(v17);
        v161 = (IOSurfaceGetPixelFormat(v17) >> 16);
        if (v161 <= 0x7F)
          v162 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v161 + 60) & 0x40000;
        else
          v162 = __maskrune(v161, 0x40000uLL);
        if (v162)
          IOSurfaceGetPixelFormat(v17);
        v163 = ((unsigned __int16)IOSurfaceGetPixelFormat(v17) >> 8);
        if (v163 <= 0x7F)
          v164 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v163 + 60) & 0x40000;
        else
          v164 = __maskrune(v163, 0x40000uLL);
        if (v164)
          IOSurfaceGetPixelFormat(v17);
        v165 = IOSurfaceGetPixelFormat(v17);
        if (v165 <= 0x7F)
          v166 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v165 + 60) & 0x40000;
        else
          v166 = __maskrune(v165, 0x40000uLL);
        if (v166)
          IOSurfaceGetPixelFormat(v17);
        IOSurfaceGetWidth(v17);
        IOSurfaceGetHeight(v17);
        IOSurfaceGetID(v17);
        v167 = IOSurfaceGetPixelFormat(v53);
        v168 = HIBYTE(v167);
        if ((v167 & 0x80000000) != 0)
          v169 = __maskrune(v168, 0x40000uLL);
        else
          v169 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v168 + 60) & 0x40000;
        if (v169)
          IOSurfaceGetPixelFormat(v53);
        v170 = (IOSurfaceGetPixelFormat(v53) >> 16);
        if (v170 <= 0x7F)
          v171 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v170 + 60) & 0x40000;
        else
          v171 = __maskrune(v170, 0x40000uLL);
        if (v171)
          IOSurfaceGetPixelFormat(v53);
        v172 = ((unsigned __int16)IOSurfaceGetPixelFormat(v53) >> 8);
        if (v172 <= 0x7F)
          v173 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v172 + 60) & 0x40000;
        else
          v173 = __maskrune(v172, 0x40000uLL);
        if (v173)
          IOSurfaceGetPixelFormat(v53);
        v174 = IOSurfaceGetPixelFormat(v53);
        if (v174 <= 0x7F)
          v175 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v174 + 60) & 0x40000;
        else
          v175 = __maskrune(v174, 0x40000uLL);
        if (!v175)
          goto LABEL_284;
        goto LABEL_283;
      }
      theDicta = (CFDictionaryRef)x_log_category_windowserver;
      if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT))
        goto LABEL_380;
      v151 = "failed with";
      if ((_DWORD)v72)
        v151 = "copied";
      v273 = (CA::WindowServer::SharedEvent *)v151;
      v152 = IOSurfaceGetPixelFormat(v17);
      v153 = HIBYTE(v152);
      if ((v152 & 0x80000000) != 0)
        v154 = __maskrune(v153, 0x40000uLL);
      else
        v154 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v153 + 60) & 0x40000;
      if (v154)
        v191 = (int)IOSurfaceGetPixelFormat(v17) >> 24;
      else
        v191 = 32;
      v257 = v191;
      v192 = (IOSurfaceGetPixelFormat(v17) >> 16);
      if (v192 <= 0x7F)
        v193 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v192 + 60) & 0x40000;
      else
        v193 = __maskrune(v192, 0x40000uLL);
      if (v193)
        v194 = (int)(IOSurfaceGetPixelFormat(v17) << 8) >> 24;
      else
        v194 = 32;
      v254 = v194;
      v195 = ((unsigned __int16)IOSurfaceGetPixelFormat(v17) >> 8);
      if (v195 <= 0x7F)
        v196 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v195 + 60) & 0x40000;
      else
        v196 = __maskrune(v195, 0x40000uLL);
      if (v196)
        v197 = (__int16)IOSurfaceGetPixelFormat(v17) >> 8;
      else
        v197 = 32;
      v252 = v197;
      v198 = IOSurfaceGetPixelFormat(v17);
      if (v198 <= 0x7F)
        v199 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v198 + 60) & 0x40000;
      else
        v199 = __maskrune(v198, 0x40000uLL);
      if (v199)
        v200 = (char)IOSurfaceGetPixelFormat(v17);
      else
        v200 = 32;
      v251 = v200;
      v269 = IOSurfaceGetWidth(v17);
      v266 = IOSurfaceGetHeight(v17);
      v263 = IOSurfaceGetID(v17);
      v201 = IOSurfaceGetPixelFormat(v53);
      v202 = HIBYTE(v201);
      if ((v201 & 0x80000000) != 0)
        v203 = __maskrune(v202, 0x40000uLL);
      else
        v203 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v202 + 60) & 0x40000;
      if (v203)
        v204 = (int)IOSurfaceGetPixelFormat(v53) >> 24;
      else
        v204 = 32;
      v250 = v204;
      v205 = (IOSurfaceGetPixelFormat(v53) >> 16);
      if (v205 <= 0x7F)
        v206 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v205 + 60) & 0x40000;
      else
        v206 = __maskrune(v205, 0x40000uLL);
      if (v206)
        v207 = (int)(IOSurfaceGetPixelFormat(v53) << 8) >> 24;
      else
        v207 = 32;
      v249 = v207;
      v208 = ((unsigned __int16)IOSurfaceGetPixelFormat(v53) >> 8);
      if (v208 <= 0x7F)
        v209 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v208 + 60) & 0x40000;
      else
        v209 = __maskrune(v208, 0x40000uLL);
      if (v209)
        v210 = (__int16)IOSurfaceGetPixelFormat(v53) >> 8;
      else
        v210 = 32;
      v211 = IOSurfaceGetPixelFormat(v53);
      if (v211 <= 0x7F)
        v212 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v211 + 60) & 0x40000;
      else
        v212 = __maskrune(v211, 0x40000uLL);
      if (v212)
        v213 = (char)IOSurfaceGetPixelFormat(v53);
      else
        v213 = 32;
      v214 = IOSurfaceGetID(v132);
      v215 = *v260;
      v216 = *((_QWORD *)v260 + 1);
      v217 = *((_QWORD *)v260 + 2);
      v218 = *((_QWORD *)v260 + 3);
      CStringPtr = CFStringGetCStringPtr(theStringb, 0x8000100u);
      LODWORD(keys[0]) = 136320514;
      *(_QWORD *)((char *)keys + 4) = v273;
      WORD2(keys[1]) = 1024;
      *(_DWORD *)((char *)&keys[1] + 6) = v280;
      WORD1(keys[2]) = 1024;
      HIDWORD(keys[2]) = v257;
      LOWORD(keys[3]) = 1024;
      *(_DWORD *)((char *)&keys[3] + 2) = v254;
      HIWORD(keys[3]) = 1024;
      LODWORD(keys[4]) = v252;
      WORD2(keys[4]) = 1024;
      *(_DWORD *)((char *)&keys[4] + 6) = v251;
      WORD1(keys[5]) = 2048;
      *(_QWORD *)((char *)&keys[5] + 4) = v269;
      WORD2(keys[6]) = 2048;
      *(_QWORD *)((char *)&keys[6] + 6) = v266;
      HIWORD(keys[7]) = 1024;
      v291 = v263;
      v292 = 1024;
      v293 = v250;
      v294 = 1024;
      v295 = v249;
      v296 = 1024;
      v297 = v210;
      v298 = 1024;
      v299 = v213;
      v300 = 2048;
      v301 = v67;
      v302 = 2048;
      v303 = v68;
      v304 = 1024;
      v305 = v214;
      v306 = 2048;
      *(double *)v307 = v215;
      *(_WORD *)&v307[8] = 2048;
      *(_QWORD *)&v307[10] = v216;
      v308 = 2048;
      v309 = v217;
      v310 = 2048;
      v311 = v218;
      v312 = 1024;
      v313 = v271;
      v314 = 2080;
      v315 = CStringPtr;
      v220 = "%s 0x%x src: %c%c%c%c [%zu x %zu] 0x%x dst: %c%c%c%c [%f x %f] 0x%x, subrect: (%f, %f, %f, %f), copy_flags: 0x%x, dict %s";
      v221 = theDicta;
      v222 = 174;
    }
    else
    {
      if (v134)
      {
        v148 = IOSurfaceGetPixelFormat(v17);
        v149 = HIBYTE(v148);
        if ((v148 & 0x80000000) != 0)
          v150 = __maskrune(v149, 0x40000uLL);
        else
          v150 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v149 + 60) & 0x40000;
        if (v150)
          IOSurfaceGetPixelFormat(v17);
        v176 = (IOSurfaceGetPixelFormat(v17) >> 16);
        if (v176 <= 0x7F)
          v177 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v176 + 60) & 0x40000;
        else
          v177 = __maskrune(v176, 0x40000uLL);
        if (v177)
          IOSurfaceGetPixelFormat(v17);
        v178 = ((unsigned __int16)IOSurfaceGetPixelFormat(v17) >> 8);
        if (v178 <= 0x7F)
          v179 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v178 + 60) & 0x40000;
        else
          v179 = __maskrune(v178, 0x40000uLL);
        if (v179)
          IOSurfaceGetPixelFormat(v17);
        v180 = IOSurfaceGetPixelFormat(v17);
        if (v180 <= 0x7F)
          v181 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v180 + 60) & 0x40000;
        else
          v181 = __maskrune(v180, 0x40000uLL);
        if (v181)
          IOSurfaceGetPixelFormat(v17);
        IOSurfaceGetWidth(v17);
        IOSurfaceGetHeight(v17);
        IOSurfaceGetID(v17);
        v182 = IOSurfaceGetPixelFormat(v53);
        v183 = HIBYTE(v182);
        if ((v182 & 0x80000000) != 0)
          v184 = __maskrune(v183, 0x40000uLL);
        else
          v184 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v183 + 60) & 0x40000;
        if (v184)
          IOSurfaceGetPixelFormat(v53);
        v185 = (IOSurfaceGetPixelFormat(v53) >> 16);
        if (v185 <= 0x7F)
          v186 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v185 + 60) & 0x40000;
        else
          v186 = __maskrune(v185, 0x40000uLL);
        if (v186)
          IOSurfaceGetPixelFormat(v53);
        v187 = ((unsigned __int16)IOSurfaceGetPixelFormat(v53) >> 8);
        if (v187 <= 0x7F)
          v188 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v187 + 60) & 0x40000;
        else
          v188 = __maskrune(v187, 0x40000uLL);
        if (v188)
          IOSurfaceGetPixelFormat(v53);
        v189 = IOSurfaceGetPixelFormat(v53);
        if (v189 <= 0x7F)
          v190 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v189 + 60) & 0x40000;
        else
          v190 = __maskrune(v189, 0x40000uLL);
        if (!v190)
          goto LABEL_284;
LABEL_283:
        IOSurfaceGetPixelFormat(v53);
LABEL_284:
        IOSurfaceGetID(v53);
        CFStringGetCStringPtr(theStringb, 0x8000100u);
        x_log_();
        goto LABEL_380;
      }
      v155 = x_log_category_windowserver;
      if (!os_log_type_enabled((os_log_t)x_log_category_windowserver, OS_LOG_TYPE_DEFAULT))
        goto LABEL_380;
      v156 = "failed with";
      if ((_DWORD)v72)
        v156 = "copied";
      theDictb = (CFDictionaryRef)v156;
      v157 = IOSurfaceGetPixelFormat(v17);
      v158 = HIBYTE(v157);
      v159 = MEMORY[0x1E0C80978];
      if ((v157 & 0x80000000) != 0)
        v160 = __maskrune(v158, 0x40000uLL);
      else
        v160 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v158 + 60) & 0x40000;
      if (v160)
        v223 = (int)IOSurfaceGetPixelFormat(v17) >> 24;
      else
        v223 = 32;
      v267 = v223;
      v224 = (IOSurfaceGetPixelFormat(v17) >> 16);
      if (v224 <= 0x7F)
        v225 = *(_DWORD *)(v159 + 4 * v224 + 60) & 0x40000;
      else
        v225 = __maskrune(v224, 0x40000uLL);
      if (v225)
        v226 = (int)(IOSurfaceGetPixelFormat(v17) << 8) >> 24;
      else
        v226 = 32;
      v264 = v226;
      v227 = ((unsigned __int16)IOSurfaceGetPixelFormat(v17) >> 8);
      if (v227 <= 0x7F)
        v228 = *(_DWORD *)(v159 + 4 * v227 + 60) & 0x40000;
      else
        v228 = __maskrune(v227, 0x40000uLL);
      if (v228)
        v229 = (__int16)IOSurfaceGetPixelFormat(v17) >> 8;
      else
        v229 = 32;
      v261 = v229;
      v230 = IOSurfaceGetPixelFormat(v17);
      if (v230 <= 0x7F)
        v231 = *(_DWORD *)(v159 + 4 * v230 + 60) & 0x40000;
      else
        v231 = __maskrune(v230, 0x40000uLL);
      if (v231)
        v232 = (char)IOSurfaceGetPixelFormat(v17);
      else
        v232 = 32;
      v258 = v232;
      v274 = (CA::WindowServer::SharedEvent *)IOSurfaceGetWidth(v17);
      v270 = IOSurfaceGetHeight(v17);
      v233 = IOSurfaceGetID(v17);
      v234 = IOSurfaceGetPixelFormat(v53);
      v235 = HIBYTE(v234);
      if ((v234 & 0x80000000) != 0)
        v236 = __maskrune(v235, 0x40000uLL);
      else
        v236 = *(_DWORD *)(v159 + 4 * v235 + 60) & 0x40000;
      if (v236)
        v237 = (int)IOSurfaceGetPixelFormat(v53) >> 24;
      else
        v237 = 32;
      v238 = (IOSurfaceGetPixelFormat(v53) >> 16);
      if (v238 <= 0x7F)
        v239 = *(_DWORD *)(v159 + 4 * v238 + 60) & 0x40000;
      else
        v239 = __maskrune(v238, 0x40000uLL);
      if (v239)
        v240 = (int)(IOSurfaceGetPixelFormat(v53) << 8) >> 24;
      else
        v240 = 32;
      v241 = ((unsigned __int16)IOSurfaceGetPixelFormat(v53) >> 8);
      if (v241 <= 0x7F)
        v242 = *(_DWORD *)(v159 + 4 * v241 + 60) & 0x40000;
      else
        v242 = __maskrune(v241, 0x40000uLL);
      if (v242)
        v243 = (__int16)IOSurfaceGetPixelFormat(v53) >> 8;
      else
        v243 = 32;
      v244 = IOSurfaceGetPixelFormat(v53);
      if (v244 <= 0x7F)
        v245 = *(_DWORD *)(v159 + 4 * v244 + 60) & 0x40000;
      else
        v245 = __maskrune(v244, 0x40000uLL);
      if (v245)
        v246 = (char)IOSurfaceGetPixelFormat(v53);
      else
        v246 = 32;
      v247 = IOSurfaceGetID(v132);
      v248 = CFStringGetCStringPtr(theStringb, 0x8000100u);
      LODWORD(keys[0]) = 136319490;
      *(_QWORD *)((char *)keys + 4) = theDictb;
      WORD2(keys[1]) = 1024;
      *(_DWORD *)((char *)&keys[1] + 6) = v280;
      WORD1(keys[2]) = 1024;
      HIDWORD(keys[2]) = v267;
      LOWORD(keys[3]) = 1024;
      *(_DWORD *)((char *)&keys[3] + 2) = v264;
      HIWORD(keys[3]) = 1024;
      LODWORD(keys[4]) = v261;
      WORD2(keys[4]) = 1024;
      *(_DWORD *)((char *)&keys[4] + 6) = v258;
      WORD1(keys[5]) = 2048;
      *(_QWORD *)((char *)&keys[5] + 4) = v274;
      WORD2(keys[6]) = 2048;
      *(_QWORD *)((char *)&keys[6] + 6) = v270;
      HIWORD(keys[7]) = 1024;
      v291 = v233;
      v292 = 1024;
      v293 = v237;
      v294 = 1024;
      v295 = v240;
      v296 = 1024;
      v297 = v243;
      v298 = 1024;
      v299 = v246;
      v300 = 2048;
      v301 = v67;
      v302 = 2048;
      v303 = v68;
      v304 = 1024;
      v305 = v247;
      v306 = 1024;
      *(_DWORD *)v307 = v271;
      *(_WORD *)&v307[4] = 2080;
      *(_QWORD *)&v307[6] = v248;
      v220 = "%s 0x%x src: %c%c%c%c [%zu x %zu] 0x%x dst: %c%c%c%c [%f x %f] 0x%x, copy_flags: 0x%x, dict %s";
      v221 = v155;
      v222 = 134;
    }
    _os_log_impl(&dword_184457000, v221, OS_LOG_TYPE_DEFAULT, v220, (uint8_t *)keys, v222);
LABEL_380:
    v17 = v133;
    v53 = v132;
    if (theStringb)
      CFRelease(theStringb);
  }
  if (v259)
  {
    v129 = CAIOSurfaceWriteToFileWithSuffix(v17, "msr-src");
    free(v129);
    v130 = CAIOSurfaceWriteToFileWithSuffix(v53, "msr-dst");
    if (v130)
    {
      if (*(float *)&dword_1ECDC6938 > 0.0)
        *(float *)&dword_1ECDC6938 = *(float *)&dword_1ECDC6938 + -1.0;
      free(v130);
    }
  }
  return v72;
}

float CA::WindowServer::IOSurface::edr_factor(CA::WindowServer::IOSurface *this)
{
  return *((float *)this + 63);
}

CA::Render *CA::WindowServer::IOSurface::reload_edr_factor(CA::WindowServer::IOSurface *this)
{
  CA::Render *result;
  __IOSurface *v3;
  float edr_factor;

  result = (CA::Render *)(*(uint64_t (**)(CA::WindowServer::IOSurface *))(*(_QWORD *)this + 160))(this);
  if (result)
  {
    edr_factor = CA::Render::iosurface_get_edr_factor(result, v3);
    return (CA::Render *)(*(uint64_t (**)(CA::WindowServer::IOSurface *, float))(*(_QWORD *)this + 200))(this, edr_factor);
  }
  return result;
}

uint64_t CA::WindowServer::msr_transfer_complete(uint64_t this, void *a2, void **a3, void *a4)
{
  int v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;

  v5 = (int)a2;
  if (this)
    this = CA::IOSAManager::unref(this);
  if (a3)
  {
    v6 = (unsigned int *)a3[1];
    if (!v5)
      (*(void (**)(void *, _QWORD, void **, void *))(*(_QWORD *)v6 + 24))(a3[1], *((_QWORD *)*a3 + 3), a3, a4);
    if (*a3)
    {

      free(*a3);
    }
    this = MEMORY[0x186DBD990](a3, 0x20C40A4A59CD2, a3, a4);
    v7 = v6 + 2;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (v6)
    {
      if (v8 == 1)
        return (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  return this;
}

void CA::WindowServer::dict_shared_event_set_value(CA::WindowServer *this, __CFDictionary *a2, CA::WindowServer::SharedEvent *a3, int a4)
{
  int v4;
  const void **v7;
  int v8;
  int v9;
  const void **v10;
  const void **v11;
  BOOL v12;
  const void *v13;
  uint64_t wait_value;
  const void *v15;
  uint64_t v16;

  v4 = (int)a3;
  v7 = (const void **)MEMORY[0x1E0D3A2B8];
  if (a4)
  {
    v8 = 4;
  }
  else
  {
    v7 = (const void **)MEMORY[0x1E0D3A2A0];
    v8 = 5;
  }
  if (a4)
    v9 = 1;
  else
    v9 = 2;
  if (a4)
    v10 = (const void **)MEMORY[0x1E0D3A2C8];
  else
    v10 = (const void **)MEMORY[0x1E0D3A2B0];
  if (a4)
    v11 = (const void **)MEMORY[0x1E0D3A2C0];
  else
    v11 = (const void **)MEMORY[0x1E0D3A2A8];
  CA_CFDictionarySetLongLong(this, *v7, *((_QWORD *)a2 + 1));
  v12 = v4 == 0;
  v13 = *v10;
  if (v12)
    v8 = 3;
  wait_value = CA::WindowServer::SharedEvent::get_wait_value((uint64_t)a2, v8, v9);
  CA_CFDictionarySetLongLong(this, v13, wait_value);
  v15 = *v11;
  v16 = CA::WindowServer::SharedEvent::inc_signal_value((uint64_t)a2, v8, v9);
  CA_CFDictionarySetLongLong(this, v15, v16);
}

float *CA::WindowServer::IOSurface::allocate_iosurface(CA::WindowServer::IOSurface *a1, unsigned int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, unsigned int a8, uint64_t a9, const void *a10)
{
  __IOSurface *v18;
  __IOSurface *v19;
  float *v20;
  float *v21;
  _DWORD *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  id v27;
  void *v28;
  uint64_t v29;
  id v30;
  void *v31;
  __IOSurface *v33;
  NSObject *v34;
  __IOSurface *v35;
  IOSurfaceID v36;
  uint64_t ID;
  _OWORD v38[2];
  uint64_t v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  uint8_t buf[4];
  IOSurfaceID v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v42 = 0;
  v40 = 0u;
  v41 = 0u;
  (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)a1 + 184))(&v40);
  v38[0] = v40;
  v38[1] = v41;
  v39 = v42;
  v18 = CA::SurfaceUtil::CAIOSurfaceCreate(a2, a3, a4, a7, 0, a8, a9, v38, a10);
  if (!v18)
    return 0;
  v19 = v18;
  if (!BYTE9(xmmword_1ECDC6A90))
  {
    if (!(_DWORD)a5)
      goto LABEL_5;
    goto LABEL_4;
  }
  IOSurfaceGetID(v18);
  IOSurfaceGetProtectionOptions();
  IOSurfaceGetAllocSize(v19);
  kdebug_trace();
  if ((_DWORD)a5)
LABEL_4:
    IOSurfaceSetYCbCrMatrix();
LABEL_5:
  v20 = CA::WindowServer::IOSurface::wrap_buffer(a1, v19, 0, 1);
  v21 = v20;
  if (v20)
  {
    v22 = v20 + 56;
    *((_DWORD *)v20 + 56) |= 0x2000000u;
    (*(void (**)(float *, uint64_t))(*(_QWORD *)v20 + 32))(v20, a5);
    (*(void (**)(float *, uint64_t, _QWORD))(*(_QWORD *)v21 + 72))(v21, a6, 0);
    v23 = (a8 << 22) & 0x1000000 | (((a8 >> 1) & 1) << 29) | (((a8 >> 5) & 1) << 28);
    v24 = v23 | ((unint64_t)(a8 & 1) << 34) | (*((unsigned int *)v21 + 56) | ((unint64_t)*((unsigned __int8 *)v21 + 228) << 32)) & 0xFBCEFFFFFFLL;
    *v22 = v23 | *v22 & 0xCEFFFFFF;
    *((_BYTE *)v21 + 228) = BYTE4(v24);
    if ((a8 & 1) != 0)
      IOSurfaceSetValue(v19, CFSTR("CAWindowServerSurface"), (CFTypeRef)*MEMORY[0x1E0C9AE50]);
    if (a10)
    {
      CFRetain(a10);
      *((_QWORD *)v21 + 29) = a10;
    }
    if (CADeviceUseSharedEvents() && *((_QWORD *)v21 + 1))
    {
      if (*((_QWORD *)v21 + 2))
        __assert_rtn("create_shared_event", "windowserver-surface.cpp", 594, "!_shared_event");
      v25 = operator new();
      v26 = *((_QWORD *)v21 + 1);
      v27 = *(id *)(v26 + 296);
      if (!v27)
      {
        v27 = CAMetalContextCreate();
        *(_QWORD *)(v26 + 296) = v27;
        v26 = *((_QWORD *)v21 + 1);
      }
      v28 = *(void **)(v26 + 280);
      *(_QWORD *)v25 = v21;
      *(_QWORD *)(v25 + 16) = 0;
      *(_OWORD *)(v25 + 32) = 0u;
      *(_OWORD *)(v25 + 48) = 0u;
      if (initialized[0] != -1)
        dispatch_once_f(initialized, 0, (dispatch_function_t)init_debug);
      if (BYTE6(xmmword_1ECDC6AF0))
      {
        if (x_log_hook_p())
        {
          v33 = (__IOSurface *)(*(uint64_t (**)(float *))(*(_QWORD *)v21 + 160))(v21);
          ID = IOSurfaceGetID(v33);
          x_log_();
        }
        else
        {
          v34 = x_log_category_sharedevent;
          if (os_log_type_enabled((os_log_t)x_log_category_sharedevent, OS_LOG_TYPE_DEBUG))
          {
            v35 = (__IOSurface *)(*(uint64_t (**)(float *))(*(_QWORD *)v21 + 160))(v21);
            v36 = IOSurfaceGetID(v35);
            *(_DWORD *)buf = 67109120;
            v44 = v36;
            _os_log_impl(&dword_184457000, v34, OS_LOG_TYPE_DEBUG, "IOSurfaceID: 0x%x  Alloc", buf, 8u);
          }
        }
      }
      v29 = objc_msgSend(v27, "newSharedEvent", ID);
      *(_QWORD *)(v25 + 8) = v29;
      v30 = v28;
      *(_QWORD *)(v25 + 24) = v28;
      if (CADeviceHasInternalBuild::once != -1)
        dispatch_once(&CADeviceHasInternalBuild::once, &__block_literal_global_107);
      if (CADeviceHasInternalBuild::internal)
      {
        v31 = (void *)operator new();
        bzero(v31, 0x808uLL);
      }
      else
      {
        v31 = 0;
      }
      *(_QWORD *)(v25 + 64) = v31;
      if (v29)
      {
        *((_QWORD *)v21 + 2) = v25;
      }
      else
      {
        CA::WindowServer::SharedEvent::~SharedEvent((CA::WindowServer::SharedEvent *)v25);
        MEMORY[0x186DBD990]();
      }
    }
  }
  else
  {
    CFRelease(v19);
  }
  return v21;
}

uint64_t ___ZN2CA14CAPSEProcessor16needs_processingEv_block_invoke()
{
  uint64_t result;

  result = objc_opt_class();
  CA::CAPSEProcessor::needs_processing(void)::has_class = result != 0;
  return result;
}

CA::Render::Surface *CA::CAPSEProcessor::process_surface(CA::CAPSEProcessor *this, CA::Render::Surface *a2, double a3, float a4, float a5)
{
  CA::Render::Surface *v8;
  char *v10;
  _QWORD *v11;
  CA::CAPSEProcessor *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  const __CFString *v23;
  __IOSurface *iosurface_with_pixel_format;
  __IOSurface *v25;
  malloc_zone_t *malloc_zone;
  char *v27;
  uint64_t i;
  uint64_t v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int *v32;
  unsigned int v33;
  unsigned int v34;
  const __CFDictionary *v35;
  const __CFDictionary *v36;
  float v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  double v42;
  double v43;
  __IOSurface *v44;
  __int16 v45;
  unsigned int *v46;
  unsigned int v47;
  unsigned int v49;
  _QWORD v50[3];
  _QWORD v51[4];

  v8 = a2;
  v51[3] = *MEMORY[0x1E0C80C00];
  if ((objc_msgSend(*(id *)this, "canProcessSurface:", *((_QWORD *)a2 + 14)) & 1) != 0)
  {
    v10 = 0;
    v11 = (_QWORD *)((char *)this + 8);
    v12 = (CA::CAPSEProcessor *)((char *)this + 8);
    do
    {
      v13 = *(char **)v12;
      if (*(_QWORD *)v12)
      {
        if (*((_DWORD *)v8 + 4) == *((_DWORD *)v13 + 4)
          && *((_DWORD *)v8 + 5) == *((_DWORD *)v13 + 5)
          && (v14 = (*(uint64_t (**)(CA::Render::Surface *))(*(_QWORD *)v8 + 240))(v8),
              v15 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v12 + 240))(*(_QWORD *)v12),
              v13 = *(char **)v12,
              v14 == v15))
        {
          if (*((_DWORD *)v13 + 2) == 1 && !IOSurfaceIsInUse(*((IOSurfaceRef *)v13 + 14)))
            v10 = *(char **)v12;
        }
        else
        {
          v16 = (unsigned int *)(v13 + 8);
          do
          {
            v17 = __ldaxr(v16);
            v18 = v17 - 1;
          }
          while (__stlxr(v18, v16));
          if (!v18)
            (*(void (**)(char *))(*(_QWORD *)v13 + 16))(v13);
          *(_QWORD *)v12 = 0;
        }
      }
      v12 = (CA::CAPSEProcessor *)((char *)v12 + 8);
    }
    while (v12 != (CA::CAPSEProcessor *)((char *)this + 32));
    if (!v10)
    {
      v19 = (MEMORY[0xFFFFFC020] >> 9) & 4;
      v20 = *((_DWORD *)v8 + 4);
      v21 = *((_DWORD *)v8 + 5);
      v22 = (*(uint64_t (**)(CA::Render::Surface *))(*(_QWORD *)v8 + 240))(v8);
      iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format((CA::Render *)0x52476841, v20, v21, v19, v22, CFSTR("CA PSE Surface"), v23);
      if (!iosurface_with_pixel_format)
        return 0;
      v25 = iosurface_with_pixel_format;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      v27 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x158uLL, 0x743898A5uLL);
      v10 = v27;
      if (v27)
        CA::Render::Surface::Surface((uint64_t)v27, v25, -1, 63, 0, 0, 0);
      *((_DWORD *)v10 + 3) |= *((_DWORD *)v8 + 3) & 0xFFFFFF00;
      CFRelease(v25);
      for (i = 0; i != 3; ++i)
      {
        if (!*((_QWORD *)this + i + 1))
        {
          i = i;
          goto LABEL_36;
        }
      }
      v29 = *v11;
      v30 = (unsigned int *)(*v11 + 8);
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (v31 == 1)
        (*(void (**)(uint64_t))(*(_QWORD *)v29 + 16))(v29);
      i = 0;
LABEL_36:
      *((_QWORD *)this + i + 1) = v10;
    }
    if (!IOSurfaceGetBulkAttachments())
      IOSurfaceSetBulkAttachments2();
    v35 = IOSurfaceCopyAllValues(*((IOSurfaceRef *)v8 + 14));
    if (v35)
    {
      v36 = v35;
      IOSurfaceSetValues(*((IOSurfaceRef *)v10 + 14), v35);
      CFRelease(v36);
      IOSurfaceSetValue(*((IOSurfaceRef *)v10 + 14), (CFStringRef)*MEMORY[0x1E0CBC048], CFSTR("CA PSE Surface"));
    }
    if (a5 <= 1.0)
      v37 = 1.0;
    else
      v37 = 1.0 / a5;
    v38 = *(void **)this;
    v39 = *((_QWORD *)v8 + 14);
    v40 = *((_QWORD *)v10 + 14);
    v50[0] = CFSTR("sourceSurfaceEDR");
    v41 = (void *)MEMORY[0x1E0CB37E8];
    (*(void (**)(CA::Render::Surface *))(*(_QWORD *)v8 + 152))(v8);
    v51[0] = objc_msgSend(v41, "numberWithFloat:");
    v50[1] = CFSTR("displayMaxNits");
    *(float *)&v42 = a4;
    v51[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v42);
    v50[2] = CFSTR("displayEDRFactor");
    *(float *)&v43 = v37;
    v51[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v43);
    objc_msgSend(v38, "processSourceSurface:withTimestamp:toDestinationSurface:options:", v39, v40, objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v51, v50, 3), a3);
    CA::Render::Surface::reload_iosurface_color_attributes((CA::Render::Surface *)v10, v44);
    if ((*(unsigned int (**)(CA::Render::Surface *))(*(_QWORD *)v8 + 160))(v8))
      v45 = 16;
    else
      v45 = 0;
    *((_WORD *)v10 + 168) = *((_WORD *)v10 + 168) & 0xFFEF | v45;
    v46 = (unsigned int *)(v10 + 8);
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 + 1, v46));
    if (!v47)
    {
      do
        v49 = __ldaxr(v46);
      while (__stlxr(v49 - 1, v46));
    }
    return (CA::Render::Surface *)v10;
  }
  else
  {
    v32 = (unsigned int *)((char *)v8 + 8);
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 + 1, v32));
    if (!v33)
    {
      v8 = 0;
      do
        v34 = __ldaxr(v32);
      while (__stlxr(v34 - 1, v32));
    }
  }
  return v8;
}

IOSurfaceRef CA::Render::FlattenManager::flattened_cache_retain_iosurface(CA::Render::FlattenManager *this)
{
  unsigned int v1;
  IOSurfaceRef *v2;
  IOSurfaceRef *v3;
  IOSurfaceRef v4;
  NSObject *v6;
  NSObject *v7;
  IOSurfaceID ID;
  size_t Width;
  size_t Height;
  uint8_t buf[4];
  unsigned int v12;
  __int16 v13;
  IOSurfaceID v14;
  __int16 v15;
  size_t v16;
  __int16 v17;
  size_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!(_DWORD)this)
    return 0;
  v1 = this;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::flattened_lock);
  if (CA::Render::flattened_cache && *(_QWORD *)(CA::Render::flattened_cache + 24))
  {
    v2 = (IOSurfaceRef *)x_hash_table_lookup(CA::Render::flattened_cache, v1, 0);
    if (v2)
    {
      v3 = v2;
      if (*v2)
      {
        if ((_BYTE)xmmword_1ECDC6AF0)
        {
          if (x_log_hook_p())
          {
            IOSurfaceGetID(*v3);
            IOSurfaceGetWidth(*v3);
            IOSurfaceGetHeight(*v3);
            x_log_();
          }
          else
          {
            v7 = x_log_category_flatten;
            if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT))
            {
              ID = IOSurfaceGetID(*v3);
              Width = IOSurfaceGetWidth(*v3);
              Height = IOSurfaceGetHeight(*v3);
              *(_DWORD *)buf = 67109888;
              v12 = v1;
              v13 = 1024;
              v14 = ID;
              v15 = 2048;
              v16 = Width;
              v17 = 2048;
              v18 = Height;
              _os_log_impl(&dword_184457000, v7, OS_LOG_TYPE_DEFAULT, "[%d] found cached surface <%d> <%zu %zu>", buf, 0x22u);
            }
          }
        }
        CFRetain(*v3);
        v4 = *v3;
        goto LABEL_9;
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::flattened_lock);
    if ((_BYTE)xmmword_1ECDC6AF0)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v6 = x_log_category_flatten;
        if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          v12 = v1;
          _os_log_impl(&dword_184457000, v6, OS_LOG_TYPE_DEFAULT, "[%d] no cached surface", buf, 8u);
        }
      }
    }
    return 0;
  }
  v4 = 0;
LABEL_9:
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::flattened_lock);
  return v4;
}

CA::Render::FlattenManager *CA::Render::FlattenManager::layer_is_flattened(CA::Render::FlattenManager *this, const CA::Render::Layer *a2)
{
  uint64_t v2;
  CA::Render::FlattenManager *result;
  uint64_t v5;

  v2 = *((_QWORD *)this + 18);
  if (!v2)
    return 0;
  result = (CA::Render::FlattenManager *)*(unsigned int *)(v2 + 72);
  if (!(_DWORD)result)
    return result;
  if ((*(_BYTE *)(v2 + 13) & 0x20) == 0)
    return 0;
  v5 = *((_QWORD *)this + 5);
  if ((v5 & 0x80000) == 0)
  {
    CA::Render::FlattenManager::flattened_cache_remove_surface(result);
    result = 0;
    *(_DWORD *)(v2 + 12) &= ~0x2000u;
    return result;
  }
  return (CA::Render::FlattenManager *)((v5 & 0x100000) == 0);
}

void std::__function::__func<CA::Render::FlattenManager::flattened_cache_dump_surfaces(void)::$_0,std::allocator<CA::Render::FlattenManager::flattened_cache_dump_surfaces(void)::$_0>,void ()(unsigned int,CA::Render::FlattenedCacheEntry *)>::~__func()
{
  JUMPOUT(0x186DBD990);
}

_QWORD *std::__function::__func<CA::Render::FlattenManager::flattened_cache_dump_surfaces(void)::$_0,std::allocator<CA::Render::FlattenManager::flattened_cache_dump_surfaces(void)::$_0>,void ()(unsigned int,CA::Render::FlattenedCacheEntry *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E159A450;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CA::Render::FlattenManager::flattened_cache_dump_surfaces(void)::$_0,std::allocator<CA::Render::FlattenManager::flattened_cache_dump_surfaces(void)::$_0>,void ()(unsigned int,CA::Render::FlattenedCacheEntry *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E159A450;
  a2[1] = v2;
  return result;
}

void std::__function::__func<CA::Render::FlattenManager::flattened_cache_dump_surfaces(void)::$_0,std::allocator<CA::Render::FlattenManager::flattened_cache_dump_surfaces(void)::$_0>,void ()(unsigned int,CA::Render::FlattenedCacheEntry *)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v5;
  const char *v6;
  char __str[1024];
  char v8[1024];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = *a3;
  if (*a3 && *(_QWORD *)v3)
  {
    bzero(v8, 0x400uLL);
    if (getuid())
      confstr(65537, v8, 0x400uLL);
    else
      strcpy(v8, "/tmp/");
    bzero(__str, 0x400uLL);
    v5 = *(_QWORD *)(v3 + 56);
    if (v5)
      v6 = (const char *)(v5 + 28);
    else
      v6 = "";
    snprintf(__str, 0x400uLL, "%sctx-%x_%s(%d).png", v8, *(_DWORD *)(v3 + 48), v6, **(_DWORD **)(a1 + 8));
    save_iosurface_as_png(*(__IOSurface **)v3, (uint64_t)__str, 1);
  }
}

void CA::CG::FillEllipse::~FillEllipse(CA::CG::FillEllipse *this)
{
  malloc_zone_t *malloc_zone;

  CA::CG::DrawOp::~DrawOp(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

uint64_t CA::CG::FillEllipse::compute_dod_corners(uint64_t a1, float64x2_t *a2)
{
  float64x2_t v2;
  float64x2_t v3;
  float64x2_t v4;
  float64x2_t v5;
  uint64_t v6;
  const double *v7;
  const double *v8;
  const double *v9;
  const double *v10;
  const double *v11;
  const double *v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  double *f64;
  float64x2x2_t v21;
  float64x2x2_t v22;

  v2 = *(float64x2_t *)(a1 + 128);
  v3 = vaddq_f64(*(float64x2_t *)(a1 + 112), vminnmq_f64(v2, (float64x2_t)vdupq_n_s64(0x8000000000000000)));
  v4 = vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_f64(v2), (int8x16_t)vnegq_f64(v2), (int8x16_t)v2), v3);
  v5.f64[0] = v4.f64[0];
  v5.f64[1] = v3.f64[1];
  *a2 = v3;
  a2[1] = v5;
  v3.f64[1] = v4.f64[1];
  a2[2] = v4;
  a2[3] = v3;
  if ((*(_BYTE *)(a1 + 100) & 4) == 0)
  {
    v6 = 0;
    v7 = (const double *)(a1 + 48);
    v8 = (const double *)(a1 + 8);
    v9 = (const double *)(a1 + 32);
    v10 = (const double *)(a1 + 16);
    v11 = (const double *)(a1 + 40);
    v12 = (const double *)(a1 + 24);
    v13 = vld1q_dup_f64(v8);
    v14 = vld1q_dup_f64(v12);
    v15 = vld1q_dup_f64(v11);
    v16 = vld1q_dup_f64(v10);
    v17 = vld1q_dup_f64(v9);
    v18 = vld1q_dup_f64(v7);
    do
    {
      f64 = a2[v6].f64;
      v21 = vld2q_f64(f64);
      v22.val[0] = vmlaq_f64(vmlaq_f64(v15, v21.val[0], v13), v21.val[1], v14);
      v22.val[1] = vmlaq_f64(vmlaq_f64(v18, v21.val[0], v16), v21.val[1], v17);
      vst2q_f64(f64, v22);
      v6 += 2;
    }
    while (v6 != 4);
  }
  return 1;
}

_QWORD *CA::CG::FillEllipse::styled_op(uint64_t a1, const double *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  malloc_zone_t *malloc_zone;
  _QWORD *v11;
  int v12;
  CGColor *Color;
  unsigned int *v14;
  unsigned int v15;

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v11 = malloc_type_zone_malloc(malloc_zone, 0xA0uLL, 0x8BB15036uLL);
  if (v11)
  {
    v12 = *(_DWORD *)(a1 + 100) & 4;
    Color = (CGColor *)CGStyleGetColor();
    CA::CG::DrawOp::DrawOp((uint64_t)v11, a2, a1, a4, a5, Color, v12 | 0x8C0);
    *v11 = off_1E1591088;
    v11[18] = a1;
    v14 = (unsigned int *)(a3 + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 + 1, v14));
    v11[19] = a3;
    *v11 = off_1E1592938;
  }
  return v11;
}

void CA::CG::FillEllipseShadow::~FillEllipseShadow(CA::CG::FillEllipseShadow *this)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *(_QWORD *)this = off_1E1591088;
  v2 = (unsigned int *)*((_QWORD *)this + 19);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
  }
  CA::CG::DrawOp::~DrawOp(this);
}

{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  malloc_zone_t *malloc_zone;

  *(_QWORD *)this = off_1E1591088;
  v2 = (unsigned int *)*((_QWORD *)this + 19);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
  }
  CA::CG::DrawOp::~DrawOp(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

CGPathRef CA::CG::FillEllipseShadow::retain_path(uint64_t a1, CA::CG::Renderer *this, CGPoint *a3)
{
  uint64_t v3;
  float64x2_t v4;
  CGRect v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 144);
  v4 = *(float64x2_t *)(v3 + 128);
  v6.origin = *(CGPoint *)(v3 + 112);
  *a3 = v6.origin;
  v6.origin = 0uLL;
  v6.size = (CGSize)vmulq_f64(vrndaq_f64(vmulq_f64(v4, (float64x2_t)vdupq_n_s64(0x40F0000000000000uLL))), (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL));
  return CA::CG::Renderer::retain_simple_path(this, &v6, 0);
}

void CA::CG::StrokeEllipse::~StrokeEllipse(CA::CG::StrokeEllipse *this)
{
  *(_QWORD *)this = off_1E1591E20;
  if (*((_QWORD *)this + 20))
    CGDashRelease();
  CA::CG::DrawOp::~DrawOp(this);
}

{
  malloc_zone_t *malloc_zone;

  *(_QWORD *)this = off_1E1591E20;
  if (*((_QWORD *)this + 20))
    CGDashRelease();
  CA::CG::DrawOp::~DrawOp(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

double *CA::CG::StrokeEllipse::compute_dod(CA::CG::StrokeEllipse *this, float64x2_t *a2)
{
  double v4;
  double v5;

  CA::Rect::operator=(a2->f64, (double *)this + 14);
  if ((*((_BYTE *)this + 100) & 4) == 0)
    CA::Rect::apply_transform(a2, (const CGAffineTransform *)((char *)this + 8));
  v4 = CA::CG::stroke_radius((uint64_t)this + 144, *(float64x2_t *)((char *)this + 8), *(float64x2_t *)((char *)this + 24));
  return CA::BoundsImpl::inset_point(a2->f64, -v4, -v5);
}

_QWORD *CA::CG::StrokeEllipse::styled_op(uint64_t a1, const double *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  malloc_zone_t *malloc_zone;
  _QWORD *v11;
  int v12;
  CGColor *Color;
  unsigned int *v14;
  unsigned int v15;

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v11 = malloc_type_zone_malloc(malloc_zone, 0xA0uLL, 0x8BB15036uLL);
  if (v11)
  {
    v12 = *(_DWORD *)(a1 + 100) & 4;
    Color = (CGColor *)CGStyleGetColor();
    CA::CG::DrawOp::DrawOp((uint64_t)v11, a2, a1, a4, a5, Color, v12 | 0x8C0);
    *v11 = off_1E1591088;
    v11[18] = a1;
    v14 = (unsigned int *)(a3 + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 + 1, v14));
    v11[19] = a3;
    *v11 = off_1E1592DF0;
  }
  return v11;
}

void CA::CG::StrokeEllipse::draw_shape(CA::CG::StrokeEllipse *this, CA::CG::Renderer *a2)
{
  double v4;
  double v5;
  double v6;
  int v7;
  double v8;
  double v9;
  double *v10;
  uint64_t v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  float64_t v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  _OWORD v23[9];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 20))
    goto LABEL_6;
  v4 = *((double *)this + 16);
  v5 = *((double *)this + 17);
  v6 = v4 - v5;
  if (v4 - v5 < 0.0)
    v6 = v5 - v4;
  if (v6 > 0.001
    || (v7 = *((_DWORD *)this + 25),
        CA::CG::DrawOp::shape_line_width((uint64_t)this, (const double *)a2, *((double *)this + 18)),
        v8 < 0.0))
  {
LABEL_6:
    CA::CG::StrokeEllipse::draw_shape_as_path(this, a2);
  }
  else
  {
    v9 = v8;
    if (v8 >= 0.001)
    {
      v10 = (double *)((char *)a2 + 32);
      v11 = 88;
      if ((v7 & 4) != 0)
        v10 = (double *)((char *)a2 + 88);
      else
        v11 = 32;
      v12 = *((double *)this + 14);
      v13 = *((double *)this + 15);
      v19 = v12;
      v20 = v13;
      v21 = v4;
      v22 = v5;
      if (v4 >= 0.0)
      {
        v14 = v4;
      }
      else
      {
        v12 = v4 + v12;
        v14 = -v4;
        v19 = v12;
        v21 = -v4;
      }
      if (v5 < 0.0)
      {
        v13 = v5 + v13;
        v5 = -v5;
        v20 = v13;
        v22 = v5;
      }
      v15 = v9 * 0.5;
      if (v14 <= v5)
        v16 = v5;
      else
        v16 = v14;
      if (v16 < 1.79769313e308)
      {
        v19 = v12 - v15;
        v20 = v13 - v15;
        v21 = v14 + v9;
        v22 = v5 + v9;
        if (v14 + v9 <= 0.0 || v5 + v9 <= 0.0)
        {
          v21 = 0.0;
          v22 = 0.0;
        }
      }
      v27 = 0;
      v17 = v15 + v4 * 0.5;
      v25 = 0u;
      v26 = 0u;
      v24 = 0u;
      v18 = *(double *)((char *)a2 + v11);
      memset(v23, 0, sizeof(v23));
      CA::Transform::set_affine((CA::Transform *)v23, v18, v10[1], v10[2], v10[3], v10[4], v10[5]);
      *((_QWORD *)&v24 + 1) = &v19;
      *(_QWORD *)&v25 = v23;
      DWORD2(v25) = 2097215;
      HIDWORD(v25) = (v7 << 31 >> 31);
      v27 = 0;
      v26 = 0uLL;
      CA::OGL::stroke_round_rect(*((_QWORD **)a2 + 1), (float64x2_t **)&v24 + 1, (double *)0xF, 0, v17, v9);
    }
  }
}

void CA::CG::StrokeEllipse::draw_shape_as_path(CA::CG::StrokeEllipse *this, CA::CG::Renderer *a2)
{
  CGPathRef v4;
  const CGPath *v5;

  v4 = CA::CG::Renderer::retain_simple_path(a2, (const CGRect *)((char *)this + 112), 0);
  if (v4)
  {
    v5 = v4;
    CA::CG::stroke_path((uint64_t)a2, (uint64_t)v4, 0, (uint64_t)this + 8, (uint64_t)this + 144);
    CGPathRelease(v5);
  }
}

void CA::CG::StrokeEllipseShadow::~StrokeEllipseShadow(CA::CG::StrokeEllipseShadow *this)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *(_QWORD *)this = off_1E1591088;
  v2 = (unsigned int *)*((_QWORD *)this + 19);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
  }
  CA::CG::DrawOp::~DrawOp(this);
}

{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  malloc_zone_t *malloc_zone;

  *(_QWORD *)this = off_1E1591088;
  v2 = (unsigned int *)*((_QWORD *)this + 19);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
  }
  CA::CG::DrawOp::~DrawOp(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

uint64_t CA::CG::StrokeEllipseShadow::retain_path(uint64_t a1, CA::CG::Renderer *this, CGPoint *a3)
{
  uint64_t v3;
  float64x2_t v4;
  const CGPath *v5;
  const CGPath *v6;
  uint64_t stroked_path;
  CGRect v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 144);
  v4 = *(float64x2_t *)(v3 + 128);
  v9.origin = *(CGPoint *)(v3 + 112);
  *a3 = v9.origin;
  v9.origin = 0uLL;
  v9.size = (CGSize)vmulq_f64(vrndaq_f64(vmulq_f64(v4, (float64x2_t)vdupq_n_s64(0x40F0000000000000uLL))), (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL));
  v5 = CA::CG::Renderer::retain_simple_path(this, &v9, 0);
  if (!v5)
    return 0;
  v6 = v5;
  stroked_path = CA::CG::create_stroked_path(v5, (_OWORD *)(v3 + 8), v3 + 144, (*(_DWORD *)(v3 + 100) & 4) != 0);
  CGPathRelease(v6);
  return stroked_path;
}

uint64_t CA::OGL::ImagingNode::mesh_node_p(CA::OGL::ImagingNode *this)
{
  return 0;
}

uint64_t CA::OGL::ImagingNode::allow_in_place(CA::OGL::ImagingNode *this)
{
  return 0;
}

CA::OGL::ImagingNode *CA::OGL::ImagingNode::remove_feature_passthrough_aware(CA::OGL::ImagingNode *this, unsigned int a2)
{
  CA::OGL::ImagingNode *result;

  if ((*((_WORD *)this + 106) & 0x100) != 0
    || (result = (CA::OGL::ImagingNode *)(*(uint64_t (**)(CA::OGL::ImagingNode *))(*(_QWORD *)this + 112))(this),
        (_DWORD)result))
  {
    result = (CA::OGL::ImagingNode *)*((_QWORD *)this + 3);
    if (result)
      result = (CA::OGL::ImagingNode *)CA::OGL::ImagingNode::remove_feature_passthrough_aware(result, a2);
  }
  *((_DWORD *)this + 54) &= ~0x800u;
  return result;
}

float CA::OGL::MaskCorners::corner_contents_texcoord(CA::OGL::MaskCorners *this, unsigned int a2, const float *a3, float *a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float result;

  v4 = 0.0;
  v5 = 0.0;
  if ((a2 & 0xFFFFFFFD) != 0)
    v5 = *((double *)this + 28) + *((double *)this + 26);
  *a4 = v5;
  if (a2 >= 2)
    v4 = *((double *)this + 29) + *((double *)this + 27);
  a4[1] = v4;
  v6 = 1.0;
  v7 = 1.0;
  if ((a2 & 0xFFFFFFFD) == 0)
    v7 = *((double *)this + 26);
  a4[2] = v7;
  if (a2 <= 1)
    v6 = *((double *)this + 27);
  a4[3] = v6;
  *a4 = *a3 + (float)((float)(a3[2] - *a3) * v5);
  a4[1] = a3[1] + (float)((float)(a3[3] - a3[1]) * v4);
  a4[2] = *a3 + (float)((float)(a3[2] - *a3) * v7);
  result = a3[1] + (float)((float)(a3[3] - a3[1]) * v6);
  a4[3] = result;
  return result;
}

void CA::OGL::CacheNode::~CacheNode(CA::OGL::CacheNode *this)
{
  abort();
}

uint64_t CA::OGL::CacheNode::apply(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 104))(*(_QWORD *)(a1 + 24));
}

void CA::OGL::FlattenNode::~FlattenNode(CA::OGL::FlattenNode *this)
{
  abort();
}

void CA::OGL::FlattenNode::compute_dod(CA::OGL::FlattenNode *this, CA::Bounds *a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  _DWORD *v8;
  NSObject *v9;
  _BOOL4 v10;
  int v11;
  int v12;
  int v13;
  int v14;
  NSObject *v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  __int128 v20;
  uint8_t buf[4];
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 2) + 24) + 42) & 0x10) != 0)
    goto LABEL_25;
  v4 = *((unsigned int *)this + 56);
  if (!(_DWORD)v4)
    goto LABEL_19;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::flattened_lock);
  v5 = 0uLL;
  if (!CA::Render::flattened_cache || !*(_QWORD *)(CA::Render::flattened_cache + 24))
    goto LABEL_8;
  v6 = x_hash_table_lookup(CA::Render::flattened_cache, v4, 0);
  if (v6)
  {
    if (!(_BYTE)xmmword_1ECDC6AF0)
    {
LABEL_7:
      v5 = *(_OWORD *)(v6 + 24);
LABEL_8:
      v20 = v5;
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::flattened_lock);
      v7 = v20;
      goto LABEL_20;
    }
    v8 = (_DWORD *)v6;
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v9 = x_log_category_flatten;
      v10 = os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT);
      v6 = (uint64_t)v8;
      if (!v10)
        goto LABEL_7;
      v11 = v8[6];
      v12 = v8[7];
      v13 = v8[8];
      v14 = v8[9];
      *(_DWORD *)buf = 67110144;
      v22 = v4;
      v23 = 1024;
      v24 = v11;
      v25 = 1024;
      v26 = v12;
      v27 = 1024;
      v28 = v13;
      v29 = 1024;
      v30 = v14;
      _os_log_impl(&dword_184457000, v9, OS_LOG_TYPE_DEFAULT, "[%d] found cached dod <%d %d %d %d>", buf, 0x20u);
    }
    v6 = (uint64_t)v8;
    goto LABEL_7;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::flattened_lock);
  v7 = 0uLL;
  if ((_BYTE)xmmword_1ECDC6AF0)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      v15 = x_log_category_flatten;
      if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        v22 = v4;
        _os_log_impl(&dword_184457000, v15, OS_LOG_TYPE_DEFAULT, "[%d] no cached dod", buf, 8u);
      }
    }
LABEL_19:
    v7 = 0uLL;
  }
LABEL_20:
  v16 = HIDWORD(v7);
  if (SDWORD2(v7) >= SHIDWORD(v7))
    v17 = HIDWORD(v7);
  else
    v17 = DWORD2(v7);
  if (v17 >= 1)
  {
    *(_QWORD *)a2 = v7;
    *((_DWORD *)a2 + 2) = DWORD2(v7);
    goto LABEL_28;
  }
LABEL_25:
  v18 = *((_QWORD *)this + 3);
  v19 = *(_DWORD *)(v18 + 136);
  if (v19 < 0)
  {
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v18 + 40))(v18, v18 + 128);
    v19 = *(_DWORD *)(v18 + 136);
  }
  *(_QWORD *)a2 = *(_QWORD *)(v18 + 128);
  *((_DWORD *)a2 + 2) = v19;
  v16 = *(_DWORD *)(v18 + 140);
LABEL_28:
  *((_DWORD *)a2 + 3) = v16;
}

uint64_t CA::OGL::FlattenNode::grow_roi(int32x2_t *this, int32x2_t *a2)
{
  if (this[17].i32[0] < 0)
    (*(void (**)(int32x2_t *, int32x2_t *))(*(_QWORD *)this + 40))(this, this + 16);
  return CA::BoundsImpl::Union(a2, this[16], this[17]);
}

uint64_t CA::OGL::FlattenNode::propagate_roi(CA::OGL::FlattenNode *this, const CA::Bounds *a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD, const CA::Bounds *))(**((_QWORD **)this + 3) + 56))(*((_QWORD *)this + 3), a2);
  *(_DWORD *)(*((_QWORD *)this + 3) + 216) = *(_DWORD *)(*((_QWORD *)this + 3) + 216) & 0xFFC00000 | *((_DWORD *)this + 54) & 0x3FFFFF;
  *(_DWORD *)(*((_QWORD *)this + 3) + 216) |= 0x400u;
  *(_WORD *)(*((_QWORD *)this + 3) + 212) = *(_WORD *)(*((_QWORD *)this + 3) + 212) & 0xFDFF | *((_WORD *)this + 106) & 0x200;
  *(_WORD *)(*((_QWORD *)this + 3) + 212) = *(_WORD *)(*((_QWORD *)this + 3) + 212) & 0xC3FF | *((_WORD *)this + 106) & 0x3C00;
  *(_DWORD *)(*((_QWORD *)this + 3) + 216) |= 0x1000u;
  return result;
}

uint64_t CA::OGL::FlattenNode::retain_surface(CA::OGL::FlattenNode *this, float *a2, uint64_t a3, __n128 a4)
{
  CA::OGL::Context **v7;
  CA::OGL::Context *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  IOSurfaceRef v16;
  __IOSurface *v17;
  unint64_t v18;
  uint64_t v19;
  __IOSurface *v20;
  NSObject *v22;
  _BOOL4 v23;
  int v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  __IOSurface *v31;
  const __CFString *v32;
  __IOSurface *v33;
  const CA::Render::LayerNode *v34;
  int v35;
  __IOSurface *iosurface_with_pixel_format;
  _QWORD *v37;
  __n128 v38;
  uint64_t v39;
  __n128 v40;
  malloc_zone_t *malloc_zone;
  _QWORD *v42;
  int *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  float v48;
  uint64_t v49;
  int v50;
  NSObject *v51;
  os_log_type_t v52;
  uint64_t v53;
  NSObject *v54;
  _BOOL4 v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  NSObject *v59;
  IOSurfaceID v60;
  uint64_t v61;
  NSObject *v62;
  int v63;
  IOSurfaceID v64;
  IOSurfaceID v65;
  int v66;
  IOSurfaceID v67;
  NSObject *v68;
  IOSurfaceID ID;
  IOSurfaceID v70;
  int v71;
  int v72;
  int v73;
  NSObject *log;
  int v75;
  BOOL v76;
  int v77;
  __n128 v78;
  __n128 v79;
  int v80;
  int v81;
  __n128 v82;
  __n128 v83;
  float *v84;
  uint8_t buf[16];
  __int128 v86;
  _OWORD v87[2];
  __int128 v88;
  _OWORD v89[2];
  int v90;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  v7 = (CA::OGL::Context **)*((_QWORD *)this + 1);
  v8 = *v7;
  v9 = *((_DWORD *)this + 34);
  if ((v9 & 0x80000000) != 0)
  {
    (*(void (**)(CA::OGL::FlattenNode *, char *))(*(_QWORD *)this + 40))(this, (char *)this + 128);
    v9 = *((_DWORD *)this + 34);
  }
  v10 = *(_QWORD *)(*((_QWORD *)this + 2) + 24);
  v11 = *(_QWORD *)(v10 + 144);
  if (!v11)
    return (*(uint64_t (**)(_QWORD, float *, uint64_t))(**((_QWORD **)this + 3) + 80))(*((_QWORD *)this + 3), a2, a3);
  v84 = a2;
  a4.n128_u64[0] = *((_QWORD *)this + 16);
  v12 = *((_DWORD *)this + 35);
  v13 = BYTE1(xmmword_1ECDC6AF0);
  v14 = xmmword_1ECDC6AF0;
  if ((*(_BYTE *)(v11 + 13) & 0x20) == 0 || (*(_BYTE *)(v10 + 42) & 0x10) != 0)
  {
LABEL_15:
    if ((*((_DWORD *)v7[1] + 266) & 4) != 0)
      return (*(uint64_t (**)(_QWORD, float *, uint64_t, __n128))(**((_QWORD **)this + 3) + 80))(*((_QWORD *)this + 3), v84, a3, a4);
    v25 = *((_QWORD *)v8 + 31);
    v83 = a4;
    v80 = v13;
    v81 = v14;
    v26 = v25 && (*(_BYTE *)(v25 + 68) & 0x30) != 0;
    v27 = *((unsigned int *)this + 56);
    v28 = (*(uint64_t (**)(CA::OGL::Context *))(*(_QWORD *)v8 + 96))(v8);
    if (!(_DWORD)v27 || (v9 & 0x80000000) != 0 || v12 < 0)
      return (*(uint64_t (**)(_QWORD, float *, uint64_t, __n128))(**((_QWORD **)this + 3) + 80))(*((_QWORD *)this + 3), v84, a3, a4);
    if (v12 | v9)
    {
      v29 = v28;
      v77 = v12;
      v76 = v26;
      if (v26)
      {
        v30 = 1380411457;
      }
      else
      {
        if (CADeviceUseCIF10::once != -1)
          dispatch_once(&CADeviceUseCIF10::once, &__block_literal_global_9735);
        if (CADeviceUseCIF10::enable_cif10)
          v30 = 1647534392;
        else
          v30 = 1111970369;
      }
      v31 = CA::Render::FlattenManager::flattened_cache_retain_iosurface((CA::Render::FlattenManager *)v27);
      if (v31)
      {
        v33 = v31;
        if (IOSurfaceGetWidth(v31) == v9
          && IOSurfaceGetHeight(v33) == v77
          && IOSurfaceGetProtectionOptions() == v29
          && IOSurfaceGetPixelFormat(v33) == (_DWORD)v30)
        {
          if ((_BYTE)xmmword_1ECDC6AF0)
          {
            if (x_log_hook_p())
            {
              IOSurfaceGetID(v33);
              x_log_();
            }
            else
            {
              v68 = x_log_category_flatten;
              if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT))
              {
                ID = IOSurfaceGetID(v33);
                *(_DWORD *)buf = 67109376;
                *(_DWORD *)&buf[4] = v27;
                *(_WORD *)&buf[8] = 1024;
                *(_DWORD *)&buf[10] = ID;
                _os_log_impl(&dword_184457000, v68, OS_LOG_TYPE_DEFAULT, "[%d] reusing surface <%d>", buf, 0xEu);
              }
            }
          }
          v35 = 0x80000;
LABEL_56:
          v48 = 1.0;
          if (!v76)
            CA::Render::Update::render_edr_factor(v7[1], v34);
          memset(v89, 0, sizeof(v89));
          v90 = 0;
          v88 = 0u;
          v86 = 0u;
          memset(v87, 0, sizeof(v87));
          *(_OWORD *)buf = 0u;
          *(int8x8_t *)((char *)v89 + 12) = vand_s8((int8x8_t)(vcvts_n_s32_f32(v48, 0x14uLL) | 0x10000000000000), (int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v48 != 0.0), 0x1FuLL)));
          IOSurfaceSetBulkAttachments2();
          v49 = (*(uint64_t (**)(CA::OGL::Context *, uint64_t, _QWORD, _QWORD, __IOSurface *))(*(_QWORD *)v8 + 672))(v8, 1, v83.n128_u32[0], v83.n128_u32[1], v33);
          if (v49)
          {
            v19 = v49;
            if (v80)
            {
              v57 = *(_QWORD *)(*((_QWORD *)this + 2) + 104);
              if (v57)
                *(_DWORD *)(v57 + 220) = *(_DWORD *)(v57 + 220) & 0xFFF1FFFF | v35;
            }
            if (v81)
            {
              if (x_log_hook_p())
              {
                IOSurfaceGetID(v33);
                x_log_();
              }
              else
              {
                v62 = x_log_category_flatten;
                if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_INFO))
                {
                  v63 = *((_DWORD *)this + 56);
                  v64 = IOSurfaceGetID(v33);
                  *(_DWORD *)buf = 67109888;
                  *(_DWORD *)&buf[4] = v63;
                  *(_WORD *)&buf[8] = 1024;
                  *(_DWORD *)&buf[10] = v64;
                  *(_WORD *)&buf[14] = 1024;
                  LODWORD(v86) = v9;
                  WORD2(v86) = 1024;
                  *(_DWORD *)((char *)&v86 + 6) = v77;
                  _os_log_impl(&dword_184457000, v62, OS_LOG_TYPE_INFO, "[%d] rendered & cached new surf <%d> <%d %d>", buf, 0x1Au);
                }
              }
            }
            CA::OGL::Context::push_surface((uint64_t)v8, v19, 1u, 0, 0);
            CA::OGL::ImagingNode::render(*((_QWORD *)this + 3), 0, 0);
            CA::OGL::Context::pop_surface(v8);
            *(_DWORD *)(v11 + 12) |= 0x2000u;
            *v84 = 1.0;
            v20 = v33;
            goto LABEL_62;
          }
          CA::Render::FlattenManager::flattened_cache_remove_surface((CA::Render::FlattenManager *)*((unsigned int *)this + 56));
          *(_DWORD *)(v11 + 12) &= ~0x2000u;
          CFRelease(v33);
          if (x_log_hook_p())
            goto LABEL_64;
          v46 = x_log_category_ogl;
          if (!os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_ERROR))
            return (*(uint64_t (**)(_QWORD, float *, uint64_t, __n128))(**((_QWORD **)this + 3) + 80))(*((_QWORD *)this + 3), v84, a3, a4);
          v50 = *((_DWORD *)this + 56);
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v50;
          v47 = "[%d] Failed to create flattened OGL::Surface";
          goto LABEL_67;
        }
      }
      iosurface_with_pixel_format = CA::Render::create_iosurface_with_pixel_format((CA::Render *)v30, v9, v77, 0, v29, CFSTR("CA Flattened Surface"), v32);
      if (iosurface_with_pixel_format)
      {
        v33 = iosurface_with_pixel_format;
        os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::flattened_lock);
        v37 = (_QWORD *)CA::Render::flattened_cache;
        if (!CA::Render::flattened_cache)
        {
          v37 = x_hash_table_new_(0, 0, 0, 0, 0, 0);
          CA::Render::flattened_cache = (uint64_t)v37;
        }
        v38 = v83;
        v38.n128_u32[2] = v9;
        v78 = v38;
        v39 = x_hash_table_lookup((uint64_t)v37, v27, 0);
        v40 = v78;
        if (!v39)
        {
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          v42 = malloc_type_zone_malloc(malloc_zone, 0x40uLL, 0x8BB15036uLL);
          v39 = (uint64_t)v42;
          if (v42)
          {
            v42[7] = 0;
            *(_OWORD *)v42 = 0u;
            *((_OWORD *)v42 + 1) = 0u;
            *((_OWORD *)v42 + 2) = 0u;
            *((_DWORD *)v42 + 12) = 0;
            v43 = (int *)CA::Render::flattened_cache;
            v44 = v27;
            v45 = v39;
          }
          else
          {
            v43 = (int *)CA::Render::flattened_cache;
            v44 = v27;
            v45 = 0;
          }
          hash_table_modify(v43, v44, v45, 0);
          v40 = v78;
        }
        v40.n128_u32[3] = v77;
        if (*(_QWORD *)v39)
        {
          v79 = v40;
          if ((_BYTE)xmmword_1ECDC6AF0)
          {
            v75 = v27;
            if (x_log_hook_p())
            {
              IOSurfaceGetID(*(IOSurfaceRef *)v39);
              IOSurfaceGetID(v33);
              x_log_();
            }
            else
            {
              log = x_log_category_flatten;
              if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT))
              {
                v65 = IOSurfaceGetID(*(IOSurfaceRef *)v39);
                v66 = *(_DWORD *)(v39 + 24);
                v70 = v65;
                v71 = *(_DWORD *)(v39 + 28);
                v72 = *(_DWORD *)(v39 + 32);
                v73 = *(_DWORD *)(v39 + 36);
                v67 = IOSurfaceGetID(v33);
                *(_DWORD *)buf = 67111680;
                *(_DWORD *)&buf[4] = v75;
                *(_WORD *)&buf[8] = 1024;
                *(_DWORD *)&buf[10] = v70;
                *(_WORD *)&buf[14] = 1024;
                LODWORD(v86) = v66;
                LODWORD(v27) = v75;
                WORD2(v86) = 1024;
                *(_DWORD *)((char *)&v86 + 6) = v71;
                WORD5(v86) = 1024;
                HIDWORD(v86) = v72;
                LOWORD(v87[0]) = 1024;
                *(_DWORD *)((char *)v87 + 2) = v73;
                WORD3(v87[0]) = 1024;
                DWORD2(v87[0]) = v67;
                WORD6(v87[0]) = 1024;
                *(_DWORD *)((char *)v87 + 14) = v83.n128_u32[0];
                WORD1(v87[1]) = 1024;
                DWORD1(v87[1]) = v83.n128_u32[1];
                WORD4(v87[1]) = 1024;
                *(_DWORD *)((char *)&v87[1] + 10) = v9;
                HIWORD(v87[1]) = 1024;
                LODWORD(v88) = v77;
                _os_log_impl(&dword_184457000, log, OS_LOG_TYPE_DEFAULT, "[%d] replacing surface <%d> <%d %d %d %d> with surface <%d> <%d %d %d %d>", buf, 0x44u);
              }
            }
          }
          CFRelease(*(CFTypeRef *)v39);
          v40 = v79;
        }
        *(_QWORD *)v39 = v33;
        *(__n128 *)(v39 + 24) = v40;
        if ((_BYTE)xmmword_1ECDC6AF0)
        {
          if (x_log_hook_p())
          {
            IOSurfaceGetID(v33);
            x_log_();
          }
          else
          {
            v59 = x_log_category_flatten;
            if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT))
            {
              v60 = IOSurfaceGetID(v33);
              v61 = *(_QWORD *)(CA::Render::flattened_cache + 24);
              *(_DWORD *)buf = 67110656;
              *(_DWORD *)&buf[4] = v27;
              *(_WORD *)&buf[8] = 1024;
              *(_DWORD *)&buf[10] = v60;
              *(_WORD *)&buf[14] = 1024;
              LODWORD(v86) = v83.n128_u32[0];
              WORD2(v86) = 1024;
              *(_DWORD *)((char *)&v86 + 6) = v83.n128_u32[1];
              WORD5(v86) = 1024;
              HIDWORD(v86) = v9;
              LOWORD(v87[0]) = 1024;
              *(_DWORD *)((char *)v87 + 2) = v77;
              WORD3(v87[0]) = 2048;
              *((_QWORD *)&v87[0] + 1) = v61;
              _os_log_impl(&dword_184457000, v59, OS_LOG_TYPE_DEFAULT, "[%d] added surface <%d> <%d %d %d %d> to cache <size: %zu>", buf, 0x30u);
            }
          }
        }
        os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::flattened_lock);
        CFRetain(v33);
        v35 = 393216;
        goto LABEL_56;
      }
      if (!x_log_hook_p())
      {
        v46 = x_log_category_flatten;
        if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v27;
          v47 = "[%d] Failed to create flattened iosurface";
LABEL_67:
          v51 = v46;
          v52 = OS_LOG_TYPE_ERROR;
LABEL_68:
          _os_log_impl(&dword_184457000, v51, v52, v47, buf, 8u);
        }
        return (*(uint64_t (**)(_QWORD, float *, uint64_t, __n128))(**((_QWORD **)this + 3) + 80))(*((_QWORD *)this + 3), v84, a3, a4);
      }
    }
    else
    {
      if (!(_BYTE)xmmword_1ECDC6AF0)
        return (*(uint64_t (**)(_QWORD, float *, uint64_t, __n128))(**((_QWORD **)this + 3) + 80))(*((_QWORD *)this + 3), v84, a3, a4);
      if (!x_log_hook_p())
      {
        v58 = x_log_category_flatten;
        if (!os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT))
          return (*(uint64_t (**)(_QWORD, float *, uint64_t, __n128))(**((_QWORD **)this + 3) + 80))(*((_QWORD *)this + 3), v84, a3, a4);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v27;
        v47 = "[%d] trying to flatten an empty surface!";
        v51 = v58;
        v52 = OS_LOG_TYPE_DEFAULT;
        goto LABEL_68;
      }
    }
LABEL_64:
    x_log_();
    return (*(uint64_t (**)(_QWORD, float *, uint64_t, __n128))(**((_QWORD **)this + 3) + 80))(*((_QWORD *)this + 3), v84, a3, a4);
  }
  v15 = BYTE1(xmmword_1ECDC6AF0);
  v82 = a4;
  v16 = CA::Render::FlattenManager::flattened_cache_retain_iosurface((CA::Render::FlattenManager *)*((unsigned int *)this + 56));
  if (!v16)
  {
    if (x_log_hook_p())
    {
      x_log_();
      a4 = v82;
      v13 = v15;
    }
    else
    {
      v22 = x_log_category_ogl;
      v23 = os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_ERROR);
      a4 = v82;
      v13 = v15;
      if (v23)
      {
        v24 = *((_DWORD *)this + 56);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v24;
        _os_log_impl(&dword_184457000, v22, OS_LOG_TYPE_ERROR, "[%d] cachedFlatten but no cached surface", buf, 8u);
        v13 = v15;
        a4 = v82;
      }
    }
    goto LABEL_15;
  }
  v17 = v16;
  if (v15)
  {
    v53 = *(_QWORD *)(*((_QWORD *)this + 2) + 104);
    if (v53)
      *(_DWORD *)(v53 + 220) = *(_DWORD *)(v53 + 220) & 0xFFF1FFFF | 0x40000;
  }
  v18 = v82.n128_u64[0];
  if (!v14)
    goto LABEL_9;
  if (x_log_hook_p())
  {
    IOSurfaceGetID(v17);
    x_log_();
LABEL_79:
    v18 = v82.n128_u64[0];
    goto LABEL_9;
  }
  v54 = x_log_category_flatten;
  v55 = os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_INFO);
  v18 = v82.n128_u64[0];
  if (v55)
  {
    v56 = *((_DWORD *)this + 56);
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&buf[4] = v56;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = IOSurfaceGetID(v17);
    _os_log_impl(&dword_184457000, v54, OS_LOG_TYPE_INFO, "[%d] using cached surf <%d>", buf, 0xEu);
    goto LABEL_79;
  }
LABEL_9:
  *v84 = 1.0;
  v19 = (*(uint64_t (**)(CA::OGL::Context *, uint64_t, _QWORD, _QWORD, __IOSurface *))(*(_QWORD *)v8 + 672))(v8, 1, v18, HIDWORD(v18), v17);
  v20 = v17;
LABEL_62:
  CFRelease(v20);
  return v19;
}

uint64_t CA::OGL::FlattenNode::apply(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 104))(*(_QWORD *)(a1 + 24));
}

void CA::OGL::AsynchronousNode::~AsynchronousNode(CA::OGL::AsynchronousNode *this)
{
  abort();
}

uint64_t CA::OGL::AsynchronousNode::apply(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 104))(*(_QWORD *)(a1 + 24));
}

uint64_t CA::OGL::FilterNode::grow_roi(CA::OGL::FilterNode *this, int32x2_t *a2)
{
  uint64_t result;

  result = CA::OGL::filter_flags(*((_QWORD *)this + 29), *((_QWORD *)this + 2));
  if ((result & 0x20) != 0)
  {
    if ((*((_DWORD *)this + 34) & 0x80000000) != 0)
      (*(void (**)(CA::OGL::FilterNode *, char *))(*(_QWORD *)this + 40))(this, (char *)this + 128);
    return CA::BoundsImpl::Union(a2, *(int32x2_t *)((char *)this + 128), *(int32x2_t *)((char *)this + 136));
  }
  return result;
}

int *CA::OGL::FilterNode::retain_surface(CA::OGL::FilterNode *this, float *a2, uint64_t a3)
{
  unsigned int v3;
  uint64_t v6;
  CA::Render::Update **v7;
  CA::Render::Update *v8;
  uint64_t v9;
  int *v10;
  float v12;
  uint64_t v13;

  v3 = a3;
  v13 = *MEMORY[0x1E0C80C00];
  if ((*((_BYTE *)this + 224) & 1) == 0)
    return CA::OGL::ImagingNode::retain_surface(this, a2, v3);
  v6 = *((_QWORD *)this + 2);
  if ((*(_WORD *)(v6 + 40) & 8) != 0 || (*(_BYTE *)(v6 + 32) & 8) != 0)
    return CA::OGL::ImagingNode::retain_surface(this, a2, v3);
  v7 = (CA::Render::Update **)*((_QWORD *)this + 1);
  v8 = *v7;
  v12 = 1.0;
  v9 = (*(uint64_t (**)(_QWORD, float *, uint64_t))(**((_QWORD **)this + 3) + 80))(*((_QWORD *)this + 3), &v12, a3);
  v10 = (int *)v9;
  if (*((_QWORD *)v8 + 33) == v9)
  {
    CA::OGL::Context::release_surface((uint64_t)v8, v9);
    return CA::OGL::ImagingNode::retain_surface(this, a2, v3);
  }
  CA::OGL::Context::push_surface((uint64_t)v8, v9, (*(_WORD *)(v9 + 75) & 0x80) == 0, 64, 0);
  CA::OGL::emit_filter(v7, *((_QWORD *)this + 29), *((_QWORD *)this + 2), v10, 0, 0, 0, *a2, v12);
  CA::OGL::Context::pop_surface(v8);
  *a2 = v12;
  return v10;
}

uint64_t CA::OGL::FilterNode::allow_in_place(CA::OGL::FilterNode *this)
{
  return *((_BYTE *)this + 224) & 1;
}

void CA::OGL::BackdropNode::~BackdropNode(CA::OGL::BackdropNode *this)
{
  abort();
}

double CA::OGL::BackdropNode::compute_dod(CA::OGL::BackdropNode *this, CA::Bounds *a2)
{
  double result;

  result = -2.68156638e154;
  *(_OWORD *)a2 = xmmword_18474E240;
  return result;
}

_DWORD *CA::OGL::BackdropNode::retain_surface(CA::OGL::BackdropNode *this, float *a2)
{
  _DWORD *result;

  *a2 = 1.0;
  result = (_DWORD *)*((_QWORD *)this + 28);
  if (result)
    ++*result;
  return result;
}

void CA::OGL::QuadNode::~QuadNode(CA::OGL::QuadNode *this)
{
  abort();
}

void CA::OGL::CombineNode::~CombineNode(CA::OGL::CombineNode *this)
{
  abort();
}

void CA::OGL::BlendNode::~BlendNode(CA::OGL::BlendNode *this)
{
  abort();
}

uint64_t CA::OGL::BlendNode::compute_dod(CA::OGL::BlendNode *this, int32x2_t *a2)
{
  int32x2_t *v4;
  __int32 v5;
  __int32 v6;
  int32x2_t *v7;

  v4 = (int32x2_t *)*((_QWORD *)this + 3);
  v5 = v4[17].i32[0];
  if (v5 < 0)
  {
    (*(void (**)(_QWORD, int32x2_t *))(*(_QWORD *)v4 + 40))(*((_QWORD *)this + 3), v4 + 16);
    v5 = v4[17].i32[0];
  }
  *a2 = v4[16];
  v6 = v4[17].i32[1];
  a2[1].i32[0] = v5;
  a2[1].i32[1] = v6;
  v7 = (int32x2_t *)*((_QWORD *)this + 4);
  if (v7[17].i32[0] < 0)
    (*(void (**)(int32x2_t *, int32x2_t *))(*(_QWORD *)v7 + 40))(v7, v7 + 16);
  return CA::BoundsImpl::Union(a2, v7[16], v7[17]);
}

uint64_t CA::OGL::BlendNode::propagate_roi(CA::OGL::BlendNode *this, const CA::Bounds *a2)
{
  (*(void (**)(_QWORD))(**((_QWORD **)this + 3) + 56))(*((_QWORD *)this + 3));
  return (*(uint64_t (**)(_QWORD, const CA::Bounds *))(**((_QWORD **)this + 4) + 56))(*((_QWORD *)this + 4), a2);
}

void CA::OGL::BlendNode::apply(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _DWORD *v5;
  CA::Shape *v6;
  int8x16_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  _DWORD *v11;
  CA::Shape *v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  int8x16_t v17;
  int32x4_t v18;
  CA::Shape *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v4 = **(_QWORD **)(a1 + 8);
  v5 = *(_DWORD **)a2;
  v6 = *(CA::Shape **)(a1 + 64);
  v20 = 0;
  v21 = 0;
  CA::OGL::emit_combine(v4, 1, v5, 0, v6, (unsigned int *)&v20);
  if (*(_BYTE *)(a1 + 124) != 2)
  {
    v8 = *(_QWORD *)(a1 + 88);
    if (v8 == 0x3C003C003C003C00)
    {
      v9 = 1;
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8) = v8;
      v9 = 3;
    }
    v10 = *(_QWORD *)(v4 + 16);
    if (*(unsigned __int8 *)(v10 + 480) >= 2u)
      *(_BYTE *)(v10 + 481) |= 1u;
    v11 = *(_DWORD **)(a2 + 8);
    v12 = *(CA::Shape **)(a1 + 64);
    v20 = 0;
    v21 = 0;
    CA::OGL::emit_combine(v4, v9, v11, 0, v12, (unsigned int *)&v20);
    *(_BYTE *)(*(_QWORD *)(v4 + 16) + 481) &= ~1u;
  }
  if ((*(_BYTE *)(a1 + 222) & 0xE) != 0)
  {
    v13 = *(_QWORD *)(v4 + 16);
    *(_BYTE *)(v13 + 480) = 3;
    *(_BYTE *)(v13 + 481) |= 1u;
    v14 = ((*(_DWORD *)(a1 + 220) >> 17) & 7) - 1;
    if (v14 > 6)
      v15 = 0;
    else
      v15 = dword_18475B0A4[v14];
    v16 = bswap32(v15);
    v7.i32[0] = v16;
    v7.i32[1] = v16 >> 8;
    v7.i32[2] = HIWORD(v16);
    v17.i64[0] = 0xFF000000FFLL;
    v17.i64[1] = 0xFF000000FFLL;
    v18 = (int32x4_t)vandq_s8(v7, v17);
    v18.i32[3] = vshrq_n_u32((uint32x4_t)vdupq_n_s32(v16), 0x18uLL).i32[3];
    *(float16x4_t *)(*(_QWORD *)(v4 + 16) + 8) = vcvt_f16_f32(vmulq_f32(vcvtq_f32_s32(v18), (float32x4_t)vdupq_n_s32(0x3B808081u)));
    v19 = *(CA::Shape **)(a1 + 64);
    v20 = 0;
    v21 = 0;
    CA::OGL::emit_combine(v4, 0, 0, 0, v19, (unsigned int *)&v20);
    *(_BYTE *)(*(_QWORD *)(v4 + 16) + 481) &= ~1u;
    *(_BYTE *)(*(_QWORD *)(v4 + 16) + 480) = *(_BYTE *)(a1 + 124);
  }
}

void CA::OGL::CompositeNode::~CompositeNode(CA::OGL::CompositeNode *this)
{
  abort();
}

uint64_t CA::OGL::CompositeNode::needs_surface(CA::OGL::CompositeNode *this, uint64_t a2)
{
  return a2;
}

uint64_t CA::OGL::CompositeNode::compute_dod(CA::OGL::CompositeNode *this, int32x2_t *a2)
{
  int32x2_t *v4;
  __int32 v5;
  __int32 v6;
  int32x2_t *v7;

  v4 = (int32x2_t *)*((_QWORD *)this + 3);
  v5 = v4[17].i32[0];
  if (v5 < 0)
  {
    (*(void (**)(_QWORD, int32x2_t *))(*(_QWORD *)v4 + 40))(*((_QWORD *)this + 3), v4 + 16);
    v5 = v4[17].i32[0];
  }
  *a2 = v4[16];
  v6 = v4[17].i32[1];
  a2[1].i32[0] = v5;
  a2[1].i32[1] = v6;
  v7 = (int32x2_t *)*((_QWORD *)this + 4);
  if (v7[17].i32[0] < 0)
    (*(void (**)(int32x2_t *, int32x2_t *))(*(_QWORD *)v7 + 40))(v7, v7 + 16);
  return CA::BoundsImpl::Union(a2, v7[16], v7[17]);
}

uint64_t CA::OGL::CompositeNode::propagate_roi(CA::OGL::CompositeNode *this, const CA::Bounds *a2)
{
  _QWORD v4[2];
  _QWORD v5[3];

  v5[2] = *MEMORY[0x1E0C80C00];
  v5[0] = 0;
  v5[1] = 0;
  v4[0] = 0;
  v4[1] = 0;
  (*(void (**)(_QWORD, _QWORD *))(**((_QWORD **)this + 3) + 56))(*((_QWORD *)this + 3), v5);
  return (*(uint64_t (**)(_QWORD, _QWORD *))(**((_QWORD **)this + 4) + 56))(*((_QWORD *)this + 4), v4);
}

void CA::OGL::TransitionNode::~TransitionNode(CA::OGL::TransitionNode *this)
{
  void *v1;
  malloc_zone_t *malloc_zone;

  *(_QWORD *)this = &off_1E1595088;
  v1 = (void *)*((_QWORD *)this + 29);
  if (v1)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v1);
  }
}

{
  void *v1;
  malloc_zone_t *malloc_zone;

  *(_QWORD *)this = &off_1E1595088;
  v1 = (void *)*((_QWORD *)this + 29);
  if (v1)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v1);
  }
  abort();
}

BOOL CA::OGL::TransitionNode::needs_surface(CA::Render::Transition **this, unsigned int a2, const CA::Render::TransitionSubclass *a3)
{
  return !CA::Render::Transition::subclass(this[28], a2, a3) && *((_QWORD *)this[28] + 4) != 0;
}

double CA::OGL::TransitionNode::compute_dod(CA::OGL::TransitionNode *this, CA::Bounds *a2)
{
  double result;

  result = -2.68156638e154;
  *(_OWORD *)a2 = xmmword_18474E240;
  return result;
}

uint64_t CA::OGL::TransitionNode::propagate_roi(CA::OGL::TransitionNode *this, const CA::Bounds *a2, double *a3)
{
  uint64_t v5;
  uint64_t v6;
  float64x2_t v7;
  int8x16_t v8;
  uint64_t v9;
  float64x2_t *v10;
  _UNKNOWN **v11;
  int32x4_t v12;
  int32x4_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int64x2_t v19;
  double v20;
  int8x16_t v21;
  double v22;
  const CA::Transform *v23;
  const double *v24;
  const double *v25;
  int8x16_t v26;
  int8x16_t v27;
  int32x4_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int32x4_t v31;
  __int32 v32;
  __int32 v33;
  int32x4_t v35;
  double v36;
  double v37;
  int8x16_t v38[2];
  int32x4_t v39;
  float64x2_t v40;
  float64x2_t v41;
  float64x2_t v42;
  float64x2_t v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v5 = *((_QWORD *)this + 2);
  v6 = *(_QWORD *)(v5 + 24);
  v7 = *(float64x2_t *)(v6 + 64);
  v8 = *(int8x16_t *)(v6 + 80);
  v38[0] = (int8x16_t)v7;
  v38[1] = v8;
  v9 = *(_QWORD *)(v5 + 16);
  v10 = *(float64x2_t **)(v9 + 56);
  if (v10)
    CA::Mat4Impl::mat4_apply_to_rect(v10, v38, a3);
  else
    v38[0] = (int8x16_t)vaddq_f64(*(float64x2_t *)(v9 + 64), v7);
  v11 = CA::Render::Transition::subclass(*((CA::Render::Transition **)this + 28), a2, (const CA::Render::TransitionSubclass *)a3);
  if (v11)
  {
    v14 = *((_QWORD *)this + 28);
    v15 = *((_QWORD *)this + 10);
    v16 = *((_DWORD *)a2 + 2);
    v17 = *((_DWORD *)a2 + 3);
    if (v16 <= v17)
      v18 = *((_DWORD *)a2 + 3);
    else
      v18 = *((_DWORD *)a2 + 2);
    v12.i32[0] = 1073741822;
    v13.i32[0] = v18;
    v19.i64[0] = (int)*(_QWORD *)a2;
    v19.i64[1] = (int)HIDWORD(*(_QWORD *)a2);
    v20 = (double)v16;
    v21 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v13, v12), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v19));
    v22 = (double)v17;
    if (v18 > 1073741822)
    {
      v20 = 1.79769313e308;
      v22 = 1.79769313e308;
    }
    v35 = (int32x4_t)v21;
    v36 = v20;
    v37 = v22;
    (*((void (**)(_UNKNOWN **, uint64_t, int8x16_t *, uint64_t, int32x4_t *, float64x2_t *, float64x2_t *))*v11
     + 3))(v11, v14, v38, v15, &v35, &v42, &v40);
    v23 = (const CA::Transform *)*((_QWORD *)this + 29);
    CA::Rect::unapply_transform((CA::Rect *)&v42, v23, v24);
    CA::Rect::unapply_transform((CA::Rect *)&v40, v23, v25);
    v26 = (int8x16_t)vceqzq_f64(v43);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v26, 1), v26).u64[0] & 0x8000000000000000) != 0
      || (v27 = vorrq_s8((int8x16_t)vcltzq_f64(v43), (int8x16_t)vcgezq_f64(v43)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v27), 1), v27).u64[0] & 0x8000000000000000) != 0))
    {
      v35 = 0uLL;
    }
    else
    {
      v28 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v42, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      v35 = vuzp1q_s32(v28, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v42, v43), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v28));
    }
    v29 = (int8x16_t)vceqzq_f64(v41);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v29, 1), v29).u64[0] & 0x8000000000000000) != 0
      || (v30 = vorrq_s8((int8x16_t)vcltzq_f64(v41), (int8x16_t)vcgezq_f64(v41)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v30), 1), v30).u64[0] & 0x8000000000000000) != 0))
    {
      v39 = 0uLL;
    }
    else
    {
      v31 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v40, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      v39 = vuzp1q_s32(v31, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v40, v41), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v31));
    }
  }
  else
  {
    v32 = *((_DWORD *)a2 + 1);
    v35.i32[0] = *(_DWORD *)a2;
    v35.i32[1] = v32;
    v33 = *((_DWORD *)a2 + 3);
    v35.i32[2] = *((_DWORD *)a2 + 2);
    v35.i32[3] = v33;
    v39.i32[0] = v35.i32[0];
    *(uint64_t *)((char *)v39.i64 + 4) = __PAIR64__(v35.u32[2], v32);
    v39.i32[3] = v33;
  }
  (*(void (**)(_QWORD, int32x4_t *))(**((_QWORD **)this + 3) + 56))(*((_QWORD *)this + 3), &v35);
  return (*(uint64_t (**)(_QWORD, int32x4_t *))(**((_QWORD **)this + 4) + 56))(*((_QWORD *)this + 4), &v39);
}

_UNKNOWN **CA::OGL::TransitionNode::apply(uint64_t a1, _QWORD *a2, double *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float64x2_t v8;
  int8x16_t v9;
  uint64_t v10;
  float64x2_t *v11;
  _UNKNOWN **result;
  _UNKNOWN **v13;
  int8x16_t v14[2];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 16);
  v6 = **(_QWORD **)(a1 + 8);
  v7 = *(_QWORD *)(v5 + 24);
  v8 = *(float64x2_t *)(v7 + 64);
  v9 = *(int8x16_t *)(v7 + 80);
  v14[0] = (int8x16_t)v8;
  v14[1] = v9;
  v10 = *(_QWORD *)(v5 + 16);
  v11 = *(float64x2_t **)(v10 + 56);
  if (v11)
    CA::Mat4Impl::mat4_apply_to_rect(v11, v14, a3);
  else
    v14[0] = (int8x16_t)vaddq_f64(*(float64x2_t *)(v10 + 64), v8);
  result = CA::Render::Transition::subclass(*(CA::Render::Transition **)(a1 + 224), a2, (const CA::Render::TransitionSubclass *)a3);
  if (result)
  {
    v13 = result;
    result = (_UNKNOWN **)(*((uint64_t (**)(_UNKNOWN **))*result + 4))(result);
    if ((_DWORD)result)
      return (_UNKNOWN **)(*((uint64_t (**)(_UNKNOWN **, _QWORD, uint64_t, int8x16_t *, _QWORD, _QWORD, _QWORD))*v13
                           + 5))(v13, *(_QWORD *)(a1 + 224), v6, v14, *(_QWORD *)(a1 + 232), *a2, a2[1]);
  }
  return result;
}

void CA::OGL::ShadowNode::~ShadowNode(CA::OGL::ShadowNode *this)
{
  abort();
}

void CA::OGL::MeshNode::~MeshNode(CA::OGL::MeshNode *this)
{
  abort();
}

uint64_t CA::OGL::MeshNode::mesh_node_p(CA::OGL::MeshNode *this)
{
  return 1;
}

void CA::CG::MetalDrawable::destroy(CA::CG::MetalDrawable *this)
{
  CA::CG::AccelDrawable::destroy((CGColorSpaceRef *)this);
  CFRelease(*((CFTypeRef *)this + 12));
}

void CA::CG::MetalDrawable::~MetalDrawable(CA::CG::MetalDrawable *this)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *(_QWORD *)this = &off_1E1591DB0;
  v2 = (unsigned int *)*((_QWORD *)this + 13);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 16))(v2);
  }
  *(_QWORD *)this = &off_1E1591B88;
  if (!*((_BYTE *)this + 70))
    __assert_rtn("~AccelDrawable", "cg-accel-drawable.cpp", 62, "_destroyed");
}

{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  malloc_zone_t *malloc_zone;

  *(_QWORD *)this = &off_1E1591DB0;
  v2 = (unsigned int *)*((_QWORD *)this + 13);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 16))(v2);
  }
  *(_QWORD *)this = &off_1E1591B88;
  if (!*((_BYTE *)this + 70))
    __assert_rtn("~AccelDrawable", "cg-accel-drawable.cpp", 62, "_destroyed");
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

uint64_t CA::CG::AccelDrawable::surface(CA::CG::AccelDrawable *this)
{
  return 0;
}

uint64_t CA::CG::MetalDrawable::texture(CA::CG::MetalDrawable *this)
{
  return *((_QWORD *)this + 12);
}

uint64_t CA::CG::MetalDrawable::needs_gpu(CA::CG::MetalDrawable *this)
{
  return 1;
}

uint64_t CA::CG::MetalDrawable::set_as_destination(CA::CG::MetalDrawable *this, CA::OGL::Context *a2, uint64_t a3)
{
  _QWORD v4[2];

  v4[1] = *MEMORY[0x1E0C80C00];
  v4[0] = *((_QWORD *)this + 12);
  (*(void (**)(CA::OGL::Context *, _QWORD, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 24))(a2, 0, v4, 1, 1, a3);
  return 1;
}

void CA::CG::MetalDrawable::retain_shared_texture(CA::CG::MetalDrawable *this@<X0>, CA::Render::MetalTexture **a2@<X8>)
{
  os_unfair_lock_s *v4;
  CA::Render::MetalTexture *v5;
  malloc_zone_t *malloc_zone;
  CA::Render::MetalTexture *v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;

  v4 = (os_unfair_lock_s *)((char *)this + 12);
  os_unfair_lock_lock((os_unfair_lock_t)this + 3);
  if (*((_BYTE *)this + 68))
  {
    v5 = 0;
  }
  else
  {
    v5 = (CA::Render::MetalTexture *)*((_QWORD *)this + 13);
    if (v5)
      goto LABEL_12;
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    v7 = (CA::Render::MetalTexture *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x70uLL, 0x743898A5uLL);
    v5 = v7;
    if (v7)
      v7 = CA::Render::MetalTexture::MetalTexture(v7, *((objc_object **)this + 12));
    CA::Render::Texture::set_colorspace(v7, *((CGColorSpace **)this + 3));
    v8 = (unsigned int *)*((_QWORD *)this + 13);
    *((_QWORD *)this + 13) = v5;
    if (v8)
    {
      v9 = v8 + 2;
      do
      {
        v10 = __ldaxr(v9);
        v11 = v10 - 1;
      }
      while (__stlxr(v11, v9));
      if (!v11)
        (*(void (**)(unsigned int *))(*(_QWORD *)v8 + 16))(v8);
      v5 = (CA::Render::MetalTexture *)*((_QWORD *)this + 13);
    }
    if (v5)
    {
LABEL_12:
      v12 = (unsigned int *)((char *)v5 + 8);
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 + 1, v12));
      if (!v13)
      {
        v5 = 0;
        do
          v14 = __ldaxr(v12);
        while (__stlxr(v14 - 1, v12));
      }
    }
  }
  *a2 = v5;
  os_unfair_lock_unlock(v4);
}

void CA::CG::MetalDrawable::mark_texture(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;

  v2 = this + 3;
  os_unfair_lock_lock(this + 3);
  v3 = *(_QWORD *)&this[26]._os_unfair_lock_opaque;
  if (v3)
  {
    v4 = (unsigned int *)(v3 + 36);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 + 1, v4));
  }
  os_unfair_lock_unlock(v2);
}

_QWORD *CA::CG::MetalDrawable::create_queue(CA::CG::MetalDrawable *this)
{
  malloc_zone_t *malloc_zone;
  _QWORD *result;

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  result = malloc_type_zone_malloc(malloc_zone, 0xD8uLL, 0x8BB15036uLL);
  if (result)
  {
    result = (_QWORD *)CA::CG::AccelQueue::AccelQueue((uint64_t)result, (uint64_t)this);
    *result = off_1E1591228;
  }
  return result;
}

uint64_t CA::CG::AccelDrawable::set_volatile_(CA::CG::AccelDrawable *this)
{
  return 0;
}

uint64_t CA::CG::AccelDrawable::is_purged_(CA::CG::AccelDrawable *this)
{
  return 0;
}

CGImageRef CA::CG::MetalDrawable::copy_cgimage(CA::CG::MetalDrawable *this)
{
  uint64_t v2;
  os_unfair_lock_s *v3;
  CGImageRef v4;
  uint64_t v5;
  malloc_zone_t *malloc_zone;
  _QWORD *v7;
  uint64_t v8;
  int v9;
  void *v10;
  uint64_t BytesPerRow;
  CGDataProvider *Direct;
  size_t v13;
  size_t v14;
  size_t v15;
  CGImageRef v16;
  size_t v17;
  size_t v18;
  size_t v19;
  CGImage *v20;
  CGFloat decode[3];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 9);
  if (v2)
    CA::CG::Queue::flush(v2, 3, 1);
  v3 = (os_unfair_lock_s *)((char *)this + 12);
  os_unfair_lock_lock((os_unfair_lock_t)this + 3);
  if (!*((_BYTE *)this + 68))
  {
    if (!*((_QWORD *)this + 10))
    {
      v5 = *((unsigned int *)this + 4);
      os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      v7 = malloc_type_zone_malloc(malloc_zone, 0x38uLL, 0x8BB15036uLL);
      if (v7)
      {
        v8 = *((_QWORD *)this + 9);
        if (v8
          || (v8 = (*(uint64_t (**)(CA::CG::MetalDrawable *))(*(_QWORD *)this + 72))(this),
              (*((_QWORD *)this + 9) = v8) != 0))
        {
          v9 = *(_DWORD *)(v8 + 48);
        }
        else
        {
          v9 = 0;
        }
        CA::CG::AccelDataProvider::AccelDataProvider((uint64_t)v7, (uint64_t)this, v9);
        *v7 = &off_1E1592B28;
      }
      v10 = (void *)*((_QWORD *)this + 12);
      BytesPerRow = CAMetalTextureGetBytesPerRow(v10);
      Direct = CGDataProviderCreateDirect(v7, objc_msgSend(v10, "height") * BytesPerRow, &CA::CG::AccelDataProvider::callbacks(void)::vtable);
      v13 = *((unsigned int *)this + 13);
      v14 = *((unsigned int *)this + 14);
      if ((_DWORD)v5 == 9)
      {
        v15 = CAMetalTextureGetBytesPerRow(*((void **)this + 12));
        *(_OWORD *)decode = xmmword_18474DF40;
        v16 = CGImageMaskCreate(v13, v14, 8uLL, 8uLL, v15, Direct, decode, 1);
      }
      else
      {
        if (v5 > 0x23)
        {
          v17 = 0;
          v18 = 0;
        }
        else
        {
          v17 = dword_184750518[v5];
          v18 = dword_1847503F0[v5];
        }
        v19 = CAMetalTextureGetBytesPerRow(*((void **)this + 12));
        v16 = CGImageCreate(v13, v14, v17, v18, v19, *((CGColorSpaceRef *)this + 3), *((_DWORD *)this + 8), Direct, 0, 1, kCGRenderingIntentDefault);
      }
      v20 = v16;
      CGDataProviderRelease(Direct);
      if (v20)
      {
        CA::CG::AccelDataProvider::set_image((CA::CG::AccelDataProvider *)v7, v20);
        os_unfair_lock_lock((os_unfair_lock_t)this + 3);
        if (!*((_QWORD *)this + 10))
        {
          *((_QWORD *)this + 10) = v20;
          goto LABEL_22;
        }
        os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
        CGImageRelease(v20);
      }
      os_unfair_lock_lock((os_unfair_lock_t)this + 3);
    }
LABEL_22:
    v4 = CGImageRetain(*((CGImageRef *)this + 10));
    goto LABEL_23;
  }
  v4 = 0;
LABEL_23:
  os_unfair_lock_unlock(v3);
  return v4;
}

CGImageRef CA::CG::MetalDrawable::copy_cgimage_mtl(CA::CG::MetalDrawable *this)
{
  uint64_t v3;
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t v6;
  CFDictionaryRef v7;

  if (*((_DWORD *)this + 4) == 9)
    return CA::CG::MetalDrawable::copy_cgimage(this);
  v3 = *((_QWORD *)this + 9);
  if (v3)
    CA::CG::Queue::flush(v3, 3, 1);
  v4 = (os_unfair_lock_s *)((char *)this + 12);
  os_unfair_lock_lock((os_unfair_lock_t)this + 3);
  if (*((_BYTE *)this + 68))
  {
    v5 = 0;
  }
  else
  {
    v5 = *((_QWORD *)this + 12);
    if (v5)
    {
      v6 = *((_QWORD *)this + 3);
      CFRetain(*((CFTypeRef *)this + 12));
      v7 = CFDictionaryCreate(0, MEMORY[0x1E0C9DAF0], MEMORY[0x1E0C9AE50], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (!v6)
        CAGetColorSpace(0x1Du);
      CGImageProviderCreate();
      CFRelease(v7);
      v5 = CGImageCreateWithImageProvider();
      CGImageProviderRelease();
    }
    CGImageSetProperty();
  }
  os_unfair_lock_unlock(v4);
  return (CGImageRef)v5;
}

void CA::Render::String::show(CA::Render::String *this)
{
  NSObject *v2;
  uint8_t buf[4];
  char *v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    v2 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      v4 = (char *)this + 28;
      _os_log_impl(&dword_184457000, v2, OS_LOG_TYPE_DEFAULT, "\"%s\"", buf, 0xCu);
    }
  }
}

uint64_t CA::Render::String::unsafe_cf_string(CA::Render::String *this)
{
  uint64_t result;
  unint64_t *v3;
  CFStringRef v4;

  v3 = (unint64_t *)((char *)this + 16);
  result = *((_QWORD *)this + 2);
  if (!result)
  {
    v4 = CFStringCreateWithCStringNoCopy(0, (const char *)this + 28, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    while (!__ldaxr(v3))
    {
      if (!__stlxr((unint64_t)v4, v3))
        return *v3;
    }
    __clrex();
    CFRelease(v4);
    return *v3;
  }
  return result;
}

void sub_1846A1BB0(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1846A1D4C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void layer_private_present(_CAMetalLayerPrivate *a1, CAMetalDrawable *a2, double a3, double a4, unsigned int a5)
{
  _CAMetalDrawablePrivate *v9;
  _CAMetalDrawablePrivate *v10;
  double v11;
  double v12;
  uint64_t v13;
  uint64_t v14;
  IOSurfaceSharedEvent *v15;
  IOSurfaceSharedEvent *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  NSObject *v23;
  _QWORD v24[7];
  unsigned int v25;
  uint8_t buf[4];
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v9 = -[CAMetalDrawable priv](a2, "priv");
  if (!v9 || (v10 = v9, (*((_BYTE *)v9 + 113) & 0x20) != 0))
  {
    if (warn_multiple_present(void)::once[0] != -1)
      dispatch_once(warn_multiple_present(void)::once, &__block_literal_global_453);
  }
  else
  {
    if (MEMORY[0x1E0D227C0])
    {
      -[CAMetalDrawable layer](a2, "layer");
      -[CAMetalDrawable drawableID](a2, "drawableID");
      FPDrawableLifetimeMarkClientDidPresent();
    }
    -[CAMetalDrawable targetSamplingTimestamp](a2, "targetSamplingTimestamp");
    if (v11 == 0.0)
    {
      v12 = a3;
    }
    else
    {
      v12 = v11;
      a5 &= ~2u;
      v13 = *(_QWORD *)(*((_QWORD *)a1 + 2) + 48);
      if (v13)
      {
        v14 = *(_QWORD *)(v13 + 24);
        *(_QWORD *)(v14 + 296) = 0;
        *(double *)(v14 + 304) = v11;
        __dmb(0xBu);
      }
    }
    *((_BYTE *)v10 + 113) |= 0x20u;
    v15 = -[CAMetalDrawable sharedEvent](a2, "sharedEvent");
    v16 = v15;
    if (((*((_WORD *)a1 + 144) & 0x20) == 0 || *((_QWORD *)a1 + 4))
      && (v17 = *(_QWORD *)(*((_QWORD *)a1 + 2) + 48)) != 0
      && (v18 = atomic_load((unint64_t *)(*(_QWORD *)(v17 + 24) + 8)), (v18 & 0x8000000000000000) != 0)
      && v15)
    {
      v19 = -[CAMetalDrawable drawableID](a2, "drawableID");
      v20 = IOSurfaceSignalEvent();
      if (v20)
      {
        v22 = v20;
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          v23 = x_log_category_api;
          if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            v27 = v22;
            _os_log_impl(&dword_184457000, v23, OS_LOG_TYPE_ERROR, "IOSurfaceSignalEvent err=0x%x", buf, 8u);
          }
        }
        layer_private_present_impl(a1, a2, v12, a5);
      }
      else
      {
        v21 = *((_QWORD *)a1 + 20);
        v24[0] = MEMORY[0x1E0C809B0];
        v24[1] = 3221225472;
        v24[2] = ___ZL21layer_private_presentP20_CAMetalLayerPrivateP15CAMetalDrawableddj_block_invoke;
        v24[3] = &unk_1E15A7248;
        v24[4] = a2;
        v24[5] = a1;
        *(double *)&v24[6] = v12;
        v25 = a5;
        -[IOSurfaceSharedEvent notifyListener:atValue:block:](v16, "notifyListener:atValue:block:", v21, v19, v24);
      }
    }
    else
    {
      layer_private_present_impl(a1, a2, v12, a5);
    }
  }
}

void ___ZL21layer_private_presentP20_CAMetalLayerPrivateP15CAMetalDrawableddj_block_invoke(uint64_t a1)
{
  layer_private_present_impl(*(_CAMetalLayerPrivate **)(a1 + 40), *(CAMetalDrawable **)(a1 + 32), *(double *)(a1 + 48), *(_DWORD *)(a1 + 56));
}

void release_sample(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char *v4;
  _QWORD *v5;
  char v6;
  char v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  unint64_t v14;
  const void *v15;
  CGColorSpace *v16;
  uint64_t v17;
  malloc_zone_t *malloc_zone;
  _QWORD *v19;

  v4 = (char *)pthread_getspecific(collect_slot);
  if (release_key && (v5 = pthread_getspecific(release_key)) != 0)
  {
    v6 = *(_BYTE *)(a3 + 113) & 0xCF;
    *(_BYTE *)(a3 + 113) = v6;
    if (v4 && *((_DWORD *)v5 + 14))
    {
      *((_QWORD *)v4 + 33) = v5[12];
      v6 = *(_BYTE *)(a3 + 113) & 0xEF;
    }
    v7 = v6 | (16 * *((_BYTE *)v5 + 74));
  }
  else
  {
    v7 = *(_BYTE *)(a3 + 113) & 0xCF;
  }
  *(_BYTE *)(a3 + 113) = v7;
  do
  {
    v8 = __ldaxr((unsigned int *)a3);
    v9 = v8 - 1;
  }
  while (__stlxr(v9, (unsigned int *)a3));
  if (!v9)
  {
    if (v4)
    {
      v10 = *((_QWORD *)v4 + 25);
      v11 = CAHostTimeWithTime(0.2) + v10;
      v12 = mach_absolute_time();
      if (*((_QWORD *)v4 + 4) || (*((_WORD *)v4 + 144) & 0x10) != 0)
        v13 = (unsigned int *)(v4 + 136);
      else
        v13 = (unsigned int *)(v4 + 132);
      v14 = *v13;
      if (v12 > v11)
        ++v14;
      if (v14 >= *((unsigned int *)v4 + 32))
      {
        v17 = *((_QWORD *)v4 + 7);
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        v19 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
        *v19 = a3;
        v19[1] = v17;
        *((_QWORD *)v4 + 7) = v19;
      }
      else
      {
        release_drawable((_CAMetalLayerPrivate *)v4, (_CAMetalDrawablePrivate *)a3);
      }
    }
    else
    {
      v15 = *(const void **)(a3 + 64);
      if (v15)
        CFRelease(v15);

      *(_QWORD *)(a3 + 72) = 0;
      v16 = *(CGColorSpace **)(a3 + 88);
      if (v16)
      {
        CGColorSpaceRelease(v16);
        *(_QWORD *)(a3 + 88) = 0;
      }

      free((void *)a3);
    }
  }
}

uint64_t mark_drawable_finish(CAMetalDrawable *a1, _CAMetalLayerPrivate *a2, int a3, double a4)
{
  uint64_t result;
  double v9;
  void *v10;
  void *v11;
  double v12;
  double v13;
  void *v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;

  -[CAMetalDrawable setDidFinish:](a1, "setDidFinish:", 1);
  result = -[CAMetalDrawable targetPresentationTimestamp](a1, "targetPresentationTimestamp");
  if (v9 != 0.0)
  {
    v10 = (void *)MEMORY[0x1E0CB37E8];
    -[CAMetalDrawable targetTimestamp](a1, "targetTimestamp");
    objc_msgSend(v10, "numberWithDouble:");
    v11 = (void *)MEMORY[0x1E0CB37E8];
    -[CAMetalDrawable targetSamplingTimestamp](a1, "targetSamplingTimestamp");
    objc_msgSend(v11, "numberWithDouble:");
    -[CAMetalDrawable minimumPresentationDuration](a1, "minimumPresentationDuration");
    v13 = v12;
    v14 = (void *)MEMORY[0x1E0CB37E8];
    -[CAMetalDrawable targetPresentationTimestamp](a1, "targetPresentationTimestamp");
    v16 = v15;
    if (v13 != 0.0)
    {
      v17 = *((double *)a2 + 37);
      -[CAMetalDrawable minimumPresentationDuration](a1, "minimumPresentationDuration");
      if (v16 <= v18 + v17)
      {
        v20 = *((double *)a2 + 37);
        -[CAMetalDrawable minimumPresentationDuration](a1, "minimumPresentationDuration");
        v16 = v21 + v20;
      }
      else
      {
        -[CAMetalDrawable targetPresentationTimestamp](a1, "targetPresentationTimestamp");
        v16 = v19;
      }
    }
    result = objc_msgSend(v14, "numberWithDouble:", v16);
  }
  if (MEMORY[0x1E0D227C8])
  {
    -[CAMetalDrawable layer](a1, "layer");
    -[CAMetalDrawable drawableID](a1, "drawableID");
    -[CAMetalDrawable hasExplicitDeadlines](a1, "hasExplicitDeadlines");
    result = FPDrawableLifetimeMarkFinished();
  }
  if (a3)
    *((double *)a2 + 37) = a4;
  return result;
}

void layer_collectable_signal(uint64_t a1, _CAMetalLayerPrivate *a2)
{
  unsigned int *v4;
  unsigned int v5;
  uint64_t v6;

  v4 = (unsigned int *)((char *)a2 + 152);
  do
    v5 = __ldaxr(v4);
  while (__stlxr(2u, v4));
  if (v5 == 1)
    dispatch_semaphore_signal(*((dispatch_semaphore_t *)a2 + 18));
  if (a1)
  {
    v6 = *(_QWORD *)(a1 + 48);
    if (!v6 || !*(_DWORD *)(*(_QWORD *)(v6 + 24) + 32))
      layer_private_cleanup_callbacks(a2);
  }
  if (*((_QWORD *)a2 + 4))
  {
    if (CAMetalLayerShouldDispatchLink(*((CAMetalLayer **)a2 + 3)))
      +[CADisplayLink dispatchDeferredDisplayLink:](CADisplayLink, "dispatchDeferredDisplayLink:", *((_QWORD *)a2 + 4));
  }
}

BOOL CAMetalLayerShouldDispatchLink(CAMetalLayer *a1)
{
  unsigned int *priv;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v7[2];

  v7[1] = *MEMORY[0x1E0C80C00];
  priv = (unsigned int *)a1->_priv;
  os_unfair_lock_lock((os_unfair_lock_t)priv + 2);
  if (*((_QWORD *)priv + 9))
  {
    v7[0] = 0;
    v3 = priv[34];
    v4 = priv[35];
    CAMetalLayerPrivateNextDrawableLocked(a1, 0, v7);
    if (v7[0] >= 5 - v3)
      v7[0] -= 5 - v3;
    os_unfair_lock_lock((os_unfair_lock_t)priv + 52);
    os_unfair_lock_lock((os_unfair_lock_t)priv + 46);
    objc_msgSend(*((id *)priv + 27), "count");
    objc_msgSend(*((id *)priv + 24), "count");
    os_unfair_lock_unlock((os_unfair_lock_t)priv + 46);
    os_unfair_lock_unlock((os_unfair_lock_t)priv + 52);
    v5 = v7[0];
    kdebug_trace();
    os_unfair_lock_unlock((os_unfair_lock_t)priv + 2);
    if (v5 != v4)
    {
      if (!(_DWORD)v4)
        return 1;
      if ((_DWORD)v4 == 1)
        return (~*((unsigned __int8 *)a1->_priv + 232) & 3) == 0;
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)priv + 2);
  }
  return 0;
}

void sub_1846A2DA4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void layer_private_set_drawable_size_internal(_CAMetalLayerPrivate *a1, int a2, int a3)
{
  unsigned int *v3;
  unsigned int v4;

  *((_DWORD *)a1 + 30) = a2;
  *((_DWORD *)a1 + 31) = a3;
  v3 = (unsigned int *)((char *)a1 + 4);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 | 1, v3));
  CAImageQueueSetSize(*((os_unfair_lock_s **)a1 + 2), *((_DWORD *)a1 + 30), *((_DWORD *)a1 + 31));
  if (MEMORY[0x1E0D227F0])
    FPMetalLayerMarkSetSize();
}

void release_drawable(_CAMetalLayerPrivate *a1, _CAMetalDrawablePrivate *a2)
{
  uint64_t v4;
  unint64_t var5;
  __IOSurface *var10;
  CGColorSpace *var13;

  if (a2)
  {
    v4 = *((_QWORD *)a1 + 2);
    if (v4)
    {
      var5 = a2->var5;
      if (var5)
        CAImageQueueUnregisterBuffer(v4, var5);
    }
    var10 = a2->var10;
    if (var10)
      CFRelease(var10);

    a2->var11 = 0;
    var13 = a2->var13;
    if (var13)
    {
      CGColorSpaceRelease(var13);
      a2->var13 = 0;
    }

    free(a2);
  }
  --*((_DWORD *)a1 + 32);
}

void ___ZL21warn_multiple_presentv_block_invoke()
{
  NSLog(CFSTR("Each CAMetalLayerDrawable can only be presented once!"));
}

void layer_private_memory_warning(CA::Render::Object *a1, os_unfair_lock_s *a2, void *a3)
{
  if (a2)
    layer_private_flush_backbuffers(a2);
}

void drawable_purgeable_callback(CA::Render::Object *a1, char *a2, void *a3)
{
  os_unfair_lock_s *v4;
  _QWORD *i;
  uint64_t v6;
  __IOSurface *v7;
  uint32_t oldState;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v4 = (os_unfair_lock_s *)(a2 + 8);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 2);
  pthread_setspecific(collect_slot, a2);
  CAImageQueueCollect_(*((_QWORD *)a2 + 2), 0, 0);
  pthread_setspecific(collect_slot, 0);
  for (i = (_QWORD *)*((_QWORD *)a2 + 7); i; i = (_QWORD *)i[1])
  {
    v6 = *i;
    *(_BYTE *)(v6 + 113) = *(_BYTE *)(*i + 113) | 0x40;
    v7 = *(__IOSurface **)(v6 + 64);
    oldState = 0;
    IOSurfaceSetPurgeable(v7, 1u, &oldState);
  }
  os_unfair_lock_unlock(v4);
}

void sub_1846A36F8(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void layer_presented(_CAImageQueue *a1, unsigned int a2, double a3, double a4, double a5, char *a6)
{
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  void *v14;
  unsigned int v15;
  uint64_t v16;
  double v17;
  uint64_t v18;
  CAMetalDrawable *v19;
  os_signpost_id_t v20;
  unsigned int v21;
  uint64_t v23;
  uint64_t v24;
  double v25;
  unint64_t v26;
  unint64_t v27;
  double v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  uint64_t *v40;
  NSObject *v41;
  unsigned int v42;
  _CAMetalLayerPrivate *v43;
  char v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  double v48;
  unint64_t v49;
  double v50;
  unint64_t v51;
  double v52;
  unsigned int v53;
  float v54;
  uint64_t v55;
  os_unfair_lock_s *lock;
  unint64_t v57;
  uint64_t v58;
  id obj;
  uint64_t v60;
  unsigned int v61;
  uint64_t v62;
  _CAMetalLayerPrivate *v63;
  uint8_t buf[8];
  _BYTE v65[10];
  __int16 v66;
  uint64_t v67;
  __int16 v68;
  uint64_t v69;
  __int16 v70;
  uint64_t v71;
  __int16 v72;
  double v73;
  __int16 v74;
  uint64_t v75;
  __int16 v76;
  uint64_t v77;
  _BYTE v78[128];
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  _BYTE v83[128];
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  uint64_t v88;

  v88 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)a6 + 28) = mach_absolute_time();
  obj = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  lock = (os_unfair_lock_s *)(a6 + 208);
  os_unfair_lock_lock((os_unfair_lock_t)a6 + 52);
  v86 = 0u;
  v87 = 0u;
  v84 = 0u;
  v85 = 0u;
  v63 = (_CAMetalLayerPrivate *)a6;
  v10 = (void *)*((_QWORD *)a6 + 27);
  v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v84, v83, 16);
  if (v11)
  {
    v12 = *(_QWORD *)v85;
    do
    {
      for (i = 0; i != v11; ++i)
      {
        if (*(_QWORD *)v85 != v12)
          objc_enumerationMutation(v10);
        v14 = *(void **)(*((_QWORD *)&v84 + 1) + 8 * i);
        if (!objc_msgSend(v14, "didComposite"))
        {
          if (a2)
            continue;
LABEL_11:
          objc_msgSend(obj, "addObject:", v14);
          continue;
        }
        v15 = objc_msgSend(v14, "updateSeed");
        if (!a2 || v15 <= a2)
          goto LABEL_11;
      }
      v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v84, v83, 16);
    }
    while (v11);
  }
  if (objc_msgSend(obj, "count"))
    objc_msgSend(*((id *)v63 + 27), "removeObjectsInArray:", obj);
  v61 = a2;
  v81 = 0u;
  v82 = 0u;
  v79 = 0u;
  v80 = 0u;
  v16 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v79, v78, 16);
  if (v16)
  {
    v60 = *(_QWORD *)v80;
    v17 = a5 + 0.001;
    do
    {
      v18 = 0;
      v62 = v16;
      do
      {
        if (*(_QWORD *)v80 != v60)
          objc_enumerationMutation(obj);
        v19 = *(CAMetalDrawable **)(*((_QWORD *)&v79 + 1) + 8 * v18);
        v20 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v63 + 2) + 48) + 24) + 88);
        v21 = -[CAMetalDrawable updateSeed](v19, "updateSeed");
        if (a3 <= 0.0 || v21 != v61)
        {
          -[CAMetalDrawable setStatus:](v19, "setStatus:", 3);
          mark_drawable_finish(v19, v63, 0, a3);
          goto LABEL_45;
        }
        -[CAMetalDrawable setStatus:](v19, "setStatus:", 2);
        -[CAMetalDrawable setPresentedTime:](v19, "setPresentedTime:", a3);
        *(_QWORD *)buf = 0;
        *(_QWORD *)v65 = 0;
        mach_get_times();
        v23 = *(_QWORD *)buf;
        v24 = *(_QWORD *)v65;
        -[CAMetalDrawable timeAcquired](v19, "timeAcquired");
        v26 = CAHostTimeWithTime(v25);
        v27 = CAHostTimeWithTime(a3);
        -[CAMetalDrawable timePresentCalled](v19, "timePresentCalled");
        v29 = CAHostTimeWithTime(v28);
        -[CAMetalDrawable targetTimestamp](v19, "targetTimestamp");
        v30 = v24 - v23;
        v31 = v26 + v30;
        v32 = v27 + v30;
        v33 = v29 + v30;
        if (v34 != 0.0)
        {
          -[CAMetalDrawable timePresentCalled](v19, "timePresentCalled");
          v36 = v35;
          -[CAMetalDrawable presentDeadline](v19, "presentDeadline");
          v38 = v37;
          -[CAMetalDrawable targetPresentationTimestamp](v19, "targetPresentationTimestamp");
          if (v36 > v38 || v17 + v39 < a3)
          {
            if (CAMetalLayerStallLog(void)::onceToken[0] != -1)
              dispatch_once(CAMetalLayerStallLog(void)::onceToken, &__block_literal_global_459);
            v40 = &CAMetalLayerStallLog(void)::log;
          }
          else
          {
            if (CAMetalLayerLog(void)::onceToken != -1)
              dispatch_once(&CAMetalLayerLog(void)::onceToken, &__block_literal_global_456);
            v40 = &CAMetalLayerLog(void)::log;
          }
          v45 = *v40;
          -[CAMetalDrawable targetTimestamp](v19, "targetTimestamp");
          v46 = v32;
          v47 = v26 + v30;
          v49 = CAHostTimeWithTime(v48);
          -[CAMetalDrawable targetSamplingTimestamp](v19, "targetSamplingTimestamp");
          v51 = CAHostTimeWithTime(v50);
          -[CAMetalDrawable targetPresentationTimestamp](v19, "targetPresentationTimestamp");
          v58 = v46;
          v57 = CAHostTimeWithTime(v52);
          if ((_DWORD)v20 && os_signpost_enabled(v45))
          {
            v53 = -[CAMetalDrawable surfaceID](v19, "surfaceID");
            -[CAMetalDrawable clientPreferredLatency](v19, "clientPreferredLatency");
            *(_DWORD *)buf = 67241984;
            *(_DWORD *)&buf[4] = v53;
            *(_WORD *)v65 = 2050;
            *(_QWORD *)&v65[2] = v33;
            v66 = 2050;
            v67 = v49 + v30;
            v68 = 2050;
            v69 = v51 + v30;
            v70 = 2050;
            v71 = v57 + v30;
            v72 = 2050;
            v73 = v54;
            v74 = 2050;
            v75 = v47;
            v76 = 2050;
            v77 = v58;
            _os_signpost_emit_with_name_impl(&dword_184457000, v45, OS_SIGNPOST_EVENT, v20, "DrawableLifetime", "ID is queue ID.\n\tsurfaceID=%{public, name=surfaceID}#x\n\ttimePresentCalled=%{public, name=timePresentCalled}llu\n\ttargetTimestamp=%{public, name=targetTimestamp}llu\n\ttargetSamplingTimestamp=%{public, name=targetSamplingTimestamp}llu\n\ttargetPresentationTimestamp=%{public, name=targetPresentationTimestamp}llu\n\tpreferredLatency=%{public, name=preferredLatency}g\n\tbeginTime=%{public, signpost.description:begin_time}llu\n\tendTime=%{public, signpost.description:end_time}llu\n", buf, 0x4Eu);
          }
          v43 = v63;
          v44 = (v36 <= v38) | (2 * *((_BYTE *)v63 + 232));
          goto LABEL_44;
        }
        if (CAMetalLayerLog(void)::onceToken == -1)
        {
          if ((_DWORD)v20)
            goto LABEL_34;
        }
        else
        {
          dispatch_once(&CAMetalLayerLog(void)::onceToken, &__block_literal_global_456);
          if ((_DWORD)v20)
          {
LABEL_34:
            v41 = CAMetalLayerLog(void)::log;
            if (os_signpost_enabled((os_log_t)CAMetalLayerLog(void)::log))
            {
              v42 = -[CAMetalDrawable surfaceID](v19, "surfaceID");
              *(_DWORD *)buf = 67240960;
              *(_DWORD *)&buf[4] = v42;
              *(_WORD *)v65 = 2050;
              *(_QWORD *)&v65[2] = v29 + v30;
              v66 = 2050;
              v67 = v31;
              v68 = 2050;
              v69 = v32;
              _os_signpost_emit_with_name_impl(&dword_184457000, v41, OS_SIGNPOST_EVENT, v20, "DrawableLifetime", "ID is queue ID.\n\tsurfaceID=%{public, name=surfaceID}#x\n\ttimePresentCalled=%{public, name=timePresentCalled}llu\n\tbeginTime=%{public, signpost.description:begin_time}llu\n\tendTime=%{public, signpost.description:end_time}llu\n", buf, 0x26u);
            }
          }
        }
        v43 = v63;
        v44 = (2 * *((_BYTE *)v63 + 232)) | 1;
LABEL_44:
        *((_BYTE *)v43 + 232) = v44;
        mark_drawable_finish(v19, v43, 1, a3);
LABEL_45:
        -[CAMetalDrawable drawableID](v19, "drawableID");
        -[CAMetalDrawable status](v19, "status");
        kdebug_trace();
        -[CAMetalDrawable didPresentAtTime:](v19, "didPresentAtTime:", a3);
        kdebug_trace();
        ++v18;
      }
      while (v62 != v18);
      v55 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v79, v78, 16);
      v16 = v55;
    }
    while (v55);
  }
  os_unfair_lock_unlock(lock);

  if (*((_QWORD *)v63 + 4))
  {
    if (CAMetalLayerShouldDispatchLink(*((CAMetalLayer **)v63 + 3)))
      +[CADisplayLink dispatchDeferredDisplayLink:](CADisplayLink, "dispatchDeferredDisplayLink:", *((_QWORD *)v63 + 4));
  }
}

void sub_1846A3D20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_unfair_lock_t lock)
{
  os_unfair_lock_unlock(lock);
  _Unwind_Resume(a1);
}

void layer_private_flush_backbuffers(os_unfair_lock_s *a1)
{
  os_unfair_lock_s *v2;

  v2 = a1 + 2;
  os_unfair_lock_lock(a1 + 2);
  layer_private_flush_async((_CAMetalLayerPrivate *)a1);
  os_unfair_lock_unlock(v2);
}

void sub_1846A3DF4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1846A3EA8(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1846A41A4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1846A4238(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void CAMetalLayerSetMetalLinkToken(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  os_unfair_lock_s *v4;
  uint64_t v5;
  int *v6;
  char v7;
  int *v8;
  uint64_t v9;

  v3 = *(_QWORD *)(a1 + 32);
  v4 = (os_unfair_lock_s *)(v3 + 8);
  os_unfair_lock_lock((os_unfair_lock_t)(v3 + 8));
  *(_QWORD *)(v3 + 32) = a2;
  if (a2)
  {
    v6 = *(int **)(v3 + 16);
    v5 = v3 + 16;
    CAImageQueueSetFlagsInternal(v6, 0x60000000050000, 0x20000000050000);
    v7 = 5 - *(_BYTE *)(v5 + 120);
  }
  else
  {
    v8 = *(int **)(v3 + 16);
    v5 = v3 + 16;
    CAImageQueueSetFlagsInternal(v8, 0x60000000050000, (unint64_t)(*(_DWORD *)(v5 + 116) == 2) << 54);
    v7 = 2;
  }
  v9 = *(_QWORD *)(*(_QWORD *)v5 + 48);
  if (v9)
    *(_BYTE *)(*(_QWORD *)(v9 + 24) + 95) = v7;
  os_unfair_lock_unlock(v4);
}

uint64_t CA::point_inside_quad(double *a1, double a2, double a3)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  _BOOL4 v15;

  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v6 = (v3 - v5) * (a2 - *a1) + (v4 - *a1) * (a3 - v3);
  v7 = a1[4];
  v8 = a1[5];
  v9 = (v5 - v8) * (a2 - v4) + (v7 - v4) * (a3 - v5);
  v10 = a1[6];
  v11 = a1[7];
  v12 = (v8 - v11) * (a2 - v7) + (v10 - v7) * (a3 - v8);
  v13 = (v11 - v3) * (a2 - v10) + (a3 - v11) * (*a1 - v10);
  if (v6 <= 0.0 && v9 <= 0.0 && v12 <= 0.0 && v13 <= 0.0)
    return 1;
  v15 = v6 >= 0.0;
  if (v9 < 0.0)
    v15 = 0;
  if (v12 < 0.0)
    v15 = 0;
  return v13 >= 0.0 && v15;
}

void CA::Rect::unapply_inverse_transform(int8x16_t *this, float64x2_t *a2, double *a3)
{
  if ((LOBYTE(a2[9].f64[0]) & 0x10) != 0)
    CA::Mat4Impl::mat4_unapply_inverse_to_rect(a2, this, a3);
  else
    CA::Rect::apply_transform(this, (const CA::Transform *)a2, a3);
}

uint64_t CA::BoundsImpl::Union(int32x2_t *a1, int32x2_t a2, int32x2_t a3)
{
  int32x2_t v3;
  uint32x2_t v4;
  uint32x2_t v5;
  unsigned __int32 v6;
  int32x2_t v7;

  v3 = a1[1];
  v4 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v3);
  v5 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, a3);
  v6 = vpmax_u32(v5, v5).u32[0];
  if ((vpmax_u32(v4, v4).u32[0] & 0x80000000) == 0)
  {
    if ((v6 & 0x80000000) != 0)
      return 1;
    v7 = vadd_s32(a2, a3);
    a2 = vmin_s32(*a1, a2);
    a3 = vsub_s32(vmax_s32(vadd_s32(*a1, v3), v7), a2);
LABEL_5:
    *a1 = a2;
    a1[1] = a3;
    return 1;
  }
  if ((v6 & 0x80000000) == 0)
    goto LABEL_5;
  return 0;
}

double *CA::BoundsImpl::inset_point(double *result, double a2, double a3)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;

  v4 = result[2];
  v3 = result[3];
  if (v4 <= v3)
    v5 = result[3];
  else
    v5 = result[2];
  if (v5 < 1.79769313e308)
  {
    v6 = result[1] + a3;
    *result = *result + a2;
    result[1] = v6;
    v7 = v4 - a2 * 2.0;
    v8 = v3 - a3 * 2.0;
    result[2] = v7;
    result[3] = v8;
    if (v7 <= 0.0 || v8 <= 0.0)
    {
      result[2] = 0.0;
      result[3] = 0.0;
    }
  }
  return result;
}

double *CA::BoundsImpl::set_points(double *this, double *a2, const double *a3)
{
  double v3;
  double v4;
  char *v5;
  double *v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;

  v3 = *a2;
  v4 = a2[1];
  if ((unint64_t)a3 >= 2)
  {
    v5 = (char *)a3 - 1;
    v6 = a2 + 3;
    v7 = a2[1];
    v8 = *a2;
    while (1)
    {
      v9 = *(v6 - 1);
      v10 = v9 > v3 ? *(v6 - 1) : v3;
      if (v9 >= v8)
        v3 = v10;
      else
        v8 = *(v6 - 1);
      v11 = *v6;
      if (*v6 < v7)
        break;
      if (v11 <= v4)
        goto LABEL_12;
LABEL_13:
      v6 += 2;
      v4 = v11;
      if (!--v5)
        goto LABEL_16;
    }
    v7 = *v6;
LABEL_12:
    v11 = v4;
    goto LABEL_13;
  }
  v8 = *a2;
  v7 = a2[1];
  v11 = v7;
LABEL_16:
  v12 = v3 - v8;
  v13 = v11 - v7;
  if (COERCE_UNSIGNED_INT64(fabs(v11 - v7 + v12)) >= 0x7FF0000000000000)
  {
    v12 = 1.79769313e308;
    v8 = -8.98846567e307;
    v7 = -8.98846567e307;
    v13 = 1.79769313e308;
  }
  *this = v8;
  this[1] = v7;
  this[2] = v12;
  this[3] = v13;
  return this;
}

void CA::CG::ClipImage::~ClipImage(CA::CG::Renderer **this, const void *a2)
{
  *this = (CA::CG::Renderer *)off_1E1593AE0;
  CA::CG::Renderer::release_object(this[1], a2);
}

{
  malloc_zone_t *malloc_zone;

  *this = (CA::CG::Renderer *)off_1E1593AE0;
  CA::CG::Renderer::release_object(this[1], a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

uint64_t CA::CG::ClipImage::type(CA::CG::ClipImage *this)
{
  return 6;
}

uint64_t CA::CG::ClipItem::prepare(CA::CG::ClipItem *this, CA::CG::Renderer *a2, const CA::CG::DrawOp *a3, CA::CG::ClipOp *a4)
{
  return 2;
}

__n128 CA::CG::ClipImage::draw(CA::CG::ClipImage *this, CA::CG::Renderer *a2, double a3, int64x2_t a4, int64x2_t a5)
{
  int8x16_t v5;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  double v9;
  double v10;
  float64x2_t v11;
  __n128 result;
  _OWORD v13[3];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  a4.i64[0] = (uint64_t)v13;
  a5.i64[0] = (uint64_t)a2 + 88;
  v5 = (int8x16_t)vdupq_lane_s64(vmvnq_s8((int8x16_t)vceqq_s64(a5, a4)).i64[0], 0);
  v6 = (float64x2_t)vandq_s8(*(int8x16_t *)((char *)a2 + 120), v5);
  v7 = (float64x2_t)vandq_s8(*(int8x16_t *)((char *)a2 + 104), v5);
  v8 = (float64x2_t)vandq_s8(*(int8x16_t *)((char *)a2 + 88), v5);
  v9 = *((double *)this + 6);
  v10 = *((double *)this + 7);
  v11 = vmlaq_n_f64(vmulq_n_f64(v8, *((double *)this + 4)), v7, *((double *)this + 5));
  v13[0] = vmlaq_n_f64(vmulq_n_f64(v8, *((double *)this + 2)), v7, *((double *)this + 3));
  v13[1] = v11;
  v13[2] = vmlaq_n_f64(vmlaq_n_f64(v6, v8, v9), v7, v10);
  CA::CG::fill_image((uint64_t)a2);
  return result;
}

void CA::CG::ClipRectFill::~ClipRectFill(CA::CG::ClipRectFill *this)
{
  malloc_zone_t *malloc_zone;

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

uint64_t CA::CG::ClipRectFill::type(CA::CG::ClipRectFill *this)
{
  return 1;
}

uint64_t CA::CG::ClipRectFill::prepare(CA::CG::ClipRectFill *this, CA::CG::Renderer *a2, const CA::CG::DrawOp *a3, int32x2_t *a4)
{
  double v5;
  float64x2_t *v6;
  __int128 v7;
  __int128 v8;
  float64x2_t v9;
  double v10;
  int32x2_t v11;
  int32x2_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int32x4_t v15;
  float64x2_t v16;
  int8x16_t v17;
  int8x16_t v23;
  int32x2_t v25;
  uint32x2_t v26;
  uint32x2_t v27;
  int32x2_t v28;
  __int128 v29;
  int32x2_t v30;
  uint32x2_t v31;
  int32x2_t v32;
  int32x4_t v33;
  __int128 v34;
  double v35[3];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v34 = 0u;
  *(_OWORD *)v35 = 0u;
  v5 = *((double *)a2 + 10);
  if (v5 == 1.0)
  {
    v6 = (float64x2_t *)((char *)this + 8);
  }
  else
  {
    v7 = *(_OWORD *)((char *)this + 8);
    v8 = *(_OWORD *)((char *)this + 24);
    v34 = v7;
    *(_OWORD *)v35 = v8;
    if (*(double *)&v8 < 1.79769313e308)
    {
      *(double *)&v34 = v5 * *(double *)&v7;
      v35[0] = *(double *)&v8 * v5;
    }
    if (*((double *)&v8 + 1) < 1.79769313e308)
    {
      *((double *)&v34 + 1) = *((double *)&v7 + 1) * v5;
      v35[1] = *((double *)&v8 + 1) * v5;
    }
    v6 = (float64x2_t *)&v34;
  }
  v9 = v6[1];
  if (*((_BYTE *)this + 40))
  {
    v10 = v6[1].f64[1];
    if (v9.f64[0] > v9.f64[1])
      v10 = v6[1].f64[0];
    if (v10 < 1073741820.0)
    {
      v16.f64[0] = NAN;
      v16.f64[1] = NAN;
      v17 = (int8x16_t)vnegq_f64(v16);
      __asm { FMOV            V4.2D, #0.5 }
      v11 = vmovn_s64(vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8(v17, _Q4, *(int8x16_t *)v6), *v6)));
      v23 = (int8x16_t)vaddq_f64(*v6, v9);
      v12 = vsub_s32(vmovn_s64(vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8(v17, _Q4, v23), (float64x2_t)v23))), v11);
    }
    else
    {
      v11 = vdup_n_s32(0xE0000001);
      v12 = (int32x2_t)0xC0000000C0000000;
    }
    *(int32x2_t *)v33.i8 = v11;
    v33.u64[1] = (unint64_t)v12;
  }
  else
  {
    v13 = (int8x16_t)vceqzq_f64(v9);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)v13, 1), v13).u64[0] & 0x8000000000000000) != 0
      || (v14 = vorrq_s8((int8x16_t)vcltzq_f64(v9), (int8x16_t)vcgezq_f64(v9)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v14), 1), v14).u64[0] & 0x8000000000000000) != 0))
    {
      v33 = 0uLL;
      v12 = 0;
    }
    else
    {
      v15 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(*v6, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      v33 = vuzp1q_s32(v15, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(*v6, v9), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v15));
      v12 = (int32x2_t)v33.u64[1];
    }
  }
  v32 = v12;
  if (CA::BoundsImpl::contains(&v33, a4))
    return 0;
  v25 = a4[1];
  v26 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v25);
  if ((vpmax_u32(v26, v26).u32[0] & 0x80000000) == 0)
  {
    v27 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v32);
    if ((vpmax_u32(v27, v27).u32[0] & 0x80000000) == 0)
    {
      v28 = vadd_s32(*a4, v25);
      *(int32x2_t *)&v29 = vmax_s32(*a4, *(int32x2_t *)v33.i8);
      v30 = vsub_s32(vmin_s32(v28, vadd_s32(*(int32x2_t *)v33.i8, v32)), *(int32x2_t *)&v29);
      v31 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v30);
      if ((vpmax_u32(v31, v31).u32[0] & 0x80000000) == 0)
      {
        *((int32x2_t *)&v29 + 1) = v30;
        *(_OWORD *)a4->i8 = v29;
        return 2 * ((*(_QWORD *)&a4[6] | *(_QWORD *)&a4[2]) != 0);
      }
    }
    a4[1] = 0;
  }
  return 1;
}

uint64_t CA::CG::ClipRectFill::draw(CA::CG::ClipRectFill *this, CA::CG::Renderer *a2)
{
  uint64_t v3;
  double *v4;
  char *v5;
  uint64_t v6;
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int8x16_t v11;
  double *v12;
  double *v13;
  _OWORD v15[9];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = *((_QWORD *)a2 + 1);
  v4 = (double *)((char *)a2 + 88);
  v5 = (char *)this + 8;
  v6 = CA::CG::mat2_filter_bits((uint64_t)a2 + 88);
  LODWORD(v4) = CA::CG::rect_filter_bits((uint64_t)v5, v4, v6, v7, v8, v9, v10, v11);
  v19 = 0;
  v17 = 0u;
  v18 = 0u;
  v16 = 0u;
  memset(v15, 0, sizeof(v15));
  CA::Transform::set_affine((CA::Transform *)v15, *((double *)a2 + 11), *((double *)a2 + 12), *((double *)a2 + 13), *((double *)a2 + 14), *((double *)a2 + 15), *((double *)a2 + 16));
  *((_QWORD *)&v16 + 1) = v5;
  *(_QWORD *)&v17 = v15;
  *((_QWORD *)&v17 + 1) = v4 | 0xFF00000000;
  v19 = 0;
  v18 = 0uLL;
  return CA::OGL::fill_rect(v3, (uint64_t)&v16 + 8, v12, v13);
}

void CA::CG::ClipRectStroke::~ClipRectStroke(CA::CG::ClipRectStroke *this)
{
  malloc_zone_t *malloc_zone;

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

uint64_t CA::CG::ClipRectStroke::type(CA::CG::ClipRectStroke *this)
{
  return 2;
}

void CA::CG::ClipRectStroke::draw(CA::CG::ClipRectStroke *this, CA::CG::Renderer *a2)
{
  uint64_t v4;
  double *v5;
  __int128 v6;
  double v7;
  uint64_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int8x16_t v12;
  int8x16_t v13;
  unsigned int v14;
  BOOL v15;
  int v16;
  double *v17;
  double *v18;
  _OWORD v19[2];
  _OWORD v20[9];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)a2 + 1);
  v5 = (double *)((char *)a2 + 88);
  v6 = *(_OWORD *)((char *)this + 24);
  v19[0] = *(_OWORD *)((char *)this + 8);
  v19[1] = v6;
  v7 = *((double *)this + 5);
  CA::BoundsImpl::inset((double *)v19, v7 * -0.5, v7 * -0.5);
  v8 = CA::CG::mat2_filter_bits((uint64_t)v5);
  v14 = CA::CG::rect_filter_bits((uint64_t)v19, v5, v8, v9, v10, v11, v12, v13);
  v15 = *((_BYTE *)this + 48) == 0;
  v24 = 0;
  if (v15)
    v16 = 0;
  else
    v16 = 255;
  v22 = 0u;
  v23 = 0u;
  v21 = 0u;
  memset(v20, 0, sizeof(v20));
  CA::Transform::set_affine((CA::Transform *)v20, *((double *)a2 + 11), *((double *)a2 + 12), *((double *)a2 + 13), *((double *)a2 + 14), *((double *)a2 + 15), *((double *)a2 + 16));
  *((_QWORD *)&v21 + 1) = v19;
  *(_QWORD *)&v22 = v20;
  *((_QWORD *)&v22 + 1) = __PAIR64__(v16, v14);
  v24 = 0;
  v23 = 0uLL;
  CA::OGL::stroke_rect(v4, (const CA::Transform **)&v21 + 1, v17, v18, v7);
}

void CA::CG::ClipEllipseFill::~ClipEllipseFill(CA::CG::ClipEllipseFill *this)
{
  malloc_zone_t *malloc_zone;

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

void CA::CG::ClipRoundedRectFill::~ClipRoundedRectFill(CA::CG::ClipRoundedRectFill *this)
{
  malloc_zone_t *malloc_zone;

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

int32x2_t *CA::CG::ClipOp::ClipOp(int32x2_t *this, CA::CG::Renderer *a2, const CA::CG::DrawOp *a3, int32x2_t *a4, CA::CG::ClipItem **a5, double a6, double a7, double a8, int64x2_t a9, double a10, float64x2_t a11)
{
  __int128 v12;
  int v13;
  int v14;
  uint64_t v17;
  double v18;
  double v19;
  double v20;
  double v21;
  int8x16_t *v22;
  int8x16_t v23;
  double v24;
  int32x2_t v25;
  float64x2_t v26;
  int8x16_t v30;
  int32x2_t v31;
  uint32x2_t v32;
  uint32x2_t v33;
  int32x2_t v34;
  int32x2_t v35;
  uint32x2_t v36;
  uint64_t v37;
  int64x2_t v38;
  int8x16_t v39;
  signed __int32 v40;
  int64x2_t v41;
  int8x16_t v42;
  int32x2_t v43;
  int64x2_t v44;
  int8x16_t v45;
  int8x16_t v46;
  int8x16_t v47;
  int8x16_t v48;
  float64x2_t v49;
  float64x2_t v50;
  int64x2_t v51;
  unint64_t v52;
  int8x16_t v53;
  int8x16_t v54;
  int32x4_t v55;
  int32x2_t v56;
  uint32x2_t v57;
  int32x2_t v58;
  uint32x2_t v59;
  int32x2_t v60;
  int32x2_t v61;
  uint32x2_t v62;
  unsigned int v63;
  uint64_t v64;
  int v65;
  int32x2_t v66;
  int32x2_t v67;
  double v68;
  double v69;
  double v70;
  double v71;
  double v72;
  double v73;
  double v74;
  double v75;
  CGColor *Background;
  double v77;
  float v78;
  double v79;
  unint64_t v81;
  int8x16_t v82;
  int64x2_t v83;
  int8x16_t v84;
  int32x4_t v85;
  int32x2_t v86;
  uint32x2_t v87;
  int32x2_t v88;
  uint32x2_t v89;
  int32x2_t v90;
  int8x16_t v91;
  int32x2_t v92;
  uint32x2_t v93;
  int v94;
  unint64_t v95;
  size_t v96;
  CA::Render *v97;
  CGColorSpace *v98;
  CA::Render *v99;
  CA::Render *v100;
  CGColorSpace *v101;
  uint32_t v102;
  CGContext *v103;
  void *v104;
  CGContext *v105;
  int64x2_t v106;
  CA::Render *v107;
  uint64_t v108;
  __int32 v109;
  CA::Render *v110;
  uint64_t v111;
  CGDataProvider *v112;
  CGImage *v113;
  int32x4_t v114;
  int32x4_t v115;
  int v116;
  int8x16_t v117;
  int64x2_t v118;
  int8x16_t v119;
  int32x2_t v120;
  int8x16_t v121;
  double v122;
  double v123;
  double v124;
  double v125;
  double v126;
  float v127;
  double v128;
  int8x16_t v130;
  int8x16_t v131;
  unint64_t v132;
  int8x16_t v133;
  int8x16_t v134;
  float64x2_t v135;
  malloc_zone_t *malloc_zone;
  double *v137;
  double *v138;
  int v139;
  int32x2_t v140;
  int32x2_t v141;
  int32x2_t v142;
  int8x16_t v144;
  int8x16_t v145;
  int8x16_t v146;
  int8x16_t v147;
  size_t size;
  CGAffineTransform v149;
  float64x2_t v150;
  float64x2_t v151;
  int8x16_t v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  uint64_t v168;

  v168 = *MEMORY[0x1E0C80C00];
  *(int32x2_t *)&v12 = *a4;
  *this = *a4;
  v13 = a4[1].i32[0];
  this[1].i32[0] = v13;
  v14 = a4[1].i32[1];
  this[1].i32[1] = v14;
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = (int32x2_t)a5;
  this[6] = 0;
  if (v13 >= v14)
    v13 = v14;
  if (v13 < 1)
    return this;
  v17 = *((_QWORD *)a3 + 9);
  if (v17)
  {
    v19 = *(double *)(v17 + 24);
    v18 = *(double *)(v17 + 32);
    if (v19 <= v18)
      v20 = *(double *)(v17 + 32);
    else
      v20 = *(double *)(v17 + 24);
    if (v20 < 1.79769313e308)
    {
      v22 = (int8x16_t *)(v17 + 8);
      v152 = 0u;
      v153 = 0u;
      v21 = *((double *)a2 + 10);
      if (v21 != 1.0)
      {
        v23 = *v22;
        v152 = *v22;
        *(double *)&v153 = v19;
        *((double *)&v153 + 1) = v18;
        if (v19 < 1.79769313e308)
        {
          *(double *)v152.i64 = v21 * *(double *)v23.i64;
          *(double *)&v153 = v19 * v21;
        }
        if (v18 < 1.79769313e308)
        {
          *(double *)&v152.i64[1] = *(double *)&v23.i64[1] * v21;
          *((double *)&v153 + 1) = v18 * v21;
        }
        v22 = &v152;
      }
      a9 = (int64x2_t)v22[1];
      v24 = *(double *)&v22[1].i64[1];
      if (*(double *)a9.i64 > v24)
        v24 = *(double *)v22[1].i64;
      if (v24 < 1073741820.0)
      {
        v26.f64[0] = NAN;
        v26.f64[1] = NAN;
        a11 = vnegq_f64(v26);
        __asm { FMOV            V6.2D, #0.5 }
        v25 = vmovn_s64(vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)a11, _Q6, *v22), *(float64x2_t *)v22)));
        v30 = (int8x16_t)vaddq_f64(*(float64x2_t *)v22, (float64x2_t)a9);
        a9 = vcvtq_s64_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)a11, _Q6, v30), (float64x2_t)v30));
        *(int32x2_t *)a9.i8 = vsub_s32(vmovn_s64(a9), v25);
      }
      else
      {
        v25 = vdup_n_s32(0xE0000001);
        a9.i64[0] = 0xC0000000C0000000;
      }
      v31 = this[1];
      v32 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v31);
      if ((vpmax_u32(v32, v32).u32[0] & 0x80000000) != 0)
        return this;
      v33 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)a9.i8);
      *(uint32x2_t *)&a11.f64[0] = vpmax_u32(v33, v33);
      if ((LODWORD(a11.f64[0]) & 0x80000000) != 0)
        goto LABEL_65;
      v34 = vadd_s32(*(int32x2_t *)&v12, v31);
      *(int32x2_t *)&v12 = vmax_s32(*(int32x2_t *)&v12, v25);
      v35 = vsub_s32(vmin_s32(v34, vadd_s32(v25, *(int32x2_t *)a9.i8)), *(int32x2_t *)&v12);
      v36 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v35);
      if ((vpmax_u32(v36, v36).u32[0] & 0x80000000) != 0)
        goto LABEL_65;
      *((int32x2_t *)&v12 + 1) = v35;
      *(_OWORD *)this->i8 = v12;
    }
    else
    {
      v21 = *((double *)a2 + 10);
    }
    if (v21 == 1.0)
    {
      if ((CA::BoundsImpl::intersect(this, *(int32x2_t *)(v17 + 40), *(int32x2_t *)(v17 + 48)) & 1) == 0)
        return this;
      goto LABEL_39;
    }
    v37 = *(_QWORD *)(v17 + 40);
    a9.i64[0] = *(_QWORD *)(v17 + 48);
    v38.i64[0] = (int)v37;
    v38.i64[1] = SHIDWORD(v37);
    v39 = (int8x16_t)vcvtq_f64_s64(v38);
    v40 = a9.i32[1];
    v38.i64[0] = a9.i32[0];
    v38.i64[1] = a9.i32[1];
    v41 = v38;
    if (a9.i32[0] > a9.i32[1])
      v40 = *(_QWORD *)(v17 + 48);
    a9.i32[0] = v40;
    LODWORD(a11.f64[0]) = 1073741822;
    v42 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32((int32x4_t)a9, (int32x4_t)a11), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), v39);
    v43 = vdup_n_s32(v40 > 1073741822);
    v44.i64[0] = v43.u32[0];
    v44.i64[1] = v43.u32[1];
    v45 = (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    v46 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v44, 0x3FuLL)), v45, (int8x16_t)vcvtq_f64_s64(v41));
    v45.i64[0] = 0x7FEFFFFFFFFFFFFFLL;
    v47 = (int8x16_t)vdupq_lane_s64(vcgtq_f64((float64x2_t)v45, (float64x2_t)v46).i64[0], 0);
    v48.i64[1] = v42.i64[1];
    *(double *)v48.i64 = v21 * *(double *)v42.i64;
    v49 = (float64x2_t)vbslq_s8(v47, v48, v42);
    v48.i64[1] = v46.i64[1];
    *(double *)v48.i64 = v21 * *(double *)v46.i64;
    v50 = (float64x2_t)vbslq_s8(v47, v48, v46);
    if (v50.f64[1] < 1.79769313e308)
    {
      v49.f64[1] = vmuld_lane_f64(v21, v49, 1);
      v50.f64[1] = v50.f64[1] * v21;
    }
    v51 = vceqzq_f64(v50);
    v52 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v51, 1), (int8x16_t)v51).u64[0];
    v53 = 0uLL;
    if ((v52 & 0x8000000000000000) == 0)
    {
      v54 = vorrq_s8((int8x16_t)vcltzq_f64(v50), (int8x16_t)vcgezq_f64(v50));
      if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v54), 1), v54).u64[0] & 0x8000000000000000) == 0)
      {
        v55 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v49, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        v53 = (int8x16_t)vuzp1q_s32(v55, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v49, v50), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v55));
      }
    }
    v56 = this[1];
    v57 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v56);
    if ((vpmax_u32(v57, v57).u32[0] & 0x80000000) != 0)
      return this;
    v58 = (int32x2_t)vextq_s8(v53, v53, 8uLL).u64[0];
    v59 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v58);
    if ((vpmax_u32(v59, v59).u32[0] & 0x80000000) == 0)
    {
      v60 = vadd_s32(*(int32x2_t *)&v12, v56);
      *(int32x2_t *)&v12 = vmax_s32(*(int32x2_t *)&v12, *(int32x2_t *)v53.i8);
      v61 = vsub_s32(vmin_s32(v60, vadd_s32(*(int32x2_t *)v53.i8, v58)), *(int32x2_t *)&v12);
      v62 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v61);
      if ((vpmax_u32(v62, v62).u32[0] & 0x80000000) == 0)
      {
        *((int32x2_t *)&v12 + 1) = v61;
        *(_OWORD *)this->i8 = v12;
LABEL_39:
        if ((*((_BYTE *)a3 + 100) & 0x20) == 0 && *(_DWORD *)(v17 + 4))
        {
          v63 = 0;
          do
          {
            v64 = v17 + 56 + 104 * (int)v63;
            v65 = (*(uint64_t (**)(uint64_t, CA::CG::Renderer *, const CA::CG::DrawOp *, int32x2_t *))(*(_QWORD *)v64 + 24))(v64, a2, a3, this);
            if (v65 == 2)
            {
              v66 = this[5];
              v67 = this[6];
              this[6] = (int32x2_t)(*(_QWORD *)&v67 + 1);
              *(_QWORD *)(*(_QWORD *)&v66 + 8 * *(_QWORD *)&v67) = v64;
            }
            else if (v65 == 1)
            {
              goto LABEL_124;
            }
            ++v63;
          }
          while (v63 < *(_DWORD *)(v17 + 4));
        }
        goto LABEL_47;
      }
    }
LABEL_65:
    this[1] = 0;
    return this;
  }
LABEL_47:
  if (*((_QWORD *)a3 + 8))
  {
    CGSoftMaskGetBounds();
    v72 = v68;
    v73 = v69;
    v74 = v70;
    v75 = v71;
    v150.f64[0] = v68;
    v150.f64[1] = v69;
    v151.f64[0] = v70;
    v151.f64[1] = v71;
    if (v70 < 0.0)
    {
      v72 = v70 + v68;
      v74 = -v70;
      v150.f64[0] = v70 + v68;
      v151.f64[0] = -v70;
    }
    if (v71 < 0.0)
    {
      v73 = v71 + v69;
      v75 = -v71;
      v150.f64[1] = v71 + v69;
      v151.f64[1] = -v71;
    }
    memset(&v149, 0, sizeof(v149));
    CGSoftMaskGetMatrix();
    Background = (CGColor *)CGSoftMaskGetBackground();
    v77 = *((double *)a2 + 10);
    if (v77 != 1.0)
    {
      v78 = v77;
      v79 = v78;
      if (v78 != 1.0 && v74 < 1.79769313e308)
      {
        v150.f64[0] = v72 * v79;
        v151.f64[0] = v74 * v79;
      }
      if (v78 != 1.0 && v75 < 1.79769313e308)
      {
        v150.f64[1] = v73 * v79;
        v151.f64[1] = v75 * v79;
      }
      *(float64x2_t *)&v149.a = vmulq_n_f64(*(float64x2_t *)&v149.a, v79);
      *(float64x2_t *)&v149.c = vmulq_n_f64(*(float64x2_t *)&v149.c, v79);
      *(float64x2_t *)&v149.tx = vmulq_n_f64(*(float64x2_t *)&v149.tx, v79);
    }
    CA::Rect::apply_transform(&v150, &v149);
    if (Background)
    {
      *(int32x2_t *)v82.i8 = *this;
      v81 = (unint64_t)this[1];
      v82.i64[1] = v81;
    }
    else
    {
      v83 = vceqzq_f64(v151);
      v82 = 0uLL;
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v83, 1), (int8x16_t)v83).u64[0] & 0x8000000000000000) == 0)
      {
        v84 = vorrq_s8((int8x16_t)vcltzq_f64(v151), (int8x16_t)vcgezq_f64(v151));
        if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v84), 1), v84).u64[0] & 0x8000000000000000) == 0)
        {
          v85 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v150, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
          v82 = (int8x16_t)vuzp1q_s32(v85, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v150, v151), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v85));
        }
      }
      v86 = (int32x2_t)vextq_s8(v82, v82, 8uLL).u64[0];
      v87 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v86);
      if ((vpmax_u32(v87, v87).u32[0] & 0x80000000) == 0)
      {
        v88 = this[1];
        v89 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v88);
        if ((vpmax_u32(v89, v89).u32[0] & 0x80000000) != 0
          || (v90 = vadd_s32(*(int32x2_t *)v82.i8, v86),
              *(int32x2_t *)v91.i8 = vmax_s32(*(int32x2_t *)v82.i8, *this),
              v92 = vsub_s32(vmin_s32(v90, vadd_s32(*this, v88)), *(int32x2_t *)v91.i8),
              v93 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v92),
              (vpmax_u32(v93, v93).u32[0] & 0x80000000) != 0))
        {
          v82.i64[1] = 0;
        }
        else
        {
          v91.u64[1] = (unint64_t)v92;
          v82 = v91;
        }
      }
      v81 = vextq_s8(v82, v82, 8uLL).u64[0];
    }
    v94 = HIDWORD(v81);
    if ((int)v81 < SHIDWORD(v81))
      v94 = v81;
    if (v94 >= 1)
    {
      v146 = v82;
      v95 = CA::Render::format_rowbytes((CA::Render *)9, v81);
      v96 = v95;
      v97 = is_mul_ok(v95, v146.u32[3]) ? (CA::Render *)(v95 * v146.u32[3]) : 0;
      v98 = (CGColorSpace *)CAGetColorSpace(1u);
      size = 0;
      v99 = (CA::Render *)CA::Render::aligned_malloc(v97, &size, 0);
      if (v99)
      {
        v100 = v99;
        if (Background)
          v101 = v98;
        else
          v101 = 0;
        if (Background)
          v102 = 0;
        else
          v102 = 7;
        v103 = CGBitmapContextCreate(v99, v146.i32[2], v146.i32[3], 8uLL, v96, v101, v102);
        if (v103)
        {
          v105 = v103;
          if (Background)
          {
            CGContextBeginTransparencyLayer(v103, 0);
            CGContextSetCompositeOperation();
            CGContextSetFillColorWithColor(v105, Background);
            CGContextFillRect(v105, *MEMORY[0x1E0C9D5E0]);
          }
          else
          {
            CGContextSetCompositeOperation();
          }
          v106.i64[0] = v146.i32[0];
          v106.i64[1] = v146.i32[1];
          v144 = (int8x16_t)vcvtq_f64_s64(v106);
          CGRenderingStateCreateCopy();
          CGRenderingStateSetBaseCTM();
          CGGStateCreateCopy();
          CGGStateResetClip();
          CGGStateSetAlpha();
          CGGStateSetStyle();
          CGGStateSetSoftMask();
          CGGStateSetCTM();
          CGGStateSetFillColor();
          CGGStateSetStrokeColor();
          CGGStateSetCompositeOperation();
          CGContextGetDelegate();
          CGSoftMaskDelegateDrawSoftMask();
          CGGStateRelease();
          CGRenderingStateRelease();
          if (Background)
            CGContextEndTransparencyLayer(v105);
          CGContextRelease(v105);
          v107 = v100;
          if (CGSoftMaskGetTransfer())
          {
            if ((CGFunctionIsIdentity() & 1) == 0)
            {
              v108 = 0;
              v166 = 0u;
              v167 = 0u;
              v164 = 0u;
              v165 = 0u;
              v162 = 0u;
              v163 = 0u;
              v160 = 0u;
              v161 = 0u;
              v158 = 0u;
              v159 = 0u;
              v156 = 0u;
              v157 = 0u;
              v154 = 0u;
              v155 = 0u;
              v152 = 0u;
              v153 = 0u;
              do
              {
                CGFunctionEvaluate();
                v152.i8[v108++] = 0;
              }
              while (v108 != 256);
              v107 = v100;
              if (v146.i32[3])
              {
                v109 = v146.i32[3];
                v110 = v100;
                do
                {
                  if (v146.i32[2])
                  {
                    v111 = 0;
                    do
                    {
                      *((_BYTE *)v110 + v111) = v152.i8[*((unsigned __int8 *)v110 + v111)];
                      ++v111;
                    }
                    while (v146.i32[2] != (_DWORD)v111);
                  }
                  v110 = (CA::Render *)((char *)v110 + v96);
                  --v109;
                }
                while (v109);
              }
            }
          }
          v112 = CGDataProviderCreateWithData((void *)size, v107, size, (CGDataProviderReleaseDataCallback)CA::Render::aligned_release);
          v113 = CGImageCreate(v146.i32[2], v146.i32[3], 8uLL, 8uLL, v96, v98, 0, v112, 0, 0, kCGRenderingIntentDefault);
          CGDataProviderRelease(v112);
          if (v146.i32[2] <= v146.i32[3])
            v116 = v146.i32[3];
          else
            v116 = v146.i32[2];
          v114.i32[0] = 1073741822;
          v115.i32[0] = v116;
          v117 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v115, v114), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), v144);
          v118.i64[0] = v146.i32[2];
          v118.i64[1] = v146.i32[3];
          v119 = (int8x16_t)vcvtq_f64_s64(v118);
          v120 = vdup_n_s32(v116 > 1073741822);
          v118.i64[0] = v120.u32[0];
          v118.i64[1] = v120.u32[1];
          v121 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v118, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v119);
          v123 = *MEMORY[0x1E0C9BAA8];
          v122 = *(double *)(MEMORY[0x1E0C9BAA8] + 8);
          v125 = *(double *)(MEMORY[0x1E0C9BAA8] + 16);
          v124 = *(double *)(MEMORY[0x1E0C9BAA8] + 24);
          v152 = *(int8x16_t *)(MEMORY[0x1E0C9BAA8] + 32);
          v126 = *((double *)a2 + 10);
          if (v126 == 1.0)
          {
            v145 = v121;
            v147 = v117;
          }
          else
          {
            v127 = 1.0 / v126;
            v128 = v127;
            _ZF = *(double *)v121.i64 >= 1.79769313e308 || v127 == 1.0;
            v130.i64[1] = v117.i64[1];
            v131.i64[1] = v121.i64[1];
            if (_ZF)
              v132 = 0;
            else
              v132 = -1;
            v133 = (int8x16_t)vdupq_n_s64(v132);
            *(double *)v131.i64 = v128 * *(double *)v121.i64;
            v134 = vbslq_s8(v133, v131, v121);
            *(double *)v130.i64 = v128 * *(double *)v117.i64;
            v135 = (float64x2_t)vbslq_s8(v133, v130, v117);
            if (v127 != 1.0 && *(double *)&v134.i64[1] < 1.79769313e308)
            {
              v135.f64[1] = vmuld_lane_f64(v128, v135, 1);
              *(double *)&v134.i64[1] = *(double *)&v134.i64[1] * v128;
            }
            v145 = v134;
            v147 = (int8x16_t)v135;
            v123 = v123 * v128;
            v122 = v122 * v128;
            v125 = v125 * v128;
            v124 = v124 * v128;
          }
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          v137 = (double *)malloc_type_zone_malloc(malloc_zone, 0x68uLL, 0x8BB15036uLL);
          v138 = v137;
          if (v137)
          {
            *(_QWORD *)v137 = off_1E1593AE0;
            *((_QWORD *)v137 + 1) = CGImageRetain(v113);
            v138[2] = v123;
            v138[3] = v122;
            v138[4] = v125;
            v138[5] = v124;
            *((int8x16_t *)v138 + 3) = v152;
            *((int8x16_t *)v138 + 4) = v147;
            *((int8x16_t *)v138 + 5) = v145;
            *((_BYTE *)v138 + 96) = 0;
          }
          this[4] = (int32x2_t)v138;
          CGImageRelease(v113);
          v139 = (*(uint64_t (**)(_QWORD, CA::CG::Renderer *, const CA::CG::DrawOp *, int32x2_t *))(**(_QWORD **)&this[4] + 24))(*(_QWORD *)&this[4], a2, a3, this);
          if (v139 == 2)
          {
            v140 = this[4];
            v141 = this[5];
            v142 = this[6];
            this[6] = (int32x2_t)(*(_QWORD *)&v142 + 1);
            *(int32x2_t *)(*(_QWORD *)&v141 + 8 * *(_QWORD *)&v142) = v140;
          }
          else if (v139 == 1)
          {
LABEL_124:
            *this = 0;
            this[1] = 0;
          }
        }
        else
        {
          CA::Render::aligned_free(v100, size, v104);
        }
      }
    }
  }
  return this;
}

void CA::Render::EmitterLayer::~EmitterLayer(CA::Render::EmitterLayer *this, const CA::Render::Object *a2)
{
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int *v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int *v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;

  *(_QWORD *)this = off_1E15967E8;
  v3 = (unsigned int *)*((_QWORD *)this + 7);
  if (v3)
  {
    v4 = v3 + 2;
    do
    {
      v5 = __ldaxr(v4);
      v6 = v5 - 1;
    }
    while (__stlxr(v6, v4));
    if (!v6)
      (*(void (**)(unsigned int *))(*(_QWORD *)v3 + 16))(v3);
  }
  v7 = (unsigned int *)*((_QWORD *)this + 6);
  if (v7)
  {
    v8 = v7 + 2;
    do
    {
      v9 = __ldaxr(v8);
      v10 = v9 - 1;
    }
    while (__stlxr(v10, v8));
    if (!v10)
      (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 16))(v7);
  }
  v11 = (unsigned int *)*((_QWORD *)this + 5);
  if (v11)
  {
    v12 = v11 + 2;
    do
    {
      v13 = __ldaxr(v12);
      v14 = v13 - 1;
    }
    while (__stlxr(v14, v12));
    if (!v14)
      (*(void (**)(unsigned int *))(*(_QWORD *)v11 + 16))(v11);
  }
  v15 = (unsigned int *)*((_QWORD *)this + 4);
  if (v15)
  {
    v16 = v15 + 2;
    do
    {
      v17 = __ldaxr(v16);
      v18 = v17 - 1;
    }
    while (__stlxr(v18, v16));
    if (!v18)
      (*(void (**)(unsigned int *))(*(_QWORD *)v15 + 16))(v15);
  }
  v19 = (unsigned int *)*((_QWORD *)this + 3);
  if (v19)
  {
    v20 = v19 + 2;
    do
    {
      v21 = __ldaxr(v20);
      v22 = v21 - 1;
    }
    while (__stlxr(v22, v20));
    if (!v22)
      (*(void (**)(unsigned int *))(*(_QWORD *)v19 + 16))(v19);
  }
  --dword_1ECDC7C64;
  *(_QWORD *)this = off_1E1598C30;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0)
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
}

{
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int *v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int *v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  malloc_zone_t *malloc_zone;

  *(_QWORD *)this = off_1E15967E8;
  v3 = (unsigned int *)*((_QWORD *)this + 7);
  if (v3)
  {
    v4 = v3 + 2;
    do
    {
      v5 = __ldaxr(v4);
      v6 = v5 - 1;
    }
    while (__stlxr(v6, v4));
    if (!v6)
      (*(void (**)(unsigned int *))(*(_QWORD *)v3 + 16))(v3);
  }
  v7 = (unsigned int *)*((_QWORD *)this + 6);
  if (v7)
  {
    v8 = v7 + 2;
    do
    {
      v9 = __ldaxr(v8);
      v10 = v9 - 1;
    }
    while (__stlxr(v10, v8));
    if (!v10)
      (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 16))(v7);
  }
  v11 = (unsigned int *)*((_QWORD *)this + 5);
  if (v11)
  {
    v12 = v11 + 2;
    do
    {
      v13 = __ldaxr(v12);
      v14 = v13 - 1;
    }
    while (__stlxr(v14, v12));
    if (!v14)
      (*(void (**)(unsigned int *))(*(_QWORD *)v11 + 16))(v11);
  }
  v15 = (unsigned int *)*((_QWORD *)this + 4);
  if (v15)
  {
    v16 = v15 + 2;
    do
    {
      v17 = __ldaxr(v16);
      v18 = v17 - 1;
    }
    while (__stlxr(v18, v16));
    if (!v18)
      (*(void (**)(unsigned int *))(*(_QWORD *)v15 + 16))(v15);
  }
  v19 = (unsigned int *)*((_QWORD *)this + 3);
  if (v19)
  {
    v20 = v19 + 2;
    do
    {
      v21 = __ldaxr(v20);
      v22 = v21 - 1;
    }
    while (__stlxr(v22, v20));
    if (!v22)
      (*(void (**)(unsigned int *))(*(_QWORD *)v19 + 16))(v19);
  }
  --dword_1ECDC7C64;
  *(_QWORD *)this = off_1E1598C30;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0)
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, this);
}

__n128 CA::Render::EmitterLayer::encode(CA::Render::EmitterLayer *this, CA::Render::Encoder *a2)
{
  uint64_t v4;
  _QWORD *v5;
  int v6;
  _DWORD *v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  __n128 result;
  __int128 v16;
  __int128 v17;

  CA::Render::Object::encode(this, a2);
  v4 = *((_QWORD *)this + 2);
  v5 = (_QWORD *)*((_QWORD *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((_QWORD *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 8);
    v5 = (_QWORD *)*((_QWORD *)a2 + 4);
  }
  *v5 = v4;
  *((_QWORD *)a2 + 4) += 8;
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 4));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 5));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 6));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 7));
  CA::Render::Encoder::encode_atom(a2, *((_DWORD *)this + 16));
  CA::Render::Encoder::encode_atom(a2, *((_DWORD *)this + 17));
  CA::Render::Encoder::encode_atom(a2, *((_DWORD *)this + 18));
  v6 = *((_DWORD *)this + 38);
  v7 = (_DWORD *)*((_QWORD *)a2 + 4);
  if ((unint64_t)(v7 + 1) > *((_QWORD *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    v7 = (_DWORD *)*((_QWORD *)a2 + 4);
  }
  *v7 = v6;
  v8 = *((_QWORD *)a2 + 4);
  v9 = *((_QWORD *)a2 + 5);
  v10 = (_QWORD *)(v8 + 4);
  *((_QWORD *)a2 + 4) = v8 + 4;
  v11 = *((_QWORD *)this + 20);
  if (v8 + 12 > v9)
  {
    CA::Render::Encoder::grow(a2, 8);
    v10 = (_QWORD *)*((_QWORD *)a2 + 4);
  }
  *v10 = v11;
  v12 = *((_QWORD *)a2 + 4);
  v13 = *((_QWORD *)a2 + 5);
  v14 = v12 + 8;
  *((_QWORD *)a2 + 4) = v12 + 8;
  if (v12 + 84 > v13)
  {
    CA::Render::Encoder::grow(a2, 76);
    v14 = *((_QWORD *)a2 + 4);
  }
  *(_OWORD *)v14 = *(_OWORD *)((char *)this + 76);
  result = *(__n128 *)((char *)this + 92);
  v16 = *(_OWORD *)((char *)this + 108);
  v17 = *(_OWORD *)((char *)this + 124);
  *(_OWORD *)(v14 + 60) = *(_OWORD *)((char *)this + 136);
  *(_OWORD *)(v14 + 32) = v16;
  *(_OWORD *)(v14 + 48) = v17;
  *(__n128 *)(v14 + 16) = result;
  *((_QWORD *)a2 + 4) += 76;
  return result;
}

void CA::Render::EmitterLayer::copy(CA::Render::EmitterLayer *this@<X0>, _QWORD *a2@<X8>)
{
  malloc_zone_t *malloc_zone;
  _DWORD *v5;
  _DWORD *v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;

  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  v5 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0xA8uLL, 0x743898A5uLL);
  v6 = v5;
  if (v5)
  {
    v5[2] = 1;
    v5[3] = 15;
    ++dword_1ECDC7C64;
    *(_QWORD *)v5 = off_1E15967E8;
    v7 = *((_QWORD *)this + 3);
    *((_QWORD *)v5 + 2) = *((_QWORD *)this + 2);
    if (v7)
    {
      v8 = (unsigned int *)(v7 + 8);
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 + 1, v8));
      if (!v9)
      {
        v7 = 0;
        do
          v19 = __ldaxr(v8);
        while (__stlxr(v19 - 1, v8));
      }
    }
    *((_QWORD *)v5 + 3) = v7;
    CA::Render::emitter_cells_copy((_QWORD *)v5 + 4, *((_DWORD **)this + 4));
    CA::Render::emitter_behaviors_copy((_QWORD *)v6 + 5, *((_DWORD **)this + 5));
    v10 = *((_QWORD *)this + 6);
    if (v10)
    {
      v11 = (unsigned int *)(v10 + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 + 1, v11));
      if (!v12)
      {
        v10 = 0;
        do
          v20 = __ldaxr(v11);
        while (__stlxr(v20 - 1, v11));
      }
    }
    *((_QWORD *)v6 + 6) = v10;
    v13 = *((_QWORD *)this + 7);
    if (v13)
    {
      v14 = (unsigned int *)(v13 + 8);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 + 1, v14));
      if (!v15)
      {
        v13 = 0;
        do
          v21 = __ldaxr(v14);
        while (__stlxr(v21 - 1, v14));
      }
    }
    *((_QWORD *)v6 + 7) = v13;
    *((_QWORD *)v6 + 8) = *((_QWORD *)this + 8);
    v6[18] = *((_DWORD *)this + 18);
    v6[38] = *((_DWORD *)this + 38);
    *((_QWORD *)v6 + 20) = *((_QWORD *)this + 20);
    v6[3] |= *((_DWORD *)this + 3) & 0xFFFFFF00;
    *(_OWORD *)(v6 + 19) = *(_OWORD *)((char *)this + 76);
    v16 = *(_OWORD *)((char *)this + 92);
    v17 = *(_OWORD *)((char *)this + 108);
    v18 = *(_OWORD *)((char *)this + 124);
    *(_OWORD *)(v6 + 34) = *(_OWORD *)((char *)this + 136);
    *(_OWORD *)(v6 + 31) = v18;
    *(_OWORD *)(v6 + 27) = v17;
    *(_OWORD *)(v6 + 23) = v16;
  }
  *a2 = v6;
}

_QWORD *CA::Render::EmitterLayer::commit_layer(_QWORD *this, CA::Render::Context *a2, CA::Render::Layer *a3, CA::Render::Handle *a4)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t i;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  malloc_zone_t *malloc_zone;
  char *v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;

  if (!this[3])
  {
    v5 = this;
    v6 = this[2];
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::EmitterState::_list_lock);
    for (i = CA::Render::EmitterState::_list; i; i = *(_QWORD *)(i + 16))
    {
      if (*(CA::Render::Context **)(i + 104) == a2 && *(_QWORD *)(i + 96) == v6)
      {
        v8 = (unsigned int *)(i + 8);
        do
          v9 = __ldaxr(v8);
        while (__stlxr(v9 + 1, v8));
        if (v9)
          goto LABEL_13;
        do
          v10 = __ldaxr(v8);
        while (__stlxr(v10 - 1, v8));
      }
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    v12 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xB8uLL, 0x743898A5uLL);
    i = (uint64_t)v12;
    if (v12)
    {
      *(_OWORD *)(v12 + 168) = 0u;
      *(_OWORD *)(v12 + 152) = 0u;
      *(_OWORD *)(v12 + 136) = 0u;
      *(_OWORD *)(v12 + 120) = 0u;
      *(_OWORD *)(v12 + 104) = 0u;
      *(_OWORD *)(v12 + 88) = 0u;
      *(_OWORD *)(v12 + 72) = 0u;
      *(_OWORD *)(v12 + 56) = 0u;
      *(_OWORD *)(v12 + 40) = 0u;
      *(_OWORD *)(v12 + 24) = 0u;
      *((_DWORD *)v12 + 2) = 1;
      *((_DWORD *)v12 + 3) = 16;
      ++dword_1ECDC7C68;
      *(_QWORD *)v12 = off_1E15968F0;
      *((_DWORD *)v12 + 6) = 0;
      *((_QWORD *)v12 + 19) = 0;
      *((_QWORD *)v12 + 20) = 0;
      *((_QWORD *)v12 + 18) = 0;
    }
    *((_QWORD *)v12 + 12) = v6;
    *((_QWORD *)v12 + 13) = a2;
    *((_QWORD *)v12 + 2) = CA::Render::EmitterState::_list;
    CA::Render::EmitterState::_list = (uint64_t)v12;
LABEL_13:
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::EmitterState::_list_lock);
    this = (_QWORD *)v5[3];
    v5[3] = i;
    if (this)
    {
      v13 = (unsigned int *)(this + 1);
      do
      {
        v14 = __ldaxr(v13);
        v15 = v14 - 1;
      }
      while (__stlxr(v15, v13));
      if (!v15)
        this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 16))(this);
      i = v5[3];
    }
    if (!*(_DWORD *)(i + 28))
      *(_DWORD *)(i + 28) = *((_DWORD *)v5 + 38);
  }
  return this;
}

BOOL CA::Render::EmitterLayer::keypath_is_object(CA::Render::EmitterLayer *this, void *const *a2)
{
  unint64_t v2;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t cell;
  uint64_t i;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unint64_t v14;

  v2 = (unint64_t)*a2;
  if (!*a2)
    return 0;
  if ((v2 & 1) != 0)
  {
    v4 = v2 >> 1;
  }
  else
  {
    if (!*(_DWORD *)v2)
      return 0;
    LODWORD(v4) = *(_DWORD *)(v2 + 4);
  }
  v5 = 1;
  if ((_DWORD)v4 == 203 || (_DWORD)v4 == 201)
    return v5;
  if ((_DWORD)v4 != 197)
    return 0;
  v6 = *((_QWORD *)this + 4);
  if ((v2 & 1) != 0 || *(_DWORD *)v2 < 2u)
    v7 = 0;
  else
    v7 = *(_DWORD *)(v2 + 8);
  cell = CA::Render::emitter_find_cell(v6, v7);
  if (!cell)
    return 0;
  for (i = 0; ; i += 2)
  {
    v10 = (unint64_t)*a2;
    if (!*a2)
      return (_DWORD)v10 == 117;
    if ((v10 & 1) != 0)
      break;
    if (i + 2 >= (unint64_t)*(unsigned int *)v10)
    {
      v14 = i + 2;
      goto LABEL_31;
    }
    if (*(_DWORD *)(v10 + 4 * i + 12) != 197)
    {
      v14 = i + 2;
      if ((v10 & 1) != 0)
        goto LABEL_34;
LABEL_31:
      if (v14 >= *(unsigned int *)v10)
        LODWORD(v10) = 0;
      else
        LODWORD(v10) = *(_DWORD *)(v10 + ((4 * v14) | 4));
      return (_DWORD)v10 == 117;
    }
    v11 = *(_QWORD *)(cell + 40);
    if (i + 3 >= (unint64_t)*(unsigned int *)v10)
      v12 = 0;
    else
      v12 = *(_DWORD *)(v10 + 4 * i + 16);
LABEL_25:
    cell = CA::Render::emitter_find_cell(v11, v12);
    if (!cell)
      return 0;
  }
  if (i == -2 && (v10 >> 1) == 197)
  {
    v12 = 0;
    v11 = *(_QWORD *)(cell + 40);
    goto LABEL_25;
  }
  v14 = i + 2;
LABEL_34:
  v10 >>= 1;
  if (v14)
    LODWORD(v10) = 0;
  return (_DWORD)v10 == 117;
}

uint64_t CA::Render::EmitterLayer::get_keypath_object(CA::Render::EmitterLayer *this, void *const *a2)
{
  unint64_t v2;
  unint64_t v4;
  char *v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t result;
  uint64_t i;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unint64_t v13;

  v2 = (unint64_t)*a2;
  if (!*a2)
    return 0;
  if ((v2 & 1) == 0)
  {
    if (*(_DWORD *)v2)
    {
      LODWORD(v4) = *(_DWORD *)(v2 + 4);
      goto LABEL_6;
    }
    return 0;
  }
  v4 = v2 >> 1;
LABEL_6:
  if ((_DWORD)v4 != 197)
  {
    if ((_DWORD)v4 == 203)
    {
      v5 = (char *)this + 56;
      return *(_QWORD *)v5;
    }
    if ((_DWORD)v4 == 201)
    {
      v5 = (char *)this + 48;
      return *(_QWORD *)v5;
    }
    return 0;
  }
  v6 = *((_QWORD *)this + 4);
  if ((v2 & 1) != 0 || *(_DWORD *)v2 < 2u)
    v7 = 0;
  else
    v7 = *(_DWORD *)(v2 + 8);
  result = CA::Render::emitter_find_cell(v6, v7);
  if (result)
  {
    for (i = 0; ; i += 2)
    {
      v10 = (unint64_t)*a2;
      if (!*a2)
        return 0;
      if ((v10 & 1) != 0)
      {
        if (i != -2)
          return 0;
        v10 >>= 1;
        if ((_DWORD)v10 != 197)
          goto LABEL_36;
        v12 = 0;
        v11 = *(_QWORD *)(result + 40);
      }
      else
      {
        if (i + 2 >= (unint64_t)*(unsigned int *)v10)
        {
          v13 = i + 2;
          goto LABEL_32;
        }
        if (*(_DWORD *)(v10 + 4 * i + 12) != 197)
        {
          v13 = i + 2;
          if ((v10 & 1) != 0)
          {
            if (i != -2)
              return 0;
            v10 >>= 1;
          }
          else
          {
LABEL_32:
            if (v13 >= *(unsigned int *)v10)
              return 0;
            LODWORD(v10) = *(_DWORD *)(v10 + ((4 * v13) | 4));
          }
LABEL_36:
          if ((_DWORD)v10 != 117)
            return 0;
          v5 = (char *)(result + 24);
          return *(_QWORD *)v5;
        }
        v11 = *(_QWORD *)(result + 40);
        if (i + 3 >= (unint64_t)*(unsigned int *)v10)
          v12 = 0;
        else
          v12 = *(_DWORD *)(v10 + 4 * i + 16);
      }
      result = CA::Render::emitter_find_cell(v11, v12);
      if (!result)
        return result;
    }
  }
  return result;
}

CA::Render::Object *CA::Render::EmitterLayer::set_keypath_object(CA::Render::Object *this, void *const *a2, CA::Render::Object *a3)
{
  unint64_t v3;
  CA::Render::Object *v4;
  CA::Render::Object *v6;
  unint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int *v18;
  unsigned int v19;
  CA::Render::Object *v20;
  uint64_t i;
  unint64_t v22;
  uint64_t v23;
  unsigned int v24;
  unint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;

  v3 = (unint64_t)*a2;
  if (*a2)
  {
    v4 = a3;
    v6 = this;
    if ((v3 & 1) != 0)
    {
      v7 = v3 >> 1;
    }
    else
    {
      if (!*(_DWORD *)v3)
        return this;
      LODWORD(v7) = *(_DWORD *)(v3 + 4);
    }
    if ((_DWORD)v7 == 197)
    {
      v13 = *((_QWORD *)this + 4);
      if ((v3 & 1) != 0 || *(_DWORD *)v3 < 2u)
        v14 = 0;
      else
        v14 = *(_DWORD *)(v3 + 8);
      this = (CA::Render::Object *)CA::Render::emitter_find_cell(v13, v14);
      if (this)
      {
        v20 = this;
        for (i = 0; ; i += 2)
        {
          v22 = (unint64_t)*a2;
          if (!*a2)
            return this;
          if ((v22 & 1) != 0)
          {
            if (i != -2)
              return this;
            v22 >>= 1;
            if ((_DWORD)v22 != 197)
              goto LABEL_57;
            v24 = 0;
            v23 = *((_QWORD *)v20 + 5);
          }
          else
          {
            if (i + 2 >= (unint64_t)*(unsigned int *)v22)
            {
              v25 = i + 2;
              goto LABEL_55;
            }
            if (*(_DWORD *)(v22 + 4 * i + 12) != 197)
            {
              v25 = i + 2;
              if ((v22 & 1) != 0)
              {
                if (i != -2)
                  return this;
                v22 >>= 1;
              }
              else
              {
LABEL_55:
                if (v25 >= *(unsigned int *)v22)
                  return this;
                LODWORD(v22) = *(_DWORD *)(v22 + ((4 * v25) | 4));
              }
LABEL_57:
              if ((_DWORD)v22 == 117)
              {
                if (v4)
                {
                  v26 = 0;
                  v27 = *((unsigned __int8 *)v4 + 12);
                  do
                    v28 = CA::Render::texture_types[v26];
                  while (v28 != v27 && v26++ != 5);
                  if (v28 != v27)
                    v4 = 0;
                }
                this = (CA::Render::Object *)*((_QWORD *)v20 + 3);
                if (this != v4)
                {
                  if (this)
                  {
                    v30 = (unsigned int *)((char *)this + 8);
                    do
                    {
                      v31 = __ldaxr(v30);
                      v32 = v31 - 1;
                    }
                    while (__stlxr(v32, v30));
                    if (!v32)
                      this = (CA::Render::Object *)(*(uint64_t (**)(CA::Render::Object *))(*(_QWORD *)this + 16))(this);
                  }
                  if (v4)
                  {
                    v33 = (unsigned int *)((char *)v4 + 8);
                    do
                      v34 = __ldaxr(v33);
                    while (__stlxr(v34 + 1, v33));
                    if (!v34)
                    {
                      v4 = 0;
                      do
                        v37 = __ldaxr(v33);
                      while (__stlxr(v37 - 1, v33));
                    }
                  }
                  *((_QWORD *)v20 + 3) = v4;
                }
              }
              return this;
            }
            v23 = *((_QWORD *)v20 + 5);
            if (i + 3 >= (unint64_t)*(unsigned int *)v22)
              v24 = 0;
            else
              v24 = *(_DWORD *)(v22 + 4 * i + 16);
          }
          this = (CA::Render::Object *)CA::Render::emitter_find_cell(v23, v24);
          if (!this)
            return this;
          v20 = this;
        }
      }
    }
    else if ((_DWORD)v7 == 203)
    {
      if (!a3 || *((_BYTE *)a3 + 12) == 56)
      {
        this = (CA::Render::Object *)*((_QWORD *)this + 7);
        if (this != a3)
        {
          if (this)
          {
            v15 = (unsigned int *)((char *)this + 8);
            do
            {
              v16 = __ldaxr(v15);
              v17 = v16 - 1;
            }
            while (__stlxr(v17, v15));
            if (!v17)
              this = (CA::Render::Object *)(*(uint64_t (**)(CA::Render::Object *))(*(_QWORD *)this + 16))(this);
          }
          if (v4)
          {
            v18 = (unsigned int *)((char *)v4 + 8);
            do
              v19 = __ldaxr(v18);
            while (__stlxr(v19 + 1, v18));
            if (!v19)
            {
              v4 = 0;
              do
                v36 = __ldaxr(v18);
              while (__stlxr(v36 - 1, v18));
            }
          }
          *((_QWORD *)v6 + 7) = v4;
        }
      }
    }
    else if ((_DWORD)v7 == 201 && (!a3 || *((_BYTE *)a3 + 12) == 36))
    {
      this = (CA::Render::Object *)*((_QWORD *)this + 6);
      if (this != a3)
      {
        if (this)
        {
          v8 = (unsigned int *)((char *)this + 8);
          do
          {
            v9 = __ldaxr(v8);
            v10 = v9 - 1;
          }
          while (__stlxr(v10, v8));
          if (!v10)
            this = (CA::Render::Object *)(*(uint64_t (**)(CA::Render::Object *))(*(_QWORD *)this + 16))(this);
        }
        if (v4)
        {
          v11 = (unsigned int *)((char *)v4 + 8);
          do
            v12 = __ldaxr(v11);
          while (__stlxr(v12 + 1, v11));
          if (!v12)
          {
            v4 = 0;
            do
              v35 = __ldaxr(v11);
            while (__stlxr(v35 - 1, v11));
          }
        }
        *((_QWORD *)v6 + 6) = v4;
      }
    }
  }
  return this;
}

uint64_t CA::Render::EmitterLayer::get_property(CA::Render::EmitterLayer *this, unint64_t a2, unsigned int *a3, unint64_t a4, double *a5, double **a6)
{
  unint64_t v6;
  double *v8;
  unsigned int *v10;
  unsigned int v12;
  uint64_t cell;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t behavior;
  const CA::Render::KeyValueArray *v18;
  double v19;
  float v20;
  unsigned int v21;
  unint64_t v22;
  float *v23;
  float v24;
  unsigned int v25;
  float64x2_t v26;
  unsigned int v27;
  uint64_t v28;
  unsigned int named_object;
  uint64_t v30;
  float32x2_t v31;
  float64x2_t v32;
  unsigned int v33;
  unsigned int v34;
  unint64_t v35;
  _OWORD v36[2];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (a4 < 4)
    return 0;
  v8 = a5;
  v10 = a3;
  v6 = a2;
  if (a6)
    *a6 = a5;
  v12 = *a3;
  if (a2 < 2 || v12 != 197)
  {
    if (a2 >= 2 && v12 == 196)
    {
      behavior = CA::Render::emitter_find_behavior(*((_QWORD *)this + 5), a3[1]);
      if (behavior)
      {
        if (v6 == 4)
        {
          v28 = v10[3];
          if ((v28 & 0x40000000) == 0)
            return 0;
          v6 = *(_QWORD *)(behavior + 32);
          if (!v6)
            return v6;
          named_object = CA::Render::KeyValueArray::find_named_object_(*(CA::Render::KeyValueArray **)(behavior + 32), (const CA::Render::KeyValueArray *)v10[2]);
          if ((named_object & 0x80000000) != 0)
            return 0;
          v30 = *(_QWORD *)(*(_QWORD *)(v6 + 8 * named_object + 24) + 24);
          if (!v30 || *(_BYTE *)(v30 + 12) != 56 || (v28 & 0xBFFFFFFF) >= *(_DWORD *)(v30 + 16))
            return 0;
          v19 = *(double *)(v30 + 8 * (v28 & 0xFFFFFFFFBFFFFFFFLL) + 24);
        }
        else
        {
          if (v6 != 3)
            return 0;
          v18 = (const CA::Render::KeyValueArray *)v10[2];
          if ((_DWORD)v18 != 208)
          {
            v6 = *(_QWORD *)(behavior + 32);
            if (!v6)
              return v6;
            v34 = CA::Render::KeyValueArray::find_named_object_(*(CA::Render::KeyValueArray **)(behavior + 32), v18);
            if ((v34 & 0x80000000) == 0)
            {
              v6 = *(_QWORD *)(*(_QWORD *)(v6 + 8 * v34 + 24) + 24);
              if (!v6)
                return v6;
              if (*(_BYTE *)(v6 + 12) == 56)
              {
                v35 = *(unsigned int *)(v6 + 16);
                if (v35 <= a4)
                {
                  memcpy(v8, (const void *)(v6 + 24), 8 * v35);
                  return *(unsigned int *)(v6 + 16);
                }
              }
            }
            return 0;
          }
          v19 = 1.0;
          if ((*(_DWORD *)(behavior + 12) & 0x100) == 0)
            v19 = 0.0;
        }
LABEL_26:
        *v8 = v19;
        return 1;
      }
    }
LABEL_30:
    if (!v6)
      return v6;
    if (v6 == 1)
    {
      *(_QWORD *)&v36[0] = 0;
      v21 = CA::Render::emitter_atom_param_index((CA::Render *)*v10, v36, (unint64_t *)a3);
      if ((v21 & 0x80000000) == 0)
      {
        v22 = *(_QWORD *)&v36[0];
        if (*(_QWORD *)&v36[0] >= a4)
          v22 = a4;
        if (v22)
        {
          v23 = (float *)((char *)this + 4 * v21 + 76);
          do
          {
            v24 = *v23++;
            *v8++ = v24;
            --v22;
          }
          while (v22);
        }
      }
      return 0;
    }
    v25 = *v10;
    if (*v10 == 156)
    {
      v31 = *(float32x2_t *)((char *)this + 128);
      v32 = vcvtq_f64_f32(vsub_f32(*(float32x2_t *)((char *)this + 136), v31));
      v36[0] = vcvtq_f64_f32(v31);
      v36[1] = v32;
      return CA::Render::get_rect_property((CA::Render *)v36, (const CA::Rect *)(v6 - 1), (int *)v10 + 1, (unsigned int *)v8, a5);
    }
    if (v25 == 205)
    {
      if ((_DWORD)v6 != 2)
        return 0;
      v26 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 100));
      v33 = v10[1];
      if (v33 == 593)
        goto LABEL_58;
      if (v33 != 250)
        return 0;
    }
    else
    {
      if (v25 != 202 || (_DWORD)v6 != 2)
        return 0;
      v26 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 88));
      v27 = v10[1];
      if (v27 == 596)
        goto LABEL_58;
      if (v27 != 600)
        return 0;
    }
    v26.f64[0] = v26.f64[1];
LABEL_58:
    *v8 = v26.f64[0];
    return 1;
  }
  cell = CA::Render::emitter_find_cell(*((_QWORD *)this + 4), a3[1]);
  if (!cell)
    return 0;
  v14 = cell;
  v10 += 2;
  for (v6 -= 2; v6; v6 -= 2)
  {
    v15 = *v10;
    v16 = CA::Render::cell_atom_param_index(*v10);
    if ((v16 & 0x80000000) == 0)
    {
      v19 = *(float *)(v14 + 4 * v16 + 72);
      goto LABEL_26;
    }
    if (v6 < 2 || v15 != 197)
    {
      if (v15 != 90)
        goto LABEL_30;
      v20 = *(float *)(v14 + 176);
      *(float64x2_t *)v8 = vcvtq_f64_f32(vmul_n_f32(*(float32x2_t *)(v14 + 164), 1.0 / v20));
      v8[2] = (float)(*(float *)(v14 + 172) * (float)(1.0 / v20));
      v8[3] = v20;
      return 4;
    }
    v14 = CA::Render::emitter_find_cell(*(_QWORD *)(v14 + 40), v10[1]);
    v10 += 2;
    if (!v14)
      return 0;
  }
  return v6;
}

float32x2_t CA::Render::EmitterLayer::set_property(CA::Render::EmitterLayer *this, unint64_t a2, unsigned int *a3, const unsigned int *a4, CA::Render::Vector *a5, double *a6, const double *a7, float32x2_t result)
{
  unsigned int *v11;
  unint64_t i;
  uint64_t v14;
  unint64_t v15;
  uint64_t cell;
  uint64_t v17;
  unsigned int v18;
  uint64_t behavior;
  const double *v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  unsigned int v25;
  double v26;
  float v27;
  float v28;
  unsigned int v29;
  float64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float64x2_t v34;
  unsigned int v35;
  double v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int named_object;
  const double *v40;
  uint64_t v41;
  unint64_t v42;
  CA::Render::Vector *v43;
  CA::Render::Object *v44;
  unsigned int *v45;
  unsigned int v46;
  unsigned int v47;
  float32x2_t v48;
  float64x2_t v49;
  float64x2_t v50;
  unsigned int v51;
  double v52;
  CA::Render::Object *v53;
  uint64_t v54;
  unsigned int *v55;
  unsigned int v56;
  unsigned int v57;
  double v58;
  double v59;
  float64x2_t v60;
  float64x2_t v61;
  uint64_t v62;

  v11 = a3;
  i = a2;
  v62 = *MEMORY[0x1E0C80C00];
  v14 = *a3;
  v15 = a2 - 2;
  if (a2 < 2 || (_DWORD)v14 != 197)
  {
    if (a2 >= 2 && (_DWORD)v14 == 196)
    {
      behavior = CA::Render::emitter_find_behavior(*((_QWORD *)this + 5), a3[1]);
      if (behavior)
      {
        v21 = behavior;
        if (i == 4)
        {
          v37 = v11[3];
          if ((v37 & 0x40000000) != 0 && a5 == (CA::Render::Vector *)1)
          {
            v38 = *(_QWORD *)(behavior + 32);
            if (v38)
            {
              named_object = CA::Render::KeyValueArray::find_named_object_(*(CA::Render::KeyValueArray **)(behavior + 32), (const CA::Render::KeyValueArray *)v11[2]);
              if ((named_object & 0x80000000) == 0)
              {
                v41 = *(_QWORD *)(*(_QWORD *)(v38 + 8 * named_object + 24) + 24);
                if (v41)
                {
                  if (*(_BYTE *)(v41 + 12) == 56)
                  {
                    v42 = v37 & 0xFFFFFFFFBFFFFFFFLL;
                    v43 = (CA::Render::Vector *)*(unsigned int *)(v41 + 16);
                    if (v42 < v43)
                    {
                      v44 = (CA::Render::Object *)CA::Render::Vector::new_vector(v43, (const void *)(v41 + 24), v40);
                      *((double *)v44 + v42 + 3) = *a6;
                      CA::Render::KeyValueArray::set_key(*(CA::Render::KeyValueArray **)(v21 + 32), (const CA::Render::KeyValueArray *)v11[2], v44);
                      v45 = (unsigned int *)((char *)v44 + 8);
                      do
                      {
                        v46 = __ldaxr(v45);
                        v47 = v46 - 1;
                      }
                      while (__stlxr(v47, v45));
                      if (!v47)
                        (*(void (**)(CA::Render::Object *))(*(_QWORD *)v44 + 16))(v44);
                    }
                  }
                }
              }
            }
          }
        }
        else if (i == 3)
        {
          if (a5 == (CA::Render::Vector *)1 && v11[2] == 208)
          {
            result = *(float32x2_t *)a6;
            v22 = *(_DWORD *)(behavior + 12);
            if (*a6 <= 0.5)
              v23 = v22 & 0xFFFFFEFF;
            else
              v23 = v22 | 0x100;
            *(_DWORD *)(behavior + 12) = v23;
          }
          else if (*(_QWORD *)(behavior + 32))
          {
            v53 = (CA::Render::Object *)CA::Render::Vector::new_vector(a5, a6, v20);
            CA::Render::KeyValueArray::set_key(*(CA::Render::KeyValueArray **)(v21 + 32), (const CA::Render::KeyValueArray *)v11[2], v53);
            v54 = *(_QWORD *)(v21 + 40);
            if (v54)
            {
              (*(void (**)(uint64_t))(*(_QWORD *)v54 + 8))(v54);
              *(_QWORD *)(v21 + 40) = 0;
            }
            if (v53)
            {
              v55 = (unsigned int *)((char *)v53 + 8);
              do
              {
                v56 = __ldaxr(v55);
                v57 = v56 - 1;
              }
              while (__stlxr(v57, v55));
              if (!v57)
                (*(void (**)(CA::Render::Object *))(*(_QWORD *)v53 + 16))(v53);
            }
          }
        }
        return result;
      }
      LODWORD(v14) = *v11;
    }
    else
    {
LABEL_30:
      if (a5 && i == 1)
      {
        v60.f64[0] = 0.0;
        v29 = CA::Render::emitter_atom_param_index((CA::Render *)v14, &v60, (unint64_t *)a3);
        if ((v29 & 0x80000000) == 0)
        {
          v30 = v60.f64[0];
          if (*(_QWORD *)&v60.f64[0] <= (unint64_t)a5)
          {
            if (*(_QWORD *)&v60.f64[0])
            {
              v31 = 0;
              v32 = v29;
              do
              {
                if ((a4 & 1) != 0)
                {
                  *(double *)&result = *a6 + *((float *)this + v32 + 19);
                  v33 = v32;
                }
                else
                {
                  result = *(float32x2_t *)a6;
                  v33 = v31 + v29;
                }
                result.f32[0] = *(double *)&result;
                *((_DWORD *)this + v33 + 19) = result.i32[0];
                ++v31;
                ++a6;
                ++v32;
                --*(_QWORD *)&v30;
              }
              while (v30 != 0.0);
            }
          }
        }
        return result;
      }
      if (i < 2)
        return result;
    }
    switch((_DWORD)v14)
    {
      case 0x9C:
        v48 = *(float32x2_t *)((char *)this + 128);
        v49 = vcvtq_f64_f32(vsub_f32(*(float32x2_t *)((char *)this + 136), v48));
        v60 = vcvtq_f64_f32(v48);
        v61 = v49;
        CA::Render::set_rect_property(v60.f64, (Rect *)(i - 1), (int *)v11 + 1, a4, (unint64_t)a5, a6, a7);
        result = vcvt_f32_f64(vaddq_f64(v61, v60));
        *((float32x2_t *)this + 16) = vcvt_f32_f64(v60);
        *((double *)this + 17) = *(double *)&result;
        break;
      case 0xCD:
        v50 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 100));
        if ((_DWORD)i == 2)
        {
          v51 = v11[1];
          if (a5 && v51 == 593)
          {
            if ((a4 & 1) != 0)
              v52 = *a6 + v50.f64[0];
            else
              v52 = *a6;
            v50.f64[0] = v52;
          }
          else if (a5 && v51 == 250)
          {
            if ((a4 & 1) != 0)
              v59 = *a6 + v50.f64[1];
            else
              v59 = *a6;
            v50.f64[1] = v59;
          }
        }
        result = vcvt_f32_f64(v50);
        *(double *)((char *)this + 100) = *(double *)&result;
        break;
      case 0xCA:
        v34 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 88));
        if ((_DWORD)i == 2)
        {
          v35 = v11[1];
          if (a5 && v35 == 596)
          {
            if ((a4 & 1) != 0)
              v36 = *a6 + v34.f64[0];
            else
              v36 = *a6;
            v34.f64[0] = v36;
          }
          else if (a5 && v35 == 600)
          {
            if ((a4 & 1) != 0)
              v58 = *a6 + v34.f64[1];
            else
              v58 = *a6;
            v34.f64[1] = v58;
          }
        }
        result = vcvt_f32_f64(v34);
        *((double *)this + 11) = *(double *)&result;
        break;
    }
    return result;
  }
  cell = CA::Render::emitter_find_cell(*((_QWORD *)this + 4), a3[1]);
  if (cell)
  {
    v17 = cell;
    v11 += 2;
    for (i = v15; i; i -= 2)
    {
      v14 = *v11;
      v18 = CA::Render::cell_atom_param_index(v14);
      if (a5 && (v18 & 0x80000000) == 0)
      {
        if ((a4 & 1) != 0)
        {
          v24 = v18;
          *(double *)&result = *a6 + *(float *)(v17 + 4 * v18 + 72);
        }
        else
        {
          result = *(float32x2_t *)a6;
          v24 = v18;
        }
        result.f32[0] = *(double *)&result;
        *(_DWORD *)(v17 + 4 * v24 + 72) = result.i32[0];
        return result;
      }
      if (i < 2 || (_DWORD)v14 != 197)
      {
        if ((_DWORD)v14 == 90)
          v25 = 23;
        else
          v25 = v18;
        if ((unint64_t)a5 >= 4 && (v25 & 0x80000000) == 0)
        {
          v26 = a6[3];
          v27 = v26 * *a6;
          *(float *)(v17 + 72 + 4 * v25) = v27;
          v28 = a6[1] * v26;
          *(float *)(v17 + 72 + 4 * (v25 + 1)) = v28;
          *(double *)&result = a6[2] * v26;
          result.f32[0] = *(double *)&result;
          *(_DWORD *)(v17 + 72 + 4 * (v25 + 2)) = result.i32[0];
          result.f32[0] = v26;
          *(_DWORD *)(v17 + 72 + 4 * (v25 + 3)) = result.i32[0];
          return result;
        }
        goto LABEL_30;
      }
      v17 = CA::Render::emitter_find_cell(*(_QWORD *)(v17 + 40), v11[1]);
      v11 += 2;
      if (!v17)
        return result;
    }
  }
  return result;
}

void CA::Render::EmitterLayer::update(CA::Render::EmitterLayer *this@<X0>, CA::Render::Update *a2@<X1>, double a3@<D0>, double a4@<D1>, uint64_t a5@<X8>)
{
  uint64_t v7;
  double v10;
  double v11;
  int v12;
  int v13;
  __int128 *v14;
  uint64_t v15;
  uint64_t v16;
  double v17;
  double v18;
  double v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v7 = *((_QWORD *)this + 3);
  if (!v7 || (*((_DWORD *)a2 + 266) & 4) != 0)
  {
    v18 = INFINITY;
  }
  else
  {
    v19 = INFINITY;
    v10 = *((double *)this + 20) + a4 * -0.00416666667;
    os_unfair_lock_lock((os_unfair_lock_t)(v7 + 24));
    v11 = *(double *)(v7 + 88);
    if (vabdd_f64(a3, v11) <= v10)
    {
      v18 = v11 + v10;
    }
    else
    {
      *(_DWORD *)(v7 + 80) = 0;
      *(_OWORD *)(v7 + 32) = CA::Volume::null;
      *(_OWORD *)(v7 + 48) = unk_18475ED70;
      *(_OWORD *)(v7 + 64) = xmmword_18475ED80;
      if (v11 != a3)
        *(_BYTE *)(v7 + 129) = v11 < a3;
      *(_DWORD *)(v7 + 168) = 0;
      *(_QWORD *)(v7 + 136) = this;
      v20 = 0u;
      v21 = 0u;
      v12 = *((_DWORD *)this + 33);
      if ((*((_DWORD *)this + 32) & 0x7FFFFFFFu) >= 0x7F800000
        && (v12 & 0x7FFFFFFFu) >= 0x7F800000
        && (*((_DWORD *)this + 36) & 0x7FFFFFFFu) >= 0x7F800000
        && (*((_DWORD *)this + 37) & 0x7FFFFFFFu) >= 0x7F800000
        && (*((_DWORD *)this + 35) & 0x7FFFFFFFu) > 0x7F7FFFFF)
      {
        v14 = 0;
      }
      else
      {
        LODWORD(v20) = *((_DWORD *)this + 32);
        DWORD1(v20) = v12;
        v13 = *((_DWORD *)this + 37);
        DWORD2(v20) = *((_DWORD *)this + 36);
        *(_QWORD *)&v21 = *((_QWORD *)this + 17);
        DWORD2(v21) = v13;
        v14 = &v20;
      }
      v15 = *(_QWORD *)(v7 + 144);
      *(_QWORD *)(v7 + 176) = v14;
      if (*(_QWORD *)(v7 + 152) != v15)
        *(_QWORD *)(v7 + 152) = v15;
      *(_BYTE *)(v7 + 128) = CA::Render::EmitterState::update_cells((CA::Render::EmitterState *)v7, &v19, *((_QWORD *)this + 4), v7 + 112, 0, a3, *((float *)this + 19));
      if ((*((_BYTE *)this + 13) & 1) == 0)
      {
        *(_QWORD *)(v7 + 72) = 0;
        *(_QWORD *)(v7 + 48) = 0;
      }
      v16 = *(_QWORD *)(v7 + 144);
      if (*(_QWORD *)(v7 + 152) != v16)
        *(_QWORD *)(v7 + 152) = v16;
      *(_QWORD *)(v7 + 136) = 0;
      *(_QWORD *)(v7 + 176) = 0;
      *(double *)(v7 + 88) = a3;
      v17 = v10 + a3;
      if (v19 > v10 + a3)
        v17 = v19;
      if (*((double *)this + 20) == 0.0)
        v18 = v19;
      else
        v18 = v17;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 24));
  }
  *(double *)a5 = v18;
  *(int64x2_t *)(a5 + 8) = vdupq_n_s64(0x400000000uLL);
}

uint64_t CA::Render::EmitterLayer::has_depth(CA::Render::EmitterLayer *this)
{
  return *((_BYTE *)this + 13) & 1;
}

uint64_t CA::Render::EmitterLayer::get_bounds(CA::Render::EmitterLayer *this, const CA::Render::Layer *a2, int64x2_t *a3, CA::Rect *a4)
{
  uint64_t v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;

  v4 = *((_QWORD *)this + 3);
  if (!v4 || !*(_DWORD *)(v4 + 124))
    return 0;
  v5 = *(double *)(v4 + 32);
  v6 = *(double *)(v4 + 40);
  v7 = *(double *)(v4 + 64);
  v8 = *(double *)(v4 + 56) - v5;
  v9 = v7 - v6;
  if (v8 >= v7 - v6)
    v10 = v7 - v6;
  else
    v10 = *(double *)(v4 + 56) - v5;
  if (v10 > 0.0)
  {
    if (v8 <= v9)
      v11 = v9;
    else
      v11 = *(double *)(v4 + 56) - v5;
    if (v11 >= 1.79769313e308)
    {
      *a3 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
      a3[1] = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      if (!a4)
        return 1;
    }
    else
    {
      *(double *)a3->i64 = v5;
      *(double *)&a3->i64[1] = v6;
      *(double *)a3[1].i64 = v8;
      *(double *)&a3[1].i64[1] = v9;
      if (!a4)
        return 1;
    }
    goto LABEL_15;
  }
  *a3 = 0u;
  a3[1] = 0u;
  if (a4)
  {
LABEL_15:
    *(_OWORD *)a4 = 0u;
    *((_OWORD *)a4 + 1) = 0u;
  }
  return 1;
}

uint64_t CA::Render::EmitterLayer::get_volume(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v3;
  __int128 v4;
  __int128 v5;

  v3 = *(_QWORD *)(a1 + 24);
  if (!v3 || !*(_DWORD *)(v3 + 124))
    return 0;
  v4 = *(_OWORD *)(v3 + 32);
  v5 = *(_OWORD *)(v3 + 64);
  a3[1] = *(_OWORD *)(v3 + 48);
  a3[2] = v5;
  *a3 = v4;
  return 1;
}

uint64_t CA::Render::EmitterLayer::visit_subclass(uint64_t a1, uint64_t (***a2)(_QWORD, uint64_t))
{
  return (**a2)(a2, a1);
}

void CA::Render::`anonymous namespace'::push_behaviors(uint64_t a1, void **a2, _DWORD *a3)
{
  unint64_t v6;
  void (**v7)(CA::Render::EmitterBehaviors::Attractor *__hidden);
  uint64_t (**v8)();
  unint64_t v9;
  float v14;
  float v15;
  int v16;
  float v17;
  uint64_t v18;
  _DWORD *v19;
  int v20;
  malloc_zone_t *v21;
  _DWORD *v22;
  CA::Render::KeyValueArray *v23;
  float v24;
  malloc_zone_t *v25;
  _DWORD *v26;
  unsigned int *v27;
  double v28;
  float64x2_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  malloc_zone_t *v33;
  _DWORD *v34;
  const CA::Render::KeyValueArray *v35;
  malloc_zone_t *v36;
  _DWORD *v37;
  CA::Render::KeyValueArray *v38;
  float v39;
  double v40;
  float v41;
  float v42;
  float v43;
  float v44;
  malloc_zone_t *v45;
  _DWORD *v46;
  unsigned int *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  malloc_zone_t *v51;
  _DWORD *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  malloc_zone_t *v57;
  _DWORD *v58;
  unsigned int *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t (**v63)();
  void (**v64)(CA::Render::EmitterBehaviors::Attractor *__hidden);
  unsigned int *v65;
  unsigned int *v66;
  unsigned int *v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int *v70;
  unsigned int v71;
  int v72;
  int v73;
  malloc_zone_t *v74;
  _DWORD *v75;
  unsigned int *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unsigned int *v80;
  unsigned int *v81;
  unsigned int *v82;
  unsigned int v83;
  unsigned int v84;
  unsigned int *v85;
  unsigned int v86;
  int v87;
  int v88;
  malloc_zone_t *v89;
  _DWORD *v90;
  CA::Render::KeyValueArray *v91;
  float v92;
  int v93;
  __float2 v94;
  malloc_zone_t *malloc_zone;
  char *v96;
  unsigned int *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  float64x2_t v101;
  float64x2_t v102;
  float float_key;
  float v104;
  float vec2_key;
  double v106;
  unint64_t v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  int int_key;
  float v114;
  float v115;
  float v116;
  float cosval;
  float v118;
  float v119;
  malloc_zone_t *v120;
  _DWORD *v121;
  float v122;
  __float2 v123;
  __float2 v124;
  float v125;
  float v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  float v132;
  uint64_t v133;
  float v134;
  float v135;
  unsigned int *v136;
  unsigned int *v137;
  unsigned int v138;
  int v139;
  int v140;
  unsigned int *v141;
  unsigned int *v142;
  unsigned int v143;
  int v144;
  int v145;
  uint64_t v146;
  unsigned int *v147;
  unsigned int v148;
  unsigned int v149;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  unsigned int *v154;
  unsigned int v155;
  unsigned int v156;
  BOOL v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  malloc_zone_t *v168;
  _DWORD *v169;
  uint64_t v170;
  int v171;
  float *v172;
  uint64_t v173;
  double *v174;
  uint64_t v175;
  double v176;
  float v177;
  uint64_t v178;
  malloc_zone_t *v179;
  _DWORD *v180;
  uint64_t v181;
  int v182;
  float *v183;
  uint64_t v184;
  double *v185;
  uint64_t v186;
  double v187;
  float v188;
  unsigned int *v189;
  unsigned int v190;
  unsigned int v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  unint64_t v199;
  malloc_zone_t *v200;
  CA::Render::Gradient *v201;
  uint64_t v202;
  unsigned int *v203;
  unsigned int *v204;
  unsigned int v205;
  BOOL v206;
  unsigned int *v207;
  unsigned int v208;
  unsigned int v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  unint64_t v217;
  malloc_zone_t *v218;
  CA::Render::Gradient *v219;
  uint64_t v220;
  unsigned int *v221;
  unsigned int v222;
  float *v223;
  uint64_t v224;
  double *v225;
  uint64_t v226;
  double v227;
  float v228;
  unsigned int *v229;
  unsigned int v230;
  float *v231;
  uint64_t v232;
  double *v233;
  uint64_t v234;
  double v235;
  float v236;
  unsigned int *v237;
  unsigned int v238;
  unint64_t v239;
  _QWORD *v240;
  _QWORD *v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  unint64_t v245;
  uint64_t v246;
  _QWORD *v247;
  char *v248;
  char *v249;
  uint64_t v250;
  unsigned int v251;
  unsigned int v252;
  unsigned int v253;
  unsigned int v254;
  uint64_t v255;
  uint64_t v256;
  float64x2_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;

  v260 = *MEMORY[0x1E0C80C00];
  if (a1 && *(_DWORD *)(a1 + 16))
  {
    v6 = 0;
    v7 = off_1E1597AC0;
    v8 = off_1E1597B20;
    v9 = 0xBF80000000000000;
    __asm { FMOV            V0.2D, #1.0 }
    v257 = _Q0;
    v14 = 1.0;
    v15 = 100000.0;
    *(float *)&v16 = 0.001;
    v17 = -1.0;
    do
    {
      v18 = *(_QWORD *)(a1 + 8 * v6 + 24);
      if ((*(_BYTE *)(v18 + 13) & 1) == 0)
        goto LABEL_367;
      v19 = *(_DWORD **)(v18 + 40);
      if (v19)
        goto LABEL_349;
      v20 = *(_DWORD *)(v18 + 16);
      if (v20 > 339)
      {
        if (v20 <= 573)
        {
          if (v20 == 340)
          {
            malloc_zone = (malloc_zone_t *)get_malloc_zone();
            v96 = (char *)malloc_type_zone_malloc(malloc_zone, 0x50uLL, 0x8BB15036uLL);
            if (v96)
            {
              v19 = v96;
              v97 = *(unsigned int **)(v18 + 32);
              *((_DWORD *)v96 + 2) = 1;
              *(_QWORD *)v96 = off_1E1597A90;
              if (!v97)
                goto LABEL_113;
              v98 = v97[4];
              if (!(_DWORD)v98)
                goto LABEL_113;
              v99 = 0;
              while (1)
              {
                v100 = *(_QWORD *)&v97[2 * v99 + 6];
                if (*(_DWORD *)(v100 + 16) == 90)
                  break;
                if (v98 == ++v99)
                  goto LABEL_113;
              }
              v101 = v257;
              v102 = v257;
              if ((v99 & 0x80000000) != 0)
                goto LABEL_114;
              v146 = *(_QWORD *)(v100 + 24);
              if (v146)
              {
                v101 = v257;
                v102 = v257;
                if (*(_BYTE *)(v146 + 12) == 56)
                {
                  v101 = v257;
                  v102 = v257;
                  if (*(_DWORD *)(v146 + 16) >= 4u)
                  {
                    v101 = *(float64x2_t *)(v146 + 40);
                    v102 = *(float64x2_t *)(v146 + 24);
                  }
                }
              }
              else
              {
LABEL_113:
                v101 = v257;
                v102 = v257;
              }
LABEL_114:
              *(float32x4_t *)(v96 + 12) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v102), v101);
              float_key = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v97, (const CA::Render::KeyValueArray *)0x18, 0.0);
              *((float *)v19 + 7) = float_key;
              v104 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v97, (const CA::Render::KeyValueArray *)0xAB, 1.0);
              *((float *)v19 + 8) = v104;
              v258 = 0;
              v259 = 0;
              vec2_key = CA::Render::KeyValueArray::get_vec2_key((CA::Render::KeyValueArray *)v97, (const CA::Render::KeyValueArray *)0x1AD, (uint64_t)&v258);
              *(float *)&v106 = v106;
              *((float *)v19 + 9) = vec2_key;
              v19[10] = LODWORD(v106);
              v19[11] = 0;
              if (CA::Render::KeyValueArray::get_int_key((CA::Render::KeyValueArray *)v97, (const CA::Render::KeyValueArray *)0x21, 1))v19[2] = 3;
              v107 = v9;
              v108 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v97, (const CA::Render::KeyValueArray *)0x25C, 0.0);
              *((float *)v19 + 11) = v108;
              v109 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v97, (const CA::Render::KeyValueArray *)0xD9, 0.0);
              v110 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v97, (const CA::Render::KeyValueArray *)0xD8, INFINITY);
              v111 = 0.0;
              if (v109 >= 0.0)
                v112 = v109;
              else
                v112 = 0.0;
              if ((LODWORD(v110) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
              {
                v111 = v14 / v110;
                if (v110 < 0.00001)
                  v111 = v15;
              }
              *((float *)v19 + 12) = v112 * v112;
              *((float *)v19 + 13) = v111 * v111;
              int_key = CA::Render::KeyValueArray::get_int_key((CA::Render::KeyValueArray *)v97, (const CA::Render::KeyValueArray *)0x208, 0);
              *((_BYTE *)v19 + 56) = int_key != 0;
              if (int_key)
              {
                v114 = *(float *)&v16;
                v115 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v97, (const CA::Render::KeyValueArray *)0xAD, 1.57079633);
                v116 = v15;
                if (fabsf(v115) >= 0.00001)
                {
                  v122 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v97, (const CA::Render::KeyValueArray *)0xAE, -1.57079633);
                  v123 = __sincosf_stret(v122);
                  v124 = __sincosf_stret(v115);
                  cosval = v124.__cosval;
                  v118 = v124.__sinval * v123.__cosval;
                  v119 = v124.__sinval * v123.__sinval;
                }
                else
                {
                  cosval = 1.0;
                  v118 = 0.0;
                  v119 = 0.0;
                }
                *((float *)v19 + 15) = v118;
                *((float *)v19 + 16) = v119;
                *((float *)v19 + 17) = cosval;
                v125 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v97, (const CA::Render::KeyValueArray *)0x71, 1.57079633);
                v126 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v97, (const CA::Render::KeyValueArray *)0x72, 0.174532925);
                v127 = v125 * 0.5;
                v128 = cosf(v127);
                v129 = cosf(v127 + v126);
                v130 = v128 - v129;
                v14 = 1.0;
                v131 = 1.0 / v130;
                _NF = v130 < v114;
                v132 = 1000.0;
                if (!_NF)
                  v132 = v131;
                *((float *)v19 + 18) = v129;
                *((float *)v19 + 19) = v132;
                v15 = v116;
                *(float *)&v16 = v114;
              }
              v9 = v107;
              v17 = -1.0;
              goto LABEL_348;
            }
            goto LABEL_125;
          }
          if (v20 == 500)
          {
            v36 = (malloc_zone_t *)get_malloc_zone();
            v37 = malloc_type_zone_malloc(v36, 0x28uLL, 0x8BB15036uLL);
            if (v37)
            {
              v19 = v37;
              v38 = *(CA::Render::KeyValueArray **)(v18 + 32);
              v37[2] = 0;
              *(_QWORD *)v37 = off_1E15979D0;
              v258 = 0;
              v259 = 0;
              v39 = CA::Render::KeyValueArray::get_vec2_key(v38, (const CA::Render::KeyValueArray *)0x1AD, (uint64_t)&v258);
              *(float *)&v40 = v40;
              *((float *)v19 + 3) = v39;
              v19[4] = LODWORD(v40);
              v41 = CA::Render::KeyValueArray::get_float_key(v38, (const CA::Render::KeyValueArray *)0x20F, 1.0);
              *((float *)v19 + 5) = v41;
              v42 = CA::Render::KeyValueArray::get_float_key(v38, (const CA::Render::KeyValueArray *)0x1BB, 0.0);
              *((float *)v19 + 6) = v41 * v42;
              v43 = CA::Render::KeyValueArray::get_float_key(v38, (const CA::Render::KeyValueArray *)0xD8, INFINITY);
              v44 = 0.0;
              if (v43 != 0.0 && (LODWORD(v43) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
                v44 = v14 / v43;
              *((float *)v19 + 7) = v43 * v43;
              *((float *)v19 + 8) = v44 * v44;
              goto LABEL_348;
            }
            goto LABEL_125;
          }
        }
        else
        {
          switch(v20)
          {
            case 574:
              v57 = (malloc_zone_t *)get_malloc_zone();
              v58 = malloc_type_zone_malloc(v57, 0x60uLL, 0x8BB15036uLL);
              if (v58)
              {
                v19 = v58;
                v59 = *(unsigned int **)(v18 + 32);
                v58[2] = 0;
                *(_QWORD *)v58 = off_1E1597B80;
                CA::Render::EmitterBehaviors::DistanceFunction::DistanceFunction((CA::Render::EmitterBehaviors::DistanceFunction *)(v58 + 3), (const CA::Render::KeyValueArray *)v59);
                *((_QWORD *)v19 + 10) = 0;
                CA::Render::EmitterBehaviors::ValueMutator::ValueMutator((CA::Render::EmitterBehaviors::ValueMutator *)(v19 + 22), (const CA::Render::KeyValueArray *)v59);
                if ((v19[22] & 0x80000000) != 0)
                  goto LABEL_348;
                if (v59 && (v60 = v59[4], (_DWORD)v60))
                {
                  v61 = 0;
                  while (1)
                  {
                    v62 = *(_QWORD *)&v59[2 * v61 + 6];
                    if (*(_DWORD *)(v62 + 16) == 240)
                      break;
                    if (v60 == ++v61)
                      goto LABEL_56;
                  }
                  v63 = v8;
                  v64 = v7;
                  if ((v61 & 0x80000000) == 0)
                  {
                    v65 = *(unsigned int **)(v62 + 24);
LABEL_58:
                    v66 = (unsigned int *)*((_QWORD *)v19 + 10);
                    if (v66 != v65)
                    {
                      if (v66)
                      {
                        v67 = v66 + 2;
                        do
                        {
                          v68 = __ldaxr(v67);
                          v69 = v68 - 1;
                        }
                        while (__stlxr(v69, v67));
                        if (!v69)
                          (*(void (**)(unsigned int *))(*(_QWORD *)v66 + 16))(v66);
                      }
                      if (v65)
                      {
                        v70 = v65 + 2;
                        do
                          v71 = __ldaxr(v70);
                        while (__stlxr(v71 + 1, v70));
                        if (!v71)
                        {
                          do
                          {
                            v65 = 0;
                            v251 = __ldaxr(v70);
                          }
                          while (__stlxr(v251 - 1, v70));
                        }
                      }
                      *((_QWORD *)v19 + 10) = v65;
                    }
                    if (v65)
                    {
                      if (*((_BYTE *)v65 + 12) != 18)
                      {
                        *((_QWORD *)v19 + 10) = 0;
                        goto LABEL_166;
                      }
                      v72 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v65 + 104))(v65);
                      v65 = (unsigned int *)*((_QWORD *)v19 + 10);
                      if (v72 != 1
                        || (v73 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v65 + 112))(*((_QWORD *)v19 + 10)),
                            v65 = (unsigned int *)*((_QWORD *)v19 + 10),
                            v73 != 1))
                      {
                        *((_QWORD *)v19 + 10) = 0;
                        if (!v65)
                          goto LABEL_74;
LABEL_166:
                        v147 = v65 + 2;
                        do
                        {
                          v148 = __ldaxr(v147);
                          v149 = v148 - 1;
                        }
                        while (__stlxr(v149, v147));
                        if (!v149)
                          (*(void (**)(unsigned int *))(*(_QWORD *)v65 + 16))(v65);
                        v65 = (unsigned int *)*((_QWORD *)v19 + 10);
                      }
                      if (v65)
                        _ZF = 1;
                      else
                        _ZF = v59 == 0;
                      if (_ZF)
                        goto LABEL_195;
                    }
                    else
                    {
LABEL_74:
                      if (!v59)
                        goto LABEL_195;
                    }
                    v151 = v59[4];
                    if ((_DWORD)v151)
                    {
                      v152 = 0;
                      v8 = v63;
                      while (1)
                      {
                        v153 = *(_QWORD *)&v59[2 * v152 + 6];
                        if (*(_DWORD *)(v153 + 16) == 576)
                          break;
                        if (v151 == ++v152)
                          goto LABEL_202;
                      }
                      if ((v152 & 0x80000000) == 0)
                      {
                        v161 = *(_QWORD *)(v153 + 24);
                        goto LABEL_203;
                      }
LABEL_202:
                      v161 = 0;
LABEL_203:
                      v162 = 0;
                      while (1)
                      {
                        v163 = *(_QWORD *)&v59[2 * v162 + 6];
                        if (*(_DWORD *)(v163 + 16) == 356)
                          break;
                        if (v151 == ++v162)
                          goto LABEL_216;
                      }
                      if ((v162 & 0x80000000) == 0)
                      {
                        v167 = *(_QWORD *)(v163 + 24);
                        goto LABEL_217;
                      }
LABEL_216:
                      v167 = 0;
LABEL_217:
                      if (v161 && *(_BYTE *)(v161 + 12) == 56)
                      {
                        if (v167 && (*(_BYTE *)(v167 + 12) != 56 || *(_DWORD *)(v167 + 16) != *(_DWORD *)(v161 + 16)))
                          v167 = 0;
                        v255 = *(unsigned int *)(v161 + 16);
                        v168 = (malloc_zone_t *)get_malloc_zone();
                        v169 = malloc_type_zone_calloc(v168, 1uLL, 0x38uLL, 0x743898A5uLL);
                        v170 = (uint64_t)v169;
                        if (v169)
                        {
                          v169[2] = 1;
                          ++dword_1ECDC7C70;
                          *(_QWORD *)v169 = off_1E1598230;
                          *((_QWORD *)v169 + 2) = v255;
                          v169[6] = 1;
                          *((float *)v169 + 7) = (float)v255 + v17;
                          *((_QWORD *)v169 + 5) = 0;
                          *((_QWORD *)v169 + 6) = 0;
                          *((_QWORD *)v169 + 4) = 0;
                          if (v167)
                            v171 = 530;
                          else
                            v171 = 18;
                          v169[3] = v171;
                          CA::Render::InterpolatedFunction::allocate_storage((CA::Render::InterpolatedFunction *)v169);
                          v172 = *(float **)(v170 + 32);
                          if (v172)
                          {
                            v173 = *(_QWORD *)(v170 + 16) * *(unsigned int *)(v170 + 24);
                            if (v173)
                            {
                              v174 = (double *)(v161 + 24);
                              v175 = 8 * v173;
                              do
                              {
                                v176 = *v174++;
                                v177 = v176;
                                *v172++ = v177;
                                v175 -= 8;
                              }
                              while (v175);
                            }
                          }
                        }
                        else
                        {
                          v223 = (float *)MEMORY[0x20];
                          if (MEMORY[0x20])
                          {
                            v224 = MEMORY[0x10] * MEMORY[0x18];
                            if (v224)
                            {
                              v225 = (double *)(v161 + 24);
                              v226 = 8 * v224;
                              do
                              {
                                v227 = *v225++;
                                v228 = v227;
                                *v223++ = v228;
                                v226 -= 8;
                              }
                              while (v226);
                            }
                          }
                        }
                        if (v167)
                          CA::Render::InterpolatedFunction::set_locations(v170, (const double *)(v167 + 24));
                        v203 = (unsigned int *)*((_QWORD *)v19 + 10);
                        *((_QWORD *)v19 + 10) = v170;
                        if (v203)
                        {
                          v229 = v203 + 2;
                          v7 = off_1E1597AC0;
                          do
                          {
                            v230 = __ldaxr(v229);
                            v206 = --v230 == 0;
                          }
                          while (__stlxr(v230, v229));
LABEL_344:
                          if (v206)
                            (*(void (**)(unsigned int *))(*(_QWORD *)v203 + 16))(v203);
                          goto LABEL_348;
                        }
                      }
LABEL_347:
                      v7 = off_1E1597AC0;
                      goto LABEL_348;
                    }
LABEL_195:
                    v7 = v64;
                    v8 = v63;
                    goto LABEL_348;
                  }
                }
                else
                {
LABEL_56:
                  v63 = v8;
                  v64 = v7;
                }
                v65 = 0;
                goto LABEL_58;
              }
              goto LABEL_125;
            case 575:
              v74 = (malloc_zone_t *)get_malloc_zone();
              v75 = malloc_type_zone_malloc(v74, 0x20uLL, 0x8BB15036uLL);
              if (v75)
              {
                v19 = v75;
                v76 = *(unsigned int **)(v18 + 32);
                v75[2] = 0;
                *(_QWORD *)v75 = off_1E1597B50;
                *((_QWORD *)v75 + 2) = 0;
                CA::Render::EmitterBehaviors::ValueMutator::ValueMutator((CA::Render::EmitterBehaviors::ValueMutator *)(v75 + 6), (const CA::Render::KeyValueArray *)v76);
                if ((v19[6] & 0x80000000) == 0)
                {
                  if (v76 && (v77 = v76[4], (_DWORD)v77))
                  {
                    v78 = 0;
                    while (1)
                    {
                      v79 = *(_QWORD *)&v76[2 * v78 + 6];
                      if (*(_DWORD *)(v79 + 16) == 240)
                        break;
                      if (v77 == ++v78)
                        goto LABEL_83;
                    }
                    v63 = v8;
                    v64 = v7;
                    if ((v78 & 0x80000000) == 0)
                    {
                      v80 = *(unsigned int **)(v79 + 24);
LABEL_85:
                      v81 = (unsigned int *)*((_QWORD *)v19 + 2);
                      if (v81 != v80)
                      {
                        if (v81)
                        {
                          v82 = v81 + 2;
                          do
                          {
                            v83 = __ldaxr(v82);
                            v84 = v83 - 1;
                          }
                          while (__stlxr(v84, v82));
                          if (!v84)
                            (*(void (**)(unsigned int *))(*(_QWORD *)v81 + 16))(v81);
                        }
                        if (v80)
                        {
                          v85 = v80 + 2;
                          do
                            v86 = __ldaxr(v85);
                          while (__stlxr(v86 + 1, v85));
                          if (!v86)
                          {
                            do
                            {
                              v80 = 0;
                              v252 = __ldaxr(v85);
                            }
                            while (__stlxr(v252 - 1, v85));
                          }
                        }
                        *((_QWORD *)v19 + 2) = v80;
                      }
                      if (v80)
                      {
                        if (*((_BYTE *)v80 + 12) != 18)
                        {
                          *((_QWORD *)v19 + 2) = 0;
                          goto LABEL_181;
                        }
                        v87 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v80 + 104))(v80);
                        v80 = (unsigned int *)*((_QWORD *)v19 + 2);
                        if (v87 != 1
                          || (v88 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v80 + 112))(*((_QWORD *)v19 + 2)),
                              v80 = (unsigned int *)*((_QWORD *)v19 + 2),
                              v88 != 1))
                        {
                          *((_QWORD *)v19 + 2) = 0;
                          if (!v80)
                            goto LABEL_101;
LABEL_181:
                          v154 = v80 + 2;
                          do
                          {
                            v155 = __ldaxr(v154);
                            v156 = v155 - 1;
                          }
                          while (__stlxr(v156, v154));
                          if (!v156)
                            (*(void (**)(unsigned int *))(*(_QWORD *)v80 + 16))(v80);
                          v80 = (unsigned int *)*((_QWORD *)v19 + 2);
                        }
                        if (v80)
                          v157 = 1;
                        else
                          v157 = v76 == 0;
                        if (!v157)
                        {
LABEL_190:
                          v158 = v76[4];
                          if ((_DWORD)v158)
                          {
                            v159 = 0;
                            v8 = v63;
                            while (1)
                            {
                              v160 = *(_QWORD *)&v76[2 * v159 + 6];
                              if (*(_DWORD *)(v160 + 16) == 576)
                                break;
                              if (v158 == ++v159)
                                goto LABEL_209;
                            }
                            if ((v159 & 0x80000000) == 0)
                            {
                              v164 = *(_QWORD *)(v160 + 24);
                              goto LABEL_210;
                            }
LABEL_209:
                            v164 = 0;
LABEL_210:
                            v165 = 0;
                            while (1)
                            {
                              v166 = *(_QWORD *)&v76[2 * v165 + 6];
                              if (*(_DWORD *)(v166 + 16) == 356)
                                break;
                              if (v158 == ++v165)
                                goto LABEL_234;
                            }
                            if ((v165 & 0x80000000) == 0)
                            {
                              v178 = *(_QWORD *)(v166 + 24);
                              goto LABEL_235;
                            }
LABEL_234:
                            v178 = 0;
LABEL_235:
                            if (v164 && *(_BYTE *)(v164 + 12) == 56)
                            {
                              if (v178
                                && (*(_BYTE *)(v178 + 12) != 56 || *(_DWORD *)(v178 + 16) != *(_DWORD *)(v164 + 16)))
                              {
                                v178 = 0;
                              }
                              v256 = *(unsigned int *)(v164 + 16);
                              v179 = (malloc_zone_t *)get_malloc_zone();
                              v180 = malloc_type_zone_calloc(v179, 1uLL, 0x38uLL, 0x743898A5uLL);
                              v181 = (uint64_t)v180;
                              if (v180)
                              {
                                v180[2] = 1;
                                ++dword_1ECDC7C70;
                                *(_QWORD *)v180 = off_1E1598230;
                                *((_QWORD *)v180 + 2) = v256;
                                v180[6] = 1;
                                *((float *)v180 + 7) = (float)v256 + v17;
                                *((_QWORD *)v180 + 5) = 0;
                                *((_QWORD *)v180 + 6) = 0;
                                *((_QWORD *)v180 + 4) = 0;
                                if (v178)
                                  v182 = 530;
                                else
                                  v182 = 18;
                                v180[3] = v182;
                                CA::Render::InterpolatedFunction::allocate_storage((CA::Render::InterpolatedFunction *)v180);
                                v183 = *(float **)(v181 + 32);
                                if (v183)
                                {
                                  v184 = *(_QWORD *)(v181 + 16) * *(unsigned int *)(v181 + 24);
                                  if (v184)
                                  {
                                    v185 = (double *)(v164 + 24);
                                    v186 = 8 * v184;
                                    do
                                    {
                                      v187 = *v185++;
                                      v188 = v187;
                                      *v183++ = v188;
                                      v186 -= 8;
                                    }
                                    while (v186);
                                  }
                                }
                              }
                              else
                              {
                                v231 = (float *)MEMORY[0x20];
                                if (MEMORY[0x20])
                                {
                                  v232 = MEMORY[0x10] * MEMORY[0x18];
                                  if (v232)
                                  {
                                    v233 = (double *)(v164 + 24);
                                    v234 = 8 * v232;
                                    do
                                    {
                                      v235 = *v233++;
                                      v236 = v235;
                                      *v231++ = v236;
                                      v234 -= 8;
                                    }
                                    while (v234);
                                  }
                                }
                              }
                              if (v178)
                                CA::Render::InterpolatedFunction::set_locations(v181, (const double *)(v178 + 24));
                              v203 = (unsigned int *)*((_QWORD *)v19 + 2);
                              *((_QWORD *)v19 + 2) = v181;
                              if (v203)
                              {
                                v237 = v203 + 2;
                                v7 = off_1E1597AC0;
                                do
                                {
                                  v238 = __ldaxr(v237);
                                  v206 = --v238 == 0;
                                }
                                while (__stlxr(v238, v237));
                                goto LABEL_344;
                              }
                            }
                            goto LABEL_347;
                          }
                        }
                      }
                      else
                      {
LABEL_101:
                        if (v76)
                          goto LABEL_190;
                      }
                      goto LABEL_195;
                    }
                  }
                  else
                  {
LABEL_83:
                    v63 = v8;
                    v64 = v7;
                  }
                  v80 = 0;
                  goto LABEL_85;
                }
LABEL_348:
                *(_QWORD *)(v18 + 40) = v19;
LABEL_349:
                if ((*(unsigned int (**)(_DWORD *))(*(_QWORD *)v19 + 16))(v19))
                {
                  v240 = a2[1];
                  v239 = (unint64_t)a2[2];
                  if ((unint64_t)v240 >= v239)
                  {
                    v242 = ((char *)v240 - (_BYTE *)*a2) >> 3;
                    if ((unint64_t)(v242 + 1) >> 61)
                      abort();
                    v243 = v239 - (_QWORD)*a2;
                    v244 = v243 >> 2;
                    if (v243 >> 2 <= (unint64_t)(v242 + 1))
                      v244 = v242 + 1;
                    if ((unint64_t)v243 >= 0x7FFFFFFFFFFFFFF8)
                      v245 = 0x1FFFFFFFFFFFFFFFLL;
                    else
                      v245 = v244;
                    if (v245)
                      v245 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Display::DisplayLinkItem *>>(v245);
                    else
                      v246 = 0;
                    v247 = (_QWORD *)(v245 + 8 * v242);
                    *v247 = v19;
                    v241 = v247 + 1;
                    v249 = (char *)*a2;
                    v248 = (char *)a2[1];
                    if (v248 != *a2)
                    {
                      do
                      {
                        v250 = *((_QWORD *)v248 - 1);
                        v248 -= 8;
                        *--v247 = v250;
                      }
                      while (v248 != v249);
                      v248 = (char *)*a2;
                    }
                    *a2 = v247;
                    a2[1] = v241;
                    a2[2] = (void *)(v245 + 8 * v246);
                    if (v248)
                      operator delete(v248);
                  }
                  else
                  {
                    *v240 = v19;
                    v241 = v240 + 1;
                  }
                  a2[1] = v241;
                  *a3 |= v19[2];
                }
                goto LABEL_367;
              }
              goto LABEL_125;
            case 592:
              v25 = (malloc_zone_t *)get_malloc_zone();
              v26 = malloc_type_zone_malloc(v25, 0x20uLL, 0x8BB15036uLL);
              if (v26)
              {
                v19 = v26;
                v27 = *(unsigned int **)(v18 + 32);
                v19[2] = 0;
                *(_QWORD *)v19 = off_1E1597A60;
                v28 = 0.0;
                v29 = (float64x2_t)xmmword_18474E5D0;
                if (v27)
                {
                  v30 = v27[4];
                  if ((_DWORD)v30)
                  {
                    v31 = 0;
                    while (1)
                    {
                      v32 = *(_QWORD *)&v27[2 * v31 + 6];
                      if (*(_DWORD *)(v32 + 16) == 229)
                        break;
                      if (v30 == ++v31)
                        goto LABEL_139;
                    }
                    if ((v31 & 0x80000000) == 0)
                    {
                      v133 = *(_QWORD *)(v32 + 24);
                      if (v133)
                      {
                        if (*(_BYTE *)(v133 + 12) == 56 && *(_DWORD *)(v133 + 16) >= 3u)
                        {
                          v28 = *(double *)(v133 + 40);
                          v29 = *(float64x2_t *)(v133 + 24);
                        }
                      }
                    }
                  }
                }
LABEL_139:
                *(float32x2_t *)(v19 + 3) = vcvt_f32_f64(v29);
                v134 = v28;
                *((float *)v19 + 5) = v134;
                v135 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v27, (const CA::Render::KeyValueArray *)0xE9, 1.0);
                *((float *)v19 + 6) = v135;
                goto LABEL_348;
              }
LABEL_125:
              *(_QWORD *)(v18 + 40) = 0;
              break;
          }
        }
      }
      else if (v20 <= 102)
      {
        if (v20 == 3)
        {
          v89 = (malloc_zone_t *)get_malloc_zone();
          v90 = malloc_type_zone_malloc(v89, 0x20uLL, 0x8BB15036uLL);
          if (v90)
          {
            v19 = v90;
            v91 = *(CA::Render::KeyValueArray **)(v18 + 32);
            v90[2] = 0;
            *(_QWORD *)v90 = off_1E15979A0;
            v92 = CA::Render::KeyValueArray::get_float_key(v91, (const CA::Render::KeyValueArray *)0x1D6, 0.0);
            *((float *)v19 + 3) = v92;
            v93 = CA::Render::KeyValueArray::get_int_key(v91, (const CA::Render::KeyValueArray *)0x1B4, 0);
            *((_BYTE *)v19 + 16) = v93 != 0;
            *(_QWORD *)(v19 + 5) = v9;
            v19[7] = 0;
            if (v93 && v92 != 0.0)
            {
              v94 = __sincosf_stret(v92);
              v19[5] = LODWORD(v94.__sinval);
              *((float *)v19 + 6) = -v94.__cosval;
            }
            goto LABEL_348;
          }
          goto LABEL_125;
        }
        if (v20 == 43)
        {
          v33 = (malloc_zone_t *)get_malloc_zone();
          v34 = malloc_type_zone_malloc(v33, 0x50uLL, 0x8BB15036uLL);
          if (v34)
          {
            v19 = v34;
            v35 = *(const CA::Render::KeyValueArray **)(v18 + 32);
            v34[2] = 0;
            *(_QWORD *)v34 = v7;
            CA::Render::EmitterBehaviors::DistanceFunction::DistanceFunction((CA::Render::EmitterBehaviors::DistanceFunction *)(v34 + 3), v35);
            goto LABEL_348;
          }
          goto LABEL_125;
        }
      }
      else
      {
        switch(v20)
        {
          case 103:
            v45 = (malloc_zone_t *)get_malloc_zone();
            v46 = malloc_type_zone_malloc(v45, 0x58uLL, 0x8BB15036uLL);
            if (v46)
            {
              v19 = v46;
              v47 = *(unsigned int **)(v18 + 32);
              v46[2] = 0;
              *(_QWORD *)v46 = v8;
              CA::Render::EmitterBehaviors::DistanceFunction::DistanceFunction((CA::Render::EmitterBehaviors::DistanceFunction *)(v46 + 3), (const CA::Render::KeyValueArray *)v47);
              *((_QWORD *)v19 + 10) = 0;
              if (!v47)
                goto LABEL_348;
              v48 = v47[4];
              if (!(_DWORD)v48)
                goto LABEL_348;
              v49 = 0;
              while (1)
              {
                v50 = *(_QWORD *)&v47[2 * v49 + 6];
                if (*(_DWORD *)(v50 + 16) == 240)
                  break;
                if (v48 == ++v49)
                  goto LABEL_257;
              }
              if ((v49 & 0x80000000) == 0)
              {
                v136 = *(unsigned int **)(v50 + 24);
                if (v136)
                {
                  v137 = v136 + 2;
                  do
                    v138 = __ldaxr(v137);
                  while (__stlxr(v138 + 1, v137));
                  if (!v138)
                  {
                    do
                      v253 = __ldaxr(v137);
                    while (__stlxr(v253 - 1, v137));
                    *((_QWORD *)v19 + 10) = 0;
                    v14 = 1.0;
                    v17 = -1.0;
                    goto LABEL_257;
                  }
                  *((_QWORD *)v19 + 10) = v136;
                  if (*((_BYTE *)v136 + 12) != 18)
                  {
                    *((_QWORD *)v19 + 10) = 0;
                    goto LABEL_251;
                  }
                  v139 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v136 + 104))(v136);
                  v136 = (unsigned int *)*((_QWORD *)v19 + 10);
                  if (v139 != 1
                    || (v140 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v136 + 112))(v136),
                        v136 = (unsigned int *)*((_QWORD *)v19 + 10),
                        v140 != 4))
                  {
                    *((_QWORD *)v19 + 10) = 0;
                    if (!v136)
                      goto LABEL_257;
LABEL_251:
                    v189 = v136 + 2;
                    do
                    {
                      v190 = __ldaxr(v189);
                      v191 = v190 - 1;
                    }
                    while (__stlxr(v191, v189));
                    if (!v191)
                      (*(void (**)(unsigned int *))(*(_QWORD *)v136 + 16))(v136);
                    v136 = (unsigned int *)*((_QWORD *)v19 + 10);
                  }
                  if (v136)
                    goto LABEL_348;
                }
              }
LABEL_257:
              v192 = v47[4];
              if (!(_DWORD)v192)
                goto LABEL_348;
              v193 = 0;
              while (1)
              {
                v194 = *(_QWORD *)&v47[2 * v193 + 6];
                if (*(_DWORD *)(v194 + 16) == 108)
                  break;
                if (v192 == ++v193)
                  goto LABEL_265;
              }
              if ((v193 & 0x80000000) != 0)
              {
LABEL_265:
                if (!v47[4])
                  goto LABEL_348;
                v195 = 0;
                goto LABEL_267;
              }
              v195 = *(_QWORD *)(v194 + 24);
              if (!v47[4])
                goto LABEL_273;
LABEL_267:
              v196 = 0;
              while (1)
              {
                v197 = *(_QWORD *)&v47[2 * v196 + 6];
                if (*(_DWORD *)(v197 + 16) == 356)
                  break;
                if (v192 == ++v196)
                  goto LABEL_273;
              }
              if ((v196 & 0x80000000) == 0)
              {
                v198 = *(_QWORD *)(v197 + 24);
                goto LABEL_274;
              }
LABEL_273:
              v198 = 0;
LABEL_274:
              if (!v195 || *(_BYTE *)(v195 + 12) != 56)
                goto LABEL_348;
              v199 = (unint64_t)*(unsigned int *)(v195 + 16) >> 2;
              if (v198 && __PAIR64__(*(_DWORD *)(v198 + 16), *(unsigned __int8 *)(v198 + 12)) != __PAIR64__(v199, 56))
                v198 = 0;
              v200 = (malloc_zone_t *)get_malloc_zone();
              v201 = (CA::Render::Gradient *)malloc_type_zone_calloc(v200, 1uLL, 0x38uLL, 0x743898A5uLL);
              v202 = (uint64_t)v201;
              if (v201)
                v201 = CA::Render::Gradient::Gradient(v201, v199, 2 * (v198 != 0));
              CA::Render::Gradient::set_colors((uint64_t)v201, (const double *)(v195 + 24));
              if (v198)
                CA::Render::InterpolatedFunction::set_locations(v202, (const double *)(v198 + 24));
              v203 = (unsigned int *)*((_QWORD *)v19 + 10);
              *((_QWORD *)v19 + 10) = v202;
              if (v203)
              {
                v204 = v203 + 2;
                v7 = off_1E1597AC0;
                do
                {
                  v205 = __ldaxr(v204);
                  v206 = --v205 == 0;
                }
                while (__stlxr(v205, v204));
                goto LABEL_323;
              }
LABEL_324:
              v7 = off_1E1597AC0;
              v8 = off_1E1597B20;
              goto LABEL_348;
            }
            goto LABEL_125;
          case 104:
            v51 = (malloc_zone_t *)get_malloc_zone();
            v52 = malloc_type_zone_malloc(v51, 0x18uLL, 0x8BB15036uLL);
            if (v52)
            {
              v19 = v52;
              v53 = *(_QWORD *)(v18 + 32);
              v52[2] = 0;
              *(_QWORD *)v52 = off_1E1597AF0;
              *((_QWORD *)v52 + 2) = 0;
              if (!v53)
                goto LABEL_348;
              v54 = *(unsigned int *)(v53 + 16);
              if (!(_DWORD)v54)
                goto LABEL_348;
              v55 = 0;
              while (1)
              {
                v56 = *(_QWORD *)(v53 + 24 + 8 * v55);
                if (*(_DWORD *)(v56 + 16) == 240)
                  break;
                if (v54 == ++v55)
                  goto LABEL_294;
              }
              if ((v55 & 0x80000000) == 0)
              {
                v141 = *(unsigned int **)(v56 + 24);
                if (v141)
                {
                  v142 = v141 + 2;
                  do
                    v143 = __ldaxr(v142);
                  while (__stlxr(v143 + 1, v142));
                  if (!v143)
                  {
                    do
                      v254 = __ldaxr(v142);
                    while (__stlxr(v254 - 1, v142));
                    *((_QWORD *)v19 + 2) = 0;
                    v14 = 1.0;
                    v17 = -1.0;
                    goto LABEL_294;
                  }
                  *((_QWORD *)v19 + 2) = v141;
                  if (*((_BYTE *)v141 + 12) != 18)
                  {
                    *((_QWORD *)v19 + 2) = 0;
                    goto LABEL_288;
                  }
                  v144 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v141 + 104))(v141);
                  v141 = (unsigned int *)*((_QWORD *)v19 + 2);
                  if (v144 != 1
                    || (v145 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v141 + 112))(v141),
                        v141 = (unsigned int *)*((_QWORD *)v19 + 2),
                        v145 != 4))
                  {
                    *((_QWORD *)v19 + 2) = 0;
                    if (!v141)
                      goto LABEL_294;
LABEL_288:
                    v207 = v141 + 2;
                    do
                    {
                      v208 = __ldaxr(v207);
                      v209 = v208 - 1;
                    }
                    while (__stlxr(v209, v207));
                    if (!v209)
                      (*(void (**)(unsigned int *))(*(_QWORD *)v141 + 16))(v141);
                    v141 = (unsigned int *)*((_QWORD *)v19 + 2);
                  }
                  if (v141)
                    goto LABEL_348;
                }
              }
LABEL_294:
              v210 = *(unsigned int *)(v53 + 16);
              if (!(_DWORD)v210)
                goto LABEL_348;
              v211 = 0;
              while (1)
              {
                v212 = *(_QWORD *)(v53 + 24 + 8 * v211);
                if (*(_DWORD *)(v212 + 16) == 108)
                  break;
                if (v210 == ++v211)
                  goto LABEL_302;
              }
              if ((v211 & 0x80000000) != 0)
              {
LABEL_302:
                if (!*(_DWORD *)(v53 + 16))
                  goto LABEL_348;
                v213 = 0;
                goto LABEL_304;
              }
              v213 = *(_QWORD *)(v212 + 24);
              if (!*(_DWORD *)(v53 + 16))
                goto LABEL_310;
LABEL_304:
              v214 = 0;
              while (1)
              {
                v215 = *(_QWORD *)(v53 + 24 + 8 * v214);
                if (*(_DWORD *)(v215 + 16) == 356)
                  break;
                if (v210 == ++v214)
                  goto LABEL_310;
              }
              if ((v214 & 0x80000000) == 0)
              {
                v216 = *(_QWORD *)(v215 + 24);
                goto LABEL_311;
              }
LABEL_310:
              v216 = 0;
LABEL_311:
              if (!v213 || *(_BYTE *)(v213 + 12) != 56)
                goto LABEL_348;
              v217 = (unint64_t)*(unsigned int *)(v213 + 16) >> 2;
              if (v216 && __PAIR64__(*(_DWORD *)(v216 + 16), *(unsigned __int8 *)(v216 + 12)) != __PAIR64__(v217, 56))
                v216 = 0;
              v218 = (malloc_zone_t *)get_malloc_zone();
              v219 = (CA::Render::Gradient *)malloc_type_zone_calloc(v218, 1uLL, 0x38uLL, 0x743898A5uLL);
              v220 = (uint64_t)v219;
              if (v219)
                v219 = CA::Render::Gradient::Gradient(v219, v217, 2 * (v216 != 0));
              CA::Render::Gradient::set_colors((uint64_t)v219, (const double *)(v213 + 24));
              if (v216)
                CA::Render::InterpolatedFunction::set_locations(v220, (const double *)(v216 + 24));
              v203 = (unsigned int *)*((_QWORD *)v19 + 2);
              *((_QWORD *)v19 + 2) = v220;
              if (v203)
              {
                v221 = v203 + 2;
                v7 = off_1E1597AC0;
                do
                {
                  v222 = __ldaxr(v221);
                  v206 = --v222 == 0;
                }
                while (__stlxr(v222, v221));
LABEL_323:
                v8 = off_1E1597B20;
                goto LABEL_344;
              }
              goto LABEL_324;
            }
            goto LABEL_125;
          case 183:
            v21 = (malloc_zone_t *)get_malloc_zone();
            v22 = malloc_type_zone_malloc(v21, 0x10uLL, 0x8BB15036uLL);
            if (v22)
            {
              v19 = v22;
              v23 = *(CA::Render::KeyValueArray **)(v18 + 32);
              v19[2] = 0;
              *(_QWORD *)v19 = off_1E1597A00;
              v24 = CA::Render::KeyValueArray::get_float_key(v23, (const CA::Render::KeyValueArray *)0xB7, 1.0);
              *((float *)v19 + 3) = v24;
              goto LABEL_348;
            }
            goto LABEL_125;
        }
      }
      v120 = (malloc_zone_t *)get_malloc_zone();
      v121 = malloc_type_zone_malloc(v120, 0x10uLL, 0x8BB15036uLL);
      if (v121)
      {
        v19 = v121;
        v121[2] = 0;
        *(_QWORD *)v121 = off_1E1597A30;
        goto LABEL_348;
      }
      *(_QWORD *)(v18 + 40) = 0;
LABEL_367:
      ++v6;
    }
    while (v6 < *(unsigned int *)(a1 + 16));
  }
}

