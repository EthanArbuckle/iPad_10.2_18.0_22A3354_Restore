uint64_t glpLLVMBuildGEP(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, const char *a5)
{
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  char *v15;
  int v16;
  size_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  char *v23;
  int v24;
  uint64_t result;

  v10 = *(unsigned int *)(a1 + 260);
  v11 = v10 + 1;
  v12 = *(_DWORD *)(a1 + 256);
  if ((int)v10 + 1 <= v12)
  {
    v15 = *(char **)(a1 + 264);
    v16 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v12 <= 1)
      v12 = 1;
    v13 = 2 * v12;
    if (v13 <= v11)
      v14 = v11;
    else
      v14 = v13;
    v15 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v14, "Vector Storage (uint8_t, growth)");
    memcpy(v15, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v14;
    *(_QWORD *)(a1 + 264) = v15;
    v16 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v15[v10 + 1], &v15[v10], (v16 - v10));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v10) = 50;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  glpSerializeLLVMValue(a1, a2);
  glpSerializeArrayOfLLVMValues(a1, a3, a4);
  if (*(_DWORD *)(a1 + 300))
  {
    v17 = strlen(a5) + 1;
    v18 = *(unsigned int *)(a1 + 260);
    v19 = v17 + v18;
    v20 = *(_DWORD *)(a1 + 256);
    if ((int)v17 + (int)v18 <= v20)
    {
      v23 = *(char **)(a1 + 264);
      v24 = *(_DWORD *)(a1 + 260);
    }
    else
    {
      if (v20 <= 1)
        v20 = 1;
      v21 = 2 * v20;
      if (v21 <= v19)
        v22 = v19;
      else
        v22 = v21;
      v23 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v22, "Vector Storage (uint8_t, growth)");
      memcpy(v23, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
      (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
      *(_DWORD *)(a1 + 256) = v22;
      *(_QWORD *)(a1 + 264) = v23;
      v24 = *(_DWORD *)(a1 + 260);
    }
    memmove(&v23[v18 + 1], &v23[v18], (v24 - v18));
    memcpy((void *)(*(_QWORD *)(a1 + 264) + v18), a5, v17);
    *(_DWORD *)(a1 + 260) += v17;
  }
  result = *(int *)(a1 + 308);
  *(_DWORD *)(a1 + 308) = result + 1;
  return result;
}

uint64_t glpLLVMGetParam(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  char *v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  char *v19;
  int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  int v43;
  uint64_t v44;
  char *v45;
  unsigned int v46;
  int v47;
  uint64_t v48;
  uint64_t result;

  v6 = *(unsigned int *)(a1 + 260);
  v7 = v6 + 1;
  v8 = *(_DWORD *)(a1 + 256);
  if ((int)v6 + 1 <= v8)
  {
    v11 = *(char **)(a1 + 264);
    v12 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v8 <= 1)
      v8 = 1;
    v9 = 2 * v8;
    if (v9 <= v7)
      v10 = v7;
    else
      v10 = v9;
    v11 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v10, "Vector Storage (uint8_t, growth)");
    memcpy(v11, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v10;
    *(_QWORD *)(a1 + 264) = v11;
    v12 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v11[v6 + 1], &v11[v6], (v12 - v6));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v6) = 17;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  glpSerializeLLVMValue(a1, a2);
  v13 = (char)glp_serialized_integer32_control(a3);
  v14 = *(unsigned int *)(a1 + 260);
  v15 = v14 + 1;
  v16 = *(_DWORD *)(a1 + 256);
  if ((int)v14 + 1 <= v16)
  {
    v19 = *(char **)(a1 + 264);
    v20 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v16 <= 1)
      v16 = 1;
    v17 = 2 * v16;
    if (v17 <= v15)
      v18 = v15;
    else
      v18 = v17;
    v19 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v18, "Vector Storage (uint8_t, growth)");
    memcpy(v19, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v18;
    *(_QWORD *)(a1 + 264) = v19;
    v20 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v19[v14 + 1], &v19[v14], (v20 - v14));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v14) = v13;
  v21 = *(_DWORD *)(a1 + 260);
  v22 = v21 + 1;
  *(_DWORD *)(a1 + 260) = v21 + 1;
  if ((v13 & 0x80000000) != 0)
  {
    switch((v13 >> 1) & 7)
    {
      case 0u:
        v23 = v21 + 2;
        v24 = *(_DWORD *)(a1 + 256);
        if (v23 <= v24)
        {
          v27 = *(char **)(a1 + 264);
          v28 = v22;
        }
        else
        {
          if (v24 <= 1)
            v24 = 1;
          v25 = 2 * v24;
          if (v25 <= (int)v23)
            v26 = v23;
          else
            v26 = v25;
          v27 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v26, "Vector Storage (uint8_t, growth)");
          memcpy(v27, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v26;
          *(_QWORD *)(a1 + 264) = v27;
          v28 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v27[v22 + 1], &v27[v22], v28 - v22);
        *(_BYTE *)(*(_QWORD *)(a1 + 264) + v22) = a3;
        v47 = 1;
        goto LABEL_55;
      case 1u:
        v41 = v21 + 3;
        v42 = *(_DWORD *)(a1 + 256);
        if (v41 <= v42)
        {
          v45 = *(char **)(a1 + 264);
          v46 = v22;
        }
        else
        {
          if (v42 <= 1)
            v42 = 1;
          v43 = 2 * v42;
          if (v43 <= (int)v41)
            v44 = v41;
          else
            v44 = v43;
          v45 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v44, "Vector Storage (uint8_t, growth)");
          memcpy(v45, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v44;
          *(_QWORD *)(a1 + 264) = v45;
          v46 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v45[v22 + 1], &v45[v22], v46 - v22);
        *(_WORD *)(*(_QWORD *)(a1 + 264) + v22) = a3;
        v47 = 2;
        goto LABEL_55;
      case 2u:
        v29 = v21 + 4;
        v30 = *(_DWORD *)(a1 + 256);
        if (v29 <= v30)
        {
          v33 = *(char **)(a1 + 264);
          v34 = v22;
        }
        else
        {
          if (v30 <= 1)
            v30 = 1;
          v31 = 2 * v30;
          if (v31 <= (int)v29)
            v32 = v29;
          else
            v32 = v31;
          v33 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v32, "Vector Storage (uint8_t, growth)");
          memcpy(v33, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v32;
          *(_QWORD *)(a1 + 264) = v33;
          v34 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v33[v22 + 1], &v33[v22], v34 - v22);
        v48 = *(_QWORD *)(a1 + 264) + v22;
        *(_BYTE *)(v48 + 2) = BYTE2(a3);
        *(_WORD *)v48 = a3;
        v47 = 3;
        goto LABEL_55;
      case 3u:
        v35 = v21 + 5;
        v36 = *(_DWORD *)(a1 + 256);
        if (v35 <= v36)
        {
          v39 = *(char **)(a1 + 264);
          v40 = v22;
        }
        else
        {
          if (v36 <= 1)
            v36 = 1;
          v37 = 2 * v36;
          if (v37 <= (int)v35)
            v38 = v35;
          else
            v38 = v37;
          v39 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v38, "Vector Storage (uint8_t, growth)");
          memcpy(v39, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v38;
          *(_QWORD *)(a1 + 264) = v39;
          v40 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v39[v22 + 1], &v39[v22], v40 - v22);
        *(_DWORD *)(*(_QWORD *)(a1 + 264) + v22) = a3;
        v47 = 4;
LABEL_55:
        *(_DWORD *)(a1 + 260) += v47;
        break;
      default:
        break;
    }
  }
  result = *(int *)(a1 + 308);
  *(_DWORD *)(a1 + 308) = result + 1;
  return result;
}

uint64_t glpLLVMSplatConstantVector(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  size_t v9;
  uint64_t v10;
  uint64_t *v11;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x24BDAC8D0];
  if ((_DWORD)a3 != 1)
  {
    MEMORY[0x24BDAC7A8](a1);
    v8 = (_QWORD *)((char *)v13 - v7);
    if (v6 >= 0x200)
      v9 = 512;
    else
      v9 = v6;
    bzero((char *)v13 - v7, v9);
    if ((int)a3 >= 1)
    {
      v10 = a3;
      v11 = v8;
      do
      {
        *v11++ = a2;
        --v10;
      }
      while (v10);
    }
    return glpLLVMConstVectorCache(a1, v8, a3);
  }
  return a2;
}

uint64_t glpBuildGetLODOperation(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v6;
  uint64_t ReturnPrimitiveType;
  char SaFlags;
  uint64_t v10;
  int v11;
  uint64_t Child;
  uint64_t SaType;
  char *v14;
  int PPTextarget;
  uint64_t TextureSize;
  uint64_t v17;
  uint64_t v18;
  uint64_t Category;
  uint64_t v20;
  uint64_t *v21;
  size_t v22;
  unint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE v32[12];
  int v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  char v37[64];
  _QWORD v38[2];

  v6 = a2;
  v38[1] = *MEMORY[0x24BDAC8D0];
  ReturnPrimitiveType = glpPPStreamOpNodeGetReturnPrimitiveType(a2);
  SaFlags = glpASTNodeGetSaFlags(v6);
  v10 = glpPrecisionIndexFromSAFlags(SaFlags);
  v11 = 1;
  Child = glpASTNodeGetChild(v6, 1u);
  SaType = glpASTNodeGetSaType(Child);
  LODWORD(v6) = glpPrimitiveTypeGetPrimitiveType(SaType);
  v14 = glpTextureNameFromSamplerType(v6);
  snprintf_l(v37, 0x40uLL, 0, "air.compute_lod_%s", v14);
  PPTextarget = glpPrimitiveSamplerGetPPTextarget(v6);
  TextureSize = glpGetTextureSize(PPTextarget, &v33);
  v17 = *(_QWORD *)a3;
  v18 = *a4;
  Category = glpPrimitiveTypeGetCategory(v18);
  if ((_DWORD)Category == 2)
  {
    Category = glpPrimitiveVectorGetLength(v18);
    v11 = Category;
  }
  if ((_DWORD)TextureSize != v11)
  {
    MEMORY[0x24BDAC7A8](Category);
    v21 = (uint64_t *)&v32[-v20];
    bzero(&v32[-v20], v22);
    v23 = 0;
    do
    {
      v24 = &a1[v23];
      v25 = v24[65];
      if (!v25)
      {
        v25 = glpLLVMConstIntCache((uint64_t)a1, a1[5], v23, 0);
        v24[65] = v25;
      }
      v21[v23++] = v25;
    }
    while (TextureSize != v23);
    v26 = glpLLVMConstVectorCache((uint64_t)a1, v21, TextureSize);
    v27 = *(_QWORD *)a3;
    v28 = glpLLVMTypeOf((uint64_t)a1, *(_QWORD *)a3);
    v29 = glpLLVMConstFromTypeCache((uint64_t)a1, 37, v28);
    v17 = glpLLVMBuildShuffleVector((uint64_t)a1, v27, v29, v26, "texCoord");
  }
  v34 = *(_OWORD *)(a3 + 8);
  v35 = v17;
  v36 = glpLLVMConstIntCache((uint64_t)a1, a1[8], 0, 0);
  v30 = glpPrimitiveTypeToLLVMType(a1, ReturnPrimitiveType, v10);
  v38[0] = 0x400000001;
  return glpLLVMCallFunction((uint64_t)a1, v37, v30, (uint64_t *)&v34, 4, (unsigned int *)v38, 2);
}

uint64_t glpLLVMGetVariablePointer(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  double v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13[3];

  v13[2] = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a2 + 144);
  v3 = *(_QWORD *)v2;
  if (*(_QWORD *)v2 && (*(_BYTE *)(a2 + 51) & 0x86) != 0)
  {
    v3 = glpPointerHashGet(*(_QWORD *)(a1 + 344), a2);
    if (!v3)
    {
      if (*(_WORD *)(a1 + 324))
      {
        v6 = glpLLVMGetElementType(a1, *(_QWORD *)v2);
        v7 = glpBuildAlloca(a1, v6);
      }
      else
      {
        v9 = glpPointerHashGet(*(_QWORD *)(a1 + 336), a2);
        v7 = glpLLVMGetParam(a1, *(_QWORD *)(a1 + 160), (v9 - 1));
      }
      v3 = v7;
      glpPointerHashPut(*(_QWORD *)(a1 + 344), a2, v7, v8);
    }
    if ((*(_BYTE *)(v2 + 32) & 4) != 0)
    {
      v10 = glpLLVMBuildLoad(a1, *(_QWORD *)(a1 + 584), "vrl");
      v11 = *(_QWORD *)(a1 + 520);
      if (!v11)
      {
        v11 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), 0, 0);
        *(_QWORD *)(a1 + 520) = v11;
      }
      v13[0] = v11;
      v13[1] = v10;
      return glpLLVMBuildGEP(a1, v3, v13, 2, "ptr");
    }
  }
  return v3;
}

uint64_t glpBuildInterpolateAt(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6)
{
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  const char *v18;
  const char *v20;
  char v21[512];
  uint64_t v22;
  uint64_t v23;
  char v24[512];
  _QWORD v25[2];

  v25[1] = *MEMORY[0x24BDAC8D0];
  v11 = *(_QWORD *)(a3 + 144);
  v12 = *(_DWORD *)(v11 + 24);
  v13 = *(_DWORD *)(v11 + 28);
  v14 = glpPrimitiveTypeToLLVMType(a1, v12, v13);
  v22 = glpLLVMBuildLoad((uint64_t)a1, a2, "srcPointerInterpolant");
  v15 = a4 & 0x46000800000;
  if ((a4 & 0x46000800000uLL) > 0x3FFFFFFFFFLL)
  {
    if ((a4 & 0x46000800000uLL) > 0x3FFFFFFFFFFLL)
    {
      if (v15 == 0x40000000000)
      {
        v16 = "air.interpolate_sample_perspective";
      }
      else
      {
        if (v15 != 0x42000000000)
          goto LABEL_24;
        v16 = "air.interpolate_sample_no_perspective";
      }
    }
    else if (v15 == 0x4000000000)
    {
      v16 = "air.interpolate_centroid_perspective";
    }
    else
    {
      if (v15 != 0x6000000000)
        goto LABEL_24;
      v16 = "air.interpolate_centroid_no_perspective";
    }
  }
  else if ((a4 & 0x46000800000uLL) > 0x1FFFFFFFFFLL)
  {
    if (v15 == 0x2000000000)
    {
      v16 = "air.interpolate_center_no_perspective";
    }
    else
    {
      if (v15 != 0x2000800000)
        goto LABEL_24;
      v16 = "air.interpolate_offset_no_perspective";
    }
  }
  else
  {
    if (v15)
    {
      if (v15 == 0x800000)
      {
        v16 = "air.interpolate_offset_perspective";
        goto LABEL_20;
      }
LABEL_24:
      abort();
    }
    v16 = "air.interpolate_center_perspective";
  }
LABEL_20:
  v23 = 0;
  snprintf_l(v21, 0x200uLL, 0, "%s%s", v16, a5);
  if (a6)
  {
    v23 = a6;
    v17 = 2;
  }
  else
  {
    v17 = 1;
  }
  v18 = glpLLVMGetTypeString(&v20, v12, v13);
  snprintf_l(v24, 0x200uLL, 0, "%s.%s", v21, v18);
  v25[0] = 0x300000001;
  return glpLLVMCallFunction((uint64_t)a1, v24, v14, &v22, v17, (unsigned int *)v25, 2);
}

uint64_t glpCGSwizzle(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t inserted, uint64_t a5, unsigned int a6)
{
  uint64_t Category;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t Length;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  size_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int *v23;
  uint64_t v24;
  int v25;
  unsigned int v26;
  uint64_t *v27;
  unint64_t v28;
  unsigned int v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  size_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unsigned int *v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  uint64_t *v62;
  unsigned int *v63;
  unint64_t v64;
  unsigned int v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  uint64_t *v77;
  unint64_t v78;
  unsigned int v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t *v87;
  uint64_t v88;

  v88 = *MEMORY[0x24BDAC8D0];
  if (!a6)
    return inserted;
  Category = glpPrimitiveTypeGetCategory(a5);
  v13 = Category;
  v14 = a6 & 7;
  if (!a2)
  {
    MEMORY[0x24BDAC7A8](Category);
    v38 = (uint64_t *)((char *)&v83 - v37);
    bzero((char *)&v83 - v37, v39);
    if ((a6 & 7) == 0)
      goto LABEL_34;
    v87 = &v83;
    v40 = inserted;
    v41 = 0;
    v42 = 3;
    do
    {
      v43 = (a6 >> v42) & 3;
      v44 = a1 + 8 * v43;
      v45 = *(_QWORD *)(v44 + 520);
      if (!v45)
      {
        v46 = (uint64_t *)(v44 + 520);
        v45 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), v43, 0);
        *v46 = v45;
      }
      v38[v41] = v45;
      v42 += 2;
      ++v41;
    }
    while (v14 != v41);
    inserted = v40;
    if ((_DWORD)v14 == 1)
    {
      if (v13 != 2)
        return inserted;
      return glpLLVMBuildExtractElement(a1, v40, *v38, "swz");
    }
    else
    {
LABEL_34:
      if (v13 != 2)
      {
        v53 = glpLLVMTypeOf(a1, inserted);
        v54 = glpLLVMVectorType(a1, v53, a6 & 7);
        v55 = glpLLVMConstFromTypeCache(a1, 37, v54);
        inserted = glpLLVMBuildInsertElement(a1, v55, inserted, *v38, "");
      }
      v56 = glpLLVMConstVectorCache(a1, v38, a6 & 7);
      return glpLLVMBuildShuffleVector(a1, inserted, inserted, v56, "swz");
    }
  }
  v15 = glpPrimitiveTypeGetCategory(a3);
  if (v13 == 2)
  {
    Length = glpPrimitiveVectorGetLength(a3);
    v86 = &v83;
    v17 = Length;
    MEMORY[0x24BDAC7A8](Length);
    if (v18 >= 0x200)
      v20 = 512;
    else
      v20 = v18;
    v87 = (uint64_t *)((char *)&v83 - v19);
    bzero((char *)&v83 - v19, v20);
    MEMORY[0x24BDAC7A8](v21);
    v23 = (unsigned int *)((char *)&v83 - v22);
    if ((_DWORD)Length == glpPrimitiveVectorGetLength(a5))
    {
      if ((_DWORD)Length)
      {
        v24 = 0;
        do
        {
          v23[v24] = v24;
          ++v24;
        }
        while (Length != v24);
      }
      if ((a6 & 7) != 0)
      {
        v25 = 0;
        v26 = Length;
        do
        {
          v23[(a6 >> (v25 + 3)) & 3] = v26;
          v25 += 2;
          ++v26;
        }
        while (2 * (_DWORD)v14 != v25);
      }
      if ((_DWORD)Length)
      {
        v27 = v87;
        do
        {
          v29 = *v23++;
          v28 = v29;
          if (v29 > 7)
          {
            v31 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), (int)v28, 1);
          }
          else
          {
            v30 = a1 + 8 * v28;
            v31 = *(_QWORD *)(v30 + 520);
            if (!v31)
            {
              v32 = (uint64_t *)(v30 + 520);
              v31 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), v28, 0);
              *v32 = v31;
            }
          }
          *v27++ = v31;
          --v17;
        }
        while (v17);
      }
      v33 = glpLLVMConstVectorCache(a1, v87, Length);
      v34 = "swz";
      v35 = a1;
      v36 = a2;
    }
    else
    {
      v85 = inserted;
      if ((_DWORD)Length)
      {
        v57 = Length;
        v58 = v23;
        do
        {
          *v58++ = v14;
          --v57;
        }
        while (v57);
      }
      v84 = a2;
      if ((a6 & 7) != 0)
      {
        v59 = 0;
        v60 = 3;
        do
        {
          v23[(a6 >> v60) & 3] = v59++;
          v60 += 2;
        }
        while ((_DWORD)v14 != v59);
      }
      if ((_DWORD)Length)
      {
        v61 = Length;
        v62 = v87;
        v63 = v23;
        do
        {
          v65 = *v63++;
          v64 = v65;
          if (v65 > 7)
          {
            v67 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), (int)v64, 1);
          }
          else
          {
            v66 = a1 + 8 * v64;
            v67 = *(_QWORD *)(v66 + 520);
            if (!v67)
            {
              v68 = (uint64_t *)(v66 + 520);
              v67 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), v64, 0);
              *v68 = v67;
            }
          }
          *v62++ = v67;
          --v61;
        }
        while (v61);
      }
      v69 = v87;
      v70 = glpLLVMConstVectorCache(a1, v87, Length);
      v71 = v85;
      v72 = glpLLVMTypeOf(a1, v85);
      v73 = glpLLVMConstFromTypeCache(a1, 37, v72);
      inserted = glpLLVMBuildShuffleVector(a1, v71, v73, v70, "shuffle0");
      if ((_DWORD)Length)
      {
        v74 = 0;
        do
        {
          v23[v74] = v74;
          ++v74;
        }
        while (Length != v74);
      }
      v75 = v84;
      if ((a6 & 7) != 0)
      {
        v76 = 0;
        do
        {
          v23[(a6 >> (v76 + 3)) & 3] = ((a6 >> (v76 + 3)) & 3) + Length;
          v76 += 2;
        }
        while (2 * (_DWORD)v14 != v76);
      }
      if ((_DWORD)Length)
      {
        v77 = v69;
        do
        {
          v79 = *v23++;
          v78 = v79;
          if (v79 > 7)
          {
            v81 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), (int)v78, 1);
          }
          else
          {
            v80 = a1 + 8 * v78;
            v81 = *(_QWORD *)(v80 + 520);
            if (!v81)
            {
              v82 = (uint64_t *)(v80 + 520);
              v81 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), v78, 0);
              *v82 = v81;
            }
          }
          *v77++ = v81;
          --v17;
        }
        while (v17);
      }
      v33 = glpLLVMConstVectorCache(a1, v69, Length);
      v34 = "merge";
      v35 = a1;
      v36 = v75;
    }
    return glpLLVMBuildShuffleVector(v35, v36, inserted, v33, v34);
  }
  if (v15 != 2)
    return inserted;
  v48 = (a6 >> 3) & 3;
  v49 = a1 + 8 * v48;
  v50 = *(_QWORD *)(v49 + 520);
  if (!v50)
  {
    v51 = (uint64_t *)(v49 + 520);
    v50 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), v48, 0);
    *v51 = v50;
  }
  return glpLLVMBuildInsertElement(a1, a2, inserted, v50, "swz");
}

uint64_t glpLLVMGetInsertBlock(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  char *v7;
  int v8;
  uint64_t result;

  v2 = *(unsigned int *)(a1 + 260);
  v3 = v2 + 1;
  v4 = *(_DWORD *)(a1 + 256);
  if ((int)v2 + 1 <= v4)
  {
    v7 = *(char **)(a1 + 264);
    v8 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v4 <= 1)
      v4 = 1;
    v5 = 2 * v4;
    if (v5 <= v3)
      v6 = v3;
    else
      v6 = v5;
    v7 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v6, "Vector Storage (uint8_t, growth)");
    memcpy(v7, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v6;
    *(_QWORD *)(a1 + 264) = v7;
    v8 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v7[v2 + 1], &v7[v2], (v8 - v2));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v2) = 21;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  result = *(int *)(a1 + 312);
  *(_DWORD *)(a1 + 312) = result + 1;
  return result;
}

void *glpLLVMPositionBuilderAtEnd(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  char *v9;
  int v10;

  v4 = *(unsigned int *)(a1 + 260);
  v5 = v4 + 1;
  v6 = *(_DWORD *)(a1 + 256);
  if ((int)v4 + 1 <= v6)
  {
    v9 = *(char **)(a1 + 264);
    v10 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v6 <= 1)
      v6 = 1;
    v7 = 2 * v6;
    if (v7 <= v5)
      v8 = v5;
    else
      v8 = v7;
    v9 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v8, "Vector Storage (uint8_t, growth)");
    memcpy(v9, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v8;
    *(_QWORD *)(a1 + 264) = v9;
    v10 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v9[v4 + 1], &v9[v4], (v10 - v4));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v4) = 23;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  return glpSerializeLLVMBlock(a1, a2);
}

void *glpSerializeLLVMBlock(uint64_t a1, uint64_t a2)
{
  int v2;
  unsigned int v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  char *v10;
  int v11;
  void *result;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  int v17;
  uint64_t v18;
  char *v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  uint64_t v24;
  char *v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  int v29;
  uint64_t v30;
  char *v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  int v35;
  uint64_t v36;
  char *v37;
  unsigned int v38;
  int v39;
  uint64_t v40;

  v2 = a2;
  v4 = (char)glp_serialized_integer32_control(a2);
  v5 = *(unsigned int *)(a1 + 260);
  v6 = v5 + 1;
  v7 = *(_DWORD *)(a1 + 256);
  if ((int)v5 + 1 <= v7)
  {
    v10 = *(char **)(a1 + 264);
    v11 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v7 <= 1)
      v7 = 1;
    v8 = 2 * v7;
    if (v8 <= v6)
      v9 = v6;
    else
      v9 = v8;
    v10 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v9, "Vector Storage (uint8_t, growth)");
    memcpy(v10, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v9;
    *(_QWORD *)(a1 + 264) = v10;
    v11 = *(_DWORD *)(a1 + 260);
  }
  result = memmove(&v10[v5 + 1], &v10[v5], (v11 - v5));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v5) = v4;
  v13 = *(_DWORD *)(a1 + 260);
  v14 = v13 + 1;
  *(_DWORD *)(a1 + 260) = v13 + 1;
  if ((v4 & 0x80000000) != 0)
  {
    switch((v4 >> 1) & 7)
    {
      case 0u:
        v15 = v13 + 2;
        v16 = *(_DWORD *)(a1 + 256);
        if (v15 <= v16)
        {
          v19 = *(char **)(a1 + 264);
          v20 = v14;
        }
        else
        {
          if (v16 <= 1)
            v16 = 1;
          v17 = 2 * v16;
          if (v17 <= (int)v15)
            v18 = v15;
          else
            v18 = v17;
          v19 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v18, "Vector Storage (uint8_t, growth)");
          memcpy(v19, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v18;
          *(_QWORD *)(a1 + 264) = v19;
          v20 = *(_DWORD *)(a1 + 260);
        }
        result = memmove(&v19[v14 + 1], &v19[v14], v20 - v14);
        *(_BYTE *)(*(_QWORD *)(a1 + 264) + v14) = v2;
        v39 = 1;
        goto LABEL_47;
      case 1u:
        v33 = v13 + 3;
        v34 = *(_DWORD *)(a1 + 256);
        if (v33 <= v34)
        {
          v37 = *(char **)(a1 + 264);
          v38 = v14;
        }
        else
        {
          if (v34 <= 1)
            v34 = 1;
          v35 = 2 * v34;
          if (v35 <= (int)v33)
            v36 = v33;
          else
            v36 = v35;
          v37 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v36, "Vector Storage (uint8_t, growth)");
          memcpy(v37, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v36;
          *(_QWORD *)(a1 + 264) = v37;
          v38 = *(_DWORD *)(a1 + 260);
        }
        result = memmove(&v37[v14 + 1], &v37[v14], v38 - v14);
        *(_WORD *)(*(_QWORD *)(a1 + 264) + v14) = v2;
        v39 = 2;
        goto LABEL_47;
      case 2u:
        v21 = v13 + 4;
        v22 = *(_DWORD *)(a1 + 256);
        if (v21 <= v22)
        {
          v25 = *(char **)(a1 + 264);
          v26 = v14;
        }
        else
        {
          if (v22 <= 1)
            v22 = 1;
          v23 = 2 * v22;
          if (v23 <= (int)v21)
            v24 = v21;
          else
            v24 = v23;
          v25 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v24, "Vector Storage (uint8_t, growth)");
          memcpy(v25, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v24;
          *(_QWORD *)(a1 + 264) = v25;
          v26 = *(_DWORD *)(a1 + 260);
        }
        result = memmove(&v25[v14 + 1], &v25[v14], v26 - v14);
        v40 = *(_QWORD *)(a1 + 264) + v14;
        *(_BYTE *)(v40 + 2) = BYTE2(v2);
        *(_WORD *)v40 = v2;
        v39 = 3;
        goto LABEL_47;
      case 3u:
        v27 = v13 + 5;
        v28 = *(_DWORD *)(a1 + 256);
        if (v27 <= v28)
        {
          v31 = *(char **)(a1 + 264);
          v32 = v14;
        }
        else
        {
          if (v28 <= 1)
            v28 = 1;
          v29 = 2 * v28;
          if (v29 <= (int)v27)
            v30 = v27;
          else
            v30 = v29;
          v31 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v30, "Vector Storage (uint8_t, growth)");
          memcpy(v31, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v30;
          *(_QWORD *)(a1 + 264) = v31;
          v32 = *(_DWORD *)(a1 + 260);
        }
        result = memmove(&v31[v14 + 1], &v31[v14], v32 - v14);
        *(_DWORD *)(*(_QWORD *)(a1 + 264) + v14) = v2;
        v39 = 4;
LABEL_47:
        *(_DWORD *)(a1 + 260) += v39;
        break;
      default:
        return result;
    }
  }
  return result;
}

BOOL glpGetConstantOffset(uint64_t a1, _DWORD *a2)
{
  _BOOL8 result;

  result = glpIsConstantNode(a1);
  if (result)
  {
    *a2 = *(_DWORD *)glpConstantNodeGetValue(a1);
    return 1;
  }
  return result;
}

uint64_t glpBuildUniformElementPtr(uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  uint64_t Gep;
  uint64_t inserted;
  uint64_t v15[2];

  v15[1] = *MEMORY[0x24BDAC8D0];
  Gep = glpFindGep((uint64_t)a1, a2, a5, a6);
  if (!Gep)
  {
    v15[0] = glpLLVMConstIntCache((uint64_t)a1, a1[5], a6, 1);
    inserted = glpLLVMGetInsertBlock((uint64_t)a1);
    glpLLVMPositionBuilderAtEnd((uint64_t)a1, a1[23]);
    if (a4)
      a3 = glpLLVMCastOperation((uint64_t)a1, 86, a3, a4, "ptr");
    Gep = glpLLVMBuildGEP((uint64_t)a1, a3, v15, 1, "ptr");
    glpLLVMPositionBuilderAtEnd((uint64_t)a1, inserted);
    glpAddGep(a1, a2, a5, a6, Gep);
  }
  return Gep;
}

uint64_t glpMakeSwizzle(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9;
  uint64_t result;
  char *v11;
  char *v12;

  v9 = 0;
  v12 = &a9;
  LODWORD(result) = 4;
  do
  {
    v11 = v12;
    v12 += 8;
    result = (*(_DWORD *)v11 << (v9 + 3)) | result & ~(24 << v9);
    v9 += 2;
  }
  while (v9 != 8);
  return result;
}

uint64_t glpFindGep(uint64_t a1, unint64_t a2, int a3, int a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t i;

  result = glpPointerHashGet(*(_QWORD *)(a1 + 352), a2);
  if (result)
  {
    v7 = *(unsigned int *)(result + 4);
    if ((_DWORD)v7)
    {
      for (i = *(_QWORD *)(result + 8) + 8; *(_DWORD *)(i - 4) != a4 || *(_DWORD *)(i - 8) != a3; i += 16)
      {
        if (!--v7)
          return 0;
      }
      return *(_QWORD *)i;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *glpAddGep(uint64_t *a1, unint64_t a2, int a3, int a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  double v12;
  int v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  _QWORD *v17;
  char *v18;
  int v19;
  void *result;
  uint64_t v21;

  v10 = glpPointerHashGet(a1[44], a2);
  if (!v10)
  {
    v10 = glpLinkerPoolAlloc(a1[16]);
    v11 = a1[19];
    *(_QWORD *)v10 = 4;
    *(_QWORD *)(v10 + 8) = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(v11 + 8))(*(_QWORD *)v11, 64, "Vector Storage (GLPGepEntry)");
    glpPointerHashPut(a1[44], a2, v10, v12);
  }
  v13 = *(_DWORD *)v10;
  v14 = *(unsigned int *)(v10 + 4);
  if ((v14 + 1) <= *(_DWORD *)v10)
  {
    v18 = *(char **)(v10 + 8);
    v19 = *(_DWORD *)(v10 + 4);
  }
  else
  {
    if (v13 <= 1)
      v13 = 1;
    v15 = 2 * v13;
    if (v15 <= (int)v14 + 1)
      v16 = v14 + 1;
    else
      v16 = v15;
    v17 = (_QWORD *)a1[19];
    v18 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))v17[1])(*v17, 16 * v16, "Vector Storage (GLPGepEntry, growth)");
    memcpy(v18, *(const void **)(v10 + 8), 16 * *(unsigned int *)(v10 + 4));
    ((void (*)(_QWORD, _QWORD))v17[3])(*v17, *(_QWORD *)(v10 + 8));
    *(_DWORD *)v10 = v16;
    *(_QWORD *)(v10 + 8) = v18;
    v19 = *(_DWORD *)(v10 + 4);
  }
  result = memmove(&v18[16 * v14 + 16], &v18[16 * v14], 16 * (v19 - v14));
  v21 = *(_QWORD *)(v10 + 8) + 16 * v14;
  *(_DWORD *)v21 = a3;
  *(_DWORD *)(v21 + 4) = a4;
  *(_QWORD *)(v21 + 8) = a5;
  ++*(_DWORD *)(v10 + 4);
  return result;
}

uint64_t glpLLVMCGInsertBasicBlock(uint64_t a1, const char *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  char *v10;
  int v11;

  v3 = glpLLVMAppendBasicBlock(a1, *(_QWORD *)(a1 + 160), a2);
  v4 = *(_QWORD *)(a1 + 432);
  if (v4)
  {
    v5 = *(unsigned int *)(a1 + 260);
    v6 = v5 + 1;
    v7 = *(_DWORD *)(a1 + 256);
    if ((int)v5 + 1 <= v7)
    {
      v10 = *(char **)(a1 + 264);
      v11 = *(_DWORD *)(a1 + 260);
    }
    else
    {
      if (v7 <= 1)
        v7 = 1;
      v8 = 2 * v7;
      if (v8 <= v6)
        v9 = v6;
      else
        v9 = v8;
      v10 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v9, "Vector Storage (uint8_t, growth)");
      memcpy(v10, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
      (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
      *(_DWORD *)(a1 + 256) = v9;
      *(_QWORD *)(a1 + 264) = v10;
      v11 = *(_DWORD *)(a1 + 260);
    }
    memmove(&v10[v5 + 1], &v10[v5], (v11 - v5));
    *(_BYTE *)(*(_QWORD *)(a1 + 264) + v5) = 22;
    ++*(_DWORD *)(a1 + 260);
    ++*(_DWORD *)(a1 + 296);
    glpSerializeLLVMBlock(a1, v3);
    glpSerializeLLVMBlock(a1, v4);
  }
  return v3;
}

uint64_t glpLLVMBuildSwitch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  char *v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  int v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  int v27;
  uint64_t v28;
  char *v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  int v33;
  uint64_t v34;
  char *v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  int v39;
  uint64_t v40;
  char *v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  int v45;
  uint64_t v46;
  char *v47;
  unsigned int v48;
  int v49;
  uint64_t v50;
  uint64_t result;

  v8 = *(unsigned int *)(a1 + 260);
  v9 = v8 + 1;
  v10 = *(_DWORD *)(a1 + 256);
  if ((int)v8 + 1 <= v10)
  {
    v13 = *(char **)(a1 + 264);
    v14 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v10 <= 1)
      v10 = 1;
    v11 = 2 * v10;
    if (v11 <= v9)
      v12 = v9;
    else
      v12 = v11;
    v13 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v12, "Vector Storage (uint8_t, growth)");
    memcpy(v13, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v12;
    *(_QWORD *)(a1 + 264) = v13;
    v14 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v13[v8 + 1], &v13[v8], (v14 - v8));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v8) = 92;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  glpSerializeLLVMValue(a1, a2);
  glpSerializeLLVMBlock(a1, a3);
  v15 = (char)glp_serialized_integer32_control(a4);
  v16 = *(unsigned int *)(a1 + 260);
  v17 = v16 + 1;
  v18 = *(_DWORD *)(a1 + 256);
  if ((int)v16 + 1 <= v18)
  {
    v21 = *(char **)(a1 + 264);
    v22 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v18 <= 1)
      v18 = 1;
    v19 = 2 * v18;
    if (v19 <= v17)
      v20 = v17;
    else
      v20 = v19;
    v21 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v20, "Vector Storage (uint8_t, growth)");
    memcpy(v21, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v20;
    *(_QWORD *)(a1 + 264) = v21;
    v22 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v21[v16 + 1], &v21[v16], (v22 - v16));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v16) = v15;
  v23 = *(_DWORD *)(a1 + 260);
  v24 = v23 + 1;
  *(_DWORD *)(a1 + 260) = v23 + 1;
  if ((v15 & 0x80000000) != 0)
  {
    switch((v15 >> 1) & 7)
    {
      case 0u:
        v25 = v23 + 2;
        v26 = *(_DWORD *)(a1 + 256);
        if (v25 <= v26)
        {
          v29 = *(char **)(a1 + 264);
          v30 = v24;
        }
        else
        {
          if (v26 <= 1)
            v26 = 1;
          v27 = 2 * v26;
          if (v27 <= (int)v25)
            v28 = v25;
          else
            v28 = v27;
          v29 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v28, "Vector Storage (uint8_t, growth)");
          memcpy(v29, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v28;
          *(_QWORD *)(a1 + 264) = v29;
          v30 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v29[v24 + 1], &v29[v24], v30 - v24);
        *(_BYTE *)(*(_QWORD *)(a1 + 264) + v24) = a4;
        v49 = 1;
        goto LABEL_55;
      case 1u:
        v43 = v23 + 3;
        v44 = *(_DWORD *)(a1 + 256);
        if (v43 <= v44)
        {
          v47 = *(char **)(a1 + 264);
          v48 = v24;
        }
        else
        {
          if (v44 <= 1)
            v44 = 1;
          v45 = 2 * v44;
          if (v45 <= (int)v43)
            v46 = v43;
          else
            v46 = v45;
          v47 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v46, "Vector Storage (uint8_t, growth)");
          memcpy(v47, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v46;
          *(_QWORD *)(a1 + 264) = v47;
          v48 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v47[v24 + 1], &v47[v24], v48 - v24);
        *(_WORD *)(*(_QWORD *)(a1 + 264) + v24) = a4;
        v49 = 2;
        goto LABEL_55;
      case 2u:
        v31 = v23 + 4;
        v32 = *(_DWORD *)(a1 + 256);
        if (v31 <= v32)
        {
          v35 = *(char **)(a1 + 264);
          v36 = v24;
        }
        else
        {
          if (v32 <= 1)
            v32 = 1;
          v33 = 2 * v32;
          if (v33 <= (int)v31)
            v34 = v31;
          else
            v34 = v33;
          v35 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v34, "Vector Storage (uint8_t, growth)");
          memcpy(v35, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v34;
          *(_QWORD *)(a1 + 264) = v35;
          v36 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v35[v24 + 1], &v35[v24], v36 - v24);
        v50 = *(_QWORD *)(a1 + 264) + v24;
        *(_BYTE *)(v50 + 2) = BYTE2(a4);
        *(_WORD *)v50 = a4;
        v49 = 3;
        goto LABEL_55;
      case 3u:
        v37 = v23 + 5;
        v38 = *(_DWORD *)(a1 + 256);
        if (v37 <= v38)
        {
          v41 = *(char **)(a1 + 264);
          v42 = v24;
        }
        else
        {
          if (v38 <= 1)
            v38 = 1;
          v39 = 2 * v38;
          if (v39 <= (int)v37)
            v40 = v37;
          else
            v40 = v39;
          v41 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v40, "Vector Storage (uint8_t, growth)");
          memcpy(v41, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v40;
          *(_QWORD *)(a1 + 264) = v41;
          v42 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v41[v24 + 1], &v41[v24], v42 - v24);
        *(_DWORD *)(*(_QWORD *)(a1 + 264) + v24) = a4;
        v49 = 4;
LABEL_55:
        *(_DWORD *)(a1 + 260) += v49;
        break;
      default:
        break;
    }
  }
  result = *(int *)(a1 + 308);
  *(_DWORD *)(a1 + 308) = result + 1;
  return result;
}

void *glpLLVMEmitBranch(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  char *v9;
  int v10;
  void *result;

  v4 = *(unsigned int *)(a1 + 260);
  v5 = v4 + 1;
  v6 = *(_DWORD *)(a1 + 256);
  if ((int)v4 + 1 <= v6)
  {
    v9 = *(char **)(a1 + 264);
    v10 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v6 <= 1)
      v6 = 1;
    v7 = 2 * v6;
    if (v7 <= v5)
      v8 = v5;
    else
      v8 = v7;
    v9 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v8, "Vector Storage (uint8_t, growth)");
    memcpy(v9, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v8;
    *(_QWORD *)(a1 + 264) = v9;
    v10 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v9[v4 + 1], &v9[v4], (v10 - v4));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v4) = 26;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  result = glpSerializeLLVMBlock(a1, a2);
  *(_DWORD *)(a1 + 332) = 0;
  return result;
}

void *glpLLVMAddCase(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  char *v13;
  int v14;

  v8 = *(unsigned int *)(a1 + 260);
  v9 = v8 + 1;
  v10 = *(_DWORD *)(a1 + 256);
  if ((int)v8 + 1 <= v10)
  {
    v13 = *(char **)(a1 + 264);
    v14 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v10 <= 1)
      v10 = 1;
    v11 = 2 * v10;
    if (v11 <= v9)
      v12 = v9;
    else
      v12 = v11;
    v13 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v12, "Vector Storage (uint8_t, growth)");
    memcpy(v13, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v12;
    *(_QWORD *)(a1 + 264) = v13;
    v14 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v13[v8 + 1], &v13[v8], (v14 - v8));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v8) = 93;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  glpSerializeLLVMValue(a1, a2);
  glpSerializeLLVMValue(a1, a3);
  return glpSerializeLLVMBlock(a1, a4);
}

uint64_t glpLLVMBuildPhi(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  char *v11;
  int v12;
  size_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  char *v19;
  int v20;
  uint64_t result;

  v6 = *(unsigned int *)(a1 + 260);
  v7 = v6 + 1;
  v8 = *(_DWORD *)(a1 + 256);
  if ((int)v6 + 1 <= v8)
  {
    v11 = *(char **)(a1 + 264);
    v12 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v8 <= 1)
      v8 = 1;
    v9 = 2 * v8;
    if (v9 <= v7)
      v10 = v7;
    else
      v10 = v9;
    v11 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v10, "Vector Storage (uint8_t, growth)");
    memcpy(v11, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v10;
    *(_QWORD *)(a1 + 264) = v11;
    v12 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v11[v6 + 1], &v11[v6], (v12 - v6));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v6) = 94;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  glpSerializeLLVMType(a1, a2);
  if (*(_DWORD *)(a1 + 300))
  {
    v13 = strlen(a3) + 1;
    v14 = *(unsigned int *)(a1 + 260);
    v15 = v13 + v14;
    v16 = *(_DWORD *)(a1 + 256);
    if ((int)v13 + (int)v14 <= v16)
    {
      v19 = *(char **)(a1 + 264);
      v20 = *(_DWORD *)(a1 + 260);
    }
    else
    {
      if (v16 <= 1)
        v16 = 1;
      v17 = 2 * v16;
      if (v17 <= v15)
        v18 = v15;
      else
        v18 = v17;
      v19 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v18, "Vector Storage (uint8_t, growth)");
      memcpy(v19, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
      (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
      *(_DWORD *)(a1 + 256) = v18;
      *(_QWORD *)(a1 + 264) = v19;
      v20 = *(_DWORD *)(a1 + 260);
    }
    memmove(&v19[v14 + 1], &v19[v14], (v20 - v14));
    memcpy((void *)(*(_QWORD *)(a1 + 264) + v14), a3, v13);
    *(_DWORD *)(a1 + 260) += v13;
  }
  result = *(int *)(a1 + 308);
  *(_DWORD *)(a1 + 308) = result + 1;
  return result;
}

void *glpLLVMAddIncoming(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  char *v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  char *v23;
  int v24;
  void *result;
  int v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  int v30;
  uint64_t v31;
  char *v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  int v36;
  uint64_t v37;
  char *v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  int v42;
  uint64_t v43;
  char *v44;
  unsigned int v45;
  unsigned int v46;
  int v47;
  int v48;
  uint64_t v49;
  char *v50;
  unsigned int v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;

  v10 = *(unsigned int *)(a1 + 260);
  v11 = v10 + 1;
  v12 = *(_DWORD *)(a1 + 256);
  if ((int)v10 + 1 <= v12)
  {
    v15 = *(char **)(a1 + 264);
    v16 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v12 <= 1)
      v12 = 1;
    v13 = 2 * v12;
    if (v13 <= v11)
      v14 = v11;
    else
      v14 = v13;
    v15 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v14, "Vector Storage (uint8_t, growth)");
    memcpy(v15, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v14;
    *(_QWORD *)(a1 + 264) = v15;
    v16 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v15[v10 + 1], &v15[v10], (v16 - v10));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v10) = 95;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  glpSerializeLLVMValue(a1, a2);
  v17 = (char)glp_serialized_integer32_control(a5);
  v18 = *(unsigned int *)(a1 + 260);
  v19 = v18 + 1;
  v20 = *(_DWORD *)(a1 + 256);
  if ((int)v18 + 1 <= v20)
  {
    v23 = *(char **)(a1 + 264);
    v24 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v20 <= 1)
      v20 = 1;
    v21 = 2 * v20;
    if (v21 <= v19)
      v22 = v19;
    else
      v22 = v21;
    v23 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v22, "Vector Storage (uint8_t, growth)");
    memcpy(v23, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v22;
    *(_QWORD *)(a1 + 264) = v23;
    v24 = *(_DWORD *)(a1 + 260);
  }
  result = memmove(&v23[v18 + 1], &v23[v18], (v24 - v18));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v18) = v17;
  v26 = *(_DWORD *)(a1 + 260);
  v27 = v26 + 1;
  *(_DWORD *)(a1 + 260) = v26 + 1;
  if ((v17 & 0x80000000) != 0)
  {
    switch((v17 >> 1) & 7)
    {
      case 0u:
        v28 = v26 + 2;
        v29 = *(_DWORD *)(a1 + 256);
        if (v28 <= v29)
        {
          v32 = *(char **)(a1 + 264);
          v33 = v27;
        }
        else
        {
          if (v29 <= 1)
            v29 = 1;
          v30 = 2 * v29;
          if (v30 <= (int)v28)
            v31 = v28;
          else
            v31 = v30;
          v32 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v31, "Vector Storage (uint8_t, growth)");
          memcpy(v32, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v31;
          *(_QWORD *)(a1 + 264) = v32;
          v33 = *(_DWORD *)(a1 + 260);
        }
        result = memmove(&v32[v27 + 1], &v32[v27], v33 - v27);
        *(_BYTE *)(*(_QWORD *)(a1 + 264) + v27) = a5;
        v52 = 1;
        goto LABEL_55;
      case 1u:
        v46 = v26 + 3;
        v47 = *(_DWORD *)(a1 + 256);
        if (v46 <= v47)
        {
          v50 = *(char **)(a1 + 264);
          v51 = v27;
        }
        else
        {
          if (v47 <= 1)
            v47 = 1;
          v48 = 2 * v47;
          if (v48 <= (int)v46)
            v49 = v46;
          else
            v49 = v48;
          v50 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v49, "Vector Storage (uint8_t, growth)");
          memcpy(v50, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v49;
          *(_QWORD *)(a1 + 264) = v50;
          v51 = *(_DWORD *)(a1 + 260);
        }
        result = memmove(&v50[v27 + 1], &v50[v27], v51 - v27);
        *(_WORD *)(*(_QWORD *)(a1 + 264) + v27) = a5;
        v52 = 2;
        goto LABEL_55;
      case 2u:
        v34 = v26 + 4;
        v35 = *(_DWORD *)(a1 + 256);
        if (v34 <= v35)
        {
          v38 = *(char **)(a1 + 264);
          v39 = v27;
        }
        else
        {
          if (v35 <= 1)
            v35 = 1;
          v36 = 2 * v35;
          if (v36 <= (int)v34)
            v37 = v34;
          else
            v37 = v36;
          v38 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v37, "Vector Storage (uint8_t, growth)");
          memcpy(v38, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v37;
          *(_QWORD *)(a1 + 264) = v38;
          v39 = *(_DWORD *)(a1 + 260);
        }
        result = memmove(&v38[v27 + 1], &v38[v27], v39 - v27);
        v53 = *(_QWORD *)(a1 + 264) + v27;
        *(_BYTE *)(v53 + 2) = BYTE2(a5);
        *(_WORD *)v53 = a5;
        v52 = 3;
        goto LABEL_55;
      case 3u:
        v40 = v26 + 5;
        v41 = *(_DWORD *)(a1 + 256);
        if (v40 <= v41)
        {
          v44 = *(char **)(a1 + 264);
          v45 = v27;
        }
        else
        {
          if (v41 <= 1)
            v41 = 1;
          v42 = 2 * v41;
          if (v42 <= (int)v40)
            v43 = v40;
          else
            v43 = v42;
          v44 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v43, "Vector Storage (uint8_t, growth)");
          memcpy(v44, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v43;
          *(_QWORD *)(a1 + 264) = v44;
          v45 = *(_DWORD *)(a1 + 260);
        }
        result = memmove(&v44[v27 + 1], &v44[v27], v45 - v27);
        *(_DWORD *)(*(_QWORD *)(a1 + 264) + v27) = a5;
        v52 = 4;
LABEL_55:
        *(_DWORD *)(a1 + 260) += v52;
        break;
      default:
        break;
    }
  }
  if ((_DWORD)a5)
  {
    a5 = a5;
    do
    {
      v54 = *a3++;
      glpSerializeLLVMValue(a1, v54);
      v55 = *a4++;
      result = glpSerializeLLVMBlock(a1, v55);
      --a5;
    }
    while (a5);
  }
  return result;
}

uint64_t glpLLVMAppendBasicBlock(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  char *v11;
  int v12;
  size_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  char *v19;
  int v20;
  uint64_t result;

  v6 = *(unsigned int *)(a1 + 260);
  v7 = v6 + 1;
  v8 = *(_DWORD *)(a1 + 256);
  if ((int)v6 + 1 <= v8)
  {
    v11 = *(char **)(a1 + 264);
    v12 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v8 <= 1)
      v8 = 1;
    v9 = 2 * v8;
    if (v9 <= v7)
      v10 = v7;
    else
      v10 = v9;
    v11 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v10, "Vector Storage (uint8_t, growth)");
    memcpy(v11, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v10;
    *(_QWORD *)(a1 + 264) = v11;
    v12 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v11[v6 + 1], &v11[v6], (v12 - v6));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v6) = 20;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  glpSerializeLLVMValue(a1, a2);
  v13 = strlen(a3) + 1;
  v14 = *(unsigned int *)(a1 + 260);
  v15 = v13 + v14;
  v16 = *(_DWORD *)(a1 + 256);
  if ((int)v13 + (int)v14 <= v16)
  {
    v19 = *(char **)(a1 + 264);
    v20 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v16 <= 1)
      v16 = 1;
    v17 = 2 * v16;
    if (v17 <= v15)
      v18 = v15;
    else
      v18 = v17;
    v19 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v18, "Vector Storage (uint8_t, growth)");
    memcpy(v19, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v18;
    *(_QWORD *)(a1 + 264) = v19;
    v20 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v19[v14 + 1], &v19[v14], (v20 - v14));
  memcpy((void *)(*(_QWORD *)(a1 + 264) + v14), a3, v13);
  *(_DWORD *)(a1 + 260) += v13;
  result = *(int *)(a1 + 312);
  *(_DWORD *)(a1 + 312) = result + 1;
  return result;
}

uint64_t glpLLVMSplatScalar(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t inserted;
  unint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  size_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  _QWORD v19[2];

  v19[1] = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a1 + 520);
  if (!v6)
  {
    v6 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), 0, 0);
    *(_QWORD *)(a1 + 520) = v6;
  }
  v7 = glpLLVMTypeOf(a1, a2);
  v8 = glpLLVMVectorType(a1, v7, a3);
  v9 = glpLLVMConstFromTypeCache(a1, 37, v8);
  inserted = glpLLVMBuildInsertElement(a1, v9, a2, v6, "");
  MEMORY[0x24BDAC7A8](inserted);
  v13 = (_QWORD *)((char *)v19 - v12);
  if (v11 >= 0x200)
    v14 = 512;
  else
    v14 = v11;
  bzero((char *)v19 - v12, v14);
  if ((_DWORD)a3)
  {
    v15 = a3;
    v16 = v13;
    do
    {
      *v16++ = v6;
      --v15;
    }
    while (v15);
  }
  v17 = glpLLVMConstVectorCache(a1, v13, a3);
  return glpLLVMBuildShuffleVector(a1, inserted, inserted, v17, "");
}

uint64_t glpLLVMSplatElement(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t inserted;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  size_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD v19[2];

  v19[1] = *MEMORY[0x24BDAC8D0];
  if ((_DWORD)a3 == 1)
    return a2;
  v7 = glpLLVMTypeOf(a1, a2);
  v8 = glpLLVMVectorType(a1, v7, a3);
  v9 = glpLLVMConstFromTypeCache(a1, 37, v8);
  v10 = *(_QWORD *)(a1 + 520);
  if (!v10)
  {
    v10 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), 0, 0);
    *(_QWORD *)(a1 + 520) = v10;
  }
  inserted = glpLLVMBuildInsertElement(a1, v9, a2, v10, "");
  MEMORY[0x24BDAC7A8](inserted);
  v14 = (_QWORD *)((char *)v19 - v13);
  if (v12 >= 0x200)
    v15 = 512;
  else
    v15 = v12;
  bzero((char *)v19 - v13, v15);
  if ((int)a3 >= 1)
  {
    v16 = a3;
    v17 = v14;
    do
    {
      *v17++ = v10;
      --v16;
    }
    while (v16);
  }
  v18 = glpLLVMConstVectorCache(a1, v14, a3);
  return glpLLVMBuildShuffleVector(a1, inserted, inserted, v18, "");
}

uint64_t glpGetTextureSize(int a1, int *a2)
{
  int v3;
  uint64_t result;

  v3 = 0;
  result = 2;
  switch(a1)
  {
    case 0:
    case 1:
    case 16:
      goto LABEL_6;
    case 4:
    case 9:
    case 13:
      goto LABEL_4;
    case 5:
    case 6:
    case 12:
      v3 = 1;
      break;
    case 7:
    case 11:
      v3 = 1;
LABEL_4:
      result = 1;
      break;
    case 8:
    case 17:
      v3 = 1;
LABEL_6:
      result = 3;
      break;
    default:
      break;
  }
  *a2 = v3;
  return result;
}

char *glpTextureNameFromSamplerType(int a1)
{
  unsigned int PPTextarget;

  PPTextarget = glpPrimitiveSamplerGetPPTextarget(a1);
  if (PPTextarget >= 0x12)
    abort();
  return off_24F4AFDA0[PPTextarget];
}

uint64_t glpLLVMBuildInsertValue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  char *v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  char *v23;
  int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  int v29;
  uint64_t v30;
  char *v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  int v35;
  uint64_t v36;
  char *v37;
  unsigned int v38;
  unsigned int v39;
  int v40;
  int v41;
  uint64_t v42;
  char *v43;
  unsigned int v44;
  unsigned int v45;
  int v46;
  int v47;
  uint64_t v48;
  char *v49;
  unsigned int v50;
  uint64_t v51;
  size_t v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  char *v57;
  unsigned int v58;
  uint64_t result;

  v10 = *(unsigned int *)(a1 + 260);
  v11 = v10 + 1;
  v12 = *(_DWORD *)(a1 + 256);
  if ((int)v10 + 1 <= v12)
  {
    v15 = *(char **)(a1 + 264);
    v16 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v12 <= 1)
      v12 = 1;
    v13 = 2 * v12;
    if (v13 <= v11)
      v14 = v11;
    else
      v14 = v13;
    v15 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v14, "Vector Storage (uint8_t, growth)");
    memcpy(v15, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v14;
    *(_QWORD *)(a1 + 264) = v15;
    v16 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v15[v10 + 1], &v15[v10], (v16 - v10));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v10) = 51;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  glpSerializeLLVMValue(a1, a2);
  glpSerializeLLVMValue(a1, a3);
  v17 = (char)glp_serialized_integer32_control(a4);
  v18 = *(unsigned int *)(a1 + 260);
  v19 = v18 + 1;
  v20 = *(_DWORD *)(a1 + 256);
  if ((int)v18 + 1 <= v20)
  {
    v23 = *(char **)(a1 + 264);
    v24 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v20 <= 1)
      v20 = 1;
    v21 = 2 * v20;
    if (v21 <= v19)
      v22 = v19;
    else
      v22 = v21;
    v23 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v22, "Vector Storage (uint8_t, growth)");
    memcpy(v23, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v22;
    *(_QWORD *)(a1 + 264) = v23;
    v24 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v23[v18 + 1], &v23[v18], (v24 - v18));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v18) = v17;
  v25 = *(_DWORD *)(a1 + 260);
  v26 = v25 + 1;
  *(_DWORD *)(a1 + 260) = v25 + 1;
  if ((v17 & 0x80000000) != 0)
  {
    switch((v17 >> 1) & 7)
    {
      case 0u:
        v27 = v25 + 2;
        v28 = *(_DWORD *)(a1 + 256);
        if (v27 <= v28)
        {
          v31 = *(char **)(a1 + 264);
          v32 = v26;
        }
        else
        {
          if (v28 <= 1)
            v28 = 1;
          v29 = 2 * v28;
          if (v29 <= (int)v27)
            v30 = v27;
          else
            v30 = v29;
          v31 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v30, "Vector Storage (uint8_t, growth)");
          memcpy(v31, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v30;
          *(_QWORD *)(a1 + 264) = v31;
          v32 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v31[v26 + 1], &v31[v26], v32 - v26);
        *(_BYTE *)(*(_QWORD *)(a1 + 264) + v26) = a4;
        v26 = *(_DWORD *)(a1 + 260) + 1;
        goto LABEL_55;
      case 1u:
        v45 = v25 + 3;
        v46 = *(_DWORD *)(a1 + 256);
        if (v45 <= v46)
        {
          v49 = *(char **)(a1 + 264);
          v50 = v26;
        }
        else
        {
          if (v46 <= 1)
            v46 = 1;
          v47 = 2 * v46;
          if (v47 <= (int)v45)
            v48 = v45;
          else
            v48 = v47;
          v49 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v48, "Vector Storage (uint8_t, growth)");
          memcpy(v49, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v48;
          *(_QWORD *)(a1 + 264) = v49;
          v50 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v49[v26 + 1], &v49[v26], v50 - v26);
        *(_WORD *)(*(_QWORD *)(a1 + 264) + v26) = a4;
        v26 = *(_DWORD *)(a1 + 260) + 2;
        goto LABEL_55;
      case 2u:
        v33 = v25 + 4;
        v34 = *(_DWORD *)(a1 + 256);
        if (v33 <= v34)
        {
          v37 = *(char **)(a1 + 264);
          v38 = v26;
        }
        else
        {
          if (v34 <= 1)
            v34 = 1;
          v35 = 2 * v34;
          if (v35 <= (int)v33)
            v36 = v33;
          else
            v36 = v35;
          v37 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v36, "Vector Storage (uint8_t, growth)");
          memcpy(v37, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v36;
          *(_QWORD *)(a1 + 264) = v37;
          v38 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v37[v26 + 1], &v37[v26], v38 - v26);
        v51 = *(_QWORD *)(a1 + 264) + v26;
        *(_BYTE *)(v51 + 2) = BYTE2(a4);
        *(_WORD *)v51 = a4;
        v26 = *(_DWORD *)(a1 + 260) + 3;
        goto LABEL_55;
      case 3u:
        v39 = v25 + 5;
        v40 = *(_DWORD *)(a1 + 256);
        if (v39 <= v40)
        {
          v43 = *(char **)(a1 + 264);
          v44 = v26;
        }
        else
        {
          if (v40 <= 1)
            v40 = 1;
          v41 = 2 * v40;
          if (v41 <= (int)v39)
            v42 = v39;
          else
            v42 = v41;
          v43 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v42, "Vector Storage (uint8_t, growth)");
          memcpy(v43, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v42;
          *(_QWORD *)(a1 + 264) = v43;
          v44 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v43[v26 + 1], &v43[v26], v44 - v26);
        *(_DWORD *)(*(_QWORD *)(a1 + 264) + v26) = a4;
        v26 = *(_DWORD *)(a1 + 260) + 4;
LABEL_55:
        *(_DWORD *)(a1 + 260) = v26;
        break;
      default:
        break;
    }
  }
  if (*(_DWORD *)(a1 + 300))
  {
    v52 = strlen(a5) + 1;
    v53 = v52 + v26;
    v54 = *(_DWORD *)(a1 + 256);
    if (v52 + v26 <= v54)
    {
      v57 = *(char **)(a1 + 264);
      v58 = v26;
    }
    else
    {
      if (v54 <= 1)
        v54 = 1;
      v55 = 2 * v54;
      if (v55 <= v53)
        v56 = v53;
      else
        v56 = v55;
      v57 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v56, "Vector Storage (uint8_t, growth)");
      memcpy(v57, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
      (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
      *(_DWORD *)(a1 + 256) = v56;
      *(_QWORD *)(a1 + 264) = v57;
      v58 = *(_DWORD *)(a1 + 260);
    }
    memmove(&v57[v26 + 1], &v57[v26], v58 - v26);
    memcpy((void *)(*(_QWORD *)(a1 + 264) + v26), a5, v52);
    *(_DWORD *)(a1 + 260) += v52;
  }
  result = *(int *)(a1 + 308);
  *(_DWORD *)(a1 + 308) = result + 1;
  return result;
}

uint64_t glpLLVMStructTypeInContext(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  char *v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  char *v19;
  int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  int v43;
  uint64_t v44;
  char *v45;
  unsigned int v46;
  int v47;
  uint64_t v48;
  uint64_t result;

  v6 = *(unsigned int *)(a1 + 260);
  v7 = v6 + 1;
  v8 = *(_DWORD *)(a1 + 256);
  if ((int)v6 + 1 <= v8)
  {
    v11 = *(char **)(a1 + 264);
    v12 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v8 <= 1)
      v8 = 1;
    v9 = 2 * v8;
    if (v9 <= v7)
      v10 = v7;
    else
      v10 = v9;
    v11 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v10, "Vector Storage (uint8_t, growth)");
    memcpy(v11, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v10;
    *(_QWORD *)(a1 + 264) = v11;
    v12 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v11[v6 + 1], &v11[v6], (v12 - v6));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v6) = 39;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  glpSerializeArrayOfLLVMTypes(a1, a2, a3);
  v13 = (char)glp_serialized_integer32_control(0);
  v14 = *(unsigned int *)(a1 + 260);
  v15 = v14 + 1;
  v16 = *(_DWORD *)(a1 + 256);
  if ((int)v14 + 1 <= v16)
  {
    v19 = *(char **)(a1 + 264);
    v20 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v16 <= 1)
      v16 = 1;
    v17 = 2 * v16;
    if (v17 <= v15)
      v18 = v15;
    else
      v18 = v17;
    v19 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v18, "Vector Storage (uint8_t, growth)");
    memcpy(v19, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v18;
    *(_QWORD *)(a1 + 264) = v19;
    v20 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v19[v14 + 1], &v19[v14], (v20 - v14));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v14) = v13;
  v21 = *(_DWORD *)(a1 + 260);
  v22 = v21 + 1;
  *(_DWORD *)(a1 + 260) = v21 + 1;
  if ((v13 & 0x80000000) != 0)
  {
    switch((v13 >> 1) & 7)
    {
      case 0u:
        v23 = v21 + 2;
        v24 = *(_DWORD *)(a1 + 256);
        if (v23 <= v24)
        {
          v27 = *(char **)(a1 + 264);
          v28 = v22;
        }
        else
        {
          if (v24 <= 1)
            v24 = 1;
          v25 = 2 * v24;
          if (v25 <= (int)v23)
            v26 = v23;
          else
            v26 = v25;
          v27 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v26, "Vector Storage (uint8_t, growth)");
          memcpy(v27, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v26;
          *(_QWORD *)(a1 + 264) = v27;
          v28 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v27[v22 + 1], &v27[v22], v28 - v22);
        *(_BYTE *)(*(_QWORD *)(a1 + 264) + v22) = 0;
        v47 = 1;
        goto LABEL_55;
      case 1u:
        v41 = v21 + 3;
        v42 = *(_DWORD *)(a1 + 256);
        if (v41 <= v42)
        {
          v45 = *(char **)(a1 + 264);
          v46 = v22;
        }
        else
        {
          if (v42 <= 1)
            v42 = 1;
          v43 = 2 * v42;
          if (v43 <= (int)v41)
            v44 = v41;
          else
            v44 = v43;
          v45 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v44, "Vector Storage (uint8_t, growth)");
          memcpy(v45, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v44;
          *(_QWORD *)(a1 + 264) = v45;
          v46 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v45[v22 + 1], &v45[v22], v46 - v22);
        *(_WORD *)(*(_QWORD *)(a1 + 264) + v22) = 0;
        v47 = 2;
        goto LABEL_55;
      case 2u:
        v29 = v21 + 4;
        v30 = *(_DWORD *)(a1 + 256);
        if (v29 <= v30)
        {
          v33 = *(char **)(a1 + 264);
          v34 = v22;
        }
        else
        {
          if (v30 <= 1)
            v30 = 1;
          v31 = 2 * v30;
          if (v31 <= (int)v29)
            v32 = v29;
          else
            v32 = v31;
          v33 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v32, "Vector Storage (uint8_t, growth)");
          memcpy(v33, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v32;
          *(_QWORD *)(a1 + 264) = v33;
          v34 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v33[v22 + 1], &v33[v22], v34 - v22);
        v48 = *(_QWORD *)(a1 + 264) + v22;
        *(_BYTE *)(v48 + 2) = 0;
        *(_WORD *)v48 = 0;
        v47 = 3;
        goto LABEL_55;
      case 3u:
        v35 = v21 + 5;
        v36 = *(_DWORD *)(a1 + 256);
        if (v35 <= v36)
        {
          v39 = *(char **)(a1 + 264);
          v40 = v22;
        }
        else
        {
          if (v36 <= 1)
            v36 = 1;
          v37 = 2 * v36;
          if (v37 <= (int)v35)
            v38 = v35;
          else
            v38 = v37;
          v39 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v38, "Vector Storage (uint8_t, growth)");
          memcpy(v39, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v38;
          *(_QWORD *)(a1 + 264) = v39;
          v40 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v39[v22 + 1], &v39[v22], v40 - v22);
        *(_DWORD *)(*(_QWORD *)(a1 + 264) + v22) = 0;
        v47 = 4;
LABEL_55:
        *(_DWORD *)(a1 + 260) += v47;
        break;
      default:
        break;
    }
  }
  result = *(int *)(a1 + 304);
  *(_DWORD *)(a1 + 304) = result + 1;
  return result;
}

uint64_t glpLLVMTypesEqual(_DWORD *a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  _BOOL4 v10;
  _BOOL4 v11;
  int Length;
  int v13;
  uint64_t result;
  int ScalarType;
  int v16;
  _DWORD *v17;
  _DWORD *v18;
  int v19;
  _DWORD *v20;
  int v21;

  v10 = glpPrimitiveTypeGetScalarType(a2) == 5 || glpPrimitiveTypeGetScalarType(a2) == 36;
  v11 = glpPrimitiveTypeGetScalarType(a4) == 5 || glpPrimitiveTypeGetScalarType(a4) == 36;
  if (glpPrimitiveTypeGetCategory(a2) == 2)
    Length = glpPrimitiveVectorGetLength(a2);
  else
    Length = 1;
  if (glpPrimitiveTypeGetCategory(a4) == 2)
    v13 = glpPrimitiveVectorGetLength(a4);
  else
    v13 = 1;
  if ((_DWORD)a2 == (_DWORD)a4 || (result = 0, v10 && v11) && Length == v13)
  {
    if (a3 != a5)
    {
      ScalarType = glpPrimitiveTypeGetScalarType(a2);
      v16 = ScalarType;
      if (ScalarType > 8)
      {
        result = 1;
        if (v16 == 9)
          return result;
        if (v16 != 36)
        {
          if (v16 == 62)
            return result;
          return 0;
        }
LABEL_24:
        switch(a3)
        {
          case 0:
          case 3:
            v17 = a1 + 31;
            goto LABEL_30;
          case 1:
            v17 = a1 + 29;
            goto LABEL_30;
          case 2:
            v17 = a1 + 30;
LABEL_30:
            if (*v17 <= 0x10u)
              goto LABEL_31;
            v19 = 32;
            break;
          default:
LABEL_31:
            v19 = 16;
            break;
        }
        switch(a5)
        {
          case 0:
          case 3:
            v20 = a1 + 31;
            goto LABEL_46;
          case 1:
            v20 = a1 + 29;
            goto LABEL_46;
          case 2:
            v20 = a1 + 30;
            goto LABEL_46;
          default:
            goto LABEL_47;
        }
      }
      if (ScalarType != 1)
      {
        if (ScalarType == 5)
          goto LABEL_24;
        return 0;
      }
      switch(a3)
      {
        case 0:
        case 3:
          v18 = a1 + 28;
          goto LABEL_39;
        case 1:
          v18 = a1 + 26;
          goto LABEL_39;
        case 2:
          v18 = a1 + 27;
LABEL_39:
          if (*v18 <= 0x10u)
            goto LABEL_40;
          v19 = 32;
          break;
        default:
LABEL_40:
          v19 = 16;
          break;
      }
      switch(a5)
      {
        case 0:
        case 3:
          v20 = a1 + 28;
          goto LABEL_46;
        case 1:
          v20 = a1 + 26;
          goto LABEL_46;
        case 2:
          v20 = a1 + 27;
LABEL_46:
          if (*v20 <= 0x10u)
            goto LABEL_47;
          v21 = 32;
          break;
        default:
LABEL_47:
          v21 = 16;
          break;
      }
      if (v19 != v21)
        return 0;
    }
    return 1;
  }
  return result;
}

void *glpSerializeArrayOfLLVMTypes(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  void *result;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;

  LODWORD(v3) = a3;
  v6 = (char)glp_serialized_integer32_control(a3);
  v7 = *(unsigned int *)(a1 + 260);
  v8 = v7 + 1;
  v9 = *(_DWORD *)(a1 + 256);
  if ((int)v7 + 1 <= v9)
  {
    v12 = *(char **)(a1 + 264);
    v13 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v9 <= 1)
      v9 = 1;
    v10 = 2 * v9;
    if (v10 <= v8)
      v11 = v8;
    else
      v11 = v10;
    v12 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v11, "Vector Storage (uint8_t, growth)");
    memcpy(v12, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v11;
    *(_QWORD *)(a1 + 264) = v12;
    v13 = *(_DWORD *)(a1 + 260);
  }
  result = memmove(&v12[v7 + 1], &v12[v7], (v13 - v7));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v7) = v6;
  v15 = *(_DWORD *)(a1 + 260);
  v16 = v15 + 1;
  *(_DWORD *)(a1 + 260) = v15 + 1;
  if ((v6 & 0x80000000) != 0)
  {
    switch((v6 >> 1) & 7)
    {
      case 0u:
        v17 = v15 + 2;
        v18 = *(_DWORD *)(a1 + 256);
        if (v17 <= v18)
        {
          v21 = *(char **)(a1 + 264);
          v22 = v16;
        }
        else
        {
          if (v18 <= 1)
            v18 = 1;
          v19 = 2 * v18;
          if (v19 <= (int)v17)
            v20 = v17;
          else
            v20 = v19;
          v21 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v20, "Vector Storage (uint8_t, growth)");
          memcpy(v21, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v20;
          *(_QWORD *)(a1 + 264) = v21;
          v22 = *(_DWORD *)(a1 + 260);
        }
        result = memmove(&v21[v16 + 1], &v21[v16], v22 - v16);
        *(_BYTE *)(*(_QWORD *)(a1 + 264) + v16) = v3;
        v41 = 1;
        goto LABEL_47;
      case 1u:
        v35 = v15 + 3;
        v36 = *(_DWORD *)(a1 + 256);
        if (v35 <= v36)
        {
          v39 = *(char **)(a1 + 264);
          v40 = v16;
        }
        else
        {
          if (v36 <= 1)
            v36 = 1;
          v37 = 2 * v36;
          if (v37 <= (int)v35)
            v38 = v35;
          else
            v38 = v37;
          v39 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v38, "Vector Storage (uint8_t, growth)");
          memcpy(v39, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v38;
          *(_QWORD *)(a1 + 264) = v39;
          v40 = *(_DWORD *)(a1 + 260);
        }
        result = memmove(&v39[v16 + 1], &v39[v16], v40 - v16);
        *(_WORD *)(*(_QWORD *)(a1 + 264) + v16) = v3;
        v41 = 2;
        goto LABEL_47;
      case 2u:
        v23 = v15 + 4;
        v24 = *(_DWORD *)(a1 + 256);
        if (v23 <= v24)
        {
          v27 = *(char **)(a1 + 264);
          v28 = v16;
        }
        else
        {
          if (v24 <= 1)
            v24 = 1;
          v25 = 2 * v24;
          if (v25 <= (int)v23)
            v26 = v23;
          else
            v26 = v25;
          v27 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v26, "Vector Storage (uint8_t, growth)");
          memcpy(v27, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v26;
          *(_QWORD *)(a1 + 264) = v27;
          v28 = *(_DWORD *)(a1 + 260);
        }
        result = memmove(&v27[v16 + 1], &v27[v16], v28 - v16);
        v42 = *(_QWORD *)(a1 + 264) + v16;
        *(_BYTE *)(v42 + 2) = BYTE2(v3);
        *(_WORD *)v42 = v3;
        v41 = 3;
        goto LABEL_47;
      case 3u:
        v29 = v15 + 5;
        v30 = *(_DWORD *)(a1 + 256);
        if (v29 <= v30)
        {
          v33 = *(char **)(a1 + 264);
          v34 = v16;
        }
        else
        {
          if (v30 <= 1)
            v30 = 1;
          v31 = 2 * v30;
          if (v31 <= (int)v29)
            v32 = v29;
          else
            v32 = v31;
          v33 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v32, "Vector Storage (uint8_t, growth)");
          memcpy(v33, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v32;
          *(_QWORD *)(a1 + 264) = v33;
          v34 = *(_DWORD *)(a1 + 260);
        }
        result = memmove(&v33[v16 + 1], &v33[v16], v34 - v16);
        *(_DWORD *)(*(_QWORD *)(a1 + 264) + v16) = v3;
        v41 = 4;
LABEL_47:
        *(_DWORD *)(a1 + 260) += v41;
        break;
      default:
        break;
    }
  }
  if ((_DWORD)v3)
  {
    v3 = v3;
    do
    {
      v43 = *a2++;
      result = glpSerializeLLVMType(a1, v43);
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t glpBuildArrayElementPtr(uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  int *Value;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (glpIsConstantNode(a4) && (Value = (int *)glpConstantNodeGetValue(a4), !a6))
  {
    v18 = *Value;
    v15 = glpBuildArrayElementPtrCst(a1, a2, a3, *Value);
    if (a5)
    {
      v17 = glpBuildArrayElementPtrCst(a1, a2, a3, v18 + 1);
LABEL_11:
      *a5 = v17;
    }
  }
  else
  {
    v13 = a1[65];
    if (!v13)
    {
      v13 = glpLLVMConstIntCache((uint64_t)a1, a1[5], 0, 0);
      a1[65] = v13;
    }
    v20 = v13;
    v14 = glpLLVMCGNode(a1, a4, 1);
    v21 = v14;
    v15 = glpLLVMBuildGEP((uint64_t)a1, a3, &v20, 2, "ptr");
    if (a5)
    {
      v16 = a1[66];
      if (!v16)
      {
        v16 = glpLLVMConstIntCache((uint64_t)a1, a1[5], 1uLL, 0);
        a1[66] = v16;
      }
      v21 = glpLLVMBinaryOperation((uint64_t)a1, 53, v14, v16, "idx");
      v17 = glpLLVMBuildGEP((uint64_t)a1, a3, &v20, 2, "nptr");
      goto LABEL_11;
    }
  }
  return v15;
}

uint64_t glpLLVMLoadVector(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t SourceVariable;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  char *v20;
  int v21;

  SourceVariable = glpLoadSourceVariable((_QWORD *)a1, a3, a2);
  v13 = glpPrimitiveTypeToLLVMType((_QWORD *)a1, a4, a5);
  if ((_DWORD)a6)
  {
    v14 = v13;
    if (!glpLLVMTypesEqual((_DWORD *)a1, a6, a7, a4, a5))
    {
      v15 = *(unsigned int *)(a1 + 260);
      v16 = v15 + 1;
      v17 = *(_DWORD *)(a1 + 256);
      if ((int)v15 + 1 <= v17)
      {
        v20 = *(char **)(a1 + 264);
        v21 = *(_DWORD *)(a1 + 260);
      }
      else
      {
        if (v17 <= 1)
          v17 = 1;
        v18 = 2 * v17;
        if (v18 <= v16)
          v19 = v16;
        else
          v19 = v18;
        v20 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v19, "Vector Storage (uint8_t, growth)");
        memcpy(v20, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
        (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
        *(_DWORD *)(a1 + 256) = v19;
        *(_QWORD *)(a1 + 264) = v20;
        v21 = *(_DWORD *)(a1 + 260);
      }
      memmove(&v20[v15 + 1], &v20[v15], (v21 - v15));
      *(_BYTE *)(*(_QWORD *)(a1 + 264) + v15) = 107;
      ++*(_DWORD *)(a1 + 260);
      ++*(_DWORD *)(a1 + 296);
      glpSerializeLLVMValue(a1, SourceVariable);
      glpSerializeLLVMType(a1, v14);
      SourceVariable = *(int *)(a1 + 308);
      *(_DWORD *)(a1 + 308) = SourceVariable + 1;
    }
  }
  return SourceVariable;
}

uint64_t glpBuildArrayElementPtrCst(uint64_t *a1, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t Gep;
  uint64_t v9;
  uint64_t inserted;
  uint64_t v12[3];

  v12[2] = *MEMORY[0x24BDAC8D0];
  Gep = glpFindGep((uint64_t)a1, a2, 0, a4);
  if (!Gep)
  {
    v9 = a1[65];
    if (!v9)
    {
      v9 = glpLLVMConstIntCache((uint64_t)a1, a1[5], 0, 0);
      a1[65] = v9;
    }
    v12[0] = v9;
    v12[1] = glpLLVMConstIntCache((uint64_t)a1, a1[5], a4, 1);
    inserted = glpLLVMGetInsertBlock((uint64_t)a1);
    glpLLVMPositionBuilderAtEnd((uint64_t)a1, a1[23]);
    Gep = glpLLVMBuildGEP((uint64_t)a1, a3, v12, 2, "ptr");
    glpLLVMPositionBuilderAtEnd((uint64_t)a1, inserted);
    glpAddGep(a1, a2, 0, a4, Gep);
  }
  return Gep;
}

uint64_t glpLoadSourceVariable(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v7;
  char __str[16];
  __int128 v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a3 + 51) & 1) == 0)
    return glpLLVMBuildLoad((uint64_t)a1, a2, "srcPointer");
  v7 = glpLayoutObjectFind(*(uint64_t **)(a3 + 8), 35);
  *(_OWORD *)__str = 0u;
  v9 = 0u;
  snprintf(__str, 0x1FuLL, "user(slot%u)", *((_DWORD *)v7 + 4));
  return glpBuildInterpolateAt(a1, a2, a3, *(_QWORD *)(a3 + 48), __str, 0);
}

uint64_t glpIsComponentAssigment(uint64_t result, unsigned int ***a2, _DWORD *a3, _DWORD *a4, int *a5, int a6)
{
  uint64_t v11;
  uint64_t Lhs;
  unsigned int **VariableExtra;
  uint64_t OffsetExpr;
  uint64_t v15;
  int v16;
  unsigned int *v17;
  uint64_t PrimitiveType;
  int Category;

  if (result)
  {
    v11 = result;
    if (glpASTNodeGetKind(result) == 39)
    {
      Lhs = glpBinaryOperatorNodeGetLhs(v11);
      VariableExtra = (unsigned int **)glpLValueNodeGetVariableExtra(Lhs);
      result = glpDerefNodeGetOffset(Lhs);
      if (!result)
        return result;
      OffsetExpr = glpOffsetNodeGetOffsetExpr(result);
      if (OffsetExpr)
      {
        v15 = OffsetExpr;
        result = glpIsConstantNode(OffsetExpr);
        if (!(_DWORD)result)
          return result;
        v16 = *(_DWORD *)glpConstantNodeGetValue(v15);
      }
      else
      {
        v16 = 0;
      }
      if (*a2)
      {
        if (*a2 == VariableExtra && !*a3 && *a4 == v16)
        {
LABEL_20:
          result = glpGetVectorSwizzle(Lhs, a5);
          if ((_DWORD)result)
          {
            *a2 = VariableExtra;
            *a3 = 0;
            result = 1;
            *a4 = v16;
          }
          return result;
        }
      }
      else
      {
        v17 = *VariableExtra;
        if (!glpTypeGetKind(*VariableExtra))
        {
          PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)v17);
          Category = glpPrimitiveTypeGetCategory(PrimitiveType);
          if (Category == 2 || Category == 3 && !a6 && glpPrimitiveTypeGetScalarType(PrimitiveType) != 62)
            goto LABEL_20;
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t glpProcessComponentWiseVectorAssignment(uint64_t *a1, uint64_t *a2, int a3, uint64_t *a4, unsigned int *a5, int a6, uint64_t a7)
{
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t Rhs;
  int Kind;
  uint64_t VariableExtra;
  unsigned int PrimitiveType;
  uint64_t Offset;
  uint64_t VectorElementExpr;
  uint64_t OffsetExpr;
  BOOL v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  unsigned int *v30;
  uint64_t v31;
  int Length;
  uint64_t v33;
  int Category;
  uint64_t ColumnType;
  uint64_t v36;
  int v37;
  unint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  size_t v43;
  uint64_t v44;
  uint64_t *v45;
  size_t v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  unsigned int v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  char *v62;
  uint64_t *v63;
  _QWORD *v64;
  uint64_t v65;
  uint64_t inserted;
  uint64_t v67;
  uint64_t *v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  int v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t *v81;
  size_t v82;
  int v83;
  uint64_t v84;
  uint64_t *v85;
  uint64_t *v86;
  uint64_t *v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  uint64_t *v92;
  uint64_t *v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  unint64_t v98;
  uint64_t *v99;
  uint64_t v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t *v103;
  uint64_t v104;
  uint64_t *v105;
  uint64_t v106;
  int v107;
  int v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t *v113;
  uint64_t v114;
  uint64_t v116;
  uint64_t SourceVariable;
  uint64_t *v118;
  uint64_t *v119;
  uint64_t v120;
  uint64_t *v121;
  uint64_t v122;
  uint64_t *v123;
  uint64_t *v124;
  uint64_t v125;

  LODWORD(v120) = a3;
  v121 = a2;
  v123 = a1;
  v125 = *MEMORY[0x24BDAC8D0];
  v9 = (a7 - 1);
  v122 = a7;
  if ((int)a7 >= 1)
  {
    LODWORD(v119) = a6;
    v10 = 0;
    v124 = 0;
    v11 = 1;
    v12 = a7;
    while (1)
    {
      Rhs = glpBinaryOperatorNodeGetRhs(a4[v10]);
      Kind = glpASTNodeGetKind(Rhs);
      if (Kind == 3)
      {
        VectorElementExpr = v11;
      }
      else
      {
        if (Kind != 81
          || (VariableExtra = glpLValueNodeGetVariableExtra(Rhs),
              glpTypeGetKind(*(unsigned int **)VariableExtra))
          || (*(_BYTE *)(VariableExtra + 52) & 1) != 0
          || (PrimitiveType = glpPrimitiveTypeGetPrimitiveType(*(_QWORD *)VariableExtra),
              glpPrimitiveTypeGetCategory(PrimitiveType) != 2)
          || (Offset = glpDerefNodeGetOffset(Rhs),
              VectorElementExpr = glpOffsetNodeGetVectorElementExpr(Offset),
              OffsetExpr = glpOffsetNodeGetOffsetExpr(Offset),
              glpOffsetNodeGetBankIndex(Offset))
          || OffsetExpr
          || VectorElementExpr)
        {
          do
          {
            v23 = *a4++;
            v22 = v23;
            if ((_DWORD)v119)
              v24 = v9 == 0;
            else
              v24 = 0;
            v25 = v24;
            v26 = glpLLVMCGNode(v123, v22, v25);
            --v9;
            --v12;
          }
          while (v12);
          return v26;
        }
        if (v124)
          v20 = v124 == (uint64_t *)VariableExtra;
        else
          v20 = 1;
        v21 = v20;
        if ((v11 & 1) != 0 && v21)
        {
          glpOffsetNodeGetSwizzle(Offset);
          VectorElementExpr = 1;
          v124 = (uint64_t *)VariableExtra;
        }
      }
      ++v10;
      v11 = VectorElementExpr;
      if (v10 >= v12)
        goto LABEL_32;
    }
  }
  v124 = 0;
  LODWORD(VectorElementExpr) = 1;
LABEL_32:
  v28 = v123;
  v29 = glpLLVMGetVariablePointer((uint64_t)v123, (unint64_t)v121);
  v30 = (unsigned int *)*v121;
  v31 = glpTypeGetKind((unsigned int *)*v121);
  if ((_DWORD)v31)
  {
    Length = 0;
  }
  else
  {
    v33 = glpPrimitiveTypeGetPrimitiveType((uint64_t)v30);
    Category = glpPrimitiveTypeGetCategory(v33);
    if (Category == 3)
    {
      ColumnType = glpPrimitiveMatrixGetColumnType(v33);
      Length = glpPrimitiveVectorGetLength(ColumnType);
      v31 = glpBuildArrayElementPtrCst(v123, (unint64_t)v121, v29, v120);
      v29 = v31;
    }
    else
    {
      if (Category != 2)
        abort();
      v31 = glpPrimitiveVectorGetLength(v33);
      Length = v31;
    }
  }
  LODWORD(v36) = v122;
  if (Length != (_DWORD)v122)
    goto LABEL_59;
  if ((int)v122 < 1)
  {
    v37 = 0;
  }
  else
  {
    v37 = 0;
    v38 = v122 + 1;
    do
    {
      v39 = (v38 - 2);
      v40 = 1 << a5[v39];
      if ((v40 & v37) != 0)
        a4[v39] = 0;
      v37 |= v40;
      --v38;
    }
    while (v38 > 1);
  }
  v41 = ~(-1 << v36);
  if ((_DWORD)VectorElementExpr && v37 == v41)
  {
    v119 = &v116;
    v120 = v29;
    v42 = v36;
    v43 = 8 * v36;
    MEMORY[0x24BDAC7A8](v31);
    v45 = (uint64_t *)((char *)&v116 - v44);
    if (v43 >= 0x200)
      v46 = 512;
    else
      v46 = 8 * v36;
    bzero(v45, v46);
    if ((int)v36 < 1)
    {
      v48 = 0;
    }
    else
    {
      v48 = 0;
      v36 = v36;
      do
      {
        v47 = *a4;
        if (*a4)
        {
          v49 = glpBinaryOperatorNodeGetRhs(v47);
          v45[*a5] = v49;
          v47 = glpASTNodeGetKind(v49);
          if ((_DWORD)v47 == 3)
            ++v48;
        }
        ++a5;
        ++a4;
        --v36;
      }
      while (v36);
    }
    v60 = v122;
    if (v48 == (_DWORD)v122)
    {
      MEMORY[0x24BDAC7A8](v47);
      v62 = (char *)&v116 - ((v61 + 15) & 0xFFFFFFFF0);
      bzero(v62, v46);
      v63 = v123;
      if (v60)
      {
        v64 = v62;
        do
        {
          v65 = *v45++;
          *v64++ = glpLLVMCGNode(v63, v65, 0);
          --v42;
        }
        while (v42);
      }
      inserted = glpLLVMConstVectorCache((uint64_t)v63, (uint64_t *)v62, v122);
      v67 = v120;
    }
    else
    {
      v68 = v123;
      v69 = v124;
      v70 = glpLLVMGetVariablePointer((uint64_t)v123, (unint64_t)v124);
      SourceVariable = glpLoadSourceVariable(v68, v70, (uint64_t)v69);
      v71 = glpLLVMTypeOf((uint64_t)v68, SourceVariable);
      v118 = &v116;
      MEMORY[0x24BDAC7A8](v71);
      v73 = (uint64_t *)((char *)&v116 - ((v72 + 15) & 0xFFFFFFFF0));
      bzero(v73, v46);
      bzero(v73, v43);
      v74 = glpPrimitiveTypeGetPrimitiveType(*v69);
      v75 = glpPrimitiveVectorGetLength(v74);
      v76 = glpLLVMConstFromTypeCache((uint64_t)v68, 37, v71);
      v77 = 0;
      v124 = (uint64_t *)v75;
      v121 = v73;
      if (v48)
      {
        v78 = v122;
        if ((int)v75 >= v48)
        {
          v116 = (uint64_t)&v116;
          MEMORY[0x24BDAC7A8](v76);
          v81 = (uint64_t *)((char *)&v116 - v80);
          if (v79 >= 0x200)
            v82 = 512;
          else
            v82 = v79;
          bzero((char *)&v116 - v80, v82);
          if (v78)
          {
            v83 = 0;
            v84 = v42;
            v85 = v45;
            v86 = v121;
            v87 = v123;
            do
            {
              v88 = *v85;
              if (glpASTNodeGetKind(*v85) == 3)
              {
                v81[v83] = glpLLVMCGNode(v87, v88, 0);
                v89 = (v83 + (_DWORD)v124);
                if (v89 > 7)
                {
                  v91 = glpLLVMConstIntCache((uint64_t)v87, v87[5], (int)v89, 1);
                }
                else
                {
                  v90 = &v87[v89];
                  v91 = v90[65];
                  if (!v91)
                  {
                    v92 = v90 + 65;
                    v91 = glpLLVMConstIntCache((uint64_t)v123, v123[5], v89, 0);
                    *v92 = v91;
                  }
                }
                *v86 = v91;
                ++v83;
              }
              ++v86;
              ++v85;
              --v84;
            }
            while (v84);
          }
          v93 = v123;
          v75 = (uint64_t)v124;
          v94 = (_DWORD)v124 - v48;
          if ((int)v124 > v48)
          {
            v95 = v48;
            do
            {
              v96 = glpLLVMTypeOf((uint64_t)v93, *v81);
              v81[v95++] = glpLLVMConstFromTypeCache((uint64_t)v93, 37, v96);
              --v94;
            }
            while (v94);
          }
          v76 = glpLLVMConstVectorCache((uint64_t)v93, v81, v75);
          v77 = 1;
          v73 = v121;
          v78 = v122;
        }
      }
      else
      {
        v78 = v122;
      }
      v116 = v76;
      if (v78)
      {
        v97 = 0;
        v98 = (2 * v75 - 1);
        v99 = &v123[v98 + 65];
        do
        {
          v100 = v45[v97];
          if (glpASTNodeGetKind(v100) == 81)
          {
            v101 = glpDerefNodeGetOffset(v100);
            v102 = (glpOffsetNodeGetSwizzle(v101) >> 3) & 3;
            v103 = &v123[v102];
            v104 = v103[65];
            if (!v104)
            {
              v105 = v103 + 65;
              v104 = glpLLVMConstIntCache((uint64_t)v123, v123[5], v102, 0);
              *v105 = v104;
              v73 = v121;
            }
            v73[v97] = v104;
            if (v97 != v102)
              v77 = 1;
          }
          else if (!v73[v97])
          {
            if (v98 > 7)
            {
              v106 = glpLLVMConstIntCache((uint64_t)v123, v123[5], (int)v98, 1);
            }
            else
            {
              v106 = *v99;
              if (!*v99)
              {
                v106 = glpLLVMConstIntCache((uint64_t)v123, v123[5], v98, 0);
                *v99 = v106;
              }
            }
            v73[v97] = v106;
            v77 = 1;
          }
          ++v97;
        }
        while (v42 != v97);
      }
      v107 = v122;
      v108 = (int)v124;
      if (v77 || (_DWORD)v124 != (_DWORD)v122)
      {
        v63 = v123;
        v109 = glpLLVMConstVectorCache((uint64_t)v123, v121, v122);
        inserted = glpLLVMBuildShuffleVector((uint64_t)v63, SourceVariable, v116, v109, "swz");
        v67 = v120;
      }
      else
      {
        v63 = v123;
        v67 = v120;
        inserted = SourceVariable;
      }
      if (v48 && v108 < v48 && v107)
      {
        v110 = 0;
        do
        {
          v111 = v45[v110];
          if (glpASTNodeGetKind(v111) == 3)
          {
            v112 = glpLLVMCGNode(v63, v111, 0);
            if (v110 > 7)
            {
              v114 = glpLLVMConstIntCache((uint64_t)v63, v63[5], v110, 1);
            }
            else
            {
              v113 = &v63[v110];
              v114 = v113[65];
              if (!v114)
              {
                v114 = glpLLVMConstIntCache((uint64_t)v63, v63[5], v110, 0);
                v113[65] = v114;
              }
            }
            inserted = glpLLVMBuildInsertElement((uint64_t)v63, inserted, v112, v114, "");
          }
          ++v110;
        }
        while (v42 != v110);
      }
    }
    glpLLVMBuildStore((uint64_t)v63, inserted, v67);
    return 0;
  }
  if (v37 == v41)
  {
    v58 = glpLLVMTypeOf((uint64_t)v28, v29);
    v59 = glpLLVMGetElementType((uint64_t)v28, v58);
    v50 = glpLLVMConstFromTypeCache((uint64_t)v28, 37, v59);
  }
  else
  {
LABEL_59:
    v50 = glpLLVMBuildLoad((uint64_t)v28, v29, "destVector");
  }
  v27 = v50;
  if ((int)v36 >= 1)
  {
    v36 = v36;
    do
    {
      v51 = glpBinaryOperatorNodeGetRhs(*a4);
      v52 = glpLLVMCGNode(v28, v51, 1);
      v54 = *a5++;
      v53 = v54;
      if (v54 > 7)
      {
        v56 = glpLLVMConstIntCache((uint64_t)v28, v28[5], (int)v53, 1);
      }
      else
      {
        v55 = &v28[v53];
        v56 = v55[65];
        if (!v56)
        {
          v57 = v55 + 65;
          v56 = glpLLVMConstIntCache((uint64_t)v28, v28[5], v53, 0);
          *v57 = v56;
        }
      }
      v27 = glpLLVMBuildInsertElement((uint64_t)v28, v27, v52, v56, "res");
      ++a4;
      --v36;
    }
    while (v36);
  }
  glpLLVMBuildStore((uint64_t)v28, v27, v29);
  return v27;
}

uint64_t glpGetVectorSwizzle(uint64_t a1, int *a2)
{
  uint64_t result;
  uint64_t v4;
  unsigned int Swizzle;

  result = glpDerefNodeGetOffset(a1);
  if (result)
  {
    v4 = result;
    if (glpOffsetNodeGetVectorElementExpr(result))
      return 0;
    Swizzle = glpOffsetNodeGetSwizzle(v4);
    if ((Swizzle & 7) != 1)
    {
      return 0;
    }
    else
    {
      *a2 = (Swizzle >> 3) & 3;
      return 1;
    }
  }
  return result;
}

uint64_t glpLLVMCGGlobalVariable(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t *v5;
  int v6;
  _DWORD *v7;
  uint64_t v8;
  int v9;
  int v10;
  unsigned int v11;
  _QWORD *v12;
  char *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  _QWORD *v20;
  char *v21;
  int v22;
  _QWORD *v23;
  int v24;
  int v25;
  unsigned int v26;
  _QWORD *v27;
  char *v28;
  int v29;
  uint64_t result;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;

  if ((*(_WORD *)(a2 + 52) & 0x980) != 0)
    *(_WORD *)(a1 + 326) = 1;
  v4 = *(uint64_t **)(a2 + 8);
  if (!v4)
  {
    v15 = 0;
    v16 = 0;
    goto LABEL_41;
  }
  v5 = glpLayoutObjectFind(v4, 33);
  if (v5)
  {
    v6 = *((_DWORD *)v5 + 4);
    switch(v6)
    {
      case 5:
        v7 = (_DWORD *)(a1 + 692);
        v8 = *(unsigned int *)(a1 + 692);
        v17 = *(_DWORD *)(a1 + 688);
        if ((int)v8 + 1 <= v17)
        {
          v21 = *(char **)(a1 + 696);
          v22 = *(_DWORD *)(a1 + 692);
        }
        else
        {
          if (v17 <= 1)
            v17 = 1;
          v18 = 2 * v17;
          if (v18 <= (int)v8 + 1)
            v19 = v8 + 1;
          else
            v19 = v18;
          v20 = *(_QWORD **)(a1 + 152);
          v21 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))v20[1])(*v20, 8 * v19, "Vector Storage (GLPVariableObject *, growth)");
          memcpy(v21, *(const void **)(a1 + 696), 8 * *(unsigned int *)(a1 + 692));
          ((void (*)(_QWORD, _QWORD))v20[3])(*v20, *(_QWORD *)(a1 + 696));
          *(_DWORD *)(a1 + 688) = v19;
          *(_QWORD *)(a1 + 696) = v21;
          v22 = *(_DWORD *)(a1 + 692);
        }
        v23 = (_QWORD *)(a1 + 696);
        memmove(&v21[8 * v8 + 8], &v21[8 * v8], 8 * (v22 - v8));
        v16 = 0;
        v15 = 1;
        goto LABEL_38;
      case 3:
        if ((~*(unsigned __int16 *)(a1 + 832) & 3) != 0)
        {
          v7 = (_DWORD *)(a1 + 692);
          v8 = *(unsigned int *)(a1 + 692);
          v24 = *(_DWORD *)(a1 + 688);
          if ((int)v8 + 1 <= v24)
          {
            v28 = *(char **)(a1 + 696);
            v29 = *(_DWORD *)(a1 + 692);
          }
          else
          {
            if (v24 <= 1)
              v24 = 1;
            v25 = 2 * v24;
            if (v25 <= (int)v8 + 1)
              v26 = v8 + 1;
            else
              v26 = v25;
            v27 = *(_QWORD **)(a1 + 152);
            v28 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))v27[1])(*v27, 8 * v26, "Vector Storage (GLPVariableObject *, growth)");
            memcpy(v28, *(const void **)(a1 + 696), 8 * *(unsigned int *)(a1 + 692));
            ((void (*)(_QWORD, _QWORD))v27[3])(*v27, *(_QWORD *)(a1 + 696));
            *(_DWORD *)(a1 + 688) = v26;
            *(_QWORD *)(a1 + 696) = v28;
            v29 = *(_DWORD *)(a1 + 692);
          }
          v23 = (_QWORD *)(a1 + 696);
          memmove(&v28[8 * v8 + 8], &v28[8 * v8], 8 * (v29 - v8));
          v15 = 0;
          v16 = 0;
          goto LABEL_38;
        }
        break;
      case 0:
        v7 = (_DWORD *)(a1 + 676);
        v8 = *(unsigned int *)(a1 + 676);
        v9 = *(_DWORD *)(a1 + 672);
        if ((int)v8 + 1 <= v9)
        {
          v13 = *(char **)(a1 + 680);
          v14 = *(_DWORD *)(a1 + 676);
        }
        else
        {
          if (v9 <= 1)
            v9 = 1;
          v10 = 2 * v9;
          if (v10 <= (int)v8 + 1)
            v11 = v8 + 1;
          else
            v11 = v10;
          v12 = *(_QWORD **)(a1 + 152);
          v13 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))v12[1])(*v12, 8 * v11, "Vector Storage (GLPVariableObject *, growth)");
          memcpy(v13, *(const void **)(a1 + 680), 8 * *(unsigned int *)(a1 + 676));
          ((void (*)(_QWORD, _QWORD))v12[3])(*v12, *(_QWORD *)(a1 + 680));
          *(_DWORD *)(a1 + 672) = v11;
          *(_QWORD *)(a1 + 680) = v13;
          v14 = *(_DWORD *)(a1 + 676);
        }
        v23 = (_QWORD *)(a1 + 680);
        memmove(&v13[8 * v8 + 8], &v13[8 * v8], 8 * (v14 - v8));
        v15 = 0;
        v16 = 1;
LABEL_38:
        *(_QWORD *)(*v23 + 8 * v8) = a2;
        ++*v7;
        goto LABEL_39;
    }
  }
  v15 = 0;
  v16 = 0;
LABEL_39:
  result = (uint64_t)glpLayoutObjectFind(*(uint64_t **)(a2 + 8), 46);
  if (!result || (*(_DWORD *)(result + 16) - 9) >= 2)
  {
LABEL_41:
    v31 = glpPrecisionIndexFromSAFlags(*(_QWORD *)(a2 + 48));
    v32 = glpTypeToLLVMType((_QWORD *)a1, *(unsigned int **)a2, v31, (_QWORD *)a2);
    v33 = *(uint64_t **)(a2 + 8);
    if (v33)
      v33 = glpLayoutObjectFind(v33, 83);
    v34 = *(_DWORD *)(a1 + 320);
    switch(v34)
    {
      case 3:
        v36 = 0;
        if (v16 && !v33)
        {
          v36 = 0;
          v37 = *(unsigned int *)(a1 + 792);
          goto LABEL_61;
        }
        break;
      case 2:
        if (!v16)
          goto LABEL_62;
        v36 = 0;
        v38 = *(_DWORD *)(*(_QWORD *)(a1 + 128) + 320);
        if (v38)
          v37 = v38;
        else
          v37 = 32;
        if ((*(_BYTE *)(a2 + 53) & 2) == 0 && !v33)
        {
LABEL_61:
          v32 = glpLLVMArrayType(a1, v32, v37);
          v35 = 4;
LABEL_64:
          result = glpLLVMPointerType(a1, v32, v36);
          v39 = *(_QWORD *)(a2 + 144);
          *(_QWORD *)v39 = result;
          *(_DWORD *)(v39 + 32) = *(_DWORD *)(v39 + 32) & 0xFFFFFFFB | v35;
          return result;
        }
        break;
      case 1:
        v35 = 0;
        if (v15)
          v36 = 3;
        else
          v36 = 0;
        if (!v16 || v33)
          goto LABEL_64;
        v37 = 32;
        goto LABEL_61;
      default:
LABEL_62:
        v36 = 0;
        v35 = 0;
        goto LABEL_64;
    }
    v35 = 0;
    goto LABEL_64;
  }
  return result;
}

uint64_t glpTypeToLLVMType(_QWORD *a1, unsigned int *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t PrimitiveType;
  uint64_t v9;
  uint64_t ElementCount;
  uint64_t v11;
  unsigned int v12;
  int v13;
  _DWORD *ElementType;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  char ElementFlags;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t *v26;
  unint64_t v28;
  uint64_t v29;
  _QWORD v30[2];

  v30[1] = *MEMORY[0x24BDAC8D0];
  if (a4)
    *(_QWORD *)(a4[18] + 24) = 0;
  switch(glpTypeGetKind(a2))
  {
    case 0u:
      PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)a2);
      if (glpPrimitiveTypeGetCategory(PrimitiveType) == 3
        && glpPrimitiveTypeGetScalarType(PrimitiveType) == 62)
      {
        goto LABEL_24;
      }
      v9 = glpPrimitiveTypeToLLVMType(a1, PrimitiveType, a3);
      goto LABEL_25;
    case 1u:
      ElementCount = glpAggregateTypeGetElementCount((uint64_t)a2);
      v11 = ElementCount;
      if ((_DWORD)ElementCount)
      {
        v12 = 0;
        v13 = 1;
        do
        {
          ElementType = (_DWORD *)glpAggregateTypeGetElementType((uint64_t)a2, v12);
          ElementCount = glpTypeIsAtomic(ElementType);
          if ((_DWORD)ElementCount)
          {
            ElementCount = glpPrimitiveTypeGetPrimitiveType((uint64_t)ElementType);
            if ((ElementCount & 0xFFFFFFFE) == 0x40)
              v13 = 0;
          }
          else
          {
            v13 = 0;
          }
          ++v12;
        }
        while ((_DWORD)v11 != v12);
        if (!v13)
          goto LABEL_24;
      }
      MEMORY[0x24BDAC7A8](ElementCount);
      v17 = (_QWORD *)((char *)v30 - v16);
      if (v15 >= 0x200)
        v18 = 512;
      else
        v18 = v15;
      bzero((char *)v30 - v16, v18);
      if ((_DWORD)v11)
      {
        v19 = 0;
        do
        {
          v20 = glpAggregateTypeGetElementType((uint64_t)a2, v19);
          ElementFlags = glpAggregateTypeGetElementFlags((uint64_t)a2, v19);
          v22 = glpPrecisionIndexFromSAFlags(ElementFlags);
          v17[v19++] = glpTypeToLLVMType(a1, v20, v22, a4);
        }
        while (v11 != v19);
      }
      v23 = glpLLVMStructTypeInContext((uint64_t)a1, v17, v11);
      if (!a4)
        goto LABEL_23;
      goto LABEL_26;
    case 2u:
LABEL_24:
      v9 = glpLLVMGetAggregateType(a1, a2, a3, (uint64_t)a4);
LABEL_25:
      v23 = v9;
      if (!a4)
      {
LABEL_23:
        v24 = 0;
        goto LABEL_32;
      }
LABEL_26:
      v25 = (uint64_t *)a4[1];
      if (!v25 || (v26 = glpLayoutObjectFind(v25, 34)) == 0)
      {
        v24 = a4[6];
LABEL_32:
        v28 = v24 & 0xFFFFFFFFFEFFFFFFLL;
        a4[6] = v28;
        if ((v28 & 0x1000000) == 0)
          return v23;
        goto LABEL_33;
      }
      v24 = a4[6];
      if (*((_DWORD *)v26 + 4) != 28)
        goto LABEL_32;
      if ((v24 & 0x1000000) == 0)
        return v23;
LABEL_33:
      *(_DWORD *)(a4[18] + 24) = glpPrimitiveTypeGetPrimitiveType((uint64_t)a2);
      v29 = glpLLVMGetNamedType((uint64_t)a1, "struct._interpolant_t");
      return glpLLVMPointerType((uint64_t)a1, v29, 1);
    default:
      abort();
  }
}

uint64_t glpLLVMGetAggregateType(_QWORD *a1, unsigned int *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7;
  int ElementCount;
  uint64_t ElementType;
  unsigned int v10;
  uint64_t Size;
  unsigned int v12;
  uint64_t v13;
  int VectorType;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v19;
  unsigned int v20;

  v19 = a3;
  v20 = 1;
  v7 = glpLLVMGetMinCommonType(a2, (int *)&v20, &v19);
  if (glpTypeGetKind(a2) == 3)
  {
    ElementCount = glpBankTypeGetElementCount((uint64_t)a2);
    ElementType = glpBankTypeGetElementType((uint64_t)a2);
    v10 = glpABIGetTypeSize(0, ElementType, 0);
    Size = glpTypeSizeGetSize(v10) * ElementCount;
  }
  else
  {
    v12 = glpABIGetTypeSize(0, (uint64_t)a2, 0);
    Size = glpTypeSizeGetSize(v12);
  }
  v13 = v20;
  VectorType = glpGetVectorType(v7, v20);
  v15 = *(_QWORD *)(a4 + 144);
  v16 = v19;
  *(_DWORD *)(v15 + 24) = VectorType;
  *(_DWORD *)(v15 + 28) = v16;
  v17 = glpPrimitiveTypeToLLVMType(a1, v7, v16);
  if (v13 >= 2)
    v17 = glpLLVMVectorType((uint64_t)a1, v17, v13);
  return glpLLVMArrayType((uint64_t)a1, v17, Size);
}

uint64_t glpLLVMBuildFunctionType(uint64_t a1, uint64_t a2, int a3, int a4, int a5, char a6)
{
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  __int16 v13;
  _BOOL4 v15;
  BOOL v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  size_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t i;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  size_t v46;
  char *v47;
  size_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t PrimitiveType;
  uint64_t ScalarType;
  uint64_t v55;
  uint64_t *v56;
  uint64_t *v57;
  _BOOL4 v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t *v62;
  int v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t *v67;
  uint64_t *v68;
  uint64_t v69;
  int v70;
  int v71;
  int v72;
  uint64_t v73;
  char *v74;
  int v75;
  uint64_t result;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t *v80;
  int v81;
  int v82;
  uint64_t v83;
  int v84;
  int v85;
  int v86;
  uint64_t *v87;
  uint64_t v88;

  v88 = *MEMORY[0x24BDAC8D0];
  if ((a6 & 2) != 0)
  {
    v9 = *(_DWORD *)(a1 + 708);
    if ((a6 & 4) != 0)
      goto LABEL_3;
  }
  else
  {
    v9 = 0;
    if ((a6 & 4) != 0)
    {
LABEL_3:
      v10 = *(_DWORD *)(a1 + 724);
      goto LABEL_6;
    }
  }
  v10 = 0;
LABEL_6:
  v11 = *(_QWORD *)(a1 + 88);
  v12 = a5 + a4;
  v13 = *(_WORD *)(a1 + 832);
  v15 = (v13 & 2) == 0 || v10 < 1;
  v16 = (v13 & 1) == 0;
  v17 = (v13 & 1) == 0 || v15;
  v85 = v17;
  v18 = !v16 && !v15;
  if ((a6 & 8) != 0)
    v19 = *(_DWORD *)(a1 + 596);
  else
    v19 = 0;
  v84 = a6 & 1;
  v86 = v19;
  v81 = v84 + v12 + v9 + v10 + v18;
  v20 = (v81 + 2 * v19);
  MEMORY[0x24BDAC7A8](a1);
  v23 = (uint64_t *)((char *)&v77 - v22);
  if (v21 >= 0x200)
    v24 = 512;
  else
    v24 = v21;
  bzero((char *)&v77 - v22, v24);
  v87 = v23;
  if (a3)
  {
    v82 = v12;
    v83 = v20;
    v79 = v11;
    v26 = *(unsigned int *)(a1 + 676);
    if ((int)v26 >= 1)
    {
      v27 = 0;
      v28 = 0;
      v29 = 8 * v26;
      while (1)
      {
        v30 = *(_QWORD *)(*(_QWORD *)(a1 + 680) + v27);
        v31 = glpLayoutObjectFind(*(uint64_t **)(v30 + 8), 34);
        v25 = glpPrecisionIndexFromSAFlags(*(_QWORD *)(v30 + 48));
        v32 = *(_DWORD *)(a1 + 320);
        if ((v32 - 1) >= 3)
        {
          if (v32 == 4)
          {
            if (*((_DWORD *)v31 + 4) == 24)
              goto LABEL_33;
LABEL_41:
            v25 = glpTypeToLLVMType((_QWORD *)a1, *(unsigned int **)v30, v25, (_QWORD *)v30);
            v23[v28] = v25;
            goto LABEL_32;
          }
          if (v32)
            goto LABEL_33;
          v35 = *((_DWORD *)v31 + 4);
          if ((v35 - 17) < 2)
          {
            if ((*(_WORD *)(a1 + 832) & 1) == 0)
              goto LABEL_33;
            goto LABEL_41;
          }
          if (v35 != 28)
            goto LABEL_33;
          v25 = glpTypeToLLVMType((_QWORD *)a1, *(unsigned int **)v30, v25, (_QWORD *)v30);
          v34 = v25;
          if ((*(_WORD *)(a1 + 832) & 1) == 0)
          {
            v25 = glpLLVMPointerType(a1, v25, 1);
            goto LABEL_30;
          }
        }
        else
        {
          v33 = *(_QWORD *)(v30 + 144);
          v34 = *(_QWORD *)v33;
          if ((*(_BYTE *)(v33 + 32) & 4) == 0)
          {
            v25 = glpLLVMGetElementType(a1, v34);
LABEL_30:
            v34 = v25;
          }
        }
        v23[v28] = v34;
LABEL_32:
        ++v28;
LABEL_33:
        v27 += 8;
        if (v29 == v27)
          goto LABEL_55;
      }
    }
    v28 = 0;
LABEL_55:
    if (*(_DWORD *)(a1 + 804))
      v23[v28++] = *(_QWORD *)(a1 + 40);
    if (*(_DWORD *)(a1 + 812))
      v23[v28++] = *(_QWORD *)(a1 + 40);
    if (*(_DWORD *)(a1 + 820))
      v23[v28++] = *(_QWORD *)(a1 + 40);
    v80 = &v77;
    v45 = *(unsigned int *)(a1 + 692);
    v46 = 8 * v45;
    MEMORY[0x24BDAC7A8](v25);
    v47 = (char *)&v77 - ((8 * v45 + 15) & 0xFFFFFFFF0);
    if ((unint64_t)(8 * v45) >= 0x200)
      v48 = 512;
    else
      v48 = 8 * v45;
    bzero((char *)&v77 - ((v46 + 15) & 0xFFFFFFFF0), v48);
    v78 = v45;
    if ((int)v45 >= 1)
    {
      v49 = 0;
      do
      {
        v50 = *(_QWORD *)(*(_QWORD *)(a1 + 696) + v49);
        v51 = glpPrecisionIndexFromSAFlags(*(_QWORD *)(v50 + 48));
        switch(*(_DWORD *)(a1 + 320))
        {
          case 0:
          case 2:
            if ((*(_WORD *)(a1 + 832) & 1) == 0)
              goto LABEL_82;
            v56 = glpLayoutObjectFind(*(uint64_t **)(v50 + 8), 69);
            v57 = glpLayoutObjectFind(*(uint64_t **)(v50 + 8), 70);
            if (v57)
            {
              v58 = *((_DWORD *)v57 + 4) == 0;
              if (!v56)
                goto LABEL_82;
            }
            else
            {
              v58 = 1;
              if (!v56)
                goto LABEL_82;
            }
            if (*((_DWORD *)v56 + 4) != 5)
              v58 = 0;
            if (!v58)
              goto LABEL_82;
            v52 = glpPrimitiveTypeToLLVMType((_QWORD *)a1, 4, v51);
            goto LABEL_83;
          case 1:
          case 3:
            v52 = **(_QWORD **)(v50 + 144);
            goto LABEL_83;
          case 4:
            if (*((_DWORD *)glpLayoutObjectFind(*(uint64_t **)(v50 + 8), 68) + 4) != 4
              || (PrimitiveType = glpPrimitiveTypeGetPrimitiveType(*(_QWORD *)v50),
                  glpPrimitiveTypeGetCategory(PrimitiveType) == 2)
              && (int)glpPrimitiveVectorGetLength(PrimitiveType) > 3)
            {
LABEL_82:
              v52 = glpTypeToLLVMType((_QWORD *)a1, *(unsigned int **)v50, v51, (_QWORD *)v50);
            }
            else
            {
              ScalarType = glpPrimitiveTypeGetScalarType(PrimitiveType);
              v55 = glpPrimitiveTypeToLLVMType((_QWORD *)a1, ScalarType, v51);
              v52 = glpLLVMVectorType(a1, v55, 4);
            }
LABEL_83:
            *(_QWORD *)&v47[v49] = v52;
            break;
          default:
            break;
        }
        v49 += 8;
      }
      while (v46 != v49);
    }
    if ((*(_DWORD *)(a1 + 320) | 2) == 3)
    {
      v23 = v87;
      memcpy(&v87[v28], (char *)&v77 - ((v46 + 15) & 0xFFFFFFFF0), v46);
      v59 = 0;
      v11 = v79;
      v20 = v83;
    }
    else
    {
      v20 = v83;
      v23 = v87;
      if ((_DWORD)v78)
      {
        v59 = glpLLVMStructTypeInContext(a1, (uint64_t *)((char *)&v77 - ((v46 + 15) & 0xFFFFFFFF0)), v78);
        v11 = v59;
      }
      else
      {
        v59 = 0;
        v11 = v79;
      }
    }
    v12 = v82;
    *(_QWORD *)(a1 + 200) = v59;
  }
  else
  {
    v36 = *(unsigned int *)(a2 + 32);
    if ((_DWORD)v36)
    {
      v82 = v12;
      v83 = v20;
      v37 = v11;
      v38 = 0;
      for (i = 0; i < v36; ++i)
      {
        v40 = *(_QWORD *)(a2 + 40);
        v41 = *(_QWORD *)(v40 + v38);
        if (v41)
        {
          v42 = *(_QWORD *)(v40 + v38 + 8);
          v43 = *(uint64_t **)(v42 + 144);
          if (!v43)
          {
            glpLLVMAllocVariableExtra(*(_QWORD *)(a1 + 152), v42);
            glpLLVMCGGlobalVariable(a1, v42);
            v43 = *(uint64_t **)(v42 + 144);
            v36 = *(unsigned int *)(a2 + 32);
          }
          v44 = ((v41 << 32) - 0x100000000) >> 29;
          v23 = v87;
          *(uint64_t *)((char *)v87 + v44) = *v43;
        }
        else
        {
          v23 = v87;
        }
        v38 += 24;
      }
      v11 = v37;
      v20 = v83;
      v12 = v82;
    }
  }
  v60 = glpLLVMVectorType(a1, *(_QWORD *)(a1 + 72), 4);
  if (v84)
    v23[v12++] = glpLLVMPointerType(a1, v60, 2);
  if (v9 >= 1)
  {
    v61 = v12;
    v62 = &v23[v12];
    v63 = v9 + v61;
    do
    {
      *v62++ = glpLLVMPointerType(a1, v60, 2);
      --v9;
    }
    while (v9);
    v12 = v63;
  }
  if (v10 >= 1)
  {
    v64 = &v23[v12];
    v12 += v10;
    do
    {
      *v64++ = glpLLVMPointerType(a1, v60, 1);
      --v10;
    }
    while (v10);
  }
  if ((v85 & 1) == 0)
    v23[v12] = glpLLVMPointerType(a1, *(_QWORD *)(a1 + 40), 1);
  if (v86 >= 1)
  {
    v65 = v86;
    v66 = &v23[v86 + v81];
    v67 = &v23[v81];
    v68 = (uint64_t *)(*(_QWORD *)(a1 + 600) + 24);
    do
    {
      *v67++ = *v68;
      *v66++ = *(v68 - 1);
      v68 += 6;
      --v65;
    }
    while (v65);
  }
  v69 = *(unsigned int *)(a1 + 260);
  v70 = v69 + 1;
  v71 = *(_DWORD *)(a1 + 256);
  if ((int)v69 + 1 <= v71)
  {
    v74 = *(char **)(a1 + 264);
    v75 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v71 <= 1)
      v71 = 1;
    v72 = 2 * v71;
    if (v72 <= v70)
      v73 = v70;
    else
      v73 = v72;
    v74 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v73, "Vector Storage (uint8_t, growth)");
    memcpy(v74, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v73;
    *(_QWORD *)(a1 + 264) = v74;
    v75 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v74[v69 + 1], &v74[v69], (v75 - v69));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v69) = 11;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  glpSerializeLLVMType(a1, v11);
  glpSerializeArrayOfLLVMTypes(a1, v23, v20);
  result = *(int *)(a1 + 304);
  *(_DWORD *)(a1 + 304) = result + 1;
  return result;
}

uint64_t glpMetalGetArgTypeNameFromASTType(char *a1, unsigned int *a2, int a3, int a4)
{
  uint64_t result;
  uint64_t PrimitiveType;
  int ElementType;
  int ColumnType;

  result = glpTypeGetKind(a2);
  if (!(_DWORD)result)
  {
    PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)a2);
    result = glpPrimitiveTypeGetCategory(PrimitiveType);
    switch((int)result)
    {
      case 0:
        result = snprintf_l(a1, 0x200uLL, 0, "void");
        break;
      case 1:
        glpScalarTypeGetMetalArgType(PrimitiveType, a3, a4);
        result = snprintf_l(a1, 0x200uLL, 0, "%s");
        break;
      case 2:
        glpPrimitiveVectorGetLength(PrimitiveType);
        ElementType = glpPrimitiveVectorGetElementType(PrimitiveType);
        glpScalarTypeGetMetalArgType(ElementType, a3, 0);
        result = snprintf_l(a1, 0x200uLL, 0, "%s%u");
        break;
      case 3:
        ColumnType = glpPrimitiveMatrixGetColumnType(PrimitiveType);
        glpPrimitiveMatrixGetColumns(PrimitiveType);
        glpPrimitiveMatrixGetRows(PrimitiveType);
        glpScalarTypeGetMetalArgType(ColumnType, a3, 0);
        result = snprintf_l(a1, 0x200uLL, 0, "%s%ux%u");
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t glpLLVMVertexGeometryMetadata(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v22;
  uint64_t v23;
  const char *v24;
  const char *v25;
  const char *v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  unsigned int v31;
  uint64_t *v32;
  _BOOL4 v33;
  uint64_t v34;
  unsigned int *ElementType;
  unsigned int Vec4s_0;
  char __str[16];
  __int128 v38;
  _OWORD v39[4];
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v6 = glpLayoutObjectFind(*(uint64_t **)(a2 + 8), 68);
  memset(v39, 0, sizeof(v39));
  if ((*(_DWORD *)(a1 + 320) | 2) == 3)
  {
    if (a3 > 7)
    {
      v8 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), (int)a3, 1);
    }
    else
    {
      v7 = a1 + 8 * a3;
      v8 = *(_QWORD *)(v7 + 520);
      if (!v8)
      {
        v9 = a3;
        v10 = (uint64_t *)(v7 + 520);
        v8 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), v9, 0);
        *v10 = v8;
      }
    }
    *(_QWORD *)&v39[0] = v8;
    *((_QWORD *)&v39[0] + 1) = glpLLVMStringMetadata(a1, "air.geometry_output");
    v11 = 2;
  }
  else
  {
    v11 = 0;
  }
  switch(*((_DWORD *)v6 + 4))
  {
    case 1:
      v12 = "air.position";
      goto LABEL_25;
    case 3:
      v12 = "air.point_size";
      goto LABEL_25;
    case 4:
      v13 = *((_DWORD *)glpLayoutObjectFind(*(uint64_t **)(a2 + 8), 71) + 4);
      v14 = "air.back_color";
      v15 = "air.front_color";
      goto LABEL_13;
    case 5:
      v13 = *((_DWORD *)glpLayoutObjectFind(*(uint64_t **)(a2 + 8), 74) + 4);
      v14 = "air.back_secondary_color";
      v15 = "air.front_secondary_color";
LABEL_13:
      if (v13)
        v12 = v14;
      else
        v12 = v15;
      goto LABEL_25;
    case 9:
      *(_QWORD *)(a1 + 744) |= 4uLL;
      v12 = "air.clip_vertex";
      goto LABEL_25;
    case 0xA:
      v16 = glpLayoutObjectFind(*(uint64_t **)(a2 + 8), 75);
      *((_QWORD *)v39 + v11) = glpLLVMStringMetadata(a1, "air.clip_distance");
      v17 = *((unsigned int *)v16 + 4);
      if (v17 > 7)
      {
        v19 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), (int)v17, 1);
      }
      else
      {
        v18 = a1 + 8 * v17;
        v19 = *(_QWORD *)(v18 + 520);
        if (!v19)
        {
          v20 = (uint64_t *)(v18 + 520);
          v19 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), v17, 0);
          *v20 = v19;
        }
      }
      *((_QWORD *)v39 + (v11 | 1)) = v19;
      goto LABEL_66;
    case 0xB:
      v12 = "air.primitive_id";
      goto LABEL_25;
    case 0xC:
      v12 = "air.render_target_array_index";
      goto LABEL_25;
    case 0xD:
      v12 = "air.edge_tessellation_factor";
      goto LABEL_25;
    case 0xE:
      v12 = "air.inside_tessellation_factor";
      goto LABEL_25;
    case 0x10:
      v12 = "air.viewport_array_index";
LABEL_25:
      *((_QWORD *)v39 + v11) = glpLLVMStringMetadata(a1, v12);
      v11 = v11 | 1;
      break;
    case 0x11:
      v22 = glpLayoutObjectFind(*(uint64_t **)(a2 + 8), 69);
      v23 = *(_QWORD *)(a2 + 48);
      v24 = "air.no_perspective";
      if ((v23 & 0x2000000000) == 0)
        v24 = "air.perspective";
      if ((v23 & 0x1000000000) != 0)
        v25 = "air.flat";
      else
        v25 = v24;
      v26 = "air.center";
      if ((v23 & 0x1000000000) == 0)
      {
        if ((v23 & 0x4000000000) != 0)
        {
          v26 = "air.centroid";
        }
        else if ((v23 & 0x40000000000) != 0)
        {
          v26 = "air.sample";
        }
      }
      if ((*(_DWORD *)(a1 + 320) | 2) == 2)
      {
        *((_QWORD *)v39 + v11) = glpLLVMStringMetadata(a1, "air.vertex_output");
        LODWORD(v11) = v11 | 1;
      }
      if ((*(_WORD *)(a1 + 832) & 1) != 0)
      {
        *(_OWORD *)__str = 0u;
        v38 = 0u;
        v31 = *((_DWORD *)v22 + 4);
        v32 = glpLayoutObjectFind(*(uint64_t **)(a2 + 8), 70);
        if (v32)
          v33 = *((_DWORD *)v32 + 4) == 0;
        else
          v33 = 1;
        if (v33 && v31 >= 8 && v31 <= 0xF)
        {
          snprintf(__str, 0x1FuLL, "user(tex_coord%u)");
        }
        else if ((*(_BYTE *)(a2 + 53) & 2) != 0)
        {
          snprintf(__str, 0x1FuLL, "user(patch%u)");
        }
        else
        {
          snprintf(__str, 0x1FuLL, "user(slot%u)");
        }
        v34 = (v11 + 1);
        *((_QWORD *)v39 + v11) = glpLLVMStringMetadata(a1, __str);
        if (*(_DWORD *)(a1 + 320) == 1)
        {
          ElementType = *(unsigned int **)a2;
          if (glpTypeGetKind(ElementType) == 3)
            ElementType = (unsigned int *)glpBankTypeGetElementType((uint64_t)ElementType);
          *((_QWORD *)v39 + v34) = glpLLVMStringMetadata(a1, "air.vec4_size");
          Vec4s_0 = glpTypeGetVec4s_0((uint64_t)ElementType);
          *((_QWORD *)v39 + (v11 + 2)) = glpGetConstantInt32(a1, Vec4s_0);
          v34 = (v11 + 3);
        }
        v11 = v34;
      }
      else
      {
        *((_QWORD *)v39 + v11) = glpLLVMStringMetadata(a1, "air.location");
        v27 = *((unsigned int *)v22 + 4);
        if (v27 > 7)
        {
          v29 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), (int)v27, 1);
        }
        else
        {
          v28 = a1 + 8 * v27;
          v29 = *(_QWORD *)(v28 + 520);
          if (!v29)
          {
            v30 = (uint64_t *)(v28 + 520);
            v29 = glpLLVMConstIntCache(a1, *(_QWORD *)(a1 + 40), v27, 0);
            *v30 = v29;
          }
        }
        *((_QWORD *)v39 + (v11 + 1)) = v29;
        v11 = (v11 + 2);
      }
      if ((*(_DWORD *)(a1 + 320) | 2) != 2 || (*(_WORD *)(a1 + 832) & 1) == 0)
      {
        *((_QWORD *)v39 + v11) = glpLLVMStringMetadata(a1, v25);
        *((_QWORD *)v39 + (v11 + 1)) = glpLLVMStringMetadata(a1, v26);
LABEL_66:
        v11 = (v11 + 2);
      }
      break;
    default:
      return glpLLVMMDNodeInContext(a1, (uint64_t *)v39, v11);
  }
  return glpLLVMMDNodeInContext(a1, (uint64_t *)v39, v11);
}

const char *glpScalarTypeGetMetalArgType(int a1, int a2, int a3)
{
  BOOL v3;
  int v4;
  unsigned int v6;
  const char *v7;
  const char *v8;

  if (a3)
    v3 = a1 == 5;
  else
    v3 = 0;
  if (v3)
    v4 = 36;
  else
    v4 = a1;
  if (v4 <= 8)
  {
    if (v4 == 1)
    {
      v6 = a2 - 1;
      v7 = "float";
      v8 = "half";
    }
    else
    {
      if (v4 != 5)
        goto LABEL_21;
      v6 = a2 - 1;
      v7 = "int";
      v8 = "short";
    }
  }
  else
  {
    if (v4 == 9)
      return "BOOL";
    if (v4 != 36)
    {
      if (v4 == 62)
        return "double";
LABEL_21:
      abort();
    }
    v6 = a2 - 1;
    v7 = "uint";
    v8 = "ushort";
  }
  if (v6 >= 2)
    return v7;
  else
    return v8;
}

uint64_t glpLLVMCGDeclareVariable(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t result;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if ((*(_WORD *)(a2 + 52) & 0x980) != 0)
    *(_WORD *)(a1 + 326) = 1;
  v4 = *(uint64_t **)(a2 + 144);
  if (!v4 || (result = *v4) == 0)
  {
    glpLLVMAllocVariableExtra(*(_QWORD *)(a1 + 152), a2);
    v6 = *(uint64_t **)(a2 + 8);
    if ((!v6 || !glpLayoutObjectFind(v6, 28)) && *(_DWORD *)(a2 + 128))
    {
      v7 = *(_QWORD *)(a2 + 48);
      if ((v7 & 0x80000000) == 0)
      {
        v8 = glpPrecisionIndexFromSAFlags(v7);
        v9 = glpTypeToLLVMType((_QWORD *)a1, *(unsigned int **)a2, v8, (_QWORD *)a2);
        result = glpBuildAlloca(a1, v9);
        **(_QWORD **)(a2 + 144) = result;
        return result;
      }
      if ((v7 & 0x100000000) != 0)
      {
        result = 0;
        **(_QWORD **)(a2 + 144) = 0;
        return result;
      }
      glpLLVMCGGlobalVariable(a1, a2);
    }
    return 0;
  }
  return result;
}

void *glpLLVMClearCurrentLine(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  char *v7;
  int v8;
  void *result;

  v2 = *(unsigned int *)(a1 + 260);
  v3 = v2 + 1;
  v4 = *(_DWORD *)(a1 + 256);
  if ((int)v2 + 1 <= v4)
  {
    v7 = *(char **)(a1 + 264);
    v8 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v4 <= 1)
      v4 = 1;
    v5 = 2 * v4;
    if (v5 <= v3)
      v6 = v3;
    else
      v6 = v5;
    v7 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v6, "Vector Storage (uint8_t, growth)");
    memcpy(v7, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v6;
    *(_QWORD *)(a1 + 264) = v7;
    v8 = *(_DWORD *)(a1 + 260);
  }
  result = memmove(&v7[v2 + 1], &v7[v2], (v8 - v2));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v2) = 105;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  return result;
}

uint64_t glpIsSimpleComponentAssigment(uint64_t a1, unsigned int ***a2, uint64_t **a3, int *a4, int *a5)
{
  unsigned int **v9;
  uint64_t result;
  uint64_t Rhs;
  unsigned int **VariableExtra;
  uint64_t *v13;
  unsigned int PrimitiveType;
  uint64_t v15;
  unsigned int **v16;

  v9 = *a2;
  v15 = 0;
  v16 = v9;
  result = glpIsComponentAssigment(a1, &v16, (_DWORD *)&v15 + 1, &v15, a4, 1);
  if ((_DWORD)result)
  {
    Rhs = glpBinaryOperatorNodeGetRhs(a1);
    if (glpASTNodeGetKind(Rhs) == 81)
    {
      VariableExtra = (unsigned int **)glpLValueNodeGetVariableExtra(Rhs);
      v13 = (uint64_t *)VariableExtra;
      if (*a3)
      {
        if (*a3 == (uint64_t *)VariableExtra)
        {
LABEL_8:
          result = glpGetVectorSwizzle(Rhs, a5);
          if ((_DWORD)result)
          {
            *a2 = v16;
            *a3 = v13;
            return 1;
          }
          return result;
        }
      }
      else if (!glpTypeGetKind(*VariableExtra))
      {
        PrimitiveType = glpPrimitiveTypeGetPrimitiveType(*v13);
        if (glpPrimitiveTypeGetCategory(PrimitiveType) == 2)
          goto LABEL_8;
      }
    }
    return 0;
  }
  return result;
}

void *glpLLVMBuildBr(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  char *v9;
  int v10;

  v4 = *(unsigned int *)(a1 + 260);
  v5 = v4 + 1;
  v6 = *(_DWORD *)(a1 + 256);
  if ((int)v4 + 1 <= v6)
  {
    v9 = *(char **)(a1 + 264);
    v10 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v6 <= 1)
      v6 = 1;
    v7 = 2 * v6;
    if (v7 <= v5)
      v8 = v5;
    else
      v8 = v7;
    v9 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v8, "Vector Storage (uint8_t, growth)");
    memcpy(v9, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v8;
    *(_QWORD *)(a1 + 264) = v9;
    v10 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v9[v4 + 1], &v9[v4], (v10 - v4));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v4) = 97;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  return glpSerializeLLVMBlock(a1, a2);
}

uint64_t glpLLVMSharedRawCall(uint64_t a1, char a2, uint64_t a3, unint64_t *a4, int a5)
{
  int v5;
  int v9;
  int v10;
  int v11;
  __int16 v12;
  _BOOL4 v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  size_t v21;
  uint64_t v22;
  uint64_t *v23;
  unint64_t v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  uint64_t v42;
  char *v43;
  int v44;
  uint64_t result;
  uint64_t v46;
  uint64_t v47;
  int v48;
  uint64_t v49;

  v5 = a5;
  v49 = *MEMORY[0x24BDAC8D0];
  if ((a2 & 2) != 0)
  {
    v9 = *(_DWORD *)(a1 + 708);
    if ((a2 & 4) != 0)
      goto LABEL_3;
  }
  else
  {
    v9 = 0;
    if ((a2 & 4) != 0)
    {
LABEL_3:
      v10 = *(_DWORD *)(a1 + 724);
      goto LABEL_6;
    }
  }
  v10 = 0;
LABEL_6:
  v11 = a2 & 1;
  v12 = *(_WORD *)(a1 + 832);
  v14 = (v12 & 2) == 0 || v10 < 1;
  v15 = (v12 & 1) == 0 || v14;
  v48 = v15;
  if ((a2 & 8) != 0)
    v16 = *(unsigned int *)(a1 + 596);
  else
    v16 = 0;
  v17 = (v11 + a5 + v9 + v10 + 2 * v16);
  MEMORY[0x24BDAC7A8](a1);
  v20 = (uint64_t *)((char *)&v46 - v19);
  if (v18 >= 0x200)
    v21 = 512;
  else
    v21 = v18;
  bzero((char *)&v46 - v19, v21);
  if (v5 < 1)
  {
    v5 = 0;
    if (v11)
LABEL_25:
      v20[v5++] = *(_QWORD *)(a1 + 440);
  }
  else
  {
    v46 = v16;
    v47 = v17;
    v16 = a3;
    v22 = v5;
    v23 = v20;
    do
    {
      v24 = *a4++;
      *v23++ = glpLLVMGetVariablePointer(a1, v24);
      --v22;
    }
    while (v22);
    a3 = v16;
    LODWORD(v16) = v46;
    v17 = v47;
    if (v11)
      goto LABEL_25;
  }
  if (v9 >= 1)
  {
    v25 = *(uint64_t **)(a1 + 712);
    v26 = &v20[v5];
    v5 += v9;
    v27 = v9;
    do
    {
      v28 = *v25++;
      *v26++ = *(_QWORD *)(v28 + 8);
      --v27;
    }
    while (v27);
  }
  if (v10 >= 1)
  {
    v29 = *(uint64_t **)(a1 + 728);
    v30 = &v20[v5];
    v5 += v10;
    v31 = v10;
    do
    {
      v32 = *v29++;
      *v30++ = *(_QWORD *)(v32 + 16);
      --v31;
    }
    while (v31);
  }
  if ((v48 & 1) == 0)
    v20[v5++] = *(_QWORD *)(a1 + 448);
  if ((int)v16 >= 1)
  {
    v33 = 0;
    v34 = &v20[v5];
    v35 = (uint64_t *)(*(_QWORD *)(a1 + 600) + 8);
    do
    {
      v34[v33] = *(v35 - 1);
      v36 = *v35;
      v35 += 6;
      v34[v16 + v33++] = v36;
    }
    while (v16 != v33);
  }
  v37 = *(_QWORD *)(a1 + 160);
  v38 = *(unsigned int *)(a1 + 260);
  v39 = v38 + 1;
  v40 = *(_DWORD *)(a1 + 256);
  if ((int)v38 + 1 <= v40)
  {
    v43 = *(char **)(a1 + 264);
    v44 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v40 <= 1)
      v40 = 1;
    v41 = 2 * v40;
    if (v41 <= v39)
      v42 = v39;
    else
      v42 = v41;
    v43 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v42, "Vector Storage (uint8_t, growth)");
    memcpy(v43, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v42;
    *(_QWORD *)(a1 + 264) = v43;
    v44 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v43[v38 + 1], &v43[v38], (v44 - v38));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v38) = 43;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  glpSerializeLLVMValue(a1, v37);
  glpSerializeLLVMValue(a1, a3);
  glpSerializeArrayOfLLVMValues(a1, v20, v17);
  result = *(int *)(a1 + 308);
  *(_DWORD *)(a1 + 308) = result + 1;
  return result;
}

uint64_t glpLLVMReadUniform(_QWORD *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  int ScalarType;
  uint64_t v11;
  uint64_t Length;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;

  ScalarType = glpPrimitiveTypeGetScalarType(a4);
  if (ScalarType == 9)
  {
    v11 = a1[5];
    if (glpPrimitiveTypeGetCategory(a4) != 2)
      goto LABEL_11;
    Length = glpPrimitiveVectorGetLength(a4);
    v13 = glpLLVMVectorType((uint64_t)a1, v11, Length);
LABEL_10:
    v11 = v13;
LABEL_11:
    v17 = glpLLVMPointerType((uint64_t)a1, v11, 2);
    v18 = glpLLVMCastOperation((uint64_t)a1, 86, a2, v17, "ptr");
    v19 = glpLLVMBuildLoad((uint64_t)a1, v18, "uniform");
    v20 = glpPrimitiveTypeToLLVMType(a1, a4, a5);
    if (ScalarType == 9)
    {
      v21 = glpLLVMConstFromTypeCache((uint64_t)a1, 35, v11);
      return glpLLVMBuildICmp((uint64_t)a1, 1, v19, v21, "uniform");
    }
    else
    {
      if (ScalarType == 1)
        v22 = 88;
      else
        v22 = 87;
      return glpLLVMCastOperation((uint64_t)a1, v22, v19, v20, "uniform");
    }
  }
  if ((_DWORD)a5 != 3 && (_DWORD)a5)
  {
    v13 = glpPrimitiveTypeToLLVMType(a1, a4, 3);
    goto LABEL_10;
  }
  if (a3 != (_DWORD)a4)
  {
    v14 = glpPrimitiveTypeToLLVMType(a1, a4, a5);
    v15 = glpLLVMPointerType((uint64_t)a1, v14, 2);
    a2 = glpLLVMCastOperation((uint64_t)a1, 86, a2, v15, "ptr");
  }
  return glpLLVMBuildLoad((uint64_t)a1, a2, "uniform");
}

uint64_t glpLLVMAddGlobalInAddressSpace(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  char *v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  char *v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  char *v24;
  int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  int v30;
  uint64_t v31;
  char *v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  int v36;
  uint64_t v37;
  char *v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  int v42;
  uint64_t v43;
  char *v44;
  unsigned int v45;
  unsigned int v46;
  int v47;
  int v48;
  uint64_t v49;
  char *v50;
  unsigned int v51;
  int v52;
  uint64_t v53;
  uint64_t result;

  v4 = *(unsigned int *)(a1 + 260);
  v5 = v4 + 1;
  v6 = *(_DWORD *)(a1 + 256);
  if ((int)v4 + 1 <= v6)
  {
    v9 = *(char **)(a1 + 264);
    v10 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v6 <= 1)
      v6 = 1;
    v7 = 2 * v6;
    if (v7 <= v5)
      v8 = v5;
    else
      v8 = v7;
    v9 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v8, "Vector Storage (uint8_t, growth)");
    memcpy(v9, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v8;
    *(_QWORD *)(a1 + 264) = v9;
    v10 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v9[v4 + 1], &v9[v4], (v10 - v4));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v4) = 110;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  glpSerializeLLVMType(a1, a2);
  if (*(_DWORD *)(a1 + 300))
  {
    v11 = *(unsigned int *)(a1 + 260);
    v12 = v11 + 1;
    v13 = *(_DWORD *)(a1 + 256);
    if ((int)v11 + 1 <= v13)
    {
      v16 = *(char **)(a1 + 264);
      v17 = *(_DWORD *)(a1 + 260);
    }
    else
    {
      if (v13 <= 1)
        v13 = 1;
      v14 = 2 * v13;
      if (v14 <= v12)
        v15 = v12;
      else
        v15 = v14;
      v16 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v15, "Vector Storage (uint8_t, growth)");
      memcpy(v16, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
      (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
      *(_DWORD *)(a1 + 256) = v15;
      *(_QWORD *)(a1 + 264) = v16;
      v17 = *(_DWORD *)(a1 + 260);
    }
    memmove(&v16[v11 + 1], &v16[v11], (v17 - v11));
    *(_BYTE *)(*(_QWORD *)(a1 + 264) + v11) = 0;
    ++*(_DWORD *)(a1 + 260);
  }
  v18 = (char)glp_serialized_integer32_control(2);
  v19 = *(unsigned int *)(a1 + 260);
  v20 = v19 + 1;
  v21 = *(_DWORD *)(a1 + 256);
  if ((int)v19 + 1 <= v21)
  {
    v24 = *(char **)(a1 + 264);
    v25 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v21 <= 1)
      v21 = 1;
    v22 = 2 * v21;
    if (v22 <= v20)
      v23 = v20;
    else
      v23 = v22;
    v24 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v23, "Vector Storage (uint8_t, growth)");
    memcpy(v24, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v23;
    *(_QWORD *)(a1 + 264) = v24;
    v25 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v24[v19 + 1], &v24[v19], (v25 - v19));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v19) = v18;
  v26 = *(_DWORD *)(a1 + 260);
  v27 = v26 + 1;
  *(_DWORD *)(a1 + 260) = v26 + 1;
  if ((v18 & 0x80000000) != 0)
  {
    switch((v18 >> 1) & 7)
    {
      case 0u:
        v28 = v26 + 2;
        v29 = *(_DWORD *)(a1 + 256);
        if (v28 <= v29)
        {
          v32 = *(char **)(a1 + 264);
          v33 = v27;
        }
        else
        {
          if (v29 <= 1)
            v29 = 1;
          v30 = 2 * v29;
          if (v30 <= (int)v28)
            v31 = v28;
          else
            v31 = v30;
          v32 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v31, "Vector Storage (uint8_t, growth)");
          memcpy(v32, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v31;
          *(_QWORD *)(a1 + 264) = v32;
          v33 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v32[v27 + 1], &v32[v27], v33 - v27);
        *(_BYTE *)(*(_QWORD *)(a1 + 264) + v27) = 2;
        v52 = 1;
        goto LABEL_65;
      case 1u:
        v46 = v26 + 3;
        v47 = *(_DWORD *)(a1 + 256);
        if (v46 <= v47)
        {
          v50 = *(char **)(a1 + 264);
          v51 = v27;
        }
        else
        {
          if (v47 <= 1)
            v47 = 1;
          v48 = 2 * v47;
          if (v48 <= (int)v46)
            v49 = v46;
          else
            v49 = v48;
          v50 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v49, "Vector Storage (uint8_t, growth)");
          memcpy(v50, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v49;
          *(_QWORD *)(a1 + 264) = v50;
          v51 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v50[v27 + 1], &v50[v27], v51 - v27);
        v52 = 2;
        *(_WORD *)(*(_QWORD *)(a1 + 264) + v27) = 2;
        goto LABEL_65;
      case 2u:
        v34 = v26 + 4;
        v35 = *(_DWORD *)(a1 + 256);
        if (v34 <= v35)
        {
          v38 = *(char **)(a1 + 264);
          v39 = v27;
        }
        else
        {
          if (v35 <= 1)
            v35 = 1;
          v36 = 2 * v35;
          if (v36 <= (int)v34)
            v37 = v34;
          else
            v37 = v36;
          v38 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v37, "Vector Storage (uint8_t, growth)");
          memcpy(v38, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v37;
          *(_QWORD *)(a1 + 264) = v38;
          v39 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v38[v27 + 1], &v38[v27], v39 - v27);
        v53 = *(_QWORD *)(a1 + 264) + v27;
        *(_BYTE *)(v53 + 2) = 0;
        *(_WORD *)v53 = 2;
        v52 = 3;
        goto LABEL_65;
      case 3u:
        v40 = v26 + 5;
        v41 = *(_DWORD *)(a1 + 256);
        if (v40 <= v41)
        {
          v44 = *(char **)(a1 + 264);
          v45 = v27;
        }
        else
        {
          if (v41 <= 1)
            v41 = 1;
          v42 = 2 * v41;
          if (v42 <= (int)v40)
            v43 = v40;
          else
            v43 = v42;
          v44 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v43, "Vector Storage (uint8_t, growth)");
          memcpy(v44, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v43;
          *(_QWORD *)(a1 + 264) = v44;
          v45 = *(_DWORD *)(a1 + 260);
        }
        memmove(&v44[v27 + 1], &v44[v27], v45 - v27);
        *(_DWORD *)(*(_QWORD *)(a1 + 264) + v27) = 2;
        v52 = 4;
LABEL_65:
        *(_DWORD *)(a1 + 260) += v52;
        break;
      default:
        break;
    }
  }
  result = *(int *)(a1 + 308);
  *(_DWORD *)(a1 + 308) = result + 1;
  return result;
}

void *glpLLVMSetGlobalConstant(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  char *v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  char *v17;
  int v18;
  void *result;
  int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  uint64_t v25;
  char *v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  int v30;
  uint64_t v31;
  char *v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  int v36;
  uint64_t v37;
  char *v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  int v42;
  uint64_t v43;
  char *v44;
  unsigned int v45;
  int v46;
  uint64_t v47;

  v4 = *(unsigned int *)(a1 + 260);
  v5 = v4 + 1;
  v6 = *(_DWORD *)(a1 + 256);
  if ((int)v4 + 1 <= v6)
  {
    v9 = *(char **)(a1 + 264);
    v10 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v6 <= 1)
      v6 = 1;
    v7 = 2 * v6;
    if (v7 <= v5)
      v8 = v5;
    else
      v8 = v7;
    v9 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v8, "Vector Storage (uint8_t, growth)");
    memcpy(v9, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v8;
    *(_QWORD *)(a1 + 264) = v9;
    v10 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v9[v4 + 1], &v9[v4], (v10 - v4));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v4) = 15;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  glpSerializeLLVMValue(a1, a2);
  v11 = (char)glp_serialized_integer32_control(1);
  v12 = *(unsigned int *)(a1 + 260);
  v13 = v12 + 1;
  v14 = *(_DWORD *)(a1 + 256);
  if ((int)v12 + 1 <= v14)
  {
    v17 = *(char **)(a1 + 264);
    v18 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v14 <= 1)
      v14 = 1;
    v15 = 2 * v14;
    if (v15 <= v13)
      v16 = v13;
    else
      v16 = v15;
    v17 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v16, "Vector Storage (uint8_t, growth)");
    memcpy(v17, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v16;
    *(_QWORD *)(a1 + 264) = v17;
    v18 = *(_DWORD *)(a1 + 260);
  }
  result = memmove(&v17[v12 + 1], &v17[v12], (v18 - v12));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v12) = v11;
  v20 = *(_DWORD *)(a1 + 260);
  v21 = v20 + 1;
  *(_DWORD *)(a1 + 260) = v20 + 1;
  if ((v11 & 0x80000000) != 0)
  {
    switch((v11 >> 1) & 7)
    {
      case 0u:
        v22 = v20 + 2;
        v23 = *(_DWORD *)(a1 + 256);
        if (v22 <= v23)
        {
          v26 = *(char **)(a1 + 264);
          v27 = v21;
        }
        else
        {
          if (v23 <= 1)
            v23 = 1;
          v24 = 2 * v23;
          if (v24 <= (int)v22)
            v25 = v22;
          else
            v25 = v24;
          v26 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v25, "Vector Storage (uint8_t, growth)");
          memcpy(v26, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v25;
          *(_QWORD *)(a1 + 264) = v26;
          v27 = *(_DWORD *)(a1 + 260);
        }
        result = memmove(&v26[v21 + 1], &v26[v21], v27 - v21);
        v46 = 1;
        *(_BYTE *)(*(_QWORD *)(a1 + 264) + v21) = 1;
        goto LABEL_55;
      case 1u:
        v40 = v20 + 3;
        v41 = *(_DWORD *)(a1 + 256);
        if (v40 <= v41)
        {
          v44 = *(char **)(a1 + 264);
          v45 = v21;
        }
        else
        {
          if (v41 <= 1)
            v41 = 1;
          v42 = 2 * v41;
          if (v42 <= (int)v40)
            v43 = v40;
          else
            v43 = v42;
          v44 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v43, "Vector Storage (uint8_t, growth)");
          memcpy(v44, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v43;
          *(_QWORD *)(a1 + 264) = v44;
          v45 = *(_DWORD *)(a1 + 260);
        }
        result = memmove(&v44[v21 + 1], &v44[v21], v45 - v21);
        *(_WORD *)(*(_QWORD *)(a1 + 264) + v21) = 1;
        v46 = 2;
        goto LABEL_55;
      case 2u:
        v28 = v20 + 4;
        v29 = *(_DWORD *)(a1 + 256);
        if (v28 <= v29)
        {
          v32 = *(char **)(a1 + 264);
          v33 = v21;
        }
        else
        {
          if (v29 <= 1)
            v29 = 1;
          v30 = 2 * v29;
          if (v30 <= (int)v28)
            v31 = v28;
          else
            v31 = v30;
          v32 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v31, "Vector Storage (uint8_t, growth)");
          memcpy(v32, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v31;
          *(_QWORD *)(a1 + 264) = v32;
          v33 = *(_DWORD *)(a1 + 260);
        }
        result = memmove(&v32[v21 + 1], &v32[v21], v33 - v21);
        v47 = *(_QWORD *)(a1 + 264) + v21;
        *(_BYTE *)(v47 + 2) = 0;
        *(_WORD *)v47 = 1;
        v46 = 3;
        goto LABEL_55;
      case 3u:
        v34 = v20 + 5;
        v35 = *(_DWORD *)(a1 + 256);
        if (v34 <= v35)
        {
          v38 = *(char **)(a1 + 264);
          v39 = v21;
        }
        else
        {
          if (v35 <= 1)
            v35 = 1;
          v36 = 2 * v35;
          if (v36 <= (int)v34)
            v37 = v34;
          else
            v37 = v36;
          v38 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v37, "Vector Storage (uint8_t, growth)");
          memcpy(v38, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
          (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
          *(_DWORD *)(a1 + 256) = v37;
          *(_QWORD *)(a1 + 264) = v38;
          v39 = *(_DWORD *)(a1 + 260);
        }
        result = memmove(&v38[v21 + 1], &v38[v21], v39 - v21);
        *(_DWORD *)(*(_QWORD *)(a1 + 264) + v21) = 1;
        v46 = 4;
LABEL_55:
        *(_DWORD *)(a1 + 260) += v46;
        break;
      default:
        return result;
    }
  }
  return result;
}

void *glpLLVMSetInitializer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  char *v11;
  int v12;

  v6 = *(unsigned int *)(a1 + 260);
  v7 = v6 + 1;
  v8 = *(_DWORD *)(a1 + 256);
  if ((int)v6 + 1 <= v8)
  {
    v11 = *(char **)(a1 + 264);
    v12 = *(_DWORD *)(a1 + 260);
  }
  else
  {
    if (v8 <= 1)
      v8 = 1;
    v9 = 2 * v8;
    if (v9 <= v7)
      v10 = v7;
    else
      v10 = v9;
    v11 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 232))(*(_QWORD *)(a1 + 224), v10, "Vector Storage (uint8_t, growth)");
    memcpy(v11, *(const void **)(a1 + 264), *(unsigned int *)(a1 + 260));
    (*(void (**)(_QWORD, _QWORD))(a1 + 248))(*(_QWORD *)(a1 + 224), *(_QWORD *)(a1 + 264));
    *(_DWORD *)(a1 + 256) = v10;
    *(_QWORD *)(a1 + 264) = v11;
    v12 = *(_DWORD *)(a1 + 260);
  }
  memmove(&v11[v6 + 1], &v11[v6], (v12 - v6));
  *(_BYTE *)(*(_QWORD *)(a1 + 264) + v6) = 16;
  ++*(_DWORD *)(a1 + 260);
  ++*(_DWORD *)(a1 + 296);
  glpSerializeLLVMValue(a1, a2);
  return glpSerializeLLVMValue(a1, a3);
}

uint64_t glpLLVMCGWriteVertexOuptut(uint64_t result, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t inserted;
  uint64_t *v12;
  uint64_t *v13;
  _BOOL4 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if ((~*(unsigned __int16 *)(result + 832) & 3) != 0)
  {
    v3 = result;
    if (!*(_QWORD *)(result + 208))
      *(_QWORD *)(result + 208) = glpLLVMConstFromTypeCache(result, 37, *(_QWORD *)(result + 200));
    v4 = *(unsigned int *)(v3 + 692);
    if ((int)v4 < 1)
    {
      v5 = 0;
    }
    else
    {
      v5 = 0;
      while (*(_QWORD *)(*(_QWORD *)(v3 + 696) + 8 * v5) != a2)
      {
        if (v4 == ++v5)
        {
          v5 = *(unsigned int *)(v3 + 692);
          break;
        }
      }
    }
    v6 = glpLLVMGetVariablePointer(v3, a2);
    v7 = glpPrecisionIndexFromSAFlags(*(_QWORD *)(a2 + 48));
    v8 = glpTypeToLLVMType((_QWORD *)v3, *(unsigned int **)a2, v7, (_QWORD *)a2);
    v9 = glpLLVMPointerType(v3, v8, 0);
    v10 = glpLLVMCastOperation(v3, 86, v6, v9, "ptr");
    inserted = glpLLVMBuildLoad(v3, v10, "out");
    if ((*(_WORD *)(v3 + 832) & 1) == 0)
      goto LABEL_20;
    v12 = glpLayoutObjectFind(*(uint64_t **)(a2 + 8), 69);
    v13 = glpLayoutObjectFind(*(uint64_t **)(a2 + 8), 70);
    if (v13)
    {
      v14 = *((_DWORD *)v13 + 4) == 0;
      if (!v12)
        goto LABEL_20;
    }
    else
    {
      v14 = 1;
      if (!v12)
      {
LABEL_20:
        result = glpLLVMBuildInsertValue(v3, *(_QWORD *)(v3 + 208), inserted, v5, "returnValue");
        *(_QWORD *)(v3 + 208) = result;
        return result;
      }
    }
    if (*((_DWORD *)v12 + 4) == 5 && v14)
    {
      v15 = glpLLVMVectorType(v3, v8, 4);
      v16 = glpLLVMConstFromTypeCache(v3, 37, v15);
      v17 = *(_QWORD *)(v3 + 520);
      if (!v17)
      {
        v17 = glpLLVMConstIntCache(v3, *(_QWORD *)(v3 + 40), 0, 0);
        *(_QWORD *)(v3 + 520) = v17;
      }
      inserted = glpLLVMBuildInsertElement(v3, v16, inserted, v17, "fogCoord");
    }
    goto LABEL_20;
  }
  return result;
}

void _glpSetCrashLogMessage(uint64_t a1)
{
  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_FAULT))
    _glpSetCrashLogMessage_cold_1(a1);
}

void glpSetCrashLogMessagef(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  os_unfair_lock_lock(&message_lock);
  vsnprintf_l(message, 0x400uLL, 0, a1, &a9);
  os_unfair_lock_unlock(&message_lock);
  _glpSetCrashLogMessage((uint64_t)message);
}

_QWORD *glpMakeCompiler(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  int v13;
  int Default;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  char *v18;
  BOOL v19;
  __n128 v21;
  uint64_t v22;

  v13 = a1;
  Default = glpGLSLVersionGetDefault(a1, a2);
  v15 = malloc_type_malloc(0x88uLL, 0x7081ABB9uLL);
  if (!v15)
    abort();
  v16 = v15;
  glpInitPoolAllocator(0x4000, 0x8000, v15);
  v21.n128_u64[0] = (unint64_t)"-1";
  v21.n128_u64[1] = 0xEDA00000002;
  v22 = 0xFFFFFFFFLL;
  glpMakeTopLevelNode((uint64_t)v16, &v21);
  v16[9] = v17;
  *((_DWORD *)v16 + 20) = 0;
  v16[11] = glpMakePointerHash(v16);
  v16[13] = glpMakeTypedValueHash(v16);
  v16[4] = glpMakeNameTable((uint64_t)v16, a3, Default);
  *((_DWORD *)v16 + 10) = v13;
  *((_DWORD *)v16 + 11) = a2;
  *((_DWORD *)v16 + 12) = 0;
  v16[7] = a4;
  v16[8] = a5;
  *((_DWORD *)v16 + 21) = a6;
  *((_BYTE *)v16 + 96) = 0;
  v18 = getenv("GL_SHADER_STYLE_GUIDE");
  if (v18)
    v19 = strcmp(v18, "0") != 0;
  else
    v19 = 0;
  *((_BYTE *)v16 + 97) = v19;
  *((_BYTE *)v16 + 98) = 0;
  *((_DWORD *)v16 + 25) = a7;
  v16[14] = glpMakeStringHash(v16);
  v16[15] = 32;
  v16[16] = ((uint64_t (*)(_QWORD, uint64_t, const char *))v16[1])(*v16, 256, "Vector Storage (GLPASTNode *)");
  return v16;
}

void glpDestroyCompiler(_QWORD *a1)
{
  glpDestroyPointerHash(a1[11]);
  glpDestroyTypedValueHash(a1[13]);
  glpDestroyNameTable(a1[4]);
  glpDestroyStringHash(a1[14]);
  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[16]);
  glpDestroyPoolAllocator((uint64_t)a1);
  free(a1);
}

uint64_t glpCompilerGetOptions(uint64_t a1)
{
  return *(unsigned int *)(a1 + 100);
}

uint64_t glpCompilerGetGLProfile(uint64_t a1)
{
  return *(unsigned int *)(a1 + 44);
}

uint64_t glpCompilerGetIOSVersion(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t glpCompilerGetInfoLog(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t glpCompilerRemapObject(_QWORD *a1, int a2, _QWORD *a3, uint64_t a4, int a5)
{
  uint64_t v10;
  double VariableObject;
  double v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  double v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  const void *v46;
  char *v47;
  uint64_t v48;
  unsigned int VariableObjectCount;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  char v57;
  uint64_t InterfaceBlockNode;
  void *v59;
  const void *v60;
  char *v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t *v64;
  int Kind;
  uint64_t v66;
  int FrameworkConstantByIndex;
  uint64_t ElementType;
  int MaxElementCount;
  uint64_t v70;
  char *PrimitiveType;
  unsigned int *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  char *MutableValue;
  unsigned int *v80;
  uint64_t v81;
  uint64_t v82;
  unsigned int v83;
  _QWORD *v84;
  uint64_t v85;
  void *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  void *v99;
  __n128 v100;
  uint64_t v101;
  void *v102;
  _QWORD *v103;
  unint64_t v104;

  if (!a3)
    return 0;
  v10 = glpPointerHashGet(a1[11], (unint64_t)a3);
  if (!v10)
  {
    switch(a2)
    {
      case 0:
      case 12:
        v16 = a3[6];
        if ((v16 & 0x40000000) != 0)
          v17 = (unint64_t)(*((_BYTE *)a1 + 96) != 0) << 40;
        else
          v17 = 0;
        v34 = v17 | v16;
        if ((_DWORD)a4)
        {
          v98 = glpCompilerRemapObject(a1, 10, *a3, a4, 1);
          v35 = (uint64_t *)glpCompilerRemapObject(a1, 11, a3[1], a4, 1);
          v99 = glpCopyString((uint64_t)a1, (const void *)a3[2], a3[3]);
          v37 = v36;
          v43 = glpCopyString((uint64_t)a1, (const void *)a3[4], a3[5]);
          v45 = v44;
          v46 = (const void *)a3[8];
          if (v46)
            v47 = glpCopyValue((uint64_t)a1, (unsigned int *)*a3, v46, v38, v39, v40, v41, v42);
          else
            v47 = 0;
          v60 = (const void *)a3[9];
          if (v60)
          {
            v61 = v47;
            if (v60 != (const void *)a3[8])
              v61 = glpCopyValue((uint64_t)a1, (unsigned int *)*a3, v60, v38, v39, v40, v41, v42);
          }
          else
          {
            v61 = 0;
          }
          v97 = (uint64_t)v47;
          v48 = v37;
          VariableObject = glpMakeVariableObject((uint64_t)a1, v98, (uint64_t)v35, v34, (uint64_t)v99, v37, (uint64_t)v43, v45, *((_BYTE *)a3 + 56), v97, (uint64_t)v61);
          v10 = v62;
          *(_QWORD *)(v62 + 96) = a3[12];
        }
        else
        {
          v48 = a3[3];
          v99 = (void *)a3[2];
          v35 = (uint64_t *)a3[1];
          v10 = (uint64_t)a3;
          a3[6] = v34;
        }
        if (!v35)
          goto LABEL_56;
        v63 = glpLayoutObjectFind(v35, 90);
        if (!v63)
          goto LABEL_56;
        v64 = v63;
        Kind = glpTypeGetKind(*(unsigned int **)v10);
        if (Kind)
        {
          if (Kind != 2)
LABEL_74:
            abort();
          v66 = v48;
          FrameworkConstantByIndex = glpGetFrameworkConstantByIndex(*((_DWORD *)v64 + 4), *((unsigned __int8 *)a1 + 44));
          ElementType = glpArrayTypeGetElementType(*(_QWORD *)v10);
          MaxElementCount = glpArrayTypeGetMaxElementCount(*(_QWORD *)v10);
          *(_QWORD *)v10 = glpMakeArrayType((uint64_t)a1, ElementType, FrameworkConstantByIndex, MaxElementCount);
          v48 = v66;
        }
        else
        {
          v70 = v48;
          PrimitiveType = glpGetPrimitiveType(5u);
          v72 = (unsigned int *)glpGetPrimitiveType(5u);
          v73 = glpGetFrameworkConstantByIndex(*((_DWORD *)v64 + 4), *((unsigned __int8 *)a1 + 44));
          MutableValue = glpMakeMutableValue((uint64_t)a1, v72, 1, v74, v75, v76, v77, v78, v73);
          v80 = (unsigned int *)PrimitiveType;
          v48 = v70;
          *(_QWORD *)(v10 + 64) = glpRemapValue(a1[13], v80, MutableValue);
        }
LABEL_56:
        if ((_DWORD)a4)
          *(_QWORD *)(v10 + 80) = glpCompilerRemapObject(a1, 2, a3[10], a4, 0);
        if (!a5 || (*(_QWORD *)(v10 + 48) & 0x80000000) == 0)
          goto LABEL_63;
        v100.n128_u64[0] = (unint64_t)"-1";
        v100.n128_u64[1] = 0xEDA00000002;
        v101 = 0xFFFFFFFFLL;
        glpMakeVariableDeclarationNode((uint64_t)a1, &v100, (uint64_t)v99, v48, 0);
        InterfaceBlockNode = v81;
        glpVariableDeclarationNodeSetExtra(v81, v10);
        glpASTNodeSetSaFlags(InterfaceBlockNode, *(_QWORD *)(v10 + 48));
        v59 = *(void **)v10;
LABEL_61:
        glpASTNodeSetSaType(InterfaceBlockNode, (uint64_t)v59);
        v82 = a1[9];
        v83 = *((_DWORD *)a1 + 20);
        *((_DWORD *)a1 + 20) = v83 + 1;
        v84 = a1;
        v85 = InterfaceBlockNode;
        goto LABEL_62;
      case 1:
      case 2:
      case 3:
        v10 = (uint64_t)a3;
        if ((_DWORD)a4)
        {
          v10 = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 88, "Interface Block Object (remapped)");
          glpPointerHashPut(a1[11], (unint64_t)a3, v10, v12);
          *(_QWORD *)v10 = glpCopyString((uint64_t)a1, (const void *)*a3, a3[1]);
          *(_QWORD *)(v10 + 8) = v13;
          if (*((_BYTE *)a3 + 32))
          {
            v14 = (const char *)glpCopyString((uint64_t)a1, (const void *)a3[2], a3[3]);
          }
          else
          {
            v15 = 0xDFA3F2CD0000004BLL;
            v14 = "<<BUG: printing instance name of interface block without an instance name>>";
          }
          *(_QWORD *)(v10 + 16) = v14;
          *(_QWORD *)(v10 + 24) = v15;
          *(_BYTE *)(v10 + 32) = *((_BYTE *)a3 + 32);
          *(_QWORD *)(v10 + 40) = a3[5];
          *(_QWORD *)(v10 + 64) = glpCompilerRemapObject(a1, 10, a3[8], a4, 1);
          VariableObjectCount = glpInterfaceBlockObjectGetVariableObjectCount((uint64_t)a3);
          *(_QWORD *)(v10 + 72) = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8 * VariableObjectCount, "Variable Object Array of Interface Block (remapped)");
          if (VariableObjectCount)
          {
            v50 = 0;
            v51 = 8 * VariableObjectCount;
            do
            {
              *(_QWORD *)(*(_QWORD *)(v10 + 72) + v50) = glpCompilerRemapObject(a1, 0, *(_QWORD *)(a3[9] + v50), a4, 0);
              v50 += 8;
            }
            while (v51 != v50);
          }
          v52 = a3[10];
          if (v52)
          {
            v53 = a1[11];
            v100.n128_u64[0] = MEMORY[0x24BDAC760];
            v100.n128_u64[1] = 0x40000000;
            v101 = (uint64_t)__glpCompilerRemapBufferObject_block_invoke;
            v102 = &__block_descriptor_tmp_19;
            v103 = a1;
            v104 = v52;
            v54 = glpPointerHashCache_b(v53, v52, (uint64_t)&v100);
          }
          else
          {
            v54 = 0;
          }
          *(_QWORD *)(v10 + 80) = v54;
          v55 = a3[7];
          if (v55)
            *(_QWORD *)(v10 + 56) = glpCompilerRemapObject(a1, 11, v55, a4, 0);
        }
        if (!a5)
          goto LABEL_63;
        v56 = *(_BYTE *)(v10 + 32);
        v57 = glpTypeGetKind(*(unsigned int **)(v10 + 64)) == 3;
        v100.n128_u64[0] = (unint64_t)"-1";
        v100.n128_u64[1] = 0xEDA00000002;
        v101 = 0xFFFFFFFFLL;
        InterfaceBlockNode = glpMakeInterfaceBlockNode((uint64_t)a1, &v100, *(_QWORD *)v10, *(_QWORD *)(v10 + 8), *(_QWORD *)(v10 + 16), *(_QWORD *)(v10 + 24), v56, v57, v10);
        glpASTNodeSetSaFlags(InterfaceBlockNode, 0);
        v59 = glpGetPrimitiveType(0);
        goto LABEL_61;
      case 4:
        if (!(_DWORD)a4)
          goto LABEL_27;
        v19 = 0;
        v20 = 0;
        v21 = a3;
        do
        {
          v22 = (_QWORD *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 16, "Overload Group");
          *v22 = glpCompilerRemapObject(a1, 10, *v21, a4, 1);
          v22[1] = 0;
          v10 = (uint64_t)v22;
          if (v20)
          {
            v20[1] = v22;
            v10 = v19;
          }
          v21 = (_QWORD *)v21[1];
          v19 = v10;
          v20 = v22;
        }
        while (v21);
        goto LABEL_63;
      case 5:
        v23 = a3[8];
        if ((_DWORD)a4)
        {
          v24 = glpCompilerRemapObject(a1, 10, *a3, a4, 1);
          v25 = glpCopyString((uint64_t)a1, (const void *)a3[3], a3[4]);
          v27 = v26;
          v28 = glpCopyString((uint64_t)a1, (const void *)a3[5], a3[6]);
          glpMakeFunctionObject((uint64_t)a1, v24, a3[1], (uint64_t)v25, v27, (uint64_t)v28, v29);
          v10 = v30;
          v31 = a3[11];
          *(_QWORD *)(v30 + 88) = v31;
          *(_QWORD *)(v30 + 80) = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8 * v31, "Parameter Info (remapped)");
          if (*((_DWORD *)a3 + 22))
          {
            v32 = 0;
            do
            {
              *(_QWORD *)(*(_QWORD *)(v10 + 80) + 8 * v32) = glpCompilerRemapObject(a1, 12, *(_QWORD *)(a3[10] + 8 * v32), a4, 1);
              ++v32;
            }
            while (v32 < *((unsigned int *)a3 + 22));
          }
          *(_QWORD *)(v10 + 72) = glpCompilerRemapObject(a1, 12, a3[9], a4, 1);
          if (!v23)
            goto LABEL_67;
          glpPointerHashPut(a1[11], (unint64_t)a3, v10, v33);
          *(_QWORD *)(v10 + 64) = -1;
          v23 = glpDeepCopyASTNode(a1, a3[8], (uint64_t (*)(uint64_t, uint64_t *, _DWORD *))compilerRemapFixup, (uint64_t)a1);
          *(_QWORD *)(v10 + 64) = v23;
        }
        else
        {
          v10 = (uint64_t)a3;
        }
        if (v23)
          goto LABEL_72;
LABEL_67:
        v87 = glpCopyString((uint64_t)a1, (const void *)a3[3], a3[4]);
        v100.n128_u64[0] = (unint64_t)"-1";
        v100.n128_u64[1] = 0xEDA00000002;
        v101 = 0xFFFFFFFFLL;
        glpMakeFunctionPrototypeNode((uint64_t)a1, &v100, (uint64_t)v87, v88);
        v23 = v89;
        glpFunctionPrototypeNodeSetExtra(v89, v10);
        v90 = *(_QWORD *)(v10 + 72);
        if (v90)
        {
          v100.n128_u64[0] = (unint64_t)"-1";
          v100.n128_u64[1] = 0xEDA00000002;
          v101 = 0xFFFFFFFFLL;
          glpMakeParameterDeclarationNode((uint64_t)a1, &v100, *(_QWORD *)(v90 + 16), *(_QWORD *)(v90 + 24));
          v92 = v91;
          glpParameterDeclarationNodeSetExtra(v91, *(_QWORD *)(v10 + 72));
          glpASTNodeSetSaType(v92, **(_QWORD **)(v10 + 72));
          glpASTNodeSetSaFlags(v92, *(_QWORD *)(*(_QWORD *)(v10 + 72) + 48));
          glpFunctionPrototypeNodeSetReturnOutParam(v23, v92);
        }
        if (*((_DWORD *)a3 + 22))
        {
          v93 = 0;
          do
          {
            v94 = *(_QWORD *)(*(_QWORD *)(v10 + 80) + 8 * v93);
            v100.n128_u64[0] = (unint64_t)"-1";
            v100.n128_u64[1] = 0xEDA00000002;
            v101 = 0xFFFFFFFFLL;
            glpMakeParameterDeclarationNode((uint64_t)a1, &v100, *(_QWORD *)(v94 + 16), *(_QWORD *)(v94 + 24));
            v96 = v95;
            glpParameterDeclarationNodeSetExtra(v95, *(_QWORD *)(*(_QWORD *)(v10 + 80) + 8 * v93));
            glpASTNodeSetSaType(v96, **(_QWORD **)(*(_QWORD *)(v10 + 80) + 8 * v93));
            glpASTNodeSetSaFlags(v96, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v10 + 80) + 8 * v93) + 48));
            glpFunctionPrototypeNodeAddParameter(a1, v23, v96);
            ++v93;
          }
          while (v93 < *((unsigned int *)a3 + 22));
        }
LABEL_72:
        if (a5)
        {
          v82 = a1[9];
          v83 = *((_DWORD *)a1 + 20);
          *((_DWORD *)a1 + 20) = v83 + 1;
          v84 = a1;
          v85 = v23;
LABEL_62:
          glpTopLevelNodeInsertDef(v84, v82, v85, v83);
        }
        goto LABEL_63;
      case 6:
      case 10:
        if (!(_DWORD)a4)
          goto LABEL_27;
        v18 = glpDeepCopyType(a1, (uint64_t)a3);
        goto LABEL_26;
      case 11:
        if ((_DWORD)a4)
        {
          v18 = (uint64_t)glpCopyLayoutObject(a1, (_QWORD **)a3);
LABEL_26:
          v10 = v18;
LABEL_63:
          glpPointerHashPut(a1[11], (unint64_t)a3, v10, VariableObject);
        }
        else
        {
LABEL_27:
          v10 = (uint64_t)a3;
        }
        break;
      default:
        goto LABEL_74;
    }
  }
  return v10;
}

uint64_t glpCompilerPoolAlloc(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 8))(*(_QWORD *)a1);
}

uint64_t compilerRemapFixup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  int Kind;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t Extra;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t VariableExtra;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD v24[5];

  v3 = a3;
  Kind = glpASTNodeGetKind(a3);
  if (Kind <= 45)
  {
    if (Kind <= 43)
    {
      if (Kind == 7)
      {
        glpFunctionCallNodeGetExtra(v3);
      }
      else if (Kind == 1)
      {
        abort();
      }
    }
    else if (Kind == 44)
    {
      Extra = glpParameterDeclarationNodeGetExtra(v3);
      v13 = glpCompilerRemapObject(a1, 12, Extra, 1, 1);
      glpParameterDeclarationNodeSetExtra(v3, v13);
    }
    else
    {
      v8 = glpFunctionPrototypeNodeGetExtra(v3);
      v9 = glpCompilerRemapObject(a1, 5, v8, 1, 1);
      glpFunctionPrototypeNodeSetExtra(v3, v9);
    }
  }
  else
  {
    switch(Kind)
    {
      case 'K':
        v6 = glpReturnStatementNodeGetExtra(v3);
        v7 = glpCompilerRemapObject(a1, 5, v6, 1, 1);
        glpReturnStatementNodeSetExtra(v3, v7);
        break;
      case 'L':
      case 'M':
      case 'O':
        return v3;
      case 'N':
        v14 = glpRawCallNodeGetExtra(v3);
        v15 = glpCompilerRemapObject(a1, 5, v14, 1, 1);
        glpRawCallNodeSetExtra(v3, v15);
        break;
      case 'P':
        v16 = glpOffsetNodeGetExtra(v3);
        v17 = *(_QWORD *)(a1 + 88);
        v24[0] = MEMORY[0x24BDAC760];
        v24[1] = 0x40000000;
        v24[2] = __compilerRemapFixup_block_invoke;
        v24[3] = &__block_descriptor_tmp_18;
        v24[4] = a1;
        v18 = glpPointerHashCache_b(v17, v16, (uint64_t)v24);
        glpOffsetNodeSetExtra(v3, v18);
        break;
      case 'Q':
        VariableExtra = glpLValueNodeGetVariableExtra(v3);
        v20 = glpCompilerRemapObject(a1, 0, VariableExtra, 1, 1);
        glpLValueNodeSetVariableExtra(v3, v20);
        break;
      default:
        if (Kind == 46)
        {
          v21 = glpVariableDeclarationNodeGetExtra(v3);
          v22 = glpCompilerRemapObject(a1, 12, v21, 1, 1);
          glpVariableDeclarationNodeSetExtra(v3, v22);
        }
        else if (Kind == 63)
        {
          v10 = *(_QWORD *)(a1 + 72);
          v11 = *(_DWORD *)(a1 + 80);
          *(_DWORD *)(a1 + 80) = v11 + 1;
          glpTopLevelNodeInsertDef((_QWORD *)a1, v10, v3, v11);
          v3 = 0;
        }
        break;
    }
  }
  return v3;
}

void *glpCompilerInsertDef(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;

  v3 = *(_QWORD *)(a1 + 72);
  v4 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v4 + 1;
  return glpTopLevelNodeInsertDef((_QWORD *)a1, v3, a2, v4);
}

uint64_t glpCompilerAllOutputsAreInvariant(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 96);
}

uint64_t glpGetFrameworkConstantByIndex(int a1, int a2)
{
  _BOOL8 v2;
  uint64_t result;

  v2 = a2 == 4;
  switch(a1)
  {
    case 0:
      result = glpBuiltInConstantValues[8 * v2];
      break;
    case 1:
      result = glpBuiltInConstantValues[8 * v2 + 3];
      break;
    case 2:
      result = glpBuiltInConstantValues[8 * v2 + 4];
      break;
    case 3:
      result = glpBuiltInConstantValues[8 * v2 + 5];
      break;
    case 4:
      result = glpBuiltInConstantValues[8 * v2 + 7];
      break;
    case 5:
      result = glpBuiltInConstantValues[8 * v2 + 1];
      break;
    case 6:
      result = glpBuiltInConstantValues[8 * v2 + 2];
      break;
    case 7:
      result = glpBuiltInConstantValues[8 * v2 + 6];
      break;
    case 8:
      result = glpBuiltInConstantValues[8 * v2 + 2] - 1;
      break;
    default:
      abort();
  }
  return result;
}

uint64_t glpCompilerRemapValue(uint64_t a1, unsigned int *a2, char *a3)
{
  return glpRemapValue(*(_QWORD *)(a1 + 104), a2, a3);
}

char *glpCompilerNewTempName(uint64_t a1)
{
  size_t v2;
  char *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;

  v2 = (snprintf_l(0, 0, 0, "$%u", *(_DWORD *)(a1 + 48)) + 1);
  v3 = (char *)(*(uint64_t (**)(_QWORD, size_t, const char *))(a1 + 8))(*(_QWORD *)a1, v2, "Compiler temp name");
  snprintf_l(v3, v2, 0, "$%u", *(_DWORD *)(a1 + 48));
  ++*(_DWORD *)(a1 + 48);
  v4 = strlen(v3);
  if (v4 >> 5 < v4)
  {
    v5 = v4;
    v6 = v4;
    do
    {
      v6 ^= 32 * v6 + (v6 >> 2) + v3[v5 - 1];
      v5 += ~(v4 >> 5);
    }
    while (v5 > v4 >> 5);
  }
  return v3;
}

uint64_t glpCompilerGetNameTable(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t glpCompilerGetLanguage(uint64_t a1)
{
  return glpNameTableGetLanguage(*(_QWORD *)(a1 + 32));
}

uint64_t glpCompilerGetTopLevelNode(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t glpCompilerApplyImplictRulesForGlobalTypeQualifier(uint64_t a1, uint64_t a2)
{
  uint64_t SaFlags;
  int Language;
  BOOL v9;
  uint64_t result;
  uint64_t *Layout;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  unsigned int v18;

  SaFlags = glpASTNodeGetSaFlags(a2);
  if (glpNameTableGetLanguage(*(_QWORD *)(a1 + 32)) == 3 && (SaFlags & 0x40000000) != 0)
    return 1;
  if (glpNameTableGetLanguage(*(_QWORD *)(a1 + 32)) == 3 && (SaFlags & 0x20000000) != 0)
  {
    v18 = -1;
    Layout = (uint64_t *)glpGlobalTypeQualifierNodeGetLayout(a2);
    glpLayoutObjectGetGeomInOut(Layout, &v18, 0, 0, 0, 0);
    if (v18 != -1)
    {
      glpNameTableGet(*(_QWORD *)(a1 + 32), "gl_in", 0x1057ED5B00000005, 0, (uint64_t)&__block_literal_global_0);
      v12 = v18;
      v13 = a1;
      v14 = 0x20000000;
      goto LABEL_27;
    }
    return 1;
  }
  if (glpNameTableGetLanguage(*(_QWORD *)(a1 + 32)) == 1 && (SaFlags & 0x40000000) != 0)
  {
    v15 = (uint64_t *)glpGlobalTypeQualifierNodeGetLayout(a2);
    v16 = glpLayoutObjectFind(v15, 18);
    if (v16)
    {
      v17 = *((unsigned int *)v16 + 4);
      if ((_DWORD)v17 != -1)
      {
        glpNameTableGet(*(_QWORD *)(a1 + 32), "gl_out", 0x92973DC800000006, 0, (uint64_t)&__block_literal_global_15);
        v13 = a1;
        v14 = 0x40000000;
        v12 = v17;
LABEL_27:
        result = glpApplySizeToBanks(v13, v14, v12);
        if (!(_DWORD)result)
          return result;
      }
    }
    return 1;
  }
  Language = glpNameTableGetLanguage(*(_QWORD *)(a1 + 32));
  v9 = (SaFlags & 0x20000000) != 0 && Language == 2;
  result = 1;
  if (!v9 && (SaFlags & 0x100000000) == 0)
    abort();
  return result;
}

void __glpCompilerApplyImplictRulesForGlobalTypeQualifier_block_invoke(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  if (a2 == 1)
    *a5 = 1;
}

void __glpCompilerApplyImplictRulesForGlobalTypeQualifier_block_invoke_2(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  if (a2 == 1)
    *a5 = 1;
}

uint64_t glpCompilerGetImpliedBankSize(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t GlobalTypeQualifier;
  uint64_t *Layout;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  unsigned int v9;

  v2 = 32;
  switch(a2)
  {
    case 1:
      v2 = 0xFFFFFFFFLL;
      v9 = -1;
      GlobalTypeQualifier = glpTopLevelNodeGetGlobalTypeQualifier(*(_QWORD *)(a1 + 72), 0x20000000);
      if (GlobalTypeQualifier)
      {
        Layout = (uint64_t *)glpGlobalTypeQualifierNodeGetLayout(GlobalTypeQualifier);
        glpLayoutObjectGetGeomInOut(Layout, &v9, 0, 0, 0, 0);
        return v9;
      }
      return v2;
    case 2:
    case 4:
      return v2;
    case 3:
      v5 = glpTopLevelNodeGetGlobalTypeQualifier(*(_QWORD *)(a1 + 72), 0x40000000);
      if (!v5)
        goto LABEL_7;
      v6 = (uint64_t *)glpGlobalTypeQualifierNodeGetLayout(v5);
      v7 = glpLayoutObjectFind(v6, 18);
      if (!v7)
        goto LABEL_7;
      v2 = *((unsigned int *)v7 + 4);
      break;
    case 5:
LABEL_7:
      v2 = 0xFFFFFFFFLL;
      break;
    default:
      abort();
  }
  return v2;
}

uint64_t glpCompilerGetValueHash(uint64_t a1)
{
  return *(_QWORD *)(a1 + 104);
}

uint64_t glpCompilerGetIntConstant(uint64_t a1, uint64_t a2)
{
  unsigned int *PrimitiveType;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *MutableValue;

  PrimitiveType = (unsigned int *)glpGetPrimitiveType(5u);
  MutableValue = glpMakeMutableValue(a1, PrimitiveType, 1, v5, v6, v7, v8, v9, a2);
  return glpRemapValue(*(_QWORD *)(a1 + 104), PrimitiveType, MutableValue);
}

uint64_t glpCompilerForceAllOutputsToBeInvariant(uint64_t result)
{
  *(_BYTE *)(result + 96) = 1;
  return result;
}

uint64_t glpCompilerUsingStyleGuide(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 97);
}

uint64_t glpCompilerGetSubroutineType(_QWORD *a1, const char *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  uint64_t *FunctionObject;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  uint64_t v21;
  uint64_t v23;
  double SubroutineType;
  uint64_t v25;

  v8 = glpStringHashGet(a1[14], a2, a3);
  if (v8)
    return v8;
  v9 = a1[14];
  v10 = *(unsigned int *)(v9 + 32);
  if (!(_DWORD)v10)
    goto LABEL_8;
  v11 = 0;
  v12 = 0;
  while (1)
  {
    v13 = *(_QWORD *)(v9 + 40);
    v14 = *(_QWORD *)(v13 + v11);
    if (v14)
      break;
LABEL_7:
    ++v12;
    v11 += 32;
    if (v12 >= v10)
      goto LABEL_8;
  }
  v15 = (unsigned int *)*a4;
  FunctionObject = (uint64_t *)glpSubroutineTypeGetFunctionObject(*(_QWORD *)(v13 + v11));
  if (!glpTypesEqual(v15, *FunctionObject))
  {
    v10 = *(unsigned int *)(v9 + 32);
    goto LABEL_7;
  }
  v23 = glpSubroutineTypeGetFunctionObject(v14);
  SubroutineType = glpMakeSubroutineType((uint64_t)a1, (uint64_t)a2, a3, v23);
  v8 = v25;
  glpStringHashPut(a1[14], a2, a3, v25, SubroutineType);
  if (!v8)
  {
LABEL_8:
    v17 = glpCompilerNewTempName((uint64_t)a1);
    a4[3] = (uint64_t)v17;
    a4[4] = v18;
    a4[5] = glpAggregateTypeMangleName(*a4, (uint64_t)v17, v18, a1);
    a4[6] = v19;
    v20 = glpMakeSubroutineType((uint64_t)a1, (uint64_t)a2, a3, (uint64_t)a4);
    v8 = v21;
    glpStringHashPut(a1[14], a2, a3, v21, v20);
  }
  return v8;
}

uint64_t glpCompilerGetImplicitConversionPolicy(uint64_t a1)
{
  uint64_t v1;
  unsigned int GLSLVersion;
  unsigned int v3;

  v1 = *(_QWORD *)(a1 + 32);
  GLSLVersion = glpNameTableGetGLSLVersion(v1);
  if (GLSLVersion > 9)
    abort();
  if (((1 << GLSLVersion) & 0xBC) != 0)
  {
    if (glpNameTableIsExtensionEnabled(v1, 0x12u))
      v3 = 2;
    else
      v3 = 1;
    if (glpNameTableIsExtensionEnabled(v1, 0x13u))
      return 3;
    else
      return v3;
  }
  else if (((1 << GLSLVersion) & 0x43) != 0)
  {
    return 0;
  }
  else
  {
    return 3;
  }
}

BOOL glpCompilerDoesTrackPrecision(uint64_t a1)
{
  int GLSLVersion;

  GLSLVersion = glpNameTableGetGLSLVersion(*(_QWORD *)(a1 + 32));
  return !GLSLVersion || GLSLVersion == 6;
}

BOOL glpCompilerDoesTypeRequirePrecision(uint64_t a1, unsigned int *ElementType)
{
  int GLSLVersion;
  int Kind;
  uint64_t PrimitiveType;
  int ScalarType;

  GLSLVersion = glpNameTableGetGLSLVersion(*(_QWORD *)(a1 + 32));
  if (GLSLVersion != 6 && GLSLVersion != 0)
    return 0;
  while (1)
  {
    Kind = glpTypeGetKind(ElementType);
    if (Kind != 2)
      break;
    ElementType = (unsigned int *)glpArrayTypeGetElementType((uint64_t)ElementType);
  }
  if (Kind)
    return 0;
  PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)ElementType);
  if (glpPrimitiveTypeGetCategory(PrimitiveType) == 4)
    return 1;
  if (!(_DWORD)PrimitiveType)
    return 0;
  ScalarType = glpPrimitiveTypeGetScalarType(PrimitiveType);
  return ScalarType != 62 && ScalarType != 9;
}

uint64_t glpCompilerSetRequiresOutputPoints(uint64_t result, char a2)
{
  *(_BYTE *)(result + 98) = a2;
  return result;
}

uint64_t glpCompilerRequiresOutputPoints(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 98);
}

void *glpCompilerPushSAContext(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  char *v8;
  int v9;
  void *result;

  v4 = *(_DWORD *)(a1 + 120);
  v5 = *(unsigned int *)(a1 + 124);
  if ((int)v5 + 1 <= v4)
  {
    v8 = *(char **)(a1 + 128);
    v9 = *(_DWORD *)(a1 + 124);
  }
  else
  {
    if (v4 <= 1)
      v4 = 1;
    v6 = 2 * v4;
    if (v6 <= (int)v5 + 1)
      v7 = v5 + 1;
    else
      v7 = v6;
    v8 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 8 * v7, "Vector Storage (GLPASTNode *, growth)");
    memcpy(v8, *(const void **)(a1 + 128), 8 * *(unsigned int *)(a1 + 124));
    (*(void (**)(_QWORD, _QWORD))(a1 + 24))(*(_QWORD *)a1, *(_QWORD *)(a1 + 128));
    *(_DWORD *)(a1 + 120) = v7;
    *(_QWORD *)(a1 + 128) = v8;
    v9 = *(_DWORD *)(a1 + 124);
  }
  result = memmove(&v8[8 * v5 + 8], &v8[8 * v5], 8 * (v9 - v5));
  *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8 * v5) = a2;
  ++*(_DWORD *)(a1 + 124);
  return result;
}

uint64_t glpCompilerPopSAContext(uint64_t result)
{
  --*(_DWORD *)(result + 124);
  return result;
}

uint64_t glpCompilerGetImmediateSAContext(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8 * (*(_DWORD *)(a1 + 124) - 2));
}

double __compilerRemapFixup_block_invoke(uint64_t a1)
{
  return glpMakeOffsetObject(*(_QWORD *)(a1 + 32));
}

double __glpCompilerRemapBufferObject_block_invoke(uint64_t a1)
{
  return glpMakeBufferObject(*(_QWORD *)(a1 + 32), **(_QWORD **)(a1 + 40), *(_DWORD *)(*(_QWORD *)(a1 + 40) + 8), *(_DWORD *)(*(_QWORD *)(a1 + 40) + 12));
}

uint64_t glpScalarTypeFromGLPType(uint64_t a1)
{
  uint64_t PrimitiveType;
  int ScalarType;

  PrimitiveType = glpPrimitiveTypeGetPrimitiveType(a1);
  ScalarType = glpPrimitiveTypeGetScalarType(PrimitiveType);
  if (ScalarType <= 8)
  {
    if (ScalarType == 1)
    {
      return 2;
    }
    else
    {
      if (ScalarType != 5)
        goto LABEL_13;
      return 1;
    }
  }
  else
  {
    switch(ScalarType)
    {
      case 9:
        return 0;
      case 36:
        return 4;
      case 62:
        return 3;
      default:
LABEL_13:
        abort();
    }
  }
}

char *glpTypeFromScalarTypeAndComponentCount(unsigned int a1, int a2)
{
  unsigned int VectorType;

  if (a1 >= 5)
    abort();
  VectorType = glpGetVectorType(dword_22A97EDC0[a1], a2);
  return glpGetPrimitiveType(VectorType);
}

void glpPackConstants(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  __int128 *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  size_t v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t *v33;
  uint64_t v34;
  unint64_t v35;
  __int128 v36;
  uint64_t v37;
  double v38;
  __int128 v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t *v43;
  __int128 *v44;
  _QWORD *v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  __int128 v50;
  __int128 v51;
  _OWORD v52[2];
  uint64_t v53;
  uint64_t v54;

  v42 = a3;
  v45 = a1;
  v54 = *MEMORY[0x24BDAC8D0];
  MEMORY[0x24BDAC7A8](a1);
  v5 = &v39 - v4;
  if (*(_DWORD *)(v6 + 32))
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    do
    {
      v10 = *(_QWORD *)(a2 + 40);
      v11 = *(_QWORD *)(v10 + v7);
      if (v11)
      {
        v50 = *(_OWORD *)(v10 + v7 + 8);
        v12 = (unsigned int *)v50;
        v13 = glpABIGetTypeSize(0, v50, 0);
        if (glpTypeSizeGetSize(v13) == 1 && !glpTypeGetKind(v12))
        {
          v5[v9++] = v50;
        }
        else
        {
          v14 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v45[1])(*v45, 176, "Constant Pack Record (direct)");
          *(_DWORD *)v14 = 0;
          *(_BYTE *)(v14 + 8) = 0;
          glpPointerHashPut(v42, v11, v14, v15);
        }
      }
      ++v8;
      v7 += 32;
    }
    while (v8 < *(unsigned int *)(a2 + 32));
  }
  else
  {
    v9 = 0;
  }
  v40 = v9;
  qsort_b(v5, v9, 0x10uLL, &__block_literal_global_1);
  v53 = 0;
  memset(v52, 0, sizeof(v52));
  if (v9)
  {
    v16 = 0;
    v39 = xmmword_22A97EA20;
    v44 = v5;
    do
    {
      v47 = v16;
      v17 = glpScalarTypeFromGLPType(*(_QWORD *)&v5[v16]);
      v18 = countComponents(*(_QWORD *)&v5[v16]);
      v19 = v18;
      v41 = v17;
      v43 = (uint64_t *)v52 + v17;
      v20 = (uint64_t *)*v43;
      v51 = v39;
      v46 = v20;
      if (v20)
      {
        v21 = (uint64_t)v46;
        *(_QWORD *)&v50 = (char *)&v44[v47] + 8;
        v48 = v18;
        v49 = v18;
        while (1)
        {
          v22 = *(_QWORD *)v50;
          v23 = bytesPerComponent(*(_DWORD *)(v21 + 8));
          if (!v19)
          {
            v21 = (uint64_t)v46;
            v34 = v47;
            v5 = v44;
            goto LABEL_36;
          }
          v24 = *(unsigned int *)(v21 + 12);
          if ((_DWORD)v24)
            break;
LABEL_24:
          v21 = *(_QWORD *)v21;
          v19 = v49;
          if (!v21)
            goto LABEL_25;
        }
        v25 = v23;
        v26 = 0;
        v27 = v23;
        do
        {
          v28 = 0;
          v29 = 0;
          while (memcmp((const void *)(v21 + 16 + v28), (const void *)(v22 + v25 * v26), v27))
          {
            ++v29;
            v28 += v25;
            if (v24 == v29)
              goto LABEL_24;
          }
          *((_DWORD *)&v52[-1] + v26++) = v29;
        }
        while (v26 != v48);
        v5 = v44;
        v34 = v47;
        v19 = v49;
      }
      else
      {
LABEL_25:
        v30 = v43;
        v5 = v44;
        v34 = v47;
        v31 = (uint64_t *)&v44[v47] + 1;
        v21 = (uint64_t)v43;
        while (1)
        {
          v21 = *(_QWORD *)v21;
          if (!v21)
            break;
          if (packInto(*v31, v19, v21, (uint64_t)&v51))
            goto LABEL_36;
        }
        v21 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v45[1])(*v45, 200, "Packed Constant");
        *(_QWORD *)v21 = 0;
        *(_QWORD *)(v21 + 8) = v41;
        *(_BYTE *)(v21 + 32) = 0;
        packInto(*v31, v19, v21, (uint64_t)&v51);
        v32 = v46;
        while (v32)
        {
          v33 = v32;
          v32 = (uint64_t *)*v32;
          if (!v32)
            goto LABEL_35;
        }
        v33 = v30;
LABEL_35:
        *v33 = v21;
      }
LABEL_36:
      v35 = *((_QWORD *)&v5[v34] + 1);
      v36 = v51;
      v37 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v45[1])(*v45, 176, "Constant Pack Record (packed)");
      *(_DWORD *)v37 = 1;
      *(_QWORD *)(v37 + 8) = v21;
      *(_DWORD *)(v37 + 16) = v19;
      *(_OWORD *)(v37 + 20) = v36;
      glpPointerHashPut(v42, v35, v37, v38);
      v16 = v34 + 1;
    }
    while (v16 != v40);
  }
}

uint64_t __glpPackConstants_block_invoke(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v4;

  v4 = uniqueComponentCount(a3);
  return v4 - uniqueComponentCount(a2);
}

uint64_t uniqueComponentCount(uint64_t *a1)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  _BOOL4 v13;

  v2 = glpScalarTypeFromGLPType(*a1);
  v3 = bytesPerComponent(v2);
  v4 = countComponents(*a1);
  if (!v4)
    return 0;
  v5 = 0;
  LODWORD(v6) = 0;
  v7 = v4;
  do
  {
    if (v5)
    {
      v8 = (char *)a1[1];
      if (!memcmp(&v8[v3 * v5], v8, v3))
      {
        v13 = 0;
      }
      else
      {
        v9 = v3;
        v10 = 1;
        do
        {
          v11 = v10;
          if (v5 == v10)
            break;
          v12 = memcmp(&v8[v3 * v5], &v8[v9], v3);
          v10 = v11 + 1;
          v9 += v3;
        }
        while (v12);
        v13 = v11 >= v5;
      }
    }
    else
    {
      v13 = 1;
    }
    v6 = (v6 + v13);
    ++v5;
  }
  while (v5 != v7);
  return v6;
}

uint64_t countComponents(uint64_t a1)
{
  uint64_t PrimitiveType;
  uint64_t result;

  PrimitiveType = glpPrimitiveTypeGetPrimitiveType(a1);
  result = glpPrimitiveTypeGetCategory(PrimitiveType);
  if ((_DWORD)result != 1)
    return glpPrimitiveVectorGetLength(PrimitiveType);
  return result;
}

uint64_t packInto(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t result;
  int v17;

  v7 = bytesPerComponent(*(_DWORD *)(a3 + 8));
  if (!a2)
    return 1;
  v8 = v7;
  v9 = 0;
  v17 = *(_DWORD *)(a3 + 12);
  v10 = a3 + 16;
  v11 = v7;
  while (1)
  {
    v12 = *(unsigned int *)(a3 + 12);
    if ((_DWORD)v12)
    {
      v13 = 0;
      v14 = 0;
      while (memcmp((const void *)(v10 + v13), (const void *)(a1 + v8 * v9), v11))
      {
        ++v14;
        v13 += v8;
        if (v12 == v14)
          goto LABEL_7;
      }
      goto LABEL_10;
    }
LABEL_7:
    v15 = *(int *)(a3 + 8);
    if (v15 >= 5)
      abort();
    if (v12 >= glpPrimitiveTypeGetMaxComponentsPerVec4(dword_22A97EDC0[v15]))
      break;
    memcpy((void *)(v10 + *(_DWORD *)(a3 + 12) * v8), (const void *)(a1 + v8 * v9), v11);
    LODWORD(v14) = *(_DWORD *)(a3 + 12);
    *(_DWORD *)(a3 + 12) = v14 + 1;
LABEL_10:
    *(_DWORD *)(a4 + 4 * v9++) = v14;
    if (v9 == a2)
      return 1;
  }
  result = 0;
  *(_DWORD *)(a3 + 12) = v17;
  return result;
}

uint64_t bytesPerComponent(unsigned int a1)
{
  if (a1 >= 5)
    abort();
  return glpPrimitiveTypeGetBytesPerComponent(dword_22A97EDC0[a1]);
}

uint64_t *glpAppendFlagDescription(uint64_t *result, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;

  v3 = result;
  if ((a2 & 1) != 0)
  {
    result = (uint64_t *)glpStringBufferAppendCString(result, "_ARGP");
    if ((a2 & 2) == 0)
    {
      if ((a2 & 4) != 0)
      {
LABEL_92:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_93:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "LOWP");
        if ((a2 & 8) != 0)
          goto LABEL_94;
        goto LABEL_49;
      }
LABEL_48:
      if ((a2 & 8) != 0)
      {
LABEL_94:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_95:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "MEDIUMP");
        if ((a2 & 0x10) != 0)
          goto LABEL_96;
        goto LABEL_50;
      }
LABEL_49:
      if ((a2 & 0x10) != 0)
      {
LABEL_96:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_97:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "HIGHP");
        if ((a2 & 0x20) != 0)
          goto LABEL_98;
        goto LABEL_51;
      }
LABEL_50:
      if ((a2 & 0x20) != 0)
      {
LABEL_98:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_99:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "CONST_110");
        if ((a2 & 0x40) != 0)
          goto LABEL_100;
        goto LABEL_52;
      }
LABEL_51:
      if ((a2 & 0x40) != 0)
      {
LABEL_100:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_101:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "CONST_120");
        if ((a2 & 0x80) != 0)
          goto LABEL_102;
        goto LABEL_53;
      }
LABEL_52:
      if ((a2 & 0x80) != 0)
      {
LABEL_102:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_103:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "NOT_FOLDABLE");
        if ((a2 & 0x100) != 0)
          goto LABEL_104;
        goto LABEL_54;
      }
LABEL_53:
      if ((a2 & 0x100) != 0)
      {
LABEL_104:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_105:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "READONLY");
        if ((a2 & 0x200) != 0)
          goto LABEL_106;
        goto LABEL_55;
      }
LABEL_54:
      if ((a2 & 0x200) != 0)
      {
LABEL_106:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_107:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "FOLDABLE");
        if ((a2 & 0x400) != 0)
          goto LABEL_108;
        goto LABEL_56;
      }
LABEL_55:
      if ((a2 & 0x400) != 0)
      {
LABEL_108:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_109:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "ROW_MAJOR");
        if ((a2 & 0x800) != 0)
          goto LABEL_110;
        goto LABEL_57;
      }
LABEL_56:
      if ((a2 & 0x800) != 0)
      {
LABEL_110:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_111:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "PURE_110");
        if ((a2 & 0x1000) != 0)
          goto LABEL_112;
        goto LABEL_58;
      }
LABEL_57:
      if ((a2 & 0x1000) != 0)
      {
LABEL_112:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_113:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "PURE");
        if ((a2 & 0x2000) != 0)
          goto LABEL_114;
        goto LABEL_59;
      }
LABEL_58:
      if ((a2 & 0x2000) != 0)
      {
LABEL_114:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_115:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "INLINE");
        if ((a2 & 0x4000) != 0)
          goto LABEL_116;
        goto LABEL_60;
      }
LABEL_59:
      if ((a2 & 0x4000) != 0)
      {
LABEL_116:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_117:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "PPSTREAMOP");
        if ((a2 & 0x8000) != 0)
          goto LABEL_118;
        goto LABEL_61;
      }
LABEL_60:
      if ((a2 & 0x8000) != 0)
      {
LABEL_118:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_119:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "FAIL_FUNCTION");
        if ((a2 & 0x10000) != 0)
          goto LABEL_120;
        goto LABEL_62;
      }
LABEL_61:
      if ((a2 & 0x10000) != 0)
      {
LABEL_120:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_121:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "SA_HANDLING");
        if ((a2 & 0x20000) != 0)
          goto LABEL_122;
        goto LABEL_63;
      }
LABEL_62:
      if ((a2 & 0x20000) != 0)
      {
LABEL_122:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_123:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "LINKER_GENERATED_FUNCTION");
        if ((a2 & 0x40000) != 0)
          goto LABEL_124;
        goto LABEL_64;
      }
LABEL_63:
      if ((a2 & 0x40000) != 0)
      {
LABEL_124:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_125:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "REQUIRE_OUTPUT_POINTS");
        if ((a2 & 0x80000) != 0)
          goto LABEL_126;
        goto LABEL_65;
      }
LABEL_64:
      if ((a2 & 0x80000) != 0)
      {
LABEL_126:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_127:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "SUBROUTINE_TYPEDEF");
        if ((a2 & 0x100000) != 0)
          goto LABEL_128;
        goto LABEL_66;
      }
LABEL_65:
      if ((a2 & 0x100000) != 0)
      {
LABEL_128:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_129:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "SUBROUTINE_IMPLEMENTATION");
        if ((a2 & 0x200000) != 0)
          goto LABEL_130;
        goto LABEL_67;
      }
LABEL_66:
      if ((a2 & 0x200000) != 0)
      {
LABEL_130:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_131:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "SUBROUTINE_STATIC");
        if ((a2 & 0x400000) != 0)
          goto LABEL_132;
        goto LABEL_68;
      }
LABEL_67:
      if ((a2 & 0x400000) != 0)
      {
LABEL_132:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_133:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "PARAMETER");
        if ((a2 & 0x800000) != 0)
          goto LABEL_134;
        goto LABEL_69;
      }
LABEL_68:
      if ((a2 & 0x800000) != 0)
      {
LABEL_134:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_135:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "CONST_EXPR");
        if ((a2 & 0x1000000) != 0)
          goto LABEL_136;
        goto LABEL_70;
      }
LABEL_69:
      if ((a2 & 0x1000000) != 0)
      {
LABEL_136:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_137:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "STAGE_IN_REF");
        if ((a2 & 0x2000000) != 0)
          goto LABEL_138;
        goto LABEL_71;
      }
LABEL_70:
      if ((a2 & 0x2000000) != 0)
      {
LABEL_138:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_139:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "ARG_IN");
        if ((a2 & 0x4000000) != 0)
          goto LABEL_140;
        goto LABEL_72;
      }
LABEL_71:
      if ((a2 & 0x4000000) != 0)
      {
LABEL_140:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_141:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "ARG_OUT");
        if ((a2 & 0x8000000) != 0)
          goto LABEL_142;
        goto LABEL_73;
      }
LABEL_72:
      if ((a2 & 0x8000000) != 0)
      {
LABEL_142:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_143:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "ARRAY_SIZED_BY_EXTRINSIC");
        if ((a2 & 0x10000000) != 0)
          goto LABEL_144;
        goto LABEL_74;
      }
LABEL_73:
      if ((a2 & 0x10000000) != 0)
      {
LABEL_144:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_145:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "MAY_BE_REDECLARED_INVARIANT");
        if ((a2 & 0x20000000) != 0)
          goto LABEL_146;
        goto LABEL_75;
      }
LABEL_74:
      if ((a2 & 0x20000000) != 0)
      {
LABEL_146:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_147:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "STAGE_IN");
        if ((a2 & 0x40000000) != 0)
          goto LABEL_148;
        goto LABEL_76;
      }
LABEL_75:
      if ((a2 & 0x40000000) != 0)
      {
LABEL_148:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_149:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "STAGE_OUT");
        if ((a2 & 0x80000000) != 0)
          goto LABEL_150;
        goto LABEL_77;
      }
LABEL_76:
      if ((a2 & 0x80000000) != 0)
      {
LABEL_150:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_151:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "GLOBAL");
        if ((a2 & 0x100000000) != 0)
          goto LABEL_152;
        goto LABEL_78;
      }
LABEL_77:
      if ((a2 & 0x100000000) != 0)
      {
LABEL_152:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_153:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "UNIFORM");
        if ((a2 & 0x200000000) != 0)
          goto LABEL_154;
        goto LABEL_79;
      }
LABEL_78:
      if ((a2 & 0x200000000) != 0)
      {
LABEL_154:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_155:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "SUBROUTINE_UNIFORM");
        if ((a2 & 0x400000000) != 0)
          goto LABEL_156;
        goto LABEL_80;
      }
LABEL_79:
      if ((a2 & 0x400000000) != 0)
      {
LABEL_156:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_157:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "BINDABLE");
        if ((a2 & 0x800000000) != 0)
          goto LABEL_158;
        goto LABEL_81;
      }
LABEL_80:
      if ((a2 & 0x800000000) != 0)
      {
LABEL_158:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_159:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "BUFFER_BACKED");
        if ((a2 & 0x1000000000) != 0)
          goto LABEL_160;
        goto LABEL_82;
      }
LABEL_81:
      if ((a2 & 0x1000000000) != 0)
      {
LABEL_160:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_161:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "FLAT");
        if ((a2 & 0x2000000000) != 0)
          goto LABEL_162;
        goto LABEL_83;
      }
LABEL_82:
      if ((a2 & 0x2000000000) != 0)
      {
LABEL_162:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_163:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "NOPERSPECTIVE");
        if ((a2 & 0x4000000000) != 0)
          goto LABEL_164;
        goto LABEL_84;
      }
LABEL_83:
      if ((a2 & 0x4000000000) != 0)
      {
LABEL_164:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_165:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "CENTROID");
        if ((a2 & 0x8000000000) != 0)
          goto LABEL_166;
        goto LABEL_85;
      }
LABEL_84:
      if ((a2 & 0x8000000000) != 0)
      {
LABEL_166:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_167:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "INVARIANT");
        if ((a2 & 0x10000000000) != 0)
          goto LABEL_168;
        goto LABEL_86;
      }
LABEL_85:
      if ((a2 & 0x10000000000) != 0)
      {
LABEL_168:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_169:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "INVARIANT_420");
        if ((a2 & 0x20000000000) != 0)
          goto LABEL_170;
        goto LABEL_87;
      }
LABEL_86:
      if ((a2 & 0x20000000000) != 0)
      {
LABEL_170:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_171:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "PATCH");
        if ((a2 & 0x40000000000) != 0)
          goto LABEL_172;
        goto LABEL_88;
      }
LABEL_87:
      if ((a2 & 0x40000000000) != 0)
      {
LABEL_172:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_173:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "SAMPLE");
        if ((a2 & 0x80000000000) == 0)
          return result;
LABEL_174:
        glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
        return (uint64_t *)glpStringBufferAppendCString(v3, "PRECISE");
      }
LABEL_88:
      if ((a2 & 0x80000000000) == 0)
        return result;
      goto LABEL_174;
    }
    glpStringBufferAppendFormat(v3, ",", v4, v5, v6, v7, v8, v9, v10);
LABEL_91:
    result = (uint64_t *)glpStringBufferAppendCString(v3, "_ANYP");
    if ((a2 & 4) != 0)
      goto LABEL_92;
    goto LABEL_48;
  }
  if ((a2 & 2) != 0)
    goto LABEL_91;
  if ((a2 & 4) != 0)
    goto LABEL_93;
  if ((a2 & 8) != 0)
    goto LABEL_95;
  if ((a2 & 0x10) != 0)
    goto LABEL_97;
  if ((a2 & 0x20) != 0)
    goto LABEL_99;
  if ((a2 & 0x40) != 0)
    goto LABEL_101;
  if ((a2 & 0x80) != 0)
    goto LABEL_103;
  if ((a2 & 0x100) != 0)
    goto LABEL_105;
  if ((a2 & 0x200) != 0)
    goto LABEL_107;
  if ((a2 & 0x400) != 0)
    goto LABEL_109;
  if ((a2 & 0x800) != 0)
    goto LABEL_111;
  if ((a2 & 0x1000) != 0)
    goto LABEL_113;
  if ((a2 & 0x2000) != 0)
    goto LABEL_115;
  if ((a2 & 0x4000) != 0)
    goto LABEL_117;
  if ((a2 & 0x8000) != 0)
    goto LABEL_119;
  if ((a2 & 0x10000) != 0)
    goto LABEL_121;
  if ((a2 & 0x20000) != 0)
    goto LABEL_123;
  if ((a2 & 0x40000) != 0)
    goto LABEL_125;
  if ((a2 & 0x80000) != 0)
    goto LABEL_127;
  if ((a2 & 0x100000) != 0)
    goto LABEL_129;
  if ((a2 & 0x200000) != 0)
    goto LABEL_131;
  if ((a2 & 0x400000) != 0)
    goto LABEL_133;
  if ((a2 & 0x800000) != 0)
    goto LABEL_135;
  if ((a2 & 0x1000000) != 0)
    goto LABEL_137;
  if ((a2 & 0x2000000) != 0)
    goto LABEL_139;
  if ((a2 & 0x4000000) != 0)
    goto LABEL_141;
  if ((a2 & 0x8000000) != 0)
    goto LABEL_143;
  if ((a2 & 0x10000000) != 0)
    goto LABEL_145;
  if ((a2 & 0x20000000) != 0)
    goto LABEL_147;
  if ((a2 & 0x40000000) != 0)
    goto LABEL_149;
  if ((a2 & 0x80000000) != 0)
    goto LABEL_151;
  if ((a2 & 0x100000000) != 0)
    goto LABEL_153;
  if ((a2 & 0x200000000) != 0)
    goto LABEL_155;
  if ((a2 & 0x400000000) != 0)
    goto LABEL_157;
  if ((a2 & 0x800000000) != 0)
    goto LABEL_159;
  if ((a2 & 0x1000000000) != 0)
    goto LABEL_161;
  if ((a2 & 0x2000000000) != 0)
    goto LABEL_163;
  if ((a2 & 0x4000000000) != 0)
    goto LABEL_165;
  if ((a2 & 0x8000000000) != 0)
    goto LABEL_167;
  if ((a2 & 0x10000000000) != 0)
    goto LABEL_169;
  if ((a2 & 0x20000000000) != 0)
    goto LABEL_171;
  if ((a2 & 0x40000000000) != 0)
    goto LABEL_173;
  if ((a2 & 0x80000000000) != 0)
    return (uint64_t *)glpStringBufferAppendCString(v3, "PRECISE");
  return result;
}

uint64_t glpPrecisionIndexFromSAFlags(char a1)
{
  uint64_t result;
  uint64_t v3;

  result = 0;
  v3 = a1 & 0x1F;
  if (v3 <= 7)
  {
    if (!v3)
      return result;
    if (v3 == 4)
      return 1;
LABEL_11:
    abort();
  }
  if (v3 == 8)
    return 2;
  if (v3 == 16)
    return 3;
  if (v3 != 31)
    goto LABEL_11;
  return result;
}

double glpMakeFunctionObject(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13;
  double result;

  v13 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 168, "Function Object");
  result = 0.0;
  *(_OWORD *)v13 = 0u;
  *(_OWORD *)(v13 + 16) = 0u;
  *(_OWORD *)(v13 + 32) = 0u;
  *(_OWORD *)(v13 + 48) = 0u;
  *(_QWORD *)(v13 + 160) = 0;
  *(_OWORD *)(v13 + 64) = 0u;
  *(_OWORD *)(v13 + 80) = 0u;
  *(_OWORD *)(v13 + 96) = 0u;
  *(_OWORD *)(v13 + 112) = 0u;
  *(_OWORD *)(v13 + 128) = 0u;
  *(_OWORD *)(v13 + 144) = 0u;
  *(_QWORD *)v13 = a2;
  *(_QWORD *)(v13 + 8) = a3;
  *(_QWORD *)(v13 + 24) = a4;
  *(_QWORD *)(v13 + 32) = a5;
  *(_QWORD *)(v13 + 40) = a6;
  *(_QWORD *)(v13 + 48) = a7;
  *(_DWORD *)(v13 + 160) = -1;
  *(_QWORD *)(v13 + 144) = 0;
  return result;
}

double glpMakeVariableObject(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9, uint64_t a10, uint64_t a11)
{
  uint64_t v18;
  double result;

  v18 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 160, "Variable Object");
  result = 0.0;
  *(_OWORD *)v18 = 0u;
  *(_OWORD *)(v18 + 16) = 0u;
  *(_OWORD *)(v18 + 32) = 0u;
  *(_OWORD *)(v18 + 48) = 0u;
  *(_OWORD *)(v18 + 64) = 0u;
  *(_OWORD *)(v18 + 80) = 0u;
  *(_OWORD *)(v18 + 96) = 0u;
  *(_OWORD *)(v18 + 112) = 0u;
  *(_OWORD *)(v18 + 128) = 0u;
  *(_OWORD *)(v18 + 144) = 0u;
  *(_QWORD *)v18 = a2;
  *(_QWORD *)(v18 + 8) = a3;
  *(_QWORD *)(v18 + 40) = a8;
  *(_QWORD *)(v18 + 48) = a4;
  *(_QWORD *)(v18 + 16) = a5;
  *(_QWORD *)(v18 + 24) = a6;
  *(_QWORD *)(v18 + 32) = a7;
  *(_BYTE *)(v18 + 56) = a9;
  *(_QWORD *)(v18 + 64) = a10;
  *(_QWORD *)(v18 + 72) = a11;
  return result;
}

uint64_t glpVariableObjectGetABI(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 88);
  if (v1)
    return *(unsigned int *)(v1 + 8);
  else
    return 0;
}

void *glpAppendVariableObjectDescription(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v24;

  if (!a2)
    return glpStringBufferAppendCString(a1, "(GLPVariableObject *)0");
  glpStringBufferAppendFormat(a1, "*((GLPVariableObject *)%p): ", a3, a4, a5, a6, a7, a8, a2);
  v16 = *(_QWORD *)(a2 + 48);
  if (v16)
  {
    glpAppendFlagDescription(a1, v16);
    glpStringBufferAppendCString(a1, " ");
  }
  glpDumpTypeToStringBuffer(a1, *(_QWORD *)a2, v10, v11, v12, v13, v14, v15, v24);
  return (void *)glpStringBufferAppendFormat(a1, " %.*s", v17, v18, v19, v20, v21, v22, *(_DWORD *)(a2 + 24));
}

uint64_t glpVariableObjectValidateImplicitArraySize(uint64_t a1, int a2, unsigned int a3, uint64_t **a4, __int128 *a5)
{
  unsigned int *v9;
  int v10;
  int Kind;
  uint64_t ElementType;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  __int128 v19;
  uint64_t v20;

  v9 = *(unsigned int **)a1;
  if (a2)
  {
    v10 = a2;
    do
    {
      Kind = glpTypeGetKind(v9);
      if (Kind == 3)
      {
        ElementType = glpBankTypeGetElementType((uint64_t)v9);
      }
      else
      {
        if (Kind != 2)
          abort();
        ElementType = glpArrayTypeGetElementType((uint64_t)v9);
      }
      v9 = (unsigned int *)ElementType;
      --v10;
    }
    while (v10);
  }
  if (glpArrayTypeGetMaxElementCount((uint64_t)v9) >= a3)
    return 1;
  v17 = *(_DWORD *)(a1 + 40);
  v19 = *a5;
  v20 = *((_QWORD *)a5 + 2);
  glpLogMessage(a4, 0, (uint64_t)&v19, "special unsized array '%.*s' may have at most %u elements (%u requested)", v13, v14, v15, v16, v17);
  return 0;
}

uint64_t glpVariableObjectExtendImplicitArraySize(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t **a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v9;
  unsigned int v10;
  __int128 v11;
  uint64_t v12;

  v11 = *(_OWORD *)a5;
  v12 = *(_QWORD *)(a5 + 16);
  result = glpVariableObjectValidateImplicitArraySize(a1, a2, a3, a4, &v11);
  if ((_DWORD)result)
  {
    v9 = a1 + 4 * a2;
    v10 = *(_DWORD *)(v9 + 96);
    if (v10 <= a3)
      v10 = a3;
    *(_DWORD *)(v9 + 96) = v10;
    return 1;
  }
  return result;
}

uint64_t glpGetIBVariableObjectCount(uint64_t a1, unsigned int *a2)
{
  uint64_t ElementType;
  int Kind;
  _BOOL8 v6;
  int v7;
  __int128 v9;
  uint64_t v10;

  ElementType = (uint64_t)a2;
  v10 = *MEMORY[0x24BDAC8D0];
  Kind = glpTypeGetKind(a2);
  v6 = a1 == 0x20000000 || a1 == 0x40000000;
  v9 = xmmword_22A97EA20;
  v7 = *(_DWORD *)((unint64_t)&v9 | (8 * (Kind == 3)) | (4 * v6));
  if (v7 == 1)
    return glpAggregateTypeGetElementCount(ElementType);
  if (v7 == 3)
  {
    ElementType = glpBankTypeGetElementType(ElementType);
    return glpAggregateTypeGetElementCount(ElementType);
  }
  return 1;
}

uint64_t glpMakeUnnamedInterfaceBlockObject(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, unsigned int *a6)
{
  uint64_t result;

  result = glpMakeNamedInterfaceBlockObject(a1, a2, a3, (uint64_t)"<<BUG: printing instance name of interface block without an instance name>>", 0xDFA3F2CD0000004BLL, a4, a5, a6);
  *(_BYTE *)(result + 32) = 0;
  return result;
}

uint64_t glpMakeNamedInterfaceBlockObject(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, unsigned int *a8)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t ElementType;
  int ElementCount;
  uint64_t v20;
  int Kind;
  _BOOL8 v23;
  uint64_t *StringBuffer;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  const char *v33;
  const char *v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t String;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  uint64_t v52;
  char v53;
  const char *v54;
  const char *v55;
  uint64_t BankType;
  uint64_t *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int Bank;
  int v72;
  uint64_t ElementLayout;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v84;
  char v85;
  char v86;
  uint64_t v87;
  unsigned int *v88;
  uint64_t v89;
  uint64_t v90;
  __int128 v91;
  uint64_t v92;

  v92 = *MEMORY[0x24BDAC8D0];
  v16 = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 88, "Interface Block Object");
  *(_OWORD *)v16 = 0u;
  *(_OWORD *)(v16 + 16) = 0u;
  *(_OWORD *)(v16 + 48) = 0u;
  *(_OWORD *)(v16 + 64) = 0u;
  *(_OWORD *)(v16 + 32) = 0u;
  *(_QWORD *)(v16 + 80) = 0;
  v89 = a6;
  v17 = a6 & 0x160000000;
  *(_QWORD *)v16 = a2;
  *(_QWORD *)(v16 + 8) = a3;
  *(_QWORD *)(v16 + 16) = a4;
  *(_QWORD *)(v16 + 24) = a5;
  *(_BYTE *)(v16 + 32) = 1;
  *(_QWORD *)(v16 + 40) = v17;
  v90 = v16;
  *(_QWORD *)(v16 + 64) = a8;
  if (v17 == 0x100000000)
  {
    ElementType = (uint64_t)a8;
    if (glpTypeGetKind(a8) == 3)
      ElementType = glpBankTypeGetElementType((uint64_t)a8);
    if (glpTypeGetKind(a8) == 3)
      ElementCount = glpBankTypeGetElementCount((uint64_t)a8);
    else
      ElementCount = 1;
    v20 = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 32, "Buffer Object");
    *(_OWORD *)v20 = 0u;
    *(_OWORD *)(v20 + 16) = 0u;
    *(_QWORD *)v20 = ElementType;
    *(_DWORD *)(v20 + 8) = a7;
    *(_DWORD *)(v20 + 12) = ElementCount;
    *(_QWORD *)(v90 + 80) = v20;
  }
  Kind = glpTypeGetKind(a8);
  v23 = v17 == 0x20000000 || v17 == 0x40000000;
  v91 = xmmword_22A97EA20;
  switch(*(_DWORD *)((unint64_t)&v91 | (8 * (Kind == 3)) | (4 * v23)))
  {
    case 0:
    case 2:
      StringBuffer = glpMakeStringBuffer(a1);
      v31 = (uint64_t)StringBuffer;
      if (v17 == 0x20000000)
        v32 = 105;
      else
        v32 = 111;
      if (v17 == 0x20000000)
        v33 = "in";
      else
        v33 = "out";
      if (v17 == 0x100000000)
      {
        v32 = 117;
        v34 = "uniform";
      }
      else
      {
        LOBYTE(v34) = (_BYTE)v33;
      }
      glpStringBufferAppendFormat(StringBuffer, "$ib$%c$%.*s", v25, v26, v27, v28, v29, v30, v32);
      v35 = glpMakeStringBuffer(a1);
      glpStringBufferAppendFormat(v35, "<%s %.*s>", v36, v37, v38, v39, v40, v41, (char)v34);
      *(_QWORD *)(v90 + 72) = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8, "Variable Object Array of Interface Block");
      String = glpStringBufferGetString(v31);
      v44 = v43;
      v45 = glpStringBufferGetString((uint64_t)v35);
      v47 = v46;
      v48 = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 160, "Variable Object");
      *(_OWORD *)v48 = 0u;
      *(_OWORD *)(v48 + 16) = 0u;
      *(_OWORD *)(v48 + 32) = 0u;
      *(_OWORD *)(v48 + 48) = 0u;
      *(_OWORD *)(v48 + 128) = 0u;
      *(_OWORD *)(v48 + 144) = 0u;
      *(_OWORD *)(v48 + 96) = 0u;
      *(_OWORD *)(v48 + 112) = 0u;
      *(_OWORD *)(v48 + 64) = 0u;
      *(_OWORD *)(v48 + 80) = 0u;
      *(_QWORD *)v48 = a8;
      *(_QWORD *)(v48 + 8) = 0;
      *(_QWORD *)(v48 + 40) = v47;
      *(_QWORD *)(v48 + 48) = v89 | 0x80000000;
      *(_QWORD *)(v48 + 16) = String;
      *(_QWORD *)(v48 + 24) = v44;
      *(_QWORD *)(v48 + 32) = v45;
      *(_BYTE *)(v48 + 56) = 0;
      *(_QWORD *)(v48 + 64) = 0;
      *(_QWORD *)(v48 + 72) = 0;
      **(_QWORD **)(v90 + 72) = v48;
      v49 = *(_QWORD *)(v90 + 72);
      *(_QWORD *)(*(_QWORD *)v49 + 80) = v90;
      *(_QWORD *)(*(_QWORD *)v49 + 88) = *(_QWORD *)(v90 + 80);
      break;
    case 1:
    case 3:
      v50 = (uint64_t)a8;
      if (glpTypeGetKind(a8) == 3)
        v50 = glpBankTypeGetElementType((uint64_t)a8);
      v51 = glpAggregateTypeGetElementCount(v50);
      *(_QWORD *)(v90 + 72) = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8 * v51, "Variable Object Array of Interface Block");
      if (v51)
      {
        v52 = 0;
        if (v17 == 0x20000000)
          v53 = 105;
        else
          v53 = 111;
        v54 = "out";
        if (v17 == 0x20000000)
          v54 = "in";
        if (v17 == 0x100000000)
          v53 = 117;
        v86 = v53;
        v87 = v51;
        v55 = "uniform";
        if (v17 != 0x100000000)
          LOBYTE(v55) = (_BYTE)v54;
        v85 = (char)v55;
        v88 = a8;
        v84 = v50;
        do
        {
          glpStructTypeGetFieldName(v50, v52);
          BankType = glpAggregateTypeGetElementType(v50, v52);
          v57 = glpMakeStringBuffer(a1);
          glpStringBufferAppendFormat(v57, "$ib$%c$%.*s$%.*s", v58, v59, v60, v61, v62, v63, v86);
          v64 = glpMakeStringBuffer(a1);
          glpStringBufferAppendFormat(v64, "<%s %.*s.%.*s>", v65, v66, v67, v68, v69, v70, v85);
          if (glpTypeGetKind(a8) == 3)
          {
            Bank = glpBankTypeGetBank((uint64_t)a8);
            v72 = glpBankTypeGetElementCount((uint64_t)a8);
            BankType = glpMakeBankType((uint64_t)a1, Bank, BankType, v72);
          }
          v50 = v84;
          ElementLayout = glpAggregateTypeGetElementLayout(v84, v52);
          v74 = glpAggregateTypeGetElementFlags(v84, v52) | v89 | 0x80000000;
          v75 = glpStringBufferGetString((uint64_t)v57);
          v77 = v76;
          v78 = glpStringBufferGetString((uint64_t)v64);
          v80 = v79;
          v81 = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 160, "Variable Object");
          *(_OWORD *)v81 = 0u;
          *(_OWORD *)(v81 + 16) = 0u;
          *(_OWORD *)(v81 + 32) = 0u;
          *(_OWORD *)(v81 + 48) = 0u;
          *(_OWORD *)(v81 + 128) = 0u;
          *(_OWORD *)(v81 + 144) = 0u;
          *(_OWORD *)(v81 + 96) = 0u;
          *(_OWORD *)(v81 + 112) = 0u;
          *(_OWORD *)(v81 + 64) = 0u;
          *(_OWORD *)(v81 + 80) = 0u;
          *(_QWORD *)v81 = BankType;
          *(_QWORD *)(v81 + 8) = ElementLayout;
          *(_QWORD *)(v81 + 40) = v80;
          *(_QWORD *)(v81 + 48) = v74;
          *(_QWORD *)(v81 + 16) = v75;
          *(_QWORD *)(v81 + 24) = v77;
          *(_QWORD *)(v81 + 32) = v78;
          *(_BYTE *)(v81 + 56) = 0;
          *(_QWORD *)(v81 + 64) = 0;
          *(_QWORD *)(v81 + 72) = 0;
          *(_QWORD *)(*(_QWORD *)(v90 + 72) + 8 * v52) = v81;
          v82 = *(_QWORD *)(v90 + 72);
          *(_QWORD *)(*(_QWORD *)(v82 + 8 * v52) + 80) = v90;
          *(_QWORD *)(*(_QWORD *)(v82 + 8 * v52++) + 88) = *(_QWORD *)(v90 + 80);
          a8 = v88;
        }
        while (v87 != v52);
      }
      break;
    default:
      return v90;
  }
  return v90;
}

double glpMakeBufferObject(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v7;
  double result;

  v7 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 32, "Buffer Object");
  result = 0.0;
  *(_OWORD *)v7 = 0u;
  *(_OWORD *)(v7 + 16) = 0u;
  *(_QWORD *)v7 = a2;
  *(_DWORD *)(v7 + 8) = a3;
  *(_DWORD *)(v7 + 12) = a4;
  return result;
}

uint64_t glpGetStructTypeFromIBType(unsigned int *a1)
{
  if (glpTypeGetKind(a1) == 3)
    return glpBankTypeGetElementType((uint64_t)a1);
  else
    return (uint64_t)a1;
}

uint64_t glpInterfaceBlockObjectGetRepresentation(uint64_t a1)
{
  uint64_t v1;
  int Kind;
  _BOOL8 v4;
  __int128 v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 40);
  Kind = glpTypeGetKind(*(unsigned int **)(a1 + 64));
  v4 = v1 == 0x20000000 || v1 == 0x40000000;
  v6 = xmmword_22A97EA20;
  return *(unsigned int *)((unint64_t)&v6 | (8 * (Kind == 3)) | (4 * v4));
}

uint64_t glpInterfaceBlockObjectGetVariableObjectCount(uint64_t a1)
{
  return glpGetIBVariableObjectCount(*(_QWORD *)(a1 + 40), *(unsigned int **)(a1 + 64));
}

uint64_t glpBufferObjectGetMinimumBufferSize(uint64_t a1)
{
  return glpABIGetMinimumBufferBytesForType(*(_DWORD *)(a1 + 8), *(_QWORD *)a1, 0);
}

double glpMakeOffsetObject(uint64_t a1)
{
  uint64_t v1;
  double result;

  v1 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 32, "Offset Object");
  result = 0.0;
  *(_OWORD *)v1 = 0u;
  *(_OWORD *)(v1 + 16) = 0u;
  *(_DWORD *)(v1 + 24) = -1;
  return result;
}

uint64_t glpPopulatePrecisionWidths(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  if (result > 9)
    abort();
  if (((1 << result) & 0x3BE) != 0)
  {
    a2[1] = -1;
    a2[2] = -1;
    *a2 = -1;
  }
  else
  {
    if ((_DWORD)result)
    {
      *(_OWORD *)a2 = xmmword_22A97EDE0;
      v2 = 0x2000000010;
    }
    else
    {
      *(_OWORD *)a2 = xmmword_22A97EDF0;
      v2 = 0x110000000BLL;
    }
    a2[2] = v2;
  }
  return result;
}

uint64_t glpGLSLVersionFromInt(int a1)
{
  if (a1 > 149)
  {
    if (a1 <= 329)
    {
      if (a1 == 150)
        return 5;
      if (a1 == 300)
        return 6;
    }
    else
    {
      switch(a1)
      {
        case 330:
          return 7;
        case 400:
          return 8;
        case 410:
          return 9;
      }
    }
  }
  else if (a1 <= 119)
  {
    if (a1 == 100)
      return 0;
    if (a1 == 110)
      return 1;
  }
  else
  {
    switch(a1)
    {
      case 120:
        return 2;
      case 130:
        return 3;
      case 140:
        return 4;
    }
  }
  return 10;
}

uint64_t glpGLSLVersionToInt(unsigned int a1)
{
  if (a1 >= 0xA)
    abort();
  return dword_22A97EE70[a1];
}

uint64_t glpGLSLVersionGetDefault(uint64_t a1, int a2)
{
  unsigned int v2;

  if ((a2 - 1) > 3)
    v2 = 10;
  else
    v2 = dword_22A97EEF0[a2 - 1];
  if (!a2)
    v2 = 1;
  if (a2 == 1)
    return 4;
  else
    return v2;
}

BOOL glpGLSLVersionAllowed(uint64_t a1, int a2)
{
  int GLProfile;
  _BOOL8 result;

  GLProfile = glpCompilerGetGLProfile(a1);
  result = 0;
  switch(a2)
  {
    case 0:
      return GLProfile == 1 || (GLProfile - 3) < 2;
    case 1:
    case 2:
      return GLProfile == 0;
    case 3:
      return result;
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
      return GLProfile == 1;
    case 6:
      return GLProfile == 4;
    default:
      abort();
  }
}

uint64_t glpGLSLVersionRequired(uint64_t a1, unsigned int a2)
{
  if (a2 >= 0xA)
    abort();
  return dword_22A97EE98[a2];
}

uint64_t glpBankForInputsInLanguage(unsigned int a1)
{
  if (a1 >= 5)
    abort();
  return dword_22A97EEC0[a1];
}

uint64_t glpBankForOutputsInLanguage(unsigned int a1)
{
  if (a1 >= 5)
    abort();
  return dword_22A97EED4[a1];
}

uint64_t glpExtensionFromString(char *__s2)
{
  uint64_t result;

  result = strcmp("GL_OES_standard_derivatives", __s2);
  if ((_DWORD)result)
  {
    if (!strcmp("GL_EXT_separate_shader_objects", __s2))
    {
      return 1;
    }
    else if (!strcmp("GL_EXT_shader_framebuffer_fetch", __s2))
    {
      return 2;
    }
    else if (!strcmp("GL_EXT_shader_texture_lod", __s2))
    {
      return 3;
    }
    else if (!strcmp("GL_EXT_shadow_samplers", __s2))
    {
      return 4;
    }
    else if (!strcmp("GL_EXT_draw_instanced", __s2))
    {
      return 5;
    }
    else if (!strcmp("GL_APPLE_ES2_extension_testing_compatibility_extension_that_shouldnt_exist", __s2))
    {
      return 6;
    }
    else if (!strcmp("GL_APPLE_clip_distance", __s2))
    {
      return 7;
    }
    else if (!strcmp("GL_ARB_draw_buffers", __s2))
    {
      return 8;
    }
    else if (!strcmp("GL_ARB_draw_instanced", __s2))
    {
      return 9;
    }
    else if (!strcmp("GL_ARB_shader_texture_lod", __s2))
    {
      return 10;
    }
    else if (!strcmp("GL_ARB_texture_rectangle", __s2))
    {
      return 11;
    }
    else if (!strcmp("GL_EXT_bindable_uniform", __s2))
    {
      return 12;
    }
    else if (!strcmp("GL_EXT_geometry_shader4", __s2))
    {
      return 13;
    }
    else if (!strcmp("GL_EXT_gpu_shader4", __s2))
    {
      return 14;
    }
    else if (!strcmp("GL_EXT_texture_array", __s2))
    {
      return 15;
    }
    else if (!strcmp("GL_APPLE_vertex_point_size", __s2))
    {
      return 16;
    }
    else if (!strcmp("GL_ARB_explicit_attrib_location", __s2))
    {
      return 17;
    }
    else if (!strcmp("GL_ARB_gpu_shader_fp64", __s2))
    {
      return 18;
    }
    else if (!strcmp("GL_ARB_gpu_shader5", __s2))
    {
      return 19;
    }
    else if (!strcmp("GL_ARB_sample_shading", __s2))
    {
      return 20;
    }
    else if (!strcmp("GL_ARB_separate_shader_objects", __s2))
    {
      return 21;
    }
    else if (!strcmp("GL_ARB_shader_bit_encoding", __s2))
    {
      return 22;
    }
    else if (!strcmp("GL_ARB_shader_precision", __s2))
    {
      return 23;
    }
    else if (!strcmp("GL_ARB_shader_subroutine", __s2))
    {
      return 24;
    }
    else if (!strcmp("GL_ARB_shading_language_include", __s2))
    {
      return 25;
    }
    else if (!strcmp("GL_ARB_tessellation_shader", __s2))
    {
      return 26;
    }
    else if (!strcmp("GL_ARB_texture_cube_map_array", __s2))
    {
      return 27;
    }
    else if (!strcmp("GL_ARB_texture_gather", __s2))
    {
      return 28;
    }
    else if (!strcmp("GL_ARB_texture_multisample", __s2))
    {
      return 29;
    }
    else if (!strcmp("GL_ARB_texture_query_lod", __s2))
    {
      return 30;
    }
    else if (!strcmp("GL_ARB_vertex_attrib_64bit", __s2))
    {
      return 31;
    }
    else if (!strcmp("GL_ARB_viewport_array", __s2))
    {
      return 32;
    }
    else if (!strcmp("GL_APPLE_shader_draw_parameters_draw_id", __s2))
    {
      return 33;
    }
    else if (!strcmp("GL_APPLE_bad_sl_glsl_usage", __s2))
    {
      return 34;
    }
    else if (!strcmp("GL_APPLE_special_ops", __s2))
    {
      return 35;
    }
    else if (!strcmp("GL_APPLE_sa_assertions", __s2))
    {
      return 36;
    }
    else if (!strcmp("GL_APPLE_fail_mixed_int_uint", __s2))
    {
      return 37;
    }
    else
    {
      return 38;
    }
  }
  return result;
}

char *glpExtensionToString(unsigned int a1)
{
  if (a1 >= 0x26)
    abort();
  return off_24F4AFF30[a1];
}

uint64_t glpExtensionAllowed(uint64_t a1, int a2)
{
  int GLProfile;
  uint64_t NameTable;
  unsigned int GLSLVersion;
  uint64_t result;
  BOOL v8;
  _BOOL4 v10;

  GLProfile = glpCompilerGetGLProfile(a1);
  NameTable = glpCompilerGetNameTable(a1);
  GLSLVersion = glpNameTableGetGLSLVersion(NameTable);
  result = 1;
  switch(a2)
  {
    case 0:
    case 3:
    case 4:
    case 5:
      v10 = GLProfile == 4 && GLSLVersion == 0;
      return GLProfile == 3 || v10;
    case 1:
    case 2:
    case 7:
      return (GLProfile - 3) < 2;
    case 6:
      v8 = GLProfile == 1 && GLSLVersion == 0;
      goto LABEL_4;
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 34:
      v8 = GLProfile == 0;
      goto LABEL_4;
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
      v8 = GLProfile == 1;
LABEL_4:
      result = v8;
      break;
    case 26:
      result = GLProfile == 1 && GLSLVersion > 4;
      break;
    case 35:
    case 36:
    case 37:
      return result;
    default:
      abort();
  }
  return result;
}

uint64_t glpExtensionAllowedAndDefault(uint64_t a1, int a2)
{
  int GLProfile;
  uint64_t NameTable;
  unsigned int GLSLVersion;
  uint64_t v7;
  int Language;
  uint64_t result;
  BOOL v10;
  _BOOL4 v11;

  GLProfile = glpCompilerGetGLProfile(a1);
  NameTable = glpCompilerGetNameTable(a1);
  GLSLVersion = glpNameTableGetGLSLVersion(NameTable);
  v7 = glpCompilerGetNameTable(a1);
  Language = glpNameTableGetLanguage(v7);
  result = 0;
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 9:
    case 10:
    case 12:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 35:
    case 36:
      return result;
    case 8:
    case 11:
      v10 = GLProfile == 0;
      goto LABEL_6;
    case 13:
      if (GLProfile)
        v10 = 0;
      else
        v10 = Language == 3;
LABEL_6:
      result = v10;
      break;
    case 26:
      v11 = (Language - 1) < 2;
      if (GLSLVersion < 5)
        v11 = 0;
      result = GLProfile == 1 && v11;
      break;
    case 34:
      if (GLProfile)
        result = 0;
      else
        result = glpCompilerGetIOSVersion(a1) >> 31;
      break;
    case 37:
      result = GLSLVersion < 8;
      break;
    default:
      abort();
  }
  return result;
}

char *glpLanguageToString(unsigned int a1)
{
  if (a1 >= 5)
    abort();
  return off_24F4B0060[a1];
}

uint64_t glpFixInterpolateAt(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t PointerHash;
  double v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t i;
  unint64_t *v13;

  PointerHash = glpMakePointerHash(a1);
  v10 = *(unsigned int *)(a3 + 32);
  if ((_DWORD)v10)
  {
    v11 = 0;
    for (i = 0; i < v10; ++i)
    {
      v13 = *(unint64_t **)(*(_QWORD *)(a3 + 40) + v11);
      if (v13)
      {
        glpPointerHashPut(PointerHash, *v13, (uint64_t)v13, v9);
        v10 = *(unsigned int *)(a3 + 32);
      }
      v11 += 32;
    }
  }
  return _fixInterpolateAt((uint64_t)a1, PointerHash, a4, a2);
}

uint64_t _fixInterpolateAt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  unsigned int v8;
  uint64_t Child;

  if (a4)
  {
    v7 = result;
    if (glpASTNodeGetChildCount(a4))
    {
      v8 = 0;
      do
      {
        Child = glpASTNodeGetChild(a4, v8);
        _fixInterpolateAt(v7, a2, a3, Child);
        ++v8;
      }
      while (v8 < glpASTNodeGetChildCount(a4));
    }
    result = glpASTNodeGetKind(a4);
    if ((_DWORD)result == 84)
      return _fixInterpolateAtInPPStreamOp(v7, a2, a3, a4);
  }
  return result;
}

uint64_t _fixInterpolateAtInPPStreamOp(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v9;
  unint64_t VariableExtra;
  uint64_t v11;
  uint64_t Offset;
  uint64_t v13;
  uint64_t OffsetExpr;
  uint64_t v15;
  uint64_t SaType;
  unsigned int *Value;
  unsigned int Swizzle;
  uint64_t v19;
  uint64_t *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int Swizzle_0;
  uint64_t OffsetNode;
  uint64_t v33;
  int PrimitiveType;
  uint64_t v35;
  uint64_t VariableName;
  uint64_t v37;
  uint64_t v38;
  uint64_t Extra;
  uint64_t LValueNode;
  char *v41;
  uint64_t v42;
  __n128 v43;
  __n128 v44;

  result = glpPPStreamOpNodeGetOpcode(a4);
  if ((result - 167) <= 2)
  {
    v9 = glpCallNodeGetArg(a4, 0);
    VariableExtra = glpLValueNodeGetVariableExtra(v9);
    v11 = glpPointerHashGet(a2, VariableExtra);
    glpASTNodeGetSaType(v9);
    Offset = glpDerefNodeGetOffset(v9);
    if (Offset)
    {
      v13 = Offset;
      OffsetExpr = glpOffsetNodeGetOffsetExpr(Offset);
      v15 = OffsetExpr;
      if (OffsetExpr)
      {
        SaType = glpASTNodeGetSaType(OffsetExpr);
        Value = (unsigned int *)glpConstantNodeGetValue(v15);
        LODWORD(v15) = glpValueGetAsSize(SaType, Value);
      }
      Swizzle = glpOffsetNodeGetSwizzle(v13);
      v19 = a1;
      v20 = (uint64_t *)VariableExtra;
      v21 = v15;
    }
    else
    {
      v19 = a1;
      v20 = (uint64_t *)VariableExtra;
      v21 = 0;
      Swizzle = 0;
    }
    v22 = v11 + 8 * _slotInLocationForOffsetIntoUserIn(v19, v20, v21, Swizzle);
    v23 = glpIntHashGet(a3, *(_DWORD *)(v22 + 16));
    Swizzle_0 = glpMakeSwizzle_0(v23, v24, v25, v26, v27, v28, v29, v30, *(_DWORD *)(v22 + 20));
    glpASTNodeGetLocation(v9, &v44);
    OffsetNode = glpMakeOffsetNode(a1, (__int128 *)&v44);
    glpOffsetNodeSetSwizzle(OffsetNode, Swizzle_0);
    v33 = glpASTNodeGetSaType(v23);
    PrimitiveType = glpPrimitiveTypeGetPrimitiveType(v33);
    glpOffsetNodeSetPreSwizzlePrimitiveType(OffsetNode, PrimitiveType);
    glpMakeOffsetObject(a1);
    glpOffsetNodeSetExtra(OffsetNode, v35);
    glpASTNodeGetLocation(v9, &v43);
    VariableName = glpLValueNodeGetVariableName(v9);
    v38 = v37;
    Extra = glpVariableDeclarationNodeGetExtra(v23);
    LValueNode = glpMakeLValueNode(a1, &v43, VariableName, v38, Extra);
    glpDerefNodeSetOffset(LValueNode, OffsetNode);
    v41 = glpGetPrimitiveType(1u);
    glpASTNodeSetSaType(LValueNode, (uint64_t)v41);
    glpASTNodeSetSaFlags(LValueNode, 0);
    v42 = glpLValueNodeGetVariableExtra(LValueNode);
    *(_QWORD *)(v42 + 48) |= 0x1000000uLL;
    return glpCallNodeSetArg(a4, 0, LValueNode);
  }
  return result;
}

uint64_t _slotInLocationForOffsetIntoUserIn(uint64_t a1, uint64_t *a2, int a3, unsigned int a4)
{
  unsigned int v8;
  unsigned int Size;
  _DWORD *v10;
  uint64_t v11;
  int v12;
  int v13;

  v8 = glpABIGetTypeSize(0, *a2, 0);
  Size = glpTypeSizeGetSize(v8);
  v10 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 4 * Size, "Array of vec4 types for fixing interpolateAt");
  glpTypeGetAppleVec4Types((unsigned int *)*a2, v10, 1, 0, 0, 0, 0, 0, 0);
  if (a3)
  {
    v11 = 0;
    v12 = 0;
    do
    {
      if (BitSetGetEquals(a2[15], v11))
        v12 += glpPrimitiveTypeGetScalarCount(v10[v11]);
      ++v11;
    }
    while (a3 != v11);
  }
  else
  {
    v12 = 0;
  }
  if ((a4 & 7) == 1)
    v13 = (a4 >> 3) & 3;
  else
    v13 = 0;
  return (v12 + v13);
}

uint64_t glpMakeSwizzle_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  return (8 * a9) | 1u;
}

uint64_t glpGetBIArchiveData(int a1, uint8_t **a2, _DWORD *a3)
{
  uint8_t *v6;
  const char *v8;
  unint64_t size;
  Dl_info v10;

  memset(&v10, 0, sizeof(v10));
  if (dladdr(&glpGetBIArchiveData__anchor, &v10))
  {
    size = 0;
    v6 = getsectiondata((const mach_header_64 *)v10.dli_fbase, "__GLSLBUILTINS", ARCHIVE_SECTIONS[a1], &size);
    if (v6)
    {
      *a2 = v6;
      *a3 = size;
      return 1;
    }
    v8 = "getsectiondata() == NULL";
  }
  else
  {
    v8 = "dladdr() != 0";
  }
  _glpSetCrashLogMessage((uint64_t)v8);
  return 0;
}

uint64_t glpParseRecover(uint64_t result)
{
  *(_DWORD *)(result + 8) = 1;
  return result;
}

uint64_t glpInitializeExtensionBehavior(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t NameTable;

  v2 = 0;
  v3 = a1 + 616;
  do
  {
    *(_DWORD *)(v3 + 4 * v2) = 3;
    result = glpExtensionAllowedAndDefault(*(_QWORD *)(a1 + 784), v2);
    if ((_DWORD)result)
    {
      *(_DWORD *)(v3 + 4 * v2) = 1;
      NameTable = glpCompilerGetNameTable(*(_QWORD *)(a1 + 784));
      result = glpNameTableSetGLSLExtensionBehavior(NameTable, v2, 1);
    }
    ++v2;
  }
  while (v2 != 38);
  return result;
}

uint64_t glpAddExtensionDefines(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const char *v4;
  size_t v5;
  char *v6;
  uint64_t v7;
  unsigned int i;
  uint64_t result;
  char *v10;
  size_t v11;
  char *v12;
  uint64_t v13;

  v2 = 0;
  v3 = a1 + 40;
  do
  {
    v4 = glpAddExtensionDefines_builtinDefines[v2];
    v5 = strlen(v4);
    v6 = (char *)malloc_type_malloc(v5 + 14, 0x7081ABB9uLL);
    if (!v6)
LABEL_10:
      abort();
    v7 = (uint64_t)v6;
    sprintf_l(v6, 0, "#define %s 1\n", v4);
    ScanFromSimpleString(v3, v7, 1);
    ++v2;
  }
  while (v2 != 2);
  for (i = 0; i != 38; ++i)
  {
    result = glpExtensionAllowed(*(_QWORD *)(a1 + 784), i);
    if ((_DWORD)result)
    {
      v10 = glpExtensionToString(i);
      v11 = strlen(v10);
      v12 = (char *)malloc_type_malloc(v11 + 14, 0x7081ABB9uLL);
      if (!v12)
        goto LABEL_10;
      v13 = (uint64_t)v12;
      sprintf_l(v12, 0, "#define %s 1\n", v10);
      result = ScanFromSimpleString(v3, v13, 1);
    }
  }
  return result;
}

uint64_t glpInitParseContext(uint64_t *a1, uint64_t a2)
{
  _QWORD *Allocator;
  uint64_t StringHash;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;

  bzero(a1, 0x320uLL);
  *(_DWORD *)a1 = glpCompilerGetLanguage(a2);
  *((_DWORD *)a1 + 152) = 1;
  a1[98] = a2;
  Allocator = (_QWORD *)glpCompilerGetAllocator(a2);
  StringHash = glpMakeStringHash(Allocator);
  a1[4] = StringHash;
  glpStringHashPut(StringHash, "gl_DepthRangeParameters", 0x775A9C5100000017, 1, v6);
  glpStringHashPut(a1[4], "gl_FogParameters", 0x46B6471700000010, 1, v7);
  glpStringHashPut(a1[4], "gl_LightSourceParameters", 0xBE176FAB00000018, 1, v8);
  glpStringHashPut(a1[4], "gl_LightModelParameters", 0xCD6CB4500000017, 1, v9);
  glpStringHashPut(a1[4], "gl_LightModelProducts", 0xC75531D000000015, 1, v10);
  glpStringHashPut(a1[4], "gl_LightProducts", 0x7CA8967F00000010, 1, v11);
  glpStringHashPut(a1[4], "gl_MaterialParameters", 0xAE967D6C00000015, 1, v12);
  glpStringHashPut(a1[4], "gl_PointParameters", 0x3E31F0AB00000012, 1, v13);
  a1[9] = (uint64_t)a1;
  glpLexerNew((uint64_t)a1);
  return glpInitPreprocessor((uint64_t)(a1 + 5), 0, 0);
}

uint64_t glpFinalizeParseContext(uint64_t a1)
{
  glpFinalizePreprocessor(a1 + 40);
  return glpLexerFree(a1);
}

_QWORD *glpMakeLayoutObject(uint64_t a1)
{
  _QWORD *result;

  result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 16, "Layout Object");
  *result = 0;
  result[1] = 0;
  return result;
}

uint64_t *glpLayoutObjectFind(uint64_t *result, int a2)
{
  do
    result = (uint64_t *)*result;
  while (result && *((_DWORD *)result + 2) != a2);
  return result;
}

_QWORD *glpCopyLayoutObject(_QWORD *a1, _QWORD **a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;

  if (!a2)
    return 0;
  v4 = (_QWORD *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 16, "Layout Object");
  *v4 = 0;
  v4[1] = 0;
  v5 = *a2;
  if (*a2)
  {
    do
    {
      v6 = (_QWORD *)*v5;
      v7 = (_QWORD *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 24, "Layout Pair (copy)");
      *v7 = 0;
      v7[1] = v5[1];
      v7[2] = v5[2];
      *v7 = 0;
      v8 = (_QWORD *)v4[1];
      if (!v8)
        v8 = v4;
      *v8 = v7;
      v4[1] = v7;
      v5 = v6;
    }
    while (v6);
  }
  return v4;
}

uint64_t glpDestroyLayoutObject(uint64_t result, _QWORD **a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;

  if (a2)
  {
    v3 = (_QWORD *)result;
    v4 = *a2;
    if (v4)
    {
      do
      {
        v5 = (_QWORD *)*v4;
        ((void (*)(_QWORD))v3[3])(*v3);
        v4 = v5;
      }
      while (v5);
    }
    return ((uint64_t (*)(_QWORD, _QWORD **))v3[3])(*v3, a2);
  }
  return result;
}

uint64_t glpLayoutObjectAppend(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, _QWORD *a6, int a7)
{
  uint64_t v13;
  __int128 v15;
  uint64_t v16;

  v13 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 24, "Layout Pair (no value)");
  *(_DWORD *)(v13 + 8) = a7;
  *(_DWORD *)(v13 + 12) = 0;
  v15 = *(_OWORD *)a3;
  v16 = *(_QWORD *)(a3 + 16);
  return addPair(a2, &v15, a4, a5, a6, v13);
}

uint64_t addPair(uint64_t a1, __int128 *a2, unsigned int a3, uint64_t a4, _QWORD *a5, uint64_t a6)
{
  int v12;
  int v13;
  int v14;
  char v15;
  uint64_t **InfoLog;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  _QWORD *v26;
  int v27;
  _QWORD *v28;
  int v29;
  int v30;
  BOOL v31;
  int v32;
  _QWORD *v34;
  _QWORD *v35;
  _QWORD *v36;
  _QWORD *v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t **v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t **v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t NameTable;
  int Language;
  unsigned int GLSLVersion;
  int v57;
  unsigned int v58;
  char v59;
  uint64_t **v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t **v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t **v71;
  char v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  BOOL v77;
  int v78;
  uint64_t v79;
  unsigned int v80;
  unsigned int v81;
  _QWORD *v82;
  uint64_t **v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  char v90;
  uint64_t v91;
  unsigned int v92;
  uint64_t v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  __int128 v102;
  uint64_t v103;

  v94 = *a2;
  v98 = *((_QWORD *)a2 + 2);
  v12 = *(_DWORD *)(a6 + 8);
  v13 = glpLayoutQualifierValueBehavior(v12);
  v93 = a6;
  v14 = *(_DWORD *)(a6 + 12);
  if (!v13)
  {
    if (!v14)
      goto LABEL_9;
    if (a1)
    {
      v15 = glpLayoutQualifierToString(v12);
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      v102 = v94;
      v103 = v98;
      glpLogMessage(InfoLog, 0, (uint64_t)&v102, "Identifier '%s' in layout must not have a value", v17, v18, v19, v20, v15);
    }
    return 0;
  }
  if (v13 == 1)
  {
    if (v14 == 1)
      goto LABEL_9;
    if (a1)
    {
      v59 = glpLayoutQualifierToString(v12);
      v60 = (uint64_t **)glpCompilerGetInfoLog(a1);
      v102 = v94;
      v103 = v98;
      glpLogMessage(v60, 0, (uint64_t)&v102, "Identifier '%s' in layout must have a value", v61, v62, v63, v64, v59);
    }
    return 0;
  }
  if ((v13 - 2) < 2)
LABEL_4:
    abort();
LABEL_9:
  v92 = a3;
  v91 = a4;
  v21 = a1;
  v95 = *a2;
  v99 = *((_QWORD *)a2 + 2);
  v22 = *(_DWORD *)(v93 + 8);
  v23 = glpLayoutQualifierValueBehavior(v22);
  v24 = glpLayoutQualifierMutexGroup(v22);
  v25 = glpLayoutMutexGroupBehavior(v24);
  v26 = (_QWORD *)*a5;
  if (*a5)
  {
    v27 = v25;
    while (1)
    {
      v28 = v26;
      v26 = (_QWORD *)*v26;
      v29 = *((_DWORD *)v28 + 2);
      v30 = glpLayoutQualifierMutexGroup(v29);
      if (v27)
        v31 = v24 == v30;
      else
        v31 = 0;
      v32 = v31;
      if (v22 != v29 && v32 == 0)
        goto LABEL_39;
      if (v23 == 1)
      {
        if (*(_DWORD *)(v93 + 16) != *((_DWORD *)v28 + 4))
        {
          if (v21)
          {
            v65 = (uint64_t **)glpCompilerGetInfoLog(v21);
            v66 = glpLayoutQualifierToString(v22);
            v102 = v95;
            v103 = v99;
            glpLogMessage(v65, 0, (uint64_t)&v102, "New value for layout '%s' ('%d') does not match previous declaration ('%d')", v67, v68, v69, v70, v66);
          }
          return 0;
        }
      }
      else if ((v23 - 2) < 2)
      {
        goto LABEL_4;
      }
      if (v27 != 2)
      {
        if (v27 == 1)
        {
          v34 = 0;
          v35 = a5;
          while (1)
          {
            v36 = v34;
            v34 = (_QWORD *)*v35;
            if (!*v35)
              break;
            v35 = (_QWORD *)*v35;
            if (*((_DWORD *)v34 + 2) == v29)
              goto LABEL_35;
          }
        }
        goto LABEL_39;
      }
      if (v22 != v29)
      {
        if (v21)
        {
          v71 = (uint64_t **)glpCompilerGetInfoLog(v21);
          v72 = glpLayoutMutexGroupToString(v24);
          glpLayoutQualifierToString(v22);
          glpLayoutQualifierToString(v29);
          v102 = v95;
          v103 = v99;
          glpLogMessage(v71, 0, (uint64_t)&v102, "New %s layout '%s' does not match previous declaration ('%s')", v73, v74, v75, v76, v72);
        }
        return 0;
      }
      v34 = 0;
      v37 = a5;
      do
      {
        v36 = v34;
        v34 = (_QWORD *)*v37;
        if (!*v37)
          goto LABEL_39;
        v37 = (_QWORD *)*v37;
      }
      while (*((_DWORD *)v34 + 2) != v22);
LABEL_35:
      v38 = *v34;
      if (v36)
      {
        *v36 = v38;
        if (v34 == (_QWORD *)a5[1])
          goto LABEL_42;
LABEL_39:
        if (!v26)
          break;
      }
      else
      {
        *a5 = v38;
        if (v34 != (_QWORD *)a5[1])
          goto LABEL_39;
        v36 = 0;
LABEL_42:
        a5[1] = v36;
        if (!v26)
          break;
      }
    }
  }
  v96 = *a2;
  v100 = *((_QWORD *)a2 + 2);
  v39 = *(_DWORD *)(v93 + 8);
  if (v39 == 9)
  {
    v40 = v21;
    v41 = v92;
    if (*(_DWORD *)(v93 + 16))
    {
      if (v40)
      {
        v48 = (uint64_t **)glpCompilerGetInfoLog(v40);
        v49 = *(_DWORD *)(v93 + 16);
        v102 = v96;
        v103 = v100;
        glpLogMessage(v48, 0, (uint64_t)&v102, "layout(stream=%d) value must be greater than or equal to zero and may not exceed (%u)", v50, v51, v52, v53, v49);
      }
      return 0;
    }
  }
  else
  {
    v40 = v21;
    v41 = v92;
    if (v39 == 18 && (*(_DWORD *)(v93 + 16) - 33) <= 0xFFFFFFDF)
    {
      if (v40)
      {
        v42 = (uint64_t **)glpCompilerGetInfoLog(v40);
        v43 = *(_DWORD *)(v93 + 16);
        v102 = v96;
        v103 = v100;
        glpLogMessage(v42, 0, (uint64_t)&v102, "layout(vertices=%d) value must be greater than zero and may not exceed gl_MaxPatchVertices (%u)", v44, v45, v46, v47, v43);
      }
      return 0;
    }
  }
  v97 = *a2;
  v101 = *((_QWORD *)a2 + 2);
  if (!v40 || !v41)
    goto LABEL_160;
  NameTable = glpCompilerGetNameTable(v40);
  Language = glpNameTableGetLanguage(NameTable);
  GLSLVersion = glpNameTableGetGLSLVersion(NameTable);
  v57 = *(_DWORD *)(v93 + 8);
  v58 = GLSLVersion;
  switch(v57)
  {
    case 0:
      v77 = v41 == 2 && Language == 3;
      v78 = !v77;
      if (!v77 || (v91 & 0x20000000) != 0)
      {
        if (((v78 ^ 1) & (v91 >> 29) & 1) == 0)
          goto LABEL_166;
      }
      else if ((v91 & 0x40000000) == 0)
      {
        goto LABEL_166;
      }
      goto LABEL_160;
    case 1:
    case 2:
    case 4:
      if ((v91 & 0x20000000) == 0)
        goto LABEL_166;
      goto LABEL_77;
    case 3:
      if (v41 == 2 && (v91 & 0x20000000) != 0 && Language == 3)
        goto LABEL_160;
      if (v41 != 2 || (v91 & 0x20000000) == 0)
        goto LABEL_166;
      goto LABEL_72;
    case 5:
      if ((v91 & 0x20000000) == 0 || v41 != 2)
        goto LABEL_166;
      goto LABEL_118;
    case 6:
    case 7:
    case 8:
      if ((v91 & 0x40000000) == 0)
        goto LABEL_166;
LABEL_77:
      if (v41 != 2 || Language != 3)
        goto LABEL_166;
      goto LABEL_160;
    case 9:
      if ((v91 & 0x40000000) == 0 || (v41 & 0xFFFFFFF7) != 1)
        goto LABEL_166;
LABEL_118:
      if (Language != 3)
        goto LABEL_166;
      if (GLSLVersion > 7)
        goto LABEL_160;
      v79 = NameTable;
      v80 = 19;
      goto LABEL_138;
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
      if ((v91 & 0x20000000) == 0 || v41 != 2)
        goto LABEL_166;
LABEL_72:
      if (Language != 2)
        goto LABEL_166;
      goto LABEL_160;
    case 18:
      if ((v91 & 0x40000000) != 0 && v41 == 2 && Language == 1)
        goto LABEL_160;
      goto LABEL_166;
    case 19:
    case 20:
      if ((v91 & 0x20000000) == 0 || v41 != 1)
        goto LABEL_166;
      goto LABEL_142;
    case 21:
    case 22:
    case 23:
      if (v41 != 7 && v41 != 2)
        goto LABEL_166;
      goto LABEL_89;
    case 24:
    case 25:
      if (v41 != 7 && v41 != 2 && v41 != 9)
        goto LABEL_166;
LABEL_89:
      if ((v91 & 0x100000000) == 0)
        goto LABEL_166;
      goto LABEL_160;
    case 26:
      if (GLSLVersion > 5
        || glpNameTableIsExtensionEnabled(NameTable, 0x11u)
        || glpNameTableIsExtensionEnabled(NameTable, 0x15u)
        || glpNameTableIsExtensionEnabled(NameTable, 1u)
        || glpNameTableIsExtensionEnabled(NameTable, 0x23u))
      {
        if ((v91 & 0x20000000) == 0 || Language)
          v81 = (Language == 4) & (v91 >> 30);
        else
          v81 = 1;
        if (v58 > 8)
          goto LABEL_156;
      }
      else
      {
        v81 = 0;
      }
      if (!glpNameTableIsExtensionEnabled(NameTable, 0x15u) && !glpNameTableIsExtensionEnabled(NameTable, 1u))
        goto LABEL_158;
LABEL_156:
      if (v81)
      {
        v81 = 1;
      }
      else
      {
        if ((v91 & 0x60000000) == 0 || (v91 & 0x20000000) != 0 && !Language)
          goto LABEL_166;
        v81 = (v91 & 0x40000000) == 0 || Language != 4;
      }
LABEL_158:
      if (v41 != 1 || !v81)
      {
LABEL_166:
        v84 = (uint64_t **)glpCompilerGetInfoLog(v40);
        v102 = v97;
        v103 = v101;
        v90 = glpLayoutQualifierToString(v57);
        glpLogMessage(v84, 0, (uint64_t)&v102, "Invalid use of layout '%s'", v85, v86, v87, v88, v90);
        return 0;
      }
LABEL_160:
      *(_QWORD *)v93 = 0;
      v82 = (_QWORD *)a5[1];
      if (!v82)
        v82 = a5;
      *v82 = v93;
      a5[1] = v93;
      return 1;
    case 27:
      if ((v91 & 0x40000000) == 0 || (v41 & 0xFFFFFFF7) != 1 || Language != 4)
        goto LABEL_166;
      if (GLSLVersion > 6)
        goto LABEL_160;
      v79 = NameTable;
      v80 = 17;
LABEL_138:
      if (!glpNameTableIsExtensionEnabled(v79, v80))
        goto LABEL_166;
      goto LABEL_160;
    case 28:
    case 29:
    case 30:
    case 33:
    case 34:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 79:
    case 80:
    case 81:
    case 83:
      if ((v41 & 0xFFFFFFF7) == 1)
        goto LABEL_160;
      goto LABEL_166;
    case 31:
    case 78:
      if ((v41 & 0xFFFFFFF7) == 1 && (v91 & 0x60000000) != 0)
        goto LABEL_160;
      goto LABEL_166;
    case 32:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
      if (v41 == 4)
        goto LABEL_160;
      goto LABEL_166;
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
      if ((v41 & 0xFFFFFFF7) == 1 && (v91 & 0x20000000) != 0)
        goto LABEL_160;
      goto LABEL_166;
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
      if ((v41 & 0xFFFFFFF7) == 1 && (v91 & 0x40000000) != 0)
        goto LABEL_160;
      goto LABEL_166;
    case 77:
      if ((v41 & 0xFFFFFFF7) != 1 || (v91 & 0x40000000) == 0)
        goto LABEL_166;
LABEL_142:
      if (Language != 4)
        goto LABEL_166;
      goto LABEL_160;
    case 82:
      if (v41 == 1 || v41 == 7)
        goto LABEL_160;
      goto LABEL_166;
    case 84:
      if (v41 <= 9 && ((1 << v41) & 0x282) != 0)
        goto LABEL_160;
      goto LABEL_166;
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
      goto LABEL_160;
    case 98:
    case 99:
      if (v41 == 5)
        goto LABEL_160;
      goto LABEL_166;
    default:
      goto LABEL_166;
  }
}

uint64_t glpLayoutObjectAppendInteger(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, _QWORD *a6, int a7, int a8)
{
  _DWORD *v15;
  __int128 v17;
  uint64_t v18;

  v15 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 24, "Layout Pair (int value)");
  v15[2] = a7;
  v15[3] = 1;
  v15[4] = a8;
  v17 = *(_OWORD *)a3;
  v18 = *(_QWORD *)(a3 + 16);
  return addPair(a2, &v17, a4, a5, a6, (uint64_t)v15);
}

BOOL glpLayoutObjectAppendMany(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, _QWORD **a5)
{
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  __int128 v13;
  uint64_t v14;

  if (!a5)
    return 1;
  v9 = *a5;
  do
  {
    v10 = v9;
    if (!v9)
      break;
    v9 = (_QWORD *)*v9;
    v11 = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 24, "Layout Pair (copy)");
    *v11 = 0;
    v11[1] = v10[1];
    v11[2] = v10[2];
    v13 = *(_OWORD *)a3;
    v14 = *(_QWORD *)(a3 + 16);
  }
  while (addPair(a2, &v13, 0, 0, a4, (uint64_t)v11));
  return v10 == 0;
}

void glpLayoutObjectRemove(uint64_t a1, _QWORD *a2, int a3)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  v3 = 0;
  v4 = a2;
  while (1)
  {
    v5 = v3;
    v3 = (_QWORD *)*v4;
    if (!*v4)
      break;
    v4 = (_QWORD *)*v4;
    if (*((_DWORD *)v3 + 2) == a3)
    {
      v6 = *v3;
      if (v5)
      {
        *v5 = v6;
        if (v3 != (_QWORD *)a2[1])
          return;
      }
      else
      {
        *a2 = v6;
        if (v3 != (_QWORD *)a2[1])
          return;
        v5 = 0;
      }
      a2[1] = v5;
      return;
    }
  }
}

uint64_t *glpLayoutObjectGetGeomInOut(uint64_t *result, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  _BOOL4 v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t *v16;

  v6 = result;
  while (1)
  {
    v6 = (uint64_t *)*v6;
    if (!v6)
      break;
    if (!*((_DWORD *)v6 + 2))
    {
      if (a4)
        *a4 = 0;
      if (a5)
        *a5 = 0;
      if (a2)
        *a2 = 1;
      break;
    }
  }
  v7 = result;
  while (1)
  {
    v7 = (uint64_t *)*v7;
    if (!v7)
      break;
    if (*((_DWORD *)v7 + 2) == 1)
    {
      if (a4)
        *a4 = 1;
      if (a2)
        *a2 = 2;
      break;
    }
  }
  v8 = result;
  while (1)
  {
    v8 = (uint64_t *)*v8;
    if (!v8)
      break;
    if (*((_DWORD *)v8 + 2) == 2)
    {
      if (a4)
        *a4 = 10;
      if (a2)
        *a2 = 4;
      break;
    }
  }
  v9 = result;
  while (1)
  {
    v9 = (uint64_t *)*v9;
    if (!v9)
      break;
    if (*((_DWORD *)v9 + 2) == 3)
    {
      if (a4)
        *a4 = 4;
      if (a2)
        *a2 = 3;
      break;
    }
  }
  v10 = result;
  while (1)
  {
    v10 = (uint64_t *)*v10;
    if (!v10)
      break;
    if (*((_DWORD *)v10 + 2) == 4)
    {
      if (a4)
        *a4 = 12;
      if (a2)
        *a2 = 6;
      break;
    }
  }
  v11 = result;
  do
  {
    v11 = (uint64_t *)*v11;
    if (!v11)
    {
      v12 = a5 != 0;
      goto LABEL_45;
    }
  }
  while (*((_DWORD *)v11 + 2) != 6);
  if (a5)
  {
    *a5 = 3;
    v12 = 1;
  }
  else
  {
    v12 = 0;
  }
LABEL_45:
  v13 = result;
  while (1)
  {
    v13 = (uint64_t *)*v13;
    if (!v13)
      break;
    if (*((_DWORD *)v13 + 2) == 7)
    {
      if (v12)
        *a5 = 5;
      break;
    }
  }
  v14 = result;
  while (1)
  {
    v14 = (uint64_t *)*v14;
    if (!v14)
      break;
    if (*((_DWORD *)v14 + 2) == 8)
    {
      if (a3)
      {
        v15 = result;
        do
          v15 = (uint64_t *)*v15;
        while (v15 && *((_DWORD *)v15 + 2) != 8);
        *a3 = *((_DWORD *)v15 + 4);
      }
      break;
    }
  }
  v16 = result;
  while (1)
  {
    v16 = (uint64_t *)*v16;
    if (!v16)
      break;
    if (*((_DWORD *)v16 + 2) == 5)
    {
      if (a6)
      {
        do
          result = (uint64_t *)*result;
        while (result && *((_DWORD *)result + 2) != 5);
        *a6 = *((_DWORD *)result + 4);
      }
      return result;
    }
  }
  return result;
}

BOOL glpLayoutQualifierFromString(char *__s2, uint64_t a2, int *a3)
{
  int v6;
  _BOOL8 result;

  if (glpStringsEqual("points", 0x7B7EE50D00000006, __s2, a2))
  {
    v6 = 0;
  }
  else if (glpStringsEqual("lines", 0x12E7E8E100000005, __s2, a2))
  {
    v6 = 1;
  }
  else if (glpStringsEqual("lines_adjacency", 0xFE3C3DF0000000FLL, __s2, a2))
  {
    v6 = 2;
  }
  else if (glpStringsEqual("triangles", 0x4499ED2F00000009, __s2, a2))
  {
    v6 = 3;
  }
  else if (glpStringsEqual("triangles_adjacency", 0x4DA743600000013, __s2, a2))
  {
    v6 = 4;
  }
  else if (glpStringsEqual("invocations", 0x5D18CBDA0000000BLL, __s2, a2))
  {
    v6 = 5;
  }
  else if (glpStringsEqual("line_strip", 0xA97F411C0000000ALL, __s2, a2))
  {
    v6 = 6;
  }
  else if (glpStringsEqual("triangle_strip", 0x363FB6020000000ELL, __s2, a2))
  {
    v6 = 7;
  }
  else if (glpStringsEqual("max_vertices", 0x326FEE410000000CLL, __s2, a2))
  {
    v6 = 8;
  }
  else if (glpStringsEqual("stream", 0x799D8DE900000006, __s2, a2))
  {
    v6 = 9;
  }
  else if (glpStringsEqual("quads", 0x12E7139A00000005, __s2, a2))
  {
    v6 = 10;
  }
  else if (glpStringsEqual("isolines", 0x18196CE900000008, __s2, a2))
  {
    v6 = 11;
  }
  else if (glpStringsEqual("equal_spacing", 0x1517300C0000000DLL, __s2, a2))
  {
    v6 = 12;
  }
  else if (glpStringsEqual("fractional_even_spacing", 0xFD76F59A00000017, __s2, a2))
  {
    v6 = 13;
  }
  else if (glpStringsEqual("fractional_odd_spacing", 0x3A06069000000016, __s2, a2))
  {
    v6 = 14;
  }
  else if (glpStringsEqual("cw", 0x178500000002, __s2, a2))
  {
    v6 = 15;
  }
  else if (glpStringsEqual("ccw", 0x39B1A00000003, __s2, a2))
  {
    v6 = 16;
  }
  else if (glpStringsEqual("point_mode", 0xCFB513380000000ALL, __s2, a2))
  {
    v6 = 17;
  }
  else if (glpStringsEqual("vertices", 0x421BABD800000008, __s2, a2))
  {
    v6 = 18;
  }
  else if (glpStringsEqual("origin_upper_left", 0x77C0A8C800000011, __s2, a2))
  {
    v6 = 19;
  }
  else if (glpStringsEqual("pixel_center_integer", 0x1E02A93600000014, __s2, a2))
  {
    v6 = 20;
  }
  else if (glpStringsEqual("shared", 0x76D5503200000006, __s2, a2))
  {
    v6 = 21;
  }
  else if (glpStringsEqual("packed", 0x76DB285300000006, __s2, a2))
  {
    v6 = 22;
  }
  else if (glpStringsEqual("std140", 0xFA5994CE00000006, __s2, a2))
  {
    v6 = 23;
  }
  else if (glpStringsEqual("row_major", 0x5970B78800000009, __s2, a2))
  {
    v6 = 24;
  }
  else if (glpStringsEqual("column_major", 0xE6CB1880000000CLL, __s2, a2))
  {
    v6 = 25;
  }
  else if (glpStringsEqual("location", 0x7C6728BC00000008, __s2, a2))
  {
    v6 = 26;
  }
  else if (glpStringsEqual("index", 0x1392090200000005, __s2, a2))
  {
    v6 = 27;
  }
  else if (glpStringsEqual("$getter", 0x9A13093A00000007, __s2, a2))
  {
    v6 = 28;
  }
  else if (glpStringsEqual("$setter", 0x9A1308B500000007, __s2, a2))
  {
    v6 = 29;
  }
  else if (glpStringsEqual("$can_be_declared_invariant", 0xB61EFF3F0000001ALL, __s2, a2))
  {
    v6 = 30;
  }
  else if (glpStringsEqual("$packed_copy_in_out", 0x9F188E8400000013, __s2, a2))
  {
    v6 = 31;
  }
  else if (glpStringsEqual("$ppstreamop", 0xF8DF7DAF0000000BLL, __s2, a2))
  {
    v6 = 32;
  }
  else if (glpStringsEqual("$pp_regtype", 0x25A314FE0000000BLL, __s2, a2))
  {
    v6 = 33;
  }
  else if (glpStringsEqual("$pp_bindattrib_info_type", 0x170805C300000018, __s2, a2))
  {
    v6 = 34;
  }
  else if (glpStringsEqual("$pp_bindattrib_generic_code", 0x78942BE50000001BLL, __s2, a2))
  {
    v6 = 35;
  }
  else if (glpStringsEqual("$pp_bindattrib_generic_fill_w_0", 0x6D916CAB0000001FLL, __s2, a2))
  {
    v6 = 36;
  }
  else if (glpStringsEqual("$pp_bindattrib_generic_on_vec4", 0xC50F77F30000001ELL, __s2, a2))
  {
    v6 = 37;
  }
  else if (glpStringsEqual("$pp_bindattrib_generic_not_builtin", 0xAD81F67300000022, __s2, a2))
  {
    v6 = 38;
  }
  else if (glpStringsEqual("$pp_bindattrib_position_origin_upper_left", 0x14C4DE9900000029, __s2, a2))
  {
    v6 = 39;
  }
  else if (glpStringsEqual("$pp_bindattrib_position_pixel_center_integer", 0x6DCDB1C50000002CLL, __s2, a2))
  {
    v6 = 40;
  }
  else if (glpStringsEqual("$pp_bindattrib_color_face", 0xC788CA3E00000019, __s2, a2))
  {
    v6 = 41;
  }
  else if (glpStringsEqual("$pp_bindattrib_seccolor_face", 0x18EEFDE0000001CLL, __s2, a2))
  {
    v6 = 42;
  }
  else if (glpStringsEqual("$pp_bindattrib_clipdistance_index", 0xD5DD809500000021, __s2, a2))
  {
    v6 = 43;
  }
  else if (glpStringsEqual("$pp_bindattrib_samplemask_index", 0xEA9FD02E0000001FLL, __s2, a2))
  {
    v6 = 44;
  }
  else if (glpStringsEqual("$pp_bindattrib_fragdata_buffer", 0xDD9F66730000001ELL, __s2, a2))
  {
    v6 = 45;
  }
  else if (glpStringsEqual("$pp_bindparam_info_type", 0xE49DB01A00000017, __s2, a2))
  {
    v6 = 46;
  }
  else if (glpStringsEqual("$pp_bindparam_generic_offset", 0x69D760E40000001CLL, __s2, a2))
  {
    v6 = 47;
  }
  else if (glpStringsEqual("$pp_bindparam_generic_stride", 0x48B4EDFE0000001CLL, __s2, a2))
  {
    v6 = 48;
  }
  else if (glpStringsEqual("$pp_bindparam_generic_type", 0x981C60B80000001ALL, __s2, a2))
  {
    v6 = 49;
  }
  else if (glpStringsEqual("$pp_bindparam_light_index", 0x234A4D7300000019, __s2, a2))
  {
    v6 = 50;
  }
  else if (glpStringsEqual("$pp_bindparam_light_binding", 0x9D1E58650000001BLL, __s2, a2))
  {
    v6 = 51;
  }
  else if (glpStringsEqual("$pp_bindparam_lightprod_index", 0xC30C20DF0000001DLL, __s2, a2))
  {
    v6 = 52;
  }
  else if (glpStringsEqual("$pp_bindparam_lightprod_face", 0xDAEB02810000001CLL, __s2, a2))
  {
    v6 = 53;
  }
  else if (glpStringsEqual("$pp_bindparam_lightprod_binding", 0xB16F87D40000001FLL, __s2, a2))
  {
    v6 = 54;
  }
  else if (glpStringsEqual("$pp_bindparam_material_face", 0xE5A951780000001BLL, __s2, a2))
  {
    v6 = 55;
  }
  else if (glpStringsEqual("$pp_bindparam_material_binding", 0x4B6D3CC90000001ELL, __s2, a2))
  {
    v6 = 56;
  }
  else if (glpStringsEqual("$pp_bindparam_texgen_texunit", 0x422A65E50000001CLL, __s2, a2))
  {
    v6 = 57;
  }
  else if (glpStringsEqual("$pp_bindparam_texgen_texcoord", 0x1305E8E80000001DLL, __s2, a2))
  {
    v6 = 58;
  }
  else if (glpStringsEqual("$pp_bindparam_texenv_texunit", 0x32AFA5880000001CLL, __s2, a2))
  {
    v6 = 59;
  }
  else if (glpStringsEqual("$pp_bindparam_clipplane_index", 0x441FEC630000001DLL, __s2, a2))
  {
    v6 = 60;
  }
  else if (glpStringsEqual("$pp_bindparam_matrix_matindex", 0x9970110A0000001DLL, __s2, a2))
  {
    v6 = 61;
  }
  else if (glpStringsEqual("$pp_bindparam_matrix_transform", 0x191EDAA50000001ELL, __s2, a2))
  {
    v6 = 62;
  }
  else if (glpStringsEqual("$pp_bindparam_matrix_rowindex", 0x4A6C18900000001DLL, __s2, a2))
  {
    v6 = 63;
  }
  else if (glpStringsEqual("$pp_bindparam_matrix_binding", 0x57FC42400000001CLL, __s2, a2))
  {
    v6 = 64;
  }
  else if (glpStringsEqual("$pp_bindparam_tfbuffer_index", 0x229FAFE40000001CLL, __s2, a2))
  {
    v6 = 65;
  }
  else if (glpStringsEqual("$pp_bindparam_tfbuffer_stream", 0xA88EDAF70000001DLL, __s2, a2))
  {
    v6 = 66;
  }
  else if (glpStringsEqual("$pp_bindparam_tfbuffer_stride", 0xA9BAEE60000001DLL, __s2, a2))
  {
    v6 = 67;
  }
  else if (glpStringsEqual("$pp_bindoutput_info_type", 0xBEA893400000018, __s2, a2))
  {
    v6 = 68;
  }
  else if (glpStringsEqual("$pp_bindoutput_generic_code", 0x91B38E370000001BLL, __s2, a2))
  {
    v6 = 69;
  }
  else if (glpStringsEqual("$pp_bindoutput_generic_not_builtin", 0x5085B18500000022, __s2, a2))
  {
    v6 = 70;
  }
  else if (glpStringsEqual("$pp_bindoutput_color_face", 0xD4E5200B00000019, __s2, a2))
  {
    v6 = 71;
  }
  else if (glpStringsEqual("$pp_bindoutput_color_buffer", 0x8E57AB560000001BLL, __s2, a2))
  {
    v6 = 72;
  }
  else if (glpStringsEqual("$pp_bindoutput_color_index", 0xD19BC26F0000001ALL, __s2, a2))
  {
    v6 = 73;
  }
  else if (glpStringsEqual("$pp_bindoutput_seccolor_face", 0x89E2DB1B0000001CLL, __s2, a2))
  {
    v6 = 74;
  }
  else if (glpStringsEqual("$pp_bindoutput_clipdistance_index", 0xDC303F4100000021, __s2, a2))
  {
    v6 = 75;
  }
  else if (glpStringsEqual("$pp_bindoutput_samplemask_index", 0xB345128E0000001FLL, __s2, a2))
  {
    v6 = 76;
  }
  else if (glpStringsEqual("$pp_draw_buffers", 0xF49461A300000010, __s2, a2))
  {
    v6 = 77;
  }
  else if (glpStringsEqual("$block_slot", 0x2B007B0000000BLL, __s2, a2))
  {
    v6 = 78;
  }
  else if (glpStringsEqual("$does_not_count_as_used_component", 0xC077861000000021, __s2, a2))
  {
    v6 = 79;
  }
  else if (glpStringsEqual("$builtin_should_link_type_check", 0x982C93B50000001FLL, __s2, a2))
  {
    v6 = 80;
  }
  else if (glpStringsEqual("$redeclarable", 0x55A31D420000000DLL, __s2, a2))
  {
    v6 = 81;
  }
  else if (glpStringsEqual("$sso_redeclaration_required", 0xC04A20BA0000001BLL, __s2, a2))
  {
    v6 = 82;
  }
  else if (glpStringsEqual("$nonarray_inout", 0xF79B6A9E0000000FLL, __s2, a2))
  {
    v6 = 83;
  }
  else if (glpStringsEqual("$sized_by_extrinsic", 0xD81B12C500000013, __s2, a2))
  {
    v6 = 84;
  }
  else if (glpStringsEqual("$full_type", 0x6B590F0000000ALL, __s2, a2))
  {
    v6 = 85;
  }
  else if (glpStringsEqual("$array", 0x8539F78100000006, __s2, a2))
  {
    v6 = 86;
  }
  else if (glpStringsEqual("$element_count", 0x650004DD0000000ELL, __s2, a2))
  {
    v6 = 87;
  }
  else if (glpStringsEqual("$max_elements", 0xC73162D10000000DLL, __s2, a2))
  {
    v6 = 88;
  }
  else if (glpStringsEqual("$struct", 0x3DC8107B00000007, __s2, a2))
  {
    v6 = 89;
  }
  else if (glpStringsEqual("$indirect_const", 0xCE9154AA0000000FLL, __s2, a2))
  {
    v6 = 90;
  }
  else if (glpStringsEqual("$inline", 0x9D91D10100000007, __s2, a2))
  {
    v6 = 91;
  }
  else if (glpStringsEqual("$pure", 0x10ED079000000005, __s2, a2))
  {
    v6 = 92;
  }
  else if (glpStringsEqual("$pure110", 0x8B40482E00000008, __s2, a2))
  {
    v6 = 93;
  }
  else if (glpStringsEqual("$fail", 0x113B635200000005, __s2, a2))
  {
    v6 = 94;
  }
  else if (glpStringsEqual("$sa_handling", 0x20FBBBCD0000000CLL, __s2, a2))
  {
    v6 = 95;
  }
  else if (glpStringsEqual("$linker_generated", 0x1FE07ADD00000011, __s2, a2))
  {
    v6 = 96;
  }
  else if (glpStringsEqual("$require_output_points", 0x4B326A8300000016, __s2, a2))
  {
    v6 = 97;
  }
  else if (glpStringsEqual("$constexpr", 0xFA8DD1240000000ALL, __s2, a2))
  {
    v6 = 98;
  }
  else
  {
    result = glpStringsEqual("$stage_in_ref", 0xFB428FA60000000DLL, __s2, a2);
    if (!result)
      return result;
    v6 = 99;
  }
  *a3 = v6;
  return 1;
}

const char *glpLayoutQualifierToString(int a1)
{
  if ((a1 - 1) > 0x62)
    return "points";
  else
    return off_24F4B00B0[a1 - 1];
}

uint64_t glpLayoutQualifierValueBehavior(int a1)
{
  if ((a1 - 5) > 0x55)
    return 0;
  else
    return dword_22A97EF6C[a1 - 5];
}

uint64_t glpLayoutQualifierMutexGroup(int a1)
{
  if ((a1 - 5) > 0x5E)
    return 3;
  else
    return dword_22A97F0C4[a1 - 5];
}

const char *glpLayoutMutexGroupToString(int a1)
{
  const char *result;

  result = "buffer storage";
  switch(a1)
  {
    case 0:
      abort();
    case 2:
      result = "matrix storage";
      break;
    case 3:
      result = "primitive type";
      break;
    case 4:
      result = "winding";
      break;
    case 5:
      result = "spacing";
      break;
    case 6:
      result = "inliner mode";
      break;
    default:
      return result;
  }
  return result;
}

uint64_t glpLayoutMutexGroupBehavior(int a1)
{
  if ((a1 - 1) > 5)
    return 0;
  else
    return dword_22A97F240[a1 - 1];
}

_DWORD *glpCompileShader(_QWORD *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  size_t v10;
  void *v11;
  _DWORD *CompiledShader;
  int Language;
  uint64_t ValueHash;
  int v16;
  void *v17;
  _OWORD v18[2];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  memset(v18, 0, sizeof(v18));
  glpInitParseContext((uint64_t *)v18, (uint64_t)a1);
  *(_QWORD *)&v42 = a3;
  *((_QWORD *)&v42 + 1) = a4;
  *(_QWORD *)&v43 = a5;
  v10 = strlen(a2);
  v11 = malloc_type_malloc(v10 + 1, 0x7081ABB9uLL);
  if (!v11)
    abort();
  v17 = v11;
  strcpy((char *)v11, a2);
  v16 = strlen(a2);
  if (glpPaParseStrings((uint64_t)v18, (uint64_t *)&v17, &v16, 1, 0)
    || (v49 = glpSANode(a1, v49), v49 == -1))
  {
    glpFinalizeParseContext((uint64_t)v18);
    free(v17);
    return 0;
  }
  else
  {
    Language = glpCompilerGetLanguage((uint64_t)a1);
    CompiledShader = glpMakeCompiledShader(Language, SDWORD2(v19), 0, 0);
    ValueHash = glpCompilerGetValueHash((uint64_t)a1);
    glpSerializeAST(ValueHash, v49, (_QWORD *)CompiledShader + 2, CompiledShader + 2);
    CompiledShader[3] = glpCompilerRequiresOutputPoints((uint64_t)a1) != 0;
    free(v17);
    glpFinalizeParseContext((uint64_t)v18);
  }
  return CompiledShader;
}

void *__abort_malloc_0(size_t a1)
{
  void *result;

  result = malloc_type_malloc(a1, 0x7081ABB9uLL);
  if (!result)
    abort();
  return result;
}

_DWORD *glpMakeCompiledShader(int a1, int a2, uint64_t a3, int a4)
{
  _DWORD *result;

  result = malloc_type_malloc(0x18uLL, 0x7081ABB9uLL);
  if (!result)
    abort();
  *result = a1;
  result[1] = a2;
  *((_QWORD *)result + 2) = a3;
  result[2] = a4;
  result[3] = 0;
  return result;
}

uint64_t glpGetCompiledShaderLanguage(unsigned int *a1)
{
  return *a1;
}

uint64_t glpGetCompiledShaderVersion(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

uint64_t glpGetCompiledShaderAST(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 8);
  return *(_QWORD *)(a1 + 16);
}

uint64_t glpCompiledShaderSerializedSize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8) + 16;
}

void *glpCompiledShaderSerialize(uint64_t a1, _QWORD *a2)
{
  size_t v2;

  *a2 = *(_QWORD *)a1;
  v2 = *(unsigned int *)(a1 + 8);
  a2[1] = v2;
  return memcpy(a2 + 2, *(const void **)(a1 + 16), v2);
}

_DWORD *glpCompiledShaderDeserialize(int *a1)
{
  int v2;
  int v3;
  size_t v4;
  void *v5;
  uint64_t v6;

  v2 = *a1;
  v3 = a1[1];
  v4 = a1[2];
  v5 = malloc_type_malloc(v4, 0x7081ABB9uLL);
  if (!v5)
    abort();
  v6 = (uint64_t)v5;
  memcpy(v5, a1 + 4, v4);
  return glpMakeCompiledShader(v2, v3, v6, v4);
}

_QWORD *glpMakeLinker(int a1, int a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, __int128 *a11, uint64_t a12, uint64_t a13)
{
  _QWORD *v18;
  _QWORD *v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  _DWORD *v24;
  char *v25;
  BOOL v26;

  v18 = malloc_type_malloc(0x170uLL, 0x7081ABB9uLL);
  if (!v18)
    abort();
  v19 = v18;
  glpInitPoolAllocator(0x8000, 0x8000, v18);
  *((_DWORD *)v19 + 14) = a1;
  *((_DWORD *)v19 + 15) = a2;
  *((_DWORD *)v19 + 10) = a3;
  *((_DWORD *)v19 + 11) = a4;
  *((_DWORD *)v19 + 12) = a5;
  v19[8] = a6;
  v19[9] = a7;
  v19[10] = a8;
  v19[11] = a9;
  v20 = *a11;
  v21 = a11[2];
  *(_OWORD *)(v19 + 39) = a11[1];
  *(_OWORD *)(v19 + 41) = v21;
  *(_OWORD *)(v19 + 37) = v20;
  v19[12] = a10;
  v19[43] = 0;
  v19[44] = a13;
  v19[28] = 5;
  v19[29] = ((uint64_t (*)(_QWORD, uint64_t, const char *))v19[1])(*v19, 40, "Vector Storage (GLPTFBuffer *)");
  v19[30] = 5;
  v22 = 0;
  v19[31] = ((uint64_t (*)(_QWORD, uint64_t, const char *))v19[1])(*v19, 40, "Vector Storage (GLPTFStore *)");
  v23 = 276;
  do
  {
    v24 = (_DWORD *)((char *)v19 + v23);
    *(v24 - 5) = 0;
    *v24 = 0;
    v19[v22 + 13] = 5;
    v19[v22 + 14] = ((uint64_t (*)(_QWORD, uint64_t, const char *))v19[1])(*v19, 40, "Vector Storage (GLPCompiledShader *)");
    v23 += 4;
    v22 += 2;
  }
  while (v22 != 10);
  v25 = getenv("GL_SHADER_STYLE_GUIDE");
  if (v25)
    v26 = strcmp(v25, "0") != 0;
  else
    v26 = 0;
  *((_BYTE *)v19 + 360) = v26;
  v19[4] = a12;
  return v19;
}

void glpDestroyLinker(_QWORD *a1)
{
  uint64_t i;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t j;
  void **v7;

  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[29]);
  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[31]);
  for (i = 14; i != 24; i += 2)
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[i]);
  glpDestroyPoolAllocator((uint64_t)a1);
  v3 = a1[43];
  if (v3)
  {
    v4 = *(unsigned int *)(v3 + 32);
    if ((_DWORD)v4)
    {
      v5 = 0;
      for (j = 0; j < v4; ++j)
      {
        v7 = *(void ***)(*(_QWORD *)(v3 + 40) + v5);
        if (v7)
        {
          free(*v7);
          free(v7);
          v4 = *(unsigned int *)(v3 + 32);
        }
        v5 += 16;
      }
      v3 = a1[43];
    }
    glpDestroyIntHash(v3);
  }
  free(a1);
}

uint64_t glpLinkerGetInfoLog(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpLinkerGetGenerateDebugMetadata(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

void *glpLinkerAddShader(_QWORD *a1, unsigned int *a2)
{
  _QWORD *v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  unsigned int v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void *result;
  uint64_t v15;

  v4 = &a1[2 * *a2];
  v5 = *((_DWORD *)v4 + 26);
  v6 = *((unsigned int *)v4 + 27);
  if ((int)v6 + 1 <= v5)
  {
    v10 = (char *)v4[14];
    v13 = *((_DWORD *)v4 + 27);
  }
  else
  {
    if (v5 <= 1)
      v7 = 1;
    else
      v7 = *((_DWORD *)v4 + 26);
    v8 = 2 * v7;
    if (v8 <= (int)v6 + 1)
      v9 = v6 + 1;
    else
      v9 = v8;
    v10 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8 * v9, "Vector Storage (GLPCompiledShader *, growth)");
    v11 = (uint64_t)&a1[2 * *a2 + 13];
    memcpy(v10, *(const void **)(v11 + 8), 8 * *(unsigned int *)(v11 + 4));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[2 * *a2 + 14]);
    v12 = (uint64_t)&a1[2 * *a2 + 13];
    *(_DWORD *)v12 = v9;
    *(_QWORD *)(v12 + 8) = v10;
    v13 = *(_DWORD *)(v12 + 4);
  }
  result = memmove(&v10[8 * v6 + 8], &v10[8 * v6], 8 * (v13 - v6));
  *(_QWORD *)(a1[2 * *a2 + 14] + 8 * v6) = a2;
  v15 = (uint64_t)&a1[2 * *a2 + 13];
  ++*(_DWORD *)(v15 + 4);
  return result;
}

uint64_t glpLinkerGetMergedAST(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(a1 + 8 * a2 + 184);
}

uint64_t serialize_bindings(_QWORD *a1, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  char *v11;
  int v12;
  uint64_t result;
  int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  int v18;
  uint64_t v19;
  char *v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  uint64_t v25;
  char *v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  int v30;
  uint64_t v31;
  char *v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  int v36;
  uint64_t v37;
  char *v38;
  unsigned int v39;
  int v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t i;
  uint64_t v45;
  unsigned int *v46;
  int v47;
  char v48;
  int v49;
  uint64_t v50;
  int v51;
  int v52;
  uint64_t v53;
  char *v54;
  int v55;
  int v56;
  unsigned int v57;
  unsigned int v58;
  int v59;
  int v60;
  uint64_t v61;
  char *v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  int v66;
  uint64_t v67;
  char *v68;
  unsigned int v69;
  unsigned int v70;
  int v71;
  int v72;
  uint64_t v73;
  char *v74;
  unsigned int v75;
  unsigned int v76;
  int v77;
  int v78;
  uint64_t v79;
  char *v80;
  unsigned int v81;
  uint64_t v82;
  int v83;
  unsigned int v84;
  char v85;
  int v86;
  uint64_t v87;
  int v88;
  int v89;
  uint64_t v90;
  char *v91;
  int v92;
  int v93;
  unsigned int v94;
  unsigned int v95;
  int v96;
  int v97;
  uint64_t v98;
  char *v99;
  unsigned int v100;
  unsigned int v101;
  int v102;
  int v103;
  uint64_t v104;
  char *v105;
  unsigned int v106;
  unsigned int v107;
  int v108;
  int v109;
  uint64_t v110;
  char *v111;
  unsigned int v112;
  unsigned int v113;
  int v114;
  int v115;
  uint64_t v116;
  char *v117;
  unsigned int v118;
  uint64_t v119;
  int v120;

  v4 = *(_DWORD *)(a2 + 36);
  v5 = (char)glp_serialized_integer32_control(v4);
  v6 = *((_DWORD *)a1 + 8);
  v7 = *((unsigned int *)a1 + 9);
  v8 = v7 + 1;
  if ((int)v7 + 1 <= v6)
  {
    v11 = (char *)a1[5];
    v12 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v6 <= 1)
      v6 = 1;
    v9 = 2 * v6;
    if (v9 <= v8)
      v10 = v8;
    else
      v10 = v9;
    v11 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v10, "Vector Storage (uint8_t, growth)");
    memcpy(v11, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v10;
    a1[5] = v11;
    v12 = *((_DWORD *)a1 + 9);
  }
  result = (uint64_t)memmove(&v11[v7 + 1], &v11[v7], (v12 - v7));
  *(_BYTE *)(a1[5] + v7) = v5;
  v14 = *((_DWORD *)a1 + 9);
  v15 = v14 + 1;
  *((_DWORD *)a1 + 9) = v14 + 1;
  if ((v5 & 0x80000000) != 0)
  {
    switch((v5 >> 1) & 7)
    {
      case 0u:
        v16 = v14 + 2;
        v17 = *((_DWORD *)a1 + 8);
        if (v16 <= v17)
        {
          v20 = (char *)a1[5];
          v21 = v15;
        }
        else
        {
          if (v17 <= 1)
            v17 = 1;
          v18 = 2 * v17;
          if (v18 <= (int)v16)
            v19 = v16;
          else
            v19 = v18;
          v20 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v19, "Vector Storage (uint8_t, growth)");
          memcpy(v20, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v19;
          a1[5] = v20;
          v21 = *((_DWORD *)a1 + 9);
        }
        result = (uint64_t)memmove(&v20[v15 + 1], &v20[v15], v21 - v15);
        *(_BYTE *)(a1[5] + v15) = v4;
        v40 = 1;
        goto LABEL_47;
      case 1u:
        v34 = v14 + 3;
        v35 = *((_DWORD *)a1 + 8);
        if (v34 <= v35)
        {
          v38 = (char *)a1[5];
          v39 = v15;
        }
        else
        {
          if (v35 <= 1)
            v35 = 1;
          v36 = 2 * v35;
          if (v36 <= (int)v34)
            v37 = v34;
          else
            v37 = v36;
          v38 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v37, "Vector Storage (uint8_t, growth)");
          memcpy(v38, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v37;
          a1[5] = v38;
          v39 = *((_DWORD *)a1 + 9);
        }
        result = (uint64_t)memmove(&v38[v15 + 1], &v38[v15], v39 - v15);
        *(_WORD *)(a1[5] + v15) = v4;
        v40 = 2;
        goto LABEL_47;
      case 2u:
        v22 = v14 + 4;
        v23 = *((_DWORD *)a1 + 8);
        if (v22 <= v23)
        {
          v26 = (char *)a1[5];
          v27 = v15;
        }
        else
        {
          if (v23 <= 1)
            v23 = 1;
          v24 = 2 * v23;
          if (v24 <= (int)v22)
            v25 = v22;
          else
            v25 = v24;
          v26 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v25, "Vector Storage (uint8_t, growth)");
          memcpy(v26, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v25;
          a1[5] = v26;
          v27 = *((_DWORD *)a1 + 9);
        }
        result = (uint64_t)memmove(&v26[v15 + 1], &v26[v15], v27 - v15);
        v41 = a1[5] + v15;
        *(_BYTE *)(v41 + 2) = BYTE2(v4);
        *(_WORD *)v41 = v4;
        v40 = 3;
        goto LABEL_47;
      case 3u:
        v28 = v14 + 5;
        v29 = *((_DWORD *)a1 + 8);
        if (v28 <= v29)
        {
          v32 = (char *)a1[5];
          v33 = v15;
        }
        else
        {
          if (v29 <= 1)
            v29 = 1;
          v30 = 2 * v29;
          if (v30 <= (int)v28)
            v31 = v28;
          else
            v31 = v30;
          v32 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v31, "Vector Storage (uint8_t, growth)");
          memcpy(v32, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v31;
          a1[5] = v32;
          v33 = *((_DWORD *)a1 + 9);
        }
        result = (uint64_t)memmove(&v32[v15 + 1], &v32[v15], v33 - v15);
        *(_DWORD *)(a1[5] + v15) = v4;
        v40 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v40;
        break;
      default:
        break;
    }
  }
  v42 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v42)
  {
    v43 = 0;
    for (i = 0; i < v42; ++i)
    {
      v45 = *(_QWORD *)(a2 + 40);
      v46 = *(unsigned int **)(v45 + v43);
      if (v46)
      {
        serialize_GLPString(a1, *(const char **)(v45 + v43 + 8), *(_QWORD *)(v45 + v43 + 16));
        v47 = *v46;
        v48 = glp_serialized_integer32_control(*v46);
        v49 = *((_DWORD *)a1 + 8);
        v50 = *((unsigned int *)a1 + 9);
        v51 = v50 + 1;
        if ((int)v50 + 1 <= v49)
        {
          v54 = (char *)a1[5];
          v55 = *((_DWORD *)a1 + 9);
        }
        else
        {
          if (v49 <= 1)
            v49 = 1;
          v52 = 2 * v49;
          if (v52 <= v51)
            v53 = v51;
          else
            v53 = v52;
          v54 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v53, "Vector Storage (uint8_t, growth)");
          memcpy(v54, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v53;
          a1[5] = v54;
          v55 = *((_DWORD *)a1 + 9);
        }
        memmove(&v54[v50 + 1], &v54[v50], (v55 - v50));
        *(_BYTE *)(a1[5] + v50) = v48;
        v56 = *((_DWORD *)a1 + 9);
        v57 = v56 + 1;
        *((_DWORD *)a1 + 9) = v56 + 1;
        if (v48 < 0)
        {
          switch((v48 >> 1) & 7)
          {
            case 0u:
              v58 = v56 + 2;
              v59 = *((_DWORD *)a1 + 8);
              if (v58 <= v59)
              {
                v62 = (char *)a1[5];
                v63 = v57;
              }
              else
              {
                if (v59 <= 1)
                  v59 = 1;
                v60 = 2 * v59;
                if (v60 <= (int)v58)
                  v61 = v58;
                else
                  v61 = v60;
                v62 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v61, "Vector Storage (uint8_t, growth)");
                memcpy(v62, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v61;
                a1[5] = v62;
                v63 = *((_DWORD *)a1 + 9);
              }
              memmove(&v62[v57 + 1], &v62[v57], v63 - v57);
              *(_BYTE *)(a1[5] + v57) = v47;
              v83 = 1;
              goto LABEL_97;
            case 1u:
              v76 = v56 + 3;
              v77 = *((_DWORD *)a1 + 8);
              if (v76 <= v77)
              {
                v80 = (char *)a1[5];
                v81 = v57;
              }
              else
              {
                if (v77 <= 1)
                  v77 = 1;
                v78 = 2 * v77;
                if (v78 <= (int)v76)
                  v79 = v76;
                else
                  v79 = v78;
                v80 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v79, "Vector Storage (uint8_t, growth)");
                memcpy(v80, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v79;
                a1[5] = v80;
                v81 = *((_DWORD *)a1 + 9);
              }
              memmove(&v80[v57 + 1], &v80[v57], v81 - v57);
              *(_WORD *)(a1[5] + v57) = v47;
              v83 = 2;
              goto LABEL_97;
            case 2u:
              v64 = v56 + 4;
              v65 = *((_DWORD *)a1 + 8);
              if (v64 <= v65)
              {
                v68 = (char *)a1[5];
                v69 = v57;
              }
              else
              {
                if (v65 <= 1)
                  v65 = 1;
                v66 = 2 * v65;
                if (v66 <= (int)v64)
                  v67 = v64;
                else
                  v67 = v66;
                v68 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v67, "Vector Storage (uint8_t, growth)");
                memcpy(v68, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v67;
                a1[5] = v68;
                v69 = *((_DWORD *)a1 + 9);
              }
              memmove(&v68[v57 + 1], &v68[v57], v69 - v57);
              v82 = a1[5] + v57;
              *(_BYTE *)(v82 + 2) = BYTE2(v47);
              *(_WORD *)v82 = v47;
              v83 = 3;
              goto LABEL_97;
            case 3u:
              v70 = v56 + 5;
              v71 = *((_DWORD *)a1 + 8);
              if (v70 <= v71)
              {
                v74 = (char *)a1[5];
                v75 = v57;
              }
              else
              {
                if (v71 <= 1)
                  v71 = 1;
                v72 = 2 * v71;
                if (v72 <= (int)v70)
                  v73 = v70;
                else
                  v73 = v72;
                v74 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v73, "Vector Storage (uint8_t, growth)");
                memcpy(v74, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v73;
                a1[5] = v74;
                v75 = *((_DWORD *)a1 + 9);
              }
              memmove(&v74[v57 + 1], &v74[v57], v75 - v57);
              *(_DWORD *)(a1[5] + v57) = v47;
              v83 = 4;
LABEL_97:
              *((_DWORD *)a1 + 9) += v83;
              break;
            default:
              break;
          }
        }
        v84 = v46[1];
        v85 = glp_serialized_integer32_control(v84);
        v86 = *((_DWORD *)a1 + 8);
        v87 = *((unsigned int *)a1 + 9);
        v88 = v87 + 1;
        if ((int)v87 + 1 <= v86)
        {
          v91 = (char *)a1[5];
          v92 = *((_DWORD *)a1 + 9);
        }
        else
        {
          if (v86 <= 1)
            v86 = 1;
          v89 = 2 * v86;
          if (v89 <= v88)
            v90 = v88;
          else
            v90 = v89;
          v91 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v90, "Vector Storage (uint8_t, growth)");
          memcpy(v91, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v90;
          a1[5] = v91;
          v92 = *((_DWORD *)a1 + 9);
        }
        memmove(&v91[v87 + 1], &v91[v87], (v92 - v87));
        *(_BYTE *)(a1[5] + v87) = v85;
        v93 = *((_DWORD *)a1 + 9);
        v94 = v93 + 1;
        *((_DWORD *)a1 + 9) = v93 + 1;
        if (v85 < 0)
        {
          switch((v85 >> 1) & 7)
          {
            case 0u:
              v95 = v93 + 2;
              v96 = *((_DWORD *)a1 + 8);
              if (v95 <= v96)
              {
                v99 = (char *)a1[5];
                v100 = v94;
              }
              else
              {
                if (v96 <= 1)
                  v96 = 1;
                v97 = 2 * v96;
                if (v97 <= (int)v95)
                  v98 = v95;
                else
                  v98 = v97;
                v99 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v98, "Vector Storage (uint8_t, growth)");
                memcpy(v99, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v98;
                a1[5] = v99;
                v100 = *((_DWORD *)a1 + 9);
              }
              memmove(&v99[v94 + 1], &v99[v94], v100 - v94);
              *(_BYTE *)(a1[5] + v94) = v84;
              v120 = 1;
              goto LABEL_144;
            case 1u:
              v113 = v93 + 3;
              v114 = *((_DWORD *)a1 + 8);
              if (v113 <= v114)
              {
                v117 = (char *)a1[5];
                v118 = v94;
              }
              else
              {
                if (v114 <= 1)
                  v114 = 1;
                v115 = 2 * v114;
                if (v115 <= (int)v113)
                  v116 = v113;
                else
                  v116 = v115;
                v117 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v116, "Vector Storage (uint8_t, growth)");
                memcpy(v117, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v116;
                a1[5] = v117;
                v118 = *((_DWORD *)a1 + 9);
              }
              memmove(&v117[v94 + 1], &v117[v94], v118 - v94);
              *(_WORD *)(a1[5] + v94) = v84;
              v120 = 2;
              goto LABEL_144;
            case 2u:
              v101 = v93 + 4;
              v102 = *((_DWORD *)a1 + 8);
              if (v101 <= v102)
              {
                v105 = (char *)a1[5];
                v106 = v94;
              }
              else
              {
                if (v102 <= 1)
                  v102 = 1;
                v103 = 2 * v102;
                if (v103 <= (int)v101)
                  v104 = v101;
                else
                  v104 = v103;
                v105 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v104, "Vector Storage (uint8_t, growth)");
                memcpy(v105, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v104;
                a1[5] = v105;
                v106 = *((_DWORD *)a1 + 9);
              }
              memmove(&v105[v94 + 1], &v105[v94], v106 - v94);
              v119 = a1[5] + v94;
              *(_BYTE *)(v119 + 2) = BYTE2(v84);
              *(_WORD *)v119 = v84;
              v120 = 3;
              goto LABEL_144;
            case 3u:
              v107 = v93 + 5;
              v108 = *((_DWORD *)a1 + 8);
              if (v107 <= v108)
              {
                v111 = (char *)a1[5];
                v112 = v94;
              }
              else
              {
                if (v108 <= 1)
                  v108 = 1;
                v109 = 2 * v108;
                if (v109 <= (int)v107)
                  v110 = v107;
                else
                  v110 = v109;
                v111 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v110, "Vector Storage (uint8_t, growth)");
                memcpy(v111, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v110;
                a1[5] = v111;
                v112 = *((_DWORD *)a1 + 9);
              }
              memmove(&v111[v94 + 1], &v111[v94], v112 - v94);
              *(_DWORD *)(a1[5] + v94) = v84;
              v120 = 4;
LABEL_144:
              *((_DWORD *)a1 + 9) += v120;
              break;
            default:
              break;
          }
        }
        result = serialize_GLPType(a1, *((_QWORD *)v46 + 1));
        v42 = *(unsigned int *)(a2 + 32);
      }
      v43 += 32;
    }
  }
  return result;
}

uint64_t deserialize_bindings(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  const void *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  const char *v24;
  double v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;

  v2 = result;
  v3 = *(unsigned int *)(result + 260);
  if (v3 >= *(_DWORD *)(result + 256))
    goto LABEL_22;
  v5 = *(_QWORD *)(result + 248);
  v6 = *(char *)(v5 + v3);
  v7 = *(unsigned __int8 *)(v5 + v3);
  *(_DWORD *)(result + 260) = v3 + 1;
  if (v6 < 0)
    __asm { BR              X16 }
  if ((_DWORD)v7)
  {
    v8 = 0;
    while (1)
    {
      v9 = (const void *)deserialize_GLPString(v2);
      v11 = v10;
      v12 = malloc_type_malloc(0x10uLL, 0x7081ABB9uLL);
      if (!v12)
LABEL_23:
        abort();
      v13 = (uint64_t)v12;
      *v12 = 0;
      v12[1] = 0;
      v14 = *(unsigned int *)(v2 + 260);
      v15 = *(_DWORD *)(v2 + 256);
      if (v14 >= v15)
        break;
      v16 = *(_QWORD *)(v2 + 248);
      v17 = *(char *)(v16 + v14);
      v18 = *(unsigned __int8 *)(v16 + v14);
      v19 = v14 + 1;
      *(_DWORD *)(v2 + 260) = v14 + 1;
      if (v17 < 0)
        __asm { BR              X15 }
      *(_DWORD *)v12 = v18;
      if (v19 >= v15)
        break;
      v20 = *(char *)(v16 + v19);
      v21 = *(unsigned __int8 *)(v16 + v19);
      *(_DWORD *)(v2 + 260) = v14 + 2;
      if (v20 < 0)
        __asm { BR              X15 }
      *((_DWORD *)v12 + 1) = v21;
      v29 = 0;
      deserialize_GLPType((unsigned int *)v2, &v29);
      *(_QWORD *)(v13 + 8) = glpDeepCopyType(&GLP_MALLOC_ALLOCATOR, v29);
      v22 = v11;
      v23 = (char *)malloc_type_malloc(v11, 0x7081ABB9uLL);
      if (!v23)
        goto LABEL_23;
      v24 = v23;
      memcpy(v23, v9, v11);
      v26 = v11 >> 5;
      if (v11 >> 5 >= v11)
      {
        v28 = v11;
      }
      else
      {
        v27 = ~(v11 >> 5);
        LODWORD(v28) = v11;
        do
        {
          v28 = (32 * (_DWORD)v28 + (v28 >> 2) + v24[(v11 - 1)]) ^ v28;
          LODWORD(v11) = v11 + v27;
        }
        while (v11 > v26);
      }
      result = glpStringHashPut(a2, v24, v22 | (v28 << 32), v13, v25);
      if (++v8 == (_DWORD)v7)
        return result;
    }
LABEL_22:
    glpDeserialError(v2, 1u);
  }
  return result;
}

uint64_t glpMakeString(uint64_t result, unsigned int a2)
{
  unsigned int v2;
  unsigned int v3;

  if (a2 >> 5 < a2)
  {
    v2 = a2;
    v3 = a2;
    do
    {
      v3 ^= 32 * v3 + (v3 >> 2) + *(char *)(result + v2 - 1);
      v2 += ~(a2 >> 5);
    }
    while (v2 > a2 >> 5);
  }
  return result;
}

void *glpSerializeLinkedProgram(_QWORD *a1, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  char *v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  int v17;
  uint64_t v18;
  char *v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  uint64_t v24;
  char *v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  int v29;
  uint64_t v30;
  char *v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  int v35;
  uint64_t v36;
  char *v37;
  unsigned int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  int v43;
  uint64_t v44;
  int v45;
  int v46;
  uint64_t v47;
  char *v48;
  int v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  int v53;
  int v54;
  uint64_t v55;
  char *v56;
  unsigned int v57;
  unsigned int v58;
  int v59;
  int v60;
  uint64_t v61;
  char *v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  int v66;
  uint64_t v67;
  char *v68;
  unsigned int v69;
  unsigned int v70;
  int v71;
  int v72;
  uint64_t v73;
  char *v74;
  unsigned int v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int v79;
  unsigned int v80;
  int v81;
  uint64_t v82;
  int v83;
  int v84;
  uint64_t v85;
  char *v86;
  int v87;
  int v88;
  unsigned int v89;
  unsigned int v90;
  int v91;
  int v92;
  uint64_t v93;
  char *v94;
  unsigned int v95;
  unsigned int v96;
  int v97;
  int v98;
  uint64_t v99;
  char *v100;
  unsigned int v101;
  unsigned int v102;
  int v103;
  int v104;
  uint64_t v105;
  char *v106;
  unsigned int v107;
  unsigned int v108;
  int v109;
  int v110;
  uint64_t v111;
  char *v112;
  unsigned int v113;
  int v114;
  uint64_t v115;
  unsigned int *v116;
  uint64_t v117;
  unsigned int v118;
  int v119;
  uint64_t v120;
  int v121;
  int v122;
  uint64_t v123;
  char *v124;
  int v125;
  int v126;
  unsigned int v127;
  unsigned int v128;
  int v129;
  int v130;
  uint64_t v131;
  char *v132;
  unsigned int v133;
  unsigned int v134;
  int v135;
  int v136;
  uint64_t v137;
  char *v138;
  unsigned int v139;
  unsigned int v140;
  int v141;
  int v142;
  uint64_t v143;
  char *v144;
  unsigned int v145;
  unsigned int v146;
  int v147;
  int v148;
  uint64_t v149;
  char *v150;
  unsigned int v151;
  int v152;
  uint64_t v153;
  _QWORD *v154;
  unsigned int v155;
  char v156;
  int v157;
  uint64_t v158;
  int v159;
  int v160;
  uint64_t v161;
  char *v162;
  int v163;
  int v164;
  unsigned int v165;
  unsigned int v166;
  int v167;
  int v168;
  uint64_t v169;
  char *v170;
  unsigned int v171;
  unsigned int v172;
  int v173;
  int v174;
  uint64_t v175;
  char *v176;
  unsigned int v177;
  unsigned int v178;
  int v179;
  int v180;
  uint64_t v181;
  char *v182;
  unsigned int v183;
  unsigned int v184;
  int v185;
  int v186;
  uint64_t v187;
  char *v188;
  unsigned int v189;
  uint64_t v190;
  uint64_t v191;
  int v192;
  int v193;
  int v194;
  uint64_t v195;
  char *v196;
  unsigned int v197;
  uint64_t v198;
  unsigned int v199;
  int v200;
  uint64_t v201;
  int v202;
  int v203;
  uint64_t v204;
  char *v205;
  int v206;
  int v207;
  unsigned int v208;
  unsigned int v209;
  int v210;
  int v211;
  uint64_t v212;
  char *v213;
  unsigned int v214;
  unsigned int v215;
  int v216;
  int v217;
  uint64_t v218;
  char *v219;
  unsigned int v220;
  unsigned int v221;
  int v222;
  int v223;
  uint64_t v224;
  char *v225;
  unsigned int v226;
  unsigned int v227;
  int v228;
  int v229;
  uint64_t v230;
  char *v231;
  unsigned int v232;
  int v233;
  uint64_t v234;
  uint64_t v235;
  unsigned int v236;
  int v237;
  uint64_t v238;
  int v239;
  int v240;
  uint64_t v241;
  char *v242;
  int v243;
  int v244;
  unsigned int v245;
  unsigned int v246;
  int v247;
  int v248;
  uint64_t v249;
  char *v250;
  unsigned int v251;
  unsigned int v252;
  int v253;
  int v254;
  uint64_t v255;
  char *v256;
  unsigned int v257;
  unsigned int v258;
  int v259;
  int v260;
  uint64_t v261;
  char *v262;
  unsigned int v263;
  unsigned int v264;
  int v265;
  int v266;
  uint64_t v267;
  char *v268;
  unsigned int v269;
  int v270;
  uint64_t v271;
  uint64_t v272;
  unsigned int v273;
  unsigned int v274;
  int v275;
  uint64_t v276;
  int v277;
  int v278;
  uint64_t v279;
  char *v280;
  int v281;
  unsigned int v282;
  int v283;
  uint64_t v284;
  int v285;
  int v286;
  uint64_t v287;
  char *v288;
  int v289;
  void *result;
  int v291;
  unsigned int v292;
  unsigned int v293;
  int v294;
  int v295;
  uint64_t v296;
  char *v297;
  unsigned int v298;
  int v299;
  unsigned int v300;
  unsigned int v301;
  int v302;
  int v303;
  uint64_t v304;
  char *v305;
  unsigned int v306;
  unsigned int v307;
  int v308;
  int v309;
  uint64_t v310;
  char *v311;
  unsigned int v312;
  unsigned int v313;
  int v314;
  int v315;
  uint64_t v316;
  char *v317;
  unsigned int v318;
  unsigned int v319;
  int v320;
  int v321;
  uint64_t v322;
  char *v323;
  unsigned int v324;
  unsigned int v325;
  int v326;
  int v327;
  uint64_t v328;
  char *v329;
  unsigned int v330;
  unsigned int v331;
  int v332;
  int v333;
  uint64_t v334;
  char *v335;
  unsigned int v336;
  unsigned int v337;
  int v338;
  int v339;
  uint64_t v340;
  char *v341;
  unsigned int v342;
  int v343;
  uint64_t v344;
  unint64_t v345;
  uint64_t v346;
  unint64_t i;
  uint64_t v348;
  uint64_t v349;
  unsigned int v350;
  unsigned int v351;
  int v352;
  uint64_t v353;
  int v354;
  int v355;
  uint64_t v356;
  char *v357;
  int v358;
  int v359;
  unsigned int v360;
  unsigned int v361;
  int v362;
  int v363;
  uint64_t v364;
  char *v365;
  unsigned int v366;
  unsigned int v367;
  int v368;
  int v369;
  uint64_t v370;
  char *v371;
  unsigned int v372;
  unsigned int v373;
  int v374;
  int v375;
  uint64_t v376;
  char *v377;
  unsigned int v378;
  unsigned int v379;
  int v380;
  int v381;
  uint64_t v382;
  char *v383;
  unsigned int v384;
  int v385;
  uint64_t v386;
  int v387;
  int v388;
  uint64_t v389;
  int v390;
  int v391;
  uint64_t v392;
  char *v393;
  int v394;
  int v395;
  int v396;
  unsigned int v397;
  int v398;
  unsigned int v399;
  int v400;
  uint64_t v401;
  char *v402;
  unsigned int v403;
  int v404;
  uint64_t v405;

  serialize_bindings(a1, *(_QWORD *)(a2 + 184));
  serialize_bindings(a1, *(_QWORD *)(a2 + 192));
  glpSerializeUniformBindings(a1, *(_QWORD *)(a2 + 80));
  v4 = *(_DWORD *)(a2 + 224);
  v5 = (char)glp_serialized_integer32_control(v4);
  v6 = *((_DWORD *)a1 + 8);
  v7 = *((unsigned int *)a1 + 9);
  v8 = v7 + 1;
  if ((int)v7 + 1 <= v6)
  {
    v11 = (char *)a1[5];
    v12 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v6 <= 1)
      v6 = 1;
    v9 = 2 * v6;
    if (v9 <= v8)
      v10 = v8;
    else
      v10 = v9;
    v11 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v10, "Vector Storage (uint8_t, growth)");
    memcpy(v11, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v10;
    a1[5] = v11;
    v12 = *((_DWORD *)a1 + 9);
  }
  memmove(&v11[v7 + 1], &v11[v7], (v12 - v7));
  *(_BYTE *)(a1[5] + v7) = v5;
  v13 = *((_DWORD *)a1 + 9);
  v14 = v13 + 1;
  *((_DWORD *)a1 + 9) = v13 + 1;
  if ((v5 & 0x80000000) != 0)
  {
    switch((v5 >> 1) & 7)
    {
      case 0u:
        v15 = v13 + 2;
        v16 = *((_DWORD *)a1 + 8);
        if (v15 <= v16)
        {
          v19 = (char *)a1[5];
          v20 = v14;
        }
        else
        {
          if (v16 <= 1)
            v16 = 1;
          v17 = 2 * v16;
          if (v17 <= (int)v15)
            v18 = v15;
          else
            v18 = v17;
          v19 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v18, "Vector Storage (uint8_t, growth)");
          memcpy(v19, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v18;
          a1[5] = v19;
          v20 = *((_DWORD *)a1 + 9);
        }
        memmove(&v19[v14 + 1], &v19[v14], v20 - v14);
        *(_BYTE *)(a1[5] + v14) = v4;
        v39 = 1;
        goto LABEL_47;
      case 1u:
        v21 = v13 + 3;
        v22 = *((_DWORD *)a1 + 8);
        if (v21 <= v22)
        {
          v25 = (char *)a1[5];
          v26 = v14;
        }
        else
        {
          if (v22 <= 1)
            v22 = 1;
          v23 = 2 * v22;
          if (v23 <= (int)v21)
            v24 = v21;
          else
            v24 = v23;
          v25 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v24, "Vector Storage (uint8_t, growth)");
          memcpy(v25, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v24;
          a1[5] = v25;
          v26 = *((_DWORD *)a1 + 9);
        }
        memmove(&v25[v14 + 1], &v25[v14], v26 - v14);
        *(_WORD *)(a1[5] + v14) = v4;
        v39 = 2;
        goto LABEL_47;
      case 2u:
        v27 = v13 + 4;
        v28 = *((_DWORD *)a1 + 8);
        if (v27 <= v28)
        {
          v31 = (char *)a1[5];
          v32 = v14;
        }
        else
        {
          if (v28 <= 1)
            v28 = 1;
          v29 = 2 * v28;
          if (v29 <= (int)v27)
            v30 = v27;
          else
            v30 = v29;
          v31 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v30, "Vector Storage (uint8_t, growth)");
          memcpy(v31, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v30;
          a1[5] = v31;
          v32 = *((_DWORD *)a1 + 9);
        }
        memmove(&v31[v14 + 1], &v31[v14], v32 - v14);
        v40 = a1[5] + v14;
        *(_BYTE *)(v40 + 2) = BYTE2(v4);
        *(_WORD *)v40 = v4;
        v39 = 3;
        goto LABEL_47;
      case 3u:
        v33 = v13 + 5;
        v34 = *((_DWORD *)a1 + 8);
        if (v33 <= v34)
        {
          v37 = (char *)a1[5];
          v38 = v14;
        }
        else
        {
          if (v34 <= 1)
            v34 = 1;
          v35 = 2 * v34;
          if (v35 <= (int)v33)
            v36 = v33;
          else
            v36 = v35;
          v37 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v36, "Vector Storage (uint8_t, growth)");
          memcpy(v37, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v36;
          a1[5] = v37;
          v38 = *((_DWORD *)a1 + 9);
        }
        memmove(&v37[v14 + 1], &v37[v14], v38 - v14);
        *(_DWORD *)(a1[5] + v14) = v4;
        v39 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v39;
        break;
      default:
        break;
    }
  }
  v41 = *(unsigned int *)(a2 + 204);
  v42 = (char)glp_serialized_integer32_control(v41);
  v43 = *((_DWORD *)a1 + 8);
  v44 = *((unsigned int *)a1 + 9);
  v45 = v44 + 1;
  if ((int)v44 + 1 <= v43)
  {
    v48 = (char *)a1[5];
    v49 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v43 <= 1)
      v43 = 1;
    v46 = 2 * v43;
    if (v46 <= v45)
      v47 = v45;
    else
      v47 = v46;
    v48 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v47, "Vector Storage (uint8_t, growth)");
    memcpy(v48, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v47;
    a1[5] = v48;
    v49 = *((_DWORD *)a1 + 9);
  }
  memmove(&v48[v44 + 1], &v48[v44], (v49 - v44));
  *(_BYTE *)(a1[5] + v44) = v42;
  v50 = *((_DWORD *)a1 + 9);
  v51 = v50 + 1;
  *((_DWORD *)a1 + 9) = v50 + 1;
  if ((v42 & 0x80000000) != 0)
  {
    switch((v42 >> 1) & 7)
    {
      case 0u:
        v52 = v50 + 2;
        v53 = *((_DWORD *)a1 + 8);
        if (v52 <= v53)
        {
          v56 = (char *)a1[5];
          v57 = v51;
        }
        else
        {
          if (v53 <= 1)
            v53 = 1;
          v54 = 2 * v53;
          if (v54 <= (int)v52)
            v55 = v52;
          else
            v55 = v54;
          v56 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v55, "Vector Storage (uint8_t, growth)");
          memcpy(v56, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v55;
          a1[5] = v56;
          v57 = *((_DWORD *)a1 + 9);
        }
        memmove(&v56[v51 + 1], &v56[v51], v57 - v51);
        *(_BYTE *)(a1[5] + v51) = v41;
        v76 = 1;
        goto LABEL_94;
      case 1u:
        v58 = v50 + 3;
        v59 = *((_DWORD *)a1 + 8);
        if (v58 <= v59)
        {
          v62 = (char *)a1[5];
          v63 = v51;
        }
        else
        {
          if (v59 <= 1)
            v59 = 1;
          v60 = 2 * v59;
          if (v60 <= (int)v58)
            v61 = v58;
          else
            v61 = v60;
          v62 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v61, "Vector Storage (uint8_t, growth)");
          memcpy(v62, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v61;
          a1[5] = v62;
          v63 = *((_DWORD *)a1 + 9);
        }
        memmove(&v62[v51 + 1], &v62[v51], v63 - v51);
        *(_WORD *)(a1[5] + v51) = v41;
        v76 = 2;
        goto LABEL_94;
      case 2u:
        v64 = v50 + 4;
        v65 = *((_DWORD *)a1 + 8);
        if (v64 <= v65)
        {
          v68 = (char *)a1[5];
          v69 = v51;
        }
        else
        {
          if (v65 <= 1)
            v65 = 1;
          v66 = 2 * v65;
          if (v66 <= (int)v64)
            v67 = v64;
          else
            v67 = v66;
          v68 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v67, "Vector Storage (uint8_t, growth)");
          memcpy(v68, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v67;
          a1[5] = v68;
          v69 = *((_DWORD *)a1 + 9);
        }
        memmove(&v68[v51 + 1], &v68[v51], v69 - v51);
        v77 = a1[5] + v51;
        *(_BYTE *)(v77 + 2) = BYTE2(v41);
        *(_WORD *)v77 = v41;
        v76 = 3;
        goto LABEL_94;
      case 3u:
        v70 = v50 + 5;
        v71 = *((_DWORD *)a1 + 8);
        if (v70 <= v71)
        {
          v74 = (char *)a1[5];
          v75 = v51;
        }
        else
        {
          if (v71 <= 1)
            v71 = 1;
          v72 = 2 * v71;
          if (v72 <= (int)v70)
            v73 = v70;
          else
            v73 = v72;
          v74 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v73, "Vector Storage (uint8_t, growth)");
          memcpy(v74, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v73;
          a1[5] = v74;
          v75 = *((_DWORD *)a1 + 9);
        }
        memmove(&v74[v51 + 1], &v74[v51], v75 - v51);
        *(_DWORD *)(a1[5] + v51) = v41;
        v76 = 4;
LABEL_94:
        *((_DWORD *)a1 + 9) += v76;
        break;
      default:
        break;
    }
  }
  if ((int)v41 >= 1)
  {
    v78 = 0;
    do
    {
      v79 = *(_DWORD *)(*(_QWORD *)(a2 + 208) + v78);
      LOBYTE(v80) = glp_serialized_integer32_control(v79);
      v81 = *((_DWORD *)a1 + 8);
      v82 = *((unsigned int *)a1 + 9);
      v83 = v82 + 1;
      if ((int)v82 + 1 <= v81)
      {
        v86 = (char *)a1[5];
        v87 = *((_DWORD *)a1 + 9);
      }
      else
      {
        if (v81 <= 1)
          v81 = 1;
        v84 = 2 * v81;
        if (v84 <= v83)
          v85 = v83;
        else
          v85 = v84;
        v86 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v85, "Vector Storage (uint8_t, growth)");
        memcpy(v86, (const void *)a1[5], *((unsigned int *)a1 + 9));
        ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
        *((_DWORD *)a1 + 8) = v85;
        a1[5] = v86;
        v87 = *((_DWORD *)a1 + 9);
      }
      v80 = (char)v80;
      memmove(&v86[v82 + 1], &v86[v82], (v87 - v82));
      *(_BYTE *)(a1[5] + v82) = v80;
      v88 = *((_DWORD *)a1 + 9);
      v89 = v88 + 1;
      *((_DWORD *)a1 + 9) = v88 + 1;
      if ((char)v80 < 0)
      {
        switch((v80 >> 1) & 7)
        {
          case 0u:
            v90 = v88 + 2;
            v91 = *((_DWORD *)a1 + 8);
            if (v90 <= v91)
            {
              v94 = (char *)a1[5];
              v95 = v89;
            }
            else
            {
              if (v91 <= 1)
                v91 = 1;
              v92 = 2 * v91;
              if (v92 <= (int)v90)
                v93 = v90;
              else
                v93 = v92;
              v94 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v93, "Vector Storage (uint8_t, growth)");
              memcpy(v94, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v93;
              a1[5] = v94;
              v95 = *((_DWORD *)a1 + 9);
            }
            memmove(&v94[v89 + 1], &v94[v89], v95 - v89);
            *(_BYTE *)(a1[5] + v89) = v79;
            v114 = 1;
            goto LABEL_143;
          case 1u:
            v96 = v88 + 3;
            v97 = *((_DWORD *)a1 + 8);
            if (v96 <= v97)
            {
              v100 = (char *)a1[5];
              v101 = v89;
            }
            else
            {
              if (v97 <= 1)
                v97 = 1;
              v98 = 2 * v97;
              if (v98 <= (int)v96)
                v99 = v96;
              else
                v99 = v98;
              v100 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v99, "Vector Storage (uint8_t, growth)");
              memcpy(v100, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v99;
              a1[5] = v100;
              v101 = *((_DWORD *)a1 + 9);
            }
            memmove(&v100[v89 + 1], &v100[v89], v101 - v89);
            *(_WORD *)(a1[5] + v89) = v79;
            v114 = 2;
            goto LABEL_143;
          case 2u:
            v102 = v88 + 4;
            v103 = *((_DWORD *)a1 + 8);
            if (v102 <= v103)
            {
              v106 = (char *)a1[5];
              v107 = v89;
            }
            else
            {
              if (v103 <= 1)
                v103 = 1;
              v104 = 2 * v103;
              if (v104 <= (int)v102)
                v105 = v102;
              else
                v105 = v104;
              v106 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v105, "Vector Storage (uint8_t, growth)");
              memcpy(v106, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v105;
              a1[5] = v106;
              v107 = *((_DWORD *)a1 + 9);
            }
            memmove(&v106[v89 + 1], &v106[v89], v107 - v89);
            v115 = a1[5] + v89;
            *(_BYTE *)(v115 + 2) = BYTE2(v79);
            *(_WORD *)v115 = v79;
            v114 = 3;
            goto LABEL_143;
          case 3u:
            v108 = v88 + 5;
            v109 = *((_DWORD *)a1 + 8);
            if (v108 <= v109)
            {
              v112 = (char *)a1[5];
              v113 = v89;
            }
            else
            {
              if (v109 <= 1)
                v109 = 1;
              v110 = 2 * v109;
              if (v110 <= (int)v108)
                v111 = v108;
              else
                v111 = v110;
              v112 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v111, "Vector Storage (uint8_t, growth)");
              memcpy(v112, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v111;
              a1[5] = v112;
              v113 = *((_DWORD *)a1 + 9);
            }
            memmove(&v112[v89 + 1], &v112[v89], v113 - v89);
            *(_DWORD *)(a1[5] + v89) = v79;
            v114 = 4;
LABEL_143:
            *((_DWORD *)a1 + 9) += v114;
            break;
          default:
            break;
        }
      }
      v78 += 4;
    }
    while (4 * v41 != v78);
  }
  v116 = *(unsigned int **)(a2 + 216);
  v117 = *v116;
  v118 = (char)glp_serialized_integer32_control(v117);
  v119 = *((_DWORD *)a1 + 8);
  v120 = *((unsigned int *)a1 + 9);
  v121 = v120 + 1;
  if ((int)v120 + 1 <= v119)
  {
    v124 = (char *)a1[5];
    v125 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v119 <= 1)
      v119 = 1;
    v122 = 2 * v119;
    if (v122 <= v121)
      v123 = v121;
    else
      v123 = v122;
    v124 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v123, "Vector Storage (uint8_t, growth)");
    memcpy(v124, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v123;
    a1[5] = v124;
    v125 = *((_DWORD *)a1 + 9);
  }
  memmove(&v124[v120 + 1], &v124[v120], (v125 - v120));
  *(_BYTE *)(a1[5] + v120) = v118;
  v126 = *((_DWORD *)a1 + 9);
  v127 = v126 + 1;
  *((_DWORD *)a1 + 9) = v126 + 1;
  if ((v118 & 0x80000000) != 0)
  {
    switch((v118 >> 1) & 7)
    {
      case 0u:
        v128 = v126 + 2;
        v129 = *((_DWORD *)a1 + 8);
        if (v128 <= v129)
        {
          v132 = (char *)a1[5];
          v133 = v127;
        }
        else
        {
          if (v129 <= 1)
            v129 = 1;
          v130 = 2 * v129;
          if (v130 <= (int)v128)
            v131 = v128;
          else
            v131 = v130;
          v132 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v131, "Vector Storage (uint8_t, growth)");
          memcpy(v132, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v131;
          a1[5] = v132;
          v133 = *((_DWORD *)a1 + 9);
        }
        memmove(&v132[v127 + 1], &v132[v127], v133 - v127);
        *(_BYTE *)(a1[5] + v127) = v117;
        v152 = 1;
        goto LABEL_191;
      case 1u:
        v134 = v126 + 3;
        v135 = *((_DWORD *)a1 + 8);
        if (v134 <= v135)
        {
          v138 = (char *)a1[5];
          v139 = v127;
        }
        else
        {
          if (v135 <= 1)
            v135 = 1;
          v136 = 2 * v135;
          if (v136 <= (int)v134)
            v137 = v134;
          else
            v137 = v136;
          v138 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v137, "Vector Storage (uint8_t, growth)");
          memcpy(v138, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v137;
          a1[5] = v138;
          v139 = *((_DWORD *)a1 + 9);
        }
        memmove(&v138[v127 + 1], &v138[v127], v139 - v127);
        *(_WORD *)(a1[5] + v127) = v117;
        v152 = 2;
        goto LABEL_191;
      case 2u:
        v140 = v126 + 4;
        v141 = *((_DWORD *)a1 + 8);
        if (v140 <= v141)
        {
          v144 = (char *)a1[5];
          v145 = v127;
        }
        else
        {
          if (v141 <= 1)
            v141 = 1;
          v142 = 2 * v141;
          if (v142 <= (int)v140)
            v143 = v140;
          else
            v143 = v142;
          v144 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v143, "Vector Storage (uint8_t, growth)");
          memcpy(v144, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v143;
          a1[5] = v144;
          v145 = *((_DWORD *)a1 + 9);
        }
        memmove(&v144[v127 + 1], &v144[v127], v145 - v127);
        v153 = a1[5] + v127;
        *(_BYTE *)(v153 + 2) = BYTE2(v117);
        *(_WORD *)v153 = v117;
        v152 = 3;
        goto LABEL_191;
      case 3u:
        v146 = v126 + 5;
        v147 = *((_DWORD *)a1 + 8);
        if (v146 <= v147)
        {
          v150 = (char *)a1[5];
          v151 = v127;
        }
        else
        {
          if (v147 <= 1)
            v147 = 1;
          v148 = 2 * v147;
          if (v148 <= (int)v146)
            v149 = v146;
          else
            v149 = v148;
          v150 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v149, "Vector Storage (uint8_t, growth)");
          memcpy(v150, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v149;
          a1[5] = v150;
          v151 = *((_DWORD *)a1 + 9);
        }
        memmove(&v150[v127 + 1], &v150[v127], v151 - v127);
        *(_DWORD *)(a1[5] + v127) = v117;
        v152 = 4;
LABEL_191:
        *((_DWORD *)a1 + 9) += v152;
        break;
      default:
        break;
    }
  }
  if ((int)v117 >= 1)
  {
    v154 = v116 + 4;
    do
    {
      v155 = *((_DWORD *)v154 - 2);
      v156 = glp_serialized_integer32_control(v155);
      v157 = *((_DWORD *)a1 + 8);
      v158 = *((unsigned int *)a1 + 9);
      v159 = v158 + 1;
      if ((int)v158 + 1 <= v157)
      {
        v162 = (char *)a1[5];
        v163 = *((_DWORD *)a1 + 9);
      }
      else
      {
        if (v157 <= 1)
          v157 = 1;
        v160 = 2 * v157;
        if (v160 <= v159)
          v161 = v159;
        else
          v161 = v160;
        v162 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v161, "Vector Storage (uint8_t, growth)");
        memcpy(v162, (const void *)a1[5], *((unsigned int *)a1 + 9));
        ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
        *((_DWORD *)a1 + 8) = v161;
        a1[5] = v162;
        v163 = *((_DWORD *)a1 + 9);
      }
      memmove(&v162[v158 + 1], &v162[v158], (v163 - v158));
      *(_BYTE *)(a1[5] + v158) = v156;
      v164 = *((_DWORD *)a1 + 9);
      v165 = v164 + 1;
      *((_DWORD *)a1 + 9) = v164 + 1;
      if (v156 < 0)
      {
        switch((v156 >> 1) & 7)
        {
          case 0u:
            v166 = v164 + 2;
            v167 = *((_DWORD *)a1 + 8);
            if (v166 <= v167)
            {
              v170 = (char *)a1[5];
              v171 = v165;
            }
            else
            {
              if (v167 <= 1)
                v167 = 1;
              v168 = 2 * v167;
              if (v168 <= (int)v166)
                v169 = v166;
              else
                v169 = v168;
              v170 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v169, "Vector Storage (uint8_t, growth)");
              memcpy(v170, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v169;
              a1[5] = v170;
              v171 = *((_DWORD *)a1 + 9);
            }
            memmove(&v170[v165 + 1], &v170[v165], v171 - v165);
            *(_BYTE *)(a1[5] + v165) = v155;
            v165 = *((_DWORD *)a1 + 9) + 1;
            goto LABEL_240;
          case 1u:
            v172 = v164 + 3;
            v173 = *((_DWORD *)a1 + 8);
            if (v172 <= v173)
            {
              v176 = (char *)a1[5];
              v177 = v165;
            }
            else
            {
              if (v173 <= 1)
                v173 = 1;
              v174 = 2 * v173;
              if (v174 <= (int)v172)
                v175 = v172;
              else
                v175 = v174;
              v176 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v175, "Vector Storage (uint8_t, growth)");
              memcpy(v176, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v175;
              a1[5] = v176;
              v177 = *((_DWORD *)a1 + 9);
            }
            memmove(&v176[v165 + 1], &v176[v165], v177 - v165);
            *(_WORD *)(a1[5] + v165) = v155;
            v165 = *((_DWORD *)a1 + 9) + 2;
            goto LABEL_240;
          case 2u:
            v178 = v164 + 4;
            v179 = *((_DWORD *)a1 + 8);
            if (v178 <= v179)
            {
              v182 = (char *)a1[5];
              v183 = v165;
            }
            else
            {
              if (v179 <= 1)
                v179 = 1;
              v180 = 2 * v179;
              if (v180 <= (int)v178)
                v181 = v178;
              else
                v181 = v180;
              v182 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v181, "Vector Storage (uint8_t, growth)");
              memcpy(v182, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v181;
              a1[5] = v182;
              v183 = *((_DWORD *)a1 + 9);
            }
            memmove(&v182[v165 + 1], &v182[v165], v183 - v165);
            v190 = a1[5] + v165;
            *(_BYTE *)(v190 + 2) = BYTE2(v155);
            *(_WORD *)v190 = v155;
            v165 = *((_DWORD *)a1 + 9) + 3;
            goto LABEL_240;
          case 3u:
            v184 = v164 + 5;
            v185 = *((_DWORD *)a1 + 8);
            if (v184 <= v185)
            {
              v188 = (char *)a1[5];
              v189 = v165;
            }
            else
            {
              if (v185 <= 1)
                v185 = 1;
              v186 = 2 * v185;
              if (v186 <= (int)v184)
                v187 = v184;
              else
                v187 = v186;
              v188 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v187, "Vector Storage (uint8_t, growth)");
              memcpy(v188, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v187;
              a1[5] = v188;
              v189 = *((_DWORD *)a1 + 9);
            }
            memmove(&v188[v165 + 1], &v188[v165], v189 - v165);
            *(_DWORD *)(a1[5] + v165) = v155;
            v165 = *((_DWORD *)a1 + 9) + 4;
LABEL_240:
            *((_DWORD *)a1 + 9) = v165;
            break;
          default:
            break;
        }
      }
      v191 = *v154;
      v192 = v165 + 8;
      v193 = *((_DWORD *)a1 + 8);
      if (v165 + 8 <= v193)
      {
        v196 = (char *)a1[5];
        v197 = v165;
      }
      else
      {
        if (v193 <= 1)
          v193 = 1;
        v194 = 2 * v193;
        if (v194 <= v192)
          v195 = v192;
        else
          v195 = v194;
        v196 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v195, "Vector Storage (uint8_t, growth)");
        memcpy(v196, (const void *)a1[5], *((unsigned int *)a1 + 9));
        ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
        *((_DWORD *)a1 + 8) = v195;
        a1[5] = v196;
        v197 = *((_DWORD *)a1 + 9);
      }
      v154 += 2;
      memmove(&v196[v165 + 1], &v196[v165], v197 - v165);
      *(_QWORD *)(a1[5] + v165) = v191;
      *((_DWORD *)a1 + 9) += 8;
      --v117;
    }
    while (v117);
  }
  v198 = *(_QWORD *)(a2 + 88);
  if (v198)
  {
    glpSerializeUniformBindings(a1, v198);
  }
  else
  {
    v199 = (char)glp_serialized_integer32_control(0);
    v200 = *((_DWORD *)a1 + 8);
    v201 = *((unsigned int *)a1 + 9);
    v202 = v201 + 1;
    if ((int)v201 + 1 <= v200)
    {
      v205 = (char *)a1[5];
      v206 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v200 <= 1)
        v200 = 1;
      v203 = 2 * v200;
      if (v203 <= v202)
        v204 = v202;
      else
        v204 = v203;
      v205 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v204, "Vector Storage (uint8_t, growth)");
      memcpy(v205, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v204;
      a1[5] = v205;
      v206 = *((_DWORD *)a1 + 9);
    }
    memmove(&v205[v201 + 1], &v205[v201], (v206 - v201));
    *(_BYTE *)(a1[5] + v201) = v199;
    v207 = *((_DWORD *)a1 + 9);
    v208 = v207 + 1;
    *((_DWORD *)a1 + 9) = v207 + 1;
    if ((v199 & 0x80000000) != 0)
    {
      switch((v199 >> 1) & 7)
      {
        case 0u:
          v209 = v207 + 2;
          v210 = *((_DWORD *)a1 + 8);
          if (v209 <= v210)
          {
            v213 = (char *)a1[5];
            v214 = v208;
          }
          else
          {
            if (v210 <= 1)
              v210 = 1;
            v211 = 2 * v210;
            if (v211 <= (int)v209)
              v212 = v209;
            else
              v212 = v211;
            v213 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v212, "Vector Storage (uint8_t, growth)");
            memcpy(v213, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v212;
            a1[5] = v213;
            v214 = *((_DWORD *)a1 + 9);
          }
          memmove(&v213[v208 + 1], &v213[v208], v214 - v208);
          *(_BYTE *)(a1[5] + v208) = 0;
          v233 = *((_DWORD *)a1 + 9) + 1;
          goto LABEL_298;
        case 1u:
          v215 = v207 + 3;
          v216 = *((_DWORD *)a1 + 8);
          if (v215 <= v216)
          {
            v219 = (char *)a1[5];
            v220 = v208;
          }
          else
          {
            if (v216 <= 1)
              v216 = 1;
            v217 = 2 * v216;
            if (v217 <= (int)v215)
              v218 = v215;
            else
              v218 = v217;
            v219 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v218, "Vector Storage (uint8_t, growth)");
            memcpy(v219, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v218;
            a1[5] = v219;
            v220 = *((_DWORD *)a1 + 9);
          }
          memmove(&v219[v208 + 1], &v219[v208], v220 - v208);
          *(_WORD *)(a1[5] + v208) = 0;
          v233 = *((_DWORD *)a1 + 9) + 2;
          goto LABEL_298;
        case 2u:
          v221 = v207 + 4;
          v222 = *((_DWORD *)a1 + 8);
          if (v221 <= v222)
          {
            v225 = (char *)a1[5];
            v226 = v208;
          }
          else
          {
            if (v222 <= 1)
              v222 = 1;
            v223 = 2 * v222;
            if (v223 <= (int)v221)
              v224 = v221;
            else
              v224 = v223;
            v225 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v224, "Vector Storage (uint8_t, growth)");
            memcpy(v225, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v224;
            a1[5] = v225;
            v226 = *((_DWORD *)a1 + 9);
          }
          memmove(&v225[v208 + 1], &v225[v208], v226 - v208);
          v234 = a1[5] + v208;
          *(_BYTE *)(v234 + 2) = 0;
          *(_WORD *)v234 = 0;
          v233 = *((_DWORD *)a1 + 9) + 3;
          goto LABEL_298;
        case 3u:
          v227 = v207 + 5;
          v228 = *((_DWORD *)a1 + 8);
          if (v227 <= v228)
          {
            v231 = (char *)a1[5];
            v232 = v208;
          }
          else
          {
            if (v228 <= 1)
              v228 = 1;
            v229 = 2 * v228;
            if (v229 <= (int)v227)
              v230 = v227;
            else
              v230 = v229;
            v231 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v230, "Vector Storage (uint8_t, growth)");
            memcpy(v231, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v230;
            a1[5] = v231;
            v232 = *((_DWORD *)a1 + 9);
          }
          memmove(&v231[v208 + 1], &v231[v208], v232 - v208);
          *(_DWORD *)(a1[5] + v208) = 0;
          v233 = *((_DWORD *)a1 + 9) + 4;
LABEL_298:
          *((_DWORD *)a1 + 9) = v233;
          break;
        default:
          break;
      }
    }
  }
  v235 = *(_QWORD *)(a2 + 96);
  if (v235)
  {
    glpSerializeUniformBindings(a1, v235);
  }
  else
  {
    v236 = (char)glp_serialized_integer32_control(0);
    v237 = *((_DWORD *)a1 + 8);
    v238 = *((unsigned int *)a1 + 9);
    v239 = v238 + 1;
    if ((int)v238 + 1 <= v237)
    {
      v242 = (char *)a1[5];
      v243 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v237 <= 1)
        v237 = 1;
      v240 = 2 * v237;
      if (v240 <= v239)
        v241 = v239;
      else
        v241 = v240;
      v242 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v241, "Vector Storage (uint8_t, growth)");
      memcpy(v242, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v241;
      a1[5] = v242;
      v243 = *((_DWORD *)a1 + 9);
    }
    memmove(&v242[v238 + 1], &v242[v238], (v243 - v238));
    *(_BYTE *)(a1[5] + v238) = v236;
    v244 = *((_DWORD *)a1 + 9);
    v245 = v244 + 1;
    *((_DWORD *)a1 + 9) = v244 + 1;
    if ((v236 & 0x80000000) != 0)
    {
      switch((v236 >> 1) & 7)
      {
        case 0u:
          v246 = v244 + 2;
          v247 = *((_DWORD *)a1 + 8);
          if (v246 <= v247)
          {
            v250 = (char *)a1[5];
            v251 = v245;
          }
          else
          {
            if (v247 <= 1)
              v247 = 1;
            v248 = 2 * v247;
            if (v248 <= (int)v246)
              v249 = v246;
            else
              v249 = v248;
            v250 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v249, "Vector Storage (uint8_t, growth)");
            memcpy(v250, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v249;
            a1[5] = v250;
            v251 = *((_DWORD *)a1 + 9);
          }
          memmove(&v250[v245 + 1], &v250[v245], v251 - v245);
          *(_BYTE *)(a1[5] + v245) = 0;
          v270 = *((_DWORD *)a1 + 9) + 1;
          goto LABEL_347;
        case 1u:
          v252 = v244 + 3;
          v253 = *((_DWORD *)a1 + 8);
          if (v252 <= v253)
          {
            v256 = (char *)a1[5];
            v257 = v245;
          }
          else
          {
            if (v253 <= 1)
              v253 = 1;
            v254 = 2 * v253;
            if (v254 <= (int)v252)
              v255 = v252;
            else
              v255 = v254;
            v256 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v255, "Vector Storage (uint8_t, growth)");
            memcpy(v256, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v255;
            a1[5] = v256;
            v257 = *((_DWORD *)a1 + 9);
          }
          memmove(&v256[v245 + 1], &v256[v245], v257 - v245);
          *(_WORD *)(a1[5] + v245) = 0;
          v270 = *((_DWORD *)a1 + 9) + 2;
          goto LABEL_347;
        case 2u:
          v258 = v244 + 4;
          v259 = *((_DWORD *)a1 + 8);
          if (v258 <= v259)
          {
            v262 = (char *)a1[5];
            v263 = v245;
          }
          else
          {
            if (v259 <= 1)
              v259 = 1;
            v260 = 2 * v259;
            if (v260 <= (int)v258)
              v261 = v258;
            else
              v261 = v260;
            v262 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v261, "Vector Storage (uint8_t, growth)");
            memcpy(v262, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v261;
            a1[5] = v262;
            v263 = *((_DWORD *)a1 + 9);
          }
          memmove(&v262[v245 + 1], &v262[v245], v263 - v245);
          v271 = a1[5] + v245;
          *(_BYTE *)(v271 + 2) = 0;
          *(_WORD *)v271 = 0;
          v270 = *((_DWORD *)a1 + 9) + 3;
          goto LABEL_347;
        case 3u:
          v264 = v244 + 5;
          v265 = *((_DWORD *)a1 + 8);
          if (v264 <= v265)
          {
            v268 = (char *)a1[5];
            v269 = v245;
          }
          else
          {
            if (v265 <= 1)
              v265 = 1;
            v266 = 2 * v265;
            if (v266 <= (int)v264)
              v267 = v264;
            else
              v267 = v266;
            v268 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v267, "Vector Storage (uint8_t, growth)");
            memcpy(v268, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v267;
            a1[5] = v268;
            v269 = *((_DWORD *)a1 + 9);
          }
          memmove(&v268[v245 + 1], &v268[v245], v269 - v245);
          *(_DWORD *)(a1[5] + v245) = 0;
          v270 = *((_DWORD *)a1 + 9) + 4;
LABEL_347:
          *((_DWORD *)a1 + 9) = v270;
          break;
        default:
          break;
      }
    }
  }
  v272 = *(_QWORD *)(a2 + 320);
  if (v272)
  {
    v273 = *(_DWORD *)(v272 + 36);
    v274 = (char)glp_serialized_integer32_control(v273);
    v275 = *((_DWORD *)a1 + 8);
    v276 = *((unsigned int *)a1 + 9);
    v277 = v276 + 1;
    if ((int)v276 + 1 <= v275)
    {
      v280 = (char *)a1[5];
      v281 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v275 <= 1)
        v275 = 1;
      v278 = 2 * v275;
      if (v278 <= v277)
        v279 = v277;
      else
        v279 = v278;
      v280 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v279, "Vector Storage (uint8_t, growth)");
      memcpy(v280, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v279;
      a1[5] = v280;
      v281 = *((_DWORD *)a1 + 9);
    }
    result = memmove(&v280[v276 + 1], &v280[v276], (v281 - v276));
    *(_BYTE *)(a1[5] + v276) = v274;
    v291 = *((_DWORD *)a1 + 9);
    v292 = v291 + 1;
    *((_DWORD *)a1 + 9) = v291 + 1;
    if ((v274 & 0x80000000) != 0)
    {
      switch((v274 >> 1) & 7)
      {
        case 0u:
          v293 = v291 + 2;
          v294 = *((_DWORD *)a1 + 8);
          if (v293 <= v294)
          {
            v297 = (char *)a1[5];
            v298 = v292;
          }
          else
          {
            if (v294 <= 1)
              v294 = 1;
            v295 = 2 * v294;
            if (v295 <= (int)v293)
              v296 = v293;
            else
              v296 = v295;
            v297 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v296, "Vector Storage (uint8_t, growth)");
            memcpy(v297, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v296;
            a1[5] = v297;
            v298 = *((_DWORD *)a1 + 9);
          }
          result = memmove(&v297[v292 + 1], &v297[v292], v298 - v292);
          *(_BYTE *)(a1[5] + v292) = v273;
          v343 = 1;
          goto LABEL_433;
        case 1u:
          v307 = v291 + 3;
          v308 = *((_DWORD *)a1 + 8);
          if (v307 <= v308)
          {
            v311 = (char *)a1[5];
            v312 = v292;
          }
          else
          {
            if (v308 <= 1)
              v308 = 1;
            v309 = 2 * v308;
            if (v309 <= (int)v307)
              v310 = v307;
            else
              v310 = v309;
            v311 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v310, "Vector Storage (uint8_t, growth)");
            memcpy(v311, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v310;
            a1[5] = v311;
            v312 = *((_DWORD *)a1 + 9);
          }
          result = memmove(&v311[v292 + 1], &v311[v292], v312 - v292);
          *(_WORD *)(a1[5] + v292) = v273;
          v343 = 2;
          goto LABEL_433;
        case 2u:
          v313 = v291 + 4;
          v314 = *((_DWORD *)a1 + 8);
          if (v313 <= v314)
          {
            v317 = (char *)a1[5];
            v318 = v292;
          }
          else
          {
            if (v314 <= 1)
              v314 = 1;
            v315 = 2 * v314;
            if (v315 <= (int)v313)
              v316 = v313;
            else
              v316 = v315;
            v317 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v316, "Vector Storage (uint8_t, growth)");
            memcpy(v317, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v316;
            a1[5] = v317;
            v318 = *((_DWORD *)a1 + 9);
          }
          result = memmove(&v317[v292 + 1], &v317[v292], v318 - v292);
          v344 = a1[5] + v292;
          *(_BYTE *)(v344 + 2) = BYTE2(v273);
          *(_WORD *)v344 = v273;
          v343 = 3;
          goto LABEL_433;
        case 3u:
          v319 = v291 + 5;
          v320 = *((_DWORD *)a1 + 8);
          if (v319 <= v320)
          {
            v323 = (char *)a1[5];
            v324 = v292;
          }
          else
          {
            if (v320 <= 1)
              v320 = 1;
            v321 = 2 * v320;
            if (v321 <= (int)v319)
              v322 = v319;
            else
              v322 = v321;
            v323 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v322, "Vector Storage (uint8_t, growth)");
            memcpy(v323, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v322;
            a1[5] = v323;
            v324 = *((_DWORD *)a1 + 9);
          }
          result = memmove(&v323[v292 + 1], &v323[v292], v324 - v292);
          *(_DWORD *)(a1[5] + v292) = v273;
          v343 = 4;
LABEL_433:
          *((_DWORD *)a1 + 9) += v343;
          break;
        default:
          break;
      }
    }
    v345 = *(unsigned int *)(v272 + 32);
    if ((_DWORD)v345)
    {
      v346 = 0;
      for (i = 0; i < v345; ++i)
      {
        v348 = *(_QWORD *)(v272 + 40);
        v349 = *(_QWORD *)(v348 + v346);
        if (v349)
        {
          v350 = *(_DWORD *)(v348 + v346 + 8);
          LOBYTE(v351) = glp_serialized_integer32_control(v350);
          v352 = *((_DWORD *)a1 + 8);
          v353 = *((unsigned int *)a1 + 9);
          v354 = v353 + 1;
          if ((int)v353 + 1 <= v352)
          {
            v357 = (char *)a1[5];
            v358 = *((_DWORD *)a1 + 9);
          }
          else
          {
            if (v352 <= 1)
              v352 = 1;
            v355 = 2 * v352;
            if (v355 <= v354)
              v356 = v354;
            else
              v356 = v355;
            v357 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v356, "Vector Storage (uint8_t, growth)");
            memcpy(v357, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v356;
            a1[5] = v357;
            v358 = *((_DWORD *)a1 + 9);
          }
          v351 = (char)v351;
          memmove(&v357[v353 + 1], &v357[v353], (v358 - v353));
          *(_BYTE *)(a1[5] + v353) = v351;
          v359 = *((_DWORD *)a1 + 9);
          v360 = v359 + 1;
          *((_DWORD *)a1 + 9) = v359 + 1;
          if ((char)v351 < 0)
          {
            switch((v351 >> 1) & 7)
            {
              case 0u:
                v361 = v359 + 2;
                v362 = *((_DWORD *)a1 + 8);
                if (v361 <= v362)
                {
                  v365 = (char *)a1[5];
                  v366 = v360;
                }
                else
                {
                  if (v362 <= 1)
                    v362 = 1;
                  v363 = 2 * v362;
                  if (v363 <= (int)v361)
                    v364 = v361;
                  else
                    v364 = v363;
                  v365 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v364, "Vector Storage (uint8_t, growth)");
                  memcpy(v365, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v364;
                  a1[5] = v365;
                  v366 = *((_DWORD *)a1 + 9);
                }
                memmove(&v365[v360 + 1], &v365[v360], v366 - v360);
                *(_BYTE *)(a1[5] + v360) = v350;
                v385 = 1;
                goto LABEL_483;
              case 1u:
                v367 = v359 + 3;
                v368 = *((_DWORD *)a1 + 8);
                if (v367 <= v368)
                {
                  v371 = (char *)a1[5];
                  v372 = v360;
                }
                else
                {
                  if (v368 <= 1)
                    v368 = 1;
                  v369 = 2 * v368;
                  if (v369 <= (int)v367)
                    v370 = v367;
                  else
                    v370 = v369;
                  v371 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v370, "Vector Storage (uint8_t, growth)");
                  memcpy(v371, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v370;
                  a1[5] = v371;
                  v372 = *((_DWORD *)a1 + 9);
                }
                memmove(&v371[v360 + 1], &v371[v360], v372 - v360);
                *(_WORD *)(a1[5] + v360) = v350;
                v385 = 2;
                goto LABEL_483;
              case 2u:
                v373 = v359 + 4;
                v374 = *((_DWORD *)a1 + 8);
                if (v373 <= v374)
                {
                  v377 = (char *)a1[5];
                  v378 = v360;
                }
                else
                {
                  if (v374 <= 1)
                    v374 = 1;
                  v375 = 2 * v374;
                  if (v375 <= (int)v373)
                    v376 = v373;
                  else
                    v376 = v375;
                  v377 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v376, "Vector Storage (uint8_t, growth)");
                  memcpy(v377, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v376;
                  a1[5] = v377;
                  v378 = *((_DWORD *)a1 + 9);
                }
                memmove(&v377[v360 + 1], &v377[v360], v378 - v360);
                v386 = a1[5] + v360;
                *(_BYTE *)(v386 + 2) = BYTE2(v350);
                *(_WORD *)v386 = v350;
                v385 = 3;
                goto LABEL_483;
              case 3u:
                v379 = v359 + 5;
                v380 = *((_DWORD *)a1 + 8);
                if (v379 <= v380)
                {
                  v383 = (char *)a1[5];
                  v384 = v360;
                }
                else
                {
                  if (v380 <= 1)
                    v380 = 1;
                  v381 = 2 * v380;
                  if (v381 <= (int)v379)
                    v382 = v379;
                  else
                    v382 = v381;
                  v383 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v382, "Vector Storage (uint8_t, growth)");
                  memcpy(v383, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v382;
                  a1[5] = v383;
                  v384 = *((_DWORD *)a1 + 9);
                }
                memmove(&v383[v360 + 1], &v383[v360], v384 - v360);
                *(_DWORD *)(a1[5] + v360) = v350;
                v385 = 4;
LABEL_483:
                *((_DWORD *)a1 + 9) += v385;
                break;
              default:
                break;
            }
          }
          serialize_GLPString(a1, *(const char **)v349, *(_QWORD *)(v349 + 8));
          v387 = *(_DWORD *)(v349 + 16);
          v388 = *((_DWORD *)a1 + 8);
          v389 = *((unsigned int *)a1 + 9);
          v390 = v389 + 4;
          if ((int)v389 + 4 <= v388)
          {
            v393 = (char *)a1[5];
            v394 = *((_DWORD *)a1 + 9);
          }
          else
          {
            if (v388 <= 1)
              v388 = 1;
            v391 = 2 * v388;
            if (v391 <= v390)
              v392 = v390;
            else
              v392 = v391;
            v393 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v392, "Vector Storage (uint8_t, growth)");
            memcpy(v393, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v392;
            a1[5] = v393;
            v394 = *((_DWORD *)a1 + 9);
          }
          memmove(&v393[v389 + 1], &v393[v389], (v394 - v389));
          *(_DWORD *)(a1[5] + v389) = v387;
          v396 = *((_DWORD *)a1 + 8);
          v395 = *((_DWORD *)a1 + 9);
          v397 = v395 + 4;
          *((_DWORD *)a1 + 9) = v395 + 4;
          v398 = *(_DWORD *)(v349 + 20);
          v399 = v395 + 8;
          if (v399 <= v396)
          {
            v402 = (char *)a1[5];
            v403 = v397;
          }
          else
          {
            if (v396 <= 1)
              v396 = 1;
            v400 = 2 * v396;
            if (v400 <= (int)v399)
              v401 = v399;
            else
              v401 = v400;
            v402 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v401, "Vector Storage (uint8_t, growth)");
            memcpy(v402, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v401;
            a1[5] = v402;
            v403 = *((_DWORD *)a1 + 9);
          }
          result = memmove(&v402[v397 + 1], &v402[v397], v403 - v397);
          *(_DWORD *)(a1[5] + v397) = v398;
          *((_DWORD *)a1 + 9) += 4;
          v345 = *(unsigned int *)(v272 + 32);
        }
        v346 += 16;
      }
    }
  }
  else
  {
    v282 = (char)glp_serialized_integer32_control(0);
    v283 = *((_DWORD *)a1 + 8);
    v284 = *((unsigned int *)a1 + 9);
    v285 = v284 + 1;
    if ((int)v284 + 1 <= v283)
    {
      v288 = (char *)a1[5];
      v289 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v283 <= 1)
        v283 = 1;
      v286 = 2 * v283;
      if (v286 <= v285)
        v287 = v285;
      else
        v287 = v286;
      v288 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v287, "Vector Storage (uint8_t, growth)");
      memcpy(v288, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v287;
      a1[5] = v288;
      v289 = *((_DWORD *)a1 + 9);
    }
    result = memmove(&v288[v284 + 1], &v288[v284], (v289 - v284));
    *(_BYTE *)(a1[5] + v284) = v282;
    v299 = *((_DWORD *)a1 + 9);
    v300 = v299 + 1;
    *((_DWORD *)a1 + 9) = v299 + 1;
    if ((v282 & 0x80000000) != 0)
    {
      switch((v282 >> 1) & 7)
      {
        case 0u:
          v301 = v299 + 2;
          v302 = *((_DWORD *)a1 + 8);
          if (v301 <= v302)
          {
            v305 = (char *)a1[5];
            v306 = v300;
          }
          else
          {
            if (v302 <= 1)
              v302 = 1;
            v303 = 2 * v302;
            if (v303 <= (int)v301)
              v304 = v301;
            else
              v304 = v303;
            v305 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v304, "Vector Storage (uint8_t, growth)");
            memcpy(v305, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v304;
            a1[5] = v305;
            v306 = *((_DWORD *)a1 + 9);
          }
          result = memmove(&v305[v300 + 1], &v305[v300], v306 - v300);
          *(_BYTE *)(a1[5] + v300) = 0;
          v404 = 1;
          goto LABEL_511;
        case 1u:
          v325 = v299 + 3;
          v326 = *((_DWORD *)a1 + 8);
          if (v325 <= v326)
          {
            v329 = (char *)a1[5];
            v330 = v300;
          }
          else
          {
            if (v326 <= 1)
              v326 = 1;
            v327 = 2 * v326;
            if (v327 <= (int)v325)
              v328 = v325;
            else
              v328 = v327;
            v329 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v328, "Vector Storage (uint8_t, growth)");
            memcpy(v329, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v328;
            a1[5] = v329;
            v330 = *((_DWORD *)a1 + 9);
          }
          result = memmove(&v329[v300 + 1], &v329[v300], v330 - v300);
          *(_WORD *)(a1[5] + v300) = 0;
          v404 = 2;
          goto LABEL_511;
        case 2u:
          v331 = v299 + 4;
          v332 = *((_DWORD *)a1 + 8);
          if (v331 <= v332)
          {
            v335 = (char *)a1[5];
            v336 = v300;
          }
          else
          {
            if (v332 <= 1)
              v332 = 1;
            v333 = 2 * v332;
            if (v333 <= (int)v331)
              v334 = v331;
            else
              v334 = v333;
            v335 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v334, "Vector Storage (uint8_t, growth)");
            memcpy(v335, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v334;
            a1[5] = v335;
            v336 = *((_DWORD *)a1 + 9);
          }
          result = memmove(&v335[v300 + 1], &v335[v300], v336 - v300);
          v405 = a1[5] + v300;
          *(_BYTE *)(v405 + 2) = 0;
          *(_WORD *)v405 = 0;
          v404 = 3;
          goto LABEL_511;
        case 3u:
          v337 = v299 + 5;
          v338 = *((_DWORD *)a1 + 8);
          if (v337 <= v338)
          {
            v341 = (char *)a1[5];
            v342 = v300;
          }
          else
          {
            if (v338 <= 1)
              v338 = 1;
            v339 = 2 * v338;
            if (v339 <= (int)v337)
              v340 = v337;
            else
              v340 = v339;
            v341 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v340, "Vector Storage (uint8_t, growth)");
            memcpy(v341, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v340;
            a1[5] = v341;
            v342 = *((_DWORD *)a1 + 9);
          }
          result = memmove(&v341[v300 + 1], &v341[v300], v342 - v300);
          *(_DWORD *)(a1[5] + v300) = 0;
          v404 = 4;
LABEL_511:
          *((_DWORD *)a1 + 9) += v404;
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

void *glpSerializeUniformBindings(_QWORD *a1, uint64_t a2)
{
  unsigned int v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  char *v10;
  int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v16;
  uint64_t v17;
  char *v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  int v22;
  uint64_t v23;
  char *v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  int v28;
  uint64_t v29;
  char *v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  int v34;
  uint64_t v35;
  char *v36;
  unsigned int v37;
  int v38;
  uint64_t v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v46;
  char *v47;
  int v48;
  void *result;
  int v50;
  unsigned int v51;
  unsigned int v52;
  int v53;
  int v54;
  uint64_t v55;
  char *v56;
  unsigned int v57;
  unsigned int v58;
  int v59;
  int v60;
  uint64_t v61;
  char *v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  int v66;
  uint64_t v67;
  char *v68;
  unsigned int v69;
  unsigned int v70;
  int v71;
  int v72;
  uint64_t v73;
  char *v74;
  unsigned int v75;
  int v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int *v82;
  char v83;
  int v84;
  uint64_t v85;
  int v86;
  int v87;
  uint64_t v88;
  char *v89;
  int v90;
  int v91;
  unsigned int v92;
  unsigned int v93;
  int v94;
  int v95;
  uint64_t v96;
  char *v97;
  unsigned int v98;
  unsigned int v99;
  int v100;
  int v101;
  uint64_t v102;
  char *v103;
  unsigned int v104;
  unsigned int v105;
  int v106;
  int v107;
  uint64_t v108;
  char *v109;
  unsigned int v110;
  unsigned int v111;
  int v112;
  int v113;
  uint64_t v114;
  char *v115;
  unsigned int v116;
  uint64_t v117;
  int v118;
  int v119;
  int v120;
  uint64_t v121;
  int v122;
  int v123;
  uint64_t v124;
  char *v125;
  int v126;
  int v127;
  int v128;
  unsigned int v129;
  int v130;
  unsigned int v131;
  int v132;
  uint64_t v133;
  char *v134;
  unsigned int v135;
  int v136;
  int v137;
  unsigned int v138;
  int v139;
  unsigned int v140;
  int v141;
  uint64_t v142;
  char *v143;
  unsigned int v144;
  int v145;
  int v146;
  unsigned int v147;
  int v148;
  unsigned int v149;
  int v150;
  uint64_t v151;
  char *v152;
  unsigned int v153;
  int v154;
  int v155;
  unsigned int v156;
  int v157;
  unsigned int v158;
  int v159;
  uint64_t v160;
  char *v161;
  unsigned int v162;
  uint64_t v163;
  unsigned int v164;
  char v165;
  int v166;
  uint64_t v167;
  int v168;
  int v169;
  uint64_t v170;
  char *v171;
  int v172;
  unsigned int v173;
  int v174;
  uint64_t v175;
  int v176;
  int v177;
  uint64_t v178;
  char *v179;
  int v180;
  int v181;
  unsigned int v182;
  unsigned int v183;
  int v184;
  int v185;
  uint64_t v186;
  char *v187;
  unsigned int v188;
  int v189;
  unsigned int v190;
  unsigned int v191;
  int v192;
  int v193;
  uint64_t v194;
  size_t v195;
  unsigned int v196;
  unsigned int v197;
  int v198;
  int v199;
  uint64_t v200;
  char *v201;
  unsigned int v202;
  unsigned int v203;
  int v204;
  int v205;
  uint64_t v206;
  char *v207;
  unsigned int v208;
  unsigned int v209;
  int v210;
  int v211;
  uint64_t v212;
  char *v213;
  unsigned int v214;
  unsigned int v215;
  int v216;
  int v217;
  uint64_t v218;
  unsigned int v219;
  unsigned int v220;
  int v221;
  int v222;
  uint64_t v223;
  unsigned int v224;
  unsigned int v225;
  int v226;
  int v227;
  uint64_t v228;
  unsigned int v229;
  int v230;
  uint64_t v231;
  unsigned int v232;
  char v233;
  int v234;
  uint64_t v235;
  int v236;
  int v237;
  uint64_t v238;
  char *v239;
  int v240;
  int v241;
  unsigned int v242;
  unsigned int v243;
  int v244;
  int v245;
  uint64_t v246;
  char *v247;
  unsigned int v248;
  unsigned int v249;
  int v250;
  int v251;
  uint64_t v252;
  char *v253;
  unsigned int v254;
  unsigned int v255;
  int v256;
  int v257;
  uint64_t v258;
  char *v259;
  unsigned int v260;
  unsigned int v261;
  int v262;
  int v263;
  uint64_t v264;
  char *v265;
  unsigned int v266;
  int v267;
  uint64_t v268;
  int v269;
  int v270;
  int v271;
  uint64_t v272;
  char *v273;
  unsigned int v274;
  uint64_t v275;
  int v276;
  int v277;
  int v278;
  int v279;
  uint64_t v280;
  char *v281;
  unsigned int v282;
  uint64_t v283;
  uint64_t v284;

  v3 = *(_DWORD *)(a2 + 32);
  v4 = (char)glp_serialized_integer32_control(v3);
  v5 = *((_DWORD *)a1 + 8);
  v6 = *((unsigned int *)a1 + 9);
  v7 = v6 + 1;
  if ((int)v6 + 1 <= v5)
  {
    v10 = (char *)a1[5];
    v11 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v5 <= 1)
      v5 = 1;
    v8 = 2 * v5;
    if (v8 <= v7)
      v9 = v7;
    else
      v9 = v8;
    v10 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v9, "Vector Storage (uint8_t, growth)");
    memcpy(v10, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v9;
    a1[5] = v10;
    v11 = *((_DWORD *)a1 + 9);
  }
  memmove(&v10[v6 + 1], &v10[v6], (v11 - v6));
  *(_BYTE *)(a1[5] + v6) = v4;
  v12 = *((_DWORD *)a1 + 9);
  v13 = v12 + 1;
  *((_DWORD *)a1 + 9) = v12 + 1;
  if ((v4 & 0x80000000) != 0)
  {
    switch((v4 >> 1) & 7)
    {
      case 0u:
        v14 = v12 + 2;
        v15 = *((_DWORD *)a1 + 8);
        if (v14 <= v15)
        {
          v18 = (char *)a1[5];
          v19 = v13;
        }
        else
        {
          if (v15 <= 1)
            v15 = 1;
          v16 = 2 * v15;
          if (v16 <= (int)v14)
            v17 = v14;
          else
            v17 = v16;
          v18 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v17, "Vector Storage (uint8_t, growth)");
          memcpy(v18, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v17;
          a1[5] = v18;
          v19 = *((_DWORD *)a1 + 9);
        }
        memmove(&v18[v13 + 1], &v18[v13], v19 - v13);
        *(_BYTE *)(a1[5] + v13) = v3;
        v38 = 1;
        goto LABEL_47;
      case 1u:
        v32 = v12 + 3;
        v33 = *((_DWORD *)a1 + 8);
        if (v32 <= v33)
        {
          v36 = (char *)a1[5];
          v37 = v13;
        }
        else
        {
          if (v33 <= 1)
            v33 = 1;
          v34 = 2 * v33;
          if (v34 <= (int)v32)
            v35 = v32;
          else
            v35 = v34;
          v36 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v35, "Vector Storage (uint8_t, growth)");
          memcpy(v36, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v35;
          a1[5] = v36;
          v37 = *((_DWORD *)a1 + 9);
        }
        memmove(&v36[v13 + 1], &v36[v13], v37 - v13);
        *(_WORD *)(a1[5] + v13) = v3;
        v38 = 2;
        goto LABEL_47;
      case 2u:
        v20 = v12 + 4;
        v21 = *((_DWORD *)a1 + 8);
        if (v20 <= v21)
        {
          v24 = (char *)a1[5];
          v25 = v13;
        }
        else
        {
          if (v21 <= 1)
            v21 = 1;
          v22 = 2 * v21;
          if (v22 <= (int)v20)
            v23 = v20;
          else
            v23 = v22;
          v24 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v23, "Vector Storage (uint8_t, growth)");
          memcpy(v24, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v23;
          a1[5] = v24;
          v25 = *((_DWORD *)a1 + 9);
        }
        memmove(&v24[v13 + 1], &v24[v13], v25 - v13);
        v39 = a1[5] + v13;
        *(_BYTE *)(v39 + 2) = BYTE2(v3);
        *(_WORD *)v39 = v3;
        v38 = 3;
        goto LABEL_47;
      case 3u:
        v26 = v12 + 5;
        v27 = *((_DWORD *)a1 + 8);
        if (v26 <= v27)
        {
          v30 = (char *)a1[5];
          v31 = v13;
        }
        else
        {
          if (v27 <= 1)
            v27 = 1;
          v28 = 2 * v27;
          if (v28 <= (int)v26)
            v29 = v26;
          else
            v29 = v28;
          v30 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v29, "Vector Storage (uint8_t, growth)");
          memcpy(v30, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v29;
          a1[5] = v30;
          v31 = *((_DWORD *)a1 + 9);
        }
        memmove(&v30[v13 + 1], &v30[v13], v31 - v13);
        *(_DWORD *)(a1[5] + v13) = v3;
        v38 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v38;
        break;
      default:
        break;
    }
  }
  v40 = *(_DWORD *)(a2 + 36);
  v41 = (char)glp_serialized_integer32_control(v40);
  v42 = *((_DWORD *)a1 + 8);
  v43 = *((unsigned int *)a1 + 9);
  v44 = v43 + 1;
  if ((int)v43 + 1 <= v42)
  {
    v47 = (char *)a1[5];
    v48 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v42 <= 1)
      v42 = 1;
    v45 = 2 * v42;
    if (v45 <= v44)
      v46 = v44;
    else
      v46 = v45;
    v47 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v46, "Vector Storage (uint8_t, growth)");
    memcpy(v47, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v46;
    a1[5] = v47;
    v48 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v47[v43 + 1], &v47[v43], (v48 - v43));
  *(_BYTE *)(a1[5] + v43) = v41;
  v50 = *((_DWORD *)a1 + 9);
  v51 = v50 + 1;
  *((_DWORD *)a1 + 9) = v50 + 1;
  if ((v41 & 0x80000000) != 0)
  {
    switch((v41 >> 1) & 7)
    {
      case 0u:
        v52 = v50 + 2;
        v53 = *((_DWORD *)a1 + 8);
        if (v52 <= v53)
        {
          v56 = (char *)a1[5];
          v57 = v51;
        }
        else
        {
          if (v53 <= 1)
            v53 = 1;
          v54 = 2 * v53;
          if (v54 <= (int)v52)
            v55 = v52;
          else
            v55 = v54;
          v56 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v55, "Vector Storage (uint8_t, growth)");
          memcpy(v56, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v55;
          a1[5] = v56;
          v57 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v56[v51 + 1], &v56[v51], v57 - v51);
        *(_BYTE *)(a1[5] + v51) = v40;
        v76 = 1;
        goto LABEL_94;
      case 1u:
        v70 = v50 + 3;
        v71 = *((_DWORD *)a1 + 8);
        if (v70 <= v71)
        {
          v74 = (char *)a1[5];
          v75 = v51;
        }
        else
        {
          if (v71 <= 1)
            v71 = 1;
          v72 = 2 * v71;
          if (v72 <= (int)v70)
            v73 = v70;
          else
            v73 = v72;
          v74 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v73, "Vector Storage (uint8_t, growth)");
          memcpy(v74, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v73;
          a1[5] = v74;
          v75 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v74[v51 + 1], &v74[v51], v75 - v51);
        *(_WORD *)(a1[5] + v51) = v40;
        v76 = 2;
        goto LABEL_94;
      case 2u:
        v58 = v50 + 4;
        v59 = *((_DWORD *)a1 + 8);
        if (v58 <= v59)
        {
          v62 = (char *)a1[5];
          v63 = v51;
        }
        else
        {
          if (v59 <= 1)
            v59 = 1;
          v60 = 2 * v59;
          if (v60 <= (int)v58)
            v61 = v58;
          else
            v61 = v60;
          v62 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v61, "Vector Storage (uint8_t, growth)");
          memcpy(v62, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v61;
          a1[5] = v62;
          v63 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v62[v51 + 1], &v62[v51], v63 - v51);
        v77 = a1[5] + v51;
        *(_BYTE *)(v77 + 2) = BYTE2(v40);
        *(_WORD *)v77 = v40;
        v76 = 3;
        goto LABEL_94;
      case 3u:
        v64 = v50 + 5;
        v65 = *((_DWORD *)a1 + 8);
        if (v64 <= v65)
        {
          v68 = (char *)a1[5];
          v69 = v51;
        }
        else
        {
          if (v65 <= 1)
            v65 = 1;
          v66 = 2 * v65;
          if (v66 <= (int)v64)
            v67 = v64;
          else
            v67 = v66;
          v68 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v67, "Vector Storage (uint8_t, growth)");
          memcpy(v68, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v67;
          a1[5] = v68;
          v69 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v68[v51 + 1], &v68[v51], v69 - v51);
        *(_DWORD *)(a1[5] + v51) = v40;
        v76 = 4;
LABEL_94:
        *((_DWORD *)a1 + 9) += v76;
        break;
      default:
        break;
    }
  }
  v78 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v78)
  {
    v79 = 0;
    v80 = 0;
    v81 = *(_QWORD *)(a2 + 40);
    v284 = v81;
    do
    {
      v82 = *(int **)(v81 + 32 * v79);
      if (v82)
      {
        v83 = glp_serialized_integer32_control(v80);
        v84 = *((_DWORD *)a1 + 8);
        v85 = *((unsigned int *)a1 + 9);
        v86 = v85 + 1;
        if ((int)v85 + 1 <= v84)
        {
          v89 = (char *)a1[5];
          v90 = *((_DWORD *)a1 + 9);
        }
        else
        {
          if (v84 <= 1)
            v84 = 1;
          v87 = 2 * v84;
          if (v87 <= v86)
            v88 = v86;
          else
            v88 = v87;
          v89 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v88, "Vector Storage (uint8_t, growth)");
          memcpy(v89, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v88;
          a1[5] = v89;
          v90 = *((_DWORD *)a1 + 9);
        }
        memmove(&v89[v85 + 1], &v89[v85], (v90 - v85));
        *(_BYTE *)(a1[5] + v85) = v83;
        v91 = *((_DWORD *)a1 + 9);
        v92 = v91 + 1;
        *((_DWORD *)a1 + 9) = v91 + 1;
        if (v83 < 0)
        {
          switch((v83 >> 1) & 7)
          {
            case 0u:
              v93 = v91 + 2;
              v94 = *((_DWORD *)a1 + 8);
              if (v93 <= v94)
              {
                v97 = (char *)a1[5];
                v98 = v92;
              }
              else
              {
                if (v94 <= 1)
                  v94 = 1;
                v95 = 2 * v94;
                if (v95 <= (int)v93)
                  v96 = v93;
                else
                  v96 = v95;
                v97 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v96, "Vector Storage (uint8_t, growth)");
                memcpy(v97, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v96;
                a1[5] = v97;
                v98 = *((_DWORD *)a1 + 9);
              }
              memmove(&v97[v92 + 1], &v97[v92], v98 - v92);
              *(_BYTE *)(a1[5] + v92) = v80;
              v118 = 1;
              goto LABEL_145;
            case 1u:
              v111 = v91 + 3;
              v112 = *((_DWORD *)a1 + 8);
              if (v111 <= v112)
              {
                v115 = (char *)a1[5];
                v116 = v92;
              }
              else
              {
                if (v112 <= 1)
                  v112 = 1;
                v113 = 2 * v112;
                if (v113 <= (int)v111)
                  v114 = v111;
                else
                  v114 = v113;
                v115 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v114, "Vector Storage (uint8_t, growth)");
                memcpy(v115, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v114;
                a1[5] = v115;
                v116 = *((_DWORD *)a1 + 9);
              }
              memmove(&v115[v92 + 1], &v115[v92], v116 - v92);
              *(_WORD *)(a1[5] + v92) = v80;
              v118 = 2;
              goto LABEL_145;
            case 2u:
              v99 = v91 + 4;
              v100 = *((_DWORD *)a1 + 8);
              if (v99 <= v100)
              {
                v103 = (char *)a1[5];
                v104 = v92;
              }
              else
              {
                if (v100 <= 1)
                  v100 = 1;
                v101 = 2 * v100;
                if (v101 <= (int)v99)
                  v102 = v99;
                else
                  v102 = v101;
                v103 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v102, "Vector Storage (uint8_t, growth)");
                memcpy(v103, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v102;
                a1[5] = v103;
                v104 = *((_DWORD *)a1 + 9);
              }
              memmove(&v103[v92 + 1], &v103[v92], v104 - v92);
              v117 = a1[5] + v92;
              *(_BYTE *)(v117 + 2) = BYTE2(v80);
              *(_WORD *)v117 = v80;
              v118 = 3;
              goto LABEL_145;
            case 3u:
              v105 = v91 + 5;
              v106 = *((_DWORD *)a1 + 8);
              if (v105 <= v106)
              {
                v109 = (char *)a1[5];
                v110 = v92;
              }
              else
              {
                if (v106 <= 1)
                  v106 = 1;
                v107 = 2 * v106;
                if (v107 <= (int)v105)
                  v108 = v105;
                else
                  v108 = v107;
                v109 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v108, "Vector Storage (uint8_t, growth)");
                memcpy(v109, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v108;
                a1[5] = v109;
                v110 = *((_DWORD *)a1 + 9);
              }
              memmove(&v109[v92 + 1], &v109[v92], v110 - v92);
              *(_DWORD *)(a1[5] + v92) = v80;
              v118 = 4;
LABEL_145:
              *((_DWORD *)a1 + 9) += v118;
              break;
            default:
              break;
          }
        }
        serialize_GLPString(a1, *(const char **)(v81 + 32 * v79 + 8), *(_QWORD *)(v81 + 32 * v79 + 16));
        v119 = *v82;
        v120 = *((_DWORD *)a1 + 8);
        v121 = *((unsigned int *)a1 + 9);
        v122 = v121 + 4;
        if ((int)v121 + 4 <= v120)
        {
          v125 = (char *)a1[5];
          v126 = *((_DWORD *)a1 + 9);
        }
        else
        {
          if (v120 <= 1)
            v120 = 1;
          v123 = 2 * v120;
          if (v123 <= v122)
            v124 = v122;
          else
            v124 = v123;
          v125 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v124, "Vector Storage (uint8_t, growth)");
          memcpy(v125, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v124;
          a1[5] = v125;
          v126 = *((_DWORD *)a1 + 9);
        }
        memmove(&v125[v121 + 1], &v125[v121], (v126 - v121));
        *(_DWORD *)(a1[5] + v121) = v119;
        v128 = *((_DWORD *)a1 + 8);
        v127 = *((_DWORD *)a1 + 9);
        v129 = v127 + 4;
        *((_DWORD *)a1 + 9) = v127 + 4;
        v130 = v82[1];
        v131 = v127 + 8;
        if (v131 <= v128)
        {
          v134 = (char *)a1[5];
          v135 = v129;
        }
        else
        {
          if (v128 <= 1)
            v128 = 1;
          v132 = 2 * v128;
          if (v132 <= (int)v131)
            v133 = v131;
          else
            v133 = v132;
          v134 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v133, "Vector Storage (uint8_t, growth)");
          memcpy(v134, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v133;
          a1[5] = v134;
          v135 = *((_DWORD *)a1 + 9);
        }
        memmove(&v134[v129 + 1], &v134[v129], v135 - v129);
        *(_DWORD *)(a1[5] + v129) = v130;
        v137 = *((_DWORD *)a1 + 8);
        v136 = *((_DWORD *)a1 + 9);
        v138 = v136 + 4;
        *((_DWORD *)a1 + 9) = v136 + 4;
        v139 = v82[2];
        v140 = v136 + 8;
        if (v140 <= v137)
        {
          v143 = (char *)a1[5];
          v144 = v138;
        }
        else
        {
          if (v137 <= 1)
            v137 = 1;
          v141 = 2 * v137;
          if (v141 <= (int)v140)
            v142 = v140;
          else
            v142 = v141;
          v143 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v142, "Vector Storage (uint8_t, growth)");
          memcpy(v143, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v142;
          a1[5] = v143;
          v144 = *((_DWORD *)a1 + 9);
        }
        memmove(&v143[v138 + 1], &v143[v138], v144 - v138);
        *(_DWORD *)(a1[5] + v138) = v139;
        v146 = *((_DWORD *)a1 + 8);
        v145 = *((_DWORD *)a1 + 9);
        v147 = v145 + 4;
        *((_DWORD *)a1 + 9) = v145 + 4;
        v148 = v82[3];
        v149 = v145 + 8;
        if (v149 <= v146)
        {
          v152 = (char *)a1[5];
          v153 = v147;
        }
        else
        {
          if (v146 <= 1)
            v146 = 1;
          v150 = 2 * v146;
          if (v150 <= (int)v149)
            v151 = v149;
          else
            v151 = v150;
          v152 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v151, "Vector Storage (uint8_t, growth)");
          memcpy(v152, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v151;
          a1[5] = v152;
          v153 = *((_DWORD *)a1 + 9);
        }
        memmove(&v152[v147 + 1], &v152[v147], v153 - v147);
        *(_DWORD *)(a1[5] + v147) = v148;
        v155 = *((_DWORD *)a1 + 8);
        v154 = *((_DWORD *)a1 + 9);
        v156 = v154 + 4;
        *((_DWORD *)a1 + 9) = v154 + 4;
        v157 = *((unsigned __int8 *)v82 + 80);
        v158 = v154 + 8;
        if (v158 <= v155)
        {
          v161 = (char *)a1[5];
          v162 = v156;
        }
        else
        {
          if (v155 <= 1)
            v155 = 1;
          v159 = 2 * v155;
          if (v159 <= (int)v158)
            v160 = v158;
          else
            v160 = v159;
          v161 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v160, "Vector Storage (uint8_t, growth)");
          memcpy(v161, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v160;
          a1[5] = v161;
          v162 = *((_DWORD *)a1 + 9);
        }
        memmove(&v161[v156 + 1], &v161[v156], v162 - v156);
        *(_DWORD *)(a1[5] + v156) = v157;
        *((_DWORD *)a1 + 9) += 4;
        serialize_GLPType(a1, *((_QWORD *)v82 + 3));
        real_serialize_GLPValue(a1, *((_QWORD *)v82 + 2), *((unsigned int **)v82 + 3));
        v163 = *((_QWORD *)v82 + 4);
        if (v163)
        {
          v164 = *(_DWORD *)(v163 + 32);
          v165 = glp_serialized_integer32_control(v164);
          v166 = *((_DWORD *)a1 + 8);
          v167 = *((unsigned int *)a1 + 9);
          v168 = v167 + 1;
          if ((int)v167 + 1 <= v166)
          {
            v171 = (char *)a1[5];
            v172 = *((_DWORD *)a1 + 9);
          }
          else
          {
            if (v166 <= 1)
              v166 = 1;
            v169 = 2 * v166;
            if (v169 <= v168)
              v170 = v168;
            else
              v170 = v169;
            v171 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v170, "Vector Storage (uint8_t, growth)");
            memcpy(v171, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v170;
            a1[5] = v171;
            v172 = *((_DWORD *)a1 + 9);
          }
          memmove(&v171[v167 + 1], &v171[v167], (v172 - v167));
          *(_BYTE *)(a1[5] + v167) = v165;
          v181 = *((_DWORD *)a1 + 9);
          v182 = v181 + 1;
          *((_DWORD *)a1 + 9) = v181 + 1;
          if (v165 < 0)
          {
            switch((v165 >> 1) & 7)
            {
              case 0u:
                v183 = v181 + 2;
                v184 = *((_DWORD *)a1 + 8);
                if (v183 <= v184)
                {
                  v187 = (char *)a1[5];
                  v188 = v182;
                }
                else
                {
                  if (v184 <= 1)
                    v184 = 1;
                  v185 = 2 * v184;
                  if (v185 <= (int)v183)
                    v186 = v183;
                  else
                    v186 = v185;
                  v187 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v186, "Vector Storage (uint8_t, growth)");
                  memcpy(v187, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v186;
                  a1[5] = v187;
                  v188 = *((_DWORD *)a1 + 9);
                }
                memmove(&v187[v182 + 1], &v187[v182], v188 - v182);
                *(_BYTE *)(a1[5] + v182) = v164;
                v230 = 1;
                goto LABEL_271;
              case 1u:
                v209 = v181 + 3;
                v210 = *((_DWORD *)a1 + 8);
                if (v209 <= v210)
                {
                  v213 = (char *)a1[5];
                  v214 = v182;
                }
                else
                {
                  if (v210 <= 1)
                    v210 = 1;
                  v211 = 2 * v210;
                  if (v211 <= (int)v209)
                    v212 = v209;
                  else
                    v212 = v211;
                  v213 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v212, "Vector Storage (uint8_t, growth)");
                  memcpy(v213, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v212;
                  a1[5] = v213;
                  v214 = *((_DWORD *)a1 + 9);
                }
                memmove(&v213[v182 + 1], &v213[v182], v214 - v182);
                *(_WORD *)(a1[5] + v182) = v164;
                v230 = 2;
                goto LABEL_271;
              case 2u:
                v197 = v181 + 4;
                v198 = *((_DWORD *)a1 + 8);
                if (v197 <= v198)
                {
                  v201 = (char *)a1[5];
                  v202 = v182;
                }
                else
                {
                  if (v198 <= 1)
                    v198 = 1;
                  v199 = 2 * v198;
                  if (v199 <= (int)v197)
                    v200 = v197;
                  else
                    v200 = v199;
                  v201 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v200, "Vector Storage (uint8_t, growth)");
                  memcpy(v201, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v200;
                  a1[5] = v201;
                  v202 = *((_DWORD *)a1 + 9);
                }
                memmove(&v201[v182 + 1], &v201[v182], v202 - v182);
                v231 = a1[5] + v182;
                *(_BYTE *)(v231 + 2) = BYTE2(v164);
                *(_WORD *)v231 = v164;
                v230 = 3;
                goto LABEL_271;
              case 3u:
                v203 = v181 + 5;
                v204 = *((_DWORD *)a1 + 8);
                if (v203 <= v204)
                {
                  v207 = (char *)a1[5];
                  v208 = v182;
                }
                else
                {
                  if (v204 <= 1)
                    v204 = 1;
                  v205 = 2 * v204;
                  if (v205 <= (int)v203)
                    v206 = v203;
                  else
                    v206 = v205;
                  v207 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v206, "Vector Storage (uint8_t, growth)");
                  memcpy(v207, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v206;
                  a1[5] = v207;
                  v208 = *((_DWORD *)a1 + 9);
                }
                memmove(&v207[v182 + 1], &v207[v182], v208 - v182);
                *(_DWORD *)(a1[5] + v182) = v164;
                v230 = 4;
LABEL_271:
                *((_DWORD *)a1 + 9) += v230;
                break;
              default:
                break;
            }
          }
          v232 = *(_DWORD *)(v163 + 36);
          v233 = glp_serialized_integer32_control(v232);
          v234 = *((_DWORD *)a1 + 8);
          v235 = *((unsigned int *)a1 + 9);
          v236 = v235 + 1;
          if ((int)v235 + 1 <= v234)
          {
            v239 = (char *)a1[5];
            v240 = *((_DWORD *)a1 + 9);
          }
          else
          {
            if (v234 <= 1)
              v234 = 1;
            v237 = 2 * v234;
            if (v237 <= v236)
              v238 = v236;
            else
              v238 = v237;
            v239 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v238, "Vector Storage (uint8_t, growth)");
            memcpy(v239, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v238;
            a1[5] = v239;
            v240 = *((_DWORD *)a1 + 9);
          }
          memmove(&v239[v235 + 1], &v239[v235], (v240 - v235));
          *(_BYTE *)(a1[5] + v235) = v233;
          v241 = *((_DWORD *)a1 + 9);
          v242 = v241 + 1;
          *((_DWORD *)a1 + 9) = v241 + 1;
          if (v233 < 0)
          {
            switch((v233 >> 1) & 7)
            {
              case 0u:
                v243 = v241 + 2;
                v244 = *((_DWORD *)a1 + 8);
                if (v243 <= v244)
                {
                  v247 = (char *)a1[5];
                  v248 = v242;
                }
                else
                {
                  if (v244 <= 1)
                    v244 = 1;
                  v245 = 2 * v244;
                  if (v245 <= (int)v243)
                    v246 = v243;
                  else
                    v246 = v245;
                  v247 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v246, "Vector Storage (uint8_t, growth)");
                  memcpy(v247, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v246;
                  a1[5] = v247;
                  v248 = *((_DWORD *)a1 + 9);
                }
                memmove(&v247[v242 + 1], &v247[v242], v248 - v242);
                *(_BYTE *)(a1[5] + v242) = v232;
                v267 = 1;
                goto LABEL_318;
              case 1u:
                v261 = v241 + 3;
                v262 = *((_DWORD *)a1 + 8);
                if (v261 <= v262)
                {
                  v265 = (char *)a1[5];
                  v266 = v242;
                }
                else
                {
                  if (v262 <= 1)
                    v262 = 1;
                  v263 = 2 * v262;
                  if (v263 <= (int)v261)
                    v264 = v261;
                  else
                    v264 = v263;
                  v265 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v264, "Vector Storage (uint8_t, growth)");
                  memcpy(v265, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v264;
                  a1[5] = v265;
                  v266 = *((_DWORD *)a1 + 9);
                }
                memmove(&v265[v242 + 1], &v265[v242], v266 - v242);
                *(_WORD *)(a1[5] + v242) = v232;
                v267 = 2;
                goto LABEL_318;
              case 2u:
                v249 = v241 + 4;
                v250 = *((_DWORD *)a1 + 8);
                if (v249 <= v250)
                {
                  v253 = (char *)a1[5];
                  v254 = v242;
                }
                else
                {
                  if (v250 <= 1)
                    v250 = 1;
                  v251 = 2 * v250;
                  if (v251 <= (int)v249)
                    v252 = v249;
                  else
                    v252 = v251;
                  v253 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v252, "Vector Storage (uint8_t, growth)");
                  memcpy(v253, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v252;
                  a1[5] = v253;
                  v254 = *((_DWORD *)a1 + 9);
                }
                memmove(&v253[v242 + 1], &v253[v242], v254 - v242);
                v268 = a1[5] + v242;
                *(_BYTE *)(v268 + 2) = BYTE2(v232);
                *(_WORD *)v268 = v232;
                v267 = 3;
                goto LABEL_318;
              case 3u:
                v255 = v241 + 5;
                v256 = *((_DWORD *)a1 + 8);
                if (v255 <= v256)
                {
                  v259 = (char *)a1[5];
                  v260 = v242;
                }
                else
                {
                  if (v256 <= 1)
                    v256 = 1;
                  v257 = 2 * v256;
                  if (v257 <= (int)v255)
                    v258 = v255;
                  else
                    v258 = v257;
                  v259 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v258, "Vector Storage (uint8_t, growth)");
                  memcpy(v259, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v258;
                  a1[5] = v259;
                  v260 = *((_DWORD *)a1 + 9);
                }
                memmove(&v259[v242 + 1], &v259[v242], v260 - v242);
                *(_DWORD *)(a1[5] + v242) = v232;
                v267 = 4;
LABEL_318:
                v242 = *((_DWORD *)a1 + 9) + v267;
                *((_DWORD *)a1 + 9) = v242;
                break;
              default:
                break;
            }
          }
          v195 = *(unsigned int *)(v163 + 36);
          v269 = v195 + v242;
          v270 = *((_DWORD *)a1 + 8);
          if (v195 + v242 <= v270)
          {
            v273 = (char *)a1[5];
            v274 = v242;
          }
          else
          {
            if (v270 <= 1)
              v270 = 1;
            v271 = 2 * v270;
            if (v271 <= v269)
              v272 = v269;
            else
              v272 = v271;
            v273 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v272, "Vector Storage (uint8_t, growth)");
            memcpy(v273, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v272;
            a1[5] = v273;
            v274 = *((_DWORD *)a1 + 9);
          }
          memmove(&v273[v242 + 1], &v273[v242], v274 - v242);
          memcpy((void *)(a1[5] + v242), *(const void **)(v163 + 40), v195);
LABEL_328:
          v190 = *((_DWORD *)a1 + 9) + v195;
          *((_DWORD *)a1 + 9) = v190;
        }
        else
        {
          LOBYTE(v173) = glp_serialized_integer32_control(0);
          v174 = *((_DWORD *)a1 + 8);
          v175 = *((unsigned int *)a1 + 9);
          v176 = v175 + 1;
          if ((int)v175 + 1 <= v174)
          {
            v179 = (char *)a1[5];
            v180 = *((_DWORD *)a1 + 9);
          }
          else
          {
            if (v174 <= 1)
              v174 = 1;
            v177 = 2 * v174;
            if (v177 <= v176)
              v178 = v176;
            else
              v178 = v177;
            v179 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v178, "Vector Storage (uint8_t, growth)");
            memcpy(v179, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v178;
            a1[5] = v179;
            v180 = *((_DWORD *)a1 + 9);
          }
          v173 = (char)v173;
          memmove(&v179[v175 + 1], &v179[v175], (v180 - v175));
          *(_BYTE *)(a1[5] + v175) = v173;
          v189 = *((_DWORD *)a1 + 9);
          v190 = v189 + 1;
          *((_DWORD *)a1 + 9) = v189 + 1;
          if ((char)v173 < 0)
          {
            switch((v173 >> 1) & 7)
            {
              case 0u:
                v191 = v189 + 2;
                v192 = *((_DWORD *)a1 + 8);
                if (v191 <= v192)
                {
                  v195 = a1[5];
                  v196 = v190;
                }
                else
                {
                  if (v192 <= 1)
                    v192 = 1;
                  v193 = 2 * v192;
                  if (v193 <= (int)v191)
                    v194 = v191;
                  else
                    v194 = v193;
                  v195 = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v194, "Vector Storage (uint8_t, growth)");
                  memcpy((void *)v195, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v194;
                  a1[5] = v195;
                  v196 = *((_DWORD *)a1 + 9);
                }
                memmove((void *)(v195 + v190 + 1), (const void *)(v195 + v190), v196 - v190);
                *(_BYTE *)(a1[5] + v190) = 0;
                LODWORD(v195) = 1;
                goto LABEL_328;
              case 1u:
                v215 = v189 + 3;
                v216 = *((_DWORD *)a1 + 8);
                if (v215 <= v216)
                {
                  v195 = a1[5];
                  v219 = v190;
                }
                else
                {
                  if (v216 <= 1)
                    v216 = 1;
                  v217 = 2 * v216;
                  if (v217 <= (int)v215)
                    v218 = v215;
                  else
                    v218 = v217;
                  v195 = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v218, "Vector Storage (uint8_t, growth)");
                  memcpy((void *)v195, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v218;
                  a1[5] = v195;
                  v219 = *((_DWORD *)a1 + 9);
                }
                memmove((void *)(v195 + v190 + 1), (const void *)(v195 + v190), v219 - v190);
                *(_WORD *)(a1[5] + v190) = 0;
                LODWORD(v195) = 2;
                goto LABEL_328;
              case 2u:
                v220 = v189 + 4;
                v221 = *((_DWORD *)a1 + 8);
                if (v220 <= v221)
                {
                  v195 = a1[5];
                  v224 = v190;
                }
                else
                {
                  if (v221 <= 1)
                    v221 = 1;
                  v222 = 2 * v221;
                  if (v222 <= (int)v220)
                    v223 = v220;
                  else
                    v223 = v222;
                  v195 = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v223, "Vector Storage (uint8_t, growth)");
                  memcpy((void *)v195, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v223;
                  a1[5] = v195;
                  v224 = *((_DWORD *)a1 + 9);
                }
                memmove((void *)(v195 + v190 + 1), (const void *)(v195 + v190), v224 - v190);
                v283 = a1[5] + v190;
                *(_BYTE *)(v283 + 2) = 0;
                *(_WORD *)v283 = 0;
                LODWORD(v195) = 3;
                goto LABEL_328;
              case 3u:
                v225 = v189 + 5;
                v226 = *((_DWORD *)a1 + 8);
                if (v225 <= v226)
                {
                  v195 = a1[5];
                  v229 = v190;
                }
                else
                {
                  if (v226 <= 1)
                    v226 = 1;
                  v227 = 2 * v226;
                  if (v227 <= (int)v225)
                    v228 = v225;
                  else
                    v228 = v227;
                  v195 = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v228, "Vector Storage (uint8_t, growth)");
                  memcpy((void *)v195, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v228;
                  a1[5] = v195;
                  v229 = *((_DWORD *)a1 + 9);
                }
                memmove((void *)(v195 + v190 + 1), (const void *)(v195 + v190), v229 - v190);
                *(_DWORD *)(a1[5] + v190) = 0;
                LODWORD(v195) = 4;
                goto LABEL_328;
              default:
                break;
            }
          }
        }
        v275 = 0;
        do
        {
          v276 = v82[v275 + 10];
          v277 = v190 + 4;
          v278 = *((_DWORD *)a1 + 8);
          if (v190 + 4 <= v278)
          {
            v281 = (char *)a1[5];
            v282 = v190;
          }
          else
          {
            if (v278 <= 1)
              v278 = 1;
            v279 = 2 * v278;
            if (v279 <= v277)
              v280 = v277;
            else
              v280 = v279;
            v281 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v280, "Vector Storage (uint8_t, growth)");
            memcpy(v281, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v280;
            a1[5] = v281;
            v282 = *((_DWORD *)a1 + 9);
          }
          ++v275;
          result = memmove(&v281[v190 + 1], &v281[v190], v282 - v190);
          *(_DWORD *)(a1[5] + v190) = v276;
          v190 = *((_DWORD *)a1 + 9) + 4;
          *((_DWORD *)a1 + 9) = v190;
        }
        while (v275 != 5);
        v80 = 0;
        v81 = v284;
        v78 = *(unsigned int *)(a2 + 32);
      }
      else
      {
        v80 = (v80 + 1);
      }
      ++v79;
    }
    while (v79 < v78);
  }
  return result;
}

_QWORD *glpLinkProgramFromLinkerOutput(uint64_t a1, int a2, _OWORD *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  size_t v15;
  void *v16;
  size_t v17;
  void *v18;
  size_t v19;
  void *v20;
  size_t v21;
  void *v22;
  size_t v23;
  void *v24;
  uint64_t StringHash;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  int v38;
  unsigned int v39;
  char *v40;
  int v41;
  int v42;
  uint64_t v43;
  size_t v44;
  _DWORD *v45;
  uint64_t v46;
  _QWORD *v47;
  unint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  unsigned int v52;
  uint64_t v53;
  _QWORD *v54;
  int v55;
  uint64_t v56;
  int v57;
  int v58;
  uint64_t v59;
  _QWORD *v60;
  uint64_t v61;
  const void *v62;
  uint64_t v63;
  uint64_t v64;
  size_t v65;
  char *v66;
  char *v67;
  double v68;
  unsigned int v69;
  unsigned int v70;
  uint64_t v71;
  int v72;
  unint64_t v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  _DWORD *v80;
  __int128 v81;
  __int128 v82;
  _OWORD v84[2];
  _OWORD v85[15];
  __int128 v86;
  uint64_t v87;
  uint64_t v88;

  v88 = *MEMORY[0x24BDAC8D0];
  v6 = malloc_type_calloc(1uLL, 0x148uLL, 0xA92C9FCEuLL);
  if (!v6)
LABEL_78:
    abort();
  v7 = v6;
  v6[40] = 0;
  *((_OWORD *)v6 + 18) = 0u;
  *((_OWORD *)v6 + 19) = 0u;
  *((_OWORD *)v6 + 16) = 0u;
  *((_OWORD *)v6 + 17) = 0u;
  *((_OWORD *)v6 + 14) = 0u;
  *((_OWORD *)v6 + 15) = 0u;
  *((_OWORD *)v6 + 12) = 0u;
  *((_OWORD *)v6 + 13) = 0u;
  *((_OWORD *)v6 + 10) = 0u;
  *((_OWORD *)v6 + 11) = 0u;
  *((_OWORD *)v6 + 8) = 0u;
  *((_OWORD *)v6 + 9) = 0u;
  *((_OWORD *)v6 + 6) = 0u;
  *((_OWORD *)v6 + 7) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *((_OWORD *)v6 + 5) = 0u;
  *((_OWORD *)v6 + 2) = 0u;
  *((_OWORD *)v6 + 3) = 0u;
  v8 = (unsigned int *)(a3 + 6);
  v9 = 5;
  *(_OWORD *)v6 = 0u;
  *((_OWORD *)v6 + 1) = 0u;
  do
  {
    if (*(v8 - 2))
    {
      if (v8[1])
      {
        v10 = (uint64_t)a3 + *v8;
        v11 = PPStreamCreate();
        PPStreamAttachStream(v11, v10);
        v7[v9 - 5] = v11;
      }
      if (v8[3])
      {
        glpCreateShaderByteCode();
        v13 = v12;
        v14 = malloc_type_malloc(v8[3], 0x7081ABB9uLL);
        if (!v14)
          goto LABEL_78;
        *(_QWORD *)v13 = v14;
        memcpy(v14, (char *)a3 + v8[2], v8[3]);
        v15 = v8[7];
        if ((_DWORD)v15)
        {
          v16 = malloc_type_malloc(v15, 0x7081ABB9uLL);
          if (!v16)
            goto LABEL_78;
          *(_QWORD *)(v13 + 8) = v16;
          memcpy(v16, (char *)a3 + v8[6], v8[7]);
        }
        v17 = v8[5];
        if ((_DWORD)v17)
        {
          v18 = malloc_type_malloc(v17, 0x7081ABB9uLL);
          if (!v18)
            goto LABEL_78;
          *(_QWORD *)(v13 + 40) = v18;
          memcpy(v18, (char *)a3 + v8[4], v8[5]);
        }
        v19 = v8[9];
        if ((_DWORD)v19)
        {
          v20 = malloc_type_malloc(v19, 0x7081ABB9uLL);
          if (!v20)
            goto LABEL_78;
          *(_QWORD *)(v13 + 16) = v20;
          memcpy(v20, (char *)a3 + v8[8], v8[9]);
        }
        v21 = v8[11];
        if ((_DWORD)v21)
        {
          v22 = malloc_type_malloc(v21, 0x7081ABB9uLL);
          if (!v22)
            goto LABEL_78;
          *(_QWORD *)(v13 + 24) = v22;
          memcpy(v22, (char *)a3 + v8[10], v8[11]);
        }
        v23 = v8[13];
        if ((_DWORD)v23)
        {
          v24 = malloc_type_malloc(v23, 0x7081ABB9uLL);
          if (!v24)
            goto LABEL_78;
          *(_QWORD *)(v13 + 32) = v24;
          memcpy(v24, (char *)a3 + v8[12], v8[13]);
        }
        *(_DWORD *)(v13 + 48) = v8[14];
        *(_QWORD *)(v13 + 72) = *((_QWORD *)v8 + 10);
        *(_QWORD *)(v13 + 80) = *((_QWORD *)v8 + 11);
        *(_DWORD *)(v13 + 52) = v8[15];
        *(_OWORD *)(v13 + 56) = *((_OWORD *)v8 + 4);
        v7[v9] = v13;
      }
    }
    ++v9;
    v8 += 26;
  }
  while (v9 != 10);
  memset(v84, 0, sizeof(v84));
  glpInitPoolAllocator(4096, 4096, v84);
  v87 = 0;
  v86 = 0u;
  memset(v85, 0, sizeof(v85));
  glpInitDeserialContext((uint64_t)v85, (uint64_t)v84, (uint64_t)v84, a1, a2);
  StringHash = glpMakeStringHash(&GLP_MALLOC_ALLOCATOR);
  v7[23] = StringHash;
  deserialize_bindings((uint64_t)v85, StringHash);
  v26 = glpMakeStringHash(&GLP_MALLOC_ALLOCATOR);
  v7[24] = v26;
  deserialize_bindings((uint64_t)v85, v26);
  v7[10] = glpDeserializeUniformBindings((uint64_t)v85);
  v27 = v87;
  if (HIDWORD(v87) >= v87)
    goto LABEL_77;
  v28 = *((_QWORD *)&v86 + 1);
  v29 = *(char *)(*((_QWORD *)&v86 + 1) + HIDWORD(v87));
  v30 = *(unsigned __int8 *)(*((_QWORD *)&v86 + 1) + HIDWORD(v87));
  v31 = ++HIDWORD(v87);
  if (v29 < 0)
    __asm { BR              X16 }
  *((_DWORD *)v7 + 56) = v30;
  if (v31 >= v27)
LABEL_77:
    glpDeserialError((uint64_t)v85, 1u);
  v32 = *(char *)(v28 + v31);
  v33 = *(unsigned __int8 *)(v28 + v31);
  HIDWORD(v87) = v31 + 1;
  if (v32 < 0)
    __asm { BR              X16 }
  v7[25] = 4;
  v7[26] = (*((void *(**)(int, size_t))&GLP_MALLOC_ALLOCATOR + 1))(GLP_MALLOC_ALLOCATOR, 0x10uLL);
  if ((_DWORD)v33)
  {
    while (HIDWORD(v87) < v87)
    {
      v34 = *(char *)(*((_QWORD *)&v86 + 1) + HIDWORD(v87));
      v35 = *(unsigned __int8 *)(*((_QWORD *)&v86 + 1) + HIDWORD(v87));
      ++HIDWORD(v87);
      if (v34 < 0)
        __asm { BR              X15 }
      v36 = *((_DWORD *)v7 + 50);
      v37 = *((unsigned int *)v7 + 51);
      if ((int)v37 + 1 <= v36)
      {
        v40 = (char *)v7[26];
        v41 = *((_DWORD *)v7 + 51);
      }
      else
      {
        if (v36 <= 1)
          v36 = 1;
        v38 = 2 * v36;
        if (v38 <= (int)v37 + 1)
          v39 = v37 + 1;
        else
          v39 = v38;
        v40 = (char *)(*((void *(**)(int, size_t))&GLP_MALLOC_ALLOCATOR + 1))(GLP_MALLOC_ALLOCATOR, 4 * v39);
        memcpy(v40, (const void *)v7[26], 4 * *((unsigned int *)v7 + 51));
        off_255B0BD18(GLP_MALLOC_ALLOCATOR, (void *)v7[26]);
        *((_DWORD *)v7 + 50) = v39;
        v7[26] = v40;
        v41 = *((_DWORD *)v7 + 51);
      }
      memmove(&v40[4 * v37 + 4], &v40[4 * v37], 4 * (v41 - v37));
      *(_DWORD *)(v7[26] + 4 * v37) = v35;
      ++*((_DWORD *)v7 + 51);
      LODWORD(v33) = v33 - 1;
      if (!(_DWORD)v33)
        goto LABEL_44;
    }
    goto LABEL_77;
  }
LABEL_44:
  if (HIDWORD(v87) >= v87)
    goto LABEL_77;
  v42 = *(char *)(*((_QWORD *)&v86 + 1) + HIDWORD(v87));
  v43 = *(unsigned __int8 *)(*((_QWORD *)&v86 + 1) + HIDWORD(v87));
  ++HIDWORD(v87);
  if (v42 < 0)
    __asm { BR              X16 }
  v44 = (int)((16 * v43) | 8);
  v45 = (*((void *(**)(int, size_t))&GLP_MALLOC_ALLOCATOR + 1))(GLP_MALLOC_ALLOCATOR, v44);
  bzero(v45, v44);
  *v45 = v43;
  if ((_DWORD)v43)
  {
    v46 = v43;
    v47 = v45 + 4;
    do
    {
      v48 = v87;
      if (HIDWORD(v87) >= v87)
        goto LABEL_77;
      v49 = *((_QWORD *)&v86 + 1);
      v50 = *(char *)(*((_QWORD *)&v86 + 1) + HIDWORD(v87));
      v51 = *(unsigned __int8 *)(*((_QWORD *)&v86 + 1) + HIDWORD(v87));
      v52 = ++HIDWORD(v87);
      if (v50 < 0)
        __asm { BR              X15 }
      *((_DWORD *)v47 - 2) = v51;
      if ((unint64_t)v52 + 8 > v48)
        goto LABEL_77;
      v53 = *(_QWORD *)(v49 + v52);
      HIDWORD(v87) = v52 + 8;
      *v47 = v53;
      v54 = v47 + 2;
      PPStreamTokenConvertParamBindingsToGeneric((unint64_t)v47, 1);
      v47 = v54;
    }
    while (--v46);
  }
  v7[27] = v45;
  v7[11] = glpDeserializeUniformBindings((uint64_t)v85);
  v7[12] = glpDeserializeUniformBindings((uint64_t)v85);
  if (HIDWORD(v87) >= v87)
    goto LABEL_77;
  v55 = *(char *)(*((_QWORD *)&v86 + 1) + HIDWORD(v87));
  v56 = *(unsigned __int8 *)(*((_QWORD *)&v86 + 1) + HIDWORD(v87));
  ++HIDWORD(v87);
  if (v55 < 0)
    __asm { BR              X16 }
  if ((_DWORD)v56)
  {
    v57 = 0;
    v7[40] = glpMakeIntHash(&GLP_MALLOC_ALLOCATOR);
    while (HIDWORD(v87) < v87)
    {
      v58 = *(char *)(*((_QWORD *)&v86 + 1) + HIDWORD(v87));
      v59 = *(unsigned __int8 *)(*((_QWORD *)&v86 + 1) + HIDWORD(v87));
      ++HIDWORD(v87);
      if (v58 < 0)
        __asm { BR              X15 }
      v60 = malloc_type_malloc(0x18uLL, 0x7081ABB9uLL);
      if (!v60)
        goto LABEL_78;
      v61 = (uint64_t)v60;
      *v60 = 0;
      v60[1] = 0;
      v60[2] = 0;
      v62 = (const void *)deserialize_GLPString((uint64_t)v85);
      v64 = v63;
      v65 = v63;
      v66 = (char *)malloc_type_malloc(v63, 0x7081ABB9uLL);
      if (!v66)
        goto LABEL_78;
      v67 = v66;
      memcpy(v66, v62, v65);
      v69 = v64 >> 5;
      if (v64 >> 5 >= v64)
      {
        v71 = v64;
      }
      else
      {
        v70 = ~(v64 >> 5);
        LODWORD(v71) = v64;
        do
        {
          v71 = (32 * (_DWORD)v71 + (v71 >> 2) + v67[(v64 - 1)]) ^ v71;
          LODWORD(v64) = v64 + v70;
        }
        while (v64 > v69);
      }
      *(_QWORD *)v61 = v67;
      *(_QWORD *)(v61 + 8) = v65 | (v71 << 32);
      v72 = HIDWORD(v87);
      v73 = v87;
      if ((unint64_t)HIDWORD(v87) + 4 > v87)
        goto LABEL_77;
      v74 = *((_QWORD *)&v86 + 1);
      v75 = *(_DWORD *)(*((_QWORD *)&v86 + 1) + HIDWORD(v87));
      HIDWORD(v87) += 4;
      v76 = HIDWORD(v87);
      *(_DWORD *)(v61 + 16) = v75;
      if (v76 + 4 > v73)
        goto LABEL_77;
      v77 = *(_DWORD *)(v74 + v76);
      HIDWORD(v87) = v72 + 8;
      *(_DWORD *)(v61 + 20) = v77;
      glpIntHashPut(v7[40], v59, v61, v68);
      if (++v57 == (_DWORD)v56)
        goto LABEL_74;
    }
    goto LABEL_77;
  }
  v7[40] = 0;
LABEL_74:
  v78 = 18;
  v79 = 252;
  do
  {
    v7[v78 - 5] = glpMakeStringHash(&GLP_MALLOC_ALLOCATOR);
    v7[v78] = glpMakeStringHash(&GLP_MALLOC_ALLOCATOR);
    v80 = (_DWORD *)((char *)v7 + v79);
    *(v80 - 5) = 0;
    *v80 = 0;
    ++v78;
    v79 += 4;
  }
  while (v78 != 23);
  v81 = *a3;
  v82 = a3[2];
  *((_OWORD *)v7 + 18) = a3[1];
  *((_OWORD *)v7 + 19) = v82;
  *((_OWORD *)v7 + 17) = v81;
  glpDestroyDeserialContext(v85);
  glpDestroyPoolAllocator((uint64_t)v84);
  return v7;
}

void *__abort_calloc()
{
  void *result;

  result = malloc_type_calloc(1uLL, 0x148uLL, 0xA92C9FCEuLL);
  if (!result)
    abort();
  return result;
}

_DWORD *glpDeserializeUniformBindings(uint64_t a1)
{
  _DWORD *v2;
  uint64_t v3;
  unsigned int v4;
  _DWORD *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  size_t v12;
  void *v13;
  __int128 v14;
  int v15;
  int v16;
  __int128 *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  _DWORD *v21;
  const void *v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  unsigned int v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  unsigned int v51;
  const void *v52;
  int v53;
  int v54;
  __int128 *v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t i;
  uint64_t v61;
  int v62;
  uint64_t v63;
  char *v64;
  char *v65;
  _QWORD *v66;
  _QWORD *v67;
  unsigned int v68;
  unsigned int v69;
  uint64_t v70;
  uint64_t v72;
  int v73;
  const void *v74;
  uint64_t v75;

  v2 = malloc_type_malloc(0x38uLL, 0x7081ABB9uLL);
  if (!v2)
    goto LABEL_44;
  v3 = *(unsigned int *)(a1 + 260);
  v4 = *(_DWORD *)(a1 + 256);
  if (v3 >= v4)
    goto LABEL_43;
  v5 = v2;
  v6 = *(_QWORD *)(a1 + 248);
  v7 = *(char *)(v6 + v3);
  v8 = *(unsigned __int8 *)(v6 + v3);
  v9 = v3 + 1;
  *(_DWORD *)(a1 + 260) = v3 + 1;
  if (v7 < 0)
    __asm { BR              X16 }
  v2[8] = v8;
  if (v9 >= v4)
    goto LABEL_43;
  v10 = *(char *)(v6 + v9);
  v11 = *(unsigned __int8 *)(v6 + v9);
  *(_DWORD *)(a1 + 260) = v9 + 1;
  if (v10 < 0)
    __asm { BR              X17 }
  v2[9] = v11;
  v12 = (32 * v8);
  v13 = malloc_type_malloc(v12, 0x7081ABB9uLL);
  if (!v13)
LABEL_44:
    abort();
  *((_QWORD *)v5 + 5) = v13;
  bzero(v13, v12);
  v14 = *(_OWORD *)&off_255B0BD10;
  *(_OWORD *)v5 = GLP_MALLOC_ALLOCATOR;
  *((_OWORD *)v5 + 1) = v14;
  *((_BYTE *)v5 + 48) = 1;
  if (v5[9])
  {
    v15 = 0;
    v16 = 0;
    v17 = &GLP_MALLOC_ALLOCATOR;
    v72 = *((_QWORD *)v5 + 5);
    while (1)
    {
      v18 = *(unsigned int *)(a1 + 260);
      if (v18 >= *(_DWORD *)(a1 + 256))
        break;
      v19 = *(_QWORD *)(a1 + 248);
      v20 = *(char *)(v19 + v18);
      v21 = (_DWORD *)*(unsigned __int8 *)(v19 + v18);
      *(_DWORD *)(a1 + 260) = v18 + 1;
      if (v20 < 0)
        __asm { BR              X15 }
      v22 = (const void *)deserialize_GLPString(a1);
      v24 = v23;
      v25 = malloc_type_malloc(0x58uLL, 0x7081ABB9uLL);
      if (!v25)
        goto LABEL_44;
      v26 = v25;
      v25[10] = 0;
      *((_OWORD *)v25 + 3) = 0u;
      *((_OWORD *)v25 + 4) = 0u;
      *((_OWORD *)v25 + 1) = 0u;
      *((_OWORD *)v25 + 2) = 0u;
      *(_OWORD *)v25 = 0u;
      v27 = *(unsigned int *)(a1 + 260);
      v28 = *(unsigned int *)(a1 + 256);
      if (v27 + 4 > v28)
        break;
      v29 = *(_QWORD *)(a1 + 248);
      v30 = *(_DWORD *)(v29 + v27);
      v31 = (v27 + 4);
      *(_DWORD *)(a1 + 260) = v31;
      *(_DWORD *)v25 = v30;
      if (v31 + 4 > v28)
        break;
      v32 = *(_DWORD *)(v29 + v31);
      v33 = (v27 + 8);
      *(_DWORD *)(a1 + 260) = v33;
      *((_DWORD *)v25 + 1) = v32;
      if (v33 + 4 > v28)
        break;
      v34 = *(_DWORD *)(v29 + v33);
      v35 = (v27 + 12);
      *(_DWORD *)(a1 + 260) = v35;
      *((_DWORD *)v25 + 2) = v34;
      if (v35 + 4 > v28)
        break;
      v36 = *(_DWORD *)(v29 + v35);
      v37 = (v27 + 16);
      *(_DWORD *)(a1 + 260) = v37;
      *((_DWORD *)v25 + 3) = v36;
      if (v37 + 4 > v28)
        break;
      v38 = *(_DWORD *)(v29 + v37);
      *(_DWORD *)(a1 + 260) = v27 + 20;
      *((_BYTE *)v25 + 80) = v38;
      v75 = 0;
      deserialize_GLPType((unsigned int *)a1, &v75);
      v39 = glpDeepCopyType(v17, v75);
      v26[3] = v39;
      v74 = 0;
      deserialize_GLPValue((unsigned int *)a1, v39, &v74);
      v45 = v74 ? glpCopyValue((uint64_t)v17, (unsigned int *)v26[3], v74, v40, v41, v42, v43, v44) : 0;
      v26[2] = v45;
      v46 = *(unsigned int *)(a1 + 260);
      v47 = *(_DWORD *)(a1 + 256);
      if (v46 >= v47)
        break;
      v48 = *(_QWORD *)(a1 + 248);
      v49 = *(char *)(v48 + v46);
      v50 = *(unsigned __int8 *)(v48 + v46);
      v51 = v46 + 1;
      *(_DWORD *)(a1 + 260) = v46 + 1;
      if (v49 < 0)
        __asm { BR              X15 }
      if ((_DWORD)v50)
      {
        v73 = v16;
        if (v51 >= v47)
          break;
        v52 = v22;
        v53 = v15;
        v54 = (int)v21;
        v21 = v5;
        v55 = v17;
        v56 = *(char *)(v48 + v51);
        v57 = *(unsigned __int8 *)(v48 + v51);
        *(_DWORD *)(a1 + 260) = v46 + 2;
        if (v56 < 0)
          __asm { BR              X15 }
        v58 = BitSetNew(v50);
        memcpy(*(void **)(v58 + 40), (const void *)(*(_QWORD *)(a1 + 248) + *(unsigned int *)(a1 + 260)), v57);
        *(_DWORD *)(a1 + 260) += v57;
        v17 = v55;
        v5 = v21;
        LODWORD(v21) = v54;
        v15 = v53;
        v22 = v52;
        v16 = v73;
      }
      else
      {
        v58 = 0;
      }
      v59 = (v15 + (_DWORD)v21);
      v26[4] = v58;
      for (i = 40; i != 60; i += 4)
      {
        v61 = *(unsigned int *)(a1 + 260);
        if (v61 + 4 > (unint64_t)*(unsigned int *)(a1 + 256))
          goto LABEL_43;
        v62 = *(_DWORD *)(*(_QWORD *)(a1 + 248) + v61);
        *(_DWORD *)(a1 + 260) = v61 + 4;
        *(_DWORD *)((char *)v26 + i) = v62;
      }
      v63 = v24;
      v64 = (char *)malloc_type_malloc(v24, 0x7081ABB9uLL);
      if (!v64)
        goto LABEL_44;
      v65 = v64;
      memcpy(v64, v22, v24);
      v66 = (_QWORD *)(v72 + 32 * v59);
      *v66 = v26;
      v67 = v66 + 1;
      v68 = v24 >> 5;
      if (v24 >> 5 >= v24)
      {
        v70 = v24;
      }
      else
      {
        v69 = ~(v24 >> 5);
        LODWORD(v70) = v24;
        do
        {
          v70 = (32 * (_DWORD)v70 + (v70 >> 2) + v65[(v24 - 1)]) ^ v70;
          LODWORD(v24) = v24 + v69;
        }
        while (v24 > v68);
      }
      *v67 = v65;
      v67[1] = v63 | (v70 << 32);
      v15 = v59 + 1;
      if (++v16 >= v5[9])
        return v5;
    }
LABEL_43:
    glpDeserialError(a1, 1u);
  }
  return v5;
}

_QWORD *glpLinkProgram(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t *v14;
  _QWORD *v15;
  _DWORD *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int8x16_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t **v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t **v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t GlobalTypeQualifier;
  uint64_t *Layout;
  uint64_t v43;
  uint64_t v44;
  uint64_t *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t *v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t i;
  unsigned int v58;
  uint64_t StringHash;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  char *v68;
  uint64_t *v69;
  uint64_t *v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t *v75;
  char *v76;
  uint64_t *v77;
  unint64_t v78;
  int v79;
  uint64_t *v80;
  char *v81;
  uint64_t *v82;
  uint64_t *v83;
  uint64_t v84;
  _BOOL4 v85;
  unsigned int v86;
  int InterstageBindings;
  uint64_t v88;
  int v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  unint64_t j;
  uint64_t v94;
  uint64_t **v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t *v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  _QWORD *v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  unint64_t k;
  uint64_t v108;
  uint64_t **v109;
  int v110;
  BOOL v111;
  uint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t **v116;
  int v117;
  int8x8_t v119;
  uint64_t v120;
  unint64_t v121;
  unint64_t v122;
  uint64_t v123;
  unint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  __int32 v128;
  uint64_t v129;
  uint64_t v130;
  unsigned int v131;
  uint64_t *v132;
  uint64_t v133;
  int v134;
  _QWORD *v135;
  uint64_t v136;
  uint64_t *v137;
  uint64_t v138;
  uint64_t v139;
  unsigned int v140;
  uint64_t ElementType;
  unsigned int v142;
  unsigned int Size;
  unsigned int v144;
  int v145;
  uint64_t v146;
  uint64_t v147;
  unsigned int v148;
  unsigned int v149;
  int v150;
  uint64_t v151;
  const char *v152;
  size_t v153;
  int v154;
  int v155;
  size_t v156;
  int v157;
  size_t v158;
  char *v159;
  _QWORD *v160;
  _BOOL4 v161;
  int v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t *v166;
  int v167;
  unsigned int v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  int SamplerCount;
  uint64_t *v175;
  int v176;
  uint64_t *v177;
  int v178;
  int v179;
  int v180;
  uint64_t v181;
  int v182;
  void *v183;
  uint64_t v184;
  const void *v185;
  int v186;
  char *v187;
  unsigned int v188;
  unsigned int v189;
  uint64_t v190;
  unsigned int *v191;
  _BYTE *v192;
  uint64_t v193;
  int v194;
  int v195;
  int v196;
  uint64_t v197;
  int v198;
  unsigned int v199;
  char *v200;
  int v201;
  unsigned int v202;
  int v203;
  uint64_t v204;
  int v205;
  unsigned int v206;
  char *v207;
  int v208;
  _DWORD *v209;
  uint64_t v210;
  double v211;
  uint64_t v212;
  unsigned int v213;
  unsigned int v214;
  uint64_t v215;
  unsigned int v216;
  uint64_t v217;
  uint64_t *v218;
  int v219;
  int v220;
  int v221;
  uint64_t v222;
  void *v223;
  uint64_t v224;
  void *v225;
  void *v226;
  uint64_t v227;
  uint64_t v228;
  int v229;
  uint64_t v230;
  unsigned int v231;
  int v232;
  int v233;
  int v234;
  unsigned int v235;
  int v236;
  uint64_t *v237;
  uint64_t *v238;
  uint64_t *v239;
  uint64_t *v240;
  uint64_t *v241;
  uint64_t *v242;
  uint64_t *v243;
  uint64_t *v244;
  uint64_t *v245;
  uint64_t *v246;
  uint64_t *v247;
  uint64_t *v248;
  uint64_t *v249;
  uint64_t *v250;
  uint64_t *v251;
  uint64_t *v252;
  uint64_t *v253;
  uint64_t *v254;
  uint64_t *v255;
  uint64_t *v256;
  uint64_t *v257;
  uint64_t *v258;
  uint64_t *v259;
  int v260;
  int v261;
  unsigned int v262;
  void *v263;
  unsigned int v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  int v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  _QWORD *v277;
  uint64_t **v278;
  uint64_t **v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t **v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  unint64_t v289;
  unint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  const void *v294;
  uint64_t v295;
  char *v296;
  uint64_t v297;
  uint64_t *v298;
  uint64_t v299;
  uint64_t v300;
  const char *String;
  uint64_t v302;
  double v303;
  unsigned int Vec4s_1;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  __int128 v309;
  uint64_t m;
  unint64_t v311;
  uint64_t v312;
  int v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  const void *v317;
  uint64_t v318;
  _OWORD *v319;
  uint64_t v320;
  uint64_t *v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  const char *v325;
  uint64_t v326;
  double v327;
  uint64_t v328;
  int v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t n;
  uint64_t v337;
  uint64_t v338;
  uint64_t *v339;
  uint64_t v340;
  unsigned int v341;
  int v342;
  uint64_t Def;
  uint64_t v344;
  uint64_t Prototype;
  uint64_t Extra;
  uint64_t v347;
  _QWORD *v348;
  void *v349;
  uint64_t v350;
  const char *v351;
  uint64_t v352;
  double v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t *v362;
  uint64_t v363;
  unint64_t v364;
  unint64_t v365;
  int v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  const void *v370;
  size_t v371;
  unsigned int *v372;
  void *v373;
  _OWORD *v374;
  uint64_t v375;
  uint64_t v376;
  unint64_t v377;
  uint64_t v378;
  uint64_t v379;
  const char *v380;
  uint64_t v381;
  double v382;
  uint64_t v383;
  unint64_t v384;
  uint64_t v385;
  unint64_t ii;
  uint64_t v387;
  uint64_t v388;
  const void *v389;
  size_t v390;
  _QWORD *v391;
  void *v392;
  uint64_t v393;
  const char *v394;
  uint64_t v395;
  double v396;
  uint64_t v397;
  unint64_t v398;
  uint64_t v399;
  unint64_t jj;
  uint64_t v401;
  _QWORD *v402;
  const void *v403;
  size_t v404;
  _QWORD *v405;
  void *v406;
  uint64_t v407;
  const char *v408;
  uint64_t v409;
  double v410;
  uint64_t v411;
  __int128 v412;
  __int128 v413;
  char *v414;
  uint64_t *v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t *v418;
  uint64_t v419;
  uint64_t v420;
  char *v421;
  int v422;
  uint64_t v423;
  int v424;
  int v425;
  int v426;
  BOOL v427;
  char v428;
  _QWORD *LLVMCodeGenContext;
  uint64_t v430;
  _QWORD *CodeGenContext;
  uint64_t **v432;
  char v433;
  uint64_t v434;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t **v438;
  char v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t **v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t **v449;
  uint64_t **v450;
  uint64_t v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t **v455;
  uint64_t **v456;
  uint64_t **v457;
  char v458;
  uint64_t v459;
  const char *v460;
  size_t v461;
  int v462;
  int v463;
  uint64_t v464;
  unsigned int v465;
  void *__src;
  unint64_t v467;
  uint64_t *v468;
  unsigned int *ArrayType;
  uint64_t *v470;
  int v471;
  int v472;
  uint64_t *v473;
  uint64_t v474;
  uint64_t *v475;
  int v476;
  int v477;
  unsigned int v478;
  uint64_t v479;
  _BOOL4 v480;
  int v481;
  uint64_t v482;
  uint64_t *v483;
  _BOOL4 v484;
  uint64_t v485;
  uint64_t *v486;
  uint64_t v487;
  int v488;
  uint64_t *v489;
  _QWORD *v490;
  int v491;
  char *v492;
  int v493;
  uint64_t v494;
  int v495;
  _OWORD *v496;
  unsigned int v497;
  void *v498;
  int v499;
  int v500;
  int __s2;
  uint64_t __s2a;
  const char *__s2b;
  uint64_t __s2c;
  char *__s2d[2];
  void *__s2e;
  char *__s2f;
  uint64_t *__s2g;
  uint64_t v510;
  void *v511;
  _QWORD v512[3];
  _BYTE v513[24];
  uint64_t v514;
  _QWORD v515[2];
  int v516;
  __int128 v517;
  int v518;
  _QWORD v519[2];
  int v520;
  _QWORD v521[2];
  int v522;
  _QWORD v523[2];
  int v524;
  uint64_t v525[4];
  uint64_t v526;
  uint64_t v527[6];
  uint64_t v528[4];
  uint64_t v529;
  uint64_t v530[6];
  __int128 v531;
  __int128 v532;
  uint64_t v533;
  uint64_t v534[3];
  _BYTE v535[24];
  uint64_t v536;
  int v537[2];
  _OWORD v538[23];
  uint64_t v539;
  uint64_t v540;
  __int128 v541;
  __int128 v542;
  __int128 v543;
  __int128 v544;
  __int128 v545;
  __int128 v546;
  __int128 v547;
  __int128 v548;
  __int128 v549;
  __int128 v550;
  __int128 v551;
  __int128 v552;
  __int128 v553;
  int8x16_t v554;
  __int128 v555;
  _QWORD v556[10];

  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v556[7] = *MEMORY[0x24BDAC8D0];
  memset(v512, 0, sizeof(v512));
  v488 = 1;
  do
  {
    v14 = &a1[v8 + 23];
    v15 = &a1[2 * v8];
    v18 = *((_DWORD *)v15 + 27);
    v16 = (_DWORD *)v15 + 27;
    v17 = v18;
    if (v18)
    {
      v491 = v13;
      v495 = v9;
      __s2 = v11;
      v19 = &v534[14 * v8];
      memset(v556, 0, 56);
      v554 = 0u;
      v555 = 0u;
      v552 = 0u;
      v553 = 0u;
      v550 = 0u;
      v551 = 0u;
      v548 = 0u;
      v549 = 0u;
      v546 = 0u;
      v547 = 0u;
      v544 = 0u;
      v545 = 0u;
      v542 = 0u;
      v543 = 0u;
      v541 = 0u;
      glpASTMergeInitContext((uint64_t)&v541, (uint64_t)a1, v8);
      v20 = 0;
      v21 = 8 * v17;
      do
      {
        v22 = glpDeserializeAST((uint64_t)a1, *(_QWORD *)(*(_QWORD *)(a1[2 * v8 + 14] + v20) + 16), *(_DWORD *)(*(_QWORD *)(a1[2 * v8 + 14] + v20) + 8));
        if (!v22)
        {
          *v14 = 0;
          v29 = (uint64_t **)a1[8];
          v30 = glpLanguageToString(v8);
          *(_QWORD *)&v531 = "-1";
          *((_QWORD *)&v531 + 1) = 0xEDA00000002;
          *(_QWORD *)&v532 = 0xFFFFFFFFLL;
          glpLogMessage(v29, 0, (uint64_t)&v531, "Compiled %s shader was corrupt.", v31, v32, v33, v34, v30);
          goto LABEL_13;
        }
        if (!glpASTMergePhase1AddTopLevelNode((uint64_t *)&v541, v22))
          goto LABEL_13;
        v20 += 8;
      }
      while (v21 != v20);
      v23 = glpASTMergePhase2((uint64_t)&v541);
      if (v23 != -1)
      {
        *v14 = v23;
        v24 = vextq_s8(v554, v554, 8uLL);
        *(_OWORD *)v19 = v553;
        *((int8x16_t *)v19 + 1) = v24;
        *((_OWORD *)v19 + 2) = v555;
        v25 = v551;
        v19[6] = v556[0];
        v19[7] = v25;
        v26 = *((_QWORD *)&v543 + 1);
        v19[8] = v550;
        v19[9] = v26;
        v27 = *(_OWORD *)&v556[3];
        *((_OWORD *)v19 + 5) = *(_OWORD *)&v556[1];
        *((_OWORD *)v19 + 6) = v27;
        goto LABEL_14;
      }
LABEL_13:
      v488 = 0;
LABEL_14:
      v11 = __s2;
      v28 = *v16;
      v9 = v495;
      if (v491)
      {
LABEL_10:
        if (v28)
          goto LABEL_17;
LABEL_24:
        v13 = 1;
        goto LABEL_25;
      }
    }
    else
    {
      v28 = 0;
      *v14 = 0;
      if (v13)
        goto LABEL_10;
    }
    if (v28)
    {
      glpPopulatePrecisionWidths(*(unsigned int *)(*(_QWORD *)a1[2 * v8 + 14] + 4), v512);
      v28 = *v16;
      if (*v16)
      {
LABEL_17:
        v35 = a1[2 * v8 + 14];
        while (2)
        {
          v36 = v10;
          v10 = 1;
          switch(*(_DWORD *)(*(_QWORD *)v35 + 4))
          {
            case 0:
              goto LABEL_23;
            case 1:
            case 2:
              v11 = 1;
              goto LABEL_22;
            case 3:
            case 4:
            case 5:
            case 7:
            case 8:
            case 9:
              v12 = 1;
              goto LABEL_22;
            case 6:
              v9 = 1;
LABEL_22:
              v10 = v36;
LABEL_23:
              v35 += 8;
              if (!--v28)
                goto LABEL_24;
              continue;
            default:
              goto LABEL_471;
          }
        }
      }
      goto LABEL_24;
    }
    v13 = 0;
LABEL_25:
    ++v8;
  }
  while (v8 != 5);
  if (!v488)
    return 0;
  if (v9 && (_DWORD)v10)
  {
    v37 = (uint64_t **)a1[8];
    *(_QWORD *)&v541 = "-1";
    *((_QWORD *)&v541 + 1) = 0xEDA00000002;
    *(_QWORD *)&v542 = 0xFFFFFFFFLL;
    v38 = "Error: Version 100 and Version 300 shaders may not be linked together.";
LABEL_150:
    glpLogMessage(v37, 0, (uint64_t)&v541, v38, a5, a6, a7, a8, v458);
    return 0;
  }
  if (v9 | v10)
  {
    v39 = (uint64_t)a1;
    if (v11 | v12)
    {
      v37 = (uint64_t **)a1[8];
      *(_QWORD *)&v541 = "-1";
      *((_QWORD *)&v541 + 1) = 0xEDA00000002;
      *(_QWORD *)&v542 = 0xFFFFFFFFLL;
      v38 = "Error: Linking ES shaders with non-ES shaders is not supported.";
      goto LABEL_150;
    }
  }
  else
  {
    v39 = (uint64_t)a1;
    if (v11 && v12)
    {
      v37 = (uint64_t **)a1[8];
      *(_QWORD *)&v541 = "-1";
      *((_QWORD *)&v541 + 1) = 0xEDA00000002;
      *(_QWORD *)&v542 = 0xFFFFFFFFLL;
      v38 = "Error: Linking legacy shaders with core profile shaders is not supported.";
      goto LABEL_150;
    }
  }
  v40 = *(_QWORD *)(v39 + 192);
  if (v40)
  {
    GlobalTypeQualifier = glpTopLevelNodeGetGlobalTypeQualifier(v40, 0x40000000);
    if (GlobalTypeQualifier)
    {
      Layout = (uint64_t *)glpGlobalTypeQualifierNodeGetLayout(GlobalTypeQualifier);
      if (glpLayoutObjectFind(Layout, 18))
        *(_DWORD *)(v39 + 320) = *((_DWORD *)glpLayoutObjectFind(Layout, 18) + 4);
    }
  }
  v43 = *(_QWORD *)(v39 + 200);
  if (v43)
  {
    v44 = glpTopLevelNodeGetGlobalTypeQualifier(v43, 0x20000000);
    if (!v44)
      goto LABEL_149;
    v45 = (uint64_t *)glpGlobalTypeQualifierNodeGetLayout(v44);
    if (glpLayoutObjectFind(v45, 3))
    {
      *(_DWORD *)(v39 + 324) = 4;
      v46 = 1;
    }
    else
    {
      v46 = 0;
    }
    if (glpLayoutObjectFind(v45, 10))
    {
      *(_DWORD *)(v39 + 324) = 7;
      v46 = 1;
    }
    if (glpLayoutObjectFind(v45, 11))
    {
      *(_DWORD *)(v39 + 324) = 36474;
      v46 = 1;
    }
    if (glpLayoutObjectFind(v45, 12))
      *(_DWORD *)(v39 + 328) = 514;
    if (glpLayoutObjectFind(v45, 13))
      *(_DWORD *)(v39 + 328) = 36476;
    if (glpLayoutObjectFind(v45, 14))
      *(_DWORD *)(v39 + 328) = 36475;
    if (glpLayoutObjectFind(v45, 15))
      *(_DWORD *)(v39 + 332) = 2304;
    if (glpLayoutObjectFind(v45, 16))
      *(_DWORD *)(v39 + 332) = 2305;
    if (glpLayoutObjectFind(v45, 17))
      *(_DWORD *)(v39 + 336) = 1;
    if (!v46)
    {
LABEL_149:
      v37 = *(uint64_t ***)(v39 + 64);
      *(_QWORD *)&v541 = "-1";
      *((_QWORD *)&v541 + 1) = 0xEDA00000002;
      *(_QWORD *)&v542 = 0xFFFFFFFFLL;
      v38 = "Tessellation evaluation shader must specify triangles, quads or isolines.";
      goto LABEL_150;
    }
  }
  v47 = *(_QWORD *)(v39 + 208);
  if (v47)
  {
    v48 = glpTopLevelNodeGetGlobalTypeQualifier(v47, 0x20000000);
    v49 = glpTopLevelNodeGetGlobalTypeQualifier(*(_QWORD *)(v39 + 208), 0x40000000);
    if (v48)
    {
      v50 = (uint64_t *)glpGlobalTypeQualifierNodeGetLayout(v48);
      glpLayoutObjectGetGeomInOut(v50, 0, 0, (_DWORD *)(v39 + 308), 0, (_DWORD *)(v39 + 316));
    }
    if (v49)
    {
      v51 = (uint64_t *)glpGlobalTypeQualifierNodeGetLayout(v49);
      glpLayoutObjectGetGeomInOut(v51, 0, (_DWORD *)(v39 + 304), 0, (_DWORD *)(v39 + 312), 0);
      v52 = *(unsigned int *)(v39 + 156);
      if ((_DWORD)v52)
      {
        v53 = *(_QWORD *)(v39 + 160);
        if ((*(_BYTE *)(*(_QWORD *)v53 + 12) & 1) != 0)
          goto LABEL_474;
        v54 = 0;
        v55 = v53 + 8;
        do
        {
          if (v52 - 1 == v54)
            goto LABEL_76;
          v56 = *(_QWORD *)(v55 + 8 * v54++);
        }
        while ((*(_BYTE *)(v56 + 12) & 1) == 0);
        if (v54 < v52)
        {
LABEL_474:
          if (*(_DWORD *)(v39 + 312))
          {
            v37 = *(uint64_t ***)(v39 + 64);
            *(_QWORD *)&v541 = "-1";
            *((_QWORD *)&v541 + 1) = 0xEDA00000002;
            *(_QWORD *)&v542 = 0xFFFFFFFFLL;
            v38 = "Use of EmitStreamVertex or EndStreamPrimitive requires layout(points) out.";
            goto LABEL_150;
          }
        }
      }
    }
  }
LABEL_76:
  if (!glpIsLegalStageCombination(v39, *(_QWORD *)(v39 + 184) != 0, *(_QWORD *)(v39 + 192) != 0, *(_QWORD *)(v39 + 200) != 0, *(_QWORD *)(v39 + 208) != 0, *(_QWORD *)(v39 + 216) != 0))return 0;
  if (*(_QWORD *)(v39 + 184) && *(_QWORD *)(v39 + 216) && !*(_DWORD *)(**(_QWORD **)(v39 + 112) + 4))
  {
    v265 = *(_QWORD *)v537;
    v266 = v540;
    v267 = glpStringHashGet(*(uint64_t *)v537, "gl_Position", 0x64C66BD10000000BLL);
    v268 = glpStringHashGet(v266, "gl_FragCoord", 0xFCBC8470000000CLL);
    if (v268 && (*(_BYTE *)(v268 + 52) & 0x80) != 0 && (!v267 || (*(_BYTE *)(v267 + 52) & 0x80) == 0))
    {
      v37 = *(uint64_t ***)(v39 + 64);
      *(_QWORD *)&v541 = "-1";
      *((_QWORD *)&v541 + 1) = 0xEDA00000002;
      *(_QWORD *)&v542 = 0xFFFFFFFFLL;
      v38 = "gl_FragCoord can be declared invariant if and only if gl_Position is declared invariant.";
      goto LABEL_150;
    }
    v269 = glpStringHashGet(v265, "gl_PointSize", 0x3BD84BA50000000CLL);
    v270 = glpStringHashGet(v266, "gl_PointCoord", 0x15E256410000000DLL);
    if (v270 && (*(_BYTE *)(v270 + 52) & 0x80) != 0 && (!v269 || (*(_BYTE *)(v269 + 52) & 0x80) == 0))
    {
      v37 = *(uint64_t ***)(v39 + 64);
      *(_QWORD *)&v541 = "-1";
      *((_QWORD *)&v541 + 1) = 0xEDA00000002;
      *(_QWORD *)&v542 = 0xFFFFFFFFLL;
      v38 = "gl_PointCoord can be declared invariant if and only if gl_PointSize is declared invariant.";
      goto LABEL_150;
    }
  }
  for (i = 0; i != 5; ++i)
  {
    if (*(_QWORD *)(v39 + 8 * i + 184))
      break;
  }
  v58 = 4;
  do
  {
    if (*(_QWORD *)(v39 + 8 * v58 + 184))
      break;
    --v58;
  }
  while (v58);
  StringHash = glpMakeStringHash((_QWORD *)v39);
  v459 = glpMakeStringHash((_QWORD *)v39);
  *(_QWORD *)&v543 = 0;
  v541 = 0u;
  v542 = 0u;
  v533 = 0;
  v531 = 0u;
  v532 = 0u;
  memset(v530, 0, 40);
  v529 = 0;
  memset(v528, 0, sizeof(v528));
  memset(v527, 0, 40);
  v526 = 0;
  memset(v525, 0, sizeof(v525));
  v523[0] = 0;
  v523[1] = 0;
  v524 = 0;
  if (!(_DWORD)i && !glpMakeVertexInputBindings(v39, v534[0], (uint64_t *)&v541, v530, v527))
    return 0;
  v464 = StringHash;
  if (i <= v58)
  {
    v64 = i;
    v65 = v58;
    v473 = &v530[v58];
    v468 = &v527[v58];
    v475 = &v528[v58];
    v66 = &v538[7 * i + 2];
    v67 = i;
    v68 = (char *)&v541 + 8;
    v69 = &v530[1];
    v70 = &v527[1];
    v71 = v39 + 192;
    v470 = &v525[v58];
    do
    {
      if (*(_QWORD *)(v39 + 8 * v64 + 184))
      {
        __s2a = v71;
        v72 = &v534[14 * v64];
        if (!glpMergeUniforms(*(uint64_t ***)(v39 + 64), v464, v72[3])
          || !glpMergeInterfaceBlocks(*(uint64_t ***)(v39 + 64), v64, v459, v72[6], 0))
        {
          return 0;
        }
        v71 = __s2a;
        v73 = __s2a;
        v486 = v70;
        v489 = v69;
        v74 = v70;
        v75 = v69;
        v492 = v68;
        v496 = v66;
        v76 = v68;
        v77 = (uint64_t *)v66;
        v78 = v64;
        do
        {
          v79 = v78;
          v80 = v77;
          v81 = v76;
          v82 = v75;
          v83 = v74;
          if (v78 > 3)
            break;
          v84 = *(_QWORD *)(v73 + v67 * 8);
          v77 += 14;
          v76 += 8;
          ++v75;
          ++v74;
          v73 += 8;
          ++v78;
        }
        while (!v84);
        v85 = 0;
        v86 = v79 + 1;
        if (v64 != 4 && v86 >= 4)
          v85 = *(_DWORD *)(a1[12] + 4) != 0;
        v483 = &v534[14 * v64];
        *((_DWORD *)v523 + v64) = v85;
        if (v64 == v65)
        {
          v39 = (uint64_t)a1;
          v68 = v492;
          v66 = v496;
          v70 = v486;
          v69 = v489;
          if (!v58)
            goto LABEL_475;
          if (!*v473 && !*v468)
          {
            v480 = v85;
            InterstageBindings = glpMakeInterstageBindings((uint64_t)a1, v58, v58, 0, 0, 0, *v483, 0, (uint64_t *)&v541 + v58, 0, v473, 0, v468);
            v85 = v480;
            if (!InterstageBindings)
              return 0;
          }
          if (v64 != 4)
          {
LABEL_475:
            if (!*v475
              && !*v470
              && !glpMakeInterstageBindings((uint64_t)a1, v58, v58, v85, v483[1], v483[2], 0, (uint64_t *)&v531 + v58, 0, v475, 0, v470, 0))
            {
              return 0;
            }
          }
        }
        else
        {
          v478 = v86;
          v481 = v85;
          v88 = glpMakeStringHash(a1);
          if (!glpMergeInterfaceBlocks((uint64_t **)a1[8], v64, v88, v483[4], 0))
            return 0;
          if (!glpMergeInterfaceBlocks((uint64_t **)a1[8], v64, v88, v483[5], v64 == 3))
            return 0;
          v89 = glpMakeInterstageBindings((uint64_t)a1, v64, v478, v481, v483[1], v483[2], *v80, (uint64_t *)&v531 + v64, (uint64_t *)&v81[v67 * 8], &v528[v64], &v82[v67], &v525[v64], &v83[v67]);
          v39 = (uint64_t)a1;
          v65 = v58;
          v68 = v492;
          v66 = v496;
          v70 = v486;
          v69 = v489;
          v71 = __s2a;
          if (!v89)
            return 0;
        }
      }
      ++v64;
      v66 += 7;
      v68 += 8;
      ++v69;
      ++v70;
      v71 += 8;
    }
    while (v64 != v58 + 1);
  }
  if (v58 == 4 && !glpMakeFragmentOutputBindings(v39, v539, &v533, &v529, &v526))
    return 0;
  if (!(_QWORD)v541)
  {
    v90 = *(_QWORD *)(v39 + 80);
    v91 = *(unsigned int *)(v90 + 32);
    if ((_DWORD)v91)
    {
      v92 = 0;
      for (j = 0; j < v91; ++j)
      {
        v94 = *(_QWORD *)(v90 + 40);
        if (*(_QWORD *)(v94 + v92))
        {
          v95 = *(uint64_t ***)(v39 + 64);
          v96 = *(_DWORD *)(v94 + v92 + 16);
          *(_QWORD *)v513 = "-1";
          *(_QWORD *)&v513[8] = 0xEDA00000002;
          *(_QWORD *)&v513[16] = 0xFFFFFFFFLL;
          glpLogMessage(v95, 1u, (uint64_t)v513, "Do not have an attached vertex shader to match BindAttributeLocation request for '%.*s'.", v60, v61, v62, v63, v96);
          v91 = *(unsigned int *)(v90 + 32);
        }
        v92 += 32;
      }
    }
  }
  v97 = 0;
  v98 = v39 + 184;
  v99 = (uint64_t *)v538;
  do
  {
    if (*(_QWORD *)(v98 + 8 * v97))
    {
      v100 = *((_DWORD *)v523 + v97);
      if (v100)
        v101 = v39 + 224;
      else
        v101 = 0;
      if (v100)
        v102 = v39 + 240;
      else
        v102 = 0;
      glpGenerateCopyInOut(a1, v97, v527[v97], v530[v97], v525[v97], v528[v97], v101, v102, *(_QWORD *)(v98 + 8 * v97), *v99);
    }
    ++v97;
    v99 += 14;
  }
  while (v97 != 5);
  v103 = a1;
  if (!v533)
  {
    v104 = a1[11];
    v105 = *(unsigned int *)(v104 + 32);
    if ((_DWORD)v105)
    {
      v106 = 0;
      for (k = 0; k < v105; ++k)
      {
        v108 = *(_QWORD *)(v104 + 40);
        if (*(_QWORD *)(v108 + v106))
        {
          v109 = (uint64_t **)a1[8];
          v110 = *(_DWORD *)(v108 + v106 + 16);
          *(_QWORD *)v513 = "-1";
          *(_QWORD *)&v513[8] = 0xEDA00000002;
          *(_QWORD *)&v513[16] = 0xFFFFFFFFLL;
          glpLogMessage(v109, 1u, (uint64_t)v513, "Do not have an attached fragment shader to match FragDataBinding request for '%.*s'.", v60, v61, v62, v63, v110);
          v105 = *(unsigned int *)(v104 + 32);
        }
        v106 += 32;
      }
    }
  }
  if ((_QWORD)v531)
    v111 = 0;
  else
    v111 = (_QWORD)v532 == 0;
  if (v111 && *((_QWORD *)&v532 + 1) == 0)
  {
    v113 = a1[12];
    if (*(_DWORD *)(v113 + 4))
    {
      v114 = 0;
      v115 = 0;
      do
      {
        v116 = (uint64_t **)a1[8];
        v117 = *(_DWORD *)(*(_QWORD *)(v113 + 8) + v114 + 8);
        *(_QWORD *)v513 = "-1";
        *(_QWORD *)&v513[8] = 0xEDA00000002;
        *(_QWORD *)&v513[16] = 0xFFFFFFFFLL;
        glpLogMessage(v116, 0, (uint64_t)v513, "Do not have an attached vertex or evaluation or geometry shader to match transform feedback binding for '%.*s.'. ", v60, v61, v62, v63, v117);
        ++v115;
        v113 = a1[12];
        v114 += 16;
      }
      while (v115 < *(unsigned int *)(v113 + 4));
      return 0;
    }
  }
  v490 = __abort_calloc();
  v521[0] = 0;
  v521[1] = 0;
  v522 = 0;
  v519[0] = 0;
  v519[1] = 0;
  v520 = 0;
  v490[10] = glpMakeStringHash(&GLP_MALLOC_ALLOCATOR);
  v490[25] = 4;
  v490[26] = (*((uint64_t (**)(_QWORD, uint64_t, const char *))&GLP_MALLOC_ALLOCATOR + 1))(GLP_MALLOC_ALLOCATOR, 16, "Vector Storage (int)");
  v465 = 0;
  __src = (void *)(*((uint64_t (**)(_QWORD, uint64_t, const char *))&GLP_MALLOC_ALLOCATOR + 1))(GLP_MALLOC_ALLOCATOR, 32, "Vector Storage (GLPVariableObject *)");
  v493 = 0;
  v471 = 0;
  v462 = 0;
  v463 = 0;
  v120 = v464;
  v121 = *(unsigned int *)(v464 + 32);
  v122 = v121;
  v123 = 4;
  while (2)
  {
    if (v122)
    {
      v124 = 0;
      while (1)
      {
        v125 = *(_QWORD *)(v120 + 40);
        v126 = *(_QWORD *)(v125 + 32 * v124);
        if (v126)
          break;
LABEL_289:
        ++v124;
        v122 = v121;
        if (v124 >= v121)
          goto LABEL_292;
      }
      v474 = v123;
      v127 = 0;
      v128 = 0;
      v129 = v125 + 32 * v124;
      v130 = *(_QWORD *)(v129 + 16);
      __s2b = *(const char **)(v129 + 8);
      v467 = v124;
      ArrayType = *(unsigned int **)v126;
      v485 = *(_QWORD *)(v126 + 120);
      v131 = *(_DWORD *)(v126 + 128);
      memset(v513, 0, 20);
      v132 = (uint64_t *)v535;
      do
      {
        if (v103[v127 + 23])
        {
          v133 = glpStringHashGet(*v132, __s2b, v130);
          v134 = 1 << v127;
          if (!v133)
            v134 = 0;
          v128 |= v134;
        }
        ++v127;
        v132 += 14;
      }
      while (v127 != 5);
      v135 = v490;
      if (v128 != 1 << v463)
      {
        if (v463 != 5)
          goto LABEL_287;
        v119.i32[0] = v128;
        v119 = vcnt_s8(v119);
        v119.i16[0] = vaddlv_u8((uint8x8_t)v119);
        if (v119.i32[0] < 2u)
          goto LABEL_287;
      }
      if (!*(_QWORD *)(v126 + 88))
      {
        v136 = 0;
        v137 = (uint64_t *)v535;
        do
        {
          if (v103[v136 + 23])
          {
            v138 = glpStringHashGet(*v137, __s2b, v130);
            if (v138)
            {
              v139 = v138;
              v485 = BitSetOr(v485, *(_QWORD *)(v138 + 120));
              v140 = *(_DWORD *)(v139 + 128);
              if (v131 <= v140)
                v131 = *(_DWORD *)(v139 + 128);
              *(_DWORD *)&v513[4 * v136] = v140;
              if (glpTypeGetKind(*(unsigned int **)v139) == 2 && *(_QWORD *)(v139 + 120))
              {
                ElementType = glpArrayTypeGetElementType(*(_QWORD *)v139);
                v142 = glpABIGetTypeSize(0, ElementType, 0);
                Size = glpTypeSizeGetSize(v142);
                v144 = *(_DWORD *)(v139 + 128);
                v145 = v144 % Size ? v144 / Size + 1 : v144 / Size;
                if (glpArrayTypeGetElementCount(*(_QWORD *)v139) != v145)
                {
                  v146 = glpArrayTypeGetElementType(*(_QWORD *)v139);
                  *(_QWORD *)v139 = glpMakeArrayType((uint64_t)v103, v146, v145, -1);
                }
              }
            }
            v135 = v490;
          }
          ++v136;
          v137 += 14;
        }
        while (v136 != 5);
        if (glpTypeGetKind(ArrayType) == 2 && v485)
        {
          v147 = glpArrayTypeGetElementType((uint64_t)ArrayType);
          v148 = glpABIGetTypeSize(0, v147, 0);
          v149 = glpTypeSizeGetSize(v148);
          v150 = v131 % v149 ? v131 / v149 + 1 : v131 / v149;
          if (glpArrayTypeGetElementCount((uint64_t)ArrayType) != v150)
          {
            v151 = glpArrayTypeGetElementType((uint64_t)ArrayType);
            ArrayType = (unsigned int *)glpMakeArrayType((uint64_t)v103, v151, v150, -1);
          }
        }
      }
      v152 = __s2b;
      v153 = v130;
      if ((_DWORD)v130 && *__s2b == 36)
      {
        if (v130 < 9
          || (v154 = strncmp("$ib$", __s2b, 4uLL), v153 = v130, v154)
          || (v155 = strncmp("$gl_", __s2b + 5, 4uLL), v153 = v130, v155))
        {
          if ((v103[5] & 2) != 0 && (*(_BYTE *)(v126 + 52) & 0xC) == 0)
          {
            v217 = 0;
            v218 = (uint64_t *)v535;
            do
            {
              if (a1[v217 + 23])
                glpStringHashGet(*v218, __s2b, v130);
              ++v217;
              v218 += 14;
            }
            while (v217 != 5);
            v219 = v465 + 1;
            if (v465 + 1 <= v474)
            {
              v224 = v465;
              v223 = __src;
            }
            else
            {
              if ((int)v474 <= 1)
                v220 = 1;
              else
                v220 = v474;
              v221 = 2 * v220;
              if (v221 <= v219)
                v222 = v219;
              else
                v222 = v221;
              v223 = (void *)(*((uint64_t (**)(_QWORD, uint64_t, const char *))&GLP_MALLOC_ALLOCATOR + 1))(GLP_MALLOC_ALLOCATOR, 8 * v222, "Vector Storage (GLPVariableObject *, growth)");
              v224 = v465;
              memcpy(v223, __src, 8 * v465);
              off_255B0BD18(GLP_MALLOC_ALLOCATOR, __src);
              v474 = v222;
            }
            *((_QWORD *)v223 + v224) = v126;
            ++v465;
            __src = v223;
          }
          else if (v130 >= 9)
          {
            goto LABEL_195;
          }
LABEL_287:
          v120 = v464;
          v123 = v474;
          v124 = v467;
LABEL_288:
          v121 = *(unsigned int *)(v120 + 32);
          goto LABEL_289;
        }
LABEL_195:
        v156 = v153;
        if (strncmp("$ib$", __s2b, 4uLL))
          goto LABEL_287;
        v157 = strncmp("$gl_", __s2b + 5, 4uLL);
        v153 = v156;
        if (v157)
          goto LABEL_287;
      }
      if ((*(_BYTE *)(v126 + 52) & 4) != 0)
        goto LABEL_287;
      v158 = v153;
      v159 = (char *)malloc_type_malloc(v153, 0x7081ABB9uLL);
      if (!v159
        || (v460 = v159,
            v461 = v158,
            memcpy(v159, __s2b, v158),
            (v160 = malloc_type_malloc(0x58uLL, 0x7081ABB9uLL)) == 0))
      {
LABEL_471:
        abort();
      }
      v160[10] = 0;
      *((_OWORD *)v160 + 3) = 0u;
      *((_OWORD *)v160 + 4) = 0u;
      *((_OWORD *)v160 + 1) = 0u;
      *((_OWORD *)v160 + 2) = 0u;
      v482 = (uint64_t)v160;
      *(_OWORD *)v160 = 0u;
      if (v130 < 3)
      {
LABEL_204:
        v161 = 0;
      }
      else if (!strncmp("gl_", __s2b, 3uLL))
      {
        v161 = 1;
      }
      else
      {
        if (v130 < 9 || strncmp("$ib$", __s2b, 4uLL))
          goto LABEL_204;
        v161 = strncmp("$gl_", __s2b + 5, 4uLL) == 0;
      }
      v162 = v471;
      v163 = 0;
      v497 = 0;
      v484 = v161;
      if (v161)
        v162 = -1;
      v477 = v162;
      v479 = v130;
      do
      {
        if (v103[v163 + 23])
        {
          v164 = v163;
          v165 = glpStringHashGet(v534[14 * v163 + 3], v152, v130);
          if (v165)
          {
            v166 = (uint64_t *)v165;
            *(_DWORD *)v482 |= 1 << v164;
            *(_DWORD *)(v165 + 156) = v477;
            v487 = v164;
            if (v484)
            {
              v167 = 0;
            }
            else
            {
              v168 = glpABIGetTypeSize(0, *(_QWORD *)v165, 0);
              v167 = glpTypeSizeGetSize(v168);
            }
            *((_DWORD *)v521 + v164) += v167;
            SamplerCount = glpTypeGetSamplerCount(*v166);
            *((_DWORD *)v519 + v164) += SamplerCount;
            if (v484 && (v103[5] & 2) != 0)
            {
              v175 = (uint64_t *)v166[1];
              if (!v175 || (v176 = SamplerCount, v177 = glpLayoutObjectFind(v175, 28), SamplerCount = v176, !v177))
              {
                v178 = v465 + 1;
                if (v465 + 1 <= v474)
                {
                  v184 = v465;
                  v183 = __src;
                }
                else
                {
                  if ((int)v474 <= 1)
                    v179 = 1;
                  else
                    v179 = v474;
                  v180 = 2 * v179;
                  if (v180 <= v178)
                    v181 = v178;
                  else
                    v181 = v180;
                  v474 = v181;
                  v182 = SamplerCount;
                  v183 = (void *)(*((uint64_t (**)(_QWORD, uint64_t, const char *))&GLP_MALLOC_ALLOCATOR + 1))(GLP_MALLOC_ALLOCATOR, 8 * v181, "Vector Storage (GLPVariableObject *, growth)");
                  v184 = v465;
                  memcpy(v183, __src, 8 * v465);
                  v152 = __s2b;
                  off_255B0BD18(GLP_MALLOC_ALLOCATOR, __src);
                  SamplerCount = v182;
                }
                *((_QWORD *)v183 + v184) = v166;
                ++v465;
                __src = v183;
              }
            }
            v185 = (const void *)v166[9];
            if (v185 && !*(_QWORD *)(v482 + 16))
            {
              v186 = SamplerCount;
              v187 = glpCopyValue((uint64_t)&GLP_MALLOC_ALLOCATOR, (unsigned int *)*v166, v185, v169, v170, v171, v172, v173);
              SamplerCount = v186;
              *(_QWORD *)(v482 + 16) = v187;
            }
            if ((v103[5] & 2) != 0 && SamplerCount >= 1)
            {
              v476 = SamplerCount;
              glpLLVMAllocVariableExtra((uint64_t)v103, (uint64_t)v166);
              v188 = glpABIGetTypeSize(0, *v166, 0);
              v189 = glpTypeSizeGetSize(v188);
              v190 = v189;
              v191 = (unsigned int *)((uint64_t (*)(_QWORD, uint64_t, const char *))v103[1])(*v103, 4 * v189, "Primitive Types");
              v192 = (_BYTE *)((uint64_t (*)(_QWORD, _QWORD, const char *))v103[1])(*v103, v189, "Flags");
              glpTypeGetAppleVec4Types((unsigned int *)*v166, v191, 1, 0, 0, v192, 0, 0, 0);
              v193 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v103[1])(*v103, 16, "Sampler Uniform");
              *(_QWORD *)(v166[18] + 8) = v193;
              *(_QWORD *)v193 = v497;
              *(_QWORD *)(v193 + 8) = ((uint64_t (*)(_QWORD, uint64_t, const char *))v103[1])(*v103, 16 * v497, "Vector Storage (GLPLLVMSampler)");
              if (v189)
              {
                v194 = 0;
                v195 = v471;
                do
                {
                  if (glpPrimitiveTypeGetCategory(*v191) == 4)
                  {
                    if (!v497)
                    {
                      v196 = *((_DWORD *)v135 + 50);
                      v197 = *((unsigned int *)v135 + 51);
                      if ((int)v197 + 1 <= v196)
                      {
                        v200 = (char *)v135[26];
                        v201 = *((_DWORD *)v135 + 51);
                      }
                      else
                      {
                        if (v196 <= 1)
                          v196 = 1;
                        v198 = 2 * v196;
                        if (v198 <= (int)v197 + 1)
                          v199 = v197 + 1;
                        else
                          v199 = v198;
                        v200 = (char *)(*((uint64_t (**)(_QWORD, uint64_t, const char *))&GLP_MALLOC_ALLOCATOR
                                        + 1))(GLP_MALLOC_ALLOCATOR, 4 * v199, "Vector Storage (int, growth)");
                        memcpy(v200, (const void *)v135[26], 4 * *((unsigned int *)v135 + 51));
                        off_255B0BD18(GLP_MALLOC_ALLOCATOR, (void *)v135[26]);
                        *((_DWORD *)v135 + 50) = v199;
                        v135[26] = v200;
                        v201 = *((_DWORD *)v135 + 51);
                      }
                      memmove(&v200[4 * v197 + 4], &v200[4 * v197], 4 * (v201 - v197));
                      *(_DWORD *)(v135[26] + 4 * v197) = v195;
                      ++*((_DWORD *)v135 + 51);
                    }
                    v202 = *v191;
                    v203 = *(_DWORD *)v193;
                    v204 = *(unsigned int *)(v193 + 4);
                    if ((v204 + 1) <= *(_DWORD *)v193)
                    {
                      v207 = *(char **)(v193 + 8);
                      v208 = *(_DWORD *)(v193 + 4);
                    }
                    else
                    {
                      if (v203 <= 1)
                        v203 = 1;
                      v205 = 2 * v203;
                      if (v205 <= (int)v204 + 1)
                        v206 = v204 + 1;
                      else
                        v206 = v205;
                      v207 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 16 * v206, "Vector Storage (GLPLLVMSampler, growth)");
                      memcpy(v207, *(const void **)(v193 + 8), 16 * *(unsigned int *)(v193 + 4));
                      v135 = v490;
                      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, *(_QWORD *)(v193 + 8));
                      *(_DWORD *)v193 = v206;
                      *(_QWORD *)(v193 + 8) = v207;
                      v208 = *(_DWORD *)(v193 + 4);
                    }
                    memmove(&v207[16 * v204 + 16], &v207[16 * v204], 16 * (v208 - v204));
                    v209 = (_DWORD *)(*(_QWORD *)(v193 + 8) + 16 * v204);
                    *v209 = v194 + v493;
                    v209[1] = -1;
                    v209[2] = v195;
                    v209[3] = v202;
                    ++*(_DWORD *)(v193 + 4);
                    ++v194;
                  }
                  ++v195;
                  ++v191;
                  --v190;
                }
                while (v190);
                v497 = v476;
                v103 = a1;
              }
              else
              {
                v497 = v476;
                v103 = a1;
              }
              v130 = v479;
              v152 = __s2b;
            }
            else
            {
              v130 = v479;
            }
            v163 = v487;
          }
          else
          {
            v130 = v479;
            v163 = v164;
          }
        }
        ++v163;
      }
      while (v163 != 5);
      *(_DWORD *)(v482 + 4) = v477;
      *(_QWORD *)(v482 + 8) = 0xFFFFFFFFLL;
      *(_QWORD *)(v482 + 24) = glpDeepCopyType(&GLP_MALLOC_ALLOCATOR, (uint64_t)ArrayType);
      v210 = v485;
      if (v485)
        v210 = BitSetCloneWithAllocator(v485, GLP_MALLOC_ALLOCATOR, *((uint64_t (**)(uint64_t, uint64_t, const char *))&GLP_MALLOC_ALLOCATOR + 1), (uint64_t)off_255B0BD10, (uint64_t)off_255B0BD18);
      *(_QWORD *)(v482 + 32) = v210;
      *(_BYTE *)(v482 + 80) = 0;
      v211 = *(double *)v513;
      *(_OWORD *)(v482 + 40) = *(_OWORD *)v513;
      *(_DWORD *)(v482 + 56) = *(_DWORD *)&v513[16];
      v212 = v135[10];
      v213 = v130 >> 5;
      if (v130 >> 5 >= v130)
      {
        v215 = v130;
        v120 = v464;
        v123 = v474;
        v124 = v467;
      }
      else
      {
        v214 = ~(v130 >> 5);
        LODWORD(v215) = v130;
        v120 = v464;
        v123 = v474;
        v124 = v467;
        do
        {
          v215 = (32 * (_DWORD)v215 + (v215 >> 2) + v460[(v130 - 1)]) ^ v215;
          LODWORD(v130) = v130 + v214;
        }
        while (v130 > v213);
      }
      glpStringHashPut(v212, v460, v461 | (v215 << 32), v482, v211);
      if (!v484)
      {
        v216 = glpABIGetTypeSize(0, (uint64_t)ArrayType, 0);
        v471 += glpTypeSizeGetSize(v216);
      }
      v493 += v497;
      v462 += glpTypeGetSamplerCount((uint64_t)ArrayType);
      goto LABEL_288;
    }
LABEL_292:
    if (++v463 != 6)
      continue;
    break;
  }
  v510 = 4;
  v225 = (void *)(*((uint64_t (**)(_QWORD, uint64_t, const char *))&GLP_MALLOC_ALLOCATOR + 1))(GLP_MALLOC_ALLOCATOR, 64, "Vector Storage (GLPContextStateUniformEntry)");
  v511 = v225;
  if (v465)
  {
    v226 = v225;
    LODWORD(v227) = 0;
    v228 = 0;
    v229 = v471;
    do
    {
      __s2c = v228;
      v230 = *((_QWORD *)__src + v228);
      v472 = v229;
      *(_DWORD *)(v230 + 156) = v229;
      v231 = glpABIGetTypeSize(0, *(_QWORD *)v230, 0);
      v232 = glpTypeSizeGetSize(v231);
      if (v232)
      {
        v233 = v232;
        v234 = 0;
        v235 = 0;
        v236 = v472;
        do
        {
          *(_OWORD *)v513 = v236 + v235;
          v237 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 46);
          if (!v237 || *((_DWORD *)v237 + 4) != 9)
          {
            v238 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 46);
            if (v238)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFFFFFFFFFE0FFLL | ((v238[2] & 0x1F) << 8);
            v239 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 48);
            if (v239)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFFFF8FFFFFFFFLL | ((unint64_t)(v239[2] & 7) << 32);
            v240 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 49);
            if (v240)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFFF07FFFFFFFFLL | ((unint64_t)(v240[2] & 0x1F) << 35);
            v241 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 51);
            if (v241)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFF0FFFFFFFFFFLL | ((unint64_t)(v241[2] & 0xF) << 40);
            v242 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 53);
            if (v242)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFFEFFFFFFFFFFLL | ((unint64_t)(v242[2] & 1) << 40);
            v243 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 54);
            if (v243)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFF9FFFFFFFFFFLL | ((unint64_t)(v243[2] & 3) << 41);
            v244 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 55);
            if (v244)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFFFFEFFFFFFFFLL | ((unint64_t)(v244[2] & 1) << 32);
            v245 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 56);
            if (v245)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFFFF1FFFFFFFFLL | ((unint64_t)(v245[2] & 7) << 33);
            v246 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 58);
            if (v246)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFFC7FFFFFFFFFLL | ((unint64_t)(v246[2] & 7) << 39);
            v247 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 62);
            if (v247)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFFCFFFFFFFFFFLL | ((unint64_t)(v247[2] & 3) << 40);
            v248 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 64);
            if (v248)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFF8FFFFFFFFFFFLL | ((unint64_t)(v248[2] & 7) << 44);
            v249 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 65);
            if (v249)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFFFF0FFFFFFFFLL | ((unint64_t)(v249[2] & 0xF) << 32);
            v250 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 66);
            if (v250)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFFF0FFFFFFFFFLL | ((unint64_t)(v250[2] & 0xF) << 36);
            v251 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 67);
            if (v251)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFFFFFFFLL | ((unint64_t)*((unsigned int *)v251 + 4) << 40);
            v252 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 47);
            if (v252)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFFFFF0000FFFFLL | (v234
                                                                                              + (*((_DWORD *)v252 + 4) << 16));
            v253 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 50);
            if (v253)
              v513[12] = v235 + *((_BYTE *)v253 + 16);
            v254 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 52);
            if (v254)
              v513[12] = v235 + *((_BYTE *)v254 + 16);
            v255 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 57);
            if (v255)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFFF80FFFFFFFFLL | ((unint64_t)(((_BYTE)v235 + *((_DWORD *)v255 + 4)) & 0x7F) << 32);
            v256 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 59);
            if (v256)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFFF80FFFFFFFFLL | ((unint64_t)(((_BYTE)v235 + *((_DWORD *)v256 + 4)) & 0x7F) << 32);
            v257 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 60);
            if (v257)
              v513[12] = v235 + *((_BYTE *)v257 + 16);
            v258 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 61);
            if (v258)
              v513[12] = *((_BYTE *)v258 + 16) + (v235 >> 2);
            v259 = glpLayoutObjectFind(*(uint64_t **)(v230 + 8), 63);
            if (v259)
              *(_QWORD *)&v513[8] = *(_QWORD *)&v513[8] & 0xFFFFF3FFFFFFFFFFLL | ((unint64_t)(((_BYTE)v235 + *((_DWORD *)v259 + 4)) & 3) << 42);
            PPStreamTokenConvertParamBindingsToGeneric((unint64_t)&v513[8], 1);
            v517 = *(_OWORD *)v513;
            v260 = v510;
            if ((int)v227 + 1 <= v510)
            {
              v227 = v227;
            }
            else
            {
              if ((int)v510 <= 1)
                v260 = 1;
              v261 = 2 * v260;
              if (v261 <= (int)v227 + 1)
                v262 = v227 + 1;
              else
                v262 = v261;
              v263 = (void *)(*((uint64_t (**)(_QWORD, uint64_t, const char *))&GLP_MALLOC_ALLOCATOR + 1))(GLP_MALLOC_ALLOCATOR, 16 * v262, "Vector Storage (GLPContextStateUniformEntry, growth)");
              v227 = v227;
              memcpy(v263, v226, 16 * v227);
              off_255B0BD18(GLP_MALLOC_ALLOCATOR, v226);
              LODWORD(v510) = v262;
              v511 = v263;
            }
            v226 = v511;
            *((_OWORD *)v511 + v227) = v517;
            LODWORD(v227) = ++HIDWORD(v510);
          }
          ++v235;
          v234 += 0x40000;
          v236 = v472;
        }
        while (v233 != v235);
      }
      v264 = glpABIGetTypeSize(0, *(_QWORD *)v230, 0);
      v229 = glpTypeSizeGetSize(v264) + v472;
      v228 = __s2c + 1;
    }
    while (__s2c + 1 != v465);
  }
  else
  {
    v229 = v471;
  }
  v271 = v229;
  off_255B0BD18(GLP_MALLOC_ALLOCATOR, __src);
  v490[27] = glpCopyContextState((uint64_t)&v510);
  off_255B0BD18(GLP_MALLOC_ALLOCATOR, v511);
  v276 = 0;
  *((_DWORD *)v490 + 56) = v271;
  v277 = a1;
  do
  {
    if (*((int *)v519 + v276) >= 17)
    {
      v279 = (uint64_t **)a1[8];
      glpLanguageToString(v276);
      glpLanguageToString(v276);
      *(_QWORD *)v513 = "-1";
      *(_QWORD *)&v513[8] = 0xEDA00000002;
      *(_QWORD *)&v513[16] = 0xFFFFFFFFLL;
      glpLogMessage(v279, 0, (uint64_t)v513, "Implementation limit of %d active %s shader samplers (e.g., maximum number of supported image units) exceeded, %s shader uses %d samplers", v280, v281, v282, v283, 16);
      goto LABEL_374;
    }
    if (*((int *)v521 + v276) >= 1025)
    {
      v284 = (uint64_t **)a1[8];
      glpLanguageToString(v276);
      *(_QWORD *)v513 = "-1";
      *(_QWORD *)&v513[8] = 0xEDA00000002;
      *(_QWORD *)&v513[16] = 0xFFFFFFFFLL;
      glpLogMessage(v284, 0, (uint64_t)v513, "Implementation limit of %d (e.g., number of built-in plus user defined active uniforms components) exceeded, %s shader uses %d total uniforms.", v285, v286, v287, v288, 0);
      goto LABEL_374;
    }
    ++v276;
  }
  while (v276 != 5);
  if (v462 >= 33)
  {
    v278 = (uint64_t **)a1[8];
    *(_QWORD *)v513 = "-1";
    *(_QWORD *)&v513[8] = 0xEDA00000002;
    *(_QWORD *)&v513[16] = 0xFFFFFFFFLL;
    glpLogMessage(v278, 0, (uint64_t)v513, "Implementation limit of %d active samplers (e.g., maximum number of supported image units) exceeded, linked shaders use %d samplers", v272, v273, v274, v275, 32);
    goto LABEL_374;
  }
  v517 = 0uLL;
  v518 = 0;
  v490[11] = glpMakeStringHash(&GLP_MALLOC_ALLOCATOR);
  v289 = *(unsigned int *)(v464 + 32);
  if ((_DWORD)v289)
  {
    v290 = 0;
    *(_OWORD *)__s2d = 0u;
    do
    {
      v291 = *(_QWORD *)(v464 + 40);
      v292 = *(_QWORD *)(v291 + 32 * v290);
      if (v292 && (*(_BYTE *)(v292 + 52) & 4) != 0)
      {
        v293 = v291 + 32 * v290;
        v294 = *(const void **)(v293 + 8);
        v295 = *(_QWORD *)(v293 + 16);
        v498 = __abort_malloc_0(v295);
        memcpy(v498, v294, v295);
        v296 = (char *)__abort_malloc_0(0x58uLL);
        *(_OWORD *)v296 = 0u;
        *((_OWORD *)v296 + 1) = 0u;
        *((_OWORD *)v296 + 2) = 0u;
        *((_OWORD *)v296 + 3) = 0u;
        *((_OWORD *)v296 + 4) = 0u;
        *((_QWORD *)v296 + 10) = 0;
        *(char **)(v296 + 4) = __s2d[0];
        *((_DWORD *)v296 + 3) = 0;
        v297 = 0;
        *((_QWORD *)v296 + 3) = glpDeepCopyType(&GLP_MALLOC_ALLOCATOR, *(_QWORD *)v292);
        *((_QWORD *)v296 + 4) = 0;
        v296[80] = 0;
        *(_DWORD *)v296 = 0;
        v298 = (uint64_t *)v535;
        do
        {
          if (a1[v297 + 23])
          {
            v299 = glpStringHashGet(*v298, (const char *)v294, v295);
            if (v299)
            {
              *(_DWORD *)v296 |= 1 << v297;
              *(_DWORD *)(*(_QWORD *)(v299 + 88) + 28) = *((_DWORD *)v296 + 2);
              *(_DWORD *)&v296[4 * v297 + 40] = 0;
              ++*((_DWORD *)&v517 + v297);
            }
          }
          ++v297;
          v298 += 14;
        }
        while (v297 != 5);
        v300 = v490[11];
        String = (const char *)glpMakeString((uint64_t)v498, v295);
        glpStringHashPut(v300, String, v302, (uint64_t)v296, v303);
        Vec4s_1 = glpTypeGetVec4s_1(*(_QWORD *)v292);
        if (16 * glpTypeGetVec4s_1(*(_QWORD *)v292) > 0x4000)
        {
          v444 = (uint64_t **)a1[8];
          glpTypeGetVec4s_1(*(_QWORD *)v292);
          *(_QWORD *)v513 = "-1";
          *(_QWORD *)&v513[8] = 0xEDA00000002;
          *(_QWORD *)&v513[16] = 0xFFFFFFFFLL;
          glpLogMessage(v444, 0, (uint64_t)v513, "Bindable uniform %.*s too large (%d exceeds max %d)", v445, v446, v447, v448, v295);
          goto LABEL_374;
        }
        v277 = a1;
        if (glpTypeGetSamplerCount(*(_QWORD *)v292))
        {
          v449 = (uint64_t **)a1[8];
          *(_QWORD *)v513 = "-1";
          *(_QWORD *)&v513[8] = 0xEDA00000002;
          *(_QWORD *)&v513[16] = 0xFFFFFFFFLL;
          glpLogMessage(v449, 0, (uint64_t)v513, "Bindable uniform %.*s not allowed to have samplers", v305, v306, v307, v308, v295);
          goto LABEL_374;
        }
        *((char **)&v309 + 1) = __s2d[1];
        *(int32x2_t *)&v309 = vadd_s32((int32x2_t)(Vec4s_1 | 0x100000000), (int32x2_t)__s2d[0]);
        *(_OWORD *)__s2d = v309;
        v289 = *(unsigned int *)(v464 + 32);
      }
      ++v290;
    }
    while (v290 < v289);
  }
  for (m = 0; m != 5; ++m)
  {
    if (*((_DWORD *)&v517 + m) > dword_22A97F330[m])
    {
      v432 = (uint64_t **)v277[8];
      v433 = glpLanguageToString(m);
      *(_QWORD *)v513 = "-1";
      *(_QWORD *)&v513[8] = 0xEDA00000002;
      *(_QWORD *)&v513[16] = 0xFFFFFFFFLL;
      glpLogMessage(v432, 0, (uint64_t)v513, "Too many bindable uniforms in %s shader (%d exceeds max %d)", v434, v435, v436, v437, v433);
      goto LABEL_374;
    }
  }
  v515[0] = 0;
  v515[1] = 0;
  v516 = 0;
  v490[12] = glpMakeStringHash(&GLP_MALLOC_ALLOCATOR);
  v311 = *(unsigned int *)(v459 + 32);
  if (!(_DWORD)v311)
  {
LABEL_403:
    v334 = 0;
    v335 = (uint64_t)a1;
    do
    {
      if (*((_DWORD *)v515 + v334) > dword_22A97F344[v334])
      {
        v438 = (uint64_t **)a1[8];
        v439 = glpLanguageToString(v334);
        *(_QWORD *)v513 = "-1";
        *(_QWORD *)&v513[8] = 0xEDA00000002;
        *(_QWORD *)&v513[16] = 0xFFFFFFFFLL;
        glpLogMessage(v438, 0, (uint64_t)v513, "Too many uniform interface blocks in %s shader (%d exceeds max %d)", v440, v441, v442, v443, v439);
        goto LABEL_374;
      }
      ++v334;
    }
    while (v334 != 5);
    for (n = 0; n != 5; ++n)
    {
      __s2f = (char *)&v490[n];
      *((_QWORD *)__s2f + 13) = glpMakeStringHash(&GLP_MALLOC_ALLOCATOR);
      v337 = v335 + 8 * n;
      v340 = *(_QWORD *)(v337 + 184);
      v339 = (uint64_t *)(v337 + 184);
      v338 = v340;
      if (v340 && glpTopLevelNodeGetDefCount(v338))
      {
        v341 = 0;
        v342 = 0;
        do
        {
          Def = glpTopLevelNodeGetDef(*v339, v341);
          if (Def)
          {
            v344 = Def;
            if (glpASTNodeGetKind(Def) == 51)
            {
              Prototype = glpFunctionDefinitionNodeGetPrototype(v344);
              Extra = glpFunctionPrototypeNodeGetExtra(Prototype);
              if ((*(_BYTE *)(Extra + 10) & 0x10) != 0)
              {
                v347 = Extra;
                *(_DWORD *)(Extra + 160) = v342;
                v348 = __abort_malloc_0(0x10uLL);
                *v348 = 0;
                v348[1] = 0;
                *(_DWORD *)v348 = -1;
                *((_DWORD *)v348 + 1) = *(_DWORD *)(v347 + 160);
                v348[1] = 0;
                v349 = __abort_malloc_0(*(unsigned int *)(v347 + 32));
                memcpy(v349, *(const void **)(v347 + 24), *(unsigned int *)(v347 + 32));
                v350 = *((_QWORD *)__s2f + 13);
                v351 = (const char *)glpMakeString((uint64_t)v349, *(_DWORD *)(v347 + 32));
                glpStringHashPut(v350, v351, v352, (uint64_t)v348, v353);
                ++v342;
              }
            }
          }
          ++v341;
        }
        while (v341 < glpTopLevelNodeGetDefCount(*v339));
        if (v342 > 4096)
        {
          v456 = *(uint64_t ***)(v335 + 64);
          *(_QWORD *)v513 = "-1";
          *(_QWORD *)&v513[8] = 0xEDA00000002;
          *(_QWORD *)&v513[16] = 0xFFFFFFFFLL;
          glpLogMessage(v456, 0, (uint64_t)v513, "Too many subroutines (%d exceeds max %d)", v354, v355, v356, v357, v342);
          goto LABEL_374;
        }
      }
      *((_QWORD *)__s2f + 18) = glpMakeStringHash(&GLP_MALLOC_ALLOCATOR);
      __s2g = (uint64_t *)(__s2f + 144);
      if (*v339)
      {
        v362 = &v534[14 * n];
        v363 = v362[7];
        v364 = *(unsigned int *)(v363 + 32);
        if ((_DWORD)v364)
        {
          v365 = 0;
          v366 = 0;
          v494 = n;
          v500 = 1 << n;
          do
          {
            v367 = *(_QWORD *)(v363 + 40);
            v368 = *(_QWORD *)(v367 + 32 * v365);
            if (v368)
            {
              v369 = v367 + 32 * v365;
              v370 = *(const void **)(v369 + 8);
              v371 = *(unsigned int *)(v369 + 16);
              v372 = *(unsigned int **)(v368 + 16);
              if (glpTypeGetKind(v372) == 2)
                v372 = (unsigned int *)glpArrayTypeGetElementType((uint64_t)v372);
              v373 = __abort_malloc_0(v371);
              memcpy(v373, v370, v371);
              v374 = __abort_malloc_0(0x58uLL);
              *v374 = 0u;
              v374[1] = 0u;
              v374[2] = 0u;
              v374[3] = 0u;
              v374[4] = 0u;
              *((_QWORD *)v374 + 10) = 0;
              *((_DWORD *)v374 + 1) = v366;
              *((_QWORD *)v374 + 1) = 0xFFFFFFFFLL;
              *((_QWORD *)v374 + 3) = glpDeepCopyType(&GLP_MALLOC_ALLOCATOR, *(_QWORD *)(v368 + 16));
              *((_QWORD *)v374 + 4) = 0;
              *((_BYTE *)v374 + 80) = 0;
              *(_DWORD *)v374 = v500;
              v375 = glpPointerHashGet(v362[8], (unint64_t)v372);
              v376 = *(unsigned int *)(v375 + 4);
              *((_QWORD *)v374 + 8) = v376;
              *((_QWORD *)v374 + 9) = (*((uint64_t (**)(_QWORD, uint64_t, const char *))&GLP_MALLOC_ALLOCATOR
                                       + 1))(GLP_MALLOC_ALLOCATOR, 4 * v376, "Vector Storage (int)");
              if (*(_DWORD *)(v375 + 4))
              {
                v377 = 0;
                do
                {
                  v378 = glpFunctionDefinitionNodeGetPrototype(*(_QWORD *)(*(_QWORD *)(v375 + 8) + 8 * v377));
                  *(_DWORD *)(*((_QWORD *)v374 + 9) + 4 * (*((_DWORD *)v374 + 17))++) = *(_DWORD *)(glpFunctionPrototypeNodeGetExtra(v378) + 160);
                  ++v377;
                }
                while (v377 < *(unsigned int *)(v375 + 4));
              }
              *(_DWORD *)(v368 + 40) = *((_DWORD *)v374 + 1);
              v379 = *__s2g;
              v380 = (const char *)glpMakeString((uint64_t)v373, v371);
              glpStringHashPut(v379, v380, v381, (uint64_t)v374, v382);
              v366 += glpTypeGetVec4s_1(*(_QWORD *)(v368 + 16));
              v364 = *(unsigned int *)(v363 + 32);
            }
            ++v365;
          }
          while (v365 < v364);
          v335 = (uint64_t)a1;
          n = v494;
          if (v366 > 4096)
          {
            v457 = (uint64_t **)a1[8];
            *(_QWORD *)v513 = "-1";
            *(_QWORD *)&v513[8] = 0xEDA00000002;
            *(_QWORD *)&v513[16] = 0xFFFFFFFFLL;
            glpLogMessage(v457, 0, (uint64_t)v513, "Too many subroutine uniforms (%d exceeds max %d)", v358, v359, v360, v361, v366);
            goto LABEL_374;
          }
        }
      }
    }
    v490[23] = glpMakeStringHash(&GLP_MALLOC_ALLOCATOR);
    v383 = v541;
    if ((_QWORD)v541)
    {
      v384 = *(unsigned int *)(v541 + 32);
      if ((_DWORD)v384)
      {
        v385 = 0;
        for (ii = 0; ii < v384; ++ii)
        {
          v387 = *(_QWORD *)(v383 + 40);
          v388 = *(_QWORD *)(v387 + v385);
          if (v388)
          {
            v389 = *(const void **)(v387 + v385 + 8);
            v390 = *(unsigned int *)(v387 + v385 + 16);
            v391 = __abort_malloc_0(0x10uLL);
            *v391 = 0;
            v391[1] = 0;
            *(_DWORD *)v391 = *(_DWORD *)v388;
            v391[1] = glpDeepCopyType(&GLP_MALLOC_ALLOCATOR, *(_QWORD *)(v388 + 8));
            v392 = __abort_malloc_0(v390);
            memcpy(v392, v389, v390);
            v393 = v490[23];
            v394 = (const char *)glpMakeString((uint64_t)v392, v390);
            glpStringHashPut(v393, v394, v395, (uint64_t)v391, v396);
            v384 = *(unsigned int *)(v383 + 32);
          }
          v385 += 32;
        }
      }
    }
    v490[24] = glpMakeStringHash(&GLP_MALLOC_ALLOCATOR);
    v397 = v533;
    if (v533)
    {
      v398 = *(unsigned int *)(v533 + 32);
      if ((_DWORD)v398)
      {
        v399 = 0;
        for (jj = 0; jj < v398; ++jj)
        {
          v401 = *(_QWORD *)(v397 + 40);
          v402 = *(_QWORD **)(v401 + v399);
          if (v402)
          {
            v403 = *(const void **)(v401 + v399 + 8);
            v404 = *(unsigned int *)(v401 + v399 + 16);
            v405 = __abort_malloc_0(0x10uLL);
            *v405 = 0;
            v405[1] = 0;
            *v405 = *v402;
            v405[1] = glpDeepCopyType(&GLP_MALLOC_ALLOCATOR, v402[1]);
            v406 = __abort_malloc_0(v404);
            memcpy(v406, v403, v404);
            v407 = v490[24];
            v408 = (const char *)glpMakeString((uint64_t)v406, v404);
            glpStringHashPut(v407, v408, v409, (uint64_t)v405, v410);
            v398 = *(unsigned int *)(v397 + 32);
          }
          v399 += 32;
        }
      }
    }
    v411 = 0;
    v412 = *(_OWORD *)(v335 + 296);
    v413 = *(_OWORD *)(v335 + 328);
    *((_OWORD *)v490 + 18) = *(_OWORD *)(v335 + 312);
    *((_OWORD *)v490 + 19) = v413;
    *((_OWORD *)v490 + 17) = v412;
    v490[40] = *(_QWORD *)(v335 + 344);
    *(_QWORD *)(v335 + 344) = 0;
    do
    {
      v490[v411] = 0;
      v414 = (char *)&v490[v411];
      *((_QWORD *)v414 + 5) = 0;
      v415 = (uint64_t *)(v414 + 40);
      v416 = v335 + 8 * v411;
      v419 = *(_QWORD *)(v416 + 184);
      v418 = (uint64_t *)(v416 + 184);
      v417 = v419;
      if (v419)
      {
        *(_QWORD *)v513 = v335;
        *(_OWORD *)&v513[8] = *(_OWORD *)(v335 + 64);
        v514 = v417;
        *v418 = glpPPTNode((uint64_t *)v513, v417);
        v420 = v335 + 4 * v411;
        v421 = (char *)v490 + 4 * v411;
        *((_DWORD *)v421 + 58) = *(_DWORD *)(v420 + 256);
        *((_DWORD *)v421 + 63) = *(_DWORD *)(v420 + 276);
        v422 = *(_DWORD *)(v335 + 40);
        if ((v422 & 2) != 0)
        {
          glpCreateShaderByteCode();
          *v415 = v423;
          if ((*(_BYTE *)(v335 + 40) & 8) != 0)
          {
            if (*((_DWORD *)v523 + v411))
              v424 = 2;
            else
              v424 = 1;
          }
          else
          {
            v424 = 1;
          }
          v425 = 0;
          v426 = *((_DWORD *)v523 + v411);
          v335 = (uint64_t)a1;
          do
          {
            if (v425)
              v427 = 1;
            else
              v427 = v426 == 0;
            v428 = !v427;
            LLVMCodeGenContext = glpMakeLLVMCodeGenContext((uint64_t)a1, (uint64_t)v490, *v415, v411, (uint64_t)v512, v425, v428);
            glpLLVMCGTopLevel((uint64_t)LLVMCodeGenContext, *v418);
            glpDestroyLLVMCodeGenContext(LLVMCodeGenContext);
            ++v425;
          }
          while (v424 != v425);
          v422 = *((_DWORD *)a1 + 10);
        }
        if ((v422 & 1) != 0)
        {
          v430 = PPStreamCreate();
          v490[v411] = v430;
          CodeGenContext = (_QWORD *)glpMakeCodeGenContext(v335, v430, v411);
          if (glpCGTopLevel(CodeGenContext, *v418, (uint64_t)&v538[7 * v411]) == -1)
            goto LABEL_374;
          glpDestroyCodeGenContext(CodeGenContext);
        }
      }
      ++v411;
    }
    while (v411 != 5);
    return v490;
  }
  v312 = 0;
  v313 = 0;
  while (2)
  {
    v314 = *(_QWORD *)(v459 + 40);
    v315 = *(_QWORD *)(v314 + 32 * v312);
    if (!v315)
    {
LABEL_402:
      if (++v312 >= v311)
        goto LABEL_403;
      continue;
    }
    break;
  }
  v316 = v314 + 32 * v312;
  v317 = *(const void **)(v316 + 8);
  v318 = *(_QWORD *)(v316 + 16);
  __s2e = __abort_malloc_0(v318);
  memcpy(__s2e, v317, v318);
  v319 = __abort_malloc_0(0x58uLL);
  *v319 = 0u;
  v319[1] = 0u;
  v319[2] = 0u;
  v319[3] = 0u;
  v319[4] = 0u;
  *((_QWORD *)v319 + 10) = 0;
  *((_DWORD *)v319 + 1) = -1;
  *((_DWORD *)v319 + 2) = v313;
  v499 = v313;
  v320 = 0;
  *((_QWORD *)v319 + 3) = glpDeepCopyType(&GLP_MALLOC_ALLOCATOR, *(_QWORD *)(v315 + 64));
  *((_QWORD *)v319 + 4) = 0;
  *((_BYTE *)v319 + 80) = *(_BYTE *)(v315 + 32) == 0;
  *(_DWORD *)v319 = 0;
  v321 = &v536;
  do
  {
    if (a1[v320 + 23])
    {
      v322 = glpStringHashGet(*v321, (const char *)v317, v318);
      if (v322)
      {
        *(_DWORD *)v319 |= 1 << v320;
        v323 = *(_QWORD *)(v322 + 80);
        *((_DWORD *)v319 + 3) = *(_DWORD *)(v323 + 8);
        *(_DWORD *)(v323 + 28) = *((_DWORD *)v319 + 2);
        *((_DWORD *)v319 + v320 + 10) = 0;
        *((_DWORD *)v515 + v320) += *(_DWORD *)(*(_QWORD *)(v315 + 80) + 12);
      }
    }
    ++v320;
    v321 += 14;
  }
  while (v320 != 5);
  v324 = v490[12];
  v325 = (const char *)glpMakeString((uint64_t)__s2e, v318);
  glpStringHashPut(v324, v325, v326, (uint64_t)v319, v327);
  v328 = *(_QWORD *)(v315 + 80);
  v329 = *(_DWORD *)(v328 + 12);
  if (glpBufferObjectGetMinimumBufferSize(v328) > 0x4000)
  {
    v450 = (uint64_t **)a1[8];
    glpBufferObjectGetMinimumBufferSize(*(_QWORD *)(v315 + 80));
    *(_QWORD *)v513 = "-1";
    *(_QWORD *)&v513[8] = 0xEDA00000002;
    *(_QWORD *)&v513[16] = 0xFFFFFFFFLL;
    glpLogMessage(v450, 0, (uint64_t)v513, "Uniform interface block %.*s too large (%d exceeds max %d)", v451, v452, v453, v454, v318);
    goto LABEL_374;
  }
  if (!glpTypeGetSamplerCount(*(_QWORD *)(v315 + 64)))
  {
    v313 = v329 + v499;
    v311 = *(unsigned int *)(v459 + 32);
    goto LABEL_402;
  }
  v455 = (uint64_t **)a1[8];
  *(_QWORD *)v513 = "-1";
  *(_QWORD *)&v513[8] = 0xEDA00000002;
  *(_QWORD *)&v513[16] = 0xFFFFFFFFLL;
  glpLogMessage(v455, 0, (uint64_t)v513, "Uniform interface block %.*s not allowed to have samplers", v330, v331, v332, v333, v318);
LABEL_374:
  glpDestroyLinkedProgram((uint64_t)v490);
  return 0;
}

uint64_t glpTypeGetVec4s_1(uint64_t a1)
{
  unsigned int v1;

  v1 = glpABIGetTypeSize(0, a1, 0);
  return glpTypeSizeGetSize(v1);
}

uint64_t glpLinkerPoolAlloc(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 8))(*(_QWORD *)a1);
}

_DWORD *glpCopyContextState(uint64_t a1)
{
  uint64_t v2;
  _DWORD *v3;
  _DWORD *v4;
  uint64_t v5;

  v2 = *(int *)(a1 + 4);
  v3 = malloc_type_malloc((16 * v2) | 8, 0x7081ABB9uLL);
  if (!v3)
    abort();
  v4 = v3;
  bzero(v3, (16 * v2) | 8);
  *v4 = v2;
  if ((int)v2 >= 1)
  {
    v5 = 0;
    do
    {
      *(_OWORD *)&v4[v5 + 2] = *(_OWORD *)(*(_QWORD *)(a1 + 8) + v5 * 4);
      v5 += 4;
    }
    while (4 * v2 != v5);
  }
  return v4;
}

void glpDestroyLinkedProgram(uint64_t a1)
{
  uint64_t i;
  _DWORD **v3;
  uint64_t j;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t k;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  void *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t m;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t n;
  uint64_t v29;
  uint64_t *v30;
  uint64_t ii;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t jj;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t kk;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t mm;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t nn;
  uint64_t v57;
  uint64_t *v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t i1;
  void **v63;

  for (i = 0; i != 40; i += 8)
  {
    v3 = *(_DWORD ***)(a1 + i);
    if (v3)
    {
      PPStreamFree(v3);
      *(_QWORD *)(a1 + i) = 0;
    }
  }
  for (j = 40; j != 80; j += 8)
  {
    v5 = *(_QWORD *)(a1 + j);
    if (v5)
    {
      if (*(_QWORD *)v5)
      {
        free(*(void **)v5);
        *(_QWORD *)v5 = 0;
      }
      v6 = *(void **)(v5 + 8);
      if (v6)
      {
        free(v6);
        *(_QWORD *)(v5 + 8) = 0;
      }
      v7 = *(void **)(v5 + 32);
      if (v7)
      {
        free(v7);
        *(_QWORD *)(v5 + 32) = 0;
      }
      v8 = *(void **)(v5 + 40);
      if (v8)
      {
        free(v8);
        *(_QWORD *)(v5 + 40) = 0;
      }
      v9 = *(void **)(v5 + 16);
      if (v9)
      {
        free(v9);
        *(_QWORD *)(v5 + 16) = 0;
      }
      v10 = *(void **)(v5 + 24);
      if (v10)
        free(v10);
      free((void *)v5);
      *(_QWORD *)(a1 + j) = 0;
    }
  }
  v11 = *(_QWORD *)(a1 + 80);
  if (v11)
  {
    v12 = *(unsigned int *)(v11 + 32);
    if ((_DWORD)v12)
    {
      v13 = 0;
      for (k = 0; k < v12; ++k)
      {
        v15 = *(_QWORD *)(v11 + 40);
        v16 = *(_QWORD *)(v15 + v13);
        if (v16)
        {
          free(*(void **)(v15 + v13 + 8));
          glpDestroyType(&GLP_MALLOC_ALLOCATOR, *(_QWORD *)(v16 + 24));
          v17 = *(_QWORD **)(v16 + 32);
          if (v17)
            BitSetFree(v17);
          free(*(void **)(v16 + 16));
          free((void *)v16);
          v12 = *(unsigned int *)(v11 + 32);
        }
        v13 += 32;
      }
      v11 = *(_QWORD *)(a1 + 80);
    }
    glpDestroyStringHash(v11);
  }
  off_255B0BD18(GLP_MALLOC_ALLOCATOR, *(void **)(a1 + 208));
  v18 = *(void **)(a1 + 216);
  if (v18)
  {
    free(v18);
    *(_QWORD *)(a1 + 216) = 0;
  }
  v19 = *(_QWORD *)(a1 + 88);
  if (v19)
  {
    v20 = *(unsigned int *)(v19 + 32);
    if ((_DWORD)v20)
    {
      v21 = 0;
      for (m = 0; m < v20; ++m)
      {
        v23 = *(_QWORD *)(v19 + 40);
        v24 = *(uint64_t **)(v23 + v21);
        if (v24)
        {
          free(*(void **)(v23 + v21 + 8));
          glpDestroyType(&GLP_MALLOC_ALLOCATOR, v24[3]);
          free(v24);
          v20 = *(unsigned int *)(v19 + 32);
        }
        v21 += 32;
      }
      v19 = *(_QWORD *)(a1 + 88);
    }
    glpDestroyStringHash(v19);
  }
  v25 = *(_QWORD *)(a1 + 96);
  if (v25)
  {
    v26 = *(unsigned int *)(v25 + 32);
    if ((_DWORD)v26)
    {
      v27 = 0;
      for (n = 0; n < v26; ++n)
      {
        v29 = *(_QWORD *)(v25 + 40);
        v30 = *(uint64_t **)(v29 + v27);
        if (v30)
        {
          free(*(void **)(v29 + v27 + 8));
          glpDestroyType(&GLP_MALLOC_ALLOCATOR, v30[3]);
          free(v30);
          v26 = *(unsigned int *)(v25 + 32);
        }
        v27 += 32;
      }
      v25 = *(_QWORD *)(a1 + 96);
    }
    glpDestroyStringHash(v25);
  }
  for (ii = 0; ii != 5; ++ii)
  {
    v32 = a1 + 8 * ii;
    v33 = *(_QWORD *)(v32 + 104);
    if (v33)
    {
      v34 = *(unsigned int *)(v33 + 32);
      if ((_DWORD)v34)
      {
        v35 = 0;
        for (jj = 0; jj < v34; ++jj)
        {
          v37 = *(_QWORD *)(v33 + 40);
          v38 = *(void **)(v37 + v35);
          if (v38)
          {
            free(*(void **)(v37 + v35 + 8));
            free(v38);
            v34 = *(unsigned int *)(v33 + 32);
          }
          v35 += 32;
        }
        v33 = *(_QWORD *)(v32 + 104);
      }
      glpDestroyStringHash(v33);
    }
    v41 = *(_QWORD *)(v32 + 144);
    v40 = (uint64_t *)(v32 + 144);
    v39 = v41;
    if (v41)
    {
      v42 = *(unsigned int *)(v39 + 32);
      if ((_DWORD)v42)
      {
        v43 = 0;
        for (kk = 0; kk < v42; ++kk)
        {
          v45 = *(_QWORD *)(v39 + 40);
          v46 = *(_QWORD *)(v45 + v43);
          if (v46)
          {
            free(*(void **)(v45 + v43 + 8));
            glpDestroyType(&GLP_MALLOC_ALLOCATOR, *(_QWORD *)(v46 + 24));
            off_255B0BD18(GLP_MALLOC_ALLOCATOR, *(void **)(v46 + 72));
            free((void *)v46);
            v42 = *(unsigned int *)(v39 + 32);
          }
          v43 += 32;
        }
        v39 = *v40;
      }
      glpDestroyStringHash(v39);
    }
  }
  v47 = *(_QWORD *)(a1 + 184);
  if (v47)
  {
    v48 = *(unsigned int *)(v47 + 32);
    if ((_DWORD)v48)
    {
      v49 = 0;
      for (mm = 0; mm < v48; ++mm)
      {
        v51 = *(_QWORD *)(v47 + 40);
        v52 = *(uint64_t **)(v51 + v49);
        if (v52)
        {
          free(*(void **)(v51 + v49 + 8));
          glpDestroyType(&GLP_MALLOC_ALLOCATOR, v52[1]);
          free(v52);
          v48 = *(unsigned int *)(v47 + 32);
        }
        v49 += 32;
      }
      v47 = *(_QWORD *)(a1 + 184);
    }
    glpDestroyStringHash(v47);
  }
  v53 = *(_QWORD *)(a1 + 192);
  if (v53)
  {
    v54 = *(unsigned int *)(v53 + 32);
    if ((_DWORD)v54)
    {
      v55 = 0;
      for (nn = 0; nn < v54; ++nn)
      {
        v57 = *(_QWORD *)(v53 + 40);
        v58 = *(uint64_t **)(v57 + v55);
        if (v58)
        {
          free(*(void **)(v57 + v55 + 8));
          glpDestroyType(&GLP_MALLOC_ALLOCATOR, v58[1]);
          free(v58);
          v54 = *(unsigned int *)(v53 + 32);
        }
        v55 += 32;
      }
      v53 = *(_QWORD *)(a1 + 192);
    }
    glpDestroyStringHash(v53);
  }
  v59 = *(_QWORD *)(a1 + 320);
  if (v59)
  {
    v60 = *(unsigned int *)(v59 + 32);
    if ((_DWORD)v60)
    {
      v61 = 0;
      for (i1 = 0; i1 < v60; ++i1)
      {
        v63 = *(void ***)(*(_QWORD *)(v59 + 40) + v61);
        if (v63)
        {
          free(*v63);
          free(v63);
          v60 = *(unsigned int *)(v59 + 32);
        }
        v61 += 16;
      }
      v59 = *(_QWORD *)(a1 + 320);
    }
    glpDestroyIntHash(v59);
  }
  free((void *)a1);
}

uint64_t glpLinkerGetCodeGenType(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t glpLinkedProgramGetPPStreamManager(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(a1 + 8 * a2);
}

uint64_t glpLinkedProgramGetShaderBytesCode(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(a1 + 8 * a2 + 40);
}

uint64_t glpLinkedProgramGetUniformHash(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

uint64_t glpLinkedProgramGetBindableUniformHash(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

uint64_t glpLinkedProgramGetUniformInterfaceBlockHash(uint64_t a1)
{
  return *(_QWORD *)(a1 + 96);
}

uint64_t glpLinkedProgramGetSubroutineHash(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(a1 + 8 * a2 + 104);
}

uint64_t glpLinkedProgramGetSubroutineUniformHash(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(a1 + 8 * a2 + 144);
}

uint64_t glpLinkedProgramGetSubroutineUniformLocationCount(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;

  v2 = *(_QWORD *)(a1 + 8 * a2 + 144);
  v3 = *(unsigned int *)(v2 + 32);
  if (!(_DWORD)v3)
    return 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  do
  {
    v7 = *(_QWORD *)(*(_QWORD *)(v2 + 40) + v4);
    if (v7)
    {
      v8 = glpABIGetTypeSize(0, *(_QWORD *)(v7 + 24), 0);
      v6 = glpTypeSizeGetSize(v8) + v6;
      v3 = *(unsigned int *)(v2 + 32);
    }
    ++v5;
    v4 += 32;
  }
  while (v5 < v3);
  return v6;
}

uint64_t glpLinkedProgramGetAttribHash(uint64_t a1)
{
  return *(_QWORD *)(a1 + 184);
}

uint64_t glpLinkedProgramGetOutputHash(uint64_t a1)
{
  return *(_QWORD *)(a1 + 192);
}

uint64_t glpLinkedProgramGetSamplerLocations(uint64_t a1)
{
  return a1 + 200;
}

uint64_t glpLinkedProgramGetContextStateUniforms(uint64_t a1)
{
  return *(_QWORD *)(a1 + 216);
}

uint64_t glpLinkedProgramGetTransformFeedbackHash(uint64_t a1)
{
  return *(_QWORD *)(a1 + 320);
}

uint64_t glpLinkedProgramGetDefaultUniformLocationCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 224);
}

uint64_t glpLinkedProgramGetActiveOutComponents(uint64_t a1, unsigned int a2)
{
  return *(unsigned int *)(a1 + 4 * a2 + 252);
}

__n128 glpLinkedProgramGetOverrides(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a1 + 272);
  v3 = *(_OWORD *)(a1 + 304);
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 288);
  *(_OWORD *)(a2 + 32) = v3;
  *(__n128 *)a2 = result;
  return result;
}

void glpDestroyCompiledShader(void **a1)
{
  free(a1[2]);
  free(a1);
}

void glpCleanUpLinkedProgram(uint64_t a1)
{
  uint64_t i;
  _DWORD **v3;

  for (i = 0; i != 40; i += 8)
  {
    v3 = *(_DWORD ***)(a1 + i);
    if (v3)
    {
      PPStreamFree(v3);
      *(_QWORD *)(a1 + i) = 0;
    }
  }
}

double glpCreateShaderByteCode()
{
  _QWORD *v0;
  double result;

  v0 = malloc_type_malloc(0x58uLL, 0x7081ABB9uLL);
  if (!v0)
    abort();
  v0[10] = 0;
  result = 0.0;
  *((_OWORD *)v0 + 3) = 0u;
  *((_OWORD *)v0 + 4) = 0u;
  *((_OWORD *)v0 + 1) = 0u;
  *((_OWORD *)v0 + 2) = 0u;
  *(_OWORD *)v0 = 0u;
  return result;
}

void *glpGenerateCopyInOut(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v11;
  unsigned int *PrimitiveType;
  int v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int *ElementType;
  unsigned int v21;
  unsigned int v22;
  unint64_t Size;
  _DWORD *v24;
  _BYTE *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  char *MutableValue;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t VRLFunctionFragment;
  char *v38;
  uint64_t v39;
  int ScalarCount;
  int v41;
  int v42;
  uint64_t v43;
  int ScalarType;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *Extra;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  uint64_t v55;
  unsigned int **v56;
  uint64_t CopyInAssignFragment;
  unsigned int v58;
  char *v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int Swizzle_1;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  unint64_t v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t i;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  __n128 *v95;
  const char *v96;
  uint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  unsigned int ***v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  unsigned int *v105;
  unsigned int v106;
  unsigned int v107;
  unsigned int v108;
  unint64_t v109;
  _DWORD *v110;
  _BYTE *v111;
  _BYTE *v112;
  unint64_t v113;
  int v114;
  int v115;
  int v116;
  unint64_t v117;
  int v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  char *v128;
  uint64_t v129;
  unsigned int **v130;
  uint64_t CopyOutAssignFragment;
  unsigned int v132;
  char *v133;
  uint64_t v134;
  int v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  int v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  int v161;
  uint64_t v162;
  uint64_t TypeConversionNode;
  uint64_t SaFlags;
  unint64_t v165;
  uint64_t v166;
  unint64_t j;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  unsigned int *v174;
  unint64_t v175;
  char *v176;
  size_t v177;
  unint64_t v178;
  uint64_t v179;
  char *v180;
  uint64_t v181;
  uint64_t *v182;
  uint64_t *StringBuffer;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t String;
  uint64_t v191;
  uint64_t v192;
  uint64_t *v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t CopyVarDeclFragment;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  unsigned int v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  unsigned int v206;
  unsigned int *v207;
  int Kind;
  unsigned int v209;
  _DWORD *v210;
  _BYTE *v211;
  unsigned int v212;
  uint64_t v213;
  int v214;
  int v215;
  int v216;
  uint64_t v217;
  int v218;
  uint64_t VectorType;
  _QWORD *v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  char *v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  char *v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t *v237;
  uint64_t StoreFragment;
  uint64_t v239;
  char *v240;
  uint64_t v241;
  uint64_t v242;
  char *v243;
  int v244;
  int DefCount;
  uint64_t Def;
  uint64_t Body;
  unsigned int StatementCount;
  uint64_t Statement;
  uint64_t Expr;
  int ExprCount;
  uint64_t v252;
  uint64_t v253;
  char *v254;
  void *result;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  char *v259;
  uint64_t v260;
  uint64_t CopyFunction;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  int v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  unint64_t v269;
  uint64_t v270;
  unint64_t v271;
  unint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t SlotVars;
  uint64_t *v276;
  uint64_t *v277;
  uint64_t v278;
  char *v279;
  _BYTE *v280;
  _DWORD *v281;
  unsigned int *v282;
  _BYTE *v283;
  uint64_t v284;
  _QWORD *v285;
  __n128 v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  _OWORD v293[2];
  _OWORD v294[2];
  __n128 v295;
  uint64_t v296;
  unint64_t v297;
  const char *v298;
  unint64_t v299;
  const char *v300;
  unint64_t v301;
  uint64_t v302;

  v264 = a8;
  v263 = a7;
  v270 = a6;
  v260 = a5;
  v265 = a2;
  v11 = a1;
  v284 = a10;
  v302 = *MEMORY[0x24BDAC8D0];
  SlotVars = generateSlotVars(a1, a3, "$in%u");
  PrimitiveType = (unsigned int *)glpGetPrimitiveType(5u);
  *(_QWORD *)&v294[0] = 0;
  v267 = a9;
  CopyFunction = makeCopyFunction(v11, a9, "$copy_in", 0x2CF8B77300000008, (uint64_t *)v294);
  v13 = *(_DWORD *)(a4 + 32);
  v285 = v11;
  if (v13)
  {
    v14 = 0;
    v262 = a4;
    do
    {
      v15 = *(_QWORD *)(a4 + 40);
      v16 = *(_QWORD *)(v15 + 32 * v14);
      if (v16)
      {
        v17 = v15 + 32 * v14;
        v19 = *(_QWORD *)(v17 + 8);
        v18 = *(_QWORD *)(v17 + 16);
        v278 = v19;
        v277 = (uint64_t *)v18;
        ElementType = **(unsigned int ***)v16;
        if (glpTypeGetKind(ElementType))
        {
          LODWORD(v276) = 0;
        }
        else
        {
          v21 = glpPrimitiveTypeGetPrimitiveType((uint64_t)ElementType);
          LODWORD(v276) = glpPrimitiveTypeGetCategory(v21) != 3;
        }
        if (glpTypeGetKind(ElementType) == 3)
        {
          LODWORD(v269) = glpBankTypeGetElementCount((uint64_t)ElementType);
          ElementType = (unsigned int *)glpBankTypeGetElementType((uint64_t)ElementType);
        }
        else
        {
          LODWORD(v269) = 0;
        }
        v22 = glpABIGetTypeSize(0, (uint64_t)ElementType, 0);
        Size = glpTypeSizeGetSize(v22);
        v24 = (_DWORD *)((uint64_t (*)(_QWORD, unint64_t, const char *))v11[1])(*v11, 4 * Size, "Array of vec4 types for Copy In (why not stack alloc'd?)");
        v25 = (_BYTE *)((uint64_t (*)(_QWORD, unint64_t, const char *))v11[1])(*v11, Size, "Array of flags for Copy In (why not stack alloc'd?)");
        v283 = v24;
        glpTypeGetAppleVec4Types(ElementType, v24, 1, 0, 0, v25, 0, 0, 0);
        if (*(_DWORD *)(v16 + 8))
        {
          v266 = v14;
          v31 = 0;
          v32 = v269;
          if (v269 <= 1)
            v32 = 1;
          LODWORD(v268) = v32;
          v272 = Size;
          do
          {
            if ((_DWORD)v269)
            {
              MutableValue = glpMakeMutableValue((uint64_t)v11, PrimitiveType, 1, v26, v27, v28, v29, v30, v31);
              v34 = glpTypedValueHashCache(v284, PrimitiveType, MutableValue, (uint64_t)MutableValue);
              v295.n128_u64[0] = (unint64_t)"-1";
              v295.n128_u64[1] = 0xEDA00000002;
              v296 = 0xFFFFFFFFLL;
              glpMakeConstantNode((uint64_t)v11, &v295, (uint64_t)PrimitiveType, v34);
              v36 = v35;
              glpASTNodeSetSaType(v35, (uint64_t)PrimitiveType);
              v295.n128_u64[0] = (unint64_t)"-1";
              v295.n128_u64[1] = 0xEDA00000002;
              v296 = 0xFFFFFFFFLL;
              VRLFunctionFragment = glpMakeVRLFunctionFragment(v11, &v295, v36);
              glpBlockNodeAddStatement(v11, *(uint64_t *)&v294[0], VRLFunctionFragment);
              v38 = glpGetPrimitiveType(0);
              glpASTNodeSetSaType(VRLFunctionFragment, (uint64_t)v38);
            }
            v271 = v31;
            if ((_DWORD)Size)
            {
              v39 = 0;
              LODWORD(v281) = 0;
              LODWORD(v273) = v271 * Size;
              do
              {
                if (BitSetGetEquals(*(_QWORD *)(*(_QWORD *)v16 + 120), v39))
                {
                  ScalarCount = glpPrimitiveTypeGetScalarCount(*(unsigned int *)&v283[4 * v39]);
                  v41 = (v25[v39] >> 1) & 2;
                  LODWORD(v282) = ScalarCount;
                  v42 = ScalarCount + v41;
                  v43 = v39 + 1;
                  if (v39 + 1 < Size && (v25[v43] & 4) != 0)
                    v42 += glpPrimitiveTypeGetScalarCount(*(unsigned int *)&v283[4 * v43]);
                  ScalarType = glpPrimitiveTypeGetScalarType(*(unsigned int *)&v283[4 * v39]);
                  LODWORD(v280) = glpGetVectorType(ScalarType, v42);
                  if ((_DWORD)v282)
                  {
                    v274 = v39 + 1;
                    v45 = 0;
                    LODWORD(v279) = v273 + v39;
                    do
                    {
                      v46 = ((_DWORD)v281 + v45);
                      v47 = glpIntHashGet(SlotVars, *(_DWORD *)(v16 + 8 * v46 + 16));
                      Extra = (uint64_t *)glpVariableDeclarationNodeGetExtra(v47);
                      v292 = 0;
                      *(_QWORD *)&v293[0] = 0;
                      v286.n128_u64[0] = 0;
                      v291 = 0;
                      v290 = 0;
                      v54 = glpMakeMutableValue((uint64_t)v11, PrimitiveType, 1, v49, v50, v51, v52, v53, v279 - ((v25[v39] >> 2) & 1));
                      v55 = glpTypedValueHashCache(v284, PrimitiveType, v54, (uint64_t)v54);
                      v56 = *(unsigned int ***)v16;
                      v295.n128_u64[0] = (unint64_t)"-1";
                      v295.n128_u64[1] = 0xEDA00000002;
                      v296 = 0xFFFFFFFFLL;
                      CopyInAssignFragment = glpMakeCopyInAssignFragment((uint64_t)v11, &v295, (uint64_t *)v293, v278, (uint64_t)v277, (uint64_t)v56, (uint64_t *)&v286, &v290, v55, &v292, Extra[2], Extra[3], (uint64_t)Extra, &v291);
                      v58 = glpPrimitiveTypeGetScalarType(*(unsigned int *)&v283[4 * v39]);
                      v59 = glpGetPrimitiveType(v58);
                      glpASTNodeSetSaType(*(uint64_t *)&v293[0], (uint64_t)v59);
                      glpASTNodeSetSaFlags(*(uint64_t *)&v293[0], Extra[6] & 0x1F);
                      glpOffsetNodeSetPreSwizzlePrimitiveType(v286.n128_i64[0], (int)v280);
                      glpASTNodeSetSaType(v292, (uint64_t)v59);
                      glpASTNodeSetSaFlags(v292, Extra[6] & 0x1F);
                      v60 = v291;
                      v61 = glpPrimitiveTypeGetPrimitiveType(*Extra);
                      glpOffsetNodeSetPreSwizzlePrimitiveType(v60, v61);
                      glpASTNodeSetSaType(v290, (uint64_t)PrimitiveType);
                      v62 = (uint64_t)v59;
                      v11 = v285;
                      glpASTNodeSetSaType(CopyInAssignFragment, v62);
                      glpASTNodeSetSaFlags(CopyInAssignFragment, Extra[6] & 0x1F);
                      v63 = v286.n128_u64[0];
                      glpMakeOffsetObject((uint64_t)v285);
                      v65 = glpOffsetNodeSetExtra(v63, v64);
                      if ((_DWORD)v276)
                        v65 = glpOffsetNodeSetOffsetExpr(v286.n128_i64[0], 0);
                      v73 = v286.n128_u64[0];
                      Swizzle_1 = glpMakeSwizzle_1(v65, v66, v67, v68, v69, v70, v71, v72, v45 + ((v25[v39] >> 1) & 2u));
                      glpOffsetNodeSetSwizzle(v73, Swizzle_1);
                      v75 = v291;
                      glpMakeOffsetObject((uint64_t)v285);
                      v77 = glpOffsetNodeSetExtra(v75, v76);
                      v78 = v291;
                      v86 = glpMakeSwizzle_1(v77, v79, v80, v81, v82, v83, v84, v85, *(_DWORD *)(v16 + 8 * v46 + 20));
                      glpOffsetNodeSetSwizzle(v78, v86);
                      glpBlockNodeAddStatement(v285, *(uint64_t *)&v294[0], CopyInAssignFragment);
                      ++v45;
                    }
                    while ((_DWORD)v282 != v45);
                    LODWORD(v281) = (_DWORD)v281 + v45;
                    Size = v272;
                    v43 = v274;
                  }
                }
                else
                {
                  v43 = v39 + 1;
                }
                v39 = v43;
              }
              while (v43 != Size);
            }
            v31 = (v271 + 1);
          }
          while ((_DWORD)v31 != (_DWORD)v268);
          ((void (*)(_QWORD, _BYTE *))v11[3])(*v11, v283);
          a4 = v262;
          v14 = v266;
        }
      }
      ++v14;
    }
    while (v14 < *(unsigned int *)(a4 + 32));
  }
  v87 = *(unsigned int *)(SlotVars + 32);
  v88 = v265;
  v89 = v267;
  if ((_DWORD)v87)
  {
    v90 = 0;
    for (i = 0; i < v87; ++i)
    {
      v92 = *(_QWORD *)(*(_QWORD *)(SlotVars + 40) + v90);
      if (v92)
      {
        glpTopLevelNodeInsertDef(v11, v267, v92, 0);
        v87 = *(unsigned int *)(SlotVars + 32);
      }
      v90 += 16;
    }
  }
  glpFixInterpolateAt(v11, v267, a4, SlotVars);
  if (v265 == 1)
    v93 = 0;
  else
    v93 = generateSlotVars(v11, v260, "$out%u");
  v94 = 0;
  memset(v294, 0, sizeof(v294));
  memset(v293, 0, sizeof(v293));
  v273 = v93;
  do
  {
    v282 = (unsigned int *)glpGetPrimitiveType(5u);
    v295.n128_u64[0] = (unint64_t)"$copy_out_0";
    v295.n128_u64[1] = 0x825A57630000000BLL;
    v296 = (uint64_t)"$copy_out_1";
    v297 = 0xB37B1E010000000BLL;
    v298 = "$copy_out_2";
    v299 = 0xF3BAF9AE0000000BLL;
    v300 = "$copy_out_3";
    v301 = 0xDFDE69E90000000BLL;
    *((_QWORD *)v293 + v94) = 0;
    v268 = v94;
    v95 = &v295 + v94;
    v96 = (const char *)v95->n128_u64[0];
    v97 = v95->n128_i64[1];
    v276 = (uint64_t *)v293 + v94;
    v266 = makeCopyFunction(v11, v89, v96, v97, v276);
    if (v88 != 1 && !v268)
    {
      v98 = v270;
      if (*(_DWORD *)(v270 + 32))
      {
        v99 = 0;
        do
        {
          v100 = *(_QWORD *)(v98 + 40);
          v101 = *(unsigned int ****)(v100 + 32 * v99);
          if (v101)
          {
            v102 = v100 + 32 * v99;
            v104 = *(_QWORD *)(v102 + 8);
            v103 = *(_QWORD *)(v102 + 16);
            SlotVars = v104;
            v274 = v103;
            v105 = **v101;
            v106 = glpABIGetTypeSize(0, (uint64_t)v105, 0);
            v107 = glpTypeSizeGetSize(v106);
            LODWORD(v277) = 0;
            if (!glpTypeGetKind(v105))
            {
              v108 = glpPrimitiveTypeGetPrimitiveType((uint64_t)v105);
              LODWORD(v277) = glpPrimitiveTypeGetCategory(v108) != 3;
            }
            v109 = v107;
            v110 = (_DWORD *)((uint64_t (*)(_QWORD, uint64_t, const char *))v11[1])(*v11, 4 * v107, "Array of vec4 types for Copy Out (why not stack alloc'd?)");
            v111 = (_BYTE *)((uint64_t (*)(_QWORD, _QWORD, const char *))v11[1])(*v11, v107, "Array of flags for Copy Out (why not stack alloc'd?)");
            v281 = v110;
            v283 = v111;
            glpTypeGetAppleVec4Types(v105, v110, 1, 0, 0, v111, 0, 0, 0);
            if (*((_DWORD *)v101 + 2))
            {
              v269 = v99;
              v112 = v283;
              if (v107)
              {
                v113 = 0;
                LODWORD(v279) = 0;
                v271 = v107;
                do
                {
                  if (BitSetGetEquals((uint64_t)(*v101)[15], v113))
                  {
                    v114 = glpPrimitiveTypeGetScalarCount(v281[v113]);
                    v115 = (v112[v113] >> 1) & 2;
                    LODWORD(v280) = v114;
                    v116 = v114 + v115;
                    v117 = v113 + 1;
                    if (v113 + 1 < v109 && (v112[v117] & 4) != 0)
                      v116 += glpPrimitiveTypeGetScalarCount(v281[v117]);
                    v118 = glpPrimitiveTypeGetScalarType(v281[v113]);
                    LODWORD(v278) = glpGetVectorType(v118, v116);
                    if ((_DWORD)v280)
                    {
                      v272 = v113 + 1;
                      v119 = 0;
                      do
                      {
                        v120 = ((_DWORD)v279 + v119);
                        v121 = glpIntHashGet(v93, v101[v120 + 2]);
                        v122 = (uint64_t *)glpVariableDeclarationNodeGetExtra(v121);
                        v291 = 0;
                        v292 = 0;
                        v290 = 0;
                        v289 = 0;
                        v288 = 0;
                        v128 = glpMakeMutableValue((uint64_t)v11, v282, 1, v123, v124, v125, v126, v127, v113 - ((v112[v113] >> 2) & 1));
                        v129 = glpTypedValueHashCache(v284, v282, v128, (uint64_t)v128);
                        v130 = *v101;
                        v286.n128_u64[0] = (unint64_t)"-1";
                        v286.n128_u64[1] = 0xEDA00000002;
                        v287 = 0xFFFFFFFFLL;
                        CopyOutAssignFragment = glpMakeCopyOutAssignFragment((uint64_t)v11, &v286, &v292, v122[2], v122[3], (uint64_t)v122, &v291, &v290, SlotVars, v274, (uint64_t)v130, &v289, &v288, v129);
                        v132 = glpPrimitiveTypeGetScalarType(v281[v113]);
                        v133 = glpGetPrimitiveType(v132);
                        glpASTNodeSetSaType(v292, (uint64_t)v133);
                        glpASTNodeSetSaFlags(v292, v122[6] & 0x1F);
                        v134 = v291;
                        v135 = glpPrimitiveTypeGetPrimitiveType(*v122);
                        glpOffsetNodeSetPreSwizzlePrimitiveType(v134, v135);
                        glpASTNodeSetSaType(v290, (uint64_t)v133);
                        v136 = v290;
                        if (glpTypeGetKind(**v101) == 1)
                          v137 = (unint64_t)v112[v113] >> 3;
                        else
                          v137 = (unint64_t)(*v101)[6] & 0x1F;
                        glpASTNodeSetSaFlags(v136, v137);
                        glpOffsetNodeSetPreSwizzlePrimitiveType(v289, v278);
                        glpASTNodeSetSaType(CopyOutAssignFragment, (uint64_t)v133);
                        glpASTNodeSetSaFlags(CopyOutAssignFragment, v122[6] & 0x1F);
                        glpASTNodeSetSaType(v288, (uint64_t)v282);
                        v138 = v291;
                        glpMakeOffsetObject((uint64_t)v285);
                        v140 = glpOffsetNodeSetExtra(v138, v139);
                        v141 = v291;
                        v149 = glpMakeSwizzle_1(v140, v142, v143, v144, v145, v146, v147, v148, HIDWORD(v101[v120 + 2]));
                        glpOffsetNodeSetSwizzle(v141, v149);
                        v150 = v289;
                        glpMakeOffsetObject((uint64_t)v285);
                        v152 = glpOffsetNodeSetExtra(v150, v151);
                        if ((_DWORD)v277)
                          v152 = glpOffsetNodeSetOffsetExpr(v289, 0);
                        v160 = v289;
                        v161 = glpMakeSwizzle_1(v152, v153, v154, v155, v156, v157, v158, v159, v119 + ((v283[v113] >> 1) & 2u));
                        glpOffsetNodeSetSwizzle(v160, v161);
                        v162 = v122[6] & 0x1F;
                        if (((unint64_t)(*v101)[6] & 0x1F) != v162)
                        {
                          v286.n128_u64[0] = (unint64_t)"-1";
                          v286.n128_u64[1] = 0xEDA00000002;
                          v287 = 0xFFFFFFFFLL;
                          TypeConversionNode = glpMakeTypeConversionNode((uint64_t)v285, &v286, (uint64_t)v133, v162);
                          glpUnaryOperatorNodeSetExpr(TypeConversionNode, v290);
                          glpASTNodeSetSaType(TypeConversionNode, (uint64_t)v133);
                          SaFlags = glpASTNodeGetSaFlags(v290);
                          glpASTNodeSetSaFlags(TypeConversionNode, SaFlags & 0xFFFFFFFFFFFFFFE0 | v162);
                          glpBinaryOperatorNodeSetRhs(CopyOutAssignFragment, TypeConversionNode);
                        }
                        v11 = v285;
                        glpBlockNodeAddStatement(v285, *v276, CopyOutAssignFragment);
                        ++v119;
                        v93 = v273;
                        v112 = v283;
                      }
                      while ((_DWORD)v280 != v119);
                      LODWORD(v279) = (_DWORD)v279 + v119;
                      v109 = v271;
                      v117 = v272;
                    }
                  }
                  else
                  {
                    v117 = v113 + 1;
                  }
                  v113 = v117;
                }
                while (v117 != v109);
              }
              ((void (*)(_QWORD, _DWORD *))v11[3])(*v11, v281);
              v99 = v269;
            }
          }
          ++v99;
          v98 = v270;
        }
        while (v99 < *(unsigned int *)(v270 + 32));
      }
      v165 = *(unsigned int *)(v93 + 32);
      v88 = v265;
      if ((_DWORD)v165)
      {
        v166 = 0;
        for (j = 0; j < v165; ++j)
        {
          v168 = *(_QWORD *)(*(_QWORD *)(v93 + 40) + v166);
          if (v168)
          {
            v286.n128_u64[0] = (unint64_t)"-1";
            v286.n128_u64[1] = 0xEDA00000002;
            v287 = 0xFFFFFFFFLL;
            glpMakeWriteOutputNode((uint64_t)v11, &v286);
            v170 = v169;
            v171 = glpVariableDeclarationNodeGetExtra(v168);
            glpWriteOutputNodeSetExtra(v170, v171);
            glpBlockNodeAddStatement(v11, *v276, v170);
            glpTopLevelNodeInsertDef(v11, v267, v168, 0);
            v165 = *(unsigned int *)(v93 + 32);
          }
          v166 += 16;
        }
      }
    }
    v172 = v268;
    *((_QWORD *)v294 + v268) = v266;
    v94 = v172 + 1;
    v89 = v267;
  }
  while (v94 != 4);
  v173 = v263;
  if (v263 && v264)
  {
    v174 = (unsigned int *)glpGetPrimitiveType(5u);
    v277 = &v260;
    MEMORY[0x24BDAC7A8](v174);
    v176 = (char *)&v260 - ((v175 + 15) & 0xFFFFFFFF0);
    if (v175 >= 0x200)
      v177 = 512;
    else
      v177 = v175;
    bzero((char *)&v260 - ((v175 + 15) & 0xFFFFFFFF0), v177);
    if (*(_DWORD *)(v173 + 4))
    {
      v178 = 0;
      do
      {
        v179 = *(_QWORD *)(v173 + 8);
        v180 = v176;
        v181 = v89;
        v182 = *(uint64_t **)(v179 + 8 * v178);
        StringBuffer = glpMakeStringBuffer(v11);
        glpStringBufferAppendFormat(StringBuffer, "TFBuffer%u", v184, v185, v186, v187, v188, v189, v178);
        String = glpStringBufferGetString((uint64_t)StringBuffer);
        v192 = v191;
        v193 = glpMakeStringBuffer(v285);
        glpStringBufferAppendCString(v193, "<TFBuffer ");
        glpStringBufferAppendString(v193, String, v192);
        glpStringBufferAppendCString(v193, ">");
        v194 = glpStringBufferGetString((uint64_t)v193);
        v196 = v195;
        v295.n128_u64[0] = (unint64_t)"-1";
        v295.n128_u64[1] = 0xEDA00000002;
        v296 = 0xFFFFFFFFLL;
        CopyVarDeclFragment = glpMakeCopyVarDeclFragment((uint64_t)v285, &v295, String, v192);
        v198 = *v182;
        v89 = v181;
        v176 = v180;
        v173 = v263;
        glpMakeVariableObject((uint64_t)v285, (uint64_t)v174, v198, 0x80000000, String, v192, v194, v196, 0, 0, 0);
        v200 = v199;
        v201 = glpABIGetTypeSize(0, (uint64_t)v174, 0);
        *(_DWORD *)(v200 + 128) = glpTypeSizeGetSize(v201);
        glpASTNodeSetSaType(CopyVarDeclFragment, (uint64_t)v174);
        glpASTNodeSetSaFlags(CopyVarDeclFragment, 0x80000000);
        glpVariableDeclarationNodeSetExtra(CopyVarDeclFragment, v200);
        *(_QWORD *)&v176[8 * v178] = v200;
        v11 = v285;
        glpTopLevelNodeInsertDef(v285, v89, CopyVarDeclFragment, 0);
        ++v178;
      }
      while (v178 < *(unsigned int *)(v173 + 4));
    }
    v202 = v264;
    if (*(_DWORD *)(v264 + 4))
    {
      v203 = 0;
      v279 = v176;
      do
      {
        v204 = *(_QWORD *)(v202 + 8);
        v278 = v203;
        v205 = *(_QWORD *)(v204 + 8 * v203);
        v206 = glpABIGetTypeSize(0, **(_QWORD **)v205, 0);
        v207 = (unsigned int *)glpTypeSizeGetSize(v206);
        Kind = glpTypeGetKind(**(unsigned int ***)v205);
        LODWORD(v283) = 0;
        if (!Kind)
        {
          v209 = glpPrimitiveTypeGetPrimitiveType(**(_QWORD **)v205);
          LODWORD(v283) = glpPrimitiveTypeGetCategory(v209) != 3;
        }
        v210 = (_DWORD *)((uint64_t (*)(_QWORD, uint64_t, const char *))v11[1])(*v11, 4 * v207, "Primitive Types");
        v211 = (_BYTE *)((uint64_t (*)(_QWORD, _QWORD, const char *))v11[1])(*v11, v207, "Flags");
        glpTypeGetAppleVec4Types(**(unsigned int ***)v205, v210, 1, 0, 0, v211, 0, 0, 0);
        if (*(_DWORD *)(v205 + 12))
        {
          v212 = *(_DWORD *)(v205 + 8);
          v213 = *(unsigned int *)(v205 + 20);
          v282 = v207;
          v280 = v211;
          v281 = v210;
          do
          {
            v214 = glpPrimitiveTypeGetScalarCount(v210[v212]);
            v215 = (v211[v212] >> 2) & 1;
            v216 = v214 + 2 * v215;
            v217 = v212 + 1;
            if (v217 < v207 && (v211[v217] & 4) != 0)
            {
              ++v215;
              v216 += glpPrimitiveTypeGetScalarCount(v210[v217]);
            }
            v218 = glpPrimitiveTypeGetScalarType(v210[v212]);
            VectorType = glpGetVectorType(v218, v216);
            v286.n128_u64[0] = 0;
            v220 = v285;
            v226 = glpMakeMutableValue((uint64_t)v285, v174, 1, v221, v222, v223, v224, v225, v213);
            v227 = v284;
            v228 = glpTypedValueHashCache(v284, v174, v226, (uint64_t)v226);
            v291 = 0;
            v292 = 0;
            v290 = 0;
            v289 = 0;
            v234 = glpMakeMutableValue((uint64_t)v220, v174, 1, v229, v230, v231, v232, v233, v212);
            v235 = glpTypedValueHashCache(v227, v174, v234, (uint64_t)v234);
            v236 = *(_QWORD *)&v279[8 * *(unsigned int *)(v205 + 16)];
            v237 = *(uint64_t **)v205;
            v295.n128_u64[0] = (unint64_t)"-1";
            v295.n128_u64[1] = 0xEDA00000002;
            v296 = 0xFFFFFFFFLL;
            StoreFragment = glpMakeStoreFragment(v220, &v295, VectorType, (uint64_t *)&v286, v228, &v292, *(_QWORD *)(v236 + 16), *(_QWORD *)(v236 + 24), v236, &v291, v237[2], v237[3], (uint64_t)v237, &v290, &v289, v235);
            glpASTNodeSetSaType(v286.n128_i64[0], (uint64_t)v174);
            glpASTNodeSetSaType(v292, (uint64_t)v174);
            v239 = v291;
            v240 = glpGetPrimitiveType(VectorType);
            glpASTNodeSetSaType(v239, (uint64_t)v240);
            glpASTNodeSetSaFlags(v291, *(_QWORD *)(*(_QWORD *)v205 + 48));
            v241 = v290;
            glpMakeOffsetObject((uint64_t)v220);
            glpOffsetNodeSetExtra(v241, v242);
            if ((_DWORD)v283)
              glpOffsetNodeSetOffsetExpr(v290, 0);
            glpASTNodeSetSaType(v289, (uint64_t)v174);
            v243 = glpGetPrimitiveType(0);
            glpASTNodeSetSaType(StoreFragment, (uint64_t)v243);
            glpBlockNodeAddStatement(v285, *((_QWORD *)v293 + *(unsigned int *)(v205 + 24)), StoreFragment);
            v244 = glpPrimitiveTypeGetScalarCount(VectorType);
            v213 = v213 + glpPrimitiveTypeGetBytesPerComponent(VectorType) * v244;
            v212 = v217 + v215;
            LODWORD(v207) = (_DWORD)v282;
            v210 = v281;
            v211 = v280;
          }
          while ((v217 + v215 - *(_DWORD *)(v205 + 8)) < *(_DWORD *)(v205 + 12));
        }
        v203 = v278 + 1;
        v202 = v264;
        v11 = v285;
      }
      while (v278 + 1 < (unint64_t)*(unsigned int *)(v264 + 4));
    }
    v88 = v265;
    v89 = v267;
  }
  DefCount = glpTopLevelNodeGetDefCount(v89);
  Def = glpTopLevelNodeGetDef(v89, DefCount - 1);
  glpFunctionDefinitionNodeGetPrototype(Def);
  Body = glpFunctionDefinitionNodeGetBody(Def);
  StatementCount = glpBlockNodeGetStatementCount(Body);
  while (StatementCount)
  {
    if (glpBlockNodeGetStatement(Body, --StatementCount))
    {
      Statement = glpBlockNodeGetStatement(Body, StatementCount);
      if (Statement)
      {
        Expr = Statement;
        while (glpIsCommaExprNode(Expr))
        {
          ExprCount = glpCommaExprNodeGetExprCount(Expr);
          Expr = glpCommaExprNodeGetExpr(Expr, ExprCount - 1);
          if (!Expr)
            goto LABEL_109;
        }
        if (glpIsReturnStatementNode(Expr))
          glpBlockNodeSetStatement(Body, StatementCount, 0);
      }
      break;
    }
  }
LABEL_109:
  v295.n128_u64[0] = (unint64_t)"-1";
  v295.n128_u64[1] = 0xEDA00000002;
  v296 = 0xFFFFFFFFLL;
  glpMakeRawCallNode((uint64_t)v11, &v295, *(_QWORD *)(CopyFunction + 24), *(_QWORD *)(CopyFunction + 32), CopyFunction);
  v253 = v252;
  v254 = glpGetPrimitiveType(0);
  glpASTNodeSetSaType(v253, (uint64_t)v254);
  result = glpBlockNodeInsertStatement(v11, Body, v253, 0);
  if (v88 != 3)
  {
    v256 = *(_QWORD *)&v294[0];
    copyOutBeforeReturnsIn(v11, *(uint64_t *)&v294[0], Def);
    v295.n128_u64[0] = (unint64_t)"-1";
    v295.n128_u64[1] = 0xEDA00000002;
    v296 = 0xFFFFFFFFLL;
    glpMakeRawCallNode((uint64_t)v11, &v295, *(_QWORD *)(v256 + 24), *(_QWORD *)(v256 + 32), v256);
    v258 = v257;
    v259 = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(v258, (uint64_t)v259);
    return glpBlockNodeAddStatement(v11, Body, v258);
  }
  return result;
}

uint64_t generateSlotVars(_QWORD *a1, uint64_t a2, char *a3)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t *StringBuffer;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t String;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t CopyVarDeclFragment;
  uint64_t v24;
  char *PrimitiveType;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  double v31;
  uint64_t v33;
  uint64_t IntHash;
  uint64_t v37;
  unsigned int v38;
  __n128 v39;
  uint64_t v40;

  IntHash = glpMakeIntHash(a1);
  v4 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = 0;
    v33 = a2;
    do
    {
      v7 = *(_QWORD *)(a2 + 40);
      v8 = *(_QWORD *)(v7 + v5);
      if ((unint64_t)(v8 + 1) >= 2)
      {
        v9 = *(_DWORD *)(v7 + v5 + 8);
        v38 = v9;
        StringBuffer = glpMakeStringBuffer(a1);
        glpStringBufferAppendFormat(StringBuffer, a3, v11, v12, v13, v14, v15, v16, v9);
        String = glpStringBufferGetString((uint64_t)StringBuffer);
        v19 = v18;
        v20 = glpMakeStringBuffer(a1);
        glpStringBufferAppendCString(v20, "<Compiler Temporary ");
        glpStringBufferAppendString(v20, String, v19);
        glpStringBufferAppendCString(v20, ">");
        v37 = glpStringBufferGetString((uint64_t)v20);
        v22 = v21;
        v39.n128_u64[0] = (unint64_t)"-1";
        v39.n128_u64[1] = 0xEDA00000002;
        v40 = 0xFFFFFFFFLL;
        CopyVarDeclFragment = glpMakeCopyVarDeclFragment((uint64_t)a1, &v39, String, v19);
        v24 = *(_QWORD *)(v8 + 24);
        PrimitiveType = glpGetPrimitiveType(*(_DWORD *)(v8 + 4));
        v26 = *(_QWORD *)(v8 + 8) | 0x80000000;
        glpMakeVariableObject((uint64_t)a1, (uint64_t)PrimitiveType, v24, v26, String, v19, v37, v22, 0, 0, 0);
        v28 = v27;
        v29 = glpABIGetTypeSize(0, (uint64_t)PrimitiveType, 0);
        *(_DWORD *)(v28 + 128) = glpTypeSizeGetSize(v29);
        glpASTNodeSetSaType(CopyVarDeclFragment, (uint64_t)PrimitiveType);
        glpASTNodeSetSaFlags(CopyVarDeclFragment, v26);
        v30 = v28;
        a2 = v33;
        glpVariableDeclarationNodeSetExtra(CopyVarDeclFragment, v30);
        glpIntHashPut(IntHash, v38, CopyVarDeclFragment, v31);
        v4 = *(unsigned int *)(v33 + 32);
      }
      ++v6;
      v5 += 16;
    }
    while (v6 < v4);
  }
  return IntHash;
}

uint64_t makeCopyFunction(_QWORD *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t *a5)
{
  char *PrimitiveType;
  uint64_t FunctionType;
  uint64_t v12;
  uint64_t Extra;
  unsigned int v14;
  uint64_t Def;
  uint64_t v16;
  char *Name;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t CopyFunctionDefinitionFragment;
  __n128 v25;
  uint64_t v26;

  PrimitiveType = glpGetPrimitiveType(0);
  FunctionType = glpMakeFunctionType(a1, (uint64_t)PrimitiveType, 0, 0, 0, 0);
  if (!glpTopLevelNodeGetDefCount(a2))
    goto LABEL_9;
  v12 = 0;
  Extra = 0;
  v14 = 0;
  do
  {
    Def = glpTopLevelNodeGetDef(a2, v14);
    if (Def)
    {
      v16 = Def;
      if (glpIsFunctionPrototypeNode(Def))
      {
        Name = (char *)glpFunctionPrototypeNodeGetName(v16);
        if (glpStringsEqual(a3, a4, Name, v18))
        {
          Extra = glpFunctionPrototypeNodeGetExtra(v16);
          glpTopLevelNodeSetDef(a2, v14, 0);
          v12 = v16;
        }
      }
    }
    ++v14;
  }
  while (v14 < glpTopLevelNodeGetDefCount(a2));
  if (!v12)
  {
LABEL_9:
    v19 = glpAggregateTypeMangleName(FunctionType, (uint64_t)a3, a4, a1);
    glpMakeFunctionObject((uint64_t)a1, FunctionType, 139264, (uint64_t)a3, a4, v19, v20);
    Extra = v21;
    v25.n128_u64[0] = (unint64_t)"-1";
    v25.n128_u64[1] = 0xEDA00000002;
    v26 = 0xFFFFFFFFLL;
    glpMakeFunctionPrototypeNode((uint64_t)a1, &v25, (uint64_t)a3, a4);
    v12 = v22;
    glpASTNodeSetSaType(v22, FunctionType);
    glpFunctionPrototypeNodeSetExtra(v12, Extra);
    glpFunctionPrototypeNodeSetReturnOutParam(v12, 0);
  }
  v25.n128_u64[0] = (unint64_t)"-1";
  v25.n128_u64[1] = 0xEDA00000002;
  v26 = 0xFFFFFFFFLL;
  CopyFunctionDefinitionFragment = glpMakeCopyFunctionDefinitionFragment((uint64_t)a1, &v25, v12, a5);
  glpTopLevelNodeInsertDef(a1, a2, CopyFunctionDefinitionFragment, 0);
  return Extra;
}

uint64_t glpMakeSwizzle_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  return (8 * a9) | 1u;
}

uint64_t copyOutBeforeReturnsIn(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t MainReturnFragment;
  uint64_t v6;
  char *PrimitiveType;
  unsigned int v8;
  uint64_t Child;
  uint64_t v10;
  __n128 v12;
  uint64_t v13;
  uint64_t v14;

  MainReturnFragment = a3;
  if (a3)
  {
    if (glpIsReturnStatementNode(a3))
    {
      v14 = 0;
      v12.n128_u64[0] = (unint64_t)"-1";
      v12.n128_u64[1] = 0xEDA00000002;
      v13 = 0xFFFFFFFFLL;
      MainReturnFragment = glpMakeMainReturnFragment(a1, &v12, &v14, *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32), a2);
      v6 = v14;
      PrimitiveType = glpGetPrimitiveType(0);
      glpASTNodeSetSaType(v6, (uint64_t)PrimitiveType);
    }
    else if (glpASTNodeGetChildCount(MainReturnFragment))
    {
      v8 = 0;
      do
      {
        Child = glpASTNodeGetChild(MainReturnFragment, v8);
        v10 = copyOutBeforeReturnsIn(a1, a2, Child);
        glpASTNodeSetChild(MainReturnFragment, v8++, v10);
      }
      while (v8 < glpASTNodeGetChildCount(MainReturnFragment));
    }
  }
  return MainReturnFragment;
}

uint64_t glpIsLegalStageCombination(uint64_t a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6;
  uint64_t **InfoLog;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  BOOL v13;
  char v14;
  char v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;

  v6 = *(_DWORD *)(a1 + 296);
  if (!a2 && a5 && !v6)
  {
    InfoLog = (uint64_t **)glpLinkerGetInfoLog(a1);
    v17 = "-1";
    v18 = 0xEDA00000002;
    v19 = 0xFFFFFFFFLL;
    v12 = "Can't have a geometry shader without a vertex shader";
LABEL_27:
    glpLogMessage(InfoLog, 0, (uint64_t)&v17, v12, v8, v9, v10, v11, v16);
    return 0;
  }
  if (!a2 && a4 && !v6)
  {
    InfoLog = (uint64_t **)glpLinkerGetInfoLog(a1);
    v17 = "-1";
    v18 = 0xEDA00000002;
    v19 = 0xFFFFFFFFLL;
    v12 = "Can't have a tessellation evaluation shader without a vertex shader";
    goto LABEL_27;
  }
  if (a3)
    v13 = v6 == 0;
  else
    v13 = 0;
  v14 = !v13;
  if (!a2 && (v14 & 1) == 0)
  {
    InfoLog = (uint64_t **)glpLinkerGetInfoLog(a1);
    v17 = "-1";
    v18 = 0xEDA00000002;
    v19 = 0xFFFFFFFFLL;
    v12 = "Can't have a tessellation control shader without a vertex shader";
    goto LABEL_27;
  }
  if (a4)
    v14 = 1;
  if ((v14 & 1) == 0)
  {
    InfoLog = (uint64_t **)glpLinkerGetInfoLog(a1);
    v17 = "-1";
    v18 = 0xEDA00000002;
    v19 = 0xFFFFFFFFLL;
    v12 = "Can't have a tessellation control shader without a tessellation evaluation shader";
    goto LABEL_27;
  }
  if ((!a2 || !a6) && !v6 && (*(_DWORD *)(a1 + 60) - 3) <= 1)
  {
    InfoLog = (uint64_t **)glpLinkerGetInfoLog(a1);
    v17 = "-1";
    v18 = 0xEDA00000002;
    v19 = 0xFFFFFFFFLL;
    v12 = "OpenGL ES requires exactly one vertex and one fragment shader to validly link.";
    goto LABEL_27;
  }
  if (!(a6 | a2) && (*(_DWORD *)(a1 + 60) - 3) <= 1)
  {
    InfoLog = (uint64_t **)glpLinkerGetInfoLog(a1);
    v17 = "-1";
    v18 = 0xEDA00000002;
    v19 = 0xFFFFFFFFLL;
    v12 = "Must have at least one shader stage in a program";
    goto LABEL_27;
  }
  return 1;
}

uint64_t glpMergeUniforms(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t *v14;
  double v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  char *v22;
  int v23;
  int v24;
  int v25;
  const char *v27;
  uint64_t v28;
  uint64_t v29;

  if (*(_DWORD *)(a3 + 32))
  {
    v6 = 0;
    v7 = 0;
    v8 = 1;
    while (1)
    {
      v9 = *(_QWORD *)(a3 + 40);
      v10 = *(_QWORD *)(v9 + v6);
      if (v10)
      {
        v11 = v9 + v6;
        v12 = *(const char **)(v11 + 8);
        v13 = *(_QWORD *)(v11 + 16);
        v14 = (uint64_t *)glpStringHashGet(a2, v12, v13);
        if (v14)
        {
          v16 = v14;
          if (!glpTypesEqual(*(unsigned int **)v10, *v14))
          {
            v25 = *(_DWORD *)(v10 + 40);
            v27 = "-1";
            v28 = 0xEDA00000002;
            v29 = 0xFFFFFFFFLL;
            glpLogMessage(a1, 0, (uint64_t)&v27, "Uniform type mismatch '%.*s'", v17, v18, v19, v20, v25);
            goto LABEL_14;
          }
          v21 = *(char **)(v10 + 72);
          if (v21)
          {
            v22 = (char *)v16[9];
            if (v22)
            {
              if (glpCompareValues(v21, *(unsigned int **)v10, v22))
              {
                v23 = *(_DWORD *)(v10 + 40);
                v27 = "-1";
                v28 = 0xEDA00000002;
                v29 = 0xFFFFFFFFLL;
                glpLogMessage(a1, 0, (uint64_t)&v27, "Uniform initializer mismatch '%.*s'", v17, v18, v19, v20, v23);
LABEL_14:
                v8 = 0;
                goto LABEL_15;
              }
            }
          }
          if (((*((_DWORD *)v16 + 12) ^ *(_DWORD *)(v10 + 48)) & 0x1FLL) != 0)
          {
            v24 = *(_DWORD *)(v10 + 40);
            v27 = "-1";
            v28 = 0xEDA00000002;
            v29 = 0xFFFFFFFFLL;
            glpLogMessage(a1, 0, (uint64_t)&v27, "Uniform precision mismatch '%.*s'", v17, v18, v19, v20, v24);
            goto LABEL_14;
          }
        }
        glpStringHashPut(a2, v12, v13, v10, v15);
      }
LABEL_15:
      ++v7;
      v6 += 32;
      if (v7 >= *(unsigned int *)(a3 + 32))
        return v8;
    }
  }
  return 1;
}

uint64_t glpMergeInterfaceBlocks(uint64_t **a1, unsigned int a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  double v17;
  uint64_t ElementType;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD v26[3];

  if (!*(_DWORD *)(a4 + 32))
    return 1;
  v8 = 0;
  v9 = 0;
  v10 = 1;
  do
  {
    v11 = *(_QWORD *)(a4 + 40);
    v12 = *(_QWORD *)(v11 + v8);
    if (v12)
    {
      v13 = v11 + v8;
      v15 = *(const char **)(v13 + 8);
      v14 = *(_QWORD *)(v13 + 16);
      v16 = glpStringHashGet(a3, v15, v14);
      if (!v16
        || ((*(_QWORD *)(**(_QWORD **)(v16 + 72) + 48) ^ *(_QWORD *)(**(_QWORD **)(v12 + 72) + 48)) & 0x160000000) != 0)
      {
        goto LABEL_9;
      }
      ElementType = *(_QWORD *)(v16 + 64);
      if (a5)
        ElementType = glpArrayTypeGetElementType(*(_QWORD *)(v16 + 64));
      if (glpTypesEqual(*(unsigned int **)(v12 + 64), ElementType))
      {
LABEL_9:
        glpStringHashPut(a3, v15, v14, v12, v17);
      }
      else
      {
        glpLanguageToString(a2);
        v26[0] = "-1";
        v26[1] = 0xEDA00000002;
        v26[2] = 0xFFFFFFFFLL;
        glpLogMessage(a1, 0, (uint64_t)v26, "Multiple declarations of interface block '%.*s' in %s shader do not match", v19, v20, v21, v22, v14);
        v10 = 0;
      }
    }
    ++v9;
    v8 += 32;
  }
  while (v9 < *(unsigned int *)(a4 + 32));
  return v10;
}

uint64_t glpMakeVertexInputBindings(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v9;
  _QWORD *Allocator;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t *v22;
  unsigned int v23;
  int Size;
  _DWORD *v25;
  _QWORD *v26;
  double v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t **InfoLog;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  _QWORD *v48;
  int v49;
  uint64_t v50;
  _QWORD *v51;
  _QWORD *v52;
  double v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  _DWORD *v57;
  uint64_t v58;
  uint64_t v59;
  const char *v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t *v63;
  uint64_t *v64;
  uint64_t **v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned int v70;
  unsigned int v71;
  uint64_t v72;
  _DWORD *v73;
  _QWORD *v74;
  double v75;
  uint64_t v76;
  int v77;
  int v78;
  uint64_t **v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unsigned int v85;
  unsigned int v86;
  uint64_t v87;
  _QWORD *v88;
  uint64_t v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  _QWORD *v95;
  int v96;
  uint64_t v97;
  _QWORD *v98;
  _QWORD *v99;
  double v100;
  int v101;
  int v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t *v105;
  uint64_t v106;
  const char *v107;
  uint64_t v108;
  uint64_t *v109;
  uint64_t *v110;
  unsigned int v111;
  uint64_t *v112;
  unsigned int v113;
  unsigned int v114;
  uint64_t v115;
  _DWORD *v116;
  char *v117;
  _QWORD *v118;
  double v119;
  unsigned int v120;
  uint64_t v121;
  char *v122;
  char v123;
  uint64_t *v124;
  int AttribForSize;
  uint64_t v126;
  int v127;
  char *v128;
  int v129;
  unsigned int v130;
  uint64_t v131;
  unsigned int v132;
  unsigned int v133;
  uint64_t v134;
  _QWORD *v135;
  uint64_t v136;
  uint64_t v137;
  _QWORD *v138;
  uint64_t v139;
  _QWORD *v140;
  uint64_t v141;
  _QWORD *v142;
  int v143;
  uint64_t v144;
  _QWORD *v145;
  uint64_t v146;
  _QWORD *v147;
  double v148;
  int v149;
  unint64_t v150;
  uint64_t v151;
  uint64_t *v152;
  uint64_t v153;
  const char *v154;
  uint64_t v155;
  uint64_t *v156;
  const char *v157;
  uint64_t *v158;
  uint64_t *v159;
  unsigned int v160;
  uint64_t *v161;
  unsigned int v162;
  unsigned int v163;
  uint64_t v164;
  _DWORD *v165;
  char *v166;
  _QWORD *v167;
  double v168;
  unsigned int v169;
  uint64_t v170;
  char *v171;
  char v172;
  uint64_t v173;
  unsigned int v174;
  int v175;
  unsigned int v176;
  uint64_t v177;
  unsigned int v178;
  unsigned int v179;
  uint64_t v180;
  _QWORD *v181;
  uint64_t *v182;
  _QWORD *v183;
  double v184;
  uint64_t v185;
  uint64_t result;
  uint64_t v187;
  uint64_t **v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  int v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t *v196;
  uint64_t *v197;
  uint64_t *v198;
  int v199;
  uint64_t v200;
  uint64_t *v201;
  uint64_t *v202;
  int v203[2];
  int v204[2];
  const char *v205;
  int v206;
  unsigned int v207;
  uint64_t *v208;
  _DWORD *v209;
  char *v210;
  int v211;
  uint64_t v212;
  const char *v213;
  uint64_t v214;
  uint64_t *v215;
  char *__s2;
  char *__s2a;
  char *__s2b;
  char *__s2c;
  uint64_t v220;
  int v221;
  char *v222;
  _BYTE *v223;
  _BYTE *v224;
  uint64_t v225;
  int v226[2];
  uint64_t *v227;
  uint64_t v228;
  unsigned int v229;
  const char *v230;
  uint64_t v231;
  uint64_t v232;

  v9 = a1;
  Allocator = (_QWORD *)glpLinkerGetAllocator(a1);
  v201 = a3;
  *a3 = glpMakeStringHash(Allocator);
  v11 = (_QWORD *)glpLinkerGetAllocator(v9);
  *a4 = glpMakeStringHash(v11);
  v12 = (_QWORD *)glpLinkerGetAllocator(v9);
  *a5 = glpMakeIntHash(v12);
  LODWORD(v13) = *(_DWORD *)(a2 + 32);
  v227 = a5;
  v228 = v9;
  v202 = a4;
  v194 = a2;
  if ((_DWORD)v13)
  {
    v14 = 0;
    v229 = 0;
    v207 = 1;
    while (1)
    {
      v15 = *(_QWORD *)(a2 + 40);
      v16 = *(uint64_t **)(v15 + 32 * v14);
      if (v16)
      {
        v17 = v15 + 32 * v14;
        v18 = *(const char **)(v17 + 8);
        v19 = *(_QWORD *)(v17 + 16);
        v20 = (uint64_t *)v16[1];
        if (v20)
        {
          v21 = glpLayoutObjectFind(v20, 26);
          if (!(_DWORD)v19)
            goto LABEL_12;
        }
        else
        {
          v21 = 0;
          if (!(_DWORD)v19)
            goto LABEL_12;
        }
        if (*v18 != 36 || v19 >= 9 && !strncmp("$ib$", v18, 4uLL) && !strncmp("$gl_", v18 + 5, 4uLL))
        {
LABEL_12:
          if (v21)
          {
            v22 = (uint64_t *)v16[1];
            v212 = v19;
            __s2 = (char *)v18;
            v208 = v21;
            if (v22)
              v197 = glpLayoutObjectFind(v22, 79);
            else
              v197 = 0;
            *(_QWORD *)v203 = v14;
            v23 = glpABIGetTypeSize(0, *v16, 0);
            Size = glpTypeSizeGetSize(v23);
            v25 = (_DWORD *)glpLinkerPoolAlloc(v9);
            v223 = (_BYTE *)glpLinkerPoolAlloc(v9);
            glpTypeGetAppleVec4Types((unsigned int *)*v16, v25, 1, 0, 0, v223, 0, 0, 0);
            v26 = (_QWORD *)glpLinkerPoolAlloc(v9);
            *v26 = v16;
            v26[1] = 0;
            glpStringHashPut(*v202, __s2, v19, (uint64_t)v26, v27);
            if (Size)
            {
              v28 = 0;
              v29 = *((_DWORD *)v208 + 4) - 1;
              do
              {
                v30 = (v223[v28] >> 2) & 1;
                if (!v30)
                  ++v29;
                if (glpIntHashGet(*a5, v29 | (v30 << 16)))
                {
                  InfoLog = (uint64_t **)glpLinkerGetInfoLog(v9);
                  v230 = "-1";
                  v231 = 0xEDA00000002;
                  v232 = 0xFFFFFFFFLL;
                  glpLogMessage(InfoLog, 0, (uint64_t)&v230, "Active attribute aliasing. Slot %d unavailable for '%.*s' from layout location request.", v32, v33, v34, v35, v29);
                  v207 = 0;
                }
                else
                {
                  v36 = glpLinkerPoolAlloc(v9);
                  *(_OWORD *)v36 = 0u;
                  *(_OWORD *)(v36 + 16) = 0u;
                  glpIntHashPut(*a5, v29 | (v30 << 16), v36, 0.0);
                  if (v229 <= v29)
                    v37 = v29;
                  else
                    v37 = v229;
                  v229 = v37;
                  if (BitSetGetEquals(v16[15], v28)
                    && glpPrimitiveTypeGetScalarCount(v25[v28]))
                  {
                    v38 = 0;
                    do
                    {
                      v39 = *((unsigned int *)v26 + 2);
                      v40 = &v26[v39];
                      *((_DWORD *)v40 + 4) = v29 | (v30 << 16);
                      *((_DWORD *)v40 + 5) = v38;
                      *((_DWORD *)v26 + 2) = v39 + 1;
                      *(_DWORD *)v36 |= 1 << v38++;
                    }
                    while (v38 < glpPrimitiveTypeGetScalarCount(v25[v28]));
                  }
                  *(_QWORD *)(v36 + 8) = v16[6] & 0x7F00000001FLL | ((unint64_t)v223[v28] >> 3);
                  *(_DWORD *)(v36 + 4) = v25[v28];
                  v41 = (uint64_t *)v16[1];
                  if (v41 && glpLayoutObjectFind(v41, 33))
                  {
                    v9 = v228;
                    *(_QWORD *)(v36 + 24) = offsetLayout(v228, (_QWORD **)v16[1], v30);
                    a5 = v227;
                  }
                  else
                  {
                    v9 = v228;
                    v42 = glpLinkerGetAllocator(v228);
                    *(_QWORD *)(v36 + 24) = glpMakeLayoutObject(v42);
                    v43 = glpLinkerGetAllocator(v228);
                    v44 = *(_QWORD **)(v36 + 24);
                    v230 = "-1";
                    v231 = 0xEDA00000002;
                    v232 = 0xFFFFFFFFLL;
                    glpLayoutObjectAppendInteger(v43, 0, (uint64_t)&v230, 0, 0, v44, 33, 0);
                    v45 = glpLinkerGetAllocator(v228);
                    v46 = *(_QWORD **)(v36 + 24);
                    v230 = "-1";
                    v231 = 0xEDA00000002;
                    v232 = 0xFFFFFFFFLL;
                    glpLayoutObjectAppendInteger(v45, 0, (uint64_t)&v230, 0, 0, v46, 34, 28);
                    v47 = glpLinkerGetAllocator(v228);
                    v48 = *(_QWORD **)(v36 + 24);
                    if (v29 >= 15)
                      v49 = 15;
                    else
                      v49 = v29;
                    v230 = "-1";
                    v231 = 0xEDA00000002;
                    v232 = 0xFFFFFFFFLL;
                    glpLayoutObjectAppendInteger(v47, 0, (uint64_t)&v230, 0, 0, v48, 35, v49 + 16);
                    v50 = glpLinkerGetAllocator(v228);
                    v51 = *(_QWORD **)(v36 + 24);
                    v230 = "-1";
                    v231 = 0xEDA00000002;
                    a5 = v227;
                    v232 = 0xFFFFFFFFLL;
                    glpLayoutObjectAppendInteger(v50, 0, (uint64_t)&v230, 0, 0, v51, 37, v30);
                  }
                }
                ++v28;
              }
              while (v28 != Size);
            }
            if (!v197)
              *(_DWORD *)(v9 + 256) += *((_DWORD *)v26 + 2);
            v52 = (_QWORD *)glpLinkerPoolAlloc(v9);
            *v52 = 0;
            v52[1] = 0;
            *(_DWORD *)v52 = *((_DWORD *)v208 + 4);
            v52[1] = *v16;
            glpStringHashPut(*v201, __s2, v212, (uint64_t)v52, v53);
            a2 = v194;
            v14 = *(_QWORD *)v203;
          }
        }
      }
      ++v14;
      v13 = *(unsigned int *)(a2 + 32);
      if (v14 >= v13)
        goto LABEL_43;
    }
  }
  v229 = 0;
  v207 = 1;
LABEL_43:
  v54 = *(_QWORD *)(v9 + 80);
  if (!*(_DWORD *)(v54 + 32))
    goto LABEL_78;
  v55 = 0;
  v195 = *(_QWORD *)(v9 + 80);
  do
  {
    v56 = *(_QWORD *)(v54 + 40);
    v57 = *(_DWORD **)(v56 + 32 * v55);
    if (!v57)
      goto LABEL_76;
    v58 = v56 + 32 * v55;
    v60 = *(const char **)(v58 + 8);
    v59 = *(_QWORD *)(v58 + 16);
    v61 = glpStringHashGet(a2, v60, v59);
    if (!v61)
    {
      v65 = (uint64_t **)glpLinkerGetInfoLog(v9);
      v230 = "-1";
      v231 = 0xEDA00000002;
      v232 = 0xFFFFFFFFLL;
      glpLogMessage(v65, 1u, (uint64_t)&v230, "Could not find vertex shader attribute '%.*s' to match BindAttributeLocation request.", v66, v67, v68, v69, v59);
LABEL_52:
      a2 = v194;
      goto LABEL_76;
    }
    v62 = (uint64_t *)v61;
    v63 = *(uint64_t **)(v61 + 8);
    if (!v63)
    {
      v209 = v57;
      v213 = v60;
      __s2a = (char *)v59;
      *(_QWORD *)v204 = v55;
LABEL_54:
      v198 = 0;
      goto LABEL_55;
    }
    if (glpLayoutObjectFind(v63, 26))
      goto LABEL_52;
    v64 = (uint64_t *)v62[1];
    *(_QWORD *)v204 = v55;
    v213 = v60;
    __s2a = (char *)v59;
    v209 = v57;
    if (!v64)
      goto LABEL_54;
    v198 = glpLayoutObjectFind(v64, 79);
LABEL_55:
    v70 = glpABIGetTypeSize(0, *v62, 0);
    v71 = glpTypeSizeGetSize(v70);
    v72 = v71;
    v73 = (_DWORD *)glpLinkerPoolAlloc(v9);
    v224 = (_BYTE *)glpLinkerPoolAlloc(v9);
    glpTypeGetAppleVec4Types((unsigned int *)*v62, v73, 1, 0, 0, v224, 0, 0, 0);
    v74 = (_QWORD *)glpLinkerPoolAlloc(v9);
    *v74 = v62;
    v74[1] = 0;
    glpStringHashPut(*v202, v213, (uint64_t)__s2a, (uint64_t)v74, v75);
    if (v71)
    {
      v76 = 0;
      v77 = *v209 - 1;
      v220 = v71;
      do
      {
        v78 = (v224[v76] >> 2) & 1;
        if (!v78)
          ++v77;
        if (glpIntHashGet(*a5, v77 | (v78 << 16)))
        {
          v79 = (uint64_t **)glpLinkerGetInfoLog(v228);
          v230 = "-1";
          v231 = 0xEDA00000002;
          v232 = 0xFFFFFFFFLL;
          glpLogMessage(v79, 0, (uint64_t)&v230, "Active attribute aliasing. Slot %d unavailable for '%.*s' from BindAttributeLocation request.", v80, v81, v82, v83, v77);
          v207 = 0;
        }
        else
        {
          v84 = glpLinkerPoolAlloc(v228);
          *(_OWORD *)v84 = 0u;
          *(_OWORD *)(v84 + 16) = 0u;
          glpIntHashPut(*a5, v77 | (v78 << 16), v84, 0.0);
          if (v229 <= v77)
            v85 = v77;
          else
            v85 = v229;
          v229 = v85;
          if (BitSetGetEquals(v62[15], v76)
            && glpPrimitiveTypeGetScalarCount(v73[v76]))
          {
            v86 = 0;
            do
            {
              v87 = *((unsigned int *)v74 + 2);
              v88 = &v74[v87];
              *((_DWORD *)v88 + 4) = v77 | (v78 << 16);
              *((_DWORD *)v88 + 5) = v86;
              *((_DWORD *)v74 + 2) = v87 + 1;
              *(_DWORD *)v84 |= 1 << v86++;
            }
            while (v86 < glpPrimitiveTypeGetScalarCount(v73[v76]));
          }
          *(_QWORD *)(v84 + 8) = v62[6] & 0x7F00000001FLL | ((unint64_t)v224[v76] >> 3);
          *(_DWORD *)(v84 + 4) = v73[v76];
          v89 = glpLinkerGetAllocator(v228);
          *(_QWORD *)(v84 + 24) = glpMakeLayoutObject(v89);
          v90 = glpLinkerGetAllocator(v228);
          v91 = *(_QWORD **)(v84 + 24);
          v230 = "-1";
          v231 = 0xEDA00000002;
          v232 = 0xFFFFFFFFLL;
          glpLayoutObjectAppendInteger(v90, 0, (uint64_t)&v230, 0, 0, v91, 33, 0);
          v92 = glpLinkerGetAllocator(v228);
          v93 = *(_QWORD **)(v84 + 24);
          v230 = "-1";
          v231 = 0xEDA00000002;
          v232 = 0xFFFFFFFFLL;
          glpLayoutObjectAppendInteger(v92, 0, (uint64_t)&v230, 0, 0, v93, 34, 28);
          v94 = glpLinkerGetAllocator(v228);
          v95 = *(_QWORD **)(v84 + 24);
          if (v77 >= 15)
            v96 = 15;
          else
            v96 = v77;
          v230 = "-1";
          v231 = 0xEDA00000002;
          v232 = 0xFFFFFFFFLL;
          glpLayoutObjectAppendInteger(v94, 0, (uint64_t)&v230, 0, 0, v95, 35, v96 + 16);
          v97 = glpLinkerGetAllocator(v228);
          v98 = *(_QWORD **)(v84 + 24);
          v230 = "-1";
          v231 = 0xEDA00000002;
          v232 = 0xFFFFFFFFLL;
          glpLayoutObjectAppendInteger(v97, 0, (uint64_t)&v230, 0, 0, v98, 37, v78);
          a5 = v227;
          v72 = v220;
        }
        ++v76;
      }
      while (v76 != v72);
    }
    v9 = v228;
    if (!v198)
      *(_DWORD *)(v228 + 256) += *((_DWORD *)v74 + 2);
    v99 = (_QWORD *)glpLinkerPoolAlloc(v228);
    *v99 = 0;
    v99[1] = 0;
    *(_DWORD *)v99 = *v209;
    v99[1] = *v62;
    glpStringHashPut(*v201, v213, (uint64_t)__s2a, (uint64_t)v99, v100);
    a2 = v194;
    v54 = v195;
    v55 = *(_QWORD *)v204;
LABEL_76:
    ++v55;
  }
  while (v55 < *(unsigned int *)(v54 + 32));
  LODWORD(v13) = *(_DWORD *)(a2 + 32);
LABEL_78:
  v101 = 8;
  v102 = v13;
  while (2)
  {
    if (!v102)
      goto LABEL_129;
    v103 = 0;
    while (2)
    {
      v104 = *(_QWORD *)(a2 + 40);
      v105 = *(uint64_t **)(v104 + 32 * v103);
      if (!v105)
        goto LABEL_127;
      v106 = v104 + 32 * v103;
      v107 = *(const char **)(v106 + 8);
      v225 = *(_QWORD *)(v106 + 16);
      v108 = glpStringHashGet(*(_QWORD *)(v9 + 80), v107, v225);
      v109 = (uint64_t *)v105[1];
      if (!v109)
      {
        v110 = 0;
        if (!v108)
          goto LABEL_86;
        goto LABEL_127;
      }
      v110 = glpLayoutObjectFind(v109, 26);
      if (v108)
        goto LABEL_127;
LABEL_86:
      if ((v225 < 3
         || strncmp("gl_", v107, 3uLL)
         && (v225 < 9 || strncmp("$ib$", v107, 4uLL) || strncmp("$gl_", v107 + 5, 4uLL)))
        && (!(_DWORD)v225
         || *v107 != 36
         || v225 >= 9 && !strncmp("$ib$", v107, 4uLL) && !strncmp("$gl_", v107 + 5, 4uLL))
        && !v110)
      {
        v111 = glpABIGetTypeSize(0, *v105, 0);
        if (glpTypeSizeGetSize(v111) == v101)
        {
          v112 = (uint64_t *)v105[1];
          v205 = v107;
          if (v112)
            v196 = glpLayoutObjectFind(v112, 79);
          else
            v196 = 0;
          v113 = glpABIGetTypeSize(0, *v105, 0);
          v114 = glpTypeSizeGetSize(v113);
          v115 = v114;
          v116 = (_DWORD *)glpLinkerPoolAlloc(v9);
          v117 = (char *)glpLinkerPoolAlloc(v9);
          glpTypeGetAppleVec4Types((unsigned int *)*v105, v116, 1, 0, 0, v117, 0, 0, 0);
          v118 = (_QWORD *)glpLinkerPoolAlloc(v9);
          *v118 = v105;
          v118[1] = 0;
          glpStringHashPut(*v202, v205, v225, (uint64_t)v118, v119);
          if (v114)
          {
            v120 = 0;
            v121 = v114;
            v122 = v117;
            do
            {
              v123 = *v122++;
              if ((v123 & 4) == 0)
                ++v120;
              --v121;
            }
            while (v121);
            v124 = v227;
            AttribForSize = allocateAttribForSize(*v227, v120);
            v199 = AttribForSize;
            if ((_DWORD)v115)
            {
              v214 = v115;
              __s2b = (char *)v105;
              v193 = v101;
              v126 = 0;
              v127 = AttribForSize - 1;
              v128 = v117;
              v9 = v228;
              v210 = v117;
              do
              {
                v129 = (v128[v126] >> 2) & 1;
                if (!v129)
                  ++v127;
                v221 = (v128[v126] >> 2) & 1;
                v130 = v127 | (v129 << 16);
                v131 = glpLinkerPoolAlloc(v9);
                *(_OWORD *)v131 = 0u;
                *(_OWORD *)(v131 + 16) = 0u;
                glpIntHashPut(*v124, v130, v131, 0.0);
                if (v229 <= v127)
                  v132 = v127;
                else
                  v132 = v229;
                v229 = v132;
                if (BitSetGetEquals(*((_QWORD *)__s2b + 15), v126)
                  && glpPrimitiveTypeGetScalarCount(v116[v126]))
                {
                  v133 = 0;
                  do
                  {
                    v134 = *((unsigned int *)v118 + 2);
                    v135 = &v118[v134];
                    *((_DWORD *)v135 + 4) = v130;
                    *((_DWORD *)v135 + 5) = v133;
                    *((_DWORD *)v118 + 2) = v134 + 1;
                    *(_DWORD *)v131 |= 1 << v133++;
                  }
                  while (v133 < glpPrimitiveTypeGetScalarCount(v116[v126]));
                }
                v128 = v210;
                *(_QWORD *)(v131 + 8) = *((_QWORD *)__s2b + 6) & 0x7F00000001FLL | ((unint64_t)v210[v126] >> 3);
                *(_DWORD *)(v131 + 4) = v116[v126];
                v9 = v228;
                v136 = glpLinkerGetAllocator(v228);
                *(_QWORD *)(v131 + 24) = glpMakeLayoutObject(v136);
                v137 = glpLinkerGetAllocator(v228);
                v138 = *(_QWORD **)(v131 + 24);
                v230 = "-1";
                v231 = 0xEDA00000002;
                v232 = 0xFFFFFFFFLL;
                glpLayoutObjectAppendInteger(v137, 0, (uint64_t)&v230, 0, 0, v138, 33, 0);
                v139 = glpLinkerGetAllocator(v228);
                v140 = *(_QWORD **)(v131 + 24);
                v230 = "-1";
                v231 = 0xEDA00000002;
                v232 = 0xFFFFFFFFLL;
                glpLayoutObjectAppendInteger(v139, 0, (uint64_t)&v230, 0, 0, v140, 34, 28);
                v141 = glpLinkerGetAllocator(v228);
                v142 = *(_QWORD **)(v131 + 24);
                if (v127 >= 15)
                  v143 = 15;
                else
                  v143 = v127;
                v230 = "-1";
                v231 = 0xEDA00000002;
                v232 = 0xFFFFFFFFLL;
                glpLayoutObjectAppendInteger(v141, 0, (uint64_t)&v230, 0, 0, v142, 35, v143 + 16);
                v144 = glpLinkerGetAllocator(v228);
                v145 = *(_QWORD **)(v131 + 24);
                v230 = "-1";
                v231 = 0xEDA00000002;
                v232 = 0xFFFFFFFFLL;
                glpLayoutObjectAppendInteger(v144, 0, (uint64_t)&v230, 0, 0, v145, 37, v221);
                ++v126;
                v124 = v227;
              }
              while (v126 != v214);
              a2 = v194;
              v101 = v193;
              v146 = v225;
              v105 = (uint64_t *)__s2b;
              if (!v196)
LABEL_125:
                *(_DWORD *)(v9 + 256) += *((_DWORD *)v118 + 2);
LABEL_126:
              v147 = (_QWORD *)glpLinkerPoolAlloc(v9);
              *v147 = 0;
              v147[1] = 0;
              *(_DWORD *)v147 = v199;
              v147[1] = *v105;
              glpStringHashPut(*v201, v205, v146, (uint64_t)v147, v148);
              goto LABEL_127;
            }
          }
          else
          {
            v199 = allocateAttribForSize(*v227, 0);
          }
          v9 = v228;
          v146 = v225;
          if (!v196)
            goto LABEL_125;
          goto LABEL_126;
        }
      }
LABEL_127:
      ++v103;
      v13 = *(unsigned int *)(a2 + 32);
      if (v103 < v13)
        continue;
      break;
    }
    v102 = *(_DWORD *)(a2 + 32);
LABEL_129:
    if (--v101)
      continue;
    break;
  }
  v149 = 8;
  do
  {
    if ((_DWORD)v13)
    {
      v150 = 0;
      do
      {
        v151 = *(_QWORD *)(a2 + 40);
        v152 = *(uint64_t **)(v151 + 32 * v150);
        if (v152)
        {
          v153 = v151 + 32 * v150;
          v154 = *(const char **)(v153 + 8);
          v155 = *(_QWORD *)(v153 + 16);
          v156 = (uint64_t *)v152[1];
          if (v156)
          {
            v157 = *(const char **)(v153 + 8);
            v158 = glpLayoutObjectFind(v156, 26);
            v154 = v157;
            v159 = v158;
          }
          else
          {
            v159 = 0;
          }
          if (v155 >= 3)
          {
            __s2c = (char *)v154;
            if ((!strncmp("gl_", v154, 3uLL)
               || v155 >= 9 && !strncmp("$ib$", __s2c, 4uLL) && !strncmp("$gl_", __s2c + 5, 4uLL))
              && !v159)
            {
              v160 = glpABIGetTypeSize(0, *v152, 0);
              if (glpTypeSizeGetSize(v160) == v149)
              {
                v161 = (uint64_t *)v152[1];
                if (v161)
                  v215 = glpLayoutObjectFind(v161, 79);
                else
                  v215 = 0;
                v162 = glpABIGetTypeSize(0, *v152, 0);
                v163 = glpTypeSizeGetSize(v162);
                v164 = v9;
                v165 = (_DWORD *)glpLinkerPoolAlloc(v9);
                v166 = (char *)glpLinkerPoolAlloc(v164);
                glpTypeGetAppleVec4Types((unsigned int *)*v152, v165, 1, 0, 0, v166, 0, 0, 0);
                v167 = (_QWORD *)glpLinkerPoolAlloc(v164);
                *v167 = v152;
                v167[1] = 0;
                glpStringHashPut(*v202, __s2c, v155, (uint64_t)v167, v168);
                if (v163)
                {
                  v169 = 0;
                  v170 = v163;
                  v171 = v166;
                  do
                  {
                    v172 = *v171++;
                    if ((v172 & 4) == 0)
                      ++v169;
                    --v170;
                  }
                  while (v170);
                  v211 = allocateAttribForSize(*v227, v169);
                  v200 = v155;
                  v206 = v149;
                  v173 = 0;
                  v174 = v211 - 1;
                  v222 = v166;
                  *(_QWORD *)v226 = v163;
                  do
                  {
                    v175 = (v166[v173] >> 2) & 1;
                    if (!v175)
                      ++v174;
                    v176 = v174 | (v175 << 16);
                    v177 = glpLinkerPoolAlloc(v228);
                    *(_OWORD *)v177 = 0u;
                    *(_OWORD *)(v177 + 16) = 0u;
                    glpIntHashPut(*v227, v176, v177, 0.0);
                    if (v229 <= v174)
                      v178 = v174;
                    else
                      v178 = v229;
                    v229 = v178;
                    if (BitSetGetEquals(v152[15], v173)
                      && glpPrimitiveTypeGetScalarCount(v165[v173]))
                    {
                      v179 = 0;
                      do
                      {
                        v180 = *((unsigned int *)v167 + 2);
                        v181 = &v167[v180];
                        *((_DWORD *)v181 + 4) = v176;
                        *((_DWORD *)v181 + 5) = v179;
                        *((_DWORD *)v167 + 2) = v180 + 1;
                        *(_DWORD *)v177 |= 1 << v179++;
                      }
                      while (v179 < glpPrimitiveTypeGetScalarCount(v165[v173]));
                    }
                    v166 = v222;
                    *(_QWORD *)(v177 + 8) = v152[6] & 0x7F00000001FLL | ((unint64_t)v222[v173] >> 3);
                    *(_DWORD *)(v177 + 4) = v165[v173];
                    *(_QWORD *)(v177 + 24) = offsetLayout(v228, (_QWORD **)v152[1], v173);
                    v182 = (uint64_t *)v152[1];
                    if (v182)
                      glpLayoutObjectFind(v182, 33);
                    ++v173;
                  }
                  while (v173 != *(_QWORD *)v226);
                  a2 = v194;
                  v149 = v206;
                  v155 = v200;
                }
                else
                {
                  v211 = allocateAttribForSize(*v227, 0);
                }
                v9 = v228;
                if (!v215)
                  *(_DWORD *)(v228 + 256) += *((_DWORD *)v167 + 2);
                v183 = (_QWORD *)glpLinkerPoolAlloc(v228);
                *v183 = 0;
                v183[1] = 0;
                *(_DWORD *)v183 = v211;
                v183[1] = *v152;
                glpStringHashPut(*v201, __s2c, v155, (uint64_t)v183, v184);
              }
            }
          }
        }
        ++v150;
        v13 = *(unsigned int *)(a2 + 32);
      }
      while (v150 < v13);
    }
    --v149;
  }
  while (v149);
  v185 = *(unsigned int *)(*v202 + 32);
  result = v207;
  if ((_DWORD)v185)
  {
    v187 = *(_QWORD *)(*v202 + 40);
    do
    {
      if (*(_QWORD *)v187)
        *(_QWORD *)(**(_QWORD **)v187 + 8) = 0;
      v187 += 32;
      --v185;
    }
    while (v185);
  }
  if (v229 >= 0x10)
  {
    v188 = (uint64_t **)glpLinkerGetInfoLog(v9);
    v230 = "-1";
    v231 = 0xEDA00000002;
    v232 = 0xFFFFFFFFLL;
    glpLogMessage(v188, 0, (uint64_t)&v230, "Implementation limit of %d MAX_VERTEX_ATTRIBS (e.g., number of generic plus conventional active vec4 attributes) exceeded, shader uses up to vec4 attribute %d.", v189, v190, v191, v192, 16);
    return 0;
  }
  return result;
}

uint64_t *offsetLayout(uint64_t a1, _QWORD **a2, unsigned int a3)
{
  _QWORD *Allocator;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;

  Allocator = (_QWORD *)glpLinkerGetAllocator(a1);
  v6 = glpCopyLayoutObject(Allocator, a2);
  v7 = glpLayoutObjectFind(v6, 35);
  if (v7)
    *((_DWORD *)v7 + 4) += a3;
  v8 = glpLayoutObjectFind(v6, 43);
  if (v8)
    *((_DWORD *)v8 + 4) += a3;
  v9 = glpLayoutObjectFind(v6, 45);
  if (v9)
    *((_DWORD *)v9 + 4) += a3;
  v10 = glpLayoutObjectFind(v6, 47);
  if (v10)
    *((_DWORD *)v10 + 4) += 4 * a3;
  v11 = glpLayoutObjectFind(v6, 50);
  if (v11)
    *((_DWORD *)v11 + 4) += a3;
  v12 = glpLayoutObjectFind(v6, 52);
  if (v12)
    *((_DWORD *)v12 + 4) += a3;
  v13 = glpLayoutObjectFind(v6, 57);
  if (v13)
    *((_DWORD *)v13 + 4) += a3;
  v14 = glpLayoutObjectFind(v6, 59);
  if (v14)
    *((_DWORD *)v14 + 4) += a3;
  v15 = glpLayoutObjectFind(v6, 60);
  if (v15)
    *((_DWORD *)v15 + 4) += a3;
  v16 = glpLayoutObjectFind(v6, 61);
  if (v16)
    *((_DWORD *)v16 + 4) += a3 >> 2;
  v17 = glpLayoutObjectFind(v6, 63);
  if (v17)
    *((_DWORD *)v17 + 4) += a3 & 3;
  v18 = glpLayoutObjectFind(v6, 69);
  if (v18)
    *((_DWORD *)v18 + 4) += a3;
  v19 = glpLayoutObjectFind(v6, 72);
  if (v19)
    *((_DWORD *)v19 + 4) += a3;
  v20 = glpLayoutObjectFind(v6, 75);
  if (v20)
    *((_DWORD *)v20 + 4) += a3;
  return v6;
}

uint64_t allocateAttribForSize(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;

  if (!a2)
    return 0;
  v4 = 0;
  v5 = a2;
  do
  {
    v6 = v4;
    while (!glpIntHashGet(a1, v6))
    {
      if (++v6 >= v5)
        return v4;
    }
    v4 = (v4 + 1);
    v5 = v4 + a2;
  }
  while (v4 < v4 + a2);
  return v4;
}

uint64_t glpMakeFragmentOutputBindings(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v9;
  _QWORD *Allocator;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t *v26;
  unsigned int v27;
  uint64_t Size;
  _DWORD *v29;
  _QWORD *v30;
  _QWORD *v31;
  const char *v32;
  _QWORD *v33;
  double v34;
  uint64_t *v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t *v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  _QWORD *v44;
  _QWORD *v45;
  double v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const char *v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t *v54;
  unsigned int v55;
  char *v56;
  _DWORD *v57;
  uint64_t *v58;
  uint64_t *v59;
  _QWORD *v60;
  double v61;
  char *i;
  unsigned int v63;
  uint64_t v64;
  uint64_t **v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t **v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unsigned int v78;
  uint64_t v79;
  unsigned int v80;
  unsigned int v81;
  uint64_t v82;
  _QWORD *v83;
  uint64_t v84;
  _QWORD *v85;
  uint64_t v86;
  _QWORD *v87;
  uint64_t v88;
  _QWORD *v89;
  int v90;
  uint64_t v91;
  _QWORD *v92;
  uint64_t v93;
  double v94;
  unint64_t v95;
  unsigned int v96;
  uint64_t **InfoLog;
  int v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  double *v106;
  uint64_t v107;
  const char *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t *v112;
  uint64_t *v113;
  uint64_t **v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unsigned int v119;
  unsigned int v120;
  uint64_t v121;
  _DWORD *v122;
  _QWORD *v123;
  double v124;
  uint64_t v125;
  unsigned int v126;
  uint64_t v127;
  uint64_t **v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t **v134;
  int v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unsigned int v141;
  uint64_t v142;
  unsigned int v143;
  unsigned int v144;
  uint64_t v145;
  _QWORD *v146;
  uint64_t v147;
  _QWORD *v148;
  uint64_t v149;
  _QWORD *v150;
  uint64_t v151;
  _QWORD *v152;
  int v153;
  uint64_t v154;
  _QWORD *v155;
  int v156;
  _QWORD *v157;
  double v158;
  uint64_t v159;
  int v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t *v165;
  uint64_t *v166;
  uint64_t *v167;
  int v168;
  int v169;
  int v170;
  uint64_t *v171;
  unsigned int v172;
  unsigned int v173;
  uint64_t v174;
  _DWORD *v175;
  _QWORD *v176;
  double v177;
  unsigned int v178;
  uint64_t v179;
  unsigned int v180;
  unsigned int v181;
  uint64_t v182;
  uint64_t **v183;
  int v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  unsigned int v190;
  uint64_t v191;
  unsigned int v192;
  uint64_t v193;
  _QWORD *v194;
  uint64_t v195;
  _QWORD *v196;
  uint64_t v197;
  _QWORD *v198;
  uint64_t v199;
  _QWORD *v200;
  uint64_t v201;
  _QWORD *v202;
  _QWORD *v203;
  double v204;
  unsigned int v205;
  uint64_t result;
  uint64_t **v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t **v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t **v219;
  unsigned int v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  char v225;
  unsigned int v226;
  uint64_t *v227;
  uint64_t *v228;
  uint64_t v229;
  uint64_t v230;
  int v231;
  uint64_t *v232;
  uint64_t *v233;
  uint64_t v234;
  const char *v235;
  uint64_t v236;
  uint64_t v237;
  _BYTE *v238;
  uint64_t *v239;
  uint64_t *v240;
  uint64_t v241;
  unsigned int v242;
  int v243[2];
  unsigned int v244;
  uint64_t v245;
  unsigned int v246;
  unsigned int v247;
  unsigned int v248;
  int v249[2];
  _BOOL4 v250;
  unsigned int v251;
  char *__s2;
  char *__s2a;
  char *__s2b;
  char *__s2c;
  unsigned int v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  int v260[2];
  uint64_t *v261;
  const char *v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  unsigned int v268;
  uint64_t v269;
  uint64_t *v270;
  const char *v271;
  uint64_t v272;
  uint64_t v273;

  v9 = a1;
  Allocator = (_QWORD *)glpLinkerGetAllocator(a1);
  v239 = a3;
  *a3 = glpMakeStringHash(Allocator);
  v11 = (_QWORD *)glpLinkerGetAllocator(v9);
  v240 = a4;
  *a4 = glpMakeStringHash(v11);
  v12 = (_QWORD *)glpLinkerGetAllocator(v9);
  v270 = a5;
  *a5 = glpMakeIntHash(v12);
  v13 = *(unsigned int *)(a2 + 32);
  v268 = 1;
  v264 = v9;
  *(_QWORD *)v249 = a2;
  if (!(_DWORD)v13)
  {
    v16 = 0;
    LODWORD(v95) = 0;
    v96 = 0;
    v251 = 0;
    v15 = 0;
    goto LABEL_92;
  }
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0x80000000;
  while (1)
  {
    v18 = *(_QWORD *)(a2 + 40);
    v269 = *(_QWORD *)(v18 + 32 * v14);
    if (!v269)
      goto LABEL_40;
    v19 = v18 + 32 * v14;
    v20 = *(_QWORD *)(v19 + 16);
    if (v20 < 3)
      goto LABEL_40;
    v245 = v14;
    v21 = *(const char **)(v19 + 8);
    if ((!strncmp("gl_", v21, 3uLL)
       || v20 >= 9 && !strncmp("$ib$", v21, 4uLL) && !strncmp("$gl_", v21 + 5, 4uLL))
      && (*v21 != 36 || v20 >= 9 && !strncmp("$ib$", v21, 4uLL) && !strncmp("$gl_", v21 + 5, 4uLL)))
    {
      break;
    }
LABEL_39:
    v14 = v245;
LABEL_40:
    if (++v14 >= v13)
    {
      v268 = 1;
      if (!v13)
        goto LABEL_91;
      goto LABEL_42;
    }
  }
  v22 = *(uint64_t **)(v269 + 8);
  if (v22)
  {
    v23 = glpLayoutObjectFind(v22, 79);
    v22 = *(uint64_t **)(v269 + 8);
  }
  else
  {
    v23 = 0;
  }
  v24 = glpLayoutObjectFind(v22, 72);
  v25 = glpLayoutObjectFind(*(uint64_t **)(v269 + 8), 77);
  v26 = v25;
  if (!v16 || !v25)
  {
    v232 = v23;
    if (v25)
      v16 = v269;
    v265 = v16;
    v27 = glpABIGetTypeSize(0, *(_QWORD *)v269, 0);
    Size = glpTypeSizeGetSize(v27);
    v29 = (_DWORD *)glpLinkerPoolAlloc(v264);
    __s2 = (char *)glpLinkerPoolAlloc(v264);
    glpTypeGetAppleVec4Types(*(unsigned int **)v269, v29, 1, 0, 0, __s2, 0, 0, 0);
    *(_QWORD *)v260 = Size;
    v30 = (_QWORD *)v269;
    v31 = (_QWORD *)glpLinkerPoolAlloc(v264);
    v32 = v21;
    v33 = v31;
    *v31 = v269;
    v31[1] = 0;
    v235 = v32;
    v241 = v20;
    glpStringHashPut(*v240, v32, v20, (uint64_t)v31, v34);
    v256 = v17;
    v35 = v26;
    if (v24)
      v256 = *((_DWORD *)v24 + 4);
    if ((_DWORD)Size)
    {
      v36 = 0;
      v250 = v35 == 0;
      do
      {
        if (BitSetGetEquals(v30[15], v36))
        {
          v37 = v17;
          v38 = glpLinkerPoolAlloc(v264);
          *(_OWORD *)v38 = 0u;
          *(_OWORD *)(v38 + 16) = 0u;
          glpIntHashPut(*v270, v256 + v36, v38, 0.0);
          if (v15 <= v256 + v36)
            v39 = v256 + v36;
          else
            v39 = v15;
          v40 = v35;
          if (v35)
            v15 = v39;
          else
            v15 = v15;
          v41 = v15;
          if (glpPrimitiveTypeGetScalarCount(v29[v36]))
          {
            v42 = 0;
            do
            {
              v43 = *((unsigned int *)v33 + 2);
              v44 = &v33[v43];
              *((_DWORD *)v44 + 4) = v256 + v36;
              *((_DWORD *)v44 + 5) = v42;
              *((_DWORD *)v33 + 2) = v43 + 1;
              *(_DWORD *)v38 |= 1 << v42++;
            }
            while (v42 < glpPrimitiveTypeGetScalarCount(v29[v36]));
          }
          v30 = (_QWORD *)v269;
          *(_QWORD *)(v38 + 8) = *(_QWORD *)(v269 + 48) & 0x7F00000001FLL | ((unint64_t)__s2[v36] >> 3);
          *(_DWORD *)(v38 + 4) = v29[v36];
          *(_QWORD *)(v38 + 24) = offsetLayout(v264, *(_QWORD ***)(v269 + 8), v36);
          v17 = v37 + v250;
          v15 = v41;
          v35 = v40;
        }
        ++v36;
      }
      while (v36 != *(_QWORD *)v260);
    }
    v9 = v264;
    if (!v232)
      *(_DWORD *)(v264 + 292) += *((_DWORD *)v33 + 2);
    v45 = (_QWORD *)glpLinkerPoolAlloc(v264);
    *v45 = 0;
    v45[1] = 0;
    *(_DWORD *)v45 = v256;
    v45[1] = *v30;
    glpStringHashPut(*v239, v235, v241, (uint64_t)v45, v46);
    a2 = *(_QWORD *)v249;
    v13 = *(unsigned int *)(*(_QWORD *)v249 + 32);
    v16 = v265;
    goto LABEL_39;
  }
  v9 = v264;
  InfoLog = (uint64_t **)glpLinkerGetInfoLog(v264);
  v98 = *(_DWORD *)(v269 + 40);
  v271 = "-1";
  v272 = 0xEDA00000002;
  v273 = 0xFFFFFFFFLL;
  glpLogMessage(InfoLog, 0, (uint64_t)&v271, "Cannot mix builtin fragment outputs '%.*s' and '%.*s'.", v99, v100, v101, v102, v98);
  v268 = 0;
  if (*(_DWORD *)(a2 + 32))
  {
LABEL_42:
    v47 = 0;
    v251 = 0;
    v246 = 0;
    v266 = v16;
    while (1)
    {
      v48 = *(_QWORD *)(a2 + 40);
      v49 = *(_QWORD *)(v48 + 32 * v47);
      if (v49)
      {
        v50 = v48 + 32 * v47;
        v51 = *(const char **)(v50 + 8);
        v52 = *(_QWORD *)(v50 + 16);
        v53 = *(uint64_t **)(v49 + 8);
        v261 = v53 ? glpLayoutObjectFind(v53, 26) : 0;
        if ((v52 < 3
           || strncmp("gl_", v51, 3uLL)
           && (v52 < 9 || strncmp("$ib$", v51, 4uLL) || strncmp("$gl_", v51 + 5, 4uLL)))
          && (!(_DWORD)v52
           || *v51 != 36
           || v52 >= 9 && !strncmp("$ib$", v51, 4uLL) && !strncmp("$gl_", v51 + 5, 4uLL))
          && v261)
        {
          v54 = *(uint64_t **)(v49 + 8);
          if (v54)
            v227 = glpLayoutObjectFind(v54, 79);
          else
            v227 = 0;
          v55 = glpABIGetTypeSize(0, *(_QWORD *)v49, 0);
          v56 = (char *)glpTypeSizeGetSize(v55);
          v57 = (_DWORD *)glpLinkerPoolAlloc(v9);
          __s2a = v56;
          v236 = glpLinkerPoolAlloc(v9);
          glpTypeGetAppleVec4Types(*(unsigned int **)v49, v57, 1, 0, 0, (_BYTE *)v236, 0, 0, 0);
          v58 = *(uint64_t **)(v49 + 8);
          v257 = v15;
          if (v58 && (v59 = glpLayoutObjectFind(v58, 27)) != 0)
            v242 = *((_DWORD *)v59 + 4);
          else
            v242 = 0;
          v60 = (_QWORD *)glpLinkerPoolAlloc(v9);
          *v60 = v49;
          v60[1] = 0;
          glpStringHashPut(*v240, v51, v52, (uint64_t)v60, v61);
          v229 = v52;
          if ((_DWORD)v56)
          {
            for (i = 0; i != __s2a; ++i)
            {
              v63 = (*((_DWORD *)v261 + 4) + (_DWORD)i) | (v242 << 16);
              v64 = glpIntHashGet(*v270, v63);
              if (v16)
              {
                v65 = (uint64_t **)glpLinkerGetInfoLog(v9);
                v66 = *(_DWORD *)(v49 + 40);
                v271 = "-1";
                v272 = 0xEDA00000002;
                v273 = 0xFFFFFFFFLL;
                glpLogMessage(v65, 0, (uint64_t)&v271, "Cannot mix builtin and user defined fragment outputs '%.*s' and '%.*s'.", v67, v68, v69, v70, v66);
              }
              else
              {
                if (!v64)
                {
                  if (BitSetGetEquals(*(_QWORD *)(v49 + 120), i))
                  {
                    v77 = glpLinkerPoolAlloc(v9);
                    *(_OWORD *)v77 = 0u;
                    *(_OWORD *)(v77 + 16) = 0u;
                    glpIntHashPut(*v270, v63, v77, 0.0);
                    v78 = *((_DWORD *)v261 + 4) + (_DWORD)i;
                    if (v257 <= v78)
                      v79 = v78;
                    else
                      v79 = v257;
                    v257 = v79;
                    v80 = v251;
                    if (v251 <= v242)
                      v80 = v242;
                    v251 = v80;
                    if (glpPrimitiveTypeGetScalarCount(v57[(_QWORD)i]))
                    {
                      v81 = 0;
                      do
                      {
                        v82 = *((unsigned int *)v60 + 2);
                        v83 = &v60[v82];
                        *((_DWORD *)v83 + 4) = v63;
                        *((_DWORD *)v83 + 5) = v81;
                        *((_DWORD *)v60 + 2) = v82 + 1;
                        *(_DWORD *)v77 |= 1 << v81++;
                      }
                      while (v81 < glpPrimitiveTypeGetScalarCount(v57[(_QWORD)i]));
                    }
                    *(_QWORD *)(v77 + 8) = *(_QWORD *)(v49 + 48) & 0x7F00000001FLL | ((unint64_t)i[v236] >> 3);
                    *(_DWORD *)(v77 + 4) = v57[(_QWORD)i];
                    *(_QWORD *)(v77 + 24) = addPPDrawBuffersToLayout(v264, *(_QWORD ***)(v77 + 24));
                    v84 = glpLinkerGetAllocator(v264);
                    v85 = *(_QWORD **)(v77 + 24);
                    v271 = "-1";
                    v272 = 0xEDA00000002;
                    v273 = 0xFFFFFFFFLL;
                    glpLayoutObjectAppendInteger(v84, 0, (uint64_t)&v271, 0, 0, v85, 33, 3);
                    v86 = glpLinkerGetAllocator(v264);
                    v87 = *(_QWORD **)(v77 + 24);
                    v271 = "-1";
                    v272 = 0xEDA00000002;
                    v273 = 0xFFFFFFFFLL;
                    glpLayoutObjectAppendInteger(v86, 0, (uint64_t)&v271, 0, 0, v87, 68, 4);
                    v88 = glpLinkerGetAllocator(v264);
                    v89 = *(_QWORD **)(v77 + 24);
                    v90 = *((_DWORD *)v261 + 4) + (_DWORD)i;
                    v271 = "-1";
                    v272 = 0xEDA00000002;
                    v273 = 0xFFFFFFFFLL;
                    glpLayoutObjectAppendInteger(v88, 0, (uint64_t)&v271, 0, 0, v89, 72, v90);
                    v91 = glpLinkerGetAllocator(v264);
                    v92 = *(_QWORD **)(v77 + 24);
                    v9 = v264;
                    v271 = "-1";
                    v272 = 0xEDA00000002;
                    v273 = 0xFFFFFFFFLL;
                    glpLayoutObjectAppendInteger(v91, 0, (uint64_t)&v271, 0, 0, v92, 73, v242);
                    v16 = v266;
                  }
                  continue;
                }
                v71 = (uint64_t **)glpLinkerGetInfoLog(v9);
                v72 = *((_DWORD *)v261 + 4) + (_DWORD)i;
                v271 = "-1";
                v272 = 0xEDA00000002;
                v273 = 0xFFFFFFFFLL;
                glpLogMessage(v71, 0, (uint64_t)&v271, "Active output aliasing. Slot %d unavailable for '%.*s' from layout location request.", v73, v74, v75, v76, v72);
              }
              v268 = 0;
            }
          }
          if (!v227)
            *(_DWORD *)(v9 + 292) += *((_DWORD *)v60 + 2);
          v93 = glpLinkerPoolAlloc(v9);
          *(_QWORD *)v93 = 0;
          *(_QWORD *)(v93 + 8) = 0;
          *(_DWORD *)v93 = *((_DWORD *)v261 + 4);
          *(_DWORD *)(v93 + 4) = v242;
          *(_QWORD *)(v93 + 8) = *(_QWORD *)v49;
          glpStringHashPut(*v239, v51, v229, v93, v94);
          ++v246;
          v15 = v257;
        }
      }
      a2 = *(_QWORD *)v249;
      ++v47;
      v95 = *(unsigned int *)(*(_QWORD *)v249 + 32);
      if (v47 >= v95)
      {
        v96 = v246;
        goto LABEL_92;
      }
    }
  }
LABEL_91:
  LODWORD(v95) = 0;
  v96 = 0;
  v251 = 0;
LABEL_92:
  v267 = v16;
  v103 = *(_QWORD *)(v9 + 88);
  if (!*(_DWORD *)(v103 + 32))
    goto LABEL_128;
  v104 = 0;
  v230 = *(_QWORD *)(v9 + 88);
  while (2)
  {
    v105 = *(_QWORD *)(v103 + 40);
    v106 = *(double **)(v105 + 32 * v104);
    if (v106)
    {
      v107 = v105 + 32 * v104;
      v108 = *(const char **)(v107 + 8);
      v109 = *(_QWORD *)(v107 + 16);
      v110 = glpStringHashGet(a2, v108, v109);
      if (v110)
      {
        v111 = v110;
        v112 = *(uint64_t **)(v110 + 8);
        if (!v112)
        {
          v258 = v15;
          v262 = v108;
          *(_QWORD *)v243 = v104;
          v247 = v96;
          goto LABEL_102;
        }
        if (!glpLayoutObjectFind(v112, 26))
        {
          v113 = *(uint64_t **)(v111 + 8);
          v258 = v15;
          v262 = v108;
          v247 = v96;
          *(_QWORD *)v243 = v104;
          if (v113)
          {
            v233 = glpLayoutObjectFind(v113, 79);
            goto LABEL_103;
          }
LABEL_102:
          v233 = 0;
LABEL_103:
          v119 = glpABIGetTypeSize(0, *(_QWORD *)v111, 0);
          v120 = glpTypeSizeGetSize(v119);
          v121 = v120;
          v122 = (_DWORD *)glpLinkerPoolAlloc(v264);
          __s2b = (char *)glpLinkerPoolAlloc(v264);
          glpTypeGetAppleVec4Types(*(unsigned int **)v111, v122, 1, 0, 0, __s2b, 0, 0, 0);
          v123 = (_QWORD *)glpLinkerPoolAlloc(v264);
          *v123 = v111;
          v123[1] = 0;
          glpStringHashPut(*v240, v262, v109, (uint64_t)v123, v124);
          v237 = v109;
          if (v120)
          {
            v125 = 0;
            v9 = v264;
            while (1)
            {
              v126 = (*(_DWORD *)v106 + v125) | (*((_DWORD *)v106 + 1) << 16);
              v127 = glpIntHashGet(*v270, v126);
              if (v267)
              {
                v128 = (uint64_t **)glpLinkerGetInfoLog(v9);
                v129 = *(_DWORD *)(v111 + 40);
                v271 = "-1";
                v272 = 0xEDA00000002;
                v273 = 0xFFFFFFFFLL;
                glpLogMessage(v128, 0, (uint64_t)&v271, "Cannot mix builtin and user defined fragment outputs '%.*s' and '%.*s'.", v130, v131, v132, v133, v129);
              }
              else
              {
                if (!v127)
                {
                  if (BitSetGetEquals(*(_QWORD *)(v111 + 120), v125))
                  {
                    v140 = glpLinkerPoolAlloc(v9);
                    *(_OWORD *)v140 = 0u;
                    *(_OWORD *)(v140 + 16) = 0u;
                    glpIntHashPut(*v270, v126, v140, 0.0);
                    v141 = *(_DWORD *)v106 + v125;
                    if (v258 <= v141)
                      v142 = v141;
                    else
                      v142 = v258;
                    v258 = v142;
                    v143 = v251;
                    if (v251 <= *((_DWORD *)v106 + 1))
                      v143 = *((_DWORD *)v106 + 1);
                    v251 = v143;
                    if (glpPrimitiveTypeGetScalarCount(v122[v125]))
                    {
                      v144 = 0;
                      do
                      {
                        v145 = *((unsigned int *)v123 + 2);
                        v146 = &v123[v145];
                        *((_DWORD *)v146 + 4) = v126;
                        *((_DWORD *)v146 + 5) = v144;
                        *((_DWORD *)v123 + 2) = v145 + 1;
                        *(_DWORD *)v140 |= 1 << v144++;
                      }
                      while (v144 < glpPrimitiveTypeGetScalarCount(v122[v125]));
                    }
                    *(_QWORD *)(v140 + 8) = *(_QWORD *)(v111 + 48) & 0x7F00000001FLL | ((unint64_t)__s2b[v125] >> 3);
                    *(_DWORD *)(v140 + 4) = v122[v125];
                    *(_QWORD *)(v140 + 24) = addPPDrawBuffersToLayout(v264, *(_QWORD ***)(v140 + 24));
                    v147 = glpLinkerGetAllocator(v264);
                    v148 = *(_QWORD **)(v140 + 24);
                    v271 = "-1";
                    v272 = 0xEDA00000002;
                    v273 = 0xFFFFFFFFLL;
                    glpLayoutObjectAppendInteger(v147, 0, (uint64_t)&v271, 0, 0, v148, 33, 3);
                    v149 = glpLinkerGetAllocator(v264);
                    v150 = *(_QWORD **)(v140 + 24);
                    v271 = "-1";
                    v272 = 0xEDA00000002;
                    v273 = 0xFFFFFFFFLL;
                    glpLayoutObjectAppendInteger(v149, 0, (uint64_t)&v271, 0, 0, v150, 68, 4);
                    v151 = glpLinkerGetAllocator(v264);
                    v152 = *(_QWORD **)(v140 + 24);
                    v153 = *(_DWORD *)v106 + v125;
                    v271 = "-1";
                    v272 = 0xEDA00000002;
                    v273 = 0xFFFFFFFFLL;
                    glpLayoutObjectAppendInteger(v151, 0, (uint64_t)&v271, 0, 0, v152, 72, v153);
                    v154 = glpLinkerGetAllocator(v264);
                    v155 = *(_QWORD **)(v140 + 24);
                    v9 = v264;
                    v156 = *((_DWORD *)v106 + 1);
                    v271 = "-1";
                    v272 = 0xEDA00000002;
                    v273 = 0xFFFFFFFFLL;
                    glpLayoutObjectAppendInteger(v154, 0, (uint64_t)&v271, 0, 0, v155, 73, v156);
                  }
                  goto LABEL_110;
                }
                v134 = (uint64_t **)glpLinkerGetInfoLog(v9);
                v135 = *(_DWORD *)v106 + v125;
                v271 = "-1";
                v272 = 0xEDA00000002;
                v273 = 0xFFFFFFFFLL;
                glpLogMessage(v134, 0, (uint64_t)&v271, "Active output aliasing. Slot %d unavailable for '%.*s' from FragDataBinding request.", v136, v137, v138, v139, v135);
              }
              v268 = 0;
LABEL_110:
              if (++v125 == v121)
                goto LABEL_123;
            }
          }
          v9 = v264;
LABEL_123:
          if (!v233)
            *(_DWORD *)(v9 + 292) += *((_DWORD *)v123 + 2);
          v157 = (_QWORD *)glpLinkerPoolAlloc(v9);
          *v157 = 0;
          v157[1] = 0;
          v158 = *v106;
          *v157 = *(_QWORD *)v106;
          v157[1] = *(_QWORD *)v111;
          glpStringHashPut(*v239, v262, v237, (uint64_t)v157, v158);
          v96 = v247 + 1;
          v15 = v258;
          a2 = *(_QWORD *)v249;
          v103 = v230;
          v104 = *(_QWORD *)v243;
        }
      }
      else
      {
        v114 = (uint64_t **)glpLinkerGetInfoLog(v9);
        v271 = "-1";
        v272 = 0xEDA00000002;
        v273 = 0xFFFFFFFFLL;
        glpLogMessage(v114, 1u, (uint64_t)&v271, "Could not find fragment shader output '%.*s' to match FragDataBinding request.", v115, v116, v117, v118, v109);
      }
    }
    if (++v104 < (unint64_t)*(unsigned int *)(v103 + 32))
      continue;
    break;
  }
  LODWORD(v95) = *(_DWORD *)(a2 + 32);
LABEL_128:
  if (!(_DWORD)v95)
  {
    result = v268;
    v205 = v251;
    goto LABEL_185;
  }
  v159 = 0;
  v160 = 0;
  while (2)
  {
    v161 = *(_QWORD *)(a2 + 40);
    v162 = *(_QWORD *)(v161 + 32 * v159);
    if (!v162)
      goto LABEL_147;
    v163 = v161 + 32 * v159;
    __s2c = *(char **)(v163 + 8);
    v263 = *(_QWORD *)(v163 + 16);
    v164 = glpStringHashGet(*(_QWORD *)(v9 + 88), __s2c, v263);
    v165 = *(uint64_t **)(v162 + 8);
    if (!v165)
    {
      v166 = 0;
LABEL_145:
      if (!v164)
        goto LABEL_134;
      goto LABEL_146;
    }
    v166 = glpLayoutObjectFind(v165, 26);
    v167 = *(uint64_t **)(v162 + 8);
    if (!v167)
      goto LABEL_145;
    if ((unint64_t)glpLayoutObjectFind(v167, 29) | v164)
    {
LABEL_146:
      v9 = v264;
      goto LABEL_147;
    }
LABEL_134:
    v168 = v263;
    v9 = v264;
    if (v263 < 3
      || strncmp("gl_", __s2c, 3uLL)
      && ((v168 = v263, v263 < 9)
       || (v169 = strncmp("$ib$", __s2c, 4uLL), v168 = v263, v169)
       || (v170 = strncmp("$gl_", __s2c + 5, 4uLL), v168 = v263, v170)))
    {
      if (!v168)
        goto LABEL_150;
      if (*__s2c == 36)
      {
        if (v263 >= 9 && !strncmp("$ib$", __s2c, 4uLL))
        {
          LOBYTE(v168) = strncmp("$gl_", __s2c + 5, 4uLL) != 0;
          goto LABEL_150;
        }
      }
      else
      {
        LOBYTE(v168) = 0;
LABEL_150:
        if ((v168 & 1) == 0 && !v166)
        {
          v171 = *(uint64_t **)(v162 + 8);
          v259 = v15;
          v248 = v96;
          v231 = v160;
          if (v171)
            v228 = glpLayoutObjectFind(v171, 79);
          else
            v228 = 0;
          v172 = glpABIGetTypeSize(0, *(_QWORD *)v162, 0);
          v173 = glpTypeSizeGetSize(v172);
          v174 = v173;
          v175 = (_DWORD *)glpLinkerPoolAlloc(v264);
          v238 = (_BYTE *)glpLinkerPoolAlloc(v264);
          glpTypeGetAppleVec4Types(*(unsigned int **)v162, v175, 1, 0, 0, v238, 0, 0, 0);
          v176 = (_QWORD *)glpLinkerPoolAlloc(v264);
          *v176 = v162;
          v176[1] = 0;
          glpStringHashPut(*v240, __s2c, v263, (uint64_t)v176, v177);
          if (v173)
          {
            v178 = 0;
            v179 = *v270;
            v180 = v173;
            v226 = v173;
            do
            {
              v181 = v178;
              while (!glpIntHashGet(v179, v178))
              {
                if (++v178 >= v180)
                {
                  v178 = v181;
                  goto LABEL_162;
                }
              }
              v178 = v181 + 1;
              v180 = v181 + 1 + v226;
            }
            while (v178 < v178 + v226);
LABEL_162:
            v244 = v178;
            v182 = 0;
            v9 = v264;
            v234 = v174;
            do
            {
              if (v267)
              {
                v183 = (uint64_t **)glpLinkerGetInfoLog(v9);
                v184 = *(_DWORD *)(v162 + 40);
                v271 = "-1";
                v272 = 0xEDA00000002;
                v273 = 0xFFFFFFFFLL;
                glpLogMessage(v183, 0, (uint64_t)&v271, "Cannot mix builtin and user defined fragment outputs '%.*s' and '%.*s'.", v185, v186, v187, v188, v184);
                v268 = 0;
              }
              else if (BitSetGetEquals(*(_QWORD *)(v162 + 120), v182))
              {
                v189 = glpLinkerPoolAlloc(v9);
                *(_OWORD *)v189 = 0u;
                *(_OWORD *)(v189 + 16) = 0u;
                v190 = v244 + v182;
                glpIntHashPut(*v270, v244 + v182, v189, 0.0);
                if (v259 <= v244 + v182)
                  v191 = v190;
                else
                  v191 = v259;
                v259 = v191;
                if (glpPrimitiveTypeGetScalarCount(v175[v182]))
                {
                  v192 = 0;
                  do
                  {
                    v193 = *((unsigned int *)v176 + 2);
                    v194 = &v176[v193];
                    *((_DWORD *)v194 + 4) = v190;
                    *((_DWORD *)v194 + 5) = v192;
                    *((_DWORD *)v176 + 2) = v193 + 1;
                    *(_DWORD *)v189 |= 1 << v192++;
                  }
                  while (v192 < glpPrimitiveTypeGetScalarCount(v175[v182]));
                }
                *(_QWORD *)(v189 + 8) = *(_QWORD *)(v162 + 48) & 0x7F00000001FLL | ((unint64_t)v238[v182] >> 3);
                *(_DWORD *)(v189 + 4) = v175[v182];
                *(_QWORD *)(v189 + 24) = addPPDrawBuffersToLayout(v264, *(_QWORD ***)(v189 + 24));
                v195 = glpLinkerGetAllocator(v264);
                v196 = *(_QWORD **)(v189 + 24);
                v271 = "-1";
                v272 = 0xEDA00000002;
                v273 = 0xFFFFFFFFLL;
                glpLayoutObjectAppendInteger(v195, 0, (uint64_t)&v271, 0, 0, v196, 33, 3);
                v197 = glpLinkerGetAllocator(v264);
                v198 = *(_QWORD **)(v189 + 24);
                v271 = "-1";
                v272 = 0xEDA00000002;
                v273 = 0xFFFFFFFFLL;
                glpLayoutObjectAppendInteger(v197, 0, (uint64_t)&v271, 0, 0, v198, 68, 4);
                v199 = glpLinkerGetAllocator(v264);
                v200 = *(_QWORD **)(v189 + 24);
                v271 = "-1";
                v272 = 0xEDA00000002;
                v273 = 0xFFFFFFFFLL;
                glpLayoutObjectAppendInteger(v199, 0, (uint64_t)&v271, 0, 0, v200, 72, v190);
                v201 = glpLinkerGetAllocator(v264);
                v202 = *(_QWORD **)(v189 + 24);
                v9 = v264;
                v271 = "-1";
                v272 = 0xEDA00000002;
                v273 = 0xFFFFFFFFLL;
                glpLayoutObjectAppendInteger(v201, 0, (uint64_t)&v271, 0, 0, v202, 73, 0);
                v174 = v234;
              }
              ++v182;
            }
            while (v182 != v174);
            a2 = *(_QWORD *)v249;
          }
          else
          {
            v244 = 0;
          }
          v15 = v259;
          if (!v228)
            *(_DWORD *)(v9 + 292) += *((_DWORD *)v176 + 2);
          v203 = (_QWORD *)glpLinkerPoolAlloc(v9);
          *v203 = 0;
          v203[1] = 0;
          *(_DWORD *)v203 = v244;
          v203[1] = *(_QWORD *)v162;
          glpStringHashPut(*v239, __s2c, v263, (uint64_t)v203, v204);
          v96 = v248 + 1;
          v160 = v231 + 1;
        }
      }
    }
LABEL_147:
    if (++v159 < (unint64_t)*(unsigned int *)(a2 + 32))
      continue;
    break;
  }
  v205 = v251;
  if (v96 < 2)
  {
    result = v268;
  }
  else
  {
    result = v268;
    if (v160 && *(_DWORD *)(**(_QWORD **)(v9 + 176) + 4) == 6)
    {
      v207 = (uint64_t **)glpLinkerGetInfoLog(v9);
      v271 = "-1";
      v272 = 0xEDA00000002;
      v273 = 0xFFFFFFFFLL;
      glpLogMessage(v207, 0, (uint64_t)&v271, "GLSL 300 requires that all fragment shader outputs have a location if there is more than one output.", v208, v209, v210, v211, v225);
      result = 0;
    }
  }
LABEL_185:
  v212 = *(unsigned int *)(*v240 + 32);
  if ((_DWORD)v212)
  {
    v213 = *(_QWORD *)(*v240 + 40);
    do
    {
      if (*(_QWORD *)v213)
        *(_QWORD *)(**(_QWORD **)v213 + 8) = 0;
      v213 += 32;
      --v212;
    }
    while (v212);
  }
  if (v205 && (_DWORD)v15)
  {
    v214 = (uint64_t **)glpLinkerGetInfoLog(v9);
    v271 = "-1";
    v272 = 0xEDA00000002;
    v273 = 0xFFFFFFFFLL;
    glpLogMessage(v214, 0, (uint64_t)&v271, "Exceeded max dual source draw buffers of %d, shader uses up to %d.", v215, v216, v217, v218, 1);
    return 0;
  }
  if (v15 >= glpBuiltInConstantValues[8 * (*(_BYTE *)(v9 + 60) == 4) + 7])
  {
    v219 = (uint64_t **)glpLinkerGetInfoLog(v9);
    v220 = glpBuiltInConstantValues[8 * (*(_BYTE *)(v9 + 60) == 4) + 7];
    v271 = "-1";
    v272 = 0xEDA00000002;
    v273 = 0xFFFFFFFFLL;
    glpLogMessage(v219, 0, (uint64_t)&v271, "Exceeded max draw buffers of %d, shader uses up to %d.", v221, v222, v223, v224, v220);
    return 0;
  }
  return result;
}

_QWORD *addPPDrawBuffersToLayout(uint64_t a1, _QWORD **a2)
{
  _QWORD *Allocator;
  _QWORD *LayoutObject;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[3];

  Allocator = (_QWORD *)glpLinkerGetAllocator(a1);
  LayoutObject = glpCopyLayoutObject(Allocator, a2);
  if (!LayoutObject)
  {
    v6 = glpLinkerGetAllocator(a1);
    LayoutObject = glpMakeLayoutObject(v6);
  }
  v7 = glpLinkerGetAllocator(a1);
  v9[0] = "-1";
  v9[1] = 0xEDA00000002;
  v9[2] = 0xFFFFFFFFLL;
  glpLayoutObjectAppendInteger(v7, 0, (uint64_t)v9, 0, 0, LayoutObject, 77, 2);
  return LayoutObject;
}

uint64_t glpMakeInterstageBindings(uint64_t StringHash, unsigned int a2, unsigned int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, uint64_t *a12, uint64_t *a13)
{
  uint64_t v13;
  uint64_t v17;
  _QWORD *Allocator;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  int v25;
  _QWORD *v26;
  const char *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _BOOL4 v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  int ElementCount;
  int PrimitiveType;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;
  double v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t **v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t **v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  _QWORD *v65;
  uint64_t v66;
  _QWORD *v67;
  uint64_t v68;
  _QWORD *v69;
  uint64_t v70;
  _QWORD *v71;
  uint64_t v72;
  _QWORD *v73;
  int v74;
  uint64_t v75;
  int v76;
  unsigned int v77;
  _QWORD *v78;
  uint64_t v79;
  char *v80;
  int v81;
  int v82;
  int v83;
  int v84;
  uint64_t *v85;
  uint64_t *v86;
  uint64_t *v87;
  uint64_t **v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  int Kind;
  unsigned int *ElementType;
  uint64_t **InfoLog;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t **v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  double v106;
  uint64_t **v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  int v114;
  uint64_t v115;
  uint64_t v116;
  int v117;
  _QWORD *v118;
  char *v119;
  int v120;
  uint64_t *v121;
  unsigned int v122;
  uint64_t *v123;
  _BYTE *v124;
  unsigned int v125;
  int v126;
  int ScalarCount;
  int v128;
  uint64_t **v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t **v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  unint64_t v139;
  unint64_t v140;
  unsigned int v141;
  const char *v142;
  uint64_t v143;
  uint64_t *v144;
  uint64_t v145;
  const char *v146;
  const char *v147;
  unsigned int *v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  uint64_t *v156;
  uint64_t *v157;
  uint64_t *v158;
  _BOOL4 v159;
  uint64_t *v160;
  uint64_t v161;
  uint64_t v162;
  int InputOutputBitsType;
  BOOL v164;
  const char *v165;
  unsigned __int8 v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  unsigned int v171;
  unsigned int Size;
  uint64_t v173;
  uint64_t v174;
  uint64_t *v175;
  double v176;
  uint64_t *v177;
  uint64_t v178;
  _QWORD *v179;
  uint64_t *v180;
  uint64_t *v181;
  unsigned int v182;
  int SlotsWithGLPType;
  double v184;
  _DWORD *v185;
  uint64_t v186;
  unsigned int v187;
  unsigned int v188;
  unsigned int v189;
  uint64_t v190;
  unsigned int v191;
  BOOL v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t *v195;
  uint64_t v196;
  uint64_t v197;
  int ScalarType;
  int v199;
  uint64_t v200;
  uint64_t v201;
  unsigned int v202;
  uint64_t v203;
  uint64_t v204;
  _QWORD *v205;
  double v206;
  unint64_t v207;
  uint64_t v208;
  uint64_t *v209;
  uint64_t v210;
  const char *v211;
  uint64_t v212;
  uint64_t *v213;
  uint64_t v214;
  unsigned int *v215;
  __int128 v216;
  __int128 v217;
  __int128 v218;
  __int128 v219;
  __int128 v220;
  __int128 v221;
  __int128 v222;
  int v223;
  uint64_t v224;
  unsigned int v225;
  unsigned int v226;
  uint64_t v227;
  uint64_t *v228;
  uint64_t *v229;
  double v230;
  uint64_t v231;
  _DWORD *v232;
  unsigned int *v233;
  uint64_t *v234;
  uint64_t *v235;
  uint64_t *v236;
  int *v237;
  int v238;
  uint64_t v239;
  uint64_t v240;
  unsigned int v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  _QWORD *v245;
  _QWORD *v246;
  uint64_t v247;
  uint64_t v248;
  _QWORD *v249;
  uint64_t v250;
  _QWORD *v251;
  uint64_t v252;
  _QWORD *v253;
  uint64_t *v254;
  _QWORD *v255;
  const char *v256;
  uint64_t v257;
  double v258;
  int v259;
  const char *v260;
  unsigned int *v261;
  __int128 v262;
  __int128 v263;
  __int128 v264;
  __int128 v265;
  __int128 v266;
  __int128 v267;
  __int128 v268;
  int v269;
  uint64_t v270;
  unsigned int v271;
  unsigned int v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t *v275;
  double v276;
  uint64_t v277;
  uint64_t v278;
  _QWORD *v279;
  uint64_t *v280;
  uint64_t *v281;
  int v282;
  _QWORD *v283;
  const char *v284;
  uint64_t v285;
  double v286;
  int v287;
  _QWORD *v288;
  double v289;
  _DWORD *v290;
  unsigned int *v291;
  uint64_t **v292;
  unsigned int v293;
  unsigned int v294;
  unsigned int v295;
  uint64_t v296;
  unsigned int v297;
  BOOL v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t *v301;
  uint64_t v302;
  uint64_t v303;
  int v304;
  int v305;
  _QWORD *v306;
  double v307;
  uint64_t **v308;
  uint64_t v309;
  unsigned int v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t *v313;
  uint64_t v314;
  uint64_t v315;
  unint64_t v316;
  uint64_t v317;
  unsigned int v318;
  double v319;
  uint64_t v320;
  uint64_t v321;
  unint64_t v322;
  uint64_t v323;
  unsigned int v324;
  double v325;
  unint64_t v326;
  size_t v327;
  uint64_t v328;
  uint64_t v329;
  unsigned int v330;
  uint64_t *v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  int v337;
  uint64_t v338;
  uint64_t v339;
  unsigned int *v340;
  __int128 v341;
  __int128 v342;
  __int128 v343;
  __int128 v344;
  __int128 v345;
  __int128 v346;
  __int128 v347;
  const char *v348;
  uint64_t v349;
  uint64_t *v350;
  uint64_t *v351;
  uint64_t v352;
  uint64_t v353;
  int v354;
  BOOL v355;
  int v356;
  uint64_t v357;
  unsigned __int8 v358;
  uint64_t **v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  int v364;
  int v365;
  char v366;
  unsigned int v367;
  uint64_t v368;
  uint64_t *v369;
  uint64_t *v370;
  uint64_t *v371;
  int v372;
  char *v373;
  uint64_t **v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  char v379;
  uint64_t v380;
  uint64_t *LayoutObject;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  _QWORD *v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  char v393;
  uint64_t **v394;
  int v395;
  double v396;
  int v397;
  _BYTE *v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t **v401;
  unsigned int v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t **v407;
  int v408;
  uint64_t v409;
  uint64_t v410;
  uint64_t v411;
  uint64_t v412;
  _QWORD *v413;
  double v414;
  unsigned int SizeInBits;
  uint64_t v416;
  unsigned int v417;
  uint64_t v418;
  unsigned int v419;
  int v420;
  uint64_t v421;
  unsigned __int8 v422;
  uint64_t **v423;
  uint64_t v424;
  uint64_t v425;
  uint64_t v426;
  uint64_t v427;
  unint64_t v428;
  char *v429;
  size_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t *v434;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t *v440;
  uint64_t v441;
  uint64_t v442;
  const char *v443;
  uint64_t *v444;
  unsigned int *v445;
  unsigned int *v446;
  _BOOL4 v447;
  uint64_t v448;
  double v449;
  uint64_t v450;
  _QWORD *v451;
  double v452;
  __int128 v453;
  __int128 v454;
  __int128 v455;
  __int128 v456;
  __int128 v457;
  __int128 v458;
  __int128 v459;
  int v460;
  uint64_t v461;
  unsigned int v462;
  uint64_t v463;
  uint64_t v464;
  uint64_t *v465;
  uint64_t *v466;
  uint64_t *v467;
  int v468;
  int v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  _QWORD *v473;
  uint64_t v474;
  uint64_t v475;
  uint64_t v476;
  uint64_t v477;
  int v478;
  uint64_t v479;
  uint64_t v480;
  _QWORD *v481;
  const char *v482;
  double v483;
  _QWORD *v484;
  double v485;
  uint64_t **v486;
  uint64_t v487;
  uint64_t v488;
  uint64_t v489;
  uint64_t v490;
  char v491;
  uint64_t **v492;
  unsigned int v493;
  uint64_t v494;
  uint64_t v495;
  uint64_t v496;
  uint64_t v497;
  uint64_t **v498;
  int v499;
  uint64_t v500;
  uint64_t v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  uint64_t v506;
  uint64_t **v507;
  uint64_t v508;
  char v510;
  char v511;
  char v512;
  _QWORD v513[2];
  uint64_t *v514;
  char *v515;
  uint64_t v516;
  uint64_t v517;
  uint64_t *v518;
  _QWORD *v519;
  uint64_t v520;
  uint64_t *v521;
  uint64_t *v522;
  uint64_t v523;
  uint64_t *v524;
  uint64_t v525;
  uint64_t *v526;
  _BYTE *v527;
  unsigned int v528;
  uint64_t v529;
  uint64_t *v530;
  uint64_t v531;
  uint64_t **v532;
  uint64_t *v533;
  unsigned int v534;
  uint64_t *v535;
  uint64_t v536;
  const char *v537;
  uint64_t v538;
  uint64_t v539;
  unsigned int *v540;
  uint64_t v541;
  __int128 v542;
  __int128 v543;
  __int128 v544;
  __int128 v545;
  __int128 v546;
  __int128 v547;
  __int128 v548;
  __int128 v549;
  __int128 v550;
  __int128 v551;
  unsigned int *v552;
  unsigned int *v553[2];

  v522 = a8;
  v13 = a7;
  v534 = a3;
  v528 = a2;
  v17 = StringHash;
  v553[1] = *(unsigned int **)MEMORY[0x24BDAC8D0];
  if (a7)
  {
    Allocator = (_QWORD *)glpLinkerGetAllocator(StringHash);
    StringHash = glpMakeStringHash(Allocator);
    *a9 = StringHash;
  }
  v526 = a11;
  if (a5)
  {
    v19 = (_QWORD *)glpLinkerGetAllocator(v17);
    StringHash = glpMakeStringHash(v19);
    *v522 = StringHash;
  }
  v521 = a10;
  if (v13)
  {
    v20 = (_QWORD *)glpLinkerGetAllocator(v17);
    StringHash = glpMakeStringHash(v20);
    *v526 = StringHash;
  }
  v535 = a13;
  if (a5)
  {
    v21 = (_QWORD *)glpLinkerGetAllocator(v17);
    StringHash = glpMakeStringHash(v21);
    *v521 = StringHash;
  }
  v530 = a12;
  if (v13)
  {
    v22 = (_QWORD *)glpLinkerGetAllocator(v17);
    StringHash = glpMakeIntHash(v22);
    *v535 = StringHash;
  }
  if (a5)
  {
    v23 = (_QWORD *)glpLinkerGetAllocator(v17);
    StringHash = glpMakeIntHash(v23);
    *v530 = StringHash;
  }
  v24 = 1;
  v531 = v13;
  v529 = a5;
  v536 = v17;
  v524 = a9;
  if (a4 && a6)
  {
    v25 = *(_DWORD *)(v17 + 60);
    v26 = (_QWORD *)glpLinkerGetAllocator(v17);
    v27 = (const char *)glpMakeStringHash(v26);
    *(_QWORD *)(v17 + 344) = glpMakeIntHash(&GLP_MALLOC_ALLOCATOR);
    v28 = *(_QWORD *)(v17 + 96);
    LODWORD(v29) = *(_DWORD *)(v28 + 4);
    if ((_DWORD)v29)
    {
      v517 = a6;
      v30 = 0;
      LODWORD(v520) = 0;
      LODWORD(v519) = 0;
      v523 = 0;
      LODWORD(v533) = 0;
      LODWORD(v518) = -1;
      v525 = (uint64_t)v27;
      LODWORD(v527) = v25;
      while (1)
      {
        LODWORD(v532) = v24;
        v31 = v30 == (_DWORD)v29 - 1 || *(_DWORD *)(v17 + 300) == 35981;
        v32 = *(_QWORD *)(v28 + 8) + 16 * v30;
        v34 = *(char **)v32;
        v33 = *(_QWORD *)(v32 + 8);
        if (glpStringsEqual("gl_NextBuffer", 0xD22C7DA40000000DLL, *(char **)v32, v33) && v25 == 1)
        {
          ElementCount = 0;
          v31 = 1;
        }
        else if (glpStringsEqual("gl_SkipComponents1", 0x17BA0E7C00000012, v34, v33) && v25 == 1)
        {
          LODWORD(v533) = (_DWORD)v533 + 4;
          ElementCount = 1;
        }
        else if (glpStringsEqual("gl_SkipComponents2", 0xB5F2691B00000012, v34, v33) && v25 == 1)
        {
          LODWORD(v533) = (_DWORD)v533 + 8;
          ElementCount = 2;
        }
        else if (glpStringsEqual("gl_SkipComponents3", 0x74D9376D00000012, v34, v33) && v25 == 1)
        {
          LODWORD(v533) = (_DWORD)v533 + 12;
          ElementCount = 3;
        }
        else
        {
          if (!glpStringsEqual("gl_SkipComponents4", 0x635B431500000012, v34, v33) || v25 != 1)
          {
            v538 = 0;
            v537 = 0;
            v552 = 0;
            v553[0] = 0;
            if (!glpTypeParseDeref(v517, (uint64_t (*)(uint64_t, uint64_t, uint64_t))topLevelLookUpObjectTypeFromStringHash, (uint64_t)v34, v33, &v537, (uint64_t *)v553, &v552))
            {
              InfoLog = (uint64_t **)glpLinkerGetInfoLog(v17);
              *(_QWORD *)&v542 = "-1";
              *((_QWORD *)&v542 + 1) = 0xEDA00000002;
              *(_QWORD *)&v543 = 0xFFFFFFFFLL;
              glpLogMessage(InfoLog, 0, (uint64_t)&v542, "Could not find transform feedback binding for '%.*s.'", v96, v97, v98, v99, v33);
              goto LABEL_56;
            }
            v85 = (uint64_t *)glpStringHashGet(v517, v537, v538);
            v86 = (uint64_t *)v85[1];
            if (v86)
            {
              v87 = glpLayoutObjectFind(v86, 9);
              if (v87)
              {
                if (*((_DWORD *)v87 + 4))
                {
                  v88 = (uint64_t **)glpLinkerGetInfoLog(v536);
                  *(_QWORD *)&v542 = "-1";
                  *((_QWORD *)&v542 + 1) = 0xEDA00000002;
                  *(_QWORD *)&v543 = 0xFFFFFFFFLL;
                  v17 = v536;
                  glpLogMessage(v88, 0, (uint64_t)&v542, "Exceeded max vertex streams of %d, with %d.", v89, v90, v91, v92, 1);
                  goto LABEL_56;
                }
              }
            }
            v518 = v85;
            Kind = glpTypeGetKind(v553[0]);
            ElementType = v553[0];
            if (Kind == 2)
            {
              ElementCount = glpArrayTypeGetElementCount((uint64_t)v553[0]);
              ElementType = (unsigned int *)glpArrayTypeGetElementType((uint64_t)v553[0]);
              v553[0] = ElementType;
            }
            else
            {
              ElementCount = 1;
            }
            v17 = v536;
            if (glpTypeGetKind(ElementType))
            {
              v100 = (uint64_t **)glpLinkerGetInfoLog(v536);
              *(_QWORD *)&v542 = "-1";
              *((_QWORD *)&v542 + 1) = 0xEDA00000002;
              *(_QWORD *)&v543 = 0xFFFFFFFFLL;
              glpLogMessage(v100, 0, (uint64_t)&v542, "Type of '%.*s' not valid for transform feedback.", v101, v102, v103, v104, v33);
              LODWORD(v518) = 0;
              goto LABEL_56;
            }
            v105 = (uint64_t)v27;
            PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)v553[0]);
            if (glpStringHashGet(v105, v34, v33))
            {
              v107 = (uint64_t **)glpLinkerGetInfoLog(v536);
              *(_QWORD *)&v542 = "-1";
              *((_QWORD *)&v542 + 1) = 0xEDA00000002;
              *(_QWORD *)&v543 = 0xFFFFFFFFLL;
              glpLogMessage(v107, 0, (uint64_t)&v542, "Duplicate transform feedback bindings specified for '%.*s.'", v108, v109, v110, v111, v33);
              LODWORD(v518) = 0;
              v27 = (const char *)v105;
              v25 = (int)v527;
              goto LABEL_56;
            }
            glpStringHashPut(v105, v34, v33, 1, v106);
            v112 = v536;
            v113 = glpLinkerPoolAlloc(v536);
            *(_QWORD *)v113 = v518;
            *(_QWORD *)(v113 + 8) = v552;
            LODWORD(v116) = (_DWORD)v533;
            *(_DWORD *)(v113 + 16) = v523;
            *(_DWORD *)(v113 + 20) = v116;
            *(_DWORD *)(v113 + 24) = 0;
            v114 = *(_DWORD *)(v112 + 240);
            v115 = *(unsigned int *)(v112 + 244);
            LODWORD(v116) = v115 + 1;
            if ((int)v115 + 1 <= v114)
            {
              v119 = *(char **)(v112 + 248);
              v120 = *(_DWORD *)(v112 + 244);
            }
            else
            {
              if (v114 <= 1)
                v114 = 1;
              v117 = 2 * v114;
              if (v117 <= (int)v116)
                v116 = v116;
              else
                v116 = v117;
              v516 = v116;
              v118 = (_QWORD *)glpLinkerGetAllocator(v112);
              v515 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))v118[1])(*v118, 8 * v516, "Vector Storage (GLPTFStore *, growth)");
              memcpy(v515, *(const void **)(v112 + 248), 8 * *(unsigned int *)(v112 + 244));
              ((void (*)(_QWORD, _QWORD))v118[3])(*v118, *(_QWORD *)(v112 + 248));
              v119 = v515;
              *(_DWORD *)(v112 + 240) = v516;
              *(_QWORD *)(v112 + 248) = v119;
              v120 = *(_DWORD *)(v112 + 244);
            }
            memmove(&v119[8 * v115 + 8], &v119[8 * v115], 8 * (v120 - v115));
            *(_QWORD *)(*(_QWORD *)(v112 + 248) + 8 * v115) = v113;
            ++*(_DWORD *)(v112 + 244);
            v121 = v518;
            *((_BYTE *)v518 + 112) = 1;
            v122 = glpABIGetTypeSize(0, *v121, 0);
            glpTypeSizeGetSize(v122);
            v123 = (uint64_t *)glpLinkerPoolAlloc(v112);
            v124 = (_BYTE *)glpLinkerPoolAlloc(v112);
            glpTypeGetAppleVec4Types((unsigned int *)*v121, v123, 1, 0, 0, v124, 0, 0, 0);
            if (HIDWORD(v552))
            {
              v125 = v552;
              v518 = v123;
              v126 = (int)v533;
              do
              {
                ScalarCount = glpPrimitiveTypeGetScalarCount(*((unsigned int *)v518 + v125));
                v126 += glpPrimitiveTypeGetBytesPerComponent(*((unsigned int *)v518 + v125++)) * ScalarCount;
              }
              while (v125 - v552 < HIDWORD(v552));
            }
            else
            {
              v126 = (int)v533;
            }
            LODWORD(v533) = v126;
            LODWORD(v518) = 0;
            goto LABEL_45;
          }
          LODWORD(v533) = (_DWORD)v533 + 16;
          ElementCount = 4;
        }
        if (*(_DWORD *)(v17 + 300) != 35980)
        {
          v50 = (uint64_t **)glpLinkerGetInfoLog(v17);
          *(_QWORD *)&v542 = "-1";
          *((_QWORD *)&v542 + 1) = 0xEDA00000002;
          *(_QWORD *)&v543 = 0xFFFFFFFFLL;
          glpLogMessage(v50, 0, (uint64_t)&v542, "Usage of '%.*s' disallowed if transformFeedbackBufferMode != GL_INTERLEAVED_ATTRIBS.", v51, v52, v53, v54, v33);
          goto LABEL_56;
        }
        PrimitiveType = 0;
LABEL_45:
        v41 = malloc_type_malloc(0x18uLL, 0x7081ABB9uLL);
        if (!v41
          || (v42 = (uint64_t)v41,
              *v41 = 0,
              v41[1] = 0,
              v43 = v33,
              v41[2] = 0,
              (v44 = (char *)malloc_type_malloc(v33, 0x7081ABB9uLL)) == 0))
        {
          abort();
        }
        v45 = v44;
        memcpy(v44, v34, v33);
        v47 = v33 >> 5;
        if (v33 >> 5 >= v33)
        {
          v49 = v33;
        }
        else
        {
          v48 = ~(v33 >> 5);
          LODWORD(v49) = v33;
          do
          {
            v49 = (32 * (_DWORD)v49 + (v49 >> 2) + v45[(v33 - 1)]) ^ v49;
            LODWORD(v33) = v33 + v48;
          }
          while (v33 > v47);
        }
        *(_QWORD *)v42 = v45;
        *(_QWORD *)(v42 + 8) = v43 | (v49 << 32);
        *(_DWORD *)(v42 + 16) = ElementCount;
        *(_DWORD *)(v42 + 20) = PrimitiveType;
        glpIntHashPut(*(_QWORD *)(v536 + 344), v30, v42, v46);
        if (!v31)
        {
          v13 = v531;
          v17 = v536;
          v24 = v532;
          v27 = (const char *)v525;
LABEL_71:
          v25 = (int)v527;
          goto LABEL_72;
        }
        v55 = v523;
        v13 = v531;
        v27 = (const char *)v525;
        v25 = (int)v527;
        if (v523 < 4)
        {
          v61 = v536;
          v62 = (_QWORD *)glpLinkerPoolAlloc(v536);
          v63 = glpLinkerGetAllocator(v536);
          *v62 = glpMakeLayoutObject(v63);
          if ((_DWORD)v533)
          {
            v64 = glpLinkerGetAllocator(v61);
            v65 = (_QWORD *)*v62;
            *(_QWORD *)&v542 = "-1";
            *((_QWORD *)&v542 + 1) = 0xEDA00000002;
            *(_QWORD *)&v543 = 0xFFFFFFFFLL;
            glpLayoutObjectAppendInteger(v64, 0, (uint64_t)&v542, 0, 0, v65, 33, 2);
            v66 = glpLinkerGetAllocator(v61);
            v67 = (_QWORD *)*v62;
            *(_QWORD *)&v542 = "-1";
            *((_QWORD *)&v542 + 1) = 0xEDA00000002;
            *(_QWORD *)&v543 = 0xFFFFFFFFLL;
            glpLayoutObjectAppendInteger(v66, 0, (uint64_t)&v542, 0, 0, v67, 46, 10);
            v68 = glpLinkerGetAllocator(v61);
            v69 = (_QWORD *)*v62;
            *(_QWORD *)&v542 = "-1";
            *((_QWORD *)&v542 + 1) = 0xEDA00000002;
            *(_QWORD *)&v543 = 0xFFFFFFFFLL;
            glpLayoutObjectAppendInteger(v68, 0, (uint64_t)&v542, 0, 0, v69, 65, v55);
            v70 = glpLinkerGetAllocator(v61);
            v71 = (_QWORD *)*v62;
            *(_QWORD *)&v542 = "-1";
            *((_QWORD *)&v542 + 1) = 0xEDA00000002;
            *(_QWORD *)&v543 = 0xFFFFFFFFLL;
            glpLayoutObjectAppendInteger(v70, 0, (uint64_t)&v542, 0, 0, v71, 66, (int)v518);
            v72 = glpLinkerGetAllocator(v61);
            v73 = (_QWORD *)*v62;
            *(_QWORD *)&v542 = "-1";
            *((_QWORD *)&v542 + 1) = 0xEDA00000002;
            *(_QWORD *)&v543 = 0xFFFFFFFFLL;
            glpLayoutObjectAppendInteger(v72, 0, (uint64_t)&v542, 0, 0, v73, 67, (int)v533);
          }
          v74 = *(_DWORD *)(v61 + 224);
          v75 = *(unsigned int *)(v61 + 228);
          v24 = v532;
          if ((int)v75 + 1 <= v74)
          {
            v79 = v61;
            v80 = *(char **)(v61 + 232);
            v81 = v75;
          }
          else
          {
            if (v74 <= 1)
              v74 = 1;
            v76 = 2 * v74;
            if (v76 <= (int)v75 + 1)
              v77 = v75 + 1;
            else
              v77 = v76;
            v78 = (_QWORD *)glpLinkerGetAllocator(v61);
            v79 = v61;
            v80 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))v78[1])(*v78, 8 * v77, "Vector Storage (GLPTFBuffer *, growth)");
            memcpy(v80, *(const void **)(v79 + 232), 8 * *(unsigned int *)(v79 + 228));
            ((void (*)(_QWORD, _QWORD))v78[3])(*v78, *(_QWORD *)(v79 + 232));
            *(_DWORD *)(v79 + 224) = v77;
            v27 = (const char *)v525;
            *(_QWORD *)(v79 + 232) = v80;
            v81 = *(_DWORD *)(v79 + 228);
          }
          memmove(&v80[8 * v75 + 8], &v80[8 * v75], 8 * (v81 - v75));
          *(_QWORD *)(*(_QWORD *)(v79 + 232) + 8 * v75) = v62;
          v82 = *(_DWORD *)(v79 + 228) + 1;
          v83 = v520;
          v84 = (int)v533;
          if (v520 <= v533)
            v83 = (int)v533;
          LODWORD(v520) = v83;
          *(_DWORD *)(v79 + 228) = v82;
          LODWORD(v519) = v84 + (_DWORD)v519;
          v523 = (v523 + 1);
          LODWORD(v518) = -1;
          LODWORD(v533) = 0;
          v17 = v79;
          goto LABEL_71;
        }
        v17 = v536;
        v56 = (uint64_t **)glpLinkerGetInfoLog(v536);
        *(_QWORD *)&v542 = "-1";
        *((_QWORD *)&v542 + 1) = 0xEDA00000002;
        *(_QWORD *)&v543 = 0xFFFFFFFFLL;
        glpLogMessage(v56, 0, (uint64_t)&v542, "Exceeded max transform feedback buffers of %d, with %d.", v57, v58, v59, v60, 4);
LABEL_56:
        v24 = 0;
LABEL_72:
        ++v30;
        v28 = *(_QWORD *)(v17 + 96);
        v29 = *(unsigned int *)(v28 + 4);
        if (v30 >= v29)
          goto LABEL_102;
      }
    }
    LODWORD(v519) = 0;
    LODWORD(v520) = 0;
LABEL_102:
    StringHash = glpDestroyStringHash((uint64_t)v27);
    v128 = *(_DWORD *)(v17 + 300);
    if (v128 == 35980)
    {
      a5 = v529;
      if (v519 >= 0x104)
      {
        v134 = (uint64_t **)glpLinkerGetInfoLog(v17);
        *(_QWORD *)&v542 = "-1";
        *((_QWORD *)&v542 + 1) = 0xEDA00000002;
        *(_QWORD *)&v543 = 0xFFFFFFFFLL;
        glpLogMessage(v134, 0, (uint64_t)&v542, "Exceeded max transform feedback interleaved components of %d, with %d.", v135, v136, v137, v138, 64);
        return 0;
      }
    }
    else
    {
      a5 = v529;
      if (v128 == 35981 && v520 >= 0x14)
      {
        v129 = (uint64_t **)glpLinkerGetInfoLog(v17);
        *(_QWORD *)&v542 = "-1";
        *((_QWORD *)&v542 + 1) = 0xEDA00000002;
        *(_QWORD *)&v543 = 0xFFFFFFFFLL;
        glpLogMessage(v129, 0, (uint64_t)&v542, "Exceeded max transform feedback separate components of %d, with %d.", v130, v131, v132, v133, 4);
        return 0;
      }
    }
    if (!(_DWORD)v24)
      return v24;
  }
  if (!a5 || (v139 = *(unsigned int *)(a5 + 32), !(_DWORD)v139))
  {
    v141 = 0x80000000;
    if (!v13)
      goto LABEL_317;
    goto LABEL_196;
  }
  v140 = 0;
  v517 = v17 + 4 * v528 + 276;
  v141 = 0x80000000;
  v142 = "Copy Binding";
  do
  {
    v143 = *(_QWORD *)(a5 + 40);
    v144 = *(uint64_t **)(v143 + 32 * v140);
    if (!v144)
      goto LABEL_192;
    v145 = v143 + 32 * v140;
    v146 = *(const char **)(v145 + 8);
    v147 = *(const char **)(v145 + 16);
    v148 = (unsigned int *)v144[15];
    v552 = 0;
    v553[0] = v148;
    StringHash = v144[1];
    v552 = (unsigned int *)*v144;
    if (!StringHash
      || (StringHash = (uint64_t)glpLayoutObjectFind((uint64_t *)StringHash, 28)) == 0
      && (StringHash = (uint64_t)glpLayoutObjectFind((uint64_t *)v144[1], 29)) == 0)
    {
      v550 = 0u;
      v551 = 0u;
      v548 = 0u;
      v549 = 0u;
      v546 = 0u;
      v547 = 0u;
      v545 = 0u;
      v544 = 0u;
      v543 = 0u;
      v542 = 0u;
      v149 = *(_OWORD *)v144;
      v543 = *((_OWORD *)v144 + 1);
      v542 = v149;
      v150 = *((_OWORD *)v144 + 2);
      v151 = *((_OWORD *)v144 + 3);
      v152 = *((_OWORD *)v144 + 5);
      v546 = *((_OWORD *)v144 + 4);
      v547 = v152;
      v545 = v151;
      v544 = v150;
      v153 = *((_OWORD *)v144 + 6);
      v154 = *((_OWORD *)v144 + 7);
      v155 = *((_OWORD *)v144 + 9);
      v550 = *((_OWORD *)v144 + 8);
      v551 = v155;
      v548 = v153;
      v549 = v154;
      if (v147 >= 3)
      {
        v525 = (uint64_t)v147;
        StringHash = strncmp("gl_", v146, 3uLL);
        if (!(_DWORD)StringHash
          || v525 >= 9
          && (StringHash = strncmp("$ib$", v146, 4uLL), !(_DWORD)StringHash)
          && (StringHash = strncmp("$gl_", v146 + 5, 4uLL), !(_DWORD)StringHash))
        {
          if (!(_DWORD)v525
            || *v146 != 36
            || v525 >= 9
            && (StringHash = strncmp("$ib$", v146, 4uLL), !(_DWORD)StringHash)
            && (StringHash = strncmp("$gl_", v146 + 5, 4uLL), !(_DWORD)StringHash))
          {
            v156 = (uint64_t *)v144[1];
            v520 = (uint64_t)v146;
            if (v156)
            {
              v157 = glpLayoutObjectFind(v156, 79);
              v158 = (uint64_t *)v144[1];
              v159 = v157 == 0;
              if (v158)
                v160 = glpLayoutObjectFind(v158, 80);
              else
                v160 = 0;
            }
            else
            {
              v160 = 0;
              v159 = 1;
            }
            v533 = v144;
            if (!v13
              || *(_DWORD *)(v536 + 296)
              || (v161 = inputForOutput(v13, v520, v525)) == 0
              || !v160
              || !*((_DWORD *)v144 + 32)
              || (v162 = v161, !*(_DWORD *)(v161 + 128)))
            {
              if (glpTypeGetKind((unsigned int *)v542) == 3)
                *(_QWORD *)&v542 = glpBankTypeGetElementType(v542);
              goto LABEL_150;
            }
            v541 = *(_QWORD *)(v161 + 120);
            v540 = *(unsigned int **)v161;
            v17 = v536;
            InputOutputBitsType = getInputOutputBitsType(v536, v534, v161, &v541, &v540, v528, (uint64_t *)v553, &v552);
            StringHash = (uint64_t)v552;
            *((unsigned int **)&v549 + 1) = v553[0];
            *(_QWORD *)&v542 = v552;
            if ((_DWORD)v24)
              v164 = InputOutputBitsType == 0;
            else
              v164 = 1;
            v24 = !v164;
            if (InputOutputBitsType)
            {
              if (!glpTypesEqual(v552, (uint64_t)v540)
                || ((*(_QWORD *)(v162 + 48) ^ v144[6]) & 0x6F000000000) != 0)
              {
                v532 = (uint64_t **)glpLinkerGetInfoLog(v536);
                v165 = v142;
                v166 = glpLanguageToString(v534);
                glpLanguageToString(v528);
                v537 = "-1";
                v538 = 0xEDA00000002;
                v539 = 0xFFFFFFFFLL;
                v144 = v533;
                v510 = v166;
                v142 = v165;
                glpLogMessage(v532, 0, (uint64_t)&v537, "Input of %s shader '%.*s' differs in type/qualifiers to that written by %s shader", v167, v168, v169, v170, v510);
                v24 = 0;
              }
LABEL_150:
              v171 = glpABIGetTypeSize(0, v542, 0);
              Size = glpTypeSizeGetSize(v171);
              StringHash = glpLinkerPoolAlloc(v536);
              *(_QWORD *)StringHash = 0;
              *(_QWORD *)(StringHash + 8) = 0;
              *(_QWORD *)StringHash = &v542;
              if ((_DWORD)v24)
              {
                v173 = StringHash;
                LODWORD(v518) = v159;
                v174 = v144[6];
                v175 = glpLayoutObjectFind((uint64_t *)v144[1], 78);
                if (v175)
                  glpIntHashPut(*v530, *((_DWORD *)v175 + 4), -1, v176);
                v177 = glpLayoutObjectFind((uint64_t *)v144[1], 69);
                LODWORD(v532) = v24;
                v519 = (_QWORD *)v140;
                if (v177)
                {
                  v178 = v536;
                  v179 = (_QWORD *)glpLinkerGetAllocator(v536);
                  v180 = glpCopyLayoutObject(v179, (_QWORD **)v144[1]);
                  v181 = glpLayoutObjectFind(v180, 69);
                  v182 = *((_DWORD *)v181 + 4);
                  *((_DWORD *)v181 + 4) = 0;
                  SlotsWithGLPType = allocateSlotsWithGLPType(v178, *v530, 0, (uint64_t **)v173, v174 & 0x7F00000001FLL, v174 & 0x7F00000001FLL, v180, 0, v182, 0x20u);
                  if (v528 == 1 && SlotsWithGLPType)
                    v144[1] = *(_QWORD *)(glpIntHashGet(*v530, v182) + 24);
                }
                else
                {
                  v185 = (_DWORD *)glpLinkerPoolAlloc(v536);
                  v523 = Size;
                  v527 = (_BYTE *)glpLinkerPoolAlloc(v536);
                  glpTypeGetAppleVec4Types((unsigned int *)v542, v185, 1, 0, 0, v527, 0, 0, 0);
                  if (glpLayoutObjectFind((uint64_t *)v144[1], 31))
                  {
                    if (Size)
                    {
                      v186 = 0;
                      v187 = 0;
                      v188 = 0;
                      v189 = 0;
                      v190 = 0;
                      do
                      {
                        if (glpPrimitiveTypeGetScalarCount(v185[v186]))
                        {
                          v191 = 0;
                          do
                          {
                            v192 = v189 > 3;
                            if (v189 <= 3)
                              v193 = v190;
                            else
                              v193 = 0;
                            if (v189 > 3)
                              v189 = 0;
                            if (v192)
                              ++v188;
                            if (BitSetGetEquals(*((uint64_t *)&v549 + 1), v186))
                            {
                              if (!v193)
                              {
                                v194 = v536;
                                v190 = glpLinkerPoolAlloc(v536);
                                *(_OWORD *)v190 = 0u;
                                *(_OWORD *)(v190 + 16) = 0u;
                                glpIntHashPut(*v530, v141, v190, 0.0);
                                v195 = v533;
                                *(_QWORD *)(v190 + 8) = v533[6] & 0x7F00000001FLL | ((unint64_t)v527[v186] >> 3);
                                *(_DWORD *)(v190 + 4) = glpPrimitiveTypeGetScalarType(v185[v186]);
                                *(_QWORD *)(v190 + 24) = offsetLayout(v194, (_QWORD **)v195[1], v188);
                                v187 = v141++;
                              }
                              v196 = *(unsigned int *)(v173 + 8);
                              v197 = v173 + 8 * v196;
                              *(_DWORD *)(v197 + 16) = v187;
                              *(_DWORD *)(v197 + 20) = v189;
                              *(_DWORD *)(v173 + 8) = v196 + 1;
                              *(_DWORD *)v190 |= 1 << v189;
                              ScalarType = glpPrimitiveTypeGetScalarType(v185[v186]);
                              v199 = componentCountForSet(*(_DWORD *)v190);
                              *(_DWORD *)(v190 + 4) = glpGetVectorType(ScalarType, v199);
                              v193 = v190;
                            }
                            else
                            {
                              v190 = v193;
                            }
                            ++v191;
                            ++v189;
                          }
                          while (v191 < glpPrimitiveTypeGetScalarCount(v185[v186]));
                        }
                        else
                        {
                          v193 = v190;
                        }
                        ++v186;
                        v190 = v193;
                        a5 = v529;
                        v144 = v533;
                      }
                      while (v186 != v523);
                    }
                  }
                  else if (Size)
                  {
                    v200 = 0;
                    do
                    {
                      if (BitSetGetEquals(*((uint64_t *)&v549 + 1), v200))
                      {
                        v201 = glpLinkerPoolAlloc(v536);
                        *(_OWORD *)v201 = 0u;
                        *(_OWORD *)(v201 + 16) = 0u;
                        glpIntHashPut(*v530, v141, v201, 0.0);
                        if (glpPrimitiveTypeGetScalarCount(v185[v200]))
                        {
                          v202 = 0;
                          do
                          {
                            v203 = *(unsigned int *)(v173 + 8);
                            v204 = v173 + 8 * v203;
                            *(_DWORD *)(v204 + 16) = v141;
                            *(_DWORD *)(v204 + 20) = v202;
                            *(_DWORD *)(v173 + 8) = v203 + 1;
                            *(_DWORD *)v201 |= 1 << v202++;
                          }
                          while (v202 < glpPrimitiveTypeGetScalarCount(v185[v200]));
                        }
                        *(_QWORD *)(v201 + 8) = v144[6] & 0x7F00000001FLL | ((unint64_t)v527[v200] >> 3);
                        *(_DWORD *)(v201 + 4) = v185[v200];
                        *(_QWORD *)(v201 + 24) = offsetLayout(v536, (_QWORD **)v144[1], v200);
                        ++v141;
                      }
                      ++v200;
                    }
                    while (v200 != v523);
                  }
                }
                *(_QWORD *)v173 = v144;
                glpStringHashPut(*v521, (const char *)v520, v525, v173, v184);
                if ((_DWORD)v518)
                  *(_DWORD *)v517 += *(_DWORD *)(v173 + 8);
                v17 = v536;
                v205 = (_QWORD *)glpLinkerPoolAlloc(v536);
                *v205 = 0;
                v205[1] = 0;
                *(_DWORD *)v205 = -1;
                v205[1] = *v144;
                StringHash = glpStringHashPut(*v522, (const char *)v520, v525, (uint64_t)v205, v206);
                v13 = v531;
                v24 = v532;
                v140 = (unint64_t)v519;
                v142 = "Copy Binding";
              }
              else
              {
                v17 = v536;
              }
            }
          }
        }
      }
    }
    v139 = *(unsigned int *)(a5 + 32);
LABEL_192:
    ++v140;
  }
  while (v140 < v139);
  if (!v13)
    goto LABEL_317;
LABEL_196:
  if (*(_DWORD *)(v13 + 32))
  {
    v207 = 0;
    v517 = v17 + 4 * v534 + 256;
    while (2)
    {
      v208 = *(_QWORD *)(v13 + 40);
      v209 = *(uint64_t **)(v208 + 32 * v207);
      if (v209)
      {
        v210 = v208 + 32 * v207;
        v211 = *(const char **)(v210 + 8);
        v212 = *(_QWORD *)(v210 + 16);
        StringHash = v209[1];
        if (!StringHash
          || (StringHash = (uint64_t)glpLayoutObjectFind((uint64_t *)StringHash, 28)) == 0
          && (StringHash = (uint64_t)glpLayoutObjectFind((uint64_t *)v209[1], 29)) == 0)
        {
          v533 = v209;
          if (v212 >= 3)
          {
            StringHash = strncmp("gl_", v211, 3uLL);
            if (!(_DWORD)StringHash
              || v212 >= 9
              && (StringHash = strncmp("$ib$", v211, 4uLL), !(_DWORD)StringHash)
              && (StringHash = strncmp("$gl_", v211 + 5, 4uLL), !(_DWORD)StringHash))
            {
              if (*v211 != 36
                || v212 >= 9
                && (StringHash = strncmp("$ib$", v211, 4uLL), !(_DWORD)StringHash)
                && (StringHash = strncmp("$gl_", v211 + 5, 4uLL), !(_DWORD)StringHash))
              {
                v236 = (uint64_t *)v209[1];
                if (v236)
                  v518 = glpLayoutObjectFind(v236, 79);
                else
                  v518 = 0;
                v260 = (const char *)v209[15];
                v537 = v260;
                v261 = (unsigned int *)*v209;
                v553[0] = (unsigned int *)*v209;
                if ((_DWORD)v24)
                {
                  v24 = getInputOutputBitsType(v17, v534, (uint64_t)v209, &v537, v553, 5, 0, 0) != 0;
                  v260 = v537;
                  v261 = v553[0];
                }
                v550 = 0u;
                v551 = 0u;
                v548 = 0u;
                v549 = 0u;
                v546 = 0u;
                v547 = 0u;
                v545 = 0u;
                v544 = 0u;
                v543 = 0u;
                v542 = 0u;
                v262 = *((_OWORD *)v209 + 8);
                v263 = *((_OWORD *)v209 + 9);
                v264 = *((_OWORD *)v209 + 6);
                v549 = *((_OWORD *)v209 + 7);
                v265 = *((_OWORD *)v209 + 1);
                v542 = *(_OWORD *)v209;
                v543 = v265;
                v266 = *((_OWORD *)v209 + 2);
                v267 = *((_OWORD *)v209 + 3);
                v268 = *((_OWORD *)v209 + 5);
                v546 = *((_OWORD *)v209 + 4);
                v547 = v268;
                v545 = v267;
                v544 = v266;
                v550 = v262;
                v551 = v263;
                v548 = v264;
                *((_QWORD *)&v549 + 1) = v260;
                *(_QWORD *)&v542 = v261;
                v269 = glpTypeGetKind(v261);
                v270 = v542;
                v525 = (uint64_t)v211;
                if (v269 == 3)
                  v270 = glpBankTypeGetElementType(v542);
                v271 = glpABIGetTypeSize(0, v270, 0);
                v272 = glpTypeSizeGetSize(v271);
                StringHash = glpLinkerPoolAlloc(v536);
                *(_QWORD *)StringHash = 0;
                *(_QWORD *)(StringHash + 8) = 0;
                *(_QWORD *)StringHash = &v542;
                if ((_DWORD)v24)
                {
                  v273 = StringHash;
                  v523 = v212;
                  v274 = v209[6];
                  v275 = glpLayoutObjectFind((uint64_t *)v209[1], 78);
                  if (v275)
                    glpIntHashPut(*v535, *((_DWORD *)v275 + 4), -1, v276);
                  v519 = (_QWORD *)v207;
                  if (glpLayoutObjectFind((uint64_t *)v209[1], 35))
                  {
                    v277 = v274 & 0x7F00000001FLL;
                    v278 = v536;
                    v279 = (_QWORD *)glpLinkerGetAllocator(v536);
                    v280 = glpCopyLayoutObject(v279, (_QWORD **)v209[1]);
                    v281 = glpLayoutObjectFind(v280, 35);
                    v282 = *((_DWORD *)v281 + 4);
                    *((_DWORD *)v281 + 4) = 0;
                    allocateSlotsWithGLPType(v278, 0, *v535, (uint64_t **)v273, v277, v277, 0, (_QWORD **)v280, v282, 0x20u);
                  }
                  else
                  {
                    v290 = (_DWORD *)glpLinkerPoolAlloc(v536);
                    v520 = v272;
                    v527 = (_BYTE *)glpLinkerPoolAlloc(v536);
                    v291 = (unsigned int *)v542;
                    if (glpTypeGetKind((unsigned int *)v542) == 3)
                      v291 = (unsigned int *)glpBankTypeGetElementType((uint64_t)v291);
                    glpTypeGetAppleVec4Types(v291, v290, 1, 0, 0, v527, 0, 0, 0);
                    if (glpLayoutObjectFind((uint64_t *)v533[1], 31))
                    {
                      if (v272)
                      {
                        v292 = 0;
                        v293 = 0;
                        v294 = 0;
                        v295 = 0;
                        v296 = 0;
                        LODWORD(v532) = v24;
                        do
                        {
                          if (glpPrimitiveTypeGetScalarCount(v290[(_QWORD)v292]))
                          {
                            v297 = 0;
                            do
                            {
                              v298 = v295 > 3;
                              if (v295 <= 3)
                                v299 = v296;
                              else
                                v299 = 0;
                              if (v295 > 3)
                                v295 = 0;
                              if (v298)
                                ++v294;
                              if (BitSetGetEquals(*((uint64_t *)&v549 + 1), v292))
                              {
                                if (!v299)
                                {
                                  v300 = v536;
                                  v296 = glpLinkerPoolAlloc(v536);
                                  *(_OWORD *)v296 = 0u;
                                  *(_OWORD *)(v296 + 16) = 0u;
                                  glpIntHashPut(*v535, v141, v296, 0.0);
                                  v301 = v533;
                                  *(_QWORD *)(v296 + 8) = v533[6] & 0x7F00000001FLL | ((unint64_t)*((unsigned __int8 *)v292 + (_QWORD)v527) >> 3);
                                  *(_DWORD *)(v296 + 4) = glpPrimitiveTypeGetScalarType(v290[(_QWORD)v292]);
                                  *(_QWORD *)(v296 + 24) = offsetLayout(v300, (_QWORD **)v301[1], v294);
                                  v293 = v141++;
                                }
                                v302 = *(unsigned int *)(v273 + 8);
                                v303 = v273 + 8 * v302;
                                *(_DWORD *)(v303 + 16) = v293;
                                *(_DWORD *)(v303 + 20) = v295;
                                *(_DWORD *)(v273 + 8) = v302 + 1;
                                *(_DWORD *)v296 |= 1 << v295;
                                v304 = glpPrimitiveTypeGetScalarType(v290[(_QWORD)v292]);
                                v305 = componentCountForSet(*(_DWORD *)v296);
                                *(_DWORD *)(v296 + 4) = glpGetVectorType(v304, v305);
                                v299 = v296;
                              }
                              else
                              {
                                v296 = v299;
                              }
                              ++v297;
                              ++v295;
                            }
                            while (v297 < glpPrimitiveTypeGetScalarCount(v290[(_QWORD)v292]));
                          }
                          else
                          {
                            v299 = v296;
                          }
                          v292 = (uint64_t **)((char *)v292 + 1);
                          v296 = v299;
                          a5 = v529;
                          v24 = v532;
                        }
                        while (v292 != (uint64_t **)v520);
                      }
                    }
                    else if (v272)
                    {
                      v308 = 0;
                      do
                      {
                        if (BitSetGetEquals(*((uint64_t *)&v549 + 1), v308))
                        {
                          v309 = glpLinkerPoolAlloc(v536);
                          *(_OWORD *)v309 = 0u;
                          *(_OWORD *)(v309 + 16) = 0u;
                          glpIntHashPut(*v535, v141, v309, 0.0);
                          if (glpPrimitiveTypeGetScalarCount(v290[(_QWORD)v308]))
                          {
                            v310 = 0;
                            do
                            {
                              v311 = *(unsigned int *)(v273 + 8);
                              v312 = v273 + 8 * v311;
                              *(_DWORD *)(v312 + 16) = v141;
                              *(_DWORD *)(v312 + 20) = v310;
                              *(_DWORD *)(v273 + 8) = v311 + 1;
                              *(_DWORD *)v309 |= 1 << v310++;
                            }
                            while (v310 < glpPrimitiveTypeGetScalarCount(v290[(_QWORD)v308]));
                          }
                          v313 = v533;
                          *(_QWORD *)(v309 + 8) = v533[6] & 0x7F00000001FLL | ((unint64_t)*((unsigned __int8 *)v308
                                                                                                 + (_QWORD)v527) >> 3);
                          *(_DWORD *)(v309 + 4) = v290[(_QWORD)v308];
                          *(_QWORD *)(v309 + 24) = offsetLayout(v536, (_QWORD **)v313[1], v308);
                          ++v141;
                        }
                        v308 = (uint64_t **)((char *)v308 + 1);
                      }
                      while (v308 != (uint64_t **)v520);
                    }
                  }
                  v17 = v536;
                  v283 = propagateCopyBindings(v536, (uint64_t)v533, v273);
                  v284 = (const char *)v525;
                  v285 = v523;
                  glpStringHashPut(*v526, (const char *)v525, v523, (uint64_t)v283, v286);
                  v13 = v531;
                  v207 = (unint64_t)v519;
                  if (!v518)
                  {
                    if (glpTypeGetKind((unsigned int *)v542) == 3)
                      v287 = glpBankTypeGetElementCount(v542);
                    else
                      v287 = 1;
                    *(_DWORD *)v517 += *((_DWORD *)v283 + 2) * v287;
                  }
                  v306 = (_QWORD *)glpLinkerPoolAlloc(v17);
                  *v306 = 0;
                  v306[1] = 0;
                  *(_DWORD *)v306 = -1;
                  v306[1] = *v533;
                  StringHash = glpStringHashPut(*v524, v284, v285, (uint64_t)v306, v307);
                }
                else
                {
                  v17 = v536;
                }
                goto LABEL_264;
              }
            }
          }
          if (v534 == 4 && (v209[6] & 0x40000000) != 0)
          {
            v213 = (uint64_t *)v209[1];
            if (v213)
              v520 = (uint64_t)glpLayoutObjectFind(v213, 79);
            else
              v520 = 0;
            v214 = v209[15];
            v215 = (unsigned int *)*v209;
            LODWORD(v527) = v24 != 0;
            v550 = 0u;
            v551 = 0u;
            v548 = 0u;
            v549 = 0u;
            v546 = 0u;
            v547 = 0u;
            v545 = 0u;
            v544 = 0u;
            v543 = 0u;
            v542 = 0u;
            v216 = *((_OWORD *)v209 + 8);
            v217 = *((_OWORD *)v209 + 9);
            v218 = *((_OWORD *)v209 + 6);
            v549 = *((_OWORD *)v209 + 7);
            v219 = *((_OWORD *)v209 + 1);
            v542 = *(_OWORD *)v209;
            v543 = v219;
            v220 = *((_OWORD *)v209 + 2);
            v221 = *((_OWORD *)v209 + 3);
            v222 = *((_OWORD *)v209 + 5);
            v546 = *((_OWORD *)v209 + 4);
            v547 = v222;
            v545 = v221;
            v544 = v220;
            v550 = v216;
            v551 = v217;
            v548 = v218;
            *((_QWORD *)&v549 + 1) = v214;
            *(_QWORD *)&v542 = v215;
            v223 = glpTypeGetKind(v215);
            v224 = v542;
            v523 = v212;
            if (v223 == 3)
              v224 = glpBankTypeGetElementType(v542);
            v225 = glpABIGetTypeSize(0, v224, 0);
            v226 = glpTypeSizeGetSize(v225);
            StringHash = glpLinkerPoolAlloc(v536);
            *(_QWORD *)StringHash = &v542;
            *(_QWORD *)(StringHash + 8) = 0;
            if ((_DWORD)v24)
            {
              v227 = StringHash;
              v525 = (uint64_t)v211;
              v519 = (_QWORD *)v207;
              v228 = (uint64_t *)v209[1];
              if (v228)
              {
                v229 = glpLayoutObjectFind(v228, 78);
                if (v229)
                  glpIntHashPut(*v535, *((_DWORD *)v229 + 4), -1, v230);
              }
              v231 = v226;
              v232 = (_DWORD *)glpLinkerPoolAlloc(v536);
              v532 = (uint64_t **)glpLinkerPoolAlloc(v536);
              v233 = (unsigned int *)v542;
              if (glpTypeGetKind((unsigned int *)v542) == 3)
                v233 = (unsigned int *)glpBankTypeGetElementType((uint64_t)v233);
              glpTypeGetAppleVec4Types(v233, v232, 1, 0, 0, v532, 0, 0, 0);
              v234 = (uint64_t *)v533[1];
              if (v234)
                v235 = glpLayoutObjectFind(v234, 26);
              else
                v235 = 0;
              v237 = (int *)glpStringHashGet(*(_QWORD *)(v536 + 80), (const char *)v533[2], v533[3]);
              if (v235)
              {
                v237 = (int *)(v235 + 2);
                goto LABEL_233;
              }
              if (v237)
              {
LABEL_233:
                v238 = *v237;
                if (v226)
                {
LABEL_234:
                  v239 = 0;
                  do
                  {
                    if (BitSetGetEquals(*((uint64_t *)&v549 + 1), v239))
                    {
                      v240 = glpLinkerPoolAlloc(v536);
                      *(_OWORD *)v240 = 0u;
                      *(_OWORD *)(v240 + 16) = 0u;
                      glpIntHashPut(*v535, v141, v240, 0.0);
                      if (glpPrimitiveTypeGetScalarCount(v232[v239]))
                      {
                        v241 = 0;
                        do
                        {
                          v242 = *(unsigned int *)(v227 + 8);
                          v243 = v227 + 8 * v242;
                          *(_DWORD *)(v243 + 16) = v141;
                          *(_DWORD *)(v243 + 20) = v241;
                          *(_DWORD *)(v227 + 8) = v242 + 1;
                          *(_DWORD *)v240 |= 1 << v241++;
                        }
                        while (v241 < glpPrimitiveTypeGetScalarCount(v232[v239]));
                      }
                      *(_QWORD *)(v240 + 8) = v533[6] & 0x7F00000001FLL | ((unint64_t)*((unsigned __int8 *)v532
                                                                                             + v239) >> 3);
                      *(_DWORD *)(v240 + 4) = v232[v239];
                      v244 = v536;
                      v245 = (_QWORD *)glpLinkerGetAllocator(v536);
                      v246 = glpCopyLayoutObject(v245, *(_QWORD ***)(v240 + 24));
                      *(_QWORD *)(v240 + 24) = v246;
                      if (!v246)
                      {
                        v247 = glpLinkerGetAllocator(v244);
                        *(_QWORD *)(v240 + 24) = glpMakeLayoutObject(v247);
                      }
                      v248 = glpLinkerGetAllocator(v244);
                      v249 = *(_QWORD **)(v240 + 24);
                      v537 = "-1";
                      v538 = 0xEDA00000002;
                      v539 = 0xFFFFFFFFLL;
                      glpLayoutObjectAppendInteger(v248, 0, (uint64_t)&v537, 0, 0, v249, 33, 0);
                      v250 = glpLinkerGetAllocator(v244);
                      v251 = *(_QWORD **)(v240 + 24);
                      v537 = "-1";
                      v538 = 0xEDA00000002;
                      v539 = 0xFFFFFFFFLL;
                      glpLayoutObjectAppendInteger(v250, 0, (uint64_t)&v537, 0, 0, v251, 34, 27);
                      v252 = glpLinkerGetAllocator(v244);
                      v253 = *(_QWORD **)(v240 + 24);
                      v537 = "-1";
                      v538 = 0xEDA00000002;
                      v539 = 0xFFFFFFFFLL;
                      glpLayoutObjectAppendInteger(v252, 0, (uint64_t)&v537, 0, 0, v253, 45, v238 + v239);
                      ++v141;
                    }
                    ++v239;
                  }
                  while (v239 != v231);
                }
              }
              else
              {
                v238 = 0;
                if (v226)
                  goto LABEL_234;
              }
              v17 = v536;
              v254 = v533;
              v255 = propagateCopyBindings(v536, (uint64_t)v533, v227);
              v256 = (const char *)v525;
              v257 = v523;
              glpStringHashPut(*v526, (const char *)v525, v523, (uint64_t)v255, v258);
              v13 = v531;
              a5 = v529;
              v207 = (unint64_t)v519;
              if (!v520)
              {
                if (glpTypeGetKind((unsigned int *)v542) == 3)
                  v259 = glpBankTypeGetElementCount(v542);
                else
                  v259 = 1;
                *(_DWORD *)(v536 + 272) += *((_DWORD *)v255 + 2) * v259;
                v256 = (const char *)v525;
                v254 = v533;
              }
              v288 = (_QWORD *)glpLinkerPoolAlloc(v17);
              *v288 = 0;
              v288[1] = 0;
              *(_DWORD *)v288 = -1;
              v288[1] = *v254;
              StringHash = glpStringHashPut(*v524, v256, v257, (uint64_t)v288, v289);
            }
            else
            {
              v17 = v536;
            }
            v24 = v527;
          }
        }
      }
LABEL_264:
      if (++v207 >= *(unsigned int *)(v13 + 32))
        break;
      continue;
    }
  }
  if (!a5)
    goto LABEL_419;
  v314 = *v530;
  if (*(_DWORD *)(*v530 + 32))
  {
    v315 = 0;
    v316 = 0;
    do
    {
      v317 = *(_QWORD *)(v314 + 40);
      if (*(_QWORD *)(v317 + v315))
      {
        v318 = *(_DWORD *)(v317 + v315 + 8);
        StringHash = glpIntHashGet(*v535, v318);
        if (!StringHash)
          StringHash = glpIntHashPut(*v535, v318, -1, v319);
      }
      ++v316;
      v315 += 16;
    }
    while (v316 < *(unsigned int *)(v314 + 32));
  }
  v320 = *v535;
  if (*(_DWORD *)(*v535 + 32))
  {
    v321 = 0;
    v322 = 0;
    do
    {
      v323 = *(_QWORD *)(v320 + 40);
      if (*(_QWORD *)(v323 + v321))
      {
        v324 = *(_DWORD *)(v323 + v321 + 8);
        StringHash = glpIntHashGet(*v530, v324);
        if (!StringHash)
          StringHash = glpIntHashPut(*v530, v324, -1, v325);
      }
      ++v322;
      v321 += 16;
    }
    while (v322 < *(unsigned int *)(v320 + 32));
  }
LABEL_317:
  if (a5)
  {
    v513[1] = v513;
    MEMORY[0x24BDAC7A8](StringHash);
    if (v326 >= 0x200)
      v327 = 512;
    else
      v327 = v326;
    v533 = (_QWORD *)((char *)v513 - ((v326 + 15) & 0xFFFFFFFF0));
    bzero(v533, v327);
    v328 = a5;
    v329 = *(unsigned int *)(a5 + 32);
    if ((_DWORD)v329)
    {
      v330 = 0;
      v331 = (uint64_t *)(*(_QWORD *)(v328 + 40) + 16);
      do
      {
        v332 = *(v331 - 2);
        if (v332)
        {
          v333 = *(v331 - 1);
          v334 = *v331;
          if (*v331 < 3
            || (StringHash = strncmp("gl_", (const char *)*(v331 - 1), 3uLL), (_DWORD)StringHash)
            && (v334 < 9
             || (StringHash = strncmp("$ib$", (const char *)v333, 4uLL), (_DWORD)StringHash)
             || (StringHash = strncmp("$gl_", (const char *)(v333 + 5), 4uLL), (_DWORD)StringHash)))
          {
            if (!(_DWORD)v334
              || *(_BYTE *)v333 != 36
              || v334 >= 9
              && (StringHash = strncmp("$ib$", (const char *)v333, 4uLL), !(_DWORD)StringHash)
              && (StringHash = strncmp("$gl_", (const char *)(v333 + 5), 4uLL), !(_DWORD)StringHash)
              || (v334 & 0xFFFFFFFC) != 0
              && *(_BYTE *)(v333 + 1) == 105
              && *(_BYTE *)(v333 + 2) == 98
              && *(_BYTE *)(v333 + 3) == 36)
            {
              v533[v330++] = v332;
            }
          }
        }
        v331 += 4;
        --v329;
      }
      while (v329);
    }
    else
    {
      v330 = 0;
    }
    v335 = v536;
    if (*(_DWORD *)(v536 + 296))
      qsort(v533, v330, 8uLL, (int (__cdecl *)(const void *, const void *))compareVariableObjectsLocationFirstNameSecond);
    v13 = v531;
    if (v330)
    {
      v336 = 0;
      if (v528 == 1)
        v337 = 5;
      else
        v337 = 3;
      LODWORD(v515) = v337;
      v513[0] = v335 + 4 * v528 + 276;
      v338 = v330;
      v525 = v330;
      do
      {
        v339 = v533[v336];
        v340 = *(unsigned int **)(v339 + 120);
        v552 = 0;
        v553[0] = v340;
        v552 = *(unsigned int **)v339;
        v550 = 0u;
        v551 = 0u;
        v548 = 0u;
        v549 = 0u;
        v546 = 0u;
        v547 = 0u;
        v545 = 0u;
        v544 = 0u;
        v543 = 0u;
        v542 = 0u;
        v341 = *(_OWORD *)v339;
        v543 = *(_OWORD *)(v339 + 16);
        v342 = *(_OWORD *)(v339 + 32);
        v343 = *(_OWORD *)(v339 + 48);
        v344 = *(_OWORD *)(v339 + 80);
        v546 = *(_OWORD *)(v339 + 64);
        v547 = v344;
        v545 = v343;
        v544 = v342;
        v345 = *(_OWORD *)(v339 + 96);
        v346 = *(_OWORD *)(v339 + 112);
        v347 = *(_OWORD *)(v339 + 144);
        v550 = *(_OWORD *)(v339 + 128);
        v551 = v347;
        v548 = v345;
        v549 = v346;
        v542 = v341;
        v348 = *(const char **)(v339 + 16);
        v349 = *(_QWORD *)(v339 + 24);
        v350 = *(uint64_t **)(v339 + 8);
        if (v350)
        {
          v351 = glpLayoutObjectFind(v350, 79);
          if (!v13)
            goto LABEL_367;
        }
        else
        {
          v351 = 0;
          if (!v13)
            goto LABEL_367;
        }
        if (!*(_DWORD *)(v335 + 296))
        {
          v352 = inputForOutput(v13, (uint64_t)v348, v349);
          if (v352)
          {
            v353 = v352;
            v541 = *(_QWORD *)(v352 + 120);
            v540 = *(unsigned int **)v352;
            v354 = getInputOutputBitsType(v335, v534, v352, &v541, &v540, v528, (uint64_t *)v553, &v552);
            StringHash = (uint64_t)v552;
            *((unsigned int **)&v549 + 1) = v553[0];
            *(_QWORD *)&v542 = v552;
            if ((_DWORD)v24)
              v355 = v354 == 0;
            else
              v355 = 1;
            v24 = !v355;
            if (!v354)
              goto LABEL_405;
            v356 = glpTypesEqual(v552, (uint64_t)v540);
            v527 = v351;
            if (!v356 || ((*(_QWORD *)(v353 + 48) ^ *(_QWORD *)(v339 + 48)) & 0x6F000000000) != 0)
            {
              v357 = glpLinkerGetInfoLog(v335);
              v358 = glpLanguageToString(v534);
              glpLanguageToString(v528);
              v537 = "-1";
              v538 = 0xEDA00000002;
              v539 = 0xFFFFFFFFLL;
              v13 = v531;
              v511 = v358;
              v335 = v536;
              v359 = (uint64_t **)v357;
              v338 = v525;
              glpLogMessage(v359, 0, (uint64_t)&v537, "Input of %s shader '%.*s' differs in type/qualifiers to that written by %s shader", v360, v361, v362, v363, v511);
              goto LABEL_365;
            }
            if ((v24 & 1) != 0)
            {
              SizeInBits = BitSetGetSizeInBits(*((uint64_t *)&v549 + 1));
              if (SizeInBits < BitSetGetSizeInBits(v541))
              {
                v416 = glpLinkerGetAllocator(v335);
                v417 = BitSetGetSizeInBits(v541);
                v418 = BitSetNewWithAllocator(v417, *(_QWORD *)v416, *(uint64_t (**)(uint64_t, uint64_t, const char *))(v416 + 8), *(_QWORD *)(v416 + 16), *(_QWORD *)(v416 + 24));
                if (BitSetGetSizeInBits(*((uint64_t *)&v549 + 1)))
                {
                  v419 = 0;
                  do
                  {
                    if (BitSetGetEquals(*((uint64_t *)&v549 + 1), v419))
                      BitSetSetEquals(v418, v419);
                    ++v419;
                  }
                  while (v419 < BitSetGetSizeInBits(*((uint64_t *)&v549 + 1)));
                }
                *((_QWORD *)&v549 + 1) = v418;
                *(_QWORD *)(v339 + 120) = v418;
                v335 = v536;
              }
              BitSetAndEquals(*((uint64_t *)&v549 + 1), v541);
              v420 = BitSetEqualsTest(*((uint64_t *)&v549 + 1), v541);
              v338 = v525;
              if (!v420)
              {
                v421 = glpLinkerGetInfoLog(v335);
                v422 = glpLanguageToString(v534);
                glpLanguageToString(v528);
                v537 = "-1";
                v538 = 0xEDA00000002;
                v539 = 0xFFFFFFFFLL;
                v13 = v531;
                v512 = v422;
                v335 = v536;
                v423 = (uint64_t **)v421;
                v338 = v525;
                glpLogMessage(v423, 0, (uint64_t)&v537, "Input of %s shader '%.*s' not properly written by %s shader", v424, v425, v426, v427, v512);
                goto LABEL_365;
              }
            }
            else
            {
LABEL_365:
              v24 = 0;
            }
            v364 = 1;
            goto LABEL_369;
          }
        }
LABEL_367:
        v527 = v351;
        v364 = 0;
        v353 = 0;
        if (glpTypeGetKind((unsigned int *)v542) == 3)
          *(_QWORD *)&v542 = glpBankTypeGetElementType(v542);
LABEL_369:
        StringHash = *(_QWORD *)(v339 + 8);
        if (StringHash && (StringHash = (uint64_t)glpLayoutObjectFind((uint64_t *)StringHash, 9)) != 0)
          v365 = *(_DWORD *)(StringHash + 16);
        else
          v365 = 0;
        if (*(_DWORD *)(v335 + 296))
          v366 = 1;
        else
          v366 = v364;
        if ((v366 & 1) != 0)
        {
          if (v365 || !(_DWORD)v24)
            goto LABEL_405;
          v367 = glpABIGetTypeSize(0, v542, 0);
          glpTypeSizeGetSize(v367);
          v368 = glpLinkerPoolAlloc(v335);
          *(_QWORD *)v368 = 0;
          *(_QWORD *)(v368 + 8) = 0;
          v520 = v368;
          *(_QWORD *)v368 = &v542;
          v517 = *(_QWORD *)(v339 + 48);
          v369 = (uint64_t *)(v517 & 0x7F00000001FLL);
          v519 = (_QWORD *)(v517 & 0x7F00000001FLL);
          if (v364)
            v369 = (uint64_t *)(*(_QWORD *)(v353 + 48) & 0x7F00000001FLL);
          v518 = v369;
          v370 = *(uint64_t **)(v339 + 8);
          LODWORD(v532) = v24;
          if (v370 && (v371 = glpLayoutObjectFind(v370, 26)) != 0)
          {
            LODWORD(v516) = 0;
            v514 = v371;
            v372 = remapSlotToCode[*((int *)v371 + 4)];
            v373 = (char *)&v548 + 8;
          }
          else
          {
            v514 = 0;
            LODWORD(v523) = -1;
            v372 = 1;
            v373 = (char *)&v545;
          }
          *((_DWORD *)v373 - 64) = v372;
          v380 = glpLinkerGetAllocator(v335);
          LayoutObject = glpMakeLayoutObject(v380);
          v382 = glpLinkerGetAllocator(v335);
          v537 = "-1";
          v538 = 0xEDA00000002;
          v539 = 0xFFFFFFFFLL;
          glpLayoutObjectAppendInteger(v382, 0, (uint64_t)&v537, 0, 0, LayoutObject, 33, (int)v515);
          v383 = glpLinkerGetAllocator(v335);
          v537 = "-1";
          v538 = 0xEDA00000002;
          v539 = 0xFFFFFFFFLL;
          glpLayoutObjectAppendInteger(v383, 0, (uint64_t)&v537, 0, 0, LayoutObject, 68, 17);
          v384 = glpLinkerGetAllocator(v335);
          v537 = "-1";
          v538 = 0xEDA00000002;
          v539 = 0xFFFFFFFFLL;
          glpLayoutObjectAppendInteger(v384, 0, (uint64_t)&v537, 0, 0, LayoutObject, 69, 0);
          v385 = glpLinkerGetAllocator(v335);
          v537 = "-1";
          v538 = 0xEDA00000002;
          v539 = 0xFFFFFFFFLL;
          glpLayoutObjectAppendInteger(v385, 0, (uint64_t)&v537, 0, 0, LayoutObject, 70, 1);
          v386 = glpLinkerGetAllocator(v335);
          v387 = glpMakeLayoutObject(v386);
          v388 = glpLinkerGetAllocator(v335);
          v537 = "-1";
          v538 = 0xEDA00000002;
          v539 = 0xFFFFFFFFLL;
          glpLayoutObjectAppendInteger(v388, 0, (uint64_t)&v537, 0, 0, v387, 33, 0);
          v389 = glpLinkerGetAllocator(v335);
          v537 = "-1";
          v538 = 0xEDA00000002;
          v539 = 0xFFFFFFFFLL;
          glpLayoutObjectAppendInteger(v389, 0, (uint64_t)&v537, 0, 0, v387, 34, 28);
          v390 = glpLinkerGetAllocator(v335);
          v537 = "-1";
          v538 = 0xEDA00000002;
          v539 = 0xFFFFFFFFLL;
          glpLayoutObjectAppendInteger(v390, 0, (uint64_t)&v537, 0, 0, v387, 35, 0);
          v391 = glpLinkerGetAllocator(v335);
          v537 = "-1";
          v538 = 0xEDA00000002;
          v539 = 0xFFFFFFFFLL;
          glpLayoutObjectAppendInteger(v391, 0, (uint64_t)&v537, 0, 0, v387, 38, 1);
          v392 = 0;
          v393 = v364 ^ 1;
          if (!v535)
            v393 = 1;
          if ((v393 & 1) == 0)
            v392 = *v535;
          v394 = (uint64_t **)v520;
          v395 = allocateSlotsWithGLPType(v536, *v530, v392, (uint64_t **)v520, (uint64_t)v518, (unint64_t)v519, LayoutObject, (_QWORD **)v387, v523, glpBuiltInConstantValues[8 * (*(_BYTE *)(v536 + 60) == 4) + 2]);
          v397 = v395;
          v24 = v532;
          v398 = v527;
          if (v528 == 1)
          {
            if (v395)
            {
              v399 = glpIntHashGet(*v530, v523);
              if (v399)
                *(_QWORD *)(v339 + 8) = *(_QWORD *)(v399 + 24);
            }
          }
          v13 = v531;
          if (!v398)
            *(_DWORD *)v513[0] += *((_DWORD *)v394 + 2);
          v400 = v536;
          if (!v397)
          {
            v401 = (uint64_t **)glpLinkerGetInfoLog(v536);
            v402 = 4 * glpBuiltInConstantValues[8 * (*(_BYTE *)(v400 + 60) == 4) + 2];
            v537 = "-1";
            v538 = 0xEDA00000002;
            v539 = 0xFFFFFFFFLL;
            glpLogMessage(v401, 0, (uint64_t)&v537, "Implementation limit of %d %s components exceeded. Unable to allocate '%.*s'.", v403, v404, v405, v406, v402);
            v24 = 0;
            if ((v516 & 1) == 0)
            {
              v407 = (uint64_t **)glpLinkerGetInfoLog(v400);
              v408 = *((_DWORD *)v514 + 4);
              v537 = "-1";
              v538 = 0xEDA00000002;
              v539 = 0xFFFFFFFFLL;
              glpLogMessage(v407, 0, (uint64_t)&v537, "Or active varying aliasing. One or more slots starting at %d unavailable for '%.*s' from layout location request.", v409, v410, v411, v412, v408);
              v24 = 0;
            }
          }
          *v394 = (uint64_t *)v339;
          glpStringHashPut(*v521, v348, v349, (uint64_t)v394, v396);
          v413 = (_QWORD *)glpLinkerPoolAlloc(v400);
          *v413 = 0;
          v413[1] = 0;
          *(_DWORD *)v413 = -1;
          v413[1] = *(_QWORD *)v339;
          StringHash = glpStringHashPut(*v522, v348, v349, (uint64_t)v413, v414);
          v335 = v400;
        }
        else
        {
          if (*(_BYTE *)(v339 + 112) || v365)
            goto LABEL_405;
          v374 = (uint64_t **)glpLinkerGetInfoLog(v335);
          v379 = glpLanguageToString(v528);
          if (v13)
            glpLanguageToString(v534);
          v537 = "-1";
          v538 = 0xEDA00000002;
          v539 = 0xFFFFFFFFLL;
          StringHash = (uint64_t)glpLogMessage(v374, 1u, (uint64_t)&v537, "Output of %s shader '%.*s' not read by %s %s", v375, v376, v377, v378, v379);
          v335 = v536;
        }
        v338 = v525;
LABEL_405:
        ++v336;
      }
      while (v336 != v338);
    }
    a5 = v529;
  }
  if (v13)
  {
LABEL_419:
    v519 = v513;
    MEMORY[0x24BDAC7A8](StringHash);
    v429 = (char *)v513 - ((v428 + 15) & 0xFFFFFFFF0);
    if (v428 >= 0x200)
      v430 = 512;
    else
      v430 = v428;
    bzero((char *)v513 - ((v428 + 15) & 0xFFFFFFFF0), v430);
    v431 = v13;
    v432 = *(unsigned int *)(v13 + 32);
    if ((_DWORD)v432)
    {
      LODWORD(v433) = 0;
      v434 = (uint64_t *)(*(_QWORD *)(v431 + 40) + 16);
      while (1)
      {
        v435 = *(v434 - 2);
        if (v435)
        {
          v436 = v24;
          v437 = *(v434 - 1);
          v438 = *v434;
          if (*v434 < 3
            || strncmp("gl_", (const char *)*(v434 - 1), 3uLL)
            && (v438 < 9
             || strncmp("$ib$", (const char *)v437, 4uLL)
             || strncmp("$gl_", (const char *)(v437 + 5), 4uLL)))
          {
            if (!(_DWORD)v438
              || *(_BYTE *)v437 != 36
              || v438 >= 9
              && !strncmp("$ib$", (const char *)v437, 4uLL)
              && !strncmp("$gl_", (const char *)(v437 + 5), 4uLL))
            {
              goto LABEL_440;
            }
            if ((v438 & 0xFFFFFFFC) != 0)
            {
              v24 = v436;
              if (*(_BYTE *)(v437 + 1) != 105 || *(_BYTE *)(v437 + 2) != 98)
                goto LABEL_443;
              if (*(_BYTE *)(v437 + 3) == 36)
              {
LABEL_440:
                if (v534 != 4 || (*(_BYTE *)(v435 + 51) & 0x40) == 0)
                {
                  *(_QWORD *)&v429[8 * v433] = v435;
                  LODWORD(v433) = v433 + 1;
                }
              }
            }
          }
          v24 = v436;
        }
LABEL_443:
        v434 += 4;
        if (!--v432)
          goto LABEL_446;
      }
    }
    LODWORD(v433) = 0;
LABEL_446:
    v439 = v536;
    if (*(_DWORD *)(v536 + 296))
      qsort(v429, v433, 8uLL, (int (__cdecl *)(const void *, const void *))compareVariableObjectsLocationFirstNameSecond);
    v13 = v531;
    v440 = v524;
    if ((_DWORD)v433)
    {
      v433 = v433;
      v520 = v439 + 4 * v534 + 256;
      while (1)
      {
        v441 = *(_QWORD *)v429;
        v443 = *(const char **)(*(_QWORD *)v429 + 16);
        v442 = *(_QWORD *)(*(_QWORD *)v429 + 24);
        v444 = *(uint64_t **)(*(_QWORD *)v429 + 8);
        if (v444)
          v533 = glpLayoutObjectFind(v444, 79);
        else
          v533 = 0;
        if (!*(_DWORD *)(v439 + 296))
        {
          if (v529)
          {
            v448 = outputForInput(*v522, (uint64_t)v443, v442);
            if (v448)
            {
              if ((_DWORD)v24)
              {
                glpStringHashPut(*v440, v443, v442, v448, v449);
                v450 = outputForInput(*v521, (uint64_t)v443, v442);
                v451 = propagateCopyBindings(v439, v441, v450);
                glpStringHashPut(*v526, v443, v442, (uint64_t)v451, v452);
                if (!v533)
                  *(_DWORD *)v520 += *((_DWORD *)v451 + 2);
              }
              goto LABEL_480;
            }
          }
          v486 = (uint64_t **)glpLinkerGetInfoLog(v439);
          v491 = glpLanguageToString(v534);
          if (v529)
            glpLanguageToString(v528);
          *(_QWORD *)&v542 = "-1";
          *((_QWORD *)&v542 + 1) = 0xEDA00000002;
          *(_QWORD *)&v543 = 0xFFFFFFFFLL;
          glpLogMessage(v486, 0, (uint64_t)&v542, "Input of %s shader '%.*s' not written by %s %s", v487, v488, v489, v490, v491);
          v24 = 0;
          goto LABEL_479;
        }
        v445 = *(unsigned int **)(v441 + 120);
        v553[0] = v445;
        v446 = *(unsigned int **)v441;
        v552 = *(unsigned int **)v441;
        if ((_DWORD)v24)
        {
          v447 = getInputOutputBitsType(v439, v534, v441, v553, &v552, 5, 0, 0) != 0;
          v446 = v552;
          v445 = v553[0];
        }
        else
        {
          v447 = 0;
        }
        v550 = 0u;
        v551 = 0u;
        v548 = 0u;
        v549 = 0u;
        v546 = 0u;
        v547 = 0u;
        v545 = 0u;
        v544 = 0u;
        v543 = 0u;
        v542 = 0u;
        v453 = *(_OWORD *)(v441 + 128);
        v454 = *(_OWORD *)(v441 + 144);
        v455 = *(_OWORD *)(v441 + 96);
        v549 = *(_OWORD *)(v441 + 112);
        v456 = *(_OWORD *)(v441 + 16);
        v542 = *(_OWORD *)v441;
        v543 = v456;
        v457 = *(_OWORD *)(v441 + 32);
        v458 = *(_OWORD *)(v441 + 48);
        v459 = *(_OWORD *)(v441 + 80);
        v546 = *(_OWORD *)(v441 + 64);
        v547 = v459;
        v545 = v458;
        v544 = v457;
        v550 = v453;
        v551 = v454;
        v548 = v455;
        *((_QWORD *)&v549 + 1) = v445;
        *(_QWORD *)&v542 = v446;
        v460 = glpTypeGetKind(v446);
        v461 = v542;
        if (v460 == 3)
          v461 = glpBankTypeGetElementType(v542);
        v532 = (uint64_t **)v443;
        v462 = glpABIGetTypeSize(0, v461, 0);
        glpTypeSizeGetSize(v462);
        v463 = glpLinkerPoolAlloc(v439);
        *(_QWORD *)v463 = 0;
        *(_QWORD *)(v463 + 8) = 0;
        *(_QWORD *)v463 = &v542;
        v464 = *(_QWORD *)(v441 + 48);
        v465 = *(uint64_t **)(v441 + 8);
        if (!v465)
          break;
        v466 = glpLayoutObjectFind(v465, 26);
        v467 = v466;
        if (!v466)
          goto LABEL_469;
        v468 = 0;
        v469 = remapSlotToCode[*((int *)v466 + 4)];
        if (v447)
          goto LABEL_470;
LABEL_467:
        v24 = 0;
        v13 = v531;
LABEL_479:
        v439 = v536;
LABEL_480:
        v429 += 8;
        if (!--v433)
          goto LABEL_481;
      }
      v467 = 0;
LABEL_469:
      v469 = -1;
      v468 = 1;
      if (v447)
      {
LABEL_470:
        LODWORD(v525) = v468;
        v530 = (uint64_t *)v442;
        LODWORD(v527) = v469;
        v523 = v464;
        v470 = v464 & 0x7F00000001FLL;
        v471 = v536;
        v472 = glpLinkerGetAllocator(v536);
        v473 = glpMakeLayoutObject(v472);
        v474 = glpLinkerGetAllocator(v471);
        v537 = "-1";
        v538 = 0xEDA00000002;
        v539 = 0xFFFFFFFFLL;
        glpLayoutObjectAppendInteger(v474, 0, (uint64_t)&v537, 0, 0, v473, 33, 0);
        v475 = glpLinkerGetAllocator(v471);
        v537 = "-1";
        v538 = 0xEDA00000002;
        v539 = 0xFFFFFFFFLL;
        glpLayoutObjectAppendInteger(v475, 0, (uint64_t)&v537, 0, 0, v473, 34, 28);
        v476 = glpLinkerGetAllocator(v471);
        v537 = "-1";
        v538 = 0xEDA00000002;
        v539 = 0xFFFFFFFFLL;
        glpLayoutObjectAppendInteger(v476, 0, (uint64_t)&v537, 0, 0, v473, 35, 0);
        v477 = glpLinkerGetAllocator(v471);
        v537 = "-1";
        v538 = 0xEDA00000002;
        v539 = 0xFFFFFFFFLL;
        glpLayoutObjectAppendInteger(v477, 0, (uint64_t)&v537, 0, 0, v473, 38, 1);
        v478 = allocateSlotsWithGLPType(v471, 0, *v535, (uint64_t **)v463, v470, v470, 0, (_QWORD **)v473, (int)v527, glpBuiltInConstantValues[8 * (*(_BYTE *)(v471 + 60) == 4) + 2]);
        if (!v533)
          *(_DWORD *)v520 += *(_DWORD *)(v463 + 8);
        v13 = v531;
        v440 = v524;
        v479 = (uint64_t)v530;
        if (v478)
        {
          v480 = v463;
          v439 = v536;
          v481 = propagateCopyBindings(v536, v441, v480);
          v482 = (const char *)v532;
          glpStringHashPut(*v526, (const char *)v532, v479, (uint64_t)v481, v483);
          v484 = (_QWORD *)glpLinkerPoolAlloc(v439);
          *v484 = 0;
          v484[1] = 0;
          *(_DWORD *)v484 = -1;
          v484[1] = *(_QWORD *)v441;
          glpStringHashPut(*v440, v482, v479, (uint64_t)v484, v485);
          v24 = 1;
        }
        else
        {
          v439 = v536;
          v492 = (uint64_t **)glpLinkerGetInfoLog(v536);
          v493 = 4 * glpBuiltInConstantValues[8 * (*(_BYTE *)(v439 + 60) == 4) + 2];
          v537 = "-1";
          v538 = 0xEDA00000002;
          v539 = 0xFFFFFFFFLL;
          glpLogMessage(v492, 0, (uint64_t)&v537, "Implementation limit of %d %s components exceeded. Unable to allocate '%.*s'.", v494, v495, v496, v497, v493);
          v24 = 0;
          if ((v525 & 1) == 0)
          {
            v498 = (uint64_t **)glpLinkerGetInfoLog(v439);
            v499 = *((_DWORD *)v467 + 4);
            v537 = "-1";
            v538 = 0xEDA00000002;
            v539 = 0xFFFFFFFFLL;
            glpLogMessage(v498, 0, (uint64_t)&v537, "Or active varying aliasing. One or more slots starting at %d unavailable for '%.*s' from layout location request.", v500, v501, v502, v503, v499);
            v24 = 0;
          }
        }
        goto LABEL_480;
      }
      goto LABEL_467;
    }
LABEL_481:
    a5 = v529;
  }
  if (v528 != 1)
  {
    if (a5)
    {
      v504 = *(unsigned int *)(*v521 + 32);
      if ((_DWORD)v504)
      {
        v505 = *(_QWORD *)(*v521 + 40);
        do
        {
          if (*(_QWORD *)v505)
            *(_QWORD *)(**(_QWORD **)v505 + 8) = 0;
          v505 += 32;
          --v504;
        }
        while (v504);
      }
    }
  }
  if (v13)
  {
    v506 = *(unsigned int *)(*v526 + 32);
    if ((_DWORD)v506)
    {
      v507 = *(uint64_t ***)(*v526 + 40);
      do
      {
        if (*v507)
        {
          v508 = **v507;
          if (v534 != 4 || (*(_QWORD *)(v508 + 48) & 0x40000000) == 0)
            *(_QWORD *)(v508 + 8) = 0;
        }
        v507 += 4;
        --v506;
      }
      while (v506);
    }
  }
  return v24;
}

uint64_t inputForOutput(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  char *v6;
  const void *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  _QWORD v12[2];

  v3 = a3;
  v12[1] = *MEMORY[0x24BDAC8D0];
  if ((a3 & 0xFFFFFFFC) == 0
    || *(_BYTE *)a2 != 36
    || *(_BYTE *)(a2 + 1) != 105
    || *(_BYTE *)(a2 + 2) != 98
    || *(_BYTE *)(a2 + 3) != 36)
  {
    return glpStringHashGet(a1, (const char *)a2, a3);
  }
  v5 = a3;
  MEMORY[0x24BDAC7A8](a1);
  v6 = (char *)v12 - ((v5 + 15) & 0x1FFFFFFF0);
  memcpy(v6, v7, v3);
  v6[4] = 105;
  v8 = v3 >> 5;
  if (v3 >> 5 >= v3)
  {
    v10 = v3;
  }
  else
  {
    v9 = ~(v3 >> 5);
    LODWORD(v10) = v3;
    do
    {
      v10 = (32 * (_DWORD)v10 + (v10 >> 2) + v6[(v3 - 1)]) ^ v10;
      LODWORD(v3) = v3 + v9;
    }
    while (v3 > v8);
  }
  return glpStringHashGet(a1, (const char *)v12 - ((v5 + 15) & 0x1FFFFFFF0), v5 | (v10 << 32));
}

uint64_t getInputOutputBitsType(uint64_t a1, unsigned int a2, uint64_t a3, _QWORD *a4, unsigned int **a5, int a6, uint64_t *a7, unsigned int **a8)
{
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  const char *v18;
  int v19;
  int v20;
  uint64_t **v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t **InfoLog;
  char v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int Kind;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v42;
  uint64_t v43;
  uint64_t v44;

  if (a7)
    v15 = *a7;
  else
    v15 = 0;
  if (a2 - 1 > 2)
    return 1;
  v40 = v15;
  v16 = *a5;
  if (glpTypeGetKind(*a5) != 3)
  {
    v17 = *(_DWORD *)(a3 + 24);
    if (v17 >= 3)
    {
      v18 = *(const char **)(a3 + 16);
      if (!strncmp("gl_", v18, 3uLL) || v17 >= 9 && !strncmp("$ib$", v18, 4uLL) && !strncmp("$gl_", v18 + 5, 4uLL))
        return 1;
    }
  }
  if ((*(_BYTE *)(a3 + 53) & 2) != 0)
    return 1;
  if (a2 != 3)
  {
    v20 = 32;
    goto LABEL_18;
  }
  v19 = *(_DWORD *)(a1 + 308);
  if (v19 > 3)
  {
    if (v19 == 4)
    {
      v20 = 3;
      goto LABEL_18;
    }
    if (v19 == 10)
    {
      v20 = 4;
      goto LABEL_18;
    }
LABEL_40:
    v20 = 6;
    goto LABEL_18;
  }
  if (!v19)
  {
    v20 = 1;
    goto LABEL_18;
  }
  if (v19 != 1)
    goto LABEL_40;
  v20 = 2;
LABEL_18:
  if (glpTypeGetKind(v16) != 3)
  {
    InfoLog = (uint64_t **)glpLinkerGetInfoLog(a1);
    v28 = glpLanguageToString(a2);
    v42 = "-1";
    v43 = 0xEDA00000002;
    v44 = 0xFFFFFFFFLL;
    glpLogMessage(InfoLog, 0, (uint64_t)&v42, "Input of %s shader '%.*s' not an array", v29, v30, v31, v32, v28);
    return 0;
  }
  if (glpBankTypeGetElementCount((uint64_t)v16) != v20
    && glpBankTypeGetElementCount((uint64_t)v16) != -1)
  {
    v21 = (uint64_t **)glpLinkerGetInfoLog(a1);
    if (a2 == 3)
    {
      v22 = glpLanguageToString(3u);
      v42 = "-1";
      v43 = 0xEDA00000002;
      v44 = 0xFFFFFFFFLL;
      glpBankTypeGetElementCount((uint64_t)v16);
      glpLogMessage(v21, 0, (uint64_t)&v42, "Input of %s shader '%.*s' must be an array, with size matching input type (input type expects %u, got %u)", v23, v24, v25, v26, v22);
    }
    else
    {
      v35 = glpLanguageToString(a2);
      v42 = "-1";
      v43 = 0xEDA00000002;
      v44 = 0xFFFFFFFFLL;
      glpBankTypeGetElementCount((uint64_t)v16);
      glpLogMessage(v21, 0, (uint64_t)&v42, "Input of %s shader '%.*s' must be an array, with size matching gl_MaxPatchVertices (expected %u, got %u)", v36, v37, v38, v39, v35);
    }
    return 0;
  }
  *a5 = (unsigned int *)glpBankTypeGetElementType((uint64_t)v16);
  if (a8)
  {
    Kind = glpTypeGetKind(*a8);
    if (a6 == 1 && Kind == 3)
      *a8 = (unsigned int *)glpBankTypeGetElementType((uint64_t)*a8);
  }
  if (a4)
    *a4 = *(_QWORD *)(a3 + 120);
  if (a7)
    *a7 = v40;
  return 1;
}

uint64_t allocateSlotsWithGLPType(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4, uint64_t a5, unint64_t a6, uint64_t *a7, _QWORD **a8, int a9, unsigned int a10)
{
  unsigned int v16;
  unsigned int Size;
  _DWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _BOOL8 v23;
  unint64_t v24;
  int *v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  int v32;
  BOOL v33;
  char v34;
  int v35;
  int ScalarType;
  int v37;
  uint64_t *v38;
  int v39;
  int v40;
  int *v41;
  int v42;
  unsigned int v43;
  uint64_t v44;
  unsigned int *v45;
  int v46;
  int v47;
  int v48;
  int v49;
  uint64_t *v50;
  BOOL v51;
  char v52;
  unsigned int v53;
  int *v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  int v62;
  int v63;
  int *v64;
  unsigned int v65;
  int v66;
  uint64_t v67;
  unsigned int *v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  unsigned int ScalarCount;
  unint64_t v75;
  _DWORD *v76;
  _DWORD *v77;
  _DWORD *v78;
  int v79;
  uint64_t v80;
  int v81;
  int v82;
  uint64_t v83;
  int v84;
  unint64_t v86;
  _BYTE *v87;
  _DWORD *v88;
  uint64_t v89;
  uint64_t v91;
  uint64_t v92;
  uint64_t v94;
  unsigned int *v95;
  int Equals;
  int v97;
  unint64_t v98;
  unint64_t v99;
  unsigned int v100;
  int v101;

  v16 = glpABIGetTypeSize(0, **a4, 0);
  Size = glpTypeSizeGetSize(v16);
  v18 = (_DWORD *)glpLinkerPoolAlloc(a1);
  v94 = a1;
  v91 = Size;
  v95 = (unsigned int *)a4;
  v87 = (_BYTE *)glpLinkerPoolAlloc(a1);
  v88 = v18;
  glpTypeGetAppleVec4Types((unsigned int *)**a4, v18, 1, 0, 0, v87, 0, 0, 0);
  v89 = a5;
  if ((a5 & 0x1Fu) >= (a6 & 0x1F))
    v19 = a6;
  else
    v19 = a6 & 0xFFFFFFFFFFFFFFE0 | a5 & 0x1F;
  if (!Size)
    return 1;
  v20 = 0;
  v21 = a10;
  v86 = v19;
  v101 = (v19 >> 11) & 0x40000000;
  v23 = 1;
  do
  {
    Equals = BitSetGetEquals(*(_QWORD *)(*(_QWORD *)v95 + 120), v20);
    if ((Equals || *(_DWORD *)(v94 + 296)) && v23)
    {
      v24 = v87[v20];
      v98 = v86 | (v24 >> 3);
      v99 = v89 | (v24 >> 3);
      v100 = v88[v20];
      v97 = a9;
      v92 = v20;
      if (!(_DWORD)v21)
        goto LABEL_45;
      v25 = &remapSlotToCode;
      while (1)
      {
        v27 = *v25++;
        v26 = v27;
        v28 = v27 | v101;
        if (a2)
        {
          v29 = glpIntHashGet(a2, v28);
          if (a3)
            goto LABEL_13;
        }
        else
        {
          v29 = 0;
          if (a3)
          {
LABEL_13:
            v30 = glpIntHashGet(a3, v28);
            goto LABEL_16;
          }
        }
        v30 = 0;
LABEL_16:
        if (v29)
          v31 = (int *)v29;
        else
          v31 = (int *)v30;
        if (v31 != (int *)-1)
        {
          if (v31)
          {
            v32 = *v31;
            v33 = a9 == -1 || v28 == a9;
            v34 = v33;
            if (!v32 && (v34 & 1) != 0)
            {
LABEL_34:
              v21 = a10;
              if (!(v29 | v30))
              {
                if (a2)
                {
                  v29 = glpLinkerPoolAlloc(v94);
                  *(_OWORD *)v29 = 0u;
                  *(_OWORD *)(v29 + 16) = 0u;
                  glpIntHashPut(a2, v28, v29, 0.0);
                  if (!a3)
                  {
                    if (v29)
                    {
                      v30 = 0;
                      goto LABEL_43;
                    }
LABEL_45:
                    LODWORD(v30) = 0;
LABEL_46:
                    v35 = a9;
                    v38 = a7;
                    if (!a7)
                    {
LABEL_69:
                      v51 = 0;
                      goto LABEL_70;
                    }
                    goto LABEL_67;
                  }
                }
                else
                {
                  if (!a3)
                    goto LABEL_45;
                  v29 = 0;
                }
                v30 = glpLinkerPoolAlloc(v94);
                *(_OWORD *)v30 = 0u;
                *(_OWORD *)(v30 + 16) = 0u;
                glpIntHashPut(a3, v28, v30, 0.0);
              }
              if (v29)
              {
LABEL_43:
                *(_QWORD *)(v29 + 8) = v98;
                ScalarType = glpPrimitiveTypeGetScalarType(v100);
                *(_DWORD *)(v29 + 4) = glpGetVectorType(ScalarType, 4);
                *(_QWORD *)(v29 + 24) = offsetLayout(v94, (_QWORD **)a7, v26);
                if (!v30)
                {
                  v37 = 0;
                  goto LABEL_51;
                }
              }
              else
              {
                if (!v30)
                  goto LABEL_46;
                v29 = 0;
              }
              *(_QWORD *)(v30 + 8) = v99;
              v39 = glpPrimitiveTypeGetScalarType(v100);
              *(_DWORD *)(v30 + 4) = glpGetVectorType(v39, 4);
              *(_QWORD *)(v30 + 24) = offsetLayout(v94, a8, v26);
              v37 = 1;
              if (v29)
              {
LABEL_51:
                v40 = 1;
                v41 = (int *)v29;
              }
              else
              {
                v40 = 0;
                v41 = (int *)v30;
              }
              v42 = *v41;
              if (glpPrimitiveTypeGetScalarCount(v100))
              {
                v43 = 0;
                do
                {
                  if (Equals)
                  {
                    v44 = v95[2];
                    v45 = &v95[2 * v44];
                    v45[4] = v28;
                    v45[5] = v43;
                    v95[2] = v44 + 1;
                  }
                  v42 |= 1 << v43;
                  if (v40)
                  {
                    *(_DWORD *)v29 = v42;
                    v46 = glpPrimitiveTypeGetScalarType(*(unsigned int *)(v29 + 4));
                    v47 = componentCountForSet(*(_DWORD *)v29);
                    *(_DWORD *)(v29 + 4) = glpGetVectorType(v46, v47);
                  }
                  if (v37)
                  {
                    *(_DWORD *)v30 = v42;
                    v48 = glpPrimitiveTypeGetScalarType(*(unsigned int *)(v30 + 4));
                    v49 = componentCountForSet(*(_DWORD *)v30);
                    *(_DWORD *)(v30 + 4) = glpGetVectorType(v48, v49);
                  }
                  ++v43;
                }
                while (v43 < glpPrimitiveTypeGetScalarCount(v100));
              }
              a9 = v97;
              if (v97 == -1)
                v35 = -1;
              else
                v35 = v97 + 1;
              LODWORD(v30) = 1;
LABEL_66:
              v38 = a7;
              v21 = a10;
              if (!a7)
                goto LABEL_69;
LABEL_67:
              v50 = glpLayoutObjectFind(v38, 33);
              if (!v50)
                goto LABEL_69;
              v51 = *((_DWORD *)v50 + 4) == 5;
LABEL_70:
              if (*(_DWORD *)(v94 + 296))
                v52 = 1;
              else
                v52 = v30;
              if ((v52 & 1) != 0 || v51 || v35 != -1 || glpPrimitiveTypeGetScalarType(v100) == 62)
                goto LABEL_133;
              if (!glpPrimitiveTypeGetScalarCount(v100))
              {
                LODWORD(v30) = 1;
                goto LABEL_133;
              }
              v53 = 0;
LABEL_79:
              if (!(_DWORD)v21)
                goto LABEL_118;
              v54 = &remapSlotToCode;
LABEL_81:
              v56 = *v54++;
              v55 = v56;
              v57 = v56 | v101;
              if (a2)
              {
                v58 = glpIntHashGet(a2, v57);
                if (a3)
                  goto LABEL_83;
LABEL_85:
                v59 = 0;
              }
              else
              {
                v58 = 0;
                if (!a3)
                  goto LABEL_85;
LABEL_83:
                v59 = glpIntHashGet(a3, v57);
              }
              if (v58)
                v60 = v58;
              else
                v60 = v59;
              if (v60 != -1)
              {
                if (!v60)
                  goto LABEL_103;
                if (*(_DWORD *)v60 != 15)
                {
                  if (!*(_DWORD *)v60)
                    goto LABEL_103;
                  v61 = v98;
                  if (!v58)
                    v61 = v99;
                  if (*(_QWORD *)(v60 + 8) == v61)
                  {
                    v62 = glpPrimitiveTypeGetScalarType(*(unsigned int *)(v60 + 4));
                    v33 = v62 == glpPrimitiveTypeGetScalarType(v100);
                    a9 = v97;
                    if (v33)
                    {
                      if (!v58 || !v59)
                      {
LABEL_103:
                        v21 = a10;
                        if (v58 | v59)
                          goto LABEL_107;
                        if (!a2)
                        {
                          v58 = 0;
                          if (!a3)
                            goto LABEL_130;
LABEL_106:
                          v59 = glpLinkerPoolAlloc(v94);
                          *(_OWORD *)v59 = 0u;
                          *(_OWORD *)(v59 + 16) = 0u;
                          glpIntHashPut(a3, v57, v59, 0.0);
LABEL_107:
                          if (!v58)
                            goto LABEL_109;
LABEL_108:
                          *(_QWORD *)(v58 + 8) = v98;
                          *(_DWORD *)(v58 + 4) = glpPrimitiveTypeGetScalarType(v100);
                          *(_QWORD *)(v58 + 24) = offsetLayout(v94, (_QWORD **)a7, v55);
                          v21 = a10;
                          goto LABEL_109;
                        }
                        v58 = glpLinkerPoolAlloc(v94);
                        *(_OWORD *)v58 = 0u;
                        *(_OWORD *)(v58 + 16) = 0u;
                        glpIntHashPut(a2, v57, v58, 0.0);
                        if (a3)
                          goto LABEL_106;
LABEL_130:
                        v59 = 0;
                        if (v58)
                          goto LABEL_108;
LABEL_109:
                        if (!v59)
                        {
                          if (v58)
                          {
LABEL_113:
                            v63 = 1;
                            v64 = (int *)v58;
                            goto LABEL_114;
                          }
LABEL_118:
                          LODWORD(v30) = 0;
                          goto LABEL_126;
                        }
                        *(_QWORD *)(v59 + 8) = v99;
                        *(_DWORD *)(v59 + 4) = glpPrimitiveTypeGetScalarType(v100);
                        *(_QWORD *)(v59 + 24) = offsetLayout(v94, a8, v55);
                        if (v58)
                          goto LABEL_113;
                        v63 = 0;
                        v64 = (int *)v59;
LABEL_114:
                        v65 = 0;
                        v66 = *v64;
                        while (((1 << v65) & v66) != 0)
                        {
                          if (++v65 == 4)
                            goto LABEL_125;
                        }
                        if (Equals)
                        {
                          v67 = v95[2];
                          v68 = &v95[2 * v67];
                          v68[4] = v57;
                          v68[5] = v65;
                          v95[2] = v67 + 1;
                        }
                        v69 = (1 << v65) | v66;
                        if (v63)
                        {
                          *(_DWORD *)v58 = v69;
                          v70 = glpPrimitiveTypeGetScalarType(*(unsigned int *)(v58 + 4));
                          v71 = componentCountForSet(*(_DWORD *)v58);
                          *(_DWORD *)(v58 + 4) = glpGetVectorType(v70, v71);
                        }
                        if (v59)
                        {
                          *(_DWORD *)v59 = v69;
                          v72 = glpPrimitiveTypeGetScalarType(*(unsigned int *)(v59 + 4));
                          v73 = componentCountForSet(*(_DWORD *)v59);
                          *(_DWORD *)(v59 + 4) = glpGetVectorType(v72, v73);
                        }
LABEL_125:
                        LODWORD(v30) = 1;
LABEL_126:
                        ScalarCount = glpPrimitiveTypeGetScalarCount(v100);
                        if (!(_DWORD)v30 || (++v53, v53 >= ScalarCount))
                        {
LABEL_133:
                          v23 = (_DWORD)v30 != 0;
                          v20 = v92;
                          break;
                        }
                        goto LABEL_79;
                      }
                      if (*(_QWORD *)(v59 + 8) == v99)
                        goto LABEL_108;
                    }
                  }
                }
              }
              if (!--v21)
              {
                LODWORD(v30) = 0;
                v21 = a10;
                goto LABEL_126;
              }
              goto LABEL_81;
            }
          }
          else if (a9 == -1 || v28 == a9)
          {
            goto LABEL_34;
          }
        }
        if (!--v21)
        {
          LODWORD(v30) = 0;
          v35 = a9;
          goto LABEL_66;
        }
      }
    }
    if (a9 == -1)
      a9 = -1;
    else
      ++a9;
    ++v20;
  }
  while (v20 != v91);
  if (!v23)
  {
    if (v95[2])
    {
      v75 = 0;
      v76 = v95 + 5;
      do
      {
        if (a2)
        {
          v77 = (_DWORD *)glpIntHashGet(a2, *(v76 - 1));
          if (a3)
            goto LABEL_143;
        }
        else
        {
          v77 = 0;
          if (a3)
          {
LABEL_143:
            v78 = (_DWORD *)glpIntHashGet(a3, *(v76 - 1));
            if (v77)
              goto LABEL_147;
            goto LABEL_150;
          }
        }
        v78 = 0;
        if (v77)
        {
LABEL_147:
          v79 = 1;
          v80 = v77[1];
          *v77 &= ~(1 << *v76);
          v81 = glpPrimitiveTypeGetScalarType(v80);
          if (*v77)
            v79 = componentCountForSet(*v77);
          v77[1] = glpGetVectorType(v81, v79);
        }
LABEL_150:
        if (v78)
        {
          v82 = 1;
          v83 = v78[1];
          *v78 &= ~(1 << *v76);
          v84 = glpPrimitiveTypeGetScalarType(v83);
          if (*v78)
            v82 = componentCountForSet(*v78);
          v78[1] = glpGetVectorType(v84, v82);
        }
        ++v75;
        v76 += 2;
      }
      while (v75 < v95[2]);
    }
    v95[2] = 0;
  }
  return v23;
}

uint64_t componentCountForSet(char a1)
{
  if ((a1 & 8) != 0)
    return 4;
  if ((a1 & 4) != 0)
    return 3;
  if ((a1 & 2) != 0)
    return 2;
  if ((a1 & 1) == 0)
    abort();
  return 1;
}

_QWORD *propagateCopyBindings(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int *ElementType;
  unsigned int v7;
  unsigned int Size;
  uint64_t v9;
  _DWORD *v10;
  _BYTE *v11;
  _QWORD *v12;
  uint64_t v13;
  int v14;
  int Equals;
  int v16;
  unsigned int v17;
  uint64_t v18;

  ElementType = *(unsigned int **)a2;
  if (glpTypeGetKind(*(unsigned int **)a2) == 3)
    ElementType = (unsigned int *)glpBankTypeGetElementType((uint64_t)ElementType);
  v7 = glpABIGetTypeSize(0, (uint64_t)ElementType, 0);
  Size = glpTypeSizeGetSize(v7);
  v9 = Size;
  v10 = (_DWORD *)glpLinkerPoolAlloc(a1);
  v11 = (_BYTE *)glpLinkerPoolAlloc(a1);
  glpTypeGetAppleVec4Types(ElementType, v10, 1, 0, 0, v11, 0, 0, 0);
  v12 = (_QWORD *)glpLinkerPoolAlloc(a1);
  *v12 = a2;
  v12[1] = 0;
  *((_DWORD *)v12 + 2) = 0;
  if (Size)
  {
    v13 = 0;
    v14 = 0;
    do
    {
      Equals = BitSetGetEquals(*(_QWORD *)(a2 + 120), v13);
      v16 = BitSetGetEquals(*(_QWORD *)(*(_QWORD *)a3 + 120), v13);
      if (Equals)
      {
        if (glpPrimitiveTypeGetScalarCount(v10[v13]))
        {
          v17 = 0;
          do
          {
            v18 = *((unsigned int *)v12 + 2);
            v12[v18 + 2] = *(_QWORD *)(a3 + 8 * (v14 + v17++) + 16);
            *((_DWORD *)v12 + 2) = v18 + 1;
          }
          while (v17 < glpPrimitiveTypeGetScalarCount(v10[v13]));
          v14 += v17;
        }
      }
      else if (v16)
      {
        v14 += glpPrimitiveTypeGetScalarCount(v10[v13]);
      }
      ++v13;
    }
    while (v13 != v9);
  }
  return v12;
}

uint64_t compareVariableObjectsLocationFirstNameSecond(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  _BOOL4 v5;
  uint64_t *v6;
  int v7;
  uint64_t result;

  v2 = *a1;
  v3 = *a2;
  v4 = *(uint64_t **)(*a1 + 8);
  if (v4)
    v5 = glpLayoutObjectFind(v4, 26) == 0;
  else
    v5 = 1;
  v6 = *(uint64_t **)(v3 + 8);
  if (v6)
  {
    if (glpLayoutObjectFind(v6, 26))
      v7 = 0;
    else
      v7 = -1;
  }
  else
  {
    v7 = -1;
  }
  result = (v7 + v5);
  if (!(v7 + v5))
    return glpStringsCompare(*(const char **)(v2 + 16), *(_QWORD *)(v2 + 24), *(char **)(v3 + 16), *(_QWORD *)(v3 + 24));
  return result;
}

uint64_t outputForInput(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  char *v6;
  const void *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  _QWORD v12[2];

  v3 = a3;
  v12[1] = *MEMORY[0x24BDAC8D0];
  if ((a3 & 0xFFFFFFFC) == 0
    || *(_BYTE *)a2 != 36
    || *(_BYTE *)(a2 + 1) != 105
    || *(_BYTE *)(a2 + 2) != 98
    || *(_BYTE *)(a2 + 3) != 36)
  {
    return glpStringHashGet(a1, (const char *)a2, a3);
  }
  v5 = a3;
  MEMORY[0x24BDAC7A8](a1);
  v6 = (char *)v12 - ((v5 + 15) & 0x1FFFFFFF0);
  memcpy(v6, v7, v3);
  v6[4] = 111;
  v8 = v3 >> 5;
  if (v3 >> 5 >= v3)
  {
    v10 = v3;
  }
  else
  {
    v9 = ~(v3 >> 5);
    LODWORD(v10) = v3;
    do
    {
      v10 = (32 * (_DWORD)v10 + (v10 >> 2) + v6[(v3 - 1)]) ^ v10;
      LODWORD(v3) = v3 + v9;
    }
    while (v3 > v8);
  }
  return glpStringHashGet(a1, (const char *)v12 - ((v5 + 15) & 0x1FFFFFFF0), v5 | (v10 << 32));
}

uint64_t topLevelLookUpObjectTypeFromStringHash(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3;

  v3 = glpStringHashGet(a1, a2, a3);
  if (v3)
    return *(_QWORD *)v3;
  else
    return -1;
}

uint64_t glpMakeLog(_QWORD *a1)
{
  uint64_t v2;

  v2 = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 48, "Log");
  *(_QWORD *)v2 = a1;
  *(_BYTE *)(v2 + 8) = 0;
  *(_QWORD *)(v2 + 16) = glpMakeStringBuffer(a1);
  *(_DWORD *)(v2 + 24) = 0;
  return v2;
}

uint64_t glpDestroyLog(_QWORD **a1)
{
  glpDestroyStringBuffer((_QWORD **)a1[2]);
  return ((uint64_t (*)(_QWORD, _QWORD **))(*a1)[3])(**a1, a1);
}

uint64_t **glpLogMessage(uint64_t **result, unsigned int a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t **v9;
  uint64_t *v11;

  v9 = result;
  if (*((_DWORD *)result + 6))
  {
    ++*((_DWORD *)result + a2 + 7);
    return result;
  }
  if (!a2)
    *((_BYTE *)result + 8) = 1;
  v11 = result[2];
  if (*(_DWORD *)(a3 + 16) == -1)
  {
    if (a2 < 4)
    {
      glpStringBufferAppendFormat(v11, "%s: ", a3, (uint64_t)a4, a5, a6, a7, a8, (char)off_24F4B03C8[a2]);
      goto LABEL_10;
    }
LABEL_11:
    abort();
  }
  if (a2 >= 4)
    goto LABEL_11;
  glpStringBufferAppendFormat(v11, "%s: %.*s:%u: ", a3, (uint64_t)a4, a5, a6, a7, a8, (char)off_24F4B03C8[a2]);
LABEL_10:
  glpStringBufferAppendFormatv(v9[2], a4, &a9);
  return (uint64_t **)glpStringBufferAppendCString(v9[2], "\n");
}

uint64_t glpLogSuppress(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  *(_QWORD *)(a1 + 28) = 0;
  v4 = a1 + 28;
  *(_QWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 24) = 1;
  (*(void (**)(uint64_t))(a2 + 16))(a2);
  *(_DWORD *)(v4 - 4) = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 16))(a3, v4);
}

uint64_t glpLogGetStringBuffer(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t glpLogSetContainsErrors(uint64_t result, char a2)
{
  *(_BYTE *)(result + 8) = a2;
  return result;
}

uint64_t glpLogContainsErrors(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 8);
}

uint64_t glpLogGetString(uint64_t a1)
{
  return glpStringBufferGetCString(*(uint64_t **)(a1 + 16));
}

uint64_t glpLogGetSerializedSize(uint64_t a1)
{
  int v1;

  glpStringBufferGetString(*(_QWORD *)(a1 + 16));
  return (v1 + 1) + 4;
}

void *glpLogSerialize(uint64_t a1, _DWORD *a2)
{
  const void *String;
  unsigned int v5;
  unsigned int v6;
  void *result;

  String = (const void *)glpStringBufferGetString(*(_QWORD *)(a1 + 16));
  v6 = v5;
  *a2++ = *(unsigned __int8 *)(a1 + 8);
  result = memcpy(a2, String, v5);
  *((_BYTE *)a2 + v6) = 0;
  return result;
}

void *glpLogDeserialize(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a1 + 8) = *(_DWORD *)a2;
  return glpStringBufferAppendCString(*(uint64_t **)(a1 + 16), (char *)(a2 + 4));
}

uint64_t glpMakeNameTable(uint64_t a1, int a2, int a3)
{
  uint64_t v6;
  uint64_t Allocator;
  _QWORD *v8;
  uint64_t StringHash;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v6 = glpCompilerPoolAlloc(a1);
  *(_QWORD *)(v6 + 264) = a1;
  Allocator = glpCompilerGetAllocator(a1);
  glpInitDeserialContext(v6, Allocator, Allocator, 0, 0);
  v8 = (_QWORD *)glpCompilerGetAllocator(a1);
  StringHash = glpMakeStringHash(v8);
  v10 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v8[1])(*v8, 40, "Name List Node");
  *(_QWORD *)(v10 + 16) = 0;
  *(_QWORD *)v10 = StringHash;
  *(_QWORD *)(v10 + 8) = glpMakeIntHash(v8);
  *(_BYTE *)(v10 + 36) = 0;
  *(_QWORD *)(v10 + 24) = 0;
  *(_QWORD *)(v6 + 272) = v10;
  *(_QWORD *)(v6 + 280) = v10;
  v11 = (_QWORD *)glpCompilerGetAllocator(*(_QWORD *)(v6 + 264));
  v12 = (_QWORD *)glpCompilerGetAllocator(*(_QWORD *)(v6 + 264));
  v13 = glpMakeStringHash(v12);
  v14 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v11[1])(*v11, 40, "Name List Node");
  *(_QWORD *)(v14 + 16) = 0;
  *(_QWORD *)v14 = v13;
  *(_QWORD *)(v14 + 8) = glpMakeIntHash(v11);
  *(_BYTE *)(v14 + 36) = 0;
  *(_QWORD *)(v14 + 24) = 0;
  *(_QWORD *)(*(_QWORD *)(v6 + 280) + 16) = v14;
  v15 = glpCompilerGetAllocator(*(_QWORD *)(v6 + 264));
  *(_QWORD *)(v6 + 456) = 10;
  *(_QWORD *)(v6 + 464) = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(v15 + 8))(*(_QWORD *)v15, 80, "Vector Storage (GLPHashTable *)");
  *(_BYTE *)(v6 + 288) = 0;
  *(_DWORD *)(v6 + 292) = a2;
  glpNameTableSetGLSLVersion(v6, a3);
  *(_QWORD *)(v6 + 472) = 0;
  return v6;
}

uint64_t glpNameTableSetGLSLVersion(uint64_t a1, int a2)
{
  _QWORD *Allocator;
  uint64_t result;
  int v6;
  _QWORD *v7;
  uint64_t v8;
  double v9;
  uint64_t v10;
  _QWORD *v11;
  double v12;
  _QWORD *v13;
  double v14;
  _QWORD *v15;
  double v16;
  _QWORD *v17;
  double v18;

  *(_DWORD *)(a1 + 296) = a2;
  memset_pattern16((void *)(a1 + 300), &unk_22A97F400, 0x98uLL);
  *(_BYTE *)(a1 + 288) = 0;
  glpDestroyIntHash(*(_QWORD *)(*(_QWORD *)(a1 + 272) + 8));
  Allocator = (_QWORD *)glpCompilerGetAllocator(*(_QWORD *)(a1 + 264));
  result = glpMakeIntHash(Allocator);
  *(_QWORD *)(*(_QWORD *)(a1 + 272) + 8) = result;
  v6 = *(_DWORD *)(a1 + 292);
  if (v6 == 4)
  {
    v10 = *(_QWORD *)(a1 + 264);
    v8 = 8;
  }
  else
  {
    if (v6)
      return result;
    v7 = (_QWORD *)glpCompilerPoolAlloc(*(_QWORD *)(a1 + 264));
    v8 = 16;
    *v7 = 16;
    glpIntHashPut(*(_QWORD *)(*(_QWORD *)(a1 + 272) + 8), 1u, (uint64_t)v7, v9);
    v10 = *(_QWORD *)(a1 + 264);
  }
  v11 = (_QWORD *)glpCompilerPoolAlloc(v10);
  *v11 = v8;
  glpIntHashPut(*(_QWORD *)(*(_QWORD *)(a1 + 272) + 8), 5u, (uint64_t)v11, v12);
  v13 = (_QWORD *)glpCompilerPoolAlloc(*(_QWORD *)(a1 + 264));
  *v13 = 4;
  glpIntHashPut(*(_QWORD *)(*(_QWORD *)(a1 + 272) + 8), 0x11u, (uint64_t)v13, v14);
  v15 = (_QWORD *)glpCompilerPoolAlloc(*(_QWORD *)(a1 + 264));
  *v15 = 4;
  result = glpIntHashPut(*(_QWORD *)(*(_QWORD *)(a1 + 272) + 8), 0x13u, (uint64_t)v15, v16);
  if (!a2)
  {
    v17 = (_QWORD *)glpCompilerPoolAlloc(*(_QWORD *)(a1 + 264));
    *v17 = 4;
    return glpIntHashPut(*(_QWORD *)(*(_QWORD *)(a1 + 272) + 8), 0x15u, (uint64_t)v17, v18);
  }
  return result;
}

uint64_t glpDestroyNameTable(uint64_t a1)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t Allocator;
  uint64_t v5;

  v2 = *(uint64_t **)(a1 + 272);
  if (v2)
  {
    do
    {
      v3 = (uint64_t *)v2[2];
      glpDestroyStringHash(*v2);
      Allocator = glpCompilerGetAllocator(*(_QWORD *)(a1 + 264));
      (*(void (**)(_QWORD, uint64_t *))(Allocator + 24))(*(_QWORD *)Allocator, v2);
      v2 = v3;
    }
    while (v3);
  }
  v5 = glpCompilerGetAllocator(*(_QWORD *)(a1 + 264));
  return (*(uint64_t (**)(_QWORD, uint64_t))(v5 + 24))(*(_QWORD *)v5, a1);
}

uint64_t glpNameTableGetLanguage(uint64_t a1)
{
  return *(unsigned int *)(a1 + 292);
}

uint64_t glpNameTablePutPrecision(uint64_t a1, unsigned int a2, uint64_t a3)
{
  _QWORD *v6;
  double v7;

  v6 = (_QWORD *)glpCompilerPoolAlloc(*(_QWORD *)(a1 + 264));
  *v6 = a3;
  return glpIntHashPut(*(_QWORD *)(*(_QWORD *)(a1 + 272) + 8), a2, (uint64_t)v6, v7);
}

uint64_t glpNameTableGetGLSLVersion(uint64_t a1)
{
  return *(unsigned int *)(a1 + 296);
}

uint64_t glpNameTableSetGLSLExtensionBehavior(uint64_t result, unsigned int a2, int a3)
{
  *(_DWORD *)(result + 4 * a2 + 300) = a3;
  *(_BYTE *)(result + 288) = 0;
  if (a2 == 19 && a3 != 3)
    *(_DWORD *)(result + 448) = 3;
  return result;
}

BOOL glpNameTableIsExtensionEnabled(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4 * a2 + 300) != 3;
}

BOOL glpNameTableGet(uint64_t a1, char *a2, uint64_t a3, char a4, uint64_t a5)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  BOOL v16;
  unsigned int v17;
  _QWORD *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t Allocator;
  _QWORD *v25;
  _QWORD *v26;
  uint64_t StringHash;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char **v33;
  char **v34;
  char **v35;
  char **v36;
  uint64_t v37;
  char **v38;
  int v39;
  uint64_t v40;
  char **v41;
  int v42;
  uint64_t v43;
  char **v44;
  unsigned int v45;
  const char **v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  const char *v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int v60;
  uint64_t v61;
  unsigned int v62;
  uint64_t v63;
  char *v64;
  void (*v65)(uint64_t, _QWORD);
  uint64_t v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v72;
  char **v73;
  char *v74;
  uint64_t v75;
  _QWORD v78[2];
  BOOL (*v79)(uint64_t, uint64_t, unsigned int *);
  void *v80;
  uint64_t v81;
  uint8_t *v82;
  int v83;

  v78[0] = MEMORY[0x24BDAC760];
  v78[1] = 0x40000000;
  v79 = __glpNameTableGet_block_invoke;
  v80 = &unk_24F4B03F0;
  v81 = a5;
  v6 = *(_QWORD *)(a1 + 272);
  if (v6)
  {
    v7 = 0;
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 280) + 16);
    v9 = a4 & 2;
    do
    {
      v10 = *(unsigned __int8 *)(v6 + 36);
      v11 = *(_QWORD *)(a1 + 280);
      v12 = glpStringHashGet(*(_QWORD *)v6, a2, a3);
      if (v12)
      {
        v13 = v10 != 0;
        if (v6 == v11)
          v13 = 2;
        if (v6 == v8)
          v14 = 3;
        else
          v14 = v13;
        v15 = ((uint64_t (*)(_QWORD *, uint64_t, uint64_t))v79)(v78, v14, v12);
        if (v15 | v9)
          return v15 != 0;
      }
      else if (v9)
      {
        return 0;
      }
      if (v12)
        v16 = v6 == v8;
      else
        v16 = 0;
      if (v16)
        v7 = 1;
      v6 = *(_QWORD *)(v6 + 16);
    }
    while (v6);
    if (v7)
      return 0;
  }
  if (*(_BYTE *)(a1 + 288))
    goto LABEL_73;
  v17 = *(_DWORD *)(a1 + 296);
  switch(v17)
  {
    case 0u:
      goto LABEL_23;
    case 6u:
      v17 = 1;
LABEL_23:
      v75 = v17;
      if (builtInsArchives[v17])
        goto LABEL_30;
      pthread_mutex_lock(&mutex);
      if (builtInsArchives[v75])
        goto LABEL_29;
      v18 = (_QWORD *)((char *)&poolAllocators + 32 * v75);
      glpInitPoolAllocator(0x20000, 0x20000, v18);
      v83 = 0;
      v82 = 0;
      if (!glpGetBIArchiveData(v75, &v82, &v83))
        aborting_due_to_builtin_read_failure_suggesting_corrupt_os_installation();
      v19 = glpOpenArchive(v18, v83, (uint64_t)v82);
      builtInsArchives[v75] = v19;
      if (!v19)
        aborting_due_to_invalid_builtin_contents_suggesting_corrupt_os_installation();
      v20 = malloc_type_calloc(*((unsigned int *)&GLP_BI_INDEX_COUNT + v75), 8uLL, 0xA92C9FCEuLL);
      if (!v20)
        goto LABEL_80;
      nameTableSets[v75] = v20;
      glpLockPoolAllocator((uint64_t)v18);
LABEL_29:
      pthread_mutex_unlock(&mutex);
LABEL_30:
      v21 = *(_QWORD *)(a1 + 280);
      v22 = *(uint64_t **)(v21 + 16);
      if (v22)
      {
        do
        {
          v23 = (uint64_t *)v22[2];
          glpDestroyStringHash(*v22);
          Allocator = glpCompilerGetAllocator(*(_QWORD *)(a1 + 264));
          (*(void (**)(_QWORD, uint64_t *))(Allocator + 24))(*(_QWORD *)Allocator, v22);
          v22 = v23;
        }
        while (v23);
        v21 = *(_QWORD *)(a1 + 280);
      }
      *(_QWORD *)(v21 + 16) = 0;
      v25 = (_QWORD *)glpCompilerGetAllocator(*(_QWORD *)(a1 + 264));
      v26 = (_QWORD *)glpCompilerGetAllocator(*(_QWORD *)(a1 + 264));
      StringHash = glpMakeStringHash(v26);
      v28 = ((uint64_t (*)(_QWORD, uint64_t, const char *))v25[1])(*v25, 40, "Name List Node");
      *(_QWORD *)(v28 + 16) = 0;
      *(_QWORD *)v28 = StringHash;
      *(_QWORD *)(v28 + 8) = glpMakeIntHash(v25);
      *(_BYTE *)(v28 + 36) = 0;
      *(_QWORD *)(v28 + 24) = 0;
      *(_QWORD *)(*(_QWORD *)(a1 + 280) + 16) = v28;
      v29 = glpCompilerGetAllocator(*(_QWORD *)(a1 + 264));
      (*(void (**)(_QWORD, _QWORD))(v29 + 24))(*(_QWORD *)v29, *(_QWORD *)(a1 + 464));
      v30 = glpCompilerGetAllocator(*(_QWORD *)(a1 + 264));
      *(_QWORD *)(a1 + 456) = 10;
      *(_QWORD *)(a1 + 464) = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(v30 + 8))(*(_QWORD *)v30, 80, "Vector Storage (GLPHashTable *)");
      v31 = *((unsigned int *)&GLP_BI_INDEX_COUNT + v75);
      if (!(_DWORD)v31)
        goto LABEL_72;
      v32 = 0;
      v33 = GLP_BI_INDEX[v75];
      v73 = v33;
      v74 = (char *)&poolAllocators + 32 * v75;
      v34 = v33 + 27;
      v35 = v33 + 3;
      v36 = v33 + 8;
      break;
    default:
      goto LABEL_80;
  }
  do
  {
    v37 = HIDWORD(v33[30 * v32 + 2]);
    if (!(_DWORD)v37)
      goto LABEL_71;
    v38 = v34;
    while (1)
    {
      v39 = *(_DWORD *)v38;
      v38 = (char **)((char *)v38 + 4);
      if (v39 == *(_DWORD *)(a1 + 292))
        break;
      if (!--v37)
        goto LABEL_71;
    }
    v40 = HIDWORD(v33[30 * v32 + 1]);
    if ((_DWORD)v40)
    {
      v41 = v35;
      while (1)
      {
        v42 = *(_DWORD *)v41;
        v41 = (char **)((char *)v41 + 4);
        if (v42 == *(_DWORD *)(a1 + 296))
          break;
        if (!--v40)
          goto LABEL_44;
      }
    }
    else
    {
LABEL_44:
      v43 = LODWORD(v33[30 * v32 + 2]);
      v44 = v36;
      if (!(_DWORD)v43)
        goto LABEL_71;
      while (1)
      {
        v45 = *(_DWORD *)v44;
        v44 = (char **)((char *)v44 + 4);
        if (*(_DWORD *)(a1 + 4 * v45 + 300) != 3)
          break;
        if (!--v43)
          goto LABEL_71;
      }
    }
    pthread_mutex_lock(&mutex);
    if (!*(_QWORD *)(nameTableSets[v75] + 8 * v32))
    {
      v46 = (const char **)&v33[30 * v32];
      glpUnlockPoolAllocator((uint64_t)v74);
      v47 = *v46;
      v48 = nameTableSets[v75];
      v49 = builtInsArchives[v75];
      v50 = strlen(*v46);
      if (v50 >> 5 >= v50)
      {
        v52 = v50;
      }
      else
      {
        v51 = v50;
        v52 = v50;
        do
        {
          v52 ^= 32 * v52 + (v52 >> 2) + v47[v51 - 1];
          v51 += ~(v50 >> 5);
        }
        while (v51 > v50 >> 5);
      }
      v83 = 0;
      v82 = 0;
      if (!glpArchiveFileGetEntryNamed(v49, v47, v50 | ((unint64_t)v52 << 32), &v83, &v82)
        || !glpDeserializeNames((uint64_t)v74, (unsigned int *)v82, v83, (uint64_t *)(v48 + 8 * v32)))
      {
LABEL_80:
        abort();
      }
      v53 = *v46;
      v54 = strlen(*v46);
      if (v54 >> 5 >= v54)
      {
        v56 = v54;
      }
      else
      {
        v55 = v54;
        v56 = v54;
        do
        {
          v56 ^= 32 * v56 + (v56 >> 2) + v53[v55 - 1];
          v55 += ~(v54 >> 5);
        }
        while (v55 > v54 >> 5);
      }
      glpArchiveFileFinishEntryNamed(builtInsArchives[v75], v53, v54 | ((unint64_t)v56 << 32));
      glpLockPoolAllocator((uint64_t)v74);
      v33 = v73;
    }
    pthread_mutex_unlock(&mutex);
    v57 = *(_QWORD *)(nameTableSets[v75] + 8 * v32);
    v58 = *(unsigned int *)(a1 + 460);
    v59 = *(_DWORD *)(a1 + 456);
    if ((int)v58 + 1 <= v59)
    {
      v64 = *(char **)(a1 + 464);
      v67 = *(_DWORD *)(a1 + 460);
    }
    else
    {
      if (v59 <= 1)
        v59 = 1;
      v60 = 2 * v59;
      v72 = *(_QWORD *)(nameTableSets[v75] + 8 * v32);
      v61 = v31;
      if (v60 <= (int)v58 + 1)
        v62 = v58 + 1;
      else
        v62 = v60;
      v63 = glpCompilerGetAllocator(*(_QWORD *)(a1 + 264));
      v64 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(v63 + 8))(*(_QWORD *)v63, 8 * v62, "Vector Storage (GLPHashTable *, growth)");
      memcpy(v64, *(const void **)(a1 + 464), 8 * *(unsigned int *)(a1 + 460));
      v65 = *(void (**)(uint64_t, _QWORD))(v63 + 24);
      v66 = *(_QWORD *)v63;
      v33 = v73;
      v65(v66, *(_QWORD *)(a1 + 464));
      *(_DWORD *)(a1 + 456) = v62;
      v31 = v61;
      v57 = v72;
      *(_QWORD *)(a1 + 464) = v64;
      v67 = *(_DWORD *)(a1 + 460);
    }
    memmove(&v64[8 * v58 + 8], &v64[8 * v58], 8 * (v67 - v58));
    *(_QWORD *)(*(_QWORD *)(a1 + 464) + 8 * v58) = v57;
    ++*(_DWORD *)(a1 + 460);
LABEL_71:
    ++v32;
    v34 += 30;
    v35 += 30;
    v36 += 30;
  }
  while (v32 != v31);
LABEL_72:
  *(_BYTE *)(a1 + 288) = 1;
LABEL_73:
  v68 = *(unsigned int *)(a1 + 460);
  if (!(_DWORD)v68)
    return 0;
  v69 = 0;
  while (1)
  {
    v70 = getAndRemapBuiltinFromScope(a1, *(_QWORD *)(*(_QWORD *)(a1 + 464) + 8 * v69), a2, a3, v69, v68, 6);
    if (v70)
    {
      if (((unsigned int (*)(_QWORD *, uint64_t, uint64_t))v79)(v78, 3, v70))
        break;
    }
    if (v68 == ++v69)
      return 0;
  }
  return 1;
}

BOOL __glpNameTableGet_block_invoke(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  uint64_t v9;
  int v11;

  v11 = 0;
  v5 = *a3;
  if ((_DWORD)v5 == 9)
  {
    v6 = *((_QWORD *)a3 + 1);
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    if (v11)
      return 1;
    v7 = *(_QWORD *)(a1 + 32);
    v8 = *(unsigned int **)(v6 + 8);
    v5 = *v8;
    v9 = *((_QWORD *)v8 + 1);
  }
  else
  {
    v7 = *(_QWORD *)(a1 + 32);
    v9 = *((_QWORD *)a3 + 1);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *))(v7 + 16))(v7, v5, v9, a2, &v11);
  return v11 != 0;
}

uint64_t getAndRemapBuiltinFromScope(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, int a5, unsigned int a6, char a7)
{
  int *v11;
  double v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  uint64_t v23;
  uint64_t v24;

  v23 = **(_QWORD **)(*(_QWORD *)(a1 + 280) + 16);
  v11 = (int *)glpStringHashGet(a2, a3, a4);
  if (!v11)
    return 0;
  glpReInitDeserialContext(a1, (uint64_t)(v11 + 1), *v11);
  v24 = 0;
  deserialize_GLPNameTableEntry(a1, &v24);
  v13 = v24;
  if (*(_DWORD *)v24 == 13)
  {
    v14 = *(_QWORD *)(v24 + 8);
    v15 = *(unsigned int *)(v14 + 4);
    if ((_DWORD)v15)
    {
      v16 = 0;
      v13 = 0;
      v17 = 24 * v15;
      do
      {
        v18 = *(_QWORD *)(v14 + 8);
        if ((a7 & 2) != 0)
          remap(a1, (int)a3, a4, a5, a6, *(_QWORD *)(v18 + v16), **(_DWORD **)(v18 + v16), *(_QWORD **)(*(_QWORD *)(v18 + v16) + 8));
        if (glpStringsEqual(*(const char **)(v18 + v16 + 8), *(_QWORD *)(v18 + v16 + 16), a3, a4))
          v13 = *(_QWORD *)(v18 + v16);
        if ((a7 & 4) != 0)
          glpStringHashPut(v23, *(const char **)(v18 + v16 + 8), *(_QWORD *)(v18 + v16 + 16), *(_QWORD *)(v18 + v16), v19);
        v16 += 24;
      }
      while (v17 != v16);
      return v13;
    }
    return 0;
  }
  if ((a7 & 2) != 0)
  {
    remap(a1, (int)a3, a4, a5, a6, v24, *(_DWORD *)v24, *(_QWORD **)(v24 + 8));
    v13 = v24;
  }
  if ((a7 & 4) != 0)
  {
    glpStringHashPut(v23, a3, a4, v13, v12);
    return v24;
  }
  return v13;
}

uint64_t glpNameTablePut(uint64_t a1, const char *a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  double v17;

  v10 = *(uint64_t **)(a1 + 272);
  v11 = glpStringHashGet(*v10, a2, a3);
  if (v11 && *(_DWORD *)(a1 + 296) == 1)
  {
    v12 = v11;
    v13 = (_QWORD *)glpCompilerPoolAlloc(*(_QWORD *)(a1 + 264));
    v14 = glpCompilerPoolAlloc(*(_QWORD *)(a1 + 264));
    *(_DWORD *)v14 = *(_DWORD *)v12;
    *(_QWORD *)(v14 + 8) = *(_QWORD *)(v12 + 8);
    *v13 = v14;
    result = glpCompilerPoolAlloc(*(_QWORD *)(a1 + 264));
    *(_DWORD *)result = a4;
    *(_QWORD *)(result + 8) = a5;
    v13[1] = result;
    *(_DWORD *)v12 = 9;
    *(_QWORD *)(v12 + 8) = v13;
  }
  else
  {
    v16 = glpCompilerPoolAlloc(*(_QWORD *)(a1 + 264));
    *(_DWORD *)v16 = a4;
    *(_QWORD *)(v16 + 8) = a5;
    return glpStringHashPut(*v10, a2, a3, v16, v17);
  }
  return result;
}

uint64_t glpNameTablePush(uint64_t a1, uint64_t a2)
{
  _QWORD *Allocator;

  Allocator = (_QWORD *)glpCompilerGetAllocator(*(_QWORD *)(a1 + 264));
  return nameTablePush(Allocator, (uint64_t *)(a1 + 272), a2, 0);
}

uint64_t nameTablePush(_QWORD *a1, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t StringHash;
  uint64_t v9;
  uint64_t result;

  StringHash = glpMakeStringHash(a1);
  v9 = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 40, "Name List Node");
  *(_QWORD *)(v9 + 16) = 0;
  *(_QWORD *)v9 = StringHash;
  result = glpMakeIntHash(a1);
  *(_QWORD *)(v9 + 8) = result;
  *(_BYTE *)(v9 + 36) = a4;
  *(_QWORD *)(v9 + 24) = a3;
  *(_QWORD *)(v9 + 16) = *a2;
  *a2 = v9;
  return result;
}

uint64_t glpNameTablePushForFunction(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *Allocator;
  uint64_t result;

  Allocator = (_QWORD *)glpCompilerGetAllocator(a1[33]);
  result = nameTablePush(Allocator, a1 + 34, a2, 1);
  a1[59] = a3;
  return result;
}

uint64_t glpNameTableSetStatementIndex(uint64_t result, int a2)
{
  *(_DWORD *)(*(_QWORD *)(result + 272) + 32) = a2;
  return result;
}

uint64_t glpNameTablePop(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t Allocator;
  uint64_t result;

  v2 = a1[34];
  if (*(_BYTE *)(v2 + 36))
    a1[59] = 0;
  glpDestroyStringHash(*(_QWORD *)v2);
  v3 = *(_QWORD *)(v2 + 16);
  Allocator = glpCompilerGetAllocator(a1[33]);
  result = (*(uint64_t (**)(_QWORD, uint64_t))(Allocator + 24))(*(_QWORD *)Allocator, v2);
  a1[34] = v3;
  return result;
}

uint64_t glpNameTableSetTopLevelBlock(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 272) + 24) = a2;
  return result;
}

uint64_t glpNameTableGetCurrentFunction(uint64_t a1)
{
  return *(_QWORD *)(a1 + 472);
}

uint64_t glpNameTableGetPrecision(uint64_t a1, unsigned int a2)
{
  _QWORD *v2;
  _QWORD *v4;
  uint64_t v5;

  v2 = *(_QWORD **)(a1 + 272);
  if (!v2)
    return 0;
  while (1)
  {
    v4 = (_QWORD *)v2[2];
    if (*v2)
    {
      v5 = glpIntHashGet(v2[1], a2);
      if (v5)
        break;
    }
    v2 = v4;
    if (!v4)
      return 0;
  }
  return *(_QWORD *)v5;
}

void aborting_due_to_invalid_builtin_contents_suggesting_corrupt_os_installation()
{
  abort();
}

void aborting_due_to_builtin_read_failure_suggesting_corrupt_os_installation()
{
  abort();
}

uint64_t remap(uint64_t a1, int a2, int a3, int a4, unsigned int a5, uint64_t a6, int a7, _QWORD *a8)
{
  _QWORD *v10;
  uint64_t result;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;

  *(_DWORD *)a6 = a7;
  v10 = *(_QWORD **)(a1 + 264);
  if (a7 == 4)
  {
    result = glpCompilerRemapObject(v10, 4, a8, 0, 1);
    v16 = (_QWORD *)result;
    v17 = (a4 + 1);
    if (v17 >= a5)
    {
      v19 = (_QWORD *)result;
    }
    else
    {
      do
      {
        result = getAndRemapBuiltinFromScope(a1, *(_QWORD *)(*(_QWORD *)(a1 + 464) + 8 * v17), a2, a3);
        if (result && (v18 = *(_QWORD *)(result + 8)) != 0)
        {
          do
          {
            v19 = (_QWORD *)glpCompilerPoolAlloc(*(_QWORD *)(a1 + 264));
            result = glpCompilerRemapObject(*(_QWORD **)(a1 + 264), 10, *(_QWORD **)v18, 0, 1);
            *v19 = result;
            v19[1] = v16;
            v18 = *(_QWORD *)(v18 + 8);
            v16 = v19;
          }
          while (v18);
        }
        else
        {
          v19 = v16;
        }
        ++v17;
        v16 = v19;
      }
      while ((_DWORD)v17 != a5);
    }
  }
  else
  {
    result = glpCompilerRemapObject(v10, a7, a8, 0, 1);
    v19 = (_QWORD *)result;
  }
  *(_QWORD *)(a6 + 8) = v19;
  return result;
}

unsigned int *FinishType(unsigned int *result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;

  v1 = result[5];
  if (v1 >= 4)
  {
    if (v1 == 4)
    {
      v3 = *result;
      v2 = result[1];
      result[2] = *result;
      result[3] = v2;
      result[4] = 8;
      if (v3 >= 3)
      {
        result[2] = 2;
        result[3] = 2 * v2;
      }
    }
  }
  else
  {
    *((_QWORD *)result + 1) = *(_QWORD *)result;
    result[4] = 4;
  }
  return result;
}

double InitReg(unsigned __int16 *a1, int a2, uint64_t a3)
{
  double result;

  *(_DWORD *)(a3 + 40) = a2;
  result = 0.0;
  *(_OWORD *)(a3 + 44) = xmmword_22A97F410;
  *(_DWORD *)(a3 + 60) = 3;
  *(_QWORD *)(a3 + 64) = *a1;
  *(_QWORD *)(a3 + 72) = 0;
  return result;
}

double AddArray(unsigned __int16 *a1, uint64_t a2, uint64_t a3)
{
  double result;
  unint64_t v6;

  if (*(_DWORD *)a2 == 2)
  {
    v6 = (*(_DWORD *)(a2 + 4) << 16) | ((unint64_t)*(unsigned int *)(a3 + 4) << 48);
    PPStreamAddParamBindingArray((uint64_t)a1, &v6);
  }
  else if (*(_DWORD *)a2 == 1)
  {
    v6 = (*(_DWORD *)(a2 + 4) << 16) | ((unint64_t)*(unsigned int *)(a3 + 4) << 48);
    PPStreamAddTempUsageArray((uint64_t)a1, &v6);
  }
  *(_OWORD *)(a2 + 40) = xmmword_22A97F420;
  *(_QWORD *)&result = 0x300000002;
  *(_QWORD *)(a2 + 56) = 0x300000002;
  *(_QWORD *)(a2 + 64) = *a1;
  *(_QWORD *)(a2 + 72) = 0;
  return result;
}

unsigned __int16 *AddBinding(unsigned __int16 *result, uint64_t a2, uint64_t a3, unsigned int a4, __int128 *a5)
{
  unint64_t v5;
  int v6;
  unsigned int v7;
  __int128 v8;
  __int128 v9;

  if (*((_DWORD *)a5 + 3))
  {
    v5 = 0;
    do
    {
      if (a4 <= 5)
        __asm { BR              X9 }
      v8 = *a5;
      v9 = a5[1];
      v6 = *result;
      if (!v5)
      {
        *(_DWORD *)a2 = a4;
        *(_DWORD *)(a2 + 4) = 0;
        *(_OWORD *)(a2 + 8) = v8;
        *(_OWORD *)(a2 + 24) = v9;
        *(_DWORD *)(a2 + 40) = 0;
        *(_OWORD *)(a2 + 44) = xmmword_22A97F410;
        *(_DWORD *)(a2 + 60) = 3;
        *(_DWORD *)(a2 + 64) = v6;
        *(_QWORD *)(a2 + 72) = 0;
        *(_DWORD *)(a2 + 68) = 0;
      }
      v7 = *((_DWORD *)a5 + 3);
      if (v5 == v7 - 1)
      {
        *(_DWORD *)a3 = a4;
        *(_DWORD *)(a3 + 4) = 0;
        *(_OWORD *)(a3 + 8) = v8;
        *(_OWORD *)(a3 + 24) = v9;
        *(_DWORD *)(a3 + 40) = 0;
        *(_OWORD *)(a3 + 44) = xmmword_22A97F410;
        *(_DWORD *)(a3 + 60) = 3;
        *(_DWORD *)(a3 + 64) = v6;
        *(_QWORD *)(a3 + 72) = 0;
        *(_DWORD *)(a3 + 68) = 0;
        v7 = *((_DWORD *)a5 + 3);
      }
      ++v5;
    }
    while (v5 < v7);
  }
  return result;
}

unsigned __int16 *AddTemp(unsigned __int16 *a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  return AddBinding(a1, a2, a3, 1u, a4);
}

unsigned __int16 *AddConstant(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  size_t v10;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD v16[3];

  v16[2] = *MEMORY[0x24BDAC8D0];
  MEMORY[0x24BDAC7A8](a1);
  v11 = (char *)&v16[-1] - ((v10 + 15) & 0xFFFFFFFF0);
  bzero(v11, v10);
  if (*(_DWORD *)(a4 + 12))
  {
    v12 = 0;
    do
    {
      v13 = *(_QWORD *)&v11[8 * v12] & 0xFFFFFFFFFFFFE0FFLL | 0x600;
      *(_QWORD *)&v11[8 * v12] = v13;
      *(_QWORD *)&v11[8 * v12] = v13 & 0xFFFF0000FFFFFFFFLL | ((unint64_t)(unsigned __int16)PPStreamChunkListGetNextIndex(*(uint64_t **)(a1 + 128)) << 32);
      v16[0] = 0;
      v16[1] = 0;
      __memcpy_chk();
      PPStreamAddConstant(a1, v16);
      ++v12;
      a5 += 16;
    }
    while (v12 < *(unsigned int *)(a4 + 12));
  }
  return AddBinding((unsigned __int16 *)a1, a2, a3, 2u, (__int128 *)a4);
}

char *AddOpv(uint64_t a1, unsigned __int8 a2, _DWORD *a3, _DWORD *a4, uint64_t *a5, unint64_t *a6)
{
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int8x16_t v15;
  unint64_t v16;
  unint64_t v17;
  BOOL v18;
  int v19;
  uint64_t v20;
  int v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t *v32;
  int v33;
  _DWORD *v34;
  int v35;
  _DWORD *v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t *v40;
  unint64_t v41;
  uint64_t v42;
  BOOL v43;
  int v44;
  BOOL v46;
  unint64_t v47;
  unsigned int v48;
  _BOOL4 v49;
  int v50;
  unsigned int v51;
  _BOOL4 v52;
  unint64_t v53;
  unsigned int v54;
  _BOOL4 v55;
  _BOOL4 v56;
  _BOOL4 v57;
  unint64_t v58;
  BOOL v59;
  _BOOL4 v60;
  unsigned int v61;
  char v62;
  unint64_t v63;
  int8x16_t v64;
  int v65;
  int v66;
  unint64_t v67;
  uint64_t v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  uint64_t v72;
  int8x16_t v73;
  int8x16_t v74;
  uint32x4_t v75;
  int8x16_t *v76;
  int8x16_t *v77;
  uint64_t v78;
  char v79;
  __int32 v80;
  int64x2_t v81;
  unint64_t v82;
  int8x16_t *v83;
  uint64_t v84;
  int v85;
  int8x8_t v86;
  int8x16_t v87;
  unint64_t v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  int8x16_t v99;
  int8x16_t v100;
  __int128 v101;
  int8x16_t v102;
  int8x16_t v103;
  int v104;
  int8x8_t v105;
  int v106;
  int8x16_t v107;
  uint64_t v108;

  v108 = *MEMORY[0x24BDAC8D0];
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 8);
  if (v7)
    v8 = v7 + 24;
  else
    v8 = 0;
  if (v7)
    v9 = *(_DWORD *)(v7 + 24) & 7;
  else
    v9 = 0;
  v97 = 0u;
  v98 = 0u;
  v95 = 0u;
  v96 = 0u;
  v94 = 0u;
  if (a4)
  {
    if (a4[17])
      ++a4[19];
    if (!a5)
    {
      v12 = 1912602624;
      v10 = 1912864768;
      v13 = 1912668160;
      switch(a4[2])
      {
        case 1:
          goto LABEL_17;
        case 2:
          goto LABEL_16;
        case 3:
          goto LABEL_15;
        case 4:
          v13 = 1912700928;
LABEL_15:
          v12 = v13;
LABEL_16:
          v10 = v12 | 0x60000;
          goto LABEL_17;
        default:
          goto LABEL_18;
      }
    }
    v10 = *a5;
LABEL_17:
    v12 = v10;
LABEL_18:
    if (a4[10] == 1)
      v14 = v12 | 0x100000000;
    else
      v14 = v12;
    v15.i64[0] = 0x100000001;
    v15.i64[1] = 0x100000001;
    v11 = vaddvq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v14), (uint32x4_t)xmmword_22A97DA10), v15))- 1;
    *((_QWORD *)&v94 + 1) = v14 & 0xFFFFFF878FFFLL | ((a4[2] << 21) + 6291456) & 0x600000 | ((a4[3] << 19) + 1572864) & 0x180000 | ((*a4 & 7) << 12) | ((unint64_t)a4[1] << 48);
  }
  else
  {
    v11 = -1;
  }
  v16 = *a6;
  v17 = a6[1];
  v18 = *a6 != 0;
  v19 = *a6 | v17;
  if (*(_OWORD *)a6 == 0)
  {
    v33 = 0;
  }
  else
  {
    v20 = 0;
    v19 = 0;
    v21 = 0;
    do
    {
      v22 = (unint64_t *)&v94 + v20 + 2;
      if (v18)
      {
        if (*(_DWORD *)(v16 + 68))
          ++*(_DWORD *)(v16 + 72);
        if (v17)
        {
          v23 = *(_QWORD *)v17;
        }
        else
        {
          *v22 = 0;
          v25 = (unint64_t)(*(_DWORD *)(v16 + 48) & 3) << 9;
          *v22 = v25;
          v26 = v25 & 0xFFFFE7FF | ((*(_DWORD *)(v16 + 52) & 3u) << 11);
          *v22 = v26;
          v27 = v26 & 0xFFFF9FFF | ((*(_DWORD *)(v16 + 56) & 3u) << 13);
          *v22 = v27;
          v23 = v27 & 0xFFFE7FFF | ((*(_DWORD *)(v16 + 60) & 3u) << 15);
        }
        *v22 = v23;
        v28 = v23 & 0xFFFFFFFFFFE7FFFFLL | ((*(_DWORD *)(v16 + 8) << 19) + 1572864) & 0x180000;
        *v22 = v28;
        v29 = v28 & 0xFFFFFFFFFFF9FFFFLL | ((*(_DWORD *)(v16 + 12) << 17) + 393216) & 0x60000;
        *v22 = v29;
        v30 = v29 & 0xFFFFFFFFFFFFFE3FLL | ((unint64_t)(*(_DWORD *)v16 & 7) << 6);
        *v22 = v30;
        v31 = v30 & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)*(_DWORD *)(v16 + 4) << 48);
        *v22 = v31;
        v24 = v31 & 0xFFFFFFFFFFFFFFEFLL | (16 * (*(_DWORD *)(v16 + 44) & 1));
      }
      else
      {
        v24 = *(_QWORD *)v17;
        v19 = 1;
      }
      *v22 = v24;
      v20 = (v21 + 1);
      v32 = &a6[2 * v20];
      v16 = *v32;
      v17 = v32[1];
      v18 = *v32 != 0;
      v21 = v20;
    }
    while (v16 | v17);
    v33 = v20 & 7;
  }
  v34 = a4 + 2;
  if (a3)
  {
    v34 = a3;
    v35 = -1;
  }
  else
  {
    v35 = v11;
  }
  if (a4)
    v36 = v34;
  else
    v36 = a3;
  if (a4)
    v37 = v35;
  else
    v37 = -1;
  if (v36 && v37 == -1)
    v37 = *v36 - 1;
  if (v19)
    v38 = ((unint64_t)(a4 != 0) << 32) | 0x28000;
  else
    v38 = (unint64_t)(a4 != 0) << 32;
  v39 = v38 | v33 & 0xFFFFC03F | (a2 << 6) | (8 * v9);
  *(_QWORD *)&v94 = v39;
  if (v36)
  {
    v39 = ((unint64_t)(v37 & 3) << 36) | ((unint64_t)((v36[1] - 1) & 3) << 34) | ((unint64_t)(v36[5] & 7) << 38) | v39 & 0xFFFFFFFFFFC7FFFFLL | ((v36[6] & 7) << 19);
    *(_QWORD *)&v94 = v39;
  }
  v40 = 0;
  while (1)
  {
    if ((v39 & 0x3FC0) != 0 || !v8)
    {
      if ((v39 & 0x3FC0) != 0x1B40)
        goto LABEL_156;
      if (!v8)
        goto LABEL_156;
      v41 = *(_QWORD *)v8;
      if ((*(_QWORD *)v8 & 0x3FC0) != 0x1B40)
        goto LABEL_156;
    }
    else
    {
      v41 = *(_QWORD *)v8;
      v42 = *(_QWORD *)v8 & 0x3FC0;
      if (v42)
        v43 = v42 == 6976;
      else
        v43 = 1;
      if (!v43)
        goto LABEL_156;
      v44 = (v41 >> 6);
      if (v44 == 109 || v44 == 0)
      {
        v46 = *(_DWORD *)(*a6 + 68) != 0;
        goto LABEL_70;
      }
    }
    v46 = 0;
LABEL_70:
    v47 = *(_QWORD *)(v8 + 8);
    v48 = DWORD2(v94);
    if (((*((_QWORD *)&v94 + 1) ^ v47) & 0x7000) != 0)
    {
      v49 = 0;
    }
    else
    {
      v49 = 0;
      if (HIWORD(*((_QWORD *)&v94 + 1)) == HIWORD(v47) && ((*((_QWORD *)&v94 + 1) ^ v47) & 0xF00000000) == 0)
        v49 = (int)(*((_QWORD *)&v94 + 1) >> 12) >> 24 == (int)(v47 >> 12) >> 24;
    }
    v52 = ((v50 = (DWORD2(v94) >> 18) & 1, (v51 = (v47 >> 18) & 1) == 0) || v50 == v51)
       && (((v47 >> 17) & 1) == 0 || ((DWORD2(v94) >> 17) & 1) == ((v47 >> 17) & 1))
       && ((v47 & 0x10000) == 0 || (HIWORD(DWORD2(v94)) & 1) == (WORD1(v47) & 1))
       && (((DWORD2(v94) >> 15) & 1) == ((v47 >> 15) & 1) || ((v47 >> 15) & 1) == 0);
    v53 = *(_QWORD *)(v8 + 16);
    v54 = v95;
    if ((((unint64_t)v95 ^ v53) & 0x1C0) != 0)
    {
      v55 = 0;
    }
    else
    {
      v55 = 0;
      if (WORD3(v95) == HIWORD(v53) && ((v95 ^ v53) & 0xF) == 0)
        v55 = (int)v95 >> 24 == (int)v53 >> 24;
    }
    v56 = ((v95 ^ v53) & 0x30) == 0;
    v57 = (((v95 >> 6) ^ (v47 >> 12)) & 7) == 0
       && WORD3(v95) == HIWORD(v47)
       && ((v95 ^ HIDWORD(v47)) & 1) == 0
       && (((v47 >> 33) ^ (v95 >> 1)) & 1) == 0
       && (((v47 >> 34) ^ (v95 >> 2)) & 3) == 0
       && (int)v95 >> 24 == (int)(v47 >> 12) >> 24;
    v58 = v41 ^ v39;
    v59 = ((v41 ^ v39) & 0x9CE00380000) == 0 && v39 >> 46 == v41 >> 46;
    v60 = v59;
    if ((v39 & 0xC00000000) != 0)
    {
      v56 = 0;
      v52 = v52 && (v58 & 0x3000000000) == 0;
      v61 = 0;
    }
    else
    {
      if (v52)
        v52 = ((v39 >> 36) & 3) >= ((v41 >> 36) & 3);
      v62 = !v46;
      if ((v58 & 0x3000000000) != 0)
        v62 = 1;
      if ((v62 & 1) != 0 || *(_DWORD *)(*a6 + 72) != 1)
      {
        v61 = 0;
      }
      else
      {
        v63 = 0;
        v64.i64[0] = 0x300000003;
        v64.i64[1] = 0x300000003;
        v107 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v95), (uint32x4_t)xmmword_22A97D9F0), v64);
        do
        {
          switch(v107.i32[v63])
          {
            case 0:
              v61 = (v47 >> 18) & 1;
              break;
            case 1:
              v61 = (v47 >> 17) & 1;
              break;
            case 2:
              v61 = WORD1(v47) & 1;
              break;
            case 3:
              v61 = (v47 >> 15) & 1;
              break;
            default:
              v61 = 1;
              break;
          }
          if (v63 >= ((v39 >> 36) & 3))
            break;
          ++v63;
        }
        while (v61);
      }
    }
    if (v61)
      v65 = v60;
    else
      v65 = 0;
    v66 = v60 && v49 && v52;
    if (v57)
      v66 = v65;
    if (v66 != 1)
      break;
    if (v40)
    {
      PPStreamChunkListRemoveChunk(*(_QWORD *)(a1 + 104), v40);
      v41 = *(_QWORD *)v8;
      v39 = v94;
    }
    v67 = v39 & 0xFFFFFFFFFFFFFFC7 | (8 * ((v41 >> 3) & 7));
    *(_QWORD *)&v94 = v67;
    LODWORD(v98) = *(_DWORD *)(v8 + 64);
    if ((v57 & v65 & 1) == 0)
    {
      v90 = v97;
      v89 = v98;
      *(_OWORD *)(v8 + 32) = v96;
      *(_OWORD *)(v8 + 48) = v90;
      *(_OWORD *)(v8 + 64) = v89;
      v91 = v95;
      *(_OWORD *)v8 = v94;
      *(_OWORD *)(v8 + 16) = v91;
      return (char *)v7;
    }
    v39 = v67 & 0xFFFFFFFFFFFFC03FLL | ((unint64_t)(*(_QWORD *)v8 >> 6) << 6);
    v68 = *(_QWORD *)(v8 + 16);
    *(_QWORD *)&v94 = v39;
    *(_QWORD *)&v95 = v68;
    v70 = v97;
    v69 = v98;
    *(_OWORD *)(v8 + 32) = v96;
    *(_OWORD *)(v8 + 48) = v70;
    *(_OWORD *)(v8 + 64) = v69;
    v71 = v95;
    *(_OWORD *)v8 = v94;
    *(_OWORD *)(v8 + 16) = v71;
    v40 = (uint64_t *)v7;
    v7 = *(_QWORD *)v7;
    if (v7)
      v8 = v7 + 24;
    else
      v8 = 0;
  }
  if (!v60 || !v49 || !v55 || !v56 || v57)
  {
LABEL_156:
    if (!v40)
      return PPStreamAddOperation(a1, (uint64_t)&v94, 0);
    return (char *)v40;
  }
  if (v40)
  {
    PPStreamChunkListRemoveChunk(*(_QWORD *)(a1 + 104), v40);
    v48 = DWORD2(v94);
    v54 = v95;
    LODWORD(v47) = *(_DWORD *)(v8 + 8);
    v53 = *(_QWORD *)(v8 + 16);
    v50 = (DWORD2(v94) >> 18) & 1;
    v51 = (v47 >> 18) & 1;
  }
  v72 = 0;
  v104 = v50;
  v73 = (int8x16_t)vdupq_n_s32(v48);
  memset(&v107, 0, 64);
  v105 = vand_s8((int8x8_t)vshl_u32(*(uint32x2_t *)v73.i8, (uint32x2_t)0xFFFFFFF0FFFFFFEFLL), (int8x8_t)0x100000001);
  v74 = (int8x16_t)vshlq_u32((uint32x4_t)v73, (uint32x4_t)xmmword_22A97DA00);
  v73.i64[0] = 0x300000003;
  v73.i64[1] = 0x300000003;
  v106 = (v48 >> 15) & 1;
  v102 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v54), (uint32x4_t)xmmword_22A97D9F0), v73);
  v103 = vandq_s8(v74, v73);
  v75 = (uint32x4_t)vdupq_n_s32(v47);
  LODWORD(v101) = v51;
  *(int8x8_t *)((char *)&v101 + 4) = vand_s8((int8x8_t)vshl_u32(*(uint32x2_t *)v75.i8, (uint32x2_t)0xFFFFFFF0FFFFFFEFLL), (int8x8_t)0x100000001);
  HIDWORD(v101) = (v47 >> 15) & 1;
  v99 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v53), (uint32x4_t)xmmword_22A97D9F0), v73);
  v100 = vandq_s8((int8x16_t)vshlq_u32(v75, (uint32x4_t)xmmword_22A97DA00), v73);
  while (2)
  {
    if (*(int *)((char *)&v104 + v72 * 4))
    {
      v76 = &v102;
      v77 = &v103;
      goto LABEL_145;
    }
    if (*(_DWORD *)((char *)&v101 + v72 * 4))
    {
      v76 = &v99;
      v77 = &v100;
LABEL_145:
      v107.i32[4 * v76->u32[v77->u32[v72]] + v72] = 1;
    }
    if (++v72 != 4)
      continue;
    break;
  }
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v101 = 0uLL;
  v99 = (int8x16_t)xmmword_22A97EA20;
  v100 = (int8x16_t)xmmword_22A97EA20;
  v81 = (int64x2_t)vandq_s8(*(int8x16_t *)(v8 + 8), (int8x16_t)xmmword_22A97F430);
  *(int64x2_t *)(v8 + 8) = v81;
  v82 = *(_QWORD *)v8 & 0xFFFFFFCFFFFFFFFFLL;
  *(_QWORD *)v8 = v82;
  v83 = &v107;
  do
  {
    v84 = 0;
    v85 = 0;
    do
    {
      if (v83->i32[v84])
      {
        ++v79;
        v86 = vand_s8((int8x8_t)vshl_u32(vmax_u32((uint32x2_t)__PAIR64__(v80, v84), (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vmovn_s64(v81), (uint32x2_t)0xFFFFFFEDFFFFFFEBLL), (int8x8_t)0x300000003)), (uint32x2_t)0x1300000015), (int8x8_t)0x18000000600000);
        v87.i64[0] = v86.u32[0];
        v87.i64[1] = v86.u32[1];
        v85 = 1;
        *((_DWORD *)&v101 + v84) = 1;
        v81 = (int64x2_t)vorrq_s8(vandq_s8((int8x16_t)v81, (int8x16_t)xmmword_22A97F430), v87);
        *(int64x2_t *)(v8 + 8) = v81;
        v100.i32[v84] = v80;
        v99.i32[v80] = v78;
      }
      ++v84;
    }
    while (v84 != 4);
    if (v85)
      ++v80;
    ++v78;
    ++v83;
  }
  while (v78 != 4);
  v88 = v81.i64[1] & 0xFFFFFFFFFFFE01FFLL | ((v99.i8[0] & 3) << 9) & 0x7FF | ((v99.i8[4] & 3) << 11) & 0x1FFF | ((v99.i8[8] & 3) << 13) & 0x7FFF | ((unint64_t)(v99.i8[12] & 3) << 15);
  *(_QWORD *)(v8 + 8) = v81.i64[0] & 0xFFFFFFFF80787FFFLL | ((unint64_t)(v101 & 1) << 18) & 0xFFFFFFFFF87FFFFFLL | ((unint64_t)(BYTE4(v101) & 1) << 17) & 0xFFFFFFFFF87FFFFFLL | ((unint64_t)(BYTE8(v101) & 1) << 16) & 0xFFFFFFFFF87FFFFFLL | ((BYTE12(v101) & 1u) << 15) | ((v100.i8[0] & 3) << 23) & 0xF9FFFFFF | ((unint64_t)(v100.i8[4] & 3) << 25) | ((unint64_t)(v100.i8[8] & 3) << 27) | ((unint64_t)(v100.i8[12] & 3) << 29);
  *(_QWORD *)(v8 + 16) = v88;
  *(_QWORD *)v8 = v82 | ((unint64_t)((v79 - 1) & 3) << 36);
  return (char *)v7;
}

char *AddOp(uint64_t a1, unsigned __int8 a2, _DWORD *a3, _DWORD *a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unsigned int v9;
  uint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  uint64_t *v15;
  unint64_t v16[14];
  uint64_t v17;

  v9 = 0;
  v17 = *MEMORY[0x24BDAC8D0];
  v15 = &a9;
  do
  {
    v10 = v15;
    v11 = *v15;
    v15 += 2;
    v12 = v10[1];
    v13 = &v16[2 * v9];
    *v13 = v11;
    v13[1] = v12;
    ++v9;
  }
  while (v11 | v12);
  return AddOpv(a1, a2, a3, a4, a5, v16);
}

char *SrcSwizzle(uint64_t a1, uint64_t a2, __int128 *a3, unsigned int a4, uint64_t a5, uint32x4_t *a6, uint64_t a7, uint64_t a8)
{
  int8x16_t v8;
  __int128 v9;
  __int128 v10;
  unsigned int v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v8 = vandq_s8((int8x16_t)vshlq_u32(*a6, (uint32x4_t)xmmword_22A97F440), (int8x16_t)xmmword_22A97F450);
  *(int8x8_t *)v8.i8 = vorr_s8(*(int8x8_t *)v8.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL));
  v26 = (v8.i32[0] | v8.i32[1]);
  v9 = a3[3];
  v23 = a3[2];
  v24 = v9;
  v25 = a3[4];
  v10 = a3[1];
  v21 = *a3;
  v22 = v10;
  if (a5)
  {
    DWORD2(v21) = a4;
    if (HIDWORD(v22) >= 4)
    {
      if (HIDWORD(v22) == 4)
      {
        *(_QWORD *)&v22 = __PAIR64__(HIDWORD(v21), a4);
        DWORD2(v22) = 8;
        if (a4 >= 3)
        {
          LODWORD(v22) = 2;
          DWORD1(v22) = 2 * HIDWORD(v21);
        }
      }
    }
    else
    {
      *(_QWORD *)&v22 = __PAIR64__(HIDWORD(v21), a4);
      DWORD2(v22) = 4;
    }
    return AddOp(a1, 0x39u, 0, (_DWORD *)a2, 0, (uint64_t)a6, a7, a8, (uint64_t)&v21);
  }
  else
  {
    v12 = *(_DWORD *)(a2 + 8);
    DWORD2(v21) = v12;
    if (HIDWORD(v22) >= 4)
    {
      if (HIDWORD(v22) == 4)
      {
        *(_QWORD *)&v22 = __PAIR64__(HIDWORD(v21), v12);
        DWORD2(v22) = 8;
        if (v12 >= 3)
        {
          LODWORD(v22) = 2;
          DWORD1(v22) = 2 * HIDWORD(v21);
        }
      }
    }
    else
    {
      *(_QWORD *)&v22 = __PAIR64__(HIDWORD(v21), v12);
      DWORD2(v22) = 4;
    }
    v13 = v25;
    v14 = v23;
    *(_OWORD *)(a2 + 48) = v24;
    *(_OWORD *)(a2 + 64) = v13;
    v15 = v22;
    *(_OWORD *)a2 = v21;
    *(_OWORD *)(a2 + 16) = v15;
    *(_OWORD *)(a2 + 32) = v14;
    v16 = *(_QWORD *)(a2 + 48);
    v17 = *(_QWORD *)(a2 + 56);
    switch(a6->i64[0])
    {
      case 0u:
        v18 = *(_QWORD *)(a2 + 48);
        break;
      case 1u:
        v18 = HIDWORD(v16);
        break;
      case 2u:
        v18 = *(_QWORD *)(a2 + 56);
        break;
      case 3u:
        v18 = HIDWORD(v17);
        break;
      default:
        LODWORD(v18) = 0;
        break;
    }
    switch(HIDWORD(a6->i64[0]))
    {
      case 0u:
        v19 = *(_QWORD *)(a2 + 48);
        break;
      case 1u:
        v19 = HIDWORD(v16);
        break;
      case 2u:
        v19 = *(_QWORD *)(a2 + 56);
        break;
      case 3u:
        v19 = HIDWORD(v17);
        break;
      default:
        LODWORD(v19) = 0;
        break;
    }
    switch(a6->i32[2])
    {
      case 0:
        v20 = *(_QWORD *)(a2 + 48);
        break;
      case 1:
        v20 = HIDWORD(v16);
        break;
      case 2:
        v20 = *(_QWORD *)(a2 + 56);
        break;
      case 3:
        v20 = HIDWORD(v17);
        break;
      default:
        LODWORD(v20) = 0;
        break;
    }
    switch(a6->i32[3])
    {
      case 0:
        break;
      case 1:
        v16 >>= 32;
        break;
      case 2:
        v16 = *(_QWORD *)(a2 + 56);
        break;
      case 3:
        v16 = HIDWORD(v17);
        break;
      default:
        LODWORD(v16) = 0;
        break;
    }
    *(_QWORD *)(a2 + 48) = v18 | ((unint64_t)v19 << 32);
    *(_QWORD *)(a2 + 56) = v20 | ((unint64_t)v16 << 32);
    return *(char **)(*(_QWORD *)(a1 + 104) + 8);
  }
}

char *DstSwizzleMask(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint32x4_t *a5, uint32x4_t *a6, uint64_t a7, uint64_t a8)
{
  int8x16_t v8;
  uint64_t v10;

  v8 = vorrq_s8(vandq_s8((int8x16_t)vshlq_u32(*a5, (uint32x4_t)xmmword_22A97F460), (int8x16_t)xmmword_22A97F490), vandq_s8((int8x16_t)vshlq_u32(*a6, (uint32x4_t)xmmword_22A97F470), (int8x16_t)xmmword_22A97F480));
  *(int8x8_t *)v8.i8 = vorr_s8(*(int8x8_t *)v8.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL));
  v10 = (v8.i32[0] | v8.i32[1]);
  if (a4)
    return AddOp(a1, 0x6Eu, 0, a2, &v10, (uint64_t)a6, a7, a8, a3);
  else
    return AddOp(a1, 0, 0, a2, &v10, (uint64_t)a6, a7, a8, a3);
}

char *SetAddressRegister(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v10;
  uint64_t v11;
  int v12;
  _OWORD v14[4];
  __int128 v15;
  _BYTE v16[80];
  __int128 v17;
  __int128 v18;

  v15 = 0u;
  memset(v14, 0, sizeof(v14));
  *(_QWORD *)&v10 = 0x100000001;
  *((_QWORD *)&v10 + 1) = 0x100000001;
  v17 = v10;
  v18 = xmmword_22A97F4A0;
  v11 = **((_QWORD **)a1 + 5);
  if (v11)
  {
    *(_OWORD *)((char *)v14 + 8) = v17;
    v12 = *(_DWORD *)(v11 + 24);
    LODWORD(v14[0]) = 4;
    DWORD1(v14[0]) = v12;
    *(_OWORD *)((char *)&v14[1] + 8) = v18;
    *(_OWORD *)((char *)&v14[2] + 8) = xmmword_22A97D460;
    *((_QWORD *)&v14[3] + 1) = 0x300000002;
    v15 = *a1;
  }
  else
  {
    AddBinding(a1, (uint64_t)v14, (uint64_t)v16, 4u, &v17);
  }
  return AddOp((uint64_t)a1, 0x48u, 0, v14, 0, a6, a7, a8, a2);
}

char *Load(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *result;
  _BYTE v17[48];
  __int128 v18;
  __int128 v19;

  switch(*(_DWORD *)(a3 + 40))
  {
    case 1:
      SetAddressRegister(a1, a4, a3, a4, a5, a6, a7, a8);
      v11 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)v17 = *(_OWORD *)a3;
      *(_OWORD *)&v17[16] = v11;
      v12 = *(_OWORD *)(a3 + 48);
      *(_OWORD *)&v17[32] = *(_OWORD *)(a3 + 32);
      v18 = v12;
      v19 = *(_OWORD *)(a3 + 64);
      *(_OWORD *)&v17[24] = *(_OWORD *)(a2 + 24);
      *(_OWORD *)&v17[8] = *(_OWORD *)(a2 + 8);
      result = AddOp((uint64_t)a1, 0, 0, (_DWORD *)a2, 0, v13, v14, v15, (uint64_t)v17);
      break;
    case 2:
      result = AddOp((uint64_t)a1, 0x7Au, 0, (_DWORD *)a2, 0, a6, a7, a8, a4);
      break;
    case 3:
      goto LABEL_6;
    case 4:
      *(_QWORD *)v17 = 116737;
LABEL_6:
      result = AddOp((uint64_t)a1, 0x98u, 0, (_DWORD *)a2, 0, a6, a7, a8, a4);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

char *glpPrimitiveTypeToString(unsigned int a1)
{
  if (a1 >= 0x4F)
    abort();
  return off_24F4B0410[a1];
}

uint64_t glpGetVectorType(int a1, int a2)
{
  char *v2;

  if ((a2 - 5) <= 0xFFFFFFFB)
    goto LABEL_14;
  if (a1 <= 8)
  {
    if (a1 == 1)
    {
      v2 = (char *)&GLP_VECTOR_TYPES + 4 * (a2 - 1);
      return *(unsigned int *)v2;
    }
    if (a1 == 5)
    {
      v2 = (char *)&GLP_VECTOR_TYPES + 4 * (a2 - 1) + 32;
      return *(unsigned int *)v2;
    }
LABEL_14:
    abort();
  }
  if (a1 == 9)
  {
    v2 = (char *)&GLP_VECTOR_TYPES + 4 * (a2 - 1) + 48;
    return *(unsigned int *)v2;
  }
  if (a1 == 36)
  {
    v2 = (char *)&GLP_VECTOR_TYPES + 4 * (a2 - 1) + 64;
    return *(unsigned int *)v2;
  }
  if (a1 != 62)
    goto LABEL_14;
  v2 = (char *)&GLP_VECTOR_TYPES + 4 * (a2 - 1) + 16;
  return *(unsigned int *)v2;
}

uint64_t glpPrimitiveTypeGetGLType(unsigned int a1)
{
  if (a1 >= 0x4F)
    abort();
  return dword_22A97F864[a1];
}

uint64_t glpPrimitiveTypeGetCategory(unsigned int a1)
{
  if (a1 >= 0x4F)
    abort();
  return dword_22A97F9A0[a1];
}

uint64_t glpPrimitiveVectorGetLength(uint64_t a1)
{
  int v1;
  uint64_t result;

  v1 = a1;
  result = 2;
  switch(v1)
  {
    case 2:
    case 6:
    case 10:
    case 37:
    case 63:
      return result;
    case 3:
    case 4:
      result = a1;
      break;
    case 7:
    case 11:
    case 38:
    case 64:
      result = 3;
      break;
    case 8:
    case 12:
    case 39:
    case 65:
      result = 4;
      break;
    default:
      abort();
  }
  return result;
}

uint64_t glpPrimitiveVectorGetElementType(int a1)
{
  uint64_t result;

  result = 1;
  switch(a1)
  {
    case 2:
    case 3:
    case 4:
      return result;
    case 6:
    case 7:
    case 8:
      result = 5;
      break;
    case 10:
    case 11:
    case 12:
      result = 9;
      break;
    case 37:
    case 38:
    case 39:
      result = 36;
      break;
    case 63:
    case 64:
    case 65:
      result = 62;
      break;
    default:
      abort();
  }
  return result;
}

uint64_t glpPrimitiveMatrixGetColumns(int a1)
{
  uint64_t result;

  result = 2;
  switch(a1)
  {
    case 13:
    case 22:
    case 23:
    case 66:
    case 69:
    case 70:
      return result;
    case 14:
    case 24:
    case 25:
    case 67:
    case 71:
    case 72:
      result = 3;
      break;
    case 15:
    case 26:
    case 27:
    case 68:
    case 73:
    case 74:
      result = 4;
      break;
    default:
      abort();
  }
  return result;
}

uint64_t glpPrimitiveMatrixGetRows(int a1)
{
  uint64_t result;

  result = 2;
  switch(a1)
  {
    case 13:
    case 24:
    case 26:
    case 66:
    case 71:
    case 73:
      return result;
    case 14:
    case 22:
    case 27:
    case 67:
    case 69:
    case 74:
      result = 3;
      break;
    case 15:
    case 23:
    case 25:
    case 68:
    case 70:
    case 72:
      result = 4;
      break;
    default:
      abort();
  }
  return result;
}

uint64_t glpPrimitiveMatrixGetColumnType(int a1)
{
  uint64_t result;

  result = 2;
  switch(a1)
  {
    case 13:
    case 24:
    case 26:
      return result;
    case 14:
    case 22:
    case 27:
      result = 3;
      break;
    case 15:
    case 23:
    case 25:
      result = 4;
      break;
    case 66:
    case 71:
    case 73:
      result = 63;
      break;
    case 67:
    case 69:
    case 74:
      result = 64;
      break;
    case 68:
    case 70:
    case 72:
      result = 65;
      break;
    default:
      abort();
  }
  return result;
}

uint64_t glpPrimitiveMatrixGetRowType(int a1)
{
  uint64_t result;

  result = 2;
  switch(a1)
  {
    case 13:
    case 22:
    case 23:
      return result;
    case 14:
    case 24:
    case 25:
      result = 3;
      break;
    case 15:
    case 26:
    case 27:
      result = 4;
      break;
    case 66:
    case 69:
    case 70:
      result = 63;
      break;
    case 67:
    case 71:
    case 72:
      result = 64;
      break;
    case 68:
    case 73:
    case 74:
      result = 65;
      break;
    default:
      abort();
  }
  return result;
}

uint64_t glpPrimitiveMatrixGetElementType(int a1)
{
  uint64_t result;

  result = 1;
  switch(a1)
  {
    case 13:
    case 14:
    case 15:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
      return result;
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
      result = 62;
      break;
    default:
      abort();
  }
  return result;
}

uint64_t glpPrimitiveSamplerGetPPTextarget(int a1)
{
  uint64_t result;

  result = 4;
  switch(a1)
  {
    case 16:
    case 40:
    case 48:
      return result;
    case 17:
    case 41:
    case 49:
      result = 3;
      break;
    case 18:
    case 42:
    case 50:
      result = 1;
      break;
    case 19:
    case 43:
    case 51:
      result = 0;
      break;
    case 20:
      result = 7;
      break;
    case 21:
      result = 6;
      break;
    case 28:
    case 44:
    case 52:
      result = 2;
      break;
    case 29:
      result = 5;
      break;
    case 30:
    case 45:
    case 53:
      result = 9;
      break;
    case 31:
    case 46:
    case 54:
      result = 10;
      break;
    case 32:
    case 47:
    case 55:
      result = 13;
      break;
    case 33:
      result = 11;
      break;
    case 34:
      result = 12;
      break;
    case 35:
      result = 8;
      break;
    case 56:
    case 58:
    case 60:
      result = 14;
      break;
    case 57:
    case 59:
    case 61:
      result = 15;
      break;
    case 75:
    case 77:
    case 78:
      result = 16;
      break;
    case 76:
      result = 17;
      break;
    default:
      abort();
  }
  return result;
}

uint64_t glpPrimitiveSamplerGetPPDatatype(int a1)
{
  uint64_t result;

  result = 0;
  switch(a1)
  {
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 56:
    case 57:
    case 75:
    case 76:
      return result;
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 77:
      result = 2;
      break;
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 60:
    case 61:
    case 78:
      result = 3;
      break;
    default:
      abort();
  }
  return result;
}

uint64_t glpPrimitiveTypeGetScalarType(uint64_t a1)
{
  uint64_t result;

  switch(glpPrimitiveTypeGetCategory(a1))
  {
    case 1u:
      result = a1;
      break;
    case 2u:
      result = glpPrimitiveVectorGetElementType(a1);
      break;
    case 3u:
      result = glpPrimitiveMatrixGetElementType(a1);
      break;
    default:
      abort();
  }
  return result;
}

uint64_t glpPrimitiveTypeReplaceScalarType(uint64_t a1, uint64_t a2)
{
  int Length;
  int Columns;
  int Rows;
  char *v8;

  switch(glpPrimitiveTypeGetCategory(a1))
  {
    case 1u:
      return a2;
    case 2u:
      Length = glpPrimitiveVectorGetLength(a1);
      return glpGetVectorType(a2, Length);
    case 3u:
      Columns = glpPrimitiveMatrixGetColumns(a1);
      Rows = glpPrimitiveMatrixGetRows(a1);
      if ((_DWORD)a2 == 62)
      {
        v8 = (char *)&GLP_MATRIX_TYPES + 12 * (Columns - 2) + 4 * (Rows - 2) + 36;
      }
      else
      {
        if ((_DWORD)a2 != 1)
LABEL_9:
          abort();
        v8 = (char *)&GLP_MATRIX_TYPES + 12 * (Columns - 2) + 4 * (Rows - 2);
      }
      return *(unsigned int *)v8;
    default:
      goto LABEL_9;
  }
}

uint64_t glpPrimitiveTypeGetScalarCount(uint64_t a1)
{
  uint64_t result;
  int Columns;

  result = glpPrimitiveTypeGetCategory(a1);
  switch((int)result)
  {
    case 1:
      return result;
    case 2:
      result = glpPrimitiveVectorGetLength(a1);
      break;
    case 3:
      Columns = glpPrimitiveMatrixGetColumns(a1);
      result = glpPrimitiveMatrixGetRows(a1) * Columns;
      break;
    default:
      abort();
  }
  return result;
}

uint64_t glpPrimitiveTypeGetBytesPerComponent(uint64_t a1)
{
  unsigned int ScalarType;

  ScalarType = glpPrimitiveTypeGetScalarType(a1);
  if (ScalarType > 0x3E)
    goto LABEL_7;
  if (((1 << ScalarType) & 0x1000000222) == 0)
  {
    if (ScalarType == 62)
      return 8;
LABEL_7:
    abort();
  }
  return 4;
}

uint64_t glpPrimitiveTypeGetMaxComponentsPerVec4(uint64_t a1)
{
  unsigned int ScalarType;
  unsigned int v2;

  ScalarType = glpPrimitiveTypeGetScalarType(a1);
  if (ScalarType > 0x3E)
    goto LABEL_7;
  if (((1 << ScalarType) & 0x1000000222) == 0)
  {
    if (ScalarType == 62)
    {
      v2 = 8;
      return 0x10 / v2;
    }
LABEL_7:
    abort();
  }
  v2 = 4;
  return 0x10 / v2;
}

uint64_t glpPrimitiveTypeGetNumVec4s(uint64_t a1)
{
  uint64_t ColumnType;
  int Category;
  int Columns;
  char ScalarCount;
  unsigned __int8 MaxComponentsPerVec4;

  ColumnType = a1;
  Category = glpPrimitiveTypeGetCategory(a1);
  if ((Category - 1) >= 2)
  {
    if (Category != 3)
      abort();
    Columns = glpPrimitiveMatrixGetColumns(ColumnType);
    ColumnType = glpPrimitiveMatrixGetColumnType(ColumnType);
  }
  else
  {
    Columns = 1;
  }
  ScalarCount = glpPrimitiveTypeGetScalarCount(ColumnType);
  MaxComponentsPerVec4 = glpPrimitiveTypeGetMaxComponentsPerVec4(ColumnType);
  return Columns * ((ScalarCount + MaxComponentsPerVec4 - 1) / MaxComponentsPerVec4);
}

uint64_t glpPrimitiveTypeGetByteStride(uint64_t a1)
{
  return 16 * glpPrimitiveTypeGetNumVec4s(a1);
}

char *glpQualifierName(unsigned int a1)
{
  if (a1 >= 0x19)
    abort();
  return off_24F4B0688[a1];
}

uint64_t glpMakeExpectedSignatureFromCall(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *Allocator;
  char *PrimitiveType;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x24BDAC8D0];
  v6 = glpCallNodeGetArgCount(a2);
  v7 = v6;
  v8 = v6;
  v9 = MEMORY[0x24BDAC7A8](v6);
  v11 = (char *)v21 - ((v10 + 15) & 0xFFFFFFFF0);
  MEMORY[0x24BDAC7A8](v9);
  v14 = (char *)v21 - v13;
  if (v12 >= 0x200)
    v15 = 512;
  else
    v15 = v12;
  bzero((char *)v21 - v13, v15);
  if (v7)
  {
    v16 = 0;
    do
    {
      v17 = glpCallNodeGetArg(a2, v16);
      *(_QWORD *)(a3 + 8 * v16) = glpASTNodeGetSaType(v17);
      *(_QWORD *)&v11[8 * v16] = 0;
      *(_QWORD *)&v14[8 * v16++] = 0;
    }
    while (v8 != v16);
  }
  Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
  PrimitiveType = glpGetPrimitiveType(0);
  return glpMakeFunctionType(Allocator, (uint64_t)PrimitiveType, v8, a3, (uint64_t)v11, (uint64_t)v14);
}

uint64_t glpLookUpAndAnalyzeCall(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7)
{
  uint64_t NameTable;
  uint64_t v15;
  _QWORD *Allocator;
  char *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t **v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t **InfoLog;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *FunctionObject;
  uint64_t v35;
  uint64_t ReturnType;
  uint64_t **v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  __n128 v42;
  __n128 v43;
  __n128 v44;
  _QWORD v45[5];
  _QWORD v46[8];
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  int v54;

  NameTable = glpCompilerGetNameTable(a1);
  v51 = 0;
  v52 = &v51;
  v53 = 0x2000000000;
  v54 = 0;
  v47 = 0;
  v48 = &v47;
  v49 = 0x2000000000;
  v50 = 0;
  v15 = MEMORY[0x24BDAC760];
  v46[0] = MEMORY[0x24BDAC760];
  v46[1] = 0x40000000;
  v46[2] = __glpLookUpAndAnalyzeCall_block_invoke;
  v46[3] = &unk_24F4B0758;
  v46[4] = &v51;
  v46[5] = &v47;
  v46[6] = NameTable;
  v46[7] = a1;
  glpNameTableGet(NameTable, a3, a4, 0, (uint64_t)v46);
  if (v48[3])
  {
    if (*((_DWORD *)v52 + 6) == 4)
    {
      Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
      v17 = (char *)glpAggregateTypeMangleName(a5, (uint64_t)a3, a4, Allocator);
      v45[0] = v15;
      v45[1] = 0x40000000;
      v45[2] = __glpLookUpAndAnalyzeCall_block_invoke_2;
      v45[3] = &unk_24F4B0780;
      v45[4] = &v47;
      if (glpNameTableGet(NameTable, v17, v18, 0, (uint64_t)v45))
        *((_DWORD *)v52 + 6) = 5;
    }
  }
  v19 = v48;
  v20 = v48[3];
  if (!v20 || (v21 = v52, *((_DWORD *)v52 + 6) == 5) && (*(_BYTE *)(v20 + 9) & 0x80) != 0)
  {
    if (!glpOperatorAsFunctionError(a1, a3, a4, a6, a2))
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a2, &v44);
      glpLogMessage(InfoLog, 0, (uint64_t)&v44, "Call to undeclared function '%.*s'", v28, v29, v30, v31, a4);
    }
LABEL_12:
    v32 = 0;
  }
  else
  {
    *(_QWORD *)a7 = 0;
    switch(*((_DWORD *)v21 + 6))
    {
      case 0:
      case 1:
      case 2:
      case 3:
      case 8:
        v22 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v42);
        glpLogMessage(v22, 0, (uint64_t)&v42, "Call to non-function '%.*s'", v23, v24, v25, v26, a4);
        goto LABEL_12;
      case 4:
        if (!glpAnalyzeCallToOverload(a1, (uint64_t *)v19[3], a2))
          goto LABEL_12;
        goto LABEL_19;
      case 5:
        FunctionObject = (uint64_t *)v19[3];
        goto LABEL_18;
      case 6:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xD:
        abort();
      case 7:
        v35 = v19[3];
        *(_QWORD *)a7 = v35;
        FunctionObject = (uint64_t *)glpSubroutineTypeGetFunctionObject(*(_QWORD *)(v35 + 16));
        if (!glpAnalyzeCallToFunction(a1, FunctionObject, a2))
        {
          glpSubroutineTypeGetName(*(_QWORD *)(*(_QWORD *)a7 + 16));
          v37 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(a2, &v43);
          glpLogMessage(v37, 0, (uint64_t)&v43, "Arguments of call to subroutine uniform '%.*s' cannot be converted to match its type ('%.*s')", v38, v39, v40, v41, *(_DWORD *)(*(_QWORD *)a7 + 8));
          goto LABEL_12;
        }
LABEL_18:
        ReturnType = glpFunctionTypeGetReturnType(*FunctionObject);
        glpASTNodeSetSaType(a2, ReturnType);
        glpFunctionCallNodeSetExtra(a2, (uint64_t)FunctionObject);
LABEL_19:
        v32 = 1;
        break;
      default:
        goto LABEL_19;
    }
  }
  _Block_object_dispose(&v47, 8);
  _Block_object_dispose(&v51, 8);
  return v32;
}

_QWORD *__glpLookUpAndAnalyzeCall_block_invoke(_QWORD *result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  _QWORD *v6;

  v6 = result;
  if (a2 == 7 || a2 == 4)
  {
    *(_DWORD *)(*(_QWORD *)(result[4] + 8) + 24) = a2;
    *(_QWORD *)(*(_QWORD *)(result[5] + 8) + 24) = a3;
LABEL_4:
    *a5 = 1;
    return result;
  }
  result = (_QWORD *)glpNameTableGetGLSLVersion(result[6]);
  if ((_DWORD)result != 1)
  {
    result = (_QWORD *)glpCompilerGetIOSVersion(v6[7]);
    if ((int)result >= 9)
      goto LABEL_4;
  }
  return result;
}

uint64_t __glpLookUpAndAnalyzeCall_block_invoke_2(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

unint64_t glpCalculateCallPrecision(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  unint64_t v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t SaFlags;
  char v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;

  v5 = (a3[1] >> 6) & 0x20 | ((unint64_t)((a3[1] & 0x1800) != 0) << 6);
  v6 = glpCallNodeGetArgCount(a2);
  v7 = v5;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v7 = v5;
    v10 = v6;
    do
    {
      v11 = glpCallNodeGetArg(a2, v8);
      v12 = *(_QWORD *)(a3[10] + 8 * v8);
      SaFlags = glpASTNodeGetSaFlags(v11);
      v14 = glpASTNodeGetSaFlags(v11);
      v15 = v14 & 0x1F;
      if ((v14 & 0x1F) != 0 && v15 != 31 && v15 > v9 && (*(_BYTE *)(v12 + 48) & 1) != 0)
        v9 = v14 & 0x1F;
      v7 &= SaFlags;
      ++v8;
    }
    while (v10 != v8);
    if (v9)
    {
LABEL_12:
      if (!v5)
        return v9;
      goto LABEL_13;
    }
  }
  v16 = a3[9];
  if (v16)
  {
    v9 = *(_QWORD *)(v16 + 48) & 0x1FLL;
    goto LABEL_12;
  }
  v9 = 0;
  if (!v5)
    return v9;
LABEL_13:
  if ((v9 & 1) != 0)
    v17 = 0;
  else
    v17 = v9;
  v18 = glpASTNodeGetSaFlags(a2);
  glpASTNodeSetSaFlags(a2, v17 | v7 | v18);
  return v9;
}

uint64_t glpHandleArgumentConversions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int **v8;
  _BOOL4 DoesTypeRequirePrecision;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t Expr;
  uint64_t v14;
  uint64_t Offset;
  uint64_t v16;
  uint64_t OffsetExpr;
  uint64_t VectorElementExpr;
  uint64_t v19;
  unsigned int *SaType;
  uint64_t v21;
  uint64_t DefaultPrecisionForType;
  unsigned int *v23;
  char SaFlags;
  unsigned int *v25;
  uint64_t v26;
  uint64_t TypeConversionNode;
  uint64_t v28;
  uint64_t **v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t **InfoLog;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t **v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t **v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t **v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD *Allocator;
  char v57;
  char v58;
  uint64_t **v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  __n128 v64;
  __n128 v65;
  __n128 v66;
  __n128 v67;
  __n128 v68;
  __n128 v69;
  __n128 v70[2];

  v8 = *(unsigned int ***)(a3 + 72);
  if (v8)
  {
    DoesTypeRequirePrecision = glpCompilerDoesTypeRequirePrecision(a1, *v8);
    v10 = (a4 & 1) != 0 ? 0 : a4;
    if (!DoesTypeRequirePrecision)
      a4 = v10;
  }
  if (!*(_DWORD *)(a3 + 88))
    return 1;
  v11 = 0;
  if ((a4 & 1) != 0)
    v12 = 0;
  else
    v12 = a4;
  while (1)
  {
    Expr = glpCallNodeGetArg(a2, v11);
    if (glpIsTypeConversionNode(Expr))
      Expr = glpUnaryOperatorNodeGetExpr(Expr);
    v14 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 80) + 8 * v11) + 48);
    if ((v14 & 0x800000) != 0)
    {
      if ((glpASTNodeGetSaFlags(Expr) & 0x60) == 0)
      {
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, v70);
        glpLogMessage(InfoLog, 0, (uint64_t)v70, "Argument %d to function '%.*s' must be a constant expression", v36, v37, v38, v39, v11 + 1);
        return 0;
      }
      v14 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 80) + 8 * v11) + 48);
    }
    if ((v14 & 0x1000000) != 0)
    {
      if (!glpIsLValueNode(Expr) || (*(_BYTE *)(glpLValueNodeGetVariableExtra(Expr) + 51) & 0x20) == 0)
      {
        v30 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v69);
        glpLogMessage(v30, 0, (uint64_t)&v69, "Argument %d to function '%.*s' must be a reference to a stage in variable", v31, v32, v33, v34, v11 + 1);
        return 0;
      }
      Offset = glpDerefNodeGetOffset(Expr);
      if (Offset)
      {
        v16 = Offset;
        OffsetExpr = glpOffsetNodeGetOffsetExpr(Offset);
        VectorElementExpr = glpOffsetNodeGetVectorElementExpr(v16);
        if (OffsetExpr)
        {
          if (!glpIsConstantNode(OffsetExpr))
            break;
        }
        if (VectorElementExpr && !glpIsConstantNode(VectorElementExpr))
          break;
      }
    }
    if ((*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a3 + 80) + 8 * v11) + 51) & 4) != 0)
    {
      v19 = glpCommaResult(Expr);
      if (glpASTNodeGetKind(v19) != 81)
      {
        v40 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v66);
        glpLogMessage(v40, 0, (uint64_t)&v66, "'out' or 'inout' argument %d to function '%.*s' must be an lvalue", v41, v42, v43, v44, v11 + 1);
        return 0;
      }
      if ((glpASTNodeGetSaFlags(v19) & 0x360) != 0)
      {
        v45 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v67);
        glpLogMessage(v45, 0, (uint64_t)&v67, "'out' or 'inout' argument %d to function '%.*s' must be writable", v46, v47, v48, v49, v11 + 1);
        return 0;
      }
    }
    SaType = (unsigned int *)glpASTNodeGetSaType(Expr);
    if (glpCompilerDoesTypeRequirePrecision(a1, SaType))
    {
      v21 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 80) + 8 * v11) + 48);
      if ((v21 & 2) != 0)
      {
        DefaultPrecisionForType = glpASTNodeGetSaFlags(Expr) & 0x1F;
      }
      else
      {
        if ((v21 & 1) != 0)
          DefaultPrecisionForType = v12;
        else
          DefaultPrecisionForType = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 80) + 8 * v11) + 48) & 0x1FLL;
        if ((v21 & 1) != 0 && !a4)
        {
          DefaultPrecisionForType = v12;
          if ((glpASTNodeGetSaFlags(Expr) & 1) == 0)
          {
            v23 = (unsigned int *)glpASTNodeGetSaType(Expr);
            DefaultPrecisionForType = glpGetDefaultPrecisionForType(a1, v23);
            if (!DefaultPrecisionForType)
            {
              v55 = glpASTNodeGetSaType(Expr);
              Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
              glpTypeHumanReadableDescription(v55, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
              v58 = v57;
              v59 = (uint64_t **)glpCompilerGetInfoLog(a1);
              glpASTNodeGetLocation(a2, &v65);
              glpLogMessage(v59, 0, (uint64_t)&v65, "Expression of type '%.*s' - precision can not be inferred and no default precision available", v60, v61, v62, v63, v58);
              return 0;
            }
          }
        }
      }
      SaFlags = glpASTNodeGetSaFlags(Expr);
      v25 = (unsigned int *)glpASTNodeGetSaType(Expr);
      if (!glpTypeGetKind(v25) && DefaultPrecisionForType && DefaultPrecisionForType != (SaFlags & 0x1F))
      {
        if ((SaFlags & 0x1F) != 0x1FLL && (SaFlags & 0x1F) != 0)
        {
          v26 = glpCompilerGetAllocator(a1);
          glpASTNodeGetLocation(a2, &v64);
          TypeConversionNode = glpMakeTypeConversionNode(v26, &v64, **(_QWORD **)(*(_QWORD *)(a3 + 80) + 8 * v11), DefaultPrecisionForType);
          glpUnaryOperatorNodeSetExpr(TypeConversionNode, Expr);
          v28 = glpSANode(a1, TypeConversionNode);
          glpCallNodeSetArg(a2, v11, v28);
        }
        else
        {
          glpPushdownPrecision(a1, Expr, DefaultPrecisionForType);
        }
      }
    }
    if (++v11 >= (unint64_t)*(unsigned int *)(a3 + 88))
      return 1;
  }
  v50 = (uint64_t **)glpCompilerGetInfoLog(a1);
  glpASTNodeGetLocation(a2, &v68);
  glpLogMessage(v50, 0, (uint64_t)&v68, "Argument %d to function '%.*s' must be a direct reference to a stage in variable", v51, v52, v53, v54, v11 + 1);
  return 0;
}

uint64_t glpLowerCallToBodilessPPStreamOp(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int *SaType;
  uint64_t **InfoLog;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t PrimitiveType;
  uint64_t Allocator;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  unsigned int *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *MutableValue;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  unsigned int *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  unsigned int *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  int v55;
  int v56;
  unsigned int i;
  _QWORD *v58;
  uint64_t v59;
  uint64_t SaFlags;
  uint64_t v61;
  char v62;
  char v64;
  __n128 v65;
  __n128 v66;
  __n128 v67;
  __n128 v68;
  __n128 v69;
  __n128 v70;

  SaType = (unsigned int *)glpASTNodeGetSaType(a2);
  if (glpTypeGetKind(SaType))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v70);
    glpLogMessage(InfoLog, 0, (uint64_t)&v70, "return of ppstreamop is not a primitive type", v8, v9, v10, v11, v64);
    return glpSAFailed();
  }
  else
  {
    v13 = glpASTNodeGetSaType(a2);
    PrimitiveType = glpPrimitiveTypeGetPrimitiveType(v13);
    Allocator = glpCompilerGetAllocator(a1);
    glpASTNodeGetLocation(a2, &v69);
    v16 = glpMakeUndeterminedCallNode(Allocator, &v69);
    v17 = glpCompilerGetAllocator(a1);
    glpASTNodeGetLocation(a2, &v68);
    glpMakeVariableIdentifierNode(v17, &v68, (uint64_t)"$ppstreamop", 0xF8DF7DAF0000000BLL);
    glpUndeterminedCallNodeSetCallee(v16, v18);
    v19 = (_QWORD *)glpCompilerGetAllocator(a1);
    v20 = glpCompilerGetAllocator(a1);
    glpASTNodeGetLocation(a2, &v67);
    v21 = glpGetPrimitiveType(5u);
    v22 = glpCompilerGetAllocator(a1);
    v23 = (unsigned int *)glpGetPrimitiveType(5u);
    MutableValue = glpMakeMutableValue(v22, v23, 1, v24, v25, v26, v27, v28, 2);
    glpMakeConstantNode(v20, &v67, (uint64_t)v21, (uint64_t)MutableValue);
    glpCallNodeAddArg(v19, v16, v30);
    v31 = (_QWORD *)glpCompilerGetAllocator(a1);
    v32 = glpCompilerGetAllocator(a1);
    glpASTNodeGetLocation(a2, &v66);
    v33 = glpGetPrimitiveType(5u);
    v34 = glpCompilerGetAllocator(a1);
    v35 = (unsigned int *)glpGetPrimitiveType(5u);
    v41 = glpMakeMutableValue(v34, v35, 1, v36, v37, v38, v39, v40, PrimitiveType);
    glpMakeConstantNode(v32, &v66, (uint64_t)v33, (uint64_t)v41);
    glpCallNodeAddArg(v31, v16, v42);
    v43 = (_QWORD *)glpCompilerGetAllocator(a1);
    v44 = glpCompilerGetAllocator(a1);
    glpASTNodeGetLocation(a2, &v65);
    v45 = glpGetPrimitiveType(5u);
    v46 = glpCompilerGetAllocator(a1);
    v47 = (unsigned int *)glpGetPrimitiveType(5u);
    v53 = glpMakeMutableValue(v46, v47, 1, v48, v49, v50, v51, v52, *(unsigned int *)(a3 + 92));
    glpMakeConstantNode(v44, &v65, (uint64_t)v45, (uint64_t)v53);
    glpCallNodeAddArg(v43, v16, v54);
    v55 = glpCallNodeGetArgCount(a2);
    if (v55)
    {
      v56 = v55;
      for (i = 0; i != v56; ++i)
      {
        v58 = (_QWORD *)glpCompilerGetAllocator(a1);
        v59 = glpCallNodeGetArg(a2, i);
        glpCallNodeAddArg(v58, v16, v59);
      }
    }
    SaFlags = glpASTNodeGetSaFlags(a2);
    v61 = glpSANode(a1, v16);
    v12 = v61;
    if ((unint64_t)(v61 + 1) >= 2)
    {
      v62 = glpASTNodeGetSaFlags(v61);
      glpASTNodeSetSaFlags(v12, SaFlags & 0xFFFFFFFFFFFFFFE0 | v62 & 0x1F);
    }
  }
  return v12;
}

uint64_t glpHandleSpecialOperatorFunction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Allocator;
  uint64_t NegateNode;
  uint64_t v9;
  uint64_t SaType;
  uint64_t SaFlags;
  __n128 v12;

  if (glpStringsEqual("$OP_pos", 0xA31C9B1600000007, *(char **)(a3 + 24), *(_QWORD *)(a3 + 32)))
    return glpCallNodeGetArg(a2, 0);
  if (!glpStringsEqual("$OP_neg", 0x34DF279C00000007, *(char **)(a3 + 24), *(_QWORD *)(a3 + 32)))
    abort();
  Allocator = glpCompilerGetAllocator(a1);
  glpASTNodeGetLocation(a2, &v12);
  NegateNode = glpMakeNegateNode(Allocator, &v12);
  v9 = glpCallNodeGetArg(a2, 0);
  glpUnaryOperatorNodeSetExpr(NegateNode, v9);
  SaType = glpASTNodeGetSaType(v9);
  glpASTNodeSetSaType(NegateNode, SaType);
  SaFlags = glpASTNodeGetSaFlags(v9);
  glpASTNodeSetSaFlags(NegateNode, SaFlags);
  return NegateNode;
}

uint64_t glpSALowerCallArgsToAssignment(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v7;
  uint64_t **v8;
  uint64_t Allocator;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t Offset;
  uint64_t v21;
  uint64_t OffsetExpr;
  uint64_t VectorElementExpr;
  uint64_t SaType;
  char SaFlags;
  _QWORD *v26;
  uint64_t v27;
  uint64_t **v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t LValueNode;
  _QWORD *v32;
  uint64_t v33;
  uint64_t AssignFragment;
  char v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t i;
  uint64_t v39;
  uint64_t Expr;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char v46;
  uint64_t TypeConversionNode;
  uint64_t v48;
  _QWORD *v49;
  char v50;
  uint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t TypedVariableFragment;
  uint64_t v62;
  char v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t Extra;
  _QWORD *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  _QWORD *v73;
  char *PrimitiveType;
  uint64_t v75;
  uint64_t v76;
  char v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  char v81;
  uint64_t v83;
  uint64_t v84;
  uint64_t *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  __n128 v89;
  uint64_t v90;
  __n128 v91;
  uint64_t v92;
  uint64_t v93;

  v86 = a4;
  v93 = *MEMORY[0x24BDAC8D0];
  v7 = glpCallNodeGetArgCount(a2);
  v84 = a3;
  v8 = *(uint64_t ***)(a3 + 80);
  v91 = 0uLL;
  v92 = 0;
  glpASTNodeGetLocation(a2, &v91);
  Allocator = glpCompilerGetAllocator(a1);
  v89 = v91;
  v90 = v92;
  glpMakeCommaExprNode(Allocator, &v89, 0);
  v87 = v10;
  v85 = &v83;
  MEMORY[0x24BDAC7A8](v10);
  v13 = (uint64_t *)((char *)&v83 - v12);
  if (v11 >= 0x200)
    v14 = 512;
  else
    v14 = v11;
  bzero((char *)&v83 - v12, v14);
  if (v7)
  {
    v15 = 0;
    v16 = v7;
    v17 = v13;
    do
    {
      *v17 = 0;
      v18 = glpCallNodeGetArg(a2, v15);
      if ((*((_BYTE *)v8[v15] + 51) & 2) != 0)
      {
        v19 = v18;
        if (glpIsConstantNode(v18)
          || glpIsLValueNode(v19)
          && ((Offset = glpDerefNodeGetOffset(v19)) == 0
           || ((v21 = Offset,
                OffsetExpr = glpOffsetNodeGetOffsetExpr(Offset),
                VectorElementExpr = glpOffsetNodeGetVectorElementExpr(v21),
                !OffsetExpr)
            || glpIsConstantNode(OffsetExpr))
           && (!VectorElementExpr || glpIsConstantNode(VectorElementExpr))))
        {
          *v17 = v19;
        }
        else
        {
          v89.n128_u64[0] = 0;
          SaType = glpASTNodeGetSaType(v19);
          SaFlags = glpASTNodeGetSaFlags(v19);
          glpMakeTemporary(a1, SaType, SaFlags & 0x1F, v19, (uint64_t *)&v89, v17);
          v26 = (_QWORD *)glpCompilerGetAllocator(a1);
          glpCommaExprNodeAddExpr(v26, v87, v89.n128_i64[0]);
        }
      }
      ++v15;
      ++v17;
    }
    while (v16 != v15);
    v27 = v16;
    v28 = v8;
    do
    {
      if ((*((_BYTE *)*v28 + 51) & 2) != 0)
      {
        v29 = glpCompilerGetAllocator(a1);
        v30 = *v28;
        v90 = v92;
        v89 = v91;
        LValueNode = glpMakeLValueNode(v29, &v89, v30[2], v30[3], (uint64_t)v30);
        glpASTNodeSetSaType(LValueNode, **v28);
        glpASTNodeSetSaFlags(LValueNode, (*v28)[6] & 0x1F);
        v32 = (_QWORD *)glpCompilerGetAllocator(a1);
        v33 = *v13;
        v89 = v91;
        v90 = v92;
        AssignFragment = glpMakeAssignFragment(a1, &v89, LValueNode, v33);
        glpCommaExprNodeAddExpr(v32, v87, AssignFragment);
      }
      ++v28;
      ++v13;
      --v27;
    }
    while (v27);
    v35 = glpASTNodeGetSaFlags(a2);
    v36 = v86;
    glpASTNodeSetSaFlags(v86, v35 & 0x1F);
    v37 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v37, v87, v36);
    for (i = 0; i != v16; ++i)
    {
      v39 = glpCallNodeGetArg(a2, i);
      if ((*((_BYTE *)v8[i] + 51) & 4) != 0)
      {
        Expr = v39;
        v41 = glpCompilerGetAllocator(a1);
        v42 = (uint64_t)v8[i];
        v90 = v92;
        v89 = v91;
        v43 = glpMakeLValueNode(v41, &v89, *(_QWORD *)(v42 + 16), *(_QWORD *)(v42 + 24), v42);
        glpASTNodeSetSaType(v43, *v8[i]);
        glpASTNodeSetSaFlags(v43, v8[i][6] & 0x1F);
        if (glpIsTypeConversionNode(Expr))
        {
          Expr = glpUnaryOperatorNodeGetExpr(Expr);
          v44 = glpCompilerGetAllocator(a1);
          v45 = glpASTNodeGetSaType(Expr);
          v46 = glpASTNodeGetSaFlags(Expr);
          v89 = v91;
          v90 = v92;
          TypeConversionNode = glpMakeTypeConversionNode(v44, &v89, v45, v46 & 0x1F);
          glpUnaryOperatorNodeSetExpr(TypeConversionNode, v43);
          v43 = glpSANode(a1, TypeConversionNode);
        }
        v89 = v91;
        v90 = v92;
        v48 = glpMakeAssignFragment(a1, &v89, Expr, v43);
        v49 = (_QWORD *)glpCompilerGetAllocator(a1);
        glpCommaExprNodeAddExpr(v49, v87, v48);
      }
    }
  }
  else
  {
    v50 = glpASTNodeGetSaFlags(a2);
    v51 = v86;
    glpASTNodeSetSaFlags(v86, v50 & 0x1F);
    v52 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v52, v87, v51);
  }
  v53 = v84;
  if (!*(_QWORD *)(v84 + 72))
    goto LABEL_36;
  v54 = glpCompilerGetAllocator(a1);
  v55 = *(_QWORD *)(v53 + 72);
  v90 = v92;
  v89 = v91;
  v56 = glpMakeLValueNode(v54, &v89, *(_QWORD *)(v55 + 16), *(_QWORD *)(v55 + 24), v55);
  glpASTNodeSetSaType(v56, **(_QWORD **)(v53 + 72));
  glpASTNodeSetSaFlags(v56, *(_QWORD *)(*(_QWORD *)(v53 + 72) + 48) & 0x80000037FLL);
  v57 = (uint64_t)glpCompilerNewTempName(a1);
  v59 = v58;
  v88 = 0;
  v60 = glpCompilerGetAllocator(a1);
  v89 = v91;
  v90 = v92;
  TypedVariableFragment = glpMakeTypedVariableFragment(v60, &v89, v57, v59, &v88, v56);
  v62 = v88;
  v63 = glpASTNodeGetSaFlags(v56);
  glpASTNodeSetSaFlags(v62, v63 & 0x1F);
  glpASTNodeSetSaType(v88, **(_QWORD **)(v53 + 72));
  v64 = glpSANode(a1, TypedVariableFragment);
  v65 = v64;
  if ((unint64_t)(v64 + 1) > 1)
  {
    v66 = glpASTNodeGetSaFlags(v64);
    glpASTNodeSetSaFlags(v65, v66 & 0xFFFFFFFF7FFFFFFFLL);
    Extra = glpVariableDeclarationNodeGetExtra(v65);
    *(_QWORD *)(Extra + 48) &= ~0x80000000uLL;
    v68 = (_QWORD *)glpCompilerGetAllocator(a1);
    v69 = v87;
    glpCommaExprNodeAddExpr(v68, v87, v65);
    v70 = glpCompilerGetAllocator(a1);
    v89 = v91;
    v90 = v92;
    glpMakeVariableIdentifierNode(v70, &v89, v57, v59);
    v72 = glpSANode(a1, v71);
    v73 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v73, v69, v72);
    PrimitiveType = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(a2, (uint64_t)PrimitiveType);
    if (glpCompilerDoesTrackPrecision(a1) && (glpASTNodeGetSaFlags(v86) & 0x1F) == 0)
    {
      v75 = v86;
      v76 = glpASTNodeGetSaFlags(v86);
      v77 = glpASTNodeGetSaFlags(v65);
      glpASTNodeSetSaFlags(v75, v77 & 0x1F | (unint64_t)v76);
    }
  }
  else
  {
    v57 = glpSAFailed();
  }
  if ((unint64_t)(v65 + 1) >= 2)
  {
LABEL_36:
    v78 = glpASTNodeGetSaFlags(a2);
    v79 = glpASTNodeGetSaType(a2);
    glpASTNodeSetSaType(v86, v79);
    v80 = glpSANode(a1, v87);
    v57 = v80;
    if ((unint64_t)(v80 + 1) >= 2)
    {
      v81 = glpASTNodeGetSaFlags(v80);
      glpASTNodeSetSaFlags(v57, v81 & 0x1F | (unint64_t)v78);
    }
  }
  return v57;
}

uint64_t glpInlineFunction(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *Allocator;
  uint64_t PointerHash;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  size_t v16;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t Offset;
  double v21;
  uint64_t v22;
  uint64_t OffsetExpr;
  uint64_t VectorElementExpr;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t DefaultPrecisionForType;
  uint64_t *v29;
  uint64_t v30;
  unsigned int *SaType;
  uint64_t Value;
  uint64_t v33;
  char SaFlags;
  uint64_t *Temporary;
  _QWORD *v36;
  uint64_t v37;
  uint64_t LValueNode;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t TypedVariableFragment;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t Extra;
  uint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  double v53;
  uint64_t v54;
  uint64_t *v55;
  _QWORD *v56;
  uint64_t *StringBuffer;
  uint64_t v58;
  double v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t *v67;
  uint64_t Body;
  uint64_t v69;
  unint64_t v70;
  unint64_t i;
  uint64_t Expr;
  _QWORD *v73;
  uint64_t v74;
  uint64_t AssignFragment;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  char v83;
  uint64_t v85[2];
  uint64_t v86;
  __n128 v87;
  __n128 v88;
  __n128 v89;
  __n128 v90;
  uint64_t v91;
  _QWORD v92[3];
  uint64_t v93;
  uint64_t v94;
  __n128 v95;
  uint64_t v96;
  __n128 v97;
  uint64_t v98;
  uint64_t v99;

  v99 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a3 + 10) & 4) != 0)
    glpCompilerSetRequiresOutputPoints(a1, 1);
  if ((a4 & 1) != 0)
    a4 = 0;
  v97 = 0uLL;
  v98 = 0;
  glpASTNodeGetLocation(a2, &v97);
  v92[0] = a4;
  v92[1] = 0;
  v85[0] = a4;
  v92[2] = a1;
  Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
  PointerHash = glpMakePointerHash(Allocator);
  v93 = PointerHash;
  v10 = (_QWORD *)glpCompilerGetAllocator(a1);
  v11 = glpMakePointerHash(v10);
  v95 = v97;
  v94 = v11;
  v96 = v98;
  v12 = glpCompilerGetAllocator(a1);
  v90 = v97;
  v91 = v98;
  glpMakeCommaExprNode(v12, &v90, 0);
  v86 = v13;
  v85[1] = (uint64_t)v85;
  MEMORY[0x24BDAC7A8](v13);
  v15 = (char *)v85 - ((v14 + 15) & 0xFFFFFFFF0);
  if (v14 >= 0x200)
    v16 = 512;
  else
    v16 = v14;
  bzero((char *)v85 - ((v14 + 15) & 0xFFFFFFFF0), v16);
  if (*(_DWORD *)(a3 + 88))
  {
    v17 = 0;
    v18 = v15;
    while (1)
    {
      *v18 = 0;
      v19 = glpCallNodeGetArg(a2, v17);
      if (!glpIsLValueNode(v19))
        break;
      Offset = glpDerefNodeGetOffset(v19);
      if (Offset)
      {
        v22 = Offset;
        OffsetExpr = glpOffsetNodeGetOffsetExpr(Offset);
        VectorElementExpr = glpOffsetNodeGetVectorElementExpr(v22);
        if (OffsetExpr)
        {
          if (!glpIsConstantNode(OffsetExpr))
            break;
        }
        if (VectorElementExpr && !glpIsConstantNode(VectorElementExpr))
          break;
      }
      v25 = *(_QWORD *)(*(_QWORD *)(a3 + 80) + 8 * v17);
      v26 = PointerHash;
      v27 = v19;
LABEL_28:
      glpPointerHashPut(v26, v25, v27, v21);
      ++v17;
      ++v18;
      if (v17 >= *(unsigned int *)(a3 + 88))
        goto LABEL_29;
    }
    if (glpIsConstantNode(v19))
    {
      if ((glpASTNodeGetSaFlags(v19) & 2) != 0)
      {
        SaType = (unsigned int *)glpASTNodeGetSaType(v19);
        DefaultPrecisionForType = glpGetDefaultPrecisionForType(a1, SaType);
      }
      else
      {
        DefaultPrecisionForType = glpASTNodeGetSaFlags(v19) & 0x1F;
      }
      glpASTNodeSetSaFlags(v19, DefaultPrecisionForType | 0x60);
      glpASTNodeGetSaFlags(v19);
      Value = glpConstantNodeGetValue(v19);
      v90.n128_u64[0] = 0;
      v29 = *(uint64_t **)(*(_QWORD *)(a3 + 80) + 8 * v17);
      v30 = *v29;
      if (Value)
      {
        v33 = 96;
LABEL_25:
        SaFlags = glpASTNodeGetSaFlags(v19);
        Temporary = (uint64_t *)glpMakeTemporary(a1, v30, SaFlags & 0x1F | (unint64_t)v33, v19 & ((uint64_t)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 80) + 8 * v17) + 48) << 38) >> 63), (uint64_t *)&v90, v18);
        if (v90.n128_u64[0])
        {
          v36 = (_QWORD *)glpCompilerGetAllocator(a1);
          glpCommaExprNodeAddExpr(v36, v86, v90.n128_i64[0]);
        }
        v37 = glpCompilerGetAllocator(a1);
        glpASTNodeGetLocation(a2, &v89);
        LValueNode = glpMakeLValueNode(v37, &v89, Temporary[2], Temporary[3], (uint64_t)Temporary);
        glpASTNodeSetSaType(LValueNode, **(_QWORD **)(*(_QWORD *)(a3 + 80) + 8 * v17));
        glpASTNodeSetSaFlags(LValueNode, Temporary[6]);
        PointerHash = v93;
        v25 = *(_QWORD *)(*(_QWORD *)(a3 + 80) + 8 * v17);
        v26 = v93;
        v27 = LValueNode;
        goto LABEL_28;
      }
    }
    else
    {
      v90.n128_u64[0] = 0;
      v29 = *(uint64_t **)(*(_QWORD *)(a3 + 80) + 8 * v17);
      v30 = *v29;
    }
    v33 = ((unint64_t)v29[6] >> 17) & 0x100;
    goto LABEL_25;
  }
LABEL_29:
  if (*(_QWORD *)(a3 + 72))
  {
    v39 = glpCompilerNewTempName(a1);
    v41 = v40;
    v90.n128_u64[0] = 0;
    v42 = glpCompilerGetAllocator(a1);
    glpASTNodeGetLocation(a2, &v88);
    TypedVariableFragment = glpMakeTypedVariableFragment(v42, &v88, (uint64_t)v39, v41, (uint64_t *)&v90, 0);
    if ((*(_QWORD *)(*(_QWORD *)(a3 + 72) + 48) & 1) != 0)
      v44 = v85[0];
    else
      v44 = *(_QWORD *)(*(_QWORD *)(a3 + 72) + 48) & 0x1FLL;
    glpASTNodeSetSaFlags(v90.n128_i64[0], v44);
    glpASTNodeSetSaType(v90.n128_i64[0], **(_QWORD **)(a3 + 72));
    v45 = glpSANode(a1, TypedVariableFragment);
    v46 = (_QWORD *)glpCompilerGetAllocator(a1);
    v47 = v86;
    glpCommaExprNodeAddExpr(v46, v86, v45);
    v48 = glpASTNodeGetSaFlags(v45);
    glpASTNodeSetSaFlags(v45, v48 & 0xFFFFFFFF7FFFFF7FLL);
    Extra = glpVariableDeclarationNodeGetExtra(v45);
    *(_QWORD *)(Extra + 48) &= 0xFFFFFFFF7FFFFF7FLL;
    v50 = (uint64_t *)glpVariableDeclarationNodeGetExtra(v45);
    v51 = glpCompilerGetAllocator(a1);
    glpASTNodeGetLocation(a2, &v87);
    v52 = glpMakeLValueNode(v51, &v87, v50[2], v50[3], (uint64_t)v50);
    glpASTNodeSetSaType(v52, *v50);
    glpASTNodeSetSaFlags(v52, v50[6]);
    glpPointerHashPut(PointerHash, *(_QWORD *)(a3 + 72), v52, v53);
    v54 = glpCompilerGetAllocator(a1);
    v55 = (uint64_t *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(v54 + 8))(*(_QWORD *)v54, 16, "String: $return_value_inline");
    v56 = (_QWORD *)glpCompilerGetAllocator(a1);
    StringBuffer = glpMakeStringBuffer(v56);
    glpStringBufferAppendCString(StringBuffer, "$return_value_inline$");
    glpStringBufferAppendString(StringBuffer, *(_QWORD *)(a3 + 40), *(_QWORD *)(a3 + 48));
    *v55 = glpStringBufferGetString((uint64_t)StringBuffer);
    v55[1] = v58;
    glpPointerHashPut(v94, *(_QWORD *)(a3 + 72), (uint64_t)v55, v59);
    if ((*(_BYTE *)(a3 + 9) & 0x18) != 0)
    {
      v60 = glpCompilerGetAllocator(a1);
      v50[13] = (uint64_t)glpMakeMutableValue(v60, **(unsigned int ***)(a3 + 72), 0, v61, v62, v63, v64, v65, v85[0]);
    }
  }
  else
  {
    v50 = 0;
    v47 = v86;
  }
  v66 = (_QWORD *)glpCompilerGetAllocator(a1);
  v67 = (uint64_t *)glpCompilerGetAllocator(a1);
  Body = glpFunctionDefinitionNodeGetBody(*(_QWORD *)(a3 + 64));
  v69 = glpDeepCopyASTNode(v67, Body, (uint64_t (*)(uint64_t, uint64_t *, _DWORD *))saInliningNodeReplacement, (uint64_t)v92);
  glpCommaExprNodeAddExpr(v66, v47, v69);
  v70 = *(unsigned int *)(a3 + 88);
  if ((_DWORD)v70)
  {
    for (i = 0; i < v70; ++i)
    {
      if ((*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a3 + 80) + 8 * i) + 51) & 4) != 0 && *(_QWORD *)&v15[8 * i])
      {
        Expr = glpCallNodeGetArg(a2, i);
        if (!glpIsLValueNode(Expr))
          Expr = glpUnaryOperatorNodeGetExpr(Expr);
        v73 = (_QWORD *)glpCompilerGetAllocator(a1);
        v74 = *(_QWORD *)&v15[8 * i];
        v90 = v97;
        v91 = v98;
        AssignFragment = glpMakeAssignFragment(a1, &v90, Expr, v74);
        v47 = v86;
        glpCommaExprNodeAddExpr(v73, v86, AssignFragment);
        v70 = *(unsigned int *)(a3 + 88);
      }
    }
  }
  if (v50)
  {
    v76 = v50[13];
    if (v76)
    {
      v50[8] = v76;
      v50[13] = 0;
      glpCommaExprNodeClearExprs(v47);
    }
    v77 = glpCompilerGetAllocator(a1);
    v91 = v98;
    v90 = v97;
    v78 = glpMakeLValueNode(v77, &v90, v50[2], v50[3], (uint64_t)v50);
    glpASTNodeSetSaType(v78, *v50);
    glpASTNodeSetSaFlags(v78, v50[6] & 0x80000037FLL);
    v79 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v79, v47, v78);
  }
  v80 = glpASTNodeGetSaFlags(a2);
  v81 = glpSANode(a1, v47);
  v82 = v81;
  if ((unint64_t)(v81 + 1) >= 2)
  {
    v83 = glpASTNodeGetSaFlags(v81);
    glpASTNodeSetSaFlags(v82, v83 & 0x1F | (unint64_t)v80);
  }
  return v82;
}

uint64_t saInliningNodeReplacement(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v3;
  int Kind;
  uint64_t v7;
  unint64_t Extra;
  uint64_t v9;
  uint64_t v10;
  uint64_t VariableExtra;
  uint64_t v12;
  uint64_t SaFlags;
  uint64_t *v14;
  uint64_t Initializer;
  uint64_t v16;
  uint64_t Lhs;
  uint64_t Rhs;
  uint64_t Offset;
  uint64_t v20;
  uint64_t v21;
  _OWORD *v22;
  _OWORD *v23;
  __int128 v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t LValueNode;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t ValueHash;
  uint64_t v34;
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  double v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t OffsetExpr;
  uint64_t v51;
  uint64_t AddFragment;
  uint64_t BankIndex;
  unsigned int Swizzle;
  unsigned int v55;
  int v56;
  int v57;
  int v58;
  uint64_t VectorElementExpr;
  int PreSwizzlePrimitiveType;
  __n128 v61;
  uint64_t v62;
  __n128 v63;
  __n128 v64;
  _QWORD v65[7];

  v3 = a3;
  Kind = glpASTNodeGetKind(a3);
  if (Kind <= 74)
  {
    if (Kind)
    {
      if (Kind != 3)
      {
        if (Kind == 46)
        {
          Extra = glpVariableDeclarationNodeGetExtra(v3);
          v9 = *(_QWORD *)(a1 + 24);
          v65[0] = MEMORY[0x24BDAC760];
          v65[1] = 0x40000000;
          v65[2] = __saInliningNodeReplacement_block_invoke;
          v65[3] = &__block_descriptor_tmp_6;
          v65[4] = a2;
          v65[5] = Extra;
          v65[6] = v3;
          v10 = glpPointerHashCache_b(v9, Extra, (uint64_t)v65);
          VariableExtra = glpLValueNodeGetVariableExtra(v10);
          glpVariableDeclarationNodeSetExtra(v3, VariableExtra);
          v12 = *(_QWORD *)(VariableExtra + 48);
          if ((v12 & 1) != 0)
          {
            *(_QWORD *)(VariableExtra + 48) = *(_QWORD *)a1 | v12 & 0xFFFFFFFFFFFFFFE0;
            SaFlags = glpASTNodeGetSaFlags(v3);
            glpASTNodeSetSaFlags(v3, SaFlags & 0xFFFFFFFFFFFFFFE0 | *(_QWORD *)a1);
          }
          v14 = (uint64_t *)glpPointerHashGet(*(_QWORD *)(a1 + 32), Extra);
          if (v14)
            glpVariableDeclarationNodeSetName(v3, *v14, v14[1]);
          Initializer = glpVariableDeclarationNodeGetInitializer(v3);
          if (Initializer)
          {
            v16 = Initializer;
            if (glpIsAssignNode(Initializer) && (*(_BYTE *)(VariableExtra + 49) & 2) != 0)
            {
              Lhs = glpBinaryOperatorNodeGetLhs(v16);
              Rhs = glpBinaryOperatorNodeGetRhs(v16);
              if (glpIsLValueNode(Lhs) && glpIsConstantNode(Rhs) && glpLValueNodeGetVariableExtra(Lhs) == VariableExtra)
              {
                Offset = glpDerefNodeGetOffset(Lhs);
                if (!Offset
                  || (v20 = Offset, !glpOffsetNodeGetOffsetExpr(Offset))
                  && !glpOffsetNodeGetSwizzle(v20)
                  && !glpOffsetNodeGetVectorElementExpr(v20))
                {
                  v21 = glpLValueNodeGetVariableExtra(Lhs);
                  *(_QWORD *)(v21 + 64) = glpConstantNodeGetValue(Rhs);
                  glpVariableDeclarationNodeSetInitializer(v3, 0);
                }
              }
            }
          }
          goto LABEL_33;
        }
LABEL_31:
        if ((glpASTNodeGetSaFlags(v3) & 1) != 0)
          goto LABEL_32;
LABEL_33:
        if (!v3)
          return 0;
        v32 = glpASTNodeGetSaFlags(v3);
        glpASTNodeSetSaFlags(v3, v32 & 0xFFFFFFFFFFFFFF1FLL);
        ValueHash = glpCompilerGetValueHash(*(_QWORD *)(a1 + 16));
        v34 = glpConstantFold((uint64_t)a2, ValueHash, v3);
        v7 = v34;
        if (v34)
        {
          v61 = *(__n128 *)(a1 + 40);
          v62 = *(_QWORD *)(a1 + 56);
          glpASTNodeSetLocation(v34, &v61);
        }
        return v7;
      }
      if ((glpASTNodeGetSaFlags(v3) & 0x1F) != 1)
        goto LABEL_33;
    }
    else
    {
      if ((glpTypeConversionNodeGetToPrecision(v3) & 1) == 0 && (glpASTNodeGetSaFlags(v3) & 1) == 0)
        goto LABEL_33;
      glpTypeConversionNodeSetToPrecision(v3, *(_QWORD *)a1);
    }
LABEL_32:
    v31 = glpASTNodeGetSaFlags(v3);
    glpASTNodeSetSaFlags(v3, v31 & 0xFFFFFFFFFFFFFFE0 | *(_QWORD *)a1);
    goto LABEL_33;
  }
  switch(Kind)
  {
    case 'K':
      v7 = 0;
      *(_BYTE *)(a1 + 8) = 1;
      break;
    case 'P':
      v22 = (_OWORD *)glpOffsetNodeGetExtra(v3);
      v23 = (_OWORD *)((uint64_t (*)(_QWORD, uint64_t, const char *))a2[1])(*a2, 32, "Offest Object (SA inlining)");
      v24 = v22[1];
      *v23 = *v22;
      v23[1] = v24;
      glpOffsetNodeSetExtra(v3, (uint64_t)v23);
      goto LABEL_33;
    case 'Q':
      v25 = glpLValueNodeGetVariableExtra(v3);
      v26 = glpPointerHashGet(*(_QWORD *)(a1 + 24), v25);
      if (v26)
      {
        LValueNode = v26;
        v28 = glpLValueNodeGetVariableExtra(v26);
        glpLValueNodeSetVariableExtra(v3, v28);
        v29 = glpASTNodeGetSaFlags(v3);
        v30 = glpASTNodeGetSaFlags(LValueNode);
        glpASTNodeSetSaFlags(v3, v29 & 0xFFFFFFFFFFFFFFE0 | v30 & 0x1F);
      }
      else if ((*(_WORD *)(v25 + 50) & 0x8040) != 0)
      {
        LValueNode = 0;
      }
      else
      {
        v36 = ((uint64_t (*)(_QWORD, uint64_t, const char *))a2[1])(*a2, 160, "Variable Object (SA inlining)");
        v37 = *(_OWORD *)(v25 + 16);
        *(_OWORD *)v36 = *(_OWORD *)v25;
        *(_OWORD *)(v36 + 16) = v37;
        v38 = *(_OWORD *)(v25 + 80);
        v40 = *(_OWORD *)(v25 + 32);
        v39 = *(_OWORD *)(v25 + 48);
        *(_OWORD *)(v36 + 64) = *(_OWORD *)(v25 + 64);
        *(_OWORD *)(v36 + 80) = v38;
        *(_OWORD *)(v36 + 32) = v40;
        *(_OWORD *)(v36 + 48) = v39;
        v41 = *(_OWORD *)(v25 + 144);
        v43 = *(_OWORD *)(v25 + 96);
        v42 = *(_OWORD *)(v25 + 112);
        *(_OWORD *)(v36 + 128) = *(_OWORD *)(v25 + 128);
        *(_OWORD *)(v36 + 144) = v41;
        *(_OWORD *)(v36 + 96) = v43;
        *(_OWORD *)(v36 + 112) = v42;
        glpASTNodeGetLocation(v3, &v64);
        LValueNode = glpMakeLValueNode((uint64_t)a2, &v64, *(_QWORD *)(v36 + 16), *(_QWORD *)(v36 + 24), v36);
        glpASTNodeSetSaType(LValueNode, *(_QWORD *)v36);
        glpASTNodeSetSaFlags(LValueNode, *(_QWORD *)(v36 + 48));
        glpPointerHashPut(*(_QWORD *)(a1 + 24), v25, LValueNode, v44);
        glpLValueNodeSetVariableExtra(v3, v36);
      }
      if ((glpASTNodeGetSaFlags(v3) & 1) != 0)
      {
        v45 = glpASTNodeGetSaFlags(v3);
        glpASTNodeSetSaFlags(v3, v45 & 0xFFFFFFFFFFFFFFE0 | *(_QWORD *)a1);
      }
      v46 = (uint64_t *)glpPointerHashGet(*(_QWORD *)(a1 + 32), v25);
      if (v46)
        glpLValueNodeSetVariableName(v3, *v46, v46[1]);
      if (LValueNode && glpIsDerefNode(LValueNode) && glpDerefNodeGetOffset(LValueNode))
      {
        v47 = glpDerefNodeGetOffset(LValueNode);
        v48 = glpDerefNodeGetOffset(v3);
        if (!v48)
        {
          glpAddOffsetIfNeeded((uint64_t)a2, v3);
          v48 = glpDerefNodeGetOffset(v3);
        }
        glpOffsetNodeGetOffsetExpr(v48);
        glpOffsetNodeGetSwizzle(v48);
        glpOffsetNodeGetVectorElementExpr(v48);
        if (glpOffsetNodeGetOffsetExpr(v47))
        {
          glpOffsetNodeGetOffsetExpr(v47);
          if (v48 && glpOffsetNodeGetOffsetExpr(v48))
          {
            v49 = *(_QWORD *)(a1 + 16);
            glpASTNodeGetLocation(v3, &v63);
            OffsetExpr = glpOffsetNodeGetOffsetExpr(v47);
            v51 = glpOffsetNodeGetOffsetExpr(v48);
            AddFragment = glpMakeAddFragment(v49, &v63, OffsetExpr, v51);
          }
          else
          {
            AddFragment = glpOffsetNodeGetOffsetExpr(v47);
          }
          glpOffsetNodeSetOffsetExpr(v48, AddFragment);
        }
        if (glpOffsetNodeGetBankIndex(v47))
        {
          BankIndex = glpOffsetNodeGetBankIndex(v47);
          glpOffsetNodeSetBankIndex(v48, BankIndex);
        }
        Swizzle = glpOffsetNodeGetSwizzle(v47);
        v55 = glpOffsetNodeGetSwizzle(v48);
        if (Swizzle)
        {
          if (v55)
          {
            v56 = v55 & 7;
            if ((v55 & 7) != 0)
            {
              v57 = 0;
              v58 = 2 * v56;
              do
              {
                v56 = (((Swizzle >> (2 * ((v55 >> (v57 + 3)) & 3) + 3)) & 3) << (v57 + 3)) | v56 & ~(24 << v57);
                v57 += 2;
              }
              while (v58 != v57);
            }
          }
          else
          {
            v56 = Swizzle;
          }
        }
        else
        {
          v56 = v55;
        }
        glpOffsetNodeSetSwizzle(v48, v56);
        if (glpOffsetNodeGetVectorElementExpr(v47))
        {
          VectorElementExpr = glpOffsetNodeGetVectorElementExpr(v47);
          glpOffsetNodeSetVectorElementExpr(v48, VectorElementExpr);
        }
        if (glpOffsetNodeGetPreSwizzlePrimitiveType(v47))
        {
          PreSwizzlePrimitiveType = glpOffsetNodeGetPreSwizzlePrimitiveType(v47);
          glpOffsetNodeSetPreSwizzlePrimitiveType(v48, PreSwizzlePrimitiveType);
        }
      }
      goto LABEL_33;
    case 'T':
      v3 = glpSAInlinePPStreamOpFixup(*(_QWORD *)(a1 + 16), v3);
      goto LABEL_33;
    default:
      goto LABEL_31;
  }
  return v7;
}

uint64_t __saInliningNodeReplacement_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  _OWORD *v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t LValueNode;
  __n128 v14;

  v2 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1[4] + 8))(*(_QWORD *)a1[4], 160, "VariableObject (SA inlining)");
  v3 = (_OWORD *)a1[5];
  v4 = v3[1];
  *(_OWORD *)v2 = *v3;
  *(_OWORD *)(v2 + 16) = v4;
  v5 = v3[2];
  v6 = v3[3];
  v7 = v3[5];
  *(_OWORD *)(v2 + 64) = v3[4];
  *(_OWORD *)(v2 + 80) = v7;
  *(_OWORD *)(v2 + 32) = v5;
  *(_OWORD *)(v2 + 48) = v6;
  v8 = v3[6];
  v9 = v3[7];
  v10 = v3[9];
  *(_OWORD *)(v2 + 128) = v3[8];
  *(_OWORD *)(v2 + 144) = v10;
  *(_OWORD *)(v2 + 96) = v8;
  *(_OWORD *)(v2 + 112) = v9;
  v11 = a1[4];
  glpASTNodeGetLocation(a1[6], &v14);
  LValueNode = glpMakeLValueNode(v11, &v14, *(_QWORD *)(v2 + 16), *(_QWORD *)(v2 + 24), v2);
  glpASTNodeSetSaType(LValueNode, *(_QWORD *)v2);
  glpASTNodeSetSaFlags(LValueNode, *(_QWORD *)(v2 + 48));
  return LValueNode;
}

char *glpQualifierKindToString(unsigned int a1)
{
  if (a1 >= 7)
    abort();
  return off_24F4B07C0[a1];
}

uint64_t glpQualifierKindOfNode(uint64_t a1)
{
  int Kind;
  unsigned int Qualifier;

  Kind = glpASTNodeGetKind(a1);
  if (Kind == 61)
    return 5;
  if (Kind == 60)
    return 0;
  if (Kind != 59 || (Qualifier = glpKeywordQualifierNodeGetQualifier(a1), Qualifier >= 0x19))
    abort();
  return dword_22A97FB20[Qualifier];
}

uint64_t glpParseQualifiers(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t *a5, _QWORD **a6, uint64_t *a7)
{
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t result;
  BOOL v17;
  _BOOL4 v18;
  unsigned int v19;
  uint64_t Qualifier;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t NameTable;
  uint64_t v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t **InfoLog;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  __n128 *v37;
  unsigned int v38;
  uint64_t **v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  unsigned int i;
  uint64_t v46;
  uint64_t Allocator;
  unsigned __int8 v48;
  char v49;
  char v50;
  uint64_t *v51;
  int QualifierCount;
  uint64_t v53;
  __n128 v54;
  __n128 v55;
  __n128 v56;
  __n128 v57[2];

  v11 = a2;
  v12 = a1;
  if (!a3)
  {
    *a6 = 0;
    *a7 = 0;
LABEL_5:
    v15 = a4;
    v14 = 0;
    return qualifierMaskToSAFlags(a1, a2, a3, v15, v14, a5);
  }
  v13 = a3;
  if (glpIsKeywordQualifierNode(a3))
  {
    *a6 = 0;
    *a7 = 0;
    v14 = 1 << glpKeywordQualifierNodeGetQualifier(v13);
    a1 = v12;
    a2 = v11;
    a3 = v13;
    v15 = a4;
    return qualifierMaskToSAFlags(a1, a2, a3, v15, v14, a5);
  }
  if (glpIsLayoutQualifierNode(v13))
  {
    *a7 = 0;
    result = qualifierMaskToSAFlags(v12, v11, v13, a4, 0, a5);
    if (!(_DWORD)result)
      return result;
    v17 = parseLayout(v12, v11, v13, a4, a6) == 0;
    return !v17;
  }
  if (glpIsSubroutineTypeListNode(v13))
  {
    *a6 = 0;
    *a7 = glpSANode(v12, v13);
    result = qualifierMaskToSAFlags(v12, v11, v13, a4 | 0x180000, 0, a5);
    if (!(_DWORD)result)
      return result;
    v17 = *a7 == -1;
    return !v17;
  }
  if (!glpIsQualifierListNode(v13))
LABEL_63:
    abort();
  *a6 = 0;
  *a7 = 0;
  QualifierCount = glpQualifierListNodeGetQualifierCount(v13);
  if (!QualifierCount)
  {
    a1 = v12;
    a2 = v11;
    a3 = v13;
    goto LABEL_5;
  }
  v51 = a5;
  v18 = 0;
  v19 = 0;
  v53 = 0;
  do
  {
    Qualifier = glpQualifierListNodeGetQualifier(v13, v19);
    v21 = Qualifier;
    if (v18)
    {
      if (!glpIsKeywordQualifierNode(Qualifier)
        || (v22 = glpKeywordQualifierNodeGetQualifier(v21), v22 > 0x12)
        || ((1 << v22) & 0x46000) == 0)
      {
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(v12);
        glpASTNodeGetLocation(v13, v57);
        v36 = "'centroid', 'sample' and 'patch' must be directly followed by 'in', 'out' or 'varying'";
        v37 = v57;
        goto LABEL_61;
      }
    }
    v23 = glpQualifierKindOfNode(v21);
    if (glpIsKeywordQualifierNode(v21) && glpKeywordQualifierNodeGetQualifier(v21) == 4)
    {
      NameTable = glpCompilerGetNameTable(v12);
      if (glpNameTableIsExtensionEnabled(NameTable, 0xEu))
        v23 = 4;
    }
    if (v23 < HIDWORD(v53))
    {
      v25 = glpCompilerGetNameTable(v12);
      if (glpNameTableGetGLSLVersion(v25) <= 9)
      {
        if (glpIsKeywordQualifierNode(v21))
        {
          v38 = glpKeywordQualifierNodeGetQualifier(v21);
          glpQualifierName(v38);
        }
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(v12);
        glpASTNodeGetLocation(v21, &v56);
        v48 = glpQualifierKindToString(v23);
        glpQualifierKindToString(HIDWORD(v53));
        v49 = v48;
        v36 = "%s qualifier %s%s%smust precede %s qualifiers";
        v37 = &v56;
LABEL_61:
        glpLogMessage(InfoLog, 0, (uint64_t)v37, v36, v32, v33, v34, v35, v49);
        return 0;
      }
    }
    if (glpIsKeywordQualifierNode(v21))
    {
      HIDWORD(v53) = v23;
      v26 = glpKeywordQualifierNodeGetQualifier(v21);
      v27 = 1 << v26;
      if (((1 << v26) & v53) != 0)
      {
        v28 = glpCompilerGetNameTable(v12);
        if (glpNameTableGetGLSLVersion(v28) < 0xA)
        {
          v39 = (uint64_t **)glpCompilerGetInfoLog(v12);
          glpASTNodeGetLocation(v21, &v55);
          v50 = glpQualifierName(v26);
          glpLogMessage(v39, 0, (uint64_t)&v55, "Duplicate qualifier '%s'", v40, v41, v42, v43, v50);
          return 0;
        }
      }
      if (v26 - 6 > 2)
      {
        v18 = 0;
      }
      else
      {
        v29 = glpCompilerGetNameTable(v12);
        v18 = !glpNameTableIsExtensionEnabled(v29, 0xEu);
      }
      LODWORD(v53) = v27 | v53;
    }
    else if (glpIsLayoutQualifierNode(v21))
    {
      v18 = 0;
    }
    else
    {
      if (!glpIsSubroutineTypeListNode(v21) || *a7)
        goto LABEL_63;
      v30 = glpSANode(v12, v21);
      *a7 = v30;
      if (v30 == -1)
        return 0;
      v18 = 0;
      a4 |= 0x180000uLL;
    }
    ++v19;
  }
  while (QualifierCount != v19);
  if (v18)
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(v12);
    glpASTNodeGetLocation(v13, &v54);
    v36 = "'centroid', 'sample' and 'patch' must be directly followed by 'in', 'out' or 'varying'";
    v37 = &v54;
    goto LABEL_61;
  }
  v44 = qualifierMaskToSAFlags(v12, v11, v13, a4, v53, v51);
  result = v44 != 0;
  if (v44)
  {
    for (i = 0; i != QualifierCount; ++i)
    {
      v46 = glpQualifierListNodeGetQualifier(v13, i);
      if (glpIsLayoutQualifierNode(v46))
      {
        if (!*a6)
        {
          Allocator = glpCompilerGetAllocator(v12);
          *a6 = glpMakeLayoutObject(Allocator);
        }
        result = parseLayout(v12, v11, v46, *v51, a6);
        if (!(_DWORD)result)
          break;
      }
      result = 1;
    }
  }
  return result;
}

uint64_t qualifierMaskToSAFlags(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  int v9;
  uint64_t v12;
  _QWORD *v13;
  uint64_t *v14;
  uint64_t **InfoLog;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  _QWORD *Allocator;
  uint64_t *StringBuffer;
  unsigned int v23;
  uint64_t NameTable;
  unsigned int GLSLVersion;
  int Language;
  _BOOL4 v27;
  _BOOL4 IsExtensionEnabled;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  BOOL v32;
  _BOOL4 v33;
  BOOL v34;
  int v35;
  BOOL v36;
  _QWORD *v37;
  uint64_t *v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  int v44;
  _QWORD *v45;
  uint64_t *v46;
  __n128 *v47;
  unint64_t v48;
  uint64_t v49;
  BOOL v50;
  char v51;
  uint64_t v52;
  BOOL v53;
  char v54;
  uint64_t v55;
  uint64_t v56;
  unsigned int v57;
  _QWORD *v58;
  uint64_t *v59;
  uint64_t **v60;
  char v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  _QWORD *v67;
  uint64_t *v68;
  uint64_t result;
  uint64_t v70;
  unsigned int v71;
  int v72;
  _QWORD *v73;
  uint64_t *v74;
  uint64_t *v75;
  int v76;
  unint64_t v77;
  BOOL v78;
  uint64_t v79;
  BOOL v80;
  unsigned int v81;
  uint64_t v82;
  char v83;
  char v84;
  int v85;
  _QWORD *v86;
  uint64_t *v87;
  int v88;
  _QWORD *v89;
  char CString;
  __n128 v91;
  __n128 v92;
  __n128 v93;

  *a6 = a4;
  v9 = a5 & 0x1F80000;
  if (a2 > 0xC)
    goto LABEL_17;
  if (((1 << a2) & 0x772) != 0)
  {
    if ((a5 & 0x1F80000u) < 0x200000)
    {
      if (!v9 || v9 == 0x80000)
        goto LABEL_21;
      if (v9 == 0x100000)
      {
        v12 = 2;
        goto LABEL_20;
      }
    }
    else if ((a5 & 0x1F80000u) >= 0x800000)
    {
      if (v9 == 0x800000)
      {
        v12 = 8;
        goto LABEL_20;
      }
      if (v9 == 0x1000000)
      {
        v12 = 16;
        goto LABEL_20;
      }
    }
    else
    {
      if (v9 == 0x200000)
      {
        v12 = 1;
        goto LABEL_20;
      }
      if (v9 == 0x400000)
      {
        v12 = 4;
LABEL_20:
        *a6 = v12 | a4;
        goto LABEL_21;
      }
    }
LABEL_17:
    Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
    StringBuffer = glpMakeStringBuffer(Allocator);
    qualifierMaskToStringBuffer(StringBuffer, v9);
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a3, &v92);
    CString = glpStringBufferGetCString(StringBuffer);
    qualifierContextToString(a2);
    v20 = "Invalid precision qualifiers '%s' in %s context";
LABEL_163:
    v47 = &v92;
    goto LABEL_164;
  }
  if (v9)
  {
    v13 = (_QWORD *)glpCompilerGetAllocator(a1);
    v14 = glpMakeStringBuffer(v13);
    qualifierMaskToStringBuffer(v14, v9);
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a3, &v93);
    CString = glpStringBufferGetCString(v14);
    qualifierContextToString(a2);
    v20 = "Precision qualifiers '%s' not allowed in %s context";
    goto LABEL_89;
  }
LABEL_21:
  v23 = a5 & 0x7E000;
  NameTable = glpCompilerGetNameTable(a1);
  GLSLVersion = glpNameTableGetGLSLVersion(NameTable);
  Language = glpNameTableGetLanguage(NameTable);
  v27 = glpNameTableIsExtensionEnabled(NameTable, 0xEu) || glpNameTableIsExtensionEnabled(NameTable, 0x23u);
  IsExtensionEnabled = glpNameTableIsExtensionEnabled(NameTable, 2u);
  v29 = (unint64_t)(glpCompilerAllOutputsAreInvariant(a1) != 0) << 40;
  v30 = (unint64_t)(a2 != 2) << 31;
  v31 = *a6;
  if (a2 != 7 || Language)
  {
    v34 = (v31 & 0x140000000) != 0;
    if (a2 != 7 || Language != 4)
    {
      v32 = (v31 & 0x120000000) != 0;
      v33 = (*a6 & 0x60000000) == 0;
      switch(a2)
      {
        case 0u:
        case 3u:
        case 4u:
        case 6u:
        case 8u:
        case 0xBu:
        case 0xCu:
          if (!v23)
            goto LABEL_86;
          v37 = (_QWORD *)glpCompilerGetAllocator(a1);
          v38 = glpMakeStringBuffer(v37);
          qualifierMaskToStringBuffer(v38, a5 & 0x7E000);
          InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(a3, &v92);
          CString = glpStringBufferGetCString(v38);
          qualifierContextToString(a2);
          v20 = "Storage qualifiers '%s' not allowed in %s context";
          goto LABEL_163;
        case 1u:
        case 9u:
        case 0xAu:
          if ((a5 & 0x7E000u) >= 0x10000)
          {
            if ((a5 & 0x7E000u) >= 0x40000)
            {
              if (v23 != 0x40000)
              {
LABEL_33:
                if (v23 != 270336)
                {
                  if (v23 != 278528)
                    goto LABEL_141;
                  v35 = Language == 4 && v27;
                  if (Language == 3)
                    v35 = 1;
                  if (GLSLVersion > 2 || !v35)
                    goto LABEL_141;
                  goto LABEL_84;
                }
                if (GLSLVersion > 2 || Language != 3)
                {
LABEL_141:
                  v58 = (_QWORD *)glpCompilerGetAllocator(a1);
                  v59 = glpMakeStringBuffer(v58);
                  qualifierMaskToStringBuffer(v59, a5 & 0x7E000);
                  v60 = (uint64_t **)glpCompilerGetInfoLog(a1);
                  glpASTNodeGetLocation(a3, &v91);
                  v61 = glpStringBufferGetCString(v59);
                  qualifierContextToString(a2);
                  glpLogMessage(v60, 0, (uint64_t)&v91, "Invalid storage qualifiers '%s' in %s context", v62, v63, v64, v65, v61);
                  return 0;
                }
                goto LABEL_68;
              }
              goto LABEL_59;
            }
LABEL_64:
            if (v23 == 0x10000)
            {
              if (v33)
              {
                v41 = 0x180000100;
                if (a2 == 2)
                  v41 = 0x100000000;
                v40 = v41 | ((unint64_t)(a2 == 7) << 35) | v31;
                goto LABEL_85;
              }
              goto LABEL_141;
            }
            if (v23 != 0x20000 || GLSLVersion > 2 || Language)
              goto LABEL_141;
LABEL_68:
            v39 = 2684354816;
            if (a2 == 2)
              v39 = 0x20000000;
            v40 = v31 | v39;
            goto LABEL_85;
          }
          v36 = v23 == 0x4000;
          if ((a5 & 0x7E000u) >= 0x4000)
            goto LABEL_78;
          if (v23)
            goto LABEL_45;
          v40 = v31 | v30;
          break;
        case 2u:
        case 7u:
          goto LABEL_30;
        case 5u:
          v57 = v23 >> 13;
          if (v23 >> 13 < 2)
          {
            v40 = v31 | 0x2000000;
            goto LABEL_85;
          }
          if (v57 == 2)
          {
            v40 = v31 | 0x4000000;
            goto LABEL_85;
          }
          if (v57 != 4)
            goto LABEL_141;
          v40 = v31 | 0x6000000;
          goto LABEL_85;
        default:
          goto LABEL_141;
      }
      goto LABEL_85;
    }
    v33 = (*a6 & 0x60000000) == 0;
    v32 = 1;
  }
  else
  {
    v32 = (v31 & 0x120000000) != 0;
    v33 = (*a6 & 0x60000000) == 0;
    v34 = 1;
  }
LABEL_30:
  if ((a5 & 0x7E000u) >= 0x10000)
  {
    if ((a5 & 0x7E000u) >= 0x40000)
    {
      if (v23 != 0x40000)
        goto LABEL_33;
LABEL_59:
      if (GLSLVersion > 2)
        goto LABEL_141;
      if (Language != 3 && Language)
      {
        if (Language != 4)
          goto LABEL_141;
        goto LABEL_68;
      }
LABEL_84:
      v40 = v31 | v30 | v29 | 0x40000000;
      goto LABEL_85;
    }
    goto LABEL_64;
  }
  v36 = v23 == 0x4000;
  if ((a5 & 0x7E000u) < 0x4000)
  {
    if (v23)
    {
LABEL_45:
      if (v23 != 0x2000 || GLSLVersion < 3 || v34)
        goto LABEL_141;
      goto LABEL_68;
    }
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a3, &v93);
    CString = qualifierContextToString(a2);
    v20 = "Storage qualifier required in %s context";
LABEL_89:
    v47 = &v93;
LABEL_164:
    glpLogMessage(InfoLog, 0, (uint64_t)v47, v20, v16, v17, v18, v19, CString);
    return 0;
  }
LABEL_78:
  if (v36)
  {
    if (GLSLVersion < 3 || v32)
      goto LABEL_141;
    goto LABEL_84;
  }
  if (v23 != 0x8000 || !IsExtensionEnabled)
    goto LABEL_141;
  v40 = v31 | v30 | v29 | 0x60000000;
LABEL_85:
  *a6 = v40;
LABEL_86:
  v42 = a5 & 0x1FE0;
  v43 = glpCompilerGetNameTable(a1);
  v44 = glpNameTableGetLanguage(v43);
  switch(a2)
  {
    case 0u:
    case 2u:
    case 3u:
    case 7u:
    case 8u:
    case 0xBu:
    case 0xCu:
      if ((a5 & 0x1FE0) == 0)
        goto LABEL_170;
      v45 = (_QWORD *)glpCompilerGetAllocator(a1);
      v46 = glpMakeStringBuffer(v45);
      qualifierMaskToStringBuffer(v46, a5 & 0x1FE0);
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a3, &v93);
      CString = glpStringBufferGetCString(v46);
      qualifierContextToString(a2);
      v20 = "Auxiliary storage qualifiers '%s' not allowed in %s context";
      goto LABEL_89;
    case 1u:
      if ((glpCompilerGetOptions(a1) & 1) == 0)
        goto LABEL_91;
      v66 = *a6;
      if (a3)
      {
        if (glpIsVariableDeclarationNode(a3)
          && glpVariableDeclarationNodeGetInitializer(a3)
          && (v66 & 0x160000000) == 0)
        {
          v66 = *a6;
LABEL_168:
          v55 = v66 | 0x60;
          goto LABEL_169;
        }
      }
      else if ((v66 & 0x160000000) == 0)
      {
        goto LABEL_168;
      }
LABEL_91:
      v48 = *a6;
      v49 = ((unint64_t)*a6 >> 29) & 1;
      if (v44)
        v50 = 0;
      else
        v50 = (*a6 & 0x20000000) != 0;
      v51 = (v48 & 0x60000000) == 0 || v50;
      v52 = (v48 >> 30) & 1;
      v53 = v44 == 4 && (*a6 & 0x40000000) != 0;
      v54 = v51 | v53;
      if ((a5 & 0x1FE0u) > 0xFF)
      {
        if ((a5 & 0x1FE0u) > 0x3FF)
        {
          if (v42 == 1024)
          {
            if ((v48 & 0x100000000) == 0)
              goto LABEL_162;
            v55 = v48 | 0x200000000;
            goto LABEL_169;
          }
          if (v42 == 2048 && (v48 & 0x160000000) == 0)
          {
LABEL_158:
            v55 = v48 | 0x100;
            goto LABEL_169;
          }
        }
        else
        {
          if (v42 == 256)
          {
            if ((v54 & 1) != 0)
              goto LABEL_162;
            v55 = v48 | 0x40000000000;
            goto LABEL_169;
          }
          if (v42 == 512 && (v48 & 0x100000000) != 0)
          {
            v55 = v48 | 0xC00000000;
            goto LABEL_169;
          }
        }
      }
      else if ((a5 & 0x1FE0u) > 0x3F)
      {
        if (v42 == 64)
        {
          if ((v54 & 1) != 0)
            goto LABEL_162;
          v55 = v48 | 0x4000000000;
          goto LABEL_169;
        }
        if (v42 == 128 && a2 == 1)
        {
          if (v44 != 1)
            LOBYTE(v52) = 0;
          if (v44 != 2)
            LODWORD(v49) = 0;
          if ((v52 & 1) != 0 || (_DWORD)v49)
          {
            v55 = v48 | 0x20000000000;
            goto LABEL_169;
          }
        }
      }
      else
      {
        if ((a5 & 0x1FE0) == 0)
          goto LABEL_170;
        if (v42 == 32 && (v48 & 0x160000000) == 0)
        {
LABEL_122:
          v55 = v48 | 0x60;
          goto LABEL_169;
        }
      }
LABEL_162:
      v67 = (_QWORD *)glpCompilerGetAllocator(a1);
      v68 = glpMakeStringBuffer(v67);
      qualifierMaskToStringBuffer(v68, a5 & 0x1FE0);
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a3, &v92);
      CString = glpStringBufferGetCString(v68);
      qualifierContextToString(a2);
      v20 = "Invalid auxiliary storage qualifiers '%s' in %s context";
      goto LABEL_163;
    case 4u:
      if ((a5 & 0x1FE0) == 0)
        goto LABEL_170;
      if (v42 != 1024)
        goto LABEL_162;
      v55 = *a6 | 0x180000;
      goto LABEL_169;
    case 5u:
      v48 = *a6;
      v56 = *a6 & 0x6000000;
      if ((a5 & 0x1FE0u) <= 0x7FF)
      {
        if ((a5 & 0x1FE0) == 0)
          goto LABEL_170;
        if (v42 != 32)
          goto LABEL_162;
        goto LABEL_149;
      }
      if (v42 != 4096)
      {
        if (v42 != 2048)
          goto LABEL_162;
LABEL_149:
        if (v56 != 0x2000000)
          goto LABEL_162;
        goto LABEL_158;
      }
      if (v56 != 0x2000000)
        goto LABEL_162;
      v55 = v48 | 0x200;
LABEL_169:
      *a6 = v55;
LABEL_170:
      result = parseInterpolationQualifiers(a1, a2, a3, a5, a6);
      if ((_DWORD)result)
      {
        result = parseInterpolationQualifiers(a1, a2, a3, a5, a6);
        if ((_DWORD)result)
        {
          v70 = glpCompilerGetNameTable(a1);
          v71 = glpNameTableGetGLSLVersion(v70);
          v72 = glpNameTableGetLanguage(v70);
          if (a2 <= 0xC)
          {
            if (((1 << a2) & 0x1FD) != 0)
            {
              if ((a5 & 2) != 0)
              {
                v73 = (_QWORD *)glpCompilerGetAllocator(a1);
                v74 = glpMakeStringBuffer(v73);
                v75 = v74;
                v76 = a5 & 2;
LABEL_203:
                qualifierMaskToStringBuffer(v74, v76);
                InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
                glpASTNodeGetLocation(a3, &v93);
                CString = glpStringBufferGetCString(v75);
                qualifierContextToString(a2);
                v20 = "Qualifiers '%s' not allowed in %s context";
                goto LABEL_89;
              }
LABEL_197:
              v88 = a5 & 1;
              if (((1 << a2) & 0x1E72) != 0)
              {
                if (v88)
                  *a6 |= 0x80000000000uLL;
              }
              else if (v88)
              {
                v89 = (_QWORD *)glpCompilerGetAllocator(a1);
                v74 = glpMakeStringBuffer(v89);
                v75 = v74;
                v76 = v88;
                goto LABEL_203;
              }
              return 1;
            }
            v77 = *a6;
            v78 = v71 > 9 || v71 == 6;
            v79 = 0x8000000000;
            if (v78)
              v79 = 0x10000000000;
            if ((v77 & 0x10000000) != 0)
            {
              if ((a5 & 2) == 0)
                goto LABEL_197;
            }
            else
            {
              if ((a5 & 2) == 0)
                goto LABEL_197;
              v80 = (*a6 & 0x20000000) == 0;
              v81 = (v72 == 0) & ((v77 & 0x20000000) >> 29);
              if ((v77 & 0x60000000) == 0)
                LOBYTE(v81) = 1;
              v82 = (v77 >> 30) & 1;
              if (v72 != 4)
                LODWORD(v82) = 0;
              v83 = v81 | v82;
              if (v71 != 6)
                v80 = 1;
              v84 = v80 & ~v83;
              if (v71 == 2)
                v85 = 0;
              else
                v85 = v82;
              if ((v84 & 1) == 0 && !v85)
                goto LABEL_194;
            }
            *a6 = v77 | v79;
            goto LABEL_197;
          }
LABEL_194:
          v86 = (_QWORD *)glpCompilerGetAllocator(a1);
          v87 = glpMakeStringBuffer(v86);
          qualifierMaskToStringBuffer(v87, a5 & 2);
          InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(a3, &v92);
          CString = glpStringBufferGetCString(v87);
          qualifierContextToString(a2);
          v20 = "Invalid qualifiers '%s' in %s context";
          goto LABEL_163;
        }
      }
      return result;
    case 6u:
      if ((a5 & 0x1FE0) == 0)
        goto LABEL_170;
      if (v42 == 2048)
      {
        v48 = *a6;
        goto LABEL_158;
      }
      if (v42 != 32)
        goto LABEL_162;
      v48 = *a6;
      goto LABEL_122;
    case 9u:
    case 0xAu:
      goto LABEL_91;
    default:
      goto LABEL_162;
  }
}

uint64_t parseLayout(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, _QWORD **a5)
{
  int LayoutPairCount;
  int v10;
  unsigned int v11;
  uint64_t LayoutPair;
  const void *Identifier;
  unsigned int v14;
  unsigned int v15;
  uint64_t Allocator;
  char *v17;
  uint64_t v18;
  int ValueKind;
  uint64_t v20;
  _QWORD *v21;
  int v22;
  int Value;
  uint64_t v24;
  _QWORD *v25;
  uint64_t **InfoLog;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __n128 v33;
  uint64_t v34;
  int v35;
  __n128 v36;
  uint64_t v37;

  v36 = 0uLL;
  v37 = 0;
  glpASTNodeGetLocation(a3, &v36);
  LayoutPairCount = glpLayoutQualifierNodeGetLayoutPairCount(a3);
  if (!LayoutPairCount)
    return 1;
  v10 = LayoutPairCount;
  v11 = 0;
  while (1)
  {
    LayoutPair = glpLayoutQualifierNodeGetLayoutPair(a3, v11);
    Identifier = (const void *)glpLayoutPairNodeGetIdentifier(LayoutPair);
    v15 = v14;
    v35 = 0;
    Allocator = glpCompilerGetAllocator(a1);
    v17 = glpLowerCaseCopyOfString(Allocator, Identifier, v15);
    if (!glpLayoutQualifierFromString(v17, v18, &v35))
      break;
    ValueKind = glpLayoutPairNodeGetValueKind(LayoutPair);
    if (ValueKind)
    {
      if (ValueKind != 1)
        abort();
      v20 = glpCompilerGetAllocator(a1);
      v21 = *a5;
      v22 = v35;
      Value = glpLayoutPairNodeGetValue(LayoutPair);
      v33 = v36;
      v34 = v37;
      if (!glpLayoutObjectAppendInteger(v20, a1, (uint64_t)&v33, a2, a4, v21, v22, Value))
        return 0;
    }
    else
    {
      v24 = glpCompilerGetAllocator(a1);
      v25 = *a5;
      v33 = v36;
      v34 = v37;
      if (!glpLayoutObjectAppend(v24, a1, (uint64_t)&v33, a2, a4, v25, v35))
        return 0;
    }
    if (v10 == ++v11)
      return 1;
  }
  InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
  v33 = v36;
  v34 = v37;
  glpLogMessage(InfoLog, 0, (uint64_t)&v33, "Unknown identifier '%.*s' in layout", v28, v29, v30, v31, v15);
  return 0;
}

uint64_t parseInterpolationQualifiers(uint64_t a1, unsigned int a2, uint64_t a3, char a4, uint64_t *a5)
{
  unsigned int v9;
  uint64_t NameTable;
  int Language;
  _QWORD *v12;
  uint64_t *v13;
  uint64_t **v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t result;
  uint64_t v21;
  _BOOL4 v23;
  uint64_t v25;
  _QWORD *Allocator;
  uint64_t *StringBuffer;
  uint64_t **InfoLog;
  char CString;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __n128 v34;
  __n128 v35;

  v9 = a4 & 0x1C;
  NameTable = glpCompilerGetNameTable(a1);
  Language = glpNameTableGetLanguage(NameTable);
  if (a2 > 0xC)
  {
LABEL_27:
    Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
    StringBuffer = glpMakeStringBuffer(Allocator);
    qualifierMaskToStringBuffer(StringBuffer, v9);
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a3, &v34);
    CString = glpStringBufferGetCString(StringBuffer);
    qualifierContextToString(a2);
    glpLogMessage(InfoLog, 0, (uint64_t)&v34, "Invalid interpolation qualifiers '%s' in %s context", v30, v31, v32, v33, CString);
    return 0;
  }
  if (((1 << a2) & 0x19FD) != 0)
  {
    if (!v9)
      return 1;
    v12 = (_QWORD *)glpCompilerGetAllocator(a1);
    v13 = glpMakeStringBuffer(v12);
    qualifierMaskToStringBuffer(v13, v9);
    v14 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a3, &v35);
    v15 = glpStringBufferGetCString(v13);
    qualifierContextToString(a2);
    glpLogMessage(v14, 0, (uint64_t)&v35, "Interpolation qualifiers '%s' not allowed in %s context", v16, v17, v18, v19, v15);
    return 0;
  }
  v21 = *a5;
  v23 = (*a5 & 0x20000000) == 0 || Language != 0;
  if ((v21 & 0x40000000) != 0 && Language == 4)
    v23 = 0;
  if ((v21 & 0x60000000) == 0)
    v23 = 0;
  result = 1;
  switch(v9 >> 2)
  {
    case 0u:
      return result;
    case 1u:
      if (!v23)
        goto LABEL_27;
      return result;
    case 2u:
      if (!v23)
        goto LABEL_27;
      v25 = v21 | 0x1000000000;
      goto LABEL_26;
    case 4u:
      if (!v23)
        goto LABEL_27;
      v25 = v21 | 0x2000000000;
LABEL_26:
      *a5 = v25;
      break;
    default:
      goto LABEL_27;
  }
  return result;
}

uint64_t *qualifierMaskToStringBuffer(uint64_t *result, int a2)
{
  uint64_t *v3;

  v3 = result;
  if ((a2 & 1) != 0)
  {
    result = (uint64_t *)glpStringBufferAppendCString(result, "precise");
    if ((a2 & 2) == 0)
    {
      if ((a2 & 4) != 0)
      {
LABEL_54:
        glpStringBufferAppendCString(v3, " ");
LABEL_55:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "smooth");
        if ((a2 & 8) != 0)
          goto LABEL_56;
        goto LABEL_30;
      }
LABEL_29:
      if ((a2 & 8) != 0)
      {
LABEL_56:
        glpStringBufferAppendCString(v3, " ");
LABEL_57:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "flat");
        if ((a2 & 0x10) != 0)
          goto LABEL_58;
        goto LABEL_31;
      }
LABEL_30:
      if ((a2 & 0x10) != 0)
      {
LABEL_58:
        glpStringBufferAppendCString(v3, " ");
LABEL_59:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "noperspective");
        if ((a2 & 0x20) != 0)
          goto LABEL_60;
        goto LABEL_32;
      }
LABEL_31:
      if ((a2 & 0x20) != 0)
      {
LABEL_60:
        glpStringBufferAppendCString(v3, " ");
LABEL_61:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "const");
        if ((a2 & 0x40) != 0)
          goto LABEL_62;
        goto LABEL_33;
      }
LABEL_32:
      if ((a2 & 0x40) != 0)
      {
LABEL_62:
        glpStringBufferAppendCString(v3, " ");
LABEL_63:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "centroid");
        if ((a2 & 0x80) != 0)
          goto LABEL_64;
        goto LABEL_34;
      }
LABEL_33:
      if ((a2 & 0x80) != 0)
      {
LABEL_64:
        glpStringBufferAppendCString(v3, " ");
LABEL_65:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "patch");
        if ((a2 & 0x100) != 0)
          goto LABEL_66;
        goto LABEL_35;
      }
LABEL_34:
      if ((a2 & 0x100) != 0)
      {
LABEL_66:
        glpStringBufferAppendCString(v3, " ");
LABEL_67:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "sample");
        if ((a2 & 0x200) != 0)
          goto LABEL_68;
        goto LABEL_36;
      }
LABEL_35:
      if ((a2 & 0x200) != 0)
      {
LABEL_68:
        glpStringBufferAppendCString(v3, " ");
LABEL_69:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "bindable");
        if ((a2 & 0x400) != 0)
          goto LABEL_70;
        goto LABEL_37;
      }
LABEL_36:
      if ((a2 & 0x400) != 0)
      {
LABEL_70:
        glpStringBufferAppendCString(v3, " ");
LABEL_71:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "subroutine");
        if ((a2 & 0x800) != 0)
          goto LABEL_72;
        goto LABEL_38;
      }
LABEL_37:
      if ((a2 & 0x800) != 0)
      {
LABEL_72:
        glpStringBufferAppendCString(v3, " ");
LABEL_73:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "$readonly");
        if ((a2 & 0x1000) != 0)
          goto LABEL_74;
        goto LABEL_39;
      }
LABEL_38:
      if ((a2 & 0x1000) != 0)
      {
LABEL_74:
        glpStringBufferAppendCString(v3, " ");
LABEL_75:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "$foldable");
        if ((a2 & 0x2000) != 0)
          goto LABEL_76;
        goto LABEL_40;
      }
LABEL_39:
      if ((a2 & 0x2000) != 0)
      {
LABEL_76:
        glpStringBufferAppendCString(v3, " ");
LABEL_77:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "in");
        if ((a2 & 0x4000) != 0)
          goto LABEL_78;
        goto LABEL_41;
      }
LABEL_40:
      if ((a2 & 0x4000) != 0)
      {
LABEL_78:
        glpStringBufferAppendCString(v3, " ");
LABEL_79:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "out");
        if ((a2 & 0x8000) != 0)
          goto LABEL_80;
        goto LABEL_42;
      }
LABEL_41:
      if ((a2 & 0x8000) != 0)
      {
LABEL_80:
        glpStringBufferAppendCString(v3, " ");
LABEL_81:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "inout");
        if ((a2 & 0x10000) != 0)
          goto LABEL_82;
        goto LABEL_43;
      }
LABEL_42:
      if ((a2 & 0x10000) != 0)
      {
LABEL_82:
        glpStringBufferAppendCString(v3, " ");
LABEL_83:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "uniform");
        if ((a2 & 0x20000) != 0)
          goto LABEL_84;
        goto LABEL_44;
      }
LABEL_43:
      if ((a2 & 0x20000) != 0)
      {
LABEL_84:
        glpStringBufferAppendCString(v3, " ");
LABEL_85:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "attribute");
        if ((a2 & 0x40000) != 0)
          goto LABEL_86;
        goto LABEL_45;
      }
LABEL_44:
      if ((a2 & 0x40000) != 0)
      {
LABEL_86:
        glpStringBufferAppendCString(v3, " ");
LABEL_87:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "varying");
        if ((a2 & 0x80000) != 0)
          goto LABEL_88;
        goto LABEL_46;
      }
LABEL_45:
      if ((a2 & 0x80000) != 0)
      {
LABEL_88:
        glpStringBufferAppendCString(v3, " ");
LABEL_89:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "$nop");
        if ((a2 & 0x100000) != 0)
          goto LABEL_90;
        goto LABEL_47;
      }
LABEL_46:
      if ((a2 & 0x100000) != 0)
      {
LABEL_90:
        glpStringBufferAppendCString(v3, " ");
LABEL_91:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "$anyp");
        if ((a2 & 0x200000) != 0)
          goto LABEL_92;
        goto LABEL_48;
      }
LABEL_47:
      if ((a2 & 0x200000) != 0)
      {
LABEL_92:
        glpStringBufferAppendCString(v3, " ");
LABEL_93:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "$argp");
        if ((a2 & 0x400000) != 0)
          goto LABEL_94;
        goto LABEL_49;
      }
LABEL_48:
      if ((a2 & 0x400000) != 0)
      {
LABEL_94:
        glpStringBufferAppendCString(v3, " ");
LABEL_95:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "lowp");
        if ((a2 & 0x800000) != 0)
          goto LABEL_96;
        goto LABEL_50;
      }
LABEL_49:
      if ((a2 & 0x800000) != 0)
      {
LABEL_96:
        glpStringBufferAppendCString(v3, " ");
LABEL_97:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "mediump");
        if ((a2 & 0x1000000) == 0)
          return result;
LABEL_98:
        glpStringBufferAppendCString(v3, " ");
        return (uint64_t *)glpStringBufferAppendCString(v3, "highp");
      }
LABEL_50:
      if ((a2 & 0x1000000) == 0)
        return result;
      goto LABEL_98;
    }
    glpStringBufferAppendCString(v3, " ");
LABEL_53:
    result = (uint64_t *)glpStringBufferAppendCString(v3, "invariant");
    if ((a2 & 4) != 0)
      goto LABEL_54;
    goto LABEL_29;
  }
  if ((a2 & 2) != 0)
    goto LABEL_53;
  if ((a2 & 4) != 0)
    goto LABEL_55;
  if ((a2 & 8) != 0)
    goto LABEL_57;
  if ((a2 & 0x10) != 0)
    goto LABEL_59;
  if ((a2 & 0x20) != 0)
    goto LABEL_61;
  if ((a2 & 0x40) != 0)
    goto LABEL_63;
  if ((a2 & 0x80) != 0)
    goto LABEL_65;
  if ((a2 & 0x100) != 0)
    goto LABEL_67;
  if ((a2 & 0x200) != 0)
    goto LABEL_69;
  if ((a2 & 0x400) != 0)
    goto LABEL_71;
  if ((a2 & 0x800) != 0)
    goto LABEL_73;
  if ((a2 & 0x1000) != 0)
    goto LABEL_75;
  if ((a2 & 0x2000) != 0)
    goto LABEL_77;
  if ((a2 & 0x4000) != 0)
    goto LABEL_79;
  if ((a2 & 0x8000) != 0)
    goto LABEL_81;
  if ((a2 & 0x10000) != 0)
    goto LABEL_83;
  if ((a2 & 0x20000) != 0)
    goto LABEL_85;
  if ((a2 & 0x40000) != 0)
    goto LABEL_87;
  if ((a2 & 0x80000) != 0)
    goto LABEL_89;
  if ((a2 & 0x100000) != 0)
    goto LABEL_91;
  if ((a2 & 0x200000) != 0)
    goto LABEL_93;
  if ((a2 & 0x400000) != 0)
    goto LABEL_95;
  if ((a2 & 0x800000) != 0)
    goto LABEL_97;
  if ((a2 & 0x1000000) != 0)
    return (uint64_t *)glpStringBufferAppendCString(v3, "highp");
  return result;
}

char *qualifierContextToString(int a1)
{
  if ((a1 - 1) >= 0xC)
    abort();
  return off_24F4B07F8[a1 - 1];
}

uint64_t glpSAFailed()
{
  return -1;
}

uint64_t glpMakeLValueForVariableObject(uint64_t a1, __n128 *a2, uint64_t *a3)
{
  uint64_t Allocator;
  uint64_t LValueNode;
  uint64_t v8;
  __n128 v10;
  unint64_t v11;

  Allocator = glpCompilerGetAllocator(a1);
  v10 = *a2;
  v11 = a2[1].n128_u64[0];
  LValueNode = glpMakeLValueNode(Allocator, &v10, a3[2], a3[3], (uint64_t)a3);
  glpASTNodeSetSaType(LValueNode, *a3);
  glpASTNodeSetSaFlags(LValueNode, a3[6] & 0x80000037FLL);
  if (a3[11])
  {
    v8 = glpCompilerGetAllocator(a1);
    glpAddOffsetIfNeeded(v8, LValueNode);
    v10 = *a2;
    v11 = a2[1].n128_u64[0];
    glpEnsureOffsetsExist(a1, &v10, LValueNode);
  }
  return LValueNode;
}

uint64_t glpAddOffsetIfNeeded(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t OffsetNode;
  uint64_t v6;
  __n128 v7;

  result = glpDerefNodeGetOffset(a2);
  if (!result)
  {
    glpASTNodeGetLocation(a2, &v7);
    OffsetNode = glpMakeOffsetNode(a1, (__int128 *)&v7);
    glpMakeOffsetObject(a1);
    glpOffsetNodeSetExtra(OffsetNode, v6);
    return glpDerefNodeSetOffset(a2, OffsetNode);
  }
  return result;
}

uint64_t glpEnsureOffsetsExist(uint64_t a1, __n128 *a2, uint64_t a3)
{
  unsigned int *SaType;
  uint64_t result;
  uint64_t Offset;
  char *PrimitiveType;
  uint64_t IntConstant;
  uint64_t ConstantValueFragment;
  __n128 v12;
  unint64_t v13;

  SaType = (unsigned int *)glpASTNodeGetSaType(a3);
  result = glpTypeGetKind(SaType);
  if ((_DWORD)result != 3)
  {
    Offset = glpDerefNodeGetOffset(a3);
    result = glpOffsetNodeGetOffsetExpr(Offset);
    if (!result)
    {
      PrimitiveType = glpGetPrimitiveType(5u);
      IntConstant = glpCompilerGetIntConstant(a1, 0);
      v12 = *a2;
      v13 = a2[1].n128_u64[0];
      ConstantValueFragment = glpMakeConstantValueFragment(a1, &v12, (uint64_t)PrimitiveType, IntConstant);
      return glpOffsetNodeSetOffsetExpr(Offset, ConstantValueFragment);
    }
  }
  return result;
}

uint64_t glpCheckIBDeref(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t ImmediateSAContext;
  uint64_t Ib;
  int Kind;
  uint64_t **InfoLog;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t SaType;
  uint64_t SaFlags;
  uint64_t Allocator;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t **v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __n128 v25;
  uint64_t v26;
  uint64_t v27;
  __n128 v28;
  __n128 v29;

  v2 = a2;
  if ((unint64_t)(a2 + 1) >= 2)
  {
    ImmediateSAContext = glpCompilerGetImmediateSAContext(a1);
    if (glpIsIBPartialDerefNode(v2))
    {
      Ib = glpIBPartialDerefNodeGetIb(v2);
      Kind = glpTypeGetKind(*(unsigned int **)(Ib + 64));
      if (Kind == 1)
        goto LABEL_20;
      if (Kind != 3)
        return v2;
      if (glpIBPartialDerefNodeGetBankIndex(v2))
      {
LABEL_20:
        if (glpIsFieldAccessNode(ImmediateSAContext))
          return v2;
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v29);
        glpLogMessage(InfoLog, 0, (uint64_t)&v29, "You must access a specific variable of the interface block '%.*s'", v9, v10, v11, v12, *(_DWORD *)(Ib + 24));
      }
      else
      {
        if (glpIsArrayAccessNode(ImmediateSAContext))
          return v2;
        v20 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v28);
        glpLogMessage(v20, 0, (uint64_t)&v28, "You must access an element of the interface block '%.*s'", v21, v22, v23, v24, *(_DWORD *)(Ib + 24));
      }
      return -1;
    }
    if (glpIsLValueNode(v2)
      && *(_QWORD *)(glpLValueNodeGetVariableExtra(v2) + 88)
      && *(_DWORD *)(*(_QWORD *)(glpLValueNodeGetVariableExtra(v2) + 88) + 8)
      && !glpIsFieldAccessNode(ImmediateSAContext)
      && !glpIsArrayAccessNode(ImmediateSAContext))
    {
      v26 = 0;
      v27 = 0;
      SaType = glpASTNodeGetSaType(v2);
      SaFlags = glpASTNodeGetSaFlags(v2);
      glpMakeTemporary(a1, SaType, SaFlags & 0x80000037FLL, v2, &v27, &v26);
      Allocator = glpCompilerGetAllocator(a1);
      glpASTNodeGetLocation(v2, &v25);
      glpMakeCommaExprNode(Allocator, &v25, 0);
      v17 = v16;
      v18 = (_QWORD *)glpCompilerGetAllocator(a1);
      glpCommaExprNodeAddExpr(v18, v17, v27);
      v19 = (_QWORD *)glpCompilerGetAllocator(a1);
      glpCommaExprNodeAddExpr(v19, v17, v26);
      return glpSANode(a1, v17);
    }
  }
  return v2;
}

uint64_t glpSAFieldAccessInternal(uint64_t a1, uint64_t a2)
{
  uint64_t Structure;
  unsigned int *SaType;
  const char *Field;
  uint64_t v7;
  uint64_t v8;
  uint64_t Ib;
  unsigned int v10;
  unsigned int v11;
  uint64_t **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t **v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t result;
  uint64_t LValueForVariableObject;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t BankIndex;
  int Kind;
  uint64_t v29;
  unsigned int Length;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int Swizzle;
  int v37;
  int v38;
  int v39;
  unsigned int FieldIndex;
  unsigned int v41;
  uint64_t v42;
  uint64_t SaFlags;
  uint64_t Offset;
  uint64_t OffsetExpr;
  uint64_t v46;
  unsigned int **VariableExtra;
  char *PrimitiveType;
  uint64_t v49;
  uint64_t IntConstant;
  uint64_t ConstantValueFragment;
  uint64_t v52;
  uint64_t v53;
  uint64_t ArrayIndexOffsetFragment;
  uint64_t **InfoLog;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  __n128 *v61;
  uint64_t **v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t FieldOffsetFragment;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  __int16 ElementFlags;
  _QWORD *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  unsigned int VectorType;
  char *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t Allocator;
  uint64_t v91;
  uint64_t ElementType;
  char v93;
  char v94;
  __n128 v95;
  __n128 v96;
  __n128 v97;
  __n128 v98;
  __n128 v99;
  __n128 v100;
  __n128 v101;
  uint64_t v102;
  __n128 v103;
  unsigned int v104;
  __n128 v105;
  __n128 v106;
  __n128 v107;
  __n128 v108;
  __n128 v109;
  __n128 v110;
  __n128 v111;
  __n128 v112;
  __n128 v113;
  _QWORD v114[2];

  Structure = glpFieldAccessNodeGetStructure(a2);
  SaType = (unsigned int *)glpASTNodeGetSaType(Structure);
  Field = (const char *)glpFieldAccessNodeGetField(a2);
  v8 = v7;
  v114[0] = Field;
  v114[1] = v7;
  if (!glpIsIBPartialDerefNode(Structure))
  {
LABEL_10:
    Kind = glpTypeGetKind(SaType);
    if (Kind == 1)
    {
      FieldIndex = glpStructTypeGetFieldIndex((uint64_t)SaType, Field, v8);
      if (FieldIndex != -1)
      {
        v41 = FieldIndex;
        v102 = 0;
        v42 = glpEnsureDeref(a1, Structure, &v102);
        glpASTNodeGetLocation(v42, &v100);
        glpEnsureOffsetsExist(a1, &v100, v42);
        SaFlags = glpASTNodeGetSaFlags(v42);
        Offset = glpDerefNodeGetOffset(v42);
        OffsetExpr = glpOffsetNodeGetOffsetExpr(Offset);
        if (glpIsLValueNode(v42)
          && *(_QWORD *)(glpLValueNodeGetVariableExtra(v42) + 8)
          && (v46 = glpLValueNodeGetVariableExtra(v42), glpLayoutObjectFind(*(uint64_t **)(v46 + 8), 28)))
        {
          VariableExtra = (unsigned int **)glpLValueNodeGetVariableExtra(v42);
          if (glpTypeGetKind(*VariableExtra) == 2)
          {
            glpASTNodeGetLocation(a2, &v99);
            glpASTNodeGetLocation(a2, &v98);
            PrimitiveType = glpGetPrimitiveType(5u);
            v49 = glpABIGetStructTypeRangeOfField(0, (uint64_t)SaType, SaFlags, v41);
            IntConstant = glpCompilerGetIntConstant(a1, v49);
            ConstantValueFragment = glpMakeConstantValueFragment(a1, &v98, (uint64_t)PrimitiveType, IntConstant);
            v52 = glpABIGetArrayStrideForElementType(0, (uint64_t)SaType, SaFlags);
            v53 = glpCompilerGetIntConstant(a1, v52);
            ArrayIndexOffsetFragment = glpMakeArrayIndexOffsetFragment(a1, &v99, ConstantValueFragment, OffsetExpr, v53);
          }
          else
          {
            glpASTNodeGetLocation(a2, &v97);
            v86 = glpABIGetStructTypeRangeOfField(0, (uint64_t)SaType, SaFlags, v41);
            v87 = glpCompilerGetIntConstant(a1, v86);
            ArrayIndexOffsetFragment = glpMakeFieldOffsetFragment(a1, &v97, OffsetExpr, v87);
          }
          v88 = ArrayIndexOffsetFragment;
          v89 = glpDerefNodeGetOffset(v42);
          glpOffsetNodeSetOffsetExpr(v89, v88);
          Allocator = glpCompilerGetAllocator(a1);
          v91 = v102;
          ElementType = glpAggregateTypeGetElementType((uint64_t)SaType, v41);
          v77 = glpHandleGetterSetter(a1, v42, ElementType, OffsetExpr, 0, (uint64_t)"getter", 0x7663339F00000006, (uint64_t)v114);
          v75 = (_QWORD *)Allocator;
          v76 = v91;
        }
        else
        {
          if (glpIsLValueNode(v42) && *(_QWORD *)(glpLValueNodeGetVariableExtra(v42) + 88))
            v67 = *(_DWORD *)(*(_QWORD *)(glpLValueNodeGetVariableExtra(v42) + 88) + 8);
          else
            v67 = 0;
          glpASTNodeGetLocation(a2, &v96);
          v68 = glpABIGetStructTypeRangeOfField(v67, (uint64_t)SaType, SaFlags, v41);
          v69 = glpCompilerGetIntConstant(a1, v68);
          FieldOffsetFragment = glpMakeFieldOffsetFragment(a1, &v96, OffsetExpr, v69);
          v71 = glpDerefNodeGetOffset(v42);
          glpOffsetNodeSetOffsetExpr(v71, FieldOffsetFragment);
          v72 = glpAggregateTypeGetElementType((uint64_t)SaType, v41);
          glpASTNodeSetSaType(v42, v72);
          v73 = glpASTNodeGetSaFlags(v42);
          ElementFlags = glpAggregateTypeGetElementFlags((uint64_t)SaType, v41);
          glpASTNodeSetSaFlags(v42, ElementFlags & 0x41F | (unint64_t)v73);
          v75 = (_QWORD *)glpCompilerGetAllocator(a1);
          v76 = v102;
          v77 = v42;
        }
        return glpMangleSideEffectsWithNewResult(v75, v76, v77);
      }
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a2, &v101);
      v93 = v8;
      v60 = "Structure has no field named %.*s";
      v61 = &v101;
    }
    else
    {
      if (!Kind)
      {
        v29 = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType);
        if (glpPrimitiveTypeGetCategory(v29) != 2)
        {
          v62 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(a2, &v105);
          v94 = glpPrimitiveTypeToString(v29);
          glpLogMessage(v62, 0, (uint64_t)&v105, "Swizzle of non-vector primitive %s", v63, v64, v65, v66, v94);
          return -1;
        }
        v104 = 0;
        glpASTNodeGetLocation(a2, &v103);
        Length = glpPrimitiveVectorGetLength(v29);
        if (!glpValidateSwizzle(a1, (uint64_t)Field, v8, (__int128 *)&v103, Length, &v104))
        {
          glpASTNodeSetSaType(a2, 0);
          return -1;
        }
        v102 = 0;
        v31 = glpEnsureDeref(a1, Structure, &v102);
        v32 = glpDerefNodeGetOffset(v31);
        if (!glpOffsetNodeGetSwizzle(v32))
        {
          v33 = glpDerefNodeGetOffset(v31);
          glpOffsetNodeSetPreSwizzlePrimitiveType(v33, v29);
        }
        v34 = glpDerefNodeGetOffset(v31);
        v35 = glpDerefNodeGetOffset(v31);
        Swizzle = glpOffsetNodeGetSwizzle(v35);
        if (Swizzle)
        {
          if (v104)
          {
            v37 = v104 & 7;
            if ((v104 & 7) != 0)
            {
              v38 = 0;
              v39 = 2 * v37;
              do
              {
                v37 = (((Swizzle >> (2 * ((v104 >> (v38 + 3)) & 3) + 3)) & 3) << (v38 + 3)) | v37 & ~(24 << v38);
                v38 += 2;
              }
              while (v39 != v38);
            }
          }
          else
          {
            v37 = Swizzle;
          }
        }
        else
        {
          v37 = v104;
        }
        glpOffsetNodeSetSwizzle(v34, v37);
        v83 = glpPrimitiveVectorGetElementType(v29);
        VectorType = glpGetVectorType(v83, v8);
        v85 = glpGetPrimitiveType(VectorType);
        glpASTNodeSetSaType(v31, (uint64_t)v85);
        v75 = (_QWORD *)glpCompilerGetAllocator(a1);
        v76 = v102;
        v77 = v31;
        return glpMangleSideEffectsWithNewResult(v75, v76, v77);
      }
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a2, &v95);
      v60 = "Field access or swizzle of non-struct non-vector";
      v61 = &v95;
    }
    glpLogMessage(InfoLog, 0, (uint64_t)v61, v60, v56, v57, v58, v59, v93);
    return -1;
  }
  Ib = glpIBPartialDerefNodeGetIb(Structure);
  if (glpTypeGetKind(SaType) != 1)
  {
    v12 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v113);
    glpLogMessage(v12, 0, (uint64_t)&v113, "You must access an element of the interface block '%.*s'", v13, v14, v15, v16, *(_DWORD *)(Ib + 24));
    return -1;
  }
  v10 = glpStructTypeGetFieldIndex((uint64_t)SaType, Field, v8);
  if (v10 == -1)
  {
    v17 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v112);
    glpLogMessage(v17, 0, (uint64_t)&v112, "Interface block '%.*s' has no variable named '%.*s'", v18, v19, v20, v21, *(_DWORD *)(Ib + 24));
    return -1;
  }
  v11 = v10;
  switch(glpInterfaceBlockObjectGetRepresentation(Ib))
  {
    case 0u:
      glpASTNodeGetLocation(Structure, &v111);
      Structure = glpMakeLValueForVariableObject(a1, &v111, **(uint64_t ***)(Ib + 72));
      goto LABEL_10;
    case 1u:
      glpASTNodeGetLocation(Structure, &v110);
      result = glpMakeLValueForVariableObject(a1, &v110, *(uint64_t **)(*(_QWORD *)(Ib + 72) + 8 * v11));
      break;
    case 2u:
      glpASTNodeGetLocation(Structure, &v109);
      LValueForVariableObject = glpMakeLValueForVariableObject(a1, &v109, **(uint64_t ***)(Ib + 72));
      v24 = glpCompilerGetAllocator(a1);
      glpASTNodeGetLocation(Structure, &v108);
      glpMakeArrayAccessNode(v24, &v108);
      v26 = v25;
      glpArrayAccessNodeSetArray(v25, LValueForVariableObject);
      BankIndex = glpIBPartialDerefNodeGetBankIndex(Structure);
      glpArrayAccessNodeSetElement(v26, BankIndex);
      result = glpSANode(a1, v26);
      Structure = result;
      if (result != -1)
        goto LABEL_10;
      break;
    case 3u:
      glpASTNodeGetLocation(Structure, &v107);
      v78 = glpMakeLValueForVariableObject(a1, &v107, *(uint64_t **)(*(_QWORD *)(Ib + 72) + 8 * v11));
      v79 = glpCompilerGetAllocator(a1);
      glpASTNodeGetLocation(Structure, &v106);
      glpMakeArrayAccessNode(v79, &v106);
      v81 = v80;
      glpArrayAccessNodeSetArray(v80, v78);
      v82 = glpIBPartialDerefNodeGetBankIndex(Structure);
      glpArrayAccessNodeSetElement(v81, v82);
      result = glpSANode(a1, v81);
      break;
    default:
      goto LABEL_10;
  }
  return result;
}

uint64_t glpValidateSwizzle(uint64_t a1, uint64_t a2, unsigned int a3, __int128 *a4, unsigned int a5, _DWORD *a6)
{
  char v7;
  uint64_t **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  signed int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t **InfoLog;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t **v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t **v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int128 v39;
  uint64_t v40;

  v7 = a3;
  if (a3 < 5)
  {
    *a6 = a3;
    if (!a3)
      return 1;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = a3;
    v18 = a3;
    while (1)
    {
      v19 = *(char *)(a2 + v15);
      v20 = v19 - 97;
      if ((v19 - 97) >= 0x1A || (v21 = 0x3CF8043u >> v20, ((0x3CF8043u >> v20) & 1) == 0))
      {
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        v39 = *a4;
        v40 = *((_QWORD *)a4 + 2);
        glpLogMessage(InfoLog, 0, (uint64_t)&v39, "Invalid character '%c' in swizzle", v25, v26, v27, v28, v19);
        return 0;
      }
      v22 = dword_22A97FC08[v20];
      if (v15)
      {
        if (v20 >= 0x1A || (v21 & 1) == 0)
          goto LABEL_22;
        if (v16 != dword_22A97FC70[v20])
        {
          v34 = (uint64_t **)glpCompilerGetInfoLog(a1);
          v39 = *a4;
          v40 = *((_QWORD *)a4 + 2);
          glpLogMessage(v34, 0, (uint64_t)&v39, "Inconsistent component characters in swizzle '%.*s'", v35, v36, v37, v38, v7);
          return 0;
        }
      }
      else
      {
        if (v20 >= 0x1A || (v21 & 1) == 0)
LABEL_22:
          abort();
        v16 = dword_22A97FC70[v20];
      }
      if (v22 >= a5)
        break;
      v18 = v18 & ~(24 << v14) | (v22 << (v14 + 3));
      *a6 = v18;
      ++v15;
      v14 += 2;
      if (v17 == v15)
        return 1;
    }
    v29 = (uint64_t **)glpCompilerGetInfoLog(a1);
    v39 = *a4;
    v40 = *((_QWORD *)a4 + 2);
    glpLogMessage(v29, 0, (uint64_t)&v39, "Swizzle component '%c' indexes beyond end of input vector (length %u)", v30, v31, v32, v33, v19);
  }
  else
  {
    v9 = (uint64_t **)glpCompilerGetInfoLog(a1);
    v39 = *a4;
    v40 = *((_QWORD *)a4 + 2);
    glpLogMessage(v9, 0, (uint64_t)&v39, "Swizzle '%.*s' has more than 4 result components", v10, v11, v12, v13, v7);
  }
  return 0;
}

uint64_t glpEnsureDeref(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t Allocator;
  uint64_t RValueNode;
  uint64_t SaType;
  uint64_t SaFlags;
  uint64_t v10;
  __n128 v12;
  uint64_t v13;

  v13 = 0;
  if (glpIsDerefNode(a2))
  {
    v13 = a2;
  }
  else
  {
    glpHandleSideEffectsForExpr(a1, a2, &v13, a3);
    if (glpIsConstantNode(v13))
    {
      Allocator = glpCompilerGetAllocator(a1);
      glpASTNodeGetLocation(v13, &v12);
      RValueNode = glpMakeRValueNode(Allocator, &v12);
      glpRValueNodeSetBase(RValueNode, v13);
      SaType = glpASTNodeGetSaType(v13);
      glpASTNodeSetSaType(RValueNode, SaType);
      SaFlags = glpASTNodeGetSaFlags(v13);
      glpASTNodeSetSaFlags(RValueNode, SaFlags);
      v13 = RValueNode;
    }
  }
  v10 = glpCompilerGetAllocator(a1);
  glpAddOffsetIfNeeded(v10, v13);
  return v13;
}

uint64_t glpHandleGetterSetter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v13;
  char v14;
  _QWORD *Allocator;
  uint64_t *StringBuffer;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t String;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  char SaFlags;
  _QWORD *v41;
  char v42;
  __n128 v45;
  __n128 v46;

  glpLValueNodeGetVariableName(a2);
  v14 = v13;
  Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
  StringBuffer = glpMakeStringBuffer(Allocator);
  glpStringBufferAppendFormat(StringBuffer, "$%.*s_%.*s", v17, v18, v19, v20, v21, v22, v14);
  if (a8)
    glpStringBufferAppendFormat(StringBuffer, "_%.*s", v23, v24, v25, v26, v27, v28, *(_DWORD *)(a8 + 8));
  v29 = glpCompilerGetAllocator(a1);
  glpASTNodeGetLocation(a2, &v46);
  String = glpStringBufferGetString((uint64_t)StringBuffer);
  v32 = glpMakeFunctionCallNode(v29, &v46, String, v31);
  v33 = (_QWORD *)glpCompilerGetAllocator(a1);
  glpCallNodeAddArg(v33, v32, a4);
  if (a5)
  {
    v34 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCallNodeAddArg(v34, v32, a5);
  }
  v35 = glpCompilerGetAllocator(a1);
  glpASTNodeGetLocation(a2, &v45);
  glpMakeCommaExprNode(v35, &v45, 0);
  v37 = v36;
  glpASTNodeSetSaType(a2, a3);
  v38 = (_QWORD *)glpCompilerGetAllocator(a1);
  glpCommaExprNodeAddExpr(v38, v37, a2);
  v39 = glpSANode(a1, v32);
  glpASTNodeSetSaType(v39, a3);
  SaFlags = glpASTNodeGetSaFlags(v39);
  glpASTNodeSetSaFlags(v39, SaFlags & 0x1F | 0x100);
  v41 = (_QWORD *)glpCompilerGetAllocator(a1);
  glpCommaExprNodeAddExpr(v41, v37, v39);
  glpASTNodeSetSaType(v37, a3);
  v42 = glpASTNodeGetSaFlags(v39);
  glpASTNodeSetSaFlags(v37, v42 & 0x1F | 0x100);
  return v37;
}

uint64_t glpPrecisionQualifierFromSaFlags(char a1)
{
  uint64_t v1;
  int v2;
  unsigned int v3;

  v1 = a1 & 0x1F;
  if (v1 == 8)
    v2 = 23;
  else
    v2 = 19;
  if (v1 == 16)
    v3 = 24;
  else
    v3 = v2;
  if (v1 == 4)
    return 22;
  else
    return v3;
}

uint64_t glpGetMostBasicPrimitiveType(unsigned int *a1)
{
  int Kind;
  unsigned int *ElementType;
  uint64_t v4;
  uint64_t PrimitiveType;

  Kind = glpTypeGetKind(a1);
  if (Kind)
  {
    if (Kind == 2)
    {
      ElementType = (unsigned int *)glpArrayTypeGetElementType((uint64_t)a1);
      glpTypeGetKind(ElementType);
    }
    return 0;
  }
  PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)a1);
  v4 = PrimitiveType;
  if (!(_DWORD)PrimitiveType || (glpPrimitiveTypeGetCategory(PrimitiveType) & 0xFFFFFFFE) != 2)
    return v4;
  return glpPrimitiveTypeGetScalarType(v4);
}

uint64_t glpGetDefaultPrecisionForType(uint64_t a1, unsigned int *a2)
{
  unsigned int MostBasicPrimitiveType;
  unsigned int v4;
  uint64_t NameTable;

  MostBasicPrimitiveType = glpGetMostBasicPrimitiveType(a2);
  if (MostBasicPrimitiveType == 36)
    v4 = 5;
  else
    v4 = MostBasicPrimitiveType;
  if (!v4)
    return 0;
  NameTable = glpCompilerGetNameTable(a1);
  return glpNameTableGetPrecision(NameTable, v4);
}

uint64_t glpSAValidateConstPrecisionConversion(uint64_t a1, uint64_t a2, char a3)
{
  unsigned int *Type;
  uint64_t Value;
  uint64_t result;
  uint64_t PrimitiveType;
  unsigned int Rows;
  unsigned int Columns;
  uint64_t NameTable;
  uint64_t GLSLVersion;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float *v18;
  uint64_t **v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int *v29;
  unsigned int v30;
  uint64_t **InfoLog;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int *v39;
  int v40;
  int v41;
  uint64_t **v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  int *v52;
  uint64_t v53;
  __n128 v54;
  __n128 v55;
  __n128 v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  Type = (unsigned int *)glpConstantNodeGetType(a2);
  Value = glpConstantNodeGetValue(a2);
  result = glpTypeGetKind(Type);
  if (!(_DWORD)result)
  {
    PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)Type);
    result = glpPrimitiveTypeGetCategory(PrimitiveType);
    Rows = result;
    if ((_DWORD)result == 1)
    {
      Columns = 1;
    }
    else
    {
      if ((_DWORD)result == 3)
      {
        Rows = glpPrimitiveMatrixGetRows(PrimitiveType);
        Columns = glpPrimitiveMatrixGetColumns(PrimitiveType);
      }
      else
      {
        if ((_DWORD)result != 2)
          return result;
        Rows = glpPrimitiveVectorGetLength(PrimitiveType);
        Columns = 1;
      }
      LODWORD(PrimitiveType) = glpPrimitiveTypeGetScalarType(PrimitiveType);
    }
    NameTable = glpCompilerGetNameTable(a1);
    GLSLVersion = glpNameTableGetGLSLVersion(NameTable);
    v57 = 0;
    v58 = 0;
    v59 = 0;
    result = glpPopulatePrecisionWidths(GLSLVersion, &v57);
    v51 = Rows;
    if ((_DWORD)PrimitiveType == 36)
    {
      if ((a3 & 0x1F) == 4 && Columns)
      {
        v25 = 0;
        v26 = ~(-1 << SBYTE4(v58));
        v27 = Columns;
        v53 = Rows;
        do
        {
          if (Rows)
          {
            v28 = v53;
            v29 = (unsigned int *)Value;
            do
            {
              v30 = *v29++;
              if (v30 > v26)
              {
                InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
                glpASTNodeGetLocation(a2, &v54);
                result = (uint64_t)glpLogMessage(InfoLog, 1u, (uint64_t)&v54, "Overflow in implicit constant conversion, minimum range for lowp unsigned int is [0,%d]", v32, v33, v34, v35, v26);
              }
              --v28;
            }
            while (v28);
          }
          ++v25;
          Value += 16;
          Rows = v51;
        }
        while (v25 != v27);
      }
    }
    else
    {
      v52 = (int *)Value;
      if ((_DWORD)PrimitiveType == 5)
      {
        if ((a3 & 0x1F) == 4 && Columns)
        {
          v36 = 0;
          v37 = 1 << (BYTE4(v58) - 1);
          v49 = Rows;
          v50 = Columns;
          do
          {
            if (Rows)
            {
              v38 = v49;
              v39 = v52;
              do
              {
                v41 = *v39++;
                v40 = v41;
                if (v41 >= v37 || v40 < -v37)
                {
                  v43 = (uint64_t **)glpCompilerGetInfoLog(a1);
                  glpASTNodeGetLocation(a2, &v55);
                  result = (uint64_t)glpLogMessage(v43, 1u, (uint64_t)&v55, "Overflow in implicit constant conversion, minimum range for lowp int is [%d,%d]", v44, v45, v46, v47, -(char)v37);
                }
                --v38;
              }
              while (v38);
            }
            ++v36;
            v52 += 4;
            Rows = v51;
          }
          while (v36 != v50);
        }
      }
      else if ((_DWORD)PrimitiveType == 1 && (a3 & 0x1F) == 4 && Columns)
      {
        v14 = 0;
        v15 = Columns;
        v16 = Rows;
        do
        {
          if (Rows)
          {
            v17 = v16;
            v18 = (float *)v52;
            do
            {
              if (*v18 >= 2.0 || *v18 <= -2.0)
              {
                v20 = (uint64_t **)glpCompilerGetInfoLog(a1);
                glpASTNodeGetLocation(a2, &v56);
                result = (uint64_t)glpLogMessage(v20, 1u, (uint64_t)&v56, "Overflow in implicit constant conversion, minimum range for lowp float is (-2,2)", v21, v22, v23, v24, v48);
              }
              ++v18;
              --v17;
            }
            while (v17);
          }
          ++v14;
          v52 += 4;
          Rows = v51;
        }
        while (v14 != v15);
      }
    }
  }
  return result;
}

uint64_t glpCheckArrayIndex(uint64_t a1, __int128 *a2, uint64_t a3, int a4, int a5, unsigned int a6, unsigned int *a7)
{
  uint64_t v11;
  unsigned int *SaType;
  _QWORD *Allocator;
  char v16;
  char v17;
  uint64_t **InfoLog;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t DefaultPrecisionForType;
  char *PrimitiveType;
  char SaFlags;
  uint64_t v28;
  uint64_t v29;
  _BOOL4 IsConstantNode;
  unsigned int *Value;
  unsigned int *Type;
  uint64_t NameTable;
  int GLSLVersion;
  char v35;
  uint64_t v36;
  uint64_t ValueHash;
  uint64_t v38;
  uint64_t **v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  char v46;
  char v47;
  uint64_t **v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char v53;
  __int128 v54;
  uint64_t v55;

  v11 = a3;
  SaType = (unsigned int *)glpASTNodeGetSaType(a3);
  if (glpTypeGetKind(SaType)
    || glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType) != 5
    && glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType) != 36)
  {
    Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
    glpTypeHumanReadableDescription((uint64_t)SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
    v17 = v16;
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    v54 = *a2;
    v55 = *((_QWORD *)a2 + 2);
    v53 = v17;
    v23 = "Index expression has type '%.*s' but should have integral type";
LABEL_3:
    glpLogMessage(InfoLog, 0, (uint64_t)&v54, v23, v19, v20, v21, v22, v53);
    return -1;
  }
  if (glpCompilerDoesTypeRequirePrecision(a1, SaType) && (glpASTNodeGetSaFlags(v11) & 0x1F) == 0)
  {
    DefaultPrecisionForType = glpGetDefaultPrecisionForType(a1, SaType);
    if (!DefaultPrecisionForType)
    {
      v45 = (_QWORD *)glpCompilerGetAllocator(a1);
      glpTypeHumanReadableDescription((uint64_t)SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v45);
      v47 = v46;
      v48 = (uint64_t **)glpCompilerGetInfoLog(a1);
      v54 = *a2;
      v55 = *((_QWORD *)a2 + 2);
      glpLogMessage(v48, 0, (uint64_t)&v54, "Array index of type '%.*s' - precision can not be inferred and no default precision available", v49, v50, v51, v52, v47);
      return -1;
    }
    glpPushdownPrecision(a1, v11, DefaultPrecisionForType);
  }
  if (glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType) == 36)
  {
    PrimitiveType = glpGetPrimitiveType(5u);
    SaFlags = glpASTNodeGetSaFlags(v11);
    v28 = glpConvert(a1, v11, (uint64_t)PrimitiveType, SaFlags & 0x1F);
    v29 = glpSANode(a1, v28);
    if ((unint64_t)(v29 + 1) < 2)
      return -1;
    v11 = v29;
  }
  IsConstantNode = glpIsConstantNode(v11);
  if (IsConstantNode)
  {
    Value = (unsigned int *)glpConstantNodeGetValue(v11);
    Type = (unsigned int *)glpConstantNodeGetType(v11);
    if (!glpValueIsUsableAsSize(Type, Value))
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      v54 = *a2;
      v55 = *((_QWORD *)a2 + 2);
      v23 = "Index expression is negative";
      goto LABEL_3;
    }
    *a7 = glpValueGetAsSize((uint64_t)Type, Value);
  }
  NameTable = glpCompilerGetNameTable(a1);
  GLSLVersion = glpNameTableGetGLSLVersion(NameTable);
  v35 = glpASTNodeGetSaFlags(v11);
  if (GLSLVersion == 1)
  {
    if ((v35 & 0x20) != 0)
      goto LABEL_20;
LABEL_25:
    if (!a4)
    {
      if (a5 || a6 != -1)
        return v11;
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      v54 = *a2;
      v55 = *((_QWORD *)a2 + 2);
      v23 = "Indirect index into implicitly-sized array";
      goto LABEL_3;
    }
    goto LABEL_26;
  }
  if ((v35 & 0x40) == 0)
    goto LABEL_25;
LABEL_20:
  v36 = glpCompilerGetAllocator(a1);
  ValueHash = glpCompilerGetValueHash(a1);
  v38 = glpConstantFold(v36, ValueHash, v11);
  if (!IsConstantNode)
  {
LABEL_26:
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    v54 = *a2;
    v55 = *((_QWORD *)a2 + 2);
    v23 = "Index expression must be constant";
    goto LABEL_3;
  }
  v11 = v38;
  if (a6 != -1 && *a7 >= a6)
  {
    v39 = (uint64_t **)glpCompilerGetInfoLog(a1);
    v40 = *a7;
    v54 = *a2;
    v55 = *((_QWORD *)a2 + 2);
    glpLogMessage(v39, 0, (uint64_t)&v54, "Index %u beyond bounds (size %u)", v41, v42, v43, v44, v40);
    return -1;
  }
  return v11;
}

uint64_t glpConvert(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t Allocator;
  uint64_t TypeConversionNode;
  __n128 v11;

  Allocator = glpCompilerGetAllocator(a1);
  glpASTNodeGetLocation(a2, &v11);
  TypeConversionNode = glpMakeTypeConversionNode(Allocator, &v11, a3, a4);
  glpUnaryOperatorNodeSetExpr(TypeConversionNode, a2);
  return glpSANode(a1, TypeConversionNode);
}

uint64_t glpIndirectVectorElement(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Array;
  uint64_t v7;
  uint64_t Element;
  unsigned int Length;
  uint64_t result;
  uint64_t v11;
  uint64_t Offset;
  uint64_t v13;
  uint64_t v14;
  unsigned int ElementType;
  char *PrimitiveType;
  _QWORD *Allocator;
  __n128 v18;
  unsigned int v19;
  uint64_t v20;

  v20 = 0;
  Array = glpArrayAccessNodeGetArray(a2);
  v7 = glpEnsureDeref(a1, Array, &v20);
  Element = glpArrayAccessNodeGetElement(a2);
  v19 = 0;
  glpASTNodeGetLocation(a2, &v18);
  Length = glpPrimitiveVectorGetLength(a3);
  result = glpCheckArrayIndex(a1, (__int128 *)&v18, Element, 0, 0, Length, &v19);
  if (result != -1)
  {
    v11 = result;
    Offset = glpDerefNodeGetOffset(v7);
    glpOffsetNodeSetVectorElementExpr(Offset, v11);
    v13 = glpDerefNodeGetOffset(v7);
    if (!glpOffsetNodeGetPreSwizzlePrimitiveType(v13))
    {
      v14 = glpDerefNodeGetOffset(v7);
      glpOffsetNodeSetPreSwizzlePrimitiveType(v14, a3);
    }
    ElementType = glpPrimitiveVectorGetElementType(a3);
    PrimitiveType = glpGetPrimitiveType(ElementType);
    glpASTNodeSetSaType(v7, (uint64_t)PrimitiveType);
    Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
    return glpMangleSideEffectsWithNewResult(Allocator, v20, v7);
  }
  return result;
}

uint64_t glpIndirectMatrixColumn(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int ColumnType;
  unsigned int *PrimitiveType;

  ColumnType = glpPrimitiveMatrixGetColumnType(a3);
  PrimitiveType = (unsigned int *)glpGetPrimitiveType(ColumnType);
  return glpIndirectArrayElement(a1, a2, PrimitiveType);
}

uint64_t glpIndirectArrayElement(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t Array;
  uint64_t Element;
  uint64_t v8;
  unsigned int *SaType;
  int Kind;
  unsigned int ElementCount;
  int PrimitiveType;
  unsigned int v13;
  uint64_t *v14;
  int v15;
  uint64_t result;
  uint64_t v17;
  uint64_t NameTable;
  uint64_t VariableExtra;
  unsigned int IndexLevel;
  unsigned int v21;
  uint64_t **v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t ImmediateSAContext;
  uint64_t Lhs;
  uint64_t v27;
  uint64_t v28;
  uint64_t Allocator;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t Offset;
  uint64_t OffsetExpr;
  uint64_t v36;
  unsigned int ABI;
  uint64_t **InfoLog;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t SaFlags;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t IntConstant;
  uint64_t v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  char v55;
  __n128 v56;
  uint64_t v57;
  __n128 v58;
  uint64_t v59;
  unsigned int v60;
  __n128 v61;
  uint64_t v62;

  glpASTNodeGetLocation(a2, &v56);
  Array = glpArrayAccessNodeGetArray(a2);
  Element = glpArrayAccessNodeGetElement(a2);
  v62 = 0;
  v8 = glpEnsureDeref(a1, Array, &v62);
  glpASTNodeGetLocation(v8, &v61);
  glpEnsureOffsetsExist(a1, &v61, v8);
  SaType = (unsigned int *)glpASTNodeGetSaType(v8);
  Kind = glpTypeGetKind(SaType);
  if (Kind)
  {
    if (Kind == 3)
    {
      ElementCount = glpBankTypeGetElementCount((uint64_t)SaType);
    }
    else
    {
      if (Kind != 2)
        abort();
      ElementCount = glpArrayTypeGetElementCount((uint64_t)SaType);
    }
  }
  else
  {
    PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType);
    ElementCount = glpPrimitiveMatrixGetColumns(PrimitiveType);
  }
  v13 = ElementCount;
  v15 = glpTypeGetKind(SaType) == 3
     && glpIsLValueNode(v8)
     && (v14 = *(uint64_t **)(glpLValueNodeGetVariableExtra(v8) + 8)) != 0
     && glpLayoutObjectFind(v14, 84) != 0;
  v60 = 0;
  v58 = v56;
  v59 = v57;
  result = glpCheckArrayIndex(a1, (__int128 *)&v58, Element, 0, v15, v13, &v60);
  if (result != -1)
  {
    v17 = result;
    NameTable = glpCompilerGetNameTable(a1);
    if (glpNameTableGetGLSLVersion(NameTable) == 6
      && (glpASTNodeGetSaFlags(v17) & 0x60) == 0
      && glpTypeGetSamplerCount((uint64_t)a3))
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      v58 = v56;
      v59 = v57;
      glpLogMessage(InfoLog, 0, (uint64_t)&v58, "Dynamic indexing of sampler types is not allowed", v39, v40, v41, v42, v55);
      return -1;
    }
    if (glpIsLValueNode(v8)
      && glpIsConstantNode(v17)
      && glpTypeGetKind(SaType) == 2
      && !glpTypeIsSized((int *)SaType))
    {
      VariableExtra = glpLValueNodeGetVariableExtra(v8);
      IndexLevel = glpLValueNodeGetIndexLevel(v8);
      v21 = v60 + 1;
      v22 = (uint64_t **)glpCompilerGetInfoLog(a1);
      v58 = v56;
      v59 = v57;
      if (!glpVariableObjectExtendImplicitArraySize(VariableExtra, IndexLevel, v21, v22, (uint64_t)&v58))
        return -1;
    }
    if (glpIsLValueNode(v8)
      && *(_QWORD *)(glpLValueNodeGetVariableExtra(v8) + 8)
      && ((v23 = glpLValueNodeGetVariableExtra(v8), glpLayoutObjectFind(*(uint64_t **)(v23 + 8), 28))
       || (v24 = glpLValueNodeGetVariableExtra(v8), glpLayoutObjectFind(*(uint64_t **)(v24 + 8), 29))))
    {
      ImmediateSAContext = glpCompilerGetImmediateSAContext(a1);
      if (!glpIsAssignNode(ImmediateSAContext)
        || (Lhs = glpBinaryOperatorNodeGetLhs(ImmediateSAContext), !glpIsArrayAccessNode(Lhs))
        || (v27 = glpBinaryOperatorNodeGetLhs(ImmediateSAContext), v28 = v17, glpArrayAccessNodeGetArray(v27) != v8))
      {
        v28 = v17;
        if (glpTypeGetKind(SaType) == 2)
        {
          v28 = v17;
          if (!glpTypeGetKind(a3))
          {
            Allocator = glpCompilerGetAllocator(a1);
            v30 = v62;
            v31 = glpHandleGetterSetter(a1, v8, (uint64_t)a3, v17, 0, (uint64_t)"getter", 0x7663339F00000006, 0);
            v32 = (_QWORD *)Allocator;
            v33 = v30;
            return glpMangleSideEffectsWithNewResult(v32, v33, v31);
          }
        }
      }
    }
    else
    {
      if (glpTypeGetKind(SaType) == 3)
      {
        Offset = glpDerefNodeGetOffset(v8);
        glpOffsetNodeSetBankIndex(Offset, v17);
        OffsetExpr = glpOffsetNodeGetOffsetExpr(Offset);
      }
      else
      {
        if (glpIsLValueNode(v8))
        {
          v36 = glpLValueNodeGetVariableExtra(v8);
          ABI = glpVariableObjectGetABI(v36);
        }
        else
        {
          ABI = 0;
        }
        SaFlags = glpASTNodeGetSaFlags(v8);
        v44 = glpABIGetArrayStrideForElementType(ABI, (uint64_t)a3, SaFlags);
        if ((SaFlags & 0x400) != 0 && !glpTypeGetKind(SaType))
        {
          v45 = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType);
          v46 = glpDerefNodeGetOffset(v8);
          v47 = glpABIGetMatrixStride(ABI, v45, SaFlags);
          glpOffsetNodeSetCompStride(v46, v47);
          v44 = 4;
        }
        glpASTNodeGetLocation(v8, &v58);
        v48 = glpDerefNodeGetOffset(v8);
        v49 = glpOffsetNodeGetOffsetExpr(v48);
        IntConstant = glpCompilerGetIntConstant(a1, v44);
        OffsetExpr = glpMakeArrayIndexOffsetFragment(a1, &v58, v49, v17, IntConstant);
      }
      v28 = OffsetExpr;
    }
    v51 = glpDerefNodeGetOffset(v8);
    glpOffsetNodeSetOffsetExpr(v51, v28);
    if (glpIsLValueNode(v8))
    {
      v52 = glpLValueNodeGetIndexLevel(v8);
      glpLValueNodeSetIndexLevel(v8, v52 + 1);
    }
    glpASTNodeSetSaType(v8, (uint64_t)a3);
    v53 = glpASTNodeGetSaFlags(v8);
    v54 = glpASTNodeGetSaFlags(v17);
    glpASTNodeSetSaFlags(v8, (v54 | 0x51F) & v53);
    v32 = (_QWORD *)glpCompilerGetAllocator(a1);
    v33 = v62;
    v31 = v8;
    return glpMangleSideEffectsWithNewResult(v32, v33, v31);
  }
  return result;
}

uint64_t glpAnalyzeCallToOverload(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t Allocator;
  unsigned int ImplicitConversionPolicy;
  uint64_t v8;
  _UNKNOWN **v9;
  unsigned int v10;
  int v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;
  int v15;
  _QWORD *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  _BOOL4 v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  unsigned int *SaType;
  uint64_t PrimitiveType;
  int ScalarType;
  uint64_t ElementType;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int ElementFlags;
  int v40;
  int v41;
  int v42;
  int v43;
  _BOOL4 v44;
  BOOL v46;
  BOOL v48;
  BOOL v49;
  BOOL v50;
  uint64_t ReturnType;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD *v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t NameTable;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t *v64;
  size_t v65;
  uint64_t j;
  uint64_t v67;
  const char *v68;
  int v69;
  char v70;
  uint64_t v71;
  _QWORD *v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  _QWORD *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t **v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  unint64_t v85;
  unint64_t v86;
  uint64_t v87;
  uint64_t *v88;
  size_t v89;
  uint64_t i;
  uint64_t v91;
  const char *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  _QWORD *v96;
  uint64_t *StringBuffer;
  uint64_t v98;
  uint64_t v99;
  _QWORD *v100;
  uint64_t v101;
  uint64_t v102;
  _QWORD *v103;
  uint64_t *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  _QWORD *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t **InfoLog;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  _BOOL4 v120;
  unint64_t v121;
  uint64_t v122;
  uint64_t *v123;
  uint64_t *v124;
  _QWORD v125[5];
  __n128 v126;
  __n128 v127;
  uint64_t v128;

  v128 = *MEMORY[0x24BDAC8D0];
  Allocator = glpCompilerGetAllocator(a1);
  v124 = (uint64_t *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(Allocator + 8))(*(_QWORD *)Allocator, 16, "Vector Storage (GLPType *)");
  v122 = a1;
  ImplicitConversionPolicy = glpCompilerGetImplicitConversionPolicy(a1);
  if (a2)
  {
    v8 = 0;
    v9 = &PROMOTIONS + 2 * ImplicitConversionPolicy;
    v123 = (uint64_t *)*v9;
    v10 = *((_DWORD *)v9 + 2);
    v11 = 2;
    do
    {
      v12 = (uint64_t *)a2[1];
      if (_canCall(*a2, a3, (uint64_t)v123, v10))
      {
        v13 = *a2;
        if ((int)v8 + 1 <= v11)
        {
          v18 = v8;
          v17 = v124;
        }
        else
        {
          if (v11 <= 1)
            v14 = 1;
          else
            v14 = v11;
          v15 = 2 * v14;
          if (v15 <= (int)v8 + 1)
            v11 = v8 + 1;
          else
            v11 = v15;
          v16 = (_QWORD *)glpCompilerGetAllocator(v122);
          v17 = (uint64_t *)((uint64_t (*)(_QWORD, uint64_t, const char *))v16[1])(*v16, 8 * v11, "Vector Storage (GLPType *, growth)");
          v18 = v8;
          memcpy(v17, v124, 8 * v8);
          ((void (*)(_QWORD, uint64_t *))v16[3])(*v16, v124);
        }
        v124 = v17;
        v17[v18] = v13;
        v8 = (v8 + 1);
      }
      a2 = v12;
    }
    while (v12);
    v19 = glpCallNodeGetArgCount(a3);
    v20 = v19;
    if ((_DWORD)v8)
    {
      v117 = v8;
      v118 = v19;
      v21 = 0;
      v121 = v8;
      v22 = v124;
      while (1)
      {
        v23 = 0;
        v24 = v22[v21];
        v25 = 1;
        v119 = v21;
        while (1)
        {
          if (v21 != v23)
          {
            v120 = v25;
            v26 = v22[v23];
            v19 = glpCallNodeGetArgCount(a3);
            if ((_DWORD)v19)
            {
              v27 = 0;
              LODWORD(v123) = 0;
              v28 = 0;
              while (1)
              {
                v29 = glpCallNodeGetArg(a3, v27);
                SaType = (unsigned int *)glpASTNodeGetSaType(v29);
                if (!glpTypeGetKind(SaType))
                {
                  PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType);
                  ScalarType = glpPrimitiveTypeGetScalarType(PrimitiveType);
                  ElementType = glpAggregateTypeGetElementType(v24, v27);
                  v34 = glpPrimitiveTypeGetPrimitiveType(ElementType);
                  v35 = glpPrimitiveTypeGetScalarType(v34);
                  v36 = glpAggregateTypeGetElementType(v26, v27);
                  v37 = glpPrimitiveTypeGetPrimitiveType(v36);
                  v38 = glpPrimitiveTypeGetScalarType(v37);
                  ElementFlags = glpAggregateTypeGetElementFlags(v24, v27);
                  if ((ElementFlags & 0x4000000) != 0)
                    v40 = ScalarType;
                  else
                    v40 = v35;
                  if ((ElementFlags & 0x4000000) == 0)
                    v35 = ScalarType;
                  v41 = glpAggregateTypeGetElementFlags(v26, v27);
                  if ((v41 & 0x4000000) != 0)
                    v42 = ScalarType;
                  else
                    v42 = v38;
                  if ((v41 & 0x4000000) != 0)
                    v43 = v38;
                  else
                    v43 = ScalarType;
                  LOBYTE(v44) = v43 == v42;
                  if (v35 == v40 || v43 == v42)
                  {
                    if (v35 != v40)
                      goto LABEL_58;
                  }
                  else
                  {
                    v46 = v35 == 1 && v40 == 62;
                    v44 = v43 == 1 && v42 == 62;
                    if (!v46 && !v44)
                    {
                      v48 = (v35 == 36 || v35 == 5) && v40 == 1;
                      if (v43 != 36 && v43 != 5)
                      {
                        v49 = 0;
                        goto LABEL_68;
                      }
                      if (v42 != 62)
                        v48 = 0;
                      if (!v48)
                      {
                        v49 = v42 == 1;
LABEL_68:
                        if (v35 == 5 || v35 == 36)
                        {
                          if (v40 != 62)
                            v49 = 0;
                          if (v49)
                            v28 = 1;
                        }
                        goto LABEL_22;
                      }
LABEL_65:
                      LODWORD(v123) = 1;
                      goto LABEL_22;
                    }
                    if (!v46)
                    {
LABEL_58:
                      v28 = 1;
                      goto LABEL_22;
                    }
                  }
                  if (!v44)
                    goto LABEL_65;
                }
LABEL_22:
                ++v27;
                v19 = glpCallNodeGetArgCount(a3);
                if (v27 >= v19)
                  goto LABEL_75;
              }
            }
            v28 = 0;
            LODWORD(v123) = 0;
LABEL_75:
            v50 = (_DWORD)v123 || v28 == 0;
            v22 = v124;
            v21 = v119;
            if (!v50 || v28 || !(_DWORD)v123)
              break;
          }
          v25 = ++v23 < v121;
          if (v23 == v121)
            goto LABEL_87;
        }
        if (!v120)
        {
LABEL_87:
          if (!v24)
            goto LABEL_104;
          _makeConversions(v122, v24, a3);
          ReturnType = glpFunctionTypeGetReturnType(v24);
          glpASTNodeSetSaType(a3, ReturnType);
          v52 = glpFunctionCallNodeGetName(a3);
          v54 = v53;
          v55 = (_QWORD *)glpCompilerGetAllocator(v122);
          v56 = (char *)glpAggregateTypeMangleName(v24, v52, v54, v55);
          v58 = v57;
          NameTable = glpCompilerGetNameTable(v122);
          v125[0] = MEMORY[0x24BDAC760];
          v125[1] = 0x40000000;
          v125[2] = __glpAnalyzeCallToOverload_block_invoke;
          v125[3] = &__block_descriptor_tmp_7;
          v125[4] = a3;
          glpNameTableGet(NameTable, v56, v58, 0, (uint64_t)v125);
          return 1;
        }
        v21 = v119 + 1;
        if (v119 + 1 == v121)
        {
LABEL_104:
          v84 = v118;
          v85 = v118;
          MEMORY[0x24BDAC7A8](v19);
          v88 = (uint64_t *)((char *)&v116 - v87);
          if (v86 >= 0x200)
            v89 = 512;
          else
            v89 = v86;
          bzero((char *)&v116 - v87, v89);
          if (v84)
          {
            for (i = 0; i != v84; v88[i++] = glpASTNodeGetSaType(v91))
              v91 = glpCallNodeGetArg(a3, i);
          }
          v92 = (const char *)glpFunctionCallNodeGetName(a3);
          v94 = v93;
          v95 = v122;
          if (!glpOperatorAsFunctionError(v122, v92, v93, v88, a3))
          {
            v123 = &v116;
            v96 = (_QWORD *)glpCompilerGetAllocator(v95);
            StringBuffer = glpMakeStringBuffer(v96);
            if ((_DWORD)v118)
            {
              v98 = 0;
              do
              {
                v99 = v88[v98];
                v100 = (_QWORD *)glpCompilerGetAllocator(v122);
                v101 = glpTypeHumanReadableDescription(v99, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v100);
                glpStringBufferAppendString(StringBuffer, v101, v102);
                if (++v98 < v85)
                  glpStringBufferAppendCString(StringBuffer, ", ");
              }
              while (v85 != v98);
            }
            v103 = (_QWORD *)glpCompilerGetAllocator(v122);
            v104 = glpMakeStringBuffer(v103);
            v105 = 0;
            if (v117 <= 1)
              v106 = 1;
            else
              v106 = v117;
            do
            {
              glpStringBufferAppendCString(v104, "    ");
              v107 = v124[v105];
              v108 = (_QWORD *)glpCompilerGetAllocator(v122);
              v109 = glpTypeHumanReadableDescription(v107, (uint64_t)v92, v94, v108);
              glpStringBufferAppendString(v104, v109, v110);
              if (++v105 < v121)
                glpStringBufferAppendCString(v104, "\n");
            }
            while (v106 != v105);
            InfoLog = (uint64_t **)glpCompilerGetInfoLog(v122);
            glpASTNodeGetLocation(a3, &v126);
            glpStringBufferGetCString(StringBuffer);
            glpStringBufferGetCString(v104);
            glpLogMessage(InfoLog, 0, (uint64_t)&v126, "Ambiguous call to function %.*s(%s).   Candidates are:\n%s", v112, v113, v114, v115, v94);
          }
          return 0;
        }
      }
    }
  }
  else
  {
    v19 = glpCallNodeGetArgCount(a3);
    v20 = v19;
  }
  v61 = v20;
  MEMORY[0x24BDAC7A8](v19);
  v64 = (uint64_t *)((char *)&v116 - v63);
  if (v62 >= 0x200)
    v65 = 512;
  else
    v65 = v62;
  bzero((char *)&v116 - v63, v65);
  if (v20)
  {
    for (j = 0; j != v20; v64[j++] = glpASTNodeGetSaType(v67))
      v67 = glpCallNodeGetArg(a3, j);
  }
  v68 = (const char *)glpFunctionCallNodeGetName(a3);
  v70 = v69;
  v71 = v122;
  if (!glpOperatorAsFunctionError(v122, v68, v69, v64, a3))
  {
    v124 = &v116;
    v72 = (_QWORD *)glpCompilerGetAllocator(v71);
    v73 = glpMakeStringBuffer(v72);
    if ((_DWORD)v61)
    {
      v74 = 0;
      do
      {
        v75 = v64[v74];
        v76 = (_QWORD *)glpCompilerGetAllocator(v122);
        v77 = glpTypeHumanReadableDescription(v75, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v76);
        glpStringBufferAppendString(v73, v77, v78);
        if (++v74 < v61)
          glpStringBufferAppendCString(v73, ", ");
      }
      while (v61 != v74);
    }
    v79 = (uint64_t **)glpCompilerGetInfoLog(v122);
    glpASTNodeGetLocation(a3, &v127);
    glpStringBufferGetCString(v73);
    glpLogMessage(v79, 0, (uint64_t)&v127, "No matching function for call to %.*s(%s)", v80, v81, v82, v83, v70);
  }
  return 0;
}

uint64_t _canCall(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  unsigned int *SaType;
  unsigned int *ElementType;
  int ElementFlags;
  uint64_t PrimitiveType;
  uint64_t v16;
  uint64_t result;
  int ScalarType;
  int v19;
  uint64_t v20;
  _DWORD *j;
  uint64_t v22;
  _DWORD *i;

  v8 = glpCallNodeGetArgCount(a2);
  if (v8 != glpAggregateTypeGetElementCount(a1))
    return 0;
  if (v8)
  {
    v9 = 0;
    v10 = (_DWORD *)(a3 + 4);
    do
    {
      v11 = glpCallNodeGetArg(a2, v9);
      SaType = (unsigned int *)glpASTNodeGetSaType(v11);
      ElementType = (unsigned int *)glpAggregateTypeGetElementType(a1, v9);
      ElementFlags = glpAggregateTypeGetElementFlags(a1, v9);
      if (!glpTypesEqual(SaType, (uint64_t)ElementType))
      {
        if ((~ElementFlags & 0x6000000) == 0
          || glpTypeGetKind(SaType)
          || glpTypeGetKind(ElementType))
        {
          return 0;
        }
        PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType);
        v16 = glpPrimitiveTypeGetPrimitiveType((uint64_t)ElementType);
        result = _primitiveStructuresMatch(PrimitiveType, v16);
        if (!(_DWORD)result)
          return result;
        ScalarType = glpPrimitiveTypeGetScalarType(PrimitiveType);
        v19 = glpPrimitiveTypeGetScalarType(v16);
        if ((ElementFlags & 0x4000000) != 0)
        {
          if (!a4)
            return 0;
          v22 = a4;
          for (i = v10; *(i - 1) != v19 || *i != ScalarType; i += 2)
          {
            if (!--v22)
              return 0;
          }
        }
        else
        {
          if (!a4)
            return 0;
          v20 = a4;
          for (j = v10; *(j - 1) != ScalarType || *j != v19; j += 2)
          {
            if (!--v20)
              return 0;
          }
        }
      }
      ++v9;
    }
    while (v9 != v8);
  }
  return 1;
}

uint64_t glpOperatorAsFunctionError(uint64_t a1, const char *a2, int a3, uint64_t *a4, uint64_t a5)
{
  int v8;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *Allocator;
  _QWORD *v14;
  uint64_t **InfoLog;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t **v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  char v27;
  __n128 v28;
  __n128 v29;
  char __s2[4];
  char v31;

  if (a3 >= 4)
    v8 = 4;
  else
    v8 = a3;
  if (strncmp("$OP_", a2, v8))
    return 0;
  v10 = glpCallNodeGetArgCount(a5);
  v11 = *a4;
  if (v10 == 2)
  {
    v12 = a4[1];
    Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
    glpTypeHumanReadableDescription(v11, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
    v14 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpTypeHumanReadableDescription(v12, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v14);
    v31 = 0;
    *(_DWORD *)__s2 = 0;
    __strncpy_chk();
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a5, &v29);
    v26 = glpBinaryOperatorStringToSymbol(__s2);
    glpLogMessage(InfoLog, 0, (uint64_t)&v29, "'%s' does not operate on '%.*s' and '%.*s'", v16, v17, v18, v19, v26);
  }
  else
  {
    v20 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpTypeHumanReadableDescription(v11, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v20);
    v31 = 0;
    *(_DWORD *)__s2 = 0;
    __strncpy_chk();
    v21 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a5, &v28);
    v27 = glpUnaryOperatorStringToSymbol(__s2);
    glpLogMessage(v21, 0, (uint64_t)&v28, "'%s' does not operate on '%.*s'", v22, v23, v24, v25, v27);
  }
  return 1;
}

uint64_t _makeConversions(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  int v6;
  unsigned int i;
  uint64_t v8;
  unsigned int *SaType;
  uint64_t v10;
  uint64_t ElementType;
  int ElementFlags;
  uint64_t v13;

  result = glpCallNodeGetArgCount(a3);
  if ((_DWORD)result)
  {
    v6 = result;
    for (i = 0; i != v6; ++i)
    {
      v8 = glpCallNodeGetArg(a3, i);
      SaType = (unsigned int *)glpASTNodeGetSaType(v8);
      v10 = glpASTNodeGetSaFlags(v8) & 0x1F;
      ElementType = glpAggregateTypeGetElementType(a2, i);
      ElementFlags = glpAggregateTypeGetElementFlags(a2, i);
      v13 = ElementFlags & 0x1F;
      result = glpTypesEqual(SaType, ElementType);
      if (!(_DWORD)result || v10 != v13)
      {
        if ((ElementFlags & 0x2000000) != 0)
          v8 = glpConvert(a1, v8, ElementType, v13);
        if ((ElementFlags & 0x4000000) != 0)
          v8 = glpConvert(a1, v8, (uint64_t)SaType, v10);
        result = glpCallNodeSetArg(a3, i, v8);
      }
    }
  }
  return result;
}

uint64_t __glpAnalyzeCallToOverload_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t result;

  result = glpFunctionCallNodeSetExtra(*(_QWORD *)(a1 + 32), a3);
  *a5 = 1;
  return result;
}

uint64_t glpAnalyzeCallToFunction(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  unsigned int ImplicitConversionPolicy;
  uint64_t ReturnType;
  char v9;
  char v10;
  uint64_t **InfoLog;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __n128 v16;

  ImplicitConversionPolicy = glpCompilerGetImplicitConversionPolicy(a1);
  if (_canCall(*a2, a3, (uint64_t)*(&PROMOTIONS + 2 * ImplicitConversionPolicy), *((_DWORD *)&PROMOTIONS + 4 * ImplicitConversionPolicy + 2)))
  {
    _makeConversions(a1, *a2, a3);
    ReturnType = glpFunctionTypeGetReturnType(*a2);
    glpASTNodeSetSaType(a3, ReturnType);
    glpFunctionCallNodeSetExtra(a3, (uint64_t)a2);
    return 1;
  }
  else
  {
    glpFunctionCallNodeGetName(a3);
    v10 = v9;
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a3, &v16);
    glpLogMessage(InfoLog, 0, (uint64_t)&v16, "Cannot call '%.*s'", v12, v13, v14, v15, v10);
    return 0;
  }
}

uint64_t glpAnalyzeCallToSubroutineArray(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  unsigned int ImplicitConversionPolicy;
  uint64_t ReturnType;
  char v9;
  char v10;
  uint64_t **InfoLog;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __n128 v16;

  ImplicitConversionPolicy = glpCompilerGetImplicitConversionPolicy(a1);
  if (_canCall(*a2, a3, (uint64_t)*(&PROMOTIONS + 2 * ImplicitConversionPolicy), *((_DWORD *)&PROMOTIONS + 4 * ImplicitConversionPolicy + 2)))
  {
    _makeConversions(a1, *a2, a3);
    ReturnType = glpFunctionTypeGetReturnType(*a2);
    glpASTNodeSetSaType(a3, ReturnType);
    return 1;
  }
  else
  {
    glpSubroutineArrayCallNodeGetName(a3);
    v10 = v9;
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a3, &v16);
    glpLogMessage(InfoLog, 0, (uint64_t)&v16, "Cannot call subroutine array '%.*s'", v12, v13, v14, v15, v10);
    return 0;
  }
}

uint64_t glpCanConvert(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;
  int ScalarType;
  int v8;
  uint64_t v9;
  _DWORD *i;

  result = _primitiveStructuresMatch(a1, a2);
  if ((_DWORD)result)
  {
    ScalarType = glpPrimitiveTypeGetScalarType(a1);
    v8 = glpPrimitiveTypeGetScalarType(a2);
    if (a3)
    {
      v9 = *((unsigned int *)&PROMOTIONS + 4 * a3 + 2);
      for (i = (_DWORD *)((char *)*(&PROMOTIONS + 2 * a3) + 4); *(i - 1) != ScalarType || *i != v8; i += 2)
      {
        if (!--v9)
          return 0;
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t _primitiveStructuresMatch(uint64_t a1, uint64_t a2)
{
  int Category;
  uint64_t result;
  int Length;
  int Rows;
  int Columns;
  BOOL v9;

  Category = glpPrimitiveTypeGetCategory(a1);
  if (Category != glpPrimitiveTypeGetCategory(a2))
    return 0;
  result = 1;
  switch(Category)
  {
    case 0:
      return 0;
    case 1:
      return result;
    case 2:
      Length = glpPrimitiveVectorGetLength(a1);
      Rows = glpPrimitiveVectorGetLength(a2);
      goto LABEL_6;
    case 3:
      Columns = glpPrimitiveMatrixGetColumns(a1);
      if (Columns != glpPrimitiveMatrixGetColumns(a2))
        return 0;
      Length = glpPrimitiveMatrixGetRows(a1);
      Rows = glpPrimitiveMatrixGetRows(a2);
LABEL_6:
      v9 = Length == Rows;
LABEL_9:
      result = v9;
      break;
    case 4:
      v9 = (_DWORD)a1 == (_DWORD)a2;
      goto LABEL_9;
    default:
      abort();
  }
  return result;
}

uint64_t glpEvaluateArraySize(uint64_t a1, __int128 *a2, uint64_t a3, int *a4)
{
  uint64_t NameTable;
  unsigned int GLSLVersion;
  int Language;
  char SaFlags;
  uint64_t Allocator;
  uint64_t ValueHash;
  uint64_t v14;
  uint64_t result;
  unsigned int *Value;
  unsigned int *Type;
  int AsSize;
  uint64_t **InfoLog;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  unsigned int v27;
  uint64_t VariableExtra;
  __int128 v31;
  uint64_t v32;

  NameTable = glpCompilerGetNameTable(a1);
  GLSLVersion = glpNameTableGetGLSLVersion(NameTable);
  Language = glpNameTableGetLanguage(NameTable);
  if (!a3)
  {
    v27 = 1;
LABEL_20:
    if (Language == 3 && GLSLVersion < 3 && a3 == 0)
      result = 3;
    else
      result = v27;
    AsSize = -1;
    goto LABEL_30;
  }
  SaFlags = glpASTNodeGetSaFlags(a3);
  if ((GLSLVersion != 1 || (SaFlags & 0x20) == 0) && (GLSLVersion == 1 || (SaFlags & 0x40) == 0))
  {
    if (!glpIsLValueNode(a3)
      || (VariableExtra = glpLValueNodeGetVariableExtra(a3),
          !glpStringsEqual("gl_VerticesIn", 0x6B1263A0000000DLL, *(char **)(VariableExtra + 16), *(_QWORD *)(VariableExtra + 24))))
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      v31 = *a2;
      v32 = *((_QWORD *)a2 + 2);
      v26 = "Array size must be a constant";
      goto LABEL_36;
    }
    v27 = 3;
    goto LABEL_20;
  }
  Allocator = glpCompilerGetAllocator(a1);
  ValueHash = glpCompilerGetValueHash(a1);
  v14 = glpConstantFold(Allocator, ValueHash, a3);
  result = glpIsConstantNode(v14);
  if (!(_DWORD)result)
    return result;
  Value = (unsigned int *)glpConstantNodeGetValue(v14);
  Type = (unsigned int *)glpConstantNodeGetType(v14);
  if (!glpValueIsUsableAsSize(Type, Value))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    v31 = *a2;
    v32 = *((_QWORD *)a2 + 2);
    v26 = "Array size must be an integer constant expression";
    goto LABEL_36;
  }
  AsSize = glpValueGetAsSize((uint64_t)Type, Value);
  if (Language == 3 && GLSLVersion < 3 && v14 == 0)
    result = 3;
  else
    result = 2;
  if (AsSize)
  {
LABEL_30:
    *a4 = AsSize;
    return result;
  }
  InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
  v31 = *a2;
  v32 = *((_QWORD *)a2 + 2);
  v26 = "Array size must be greater than zero";
LABEL_36:
  glpLogMessage(InfoLog, 0, (uint64_t)&v31, v26, v22, v23, v24, v25, v31);
  return 0;
}

uint64_t glpEvaluateTypeNode(uint64_t a1, __int128 *a2, unsigned int a3, int a4, uint64_t a5, uint64_t a6, unsigned int **a7, uint64_t a8, uint64_t **a9, uint64_t *a10)
{
  uint64_t Qualifiers;
  uint64_t result;
  uint64_t **InfoLog;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  unsigned int *ElementType;
  unsigned int *v26;
  _QWORD *Allocator;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  unsigned int v32;
  unsigned __int8 v33;
  uint64_t PrimitiveType;
  unsigned int *v35;
  _QWORD *v36;
  uint64_t v37;
  unsigned int v38;
  char v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BOOL4 DoesTrackPrecision;
  __int128 *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t NameTable;
  unsigned int GLSLVersion;
  unsigned int Language;
  _BOOL4 IsExtensionEnabled;
  BOOL v53;
  int Kind;
  unsigned int *v55;
  uint64_t v56;
  int v57;
  int v58;
  unsigned int *v59;
  _BOOL4 v60;
  uint64_t v61;
  int v62;
  int v63;
  int v64;
  int v65;
  _BOOL4 v66;
  _BOOL4 v67;
  int v68;
  unsigned int v69;
  int v70;
  uint64_t ScalarType;
  unsigned int *v72;
  unsigned int *v73;
  _QWORD *v74;
  char v75;
  char v76;
  uint64_t **v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  char v82;
  uint64_t MostBasicPrimitiveType;
  int Category;
  uint64_t DefaultPrecisionForType;
  unsigned int *v86;
  _QWORD *v87;
  char v88;
  char v89;
  uint64_t **v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  _BOOL4 v95;
  int v96;
  uint64_t v97;
  int v98;
  int v99;
  int v100;
  BOOL v101;
  _BOOL4 v102;
  uint64_t *v103;
  _BOOL4 v104;
  int v105;
  _BOOL4 v106;
  int v107;
  _BOOL4 v108;
  int v109;
  int v110;
  _BOOL4 v111;
  int v112;
  int v113;
  unsigned int *v114;
  int v115;
  uint64_t **v116;
  const char *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unsigned int *v122;
  uint64_t v123;
  int ElementCount;
  int ImpliedBankSize;
  uint64_t **v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  const char *v131;
  uint64_t v132;
  unsigned int *v133;
  _QWORD *v134;
  char v135;
  char v136;
  uint64_t **v137;
  uint64_t v138;
  unsigned int v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  char v144;
  unsigned int v145;
  char v146;
  int v147;
  int v148;
  BOOL v149;
  uint64_t v150;
  int v151;
  int v152;
  uint64_t **v153;
  unsigned int v154;
  __int128 *i;
  _QWORD v157[6];
  _BOOL4 v158;
  __int128 v159;
  uint64_t v160;
  _QWORD v161[6];
  _BOOL4 v162;
  uint64_t v163;
  uint64_t *v164;
  uint64_t v165;
  uint64_t v166;
  __int128 v167;
  uint64_t v168;
  int v169;

  *a7 = (unsigned int *)glpASTNodeGetSaType(a5);
  if (glpIsQualifiedTypeNode(a5))
    Qualifiers = glpQualifiedTypeNodeGetQualifiers(a5);
  else
    Qualifiers = 0;
  result = glpParseQualifiers(a1, a3, Qualifiers, a6, (uint64_t *)a8, a9, a10);
  if (!(_DWORD)result)
    return result;
  if (glpTypeGetKind(*a7) == 5 && (*(_BYTE *)(a8 + 4) & 1) == 0)
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    v167 = *a2;
    v168 = *((_QWORD *)a2 + 2);
    v24 = "Only subroutine uniforms may have subroutine types";
LABEL_152:
    glpLogMessage(InfoLog, 0, (uint64_t)&v167, v24, v20, v21, v22, v23, v144);
    return 0;
  }
  ElementType = *a7;
  for (i = a2;
        glpTypeGetKind(ElementType) == 2;
  if ((*(_BYTE *)a8 & 0x1F) != 0)
  {
    if (glpTypeGetKind(ElementType))
    {
      v26 = *a7;
      Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
      glpTypeHumanReadableDescription((uint64_t)v26, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
      v28 = glpCompilerGetInfoLog(a1);
      v29 = *(_QWORD *)a8 & 0x1FLL;
      if (v29 == 8)
        v30 = 23;
      else
        v30 = 19;
      if (v29 == 16)
        v31 = 24;
      else
        v31 = v30;
      if (v29 == 4)
        v32 = 22;
      else
        v32 = v31;
      v33 = glpQualifierName(v32);
      v167 = *a2;
      v168 = *((_QWORD *)a2 + 2);
      v144 = v33;
      v24 = "'%s' : precision qualifier not allowed for type %.*s";
      goto LABEL_22;
    }
    PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)ElementType);
    if ((glpPrimitiveTypeGetCategory(PrimitiveType) & 0xFFFFFFFB) != 0)
      LODWORD(PrimitiveType) = glpPrimitiveTypeGetScalarType(PrimitiveType);
    if ((_DWORD)PrimitiveType == 9 || !(_DWORD)PrimitiveType)
    {
      v35 = *a7;
      v36 = (_QWORD *)glpCompilerGetAllocator(a1);
      glpTypeHumanReadableDescription((uint64_t)v35, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v36);
      v153 = (uint64_t **)glpCompilerGetInfoLog(a1);
      v37 = *(_QWORD *)a8 & 0x1FLL;
      switch(v37)
      {
        case 4:
          v38 = 22;
          break;
        case 16:
          v38 = 24;
          break;
        case 8:
          v38 = 23;
          break;
        default:
          v38 = 19;
          break;
      }
      v39 = glpQualifierName(v38);
      v167 = *i;
      v168 = *((_QWORD *)i + 2);
      glpLogMessage(v153, 0, (uint64_t)&v167, "'%s' : precision qualifier not allowed for type %.*s", v40, v41, v42, v43, v39);
      return 0;
    }
  }
  if (!glpCompilerDoesTrackPrecision(a1))
    *(_QWORD *)a8 &= 0xFFFFFFFFFFFFFFE0;
  DoesTrackPrecision = glpCompilerDoesTrackPrecision(a1);
  v45 = i;
  if (a4)
  {
    if (DoesTrackPrecision && (*(_BYTE *)a8 & 0x1F) == 0 && !glpTypeGetKind(ElementType))
    {
      MostBasicPrimitiveType = glpGetMostBasicPrimitiveType(ElementType);
      Category = glpPrimitiveTypeGetCategory(MostBasicPrimitiveType);
      if (Category)
      {
        if (Category != 4)
          LODWORD(MostBasicPrimitiveType) = glpPrimitiveTypeGetScalarType(MostBasicPrimitiveType);
        DefaultPrecisionForType = glpGetDefaultPrecisionForType(a1, ElementType);
        if (!DefaultPrecisionForType && (_DWORD)MostBasicPrimitiveType != 9)
        {
          v86 = *a7;
          v87 = (_QWORD *)glpCompilerGetAllocator(a1);
          glpTypeHumanReadableDescription((uint64_t)v86, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v87);
          v89 = v88;
          v90 = (uint64_t **)glpCompilerGetInfoLog(a1);
          v167 = *i;
          v168 = *((_QWORD *)i + 2);
          glpLogMessage(v90, 0, (uint64_t)&v167, "'%.*s' : declaration must include a precision qualifier for type", v91, v92, v93, v94, v89);
          return 0;
        }
        if ((_DWORD)MostBasicPrimitiveType != 9)
          *(_QWORD *)a8 |= DefaultPrecisionForType;
      }
    }
  }
  if ((glpASTNodeGetSaFlags(a5) & 0x8000000) != 0)
  {
    if (!*a9)
    {
      v46 = glpCompilerGetAllocator(a1);
      *a9 = glpMakeLayoutObject(v46);
    }
    v47 = glpCompilerGetAllocator(a1);
    v48 = *a9;
    *(_QWORD *)&v167 = "-1";
    *((_QWORD *)&v167 + 1) = 0xEDA00000002;
    v168 = 0xFFFFFFFFLL;
    glpLayoutObjectAppend(v47, 0, (uint64_t)&v167, 0, 0, v48, 84);
  }
  if ((*(_BYTE *)(a8 + 3) & 0x60) == 0)
  {
    Kind = glpTypeGetKind(*a7);
    v55 = *a7;
    if (Kind == 2)
      v55 = (unsigned int *)glpArrayTypeGetElementType((uint64_t)v55);
    if (glpTypeGetKind(v55) == 2)
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      v167 = *i;
      v168 = *((_QWORD *)i + 2);
      v24 = "Multi-dimensional array types not supported";
      goto LABEL_152;
    }
    if ((~*(_QWORD *)a8 & 0x300000000) == 0 && glpTypeGetKind(*a7) != 5)
    {
      if (glpTypeGetKind(*a7) != 2
        || (v72 = (unsigned int *)glpArrayTypeGetElementType((uint64_t)*a7), glpTypeGetKind(v72) != 5))
      {
        v73 = *a7;
        v74 = (_QWORD *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription((uint64_t)v73, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v74);
        v76 = v75;
        v77 = (uint64_t **)glpCompilerGetInfoLog(a1);
        v167 = *i;
        v168 = *((_QWORD *)i + 2);
        glpLogMessage(v77, 0, (uint64_t)&v167, "subroutine uniform may not have non-subroutine type '%.*s'", v78, v79, v80, v81, v76);
        return 0;
      }
    }
    goto LABEL_116;
  }
  NameTable = glpCompilerGetNameTable(a1);
  GLSLVersion = glpNameTableGetGLSLVersion(NameTable);
  Language = glpNameTableGetLanguage(NameTable);
  IsExtensionEnabled = glpNameTableIsExtensionEnabled(NameTable, 0x23u);
  v53 = GLSLVersion > 2 || glpNameTableIsExtensionEnabled(NameTable, 0xEu);
  v146 = v53;
  v150 = *(_QWORD *)a8;
  v56 = (*(_QWORD *)a8 >> 29) & 1;
  if (Language)
    v57 = 0;
  else
    v57 = (*(_QWORD *)a8 >> 29) & 1;
  v152 = v57;
  if (Language != 4)
    LODWORD(v56) = 0;
  v148 = v56;
  v149 = Language == 4;
  v58 = glpTypeGetKind(*a7);
  v59 = *a7;
  v147 = v58;
  if (v58 == 2)
    v59 = (unsigned int *)glpArrayTypeGetElementType((uint64_t)v59);
  v151 = glpTypeGetKind(v59);
  if (v151 == 2)
    v59 = (unsigned int *)glpArrayTypeGetElementType((uint64_t)v59);
  v154 = GLSLVersion;
  v145 = Language;
  v60 = IsExtensionEnabled;
  if (glpTypeGetKind(v59))
    v61 = 0;
  else
    v61 = glpPrimitiveTypeGetPrimitiveType((uint64_t)v59);
  v62 = glpPrimitiveTypeGetCategory(v61);
  v63 = glpPrimitiveTypeGetCategory(v61);
  v64 = v63;
  if (!v62)
  {
    v65 = 0;
    v66 = 0;
    goto LABEL_69;
  }
  v63 = glpPrimitiveTypeGetCategory(v61);
  if (v64 == 4)
  {
    v65 = 0;
    v62 = 0;
    v66 = 0;
LABEL_69:
    v67 = v60;
    v68 = v152;
    v69 = v154;
    goto LABEL_91;
  }
  v70 = v63;
  ScalarType = glpPrimitiveTypeGetScalarType(v61);
  v62 = ScalarType;
  v67 = v60;
  if ((_DWORD)ScalarType != 9 || v60)
  {
    v82 = v146;
    if (v60)
      v82 = 1;
    v69 = v154;
    if ((v82 & 1) != 0 || (_DWORD)ScalarType == 1)
    {
      v95 = v67;
      v96 = glpPrimitiveTypeGetScalarType(ScalarType);
      v67 = v95;
      v66 = v96 == 62;
      v65 = 1;
    }
    else
    {
      v65 = 0;
      v66 = 0;
    }
  }
  else
  {
    v65 = 0;
    v66 = 0;
    v62 = 9;
    v69 = v154;
  }
  v68 = v152;
  v63 = v70;
LABEL_91:
  v97 = *(_QWORD *)a8;
  if ((*(_QWORD *)a8 & 0x1000000000) != 0)
  {
    v99 = 1;
    if (!v68)
      goto LABEL_100;
LABEL_110:
    if (v151 == 2)
      v65 = 0;
    v101 = v69 > 4;
    v45 = i;
    if (v101)
    {
LABEL_115:
      if (v65)
        goto LABEL_116;
LABEL_177:
      v133 = *a7;
      v134 = (_QWORD *)glpCompilerGetAllocator(a1);
      glpTypeHumanReadableDescription((uint64_t)v133, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v134);
      v136 = v135;
      v137 = (uint64_t **)glpCompilerGetInfoLog(a1);
      v138 = glpCompilerGetNameTable(a1);
      v139 = glpNameTableGetLanguage(v138);
      glpLanguageToString(v139);
      v167 = *v45;
      v168 = *((_QWORD *)v45 + 2);
      glpLogMessage(v137, 0, (uint64_t)&v167, "%.*s can't be an %s in the %s shader", v140, v141, v142, v143, v136);
      return 0;
    }
LABEL_113:
    if (v147 == 2)
      v65 = 0;
    goto LABEL_115;
  }
  v98 = v148 ^ 1;
  if (v69 <= 4)
    v98 = 0;
  if (v62 == 1)
    v98 = 1;
  if (v67)
    v99 = 1;
  else
    v99 = v98;
  if (v68)
    goto LABEL_110;
LABEL_100:
  if ((*(_DWORD *)&v149 & (v150 >> 30)) != 0)
  {
    if (v63 == 3)
      v100 = 0;
    else
      v100 = v65;
    if (v151 == 2)
      v100 = 0;
    v65 = v100 & !v66;
    v101 = v69 > 2;
    v45 = i;
    if (v101 || v67)
      goto LABEL_115;
    goto LABEL_113;
  }
  v45 = i;
  if (a3 - 9 < 2 || (v97 & 0x20000000000) != 0)
    goto LABEL_136;
  if (*a9)
  {
    v102 = v67;
    v103 = glpLayoutObjectFind(*a9, 83);
    v67 = v102;
    if (v103)
      goto LABEL_136;
    v97 = *(_QWORD *)a8;
  }
  if ((v97 & 0x20000000) == 0)
  {
LABEL_132:
    if ((v97 & 0x40000000) != 0)
    {
      v106 = v67;
      v107 = glpBankForOutputsInLanguage(v145);
      v67 = v106;
      if (v107)
        goto LABEL_134;
    }
LABEL_136:
    if (v151 == 2)
      v110 = 0;
    else
      v110 = v65;
    v65 = v110 & v99;
    if (v154 < 5)
      goto LABEL_176;
    if ((v65 & 1) == 0)
    {
      v111 = v67;
      v112 = glpTypeGetKind(*a7);
      v67 = v111;
      if (v112 != 1)
      {
        if (v147 != 2)
          goto LABEL_177;
        if (v151 == 2)
          goto LABEL_177;
        v113 = glpTypeGetKind(v59);
        v67 = v111;
        if (v113 != 1)
          goto LABEL_177;
      }
    }
    *(_QWORD *)&v167 = 0;
    *((_QWORD *)&v167 + 1) = &v167;
    v168 = 0x2000000000;
    v169 = 1;
    v163 = 0;
    v164 = &v163;
    v165 = 0x2000000000;
    v166 = 0;
    v114 = *a7;
    v157[0] = MEMORY[0x24BDAC760];
    v157[1] = 0x40000000;
    v157[2] = __glpEvaluateTypeNode_block_invoke_2;
    v157[3] = &unk_24F4B08E8;
    v158 = v67;
    v157[4] = &v167;
    v157[5] = &v163;
    glpEachPrimitiveComponentOfType((uint64_t)v114, (uint64_t)v157);
    if (*(_DWORD *)(*((_QWORD *)&v167 + 1) + 24))
    {
      _Block_object_dispose(&v163, 8);
      _Block_object_dispose(&v167, 8);
      goto LABEL_116;
    }
    goto LABEL_171;
  }
  v104 = v67;
  v105 = glpBankForInputsInLanguage(v145);
  v67 = v104;
  if (!v105)
  {
    v97 = *(_QWORD *)a8;
    goto LABEL_132;
  }
LABEL_134:
  v108 = v67;
  if ((*(_BYTE *)(a8 + 3) & 0x20) != 0)
    v109 = glpBankForInputsInLanguage(v145);
  else
    v109 = glpBankForOutputsInLanguage(v145);
  v115 = v109;
  if (v147 != 2)
  {
    v116 = (uint64_t **)glpCompilerGetInfoLog(a1);
    if ((*(_QWORD *)a8 & 0x20000000) != 0)
      v117 = "inputs";
    else
      v117 = "outputs";
    glpLanguageToString(v145);
    v167 = *i;
    v168 = *((_QWORD *)i + 2);
    glpLogMessage(v116, 0, (uint64_t)&v167, "%s in the %s shader must be arrays", v118, v119, v120, v121, (char)v117);
    return 0;
  }
  if (glpTypeGetKind(v59) != 1)
    goto LABEL_166;
  *(_QWORD *)&v167 = 0;
  *((_QWORD *)&v167 + 1) = &v167;
  v168 = 0x2000000000;
  v169 = 1;
  v163 = 0;
  v164 = &v163;
  v165 = 0x2000000000;
  v166 = 0;
  v122 = *a7;
  v161[0] = MEMORY[0x24BDAC760];
  v161[1] = 0x40000000;
  v161[2] = __glpEvaluateTypeNode_block_invoke;
  v161[3] = &unk_24F4B08C0;
  v162 = v108;
  v161[4] = &v167;
  v161[5] = &v163;
  glpEachPrimitiveComponentOfType((uint64_t)v122, (uint64_t)v161);
  if (!*(_DWORD *)(*((_QWORD *)&v167 + 1) + 24))
  {
LABEL_171:
    v126 = (uint64_t **)glpCompilerGetInfoLog(a1);
    if ((*(_QWORD *)a8 & 0x20000000) != 0)
      v131 = "Input";
    else
      v131 = "Output";
    v159 = *i;
    v160 = *((_QWORD *)i + 2);
    glpLogMessage(v126, 0, (uint64_t)&v159, "%s variables may not contain %s", v127, v128, v129, v130, (char)v131);
    _Block_object_dispose(&v163, 8);
    _Block_object_dispose(&v167, 8);
    return 0;
  }
  _Block_object_dispose(&v163, 8);
  _Block_object_dispose(&v167, 8);
  v65 = 1;
LABEL_166:
  v123 = glpArrayTypeGetElementType((uint64_t)*a7);
  ElementCount = glpArrayTypeGetElementCount((uint64_t)*a7);
  ImpliedBankSize = glpCompilerGetImpliedBankSize(a1, v115);
  if (ElementCount == -1)
    ElementCount = ImpliedBankSize;
  if (ImpliedBankSize != -1 && ElementCount != ImpliedBankSize)
  {
    v28 = glpCompilerGetInfoLog(a1);
    glpLanguageToString(v145);
    v167 = *i;
    v168 = *((_QWORD *)i + 2);
    v144 = ElementCount;
    v24 = "Declared size (%u) of %s array in the %s shader is incompatible with earlier declarations (expected %u)";
LABEL_22:
    InfoLog = (uint64_t **)v28;
    goto LABEL_152;
  }
  v132 = glpCompilerGetAllocator(a1);
  *a7 = (unsigned int *)glpMakeBankType(v132, v115, v123, ElementCount);
LABEL_176:
  if (!v65)
    goto LABEL_177;
LABEL_116:
  if (!glpTypeGetKind(*a7) && !glpPrimitiveTypeGetPrimitiveType((uint64_t)*a7))
  {
    if ((*(_QWORD *)a8 & 0xFFFFFFFFFFE7FFFFLL) != 0)
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      v167 = *v45;
      v168 = *((_QWORD *)v45 + 2);
      v24 = "void may not be qualified";
      goto LABEL_152;
    }
    if (a3 != 4)
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      v167 = *v45;
      v168 = *((_QWORD *)v45 + 2);
      v24 = "void not allowed except as return type";
      goto LABEL_152;
    }
  }
  result = 1;
  if (a3 != 8 && a4 && (*(_QWORD *)a8 & 0x900000000) != 0x100000000 && (*(_QWORD *)a8 & 0x6000000) != 0x2000000)
  {
    if (!glpTypeGetSamplerCount((uint64_t)*a7))
      return 1;
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    v167 = *i;
    v168 = *((_QWORD *)i + 2);
    v24 = "Samplers not allowed except in non-buffer uniforms and in-parameters";
    goto LABEL_152;
  }
  return result;
}

uint64_t __glpEvaluateTypeNode_block_invoke(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result;
  const char *v7;

  result = glpPrimitiveTypeGetCategory(a2);
  if ((result - 1) >= 3)
  {
    if ((_DWORD)result == 4)
    {
      v7 = "samplers";
      goto LABEL_9;
    }
    if (!(_DWORD)result)
      abort();
  }
  else if (!*(_DWORD *)(a1 + 48))
  {
    result = glpPrimitiveTypeGetScalarType(a2);
    if ((_DWORD)result == 9)
    {
      v7 = "BOOLs";
LABEL_9:
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v7;
      *a3 = 1;
    }
  }
  return result;
}

uint64_t __glpEvaluateTypeNode_block_invoke_2(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result;
  const char *v7;

  result = glpPrimitiveTypeGetCategory(a2);
  if ((result - 1) >= 3)
  {
    if ((_DWORD)result == 4)
    {
      v7 = "samplers";
      goto LABEL_9;
    }
    if (!(_DWORD)result)
      abort();
  }
  else if (!*(_DWORD *)(a1 + 48))
  {
    result = glpPrimitiveTypeGetScalarType(a2);
    if ((_DWORD)result == 9)
    {
      v7 = "BOOLs";
LABEL_9:
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v7;
      *a3 = 1;
    }
  }
  return result;
}

uint64_t glpCheckName(uint64_t a1, uint64_t a2, const char *a3, unsigned int a4)
{
  uint64_t NameTable;
  uint64_t **InfoLog;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __n128 v15;

  NameTable = glpCompilerGetNameTable(a1);
  if (!glpNameTableIsExtensionEnabled(NameTable, 0x23u) && a4 >= 3 && !strncmp("gl_", a3, 3uLL))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v15);
    glpLogMessage(InfoLog, 0, (uint64_t)&v15, "Identifier name '%.*s' cannot start with 'gl_'", v10, v11, v12, v13, a4);
    return -1;
  }
  return a2;
}

BOOL glpHandleVariableRedeclaration(uint64_t a1, __int128 *a2, uint64_t a3, char a4, unsigned int *a5, uint64_t a6, uint64_t *a7, unsigned int *a8, unsigned int *a9, uint64_t a10, _QWORD **a11, unsigned int **a12, unint64_t *a13, _QWORD **a14)
{
  _BOOL4 v19;
  uint64_t NameTable;
  _QWORD *Allocator;
  _QWORD *v22;
  char v23;
  char v24;
  int Kind;
  unsigned int *v26;
  int v27;
  int v28;
  unsigned int *v29;
  unsigned int *v30;
  int v31;
  uint64_t v32;
  int ElementCount;
  int v34;
  unsigned int *ElementType;
  unsigned int *v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  _BOOL4 v41;
  uint64_t **InfoLog;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _BOOL8 result;
  unsigned int *v48;
  int v49;
  unsigned int v50;
  unsigned int *v51;
  unsigned int *v52;
  int v53;
  unsigned int v54;
  uint64_t **v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t **v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t **v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t **v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t **v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t **v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t ArrayType;
  unsigned int v86;
  unsigned int v87;
  unsigned int v88;
  unsigned int v89;
  uint64_t **v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t **v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  int v100;
  uint64_t **v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  int v106;
  uint64_t v107;
  uint64_t v108;
  int Bank;
  uint64_t BankType;
  uint64_t **v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t **v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  int v127;
  int MaxElementCount;
  unsigned int v129;
  _QWORD *v130;
  _QWORD *v131;
  uint64_t v132;
  _QWORD *v133;
  _QWORD *v134;
  uint64_t v135;
  uint64_t v136;
  unsigned int v137;
  _BOOL4 v140;
  char v141;
  __int128 v142;
  uint64_t v143;

  if (a7)
  {
    v19 = glpLayoutObjectFind(a7, 81) != 0;
    if (glpLayoutObjectFind(a7, 82))
    {
      NameTable = glpCompilerGetNameTable(a1);
      if (glpNameTableGetGLSLVersion(NameTable) > 8
        || glpNameTableIsExtensionEnabled(NameTable, 0x15u)
        || glpNameTableIsExtensionEnabled(NameTable, 1u))
      {
        v19 = 1;
      }
    }
  }
  else
  {
    v19 = 0;
  }
  v140 = v19;
  Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
  glpTypeHumanReadableDescription((uint64_t)a5, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
  v22 = (_QWORD *)glpCompilerGetAllocator(a1);
  glpTypeHumanReadableDescription((uint64_t)a9, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v22);
  v24 = v23;
  Kind = glpTypeGetKind(a5);
  if (Kind != glpTypeGetKind(a9))
    goto LABEL_31;
  v26 = a5;
  if (Kind == 3)
  {
    ElementCount = glpBankTypeGetElementCount((uint64_t)a5);
    v34 = glpBankTypeGetElementCount((uint64_t)a9);
    if (ElementCount != -1 && v34 != -1 && ElementCount != v34)
      goto LABEL_31;
    ElementType = (unsigned int *)glpBankTypeGetElementType((uint64_t)a5);
    v36 = (unsigned int *)glpBankTypeGetElementType((uint64_t)a9);
    v136 = (uint64_t)ElementType;
    v37 = glpTypeGetKind(ElementType);
    if (v37 != glpTypeGetKind(v36))
      goto LABEL_31;
    if (v37 == 2)
    {
      v38 = glpArrayTypeGetElementCount(v136);
      v39 = glpArrayTypeGetElementCount((uint64_t)v36);
      if (v38 != -1 && v39 != -1 && v38 != v39)
        goto LABEL_31;
      v40 = glpArrayTypeGetElementType(v136);
      v32 = glpArrayTypeGetElementType((uint64_t)v36);
      v26 = (unsigned int *)v40;
    }
    else
    {
      v26 = (unsigned int *)v136;
      v32 = (uint64_t)v36;
    }
  }
  else if (Kind == 2)
  {
    v27 = glpArrayTypeGetElementCount((uint64_t)a5);
    v28 = glpArrayTypeGetElementCount((uint64_t)a9);
    if (v27 != -1 && v28 != -1 && v27 != v28)
      goto LABEL_31;
    v29 = (unsigned int *)glpArrayTypeGetElementType((uint64_t)a5);
    v30 = (unsigned int *)glpArrayTypeGetElementType((uint64_t)a9);
    v31 = glpTypeGetKind(v29);
    if (v31 != glpTypeGetKind(v30))
      goto LABEL_31;
    v26 = v29;
    v32 = (uint64_t)v30;
  }
  else
  {
    v32 = (uint64_t)a9;
  }
  if (!glpTypesEqual(v26, v32))
  {
LABEL_31:
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    v142 = *a2;
    v143 = *((_QWORD *)a2 + 2);
    glpLogMessage(InfoLog, 0, (uint64_t)&v142, "Type (%.*s) of redeclaration of '%.*s' is incompatible with type (%.*s) of previous declaration", v43, v44, v45, v46, v24);
    return 0;
  }
  if (glpTypeGetKind(a5) != 2 && glpTypeGetKind(a5) != 3)
  {
    if (!v140)
    {
      v70 = (uint64_t **)glpCompilerGetInfoLog(a1);
      v142 = *a2;
      v143 = *((_QWORD *)a2 + 2);
      glpLogMessage(v70, 0, (uint64_t)&v142, "Regular non-array variable '%.*s' may not be redeclared", v71, v72, v73, v74, a4);
      return 0;
    }
    if (!glpTypesEqual(a5, (uint64_t)a9))
    {
      v60 = (uint64_t **)glpCompilerGetInfoLog(a1);
      v142 = *a2;
      v143 = *((_QWORD *)a2 + 2);
      glpLogMessage(v60, 0, (uint64_t)&v142, "Type (%.*s) of redeclaration of '%.*s' differs from type (%.*s) of previous declaration", v61, v62, v63, v64, v24);
      return 0;
    }
    goto LABEL_95;
  }
  if (glpTypeGetKind(a5) == 2)
  {
    v41 = 0;
  }
  else
  {
    v48 = (unsigned int *)glpBankTypeGetElementType((uint64_t)a5);
    v41 = glpTypeGetKind(v48) == 2;
  }
  v49 = _elementCount(a5);
  v50 = _elementCount(a9);
  if (v50 == -1 && v49 != -1)
    goto LABEL_39;
  if (v41)
  {
    v137 = v50;
    v51 = (unsigned int *)_elementType(a5);
    v52 = (unsigned int *)_elementType(a9);
    v53 = _elementCount(v51);
    v54 = _elementCount(v52);
    if (v54 == -1 && v53 != -1)
    {
LABEL_39:
      v55 = (uint64_t **)glpCompilerGetInfoLog(a1);
      v142 = *a2;
      v143 = *((_QWORD *)a2 + 2);
      glpLogMessage(v55, 0, (uint64_t)&v142, "Type (%.*s) of redeclaration of '%.*s' is less specific than type (%.*s) of previous declaration", v56, v57, v58, v59, v24);
      return 0;
    }
    if (v49 != -1 || v137 == -1)
    {
      if (v53 != -1 || v54 == -1)
      {
        if ((v137 & v49 & v53 & v54) != 0xFFFFFFFF)
        {
          v111 = (uint64_t **)glpCompilerGetInfoLog(a1);
          v142 = *a2;
          v143 = *((_QWORD *)a2 + 2);
          glpLogMessage(v111, 0, (uint64_t)&v142, "Size in type (%.*s) of redeclaration of sized array '%.*s' adds nothing to size in type (%.*s) of previous declaration", v112, v113, v114, v115, v24);
          return 0;
        }
        goto LABEL_87;
      }
      if (v49 == -1 || v49 == v137)
      {
LABEL_69:
        if (*a8 > v137)
        {
          v95 = (uint64_t **)glpCompilerGetInfoLog(a1);
          v142 = *a2;
          v143 = *((_QWORD *)a2 + 2);
          glpLogMessage(v95, 0, (uint64_t)&v142, "Outer size in type (%.*s) of redeclaration of implicitly-sized array '%.*s' is less than the implicit size (%u)", v96, v97, v98, v99, v24);
          return 0;
        }
        if (a8[1] > v54)
        {
          v116 = (uint64_t **)glpCompilerGetInfoLog(a1);
          v142 = *a2;
          v143 = *((_QWORD *)a2 + 2);
          glpLogMessage(v116, 0, (uint64_t)&v142, "Inner size in type (%.*s) of redeclaration of implicitly-sized array '%.*s' is less than the implicit size (%u)", v117, v118, v119, v120, v24);
          return 0;
        }
LABEL_87:
        v141 = a4;
        v121 = glpBankTypeGetElementType((uint64_t)a5);
        v122 = glpBankTypeGetElementType((uint64_t)a9);
        v123 = glpCompilerGetAllocator(a1);
        v124 = glpArrayTypeGetElementType(v121);
        v125 = glpArrayTypeGetElementCount(v121);
        v126 = glpArrayTypeGetElementCount(v122);
        if (v125 == -1)
          v127 = v126;
        else
          v127 = v125;
        MaxElementCount = glpArrayTypeGetMaxElementCount(v121);
        ArrayType = glpMakeArrayType(v123, v124, v127, MaxElementCount);
        if (glpArrayTypeGetMaxElementCount(ArrayType) != -1)
        {
          v129 = glpArrayTypeGetElementCount(ArrayType);
          if (v129 > glpArrayTypeGetMaxElementCount(ArrayType))
          {
LABEL_80:
            v101 = (uint64_t **)glpCompilerGetInfoLog(a1);
            v142 = *a2;
            v143 = *((_QWORD *)a2 + 2);
            glpLogMessage(v101, 0, (uint64_t)&v142, "Redeclaration of special array '%.*s' exceeds maximum allowed size", v102, v103, v104, v105, v141);
            return 0;
          }
        }
        goto LABEL_63;
      }
    }
    else if (v53 == -1 || v53 == v54)
    {
      goto LABEL_69;
    }
    v75 = (uint64_t **)glpCompilerGetInfoLog(a1);
    v142 = *a2;
    v143 = *((_QWORD *)a2 + 2);
    glpLogMessage(v75, 0, (uint64_t)&v142, "Size in type (%.*s) of redeclaration of sized array '%.*s' doesn't match size in type (%.*s) of previous declaration", v76, v77, v78, v79, v24);
    return 0;
  }
  if (v49 == -1)
  {
    if (v50 != -1 && *a8 > v50)
    {
      v80 = (uint64_t **)glpCompilerGetInfoLog(a1);
      v142 = *a2;
      v143 = *((_QWORD *)a2 + 2);
      glpLogMessage(v80, 0, (uint64_t)&v142, "Size in type (%.*s) of redeclaration of implicitly-sized array '%.*s' is less than the implicit size (%u)", v81, v82, v83, v84, v24);
      return 0;
    }
  }
  else
  {
    if (!v140)
    {
      v90 = (uint64_t **)glpCompilerGetInfoLog(a1);
      v142 = *a2;
      v143 = *((_QWORD *)a2 + 2);
      glpLogMessage(v90, 0, (uint64_t)&v142, "Redeclaration of sized array '%.*s' not allowed", v91, v92, v93, v94, a4);
      return 0;
    }
    if (v49 != v50)
    {
      v65 = (uint64_t **)glpCompilerGetInfoLog(a1);
      v142 = *a2;
      v143 = *((_QWORD *)a2 + 2);
      glpLogMessage(v65, 0, (uint64_t)&v142, "Redeclaration of redeclarable sized array '%.*s' would alter size", v66, v67, v68, v69, a4);
      return 0;
    }
  }
  v141 = a4;
  ArrayType = _elementType(a5);
LABEL_63:
  v86 = _elementCount(a5);
  v87 = _elementCount(a9);
  if (v86 == -1)
    v88 = v87;
  else
    v88 = v86;
  if (glpTypeGetKind(a5) == 3)
    v89 = -1;
  else
    v89 = glpArrayTypeGetMaxElementCount((uint64_t)a5);
  if (glpTypeGetKind(a9) == 3)
    v100 = -1;
  else
    v100 = glpArrayTypeGetMaxElementCount((uint64_t)a9);
  if (v89 == -1)
    v89 = v100;
  if (v89 != -1 && v88 != -1 && v88 > v89)
    goto LABEL_80;
  v106 = glpTypeGetKind(a5);
  v107 = glpCompilerGetAllocator(a1);
  v108 = v107;
  if (v106 == 3)
  {
    Bank = glpBankTypeGetBank((uint64_t)a5);
    BankType = glpMakeBankType(v108, Bank, ArrayType, v88);
  }
  else
  {
    BankType = glpMakeArrayType(v107, ArrayType, v88, v89);
  }
  a5 = (unsigned int *)BankType;
LABEL_95:
  *a12 = a5;
  if (a7)
  {
    v130 = (_QWORD *)glpCompilerGetAllocator(a1);
    v131 = glpCopyLayoutObject(v130, (_QWORD **)a7);
    *a14 = v131;
    if (a11)
    {
      v132 = glpCompilerGetAllocator(a1);
      v133 = *a14;
      v142 = *a2;
      v143 = *((_QWORD *)a2 + 2);
      result = glpLayoutObjectAppendMany(v132, a1, (uint64_t)&v142, v133, a11);
      if (!result)
        return result;
      goto LABEL_101;
    }
  }
  else
  {
    if (!a11)
    {
LABEL_101:
      v131 = *a14;
      goto LABEL_102;
    }
    v134 = (_QWORD *)glpCompilerGetAllocator(a1);
    v131 = glpCopyLayoutObject(v134, a11);
    *a14 = v131;
  }
LABEL_102:
  if (v131)
  {
    v135 = glpCompilerGetAllocator(a1);
    glpLayoutObjectRemove(v135, *a14, 82);
  }
  *a13 = a6 & 0xFFFFFFFFFFFFFFE0 | a10;
  return 1;
}

uint64_t _elementCount(unsigned int *a1)
{
  int Kind;

  Kind = glpTypeGetKind(a1);
  if (Kind == 3)
    return glpBankTypeGetElementCount((uint64_t)a1);
  if (Kind != 2)
    abort();
  return glpArrayTypeGetElementCount((uint64_t)a1);
}

uint64_t _elementType(unsigned int *a1)
{
  int Kind;

  Kind = glpTypeGetKind(a1);
  if (Kind == 3)
    return glpBankTypeGetElementType((uint64_t)a1);
  if (Kind != 2)
    abort();
  return glpArrayTypeGetElementType((uint64_t)a1);
}

uint64_t glpFlattenCommaTree(uint64_t a1, uint64_t a2)
{
  _QWORD *Allocator;
  uint64_t v4;
  uint64_t v5;
  __n128 v7;

  Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
  glpASTNodeGetLocation(a2, &v7);
  glpMakeCommaExprNode((uint64_t)Allocator, &v7, 0);
  v5 = v4;
  flattenCommaTreeInto(a2, v4, Allocator);
  return v5;
}

void *flattenCommaTreeInto(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  void *result;
  int v7;
  unsigned int i;
  uint64_t Expr;

  if (glpASTNodeGetKind(a1) != 43)
    return glpCommaExprNodeAddExpr(a3, a2, a1);
  result = (void *)glpCommaExprNodeGetExprCount(a1);
  if ((_DWORD)result)
  {
    v7 = (int)result;
    for (i = 0; i != v7; ++i)
    {
      Expr = glpCommaExprNodeGetExpr(a1, i);
      result = (void *)flattenCommaTreeInto(Expr, a2, a3);
    }
  }
  return result;
}

uint64_t glpCommaResult(uint64_t Expr)
{
  uint64_t v1;
  int ExprCount;

  while (1)
  {
    v1 = Expr;
    if (glpASTNodeGetKind(Expr) != 43)
      break;
    ExprCount = glpCommaExprNodeGetExprCount(v1);
    Expr = glpCommaExprNodeGetExpr(v1, ExprCount - 1);
  }
  return v1;
}

uint64_t glpSASpecialAssert(uint64_t a1, uint64_t a2)
{
  uint64_t **InfoLog;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  __n128 *v10;
  uint64_t v11;
  const char *Name;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t **v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t ConstantValueFragment;
  const char *v25;
  int v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  unsigned int v30;
  unsigned int *PrimitiveType;
  uint64_t v32;
  uint64_t v33;
  uint64_t SaType;
  char *v35;
  uint64_t IntConstant;
  __n128 *v37;
  uint64_t **v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *Allocator;
  uint64_t **v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  uint64_t *StringBuffer;
  uint64_t **v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  uint64_t *v61;
  _QWORD *v62;
  uint64_t *v63;
  uint64_t **v64;
  char v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  char v70;
  char CString;
  __n128 v72;
  __n128 v73;
  __n128 v74;
  _QWORD v75[7];
  uint64_t v76;
  uint64_t *v77;
  uint64_t v78;
  uint64_t v79;
  __n128 v80;
  __n128 v81;
  __n128 v82;
  __n128 v83;
  __n128 v84;
  __n128 v85;
  __n128 v86;
  __n128 v87;

  if (glpCallNodeGetArgCount(a2) <= 1)
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v87);
    v9 = "$assert requires at least 2 arguments";
    v10 = &v87;
LABEL_13:
    glpLogMessage(InfoLog, 0, (uint64_t)v10, v9, v5, v6, v7, v8, v70);
    return -1;
  }
  v11 = glpCallNodeGetArg(a2, 0);
  if (glpASTNodeGetKind(v11) != 1)
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v86);
    v9 = "first argument to $assert must be an identifier";
    v10 = &v86;
    goto LABEL_13;
  }
  Name = (const char *)glpVariableIdentifierNodeGetName(v11);
  v13 = (char *)Name;
  v15 = v14;
  v16 = (v14 - 8);
  if (v14 >= 8)
  {
    if (!strncmp(Name, "type_is_", 8uLL))
    {
      v25 = v13 + 8;
      if (v16 >> 5 >= v16)
      {
        v27 = v16;
      }
      else
      {
        v26 = v15 - 9;
        LODWORD(v27) = v16;
        do
        {
          v27 = (32 * (_DWORD)v27 + (v27 >> 2) + v25[v26]) ^ v27;
          v26 += ~(v16 >> 5);
        }
        while (v26 + 1 > v16 >> 5);
      }
      v30 = glpPrimitiveTypeFromString(v25, v16 | (v27 << 32));
      PrimitiveType = (unsigned int *)glpGetPrimitiveType(v30);
      v32 = glpCallNodeGetArg(a2, 1u);
      v33 = glpSANode(a1, v32);
      if (v33 == -1)
      {
        v38 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v85);
        glpLogMessage(v38, 0, (uint64_t)&v85, "$assert type_is: expected %.*s but got SA failure", v39, v40, v41, v42, v16);
        return -1;
      }
      SaType = glpASTNodeGetSaType(v33);
      if (!glpTypesEqual(PrimitiveType, SaType))
      {
        Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription(SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
        v45 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v83);
        glpLogMessage(v45, 0, (uint64_t)&v83, "$assert type_is: expected %.*s but got %.*s", v46, v47, v48, v49, v16);
        return -1;
      }
      glpASTNodeGetLocation(a2, &v84);
      v35 = glpGetPrimitiveType(5u);
      IntConstant = glpCompilerGetIntConstant(a1, 1);
      v37 = &v84;
      return glpMakeConstantValueFragment(a1, v37, (uint64_t)v35, IntConstant);
    }
    if (v15 < 0xD || strncmp(v13, "precision_is_", 0xDuLL))
      goto LABEL_8;
    if (v15 < 0x11)
    {
      if ((_DWORD)v15 != 16)
        goto LABEL_49;
      goto LABEL_35;
    }
    v43 = 4;
    if (!strncmp(v13 + 13, "lowp", 4uLL))
    {
LABEL_37:
      v50 = glpCallNodeGetArg(a2, 1u);
      v51 = glpSANode(a1, v50);
      if (v51 == -1)
      {
        v53 = (_QWORD *)glpCompilerGetAllocator(a1);
        StringBuffer = glpMakeStringBuffer(v53);
        _formatPrecisionToStringBuffer(StringBuffer, v43);
        v55 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v82);
        CString = glpStringBufferGetCString(StringBuffer);
        glpLogMessage(v55, 0, (uint64_t)&v82, "$assert precision_is: expected %s but got SA failure", v56, v57, v58, v59, CString);
        return -1;
      }
      v52 = glpASTNodeGetSaFlags(v51) & 0x1F;
      if (v52 != v43)
      {
        v60 = (_QWORD *)glpCompilerGetAllocator(a1);
        v61 = glpMakeStringBuffer(v60);
        _formatPrecisionToStringBuffer(v61, v43);
        v62 = (_QWORD *)glpCompilerGetAllocator(a1);
        v63 = glpMakeStringBuffer(v62);
        _formatPrecisionToStringBuffer(v63, v52);
        v64 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v80);
        v65 = glpStringBufferGetCString(v61);
        glpStringBufferGetCString(v63);
        glpLogMessage(v64, 0, (uint64_t)&v80, "$assert precision_is: expected %s but got %s", v66, v67, v68, v69, v65);
        return -1;
      }
      glpASTNodeGetLocation(a2, &v81);
      v35 = glpGetPrimitiveType(5u);
      IntConstant = glpCompilerGetIntConstant(a1, 1);
      v37 = &v81;
      return glpMakeConstantValueFragment(a1, v37, (uint64_t)v35, IntConstant);
    }
    if (v15 < 0x14)
    {
      if (v15 < 0x12)
        goto LABEL_35;
    }
    else if (!strncmp(v13 + 13, "mediump", 7uLL))
    {
      v43 = 8;
      goto LABEL_37;
    }
    if (!strncmp(v13 + 13, "highp", 5uLL))
    {
      v43 = 16;
      goto LABEL_37;
    }
    if (!strncmp(v13 + 13, "_argp", 5uLL))
    {
      v43 = 1;
      goto LABEL_37;
    }
    if (!strncmp(v13 + 13, "_anyp", 5uLL))
    {
      v43 = 2;
      goto LABEL_37;
    }
LABEL_35:
    if (!strncmp(v13 + 13, "nop", 3uLL))
    {
      v43 = 0;
      goto LABEL_37;
    }
LABEL_49:
    abort();
  }
LABEL_8:
  if (!glpStringsEqual("sa_failed", 0xBA70AE8500000009, v13, v15))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v72);
    v70 = v15;
    v9 = "$assert unknown assertion kind: %.*s";
    v10 = &v72;
    goto LABEL_13;
  }
  v76 = 0;
  v77 = &v76;
  v78 = 0x2000000000;
  v79 = 0;
  v17 = glpCompilerGetInfoLog(a1);
  v75[0] = MEMORY[0x24BDAC760];
  v75[1] = 0x40000000;
  v75[2] = __glpSASpecialAssert_block_invoke;
  v75[3] = &unk_24F4B0910;
  v75[4] = &v76;
  v75[5] = a1;
  v75[6] = a2;
  glpLogSuppress(v17, (uint64_t)v75, (uint64_t)&__block_literal_global_2);
  if (v77[3] == -1)
  {
    glpASTNodeGetLocation(a2, &v74);
    v28 = glpGetPrimitiveType(5u);
    v29 = glpCompilerGetIntConstant(a1, 1);
    ConstantValueFragment = glpMakeConstantValueFragment(a1, &v74, (uint64_t)v28, v29);
  }
  else
  {
    v18 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v73);
    glpLogMessage(v18, 0, (uint64_t)&v73, "$assert sa_failed: expected this code to fail SA, but it passed", v19, v20, v21, v22, v70);
    ConstantValueFragment = -1;
  }
  _Block_object_dispose(&v76, 8);
  return ConstantValueFragment;
}

uint64_t *_formatPrecisionToStringBuffer(uint64_t *result, uint64_t a2)
{
  uint64_t *v3;
  char *v5;

  v3 = result;
  v5 = "nop";
  switch(a2)
  {
    case 0:
      return (uint64_t *)glpStringBufferAppendCString(v3, v5);
    case 1:
      v5 = "$argp";
      return (uint64_t *)glpStringBufferAppendCString(v3, v5);
    case 2:
      v5 = "$anyp";
      return (uint64_t *)glpStringBufferAppendCString(v3, v5);
    case 3:
    case 5:
    case 6:
    case 7:
      goto LABEL_6;
    case 4:
      v5 = "lowp";
      return (uint64_t *)glpStringBufferAppendCString(v3, v5);
    case 8:
      v5 = "mediump";
      return (uint64_t *)glpStringBufferAppendCString(v3, v5);
    default:
      if (a2 == 16)
        goto LABEL_27;
      if (a2 == 31)
      {
        v5 = "allp";
        return (uint64_t *)glpStringBufferAppendCString(v3, v5);
      }
LABEL_6:
      if ((a2 & 2) != 0)
      {
        result = (uint64_t *)glpStringBufferAppendCString(result, "$anyp");
        if ((a2 & 1) == 0)
        {
          if ((a2 & 4) != 0)
          {
LABEL_22:
            glpStringBufferAppendCString(v3, "|");
LABEL_23:
            result = (uint64_t *)glpStringBufferAppendCString(v3, "lowp");
            if ((a2 & 8) != 0)
              goto LABEL_24;
            goto LABEL_18;
          }
LABEL_17:
          if ((a2 & 8) != 0)
          {
LABEL_24:
            glpStringBufferAppendCString(v3, "|");
LABEL_25:
            result = (uint64_t *)glpStringBufferAppendCString(v3, "mediump");
            if ((a2 & 0x10) == 0)
              return result;
            goto LABEL_26;
          }
LABEL_18:
          if ((a2 & 0x10) == 0)
            return result;
LABEL_26:
          glpStringBufferAppendCString(v3, "|");
          goto LABEL_27;
        }
        glpStringBufferAppendCString(v3, "|");
LABEL_21:
        result = (uint64_t *)glpStringBufferAppendCString(v3, "$argp");
        if ((a2 & 4) != 0)
          goto LABEL_22;
        goto LABEL_17;
      }
      if ((a2 & 1) != 0)
        goto LABEL_21;
      if ((a2 & 4) != 0)
        goto LABEL_23;
      if ((a2 & 8) != 0)
        goto LABEL_25;
      if ((a2 & 0x10) == 0)
        return result;
LABEL_27:
      v5 = "highp";
      return (uint64_t *)glpStringBufferAppendCString(v3, v5);
  }
}

uint64_t __glpSASpecialAssert_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = a1[5];
  v3 = glpCallNodeGetArg(a1[6], 1u);
  result = glpSANode(v2, v3);
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = result;
  return result;
}

uint64_t glpApplySizeToBanks(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t TopLevelNode;
  unsigned int v7;
  uint64_t Def;
  uint64_t v9;
  int Kind;
  unsigned int i;
  unsigned int v12;
  uint64_t Declaration;
  unsigned int *SaType;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t BankType;
  uint64_t Extra;
  uint64_t v25;
  uint64_t v26;
  int Bank;
  unsigned int VariableObjectCount;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t Allocator;
  uint64_t ElementType;
  uint64_t v34;
  uint64_t v35;
  uint64_t **InfoLog;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  __n128 v46;

  v5 = a1;
  TopLevelNode = glpCompilerGetTopLevelNode(a1);
  if (glpTopLevelNodeGetDefCount(TopLevelNode))
  {
    v7 = 0;
    v45 = a2;
    do
    {
      Def = glpTopLevelNodeGetDef(TopLevelNode, v7);
      if ((unint64_t)(Def + 1) >= 2)
      {
        v9 = Def;
        Kind = glpASTNodeGetKind(Def);
        if ((Kind - 46) >= 2)
        {
          if (Kind == 57)
          {
            Extra = glpInterfaceBlockNodeGetExtra(v9);
            if (Extra)
            {
              v25 = Extra;
              if (*(_QWORD *)(Extra + 40) == a2)
              {
                v26 = *(_QWORD *)(Extra + 64);
                Bank = glpBankTypeGetBank(v26);
                v43 = v26;
                v44 = a3;
                if (glpBankTypeGetElementCount(v26) == -1)
                {
                  VariableObjectCount = glpInterfaceBlockObjectGetVariableObjectCount(v25);
                  if (VariableObjectCount)
                  {
                    v29 = 0;
                    v30 = 8 * VariableObjectCount;
                    do
                    {
                      v31 = *(uint64_t **)(*(_QWORD *)(v25 + 72) + v29);
                      Allocator = glpCompilerGetAllocator(v5);
                      ElementType = glpBankTypeGetElementType(*v31);
                      *v31 = glpMakeBankType(Allocator, Bank, ElementType, v44);
                      v29 += 8;
                    }
                    while (v30 != v29);
                  }
                }
                else if (glpBankTypeGetElementCount(v26) != (_DWORD)a3)
                {
                  InfoLog = (uint64_t **)glpCompilerGetInfoLog(v5);
                  glpASTNodeGetLocation(v9, &v46);
                  v37 = *(_DWORD *)(v25 + 8);
                  glpBankTypeGetElementCount(v43);
                  glpLogMessage(InfoLog, 0, (uint64_t)&v46, "Size of interface block array '%.*s' should have been %u but was %u", v38, v39, v40, v41, v37);
                  return 0;
                }
                v34 = glpCompilerGetAllocator(v5);
                v35 = glpBankTypeGetElementType(v43);
                a3 = v44;
                *(_QWORD *)(v25 + 64) = glpMakeBankType(v34, Bank, v35, v44);
              }
            }
          }
        }
        else
        {
          for (i = 0; ; ++i)
          {
            v12 = glpASTNodeGetKind(v9) == 47 ? glpVariableDeclarationGroupNodeGetDeclarationCount(v9) : 1;
            if (i >= v12)
              break;
            Declaration = v9;
            if (glpASTNodeGetKind(v9) == 47)
              Declaration = glpVariableDeclarationGroupNodeGetDeclaration(v9, i);
            SaType = (unsigned int *)glpASTNodeGetSaType(Declaration);
            if ((glpASTNodeGetSaFlags(Declaration) & a2) != 0
              && SaType
              && glpTypeGetKind(SaType) == 3
              && glpBankTypeGetElementCount((uint64_t)SaType) == -1)
            {
              v15 = glpCompilerGetAllocator(v5);
              v16 = TopLevelNode;
              v17 = v5;
              v18 = a3;
              v19 = v15;
              v20 = glpBankTypeGetBank((uint64_t)SaType);
              v21 = glpBankTypeGetElementType((uint64_t)SaType);
              v22 = v19;
              a3 = v18;
              v5 = v17;
              TopLevelNode = v16;
              a2 = v45;
              BankType = glpMakeBankType(v22, v20, v21, a3);
              glpASTNodeSetSaType(Declaration, BankType);
              *(_QWORD *)glpVariableDeclarationNodeGetExtra(Declaration) = BankType;
            }
          }
        }
      }
      ++v7;
    }
    while (v7 < glpTopLevelNodeGetDefCount(TopLevelNode));
  }
  return 1;
}

uint64_t glpSAPreIncrementOrDecrement(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t Expr;
  uint64_t (*v7)(uint64_t, __n128 *, uint64_t, uint64_t);
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int ExprCount;
  uint64_t v12;
  uint64_t Allocator;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  __n128 v18;
  __n128 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = 0;
  v20 = 0;
  Expr = glpUnaryOperatorNodeGetExpr(a2);
  glpHandleSideEffectsForExpr(a1, Expr, &v21, &v20);
  if (a3)
    v7 = glpMakeIncrementFragment;
  else
    v7 = glpMakeDecrementFragment;
  glpASTNodeGetLocation(a2, &v19);
  v8 = v21;
  v9 = glpDuplicateDerefOrConstant(a1, v21);
  v10 = v7(a1, &v19, v8, v9);
  if (v20 && glpIsCommaExprNode(v20))
  {
    ExprCount = glpCommaExprNodeGetExprCount(v20);
    glpCommaExprNodeSetExpr(v20, ExprCount - 1, v10);
    glpASTNodeSetSaType(v20, 0);
    v12 = v20;
  }
  else
  {
    Allocator = glpCompilerGetAllocator(a1);
    glpASTNodeGetLocation(a2, &v18);
    glpMakeCommaExprNode(Allocator, &v18, 0);
    v12 = v14;
    if (v20)
    {
      v15 = (_QWORD *)glpCompilerGetAllocator(a1);
      glpCommaExprNodeAddExpr(v15, v12, v20);
    }
    v16 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v16, v12, v10);
  }
  return glpSANode(a1, v12);
}

uint64_t glpSAPostIncrementOrDecrement(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t Expr;
  uint64_t SaType;
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, __n128 *, uint64_t, uint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t Allocator;
  uint64_t v15;
  uint64_t v16;
  int ExprCount;
  int v18;
  unsigned int i;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  __n128 v27;
  __n128 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v32 = 0;
  v31 = 0;
  Expr = glpUnaryOperatorNodeGetExpr(a2);
  glpHandleSideEffectsForExpr(a1, Expr, &v32, &v31);
  v29 = 0;
  v30 = 0;
  SaType = glpASTNodeGetSaType(v32);
  v8 = glpASTNodeGetSaFlags(v32) & 0x1F;
  v9 = glpDuplicateDerefOrConstant(a1, v32);
  glpMakeTemporary(a1, SaType, v8, v9, &v30, &v29);
  if (a3)
    v10 = glpMakeIncrementFragment;
  else
    v10 = glpMakeDecrementFragment;
  glpASTNodeGetLocation(a2, &v28);
  v11 = v32;
  v12 = glpDuplicateDerefOrConstant(a1, v32);
  v13 = v10(a1, &v28, v11, v12);
  Allocator = glpCompilerGetAllocator(a1);
  glpASTNodeGetLocation(a2, &v27);
  glpMakeCommaExprNode(Allocator, &v27, 0);
  v16 = v15;
  if (v31)
  {
    if (glpIsCommaExprNode(v31))
    {
      ExprCount = glpCommaExprNodeGetExprCount(v31);
      if (ExprCount)
      {
        v18 = ExprCount;
        for (i = 0; i != v18; ++i)
        {
          v20 = (_QWORD *)glpCompilerGetAllocator(a1);
          v21 = glpCommaExprNodeGetExpr(v31, i);
          glpCommaExprNodeAddExpr(v20, v16, v21);
        }
      }
    }
    else
    {
      v22 = (_QWORD *)glpCompilerGetAllocator(a1);
      glpCommaExprNodeAddExpr(v22, v16, v31);
    }
  }
  if (v30)
  {
    v23 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v23, v16, v30);
  }
  v24 = (_QWORD *)glpCompilerGetAllocator(a1);
  glpCommaExprNodeAddExpr(v24, v16, v13);
  v25 = (_QWORD *)glpCompilerGetAllocator(a1);
  glpCommaExprNodeAddExpr(v25, v16, v29);
  return glpSANode(a1, v16);
}

uint64_t glpSABuiltinPPStreamOp(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  uint64_t **InfoLog;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  __n128 *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int *SaType;
  _DWORD *Value;
  unsigned int *v16;
  uint64_t AsSize;
  uint64_t v18;
  uint64_t v19;
  unsigned int *v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int *v23;
  _DWORD *v24;
  unsigned int *v25;
  unsigned int v26;
  uint64_t **v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  __n128 *v33;
  uint64_t PPStreamOpNode;
  uint64_t **v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  unsigned int v44;
  uint64_t Allocator;
  _QWORD *v46;
  uint64_t v47;
  char *v48;
  uint64_t PrecisionFlagsFromArgs;
  uint64_t v50;
  unsigned int v51;
  uint64_t v52;
  unsigned int *v53;
  unsigned int PrimitiveType;
  uint64_t v55;
  __n128 v56;
  __n128 v57;
  __n128 v58;
  __n128 v59;
  __n128 v60;
  __n128 v61;
  __n128 v62;
  __n128 v63;
  __n128 v64;
  __n128 v65;
  __n128 v66;
  uint64_t v67;

  v67 = *MEMORY[0x24BDAC8D0];
  v4 = glpCallNodeGetArgCount(a2);
  if (v4 <= 2)
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v66);
    v10 = "too few arguments to $ppstreamop.";
    v11 = &v66;
LABEL_16:
    glpLogMessage(InfoLog, 0, (uint64_t)v11, v10, v6, v7, v8, v9, v55);
    return glpSAFailed();
  }
  v12 = v4;
  v13 = glpCallNodeGetArg(a2, 0);
  SaType = (unsigned int *)glpASTNodeGetSaType(v13);
  if (!glpIsConstantNode(v13)
    || (Value = (_DWORD *)glpConstantNodeGetValue(v13), !glpValueIsUsableAsSize(SaType, Value)))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v65);
    v10 = "argsToIgnore for $ppstreamop must be an integer constant.";
    v11 = &v65;
    goto LABEL_16;
  }
  v16 = (unsigned int *)glpConstantNodeGetValue(v13);
  AsSize = glpValueGetAsSize((uint64_t)SaType, v16);
  if (AsSize >= v12 || (AsSize - 2) >= 3)
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v64);
    v10 = "argsToIgnore for $ppstreamop not valid, must be 2, 3 or 4 and less than call args.";
    v11 = &v64;
    goto LABEL_16;
  }
  v18 = AsSize;
  MEMORY[0x24BDAC7A8](AsSize);
  v20 = (unsigned int *)((char *)&v55 - ((v19 + 15) & 0x7FFFFFFF0));
  v21 = 0;
  do
  {
    v22 = glpCallNodeGetArg(a2, (int)v21 + 1);
    v23 = (unsigned int *)glpASTNodeGetSaType(v22);
    if (!glpIsConstantNode(v22) || (v24 = (_DWORD *)glpConstantNodeGetValue(v22), !glpValueIsUsableAsSize(v23, v24)))
    {
      v36 = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a2, &v63);
      glpLogMessage(v36, 0, (uint64_t)&v63, "Argument %u to $ppstreamop must be an integer constant.", v37, v38, v39, v40, v21 + 2);
      return glpSAFailed();
    }
    v25 = (unsigned int *)glpConstantNodeGetValue(v22);
    v20[v21++] = glpValueGetAsSize((uint64_t)v23, v25);
  }
  while (v18 != v21);
  v26 = *v20;
  if (*v20 >= 0x4F)
  {
    v27 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v62);
    v32 = "returnPrimitiveType of $ppstreamop must represent a primitive type.";
    v33 = &v62;
    goto LABEL_13;
  }
  v41 = v21 + 1;
  if (v18 < 2)
  {
    v55 = 0;
    v43 = 0;
    v44 = v26;
    goto LABEL_29;
  }
  v42 = v20[1];
  if (v42 >= 0xAF)
  {
    v27 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v61);
    v32 = "opcode of $ppstreamop must represent an opcode.";
    v33 = &v61;
    goto LABEL_13;
  }
  if (v18 < 3)
  {
    v55 = 0;
    v44 = v26;
    goto LABEL_28;
  }
  v44 = v20[2];
  if (v44 >= 0x4F)
  {
    v27 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v60);
    v32 = "opPrimitiveType of $ppstreamop must represent a primitive type.";
    v33 = &v60;
    goto LABEL_13;
  }
  if (v18 >= 4)
  {
    if (v20[3] < 2)
    {
      if (v41 >= v12)
      {
        v27 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v58);
        v32 = "texture op last arg is missing, it must be a sampler";
        v33 = &v58;
      }
      else
      {
        HIDWORD(v55) = v20[3];
        v51 = v42;
        v52 = glpCallNodeGetArg(a2, v12 - 1);
        v53 = (unsigned int *)glpASTNodeGetSaType(v52);
        if (!glpTypeGetKind(v53))
        {
          PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)v53);
          if (glpPrimitiveTypeGetCategory(PrimitiveType) == 4)
          {
            LODWORD(v55) = 1;
            v43 = v51;
            goto LABEL_29;
          }
        }
        v27 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v57);
        v32 = "texture op last arg is not a sampler, it must be a sampler";
        v33 = &v57;
      }
    }
    else
    {
      v27 = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a2, &v59);
      v32 = "has_offset of $ppstreamop must be 0 or 1.";
      v33 = &v59;
    }
LABEL_13:
    glpLogMessage(v27, 0, (uint64_t)v33, v32, v28, v29, v30, v31, v55);
    return glpSAFailed();
  }
  v55 = 0;
LABEL_28:
  v43 = v42;
LABEL_29:
  Allocator = glpCompilerGetAllocator(a1);
  glpASTNodeGetLocation(a2, &v56);
  PPStreamOpNode = glpMakePPStreamOpNode(Allocator, &v56, v26, v43, v44, v55, SHIDWORD(v55));
  if (v41 < v12)
  {
    do
    {
      v46 = (_QWORD *)glpCompilerGetAllocator(a1);
      v47 = glpCallNodeGetArg(a2, v41);
      glpCallNodeAddArg(v46, PPStreamOpNode, v47);
      ++v41;
    }
    while (v12 != v41);
  }
  v48 = glpGetPrimitiveType(v26);
  glpASTNodeSetSaType(PPStreamOpNode, (uint64_t)v48);
  if (glpCompilerDoesTrackPrecision(a1))
  {
    PrecisionFlagsFromArgs = getPrecisionFlagsFromArgs(PPStreamOpNode);
    v50 = PPStreamOpNode;
  }
  else
  {
    v50 = PPStreamOpNode;
    PrecisionFlagsFromArgs = 0;
  }
  glpASTNodeSetSaFlags(v50, PrecisionFlagsFromArgs);
  return PPStreamOpNode;
}

uint64_t getPrecisionFlagsFromArgs(uint64_t a1)
{
  unsigned int *SaType;
  int v3;
  int HasSrctex;
  int v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int PrimitiveType;
  unsigned int v17;
  uint64_t v18;
  uint64_t result;
  int Opcode;

  SaType = (unsigned int *)glpASTNodeGetSaType(a1);
  if (!glpTypeGetKind(SaType))
  {
    PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType);
    if (glpPrimitiveTypeGetCategory(PrimitiveType))
    {
      v17 = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType);
      if (glpPrimitiveTypeGetCategory(v17) != 4)
      {
        v18 = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType);
        if (glpPrimitiveTypeGetScalarType(v18) == 9)
          return 0;
      }
    }
  }
  v3 = glpCallNodeGetArgCount(a1);
  HasSrctex = glpPPStreamOpNodeGetHasSrctex(a1);
  if (!v3)
  {
    v7 = 0;
    goto LABEL_20;
  }
  v5 = HasSrctex;
  v6 = 0;
  v7 = 0;
  while (1)
  {
    v8 = glpCallNodeGetArg(a1, v6);
    v9 = glpASTNodeGetSaFlags(v8) & 0x1F;
    if (v9 != 2)
      break;
LABEL_13:
    if (v3 == ++v6)
      goto LABEL_20;
  }
  if (!v5
    || (v10 = glpCallNodeGetArg(a1, v6),
        v11 = (unsigned int *)glpASTNodeGetSaType(v10),
        glpTypeGetKind(v11))
    || (v12 = glpCallNodeGetArg(a1, v6),
        v13 = glpASTNodeGetSaType(v12),
        v14 = glpPrimitiveTypeGetPrimitiveType(v13),
        glpPrimitiveTypeGetCategory(v14) != 4))
  {
    if (v9 > v7 && v9 != 31)
      v7 = v9;
    goto LABEL_13;
  }
  v7 = v9;
LABEL_20:
  Opcode = glpPPStreamOpNodeGetOpcode(a1);
  result = 16;
  if ((Opcode - 92) >= 2 && Opcode != 131)
  {
    if (Opcode == 100)
      return 8;
    else
      return v7;
  }
  return result;
}

uint64_t glpSAInlinePPStreamOpFixup(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  uint64_t PrecisionFlagsFromArgs;

  if (glpCompilerDoesTrackPrecision(a1))
  {
    v3 = glpASTNodeGetSaFlags(a2) & 0xFFFFFFFFFFFFFFE0;
    PrecisionFlagsFromArgs = getPrecisionFlagsFromArgs(a2);
    glpASTNodeSetSaFlags(a2, v3 | PrecisionFlagsFromArgs);
  }
  return a2;
}

uint64_t pushdownPrecisionInternal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  int Kind;
  uint64_t IfStatement;
  uint64_t Base;
  unsigned int *v11;
  uint64_t SaFlags;
  unsigned int *v13;
  uint64_t Extra;
  uint64_t v15;
  unsigned int *v16;
  uint64_t v17;
  unsigned int v19;
  uint64_t Expr;
  unsigned int v21;
  uint64_t Statement;
  unsigned int *v23;
  unsigned int *SaType;
  unsigned int *v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t Lhs;
  uint64_t Rhs;
  unsigned int *v30;
  uint64_t v31;

  if (!a2)
    return 1;
  v6 = a2;
  while (1)
  {
    Kind = glpASTNodeGetKind(v6);
    if (Kind > 64)
    {
      if (Kind > 77)
      {
        switch(Kind)
        {
          case 'N':
            return 1;
          case 'Q':
            SaType = (unsigned int *)glpASTNodeGetSaType(v6);
            if (!glpCompilerDoesTypeRequirePrecision(a1, SaType) || (glpASTNodeGetSaFlags(v6) & 0x1F) != 0)
              return 1;
            glpLValueNodeGetVariableExtra(v6);
            break;
          case 'R':
            Base = glpRValueNodeGetBase(v6);
            goto LABEL_26;
          case 'T':
            if ((_DWORD)a4
              || (v25 = (unsigned int *)glpASTNodeGetSaType(v6), glpCompilerDoesTypeRequirePrecision(a1, v25)))
            {
              switch(glpPPStreamOpNodeGetOpcode(v6))
              {
                case 2u:
                case 3u:
                case 4u:
                case 5u:
                case 6u:
                case 7u:
                case 0xCu:
                case 0x10u:
                case 0x12u:
                case 0x13u:
                case 0x15u:
                case 0x16u:
                case 0x17u:
                case 0x19u:
                case 0x1Au:
                case 0x1Bu:
                case 0x1Cu:
                case 0x1Du:
                case 0x1Eu:
                case 0x1Fu:
                case 0x20u:
                case 0x21u:
                case 0x22u:
                case 0x27u:
                case 0x2Cu:
                case 0x2Du:
                case 0x2Eu:
                case 0x2Fu:
                case 0x31u:
                case 0x32u:
                case 0x33u:
                case 0x34u:
                case 0x35u:
                case 0x36u:
                case 0x38u:
                case 0x3Au:
                case 0x3Bu:
                case 0x3Cu:
                case 0x3Du:
                case 0x3Fu:
                case 0x40u:
                case 0x50u:
                case 0x51u:
                case 0x69u:
                case 0x70u:
                case 0x71u:
                case 0x7Bu:
                case 0x7Cu:
                case 0x7Du:
                case 0x7Eu:
                case 0x7Fu:
                case 0x80u:
                case 0x81u:
                case 0x84u:
                case 0x85u:
                case 0x86u:
                case 0x89u:
                case 0x8Au:
                case 0x8Bu:
                case 0x90u:
                case 0x91u:
                case 0x92u:
                case 0x93u:
                case 0x94u:
                case 0x95u:
                  if (glpCallNodeGetArgCount(v6))
                  {
                    v26 = 0;
                    do
                    {
                      v27 = glpCallNodeGetArg(v6, v26);
                      pushdownPrecisionInternal(a1, v27, a3, a4);
                      ++v26;
                    }
                    while (v26 < glpCallNodeGetArgCount(v6));
                  }
                  goto LABEL_54;
                default:
                  if (!(_DWORD)a4)
                    goto LABEL_58;
                  goto LABEL_54;
              }
            }
            return 1;
          default:
            goto LABEL_58;
        }
        goto LABEL_56;
      }
      switch(Kind)
      {
        case 'A':
          Base = glpExpressionStatementNodeGetExpr(v6);
          break;
        case 'C':
          IfStatement = glpIfStatementNodeGetIfStatement(v6);
          pushdownPrecisionInternal(a1, IfStatement, a3, a4);
          Base = glpIfStatementNodeGetElseStatement(v6);
          break;
        case 'B':
          if (glpBlockNodeGetStatementCount(v6))
          {
            v21 = 0;
            do
            {
              Statement = glpBlockNodeGetStatement(v6, v21);
              pushdownPrecisionInternal(a1, Statement, a3, a4);
              ++v21;
            }
            while (v21 < glpBlockNodeGetStatementCount(v6));
          }
          return 1;
        default:
          goto LABEL_58;
      }
      goto LABEL_26;
    }
    if (Kind > 38)
      break;
    if (Kind)
    {
      if (Kind != 16)
      {
        if (Kind == 3)
        {
          v23 = (unsigned int *)glpASTNodeGetSaType(v6);
          if (glpCompilerDoesTypeRequirePrecision(a1, v23) && (glpASTNodeGetSaFlags(v6) & 0x1F) == 0)
          {
            glpSAValidateConstPrecisionConversion(a1, v6, a3);
            goto LABEL_56;
          }
          return 1;
        }
        goto LABEL_58;
      }
      v11 = (unsigned int *)glpASTNodeGetSaType(v6);
      if (glpCompilerDoesTypeRequirePrecision(a1, v11) && (glpASTNodeGetSaFlags(v6) & 0x1F) == 0)
      {
        SaFlags = glpASTNodeGetSaFlags(v6);
        glpASTNodeSetSaFlags(v6, SaFlags & 0xFFFFFFFFFFFFFFE0 | a3);
      }
    }
    else
    {
      v16 = (unsigned int *)glpASTNodeGetSaType(v6);
      if (glpCompilerDoesTypeRequirePrecision(a1, v16) && (glpASTNodeGetSaFlags(v6) & 0x1F) == 0)
      {
        v17 = glpASTNodeGetSaFlags(v6);
        glpASTNodeSetSaFlags(v6, v17 & 0xFFFFFFFFFFFFFFE0 | a3);
        glpTypeConversionNodeSetToPrecision(v6, a3);
      }
    }
    Base = glpUnaryOperatorNodeGetExpr(v6);
LABEL_26:
    v6 = Base;
    if (!Base)
      return 1;
  }
  if (Kind == 46)
  {
    v13 = (unsigned int *)glpASTNodeGetSaType(v6);
    if (glpCompilerDoesTypeRequirePrecision(a1, v13) && (glpASTNodeGetSaFlags(v6) & 0x1F) == 0)
    {
      Extra = glpVariableDeclarationNodeGetExtra(v6);
      *(_QWORD *)(Extra + 48) = *(_QWORD *)(Extra + 48) & 0xFFFFFFFFFFFFFFE0 | a3;
      v15 = glpASTNodeGetSaFlags(v6);
      glpASTNodeSetSaFlags(v6, v15 & 0xFFFFFFFFFFFFFFE0 | a3);
    }
    Base = glpVariableDeclarationNodeGetInitializer(v6);
    goto LABEL_26;
  }
  if (Kind == 39)
  {
    Lhs = glpBinaryOperatorNodeGetLhs(v6);
    pushdownPrecisionInternal(a1, Lhs, a3, a4);
    Rhs = glpBinaryOperatorNodeGetRhs(v6);
    pushdownPrecisionInternal(a1, Rhs, a3, a4);
    goto LABEL_54;
  }
  if (Kind != 43)
LABEL_58:
    abort();
  if (glpCommaExprNodeGetExprCount(v6))
  {
    v19 = 0;
    do
    {
      Expr = glpCommaExprNodeGetExpr(v6, v19);
      pushdownPrecisionInternal(a1, Expr, a3, 1);
      ++v19;
    }
    while (v19 < glpCommaExprNodeGetExprCount(v6));
  }
LABEL_54:
  v30 = (unsigned int *)glpASTNodeGetSaType(v6);
  if (glpCompilerDoesTypeRequirePrecision(a1, v30) && (glpASTNodeGetSaFlags(v6) & 0x1F) == 0)
  {
LABEL_56:
    v31 = glpASTNodeGetSaFlags(v6);
    glpASTNodeSetSaFlags(v6, v31 & 0xFFFFFFFFFFFFFFE0 | a3);
  }
  return 1;
}

uint64_t glpPushdownPrecision(uint64_t a1, uint64_t a2, char a3)
{
  pushdownPrecisionInternal(a1, a2, a3 & 0x1F, 0);
  return 1;
}

unint64_t glp_serialized_integer64_control(unint64_t result)
{
  unint64_t v1;
  uint64_t v2;
  unsigned int v3;
  unint64_t v4;
  unint64_t v5;

  if (result >= 0x80)
  {
    v1 = result & 0xFF00000000000000;
    v2 = (result & 0xFF00000000000000) != 0 && HIBYTE(result) != 255;
    v3 = ((v1 ^ (v2 << 63 >> 63)) == 0xFF00000000000000) | 0xFFFFFF8E;
    if ((v2 & 1) == 0)
    {
      v4 = 0xFF00000000000000;
      do
      {
        v3 = v3 & 0xFFFFFFF1 | (2 * (((v3 + 14) >> 1) & 7));
        if (v4 >> 8 == 255)
          break;
        v1 >>= 8;
        v5 = result & (v4 >> 8);
        v4 >>= 8;
      }
      while (v5 == v1);
    }
    return v3 & 0xFFFFFF8F;
  }
  return result;
}

uint64_t glp_serialized_integer32_control(uint64_t result)
{
  int v1;
  unsigned int v2;
  int v3;
  int v4;
  unsigned int v5;

  if ((int)result >= 0)
    v1 = -128;
  else
    v1 = -127;
  v2 = result ^ ((int)result >> 31);
  if (HIBYTE(v2))
    v3 = 6;
  else
    v3 = 4;
  if (v2 >= 0x10000)
    v4 = v3;
  else
    v4 = 2 * (v2 > 0xFF);
  v5 = v4 | v1;
  if (result >= 0x80)
    return v5;
  else
    return result;
}

uint64_t glpInitSerialContext(_QWORD *a1, _OWORD *a2)
{
  __int128 v3;
  uint64_t result;

  v3 = a2[1];
  *(_OWORD *)a1 = *a2;
  *((_OWORD *)a1 + 1) = v3;
  a1[4] = 1024;
  a1[5] = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 1024, "Vector Storage (uint8_t)");
  a1[6] = glpMakeStringHash(a1);
  a1[7] = 0;
  result = glpMakePointerHash(a1);
  a1[8] = result;
  return result;
}

uint64_t glpDestroySerialContext(uint64_t a1, int a2)
{
  uint64_t result;

  glpDestroyPointerHash(*(_QWORD *)(a1 + 64));
  result = glpDestroyStringHash(*(_QWORD *)(a1 + 48));
  if (a2)
    return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 24))(*(_QWORD *)a1, *(_QWORD *)(a1 + 40));
  return result;
}

uint64_t serialize_pointer(_QWORD *a1, unint64_t a2)
{
  int v4;
  double v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  _DWORD *v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  char *v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  char *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  char *v35;
  int v36;
  int v37;
  unsigned int v38;
  uint64_t result;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  uint64_t v44;
  char *v45;
  unsigned int v46;
  unsigned int v47;
  int v48;
  int v49;
  uint64_t v50;
  char *v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  int v55;
  uint64_t v56;
  char *v57;
  unsigned int v58;
  unsigned int v59;
  int v60;
  int v61;
  uint64_t v62;
  char *v63;
  unsigned int v64;
  uint64_t v65;

  if (!a2)
  {
    v13 = (_DWORD *)a1 + 9;
    v21 = *((unsigned int *)a1 + 9);
    v22 = v21 + 1;
    v23 = *((_DWORD *)a1 + 8);
    if ((int)v21 + 1 <= v23)
    {
      v26 = (char *)a1[5];
      v27 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v23 <= 1)
        v23 = 1;
      v24 = 2 * v23;
      if (v24 <= v22)
        v25 = v22;
      else
        v25 = v24;
      v26 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v25, "Vector Storage (uint8_t, growth)");
      memcpy(v26, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v25;
      a1[5] = v26;
      v27 = *((_DWORD *)a1 + 9);
    }
    memmove(&v26[v21 + 1], &v26[v21], (v27 - v21));
    result = 0;
    *(_BYTE *)(a1[5] + v21) = 0;
LABEL_41:
    v40 = 1;
    goto LABEL_52;
  }
  v4 = glpPointerHashGet(a1[8], a2);
  if (!v4)
  {
    v28 = a1[8];
    v29 = a1[7] + 1;
    a1[7] = v29;
    glpPointerHashPut(v28, a2, v29, v5);
    v13 = (_DWORD *)a1 + 9;
    v30 = *((unsigned int *)a1 + 9);
    v31 = v30 + 1;
    v32 = *((_DWORD *)a1 + 8);
    if ((int)v30 + 1 <= v32)
    {
      v35 = (char *)a1[5];
      v36 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v32 <= 1)
        v32 = 1;
      v33 = 2 * v32;
      if (v33 <= v31)
        v34 = v31;
      else
        v34 = v33;
      v35 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v34, "Vector Storage (uint8_t, growth)");
      memcpy(v35, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v34;
      a1[5] = v35;
      v36 = *((_DWORD *)a1 + 9);
    }
    memmove(&v35[v30 + 1], &v35[v30], (v36 - v30));
    v40 = 1;
    *(_BYTE *)(a1[5] + v30) = 1;
    result = 1;
LABEL_52:
    *v13 += v40;
    return result;
  }
  v6 = v4 + 1;
  if (v4 + 1 >= 0)
    v7 = -128;
  else
    v7 = -127;
  v8 = v6 ^ (v6 >> 31);
  if (HIBYTE(v8))
    v9 = 6;
  else
    v9 = 4;
  if (v8 >= 0x10000)
    v10 = v9;
  else
    v10 = 2 * (v8 > 0xFF);
  v11 = v10 | v7;
  if (v6 < 0x80)
    v12 = v4 + 1;
  else
    v12 = v11;
  v13 = (_DWORD *)a1 + 9;
  v14 = *((unsigned int *)a1 + 9);
  v15 = v14 + 1;
  v16 = *((_DWORD *)a1 + 8);
  if ((int)v14 + 1 <= v16)
  {
    v19 = (char *)a1[5];
    v20 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v16 <= 1)
      v16 = 1;
    v17 = 2 * v16;
    if (v17 <= v15)
      v18 = v15;
    else
      v18 = v17;
    v19 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v18, "Vector Storage (uint8_t, growth)");
    memcpy(v19, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v18;
    a1[5] = v19;
    v20 = *((_DWORD *)a1 + 9);
  }
  memmove(&v19[v14 + 1], &v19[v14], (v20 - v14));
  *(_BYTE *)(a1[5] + v14) = v12;
  v37 = *((_DWORD *)a1 + 9);
  v38 = v37 + 1;
  *((_DWORD *)a1 + 9) = v37 + 1;
  if ((v12 & 0x80) != 0)
  {
    switch((v12 >> 1) & 7)
    {
      case 0u:
        v41 = v37 + 2;
        v42 = *((_DWORD *)a1 + 8);
        if (v41 <= v42)
        {
          v45 = (char *)a1[5];
          v46 = v38;
        }
        else
        {
          if (v42 <= 1)
            v42 = 1;
          v43 = 2 * v42;
          if (v43 <= (int)v41)
            v44 = v41;
          else
            v44 = v43;
          v45 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v44, "Vector Storage (uint8_t, growth)");
          memcpy(v45, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v44;
          a1[5] = v45;
          v46 = *((_DWORD *)a1 + 9);
        }
        memmove(&v45[v38 + 1], &v45[v38], v46 - v38);
        result = 0;
        *(_BYTE *)(a1[5] + v38) = v6;
        goto LABEL_41;
      case 1u:
        v59 = v37 + 3;
        v60 = *((_DWORD *)a1 + 8);
        if (v59 <= v60)
        {
          v63 = (char *)a1[5];
          v64 = v38;
        }
        else
        {
          if (v60 <= 1)
            v60 = 1;
          v61 = 2 * v60;
          if (v61 <= (int)v59)
            v62 = v59;
          else
            v62 = v61;
          v63 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v62, "Vector Storage (uint8_t, growth)");
          memcpy(v63, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v62;
          a1[5] = v63;
          v64 = *((_DWORD *)a1 + 9);
        }
        memmove(&v63[v38 + 1], &v63[v38], v64 - v38);
        result = 0;
        *(_WORD *)(a1[5] + v38) = v6;
        v40 = 2;
        goto LABEL_52;
      case 2u:
        v47 = v37 + 4;
        v48 = *((_DWORD *)a1 + 8);
        if (v47 <= v48)
        {
          v51 = (char *)a1[5];
          v52 = v38;
        }
        else
        {
          if (v48 <= 1)
            v48 = 1;
          v49 = 2 * v48;
          if (v49 <= (int)v47)
            v50 = v47;
          else
            v50 = v49;
          v51 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v50, "Vector Storage (uint8_t, growth)");
          memcpy(v51, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v50;
          a1[5] = v51;
          v52 = *((_DWORD *)a1 + 9);
        }
        memmove(&v51[v38 + 1], &v51[v38], v52 - v38);
        result = 0;
        v65 = a1[5] + v38;
        *(_BYTE *)(v65 + 2) = BYTE2(v6);
        *(_WORD *)v65 = v6;
        v40 = 3;
        goto LABEL_52;
      case 3u:
        v53 = v37 + 5;
        v54 = *((_DWORD *)a1 + 8);
        if (v53 <= v54)
        {
          v57 = (char *)a1[5];
          v58 = v38;
        }
        else
        {
          if (v54 <= 1)
            v54 = 1;
          v55 = 2 * v54;
          if (v55 <= (int)v53)
            v56 = v53;
          else
            v56 = v55;
          v57 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v56, "Vector Storage (uint8_t, growth)");
          memcpy(v57, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v56;
          a1[5] = v57;
          v58 = *((_DWORD *)a1 + 9);
        }
        memmove(&v57[v38 + 1], &v57[v38], v58 - v38);
        result = 0;
        *(_DWORD *)(a1[5] + v38) = v6;
        v40 = 4;
        goto LABEL_52;
      default:
        return 0;
    }
  }
  return 0;
}

uint64_t serialize_GLPString(_QWORD *a1, const char *a2, uint64_t a3)
{
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  char *v17;
  int v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  uint64_t v24;
  char *v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  int v29;
  uint64_t v30;
  char *v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  int v35;
  uint64_t v36;
  char *v37;
  unsigned int v38;
  unsigned int v39;
  int v40;
  int v41;
  uint64_t v42;
  char *v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  const void *v47;
  uint64_t result;
  int v49;
  uint64_t v50;
  int v51;
  int v52;
  uint64_t v53;
  char *v54;
  int v55;

  if ((int)a3 >= 0)
    v6 = -128;
  else
    v6 = -127;
  v7 = a3 ^ ((int)a3 >> 31);
  if (HIBYTE(v7))
    v8 = 6;
  else
    v8 = 4;
  if (v7 >= 0x10000)
    v9 = v8;
  else
    v9 = 2 * (v7 > 0xFF);
  v10 = v9 | v6;
  if (a3 >= 0x80)
    v11 = v10;
  else
    v11 = a3;
  v12 = *((_DWORD *)a1 + 8);
  v13 = *((unsigned int *)a1 + 9);
  v14 = v13 + 1;
  if ((int)v13 + 1 <= v12)
  {
    v17 = (char *)a1[5];
    v18 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v12 <= 1)
      v12 = 1;
    v15 = 2 * v12;
    if (v15 <= v14)
      v16 = v14;
    else
      v16 = v15;
    v17 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v16, "Vector Storage (uint8_t, growth)");
    memcpy(v17, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v16;
    a1[5] = v17;
    v18 = *((_DWORD *)a1 + 9);
  }
  memmove(&v17[v13 + 1], &v17[v13], (v18 - v13));
  *(_BYTE *)(a1[5] + v13) = v11;
  v19 = *((_DWORD *)a1 + 9);
  v20 = v19 + 1;
  *((_DWORD *)a1 + 9) = v19 + 1;
  if ((v11 & 0x80) != 0)
  {
    switch((v11 >> 1) & 7)
    {
      case 0u:
        v21 = v19 + 2;
        v22 = *((_DWORD *)a1 + 8);
        if (v21 <= v22)
        {
          v25 = (char *)a1[5];
          v26 = v20;
        }
        else
        {
          if (v22 <= 1)
            v22 = 1;
          v23 = 2 * v22;
          if (v23 <= (int)v21)
            v24 = v21;
          else
            v24 = v23;
          v25 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v24, "Vector Storage (uint8_t, growth)");
          memcpy(v25, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v24;
          a1[5] = v25;
          v26 = *((_DWORD *)a1 + 9);
        }
        memmove(&v25[v20 + 1], &v25[v20], v26 - v20);
        *(_BYTE *)(a1[5] + v20) = a3;
        v45 = 1;
        goto LABEL_59;
      case 1u:
        v39 = v19 + 3;
        v40 = *((_DWORD *)a1 + 8);
        if (v39 <= v40)
        {
          v43 = (char *)a1[5];
          v44 = v20;
        }
        else
        {
          if (v40 <= 1)
            v40 = 1;
          v41 = 2 * v40;
          if (v41 <= (int)v39)
            v42 = v39;
          else
            v42 = v41;
          v43 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v42, "Vector Storage (uint8_t, growth)");
          memcpy(v43, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v42;
          a1[5] = v43;
          v44 = *((_DWORD *)a1 + 9);
        }
        memmove(&v43[v20 + 1], &v43[v20], v44 - v20);
        *(_WORD *)(a1[5] + v20) = a3;
        v45 = 2;
        goto LABEL_59;
      case 2u:
        v27 = v19 + 4;
        v28 = *((_DWORD *)a1 + 8);
        if (v27 <= v28)
        {
          v31 = (char *)a1[5];
          v32 = v20;
        }
        else
        {
          if (v28 <= 1)
            v28 = 1;
          v29 = 2 * v28;
          if (v29 <= (int)v27)
            v30 = v27;
          else
            v30 = v29;
          v31 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v30, "Vector Storage (uint8_t, growth)");
          memcpy(v31, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v30;
          a1[5] = v31;
          v32 = *((_DWORD *)a1 + 9);
        }
        memmove(&v31[v20 + 1], &v31[v20], v32 - v20);
        v46 = a1[5] + v20;
        *(_BYTE *)(v46 + 2) = BYTE2(a3);
        *(_WORD *)v46 = a3;
        v45 = 3;
        goto LABEL_59;
      case 3u:
        v33 = v19 + 5;
        v34 = *((_DWORD *)a1 + 8);
        if (v33 <= v34)
        {
          v37 = (char *)a1[5];
          v38 = v20;
        }
        else
        {
          if (v34 <= 1)
            v34 = 1;
          v35 = 2 * v34;
          if (v35 <= (int)v33)
            v36 = v33;
          else
            v36 = v35;
          v37 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v36, "Vector Storage (uint8_t, growth)");
          memcpy(v37, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v36;
          a1[5] = v37;
          v38 = *((_DWORD *)a1 + 9);
        }
        memmove(&v37[v20 + 1], &v37[v20], v38 - v20);
        *(_DWORD *)(a1[5] + v20) = a3;
        v45 = 4;
LABEL_59:
        *((_DWORD *)a1 + 9) += v45;
        break;
      default:
        break;
    }
  }
  v47 = (const void *)glpStringHashCache(a1[6], a2, a3, (uint64_t)a2);
  result = serialize_pointer(a1, (unint64_t)v47);
  if ((_DWORD)result)
  {
    v49 = *((_DWORD *)a1 + 8);
    v50 = *((unsigned int *)a1 + 9);
    v51 = v50 + a3;
    if ((int)v50 + (int)a3 <= v49)
    {
      v54 = (char *)a1[5];
      v55 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v49 <= 1)
        v49 = 1;
      v52 = 2 * v49;
      if (v52 <= v51)
        v53 = v51;
      else
        v53 = v52;
      v54 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v53, "Vector Storage (uint8_t, growth)");
      memcpy(v54, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v53;
      a1[5] = v54;
      v55 = *((_DWORD *)a1 + 9);
    }
    memmove(&v54[v50 + 1], &v54[v50], (v55 - v50));
    result = (uint64_t)memcpy((void *)(a1[5] + v50), v47, a3);
    *((_DWORD *)a1 + 9) += a3;
  }
  return result;
}

char *deserialErrorString(unsigned int a1)
{
  if (a1 >= 7)
    abort();
  return off_24F4B0990[a1];
}

uint64_t glpInitDeserialContext(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t result;

  *(_QWORD *)(a1 + 200) = a2;
  *(_QWORD *)(a1 + 208) = 4096;
  result = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a2 + 8))(*(_QWORD *)a2, 0x8000, "Vector Storage (void *)");
  *(_QWORD *)(a1 + 216) = result;
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 232) = 0;
  *(_QWORD *)(a1 + 240) = a3;
  *(_QWORD *)(a1 + 248) = a4;
  *(_DWORD *)(a1 + 256) = a5;
  *(_DWORD *)(a1 + 260) = 0;
  return result;
}

uint64_t glpReInitDeserialContext(uint64_t result, uint64_t a2, int a3)
{
  *(_DWORD *)(result + 212) = 0;
  *(_QWORD *)(result + 248) = a2;
  *(_DWORD *)(result + 256) = a3;
  *(_DWORD *)(result + 260) = 0;
  return result;
}

uint64_t glpDestroyDeserialContext(_QWORD *a1)
{
  _QWORD *i;

  for (i = (_QWORD *)a1[28]; i; i = (_QWORD *)a1[28])
  {
    a1[28] = *i;
    (*(void (**)(_QWORD))(a1[25] + 24))(*(_QWORD *)a1[25]);
  }
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1[25] + 24))(*(_QWORD *)a1[25], a1[27]);
}

float deserialize_float(uint64_t a1)
{
  uint64_t v1;
  float result;

  v1 = *(unsigned int *)(a1 + 260);
  if (v1 + 4 > (unint64_t)*(unsigned int *)(a1 + 256))
    glpDeserialError(a1, 1u);
  result = *(float *)(*(_QWORD *)(a1 + 248) + v1);
  *(_DWORD *)(a1 + 260) = v1 + 4;
  return result;
}

double deserialize_double(uint64_t a1)
{
  uint64_t v1;
  double result;

  v1 = *(unsigned int *)(a1 + 260);
  if (v1 + 8 > (unint64_t)*(unsigned int *)(a1 + 256))
    glpDeserialError(a1, 1u);
  result = *(double *)(*(_QWORD *)(a1 + 248) + v1);
  *(_DWORD *)(a1 + 260) = v1 + 8;
  return result;
}

unsigned int *deserialize_pointer(unsigned int *result, uint64_t a2, _QWORD *a3)
{
  unsigned int *v3;
  uint64_t v4;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  char *v13;
  int v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  _QWORD *v18;
  char *v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  _QWORD *v25;
  char *v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v3 = result;
  v4 = result[65];
  if (v4 >= result[64])
    glpDeserialError((uint64_t)result, 1u);
  v7 = *((_QWORD *)result + 31);
  v8 = *(char *)(v7 + v4);
  v9 = *(unsigned __int8 *)(v7 + v4);
  result[65] = v4 + 1;
  if (v8 < 0)
    __asm { BR              X16 }
  if ((_DWORD)v9 == 1)
  {
    v10 = *((_QWORD *)result + 29);
    if (v10)
    {
      *((_QWORD *)result + 29) = *(_QWORD *)v10;
    }
    else
    {
      v10 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(*((_QWORD *)result + 25) + 8))(**((_QWORD **)result + 25), 32, "FutureStack");
      *(_QWORD *)(v10 + 8) = 0;
      *(_QWORD *)(v10 + 16) = 0;
      *(_QWORD *)v10 = 0;
    }
    *(_QWORD *)v10 = *((_QWORD *)v3 + 28);
    v21 = v3[52];
    v22 = v3[53];
    *(_DWORD *)(v10 + 24) = v22;
    *((_QWORD *)v3 + 28) = v10;
    if ((int)v22 + 1 <= v21)
    {
      v26 = (char *)*((_QWORD *)v3 + 27);
      v27 = v22;
    }
    else
    {
      if (v21 <= 1)
        v21 = 1;
      v23 = 2 * v21;
      if (v23 <= (int)v22 + 1)
        v24 = v22 + 1;
      else
        v24 = v23;
      v25 = (_QWORD *)*((_QWORD *)v3 + 25);
      v26 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))v25[1])(*v25, 8 * v24, "Vector Storage (void *, growth)");
      memcpy(v26, *((const void **)v3 + 27), 8 * v3[53]);
      ((void (*)(_QWORD, _QWORD))v25[3])(*v25, *((_QWORD *)v3 + 27));
      v3[52] = v24;
      *((_QWORD *)v3 + 27) = v26;
      v27 = v3[53];
    }
    memmove(&v26[8 * v22 + 8], &v26[8 * v22], 8 * (v27 - v22));
    *(_QWORD *)(*((_QWORD *)v3 + 27) + 8 * v22) = 0;
    ++v3[53];
    result = (unsigned int *)(*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
    *(_QWORD *)(*((_QWORD *)v3 + 27) + 8 * *(unsigned int *)(v10 + 24)) = result;
    v28 = *(unsigned int *)(v10 + 12);
    if ((_DWORD)v28)
    {
      v29 = 0;
      v30 = 8 * v28;
      do
      {
        **(_QWORD **)(*(_QWORD *)(v10 + 16) + v29) = result;
        v29 += 8;
      }
      while (v30 != v29);
    }
    v31 = *(_QWORD *)v10;
    *(_DWORD *)(v10 + 12) = 0;
    *(_DWORD *)(v10 + 24) = 0;
    *(_QWORD *)v10 = *((_QWORD *)v3 + 29);
    *((_QWORD *)v3 + 28) = v31;
    *((_QWORD *)v3 + 29) = v10;
    *a3 = result;
  }
  else if ((_DWORD)v9)
  {
    v11 = v9 - 2;
    if ((int)v9 - 2 < result[53] && (v12 = *(_QWORD *)(*((_QWORD *)result + 27) + 8 * v11)) != 0)
    {
      *a3 = v12;
    }
    else
    {
      v13 = (char *)(result + 56);
      do
      {
        v13 = *(char **)v13;
        if (!v13)
          glpDeserialError((uint64_t)result, 2u);
      }
      while (*((_DWORD *)v13 + 6) != v11);
      v14 = *((_DWORD *)v13 + 2);
      v15 = *((unsigned int *)v13 + 3);
      if ((int)v15 + 1 <= v14)
      {
        v19 = (char *)*((_QWORD *)v13 + 2);
        v20 = *((_DWORD *)v13 + 3);
      }
      else
      {
        if (v14 <= 1)
          v14 = 1;
        v16 = 2 * v14;
        if (v16 <= (int)v15 + 1)
          v17 = v15 + 1;
        else
          v17 = v16;
        v18 = (_QWORD *)*((_QWORD *)result + 25);
        v19 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))v18[1])(*v18, 8 * v17, "Vector Storage (void**, growth)");
        memcpy(v19, *((const void **)v13 + 2), 8 * *((unsigned int *)v13 + 3));
        ((void (*)(_QWORD, _QWORD))v18[3])(*v18, *((_QWORD *)v13 + 2));
        *((_DWORD *)v13 + 2) = v17;
        *((_QWORD *)v13 + 2) = v19;
        v20 = *((_DWORD *)v13 + 3);
      }
      result = (unsigned int *)memmove(&v19[8 * v15 + 8], &v19[8 * v15], 8 * (v20 - v15));
      *(_QWORD *)(*((_QWORD *)v13 + 2) + 8 * v15) = a3;
      ++*((_DWORD *)v13 + 3);
    }
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

void glpDeserialError(uint64_t a1, unsigned int a2)
{
  char v4;
  unsigned __int8 md[17];

  CC_SHA1(*(const void **)(a1 + 248), *(_DWORD *)(a1 + 256), md);
  v4 = deserialErrorString(a2);
  glpSetCrashLogMessagef("GLProgrammability: deserial error (%s) at offset %u into data of length %u with SHA1 %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x", md[10], md[11], md[12], md[13], md[14], md[15], md[16], v4);
  _longjmp((int *)a1, a2);
}

uint64_t deserialize_GLPString(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t result;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  _QWORD v9[6];
  uint64_t v10;

  v1 = *(unsigned int *)(a1 + 260);
  if (v1 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v2 = *(_QWORD *)(a1 + 248);
  v3 = *(char *)(v2 + v1);
  v4 = *(unsigned __int8 *)(v2 + v1);
  *(_DWORD *)(a1 + 260) = v1 + 1;
  if (v3 < 0)
    __asm { BR              X16 }
  v10 = 0;
  v9[0] = MEMORY[0x24BDAC760];
  v9[1] = 0x40000000;
  v9[2] = __deserialize_GLPString_block_invoke;
  v9[3] = &__block_descriptor_tmp_8;
  v9[4] = a1;
  v9[5] = v4;
  deserialize_pointer((unsigned int *)a1, (uint64_t)v9, &v10);
  result = v10;
  v6 = v4 >> 5;
  if (v4 >> 5 < v4)
  {
    v7 = ~(v4 >> 5);
    v8 = v4;
    do
    {
      v8 ^= 32 * v8 + (v8 >> 2) + *(char *)(v10 + (v4 - 1));
      LODWORD(v4) = v4 + v7;
    }
    while (v4 > v6);
  }
  return result;
}

uint64_t ShInitialize(_OWORD *a1, int a2)
{
  _OWORD *v2;
  __int128 v3;
  _BYTE *v4;

  if (a1)
  {
    v2 = (_OWORD *)((char *)&glpBuiltInConstantValues + 32 * (a2 == 4));
    v3 = a1[1];
    *v2 = *a1;
    v2[1] = v3;
    v4 = &glpBuiltInConstantsInitialized;
    if (a2 == 4)
      v4 = &unk_254127231;
    *v4 = 1;
  }
  return 1;
}

_DWORD *ShConstructCompiler(int *a1)
{
  int v2;
  int v3;
  int v4;
  _DWORD *v5;
  _DWORD *v6;
  uint64_t Log;

  v2 = *a1;
  v3 = a1[2];
  v4 = a1[4];
  v5 = malloc_type_malloc(0x88uLL, 0x7081ABB9uLL);
  if (!v5)
    abort();
  v6 = v5;
  *v5 = 0;
  v5[2] = 0;
  v5[3] = v2;
  v5[4] = a1[3];
  v5[5] = v4;
  *((_QWORD *)v5 + 3) = glpMakeLog(&GLP_MALLOC_ALLOCATOR);
  Log = glpMakeLog(&GLP_MALLOC_ALLOCATOR);
  *((_QWORD *)v6 + 5) = 0;
  *((_QWORD *)v6 + 6) = 0;
  *((_QWORD *)v6 + 4) = Log;
  v6[14] = v3;
  return v6;
}

_DWORD *ShConstructLinker(int *a1)
{
  int v2;
  int v3;
  _DWORD *v4;
  _DWORD *v5;

  v2 = *a1;
  v3 = a1[4];
  v4 = malloc_type_malloc(0x88uLL, 0x7081ABB9uLL);
  if (!v4)
    abort();
  v5 = v4;
  *v4 = 1;
  v4[2] = 0;
  v4[3] = v2;
  v4[4] = a1[3];
  v4[5] = v3;
  *((_QWORD *)v4 + 3) = glpMakeLog(&GLP_MALLOC_ALLOCATOR);
  *((_QWORD *)v5 + 4) = glpMakeLog(&GLP_MALLOC_ALLOCATOR);
  *(_OWORD *)(v5 + 10) = 0u;
  *(_OWORD *)(v5 + 14) = 0u;
  *(_OWORD *)(v5 + 17) = 0u;
  *((_QWORD *)v5 + 11) = 0;
  *((_QWORD *)v5 + 12) = 0;
  *((_QWORD *)v5 + 13) = glpMakeStringHash(&GLP_MALLOC_ALLOCATOR);
  *((_QWORD *)v5 + 14) = glpMakeStringHash(&GLP_MALLOC_ALLOCATOR);
  *((_QWORD *)v5 + 15) = 0;
  *((_QWORD *)v5 + 16) = (*((void *(**)(int, size_t))&GLP_MALLOC_ALLOCATOR + 1))(GLP_MALLOC_ALLOCATOR, 0);
  return v5;
}

void ShDestruct(unsigned int *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t j;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  unint64_t v15;

  handleResetPre((uint64_t)a1);
  handleResetPost((uint64_t)a1);
  if (*a1 == 1)
  {
    v2 = *((_QWORD *)a1 + 13);
    v3 = *(unsigned int *)(v2 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = *(_QWORD *)(v2 + 40);
        v7 = *(void **)(v6 + v4);
        if (v7)
        {
          free(*(void **)(v6 + v4 + 8));
          free(v7);
          v3 = *(unsigned int *)(v2 + 32);
        }
        v4 += 32;
      }
      v2 = *((_QWORD *)a1 + 13);
    }
    glpDestroyStringHash(v2);
    *((_QWORD *)a1 + 13) = 0;
    v8 = *((_QWORD *)a1 + 14);
    v9 = *(unsigned int *)(v8 + 32);
    if ((_DWORD)v9)
    {
      v10 = 0;
      for (j = 0; j < v9; ++j)
      {
        v12 = *(_QWORD *)(v8 + 40);
        v13 = *(void **)(v12 + v10);
        if (v13)
        {
          free(*(void **)(v12 + v10 + 8));
          free(v13);
          v9 = *(unsigned int *)(v8 + 32);
        }
        v10 += 32;
      }
      v8 = *((_QWORD *)a1 + 14);
    }
    glpDestroyStringHash(v8);
    *((_QWORD *)a1 + 14) = 0;
    if (a1[31])
    {
      v14 = 0;
      v15 = 0;
      do
      {
        free(*(void **)(*((_QWORD *)a1 + 16) + v14));
        ++v15;
        v14 += 16;
      }
      while (v15 < a1[31]);
    }
    off_255B0BD18(GLP_MALLOC_ALLOCATOR, *((void **)a1 + 16));
  }
  free(a1);
}

uint64_t handleResetPre(uint64_t result)
{
  _QWORD *v1;
  _QWORD **v2;
  _QWORD **v3;
  _QWORD *v4;
  uint64_t v5;

  v1 = (_QWORD *)result;
  if (*(_DWORD *)result <= 1u)
  {
    v2 = *(_QWORD ***)(result + 24);
    if (v2)
    {
      glpDestroyLog(v2);
      v1[3] = 0;
    }
    v3 = (_QWORD **)v1[4];
    if (v3)
    {
      glpDestroyLog(v3);
      v1[4] = 0;
    }
    v5 = v1[5];
    v4 = v1 + 5;
    result = v5;
    if (v5)
    {
      result = glpDestroyStringBuffer((_QWORD **)result);
      *v4 = 0;
    }
  }
  return result;
}

void handleResetPost(uint64_t a1)
{
  void **v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t i;
  void *v9;
  void *v10;

  if (*(_DWORD *)a1 == 1)
  {
    v4 = *(_QWORD *)(a1 + 48);
    if (v4)
    {
      glpDestroyLinkedProgram(v4);
      *(_QWORD *)(a1 + 48) = 0;
    }
    free(*(void **)(a1 + 56));
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 64) = 0;
    free(*(void **)(a1 + 72));
    *(_QWORD *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 80) = 0;
    v5 = *(_QWORD *)(a1 + 88);
    if (v5)
    {
      v6 = *(unsigned int *)(v5 + 32);
      if ((_DWORD)v6)
      {
        v7 = 0;
        for (i = 0; i < v6; ++i)
        {
          v9 = *(void **)(*(_QWORD *)(v5 + 40) + v7);
          if (v9)
          {
            free(v9);
            v6 = *(unsigned int *)(v5 + 32);
          }
          v7 += 16;
        }
        v5 = *(_QWORD *)(a1 + 88);
      }
      glpDestroyIntHash(v5);
      *(_QWORD *)(a1 + 88) = 0;
    }
    v10 = *(void **)(a1 + 96);
    v3 = (_QWORD *)(a1 + 96);
    free(v10);
    goto LABEL_16;
  }
  if (!*(_DWORD *)a1)
  {
    v3 = (_QWORD *)(a1 + 48);
    v2 = *(void ***)(a1 + 48);
    if (v2)
    {
      glpDestroyCompiledShader(v2);
LABEL_16:
      *v3 = 0;
    }
  }
}

uint64_t ShFinalize()
{
  return 1;
}

BOOL ShCompile(int32x2_t *a1, const char **a2, uint64_t a3, int32x2_t *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t Log;
  uint64_t v10;
  size_t v11;
  char *v12;
  void *v13;
  uint64_t v14;
  unsigned int *v15;
  _DWORD *v16;
  _QWORD *Compiler;
  _DWORD *v18;
  unint64_t v19;
  unsigned int v20;
  char *v21;
  uint64_t v22;
  _BOOL8 result;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  _QWORD *v28;
  uint64_t *StringBuffer;
  unint64_t TopLevelNode;
  uint64_t v31;
  uint64_t v32;
  char v33;
  uint64_t v34;
  _BOOL4 v35;
  uint64_t v36;
  void *v37;
  _OWORD v38[2];
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  v7 = (uint64_t)a4[11];
  v34 = (uint64_t)a4[10];
  v8 = (uint64_t)a4[12];
  v33 = (char)*a4;
  a1[1] = vrev64_s32(*a4);
  handleResetPre((uint64_t)a1);
  Log = glpMakeLog(&GLP_MALLOC_ALLOCATOR);
  v10 = glpMakeLog(&GLP_MALLOC_ALLOCATOR);
  memset(v38, 0, sizeof(v38));
  if (!compilerCache)
    dispatch_sync((dispatch_queue_t)gSerialQueue, &__block_literal_global_3);
  v11 = strlen(*a2);
  v12 = (char *)malloc_type_malloc(v11 + 17, 0x7081ABB9uLL);
  if (!v12)
    goto LABEL_21;
  v13 = v12;
  *(_DWORD *)v12 = a1[2].i32[0];
  *((_DWORD *)v12 + 1) = a1[2].i32[1];
  *((_QWORD *)v12 + 1) = a1[7].u32[0];
  memcpy(v12 + 16, *a2, v11 + 1);
  glpCacheGenerateHash(v13, v11 + 17, (unsigned __int8 *)v38);
  free(v13);
  v36 = 0;
  v37 = 0;
  if (!glpCacheGetElement(compilerCache, (uint64_t)v38, (uint64_t)&v37, (uint64_t)&v36))
  {
    v32 = v10;
    Compiler = glpMakeCompiler(a1[2].u32[0], a1[2].i32[1], a1[7].i32[0], Log, v10, 128, ((unsigned __int32)a4[3].i32[0] >> 2) & 1);
    v18 = glpCompileShader(Compiler, *a2, v34, v7, v8);
    v16 = v18;
    v31 = (uint64_t)Compiler;
    v35 = v18 != 0;
    if (v18)
    {
      v19 = (glpCompiledShaderSerializedSize((uint64_t)v18) + 19) & 0xFFFFFFFFFFFFFFFCLL;
      v20 = 16;
    }
    else
    {
      v20 = 0;
      v19 = 16;
    }
    v24 = (v19 | 3) + glpLogGetSerializedSize(Log);
    v25 = (glpLogGetSerializedSize(Log) + (v24 & 0xFFFFFFFFFFFFFFFCLL) + 3) & 0xFFFFFFFFFFFFFFFCLL;
    v26 = (char *)malloc_type_malloc(v25, 0x7081ABB9uLL);
    if (v26)
    {
      v27 = v26;
      *(_DWORD *)v26 = v35;
      *((_DWORD *)v26 + 1) = v20;
      *((_DWORD *)v26 + 2) = v19;
      *((_DWORD *)v26 + 3) = v24 & 0xFFFFFFFC;
      if (v16)
      {
        glpCompiledShaderSerialize((uint64_t)v16, &v26[v20]);
        glpLogSerialize(Log, &v27[v19 & 0xFFFFFFFC]);
        v22 = v32;
        glpLogSerialize(v32, &v27[v24 & 0xFFFFFFFC]);
        glpCacheAddElement(compilerCache, (uint64_t)v38, (uint64_t)v27, v25);
        free(v27);
        v28 = (_QWORD *)v31;
        if ((v33 & 1) != 0)
        {
          StringBuffer = (uint64_t *)glpLogGetStringBuffer(v32);
          glpStringBufferAppendCString(StringBuffer, "\nIntermediate Parse Tree\n========================\n");
          TopLevelNode = glpCompilerGetTopLevelNode(v31);
          glpDumpASTNodeToStringBuffer(StringBuffer, TopLevelNode);
        }
      }
      else
      {
        glpLogSerialize(Log, &v26[v19 & 0xFFFFFFFC]);
        v22 = v32;
        glpLogSerialize(v32, &v27[v24 & 0xFFFFFFFC]);
        glpCacheAddElement(compilerCache, (uint64_t)v38, (uint64_t)v27, v25);
        free(v27);
        v28 = (_QWORD *)v31;
      }
      glpDestroyCompiler(v28);
      if (v16)
        goto LABEL_11;
      goto LABEL_12;
    }
LABEL_21:
    abort();
  }
  v14 = v10;
  v15 = (unsigned int *)v37;
  if (*(_DWORD *)v37)
    v16 = glpCompiledShaderDeserialize((int *)((char *)v37 + *((unsigned int *)v37 + 1)));
  else
    v16 = 0;
  glpLogDeserialize(Log, (uint64_t)v37 + v15[2]);
  v21 = (char *)v37 + v15[3];
  v22 = v14;
  glpLogDeserialize(v14, (uint64_t)v21);
  free(v37);
  v37 = 0;
  if (v16)
  {
LABEL_11:
    handleResetPost((uint64_t)a1);
    a1[6] = (int32x2_t)v16;
  }
LABEL_12:
  result = v16 != 0;
  a1[3] = (int32x2_t)Log;
  a1[4] = (int32x2_t)v22;
  return result;
}

BOOL ShLink(uint64_t a1, uint64_t *a2, unsigned int a3, char *a4)
{
  int v4;
  int v5;
  uint64_t v10;
  int v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  char *v22;
  int v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  int v28;
  uint64_t v29;
  char *v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  int v34;
  uint64_t v35;
  char *v36;
  unsigned int v37;
  unsigned int v38;
  int v39;
  int v40;
  uint64_t v41;
  char *v42;
  unsigned int v43;
  unsigned int v44;
  int v45;
  int v46;
  uint64_t v47;
  char *v48;
  unsigned int v49;
  size_t v50;
  uint64_t v51;
  CC_LONG v52;
  char *v53;
  char *v54;
  _DWORD *v55;
  unsigned int v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int *v60;
  const void *CompiledShaderAST;
  size_t v62;
  uint64_t v63;
  size_t v64;
  int v65;
  __int128 v66;
  __int128 v67;
  unsigned int *v68;
  __int128 v69;
  _DWORD *v70;
  int v71;
  uint64_t Log;
  uint64_t v73;
  uint64_t *StringBuffer;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  _QWORD *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  _QWORD *Linker;
  uint64_t v101;
  uint64_t v102;
  int v103;
  _QWORD *v104;
  uint64_t v105;
  unsigned int i;
  uint64_t **PPStreamManager;
  uint64_t *v108;
  unsigned int j;
  uint64_t MergedAST;
  unint64_t v111;
  char *v112;
  void *v113;
  uint64_t v114;
  const void *String;
  int v116;
  int v117;
  uint64_t v118;
  uint64_t v119;
  int v120;
  const void *v121;
  int v122;
  unsigned int v123;
  int v124;
  size_t v125;
  uint64_t v126;
  uint64_t k;
  uint64_t v128;
  uint64_t ShaderBytesCode;
  _DWORD *v130;
  unsigned __int16 *Stream;
  int v132;
  int v133;
  int v134;
  _DWORD *v135;
  _DWORD *v136;
  int v137;
  _DWORD *v138;
  int v139;
  char *v140;
  _DWORD *v141;
  int v142;
  char *v143;
  _DWORD *v144;
  int v145;
  char *v146;
  char *v147;
  char *v148;
  int v149;
  _DWORD *v150;
  _DWORD *v151;
  uint64_t v152;
  uint64_t v153;
  __int128 v154;
  __int128 v155;
  char *v156;
  char *v157;
  void *v158;
  const void **v159;
  const void **v160;
  const void *v161;
  const void *v162;
  const void *v163;
  const void *v164;
  const void *v165;
  uint64_t v166;
  _DWORD *v167;
  uint64_t UniformHash;
  uint64_t BindableUniformHash;
  unint64_t v170;
  uint64_t v171;
  uint64_t v172;
  unint64_t v173;
  int v174;
  uint64_t v175;
  unsigned int v176;
  int Size;
  _DWORD *v178;
  size_t v179;
  void *v180;
  unint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  unsigned int v185;
  unsigned int v186;
  size_t v187;
  unsigned int *v188;
  unsigned int *v189;
  int *v190;
  int *v191;
  _BYTE *v192;
  _BYTE *v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  _BYTE *v197;
  int v198;
  unsigned int v199;
  int v200;
  __int128 *v201;
  int v202;
  int v203;
  const void *v204;
  const void *v205;
  uint64_t v206;
  uint64_t v207;
  void *v208;
  int *v209;
  char *v210;
  signed int v211;
  unsigned int *v212;
  int v213;
  uint64_t v214;
  _QWORD *v215;
  uint64_t v216;
  _DWORD *v217;
  __int128 v218;
  __int128 v219;
  void *__src[2];
  __int128 v221;
  uint64_t v222;
  _OWORD v223[2];
  _OWORD v224[2];
  __int128 v225;
  __int128 v226;
  size_t __n[2];
  __int128 v228;
  _QWORD v229[58];
  _OWORD v230[2];
  uint64_t v231;
  uint64_t v232;

  v232 = *MEMORY[0x24BDAC8D0];
  v4 = *(_DWORD *)a4;
  v5 = *((_DWORD *)a4 + 1);
  *(_DWORD *)(a1 + 8) = v5;
  *(_DWORD *)(a1 + 12) = v4;
  if (!v5)
    return 0;
  handleResetPre(a1);
  if (!linkerCache)
    dispatch_sync((dispatch_queue_t)gSerialQueue, &__block_literal_global_5);
  memset(v224, 0, sizeof(v224));
  v213 = a3;
  v210 = a4;
  if (a3)
  {
    v10 = a3;
    v11 = 208;
    v12 = a2;
    do
    {
      LODWORD(v225) = 0;
      v13 = *v12++;
      glpGetCompiledShaderAST(*(_QWORD *)(v13 + 48), &v225);
      v11 = ((v11 | 7) + v225) & 0xFFFFFFF8;
      --v10;
    }
    while (v10);
  }
  else
  {
    v11 = 208;
  }
  v218 = 0u;
  v219 = 0u;
  glpInitPoolAllocator(0x4000, 0x4000, &v218);
  v229[0] = 0;
  *(_OWORD *)__n = 0u;
  v228 = 0u;
  v225 = 0u;
  v226 = 0u;
  glpInitSerialContext(&v225, &v218);
  serialize_bindings(&v225, *(_QWORD *)(a1 + 104));
  serialize_bindings(&v225, *(_QWORD *)(a1 + 112));
  v15 = *(unsigned int *)(a1 + 124);
  v16 = (char)glp_serialized_integer32_control(v15);
  v17 = HIDWORD(__n[0]);
  v18 = __n[0];
  v19 = HIDWORD(__n[0]) + 1;
  if ((HIDWORD(__n[0]) + 1) <= LODWORD(__n[0]))
  {
    v22 = (char *)__n[1];
    v23 = HIDWORD(__n[0]);
  }
  else
  {
    if (SLODWORD(__n[0]) <= 1)
      v18 = 1;
    v20 = 2 * v18;
    if (v20 <= v19)
      v21 = v19;
    else
      v21 = v20;
    v22 = (char *)(*((uint64_t (**)(_QWORD, uint64_t, const char *))&v225 + 1))(v225, v21, "Vector Storage (uint8_t, growth)");
    memcpy(v22, (const void *)__n[1], HIDWORD(__n[0]));
    (*((void (**)(_QWORD, size_t))&v226 + 1))(v225, __n[1]);
    LODWORD(__n[0]) = v21;
    __n[1] = (size_t)v22;
    v23 = HIDWORD(__n[0]);
  }
  memmove(&v22[v17 + 1], &v22[v17], (v23 - v17));
  *(_BYTE *)(__n[1] + v17) = v16;
  v24 = HIDWORD(__n[0]);
  v25 = ++HIDWORD(__n[0]);
  if ((v16 & 0x80000000) != 0)
  {
    switch((v16 >> 1) & 7)
    {
      case 0u:
        v26 = v24 + 2;
        v27 = __n[0];
        if (v26 <= LODWORD(__n[0]))
        {
          v30 = (char *)__n[1];
          v31 = v25;
        }
        else
        {
          if (SLODWORD(__n[0]) <= 1)
            v27 = 1;
          v28 = 2 * v27;
          if (v28 <= (int)v26)
            v29 = v26;
          else
            v29 = v28;
          v30 = (char *)(*((uint64_t (**)(_QWORD, uint64_t, const char *))&v225 + 1))(v225, v29, "Vector Storage (uint8_t, growth)");
          memcpy(v30, (const void *)__n[1], HIDWORD(__n[0]));
          (*((void (**)(_QWORD, size_t))&v226 + 1))(v225, __n[1]);
          LODWORD(__n[0]) = v29;
          __n[1] = (size_t)v30;
          v31 = HIDWORD(__n[0]);
        }
        memmove(&v30[v25 + 1], &v30[v25], v31 - v25);
        *(_BYTE *)(__n[1] + v25) = v15;
        v25 = HIDWORD(__n[0]) + 1;
        goto LABEL_56;
      case 1u:
        v32 = v24 + 3;
        v33 = __n[0];
        if (v32 <= LODWORD(__n[0]))
        {
          v36 = (char *)__n[1];
          v37 = v25;
        }
        else
        {
          if (SLODWORD(__n[0]) <= 1)
            v33 = 1;
          v34 = 2 * v33;
          if (v34 <= (int)v32)
            v35 = v32;
          else
            v35 = v34;
          v36 = (char *)(*((uint64_t (**)(_QWORD, uint64_t, const char *))&v225 + 1))(v225, v35, "Vector Storage (uint8_t, growth)");
          memcpy(v36, (const void *)__n[1], HIDWORD(__n[0]));
          (*((void (**)(_QWORD, size_t))&v226 + 1))(v225, __n[1]);
          LODWORD(__n[0]) = v35;
          __n[1] = (size_t)v36;
          v37 = HIDWORD(__n[0]);
        }
        memmove(&v36[v25 + 1], &v36[v25], v37 - v25);
        *(_WORD *)(__n[1] + v25) = v15;
        v25 = HIDWORD(__n[0]) + 2;
        goto LABEL_56;
      case 2u:
        v38 = v24 + 4;
        v39 = __n[0];
        if (v38 <= LODWORD(__n[0]))
        {
          v42 = (char *)__n[1];
          v43 = v25;
        }
        else
        {
          if (SLODWORD(__n[0]) <= 1)
            v39 = 1;
          v40 = 2 * v39;
          if (v40 <= (int)v38)
            v41 = v38;
          else
            v41 = v40;
          v42 = (char *)(*((uint64_t (**)(_QWORD, uint64_t, const char *))&v225 + 1))(v225, v41, "Vector Storage (uint8_t, growth)");
          memcpy(v42, (const void *)__n[1], HIDWORD(__n[0]));
          (*((void (**)(_QWORD, size_t))&v226 + 1))(v225, __n[1]);
          LODWORD(__n[0]) = v41;
          __n[1] = (size_t)v42;
          v43 = HIDWORD(__n[0]);
        }
        memmove(&v42[v25 + 1], &v42[v25], v43 - v25);
        v50 = __n[1] + v25;
        *(_BYTE *)(v50 + 2) = BYTE2(v15);
        *(_WORD *)v50 = v15;
        v25 = HIDWORD(__n[0]) + 3;
        goto LABEL_56;
      case 3u:
        v44 = v24 + 5;
        v45 = __n[0];
        if (v44 <= LODWORD(__n[0]))
        {
          v48 = (char *)__n[1];
          v49 = v25;
        }
        else
        {
          if (SLODWORD(__n[0]) <= 1)
            v45 = 1;
          v46 = 2 * v45;
          if (v46 <= (int)v44)
            v47 = v44;
          else
            v47 = v46;
          v48 = (char *)(*((uint64_t (**)(_QWORD, uint64_t, const char *))&v225 + 1))(v225, v47, "Vector Storage (uint8_t, growth)");
          memcpy(v48, (const void *)__n[1], HIDWORD(__n[0]));
          (*((void (**)(_QWORD, size_t))&v226 + 1))(v225, __n[1]);
          LODWORD(__n[0]) = v47;
          __n[1] = (size_t)v48;
          v49 = HIDWORD(__n[0]);
        }
        memmove(&v48[v25 + 1], &v48[v25], v49 - v25);
        *(_DWORD *)(__n[1] + v25) = v15;
        v25 = HIDWORD(__n[0]) + 4;
LABEL_56:
        HIDWORD(__n[0]) = v25;
        break;
      default:
        break;
    }
  }
  if ((_DWORD)v15)
  {
    v51 = 0;
    do
    {
      serialize_GLPString(&v225, *(const char **)(*(_QWORD *)(a1 + 128) + v51), *(_QWORD *)(*(_QWORD *)(a1 + 128) + v51 + 8));
      v51 += 16;
    }
    while (16 * v15 != v51);
    v25 = HIDWORD(__n[0]);
  }
  v52 = v25 + v11;
  v53 = (char *)malloc_type_malloc(v25 + v11, 0x7081ABB9uLL);
  if (!v53)
    goto LABEL_154;
  v54 = v53;
  bzero(v53, v25 + v11);
  if (v213)
  {
    v55 = v54 + 140;
    v56 = 208;
    v57 = a2;
    v58 = v213;
    do
    {
      v59 = *v57++;
      v60 = *(unsigned int **)(v59 + 48);
      LODWORD(v230[0]) = 0;
      CompiledShaderAST = (const void *)glpGetCompiledShaderAST((uint64_t)v60, v230);
      *(v55 - 3) = glpGetCompiledShaderLanguage(v60);
      *(v55 - 2) = glpGetCompiledShaderVersion((uint64_t)v60);
      *(v55 - 1) = v56;
      v62 = LODWORD(v230[0]);
      *v55 = v230[0];
      v55 += 4;
      memcpy(&v54[v56], CompiledShaderAST, v62);
      v63 = v62 + v56;
      v56 = (v63 + 7) & 0xFFFFFFF8;
      bzero(&v54[v63], v56 - v63);
      --v58;
    }
    while (v58);
  }
  else
  {
    v56 = 208;
  }
  v64 = HIDWORD(__n[0]);
  *((_DWORD *)v54 + 28) = v56;
  *((_DWORD *)v54 + 29) = v64;
  memcpy(&v54[v56], (const void *)__n[1], v64);
  glpDestroySerialContext((uint64_t)&v225, 1);
  glpDestroyPoolAllocator((uint64_t)&v218);
  *(_QWORD *)v54 = *(_QWORD *)v210;
  *((_DWORD *)v54 + 2) = *((_DWORD *)v210 + 2);
  *((_DWORD *)v54 + 3) = *(_DWORD *)(a1 + 16);
  v65 = *(_DWORD *)(a1 + 20);
  *((_DWORD *)v54 + 4) = v65;
  *(_QWORD *)(v54 + 20) = *(_QWORD *)(v210 + 20);
  *((_DWORD *)v54 + 7) = *((_DWORD *)v210 + 7);
  v66 = *((_OWORD *)v210 + 2);
  v67 = *((_OWORD *)v210 + 4);
  *((_OWORD *)v54 + 3) = *((_OWORD *)v210 + 3);
  *((_OWORD *)v54 + 4) = v67;
  *((_OWORD *)v54 + 2) = v66;
  v68 = &glpBuiltInConstantValues[8 * (v65 == 4)];
  v69 = *((_OWORD *)v68 + 1);
  *((_OWORD *)v54 + 5) = *(_OWORD *)v68;
  *((_OWORD *)v54 + 6) = v69;
  *((_DWORD *)v54 + 30) = v213;
  glpCacheGenerateHash(v54, v52, (unsigned __int8 *)v224);
  free(v54);
  v216 = 0;
  v217 = 0;
  if (glpCacheGetElement(linkerCache, (uint64_t)v224, (uint64_t)&v217, (uint64_t)&v216))
  {
    v70 = v217;
    v71 = v217[12];
    Log = glpMakeLog(&GLP_MALLOC_ALLOCATOR);
    v73 = glpMakeLog(&GLP_MALLOC_ALLOCATOR);
    glpLogSetContainsErrors(Log, v70[16]);
    StringBuffer = (uint64_t *)glpLogGetStringBuffer(Log);
    glpStringBufferAppendFormat(StringBuffer, "%.*s", v75, v76, v77, v78, v79, v80, v70[18]);
    glpLogSetContainsErrors(v73, v70[19]);
    v81 = (uint64_t *)glpLogGetStringBuffer(v73);
    glpStringBufferAppendFormat(v81, "%.*s", v82, v83, v84, v85, v86, v87, v70[21]);
    if (v71)
    {
      v88 = v70[15];
      v89 = (uint64_t)v70 + (int)v70[14];
      handleResetPost(a1);
      v90 = glpLinkProgramFromLinkerOutput(v89, v88, v70);
    }
    else
    {
      v90 = 0;
    }
    *(_QWORD *)(a1 + 48) = v90;
    *(_QWORD *)(a1 + 24) = Log;
    *(_QWORD *)(a1 + 32) = v73;
    v113 = v217;
  }
  else
  {
    v91 = (uint64_t)(v210 + 32);
    v208 = (void *)glpMakeLog(&GLP_MALLOC_ALLOCATOR);
    v92 = glpMakeLog(&GLP_MALLOC_ALLOCATOR);
    Linker = glpMakeLinker(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20), *((_DWORD *)v210 + 5), *((_DWORD *)v210 + 6), *((_DWORD *)v210 + 7), (uint64_t)v208, v92, *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 112), a1 + 120, (__int128 *)v210 + 2, 0, (uint64_t)&glpBuiltInConstantValues[8 * (v210[16] == 4)]);
    if (v213 >= 1)
    {
      v101 = v213;
      do
      {
        v102 = *a2++;
        glpLinkerAddShader(Linker, *(unsigned int **)(v102 + 48));
        --v101;
      }
      while (v101);
    }
    v103 = *(_DWORD *)v210;
    v104 = glpLinkProgram(Linker, v93, v94, v95, v96, v97, v98, v99);
    v214 = (uint64_t)v104;
    if (v104)
    {
      v105 = (uint64_t)v104;
      handleResetPost(a1);
      *(_QWORD *)(a1 + 48) = v105;
      glpLinkedProgramGetOverrides(v105, v91);
      if (*(_DWORD *)(a1 + 8) >= 4u)
      {
        for (i = 0; i != 5; ++i)
        {
          PPStreamManager = (uint64_t **)glpLinkedProgramGetPPStreamManager(*(_QWORD *)(a1 + 48), i);
          if (PPStreamManager)
            glpPPShaderLinearizeStreamMgr(PPStreamManager, 25291);
        }
      }
      *(_QWORD *)(a1 + 24) = v208;
      *(_QWORD *)(a1 + 32) = v92;
      if ((v103 & 1) != 0)
      {
        v108 = (uint64_t *)glpLogGetStringBuffer(v92);
        glpStringBufferAppendCString(v108, "\nMerged ASTs\n========================\n");
        for (j = 0; j != 5; ++j)
        {
          MergedAST = glpLinkerGetMergedAST((uint64_t)Linker, j);
          if (MergedAST)
          {
            v111 = MergedAST;
            glpStringBufferAppendCString(v108, "\nMerged AST for ");
            v112 = glpLanguageToString(j);
            glpStringBufferAppendCString(v108, v112);
            glpStringBufferAppendCString(v108, " shader\n");
            glpDumpASTNodeToStringBuffer(v108, v111);
          }
        }
      }
    }
    else
    {
      *(_QWORD *)(a1 + 24) = v208;
      *(_QWORD *)(a1 + 32) = v92;
    }
    glpDestroyLinker(Linker);
    v114 = glpLogGetStringBuffer((uint64_t)v208);
    String = (const void *)glpStringBufferGetString(v114);
    v117 = v116;
    v118 = glpLogGetStringBuffer(v92);
    v119 = glpStringBufferGetString(v118);
    v121 = (const void *)v119;
    v122 = v120;
    v123 = v117 + 608;
    if ((v117 & 7) != 0)
      v123 = (v117 & 0xFFFFFFF8) + 616;
    v211 = v123;
    v124 = v120 + v123 + 7;
    v125 = v124 & 0xFFFFFFF8;
    v90 = (_QWORD *)v214;
    if (v214)
    {
      v201 = (__int128 *)v91;
      v202 = v120;
      v203 = v117;
      v204 = (const void *)v119;
      v205 = String;
      v206 = v92;
      v231 = 0;
      memset(v230, 0, sizeof(v230));
      bzero(&v225, 0x208uLL);
      v126 = 0;
      for (k = 0; k != 5; ++k)
      {
        v128 = glpLinkedProgramGetPPStreamManager(v214, k);
        ShaderBytesCode = glpLinkedProgramGetShaderBytesCode(v214, k);
        v130 = (_DWORD *)((char *)&v225 + v126);
        *(_DWORD *)((char *)&v225 + v126 + 4) = k;
        if (v128)
        {
          LODWORD(v218) = 0;
          Stream = PPStreamGetStream(v128, &v218);
          v132 = v218;
          v133 = 8 * v218;
          v130[2] = v125;
          v130[3] = v133;
          *v130 = 1;
          LODWORD(v125) = v125 + 8 * v132;
        }
        else
        {
          Stream = 0;
        }
        *((_QWORD *)v230 + k) = Stream;
        if (ShaderBytesCode && *(_QWORD *)ShaderBytesCode)
        {
          v134 = **(_DWORD **)ShaderBytesCode + 4;
          v135 = (_DWORD *)((char *)&v225 + v126);
          v135[4] = v125;
          v135[5] = v134;
          *v135 = 1;
          LODWORD(v125) = v134 + v125;
          v136 = *(_DWORD **)(ShaderBytesCode + 8);
          if (v136)
          {
            v137 = 8 * *v136 + 8;
            v135[8] = v125;
            v135[9] = v137;
            LODWORD(v125) = v137 + v125;
          }
          v138 = *(_DWORD **)(ShaderBytesCode + 40);
          if (v138)
          {
            v139 = *v138 + 4;
            v140 = (char *)&v225 + v126;
            *((_DWORD *)v140 + 6) = v125;
            *((_DWORD *)v140 + 7) = v139;
            LODWORD(v125) = v139 + v125;
          }
          v141 = *(_DWORD **)(ShaderBytesCode + 16);
          if (v141)
          {
            v142 = 4 * *v141 + 4;
            v143 = (char *)&v225 + v126;
            *((_DWORD *)v143 + 10) = v125;
            *((_DWORD *)v143 + 11) = v142;
            LODWORD(v125) = v142 + v125;
          }
          v144 = *(_DWORD **)(ShaderBytesCode + 24);
          if (v144)
          {
            v145 = 4 * *v144 + 4;
            v146 = (char *)&v225 + v126;
            *((_DWORD *)v146 + 12) = v125;
            *((_DWORD *)v146 + 13) = v145;
            LODWORD(v125) = v145 + v125;
          }
          if (*(_QWORD *)(ShaderBytesCode + 32))
          {
            v147 = (char *)&v225 + v126;
            *((_DWORD *)v147 + 14) = v125;
            *((_DWORD *)v147 + 15) = 0;
          }
          v148 = (char *)&v225 + v126;
          *(_OWORD *)(v148 + 88) = *(_OWORD *)(ShaderBytesCode + 72);
          *((_QWORD *)v148 + 8) = *(_QWORD *)(ShaderBytesCode + 48);
          *(_OWORD *)(v148 + 72) = *(_OWORD *)(ShaderBytesCode + 56);
        }
        v126 += 104;
      }
      memset(v223, 0, sizeof(v223));
      glpInitPoolAllocator(0x4000, 0x4000, v223);
      v222 = 0;
      *(_OWORD *)__src = 0u;
      v221 = 0u;
      v218 = 0u;
      v219 = 0u;
      glpInitSerialContext(&v218, v223);
      glpSerializeLinkedProgram(&v218, v214);
      v149 = HIDWORD(__src[0]);
      v200 = (v125 + 7) & 0xFFFFFFF8;
      if ((BYTE4(__src[0]) & 7) != 0)
        v125 = ((HIDWORD(__src[0]) + v200) & 0xFFFFFFF8) + 8;
      else
        v125 = (HIDWORD(__src[0]) + v200);
      v150 = malloc_type_malloc(v125, 0x7081ABB9uLL);
      if (!v150)
        goto LABEL_154;
      v151 = v150;
      v152 = 0;
      v153 = 0;
      v154 = *v201;
      v155 = v201[2];
      *((_OWORD *)v150 + 1) = v201[1];
      *((_OWORD *)v150 + 2) = v155;
      *(_OWORD *)v150 = v154;
      *((_QWORD *)v150 + 6) = 0x500000001;
      v156 = (char *)(v150 + 22);
      do
      {
        v157 = &v156[v152 * 8];
        *((_OWORD *)v157 + 3) = *(_OWORD *)&v229[v152 - 2];
        *((_OWORD *)v157 + 4) = *(_OWORD *)&v229[v152];
        *((_OWORD *)v157 + 5) = *(_OWORD *)&v229[v152 + 2];
        *((_QWORD *)v157 + 12) = v229[v152 + 4];
        *(_OWORD *)v157 = *(__int128 *)((char *)&v225 + v152 * 8);
        *((_OWORD *)v157 + 1) = *(__int128 *)((char *)&v225 + v152 * 8 + 16);
        *((_OWORD *)v157 + 2) = *(_OWORD *)&__n[v152];
        v158 = (void *)*((_QWORD *)v230 + v153);
        if (v158)
        {
          memcpy((char *)v151 + *(unsigned int *)((char *)&v225 + v152 * 8 + 8), *((const void **)v230 + v153), *(int *)((char *)&v225 + v152 * 8 + 12));
          free(v158);
          *((_QWORD *)v230 + v153) = 0;
        }
        v159 = (const void **)glpLinkedProgramGetShaderBytesCode(v214, v153);
        if (v159)
        {
          v160 = v159;
          if (*v159)
          {
            memcpy((char *)v151 + *(unsigned int *)((char *)&v225 + v152 * 8 + 16), *v159, *(int *)((char *)&v226 + v152 * 8 + 4));
            v161 = v160[1];
            if (v161)
              memcpy((char *)v151 + LODWORD(__n[v152]), v161, SHIDWORD(__n[v152]));
            v162 = v160[5];
            if (v162)
              memcpy((char *)v151 + LODWORD(__n[v152 - 1]), v162, *(unsigned int *)((char *)&v226 + v152 * 8 + 12));
            v163 = v160[2];
            if (v163)
              memcpy((char *)v151 + LODWORD(__n[v152 + 1]), v163, SHIDWORD(__n[v152 + 1]));
            v164 = v160[3];
            if (v164)
              memcpy((char *)v151 + LODWORD(v229[v152 - 2]), v164, *(int *)((char *)&v228 + v152 * 8 + 4));
            v165 = v160[4];
            if (v165)
              memcpy((char *)v151 + LODWORD(v229[v152 - 1]), v165, *(int *)((char *)&v228 + v152 * 8 + 12));
          }
        }
        ++v153;
        v152 += 13;
      }
      while (v152 != 65);
      v151[14] = v200;
      v151[15] = v149;
      memcpy((char *)v151 + v200, __src[1], v149);
      glpDestroySerialContext((uint64_t)&v218, 1);
      glpDestroyPoolAllocator((uint64_t)v223);
      v90 = (_QWORD *)v214;
      String = v205;
      v166 = v206;
      v117 = v203;
      v121 = v204;
      v122 = v202;
    }
    else
    {
      v167 = malloc_type_malloc(v124 & 0xFFFFFFF8, 0x7081ABB9uLL);
      if (!v167)
        goto LABEL_154;
      v151 = v167;
      v167[12] = 0;
      *((_QWORD *)v167 + 7) = 0;
      v166 = v92;
    }
    v151[17] = 608;
    v151[18] = v117;
    v151[16] = glpLogContainsErrors((uint64_t)v208);
    v151[20] = v211;
    v151[21] = v122;
    v151[19] = glpLogContainsErrors(v166);
    memcpy(v151 + 152, String, v117);
    memcpy((char *)v151 + v211, v121, v122);
    glpCacheAddElement(linkerCache, (uint64_t)v224, (uint64_t)v151, v125);
    v113 = v151;
  }
  free(v113);
  v215 = v90;
  if (v90)
  {
    *(_DWORD *)(a1 + 64) = glpLinkedProgramGetDefaultUniformLocationCount(*(_QWORD *)(a1 + 48));
    UniformHash = glpLinkedProgramGetUniformHash(*(_QWORD *)(a1 + 48));
    BindableUniformHash = glpLinkedProgramGetBindableUniformHash(*(_QWORD *)(a1 + 48));
    v170 = *(unsigned int *)(BindableUniformHash + 32);
    if ((_DWORD)v170)
    {
      v171 = BindableUniformHash;
      v172 = 0;
      v173 = 0;
      v174 = 0;
      do
      {
        v175 = *(_QWORD *)(*(_QWORD *)(v171 + 40) + v172);
        if (v175)
        {
          v176 = glpABIGetTypeSize(0, *(_QWORD *)(v175 + 24), 0);
          Size = glpTypeSizeGetSize(v176);
          *(_DWORD *)(a1 + 68) += Size;
          v178 = malloc_type_realloc(*(void **)(a1 + 96), 4 * (v174 + 1), 0x2BDC8648uLL);
          if (!v178)
            goto LABEL_154;
          *(_QWORD *)(a1 + 96) = v178;
          v178[v174] = Size;
          v170 = *(unsigned int *)(v171 + 32);
          ++v174;
        }
        ++v173;
        v172 += 32;
      }
      while (v173 < v170);
    }
    v179 = *(int *)(a1 + 64);
    *(_DWORD *)(a1 + 80) = v179;
    v180 = malloc_type_calloc(v179, 8uLL, 0xA92C9FCEuLL);
    if (v180)
    {
      *(_QWORD *)(a1 + 72) = v180;
      v181 = *(unsigned int *)(UniformHash + 32);
      if ((_DWORD)v181)
      {
        v182 = 0;
        v207 = UniformHash;
        while (1)
        {
          v183 = *(_QWORD *)(*(_QWORD *)(UniformHash + 40) + 32 * v182);
          if (v183)
          {
            v184 = *(int *)(v183 + 4);
            if ((_DWORD)v184 != -1)
            {
              v185 = glpABIGetTypeSize(0, *(_QWORD *)(v183 + 24), 0);
              v186 = glpTypeSizeGetSize(v185);
              v187 = 4 * v186;
              v188 = (unsigned int *)malloc_type_malloc(v187, 0x7081ABB9uLL);
              if (!v188)
                goto LABEL_154;
              v189 = v188;
              v190 = (int *)malloc_type_malloc(v187, 0x7081ABB9uLL);
              if (!v190)
                goto LABEL_154;
              v191 = v190;
              v192 = malloc_type_malloc(v186, 0x7081ABB9uLL);
              if (!v192)
                goto LABEL_154;
              v193 = v192;
              v209 = v191;
              v212 = v189;
              glpTypeGetAppleVec4Types(*(unsigned int **)(v183 + 24), v189, 1, v191, 0, v192, 0, 0, 1);
              if (v186)
              {
                v194 = 0;
                v195 = 8 * v184;
                v196 = 8 * v186;
                v197 = v193;
                do
                {
                  v198 = *v191++;
                  *(_DWORD *)(*(_QWORD *)(a1 + 72) + v195 + v194) = v198;
                  v199 = *v189++;
                  *(_WORD *)(*(_QWORD *)(a1 + 72) + v195 + v194 + 4) = glpPrimitiveTypeGetGLType(v199);
                  *(_BYTE *)(*(_QWORD *)(a1 + 72) + v195 + v194 + 6) = *(_DWORD *)v183;
                  *(_BYTE *)(*(_QWORD *)(a1 + 72) + v195 + v194 + 7) = *(_BYTE *)(*(_QWORD *)(a1 + 72) + v195 + v194 + 7) & 0xFE | *v197 & 1;
                  *(_BYTE *)(*(_QWORD *)(a1 + 72) + v195 + v194 + 7) = *(_BYTE *)(*(_QWORD *)(a1 + 72) + v195 + v194 + 7) & 0xFD | *v197 & 2;
                  LOBYTE(v199) = *v197++;
                  *(_BYTE *)(*(_QWORD *)(a1 + 72) + v195 + v194 + 7) = *(_BYTE *)(*(_QWORD *)(a1 + 72) + v195 + v194 + 7) & 0xFB | v199 & 4;
                  v194 += 8;
                }
                while (v196 != v194);
              }
              free(v212);
              free(v209);
              free(v193);
              UniformHash = v207;
              v181 = *(unsigned int *)(v207 + 32);
            }
          }
          if (++v182 >= v181)
            return v215 != 0;
        }
      }
      return v215 != 0;
    }
LABEL_154:
    abort();
  }
  return v215 != 0;
}

void ShCleanup(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 48);
  if (v1)
    glpCleanUpLinkedProgram(v1);
}

uint64_t ShGetInfoLog(uint64_t a1)
{
  char *String;
  char *v3;
  char *v4;
  _QWORD **v5;
  uint64_t *StringBuffer;

  String = (char *)glpLogGetString(*(_QWORD *)(a1 + 24));
  v3 = (char *)glpLogGetString(*(_QWORD *)(a1 + 32));
  if (!*v3)
    return (uint64_t)String;
  v4 = v3;
  v5 = *(_QWORD ***)(a1 + 40);
  if (v5)
    glpDestroyStringBuffer(v5);
  StringBuffer = glpMakeStringBuffer(&GLP_MALLOC_ALLOCATOR);
  *(_QWORD *)(a1 + 40) = StringBuffer;
  glpStringBufferAppendCString(StringBuffer, String);
  glpStringBufferAppendCString(*(uint64_t **)(a1 + 40), v4);
  return glpStringBufferGetCString(*(uint64_t **)(a1 + 40));
}

uint64_t ShAttributeBindingRequest(uint64_t a1, int a2, char *__s1)
{
  uint64_t result;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  unsigned int v12;
  char *v13;
  const char *v14;
  unsigned int v15;
  double v16;
  unsigned int v17;

  result = strncmp(__s1, "gl_", 3uLL);
  if ((_DWORD)result)
  {
    v7 = strlen(__s1);
    if (v7 >> 5 >= v7)
    {
      v9 = v7;
    }
    else
    {
      v8 = v7;
      v9 = v7;
      do
      {
        v9 ^= 32 * v9 + (v9 >> 2) + __s1[v8 - 1];
        v8 += ~(v7 >> 5);
      }
      while (v8 > v7 >> 5);
    }
    result = glpStringHashGet(*(_QWORD *)(a1 + 104), __s1, v7 | ((unint64_t)v9 << 32));
    if (result)
    {
      *(_DWORD *)result = a2;
    }
    else
    {
      v10 = malloc_type_malloc(0x10uLL, 0x7081ABB9uLL);
      if (!v10
        || (v11 = (uint64_t)v10,
            *v10 = a2,
            v10[1] = 0,
            *((_QWORD *)v10 + 1) = 0,
            v12 = strlen(__s1),
            (v13 = (char *)malloc_type_malloc((int)v12, 0x7081ABB9uLL)) == 0))
      {
        abort();
      }
      v14 = v13;
      v15 = v12;
      memcpy(v13, __s1, (int)v12);
      if (v12 >> 5 >= v12)
      {
        v17 = v12;
      }
      else
      {
        v17 = v12;
        do
        {
          v17 ^= 32 * v17 + (v17 >> 2) + v14[v15 - 1];
          v15 += ~(v12 >> 5);
        }
        while (v15 > v12 >> 5);
      }
      return glpStringHashPut(*(_QWORD *)(a1 + 104), v14, v12 | ((unint64_t)v17 << 32), v11, v16);
    }
  }
  return result;
}

uint64_t ShGetNumActiveAttributes(uint64_t a1)
{
  uint64_t result;
  uint64_t AttribHash;
  _OWORD v3[4];
  __int128 v4;
  uint64_t v5;
  unsigned int *v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  unsigned int v15;

  v15 = 0;
  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    AttribHash = glpLinkedProgramGetAttribHash(result);
    v4 = 0u;
    v5 = 0;
    v12 = 0u;
    v13 = 0u;
    v10 = 0u;
    v11 = 0u;
    memset(v3, 0, sizeof(v3));
    v7 = 0u;
    DWORD2(v4) = -1;
    v8 = 0;
    v9 = 0xFFFFFFFFLL;
    v14 = 0;
    v6 = &v15;
    getBindingInfo(AttribHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPBinding, (uint64_t)v3);
    return v15;
  }
  return result;
}

uint64_t getBindingInfo(uint64_t a1, uint64_t (*a2)(uint64_t result, unsigned int *a2, unsigned int *a3, unsigned int **a4, uint64_t *a5, unsigned __int8 *a6), uint64_t a3)
{
  _DWORD *v6;
  _DWORD *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _BOOL4 v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  size_t v16;
  void *v17;
  uint64_t v18;
  int v19;
  _DWORD *v20;
  _DWORD *v21;
  _DWORD *v22;
  _DWORD *v23;
  _DWORD *v24;
  unsigned __int8 v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  uint64_t v32;
  void *ptr;
  int v34[2];

  ptr = 0;
  *(_QWORD *)v34 = 0;
  v32 = 0;
  v31 = 0;
  v6 = *(_DWORD **)(a3 + 8);
  if (v6)
    *v6 = 0;
  v7 = *(_DWORD **)(a3 + 104);
  if (v7)
    *v7 = 0;
  v8 = *(unsigned int *)(a1 + 32);
  if (!(_DWORD)v8)
  {
LABEL_28:
    v18 = 0;
    goto LABEL_38;
  }
  v9 = 0;
  v10 = 0;
  v12 = (char *)a2 == (char *)typeFromGLPUniformBlockBinding || (char *)a2 == (char *)typeFromGLPUniformBinding;
  while (1)
  {
    v13 = *(_QWORD *)(a1 + 40);
    v14 = *(_QWORD *)(v13 + v9);
    if (v14)
      break;
LABEL_27:
    ++v10;
    v9 += 32;
    if (v10 >= v8)
      goto LABEL_28;
  }
  v15 = *(const void **)(v13 + v9 + 8);
  v16 = *(unsigned int *)(v13 + v9 + 16);
  v29 = 0;
  v30 = 0;
  v27 = 0;
  v28 = 0;
  v26 = 0;
  a2(v14, &v30, &v29, &v28, &v27, &v26);
  v34[0] = 0;
  if (v26)
  {
    if (!v12)
      goto LABEL_25;
    goto LABEL_22;
  }
  if (*(_QWORD *)(a3 + 48) && *(_DWORD *)(a3 + 16) || *(_QWORD *)(a3 + 56))
  {
    v17 = malloc_type_realloc(ptr, v16, 0x2BDC8648uLL);
    if (!v17)
      abort();
    ptr = v17;
    memcpy(v17, v15, v16);
  }
  v34[0] = v16;
  if (v12)
  {
LABEL_22:
    if (*(_DWORD *)(v14 + 4) == -1 && *(_DWORD *)(v14 + 8) != -1)
      v31 = *(_DWORD *)(v14 + 8);
  }
LABEL_25:
  if (!getBindingInfoForType(1, v26, v30, 0, (uint64_t)&ptr, v29, v28, 0, (_DWORD *)&v32 + 1, &v32, &v31, 0, a3))
  {
    v8 = *(unsigned int *)(a1 + 32);
    goto LABEL_27;
  }
  if (*(_QWORD *)a3)
    **(_QWORD **)a3 = v14;
  v19 = v34[0];
  getString(ptr, v34[0], *(_DWORD *)(a3 + 16), *(_DWORD **)(a3 + 24), *(void **)(a3 + 48));
  v20 = *(_DWORD **)(a3 + 64);
  if (v20)
    *v20 = v19 + 1;
  v21 = *(_DWORD **)(a3 + 80);
  if (v21)
    *v21 = HIDWORD(v32);
  v22 = *(_DWORD **)(a3 + 128);
  if (v22)
    *v22 = v31;
  v18 = 1;
LABEL_38:
  free(ptr);
  v23 = *(_DWORD **)(a3 + 88);
  if (v23)
    *v23 = HIDWORD(v32);
  v24 = *(_DWORD **)(a3 + 136);
  if (v24)
    *v24 = v32;
  return v18;
}

uint64_t typeFromGLPBinding(uint64_t result, _DWORD *a2, _DWORD *a3, _QWORD *a4, _QWORD *a5, _BYTE *a6)
{
  *a2 = 0;
  *a3 = 0;
  *a4 = *(_QWORD *)(result + 8);
  *a5 = 0;
  *a6 = 0;
  return result;
}

uint64_t ShGetActiveNonbindableUniformsSize(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 48))
    return *(unsigned int *)(a1 + 64);
  else
    return 0;
}

uint64_t ShGetNumBindableUniformBuffers(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 48);
  if (result)
    return *(unsigned int *)(glpLinkedProgramGetBindableUniformHash(result) + 36);
  return result;
}

uint64_t ShGetActiveBindableUniformBufferSizeTable(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 48))
    return *(_QWORD *)(a1 + 96);
  else
    return 0;
}

uint64_t ShGetActiveBindableUniformBufferIndexOffsetFromLocation(uint64_t a1, signed int a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t result;

  if (!*(_QWORD *)(a1 + 48))
    return 0;
  result = getBindableUniformLocationInfo(a1, a2);
  if (result)
  {
    if (a3)
      *a3 = *(_DWORD *)result;
    if (a4)
      *a4 = *(_DWORD *)(result + 4);
    return 1;
  }
  return result;
}

uint64_t getBindableUniformLocationInfo(uint64_t a1, signed int a2)
{
  uint64_t IntHash;
  uint64_t v5;
  uint64_t BindableUniformHash;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int Size;
  signed int v14;
  void *v16;
  double v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  uint64_t v23;
  char *v24;
  int v25;
  _QWORD v27[2];

  v27[1] = *MEMORY[0x24BDAC8D0];
  IntHash = *(_QWORD *)(a1 + 88);
  if (!IntHash)
  {
    IntHash = glpMakeIntHash(&GLP_MALLOC_ALLOCATOR);
    *(_QWORD *)(a1 + 88) = IntHash;
  }
  v5 = glpIntHashGet(IntHash, a2);
  if (!v5)
  {
    BindableUniformHash = glpLinkedProgramGetBindableUniformHash(*(_QWORD *)(a1 + 48));
    v7 = *(unsigned int *)(BindableUniformHash + 32);
    if (!(_DWORD)v7)
      return 0;
    v8 = BindableUniformHash;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *(_QWORD *)(*(_QWORD *)(v8 + 40) + v9);
      if (v11)
      {
        v12 = glpABIGetTypeSize(0, *(_QWORD *)(v11 + 24), 0);
        Size = glpTypeSizeGetSize(v12);
        v14 = *(_DWORD *)(v11 + 4);
        if (v14 <= a2 && v14 + Size > a2)
        {
          v16 = malloc_type_malloc(0x18uLL, 0x7081ABB9uLL);
          if (!v16)
            abort();
          v5 = (uint64_t)v16;
          v18 = glpIntHashPut(*(_QWORD *)(a1 + 88), a2, (uint64_t)v16, v17);
          v19 = a2 - *(_DWORD *)(v11 + 4);
          *(_DWORD *)v5 = *(_DWORD *)(v11 + 8);
          *(_DWORD *)(v5 + 4) = v19;
          v20 = MEMORY[0x24BDAC7A8](v18);
          v22 = (_DWORD *)((char *)v27 - ((v21 + 15) & 0x7FFFFFFF0));
          MEMORY[0x24BDAC7A8](v20);
          v24 = (char *)v27 - v23;
          glpTypeGetAppleVec4Types(*(unsigned int **)(v11 + 24), v22, 1, (_QWORD *)((char *)v27 - v23), 0, 0, 0, 0, 1);
          v25 = a2 - *(_DWORD *)(v11 + 4);
          *(_DWORD *)(v5 + 8) = *(_DWORD *)&v24[4 * v25];
          *(_DWORD *)(v5 + 12) = glpPrimitiveTypeGetGLType(v22[v25]);
          *(_BYTE *)(v5 + 16) = *(_DWORD *)v11;
          return v5;
        }
        v7 = *(unsigned int *)(v8 + 32);
      }
      ++v10;
      v9 += 32;
      if (v10 >= v7)
        return 0;
    }
  }
  return v5;
}

uint64_t ShGetBindableUniformTypeInfo(uint64_t a1, signed int a2, _DWORD *a3, _DWORD *a4, _BYTE *a5)
{
  uint64_t result;

  if (!*(_QWORD *)(a1 + 48))
    return 0;
  result = getBindableUniformLocationInfo(a1, a2);
  if (result)
  {
    if (a3)
      *a3 = *(_DWORD *)(result + 8);
    if (a4)
      *a4 = *(_DWORD *)(result + 12);
    if (a5)
      *a5 = *(_BYTE *)(result + 16);
    return 1;
  }
  return result;
}

uint64_t ShGetUniformPartitionInfo()
{
  return 0;
}

uint64_t ShGetMaxAttributeLength(uint64_t a1)
{
  uint64_t result;
  uint64_t AttribHash;
  _QWORD v3[2];
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  unsigned int v17;

  v17 = 0;
  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    AttribHash = glpLinkedProgramGetAttribHash(result);
    v14 = 0u;
    v15 = 0u;
    v12 = 0u;
    v13 = 0u;
    v9 = 0u;
    v5 = 0u;
    v6 = 0u;
    v3[0] = 0;
    v4 = 0u;
    v7 = 0u;
    v8 = 0u;
    DWORD2(v7) = -1;
    v10 = 0;
    v11 = 0xFFFFFFFFLL;
    v16 = 0;
    v3[1] = &v17;
    getBindingInfo(AttribHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPBinding, (uint64_t)v3);
    return v17;
  }
  return result;
}

uint64_t ShGetActiveAttrib(uint64_t a1, int a2, int a3, _DWORD *a4, int *a5, _DWORD *a6, void *a7)
{
  uint64_t result;
  uint64_t AttribHash;
  uint64_t v15;
  int *i;
  uint64_t v17;
  int v18;
  const void *v19;
  int Kind;
  int ElementCount;
  uint64_t ElementType;
  unsigned int PrimitiveType;

  result = *(_QWORD *)(a1 + 48);
  if (!result)
    return result;
  AttribHash = glpLinkedProgramGetAttribHash(result);
  v15 = *(unsigned int *)(AttribHash + 32);
  if (!(_DWORD)v15)
    return 0;
  for (i = (int *)(*(_QWORD *)(AttribHash + 40) + 16); ; i += 8)
  {
    v17 = *((_QWORD *)i - 2);
    if (v17)
      break;
LABEL_7:
    if (!--v15)
      return 0;
  }
  if (a2)
  {
    --a2;
    goto LABEL_7;
  }
  v18 = *i;
  v19 = (const void *)*((_QWORD *)i - 1);
  Kind = glpTypeGetKind(*(unsigned int **)(v17 + 8));
  getString(v19, v18, a3, a4, a7);
  if (a5)
  {
    if (Kind == 2)
      ElementCount = glpArrayTypeGetElementCount(*(_QWORD *)(v17 + 8));
    else
      ElementCount = 1;
    *a5 = ElementCount;
  }
  if (a6)
  {
    ElementType = *(_QWORD *)(v17 + 8);
    if (Kind == 2)
      ElementType = glpArrayTypeGetElementType(ElementType);
    PrimitiveType = glpPrimitiveTypeGetPrimitiveType(ElementType);
    *a6 = glpPrimitiveTypeGetGLType(PrimitiveType);
  }
  return 1;
}

const void *getString(const void *__src, int a2, int a3, _DWORD *a4, void *__dst)
{
  int v9;
  int v10;

  if (!a3)
  {
    if (!a4)
      return __src;
    __src = 0;
    goto LABEL_11;
  }
  if (a3 >= a2)
    v9 = a2;
  else
    v9 = a3;
  __src = memcpy(__dst, __src, v9);
  v10 = a3 - 1;
  if (a3 - 1 >= a2)
    v10 = a2;
  *((_BYTE *)__dst + v10) = 0;
  if (a4)
  {
    __src = (const void *)strlen((const char *)__dst);
LABEL_11:
    *a4 = (_DWORD)__src;
  }
  return __src;
}

uint64_t ShGetAttribLocation(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t AttribHash;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int *v9;

  v2 = *(_QWORD *)(a1 + 48);
  v3 = 0xFFFFFFFFLL;
  if (v2)
  {
    AttribHash = glpLinkedProgramGetAttribHash(v2);
    v6 = strlen(a2);
    if (v6 >> 5 >= v6)
    {
      v8 = v6;
    }
    else
    {
      v7 = v6;
      v8 = v6;
      do
      {
        v8 ^= 32 * v8 + (v8 >> 2) + a2[v7 - 1];
        v7 += ~(v6 >> 5);
      }
      while (v7 > v6 >> 5);
    }
    v9 = (unsigned int *)glpStringHashGet(AttribHash, a2, v6 | ((unint64_t)v8 << 32));
    if (v9)
      return *v9;
    else
      return 0xFFFFFFFFLL;
  }
  return v3;
}

uint64_t ShGetContextStateUniforms(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 48);
  if (result)
    return glpLinkedProgramGetContextStateUniforms(result);
  return result;
}

uint64_t ShGetUniformLocation(uint64_t a1, const char *a2, _BYTE *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t UniformHash;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t BindableUniformHash;
  int Kind;
  unsigned int *ElementType;
  uint64_t v18;
  unsigned int *v19;
  const char *v20;
  uint64_t v21;

  v4 = *(_QWORD *)(a1 + 48);
  v5 = 0xFFFFFFFFLL;
  if (v4)
  {
    UniformHash = glpLinkedProgramGetUniformHash(v4);
    v9 = strlen(a2);
    if (v9 >> 5 < v9)
    {
      v10 = v9;
      v11 = v9;
      do
      {
        v11 ^= 32 * v11 + (v11 >> 2) + a2[v10 - 1];
        v10 += ~(v9 >> 5);
      }
      while (v10 > v9 >> 5);
    }
    v12 = v9;
    v20 = 0;
    v21 = 0;
    v18 = 0;
    v19 = 0;
    if ((glpTypeParseDeref(UniformHash, (uint64_t (*)(uint64_t, uint64_t, uint64_t))topLevelLookUpUniformBindingTypeFromStringHash, (uint64_t)a2, v9, &v20, (uint64_t *)&v19, &v18)&& (v13 = glpStringHashGet(UniformHash, v20, v21), *a3 = 0, v13)|| (BindableUniformHash = glpLinkedProgramGetBindableUniformHash(*(_QWORD *)(a1 + 48)), glpTypeParseDeref(BindableUniformHash, (uint64_t (*)(uint64_t, uint64_t, uint64_t))topLevelLookUpUniformBindingTypeFromStringHash, (uint64_t)a2, v12, &v20, (uint64_t *)&v19, &v18))&& (v13 = glpStringHashGet(BindableUniformHash, v20, v21), *a3 = 1, v13))&& *(_DWORD *)(v13 + 4) != -1)
    {
      Kind = glpTypeGetKind(v19);
      ElementType = v19;
      if (Kind == 2)
      {
        ElementType = (unsigned int *)glpArrayTypeGetElementType((uint64_t)v19);
        v19 = ElementType;
      }
      if (glpTypeGetKind(ElementType))
      {
        v5 = 0xFFFFFFFFLL;
        if (*a3 && !(_DWORD)v18)
          return *(unsigned int *)(v13 + 4);
      }
      else
      {
        return (v18 + *(_DWORD *)(v13 + 4));
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return v5;
}

uint64_t topLevelLookUpUniformBindingTypeFromStringHash(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t result;

  result = glpStringHashGet(a1, a2, a3);
  if (result)
    return *(_QWORD *)(result + 24);
  return result;
}

uint64_t ShSetInitialUniformValue(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t result;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t i;
  uint64_t v10;
  unsigned int v11;
  int v12;
  int v13;
  BOOL v14;
  int v15;
  uint64_t v17;

  result = glpLinkedProgramGetUniformHash(*(_QWORD *)(a1 + 48));
  v6 = *(unsigned int *)(result + 32);
  if ((_DWORD)v6)
  {
    v7 = result;
    v8 = 0;
    for (i = 0; i < v6; ++i)
    {
      v10 = *(_QWORD *)(*(_QWORD *)(v7 + 40) + v8);
      if (v10 && *(_DWORD *)(v10 + 4) != -1)
      {
        v11 = glpABIGetTypeSize(0, *(_QWORD *)(v10 + 24), 0);
        result = glpTypeSizeGetSize(v11);
        v12 = *(_DWORD *)(v10 + 4);
        v13 = v12 + result;
        v14 = __OFSUB__(a2, v12);
        v15 = a2 - v12;
        if (v15 < 0 == v14 && v13 > a2)
        {
          v17 = *(_QWORD *)(v10 + 16);
          if (v17)
          {
            *(_OWORD *)a3 = *(_OWORD *)(v17 + 16 * v15);
          }
          else
          {
            *(_QWORD *)a3 = 0;
            *(_QWORD *)(a3 + 8) = 0;
          }
          return result;
        }
        v6 = *(unsigned int *)(v7 + 32);
      }
      v8 += 32;
    }
  }
  return result;
}

uint64_t ShGetPPStreamManager(uint64_t a1, unsigned int a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 48);
  if (result)
    return glpLinkedProgramGetPPStreamManager(result, a2);
  return result;
}

uint64_t ShGetShaderByteCode(uint64_t a1, unsigned int a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 48);
  if (result)
    return glpLinkedProgramGetShaderBytesCode(result, a2);
  return result;
}

uint64_t ShGetLinkerPPStream(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  uint64_t v5;
  const char *v6;
  size_t v7;
  size_t v8;
  char *v9;
  char *v10;
  size_t v11;
  size_t v12;
  char *v13;

  free(*(void **)(a1 + 56));
  v4 = malloc_type_malloc(1uLL, 0x7081ABB9uLL);
  if (!v4)
LABEL_9:
    abort();
  v5 = 0;
  *(_QWORD *)(a1 + 56) = v4;
  *v4 = 0;
  do
  {
    if (*(_QWORD *)(a2 + v5 * 8))
    {
      v6 = off_24F4B0A48[v5];
      v7 = strlen(*(const char **)(a1 + 56));
      v8 = strlen(v6);
      v9 = (char *)malloc_type_realloc(*(void **)(a1 + 56), v7 + v8 + 1, 0x2BDC8648uLL);
      if (!v9)
        goto LABEL_9;
      *(_QWORD *)(a1 + 56) = v9;
      strcat(v9, v6);
      v10 = (char *)glpPPDisassemble(*(_DWORD **)(a2 + v5 * 8));
      v11 = strlen(*(const char **)(a1 + 56));
      v12 = strlen(v10);
      v13 = (char *)malloc_type_realloc(*(void **)(a1 + 56), v11 + v12 + 1, 0x2BDC8648uLL);
      if (!v13)
        goto LABEL_9;
      *(_QWORD *)(a1 + 56) = v13;
      strcat(v13, v10);
      glpPPDisassembleFree(v10);
    }
    ++v5;
  }
  while (v5 != 5);
  return *(_QWORD *)(a1 + 56);
}

uint64_t ShTransformFeedbackVaryings(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  unsigned int v14;
  unsigned int v15;
  size_t v16;
  size_t v17;
  _QWORD *v18;

  if (*(_DWORD *)(a1 + 124))
  {
    v6 = 0;
    v7 = 0;
    do
    {
      free(*(void **)(*(_QWORD *)(a1 + 128) + v6));
      ++v7;
      v6 += 16;
    }
    while (v7 < *(unsigned int *)(a1 + 124));
  }
  off_255B0BD18(GLP_MALLOC_ALLOCATOR, *(void **)(a1 + 128));
  *(_DWORD *)(a1 + 120) = a2;
  *(_DWORD *)(a1 + 124) = 0;
  *(_QWORD *)(a1 + 128) = (*((void *(**)(int, size_t))&GLP_MALLOC_ALLOCATOR + 1))(GLP_MALLOC_ALLOCATOR, 16 * a2);
  if (a2)
  {
    v8 = 0;
    v9 = a2;
    do
    {
      v10 = strlen(*(const char **)(a3 + 8 * v8));
      v11 = v10;
      v12 = (char *)malloc_type_malloc(v10, 0x7081ABB9uLL);
      if (!v12)
        abort();
      v13 = v12;
      memcpy(v12, *(const void **)(a3 + 8 * v8), v10);
      v14 = v10 >> 5;
      if (v10 >> 5 >= v10)
      {
        v16 = v10;
      }
      else
      {
        v15 = ~(v10 >> 5);
        LODWORD(v16) = v10;
        do
        {
          v16 = (32 * (_DWORD)v16 + (v16 >> 2) + v13[(v10 - 1)]) ^ v16;
          LODWORD(v10) = v10 + v15;
        }
        while (v10 > v14);
      }
      v17 = v11 | (v16 << 32);
      v18 = (_QWORD *)(*(_QWORD *)(a1 + 128) + 16 * *(unsigned int *)(a1 + 124));
      *v18 = v13;
      v18[1] = v17;
      ++*(_DWORD *)(a1 + 124);
      ++v8;
    }
    while (v8 != v9);
  }
  return 0;
}

uint64_t ShGetMaxTransformFeedbackVaryingLength(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;

  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    result = glpLinkedProgramGetTransformFeedbackHash(result);
    if (result)
    {
      v2 = result;
      v3 = *(unsigned int *)(result + 32);
      if ((_DWORD)v3)
      {
        result = 0;
        v4 = *(_QWORD *)(v2 + 40);
        do
        {
          if (*(_QWORD *)v4)
          {
            v5 = *(_DWORD *)(*(_QWORD *)v4 + 8);
            if ((int)result <= v5 + 1)
              result = (v5 + 1);
            else
              result = result;
          }
          v4 += 16;
          --v3;
        }
        while (v3);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t ShGetTransformFeedbackVarying(uint64_t a1, unsigned int a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, void *a7)
{
  uint64_t result;
  uint64_t TransformFeedbackHash;
  uint64_t v15;

  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    TransformFeedbackHash = glpLinkedProgramGetTransformFeedbackHash(result);
    v15 = glpIntHashGet(TransformFeedbackHash, a2);
    getString(*(const void **)v15, *(_DWORD *)(v15 + 8), a3, a4, a7);
    if (a5)
      *a5 = *(_DWORD *)(v15 + 16);
    if (a6)
      *a6 = glpPrimitiveTypeGetGLType(*(_DWORD *)(v15 + 20));
    return 1;
  }
  return result;
}

uint64_t ShGetNumActiveVaryingsComponents(uint64_t a1, unsigned int a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 48);
  if (result)
    return glpLinkedProgramGetActiveOutComponents(result, a2);
  return result;
}

uint64_t ShFragDataBindingRequest(uint64_t a1, int a2, int a3, char *__s1)
{
  uint64_t result;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  _DWORD *v12;
  uint64_t v13;
  unsigned int v14;
  char *v15;
  const char *v16;
  unsigned int v17;
  double v18;
  unsigned int v19;

  result = strncmp(__s1, "gl_", 3uLL);
  if ((_DWORD)result)
  {
    v9 = strlen(__s1);
    if (v9 >> 5 >= v9)
    {
      v11 = v9;
    }
    else
    {
      v10 = v9;
      v11 = v9;
      do
      {
        v11 ^= 32 * v11 + (v11 >> 2) + __s1[v10 - 1];
        v10 += ~(v9 >> 5);
      }
      while (v10 > v9 >> 5);
    }
    result = glpStringHashGet(*(_QWORD *)(a1 + 112), __s1, v9 | ((unint64_t)v11 << 32));
    if (result)
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
    }
    else
    {
      v12 = malloc_type_malloc(0x10uLL, 0x7081ABB9uLL);
      if (!v12
        || (v13 = (uint64_t)v12,
            *v12 = a2,
            v12[1] = a3,
            *((_QWORD *)v12 + 1) = 0,
            v14 = strlen(__s1),
            (v15 = (char *)malloc_type_malloc((int)v14, 0x7081ABB9uLL)) == 0))
      {
        abort();
      }
      v16 = v15;
      v17 = v14;
      memcpy(v15, __s1, (int)v14);
      if (v14 >> 5 >= v14)
      {
        v19 = v14;
      }
      else
      {
        v19 = v14;
        do
        {
          v19 ^= 32 * v19 + (v19 >> 2) + v16[v17 - 1];
          v17 += ~(v14 >> 5);
        }
        while (v17 > v14 >> 5);
      }
      return glpStringHashPut(*(_QWORD *)(a1 + 112), v16, v14 | ((unint64_t)v19 << 32), v13, v18);
    }
  }
  return result;
}

uint64_t ShGetFragDataLocation(uint64_t a1, const char *a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t OutputHash;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  _DWORD *v12;
  int Kind;
  unsigned int *ElementType;
  uint64_t v16;
  unsigned int *v17;
  const char *v18;
  uint64_t v19;

  v3 = *(_QWORD *)(a1 + 48);
  v4 = 0xFFFFFFFFLL;
  if (v3)
  {
    OutputHash = glpLinkedProgramGetOutputHash(v3);
    v8 = strlen(a2);
    if (v8 >> 5 < v8)
    {
      v9 = v8;
      v10 = v8;
      do
      {
        v10 ^= 32 * v10 + (v10 >> 2) + a2[v9 - 1];
        v9 += ~(v8 >> 5);
      }
      while (v9 > v8 >> 5);
    }
    v18 = 0;
    v19 = 0;
    v16 = 0;
    v17 = 0;
    if (glpTypeParseDeref(OutputHash, (uint64_t (*)(uint64_t, uint64_t, uint64_t))topLevelLookUpGLPBindingTypeFromStringHash, (uint64_t)a2, v8, &v18, (uint64_t *)&v17, &v16)&& (v11 = glpStringHashGet(OutputHash, v18, v19)) != 0)
    {
      v12 = (_DWORD *)v11;
      Kind = glpTypeGetKind(v17);
      ElementType = v17;
      if (Kind == 2)
      {
        ElementType = (unsigned int *)glpArrayTypeGetElementType((uint64_t)v17);
        v17 = ElementType;
      }
      if (glpTypeGetKind(ElementType))
      {
        v4 = 0xFFFFFFFFLL;
        if (!a3)
          return v4;
        goto LABEL_14;
      }
      v4 = (v16 + *v12);
      if (a3)
LABEL_14:
        *a3 = v12[1];
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return v4;
}

uint64_t topLevelLookUpGLPBindingTypeFromStringHash(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t result;

  result = glpStringHashGet(a1, a2, a3);
  if (result)
    return *(_QWORD *)(result + 8);
  return result;
}

uint64_t ShGetNumActiveUniformBlocks(uint64_t a1)
{
  uint64_t result;
  uint64_t UniformInterfaceBlockHash;
  _OWORD v3[4];
  __int128 v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  unsigned int *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  unsigned int v16;

  v16 = 0;
  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    UniformInterfaceBlockHash = glpLinkedProgramGetUniformInterfaceBlockHash(result);
    v13 = 0u;
    v14 = 0u;
    v10 = 0;
    v12 = 0u;
    v6 = 0u;
    v9 = 0;
    memset(v3, 0, sizeof(v3));
    v4 = 0u;
    v5 = 0u;
    DWORD2(v4) = -1;
    v7 = 0;
    v8 = -1;
    v15 = 256;
    v11 = &v16;
    getBindingInfo(UniformInterfaceBlockHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBlockBinding, (uint64_t)v3);
    return v16;
  }
  return result;
}

uint64_t typeFromGLPUniformBlockBinding(uint64_t result, _DWORD *a2, _DWORD *a3, _QWORD *a4, _QWORD *a5, _BYTE *a6)
{
  *a2 = *(_DWORD *)(result + 12);
  *a3 = *(_DWORD *)result;
  *a4 = *(_QWORD *)(result + 24);
  *a5 = *(_QWORD *)(result + 32);
  *a6 = 0;
  return result;
}

uint64_t ShGetMaxActiveUniformBlockLength(uint64_t a1)
{
  uint64_t result;
  uint64_t UniformInterfaceBlockHash;
  _OWORD v3[4];
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  unsigned int v15;

  v15 = 0;
  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    UniformInterfaceBlockHash = glpLinkedProgramGetUniformInterfaceBlockHash(result);
    v6 = 0;
    v12 = 0u;
    v13 = 0u;
    v10 = 0u;
    v11 = 0u;
    memset(v3, 0, sizeof(v3));
    v4 = 0u;
    v5 = 0u;
    DWORD2(v4) = -1;
    v9 = 0xFFFFFFFFLL;
    v14 = 256;
    v7 = &v15;
    v8 = 0;
    getBindingInfo(UniformInterfaceBlockHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBlockBinding, (uint64_t)v3);
    return v15;
  }
  return result;
}

uint64_t ShGetUniformBlockIndex(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t UniformInterfaceBlockHash;
  _OWORD v7[3];
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  __int128 v16;
  __int128 v17;
  _QWORD v18[4];
  unsigned int v19;

  v2 = 0xFFFFFFFFLL;
  v19 = -1;
  v3 = *(_QWORD *)(a1 + 48);
  if (v3)
  {
    UniformInterfaceBlockHash = glpLinkedProgramGetUniformInterfaceBlockHash(v3);
    v12 = 0u;
    v8 = 0;
    memset(v7, 0, sizeof(v7));
    v10 = 0u;
    v11 = 0u;
    DWORD2(v10) = -1;
    v13 = 0;
    v14 = 0xFFFFFFFFLL;
    v16 = 0u;
    v17 = 0u;
    memset(v18, 0, sizeof(v18));
    v15 = &v19;
    v9 = a2;
    BYTE1(v18[3]) = 1;
    getBindingInfo(UniformInterfaceBlockHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBlockBinding, (uint64_t)v7);
    return v19;
  }
  return v2;
}

uint64_t ShGetActiveUniformBlockiv(uint64_t a1, int a2, int a3, int *a4)
{
  uint64_t result;
  uint64_t UniformHash;
  uint64_t UniformInterfaceBlockHash;
  int v11;
  uint64_t v12;
  uint64x2_t v13;
  _DWORD *v14;
  int v15;
  int64x2_t v16;
  int64x2_t v17;
  int32x2_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _OWORD v22[4];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  int v32;

  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    v32 = 0;
    UniformHash = glpLinkedProgramGetUniformHash(result);
    v31 = 0;
    v23 = 0u;
    *(_QWORD *)&v24 = 0;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v26 = 0u;
    memset(v22, 0, sizeof(v22));
    v25 = 0u;
    DWORD2(v23) = -1;
    *(_QWORD *)&v26 = 0;
    DWORD2(v26) = -1;
    *((_QWORD *)&v24 + 1) = &v32;
    getBindingInfo(UniformHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)v22);
    v20 = 0;
    v21 = 0;
    v19 = 0;
    UniformInterfaceBlockHash = glpLinkedProgramGetUniformInterfaceBlockHash(*(_QWORD *)(a1 + 48));
    memset(v22, 0, 20);
    memset((char *)&v22[1] + 8, 0, 40);
    DWORD2(v23) = -1;
    v24 = 0u;
    *((_QWORD *)&v25 + 1) = 0;
    LOWORD(v31) = 256;
    v27 = 0u;
    v29 = 0u;
    v30 = 0u;
    DWORD2(v26) = a2;
    *(_QWORD *)&v26 = (char *)&v21 + 4;
    *(_QWORD *)&v23 = &v21;
    *(_QWORD *)&v25 = (char *)&v20 + 4;
    *(_QWORD *)&v28 = &v20;
    *((_QWORD *)&v28 + 1) = &v19;
    result = getBindingInfo(UniformInterfaceBlockHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBlockBinding, (uint64_t)v22);
    switch(a3)
    {
      case 35392:
        v11 = HIDWORD(v21);
        goto LABEL_21;
      case 35393:
        v11 = v21;
        goto LABEL_21;
      case 35394:
        v11 = v19;
        goto LABEL_21;
      case 35395:
        if (v19 >= 1)
        {
          v12 = (v19 + 1) & 0x1FFFFFFFELL;
          v13 = (uint64x2_t)vdupq_n_s64((unint64_t)v19 - 1);
          v14 = a4 + 1;
          v15 = v32 + v20;
          v16 = (int64x2_t)xmmword_22A97FDD0;
          v17 = vdupq_n_s64(2uLL);
          do
          {
            v18 = vmovn_s64((int64x2_t)vcgeq_u64(v13, (uint64x2_t)v16));
            if ((v18.i8[0] & 1) != 0)
              *(v14 - 1) = v15;
            if ((v18.i8[4] & 1) != 0)
              *v14 = v15 + 1;
            v16 = vaddq_s64(v16, v17);
            v14 += 2;
            v15 += 2;
            v12 -= 2;
          }
          while (v12);
        }
        return result;
      case 35396:
        v11 = BYTE4(v20) & 1;
        goto LABEL_21;
      case 35397:
        v11 = (HIDWORD(v20) >> 3) & 1;
        goto LABEL_21;
      case 35398:
        v11 = (HIDWORD(v20) >> 4) & 1;
        goto LABEL_21;
      default:
        if (a3 == 34032)
        {
          v11 = (HIDWORD(v20) >> 1) & 1;
        }
        else
        {
          if (a3 != 34033)
            return result;
          v11 = (HIDWORD(v20) >> 2) & 1;
        }
LABEL_21:
        *a4 = v11;
        break;
    }
  }
  return result;
}

uint64_t typeFromGLPUniformBinding(uint64_t result, _DWORD *a2, _DWORD *a3, _QWORD *a4, _QWORD *a5, _BYTE *a6)
{
  *a2 = *(_DWORD *)(result + 12);
  *a3 = *(_DWORD *)result;
  *a4 = *(_QWORD *)(result + 24);
  *a5 = *(_QWORD *)(result + 32);
  *a6 = *(_BYTE *)(result + 80);
  return result;
}

uint64_t ShGetActiveUniformBlockName(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, unint64_t a5)
{
  uint64_t result;
  uint64_t UniformInterfaceBlockHash;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    UniformInterfaceBlockHash = glpLinkedProgramGetUniformInterfaceBlockHash(result);
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v18 = 0u;
    v14 = 0u;
    v11 = 0u;
    v16 = 0u;
    v17 = 0u;
    DWORD2(v16) = -1;
    v19 = 0;
    v25 = 256;
    v20 = a2;
    v12 = a3;
    v13 = a4;
    v15 = a5;
    return getBindingInfo(UniformInterfaceBlockHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBlockBinding, (uint64_t)&v11);
  }
  return result;
}

uint64_t ShGetUniformIndex(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t UniformHash;
  uint64_t UniformInterfaceBlockHash;
  int BindingInfo;
  int NumActiveNonbindableUniforms;
  _OWORD v11[3];
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  unsigned int *v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  unsigned int v24;

  v3 = *(_QWORD *)(a1 + 48);
  v4 = 0xFFFFFFFFLL;
  if (v3)
  {
    UniformHash = glpLinkedProgramGetUniformHash(v3);
    v24 = 0;
    v14 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v12 = 0;
    memset(v11, 0, sizeof(v11));
    DWORD2(v14) = -1;
    v16 = 0u;
    v17 = 0u;
    v18 = 0xFFFFFFFFLL;
    v23 = 0;
    v15 = &v24;
    v13 = a2;
    if (getBindingInfo(UniformHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)v11))
    {
      return v24;
    }
    else
    {
      LOBYTE(v23) = 1;
      UniformInterfaceBlockHash = glpLinkedProgramGetUniformInterfaceBlockHash(*(_QWORD *)(a1 + 48));
      BindingInfo = getBindingInfo(UniformInterfaceBlockHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)v11);
      NumActiveNonbindableUniforms = ShGetNumActiveNonbindableUniforms(a1);
      if (BindingInfo)
        return v24 + NumActiveNonbindableUniforms;
      else
        return 0xFFFFFFFFLL;
    }
  }
  return v4;
}

uint64_t ShGetNumActiveNonbindableUniforms(uint64_t a1)
{
  uint64_t result;
  uint64_t UniformHash;
  _OWORD v3[4];
  __int128 v4;
  uint64_t v5;
  unsigned int *v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  unsigned int v15;

  v15 = 0;
  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    UniformHash = glpLinkedProgramGetUniformHash(result);
    v4 = 0u;
    v5 = 0;
    v12 = 0u;
    v13 = 0u;
    v10 = 0u;
    v11 = 0u;
    memset(v3, 0, sizeof(v3));
    v7 = 0u;
    DWORD2(v4) = -1;
    v8 = 0;
    v9 = 0xFFFFFFFFLL;
    v14 = 0;
    v6 = &v15;
    getBindingInfo(UniformHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)v3);
    return v15;
  }
  return result;
}

uint64_t ShGetActiveUniformIndex(uint64_t a1, unsigned int a2, int a3, unsigned int *a4)
{
  uint64_t result;
  uint64_t UniformHash;
  int NumActiveNonbindableUniforms;
  uint64_t UniformInterfaceBlockHash;
  unsigned int v12;
  _OWORD v13[2];
  uint64_t *v14;
  char *v15;
  __int128 v16;
  unsigned int *v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  unsigned int v33;
  uint64_t v34;

  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    UniformHash = glpLinkedProgramGetUniformHash(result);
    v34 = 0;
    v32 = -1;
    v33 = 0;
    v30 = -1;
    v31 = -1;
    v29 = -1;
    v28 = 0;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v16 = 0u;
    memset(v13, 0, sizeof(v13));
    v19 = 0u;
    v22 = 0xFFFFFFFFLL;
    v27 = 0;
    v18 = a2;
    v14 = &v34;
    v15 = (char *)&v34 + 4;
    v21 = 0;
    v20 = (unint64_t)&v28;
    v17 = &v33;
    result = getBindingInfo(UniformHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)v13);
    if (!(_DWORD)result)
    {
      *(_QWORD *)&v23 = &v32;
      *(_QWORD *)&v25 = &v31;
      *((_QWORD *)&v25 + 1) = &v30;
      *(_QWORD *)&v26 = &v29;
      *((_QWORD *)&v26 + 1) = (char *)&v28 + 4;
      NumActiveNonbindableUniforms = ShGetNumActiveNonbindableUniforms(a1);
      LODWORD(v18) = v18 - NumActiveNonbindableUniforms;
      LOBYTE(v27) = 1;
      UniformInterfaceBlockHash = glpLinkedProgramGetUniformInterfaceBlockHash(*(_QWORD *)(a1 + 48));
      result = getBindingInfo(UniformInterfaceBlockHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)v13);
    }
    switch(a3)
    {
      case 35383:
        v12 = HIDWORD(v34);
        goto LABEL_19;
      case 35384:
        v12 = v34;
        goto LABEL_19;
      case 35385:
        v12 = v33;
        goto LABEL_19;
      case 35386:
        v12 = v32;
        goto LABEL_19;
      case 35387:
        v12 = v31;
        goto LABEL_19;
      case 35388:
        v12 = v30;
        goto LABEL_19;
      case 35389:
        v12 = v29;
        goto LABEL_19;
      case 35390:
        v12 = HIDWORD(v28);
LABEL_19:
        *a4 = v12;
        break;
      default:
        switch(a3)
        {
          case 35424:
            v12 = v28 & 1;
            goto LABEL_19;
          case 35425:
            v12 = (v28 >> 1) & 1;
            goto LABEL_19;
          case 35426:
            v12 = (v28 >> 2) & 1;
            goto LABEL_19;
          case 35427:
            v12 = (v28 >> 3) & 1;
            goto LABEL_19;
          case 35428:
            v12 = (v28 >> 4) & 1;
            goto LABEL_19;
          default:
            return result;
        }
    }
  }
  return result;
}

uint64_t ShGetActiveUniformName(uint64_t a1, int a2, unsigned int a3, uint64_t a4, unint64_t a5)
{
  uint64_t result;
  uint64_t UniformHash;
  int NumActiveNonbindableUniforms;
  uint64_t UniformInterfaceBlockHash;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    UniformHash = glpLinkedProgramGetUniformHash(result);
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v21 = 0u;
    v17 = 0u;
    v14 = 0u;
    v19 = 0u;
    v20 = 0u;
    v22 = 0;
    v23 = 0xFFFFFFFFLL;
    v28 = 0;
    DWORD2(v19) = a2;
    v15 = a3;
    v16 = a4;
    v18 = a5;
    result = getBindingInfo(UniformHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)&v14);
    if (!(_DWORD)result)
    {
      NumActiveNonbindableUniforms = ShGetNumActiveNonbindableUniforms(a1);
      DWORD2(v19) -= NumActiveNonbindableUniforms;
      LOBYTE(v28) = 1;
      UniformInterfaceBlockHash = glpLinkedProgramGetUniformInterfaceBlockHash(*(_QWORD *)(a1 + 48));
      return getBindingInfo(UniformInterfaceBlockHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)&v14);
    }
  }
  return result;
}

uint64_t ShGetNumActiveUniforms(uint64_t a1)
{
  uint64_t result;
  uint64_t UniformHash;
  int v4;
  uint64_t BindableUniformHash;
  int v6;
  uint64_t UniformInterfaceBlockHash;
  _OWORD v8[4];
  __int128 v9;
  uint64_t v10;
  int *v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  int v20;

  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    v20 = 0;
    UniformHash = glpLinkedProgramGetUniformHash(result);
    v9 = 0u;
    v10 = 0;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    memset(v8, 0, sizeof(v8));
    v12 = 0u;
    DWORD2(v9) = -1;
    v13 = 0;
    v14 = 0xFFFFFFFFLL;
    v19 = 0;
    v11 = &v20;
    getBindingInfo(UniformHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)v8);
    v4 = v20;
    BindableUniformHash = glpLinkedProgramGetBindableUniformHash(*(_QWORD *)(a1 + 48));
    getBindingInfo(BindableUniformHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)v8);
    v6 = v20 + v4;
    LOBYTE(v19) = 1;
    UniformInterfaceBlockHash = glpLinkedProgramGetUniformInterfaceBlockHash(*(_QWORD *)(a1 + 48));
    getBindingInfo(UniformInterfaceBlockHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)v8);
    return (v6 + v20);
  }
  return result;
}

uint64_t ShGetMaxActiveUniformLength(uint64_t a1)
{
  uint64_t result;
  uint64_t UniformHash;
  int v4;
  uint64_t BindableUniformHash;
  uint64_t UniformInterfaceBlockHash;
  int v7;
  _QWORD v8[2];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  int v22;

  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    v22 = 0;
    UniformHash = glpLinkedProgramGetUniformHash(result);
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v14 = 0u;
    v10 = 0u;
    v11 = 0u;
    v8[0] = 0;
    v9 = 0u;
    v12 = 0u;
    v13 = 0u;
    DWORD2(v12) = -1;
    v15 = 0;
    v16 = 0xFFFFFFFFLL;
    v21 = 0;
    v8[1] = &v22;
    getBindingInfo(UniformHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)v8);
    v4 = v22;
    BindableUniformHash = glpLinkedProgramGetBindableUniformHash(*(_QWORD *)(a1 + 48));
    getBindingInfo(BindableUniformHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)v8);
    if (v4 <= v22)
      v4 = v22;
    LOBYTE(v21) = 1;
    UniformInterfaceBlockHash = glpLinkedProgramGetUniformInterfaceBlockHash(*(_QWORD *)(a1 + 48));
    getBindingInfo(UniformInterfaceBlockHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)v8);
    v7 = v22;
    if (v4 > v22)
      v7 = v4;
    return v7 & ~(v7 >> 31);
  }
  return result;
}

uint64_t ShGetActiveUniform(uint64_t a1, int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7)
{
  uint64_t result;
  uint64_t UniformHash;
  int NumActiveNonbindableUniforms;
  uint64_t BindableUniformHash;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t UniformInterfaceBlockHash;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  _OWORD v38[4];
  __int128 v39;
  uint64_t v40;
  int *v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;
  int v50;

  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    UniformHash = glpLinkedProgramGetUniformHash(result);
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v30 = 0u;
    v22 = 0u;
    v28 = 0u;
    v29 = 0u;
    v31 = 0;
    v32 = 0xFFFFFFFFLL;
    v37 = 0;
    DWORD2(v28) = a2;
    v23 = a3;
    v24 = a4;
    v25 = a5;
    v26 = a6;
    v27 = a7;
    if (getBindingInfo(UniformHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)&v22))return 1;
    NumActiveNonbindableUniforms = ShGetNumActiveNonbindableUniforms(a1);
    DWORD2(v28) -= NumActiveNonbindableUniforms;
    BindableUniformHash = glpLinkedProgramGetBindableUniformHash(*(_QWORD *)(a1 + 48));
    if (getBindingInfo(BindableUniformHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)&v22))
    {
      return 1;
    }
    else
    {
      v50 = 0;
      v18 = *(_QWORD *)(a1 + 48);
      if (v18)
      {
        v19 = glpLinkedProgramGetBindableUniformHash(v18);
        v39 = 0u;
        v40 = 0;
        v47 = 0u;
        v48 = 0u;
        v45 = 0u;
        v46 = 0u;
        memset(v38, 0, sizeof(v38));
        v42 = 0u;
        DWORD2(v39) = -1;
        v43 = 0;
        v44 = 0xFFFFFFFFLL;
        v49 = 0;
        v41 = &v50;
        getBindingInfo(v19, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)v38);
        v20 = v50;
        v18 = *(_QWORD *)(a1 + 48);
      }
      else
      {
        v20 = 0;
      }
      DWORD2(v28) -= v20;
      LOBYTE(v37) = 1;
      UniformInterfaceBlockHash = glpLinkedProgramGetUniformInterfaceBlockHash(v18);
      return getBindingInfo(UniformInterfaceBlockHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)&v22);
    }
  }
  return result;
}

uint64_t ShGetActiveSamplerLocations(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  uint64_t SamplerLocations;
  int v5;

  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    SamplerLocations = glpLinkedProgramGetSamplerLocations(result);
    v5 = *(_DWORD *)(SamplerLocations + 4);
    result = *(_QWORD *)(SamplerLocations + 8);
  }
  else
  {
    v5 = 0;
  }
  *a2 = v5;
  return result;
}

uint64_t ShGetNumActiveSubroutines(uint64_t a1, unsigned int a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 48);
  if (result)
    return *(unsigned int *)(glpLinkedProgramGetSubroutineHash(result, a2) + 36);
  return result;
}

uint64_t ShGetNumActiveSubroutineUniforms(uint64_t a1, unsigned int a2)
{
  uint64_t result;
  uint64_t SubroutineUniformHash;
  _OWORD v4[4];
  __int128 v5;
  uint64_t v6;
  unsigned int *v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  unsigned int v16;

  v16 = 0;
  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    SubroutineUniformHash = glpLinkedProgramGetSubroutineUniformHash(result, a2);
    v5 = 0u;
    v6 = 0;
    v13 = 0u;
    v14 = 0u;
    v11 = 0u;
    v12 = 0u;
    memset(v4, 0, sizeof(v4));
    v8 = 0u;
    DWORD2(v5) = -1;
    v9 = 0;
    v10 = 0xFFFFFFFFLL;
    v15 = 0;
    v7 = &v16;
    getBindingInfo(SubroutineUniformHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)v4);
    return v16;
  }
  return result;
}

uint64_t ShGetNumActiveSubroutineUniformLocations(uint64_t a1, unsigned int a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 48);
  if (result)
    return glpLinkedProgramGetSubroutineUniformLocationCount(result, a2);
  return result;
}

uint64_t ShGetMaxActiveSubroutineLength(uint64_t a1, unsigned int a2)
{
  uint64_t result;
  uint64_t SubroutineHash;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;

  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    SubroutineHash = glpLinkedProgramGetSubroutineHash(result, a2);
    v4 = *(unsigned int *)(SubroutineHash + 32);
    if ((_DWORD)v4)
    {
      v5 = SubroutineHash;
      result = 0;
      v6 = (_DWORD *)(*(_QWORD *)(v5 + 40) + 16);
      do
      {
        if (*((_QWORD *)v6 - 2))
        {
          if ((int)result <= *v6 + 1)
            result = (*v6 + 1);
          else
            result = result;
        }
        v6 += 8;
        --v4;
      }
      while (v4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ShGetMaxActiveSubroutineUniformLength(uint64_t a1, unsigned int a2)
{
  uint64_t result;
  uint64_t SubroutineUniformHash;
  _QWORD v4[2];
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  unsigned int v18;

  v18 = 0;
  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    SubroutineUniformHash = glpLinkedProgramGetSubroutineUniformHash(result, a2);
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    v10 = 0u;
    v6 = 0u;
    v7 = 0u;
    v4[0] = 0;
    v5 = 0u;
    v8 = 0u;
    v9 = 0u;
    DWORD2(v8) = -1;
    v11 = 0;
    v12 = 0xFFFFFFFFLL;
    v17 = 0;
    v4[1] = &v18;
    getBindingInfo(SubroutineUniformHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)v4);
    return v18;
  }
  return result;
}

uint64_t ShGetSubroutineUniformLocation(uint64_t a1, unsigned int a2, const char *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t SubroutineUniformHash;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int Kind;
  unsigned int *ElementType;
  uint64_t v15;
  unsigned int *v16;
  const char *v17;
  uint64_t v18;

  v3 = *(_QWORD *)(a1 + 48);
  v4 = 0xFFFFFFFFLL;
  if (v3)
  {
    SubroutineUniformHash = glpLinkedProgramGetSubroutineUniformHash(v3, a2);
    v7 = strlen(a3);
    if (v7 >> 5 < v7)
    {
      v8 = v7;
      v9 = v7;
      do
      {
        v9 ^= 32 * v9 + (v9 >> 2) + a3[v8 - 1];
        v8 += ~(v7 >> 5);
      }
      while (v8 > v7 >> 5);
    }
    v17 = 0;
    v18 = 0;
    v15 = 0;
    v16 = 0;
    if (!glpTypeParseDeref(SubroutineUniformHash, (uint64_t (*)(uint64_t, uint64_t, uint64_t))topLevelLookUpUniformBindingTypeFromStringHash, (uint64_t)a3, v7, &v17, (uint64_t *)&v16, &v15))return 0xFFFFFFFFLL;
    v10 = glpStringHashGet(SubroutineUniformHash, v17, v18);
    if (!v10)
      return 0xFFFFFFFFLL;
    v11 = v10;
    if (*(_DWORD *)(v10 + 4) == -1)
      return 0xFFFFFFFFLL;
    Kind = glpTypeGetKind(v16);
    ElementType = v16;
    if (Kind == 2)
    {
      ElementType = (unsigned int *)glpArrayTypeGetElementType((uint64_t)v16);
      v16 = ElementType;
    }
    if (glpTypeGetKind(ElementType) == 5)
      return (v15 + *(_DWORD *)(v11 + 4));
    else
      return 0xFFFFFFFFLL;
  }
  return v4;
}

uint64_t ShGetSubroutineIndex(uint64_t a1, unsigned int a2, const char *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t SubroutineHash;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;

  v3 = *(_QWORD *)(a1 + 48);
  v4 = 0xFFFFFFFFLL;
  if (v3)
  {
    SubroutineHash = glpLinkedProgramGetSubroutineHash(v3, a2);
    v7 = strlen(a3);
    if (v7 >> 5 >= v7)
    {
      v9 = v7;
    }
    else
    {
      v8 = v7;
      v9 = v7;
      do
      {
        v9 ^= 32 * v9 + (v9 >> 2) + a3[v8 - 1];
        v8 += ~(v7 >> 5);
      }
      while (v8 > v7 >> 5);
    }
    v10 = glpStringHashGet(SubroutineHash, a3, v7 | ((unint64_t)v9 << 32));
    if (v10)
      return *(unsigned int *)(v10 + 4);
    else
      return 0xFFFFFFFFLL;
  }
  return v4;
}

uint64_t ShGetActiveSubroutineUniformiv(uint64_t a1, unsigned int a2, unsigned int a3, int a4, _DWORD *a5)
{
  uint64_t result;
  uint64_t SubroutineUniformHash;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  __int128 v15;
  uint64_t v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  _QWORD v25[3];
  __int128 v26;
  __int128 v27;
  _BYTE v28[24];
  uint64_t v29;
  uint64_t v30;

  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    SubroutineUniformHash = glpLinkedProgramGetSubroutineUniformHash(result, a2);
    v29 = 0;
    v30 = 0;
    v18 = 0u;
    v19 = 0;
    v15 = 0u;
    v16 = 0;
    v22 = 0u;
    v23 = 0u;
    v24 = 0;
    v25[0] = 0xFFFFFFFFLL;
    *(_OWORD *)&v25[1] = 0u;
    v26 = 0u;
    v27 = 0u;
    memset(v28, 0, sizeof(v28));
    v14 = &v30;
    v21 = a3;
    v10 = (uint64_t *)((char *)&v29 + 4);
    v17 = (char *)&v29 + 4;
    v20 = &v29;
    result = getBindingInfo(SubroutineUniformHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)&v14);
    if (a4 <= 36425)
    {
      if (a4 != 35384)
      {
        if (a4 != 35385)
          return result;
        v10 = &v29;
      }
      goto LABEL_13;
    }
    if (a4 == 36426)
    {
      v10 = (uint64_t *)(v30 + 68);
LABEL_13:
      *a5 = *(_DWORD *)v10;
      return result;
    }
    if (a4 == 36427)
    {
      v11 = v30;
      if (*(_DWORD *)(v30 + 68))
      {
        v12 = 0;
        v13 = *(_QWORD *)(v30 + 72);
        do
        {
          a5[v12] = *(_DWORD *)(v13 + 4 * v12);
          ++v12;
        }
        while (v12 < *(unsigned int *)(v11 + 68));
      }
    }
  }
  return result;
}

uint64_t ShGetActiveSubroutineUniformName(uint64_t a1, unsigned int a2, int a3, unsigned int a4, uint64_t a5, unint64_t a6)
{
  uint64_t result;
  uint64_t SubroutineUniformHash;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    SubroutineUniformHash = glpLinkedProgramGetSubroutineUniformHash(result, a2);
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v19 = 0u;
    v15 = 0u;
    v12 = 0u;
    v17 = 0u;
    v18 = 0u;
    v20 = 0;
    v21 = 0xFFFFFFFFLL;
    v26 = 0;
    DWORD2(v17) = a3;
    v13 = a4;
    v14 = a5;
    v16 = a6;
    return getBindingInfo(SubroutineUniformHash, (uint64_t (*)(uint64_t, unsigned int *, unsigned int *, unsigned int **, uint64_t *, unsigned __int8 *))typeFromGLPUniformBinding, (uint64_t)&v12);
  }
  return result;
}

_QWORD *ShGetActiveSubroutineName(uint64_t a1, unsigned int a2, int a3, int a4, _DWORD *a5, void *a6)
{
  _QWORD *result;
  uint64_t v11;
  int *i;
  uint64_t v13;

  result = *(_QWORD **)(a1 + 48);
  if (result)
  {
    result = (_QWORD *)glpLinkedProgramGetSubroutineHash((uint64_t)result, a2);
    v11 = *((unsigned int *)result + 8);
    if ((_DWORD)v11)
    {
      for (i = (int *)(result[5] + 16); ; i += 8)
      {
        v13 = *((_QWORD *)i - 2);
        if (v13)
        {
          if (*(_DWORD *)(v13 + 4) == a3)
            break;
        }
        if (!--v11)
          return result;
      }
      return getString(*((const void **)i - 1), *i, a4, a5, a6);
    }
  }
  return result;
}

uint64_t ShGetCachedUniformIndexTable(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 48))
    return *(_QWORD *)(a1 + 72);
  else
    return 0;
}

uint64_t ShGetCachedUniformIndexTableSize(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 48))
    return *(unsigned int *)(a1 + 80);
  else
    return 0;
}

uint64_t ShGetInteger(uint64_t *a1, int a2, _QWORD *a3)
{
  _DWORD *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  _DWORD *v13;
  const void *v14;
  size_t v15;
  uint64_t v16;
  size_t v17;
  char *v18;
  size_t v19;
  char *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  int v27;
  uint64_t v28;
  _DWORD *v29;
  const void *v30;
  size_t v31;
  uint64_t v32;
  size_t v33;
  char *v34;
  size_t v35;
  char *v36;
  void *v37;
  char *v38;
  _DWORD *v39;
  _DWORD *v40;
  uint64_t OutputHash;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  const void *v49;
  size_t v50;
  uint64_t v51;
  size_t v52;
  char *v53;
  _DWORD *v54;
  unsigned int CompiledShaderVersion;
  int v56;
  _QWORD *v58;

  switch(a2)
  {
    case 1707:
      v5 = malloc_type_realloc(0, 4uLL, 0x2BDC8648uLL);
      if (!v5)
        goto LABEL_39;
      v58 = a3;
      *v5 = 0;
      v6 = a1[13];
      v7 = *(unsigned int *)(v6 + 32);
      if (!(_DWORD)v7)
        goto LABEL_34;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 4;
      while (1)
      {
        v12 = *(_QWORD *)(v6 + 40);
        v13 = *(_DWORD **)(v12 + v8);
        if (v13)
        {
          v14 = *(const void **)(v12 + v8 + 8);
          v15 = *(unsigned int *)(v12 + v8 + 16);
          v16 = v11;
          v17 = v11 + 4;
          v18 = (char *)malloc_type_realloc(v5, v17, 0x2BDC8648uLL);
          if (!v18)
            goto LABEL_39;
          *(_DWORD *)&v18[v16] = v15;
          v19 = (int)v15 + (int)v17;
          v20 = (char *)malloc_type_realloc(v18, v19, 0x2BDC8648uLL);
          if (!v20)
            goto LABEL_39;
          v21 = v20;
          memcpy(&v20[v17], v14, v15);
          v5 = malloc_type_realloc(v21, (int)v19 + 4, 0x2BDC8648uLL);
          if (!v5)
            goto LABEL_39;
          *(_DWORD *)((char *)v5 + v19) = *v13;
          ++v10;
          v7 = *(unsigned int *)(v6 + 32);
          v11 = v19 + 4;
        }
        ++v9;
        v8 += 32;
        if (v9 >= v7)
          goto LABEL_35;
      }
    case 1708:
      v5 = malloc_type_realloc(0, 4uLL, 0x2BDC8648uLL);
      if (!v5)
        goto LABEL_39;
      v58 = a3;
      *v5 = 0;
      v23 = a1[14];
      v24 = *(unsigned int *)(v23 + 32);
      if ((_DWORD)v24)
      {
        v25 = 0;
        v26 = 0;
        v10 = 0;
        v27 = 4;
        while (1)
        {
          v28 = *(_QWORD *)(v23 + 40);
          v29 = *(_DWORD **)(v28 + v25);
          if (v29)
          {
            v30 = *(const void **)(v28 + v25 + 8);
            v31 = *(unsigned int *)(v28 + v25 + 16);
            v32 = v27;
            v33 = v27 + 4;
            v34 = (char *)malloc_type_realloc(v5, v33, 0x2BDC8648uLL);
            if (!v34)
              goto LABEL_39;
            *(_DWORD *)&v34[v32] = v31;
            v35 = (int)v31 + (int)v33;
            v36 = (char *)malloc_type_realloc(v34, v35, 0x2BDC8648uLL);
            if (!v36)
              goto LABEL_39;
            v37 = v36;
            memcpy(&v36[v33], v30, v31);
            v38 = (char *)malloc_type_realloc(v37, v35 + 4, 0x2BDC8648uLL);
            if (!v38)
              goto LABEL_39;
            *(_DWORD *)&v38[v35] = *v29;
            v5 = malloc_type_realloc(v38, (int)v35 + 8, 0x2BDC8648uLL);
            if (!v5)
              goto LABEL_39;
            *(_DWORD *)((char *)v5 + v35 + 4) = v29[1];
            ++v10;
            v24 = *(unsigned int *)(v23 + 32);
            v27 = v35 + 8;
          }
          ++v26;
          v25 += 32;
          if (v26 >= v24)
            goto LABEL_35;
        }
      }
LABEL_34:
      v10 = 0;
LABEL_35:
      v22 = 0;
      *v5 = v10;
      *v58 = v5;
      break;
    case 1709:
      v39 = malloc_type_realloc(0, 4uLL, 0x2BDC8648uLL);
      if (!v39)
        goto LABEL_39;
      v40 = v39;
      *v39 = 0;
      OutputHash = glpLinkedProgramGetOutputHash(a1[6]);
      v42 = *(unsigned int *)(OutputHash + 32);
      if ((_DWORD)v42)
      {
        v43 = OutputHash;
        v44 = 0;
        v45 = 0;
        v46 = 0;
        v47 = 4;
        do
        {
          v48 = *(_QWORD *)(v43 + 40);
          if (*(_QWORD *)(v48 + v44))
          {
            v49 = *(const void **)(v48 + v44 + 8);
            v50 = *(unsigned int *)(v48 + v44 + 16);
            v51 = v47;
            v52 = v47 + 4;
            v53 = (char *)malloc_type_realloc(v40, v52, 0x2BDC8648uLL);
            if (!v53
              || (*(_DWORD *)&v53[v51] = v50, (v54 = malloc_type_realloc(v53, (int)v50 + (int)v52, 0x2BDC8648uLL)) == 0))
            {
LABEL_39:
              abort();
            }
            v40 = v54;
            memcpy((char *)v54 + v52, v49, v50);
            ++v46;
            v42 = *(unsigned int *)(v43 + 32);
            v47 = v50 + v52;
          }
          ++v45;
          v44 += 32;
        }
        while (v45 < v42);
      }
      else
      {
        v46 = 0;
      }
      v22 = 0;
      *v40 = v46;
      *a3 = v40;
      break;
    case 1710:
      CompiledShaderVersion = glpGetCompiledShaderVersion(a1[6]);
      v56 = glpGLSLVersionToInt(CompiledShaderVersion);
      v22 = 0;
      *(_DWORD *)a3 = v56;
      return v22;
    default:
      return 10010;
  }
  return v22;
}

dispatch_queue_t ShInitializeLibrary()
{
  dispatch_queue_t result;

  result = dispatch_queue_create("OpenGL Caching", 0);
  gSerialQueue = (uint64_t)result;
  return result;
}

void ShTerminateLibrary()
{
  if (compilerCache)
  {
    glpCacheDelete((void *)compilerCache);
    compilerCache = 0;
  }
  if (linkerCache)
  {
    glpCacheDelete((void *)linkerCache);
    linkerCache = 0;
  }
  dispatch_release((dispatch_object_t)gSerialQueue);
  gSerialQueue = 0;
}

uint64_t getBindingInfoForType(int a1, int a2, unsigned int a3, unsigned int a4, uint64_t a5, unsigned int a6, unsigned int *a7, uint64_t a8, _DWORD *a9, _DWORD *a10, _DWORD *a11, int a12, uint64_t a13)
{
  unsigned int *v14;
  uint64_t v17;
  _BOOL4 v18;
  uint64_t BindingInfoForType;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  unsigned int *v25;
  _DWORD *v26;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  unsigned int *v31;
  _DWORD *v32;
  char v33;
  const char *v34;
  int v35;
  int v36;
  unsigned int v37;
  char *v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  unsigned int *v42;
  _DWORD *v43;
  int v44;
  const char *v45;
  size_t v46;
  int v47;
  int *v48;
  int v49;
  int v50;
  int Kind;
  unsigned int v52;
  char *v53;
  char *v54;
  const void *v55;
  size_t v56;
  size_t v57;
  _BOOL4 v59;
  unsigned int v60;
  int *v61;
  int v62;
  int v63;
  _DWORD *v64;
  unsigned int PrimitiveType;
  _DWORD *v66;
  unsigned int v67;
  _DWORD *v68;
  _DWORD *v69;
  _DWORD *v70;
  uint64_t v71;
  int v72;
  unsigned int *v73;
  unsigned int v74;
  int *v75;
  int v76;
  int v77;
  const void *v78;
  size_t v79;
  int v80;
  size_t v81;
  int v82;
  int *v83;
  int v84;
  int v85;
  int v86;
  unsigned int v87;
  _DWORD *v88;
  int *v89;
  int v90;
  _BYTE *v91;
  int ElementCount;
  int v93;
  int v94;
  __int16 ElementFlags;
  int v96;
  uint64_t ElementType;
  uint64_t FieldName;
  unsigned int v99;
  unsigned int v100;
  const void *v101;
  char *v102;
  int v103;
  uint64_t v104;
  unsigned int v105;
  int Size;
  _DWORD *v107;
  _DWORD *v108;
  int v110;
  int v111;
  int v112;
  int v113;
  int v114;
  uint64_t v115;
  int v116;
  int v118;
  _BOOL4 v120;
  int v123;
  char __src[32];
  uint64_t v126;

  v14 = a7;
  v17 = a13;
  v126 = *MEMORY[0x24BDAC8D0];
  v18 = *(_QWORD *)(a13 + 48) && *(_DWORD *)(a13 + 16) || *(_QWORD *)(a13 + 56) != 0;
  v120 = v18;
  BindingInfoForType = 0;
  v123 = a12;
  LODWORD(v20) = 1;
  switch(glpTypeGetKind(a7))
  {
    case 0u:
    case 5u:
      goto LABEL_68;
    case 1u:
      v22 = *(_DWORD *)(a5 + 8);
      if (!a1)
      {
        v27 = 0;
        v28 = 0;
        v77 = *(_DWORD *)(a5 + 8);
        v23 = (uint64_t)a7;
        goto LABEL_138;
      }
      v23 = (uint64_t)v14;
      v24 = glpABIGetMinimumBufferBytesForType(a3, (uint64_t)v14, (unint64_t)(a4 != 0) << 10);
      if (*a11 == *(_DWORD *)(a13 + 120))
        goto LABEL_10;
      if (!*(_QWORD *)(a13 + 128))
        goto LABEL_115;
      v78 = *(const void **)(a13 + 56);
      if (v78 && (v79 = strlen((const char *)v78), v79 == *(_DWORD *)(a5 + 8)))
      {
        v80 = memcmp(v78, *(const void **)a5, v79);
        v17 = a13;
        if (v80)
        {
LABEL_115:
          v27 = 0;
          v28 = 0;
        }
        else
        {
LABEL_10:
          v25 = *(unsigned int **)(v17 + 96);
          if (v25)
            *v25 = a6;
          v26 = *(_DWORD **)(v17 + 112);
          if (v26)
            *v26 = v24;
          v27 = *a9;
          v28 = 1;
        }
      }
      else
      {
        v27 = 0;
        v28 = 0;
        v17 = a13;
      }
      v89 = *(int **)(v17 + 104);
      v77 = *(_DWORD *)(a5 + 8);
      if (v89)
      {
        v90 = *v89;
        if (*v89 <= v77 + 1)
          v90 = v77 + 1;
        *v89 = v90;
        v77 = *(_DWORD *)(a5 + 8);
      }
LABEL_138:
      if (a2)
        goto LABEL_143;
      if (!v120)
        goto LABEL_142;
      v91 = malloc_type_realloc(*(void **)a5, (v77 + 1), 0x2BDC8648uLL);
      if (!v91)
        goto LABEL_174;
      *(_QWORD *)a5 = v91;
      v91[*(unsigned int *)(a5 + 8)] = 46;
      v77 = *(_DWORD *)(a5 + 8);
LABEL_142:
      *(_DWORD *)(a5 + 8) = ++v77;
LABEL_143:
      ElementCount = glpAggregateTypeGetElementCount(v23);
      if (ElementCount < 1)
      {
        if (!a1)
          return 0;
      }
      else
      {
        v93 = ElementCount;
        v114 = v22;
        v116 = v28;
        v112 = v27;
        v94 = 1;
        do
        {
          ElementFlags = glpAggregateTypeGetElementFlags(v23, v94 - 1);
          v96 = glpABIGetStructTypeRangeOfField(a3, v23, (unint64_t)(a4 != 0) << 10, v94 - 1);
          ElementType = glpAggregateTypeGetElementType(v23, v94 - 1);
          FieldName = glpStructTypeGetFieldName(v23, v94 - 1);
          v100 = v99;
          *(_DWORD *)(a5 + 8) = v77;
          if (v120)
          {
            v101 = (const void *)FieldName;
            v102 = (char *)malloc_type_realloc(*(void **)a5, v77 + v99, 0x2BDC8648uLL);
            if (!v102)
              goto LABEL_174;
            *(_QWORD *)a5 = v102;
            memcpy(&v102[*(unsigned int *)(a5 + 8)], v101, v100);
            v103 = *(_DWORD *)(a5 + 8);
          }
          else
          {
            v103 = v77;
          }
          *(_DWORD *)(a5 + 8) = v103 + v100;
          if ((ElementFlags & 0x400) != 0)
            v104 = 1;
          else
            v104 = a4;
          v17 = a13;
          BindingInfoForType = getBindingInfoForType(0, 0, a3, v104, a5, a6, ElementType, a8, a9, a10, a11, v96 + a12, a13);
          v105 = glpABIGetTypeSize(0, ElementType, 0);
          Size = glpTypeSizeGetSize(v105);
          v23 = (uint64_t)a7;
          if (v94 >= v93)
            break;
          a8 = (Size + a8);
          ++v94;
        }
        while (!(_DWORD)BindingInfoForType);
        v28 = v116;
        if (!a1)
          return BindingInfoForType;
        v27 = v112;
        v22 = v114;
        if ((_DWORD)BindingInfoForType)
        {
          if (!v116)
            return 1;
          goto LABEL_160;
        }
      }
      *(_DWORD *)(a5 + 8) = v22;
      if (!v28)
      {
        BindingInfoForType = 0;
        ++*a11;
        v64 = a10;
        goto LABEL_89;
      }
LABEL_160:
      v107 = *(_DWORD **)(v17 + 144);
      if (v107)
        *v107 = v27;
      v75 = *(int **)(v17 + 152);
      if (v75)
      {
        v76 = *a9 - v27;
        goto LABEL_171;
      }
      return 1;
    case 2u:
    case 3u:
      if (glpTypeGetKind(v14) == 3)
        v21 = glpBankTypeGetElementCount((uint64_t)a7);
      else
        v21 = glpArrayTypeGetElementCount((uint64_t)a7);
      v20 = v21;
      if (glpTypeGetKind(a7) == 3)
        v29 = glpBankTypeGetElementType((uint64_t)a7);
      else
        v29 = glpArrayTypeGetElementType((uint64_t)a7);
      v14 = (unsigned int *)v29;
      v115 = (unint64_t)(a4 != 0) << 10;
      v118 = glpABIGetArrayStrideForElementType(a3, v29, v115);
      if (a1 && *(_BYTE *)(a13 + 192) && glpTypeGetKind(a7) == 3)
      {
        v30 = glpABIGetMinimumBufferBytesForType(a3, (uint64_t)v14, v115);
        if (*a11 == *(_DWORD *)(a13 + 120))
        {
LABEL_23:
          v31 = *(unsigned int **)(v17 + 96);
          if (v31)
            *v31 = a6;
          v32 = *(_DWORD **)(v17 + 112);
          if (v32)
            *v32 = v30;
          v33 = 0;
          LODWORD(v34) = *a9;
LABEL_122:
          v83 = *(int **)(a13 + 104);
          if (v83)
          {
            v84 = *v83;
            v85 = *(_DWORD *)(a5 + 8);
            if (*v83 <= v85 + 1)
              v84 = v85 + 1;
            *v83 = v84;
          }
          v86 = getBindingInfoForType(0, 0, a3, a4, a5, a6, v14, a8, a9, a10, a11, 0, a13);
          v87 = glpABIGetTypeSize(0, (uint64_t)v14, 0);
          glpTypeSizeGetSize(v87);
          if ((v33 & 1) != 0)
          {
            if (!v86)
            {
              BindingInfoForType = 0;
              ++*a11;
              ++*a10;
              *a11 += v20 - 1;
              *a10 += v20 - 1;
              return BindingInfoForType;
            }
          }
          else
          {
            v88 = *(_DWORD **)(a13 + 144);
            if (v88)
              *v88 = (_DWORD)v34;
            v75 = *(int **)(a13 + 152);
            if (v75)
            {
              v76 = *a9 - (_DWORD)v34;
              goto LABEL_171;
            }
          }
          return 1;
        }
        if (*(_QWORD *)(a13 + 128))
        {
          v34 = *(const char **)(a13 + 56);
          if (!v34)
          {
LABEL_121:
            v33 = 1;
            goto LABEL_122;
          }
          v81 = strlen(v34);
          if (v81 == *(_DWORD *)(a5 + 8))
          {
            v82 = memcmp(v34, *(const void **)a5, v81);
            v17 = a13;
            if (!v82)
              goto LABEL_23;
          }
        }
        LODWORD(v34) = 0;
        goto LABEL_121;
      }
      if (glpTypeGetKind(v14) != 5 && glpTypeGetKind(v14))
      {
        if ((int)v20 < 1)
          return 0;
        v35 = 0;
        v36 = 0;
        v110 = *a9;
        v111 = 0;
        v113 = *(_DWORD *)(a5 + 8);
        while (1)
        {
          *(_DWORD *)(a5 + 8) = v113;
          v37 = snprintf_l(__src, 0x20uLL, 0, "[%d]", v36);
          if (v120)
          {
            v38 = (char *)malloc_type_realloc(*(void **)a5, *(_DWORD *)(a5 + 8) + v37, 0x2BDC8648uLL);
            if (!v38)
              goto LABEL_174;
            *(_QWORD *)a5 = v38;
            memcpy(&v38[*(unsigned int *)(a5 + 8)], __src, v37);
          }
          v39 = v20;
          v40 = *(_DWORD *)(a5 + 8) + v37;
          *(_DWORD *)(a5 + 8) = v40;
          if (!a1)
          {
            v44 = v123;
            goto LABEL_57;
          }
          v41 = glpABIGetMinimumBufferBytesForType(a3, (uint64_t)v14, v115);
          if (*a11 != *(_DWORD *)(v17 + 120))
          {
            if (!*(_QWORD *)(v17 + 128))
              goto LABEL_49;
            v45 = *(const char **)(v17 + 56);
            if (!v45 || (v46 = strlen(v45), v46 != *(_DWORD *)(a5 + 8)))
            {
              v17 = a13;
              goto LABEL_49;
            }
            v47 = memcmp(v45, *(const void **)a5, v46);
            v17 = a13;
            if (v47)
              goto LABEL_49;
          }
          v42 = *(unsigned int **)(v17 + 96);
          if (v42)
            *v42 = a6;
          v43 = *(_DWORD **)(v17 + 112);
          if (v43)
            *v43 = v41;
          v111 = *a9;
          v35 = 1;
LABEL_49:
          v48 = *(int **)(v17 + 104);
          if (v48)
          {
            v49 = *v48;
            v50 = *(_DWORD *)(a5 + 8);
            if (*v48 <= v50 + 1)
              v49 = v50 + 1;
            *v48 = v49;
          }
          v44 = *(unsigned __int8 *)(v17 + 193);
          if (*(_BYTE *)(v17 + 193))
          {
            Kind = glpTypeGetKind(a7);
            v44 = 0;
            if (v36)
            {
              if (Kind == 3)
              {
                v111 = v110;
LABEL_59:
                *(_DWORD *)(a5 + 8) = v40;
                if (v35)
                  goto LABEL_167;
                BindingInfoForType = 0;
                ++*a11;
                ++*a10;
                goto LABEL_61;
              }
            }
          }
LABEL_57:
          BindingInfoForType = getBindingInfoForType(0, 0, a3, a4, a5, a6, v14, a8, a9, a10, a11, v44, v17);
          v52 = glpABIGetTypeSize(0, (uint64_t)v14, 0);
          a8 = glpTypeSizeGetSize(v52) + a8;
          if (a1)
          {
            if ((_DWORD)BindingInfoForType)
            {
              if (v35)
              {
LABEL_167:
                v108 = *(_DWORD **)(v17 + 144);
                if (v108)
                  *v108 = v111;
                v75 = *(int **)(v17 + 152);
                if (v75)
                {
                  v76 = *a9 - v111;
LABEL_171:
                  *v75 = v76;
                }
              }
              return 1;
            }
            goto LABEL_59;
          }
LABEL_61:
          if (++v36 < (int)v39)
          {
            v20 = v39;
            v123 += v118;
            if (!(_DWORD)BindingInfoForType)
              continue;
          }
          return BindingInfoForType;
        }
      }
      if (v120)
      {
        v53 = (char *)malloc_type_realloc(*(void **)a5, (*(_DWORD *)(a5 + 8) + 3), 0x2BDC8648uLL);
        if (!v53)
LABEL_174:
          abort();
        *(_QWORD *)a5 = v53;
        v54 = &v53[*(unsigned int *)(a5 + 8)];
        v54[2] = 93;
        *(_WORD *)v54 = 12379;
      }
      *(_DWORD *)(a5 + 8) += 3;
      LODWORD(BindingInfoForType) = v118;
LABEL_68:
      if (!*(_QWORD *)(a13 + 80))
        goto LABEL_77;
      v55 = *(const void **)(a13 + 56);
      if (v55)
      {
        v56 = strlen(*(const char **)(a13 + 56));
        LODWORD(v55) = v56 == *(_DWORD *)(a5 + 8) && memcmp(v55, *(const void **)a5, v56) == 0;
        if (glpTypeGetKind(a7) == 2 && !(_DWORD)v55)
        {
          v57 = strlen(*(const char **)(a13 + 56));
          if (v57 == *(_DWORD *)(a5 + 8) - 3)
            LODWORD(v55) = memcmp(*(const void **)(a13 + 56), *(const void **)a5, v57) == 0;
          else
LABEL_77:
            LODWORD(v55) = 0;
        }
      }
      if (*a9 == *(_DWORD *)(a13 + 72) || (_DWORD)v55 != 0)
      {
        if (glpTypeGetKind(v14))
        {
          v59 = 0;
        }
        else
        {
          PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)v14);
          v59 = glpPrimitiveTypeGetCategory(PrimitiveType) == 3;
        }
        v66 = *(_DWORD **)(a13 + 32);
        if (v66)
          *v66 = v20;
        if (*(_QWORD *)(a13 + 40))
        {
          v67 = glpPrimitiveTypeGetPrimitiveType((uint64_t)v14);
          **(_DWORD **)(a13 + 40) = glpPrimitiveTypeGetGLType(v67);
        }
        v68 = *(_DWORD **)(a13 + 160);
        if (v68)
          *v68 = a12;
        v69 = *(_DWORD **)(a13 + 168);
        if (v69)
          *v69 = BindingInfoForType;
        v70 = *(_DWORD **)(a13 + 176);
        if (v70)
        {
          if (v59)
          {
            v71 = glpPrimitiveTypeGetPrimitiveType((uint64_t)v14);
            v72 = glpABIGetMatrixStride(a3, v71, (unint64_t)(a4 != 0) << 10);
            v70 = *(_DWORD **)(a13 + 176);
          }
          else
          {
            v72 = 0;
          }
          *v70 = v72;
        }
        v73 = *(unsigned int **)(a13 + 184);
        if (v73)
        {
          v74 = a4;
          if (!v59)
            v74 = 0;
          *v73 = v74;
        }
        v75 = *(int **)(a13 + 96);
        if (v75)
        {
          v76 = a6;
          goto LABEL_171;
        }
        return 1;
      }
      v60 = glpABIGetTypeSize(0, (uint64_t)v14, 0);
      glpTypeSizeGetSize(v60);
      v61 = *(int **)(a13 + 8);
      if (v61)
      {
        v62 = *v61;
        v63 = *(_DWORD *)(a5 + 8);
        if (*v61 <= v63 + 1)
          v62 = v63 + 1;
        *v61 = v62;
      }
      BindingInfoForType = 0;
      v64 = a9;
LABEL_89:
      ++*v64;
      return BindingInfoForType;
    default:
      return BindingInfoForType;
  }
}

void *glpCopyString(uint64_t a1, const void *a2, unsigned int a3)
{
  size_t v4;
  void *v5;

  v4 = a3;
  v5 = (void *)(*(uint64_t (**)(_QWORD, _QWORD, const char *))(a1 + 8))(*(_QWORD *)a1, a3, "String Contents (copy)");
  memcpy(v5, a2, v4);
  return v5;
}

char *glpLowerCaseCopyOfString(uint64_t a1, const void *a2, unsigned int a3)
{
  size_t v4;
  char *v5;
  uint64_t v6;
  char *v7;
  unsigned int v8;
  int v9;

  v4 = a3;
  v5 = (char *)(*(uint64_t (**)(_QWORD, _QWORD, const char *))(a1 + 8))(*(_QWORD *)a1, a3, "String Contents (copy)");
  memcpy(v5, a2, v4);
  if (v4)
  {
    v6 = MEMORY[0x24BDAC740];
    v7 = v5;
    do
    {
      v8 = *v7;
      if ((v8 & 0x80000000) != 0)
        LOBYTE(v9) = ___tolower_l(v8, 0);
      else
        v9 = *(_DWORD *)(v6 + 4 * v8 + 1084);
      *v7++ = v9;
      --v4;
    }
    while (v4);
  }
  return v5;
}

BOOL glpStringsEqual(const char *a1, uint64_t a2, char *__s2, uint64_t a4)
{
  return a2 == a4 && strncmp(a1, __s2, a2) == 0;
}

uint64_t glpStringsCompare(const char *a1, unsigned int a2, char *__s2, unsigned int a4)
{
  unsigned int v5;
  size_t v6;
  uint64_t result;

  v5 = a2 - a4;
  if (a2 >= a4)
    v6 = a4;
  else
    v6 = a2;
  LODWORD(result) = strncmp(a1, __s2, v6);
  if ((_DWORD)result)
    return result;
  else
    return v5;
}

_QWORD *glpMakeStringBuffer(_QWORD *a1)
{
  _QWORD *v2;

  v2 = (_QWORD *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 24, "String Buffer");
  *v2 = a1;
  v2[1] = 64;
  v2[2] = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 64, "Vector Storage (char)");
  return v2;
}

uint64_t glpDestroyStringBuffer(_QWORD **a1)
{
  ((void (*)(_QWORD, _QWORD *))(*a1)[3])(**a1, a1[2]);
  return ((uint64_t (*)(_QWORD, _QWORD **))(*a1)[3])(**a1, a1);
}

uint64_t glpStringBufferGetString(uint64_t a1)
{
  uint64_t result;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;

  result = *(_QWORD *)(a1 + 16);
  v3 = *(_DWORD *)(a1 + 12);
  if (v3 >> 5 < v3)
  {
    v4 = v3;
    v5 = v3;
    do
    {
      v5 ^= 32 * v5 + (v5 >> 2) + *(char *)(result + v4 - 1);
      v4 += ~(v3 >> 5);
    }
    while (v4 > v3 >> 5);
  }
  return result;
}

uint64_t glpStringBufferGetCString(uint64_t *a1)
{
  int v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  int v9;

  v2 = *((_DWORD *)a1 + 2);
  v3 = *((unsigned int *)a1 + 3);
  v4 = v3 + 1;
  if ((int)v3 + 1 <= v2)
  {
    v8 = (char *)a1[2];
    v9 = *((_DWORD *)a1 + 3);
  }
  else
  {
    if (v2 <= 1)
      v2 = 1;
    v5 = 2 * v2;
    if (v5 <= v4)
      v6 = v4;
    else
      v6 = v5;
    v7 = *a1;
    v8 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(*a1 + 8))(*(_QWORD *)*a1, v6, "Vector Storage (char, growth)");
    memcpy(v8, (const void *)a1[2], *((unsigned int *)a1 + 3));
    (*(void (**)(_QWORD, uint64_t))(v7 + 24))(*(_QWORD *)v7, a1[2]);
    *((_DWORD *)a1 + 2) = v6;
    a1[2] = (uint64_t)v8;
    v9 = *((_DWORD *)a1 + 3);
  }
  memmove(&v8[v3 + 1], &v8[v3], (v9 - v3));
  *(_BYTE *)(a1[2] + v3) = 0;
  return a1[2];
}

void *glpStringBufferAppend(uint64_t *a1, const void *a2, unsigned int a3)
{
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  int v13;
  void *result;

  v6 = *((_DWORD *)a1 + 2);
  v7 = *((unsigned int *)a1 + 3);
  v8 = v7 + a3;
  if (v7 + a3 <= v6)
  {
    v12 = (char *)a1[2];
    v13 = *((_DWORD *)a1 + 3);
  }
  else
  {
    if (v6 <= 1)
      v6 = 1;
    v9 = 2 * v6;
    if (v9 <= v8)
      v10 = v8;
    else
      v10 = v9;
    v11 = *a1;
    v12 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(*a1 + 8))(*(_QWORD *)*a1, v10, "Vector Storage (char, growth)");
    memcpy(v12, (const void *)a1[2], *((unsigned int *)a1 + 3));
    (*(void (**)(_QWORD, uint64_t))(v11 + 24))(*(_QWORD *)v11, a1[2]);
    *((_DWORD *)a1 + 2) = v10;
    a1[2] = (uint64_t)v12;
    v13 = *((_DWORD *)a1 + 3);
  }
  memmove(&v12[v7 + 1], &v12[v7], (v13 - v7));
  result = memcpy((void *)(a1[2] + v7), a2, a3);
  *((_DWORD *)a1 + 3) += a3;
  return result;
}

void *glpStringBufferAppendCString(uint64_t *a1, char *__s)
{
  unsigned int v4;

  v4 = strlen(__s);
  return glpStringBufferAppend(a1, __s, v4);
}

uint64_t glpStringBufferAppendFormat(uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return glpStringBufferAppendFormatv(a1, a2, &a9);
}

uint64_t glpStringBufferAppendFormatv(uint64_t *a1, char *a2, va_list a3)
{
  uint64_t v5;
  size_t v6;
  int v7;
  size_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t result;

  v5 = *((unsigned int *)a1 + 3);
  v6 = (*((_DWORD *)a1 + 2) - v5);
  v7 = vsnprintf_l((char *)(a1[2] + v5), v6, 0, a2, a3);
  v8 = (v7 + 1);
  if (v8 <= v6)
  {
    v14 = (void *)a1[2];
  }
  else
  {
    v9 = *((_DWORD *)a1 + 2);
    if (v9 <= 1)
      v9 = 1;
    v10 = 2 * v9;
    v11 = v8 + *((_DWORD *)a1 + 3);
    if (v10 <= v11)
      v12 = v11;
    else
      v12 = v10;
    v13 = *a1;
    v14 = (void *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(*a1 + 8))(*(_QWORD *)*a1, v12, "Vector Storage (char, growth)");
    memcpy(v14, (const void *)a1[2], *((unsigned int *)a1 + 3));
    (*(void (**)(_QWORD, uint64_t))(v13 + 24))(*(_QWORD *)v13, a1[2]);
    *((_DWORD *)a1 + 2) = v12;
    a1[2] = (uint64_t)v14;
  }
  result = vsnprintf_l((char *)v14 + *((unsigned int *)a1 + 3), v8, 0, a2, a3);
  *((_DWORD *)a1 + 3) += v7;
  return result;
}

BOOL glpDatasEqual(const void *a1, uint64_t a2, void *__s2, uint64_t a4)
{
  return a2 == a4 && memcmp(a1, __s2, a2) == 0;
}

uint64_t glpPrimitiveTypeFromString(const char *a1, uint64_t a2)
{
  return *(unsigned int *)(glpStringHashGet((uint64_t)&GLP_PRIMITIVE_TYPES, a1, a2) + 4);
}

uint64_t glpPrimitiveTypeGetPrimitiveType(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

uint64_t glpDeepCopyType(_QWORD *a1, uint64_t a2)
{
  uint64_t StructType;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  void **v17;
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  char *v31;
  size_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  StructType = a2;
  switch(*(_DWORD *)a2)
  {
    case 0:
      return StructType;
    case 1:
      v44 = &v42;
      v4 = *(unsigned int *)(a2 + 4);
      v5 = MEMORY[0x24BDAC7A8](a1);
      v6 = &v42 - 2 * v4;
      v7 = 8 * v4;
      MEMORY[0x24BDAC7A8](v5);
      v8 = (8 * v4 + 15) & 0xFFFFFFFF0;
      v9 = (char *)&v42 - v8;
      if ((unint64_t)(8 * v4) >= 0x200)
        v10 = 512;
      else
        v10 = 8 * v4;
      bzero((char *)&v42 - v8, v10);
      v12 = MEMORY[0x24BDAC7A8](v11);
      v13 = (char *)&v42 - v8;
      MEMORY[0x24BDAC7A8](v12);
      v14 = (char *)&v42 - v8;
      bzero(v14, v10);
      v43 = v4;
      if ((_DWORD)v4)
      {
        v15 = 0;
        v16 = 0;
        do
        {
          v17 = (void **)&v6[v15];
          *v17 = glpCopyString((uint64_t)a1, *(const void **)(*(_QWORD *)(StructType + 48) + v15 * 8), *(_QWORD *)(*(_QWORD *)(StructType + 48) + v15 * 8 + 8));
          v17[1] = v18;
          *(_QWORD *)&v9[v16] = glpDeepCopyType(a1, *(_QWORD *)(*(_QWORD *)(StructType + 8) + v16));
          v19 = *(_QWORD *)(StructType + 24);
          *(_QWORD *)&v13[v16] = *(_QWORD *)(*(_QWORD *)(StructType + 16) + v16);
          *(_QWORD *)&v14[v16] = glpCopyLayoutObject(a1, *(_QWORD ***)(v19 + v16));
          v16 += 8;
          v15 += 2;
        }
        while (v7 != v16);
      }
      v20 = glpCopyString((uint64_t)a1, *(const void **)(StructType + 32), *(_QWORD *)(StructType + 40));
      StructType = glpMakeStructType(a1, (uint64_t)v20, v21, v43, (uint64_t)v6, (uint64_t)v9, (uint64_t)v13, (uint64_t)v14);
      break;
    case 2:
      v22 = glpDeepCopyType(a1, *(_QWORD *)(a2 + 16));
      v23 = *(_QWORD *)(StructType + 4);
      StructType = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 24, "Array Type");
      *(_QWORD *)StructType = 0;
      *(_QWORD *)(StructType + 8) = 0;
      *(_DWORD *)StructType = 2;
      *(_QWORD *)(StructType + 16) = v22;
      *(_QWORD *)(StructType + 4) = v23;
      break;
    case 3:
      v24 = *(_DWORD *)(a2 + 8);
      v25 = glpDeepCopyType(a1, *(_QWORD *)(a2 + 16));
      v26 = *(_DWORD *)(StructType + 4);
      StructType = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 24, "Bank Type");
      *(_QWORD *)StructType = 0;
      *(_QWORD *)(StructType + 8) = 0;
      *(_DWORD *)(StructType + 4) = v26;
      *(_DWORD *)(StructType + 8) = v24;
      *(_QWORD *)(StructType + 16) = v25;
      *(_DWORD *)StructType = 3;
      break;
    case 4:
      v27 = *(unsigned int *)(a2 + 4);
      v28 = MEMORY[0x24BDAC7A8](a1);
      v29 = (8 * v27 + 15) & 0xFFFFFFFF0;
      v30 = (char *)&v42 - v29;
      MEMORY[0x24BDAC7A8](v28);
      v31 = (char *)&v42 - v29;
      if ((unint64_t)(8 * v27) >= 0x200)
        v32 = 512;
      else
        v32 = 8 * v27;
      bzero((char *)&v42 - v29, v32);
      MEMORY[0x24BDAC7A8](v33);
      v34 = (char *)&v42 - v29;
      bzero(v34, v32);
      if ((_DWORD)v27)
      {
        v35 = 0;
        do
        {
          v36 = *(_QWORD *)(StructType + 8);
          *(_QWORD *)&v30[v35] = *(_QWORD *)(*(_QWORD *)(StructType + 16) + v35);
          *(_QWORD *)&v31[v35] = glpDeepCopyType(a1, *(_QWORD *)(v36 + v35));
          *(_QWORD *)&v34[v35] = glpCopyLayoutObject(a1, *(_QWORD ***)(*(_QWORD *)(StructType + 24) + v35));
          v35 += 8;
        }
        while (8 * v27 != v35);
      }
      v37 = glpDeepCopyType(a1, *(_QWORD *)(StructType + 32));
      StructType = glpMakeFunctionType(a1, v37, v27, (uint64_t)v31, (uint64_t)v30, (uint64_t)v34);
      break;
    case 5:
      v38 = glpCopyString((uint64_t)a1, *(const void **)(a2 + 16), *(_QWORD *)(a2 + 24));
      v40 = v39;
      StructType = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 32, "Subroutine Type");
      *(_OWORD *)StructType = 0u;
      *(_OWORD *)(StructType + 16) = 0u;
      *(_DWORD *)StructType = 5;
      *(_QWORD *)(StructType + 16) = v38;
      *(_QWORD *)(StructType + 24) = v40;
      *(_QWORD *)(StructType + 8) = 0;
      break;
    default:
      abort();
  }
  return StructType;
}

uint64_t glpTypeGetKind(unsigned int *a1)
{
  return *a1;
}

uint64_t glpAggregateTypeGetElementCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

uint64_t glpStructTypeGetFieldName(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16 * a2);
}

uint64_t glpAggregateTypeGetElementType(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
}

uint64_t glpAggregateTypeGetElementFlags(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * a2);
}

uint64_t glpAggregateTypeGetElementLayout(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * a2);
}

uint64_t glpMakeStructType(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16;
  uint64_t v17;

  v16 = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 56, "Struct Type");
  *(_OWORD *)v16 = 0u;
  *(_OWORD *)(v16 + 16) = 0u;
  *(_OWORD *)(v16 + 32) = 0u;
  *(_QWORD *)(v16 + 48) = 0;
  *(_DWORD *)v16 = 1;
  initAggregateType(a1, v16, a4, a6, a7, a8);
  *(_QWORD *)(v16 + 48) = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 16 * a4, "Struct type (field name storage)");
  if (a4)
  {
    v17 = 0;
    do
    {
      *(_OWORD *)(*(_QWORD *)(v16 + 48) + v17) = *(_OWORD *)(a5 + v17);
      v17 += 16;
    }
    while (16 * a4 != v17);
  }
  *(_QWORD *)(v16 + 32) = a2;
  *(_QWORD *)(v16 + 40) = a3;
  return v16;
}

uint64_t glpStructTypeGetName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t glpMakeArrayType(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 24, "Array Type");
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = a2;
  *(_DWORD *)result = 2;
  *(_DWORD *)(result + 4) = a3;
  *(_DWORD *)(result + 8) = a4;
  return result;
}

uint64_t glpArrayTypeGetElementType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t glpArrayTypeGetMaxElementCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t glpMakeBankType(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 24, "Bank Type");
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 4) = a4;
  *(_DWORD *)(result + 8) = a2;
  *(_QWORD *)(result + 16) = a3;
  *(_DWORD *)result = 3;
  return result;
}

uint64_t glpBankTypeGetBank(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t glpBankTypeGetElementType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t glpBankTypeGetElementCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

uint64_t glpMakeFunctionType(_QWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;

  v12 = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 40, "Function Type");
  *(_OWORD *)v12 = 0u;
  *(_OWORD *)(v12 + 16) = 0u;
  *(_QWORD *)(v12 + 32) = 0;
  *(_DWORD *)v12 = 4;
  initAggregateType(a1, v12, a3, a4, a5, a6);
  *(_QWORD *)(v12 + 32) = a2;
  return v12;
}

uint64_t glpFunctionTypeGetReturnType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

double glpMakeSubroutineType(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  double result;

  v7 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 32, "Subroutine Type");
  result = 0.0;
  *(_OWORD *)v7 = 0u;
  *(_OWORD *)(v7 + 16) = 0u;
  *(_DWORD *)v7 = 5;
  *(_QWORD *)(v7 + 16) = a2;
  *(_QWORD *)(v7 + 24) = a3;
  *(_QWORD *)(v7 + 8) = a4;
  return result;
}

uint64_t glpSubroutineTypeGetName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

_QWORD *glpDestroyType(_QWORD *result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v3 = result;
  switch(*(_DWORD *)a2)
  {
    case 0:
      return result;
    case 1:
      destroyAggregateType(result, a2);
      ((void (*)(_QWORD, _QWORD))v3[3])(*v3, *(_QWORD *)(a2 + 32));
      v5 = *(unsigned int *)(a2 + 4);
      if ((_DWORD)v5)
      {
        v6 = 0;
        v7 = 16 * v5;
        do
        {
          ((void (*)(_QWORD, _QWORD))v3[3])(*v3, *(_QWORD *)(*(_QWORD *)(a2 + 48) + v6));
          v6 += 16;
        }
        while (v7 != v6);
      }
      ((void (*)(_QWORD, _QWORD))v3[3])(*v3, *(_QWORD *)(a2 + 48));
      return (_QWORD *)((uint64_t (*)(_QWORD, uint64_t))v3[3])(*v3, a2);
    case 2:
    case 3:
      v4 = *(_QWORD *)(a2 + 16);
      goto LABEL_8;
    case 4:
      destroyAggregateType(result, a2);
      v4 = *(_QWORD *)(a2 + 32);
LABEL_8:
      glpDestroyType(v3, v4);
      break;
    case 5:
      ((void (*)(_QWORD, _QWORD))result[3])(*result, *(_QWORD *)(a2 + 16));
      break;
    default:
      abort();
  }
  return (_QWORD *)((uint64_t (*)(_QWORD, uint64_t))v3[3])(*v3, a2);
}

uint64_t destroyAggregateType(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = *(unsigned int *)(a2 + 4);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = 8 * v4;
    do
    {
      glpDestroyType(a1, *(_QWORD *)(*(_QWORD *)(a2 + 8) + v5));
      glpDestroyLayoutObject((uint64_t)a1, *(_QWORD ***)(*(_QWORD *)(a2 + 24) + v5));
      v5 += 8;
    }
    while (v6 != v5);
  }
  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, *(_QWORD *)(a2 + 8));
  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, *(_QWORD *)(a2 + 16));
  return ((uint64_t (*)(_QWORD, _QWORD))a1[3])(*a1, *(_QWORD *)(a2 + 24));
}

uint64_t glpTypesEqual(unsigned int *a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int *v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a1 == (unsigned int *)a2)
    return 1;
  v2 = a2;
  v3 = a1;
  while (1)
  {
    result = *v3;
    if ((_DWORD)result != *(_DWORD *)v2)
      return 0;
    if ((_DWORD)result != 5)
      break;
    result = glpStringsEqual(*((const char **)v3 + 2), *((_QWORD *)v3 + 3), *(char **)(v2 + 16), *(_QWORD *)(v2 + 24));
    if (!(_DWORD)result)
      return result;
    v3 = (unsigned int *)**((_QWORD **)v3 + 1);
    v2 = **(_QWORD **)(v2 + 8);
    if (v3 == (unsigned int *)v2)
      return 1;
  }
  switch((int)result)
  {
    case 0:
      return result;
    case 1:
      result = glpStringsEqual(*((const char **)v3 + 4), *((_QWORD *)v3 + 5), *(char **)(v2 + 32), *(_QWORD *)(v2 + 40));
      if (!(_DWORD)result)
        return result;
      result = aggregateGutsEqual((uint64_t)v3, v2);
      if (!(_DWORD)result)
        return result;
      v5 = v3[1];
      if (!(_DWORD)v5)
        return 1;
      v6 = 0;
      v7 = 16 * v5;
      do
      {
        result = glpStringsEqual(*(const char **)(*((_QWORD *)v3 + 6) + v6), *(_QWORD *)(*((_QWORD *)v3 + 6) + v6 + 8), *(char **)(*(_QWORD *)(v2 + 48) + v6), *(_QWORD *)(*(_QWORD *)(v2 + 48) + v6 + 8));
        if (!(_DWORD)result)
          break;
        v6 += 16;
        result = 1;
      }
      while (v7 != v6);
      break;
    case 2:
      result = glpTypesEqual(*((_QWORD *)v3 + 2), *(_QWORD *)(v2 + 16));
      if (!(_DWORD)result)
        return result;
      goto LABEL_21;
    case 3:
      result = glpTypesEqual(*((_QWORD *)v3 + 2), *(_QWORD *)(v2 + 16));
      if (!(_DWORD)result)
        return result;
      if (v3[2] != *(_DWORD *)(v2 + 8))
        return 0;
LABEL_21:
      result = v3[1] == *(_DWORD *)(v2 + 4);
      break;
    case 4:
      result = glpTypesEqual(*((_QWORD *)v3 + 4), *(_QWORD *)(v2 + 32));
      if ((_DWORD)result)
        return aggregateGutsEqual((uint64_t)v3, v2);
      return result;
    default:
      abort();
  }
  return result;
}

uint64_t aggregateGutsEqual(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v5;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 4);
  if (v2 != *(_DWORD *)(a2 + 4))
    return 0;
  if (!v2)
    return 1;
  v5 = 0;
  while (1)
  {
    result = glpTypesEqual(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v5), *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * v5));
    if (!(_DWORD)result)
      break;
    if (((*(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * v5) ^ *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v5)) & 0xFFFFFFFFFFFFFDFFLL) != 0)
      return 0;
    if (++v5 >= (unint64_t)*(unsigned int *)(a1 + 4))
      return 1;
  }
  return result;
}

uint64_t glpArrayTypeGetElementCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

uint64_t glpSubroutineTypeGetFunctionObject(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t glpEachPrimitiveComponentOfType(uint64_t a1, uint64_t a2)
{
  int v3;

  v3 = 0;
  return _eachPrimitiveComponent(a1, (uint64_t)&v3, a2);
}

uint64_t _eachPrimitiveComponent(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;

  v5 = result;
  while (2)
  {
    switch(*(_DWORD *)v5)
    {
      case 0:
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a3 + 16))(a3, *(unsigned int *)(v5 + 4), a2);
      case 1:
        if (*(_DWORD *)(v5 + 4))
        {
          v6 = 0;
          do
          {
            result = _eachPrimitiveComponent(*(_QWORD *)(*(_QWORD *)(v5 + 8) + 8 * v6), a2, a3);
            if (a2)
              break;
            ++v6;
          }
          while (v6 < *(unsigned int *)(v5 + 4));
        }
        return result;
      case 2:
      case 3:
        v5 = *(_QWORD *)(v5 + 16);
        continue;
      case 4:
      case 5:
        abort();
      default:
        return result;
    }
  }
}

uint64_t glpTypeGetSamplerCount(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int Category;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int SamplerCount;

  v2 = 0;
  switch(*(_DWORD *)a1)
  {
    case 0:
      Category = glpPrimitiveTypeGetCategory(*(_DWORD *)(a1 + 4));
      if (Category >= 5)
        goto LABEL_21;
      return dword_22A97FE28[Category];
    case 1:
      v8 = *(unsigned int *)(a1 + 4);
      if (!(_DWORD)v8)
        return 0;
      v9 = 0;
      LODWORD(v2) = 0;
      v10 = 8 * v8;
      do
      {
        SamplerCount = glpTypeGetSamplerCount(*(_QWORD *)(*(_QWORD *)(a1 + 8) + v9));
        if (SamplerCount == -1)
          v2 = 0xFFFFFFFFLL;
        else
          v2 = (SamplerCount + v2);
        v9 += 8;
      }
      while (v10 != v9);
      return v2;
    case 2:
    case 3:
      v3 = glpTypeGetSamplerCount(*(_QWORD *)(a1 + 16));
      v4 = *(_DWORD *)(a1 + 4);
      if (v3)
        v5 = -1;
      else
        v5 = 0;
      v6 = v4 * v3;
      if (v3 == -1)
        v6 = -1;
      if (v4 == -1)
        return v5;
      else
        return v6;
    case 5:
      return v2;
    default:
LABEL_21:
      abort();
  }
}

uint64_t glpTypeIsAtomic(_DWORD *a1)
{
  uint64_t result;
  int Category;

  if ((*a1 - 1) >= 2)
  {
    if (!*a1)
    {
      Category = glpPrimitiveTypeGetCategory(a1[1]);
      result = 1;
      switch(Category)
      {
        case 1:
        case 2:
        case 4:
          return result;
        case 3:
          return 0;
        default:
          break;
      }
    }
    abort();
  }
  return 0;
}

char *glpGetPrimitiveType(unsigned int a1)
{
  return (char *)&GLP_PRIMITIVE_TYPE_ARRAY + 8 * a1;
}

uint64_t glpTypeIsSized(int *a1)
{
  int v1;
  int v3;

  v1 = *a1;
  if (!*a1)
    return 1;
  if (v1 == 2)
    return a1[1] != -1;
  if (v1 != 1)
    abort();
  v3 = 0;
  glpStructTypeGetSizesAndAlignments(0, (uint64_t)a1, 0, &v3, 0, 0);
  return glpTypeSizeIsValid(v3);
}

uint64_t glpStructTypeGetSizesAndAlignments(unsigned int a1, uint64_t a2, uint64_t a3, _DWORD *a4, unsigned int *a5, uint64_t a6)
{
  unsigned int TypeSize;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int Size;
  unsigned int v24;
  unsigned int *v25;
  uint64_t result;
  unsigned int *v27;
  _DWORD *v28;
  unsigned int *v29;

  TypeSize = glpMakeTypeSize(0);
  v12 = glpABIGetMinimumStructAlignment(a1);
  v13 = *(unsigned int *)(a2 + 4);
  v28 = a4;
  v29 = a5;
  if ((int)v13 >= 1)
  {
    v14 = 0;
    v15 = 8 * v13;
    do
    {
      v16 = TypeSize;
      if (glpTypeSizeIsValid(TypeSize))
      {
        v17 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + v14);
        v18 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + v14) | a3;
        v19 = glpABIGetTypeSize(a1, v17, v18);
        v20 = v19;
        if (glpTypeSizeIsValid(v19))
        {
          v21 = glpABIGetTypeAlign(a1, v17, v18);
          v22 = (v21 + glpTypeSizeGetSize(v16) - 1) / v21 * v21;
          Size = glpTypeSizeGetSize(v20);
          v24 = Size;
          if (v21 > v12)
            v12 = v21;
          TypeSize = glpMakeTypeSize(v22 + Size);
          if (a6)
          {
            v25 = (unsigned int *)(a6 + v14);
            *v25 = v22;
            v25[1] = v24;
          }
        }
        else
        {
          TypeSize = glpInvalidTypeSize();
        }
      }
      v14 += 8;
    }
    while (v15 != v14);
  }
  result = glpTypeSizeIsValid(TypeSize);
  if ((_DWORD)result)
  {
    if (v28)
    {
      result = glpAlignTypeSize(TypeSize, v12);
      *v28 = result;
    }
    v27 = v29;
    if (!v29)
      return result;
LABEL_20:
    *v27 = v12;
    return result;
  }
  if (v28)
  {
    result = glpInvalidTypeSize();
    *v28 = result;
  }
  v27 = v29;
  if (v29)
  {
    v12 = -1;
    goto LABEL_20;
  }
  return result;
}

uint64_t initAggregateType(_QWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;

  *(_DWORD *)(a2 + 4) = a3;
  v12 = 8 * a3;
  *(_QWORD *)(a2 + 8) = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v12, "Aggregate type (element type storage)");
  *(_QWORD *)(a2 + 16) = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v12, "Aggregate type (element flag storage)");
  result = ((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v12, "Aggregate type (element layout storage)");
  *(_QWORD *)(a2 + 24) = result;
  if (a3)
  {
    v14 = 0;
    do
    {
      *(_QWORD *)(*(_QWORD *)(a2 + 8) + v14) = *(_QWORD *)(a4 + v14);
      v15 = *(_QWORD *)(a2 + 24);
      *(_QWORD *)(*(_QWORD *)(a2 + 16) + v14) = *(_QWORD *)(a5 + v14);
      *(_QWORD *)(v15 + v14) = *(_QWORD *)(a6 + v14);
      v14 += 8;
    }
    while (8 * a3 != v14);
  }
  return result;
}

uint64_t glpAggregateTypeMangleName(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *StringBuffer;
  unint64_t v8;

  StringBuffer = glpMakeStringBuffer(a4);
  glpStringBufferAppendCString(StringBuffer, "#");
  glpStringBufferAppendString(StringBuffer, a2, a3);
  if (*(_DWORD *)(a1 + 4))
  {
    v8 = 0;
    do
    {
      glpStringBufferAppendCString(StringBuffer, "@");
      appendTypeName(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v8++), StringBuffer);
    }
    while (v8 < *(unsigned int *)(a1 + 4));
  }
  return glpStringBufferGetString((uint64_t)StringBuffer);
}

void *appendTypeName(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v11;

  switch(*(_DWORD *)a1)
  {
    case 0:
      v11 = glpPrimitiveTypeToString(*(_DWORD *)(a1 + 4));
      return glpStringBufferAppendCString(a2, v11);
    case 1:
      return (void *)glpStringBufferAppendString(a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
    case 2:
    case 3:
      appendTypeName(*(_QWORD *)(a1 + 16), a2);
      if (*(_DWORD *)(a1 + 4) != -1)
        return (void *)glpStringBufferAppendFormat(a2, "[%u]", v4, v5, v6, v7, v8, v9, *(_DWORD *)(a1 + 4));
      v11 = "[]";
      return glpStringBufferAppendCString(a2, v11);
    case 5:
      appendTypeName_cold_1(a1, (uint64_t)a2);
      goto LABEL_9;
    default:
LABEL_9:
      abort();
  }
}

uint64_t glpStructTypeGetFieldIndex(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = *(unsigned int *)(a1 + 4);
  if (!(_DWORD)v3)
    return 0xFFFFFFFFLL;
  v7 = 0;
  v8 = 0;
  v9 = 16 * v3;
  while (!glpStringsEqual(a2, a3, *(char **)(*(_QWORD *)(a1 + 48) + v7), *(_QWORD *)(*(_QWORD *)(a1 + 48) + v7 + 8)))
  {
    v7 += 16;
    v8 = (v8 + 1);
    if (v9 == v7)
      return 0xFFFFFFFFLL;
  }
  return v8;
}

uint64_t glpTypeParseDeref(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, uint64_t), uint64_t a3, unsigned int a4, _QWORD *a5, uint64_t *a6, _DWORD *a7)
{
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  _BOOL4 v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int FieldIndex;
  unsigned int v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  unsigned __int8 *v30;
  int v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t result;
  uint64_t v41;
  uint64_t v44;
  int v45;
  char *v46;

  v9 = 0;
  v10 = 0;
  v11 = 0;
  LODWORD(v12) = 0;
  v45 = 0;
  v13 = 0;
  v14 = 0;
  v44 = 0;
  v41 = a3 + 1;
  v15 = 1;
  do
  {
    if (v9 == a4)
    {
      v16 = v15 != 0;
      if (v11 == a4 && !v15)
        goto LABEL_46;
LABEL_12:
      if (!v16)
        return 0;
      v19 = v9 - v11;
      if (v19 >> 5 >= v19)
      {
        v21 = v9 - v11;
      }
      else
      {
        v20 = v9 - v11;
        LODWORD(v21) = v9 - v11;
        do
        {
          v21 = (32 * (_DWORD)v21 + (v21 >> 2) + *(char *)(a3 + (int)v11 + v20 - 1)) ^ v21;
          v20 += ~(v19 >> 5);
        }
        while (v20 > v19 >> 5);
      }
      v22 = v19 | (v21 << 32);
      if (v13)
      {
        if (*(_DWORD *)v13 != 1)
          return 0;
        FieldIndex = glpStructTypeGetFieldIndex(v13, (const char *)(a3 + (int)v11), v22);
        if (FieldIndex == -1)
          return 0;
        v24 = FieldIndex;
        v25 = *(_QWORD *)(*(_QWORD *)(v13 + 8) + 8 * FieldIndex);
        v26 = glpABIGetStructTypeRangeOfField(0, v13, v10, FieldIndex);
        v12 = HIDWORD(v26);
        v45 += v26;
        v10 |= *(_QWORD *)(*(_QWORD *)(v13 + 16) + 8 * v24) & 0x400;
        v22 = v14;
        v13 = v25;
      }
      else
      {
        v27 = a2(a1, a3 + (int)v11, v22);
        if (v27 == -1)
        {
          v13 = 0;
          v15 = 1;
          v44 = a3 + (int)v11;
          v14 = v22;
          goto LABEL_43;
        }
        v13 = v27;
        if (!v27)
          return 0;
        v28 = glpABIGetTypeSize(0, v27, 0);
        LODWORD(v12) = glpTypeSizeGetSize(v28);
        v45 = 0;
        v44 = a3 + (int)v11;
      }
      v11 = v9 + 1;
      if (v9 == a4)
      {
        v15 = 0;
        v14 = v22;
        v9 = a4;
        goto LABEL_43;
      }
      v18 = (int)v9;
      v17 = *(unsigned __int8 *)(a3 + (int)v9);
      v14 = v22;
      goto LABEL_28;
    }
    v17 = *(unsigned __int8 *)(a3 + (int)v9);
    if (v17 != 91 && v17 != 46)
      goto LABEL_43;
    v16 = v15 != 0;
    if (v9 != v11 || v15)
      goto LABEL_12;
    if (!*(_DWORD *)v13)
      return 0;
    v18 = (int)v9;
    v11 = v9;
LABEL_28:
    if (v17 == 46)
    {
      v15 = *(_DWORD *)v13;
      if (*(_DWORD *)v13 != 1)
        return 0;
      v11 = v9 + 1;
    }
    else
    {
      if (v17 == 91)
      {
        v29 = v18 << 32;
        v30 = (unsigned __int8 *)(v41 + v18);
        v9 = v18;
        while (++v9 < a4)
        {
          v31 = *v30++;
          v29 += 0x100000000;
          if ((v31 - 48) >= 0xA)
          {
            if (v11 != v9)
            {
              v32 = v29 >> 32;
              if (*(_BYTE *)(a3 + (v29 >> 32)) == 93)
              {
                v46 = 0;
                v33 = strtoul_l((const char *)(a3 + (int)v11), &v46, 10, 0);
                if (*(_DWORD *)v13 == 2 && *(_BYTE *)(a3 + v32) == 93)
                {
                  v34 = v33;
                  if (*(_DWORD *)(v13 + 4) > v33)
                  {
                    v11 = v9 + 1;
                    v13 = *(_QWORD *)(v13 + 16);
                    v35 = glpABIGetTypeSize(0, v13, 0);
                    v45 += glpTypeSizeGetSize(v35) * v34;
                    v36 = glpABIGetTypeSize(0, v13, 0);
                    LODWORD(v12) = glpTypeSizeGetSize(v36);
                    goto LABEL_39;
                  }
                }
              }
            }
            return 0;
          }
        }
        return 0;
      }
LABEL_39:
      v15 = 0;
    }
LABEL_43:
    ++v9;
  }
  while (v9 <= a4);
  if (v15)
    return 0;
LABEL_46:
  *a5 = v44;
  a5[1] = v14;
  *a6 = v13;
  result = 1;
  *a7 = v45;
  a7[1] = v12;
  return result;
}

uint64_t glpTypeHumanReadableDescription(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *StringBuffer;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unint64_t v18;
  uint64_t result;
  char v20;

  switch(*(_DWORD *)a1)
  {
    case 0:
      v12 = glpPrimitiveTypeToString(*(_DWORD *)(a1 + 4));
      v13 = strlen(v12);
      if (v13 >> 5 < v13)
      {
        v14 = v13;
        v15 = v13;
        do
        {
          v15 ^= 32 * v15 + (v15 >> 2) + v12[v14 - 1];
          v14 += ~(v13 >> 5);
        }
        while (v14 > v13 >> 5);
      }
      goto LABEL_18;
    case 1:
      v12 = *(char **)(a1 + 32);
      goto LABEL_18;
    case 2:
    case 3:
      StringBuffer = glpMakeStringBuffer(a4);
      humanReadableDescriptionToBuffer(*(_DWORD **)(a1 + 16), StringBuffer);
      if (*(_DWORD *)(a1 + 4) == -1)
        glpStringBufferAppendFormat(StringBuffer, "[]", v6, v7, v8, v9, v10, v11, v20);
      else
        glpStringBufferAppendFormat(StringBuffer, "[%u]", v6, v7, v8, v9, v10, v11, *(_DWORD *)(a1 + 4));
      goto LABEL_17;
    case 4:
      StringBuffer = glpMakeStringBuffer(a4);
      humanReadableDescriptionToBuffer(*(_DWORD **)(a1 + 32), StringBuffer);
      glpStringBufferAppendCString(StringBuffer, " ");
      glpStringBufferAppendString(StringBuffer, a2, a3);
      glpStringBufferAppendCString(StringBuffer, "(");
      if (*(_DWORD *)(a1 + 4))
      {
        v18 = 0;
        do
        {
          if (v18)
            glpStringBufferAppendCString(StringBuffer, ", ");
          humanReadableDescriptionToBuffer(*(_DWORD **)(*(_QWORD *)(a1 + 8) + 8 * v18++), StringBuffer);
        }
        while (v18 < *(unsigned int *)(a1 + 4));
      }
      glpStringBufferAppendCString(StringBuffer, ")");
LABEL_17:
      result = glpStringBufferGetString((uint64_t)StringBuffer);
      break;
    case 5:
      v12 = *(char **)(a1 + 16);
LABEL_18:
      result = (uint64_t)v12;
      break;
    default:
      abort();
  }
  return result;
}

_DWORD *humanReadableDescriptionToBuffer(_DWORD *result, uint64_t *a2)
{
  char *v3;
  uint64_t v4;
  uint64_t v5;

  switch(*result)
  {
    case 0:
      v3 = glpPrimitiveTypeToString(result[1]);
      goto LABEL_4;
    case 1:
      v4 = *((_QWORD *)result + 4);
      v5 = *((_QWORD *)result + 5);
      goto LABEL_7;
    case 2:
    case 3:
      humanReadableDescriptionToBuffer(*((_QWORD *)result + 2), a2);
      v3 = "[]";
LABEL_4:
      result = glpStringBufferAppendCString(a2, v3);
      break;
    case 4:
      abort();
    case 5:
      v4 = *((_QWORD *)result + 2);
      v5 = *((_QWORD *)result + 3);
LABEL_7:
      result = (_DWORD *)glpStringBufferAppendString(a2, v4, v5);
      break;
    default:
      return result;
  }
  return result;
}

void *glpDumpTypeToStringBuffer(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  void *result;
  uint64_t *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char v34;
  char v35;
  char v36;

  if (a2)
  {
    v10 = a2;
    while (1)
    {
      if (*(_DWORD *)v10 != 5)
      {
        switch(*(_DWORD *)v10)
        {
          case 0:
            v35 = glpPrimitiveTypeToString(*(_DWORD *)(v10 + 4));
            return (void *)glpStringBufferAppendFormat(a1, "%s", v14, v15, v16, v17, v18, v19, v35);
          case 1:
            return (void *)glpStringBufferAppendFormat(a1, "struct %.*s", a3, a4, a5, a6, a7, a8, *(_QWORD *)(v10 + 40));
          case 2:
            v20 = "array<";
            goto LABEL_13;
          case 3:
            v20 = "bank<";
LABEL_13:
            glpStringBufferAppendCString(a1, v20);
            glpDumpTypeToStringBuffer(a1, *(_QWORD *)(v10 + 16));
            if (*(_DWORD *)(v10 + 4) == -1)
              return glpStringBufferAppendCString(a1, ", ?>");
            else
              return (void *)glpStringBufferAppendFormat(a1, ", %u>", v21, v22, v23, v24, v25, v26, *(_DWORD *)(v10 + 4));
          case 4:
            glpDumpTypeToStringBuffer(a1, *(_QWORD *)(v10 + 32));
            glpStringBufferAppendFormat(a1, " (*)(", v27, v28, v29, v30, v31, v32, v34);
            if (*(_DWORD *)(v10 + 4))
            {
              v33 = 0;
              do
              {
                if (v33)
                  glpStringBufferAppendFormat(a1, ", ", a3, a4, a5, a6, a7, a8, v36);
                glpDumpTypeToStringBuffer(a1, *(_QWORD *)(*(_QWORD *)(v10 + 8) + 8 * v33++));
              }
              while (v33 < *(unsigned int *)(v10 + 4));
            }
            v13 = ")";
            return (void *)glpStringBufferAppendFormat(a1, v13, a3, a4, a5, a6, a7, a8, a9);
          default:
            abort();
        }
      }
      result = (void *)glpStringBufferAppendFormat(a1, "subroutine %.*s: ", a3, a4, a5, a6, a7, a8, *(_QWORD *)(v10 + 24));
      v12 = *(uint64_t **)(v10 + 8);
      if (!v12)
        break;
      v10 = *v12;
      if (!*v12)
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    v13 = "NULL";
    return (void *)glpStringBufferAppendFormat(a1, v13, a3, a4, a5, a6, a7, a8, a9);
  }
  return result;
}

const char *glpUnaryOperatorStringToSymbol(char *__s2)
{
  if (!strcmp("pos", __s2))
    return "+";
  if (!strcmp("neg", __s2))
    return "-";
  if (!strcmp("not", __s2))
    return "!";
  if (strcmp("comp", __s2))
    abort();
  return "~";
}

uint64_t glpAnalyzeUnaryMathOp(uint64_t a1, uint64_t a2)
{
  uint64_t Expr;
  _QWORD *Allocator;
  int Kind;
  const char *v7;
  uint64_t v8;
  uint64_t UnopFuncallFragment;
  __n128 v11;

  Expr = glpUnaryOperatorNodeGetExpr(a2);
  Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
  glpASTNodeGetLocation(a2, &v11);
  Kind = glpASTNodeGetKind(a2);
  v7 = "$OP_comp";
  v8 = 0xEBA2867D00000008;
  switch(Kind)
  {
    case 15:
      v7 = "$OP_pos";
      v8 = 0xA31C9B1600000007;
      break;
    case 16:
      v7 = "$OP_neg";
      v8 = 0x34DF279C00000007;
      break;
    case 17:
      v7 = "$OP_not";
      v8 = 0x9366A7C400000007;
      break;
    case 18:
      break;
    default:
      abort();
  }
  UnopFuncallFragment = glpMakeUnopFuncallFragment(Allocator, &v11, (uint64_t)v7, v8, Expr);
  return glpSANode(a1, UnopFuncallFragment);
}

const char *glpBinaryOperatorStringToSymbol(char *__s2)
{
  if (!strcmp("slt", __s2))
    return "<";
  if (!strcmp("sle", __s2))
    return "<=";
  if (!strcmp("sgt", __s2))
    return ">";
  if (!strcmp("sge", __s2))
    return ">=";
  if (!strcmp("seq", __s2))
    return "==";
  if (!strcmp("sne", __s2))
    return "!=";
  if (!strcmp("mul", __s2))
    return "*";
  if (!strcmp("div", __s2))
    return "/";
  if (!strcmp("mod", __s2))
    return "%";
  if (!strcmp("add", __s2))
    return "+";
  if (!strcmp("sub", __s2))
    return "-";
  if (!strcmp("and", __s2))
    return "&";
  if (!strcmp("or", __s2))
    return "|";
  if (!strcmp("xor", __s2))
    return "^";
  if (!strcmp("shl", __s2))
    return "<<";
  if (!strcmp("shr", __s2))
    return ">>";
  if (!strcmp("anl", __s2))
    return "&&";
  if (!strcmp("orl", __s2))
    return "||";
  if (strcmp("xrl", __s2))
    abort();
  return "^^";
}

uint64_t glpAnalyzeBinaryMathOp(uint64_t a1, uint64_t a2)
{
  uint64_t Lhs;
  uint64_t Rhs;
  _QWORD *Allocator;
  int Kind;
  const char *v8;
  uint64_t v9;
  uint64_t BinopFuncallFragment;
  __n128 v12;

  Lhs = glpBinaryOperatorNodeGetLhs(a2);
  Rhs = glpBinaryOperatorNodeGetRhs(a2);
  Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
  glpASTNodeGetLocation(a2, &v12);
  Kind = glpASTNodeGetKind(a2);
  v8 = "$OP_xrl";
  v9 = 0xCB2BD55100000007;
  switch(Kind)
  {
    case 19:
      v8 = "$OP_mul";
      v9 = 0x952C13B700000007;
      break;
    case 20:
      v8 = "$OP_div";
      v9 = 0xF835D66B00000007;
      break;
    case 21:
      v8 = "$OP_mod";
      v9 = 0x2827016500000007;
      break;
    case 22:
      v8 = "$OP_add";
      v9 = 0xBD95F1700000007;
      break;
    case 23:
      v8 = "$OP_sub";
      v9 = 0x597AE55300000007;
      break;
    case 24:
      v8 = "$OP_shl";
      v9 = 0xC08132B300000007;
      break;
    case 25:
      v8 = "$OP_shr";
      v9 = 0x4CDCFCD000000007;
      break;
    case 26:
      v8 = "$OP_slt";
      v9 = 0x7B30B0FF00000007;
      break;
    case 27:
      v8 = "$OP_sle";
      v9 = 0xA153270000000007;
      break;
    case 28:
      v8 = "$OP_sgt";
      v9 = 0x1F55519B00000007;
      break;
    case 29:
      v8 = "$OP_sge";
      v9 = 0x1B1FEDA500000007;
      break;
    case 30:
      v8 = "$OP_seq";
      v9 = 0x8C71514400000007;
      break;
    case 31:
      v8 = "$OP_sne";
      v9 = 0x97C1FFE700000007;
      break;
    case 32:
      v8 = "$OP_anl";
      v9 = 0x6C41D90B00000007;
      break;
    case 33:
      v8 = "$OP_orl";
      v9 = 0xCEE17B3300000007;
      break;
    case 34:
      break;
    case 35:
      v8 = "$OP_and";
      v9 = 0x2CFF98A600000007;
      break;
    case 36:
      v8 = "$OP_or";
      v9 = 0x77FE58B000000006;
      break;
    case 37:
      v8 = "$OP_xor";
      v9 = 0x8ADCA24100000007;
      break;
    default:
      abort();
  }
  BinopFuncallFragment = glpMakeBinopFuncallFragment(Allocator, &v12, (uint64_t)v8, v9, Lhs, Rhs);
  return glpSANode(a1, BinopFuncallFragment);
}

uint64_t glpCheckAndSanitizeConstructorCall(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int *SaType;
  uint64_t PrimitiveType;
  int v7;
  uint64_t v8;
  unsigned int *v9;
  char v10;
  char v11;
  int v12;
  uint64_t v13;
  uint64_t Allocator;
  uint64_t ElementType;
  int v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  char v22;
  char v23;
  uint64_t **v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t **InfoLog;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _BOOL4 DoesTypeRequirePrecision;
  uint64_t **v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  __n128 *v42;
  uint64_t NameTable;
  unsigned int v46;
  int Category;
  char v48;
  char v49;
  __n128 v50;
  __n128 v51;
  __n128 v52;
  void *v53;
  void *v54;
  __n128 *v55;
  int *v56;
  uint64_t v57;
  uint64_t v58;
  int *v59;
  uint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t v63;
  __n128 v64;
  uint64_t v65;
  uint64_t v66;

  v4 = glpConstructorCallNodeGetType(a2);
  SaType = (int *)glpASTNodeGetSaType(v4);
  switch(glpTypeGetKind((unsigned int *)SaType))
  {
    case 0u:
      PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType);
      if (glpPrimitiveTypeGetCategory(PrimitiveType) - 1 > 2)
      {
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v51);
        v49 = glpPrimitiveTypeToString(PrimitiveType);
        glpLogMessage(InfoLog, 0, (uint64_t)&v51, "Primitive type '%s' can't be constructed", v30, v31, v32, v33, v49);
        return glpSAFailed();
      }
      v7 = glpCallNodeGetArgCount(a2);
      if (!v7)
      {
        v36 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v52);
        v41 = "Constructor of primitive type must have at least one argument";
        v42 = &v52;
LABEL_31:
        glpLogMessage(v36, 0, (uint64_t)v42, v41, v37, v38, v39, v40, v48);
        return glpSAFailed();
      }
      if (v7 != 1)
        goto LABEL_6;
      v8 = glpCallNodeGetArg(a2, 0);
      v9 = (unsigned int *)glpASTNodeGetSaType(v8);
      if (glpTypeGetKind(v9))
        goto LABEL_6;
      v46 = glpPrimitiveTypeGetPrimitiveType((uint64_t)v9);
      Category = glpPrimitiveTypeGetCategory(v46);
      if (Category == 3)
      {
        v11 = 0;
        v10 = 1;
      }
      else
      {
        if (Category == 1)
          v10 = 0;
        else
LABEL_6:
          v10 = 1;
        v11 = 1;
      }
      v12 = glpPrimitiveTypeGetCategory(PrimitiveType);
      if (v12 != 3)
      {
        if (v12 == 2)
        {
          if ((v10 & 1) == 0)
            return _checkAndSanitizeSplat(a1, a2, PrimitiveType);
        }
        else if (v12 != 1)
        {
LABEL_11:
          abort();
        }
        return _checkAndSanitizeComponentwiseConstructorCall(a1, a2, PrimitiveType);
      }
      if ((v10 & 1) == 0)
        return _checkAndSanitizeDiagonalMatrixConstructorCall(a1, a2, PrimitiveType);
      if ((v11 & 1) != 0)
        return _checkAndSanitizeComponentwiseConstructorCall(a1, a2, PrimitiveType);
      NameTable = glpCompilerGetNameTable(a1);
      if (glpNameTableGetGLSLVersion(NameTable) != 1)
        return _checkAndSanitizeSubOrSuperMatrixConstructorCall(a1, a2, PrimitiveType);
      v36 = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a2, &v64);
      v41 = "GLSL 110 does not allow sub- or super-matrix constructors";
      v42 = &v64;
      goto LABEL_31;
    case 1u:
      v64.n128_u64[0] = 0;
      v64.n128_u64[1] = (unint64_t)&v64;
      v65 = 0x2000000000;
      v66 = 96;
      v52.n128_u64[0] = MEMORY[0x24BDAC760];
      v52.n128_u64[1] = 0x40000000;
      v53 = ___checkAndSanitizeStructConstructorCall_block_invoke;
      v54 = &unk_24F4B0B78;
      v55 = &v64;
      v56 = SaType;
      v57 = a1;
      if (_checkConstructorArgs(a1, a2, (uint64_t)&v52))
        v13 = _elementwiseConstructor(a1, a2, (uint64_t)SaType, 0, *(_QWORD *)(v64.n128_u64[1] + 24));
      else
        v13 = glpSAFailed();
      v34 = v13;
      goto LABEL_26;
    case 2u:
      if (!glpTypeIsSized(SaType))
      {
        Allocator = glpCompilerGetAllocator(a1);
        ElementType = glpArrayTypeGetElementType((uint64_t)SaType);
        v16 = glpCallNodeGetArgCount(a2);
        SaType = (int *)glpMakeArrayType(Allocator, ElementType, v16, -1);
      }
      v17 = glpArrayTypeGetElementType((uint64_t)SaType);
      v64.n128_u64[0] = 0;
      v64.n128_u64[1] = (unint64_t)&v64;
      v65 = 0x2000000000;
      v66 = 0;
      v60 = 0;
      v61 = &v60;
      v62 = 0x2000000000;
      v63 = 96;
      v52.n128_u64[0] = MEMORY[0x24BDAC760];
      v52.n128_u64[1] = 0x40000000;
      v53 = ___checkAndSanitizeArrayConstructorCall_block_invoke;
      v54 = &unk_24F4B0B30;
      v55 = &v64;
      v56 = (int *)&v60;
      v57 = v17;
      v58 = a1;
      v59 = SaType;
      if (_checkConstructorArgs(a1, a2, (uint64_t)&v52))
      {
        v18 = v64.n128_u64[1];
        if (v61[3])
          goto LABEL_18;
        if (!*(_QWORD *)(v64.n128_u64[1] + 24))
        {
          v19 = 0;
          goto LABEL_19;
        }
        DoesTypeRequirePrecision = glpCompilerDoesTypeRequirePrecision(a1, (unsigned int *)SaType);
        v18 = v64.n128_u64[1];
        if (!DoesTypeRequirePrecision)
        {
LABEL_18:
          v19 = 0;
          *(_QWORD *)(v18 + 24) = 0;
        }
        else
        {
          v19 = *(_QWORD *)(v64.n128_u64[1] + 24);
        }
LABEL_19:
        v20 = _elementwiseConstructor(a1, a2, (uint64_t)SaType, v19, v61[3]);
        goto LABEL_25;
      }
      v20 = glpSAFailed();
LABEL_25:
      v34 = v20;
      _Block_object_dispose(&v60, 8);
LABEL_26:
      _Block_object_dispose(&v64, 8);
      return v34;
    case 5u:
      v21 = (_QWORD *)glpCompilerGetAllocator(a1);
      glpTypeHumanReadableDescription((uint64_t)SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v21);
      v23 = v22;
      v24 = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a2, &v50);
      glpLogMessage(v24, 0, (uint64_t)&v50, "Subroutine type '%.*s' can't be constructed", v25, v26, v27, v28, v23);
      return glpSAFailed();
    default:
      goto LABEL_11;
  }
}

uint64_t glpLowerNonatomicTypeConversion(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t Expr;
  uint64_t Allocator;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  char SaFlags;
  _QWORD v15[6];
  __n128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v4 = glpTypeConversionNodeGetToType(a2);
  v5 = glpTypeConversionNodeGetToPrecision(a2);
  v18 = 0;
  v19 = 0;
  Expr = glpUnaryOperatorNodeGetExpr(a2);
  glpHandleSideEffectsForExpr(a1, Expr, &v18, &v19);
  Allocator = glpCompilerGetAllocator(a1);
  v16.n128_u64[0] = (unint64_t)"-1";
  v16.n128_u64[1] = 0xEDA00000002;
  v17 = 0xFFFFFFFFLL;
  glpMakeCommaExprNode(Allocator, &v16, 0);
  v9 = v8;
  v10 = v19;
  if (v19)
  {
    v11 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v11, v9, v10);
  }
  v12 = v18;
  SaFlags = glpASTNodeGetSaFlags(v18);
  v15[0] = MEMORY[0x24BDAC760];
  v15[1] = 0x40000000;
  v15[2] = __glpLowerNonatomicTypeConversion_block_invoke;
  v15[3] = &__block_descriptor_tmp_10;
  v15[4] = a1;
  v15[5] = v12;
  return _constructor(a1, v4, v9, v5, SaFlags & 0x60, (uint64_t)v15);
}

uint64_t glpHandleSideEffectsForExpr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t Offset;
  uint64_t v16;
  uint64_t BankIndex;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  int ExprCount;
  uint64_t OffsetExpr;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  int v26;
  uint64_t VectorElementExpr;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t Allocator;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __n128 v45;
  uint64_t v46;

  v7 = glpFlattenCommaTree(a1, a2);
  v8 = glpSANode(a1, v7);
  v9 = glpCommaResult(v8);
  result = glpASTNodeGetKind(v9);
  if ((result - 81) >= 2)
  {
    if ((_DWORD)result == 3)
    {
      if (v9 == v8)
        v34 = 0;
      else
        v34 = v8;
      *a4 = v34;
      *a3 = v9;
    }
    else
    {
      v43 = 0;
      v44 = 0;
      _tempForExpr(a1, v8, &v44, &v43);
      Allocator = glpCompilerGetAllocator(a1);
      v45.n128_u64[0] = (unint64_t)"-1";
      v45.n128_u64[1] = 0xEDA00000002;
      v46 = 0xFFFFFFFFLL;
      glpMakeCommaExprNode(Allocator, &v45, 0);
      v37 = v36;
      v38 = (_QWORD *)glpCompilerGetAllocator(a1);
      glpCommaExprNodeAddExpr(v38, v37, v44);
      v39 = (_QWORD *)glpCompilerGetAllocator(a1);
      v40 = v43;
      v41 = (uint64_t *)glpCompilerGetAllocator(a1);
      v42 = glpDeepCopyASTNode(v41, v40, (uint64_t (*)(uint64_t, uint64_t *, _DWORD *))getAccessorReplaceCallback, 0);
      result = (uint64_t)glpCommaExprNodeAddExpr(v39, v37, v42);
      *a4 = v37;
      *a3 = v40;
    }
  }
  else
  {
    if (v9 == v8)
    {
      v11 = glpCompilerGetAllocator(a1);
      v45.n128_u64[0] = (unint64_t)"-1";
      v45.n128_u64[1] = 0xEDA00000002;
      v46 = 0xFFFFFFFFLL;
      glpMakeCommaExprNode(v11, &v45, 0);
      v13 = v12;
      v14 = (_QWORD *)glpCompilerGetAllocator(a1);
      glpCommaExprNodeAddExpr(v14, v13, v8);
      v8 = v13;
    }
    Offset = glpDerefNodeGetOffset(v9);
    if (Offset)
    {
      v16 = Offset;
      BankIndex = glpOffsetNodeGetBankIndex(Offset);
      if (BankIndex)
      {
        v18 = BankIndex;
        if (!glpIsConstantNode(BankIndex))
        {
          v44 = 0;
          v45.n128_u64[0] = 0;
          _tempForExpr(a1, v18, (uint64_t *)&v45, &v44);
          v19 = (_QWORD *)glpCompilerGetAllocator(a1);
          v20 = v45.n128_u64[0];
          ExprCount = glpCommaExprNodeGetExprCount(v8);
          glpCommaExprNodeInsertExpr(v19, v8, v20, ExprCount - 1);
          glpOffsetNodeSetBankIndex(v16, v44);
        }
      }
      OffsetExpr = glpOffsetNodeGetOffsetExpr(v16);
      if (OffsetExpr)
      {
        v23 = OffsetExpr;
        if (!glpIsConstantNode(OffsetExpr))
        {
          v44 = 0;
          v45.n128_u64[0] = 0;
          _tempForExpr(a1, v23, (uint64_t *)&v45, &v44);
          v24 = (_QWORD *)glpCompilerGetAllocator(a1);
          v25 = v45.n128_u64[0];
          v26 = glpCommaExprNodeGetExprCount(v8);
          glpCommaExprNodeInsertExpr(v24, v8, v25, v26 - 1);
          glpOffsetNodeSetOffsetExpr(v16, v44);
        }
      }
      VectorElementExpr = glpOffsetNodeGetVectorElementExpr(v16);
      if (VectorElementExpr)
      {
        v28 = VectorElementExpr;
        if (!glpIsConstantNode(VectorElementExpr))
        {
          v44 = 0;
          v45.n128_u64[0] = 0;
          _tempForExpr(a1, v28, (uint64_t *)&v45, &v44);
          v29 = (_QWORD *)glpCompilerGetAllocator(a1);
          v30 = v45.n128_u64[0];
          v31 = glpCommaExprNodeGetExprCount(v8);
          glpCommaExprNodeInsertExpr(v29, v8, v30, v31 - 1);
          glpOffsetNodeSetVectorElementExpr(v16, v44);
        }
      }
    }
    if (glpCommaExprNodeGetExprCount(v8) == 1)
      v32 = 0;
    else
      v32 = v8;
    *a4 = v32;
    v33 = (uint64_t *)glpCompilerGetAllocator(a1);
    result = glpDeepCopyASTNode(v33, v9, (uint64_t (*)(uint64_t, uint64_t *, _DWORD *))getAccessorReplaceCallback, 0);
    *a3 = result;
  }
  if (*a4)
  {
    result = glpSANode(a1, *a4);
    *a4 = result;
  }
  return result;
}

uint64_t _constructor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t Allocator;
  uint64_t v13;
  uint64_t v14;
  uint64_t Temporary;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t ValueHash;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t Expr;
  int ExprCount;
  uint64_t SaFlags;
  __n128 v31;
  uint64_t v32;
  uint64_t v33;
  __n128 v34;

  Allocator = glpCompilerGetAllocator(a1);
  glpASTNodeGetLocation(a3, &v34);
  glpMakeCommaExprNode(Allocator, &v34, 0);
  v14 = v13;
  v32 = 0;
  v33 = 0;
  Temporary = glpMakeTemporary(a1, a2, a4, 0, &v33, &v32);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a6 + 16))(a6, v32, v14);
  v16 = v33;
  v17 = glpASTNodeGetSaFlags(v33) & 0xFFFFFFFFFFFFFF7FLL;
  glpASTNodeSetSaFlags(v16, v17);
  *(_QWORD *)(glpVariableDeclarationNodeGetExtra(v16) + 48) = v17;
  v18 = glpSANode(a1, v14);
  glpVariableDeclarationNodeSetInitializer(v16, v18);
  v19 = glpCompilerGetAllocator(a1);
  ValueHash = glpCompilerGetValueHash(a1);
  v21 = glpConstantFold(v19, ValueHash, v16);
  v22 = (_QWORD *)glpCompilerGetAllocator(a1);
  glpCommaExprNodeAddExpr(v22, a3, v21);
  v23 = (_QWORD *)glpCompilerGetAllocator(a1);
  v24 = glpCompilerGetAllocator(a1);
  glpASTNodeGetLocation(a3, &v31);
  glpMakeVariableIdentifierNode(v24, &v31, *(_QWORD *)(Temporary + 32), *(_QWORD *)(Temporary + 40));
  glpCommaExprNodeAddExpr(v23, a3, v25);
  v26 = glpSANode(a1, a3);
  Expr = v26;
  if (glpIsCommaExprNode(v26))
  {
    ExprCount = glpCommaExprNodeGetExprCount(v26);
    Expr = glpCommaExprNodeGetExpr(v26, ExprCount - 1);
  }
  if (glpIsConstantNode(Expr))
  {
    SaFlags = glpASTNodeGetSaFlags(Expr);
    glpASTNodeSetSaFlags(Expr, SaFlags | a5);
    return Expr;
  }
  return v26;
}

uint64_t __glpLowerNonatomicTypeConversion_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t Accessor;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t Allocator;
  uint64_t AssignNode;
  uint64_t v17;
  _QWORD *v18;
  __n128 v19;
  uint64_t v20;

  result = glpGetAccessorCount(a2);
  if ((_DWORD)result)
  {
    v7 = result;
    v8 = 0;
    do
    {
      v9 = *(_QWORD *)(a1 + 32);
      Accessor = glpMakeAccessor(v9, a2, v8);
      v11 = glpSANode(v9, Accessor);
      v12 = *(_QWORD *)(a1 + 32);
      v13 = glpMakeAccessor(v12, *(_QWORD *)(a1 + 40), v8);
      v14 = glpSANode(v12, v13);
      Allocator = glpCompilerGetAllocator(*(_QWORD *)(a1 + 32));
      v19.n128_u64[0] = (unint64_t)"-1";
      v19.n128_u64[1] = 0xEDA00000002;
      v20 = 0xFFFFFFFFLL;
      AssignNode = glpMakeAssignNode(Allocator, &v19, 0);
      glpBinaryOperatorNodeSetLhs(AssignNode, v11);
      glpBinaryOperatorNodeSetRhs(AssignNode, v14);
      v17 = glpSANode(*(_QWORD *)(a1 + 32), AssignNode);
      v18 = (_QWORD *)glpCompilerGetAllocator(*(_QWORD *)(a1 + 32));
      result = (uint64_t)glpCommaExprNodeAddExpr(v18, a3, v17);
      v8 = (v8 + 1);
    }
    while (v7 != (_DWORD)v8);
  }
  return result;
}

uint64_t glpGetAccessorCount(uint64_t a1)
{
  unsigned int *SaType;
  int Kind;
  unsigned int PrimitiveType;
  int v4;

  SaType = (unsigned int *)glpASTNodeGetSaType(a1);
  Kind = glpTypeGetKind(SaType);
  if (Kind == 2)
    return glpArrayTypeGetElementCount((uint64_t)SaType);
  if (Kind == 1)
    return glpAggregateTypeGetElementCount((uint64_t)SaType);
  if (Kind
    || (PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType),
        glpPrimitiveTypeGetCategory(PrimitiveType) != 3))
  {
    abort();
  }
  v4 = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType);
  return glpPrimitiveMatrixGetColumns(v4);
}

uint64_t glpMakeAccessor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int *SaType;
  int Kind;
  unsigned int PrimitiveType;
  uint64_t Allocator;
  uint64_t *v10;
  uint64_t v11;
  uint64_t IntConstant;
  uint64_t v14;
  uint64_t FieldName;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  __n128 v20;
  uint64_t v21;

  SaType = (unsigned int *)glpASTNodeGetSaType(a2);
  Kind = glpTypeGetKind(SaType);
  if (Kind == 2)
  {
LABEL_5:
    Allocator = glpCompilerGetAllocator(a1);
    v10 = (uint64_t *)glpCompilerGetAllocator(a1);
    v11 = glpDeepCopyASTNode(v10, a2, (uint64_t (*)(uint64_t, uint64_t *, _DWORD *))getAccessorReplaceCallback, 0);
    IntConstant = glpCompilerGetIntConstant(a1, a3);
    v20.n128_u64[0] = (unint64_t)"-1";
    v20.n128_u64[1] = 0xEDA00000002;
    v21 = 0xFFFFFFFFLL;
    return glpMakeArrayAccessFragment(Allocator, &v20, v11, IntConstant);
  }
  if (Kind != 1)
  {
    if (Kind
      || (PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType),
          glpPrimitiveTypeGetCategory(PrimitiveType) != 3))
    {
      abort();
    }
    goto LABEL_5;
  }
  v14 = glpCompilerGetAllocator(a1);
  FieldName = glpStructTypeGetFieldName((uint64_t)SaType, a3);
  v17 = v16;
  v18 = (uint64_t *)glpCompilerGetAllocator(a1);
  v19 = glpDeepCopyASTNode(v18, a2, (uint64_t (*)(uint64_t, uint64_t *, _DWORD *))getAccessorReplaceCallback, 0);
  v20.n128_u64[0] = (unint64_t)"-1";
  v20.n128_u64[1] = 0xEDA00000002;
  v21 = 0xFFFFFFFFLL;
  return glpMakeFieldAccessFragment(v14, &v20, FieldName, v17, v19);
}

uint64_t glpMakeTemporary(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, _QWORD *a6)
{
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t Allocator;
  uint64_t TypedVariableFragment;
  uint64_t v17;
  uint64_t NameTable;
  uint64_t SaFlags;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __n128 v24;
  uint64_t v25;
  _QWORD v26[5];
  __n128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  v12 = glpCompilerNewTempName(a1);
  v14 = v13;
  v30 = 0;
  Allocator = glpCompilerGetAllocator(a1);
  v27.n128_u64[0] = (unint64_t)"-1";
  v27.n128_u64[1] = 0xEDA00000002;
  v28 = 0xFFFFFFFFLL;
  TypedVariableFragment = glpMakeTypedVariableFragment(Allocator, &v27, (uint64_t)v12, v14, &v30, a4);
  glpASTNodeSetSaFlags(v30, a3);
  glpASTNodeSetSaType(v30, a2);
  v17 = glpSANode(a1, TypedVariableFragment);
  v27.n128_u64[0] = 0;
  v27.n128_u64[1] = (unint64_t)&v27;
  v28 = 0x2000000000;
  v29 = 0;
  NameTable = glpCompilerGetNameTable(a1);
  v26[0] = MEMORY[0x24BDAC760];
  v26[1] = 0x40000000;
  v26[2] = __glpMakeTemporary_block_invoke;
  v26[3] = &unk_24F4B0A98;
  v26[4] = &v27;
  glpNameTableGet(NameTable, v12, v14, 0, (uint64_t)v26);
  if (v17)
  {
    SaFlags = glpASTNodeGetSaFlags(v17);
    glpASTNodeSetSaFlags(v17, SaFlags & 0xFFFFFFFF7FFFFFFFLL);
  }
  *(_QWORD *)(*(_QWORD *)(v27.n128_u64[1] + 24) + 48) &= ~0x80000000uLL;
  *a5 = v17;
  v20 = glpCompilerGetAllocator(a1);
  v24.n128_u64[0] = (unint64_t)"-1";
  v24.n128_u64[1] = 0xEDA00000002;
  v25 = 0xFFFFFFFFLL;
  glpMakeVariableIdentifierNode(v20, &v24, (uint64_t)v12, v14);
  *a6 = glpSANode(a1, v21);
  v22 = *(_QWORD *)(v27.n128_u64[1] + 24);
  _Block_object_dispose(&v27, 8);
  return v22;
}

uint64_t __glpMakeTemporary_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

uint64_t _tempForExpr(uint64_t a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  char SaFlags;
  uint64_t v9;
  uint64_t v10;
  uint64_t SaType;

  SaFlags = glpASTNodeGetSaFlags(a2);
  if ((SaFlags & 0x60) != 0)
    v9 = SaFlags & 0x60;
  else
    v9 = 256;
  v10 = glpASTNodeGetSaFlags(a2) & 0x1F;
  SaType = glpASTNodeGetSaType(a2);
  return glpMakeTemporary(a1, SaType, v9 | v10, a2, a3, a4);
}

uint64_t glpDuplicateDerefOrConstant(uint64_t a1, uint64_t a2)
{
  uint64_t *Allocator;

  Allocator = (uint64_t *)glpCompilerGetAllocator(a1);
  return glpDeepCopyASTNode(Allocator, a2, (uint64_t (*)(uint64_t, uint64_t *, _DWORD *))getAccessorReplaceCallback, 0);
}

uint64_t glpMangleSideEffectsWithNewResult(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  int ExprCount;
  uint64_t SaType;
  uint64_t SaFlags;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __n128 v14;

  if (!a2)
    return a3;
  v4 = a2;
  if (glpIsCommaExprNode(a2))
  {
    ExprCount = glpCommaExprNodeGetExprCount(v4);
    glpCommaExprNodeSetExpr(v4, ExprCount - 1, a3);
    SaType = glpASTNodeGetSaType(a3);
    glpASTNodeSetSaType(v4, SaType);
    SaFlags = glpASTNodeGetSaFlags(a3);
    glpASTNodeSetSaFlags(v4, SaFlags);
  }
  else
  {
    glpASTNodeGetLocation(a3, &v14);
    glpMakeCommaExprNode((uint64_t)a1, &v14, 0);
    v10 = v9;
    glpCommaExprNodeAddExpr(a1, v9, v4);
    glpCommaExprNodeAddExpr(a1, v10, a3);
    v11 = glpASTNodeGetSaType(a3);
    glpASTNodeSetSaType(v10, v11);
    v12 = glpASTNodeGetSaFlags(a3);
    glpASTNodeSetSaFlags(v10, v12);
    return v10;
  }
  return v4;
}

uint64_t getAccessorReplaceCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int Kind;
  _OWORD *Extra;
  _OWORD *v7;
  __int128 v8;

  Kind = glpASTNodeGetKind(a3);
  if (Kind == 80)
  {
    Extra = (_OWORD *)glpOffsetNodeGetExtra(a3);
    v7 = (_OWORD *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a2 + 8))(*(_QWORD *)a2, 32, "Offset Object (accessor replacement)");
    v8 = Extra[1];
    *v7 = *Extra;
    v7[1] = v8;
    glpOffsetNodeSetExtra(a3, (uint64_t)v7);
  }
  else if (Kind == 7 || Kind == 39)
  {
    abort();
  }
  return a3;
}

uint64_t glpGetScalarAccessorCount(uint64_t a1)
{
  uint64_t SaType;
  uint64_t PrimitiveType;
  uint64_t result;

  SaType = glpASTNodeGetSaType(a1);
  PrimitiveType = glpPrimitiveTypeGetPrimitiveType(SaType);
  result = glpPrimitiveTypeGetCategory(PrimitiveType);
  if ((_DWORD)result != 1)
  {
    if ((_DWORD)result != 2)
      abort();
    return glpPrimitiveVectorGetLength(PrimitiveType);
  }
  return result;
}

uint64_t glpMakeScalarAccessor(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t SaType;
  unsigned int PrimitiveType;
  int Category;
  uint64_t *v9;
  uint64_t Allocator;
  char *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  __n128 v16;
  uint64_t v17;

  SaType = glpASTNodeGetSaType(a2);
  PrimitiveType = glpPrimitiveTypeGetPrimitiveType(SaType);
  Category = glpPrimitiveTypeGetCategory(PrimitiveType);
  if (Category == 2)
  {
    Allocator = glpCompilerGetAllocator(a1);
    v12 = &aXyzw[a3];
    v13 = ((unint64_t)(*v12 ^ 1u) << 32) + 0x2000000001;
    v14 = (uint64_t *)glpCompilerGetAllocator(a1);
    v15 = glpDeepCopyASTNode(v14, a2, (uint64_t (*)(uint64_t, uint64_t *, _DWORD *))getAccessorReplaceCallback, 0);
    v16.n128_u64[0] = (unint64_t)"-1";
    v16.n128_u64[1] = 0xEDA00000002;
    v17 = 0xFFFFFFFFLL;
    return glpMakeFieldAccessFragment(Allocator, &v16, (uint64_t)v12, v13, v15);
  }
  else
  {
    if (Category != 1)
      abort();
    v9 = (uint64_t *)glpCompilerGetAllocator(a1);
    return glpDeepCopyASTNode(v9, a2, (uint64_t (*)(uint64_t, uint64_t *, _DWORD *))getAccessorReplaceCallback, 0);
  }
}

uint64_t _checkAndSanitizeComponentwiseConstructorCall(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int ScalarCount;
  _QWORD *v7;
  unsigned int v8;
  unsigned int *v9;
  uint64_t DoesTypeRequirePrecision;
  unsigned int i;
  uint64_t v12;
  unsigned int *SaType;
  uint64_t DefaultPrecisionForType;
  _QWORD *Allocator;
  char v16;
  char v17;
  uint64_t **InfoLog;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  size_t v25;
  uint64_t ArgsAccessible;
  uint64_t v27;
  uint64_t *v28;
  size_t v29;
  uint64_t v30;
  size_t v31;
  char *v32;
  uint64_t ScalarType;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int *PrimitiveType;
  uint64_t v48;
  __n128 v49;
  uint64_t v50;
  unsigned int v51;
  uint64_t v52;
  __n128 v53;
  _QWORD v54[7];
  int v55;
  uint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD v64[3];
  int v65;
  _QWORD v66[8];

  v66[6] = *MEMORY[0x24BDAC8D0];
  ScalarCount = glpPrimitiveTypeGetScalarCount(a3);
  v64[0] = 0;
  v64[1] = v64;
  v64[2] = 0x2000000000;
  v65 = 0;
  v60 = 0;
  v61 = &v60;
  v62 = 0x2000000000;
  v63 = 96;
  v56 = 0;
  v57 = &v56;
  v58 = 0x2000000000;
  v59 = 0;
  v54[0] = MEMORY[0x24BDAC760];
  v54[1] = 0x40000000;
  v54[2] = ___checkAndSanitizeComponentwiseConstructorCall_block_invoke;
  v54[3] = &unk_24F4B0AC0;
  v54[4] = &v56;
  v54[5] = &v60;
  v54[6] = v64;
  v55 = ScalarCount;
  if (!_checkConstructorArgs(a1, a2, (uint64_t)v54))
  {
    v44 = glpSAFailed();
    goto LABEL_19;
  }
  v7 = v57 + 3;
  if (!v61[3])
  {
    if (!*v7)
      goto LABEL_4;
    PrimitiveType = (unsigned int *)glpGetPrimitiveType(a3);
    if (glpCompilerDoesTypeRequirePrecision(a1, PrimitiveType))
      goto LABEL_4;
    v7 = v57 + 3;
  }
  *v7 = 0;
LABEL_4:
  v8 = glpCallNodeGetArgCount(a2);
  doPrecisionWarningsForLowpInt(a1, a2, a3, v57[3]);
  v9 = (unsigned int *)glpGetPrimitiveType(a3);
  DoesTypeRequirePrecision = glpCompilerDoesTypeRequirePrecision(a1, v9);
  if (!(_DWORD)DoesTypeRequirePrecision && v8)
  {
    for (i = 0; i != v8; ++i)
    {
      v12 = glpCallNodeGetArg(a2, i);
      SaType = (unsigned int *)glpASTNodeGetSaType(v12);
      DoesTypeRequirePrecision = glpCompilerDoesTypeRequirePrecision(a1, SaType);
      if ((_DWORD)DoesTypeRequirePrecision)
      {
        DoesTypeRequirePrecision = glpASTNodeGetSaFlags(v12);
        if ((DoesTypeRequirePrecision & 0x1F) == 0)
        {
          DefaultPrecisionForType = glpGetDefaultPrecisionForType(a1, SaType);
          if (DefaultPrecisionForType)
          {
            DoesTypeRequirePrecision = glpPushdownPrecision(a1, v12, DefaultPrecisionForType);
          }
          else
          {
            Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
            glpTypeHumanReadableDescription((uint64_t)SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
            v17 = v16;
            InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(a2, &v53);
            DoesTypeRequirePrecision = (uint64_t)glpLogMessage(InfoLog, 0, (uint64_t)&v53, "Constructor argument of type '%.*s' - precision can not be inferred and no default precision available", v19, v20, v21, v22, v17);
          }
        }
      }
    }
  }
  v52 = 0;
  MEMORY[0x24BDAC7A8](DoesTypeRequirePrecision);
  v24 = (uint64_t *)((char *)&v48 - v23);
  bzero((char *)&v48 - v23, v25);
  ArgsAccessible = _makeArgsAccessible(a1, a2, v57[3], v24, &v52);
  v51 = 0;
  MEMORY[0x24BDAC7A8](ArgsAccessible);
  v28 = &v48 - v27;
  bzero(v28, v29);
  v30 = _atomicizeArgs(a1, v8, (uint64_t)v24, &v51, (uint64_t)v28);
  v50 = 0;
  LODWORD(v24) = v51;
  MEMORY[0x24BDAC7A8](v30);
  v32 = (char *)&v48 - ((v31 + 15) & 0xFFFFFFFF0);
  bzero(v32, v31);
  ScalarType = glpPrimitiveTypeGetScalarType(a3);
  _convertAccesses(a1, ScalarType, v57[3], v24, v28, &v50, (uint64_t *)v32);
  v34 = glpCompilerGetAllocator(a1);
  glpASTNodeGetLocation(a2, &v49);
  glpMakeCommaExprNode(v34, &v49, 0);
  v36 = v35;
  v37 = v52;
  if (v52)
  {
    v38 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v38, v36, v37);
  }
  v39 = v50;
  if (v50)
  {
    v40 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v40, v36, v39);
  }
  v41 = v57[3];
  v42 = v61[3];
  v43 = glpGetPrimitiveType(a3);
  v66[0] = MEMORY[0x24BDAC760];
  v66[1] = 0x40000000;
  v66[2] = ___componentwiseConstructor_block_invoke;
  v66[3] = &__block_descriptor_tmp_86;
  v66[4] = a1;
  v66[5] = v32;
  v44 = _constructor(a1, (uint64_t)v43, v36, v41, v42, (uint64_t)v66);
LABEL_19:
  v45 = v44;
  _Block_object_dispose(&v56, 8);
  _Block_object_dispose(&v60, 8);
  _Block_object_dispose(v64, 8);
  return v45;
}

uint64_t _checkAndSanitizeSplat(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  unsigned int *PrimitiveType;
  unsigned int *v8;
  uint64_t ScalarType;
  uint64_t ScalarCount;
  unsigned int v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v31;
  unsigned int *SaType;
  uint64_t DefaultPrecisionForType;
  _QWORD *Allocator;
  char v35;
  char v36;
  uint64_t **InfoLog;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __n128 v43;
  uint64_t v44;
  __n128 v45;
  uint64_t v46;
  _QWORD v47[6];
  uint64_t v48;
  uint64_t v49[2];

  v49[1] = *MEMORY[0x24BDAC8D0];
  v46 = 0;
  v49[0] = 0;
  _makeArgsAccessible(a1, a2, 0, v49, &v46);
  v6 = glpASTNodeGetSaFlags(v49[0]) & 0x1F;
  if (v6)
  {
    PrimitiveType = (unsigned int *)glpGetPrimitiveType(a3);
    if (!glpCompilerDoesTypeRequirePrecision(a1, PrimitiveType))
      v6 = 0;
  }
  doPrecisionWarningsForLowpInt(a1, a2, a3, v6);
  v8 = (unsigned int *)glpGetPrimitiveType(a3);
  if (!glpCompilerDoesTypeRequirePrecision(a1, v8))
  {
    v31 = glpCallNodeGetArg(a2, 0);
    SaType = (unsigned int *)glpASTNodeGetSaType(v31);
    if (glpCompilerDoesTypeRequirePrecision(a1, SaType) && (glpASTNodeGetSaFlags(v31) & 0x1F) == 0)
    {
      DefaultPrecisionForType = glpGetDefaultPrecisionForType(a1, SaType);
      if (DefaultPrecisionForType)
      {
        glpPushdownPrecision(a1, v31, DefaultPrecisionForType);
      }
      else
      {
        Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription((uint64_t)SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
        v36 = v35;
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v45);
        glpLogMessage(InfoLog, 0, (uint64_t)&v45, "Constructor argument of type '%.*s' - precision can not be inferred and no default precision available", v38, v39, v40, v41, v36);
      }
    }
  }
  v44 = 0;
  v48 = 0;
  ScalarType = glpPrimitiveTypeGetScalarType(a3);
  _convertAccesses(a1, ScalarType, v6, 1u, v49, &v44, &v48);
  ScalarCount = glpPrimitiveTypeGetScalarCount(a3);
  v11 = ScalarCount;
  MEMORY[0x24BDAC7A8](ScalarCount);
  v14 = (uint64_t *)((char *)&v42 - v13);
  if (v12 >= 0x200)
    v15 = 512;
  else
    v15 = v12;
  bzero((char *)&v42 - v13, v15);
  if (v11)
  {
    v16 = v11;
    v17 = v48;
    v18 = v14;
    do
    {
      v19 = (uint64_t *)glpCompilerGetAllocator(a1);
      *v18++ = glpDeepCopyASTNode(v19, v17, (uint64_t (*)(uint64_t, uint64_t *, _DWORD *))getAccessorReplaceCallback, 0);
      --v16;
    }
    while (v16);
  }
  v20 = glpCompilerGetAllocator(a1);
  glpASTNodeGetLocation(a2, &v43);
  glpMakeCommaExprNode(v20, &v43, 0);
  v22 = v21;
  v23 = v46;
  if (v46)
  {
    v24 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v24, v22, v23);
  }
  v25 = v44;
  if (v44)
  {
    v26 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v26, v22, v25);
  }
  v27 = glpCallNodeGetArg(a2, 0);
  v28 = glpASTNodeGetSaFlags(v27) & 0x60;
  v29 = glpGetPrimitiveType(a3);
  v47[0] = MEMORY[0x24BDAC760];
  v47[1] = 0x40000000;
  v47[2] = ___componentwiseConstructor_block_invoke;
  v47[3] = &__block_descriptor_tmp_86;
  v47[4] = a1;
  v47[5] = v14;
  return _constructor(a1, (uint64_t)v29, v22, v6, v28, (uint64_t)v47);
}

uint64_t _checkAndSanitizeDiagonalMatrixConstructorCall(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t ScalarType;
  unsigned int v8;
  unsigned int *PrimitiveType;
  uint64_t Allocator;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *MutableValue;
  uint64_t v17;
  uint64_t ConstantValueFragment;
  unsigned int Rows;
  uint64_t ScalarCount;
  int v21;
  unint64_t v22;
  uint64_t v23;
  char *v24;
  size_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;
  __n128 v46;
  uint64_t v47;
  uint64_t v48;
  __n128 v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55[2];

  v55[1] = *MEMORY[0x24BDAC8D0];
  v48 = 0;
  v55[0] = 0;
  _makeArgsAccessible(a1, a2, 0, v55, &v48);
  v6 = glpASTNodeGetSaFlags(v55[0]) & 0x1F;
  v43 = a2;
  doPrecisionWarningsForLowpInt(a1, a2, a3, v6);
  v47 = 0;
  v54 = 0;
  ScalarType = glpPrimitiveTypeGetScalarType(a3);
  v45 = v6;
  _convertAccesses(a1, ScalarType, v6, 1u, v55, &v47, &v54);
  v8 = glpPrimitiveTypeGetScalarType(a3);
  PrimitiveType = (unsigned int *)glpGetPrimitiveType(v8);
  Allocator = glpCompilerGetAllocator(a1);
  MutableValue = glpMakeMutableValue(Allocator, PrimitiveType, 0, v11, v12, v13, v14, v15, v42);
  v17 = glpCompilerRemapValue(a1, PrimitiveType, MutableValue);
  v49.n128_u64[0] = (unint64_t)"-1";
  v49.n128_u64[1] = 0xEDA00000002;
  v50 = 0xFFFFFFFFLL;
  ConstantValueFragment = glpMakeConstantValueFragment(a1, &v49, (uint64_t)PrimitiveType, v17);
  Rows = glpPrimitiveMatrixGetRows(a3);
  v44 = a3;
  ScalarCount = glpPrimitiveTypeGetScalarCount(a3);
  v21 = ScalarCount;
  v42 = (uint64_t)&v42;
  MEMORY[0x24BDAC7A8](ScalarCount);
  v24 = (char *)&v42 - v23;
  if (v22 >= 0x200)
    v25 = 512;
  else
    v25 = v22;
  bzero((char *)&v42 - v23, v25);
  if (v21)
  {
    v26 = 0;
    v27 = v54;
    do
    {
      v28 = (uint64_t *)glpCompilerGetAllocator(a1);
      if (v26 % Rows == v26 / Rows)
        v29 = v27;
      else
        v29 = ConstantValueFragment;
      *(_QWORD *)&v24[8 * v26++] = glpDeepCopyASTNode(v28, v29, (uint64_t (*)(uint64_t, uint64_t *, _DWORD *))getAccessorReplaceCallback, 0);
    }
    while (v21 != v26);
  }
  v30 = glpCompilerGetAllocator(a1);
  v31 = v43;
  glpASTNodeGetLocation(v43, &v46);
  glpMakeCommaExprNode(v30, &v46, 0);
  v33 = v32;
  v34 = v48;
  if (v48)
  {
    v35 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v35, v33, v34);
  }
  v36 = v47;
  if (v47)
  {
    v37 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v37, v33, v36);
  }
  v38 = glpCallNodeGetArg(v31, 0);
  v39 = glpASTNodeGetSaFlags(v38) & 0x60;
  v40 = glpGetPrimitiveType(v44);
  v49.n128_u64[0] = MEMORY[0x24BDAC760];
  v49.n128_u64[1] = 0x40000000;
  v50 = (uint64_t)___componentwiseConstructor_block_invoke;
  v51 = &__block_descriptor_tmp_86;
  v52 = a1;
  v53 = v24;
  return _constructor(a1, (uint64_t)v40, v33, v45, v39, (uint64_t)&v49);
}

uint64_t _checkAndSanitizeSubOrSuperMatrixConstructorCall(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  size_t v9;
  char *v10;
  uint64_t ScalarType;
  uint64_t v12;
  char SaFlags;
  unsigned int v14;
  unsigned int *PrimitiveType;
  uint64_t Allocator;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *MutableValue;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  unsigned int Columns;
  uint64_t SaType;
  int v34;
  unsigned int Rows;
  uint64_t v36;
  int v37;
  uint64_t v38;
  unsigned int v39;
  unint64_t v40;
  uint64_t v41;
  char *v42;
  size_t v43;
  unint64_t v44;
  int v45;
  int v46;
  uint64_t v47;
  uint64_t ScalarAccessor;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  uint64_t v66;
  uint64_t v67;
  unsigned int v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  uint64_t ConstantValueFragment;
  uint64_t v73;
  unsigned int v74;
  uint64_t v75;
  __n128 v76;
  uint64_t v77;
  void *v78;
  uint64_t v79;
  char *v80;
  _OWORD v81[2];
  uint64_t v82[3];

  v82[1] = *MEMORY[0x24BDAC8D0];
  v6 = glpCallNodeGetArgCount(a2);
  v75 = 0;
  v82[0] = 0;
  v67 = a2;
  _makeArgsAccessible(a1, a2, 0, v82, &v75);
  v74 = 0;
  memset(v81, 0, sizeof(v81));
  v7 = _atomicizeArgs(a1, v6, (uint64_t)v82, &v74, (uint64_t)v81);
  v73 = 0;
  v8 = v74;
  MEMORY[0x24BDAC7A8](v7);
  v10 = (char *)&v66 - ((v9 + 15) & 0xFFFFFFFF0);
  bzero(v10, v9);
  ScalarType = glpPrimitiveTypeGetScalarType(a3);
  v12 = v82[0];
  SaFlags = glpASTNodeGetSaFlags(v82[0]);
  _convertAccesses(a1, ScalarType, SaFlags & 0x1F, v8, (uint64_t *)v81, &v73, (uint64_t *)v10);
  v14 = glpPrimitiveTypeGetScalarType(a3);
  PrimitiveType = (unsigned int *)glpGetPrimitiveType(v14);
  Allocator = glpCompilerGetAllocator(a1);
  MutableValue = glpMakeMutableValue(Allocator, PrimitiveType, 0, v17, v18, v19, v20, v21, v66);
  v23 = glpCompilerRemapValue(a1, PrimitiveType, MutableValue);
  v76.n128_u64[0] = (unint64_t)"-1";
  v76.n128_u64[1] = 0xEDA00000002;
  v77 = 0xFFFFFFFFLL;
  ConstantValueFragment = glpMakeConstantValueFragment(a1, &v76, (uint64_t)PrimitiveType, v23);
  v24 = glpCompilerGetAllocator(a1);
  v30 = glpMakeMutableValue(v24, PrimitiveType, 1, v25, v26, v27, v28, v29, 0x3FF0000000000000);
  v31 = glpCompilerRemapValue(a1, PrimitiveType, v30);
  v76.n128_u64[0] = (unint64_t)"-1";
  v76.n128_u64[1] = 0xEDA00000002;
  v77 = 0xFFFFFFFFLL;
  v71 = glpMakeConstantValueFragment(a1, &v76, (uint64_t)PrimitiveType, v31);
  LODWORD(ScalarType) = glpPrimitiveMatrixGetRows(a3);
  v68 = a3;
  Columns = glpPrimitiveMatrixGetColumns(a3);
  SaType = glpASTNodeGetSaType(v12);
  v34 = glpPrimitiveTypeGetPrimitiveType(SaType);
  Rows = glpPrimitiveMatrixGetRows(v34);
  v36 = glpASTNodeGetSaType(v12);
  v37 = glpPrimitiveTypeGetPrimitiveType(v36);
  v38 = glpPrimitiveMatrixGetColumns(v37);
  v39 = v38;
  v66 = (uint64_t)&v66;
  v70 = ScalarType;
  MEMORY[0x24BDAC7A8](v38);
  v42 = (char *)&v66 - v41;
  if (v40 >= 0x200)
    v43 = 512;
  else
    v43 = v40;
  bzero((char *)&v66 - v41, v43);
  if (Columns)
  {
    v44 = 0;
    v45 = 0;
    v69 = Columns;
    v46 = v70;
    do
    {
      if (v70)
      {
        v47 = 0;
        do
        {
          if (v44 >= v39 || v47 >= Rows)
          {
            v50 = (uint64_t *)glpCompilerGetAllocator(a1);
            if (v44 == v47)
              v51 = v71;
            else
              v51 = ConstantValueFragment;
            v49 = glpDeepCopyASTNode(v50, v51, (uint64_t (*)(uint64_t, uint64_t *, _DWORD *))getAccessorReplaceCallback, 0);
          }
          else
          {
            ScalarAccessor = glpMakeScalarAccessor(a1, *(_QWORD *)&v10[8 * v44], v47);
            v49 = glpSANode(a1, ScalarAccessor);
          }
          *(_QWORD *)&v42[8 * (v45 + v47++)] = v49;
        }
        while (v46 != (_DWORD)v47);
        v45 += v47;
      }
      ++v44;
    }
    while (v44 != v69);
  }
  v52 = glpCompilerGetAllocator(a1);
  v76.n128_u64[0] = (unint64_t)"-1";
  v76.n128_u64[1] = 0xEDA00000002;
  v77 = 0xFFFFFFFFLL;
  glpMakeCommaExprNode(v52, &v76, 0);
  v54 = v53;
  v55 = v75;
  if (v75)
  {
    v56 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v56, v54, v55);
  }
  v57 = v73;
  if (v73)
  {
    v58 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v58, v54, v57);
  }
  v59 = v67;
  v60 = glpCallNodeGetArg(v67, 0);
  v61 = glpASTNodeGetSaFlags(v60) & 0x1F;
  v62 = glpCallNodeGetArg(v59, 0);
  v63 = glpASTNodeGetSaFlags(v62) & 0x60;
  v64 = glpGetPrimitiveType(v68);
  v76.n128_u64[0] = MEMORY[0x24BDAC760];
  v76.n128_u64[1] = 0x40000000;
  v77 = (uint64_t)___componentwiseConstructor_block_invoke;
  v78 = &__block_descriptor_tmp_86;
  v79 = a1;
  v80 = v42;
  return _constructor(a1, (uint64_t)v64, v54, v61, v63, (uint64_t)&v76);
}

uint64_t _checkConstructorArgs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t SaType;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _QWORD *v13;
  char v14;
  char v15;
  uint64_t **v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *Allocator;
  char v23;
  char v24;
  _QWORD *v25;
  uint64_t **InfoLog;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  char v32;
  char v33;
  uint64_t **v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __n128 v40;
  __n128 v41;
  __n128 v42;

  v6 = glpConstructorCallNodeGetType(a2);
  SaType = glpASTNodeGetSaType(v6);
  v8 = glpCallNodeGetArgCount(a2);
  if (v8)
  {
    v9 = v8;
    v10 = 0;
    while (1)
    {
      v11 = glpCallNodeGetArg(a2, v10);
      v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, v10, v11);
      if (v12 == 2)
        break;
      if (v12 == 1)
      {
        v21 = glpASTNodeGetSaType(v11);
        Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription(v21, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
        v24 = v23;
        v25 = (_QWORD *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription(SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v25);
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v42);
        glpLogMessage(InfoLog, 0, (uint64_t)&v42, "Invalid type '%.*s' as argument %u of constructor of '%.*s'", v27, v28, v29, v30, v24);
        return 0;
      }
      v10 = (v10 + 1);
      if (v9 == (_DWORD)v10)
        goto LABEL_6;
    }
    if ((int)v10 + 1 >= v9)
      return 1;
    v31 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpTypeHumanReadableDescription(SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v31);
    v33 = v32;
    v34 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v41);
    glpLogMessage(v34, 0, (uint64_t)&v41, "Too many arguments to constructor of '%.*s'", v35, v36, v37, v38, v33);
  }
  else
  {
LABEL_6:
    v13 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpTypeHumanReadableDescription(SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v13);
    v15 = v14;
    v16 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v40);
    glpLogMessage(v16, 0, (uint64_t)&v40, "Too few arguments to constructor of '%.*s'", v17, v18, v19, v20, v15);
  }
  return 0;
}

uint64_t ___checkAndSanitizeComponentwiseConstructorCall_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t SaFlags;
  unint64_t v6;
  uint64_t v7;
  unsigned int *SaType;
  uint64_t PrimitiveType;

  SaFlags = glpASTNodeGetSaFlags(a3);
  v6 = SaFlags & 0x1F;
  if (v6 != 31)
  {
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (*(_QWORD *)(v7 + 24) > v6)
      v6 = *(_QWORD *)(v7 + 24);
    *(_QWORD *)(v7 + 24) = v6;
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) &= SaFlags;
  SaType = (unsigned int *)glpASTNodeGetSaType(a3);
  if (glpTypeGetKind(SaType))
    return 1;
  PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType);
  if (glpPrimitiveTypeGetCategory(PrimitiveType) - 1 > 2)
    return 1;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) += glpPrimitiveTypeGetScalarCount(PrimitiveType);
  return 2 * (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) >= *(_DWORD *)(a1 + 56));
}

uint64_t doPrecisionWarningsForLowpInt(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t result;
  int v9;
  unsigned int *PrimitiveType;
  unsigned int i;
  uint64_t v12;
  unsigned int *SaType;
  uint64_t v15;
  _QWORD *Allocator;
  char v17;
  char v18;
  uint64_t **InfoLog;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __n128 v24;

  result = glpCallNodeGetArgCount(a2);
  if (a4 == 4)
  {
    v9 = result;
    PrimitiveType = (unsigned int *)glpGetPrimitiveType(a3);
    result = glpGetMostBasicPrimitiveType(PrimitiveType);
    if ((_DWORD)result == 1)
    {
      if (v9)
      {
        for (i = 0; i != v9; ++i)
        {
          v12 = glpCallNodeGetArg(a2, i);
          SaType = (unsigned int *)glpASTNodeGetSaType(v12);
          result = glpGetMostBasicPrimitiveType(SaType);
          if ((_DWORD)result == 36 || (_DWORD)result == 5)
          {
            result = glpASTNodeGetSaFlags(v12);
            if ((result & 0x1F) == 4)
            {
              v15 = glpASTNodeGetSaType(v12);
              Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
              glpTypeHumanReadableDescription(v15, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
              v18 = v17;
              InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
              glpASTNodeGetLocation(a2, &v24);
              result = (uint64_t)glpLogMessage(InfoLog, 1u, (uint64_t)&v24, "Casting lowp %.*s to lowp float - this may produce incorrect results", v20, v21, v22, v23, v18);
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t _makeArgsAccessible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t Allocator;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t result;
  __n128 v20;
  uint64_t v21;

  Allocator = glpCompilerGetAllocator(a1);
  v20.n128_u64[0] = (unint64_t)"-1";
  v20.n128_u64[1] = 0xEDA00000002;
  v21 = 0xFFFFFFFFLL;
  glpMakeCommaExprNode(Allocator, &v20, 0);
  *a5 = v11;
  v12 = glpCallNodeGetArgCount(a2);
  if (v12)
  {
    v13 = 0;
    v14 = v12;
    do
    {
      v15 = glpCallNodeGetArg(a2, v13);
      v16 = v15;
      if (a3 && (glpASTNodeGetSaFlags(v15) & 0x1F) == 0)
        glpPushdownPrecision(a1, v16, a3);
      v20.n128_u64[0] = 0;
      glpHandleSideEffectsForExpr(a1, v16, a4, (uint64_t *)&v20);
      v17 = v20.n128_u64[0];
      if (v20.n128_u64[0])
      {
        v18 = (_QWORD *)glpCompilerGetAllocator(a1);
        glpCommaExprNodeAddExpr(v18, *a5, v17);
      }
      ++v13;
      ++a4;
    }
    while (v14 != v13);
  }
  result = glpCommaExprNodeGetExprCount(*a5);
  if (!(_DWORD)result)
    *a5 = 0;
  return result;
}

uint64_t _atomicizeArgs(uint64_t result, unsigned int a2, uint64_t a3, unsigned int *a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  _DWORD *SaType;
  int IsAtomic;
  int v14;
  uint64_t v15;
  uint64_t Accessor;

  if (a2)
  {
    v8 = result;
    v9 = 0;
    v10 = 0;
    v11 = a2;
    do
    {
      SaType = (_DWORD *)glpASTNodeGetSaType(*(_QWORD *)(a3 + 8 * v9));
      IsAtomic = glpTypeIsAtomic(SaType);
      result = *(_QWORD *)(a3 + 8 * v9);
      if (IsAtomic)
      {
        *(_QWORD *)(a5 + 8 * v10++) = result;
      }
      else
      {
        result = glpGetAccessorCount(result);
        if ((_DWORD)result)
        {
          v14 = result;
          v15 = 0;
          do
          {
            Accessor = glpMakeAccessor(v8, *(_QWORD *)(a3 + 8 * v9), v15);
            result = glpSANode(v8, Accessor);
            *(_QWORD *)(a5 + 8 * (v10 + v15)) = result;
            v15 = (v15 + 1);
          }
          while (v14 != (_DWORD)v15);
          v10 += v15;
        }
      }
      ++v9;
    }
    while (v9 != v11);
  }
  else
  {
    v10 = 0;
  }
  *a4 = v10;
  return result;
}

uint64_t _convertAccesses(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t Allocator;
  uint64_t v15;
  uint64_t v16;
  uint64_t SaType;
  uint64_t PrimitiveType;
  int v19;
  unsigned int v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t result;
  __n128 v27;
  uint64_t v28;

  Allocator = glpCompilerGetAllocator(a1);
  v27.n128_u64[0] = (unint64_t)"-1";
  v27.n128_u64[1] = 0xEDA00000002;
  v28 = 0xFFFFFFFFLL;
  glpMakeCommaExprNode(Allocator, &v27, 0);
  *a6 = v15;
  if (a4)
  {
    v16 = a4;
    do
    {
      SaType = glpASTNodeGetSaType(*a5);
      PrimitiveType = glpPrimitiveTypeGetPrimitiveType(SaType);
      v19 = PrimitiveType;
      v20 = glpPrimitiveTypeReplaceScalarType(PrimitiveType, a2);
      if (v19 == v20)
      {
        *a7 = *a5;
      }
      else
      {
        v27.n128_u64[0] = 0;
        v21 = *a5;
        v22 = glpGetPrimitiveType(v20);
        v23 = glpConvert(a1, v21, (uint64_t)v22, a3);
        glpHandleSideEffectsForExpr(a1, v23, a7, (uint64_t *)&v27);
        v24 = v27.n128_u64[0];
        if (v27.n128_u64[0])
        {
          v25 = (_QWORD *)glpCompilerGetAllocator(a1);
          glpCommaExprNodeAddExpr(v25, *a6, v24);
        }
      }
      ++a5;
      ++a7;
      --v16;
    }
    while (v16);
    v15 = *a6;
  }
  result = glpCommaExprNodeGetExprCount(v15);
  if (!(_DWORD)result)
    *a6 = 0;
  return result;
}

void ___componentwiseConstructor_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t SaType;
  unsigned int PrimitiveType;
  int AccessorCount;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t Accessor;
  int ScalarAccessorCount;
  int v12;
  int i;
  uint64_t ScalarAccessor;
  __int128 v15;
  _QWORD v16[2];
  uint64_t (*v17)(_QWORD *, uint64_t);
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD v23[3];
  int v24;
  _QWORD v25[3];
  int v26;

  v25[0] = 0;
  v25[1] = v25;
  v25[2] = 0x2000000000;
  v26 = 0;
  v23[0] = 0;
  v23[1] = v23;
  v23[2] = 0x2000000000;
  v24 = 0;
  v16[0] = MEMORY[0x24BDAC760];
  v16[1] = 0x40000000;
  v17 = ___componentwiseConstructor_block_invoke_2;
  v18 = &unk_24F4B0AE8;
  v15 = *(_OWORD *)(a1 + 32);
  v21 = v15;
  v19 = v25;
  v20 = v23;
  v22 = a3;
  SaType = glpASTNodeGetSaType(a2);
  PrimitiveType = glpPrimitiveTypeGetPrimitiveType(SaType);
  if (glpPrimitiveTypeGetCategory(PrimitiveType) == 3)
  {
    AccessorCount = glpGetAccessorCount(a2);
    if (!AccessorCount)
      goto LABEL_13;
  }
  else
  {
    AccessorCount = 1;
  }
  v7 = 0;
  v8 = 0;
  do
  {
    v9 = a2;
    if (AccessorCount != 1)
    {
      Accessor = glpMakeAccessor(v15, a2, v8);
      v9 = glpSANode(v15, Accessor);
    }
    ScalarAccessorCount = glpGetScalarAccessorCount(v9);
    if (ScalarAccessorCount)
    {
      v12 = ScalarAccessorCount;
      for (i = 0; i != v12; ++i)
      {
        ScalarAccessor = glpMakeScalarAccessor(v15, v9, i);
        ((void (*)(_QWORD *, uint64_t, _QWORD))v17)(v16, ScalarAccessor, (v7 + i));
      }
      v7 += i;
    }
    v8 = (v8 + 1);
  }
  while ((_DWORD)v8 != AccessorCount);
LABEL_13:
  _Block_object_dispose(v23, 8);
  _Block_object_dispose(v25, 8);
}

uint64_t ___componentwiseConstructor_block_invoke_2(_QWORD *a1, uint64_t a2)
{
  uint64_t ScalarAccessor;
  uint64_t v5;
  uint64_t v6;
  uint64_t Allocator;
  uint64_t AssignNode;
  _QWORD *v9;
  uint64_t result;
  __n128 v11;
  uint64_t v12;

  ScalarAccessor = glpMakeScalarAccessor(a1[6], *(_QWORD *)(a1[7] + 8 * *(unsigned int *)(*(_QWORD *)(a1[4] + 8) + 24)), *(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24));
  v5 = a1[6];
  v6 = a1[8];
  Allocator = glpCompilerGetAllocator(v5);
  v11.n128_u64[0] = (unint64_t)"-1";
  v11.n128_u64[1] = 0xEDA00000002;
  v12 = 0xFFFFFFFFLL;
  AssignNode = glpMakeAssignNode(Allocator, &v11, 0);
  glpBinaryOperatorNodeSetLhs(AssignNode, a2);
  glpBinaryOperatorNodeSetRhs(AssignNode, ScalarAccessor);
  v9 = (_QWORD *)glpCompilerGetAllocator(v5);
  glpCommaExprNodeAddExpr(v9, v6, AssignNode);
  LODWORD(a2) = ++*(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
  result = glpGetScalarAccessorCount(*(_QWORD *)(a1[7] + 8 * *(unsigned int *)(*(_QWORD *)(a1[4] + 8) + 24)));
  if (a2 >= result)
  {
    ++*(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
    *(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = 0;
  }
  return result;
}

uint64_t ___checkAndSanitizeArrayConstructorCall_block_invoke(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t SaFlags;
  unint64_t v7;
  uint64_t v8;
  unsigned int *SaType;
  uint64_t PrimitiveType;
  uint64_t v12;
  unsigned int ImplicitConversionPolicy;

  SaFlags = glpASTNodeGetSaFlags(a3);
  v7 = SaFlags & 0x1F;
  if (v7 != 31)
  {
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (*(_QWORD *)(v8 + 24) > v7)
      v7 = *(_QWORD *)(v8 + 24);
    *(_QWORD *)(v8 + 24) = v7;
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) &= SaFlags;
  SaType = (unsigned int *)glpASTNodeGetSaType(a3);
  if (glpTypesEqual(*(unsigned int **)(a1 + 48), (uint64_t)SaType))
    return 2 * (a2 + 1 == glpArrayTypeGetElementCount(*(_QWORD *)(a1 + 64)));
  if (!glpTypeGetKind(SaType)
    && !glpTypeGetKind(*(unsigned int **)(a1 + 48))
    && (PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType),
        v12 = glpPrimitiveTypeGetPrimitiveType(*(_QWORD *)(a1 + 48)),
        ImplicitConversionPolicy = glpCompilerGetImplicitConversionPolicy(*(_QWORD *)(a1 + 56)),
        glpCanConvert(PrimitiveType, v12, ImplicitConversionPolicy)))
  {
    return 2 * (a2 + 1 == glpArrayTypeGetElementCount(*(_QWORD *)(a1 + 64)));
  }
  else
  {
    return 1;
  }
}

uint64_t _elementwiseConstructor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  size_t v13;
  uint64_t Allocator;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD v20[7];
  __n128 v21;
  uint64_t v22[2];

  v22[1] = *MEMORY[0x24BDAC8D0];
  v22[0] = 0;
  v10 = glpCallNodeGetArgCount(a2);
  MEMORY[0x24BDAC7A8](v10);
  v12 = (_QWORD *)((char *)v20 - v11);
  bzero((char *)v20 - v11, v13);
  _makeArgsAccessible(a1, a2, a4, v12, v22);
  Allocator = glpCompilerGetAllocator(a1);
  glpASTNodeGetLocation(a2, &v21);
  glpMakeCommaExprNode(Allocator, &v21, 0);
  v16 = v15;
  v17 = v22[0];
  if (v22[0])
  {
    v18 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v18, v16, v17);
  }
  v20[0] = MEMORY[0x24BDAC760];
  v20[1] = 0x40000000;
  v20[2] = ___elementwiseConstructor_block_invoke;
  v20[3] = &__block_descriptor_tmp_88;
  v20[4] = a1;
  v20[5] = v16;
  v20[6] = v12;
  return _constructor(a1, a3, v16, a4, a5, (uint64_t)v20);
}

uint64_t ___elementwiseConstructor_block_invoke(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t Accessor;
  uint64_t v11;
  uint64_t Allocator;
  uint64_t AssignNode;
  uint64_t v14;
  _QWORD *v15;
  __n128 v16;

  result = glpGetAccessorCount(a2);
  if ((_DWORD)result)
  {
    v7 = 0;
    v8 = result;
    do
    {
      v9 = a1[4];
      Accessor = glpMakeAccessor(v9, a2, v7);
      v11 = glpSANode(v9, Accessor);
      Allocator = glpCompilerGetAllocator(a1[4]);
      glpASTNodeGetLocation(a1[5], &v16);
      AssignNode = glpMakeAssignNode(Allocator, &v16, 0);
      glpBinaryOperatorNodeSetLhs(AssignNode, v11);
      glpBinaryOperatorNodeSetRhs(AssignNode, *(_QWORD *)(a1[6] + 8 * v7));
      v14 = glpSANode(a1[4], AssignNode);
      v15 = (_QWORD *)glpCompilerGetAllocator(a1[4]);
      result = (uint64_t)glpCommaExprNodeAddExpr(v15, a3, v14);
      ++v7;
    }
    while (v8 != v7);
  }
  return result;
}

uint64_t ___checkAndSanitizeStructConstructorCall_block_invoke(_QWORD *a1, unsigned int a2, uint64_t a3)
{
  unsigned int *SaType;
  unsigned int *ElementType;
  uint64_t PrimitiveType;
  uint64_t v10;
  unsigned int ImplicitConversionPolicy;

  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) &= glpASTNodeGetSaFlags(a3);
  SaType = (unsigned int *)glpASTNodeGetSaType(a3);
  ElementType = (unsigned int *)glpAggregateTypeGetElementType(a1[5], a2);
  if (glpTypesEqual(ElementType, (uint64_t)SaType))
    return 2 * (a2 + 1 == glpAggregateTypeGetElementCount(a1[5]));
  if (!glpTypeGetKind(SaType)
    && !glpTypeGetKind(ElementType)
    && (PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType),
        v10 = glpPrimitiveTypeGetPrimitiveType((uint64_t)ElementType),
        ImplicitConversionPolicy = glpCompilerGetImplicitConversionPolicy(a1[6]),
        glpCanConvert(PrimitiveType, v10, ImplicitConversionPolicy)))
  {
    return 2 * (a2 + 1 == glpAggregateTypeGetElementCount(a1[5]));
  }
  else
  {
    return 1;
  }
}

uint64_t glpMakeSourceLocation@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, int a3@<W2>, _QWORD *a4@<X8>)
{
  a4[1] = a2;
  a4[2] = 0;
  *a4 = result;
  *((_DWORD *)a4 + 4) = a3;
  return result;
}

char *glpMakeMutableValue(uint64_t a1, unsigned int *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unsigned int v12;
  unsigned int Size;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  char *v20;
  int ScalarType;
  unsigned int ScalarCount;
  uint64_t v23;
  _DWORD *v24;
  uint64_t v25;
  _DWORD *v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  _DWORD *v30;
  uint64_t v31;
  double *v32;
  float v33;
  _QWORD v35[2];

  v35[1] = *MEMORY[0x24BDAC8D0];
  v12 = glpABIGetTypeSize(0, (uint64_t)a2, 0);
  Size = glpTypeSizeGetSize(v12);
  v14 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 16 * Size, "Value");
  bzero(v14, 16 * Size);
  if (a3)
  {
    v16 = Size;
    MEMORY[0x24BDAC7A8](v15);
    v18 = (_DWORD *)((char *)v35 - ((v17 + 15) & 0x7FFFFFFF0));
    glpTypeGetAppleVec4Types(a2, v18, 1, 0, 0, 0, 0, 0, 0);
    v35[0] = &a9;
    if ((_DWORD)v16)
    {
      v19 = 0;
      v20 = v14;
      do
      {
        ScalarType = glpPrimitiveTypeGetScalarType(v18[v19]);
        ScalarCount = glpPrimitiveTypeGetScalarCount(v18[v19]);
        glpPrimitiveTypeGetBytesPerComponent(v18[v19]);
        if (ScalarType <= 8)
        {
          if (ScalarType == 1)
          {
            if (ScalarCount)
            {
              v31 = 0;
              do
              {
                v32 = (double *)v35[0];
                v35[0] += 8;
                v33 = *v32;
                *(float *)&v20[v31] = v33;
                v31 += 4;
              }
              while (4 * ScalarCount != v31);
            }
          }
          else
          {
            if (ScalarType != 5)
LABEL_31:
              abort();
            if (ScalarCount)
            {
              v25 = 0;
              do
              {
                v26 = (_DWORD *)v35[0];
                v35[0] += 8;
                *(_DWORD *)&v20[v25] = *v26;
                v25 += 4;
              }
              while (4 * ScalarCount != v25);
            }
          }
        }
        else
        {
          switch(ScalarType)
          {
            case 62:
              if (ScalarCount)
              {
                v27 = 0;
                do
                {
                  v28 = (_QWORD *)v35[0];
                  v35[0] += 8;
                  *(_QWORD *)&v20[v27] = *v28;
                  v27 += 8;
                }
                while (8 * ScalarCount != v27);
              }
              break;
            case 36:
              if (ScalarCount)
              {
                v29 = 0;
                do
                {
                  v30 = (_DWORD *)v35[0];
                  v35[0] += 8;
                  *(_DWORD *)&v20[v29] = *v30;
                  v29 += 4;
                }
                while (4 * ScalarCount != v29);
              }
              break;
            case 9:
              if (ScalarCount)
              {
                v23 = 0;
                do
                {
                  v24 = (_DWORD *)v35[0];
                  v35[0] += 8;
                  *(_DWORD *)&v20[v23] = *v24 != 0;
                  v23 += 4;
                }
                while (4 * ScalarCount != v23);
              }
              break;
            default:
              goto LABEL_31;
          }
        }
        ++v19;
        v20 += 16;
      }
      while (v19 != v16);
    }
  }
  return v14;
}

char *glpCopyValue(uint64_t a1, unsigned int *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *MutableValue;
  uint64_t v12;

  MutableValue = glpMakeMutableValue(a1, a2, 0, a4, a5, a6, a7, a8, v12);
  glpCopyValueInto(MutableValue, (uint64_t)a2, a3);
  return MutableValue;
}

void *glpCopyValueInto(void *a1, uint64_t a2, const void *a3)
{
  unsigned int v5;
  size_t v6;

  v5 = glpABIGetTypeSize(0, a2, 0);
  v6 = 16 * glpTypeSizeGetSize(v5);
  return memcpy(a1, a3, v6);
}

uint64_t glpCompareValues(char *a1, unsigned int *a2, char *a3)
{
  unsigned int v6;
  uint64_t Size;
  unsigned int v8;
  uint64_t v9;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  int BytesPerComponent;
  unsigned int v14;
  int ScalarCount;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x24BDAC8D0];
  v6 = glpABIGetTypeSize(0, (uint64_t)a2, 0);
  Size = glpTypeSizeGetSize(v6);
  v8 = Size;
  MEMORY[0x24BDAC7A8](Size);
  v10 = (unsigned int *)((char *)v17 - v9);
  glpTypeGetAppleVec4Types(a2, (_QWORD *)((char *)v17 - v9), 1, 0, 0, 0, 0, 0, 0);
  v11 = 0;
  if (v8)
  {
    v12 = v8;
    do
    {
      BytesPerComponent = glpPrimitiveTypeGetBytesPerComponent(*v10);
      v14 = *v10++;
      ScalarCount = glpPrimitiveTypeGetScalarCount(v14);
      v11 = memcmp(a1, a3, (ScalarCount * BytesPerComponent)) | v11;
      a1 += 16;
      a3 += 16;
      --v12;
    }
    while (v12);
  }
  return v11;
}

BOOL glpValueIsUsableAsSize(unsigned int *a1, _DWORD *a2)
{
  if (glpTypeGetKind(a1))
    return 0;
  if (glpPrimitiveTypeGetPrimitiveType((uint64_t)a1) != 5 || (*a2 & 0x80000000) != 0)
    return glpPrimitiveTypeGetPrimitiveType((uint64_t)a1) == 36;
  return 1;
}

uint64_t glpValueGetAsSize(uint64_t a1, unsigned int *a2)
{
  glpPrimitiveTypeGetPrimitiveType(a1);
  return *a2;
}

void *glpAppendValueDescriptionToStringBuffer(uint64_t *a1, unsigned int *a2, uint64_t a3)
{
  unsigned int v6;
  uint64_t Size;
  unsigned int v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  int ScalarType;
  unsigned int ScalarCount;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  _QWORD v43[2];

  v43[1] = *MEMORY[0x24BDAC8D0];
  v6 = glpABIGetTypeSize(0, (uint64_t)a2, 0);
  Size = glpTypeSizeGetSize(v6);
  v8 = Size;
  MEMORY[0x24BDAC7A8](Size);
  v10 = (char *)v43 - v9;
  glpTypeGetAppleVec4Types(a2, (_QWORD *)((char *)v43 - v9), 1, 0, 0, 0, 0, 0, 0);
  glpStringBufferAppendCString(a1, "(");
  if (v8)
  {
    v17 = 0;
    v43[0] = v8;
    do
    {
      v18 = ", {";
      if (!v17)
        v18 = "{";
      glpStringBufferAppendFormat(a1, "%s", v11, v12, v13, v14, v15, v16, (char)v18);
      ScalarType = glpPrimitiveTypeGetScalarType(*(unsigned int *)&v10[4 * v17]);
      ScalarCount = glpPrimitiveTypeGetScalarCount(*(unsigned int *)&v10[4 * v17]);
      glpPrimitiveTypeGetBytesPerComponent(*(unsigned int *)&v10[4 * v17]);
      if (ScalarType <= 8)
      {
        if (ScalarType == 1)
        {
          if (ScalarCount)
          {
            v39 = 0;
            v40 = 4 * ScalarCount;
            do
            {
              if (v39)
                v41 = ", ";
              else
                v41 = "";
              glpStringBufferAppendFormat(a1, "%s%f (= %a)", v21, v22, v23, v24, v25, v26, (char)v41);
              v39 += 4;
            }
            while (v40 != v39);
          }
        }
        else
        {
          if (ScalarType != 5)
LABEL_47:
            abort();
          if (ScalarCount)
          {
            v30 = 0;
            v31 = 4 * ScalarCount;
            do
            {
              if (v30)
                v32 = ", ";
              else
                v32 = "";
              glpStringBufferAppendFormat(a1, "%s%d", v21, v22, v23, v24, v25, v26, (char)v32);
              v30 += 4;
            }
            while (v31 != v30);
          }
        }
      }
      else
      {
        switch(ScalarType)
        {
          case 62:
            if (ScalarCount)
            {
              v33 = 0;
              v34 = 8 * ScalarCount;
              do
              {
                if (v33)
                  v35 = ", ";
                else
                  v35 = "";
                glpStringBufferAppendFormat(a1, "%s%f (= %a)", v21, v22, v23, v24, v25, v26, (char)v35);
                v33 += 8;
              }
              while (v34 != v33);
            }
            break;
          case 36:
            if (ScalarCount)
            {
              v36 = 0;
              v37 = 4 * ScalarCount;
              do
              {
                if (v36)
                  v38 = ", ";
                else
                  v38 = "";
                glpStringBufferAppendFormat(a1, "%s%u", v21, v22, v23, v24, v25, v26, (char)v38);
                v36 += 4;
              }
              while (v37 != v36);
            }
            break;
          case 9:
            if (ScalarCount)
            {
              v27 = 0;
              v28 = 4 * ScalarCount;
              do
              {
                if (v27)
                  v29 = ", ";
                else
                  v29 = "";
                glpStringBufferAppendFormat(a1, "%s%s", v21, v22, v23, v24, v25, v26, (char)v29);
                v27 += 4;
              }
              while (v28 != v27);
            }
            break;
          default:
            goto LABEL_47;
        }
      }
      glpStringBufferAppendFormat(a1, "}", v21, v22, v23, v24, v25, v26, v43[0]);
      ++v17;
      a3 += 16;
    }
    while (v17 != v43[0]);
  }
  return glpStringBufferAppendCString(a1, ")");
}

uint64_t glpTypedValueHash(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  unsigned int Size;
  unsigned int v5;
  unsigned int v6;
  int v7;
  uint64_t result;

  v3 = glpABIGetTypeSize(0, a1, 0);
  Size = glpTypeSizeGetSize(v3);
  v5 = 16 * Size;
  v6 = (Size >> 1) & 0x7FFFFFF;
  if (v6 >= 16 * Size)
    return 16 * Size;
  v7 = ~(v5 >> 5);
  LODWORD(result) = 16 * Size;
  do
  {
    result = (32 * (_DWORD)result + (result >> 2) + *(char *)(a2 + v5 - 1)) ^ result;
    v5 += v7;
  }
  while (v5 > v6);
  return result;
}

uint64_t glpTypedValuesEqual(unsigned int *a1, char *a2, uint64_t a3, char *a4)
{
  uint64_t result;

  result = glpTypesEqual(a1, a3);
  if ((_DWORD)result)
    return glpCompareValues(a2, a1, a4) == 0;
  return result;
}

uint64_t glpRemapValue(uint64_t a1, unsigned int *a2, char *a3)
{
  if (a3)
    return glpTypedValueHashCache(a1, a2, a3, (uint64_t)a3);
  else
    return 0;
}

uint64_t LookUpAddString(uint64_t a1, char *a2)
{
  unsigned int v3;
  uint64_t result;
  uint64_t v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  int v12;
  BOOL v13;
  char v14;
  _DWORD *v15;

  v3 = LookUpAddStringHash(a1, a2);
  result = *(unsigned int *)(*(_QWORD *)(a1 + 16) + 8 * v3 + 4);
  if (!(_DWORD)result)
  {
    v5 = v3;
    v6 = *(_DWORD *)(a1 + 64);
    if (v6 >= *(_DWORD *)(a1 + 68))
    {
      GrowAtomTable(a1, 2 * v6);
      v6 = *(_DWORD *)(a1 + 64);
    }
    v7 = *(_QWORD *)(a1 + 48);
    *(_DWORD *)(v7 + 4 * v6) = -1;
    v8 = *(_DWORD *)(a1 + 64);
    v9 = (int)v8;
    if (v8)
    {
      v10 = 0;
      v11 = 0;
      do
      {
        v12 = v8 & 1 | (2 * v11);
        ++v10;
        v11 = v12;
        v13 = v8 > 1;
        v8 >>= 1;
      }
      while (v13);
    }
    else
    {
      v12 = 0;
      v10 = 0;
    }
    v14 = 20 - v10;
    if (v10 > 0x14)
      v14 = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * v9) = v12 << v14;
    result = *(int *)(a1 + 64);
    *(_DWORD *)(a1 + 64) = result + 1;
    v15 = (_DWORD *)(*(_QWORD *)(a1 + 16) + 8 * v5);
    *(_DWORD *)(v7 + 4 * result) = *v15;
    v15[1] = result;
  }
  return result;
}

uint64_t LookUpAddStringHash(uint64_t a1, char *a2)
{
  unsigned int i;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  char *v8;
  int HashLoc;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  void *v15;
  _DWORD *v16;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  for (i = FindHashLoc((uint64_t *)a1, a2); (i & 0x80000000) != 0; i = FindHashLoc((uint64_t *)a1, a2))
  {
    v5 = *(_OWORD *)(a1 + 48);
    v20 = *(_OWORD *)(a1 + 32);
    v21 = v5;
    v22 = *(_QWORD *)(a1 + 64);
    v6 = *(_OWORD *)(a1 + 16);
    v18 = *(_OWORD *)a1;
    v19 = v6;
    if (InitAtomTable(a1, (2 * DWORD2(v6)) | 1u))
    {
      v7 = *(int *)(a1 + 64);
      if ((int)v7 < (int)v22)
      {
        do
        {
          v8 = (char *)(v18 + *(int *)(v21 + 4 * v7));
          HashLoc = FindHashLoc((uint64_t *)&v18, v8);
          AddAtomFixed(a1, (uint64_t)v8, *(unsigned int *)(v19 + 8 * HashLoc + 4));
          ++v7;
        }
        while (v7 < (int)v22);
      }
      FreeAtomTable((uint64_t)&v18);
    }
  }
  v10 = i;
  if (!*(_DWORD *)(*(_QWORD *)(a1 + 16) + 8 * i))
  {
    ++*(_DWORD *)(a1 + 28);
    v11 = strlen(a2) + 1;
    v13 = *(_DWORD *)(a1 + 8);
    v12 = *(_DWORD *)(a1 + 12);
    if (v11 + v13 >= v12)
    {
      do
      {
        v15 = malloc_type_malloc(2 * v12, 0x7081ABB9uLL);
        if (!v15)
          abort();
        v14 = (uint64_t)v15;
        memcpy(v15, *(const void **)a1, *(int *)(a1 + 12));
        free(*(void **)a1);
        *(_QWORD *)a1 = v14;
        v13 = *(_DWORD *)(a1 + 8);
        v12 = 2 * *(_DWORD *)(a1 + 12);
        *(_DWORD *)(a1 + 12) = v12;
      }
      while (v13 + v11 >= v12);
    }
    else
    {
      v14 = *(_QWORD *)a1;
    }
    strcpy((char *)(v14 + v13), a2);
    *(_DWORD *)(a1 + 8) += v11;
    v16 = (_DWORD *)(*(_QWORD *)(a1 + 16) + 8 * v10);
    *v16 = v13;
    v16[1] = 0;
  }
  return v10;
}

const char *GetAtomString(uint64_t a1, int a2)
{
  uint64_t v2;
  const char *v4;

  if (a2 < 1 || *(_DWORD *)(a1 + 64) <= a2)
  {
    v4 = "<invalid atom>";
    if (a2 == -1)
      v4 = "<EOF>";
    if (a2)
      return v4;
    else
      return "<null atom>";
  }
  else
  {
    v2 = *(unsigned int *)(*(_QWORD *)(a1 + 48) + 4 * a2);
    if ((int)v2 < 1 || (int)v2 >= *(_DWORD *)(a1 + 8))
      return "<internal error: bad soffset>";
    else
      return (const char *)(*(_QWORD *)a1 + v2);
  }
}

uint64_t GetReversedAtom(uint64_t a1, int a2)
{
  if (a2 < 1 || *(_DWORD *)(a1 + 64) <= a2)
    return 0;
  else
    return *(unsigned int *)(*(_QWORD *)(a1 + 56) + 4 * a2);
}

uint64_t InitAtomTable(uint64_t a1, int a2)
{
  void *v4;
  unsigned int v5;
  void *v6;
  uint64_t v7;
  _DWORD *v8;
  char v9;
  uint64_t v10;
  uint64_t i;
  _BYTE v13[2];

  v4 = malloc_type_malloc(0x4000uLL, 0x7081ABB9uLL);
  if (!v4
    || ((*(_QWORD *)a1 = v4, *(_QWORD *)(a1 + 8) = 0x400000000001, a2 >= 1) ? (v5 = a2) : (v5 = 2047),
        (v6 = malloc_type_malloc(8 * v5, 0x7081ABB9uLL)) == 0))
  {
    abort();
  }
  *(_QWORD *)(a1 + 16) = v6;
  *(_DWORD *)(a1 + 24) = v5;
  bzero(v6, 8 * v5);
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 28) = 0;
  *(_QWORD *)(a1 + 44) = 0;
  *(_QWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  GrowAtomTable(a1, 1024);
  if (!*(_QWORD *)(a1 + 48))
    return 0;
  AddAtomFixed(a1, (uint64_t)"<undefined>", 0);
  v7 = 0;
  v8 = *(_DWORD **)(a1 + 48);
  do
    v8[v7++] = *v8;
  while (v7 != 290);
  v13[1] = 0;
  v9 = 126;
  v10 = 1u;
  do
  {
    v13[0] = v9;
    AddAtomFixed(a1, (uint64_t)v13, v9);
    v9 = asc_22A9921F7[v10++];
  }
  while (v10 != 26);
  for (i = 0; i != 512; i += 16)
    AddAtomFixed(a1, *(_QWORD *)((char *)&tokens + i + 8), *(unsigned int *)((char *)&tokens + i));
  LookUpAddString(a1, "<*** end fixed atoms ***>");
  return 1;
}

void GrowAtomTable(uint64_t a1, int a2)
{
  void *v4;
  size_t v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  int v10;
  char *v11;
  char *v12;

  if (*(_DWORD *)(a1 + 68) < a2)
  {
    v4 = *(void **)(a1 + 48);
    v5 = 4 * a2;
    if (v4)
    {
      v6 = (char *)malloc_type_realloc(v4, 4 * a2, 0x2BDC8648uLL);
      if (v6)
      {
        v7 = v6;
        v8 = (char *)malloc_type_realloc(*(void **)(a1 + 56), v5, 0x2BDC8648uLL);
        if (v8)
        {
          v9 = v8;
          v10 = *(_DWORD *)(a1 + 68);
LABEL_9:
          bzero(&v7[4 * v10], 4 * (a2 - v10));
          bzero(&v9[4 * *(int *)(a1 + 68)], 4 * (a2 - *(_DWORD *)(a1 + 68)));
          *(_QWORD *)(a1 + 48) = v7;
          *(_QWORD *)(a1 + 56) = v9;
          *(_DWORD *)(a1 + 68) = a2;
          return;
        }
      }
    }
    else
    {
      v11 = (char *)malloc_type_malloc(4 * a2, 0x7081ABB9uLL);
      if (v11)
      {
        v7 = v11;
        v12 = (char *)malloc_type_malloc(v5, 0x7081ABB9uLL);
        if (v12)
        {
          v9 = v12;
          v10 = 0;
          *(_DWORD *)(a1 + 68) = 0;
          goto LABEL_9;
        }
      }
    }
    abort();
  }
}

uint64_t AddAtomFixed(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5;
  int v6;
  BOOL v7;
  int v8;
  int v9;
  _DWORD *v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  int v16;
  BOOL v17;
  char v18;
  int v19;

  v5 = LookUpAddStringHash();
  v6 = *(_DWORD *)(a1 + 68);
  v7 = *(_DWORD *)(a1 + 64) >= v6 || v6 <= (int)a3;
  if (v7)
  {
    v8 = 2 * v6;
    if (v8 <= (int)a3)
      v9 = a3 + 1;
    else
      v9 = v8;
    GrowAtomTable(a1, v9);
  }
  v10 = (_DWORD *)(*(_QWORD *)(a1 + 16) + 8 * v5);
  *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * (int)a3) = *v10;
  v10[1] = a3;
  v11 = *(_DWORD *)(a1 + 64);
  if (v11 <= (int)a3)
  {
    v12 = *(_QWORD *)(a1 + 56);
    do
    {
      if (v11)
      {
        v13 = 0;
        v14 = 0;
        v15 = v11;
        do
        {
          v16 = v15 & 1 | (2 * v14);
          ++v13;
          v14 = v16;
          v7 = v15 > 1;
          v15 >>= 1;
        }
        while (v7);
      }
      else
      {
        v16 = 0;
        v13 = 0;
      }
      v17 = v13 <= 0x14;
      v18 = 20 - v13;
      if (!v17)
        v18 = 0;
      *(_DWORD *)(v12 + 4 * v11) = v16 << v18;
      v19 = *(_DWORD *)(a1 + 64);
      v11 = v19 + 1;
      *(_DWORD *)(a1 + 64) = v19 + 1;
    }
    while (v19 < (int)a3);
  }
  return a3;
}

uint64_t GetStringOfAtom(_QWORD *a1, int a2)
{
  return *a1 + *(int *)(a1[6] + 4 * a2);
}

void FreeAtomTable(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = *(void **)a1;
  if (v2)
    free(v2);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v3 = *(void **)(a1 + 16);
  if (v3)
    free(v3);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  v4 = *(void **)(a1 + 48);
  if (v4)
    free(v4);
  v5 = *(void **)(a1 + 56);
  if (v5)
    free(v5);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
}

uint64_t FindHashLoc(uint64_t *a1, char *__s1)
{
  int v4;
  int v5;
  char *v6;
  signed __int8 v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  char *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;

  v4 = *__s1;
  if (*__s1)
  {
    v5 = 0;
    v6 = __s1 + 1;
    v7 = *__s1;
    do
    {
      v5 = (13507 * v5 + 197 * v7) ^ (v5 >> 2);
      v8 = *v6++;
      v7 = v8;
    }
    while (v8);
    v9 = v5 & 0x7FFFFFFF;
  }
  else
  {
    v9 = 0;
  }
  v10 = *((_DWORD *)a1 + 6);
  v11 = (v9 % v10);
  v12 = a1[2];
  v13 = *(int *)(v12 + 8 * v11);
  if ((_DWORD)v13)
  {
    v14 = *a1;
    if (strcmp(__s1, (const char *)(*a1 + v13)))
    {
      v15 = 0;
      if (v4)
      {
        v16 = __s1 + 1;
        do
        {
          v15 = (729 * v15 + 37 * (char)v4) ^ (v15 >> 1);
          v17 = *v16++;
          LOBYTE(v4) = v17;
        }
        while (v17);
      }
      v18 = 0;
      while (1)
      {
        v11 = (((v11 + v15) & 0x7FFFFFFF) % v10);
        v19 = *(int *)(v12 + 8 * v11);
        if (!(_DWORD)v19)
          break;
        if (!strcmp(__s1, (const char *)(v14 + v19)))
          return v11;
        v18 += 4;
        if ((_DWORD)v18 == 12)
          return 0xFFFFFFFFLL;
      }
      ++*(_DWORD *)((char *)a1 + v18 + 32);
    }
  }
  return v11;
}

uint64_t lazyCPPSetup(uint64_t result)
{
  uint64_t v1;

  if (!*(_DWORD *)(result + 28))
  {
    v1 = result;
    glpInitializeExtensionBehavior(*(_QWORD *)(result + 32));
    glpAddExtensionDefines(*(_QWORD *)(v1 + 32));
    result = glpParseContextValidateGLSLVersion(*(_QWORD *)(v1 + 32));
    *(_DWORD *)(v1 + 28) = 1;
  }
  return result;
}

uint64_t InitCPP(uint64_t a1)
{
  uint64_t v2;
  int8x8_t v3;
  _QWORD *Pool;

  v2 = a1 + 384;
  *(_DWORD *)(a1 + 456) = LookUpAddString(a1 + 384, "define");
  *(_DWORD *)(a1 + 460) = LookUpAddString(v2, "defined");
  *(_DWORD *)(a1 + 468) = LookUpAddString(v2, "elif");
  *(_DWORD *)(a1 + 464) = LookUpAddString(v2, "else");
  *(_DWORD *)(a1 + 472) = LookUpAddString(v2, "endif");
  *(_DWORD *)(a1 + 476) = LookUpAddString(v2, "if");
  *(_DWORD *)(a1 + 480) = LookUpAddString(v2, "ifdef");
  *(_DWORD *)(a1 + 484) = LookUpAddString(v2, "ifndef");
  *(_DWORD *)(a1 + 488) = LookUpAddString(v2, "include");
  *(_DWORD *)(a1 + 492) = LookUpAddString(v2, "line");
  *(_DWORD *)(a1 + 496) = LookUpAddString(v2, "pragma");
  *(_DWORD *)(a1 + 500) = LookUpAddString(v2, "undef");
  *(_DWORD *)(a1 + 504) = LookUpAddString(v2, "error");
  *(_DWORD *)(a1 + 508) = LookUpAddString(v2, "__LINE__");
  *(_DWORD *)(a1 + 512) = LookUpAddString(v2, "__FILE__");
  *(_DWORD *)(a1 + 516) = LookUpAddString(v2, "__VERSION__");
  *(_DWORD *)(a1 + 520) = LookUpAddString(v2, "version");
  *(_DWORD *)(a1 + 524) = LookUpAddString(v2, "extension");
  *(_DWORD *)(a1 + 528) = LookUpAddString(v2, "core");
  *(_DWORD *)(a1 + 532) = LookUpAddString(v2, "es");
  Pool = mem_CreatePool(0, 0, v3);
  *(_QWORD *)(a1 + 536) = NewScopeInPool(a1, Pool);
  return 1;
}

uint64_t FreeCPP(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 536);
  if (v1)
  {
    mem_FreePool(*(_QWORD **)(v1 + 40));
    *(_QWORD *)(a1 + 536) = 0;
  }
  return 1;
}

BOOL op_logor(int a1, int a2)
{
  return (a2 | a1) != 0;
}

BOOL op_logand(int a1, int a2)
{
  BOOL v2;

  if (a1)
    v2 = a2 == 0;
  else
    v2 = 1;
  return !v2;
}

uint64_t op_or(unsigned int a1, int a2)
{
  return a2 | a1;
}

uint64_t op_xor(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

uint64_t op_and(unsigned int a1, int a2)
{
  return a2 & a1;
}

BOOL op_eq(int a1, int a2)
{
  return a1 == a2;
}

BOOL op_ne(int a1, int a2)
{
  return a1 != a2;
}

BOOL op_gt(int a1, int a2)
{
  return a1 > a2;
}

BOOL op_ge(int a1, int a2)
{
  return a1 >= a2;
}

BOOL op_lt(int a1, int a2)
{
  return a1 < a2;
}

BOOL op_le(int a1, int a2)
{
  return a1 <= a2;
}

uint64_t op_shl(int a1, char a2)
{
  return (a1 << a2);
}

uint64_t op_shr(int a1, char a2)
{
  return (a1 >> a2);
}

uint64_t op_add(int a1, int a2)
{
  return (a2 + a1);
}

uint64_t op_sub(int a1, int a2)
{
  return (a1 - a2);
}

uint64_t op_mul(int a1, int a2)
{
  return (a2 * a1);
}

uint64_t op_div(int a1, int a2)
{
  if (a2)
    return (a1 / a2);
  else
    return 0x7FFFFFFFLL;
}

uint64_t op_mod(int a1, int a2)
{
  if (a2)
    return (a1 % a2);
  else
    return 0x7FFFFFFFLL;
}

uint64_t op_neg(int a1)
{
  return -a1;
}

uint64_t op_cmpl(int a1)
{
  return ~a1;
}

BOOL op_not(int a1)
{
  return a1 == 0;
}

uint64_t readCPPline(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  const char *StringOfAtom;
  size_t v18;
  char *v19;
  uint64_t v20;
  int v21;
  BOOL v22;
  int v23;
  int v24;
  int v25;
  _DWORD *v26;
  int v27;
  uint64_t v28;
  const char *AtomString;
  uint64_t *v30;
  int v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int *v42;
  uint64_t v43;
  int *v44;
  int v45;
  int v46;
  int v47;
  int Token;
  int v49;
  int v50;
  uint64_t v51;
  int v52;
  char v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char v60;
  uint64_t v61;
  uint64_t v62;
  int *v63;
  int v64;
  uint64_t v65;
  char v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  char ErrMsg;
  _DWORD *v76;
  char __s2[1026];
  _DWORD __src[64];
  uint64_t v79;

  v79 = *MEMORY[0x24BDAC8D0];
  v10 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  if ((_DWORD)v10 != 270)
    goto LABEL_112;
  v11 = *(_DWORD *)(a2 + 12);
  if (v11 != *(_DWORD *)(a1 + 520) && !*(_DWORD *)(a1 + 28))
  {
    StringOfAtom = (const char *)GetStringOfAtom((_QWORD *)(a1 + 384), v11);
    v18 = strlen(StringOfAtom);
    v19 = (char *)malloc_type_malloc(v18 + 4, 0x7081ABB9uLL);
    if (!v19)
      abort();
    v20 = (uint64_t)v19;
    sprintf_l(v19, 0, "#%s", StringOfAtom);
    ScanFromSimpleString(a1, v20, 0);
    lazyCPPSetup(a1);
    return 10;
  }
  if (v11 != *(_DWORD *)(a1 + 456))
  {
    if (v11 == *(_DWORD *)(a1 + 464))
    {
      v15 = *(unsigned int *)(a1 + 40);
      if ((int)v15 < 1)
      {
        v14 = "#else mismatch";
        goto LABEL_110;
      }
      if (*(_DWORD *)(a1 + 4 * v15 + 44))
      {
        v14 = "#else after a #else";
        goto LABEL_110;
      }
      if ((*(unsigned int (**)(void))(*(_QWORD *)(a1 + 16) + 16))() != 10)
      {
        if ((int)glpCompilerGetIOSVersion(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 784)) < 10)
          glpCPPWarningToInfoLog(a1, (char)"unexpected tokens following #else preprocessor directive - expected a newline");
        else
          glpCPPErrorToInfoLog(a1, (char)"unexpected tokens following #else preprocessor directive - expected a newline");
        while ((*(unsigned int (**)(void))(*(_QWORD *)(a1 + 16) + 16))() != 10)
          ;
      }
      *(_DWORD *)(a1 + 4 * *(int *)(a1 + 40) + 44) = 1;
LABEL_99:
      v28 = CPPelse(a1, 0, a2);
      goto LABEL_100;
    }
    if (v11 == *(_DWORD *)(a1 + 468))
    {
      v16 = *(unsigned int *)(a1 + 40);
      if ((int)v16 < 1)
      {
        v14 = "#elif mismatch";
        goto LABEL_110;
      }
      if (*(_DWORD *)(a1 + 4 * v16 + 44))
      {
        v14 = "#elif after a #else";
        goto LABEL_110;
      }
      while ((*(unsigned int (**)(void))(*(_QWORD *)(a1 + 16) + 16))() != 10)
        ;
      goto LABEL_99;
    }
    if (v11 == *(_DWORD *)(a1 + 472))
    {
      v21 = *(_DWORD *)(a1 + 40);
      v22 = __OFSUB__(v21, 1);
      v23 = v21 - 1;
      if (v23 < 0 != v22)
      {
        v14 = "#endif mismatch";
        goto LABEL_110;
      }
      *(_DWORD *)(a1 + 40) = v23;
      if ((*(unsigned int (**)(void))(*(_QWORD *)(a1 + 16) + 16))() != 10)
      {
        if ((int)glpCompilerGetIOSVersion(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 784)) < 8)
          glpCPPWarningToInfoLog(a1, (char)"unexpected tokens following #endif preprocessor directive - expected a newline");
        else
          glpCPPErrorToInfoLog(a1, (char)"unexpected tokens following #endif preprocessor directive - expected a newline");
        v10 = 10;
        while ((*(unsigned int (**)(void))(*(_QWORD *)(a1 + 16) + 16))() != 10)
          ;
        goto LABEL_112;
      }
      goto LABEL_27;
    }
    if (v11 == *(_DWORD *)(a1 + 476))
    {
      v28 = CPPif (a1, a2);
    }
    else
    {
      if (v11 == *(_DWORD *)(a1 + 480))
      {
        v51 = a1;
        v52 = 1;
      }
      else
      {
        if (v11 != *(_DWORD *)(a1 + 484))
        {
          if (v11 == *(_DWORD *)(a1 + 488))
          {
            if (glpIsExtensionEnabled(*(_QWORD *)(a1 + 32), 0x19u)
              || glpIsExtensionEnabled(*(_QWORD *)(a1 + 32), 0x23u))
            {
              v28 = CPPinclude(a1, a2);
              goto LABEL_100;
            }
            v11 = *(_DWORD *)(a2 + 12);
          }
          if (v11 == *(_DWORD *)(a1 + 492))
          {
            v28 = CPPline((_QWORD *)a1, a2);
            goto LABEL_100;
          }
          if (v11 == *(_DWORD *)(a1 + 496))
          {
            v28 = CPPpragma(a1, a2);
            goto LABEL_100;
          }
          if (v11 == *(_DWORD *)(a1 + 500))
          {
            v28 = CPPundef(a1, a2);
            goto LABEL_100;
          }
          if (v11 != *(_DWORD *)(a1 + 504))
          {
            if (v11 == *(_DWORD *)(a1 + 520))
            {
              v28 = CPPversion(a1, a2);
            }
            else
            {
              if (v11 != *(_DWORD *)(a1 + 524))
              {
                glpStoreErrMsg(a1, (char)"Invalid Directive:", v4, v5, v6, v7, v8, v9);
                v68 = GetStringOfAtom((_QWORD *)(a1 + 384), *(_DWORD *)(a2 + 12));
                glpStoreErrMsg(a1, v68, v69, v70, v71, v72, v73, v74);
                ErrMsg = glpGetErrMsg(a1);
                glpCPPShInfoLogMsg(a1, ErrMsg);
                glpResetErrMsg(a1);
                goto LABEL_111;
              }
              v28 = CPPextension(a1, a2);
            }
            goto LABEL_100;
          }
          CPPerror(a1, a2);
LABEL_27:
          v10 = 10;
          goto LABEL_112;
        }
        v51 = a1;
        v52 = 0;
      }
      v28 = CPPifdef(v51, v52, a2);
    }
LABEL_100:
    v10 = v28;
    goto LABEL_112;
  }
  v12 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  if ((_DWORD)v12 != 270)
  {
    v10 = v12;
LABEL_15:
    glpCPPErrorToInfoLog(a1, (char)"#define");
    goto LABEL_112;
  }
  if (!*(_DWORD *)(a1 + 28))
    lazyCPPSetup(a1);
  v13 = *(_DWORD *)(a2 + 12);
  if (checkReservedName(a1, v13))
  {
    v14 = "#define of reserved name";
    goto LABEL_110;
  }
  v24 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  if (v24 != 40)
  {
    v27 = v24;
    v25 = 0;
    v26 = 0;
LABEL_39:
    AtomString = GetAtomString(a1 + 384, v13);
    v30 = NewTokenStream(a1, AtomString, *(_QWORD **)(*(_QWORD *)(a1 + 536) + 40));
    while ((v27 + 1) > 0xB || ((1 << (v27 + 1)) & 0x803) == 0)
    {
      while (v27 == 92)
      {
        v32 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
        if ((v32 + 1) > 0xB || ((1 << (v32 + 1)) & 0x803) == 0)
        {
          v27 = v32;
          RecordToken(v30, 92, a2);
        }
        else
        {
          v27 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
        }
      }
      if ((v27 + 1) > 0xB || ((1 << (v27 + 1)) & 0x803) == 0)
      {
        RecordToken(v30, v27, a2);
        v27 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
      }
    }
    v34 = LookUpSymbol(a1, *(_QWORD *)(a1 + 536), v13);
    if (v34)
    {
      v41 = v34;
      if ((*(_BYTE *)(v34 + 56) & 2) == 0)
      {
        v76 = v26;
        if (*(_DWORD *)(v34 + 32) == v25)
        {
          if (v25 < 1)
          {
LABEL_62:
            RewindTokenStream(*(_QWORD *)(v34 + 48));
            RewindTokenStream((uint64_t)v30);
            while (1)
            {
              bzero((void *)a2, 0x420uLL);
              Token = ReadToken(*(uint64_t **)(v41 + 48), a2);
              v49 = *(_DWORD *)(a2 + 12);
              v50 = *(_DWORD *)(a2 + 20);
              __strcpy_chk();
              bzero((void *)a2, 0x420uLL);
              if (ReadToken(v30, a2) != Token
                || *(_DWORD *)(a2 + 12) != v49
                || *(_DWORD *)(a2 + 20) != v50
                || strcmp((const char *)(a2 + 24), __s2))
              {
                break;
              }
              if (Token <= 0)
                goto LABEL_73;
            }
          }
          else
          {
            v42 = *(int **)(v34 + 40);
            v43 = v25;
            v44 = v26;
            while (1)
            {
              v46 = *v42++;
              v45 = v46;
              v47 = *v44++;
              if (v45 != v47)
                break;
              if (!--v43)
                goto LABEL_62;
            }
          }
        }
        glpStoreErrMsg(a1, (char)"Macro Redefined", v35, v36, v37, v38, v39, v40);
        v53 = GetStringOfAtom((_QWORD *)(a1 + 384), v13);
        glpStoreErrMsg(a1, v53, v54, v55, v56, v57, v58, v59);
        v60 = glpGetErrMsg(a1);
        glpDecLineNumber(a1);
        glpCPPShInfoLogMsg(a1, v60);
        glpIncLineNumber(a1);
        glpResetErrMsg(a1);
LABEL_73:
        v26 = v76;
      }
    }
    else
    {
      v41 = AddSymbol(a1, *(_QWORD *)(a1 + 536), v13, 0);
    }
    *(_DWORD *)(v41 + 32) = v25;
    *(_DWORD *)(v41 + 36) = 0;
    *(_QWORD *)(v41 + 40) = v26;
    *(_QWORD *)(v41 + 48) = v30;
    v10 = 10;
    *(_QWORD *)(v41 + 56) = 0;
    goto LABEL_112;
  }
  if (*(_DWORD *)(a2 + 16))
  {
    v25 = 0;
    v26 = 0;
    v27 = 40;
    goto LABEL_39;
  }
  v25 = 0;
  while (1)
  {
    v61 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
    v10 = v61;
    if (!v25 && (_DWORD)v61 == 41)
    {
      v25 = 0;
LABEL_120:
      v26 = (_DWORD *)mem_Alloc(*(_QWORD **)(*(_QWORD *)(a1 + 536) + 40), 4 * v25);
      memcpy(v26, __src, 4 * v25);
      v27 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
      *(_DWORD *)(a2 + 20) = 1;
      goto LABEL_39;
    }
    if ((_DWORD)v61 != 270)
      goto LABEL_15;
    if (v25 <= 63)
      break;
    if ((int)glpCompilerGetIOSVersion(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 784)) >= 10)
    {
      v14 = "too many arguments for #define";
      goto LABEL_110;
    }
LABEL_90:
    v65 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
    if ((_DWORD)v65 != 44)
    {
      v10 = v65;
      if ((_DWORD)v65 != 41)
        goto LABEL_15;
      goto LABEL_120;
    }
  }
  if (v25 < 1)
  {
LABEL_88:
    __src[v25++] = *(_DWORD *)(a2 + 12);
    goto LABEL_90;
  }
  v62 = v25;
  v63 = __src;
  while (1)
  {
    v64 = *v63++;
    if (v64 == *(_DWORD *)(a2 + 12) && (int)glpCompilerGetIOSVersion(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 784)) >= 10)
      break;
    if (!--v62)
      goto LABEL_88;
  }
  v14 = "#define has duplicate argument names";
LABEL_110:
  glpCPPErrorToInfoLog(a1, (char)v14);
LABEL_111:
  v10 = 270;
LABEL_112:
  while ((v10 + 1) > 0xB || ((1 << (v10 + 1)) & 0x803) == 0)
    v10 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  lazyCPPSetup(a1);
  return v10;
}

uint64_t CPPelse(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t result;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  int v14;
  const char *v15;
  int v16;
  int v17;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  if ((int)result < 1)
    return result;
  v7 = *(_DWORD *)(a1 + 40);
  while (1)
  {
    if ((_DWORD)result == 10)
      goto LABEL_13;
    if ((_DWORD)result != 35)
    {
      while ((*(unsigned int (**)(void))(*(_QWORD *)(a1 + 16) + 16))() != 10)
        ;
LABEL_13:
      result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
      goto LABEL_14;
    }
    result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
    if ((_DWORD)result == 270)
      break;
LABEL_14:
    if ((int)result <= 0)
      return result;
  }
  v8 = *(_DWORD *)(a3 + 12);
  if (v8 == *(_DWORD *)(a1 + 476) || v8 == *(_DWORD *)(a1 + 480) || v8 == *(_DWORD *)(a1 + 484))
  {
    v9 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 40) = v9;
    if (v9 >= 0x40)
    {
      glpCPPErrorToInfoLog(a1, (char)"max #if nesting depth exceeded");
      return 0;
    }
    *(_DWORD *)(a1 + 4 * v9 + 44) = 0;
    goto LABEL_11;
  }
  if (v8 == *(_DWORD *)(a1 + 472))
  {
    v10 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = v10 - 1;
    if (v10 <= v7)
    {
      result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
      if ((_DWORD)result != 10)
      {
        if ((int)glpCompilerGetIOSVersion(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 784)) < 8)
          glpCPPWarningToInfoLog(a1, (char)"unexpected tokens following #endif preprocessor directive - expected a newline");
        else
          glpCPPErrorToInfoLog(a1, (char)"unexpected tokens following #endif preprocessor directive - expected a newline");
        do
        {
          v16 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
          result = 10;
        }
        while (v16 != 10);
      }
      return result;
    }
    goto LABEL_11;
  }
  if (v8 == *(_DWORD *)(a1 + 468))
  {
    v11 = *(int *)(a1 + 40);
    if (!*(_DWORD *)(a1 + 4 * v11 + 44))
    {
      result = 270;
      if (a2 && (_DWORD)v11 == v7)
      {
        *(_DWORD *)(a1 + 40) = v7 - 1;
        return CPPif (a1, a3);
      }
      goto LABEL_14;
    }
    v15 = "#elif after a #else";
LABEL_38:
    glpCPPErrorToInfoLog(a1, (char)v15);
    return 270;
  }
  if (v8 != *(_DWORD *)(a1 + 464))
  {
LABEL_11:
    result = 270;
    goto LABEL_14;
  }
  v12 = a1 + 4 * *(int *)(a1 + 40);
  v14 = *(_DWORD *)(v12 + 44);
  v13 = (_DWORD *)(v12 + 44);
  if (v14)
  {
    v15 = "#else after a #else";
    goto LABEL_38;
  }
  *v13 = 1;
  result = 270;
  if (!a2 || *(_DWORD *)(a1 + 40) != v7)
    goto LABEL_14;
  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  if ((_DWORD)result != 10)
  {
    if ((int)glpCompilerGetIOSVersion(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 784)) < 10)
      glpCPPWarningToInfoLog(a1, (char)"unexpected tokens following #else preprocessor directive - expected a newline");
    else
      glpCPPErrorToInfoLog(a1, (char)"unexpected tokens following #else preprocessor directive - expected a newline");
    do
    {
      v17 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
      result = 10;
    }
    while (v17 != 10);
  }
  return result;
}

uint64_t CPPif (uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v7;

  v4 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  v7 = 0;
  if (!*(_DWORD *)(a1 + 28))
    lazyCPPSetup(a1);
  v5 = *(_DWORD *)(a1 + 40) + 1;
  *(_DWORD *)(a1 + 40) = v5;
  if (v5 < 0x40)
  {
    *(_DWORD *)(a1 + 4 * v5 + 44) = 0;
    if (eval(a1, v4, 0, (_BOOL4 *)&v7 + 1, &v7, a2, 0) != 10)
    {
      glpCPPErrorToInfoLog(a1, (char)"unexpected tokens following #if preprocessor directive - expected a newline");
      while ((*(unsigned int (**)(void))(*(_QWORD *)(a1 + 16) + 16))() != 10)
        ;
    }
    if (v7)
      return 10;
    else
      return CPPelse(a1, 1, a2);
  }
  else
  {
    glpCPPErrorToInfoLog(a1, (char)"max #if nesting depth exceeded");
    return 0;
  }
}

uint64_t CPPifdef(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  const char *v10;
  int v11;

  v6 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  v7 = *(_DWORD *)(a3 + 12);
  if (!*(_DWORD *)(a1 + 28))
    lazyCPPSetup(a1);
  v8 = *(_DWORD *)(a1 + 40) + 1;
  *(_DWORD *)(a1 + 40) = v8;
  if (v8 >= 0x40)
  {
    glpCPPErrorToInfoLog(a1, (char)"max #if nesting depth exceeded");
    return 0;
  }
  *(_DWORD *)(a1 + 4 * v8 + 44) = 0;
  if ((_DWORD)v6 != 270)
  {
    if (a2)
      v10 = "ifdef";
    else
      v10 = "ifndef";
    glpCPPErrorToInfoLog(a1, (char)v10);
    return v6;
  }
  v9 = LookUpSymbol(a1, *(_QWORD *)(a1 + 536), v7);
  if ((*(unsigned int (**)(void))(*(_QWORD *)(a1 + 16) + 16))() != 10)
  {
    if ((int)glpCompilerGetIOSVersion(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 784)) < 10)
      glpCPPWarningToInfoLog(a1, (char)"unexpected tokens following #ifdef preprocessor directive - expected a newline");
    else
      glpCPPErrorToInfoLog(a1, (char)"unexpected tokens following #ifdef preprocessor directive - expected a newline");
    while ((*(unsigned int (**)(void))(*(_QWORD *)(a1 + 16) + 16))() != 10)
      ;
  }
  if (v9)
    v11 = ((*(_DWORD *)(v9 + 56) >> 1) & 1) == 0;
  else
    v11 = 0;
  if (v11 == a2)
    return 10;
  return CPPelse(a1, 1, a3);
}

uint64_t CPPinclude(uint64_t a1, uint64_t a2)
{
  int v4;
  char *StringOfAtom;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char ErrMsg;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  _QWORD v43[2];

  v43[1] = *MEMORY[0x24BDAC8D0];
  if (!*(_DWORD *)(a1 + 28))
    lazyCPPSetup(a1);
  *(_DWORD *)(a1 + 352) |= 2u;
  while (1)
  {
    v4 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
    if (v4 != 270)
      break;
    if (!MacroExpand((_QWORD *)a1, *(_DWORD *)(a2 + 12), a2))
    {
      *(_DWORD *)(a1 + 352) &= ~2u;
LABEL_16:
      glpCPPErrorToInfoLog(a1, (char)"#include");
      return 10;
    }
  }
  *(_DWORD *)(a1 + 352) &= ~2u;
  if (v4 != 278)
    goto LABEL_16;
  StringOfAtom = (char *)GetStringOfAtom((_QWORD *)(a1 + 384), *(_DWORD *)(a2 + 12));
  if ((*(unsigned int (**)(void))(*(_QWORD *)(a1 + 16) + 16))() != 10)
  {
    glpCPPWarningToInfoLog(a1, (char)"unexpected tokens following #include preprocessor directive - expected a newline");
    while ((*(unsigned int (**)(void))(*(_QWORD *)(a1 + 16) + 16))() != 10)
      ;
  }
  if (!*(_QWORD *)(a1 + 368) || !*(_QWORD *)(a1 + 376))
  {
    glpStoreErrMsg(a1, (char)"GetInclude, FreeInclude callbacks unset, cannot #include", v6, v7, v8, v9, v10, v11);
    glpStoreErrMsg(a1, (char)StringOfAtom, v23, v24, v25, v26, v27, v28);
    ErrMsg = glpGetErrMsg(a1);
    glpDecLineNumber(a1);
    glpCPPShInfoLogMsg(a1, ErrMsg);
    glpIncLineNumber(a1);
    glpResetErrMsg(a1);
    return 0;
  }
  v12 = strlen(StringOfAtom);
  v13 = (char *)v43 - ((MEMORY[0x24BDAC7A8](v12) + 16) & 0xFFFFFFFFFFFFFFF0);
  strncpy(v13, StringOfAtom, v12);
  v13[v12] = 0;
  v14 = (*(uint64_t (**)(_QWORD, char *))(a1 + 368))(*(_QWORD *)(a1 + 360), v13);
  if (!v14)
  {
    glpStoreErrMsg(a1, (char)"Cannot #include", v15, v16, v17, v18, v19, v20);
    glpStoreErrMsg(a1, (char)StringOfAtom, v30, v31, v32, v33, v34, v35);
    glpStoreErrMsg(a1, (char)"not found", v36, v37, v38, v39, v40, v41);
    v42 = glpGetErrMsg(a1);
    glpDecLineNumber(a1);
    glpCPPShInfoLogMsg(a1, v42);
    glpIncLineNumber(a1);
    glpResetErrMsg(a1);
    return 0;
  }
  v21 = *(_DWORD *)(a1 + 356);
  *(_DWORD *)(a1 + 356) = v21 + 1;
  if (v21 >= 199)
  {
    glpDecLineNumber(a1);
    glpCPPShInfoLogMsg(a1, (char)"#include nested too deeply");
    glpIncLineNumber(a1);
    return 0;
  }
  ScanFromIncludeString(a1, v14, StringOfAtom);
  return 10;
}

uint64_t CPPline(_QWORD *a1, uint64_t a2)
{
  uint64_t (*i)(void);
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  char *StringOfAtom;

  for (i = *(uint64_t (**)(void))(a1[2] + 16); ; i = *(uint64_t (**)(void))(a1[2] + 16))
  {
    v5 = i();
    v6 = v5;
    if ((_DWORD)v5 != 270)
      break;
    if (!MacroExpand(a1, *(_DWORD *)(a2 + 12), a2))
      goto LABEL_26;
  }
  if ((_DWORD)v5 == 10)
  {
    glpDecLineNumber((uint64_t)a1);
    glpCPPErrorToInfoLog((uint64_t)a1, (char)"#line");
    glpIncLineNumber((uint64_t)a1);
    return v6;
  }
  if ((_DWORD)v5 != 271)
    goto LABEL_26;
  v7 = strtol_l((const char *)(a2 + 24), 0, 10, 0);
  *(_DWORD *)(a2 + 16) = v7;
  glpSetLineNumber((uint64_t)a1, v7 - (*(_DWORD *)a1 > 5u));
  while (1)
  {
    v8 = (*(uint64_t (**)(void))(a1[2] + 16))();
    v6 = v8;
    if ((_DWORD)v8 != 270)
      break;
    if (!MacroExpand(a1, *(_DWORD *)(a2 + 12), a2))
      goto LABEL_26;
  }
  if ((_DWORD)v8 != 10)
  {
    if ((_DWORD)v8 == 271)
    {
      glpSetFilename((uint64_t)a1, (char *)(a2 + 24));
      while (1)
      {
        v6 = (*(uint64_t (**)(void))(a1[2] + 16))();
        if ((_DWORD)v6 != 270)
          break;
        if (!MacroExpand(a1, *(_DWORD *)(a2 + 12), a2))
          goto LABEL_26;
      }
LABEL_25:
      if ((_DWORD)v6 == 10)
        return v6;
      goto LABEL_26;
    }
    if ((_DWORD)v8 == 278 && (glpIsExtensionEnabled(a1[4], 0x19u) || glpIsExtensionEnabled(a1[4], 0x23u)))
    {
      StringOfAtom = (char *)GetStringOfAtom(a1 + 48, *(_DWORD *)(a2 + 12));
      glpSetFilename((uint64_t)a1, StringOfAtom);
      do
      {
        v6 = (*(uint64_t (**)(void))(a1[2] + 16))();
        if ((_DWORD)v6 != 270)
          goto LABEL_25;
      }
      while (MacroExpand(a1, *(_DWORD *)(a2 + 12), a2));
    }
LABEL_26:
    glpCPPErrorToInfoLog((uint64_t)a1, (char)"#line");
  }
  return v6;
}

uint64_t CPPpragma(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  int v6;
  void *v7;
  void *v8;
  uint64_t v9;
  int v10;
  void *v11;
  const char *AtomString;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  uint64_t v17;
  void **v18;
  void *v19;
  char __src[2];

  v4 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  if (v4 == 10)
    return 10;
  v6 = v4;
  v7 = malloc_type_malloc(0x50uLL, 0x7081ABB9uLL);
  if (!v7)
LABEL_26:
    abort();
  v8 = v7;
  v9 = 0;
  v10 = 10;
  do
  {
    if (v9 >= v10)
    {
      v10 *= 2;
      v11 = malloc_type_realloc(v8, 8 * v10, 0x2BDC8648uLL);
      if (!v11)
        goto LABEL_26;
      v8 = v11;
    }
    if (v6 > 269)
    {
      if (v6 == 271)
      {
LABEL_16:
        v16 = strlen((const char *)(a2 + 24));
        v14 = (char *)malloc_type_malloc(v16 + 1, 0x7081ABB9uLL);
        if (!v14)
          goto LABEL_26;
        *((_QWORD *)v8 + v9) = v14;
        v15 = (char *)(a2 + 24);
        goto LABEL_20;
      }
      if (v6 == 270)
      {
        AtomString = GetAtomString(a1 + 384, *(_DWORD *)(a2 + 12));
        v13 = strlen(AtomString);
        v14 = (char *)malloc_type_malloc(v13 + 1, 0x7081ABB9uLL);
        if (!v14)
          goto LABEL_26;
        *((_QWORD *)v8 + v9) = v14;
        v15 = (char *)AtomString;
        goto LABEL_20;
      }
    }
    else
    {
      if ((v6 - 266) < 2)
        goto LABEL_16;
      if (v6 == -1)
      {
        glpCPPShInfoLogMsg(a1, (char)"#pragma directive must end with a newline");
        return 0xFFFFFFFFLL;
      }
    }
    __src[0] = v6;
    __src[1] = 0;
    v14 = (char *)malloc_type_malloc(2uLL, 0x7081ABB9uLL);
    if (!v14)
      goto LABEL_26;
    *((_QWORD *)v8 + v9) = v14;
    v15 = __src;
LABEL_20:
    strcpy(v14, v15);
    ++v9;
    v6 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  }
  while (v6 != 10);
  (*(void (**)(void))(*(_QWORD *)(a1 + 16) + 32))();
  glpHandlePragma(a1, (const char **)v8, v9);
  v5 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  if ((_DWORD)v9)
  {
    v17 = v9;
    v18 = (void **)v8;
    do
    {
      v19 = *v18++;
      free(v19);
      --v17;
    }
    while (v17);
  }
  free(v8);
  return v5;
}

uint64_t CPPundef(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  uint64_t v8;

  v4 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  if ((_DWORD)v4 != 270)
  {
    v5 = v4;
    goto LABEL_5;
  }
  if (checkReservedName(a1, *(_DWORD *)(a2 + 12)))
  {
    v5 = 270;
    v6 = "#undef of reserved name";
LABEL_6:
    glpCPPErrorToInfoLog(a1, (char)v6);
    return v5;
  }
  v8 = LookUpSymbol(a1, *(_QWORD *)(a1 + 536), *(_DWORD *)(a2 + 12));
  if (v8)
    *(_DWORD *)(v8 + 56) |= 2u;
  v5 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  if ((_DWORD)v5 != 10)
  {
LABEL_5:
    v6 = "#undef";
    goto LABEL_6;
  }
  return v5;
}

uint64_t CPPerror(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  char StringOfAtom;
  int v20;
  _QWORD *v21;
  char ErrMsg;

  v4 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  glpStoreErrMsg(a1, (char)"", v5, v6, v7, v8, v9, v10);
  while (1)
  {
    v17 = v4 - 9;
    if ((v4 - 265) > 0xD)
      break;
    if (((1 << v17) & 0x46) != 0)
    {
      v18 = a1;
      StringOfAtom = a2 + 24;
      goto LABEL_11;
    }
    if (((1 << v17) & 0x2020) == 0)
    {
      if (v4 == 265)
        goto LABEL_12;
      break;
    }
    v20 = *(_DWORD *)(a2 + 12);
    v21 = (_QWORD *)(a1 + 384);
LABEL_10:
    StringOfAtom = GetStringOfAtom(v21, v20);
    v18 = a1;
LABEL_11:
    glpStoreErrMsg(v18, StringOfAtom, v11, v12, v13, v14, v15, v16);
    v4 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  }
  if (v4 != 10)
  {
    v21 = (_QWORD *)(a1 + 384);
    v20 = v4;
    goto LABEL_10;
  }
LABEL_12:
  glpDecLineNumber(a1);
  ErrMsg = glpGetErrMsg(a1);
  glpCPPShInfoLogMsg(a1, ErrMsg);
  glpResetErrMsg(a1);
  return glpIncLineNumber(a1);
}

uint64_t CPPversion(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;

  v4 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  if (*(_DWORD *)(a1 + 28) == 1)
    glpCPPShInfoLogMsg(a1, (char)"#version must occur before any other statement in the program");
  if ((_DWORD)v4 != 271)
  {
    if ((_DWORD)v4 == 10)
    {
      glpDecLineNumber(a1);
      glpCPPErrorToInfoLog(a1, (char)"#version");
      glpIncLineNumber(a1);
      return v4;
    }
    glpCPPErrorToInfoLog(a1, (char)"#version");
  }
  v5 = strtol_l((const char *)(a2 + 24), 0, 10, 0);
  *(_DWORD *)(a2 + 16) = v5;
  glpParseContextSetGLSLVersion(*(_QWORD *)(a1 + 32), v5);
  v4 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  if ((_DWORD)v4 == 10 && *(_DWORD *)a1 != 6)
  {
    lazyCPPSetup(a1);
    return 10;
  }
  else
  {
    v6 = *(_DWORD *)(a2 + 12);
    if (v6 == *(_DWORD *)(a1 + 528) && *(_DWORD *)a1 >= 5u || v6 == *(_DWORD *)(a1 + 532) && *(_DWORD *)a1 == 6)
      lazyCPPSetup(a1);
    else
      glpCPPErrorToInfoLog(a1, (char)"#version");
  }
  return v4;
}

uint64_t CPPextension(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *AtomString;
  char *v11;
  const char *v12;

  if ((int)glpCompilerGetIOSVersion(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 784)) >= 10 && (*(_BYTE *)(a1 + 352) & 8) != 0)
    glpCPPErrorToInfoLog(a1, (char)"#extension must always be before any non-preprocessor tokens");
  v4 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  if (v4 != 270)
  {
    if (v4 == 10)
    {
      glpDecLineNumber(a1);
      glpCPPShInfoLogMsg(a1, (char)"extension name not specified");
      glpIncLineNumber(a1);
      return 10;
    }
    glpCPPErrorToInfoLog(a1, (char)"#extension");
  }
  v6 = *(_DWORD *)(a2 + 12);
  v7 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  if ((_DWORD)v7 != 58)
  {
    v5 = v7;
    v12 = "':' missing after extension name";
LABEL_14:
    glpCPPShInfoLogMsg(a1, (char)v12);
    return v5;
  }
  v8 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  if ((_DWORD)v8 != 270)
  {
    v5 = v8;
    v12 = "behavior for extension not specified";
    goto LABEL_14;
  }
  v9 = *(_QWORD *)(a1 + 32);
  AtomString = (char *)GetAtomString(a1 + 384, v6);
  v11 = (char *)GetAtomString(a1 + 384, *(_DWORD *)(a2 + 12));
  glpUpdateExtensionBehavior(v9, AtomString, v11);
  v5 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  if ((_DWORD)v5 != 10)
    glpCPPErrorToInfoLog(a1, (char)"#extension");
  return v5;
}

uint64_t MacroExpand(_QWORD *a1, int a2, uint64_t a3)
{
  uint64_t v6;
  int LineNumber;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v12;
  uint64_t Filename;
  uint64_t v14;
  char *v15;
  int **v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  _BOOL4 v32;
  const char *v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  int v43;
  int v44;
  int v45;
  char StringOfAtom;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char ErrMsg;
  uint64_t v54;
  uint64_t *v55;
  int Token;
  uint64_t *v57;
  char *v58;
  int v59;
  int i;
  uint64_t v61;

  v6 = LookUpSymbol((uint64_t)a1, a1[67], a2);
  if (*((_DWORD *)a1 + 127) == a2)
  {
    LineNumber = glpGetLineNumber((uint64_t)a1);
LABEL_6:
    *(_DWORD *)(a3 + 16) = LineNumber;
    sprintf_l((char *)(a3 + 24), 0, "%d", LineNumber);
LABEL_7:
    v9 = (uint64_t)a1;
    v10 = 271;
LABEL_8:
    UngetToken(v9, v10, (const void *)a3);
    return 1;
  }
  if (*((_DWORD *)a1 + 128) == a2)
  {
    if ((*(char *)glpGetFilename((uint64_t)a1) - 48) > 9)
    {
      Filename = glpGetFilename((uint64_t)a1);
      *(_DWORD *)(a3 + 12) = LookUpAddString((uint64_t)(a1 + 48), (char *)Filename);
      v9 = (uint64_t)a1;
      v10 = 278;
      goto LABEL_8;
    }
    v8 = glpGetFilename((uint64_t)a1);
    LineNumber = strtol_l((const char *)v8, 0, 10, 0);
    goto LABEL_6;
  }
  if (*((_DWORD *)a1 + 129) == a2)
  {
    v12 = glpGLSLVersionToInt(*(_DWORD *)a1);
    sprintf_l((char *)(a3 + 24), 0, "%d", v12);
    *(_DWORD *)(a3 + 16) = strtol_l((const char *)(a3 + 24), 0, 10, 0);
    goto LABEL_7;
  }
  v14 = v6;
  if (!v6 || (*(_BYTE *)(v6 + 56) & 3) != 0)
    return 0;
  v15 = (char *)malloc_type_malloc(0x48uLL, 0x7081ABB9uLL);
  if (!v15)
LABEL_82:
    abort();
  v16 = (int **)v15;
  *(_OWORD *)(v15 + 8) = 0u;
  *(_OWORD *)(v15 + 56) = 0u;
  *(_OWORD *)(v15 + 40) = 0u;
  *(_OWORD *)(v15 + 24) = 0u;
  *(_QWORD *)v15 = a1;
  *((_QWORD *)v15 + 2) = macro_scan;
  v17 = a1[2];
  *((_DWORD *)v16 + 12) = *(_DWORD *)(v17 + 48);
  v16[5] = *(int **)(v17 + 40);
  v16[7] = (int *)(v14 + 32);
  if (*(_QWORD *)(v14 + 40))
  {
    v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 16))(v17, a3);
    if (v18 != 40)
    {
      UngetToken((uint64_t)a1, v18, (const void *)a3);
      *(_DWORD *)(a3 + 12) = a2;
      free(v16);
      return 0;
    }
    v16[8] = (int *)mem_Alloc(*(_QWORD **)(a1[67] + 40), 8 * *v16[7]);
    if (*v16[7] >= 1)
    {
      v19 = 0;
      do
        *(_QWORD *)&v16[8][2 * v19++] = NewTokenStream((uint64_t)a1, "macro arg2", *(_QWORD **)(a1[67] + 40));
      while (v19 < *v16[7]);
    }
    v20 = 0;
    v21 = 0;
    while (2)
    {
      v22 = 0;
      while (1)
      {
        v23 = (*(uint64_t (**)(void))(a1[2] + 16))();
        if (v23 != 270)
          goto LABEL_28;
        do
        {
          if (!MacroExpand(a1, *(unsigned int *)(a3 + 12), a3))
          {
            v23 = 270;
            goto LABEL_31;
          }
          v30 = (*(uint64_t (**)(void))(a1[2] + 16))();
        }
        while (v30 == 270);
        v23 = v30;
LABEL_28:
        if (v23 <= 0)
        {
LABEL_62:
          glpStoreErrMsg((uint64_t)a1, (char)"EOF in Macro ", v24, v25, v26, v27, v28, v29);
          StringOfAtom = GetStringOfAtom(a1 + 48, a2);
          glpStoreErrMsg((uint64_t)a1, StringOfAtom, v47, v48, v49, v50, v51, v52);
          ErrMsg = glpGetErrMsg((uint64_t)a1);
          glpCPPShInfoLogMsg((uint64_t)a1, ErrMsg);
          glpResetErrMsg((uint64_t)a1);
          free(v16);
          return 1;
        }
LABEL_31:
        v31 = *v16[7];
        v32 = v23 != 41;
        if (v23 != 41 && !v31)
          break;
        if (v22)
        {
          if (v23 == 40)
LABEL_40:
            ++v22;
        }
        else
        {
          switch(v23)
          {
            case '(':
              goto LABEL_40;
            case ')':
              if (v31 != 1 || v21 != 0)
                LODWORD(v20) = v20 + 1;
              goto LABEL_51;
            case ',':
              goto LABEL_43;
          }
          v22 = 0;
        }
        v22 -= v23 == 41;
        RecordToken(*(_QWORD **)&v16[8][2 * v20], v23, a3);
        v21 = 1;
      }
      v32 = 1;
LABEL_43:
      if (++v20 < v31)
        continue;
      break;
    }
LABEL_51:
    if ((int)v20 >= v31)
    {
      if (!v32)
      {
LABEL_63:
        if (*v16[7] >= 1)
        {
          v54 = 0;
          while (1)
          {
            v55 = *(uint64_t **)&v16[8][2 * v54];
            RewindTokenStream((uint64_t)v55);
            do
            {
              while (1)
              {
                Token = ReadToken(v55, a3);
                if (Token == 270)
                  break;
                if (Token <= 0)
                {
                  v57 = v55;
                  goto LABEL_80;
                }
              }
            }
            while (!LookUpSymbol((uint64_t)a1, a1[67], *(_DWORD *)(a3 + 12)));
            v57 = NewTokenStream((uint64_t)a1, "macro arg1", *(_QWORD **)(a1[67] + 40));
            v58 = (char *)malloc_type_malloc(0x38uLL, 0x7081ABB9uLL);
            if (!v58)
              goto LABEL_82;
            *(_OWORD *)(v58 + 8) = 0u;
            *(_OWORD *)(v58 + 24) = 0u;
            *(_OWORD *)(v58 + 40) = 0u;
            *(_QWORD *)v58 = a1;
            *((_QWORD *)v58 + 3) = eof_scan;
            *((_QWORD *)v58 + 4) = noop;
            *((_QWORD *)v58 + 1) = a1[2];
            *((_QWORD *)v58 + 2) = eof_scan;
            a1[2] = v58;
            ReadFromTokenStream(v55, 0);
            v59 = (*(uint64_t (**)(void))(a1[2] + 16))();
            if (v59 >= 1)
            {
              for (i = v59; i > 0; i = (*(uint64_t (**)(void))(a1[2] + 16))())
              {
                if (i != 270 || !MacroExpand(a1, *(unsigned int *)(a3 + 12), a3))
                  RecordToken(v57, i, a3);
              }
            }
            v61 = a1[2];
            if (*(uint64_t (**)())(v61 + 16) == eof_scan)
            {
              a1[2] = *(_QWORD *)(v61 + 8);
              free((void *)v61);
            }
LABEL_80:
            *(_QWORD *)&v16[8][2 * v54++] = v57;
            if (v54 >= *v16[7])
              goto LABEL_81;
          }
        }
        goto LABEL_81;
      }
      v43 = 0;
      v34 = "Too many args in Macro ";
      while (v23 != 41 || v43 >= 1)
      {
        v44 = v43 - (v23 == 41);
        v45 = (*(uint64_t (**)(void))(a1[2] + 16))();
        v23 = v45;
        if (v45 == 40)
          v43 = v44 + 1;
        else
          v43 = v44;
        if (v45 < 0)
          goto LABEL_62;
      }
    }
    else
    {
      v34 = "Too few args in Macro ";
    }
    glpStoreErrMsg((uint64_t)a1, (char)v34, v24, v25, v26, v27, v28, v29);
    v35 = GetStringOfAtom(a1 + 48, a2);
    glpStoreErrMsg((uint64_t)a1, v35, v36, v37, v38, v39, v40, v41);
    v42 = glpGetErrMsg((uint64_t)a1);
    glpCPPShInfoLogMsg((uint64_t)a1, v42);
    glpResetErrMsg((uint64_t)a1);
    goto LABEL_63;
  }
LABEL_81:
  v16[1] = (int *)a1[2];
  *(_DWORD *)(v14 + 56) |= 1u;
  RewindTokenStream(*(_QWORD *)(v14 + 48));
  a1[2] = v16;
  return 1;
}

uint64_t macro_scan(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  int v5;
  _BOOL4 v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  const char *v10;
  _BOOL4 v11;
  uint64_t Token;
  uint64_t v13;
  unsigned int *v14;
  int v15;
  uint64_t v16;
  BOOL v17;
  int v18;
  _BOOL4 matched;
  BOOL v20;
  _BOOL4 v21;
  uint64_t *v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v28;
  char v29[10000];
  uint64_t v30;

  v1 = (uint64_t *)MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v4 = v1;
  v5 = 0;
  v6 = 0;
  LODWORD(v7) = 0;
  v30 = *MEMORY[0x24BDAC8D0];
  v8 = *v1;
  v29[0] = 0;
  v28 = v8 + 384;
  v9 = "## pastebuf exceeded";
  while (1)
  {
    v10 = v9;
    while (1)
    {
      v11 = v6;
      Token = ReadToken(*(uint64_t **)(v4[7] + 16), v3);
      if ((_DWORD)Token != 289)
        break;
      v6 = 0;
      if (!v11)
      {
        glpCPPErrorToInfoLog(v8, (char)"pasting invalid tokens");
        v6 = 0;
      }
    }
    v13 = Token;
    v14 = (unsigned int *)v4[7];
    v9 = v10;
    if ((_DWORD)Token == 270)
    {
      v7 = *v14;
      v15 = (v7 & ((int)v7 >> 31)) - 1;
      v16 = v7 - 1;
      while (1)
      {
        v17 = __OFSUB__((_DWORD)v7, 1);
        LODWORD(v7) = v7 - 1;
        if ((int)v7 < 0 != v17)
          break;
        v18 = *(_DWORD *)(*((_QWORD *)v14 + 1) + 4 * v16--);
        if (v18 == *(_DWORD *)(v3 + 12))
          goto LABEL_12;
      }
      LODWORD(v7) = v15;
    }
LABEL_12:
    matched = MatchNextToken(*((_QWORD *)v14 + 2), 289);
    v20 = (_DWORD)v13 != 270 || (int)v7 < 0;
    v21 = !v20;
    if ((!matched & (v5 ^ 1)) != 0)
      break;
    v6 = matched;
    if (v21)
    {
      v22 = *(uint64_t **)(v4[8] + 8 * v7);
      RewindTokenStream((uint64_t)v22);
      v23 = ReadToken(v22, v3);
      if ((v23 & 0x80000000) == 0)
      {
        while ((v23 - 266) <= 0xD)
        {
          v24 = 1 << (v23 - 10);
          if ((v24 & 0x23) == 0)
          {
            if ((v24 & 0x3010) == 0)
              break;
            GetAtomString(v28, *(_DWORD *)(v3 + 12));
          }
LABEL_26:
          if ((unint64_t)__strlcat_chk() >> 4 >= 0x271)
            glpCPPErrorToInfoLog(v8, (char)v10);
          v23 = ReadToken(v22, v3);
          if (v23 < 0)
            goto LABEL_37;
        }
        glpCPPErrorToInfoLog(v8, (char)"pasting invalid tokens");
        goto LABEL_26;
      }
      goto LABEL_37;
    }
    if ((v13 - 266) > 0xD)
      goto LABEL_34;
    v25 = 1 << (v13 - 10);
    if ((v25 & 0x23) != 0)
      goto LABEL_35;
    if ((v25 & 0x3010) != 0)
      GetAtomString(v28, *(_DWORD *)(v3 + 12));
    else
LABEL_34:
      glpCPPErrorToInfoLog(v8, (char)"pasting invalid tokens");
LABEL_35:
    if ((unint64_t)__strlcat_chk() >> 4 >= 0x271)
      glpCPPErrorToInfoLog(v8, (char)v10);
LABEL_37:
    v5 = 1;
    if (!v6)
    {
      if ((unint64_t)__strlcat_chk() >> 4 >= 0x271)
        glpCPPErrorToInfoLog(v8, (char)"## pastebuf exceeded");
      ScanFromTokenPastedString(v8, v29);
LABEL_43:
      v26 = v8 + 16;
      return (*(uint64_t (**)(void))(*(_QWORD *)v26 + 16))();
    }
  }
  if (v21)
  {
    ReadFromTokenStream(*(_QWORD **)(v4[8] + 8 * v7), 0);
    goto LABEL_43;
  }
  if ((int)v13 <= 0)
  {
    *(_DWORD *)(v4[7] + 24) &= ~1u;
    *(_QWORD *)(v8 + 16) = v4[1];
    v26 = v8 + 16;
    free(v4);
    return (*(uint64_t (**)(void))(*(_QWORD *)v26 + 16))();
  }
  return v13;
}

BOOL checkReservedName(uint64_t a1, int a2)
{
  const char *StringOfAtom;
  _BOOL8 result;

  result = 0;
  if (!glpIsExtensionEnabled(*(_QWORD *)(a1 + 32), 0x23u)
    && !*(_DWORD *)(a1 + 12)
    && (int)glpCompilerGetIOSVersion(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 784)) >= 10)
  {
    StringOfAtom = (const char *)GetStringOfAtom((_QWORD *)(a1 + 384), a2);
    if (!strncmp("GL_", StringOfAtom, 3uLL)
      || *(_DWORD *)(a1 + 508) == a2
      || *(_DWORD *)(a1 + 512) == a2
      || *(_DWORD *)(a1 + 516) == a2)
    {
      return 1;
    }
  }
  return result;
}

uint64_t eval(uint64_t a1, uint64_t a2, int a3, _BOOL4 *a4, _DWORD *a5, uint64_t a6, uint64_t a7)
{
  int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  _BOOL4 v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  _BOOL8 v26;
  uint64_t v27;
  BOOL v28;
  int v30;

  while (1)
  {
    if ((_DWORD)a2 != 270)
    {
      if ((_DWORD)a2 == 40)
      {
        v15 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
        a2 = eval(a1, v15, 0, a4, a5, a6, a7);
        if (*a5)
          return a2;
LABEL_25:
        if ((_DWORD)a2 != 41)
          goto LABEL_48;
        v30 = a3;
        goto LABEL_27;
      }
      if ((_DWORD)a2 == 271)
      {
        v30 = a3;
        *a4 = *(_DWORD *)(a6 + 16);
LABEL_27:
        a2 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
        goto LABEL_28;
      }
      v16 = 3;
      while (1)
      {
        v17 = v16;
        if (unop[2 * v16] == (uint64_t (*)(_BOOL4))(int)a2)
          break;
        --v16;
        if (!(_DWORD)v17)
          goto LABEL_48;
      }
      v30 = a3;
      v22 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
      a2 = eval(a1, v22, 12, a4, a5, a6, a7);
      *a4 = unop[2 * v17 + 1](*a4);
LABEL_28:
      if (*a5)
        return a2;
      goto LABEL_29;
    }
    v14 = *(_DWORD *)(a6 + 12);
    if (v14 == *(_DWORD *)(a1 + 460))
    {
      v18 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
      v19 = v18;
      a2 = v18;
      if ((_DWORD)v18 == 40)
        a2 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
      if ((_DWORD)a2 != 270)
        goto LABEL_48;
      v20 = LookUpSymbol(a1, *(_QWORD *)(a1 + 536), *(_DWORD *)(a6 + 12));
      if (v20)
        v21 = ((*(_DWORD *)(v20 + 56) >> 1) & 1) == 0;
      else
        v21 = 0;
      *a4 = v21;
      a2 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
      if (v19 == 40)
        goto LABEL_25;
      v30 = a3;
      goto LABEL_28;
    }
    if (!MacroExpand((_QWORD *)a1, v14, a6))
      break;
    a2 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  }
  if (!(_DWORD)a7)
  {
    a2 = 270;
LABEL_48:
    glpCPPErrorToInfoLog(a1, (char)"incorrect preprocessor directive");
    *a5 = 1;
    *a4 = 0;
    return a2;
  }
  v30 = a3;
  a2 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  *a4 = 0;
  *a5 = 0;
  LODWORD(a7) = 1;
  do
  {
LABEL_29:
    if ((_DWORD)a2 == 10 || (_DWORD)a2 == 41)
      break;
    v23 = 17;
    while (1)
    {
      v24 = v23;
      if (*((_DWORD *)&binop + 4 * v23) == (_DWORD)a2)
        break;
      --v23;
      if (!(_DWORD)v24)
        goto LABEL_48;
    }
    v25 = *((unsigned int *)&binop + 4 * v23 + 1);
    if ((int)v25 <= v30)
      break;
    v26 = *a4;
    if ((_DWORD)a7 || (_DWORD)a2 == 276 && v26)
    {
      a7 = 1;
    }
    else
    {
      v28 = (_DWORD)a2 == 257 && !v26;
      a7 = v28;
    }
    v27 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
    a2 = eval(a1, v27, v25, a4, a5, a6, a7);
    *a4 = (*((uint64_t (**)(_BOOL8, _BOOL4))&binop + 2 * v24 + 1))(v26, *a4);
  }
  while (!*a5);
  return a2;
}

uint64_t eof_scan()
{
  return 0xFFFFFFFFLL;
}

uint64_t glpInitPreprocessor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 352) &= 0xFFFFFFFC;
  *(_QWORD *)(a1 + 312) = 0;
  *(_DWORD *)(a1 + 364) = 0;
  *(_QWORD *)(a1 + 356) = 0;
  *(_QWORD *)(a1 + 544) = 0;
  *(_QWORD *)(a1 + 560) = 0;
  *(_QWORD *)(a1 + 552) = 0;
  *(_QWORD *)(a1 + 368) = a2;
  *(_QWORD *)(a1 + 376) = a3;
  InitAtomTable(a1 + 384, 0);
  InitScanner(a1);
  return 0;
}

uint64_t glpFinalizePreprocessor(uint64_t a1)
{
  FreeAtomTable(a1 + 384);
  FreeScanner(a1);
  return 0;
}

_QWORD *mem_CreatePool(size_t a1, unsigned int a2, int8x8_t a3)
{
  _QWORD *result;
  uint64_t v5;
  size_t v6;
  uint8x8_t v7;

  result = 0;
  if (a2)
    v5 = a2;
  else
    v5 = 8;
  if (a1)
    v6 = a1;
  else
    v6 = 0x10000;
  if (v6 >= 0x30)
  {
    a3.i32[0] = v5;
    v7 = (uint8x8_t)vcnt_s8(a3);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.i32[0] <= 1u && (v6 & ((_DWORD)v5 - 1)) == 0)
    {
      result = malloc_type_malloc(v6, 0x7081ABB9uLL);
      if (!result)
        abort();
      *result = 0;
      result[1] = ((unint64_t)result + v5 + 47) & -(uint64_t)v5;
      result[2] = (char *)result + v6;
      result[3] = v6;
      result[4] = v5 - 1;
      result[5] = 0;
    }
  }
  return result;
}

void mem_FreePool(_QWORD *a1)
{
  _QWORD *v1;
  uint64_t **v2;
  _QWORD *v3;

  v1 = a1;
  v2 = (uint64_t **)a1[5];
  if (!v2)
    goto LABEL_7;
  do
  {
    ((void (*)(uint64_t *))v2[1])(v2[2]);
    v2 = (uint64_t **)*v2;
  }
  while (v2);
  if (v1)
  {
LABEL_7:
    do
    {
      v3 = (_QWORD *)*v1;
      free(v1);
      v1 = v3;
    }
    while (v3);
  }
}

uint64_t mem_Alloc(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  unint64_t v6;
  unint64_t v7;
  _BOOL4 v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  _QWORD *v14;
  char *v15;

  v3 = a1[4];
  v4 = (v3 + a2) & ~v3;
  if (!v4)
    v4 = v3 + 1;
  result = a1[1];
  v6 = a1[2];
  v7 = v4 + result;
  v8 = __CFADD__(v4, result);
  a1[1] = v7;
  if (v7 > v6 || v8)
  {
    v10 = ~v3;
    v11 = v3 + v4 + 8;
    v12 = v11 & v10;
    a1[1] = result;
    v13 = a1[3];
    if ((v11 & (unint64_t)v10) >= v13)
    {
      v14 = malloc_type_malloc(v11 & v10, 0x7081ABB9uLL);
      if (v14)
        goto LABEL_14;
    }
    else
    {
      v14 = malloc_type_malloc(v13, 0x7081ABB9uLL);
      if (v14)
      {
        v15 = (char *)v14 + a1[3];
        a1[1] = (char *)v14 + v12;
        a1[2] = v15;
LABEL_14:
        *v14 = *a1;
        *a1 = v14;
        return ((unint64_t)v14 + a1[4] + 8) & ~a1[4];
      }
    }
    abort();
  }
  return result;
}

uint64_t mem_AddCleanup(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t result;

  a1[1] = (a1[1] + 7) & 0xFFFFFFFFFFFFFFF8;
  v6 = mem_Alloc(a1, 24);
  if (!v6)
    return 0xFFFFFFFFLL;
  v7 = (_QWORD *)v6;
  result = 0;
  *v7 = a1[5];
  v7[1] = a2;
  v7[2] = a3;
  a1[5] = v7;
  return result;
}

uint64_t InitScanner(uint64_t a1)
{
  uint64_t result;

  result = InitCPP(a1);
  if ((_DWORD)result)
  {
    eof_inputsrc = a1;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = &eof_inputsrc;
    *(_DWORD *)(a1 + 352) &= ~8u;
    *(_QWORD *)(a1 + 24) = 10;
    return 1;
  }
  return result;
}

uint64_t FreeScanner(uint64_t a1)
{
  uint64_t *i;

  for (i = *(uint64_t **)(a1 + 16); i != &eof_inputsrc; i = *(uint64_t **)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i[1];
    free(i);
  }
  return FreeCPP(a1);
}

uint64_t ScanFromString(uint64_t a1, uint64_t a2)
{
  char *v4;
  char *v5;
  uint64_t Filename;

  v4 = (char *)malloc_type_malloc(0x40uLL, 0x7081ABB9uLL);
  if (!v4)
    abort();
  v5 = v4;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + 8) = 0u;
  *((_QWORD *)v4 + 7) = a2;
  *(_QWORD *)v4 = a1;
  glpSetFileNumber(a1, 0);
  glpSetLineNumber(a1, 1);
  *((_DWORD *)v5 + 12) = glpGetLineNumber(a1);
  Filename = glpGetFilename(a1);
  *((_QWORD *)v5 + 3) = str_getch;
  *((_QWORD *)v5 + 4) = str_ungetch;
  *((_QWORD *)v5 + 5) = Filename;
  *((_QWORD *)v5 + 1) = *(_QWORD *)(a1 + 16);
  *((_QWORD *)v5 + 2) = byte_scan;
  *(_QWORD *)(a1 + 16) = v5;
  return 1;
}

uint64_t byte_scan(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  unint64_t v9;
  int v10;
  BOOL v11;
  unsigned int v13;
  uint64_t v14;
  uint64_t v16;
  unsigned int v17;
  int v18;
  int v19;
  BOOL v20;
  uint64_t v21;
  _BOOL4 v23;
  uint64_t v25;
  int v26;
  unint64_t v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  BOOL v36;
  unint64_t v37;
  unint64_t v38;
  int v39;
  int v41;
  int v42;
  int v43;
  int v44;
  unint64_t v45;
  const char *v46;
  unsigned int v47;
  uint64_t v48;
  int v49;
  int v51;
  char v52;
  _BOOL4 IsExtensionEnabled;
  unint64_t v55;
  unint64_t v56;
  _BOOL4 v57;
  uint64_t v59;
  unint64_t v60;
  char v61[1026];
  uint64_t v62;

  v62 = *MEMORY[0x24BDAC8D0];
  v3 = *a1;
  *(_DWORD *)(a2 + 20) = 0;
LABEL_2:
  *(_DWORD *)(a2 + 16) = 0;
  while (1)
  {
    v4 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
    v5 = v4;
    if (v4 > 0x20 || ((1 << v4) & 0x100002200) == 0)
      break;
    *(_QWORD *)(a2 + 16) = 0x100000001;
  }
  v6 = *(_DWORD *)(v3 + 352);
  if ((v6 & 4) == 0
    || (v6 &= ~4u, *(_DWORD *)(v3 + 352) = v6, (v4 & 0xFFFFFFDF) - 65 >= 0x1A)
    && (_DWORD)v4 != 95
    && (v4 - 48) > 9)
  {
    switch((int)v4)
    {
      case '!':
        if ((*(unsigned int (**)(void))(*(_QWORD *)(v3 + 16) + 24))() == 61)
          return 275;
        (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
        return 33;
      case '"':
        v61[0] = 34;
        v26 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
        v27 = 1;
        while (2)
        {
          if (v26 == 92)
            goto LABEL_79;
          if (v26 == -1 || v26 == 10)
            goto LABEL_183;
          if (v26 != 34)
          {
            if (v27 > 0x400)
              glpCPPErrorToInfoLog(v3, (char)"ERROR___STRING_TOO_LONG");
            else
              v61[v27++] = v26;
LABEL_79:
            v26 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
            continue;
          }
          break;
        }
        if (v27 > 0x400)
          goto LABEL_216;
        v52 = 34;
        goto LABEL_215;
      case '#':
        if ((*(unsigned int (**)(void))(*(_QWORD *)(v3 + 16) + 24))() == 35
          && (*(_DWORD *)v3 > 2u || glpIsExtensionEnabled(*(_QWORD *)(v3 + 32), 0x23u)))
        {
          *(_DWORD *)(v3 + 352) |= 4u;
          return 289;
        }
        else
        {
          (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
          return 35;
        }
      case '$':
        if (!glpIsExtensionEnabled(*(_QWORD *)(v3 + 32), 0x23u))
        {
          v5 = 36;
          if (!glpIsExtensionEnabled(*(_QWORD *)(v3 + 32), 0x24u))
            return v5;
        }
        v61[0] = 36;
        LOBYTE(v5) = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
        v9 = 1;
        goto LABEL_21;
      case '%':
        v28 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
        if (v28 == 61)
          return 259;
        if (v28 == 62)
          return 288;
        (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
        return 37;
      case '&':
        v29 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
        if (v29 == 38)
          return 257;
        if (v29 == 61)
          return 282;
        (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
        return 38;
      case '*':
        if ((*(unsigned int (**)(void))(*(_QWORD *)(v3 + 16) + 24))() == 61)
          return 262;
        (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
        return 42;
      case '+':
        v30 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
        if (v30 == 43)
          return 277;
        if (v30 == 61)
          return 260;
        (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
        return 43;
      case '-':
        v31 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
        if (v31 == 45)
          return 274;
        if (v31 == 61)
          return 258;
        (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
        return 45;
      case '.':
        v32 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
        if ((v32 - 48) <= 9)
        {
          (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
          v16 = v3;
          v17 = 0;
          v18 = 46;
          return lFloatConst(v16, v17, v18, a2);
        }
        if (v32 == 46)
          return 0xFFFFFFFFLL;
        (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
        return 46;
      case '/':
        v7 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
        if (v7 != 42)
        {
          if (v7 == 61)
            return 261;
          if (v7 == 47)
          {
            do
              v21 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
            while ((_DWORD)v21 != -1 && (_DWORD)v21 != 10);
            return v21;
          }
          else
          {
            (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
            return 47;
          }
        }
        do
        {
          v8 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
          while (v8 == 42)
          {
            v8 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
            if (v8 == 47)
              goto LABEL_2;
            if (v8 == -1)
              goto LABEL_18;
          }
        }
        while (v8 != -1);
LABEL_18:
        glpCPPErrorToInfoLog(v3, (char)"ERROR___EOF_IN_COMMENT");
        return 0xFFFFFFFFLL;
      case '0':
        *(_BYTE *)(a2 + 24) = 48;
        v33 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
        LODWORD(v5) = v33;
        if ((v33 & 0xFFFFFFDF) == 0x58)
        {
          *(_BYTE *)(a2 + 25) = v33;
          v34 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
          v35 = v34;
          if ((v34 - 48) >= 0xA
            && ((v34 - 65) <= 0x25
              ? (v36 = ((1 << (v34 - 65)) & 0x3F0000003FLL) == 0)
              : (v36 = 1),
                v36))
          {
            glpCPPErrorToInfoLog(v3, (char)"ERROR___ERROR_IN_HEX_CONSTANT");
            v37 = 2;
          }
          else
          {
            v37 = 2;
            do
            {
              if (v37 > 0x400)
              {
                glpCPPErrorToInfoLog(v3, (char)"ERROR___TOKEN_TOO_LONG");
              }
              else
              {
                v38 = a2 + v37++;
                *(_BYTE *)(v38 + 24) = v35;
              }
              v39 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
              v35 = v39;
            }
            while ((v39 - 48) < 0xA
                 || (v39 - 65) <= 0x25 && ((1 << (v39 - 65)) & 0x3F0000003FLL) != 0);
          }
          if (*(_DWORD *)v3 <= 2u)
          {
            IsExtensionEnabled = glpIsExtensionEnabled(*(_QWORD *)(v3 + 32), 0xEu);
            if ((v35 & 0xFFFFFFDF) != 0x55 || !IsExtensionEnabled)
              goto LABEL_222;
          }
          else if ((v35 & 0xFFFFFFDF) != 0x55)
          {
LABEL_222:
            if (v37 >= 0x401)
            {
              glpCPPErrorToInfoLog(v3, (char)"ERROR___TOKEN_TOO_LONG");
              v37 = 1024;
            }
            *(_BYTE *)(a2 + v37 + 24) = 0;
            (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
            v56 = strtoll_l((const char *)(a2 + 24), 0, 0, 0);
            *(_DWORD *)(a2 + 16) = v56;
            if (!HIDWORD(v56))
              return 271;
            v46 = "ERROR___HEX_CONST_OVERFLOW";
LABEL_156:
            glpCPPErrorToInfoLog(v3, (char)v46);
            return 271;
          }
          if (v37 > 0x400)
          {
            glpCPPErrorToInfoLog(v3, (char)"ERROR___TOKEN_TOO_LONG");
          }
          else
          {
            v55 = a2 + v37++;
            *(_BYTE *)(v55 + 24) = v35;
          }
          (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
          goto LABEL_222;
        }
        if ((v33 & 0xFFFFFFF8) == 0x30)
        {
          v47 = 1;
          do
          {
            if (v47 > 0x400)
            {
              glpCPPErrorToInfoLog(v3, (char)"ERROR___TOKEN_TOO_LONG");
            }
            else
            {
              v48 = a2 + v47++;
              *(_BYTE *)(v48 + 24) = v5;
            }
            v49 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
            LODWORD(v5) = v49;
          }
          while ((v49 & 0xFFFFFFF8) == 0x30);
          if ((v49 - 46) <= 0x37 && ((1 << (v49 - 46)) & 0x80000000800001) != 0)
          {
            v16 = v3;
            v17 = v47;
LABEL_45:
            v18 = v5;
            return lFloatConst(v16, v17, v18, a2);
          }
          if (*(_DWORD *)v3 <= 2u)
          {
            v57 = glpIsExtensionEnabled(*(_QWORD *)(v3 + 32), 0xEu);
            if ((v5 & 0xFFFFFFDF) != 0x55 || !v57)
              goto LABEL_242;
          }
          else if ((v49 & 0xFFFFFFDF) != 0x55)
          {
LABEL_242:
            if (v47 >= 0x401)
            {
              glpCPPErrorToInfoLog(v3, (char)"ERROR___TOKEN_TOO_LONG");
              v47 = 1024;
            }
            *(_BYTE *)(a2 + v47 + 24) = 0;
            (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
            v60 = strtoll_l((const char *)(a2 + 24), 0, 0, 0);
            *(_DWORD *)(a2 + 16) = v60;
            if (!HIDWORD(v60))
              return 271;
            v46 = "ERROR___OCT_CONST_OVERFLOW";
            goto LABEL_156;
          }
          if (v47 > 0x400)
          {
            glpCPPErrorToInfoLog(v3, (char)"ERROR___TOKEN_TOO_LONG");
          }
          else
          {
            v59 = a2 + v47++;
            *(_BYTE *)(v59 + 24) = v5;
          }
          (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
          goto LABEL_242;
        }
        v13 = 1;
LABEL_35:
        if ((v5 - 48) <= 9)
        {
          do
          {
            if (v13 > 0x400)
            {
              glpCPPErrorToInfoLog(v3, (char)"ERROR___TOKEN_TOO_LONG");
            }
            else
            {
              v14 = a2 + v13++;
              *(_BYTE *)(v14 + 24) = v5;
            }
            LODWORD(v5) = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
          }
          while ((v5 - 48) < 0xA);
        }
        if ((v5 - 46) <= 0x37 && ((1 << (v5 - 46)) & 0x80000000800001) != 0)
        {
          v16 = v3;
          v17 = v13;
          goto LABEL_45;
        }
        if (*(_DWORD *)v3 <= 2u)
        {
          v23 = glpIsExtensionEnabled(*(_QWORD *)(v3 + 32), 0xEu);
          if ((v5 & 0xFFFFFFDF) != 0x55 || !v23)
            goto LABEL_152;
        }
        else if ((v5 & 0xFFFFFFDF) != 0x55)
        {
LABEL_152:
          if (v13 >= 0x401)
          {
            glpCPPErrorToInfoLog(v3, (char)"ERROR___TOKEN_TOO_LONG");
            v13 = 1024;
          }
          *(_BYTE *)(a2 + 24 + v13) = 0;
          (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
          v45 = strtoll_l((const char *)(a2 + 24), 0, 0, 0);
          *(_DWORD *)(a2 + 16) = v45;
          if (!HIDWORD(v45))
            return 271;
          v46 = "ERROR___INTEGER_CONST_OVERFLOW";
          goto LABEL_156;
        }
        if (v13 > 0x400)
        {
          glpCPPErrorToInfoLog(v3, (char)"ERROR___TOKEN_TOO_LONG");
        }
        else
        {
          v25 = a2 + v13++;
          *(_BYTE *)(v25 + 24) = v5;
        }
        (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
        goto LABEL_152;
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        v13 = 0;
        goto LABEL_35;
      case ':':
        if ((*(unsigned int (**)(void))(*(_QWORD *)(v3 + 16) + 24))() == 62)
          return 286;
        (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
        return 58;
      case '<':
        if ((v6 & 2) == 0)
        {
          v41 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
          if (v41 > 59)
          {
            if (v41 == 61)
              return 272;
            if (v41 == 60)
            {
              if ((*(unsigned int (**)(void))(*(_QWORD *)(v3 + 16) + 24))() == 61)
                return 281;
              (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
              return 273;
            }
          }
          else
          {
            if (v41 == 37)
              return 287;
            if (v41 == 58)
              return 285;
          }
          (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
          return 60;
        }
        v61[0] = 60;
        v51 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
        v27 = 1;
        while (2)
        {
          if (v51 == 92)
            goto LABEL_176;
          if (v51 == -1 || v51 == 10)
          {
LABEL_183:
            glpCPPErrorToInfoLog(v3, (char)"ERROR___CPP_EOL_IN_STRING");
            return 265;
          }
          if (v51 != 62)
          {
            if (v27 > 0x400)
              glpCPPErrorToInfoLog(v3, (char)"ERROR___STRING_TOO_LONG");
            else
              v61[v27++] = v51;
LABEL_176:
            v51 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
            continue;
          }
          break;
        }
        if (v27 > 0x400)
        {
LABEL_216:
          glpCPPErrorToInfoLog(v3, (char)"ERROR___STRING_TOO_LONG");
        }
        else
        {
          v52 = 62;
LABEL_215:
          v61[v27++] = v52;
        }
        (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
        if (v27 >= 0x401)
        {
          glpCPPErrorToInfoLog(v3, (char)"ERROR___STRING_TOO_LONG");
          v27 = 1024;
        }
        v61[v27] = 0;
        *(_DWORD *)(a2 + 12) = LookUpAddString(v3 + 384, v61);
        (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
        return 278;
      case '=':
        if ((*(unsigned int (**)(void))(*(_QWORD *)(v3 + 16) + 24))() == 61)
          return 263;
        (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
        return 61;
      case '>':
        v42 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
        if (v42 == 61)
          return 268;
        if (v42 == 62)
        {
          if ((*(unsigned int (**)(void))(*(_QWORD *)(v3 + 16) + 24))() == 61)
          {
            return 280;
          }
          else
          {
            (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
            return 269;
          }
        }
        else
        {
          (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
          return 62;
        }
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
        v9 = 0;
        do
        {
LABEL_21:
          if (v9 > 0x400)
            glpCPPErrorToInfoLog(v3, (char)"ERROR___TOKEN_TOO_LONG");
          else
            v61[v9++] = v5;
          v10 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
          LOBYTE(v5) = v10;
          v11 = (v10 - 48) >= 0xA && (v10 & 0xFFFFFFDF) - 65 >= 0x1A;
        }
        while (!v11 || v10 == 95);
        goto LABEL_30;
      case '^':
        v43 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
        if (v43 == 94)
          return 264;
        if (v43 == 61)
          return 284;
        (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
        return 94;
      case '|':
        v44 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
        if (v44 == 124)
          return 276;
        if (v44 == 61)
          return 283;
        (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
        return 124;
      default:
        return v5;
    }
  }
  v9 = 0;
  do
  {
    if (v9 > 0x400)
      glpCPPErrorToInfoLog(v3, (char)"ERROR___TOKEN_TOO_LONG");
    else
      v61[v9++] = v5;
    v19 = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 24))();
    LOBYTE(v5) = v19;
    v20 = (v19 - 48) >= 0xA && (v19 & 0xFFFFFFDF) - 65 >= 0x1A;
  }
  while (!v20 || v19 == 95);
LABEL_30:
  if (v9 >= 0x401)
  {
    glpCPPErrorToInfoLog(v3, (char)"ERROR___TOKEN_TOO_LONG");
    v9 = 1024;
  }
  v61[v9] = 0;
  (*(void (**)(void))(*(_QWORD *)(v3 + 16) + 32))();
  *(_DWORD *)(a2 + 12) = LookUpAddString(v3 + 384, v61);
  return 270;
}

uint64_t str_getch(uint64_t *a1, uint64_t a2)
{
  uint64_t i;
  _BYTE *v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;

  for (i = *a1; ; a1 = *(uint64_t **)(i + 16))
  {
    v4 = (_BYTE *)a1[7];
    v5 = *v4;
    if (*v4)
      break;
    v6 = *(_DWORD *)(i + 324) + 1;
    *(_DWORD *)(i + 324) = v6;
    v7 = *(_DWORD *)(i + 336);
    *(_QWORD *)(i + 16) = a1[1];
    if (v6 >= v7)
    {
      *(_DWORD *)(i + 324) = 0;
      free(a1);
      return 0xFFFFFFFFLL;
    }
    free(a1);
    glpSetFileNumber(i, *(_DWORD *)(i + 324));
    glpSetLineNumber(i, 1);
    ScanFromString(i, *(_QWORD *)(*(_QWORD *)(i + 344) + 8 * *(int *)(i + 324)));
  }
  a1[7] = (uint64_t)(v4 + 1);
  if ((_DWORD)v5 == 92)
  {
    v8 = (*(uint64_t (**)(void))(*(_QWORD *)(i + 16) + 24))();
    v9 = *(_QWORD *)(i + 16);
    if ((_DWORD)v8 == 10)
      return (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 24))(v9, a2);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 32))(v9, v8, a2);
    return 92;
  }
  else if ((_DWORD)v5 == 10)
  {
    ++*((_DWORD *)a1 + 12);
    glpIncLineNumber(i);
  }
  return v5;
}

uint64_t *str_ungetch(uint64_t *result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;

  v2 = result[7];
  v4 = *(unsigned __int8 *)(v2 - 1);
  v3 = v2 - 1;
  if (v4 == a2)
  {
    result[7] = v3;
  }
  else
  {
    *(_BYTE *)result[7] = 0;
    --*(_DWORD *)(*result + 324);
  }
  if (a2 == 10)
  {
    --*((_DWORD *)result + 12);
    return (uint64_t *)glpDecLineNumber(*result);
  }
  return result;
}

uint64_t ScanFromIncludeString(uint64_t a1, uint64_t a2, char *a3)
{
  char *v6;
  char *v7;
  uint64_t Filename;

  v6 = (char *)malloc_type_malloc(0x48uLL, 0x7081ABB9uLL);
  if (!v6)
    abort();
  v7 = v6;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_OWORD *)(v6 + 24) = 0u;
  *(_OWORD *)(v6 + 8) = 0u;
  *((_QWORD *)v6 + 7) = a2;
  *((_QWORD *)v6 + 8) = a2;
  *(_QWORD *)v6 = a1;
  glpSetFilename(a1, a3);
  glpSetLineNumber(a1, 1);
  *((_DWORD *)v7 + 12) = glpGetLineNumber(a1);
  Filename = glpGetFilename(a1);
  *((_QWORD *)v7 + 3) = include_str_getch;
  *((_QWORD *)v7 + 4) = include_str_ungetch;
  *((_QWORD *)v7 + 5) = Filename;
  *((_QWORD *)v7 + 1) = *(_QWORD *)(a1 + 16);
  *((_QWORD *)v7 + 2) = byte_scan;
  *(_QWORD *)(a1 + 16) = v7;
  return 1;
}

uint64_t include_str_getch(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v4 = *a1;
  v5 = (_BYTE *)a1[7];
  v6 = *v5;
  if (!*v5)
  {
    *(_QWORD *)(v4 + 16) = a1[1];
    --*(_DWORD *)(v4 + 356);
    (*(void (**)(_QWORD, uint64_t))(v4 + 376))(*(_QWORD *)(v4 + 360), a1[8]);
    free(a1);
    glpSetLineNumber(v4, *(_DWORD *)(*(_QWORD *)(v4 + 16) + 48));
    glpSetFilename(v4, *(char **)(*(_QWORD *)(v4 + 16) + 40));
    v7 = *(_QWORD *)(v4 + 16);
    return (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 24))(v7, a2);
  }
  a1[7] = (uint64_t)(v5 + 1);
  if ((_DWORD)v6 != 92)
  {
    if ((_DWORD)v6 == 10)
    {
      ++*((_DWORD *)a1 + 12);
      glpIncLineNumber(v4);
    }
    return v6;
  }
  v8 = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 16) + 24))();
  v7 = *(_QWORD *)(v4 + 16);
  if ((_DWORD)v8 == 10)
    return (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 24))(v7, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32))(v7, v8, a2);
  return 92;
}

uint64_t include_str_ungetch(uint64_t result, int a2)
{
  --*(_QWORD *)(result + 56);
  if (a2 == 10)
  {
    --*(_DWORD *)(result + 48);
    return glpDecLineNumber(*(_QWORD *)result);
  }
  return result;
}

uint64_t ScanFromSimpleString(uint64_t a1, uint64_t a2, int a3)
{
  char *v6;
  char *v7;
  uint64_t Filename;

  v6 = (char *)malloc_type_malloc(0x50uLL, 0x7081ABB9uLL);
  if (!v6)
    abort();
  v7 = v6;
  *(_OWORD *)(v6 + 56) = 0u;
  *((_QWORD *)v6 + 8) = a2;
  *((_QWORD *)v6 + 9) = 0;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_OWORD *)(v6 + 24) = 0u;
  *(_OWORD *)(v6 + 8) = 0u;
  *((_QWORD *)v6 + 7) = a2;
  *(_QWORD *)v6 = a1;
  *((_DWORD *)v6 + 12) = glpGetLineNumber(a1);
  Filename = glpGetFilename(a1);
  *((_QWORD *)v7 + 3) = simple_str_getch;
  *((_QWORD *)v7 + 4) = simple_str_ungetch;
  *((_QWORD *)v7 + 5) = Filename;
  *((_QWORD *)v7 + 1) = *(_QWORD *)(a1 + 16);
  *((_QWORD *)v7 + 2) = byte_scan;
  *(_QWORD *)(a1 + 16) = v7;
  *((_DWORD *)v7 + 18) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = a3;
  return 1;
}

uint64_t simple_str_getch(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v4 = *(_QWORD *)a1;
  v5 = *(_BYTE **)(a1 + 56);
  v6 = *v5;
  if (!*v5)
  {
    *(_QWORD *)(v4 + 16) = *(_QWORD *)(a1 + 8);
    *(_DWORD *)(v4 + 12) = *(_DWORD *)(a1 + 72);
    free(*(void **)(a1 + 64));
    free((void *)a1);
    glpSetLineNumber(v4, *(_DWORD *)(*(_QWORD *)(v4 + 16) + 48));
    glpSetFilename(v4, *(char **)(*(_QWORD *)(v4 + 16) + 40));
    v7 = *(_QWORD *)(v4 + 16);
    return (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 24))(v7, a2);
  }
  *(_QWORD *)(a1 + 56) = v5 + 1;
  if ((_DWORD)v6 != 92)
  {
    if ((_DWORD)v6 == 10)
    {
      ++*(_DWORD *)(a1 + 48);
      glpIncLineNumber(v4);
    }
    return v6;
  }
  v8 = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 16) + 24))();
  v7 = *(_QWORD *)(v4 + 16);
  if ((_DWORD)v8 == 10)
    return (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 24))(v7, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32))(v7, v8, a2);
  return 92;
}

uint64_t simple_str_ungetch(uint64_t result, int a2)
{
  --*(_QWORD *)(result + 56);
  if (a2 == 10)
  {
    --*(_DWORD *)(result + 48);
    return glpDecLineNumber(*(_QWORD *)result);
  }
  return result;
}

uint64_t ScanFromTokenPastedString(uint64_t a1, const char *a2)
{
  _OWORD *v4;
  _OWORD *v5;
  size_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;

  v4 = malloc_type_malloc(0x50uLL, 0x7081ABB9uLL);
  if (!v4)
    goto LABEL_4;
  v5 = v4;
  v4[3] = 0u;
  v4[4] = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  *v4 = 0u;
  v6 = strlen(a2);
  v7 = (char *)malloc_type_malloc(v6 + 1, 0x7081ABB9uLL);
  if (!v7)
LABEL_4:
    abort();
  *((_QWORD *)v5 + 8) = v7;
  strcpy(v7, a2);
  *((_QWORD *)v5 + 7) = *((_QWORD *)v5 + 8);
  *((_DWORD *)v5 + 18) = 0;
  v8 = *(_QWORD *)(a1 + 16);
  *((_DWORD *)v5 + 12) = *(_DWORD *)(v8 + 48);
  v9 = *(_QWORD *)(v8 + 40);
  *((_QWORD *)v5 + 2) = token_pasted_str_scan;
  *((_QWORD *)v5 + 3) = token_pasted_str_getch;
  *((_QWORD *)v5 + 4) = token_pasted_str_ungetch;
  *((_QWORD *)v5 + 5) = v9;
  *(_QWORD *)v5 = a1;
  *((_QWORD *)v5 + 1) = v8;
  *(_QWORD *)(a1 + 16) = v5;
  return 1;
}

uint64_t token_pasted_str_scan(_DWORD *a1, uint64_t a2)
{
  uint64_t v3;

  if (a1[18])
  {
    v3 = *(_QWORD *)a1;
    *(_QWORD *)(*(_QWORD *)a1 + 16) = *((_QWORD *)a1 + 1);
    free(*((void **)a1 + 8));
    free(a1);
    glpSetLineNumber(v3, *(_DWORD *)(*(_QWORD *)(v3 + 16) + 48));
    glpSetFilename(v3, *(char **)(*(_QWORD *)(v3 + 16) + 40));
    return (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 16) + 16))();
  }
  else
  {
    a1[18] = 1;
    return byte_scan((uint64_t *)a1, a2);
  }
}

uint64_t token_pasted_str_getch(uint64_t a1, uint64_t a2)
{
  _BYTE *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;

  v2 = *(_BYTE **)(a1 + 56);
  v3 = *v2;
  if (!*v2)
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 56) = v2 + 1;
  if ((_DWORD)v3 == 92)
  {
    v6 = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 16) + 24))();
    v7 = *(_QWORD *)(v4 + 16);
    if ((_DWORD)v6 == 10)
      return (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 24))(v7, a2);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32))(v7, v6, a2);
    return 92;
  }
  else if ((_DWORD)v3 == 10)
  {
    ++*(_DWORD *)(a1 + 48);
    glpIncLineNumber(v4);
  }
  return v3;
}

uint64_t token_pasted_str_ungetch(uint64_t result, int a2)
{
  --*(_QWORD *)(result + 56);
  if (a2 == 10)
  {
    --*(_DWORD *)(result + 48);
    return glpDecLineNumber(*(_QWORD *)result);
  }
  return result;
}

#error "22A91200C: call analysis failed (funcsize=197)"

uint64_t eof_scan_0()
{
  return 0xFFFFFFFFLL;
}

uint64_t lFloatConst(uint64_t a1, unsigned int a2, int a3, uint64_t a4)
{
  unsigned int v5;
  const char *v7;
  int v8;
  int v9;
  char v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;

  v5 = a2;
  v7 = (const char *)(a4 + 24);
  if (a3 == 46)
  {
    if (a2 > 0x400)
    {
      glpCPPErrorToInfoLog(a1, (char)"ERROR___FP_CONST_TOO_LONG");
    }
    else
    {
      v7[a2] = 46;
      v5 = a2 + 1;
    }
    v8 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 24))();
    if ((v8 - 48) <= 9)
    {
      do
      {
        if (v5 > 0x400)
          glpCPPErrorToInfoLog(a1, (char)"ERROR___FP_CONST_TOO_LONG");
        else
          v7[v5++] = v8;
        v8 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 24))();
      }
      while ((v8 - 48) < 0xA);
    }
  }
  else
  {
    v8 = a3;
  }
  if ((v8 & 0xFFFFFFDF) == 0x45)
  {
    if (v5 > 0x400)
      glpCPPErrorToInfoLog(a1, (char)"ERROR___FP_CONST_TOO_LONG");
    else
      v7[v5++] = v8;
    v9 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 24))();
    if (v9 == 45)
    {
      if (v5 <= 0x400)
      {
        v10 = 45;
        goto LABEL_21;
      }
    }
    else
    {
      v8 = v9;
      if (v9 != 43)
        goto LABEL_24;
      if (v5 <= 0x400)
      {
        v10 = 43;
LABEL_21:
        v7[v5++] = v10;
LABEL_23:
        v8 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 24))();
LABEL_24:
        if ((v8 - 48) > 9)
        {
          glpCPPErrorToInfoLog(a1, (char)"ERROR___ERROR_IN_EXPONENT");
        }
        else
        {
          do
          {
            if (v5 > 0x400)
              glpCPPErrorToInfoLog(a1, (char)"ERROR___FP_CONST_TOO_LONG");
            else
              v7[v5++] = v8;
            v8 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 24))();
          }
          while ((v8 - 48) < 0xA);
        }
        goto LABEL_31;
      }
    }
    glpCPPErrorToInfoLog(a1, (char)"ERROR___FP_CONST_TOO_LONG");
    goto LABEL_23;
  }
LABEL_31:
  if ((*(_DWORD *)a1 > 7u || glpIsExtensionEnabled(*(_QWORD *)(a1 + 32), 0x12u)) && (v8 | 0x20) == 0x6C)
  {
    if (v5 > 0x400)
      glpCPPErrorToInfoLog(a1, (char)"ERROR___FP_CONST_TOO_LONG");
    else
      v7[v5++] = v8;
    v13 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 24))();
    if (v8 == 108)
      v14 = 102;
    else
      v14 = 70;
    if (v13 == v14)
    {
      if (v5 > 0x400)
        glpCPPErrorToInfoLog(a1, (char)"ERROR___FP_CONST_TOO_LONG");
      else
        v7[v5++] = v13;
      (*(void (**)(void))(*(_QWORD *)(a1 + 16) + 24))();
      v12 = 0;
      v11 = 267;
    }
    else
    {
      (*(void (**)(void))(*(_QWORD *)(a1 + 16) + 32))();
      --v5;
      v11 = 266;
      v12 = 1;
    }
  }
  else
  {
    v11 = 266;
    v12 = 1;
    if ((v8 & 0xFFFFFFDF) == 0x46 && *(_DWORD *)a1 >= 2u)
    {
      if (v5 > 0x400)
        glpCPPErrorToInfoLog(a1, (char)"ERROR___FP_CONST_TOO_LONG");
      else
        v7[v5++] = v8;
      (*(void (**)(void))(*(_QWORD *)(a1 + 16) + 24))();
    }
  }
  if (v5 >= 0x401)
  {
    glpCPPErrorToInfoLog(a1, (char)"ERROR___FP_CONST_TOO_LONG");
    v5 = 1024;
  }
  v7[v5] = 0;
  if (v12)
    *(float *)(a4 + 8) = strtof_l(v7, 0, 0);
  else
    *(double *)a4 = strtod_l(v7, 0, 0);
  (*(void (**)(void))(*(_QWORD *)(a1 + 16) + 32))();
  return v11;
}

uint64_t NewScopeInPool(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = mem_Alloc(a2, 72);
  v5 = v4;
  *(_QWORD *)(v4 + 40) = a2;
  *(_QWORD *)(v4 + 48) = 0;
  *(_DWORD *)(v4 + 56) = 0;
  *(_QWORD *)(v4 + 64) = 0;
  *(_QWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 32) = 0;
  v6 = *(_QWORD *)(a1 + 544);
  *(_QWORD *)v4 = a1;
  *(_QWORD *)(v4 + 8) = v6;
  if (v6)
    *(_QWORD *)(v6 + 16) = v4;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)(a1 + 544) = v4;
  mem_AddCleanup(a2, (uint64_t)unlinkScope, v4);
  return v5;
}

_QWORD *unlinkScope(_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;

  v1 = result[1];
  if (v1)
    *(_QWORD *)(v1 + 16) = result[2];
  v2 = result[2];
  if (v2)
    v3 = (_QWORD *)(v2 + 8);
  else
    v3 = (_QWORD *)(*result + 544);
  *v3 = v1;
  return result;
}

uint64_t AddSymbol(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int ReversedAtom;
  int v12;
  uint64_t *v13;

  v6 = a2;
  if (!a2)
    v6 = *(_QWORD *)(a1 + 552);
  v8 = mem_Alloc(*(_QWORD **)(v6 + 40), 64);
  v9 = v8;
  *(_QWORD *)(v8 + 8) = 0;
  *(_QWORD *)(v8 + 16) = 0;
  *(_QWORD *)v8 = 0;
  *(_DWORD *)(v8 + 24) = a3;
  *(_DWORD *)(v8 + 28) = a4;
  *(_OWORD *)(v8 + 32) = 0u;
  *(_OWORD *)(v8 + 48) = 0u;
  v10 = *(uint64_t **)(v6 + 48);
  if (v10)
  {
    ReversedAtom = GetReversedAtom(a1 + 384, a3);
    v12 = GetReversedAtom(a1 + 384, *((_DWORD *)v10 + 6));
    while (1)
    {
      if (v12 == ReversedAtom)
      {
        glpCPPErrorToInfoLog(a1, (char)"GetAtomString(&cpp->atable, fSymb->name)");
        return v9;
      }
      if (v12 <= ReversedAtom)
      {
        v13 = (uint64_t *)v10[1];
        if (!v13)
        {
          v10[1] = v9;
          return v9;
        }
      }
      else
      {
        v13 = (uint64_t *)*v10;
        if (!*v10)
        {
          *v10 = v9;
          return v9;
        }
      }
      v12 = GetReversedAtom(a1 + 384, *((_DWORD *)v13 + 6));
      v10 = v13;
    }
  }
  *(_QWORD *)(v6 + 48) = v8;
  return v9;
}

uint64_t LookUpLocalSymbol(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;
  int ReversedAtom;
  uint64_t v7;
  int v8;
  uint64_t *v9;

  v5 = a1 + 384;
  ReversedAtom = GetReversedAtom(a1 + 384, a3);
  if (!a2)
    a2 = *(_QWORD *)(a1 + 552);
  v7 = *(_QWORD *)(a2 + 48);
  if (v7)
  {
    do
    {
      v8 = GetReversedAtom(v5, *(_DWORD *)(v7 + 24));
      if (v8 == ReversedAtom)
        break;
      v9 = (uint64_t *)(v7 + 8);
      if (v8 > ReversedAtom)
        v9 = (uint64_t *)v7;
      v7 = *v9;
    }
    while (*v9);
  }
  return v7;
}

uint64_t LookUpSymbol(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t result;

  v4 = a2;
  if (!a2)
  {
    v4 = *(_QWORD *)(a1 + 552);
    if (!v4)
      return 0;
  }
  while (1)
  {
    result = LookUpLocalSymbol(a1, v4, a3);
    if (result)
      break;
    v4 = *(_QWORD *)(v4 + 24);
    if (!v4)
      return 0;
  }
  return result;
}

_QWORD *NewTokenStream(uint64_t a1, const char *a2, _QWORD *a3)
{
  _QWORD *v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  char *v11;
  unsigned __int8 *v12;
  uint64_t v13;
  int v14;
  int v15;

  v6 = (_QWORD *)mem_Alloc(a3, 40);
  *v6 = a1;
  v6[1] = 0;
  v7 = strlen(a2);
  v8 = mem_Alloc(a3, v7 + 1);
  v9 = v8;
  v10 = *a2;
  v11 = (char *)v8;
  if (*a2)
  {
    v12 = (unsigned __int8 *)(a2 + 1);
    v13 = MEMORY[0x24BDAC740];
    v11 = (char *)v8;
    do
    {
      if (v10 < 0)
      {
        v14 = __maskrune_l(v10, 0x500uLL, 0);
        v10 = *(v12 - 1);
        if (v14)
          goto LABEL_9;
      }
      else if ((*(_DWORD *)(v13 + 4 * v10 + 60) & 0x500) != 0)
      {
        goto LABEL_9;
      }
      if ((v10 & 0xFE) == 0x2E)
      {
        v10 = 95;
LABEL_9:
        *v11++ = v10;
      }
      v15 = *v12++;
      v10 = v15;
    }
    while (v15);
  }
  *v11 = 0;
  v6[3] = 0;
  v6[4] = 0;
  v6[2] = v9;
  lNewBlock((uint64_t)v6, a3);
  return v6;
}

uint64_t lNewBlock(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t *v4;

  result = mem_Alloc(a2, 288);
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 24) = result + 32;
  *(_DWORD *)(result + 16) = 256;
  v4 = (uint64_t *)(a1 + 24);
  if (*(_QWORD *)(a1 + 24))
    v4 = *(uint64_t **)(a1 + 32);
  *v4 = result;
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

uint64_t RecordToken(_QWORD *a1, int a2, uint64_t a3)
{
  uint64_t result;
  int v7;
  const char *AtomString;
  char v9;
  unsigned __int8 *v10;
  int v11;
  char v12;
  unsigned __int8 *v13;
  int v14;

  if (*(_DWORD *)(a3 + 20))
    lAddByte(a1, 0);
  result = lAddByte(a1, a2 & 0x7Fu | ((a2 > 256) << 7));
  if ((a2 - 266) <= 0xD)
  {
    v7 = 1 << (a2 - 10);
    if ((v7 & 0x23) != 0)
    {
      v12 = *(_BYTE *)(a3 + 24);
      if (v12)
      {
        v13 = (unsigned __int8 *)(a3 + 25);
        do
        {
          lAddByte(a1, v12);
          v14 = *v13++;
          v12 = v14;
        }
        while (v14);
      }
    }
    else
    {
      if ((v7 & 0x3010) == 0)
        return result;
      AtomString = GetAtomString(*a1 + 384, *(_DWORD *)(a3 + 12));
      v9 = *AtomString;
      if (*AtomString)
      {
        v10 = (unsigned __int8 *)(AtomString + 1);
        do
        {
          lAddByte(a1, v9);
          v11 = *v10++;
          v9 = v11;
        }
        while (v11);
      }
    }
    return lAddByte(a1, 0);
  }
  return result;
}

uint64_t lAddByte(_QWORD *a1, char a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;

  result = a1[4];
  v5 = *(_DWORD *)(result + 12);
  if (v5 >= *(_DWORD *)(result + 16))
  {
    result = lNewBlock((uint64_t)a1, *(_QWORD **)(*(_QWORD *)(*a1 + 536) + 40));
    v5 = *(_DWORD *)(result + 12);
  }
  v6 = *(_QWORD *)(result + 24);
  *(_DWORD *)(result + 12) = v5 + 1;
  *(_BYTE *)(v6 + v5) = a2;
  return result;
}

uint64_t RewindTokenStream(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 24);
  if (v1)
  {
    *(_QWORD *)(result + 32) = v1;
    *(_DWORD *)(v1 + 8) = 0;
  }
  return result;
}

uint64_t ReadToken(uint64_t *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  unsigned int v6;
  int Byte;
  int v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  int v12;
  int v13;
  unint64_t v14;
  int v15;
  BOOL v16;
  char v17;
  unint64_t v18;
  int v19;
  char v20[1026];
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  LODWORD(result) = lReadByte((uint64_t)a1);
  if (!(_DWORD)result)
  {
    *(_DWORD *)(a2 + 20) = 1;
    LODWORD(result) = lReadByte((uint64_t)a1);
    if ((result & 0x80000000) == 0)
      goto LABEL_3;
    return 0xFFFFFFFFLL;
  }
  if ((result & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
LABEL_3:
  if (result <= 0x7F)
    result = result;
  else
    result = (result + 128);
  switch((int)result)
  {
    case 266:
      Byte = lReadByte((uint64_t)a1);
      if ((Byte & 0xDF) == 0x46
        || (v8 = Byte << 24, Byte << 24 == 754974720)
        || v8 == 721420288
        || v8 == 771751936
        || (Byte & 0xDF) == 0x45
        || ((Byte << 24) - 788529153) < 0xAFFFFFF)
      {
        v9 = 0;
        while (1)
        {
          if (v9 > 0x400)
            glpCPPErrorToInfoLog(*a1, (char)"ERROR_TOKEN_TOO_LONG");
          else
            v20[v9++] = Byte;
          Byte = lReadByte((uint64_t)a1);
          if ((Byte & 0xDF) != 0x46)
          {
            v19 = Byte << 24;
            if (Byte << 24 != 754974720
              && v19 != 721420288
              && v19 != 771751936
              && (Byte & 0xDF) != 0x45
              && ((Byte << 24) - 788529153) >= 0xAFFFFFF)
            {
              break;
            }
          }
        }
        if (v9 >= 0x401)
        {
          glpCPPErrorToInfoLog(*a1, (char)"ERROR_TOKEN_TOO_LONG");
          v9 = 1024;
        }
      }
      else
      {
        v9 = 0;
      }
      v20[v9] = 0;
      __strcpy_chk();
      *(float *)(a2 + 8) = strtof_l((const char *)(a2 + 24), 0, 0);
      result = 266;
      break;
    case 267:
      v10 = 0;
      while (1)
      {
        v11 = lReadByte((uint64_t)a1);
        v12 = v11 & 0xDF;
        if (v12 != 70 && v12 != 76)
        {
          v13 = v11 << 24;
          if (v11 << 24 != 754974720
            && v13 != 721420288
            && v13 != 771751936
            && v12 != 69
            && ((v11 << 24) - 788529153) >= 0xAFFFFFF)
          {
            break;
          }
        }
        if (v10 <= 0x400)
          v20[v10++] = v11;
        else
          glpCPPErrorToInfoLog(*a1, (char)"ERROR_TOKEN_TOO_LONG");
      }
      if (v10 >= 0x401)
      {
        glpCPPErrorToInfoLog(*a1, (char)"ERROR_TOKEN_TOO_LONG");
        v10 = 1024;
      }
      v20[v10] = 0;
      __strcpy_chk();
      *(double *)a2 = strtod_l((const char *)(a2 + 24), 0, 0);
      result = 267;
      break;
    case 270:
    case 279:
      v5 = lReadByte((uint64_t)a1);
      v6 = 0;
      if (!glpIsExtensionEnabled(*(_QWORD *)(*a1 + 32), 0x23u) || v5 != 36)
        goto LABEL_71;
      v20[0] = 36;
      v6 = 1;
      while (1)
      {
        v5 = lReadByte((uint64_t)a1);
LABEL_71:
        if ((v5 & 0xFFFFFFDF) - 65 >= 0x1A && v5 != 95 && (v5 - 48) > 9)
          break;
        if (v6 > 0x400)
          glpCPPErrorToInfoLog(*a1, (char)"ERROR_TOKEN_TOO_LONG");
        else
          v20[v6++] = v5;
      }
      if (v6 >= 0x401)
      {
        glpCPPErrorToInfoLog(*a1, (char)"ERROR_TOKEN_TOO_LONG");
        v6 = 1024;
      }
      v20[v6] = 0;
      *(_DWORD *)(a2 + 12) = LookUpAddString(*a1 + 384, v20);
      result = 270;
      break;
    case 271:
      v14 = 0;
      while (1)
      {
        v15 = lReadByte((uint64_t)a1);
        v16 = ((v15 << 24) - 788529153) >= 0xAFFFFFF
           && ((v15 << 24) & 0xDFFFFFFF) - 1073741825 >= 0x6FFFFFF;
        if (v16 && (v15 & 0xDF) != 0x58 && (v15 & 0xDF) != 0x55)
          break;
        if (v14 <= 0x400)
          v20[v14++] = v15;
        else
          glpCPPErrorToInfoLog(*a1, (char)"ERROR_TOKEN_TOO_LONG");
      }
      if (v14 >= 0x401)
      {
        glpCPPErrorToInfoLog(*a1, (char)"ERROR_TOKEN_TOO_LONG");
        v14 = 1024;
      }
      v20[v14] = 0;
      __strcpy_chk();
      *(_DWORD *)(a2 + 16) = strtoul_l((const char *)(a2 + 24), 0, 0, 0);
      result = 271;
      break;
    case 278:
      v17 = lReadByte((uint64_t)a1);
      if (v17)
      {
        v18 = 0;
        do
        {
          if (v18 > 0x400)
            glpCPPErrorToInfoLog(*a1, (char)"ERROR_TOKEN_TOO_LONG");
          else
            v20[v18++] = v17;
          v17 = lReadByte((uint64_t)a1);
        }
        while (v17);
        if (v18 >= 0x401)
        {
          glpCPPErrorToInfoLog(*a1, (char)"ERROR_TOKEN_TOO_LONG");
          v18 = 1024;
        }
      }
      else
      {
        v18 = 0;
      }
      v20[v18] = 0;
      *(_DWORD *)(a2 + 12) = LookUpAddString(*a1 + 384, v20);
      result = 278;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t lReadByte(uint64_t a1)
{
  uint64_t *v1;
  int v2;
  uint64_t v3;

  v1 = *(uint64_t **)(a1 + 32);
  if (v1)
  {
    v2 = *((_DWORD *)v1 + 2);
    if (v2 < *((_DWORD *)v1 + 3))
    {
LABEL_5:
      v3 = v1[3];
      *((_DWORD *)v1 + 2) = v2 + 1;
      return *(unsigned __int8 *)(v3 + v2);
    }
    v1 = (uint64_t *)*v1;
    if (v1)
    {
      v2 = 0;
      *((_DWORD *)v1 + 2) = 0;
      *(_QWORD *)(a1 + 32) = v1;
      goto LABEL_5;
    }
    *(_QWORD *)(a1 + 32) = 0;
  }
  return 0xFFFFFFFFLL;
}

BOOL MatchNextToken(uint64_t a1, int a2)
{
  uint64_t *v2;
  int v5;
  int v6;
  uint64_t *v7;
  int v8;
  _BOOL8 result;

  v2 = *(uint64_t **)(a1 + 32);
  if (!v2)
    return 0;
  v5 = *((_DWORD *)v2 + 2);
  if (v5 >= *((_DWORD *)v2 + 3))
  {
    v2 = (uint64_t *)*v2;
    if (!v2)
      goto LABEL_15;
    v5 = 0;
    *((_DWORD *)v2 + 2) = 0;
    *(_QWORD *)(a1 + 32) = v2;
  }
  v6 = *(unsigned __int8 *)(v2[3] + v5);
  if (!v6)
  {
    lReadByte(a1);
    v7 = *(uint64_t **)(a1 + 32);
    if (v7)
    {
      v8 = *((_DWORD *)v7 + 2);
      if (v8 < *((_DWORD *)v7 + 3))
      {
LABEL_10:
        v6 = *(unsigned __int8 *)(v7[3] + v8);
        goto LABEL_11;
      }
      v7 = (uint64_t *)*v7;
      if (v7)
      {
        v8 = 0;
        *((_DWORD *)v7 + 2) = 0;
        *(_QWORD *)(a1 + 32) = v7;
        goto LABEL_10;
      }
LABEL_15:
      result = 0;
      *(_QWORD *)(a1 + 32) = 0;
      return result;
    }
    return 0;
  }
LABEL_11:
  if ((v6 & 0x80u) != 0)
    v6 += 128;
  return v6 == a2;
}

uint64_t ReadFromTokenStream(_QWORD *a1, uint64_t a2)
{
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v4 = malloc_type_malloc(0x48uLL, 0x7081ABB9uLL);
  if (!v4)
    abort();
  v4[2] = 0u;
  v4[3] = 0u;
  *((_QWORD *)v4 + 8) = 0;
  *v4 = 0u;
  v4[1] = 0u;
  v5 = *a1;
  v6 = *(_QWORD *)(*a1 + 16);
  *((_DWORD *)v4 + 12) = *(_DWORD *)(v6 + 48);
  *((_QWORD *)v4 + 5) = *(_QWORD *)(v6 + 40);
  *((_QWORD *)v4 + 1) = v6;
  *((_QWORD *)v4 + 2) = scan_token;
  *(_QWORD *)v4 = v5;
  *((_QWORD *)v4 + 7) = a1;
  *((_QWORD *)v4 + 8) = a2;
  v7 = a1[3];
  if (v7)
  {
    a1[4] = v7;
    *(_DWORD *)(v7 + 8) = 0;
  }
  *(_QWORD *)(v5 + 16) = v4;
  return 1;
}

uint64_t scan_token(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t result;
  unsigned int (*v6)(uint64_t);

  v3 = *(uint64_t **)(a1 + 56);
  v4 = *v3;
  result = ReadToken(v3, a2);
  if ((_DWORD)result == 10)
  {
    ++*(_DWORD *)(a1 + 48);
  }
  else if ((int)result <= 0)
  {
    *(_QWORD *)(v4 + 16) = *(_QWORD *)(a1 + 8);
    v6 = *(unsigned int (**)(uint64_t))(a1 + 64);
    free((void *)a1);
    if (v6 && !v6(v4))
      return 0xFFFFFFFFLL;
    else
      return (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 16) + 16))();
  }
  return result;
}

void *UngetToken(uint64_t a1, int a2, const void *a3)
{
  _DWORD *v6;
  _DWORD *v7;
  void *result;
  uint64_t v9;

  v6 = malloc_type_malloc(0x460uLL, 0x7081ABB9uLL);
  if (!v6)
    abort();
  v7 = v6;
  bzero(v6, 0x460uLL);
  v7[14] = a2;
  result = memcpy(v7 + 16, a3, 0x420uLL);
  v9 = *(_QWORD *)(a1 + 16);
  v7[12] = *(_DWORD *)(v9 + 48);
  *((_QWORD *)v7 + 5) = *(_QWORD *)(v9 + 40);
  *((_QWORD *)v7 + 1) = v9;
  *((_QWORD *)v7 + 2) = reget_token;
  *(_QWORD *)v7 = a1;
  *(_QWORD *)(a1 + 16) = v7;
  return result;
}

uint64_t reget_token(_QWORD *a1, void *__dst)
{
  uint64_t v3;

  v3 = *((unsigned int *)a1 + 14);
  memcpy(__dst, a1 + 8, 0x420uLL);
  *(_QWORD *)(*a1 + 16) = a1[1];
  free(a1);
  return v3;
}

_OWORD *glpCacheOpen()
{
  char *v0;
  _OWORD *v1;
  _OWORD *v2;
  const __CFArray *v3;
  CFIndex Count;
  const __CFURL *ValueAtIndex;
  const __CFString *v6;
  int v7;
  __CFBundle *MainBundle;
  CFStringRef Identifier;
  const __CFString *v11;
  size_t v12;
  int v13;
  unsigned int v14;
  stat v15;
  char __s[1025];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v14 = 0;
  v0 = getenv("GL_SHADER_CACHE_SIZE");
  if (!v0 || sscanf(v0, "%d", &v14) != 1 || v14 >= 0x10000001)
    v14 = 0x10000000;
  v1 = malloc_type_malloc(0x30uLL, 0x7081ABB9uLL);
  if (!v1)
    abort();
  v2 = v1;
  v1[1] = 0u;
  v1[2] = 0u;
  *v1 = 0u;
  if (v14)
  {
    *((_QWORD *)v1 + 3) = dispatch_queue_create("CompilerFSCacheSerialQueue", 0);
    v3 = (const __CFArray *)CFCopySearchPathForDirectoriesInDomains();
    Count = CFArrayGetCount(v3);
    if (Count < 1)
      goto LABEL_11;
    ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v3, Count - 1);
    if (!ValueAtIndex)
      goto LABEL_11;
    __s[0] = 0;
    v6 = CFURLCopyFileSystemPath(ValueAtIndex, kCFURLPOSIXPathStyle);
    v7 = strlen(__s);
    CFStringGetCString(v6, &__s[v7], 1025 - v7, 0x8000100u);
    CFRelease(v6);
    memset(&v15, 0, sizeof(v15));
    if (stat(__s, &v15))
    {
      syslog(3, "path for application cache was not found: %s");
LABEL_11:
      CFRelease(v3);
      return v2;
    }
    MainBundle = CFBundleGetMainBundle();
    if (MainBundle)
    {
      Identifier = CFBundleGetIdentifier(MainBundle);
      if (Identifier)
      {
        v11 = Identifier;
        v12 = strlen(__s);
        if (v12 && __s[v12] != 47)
          __strncat_chk();
        v13 = strlen(__s);
        CFStringGetCString(v11, &__s[v13], 1025 - v13, 0x8000100u);
      }
      if (stat(__s, &v15) && mkdir(__s, 0x1FFu))
      {
        syslog(3, "could not create path: %s");
        goto LABEL_11;
      }
    }
    strlen(__s);
    __strncat_chk();
    if (stat(__s, &v15) && mkdir(__s, 0x1FFu))
      goto LABEL_11;
    CFRelease(v3);
    __strlcat_chk();
    __strlcat_chk();
    *((_QWORD *)v2 + 1) = v14;
    *((_DWORD *)v2 + 4) = 2097153;
    if (!fscache_open())
    {
      if (*((_QWORD *)v2 + 5))
        *(_DWORD *)v2 = v14;
      else
        syslog(3, "fscache_open returned a NULL pointer but no error.");
    }
  }
  return v2;
}

void glpCacheDelete(void *a1)
{
  NSObject *v2;
  _QWORD block[5];

  if (*(int *)a1 >= 1)
  {
    v2 = *((_QWORD *)a1 + 3);
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 0x40000000;
    block[2] = __glpCacheDelete_block_invoke;
    block[3] = &__block_descriptor_tmp_11;
    block[4] = a1;
    dispatch_sync(v2, block);
  }
  dispatch_release(*((dispatch_object_t *)a1 + 3));
  free(a1);
}

uint64_t __glpCacheDelete_block_invoke()
{
  return fscache_close();
}

uint64_t glpCacheGenerateHash(const void *a1, CC_LONG a2, unsigned __int8 *a3)
{
  CC_SHA256_CTX v7;

  memset(&v7, 0, sizeof(v7));
  CC_SHA256_Init(&v7);
  CC_SHA256_Update(&v7, a1, a2);
  CC_SHA256_Update(&v7, "Aug  3 2024", 0xBu);
  CC_SHA256_Update(&v7, "08:24:51", 8u);
  return CC_SHA256_Final(a3, &v7);
}

uint64_t glpCacheGetElement(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v4;
  uint64_t v5;
  _QWORD block[9];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  if (*(_DWORD *)a1)
  {
    v4 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 0x40000000;
    block[2] = __glpCacheGetElement_block_invoke;
    block[3] = &unk_24F4B0F20;
    block[4] = &v8;
    block[5] = a1;
    block[6] = a2;
    block[7] = a3;
    block[8] = a4;
    dispatch_sync(v4, block);
    v5 = *((unsigned int *)v9 + 6);
  }
  else
  {
    v5 = 0;
  }
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t __glpCacheGetElement_block_invoke(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  int v7;
  void *v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  result = fscache_find_and_retain();
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 203)
  {
    ++*(_DWORD *)(*(_QWORD *)(a1 + 40) + 36);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
  else
  {
    result = fscache_element_get_data();
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (*(_DWORD *)(v3 + 24))
    {
      *(_DWORD *)(v3 + 24) = 0;
    }
    else
    {
      v9 = 0u;
      v10 = 0u;
      glpCacheGenerateHash((const void *)0x20, 0xFFFFFFE0, (unsigned __int8 *)&v9);
      if ((_QWORD)v9 == MEMORY[0]
        && *((_QWORD *)&v9 + 1) == MEMORY[8]
        && (_QWORD)v10 == MEMORY[0x10]
        && *((_QWORD *)&v10 + 1) == MEMORY[0x18])
      {
        v8 = malloc_type_malloc(0xFFFFFFFFFFFFFFE0, 0x7081ABB9uLL);
        if (!v8)
          abort();
        **(_QWORD **)(a1 + 56) = v8;
        **(_QWORD **)(a1 + 64) = -32;
        result = (uint64_t)memcpy(**(void ***)(a1 + 56), (const void *)0x20, 0xFFFFFFFFFFFFFFE0);
        ++*(_DWORD *)(*(_QWORD *)(a1 + 40) + 32);
        v7 = 1;
      }
      else
      {
        result = fscache_remove_and_release();
        v7 = 0;
      }
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v7;
    }
  }
  return result;
}

void glpCacheAddElement(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v4;
  _QWORD v5[8];

  if (*(_DWORD *)a1)
  {
    v4 = *(NSObject **)(a1 + 24);
    v5[0] = MEMORY[0x24BDAC760];
    v5[1] = 0x40000000;
    v5[2] = __glpCacheAddElement_block_invoke;
    v5[3] = &__block_descriptor_tmp_24;
    v5[4] = a3;
    v5[5] = a4;
    v5[6] = a1;
    v5[7] = a2;
    dispatch_sync(v4, v5);
  }
}

void __glpCacheAddElement_block_invoke(uint64_t a1)
{
  _OWORD *v2;
  void *v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5 = 0u;
  v6 = 0u;
  glpCacheGenerateHash(*(const void **)(a1 + 32), *(_QWORD *)(a1 + 40), (unsigned __int8 *)&v5);
  v2 = malloc_type_malloc(*(_QWORD *)(a1 + 40) + 32, 0x7081ABB9uLL);
  if (!v2)
    abort();
  v3 = v2;
  v4 = v6;
  *v2 = v5;
  v2[1] = v4;
  memcpy(v2 + 2, *(const void **)(a1 + 32), *(_QWORD *)(a1 + 40));
  fscache_insert_and_retain();
  free(v3);
}

uint64_t glpBaseSizeOfNodeKind(unsigned int a1)
{
  if (a1 >= 0x56)
    abort();
  return qword_22A97FF40[a1];
}

uint64_t glpDeepCopyASTNode(uint64_t *a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t *, _DWORD *), uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t, const char *);
  uint64_t v10;
  _DWORD *v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;

  if (!a2)
    return 0;
  v7 = *(unsigned int *)(a2 + 4);
  v8 = *a1;
  v9 = (uint64_t (*)(uint64_t, uint64_t, const char *))a1[1];
  v10 = glpBaseSizeOfNodeKind(*(_DWORD *)(a2 + 16));
  v11 = (_DWORD *)v9(v8, v10 + 8 * v7, "AST Node (copy)");
  v12 = glpBaseSizeOfNodeKind(*(_DWORD *)(a2 + 16));
  memcpy(v11, (const void *)a2, v12);
  *v11 = v7;
  v11[1] = v7;
  *((_QWORD *)v11 + 1) = (char *)v11 + glpBaseSizeOfNodeKind(*(_DWORD *)(a2 + 16));
  if ((_DWORD)v7)
  {
    v13 = 0;
    v14 = 8 * v7;
    do
    {
      *(_QWORD *)(*((_QWORD *)v11 + 1) + v13) = glpDeepCopyASTNode(a1, *(_QWORD *)(*(_QWORD *)(a2 + 8) + v13), a3, a4);
      v13 += 8;
    }
    while (v14 != v13);
  }
  if (a3)
    return a3(a4, a1, v11);
  return (uint64_t)v11;
}

uint64_t glpASTNodeGetChildCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

uint64_t glpASTNodeSetChild(uint64_t result, unsigned int a2, uint64_t a3)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * a2) = a3;
  return result;
}

uint64_t glpASTNodeGetChild(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
}

uint64_t glpTopLevelNodeGetGlobalTypeQualifier(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t *i;
  uint64_t result;

  v2 = *(unsigned int *)(a1 + 64);
  if (!(_DWORD)v2)
    return 0;
  for (i = *(uint64_t **)(a1 + 8); ; ++i)
  {
    result = *i;
    if ((unint64_t)(*i + 1) >= 2
      && *(_DWORD *)(result + 16) == 63
      && *(_QWORD *)(result + 32)
      && (*(_QWORD *)(result + 24) & 0xFFFFFFFFFFFFFF7FLL) == a2)
    {
      break;
    }
    if (!--v2)
      return 0;
  }
  return result;
}

uint64_t glpTopLevelNodeGetDefCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t glpTopLevelNodeGetDef(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
}

uint64_t glpASTNodeGetSaType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t glpASTNodeGetSaFlags(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t glpASTNodeGetKind(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t glpASTNodeSetSaFlags(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 24) = a2;
  return result;
}

uint64_t glpASTNodeSetSaType(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = a2;
  return result;
}

__n128 glpASTNodeGetLocation@<Q0>(uint64_t a1@<X0>, __n128 *a2@<X8>)
{
  __n128 result;

  result = *(__n128 *)(a1 + 40);
  *a2 = result;
  a2[1].n128_u64[0] = *(_QWORD *)(a1 + 56);
  return result;
}

__n128 glpASTNodeSetLocation(uint64_t a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *(_QWORD *)(a1 + 56) = a2[1].n128_u64[0];
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t glpUnaryOperatorNodeGetExpr(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpUnaryOperatorNodeSetExpr(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpIsBinaryOperatorNode(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 16) - 19;
  if (v1 > 0x15)
    return 0;
  else
    return dword_22A9801F4[v1];
}

uint64_t glpBinaryOperatorNodeGetLhs(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpBinaryOperatorNodeSetLhs(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpBinaryOperatorNodeGetRhs(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
}

uint64_t glpBinaryOperatorNodeSetRhs(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8) = a2;
  return result;
}

uint64_t glpCallNodeGetArgCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t glpCallNodeGetArg(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
}

uint64_t glpCallNodeSetArg(uint64_t result, unsigned int a2, uint64_t a3)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * a2) = a3;
  return result;
}

void *glpCallNodeAddArg(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return glpCallNodeInsertArg(a1, a2, a3, *(_DWORD *)(a2 + 64));
}

void *glpCallNodeInsertArg(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v7;
  int v8;
  int v10;
  int v11;
  unsigned int v12;
  char *v13;
  void *result;

  v7 = *(_DWORD *)(a2 + 4);
  v8 = v7 + 1;
  if ((v7 + 1) <= *(_DWORD *)a2)
  {
    v13 = *(char **)(a2 + 8);
  }
  else
  {
    if (*(int *)a2 <= 1)
      v10 = 1;
    else
      v10 = *(_DWORD *)a2;
    v11 = 2 * v10;
    if (v11 <= v8)
      v12 = v8;
    else
      v12 = v11;
    v13 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8 * v12, "Vector Storage (GLPASTNode *, growth)");
    memcpy(v13, *(const void **)(a2 + 8), 8 * *(unsigned int *)(a2 + 4));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, *(_QWORD *)(a2 + 8));
    *(_DWORD *)a2 = v12;
    *(_QWORD *)(a2 + 8) = v13;
    v7 = *(_DWORD *)(a2 + 4);
  }
  result = memmove(&v13[8 * a4 + 8], &v13[8 * a4], 8 * (v7 - a4));
  *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * a4) = a3;
  ++*(_DWORD *)(a2 + 4);
  ++*(_DWORD *)(a2 + 64);
  return result;
}

void *glpStructureNodeClearFields(uint64_t a1)
{
  uint64_t v2;
  void *result;

  v2 = *(unsigned int *)(a1 + 64);
  result = memmove(*(void **)(a1 + 8), (const void *)(*(_QWORD *)(a1 + 8) + 8 * v2), 8 * (*(_DWORD *)(a1 + 4) - v2));
  *(_DWORD *)(a1 + 4) -= v2;
  *(_DWORD *)(a1 + 64) = 0;
  return result;
}

uint64_t glpStructureNodeGetFieldCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t glpStructureNodeGetField(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
}

uint64_t glpStructureNodeSetField(uint64_t result, unsigned int a2, uint64_t a3)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * a2) = a3;
  return result;
}

void *glpStructureNodeAddField(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return glpStructureNodeInsertField(a1, a2, a3, *(_DWORD *)(a2 + 64));
}

void *glpStructureNodeInsertField(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v7;
  int v8;
  int v10;
  int v11;
  unsigned int v12;
  char *v13;
  void *result;

  v7 = *(_DWORD *)(a2 + 4);
  v8 = v7 + 1;
  if ((v7 + 1) <= *(_DWORD *)a2)
  {
    v13 = *(char **)(a2 + 8);
  }
  else
  {
    if (*(int *)a2 <= 1)
      v10 = 1;
    else
      v10 = *(_DWORD *)a2;
    v11 = 2 * v10;
    if (v11 <= v8)
      v12 = v8;
    else
      v12 = v11;
    v13 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8 * v12, "Vector Storage (GLPASTNode *, growth)");
    memcpy(v13, *(const void **)(a2 + 8), 8 * *(unsigned int *)(a2 + 4));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, *(_QWORD *)(a2 + 8));
    *(_DWORD *)a2 = v12;
    *(_QWORD *)(a2 + 8) = v13;
    v7 = *(_DWORD *)(a2 + 4);
  }
  result = memmove(&v13[8 * a4 + 8], &v13[8 * a4], 8 * (v7 - a4));
  *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * a4) = a3;
  ++*(_DWORD *)(a2 + 4);
  ++*(_DWORD *)(a2 + 64);
  return result;
}

uint64_t glpMakeTypeConversionNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  __n128 v9;
  unint64_t v10;

  v7 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 88, "AST Node (TypeConversion)");
  *(_QWORD *)(v7 + 8) = v7 + 80;
  *(_DWORD *)v7 = 1;
  v9 = *a2;
  v10 = a2[1].n128_u64[0];
  initUnaryOperatorNode(v7, 0, &v9);
  *(_QWORD *)(v7 + 64) = a3;
  *(_QWORD *)(v7 + 72) = a4;
  return v7;
}

BOOL glpIsTypeConversionNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 0;
}

uint64_t glpTypeConversionNodeGetToType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpTypeConversionNodeGetToPrecision(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t glpTypeConversionNodeSetToPrecision(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 72) = a2;
  return result;
}

__n128 glpMakeVariableIdentifierNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  unint64_t v8;
  __n128 result;

  v7 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (VariableIdentifier)");
  *(_QWORD *)(v7 + 8) = v7 + 80;
  *(_DWORD *)v7 = 0;
  v8 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 16) = 1;
  *(_QWORD *)(v7 + 24) = 0;
  *(_QWORD *)(v7 + 32) = 0;
  *(__n128 *)(v7 + 40) = result;
  *(_QWORD *)(v7 + 56) = v8;
  *(_QWORD *)(v7 + 64) = a3;
  *(_QWORD *)(v7 + 72) = a4;
  return result;
}

BOOL glpIsVariableIdentifierNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 1;
}

uint64_t glpVariableIdentifierNodeGetName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

__n128 glpMakeTypeIdentifierNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  unint64_t v8;
  __n128 result;

  v7 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (TypeIdentifier)");
  *(_QWORD *)(v7 + 8) = v7 + 80;
  *(_DWORD *)v7 = 0;
  v8 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 16) = 2;
  *(_QWORD *)(v7 + 24) = 0;
  *(_QWORD *)(v7 + 32) = 0;
  *(__n128 *)(v7 + 40) = result;
  *(_QWORD *)(v7 + 56) = v8;
  *(_QWORD *)(v7 + 64) = a3;
  *(_QWORD *)(v7 + 72) = a4;
  return result;
}

uint64_t glpTypeIdentifierNodeGetName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

__n128 glpMakeConstantNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  unint64_t v8;
  __n128 result;

  v7 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (Constant)");
  *(_QWORD *)(v7 + 8) = v7 + 80;
  *(_DWORD *)v7 = 0;
  v8 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 16) = 3;
  *(_QWORD *)(v7 + 24) = 0;
  *(_QWORD *)(v7 + 32) = 0;
  *(__n128 *)(v7 + 40) = result;
  *(_QWORD *)(v7 + 56) = v8;
  *(_QWORD *)(v7 + 64) = a3;
  *(_QWORD *)(v7 + 72) = a4;
  return result;
}

BOOL glpIsConstantNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 3;
}

uint64_t glpConstantNodeGetType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpConstantNodeGetValue(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t glpConstantNodeSetValue(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 72) = a2;
  return result;
}

__n128 glpMakeArrayAccessNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  __n128 result;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (ArrayAccess)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v4 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 16) = 4;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(__n128 *)(v3 + 40) = result;
  *(_QWORD *)(v3 + 56) = v4;
  **(_QWORD **)(v3 + 8) = 0;
  LODWORD(v4) = *(_DWORD *)(v3 + 4) + 1;
  *(_DWORD *)(v3 + 4) = v4;
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4) = 0;
  ++*(_DWORD *)(v3 + 4);
  return result;
}

BOOL glpIsArrayAccessNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 4;
}

uint64_t glpArrayAccessNodeGetArray(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpArrayAccessNodeSetArray(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpArrayAccessNodeGetElement(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
}

uint64_t glpArrayAccessNodeSetElement(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8) = a2;
  return result;
}

__n128 glpMakeFieldAccessNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  unint64_t v8;
  __n128 result;

  v7 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 88, "AST Node (FieldAccess)");
  *(_QWORD *)(v7 + 8) = v7 + 80;
  *(_DWORD *)v7 = 1;
  v8 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 16) = 5;
  *(_QWORD *)(v7 + 24) = 0;
  *(_QWORD *)(v7 + 32) = 0;
  *(__n128 *)(v7 + 40) = result;
  *(_QWORD *)(v7 + 56) = v8;
  *(_QWORD *)(v7 + 64) = a3;
  *(_QWORD *)(v7 + 72) = a4;
  **(_QWORD **)(v7 + 8) = 0;
  ++*(_DWORD *)(v7 + 4);
  return result;
}

BOOL glpIsFieldAccessNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 5;
}

uint64_t glpFieldAccessNodeGetField(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpFieldAccessNodeGetStructure(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpFieldAccessNodeSetStructure(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpMakeUndeterminedCallNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 88, "AST Node (UndeterminedCall)");
  *(_QWORD *)(v3 + 8) = v3 + 72;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initCallNode(v3, 6, &v5);
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * (*(_DWORD *)(v3 + 4))++) = 0;
  return v3;
}

BOOL glpIsUndeterminedCallNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 6;
}

uint64_t glpUndeterminedCallNodeGetCallee(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * *(unsigned int *)(a1 + 64));
}

uint64_t glpUndeterminedCallNodeSetCallee(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * *(unsigned int *)(result + 64)) = a2;
  return result;
}

uint64_t glpMakeFunctionCallNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  __n128 v9;
  unint64_t v10;

  v7 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 104, "AST Node (FunctionCall)");
  *(_QWORD *)(v7 + 8) = v7 + 96;
  *(_DWORD *)v7 = 1;
  v9 = *a2;
  v10 = a2[1].n128_u64[0];
  initCallNode(v7, 7, &v9);
  *(_QWORD *)(v7 + 72) = a3;
  *(_QWORD *)(v7 + 80) = a4;
  *(_QWORD *)(v7 + 88) = 0;
  return v7;
}

uint64_t glpFunctionCallNodeGetName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t glpFunctionCallNodeGetExtra(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

uint64_t glpFunctionCallNodeSetExtra(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 88) = a2;
  return result;
}

uint64_t glpMakeSubroutineArrayCallNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  __n128 v9;
  unint64_t v10;

  v7 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 104, "AST Node (SubroutineArrayCall)");
  *(_QWORD *)(v7 + 8) = v7 + 88;
  *(_DWORD *)v7 = 2;
  v9 = *a2;
  v10 = a2[1].n128_u64[0];
  initCallNode(v7, 8, &v9);
  *(_QWORD *)(v7 + 72) = a3;
  *(_QWORD *)(v7 + 80) = a4;
  *(_QWORD *)(*(_QWORD *)(v7 + 8) + 8 * (*(_DWORD *)(v7 + 4))++) = 0;
  return v7;
}

uint64_t glpSubroutineArrayCallNodeGetName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t glpSubroutineArrayCallNodeGetIndexExpr(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * *(unsigned int *)(a1 + 64));
}

uint64_t glpSubroutineArrayCallNodeSetIndexExpr(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * *(unsigned int *)(result + 64)) = a2;
  return result;
}

uint64_t glpMakeMethodCallNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  __n128 v9;
  unint64_t v10;

  v7 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 104, "AST Node (MethodCall)");
  *(_QWORD *)(v7 + 8) = v7 + 88;
  *(_DWORD *)v7 = 2;
  v9 = *a2;
  v10 = a2[1].n128_u64[0];
  initCallNode(v7, 9, &v9);
  *(_QWORD *)(v7 + 72) = a3;
  *(_QWORD *)(v7 + 80) = a4;
  *(_QWORD *)(*(_QWORD *)(v7 + 8) + 8 * (*(_DWORD *)(v7 + 4))++) = 0;
  return v7;
}

uint64_t glpMethodCallNodeGetName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t glpMethodCallNodeGetReceiver(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * *(unsigned int *)(a1 + 64));
}

uint64_t glpMethodCallNodeSetReceiver(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * *(unsigned int *)(result + 64)) = a2;
  return result;
}

uint64_t glpMakeConstructorCallNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 88, "AST Node (ConstructorCall)");
  *(_QWORD *)(v3 + 8) = v3 + 72;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initCallNode(v3, 10, &v5);
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * (*(_DWORD *)(v3 + 4))++) = 0;
  return v3;
}

uint64_t glpConstructorCallNodeGetType(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * *(unsigned int *)(a1 + 64));
}

uint64_t glpConstructorCallNodeSetType(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * *(unsigned int *)(result + 64)) = a2;
  return result;
}

uint64_t glpMakePostincrementNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 72, "AST Node (Postincrement)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 1;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initUnaryOperatorNode(v3, 11, &v5);
  return v3;
}

uint64_t glpMakePostdecrementNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 72, "AST Node (Postdecrement)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 1;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initUnaryOperatorNode(v3, 12, &v5);
  return v3;
}

uint64_t glpMakePreincrementNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 72, "AST Node (Preincrement)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 1;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initUnaryOperatorNode(v3, 13, &v5);
  return v3;
}

uint64_t glpMakePredecrementNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 72, "AST Node (Predecrement)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 1;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initUnaryOperatorNode(v3, 14, &v5);
  return v3;
}

uint64_t glpMakeUnaryPlusNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 72, "AST Node (UnaryPlus)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 1;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initUnaryOperatorNode(v3, 15, &v5);
  return v3;
}

uint64_t glpMakeNegateNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 72, "AST Node (Negate)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 1;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initUnaryOperatorNode(v3, 16, &v5);
  return v3;
}

uint64_t glpMakeLogicalNotNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 72, "AST Node (LogicalNot)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 1;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initUnaryOperatorNode(v3, 17, &v5);
  return v3;
}

uint64_t glpMakeBitwiseNotNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 72, "AST Node (BitwiseNot)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 1;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initUnaryOperatorNode(v3, 18, &v5);
  return v3;
}

uint64_t glpMakeMultiplyNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (Multiply)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 19, &v5);
  return v3;
}

uint64_t glpMakeDivideNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (Divide)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 20, &v5);
  return v3;
}

uint64_t glpMakeModuloNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (Modulo)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 21, &v5);
  return v3;
}

uint64_t glpMakeAddNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (Add)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 22, &v5);
  return v3;
}

uint64_t glpMakeSubtractNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (Subtract)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 23, &v5);
  return v3;
}

uint64_t glpMakeShiftLeftNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (ShiftLeft)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 24, &v5);
  return v3;
}

uint64_t glpMakeShiftRightNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (ShiftRight)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 25, &v5);
  return v3;
}

uint64_t glpMakeLessNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (Less)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 26, &v5);
  return v3;
}

uint64_t glpMakeLessEqualNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (LessEqual)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 27, &v5);
  return v3;
}

uint64_t glpMakeGreaterNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (Greater)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 28, &v5);
  return v3;
}

uint64_t glpMakeGreaterEqualNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (GreaterEqual)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 29, &v5);
  return v3;
}

uint64_t glpMakeEqualNode(uint64_t a1, __n128 *a2, char a3)
{
  uint64_t v5;
  __n128 v7;
  unint64_t v8;

  v5 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 88, "AST Node (Equal)");
  *(_QWORD *)(v5 + 8) = v5 + 72;
  *(_DWORD *)v5 = 2;
  v7 = *a2;
  v8 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v5, 30, &v7);
  *(_BYTE *)(v5 + 64) = a3;
  return v5;
}

uint64_t glpEqualNodeGetIsFromSource(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 64);
}

uint64_t glpMakeNotEqualNode(uint64_t a1, __n128 *a2, char a3)
{
  uint64_t v5;
  __n128 v7;
  unint64_t v8;

  v5 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 88, "AST Node (NotEqual)");
  *(_QWORD *)(v5 + 8) = v5 + 72;
  *(_DWORD *)v5 = 2;
  v7 = *a2;
  v8 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v5, 31, &v7);
  *(_BYTE *)(v5 + 64) = a3;
  return v5;
}

uint64_t glpNotEqualNodeGetIsFromSource(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 64);
}

uint64_t glpMakeLogicalAndNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (LogicalAnd)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 32, &v5);
  return v3;
}

uint64_t glpMakeLogicalOrNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (LogicalOr)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 33, &v5);
  return v3;
}

uint64_t glpMakeLogicalXorNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (LogicalXor)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 34, &v5);
  return v3;
}

uint64_t glpMakeBitwiseAndNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (BitwiseAnd)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 35, &v5);
  return v3;
}

uint64_t glpMakeBitwiseOrNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (BitwiseOr)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 36, &v5);
  return v3;
}

uint64_t glpMakeBitwiseXorNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (BitwiseXor)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v3, 37, &v5);
  return v3;
}

__n128 glpMakeIfExprNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  __n128 result;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 88, "AST Node (IfExpr)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 3;
  v4 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 16) = 38;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(__n128 *)(v3 + 40) = result;
  *(_QWORD *)(v3 + 56) = v4;
  **(_QWORD **)(v3 + 8) = 0;
  LODWORD(v4) = *(_DWORD *)(v3 + 4) + 1;
  *(_DWORD *)(v3 + 4) = v4;
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4) = 0;
  LODWORD(v4) = *(_DWORD *)(v3 + 4) + 1;
  *(_DWORD *)(v3 + 4) = v4;
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4) = 0;
  ++*(_DWORD *)(v3 + 4);
  return result;
}

uint64_t glpIfExprNodeGetCondition(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpIfExprNodeSetCondition(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpIfExprNodeGetIfExpr(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
}

uint64_t glpIfExprNodeSetIfExpr(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8) = a2;
  return result;
}

uint64_t glpIfExprNodeGetElseExpr(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16);
}

uint64_t glpIfExprNodeSetElseExpr(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 16) = a2;
  return result;
}

uint64_t glpMakeAssignNode(uint64_t a1, __n128 *a2, char a3)
{
  uint64_t v5;
  __n128 v7;
  unint64_t v8;

  v5 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 88, "AST Node (Assign)");
  *(_QWORD *)(v5 + 8) = v5 + 72;
  *(_DWORD *)v5 = 2;
  v7 = *a2;
  v8 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v5, 39, &v7);
  *(_BYTE *)(v5 + 64) = a3;
  return v5;
}

BOOL glpIsAssignNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 39;
}

uint64_t glpAssignNodeGetIsFromSource(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 64);
}

uint64_t glpMakeOpAssignNode(uint64_t a1, __n128 *a2, uint64_t a3)
{
  uint64_t v5;
  __n128 v7;
  unint64_t v8;

  v5 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 88, "AST Node (OpAssign)");
  *(_QWORD *)(v5 + 8) = v5 + 72;
  *(_DWORD *)v5 = 2;
  v7 = *a2;
  v8 = a2[1].n128_u64[0];
  initBinaryOperatorNode(v5, 40, &v7);
  *(_QWORD *)(v5 + 64) = a3;
  return v5;
}

BOOL glpIsOpAssignNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 40;
}

uint64_t glpOpAssignNodeGetDesugar(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpReadInputNodeGetExtra(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

__n128 glpMakeWriteOutputNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  __n128 result;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 72, "AST Node (WriteOutput)");
  *(_QWORD *)(v3 + 8) = v3 + 72;
  *(_DWORD *)v3 = 0;
  v4 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 16) = 42;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(__n128 *)(v3 + 40) = result;
  *(_QWORD *)(v3 + 56) = v4;
  *(_QWORD *)(v3 + 64) = 0;
  return result;
}

uint64_t glpWriteOutputNodeGetExtra(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpWriteOutputNodeSetExtra(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 64) = a2;
  return result;
}

__n128 glpMakeCommaExprNode(uint64_t a1, __n128 *a2, char a3)
{
  uint64_t v5;
  unint64_t v6;
  __n128 result;

  v5 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (CommaExpr)");
  *(_QWORD *)(v5 + 8) = v5 + 72;
  *(_DWORD *)v5 = 1;
  v6 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v5 + 4) = 0;
  *(_DWORD *)(v5 + 16) = 43;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(__n128 *)(v5 + 40) = result;
  *(_QWORD *)(v5 + 56) = v6;
  *(_BYTE *)(v5 + 64) = a3;
  *(_DWORD *)(v5 + 68) = 0;
  return result;
}

BOOL glpIsCommaExprNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 43;
}

uint64_t glpCommaExprNodeGetIsFromSource(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 64);
}

void *glpCommaExprNodeClearExprs(uint64_t a1)
{
  uint64_t v2;
  void *result;

  v2 = *(unsigned int *)(a1 + 68);
  result = memmove(*(void **)(a1 + 8), (const void *)(*(_QWORD *)(a1 + 8) + 8 * v2), 8 * (*(_DWORD *)(a1 + 4) - v2));
  *(_DWORD *)(a1 + 4) -= v2;
  *(_DWORD *)(a1 + 68) = 0;
  return result;
}

uint64_t glpCommaExprNodeGetExprCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 68);
}

uint64_t glpCommaExprNodeGetExpr(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
}

uint64_t glpCommaExprNodeSetExpr(uint64_t result, unsigned int a2, uint64_t a3)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * a2) = a3;
  return result;
}

void *glpCommaExprNodeAddExpr(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return glpCommaExprNodeInsertExpr(a1, a2, a3, *(_DWORD *)(a2 + 68));
}

void *glpCommaExprNodeInsertExpr(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v7;
  int v8;
  int v10;
  int v11;
  unsigned int v12;
  char *v13;
  void *result;

  v7 = *(_DWORD *)(a2 + 4);
  v8 = v7 + 1;
  if ((v7 + 1) <= *(_DWORD *)a2)
  {
    v13 = *(char **)(a2 + 8);
  }
  else
  {
    if (*(int *)a2 <= 1)
      v10 = 1;
    else
      v10 = *(_DWORD *)a2;
    v11 = 2 * v10;
    if (v11 <= v8)
      v12 = v8;
    else
      v12 = v11;
    v13 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8 * v12, "Vector Storage (GLPASTNode *, growth)");
    memcpy(v13, *(const void **)(a2 + 8), 8 * *(unsigned int *)(a2 + 4));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, *(_QWORD *)(a2 + 8));
    *(_DWORD *)a2 = v12;
    *(_QWORD *)(a2 + 8) = v13;
    v7 = *(_DWORD *)(a2 + 4);
  }
  result = memmove(&v13[8 * a4 + 8], &v13[8 * a4], 8 * (v7 - a4));
  *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * a4) = a3;
  ++*(_DWORD *)(a2 + 4);
  ++*(_DWORD *)(a2 + 68);
  return result;
}

__n128 glpMakeParameterDeclarationNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  unint64_t v8;
  __n128 result;

  v7 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 96, "AST Node (ParameterDeclaration)");
  *(_QWORD *)(v7 + 8) = v7 + 88;
  *(_DWORD *)v7 = 1;
  v8 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 16) = 44;
  *(_QWORD *)(v7 + 24) = 0;
  *(_QWORD *)(v7 + 32) = 0;
  *(__n128 *)(v7 + 40) = result;
  *(_QWORD *)(v7 + 56) = v8;
  *(_QWORD *)(v7 + 64) = a3;
  *(_QWORD *)(v7 + 72) = a4;
  *(_QWORD *)(v7 + 80) = 0;
  **(_QWORD **)(v7 + 8) = 0;
  ++*(_DWORD *)(v7 + 4);
  return result;
}

uint64_t glpParameterDeclarationNodeGetName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpParameterDeclarationNodeGetExtra(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

uint64_t glpParameterDeclarationNodeSetExtra(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 80) = a2;
  return result;
}

uint64_t glpParameterDeclarationNodeGetType(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpParameterDeclarationNodeSetType(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

__n128 glpMakeFunctionPrototypeNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  unint64_t v8;
  __n128 result;

  v7 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 120, "AST Node (FunctionPrototype)");
  *(_QWORD *)(v7 + 8) = v7 + 96;
  *(_DWORD *)v7 = 3;
  v8 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 16) = 45;
  *(_QWORD *)(v7 + 24) = 0;
  *(_QWORD *)(v7 + 32) = 0;
  *(__n128 *)(v7 + 40) = result;
  *(_QWORD *)(v7 + 56) = v8;
  *(_QWORD *)(v7 + 64) = a3;
  *(_QWORD *)(v7 + 72) = a4;
  *(_QWORD *)(v7 + 80) = 0;
  **(_QWORD **)(v7 + 8) = 0;
  LODWORD(v8) = *(_DWORD *)(v7 + 4) + 1;
  *(_DWORD *)(v7 + 4) = v8;
  *(_QWORD *)(*(_QWORD *)(v7 + 8) + 8 * v8) = 0;
  ++*(_DWORD *)(v7 + 4);
  *(_DWORD *)(v7 + 88) = 0;
  return result;
}

BOOL glpIsFunctionPrototypeNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 45;
}

uint64_t glpFunctionPrototypeNodeGetName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpFunctionPrototypeNodeGetExtra(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

uint64_t glpFunctionPrototypeNodeSetExtra(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 80) = a2;
  return result;
}

uint64_t glpFunctionPrototypeNodeGetReturnType(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpFunctionPrototypeNodeSetReturnType(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpFunctionPrototypeNodeGetReturnOutParam(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
}

uint64_t glpFunctionPrototypeNodeSetReturnOutParam(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8) = a2;
  return result;
}

void *glpFunctionPrototypeNodeClearParameters(uint64_t a1)
{
  int v2;
  void *result;

  v2 = *(_DWORD *)(a1 + 88);
  result = memmove((void *)(*(_QWORD *)(a1 + 8) + 16), (const void *)(*(_QWORD *)(a1 + 8) + 8 * (v2 + 2)), 8 * (*(_DWORD *)(a1 + 4) - (v2 + 2)));
  *(_DWORD *)(a1 + 4) -= v2;
  *(_DWORD *)(a1 + 88) = 0;
  return result;
}

uint64_t glpFunctionPrototypeNodeGetParameterCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 88);
}

uint64_t glpFunctionPrototypeNodeGetParameter(uint64_t a1, int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * (a2 + 2));
}

uint64_t glpFunctionPrototypeNodeSetParameter(uint64_t result, int a2, uint64_t a3)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * (a2 + 2)) = a3;
  return result;
}

void *glpFunctionPrototypeNodeAddParameter(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return glpFunctionPrototypeNodeInsertParameter(a1, a2, a3, *(_DWORD *)(a2 + 88));
}

void *glpFunctionPrototypeNodeInsertParameter(_QWORD *a1, uint64_t a2, uint64_t a3, int a4)
{
  int v7;
  int v8;
  int v10;
  int v11;
  unsigned int v12;
  char *v13;
  unsigned int v14;
  void *result;

  v7 = *(_DWORD *)(a2 + 4);
  v8 = v7 + 1;
  if ((v7 + 1) <= *(_DWORD *)a2)
  {
    v13 = *(char **)(a2 + 8);
  }
  else
  {
    if (*(int *)a2 <= 1)
      v10 = 1;
    else
      v10 = *(_DWORD *)a2;
    v11 = 2 * v10;
    if (v11 <= v8)
      v12 = v8;
    else
      v12 = v11;
    v13 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8 * v12, "Vector Storage (GLPASTNode *, growth)");
    memcpy(v13, *(const void **)(a2 + 8), 8 * *(unsigned int *)(a2 + 4));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, *(_QWORD *)(a2 + 8));
    *(_DWORD *)a2 = v12;
    *(_QWORD *)(a2 + 8) = v13;
    v7 = *(_DWORD *)(a2 + 4);
  }
  v14 = a4 + 2;
  result = memmove(&v13[8 * v14 + 8], &v13[8 * v14], 8 * (v7 - v14));
  *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * v14) = a3;
  ++*(_DWORD *)(a2 + 4);
  ++*(_DWORD *)(a2 + 88);
  return result;
}

__n128 glpMakeVariableDeclarationNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v9;
  unint64_t v10;
  __n128 result;

  v9 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 112, "AST Node (VariableDeclaration)");
  *(_QWORD *)(v9 + 8) = v9 + 96;
  *(_DWORD *)v9 = 2;
  v10 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v9 + 4) = 0;
  *(_DWORD *)(v9 + 16) = 46;
  *(_QWORD *)(v9 + 24) = 0;
  *(_QWORD *)(v9 + 32) = 0;
  *(__n128 *)(v9 + 40) = result;
  *(_QWORD *)(v9 + 56) = v10;
  *(_QWORD *)(v9 + 64) = a3;
  *(_QWORD *)(v9 + 72) = a4;
  *(_BYTE *)(v9 + 80) = a5;
  *(_QWORD *)(v9 + 88) = 0;
  **(_QWORD **)(v9 + 8) = 0;
  LODWORD(v10) = *(_DWORD *)(v9 + 4) + 1;
  *(_DWORD *)(v9 + 4) = v10;
  *(_QWORD *)(*(_QWORD *)(v9 + 8) + 8 * v10) = 0;
  ++*(_DWORD *)(v9 + 4);
  return result;
}

BOOL glpIsVariableDeclarationNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 46;
}

uint64_t glpVariableDeclarationNodeGetName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpVariableDeclarationNodeSetName(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 64) = a2;
  *(_QWORD *)(result + 72) = a3;
  return result;
}

uint64_t glpVariableDeclarationNodeGetIsFromSource(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 80);
}

uint64_t glpVariableDeclarationNodeGetExtra(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

uint64_t glpVariableDeclarationNodeSetExtra(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 88) = a2;
  return result;
}

uint64_t glpVariableDeclarationNodeGetType(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpVariableDeclarationNodeSetType(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpVariableDeclarationNodeGetInitializer(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
}

uint64_t glpVariableDeclarationNodeSetInitializer(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8) = a2;
  return result;
}

__n128 glpMakeVariableDeclarationGroupNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  __n128 result;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 88, "AST Node (VariableDeclarationGroup)");
  *(_QWORD *)(v3 + 8) = v3 + 72;
  *(_DWORD *)v3 = 2;
  v4 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 16) = 47;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(__n128 *)(v3 + 40) = result;
  *(_QWORD *)(v3 + 56) = v4;
  **(_QWORD **)(v3 + 8) = 0;
  ++*(_DWORD *)(v3 + 4);
  *(_DWORD *)(v3 + 64) = 0;
  return result;
}

uint64_t glpVariableDeclarationGroupNodeGetBaseType(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpVariableDeclarationGroupNodeSetBaseType(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpVariableDeclarationGroupNodeGetDeclarationCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t glpVariableDeclarationGroupNodeGetDeclaration(uint64_t a1, int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * (a2 + 1));
}

uint64_t glpVariableDeclarationGroupNodeSetDeclaration(uint64_t result, int a2, uint64_t a3)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * (a2 + 1)) = a3;
  return result;
}

void *glpVariableDeclarationGroupNodeAddDeclaration(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return glpVariableDeclarationGroupNodeInsertDeclaration(a1, a2, a3, *(_DWORD *)(a2 + 64));
}

void *glpVariableDeclarationGroupNodeInsertDeclaration(_QWORD *a1, uint64_t a2, uint64_t a3, int a4)
{
  int v7;
  int v8;
  int v10;
  int v11;
  unsigned int v12;
  char *v13;
  unsigned int v14;
  void *result;

  v7 = *(_DWORD *)(a2 + 4);
  v8 = v7 + 1;
  if ((v7 + 1) <= *(_DWORD *)a2)
  {
    v13 = *(char **)(a2 + 8);
  }
  else
  {
    if (*(int *)a2 <= 1)
      v10 = 1;
    else
      v10 = *(_DWORD *)a2;
    v11 = 2 * v10;
    if (v11 <= v8)
      v12 = v8;
    else
      v12 = v11;
    v13 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8 * v12, "Vector Storage (GLPASTNode *, growth)");
    memcpy(v13, *(const void **)(a2 + 8), 8 * *(unsigned int *)(a2 + 4));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, *(_QWORD *)(a2 + 8));
    *(_DWORD *)a2 = v12;
    *(_QWORD *)(a2 + 8) = v13;
    v7 = *(_DWORD *)(a2 + 4);
  }
  v14 = a4 + 1;
  result = memmove(&v13[8 * v14 + 8], &v13[8 * v14], 8 * (v7 - v14));
  *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * v14) = a3;
  ++*(_DWORD *)(a2 + 4);
  ++*(_DWORD *)(a2 + 64);
  return result;
}

__n128 glpMakePrecisionDeclarationNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  __n128 result;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (PrecisionDeclaration)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v4 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 16) = 48;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(__n128 *)(v3 + 40) = result;
  *(_QWORD *)(v3 + 56) = v4;
  **(_QWORD **)(v3 + 8) = 0;
  LODWORD(v4) = *(_DWORD *)(v3 + 4) + 1;
  *(_DWORD *)(v3 + 4) = v4;
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4) = 0;
  ++*(_DWORD *)(v3 + 4);
  return result;
}

uint64_t glpPrecisionDeclarationNodeGetQualifier(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpPrecisionDeclarationNodeSetQualifier(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpPrecisionDeclarationNodeGetType(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
}

uint64_t glpPrecisionDeclarationNodeSetType(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8) = a2;
  return result;
}

__n128 glpMakeQualifiedDeclarationNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  unint64_t v8;
  __n128 result;

  v7 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 88, "AST Node (QualifiedDeclaration)");
  *(_QWORD *)(v7 + 8) = v7 + 80;
  *(_DWORD *)v7 = 1;
  v8 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 16) = 49;
  *(_QWORD *)(v7 + 24) = 0;
  *(_QWORD *)(v7 + 32) = 0;
  *(__n128 *)(v7 + 40) = result;
  *(_QWORD *)(v7 + 56) = v8;
  *(_QWORD *)(v7 + 64) = a3;
  *(_QWORD *)(v7 + 72) = a4;
  **(_QWORD **)(v7 + 8) = 0;
  ++*(_DWORD *)(v7 + 4);
  return result;
}

uint64_t glpQualifiedDeclarationNodeGetName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpQualifiedDeclarationNodeGetQualifiers(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpQualifiedDeclarationNodeSetQualifiers(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

__n128 glpMakeQualifiedDeclarationGroupNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  __n128 result;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (QualifiedDeclarationGroup)");
  *(_QWORD *)(v3 + 8) = v3 + 72;
  *(_DWORD *)v3 = 1;
  v4 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 16) = 50;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(__n128 *)(v3 + 40) = result;
  *(_QWORD *)(v3 + 56) = v4;
  *(_DWORD *)(v3 + 64) = 0;
  return result;
}

uint64_t glpQualifiedDeclarationGroupNodeGetDeclarationCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t glpQualifiedDeclarationGroupNodeGetDeclaration(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
}

uint64_t glpQualifiedDeclarationGroupNodeSetDeclaration(uint64_t result, unsigned int a2, uint64_t a3)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * a2) = a3;
  return result;
}

void *glpQualifiedDeclarationGroupNodeAddDeclaration(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return glpQualifiedDeclarationGroupNodeInsertDeclaration(a1, a2, a3, *(_DWORD *)(a2 + 64));
}

void *glpQualifiedDeclarationGroupNodeInsertDeclaration(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v7;
  int v8;
  int v10;
  int v11;
  unsigned int v12;
  char *v13;
  void *result;

  v7 = *(_DWORD *)(a2 + 4);
  v8 = v7 + 1;
  if ((v7 + 1) <= *(_DWORD *)a2)
  {
    v13 = *(char **)(a2 + 8);
  }
  else
  {
    if (*(int *)a2 <= 1)
      v10 = 1;
    else
      v10 = *(_DWORD *)a2;
    v11 = 2 * v10;
    if (v11 <= v8)
      v12 = v8;
    else
      v12 = v11;
    v13 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8 * v12, "Vector Storage (GLPASTNode *, growth)");
    memcpy(v13, *(const void **)(a2 + 8), 8 * *(unsigned int *)(a2 + 4));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, *(_QWORD *)(a2 + 8));
    *(_DWORD *)a2 = v12;
    *(_QWORD *)(a2 + 8) = v13;
    v7 = *(_DWORD *)(a2 + 4);
  }
  result = memmove(&v13[8 * a4 + 8], &v13[8 * a4], 8 * (v7 - a4));
  *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * a4) = a3;
  ++*(_DWORD *)(a2 + 4);
  ++*(_DWORD *)(a2 + 64);
  return result;
}

__n128 glpMakeFunctionDefinitionNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  __n128 result;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (FunctionDefinition)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v4 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 16) = 51;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(__n128 *)(v3 + 40) = result;
  *(_QWORD *)(v3 + 56) = v4;
  **(_QWORD **)(v3 + 8) = 0;
  LODWORD(v4) = *(_DWORD *)(v3 + 4) + 1;
  *(_DWORD *)(v3 + 4) = v4;
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4) = 0;
  ++*(_DWORD *)(v3 + 4);
  return result;
}

BOOL glpIsFunctionDefinitionNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 51;
}

uint64_t glpFunctionDefinitionNodeGetPrototype(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpFunctionDefinitionNodeSetPrototype(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpFunctionDefinitionNodeGetBody(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
}

uint64_t glpFunctionDefinitionNodeSetBody(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8) = a2;
  return result;
}

__n128 glpMakeQualifiedTypeNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  __n128 result;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (QualifiedType)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v4 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 16) = 52;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(__n128 *)(v3 + 40) = result;
  *(_QWORD *)(v3 + 56) = v4;
  **(_QWORD **)(v3 + 8) = 0;
  LODWORD(v4) = *(_DWORD *)(v3 + 4) + 1;
  *(_DWORD *)(v3 + 4) = v4;
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4) = 0;
  ++*(_DWORD *)(v3 + 4);
  return result;
}

BOOL glpIsQualifiedTypeNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 52;
}

uint64_t glpQualifiedTypeNodeGetType(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpQualifiedTypeNodeSetType(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpQualifiedTypeNodeGetQualifiers(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
}

uint64_t glpQualifiedTypeNodeSetQualifiers(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8) = a2;
  return result;
}

__n128 glpMakePrimitiveTypeNode(uint64_t a1, __n128 *a2, int a3)
{
  uint64_t v5;
  unint64_t v6;
  __n128 result;

  v5 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 72, "AST Node (PrimitiveType)");
  *(_QWORD *)(v5 + 8) = v5 + 72;
  *(_DWORD *)v5 = 0;
  v6 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v5 + 4) = 0;
  *(_DWORD *)(v5 + 16) = 53;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(__n128 *)(v5 + 40) = result;
  *(_QWORD *)(v5 + 56) = v6;
  *(_DWORD *)(v5 + 64) = a3;
  return result;
}

BOOL glpIsPrimitiveTypeNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 53;
}

uint64_t glpPrimitiveTypeNodeGetType(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

__n128 glpMakeArrayTypeNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  __n128 result;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (ArrayType)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v4 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 16) = 54;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(__n128 *)(v3 + 40) = result;
  *(_QWORD *)(v3 + 56) = v4;
  **(_QWORD **)(v3 + 8) = 0;
  LODWORD(v4) = *(_DWORD *)(v3 + 4) + 1;
  *(_DWORD *)(v3 + 4) = v4;
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4) = 0;
  ++*(_DWORD *)(v3 + 4);
  return result;
}

BOOL glpIsArrayTypeNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 54;
}

uint64_t glpArrayTypeNodeGetElementType(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpArrayTypeNodeSetElementType(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpArrayTypeNodeGetDimension(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
}

uint64_t glpArrayTypeNodeSetDimension(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8) = a2;
  return result;
}

__n128 glpMakeFieldDeclarationNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  unint64_t v8;
  __n128 result;

  v7 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 88, "AST Node (FieldDeclaration)");
  *(_QWORD *)(v7 + 8) = v7 + 80;
  *(_DWORD *)v7 = 1;
  v8 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 16) = 55;
  *(_QWORD *)(v7 + 24) = 0;
  *(_QWORD *)(v7 + 32) = 0;
  *(__n128 *)(v7 + 40) = result;
  *(_QWORD *)(v7 + 56) = v8;
  *(_QWORD *)(v7 + 64) = a3;
  *(_QWORD *)(v7 + 72) = a4;
  **(_QWORD **)(v7 + 8) = 0;
  ++*(_DWORD *)(v7 + 4);
  return result;
}

uint64_t glpFieldDeclarationNodeGetName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpFieldDeclarationNodeGetType(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpFieldDeclarationNodeSetType(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpMakeStructTypeNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  __n128 v9;
  unint64_t v10;

  v7 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 96, "AST Node (StructType)");
  *(_QWORD *)(v7 + 8) = v7 + 88;
  *(_DWORD *)v7 = 1;
  v9 = *a2;
  v10 = a2[1].n128_u64[0];
  initStructureNode(v7, 56, &v9);
  *(_QWORD *)(v7 + 72) = a3;
  *(_QWORD *)(v7 + 80) = a4;
  return v7;
}

BOOL glpIsStructTypeNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 56;
}

uint64_t glpStructTypeNodeGetName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t glpMakeInterfaceBlockNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, char a8, uint64_t a9)
{
  uint64_t v16;
  unsigned int v17;
  __n128 v19;
  unint64_t v20;

  v16 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 144, "AST Node (InterfaceBlock)");
  *(_QWORD *)(v16 + 8) = v16 + 120;
  *(_DWORD *)v16 = 3;
  v19 = *a2;
  v20 = a2[1].n128_u64[0];
  initStructureNode(v16, 57, &v19);
  *(_QWORD *)(v16 + 72) = a3;
  *(_QWORD *)(v16 + 80) = a4;
  *(_QWORD *)(v16 + 88) = a5;
  *(_QWORD *)(v16 + 96) = a6;
  *(_BYTE *)(v16 + 104) = a7;
  *(_BYTE *)(v16 + 105) = a8;
  *(_QWORD *)(v16 + 112) = a9;
  *(_QWORD *)(*(_QWORD *)(v16 + 8) + 8 * *(unsigned int *)(v16 + 4)) = 0;
  v17 = *(_DWORD *)(v16 + 4) + 1;
  *(_DWORD *)(v16 + 4) = v17;
  *(_QWORD *)(*(_QWORD *)(v16 + 8) + 8 * v17) = 0;
  ++*(_DWORD *)(v16 + 4);
  return v16;
}

BOOL glpIsInterfaceBlockNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 57;
}

uint64_t glpInterfaceBlockNodeGetBlockName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t glpInterfaceBlockNodeGetInstanceName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

uint64_t glpInterfaceBlockNodeGetHasInstanceName(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 104);
}

uint64_t glpInterfaceBlockNodeGetIsArray(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 105);
}

uint64_t glpInterfaceBlockNodeGetExtra(uint64_t a1)
{
  return *(_QWORD *)(a1 + 112);
}

uint64_t glpInterfaceBlockNodeSetExtra(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 112) = a2;
  return result;
}

uint64_t glpInterfaceBlockNodeGetQualifiers(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * *(unsigned int *)(a1 + 64));
}

uint64_t glpInterfaceBlockNodeSetQualifiers(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * *(unsigned int *)(result + 64)) = a2;
  return result;
}

uint64_t glpInterfaceBlockNodeGetDimension(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * (*(_DWORD *)(a1 + 64) + 1));
}

uint64_t glpInterfaceBlockNodeSetDimension(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * (*(_DWORD *)(result + 64) + 1)) = a2;
  return result;
}

__n128 glpMakeLayoutTypeNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  __n128 result;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (LayoutType)");
  *(_QWORD *)(v3 + 8) = v3 + 72;
  *(_DWORD *)v3 = 1;
  v4 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 16) = 58;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(__n128 *)(v3 + 40) = result;
  *(_QWORD *)(v3 + 56) = v4;
  *(_DWORD *)(v3 + 64) = 0;
  return result;
}

uint64_t glpLayoutTypeNodeGetLayoutPairCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t glpLayoutTypeNodeGetLayoutPair(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
}

uint64_t glpLayoutTypeNodeSetLayoutPair(uint64_t result, unsigned int a2, uint64_t a3)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * a2) = a3;
  return result;
}

void *glpLayoutTypeNodeAddLayoutPair(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return glpLayoutTypeNodeInsertLayoutPair(a1, a2, a3, *(_DWORD *)(a2 + 64));
}

void *glpLayoutTypeNodeInsertLayoutPair(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v7;
  int v8;
  int v10;
  int v11;
  unsigned int v12;
  char *v13;
  void *result;

  v7 = *(_DWORD *)(a2 + 4);
  v8 = v7 + 1;
  if ((v7 + 1) <= *(_DWORD *)a2)
  {
    v13 = *(char **)(a2 + 8);
  }
  else
  {
    if (*(int *)a2 <= 1)
      v10 = 1;
    else
      v10 = *(_DWORD *)a2;
    v11 = 2 * v10;
    if (v11 <= v8)
      v12 = v8;
    else
      v12 = v11;
    v13 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8 * v12, "Vector Storage (GLPASTNode *, growth)");
    memcpy(v13, *(const void **)(a2 + 8), 8 * *(unsigned int *)(a2 + 4));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, *(_QWORD *)(a2 + 8));
    *(_DWORD *)a2 = v12;
    *(_QWORD *)(a2 + 8) = v13;
    v7 = *(_DWORD *)(a2 + 4);
  }
  result = memmove(&v13[8 * a4 + 8], &v13[8 * a4], 8 * (v7 - a4));
  *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * a4) = a3;
  ++*(_DWORD *)(a2 + 4);
  ++*(_DWORD *)(a2 + 64);
  return result;
}

uint64_t glpMakeKeywordQualifierNode(uint64_t a1, __n128 *a2, int a3)
{
  uint64_t v5;
  __n128 v7;
  unint64_t v8;

  v5 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 72, "AST Node (KeywordQualifier)");
  *(_QWORD *)(v5 + 8) = v5 + 72;
  *(_DWORD *)v5 = 0;
  v7 = *a2;
  v8 = a2[1].n128_u64[0];
  initQualifierNode(v5, 59, &v7);
  *(_DWORD *)(v5 + 64) = a3;
  return v5;
}

BOOL glpIsKeywordQualifierNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 59;
}

uint64_t glpKeywordQualifierNodeGetQualifier(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t glpMakeLayoutQualifierNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (LayoutQualifier)");
  *(_QWORD *)(v3 + 8) = v3 + 72;
  *(_DWORD *)v3 = 1;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initQualifierNode(v3, 60, &v5);
  *(_DWORD *)(v3 + 64) = 0;
  return v3;
}

BOOL glpIsLayoutQualifierNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 60;
}

uint64_t glpLayoutQualifierNodeGetLayoutPairCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t glpLayoutQualifierNodeGetLayoutPair(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
}

uint64_t glpLayoutQualifierNodeSetLayoutPair(uint64_t result, unsigned int a2, uint64_t a3)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * a2) = a3;
  return result;
}

void *glpLayoutQualifierNodeAddLayoutPair(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return glpLayoutQualifierNodeInsertLayoutPair(a1, a2, a3, *(_DWORD *)(a2 + 64));
}

void *glpLayoutQualifierNodeInsertLayoutPair(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v7;
  int v8;
  int v10;
  int v11;
  unsigned int v12;
  char *v13;
  void *result;

  v7 = *(_DWORD *)(a2 + 4);
  v8 = v7 + 1;
  if ((v7 + 1) <= *(_DWORD *)a2)
  {
    v13 = *(char **)(a2 + 8);
  }
  else
  {
    if (*(int *)a2 <= 1)
      v10 = 1;
    else
      v10 = *(_DWORD *)a2;
    v11 = 2 * v10;
    if (v11 <= v8)
      v12 = v8;
    else
      v12 = v11;
    v13 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8 * v12, "Vector Storage (GLPASTNode *, growth)");
    memcpy(v13, *(const void **)(a2 + 8), 8 * *(unsigned int *)(a2 + 4));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, *(_QWORD *)(a2 + 8));
    *(_DWORD *)a2 = v12;
    *(_QWORD *)(a2 + 8) = v13;
    v7 = *(_DWORD *)(a2 + 4);
  }
  result = memmove(&v13[8 * a4 + 8], &v13[8 * a4], 8 * (v7 - a4));
  *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * a4) = a3;
  ++*(_DWORD *)(a2 + 4);
  ++*(_DWORD *)(a2 + 64);
  return result;
}

uint64_t glpMakeSubroutineTypeListNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (SubroutineTypeList)");
  *(_QWORD *)(v3 + 8) = v3 + 72;
  *(_DWORD *)v3 = 1;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initQualifierNode(v3, 61, &v5);
  *(_DWORD *)(v3 + 64) = 0;
  return v3;
}

BOOL glpIsSubroutineTypeListNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 61;
}

uint64_t glpSubroutineTypeListNodeGetTypeCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t glpSubroutineTypeListNodeGetType(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
}

uint64_t glpSubroutineTypeListNodeSetType(uint64_t result, unsigned int a2, uint64_t a3)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * a2) = a3;
  return result;
}

void *glpSubroutineTypeListNodeAddType(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return glpSubroutineTypeListNodeInsertType(a1, a2, a3, *(_DWORD *)(a2 + 64));
}

void *glpSubroutineTypeListNodeInsertType(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v7;
  int v8;
  int v10;
  int v11;
  unsigned int v12;
  char *v13;
  void *result;

  v7 = *(_DWORD *)(a2 + 4);
  v8 = v7 + 1;
  if ((v7 + 1) <= *(_DWORD *)a2)
  {
    v13 = *(char **)(a2 + 8);
  }
  else
  {
    if (*(int *)a2 <= 1)
      v10 = 1;
    else
      v10 = *(_DWORD *)a2;
    v11 = 2 * v10;
    if (v11 <= v8)
      v12 = v8;
    else
      v12 = v11;
    v13 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8 * v12, "Vector Storage (GLPASTNode *, growth)");
    memcpy(v13, *(const void **)(a2 + 8), 8 * *(unsigned int *)(a2 + 4));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, *(_QWORD *)(a2 + 8));
    *(_DWORD *)a2 = v12;
    *(_QWORD *)(a2 + 8) = v13;
    v7 = *(_DWORD *)(a2 + 4);
  }
  result = memmove(&v13[8 * a4 + 8], &v13[8 * a4], 8 * (v7 - a4));
  *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * a4) = a3;
  ++*(_DWORD *)(a2 + 4);
  ++*(_DWORD *)(a2 + 64);
  return result;
}

__n128 glpMakeQualifierListNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  __n128 result;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (QualifierList)");
  *(_QWORD *)(v3 + 8) = v3 + 72;
  *(_DWORD *)v3 = 1;
  v4 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 16) = 62;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(__n128 *)(v3 + 40) = result;
  *(_QWORD *)(v3 + 56) = v4;
  *(_DWORD *)(v3 + 64) = 0;
  return result;
}

BOOL glpIsQualifierListNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 62;
}

uint64_t glpQualifierListNodeGetQualifierCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t glpQualifierListNodeGetQualifier(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
}

uint64_t glpQualifierListNodeSetQualifier(uint64_t result, unsigned int a2, uint64_t a3)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * a2) = a3;
  return result;
}

void *glpQualifierListNodeAddQualifier(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return glpQualifierListNodeInsertQualifier(a1, a2, a3, *(_DWORD *)(a2 + 64));
}

void *glpQualifierListNodeInsertQualifier(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v7;
  int v8;
  int v10;
  int v11;
  unsigned int v12;
  char *v13;
  void *result;

  v7 = *(_DWORD *)(a2 + 4);
  v8 = v7 + 1;
  if ((v7 + 1) <= *(_DWORD *)a2)
  {
    v13 = *(char **)(a2 + 8);
  }
  else
  {
    if (*(int *)a2 <= 1)
      v10 = 1;
    else
      v10 = *(_DWORD *)a2;
    v11 = 2 * v10;
    if (v11 <= v8)
      v12 = v8;
    else
      v12 = v11;
    v13 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8 * v12, "Vector Storage (GLPASTNode *, growth)");
    memcpy(v13, *(const void **)(a2 + 8), 8 * *(unsigned int *)(a2 + 4));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, *(_QWORD *)(a2 + 8));
    *(_DWORD *)a2 = v12;
    *(_QWORD *)(a2 + 8) = v13;
    v7 = *(_DWORD *)(a2 + 4);
  }
  result = memmove(&v13[8 * a4 + 8], &v13[8 * a4], 8 * (v7 - a4));
  *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * a4) = a3;
  ++*(_DWORD *)(a2 + 4);
  ++*(_DWORD *)(a2 + 64);
  return result;
}

__n128 glpMakeGlobalTypeQualifierNode(uint64_t a1, __n128 *a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;
  __n128 result;

  v5 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (GlobalTypeQualifier)");
  *(_QWORD *)(v5 + 8) = v5 + 72;
  *(_DWORD *)v5 = 1;
  v6 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v5 + 4) = 0;
  *(_DWORD *)(v5 + 16) = 63;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(__n128 *)(v5 + 40) = result;
  *(_QWORD *)(v5 + 56) = v6;
  *(_QWORD *)(v5 + 64) = a3;
  **(_QWORD **)(v5 + 8) = 0;
  ++*(_DWORD *)(v5 + 4);
  return result;
}

uint64_t glpGlobalTypeQualifierNodeGetLayout(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpGlobalTypeQualifierNodeSetLayout(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t glpGlobalTypeQualifierNodeGetQualifierList(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpGlobalTypeQualifierNodeSetQualifierList(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

__n128 glpMakeLayoutPairNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  unint64_t v16;
  __n128 result;

  v15 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 112, "AST Node (LayoutPair)");
  *(_QWORD *)(v15 + 8) = v15 + 104;
  *(_DWORD *)v15 = 1;
  v16 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v15 + 4) = 0;
  *(_DWORD *)(v15 + 16) = 64;
  *(_QWORD *)(v15 + 24) = 0;
  *(_QWORD *)(v15 + 32) = 0;
  *(__n128 *)(v15 + 40) = result;
  *(_QWORD *)(v15 + 56) = v16;
  *(_QWORD *)(v15 + 64) = a3;
  *(_QWORD *)(v15 + 72) = a4;
  *(_DWORD *)(v15 + 80) = a5;
  *(_DWORD *)(v15 + 84) = a6;
  *(_QWORD *)(v15 + 88) = a7;
  *(_QWORD *)(v15 + 96) = a8;
  **(_QWORD **)(v15 + 8) = 0;
  ++*(_DWORD *)(v15 + 4);
  return result;
}

uint64_t glpLayoutPairNodeGetIdentifier(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpLayoutPairNodeGetValueKind(uint64_t a1)
{
  return *(unsigned int *)(a1 + 80);
}

uint64_t glpLayoutPairNodeGetValue(uint64_t a1)
{
  return *(unsigned int *)(a1 + 84);
}

uint64_t glpLayoutPairNodeGetString(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

uint64_t glpLayoutPairNodeGetType(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpLayoutPairNodeSetType(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpMakeExpressionStatementNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 72, "AST Node (ExpressionStatement)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 1;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initStatementNode(v3, 65, &v5);
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * (*(_DWORD *)(v3 + 4))++) = 0;
  return v3;
}

uint64_t glpExpressionStatementNodeGetExpr(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpExpressionStatementNodeSetExpr(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpMakeBlockNode(uint64_t a1, __n128 *a2, char a3)
{
  uint64_t v5;
  __n128 v7;
  unint64_t v8;

  v5 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (Block)");
  *(_QWORD *)(v5 + 8) = v5 + 72;
  *(_DWORD *)v5 = 1;
  v7 = *a2;
  v8 = a2[1].n128_u64[0];
  initStatementNode(v5, 66, &v7);
  *(_BYTE *)(v5 + 64) = a3;
  *(_DWORD *)(v5 + 68) = 0;
  return v5;
}

uint64_t glpBlockNodeGetNeedsNewScope(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 64);
}

uint64_t glpBlockNodeSetNeedsNewScope(uint64_t result, char a2)
{
  *(_BYTE *)(result + 64) = a2;
  return result;
}

uint64_t glpBlockNodeGetStatementCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 68);
}

uint64_t glpBlockNodeGetStatement(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
}

uint64_t glpBlockNodeSetStatement(uint64_t result, unsigned int a2, uint64_t a3)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * a2) = a3;
  return result;
}

void *glpBlockNodeAddStatement(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return glpBlockNodeInsertStatement(a1, a2, a3, *(_DWORD *)(a2 + 68));
}

void *glpBlockNodeInsertStatement(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v7;
  int v8;
  int v10;
  int v11;
  unsigned int v12;
  char *v13;
  void *result;

  v7 = *(_DWORD *)(a2 + 4);
  v8 = v7 + 1;
  if ((v7 + 1) <= *(_DWORD *)a2)
  {
    v13 = *(char **)(a2 + 8);
  }
  else
  {
    if (*(int *)a2 <= 1)
      v10 = 1;
    else
      v10 = *(_DWORD *)a2;
    v11 = 2 * v10;
    if (v11 <= v8)
      v12 = v8;
    else
      v12 = v11;
    v13 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8 * v12, "Vector Storage (GLPASTNode *, growth)");
    memcpy(v13, *(const void **)(a2 + 8), 8 * *(unsigned int *)(a2 + 4));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, *(_QWORD *)(a2 + 8));
    *(_DWORD *)a2 = v12;
    *(_QWORD *)(a2 + 8) = v13;
    v7 = *(_DWORD *)(a2 + 4);
  }
  result = memmove(&v13[8 * a4 + 8], &v13[8 * a4], 8 * (v7 - a4));
  *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * a4) = a3;
  ++*(_DWORD *)(a2 + 4);
  ++*(_DWORD *)(a2 + 68);
  return result;
}

uint64_t glpMakeIfStatementNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  __n128 v7;
  unint64_t v8;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 88, "AST Node (IfStatement)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 3;
  v7 = *a2;
  v8 = a2[1].n128_u64[0];
  initStatementNode(v3, 67, &v7);
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * *(unsigned int *)(v3 + 4)) = 0;
  v4 = *(_DWORD *)(v3 + 4) + 1;
  *(_DWORD *)(v3 + 4) = v4;
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4) = 0;
  v5 = *(_DWORD *)(v3 + 4) + 1;
  *(_DWORD *)(v3 + 4) = v5;
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v5) = 0;
  ++*(_DWORD *)(v3 + 4);
  return v3;
}

uint64_t glpIfStatementNodeGetCond(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpIfStatementNodeSetCond(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpIfStatementNodeGetIfStatement(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
}

uint64_t glpIfStatementNodeSetIfStatement(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8) = a2;
  return result;
}

uint64_t glpIfStatementNodeGetElseStatement(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16);
}

uint64_t glpIfStatementNodeSetElseStatement(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 16) = a2;
  return result;
}

uint64_t glpMakeLoopStatementNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  unsigned int v4;
  __n128 v6;
  unint64_t v7;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (LoopStatement)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v6 = *a2;
  v7 = a2[1].n128_u64[0];
  initStatementNode(v3, 68, &v6);
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * *(unsigned int *)(v3 + 4)) = 0;
  v4 = *(_DWORD *)(v3 + 4) + 1;
  *(_DWORD *)(v3 + 4) = v4;
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4) = 0;
  ++*(_DWORD *)(v3 + 4);
  return v3;
}

uint64_t glpLoopStatementNodeGetBody0(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpLoopStatementNodeSetBody0(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpLoopStatementNodeGetBody1(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
}

uint64_t glpLoopStatementNodeSetBody1(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8) = a2;
  return result;
}

uint64_t glpMakeSwitchStatementNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  unsigned int v4;
  __n128 v6;
  unint64_t v7;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (SwitchStatement)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v6 = *a2;
  v7 = a2[1].n128_u64[0];
  initStatementNode(v3, 69, &v6);
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * *(unsigned int *)(v3 + 4)) = 0;
  v4 = *(_DWORD *)(v3 + 4) + 1;
  *(_DWORD *)(v3 + 4) = v4;
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4) = 0;
  ++*(_DWORD *)(v3 + 4);
  return v3;
}

uint64_t glpSwitchStatementNodeGetExpr(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpSwitchStatementNodeSetExpr(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpSwitchStatementNodeGetBody(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
}

uint64_t glpSwitchStatementNodeSetBody(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8) = a2;
  return result;
}

uint64_t glpMakeCaseStatementNode(uint64_t a1, __n128 *a2, char a3)
{
  uint64_t v5;
  __n128 v7;
  unint64_t v8;

  v5 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (CaseStatement)");
  *(_QWORD *)(v5 + 8) = v5 + 72;
  *(_DWORD *)v5 = 1;
  v7 = *a2;
  v8 = a2[1].n128_u64[0];
  initStatementNode(v5, 70, &v7);
  *(_BYTE *)(v5 + 64) = a3;
  *(_QWORD *)(*(_QWORD *)(v5 + 8) + 8 * (*(_DWORD *)(v5 + 4))++) = 0;
  return v5;
}

BOOL glpIsCaseStatementNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 70;
}

uint64_t glpCaseStatementNodeGetIsStray(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 64);
}

uint64_t glpCaseStatementNodeSetIsStray(uint64_t result, char a2)
{
  *(_BYTE *)(result + 64) = a2;
  return result;
}

uint64_t glpCaseStatementNodeGetConstValue(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpCaseStatementNodeSetConstValue(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpMakeDefaultStatementNode(uint64_t a1, __n128 *a2, char a3)
{
  uint64_t v5;
  __n128 v7;
  unint64_t v8;

  v5 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 72, "AST Node (DefaultStatement)");
  *(_QWORD *)(v5 + 8) = v5 + 72;
  *(_DWORD *)v5 = 0;
  v7 = *a2;
  v8 = a2[1].n128_u64[0];
  initStatementNode(v5, 71, &v7);
  *(_BYTE *)(v5 + 64) = a3;
  return v5;
}

BOOL glpIsDefaultStatementNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 71;
}

uint64_t glpDefaultStatementNodeGetIsStray(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 64);
}

uint64_t glpDefaultStatementNodeSetIsStray(uint64_t result, char a2)
{
  *(_BYTE *)(result + 64) = a2;
  return result;
}

uint64_t glpMakeBreakStatementNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 64, "AST Node (BreakStatement)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 0;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initStatementNode(v3, 72, &v5);
  return v3;
}

BOOL glpIsBreakStatementNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 72;
}

uint64_t glpMakeContinueStatementNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 64, "AST Node (ContinueStatement)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 0;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initStatementNode(v3, 73, &v5);
  return v3;
}

BOOL glpIsContinueStatementNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 73;
}

uint64_t glpMakeDiscardStatementNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 64, "AST Node (DiscardStatement)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 0;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initStatementNode(v3, 74, &v5);
  return v3;
}

BOOL glpIsDiscardStatementNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 74;
}

uint64_t glpMakeReturnStatementNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (ReturnStatement)");
  *(_QWORD *)(v3 + 8) = v3 + 72;
  *(_DWORD *)v3 = 1;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initStatementNode(v3, 75, &v5);
  *(_QWORD *)(v3 + 64) = 0;
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * (*(_DWORD *)(v3 + 4))++) = 0;
  return v3;
}

BOOL glpIsReturnStatementNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 75;
}

uint64_t glpReturnStatementNodeGetExtra(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpReturnStatementNodeSetExtra(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t glpReturnStatementNodeGetExpr(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpReturnStatementNodeSetExpr(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

__n128 glpMakeTopLevelNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  __n128 result;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (TopLevel)");
  *(_QWORD *)(v3 + 8) = v3 + 72;
  *(_DWORD *)v3 = 1;
  v4 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 16) = 76;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(__n128 *)(v3 + 40) = result;
  *(_QWORD *)(v3 + 56) = v4;
  *(_DWORD *)(v3 + 64) = 0;
  return result;
}

BOOL glpIsTopLevelNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 76;
}

uint64_t glpTopLevelNodeSetDef(uint64_t result, unsigned int a2, uint64_t a3)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * a2) = a3;
  return result;
}

void *glpTopLevelNodeAddDef(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return glpTopLevelNodeInsertDef(a1, a2, a3, *(_DWORD *)(a2 + 64));
}

void *glpTopLevelNodeInsertDef(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v7;
  int v8;
  int v10;
  int v11;
  unsigned int v12;
  char *v13;
  void *result;

  v7 = *(_DWORD *)(a2 + 4);
  v8 = v7 + 1;
  if ((v7 + 1) <= *(_DWORD *)a2)
  {
    v13 = *(char **)(a2 + 8);
  }
  else
  {
    if (*(int *)a2 <= 1)
      v10 = 1;
    else
      v10 = *(_DWORD *)a2;
    v11 = 2 * v10;
    if (v11 <= v8)
      v12 = v8;
    else
      v12 = v11;
    v13 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, 8 * v12, "Vector Storage (GLPASTNode *, growth)");
    memcpy(v13, *(const void **)(a2 + 8), 8 * *(unsigned int *)(a2 + 4));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, *(_QWORD *)(a2 + 8));
    *(_DWORD *)a2 = v12;
    *(_QWORD *)(a2 + 8) = v13;
    v7 = *(_DWORD *)(a2 + 4);
  }
  result = memmove(&v13[8 * a4 + 8], &v13[8 * a4], 8 * (v7 - a4));
  *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * a4) = a3;
  ++*(_DWORD *)(a2 + 4);
  ++*(_DWORD *)(a2 + 64);
  return result;
}

__n128 glpMakeAvailabilityDeclarationNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  __n128 result;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 72, "AST Node (AvailabilityDeclaration)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 1;
  v4 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 16) = 77;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(__n128 *)(v3 + 40) = result;
  *(_QWORD *)(v3 + 56) = v4;
  **(_QWORD **)(v3 + 8) = 0;
  ++*(_DWORD *)(v3 + 4);
  return result;
}

uint64_t glpAvailabilityDeclarationNodeSetExpr(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

__n128 glpMakeRawCallNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  unint64_t v10;
  __n128 result;

  v9 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 88, "AST Node (RawCall)");
  *(_QWORD *)(v9 + 8) = v9 + 88;
  *(_DWORD *)v9 = 0;
  v10 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v9 + 4) = 0;
  *(_DWORD *)(v9 + 16) = 78;
  *(_QWORD *)(v9 + 24) = 0;
  *(_QWORD *)(v9 + 32) = 0;
  *(__n128 *)(v9 + 40) = result;
  *(_QWORD *)(v9 + 56) = v10;
  *(_QWORD *)(v9 + 64) = a3;
  *(_QWORD *)(v9 + 72) = a4;
  *(_QWORD *)(v9 + 80) = a5;
  return result;
}

uint64_t glpRawCallNodeGetName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpRawCallNodeGetExtra(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

uint64_t glpRawCallNodeSetExtra(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 80) = a2;
  return result;
}

__n128 glpMakeSubroutineRawCallNode(uint64_t a1, __n128 *a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;
  __n128 result;

  v5 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (SubroutineRawCall)");
  *(_QWORD *)(v5 + 8) = v5 + 72;
  *(_DWORD *)v5 = 1;
  v6 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v5 + 4) = 0;
  *(_DWORD *)(v5 + 16) = 79;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(__n128 *)(v5 + 40) = result;
  *(_QWORD *)(v5 + 56) = v6;
  *(_QWORD *)(v5 + 64) = a3;
  **(_QWORD **)(v5 + 8) = 0;
  ++*(_DWORD *)(v5 + 4);
  return result;
}

uint64_t glpSubroutineRawCallNodeGetExtra(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpSubroutineRawCallNodeGetIndexExpr(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpSubroutineRawCallNodeSetIndexExpr(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpMakeOffsetNode(uint64_t a1, __int128 *a2)
{
  uint64_t v3;
  uint64_t v4;
  __int128 v5;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 112, "AST Node (Offset)");
  *(_QWORD *)(v3 + 8) = v3 + 88;
  *(_DWORD *)v3 = 3;
  v4 = *((_QWORD *)a2 + 2);
  v5 = *a2;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 16) = 80;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(_OWORD *)(v3 + 40) = v5;
  *(_QWORD *)(v3 + 56) = v4;
  *(_QWORD *)(v3 + 64) = 0;
  *(_QWORD *)(v3 + 72) = 0;
  *(_DWORD *)(v3 + 80) = 0;
  **(_QWORD **)(v3 + 8) = 0;
  LODWORD(v4) = *(_DWORD *)(v3 + 4) + 1;
  *(_DWORD *)(v3 + 4) = v4;
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4) = 0;
  LODWORD(v4) = *(_DWORD *)(v3 + 4) + 1;
  *(_DWORD *)(v3 + 4) = v4;
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4) = 0;
  ++*(_DWORD *)(v3 + 4);
  *(_QWORD *)(v3 + 32) = glpGetPrimitiveType(0);
  *(_DWORD *)(v3 + 80) = -1;
  return v3;
}

uint64_t glpOffsetNodeGetExtra(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpOffsetNodeSetExtra(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t glpOffsetNodeGetSwizzle(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

uint64_t glpOffsetNodeSetSwizzle(uint64_t result, int a2)
{
  *(_DWORD *)(result + 72) = a2;
  return result;
}

uint64_t glpOffsetNodeGetPreSwizzlePrimitiveType(uint64_t a1)
{
  return *(unsigned int *)(a1 + 76);
}

uint64_t glpOffsetNodeSetPreSwizzlePrimitiveType(uint64_t result, int a2)
{
  *(_DWORD *)(result + 76) = a2;
  return result;
}

uint64_t glpOffsetNodeGetCompStride(uint64_t a1)
{
  return *(unsigned int *)(a1 + 80);
}

uint64_t glpOffsetNodeSetCompStride(uint64_t result, int a2)
{
  *(_DWORD *)(result + 80) = a2;
  return result;
}

uint64_t glpOffsetNodeGetBankIndex(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpOffsetNodeSetBankIndex(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpOffsetNodeGetOffsetExpr(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
}

uint64_t glpOffsetNodeSetOffsetExpr(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8) = a2;
  return result;
}

uint64_t glpOffsetNodeGetVectorElementExpr(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16);
}

uint64_t glpOffsetNodeSetVectorElementExpr(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 16) = a2;
  return result;
}

BOOL glpIsDerefNode(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 16) - 81) < 2;
}

uint64_t glpDerefNodeGetOffset(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpDerefNodeSetOffset(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpMakeLValueNode(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  __n128 v11;
  unint64_t v12;

  v9 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 104, "AST Node (LValue)");
  *(_QWORD *)(v9 + 8) = v9 + 96;
  *(_DWORD *)v9 = 1;
  v11 = *a2;
  v12 = a2[1].n128_u64[0];
  initDerefNode(v9, 81, &v11);
  *(_QWORD *)(v9 + 64) = a3;
  *(_QWORD *)(v9 + 72) = a4;
  *(_QWORD *)(v9 + 80) = a5;
  *(_DWORD *)(v9 + 88) = 0;
  return v9;
}

BOOL glpIsLValueNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 81;
}

uint64_t glpLValueNodeGetVariableName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpLValueNodeSetVariableName(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 64) = a2;
  *(_QWORD *)(result + 72) = a3;
  return result;
}

uint64_t glpLValueNodeGetVariableExtra(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

uint64_t glpLValueNodeSetVariableExtra(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 80) = a2;
  return result;
}

uint64_t glpLValueNodeGetIndexLevel(uint64_t a1)
{
  return *(unsigned int *)(a1 + 88);
}

uint64_t glpLValueNodeSetIndexLevel(uint64_t result, int a2)
{
  *(_DWORD *)(result + 88) = a2;
  return result;
}

uint64_t glpMakeRValueNode(uint64_t a1, __n128 *a2)
{
  uint64_t v3;
  __n128 v5;
  unint64_t v6;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (RValue)");
  *(_QWORD *)(v3 + 8) = v3 + 64;
  *(_DWORD *)v3 = 2;
  v5 = *a2;
  v6 = a2[1].n128_u64[0];
  initDerefNode(v3, 82, &v5);
  *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * (*(_DWORD *)(v3 + 4))++) = 0;
  return v3;
}

uint64_t glpRValueNodeGetBase(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
}

uint64_t glpRValueNodeSetBase(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 8) = a2;
  return result;
}

__n128 glpMakeIBPartialDerefNode(uint64_t a1, __n128 *a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;
  __n128 result;

  v5 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 80, "AST Node (IBPartialDeref)");
  *(_QWORD *)(v5 + 8) = v5 + 72;
  *(_DWORD *)v5 = 1;
  v6 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v5 + 4) = 0;
  *(_DWORD *)(v5 + 16) = 83;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(__n128 *)(v5 + 40) = result;
  *(_QWORD *)(v5 + 56) = v6;
  *(_QWORD *)(v5 + 64) = a3;
  **(_QWORD **)(v5 + 8) = 0;
  ++*(_DWORD *)(v5 + 4);
  return result;
}

BOOL glpIsIBPartialDerefNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 83;
}

uint64_t glpIBPartialDerefNodeGetIb(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t glpIBPartialDerefNodeGetBankIndex(uint64_t a1)
{
  return **(_QWORD **)(a1 + 8);
}

uint64_t glpIBPartialDerefNodeSetBankIndex(uint64_t result, uint64_t a2)
{
  **(_QWORD **)(result + 8) = a2;
  return result;
}

uint64_t glpMakePPStreamOpNode(uint64_t a1, __n128 *a2, int a3, int a4, int a5, int a6, int a7)
{
  uint64_t v13;
  __n128 v15;
  unint64_t v16;

  v13 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 104, "AST Node (PPStreamOp)");
  *(_QWORD *)(v13 + 8) = v13 + 96;
  *(_DWORD *)v13 = 1;
  v15 = *a2;
  v16 = a2[1].n128_u64[0];
  initCallNode(v13, 84, &v15);
  *(_DWORD *)(v13 + 72) = a3;
  *(_DWORD *)(v13 + 76) = a4;
  *(_DWORD *)(v13 + 80) = a5;
  *(_DWORD *)(v13 + 84) = a6;
  *(_DWORD *)(v13 + 88) = a7;
  return v13;
}

uint64_t glpPPStreamOpNodeGetReturnPrimitiveType(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

uint64_t glpPPStreamOpNodeGetOpcode(uint64_t a1)
{
  return *(unsigned int *)(a1 + 76);
}

uint64_t glpPPStreamOpNodeGetOpPrimitiveType(uint64_t a1)
{
  return *(unsigned int *)(a1 + 80);
}

uint64_t glpPPStreamOpNodeGetHasSrctex(uint64_t a1)
{
  return *(unsigned int *)(a1 + 84);
}

uint64_t glpPPStreamOpNodeGetHasOffset(uint64_t a1)
{
  return *(unsigned int *)(a1 + 88);
}

__n128 glpMakeSubroutineUniformNode(uint64_t a1, __n128 *a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;
  __n128 result;

  v5 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(a1 + 8))(*(_QWORD *)a1, 72, "AST Node (SubroutineUniform)");
  *(_QWORD *)(v5 + 8) = v5 + 72;
  *(_DWORD *)v5 = 0;
  v6 = a2[1].n128_u64[0];
  result = *a2;
  *(_DWORD *)(v5 + 4) = 0;
  *(_DWORD *)(v5 + 16) = 85;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(__n128 *)(v5 + 40) = result;
  *(_QWORD *)(v5 + 56) = v6;
  *(_QWORD *)(v5 + 64) = a3;
  return result;
}

BOOL glpIsSubroutineUniformNode(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 85;
}

uint64_t glpSubroutineUniformNodeGetExtra(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

__n128 initUnaryOperatorNode(uint64_t a1, int a2, __n128 *a3)
{
  unint64_t v3;
  __n128 result;

  v3 = a3[1].n128_u64[0];
  result = *a3;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a1 + 56) = v3;
  **(_QWORD **)(a1 + 8) = 0;
  ++*(_DWORD *)(a1 + 4);
  return result;
}

__n128 initCallNode(uint64_t a1, int a2, __n128 *a3)
{
  unint64_t v3;
  __n128 result;

  v3 = a3[1].n128_u64[0];
  result = *a3;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a1 + 56) = v3;
  *(_DWORD *)(a1 + 64) = 0;
  return result;
}

__n128 initBinaryOperatorNode(uint64_t a1, int a2, __n128 *a3)
{
  unint64_t v3;
  __n128 result;

  v3 = a3[1].n128_u64[0];
  result = *a3;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a1 + 56) = v3;
  **(_QWORD **)(a1 + 8) = 0;
  LODWORD(v3) = *(_DWORD *)(a1 + 4) + 1;
  *(_DWORD *)(a1 + 4) = v3;
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v3) = 0;
  ++*(_DWORD *)(a1 + 4);
  return result;
}

__n128 initStructureNode(uint64_t a1, int a2, __n128 *a3)
{
  unint64_t v3;
  __n128 result;

  v3 = a3[1].n128_u64[0];
  result = *a3;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a1 + 56) = v3;
  *(_DWORD *)(a1 + 64) = 0;
  return result;
}

__n128 initQualifierNode(uint64_t a1, int a2, __n128 *a3)
{
  unint64_t v3;
  __n128 result;

  v3 = a3[1].n128_u64[0];
  result = *a3;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a1 + 56) = v3;
  return result;
}

__n128 initStatementNode(uint64_t a1, int a2, __n128 *a3)
{
  unint64_t v3;
  __n128 result;

  v3 = a3[1].n128_u64[0];
  result = *a3;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a1 + 56) = v3;
  return result;
}

__n128 initDerefNode(uint64_t a1, int a2, __n128 *a3)
{
  unint64_t v3;
  __n128 result;

  v3 = a3[1].n128_u64[0];
  result = *a3;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a1 + 56) = v3;
  **(_QWORD **)(a1 + 8) = 0;
  ++*(_DWORD *)(a1 + 4);
  return result;
}

unsigned int *deserialize_GLPType(unsigned int *a1, _QWORD *a2)
{
  _QWORD v3[5];

  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 0x40000000;
  v3[2] = __deserialize_GLPType_block_invoke;
  v3[3] = &__block_descriptor_tmp_12;
  v3[4] = a1;
  return deserialize_pointer(a1, (uint64_t)v3, a2);
}

unsigned int *deserialize_GLPValue(unsigned int *a1, uint64_t a2, _QWORD *a3)
{
  _QWORD v4[6];

  v4[0] = MEMORY[0x24BDAC760];
  v4[1] = 0x40000000;
  v4[2] = __deserialize_GLPValue_block_invoke;
  v4[3] = &__block_descriptor_tmp_2;
  v4[4] = a1;
  v4[5] = a2;
  return deserialize_pointer(a1, (uint64_t)v4, a3);
}

void *deserialize_GLPNameTableEntry(uint64_t a1, _QWORD *a2)
{
  _DWORD *v4;
  uint64_t v5;
  unsigned int v6;
  _DWORD *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  _QWORD *v12;
  void *v13;
  void *v14;
  void *result;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  int v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  _QWORD *v25;
  char *v26;
  int v27;
  uint64_t v28;
  _QWORD *v29;
  __int128 v30;
  void *v31;
  void *v32;
  uint64_t v33;

  v4 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(*(_QWORD *)(a1 + 240) + 8))(**(_QWORD **)(a1 + 240), 16, "Deserialized");
  v5 = *(unsigned int *)(a1 + 260);
  v6 = *(_DWORD *)(a1 + 256);
  if (v5 >= v6)
LABEL_29:
    glpDeserialError(a1, 1u);
  v7 = v4;
  v8 = *(_QWORD *)(a1 + 248);
  v9 = *(char *)(v8 + v5);
  v10 = *(unsigned __int8 *)(v8 + v5);
  v11 = v5 + 1;
  *(_DWORD *)(a1 + 260) = v5 + 1;
  if (v9 < 0)
    __asm { BR              X16 }
  *v4 = v10;
  switch((int)v10)
  {
    case 0:
    case 12:
      v12 = v4 + 2;
      *(_QWORD *)&v30 = MEMORY[0x24BDAC760];
      v13 = __deserialize_GLPVariableObject_block_invoke;
      *((_QWORD *)&v30 + 1) = 0x40000000;
      v14 = &__block_descriptor_tmp_6;
      goto LABEL_13;
    case 1:
    case 2:
    case 3:
      v12 = v4 + 2;
      *(_QWORD *)&v30 = MEMORY[0x24BDAC760];
      v13 = __deserialize_GLPInterfaceBlockObject_block_invoke;
      *((_QWORD *)&v30 + 1) = 0x40000000;
      v14 = &__block_descriptor_tmp_9;
      goto LABEL_13;
    case 4:
      v12 = v4 + 2;
      *(_QWORD *)&v30 = MEMORY[0x24BDAC760];
      v13 = __deserialize_GLPOverload_block_invoke;
      *((_QWORD *)&v30 + 1) = 0x40000000;
      v14 = &__block_descriptor_tmp_10;
      goto LABEL_13;
    case 5:
      v12 = v4 + 2;
      *(_QWORD *)&v30 = MEMORY[0x24BDAC760];
      v13 = __deserialize_GLPFunctionObject_block_invoke;
      *((_QWORD *)&v30 + 1) = 0x40000000;
      v14 = &__block_descriptor_tmp_5;
      goto LABEL_13;
    case 6:
    case 8:
    case 10:
      v12 = v4 + 2;
      *(_QWORD *)&v30 = MEMORY[0x24BDAC760];
      v13 = __deserialize_GLPType_block_invoke;
      *((_QWORD *)&v30 + 1) = 0x40000000;
      v14 = &__block_descriptor_tmp_12;
      goto LABEL_13;
    case 7:
      v12 = v4 + 2;
      *(_QWORD *)&v30 = MEMORY[0x24BDAC760];
      v13 = __deserialize_GLPSubroutineUniformObject_block_invoke;
      *((_QWORD *)&v30 + 1) = 0x40000000;
      v14 = &__block_descriptor_tmp_11;
      goto LABEL_13;
    case 9:
      v12 = v4 + 2;
      *(_QWORD *)&v30 = MEMORY[0x24BDAC760];
      v13 = __deserialize_GLPTwoThings_block_invoke;
      *((_QWORD *)&v30 + 1) = 0x40000000;
      v14 = &__block_descriptor_tmp_12;
      goto LABEL_13;
    case 11:
      v12 = v4 + 2;
      *(_QWORD *)&v30 = MEMORY[0x24BDAC760];
      v13 = __deserialize_GLPLayoutObject_block_invoke;
      *((_QWORD *)&v30 + 1) = 0x40000000;
      v14 = &__block_descriptor_tmp_3;
LABEL_13:
      v31 = v13;
      v32 = v14;
      v33 = a1;
      result = deserialize_pointer((unsigned int *)a1, (uint64_t)&v30, v12);
      goto LABEL_14;
    case 13:
      if (v11 >= v6)
        goto LABEL_29;
      v16 = *(char *)(v8 + v11);
      v17 = *(unsigned __int8 *)(v8 + v11);
      *(_DWORD *)(a1 + 260) = v5 + 2;
      v29 = a2;
      if (v16 < 0)
        __asm { BR              X16 }
      v18 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(*(_QWORD *)(a1 + 240) + 8))(**(_QWORD **)(a1 + 240), 16, "Deserialized");
      v19 = *(_QWORD *)(a1 + 240);
      *(_DWORD *)v18 = v17;
      *(_DWORD *)(v18 + 4) = 0;
      result = (void *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(v19 + 8))(*(_QWORD *)v19, 24 * v17, "Vector Storage (GLPNameTableEntryWithName)");
      *(_QWORD *)(v18 + 8) = result;
      if ((int)v17 >= 1)
      {
        do
        {
          *(_QWORD *)&v30 = 0;
          *((_QWORD *)&v30 + 1) = deserialize_GLPString(a1);
          v31 = v20;
          deserialize_GLPNameTableEntry(a1, &v30);
          v21 = *(_DWORD *)v18;
          v22 = *(unsigned int *)(v18 + 4);
          if ((v22 + 1) <= *(_DWORD *)v18)
          {
            v26 = *(char **)(v18 + 8);
            v27 = *(_DWORD *)(v18 + 4);
          }
          else
          {
            if (v21 <= 1)
              v21 = 1;
            v23 = 2 * v21;
            if (v23 <= (int)v22 + 1)
              v24 = v22 + 1;
            else
              v24 = v23;
            v25 = *(_QWORD **)(a1 + 240);
            v26 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))v25[1])(*v25, 24 * v24, "Vector Storage (GLPNameTableEntryWithName, growth)");
            memcpy(v26, *(const void **)(v18 + 8), 24 * *(unsigned int *)(v18 + 4));
            ((void (*)(_QWORD, _QWORD))v25[3])(*v25, *(_QWORD *)(v18 + 8));
            *(_DWORD *)v18 = v24;
            *(_QWORD *)(v18 + 8) = v26;
            v27 = *(_DWORD *)(v18 + 4);
          }
          result = memmove(&v26[24 * v22 + 24], &v26[24 * v22], 24 * (v27 - v22));
          v28 = *(_QWORD *)(v18 + 8) + 24 * v22;
          *(_QWORD *)(v28 + 16) = v31;
          *(_OWORD *)v28 = v30;
          ++*(_DWORD *)(v18 + 4);
          LODWORD(v17) = v17 - 1;
        }
        while ((_DWORD)v17);
      }
      *((_QWORD *)v7 + 1) = v18;
      a2 = v29;
LABEL_14:
      *a2 = v7;
      return result;
    default:
      glpDeserialError(a1, 0xAu);
  }
}

uint64_t glpDeserializeAST(uint64_t a1, uint64_t a2, int a3)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  _OWORD v14[2];
  uint64_t v15;
  uint64_t v16;
  void *v17;
  void *v18;
  _OWORD *v19;
  uint64_t v20;
  _OWORD v21[15];
  __int128 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  memset(v14, 0, sizeof(v14));
  glpInitPoolAllocator(0x20000, 0x20000, v14);
  v23 = 0;
  v22 = 0u;
  memset(v21, 0, sizeof(v21));
  glpInitDeserialContext((uint64_t)v21, (uint64_t)v14, a1, a2, a3);
  if (_setjmp((int *)v21))
  {
    glpDestroyDeserialContext(v21);
    glpDestroyPoolAllocator((uint64_t)v14);
    return 0;
  }
  else
  {
    if (HIDWORD(v23) >= v23)
      glpDeserialError((uint64_t)v21, 1u);
    v7 = *(char *)(*((_QWORD *)&v22 + 1) + HIDWORD(v23));
    v8 = *(unsigned __int8 *)(*((_QWORD *)&v22 + 1) + HIDWORD(v23));
    ++HIDWORD(v23);
    if (v7 < 0)
      __asm { BR              X3 }
    v9 = MEMORY[0x24BDAC760];
    if ((_DWORD)v8)
    {
      v10 = v8;
      do
      {
        v13 = 0;
        v11 = v10;
        v15 = v9;
        v16 = 0x40000000;
        v17 = __deserialize_GLPType_block_invoke;
        v18 = &__block_descriptor_tmp_12;
        v19 = v21;
        deserialize_pointer((unsigned int *)v21, (uint64_t)&v15, &v13);
        v12 = 0;
        v15 = v9;
        v16 = 0x40000000;
        v17 = __deserialize_GLPValue_block_invoke;
        v18 = &__block_descriptor_tmp_2;
        v19 = v21;
        v20 = v13;
        deserialize_pointer((unsigned int *)v21, (uint64_t)&v15, &v12);
        v10 = v11 - 1;
      }
      while (v11 != 1);
    }
    v13 = 0;
    v15 = v9;
    v16 = 0x40000000;
    v17 = __deserialize_GLPASTNode_block_invoke;
    v18 = &__block_descriptor_tmp_16_0;
    v19 = v21;
    deserialize_pointer((unsigned int *)v21, (uint64_t)&v15, &v13);
    glpDestroyDeserialContext(v21);
    glpDestroyPoolAllocator((uint64_t)v14);
    return v13;
  }
}

BOOL glpDeserializeNames(uint64_t a1, unsigned int *a2, int a3, uint64_t *a4)
{
  uint64_t v8;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _OWORD v39[2];
  uint64_t v40;
  uint64_t v41;
  void *v42;
  void *v43;
  _OWORD *v44;
  uint64_t v45;
  _OWORD v46[15];
  __int128 v47;
  uint64_t v48;
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  memset(v39, 0, sizeof(v39));
  glpInitPoolAllocator(0x20000, 0x20000, v39);
  v48 = 0;
  v47 = 0u;
  memset(v46, 0, sizeof(v46));
  v8 = *a2;
  glpInitDeserialContext((uint64_t)v46, (uint64_t)v39, a1, (uint64_t)(a2 + 1), a3);
  if (_setjmp((int *)v46))
  {
    glpDestroyDeserialContext(v46);
    glpDestroyPoolAllocator((uint64_t)v39);
    return 0;
  }
  v10 = HIDWORD(v48);
  if (HIDWORD(v48) >= v48)
    goto LABEL_30;
  v11 = *(char *)(*((_QWORD *)&v47 + 1) + HIDWORD(v48));
  v12 = *(unsigned __int8 *)(*((_QWORD *)&v47 + 1) + HIDWORD(v48));
  ++HIDWORD(v48);
  if (v11 < 0)
    __asm { BR              X3 }
  if ((_DWORD)v12)
  {
    v13 = v12;
    v14 = MEMORY[0x24BDAC760];
    do
    {
      v38 = 0;
      v40 = v14;
      v41 = 0x40000000;
      v42 = __deserialize_GLPType_block_invoke;
      v43 = &__block_descriptor_tmp_12;
      v44 = v46;
      deserialize_pointer((unsigned int *)v46, (uint64_t)&v40, &v38);
      v37 = 0;
      v40 = v14;
      v41 = 0x40000000;
      v42 = __deserialize_GLPValue_block_invoke;
      v43 = &__block_descriptor_tmp_2;
      v44 = v46;
      v45 = v38;
      deserialize_pointer((unsigned int *)v46, (uint64_t)&v40, &v37);
      --v13;
    }
    while (v13);
    v15 = HIDWORD(v48);
    v16 = v48;
    v8 = v8;
  }
  else
  {
    v16 = v48;
    v15 = v10 + 1;
  }
  if (v15 >= v16)
LABEL_30:
    glpDeserialError((uint64_t)v46, 1u);
  v17 = *(unsigned __int8 *)(*((_QWORD *)&v47 + 1) + v15);
  HIDWORD(v48) = v15 + 1;
  if (v17)
  {
    v18 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(v47 + 8))(*(_QWORD *)v47, 56, "Deserialized");
    v19 = HIDWORD(v48);
    v20 = v48;
    if (HIDWORD(v48) >= v48)
      goto LABEL_30;
    v21 = *((_QWORD *)&v47 + 1);
    v22 = *(char *)(*((_QWORD *)&v47 + 1) + HIDWORD(v48));
    v23 = *(unsigned __int8 *)(*((_QWORD *)&v47 + 1) + HIDWORD(v48));
    ++HIDWORD(v48);
    if (v22 < 0)
      __asm { BR              X4 }
    v24 = v19 + 1;
    v25 = v23;
    *(_DWORD *)(v18 + 32) = v23;
    if (v24 >= v20)
      goto LABEL_30;
    v26 = v18;
    v27 = *(char *)(v21 + v24);
    v28 = *(unsigned __int8 *)(v21 + v24);
    HIDWORD(v48) = v19 + 2;
    if (v27 < 0)
      __asm { BR              X3 }
    *(_DWORD *)(v18 + 36) = v28;
    *(_QWORD *)(v18 + 40) = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(v47 + 8))(*(_QWORD *)v47, 32 * v25, "Deserialized");
    *(_BYTE *)(v26 + 48) = 0;
    *(_OWORD *)v26 = 0u;
    *(_OWORD *)(v26 + 16) = 0u;
    v29 = *(unsigned int *)(v26 + 32);
    if ((_DWORD)v29)
    {
      v30 = (char *)a2 + v8;
      v31 = 0;
      v32 = 0;
      while ((unint64_t)HIDWORD(v48) + 4 <= v48)
      {
        v33 = *(unsigned int *)(*((_QWORD *)&v47 + 1) + HIDWORD(v48));
        HIDWORD(v48) += 4;
        v34 = *(_QWORD *)(v26 + 40);
        if ((_DWORD)v33 == -1)
        {
          *(_QWORD *)(v34 + v32) = 0;
        }
        else
        {
          v35 = v34 + v32;
          *(_QWORD *)(v34 + v32) = &v30[v33];
          *(_QWORD *)(v35 + 8) = deserialize_GLPString((uint64_t)v46);
          *(_QWORD *)(v35 + 16) = v36;
          v29 = *(unsigned int *)(v26 + 32);
        }
        ++v31;
        v32 += 32;
        if (v31 >= v29)
          goto LABEL_29;
      }
      goto LABEL_30;
    }
  }
  else
  {
    v26 = 0;
  }
LABEL_29:
  *a4 = v26;
  glpDestroyDeserialContext(v46);
  glpDestroyPoolAllocator((uint64_t)v39);
  return *a4 != 0;
}

unsigned int *deserializeTypeConversionFields(uint64_t a1, uint64_t a2)
{
  unsigned int *result;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  _QWORD v9[5];

  deserializeASTFields(a1, a2);
  v9[0] = MEMORY[0x24BDAC760];
  v9[1] = 0x40000000;
  v9[2] = __deserialize_GLPType_block_invoke;
  v9[3] = &__block_descriptor_tmp_12;
  v9[4] = a1;
  result = deserialize_pointer((unsigned int *)a1, (uint64_t)v9, (_QWORD *)(a2 + 64));
  v5 = *(unsigned int *)(a1 + 260);
  if (v5 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v6 = *(_QWORD *)(a1 + 248);
  v7 = *(char *)(v6 + v5);
  v8 = *(unsigned __int8 *)(v6 + v5);
  *(_DWORD *)(a1 + 260) = v5 + 1;
  if (v7 < 0)
    __asm { BR              X16 }
  *(_QWORD *)(a2 + 72) = v8;
  return result;
}

uint64_t deserializeVariableIdentifierFields(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  deserializeASTFields(a1, a2);
  result = deserialize_GLPString(a1);
  *(_QWORD *)(a2 + 64) = result;
  *(_QWORD *)(a2 + 72) = v5;
  return result;
}

uint64_t deserializeTypeIdentifierFields(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  deserializeASTFields(a1, a2);
  result = deserialize_GLPString(a1);
  *(_QWORD *)(a2 + 64) = result;
  *(_QWORD *)(a2 + 72) = v5;
  return result;
}

unsigned int *deserializeConstantFields(unsigned int *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t Type;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v10;
  unsigned int *v11;
  uint64_t v12;

  deserializeASTFields((uint64_t)a1, a2);
  v4 = MEMORY[0x24BDAC760];
  v7 = MEMORY[0x24BDAC760];
  v8 = 0x40000000;
  v9 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))__deserialize_GLPType_block_invoke;
  v10 = &__block_descriptor_tmp_12;
  v11 = a1;
  deserialize_pointer(a1, (uint64_t)&v7, (_QWORD *)(a2 + 64));
  Type = glpConstantNodeGetType(a2);
  v7 = v4;
  v8 = 0x40000000;
  v9 = __deserialize_GLPValue_block_invoke;
  v10 = &__block_descriptor_tmp_2;
  v11 = a1;
  v12 = Type;
  return deserialize_pointer(a1, (uint64_t)&v7, (_QWORD *)(a2 + 72));
}

uint64_t deserializeFieldAccessFields(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  deserializeASTFields(a1, a2);
  result = deserialize_GLPString(a1);
  *(_QWORD *)(a2 + 64) = result;
  *(_QWORD *)(a2 + 72) = v5;
  return result;
}

unsigned int *deserializeFunctionCallFields(unsigned int *a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD v6[5];

  deserializeCallFields((uint64_t)a1, (uint64_t)a2);
  a2[9] = deserialize_GLPString((uint64_t)a1);
  a2[10] = v4;
  v6[0] = MEMORY[0x24BDAC760];
  v6[1] = 0x40000000;
  v6[2] = __deserialize_GLPFunctionObject_block_invoke;
  v6[3] = &__block_descriptor_tmp_5;
  v6[4] = a1;
  return deserialize_pointer(a1, (uint64_t)v6, a2 + 11);
}

uint64_t deserializeSubroutineArrayCallFields(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  deserializeCallFields(a1, a2);
  result = deserialize_GLPString(a1);
  *(_QWORD *)(a2 + 72) = result;
  *(_QWORD *)(a2 + 80) = v5;
  return result;
}

uint64_t deserializeMethodCallFields(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  deserializeCallFields(a1, a2);
  result = deserialize_GLPString(a1);
  *(_QWORD *)(a2 + 72) = result;
  *(_QWORD *)(a2 + 80) = v5;
  return result;
}

void deserializeEqualFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char v5;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v5 = *(_BYTE *)(*(_QWORD *)(a1 + 248) + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  *(_BYTE *)(a2 + 64) = v5;
}

void deserializeNotEqualFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char v5;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v5 = *(_BYTE *)(*(_QWORD *)(a1 + 248) + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  *(_BYTE *)(a2 + 64) = v5;
}

void deserializeAssignFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char v5;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v5 = *(_BYTE *)(*(_QWORD *)(a1 + 248) + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  *(_BYTE *)(a2 + 64) = v5;
}

unsigned int *deserializeReadInputFields(unsigned int *a1, uint64_t a2)
{
  _QWORD v5[5];

  deserializeASTFields((uint64_t)a1, a2);
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 0x40000000;
  v5[2] = __deserialize_GLPVariableObject_block_invoke;
  v5[3] = &__block_descriptor_tmp_6;
  v5[4] = a1;
  return deserialize_pointer(a1, (uint64_t)v5, (_QWORD *)(a2 + 64));
}

unsigned int *deserializeWriteOutputFields(unsigned int *a1, uint64_t a2)
{
  _QWORD v5[5];

  deserializeASTFields((uint64_t)a1, a2);
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 0x40000000;
  v5[2] = __deserialize_GLPVariableObject_block_invoke;
  v5[3] = &__block_descriptor_tmp_6;
  v5[4] = a1;
  return deserialize_pointer(a1, (uint64_t)v5, (_QWORD *)(a2 + 64));
}

void deserializeCommaExprFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256)
    || (v5 = *(_BYTE *)(*(_QWORD *)(a1 + 248) + v4),
        *(_DWORD *)(a1 + 260) = v4 + 1,
        *(_BYTE *)(a2 + 64) = v5,
        v6 = *(unsigned int *)(a1 + 260),
        v6 >= *(_DWORD *)(a1 + 256)))
  {
    glpDeserialError(a1, 1u);
  }
  v7 = *(_QWORD *)(a1 + 248);
  v8 = *(char *)(v7 + v6);
  v9 = *(unsigned __int8 *)(v7 + v6);
  *(_DWORD *)(a1 + 260) = v6 + 1;
  if (v8 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 68) = v9;
}

unsigned int *deserializeParameterDeclarationFields(unsigned int *a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD v6[5];

  deserializeASTFields((uint64_t)a1, (uint64_t)a2);
  a2[8] = deserialize_GLPString((uint64_t)a1);
  a2[9] = v4;
  v6[0] = MEMORY[0x24BDAC760];
  v6[1] = 0x40000000;
  v6[2] = __deserialize_GLPVariableObject_block_invoke;
  v6[3] = &__block_descriptor_tmp_6;
  v6[4] = a1;
  return deserialize_pointer(a1, (uint64_t)v6, a2 + 10);
}

unsigned int *deserializeFunctionPrototypeFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int *result;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  _QWORD v10[5];

  deserializeASTFields(a1, a2);
  *(_QWORD *)(a2 + 64) = deserialize_GLPString(a1);
  *(_QWORD *)(a2 + 72) = v4;
  v10[0] = MEMORY[0x24BDAC760];
  v10[1] = 0x40000000;
  v10[2] = __deserialize_GLPFunctionObject_block_invoke;
  v10[3] = &__block_descriptor_tmp_5;
  v10[4] = a1;
  result = deserialize_pointer((unsigned int *)a1, (uint64_t)v10, (_QWORD *)(a2 + 80));
  v6 = *(unsigned int *)(a1 + 260);
  if (v6 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v7 = *(_QWORD *)(a1 + 248);
  v8 = *(char *)(v7 + v6);
  v9 = *(unsigned __int8 *)(v7 + v6);
  *(_DWORD *)(a1 + 260) = v6 + 1;
  if (v8 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 88) = v9;
  return result;
}

unsigned int *deserializeVariableDeclarationFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  char v6;
  _QWORD v8[5];

  deserializeASTFields(a1, a2);
  *(_QWORD *)(a2 + 64) = deserialize_GLPString(a1);
  *(_QWORD *)(a2 + 72) = v4;
  v5 = *(unsigned int *)(a1 + 260);
  if (v5 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v6 = *(_BYTE *)(*(_QWORD *)(a1 + 248) + v5);
  *(_DWORD *)(a1 + 260) = v5 + 1;
  *(_BYTE *)(a2 + 80) = v6;
  v8[0] = MEMORY[0x24BDAC760];
  v8[1] = 0x40000000;
  v8[2] = __deserialize_GLPVariableObject_block_invoke;
  v8[3] = &__block_descriptor_tmp_6;
  v8[4] = a1;
  return deserialize_pointer((unsigned int *)a1, (uint64_t)v8, (_QWORD *)(a2 + 88));
}

void deserializeVariableDeclarationGroupFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v5 = *(_QWORD *)(a1 + 248);
  v6 = *(char *)(v5 + v4);
  v7 = *(unsigned __int8 *)(v5 + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  if (v6 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 64) = v7;
}

uint64_t deserializeQualifiedDeclarationFields(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  deserializeASTFields(a1, a2);
  result = deserialize_GLPString(a1);
  *(_QWORD *)(a2 + 64) = result;
  *(_QWORD *)(a2 + 72) = v5;
  return result;
}

void deserializeQualifiedDeclarationGroupFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v5 = *(_QWORD *)(a1 + 248);
  v6 = *(char *)(v5 + v4);
  v7 = *(unsigned __int8 *)(v5 + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  if (v6 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 64) = v7;
}

void deserializePrimitiveTypeFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v5 = *(_QWORD *)(a1 + 248);
  v6 = *(char *)(v5 + v4);
  v7 = *(unsigned __int8 *)(v5 + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  if (v6 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 64) = v7;
}

uint64_t deserializeFieldDeclarationFields(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  deserializeASTFields(a1, a2);
  result = deserialize_GLPString(a1);
  *(_QWORD *)(a2 + 64) = result;
  *(_QWORD *)(a2 + 72) = v5;
  return result;
}

uint64_t deserializeStructTypeFields(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  deserializeStructureFields(a1, a2);
  result = deserialize_GLPString(a1);
  *(_QWORD *)(a2 + 72) = result;
  *(_QWORD *)(a2 + 80) = v5;
  return result;
}

unsigned int *deserializeInterfaceBlockFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  char v9;
  _QWORD v11[5];

  deserializeStructureFields(a1, a2);
  *(_QWORD *)(a2 + 72) = deserialize_GLPString(a1);
  *(_QWORD *)(a2 + 80) = v4;
  *(_QWORD *)(a2 + 88) = deserialize_GLPString(a1);
  *(_QWORD *)(a2 + 96) = v5;
  v6 = *(unsigned int *)(a1 + 260);
  if (v6 >= *(_DWORD *)(a1 + 256)
    || (v7 = *(_BYTE *)(*(_QWORD *)(a1 + 248) + v6),
        *(_DWORD *)(a1 + 260) = v6 + 1,
        *(_BYTE *)(a2 + 104) = v7,
        v8 = *(unsigned int *)(a1 + 260),
        v8 >= *(_DWORD *)(a1 + 256)))
  {
    glpDeserialError(a1, 1u);
  }
  v9 = *(_BYTE *)(*(_QWORD *)(a1 + 248) + v8);
  *(_DWORD *)(a1 + 260) = v8 + 1;
  *(_BYTE *)(a2 + 105) = v9;
  v11[0] = MEMORY[0x24BDAC760];
  v11[1] = 0x40000000;
  v11[2] = __deserialize_GLPInterfaceBlockObject_block_invoke;
  v11[3] = &__block_descriptor_tmp_9;
  v11[4] = a1;
  return deserialize_pointer((unsigned int *)a1, (uint64_t)v11, (_QWORD *)(a2 + 112));
}

void deserializeLayoutTypeFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v5 = *(_QWORD *)(a1 + 248);
  v6 = *(char *)(v5 + v4);
  v7 = *(unsigned __int8 *)(v5 + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  if (v6 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 64) = v7;
}

void deserializeKeywordQualifierFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v5 = *(_QWORD *)(a1 + 248);
  v6 = *(char *)(v5 + v4);
  v7 = *(unsigned __int8 *)(v5 + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  if (v6 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 64) = v7;
}

void deserializeLayoutQualifierFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v5 = *(_QWORD *)(a1 + 248);
  v6 = *(char *)(v5 + v4);
  v7 = *(unsigned __int8 *)(v5 + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  if (v6 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 64) = v7;
}

void deserializeSubroutineTypeListFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v5 = *(_QWORD *)(a1 + 248);
  v6 = *(char *)(v5 + v4);
  v7 = *(unsigned __int8 *)(v5 + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  if (v6 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 64) = v7;
}

void deserializeQualifierListFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v5 = *(_QWORD *)(a1 + 248);
  v6 = *(char *)(v5 + v4);
  v7 = *(unsigned __int8 *)(v5 + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  if (v6 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 64) = v7;
}

unsigned int *deserializeGlobalTypeQualifierFields(unsigned int *a1, uint64_t a2)
{
  _QWORD v5[5];

  deserializeASTFields((uint64_t)a1, a2);
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 0x40000000;
  v5[2] = __deserialize_GLPLayoutObject_block_invoke;
  v5[3] = &__block_descriptor_tmp_3;
  v5[4] = a1;
  return deserialize_pointer(a1, (uint64_t)v5, (_QWORD *)(a2 + 64));
}

uint64_t deserializeLayoutPairFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t result;
  uint64_t v12;

  deserializeASTFields(a1, a2);
  *(_QWORD *)(a2 + 64) = deserialize_GLPString(a1);
  *(_QWORD *)(a2 + 72) = v4;
  v5 = *(unsigned int *)(a1 + 260);
  if (v5 >= *(_DWORD *)(a1 + 256))
    goto LABEL_6;
  v6 = *(_QWORD *)(a1 + 248);
  v7 = *(char *)(v6 + v5);
  v8 = *(unsigned __int8 *)(v6 + v5);
  *(_DWORD *)(a1 + 260) = v5 + 1;
  if (v7 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 80) = v8;
  v9 = *(unsigned int *)(a1 + 260);
  if (v9 + 4 > (unint64_t)*(unsigned int *)(a1 + 256))
LABEL_6:
    glpDeserialError(a1, 1u);
  v10 = *(_DWORD *)(*(_QWORD *)(a1 + 248) + v9);
  *(_DWORD *)(a1 + 260) = v9 + 4;
  *(_DWORD *)(a2 + 84) = v10;
  result = deserialize_GLPString(a1);
  *(_QWORD *)(a2 + 88) = result;
  *(_QWORD *)(a2 + 96) = v12;
  return result;
}

void deserializeBlockFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256)
    || (v5 = *(_BYTE *)(*(_QWORD *)(a1 + 248) + v4),
        *(_DWORD *)(a1 + 260) = v4 + 1,
        *(_BYTE *)(a2 + 64) = v5,
        v6 = *(unsigned int *)(a1 + 260),
        v6 >= *(_DWORD *)(a1 + 256)))
  {
    glpDeserialError(a1, 1u);
  }
  v7 = *(_QWORD *)(a1 + 248);
  v8 = *(char *)(v7 + v6);
  v9 = *(unsigned __int8 *)(v7 + v6);
  *(_DWORD *)(a1 + 260) = v6 + 1;
  if (v8 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 68) = v9;
}

void deserializeCaseStatementFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char v5;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v5 = *(_BYTE *)(*(_QWORD *)(a1 + 248) + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  *(_BYTE *)(a2 + 64) = v5;
}

void deserializeDefaultStatementFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char v5;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v5 = *(_BYTE *)(*(_QWORD *)(a1 + 248) + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  *(_BYTE *)(a2 + 64) = v5;
}

unsigned int *deserializeReturnStatementFields(unsigned int *a1, uint64_t a2)
{
  _QWORD v5[5];

  deserializeASTFields((uint64_t)a1, a2);
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 0x40000000;
  v5[2] = __deserialize_GLPFunctionObject_block_invoke;
  v5[3] = &__block_descriptor_tmp_5;
  v5[4] = a1;
  return deserialize_pointer(a1, (uint64_t)v5, (_QWORD *)(a2 + 64));
}

void deserializeTopLevelFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v5 = *(_QWORD *)(a1 + 248);
  v6 = *(char *)(v5 + v4);
  v7 = *(unsigned __int8 *)(v5 + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  if (v6 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 64) = v7;
}

unsigned int *deserializeRawCallFields(unsigned int *a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD v6[5];

  deserializeASTFields((uint64_t)a1, (uint64_t)a2);
  a2[8] = deserialize_GLPString((uint64_t)a1);
  a2[9] = v4;
  v6[0] = MEMORY[0x24BDAC760];
  v6[1] = 0x40000000;
  v6[2] = __deserialize_GLPFunctionObject_block_invoke;
  v6[3] = &__block_descriptor_tmp_5;
  v6[4] = a1;
  return deserialize_pointer(a1, (uint64_t)v6, a2 + 10);
}

unsigned int *deserializeSubroutineRawCallFields(unsigned int *a1, uint64_t a2)
{
  _QWORD v5[5];

  deserializeASTFields((uint64_t)a1, a2);
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 0x40000000;
  v5[2] = __deserialize_GLPSubroutineUniformObject_block_invoke;
  v5[3] = &__block_descriptor_tmp_11;
  v5[4] = a1;
  return deserialize_pointer(a1, (uint64_t)v5, (_QWORD *)(a2 + 64));
}

unsigned int *deserializeOffsetFields(uint64_t a1, uint64_t a2)
{
  unsigned int *result;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  _QWORD v17[5];

  deserializeASTFields(a1, a2);
  v17[0] = MEMORY[0x24BDAC760];
  v17[1] = 0x40000000;
  v17[2] = __deserialize_GLPOffsetObject_block_invoke;
  v17[3] = &__block_descriptor_tmp_17;
  v17[4] = a1;
  result = deserialize_pointer((unsigned int *)a1, (uint64_t)v17, (_QWORD *)(a2 + 64));
  v5 = *(unsigned int *)(a1 + 260);
  if (v5 >= *(_DWORD *)(a1 + 256))
    goto LABEL_11;
  v6 = *(_QWORD *)(a1 + 248);
  v7 = *(char *)(v6 + v5);
  v8 = *(unsigned __int8 *)(v6 + v5);
  *(_DWORD *)(a1 + 260) = v5 + 1;
  if (v7 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 72) = v8;
  v9 = *(unsigned int *)(a1 + 260);
  if (v9 >= *(_DWORD *)(a1 + 256))
    goto LABEL_11;
  v10 = *(_QWORD *)(a1 + 248);
  v11 = *(char *)(v10 + v9);
  v12 = *(unsigned __int8 *)(v10 + v9);
  *(_DWORD *)(a1 + 260) = v9 + 1;
  if (v11 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 76) = v12;
  v13 = *(unsigned int *)(a1 + 260);
  if (v13 >= *(_DWORD *)(a1 + 256))
LABEL_11:
    glpDeserialError(a1, 1u);
  v14 = *(_QWORD *)(a1 + 248);
  v15 = *(char *)(v14 + v13);
  v16 = *(unsigned __int8 *)(v14 + v13);
  *(_DWORD *)(a1 + 260) = v13 + 1;
  if (v15 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 80) = v16;
  return result;
}

unsigned int *deserializeLValueFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int *result;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  _QWORD v10[5];

  deserializeASTFields(a1, a2);
  *(_QWORD *)(a2 + 64) = deserialize_GLPString(a1);
  *(_QWORD *)(a2 + 72) = v4;
  v10[0] = MEMORY[0x24BDAC760];
  v10[1] = 0x40000000;
  v10[2] = __deserialize_GLPVariableObject_block_invoke;
  v10[3] = &__block_descriptor_tmp_6;
  v10[4] = a1;
  result = deserialize_pointer((unsigned int *)a1, (uint64_t)v10, (_QWORD *)(a2 + 80));
  v6 = *(unsigned int *)(a1 + 260);
  if (v6 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v7 = *(_QWORD *)(a1 + 248);
  v8 = *(char *)(v7 + v6);
  v9 = *(unsigned __int8 *)(v7 + v6);
  *(_DWORD *)(a1 + 260) = v6 + 1;
  if (v8 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 88) = v9;
  return result;
}

unsigned int *deserializeIBPartialDerefFields(unsigned int *a1, uint64_t a2)
{
  _QWORD v5[5];

  deserializeASTFields((uint64_t)a1, a2);
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 0x40000000;
  v5[2] = __deserialize_GLPInterfaceBlockObject_block_invoke;
  v5[3] = &__block_descriptor_tmp_9;
  v5[4] = a1;
  return deserialize_pointer(a1, (uint64_t)v5, (_QWORD *)(a2 + 64));
}

void deserializePPStreamOpFields(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;

  deserializeCallFields(a1, (uint64_t)a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    goto LABEL_17;
  v5 = *(_QWORD *)(a1 + 248);
  v6 = *(char *)(v5 + v4);
  v7 = *(unsigned __int8 *)(v5 + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  if (v6 < 0)
    __asm { BR              X16 }
  a2[18] = v7;
  v8 = *(unsigned int *)(a1 + 260);
  if (v8 >= *(_DWORD *)(a1 + 256))
    goto LABEL_17;
  v9 = *(_QWORD *)(a1 + 248);
  v10 = *(char *)(v9 + v8);
  v11 = *(unsigned __int8 *)(v9 + v8);
  *(_DWORD *)(a1 + 260) = v8 + 1;
  if (v10 < 0)
    __asm { BR              X16 }
  a2[19] = v11;
  v12 = *(unsigned int *)(a1 + 260);
  if (v12 >= *(_DWORD *)(a1 + 256))
    goto LABEL_17;
  v13 = *(_QWORD *)(a1 + 248);
  v14 = *(char *)(v13 + v12);
  v15 = *(unsigned __int8 *)(v13 + v12);
  *(_DWORD *)(a1 + 260) = v12 + 1;
  if (v14 < 0)
    __asm { BR              X16 }
  a2[20] = v15;
  v16 = *(unsigned int *)(a1 + 260);
  if (v16 >= *(_DWORD *)(a1 + 256))
    goto LABEL_17;
  v17 = *(_QWORD *)(a1 + 248);
  v18 = *(char *)(v17 + v16);
  v19 = *(unsigned __int8 *)(v17 + v16);
  *(_DWORD *)(a1 + 260) = v16 + 1;
  if (v18 < 0)
    __asm { BR              X16 }
  a2[21] = v19;
  v20 = *(unsigned int *)(a1 + 260);
  if (v20 >= *(_DWORD *)(a1 + 256))
LABEL_17:
    glpDeserialError(a1, 1u);
  v21 = *(_QWORD *)(a1 + 248);
  v22 = *(char *)(v21 + v20);
  v23 = *(unsigned __int8 *)(v21 + v20);
  *(_DWORD *)(a1 + 260) = v20 + 1;
  if (v22 < 0)
    __asm { BR              X16 }
  a2[22] = v23;
}

unsigned int *deserializeSubroutineUniformFields(unsigned int *a1, uint64_t a2)
{
  _QWORD v5[5];

  deserializeASTFields((uint64_t)a1, a2);
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 0x40000000;
  v5[2] = __deserialize_GLPSubroutineUniformObject_block_invoke;
  v5[3] = &__block_descriptor_tmp_11;
  v5[4] = a1;
  return deserialize_pointer(a1, (uint64_t)v5, (_QWORD *)(a2 + 64));
}

double deserializeASTFields(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  double result;
  __int128 v19;
  uint64_t (*v20)();
  void *v21;
  uint64_t v22;

  v3 = *(unsigned int *)(a1 + 260);
  if (v3 >= *(_DWORD *)(a1 + 256))
    goto LABEL_11;
  v5 = *(_QWORD *)(a1 + 248);
  v6 = *(char *)(v5 + v3);
  v7 = *(unsigned __int8 *)(v5 + v3);
  *(_DWORD *)(a1 + 260) = v3 + 1;
  if (v6 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 16) = v7;
  v8 = *(unsigned int *)(a1 + 260);
  if (v8 >= *(_DWORD *)(a1 + 256))
    goto LABEL_11;
  v9 = *(_QWORD *)(a1 + 248);
  v10 = *(char *)(v9 + v8);
  v11 = *(unsigned __int8 *)(v9 + v8);
  *(_DWORD *)(a1 + 260) = v8 + 1;
  if (v10 < 0)
    __asm { BR              X16 }
  *(_QWORD *)(a2 + 24) = v11;
  *(_QWORD *)&v19 = MEMORY[0x24BDAC760];
  *((_QWORD *)&v19 + 1) = 0x40000000;
  v20 = __deserialize_GLPType_block_invoke;
  v21 = &__block_descriptor_tmp_12;
  v22 = a1;
  deserialize_pointer((unsigned int *)a1, (uint64_t)&v19, (_QWORD *)(a2 + 32));
  v12 = deserialize_GLPString(a1);
  v14 = *(unsigned int *)(a1 + 260);
  if (v14 >= *(_DWORD *)(a1 + 256))
LABEL_11:
    glpDeserialError(a1, 1u);
  v15 = *(_QWORD *)(a1 + 248);
  v16 = *(char *)(v15 + v14);
  v17 = *(unsigned __int8 *)(v15 + v14);
  *(_DWORD *)(a1 + 260) = v14 + 1;
  if (v16 < 0)
    __asm { BR              X16 }
  glpMakeSourceLocation(v12, v13, v17, &v19);
  result = *(double *)&v19;
  *(_OWORD *)(a2 + 40) = v19;
  *(_QWORD *)(a2 + 56) = v20;
  return result;
}

void deserializeCallFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v5 = *(_QWORD *)(a1 + 248);
  v6 = *(char *)(v5 + v4);
  v7 = *(unsigned __int8 *)(v5 + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  if (v6 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 64) = v7;
}

void deserializeStructureFields(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  deserializeASTFields(a1, a2);
  v4 = *(unsigned int *)(a1 + 260);
  if (v4 >= *(_DWORD *)(a1 + 256))
    glpDeserialError(a1, 1u);
  v5 = *(_QWORD *)(a1 + 248);
  v6 = *(char *)(v5 + v4);
  v7 = *(unsigned __int8 *)(v5 + v4);
  *(_DWORD *)(a1 + 260) = v4 + 1;
  if (v6 < 0)
    __asm { BR              X16 }
  *(_DWORD *)(a2 + 64) = v7;
}

uint64_t serialize_GLPType(_QWORD *a1, unint64_t a2)
{
  unsigned int *ReturnType;
  uint64_t result;
  uint64_t Kind;
  int v6;
  char v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  char *v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  int v41;
  uint64_t v42;
  int v43;
  uint64_t ElementCount;
  int v45;
  char v46;
  int v47;
  uint64_t v48;
  int v49;
  int v50;
  uint64_t v51;
  char *v52;
  int v53;
  int v54;
  unsigned int v55;
  unsigned int v56;
  int v57;
  int v58;
  uint64_t v59;
  char *v60;
  unsigned int v61;
  unsigned int v62;
  int v63;
  int v64;
  uint64_t v65;
  char *v66;
  unsigned int v67;
  unsigned int v68;
  int v69;
  int v70;
  uint64_t v71;
  char *v72;
  unsigned int v73;
  unsigned int v74;
  int v75;
  int v76;
  uint64_t v77;
  char *v78;
  unsigned int v79;
  int v80;
  uint64_t v81;
  unsigned int i;
  uint64_t ElementType;
  unint64_t ElementFlags;
  char v85;
  int v86;
  uint64_t v87;
  int v88;
  int v89;
  uint64_t v90;
  char *v91;
  int v92;
  unint64_t *ElementLayout;
  uint64_t PrimitiveType;
  int v95;
  unsigned int v96;
  int v97;
  uint64_t v98;
  int v99;
  int v100;
  uint64_t v101;
  char *v102;
  int v103;
  uint64_t v104;
  int v105;
  unsigned int v106;
  int v107;
  uint64_t v108;
  int v109;
  int v110;
  uint64_t v111;
  char *v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  int v116;
  unsigned int v117;
  int v118;
  uint64_t v119;
  int v120;
  int v121;
  uint64_t v122;
  char *v123;
  int v124;
  uint64_t v125;
  uint64_t v126;
  int v127;
  unsigned int v128;
  int v129;
  uint64_t v130;
  int v131;
  int v132;
  uint64_t v133;
  char *v134;
  int v135;
  const char *v136;
  uint64_t v137;
  unint64_t FunctionObject;
  int v139;
  unsigned int v140;
  int v141;
  unsigned int v142;
  unsigned int v143;
  int v144;
  int v145;
  uint64_t v146;
  char *v147;
  unsigned int v148;
  int v149;
  unsigned int v150;
  unsigned int v151;
  int v152;
  int v153;
  uint64_t v154;
  char *v155;
  unsigned int v156;
  int v157;
  unsigned int v158;
  unsigned int v159;
  int v160;
  int v161;
  uint64_t v162;
  char *v163;
  unsigned int v164;
  unsigned int v165;
  int v166;
  int v167;
  uint64_t v168;
  char *v169;
  unsigned int v170;
  unsigned int v171;
  int v172;
  int v173;
  uint64_t v174;
  char *v175;
  unsigned int v176;
  unsigned int v177;
  int v178;
  int v179;
  uint64_t v180;
  char *v181;
  unsigned int v182;
  unsigned int v183;
  int v184;
  int v185;
  uint64_t v186;
  char *v187;
  unsigned int v188;
  unsigned int v189;
  int v190;
  int v191;
  uint64_t v192;
  char *v193;
  unsigned int v194;
  unsigned int v195;
  int v196;
  int v197;
  uint64_t v198;
  char *v199;
  unsigned int v200;
  unsigned int v201;
  int v202;
  int v203;
  uint64_t v204;
  char *v205;
  unsigned int v206;
  unsigned int v207;
  int v208;
  int v209;
  uint64_t v210;
  char *v211;
  unsigned int v212;
  unsigned int v213;
  int v214;
  int v215;
  uint64_t v216;
  char *v217;
  unsigned int v218;
  int v219;
  int v220;
  int v221;
  uint64_t v222;
  unsigned int j;
  uint64_t v224;
  unint64_t v225;
  char v226;
  int v227;
  uint64_t v228;
  int v229;
  int v230;
  uint64_t v231;
  char *v232;
  int v233;
  unint64_t *v234;
  const char *FieldName;
  uint64_t v236;
  const char *Name;
  uint64_t v238;
  uint64_t v239;
  uint64_t MaxElementCount;
  unsigned int v241;
  int v242;
  uint64_t v243;
  int v244;
  int v245;
  uint64_t v246;
  char *v247;
  int v248;
  uint64_t v249;
  uint64_t Bank;
  unsigned int v251;
  int v252;
  uint64_t v253;
  int v254;
  int v255;
  uint64_t v256;
  char *v257;
  int v258;
  unsigned int v259;
  int v260;
  int v261;
  uint64_t v262;
  char *v263;
  unsigned int v264;
  unsigned int v265;
  int v266;
  int v267;
  uint64_t v268;
  char *v269;
  unsigned int v270;
  unsigned int v271;
  int v272;
  int v273;
  uint64_t v274;
  char *v275;
  unsigned int v276;
  unsigned int v277;
  int v278;
  int v279;
  uint64_t v280;
  char *v281;
  unsigned int v282;
  int v283;
  uint64_t v284;

  ReturnType = (unsigned int *)a2;
  result = serialize_pointer(a1, a2);
  if ((_DWORD)result)
  {
    while (1)
    {
      Kind = glpTypeGetKind(ReturnType);
      v6 = Kind;
      v7 = glp_serialized_integer32_control(Kind);
      v8 = *((_DWORD *)a1 + 8);
      v9 = *((unsigned int *)a1 + 9);
      v10 = v9 + 1;
      if ((int)v9 + 1 <= v8)
      {
        v13 = (char *)a1[5];
        v14 = *((_DWORD *)a1 + 9);
      }
      else
      {
        if (v8 <= 1)
          v8 = 1;
        v11 = 2 * v8;
        v12 = v11 <= v10 ? v10 : v11;
        v13 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v12, "Vector Storage (uint8_t, growth)");
        memcpy(v13, (const void *)a1[5], *((unsigned int *)a1 + 9));
        ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
        *((_DWORD *)a1 + 8) = v12;
        a1[5] = v13;
        v14 = *((_DWORD *)a1 + 9);
      }
      memmove(&v13[v9 + 1], &v13[v9], (v14 - v9));
      *(_BYTE *)(a1[5] + v9) = v7;
      v15 = *((_DWORD *)a1 + 9);
      v16 = v15 + 1;
      *((_DWORD *)a1 + 9) = v15 + 1;
      if (v7 < 0)
      {
        switch((v7 >> 1) & 7)
        {
          case 0u:
            v17 = v15 + 2;
            v18 = *((_DWORD *)a1 + 8);
            if (v17 <= v18)
            {
              v21 = (char *)a1[5];
              v22 = v16;
            }
            else
            {
              if (v18 <= 1)
                v18 = 1;
              v19 = 2 * v18;
              if (v19 <= (int)v17)
                v20 = v17;
              else
                v20 = v19;
              v21 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v20, "Vector Storage (uint8_t, growth)");
              memcpy(v21, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v20;
              a1[5] = v21;
              v22 = *((_DWORD *)a1 + 9);
            }
            memmove(&v21[v16 + 1], &v21[v16], v22 - v16);
            *(_BYTE *)(a1[5] + v16) = v6;
            v41 = 1;
            goto LABEL_48;
          case 1u:
            v23 = v15 + 3;
            v24 = *((_DWORD *)a1 + 8);
            if (v23 <= v24)
            {
              v27 = (char *)a1[5];
              v28 = v16;
            }
            else
            {
              if (v24 <= 1)
                v24 = 1;
              v25 = 2 * v24;
              if (v25 <= (int)v23)
                v26 = v23;
              else
                v26 = v25;
              v27 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v26, "Vector Storage (uint8_t, growth)");
              memcpy(v27, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v26;
              a1[5] = v27;
              v28 = *((_DWORD *)a1 + 9);
            }
            memmove(&v27[v16 + 1], &v27[v16], v28 - v16);
            *(_WORD *)(a1[5] + v16) = v6;
            v41 = 2;
            goto LABEL_48;
          case 2u:
            v29 = v15 + 4;
            v30 = *((_DWORD *)a1 + 8);
            if (v29 <= v30)
            {
              v33 = (char *)a1[5];
              v34 = v16;
            }
            else
            {
              if (v30 <= 1)
                v30 = 1;
              v31 = 2 * v30;
              if (v31 <= (int)v29)
                v32 = v29;
              else
                v32 = v31;
              v33 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v32, "Vector Storage (uint8_t, growth)");
              memcpy(v33, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v32;
              a1[5] = v33;
              v34 = *((_DWORD *)a1 + 9);
            }
            memmove(&v33[v16 + 1], &v33[v16], v34 - v16);
            v42 = a1[5] + v16;
            *(_BYTE *)(v42 + 2) = BYTE2(v6);
            *(_WORD *)v42 = v6;
            v41 = 3;
            goto LABEL_48;
          case 3u:
            v35 = v15 + 5;
            v36 = *((_DWORD *)a1 + 8);
            if (v35 <= v36)
            {
              v39 = (char *)a1[5];
              v40 = v16;
            }
            else
            {
              if (v36 <= 1)
                v36 = 1;
              v37 = 2 * v36;
              if (v37 <= (int)v35)
                v38 = v35;
              else
                v38 = v37;
              v39 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v38, "Vector Storage (uint8_t, growth)");
              memcpy(v39, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v38;
              a1[5] = v39;
              v40 = *((_DWORD *)a1 + 9);
            }
            memmove(&v39[v16 + 1], &v39[v16], v40 - v16);
            *(_DWORD *)(a1[5] + v16) = v6;
            v41 = 4;
LABEL_48:
            *((_DWORD *)a1 + 9) += v41;
            break;
          default:
            break;
        }
      }
      v43 = glpTypeGetKind(ReturnType);
      if (v43 != 4)
        break;
      ElementCount = glpAggregateTypeGetElementCount((uint64_t)ReturnType);
      v45 = ElementCount;
      v46 = glp_serialized_integer32_control(ElementCount);
      v47 = *((_DWORD *)a1 + 8);
      v48 = *((unsigned int *)a1 + 9);
      v49 = v48 + 1;
      if ((int)v48 + 1 <= v47)
      {
        v52 = (char *)a1[5];
        v53 = *((_DWORD *)a1 + 9);
      }
      else
      {
        if (v47 <= 1)
          v47 = 1;
        v50 = 2 * v47;
        if (v50 <= v49)
          v51 = v49;
        else
          v51 = v50;
        v52 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v51, "Vector Storage (uint8_t, growth)");
        memcpy(v52, (const void *)a1[5], *((unsigned int *)a1 + 9));
        ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
        *((_DWORD *)a1 + 8) = v51;
        a1[5] = v52;
        v53 = *((_DWORD *)a1 + 9);
      }
      memmove(&v52[v48 + 1], &v52[v48], (v53 - v48));
      *(_BYTE *)(a1[5] + v48) = v46;
      v54 = *((_DWORD *)a1 + 9);
      v55 = v54 + 1;
      *((_DWORD *)a1 + 9) = v54 + 1;
      if (v46 < 0)
      {
        switch((v46 >> 1) & 7)
        {
          case 0u:
            v56 = v54 + 2;
            v57 = *((_DWORD *)a1 + 8);
            if (v56 <= v57)
            {
              v60 = (char *)a1[5];
              v61 = v55;
            }
            else
            {
              if (v57 <= 1)
                v57 = 1;
              v58 = 2 * v57;
              if (v58 <= (int)v56)
                v59 = v56;
              else
                v59 = v58;
              v60 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v59, "Vector Storage (uint8_t, growth)");
              memcpy(v60, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v59;
              a1[5] = v60;
              v61 = *((_DWORD *)a1 + 9);
            }
            memmove(&v60[v55 + 1], &v60[v55], v61 - v55);
            *(_BYTE *)(a1[5] + v55) = v45;
            v80 = 1;
            goto LABEL_96;
          case 1u:
            v62 = v54 + 3;
            v63 = *((_DWORD *)a1 + 8);
            if (v62 <= v63)
            {
              v66 = (char *)a1[5];
              v67 = v55;
            }
            else
            {
              if (v63 <= 1)
                v63 = 1;
              v64 = 2 * v63;
              if (v64 <= (int)v62)
                v65 = v62;
              else
                v65 = v64;
              v66 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v65, "Vector Storage (uint8_t, growth)");
              memcpy(v66, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v65;
              a1[5] = v66;
              v67 = *((_DWORD *)a1 + 9);
            }
            memmove(&v66[v55 + 1], &v66[v55], v67 - v55);
            *(_WORD *)(a1[5] + v55) = v45;
            v80 = 2;
            goto LABEL_96;
          case 2u:
            v68 = v54 + 4;
            v69 = *((_DWORD *)a1 + 8);
            if (v68 <= v69)
            {
              v72 = (char *)a1[5];
              v73 = v55;
            }
            else
            {
              if (v69 <= 1)
                v69 = 1;
              v70 = 2 * v69;
              if (v70 <= (int)v68)
                v71 = v68;
              else
                v71 = v70;
              v72 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v71, "Vector Storage (uint8_t, growth)");
              memcpy(v72, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v71;
              a1[5] = v72;
              v73 = *((_DWORD *)a1 + 9);
            }
            memmove(&v72[v55 + 1], &v72[v55], v73 - v55);
            v81 = a1[5] + v55;
            *(_BYTE *)(v81 + 2) = BYTE2(v45);
            *(_WORD *)v81 = v45;
            v80 = 3;
            goto LABEL_96;
          case 3u:
            v74 = v54 + 5;
            v75 = *((_DWORD *)a1 + 8);
            if (v74 <= v75)
            {
              v78 = (char *)a1[5];
              v79 = v55;
            }
            else
            {
              if (v75 <= 1)
                v75 = 1;
              v76 = 2 * v75;
              if (v76 <= (int)v74)
                v77 = v74;
              else
                v77 = v76;
              v78 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v77, "Vector Storage (uint8_t, growth)");
              memcpy(v78, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v77;
              a1[5] = v78;
              v79 = *((_DWORD *)a1 + 9);
            }
            memmove(&v78[v55 + 1], &v78[v55], v79 - v55);
            *(_DWORD *)(a1[5] + v55) = v45;
            v80 = 4;
LABEL_96:
            *((_DWORD *)a1 + 9) += v80;
            break;
          default:
            break;
        }
      }
      if (v45)
      {
        for (i = 0; i != v45; ++i)
        {
          ElementType = glpAggregateTypeGetElementType((uint64_t)ReturnType, i);
          serialize_GLPType(a1, ElementType);
          ElementFlags = glpAggregateTypeGetElementFlags((uint64_t)ReturnType, i);
          v85 = glp_serialized_integer64_control(ElementFlags);
          v86 = *((_DWORD *)a1 + 8);
          v87 = *((unsigned int *)a1 + 9);
          v88 = v87 + 1;
          if ((int)v87 + 1 <= v86)
          {
            v91 = (char *)a1[5];
            v92 = *((_DWORD *)a1 + 9);
          }
          else
          {
            if (v86 <= 1)
              v86 = 1;
            v89 = 2 * v86;
            if (v89 <= v88)
              v90 = v88;
            else
              v90 = v89;
            v91 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v90, "Vector Storage (uint8_t, growth)");
            memcpy(v91, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v90;
            a1[5] = v91;
            v92 = *((_DWORD *)a1 + 9);
          }
          memmove(&v91[v87 + 1], &v91[v87], (v92 - v87));
          *(_BYTE *)(a1[5] + v87) = v85;
          ++*((_DWORD *)a1 + 9);
          if (v85 < 0)
            __asm { BR              X10 }
          ElementLayout = (unint64_t *)glpAggregateTypeGetElementLayout((uint64_t)ReturnType, i);
          serialize_GLPLayoutObject(a1, ElementLayout);
        }
      }
      ReturnType = (unsigned int *)glpFunctionTypeGetReturnType((uint64_t)ReturnType);
      result = serialize_pointer(a1, (unint64_t)ReturnType);
      if (!(_DWORD)result)
        return result;
    }
    switch(v43)
    {
      case 0:
        PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)ReturnType);
        v95 = PrimitiveType;
        v96 = (char)glp_serialized_integer32_control(PrimitiveType);
        v97 = *((_DWORD *)a1 + 8);
        v98 = *((unsigned int *)a1 + 9);
        v99 = v98 + 1;
        if ((int)v98 + 1 <= v97)
        {
          v102 = (char *)a1[5];
          v103 = *((_DWORD *)a1 + 9);
        }
        else
        {
          if (v97 <= 1)
            v97 = 1;
          v100 = 2 * v97;
          if (v100 <= v99)
            v101 = v99;
          else
            v101 = v100;
          v102 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v101, "Vector Storage (uint8_t, growth)");
          memcpy(v102, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v101;
          a1[5] = v102;
          v103 = *((_DWORD *)a1 + 9);
        }
        result = (uint64_t)memmove(&v102[v98 + 1], &v102[v98], (v103 - v98));
        *(_BYTE *)(a1[5] + v98) = v96;
        v139 = *((_DWORD *)a1 + 9);
        v140 = v139 + 1;
        *((_DWORD *)a1 + 9) = v139 + 1;
        if ((v96 & 0x80000000) != 0)
        {
          switch((v96 >> 1) & 7)
          {
            case 0u:
              goto LABEL_299;
            case 1u:
              goto LABEL_306;
            case 2u:
              goto LABEL_313;
            case 3u:
              goto LABEL_320;
            default:
              return result;
          }
        }
        break;
      case 1:
        v104 = glpAggregateTypeGetElementCount((uint64_t)ReturnType);
        v105 = v104;
        v106 = (char)glp_serialized_integer32_control(v104);
        v107 = *((_DWORD *)a1 + 8);
        v108 = *((unsigned int *)a1 + 9);
        v109 = v108 + 1;
        if ((int)v108 + 1 <= v107)
        {
          v112 = (char *)a1[5];
          v113 = *((_DWORD *)a1 + 9);
        }
        else
        {
          if (v107 <= 1)
            v107 = 1;
          v110 = 2 * v107;
          if (v110 <= v109)
            v111 = v109;
          else
            v111 = v110;
          v112 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v111, "Vector Storage (uint8_t, growth)");
          memcpy(v112, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v111;
          a1[5] = v112;
          v113 = *((_DWORD *)a1 + 9);
        }
        memmove(&v112[v108 + 1], &v112[v108], (v113 - v108));
        *(_BYTE *)(a1[5] + v108) = v106;
        v141 = *((_DWORD *)a1 + 9);
        v142 = v141 + 1;
        *((_DWORD *)a1 + 9) = v141 + 1;
        if ((v106 & 0x80000000) != 0)
        {
          switch((v106 >> 1) & 7)
          {
            case 0u:
              v143 = v141 + 2;
              v144 = *((_DWORD *)a1 + 8);
              if (v143 <= v144)
              {
                v147 = (char *)a1[5];
                v148 = v142;
              }
              else
              {
                if (v144 <= 1)
                  v144 = 1;
                v145 = 2 * v144;
                if (v145 <= (int)v143)
                  v146 = v143;
                else
                  v146 = v145;
                v147 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v146, "Vector Storage (uint8_t, growth)");
                memcpy(v147, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v146;
                a1[5] = v147;
                v148 = *((_DWORD *)a1 + 9);
              }
              memmove(&v147[v142 + 1], &v147[v142], v148 - v142);
              *(_BYTE *)(a1[5] + v142) = v105;
              v219 = 1;
              goto LABEL_250;
            case 1u:
              v165 = v141 + 3;
              v166 = *((_DWORD *)a1 + 8);
              if (v165 <= v166)
              {
                v169 = (char *)a1[5];
                v170 = v142;
              }
              else
              {
                if (v166 <= 1)
                  v166 = 1;
                v167 = 2 * v166;
                if (v167 <= (int)v165)
                  v168 = v165;
                else
                  v168 = v167;
                v169 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v168, "Vector Storage (uint8_t, growth)");
                memcpy(v169, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v168;
                a1[5] = v169;
                v170 = *((_DWORD *)a1 + 9);
              }
              memmove(&v169[v142 + 1], &v169[v142], v170 - v142);
              *(_WORD *)(a1[5] + v142) = v105;
              v219 = 2;
              goto LABEL_250;
            case 2u:
              v171 = v141 + 4;
              v172 = *((_DWORD *)a1 + 8);
              if (v171 <= v172)
              {
                v175 = (char *)a1[5];
                v176 = v142;
              }
              else
              {
                if (v172 <= 1)
                  v172 = 1;
                v173 = 2 * v172;
                if (v173 <= (int)v171)
                  v174 = v171;
                else
                  v174 = v173;
                v175 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v174, "Vector Storage (uint8_t, growth)");
                memcpy(v175, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v174;
                a1[5] = v175;
                v176 = *((_DWORD *)a1 + 9);
              }
              memmove(&v175[v142 + 1], &v175[v142], v176 - v142);
              v222 = a1[5] + v142;
              *(_BYTE *)(v222 + 2) = BYTE2(v105);
              *(_WORD *)v222 = v105;
              v219 = 3;
              goto LABEL_250;
            case 3u:
              v177 = v141 + 5;
              v178 = *((_DWORD *)a1 + 8);
              if (v177 <= v178)
              {
                v181 = (char *)a1[5];
                v182 = v142;
              }
              else
              {
                if (v178 <= 1)
                  v178 = 1;
                v179 = 2 * v178;
                if (v179 <= (int)v177)
                  v180 = v177;
                else
                  v180 = v179;
                v181 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v180, "Vector Storage (uint8_t, growth)");
                memcpy(v181, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v180;
                a1[5] = v181;
                v182 = *((_DWORD *)a1 + 9);
              }
              memmove(&v181[v142 + 1], &v181[v142], v182 - v142);
              *(_DWORD *)(a1[5] + v142) = v105;
              v219 = 4;
LABEL_250:
              *((_DWORD *)a1 + 9) += v219;
              break;
            default:
              break;
          }
        }
        if (v105)
        {
          for (j = 0; j != v105; ++j)
          {
            v224 = glpAggregateTypeGetElementType((uint64_t)ReturnType, j);
            serialize_GLPType(a1, v224);
            v225 = glpAggregateTypeGetElementFlags((uint64_t)ReturnType, j);
            v226 = glp_serialized_integer64_control(v225);
            v227 = *((_DWORD *)a1 + 8);
            v228 = *((unsigned int *)a1 + 9);
            v229 = v228 + 1;
            if ((int)v228 + 1 <= v227)
            {
              v232 = (char *)a1[5];
              v233 = *((_DWORD *)a1 + 9);
            }
            else
            {
              if (v227 <= 1)
                v227 = 1;
              v230 = 2 * v227;
              if (v230 <= v229)
                v231 = v229;
              else
                v231 = v230;
              v232 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v231, "Vector Storage (uint8_t, growth)");
              memcpy(v232, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v231;
              a1[5] = v232;
              v233 = *((_DWORD *)a1 + 9);
            }
            memmove(&v232[v228 + 1], &v232[v228], (v233 - v228));
            *(_BYTE *)(a1[5] + v228) = v226;
            ++*((_DWORD *)a1 + 9);
            if (v226 < 0)
              __asm { BR              X10 }
            v234 = (unint64_t *)glpAggregateTypeGetElementLayout((uint64_t)ReturnType, j);
            serialize_GLPLayoutObject(a1, v234);
            FieldName = (const char *)glpStructTypeGetFieldName((uint64_t)ReturnType, j);
            serialize_GLPString(a1, FieldName, v236);
          }
        }
        Name = (const char *)glpStructTypeGetName((uint64_t)ReturnType);
        result = serialize_GLPString(a1, Name, v238);
        break;
      case 2:
        v114 = glpArrayTypeGetElementType((uint64_t)ReturnType);
        serialize_GLPType(a1, v114);
        v115 = glpArrayTypeGetElementCount((uint64_t)ReturnType);
        v116 = v115;
        v117 = (char)glp_serialized_integer32_control(v115);
        v118 = *((_DWORD *)a1 + 8);
        v119 = *((unsigned int *)a1 + 9);
        v120 = v119 + 1;
        if ((int)v119 + 1 <= v118)
        {
          v123 = (char *)a1[5];
          v124 = *((_DWORD *)a1 + 9);
        }
        else
        {
          if (v118 <= 1)
            v118 = 1;
          v121 = 2 * v118;
          if (v121 <= v120)
            v122 = v120;
          else
            v122 = v121;
          v123 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v122, "Vector Storage (uint8_t, growth)");
          memcpy(v123, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v122;
          a1[5] = v123;
          v124 = *((_DWORD *)a1 + 9);
        }
        memmove(&v123[v119 + 1], &v123[v119], (v124 - v119));
        *(_BYTE *)(a1[5] + v119) = v117;
        v149 = *((_DWORD *)a1 + 9);
        v150 = v149 + 1;
        *((_DWORD *)a1 + 9) = v149 + 1;
        if ((v117 & 0x80000000) != 0)
        {
          switch((v117 >> 1) & 7)
          {
            case 0u:
              v151 = v149 + 2;
              v152 = *((_DWORD *)a1 + 8);
              if (v151 <= v152)
              {
                v155 = (char *)a1[5];
                v156 = v150;
              }
              else
              {
                if (v152 <= 1)
                  v152 = 1;
                v153 = 2 * v152;
                if (v153 <= (int)v151)
                  v154 = v151;
                else
                  v154 = v153;
                v155 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v154, "Vector Storage (uint8_t, growth)");
                memcpy(v155, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v154;
                a1[5] = v155;
                v156 = *((_DWORD *)a1 + 9);
              }
              memmove(&v155[v150 + 1], &v155[v150], v156 - v150);
              *(_BYTE *)(a1[5] + v150) = v116;
              v220 = 1;
              goto LABEL_271;
            case 1u:
              v183 = v149 + 3;
              v184 = *((_DWORD *)a1 + 8);
              if (v183 <= v184)
              {
                v187 = (char *)a1[5];
                v188 = v150;
              }
              else
              {
                if (v184 <= 1)
                  v184 = 1;
                v185 = 2 * v184;
                if (v185 <= (int)v183)
                  v186 = v183;
                else
                  v186 = v185;
                v187 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v186, "Vector Storage (uint8_t, growth)");
                memcpy(v187, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v186;
                a1[5] = v187;
                v188 = *((_DWORD *)a1 + 9);
              }
              memmove(&v187[v150 + 1], &v187[v150], v188 - v150);
              *(_WORD *)(a1[5] + v150) = v116;
              v220 = 2;
              goto LABEL_271;
            case 2u:
              v189 = v149 + 4;
              v190 = *((_DWORD *)a1 + 8);
              if (v189 <= v190)
              {
                v193 = (char *)a1[5];
                v194 = v150;
              }
              else
              {
                if (v190 <= 1)
                  v190 = 1;
                v191 = 2 * v190;
                if (v191 <= (int)v189)
                  v192 = v189;
                else
                  v192 = v191;
                v193 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v192, "Vector Storage (uint8_t, growth)");
                memcpy(v193, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v192;
                a1[5] = v193;
                v194 = *((_DWORD *)a1 + 9);
              }
              memmove(&v193[v150 + 1], &v193[v150], v194 - v150);
              v239 = a1[5] + v150;
              *(_BYTE *)(v239 + 2) = BYTE2(v116);
              *(_WORD *)v239 = v116;
              v220 = 3;
              goto LABEL_271;
            case 3u:
              v195 = v149 + 5;
              v196 = *((_DWORD *)a1 + 8);
              if (v195 <= v196)
              {
                v199 = (char *)a1[5];
                v200 = v150;
              }
              else
              {
                if (v196 <= 1)
                  v196 = 1;
                v197 = 2 * v196;
                if (v197 <= (int)v195)
                  v198 = v195;
                else
                  v198 = v197;
                v199 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v198, "Vector Storage (uint8_t, growth)");
                memcpy(v199, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v198;
                a1[5] = v199;
                v200 = *((_DWORD *)a1 + 9);
              }
              memmove(&v199[v150 + 1], &v199[v150], v200 - v150);
              *(_DWORD *)(a1[5] + v150) = v116;
              v220 = 4;
LABEL_271:
              *((_DWORD *)a1 + 9) += v220;
              break;
            default:
              break;
          }
        }
        MaxElementCount = glpArrayTypeGetMaxElementCount((uint64_t)ReturnType);
        v95 = MaxElementCount;
        v241 = (char)glp_serialized_integer32_control(MaxElementCount);
        v242 = *((_DWORD *)a1 + 8);
        v243 = *((unsigned int *)a1 + 9);
        v244 = v243 + 1;
        if ((int)v243 + 1 <= v242)
        {
          v247 = (char *)a1[5];
          v248 = *((_DWORD *)a1 + 9);
        }
        else
        {
          if (v242 <= 1)
            v242 = 1;
          v245 = 2 * v242;
          if (v245 <= v244)
            v246 = v244;
          else
            v246 = v245;
          v247 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v246, "Vector Storage (uint8_t, growth)");
          memcpy(v247, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v246;
          a1[5] = v247;
          v248 = *((_DWORD *)a1 + 9);
        }
        result = (uint64_t)memmove(&v247[v243 + 1], &v247[v243], (v248 - v243));
        *(_BYTE *)(a1[5] + v243) = v241;
        v139 = *((_DWORD *)a1 + 9);
        v140 = v139 + 1;
        *((_DWORD *)a1 + 9) = v139 + 1;
        if ((v241 & 0x80000000) != 0)
        {
          switch((v241 >> 1) & 7)
          {
            case 0u:
              goto LABEL_299;
            case 1u:
              goto LABEL_306;
            case 2u:
              goto LABEL_313;
            case 3u:
              goto LABEL_320;
            default:
              return result;
          }
        }
        break;
      case 3:
        v125 = glpBankTypeGetElementType((uint64_t)ReturnType);
        serialize_GLPType(a1, v125);
        v126 = glpBankTypeGetElementCount((uint64_t)ReturnType);
        v127 = v126;
        v128 = (char)glp_serialized_integer32_control(v126);
        v129 = *((_DWORD *)a1 + 8);
        v130 = *((unsigned int *)a1 + 9);
        v131 = v130 + 1;
        if ((int)v130 + 1 <= v129)
        {
          v134 = (char *)a1[5];
          v135 = *((_DWORD *)a1 + 9);
        }
        else
        {
          if (v129 <= 1)
            v129 = 1;
          v132 = 2 * v129;
          if (v132 <= v131)
            v133 = v131;
          else
            v133 = v132;
          v134 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v133, "Vector Storage (uint8_t, growth)");
          memcpy(v134, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v133;
          a1[5] = v134;
          v135 = *((_DWORD *)a1 + 9);
        }
        memmove(&v134[v130 + 1], &v134[v130], (v135 - v130));
        *(_BYTE *)(a1[5] + v130) = v128;
        v157 = *((_DWORD *)a1 + 9);
        v158 = v157 + 1;
        *((_DWORD *)a1 + 9) = v157 + 1;
        if ((v128 & 0x80000000) != 0)
        {
          switch((v128 >> 1) & 7)
          {
            case 0u:
              v159 = v157 + 2;
              v160 = *((_DWORD *)a1 + 8);
              if (v159 <= v160)
              {
                v163 = (char *)a1[5];
                v164 = v158;
              }
              else
              {
                if (v160 <= 1)
                  v160 = 1;
                v161 = 2 * v160;
                if (v161 <= (int)v159)
                  v162 = v159;
                else
                  v162 = v161;
                v163 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v162, "Vector Storage (uint8_t, growth)");
                memcpy(v163, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v162;
                a1[5] = v163;
                v164 = *((_DWORD *)a1 + 9);
              }
              memmove(&v163[v158 + 1], &v163[v158], v164 - v158);
              *(_BYTE *)(a1[5] + v158) = v127;
              v221 = 1;
              goto LABEL_288;
            case 1u:
              v201 = v157 + 3;
              v202 = *((_DWORD *)a1 + 8);
              if (v201 <= v202)
              {
                v205 = (char *)a1[5];
                v206 = v158;
              }
              else
              {
                if (v202 <= 1)
                  v202 = 1;
                v203 = 2 * v202;
                if (v203 <= (int)v201)
                  v204 = v201;
                else
                  v204 = v203;
                v205 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v204, "Vector Storage (uint8_t, growth)");
                memcpy(v205, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v204;
                a1[5] = v205;
                v206 = *((_DWORD *)a1 + 9);
              }
              memmove(&v205[v158 + 1], &v205[v158], v206 - v158);
              *(_WORD *)(a1[5] + v158) = v127;
              v221 = 2;
              goto LABEL_288;
            case 2u:
              v207 = v157 + 4;
              v208 = *((_DWORD *)a1 + 8);
              if (v207 <= v208)
              {
                v211 = (char *)a1[5];
                v212 = v158;
              }
              else
              {
                if (v208 <= 1)
                  v208 = 1;
                v209 = 2 * v208;
                if (v209 <= (int)v207)
                  v210 = v207;
                else
                  v210 = v209;
                v211 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v210, "Vector Storage (uint8_t, growth)");
                memcpy(v211, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v210;
                a1[5] = v211;
                v212 = *((_DWORD *)a1 + 9);
              }
              memmove(&v211[v158 + 1], &v211[v158], v212 - v158);
              v249 = a1[5] + v158;
              *(_BYTE *)(v249 + 2) = BYTE2(v127);
              *(_WORD *)v249 = v127;
              v221 = 3;
              goto LABEL_288;
            case 3u:
              v213 = v157 + 5;
              v214 = *((_DWORD *)a1 + 8);
              if (v213 <= v214)
              {
                v217 = (char *)a1[5];
                v218 = v158;
              }
              else
              {
                if (v214 <= 1)
                  v214 = 1;
                v215 = 2 * v214;
                if (v215 <= (int)v213)
                  v216 = v213;
                else
                  v216 = v215;
                v217 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v216, "Vector Storage (uint8_t, growth)");
                memcpy(v217, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v216;
                a1[5] = v217;
                v218 = *((_DWORD *)a1 + 9);
              }
              memmove(&v217[v158 + 1], &v217[v158], v218 - v158);
              *(_DWORD *)(a1[5] + v158) = v127;
              v221 = 4;
LABEL_288:
              *((_DWORD *)a1 + 9) += v221;
              break;
            default:
              break;
          }
        }
        Bank = glpBankTypeGetBank((uint64_t)ReturnType);
        v95 = Bank;
        v251 = (char)glp_serialized_integer32_control(Bank);
        v252 = *((_DWORD *)a1 + 8);
        v253 = *((unsigned int *)a1 + 9);
        v254 = v253 + 1;
        if ((int)v253 + 1 <= v252)
        {
          v257 = (char *)a1[5];
          v258 = *((_DWORD *)a1 + 9);
        }
        else
        {
          if (v252 <= 1)
            v252 = 1;
          v255 = 2 * v252;
          if (v255 <= v254)
            v256 = v254;
          else
            v256 = v255;
          v257 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v256, "Vector Storage (uint8_t, growth)");
          memcpy(v257, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v256;
          a1[5] = v257;
          v258 = *((_DWORD *)a1 + 9);
        }
        result = (uint64_t)memmove(&v257[v253 + 1], &v257[v253], (v258 - v253));
        *(_BYTE *)(a1[5] + v253) = v251;
        v139 = *((_DWORD *)a1 + 9);
        v140 = v139 + 1;
        *((_DWORD *)a1 + 9) = v139 + 1;
        if ((v251 & 0x80000000) != 0)
        {
          switch((v251 >> 1) & 7)
          {
            case 0u:
LABEL_299:
              v259 = v139 + 2;
              v260 = *((_DWORD *)a1 + 8);
              if (v259 <= v260)
              {
                v263 = (char *)a1[5];
                v264 = v140;
              }
              else
              {
                if (v260 <= 1)
                  v260 = 1;
                v261 = 2 * v260;
                if (v261 <= (int)v259)
                  v262 = v259;
                else
                  v262 = v261;
                v263 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v262, "Vector Storage (uint8_t, growth)");
                memcpy(v263, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v262;
                a1[5] = v263;
                v264 = *((_DWORD *)a1 + 9);
              }
              result = (uint64_t)memmove(&v263[v140 + 1], &v263[v140], v264 - v140);
              *(_BYTE *)(a1[5] + v140) = v95;
              v283 = *((_DWORD *)a1 + 9) + 1;
              goto LABEL_335;
            case 1u:
LABEL_306:
              v265 = v139 + 3;
              v266 = *((_DWORD *)a1 + 8);
              if (v265 <= v266)
              {
                v269 = (char *)a1[5];
                v270 = v140;
              }
              else
              {
                if (v266 <= 1)
                  v266 = 1;
                v267 = 2 * v266;
                if (v267 <= (int)v265)
                  v268 = v265;
                else
                  v268 = v267;
                v269 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v268, "Vector Storage (uint8_t, growth)");
                memcpy(v269, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v268;
                a1[5] = v269;
                v270 = *((_DWORD *)a1 + 9);
              }
              result = (uint64_t)memmove(&v269[v140 + 1], &v269[v140], v270 - v140);
              *(_WORD *)(a1[5] + v140) = v95;
              v283 = *((_DWORD *)a1 + 9) + 2;
              goto LABEL_335;
            case 2u:
LABEL_313:
              v271 = v139 + 4;
              v272 = *((_DWORD *)a1 + 8);
              if (v271 <= v272)
              {
                v275 = (char *)a1[5];
                v276 = v140;
              }
              else
              {
                if (v272 <= 1)
                  v272 = 1;
                v273 = 2 * v272;
                if (v273 <= (int)v271)
                  v274 = v271;
                else
                  v274 = v273;
                v275 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v274, "Vector Storage (uint8_t, growth)");
                memcpy(v275, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v274;
                a1[5] = v275;
                v276 = *((_DWORD *)a1 + 9);
              }
              result = (uint64_t)memmove(&v275[v140 + 1], &v275[v140], v276 - v140);
              v284 = a1[5] + v140;
              *(_BYTE *)(v284 + 2) = BYTE2(v95);
              *(_WORD *)v284 = v95;
              v283 = *((_DWORD *)a1 + 9) + 3;
              goto LABEL_335;
            case 3u:
LABEL_320:
              v277 = v139 + 5;
              v278 = *((_DWORD *)a1 + 8);
              if (v277 <= v278)
              {
                v281 = (char *)a1[5];
                v282 = v140;
              }
              else
              {
                if (v278 <= 1)
                  v278 = 1;
                v279 = 2 * v278;
                if (v279 <= (int)v277)
                  v280 = v277;
                else
                  v280 = v279;
                v281 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v280, "Vector Storage (uint8_t, growth)");
                memcpy(v281, (const void *)a1[5], *((unsigned int *)a1 + 9));
                ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                *((_DWORD *)a1 + 8) = v280;
                a1[5] = v281;
                v282 = *((_DWORD *)a1 + 9);
              }
              result = (uint64_t)memmove(&v281[v140 + 1], &v281[v140], v282 - v140);
              *(_DWORD *)(a1[5] + v140) = v95;
              v283 = *((_DWORD *)a1 + 9) + 4;
LABEL_335:
              *((_DWORD *)a1 + 9) = v283;
              break;
            default:
              return result;
          }
        }
        break;
      case 5:
        v136 = (const char *)glpSubroutineTypeGetName((uint64_t)ReturnType);
        serialize_GLPString(a1, v136, v137);
        FunctionObject = glpSubroutineTypeGetFunctionObject((uint64_t)ReturnType);
        result = serialize_GLPFunctionObject(a1, FunctionObject);
        break;
      default:
        abort();
    }
  }
  return result;
}

uint64_t serialize_GLPLayoutObject(_QWORD *a1, unint64_t *a2)
{
  uint64_t result;

  result = serialize_pointer(a1, (unint64_t)a2);
  if ((_DWORD)result)
  {
    serialize_GLPLayoutPair(a1, *a2);
    return serialize_GLPLayoutPair(a1, a2[1]);
  }
  return result;
}

uint64_t serialize_GLPFunctionObject(_QWORD *a1, unint64_t a2)
{
  uint64_t result;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  char *v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  char *v20;
  int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  int v26;
  uint64_t v27;
  char *v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  int v32;
  uint64_t v33;
  char *v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  int v38;
  uint64_t v39;
  char *v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  int v44;
  uint64_t v45;
  char *v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  int v52;
  uint64_t v53;
  int v54;
  int v55;
  uint64_t v56;
  char *v57;
  int v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  int v62;
  int v63;
  uint64_t v64;
  char *v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  int v69;
  uint64_t v70;
  char *v71;
  unsigned int v72;
  unsigned int v73;
  int v74;
  int v75;
  uint64_t v76;
  char *v77;
  unsigned int v78;
  unsigned int v79;
  int v80;
  int v81;
  uint64_t v82;
  char *v83;
  unsigned int v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  unsigned int v89;
  unsigned int v90;
  int v91;
  uint64_t v92;
  int v93;
  int v94;
  uint64_t v95;
  char *v96;
  int v97;
  int v98;
  unsigned int v99;
  unsigned int v100;
  int v101;
  int v102;
  uint64_t v103;
  char *v104;
  unsigned int v105;
  unsigned int v106;
  int v107;
  int v108;
  uint64_t v109;
  char *v110;
  unsigned int v111;
  unsigned int v112;
  int v113;
  int v114;
  uint64_t v115;
  char *v116;
  unsigned int v117;
  unsigned int v118;
  int v119;
  int v120;
  uint64_t v121;
  char *v122;
  unsigned int v123;
  uint64_t v124;
  int v125;
  unint64_t v126;

  result = serialize_pointer(a1, a2);
  if ((_DWORD)result)
  {
    serialize_GLPType(a1, *(_QWORD *)a2);
    v5 = (char)glp_serialized_integer64_control(*(_QWORD *)(a2 + 8));
    v6 = *((_DWORD *)a1 + 8);
    v7 = *((unsigned int *)a1 + 9);
    v8 = v7 + 1;
    if ((int)v7 + 1 <= v6)
    {
      v11 = (char *)a1[5];
      v12 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v6 <= 1)
        v6 = 1;
      v9 = 2 * v6;
      if (v9 <= v8)
        v10 = v8;
      else
        v10 = v9;
      v11 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v10, "Vector Storage (uint8_t, growth)");
      memcpy(v11, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v10;
      a1[5] = v11;
      v12 = *((_DWORD *)a1 + 9);
    }
    memmove(&v11[v7 + 1], &v11[v7], (v12 - v7));
    *(_BYTE *)(a1[5] + v7) = v5;
    ++*((_DWORD *)a1 + 9);
    if (v5 < 0)
      __asm { BR              X11 }
    if ((*(_BYTE *)(a2 + 9) & 0x40) != 0)
    {
      v13 = *(_DWORD *)(a2 + 92);
      v14 = (char)glp_serialized_integer32_control(v13);
      v15 = *((_DWORD *)a1 + 8);
      v16 = *((unsigned int *)a1 + 9);
      v17 = v16 + 1;
      if ((int)v16 + 1 <= v15)
      {
        v20 = (char *)a1[5];
        v21 = *((_DWORD *)a1 + 9);
      }
      else
      {
        if (v15 <= 1)
          v15 = 1;
        v18 = 2 * v15;
        if (v18 <= v17)
          v19 = v17;
        else
          v19 = v18;
        v20 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v19, "Vector Storage (uint8_t, growth)");
        memcpy(v20, (const void *)a1[5], *((unsigned int *)a1 + 9));
        ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
        *((_DWORD *)a1 + 8) = v19;
        a1[5] = v20;
        v21 = *((_DWORD *)a1 + 9);
      }
      memmove(&v20[v16 + 1], &v20[v16], (v21 - v16));
      *(_BYTE *)(a1[5] + v16) = v14;
      v22 = *((_DWORD *)a1 + 9);
      v23 = v22 + 1;
      *((_DWORD *)a1 + 9) = v22 + 1;
      if ((v14 & 0x80000000) != 0)
      {
        switch((v14 >> 1) & 7)
        {
          case 0u:
            v24 = v22 + 2;
            v25 = *((_DWORD *)a1 + 8);
            if (v24 <= v25)
            {
              v28 = (char *)a1[5];
              v29 = v23;
            }
            else
            {
              if (v25 <= 1)
                v25 = 1;
              v26 = 2 * v25;
              if (v26 <= (int)v24)
                v27 = v24;
              else
                v27 = v26;
              v28 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v27, "Vector Storage (uint8_t, growth)");
              memcpy(v28, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v27;
              a1[5] = v28;
              v29 = *((_DWORD *)a1 + 9);
            }
            memmove(&v28[v23 + 1], &v28[v23], v29 - v23);
            *(_BYTE *)(a1[5] + v23) = v13;
            v48 = 1;
            goto LABEL_59;
          case 1u:
            v42 = v22 + 3;
            v43 = *((_DWORD *)a1 + 8);
            if (v42 <= v43)
            {
              v46 = (char *)a1[5];
              v47 = v23;
            }
            else
            {
              if (v43 <= 1)
                v43 = 1;
              v44 = 2 * v43;
              if (v44 <= (int)v42)
                v45 = v42;
              else
                v45 = v44;
              v46 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v45, "Vector Storage (uint8_t, growth)");
              memcpy(v46, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v45;
              a1[5] = v46;
              v47 = *((_DWORD *)a1 + 9);
            }
            memmove(&v46[v23 + 1], &v46[v23], v47 - v23);
            *(_WORD *)(a1[5] + v23) = v13;
            v48 = 2;
            goto LABEL_59;
          case 2u:
            v30 = v22 + 4;
            v31 = *((_DWORD *)a1 + 8);
            if (v30 <= v31)
            {
              v34 = (char *)a1[5];
              v35 = v23;
            }
            else
            {
              if (v31 <= 1)
                v31 = 1;
              v32 = 2 * v31;
              if (v32 <= (int)v30)
                v33 = v30;
              else
                v33 = v32;
              v34 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v33, "Vector Storage (uint8_t, growth)");
              memcpy(v34, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v33;
              a1[5] = v34;
              v35 = *((_DWORD *)a1 + 9);
            }
            memmove(&v34[v23 + 1], &v34[v23], v35 - v23);
            v49 = a1[5] + v23;
            *(_BYTE *)(v49 + 2) = BYTE2(v13);
            *(_WORD *)v49 = v13;
            v48 = 3;
            goto LABEL_59;
          case 3u:
            v36 = v22 + 5;
            v37 = *((_DWORD *)a1 + 8);
            if (v36 <= v37)
            {
              v40 = (char *)a1[5];
              v41 = v23;
            }
            else
            {
              if (v37 <= 1)
                v37 = 1;
              v38 = 2 * v37;
              if (v38 <= (int)v36)
                v39 = v36;
              else
                v39 = v38;
              v40 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v39, "Vector Storage (uint8_t, growth)");
              memcpy(v40, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v39;
              a1[5] = v40;
              v41 = *((_DWORD *)a1 + 9);
            }
            memmove(&v40[v23 + 1], &v40[v23], v41 - v23);
            *(_DWORD *)(a1[5] + v23) = v13;
            v48 = 4;
LABEL_59:
            *((_DWORD *)a1 + 9) += v48;
            break;
          default:
            break;
        }
      }
    }
    serialize_GLPString(a1, *(const char **)(a2 + 24), *(_QWORD *)(a2 + 32));
    serialize_GLPString(a1, *(const char **)(a2 + 40), *(_QWORD *)(a2 + 48));
    serialize_GLPASTNode(a1, *(_QWORD *)(a2 + 56));
    serialize_GLPASTNode(a1, *(_QWORD *)(a2 + 64));
    v50 = *(unsigned int *)(a2 + 88);
    v51 = (char)glp_serialized_integer32_control(v50);
    v52 = *((_DWORD *)a1 + 8);
    v53 = *((unsigned int *)a1 + 9);
    v54 = v53 + 1;
    if ((int)v53 + 1 <= v52)
    {
      v57 = (char *)a1[5];
      v58 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v52 <= 1)
        v52 = 1;
      v55 = 2 * v52;
      if (v55 <= v54)
        v56 = v54;
      else
        v56 = v55;
      v57 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v56, "Vector Storage (uint8_t, growth)");
      memcpy(v57, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v56;
      a1[5] = v57;
      v58 = *((_DWORD *)a1 + 9);
    }
    memmove(&v57[v53 + 1], &v57[v53], (v58 - v53));
    *(_BYTE *)(a1[5] + v53) = v51;
    v59 = *((_DWORD *)a1 + 9);
    v60 = v59 + 1;
    *((_DWORD *)a1 + 9) = v59 + 1;
    if ((v51 & 0x80000000) != 0)
    {
      switch((v51 >> 1) & 7)
      {
        case 0u:
          v61 = v59 + 2;
          v62 = *((_DWORD *)a1 + 8);
          if (v61 <= v62)
          {
            v65 = (char *)a1[5];
            v66 = v60;
          }
          else
          {
            if (v62 <= 1)
              v62 = 1;
            v63 = 2 * v62;
            if (v63 <= (int)v61)
              v64 = v61;
            else
              v64 = v63;
            v65 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v64, "Vector Storage (uint8_t, growth)");
            memcpy(v65, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v64;
            a1[5] = v65;
            v66 = *((_DWORD *)a1 + 9);
          }
          memmove(&v65[v60 + 1], &v65[v60], v66 - v60);
          *(_BYTE *)(a1[5] + v60) = v50;
          v86 = 1;
          goto LABEL_106;
        case 1u:
          v79 = v59 + 3;
          v80 = *((_DWORD *)a1 + 8);
          if (v79 <= v80)
          {
            v83 = (char *)a1[5];
            v84 = v60;
          }
          else
          {
            if (v80 <= 1)
              v80 = 1;
            v81 = 2 * v80;
            if (v81 <= (int)v79)
              v82 = v79;
            else
              v82 = v81;
            v83 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v82, "Vector Storage (uint8_t, growth)");
            memcpy(v83, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v82;
            a1[5] = v83;
            v84 = *((_DWORD *)a1 + 9);
          }
          memmove(&v83[v60 + 1], &v83[v60], v84 - v60);
          *(_WORD *)(a1[5] + v60) = v50;
          v86 = 2;
          goto LABEL_106;
        case 2u:
          v67 = v59 + 4;
          v68 = *((_DWORD *)a1 + 8);
          if (v67 <= v68)
          {
            v71 = (char *)a1[5];
            v72 = v60;
          }
          else
          {
            if (v68 <= 1)
              v68 = 1;
            v69 = 2 * v68;
            if (v69 <= (int)v67)
              v70 = v67;
            else
              v70 = v69;
            v71 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v70, "Vector Storage (uint8_t, growth)");
            memcpy(v71, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v70;
            a1[5] = v71;
            v72 = *((_DWORD *)a1 + 9);
          }
          memmove(&v71[v60 + 1], &v71[v60], v72 - v60);
          v85 = a1[5] + v60;
          *(_BYTE *)(v85 + 2) = BYTE2(v50);
          *(_WORD *)v85 = v50;
          v86 = 3;
          goto LABEL_106;
        case 3u:
          v73 = v59 + 5;
          v74 = *((_DWORD *)a1 + 8);
          if (v73 <= v74)
          {
            v77 = (char *)a1[5];
            v78 = v60;
          }
          else
          {
            if (v74 <= 1)
              v74 = 1;
            v75 = 2 * v74;
            if (v75 <= (int)v73)
              v76 = v73;
            else
              v76 = v75;
            v77 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v76, "Vector Storage (uint8_t, growth)");
            memcpy(v77, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v76;
            a1[5] = v77;
            v78 = *((_DWORD *)a1 + 9);
          }
          memmove(&v77[v60 + 1], &v77[v60], v78 - v60);
          *(_DWORD *)(a1[5] + v60) = v50;
          v86 = 4;
LABEL_106:
          *((_DWORD *)a1 + 9) += v86;
          break;
        default:
          break;
      }
    }
    serialize_GLPVariableObject(a1, *(_QWORD *)(a2 + 72));
    if ((_DWORD)v50)
    {
      v87 = 0;
      v88 = 8 * v50;
      do
      {
        serialize_GLPVariableObject(a1, *(_QWORD *)(*(_QWORD *)(a2 + 80) + v87));
        v87 += 8;
      }
      while (v88 != v87);
    }
    v89 = *(_DWORD *)(a2 + 96);
    v90 = (char)glp_serialized_integer32_control(v89);
    v91 = *((_DWORD *)a1 + 8);
    v92 = *((unsigned int *)a1 + 9);
    v93 = v92 + 1;
    if ((int)v92 + 1 <= v91)
    {
      v96 = (char *)a1[5];
      v97 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v91 <= 1)
        v91 = 1;
      v94 = 2 * v91;
      if (v94 <= v93)
        v95 = v93;
      else
        v95 = v94;
      v96 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v95, "Vector Storage (uint8_t, growth)");
      memcpy(v96, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v95;
      a1[5] = v96;
      v97 = *((_DWORD *)a1 + 9);
    }
    result = (uint64_t)memmove(&v96[v92 + 1], &v96[v92], (v97 - v92));
    *(_BYTE *)(a1[5] + v92) = v90;
    v98 = *((_DWORD *)a1 + 9);
    v99 = v98 + 1;
    *((_DWORD *)a1 + 9) = v98 + 1;
    if ((v90 & 0x80000000) != 0)
    {
      switch((v90 >> 1) & 7)
      {
        case 0u:
          v100 = v98 + 2;
          v101 = *((_DWORD *)a1 + 8);
          if (v100 <= v101)
          {
            v104 = (char *)a1[5];
            v105 = v99;
          }
          else
          {
            if (v101 <= 1)
              v101 = 1;
            v102 = 2 * v101;
            if (v102 <= (int)v100)
              v103 = v100;
            else
              v103 = v102;
            v104 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v103, "Vector Storage (uint8_t, growth)");
            memcpy(v104, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v103;
            a1[5] = v104;
            v105 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v104[v99 + 1], &v104[v99], v105 - v99);
          *(_BYTE *)(a1[5] + v99) = v89;
          v125 = 1;
          goto LABEL_156;
        case 1u:
          v118 = v98 + 3;
          v119 = *((_DWORD *)a1 + 8);
          if (v118 <= v119)
          {
            v122 = (char *)a1[5];
            v123 = v99;
          }
          else
          {
            if (v119 <= 1)
              v119 = 1;
            v120 = 2 * v119;
            if (v120 <= (int)v118)
              v121 = v118;
            else
              v121 = v120;
            v122 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v121, "Vector Storage (uint8_t, growth)");
            memcpy(v122, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v121;
            a1[5] = v122;
            v123 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v122[v99 + 1], &v122[v99], v123 - v99);
          *(_WORD *)(a1[5] + v99) = v89;
          v125 = 2;
          goto LABEL_156;
        case 2u:
          v106 = v98 + 4;
          v107 = *((_DWORD *)a1 + 8);
          if (v106 <= v107)
          {
            v110 = (char *)a1[5];
            v111 = v99;
          }
          else
          {
            if (v107 <= 1)
              v107 = 1;
            v108 = 2 * v107;
            if (v108 <= (int)v106)
              v109 = v106;
            else
              v109 = v108;
            v110 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v109, "Vector Storage (uint8_t, growth)");
            memcpy(v110, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v109;
            a1[5] = v110;
            v111 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v110[v99 + 1], &v110[v99], v111 - v99);
          v124 = a1[5] + v99;
          *(_BYTE *)(v124 + 2) = BYTE2(v89);
          *(_WORD *)v124 = v89;
          v125 = 3;
          goto LABEL_156;
        case 3u:
          v112 = v98 + 5;
          v113 = *((_DWORD *)a1 + 8);
          if (v112 <= v113)
          {
            v116 = (char *)a1[5];
            v117 = v99;
          }
          else
          {
            if (v113 <= 1)
              v113 = 1;
            v114 = 2 * v113;
            if (v114 <= (int)v112)
              v115 = v112;
            else
              v115 = v114;
            v116 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v115, "Vector Storage (uint8_t, growth)");
            memcpy(v116, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v115;
            a1[5] = v116;
            v117 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v116[v99 + 1], &v116[v99], v117 - v99);
          *(_DWORD *)(a1[5] + v99) = v89;
          v125 = 4;
LABEL_156:
          *((_DWORD *)a1 + 9) += v125;
          break;
        default:
          break;
      }
    }
    if (*(_DWORD *)(a2 + 96))
    {
      v126 = 0;
      do
        result = serialize_GLPType(a1, *(_QWORD *)(*(_QWORD *)(a2 + 104) + 8 * v126++));
      while (v126 < *(unsigned int *)(a2 + 96));
    }
  }
  return result;
}

uint64_t real_serialize_GLPValue(_QWORD *a1, unint64_t a2, unsigned int *a3)
{
  unint64_t v4;
  uint64_t result;
  unsigned int v7;
  uint64_t Size;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  int ScalarType;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  BOOL v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  char *v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  char v27;
  int v28;
  uint64_t v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  int v34;
  int v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  int v39;
  uint64_t v40;
  char *v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  int v45;
  uint64_t v46;
  char *v47;
  unsigned int v48;
  unsigned int v49;
  int v50;
  int v51;
  uint64_t v52;
  char *v53;
  unsigned int v54;
  unsigned int v55;
  int v56;
  int v57;
  uint64_t v58;
  char *v59;
  unsigned int v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  int v69;
  uint64_t v70;
  char *v71;
  unsigned int v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  char v76;
  int v77;
  uint64_t v78;
  int v79;
  int v80;
  uint64_t v81;
  char *v82;
  int v83;
  int v84;
  unsigned int v85;
  unsigned int v86;
  int v87;
  int v88;
  uint64_t v89;
  char *v90;
  unsigned int v91;
  unsigned int v92;
  int v93;
  int v94;
  uint64_t v95;
  char *v96;
  unsigned int v97;
  unsigned int v98;
  int v99;
  int v100;
  uint64_t v101;
  char *v102;
  unsigned int v103;
  unsigned int v104;
  int v105;
  int v106;
  uint64_t v107;
  char *v108;
  unsigned int v109;
  int v110;
  uint64_t v111;
  uint64_t v112;
  unsigned int v113;
  uint64_t v114;
  int v115;
  int v116;
  int v117;
  int v118;
  uint64_t v119;
  char *v120;
  unsigned int v121;
  uint64_t v122;
  uint64_t v123;
  char *v124;
  uint64_t v125;

  v4 = a2;
  v125 = *MEMORY[0x24BDAC8D0];
  result = serialize_pointer(a1, a2);
  if ((_DWORD)result)
  {
    v7 = glpABIGetTypeSize(0, (uint64_t)a3, 0);
    Size = glpTypeSizeGetSize(v7);
    v9 = Size;
    v122 = (uint64_t)&v122;
    MEMORY[0x24BDAC7A8](Size);
    v124 = (char *)&v122 - v10;
    result = glpTypeGetAppleVec4Types(a3, (uint64_t *)((char *)&v122 - v10), 1, 0, 0, 0, 0, 0, 0);
    if (v9)
    {
      v11 = 0;
      v123 = v9;
      do
      {
        v12 = v124;
        ScalarType = glpPrimitiveTypeGetScalarType(*(unsigned int *)&v124[4 * v11]);
        result = glpPrimitiveTypeGetScalarCount(*(unsigned int *)&v12[4 * v11]);
        if (ScalarType <= 8)
        {
          if (ScalarType == 1)
          {
            if ((_DWORD)result)
            {
              v112 = 0;
              v113 = *((_DWORD *)a1 + 9);
              v114 = 4 * result;
              do
              {
                v115 = *(_DWORD *)(v4 + v112);
                v116 = v113 + 4;
                v117 = *((_DWORD *)a1 + 8);
                if (v113 + 4 <= v117)
                {
                  v120 = (char *)a1[5];
                  v121 = v113;
                }
                else
                {
                  if (v117 <= 1)
                    v117 = 1;
                  v118 = 2 * v117;
                  if (v118 <= v116)
                    v119 = v116;
                  else
                    v119 = v118;
                  v120 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v119, "Vector Storage (uint8_t, growth)");
                  memcpy(v120, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v119;
                  a1[5] = v120;
                  v121 = *((_DWORD *)a1 + 9);
                }
                v112 += 4;
                result = (uint64_t)memmove(&v120[v113 + 1], &v120[v113], v121 - v113);
                *(_DWORD *)(a1[5] + v113) = v115;
                v113 = *((_DWORD *)a1 + 9) + 4;
                *((_DWORD *)a1 + 9) = v113;
              }
              while (v114 != v112);
            }
          }
          else
          {
            if (ScalarType != 5)
LABEL_149:
              abort();
            if ((_DWORD)result)
            {
              v24 = 0;
              v25 = 4 * result;
              do
              {
                v26 = *(_DWORD *)(v4 + v24);
                v27 = glp_serialized_integer32_control(v26);
                v28 = *((_DWORD *)a1 + 8);
                v29 = *((unsigned int *)a1 + 9);
                v30 = v29 + 1;
                if ((int)v29 + 1 <= v28)
                {
                  v33 = (char *)a1[5];
                  v34 = *((_DWORD *)a1 + 9);
                }
                else
                {
                  if (v28 <= 1)
                    v28 = 1;
                  v31 = 2 * v28;
                  if (v31 <= v30)
                    v32 = v30;
                  else
                    v32 = v31;
                  v33 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v32, "Vector Storage (uint8_t, growth)");
                  memcpy(v33, (const void *)a1[5], *((unsigned int *)a1 + 9));
                  ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                  *((_DWORD *)a1 + 8) = v32;
                  a1[5] = v33;
                  v34 = *((_DWORD *)a1 + 9);
                }
                result = (uint64_t)memmove(&v33[v29 + 1], &v33[v29], (v34 - v29));
                *(_BYTE *)(a1[5] + v29) = v27;
                v35 = *((_DWORD *)a1 + 9);
                v36 = v35 + 1;
                *((_DWORD *)a1 + 9) = v35 + 1;
                if (v27 < 0)
                {
                  switch((v27 >> 1) & 7)
                  {
                    case 0u:
                      v37 = v35 + 2;
                      v38 = *((_DWORD *)a1 + 8);
                      if (v37 <= v38)
                      {
                        v41 = (char *)a1[5];
                        v42 = v36;
                      }
                      else
                      {
                        if (v38 <= 1)
                          v38 = 1;
                        v39 = 2 * v38;
                        if (v39 <= (int)v37)
                          v40 = v37;
                        else
                          v40 = v39;
                        v41 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v40, "Vector Storage (uint8_t, growth)");
                        memcpy(v41, (const void *)a1[5], *((unsigned int *)a1 + 9));
                        ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                        *((_DWORD *)a1 + 8) = v40;
                        a1[5] = v41;
                        v42 = *((_DWORD *)a1 + 9);
                      }
                      result = (uint64_t)memmove(&v41[v36 + 1], &v41[v36], v42 - v36);
                      *(_BYTE *)(a1[5] + v36) = v26;
                      v61 = 1;
                      goto LABEL_70;
                    case 1u:
                      v43 = v35 + 3;
                      v44 = *((_DWORD *)a1 + 8);
                      if (v43 <= v44)
                      {
                        v47 = (char *)a1[5];
                        v48 = v36;
                      }
                      else
                      {
                        if (v44 <= 1)
                          v44 = 1;
                        v45 = 2 * v44;
                        if (v45 <= (int)v43)
                          v46 = v43;
                        else
                          v46 = v45;
                        v47 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v46, "Vector Storage (uint8_t, growth)");
                        memcpy(v47, (const void *)a1[5], *((unsigned int *)a1 + 9));
                        ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                        *((_DWORD *)a1 + 8) = v46;
                        a1[5] = v47;
                        v48 = *((_DWORD *)a1 + 9);
                      }
                      result = (uint64_t)memmove(&v47[v36 + 1], &v47[v36], v48 - v36);
                      *(_WORD *)(a1[5] + v36) = v26;
                      v61 = 2;
                      goto LABEL_70;
                    case 2u:
                      v49 = v35 + 4;
                      v50 = *((_DWORD *)a1 + 8);
                      if (v49 <= v50)
                      {
                        v53 = (char *)a1[5];
                        v54 = v36;
                      }
                      else
                      {
                        if (v50 <= 1)
                          v50 = 1;
                        v51 = 2 * v50;
                        if (v51 <= (int)v49)
                          v52 = v49;
                        else
                          v52 = v51;
                        v53 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v52, "Vector Storage (uint8_t, growth)");
                        memcpy(v53, (const void *)a1[5], *((unsigned int *)a1 + 9));
                        ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                        *((_DWORD *)a1 + 8) = v52;
                        a1[5] = v53;
                        v54 = *((_DWORD *)a1 + 9);
                      }
                      result = (uint64_t)memmove(&v53[v36 + 1], &v53[v36], v54 - v36);
                      v62 = a1[5] + v36;
                      *(_BYTE *)(v62 + 2) = BYTE2(v26);
                      *(_WORD *)v62 = v26;
                      v61 = 3;
                      goto LABEL_70;
                    case 3u:
                      v55 = v35 + 5;
                      v56 = *((_DWORD *)a1 + 8);
                      if (v55 <= v56)
                      {
                        v59 = (char *)a1[5];
                        v60 = v36;
                      }
                      else
                      {
                        if (v56 <= 1)
                          v56 = 1;
                        v57 = 2 * v56;
                        if (v57 <= (int)v55)
                          v58 = v55;
                        else
                          v58 = v57;
                        v59 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v58, "Vector Storage (uint8_t, growth)");
                        memcpy(v59, (const void *)a1[5], *((unsigned int *)a1 + 9));
                        ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                        *((_DWORD *)a1 + 8) = v58;
                        a1[5] = v59;
                        v60 = *((_DWORD *)a1 + 9);
                      }
                      result = (uint64_t)memmove(&v59[v36 + 1], &v59[v36], v60 - v36);
                      *(_DWORD *)(a1[5] + v36) = v26;
                      v61 = 4;
LABEL_70:
                      *((_DWORD *)a1 + 9) += v61;
                      break;
                    default:
                      break;
                  }
                }
                v24 += 4;
              }
              while (v25 != v24);
            }
          }
        }
        else
        {
          switch(ScalarType)
          {
            case 62:
              if ((_DWORD)result)
              {
                v63 = 0;
                v64 = *((_DWORD *)a1 + 9);
                v65 = 8 * result;
                do
                {
                  v66 = *(_QWORD *)(v4 + v63);
                  v67 = v64 + 8;
                  v68 = *((_DWORD *)a1 + 8);
                  if (v64 + 8 <= v68)
                  {
                    v71 = (char *)a1[5];
                    v72 = v64;
                  }
                  else
                  {
                    if (v68 <= 1)
                      v68 = 1;
                    v69 = 2 * v68;
                    if (v69 <= v67)
                      v70 = v67;
                    else
                      v70 = v69;
                    v71 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v70, "Vector Storage (uint8_t, growth)");
                    memcpy(v71, (const void *)a1[5], *((unsigned int *)a1 + 9));
                    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                    *((_DWORD *)a1 + 8) = v70;
                    a1[5] = v71;
                    v72 = *((_DWORD *)a1 + 9);
                  }
                  v63 += 8;
                  result = (uint64_t)memmove(&v71[v64 + 1], &v71[v64], v72 - v64);
                  *(_QWORD *)(a1[5] + v64) = v66;
                  v64 = *((_DWORD *)a1 + 9) + 8;
                  *((_DWORD *)a1 + 9) = v64;
                }
                while (v65 != v63);
              }
              break;
            case 36:
              if ((_DWORD)result)
              {
                v73 = 0;
                v74 = 4 * result;
                do
                {
                  v75 = *(_DWORD *)(v4 + v73);
                  v76 = glp_serialized_integer32_control(v75);
                  v77 = *((_DWORD *)a1 + 8);
                  v78 = *((unsigned int *)a1 + 9);
                  v79 = v78 + 1;
                  if ((int)v78 + 1 <= v77)
                  {
                    v82 = (char *)a1[5];
                    v83 = *((_DWORD *)a1 + 9);
                  }
                  else
                  {
                    if (v77 <= 1)
                      v77 = 1;
                    v80 = 2 * v77;
                    if (v80 <= v79)
                      v81 = v79;
                    else
                      v81 = v80;
                    v82 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v81, "Vector Storage (uint8_t, growth)");
                    memcpy(v82, (const void *)a1[5], *((unsigned int *)a1 + 9));
                    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                    *((_DWORD *)a1 + 8) = v81;
                    a1[5] = v82;
                    v83 = *((_DWORD *)a1 + 9);
                  }
                  result = (uint64_t)memmove(&v82[v78 + 1], &v82[v78], (v83 - v78));
                  *(_BYTE *)(a1[5] + v78) = v76;
                  v84 = *((_DWORD *)a1 + 9);
                  v85 = v84 + 1;
                  *((_DWORD *)a1 + 9) = v84 + 1;
                  if (v76 < 0)
                  {
                    switch((v76 >> 1) & 7)
                    {
                      case 0u:
                        v86 = v84 + 2;
                        v87 = *((_DWORD *)a1 + 8);
                        if (v86 <= v87)
                        {
                          v90 = (char *)a1[5];
                          v91 = v85;
                        }
                        else
                        {
                          if (v87 <= 1)
                            v87 = 1;
                          v88 = 2 * v87;
                          if (v88 <= (int)v86)
                            v89 = v86;
                          else
                            v89 = v88;
                          v90 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v89, "Vector Storage (uint8_t, growth)");
                          memcpy(v90, (const void *)a1[5], *((unsigned int *)a1 + 9));
                          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                          *((_DWORD *)a1 + 8) = v89;
                          a1[5] = v90;
                          v91 = *((_DWORD *)a1 + 9);
                        }
                        result = (uint64_t)memmove(&v90[v85 + 1], &v90[v85], v91 - v85);
                        *(_BYTE *)(a1[5] + v85) = v75;
                        v110 = 1;
                        goto LABEL_133;
                      case 1u:
                        v92 = v84 + 3;
                        v93 = *((_DWORD *)a1 + 8);
                        if (v92 <= v93)
                        {
                          v96 = (char *)a1[5];
                          v97 = v85;
                        }
                        else
                        {
                          if (v93 <= 1)
                            v93 = 1;
                          v94 = 2 * v93;
                          if (v94 <= (int)v92)
                            v95 = v92;
                          else
                            v95 = v94;
                          v96 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v95, "Vector Storage (uint8_t, growth)");
                          memcpy(v96, (const void *)a1[5], *((unsigned int *)a1 + 9));
                          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                          *((_DWORD *)a1 + 8) = v95;
                          a1[5] = v96;
                          v97 = *((_DWORD *)a1 + 9);
                        }
                        result = (uint64_t)memmove(&v96[v85 + 1], &v96[v85], v97 - v85);
                        *(_WORD *)(a1[5] + v85) = v75;
                        v110 = 2;
                        goto LABEL_133;
                      case 2u:
                        v98 = v84 + 4;
                        v99 = *((_DWORD *)a1 + 8);
                        if (v98 <= v99)
                        {
                          v102 = (char *)a1[5];
                          v103 = v85;
                        }
                        else
                        {
                          if (v99 <= 1)
                            v99 = 1;
                          v100 = 2 * v99;
                          if (v100 <= (int)v98)
                            v101 = v98;
                          else
                            v101 = v100;
                          v102 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v101, "Vector Storage (uint8_t, growth)");
                          memcpy(v102, (const void *)a1[5], *((unsigned int *)a1 + 9));
                          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                          *((_DWORD *)a1 + 8) = v101;
                          a1[5] = v102;
                          v103 = *((_DWORD *)a1 + 9);
                        }
                        result = (uint64_t)memmove(&v102[v85 + 1], &v102[v85], v103 - v85);
                        v111 = a1[5] + v85;
                        *(_BYTE *)(v111 + 2) = BYTE2(v75);
                        *(_WORD *)v111 = v75;
                        v110 = 3;
                        goto LABEL_133;
                      case 3u:
                        v104 = v84 + 5;
                        v105 = *((_DWORD *)a1 + 8);
                        if (v104 <= v105)
                        {
                          v108 = (char *)a1[5];
                          v109 = v85;
                        }
                        else
                        {
                          if (v105 <= 1)
                            v105 = 1;
                          v106 = 2 * v105;
                          if (v106 <= (int)v104)
                            v107 = v104;
                          else
                            v107 = v106;
                          v108 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v107, "Vector Storage (uint8_t, growth)");
                          memcpy(v108, (const void *)a1[5], *((unsigned int *)a1 + 9));
                          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                          *((_DWORD *)a1 + 8) = v107;
                          a1[5] = v108;
                          v109 = *((_DWORD *)a1 + 9);
                        }
                        result = (uint64_t)memmove(&v108[v85 + 1], &v108[v85], v109 - v85);
                        *(_DWORD *)(a1[5] + v85) = v75;
                        v110 = 4;
LABEL_133:
                        *((_DWORD *)a1 + 9) += v110;
                        break;
                      default:
                        break;
                    }
                  }
                  v73 += 4;
                }
                while (v74 != v73);
              }
              break;
            case 9:
              if ((_DWORD)result)
              {
                v14 = 0;
                v15 = *((_DWORD *)a1 + 9);
                v16 = 4 * result;
                do
                {
                  v17 = *(_DWORD *)(v4 + v14) != 0;
                  v18 = v15 + 1;
                  v19 = *((_DWORD *)a1 + 8);
                  if (v15 + 1 <= v19)
                  {
                    v22 = (char *)a1[5];
                    v23 = v15;
                  }
                  else
                  {
                    if (v19 <= 1)
                      v19 = 1;
                    v20 = 2 * v19;
                    if (v20 <= v18)
                      v21 = v18;
                    else
                      v21 = v20;
                    v22 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v21, "Vector Storage (uint8_t, growth)");
                    memcpy(v22, (const void *)a1[5], *((unsigned int *)a1 + 9));
                    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
                    *((_DWORD *)a1 + 8) = v21;
                    a1[5] = v22;
                    v23 = *((_DWORD *)a1 + 9);
                  }
                  v14 += 4;
                  result = (uint64_t)memmove(&v22[v15 + 1], &v22[v15], v23 - v15);
                  *(_BYTE *)(a1[5] + v15) = v17;
                  v15 = *((_DWORD *)a1 + 9) + 1;
                  *((_DWORD *)a1 + 9) = v15;
                }
                while (v16 != v14);
              }
              break;
            default:
              goto LABEL_149;
          }
        }
        ++v11;
        v4 += 16;
      }
      while (v11 != v123);
    }
  }
  return result;
}

void glpSerializeAST(uint64_t a1, unint64_t a2, _QWORD *a3, _DWORD *a4)
{
  unsigned int v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  char *v15;
  int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  uint64_t v22;
  char *v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  int v27;
  uint64_t v28;
  char *v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  int v33;
  uint64_t v34;
  char *v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  int v39;
  uint64_t v40;
  char *v41;
  unsigned int v42;
  int v43;
  size_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t i;
  uint64_t v48;
  unint64_t v49;
  unsigned int *v50;
  void *v51;
  __int128 v52;
  __int128 v53;
  size_t __n[2];
  __int128 v55;
  uint64_t v56;
  _OWORD v57[2];

  memset(v57, 0, sizeof(v57));
  glpInitPoolAllocator(0x4000, 0x4000, v57);
  v56 = 0;
  *(_OWORD *)__n = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  glpInitSerialContext(&v52, v57);
  v8 = *(_DWORD *)(a1 + 36);
  v9 = (char)glp_serialized_integer32_control(v8);
  v10 = __n[0];
  v11 = HIDWORD(__n[0]);
  v12 = HIDWORD(__n[0]) + 1;
  if ((HIDWORD(__n[0]) + 1) <= LODWORD(__n[0]))
  {
    v15 = (char *)__n[1];
    v16 = HIDWORD(__n[0]);
  }
  else
  {
    if (SLODWORD(__n[0]) <= 1)
      v10 = 1;
    v13 = 2 * v10;
    if (v13 <= v12)
      v14 = v12;
    else
      v14 = v13;
    v15 = (char *)(*((uint64_t (**)(_QWORD, uint64_t, const char *))&v52 + 1))(v52, v14, "Vector Storage (uint8_t, growth)");
    memcpy(v15, (const void *)__n[1], HIDWORD(__n[0]));
    (*((void (**)(_QWORD, size_t))&v53 + 1))(v52, __n[1]);
    LODWORD(__n[0]) = v14;
    __n[1] = (size_t)v15;
    v16 = HIDWORD(__n[0]);
  }
  memmove(&v15[v11 + 1], &v15[v11], (v16 - v11));
  *(_BYTE *)(__n[1] + v11) = v9;
  v17 = HIDWORD(__n[0]);
  v18 = ++HIDWORD(__n[0]);
  if ((v9 & 0x80000000) != 0)
  {
    switch((v9 >> 1) & 7)
    {
      case 0u:
        v19 = v17 + 2;
        v20 = __n[0];
        if (v19 <= LODWORD(__n[0]))
        {
          v23 = (char *)__n[1];
          v24 = v18;
        }
        else
        {
          if (SLODWORD(__n[0]) <= 1)
            v20 = 1;
          v21 = 2 * v20;
          if (v21 <= (int)v19)
            v22 = v19;
          else
            v22 = v21;
          v23 = (char *)(*((uint64_t (**)(_QWORD, uint64_t, const char *))&v52 + 1))(v52, v22, "Vector Storage (uint8_t, growth)");
          memcpy(v23, (const void *)__n[1], HIDWORD(__n[0]));
          (*((void (**)(_QWORD, size_t))&v53 + 1))(v52, __n[1]);
          LODWORD(__n[0]) = v22;
          __n[1] = (size_t)v23;
          v24 = HIDWORD(__n[0]);
        }
        memmove(&v23[v18 + 1], &v23[v18], v24 - v18);
        *(_BYTE *)(__n[1] + v18) = v8;
        v43 = 1;
        goto LABEL_47;
      case 1u:
        v25 = v17 + 3;
        v26 = __n[0];
        if (v25 <= LODWORD(__n[0]))
        {
          v29 = (char *)__n[1];
          v30 = v18;
        }
        else
        {
          if (SLODWORD(__n[0]) <= 1)
            v26 = 1;
          v27 = 2 * v26;
          if (v27 <= (int)v25)
            v28 = v25;
          else
            v28 = v27;
          v29 = (char *)(*((uint64_t (**)(_QWORD, uint64_t, const char *))&v52 + 1))(v52, v28, "Vector Storage (uint8_t, growth)");
          memcpy(v29, (const void *)__n[1], HIDWORD(__n[0]));
          (*((void (**)(_QWORD, size_t))&v53 + 1))(v52, __n[1]);
          LODWORD(__n[0]) = v28;
          __n[1] = (size_t)v29;
          v30 = HIDWORD(__n[0]);
        }
        memmove(&v29[v18 + 1], &v29[v18], v30 - v18);
        *(_WORD *)(__n[1] + v18) = v8;
        v43 = 2;
        goto LABEL_47;
      case 2u:
        v31 = v17 + 4;
        v32 = __n[0];
        if (v31 <= LODWORD(__n[0]))
        {
          v35 = (char *)__n[1];
          v36 = v18;
        }
        else
        {
          if (SLODWORD(__n[0]) <= 1)
            v32 = 1;
          v33 = 2 * v32;
          if (v33 <= (int)v31)
            v34 = v31;
          else
            v34 = v33;
          v35 = (char *)(*((uint64_t (**)(_QWORD, uint64_t, const char *))&v52 + 1))(v52, v34, "Vector Storage (uint8_t, growth)");
          memcpy(v35, (const void *)__n[1], HIDWORD(__n[0]));
          (*((void (**)(_QWORD, size_t))&v53 + 1))(v52, __n[1]);
          LODWORD(__n[0]) = v34;
          __n[1] = (size_t)v35;
          v36 = HIDWORD(__n[0]);
        }
        memmove(&v35[v18 + 1], &v35[v18], v36 - v18);
        v44 = __n[1] + v18;
        *(_BYTE *)(v44 + 2) = BYTE2(v8);
        *(_WORD *)v44 = v8;
        v43 = 3;
        goto LABEL_47;
      case 3u:
        v37 = v17 + 5;
        v38 = __n[0];
        if (v37 <= LODWORD(__n[0]))
        {
          v41 = (char *)__n[1];
          v42 = v18;
        }
        else
        {
          if (SLODWORD(__n[0]) <= 1)
            v38 = 1;
          v39 = 2 * v38;
          if (v39 <= (int)v37)
            v40 = v37;
          else
            v40 = v39;
          v41 = (char *)(*((uint64_t (**)(_QWORD, uint64_t, const char *))&v52 + 1))(v52, v40, "Vector Storage (uint8_t, growth)");
          memcpy(v41, (const void *)__n[1], HIDWORD(__n[0]));
          (*((void (**)(_QWORD, size_t))&v53 + 1))(v52, __n[1]);
          LODWORD(__n[0]) = v40;
          __n[1] = (size_t)v41;
          v42 = HIDWORD(__n[0]);
        }
        memmove(&v41[v18 + 1], &v41[v18], v42 - v18);
        *(_DWORD *)(__n[1] + v18) = v8;
        v43 = 4;
LABEL_47:
        HIDWORD(__n[0]) += v43;
        break;
      default:
        break;
    }
  }
  v45 = *(unsigned int *)(a1 + 32);
  if ((_DWORD)v45)
  {
    v46 = 0;
    for (i = 0; i < v45; ++i)
    {
      v48 = *(_QWORD *)(a1 + 40);
      v49 = *(_QWORD *)(v48 + v46);
      if (v49)
      {
        v50 = *(unsigned int **)(v48 + v46 + 8);
        serialize_GLPType(&v52, (unint64_t)v50);
        real_serialize_GLPValue(&v52, v49, v50);
        v45 = *(unsigned int *)(a1 + 32);
      }
      v46 += 32;
    }
  }
  serialize_GLPASTNode(&v52, a2);
  v51 = malloc_type_malloc(HIDWORD(__n[0]), 0x7081ABB9uLL);
  if (!v51)
    abort();
  *a3 = v51;
  memcpy(v51, (const void *)__n[1], HIDWORD(__n[0]));
  *a4 = HIDWORD(__n[0]);
  glpDestroySerialContext((uint64_t)&v52, 1);
  glpDestroyPoolAllocator((uint64_t)v57);
}

uint64_t serialize_GLPASTNode(_QWORD *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t ChildCount;
  int v6;
  unsigned int v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  char *v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  int v41;
  uint64_t v42;
  unsigned int i;
  uint64_t Child;

  result = serialize_pointer(a1, a2);
  if ((_DWORD)result)
  {
    switch(glpASTNodeGetKind(a2))
    {
      case 0u:
        serializeTypeConversionFields(a1, a2);
        break;
      case 1u:
        serializeVariableIdentifierFields(a1, a2);
        break;
      case 2u:
        serializeTypeIdentifierFields(a1, a2);
        break;
      case 3u:
        serializeConstantFields(a1, a2);
        break;
      case 4u:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
      case 0x20u:
      case 0x21u:
      case 0x22u:
      case 0x23u:
      case 0x24u:
      case 0x25u:
      case 0x26u:
      case 0x30u:
      case 0x33u:
      case 0x34u:
      case 0x36u:
      case 0x41u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Du:
      case 0x52u:
        serializeASTFields(a1, a2);
        break;
      case 5u:
        serializeFieldAccessFields(a1, a2);
        break;
      case 6u:
      case 0xAu:
        serializeCallFields(a1, a2);
        break;
      case 7u:
        serializeFunctionCallFields(a1, a2);
        break;
      case 8u:
        serializeSubroutineArrayCallFields(a1, a2);
        break;
      case 9u:
        serializeMethodCallFields(a1, a2);
        break;
      case 0x1Eu:
        serializeEqualFields(a1, a2);
        break;
      case 0x1Fu:
        serializeNotEqualFields(a1, a2);
        break;
      case 0x27u:
        serializeAssignFields(a1, a2);
        break;
      case 0x28u:
        serializeOpAssignFields(a1, a2);
      case 0x29u:
        serializeReadInputFields(a1, a2);
        break;
      case 0x2Au:
        serializeWriteOutputFields(a1, a2);
        break;
      case 0x2Bu:
        serializeCommaExprFields(a1, a2);
        break;
      case 0x2Cu:
        serializeParameterDeclarationFields(a1, a2);
        break;
      case 0x2Du:
        serializeFunctionPrototypeFields(a1, a2);
        break;
      case 0x2Eu:
        serializeVariableDeclarationFields(a1, a2);
        break;
      case 0x2Fu:
        serializeVariableDeclarationGroupFields(a1, a2);
        break;
      case 0x31u:
        serializeQualifiedDeclarationFields(a1, a2);
        break;
      case 0x32u:
        serializeQualifiedDeclarationGroupFields(a1, a2);
        break;
      case 0x35u:
        serializePrimitiveTypeFields(a1, a2);
        break;
      case 0x37u:
        serializeFieldDeclarationFields(a1, a2);
        break;
      case 0x38u:
        serializeStructTypeFields(a1, a2);
        break;
      case 0x39u:
        serializeInterfaceBlockFields(a1, a2);
        break;
      case 0x3Au:
        serializeLayoutTypeFields(a1, a2);
        break;
      case 0x3Bu:
        serializeKeywordQualifierFields(a1, a2);
        break;
      case 0x3Cu:
        serializeLayoutQualifierFields(a1, a2);
        break;
      case 0x3Du:
        serializeSubroutineTypeListFields(a1, a2);
        break;
      case 0x3Eu:
        serializeQualifierListFields(a1, a2);
        break;
      case 0x3Fu:
        serializeGlobalTypeQualifierFields(a1, a2);
        break;
      case 0x40u:
        serializeLayoutPairFields(a1, a2);
        break;
      case 0x42u:
        serializeBlockFields(a1, a2);
        break;
      case 0x46u:
        serializeCaseStatementFields(a1, a2);
        break;
      case 0x47u:
        serializeDefaultStatementFields(a1, a2);
        break;
      case 0x4Bu:
        serializeReturnStatementFields(a1, a2);
        break;
      case 0x4Cu:
        serializeTopLevelFields(a1, a2);
        break;
      case 0x4Eu:
        serializeRawCallFields(a1, a2);
        break;
      case 0x4Fu:
        serializeSubroutineRawCallFields(a1, a2);
        break;
      case 0x50u:
        serializeOffsetFields(a1, a2);
        break;
      case 0x51u:
        serializeLValueFields(a1, a2);
        break;
      case 0x53u:
        serializeIBPartialDerefFields(a1, a2);
        break;
      case 0x54u:
        serializePPStreamOpFields(a1, a2);
        break;
      case 0x55u:
        serializeSubroutineUniformFields(a1, a2);
        break;
      default:
        abort();
    }
    ChildCount = glpASTNodeGetChildCount(a2);
    v6 = ChildCount;
    v7 = (char)glp_serialized_integer32_control(ChildCount);
    v8 = *((_DWORD *)a1 + 8);
    v9 = *((unsigned int *)a1 + 9);
    v10 = v9 + 1;
    if ((int)v9 + 1 <= v8)
    {
      v13 = (char *)a1[5];
      v14 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v8 <= 1)
        v8 = 1;
      v11 = 2 * v8;
      if (v11 <= v10)
        v12 = v10;
      else
        v12 = v11;
      v13 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v12, "Vector Storage (uint8_t, growth)");
      memcpy(v13, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v12;
      a1[5] = v13;
      v14 = *((_DWORD *)a1 + 9);
    }
    result = (uint64_t)memmove(&v13[v9 + 1], &v13[v9], (v14 - v9));
    *(_BYTE *)(a1[5] + v9) = v7;
    v15 = *((_DWORD *)a1 + 9);
    v16 = v15 + 1;
    *((_DWORD *)a1 + 9) = v15 + 1;
    if ((v7 & 0x80000000) != 0)
    {
      switch((v7 >> 1) & 7)
      {
        case 0u:
          v17 = v15 + 2;
          v18 = *((_DWORD *)a1 + 8);
          if (v17 <= v18)
          {
            v21 = (char *)a1[5];
            v22 = v16;
          }
          else
          {
            if (v18 <= 1)
              v18 = 1;
            v19 = 2 * v18;
            if (v19 <= (int)v17)
              v20 = v17;
            else
              v20 = v19;
            v21 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v20, "Vector Storage (uint8_t, growth)");
            memcpy(v21, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v20;
            a1[5] = v21;
            v22 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v21[v16 + 1], &v21[v16], v22 - v16);
          *(_BYTE *)(a1[5] + v16) = v6;
          v41 = 1;
          goto LABEL_50;
        case 1u:
          v23 = v15 + 3;
          v24 = *((_DWORD *)a1 + 8);
          if (v23 <= v24)
          {
            v27 = (char *)a1[5];
            v28 = v16;
          }
          else
          {
            if (v24 <= 1)
              v24 = 1;
            v25 = 2 * v24;
            if (v25 <= (int)v23)
              v26 = v23;
            else
              v26 = v25;
            v27 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v26, "Vector Storage (uint8_t, growth)");
            memcpy(v27, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v26;
            a1[5] = v27;
            v28 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v27[v16 + 1], &v27[v16], v28 - v16);
          *(_WORD *)(a1[5] + v16) = v6;
          v41 = 2;
          goto LABEL_50;
        case 2u:
          v29 = v15 + 4;
          v30 = *((_DWORD *)a1 + 8);
          if (v29 <= v30)
          {
            v33 = (char *)a1[5];
            v34 = v16;
          }
          else
          {
            if (v30 <= 1)
              v30 = 1;
            v31 = 2 * v30;
            if (v31 <= (int)v29)
              v32 = v29;
            else
              v32 = v31;
            v33 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v32, "Vector Storage (uint8_t, growth)");
            memcpy(v33, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v32;
            a1[5] = v33;
            v34 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v33[v16 + 1], &v33[v16], v34 - v16);
          v42 = a1[5] + v16;
          *(_BYTE *)(v42 + 2) = BYTE2(v6);
          *(_WORD *)v42 = v6;
          v41 = 3;
          goto LABEL_50;
        case 3u:
          v35 = v15 + 5;
          v36 = *((_DWORD *)a1 + 8);
          if (v35 <= v36)
          {
            v39 = (char *)a1[5];
            v40 = v16;
          }
          else
          {
            if (v36 <= 1)
              v36 = 1;
            v37 = 2 * v36;
            if (v37 <= (int)v35)
              v38 = v35;
            else
              v38 = v37;
            v39 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v38, "Vector Storage (uint8_t, growth)");
            memcpy(v39, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v38;
            a1[5] = v39;
            v40 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v39[v16 + 1], &v39[v16], v40 - v16);
          *(_DWORD *)(a1[5] + v16) = v6;
          v41 = 4;
LABEL_50:
          *((_DWORD *)a1 + 9) += v41;
          break;
        default:
          break;
      }
    }
    if (v6)
    {
      for (i = 0; i != v6; ++i)
      {
        Child = glpASTNodeGetChild(a2, i);
        result = serialize_GLPASTNode(a1, Child);
      }
    }
  }
  return result;
}

uint64_t serialize_GLPLayoutPair(_QWORD *a1, unint64_t a2)
{
  uint64_t result;
  unsigned int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  int v18;
  uint64_t v19;
  char *v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  uint64_t v25;
  char *v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  int v30;
  uint64_t v31;
  char *v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  int v36;
  uint64_t v37;
  char *v38;
  unsigned int v39;
  uint64_t v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  char *v49;
  int v50;
  int v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  int v55;
  uint64_t v56;
  char *v57;
  unsigned int v58;
  unsigned int v59;
  int v60;
  int v61;
  uint64_t v62;
  char *v63;
  unsigned int v64;
  unsigned int v65;
  int v66;
  int v67;
  uint64_t v68;
  char *v69;
  unsigned int v70;
  unsigned int v71;
  int v72;
  int v73;
  uint64_t v74;
  char *v75;
  unsigned int v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  unsigned int v80;
  int v81;
  uint64_t v82;
  int v83;
  int v84;
  uint64_t v85;
  char *v86;
  int v87;
  int v88;
  unsigned int v89;
  unsigned int v90;
  int v91;
  int v92;
  uint64_t v93;
  char *v94;
  unsigned int v95;
  unsigned int v96;
  int v97;
  int v98;
  uint64_t v99;
  char *v100;
  unsigned int v101;
  unsigned int v102;
  int v103;
  int v104;
  uint64_t v105;
  char *v106;
  unsigned int v107;
  unsigned int v108;
  int v109;
  int v110;
  uint64_t v111;
  char *v112;
  unsigned int v113;
  int v114;
  uint64_t v115;

  result = serialize_pointer(a1, a2);
  if ((_DWORD)result)
  {
    serialize_GLPLayoutPair(a1, *(_QWORD *)a2);
    v5 = *(_DWORD *)(a2 + 8);
    v6 = (char)glp_serialized_integer32_control(v5);
    v7 = *((_DWORD *)a1 + 8);
    v8 = *((unsigned int *)a1 + 9);
    v9 = v8 + 1;
    if ((int)v8 + 1 <= v7)
    {
      v12 = (char *)a1[5];
      v13 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v7 <= 1)
        v7 = 1;
      v10 = 2 * v7;
      if (v10 <= v9)
        v11 = v9;
      else
        v11 = v10;
      v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
      memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v11;
      a1[5] = v12;
      v13 = *((_DWORD *)a1 + 9);
    }
    memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
    *(_BYTE *)(a1[5] + v8) = v6;
    v14 = *((_DWORD *)a1 + 9);
    v15 = v14 + 1;
    *((_DWORD *)a1 + 9) = v14 + 1;
    if ((v6 & 0x80000000) != 0)
    {
      switch((v6 >> 1) & 7)
      {
        case 0u:
          v16 = v14 + 2;
          v17 = *((_DWORD *)a1 + 8);
          if (v16 <= v17)
          {
            v20 = (char *)a1[5];
            v21 = v15;
          }
          else
          {
            if (v17 <= 1)
              v17 = 1;
            v18 = 2 * v17;
            if (v18 <= (int)v16)
              v19 = v16;
            else
              v19 = v18;
            v20 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v19, "Vector Storage (uint8_t, growth)");
            memcpy(v20, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v19;
            a1[5] = v20;
            v21 = *((_DWORD *)a1 + 9);
          }
          memmove(&v20[v15 + 1], &v20[v15], v21 - v15);
          *(_BYTE *)(a1[5] + v15) = v5;
          v41 = 1;
          goto LABEL_48;
        case 1u:
          v34 = v14 + 3;
          v35 = *((_DWORD *)a1 + 8);
          if (v34 <= v35)
          {
            v38 = (char *)a1[5];
            v39 = v15;
          }
          else
          {
            if (v35 <= 1)
              v35 = 1;
            v36 = 2 * v35;
            if (v36 <= (int)v34)
              v37 = v34;
            else
              v37 = v36;
            v38 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v37, "Vector Storage (uint8_t, growth)");
            memcpy(v38, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v37;
            a1[5] = v38;
            v39 = *((_DWORD *)a1 + 9);
          }
          memmove(&v38[v15 + 1], &v38[v15], v39 - v15);
          *(_WORD *)(a1[5] + v15) = v5;
          v41 = 2;
          goto LABEL_48;
        case 2u:
          v22 = v14 + 4;
          v23 = *((_DWORD *)a1 + 8);
          if (v22 <= v23)
          {
            v26 = (char *)a1[5];
            v27 = v15;
          }
          else
          {
            if (v23 <= 1)
              v23 = 1;
            v24 = 2 * v23;
            if (v24 <= (int)v22)
              v25 = v22;
            else
              v25 = v24;
            v26 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v25, "Vector Storage (uint8_t, growth)");
            memcpy(v26, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v25;
            a1[5] = v26;
            v27 = *((_DWORD *)a1 + 9);
          }
          memmove(&v26[v15 + 1], &v26[v15], v27 - v15);
          v40 = a1[5] + v15;
          *(_BYTE *)(v40 + 2) = BYTE2(v5);
          *(_WORD *)v40 = v5;
          v41 = 3;
          goto LABEL_48;
        case 3u:
          v28 = v14 + 5;
          v29 = *((_DWORD *)a1 + 8);
          if (v28 <= v29)
          {
            v32 = (char *)a1[5];
            v33 = v15;
          }
          else
          {
            if (v29 <= 1)
              v29 = 1;
            v30 = 2 * v29;
            if (v30 <= (int)v28)
              v31 = v28;
            else
              v31 = v30;
            v32 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v31, "Vector Storage (uint8_t, growth)");
            memcpy(v32, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v31;
            a1[5] = v32;
            v33 = *((_DWORD *)a1 + 9);
          }
          memmove(&v32[v15 + 1], &v32[v15], v33 - v15);
          *(_DWORD *)(a1[5] + v15) = v5;
          v41 = 4;
LABEL_48:
          *((_DWORD *)a1 + 9) += v41;
          break;
        default:
          break;
      }
    }
    v42 = *(_DWORD *)(a2 + 12);
    v43 = (char)glp_serialized_integer32_control(v42);
    v44 = *((_DWORD *)a1 + 8);
    v45 = *((unsigned int *)a1 + 9);
    v46 = v45 + 1;
    if ((int)v45 + 1 <= v44)
    {
      v49 = (char *)a1[5];
      v50 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v44 <= 1)
        v44 = 1;
      v47 = 2 * v44;
      if (v47 <= v46)
        v48 = v46;
      else
        v48 = v47;
      v49 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v48, "Vector Storage (uint8_t, growth)");
      memcpy(v49, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v48;
      a1[5] = v49;
      v50 = *((_DWORD *)a1 + 9);
    }
    result = (uint64_t)memmove(&v49[v45 + 1], &v49[v45], (v50 - v45));
    *(_BYTE *)(a1[5] + v45) = v43;
    v51 = *((_DWORD *)a1 + 9);
    v52 = v51 + 1;
    *((_DWORD *)a1 + 9) = v51 + 1;
    if ((v43 & 0x80000000) != 0)
    {
      switch((v43 >> 1) & 7)
      {
        case 0u:
          v53 = v51 + 2;
          v54 = *((_DWORD *)a1 + 8);
          if (v53 <= v54)
          {
            v57 = (char *)a1[5];
            v58 = v52;
          }
          else
          {
            if (v54 <= 1)
              v54 = 1;
            v55 = 2 * v54;
            if (v55 <= (int)v53)
              v56 = v53;
            else
              v56 = v55;
            v57 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v56, "Vector Storage (uint8_t, growth)");
            memcpy(v57, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v56;
            a1[5] = v57;
            v58 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v57[v52 + 1], &v57[v52], v58 - v52);
          *(_BYTE *)(a1[5] + v52) = v42;
          v78 = 1;
          goto LABEL_95;
        case 1u:
          v71 = v51 + 3;
          v72 = *((_DWORD *)a1 + 8);
          if (v71 <= v72)
          {
            v75 = (char *)a1[5];
            v76 = v52;
          }
          else
          {
            if (v72 <= 1)
              v72 = 1;
            v73 = 2 * v72;
            if (v73 <= (int)v71)
              v74 = v71;
            else
              v74 = v73;
            v75 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v74, "Vector Storage (uint8_t, growth)");
            memcpy(v75, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v74;
            a1[5] = v75;
            v76 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v75[v52 + 1], &v75[v52], v76 - v52);
          *(_WORD *)(a1[5] + v52) = v42;
          v78 = 2;
          goto LABEL_95;
        case 2u:
          v59 = v51 + 4;
          v60 = *((_DWORD *)a1 + 8);
          if (v59 <= v60)
          {
            v63 = (char *)a1[5];
            v64 = v52;
          }
          else
          {
            if (v60 <= 1)
              v60 = 1;
            v61 = 2 * v60;
            if (v61 <= (int)v59)
              v62 = v59;
            else
              v62 = v61;
            v63 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v62, "Vector Storage (uint8_t, growth)");
            memcpy(v63, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v62;
            a1[5] = v63;
            v64 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v63[v52 + 1], &v63[v52], v64 - v52);
          v77 = a1[5] + v52;
          *(_BYTE *)(v77 + 2) = BYTE2(v42);
          *(_WORD *)v77 = v42;
          v78 = 3;
          goto LABEL_95;
        case 3u:
          v65 = v51 + 5;
          v66 = *((_DWORD *)a1 + 8);
          if (v65 <= v66)
          {
            v69 = (char *)a1[5];
            v70 = v52;
          }
          else
          {
            if (v66 <= 1)
              v66 = 1;
            v67 = 2 * v66;
            if (v67 <= (int)v65)
              v68 = v65;
            else
              v68 = v67;
            v69 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v68, "Vector Storage (uint8_t, growth)");
            memcpy(v69, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v68;
            a1[5] = v69;
            v70 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v69[v52 + 1], &v69[v52], v70 - v52);
          *(_DWORD *)(a1[5] + v52) = v42;
          v78 = 4;
LABEL_95:
          *((_DWORD *)a1 + 9) += v78;
          break;
        default:
          break;
      }
    }
    if (*(_DWORD *)(a2 + 12) == 1)
    {
      v79 = *(unsigned int *)(a2 + 16);
      v80 = (char)glp_serialized_integer32_control(v79);
      v81 = *((_DWORD *)a1 + 8);
      v82 = *((unsigned int *)a1 + 9);
      v83 = v82 + 1;
      if ((int)v82 + 1 <= v81)
      {
        v86 = (char *)a1[5];
        v87 = *((_DWORD *)a1 + 9);
      }
      else
      {
        if (v81 <= 1)
          v81 = 1;
        v84 = 2 * v81;
        if (v84 <= v83)
          v85 = v83;
        else
          v85 = v84;
        v86 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v85, "Vector Storage (uint8_t, growth)");
        memcpy(v86, (const void *)a1[5], *((unsigned int *)a1 + 9));
        ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
        *((_DWORD *)a1 + 8) = v85;
        a1[5] = v86;
        v87 = *((_DWORD *)a1 + 9);
      }
      result = (uint64_t)memmove(&v86[v82 + 1], &v86[v82], (v87 - v82));
      *(_BYTE *)(a1[5] + v82) = v80;
      v88 = *((_DWORD *)a1 + 9);
      v89 = v88 + 1;
      *((_DWORD *)a1 + 9) = v88 + 1;
      if ((v80 & 0x80000000) != 0)
      {
        switch((v80 >> 1) & 7)
        {
          case 0u:
            v90 = v88 + 2;
            v91 = *((_DWORD *)a1 + 8);
            if (v90 <= v91)
            {
              v94 = (char *)a1[5];
              v95 = v89;
            }
            else
            {
              if (v91 <= 1)
                v91 = 1;
              v92 = 2 * v91;
              if (v92 <= (int)v90)
                v93 = v90;
              else
                v93 = v92;
              v94 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v93, "Vector Storage (uint8_t, growth)");
              memcpy(v94, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v93;
              a1[5] = v94;
              v95 = *((_DWORD *)a1 + 9);
            }
            result = (uint64_t)memmove(&v94[v89 + 1], &v94[v89], v95 - v89);
            *(_BYTE *)(a1[5] + v89) = v79;
            v114 = 1;
            goto LABEL_143;
          case 1u:
            v108 = v88 + 3;
            v109 = *((_DWORD *)a1 + 8);
            if (v108 <= v109)
            {
              v112 = (char *)a1[5];
              v113 = v89;
            }
            else
            {
              if (v109 <= 1)
                v109 = 1;
              v110 = 2 * v109;
              if (v110 <= (int)v108)
                v111 = v108;
              else
                v111 = v110;
              v112 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v111, "Vector Storage (uint8_t, growth)");
              memcpy(v112, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v111;
              a1[5] = v112;
              v113 = *((_DWORD *)a1 + 9);
            }
            result = (uint64_t)memmove(&v112[v89 + 1], &v112[v89], v113 - v89);
            *(_WORD *)(a1[5] + v89) = v79;
            v114 = 2;
            goto LABEL_143;
          case 2u:
            v96 = v88 + 4;
            v97 = *((_DWORD *)a1 + 8);
            if (v96 <= v97)
            {
              v100 = (char *)a1[5];
              v101 = v89;
            }
            else
            {
              if (v97 <= 1)
                v97 = 1;
              v98 = 2 * v97;
              if (v98 <= (int)v96)
                v99 = v96;
              else
                v99 = v98;
              v100 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v99, "Vector Storage (uint8_t, growth)");
              memcpy(v100, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v99;
              a1[5] = v100;
              v101 = *((_DWORD *)a1 + 9);
            }
            result = (uint64_t)memmove(&v100[v89 + 1], &v100[v89], v101 - v89);
            v115 = a1[5] + v89;
            *(_BYTE *)(v115 + 2) = BYTE2(v79);
            *(_WORD *)v115 = v79;
            v114 = 3;
            goto LABEL_143;
          case 3u:
            v102 = v88 + 5;
            v103 = *((_DWORD *)a1 + 8);
            if (v102 <= v103)
            {
              v106 = (char *)a1[5];
              v107 = v89;
            }
            else
            {
              if (v103 <= 1)
                v103 = 1;
              v104 = 2 * v103;
              if (v104 <= (int)v102)
                v105 = v102;
              else
                v105 = v104;
              v106 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v105, "Vector Storage (uint8_t, growth)");
              memcpy(v106, (const void *)a1[5], *((unsigned int *)a1 + 9));
              ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
              *((_DWORD *)a1 + 8) = v105;
              a1[5] = v106;
              v107 = *((_DWORD *)a1 + 9);
            }
            result = (uint64_t)memmove(&v106[v89 + 1], &v106[v89], v107 - v89);
            *(_DWORD *)(a1[5] + v89) = v79;
            v114 = 4;
LABEL_143:
            *((_DWORD *)a1 + 9) += v114;
            break;
          default:
            return result;
        }
      }
    }
  }
  return result;
}

uint64_t serialize_GLPVariableObject(_QWORD *a1, unint64_t a2)
{
  uint64_t result;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  char *v11;
  int v12;
  char v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  char *v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  char *v28;
  int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  int v34;
  uint64_t v35;
  char *v36;
  unsigned int v37;
  unsigned int v38;
  int v39;
  int v40;
  uint64_t v41;
  char *v42;
  unsigned int v43;
  unsigned int v44;
  int v45;
  int v46;
  uint64_t v47;
  char *v48;
  unsigned int v49;
  unsigned int v50;
  int v51;
  int v52;
  uint64_t v53;
  char *v54;
  unsigned int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  int v62;
  int v63;
  uint64_t v64;
  char *v65;
  int v66;
  int v67;
  unsigned int v68;
  unsigned int v69;
  int v70;
  int v71;
  uint64_t v72;
  char *v73;
  unsigned int v74;
  unsigned int v75;
  int v76;
  int v77;
  uint64_t v78;
  char *v79;
  unsigned int v80;
  unsigned int v81;
  int v82;
  int v83;
  uint64_t v84;
  char *v85;
  unsigned int v86;
  unsigned int v87;
  int v88;
  int v89;
  uint64_t v90;
  char *v91;
  unsigned int v92;
  int v93;
  uint64_t v94;

  result = serialize_pointer(a1, a2);
  if ((_DWORD)result)
  {
    serialize_GLPType(a1, *(_QWORD *)a2);
    serialize_GLPLayoutObject(a1, *(unint64_t **)(a2 + 8));
    v5 = (char)glp_serialized_integer64_control(*(_QWORD *)(a2 + 48));
    v6 = *((_DWORD *)a1 + 8);
    v7 = *((unsigned int *)a1 + 9);
    v8 = v7 + 1;
    if ((int)v7 + 1 <= v6)
    {
      v11 = (char *)a1[5];
      v12 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v6 <= 1)
        v6 = 1;
      v9 = 2 * v6;
      if (v9 <= v8)
        v10 = v8;
      else
        v10 = v9;
      v11 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v10, "Vector Storage (uint8_t, growth)");
      memcpy(v11, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v10;
      a1[5] = v11;
      v12 = *((_DWORD *)a1 + 9);
    }
    memmove(&v11[v7 + 1], &v11[v7], (v12 - v7));
    *(_BYTE *)(a1[5] + v7) = v5;
    ++*((_DWORD *)a1 + 9);
    if (v5 < 0)
      __asm { BR              X11 }
    serialize_GLPString(a1, *(const char **)(a2 + 16), *(_QWORD *)(a2 + 24));
    serialize_GLPString(a1, *(const char **)(a2 + 32), *(_QWORD *)(a2 + 40));
    v13 = *(_BYTE *)(a2 + 56);
    v14 = *((_DWORD *)a1 + 8);
    v15 = *((unsigned int *)a1 + 9);
    v16 = v15 + 1;
    if ((int)v15 + 1 <= v14)
    {
      v19 = (char *)a1[5];
      v20 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v14 <= 1)
        v14 = 1;
      v17 = 2 * v14;
      if (v17 <= v16)
        v18 = v16;
      else
        v18 = v17;
      v19 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v18, "Vector Storage (uint8_t, growth)");
      memcpy(v19, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v18;
      a1[5] = v19;
      v20 = *((_DWORD *)a1 + 9);
    }
    memmove(&v19[v15 + 1], &v19[v15], (v20 - v15));
    *(_BYTE *)(a1[5] + v15) = v13;
    ++*((_DWORD *)a1 + 9);
    real_serialize_GLPValue(a1, *(_QWORD *)(a2 + 64), *(unsigned int **)a2);
    real_serialize_GLPValue(a1, *(_QWORD *)(a2 + 72), *(unsigned int **)a2);
    serialize_GLPInterfaceBlockObject(a1, *(_QWORD *)(a2 + 80));
    serialize_GLPBufferObject(a1, *(_QWORD *)(a2 + 88));
    v21 = *(_DWORD *)(a2 + 96);
    v22 = (char)glp_serialized_integer32_control(v21);
    v23 = *((_DWORD *)a1 + 8);
    v24 = *((unsigned int *)a1 + 9);
    v25 = v24 + 1;
    if ((int)v24 + 1 <= v23)
    {
      v28 = (char *)a1[5];
      v29 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v23 <= 1)
        v23 = 1;
      v26 = 2 * v23;
      if (v26 <= v25)
        v27 = v25;
      else
        v27 = v26;
      v28 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v27, "Vector Storage (uint8_t, growth)");
      memcpy(v28, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v27;
      a1[5] = v28;
      v29 = *((_DWORD *)a1 + 9);
    }
    memmove(&v28[v24 + 1], &v28[v24], (v29 - v24));
    *(_BYTE *)(a1[5] + v24) = v22;
    v30 = *((_DWORD *)a1 + 9);
    v31 = v30 + 1;
    *((_DWORD *)a1 + 9) = v30 + 1;
    if ((v22 & 0x80000000) != 0)
    {
      switch((v22 >> 1) & 7)
      {
        case 0u:
          v32 = v30 + 2;
          v33 = *((_DWORD *)a1 + 8);
          if (v32 <= v33)
          {
            v36 = (char *)a1[5];
            v37 = v31;
          }
          else
          {
            if (v33 <= 1)
              v33 = 1;
            v34 = 2 * v33;
            if (v34 <= (int)v32)
              v35 = v32;
            else
              v35 = v34;
            v36 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v35, "Vector Storage (uint8_t, growth)");
            memcpy(v36, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v35;
            a1[5] = v36;
            v37 = *((_DWORD *)a1 + 9);
          }
          memmove(&v36[v31 + 1], &v36[v31], v37 - v31);
          *(_BYTE *)(a1[5] + v31) = v21;
          v56 = 1;
          goto LABEL_66;
        case 1u:
          v38 = v30 + 3;
          v39 = *((_DWORD *)a1 + 8);
          if (v38 <= v39)
          {
            v42 = (char *)a1[5];
            v43 = v31;
          }
          else
          {
            if (v39 <= 1)
              v39 = 1;
            v40 = 2 * v39;
            if (v40 <= (int)v38)
              v41 = v38;
            else
              v41 = v40;
            v42 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v41, "Vector Storage (uint8_t, growth)");
            memcpy(v42, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v41;
            a1[5] = v42;
            v43 = *((_DWORD *)a1 + 9);
          }
          memmove(&v42[v31 + 1], &v42[v31], v43 - v31);
          *(_WORD *)(a1[5] + v31) = v21;
          v56 = 2;
          goto LABEL_66;
        case 2u:
          v44 = v30 + 4;
          v45 = *((_DWORD *)a1 + 8);
          if (v44 <= v45)
          {
            v48 = (char *)a1[5];
            v49 = v31;
          }
          else
          {
            if (v45 <= 1)
              v45 = 1;
            v46 = 2 * v45;
            if (v46 <= (int)v44)
              v47 = v44;
            else
              v47 = v46;
            v48 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v47, "Vector Storage (uint8_t, growth)");
            memcpy(v48, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v47;
            a1[5] = v48;
            v49 = *((_DWORD *)a1 + 9);
          }
          memmove(&v48[v31 + 1], &v48[v31], v49 - v31);
          v57 = a1[5] + v31;
          *(_BYTE *)(v57 + 2) = BYTE2(v21);
          *(_WORD *)v57 = v21;
          v56 = 3;
          goto LABEL_66;
        case 3u:
          v50 = v30 + 5;
          v51 = *((_DWORD *)a1 + 8);
          if (v50 <= v51)
          {
            v54 = (char *)a1[5];
            v55 = v31;
          }
          else
          {
            if (v51 <= 1)
              v51 = 1;
            v52 = 2 * v51;
            if (v52 <= (int)v50)
              v53 = v50;
            else
              v53 = v52;
            v54 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v53, "Vector Storage (uint8_t, growth)");
            memcpy(v54, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v53;
            a1[5] = v54;
            v55 = *((_DWORD *)a1 + 9);
          }
          memmove(&v54[v31 + 1], &v54[v31], v55 - v31);
          *(_DWORD *)(a1[5] + v31) = v21;
          v56 = 4;
LABEL_66:
          *((_DWORD *)a1 + 9) += v56;
          break;
        default:
          break;
      }
    }
    v58 = *(unsigned int *)(a2 + 100);
    v59 = (char)glp_serialized_integer32_control(v58);
    v60 = *((_DWORD *)a1 + 8);
    v61 = *((unsigned int *)a1 + 9);
    v62 = v61 + 1;
    if ((int)v61 + 1 <= v60)
    {
      v65 = (char *)a1[5];
      v66 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v60 <= 1)
        v60 = 1;
      v63 = 2 * v60;
      if (v63 <= v62)
        v64 = v62;
      else
        v64 = v63;
      v65 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v64, "Vector Storage (uint8_t, growth)");
      memcpy(v65, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v64;
      a1[5] = v65;
      v66 = *((_DWORD *)a1 + 9);
    }
    result = (uint64_t)memmove(&v65[v61 + 1], &v65[v61], (v66 - v61));
    *(_BYTE *)(a1[5] + v61) = v59;
    v67 = *((_DWORD *)a1 + 9);
    v68 = v67 + 1;
    *((_DWORD *)a1 + 9) = v67 + 1;
    if ((v59 & 0x80000000) != 0)
    {
      switch((v59 >> 1) & 7)
      {
        case 0u:
          v69 = v67 + 2;
          v70 = *((_DWORD *)a1 + 8);
          if (v69 <= v70)
          {
            v73 = (char *)a1[5];
            v74 = v68;
          }
          else
          {
            if (v70 <= 1)
              v70 = 1;
            v71 = 2 * v70;
            if (v71 <= (int)v69)
              v72 = v69;
            else
              v72 = v71;
            v73 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v72, "Vector Storage (uint8_t, growth)");
            memcpy(v73, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v72;
            a1[5] = v73;
            v74 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v73[v68 + 1], &v73[v68], v74 - v68);
          *(_BYTE *)(a1[5] + v68) = v58;
          v93 = 1;
          goto LABEL_113;
        case 1u:
          v75 = v67 + 3;
          v76 = *((_DWORD *)a1 + 8);
          if (v75 <= v76)
          {
            v79 = (char *)a1[5];
            v80 = v68;
          }
          else
          {
            if (v76 <= 1)
              v76 = 1;
            v77 = 2 * v76;
            if (v77 <= (int)v75)
              v78 = v75;
            else
              v78 = v77;
            v79 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v78, "Vector Storage (uint8_t, growth)");
            memcpy(v79, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v78;
            a1[5] = v79;
            v80 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v79[v68 + 1], &v79[v68], v80 - v68);
          *(_WORD *)(a1[5] + v68) = v58;
          v93 = 2;
          goto LABEL_113;
        case 2u:
          v81 = v67 + 4;
          v82 = *((_DWORD *)a1 + 8);
          if (v81 <= v82)
          {
            v85 = (char *)a1[5];
            v86 = v68;
          }
          else
          {
            if (v82 <= 1)
              v82 = 1;
            v83 = 2 * v82;
            if (v83 <= (int)v81)
              v84 = v81;
            else
              v84 = v83;
            v85 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v84, "Vector Storage (uint8_t, growth)");
            memcpy(v85, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v84;
            a1[5] = v85;
            v86 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v85[v68 + 1], &v85[v68], v86 - v68);
          v94 = a1[5] + v68;
          *(_BYTE *)(v94 + 2) = BYTE2(v58);
          *(_WORD *)v94 = v58;
          v93 = 3;
          goto LABEL_113;
        case 3u:
          v87 = v67 + 5;
          v88 = *((_DWORD *)a1 + 8);
          if (v87 <= v88)
          {
            v91 = (char *)a1[5];
            v92 = v68;
          }
          else
          {
            if (v88 <= 1)
              v88 = 1;
            v89 = 2 * v88;
            if (v89 <= (int)v87)
              v90 = v87;
            else
              v90 = v89;
            v91 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v90, "Vector Storage (uint8_t, growth)");
            memcpy(v91, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v90;
            a1[5] = v91;
            v92 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v91[v68 + 1], &v91[v68], v92 - v68);
          *(_DWORD *)(a1[5] + v68) = v58;
          v93 = 4;
LABEL_113:
          *((_DWORD *)a1 + 9) += v93;
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

uint64_t serialize_GLPInterfaceBlockObject(_QWORD *a1, unint64_t a2)
{
  uint64_t result;
  unsigned int VariableObjectCount;
  char v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  char *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;

  result = serialize_pointer(a1, a2);
  if ((_DWORD)result)
  {
    VariableObjectCount = glpInterfaceBlockObjectGetVariableObjectCount(a2);
    serialize_GLPString(a1, *(const char **)a2, *(_QWORD *)(a2 + 8));
    v6 = *(_BYTE *)(a2 + 32);
    v7 = *((_DWORD *)a1 + 8);
    v8 = *((unsigned int *)a1 + 9);
    v9 = v8 + 1;
    if ((int)v8 + 1 <= v7)
    {
      v12 = (char *)a1[5];
      v13 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v7 <= 1)
        v7 = 1;
      v10 = 2 * v7;
      if (v10 <= v9)
        v11 = v9;
      else
        v11 = v10;
      v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
      memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v11;
      a1[5] = v12;
      v13 = *((_DWORD *)a1 + 9);
    }
    memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
    *(_BYTE *)(a1[5] + v8) = v6;
    ++*((_DWORD *)a1 + 9);
    if (*(_BYTE *)(a2 + 32))
      serialize_GLPString(a1, *(const char **)(a2 + 16), *(_QWORD *)(a2 + 24));
    v14 = (char)glp_serialized_integer64_control(*(_QWORD *)(a2 + 40));
    v15 = *((_DWORD *)a1 + 8);
    v16 = *((unsigned int *)a1 + 9);
    v17 = v16 + 1;
    if ((int)v16 + 1 <= v15)
    {
      v20 = (char *)a1[5];
      v21 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v15 <= 1)
        v15 = 1;
      v18 = 2 * v15;
      if (v18 <= v17)
        v19 = v17;
      else
        v19 = v18;
      v20 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v19, "Vector Storage (uint8_t, growth)");
      memcpy(v20, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v19;
      a1[5] = v20;
      v21 = *((_DWORD *)a1 + 9);
    }
    memmove(&v20[v16 + 1], &v20[v16], (v21 - v16));
    *(_BYTE *)(a1[5] + v16) = v14;
    ++*((_DWORD *)a1 + 9);
    if (v14 < 0)
      __asm { BR              X11 }
    serialize_GLPLayoutObject(a1, *(unint64_t **)(a2 + 56));
    serialize_GLPType(a1, *(_QWORD *)(a2 + 64));
    if (VariableObjectCount)
    {
      v22 = 0;
      v23 = 8 * VariableObjectCount;
      do
      {
        serialize_GLPVariableObject(a1, *(_QWORD *)(*(_QWORD *)(a2 + 72) + v22));
        v22 += 8;
      }
      while (v23 != v22);
    }
    return serialize_GLPBufferObject(a1, *(_QWORD *)(a2 + 80));
  }
  return result;
}

uint64_t serialize_GLPBufferObject(_QWORD *a1, unint64_t a2)
{
  uint64_t result;
  unsigned int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  int v18;
  uint64_t v19;
  char *v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  uint64_t v25;
  char *v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  int v30;
  uint64_t v31;
  char *v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  int v36;
  uint64_t v37;
  char *v38;
  unsigned int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  char *v49;
  int v50;
  int v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  int v55;
  uint64_t v56;
  char *v57;
  unsigned int v58;
  unsigned int v59;
  int v60;
  int v61;
  uint64_t v62;
  char *v63;
  unsigned int v64;
  unsigned int v65;
  int v66;
  int v67;
  uint64_t v68;
  char *v69;
  unsigned int v70;
  unsigned int v71;
  int v72;
  int v73;
  uint64_t v74;
  char *v75;
  unsigned int v76;
  int v77;
  uint64_t v78;

  result = serialize_pointer(a1, a2);
  if ((_DWORD)result)
  {
    serialize_GLPType(a1, *(_QWORD *)a2);
    v5 = *(_DWORD *)(a2 + 8);
    v6 = (char)glp_serialized_integer32_control(v5);
    v7 = *((_DWORD *)a1 + 8);
    v8 = *((unsigned int *)a1 + 9);
    v9 = v8 + 1;
    if ((int)v8 + 1 <= v7)
    {
      v12 = (char *)a1[5];
      v13 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v7 <= 1)
        v7 = 1;
      v10 = 2 * v7;
      if (v10 <= v9)
        v11 = v9;
      else
        v11 = v10;
      v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
      memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v11;
      a1[5] = v12;
      v13 = *((_DWORD *)a1 + 9);
    }
    memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
    *(_BYTE *)(a1[5] + v8) = v6;
    v14 = *((_DWORD *)a1 + 9);
    v15 = v14 + 1;
    *((_DWORD *)a1 + 9) = v14 + 1;
    if ((v6 & 0x80000000) != 0)
    {
      switch((v6 >> 1) & 7)
      {
        case 0u:
          v16 = v14 + 2;
          v17 = *((_DWORD *)a1 + 8);
          if (v16 <= v17)
          {
            v20 = (char *)a1[5];
            v21 = v15;
          }
          else
          {
            if (v17 <= 1)
              v17 = 1;
            v18 = 2 * v17;
            if (v18 <= (int)v16)
              v19 = v16;
            else
              v19 = v18;
            v20 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v19, "Vector Storage (uint8_t, growth)");
            memcpy(v20, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v19;
            a1[5] = v20;
            v21 = *((_DWORD *)a1 + 9);
          }
          memmove(&v20[v15 + 1], &v20[v15], v21 - v15);
          *(_BYTE *)(a1[5] + v15) = v5;
          v40 = 1;
          goto LABEL_48;
        case 1u:
          v34 = v14 + 3;
          v35 = *((_DWORD *)a1 + 8);
          if (v34 <= v35)
          {
            v38 = (char *)a1[5];
            v39 = v15;
          }
          else
          {
            if (v35 <= 1)
              v35 = 1;
            v36 = 2 * v35;
            if (v36 <= (int)v34)
              v37 = v34;
            else
              v37 = v36;
            v38 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v37, "Vector Storage (uint8_t, growth)");
            memcpy(v38, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v37;
            a1[5] = v38;
            v39 = *((_DWORD *)a1 + 9);
          }
          memmove(&v38[v15 + 1], &v38[v15], v39 - v15);
          *(_WORD *)(a1[5] + v15) = v5;
          v40 = 2;
          goto LABEL_48;
        case 2u:
          v22 = v14 + 4;
          v23 = *((_DWORD *)a1 + 8);
          if (v22 <= v23)
          {
            v26 = (char *)a1[5];
            v27 = v15;
          }
          else
          {
            if (v23 <= 1)
              v23 = 1;
            v24 = 2 * v23;
            if (v24 <= (int)v22)
              v25 = v22;
            else
              v25 = v24;
            v26 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v25, "Vector Storage (uint8_t, growth)");
            memcpy(v26, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v25;
            a1[5] = v26;
            v27 = *((_DWORD *)a1 + 9);
          }
          memmove(&v26[v15 + 1], &v26[v15], v27 - v15);
          v41 = a1[5] + v15;
          *(_BYTE *)(v41 + 2) = BYTE2(v5);
          *(_WORD *)v41 = v5;
          v40 = 3;
          goto LABEL_48;
        case 3u:
          v28 = v14 + 5;
          v29 = *((_DWORD *)a1 + 8);
          if (v28 <= v29)
          {
            v32 = (char *)a1[5];
            v33 = v15;
          }
          else
          {
            if (v29 <= 1)
              v29 = 1;
            v30 = 2 * v29;
            if (v30 <= (int)v28)
              v31 = v28;
            else
              v31 = v30;
            v32 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v31, "Vector Storage (uint8_t, growth)");
            memcpy(v32, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v31;
            a1[5] = v32;
            v33 = *((_DWORD *)a1 + 9);
          }
          memmove(&v32[v15 + 1], &v32[v15], v33 - v15);
          *(_DWORD *)(a1[5] + v15) = v5;
          v40 = 4;
LABEL_48:
          *((_DWORD *)a1 + 9) += v40;
          break;
        default:
          break;
      }
    }
    v42 = *(unsigned int *)(a2 + 12);
    v43 = (char)glp_serialized_integer32_control(v42);
    v44 = *((_DWORD *)a1 + 8);
    v45 = *((unsigned int *)a1 + 9);
    v46 = v45 + 1;
    if ((int)v45 + 1 <= v44)
    {
      v49 = (char *)a1[5];
      v50 = *((_DWORD *)a1 + 9);
    }
    else
    {
      if (v44 <= 1)
        v44 = 1;
      v47 = 2 * v44;
      if (v47 <= v46)
        v48 = v46;
      else
        v48 = v47;
      v49 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v48, "Vector Storage (uint8_t, growth)");
      memcpy(v49, (const void *)a1[5], *((unsigned int *)a1 + 9));
      ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
      *((_DWORD *)a1 + 8) = v48;
      a1[5] = v49;
      v50 = *((_DWORD *)a1 + 9);
    }
    result = (uint64_t)memmove(&v49[v45 + 1], &v49[v45], (v50 - v45));
    *(_BYTE *)(a1[5] + v45) = v43;
    v51 = *((_DWORD *)a1 + 9);
    v52 = v51 + 1;
    *((_DWORD *)a1 + 9) = v51 + 1;
    if ((v43 & 0x80000000) != 0)
    {
      switch((v43 >> 1) & 7)
      {
        case 0u:
          v53 = v51 + 2;
          v54 = *((_DWORD *)a1 + 8);
          if (v53 <= v54)
          {
            v57 = (char *)a1[5];
            v58 = v52;
          }
          else
          {
            if (v54 <= 1)
              v54 = 1;
            v55 = 2 * v54;
            if (v55 <= (int)v53)
              v56 = v53;
            else
              v56 = v55;
            v57 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v56, "Vector Storage (uint8_t, growth)");
            memcpy(v57, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v56;
            a1[5] = v57;
            v58 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v57[v52 + 1], &v57[v52], v58 - v52);
          *(_BYTE *)(a1[5] + v52) = v42;
          v77 = 1;
          goto LABEL_95;
        case 1u:
          v71 = v51 + 3;
          v72 = *((_DWORD *)a1 + 8);
          if (v71 <= v72)
          {
            v75 = (char *)a1[5];
            v76 = v52;
          }
          else
          {
            if (v72 <= 1)
              v72 = 1;
            v73 = 2 * v72;
            if (v73 <= (int)v71)
              v74 = v71;
            else
              v74 = v73;
            v75 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v74, "Vector Storage (uint8_t, growth)");
            memcpy(v75, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v74;
            a1[5] = v75;
            v76 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v75[v52 + 1], &v75[v52], v76 - v52);
          *(_WORD *)(a1[5] + v52) = v42;
          v77 = 2;
          goto LABEL_95;
        case 2u:
          v59 = v51 + 4;
          v60 = *((_DWORD *)a1 + 8);
          if (v59 <= v60)
          {
            v63 = (char *)a1[5];
            v64 = v52;
          }
          else
          {
            if (v60 <= 1)
              v60 = 1;
            v61 = 2 * v60;
            if (v61 <= (int)v59)
              v62 = v59;
            else
              v62 = v61;
            v63 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v62, "Vector Storage (uint8_t, growth)");
            memcpy(v63, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v62;
            a1[5] = v63;
            v64 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v63[v52 + 1], &v63[v52], v64 - v52);
          v78 = a1[5] + v52;
          *(_BYTE *)(v78 + 2) = BYTE2(v42);
          *(_WORD *)v78 = v42;
          v77 = 3;
          goto LABEL_95;
        case 3u:
          v65 = v51 + 5;
          v66 = *((_DWORD *)a1 + 8);
          if (v65 <= v66)
          {
            v69 = (char *)a1[5];
            v70 = v52;
          }
          else
          {
            if (v66 <= 1)
              v66 = 1;
            v67 = 2 * v66;
            if (v67 <= (int)v65)
              v68 = v65;
            else
              v68 = v67;
            v69 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v68, "Vector Storage (uint8_t, growth)");
            memcpy(v69, (const void *)a1[5], *((unsigned int *)a1 + 9));
            ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
            *((_DWORD *)a1 + 8) = v68;
            a1[5] = v69;
            v70 = *((_DWORD *)a1 + 9);
          }
          result = (uint64_t)memmove(&v69[v52 + 1], &v69[v52], v70 - v52);
          *(_DWORD *)(a1[5] + v52) = v42;
          v77 = 4;
LABEL_95:
          *((_DWORD *)a1 + 9) += v77;
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

void *serializeTypeConversionFields(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  void *result;

  serializeASTFields(a1, a2);
  v4 = glpTypeConversionNodeGetToType(a2);
  serialize_GLPType(a1, v4);
  v5 = glpTypeConversionNodeGetToPrecision(a2);
  v6 = (char)glp_serialized_integer64_control(v5);
  v7 = *((_DWORD *)a1 + 8);
  v8 = *((unsigned int *)a1 + 9);
  v9 = v8 + 1;
  if ((int)v8 + 1 <= v7)
  {
    v12 = (char *)a1[5];
    v13 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v7 <= 1)
      v7 = 1;
    v10 = 2 * v7;
    if (v10 <= v9)
      v11 = v9;
    else
      v11 = v10;
    v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
    memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v11;
    a1[5] = v12;
    v13 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
  *(_BYTE *)(a1[5] + v8) = v6;
  ++*((_DWORD *)a1 + 9);
  if (v6 < 0)
    __asm { BR              X11 }
  return result;
}

uint64_t serializeVariableIdentifierFields(_QWORD *a1, uint64_t a2)
{
  const char *Name;
  uint64_t v5;

  serializeASTFields(a1, a2);
  Name = (const char *)glpVariableIdentifierNodeGetName(a2);
  return serialize_GLPString(a1, Name, v5);
}

uint64_t serializeTypeIdentifierFields(_QWORD *a1, uint64_t a2)
{
  const char *Name;
  uint64_t v5;

  serializeASTFields(a1, a2);
  Name = (const char *)glpTypeIdentifierNodeGetName(a2);
  return serialize_GLPString(a1, Name, v5);
}

uint64_t serializeConstantFields(_QWORD *a1, uint64_t a2)
{
  uint64_t Type;
  unint64_t Value;
  unsigned int *v6;

  serializeASTFields(a1, a2);
  Type = glpConstantNodeGetType(a2);
  serialize_GLPType(a1, Type);
  Value = glpConstantNodeGetValue(a2);
  v6 = (unsigned int *)glpConstantNodeGetType(a2);
  return real_serialize_GLPValue(a1, Value, v6);
}

uint64_t serializeFieldAccessFields(_QWORD *a1, uint64_t a2)
{
  const char *Field;
  uint64_t v5;

  serializeASTFields(a1, a2);
  Field = (const char *)glpFieldAccessNodeGetField(a2);
  return serialize_GLPString(a1, Field, v5);
}

uint64_t serializeFunctionCallFields(_QWORD *a1, uint64_t a2)
{
  const char *v4;
  uint64_t v5;
  uint64_t v6;

  serializeCallFields(a1, a2);
  v4 = (const char *)glpFunctionCallNodeGetName(a2);
  serialize_GLPString(a1, v4, v5);
  v6 = glpFunctionCallNodeGetExtra(a2);
  return serialize_GLPFunctionObject(a1, v6);
}

uint64_t serializeSubroutineArrayCallFields(_QWORD *a1, uint64_t a2)
{
  const char *v4;
  uint64_t v5;

  serializeCallFields(a1, a2);
  v4 = (const char *)glpSubroutineArrayCallNodeGetName(a2);
  return serialize_GLPString(a1, v4, v5);
}

uint64_t serializeMethodCallFields(_QWORD *a1, uint64_t a2)
{
  const char *v4;
  uint64_t v5;

  serializeCallFields(a1, a2);
  v4 = (const char *)glpMethodCallNodeGetName(a2);
  return serialize_GLPString(a1, v4, v5);
}

void *serializeEqualFields(_QWORD *a1, uint64_t a2)
{
  char v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  char *v10;
  int v11;
  void *result;

  serializeASTFields(a1, a2);
  v4 = glpEqualNodeGetIsFromSource(a2);
  v5 = *((_DWORD *)a1 + 8);
  v6 = *((unsigned int *)a1 + 9);
  v7 = v6 + 1;
  if ((int)v6 + 1 <= v5)
  {
    v10 = (char *)a1[5];
    v11 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v5 <= 1)
      v5 = 1;
    v8 = 2 * v5;
    if (v8 <= v7)
      v9 = v7;
    else
      v9 = v8;
    v10 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v9, "Vector Storage (uint8_t, growth)");
    memcpy(v10, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v9;
    a1[5] = v10;
    v11 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v10[v6 + 1], &v10[v6], (v11 - v6));
  *(_BYTE *)(a1[5] + v6) = v4;
  ++*((_DWORD *)a1 + 9);
  return result;
}

void *serializeNotEqualFields(_QWORD *a1, uint64_t a2)
{
  char v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  char *v10;
  int v11;
  void *result;

  serializeASTFields(a1, a2);
  v4 = glpNotEqualNodeGetIsFromSource(a2);
  v5 = *((_DWORD *)a1 + 8);
  v6 = *((unsigned int *)a1 + 9);
  v7 = v6 + 1;
  if ((int)v6 + 1 <= v5)
  {
    v10 = (char *)a1[5];
    v11 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v5 <= 1)
      v5 = 1;
    v8 = 2 * v5;
    if (v8 <= v7)
      v9 = v7;
    else
      v9 = v8;
    v10 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v9, "Vector Storage (uint8_t, growth)");
    memcpy(v10, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v9;
    a1[5] = v10;
    v11 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v10[v6 + 1], &v10[v6], (v11 - v6));
  *(_BYTE *)(a1[5] + v6) = v4;
  ++*((_DWORD *)a1 + 9);
  return result;
}

void *serializeAssignFields(_QWORD *a1, uint64_t a2)
{
  char v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  char *v10;
  int v11;
  void *result;

  serializeASTFields(a1, a2);
  v4 = glpAssignNodeGetIsFromSource(a2);
  v5 = *((_DWORD *)a1 + 8);
  v6 = *((unsigned int *)a1 + 9);
  v7 = v6 + 1;
  if ((int)v6 + 1 <= v5)
  {
    v10 = (char *)a1[5];
    v11 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v5 <= 1)
      v5 = 1;
    v8 = 2 * v5;
    if (v8 <= v7)
      v9 = v7;
    else
      v9 = v8;
    v10 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v9, "Vector Storage (uint8_t, growth)");
    memcpy(v10, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v9;
    a1[5] = v10;
    v11 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v10[v6 + 1], &v10[v6], (v11 - v6));
  *(_BYTE *)(a1[5] + v6) = v4;
  ++*((_DWORD *)a1 + 9);
  return result;
}

void serializeOpAssignFields(_QWORD *a1, uint64_t a2)
{
  serializeASTFields(a1, a2);
  glpOpAssignNodeGetDesugar(a2);
  abort();
}

uint64_t serializeReadInputFields(_QWORD *a1, uint64_t a2)
{
  unint64_t Extra;

  serializeASTFields(a1, a2);
  Extra = glpReadInputNodeGetExtra(a2);
  return serialize_GLPVariableObject(a1, Extra);
}

uint64_t serializeWriteOutputFields(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;

  serializeASTFields(a1, a2);
  v4 = glpWriteOutputNodeGetExtra(a2);
  return serialize_GLPVariableObject(a1, v4);
}

void *serializeCommaExprFields(_QWORD *a1, uint64_t a2)
{
  char v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  char *v10;
  int v11;
  uint64_t ExprCount;
  int v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  char *v20;
  int v21;
  void *result;
  int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  int v27;
  uint64_t v28;
  char *v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  int v33;
  uint64_t v34;
  char *v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  int v39;
  uint64_t v40;
  char *v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  int v45;
  uint64_t v46;
  char *v47;
  unsigned int v48;
  int v49;
  uint64_t v50;

  serializeASTFields(a1, a2);
  v4 = glpCommaExprNodeGetIsFromSource(a2);
  v5 = *((_DWORD *)a1 + 8);
  v6 = *((unsigned int *)a1 + 9);
  v7 = v6 + 1;
  if ((int)v6 + 1 <= v5)
  {
    v10 = (char *)a1[5];
    v11 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v5 <= 1)
      v5 = 1;
    v8 = 2 * v5;
    if (v8 <= v7)
      v9 = v7;
    else
      v9 = v8;
    v10 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v9, "Vector Storage (uint8_t, growth)");
    memcpy(v10, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v9;
    a1[5] = v10;
    v11 = *((_DWORD *)a1 + 9);
  }
  memmove(&v10[v6 + 1], &v10[v6], (v11 - v6));
  *(_BYTE *)(a1[5] + v6) = v4;
  ++*((_DWORD *)a1 + 9);
  ExprCount = glpCommaExprNodeGetExprCount(a2);
  v13 = ExprCount;
  v14 = (char)glp_serialized_integer32_control(ExprCount);
  v15 = *((_DWORD *)a1 + 8);
  v16 = *((unsigned int *)a1 + 9);
  v17 = v16 + 1;
  if ((int)v16 + 1 <= v15)
  {
    v20 = (char *)a1[5];
    v21 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v15 <= 1)
      v15 = 1;
    v18 = 2 * v15;
    if (v18 <= v17)
      v19 = v17;
    else
      v19 = v18;
    v20 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v19, "Vector Storage (uint8_t, growth)");
    memcpy(v20, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v19;
    a1[5] = v20;
    v21 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v20[v16 + 1], &v20[v16], (v21 - v16));
  *(_BYTE *)(a1[5] + v16) = v14;
  v23 = *((_DWORD *)a1 + 9);
  v24 = v23 + 1;
  *((_DWORD *)a1 + 9) = v23 + 1;
  if ((v14 & 0x80000000) != 0)
  {
    switch((v14 >> 1) & 7)
    {
      case 0u:
        v25 = v23 + 2;
        v26 = *((_DWORD *)a1 + 8);
        if (v25 <= v26)
        {
          v29 = (char *)a1[5];
          v30 = v24;
        }
        else
        {
          if (v26 <= 1)
            v26 = 1;
          v27 = 2 * v26;
          if (v27 <= (int)v25)
            v28 = v25;
          else
            v28 = v27;
          v29 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v28, "Vector Storage (uint8_t, growth)");
          memcpy(v29, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v28;
          a1[5] = v29;
          v30 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v29[v24 + 1], &v29[v24], v30 - v24);
        *(_BYTE *)(a1[5] + v24) = v13;
        v49 = 1;
        goto LABEL_55;
      case 1u:
        v43 = v23 + 3;
        v44 = *((_DWORD *)a1 + 8);
        if (v43 <= v44)
        {
          v47 = (char *)a1[5];
          v48 = v24;
        }
        else
        {
          if (v44 <= 1)
            v44 = 1;
          v45 = 2 * v44;
          if (v45 <= (int)v43)
            v46 = v43;
          else
            v46 = v45;
          v47 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v46, "Vector Storage (uint8_t, growth)");
          memcpy(v47, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v46;
          a1[5] = v47;
          v48 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v47[v24 + 1], &v47[v24], v48 - v24);
        *(_WORD *)(a1[5] + v24) = v13;
        v49 = 2;
        goto LABEL_55;
      case 2u:
        v31 = v23 + 4;
        v32 = *((_DWORD *)a1 + 8);
        if (v31 <= v32)
        {
          v35 = (char *)a1[5];
          v36 = v24;
        }
        else
        {
          if (v32 <= 1)
            v32 = 1;
          v33 = 2 * v32;
          if (v33 <= (int)v31)
            v34 = v31;
          else
            v34 = v33;
          v35 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v34, "Vector Storage (uint8_t, growth)");
          memcpy(v35, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v34;
          a1[5] = v35;
          v36 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v35[v24 + 1], &v35[v24], v36 - v24);
        v50 = a1[5] + v24;
        *(_BYTE *)(v50 + 2) = BYTE2(v13);
        *(_WORD *)v50 = v13;
        v49 = 3;
        goto LABEL_55;
      case 3u:
        v37 = v23 + 5;
        v38 = *((_DWORD *)a1 + 8);
        if (v37 <= v38)
        {
          v41 = (char *)a1[5];
          v42 = v24;
        }
        else
        {
          if (v38 <= 1)
            v38 = 1;
          v39 = 2 * v38;
          if (v39 <= (int)v37)
            v40 = v37;
          else
            v40 = v39;
          v41 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v40, "Vector Storage (uint8_t, growth)");
          memcpy(v41, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v40;
          a1[5] = v41;
          v42 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v41[v24 + 1], &v41[v24], v42 - v24);
        *(_DWORD *)(a1[5] + v24) = v13;
        v49 = 4;
LABEL_55:
        *((_DWORD *)a1 + 9) += v49;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t serializeParameterDeclarationFields(_QWORD *a1, uint64_t a2)
{
  const char *Name;
  uint64_t v5;
  unint64_t Extra;

  serializeASTFields(a1, a2);
  Name = (const char *)glpParameterDeclarationNodeGetName(a2);
  serialize_GLPString(a1, Name, v5);
  Extra = glpParameterDeclarationNodeGetExtra(a2);
  return serialize_GLPVariableObject(a1, Extra);
}

void *serializeFunctionPrototypeFields(_QWORD *a1, uint64_t a2)
{
  const char *Name;
  uint64_t v5;
  uint64_t Extra;
  uint64_t ParameterCount;
  int v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  char *v15;
  int v16;
  void *result;
  int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  int v22;
  uint64_t v23;
  char *v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  int v28;
  uint64_t v29;
  char *v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  int v34;
  uint64_t v35;
  char *v36;
  unsigned int v37;
  unsigned int v38;
  int v39;
  int v40;
  uint64_t v41;
  char *v42;
  unsigned int v43;
  int v44;
  uint64_t v45;

  serializeASTFields(a1, a2);
  Name = (const char *)glpFunctionPrototypeNodeGetName(a2);
  serialize_GLPString(a1, Name, v5);
  Extra = glpFunctionPrototypeNodeGetExtra(a2);
  serialize_GLPFunctionObject(a1, Extra);
  ParameterCount = glpFunctionPrototypeNodeGetParameterCount(a2);
  v8 = ParameterCount;
  v9 = (char)glp_serialized_integer32_control(ParameterCount);
  v10 = *((_DWORD *)a1 + 8);
  v11 = *((unsigned int *)a1 + 9);
  v12 = v11 + 1;
  if ((int)v11 + 1 <= v10)
  {
    v15 = (char *)a1[5];
    v16 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v10 <= 1)
      v10 = 1;
    v13 = 2 * v10;
    if (v13 <= v12)
      v14 = v12;
    else
      v14 = v13;
    v15 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v14, "Vector Storage (uint8_t, growth)");
    memcpy(v15, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v14;
    a1[5] = v15;
    v16 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v15[v11 + 1], &v15[v11], (v16 - v11));
  *(_BYTE *)(a1[5] + v11) = v9;
  v18 = *((_DWORD *)a1 + 9);
  v19 = v18 + 1;
  *((_DWORD *)a1 + 9) = v18 + 1;
  if ((v9 & 0x80000000) != 0)
  {
    switch((v9 >> 1) & 7)
    {
      case 0u:
        v20 = v18 + 2;
        v21 = *((_DWORD *)a1 + 8);
        if (v20 <= v21)
        {
          v24 = (char *)a1[5];
          v25 = v19;
        }
        else
        {
          if (v21 <= 1)
            v21 = 1;
          v22 = 2 * v21;
          if (v22 <= (int)v20)
            v23 = v20;
          else
            v23 = v22;
          v24 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v23, "Vector Storage (uint8_t, growth)");
          memcpy(v24, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v23;
          a1[5] = v24;
          v25 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v24[v19 + 1], &v24[v19], v25 - v19);
        *(_BYTE *)(a1[5] + v19) = v8;
        v44 = 1;
        goto LABEL_47;
      case 1u:
        v38 = v18 + 3;
        v39 = *((_DWORD *)a1 + 8);
        if (v38 <= v39)
        {
          v42 = (char *)a1[5];
          v43 = v19;
        }
        else
        {
          if (v39 <= 1)
            v39 = 1;
          v40 = 2 * v39;
          if (v40 <= (int)v38)
            v41 = v38;
          else
            v41 = v40;
          v42 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v41, "Vector Storage (uint8_t, growth)");
          memcpy(v42, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v41;
          a1[5] = v42;
          v43 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v42[v19 + 1], &v42[v19], v43 - v19);
        *(_WORD *)(a1[5] + v19) = v8;
        v44 = 2;
        goto LABEL_47;
      case 2u:
        v26 = v18 + 4;
        v27 = *((_DWORD *)a1 + 8);
        if (v26 <= v27)
        {
          v30 = (char *)a1[5];
          v31 = v19;
        }
        else
        {
          if (v27 <= 1)
            v27 = 1;
          v28 = 2 * v27;
          if (v28 <= (int)v26)
            v29 = v26;
          else
            v29 = v28;
          v30 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v29, "Vector Storage (uint8_t, growth)");
          memcpy(v30, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v29;
          a1[5] = v30;
          v31 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v30[v19 + 1], &v30[v19], v31 - v19);
        v45 = a1[5] + v19;
        *(_BYTE *)(v45 + 2) = BYTE2(v8);
        *(_WORD *)v45 = v8;
        v44 = 3;
        goto LABEL_47;
      case 3u:
        v32 = v18 + 5;
        v33 = *((_DWORD *)a1 + 8);
        if (v32 <= v33)
        {
          v36 = (char *)a1[5];
          v37 = v19;
        }
        else
        {
          if (v33 <= 1)
            v33 = 1;
          v34 = 2 * v33;
          if (v34 <= (int)v32)
            v35 = v32;
          else
            v35 = v34;
          v36 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v35, "Vector Storage (uint8_t, growth)");
          memcpy(v36, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v35;
          a1[5] = v36;
          v37 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v36[v19 + 1], &v36[v19], v37 - v19);
        *(_DWORD *)(a1[5] + v19) = v8;
        v44 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v44;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t serializeVariableDeclarationFields(_QWORD *a1, uint64_t a2)
{
  const char *Name;
  uint64_t v5;
  char v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  unint64_t Extra;

  serializeASTFields(a1, a2);
  Name = (const char *)glpVariableDeclarationNodeGetName(a2);
  serialize_GLPString(a1, Name, v5);
  v6 = glpVariableDeclarationNodeGetIsFromSource(a2);
  v7 = *((_DWORD *)a1 + 8);
  v8 = *((unsigned int *)a1 + 9);
  v9 = v8 + 1;
  if ((int)v8 + 1 <= v7)
  {
    v12 = (char *)a1[5];
    v13 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v7 <= 1)
      v7 = 1;
    v10 = 2 * v7;
    if (v10 <= v9)
      v11 = v9;
    else
      v11 = v10;
    v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
    memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v11;
    a1[5] = v12;
    v13 = *((_DWORD *)a1 + 9);
  }
  memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
  *(_BYTE *)(a1[5] + v8) = v6;
  ++*((_DWORD *)a1 + 9);
  Extra = glpVariableDeclarationNodeGetExtra(a2);
  return serialize_GLPVariableObject(a1, Extra);
}

void *serializeVariableDeclarationGroupFields(_QWORD *a1, uint64_t a2)
{
  uint64_t DeclarationCount;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  void *result;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  int v41;
  uint64_t v42;

  serializeASTFields(a1, a2);
  DeclarationCount = glpVariableDeclarationGroupNodeGetDeclarationCount(a2);
  v5 = DeclarationCount;
  v6 = (char)glp_serialized_integer32_control(DeclarationCount);
  v7 = *((_DWORD *)a1 + 8);
  v8 = *((unsigned int *)a1 + 9);
  v9 = v8 + 1;
  if ((int)v8 + 1 <= v7)
  {
    v12 = (char *)a1[5];
    v13 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v7 <= 1)
      v7 = 1;
    v10 = 2 * v7;
    if (v10 <= v9)
      v11 = v9;
    else
      v11 = v10;
    v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
    memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v11;
    a1[5] = v12;
    v13 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
  *(_BYTE *)(a1[5] + v8) = v6;
  v15 = *((_DWORD *)a1 + 9);
  v16 = v15 + 1;
  *((_DWORD *)a1 + 9) = v15 + 1;
  if ((v6 & 0x80000000) != 0)
  {
    switch((v6 >> 1) & 7)
    {
      case 0u:
        v17 = v15 + 2;
        v18 = *((_DWORD *)a1 + 8);
        if (v17 <= v18)
        {
          v21 = (char *)a1[5];
          v22 = v16;
        }
        else
        {
          if (v18 <= 1)
            v18 = 1;
          v19 = 2 * v18;
          if (v19 <= (int)v17)
            v20 = v17;
          else
            v20 = v19;
          v21 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v20, "Vector Storage (uint8_t, growth)");
          memcpy(v21, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v20;
          a1[5] = v21;
          v22 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v21[v16 + 1], &v21[v16], v22 - v16);
        *(_BYTE *)(a1[5] + v16) = v5;
        v41 = 1;
        goto LABEL_47;
      case 1u:
        v35 = v15 + 3;
        v36 = *((_DWORD *)a1 + 8);
        if (v35 <= v36)
        {
          v39 = (char *)a1[5];
          v40 = v16;
        }
        else
        {
          if (v36 <= 1)
            v36 = 1;
          v37 = 2 * v36;
          if (v37 <= (int)v35)
            v38 = v35;
          else
            v38 = v37;
          v39 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v38, "Vector Storage (uint8_t, growth)");
          memcpy(v39, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v38;
          a1[5] = v39;
          v40 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v39[v16 + 1], &v39[v16], v40 - v16);
        *(_WORD *)(a1[5] + v16) = v5;
        v41 = 2;
        goto LABEL_47;
      case 2u:
        v23 = v15 + 4;
        v24 = *((_DWORD *)a1 + 8);
        if (v23 <= v24)
        {
          v27 = (char *)a1[5];
          v28 = v16;
        }
        else
        {
          if (v24 <= 1)
            v24 = 1;
          v25 = 2 * v24;
          if (v25 <= (int)v23)
            v26 = v23;
          else
            v26 = v25;
          v27 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v26, "Vector Storage (uint8_t, growth)");
          memcpy(v27, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v26;
          a1[5] = v27;
          v28 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v27[v16 + 1], &v27[v16], v28 - v16);
        v42 = a1[5] + v16;
        *(_BYTE *)(v42 + 2) = BYTE2(v5);
        *(_WORD *)v42 = v5;
        v41 = 3;
        goto LABEL_47;
      case 3u:
        v29 = v15 + 5;
        v30 = *((_DWORD *)a1 + 8);
        if (v29 <= v30)
        {
          v33 = (char *)a1[5];
          v34 = v16;
        }
        else
        {
          if (v30 <= 1)
            v30 = 1;
          v31 = 2 * v30;
          if (v31 <= (int)v29)
            v32 = v29;
          else
            v32 = v31;
          v33 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v32, "Vector Storage (uint8_t, growth)");
          memcpy(v33, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v32;
          a1[5] = v33;
          v34 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v33[v16 + 1], &v33[v16], v34 - v16);
        *(_DWORD *)(a1[5] + v16) = v5;
        v41 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v41;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t serializeQualifiedDeclarationFields(_QWORD *a1, uint64_t a2)
{
  const char *Name;
  uint64_t v5;

  serializeASTFields(a1, a2);
  Name = (const char *)glpQualifiedDeclarationNodeGetName(a2);
  return serialize_GLPString(a1, Name, v5);
}

void *serializeQualifiedDeclarationGroupFields(_QWORD *a1, uint64_t a2)
{
  uint64_t DeclarationCount;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  void *result;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  int v41;
  uint64_t v42;

  serializeASTFields(a1, a2);
  DeclarationCount = glpQualifiedDeclarationGroupNodeGetDeclarationCount(a2);
  v5 = DeclarationCount;
  v6 = (char)glp_serialized_integer32_control(DeclarationCount);
  v7 = *((_DWORD *)a1 + 8);
  v8 = *((unsigned int *)a1 + 9);
  v9 = v8 + 1;
  if ((int)v8 + 1 <= v7)
  {
    v12 = (char *)a1[5];
    v13 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v7 <= 1)
      v7 = 1;
    v10 = 2 * v7;
    if (v10 <= v9)
      v11 = v9;
    else
      v11 = v10;
    v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
    memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v11;
    a1[5] = v12;
    v13 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
  *(_BYTE *)(a1[5] + v8) = v6;
  v15 = *((_DWORD *)a1 + 9);
  v16 = v15 + 1;
  *((_DWORD *)a1 + 9) = v15 + 1;
  if ((v6 & 0x80000000) != 0)
  {
    switch((v6 >> 1) & 7)
    {
      case 0u:
        v17 = v15 + 2;
        v18 = *((_DWORD *)a1 + 8);
        if (v17 <= v18)
        {
          v21 = (char *)a1[5];
          v22 = v16;
        }
        else
        {
          if (v18 <= 1)
            v18 = 1;
          v19 = 2 * v18;
          if (v19 <= (int)v17)
            v20 = v17;
          else
            v20 = v19;
          v21 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v20, "Vector Storage (uint8_t, growth)");
          memcpy(v21, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v20;
          a1[5] = v21;
          v22 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v21[v16 + 1], &v21[v16], v22 - v16);
        *(_BYTE *)(a1[5] + v16) = v5;
        v41 = 1;
        goto LABEL_47;
      case 1u:
        v35 = v15 + 3;
        v36 = *((_DWORD *)a1 + 8);
        if (v35 <= v36)
        {
          v39 = (char *)a1[5];
          v40 = v16;
        }
        else
        {
          if (v36 <= 1)
            v36 = 1;
          v37 = 2 * v36;
          if (v37 <= (int)v35)
            v38 = v35;
          else
            v38 = v37;
          v39 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v38, "Vector Storage (uint8_t, growth)");
          memcpy(v39, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v38;
          a1[5] = v39;
          v40 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v39[v16 + 1], &v39[v16], v40 - v16);
        *(_WORD *)(a1[5] + v16) = v5;
        v41 = 2;
        goto LABEL_47;
      case 2u:
        v23 = v15 + 4;
        v24 = *((_DWORD *)a1 + 8);
        if (v23 <= v24)
        {
          v27 = (char *)a1[5];
          v28 = v16;
        }
        else
        {
          if (v24 <= 1)
            v24 = 1;
          v25 = 2 * v24;
          if (v25 <= (int)v23)
            v26 = v23;
          else
            v26 = v25;
          v27 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v26, "Vector Storage (uint8_t, growth)");
          memcpy(v27, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v26;
          a1[5] = v27;
          v28 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v27[v16 + 1], &v27[v16], v28 - v16);
        v42 = a1[5] + v16;
        *(_BYTE *)(v42 + 2) = BYTE2(v5);
        *(_WORD *)v42 = v5;
        v41 = 3;
        goto LABEL_47;
      case 3u:
        v29 = v15 + 5;
        v30 = *((_DWORD *)a1 + 8);
        if (v29 <= v30)
        {
          v33 = (char *)a1[5];
          v34 = v16;
        }
        else
        {
          if (v30 <= 1)
            v30 = 1;
          v31 = 2 * v30;
          if (v31 <= (int)v29)
            v32 = v29;
          else
            v32 = v31;
          v33 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v32, "Vector Storage (uint8_t, growth)");
          memcpy(v33, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v32;
          a1[5] = v33;
          v34 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v33[v16 + 1], &v33[v16], v34 - v16);
        *(_DWORD *)(a1[5] + v16) = v5;
        v41 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v41;
        break;
      default:
        return result;
    }
  }
  return result;
}

void *serializePrimitiveTypeFields(_QWORD *a1, uint64_t a2)
{
  uint64_t Type;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  void *result;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  int v41;
  uint64_t v42;

  serializeASTFields(a1, a2);
  Type = glpPrimitiveTypeNodeGetType(a2);
  v5 = Type;
  v6 = (char)glp_serialized_integer32_control(Type);
  v7 = *((_DWORD *)a1 + 8);
  v8 = *((unsigned int *)a1 + 9);
  v9 = v8 + 1;
  if ((int)v8 + 1 <= v7)
  {
    v12 = (char *)a1[5];
    v13 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v7 <= 1)
      v7 = 1;
    v10 = 2 * v7;
    if (v10 <= v9)
      v11 = v9;
    else
      v11 = v10;
    v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
    memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v11;
    a1[5] = v12;
    v13 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
  *(_BYTE *)(a1[5] + v8) = v6;
  v15 = *((_DWORD *)a1 + 9);
  v16 = v15 + 1;
  *((_DWORD *)a1 + 9) = v15 + 1;
  if ((v6 & 0x80000000) != 0)
  {
    switch((v6 >> 1) & 7)
    {
      case 0u:
        v17 = v15 + 2;
        v18 = *((_DWORD *)a1 + 8);
        if (v17 <= v18)
        {
          v21 = (char *)a1[5];
          v22 = v16;
        }
        else
        {
          if (v18 <= 1)
            v18 = 1;
          v19 = 2 * v18;
          if (v19 <= (int)v17)
            v20 = v17;
          else
            v20 = v19;
          v21 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v20, "Vector Storage (uint8_t, growth)");
          memcpy(v21, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v20;
          a1[5] = v21;
          v22 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v21[v16 + 1], &v21[v16], v22 - v16);
        *(_BYTE *)(a1[5] + v16) = v5;
        v41 = 1;
        goto LABEL_47;
      case 1u:
        v35 = v15 + 3;
        v36 = *((_DWORD *)a1 + 8);
        if (v35 <= v36)
        {
          v39 = (char *)a1[5];
          v40 = v16;
        }
        else
        {
          if (v36 <= 1)
            v36 = 1;
          v37 = 2 * v36;
          if (v37 <= (int)v35)
            v38 = v35;
          else
            v38 = v37;
          v39 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v38, "Vector Storage (uint8_t, growth)");
          memcpy(v39, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v38;
          a1[5] = v39;
          v40 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v39[v16 + 1], &v39[v16], v40 - v16);
        *(_WORD *)(a1[5] + v16) = v5;
        v41 = 2;
        goto LABEL_47;
      case 2u:
        v23 = v15 + 4;
        v24 = *((_DWORD *)a1 + 8);
        if (v23 <= v24)
        {
          v27 = (char *)a1[5];
          v28 = v16;
        }
        else
        {
          if (v24 <= 1)
            v24 = 1;
          v25 = 2 * v24;
          if (v25 <= (int)v23)
            v26 = v23;
          else
            v26 = v25;
          v27 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v26, "Vector Storage (uint8_t, growth)");
          memcpy(v27, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v26;
          a1[5] = v27;
          v28 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v27[v16 + 1], &v27[v16], v28 - v16);
        v42 = a1[5] + v16;
        *(_BYTE *)(v42 + 2) = BYTE2(v5);
        *(_WORD *)v42 = v5;
        v41 = 3;
        goto LABEL_47;
      case 3u:
        v29 = v15 + 5;
        v30 = *((_DWORD *)a1 + 8);
        if (v29 <= v30)
        {
          v33 = (char *)a1[5];
          v34 = v16;
        }
        else
        {
          if (v30 <= 1)
            v30 = 1;
          v31 = 2 * v30;
          if (v31 <= (int)v29)
            v32 = v29;
          else
            v32 = v31;
          v33 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v32, "Vector Storage (uint8_t, growth)");
          memcpy(v33, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v32;
          a1[5] = v33;
          v34 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v33[v16 + 1], &v33[v16], v34 - v16);
        *(_DWORD *)(a1[5] + v16) = v5;
        v41 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v41;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t serializeFieldDeclarationFields(_QWORD *a1, uint64_t a2)
{
  const char *Name;
  uint64_t v5;

  serializeASTFields(a1, a2);
  Name = (const char *)glpFieldDeclarationNodeGetName(a2);
  return serialize_GLPString(a1, Name, v5);
}

uint64_t serializeStructTypeFields(_QWORD *a1, uint64_t a2)
{
  const char *Name;
  uint64_t v5;

  serializeStructureFields(a1, a2);
  Name = (const char *)glpStructTypeNodeGetName(a2);
  return serialize_GLPString(a1, Name, v5);
}

uint64_t serializeInterfaceBlockFields(_QWORD *a1, uint64_t a2)
{
  const char *BlockName;
  uint64_t v5;
  const char *InstanceName;
  uint64_t v7;
  char HasInstanceName;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  char *v14;
  int v15;
  char IsArray;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  char *v22;
  int v23;
  unint64_t Extra;

  serializeStructureFields(a1, a2);
  BlockName = (const char *)glpInterfaceBlockNodeGetBlockName(a2);
  serialize_GLPString(a1, BlockName, v5);
  InstanceName = (const char *)glpInterfaceBlockNodeGetInstanceName(a2);
  serialize_GLPString(a1, InstanceName, v7);
  HasInstanceName = glpInterfaceBlockNodeGetHasInstanceName(a2);
  v9 = *((_DWORD *)a1 + 8);
  v10 = *((unsigned int *)a1 + 9);
  v11 = v10 + 1;
  if ((int)v10 + 1 <= v9)
  {
    v14 = (char *)a1[5];
    v15 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v9 <= 1)
      v9 = 1;
    v12 = 2 * v9;
    if (v12 <= v11)
      v13 = v11;
    else
      v13 = v12;
    v14 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v13, "Vector Storage (uint8_t, growth)");
    memcpy(v14, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v13;
    a1[5] = v14;
    v15 = *((_DWORD *)a1 + 9);
  }
  memmove(&v14[v10 + 1], &v14[v10], (v15 - v10));
  *(_BYTE *)(a1[5] + v10) = HasInstanceName;
  ++*((_DWORD *)a1 + 9);
  IsArray = glpInterfaceBlockNodeGetIsArray(a2);
  v17 = *((_DWORD *)a1 + 8);
  v18 = *((unsigned int *)a1 + 9);
  v19 = v18 + 1;
  if ((int)v18 + 1 <= v17)
  {
    v22 = (char *)a1[5];
    v23 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v17 <= 1)
      v17 = 1;
    v20 = 2 * v17;
    if (v20 <= v19)
      v21 = v19;
    else
      v21 = v20;
    v22 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v21, "Vector Storage (uint8_t, growth)");
    memcpy(v22, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v21;
    a1[5] = v22;
    v23 = *((_DWORD *)a1 + 9);
  }
  memmove(&v22[v18 + 1], &v22[v18], (v23 - v18));
  *(_BYTE *)(a1[5] + v18) = IsArray;
  ++*((_DWORD *)a1 + 9);
  Extra = glpInterfaceBlockNodeGetExtra(a2);
  return serialize_GLPInterfaceBlockObject(a1, Extra);
}

void *serializeLayoutTypeFields(_QWORD *a1, uint64_t a2)
{
  uint64_t LayoutPairCount;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  void *result;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  int v41;
  uint64_t v42;

  serializeASTFields(a1, a2);
  LayoutPairCount = glpLayoutTypeNodeGetLayoutPairCount(a2);
  v5 = LayoutPairCount;
  v6 = (char)glp_serialized_integer32_control(LayoutPairCount);
  v7 = *((_DWORD *)a1 + 8);
  v8 = *((unsigned int *)a1 + 9);
  v9 = v8 + 1;
  if ((int)v8 + 1 <= v7)
  {
    v12 = (char *)a1[5];
    v13 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v7 <= 1)
      v7 = 1;
    v10 = 2 * v7;
    if (v10 <= v9)
      v11 = v9;
    else
      v11 = v10;
    v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
    memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v11;
    a1[5] = v12;
    v13 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
  *(_BYTE *)(a1[5] + v8) = v6;
  v15 = *((_DWORD *)a1 + 9);
  v16 = v15 + 1;
  *((_DWORD *)a1 + 9) = v15 + 1;
  if ((v6 & 0x80000000) != 0)
  {
    switch((v6 >> 1) & 7)
    {
      case 0u:
        v17 = v15 + 2;
        v18 = *((_DWORD *)a1 + 8);
        if (v17 <= v18)
        {
          v21 = (char *)a1[5];
          v22 = v16;
        }
        else
        {
          if (v18 <= 1)
            v18 = 1;
          v19 = 2 * v18;
          if (v19 <= (int)v17)
            v20 = v17;
          else
            v20 = v19;
          v21 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v20, "Vector Storage (uint8_t, growth)");
          memcpy(v21, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v20;
          a1[5] = v21;
          v22 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v21[v16 + 1], &v21[v16], v22 - v16);
        *(_BYTE *)(a1[5] + v16) = v5;
        v41 = 1;
        goto LABEL_47;
      case 1u:
        v35 = v15 + 3;
        v36 = *((_DWORD *)a1 + 8);
        if (v35 <= v36)
        {
          v39 = (char *)a1[5];
          v40 = v16;
        }
        else
        {
          if (v36 <= 1)
            v36 = 1;
          v37 = 2 * v36;
          if (v37 <= (int)v35)
            v38 = v35;
          else
            v38 = v37;
          v39 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v38, "Vector Storage (uint8_t, growth)");
          memcpy(v39, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v38;
          a1[5] = v39;
          v40 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v39[v16 + 1], &v39[v16], v40 - v16);
        *(_WORD *)(a1[5] + v16) = v5;
        v41 = 2;
        goto LABEL_47;
      case 2u:
        v23 = v15 + 4;
        v24 = *((_DWORD *)a1 + 8);
        if (v23 <= v24)
        {
          v27 = (char *)a1[5];
          v28 = v16;
        }
        else
        {
          if (v24 <= 1)
            v24 = 1;
          v25 = 2 * v24;
          if (v25 <= (int)v23)
            v26 = v23;
          else
            v26 = v25;
          v27 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v26, "Vector Storage (uint8_t, growth)");
          memcpy(v27, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v26;
          a1[5] = v27;
          v28 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v27[v16 + 1], &v27[v16], v28 - v16);
        v42 = a1[5] + v16;
        *(_BYTE *)(v42 + 2) = BYTE2(v5);
        *(_WORD *)v42 = v5;
        v41 = 3;
        goto LABEL_47;
      case 3u:
        v29 = v15 + 5;
        v30 = *((_DWORD *)a1 + 8);
        if (v29 <= v30)
        {
          v33 = (char *)a1[5];
          v34 = v16;
        }
        else
        {
          if (v30 <= 1)
            v30 = 1;
          v31 = 2 * v30;
          if (v31 <= (int)v29)
            v32 = v29;
          else
            v32 = v31;
          v33 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v32, "Vector Storage (uint8_t, growth)");
          memcpy(v33, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v32;
          a1[5] = v33;
          v34 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v33[v16 + 1], &v33[v16], v34 - v16);
        *(_DWORD *)(a1[5] + v16) = v5;
        v41 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v41;
        break;
      default:
        return result;
    }
  }
  return result;
}

void *serializeKeywordQualifierFields(_QWORD *a1, uint64_t a2)
{
  uint64_t Qualifier;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  void *result;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  int v41;
  uint64_t v42;

  serializeASTFields(a1, a2);
  Qualifier = glpKeywordQualifierNodeGetQualifier(a2);
  v5 = Qualifier;
  v6 = (char)glp_serialized_integer32_control(Qualifier);
  v7 = *((_DWORD *)a1 + 8);
  v8 = *((unsigned int *)a1 + 9);
  v9 = v8 + 1;
  if ((int)v8 + 1 <= v7)
  {
    v12 = (char *)a1[5];
    v13 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v7 <= 1)
      v7 = 1;
    v10 = 2 * v7;
    if (v10 <= v9)
      v11 = v9;
    else
      v11 = v10;
    v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
    memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v11;
    a1[5] = v12;
    v13 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
  *(_BYTE *)(a1[5] + v8) = v6;
  v15 = *((_DWORD *)a1 + 9);
  v16 = v15 + 1;
  *((_DWORD *)a1 + 9) = v15 + 1;
  if ((v6 & 0x80000000) != 0)
  {
    switch((v6 >> 1) & 7)
    {
      case 0u:
        v17 = v15 + 2;
        v18 = *((_DWORD *)a1 + 8);
        if (v17 <= v18)
        {
          v21 = (char *)a1[5];
          v22 = v16;
        }
        else
        {
          if (v18 <= 1)
            v18 = 1;
          v19 = 2 * v18;
          if (v19 <= (int)v17)
            v20 = v17;
          else
            v20 = v19;
          v21 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v20, "Vector Storage (uint8_t, growth)");
          memcpy(v21, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v20;
          a1[5] = v21;
          v22 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v21[v16 + 1], &v21[v16], v22 - v16);
        *(_BYTE *)(a1[5] + v16) = v5;
        v41 = 1;
        goto LABEL_47;
      case 1u:
        v35 = v15 + 3;
        v36 = *((_DWORD *)a1 + 8);
        if (v35 <= v36)
        {
          v39 = (char *)a1[5];
          v40 = v16;
        }
        else
        {
          if (v36 <= 1)
            v36 = 1;
          v37 = 2 * v36;
          if (v37 <= (int)v35)
            v38 = v35;
          else
            v38 = v37;
          v39 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v38, "Vector Storage (uint8_t, growth)");
          memcpy(v39, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v38;
          a1[5] = v39;
          v40 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v39[v16 + 1], &v39[v16], v40 - v16);
        *(_WORD *)(a1[5] + v16) = v5;
        v41 = 2;
        goto LABEL_47;
      case 2u:
        v23 = v15 + 4;
        v24 = *((_DWORD *)a1 + 8);
        if (v23 <= v24)
        {
          v27 = (char *)a1[5];
          v28 = v16;
        }
        else
        {
          if (v24 <= 1)
            v24 = 1;
          v25 = 2 * v24;
          if (v25 <= (int)v23)
            v26 = v23;
          else
            v26 = v25;
          v27 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v26, "Vector Storage (uint8_t, growth)");
          memcpy(v27, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v26;
          a1[5] = v27;
          v28 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v27[v16 + 1], &v27[v16], v28 - v16);
        v42 = a1[5] + v16;
        *(_BYTE *)(v42 + 2) = BYTE2(v5);
        *(_WORD *)v42 = v5;
        v41 = 3;
        goto LABEL_47;
      case 3u:
        v29 = v15 + 5;
        v30 = *((_DWORD *)a1 + 8);
        if (v29 <= v30)
        {
          v33 = (char *)a1[5];
          v34 = v16;
        }
        else
        {
          if (v30 <= 1)
            v30 = 1;
          v31 = 2 * v30;
          if (v31 <= (int)v29)
            v32 = v29;
          else
            v32 = v31;
          v33 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v32, "Vector Storage (uint8_t, growth)");
          memcpy(v33, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v32;
          a1[5] = v33;
          v34 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v33[v16 + 1], &v33[v16], v34 - v16);
        *(_DWORD *)(a1[5] + v16) = v5;
        v41 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v41;
        break;
      default:
        return result;
    }
  }
  return result;
}

void *serializeLayoutQualifierFields(_QWORD *a1, uint64_t a2)
{
  uint64_t LayoutPairCount;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  void *result;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  int v41;
  uint64_t v42;

  serializeASTFields(a1, a2);
  LayoutPairCount = glpLayoutQualifierNodeGetLayoutPairCount(a2);
  v5 = LayoutPairCount;
  v6 = (char)glp_serialized_integer32_control(LayoutPairCount);
  v7 = *((_DWORD *)a1 + 8);
  v8 = *((unsigned int *)a1 + 9);
  v9 = v8 + 1;
  if ((int)v8 + 1 <= v7)
  {
    v12 = (char *)a1[5];
    v13 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v7 <= 1)
      v7 = 1;
    v10 = 2 * v7;
    if (v10 <= v9)
      v11 = v9;
    else
      v11 = v10;
    v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
    memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v11;
    a1[5] = v12;
    v13 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
  *(_BYTE *)(a1[5] + v8) = v6;
  v15 = *((_DWORD *)a1 + 9);
  v16 = v15 + 1;
  *((_DWORD *)a1 + 9) = v15 + 1;
  if ((v6 & 0x80000000) != 0)
  {
    switch((v6 >> 1) & 7)
    {
      case 0u:
        v17 = v15 + 2;
        v18 = *((_DWORD *)a1 + 8);
        if (v17 <= v18)
        {
          v21 = (char *)a1[5];
          v22 = v16;
        }
        else
        {
          if (v18 <= 1)
            v18 = 1;
          v19 = 2 * v18;
          if (v19 <= (int)v17)
            v20 = v17;
          else
            v20 = v19;
          v21 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v20, "Vector Storage (uint8_t, growth)");
          memcpy(v21, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v20;
          a1[5] = v21;
          v22 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v21[v16 + 1], &v21[v16], v22 - v16);
        *(_BYTE *)(a1[5] + v16) = v5;
        v41 = 1;
        goto LABEL_47;
      case 1u:
        v35 = v15 + 3;
        v36 = *((_DWORD *)a1 + 8);
        if (v35 <= v36)
        {
          v39 = (char *)a1[5];
          v40 = v16;
        }
        else
        {
          if (v36 <= 1)
            v36 = 1;
          v37 = 2 * v36;
          if (v37 <= (int)v35)
            v38 = v35;
          else
            v38 = v37;
          v39 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v38, "Vector Storage (uint8_t, growth)");
          memcpy(v39, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v38;
          a1[5] = v39;
          v40 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v39[v16 + 1], &v39[v16], v40 - v16);
        *(_WORD *)(a1[5] + v16) = v5;
        v41 = 2;
        goto LABEL_47;
      case 2u:
        v23 = v15 + 4;
        v24 = *((_DWORD *)a1 + 8);
        if (v23 <= v24)
        {
          v27 = (char *)a1[5];
          v28 = v16;
        }
        else
        {
          if (v24 <= 1)
            v24 = 1;
          v25 = 2 * v24;
          if (v25 <= (int)v23)
            v26 = v23;
          else
            v26 = v25;
          v27 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v26, "Vector Storage (uint8_t, growth)");
          memcpy(v27, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v26;
          a1[5] = v27;
          v28 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v27[v16 + 1], &v27[v16], v28 - v16);
        v42 = a1[5] + v16;
        *(_BYTE *)(v42 + 2) = BYTE2(v5);
        *(_WORD *)v42 = v5;
        v41 = 3;
        goto LABEL_47;
      case 3u:
        v29 = v15 + 5;
        v30 = *((_DWORD *)a1 + 8);
        if (v29 <= v30)
        {
          v33 = (char *)a1[5];
          v34 = v16;
        }
        else
        {
          if (v30 <= 1)
            v30 = 1;
          v31 = 2 * v30;
          if (v31 <= (int)v29)
            v32 = v29;
          else
            v32 = v31;
          v33 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v32, "Vector Storage (uint8_t, growth)");
          memcpy(v33, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v32;
          a1[5] = v33;
          v34 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v33[v16 + 1], &v33[v16], v34 - v16);
        *(_DWORD *)(a1[5] + v16) = v5;
        v41 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v41;
        break;
      default:
        return result;
    }
  }
  return result;
}

void *serializeSubroutineTypeListFields(_QWORD *a1, uint64_t a2)
{
  uint64_t TypeCount;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  void *result;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  int v41;
  uint64_t v42;

  serializeASTFields(a1, a2);
  TypeCount = glpSubroutineTypeListNodeGetTypeCount(a2);
  v5 = TypeCount;
  v6 = (char)glp_serialized_integer32_control(TypeCount);
  v7 = *((_DWORD *)a1 + 8);
  v8 = *((unsigned int *)a1 + 9);
  v9 = v8 + 1;
  if ((int)v8 + 1 <= v7)
  {
    v12 = (char *)a1[5];
    v13 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v7 <= 1)
      v7 = 1;
    v10 = 2 * v7;
    if (v10 <= v9)
      v11 = v9;
    else
      v11 = v10;
    v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
    memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v11;
    a1[5] = v12;
    v13 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
  *(_BYTE *)(a1[5] + v8) = v6;
  v15 = *((_DWORD *)a1 + 9);
  v16 = v15 + 1;
  *((_DWORD *)a1 + 9) = v15 + 1;
  if ((v6 & 0x80000000) != 0)
  {
    switch((v6 >> 1) & 7)
    {
      case 0u:
        v17 = v15 + 2;
        v18 = *((_DWORD *)a1 + 8);
        if (v17 <= v18)
        {
          v21 = (char *)a1[5];
          v22 = v16;
        }
        else
        {
          if (v18 <= 1)
            v18 = 1;
          v19 = 2 * v18;
          if (v19 <= (int)v17)
            v20 = v17;
          else
            v20 = v19;
          v21 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v20, "Vector Storage (uint8_t, growth)");
          memcpy(v21, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v20;
          a1[5] = v21;
          v22 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v21[v16 + 1], &v21[v16], v22 - v16);
        *(_BYTE *)(a1[5] + v16) = v5;
        v41 = 1;
        goto LABEL_47;
      case 1u:
        v35 = v15 + 3;
        v36 = *((_DWORD *)a1 + 8);
        if (v35 <= v36)
        {
          v39 = (char *)a1[5];
          v40 = v16;
        }
        else
        {
          if (v36 <= 1)
            v36 = 1;
          v37 = 2 * v36;
          if (v37 <= (int)v35)
            v38 = v35;
          else
            v38 = v37;
          v39 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v38, "Vector Storage (uint8_t, growth)");
          memcpy(v39, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v38;
          a1[5] = v39;
          v40 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v39[v16 + 1], &v39[v16], v40 - v16);
        *(_WORD *)(a1[5] + v16) = v5;
        v41 = 2;
        goto LABEL_47;
      case 2u:
        v23 = v15 + 4;
        v24 = *((_DWORD *)a1 + 8);
        if (v23 <= v24)
        {
          v27 = (char *)a1[5];
          v28 = v16;
        }
        else
        {
          if (v24 <= 1)
            v24 = 1;
          v25 = 2 * v24;
          if (v25 <= (int)v23)
            v26 = v23;
          else
            v26 = v25;
          v27 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v26, "Vector Storage (uint8_t, growth)");
          memcpy(v27, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v26;
          a1[5] = v27;
          v28 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v27[v16 + 1], &v27[v16], v28 - v16);
        v42 = a1[5] + v16;
        *(_BYTE *)(v42 + 2) = BYTE2(v5);
        *(_WORD *)v42 = v5;
        v41 = 3;
        goto LABEL_47;
      case 3u:
        v29 = v15 + 5;
        v30 = *((_DWORD *)a1 + 8);
        if (v29 <= v30)
        {
          v33 = (char *)a1[5];
          v34 = v16;
        }
        else
        {
          if (v30 <= 1)
            v30 = 1;
          v31 = 2 * v30;
          if (v31 <= (int)v29)
            v32 = v29;
          else
            v32 = v31;
          v33 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v32, "Vector Storage (uint8_t, growth)");
          memcpy(v33, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v32;
          a1[5] = v33;
          v34 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v33[v16 + 1], &v33[v16], v34 - v16);
        *(_DWORD *)(a1[5] + v16) = v5;
        v41 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v41;
        break;
      default:
        return result;
    }
  }
  return result;
}

void *serializeQualifierListFields(_QWORD *a1, uint64_t a2)
{
  uint64_t QualifierCount;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  void *result;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  int v41;
  uint64_t v42;

  serializeASTFields(a1, a2);
  QualifierCount = glpQualifierListNodeGetQualifierCount(a2);
  v5 = QualifierCount;
  v6 = (char)glp_serialized_integer32_control(QualifierCount);
  v7 = *((_DWORD *)a1 + 8);
  v8 = *((unsigned int *)a1 + 9);
  v9 = v8 + 1;
  if ((int)v8 + 1 <= v7)
  {
    v12 = (char *)a1[5];
    v13 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v7 <= 1)
      v7 = 1;
    v10 = 2 * v7;
    if (v10 <= v9)
      v11 = v9;
    else
      v11 = v10;
    v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
    memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v11;
    a1[5] = v12;
    v13 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
  *(_BYTE *)(a1[5] + v8) = v6;
  v15 = *((_DWORD *)a1 + 9);
  v16 = v15 + 1;
  *((_DWORD *)a1 + 9) = v15 + 1;
  if ((v6 & 0x80000000) != 0)
  {
    switch((v6 >> 1) & 7)
    {
      case 0u:
        v17 = v15 + 2;
        v18 = *((_DWORD *)a1 + 8);
        if (v17 <= v18)
        {
          v21 = (char *)a1[5];
          v22 = v16;
        }
        else
        {
          if (v18 <= 1)
            v18 = 1;
          v19 = 2 * v18;
          if (v19 <= (int)v17)
            v20 = v17;
          else
            v20 = v19;
          v21 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v20, "Vector Storage (uint8_t, growth)");
          memcpy(v21, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v20;
          a1[5] = v21;
          v22 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v21[v16 + 1], &v21[v16], v22 - v16);
        *(_BYTE *)(a1[5] + v16) = v5;
        v41 = 1;
        goto LABEL_47;
      case 1u:
        v35 = v15 + 3;
        v36 = *((_DWORD *)a1 + 8);
        if (v35 <= v36)
        {
          v39 = (char *)a1[5];
          v40 = v16;
        }
        else
        {
          if (v36 <= 1)
            v36 = 1;
          v37 = 2 * v36;
          if (v37 <= (int)v35)
            v38 = v35;
          else
            v38 = v37;
          v39 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v38, "Vector Storage (uint8_t, growth)");
          memcpy(v39, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v38;
          a1[5] = v39;
          v40 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v39[v16 + 1], &v39[v16], v40 - v16);
        *(_WORD *)(a1[5] + v16) = v5;
        v41 = 2;
        goto LABEL_47;
      case 2u:
        v23 = v15 + 4;
        v24 = *((_DWORD *)a1 + 8);
        if (v23 <= v24)
        {
          v27 = (char *)a1[5];
          v28 = v16;
        }
        else
        {
          if (v24 <= 1)
            v24 = 1;
          v25 = 2 * v24;
          if (v25 <= (int)v23)
            v26 = v23;
          else
            v26 = v25;
          v27 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v26, "Vector Storage (uint8_t, growth)");
          memcpy(v27, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v26;
          a1[5] = v27;
          v28 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v27[v16 + 1], &v27[v16], v28 - v16);
        v42 = a1[5] + v16;
        *(_BYTE *)(v42 + 2) = BYTE2(v5);
        *(_WORD *)v42 = v5;
        v41 = 3;
        goto LABEL_47;
      case 3u:
        v29 = v15 + 5;
        v30 = *((_DWORD *)a1 + 8);
        if (v29 <= v30)
        {
          v33 = (char *)a1[5];
          v34 = v16;
        }
        else
        {
          if (v30 <= 1)
            v30 = 1;
          v31 = 2 * v30;
          if (v31 <= (int)v29)
            v32 = v29;
          else
            v32 = v31;
          v33 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v32, "Vector Storage (uint8_t, growth)");
          memcpy(v33, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v32;
          a1[5] = v33;
          v34 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v33[v16 + 1], &v33[v16], v34 - v16);
        *(_DWORD *)(a1[5] + v16) = v5;
        v41 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v41;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t serializeGlobalTypeQualifierFields(_QWORD *a1, uint64_t a2)
{
  unint64_t *Layout;

  serializeASTFields(a1, a2);
  Layout = (unint64_t *)glpGlobalTypeQualifierNodeGetLayout(a2);
  return serialize_GLPLayoutObject(a1, Layout);
}

uint64_t serializeLayoutPairFields(_QWORD *a1, uint64_t a2)
{
  const char *Identifier;
  uint64_t v5;
  uint64_t ValueKind;
  int v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  char *v14;
  int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int v20;
  uint64_t v21;
  char *v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  int v26;
  uint64_t v27;
  char *v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  int v32;
  uint64_t v33;
  char *v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  int v38;
  uint64_t v39;
  char *v40;
  unsigned int v41;
  int v42;
  uint64_t v43;
  int Value;
  int v45;
  uint64_t v46;
  int v47;
  int v48;
  uint64_t v49;
  char *v50;
  int v51;
  const char *String;
  uint64_t v53;

  serializeASTFields(a1, a2);
  Identifier = (const char *)glpLayoutPairNodeGetIdentifier(a2);
  serialize_GLPString(a1, Identifier, v5);
  ValueKind = glpLayoutPairNodeGetValueKind(a2);
  v7 = ValueKind;
  v8 = (char)glp_serialized_integer32_control(ValueKind);
  v9 = *((_DWORD *)a1 + 8);
  v10 = *((unsigned int *)a1 + 9);
  v11 = v10 + 1;
  if ((int)v10 + 1 <= v9)
  {
    v14 = (char *)a1[5];
    v15 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v9 <= 1)
      v9 = 1;
    v12 = 2 * v9;
    if (v12 <= v11)
      v13 = v11;
    else
      v13 = v12;
    v14 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v13, "Vector Storage (uint8_t, growth)");
    memcpy(v14, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v13;
    a1[5] = v14;
    v15 = *((_DWORD *)a1 + 9);
  }
  memmove(&v14[v10 + 1], &v14[v10], (v15 - v10));
  *(_BYTE *)(a1[5] + v10) = v8;
  v16 = *((_DWORD *)a1 + 9);
  v17 = v16 + 1;
  *((_DWORD *)a1 + 9) = v16 + 1;
  if ((v8 & 0x80000000) != 0)
  {
    switch((v8 >> 1) & 7)
    {
      case 0u:
        v18 = v16 + 2;
        v19 = *((_DWORD *)a1 + 8);
        if (v18 <= v19)
        {
          v22 = (char *)a1[5];
          v23 = v17;
        }
        else
        {
          if (v19 <= 1)
            v19 = 1;
          v20 = 2 * v19;
          if (v20 <= (int)v18)
            v21 = v18;
          else
            v21 = v20;
          v22 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v21, "Vector Storage (uint8_t, growth)");
          memcpy(v22, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v21;
          a1[5] = v22;
          v23 = *((_DWORD *)a1 + 9);
        }
        memmove(&v22[v17 + 1], &v22[v17], v23 - v17);
        *(_BYTE *)(a1[5] + v17) = v7;
        v42 = 1;
        goto LABEL_47;
      case 1u:
        v36 = v16 + 3;
        v37 = *((_DWORD *)a1 + 8);
        if (v36 <= v37)
        {
          v40 = (char *)a1[5];
          v41 = v17;
        }
        else
        {
          if (v37 <= 1)
            v37 = 1;
          v38 = 2 * v37;
          if (v38 <= (int)v36)
            v39 = v36;
          else
            v39 = v38;
          v40 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v39, "Vector Storage (uint8_t, growth)");
          memcpy(v40, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v39;
          a1[5] = v40;
          v41 = *((_DWORD *)a1 + 9);
        }
        memmove(&v40[v17 + 1], &v40[v17], v41 - v17);
        *(_WORD *)(a1[5] + v17) = v7;
        v42 = 2;
        goto LABEL_47;
      case 2u:
        v24 = v16 + 4;
        v25 = *((_DWORD *)a1 + 8);
        if (v24 <= v25)
        {
          v28 = (char *)a1[5];
          v29 = v17;
        }
        else
        {
          if (v25 <= 1)
            v25 = 1;
          v26 = 2 * v25;
          if (v26 <= (int)v24)
            v27 = v24;
          else
            v27 = v26;
          v28 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v27, "Vector Storage (uint8_t, growth)");
          memcpy(v28, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v27;
          a1[5] = v28;
          v29 = *((_DWORD *)a1 + 9);
        }
        memmove(&v28[v17 + 1], &v28[v17], v29 - v17);
        v43 = a1[5] + v17;
        *(_BYTE *)(v43 + 2) = BYTE2(v7);
        *(_WORD *)v43 = v7;
        v42 = 3;
        goto LABEL_47;
      case 3u:
        v30 = v16 + 5;
        v31 = *((_DWORD *)a1 + 8);
        if (v30 <= v31)
        {
          v34 = (char *)a1[5];
          v35 = v17;
        }
        else
        {
          if (v31 <= 1)
            v31 = 1;
          v32 = 2 * v31;
          if (v32 <= (int)v30)
            v33 = v30;
          else
            v33 = v32;
          v34 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v33, "Vector Storage (uint8_t, growth)");
          memcpy(v34, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v33;
          a1[5] = v34;
          v35 = *((_DWORD *)a1 + 9);
        }
        memmove(&v34[v17 + 1], &v34[v17], v35 - v17);
        *(_DWORD *)(a1[5] + v17) = v7;
        v42 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v42;
        break;
      default:
        break;
    }
  }
  Value = glpLayoutPairNodeGetValue(a2);
  v45 = *((_DWORD *)a1 + 8);
  v46 = *((unsigned int *)a1 + 9);
  v47 = v46 + 4;
  if ((int)v46 + 4 <= v45)
  {
    v50 = (char *)a1[5];
    v51 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v45 <= 1)
      v45 = 1;
    v48 = 2 * v45;
    if (v48 <= v47)
      v49 = v47;
    else
      v49 = v48;
    v50 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v49, "Vector Storage (uint8_t, growth)");
    memcpy(v50, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v49;
    a1[5] = v50;
    v51 = *((_DWORD *)a1 + 9);
  }
  memmove(&v50[v46 + 1], &v50[v46], (v51 - v46));
  *(_DWORD *)(a1[5] + v46) = Value;
  *((_DWORD *)a1 + 9) += 4;
  String = (const char *)glpLayoutPairNodeGetString(a2);
  return serialize_GLPString(a1, String, v53);
}

void *serializeBlockFields(_QWORD *a1, uint64_t a2)
{
  char NeedsNewScope;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  char *v10;
  int v11;
  uint64_t StatementCount;
  int v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  char *v20;
  int v21;
  void *result;
  int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  int v27;
  uint64_t v28;
  char *v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  int v33;
  uint64_t v34;
  char *v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  int v39;
  uint64_t v40;
  char *v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  int v45;
  uint64_t v46;
  char *v47;
  unsigned int v48;
  int v49;
  uint64_t v50;

  serializeASTFields(a1, a2);
  NeedsNewScope = glpBlockNodeGetNeedsNewScope(a2);
  v5 = *((_DWORD *)a1 + 8);
  v6 = *((unsigned int *)a1 + 9);
  v7 = v6 + 1;
  if ((int)v6 + 1 <= v5)
  {
    v10 = (char *)a1[5];
    v11 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v5 <= 1)
      v5 = 1;
    v8 = 2 * v5;
    if (v8 <= v7)
      v9 = v7;
    else
      v9 = v8;
    v10 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v9, "Vector Storage (uint8_t, growth)");
    memcpy(v10, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v9;
    a1[5] = v10;
    v11 = *((_DWORD *)a1 + 9);
  }
  memmove(&v10[v6 + 1], &v10[v6], (v11 - v6));
  *(_BYTE *)(a1[5] + v6) = NeedsNewScope;
  ++*((_DWORD *)a1 + 9);
  StatementCount = glpBlockNodeGetStatementCount(a2);
  v13 = StatementCount;
  v14 = (char)glp_serialized_integer32_control(StatementCount);
  v15 = *((_DWORD *)a1 + 8);
  v16 = *((unsigned int *)a1 + 9);
  v17 = v16 + 1;
  if ((int)v16 + 1 <= v15)
  {
    v20 = (char *)a1[5];
    v21 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v15 <= 1)
      v15 = 1;
    v18 = 2 * v15;
    if (v18 <= v17)
      v19 = v17;
    else
      v19 = v18;
    v20 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v19, "Vector Storage (uint8_t, growth)");
    memcpy(v20, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v19;
    a1[5] = v20;
    v21 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v20[v16 + 1], &v20[v16], (v21 - v16));
  *(_BYTE *)(a1[5] + v16) = v14;
  v23 = *((_DWORD *)a1 + 9);
  v24 = v23 + 1;
  *((_DWORD *)a1 + 9) = v23 + 1;
  if ((v14 & 0x80000000) != 0)
  {
    switch((v14 >> 1) & 7)
    {
      case 0u:
        v25 = v23 + 2;
        v26 = *((_DWORD *)a1 + 8);
        if (v25 <= v26)
        {
          v29 = (char *)a1[5];
          v30 = v24;
        }
        else
        {
          if (v26 <= 1)
            v26 = 1;
          v27 = 2 * v26;
          if (v27 <= (int)v25)
            v28 = v25;
          else
            v28 = v27;
          v29 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v28, "Vector Storage (uint8_t, growth)");
          memcpy(v29, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v28;
          a1[5] = v29;
          v30 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v29[v24 + 1], &v29[v24], v30 - v24);
        *(_BYTE *)(a1[5] + v24) = v13;
        v49 = 1;
        goto LABEL_55;
      case 1u:
        v43 = v23 + 3;
        v44 = *((_DWORD *)a1 + 8);
        if (v43 <= v44)
        {
          v47 = (char *)a1[5];
          v48 = v24;
        }
        else
        {
          if (v44 <= 1)
            v44 = 1;
          v45 = 2 * v44;
          if (v45 <= (int)v43)
            v46 = v43;
          else
            v46 = v45;
          v47 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v46, "Vector Storage (uint8_t, growth)");
          memcpy(v47, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v46;
          a1[5] = v47;
          v48 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v47[v24 + 1], &v47[v24], v48 - v24);
        *(_WORD *)(a1[5] + v24) = v13;
        v49 = 2;
        goto LABEL_55;
      case 2u:
        v31 = v23 + 4;
        v32 = *((_DWORD *)a1 + 8);
        if (v31 <= v32)
        {
          v35 = (char *)a1[5];
          v36 = v24;
        }
        else
        {
          if (v32 <= 1)
            v32 = 1;
          v33 = 2 * v32;
          if (v33 <= (int)v31)
            v34 = v31;
          else
            v34 = v33;
          v35 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v34, "Vector Storage (uint8_t, growth)");
          memcpy(v35, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v34;
          a1[5] = v35;
          v36 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v35[v24 + 1], &v35[v24], v36 - v24);
        v50 = a1[5] + v24;
        *(_BYTE *)(v50 + 2) = BYTE2(v13);
        *(_WORD *)v50 = v13;
        v49 = 3;
        goto LABEL_55;
      case 3u:
        v37 = v23 + 5;
        v38 = *((_DWORD *)a1 + 8);
        if (v37 <= v38)
        {
          v41 = (char *)a1[5];
          v42 = v24;
        }
        else
        {
          if (v38 <= 1)
            v38 = 1;
          v39 = 2 * v38;
          if (v39 <= (int)v37)
            v40 = v37;
          else
            v40 = v39;
          v41 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v40, "Vector Storage (uint8_t, growth)");
          memcpy(v41, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v40;
          a1[5] = v41;
          v42 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v41[v24 + 1], &v41[v24], v42 - v24);
        *(_DWORD *)(a1[5] + v24) = v13;
        v49 = 4;
LABEL_55:
        *((_DWORD *)a1 + 9) += v49;
        break;
      default:
        return result;
    }
  }
  return result;
}

void *serializeCaseStatementFields(_QWORD *a1, uint64_t a2)
{
  char IsStray;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  char *v10;
  int v11;
  void *result;

  serializeASTFields(a1, a2);
  IsStray = glpCaseStatementNodeGetIsStray(a2);
  v5 = *((_DWORD *)a1 + 8);
  v6 = *((unsigned int *)a1 + 9);
  v7 = v6 + 1;
  if ((int)v6 + 1 <= v5)
  {
    v10 = (char *)a1[5];
    v11 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v5 <= 1)
      v5 = 1;
    v8 = 2 * v5;
    if (v8 <= v7)
      v9 = v7;
    else
      v9 = v8;
    v10 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v9, "Vector Storage (uint8_t, growth)");
    memcpy(v10, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v9;
    a1[5] = v10;
    v11 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v10[v6 + 1], &v10[v6], (v11 - v6));
  *(_BYTE *)(a1[5] + v6) = IsStray;
  ++*((_DWORD *)a1 + 9);
  return result;
}

void *serializeDefaultStatementFields(_QWORD *a1, uint64_t a2)
{
  char IsStray;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  char *v10;
  int v11;
  void *result;

  serializeASTFields(a1, a2);
  IsStray = glpDefaultStatementNodeGetIsStray(a2);
  v5 = *((_DWORD *)a1 + 8);
  v6 = *((unsigned int *)a1 + 9);
  v7 = v6 + 1;
  if ((int)v6 + 1 <= v5)
  {
    v10 = (char *)a1[5];
    v11 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v5 <= 1)
      v5 = 1;
    v8 = 2 * v5;
    if (v8 <= v7)
      v9 = v7;
    else
      v9 = v8;
    v10 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v9, "Vector Storage (uint8_t, growth)");
    memcpy(v10, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v9;
    a1[5] = v10;
    v11 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v10[v6 + 1], &v10[v6], (v11 - v6));
  *(_BYTE *)(a1[5] + v6) = IsStray;
  ++*((_DWORD *)a1 + 9);
  return result;
}

uint64_t serializeReturnStatementFields(_QWORD *a1, uint64_t a2)
{
  uint64_t Extra;

  serializeASTFields(a1, a2);
  Extra = glpReturnStatementNodeGetExtra(a2);
  return serialize_GLPFunctionObject(a1, Extra);
}

void *serializeTopLevelFields(_QWORD *a1, uint64_t a2)
{
  uint64_t DefCount;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  void *result;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  int v41;
  uint64_t v42;

  serializeASTFields(a1, a2);
  DefCount = glpTopLevelNodeGetDefCount(a2);
  v5 = DefCount;
  v6 = (char)glp_serialized_integer32_control(DefCount);
  v7 = *((_DWORD *)a1 + 8);
  v8 = *((unsigned int *)a1 + 9);
  v9 = v8 + 1;
  if ((int)v8 + 1 <= v7)
  {
    v12 = (char *)a1[5];
    v13 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v7 <= 1)
      v7 = 1;
    v10 = 2 * v7;
    if (v10 <= v9)
      v11 = v9;
    else
      v11 = v10;
    v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
    memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v11;
    a1[5] = v12;
    v13 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
  *(_BYTE *)(a1[5] + v8) = v6;
  v15 = *((_DWORD *)a1 + 9);
  v16 = v15 + 1;
  *((_DWORD *)a1 + 9) = v15 + 1;
  if ((v6 & 0x80000000) != 0)
  {
    switch((v6 >> 1) & 7)
    {
      case 0u:
        v17 = v15 + 2;
        v18 = *((_DWORD *)a1 + 8);
        if (v17 <= v18)
        {
          v21 = (char *)a1[5];
          v22 = v16;
        }
        else
        {
          if (v18 <= 1)
            v18 = 1;
          v19 = 2 * v18;
          if (v19 <= (int)v17)
            v20 = v17;
          else
            v20 = v19;
          v21 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v20, "Vector Storage (uint8_t, growth)");
          memcpy(v21, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v20;
          a1[5] = v21;
          v22 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v21[v16 + 1], &v21[v16], v22 - v16);
        *(_BYTE *)(a1[5] + v16) = v5;
        v41 = 1;
        goto LABEL_47;
      case 1u:
        v35 = v15 + 3;
        v36 = *((_DWORD *)a1 + 8);
        if (v35 <= v36)
        {
          v39 = (char *)a1[5];
          v40 = v16;
        }
        else
        {
          if (v36 <= 1)
            v36 = 1;
          v37 = 2 * v36;
          if (v37 <= (int)v35)
            v38 = v35;
          else
            v38 = v37;
          v39 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v38, "Vector Storage (uint8_t, growth)");
          memcpy(v39, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v38;
          a1[5] = v39;
          v40 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v39[v16 + 1], &v39[v16], v40 - v16);
        *(_WORD *)(a1[5] + v16) = v5;
        v41 = 2;
        goto LABEL_47;
      case 2u:
        v23 = v15 + 4;
        v24 = *((_DWORD *)a1 + 8);
        if (v23 <= v24)
        {
          v27 = (char *)a1[5];
          v28 = v16;
        }
        else
        {
          if (v24 <= 1)
            v24 = 1;
          v25 = 2 * v24;
          if (v25 <= (int)v23)
            v26 = v23;
          else
            v26 = v25;
          v27 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v26, "Vector Storage (uint8_t, growth)");
          memcpy(v27, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v26;
          a1[5] = v27;
          v28 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v27[v16 + 1], &v27[v16], v28 - v16);
        v42 = a1[5] + v16;
        *(_BYTE *)(v42 + 2) = BYTE2(v5);
        *(_WORD *)v42 = v5;
        v41 = 3;
        goto LABEL_47;
      case 3u:
        v29 = v15 + 5;
        v30 = *((_DWORD *)a1 + 8);
        if (v29 <= v30)
        {
          v33 = (char *)a1[5];
          v34 = v16;
        }
        else
        {
          if (v30 <= 1)
            v30 = 1;
          v31 = 2 * v30;
          if (v31 <= (int)v29)
            v32 = v29;
          else
            v32 = v31;
          v33 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v32, "Vector Storage (uint8_t, growth)");
          memcpy(v33, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v32;
          a1[5] = v33;
          v34 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v33[v16 + 1], &v33[v16], v34 - v16);
        *(_DWORD *)(a1[5] + v16) = v5;
        v41 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v41;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t serializeRawCallFields(_QWORD *a1, uint64_t a2)
{
  const char *v4;
  uint64_t v5;
  uint64_t v6;

  serializeASTFields(a1, a2);
  v4 = (const char *)glpRawCallNodeGetName(a2);
  serialize_GLPString(a1, v4, v5);
  v6 = glpRawCallNodeGetExtra(a2);
  return serialize_GLPFunctionObject(a1, v6);
}

uint64_t serializeSubroutineRawCallFields(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;

  serializeASTFields(a1, a2);
  v4 = glpSubroutineRawCallNodeGetExtra(a2);
  return serialize_GLPSubroutineUniformObject(a1, v4);
}

void *serializeOffsetFields(_QWORD *a1, uint64_t a2)
{
  unint64_t Extra;
  uint64_t Swizzle;
  int v6;
  unsigned int v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  char *v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  int v41;
  uint64_t v42;
  uint64_t PreSwizzlePrimitiveType;
  int v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  int v48;
  int v49;
  uint64_t v50;
  char *v51;
  int v52;
  int v53;
  unsigned int v54;
  unsigned int v55;
  int v56;
  int v57;
  uint64_t v58;
  char *v59;
  unsigned int v60;
  unsigned int v61;
  int v62;
  int v63;
  uint64_t v64;
  char *v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  int v69;
  uint64_t v70;
  char *v71;
  unsigned int v72;
  unsigned int v73;
  int v74;
  int v75;
  uint64_t v76;
  char *v77;
  unsigned int v78;
  int v79;
  uint64_t v80;
  uint64_t CompStride;
  int v82;
  unsigned int v83;
  int v84;
  uint64_t v85;
  int v86;
  int v87;
  uint64_t v88;
  char *v89;
  int v90;
  void *result;
  int v92;
  unsigned int v93;
  unsigned int v94;
  int v95;
  int v96;
  uint64_t v97;
  char *v98;
  unsigned int v99;
  unsigned int v100;
  int v101;
  int v102;
  uint64_t v103;
  char *v104;
  unsigned int v105;
  unsigned int v106;
  int v107;
  int v108;
  uint64_t v109;
  char *v110;
  unsigned int v111;
  unsigned int v112;
  int v113;
  int v114;
  uint64_t v115;
  char *v116;
  unsigned int v117;
  int v118;
  uint64_t v119;

  serializeASTFields(a1, a2);
  Extra = glpOffsetNodeGetExtra(a2);
  serialize_pointer(a1, Extra);
  Swizzle = glpOffsetNodeGetSwizzle(a2);
  v6 = Swizzle;
  v7 = (char)glp_serialized_integer32_control(Swizzle);
  v8 = *((_DWORD *)a1 + 8);
  v9 = *((unsigned int *)a1 + 9);
  v10 = v9 + 1;
  if ((int)v9 + 1 <= v8)
  {
    v13 = (char *)a1[5];
    v14 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v8 <= 1)
      v8 = 1;
    v11 = 2 * v8;
    if (v11 <= v10)
      v12 = v10;
    else
      v12 = v11;
    v13 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v12, "Vector Storage (uint8_t, growth)");
    memcpy(v13, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v12;
    a1[5] = v13;
    v14 = *((_DWORD *)a1 + 9);
  }
  memmove(&v13[v9 + 1], &v13[v9], (v14 - v9));
  *(_BYTE *)(a1[5] + v9) = v7;
  v15 = *((_DWORD *)a1 + 9);
  v16 = v15 + 1;
  *((_DWORD *)a1 + 9) = v15 + 1;
  if ((v7 & 0x80000000) != 0)
  {
    switch((v7 >> 1) & 7)
    {
      case 0u:
        v17 = v15 + 2;
        v18 = *((_DWORD *)a1 + 8);
        if (v17 <= v18)
        {
          v21 = (char *)a1[5];
          v22 = v16;
        }
        else
        {
          if (v18 <= 1)
            v18 = 1;
          v19 = 2 * v18;
          if (v19 <= (int)v17)
            v20 = v17;
          else
            v20 = v19;
          v21 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v20, "Vector Storage (uint8_t, growth)");
          memcpy(v21, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v20;
          a1[5] = v21;
          v22 = *((_DWORD *)a1 + 9);
        }
        memmove(&v21[v16 + 1], &v21[v16], v22 - v16);
        *(_BYTE *)(a1[5] + v16) = v6;
        v41 = 1;
        goto LABEL_47;
      case 1u:
        v35 = v15 + 3;
        v36 = *((_DWORD *)a1 + 8);
        if (v35 <= v36)
        {
          v39 = (char *)a1[5];
          v40 = v16;
        }
        else
        {
          if (v36 <= 1)
            v36 = 1;
          v37 = 2 * v36;
          if (v37 <= (int)v35)
            v38 = v35;
          else
            v38 = v37;
          v39 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v38, "Vector Storage (uint8_t, growth)");
          memcpy(v39, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v38;
          a1[5] = v39;
          v40 = *((_DWORD *)a1 + 9);
        }
        memmove(&v39[v16 + 1], &v39[v16], v40 - v16);
        *(_WORD *)(a1[5] + v16) = v6;
        v41 = 2;
        goto LABEL_47;
      case 2u:
        v23 = v15 + 4;
        v24 = *((_DWORD *)a1 + 8);
        if (v23 <= v24)
        {
          v27 = (char *)a1[5];
          v28 = v16;
        }
        else
        {
          if (v24 <= 1)
            v24 = 1;
          v25 = 2 * v24;
          if (v25 <= (int)v23)
            v26 = v23;
          else
            v26 = v25;
          v27 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v26, "Vector Storage (uint8_t, growth)");
          memcpy(v27, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v26;
          a1[5] = v27;
          v28 = *((_DWORD *)a1 + 9);
        }
        memmove(&v27[v16 + 1], &v27[v16], v28 - v16);
        v42 = a1[5] + v16;
        *(_BYTE *)(v42 + 2) = BYTE2(v6);
        *(_WORD *)v42 = v6;
        v41 = 3;
        goto LABEL_47;
      case 3u:
        v29 = v15 + 5;
        v30 = *((_DWORD *)a1 + 8);
        if (v29 <= v30)
        {
          v33 = (char *)a1[5];
          v34 = v16;
        }
        else
        {
          if (v30 <= 1)
            v30 = 1;
          v31 = 2 * v30;
          if (v31 <= (int)v29)
            v32 = v29;
          else
            v32 = v31;
          v33 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v32, "Vector Storage (uint8_t, growth)");
          memcpy(v33, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v32;
          a1[5] = v33;
          v34 = *((_DWORD *)a1 + 9);
        }
        memmove(&v33[v16 + 1], &v33[v16], v34 - v16);
        *(_DWORD *)(a1[5] + v16) = v6;
        v41 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v41;
        break;
      default:
        break;
    }
  }
  PreSwizzlePrimitiveType = glpOffsetNodeGetPreSwizzlePrimitiveType(a2);
  v44 = PreSwizzlePrimitiveType;
  v45 = (char)glp_serialized_integer32_control(PreSwizzlePrimitiveType);
  v46 = *((_DWORD *)a1 + 8);
  v47 = *((unsigned int *)a1 + 9);
  v48 = v47 + 1;
  if ((int)v47 + 1 <= v46)
  {
    v51 = (char *)a1[5];
    v52 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v46 <= 1)
      v46 = 1;
    v49 = 2 * v46;
    if (v49 <= v48)
      v50 = v48;
    else
      v50 = v49;
    v51 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v50, "Vector Storage (uint8_t, growth)");
    memcpy(v51, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v50;
    a1[5] = v51;
    v52 = *((_DWORD *)a1 + 9);
  }
  memmove(&v51[v47 + 1], &v51[v47], (v52 - v47));
  *(_BYTE *)(a1[5] + v47) = v45;
  v53 = *((_DWORD *)a1 + 9);
  v54 = v53 + 1;
  *((_DWORD *)a1 + 9) = v53 + 1;
  if ((v45 & 0x80000000) != 0)
  {
    switch((v45 >> 1) & 7)
    {
      case 0u:
        v55 = v53 + 2;
        v56 = *((_DWORD *)a1 + 8);
        if (v55 <= v56)
        {
          v59 = (char *)a1[5];
          v60 = v54;
        }
        else
        {
          if (v56 <= 1)
            v56 = 1;
          v57 = 2 * v56;
          if (v57 <= (int)v55)
            v58 = v55;
          else
            v58 = v57;
          v59 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v58, "Vector Storage (uint8_t, growth)");
          memcpy(v59, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v58;
          a1[5] = v59;
          v60 = *((_DWORD *)a1 + 9);
        }
        memmove(&v59[v54 + 1], &v59[v54], v60 - v54);
        *(_BYTE *)(a1[5] + v54) = v44;
        v79 = 1;
        goto LABEL_94;
      case 1u:
        v73 = v53 + 3;
        v74 = *((_DWORD *)a1 + 8);
        if (v73 <= v74)
        {
          v77 = (char *)a1[5];
          v78 = v54;
        }
        else
        {
          if (v74 <= 1)
            v74 = 1;
          v75 = 2 * v74;
          if (v75 <= (int)v73)
            v76 = v73;
          else
            v76 = v75;
          v77 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v76, "Vector Storage (uint8_t, growth)");
          memcpy(v77, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v76;
          a1[5] = v77;
          v78 = *((_DWORD *)a1 + 9);
        }
        memmove(&v77[v54 + 1], &v77[v54], v78 - v54);
        *(_WORD *)(a1[5] + v54) = v44;
        v79 = 2;
        goto LABEL_94;
      case 2u:
        v61 = v53 + 4;
        v62 = *((_DWORD *)a1 + 8);
        if (v61 <= v62)
        {
          v65 = (char *)a1[5];
          v66 = v54;
        }
        else
        {
          if (v62 <= 1)
            v62 = 1;
          v63 = 2 * v62;
          if (v63 <= (int)v61)
            v64 = v61;
          else
            v64 = v63;
          v65 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v64, "Vector Storage (uint8_t, growth)");
          memcpy(v65, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v64;
          a1[5] = v65;
          v66 = *((_DWORD *)a1 + 9);
        }
        memmove(&v65[v54 + 1], &v65[v54], v66 - v54);
        v80 = a1[5] + v54;
        *(_BYTE *)(v80 + 2) = BYTE2(v44);
        *(_WORD *)v80 = v44;
        v79 = 3;
        goto LABEL_94;
      case 3u:
        v67 = v53 + 5;
        v68 = *((_DWORD *)a1 + 8);
        if (v67 <= v68)
        {
          v71 = (char *)a1[5];
          v72 = v54;
        }
        else
        {
          if (v68 <= 1)
            v68 = 1;
          v69 = 2 * v68;
          if (v69 <= (int)v67)
            v70 = v67;
          else
            v70 = v69;
          v71 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v70, "Vector Storage (uint8_t, growth)");
          memcpy(v71, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v70;
          a1[5] = v71;
          v72 = *((_DWORD *)a1 + 9);
        }
        memmove(&v71[v54 + 1], &v71[v54], v72 - v54);
        *(_DWORD *)(a1[5] + v54) = v44;
        v79 = 4;
LABEL_94:
        *((_DWORD *)a1 + 9) += v79;
        break;
      default:
        break;
    }
  }
  CompStride = glpOffsetNodeGetCompStride(a2);
  v82 = CompStride;
  v83 = (char)glp_serialized_integer32_control(CompStride);
  v84 = *((_DWORD *)a1 + 8);
  v85 = *((unsigned int *)a1 + 9);
  v86 = v85 + 1;
  if ((int)v85 + 1 <= v84)
  {
    v89 = (char *)a1[5];
    v90 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v84 <= 1)
      v84 = 1;
    v87 = 2 * v84;
    if (v87 <= v86)
      v88 = v86;
    else
      v88 = v87;
    v89 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v88, "Vector Storage (uint8_t, growth)");
    memcpy(v89, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v88;
    a1[5] = v89;
    v90 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v89[v85 + 1], &v89[v85], (v90 - v85));
  *(_BYTE *)(a1[5] + v85) = v83;
  v92 = *((_DWORD *)a1 + 9);
  v93 = v92 + 1;
  *((_DWORD *)a1 + 9) = v92 + 1;
  if ((v83 & 0x80000000) != 0)
  {
    switch((v83 >> 1) & 7)
    {
      case 0u:
        v94 = v92 + 2;
        v95 = *((_DWORD *)a1 + 8);
        if (v94 <= v95)
        {
          v98 = (char *)a1[5];
          v99 = v93;
        }
        else
        {
          if (v95 <= 1)
            v95 = 1;
          v96 = 2 * v95;
          if (v96 <= (int)v94)
            v97 = v94;
          else
            v97 = v96;
          v98 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v97, "Vector Storage (uint8_t, growth)");
          memcpy(v98, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v97;
          a1[5] = v98;
          v99 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v98[v93 + 1], &v98[v93], v99 - v93);
        *(_BYTE *)(a1[5] + v93) = v82;
        v118 = 1;
        goto LABEL_141;
      case 1u:
        v112 = v92 + 3;
        v113 = *((_DWORD *)a1 + 8);
        if (v112 <= v113)
        {
          v116 = (char *)a1[5];
          v117 = v93;
        }
        else
        {
          if (v113 <= 1)
            v113 = 1;
          v114 = 2 * v113;
          if (v114 <= (int)v112)
            v115 = v112;
          else
            v115 = v114;
          v116 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v115, "Vector Storage (uint8_t, growth)");
          memcpy(v116, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v115;
          a1[5] = v116;
          v117 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v116[v93 + 1], &v116[v93], v117 - v93);
        *(_WORD *)(a1[5] + v93) = v82;
        v118 = 2;
        goto LABEL_141;
      case 2u:
        v100 = v92 + 4;
        v101 = *((_DWORD *)a1 + 8);
        if (v100 <= v101)
        {
          v104 = (char *)a1[5];
          v105 = v93;
        }
        else
        {
          if (v101 <= 1)
            v101 = 1;
          v102 = 2 * v101;
          if (v102 <= (int)v100)
            v103 = v100;
          else
            v103 = v102;
          v104 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v103, "Vector Storage (uint8_t, growth)");
          memcpy(v104, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v103;
          a1[5] = v104;
          v105 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v104[v93 + 1], &v104[v93], v105 - v93);
        v119 = a1[5] + v93;
        *(_BYTE *)(v119 + 2) = BYTE2(v82);
        *(_WORD *)v119 = v82;
        v118 = 3;
        goto LABEL_141;
      case 3u:
        v106 = v92 + 5;
        v107 = *((_DWORD *)a1 + 8);
        if (v106 <= v107)
        {
          v110 = (char *)a1[5];
          v111 = v93;
        }
        else
        {
          if (v107 <= 1)
            v107 = 1;
          v108 = 2 * v107;
          if (v108 <= (int)v106)
            v109 = v106;
          else
            v109 = v108;
          v110 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v109, "Vector Storage (uint8_t, growth)");
          memcpy(v110, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v109;
          a1[5] = v110;
          v111 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v110[v93 + 1], &v110[v93], v111 - v93);
        *(_DWORD *)(a1[5] + v93) = v82;
        v118 = 4;
LABEL_141:
        *((_DWORD *)a1 + 9) += v118;
        break;
      default:
        return result;
    }
  }
  return result;
}

void *serializeLValueFields(_QWORD *a1, uint64_t a2)
{
  const char *VariableName;
  uint64_t v5;
  unint64_t VariableExtra;
  uint64_t IndexLevel;
  int v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  char *v15;
  int v16;
  void *result;
  int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  int v22;
  uint64_t v23;
  char *v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  int v28;
  uint64_t v29;
  char *v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  int v34;
  uint64_t v35;
  char *v36;
  unsigned int v37;
  unsigned int v38;
  int v39;
  int v40;
  uint64_t v41;
  char *v42;
  unsigned int v43;
  int v44;
  uint64_t v45;

  serializeASTFields(a1, a2);
  VariableName = (const char *)glpLValueNodeGetVariableName(a2);
  serialize_GLPString(a1, VariableName, v5);
  VariableExtra = glpLValueNodeGetVariableExtra(a2);
  serialize_GLPVariableObject(a1, VariableExtra);
  IndexLevel = glpLValueNodeGetIndexLevel(a2);
  v8 = IndexLevel;
  v9 = (char)glp_serialized_integer32_control(IndexLevel);
  v10 = *((_DWORD *)a1 + 8);
  v11 = *((unsigned int *)a1 + 9);
  v12 = v11 + 1;
  if ((int)v11 + 1 <= v10)
  {
    v15 = (char *)a1[5];
    v16 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v10 <= 1)
      v10 = 1;
    v13 = 2 * v10;
    if (v13 <= v12)
      v14 = v12;
    else
      v14 = v13;
    v15 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v14, "Vector Storage (uint8_t, growth)");
    memcpy(v15, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v14;
    a1[5] = v15;
    v16 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v15[v11 + 1], &v15[v11], (v16 - v11));
  *(_BYTE *)(a1[5] + v11) = v9;
  v18 = *((_DWORD *)a1 + 9);
  v19 = v18 + 1;
  *((_DWORD *)a1 + 9) = v18 + 1;
  if ((v9 & 0x80000000) != 0)
  {
    switch((v9 >> 1) & 7)
    {
      case 0u:
        v20 = v18 + 2;
        v21 = *((_DWORD *)a1 + 8);
        if (v20 <= v21)
        {
          v24 = (char *)a1[5];
          v25 = v19;
        }
        else
        {
          if (v21 <= 1)
            v21 = 1;
          v22 = 2 * v21;
          if (v22 <= (int)v20)
            v23 = v20;
          else
            v23 = v22;
          v24 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v23, "Vector Storage (uint8_t, growth)");
          memcpy(v24, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v23;
          a1[5] = v24;
          v25 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v24[v19 + 1], &v24[v19], v25 - v19);
        *(_BYTE *)(a1[5] + v19) = v8;
        v44 = 1;
        goto LABEL_47;
      case 1u:
        v38 = v18 + 3;
        v39 = *((_DWORD *)a1 + 8);
        if (v38 <= v39)
        {
          v42 = (char *)a1[5];
          v43 = v19;
        }
        else
        {
          if (v39 <= 1)
            v39 = 1;
          v40 = 2 * v39;
          if (v40 <= (int)v38)
            v41 = v38;
          else
            v41 = v40;
          v42 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v41, "Vector Storage (uint8_t, growth)");
          memcpy(v42, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v41;
          a1[5] = v42;
          v43 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v42[v19 + 1], &v42[v19], v43 - v19);
        *(_WORD *)(a1[5] + v19) = v8;
        v44 = 2;
        goto LABEL_47;
      case 2u:
        v26 = v18 + 4;
        v27 = *((_DWORD *)a1 + 8);
        if (v26 <= v27)
        {
          v30 = (char *)a1[5];
          v31 = v19;
        }
        else
        {
          if (v27 <= 1)
            v27 = 1;
          v28 = 2 * v27;
          if (v28 <= (int)v26)
            v29 = v26;
          else
            v29 = v28;
          v30 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v29, "Vector Storage (uint8_t, growth)");
          memcpy(v30, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v29;
          a1[5] = v30;
          v31 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v30[v19 + 1], &v30[v19], v31 - v19);
        v45 = a1[5] + v19;
        *(_BYTE *)(v45 + 2) = BYTE2(v8);
        *(_WORD *)v45 = v8;
        v44 = 3;
        goto LABEL_47;
      case 3u:
        v32 = v18 + 5;
        v33 = *((_DWORD *)a1 + 8);
        if (v32 <= v33)
        {
          v36 = (char *)a1[5];
          v37 = v19;
        }
        else
        {
          if (v33 <= 1)
            v33 = 1;
          v34 = 2 * v33;
          if (v34 <= (int)v32)
            v35 = v32;
          else
            v35 = v34;
          v36 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v35, "Vector Storage (uint8_t, growth)");
          memcpy(v36, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v35;
          a1[5] = v36;
          v37 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v36[v19 + 1], &v36[v19], v37 - v19);
        *(_DWORD *)(a1[5] + v19) = v8;
        v44 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v44;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t serializeIBPartialDerefFields(_QWORD *a1, uint64_t a2)
{
  unint64_t Ib;

  serializeASTFields(a1, a2);
  Ib = glpIBPartialDerefNodeGetIb(a2);
  return serialize_GLPInterfaceBlockObject(a1, Ib);
}

void *serializePPStreamOpFields(_QWORD *a1, uint64_t a2)
{
  uint64_t ReturnPrimitiveType;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  int v18;
  uint64_t v19;
  char *v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  uint64_t v25;
  char *v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  int v30;
  uint64_t v31;
  char *v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  int v36;
  uint64_t v37;
  char *v38;
  unsigned int v39;
  int v40;
  uint64_t v41;
  uint64_t Opcode;
  int v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  int v47;
  int v48;
  uint64_t v49;
  char *v50;
  int v51;
  int v52;
  unsigned int v53;
  unsigned int v54;
  int v55;
  int v56;
  uint64_t v57;
  char *v58;
  unsigned int v59;
  unsigned int v60;
  int v61;
  int v62;
  uint64_t v63;
  char *v64;
  unsigned int v65;
  unsigned int v66;
  int v67;
  int v68;
  uint64_t v69;
  char *v70;
  unsigned int v71;
  unsigned int v72;
  int v73;
  int v74;
  uint64_t v75;
  char *v76;
  unsigned int v77;
  int v78;
  uint64_t v79;
  uint64_t OpPrimitiveType;
  int v81;
  unsigned int v82;
  int v83;
  uint64_t v84;
  int v85;
  int v86;
  uint64_t v87;
  char *v88;
  int v89;
  int v90;
  unsigned int v91;
  unsigned int v92;
  int v93;
  int v94;
  uint64_t v95;
  char *v96;
  unsigned int v97;
  unsigned int v98;
  int v99;
  int v100;
  uint64_t v101;
  char *v102;
  unsigned int v103;
  unsigned int v104;
  int v105;
  int v106;
  uint64_t v107;
  char *v108;
  unsigned int v109;
  unsigned int v110;
  int v111;
  int v112;
  uint64_t v113;
  char *v114;
  unsigned int v115;
  int v116;
  uint64_t v117;
  uint64_t HasSrctex;
  int v119;
  unsigned int v120;
  int v121;
  uint64_t v122;
  int v123;
  int v124;
  uint64_t v125;
  char *v126;
  int v127;
  int v128;
  unsigned int v129;
  unsigned int v130;
  int v131;
  int v132;
  uint64_t v133;
  char *v134;
  unsigned int v135;
  unsigned int v136;
  int v137;
  int v138;
  uint64_t v139;
  char *v140;
  unsigned int v141;
  unsigned int v142;
  int v143;
  int v144;
  uint64_t v145;
  char *v146;
  unsigned int v147;
  unsigned int v148;
  int v149;
  int v150;
  uint64_t v151;
  char *v152;
  unsigned int v153;
  int v154;
  uint64_t v155;
  uint64_t HasOffset;
  int v157;
  unsigned int v158;
  int v159;
  uint64_t v160;
  int v161;
  int v162;
  uint64_t v163;
  char *v164;
  int v165;
  void *result;
  int v167;
  unsigned int v168;
  unsigned int v169;
  int v170;
  int v171;
  uint64_t v172;
  char *v173;
  unsigned int v174;
  unsigned int v175;
  int v176;
  int v177;
  uint64_t v178;
  char *v179;
  unsigned int v180;
  unsigned int v181;
  int v182;
  int v183;
  uint64_t v184;
  char *v185;
  unsigned int v186;
  unsigned int v187;
  int v188;
  int v189;
  uint64_t v190;
  char *v191;
  unsigned int v192;
  int v193;
  uint64_t v194;

  serializeCallFields(a1, a2);
  ReturnPrimitiveType = glpPPStreamOpNodeGetReturnPrimitiveType(a2);
  v5 = ReturnPrimitiveType;
  v6 = (char)glp_serialized_integer32_control(ReturnPrimitiveType);
  v7 = *((_DWORD *)a1 + 8);
  v8 = *((unsigned int *)a1 + 9);
  v9 = v8 + 1;
  if ((int)v8 + 1 <= v7)
  {
    v12 = (char *)a1[5];
    v13 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v7 <= 1)
      v7 = 1;
    v10 = 2 * v7;
    if (v10 <= v9)
      v11 = v9;
    else
      v11 = v10;
    v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
    memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v11;
    a1[5] = v12;
    v13 = *((_DWORD *)a1 + 9);
  }
  memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
  *(_BYTE *)(a1[5] + v8) = v6;
  v14 = *((_DWORD *)a1 + 9);
  v15 = v14 + 1;
  *((_DWORD *)a1 + 9) = v14 + 1;
  if ((v6 & 0x80000000) != 0)
  {
    switch((v6 >> 1) & 7)
    {
      case 0u:
        v16 = v14 + 2;
        v17 = *((_DWORD *)a1 + 8);
        if (v16 <= v17)
        {
          v20 = (char *)a1[5];
          v21 = v15;
        }
        else
        {
          if (v17 <= 1)
            v17 = 1;
          v18 = 2 * v17;
          if (v18 <= (int)v16)
            v19 = v16;
          else
            v19 = v18;
          v20 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v19, "Vector Storage (uint8_t, growth)");
          memcpy(v20, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v19;
          a1[5] = v20;
          v21 = *((_DWORD *)a1 + 9);
        }
        memmove(&v20[v15 + 1], &v20[v15], v21 - v15);
        *(_BYTE *)(a1[5] + v15) = v5;
        v40 = 1;
        goto LABEL_47;
      case 1u:
        v34 = v14 + 3;
        v35 = *((_DWORD *)a1 + 8);
        if (v34 <= v35)
        {
          v38 = (char *)a1[5];
          v39 = v15;
        }
        else
        {
          if (v35 <= 1)
            v35 = 1;
          v36 = 2 * v35;
          if (v36 <= (int)v34)
            v37 = v34;
          else
            v37 = v36;
          v38 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v37, "Vector Storage (uint8_t, growth)");
          memcpy(v38, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v37;
          a1[5] = v38;
          v39 = *((_DWORD *)a1 + 9);
        }
        memmove(&v38[v15 + 1], &v38[v15], v39 - v15);
        *(_WORD *)(a1[5] + v15) = v5;
        v40 = 2;
        goto LABEL_47;
      case 2u:
        v22 = v14 + 4;
        v23 = *((_DWORD *)a1 + 8);
        if (v22 <= v23)
        {
          v26 = (char *)a1[5];
          v27 = v15;
        }
        else
        {
          if (v23 <= 1)
            v23 = 1;
          v24 = 2 * v23;
          if (v24 <= (int)v22)
            v25 = v22;
          else
            v25 = v24;
          v26 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v25, "Vector Storage (uint8_t, growth)");
          memcpy(v26, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v25;
          a1[5] = v26;
          v27 = *((_DWORD *)a1 + 9);
        }
        memmove(&v26[v15 + 1], &v26[v15], v27 - v15);
        v41 = a1[5] + v15;
        *(_BYTE *)(v41 + 2) = BYTE2(v5);
        *(_WORD *)v41 = v5;
        v40 = 3;
        goto LABEL_47;
      case 3u:
        v28 = v14 + 5;
        v29 = *((_DWORD *)a1 + 8);
        if (v28 <= v29)
        {
          v32 = (char *)a1[5];
          v33 = v15;
        }
        else
        {
          if (v29 <= 1)
            v29 = 1;
          v30 = 2 * v29;
          if (v30 <= (int)v28)
            v31 = v28;
          else
            v31 = v30;
          v32 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v31, "Vector Storage (uint8_t, growth)");
          memcpy(v32, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v31;
          a1[5] = v32;
          v33 = *((_DWORD *)a1 + 9);
        }
        memmove(&v32[v15 + 1], &v32[v15], v33 - v15);
        *(_DWORD *)(a1[5] + v15) = v5;
        v40 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v40;
        break;
      default:
        break;
    }
  }
  Opcode = glpPPStreamOpNodeGetOpcode(a2);
  v43 = Opcode;
  v44 = (char)glp_serialized_integer32_control(Opcode);
  v45 = *((_DWORD *)a1 + 8);
  v46 = *((unsigned int *)a1 + 9);
  v47 = v46 + 1;
  if ((int)v46 + 1 <= v45)
  {
    v50 = (char *)a1[5];
    v51 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v45 <= 1)
      v45 = 1;
    v48 = 2 * v45;
    if (v48 <= v47)
      v49 = v47;
    else
      v49 = v48;
    v50 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v49, "Vector Storage (uint8_t, growth)");
    memcpy(v50, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v49;
    a1[5] = v50;
    v51 = *((_DWORD *)a1 + 9);
  }
  memmove(&v50[v46 + 1], &v50[v46], (v51 - v46));
  *(_BYTE *)(a1[5] + v46) = v44;
  v52 = *((_DWORD *)a1 + 9);
  v53 = v52 + 1;
  *((_DWORD *)a1 + 9) = v52 + 1;
  if ((v44 & 0x80000000) != 0)
  {
    switch((v44 >> 1) & 7)
    {
      case 0u:
        v54 = v52 + 2;
        v55 = *((_DWORD *)a1 + 8);
        if (v54 <= v55)
        {
          v58 = (char *)a1[5];
          v59 = v53;
        }
        else
        {
          if (v55 <= 1)
            v55 = 1;
          v56 = 2 * v55;
          if (v56 <= (int)v54)
            v57 = v54;
          else
            v57 = v56;
          v58 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v57, "Vector Storage (uint8_t, growth)");
          memcpy(v58, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v57;
          a1[5] = v58;
          v59 = *((_DWORD *)a1 + 9);
        }
        memmove(&v58[v53 + 1], &v58[v53], v59 - v53);
        *(_BYTE *)(a1[5] + v53) = v43;
        v78 = 1;
        goto LABEL_94;
      case 1u:
        v72 = v52 + 3;
        v73 = *((_DWORD *)a1 + 8);
        if (v72 <= v73)
        {
          v76 = (char *)a1[5];
          v77 = v53;
        }
        else
        {
          if (v73 <= 1)
            v73 = 1;
          v74 = 2 * v73;
          if (v74 <= (int)v72)
            v75 = v72;
          else
            v75 = v74;
          v76 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v75, "Vector Storage (uint8_t, growth)");
          memcpy(v76, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v75;
          a1[5] = v76;
          v77 = *((_DWORD *)a1 + 9);
        }
        memmove(&v76[v53 + 1], &v76[v53], v77 - v53);
        *(_WORD *)(a1[5] + v53) = v43;
        v78 = 2;
        goto LABEL_94;
      case 2u:
        v60 = v52 + 4;
        v61 = *((_DWORD *)a1 + 8);
        if (v60 <= v61)
        {
          v64 = (char *)a1[5];
          v65 = v53;
        }
        else
        {
          if (v61 <= 1)
            v61 = 1;
          v62 = 2 * v61;
          if (v62 <= (int)v60)
            v63 = v60;
          else
            v63 = v62;
          v64 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v63, "Vector Storage (uint8_t, growth)");
          memcpy(v64, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v63;
          a1[5] = v64;
          v65 = *((_DWORD *)a1 + 9);
        }
        memmove(&v64[v53 + 1], &v64[v53], v65 - v53);
        v79 = a1[5] + v53;
        *(_BYTE *)(v79 + 2) = BYTE2(v43);
        *(_WORD *)v79 = v43;
        v78 = 3;
        goto LABEL_94;
      case 3u:
        v66 = v52 + 5;
        v67 = *((_DWORD *)a1 + 8);
        if (v66 <= v67)
        {
          v70 = (char *)a1[5];
          v71 = v53;
        }
        else
        {
          if (v67 <= 1)
            v67 = 1;
          v68 = 2 * v67;
          if (v68 <= (int)v66)
            v69 = v66;
          else
            v69 = v68;
          v70 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v69, "Vector Storage (uint8_t, growth)");
          memcpy(v70, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v69;
          a1[5] = v70;
          v71 = *((_DWORD *)a1 + 9);
        }
        memmove(&v70[v53 + 1], &v70[v53], v71 - v53);
        *(_DWORD *)(a1[5] + v53) = v43;
        v78 = 4;
LABEL_94:
        *((_DWORD *)a1 + 9) += v78;
        break;
      default:
        break;
    }
  }
  OpPrimitiveType = glpPPStreamOpNodeGetOpPrimitiveType(a2);
  v81 = OpPrimitiveType;
  v82 = (char)glp_serialized_integer32_control(OpPrimitiveType);
  v83 = *((_DWORD *)a1 + 8);
  v84 = *((unsigned int *)a1 + 9);
  v85 = v84 + 1;
  if ((int)v84 + 1 <= v83)
  {
    v88 = (char *)a1[5];
    v89 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v83 <= 1)
      v83 = 1;
    v86 = 2 * v83;
    if (v86 <= v85)
      v87 = v85;
    else
      v87 = v86;
    v88 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v87, "Vector Storage (uint8_t, growth)");
    memcpy(v88, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v87;
    a1[5] = v88;
    v89 = *((_DWORD *)a1 + 9);
  }
  memmove(&v88[v84 + 1], &v88[v84], (v89 - v84));
  *(_BYTE *)(a1[5] + v84) = v82;
  v90 = *((_DWORD *)a1 + 9);
  v91 = v90 + 1;
  *((_DWORD *)a1 + 9) = v90 + 1;
  if ((v82 & 0x80000000) != 0)
  {
    switch((v82 >> 1) & 7)
    {
      case 0u:
        v92 = v90 + 2;
        v93 = *((_DWORD *)a1 + 8);
        if (v92 <= v93)
        {
          v96 = (char *)a1[5];
          v97 = v91;
        }
        else
        {
          if (v93 <= 1)
            v93 = 1;
          v94 = 2 * v93;
          if (v94 <= (int)v92)
            v95 = v92;
          else
            v95 = v94;
          v96 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v95, "Vector Storage (uint8_t, growth)");
          memcpy(v96, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v95;
          a1[5] = v96;
          v97 = *((_DWORD *)a1 + 9);
        }
        memmove(&v96[v91 + 1], &v96[v91], v97 - v91);
        *(_BYTE *)(a1[5] + v91) = v81;
        v116 = 1;
        goto LABEL_141;
      case 1u:
        v110 = v90 + 3;
        v111 = *((_DWORD *)a1 + 8);
        if (v110 <= v111)
        {
          v114 = (char *)a1[5];
          v115 = v91;
        }
        else
        {
          if (v111 <= 1)
            v111 = 1;
          v112 = 2 * v111;
          if (v112 <= (int)v110)
            v113 = v110;
          else
            v113 = v112;
          v114 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v113, "Vector Storage (uint8_t, growth)");
          memcpy(v114, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v113;
          a1[5] = v114;
          v115 = *((_DWORD *)a1 + 9);
        }
        memmove(&v114[v91 + 1], &v114[v91], v115 - v91);
        *(_WORD *)(a1[5] + v91) = v81;
        v116 = 2;
        goto LABEL_141;
      case 2u:
        v98 = v90 + 4;
        v99 = *((_DWORD *)a1 + 8);
        if (v98 <= v99)
        {
          v102 = (char *)a1[5];
          v103 = v91;
        }
        else
        {
          if (v99 <= 1)
            v99 = 1;
          v100 = 2 * v99;
          if (v100 <= (int)v98)
            v101 = v98;
          else
            v101 = v100;
          v102 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v101, "Vector Storage (uint8_t, growth)");
          memcpy(v102, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v101;
          a1[5] = v102;
          v103 = *((_DWORD *)a1 + 9);
        }
        memmove(&v102[v91 + 1], &v102[v91], v103 - v91);
        v117 = a1[5] + v91;
        *(_BYTE *)(v117 + 2) = BYTE2(v81);
        *(_WORD *)v117 = v81;
        v116 = 3;
        goto LABEL_141;
      case 3u:
        v104 = v90 + 5;
        v105 = *((_DWORD *)a1 + 8);
        if (v104 <= v105)
        {
          v108 = (char *)a1[5];
          v109 = v91;
        }
        else
        {
          if (v105 <= 1)
            v105 = 1;
          v106 = 2 * v105;
          if (v106 <= (int)v104)
            v107 = v104;
          else
            v107 = v106;
          v108 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v107, "Vector Storage (uint8_t, growth)");
          memcpy(v108, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v107;
          a1[5] = v108;
          v109 = *((_DWORD *)a1 + 9);
        }
        memmove(&v108[v91 + 1], &v108[v91], v109 - v91);
        *(_DWORD *)(a1[5] + v91) = v81;
        v116 = 4;
LABEL_141:
        *((_DWORD *)a1 + 9) += v116;
        break;
      default:
        break;
    }
  }
  HasSrctex = glpPPStreamOpNodeGetHasSrctex(a2);
  v119 = HasSrctex;
  v120 = (char)glp_serialized_integer32_control(HasSrctex);
  v121 = *((_DWORD *)a1 + 8);
  v122 = *((unsigned int *)a1 + 9);
  v123 = v122 + 1;
  if ((int)v122 + 1 <= v121)
  {
    v126 = (char *)a1[5];
    v127 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v121 <= 1)
      v121 = 1;
    v124 = 2 * v121;
    if (v124 <= v123)
      v125 = v123;
    else
      v125 = v124;
    v126 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v125, "Vector Storage (uint8_t, growth)");
    memcpy(v126, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v125;
    a1[5] = v126;
    v127 = *((_DWORD *)a1 + 9);
  }
  memmove(&v126[v122 + 1], &v126[v122], (v127 - v122));
  *(_BYTE *)(a1[5] + v122) = v120;
  v128 = *((_DWORD *)a1 + 9);
  v129 = v128 + 1;
  *((_DWORD *)a1 + 9) = v128 + 1;
  if ((v120 & 0x80000000) != 0)
  {
    switch((v120 >> 1) & 7)
    {
      case 0u:
        v130 = v128 + 2;
        v131 = *((_DWORD *)a1 + 8);
        if (v130 <= v131)
        {
          v134 = (char *)a1[5];
          v135 = v129;
        }
        else
        {
          if (v131 <= 1)
            v131 = 1;
          v132 = 2 * v131;
          if (v132 <= (int)v130)
            v133 = v130;
          else
            v133 = v132;
          v134 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v133, "Vector Storage (uint8_t, growth)");
          memcpy(v134, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v133;
          a1[5] = v134;
          v135 = *((_DWORD *)a1 + 9);
        }
        memmove(&v134[v129 + 1], &v134[v129], v135 - v129);
        *(_BYTE *)(a1[5] + v129) = v119;
        v154 = 1;
        goto LABEL_188;
      case 1u:
        v148 = v128 + 3;
        v149 = *((_DWORD *)a1 + 8);
        if (v148 <= v149)
        {
          v152 = (char *)a1[5];
          v153 = v129;
        }
        else
        {
          if (v149 <= 1)
            v149 = 1;
          v150 = 2 * v149;
          if (v150 <= (int)v148)
            v151 = v148;
          else
            v151 = v150;
          v152 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v151, "Vector Storage (uint8_t, growth)");
          memcpy(v152, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v151;
          a1[5] = v152;
          v153 = *((_DWORD *)a1 + 9);
        }
        memmove(&v152[v129 + 1], &v152[v129], v153 - v129);
        *(_WORD *)(a1[5] + v129) = v119;
        v154 = 2;
        goto LABEL_188;
      case 2u:
        v136 = v128 + 4;
        v137 = *((_DWORD *)a1 + 8);
        if (v136 <= v137)
        {
          v140 = (char *)a1[5];
          v141 = v129;
        }
        else
        {
          if (v137 <= 1)
            v137 = 1;
          v138 = 2 * v137;
          if (v138 <= (int)v136)
            v139 = v136;
          else
            v139 = v138;
          v140 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v139, "Vector Storage (uint8_t, growth)");
          memcpy(v140, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v139;
          a1[5] = v140;
          v141 = *((_DWORD *)a1 + 9);
        }
        memmove(&v140[v129 + 1], &v140[v129], v141 - v129);
        v155 = a1[5] + v129;
        *(_BYTE *)(v155 + 2) = BYTE2(v119);
        *(_WORD *)v155 = v119;
        v154 = 3;
        goto LABEL_188;
      case 3u:
        v142 = v128 + 5;
        v143 = *((_DWORD *)a1 + 8);
        if (v142 <= v143)
        {
          v146 = (char *)a1[5];
          v147 = v129;
        }
        else
        {
          if (v143 <= 1)
            v143 = 1;
          v144 = 2 * v143;
          if (v144 <= (int)v142)
            v145 = v142;
          else
            v145 = v144;
          v146 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v145, "Vector Storage (uint8_t, growth)");
          memcpy(v146, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v145;
          a1[5] = v146;
          v147 = *((_DWORD *)a1 + 9);
        }
        memmove(&v146[v129 + 1], &v146[v129], v147 - v129);
        *(_DWORD *)(a1[5] + v129) = v119;
        v154 = 4;
LABEL_188:
        *((_DWORD *)a1 + 9) += v154;
        break;
      default:
        break;
    }
  }
  HasOffset = glpPPStreamOpNodeGetHasOffset(a2);
  v157 = HasOffset;
  v158 = (char)glp_serialized_integer32_control(HasOffset);
  v159 = *((_DWORD *)a1 + 8);
  v160 = *((unsigned int *)a1 + 9);
  v161 = v160 + 1;
  if ((int)v160 + 1 <= v159)
  {
    v164 = (char *)a1[5];
    v165 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v159 <= 1)
      v159 = 1;
    v162 = 2 * v159;
    if (v162 <= v161)
      v163 = v161;
    else
      v163 = v162;
    v164 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v163, "Vector Storage (uint8_t, growth)");
    memcpy(v164, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v163;
    a1[5] = v164;
    v165 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v164[v160 + 1], &v164[v160], (v165 - v160));
  *(_BYTE *)(a1[5] + v160) = v158;
  v167 = *((_DWORD *)a1 + 9);
  v168 = v167 + 1;
  *((_DWORD *)a1 + 9) = v167 + 1;
  if ((v158 & 0x80000000) != 0)
  {
    switch((v158 >> 1) & 7)
    {
      case 0u:
        v169 = v167 + 2;
        v170 = *((_DWORD *)a1 + 8);
        if (v169 <= v170)
        {
          v173 = (char *)a1[5];
          v174 = v168;
        }
        else
        {
          if (v170 <= 1)
            v170 = 1;
          v171 = 2 * v170;
          if (v171 <= (int)v169)
            v172 = v169;
          else
            v172 = v171;
          v173 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v172, "Vector Storage (uint8_t, growth)");
          memcpy(v173, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v172;
          a1[5] = v173;
          v174 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v173[v168 + 1], &v173[v168], v174 - v168);
        *(_BYTE *)(a1[5] + v168) = v157;
        v193 = 1;
        goto LABEL_235;
      case 1u:
        v187 = v167 + 3;
        v188 = *((_DWORD *)a1 + 8);
        if (v187 <= v188)
        {
          v191 = (char *)a1[5];
          v192 = v168;
        }
        else
        {
          if (v188 <= 1)
            v188 = 1;
          v189 = 2 * v188;
          if (v189 <= (int)v187)
            v190 = v187;
          else
            v190 = v189;
          v191 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v190, "Vector Storage (uint8_t, growth)");
          memcpy(v191, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v190;
          a1[5] = v191;
          v192 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v191[v168 + 1], &v191[v168], v192 - v168);
        *(_WORD *)(a1[5] + v168) = v157;
        v193 = 2;
        goto LABEL_235;
      case 2u:
        v175 = v167 + 4;
        v176 = *((_DWORD *)a1 + 8);
        if (v175 <= v176)
        {
          v179 = (char *)a1[5];
          v180 = v168;
        }
        else
        {
          if (v176 <= 1)
            v176 = 1;
          v177 = 2 * v176;
          if (v177 <= (int)v175)
            v178 = v175;
          else
            v178 = v177;
          v179 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v178, "Vector Storage (uint8_t, growth)");
          memcpy(v179, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v178;
          a1[5] = v179;
          v180 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v179[v168 + 1], &v179[v168], v180 - v168);
        v194 = a1[5] + v168;
        *(_BYTE *)(v194 + 2) = BYTE2(v157);
        *(_WORD *)v194 = v157;
        v193 = 3;
        goto LABEL_235;
      case 3u:
        v181 = v167 + 5;
        v182 = *((_DWORD *)a1 + 8);
        if (v181 <= v182)
        {
          v185 = (char *)a1[5];
          v186 = v168;
        }
        else
        {
          if (v182 <= 1)
            v182 = 1;
          v183 = 2 * v182;
          if (v183 <= (int)v181)
            v184 = v181;
          else
            v184 = v183;
          v185 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v184, "Vector Storage (uint8_t, growth)");
          memcpy(v185, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v184;
          a1[5] = v185;
          v186 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v185[v168 + 1], &v185[v168], v186 - v168);
        *(_DWORD *)(a1[5] + v168) = v157;
        v193 = 4;
LABEL_235:
        *((_DWORD *)a1 + 9) += v193;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t serializeSubroutineUniformFields(_QWORD *a1, uint64_t a2)
{
  unint64_t Extra;

  serializeASTFields(a1, a2);
  Extra = glpSubroutineUniformNodeGetExtra(a2);
  return serialize_GLPSubroutineUniformObject(a1, Extra);
}

void *serializeASTFields(_QWORD *a1, uint64_t a2)
{
  uint64_t Kind;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  int v18;
  uint64_t v19;
  char *v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  uint64_t v25;
  char *v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  int v30;
  uint64_t v31;
  char *v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  int v36;
  uint64_t v37;
  char *v38;
  unsigned int v39;
  int v40;
  uint64_t v41;
  unint64_t SaFlags;
  int v43;
  int v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  char *v49;
  int v50;
  uint64_t SaType;
  unsigned int v52;
  unsigned int v53;
  int v54;
  uint64_t v55;
  int v56;
  int v57;
  uint64_t v58;
  char *v59;
  int v60;
  void *result;
  int v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  int v66;
  uint64_t v67;
  char *v68;
  unsigned int v69;
  unsigned int v70;
  int v71;
  int v72;
  uint64_t v73;
  char *v74;
  unsigned int v75;
  unsigned int v76;
  int v77;
  int v78;
  uint64_t v79;
  char *v80;
  unsigned int v81;
  unsigned int v82;
  int v83;
  int v84;
  uint64_t v85;
  char *v86;
  unsigned int v87;
  int v88;
  uint64_t v89;
  __n128 v90;
  unsigned int v91;

  Kind = glpASTNodeGetKind(a2);
  v5 = Kind;
  v6 = (char)glp_serialized_integer32_control(Kind);
  v7 = *((_DWORD *)a1 + 8);
  v8 = *((unsigned int *)a1 + 9);
  v9 = v8 + 1;
  if ((int)v8 + 1 <= v7)
  {
    v12 = (char *)a1[5];
    v13 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v7 <= 1)
      v7 = 1;
    v10 = 2 * v7;
    if (v10 <= v9)
      v11 = v9;
    else
      v11 = v10;
    v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
    memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v11;
    a1[5] = v12;
    v13 = *((_DWORD *)a1 + 9);
  }
  memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
  *(_BYTE *)(a1[5] + v8) = v6;
  v14 = *((_DWORD *)a1 + 9);
  v15 = v14 + 1;
  *((_DWORD *)a1 + 9) = v14 + 1;
  if ((v6 & 0x80000000) != 0)
  {
    switch((v6 >> 1) & 7)
    {
      case 0u:
        v16 = v14 + 2;
        v17 = *((_DWORD *)a1 + 8);
        if (v16 <= v17)
        {
          v20 = (char *)a1[5];
          v21 = v15;
        }
        else
        {
          if (v17 <= 1)
            v17 = 1;
          v18 = 2 * v17;
          if (v18 <= (int)v16)
            v19 = v16;
          else
            v19 = v18;
          v20 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v19, "Vector Storage (uint8_t, growth)");
          memcpy(v20, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v19;
          a1[5] = v20;
          v21 = *((_DWORD *)a1 + 9);
        }
        memmove(&v20[v15 + 1], &v20[v15], v21 - v15);
        *(_BYTE *)(a1[5] + v15) = v5;
        v40 = 1;
        goto LABEL_47;
      case 1u:
        v22 = v14 + 3;
        v23 = *((_DWORD *)a1 + 8);
        if (v22 <= v23)
        {
          v26 = (char *)a1[5];
          v27 = v15;
        }
        else
        {
          if (v23 <= 1)
            v23 = 1;
          v24 = 2 * v23;
          if (v24 <= (int)v22)
            v25 = v22;
          else
            v25 = v24;
          v26 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v25, "Vector Storage (uint8_t, growth)");
          memcpy(v26, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v25;
          a1[5] = v26;
          v27 = *((_DWORD *)a1 + 9);
        }
        memmove(&v26[v15 + 1], &v26[v15], v27 - v15);
        *(_WORD *)(a1[5] + v15) = v5;
        v40 = 2;
        goto LABEL_47;
      case 2u:
        v28 = v14 + 4;
        v29 = *((_DWORD *)a1 + 8);
        if (v28 <= v29)
        {
          v32 = (char *)a1[5];
          v33 = v15;
        }
        else
        {
          if (v29 <= 1)
            v29 = 1;
          v30 = 2 * v29;
          if (v30 <= (int)v28)
            v31 = v28;
          else
            v31 = v30;
          v32 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v31, "Vector Storage (uint8_t, growth)");
          memcpy(v32, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v31;
          a1[5] = v32;
          v33 = *((_DWORD *)a1 + 9);
        }
        memmove(&v32[v15 + 1], &v32[v15], v33 - v15);
        v41 = a1[5] + v15;
        *(_BYTE *)(v41 + 2) = BYTE2(v5);
        *(_WORD *)v41 = v5;
        v40 = 3;
        goto LABEL_47;
      case 3u:
        v34 = v14 + 5;
        v35 = *((_DWORD *)a1 + 8);
        if (v34 <= v35)
        {
          v38 = (char *)a1[5];
          v39 = v15;
        }
        else
        {
          if (v35 <= 1)
            v35 = 1;
          v36 = 2 * v35;
          if (v36 <= (int)v34)
            v37 = v34;
          else
            v37 = v36;
          v38 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v37, "Vector Storage (uint8_t, growth)");
          memcpy(v38, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v37;
          a1[5] = v38;
          v39 = *((_DWORD *)a1 + 9);
        }
        memmove(&v38[v15 + 1], &v38[v15], v39 - v15);
        *(_DWORD *)(a1[5] + v15) = v5;
        v40 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v40;
        break;
      default:
        break;
    }
  }
  SaFlags = glpASTNodeGetSaFlags(a2);
  v43 = (char)glp_serialized_integer64_control(SaFlags);
  v44 = *((_DWORD *)a1 + 8);
  v45 = *((unsigned int *)a1 + 9);
  v46 = v45 + 1;
  if ((int)v45 + 1 <= v44)
  {
    v49 = (char *)a1[5];
    v50 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v44 <= 1)
      v44 = 1;
    v47 = 2 * v44;
    if (v47 <= v46)
      v48 = v46;
    else
      v48 = v47;
    v49 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v48, "Vector Storage (uint8_t, growth)");
    memcpy(v49, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v48;
    a1[5] = v49;
    v50 = *((_DWORD *)a1 + 9);
  }
  memmove(&v49[v45 + 1], &v49[v45], (v50 - v45));
  *(_BYTE *)(a1[5] + v45) = v43;
  ++*((_DWORD *)a1 + 9);
  if (v43 < 0)
    __asm { BR              X11 }
  SaType = glpASTNodeGetSaType(a2);
  serialize_GLPType(a1, SaType);
  glpASTNodeGetLocation(a2, &v90);
  serialize_GLPString(a1, (const char *)v90.n128_u64[0], v90.n128_i64[1]);
  v52 = v91;
  v53 = (char)glp_serialized_integer32_control(v91);
  v54 = *((_DWORD *)a1 + 8);
  v55 = *((unsigned int *)a1 + 9);
  v56 = v55 + 1;
  if ((int)v55 + 1 <= v54)
  {
    v59 = (char *)a1[5];
    v60 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v54 <= 1)
      v54 = 1;
    v57 = 2 * v54;
    if (v57 <= v56)
      v58 = v56;
    else
      v58 = v57;
    v59 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v58, "Vector Storage (uint8_t, growth)");
    memcpy(v59, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v58;
    a1[5] = v59;
    v60 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v59[v55 + 1], &v59[v55], (v60 - v55));
  *(_BYTE *)(a1[5] + v55) = v53;
  v62 = *((_DWORD *)a1 + 9);
  v63 = v62 + 1;
  *((_DWORD *)a1 + 9) = v62 + 1;
  if ((v53 & 0x80000000) != 0)
  {
    switch((v53 >> 1) & 7)
    {
      case 0u:
        v64 = v62 + 2;
        v65 = *((_DWORD *)a1 + 8);
        if (v64 <= v65)
        {
          v68 = (char *)a1[5];
          v69 = v63;
        }
        else
        {
          if (v65 <= 1)
            v65 = 1;
          v66 = 2 * v65;
          if (v66 <= (int)v64)
            v67 = v64;
          else
            v67 = v66;
          v68 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v67, "Vector Storage (uint8_t, growth)");
          memcpy(v68, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v67;
          a1[5] = v68;
          v69 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v68[v63 + 1], &v68[v63], v69 - v63);
        *(_BYTE *)(a1[5] + v63) = v52;
        v88 = 1;
        goto LABEL_104;
      case 1u:
        v70 = v62 + 3;
        v71 = *((_DWORD *)a1 + 8);
        if (v70 <= v71)
        {
          v74 = (char *)a1[5];
          v75 = v63;
        }
        else
        {
          if (v71 <= 1)
            v71 = 1;
          v72 = 2 * v71;
          if (v72 <= (int)v70)
            v73 = v70;
          else
            v73 = v72;
          v74 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v73, "Vector Storage (uint8_t, growth)");
          memcpy(v74, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v73;
          a1[5] = v74;
          v75 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v74[v63 + 1], &v74[v63], v75 - v63);
        *(_WORD *)(a1[5] + v63) = v52;
        v88 = 2;
        goto LABEL_104;
      case 2u:
        v76 = v62 + 4;
        v77 = *((_DWORD *)a1 + 8);
        if (v76 <= v77)
        {
          v80 = (char *)a1[5];
          v81 = v63;
        }
        else
        {
          if (v77 <= 1)
            v77 = 1;
          v78 = 2 * v77;
          if (v78 <= (int)v76)
            v79 = v76;
          else
            v79 = v78;
          v80 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v79, "Vector Storage (uint8_t, growth)");
          memcpy(v80, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v79;
          a1[5] = v80;
          v81 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v80[v63 + 1], &v80[v63], v81 - v63);
        v89 = a1[5] + v63;
        *(_BYTE *)(v89 + 2) = BYTE2(v52);
        *(_WORD *)v89 = v52;
        v88 = 3;
        goto LABEL_104;
      case 3u:
        v82 = v62 + 5;
        v83 = *((_DWORD *)a1 + 8);
        if (v82 <= v83)
        {
          v86 = (char *)a1[5];
          v87 = v63;
        }
        else
        {
          if (v83 <= 1)
            v83 = 1;
          v84 = 2 * v83;
          if (v84 <= (int)v82)
            v85 = v82;
          else
            v85 = v84;
          v86 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v85, "Vector Storage (uint8_t, growth)");
          memcpy(v86, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v85;
          a1[5] = v86;
          v87 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v86[v63 + 1], &v86[v63], v87 - v63);
        *(_DWORD *)(a1[5] + v63) = v52;
        v88 = 4;
LABEL_104:
        *((_DWORD *)a1 + 9) += v88;
        break;
      default:
        return result;
    }
  }
  return result;
}

void *serializeCallFields(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  void *result;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  int v41;
  uint64_t v42;

  serializeASTFields(a1, a2);
  v4 = glpCallNodeGetArgCount(a2);
  v5 = v4;
  v6 = (char)glp_serialized_integer32_control(v4);
  v7 = *((_DWORD *)a1 + 8);
  v8 = *((unsigned int *)a1 + 9);
  v9 = v8 + 1;
  if ((int)v8 + 1 <= v7)
  {
    v12 = (char *)a1[5];
    v13 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v7 <= 1)
      v7 = 1;
    v10 = 2 * v7;
    if (v10 <= v9)
      v11 = v9;
    else
      v11 = v10;
    v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
    memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v11;
    a1[5] = v12;
    v13 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
  *(_BYTE *)(a1[5] + v8) = v6;
  v15 = *((_DWORD *)a1 + 9);
  v16 = v15 + 1;
  *((_DWORD *)a1 + 9) = v15 + 1;
  if ((v6 & 0x80000000) != 0)
  {
    switch((v6 >> 1) & 7)
    {
      case 0u:
        v17 = v15 + 2;
        v18 = *((_DWORD *)a1 + 8);
        if (v17 <= v18)
        {
          v21 = (char *)a1[5];
          v22 = v16;
        }
        else
        {
          if (v18 <= 1)
            v18 = 1;
          v19 = 2 * v18;
          if (v19 <= (int)v17)
            v20 = v17;
          else
            v20 = v19;
          v21 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v20, "Vector Storage (uint8_t, growth)");
          memcpy(v21, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v20;
          a1[5] = v21;
          v22 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v21[v16 + 1], &v21[v16], v22 - v16);
        *(_BYTE *)(a1[5] + v16) = v5;
        v41 = 1;
        goto LABEL_47;
      case 1u:
        v35 = v15 + 3;
        v36 = *((_DWORD *)a1 + 8);
        if (v35 <= v36)
        {
          v39 = (char *)a1[5];
          v40 = v16;
        }
        else
        {
          if (v36 <= 1)
            v36 = 1;
          v37 = 2 * v36;
          if (v37 <= (int)v35)
            v38 = v35;
          else
            v38 = v37;
          v39 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v38, "Vector Storage (uint8_t, growth)");
          memcpy(v39, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v38;
          a1[5] = v39;
          v40 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v39[v16 + 1], &v39[v16], v40 - v16);
        *(_WORD *)(a1[5] + v16) = v5;
        v41 = 2;
        goto LABEL_47;
      case 2u:
        v23 = v15 + 4;
        v24 = *((_DWORD *)a1 + 8);
        if (v23 <= v24)
        {
          v27 = (char *)a1[5];
          v28 = v16;
        }
        else
        {
          if (v24 <= 1)
            v24 = 1;
          v25 = 2 * v24;
          if (v25 <= (int)v23)
            v26 = v23;
          else
            v26 = v25;
          v27 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v26, "Vector Storage (uint8_t, growth)");
          memcpy(v27, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v26;
          a1[5] = v27;
          v28 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v27[v16 + 1], &v27[v16], v28 - v16);
        v42 = a1[5] + v16;
        *(_BYTE *)(v42 + 2) = BYTE2(v5);
        *(_WORD *)v42 = v5;
        v41 = 3;
        goto LABEL_47;
      case 3u:
        v29 = v15 + 5;
        v30 = *((_DWORD *)a1 + 8);
        if (v29 <= v30)
        {
          v33 = (char *)a1[5];
          v34 = v16;
        }
        else
        {
          if (v30 <= 1)
            v30 = 1;
          v31 = 2 * v30;
          if (v31 <= (int)v29)
            v32 = v29;
          else
            v32 = v31;
          v33 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v32, "Vector Storage (uint8_t, growth)");
          memcpy(v33, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v32;
          a1[5] = v33;
          v34 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v33[v16 + 1], &v33[v16], v34 - v16);
        *(_DWORD *)(a1[5] + v16) = v5;
        v41 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v41;
        break;
      default:
        return result;
    }
  }
  return result;
}

void *serializeStructureFields(_QWORD *a1, uint64_t a2)
{
  uint64_t FieldCount;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  void *result;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  unsigned int v40;
  int v41;
  uint64_t v42;

  serializeASTFields(a1, a2);
  FieldCount = glpStructureNodeGetFieldCount(a2);
  v5 = FieldCount;
  v6 = (char)glp_serialized_integer32_control(FieldCount);
  v7 = *((_DWORD *)a1 + 8);
  v8 = *((unsigned int *)a1 + 9);
  v9 = v8 + 1;
  if ((int)v8 + 1 <= v7)
  {
    v12 = (char *)a1[5];
    v13 = *((_DWORD *)a1 + 9);
  }
  else
  {
    if (v7 <= 1)
      v7 = 1;
    v10 = 2 * v7;
    if (v10 <= v9)
      v11 = v9;
    else
      v11 = v10;
    v12 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v11, "Vector Storage (uint8_t, growth)");
    memcpy(v12, (const void *)a1[5], *((unsigned int *)a1 + 9));
    ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
    *((_DWORD *)a1 + 8) = v11;
    a1[5] = v12;
    v13 = *((_DWORD *)a1 + 9);
  }
  result = memmove(&v12[v8 + 1], &v12[v8], (v13 - v8));
  *(_BYTE *)(a1[5] + v8) = v6;
  v15 = *((_DWORD *)a1 + 9);
  v16 = v15 + 1;
  *((_DWORD *)a1 + 9) = v15 + 1;
  if ((v6 & 0x80000000) != 0)
  {
    switch((v6 >> 1) & 7)
    {
      case 0u:
        v17 = v15 + 2;
        v18 = *((_DWORD *)a1 + 8);
        if (v17 <= v18)
        {
          v21 = (char *)a1[5];
          v22 = v16;
        }
        else
        {
          if (v18 <= 1)
            v18 = 1;
          v19 = 2 * v18;
          if (v19 <= (int)v17)
            v20 = v17;
          else
            v20 = v19;
          v21 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v20, "Vector Storage (uint8_t, growth)");
          memcpy(v21, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v20;
          a1[5] = v21;
          v22 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v21[v16 + 1], &v21[v16], v22 - v16);
        *(_BYTE *)(a1[5] + v16) = v5;
        v41 = 1;
        goto LABEL_47;
      case 1u:
        v35 = v15 + 3;
        v36 = *((_DWORD *)a1 + 8);
        if (v35 <= v36)
        {
          v39 = (char *)a1[5];
          v40 = v16;
        }
        else
        {
          if (v36 <= 1)
            v36 = 1;
          v37 = 2 * v36;
          if (v37 <= (int)v35)
            v38 = v35;
          else
            v38 = v37;
          v39 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v38, "Vector Storage (uint8_t, growth)");
          memcpy(v39, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v38;
          a1[5] = v39;
          v40 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v39[v16 + 1], &v39[v16], v40 - v16);
        *(_WORD *)(a1[5] + v16) = v5;
        v41 = 2;
        goto LABEL_47;
      case 2u:
        v23 = v15 + 4;
        v24 = *((_DWORD *)a1 + 8);
        if (v23 <= v24)
        {
          v27 = (char *)a1[5];
          v28 = v16;
        }
        else
        {
          if (v24 <= 1)
            v24 = 1;
          v25 = 2 * v24;
          if (v25 <= (int)v23)
            v26 = v23;
          else
            v26 = v25;
          v27 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v26, "Vector Storage (uint8_t, growth)");
          memcpy(v27, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v26;
          a1[5] = v27;
          v28 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v27[v16 + 1], &v27[v16], v28 - v16);
        v42 = a1[5] + v16;
        *(_BYTE *)(v42 + 2) = BYTE2(v5);
        *(_WORD *)v42 = v5;
        v41 = 3;
        goto LABEL_47;
      case 3u:
        v29 = v15 + 5;
        v30 = *((_DWORD *)a1 + 8);
        if (v29 <= v30)
        {
          v33 = (char *)a1[5];
          v34 = v16;
        }
        else
        {
          if (v30 <= 1)
            v30 = 1;
          v31 = 2 * v30;
          if (v31 <= (int)v29)
            v32 = v29;
          else
            v32 = v31;
          v33 = (char *)((uint64_t (*)(_QWORD, uint64_t, const char *))a1[1])(*a1, v32, "Vector Storage (uint8_t, growth)");
          memcpy(v33, (const void *)a1[5], *((unsigned int *)a1 + 9));
          ((void (*)(_QWORD, _QWORD))a1[3])(*a1, a1[5]);
          *((_DWORD *)a1 + 8) = v32;
          a1[5] = v33;
          v34 = *((_DWORD *)a1 + 9);
        }
        result = memmove(&v33[v16 + 1], &v33[v16], v34 - v16);
        *(_DWORD *)(a1[5] + v16) = v5;
        v41 = 4;
LABEL_47:
        *((_DWORD *)a1 + 9) += v41;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t serialize_GLPSubroutineUniformObject(_QWORD *a1, unint64_t a2)
{
  uint64_t result;

  result = serialize_pointer(a1, a2);
  if ((_DWORD)result)
  {
    serialize_GLPString(a1, *(const char **)a2, *(_QWORD *)(a2 + 8));
    return serialize_GLPType(a1, *(_QWORD *)(a2 + 16));
  }
  return result;
}

uint64_t glpMakeCopyVarDeclFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  __n128 v7;
  unint64_t v8;

  v7 = *a2;
  v8 = a2[1].n128_u64[0];
  glpMakeVariableDeclarationNode(a1, &v7, a3, a4, 0);
  v5 = v4;
  glpVariableDeclarationNodeSetType(v4, 0);
  glpVariableDeclarationNodeSetInitializer(v5, 0);
  return v5;
}

uint64_t glpMakeCopyFunctionDefinitionFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t BlockNode;
  uint64_t v9;
  uint64_t v10;
  __n128 v12;
  unint64_t v13;

  v12 = *a2;
  v13 = a2[1].n128_u64[0];
  BlockNode = glpMakeBlockNode(a1, &v12, 0);
  *a4 = BlockNode;
  v12 = *a2;
  v13 = a2[1].n128_u64[0];
  glpMakeFunctionDefinitionNode(a1, &v12);
  v10 = v9;
  glpFunctionDefinitionNodeSetPrototype(v9, a3);
  glpFunctionDefinitionNodeSetBody(v10, BlockNode);
  return v10;
}

uint64_t glpMakeCopyInAssignFragment(uint64_t a1, __n128 *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t *a8, uint64_t a9, uint64_t *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t *a14)
{
  char *PrimitiveType;
  uint64_t v23;
  uint64_t v24;
  uint64_t OffsetNode;
  uint64_t LValueNode;
  uint64_t v27;
  uint64_t v28;
  uint64_t AssignNode;
  __n128 v31;
  unint64_t v32;

  PrimitiveType = glpGetPrimitiveType(5u);
  v31 = *a2;
  v32 = a2[1].n128_u64[0];
  glpMakeConstantNode(a1, &v31, (uint64_t)PrimitiveType, a9);
  v24 = v23;
  *a8 = v23;
  v31 = *a2;
  v32 = a2[1].n128_u64[0];
  OffsetNode = glpMakeOffsetNode(a1, (__int128 *)&v31);
  glpOffsetNodeSetBankIndex(OffsetNode, 0);
  glpOffsetNodeSetOffsetExpr(OffsetNode, v24);
  glpOffsetNodeSetVectorElementExpr(OffsetNode, 0);
  *a7 = OffsetNode;
  v31 = *a2;
  v32 = a2[1].n128_u64[0];
  LValueNode = glpMakeLValueNode(a1, &v31, a4, a5, a6);
  glpDerefNodeSetOffset(LValueNode, OffsetNode);
  *a3 = LValueNode;
  v31 = *a2;
  v32 = a2[1].n128_u64[0];
  v27 = glpMakeOffsetNode(a1, (__int128 *)&v31);
  glpOffsetNodeSetBankIndex(v27, 0);
  glpOffsetNodeSetOffsetExpr(v27, 0);
  glpOffsetNodeSetVectorElementExpr(v27, 0);
  *a14 = v27;
  v31 = *a2;
  v32 = a2[1].n128_u64[0];
  v28 = glpMakeLValueNode(a1, &v31, a11, a12, a13);
  glpDerefNodeSetOffset(v28, v27);
  *a10 = v28;
  v31 = *a2;
  v32 = a2[1].n128_u64[0];
  AssignNode = glpMakeAssignNode(a1, &v31, 0);
  glpBinaryOperatorNodeSetLhs(AssignNode, LValueNode);
  glpBinaryOperatorNodeSetRhs(AssignNode, v28);
  return AssignNode;
}

uint64_t glpMakeCopyOutAssignFragment(uint64_t a1, __n128 *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t *a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12, uint64_t *a13, uint64_t a14)
{
  uint64_t OffsetNode;
  uint64_t LValueNode;
  char *PrimitiveType;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t AssignNode;
  __n128 v31;
  unint64_t v32;

  v31 = *a2;
  v32 = a2[1].n128_u64[0];
  OffsetNode = glpMakeOffsetNode(a1, (__int128 *)&v31);
  glpOffsetNodeSetBankIndex(OffsetNode, 0);
  glpOffsetNodeSetOffsetExpr(OffsetNode, 0);
  glpOffsetNodeSetVectorElementExpr(OffsetNode, 0);
  *a7 = OffsetNode;
  v31 = *a2;
  v32 = a2[1].n128_u64[0];
  LValueNode = glpMakeLValueNode(a1, &v31, a4, a5, a6);
  glpDerefNodeSetOffset(LValueNode, OffsetNode);
  *a3 = LValueNode;
  PrimitiveType = glpGetPrimitiveType(5u);
  v31 = *a2;
  v32 = a2[1].n128_u64[0];
  glpMakeConstantNode(a1, &v31, (uint64_t)PrimitiveType, a14);
  v25 = v24;
  *a13 = v24;
  v31 = *a2;
  v32 = a2[1].n128_u64[0];
  v26 = glpMakeOffsetNode(a1, (__int128 *)&v31);
  glpOffsetNodeSetBankIndex(v26, 0);
  glpOffsetNodeSetOffsetExpr(v26, v25);
  glpOffsetNodeSetVectorElementExpr(v26, 0);
  *a12 = v26;
  v31 = *a2;
  v32 = a2[1].n128_u64[0];
  v27 = glpMakeLValueNode(a1, &v31, a9, a10, a11);
  glpDerefNodeSetOffset(v27, v26);
  *a8 = v27;
  v31 = *a2;
  v32 = a2[1].n128_u64[0];
  AssignNode = glpMakeAssignNode(a1, &v31, 0);
  glpBinaryOperatorNodeSetLhs(AssignNode, LValueNode);
  glpBinaryOperatorNodeSetRhs(AssignNode, v27);
  return AssignNode;
}

uint64_t glpMakeVRLFunctionFragment(_QWORD *a1, __n128 *a2, uint64_t a3)
{
  uint64_t PPStreamOpNode;
  __n128 v7;
  unint64_t v8;

  v7 = *a2;
  v8 = a2[1].n128_u64[0];
  PPStreamOpNode = glpMakePPStreamOpNode((uint64_t)a1, &v7, 0, 121, 0, 0, 0);
  glpCallNodeAddArg(a1, PPStreamOpNode, a3);
  return PPStreamOpNode;
}

uint64_t glpMakeStoreFragment(_QWORD *a1, __n128 *a2, int a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t *a14, uint64_t *a15, uint64_t a16)
{
  char *PrimitiveType;
  uint64_t v24;
  uint64_t v25;
  uint64_t LValueNode;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t OffsetNode;
  uint64_t v31;
  uint64_t PPStreamOpNode;
  __n128 v35;
  unint64_t v36;

  PrimitiveType = glpGetPrimitiveType(5u);
  v35 = *a2;
  v36 = a2[1].n128_u64[0];
  glpMakeConstantNode((uint64_t)a1, &v35, (uint64_t)PrimitiveType, a5);
  v25 = v24;
  *a4 = v24;
  v35 = *a2;
  v36 = a2[1].n128_u64[0];
  LValueNode = glpMakeLValueNode((uint64_t)a1, &v35, a7, a8, a9);
  glpDerefNodeSetOffset(LValueNode, 0);
  *a6 = LValueNode;
  v27 = glpGetPrimitiveType(5u);
  v35 = *a2;
  v36 = a2[1].n128_u64[0];
  glpMakeConstantNode((uint64_t)a1, &v35, (uint64_t)v27, a16);
  v29 = v28;
  *a15 = v28;
  v35 = *a2;
  v36 = a2[1].n128_u64[0];
  OffsetNode = glpMakeOffsetNode((uint64_t)a1, (__int128 *)&v35);
  glpOffsetNodeSetBankIndex(OffsetNode, 0);
  glpOffsetNodeSetOffsetExpr(OffsetNode, v29);
  glpOffsetNodeSetVectorElementExpr(OffsetNode, 0);
  *a14 = OffsetNode;
  v35 = *a2;
  v36 = a2[1].n128_u64[0];
  v31 = glpMakeLValueNode((uint64_t)a1, &v35, a11, a12, a13);
  glpDerefNodeSetOffset(v31, OffsetNode);
  *a10 = v31;
  v35 = *a2;
  v36 = a2[1].n128_u64[0];
  PPStreamOpNode = glpMakePPStreamOpNode((uint64_t)a1, &v35, 0, 153, a3, 0, 0);
  glpCallNodeAddArg(a1, PPStreamOpNode, v25);
  glpCallNodeAddArg(a1, PPStreamOpNode, LValueNode);
  glpCallNodeAddArg(a1, PPStreamOpNode, v31);
  return PPStreamOpNode;
}

uint64_t glpMakeMainReturnFragment(_QWORD *a1, __n128 *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t ReturnStatementNode;
  uint64_t BlockNode;
  __n128 v14;
  unint64_t v15;

  v14 = *a2;
  v15 = a2[1].n128_u64[0];
  glpMakeRawCallNode((uint64_t)a1, &v14, a4, a5, a6);
  v10 = v9;
  *a3 = v9;
  v14 = *a2;
  v15 = a2[1].n128_u64[0];
  ReturnStatementNode = glpMakeReturnStatementNode((uint64_t)a1, &v14);
  glpReturnStatementNodeSetExpr(ReturnStatementNode, 0);
  v14 = *a2;
  v15 = a2[1].n128_u64[0];
  BlockNode = glpMakeBlockNode((uint64_t)a1, &v14, 0);
  glpBlockNodeAddStatement(a1, BlockNode, v10);
  glpBlockNodeAddStatement(a1, BlockNode, ReturnStatementNode);
  return BlockNode;
}

uint64_t glpMakeIncrementFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *Allocator;
  uint64_t SaType;
  uint64_t PrimitiveType;
  int ScalarType;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t IntConstant;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t AddNode;
  uint64_t AssignNode;
  __n128 v22;
  unint64_t v23;

  Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
  SaType = glpASTNodeGetSaType(a3);
  PrimitiveType = glpPrimitiveTypeGetPrimitiveType(SaType);
  ScalarType = glpPrimitiveTypeGetScalarType(PrimitiveType);
  v22 = *a2;
  v23 = a2[1].n128_u64[0];
  glpMakePrimitiveTypeNode((uint64_t)Allocator, &v22, ScalarType);
  v13 = v12;
  v14 = glpGetPrimitiveType(5u);
  IntConstant = glpCompilerGetIntConstant(a1, 1);
  v22 = *a2;
  v23 = a2[1].n128_u64[0];
  glpMakeConstantNode((uint64_t)Allocator, &v22, (uint64_t)v14, IntConstant);
  v17 = v16;
  v22 = *a2;
  v23 = a2[1].n128_u64[0];
  v18 = glpMakeConstructorCallNode((uint64_t)Allocator, &v22);
  glpConstructorCallNodeSetType(v18, v13);
  glpCallNodeAddArg(Allocator, v18, v17);
  v22 = *a2;
  v23 = a2[1].n128_u64[0];
  AddNode = glpMakeAddNode((uint64_t)Allocator, &v22);
  glpBinaryOperatorNodeSetLhs(AddNode, a4);
  glpBinaryOperatorNodeSetRhs(AddNode, v18);
  v22 = *a2;
  v23 = a2[1].n128_u64[0];
  AssignNode = glpMakeAssignNode((uint64_t)Allocator, &v22, 0);
  glpBinaryOperatorNodeSetLhs(AssignNode, a3);
  glpBinaryOperatorNodeSetRhs(AssignNode, AddNode);
  return glpSANode(a1, AssignNode);
}

uint64_t glpMakeDecrementFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *Allocator;
  uint64_t SaType;
  uint64_t PrimitiveType;
  int ScalarType;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t IntConstant;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t SubtractNode;
  uint64_t AssignNode;
  __n128 v22;
  unint64_t v23;

  Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
  SaType = glpASTNodeGetSaType(a3);
  PrimitiveType = glpPrimitiveTypeGetPrimitiveType(SaType);
  ScalarType = glpPrimitiveTypeGetScalarType(PrimitiveType);
  v22 = *a2;
  v23 = a2[1].n128_u64[0];
  glpMakePrimitiveTypeNode((uint64_t)Allocator, &v22, ScalarType);
  v13 = v12;
  v14 = glpGetPrimitiveType(5u);
  IntConstant = glpCompilerGetIntConstant(a1, 1);
  v22 = *a2;
  v23 = a2[1].n128_u64[0];
  glpMakeConstantNode((uint64_t)Allocator, &v22, (uint64_t)v14, IntConstant);
  v17 = v16;
  v22 = *a2;
  v23 = a2[1].n128_u64[0];
  v18 = glpMakeConstructorCallNode((uint64_t)Allocator, &v22);
  glpConstructorCallNodeSetType(v18, v13);
  glpCallNodeAddArg(Allocator, v18, v17);
  v22 = *a2;
  v23 = a2[1].n128_u64[0];
  SubtractNode = glpMakeSubtractNode((uint64_t)Allocator, &v22);
  glpBinaryOperatorNodeSetLhs(SubtractNode, a4);
  glpBinaryOperatorNodeSetRhs(SubtractNode, v18);
  v22 = *a2;
  v23 = a2[1].n128_u64[0];
  AssignNode = glpMakeAssignNode((uint64_t)Allocator, &v22, 0);
  glpBinaryOperatorNodeSetLhs(AssignNode, a3);
  glpBinaryOperatorNodeSetRhs(AssignNode, SubtractNode);
  return glpSANode(a1, AssignNode);
}

uint64_t glpMakeConstantValueFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t Allocator;
  uint64_t v9;
  __n128 v11;
  unint64_t v12;

  Allocator = glpCompilerGetAllocator(a1);
  v11 = *a2;
  v12 = a2[1].n128_u64[0];
  glpMakeConstantNode(Allocator, &v11, a3, a4);
  return glpSANode(a1, v9);
}

uint64_t glpMakeArrayIndexOffsetFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t Allocator;
  char *PrimitiveType;
  uint64_t v12;
  uint64_t v13;
  uint64_t MultiplyNode;
  uint64_t AddNode;
  __n128 v17;
  unint64_t v18;

  Allocator = glpCompilerGetAllocator(a1);
  PrimitiveType = glpGetPrimitiveType(5u);
  v17 = *a2;
  v18 = a2[1].n128_u64[0];
  glpMakeConstantNode(Allocator, &v17, (uint64_t)PrimitiveType, a5);
  v13 = v12;
  v17 = *a2;
  v18 = a2[1].n128_u64[0];
  MultiplyNode = glpMakeMultiplyNode(Allocator, &v17);
  glpBinaryOperatorNodeSetLhs(MultiplyNode, a4);
  glpBinaryOperatorNodeSetRhs(MultiplyNode, v13);
  v17 = *a2;
  v18 = a2[1].n128_u64[0];
  AddNode = glpMakeAddNode(Allocator, &v17);
  glpBinaryOperatorNodeSetLhs(AddNode, a3);
  glpBinaryOperatorNodeSetRhs(AddNode, MultiplyNode);
  return glpSANode(a1, AddNode);
}

uint64_t glpMakeFieldOffsetFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t Allocator;
  char *PrimitiveType;
  uint64_t v10;
  uint64_t v11;
  uint64_t AddNode;
  __n128 v14;
  unint64_t v15;

  Allocator = glpCompilerGetAllocator(a1);
  PrimitiveType = glpGetPrimitiveType(5u);
  v14 = *a2;
  v15 = a2[1].n128_u64[0];
  glpMakeConstantNode(Allocator, &v14, (uint64_t)PrimitiveType, a4);
  v11 = v10;
  v14 = *a2;
  v15 = a2[1].n128_u64[0];
  AddNode = glpMakeAddNode(Allocator, &v14);
  glpBinaryOperatorNodeSetLhs(AddNode, a3);
  glpBinaryOperatorNodeSetRhs(AddNode, v11);
  return glpSANode(a1, AddNode);
}

uint64_t glpMakeIfExprFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *Allocator;
  char SaFlags;
  int v17;
  uint64_t KeywordQualifierNode;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t AssignNode;
  uint64_t BlockNode;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t IfStatementNode;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __n128 v38;
  unint64_t v39;

  Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
  SaFlags = glpASTNodeGetSaFlags(a7);
  v17 = glpPrecisionQualifierFromSaFlags(SaFlags);
  v38 = *a2;
  v39 = a2[1].n128_u64[0];
  KeywordQualifierNode = glpMakeKeywordQualifierNode((uint64_t)Allocator, &v38, v17);
  v38 = *a2;
  v39 = a2[1].n128_u64[0];
  glpMakeQualifiedTypeNode((uint64_t)Allocator, &v38);
  v20 = v19;
  glpQualifiedTypeNodeSetType(v19, a5);
  glpQualifiedTypeNodeSetQualifiers(v20, KeywordQualifierNode);
  v38 = *a2;
  v39 = a2[1].n128_u64[0];
  glpMakeVariableDeclarationNode((uint64_t)Allocator, &v38, a3, a4, 0);
  v22 = v21;
  glpVariableDeclarationNodeSetType(v21, v20);
  glpVariableDeclarationNodeSetInitializer(v22, 0);
  v38 = *a2;
  v39 = a2[1].n128_u64[0];
  glpMakeVariableIdentifierNode((uint64_t)Allocator, &v38, a3, a4);
  v24 = v23;
  v38 = *a2;
  v39 = a2[1].n128_u64[0];
  AssignNode = glpMakeAssignNode((uint64_t)Allocator, &v38, 0);
  glpBinaryOperatorNodeSetLhs(AssignNode, v24);
  glpBinaryOperatorNodeSetRhs(AssignNode, a7);
  v38 = *a2;
  v39 = a2[1].n128_u64[0];
  BlockNode = glpMakeBlockNode((uint64_t)Allocator, &v38, 0);
  glpBlockNodeAddStatement(Allocator, BlockNode, AssignNode);
  v38 = *a2;
  v39 = a2[1].n128_u64[0];
  glpMakeVariableIdentifierNode((uint64_t)Allocator, &v38, a3, a4);
  v28 = v27;
  v38 = *a2;
  v39 = a2[1].n128_u64[0];
  v29 = glpMakeAssignNode((uint64_t)Allocator, &v38, 0);
  glpBinaryOperatorNodeSetLhs(v29, v28);
  glpBinaryOperatorNodeSetRhs(v29, a8);
  v38 = *a2;
  v39 = a2[1].n128_u64[0];
  v30 = glpMakeBlockNode((uint64_t)Allocator, &v38, 0);
  glpBlockNodeAddStatement(Allocator, v30, v29);
  v38 = *a2;
  v39 = a2[1].n128_u64[0];
  IfStatementNode = glpMakeIfStatementNode((uint64_t)Allocator, &v38);
  glpIfStatementNodeSetCond(IfStatementNode, a6);
  glpIfStatementNodeSetIfStatement(IfStatementNode, BlockNode);
  glpIfStatementNodeSetElseStatement(IfStatementNode, v30);
  v38 = *a2;
  v39 = a2[1].n128_u64[0];
  glpMakeVariableIdentifierNode((uint64_t)Allocator, &v38, a3, a4);
  v33 = v32;
  v38 = *a2;
  v39 = a2[1].n128_u64[0];
  glpMakeCommaExprNode((uint64_t)Allocator, &v38, 0);
  v35 = v34;
  glpCommaExprNodeAddExpr(Allocator, v34, v22);
  glpCommaExprNodeAddExpr(Allocator, v35, IfStatementNode);
  glpCommaExprNodeAddExpr(Allocator, v35, v33);
  return glpSANode(a1, v35);
}

uint64_t glpMakeTypedVariableFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __n128 v17;
  unint64_t v18;

  v17 = *a2;
  v18 = a2[1].n128_u64[0];
  glpMakeTypeIdentifierNode(a1, &v17, (uint64_t)"<<BUG: placeholder type still exists>>", 0x781A7BE300000026);
  v13 = v12;
  *a5 = v12;
  v17 = *a2;
  v18 = a2[1].n128_u64[0];
  glpMakeVariableDeclarationNode(a1, &v17, a3, a4, 0);
  v15 = v14;
  glpVariableDeclarationNodeSetType(v14, v13);
  glpVariableDeclarationNodeSetInitializer(v15, a6);
  return v15;
}

uint64_t glpMakeFieldAccessFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  __n128 v9;
  unint64_t v10;

  v9 = *a2;
  v10 = a2[1].n128_u64[0];
  glpMakeFieldAccessNode(a1, &v9, a3, a4);
  v7 = v6;
  glpFieldAccessNodeSetStructure(v6, a5);
  return v7;
}

uint64_t glpMakeArrayAccessFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  char *PrimitiveType;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __n128 v14;
  unint64_t v15;

  PrimitiveType = glpGetPrimitiveType(5u);
  v14 = *a2;
  v15 = a2[1].n128_u64[0];
  glpMakeConstantNode(a1, &v14, (uint64_t)PrimitiveType, a4);
  v10 = v9;
  v14 = *a2;
  v15 = a2[1].n128_u64[0];
  glpMakeArrayAccessNode(a1, &v14);
  v12 = v11;
  glpArrayAccessNodeSetArray(v11, a3);
  glpArrayAccessNodeSetElement(v12, v10);
  return v12;
}

uint64_t glpMakeAssignFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t Allocator;
  uint64_t AssignNode;
  __n128 v11;
  unint64_t v12;

  Allocator = glpCompilerGetAllocator(a1);
  v11 = *a2;
  v12 = a2[1].n128_u64[0];
  AssignNode = glpMakeAssignNode(Allocator, &v11, 0);
  glpBinaryOperatorNodeSetLhs(AssignNode, a3);
  glpBinaryOperatorNodeSetRhs(AssignNode, a4);
  return glpSANode(a1, AssignNode);
}

uint64_t glpMakeEqualFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t Allocator;
  uint64_t EqualNode;
  __n128 v11;
  unint64_t v12;

  Allocator = glpCompilerGetAllocator(a1);
  v11 = *a2;
  v12 = a2[1].n128_u64[0];
  EqualNode = glpMakeEqualNode(Allocator, &v11, 0);
  glpBinaryOperatorNodeSetLhs(EqualNode, a3);
  glpBinaryOperatorNodeSetRhs(EqualNode, a4);
  return glpSANode(a1, EqualNode);
}

uint64_t glpMakeNotEqualFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t Allocator;
  uint64_t NotEqualNode;
  __n128 v11;
  unint64_t v12;

  Allocator = glpCompilerGetAllocator(a1);
  v11 = *a2;
  v12 = a2[1].n128_u64[0];
  NotEqualNode = glpMakeNotEqualNode(Allocator, &v11, 0);
  glpBinaryOperatorNodeSetLhs(NotEqualNode, a3);
  glpBinaryOperatorNodeSetRhs(NotEqualNode, a4);
  return glpSANode(a1, NotEqualNode);
}

uint64_t glpMakeLogicalAndFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t Allocator;
  uint64_t LogicalAndNode;
  __n128 v11;
  unint64_t v12;

  Allocator = glpCompilerGetAllocator(a1);
  v11 = *a2;
  v12 = a2[1].n128_u64[0];
  LogicalAndNode = glpMakeLogicalAndNode(Allocator, &v11);
  glpBinaryOperatorNodeSetLhs(LogicalAndNode, a3);
  glpBinaryOperatorNodeSetRhs(LogicalAndNode, a4);
  return glpSANode(a1, LogicalAndNode);
}

uint64_t glpMakeLogicalOrFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t Allocator;
  uint64_t LogicalOrNode;
  __n128 v11;
  unint64_t v12;

  Allocator = glpCompilerGetAllocator(a1);
  v11 = *a2;
  v12 = a2[1].n128_u64[0];
  LogicalOrNode = glpMakeLogicalOrNode(Allocator, &v11);
  glpBinaryOperatorNodeSetLhs(LogicalOrNode, a3);
  glpBinaryOperatorNodeSetRhs(LogicalOrNode, a4);
  return glpSANode(a1, LogicalOrNode);
}

uint64_t glpMakeAddFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t Allocator;
  uint64_t AddNode;
  __n128 v11;
  unint64_t v12;

  Allocator = glpCompilerGetAllocator(a1);
  v11 = *a2;
  v12 = a2[1].n128_u64[0];
  AddNode = glpMakeAddNode(Allocator, &v11);
  glpBinaryOperatorNodeSetLhs(AddNode, a3);
  glpBinaryOperatorNodeSetRhs(AddNode, a4);
  return glpSANode(a1, AddNode);
}

uint64_t glpMakeUnopFuncallFragment(_QWORD *a1, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  __n128 v9;
  unint64_t v10;

  v9 = *a2;
  v10 = a2[1].n128_u64[0];
  v7 = glpMakeFunctionCallNode((uint64_t)a1, &v9, a3, a4);
  glpCallNodeAddArg(a1, v7, a5);
  return v7;
}

uint64_t glpMakeBinopFuncallFragment(_QWORD *a1, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  __n128 v11;
  unint64_t v12;

  v11 = *a2;
  v12 = a2[1].n128_u64[0];
  v9 = glpMakeFunctionCallNode((uint64_t)a1, &v11, a3, a4);
  glpCallNodeAddArg(a1, v9, a5);
  glpCallNodeAddArg(a1, v9, a6);
  return v9;
}

uint64_t glpMakeSubroutineImplementationFragment(_QWORD *a1, __n128 *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t ReturnStatementNode;
  uint64_t BlockNode;
  uint64_t v20;
  uint64_t v21;
  __n128 v23;
  unint64_t v24;

  v23 = *a2;
  v24 = a2[1].n128_u64[0];
  glpMakeFunctionPrototypeNode((uint64_t)a1, &v23, a4, a5);
  v16 = v15;
  glpFunctionPrototypeNodeSetReturnType(v15, 0);
  glpFunctionPrototypeNodeSetReturnOutParam(v16, 0);
  *a3 = v16;
  v23 = *a2;
  v24 = a2[1].n128_u64[0];
  v17 = glpMakeFunctionCallNode((uint64_t)a1, &v23, a9, a10);
  *a7 = v17;
  v23 = *a2;
  v24 = a2[1].n128_u64[0];
  ReturnStatementNode = glpMakeReturnStatementNode((uint64_t)a1, &v23);
  glpReturnStatementNodeSetExpr(ReturnStatementNode, v17);
  v23 = *a2;
  v24 = a2[1].n128_u64[0];
  BlockNode = glpMakeBlockNode((uint64_t)a1, &v23, 0);
  glpBlockNodeAddStatement(a1, BlockNode, ReturnStatementNode);
  *a6 = BlockNode;
  v23 = *a2;
  v24 = a2[1].n128_u64[0];
  glpMakeFunctionDefinitionNode((uint64_t)a1, &v23);
  v21 = v20;
  glpFunctionDefinitionNodeSetPrototype(v20, v16);
  glpFunctionDefinitionNodeSetBody(v21, BlockNode);
  return v21;
}

uint64_t glpMakeSubroutineParameterFragment(uint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  __n128 v7;
  unint64_t v8;

  v7 = *a2;
  v8 = a2[1].n128_u64[0];
  glpMakeParameterDeclarationNode(a1, &v7, a3, a4);
  v5 = v4;
  glpParameterDeclarationNodeSetType(v4, 0);
  return v5;
}

uint64_t glpMakeWhileFragment(_QWORD *a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t LogicalNotNode;
  uint64_t BreakStatementNode;
  uint64_t IfStatementNode;
  uint64_t BlockNode;
  uint64_t LoopStatementNode;
  __n128 v14;
  unint64_t v15;

  v14 = *a2;
  v15 = a2[1].n128_u64[0];
  LogicalNotNode = glpMakeLogicalNotNode((uint64_t)a1, &v14);
  glpUnaryOperatorNodeSetExpr(LogicalNotNode, a3);
  v14 = *a2;
  v15 = a2[1].n128_u64[0];
  BreakStatementNode = glpMakeBreakStatementNode((uint64_t)a1, &v14);
  v14 = *a2;
  v15 = a2[1].n128_u64[0];
  IfStatementNode = glpMakeIfStatementNode((uint64_t)a1, &v14);
  glpIfStatementNodeSetCond(IfStatementNode, LogicalNotNode);
  glpIfStatementNodeSetIfStatement(IfStatementNode, BreakStatementNode);
  glpIfStatementNodeSetElseStatement(IfStatementNode, 0);
  v14 = *a2;
  v15 = a2[1].n128_u64[0];
  BlockNode = glpMakeBlockNode((uint64_t)a1, &v14, 1);
  glpBlockNodeAddStatement(a1, BlockNode, IfStatementNode);
  glpBlockNodeAddStatement(a1, BlockNode, a4);
  v14 = *a2;
  v15 = a2[1].n128_u64[0];
  LoopStatementNode = glpMakeLoopStatementNode((uint64_t)a1, &v14);
  glpLoopStatementNodeSetBody0(LoopStatementNode, BlockNode);
  glpLoopStatementNodeSetBody1(LoopStatementNode, 0);
  return LoopStatementNode;
}

uint64_t glpMakeDoWhileFragment(_QWORD *a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t BlockNode;
  uint64_t LogicalNotNode;
  uint64_t BreakStatementNode;
  uint64_t IfStatementNode;
  uint64_t v12;
  uint64_t LoopStatementNode;
  __n128 v15;
  unint64_t v16;

  v15 = *a2;
  v16 = a2[1].n128_u64[0];
  BlockNode = glpMakeBlockNode((uint64_t)a1, &v15, 1);
  glpBlockNodeAddStatement(a1, BlockNode, a3);
  v15 = *a2;
  v16 = a2[1].n128_u64[0];
  LogicalNotNode = glpMakeLogicalNotNode((uint64_t)a1, &v15);
  glpUnaryOperatorNodeSetExpr(LogicalNotNode, a4);
  v15 = *a2;
  v16 = a2[1].n128_u64[0];
  BreakStatementNode = glpMakeBreakStatementNode((uint64_t)a1, &v15);
  v15 = *a2;
  v16 = a2[1].n128_u64[0];
  IfStatementNode = glpMakeIfStatementNode((uint64_t)a1, &v15);
  glpIfStatementNodeSetCond(IfStatementNode, LogicalNotNode);
  glpIfStatementNodeSetIfStatement(IfStatementNode, BreakStatementNode);
  glpIfStatementNodeSetElseStatement(IfStatementNode, 0);
  v15 = *a2;
  v16 = a2[1].n128_u64[0];
  v12 = glpMakeBlockNode((uint64_t)a1, &v15, 1);
  glpBlockNodeAddStatement(a1, v12, IfStatementNode);
  v15 = *a2;
  v16 = a2[1].n128_u64[0];
  LoopStatementNode = glpMakeLoopStatementNode((uint64_t)a1, &v15);
  glpLoopStatementNodeSetBody0(LoopStatementNode, BlockNode);
  glpLoopStatementNodeSetBody1(LoopStatementNode, v12);
  return LoopStatementNode;
}

uint64_t glpMakeForFragment(_QWORD *a1, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t LogicalNotNode;
  uint64_t BreakStatementNode;
  uint64_t IfStatementNode;
  uint64_t BlockNode;
  uint64_t LoopStatementNode;
  uint64_t v17;
  __n128 v19;
  unint64_t v20;

  v19 = *a2;
  v20 = a2[1].n128_u64[0];
  LogicalNotNode = glpMakeLogicalNotNode((uint64_t)a1, &v19);
  glpUnaryOperatorNodeSetExpr(LogicalNotNode, a4);
  v19 = *a2;
  v20 = a2[1].n128_u64[0];
  BreakStatementNode = glpMakeBreakStatementNode((uint64_t)a1, &v19);
  v19 = *a2;
  v20 = a2[1].n128_u64[0];
  IfStatementNode = glpMakeIfStatementNode((uint64_t)a1, &v19);
  glpIfStatementNodeSetCond(IfStatementNode, LogicalNotNode);
  glpIfStatementNodeSetIfStatement(IfStatementNode, BreakStatementNode);
  glpIfStatementNodeSetElseStatement(IfStatementNode, 0);
  v19 = *a2;
  v20 = a2[1].n128_u64[0];
  BlockNode = glpMakeBlockNode((uint64_t)a1, &v19, 0);
  glpBlockNodeAddStatement(a1, BlockNode, IfStatementNode);
  glpBlockNodeAddStatement(a1, BlockNode, a5);
  v19 = *a2;
  v20 = a2[1].n128_u64[0];
  LoopStatementNode = glpMakeLoopStatementNode((uint64_t)a1, &v19);
  glpLoopStatementNodeSetBody0(LoopStatementNode, BlockNode);
  glpLoopStatementNodeSetBody1(LoopStatementNode, a6);
  v19 = *a2;
  v20 = a2[1].n128_u64[0];
  v17 = glpMakeBlockNode((uint64_t)a1, &v19, 1);
  glpBlockNodeAddStatement(a1, v17, a3);
  glpBlockNodeAddStatement(a1, v17, LoopStatementNode);
  return v17;
}

uint64_t glpDumpASTNodeToStringBuffer(uint64_t *a1, unint64_t a2)
{
  uint64_t PointerHash;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v15;
  char v16;

  PointerHash = glpMakePointerHash(&GLP_MALLOC_ALLOCATOR);
  writeASTNode(PointerHash, a1, a2, 0, 1, v5, v6, v7, v15);
  glpStringBufferAppendFormat(a1, "\n", v8, v9, v10, v11, v12, v13, v16);
  return glpDestroyPointerHash(PointerHash);
}

uint64_t writeASTNode(uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  char *v12;
  int v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  double v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t Child;
  int v46;
  char v48;
  char v49;
  char v50;

  v9 = a4;
  if (a3 == -1)
  {
    if ((_DWORD)a4)
    {
      v12 = "<<FAILED>>";
      do
      {
        glpStringBufferAppendFormat(a2, "    ", a3, a4, a5, a6, a7, a8, v48);
        LODWORD(v9) = v9 - 1;
      }
      while ((_DWORD)v9);
    }
    else
    {
      v12 = "<<FAILED>>";
    }
  }
  else
  {
    if (!a3)
    {
      if ((_DWORD)a4)
      {
        v12 = "NIL";
        do
        {
          glpStringBufferAppendFormat(a2, "    ", a3, a4, a5, a6, a7, a8, v48);
          LODWORD(v9) = v9 - 1;
        }
        while ((_DWORD)v9);
      }
      else
      {
        v12 = "NIL";
      }
      return glpStringBufferAppendFormat(a2, v12, a3, a4, a5, a6, a7, a8, a9);
    }
    v13 = a5;
    if (a1)
    {
      if (glpPointerHashGet(a1, a3))
      {
        if ((_DWORD)v9)
        {
          v22 = v9;
          do
          {
            glpStringBufferAppendFormat(a2, "    ", v15, v16, v17, v18, v19, v20, v48);
            --v22;
          }
          while (v22);
          glpStringBufferAppendFormat(a2, "<<PREVIOUSLY VISITED:\n", v15, v16, v17, v18, v19, v20, v48);
          writeASTNode(0, a2, a3, (v9 + 1), 0);
          glpStringBufferAppendFormat(a2, "\n", v23, v24, v25, v26, v27, v28, v49);
          v12 = ">>\n";
          do
          {
            glpStringBufferAppendFormat(a2, "    ", a3, a4, a5, a6, a7, a8, v50);
            LODWORD(v9) = v9 - 1;
          }
          while ((_DWORD)v9);
          return glpStringBufferAppendFormat(a2, v12, a3, a4, a5, a6, a7, a8, a9);
        }
        glpStringBufferAppendFormat(a2, "<<PREVIOUSLY VISITED:\n", v15, v16, v17, v18, v19, v20, v48);
        writeASTNode(0, a2, a3, 1, 0);
        v12 = ">>\n";
        v42 = "\n";
LABEL_126:
        glpStringBufferAppendFormat(a2, v42, v36, v37, v38, v39, v40, v41, v48);
        return glpStringBufferAppendFormat(a2, v12, a3, a4, a5, a6, a7, a8, a9);
      }
      glpPointerHashPut(a1, a3, 1, v21);
    }
    if ((_DWORD)v9)
    {
      v29 = v9;
      do
      {
        glpStringBufferAppendFormat(a2, "    ", a3, a4, a5, a6, a7, a8, v48);
        --v29;
      }
      while (v29);
    }
    switch(glpASTNodeGetKind(a3))
    {
      case 0u:
        writeTypeConversion(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 1u:
        writeVariableIdentifier(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 2u:
        writeTypeIdentifier(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 3u:
        writeConstant(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 4u:
        writeArrayAccess(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 5u:
        writeFieldAccess(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 6u:
        writeUndeterminedCall(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 7u:
        writeFunctionCall(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 8u:
        writeSubroutineArrayCall(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 9u:
        writeMethodCall(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 0xAu:
        writeConstructorCall(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0xBu:
        writePostincrement(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0xCu:
        writePostdecrement(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0xDu:
        writePreincrement(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0xEu:
        writePredecrement(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0xFu:
        writeUnaryPlus(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x10u:
        writeNegate(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x11u:
        writeLogicalNot(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x12u:
        writeBitwiseNot(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x13u:
        writeMultiply(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x14u:
        writeDivide(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x15u:
        writeModulo(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x16u:
        writeAdd(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x17u:
        writeSubtract(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x18u:
        writeShiftLeft(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x19u:
        writeShiftRight(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x1Au:
        writeLess(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x1Bu:
        writeLessEqual(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x1Cu:
        writeGreater(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x1Du:
        writeGreaterEqual(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x1Eu:
        writeEqual(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x1Fu:
        writeNotEqual(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x20u:
        writeLogicalAnd(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x21u:
        writeLogicalOr(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x22u:
        writeLogicalXor(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x23u:
        writeBitwiseAnd(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x24u:
        writeBitwiseOr(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x25u:
        writeBitwiseXor(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x26u:
        writeIfExpr(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x27u:
        writeAssign(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x28u:
        writeOpAssign(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x29u:
        writeReadInput(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x2Au:
        writeWriteOutput(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x2Bu:
        writeCommaExpr(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x2Cu:
        writeParameterDeclaration(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 0x2Du:
        writeFunctionPrototype(a2, a3, v9, v31, v32, v33, v34, v35, v48);
        break;
      case 0x2Eu:
        writeVariableDeclaration(a2, a3, v9, v31, v32, v33, v34, v35, v48);
        break;
      case 0x2Fu:
        writeVariableDeclarationGroup(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x30u:
        writePrecisionDeclaration(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x31u:
        writeQualifiedDeclaration(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x32u:
        writeQualifiedDeclarationGroup(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x33u:
        writeFunctionDefinition(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x34u:
        writeQualifiedType(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x35u:
        writePrimitiveType(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 0x36u:
        writeArrayType(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x37u:
        writeFieldDeclaration(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 0x38u:
        writeStructType(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 0x39u:
        writeInterfaceBlock(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 0x3Au:
        writeLayoutType(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x3Bu:
        writeKeywordQualifier(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 0x3Cu:
        writeLayoutQualifier(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x3Du:
        writeSubroutineTypeList(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x3Eu:
        writeQualifierList(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x3Fu:
        writeGlobalTypeQualifier(a2, a3, v9, v31, v32, v33, v34, v35, v48);
        break;
      case 0x40u:
        writeLayoutPair(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 0x41u:
        writeExpressionStatement(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x42u:
        writeBlock(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 0x43u:
        writeIfStatement(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x44u:
        writeLoopStatement(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x45u:
        writeSwitchStatement(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x46u:
        writeCaseStatement(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x47u:
        writeDefaultStatement(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x48u:
        writeBreakStatement(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x49u:
        writeContinueStatement(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x4Au:
        writeDiscardStatement(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x4Bu:
        writeReturnStatement(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x4Cu:
        writeTopLevel(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x4Du:
        writeAvailabilityDeclaration(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x4Eu:
        writeRawCall(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 0x4Fu:
        writeSubroutineRawCall(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 0x50u:
        writeOffset(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 0x51u:
        writeLValue(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 0x52u:
        writeRValue(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x53u:
        writeIBPartialDeref(a2, a3, v30, v31, v32, v33, v34, v35, v48);
        break;
      case 0x54u:
        writePPStreamOp(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      case 0x55u:
        writeSubroutineUniform(a2, a3, v9, v31, v32, v33, v34, v35);
        break;
      default:
        abort();
    }
    if (!v13)
    {
      if ((_DWORD)v9 == -1)
      {
        v12 = ")";
        v42 = "<<KIDS ELIDED TO AVOID RECURSION>>";
      }
      else
      {
        v46 = v9 + 1;
        v12 = ")";
        v42 = "<<KIDS ELIDED TO AVOID RECURSION>>";
        do
        {
          glpStringBufferAppendFormat(a2, "    ", v36, v37, v38, v39, v40, v41, v48);
          --v46;
        }
        while (v46);
      }
      goto LABEL_126;
    }
    if (glpASTNodeGetChildCount(a3))
    {
      v43 = 0;
      v44 = (v9 + 1);
      v12 = ")";
      do
      {
        if (v43)
          glpStringBufferAppendFormat(a2, "\n", a3, a4, a5, a6, a7, a8, v48);
        Child = glpASTNodeGetChild(a3, v43);
        writeASTNode(a1, a2, Child, v44, 1);
        ++v43;
      }
      while (v43 < glpASTNodeGetChildCount(a3));
    }
    else
    {
      v12 = ")";
    }
  }
  return glpStringBufferAppendFormat(a2, v12, a3, a4, a5, a6, a7, a8, a9);
}

void *writeTypeConversion(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v33;
  char v34;
  char v35;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(TypeConversion:", a3, a4, a5, a6, a7, a8, v33);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v34);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v35);
      --v23;
    }
    while (v23);
  }
  v24 = glpTypeConversionNodeGetToPrecision(a2);
  glpAppendFlagDescription(a1, v24);
  glpStringBufferAppendCString(a1, " ");
  v25 = glpTypeConversionNodeGetToType(a2);
  glpDumpTypeToStringBuffer(a1, v25, v26, v27, v28, v29, v30, v31, v35);
  return glpStringBufferAppendCString(a1, "\n");
}

uint64_t writeVariableIdentifier(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v33;
  char v34;
  char v35;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(VariableIdentifier:", a3, a4, a5, a6, a7, a8, v33);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v34);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v35);
      --v23;
    }
    while (v23);
  }
  glpVariableIdentifierNodeGetName(a2);
  v25 = v24;
  glpVariableIdentifierNodeGetName(a2);
  return glpStringBufferAppendFormat(a1, "%.*s -> ", v26, v27, v28, v29, v30, v31, v25);
}

uint64_t writeTypeIdentifier(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v33;
  char v34;
  char v35;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(TypeIdentifier:", a3, a4, a5, a6, a7, a8, v33);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v34);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v35);
      --v23;
    }
    while (v23);
  }
  glpTypeIdentifierNodeGetName(a2);
  v25 = v24;
  glpTypeIdentifierNodeGetName(a2);
  return glpStringBufferAppendFormat(a1, "%.*s", v26, v27, v28, v29, v30, v31, v25);
}

void *writeConstant(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unsigned int *Type;
  uint64_t Value;
  char v27;
  char v28;
  char v29;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(Constant:", a3, a4, a5, a6, a7, a8, v27);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v28);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v29);
      --v23;
    }
    while (v23);
  }
  Type = (unsigned int *)glpConstantNodeGetType(a2);
  Value = glpConstantNodeGetValue(a2);
  return glpAppendValueDescriptionToStringBuffer(a1, Type, Value);
}

uint64_t writeArrayAccess(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(ArrayAccess:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeFieldAccess(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v33;
  char v34;
  char v35;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(FieldAccess:", a3, a4, a5, a6, a7, a8, v33);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v34);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v35);
      --v23;
    }
    while (v23);
  }
  glpFieldAccessNodeGetField(a2);
  v25 = v24;
  glpFieldAccessNodeGetField(a2);
  return glpStringBufferAppendFormat(a1, "%.*s\n", v26, v27, v28, v29, v30, v31, v25);
}

uint64_t writeUndeterminedCall(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(UndeterminedCall:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeFunctionCall(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v33;
  char v34;
  char v35;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(FunctionCall:", a3, a4, a5, a6, a7, a8, v33);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v34);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v35);
      --v23;
    }
    while (v23);
  }
  glpFunctionCallNodeGetName(a2);
  v25 = v24;
  glpFunctionCallNodeGetName(a2);
  return glpStringBufferAppendFormat(a1, "%.*s\n", v26, v27, v28, v29, v30, v31, v25);
}

uint64_t writeSubroutineArrayCall(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(SubroutineArrayCall:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeMethodCall(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v33;
  char v34;
  char v35;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(MethodCall:", a3, a4, a5, a6, a7, a8, v33);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v34);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v35);
      --v23;
    }
    while (v23);
  }
  glpMethodCallNodeGetName(a2);
  v25 = v24;
  glpMethodCallNodeGetName(a2);
  return glpStringBufferAppendFormat(a1, "%.*s\n", v26, v27, v28, v29, v30, v31, v25);
}

uint64_t writeConstructorCall(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(ConstructorCall:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writePostincrement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(Postincrement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writePostdecrement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(Postdecrement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writePreincrement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(Preincrement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writePredecrement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(Predecrement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeUnaryPlus(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(UnaryPlus:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeNegate(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(Negate:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeLogicalNot(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(LogicalNot:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeBitwiseNot(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(BitwiseNot:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeMultiply(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(Multiply:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeDivide(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(Divide:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeModulo(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(Modulo:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeAdd(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(Add:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeSubtract(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(Subtract:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeShiftLeft(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(ShiftLeft:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeShiftRight(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(ShiftRight:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeLess(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(Less:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeLessEqual(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(LessEqual:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeGreater(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(Greater:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeGreaterEqual(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(GreaterEqual:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeEqual(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(Equal:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeNotEqual(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(NotEqual:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeLogicalAnd(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(LogicalAnd:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeLogicalOr(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(LogicalOr:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeLogicalXor(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(LogicalXor:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeBitwiseAnd(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(BitwiseAnd:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeBitwiseOr(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(BitwiseOr:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeBitwiseXor(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(BitwiseXor:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeIfExpr(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(IfExpr:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeAssign(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(Assign:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeOpAssign(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(OpAssign:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeReadInput(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(ReadInput:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeWriteOutput(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(WriteOutput:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeCommaExpr(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(CommaExpr:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

void *writeParameterDeclaration(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t Extra;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char v40;
  char v41;
  char v42;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(ParameterDeclaration:", a3, a4, a5, a6, a7, a8, v40);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v41);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v42);
      --v23;
    }
    while (v23);
  }
  glpParameterDeclarationNodeGetName(a2);
  v25 = v24;
  glpParameterDeclarationNodeGetName(a2);
  glpStringBufferAppendFormat(a1, "%.*s -> ", v26, v27, v28, v29, v30, v31, v25);
  Extra = glpParameterDeclarationNodeGetExtra(a2);
  glpAppendVariableObjectDescription(a1, Extra, v33, v34, v35, v36, v37, v38);
  return glpStringBufferAppendCString(a1, "\n");
}

uint64_t writeFunctionPrototype(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  char v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t Extra;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t result;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char v76;
  char v77;
  char v78;
  char v79;
  char v80;

  v9 = a3;
  glpStringBufferAppendFormat(a1, "(FunctionPrototype:", a3, a4, a5, a6, a7, a8, v76);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v12, v13, v14, v15, v16, v17, v77);
  if (v9 != -1)
  {
    v24 = v9 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v18, v19, v20, v21, v22, v23, v78);
      --v24;
    }
    while (v24);
  }
  glpFunctionPrototypeNodeGetName(a2);
  v26 = v25;
  glpFunctionPrototypeNodeGetName(a2);
  glpFunctionPrototypeNodeGetExtra(a2);
  glpStringBufferAppendFormat(a1, "%.*s == %p", v27, v28, v29, v30, v31, v32, v26);
  if (glpFunctionPrototypeNodeGetExtra(a2) && *(_QWORD *)(glpFunctionPrototypeNodeGetExtra(a2) + 8))
  {
    glpStringBufferAppendFormat(a1, ";", v33, v34, v35, v36, v37, v38, v79);
    Extra = glpFunctionPrototypeNodeGetExtra(a2);
    glpAppendFlagDescription(a1, *(_QWORD *)(Extra + 8));
  }
  glpStringBufferAppendFormat(a1, "\n", v33, v34, v35, v36, v37, v38, v79);
  if (glpFunctionPrototypeNodeGetExtra(a2))
  {
    if (v9 != -1)
    {
      v46 = v9 + 1;
      do
      {
        glpStringBufferAppendFormat(a1, "    ", v40, v41, v42, v43, v44, v45, v80);
        --v46;
      }
      while (v46);
    }
    v47 = glpFunctionPrototypeNodeGetExtra(a2);
    glpStringBufferAppendFormat(a1, "  %p\n", v48, v49, v50, v51, v52, v53, *(_QWORD *)(v47 + 72));
  }
  result = glpFunctionPrototypeNodeGetExtra(a2);
  if (result)
  {
    if (v9 != -1)
    {
      v61 = v9 + 1;
      do
      {
        glpStringBufferAppendFormat(a1, "    ", v55, v56, v57, v58, v59, v60, v80);
        --v61;
      }
      while (v61);
    }
    glpStringBufferAppendFormat(a1, "  ", v55, v56, v57, v58, v59, v60, v80);
    if (glpFunctionPrototypeNodeGetParameterCount(a2))
    {
      v68 = 0;
      do
      {
        v69 = glpFunctionPrototypeNodeGetExtra(a2);
        glpStringBufferAppendFormat(a1, "%p ", v70, v71, v72, v73, v74, v75, *(_QWORD *)(*(_QWORD *)(v69 + 80) + 8 * v68++));
      }
      while (v68 < glpFunctionPrototypeNodeGetParameterCount(a2));
    }
    return glpStringBufferAppendFormat(a1, "\n", v62, v63, v64, v65, v66, v67, a9);
  }
  return result;
}

uint64_t writeVariableDeclaration(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  char v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t Extra;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  unsigned int *SaType;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t result;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  char v83;
  char v84;
  char v85;
  char v86;

  v9 = a3;
  glpStringBufferAppendFormat(a1, "(VariableDeclaration:", a3, a4, a5, a6, a7, a8, v83);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v12, v13, v14, v15, v16, v17, v84);
  if (v9 != -1)
  {
    v24 = v9 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v18, v19, v20, v21, v22, v23, v85);
      --v24;
    }
    while (v24);
  }
  glpVariableDeclarationNodeGetName(a2);
  v26 = v25;
  glpVariableDeclarationNodeGetName(a2);
  glpStringBufferAppendFormat(a1, "%.*s -> ", v27, v28, v29, v30, v31, v32, v26);
  Extra = glpVariableDeclarationNodeGetExtra(a2);
  glpAppendVariableObjectDescription(a1, Extra, v34, v35, v36, v37, v38, v39);
  glpStringBufferAppendCString(a1, "\n");
  if (glpVariableDeclarationNodeGetExtra(a2) && *(_QWORD *)(glpVariableDeclarationNodeGetExtra(a2) + 64))
  {
    if (v9 != -1)
    {
      v46 = v9 + 1;
      do
      {
        glpStringBufferAppendFormat(a1, "    ", v40, v41, v42, v43, v44, v45, v86);
        --v46;
      }
      while (v46);
    }
    SaType = (unsigned int *)glpASTNodeGetSaType(a2);
    v48 = (uint64_t *)(glpVariableDeclarationNodeGetExtra(a2) + 64);
LABEL_16:
    glpAppendValueDescriptionToStringBuffer(a1, SaType, *v48);
    glpStringBufferAppendFormat(a1, "\n", v56, v57, v58, v59, v60, v61, v86);
    goto LABEL_17;
  }
  if (glpVariableDeclarationNodeGetExtra(a2) && *(_QWORD *)(glpVariableDeclarationNodeGetExtra(a2) + 72))
  {
    if (v9 != -1)
    {
      v55 = v9 + 1;
      do
      {
        glpStringBufferAppendFormat(a1, "    ", v49, v50, v51, v52, v53, v54, v86);
        --v55;
      }
      while (v55);
    }
    SaType = (unsigned int *)glpASTNodeGetSaType(a2);
    v48 = (uint64_t *)(glpVariableDeclarationNodeGetExtra(a2) + 72);
    goto LABEL_16;
  }
LABEL_17:
  result = glpVariableDeclarationNodeGetExtra(a2);
  if (result)
  {
    result = glpVariableDeclarationNodeGetExtra(a2);
    if (*(_QWORD *)(result + 8))
    {
      if (v9 != -1)
      {
        v69 = v9 + 1;
        do
        {
          glpStringBufferAppendFormat(a1, "    ", v63, v64, v65, v66, v67, v68, v86);
          --v69;
        }
        while (v69);
      }
      v70 = glpVariableDeclarationNodeGetExtra(a2);
      writeLayoutObject(a1, *(uint64_t ***)(v70 + 8), v71, v72, v73, v74, v75, v76);
      return glpStringBufferAppendFormat(a1, "\n", v77, v78, v79, v80, v81, v82, a9);
    }
  }
  return result;
}

uint64_t writeVariableDeclarationGroup(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(VariableDeclarationGroup:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writePrecisionDeclaration(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(PrecisionDeclaration:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeQualifiedDeclaration(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(QualifiedDeclaration:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeQualifiedDeclarationGroup(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(QualifiedDeclarationGroup:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeFunctionDefinition(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(FunctionDefinition:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeQualifiedType(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(QualifiedType:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writePrimitiveType(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unsigned int Type;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v33;
  char v34;
  char v35;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(PrimitiveType:", a3, a4, a5, a6, a7, a8, v33);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v34);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v35);
      --v23;
    }
    while (v23);
  }
  Type = glpPrimitiveTypeNodeGetType(a2);
  v25 = glpPrimitiveTypeToString(Type);
  return glpStringBufferAppendFormat(a1, "%s", v26, v27, v28, v29, v30, v31, v25);
}

uint64_t writeArrayType(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(ArrayType:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeFieldDeclaration(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v33;
  char v34;
  char v35;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(FieldDeclaration:", a3, a4, a5, a6, a7, a8, v33);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v34);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v35);
      --v23;
    }
    while (v23);
  }
  glpFieldDeclarationNodeGetName(a2);
  v25 = v24;
  glpFieldDeclarationNodeGetName(a2);
  return glpStringBufferAppendFormat(a1, "%.*s\n", v26, v27, v28, v29, v30, v31, v25);
}

uint64_t writeStructType(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v33;
  char v34;
  char v35;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(StructType:", a3, a4, a5, a6, a7, a8, v33);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v34);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v35);
      --v23;
    }
    while (v23);
  }
  glpStructTypeNodeGetName(a2);
  v25 = v24;
  glpStructTypeNodeGetName(a2);
  return glpStringBufferAppendFormat(a1, "%.*s\n", v26, v27, v28, v29, v30, v31, v25);
}

void *writeInterfaceBlock(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t Extra;
  int v24;
  uint64_t BlockName;
  uint64_t v26;
  uint64_t InstanceName;
  uint64_t v28;
  char ElementCount;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *result;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char v52;
  char v53;
  char v54;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(InterfaceBlock:", a3, a4, a5, a6, a7, a8, v52);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v53);
  Extra = glpInterfaceBlockNodeGetExtra(a2);
  if (v8 != -1)
  {
    v24 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v54);
      --v24;
    }
    while (v24);
  }
  BlockName = glpInterfaceBlockNodeGetBlockName(a2);
  glpStringBufferAppendString(a1, BlockName, v26);
  if (glpInterfaceBlockNodeGetHasInstanceName(a2))
  {
    glpStringBufferAppendCString(a1, " ");
    InstanceName = glpInterfaceBlockNodeGetInstanceName(a2);
    glpStringBufferAppendString(a1, InstanceName, v28);
    if (!Extra)
      return glpStringBufferAppendCString(a1, "\n");
    if (glpInterfaceBlockNodeGetDimension(a2))
    {
      ElementCount = glpBankTypeGetElementCount(*(_QWORD *)(Extra + 64));
      glpStringBufferAppendFormat(a1, "[%u]", v30, v31, v32, v33, v34, v35, ElementCount);
    }
    glpStringBufferAppendCString(a1, "\n");
  }
  else
  {
    result = glpStringBufferAppendCString(a1, "\n");
    if (!Extra)
      return result;
  }
  result = (void *)glpInterfaceBlockObjectGetVariableObjectCount(Extra);
  if ((_DWORD)result)
  {
    v43 = 0;
    v44 = result;
    do
    {
      if (v8 != -1)
      {
        v45 = v8 + 1;
        do
        {
          glpStringBufferAppendFormat(a1, "    ", v37, v38, v39, v40, v41, v42, v54);
          --v45;
        }
        while (v45);
      }
      glpStringBufferAppendCString(a1, "  -> ");
      glpAppendVariableObjectDescription(a1, *(_QWORD *)(*(_QWORD *)(Extra + 72) + 8 * v43), v46, v47, v48, v49, v50, v51);
      result = glpStringBufferAppendCString(a1, "\n");
      ++v43;
    }
    while (v43 != v44);
  }
  return result;
}

uint64_t writeLayoutType(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(LayoutType:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

void *writeKeywordQualifier(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unsigned int Qualifier;
  char *v25;
  char v27;
  char v28;
  char v29;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(KeywordQualifier:", a3, a4, a5, a6, a7, a8, v27);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v28);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v29);
      --v23;
    }
    while (v23);
  }
  Qualifier = glpKeywordQualifierNodeGetQualifier(a2);
  v25 = glpQualifierName(Qualifier);
  return glpStringBufferAppendCString(a1, v25);
}

uint64_t writeLayoutQualifier(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(LayoutQualifier:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeSubroutineTypeList(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(SubroutineTypeList:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeQualifierList(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(QualifierList:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeGlobalTypeQualifier(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t **Layout;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char v39;
  char v40;
  char v41;

  v9 = a3;
  glpStringBufferAppendFormat(a1, "(GlobalTypeQualifier:", a3, a4, a5, a6, a7, a8, v39);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v12, v13, v14, v15, v16, v17, v40);
  result = glpGlobalTypeQualifierNodeGetLayout(a2);
  if (result)
  {
    if (v9 != -1)
    {
      v25 = v9 + 1;
      do
      {
        glpStringBufferAppendFormat(a1, "    ", v19, v20, v21, v22, v23, v24, v41);
        --v25;
      }
      while (v25);
    }
    Layout = (uint64_t **)glpGlobalTypeQualifierNodeGetLayout(a2);
    writeLayoutObject(a1, Layout, v27, v28, v29, v30, v31, v32);
    return glpStringBufferAppendFormat(a1, "\n", v33, v34, v35, v36, v37, v38, a9);
  }
  return result;
}

uint64_t writeLayoutPair(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t Identifier;
  uint64_t v25;
  uint64_t result;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  char v42;
  char v43;
  char Value;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(LayoutPair:", a3, a4, a5, a6, a7, a8, v41);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v42);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v43);
      --v23;
    }
    while (v23);
  }
  Identifier = glpLayoutPairNodeGetIdentifier(a2);
  glpStringBufferAppendString(a1, Identifier, v25);
  result = glpLayoutPairNodeGetValueKind(a2);
  switch((int)result)
  {
    case 0:
    case 2:
      return result;
    case 1:
      Value = glpLayoutPairNodeGetValue(a2);
      result = glpStringBufferAppendFormat(a1, "=%d", v27, v28, v29, v30, v31, v32, Value);
      break;
    case 3:
      glpLayoutPairNodeGetString(a2);
      v34 = v33;
      glpLayoutPairNodeGetString(a2);
      result = glpStringBufferAppendFormat(a1, "=%.*s", v35, v36, v37, v38, v39, v40, v34);
      break;
    default:
      abort();
  }
  return result;
}

uint64_t writeExpressionStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(ExpressionStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

void *writeBlock(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char *v24;
  char v26;
  char v27;
  char v28;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(Block:", a3, a4, a5, a6, a7, a8, v26);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v27);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v28);
      --v23;
    }
    while (v23);
  }
  if (glpBlockNodeGetNeedsNewScope(a2))
    v24 = "--new scope--\n";
  else
    v24 = "no new scope\n";
  return glpStringBufferAppendCString(a1, v24);
}

uint64_t writeIfStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(IfStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeLoopStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(LoopStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeSwitchStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(SwitchStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeCaseStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(CaseStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeDefaultStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(DefaultStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeBreakStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(BreakStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeContinueStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(ContinueStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeDiscardStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(DiscardStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeReturnStatement(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(ReturnStatement:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeTopLevel(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(TopLevel:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeAvailabilityDeclaration(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(AvailabilityDeclaration:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

void *writeRawCall(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  char v27;
  char v28;
  char v29;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(RawCall:", a3, a4, a5, a6, a7, a8, v27);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v28);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v29);
      --v23;
    }
    while (v23);
  }
  v24 = glpRawCallNodeGetName(a2);
  glpStringBufferAppendString(a1, v24, v25);
  return glpStringBufferAppendCString(a1, "\n");
}

void *writeSubroutineRawCall(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  _QWORD *v24;
  char v26;
  char v27;
  char v28;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(SubroutineRawCall:", a3, a4, a5, a6, a7, a8, v26);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v27);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v28);
      --v23;
    }
    while (v23);
  }
  v24 = (_QWORD *)glpSubroutineRawCallNodeGetExtra(a2);
  glpStringBufferAppendString(a1, *v24, v24[1]);
  return glpStringBufferAppendCString(a1, "\n");
}

uint64_t writeOffset(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unsigned int Swizzle;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _BYTE *v27;
  int v28;
  uint64_t result;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  char v45;
  char v46;
  _BYTE v47[5];

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(Offset:", a3, a4, a5, a6, a7, a8, v44);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v45);
  v17 = v8 + 1;
  Swizzle = glpOffsetNodeGetSwizzle(a2);
  if (Swizzle)
  {
    v25 = Swizzle & 7;
    if ((Swizzle & 7) != 0)
    {
      v26 = 0;
      v27 = v47;
      do
      {
        *v27++ = aXyzw[(Swizzle >> (v26 + 3)) & 3];
        v26 += 2;
      }
      while (2 * (Swizzle & 7) != v26);
    }
    else
    {
      v25 = 0;
    }
    v47[v25] = 0;
    if (v8 != -1)
    {
      v28 = v8 + 1;
      do
      {
        glpStringBufferAppendFormat(a1, "    ", v19, v20, v21, v22, v23, v24, v46);
        --v28;
      }
      while (v28);
    }
    glpStringBufferAppendFormat(a1, ".%s\n", v19, v20, v21, v22, v23, v24, (char)v47);
  }
  result = glpOffsetNodeGetPreSwizzlePrimitiveType(a2);
  if ((_DWORD)result)
  {
    v36 = result;
    if (v8 != -1)
    {
      do
      {
        glpStringBufferAppendFormat(a1, "    ", v30, v31, v32, v33, v34, v35, v46);
        --v17;
      }
      while (v17);
    }
    v37 = glpPrimitiveTypeToString(v36);
    return glpStringBufferAppendFormat(a1, "pre-swizzle type: %s\n", v38, v39, v40, v41, v42, v43, v37);
  }
  return result;
}

void *writeLValue(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t VariableExtra;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char v40;
  char v41;
  char v42;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(LValue:", a3, a4, a5, a6, a7, a8, v40);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v41);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v42);
      --v23;
    }
    while (v23);
  }
  glpLValueNodeGetVariableName(a2);
  v25 = v24;
  glpLValueNodeGetVariableName(a2);
  glpStringBufferAppendFormat(a1, "%.*s -> ", v26, v27, v28, v29, v30, v31, v25);
  VariableExtra = glpLValueNodeGetVariableExtra(a2);
  glpAppendVariableObjectDescription(a1, VariableExtra, v33, v34, v35, v36, v37, v38);
  return glpStringBufferAppendCString(a1, "\n");
}

uint64_t writeRValue(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(RValue:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writeIBPartialDeref(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  glpStringBufferAppendFormat(a1, "(IBPartialDeref:", a3, a4, a5, a6, a7, a8, v18);
  writeSAInfo(a1, a2);
  return glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t writePPStreamOp(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  unsigned int ReturnPrimitiveType;
  char v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int Opcode;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  unsigned int v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  unsigned int OpPrimitiveType;
  char v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char HasSrctex;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  char HasOffset;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  char v106;
  char v107;
  char v108;
  char v109;
  char v110;
  char v111;
  char v112;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(PPStreamOp:", a3, a4, a5, a6, a7, a8, v106);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v107);
  if (v8 == -1)
  {
    ReturnPrimitiveType = glpPPStreamOpNodeGetReturnPrimitiveType(a2);
    v40 = glpPrimitiveTypeToString(ReturnPrimitiveType);
    glpStringBufferAppendFormat(a1, "returnPrimitiveType: %s\n", v41, v42, v43, v44, v45, v46, v40);
  }
  else
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v108);
      --v23;
    }
    while (v23);
    v24 = glpPPStreamOpNodeGetReturnPrimitiveType(a2);
    v25 = glpPrimitiveTypeToString(v24);
    glpStringBufferAppendFormat(a1, "returnPrimitiveType: %s\n", v26, v27, v28, v29, v30, v31, v25);
    v38 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v32, v33, v34, v35, v36, v37, v109);
      --v38;
    }
    while (v38);
  }
  Opcode = glpPPStreamOpNodeGetOpcode(a2);
  glpStringBufferAppendFormat(a1, "opcode: %s\n", v48, v49, v50, v51, v52, v53, (char)ppstreamOpString[Opcode]);
  if (v8 == -1)
  {
    OpPrimitiveType = glpPPStreamOpNodeGetOpPrimitiveType(a2);
    v77 = glpPrimitiveTypeToString(OpPrimitiveType);
    glpStringBufferAppendFormat(a1, "opPrimitiveType: %s\n", v78, v79, v80, v81, v82, v83, v77);
  }
  else
  {
    v60 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v54, v55, v56, v57, v58, v59, v110);
      --v60;
    }
    while (v60);
    v61 = glpPPStreamOpNodeGetOpPrimitiveType(a2);
    v62 = glpPrimitiveTypeToString(v61);
    glpStringBufferAppendFormat(a1, "opPrimitiveType: %s\n", v63, v64, v65, v66, v67, v68, v62);
    v75 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v69, v70, v71, v72, v73, v74, v111);
      --v75;
    }
    while (v75);
  }
  HasSrctex = glpPPStreamOpNodeGetHasSrctex(a2);
  glpStringBufferAppendFormat(a1, "has_srctex: %d\n", v85, v86, v87, v88, v89, v90, HasSrctex);
  if (v8 != -1)
  {
    v97 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v91, v92, v93, v94, v95, v96, v112);
      --v97;
    }
    while (v97);
  }
  HasOffset = glpPPStreamOpNodeGetHasOffset(a2);
  return glpStringBufferAppendFormat(a1, "has_offset: %d\n", v99, v100, v101, v102, v103, v104, HasOffset);
}

void *writeSubroutineUniform(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  _QWORD *Extra;
  char v26;
  char v27;
  char v28;

  v8 = a3;
  glpStringBufferAppendFormat(a1, "(SubroutineUniform:", a3, a4, a5, a6, a7, a8, v26);
  writeSAInfo(a1, a2);
  glpStringBufferAppendFormat(a1, "\n", v11, v12, v13, v14, v15, v16, v27);
  if (v8 != -1)
  {
    v23 = v8 + 1;
    do
    {
      glpStringBufferAppendFormat(a1, "    ", v17, v18, v19, v20, v21, v22, v28);
      --v23;
    }
    while (v23);
  }
  Extra = (_QWORD *)glpSubroutineUniformNodeGetExtra(a2);
  glpStringBufferAppendString(a1, *Extra, Extra[1]);
  return glpStringBufferAppendCString(a1, "\n");
}

uint64_t *writeSAInfo(uint64_t *a1, uint64_t a2)
{
  uint64_t SaType;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t SaFlags;
  char v19;
  char v20;

  SaType = glpASTNodeGetSaType(a2);
  glpDumpTypeToStringBuffer(a1, SaType, v5, v6, v7, v8, v9, v10, v19);
  result = (uint64_t *)glpASTNodeGetSaFlags(a2);
  if (result)
  {
    glpStringBufferAppendFormat(a1, ";", v12, v13, v14, v15, v16, v17, v20);
    SaFlags = glpASTNodeGetSaFlags(a2);
    return glpAppendFlagDescription(a1, SaFlags);
  }
  return result;
}

uint64_t writeLayoutObject(uint64_t *a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t *v11;
  uint64_t *v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;

  result = glpStringBufferAppendFormat(a1, "layout:", a3, a4, a5, a6, a7, a8, v26);
  v11 = *a2;
  if (*a2)
  {
    do
    {
      v12 = (uint64_t *)*v11;
      v13 = glpLayoutQualifierToString(*((_DWORD *)v11 + 2));
      result = glpStringBufferAppendFormat(a1, "%s ", v14, v15, v16, v17, v18, v19, v13);
      if (*((_DWORD *)v11 + 3) == 1)
        result = glpStringBufferAppendFormat(a1, "= %d ", v20, v21, v22, v23, v24, v25, *((_DWORD *)v11 + 4));
      v11 = v12;
    }
    while (v12);
  }
  return result;
}

uint64_t phase2AddDef(uint64_t *a1, uint64_t a2)
{
  uint64_t Prototype;
  unint64_t Extra;
  uint64_t v6;
  uint64_t v7;
  double v8;
  uint64_t v9;
  _BOOL4 v10;
  unint64_t v11;
  uint64_t v12;
  double v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unsigned int DefCount;
  uint64_t v20;
  double v21;
  unint64_t v22;

  if (glpIsFunctionDefinitionNode(a2))
  {
    Prototype = glpFunctionDefinitionNodeGetPrototype(a2);
    Extra = glpFunctionPrototypeNodeGetExtra(Prototype);
    v6 = glpPointerHashGet(a1[16], Extra);
    v7 = Prototype;
LABEL_3:
    glpFunctionPrototypeNodeSetExtra(v7, v6);
    if (glpPointerHashGet(a1[22], v6))
      return 1;
    v9 = a1[22];
    goto LABEL_5;
  }
  if (glpIsVariableDeclarationNode(a2))
  {
    v11 = glpVariableDeclarationNodeGetExtra(a2);
    v12 = glpPointerHashGet(a1[15], v11);
    glpVariableDeclarationNodeSetExtra(a2, v12);
    if (glpPointerHashGet(a1[21], v12))
      return 1;
    glpPointerHashPut(a1[21], v12, v12, v13);
    v10 = (*(_BYTE *)(v12 + 51) & 0x60) != 0;
    goto LABEL_10;
  }
  if (!glpIsInterfaceBlockNode(a2))
  {
    if (glpIsSubroutineUniformNode(a2))
    {
      v20 = glpSubroutineUniformNodeGetExtra(a2);
      if (glpStringHashGet(a1[20], *(const char **)v20, *(_QWORD *)(v20 + 8)))
        return 1;
      glpStringHashPut(a1[20], *(const char **)v20, *(_QWORD *)(v20 + 8), v20, v21);
      goto LABEL_6;
    }
    v22 = glpFunctionPrototypeNodeGetExtra(a2);
    v6 = glpPointerHashGet(a1[16], v22);
    v7 = a2;
    goto LABEL_3;
  }
  v6 = glpInterfaceBlockNodeGetExtra(a2);
  if (glpPointerHashGet(a1[23], v6))
    return 1;
  v9 = a1[23];
LABEL_5:
  glpPointerHashPut(v9, v6, v6, v8);
LABEL_6:
  v10 = 0;
LABEL_10:
  v14 = phase2Process(a1, a2);
  if (v14 == -1)
    return 0;
  v15 = v14;
  v16 = (_QWORD *)*a1;
  v17 = a1[19];
  if (v10)
    DefCount = 0;
  else
    DefCount = glpTopLevelNodeGetDefCount(v17);
  glpTopLevelNodeInsertDef(v16, v17, v15, DefCount);
  return 1;
}

uint64_t phase2Process(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v4;
  uint64_t Child;
  uint64_t v6;

  v2 = a2;
  if (a2)
  {
    if (!glpASTNodeGetChildCount(a2))
    {
LABEL_6:
      switch(glpASTNodeGetKind(v2))
      {
        case 0u:
        case 1u:
        case 2u:
        case 4u:
        case 5u:
        case 6u:
        case 7u:
        case 8u:
        case 9u:
        case 0xAu:
        case 0xBu:
        case 0xCu:
        case 0xDu:
        case 0xEu:
        case 0xFu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
        case 0x14u:
        case 0x15u:
        case 0x16u:
        case 0x17u:
        case 0x18u:
        case 0x19u:
        case 0x1Au:
        case 0x1Bu:
        case 0x1Cu:
        case 0x1Du:
        case 0x1Eu:
        case 0x1Fu:
        case 0x20u:
        case 0x21u:
        case 0x22u:
        case 0x23u:
        case 0x24u:
        case 0x25u:
        case 0x26u:
        case 0x27u:
        case 0x28u:
        case 0x29u:
        case 0x2Au:
        case 0x2Bu:
        case 0x2Fu:
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x36u:
        case 0x37u:
        case 0x38u:
        case 0x3Au:
        case 0x3Bu:
        case 0x3Cu:
        case 0x3Du:
        case 0x3Eu:
        case 0x3Fu:
        case 0x40u:
        case 0x41u:
        case 0x42u:
        case 0x43u:
        case 0x44u:
        case 0x45u:
        case 0x46u:
        case 0x47u:
        case 0x48u:
        case 0x49u:
        case 0x4Au:
        case 0x4Bu:
        case 0x4Cu:
        case 0x4Du:
        case 0x50u:
        case 0x52u:
        case 0x53u:
        case 0x54u:
          return v2;
        case 3u:
          phase2ProcessConstant((uint64_t)a1, v2);
          return v2;
        case 0x2Cu:
          phase2ProcessParameterDeclaration((uint64_t)a1, v2);
          return v2;
        case 0x2Du:
          phase2ProcessFunctionPrototype((uint64_t)a1, v2);
          return v2;
        case 0x2Eu:
          phase2ProcessVariableDeclaration((uint64_t)a1, v2);
          return v2;
        case 0x39u:
          phase2ProcessInterfaceBlock((uint64_t)a1, v2);
          return v2;
        case 0x4Eu:
          return phase2ProcessRawCall((uint64_t)a1, v2);
        case 0x4Fu:
          return phase2ProcessSubroutineRawCall(a1, v2);
        case 0x51u:
          return phase2ProcessLValue((_QWORD **)a1, v2);
        case 0x55u:
          return phase2ProcessSubroutineUniform((uint64_t)a1, v2);
        default:
          abort();
      }
    }
    v4 = 0;
    while (1)
    {
      Child = glpASTNodeGetChild(v2, v4);
      v6 = phase2Process(a1, Child);
      if (v6 == -1)
        return -1;
      glpASTNodeSetChild(v2, v4++, v6);
      if (v4 >= glpASTNodeGetChildCount(v2))
        goto LABEL_6;
    }
  }
  return v2;
}

uint64_t phase2ProcessConstant(uint64_t a1, uint64_t a2)
{
  char SaFlags;
  unsigned int *Type;
  char *Value;
  uint64_t v7;

  SaFlags = glpASTNodeGetSaFlags(a2);
  Type = (unsigned int *)glpConstantNodeGetType(a2);
  Value = (char *)glpConstantNodeGetValue(a2);
  v7 = glpMergeRemapValue(a1, SaFlags, Type, Value);
  glpConstantNodeSetValue(a2, v7);
  return a2;
}

uint64_t phase2ProcessParameterDeclaration(uint64_t a1, uint64_t a2)
{
  unint64_t Extra;
  uint64_t *v5;

  Extra = glpParameterDeclarationNodeGetExtra(a2);
  v5 = (uint64_t *)glpPointerHashGet(*(_QWORD *)(a1 + 120), Extra);
  glpParameterDeclarationNodeSetExtra(a2, (uint64_t)v5);
  lazyPrepareVariableObject(a1, (uint64_t)v5);
  glpASTNodeSetSaType(a2, *v5);
  return a2;
}

uint64_t phase2ProcessFunctionPrototype(uint64_t a1, uint64_t a2)
{
  unint64_t Extra;
  uint64_t v5;

  Extra = glpFunctionPrototypeNodeGetExtra(a2);
  v5 = glpPointerHashGet(*(_QWORD *)(a1 + 128), Extra);
  glpFunctionPrototypeNodeSetExtra(a2, v5);
  return a2;
}

uint64_t phase2ProcessVariableDeclaration(uint64_t a1, uint64_t a2)
{
  uint64_t *Extra;

  Extra = (uint64_t *)glpVariableDeclarationNodeGetExtra(a2);
  lazyPrepareVariableObject(a1, (uint64_t)Extra);
  glpASTNodeSetSaType(a2, *Extra);
  return a2;
}

uint64_t phase2ProcessInterfaceBlock(uint64_t a1, uint64_t a2)
{
  uint64_t Extra;
  double v5;
  uint64_t v6;
  uint64_t *v7;
  unsigned int VariableObjectCount;
  uint64_t v9;
  uint64_t v10;

  Extra = glpInterfaceBlockNodeGetExtra(a2);
  v6 = *(_QWORD *)(**(_QWORD **)(Extra + 72) + 48);
  if ((v6 & 0x20000000) != 0)
  {
    v7 = (uint64_t *)(a1 + 224);
  }
  else if ((v6 & 0x40000000) != 0)
  {
    v7 = (uint64_t *)(a1 + 232);
  }
  else
  {
    if ((v6 & 0x100000000) == 0)
      goto LABEL_8;
    v7 = (uint64_t *)(a1 + 240);
  }
  glpStringHashPut(*v7, *(const char **)Extra, *(_QWORD *)(Extra + 8), Extra, v5);
LABEL_8:
  VariableObjectCount = glpInterfaceBlockObjectGetVariableObjectCount(Extra);
  if (VariableObjectCount)
  {
    v9 = 0;
    v10 = 8 * VariableObjectCount;
    do
    {
      lazyPrepareVariableObject(a1, *(_QWORD *)(*(_QWORD *)(Extra + 72) + v9));
      v9 += 8;
    }
    while (v10 != v9);
  }
  return a2;
}

uint64_t phase2ProcessRawCall(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  double v6;
  uint64_t v7;
  const char *v8;
  unsigned int v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t **v16;
  uint64_t **v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  char v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;

  v4 = glpRawCallNodeGetExtra(a2);
  v5 = glpPointerHashGet(*(_QWORD *)(a1 + 128), v4);
  if (!v5)
  {
    v5 = glpStringHashGet(*(_QWORD *)(a1 + 48), *(const char **)(v4 + 40), *(_QWORD *)(v4 + 48));
    if (v5)
      glpPointerHashPut(*(_QWORD *)(a1 + 128), v4, v5, v6);
  }
  glpRawCallNodeSetExtra(a2, v5);
  v7 = glpPointerHashGet(*(_QWORD *)(a1 + 96), v5);
  if (!v7)
  {
    v17 = *(uint64_t ***)(a1 + 8);
    v18 = *(_DWORD *)(a1 + 24);
    v19 = *(_DWORD *)(v4 + 32);
    v27 = "-1";
    v28 = 0xEDA00000002;
    v29 = 0xFFFFFFFFLL;
    glpLanguageToString(v18);
    glpLogMessage(v17, 0, (uint64_t)&v27, "No definition of %.*s in %s shader", v20, v21, v22, v23, v19);
    return -1;
  }
  if (*(_BYTE *)(v5 + 128))
  {
    v8 = *(const char **)(v4 + 24);
    v9 = *(_DWORD *)(v4 + 32);
    if (v9 >= 0x12)
      v10 = 18;
    else
      v10 = v9;
    v15 = strncmp("$SubroutineStatic$", v8, v10);
    v16 = *(uint64_t ***)(a1 + 8);
    v27 = "-1";
    v28 = 0xEDA00000002;
    v29 = 0xFFFFFFFFLL;
    if (v15)
      v26 = v9;
    else
      v26 = v9 - 18;
    glpLogMessage(v16, 0, (uint64_t)&v27, "Recursive function call to %.*s", v11, v12, v13, v14, v26);
    return -1;
  }
  *(_BYTE *)(v5 + 128) = 1;
  v24 = phase2AddDef(a1, v7);
  *(_BYTE *)(v5 + 128) = 0;
  if (v24)
    return a2;
  else
    return -1;
}

uint64_t phase2ProcessSubroutineRawCall(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *ElementType;
  uint64_t v8;
  unsigned int **v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  char *v16;
  int v17;
  uint64_t **v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t **v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v33;
  uint64_t v34;
  uint64_t v35;

  v2 = a2;
  v4 = glpSubroutineRawCallNodeGetExtra(a2);
  v5 = glpPointerHashGet(a1[14], v4);
  if (!v5)
  {
    v18 = (uint64_t **)a1[1];
    v19 = *((_DWORD *)a1 + 6);
    v20 = *(_DWORD *)(v4 + 8);
    v33 = "-1";
    v34 = 0xEDA00000002;
    v35 = 0xFFFFFFFFLL;
    glpLanguageToString(v19);
    glpLogMessage(v18, 0, (uint64_t)&v33, "No definition of subroutine uniform %.*s in %s shader", v21, v22, v23, v24, v20);
    return -1;
  }
  v6 = v5;
  ElementType = *(unsigned int **)(v4 + 16);
  if (glpTypeGetKind(ElementType) == 2)
    ElementType = (unsigned int *)glpArrayTypeGetElementType((uint64_t)ElementType);
  v8 = *((unsigned int *)a1 + 71);
  if ((_DWORD)v8)
  {
    v9 = (unsigned int **)a1[36];
    v10 = *((unsigned int *)a1 + 71);
    while (ElementType != *v9)
    {
      ++v9;
      if (!--v10)
        goto LABEL_8;
    }
    v25 = (uint64_t **)a1[1];
    v26 = *((_DWORD *)a1 + 6);
    v27 = *(_DWORD *)(v4 + 8);
    v33 = "-1";
    v34 = 0xEDA00000002;
    v35 = 0xFFFFFFFFLL;
    glpLanguageToString(v26);
    glpLogMessage(v25, 0, (uint64_t)&v33, "Potentially recursive subroutine call through subroutine uniform %.*s in %s shader", v28, v29, v30, v31, v27);
    return -1;
  }
LABEL_8:
  v11 = v8 + 1;
  v12 = *((_DWORD *)a1 + 70);
  if ((int)v8 + 1 <= v12)
  {
    v16 = (char *)a1[36];
    v17 = *((_DWORD *)a1 + 71);
  }
  else
  {
    if (v12 <= 1)
      v12 = 1;
    v13 = 2 * v12;
    if (v13 <= v11)
      v14 = v8 + 1;
    else
      v14 = v13;
    v15 = *a1;
    v16 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(*a1 + 8))(*(_QWORD *)*a1, 8 * v14, "Vector Storage (GLPType *, growth)");
    memcpy(v16, (const void *)a1[36], 8 * *((unsigned int *)a1 + 71));
    (*(void (**)(_QWORD, uint64_t))(v15 + 24))(*(_QWORD *)v15, a1[36]);
    *((_DWORD *)a1 + 70) = v14;
    a1[36] = (uint64_t)v16;
    v17 = *((_DWORD *)a1 + 71);
  }
  memmove(&v16[8 * v8 + 8], &v16[8 * v8], 8 * (v17 - v8));
  *(_QWORD *)(a1[36] + 8 * v8) = ElementType;
  ++*((_DWORD *)a1 + 71);
  if (!phase2AddDef(a1, v6))
    return -1;
  memmove((void *)(a1[36] + 8 * v8), (const void *)(a1[36] + 8 * v11), 8 * (*((_DWORD *)a1 + 71) - v11));
  --*((_DWORD *)a1 + 71);
  return v2;
}

uint64_t phase2ProcessLValue(_QWORD **a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t VariableExtra;
  unint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t **v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t Offset;
  uint64_t v17;
  uint64_t OffsetExpr;
  uint64_t v19;
  unsigned int *Value;
  uint64_t SaType;
  unsigned int AsSize;
  unsigned int PreSwizzlePrimitiveType;
  uint64_t PrimitiveType;
  unsigned int *ElementType;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  int Size;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t BankIndex;
  int Bank;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t IntConstantNode;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t PPStreamOpNode;
  char *v47;
  uint64_t SaFlags;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  __n128 v58;
  uint64_t v59;
  uint64_t v60;

  v2 = a2;
  v60 = *MEMORY[0x24BDAC8D0];
  VariableExtra = glpLValueNodeGetVariableExtra(a2);
  v5 = VariableExtra;
  if (*((_BYTE *)a1 + 32))
  {
    v6 = *(uint64_t **)(VariableExtra + 8);
    if (v6)
    {
      if (glpLayoutObjectFind(v6, 82))
      {
        v11 = (uint64_t **)a1[1];
        v12 = *(_DWORD *)(v5 + 40);
        v58.n128_u64[0] = (unint64_t)"-1";
        v58.n128_u64[1] = 0xEDA00000002;
        v59 = 0xFFFFFFFFLL;
        glpLogMessage(v11, 0, (uint64_t)&v58, "Built-in variable '%.*s' must be redeclared before use, with separate shader objects.", v7, v8, v9, v10, v12);
        return -1;
      }
    }
  }
  v13 = glpPointerHashGet((uint64_t)a1[15], v5);
  if (v13)
  {
    v14 = v13;
    glpLValueNodeSetVariableExtra(v2, v13);
    v15 = glpPointerHashGet((uint64_t)a1[11], v14);
    if (v15)
    {
      v5 = v14;
      if (!phase2AddDef(a1, v15))
        return -1;
    }
    else
    {
      v5 = v14;
    }
  }
  lazyPrepareVariableObject((uint64_t)a1, v5);
  if (*(_QWORD *)(v5 + 120))
  {
    Offset = glpDerefNodeGetOffset(v2);
    if (Offset
      && (v17 = Offset, (OffsetExpr = glpOffsetNodeGetOffsetExpr(Offset)) != 0)
      && (v19 = OffsetExpr, glpIsConstantNode(OffsetExpr)))
    {
      Value = (unsigned int *)glpConstantNodeGetValue(v19);
      SaType = glpASTNodeGetSaType(v19);
      AsSize = glpValueGetAsSize(SaType, Value);
      if (glpOffsetNodeGetPreSwizzlePrimitiveType(v17))
      {
        PreSwizzlePrimitiveType = glpOffsetNodeGetPreSwizzlePrimitiveType(v17);
        PrimitiveType = (uint64_t)glpGetPrimitiveType(PreSwizzlePrimitiveType);
      }
      else
      {
        PrimitiveType = glpASTNodeGetSaType(v2);
      }
      v29 = glpABIGetTypeSize(0, PrimitiveType, 0);
      Size = glpTypeSizeGetSize(v29);
      v31 = Size + AsSize;
      BitSetSetRangeEquals(*(_QWORD *)(v5 + 120), AsSize, Size + AsSize, 1);
      v32 = *(_DWORD *)(v5 + 128);
      if (v32 <= v31)
        v32 = v31;
      *(_DWORD *)(v5 + 128) = v32;
    }
    else
    {
      ElementType = *(unsigned int **)v5;
      if (glpTypeGetKind(*(unsigned int **)v5) == 3)
        ElementType = (unsigned int *)glpBankTypeGetElementType((uint64_t)ElementType);
      v26 = glpABIGetTypeSize(0, (uint64_t)ElementType, 0);
      v27 = glpTypeSizeGetSize(v26);
      MEMORY[0x24BDAC7A8](v27);
      glpTypeGetAppleVec4Types(ElementType, (__n128 *)((char *)&v58 - v28), 1, 0, 0, 0, *(_QWORD *)(v5 + 120), 0, 0);
      *(_DWORD *)(v5 + 128) = BitSetLastSetBit(*(_QWORD *)(v5 + 120)) + 1;
    }
  }
  v33 = glpDerefNodeGetOffset(v2);
  if (v33)
  {
    v34 = v33;
    BankIndex = glpOffsetNodeGetBankIndex(v33);
    glpTypeGetKind(*(unsigned int **)v5);
    if (BankIndex)
    {
      Bank = glpBankTypeGetBank(*(_QWORD *)v5);
      if ((Bank - 1) < 2 || Bank == 4)
      {
        glpBankTypeGetElementCount(*(_QWORD *)v5);
        v37 = glpBankTypeGetElementType(*(_QWORD *)v5);
        v38 = glpABIGetTypeSize(0, v37, 0);
        v39 = glpTypeSizeGetSize(v38);
        v40 = glpOffsetNodeGetOffsetExpr(v34);
        if (!v40)
        {
          IntConstantNode = makeIntConstantNode((uint64_t *)a1, 0);
          v40 = phase2Process(a1, IntConstantNode);
        }
        v42 = makeIntConstantNode((uint64_t *)a1, v39);
        v43 = phase2Process(a1, v42);
        v44 = glpGetPrimitiveType(5u);
        glpASTNodeSetSaType(v43, (uint64_t)v44);
        glpASTNodeSetSaFlags(v43, 96);
        v45 = (uint64_t)*a1;
        v58.n128_u64[0] = (unint64_t)"-1";
        v58.n128_u64[1] = 0xEDA00000002;
        v59 = 0xFFFFFFFFLL;
        PPStreamOpNode = glpMakePPStreamOpNode(v45, &v58, 5, 34, 5, 0, 0);
        glpCallNodeAddArg(*a1, PPStreamOpNode, BankIndex);
        glpCallNodeAddArg(*a1, PPStreamOpNode, v43);
        v47 = glpGetPrimitiveType(5u);
        glpASTNodeSetSaType(PPStreamOpNode, (uint64_t)v47);
        SaFlags = glpASTNodeGetSaFlags(BankIndex);
        v49 = glpASTNodeGetSaFlags(v43);
        glpASTNodeSetSaFlags(PPStreamOpNode, v49 & SaFlags);
        v50 = glpConstantFold((uint64_t)*a1, (uint64_t)a1[31], PPStreamOpNode);
        v51 = (uint64_t)*a1;
        v58.n128_u64[0] = (unint64_t)"-1";
        v58.n128_u64[1] = 0xEDA00000002;
        v59 = 0xFFFFFFFFLL;
        v52 = glpMakePPStreamOpNode(v51, &v58, 5, 31, 5, 0, 0);
        glpCallNodeAddArg(*a1, v52, v50);
        glpCallNodeAddArg(*a1, v52, v40);
        v53 = glpGetPrimitiveType(5u);
        glpASTNodeSetSaType(v52, (uint64_t)v53);
        v54 = glpASTNodeGetSaFlags(v50);
        v55 = glpASTNodeGetSaFlags(v40);
        glpASTNodeSetSaFlags(v52, v55 & v54);
        v56 = glpConstantFold((uint64_t)*a1, (uint64_t)a1[31], v52);
        glpOffsetNodeSetOffsetExpr(v34, v56);
        glpOffsetNodeSetBankIndex(v34, 0);
      }
      else if (!Bank)
      {
        abort();
      }
    }
  }
  return v2;
}

uint64_t phase2ProcessSubroutineUniform(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t Extra;
  unsigned int *ElementType;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t **v13;
  int v14;
  _QWORD v16[3];

  v2 = a2;
  Extra = glpSubroutineUniformNodeGetExtra(a2);
  ElementType = *(unsigned int **)(Extra + 16);
  if (glpTypeGetKind(ElementType) == 2)
    ElementType = (unsigned int *)glpArrayTypeGetElementType((uint64_t)ElementType);
  v6 = glpPointerHashGet(*(_QWORD *)(a1 + 144), (unint64_t)ElementType);
  if (v6 && (v11 = v6, *(_DWORD *)(v6 + 4)))
  {
    v12 = 0;
    while (phase2AddDef(a1, *(_QWORD *)(*(_QWORD *)(v11 + 8) + 8 * v12)))
    {
      if (++v12 >= (unint64_t)*(unsigned int *)(v11 + 4))
        return v2;
    }
  }
  else
  {
    v13 = *(uint64_t ***)(a1 + 8);
    v14 = *(_DWORD *)(Extra + 8);
    v16[0] = "-1";
    v16[1] = 0xEDA00000002;
    v16[2] = 0xFFFFFFFFLL;
    glpLogMessage(v13, 0, (uint64_t)v16, "Subroutine uniform '%.*s' has no possible implementations", v7, v8, v9, v10, v14);
  }
  return -1;
}

uint64_t lazyPrepareVariableObject(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t ElementType;
  int Kind;
  int *v7;
  int *v8;
  double v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t ArrayType;
  uint64_t v13;
  int Bank;
  int ElementCount;
  uint64_t BankType;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  _BOOL4 v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  unsigned int Size;
  uint64_t v32;
  int v33;
  unsigned int v34;

  if (*(_DWORD *)(a2 + 128) || *(_QWORD *)(a2 + 120))
    return result;
  v3 = result;
  if (!*(_DWORD *)(result + 20)
    && *(_DWORD *)(result + 24) == 3
    && (*(_BYTE *)(a2 + 51) & 0x20) != 0
    && glpTypeGetKind(*(unsigned int **)a2) == 3)
  {
    v4 = *(_QWORD *)v3;
    ElementType = glpBankTypeGetElementType(*(_QWORD *)a2);
    *(_QWORD *)a2 = glpMakeBankType(v4, 1, ElementType, *(_DWORD *)(v3 + 28));
  }
  Kind = glpTypeGetKind(*(unsigned int **)a2);
  v7 = *(int **)a2;
  if (Kind == 3)
  {
    v8 = (int *)glpBankTypeGetElementType((uint64_t)v7);
    if (!glpTypeIsSized(v8))
    {
      v10 = *(_QWORD *)v3;
      v11 = glpArrayTypeGetElementType((uint64_t)v8);
      ArrayType = glpMakeArrayType(v10, v11, *(_DWORD *)(a2 + 100), -1);
      v13 = *(_QWORD *)v3;
      Bank = glpBankTypeGetBank(*(_QWORD *)a2);
      ElementCount = glpBankTypeGetElementCount(*(_QWORD *)a2);
      BankType = glpMakeBankType(v13, Bank, ArrayType, ElementCount);
LABEL_13:
      *(_QWORD *)a2 = BankType;
    }
  }
  else if (!glpTypeIsSized(v7))
  {
    v17 = *(_QWORD *)v3;
    v18 = glpArrayTypeGetElementType(*(_QWORD *)a2);
    BankType = glpMakeArrayType(v17, v18, *(_DWORD *)(a2 + 96), -1);
    goto LABEL_13;
  }
  v19 = *(_QWORD *)(a2 + 48);
  if (*(_DWORD *)(v3 + 24) == 4 && (*(_QWORD *)(a2 + 48) & 0x60000000) == 0x60000000)
  {
    glpStringHashPut(*(_QWORD *)(v3 + 192), *(const char **)(a2 + 16), *(_QWORD *)(a2 + 24), a2, v9);
    goto LABEL_17;
  }
  if ((v19 & 0x20000000) != 0)
  {
    v24 = *(_QWORD *)(v3 + 192);
    v25 = *(const char **)(a2 + 16);
    v26 = *(_QWORD *)(a2 + 24);
    goto LABEL_25;
  }
  if ((v19 & 0x40000000) != 0)
  {
LABEL_17:
    glpStringHashPut(*(_QWORD *)(v3 + 200), *(const char **)(a2 + 16), *(_QWORD *)(a2 + 24), a2, v9);
    v20 = *(_QWORD *)(v3 + 216);
    v21 = apiName(*(_QWORD **)v3, a2);
    v23 = v22;
    v24 = v20;
    v25 = (const char *)v21;
    v26 = v23;
LABEL_25:
    glpStringHashPut(v24, v25, v26, a2, v9);
    v27 = 1;
    goto LABEL_26;
  }
  if ((v19 & 0x100000000) != 0)
  {
    glpStringHashPut(*(_QWORD *)(v3 + 208), *(const char **)(a2 + 16), *(_QWORD *)(a2 + 24), a2, v9);
LABEL_34:
    v27 = *(_QWORD *)(a2 + 88) == 0;
    goto LABEL_26;
  }
  if (glpTypeGetKind(*(unsigned int **)a2) == 2
    || glpTypeGetKind(*(unsigned int **)a2) == 1)
  {
    goto LABEL_34;
  }
  v27 = 0;
LABEL_26:
  v28 = *(_QWORD *)a2;
  if (glpTypeGetKind(*(unsigned int **)a2) == 3)
    v28 = glpBankTypeGetElementType(v28);
  if (v27)
  {
    v29 = *(_QWORD *)v3;
    v30 = glpABIGetTypeSize(0, v28, 0);
    Size = glpTypeSizeGetSize(v30);
    v32 = BitSetNewWithAllocator(Size, *(_QWORD *)v29, *(uint64_t (**)(uint64_t, uint64_t, const char *))(v29 + 8), *(_QWORD *)(v29 + 16), *(_QWORD *)(v29 + 24));
    v33 = 0;
    *(_QWORD *)(a2 + 120) = v32;
  }
  else
  {
    v34 = glpABIGetTypeSize(0, v28, 0);
    v33 = glpTypeSizeGetSize(v34);
  }
  *(_DWORD *)(a2 + 128) = v33;
  *(_QWORD *)(a2 + 64) = glpMergeRemapValue(v3, *(_QWORD *)(a2 + 48), *(unsigned int **)a2, *(char **)(a2 + 64));
  result = glpMergeRemapValue(v3, *(_QWORD *)(a2 + 48), *(unsigned int **)a2, *(char **)(a2 + 72));
  *(_QWORD *)(a2 + 72) = result;
  return result;
}

uint64_t apiName(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v5;
  uint64_t FieldName;
  unsigned int *ElementType;
  uint64_t *StringBuffer;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v3 = *(_QWORD *)(a2 + 80);
  if (!v3)
    return *(_QWORD *)(a2 + 32);
  if (glpInterfaceBlockObjectGetVariableObjectCount(*(_QWORD *)(a2 + 80)))
  {
    v5 = 0;
    do
    {
      if (*(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v5) == a2)
        break;
      ++v5;
    }
    while (v5 < glpInterfaceBlockObjectGetVariableObjectCount(v3));
  }
  else
  {
    LODWORD(v5) = 0;
  }
  ElementType = *(unsigned int **)(v3 + 64);
  if (glpTypeGetKind(ElementType) == 3)
    ElementType = (unsigned int *)glpBankTypeGetElementType((uint64_t)ElementType);
  FieldName = glpStructTypeGetFieldName((uint64_t)ElementType, v5);
  if (*(_BYTE *)(v3 + 32))
  {
    StringBuffer = glpMakeStringBuffer(a1);
    glpStringBufferAppendFormat(StringBuffer, "%.*s.%.*s", v9, v10, v11, v12, v13, v14, *(_DWORD *)(v3 + 8));
    return glpStringBufferGetString((uint64_t)StringBuffer);
  }
  return FieldName;
}

uint64_t makeIntConstantNode(uint64_t *a1, uint64_t a2)
{
  unsigned int *PrimitiveType;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *MutableValue;
  uint64_t v12;
  uint64_t v13;
  __n128 v15;
  uint64_t v16;

  PrimitiveType = (unsigned int *)glpGetPrimitiveType(5u);
  v5 = *a1;
  MutableValue = glpMakeMutableValue(v5, PrimitiveType, 1, v6, v7, v8, v9, v10, a2);
  v15.n128_u64[0] = (unint64_t)"-1";
  v15.n128_u64[1] = 0xEDA00000002;
  v16 = 0xFFFFFFFFLL;
  glpMakeConstantNode(v5, &v15, (uint64_t)PrimitiveType, (uint64_t)MutableValue);
  v13 = v12;
  glpASTNodeSetSaType(v12, (uint64_t)PrimitiveType);
  glpASTNodeSetSaFlags(v13, 96);
  return v13;
}

uint64_t glpCheckBarrier(uint64_t a1)
{
  int v2;

  v2 = 0;
  return checkBarrier(a1, 0, &v2);
}

uint64_t checkBarrier(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t Body;
  int Kind;
  uint64_t Cond;
  uint64_t result;
  uint64_t IfStatement;
  uint64_t ElseStatement;
  uint64_t Prototype;
  uint64_t v12;
  char *Name;
  uint64_t v14;
  uint64_t Body0;
  uint64_t Expr;

  if (!a1)
    return 1;
  Body = a1;
  while (2)
  {
    Kind = glpASTNodeGetKind(Body);
    switch(Kind)
    {
      case 'C':
        Cond = glpIfStatementNodeGetCond(Body);
        result = checkBarrier(Cond, a2, a3);
        if ((_DWORD)result)
        {
          IfStatement = glpIfStatementNodeGetIfStatement(Body);
          result = checkBarrier(IfStatement, 0, a3);
          if ((_DWORD)result)
          {
            ElseStatement = glpIfStatementNodeGetElseStatement(Body);
            goto LABEL_16;
          }
        }
        return result;
      case 'D':
        Body0 = glpLoopStatementNodeGetBody0(Body);
        result = checkBarrier(Body0, 0, a3);
        if ((_DWORD)result)
        {
          ElseStatement = glpLoopStatementNodeGetBody1(Body);
          goto LABEL_16;
        }
        return result;
      case 'E':
        Expr = glpSwitchStatementNodeGetExpr(Body);
        result = checkBarrier(Expr, a2, a3);
        if ((_DWORD)result)
        {
          ElseStatement = glpSwitchStatementNodeGetBody(Body);
LABEL_16:
          Body = ElseStatement;
          a2 = 0;
          goto LABEL_17;
        }
        return result;
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
        return genericCheckKidsBarrier(Body, a2, (uint64_t)a3);
      case 'K':
        result = genericCheckKidsBarrier(Body, a2, (uint64_t)a3);
        if (!(_DWORD)result)
          return result;
        *a3 = 0;
        return 1;
      default:
        if (Kind == 51)
        {
          Prototype = glpFunctionDefinitionNodeGetPrototype(Body);
          result = checkBarrier(Prototype, a2, a3);
          if (!(_DWORD)result)
            return result;
          v12 = glpFunctionDefinitionNodeGetPrototype(Body);
          Name = (char *)glpFunctionPrototypeNodeGetName(v12);
          if (glpStringsEqual("main", 0x83863A00000004, Name, v14))
          {
            a2 = 1;
            *a3 = 1;
          }
          Body = glpFunctionDefinitionNodeGetBody(Body);
LABEL_17:
          if (!Body)
            return 1;
          continue;
        }
        if (Kind != 84 || glpPPStreamOpNodeGetOpcode(Body) != 170)
          return genericCheckKidsBarrier(Body, a2, (uint64_t)a3);
        if ((_DWORD)a2)
          return *a3 != 0;
        return 0;
    }
  }
}

uint64_t genericCheckKidsBarrier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6;
  uint64_t Child;
  uint64_t result;

  if (!glpASTNodeGetChildCount(a1))
    return 1;
  v6 = 0;
  while (1)
  {
    Child = glpASTNodeGetChild(a1, v6);
    result = checkBarrier(Child, a2, a3);
    if (!(_DWORD)result)
      break;
    if (++v6 >= glpASTNodeGetChildCount(a1))
      return 1;
  }
  return result;
}

uint64_t glpConstantValueFromDecomposedInitializer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int Kind;
  uint64_t result;
  uint64_t Lhs;
  uint64_t Rhs;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int *v14;
  unsigned int Swizzle;
  unsigned int v16;
  uint64_t SaType;
  int PrimitiveType;
  uint64_t v19;
  unsigned int v20;
  int ExprCount;
  int v22;
  unsigned int v23;
  uint64_t Expr;
  uint64_t Offset;
  uint64_t v26;
  uint64_t BankIndex;
  uint64_t VectorElementExpr;
  uint64_t OffsetExpr;
  uint64_t v30;
  const void *Value;

  Kind = glpASTNodeGetKind(a3);
  result = 0;
  if (Kind > 42)
  {
    if (Kind == 81)
    {
      Offset = glpDerefNodeGetOffset(a3);
      if (!Offset)
        return glpLValueNodeGetVariableExtra(a3) == a1;
      v26 = Offset;
      if (!glpOffsetNodeGetBankIndex(Offset)
        || (BankIndex = glpOffsetNodeGetBankIndex(v26), result = glpIsConstantNode(BankIndex), (_DWORD)result))
      {
        if (!glpOffsetNodeGetVectorElementExpr(v26)
          || (VectorElementExpr = glpOffsetNodeGetVectorElementExpr(v26),
              result = glpIsConstantNode(VectorElementExpr),
              (_DWORD)result))
        {
          if (!glpOffsetNodeGetOffsetExpr(v26))
            return glpLValueNodeGetVariableExtra(a3) == a1;
          OffsetExpr = glpOffsetNodeGetOffsetExpr(v26);
          result = glpIsConstantNode(OffsetExpr);
          if ((_DWORD)result)
            return glpLValueNodeGetVariableExtra(a3) == a1;
        }
      }
    }
    else
    {
      if (Kind != 43)
        return result;
      ExprCount = glpCommaExprNodeGetExprCount(a3);
      if (!ExprCount)
        return 1;
      v22 = ExprCount;
      v23 = 0;
      while (1)
      {
        Expr = glpCommaExprNodeGetExpr(a3, v23);
        result = glpConstantValueFromDecomposedInitializer(a1, a2, Expr);
        if (!(_DWORD)result)
          break;
        if (v22 == ++v23)
          return 1;
      }
    }
  }
  else
  {
    if (Kind == 3)
      return 1;
    if (Kind == 39)
    {
      Lhs = glpBinaryOperatorNodeGetLhs(a3);
      Rhs = glpBinaryOperatorNodeGetRhs(a3);
      result = glpIsLValueNode(Lhs);
      if ((_DWORD)result)
      {
        if (glpLValueNodeGetVariableExtra(Lhs) != a1)
          return 0;
        result = glpIsConstantNode(Rhs);
        if (!(_DWORD)result)
          return result;
        v10 = glpDerefNodeGetOffset(Lhs);
        if (!v10)
        {
          LODWORD(v13) = 0;
          goto LABEL_38;
        }
        v11 = v10;
        if (glpOffsetNodeGetBankIndex(v10) || glpOffsetNodeGetVectorElementExpr(v11))
          return 0;
        v12 = glpOffsetNodeGetOffsetExpr(v11);
        v13 = (unsigned int *)v12;
        if (!v12)
        {
LABEL_14:
          Swizzle = glpOffsetNodeGetSwizzle(v11);
          if ((Swizzle & 6) == 0)
          {
            v16 = Swizzle;
            if (Swizzle)
            {
              SaType = glpASTNodeGetSaType(Lhs);
              PrimitiveType = glpPrimitiveTypeGetPrimitiveType(SaType);
              v19 = a2 + 16 * v13;
              v20 = (v16 >> 3) & 3;
              if (PrimitiveType <= 8)
              {
                if (PrimitiveType != 1 && PrimitiveType != 5)
                  goto LABEL_45;
              }
              else if (PrimitiveType != 9 && PrimitiveType != 36)
              {
                if (PrimitiveType == 62)
                {
                  *(_QWORD *)(v19 + 8 * v20) = *(_QWORD *)glpConstantNodeGetValue(Rhs);
                  return 1;
                }
LABEL_45:
                abort();
              }
              *(_DWORD *)(v19 + 4 * v20) = *(_DWORD *)glpConstantNodeGetValue(Rhs);
              return 1;
            }
LABEL_38:
            v30 = glpASTNodeGetSaType(Rhs);
            Value = (const void *)glpConstantNodeGetValue(Rhs);
            glpCopyValueInto((void *)(a2 + 16 * v13), v30, Value);
            return 1;
          }
          return 0;
        }
        result = glpIsConstantNode(v12);
        if ((_DWORD)result)
        {
          v14 = (unsigned int *)glpASTNodeGetSaType((uint64_t)v13);
          v13 = (unsigned int *)glpConstantNodeGetValue((uint64_t)v13);
          result = glpValueIsUsableAsSize(v14, v13);
          if ((_DWORD)result)
          {
            LODWORD(v13) = glpValueGetAsSize((uint64_t)v14, v13);
            goto LABEL_14;
          }
        }
      }
    }
  }
  return result;
}

uint64_t glpConstantFold(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t SaFlags;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;

  if ((unint64_t)(a3 + 1) < 2 || (glpASTNodeGetSaFlags(a3) & 0x80) != 0)
    return a3;
  switch(glpASTNodeGetKind(a3))
  {
    case 0u:
      return foldTypeConversion(a1, a2, a3);
    case 3u:
      return foldConstant(a1, a2, a3);
    case 0x10u:
      return foldNegate(a1, a2, a3);
    case 0x11u:
      v8 = a1;
      v9 = a2;
      v10 = a3;
      v11 = 10;
      goto LABEL_11;
    case 0x12u:
      v8 = a1;
      v9 = a2;
      v10 = a3;
      v11 = 132;
LABEL_11:
      result = foldUnaryOperator(v8, v9, v10, v11);
      break;
    case 0x27u:
      foldAssign(a3);
      return a3;
    case 0x2Bu:
      result = foldCommaExpr(a3);
      break;
    case 0x2Eu:
      result = foldVariableDeclaration(a1, a3);
      break;
    case 0x42u:
      result = foldBlock(a3);
      break;
    case 0x43u:
      result = foldIfStatement(a3);
      break;
    case 0x45u:
      foldSwitchStatement(a1, a3);
      return a3;
    case 0x51u:
      result = foldLValue(a1, a2, a3);
      break;
    case 0x52u:
      result = foldRValue(a1, a2, a3);
      break;
    case 0x54u:
      result = foldPPStreamOp(a1, a2, a3);
      break;
    default:
      SaFlags = glpASTNodeGetSaFlags(a3);
      glpASTNodeSetSaFlags(a3, SaFlags | 0x80);
      return a3;
  }
  return result;
}

uint64_t foldTypeConversion(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t Expr;
  uint64_t SaType;
  uint64_t PrimitiveType;
  const void *Value;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *MutableValue;
  uint64_t v19;
  uint64_t v20;
  int ScalarType;
  int v22;
  int v23;
  int v24;
  int v25;
  char GLVMType;
  uint64_t SaFlags;
  uint64_t v28;
  uint64_t v30;
  unint64_t v31;
  int v32[34];
  uint64_t v33;

  v3 = a3;
  v33 = *MEMORY[0x24BDAC8D0];
  Expr = glpUnaryOperatorNodeGetExpr(a3);
  if (glpIsConstantNode(Expr))
  {
    SaType = glpASTNodeGetSaType(Expr);
    PrimitiveType = glpPrimitiveTypeGetPrimitiveType(SaType);
    Value = (const void *)glpConstantNodeGetValue(Expr);
    v10 = glpASTNodeGetSaType(v3);
    v11 = glpPrimitiveTypeGetPrimitiveType(v10);
    v12 = (unsigned int *)glpASTNodeGetSaType(v3);
    MutableValue = glpMakeMutableValue(a1, v12, 0, v13, v14, v15, v16, v17, v30);
    v31 = 0;
    v19 = glpASTNodeGetSaType(v3);
    v20 = glpPrimitiveTypeGetPrimitiveType(v19);
    ScalarType = glpPrimitiveTypeGetScalarType(v20);
    if (ScalarType == 36)
      v22 = 3;
    else
      v22 = 4;
    if (ScalarType == 9)
      v23 = 1;
    else
      v23 = v22;
    if (ScalarType == 5)
      v24 = 2;
    else
      v24 = 4;
    if (ScalarType == 1)
      v24 = 0;
    if (ScalarType <= 8)
      v25 = v24;
    else
      v25 = v23;
    GLVMType = glpGLPTypeGetGLVMType(PrimitiveType);
    glvmChooseDestTypeConversion(v25, GLVMType, &v31);
    if ((v31 & 0x7C0000000000000) != 0)
    {
      glpVecFromValue(v32, PrimitiveType, Value);
      glvmTypeConvertCF((uint64_t)v32, (v31 >> 54) & 0x1F);
      glpMutableValueFromVec(MutableValue, v11, v32);
    }
    else
    {
      v28 = glpASTNodeGetSaType(v3);
      glpCopyValueInto(MutableValue, v28, Value);
    }
    return glpMakeConstantNodeFromNodeAndMutableValue(a1, a2, v3, MutableValue);
  }
  else
  {
    SaFlags = glpASTNodeGetSaFlags(v3);
    glpASTNodeSetSaFlags(v3, SaFlags | 0x80);
  }
  return v3;
}

uint64_t foldConstant(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int *SaType;
  const void *Value;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;

  SaType = (unsigned int *)glpASTNodeGetSaType(a3);
  Value = (const void *)glpConstantNodeGetValue(a3);
  v13 = glpCopyValue(a1, SaType, Value, v8, v9, v10, v11, v12);
  return glpMakeConstantNodeFromNodeAndMutableValue(a1, a2, a3, v13);
}

uint64_t foldNegate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t Expr;
  uint64_t SaType;
  uint64_t PrimitiveType;
  int Category;
  int ByteStride;
  uint64_t v11;
  uint64_t SaFlags;
  uint64_t Value;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *MutableValue;
  int GLVMType;
  int v22;
  unsigned int v23;
  uint64_t v25[18];

  v3 = a3;
  v25[17] = *MEMORY[0x24BDAC8D0];
  Expr = glpUnaryOperatorNodeGetExpr(a3);
  if (glpIsConstantNode(Expr))
  {
    SaType = glpASTNodeGetSaType(v3);
    PrimitiveType = glpPrimitiveTypeGetPrimitiveType(SaType);
    Category = glpPrimitiveTypeGetCategory(PrimitiveType);
    if ((Category - 1) >= 2)
    {
      if (Category == 3)
      {
        LODWORD(v11) = glpPrimitiveMatrixGetColumns(PrimitiveType);
        PrimitiveType = glpPrimitiveMatrixGetColumnType(PrimitiveType);
        ByteStride = glpPrimitiveTypeGetByteStride(PrimitiveType);
      }
      else
      {
        LODWORD(v11) = 0;
        ByteStride = 0;
      }
    }
    else
    {
      ByteStride = 0;
      LODWORD(v11) = 1;
    }
    Value = glpConstantNodeGetValue(Expr);
    v14 = (unsigned int *)glpASTNodeGetSaType(v3);
    MutableValue = glpMakeMutableValue(a1, v14, 0, v15, v16, v17, v18, v19, v25[0]);
    GLVMType = glpGLPTypeGetGLVMType(PrimitiveType);
    if ((_DWORD)v11)
    {
      v22 = GLVMType;
      v23 = 0;
      v11 = v11;
      do
      {
        glpVecFromValue((int *)v25, PrimitiveType, (const void *)(Value + v23));
        glvmSourceNegateCF(0, v22, (uint64_t)v25);
        glpMutableValueFromVec(&MutableValue[v23], PrimitiveType, v25);
        v23 += ByteStride;
        --v11;
      }
      while (v11);
    }
    return glpMakeConstantNodeFromNodeAndMutableValue(a1, a2, v3, MutableValue);
  }
  else
  {
    SaFlags = glpASTNodeGetSaFlags(v3);
    glpASTNodeSetSaFlags(v3, SaFlags | 0x80);
  }
  return v3;
}

uint64_t foldAssign(uint64_t a1)
{
  uint64_t Lhs;
  uint64_t Rhs;
  uint64_t VariableExtra;
  uint64_t v5;
  uint64_t SaFlags;

  Lhs = glpBinaryOperatorNodeGetLhs(a1);
  Rhs = glpBinaryOperatorNodeGetRhs(a1);
  if (!glpIsLValueNode(Lhs))
    goto LABEL_6;
  VariableExtra = glpLValueNodeGetVariableExtra(Lhs);
  v5 = *(_QWORD *)(VariableExtra + 104);
  if (!v5 || !glpIsConstantNode(Rhs) || !glpConstantValueFromDecomposedInitializer(VariableExtra, v5, a1))
  {
    *(_QWORD *)(VariableExtra + 104) = 0;
LABEL_6:
    SaFlags = glpASTNodeGetSaFlags(a1);
    glpASTNodeSetSaFlags(a1, SaFlags | 0x80);
  }
  return a1;
}

uint64_t foldCommaExpr(uint64_t a1)
{
  int ChildCount;
  int v3;
  unsigned int v4;
  unint64_t v5;
  uint64_t Child;
  uint64_t v7;
  uint64_t SaFlags;

  ChildCount = glpASTNodeGetChildCount(a1);
  if (!ChildCount)
    return a1;
  v3 = ChildCount;
  v4 = 0;
  LODWORD(v5) = 0;
  do
  {
    Child = glpASTNodeGetChild(a1, v4);
    v7 = Child;
    if (Child)
    {
      if ((_DWORD)v5)
        LODWORD(v5) = 1;
      else
        v5 = ((unint64_t)glpASTNodeGetSaFlags(Child) >> 7) & 1;
    }
    ++v4;
  }
  while (v3 != v4);
  if ((_DWORD)v5)
  {
    SaFlags = glpASTNodeGetSaFlags(a1);
    glpASTNodeSetSaFlags(a1, SaFlags | 0x80);
    return a1;
  }
  return v7;
}

uint64_t foldVariableDeclaration(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t Extra;
  const char *Name;
  unsigned int v6;
  const char *v7;
  _BOOL4 v8;
  uint64_t v9;
  uint64_t Initializer;
  uint64_t v12;
  uint64_t SaFlags;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BOOL4 v19;
  char *MutableValue;
  uint64_t v21;
  uint64_t v23;

  v2 = a2;
  Extra = glpVariableDeclarationNodeGetExtra(a2);
  Name = (const char *)glpVariableDeclarationNodeGetName(v2);
  if (v6 && (v7 = Name, *Name == 36))
    v8 = v6 < 9 || strncmp("$ib$", Name, 4uLL) || strncmp("$gl_", v7 + 5, 4uLL) != 0;
  else
    v8 = 0;
  v9 = *(_QWORD *)(Extra + 64);
  Initializer = glpVariableDeclarationNodeGetInitializer(v2);
  if (v9)
    v8 = 1;
  if (!v8 || Initializer != 0)
  {
    v12 = Initializer;
    SaFlags = glpASTNodeGetSaFlags(v2);
    glpASTNodeSetSaFlags(v2, SaFlags | 0x80);
    if (v12)
      v19 = v8;
    else
      v19 = 0;
    if (v19)
    {
      MutableValue = glpMakeMutableValue(a1, *(unsigned int **)Extra, 0, v14, v15, v16, v17, v18, v23);
      v21 = glpVariableDeclarationNodeGetInitializer(v2);
      if (glpConstantValueFromDecomposedInitializer(Extra, (uint64_t)MutableValue, v21))
      {
        *(_QWORD *)(Extra + 64) = MutableValue;
        *(_QWORD *)(Extra + 72) = MutableValue;
        glpVariableDeclarationNodeSetInitializer(v2, 0);
        return 0;
      }
    }
  }
  return v2;
}

uint64_t foldBlock(uint64_t a1)
{
  uint64_t v1;
  unsigned int v2;
  uint64_t Statement;
  uint64_t SaFlags;

  v1 = a1;
  if (!glpBlockNodeGetStatementCount(a1))
    return 0;
  v2 = 0;
  while (1)
  {
    Statement = glpBlockNodeGetStatement(v1, v2);
    if (Statement)
    {
      if ((glpASTNodeGetSaFlags(Statement) & 0x80) != 0)
        break;
    }
    if (++v2 >= glpBlockNodeGetStatementCount(v1))
      return 0;
  }
  SaFlags = glpASTNodeGetSaFlags(v1);
  glpASTNodeSetSaFlags(v1, SaFlags | 0x80);
  return v1;
}

uint64_t foldIfStatement(uint64_t a1)
{
  uint64_t Cond;
  uint64_t SaFlags;

  Cond = glpIfStatementNodeGetCond(a1);
  if (glpIsConstantNode(Cond))
  {
    if (*(_DWORD *)glpConstantNodeGetValue(Cond))
      return glpIfStatementNodeGetIfStatement(a1);
    else
      return glpIfStatementNodeGetElseStatement(a1);
  }
  else
  {
    SaFlags = glpASTNodeGetSaFlags(a1);
    glpASTNodeSetSaFlags(a1, SaFlags | 0x80);
    return a1;
  }
}

uint64_t foldSwitchStatement(uint64_t a1, uint64_t a2)
{
  uint64_t BlockNode;
  uint64_t SaFlags;
  __n128 v7;

  if (!glpSwitchStatementNodeGetBody(a2))
  {
    glpASTNodeGetLocation(a2, &v7);
    BlockNode = glpMakeBlockNode(a1, &v7, 0);
    glpSwitchStatementNodeSetBody(a2, BlockNode);
  }
  SaFlags = glpASTNodeGetSaFlags(a2);
  glpASTNodeSetSaFlags(a2, SaFlags | 0x80);
  return a2;
}

uint64_t foldLValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *VariableExtra;
  char *v7;
  uint64_t SaFlags;

  VariableExtra = (uint64_t *)glpLValueNodeGetVariableExtra(a3);
  v7 = (char *)VariableExtra[8];
  if (v7)
    return foldDerefNode(a1, a2, a3, v7, *VariableExtra);
  SaFlags = glpASTNodeGetSaFlags(a3);
  glpASTNodeSetSaFlags(a3, SaFlags | 0x80);
  return a3;
}

uint64_t foldRValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Base;
  char *Value;
  uint64_t Type;
  uint64_t SaFlags;

  Base = glpRValueNodeGetBase(a3);
  if (glpIsConstantNode(Base))
  {
    Value = (char *)glpConstantNodeGetValue(Base);
    Type = glpConstantNodeGetType(Base);
    return foldDerefNode(a1, a2, a3, Value, Type);
  }
  else
  {
    SaFlags = glpASTNodeGetSaFlags(a3);
    glpASTNodeSetSaFlags(a3, SaFlags | 0x80);
    return a3;
  }
}

uint64_t foldPPStreamOp(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int ReturnPrimitiveType;
  unsigned int Opcode;
  int HasSrctex;
  uint64_t ChildCount;
  unsigned int v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  size_t v14;
  uint64_t v15;
  BOOL v16;
  _BOOL4 v17;
  uint64_t i;
  uint64_t Child;
  unsigned int v20;
  unsigned int v21;
  _BOOL4 v22;
  _BOOL4 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  int Category;
  unsigned int v30;
  int v31;
  unsigned int *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *MutableValue;
  char *v40;
  char *v41;
  uint64_t v42;
  uint64_t SaFlags;
  uint64_t v44;
  uint64_t v46;
  uint64_t SaType;
  uint64_t v48;
  int PrimitiveType;
  int v50;
  _BOOL4 IsConstantNode;
  _BOOL4 v53;
  _BOOL4 v54;
  _BOOL4 v55;
  _BOOL4 v57;
  _BOOL4 v58;
  uint64_t v59;
  _DWORD *Value;
  uint64_t v61;
  _DWORD *v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unsigned int OpPrimitiveType;
  unsigned int v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  ReturnPrimitiveType = glpPPStreamOpNodeGetReturnPrimitiveType(a3);
  Opcode = glpPPStreamOpNodeGetOpcode(a3);
  OpPrimitiveType = glpPPStreamOpNodeGetOpPrimitiveType(a3);
  HasSrctex = glpPPStreamOpNodeGetHasSrctex(a3);
  ChildCount = glpASTNodeGetChildCount(a3);
  v10 = ChildCount;
  MEMORY[0x24BDAC7A8](ChildCount);
  v13 = (uint64_t *)((char *)&v72 - v12);
  if (v11 >= 0x200)
    v14 = 512;
  else
    v14 = v11;
  bzero((char *)&v72 - v12, v14);
  v15 = v10;
  if (HasSrctex)
    v16 = 1;
  else
    v16 = v10 >= 5;
  v17 = !v16;
  v73 = a1;
  v75 = ReturnPrimitiveType;
  if (v10)
  {
    for (i = 0; i != v10; ++i)
    {
      Child = glpASTNodeGetChild(a3, i);
      v13[i] = Child;
      if (!glpIsConstantNode(Child))
        v17 = 0;
    }
    v17 = v17;
  }
  if (v17 || Opcode > 0x22 || ((1 << Opcode) & 0x580000000) == 0)
    goto LABEL_17;
  v72 = a2;
  v46 = *v13;
  SaType = glpASTNodeGetSaType(*v13);
  v44 = v13[1];
  v48 = glpASTNodeGetSaType(v44);
  PrimitiveType = glpPrimitiveTypeGetPrimitiveType(SaType);
  v50 = glpPrimitiveTypeGetPrimitiveType(v48);
  IsConstantNode = glpIsConstantNode(v46);
  v53 = PrimitiveType == 5 || PrimitiveType == 36;
  v54 = IsConstantNode && v53;
  v55 = glpIsConstantNode(v44);
  v57 = v50 == 5 || v50 == 36;
  v58 = v55 && v57;
  v59 = v46;
  if (v54)
    Value = (_DWORD *)glpConstantNodeGetValue(v46);
  else
    Value = 0;
  v61 = v72;
  if (v58)
    v62 = (_DWORD *)glpConstantNodeGetValue(v44);
  else
    v62 = 0;
  v63 = v59;
  a2 = v61;
  if (Opcode == 31)
  {
    if (Value && !*Value)
      return v44;
LABEL_76:
    if (v62)
    {
      v44 = v63;
      if (!*v62)
        return v44;
    }
LABEL_17:
    v21 = OpPrimitiveType;
    v20 = v75;
    if (v75)
      v22 = v17;
    else
      v22 = 0;
    if (OpPrimitiveType)
      v23 = v22;
    else
      v23 = 0;
    if (Opcode - 78 <= 0x28 && ((1 << (Opcode - 78)) & 0x18000000001) != 0 || Opcode == 11)
      goto LABEL_34;
    if (Opcode != 34)
      goto LABEL_31;
    goto LABEL_27;
  }
  if (Opcode == 32)
    goto LABEL_76;
  if (Opcode != 34)
    goto LABEL_17;
  if (Value && !*Value || v62 && !*v62)
  {
    v64 = v75;
    v65 = (unsigned int *)glpGetPrimitiveType(v75);
    v66 = v73;
    MutableValue = glpMakeMutableValue(v73, v65, 0, v67, v68, v69, v70, v71, v72);
    glpPrimitiveTypeGetScalarCount(v64);
    v42 = v66;
    return glpMakeConstantNodeFromNodeAndMutableValue(v42, a2, a3, MutableValue);
  }
  if (Value && *Value == 1)
    return v44;
  if (v62)
  {
    v44 = v63;
    if (*v62 == 1)
      return v44;
  }
  v23 = 0;
  v21 = OpPrimitiveType;
  v20 = v75;
LABEL_27:
  v24 = glpCallNodeGetArg(a3, 0);
  v25 = glpASTNodeGetSaType(v24);
  v26 = glpCallNodeGetArg(a3, 1u);
  v27 = glpASTNodeGetSaType(v26);
  v28 = glpPrimitiveTypeGetPrimitiveType(v25);
  Category = glpPrimitiveTypeGetCategory(v28);
  v30 = glpPrimitiveTypeGetPrimitiveType(v27);
  v31 = glpPrimitiveTypeGetCategory(v30);
  if (Category == 3 && (v31 & 0xFFFFFFFE) == 2 || Category == 2 && v31 == 3)
    goto LABEL_34;
LABEL_31:
  if (Opcode - 171 < 4 || !v23)
  {
LABEL_34:
    SaFlags = glpASTNodeGetSaFlags(a3);
    glpASTNodeSetSaFlags(a3, SaFlags | 0x80);
    return a3;
  }
  v32 = (unsigned int *)glpGetPrimitiveType(v20);
  v33 = v73;
  MutableValue = glpMakeMutableValue(v73, v32, 0, v34, v35, v36, v37, v38, v72);
  v40 = glpGetPrimitiveType(v21);
  v41 = glpGetPrimitiveType(v20);
  glvmOp(Opcode, (uint64_t)v40, v15, v13, MutableValue, (uint64_t)v41);
  v42 = v33;
  return glpMakeConstantNodeFromNodeAndMutableValue(v42, a2, a3, MutableValue);
}

uint64_t glpGLPTypeGetGLVMType(uint64_t a1)
{
  int ScalarType;
  int v2;
  unsigned int v3;
  unsigned int v4;

  ScalarType = glpPrimitiveTypeGetScalarType(a1);
  if (ScalarType == 36)
    v2 = 8;
  else
    v2 = 16;
  if (ScalarType == 9)
    v3 = 2;
  else
    v3 = v2;
  if (ScalarType == 5)
    v4 = 1;
  else
    v4 = 16;
  if (ScalarType == 1)
    v4 = 4;
  if (ScalarType <= 8)
    return v4;
  else
    return v3;
}

uint64_t glpVecFromValue(int *a1, uint64_t a2, const void *a3)
{
  int BytesPerComponent;
  unsigned int ScalarCount;
  uint64_t result;
  uint64_t v9;
  int v10;

  BytesPerComponent = glpPrimitiveTypeGetBytesPerComponent(a2);
  ScalarCount = glpPrimitiveTypeGetScalarCount(a2);
  memcpy(a1, a3, ScalarCount * BytesPerComponent);
  result = glpPrimitiveTypeGetScalarType(a2);
  if ((_DWORD)result == 9 && ScalarCount)
  {
    v9 = ScalarCount;
    do
    {
      if (*a1)
        v10 = -1;
      else
        v10 = 0;
      *a1++ = v10;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t glpMutableValueFromVec(_DWORD *a1, uint64_t a2, const void *a3)
{
  int BytesPerComponent;
  unsigned int ScalarCount;
  uint64_t result;
  uint64_t v9;

  BytesPerComponent = glpPrimitiveTypeGetBytesPerComponent(a2);
  ScalarCount = glpPrimitiveTypeGetScalarCount(a2);
  memcpy(a1, a3, ScalarCount * BytesPerComponent);
  result = glpPrimitiveTypeGetScalarType(a2);
  if ((_DWORD)result == 9 && ScalarCount)
  {
    v9 = ScalarCount;
    do
    {
      *a1 = *a1 != 0;
      ++a1;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t glpMakeConstantNodeFromNodeAndMutableValue(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t SaType;
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t SaFlags;
  __n128 v16;

  glpASTNodeGetLocation(a3, &v16);
  SaType = glpASTNodeGetSaType(a3);
  v9 = (unsigned int *)glpASTNodeGetSaType(a3);
  v10 = glpRemapValue(a2, v9, a4);
  glpMakeConstantNode(a1, &v16, SaType, v10);
  v12 = v11;
  v13 = glpASTNodeGetSaType(a3);
  glpASTNodeSetSaType(v12, v13);
  SaFlags = glpASTNodeGetSaFlags(a3);
  glpASTNodeSetSaFlags(v12, SaFlags);
  return v12;
}

uint64_t foldUnaryOperator(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int *SaType;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *MutableValue;
  uint64_t SaFlags;
  uint64_t v17;
  uint64_t Expr;

  Expr = glpUnaryOperatorNodeGetExpr(a3);
  if (glpIsConstantNode(Expr))
  {
    SaType = (unsigned int *)glpASTNodeGetSaType(a3);
    MutableValue = glpMakeMutableValue(a1, SaType, 0, v9, v10, v11, v12, v13, v17);
    glvmOp(a4, (uint64_t)SaType, 1, &Expr, MutableValue, (uint64_t)SaType);
    return glpMakeConstantNodeFromNodeAndMutableValue(a1, a2, a3, MutableValue);
  }
  else
  {
    SaFlags = glpASTNodeGetSaFlags(a3);
    glpASTNodeSetSaFlags(a3, SaFlags | 0x80);
    return a3;
  }
}

uint64_t glvmOp(int a1, uint64_t a2, uint64_t a3, uint64_t *a4, _DWORD *a5, uint64_t a6)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  unsigned int v16;
  unsigned int *v17;
  _DWORD *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t Type;
  uint64_t PrimitiveType;
  unsigned int ScalarCount;
  uint64_t v24;
  uint64_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  uint64x2_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  __n128 v44;
  int8x16_t v45;
  int8x16_t v46;
  int8x16_t v47;
  unint64_t v48;
  uint64_t v49;
  const void *Value;
  uint64_t v51;
  int *v52;
  unsigned int v53;
  uint64_t v54;
  char *v55;
  uint64_t *v56;
  unint64_t v57;
  unsigned int v58;
  unsigned int BytesPerComponent;
  unint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v65;
  void *Constants;
  int v67;
  _DWORD *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  char *v75;
  unint64_t v76;
  float32x4_t v77[8];
  int8x16_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;

  v68 = a5;
  v67 = a1;
  v79 = *MEMORY[0x24BDAC8D0];
  Constants = glvmGetConstants();
  v10 = a3;
  v11 = MEMORY[0x24BDAC7A8](Constants);
  v13 = (char *)&v65 - ((v12 + 15) & 0x7FFFFFFF0);
  MEMORY[0x24BDAC7A8](v11);
  v15 = (char *)&v65 - v14;
  v74 = a3;
  v73 = a6;
  if ((_DWORD)a3)
  {
    v76 = a2;
    v16 = 0;
    a3 = a3;
    v17 = (unsigned int *)((char *)&v65 - v14);
    v18 = v13;
    v19 = a4;
    do
    {
      v20 = *v19++;
      Type = glpConstantNodeGetType(v20);
      PrimitiveType = glpPrimitiveTypeGetPrimitiveType(Type);
      *v18++ = PrimitiveType;
      ScalarCount = glpPrimitiveTypeGetScalarCount(PrimitiveType);
      *v17++ = ScalarCount;
      if (v16 <= ScalarCount)
        v16 = ScalarCount;
      --a3;
    }
    while (a3);
    v77[0].i32[0] = 0;
    v78.i32[0] = 0;
    if ((_DWORD)v74)
    {
      v24 = 0;
      do
      {
        v25 = *(unsigned int *)&v13[v24 * 4];
        v77[0].i32[v24] = glpPrimitiveTypeGetScalarCount(v25) - 1;
        v78.i32[v24++] = glpGLPTypeGetGLVMType(v25);
      }
      while (v10 != v24);
      v26.i64[0] = 0x1F0000001FLL;
      v26.i64[1] = 0x1F0000001FLL;
      v27 = vandq_s8(v78, v26);
      v28.i64[0] = v27.u32[0];
      v28.i64[1] = v27.u32[1];
      v29 = (uint64x2_t)v28;
      v28.i64[0] = v27.u32[2];
      v28.i64[1] = v27.u32[3];
      v30 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)v77[0], (uint32x4_t)xmmword_22A980C30), (int8x16_t)xmmword_22A980C40);
      v31 = vorrq_s8((int8x16_t)vshlq_u64(v29, (uint64x2_t)xmmword_22A980C20), (int8x16_t)vshlq_u64((uint64x2_t)v28, (uint64x2_t)xmmword_22A980C10));
      *(int8x8_t *)v29.i8 = vorr_s8(*(int8x8_t *)v30.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
      v28.i64[0] = v29.u32[0];
      v28.i64[1] = v29.u32[1];
      v32 = vorrq_s8(v31, v28);
      v33 = (unint64_t)vorr_s8(*(int8x8_t *)v32.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
    }
    else
    {
      v33 = 0;
    }
    a6 = v73;
    a2 = v76;
    if (v73)
      goto LABEL_14;
  }
  else
  {
    v16 = 0;
    v33 = 0;
    if (a6)
    {
LABEL_14:
      v34 = glpPrimitiveTypeGetPrimitiveType(a6);
      v33 = v33 & 0xE0FFFFFFFFFFFFFFLL | (glpGLPTypeGetGLVMType(v34) << 56);
    }
  }
  v35 = glpPrimitiveTypeGetPrimitiveType(a6);
  v36 = glpPrimitiveTypeGetScalarCount(v35);
  v37 = v33 & 0xFFFFFFFFFFFFFF0FLL | 0x10;
  if (v36 == 4)
    v37 = v33 | 0xF0;
  if (v36 == 3)
    v37 = v33 & 0xFFFFFFFFFFFFFF0FLL | 0x70;
  if (v36 == 2)
    v38 = v33 & 0xFFFFFFFFFFFFFF0FLL | 0x30;
  else
    v38 = v37;
  v39 = glpPrimitiveTypeGetPrimitiveType(a2);
  v40 = glpPrimitiveTypeGetScalarCount(v39);
  v76 = v38 & 0xFFFFFFFFFF87FFFFLL | (((_DWORD)v40 << 19) + 1572864) & 0x180000;
  MEMORY[0x24BDAC7A8](v40);
  v48 = (unint64_t)(&v65 - 16 * v10) & 0xFFFFFFFFFFFFFFE0;
  if ((_DWORD)v74)
  {
    v49 = 0;
    v72 = ((v16 << 17) + 393216) & 0x60000;
    v71 = ((v16 << 15) + 98304) & 0x18000;
    v70 = (((_WORD)v16 << 13) + 24576) & 0x6000;
    v69 = (((_WORD)v16 << 11) + 6144) & 0x1800;
    v75 = v13;
    do
    {
      Value = (const void *)glpConstantNodeGetValue(a4[v49]);
      v51 = *(unsigned int *)&v13[4 * v49];
      v52 = (int *)(v48 + (v49 << 7));
      glpVecFromValue(v52, v51, Value);
      v53 = *(_DWORD *)&v15[4 * v49];
      if (v53 < v16)
      {
        v54 = v10;
        v55 = v15;
        v56 = a4;
        v57 = v48;
        v58 = v53 - 1;
        do
        {
          BytesPerComponent = glpPrimitiveTypeGetBytesPerComponent(v51);
          memcpy((char *)v52 + BytesPerComponent * v53++, (char *)v52 + BytesPerComponent * v58, BytesPerComponent);
        }
        while (v16 != v53);
        v48 = v57;
        switch((int)v49)
        {
          case 0:
            v60 = v76 & 0xFFFFFFFFFFFFE7FFLL;
            v61 = &v81;
            goto LABEL_32;
          case 1:
            v60 = v76 & 0xFFFFFFFFFFFF9FFFLL;
            v61 = &v82;
            goto LABEL_32;
          case 2:
            v60 = v76 & 0xFFFFFFFFFFFE7FFFLL;
            v61 = &v83;
            goto LABEL_32;
          case 3:
            v60 = v76 & 0xFFFFFFFFFFF9FFFFLL;
            v61 = &v84;
LABEL_32:
            v76 = v60 | *(v61 - 32);
            break;
          default:
            v48 = v57;
            break;
        }
        a4 = v56;
        v15 = v55;
        v10 = v54;
        v13 = v75;
      }
      ++v49;
    }
    while (v49 != v10);
  }
  v62 = v73;
  switch(v67)
  {
    case 2:
      glvmOperationABS((uint64_t)Constants, (int8x16_t *)v48, (int8x16_t *)v77, v76);
      break;
    case 3:
      glvmOperationCEI((uint64_t)Constants, (double *)v48, (uint64_t)v77, v76, v44);
      break;
    case 4:
      glvmOperationFRC((uint64_t)Constants, (float32x4_t *)v48, (double *)v77[0].i64, v76);
      break;
    case 5:
      glvmOperationFLR((uint64_t)Constants, (double *)v48, (uint64_t)v77, v76, v44);
      break;
    case 6:
    case 80:
    case 81:
      glvmOperationZERO((uint64_t)Constants, v77, v76);
      break;
    case 7:
      glvmOperationSSG((int8x16_t)v44, (uint64_t)Constants, v48, (float64_t *)v77[0].i64, v76);
      break;
    case 8:
      glvmOperationANY((uint64_t)Constants, (int32x2_t *)v48, v77, v76);
      break;
    case 9:
      glvmOperationALL((uint64_t)Constants, (int32x2_t *)v48, v77, v76);
      break;
    case 10:
      glvmOperationNOT((uint64_t)Constants, (int8x16_t *)v48, (int8x16_t *)v77);
      break;
    case 11:
      glvmOperationNSE((uint64_t)Constants, v48, (uint64_t)v77, v76);
      break;
    case 12:
      glvmOperationSQT((uint64_t)Constants, (double *)v48, (double *)v77[0].i64, v76);
      break;
    case 16:
      glvmOperationEX2((uint64_t)Constants, (float32x4_t *)v48, (uint64_t)v77, v76);
      break;
    case 18:
      glvmOperationLEN((uint64_t)Constants, v48, (uint64_t)v77, v76);
      break;
    case 19:
      glvmOperationLG2((uint64_t)Constants, (float *)v48, v77, v76);
      break;
    case 21:
      glvmOperationNRM((uint64_t)Constants, (float32x4_t *)v48, v77, v76);
      break;
    case 22:
      glvmOperationRAD((uint64_t)Constants, (float32x4_t *)v48, v77);
      break;
    case 23:
      glvmOperationDEG((uint64_t)Constants, (float32x4_t *)v48, v77);
      break;
    case 25:
      glvmOperationSIN(Constants, v48, v77, v76);
      break;
    case 26:
      glvmOperationCOS((uint64_t)Constants, (float32x4_t *)v48, v77);
      break;
    case 27:
      glvmOperationTAN((uint64_t)Constants, (float32x4_t *)v48, (int8x16_t *)v77);
      break;
    case 28:
      glvmOperationASN((uint64_t)Constants, (int8x16_t *)v48, (int8x16_t *)v77);
      break;
    case 29:
      glvmOperationACS((uint64_t)Constants, (float32x4_t *)v48, v77);
      break;
    case 30:
      if ((_DWORD)v74 == 2)
        glvmOperationATN2((uint64_t)Constants, (float32x4_t *)v48, (float32x4_t *)(v48 + 128), (uint64_t)v77);
      else
        glvmOperationATN((uint64_t)Constants, (int8x16_t *)v48, (int8x16_t *)v77);
      break;
    case 31:
      glvmOperationADD((uint64_t)Constants, v48, v48 + 128, (uint64_t)v77, v76);
      break;
    case 32:
      glvmOperationSUB((uint64_t)Constants, v48, v48 + 128, (uint64_t)v77, v76);
      break;
    case 33:
      glvmOperationMOD((uint64_t)Constants, v48, v48 + 128, (uint64_t)v77, v76);
      break;
    case 34:
      glvmOperationMUL((uint64_t)Constants, v48, v48 + 128, (uint64_t)v77, v76);
      break;
    case 35:
      glvmOperationMLC(Constants, v48, v48 + 128, v77, v76);
      break;
    case 36:
      glvmOperationANL((uint64_t)Constants, (int8x16_t *)v48, (int8x16_t *)(v48 + 128), (int8x16_t *)v77);
      break;
    case 37:
      glvmOperationORL((uint64_t)Constants, (int8x16_t *)v48, (int8x16_t *)(v48 + 128), (int8x16_t *)v77);
      break;
    case 38:
      glvmOperationXRL((uint64_t)Constants, (int8x16_t *)v48, (int8x16_t *)(v48 + 128), (int8x16_t *)v77);
      break;
    case 39:
      glvmOperationDOT((uint64_t)Constants, v48, v48 + 128, (uint64_t)v77, v76);
      break;
    case 44:
      glvmOperationMIN((uint64_t)Constants, (int *)v48, (int *)(v48 + 128), (uint64_t)v77, v76);
      break;
    case 45:
      glvmOperationMAX((uint64_t)Constants, (int *)v48, (int *)(v48 + 128), (uint64_t)v77, v76);
      break;
    case 46:
      glvmOperationXPD((uint64_t)Constants, v48, v48 + 128, (uint64_t)v77, v76);
      break;
    case 47:
      glvmOperationRFL((uint64_t)Constants, v48, v48 + 128, (uint64_t)v77, v76);
      break;
    case 49:
      glvmOperationSEQ((int32x4_t)v44, (uint64_t)Constants, v48, v48 + 128, (int32x4_t *)v77, v76);
      break;
    case 50:
      glvmOperationSGE((uint64_t)Constants, v48, v48 + 128, (int32x4_t *)v77, v76);
      break;
    case 51:
      glvmOperationSGT((uint64_t)Constants, v48, v48 + 128, (int32x4_t *)v77, v76);
      break;
    case 52:
      glvmOperationSLE((uint64_t)Constants, v48, v48 + 128, (int32x4_t *)v77, v76);
      break;
    case 53:
      glvmOperationSLT((uint64_t)Constants, v48, v48 + 128, (int32x4_t *)v77, v76);
      break;
    case 54:
      glvmOperationSNE((int32x4_t)v44, (uint64_t)Constants, v48, v48 + 128, (int32x4_t *)v77, v76);
      break;
    case 56:
      glvmOperationPOW((uint64_t)Constants, (float *)v48, (float32x4_t *)(v48 + 128), (uint64_t)v77, v76);
      break;
    case 58:
      glvmOperationDIV((float64x2_t)v44, (uint64_t)Constants, v48, v48 + 128, (uint64_t)v77, v76);
      break;
    case 59:
      glvmOperationFFW((uint64_t)Constants, v48, v48 + 128, v48 + 256, (uint64_t)v77, v76);
      break;
    case 60:
      glvmOperationLRP((uint64_t)Constants, v48, (float64x2_t *)(v48 + 128), (float64x2_t *)(v48 + 256), (float64x2_t *)v77, v76);
      break;
    case 61:
      glvmOperationCLM((uint64_t)Constants, (int *)v48, (int *)(v48 + 128), (unsigned int *)(v48 + 256), (uint64_t)v77, v76);
      break;
    case 63:
      glvmOperationMAD((uint64_t)Constants, v48, (float64x2_t *)(v48 + 128), (float64x2_t *)(v48 + 256), (float64x2_t *)v77, v76);
      break;
    case 64:
      glvmOperationSMS((uint64_t)Constants, (float64x2_t *)v48, (float64x2_t *)(v48 + 128), (float64x2_t *)(v48 + 256), (float64x2_t *)v77, v76);
      break;
    case 92:
      glvmOperationPK2H((uint64_t)Constants, (_DWORD *)v48, v77);
      break;
    case 93:
      glvmOperationPK2US((uint64_t)Constants, (float32x2_t *)v48, v77);
      break;
    case 94:
      glvmOperationPK4B((uint64_t)Constants, (float32x4_t *)v48, v77);
      break;
    case 95:
      glvmOperationPK4UB((uint64_t)Constants, (float32x4_t *)v48, v77);
      break;
    case 100:
      glvmOperationUP2H((uint64_t)Constants, (unsigned __int16 *)v48, (int *)v77);
      break;
    case 101:
      glvmOperationUP2US(v44.n128_f32[0], (uint64_t)Constants, (_WORD *)v48, v77);
      break;
    case 102:
      glvmOperationUP4B((int8x8_t)v44.n128_u64[0], (uint64_t)Constants, (__int8 *)v48, v77);
      break;
    case 103:
      glvmOperationUP4UB(v44.n128_f32[0], (uint64_t)Constants, (_BYTE *)v48, v77);
      break;
    case 105:
      glvmOperationRFR((uint64_t)Constants, v48, v48 + 128, v48 + 256, (uint64_t)v77, v76);
      break;
    case 112:
      glvmOperationEXPE((uint64_t)Constants, (float32x4_t *)v48, (uint64_t)v77, v76);
      break;
    case 113:
      glvmOperationLOGE((uint64_t)Constants, (float *)v48, v77, v76);
      break;
    case 123:
      glvmOperationROUND((uint64_t)Constants, (float *)v48, (uint64_t)v77, v76);
      break;
    case 124:
      glvmOperationTRUNCATE((uint64_t)Constants, (float *)v48, (uint64_t)v77, v76);
      break;
    case 125:
      glvmOperationAND((uint64_t)Constants, (int8x16_t *)v48, (int8x16_t *)(v48 + 128), (int8x16_t *)v77);
      break;
    case 126:
      glvmOperationOR((uint64_t)Constants, (int8x16_t *)v48, (int8x16_t *)(v48 + 128), (int8x16_t *)v77);
      break;
    case 127:
      glvmOperationXOR((uint64_t)Constants, (int8x16_t *)v48, (int8x16_t *)(v48 + 128), (int8x16_t *)v77);
      break;
    case 128:
      glvmOperationSHL((uint64_t)Constants, (_DWORD *)v48, (_DWORD *)(v48 + 128), v77);
      break;
    case 129:
      glvmOperationSHR((uint64_t)Constants, (int *)v48, (_DWORD *)(v48 + 128), v77, v76);
      break;
    case 132:
      glvmOperationCOMP((uint64_t)Constants, (int8x16_t *)v48, (int8x16_t *)v77);
      break;
    case 133:
      glvmOperationDISTANCE((uint64_t)Constants, v48, v48 + 128, (uint64_t)v77, v76);
      break;
    case 134:
      glvmOperationINVERSESQRT((uint64_t)Constants, (double *)v48, (double *)v77[0].i64, v76);
      break;
    case 137:
      glvmOperationROUNDEVEN((uint64_t)Constants, (double *)v48, (double *)v77[0].i64, v76);
      break;
    case 138:
      glvmOperationISNAN((uint64_t)Constants, (float32x4_t *)v48, (int8x16_t *)v77, v76);
      break;
    case 139:
      glvmOperationISINF((uint64_t)Constants, (int8x16_t *)v48, (int32x4_t *)v77, v76);
      break;
    case 144:
      glvmOperationSINH((uint64_t)Constants, (float *)v48, v77[0].f32);
      break;
    case 145:
      glvmOperationCOSH((uint64_t)Constants, (float *)v48, v77[0].f32);
      break;
    case 146:
      glvmOperationTANH((uint64_t)Constants, (float *)v48, v77[0].f32);
      break;
    case 147:
      glvmOperationASINH((uint64_t)Constants, (float *)v48, v77[0].f32);
      break;
    case 148:
      glvmOperationACOSH((uint64_t)Constants, (float *)v48, v77[0].f32);
      break;
    case 149:
      glvmOperationATANH((uint64_t)Constants, (float *)v48, v77[0].f32);
      break;
    case 150:
      glvmOperationTO_BITS((uint64_t)Constants, v48, (uint64_t)v77);
      break;
    case 151:
      glvmOperationFROM_BITS((uint64_t)Constants, v48, (uint64_t)v77);
      break;
    case 154:
      glvmOperationEXTRACT_EXPONENT((uint64_t)Constants, (float *)v48, (uint64_t)v77, v76);
      break;
    case 155:
      glvmOperationEXTRACT_SIGNIFICAND((uint64_t)Constants, (float *)v48, (uint64_t)v77, v76);
      break;
    case 156:
      glvmOperationLDEXP((uint64_t)Constants, (float *)v48, (unsigned int *)(v48 + 128), (uint64_t)v77, v76);
      break;
    case 157:
      glvmOperationPK2W((uint64_t)Constants, (_QWORD *)v48, v77);
      break;
    case 158:
      glvmOperationUP2W((uint64_t)Constants, (_QWORD *)v48, v77);
      break;
    case 159:
      glvmOperationMUL_HB((uint64_t)Constants, (unsigned int *)v48, (unsigned int *)(v48 + 128), v77, v76, v41, v42, v43, (uint64_t)&v80);
      break;
    case 160:
      glvmOperationBITFIELD_REVERSE((uint64_t)Constants, (_DWORD *)v48, v77);
      break;
    case 161:
      glvmOperationBITCOUNT((uint64_t)Constants, (unsigned int *)v48, v77);
      break;
    case 162:
      glvmOperationFIND_LSB((uint64_t)Constants, (_DWORD *)v48, v77);
      break;
    case 163:
      glvmOperationFIND_MSB((int8x16_t)v44, v45, v46, v47, (uint64_t)Constants, (int32x4_t *)v48, (int *)v77, v76);
      break;
    default:
      break;
  }
  v63 = glpPrimitiveTypeGetPrimitiveType(v62);
  return glpMutableValueFromVec(v68, v63, v77);
}

uint64_t foldDerefNode(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  uint64_t Offset;
  uint64_t v11;
  uint64_t BankIndex;
  uint64_t OffsetExpr;
  unsigned int Swizzle;
  uint64_t VectorElementExpr;
  uint64_t v16;
  unsigned int *SaType;
  unsigned int PreSwizzlePrimitiveType;
  uint64_t SaFlags;
  unsigned int *Value;
  unsigned int *Type;
  unsigned int AsSize;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t PrimitiveType;
  int ScalarType;
  unsigned int VectorType;
  unsigned int *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *MutableValue;
  unsigned int *v42;
  unsigned int *v43;
  unsigned int v44;
  uint64_t v45;
  unsigned int *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int Swizzle_2;
  unsigned int *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;

  Offset = glpDerefNodeGetOffset(a3);
  v69 = a2;
  if (Offset)
  {
    v11 = Offset;
    BankIndex = glpOffsetNodeGetBankIndex(Offset);
    OffsetExpr = glpOffsetNodeGetOffsetExpr(v11);
    Swizzle = glpOffsetNodeGetSwizzle(v11);
    VectorElementExpr = glpOffsetNodeGetVectorElementExpr(v11);
  }
  else
  {
    Swizzle = 0;
    BankIndex = 0;
    OffsetExpr = 0;
    VectorElementExpr = 0;
  }
  v16 = glpDerefNodeGetOffset(a3);
  SaType = (unsigned int *)glpASTNodeGetSaType(a3);
  if (!glpTypeGetKind(SaType) && v16 && glpOffsetNodeGetPreSwizzlePrimitiveType(v16))
  {
    PreSwizzlePrimitiveType = glpOffsetNodeGetPreSwizzlePrimitiveType(v16);
    SaType = (unsigned int *)glpGetPrimitiveType(PreSwizzlePrimitiveType);
  }
  if (BankIndex)
    goto LABEL_9;
  if (OffsetExpr)
  {
    if (!glpIsConstantNode(OffsetExpr))
      goto LABEL_9;
    Value = (unsigned int *)glpConstantNodeGetValue(OffsetExpr);
    Type = (unsigned int *)glpConstantNodeGetType(OffsetExpr);
    if (!glpValueIsUsableAsSize(Type, Value))
      goto LABEL_9;
    AsSize = glpValueGetAsSize((uint64_t)Type, Value);
    v24 = glpABIGetTypeSize(0, a5, 0);
    if (AsSize >= glpTypeSizeGetSize(v24))
      goto LABEL_9;
    v30 = glpCopyValue(a1, SaType, &a4[16 * AsSize], v25, v26, v27, v28, v29);
  }
  else
  {
    v30 = a4;
  }
  if (Swizzle)
  {
    v31 = glpASTNodeGetSaType(a3);
    PrimitiveType = glpPrimitiveTypeGetPrimitiveType(v31);
    ScalarType = glpPrimitiveTypeGetScalarType(PrimitiveType);
    VectorType = glpGetVectorType(ScalarType, Swizzle & 7);
    v35 = (unsigned int *)glpGetPrimitiveType(VectorType);
    MutableValue = glpMakeMutableValue(a1, v35, 0, v36, v37, v38, v39, v40, v68);
    glpCopyValueIntoWithSwizzle((uint64_t)MutableValue, (uint64_t)v35, (uint64_t)v30, Swizzle);
    v30 = MutableValue;
  }
  if (!VectorElementExpr)
    goto LABEL_23;
  if (!glpIsConstantNode(VectorElementExpr)
    || (v42 = (unsigned int *)glpConstantNodeGetValue(VectorElementExpr),
        v43 = (unsigned int *)glpConstantNodeGetType(VectorElementExpr),
        !glpValueIsUsableAsSize(v43, v42))
    || (v44 = glpValueGetAsSize((uint64_t)v43, v42),
        v45 = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType),
        v44 >= glpPrimitiveTypeGetScalarCount(v45)))
  {
LABEL_9:
    SaFlags = glpASTNodeGetSaFlags(a3);
    glpASTNodeSetSaFlags(a3, SaFlags | 0x80);
    return a3;
  }
  v46 = (unsigned int *)glpASTNodeGetSaType(a3);
  v52 = glpMakeMutableValue(a1, v46, 0, v47, v48, v49, v50, v51, v68);
  v53 = glpASTNodeGetSaType(a3);
  Swizzle_2 = glpMakeSwizzle_2(v53, v54, v55, v56, v57, v58, v59, v60, v44);
  glpCopyValueIntoWithSwizzle((uint64_t)v52, v53, (uint64_t)v30, Swizzle_2);
  v30 = v52;
LABEL_23:
  if (v30 == a4)
  {
    v62 = (unsigned int *)glpASTNodeGetSaType(a3);
    v30 = glpCopyValue(a1, v62, a4, v63, v64, v65, v66, v67);
  }
  return glpMakeConstantNodeFromNodeAndMutableValue(a1, v69, a3, v30);
}

uint64_t glpCopyValueIntoWithSwizzle(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  unsigned int v7;
  uint64_t PrimitiveType;
  uint64_t result;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;

  v7 = a4 & 7;
  PrimitiveType = glpPrimitiveTypeGetPrimitiveType(a2);
  result = glpPrimitiveTypeGetBytesPerComponent(PrimitiveType);
  if (v7)
  {
    v10 = result;
    v11 = 0;
    v12 = 0;
    v13 = 2 * v7;
    v14 = result;
    do
    {
      result = (uint64_t)memcpy((void *)(a1 + v11), (const void *)(a3 + ((a4 >> (v12 + 3)) & 3) * v10), v14);
      v12 += 2;
      v11 += v10;
    }
    while (v13 != v12);
  }
  return result;
}

uint64_t glpMakeSwizzle_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  return (8 * a9) | 1u;
}

uint64_t glpPPTNode(uint64_t *a1, uint64_t a2)
{
  if (a2)
  {
    switch(glpASTNodeGetKind(a2))
    {
      case 0u:
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 9u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
      case 0x1Eu:
      case 0x1Fu:
      case 0x20u:
      case 0x21u:
      case 0x22u:
      case 0x23u:
      case 0x24u:
      case 0x25u:
      case 0x26u:
      case 0x27u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x3Fu:
      case 0x40u:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Du:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
        goto LABEL_3;
      case 0x2Eu:
        return glpPPTVariableDeclaration(a1, a2);
      case 0x33u:
        return glpPPTFunctionDefinition(a1, a2);
      case 0x45u:
        glpPPTSwitchStatement(a1, a2);
        return a2;
      case 0x4Cu:
        a1[3] = a2;
LABEL_3:
        transformKids((uint64_t)a1, a2);
        return a2;
      case 0x4Eu:
        return glpPPTRawCall(a1, a2);
      default:
        abort();
    }
  }
  return a2;
}

uint64_t glpPPTVariableDeclaration(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t Initializer;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t SaType;
  unsigned int v9;
  uint64_t Def;
  uint64_t Prototype;
  uint64_t Extra;
  uint64_t Body;
  __n128 v15;

  v2 = a2;
  transformKids((uint64_t)a1, a2);
  if (glpVariableDeclarationNodeGetInitializer(v2) && (glpASTNodeGetSaFlags(v2) & 0x100000000) == 0)
  {
    Initializer = glpVariableDeclarationNodeGetInitializer(v2);
    glpVariableDeclarationNodeSetInitializer(v2, 0);
    if ((glpASTNodeGetSaFlags(v2) & 0x80000000) != 0)
    {
      if (glpTopLevelNodeGetDefCount(a1[3]))
      {
        v9 = 0;
        while (1)
        {
          Def = glpTopLevelNodeGetDef(a1[3], v9);
          if (glpIsFunctionDefinitionNode(Def))
          {
            Prototype = glpFunctionDefinitionNodeGetPrototype(Def);
            Extra = glpFunctionPrototypeNodeGetExtra(Prototype);
            if (glpStringsEqual("$copy_in", 0x2CF8B77300000008, *(char **)(Extra + 24), *(_QWORD *)(Extra + 32)))
              break;
          }
          if (++v9 >= glpTopLevelNodeGetDefCount(a1[3]))
            goto LABEL_10;
        }
        Body = glpFunctionDefinitionNodeGetBody(Def);
      }
      else
      {
LABEL_10:
        Body = 0;
      }
      glpBlockNodeAddStatement((_QWORD *)*a1, Body, Initializer);
    }
    else
    {
      v5 = *a1;
      glpASTNodeGetLocation(v2, &v15);
      glpMakeCommaExprNode(v5, &v15, 0);
      v7 = v6;
      glpCommaExprNodeAddExpr((_QWORD *)*a1, v6, v2);
      glpCommaExprNodeAddExpr((_QWORD *)*a1, v7, Initializer);
      SaType = glpASTNodeGetSaType(v2);
      glpASTNodeSetSaType(v7, SaType);
      return v7;
    }
  }
  return v2;
}

uint64_t glpPPTFunctionDefinition(uint64_t *a1, uint64_t a2)
{
  uint64_t Prototype;
  uint64_t Body;
  unsigned int StatementCount;
  uint64_t Statement;
  uint64_t Expr;
  int ExprCount;
  uint64_t Extra;
  uint64_t v11;
  uint64_t ReturnStatementNode;
  char *PrimitiveType;
  __n128 v15;

  transformKids((uint64_t)a1, a2);
  Prototype = glpFunctionDefinitionNodeGetPrototype(a2);
  if ((*(_BYTE *)(glpFunctionPrototypeNodeGetExtra(Prototype) + 9) & 0x20) != 0)
  {
    Extra = glpFunctionPrototypeNodeGetExtra(Prototype);
    *(_QWORD *)(Extra + 64) = a2;
    if ((*(_BYTE *)(Extra + 10) & 2) == 0)
      return Prototype;
  }
  else
  {
    Body = glpFunctionDefinitionNodeGetBody(a2);
    StatementCount = glpBlockNodeGetStatementCount(Body);
    do
    {
      if (!StatementCount)
        goto LABEL_13;
      --StatementCount;
    }
    while (!glpBlockNodeGetStatement(Body, StatementCount));
    Statement = glpBlockNodeGetStatement(Body, StatementCount);
    if (!Statement)
      goto LABEL_13;
    Expr = Statement;
    while (glpIsCommaExprNode(Expr))
    {
      ExprCount = glpCommaExprNodeGetExprCount(Expr);
      Expr = glpCommaExprNodeGetExpr(Expr, ExprCount - 1);
      if (!Expr)
        goto LABEL_13;
    }
    if (!glpIsReturnStatementNode(Expr))
    {
LABEL_13:
      v11 = *a1;
      glpASTNodeGetLocation(a2, &v15);
      ReturnStatementNode = glpMakeReturnStatementNode(v11, &v15);
      PrimitiveType = glpGetPrimitiveType(0);
      glpASTNodeSetSaType(ReturnStatementNode, (uint64_t)PrimitiveType);
      glpBlockNodeAddStatement((_QWORD *)*a1, Body, ReturnStatementNode);
    }
  }
  return a2;
}

uint64_t glpPPTSwitchStatement(uint64_t *a1, uint64_t a2)
{
  uint64_t Body;
  unsigned int StatementCount;
  uint64_t Statement;
  uint64_t Expr;
  int ExprCount;
  uint64_t v9;
  uint64_t BreakStatementNode;
  char *PrimitiveType;
  __n128 v13;

  transformKids((uint64_t)a1, a2);
  Body = glpSwitchStatementNodeGetBody(a2);
  StatementCount = glpBlockNodeGetStatementCount(Body);
  do
  {
    if (!StatementCount)
      goto LABEL_10;
    --StatementCount;
  }
  while (!glpBlockNodeGetStatement(Body, StatementCount));
  Statement = glpBlockNodeGetStatement(Body, StatementCount);
  if (!Statement)
    goto LABEL_10;
  Expr = Statement;
  while (glpIsCommaExprNode(Expr))
  {
    ExprCount = glpCommaExprNodeGetExprCount(Expr);
    Expr = glpCommaExprNodeGetExpr(Expr, ExprCount - 1);
    if (!Expr)
      goto LABEL_10;
  }
  if (!glpIsBreakStatementNode(Expr))
  {
LABEL_10:
    v9 = *a1;
    glpASTNodeGetLocation(a2, &v13);
    BreakStatementNode = glpMakeBreakStatementNode(v9, &v13);
    PrimitiveType = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(BreakStatementNode, (uint64_t)PrimitiveType);
    glpBlockNodeAddStatement((_QWORD *)*a1, Body, BreakStatementNode);
  }
  return a2;
}

uint64_t glpPPTRawCall(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int ExprCount;
  uint64_t *v9;
  uint64_t Body;
  uint64_t v11;
  _QWORD v13[3];
  __n128 v14;

  transformKids((uint64_t)a1, a2);
  v4 = *a1;
  glpASTNodeGetLocation(a2, &v14);
  glpMakeCommaExprNode(v4, &v14, 0);
  v6 = v5;
  v7 = glpRawCallNodeGetExtra(a2);
  ExprCount = glpCommaExprNodeGetExprCount(v6);
  glpCommaExprNodeAddExpr((_QWORD *)*a1, v6, a2);
  if (*(_QWORD *)(v7 + 64) && (*(_BYTE *)(v7 + 9) & 0x20) != 0)
  {
    v13[0] = 0;
    v13[1] = glpMakePointerHash((_QWORD *)*a1);
    v13[2] = glpMakePointerHash((_QWORD *)*a1);
    v9 = (uint64_t *)*a1;
    Body = glpFunctionDefinitionNodeGetBody(*(_QWORD *)(v7 + 64));
    v11 = glpDeepCopyASTNode(v9, Body, (uint64_t (*)(uint64_t, uint64_t *, _DWORD *))inliningNodeReplacement, (uint64_t)v13);
    glpCommaExprNodeSetExpr(v6, ExprCount, v11);
  }
  return v6;
}

uint64_t transformKids(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unsigned int v5;
  uint64_t Child;
  uint64_t v7;

  result = glpASTNodeGetChildCount(a2);
  if ((_DWORD)result)
  {
    v5 = 0;
    do
    {
      Child = glpASTNodeGetChild(a2, v5);
      v7 = glpPPTNode(a1, Child);
      glpASTNodeSetChild(a2, v5++, v7);
      result = glpASTNodeGetChildCount(a2);
    }
    while (v5 < result);
  }
  return result;
}

uint64_t inliningNodeReplacement(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  int Kind;
  unint64_t VariableExtra;
  uint64_t v8;
  _OWORD *v9;
  _OWORD *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  unint64_t Extra;
  uint64_t v20;
  uint64_t v21;
  _QWORD v23[6];

  v3 = a3;
  Kind = glpASTNodeGetKind(a3);
  if (Kind > 79)
  {
    if (Kind == 80)
    {
      Extra = glpOffsetNodeGetExtra(v3);
      v20 = *(_QWORD *)(a1 + 16);
      v23[0] = MEMORY[0x24BDAC760];
      v23[1] = 0x40000000;
      v23[2] = __inliningNodeReplacement_block_invoke;
      v23[3] = &__block_descriptor_tmp_13;
      v23[4] = a2;
      v23[5] = Extra;
      v21 = glpPointerHashCache_b(v20, Extra, (uint64_t)v23);
      glpOffsetNodeSetExtra(v3, v21);
    }
    else if (Kind == 81)
    {
      VariableExtra = glpLValueNodeGetVariableExtra(v3);
      v8 = glpPointerHashGet(*(_QWORD *)(a1 + 8), VariableExtra);
      if (v8)
        glpLValueNodeSetVariableExtra(v3, v8);
    }
  }
  else if (Kind == 46)
  {
    v9 = (_OWORD *)glpVariableDeclarationNodeGetExtra(v3);
    v10 = (_OWORD *)(*(uint64_t (**)(_QWORD, uint64_t, const char *))(a2 + 8))(*(_QWORD *)a2, 160, "Variable Object (PPT inlining)");
    v11 = v9[1];
    *v10 = *v9;
    v10[1] = v11;
    v12 = v9[5];
    v14 = v9[2];
    v13 = v9[3];
    v10[4] = v9[4];
    v10[5] = v12;
    v10[2] = v14;
    v10[3] = v13;
    v15 = v9[8];
    v16 = v9[9];
    v18 = v9[6];
    v17 = v9[7];
    v10[8] = v15;
    v10[9] = v16;
    v10[6] = v18;
    v10[7] = v17;
    glpPointerHashPut(*(_QWORD *)(a1 + 8), (unint64_t)v9, (uint64_t)v10, *(double *)&v15);
    glpVariableDeclarationNodeSetExtra(v3, (uint64_t)v10);
  }
  else if (Kind == 75)
  {
    v3 = 0;
    *(_BYTE *)a1 = 1;
  }
  return v3;
}

__n128 __inliningNodeReplacement_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  __n128 result;

  v2 = (*(uint64_t (**)(_QWORD, uint64_t, const char *))(*(_QWORD *)(a1 + 32) + 8))(**(_QWORD **)(a1 + 32), 32, "Offset Object (PPT inlining)");
  v3 = *(_QWORD *)(a1 + 40);
  result = *(__n128 *)(v3 + 16);
  *(_OWORD *)v2 = *(_OWORD *)v3;
  *(__n128 *)(v2 + 16) = result;
  return result;
}

uint64_t glpSANode(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t Allocator;
  uint64_t ValueHash;

  v2 = a2;
  if ((unint64_t)(a2 + 1) >= 2 && !glpASTNodeGetSaType(a2))
  {
    glpCompilerPushSAContext((uint64_t)a1, v2);
    switch(glpASTNodeGetKind(v2))
    {
      case 0u:
        v4 = glpSATypeConversion((uint64_t)a1, v2);
        goto LABEL_84;
      case 1u:
        v4 = glpSAVariableIdentifier((uint64_t)a1, v2);
        goto LABEL_84;
      case 2u:
        v4 = glpSATypeIdentifier((uint64_t)a1, v2);
        goto LABEL_84;
      case 3u:
        glpSAConstant(v2);
        goto LABEL_85;
      case 4u:
        v4 = glpSAArrayAccess((uint64_t)a1, v2);
        goto LABEL_84;
      case 5u:
        v4 = glpSAFieldAccess((uint64_t)a1, v2);
        goto LABEL_84;
      case 6u:
        v4 = glpSAUndeterminedCall((uint64_t)a1, v2);
        goto LABEL_84;
      case 7u:
        v4 = glpSAFunctionCall((uint64_t)a1, v2);
        goto LABEL_84;
      case 8u:
        v4 = glpSASubroutineArrayCall((uint64_t)a1, v2);
        goto LABEL_84;
      case 9u:
        v4 = glpSAMethodCall((uint64_t)a1, v2);
        goto LABEL_84;
      case 0xAu:
        v4 = glpSAConstructorCall((uint64_t)a1, v2);
        goto LABEL_84;
      case 0xBu:
        v4 = glpSAPostincrement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0xCu:
        v4 = glpSAPostdecrement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0xDu:
        v4 = glpSAPreincrement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0xEu:
        v4 = glpSAPredecrement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0xFu:
        v4 = glpSAUnaryPlus((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x10u:
        v4 = glpSANegate((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x11u:
        v4 = glpSALogicalNot((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x12u:
        v4 = glpSABitwiseNot((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x13u:
        v4 = glpSAMultiply((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x14u:
        v4 = glpSADivide((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x15u:
        v4 = glpSAModulo((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x16u:
        v4 = glpSAAdd((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x17u:
        v4 = glpSASubtract((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x18u:
        v4 = glpSAShiftLeft((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x19u:
        v4 = glpSAShiftRight((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x1Au:
        v4 = glpSALess((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x1Bu:
        v4 = glpSALessEqual((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x1Cu:
        v4 = glpSAGreater((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x1Du:
        v4 = glpSAGreaterEqual((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x1Eu:
        v4 = glpSAEqual((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x1Fu:
        v4 = glpSANotEqual((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x20u:
        v4 = glpSALogicalAnd((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x21u:
        v4 = glpSALogicalOr((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x22u:
        v4 = glpSALogicalXor((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x23u:
        v4 = glpSABitwiseAnd((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x24u:
        v4 = glpSABitwiseOr((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x25u:
        v4 = glpSABitwiseXor((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x26u:
        v4 = glpSAIfExpr((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x27u:
        v4 = glpSAAssign((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x28u:
        v4 = glpSAOpAssign((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x29u:
        glpSAReadInput();
      case 0x2Au:
        glpSAWriteOutput();
      case 0x2Bu:
        v4 = glpSACommaExpr((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x2Cu:
        v4 = glpSAParameterDeclaration((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x2Du:
        v4 = glpSAFunctionPrototype(a1, v2);
        goto LABEL_84;
      case 0x2Eu:
        v4 = glpSAVariableDeclaration((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x2Fu:
        v4 = glpSAVariableDeclarationGroup((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x30u:
        v4 = glpSAPrecisionDeclaration((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x31u:
        v4 = glpSAQualifiedDeclaration((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x32u:
        v4 = glpSAQualifiedDeclarationGroup((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x33u:
        v4 = glpSAFunctionDefinition((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x34u:
        v4 = glpSAQualifiedType((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x35u:
        glpSAPrimitiveType(v2);
        goto LABEL_85;
      case 0x36u:
        v4 = glpSAArrayType((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x37u:
        v4 = glpSAFieldDeclaration((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x38u:
        v4 = glpSAStructType((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x39u:
        v4 = glpSAInterfaceBlock((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x3Au:
        v4 = glpSALayoutType((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x3Bu:
        glpSAKeywordQualifier();
      case 0x3Cu:
        v4 = glpSALayoutQualifier((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x3Du:
        v4 = glpSASubroutineTypeList((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x3Eu:
        v4 = glpSAQualifierList((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x3Fu:
        v4 = glpSAGlobalTypeQualifier((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x40u:
        v4 = glpSALayoutPair((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x41u:
        v4 = glpSAExpressionStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x42u:
        v4 = glpSABlock((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x43u:
        v4 = glpSAIfStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x44u:
        v4 = glpSALoopStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x45u:
        v4 = glpSASwitchStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x46u:
        v4 = glpSACaseStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x47u:
        v4 = glpSADefaultStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x48u:
        v4 = glpSABreakStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x49u:
        v4 = glpSAContinueStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x4Au:
        v4 = glpSADiscardStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x4Bu:
        v4 = glpSAReturnStatement((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x4Cu:
        v4 = glpSATopLevel((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x4Du:
        glpSAAvailabilityDeclaration();
      case 0x4Eu:
        glpSARawCall();
      case 0x4Fu:
        v4 = glpSASubroutineRawCall((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x50u:
        v4 = glpSAOffset((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x51u:
        v4 = glpSALValue((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x52u:
        v4 = glpSARValue((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x53u:
        v4 = glpSAIBPartialDeref((uint64_t)a1, v2);
        goto LABEL_84;
      case 0x54u:
        v4 = glpSAPPStreamOp((uint64_t)a1, v2);
LABEL_84:
        v2 = v4;
LABEL_85:
        if ((unint64_t)(v2 + 1) >= 2)
        {
          Allocator = glpCompilerGetAllocator(a1);
          ValueHash = glpCompilerGetValueHash((uint64_t)a1);
          v2 = glpConstantFold(Allocator, ValueHash, v2);
        }
        glpCompilerPopSAContext((uint64_t)a1);
        break;
      case 0x55u:
        glpSASubroutineUniform();
      default:
        abort();
    }
  }
  return v2;
}

uint64_t glpSATypeConversion(uint64_t a1, uint64_t a2)
{
  _DWORD *v4;
  uint64_t Expr;
  char SaFlags;
  uint64_t v7;
  uint64_t v8;

  if (glpSAUnaryOperator(a1, a2) == -1)
    return glpSAFailed();
  v4 = (_DWORD *)glpTypeConversionNodeGetToType(a2);
  if (!glpTypeIsAtomic(v4))
    return glpLowerNonatomicTypeConversion(a1, a2);
  glpASTNodeSetSaType(a2, (uint64_t)v4);
  Expr = glpUnaryOperatorNodeGetExpr(a2);
  SaFlags = glpASTNodeGetSaFlags(Expr);
  v7 = glpTypeConversionNodeGetToPrecision(a2);
  v8 = glpUnaryOperatorNodeGetExpr(a2);
  if (glpIsConstantNode(v8))
    glpSAValidateConstPrecisionConversion(a1, Expr, v7);
  glpASTNodeSetSaFlags(a2, SaFlags & 0x60 | (unint64_t)v7);
  return a2;
}

uint64_t glpSAVariableIdentifier(uint64_t a1, uint64_t LValueForVariableObject)
{
  uint64_t NameTable;
  char *Name;
  uint64_t v6;
  uint64_t v7;
  uint64_t **v8;
  char v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t **InfoLog;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  char *v21;
  __n128 *v22;
  uint64_t v23;
  __n128 *v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t Allocator;
  uint64_t v28;
  int Representation;
  uint64_t StructTypeFromIBType;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int FieldIndex;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  char v42;
  __n128 v43;
  __n128 v44;
  __n128 v45;
  __n128 v46;
  __n128 v47;
  __n128 v48;
  __n128 v49;
  __n128 v50;
  _QWORD v51[7];
  uint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  int v59;

  NameTable = glpCompilerGetNameTable(a1);
  v56 = 0;
  v57 = &v56;
  v58 = 0x2000000000;
  v59 = 0;
  v52 = 0;
  v53 = &v52;
  v54 = 0x2000000000;
  v55 = 0;
  Name = (char *)glpVariableIdentifierNodeGetName(LValueForVariableObject);
  v51[0] = MEMORY[0x24BDAC760];
  v51[1] = 0x40000000;
  v51[2] = __glpSAVariableIdentifier_block_invoke;
  v51[3] = &unk_24F4B3190;
  v51[4] = &v56;
  v51[5] = &v52;
  v51[6] = NameTable;
  glpNameTableGet(NameTable, Name, v6, 0, (uint64_t)v51);
  v7 = v53[3];
  if (v7)
  {
    switch(*((_DWORD *)v57 + 6))
    {
      case 0:
        glpASTNodeGetLocation(LValueForVariableObject, &v49);
        v24 = &v49;
        v25 = a1;
        v26 = (uint64_t *)v7;
        goto LABEL_15;
      case 1:
        Allocator = glpCompilerGetAllocator(a1);
        glpASTNodeGetLocation(LValueForVariableObject, &v47);
        glpMakeIBPartialDerefNode(Allocator, &v47, v7);
        LValueForVariableObject = v28;
        glpASTNodeSetSaType(v28, *(_QWORD *)(v7 + 64));
        goto LABEL_16;
      case 2:
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(LValueForVariableObject, &v48);
        v21 = "You may never refer to an interface block by its block name within a shader";
        v22 = &v48;
        goto LABEL_5;
      case 3:
        Representation = glpInterfaceBlockObjectGetRepresentation(v53[3]);
        StructTypeFromIBType = glpGetStructTypeFromIBType(*(unsigned int **)(v7 + 64));
        v31 = (const char *)glpVariableIdentifierNodeGetName(LValueForVariableObject);
        v33 = v32;
        FieldIndex = glpStructTypeGetFieldIndex(StructTypeFromIBType, v31, v32);
        if (Representation == 1)
        {
          v39 = FieldIndex;
          glpASTNodeGetLocation(LValueForVariableObject, &v44);
          v26 = *(uint64_t **)(*(_QWORD *)(v7 + 72) + 8 * v39);
          v24 = &v44;
          v25 = a1;
LABEL_15:
          LValueForVariableObject = glpMakeLValueForVariableObject(v25, v24, v26);
        }
        else
        {
          if (Representation)
LABEL_18:
            abort();
          glpASTNodeGetLocation(LValueForVariableObject, &v46);
          v35 = glpMakeLValueForVariableObject(a1, &v46, **(uint64_t ***)(v7 + 72));
          v36 = glpCompilerGetAllocator(a1);
          glpASTNodeGetLocation(LValueForVariableObject, &v45);
          glpMakeFieldAccessNode(v36, &v45, (uint64_t)v31, v33);
          v38 = v37;
          glpFieldAccessNodeSetStructure(v37, v35);
          LValueForVariableObject = glpSAFieldAccessInternal(a1, v38);
          if (LValueForVariableObject == -1)
            goto LABEL_6;
        }
LABEL_16:
        v23 = glpCheckIBDeref(a1, LValueForVariableObject);
        goto LABEL_17;
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
        v8 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(LValueForVariableObject, &v43);
        glpVariableIdentifierNodeGetName(LValueForVariableObject);
        v10 = v9;
        glpVariableIdentifierNodeGetName(LValueForVariableObject);
        glpLogMessage(v8, 0, (uint64_t)&v43, "Attempt to use '%.*s' as a variable", v11, v12, v13, v14, v10);
        goto LABEL_6;
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xD:
        goto LABEL_18;
      default:
        goto LABEL_16;
    }
  }
  InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
  glpASTNodeGetLocation(LValueForVariableObject, &v50);
  glpVariableIdentifierNodeGetName(LValueForVariableObject);
  v42 = v20;
  glpVariableIdentifierNodeGetName(LValueForVariableObject);
  v21 = "Use of undeclared identifier '%.*s'";
  v22 = &v50;
LABEL_5:
  glpLogMessage(InfoLog, 0, (uint64_t)v22, v21, v16, v17, v18, v19, v42);
LABEL_6:
  v23 = glpSAFailed();
LABEL_17:
  v40 = v23;
  _Block_object_dispose(&v52, 8);
  _Block_object_dispose(&v56, 8);
  return v40;
}

uint64_t glpSATypeIdentifier(uint64_t a1, uint64_t a2)
{
  uint64_t NameTable;
  char *Name;
  uint64_t v6;
  uint64_t v7;
  uint64_t **InfoLog;
  char v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t **v15;
  char v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __n128 v23;
  __n128 v24;
  _QWORD v25[7];
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  int v33;

  NameTable = glpCompilerGetNameTable(a1);
  v30 = 0;
  v31 = &v30;
  v32 = 0x2000000000;
  v33 = 0;
  v26 = 0;
  v27 = &v26;
  v28 = 0x2000000000;
  v29 = 0;
  Name = (char *)glpTypeIdentifierNodeGetName(a2);
  v25[0] = MEMORY[0x24BDAC760];
  v25[1] = 0x40000000;
  v25[2] = __glpSATypeIdentifier_block_invoke;
  v25[3] = &unk_24F4B31B8;
  v25[4] = &v30;
  v25[5] = &v26;
  v25[6] = NameTable;
  glpNameTableGet(NameTable, Name, v6, 0, (uint64_t)v25);
  v7 = v27[3];
  if (v7)
  {
    switch(*((_DWORD *)v31 + 6))
    {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 7:
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v23);
        glpTypeIdentifierNodeGetName(a2);
        v10 = v9;
        glpTypeIdentifierNodeGetName(a2);
        glpLogMessage(InfoLog, 0, (uint64_t)&v23, "Attempt to use '%.*s' as a type", v11, v12, v13, v14, v10);
        goto LABEL_5;
      case 6:
      case 8:
        glpASTNodeSetSaType(a2, v7);
        goto LABEL_6;
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xD:
        abort();
      default:
        goto LABEL_6;
    }
  }
  v15 = (uint64_t **)glpCompilerGetInfoLog(a1);
  glpASTNodeGetLocation(a2, &v24);
  glpTypeIdentifierNodeGetName(a2);
  v17 = v16;
  glpTypeIdentifierNodeGetName(a2);
  glpLogMessage(v15, 0, (uint64_t)&v24, "Use of undeclared type '%.*s'", v18, v19, v20, v21, v17);
LABEL_5:
  a2 = glpSAFailed();
LABEL_6:
  _Block_object_dispose(&v26, 8);
  _Block_object_dispose(&v30, 8);
  return a2;
}

uint64_t glpSAConstant(uint64_t a1)
{
  uint64_t Type;

  Type = glpConstantNodeGetType(a1);
  glpASTNodeSetSaType(a1, Type);
  glpASTNodeSetSaFlags(a1, 96);
  return a1;
}

uint64_t glpSAArrayAccess(uint64_t a1, uint64_t a2)
{
  uint64_t Array;
  uint64_t v5;
  uint64_t Element;
  uint64_t v7;
  uint64_t v8;
  unsigned int *SaType;
  int Kind;
  uint64_t PrimitiveType;
  int Category;
  uint64_t v13;
  uint64_t Ib;
  uint64_t **InfoLog;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *Allocator;
  char v22;
  char v23;
  uint64_t **v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t NameTable;
  int v30;
  unsigned int *ElementType;
  uint64_t v32;
  unsigned int ElementCount;
  uint64_t v34;
  uint64_t v35;
  __n128 v36;
  __n128 v37;
  unsigned int v38;
  __n128 v39;

  Array = glpArrayAccessNodeGetArray(a2);
  v5 = glpSANode(a1, Array);
  if (v5 != -1)
    glpArrayAccessNodeSetArray(a2, v5);
  Element = glpArrayAccessNodeGetElement(a2);
  v7 = glpSANode(a1, Element);
  if (v7 == -1)
    return glpSAFailed();
  glpArrayAccessNodeSetElement(a2, v7);
  if (v5 == -1)
    return glpSAFailed();
  v8 = glpArrayAccessNodeGetArray(a2);
  SaType = (unsigned int *)glpASTNodeGetSaType(v8);
  if (glpIsIBPartialDerefNode(v8) && glpTypeGetKind(SaType) != 3)
  {
    Ib = glpIBPartialDerefNodeGetIb(v8);
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v39);
    glpLogMessage(InfoLog, 0, (uint64_t)&v39, "You may not index the non-array interface block '%.*s'", v17, v18, v19, v20, *(_DWORD *)(Ib + 24));
    return glpSAFailed();
  }
  Kind = glpTypeGetKind(SaType);
  if (Kind == 3)
  {
    if (!glpIsIBPartialDerefNode(v8))
    {
      ElementType = (unsigned int *)glpBankTypeGetElementType((uint64_t)SaType);
      goto LABEL_23;
    }
    NameTable = glpCompilerGetNameTable(a1);
    v30 = (*(_BYTE *)(**(_QWORD **)(glpIBPartialDerefNodeGetIb(v8) + 72) + 52) & 1) != 0
       && glpNameTableGetGLSLVersion(NameTable) <= 7
       && !glpNameTableIsExtensionEnabled(NameTable, 0x13u);
    v32 = glpArrayAccessNodeGetElement(a2);
    v38 = 0;
    glpASTNodeGetLocation(v32, &v37);
    ElementCount = glpBankTypeGetElementCount((uint64_t)SaType);
    v34 = glpCheckArrayIndex(a1, (__int128 *)&v37, v32, v30, 0, ElementCount, &v38);
    if (v34 != -1)
    {
      glpIBPartialDerefNodeSetBankIndex(v8, v34);
      v35 = glpBankTypeGetElementType((uint64_t)SaType);
      glpASTNodeSetSaType(v8, v35);
      return glpCheckIBDeref(a1, v8);
    }
    return glpSAFailed();
  }
  if (Kind == 2)
  {
    ElementType = (unsigned int *)glpArrayTypeGetElementType((uint64_t)SaType);
LABEL_23:
    v13 = glpIndirectArrayElement(a1, a2, ElementType);
    goto LABEL_24;
  }
  if (Kind)
    goto LABEL_15;
  PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType);
  Category = glpPrimitiveTypeGetCategory(PrimitiveType);
  if (Category == 3)
  {
    v13 = glpIndirectMatrixColumn(a1, a2, PrimitiveType);
    goto LABEL_24;
  }
  if (Category != 2)
  {
LABEL_15:
    Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
    glpTypeHumanReadableDescription((uint64_t)SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
    v23 = v22;
    v24 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v36);
    glpLogMessage(v24, 0, (uint64_t)&v36, "Can't access array element of type '%.*s'", v25, v26, v27, v28, v23);
    return glpSAFailed();
  }
  v13 = glpIndirectVectorElement(a1, a2, PrimitiveType);
LABEL_24:
  v8 = v13;
  return glpCheckIBDeref(a1, v8);
}

uint64_t glpSAFieldAccess(uint64_t a1, uint64_t a2)
{
  uint64_t Structure;
  uint64_t v5;
  uint64_t v6;

  Structure = glpFieldAccessNodeGetStructure(a2);
  v5 = glpSANode(a1, Structure);
  if (v5 == -1)
    return glpSAFailed();
  glpFieldAccessNodeSetStructure(a2, v5);
  v6 = glpSAFieldAccessInternal(a1, a2);
  return glpCheckIBDeref(a1, v6);
}

uint64_t glpSAUndeterminedCall(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  int Kind;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t NameTable;
  uint64_t Allocator;
  uint64_t Field;
  uint64_t v13;
  uint64_t v14;
  uint64_t Structure;
  int v16;
  int v17;
  unsigned int i;
  _QWORD *v19;
  uint64_t v20;
  uint64_t Array;
  uint64_t v22;
  uint64_t Name;
  uint64_t v24;
  uint64_t Element;
  int v26;
  int v27;
  unsigned int j;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t SaType;
  _QWORD *v35;
  char v36;
  char v37;
  uint64_t **v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t **InfoLog;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  int v50;
  uint64_t **v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t **v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  int v65;
  unsigned int k;
  _QWORD *v67;
  uint64_t v68;
  char v69;
  __n128 v70;
  __n128 v71;
  __n128 v72;
  __n128 v73;
  __n128 v74;
  __n128 v75;
  __n128 v76;
  _QWORD v77[8];
  uint64_t v78;
  uint64_t *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t *v83;
  uint64_t v84;
  int v85;

  v2 = a2;
  if (glpSACall(a1, a2) == -1)
    return glpSAFailed();
  v4 = glpUndeterminedCallNodeGetCallee(v2);
  Kind = glpASTNodeGetKind(v4);
  switch(Kind)
  {
    case 5:
      Allocator = glpCompilerGetAllocator(a1);
      glpASTNodeGetLocation(v2, &v73);
      Field = glpFieldAccessNodeGetField(v4);
      v14 = glpMakeMethodCallNode(Allocator, &v73, Field, v13);
      Structure = glpFieldAccessNodeGetStructure(v4);
      glpMethodCallNodeSetReceiver(v14, Structure);
      v16 = glpCallNodeGetArgCount(v2);
      if (v16)
      {
        v17 = v16;
        for (i = 0; i != v17; ++i)
        {
          v19 = (_QWORD *)glpCompilerGetAllocator(a1);
          v20 = glpCallNodeGetArg(v2, i);
          glpCallNodeAddArg(v19, v14, v20);
        }
      }
      break;
    case 4:
      Array = glpArrayAccessNodeGetArray(v4);
      if (!glpIsVariableIdentifierNode(Array))
      {
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v4, &v71);
        glpLogMessage(InfoLog, 0, (uint64_t)&v71, "Call of element of non-subroutine-uniform array", v44, v45, v46, v47, v69);
        return glpSAFailed();
      }
      v22 = glpCompilerGetAllocator(a1);
      glpASTNodeGetLocation(v2, &v72);
      Name = glpVariableIdentifierNodeGetName(Array);
      v14 = glpMakeSubroutineArrayCallNode(v22, &v72, Name, v24);
      Element = glpArrayAccessNodeGetElement(v4);
      glpSubroutineArrayCallNodeSetIndexExpr(v14, Element);
      v26 = glpCallNodeGetArgCount(v2);
      if (v26)
      {
        v27 = v26;
        for (j = 0; j != v27; ++j)
        {
          v29 = (_QWORD *)glpCompilerGetAllocator(a1);
          v30 = glpCallNodeGetArg(v2, j);
          glpCallNodeAddArg(v29, v14, v30);
        }
      }
      break;
    case 1:
      v6 = (char *)glpVariableIdentifierNodeGetName(v4);
      v8 = v7;
      NameTable = glpCompilerGetNameTable(a1);
      if (glpNameTableIsExtensionEnabled(NameTable, 0x24u) && glpStringsEqual("$assert", 0x75B16CFF00000007, v6, v8))
        return glpSASpecialAssert(a1, v2);
      if (glpStringsEqual("$ppstreamop", 0xF8DF7DAF0000000BLL, v6, v8))
        return glpSABuiltinPPStreamOp(a1, v2);
      v48 = glpCompilerGetNameTable(a1);
      v82 = 0;
      v83 = &v82;
      v84 = 0x2000000000;
      v85 = 0;
      v78 = 0;
      v79 = &v78;
      v80 = 0x2000000000;
      v81 = 0;
      v77[0] = MEMORY[0x24BDAC760];
      v77[1] = 0x40000000;
      v77[2] = __glpSAUndeterminedCall_block_invoke;
      v77[3] = &unk_24F4B31E0;
      v77[4] = &v82;
      v77[5] = &v78;
      v77[6] = v48;
      v77[7] = a1;
      glpNameTableGet(v48, v6, v8, 0, (uint64_t)v77);
      if (v79[3])
      {
        v49 = *((_DWORD *)v83 + 6);
        if (v49 > 0xD)
        {
LABEL_33:
          _Block_object_dispose(&v78, 8);
          _Block_object_dispose(&v82, 8);
          return v2;
        }
        v50 = 1 << v49;
        if ((v50 & 0x10F) == 0)
        {
          if ((v50 & 0x90) == 0)
            abort();
          v62 = glpCompilerGetAllocator(a1);
          glpASTNodeGetLocation(v2, &v76);
          v63 = glpMakeFunctionCallNode(v62, &v76, (uint64_t)v6, v8);
          v64 = glpCallNodeGetArgCount(v2);
          if (v64)
          {
            v65 = v64;
            for (k = 0; k != v65; ++k)
            {
              v67 = (_QWORD *)glpCompilerGetAllocator(a1);
              v68 = glpCallNodeGetArg(v2, k);
              glpCallNodeAddArg(v67, v63, v68);
            }
          }
          v61 = glpSANode(a1, v63);
          goto LABEL_32;
        }
        v51 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v4, &v75);
        glpLogMessage(v51, 0, (uint64_t)&v75, "Invalid call of '%.*s' (not a function or subroutine uniform)", v52, v53, v54, v55, v8);
      }
      else
      {
        v56 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v4, &v74);
        glpLogMessage(v56, 0, (uint64_t)&v74, "Invalid call of undeclared identifier '%.*s'", v57, v58, v59, v60, v8);
      }
      v61 = glpSAFailed();
LABEL_32:
      v2 = v61;
      goto LABEL_33;
    default:
      v32 = glpSANode(a1, v4);
      if (v32 != -1)
      {
        v33 = v32;
        SaType = glpASTNodeGetSaType(v32);
        v35 = (_QWORD *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription(SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v35);
        v37 = v36;
        v38 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v33, &v70);
        glpLogMessage(v38, 0, (uint64_t)&v70, "'%.*s' is not callable", v39, v40, v41, v42, v37);
        return glpSAFailed();
      }
      return glpSAFailed();
  }
  return glpSANode(a1, v14);
}

uint64_t glpSAFunctionCall(uint64_t a1, uint64_t a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  size_t v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t Allocator;
  uint64_t v19;
  uint64_t v20;
  __n128 v21;
  __n128 v22;
  uint64_t v23[2];

  v23[1] = *MEMORY[0x24BDAC8D0];
  if (glpSACall(a1, a2) == -1)
    return glpSAFailed();
  v4 = (char *)glpFunctionCallNodeGetName(a2);
  v6 = v5;
  v7 = glpCallNodeGetArgCount(a2);
  MEMORY[0x24BDAC7A8](v7);
  v10 = (uint64_t *)((char *)&v21 - v9);
  if (v8 >= 0x200)
    v11 = 512;
  else
    v11 = v8;
  bzero((char *)&v21 - v9, v11);
  v12 = glpMakeExpectedSignatureFromCall(a1, a2, (uint64_t)v10);
  v23[0] = 0;
  if (!glpLookUpAndAnalyzeCall(a1, a2, v4, v6, v12, v10, (uint64_t)v23))
    return glpSAFailed();
  v13 = (_QWORD *)glpFunctionCallNodeGetExtra(a2);
  v14 = glpCalculateCallPrecision(a1, a2, v13);
  if (!glpHandleArgumentConversions(a1, a2, (uint64_t)v13, v14))
    return glpSAFailed();
  v15 = v13[1];
  if ((v15 & 0x4000) != 0)
    return glpLowerCallToBodilessPPStreamOp(a1, a2, (uint64_t)v13);
  if ((v15 & 0x10000) != 0)
    return glpHandleSpecialOperatorFunction(a1, a2, (uint64_t)v13);
  if ((v15 & 0x2000) != 0 && v13[8])
    return glpInlineFunction(a1, a2, (uint64_t)v13, v14);
  v17 = v23[0];
  Allocator = glpCompilerGetAllocator(a1);
  if (v17)
  {
    glpASTNodeGetLocation(a2, &v22);
    glpMakeSubroutineRawCallNode(Allocator, &v22, v23[0]);
  }
  else
  {
    glpASTNodeGetLocation(a2, &v21);
    v20 = glpFunctionCallNodeGetExtra(a2);
    glpMakeRawCallNode(Allocator, &v21, (uint64_t)v4, v6, v20);
  }
  return glpSALowerCallArgsToAssignment(a1, a2, (uint64_t)v13, v19);
}

uint64_t glpSASubroutineArrayCall(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t NameTable;
  uint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  unsigned int ElementCount;
  uint64_t v14;
  uint64_t v15;
  uint64_t ElementType;
  uint64_t *FunctionObject;
  uint64_t ReturnType;
  unint64_t v19;
  uint64_t Allocator;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t **InfoLog;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t **v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t **v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  __n128 v41;
  __n128 v42;
  __n128 v43;
  unsigned int v44;
  __n128 v45;
  __n128 v46;
  _QWORD v47[6];
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  int v55;

  if (glpSACall(a1, a2) == -1)
    return glpSAFailed();
  v4 = glpSubroutineArrayCallNodeGetIndexExpr(a2);
  v5 = glpSANode(a1, v4);
  if (v5 == -1)
    return glpSAFailed();
  glpSubroutineArrayCallNodeSetIndexExpr(a2, v5);
  v6 = (char *)glpSubroutineArrayCallNodeGetName(a2);
  v8 = v7;
  NameTable = glpCompilerGetNameTable(a1);
  v52 = 0;
  v53 = &v52;
  v54 = 0x2000000000;
  v55 = 0;
  v48 = 0;
  v49 = &v48;
  v50 = 0x2000000000;
  v51 = 0;
  v47[0] = MEMORY[0x24BDAC760];
  v47[1] = 0x40000000;
  v47[2] = __glpSASubroutineArrayCall_block_invoke;
  v47[3] = &unk_24F4B3208;
  v47[4] = &v52;
  v47[5] = &v48;
  glpNameTableGet(NameTable, v6, v8, 0, (uint64_t)v47);
  v10 = v49[3];
  if (!v10 || *((_DWORD *)v53 + 6) != 7)
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v46);
    glpLogMessage(InfoLog, 0, (uint64_t)&v46, "'%.*s' does not name a subroutine uniform", v26, v27, v28, v29, v8);
    goto LABEL_12;
  }
  v11 = *(unsigned int **)(v10 + 16);
  if (glpTypeGetKind(v11) != 2)
  {
    v31 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v45);
    glpLogMessage(v31, 0, (uint64_t)&v45, "'%.*s' does not name a subroutine array", v32, v33, v34, v35, v8);
    goto LABEL_12;
  }
  v12 = glpSubroutineArrayCallNodeGetIndexExpr(a2);
  v44 = 0;
  glpASTNodeGetLocation(v12, &v43);
  ElementCount = glpArrayTypeGetElementCount((uint64_t)v11);
  v14 = glpCheckArrayIndex(a1, (__int128 *)&v43, v12, 0, 0, ElementCount, &v44);
  if (v14 == -1)
    goto LABEL_12;
  v15 = v14;
  ElementType = glpArrayTypeGetElementType((uint64_t)v11);
  FunctionObject = (uint64_t *)glpSubroutineTypeGetFunctionObject(ElementType);
  if (!glpAnalyzeCallToSubroutineArray(a1, FunctionObject, a2))
  {
    glpSubroutineTypeGetName(ElementType);
    v36 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v42);
    glpLogMessage(v36, 0, (uint64_t)&v42, "Arguments of call to subroutine uniform array '%.*s' cannot be converted to match its element type ('%.*s')", v37, v38, v39, v40, *(_DWORD *)(v10 + 8));
    goto LABEL_12;
  }
  ReturnType = glpFunctionTypeGetReturnType(*FunctionObject);
  glpASTNodeSetSaType(a2, ReturnType);
  v19 = glpCalculateCallPrecision(a1, a2, FunctionObject);
  if (!glpHandleArgumentConversions(a1, a2, (uint64_t)FunctionObject, v19))
  {
LABEL_12:
    v23 = glpSAFailed();
    goto LABEL_13;
  }
  Allocator = glpCompilerGetAllocator(a1);
  glpASTNodeGetLocation(a2, &v41);
  glpMakeSubroutineRawCallNode(Allocator, &v41, v10);
  v22 = v21;
  glpSubroutineRawCallNodeSetIndexExpr(v21, v15);
  v23 = glpSALowerCallArgsToAssignment(a1, a2, (uint64_t)FunctionObject, v22);
LABEL_13:
  v30 = v23;
  _Block_object_dispose(&v48, 8);
  _Block_object_dispose(&v52, 8);
  return v30;
}

uint64_t glpSAMethodCall(uint64_t a1, uint64_t a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t NameTable;
  uint64_t **InfoLog;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v16;
  uint64_t v17;
  char *Name;
  uint64_t v19;
  uint64_t v20;
  unsigned int *PrimitiveType;
  uint64_t Allocator;
  uint64_t ElementCount;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *MutableValue;
  uint64_t v30;
  uint64_t ConstantValueFragment;
  int v32;
  uint64_t **v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t **v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int *SaType;
  unsigned int *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t **v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t **v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t **v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char v80;
  uint64_t v81;
  __n128 v82;
  uint64_t v83;
  _QWORD v84[6];
  uint64_t v85;
  uint64_t *v86;
  uint64_t v87;
  uint64_t v88;
  __n128 v89;
  uint64_t v90;
  int v91;
  __n128 v92;
  uint64_t v93;

  if (glpSACall(a1, a2) == -1)
    return glpSAFailed();
  v92 = 0uLL;
  v93 = 0;
  glpASTNodeGetLocation(a2, &v92);
  v4 = (char *)glpMethodCallNodeGetName(a2);
  v6 = v5;
  NameTable = glpCompilerGetNameTable(a1);
  if (glpNameTableGetGLSLVersion(NameTable) < 2)
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    v89 = v92;
    v90 = v93;
    v13 = "Method calls not allowed in this GLSL version";
LABEL_9:
    glpLogMessage(InfoLog, 0, (uint64_t)&v89, v13, v9, v10, v11, v12, v80);
    return glpSAFailed();
  }
  if (!glpStringsEqual("length", 0x9836E88D00000006, v4, v6))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    v89 = v92;
    v90 = v93;
    v80 = v6;
    v13 = "Call of unknown method '%.*s'";
    goto LABEL_9;
  }
  if (glpCallNodeGetArgCount(a2))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    v89 = v92;
    v90 = v93;
    v13 = ".length() method takes no arguments";
    goto LABEL_9;
  }
  v16 = glpMethodCallNodeGetReceiver(a2);
  if (glpIsVariableIdentifierNode(v16))
  {
    v89.n128_u64[0] = 0;
    v89.n128_u64[1] = (unint64_t)&v89;
    v90 = 0x2000000000;
    v91 = 0;
    v85 = 0;
    v86 = &v85;
    v87 = 0x2000000000;
    v88 = 0;
    v17 = glpCompilerGetNameTable(a1);
    Name = (char *)glpVariableIdentifierNodeGetName(v16);
    v84[0] = MEMORY[0x24BDAC760];
    v84[1] = 0x40000000;
    v84[2] = __glpSAMethodCall_block_invoke;
    v84[3] = &unk_24F4B3230;
    v84[4] = &v89;
    v84[5] = &v85;
    glpNameTableGet(v17, Name, v19, 0, (uint64_t)v84);
    v20 = v86[3];
    if (!v20 || *(_DWORD *)(v89.n128_u64[1] + 24) != 1)
    {
      v32 = 1;
      goto LABEL_24;
    }
    if (glpTypeGetKind(*(unsigned int **)(v20 + 64)) == 3)
    {
      if (glpBankTypeGetElementCount(*(_QWORD *)(v20 + 64)) != -1)
      {
        PrimitiveType = (unsigned int *)glpGetPrimitiveType(5u);
        Allocator = glpCompilerGetAllocator(a1);
        ElementCount = glpBankTypeGetElementCount(*(_QWORD *)(v20 + 64));
        MutableValue = glpMakeMutableValue(Allocator, PrimitiveType, 1, v24, v25, v26, v27, v28, ElementCount);
        v30 = glpCompilerRemapValue(a1, PrimitiveType, MutableValue);
        v82 = v92;
        v83 = v93;
        ConstantValueFragment = glpMakeConstantValueFragment(a1, &v82, (uint64_t)PrimitiveType, v30);
LABEL_23:
        v16 = ConstantValueFragment;
        v32 = 0;
LABEL_24:
        _Block_object_dispose(&v85, 8);
        _Block_object_dispose(&v89, 8);
        if (!v32)
          return v16;
        goto LABEL_25;
      }
      v38 = (uint64_t **)glpCompilerGetInfoLog(a1);
      v82 = v92;
      v83 = v93;
      glpLogMessage(v38, 0, (uint64_t)&v82, "Call to method '%.*s' of unsized interface block", v39, v40, v41, v42, v6);
    }
    else
    {
      v33 = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpVariableIdentifierNodeGetName(v16);
      glpVariableIdentifierNodeGetName(v16);
      v82 = v92;
      v83 = v93;
      glpLogMessage(v33, 0, (uint64_t)&v82, "Call to method '%.*s' of non-array interface block '%.*s'", v34, v35, v36, v37, v6);
    }
    ConstantValueFragment = glpSAFailed();
    goto LABEL_23;
  }
LABEL_25:
  v43 = glpMethodCallNodeGetReceiver(a2);
  v44 = glpSANode(a1, v43);
  if (v44 != -1)
  {
    glpMethodCallNodeSetReceiver(a2, v44);
    v45 = glpMethodCallNodeGetReceiver(a2);
    SaType = (unsigned int *)glpASTNodeGetSaType(v45);
    if (glpTypeGetKind(SaType) == 2)
    {
      if (glpArrayTypeGetElementCount((uint64_t)SaType) == -1)
      {
        v70 = (uint64_t **)glpCompilerGetInfoLog(a1);
        v89 = v92;
        v90 = v93;
        glpLogMessage(v70, 0, (uint64_t)&v89, "Call to method '%.*s' of unsized array", v71, v72, v73, v74, v6);
        return glpSAFailed();
      }
      v47 = (unsigned int *)glpGetPrimitiveType(5u);
      v48 = glpCompilerGetAllocator(a1);
      v81 = glpArrayTypeGetElementCount((uint64_t)SaType);
      v54 = glpMakeMutableValue(v48, v47, 1, v49, v50, v51, v52, v53, v81);
    }
    else
    {
      if (glpTypeGetKind(SaType) != 3)
      {
        v64 = (_QWORD *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription((uint64_t)SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v64);
        v65 = (uint64_t **)glpCompilerGetInfoLog(a1);
        v89 = v92;
        v90 = v93;
        glpLogMessage(v65, 0, (uint64_t)&v89, "Call to method '%.*s' of non-array type '%.*s'", v66, v67, v68, v69, v6);
        return glpSAFailed();
      }
      v55 = glpBankTypeGetElementCount((uint64_t)SaType);
      if ((_DWORD)v55 == -1)
      {
        v75 = (uint64_t **)glpCompilerGetInfoLog(a1);
        v89 = v92;
        v90 = v93;
        glpLogMessage(v75, 0, (uint64_t)&v89, "Call to method '%.*s' of unsized interface block array", v76, v77, v78, v79, v6);
        return glpSAFailed();
      }
      v56 = v55;
      v47 = (unsigned int *)glpGetPrimitiveType(5u);
      v57 = glpCompilerGetAllocator(a1);
      v54 = glpMakeMutableValue(v57, v47, 1, v58, v59, v60, v61, v62, v56);
    }
    v63 = glpCompilerRemapValue(a1, v47, v54);
    v89 = v92;
    v90 = v93;
    return glpMakeConstantValueFragment(a1, &v89, (uint64_t)v47, v63);
  }
  return glpSAFailed();
}

uint64_t glpSAConstructorCall(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  if (glpSACall(a1, a2) == -1)
    return glpSAFailed();
  v4 = glpConstructorCallNodeGetType(a2);
  v5 = glpSANode(a1, v4);
  if (v5 == -1)
    return glpSAFailed();
  glpConstructorCallNodeSetType(a2, v5);
  result = glpCheckAndSanitizeConstructorCall(a1, a2);
  if (result == -1)
    return glpSAFailed();
  return result;
}

uint64_t glpSAPostincrement(uint64_t a1, uint64_t a2)
{
  if (glpSAIncrementOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpSAPostIncrementOrDecrement(a1, a2, 1);
}

uint64_t glpSAPostdecrement(uint64_t a1, uint64_t a2)
{
  if (glpSAIncrementOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpSAPostIncrementOrDecrement(a1, a2, 0);
}

uint64_t glpSAPreincrement(uint64_t a1, uint64_t a2)
{
  if (glpSAIncrementOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpSAPreIncrementOrDecrement(a1, a2, 1);
}

uint64_t glpSAPredecrement(uint64_t a1, uint64_t a2)
{
  if (glpSAIncrementOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpSAPreIncrementOrDecrement(a1, a2, 0);
}

uint64_t glpSAUnaryPlus(uint64_t a1, uint64_t a2)
{
  if (glpSAUnaryOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpAnalyzeUnaryMathOp(a1, a2);
}

uint64_t glpSANegate(uint64_t a1, uint64_t a2)
{
  if (glpSAUnaryOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpAnalyzeUnaryMathOp(a1, a2);
}

uint64_t glpSALogicalNot(uint64_t a1, uint64_t a2)
{
  if (glpSAUnaryOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpAnalyzeUnaryMathOp(a1, a2);
}

uint64_t glpSABitwiseNot(uint64_t a1, uint64_t a2)
{
  if (glpSAUnaryOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpAnalyzeUnaryMathOp(a1, a2);
}

uint64_t glpSAMultiply(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpAnalyzeBinaryMathOp(a1, a2);
}

uint64_t glpSADivide(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpAnalyzeBinaryMathOp(a1, a2);
}

uint64_t glpSAModulo(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpAnalyzeBinaryMathOp(a1, a2);
}

uint64_t glpSAAdd(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpAnalyzeBinaryMathOp(a1, a2);
}

uint64_t glpSASubtract(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpAnalyzeBinaryMathOp(a1, a2);
}

uint64_t glpSAShiftLeft(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpAnalyzeBinaryMathOp(a1, a2);
}

uint64_t glpSAShiftRight(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpAnalyzeBinaryMathOp(a1, a2);
}

uint64_t glpSALess(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  char *PrimitiveType;
  uint64_t SaFlags;

  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  v4 = glpAnalyzeBinaryMathOp(a1, a2);
  if (v4 == -1)
    return glpSAFailed();
  v5 = v4;
  PrimitiveType = glpGetPrimitiveType(9u);
  glpASTNodeSetSaType(v5, (uint64_t)PrimitiveType);
  if (glpCompilerDoesTrackPrecision(a1))
  {
    SaFlags = glpASTNodeGetSaFlags(v5);
    glpASTNodeSetSaFlags(v5, SaFlags & 0xFFFFFFFFFFFFFFE0);
  }
  return v5;
}

uint64_t glpSALessEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  char *PrimitiveType;
  uint64_t SaFlags;

  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  v4 = glpAnalyzeBinaryMathOp(a1, a2);
  if (v4 == -1)
    return glpSAFailed();
  v5 = v4;
  PrimitiveType = glpGetPrimitiveType(9u);
  glpASTNodeSetSaType(v5, (uint64_t)PrimitiveType);
  if (glpCompilerDoesTrackPrecision(a1))
  {
    SaFlags = glpASTNodeGetSaFlags(v5);
    glpASTNodeSetSaFlags(v5, SaFlags & 0xFFFFFFFFFFFFFFE0);
  }
  return v5;
}

uint64_t glpSAGreater(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  char *PrimitiveType;
  uint64_t SaFlags;

  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  v4 = glpAnalyzeBinaryMathOp(a1, a2);
  if (v4 == -1)
    return glpSAFailed();
  v5 = v4;
  PrimitiveType = glpGetPrimitiveType(9u);
  glpASTNodeSetSaType(v5, (uint64_t)PrimitiveType);
  if (glpCompilerDoesTrackPrecision(a1))
  {
    SaFlags = glpASTNodeGetSaFlags(v5);
    glpASTNodeSetSaFlags(v5, SaFlags & 0xFFFFFFFFFFFFFFE0);
  }
  return v5;
}

uint64_t glpSAGreaterEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  char *PrimitiveType;
  uint64_t SaFlags;

  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  v4 = glpAnalyzeBinaryMathOp(a1, a2);
  if (v4 == -1)
    return glpSAFailed();
  v5 = v4;
  PrimitiveType = glpGetPrimitiveType(9u);
  glpASTNodeSetSaType(v5, (uint64_t)PrimitiveType);
  if (glpCompilerDoesTrackPrecision(a1))
  {
    SaFlags = glpASTNodeGetSaFlags(v5);
    glpASTNodeSetSaFlags(v5, SaFlags & 0xFFFFFFFFFFFFFFE0);
  }
  return v5;
}

uint64_t glpSAEqual(uint64_t a1, uint64_t a2)
{
  uint64_t Lhs;
  uint64_t Rhs;
  unsigned int *SaType;
  unsigned int *v7;
  uint64_t NameTable;
  uint64_t **InfoLog;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  __n128 *v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t Allocator;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  int AccessorCount;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t Accessor;
  uint64_t v28;
  uint64_t EqualFragment;
  uint64_t v30;
  uint64_t v31;
  char *PrimitiveType;
  _QWORD *v34;
  uint64_t SaFlags;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __n128 v40;
  uint64_t v41;
  __n128 v42;
  uint64_t v43;
  __n128 v44;
  __n128 v45;

  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  Lhs = glpBinaryOperatorNodeGetLhs(a2);
  Rhs = glpBinaryOperatorNodeGetRhs(a2);
  SaType = (unsigned int *)glpASTNodeGetSaType(Lhs);
  if (!glpTypeGetKind(SaType))
  {
    v30 = glpAnalyzeBinaryMathOp(a1, a2);
    if (v30 != -1)
    {
      v31 = v30;
      PrimitiveType = glpGetPrimitiveType(9u);
      glpASTNodeSetSaType(v31, (uint64_t)PrimitiveType);
      goto LABEL_25;
    }
    return glpSAFailed();
  }
  if (!glpEqualNodeGetIsFromSource(a2)
    || (v7 = (unsigned int *)glpASTNodeGetSaType(Lhs), glpTypeGetKind(v7) != 2)
    || (NameTable = glpCompilerGetNameTable(a1), glpNameTableGetGLSLVersion(NameTable) > 1))
  {
    v16 = (unsigned int *)glpASTNodeGetSaType(Lhs);
    v17 = glpASTNodeGetSaType(Rhs);
    if (!glpTypesEqual(v16, v17))
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a2, &v44);
      v14 = "Incompatible types in '=='";
      v15 = &v44;
      goto LABEL_22;
    }
    v42 = 0uLL;
    v43 = 0;
    glpASTNodeGetLocation(a2, &v42);
    Allocator = glpCompilerGetAllocator(a1);
    v40 = v42;
    v41 = v43;
    glpMakeCommaExprNode(Allocator, &v40, 0);
    v20 = v19;
    v38 = 0;
    v39 = 0;
    glpHandleSideEffectsForExpr(a1, Lhs, &v39, &v38);
    if (v38)
    {
      v21 = (_QWORD *)glpCompilerGetAllocator(a1);
      glpCommaExprNodeAddExpr(v21, v20, v38);
      v38 = 0;
    }
    v36 = 0;
    v37 = 0;
    glpHandleSideEffectsForExpr(a1, Rhs, &v37, &v36);
    if (v36)
    {
      v22 = (_QWORD *)glpCompilerGetAllocator(a1);
      glpCommaExprNodeAddExpr(v22, v20, v36);
      v36 = 0;
    }
    AccessorCount = glpGetAccessorCount(v39);
    if (AccessorCount)
    {
      v24 = AccessorCount;
      v25 = 0;
      v26 = 0;
      do
      {
        Accessor = glpMakeAccessor(a1, v39, v25);
        v28 = glpMakeAccessor(a1, v37, v25);
        v40 = v42;
        v41 = v43;
        EqualFragment = glpMakeEqualFragment(a1, &v40, Accessor, v28);
        if (v26)
        {
          v40 = v42;
          v41 = v43;
          EqualFragment = glpMakeLogicalAndFragment(a1, &v40, v26, EqualFragment);
        }
        v25 = (v25 + 1);
        v26 = EqualFragment;
      }
      while (v24 != (_DWORD)v25);
    }
    else
    {
      EqualFragment = 0;
    }
    v34 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v34, v20, EqualFragment);
    v31 = glpSANode(a1, v20);
LABEL_25:
    if (glpCompilerDoesTrackPrecision(a1))
    {
      SaFlags = glpASTNodeGetSaFlags(v31);
      glpASTNodeSetSaFlags(v31, SaFlags & 0xFFFFFFFFFFFFFFE0);
    }
    return v31;
  }
  InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
  glpASTNodeGetLocation(a2, &v45);
  v14 = "'==' disallowed on array types";
  v15 = &v45;
LABEL_22:
  glpLogMessage(InfoLog, 0, (uint64_t)v15, v14, v10, v11, v12, v13, v36);
  return glpSAFailed();
}

uint64_t glpSANotEqual(uint64_t a1, uint64_t a2)
{
  uint64_t Lhs;
  uint64_t Rhs;
  unsigned int *SaType;
  unsigned int *v7;
  uint64_t NameTable;
  uint64_t **InfoLog;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  __n128 *v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t Allocator;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  int AccessorCount;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t Accessor;
  uint64_t v28;
  uint64_t NotEqualFragment;
  uint64_t v30;
  uint64_t v31;
  char *PrimitiveType;
  _QWORD *v34;
  uint64_t SaFlags;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __n128 v40;
  uint64_t v41;
  __n128 v42;
  uint64_t v43;
  __n128 v44;
  __n128 v45;

  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  Lhs = glpBinaryOperatorNodeGetLhs(a2);
  Rhs = glpBinaryOperatorNodeGetRhs(a2);
  SaType = (unsigned int *)glpASTNodeGetSaType(Lhs);
  if (!glpTypeGetKind(SaType))
  {
    v30 = glpAnalyzeBinaryMathOp(a1, a2);
    if (v30 != -1)
    {
      v31 = v30;
      PrimitiveType = glpGetPrimitiveType(9u);
      glpASTNodeSetSaType(v31, (uint64_t)PrimitiveType);
      goto LABEL_25;
    }
    return glpSAFailed();
  }
  if (!glpNotEqualNodeGetIsFromSource(a2)
    || (v7 = (unsigned int *)glpASTNodeGetSaType(Lhs), glpTypeGetKind(v7) != 2)
    || (NameTable = glpCompilerGetNameTable(a1), glpNameTableGetGLSLVersion(NameTable) > 1))
  {
    v16 = (unsigned int *)glpASTNodeGetSaType(Lhs);
    v17 = glpASTNodeGetSaType(Rhs);
    if (!glpTypesEqual(v16, v17))
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a2, &v44);
      v14 = "Incompatible types in '!='";
      v15 = &v44;
      goto LABEL_22;
    }
    v42 = 0uLL;
    v43 = 0;
    glpASTNodeGetLocation(a2, &v42);
    Allocator = glpCompilerGetAllocator(a1);
    v40 = v42;
    v41 = v43;
    glpMakeCommaExprNode(Allocator, &v40, 0);
    v20 = v19;
    v38 = 0;
    v39 = 0;
    glpHandleSideEffectsForExpr(a1, Lhs, &v39, &v38);
    if (v38)
    {
      v21 = (_QWORD *)glpCompilerGetAllocator(a1);
      glpCommaExprNodeAddExpr(v21, v20, v38);
      v38 = 0;
    }
    v36 = 0;
    v37 = 0;
    glpHandleSideEffectsForExpr(a1, Rhs, &v37, &v36);
    if (v36)
    {
      v22 = (_QWORD *)glpCompilerGetAllocator(a1);
      glpCommaExprNodeAddExpr(v22, v20, v36);
      v36 = 0;
    }
    AccessorCount = glpGetAccessorCount(v39);
    if (AccessorCount)
    {
      v24 = AccessorCount;
      v25 = 0;
      v26 = 0;
      do
      {
        Accessor = glpMakeAccessor(a1, v39, v25);
        v28 = glpMakeAccessor(a1, v37, v25);
        v40 = v42;
        v41 = v43;
        NotEqualFragment = glpMakeNotEqualFragment(a1, &v40, Accessor, v28);
        if (v26)
        {
          v40 = v42;
          v41 = v43;
          NotEqualFragment = glpMakeLogicalOrFragment(a1, &v40, v26, NotEqualFragment);
        }
        v25 = (v25 + 1);
        v26 = NotEqualFragment;
      }
      while (v24 != (_DWORD)v25);
    }
    else
    {
      NotEqualFragment = 0;
    }
    v34 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v34, v20, NotEqualFragment);
    v31 = glpSANode(a1, v20);
LABEL_25:
    if (glpCompilerDoesTrackPrecision(a1))
    {
      SaFlags = glpASTNodeGetSaFlags(v31);
      glpASTNodeSetSaFlags(v31, SaFlags & 0xFFFFFFFFFFFFFFE0);
    }
    return v31;
  }
  InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
  glpASTNodeGetLocation(a2, &v45);
  v14 = "'!=' disallowed on array types";
  v15 = &v45;
LABEL_22:
  glpLogMessage(InfoLog, 0, (uint64_t)v15, v14, v10, v11, v12, v13, v36);
  return glpSAFailed();
}

uint64_t glpSALogicalAnd(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *SaType;
  char *PrimitiveType;
  uint64_t **InfoLog;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v14;
  __n128 v15;

  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  v4 = glpAnalyzeBinaryMathOp(a1, a2);
  if (v4 == -1)
    return glpSAFailed();
  v5 = v4;
  SaType = (unsigned int *)glpASTNodeGetSaType(v4);
  PrimitiveType = glpGetPrimitiveType(9u);
  if (!glpTypesEqual(SaType, (uint64_t)PrimitiveType))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v5, &v15);
    glpLogMessage(InfoLog, 0, (uint64_t)&v15, "logical operator must be of type BOOL", v9, v10, v11, v12, v14);
    return glpSAFailed();
  }
  return v5;
}

uint64_t glpSALogicalOr(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *SaType;
  char *PrimitiveType;
  uint64_t **InfoLog;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v14;
  __n128 v15;

  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  v4 = glpAnalyzeBinaryMathOp(a1, a2);
  if (v4 == -1)
    return glpSAFailed();
  v5 = v4;
  SaType = (unsigned int *)glpASTNodeGetSaType(v4);
  PrimitiveType = glpGetPrimitiveType(9u);
  if (!glpTypesEqual(SaType, (uint64_t)PrimitiveType))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v5, &v15);
    glpLogMessage(InfoLog, 0, (uint64_t)&v15, "logical operator must be of type BOOL", v9, v10, v11, v12, v14);
    return glpSAFailed();
  }
  return v5;
}

uint64_t glpSALogicalXor(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *SaType;
  char *PrimitiveType;
  uint64_t **InfoLog;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v14;
  __n128 v15;

  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  v4 = glpAnalyzeBinaryMathOp(a1, a2);
  if (v4 == -1)
    return glpSAFailed();
  v5 = v4;
  SaType = (unsigned int *)glpASTNodeGetSaType(v4);
  PrimitiveType = glpGetPrimitiveType(9u);
  if (!glpTypesEqual(SaType, (uint64_t)PrimitiveType))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v5, &v15);
    glpLogMessage(InfoLog, 0, (uint64_t)&v15, "logical operator must be of type BOOL", v9, v10, v11, v12, v14);
    return glpSAFailed();
  }
  return v5;
}

uint64_t glpSABitwiseAnd(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpAnalyzeBinaryMathOp(a1, a2);
}

uint64_t glpSABitwiseOr(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpAnalyzeBinaryMathOp(a1, a2);
}

uint64_t glpSABitwiseXor(uint64_t a1, uint64_t a2)
{
  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  else
    return glpAnalyzeBinaryMathOp(a1, a2);
}

uint64_t glpSAIfExpr(uint64_t a1, uint64_t a2)
{
  uint64_t Condition;
  uint64_t v5;
  int v6;
  uint64_t IfExpr;
  uint64_t v8;
  uint64_t ElseExpr;
  uint64_t v10;
  uint64_t v11;
  unsigned int *SaType;
  char *PrimitiveType;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t Allocator;
  uint64_t ValueHash;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t **InfoLog;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  __n128 *v32;
  uint64_t IfExprFragment;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t SaFlags;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int ImplicitConversionPolicy;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t **v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char v60;
  unsigned int v61;
  __n128 v62;
  __n128 v63;
  __n128 v64;
  __n128 v65;
  __n128 v66;

  Condition = glpIfExprNodeGetCondition(a2);
  v5 = glpSANode(a1, Condition);
  if (v5 == -1)
  {
    v6 = 0;
  }
  else
  {
    glpIfExprNodeSetCondition(a2, v5);
    v6 = 1;
  }
  IfExpr = glpIfExprNodeGetIfExpr(a2);
  v8 = glpSANode(a1, IfExpr);
  if (v8 == -1)
    v6 = 0;
  else
    glpIfExprNodeSetIfExpr(a2, v8);
  ElseExpr = glpIfExprNodeGetElseExpr(a2);
  v10 = glpSANode(a1, ElseExpr);
  if (v10 == -1)
    return glpSAFailed();
  glpIfExprNodeSetElseExpr(a2, v10);
  if (!v6)
    return glpSAFailed();
  v11 = glpIfExprNodeGetCondition(a2);
  SaType = (unsigned int *)glpASTNodeGetSaType(v11);
  PrimitiveType = glpGetPrimitiveType(9u);
  if (!glpTypesEqual(SaType, (uint64_t)PrimitiveType))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v66);
    v31 = "Condition must be of type BOOL";
    v32 = &v66;
LABEL_23:
    glpLogMessage(InfoLog, 0, (uint64_t)v32, v31, v27, v28, v29, v30, v60);
    return glpSAFailed();
  }
  v14 = glpIfExprNodeGetIfExpr(a2);
  v15 = glpIfExprNodeGetElseExpr(a2);
  v16 = (unsigned int *)glpASTNodeGetSaType(v14);
  v17 = (unsigned int *)glpASTNodeGetSaType(v15);
  v18 = glpASTNodeGetSaFlags(v14) & 0x1F;
  v19 = glpASTNodeGetSaFlags(v15) & 0x1F;
  if (glpTypesEqual(v16, (uint64_t)v17))
    goto LABEL_11;
  if (glpTypeGetKind(v16) || glpTypeGetKind(v17))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v64);
    v31 = "Types in conditional operator do not match";
    v32 = &v64;
    goto LABEL_23;
  }
  ImplicitConversionPolicy = glpCompilerGetImplicitConversionPolicy(a1);
  v50 = glpPrimitiveTypeGetPrimitiveType((uint64_t)v16);
  v51 = glpPrimitiveTypeGetPrimitiveType((uint64_t)v17);
  v61 = v51;
  if (glpCanConvert(v51, v50, ImplicitConversionPolicy))
  {
    v52 = glpConvert(a1, v15, (uint64_t)v16, v18);
    glpIfExprNodeSetElseExpr(a2, v52);
  }
  else
  {
    if (!glpCanConvert(v50, v61, ImplicitConversionPolicy))
    {
      v54 = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a2, &v65);
      v55 = glpPrimitiveTypeToString(v50);
      glpPrimitiveTypeToString(v61);
      glpLogMessage(v54, 0, (uint64_t)&v65, "Types '%s' and '%s' in conditional operator do not match (and no applicable implicit type conversion)", v56, v57, v58, v59, v55);
      return glpSAFailed();
    }
    v53 = glpConvert(a1, v14, (uint64_t)v17, v19);
    glpIfExprNodeSetIfExpr(a2, v53);
  }
LABEL_11:
  if (v18 != v19)
  {
    if (v18 != 31 && v18)
    {
      if (v18 <= v19)
      {
        v14 = glpConvert(a1, v14, (uint64_t)v16, v19);
        glpIfExprNodeSetIfExpr(a2, v14);
      }
      else
      {
        v15 = glpConvert(a1, v15, (uint64_t)v17, v18);
        glpIfExprNodeSetElseExpr(a2, v15);
      }
    }
    else
    {
      glpPushdownPrecision(a1, v14, v19);
    }
  }
  Allocator = glpCompilerGetAllocator(a1);
  ValueHash = glpCompilerGetValueHash(a1);
  v22 = glpIfExprNodeGetCondition(a2);
  v23 = glpConstantFold(Allocator, ValueHash, v22);
  if (!glpIsConstantNode(v23))
  {
    v34 = glpCompilerGetAllocator(a1);
    glpASTNodeGetLocation(a2, &v63);
    glpMakeTypeIdentifierNode(v34, &v63, (uint64_t)"<<BUG: placeholder type still exists>>", 0x781A7BE300000026);
    v36 = v35;
    v37 = glpIfExprNodeGetIfExpr(a2);
    v38 = glpASTNodeGetSaType(v37);
    glpASTNodeSetSaType(v36, v38);
    glpASTNodeSetSaFlags(v36, v18);
    v39 = glpIfExprNodeGetCondition(a2);
    v40 = glpASTNodeGetSaFlags(v39) | 0x1F;
    SaFlags = glpASTNodeGetSaFlags(v14);
    v42 = v40 & SaFlags & glpASTNodeGetSaFlags(v15);
    glpASTNodeGetLocation(a2, &v62);
    v43 = glpCompilerNewTempName(a1);
    v45 = v44;
    v46 = glpIfExprNodeGetCondition(a2);
    v47 = glpIfExprNodeGetIfExpr(a2);
    v48 = glpIfExprNodeGetElseExpr(a2);
    IfExprFragment = glpMakeIfExprFragment(a1, &v62, (uint64_t)v43, v45, v36, v46, v47, v48);
    glpASTNodeSetSaFlags(v36, v42);
    return IfExprFragment;
  }
  if (*(_DWORD *)glpConstantNodeGetValue(v23))
    v24 = glpIfExprNodeGetIfExpr(a2);
  else
    v24 = glpIfExprNodeGetElseExpr(a2);
  return glpSANode(a1, v24);
}

uint64_t glpSAAssign(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t Lhs;
  uint64_t Rhs;
  uint64_t **InfoLog;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  __n128 *v12;
  uint64_t SaType;
  unsigned int *v15;
  unsigned int *v16;
  unsigned int *v17;
  unsigned int *v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  _DWORD *v22;
  unsigned int *v23;
  unsigned int *v24;
  unsigned int *v25;
  uint64_t v26;
  _QWORD *Allocator;
  char v28;
  char v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t **v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  uint64_t Offset;
  unsigned int Swizzle;
  uint64_t v40;
  _DWORD *v41;
  uint64_t VariableExtra;
  uint64_t v43;
  uint64_t v44;
  uint64_t OffsetExpr;
  uint64_t v46;
  unsigned int *v47;
  uint64_t NameTable;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  int AccessorCount;
  int v55;
  uint64_t v56;
  _QWORD *v57;
  uint64_t Accessor;
  uint64_t v59;
  uint64_t AssignFragment;
  _QWORD *v61;
  uint64_t Expr;
  int ExprCount;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char v67;
  uint64_t v68;
  uint64_t PrimitiveType;
  uint64_t v70;
  uint64_t v71;
  unsigned int ImplicitConversionPolicy;
  uint64_t v73;
  char SaFlags;
  uint64_t v75;
  _QWORD *v76;
  char v77;
  char v78;
  uint64_t v79;
  _QWORD *v80;
  uint64_t **v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  char v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  __n128 v91;
  uint64_t v92;
  __n128 v93;
  uint64_t v94;
  __n128 v95;
  __n128 v96;
  __n128 v97;
  __n128 v98;
  __n128 v99;
  __n128 v100;
  __n128 v101;
  __n128 v102;
  __n128 v103;

  v2 = a2;
  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  Lhs = glpBinaryOperatorNodeGetLhs(v2);
  Rhs = glpBinaryOperatorNodeGetRhs(v2);
  if (!glpIsLValueNode(Lhs))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v103);
    v11 = "Left-hand-side of assignment must be an lvalue";
    v12 = &v103;
    goto LABEL_9;
  }
  if ((glpASTNodeGetSaFlags(Lhs) & 0x60) == 0)
  {
    if ((glpASTNodeGetSaFlags(Lhs) & 0x300) != 0)
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v2, &v101);
      v11 = "Left-hand-side of assignment must not be read-only";
      v12 = &v101;
      goto LABEL_9;
    }
    if (glpAssignNodeGetIsFromSource(v2))
    {
      SaType = glpASTNodeGetSaType(Lhs);
      if (glpTypeGetSamplerCount(SaType))
      {
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v100);
        v11 = "Cannot assign samplers";
        v12 = &v100;
        goto LABEL_9;
      }
    }
    v15 = (unsigned int *)glpASTNodeGetSaType(Lhs);
    if (glpTypeGetKind(v15) != 1)
    {
      v16 = (unsigned int *)glpASTNodeGetSaType(Lhs);
      if (glpTypeGetKind(v16) != 2)
      {
        v17 = (unsigned int *)glpASTNodeGetSaType(Lhs);
        if (glpTypeGetKind(v17))
        {
          InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(v2, &v99);
          v11 = "You can't assign non-struct non-primitives directly.";
          v12 = &v99;
          goto LABEL_9;
        }
      }
    }
    v18 = (unsigned int *)glpASTNodeGetSaType(Lhs);
    v19 = glpASTNodeGetSaType(Rhs);
    if (!glpTypesEqual(v18, v19))
    {
      v24 = (unsigned int *)glpASTNodeGetSaType(Lhs);
      if (glpTypeGetKind(v24)
        || (v25 = (unsigned int *)glpASTNodeGetSaType(Rhs), glpTypeGetKind(v25)))
      {
        v26 = glpASTNodeGetSaType(Lhs);
        Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription(v26, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
        v29 = v28;
        v30 = glpASTNodeGetSaType(Rhs);
        v31 = (_QWORD *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription(v30, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v31);
        v32 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v97);
        glpLogMessage(v32, 0, (uint64_t)&v97, "Incompatible types (%.*s and %.*s) in assignment", v33, v34, v35, v36, v29);
        return glpSAFailed();
      }
      v68 = glpASTNodeGetSaType(Lhs);
      PrimitiveType = glpPrimitiveTypeGetPrimitiveType(v68);
      v70 = glpASTNodeGetSaType(Rhs);
      v71 = glpPrimitiveTypeGetPrimitiveType(v70);
      ImplicitConversionPolicy = glpCompilerGetImplicitConversionPolicy(a1);
      LODWORD(v71) = glpCanConvert(v71, PrimitiveType, ImplicitConversionPolicy);
      v73 = glpASTNodeGetSaType(Lhs);
      if (!(_DWORD)v71)
      {
        v76 = (_QWORD *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription(v73, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v76);
        v78 = v77;
        v79 = glpASTNodeGetSaType(Rhs);
        v80 = (_QWORD *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription(v79, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v80);
        v81 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v98);
        glpLogMessage(v81, 0, (uint64_t)&v98, "Incompatible types (%.*s and %.*s) in assignment (and no available implicit conversion)", v82, v83, v84, v85, v78);
        return glpSAFailed();
      }
      SaFlags = glpASTNodeGetSaFlags(Lhs);
      v75 = glpConvert(a1, Rhs, v73, SaFlags & 0x1F);
      glpBinaryOperatorNodeSetRhs(v2, v75);
    }
    v20 = glpASTNodeGetSaFlags(Rhs) & 0x1F;
    v21 = (_DWORD *)glpASTNodeGetSaType(Lhs);
    if (glpTypeIsAtomic(v21) && (glpASTNodeGetSaFlags(Lhs) & 0x1F) != v20)
    {
      if (v20 != 31 && v20)
      {
        if ((glpASTNodeGetSaFlags(Lhs) & 0x1F) != 0)
        {
          v66 = glpASTNodeGetSaType(Lhs);
          v67 = glpASTNodeGetSaFlags(Lhs);
          Rhs = glpConvert(a1, Rhs, v66, v67 & 0x1F);
          glpBinaryOperatorNodeSetRhs(v2, Rhs);
        }
        else
        {
          glpASTNodeGetSaFlags(Rhs);
        }
LABEL_32:
        if (glpDerefNodeGetOffset(Lhs))
        {
          Offset = glpDerefNodeGetOffset(Lhs);
          Swizzle = glpOffsetNodeGetSwizzle(Offset);
          if (glpSwizzleHasDuplicateComponents(Swizzle))
          {
            InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(v2, &v96);
            v11 = "Destination swizzle may not have duplicate components";
            v12 = &v96;
            goto LABEL_9;
          }
        }
        v40 = glpASTNodeGetSaType(Lhs);
        glpASTNodeSetSaType(v2, v40);
        v41 = (_DWORD *)glpASTNodeGetSaType(Lhs);
        if (glpTypeIsAtomic(v41))
        {
          if (!*(_QWORD *)(glpLValueNodeGetVariableExtra(Lhs) + 8)
            || (VariableExtra = glpLValueNodeGetVariableExtra(Lhs),
                !glpLayoutObjectFind(*(uint64_t **)(VariableExtra + 8), 29)))
          {
LABEL_52:
            if (glpIsBinaryOperatorNode(v2))
            {
              Expr = glpBinaryOperatorNodeGetLhs(v2);
            }
            else
            {
              if (!glpIsCommaExprNode(v2))
              {
                v65 = v2;
                v64 = 0;
                goto LABEL_57;
              }
              ExprCount = glpCommaExprNodeGetExprCount(v2);
              Expr = glpCommaExprNodeGetExpr(v2, ExprCount - 1);
            }
            v64 = glpASTNodeGetSaFlags(Expr) & 0x1F;
            v65 = v2;
LABEL_57:
            glpASTNodeSetSaFlags(v65, v64);
            return v2;
          }
          v43 = glpASTNodeGetSaType(Lhs);
          v44 = glpDerefNodeGetOffset(Lhs);
          OffsetExpr = glpOffsetNodeGetOffsetExpr(v44);
          v46 = glpHandleGetterSetter(a1, Lhs, v43, OffsetExpr, Rhs, (uint64_t)"setter", 0x7663306B00000006, 0);
        }
        else
        {
          if (glpAssignNodeGetIsFromSource(v2))
          {
            v47 = (unsigned int *)glpASTNodeGetSaType(Lhs);
            if (glpTypeGetKind(v47) == 2)
            {
              NameTable = glpCompilerGetNameTable(a1);
              if (glpNameTableGetGLSLVersion(NameTable) <= 1)
              {
                InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
                glpASTNodeGetLocation(v2, &v95);
                v11 = "'=' disallowed on array types";
                v12 = &v95;
                goto LABEL_9;
              }
            }
          }
          v93 = 0uLL;
          v94 = 0;
          glpASTNodeGetLocation(v2, &v93);
          v49 = glpCompilerGetAllocator(a1);
          v91 = v93;
          v92 = v94;
          glpMakeCommaExprNode(v49, &v91, 0);
          v51 = v50;
          v89 = 0;
          v90 = 0;
          glpHandleSideEffectsForExpr(a1, Lhs, &v90, &v89);
          if (v89)
          {
            v52 = (_QWORD *)glpCompilerGetAllocator(a1);
            glpCommaExprNodeAddExpr(v52, v51, v89);
            v89 = 0;
          }
          v87 = 0;
          v88 = 0;
          glpHandleSideEffectsForExpr(a1, Rhs, &v88, &v87);
          if (v87)
          {
            v53 = (_QWORD *)glpCompilerGetAllocator(a1);
            glpCommaExprNodeAddExpr(v53, v51, v87);
            v87 = 0;
          }
          AccessorCount = glpGetAccessorCount(v90);
          if (AccessorCount)
          {
            v55 = AccessorCount;
            v56 = 0;
            do
            {
              v57 = (_QWORD *)glpCompilerGetAllocator(a1);
              Accessor = glpMakeAccessor(a1, v90, v56);
              v59 = glpMakeAccessor(a1, v88, v56);
              v91 = v93;
              v92 = v94;
              AssignFragment = glpMakeAssignFragment(a1, &v91, Accessor, v59);
              glpCommaExprNodeAddExpr(v57, v51, AssignFragment);
              v56 = (v56 + 1);
            }
            while (v55 != (_DWORD)v56);
          }
          v61 = (_QWORD *)glpCompilerGetAllocator(a1);
          glpCommaExprNodeAddExpr(v61, v51, v90);
          v46 = glpSANode(a1, v51);
        }
        v2 = v46;
        goto LABEL_52;
      }
    }
    else
    {
      v22 = (_DWORD *)glpASTNodeGetSaType(Lhs);
      if (glpTypeIsAtomic(v22))
        goto LABEL_32;
      if (v20)
        goto LABEL_32;
      v23 = (unsigned int *)glpASTNodeGetSaType(Lhs);
      if (!glpCompilerDoesTypeRequirePrecision(a1, v23))
        goto LABEL_32;
    }
    v37 = glpASTNodeGetSaFlags(Lhs);
    glpPushdownPrecision(a1, Rhs, v37);
    goto LABEL_32;
  }
  InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
  glpASTNodeGetLocation(v2, &v102);
  v11 = "Left-hand-side of assignment must not be const";
  v12 = &v102;
LABEL_9:
  glpLogMessage(InfoLog, 0, (uint64_t)v12, v11, v7, v8, v9, v10, v86);
  return glpSAFailed();
}

uint64_t glpSAOpAssign(uint64_t a1, uint64_t a2)
{
  uint64_t Lhs;
  uint64_t Rhs;
  unsigned int *SaType;
  char SaFlags;
  uint64_t (*Desugar)(uint64_t, __n128 *, __n128);
  uint64_t Allocator;
  __n128 Location;
  uint64_t v11;
  uint64_t v12;
  uint64_t AssignNode;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  int ExprCount;
  int v21;
  unsigned int v22;
  uint64_t Expr;
  _QWORD *v24;
  _QWORD *v26;
  _QWORD *v27;
  __n128 v28;
  __n128 v29;
  __n128 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  if (glpSABinaryOperator(a1, a2) == -1)
    return glpSAFailed();
  Lhs = glpBinaryOperatorNodeGetLhs(a2);
  Rhs = glpBinaryOperatorNodeGetRhs(a2);
  SaType = (unsigned int *)glpASTNodeGetSaType(Lhs);
  if (glpCompilerDoesTypeRequirePrecision(a1, SaType) && (glpASTNodeGetSaFlags(Rhs) & 0x1F) == 0)
  {
    SaFlags = glpASTNodeGetSaFlags(Lhs);
    glpPushdownPrecision(a1, Rhs, SaFlags);
  }
  v33 = 0;
  v34 = 0;
  glpHandleSideEffectsForExpr(a1, Lhs, &v34, &v33);
  v31 = 0;
  v32 = 0;
  glpHandleSideEffectsForExpr(a1, Rhs, &v32, &v31);
  Desugar = (uint64_t (*)(uint64_t, __n128 *, __n128))glpOpAssignNodeGetDesugar(a2);
  Allocator = glpCompilerGetAllocator(a1);
  Location = glpASTNodeGetLocation(a2, &v30);
  v11 = Desugar(Allocator, &v30, Location);
  glpBinaryOperatorNodeSetLhs(v11, v34);
  glpBinaryOperatorNodeSetRhs(v11, v32);
  v12 = glpCompilerGetAllocator(a1);
  glpASTNodeGetLocation(a2, &v29);
  AssignNode = glpMakeAssignNode(v12, &v29, 0);
  v14 = glpDuplicateDerefOrConstant(a1, v34);
  glpBinaryOperatorNodeSetLhs(AssignNode, v14);
  glpBinaryOperatorNodeSetRhs(AssignNode, v11);
  if (v31 && glpIsCommaExprNode(v31))
  {
    v15 = glpCommaExprNodeGetExprCount(v31) - 1;
    glpCommaExprNodeSetExpr(v31, v15, 0);
    v16 = v31;
    glpASTNodeSetSaType(v31, 0);
  }
  else
  {
    v17 = glpCompilerGetAllocator(a1);
    glpASTNodeGetLocation(a2, &v28);
    glpMakeCommaExprNode(v17, &v28, 0);
    v16 = v18;
    if (v31)
    {
      v19 = (_QWORD *)glpCompilerGetAllocator(a1);
      glpCommaExprNodeAddExpr(v19, v16, v31);
    }
    v15 = -1;
  }
  if (v33)
  {
    if (glpIsCommaExprNode(v33))
    {
      ExprCount = glpCommaExprNodeGetExprCount(v33);
      v21 = ExprCount - 1;
      if (ExprCount != 1)
      {
        v22 = 0;
        do
        {
          Expr = glpCommaExprNodeGetExpr(v33, v22);
          if ((v15 & 0x80000000) != 0)
          {
            v24 = (_QWORD *)glpCompilerGetAllocator(a1);
            glpCommaExprNodeAddExpr(v24, v16, Expr);
          }
          else
          {
            glpCommaExprNodeSetExpr(v16, v15, Expr);
            v15 = -1;
          }
          glpCommaExprNodeSetExpr(v33, v22++, 0);
        }
        while (v21 != v22);
      }
      glpASTNodeSetSaType(v16, 0);
    }
    else if (v33)
    {
      if ((v15 & 0x80000000) != 0)
      {
        v26 = (_QWORD *)glpCompilerGetAllocator(a1);
        glpCommaExprNodeAddExpr(v26, v16, v33);
      }
      else
      {
        glpCommaExprNodeSetExpr(v16, v15, v33);
      }
      goto LABEL_27;
    }
  }
  if ((v15 & 0x80000000) != 0)
  {
LABEL_27:
    v27 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v27, v16, AssignNode);
    return glpSANode(a1, v16);
  }
  glpCommaExprNodeSetExpr(v16, v15, AssignNode);
  return glpSANode(a1, v16);
}

void glpSAReadInput()
{
  abort();
}

void glpSAWriteOutput()
{
  abort();
}

uint64_t glpSACommaExpr(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v4;
  int v5;
  uint64_t Expr;
  uint64_t v7;
  int ExprCount;
  uint64_t v9;
  uint64_t SaType;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int *v16;
  uint64_t DefaultPrecisionForType;
  int v18;
  uint64_t v19;
  char SaFlags;
  uint64_t v22;
  _QWORD *Allocator;
  char v24;
  char v25;
  uint64_t **InfoLog;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  __n128 v31;

  v2 = a2;
  if (glpCommaExprNodeGetExprCount(a2))
  {
    v4 = 0;
    v5 = 1;
    do
    {
      Expr = glpCommaExprNodeGetExpr(v2, v4);
      v7 = glpSANode(a1, Expr);
      if (v7 == -1)
        v5 = 0;
      else
        glpCommaExprNodeSetExpr(v2, v4, v7);
      ++v4;
    }
    while (v4 < glpCommaExprNodeGetExprCount(v2));
    if (!v5)
      return glpSAFailed();
  }
  ExprCount = glpCommaExprNodeGetExprCount(v2);
  v9 = glpCommaExprNodeGetExpr(v2, ExprCount - 1);
  SaType = glpASTNodeGetSaType(v9);
  glpASTNodeSetSaType(v2, SaType);
  if (glpCommaExprNodeGetExprCount(v2))
  {
    v11 = 0;
    v12 = 96;
    while (1)
    {
      v13 = glpCommaExprNodeGetExpr(v2, v11);
      if (v13)
      {
        v14 = v13;
        v12 &= glpASTNodeGetSaFlags(v13);
        if (glpCommaExprNodeGetIsFromSource(v2))
        {
          if (v11 != glpCommaExprNodeGetExprCount(v2) - 1)
          {
            v15 = (unsigned int *)glpASTNodeGetSaType(v14);
            if (glpCompilerDoesTypeRequirePrecision(a1, v15) && (glpASTNodeGetSaFlags(v14) & 0x1F) == 0)
            {
              v16 = (unsigned int *)glpASTNodeGetSaType(v14);
              DefaultPrecisionForType = glpGetDefaultPrecisionForType(a1, v16);
              if (!DefaultPrecisionForType)
              {
                v22 = glpASTNodeGetSaType(v14);
                Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
                glpTypeHumanReadableDescription(v22, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
                v25 = v24;
                InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
                glpASTNodeGetLocation(v2, &v31);
                glpLogMessage(InfoLog, 0, (uint64_t)&v31, "Expression of type '%.*s' - precision can not be inferred and no default precision available", v27, v28, v29, v30, v25);
                return glpSAFailed();
              }
              glpPushdownPrecision(a1, v14, DefaultPrecisionForType);
            }
          }
        }
      }
      if (++v11 >= glpCommaExprNodeGetExprCount(v2))
        goto LABEL_20;
    }
  }
  v12 = 96;
LABEL_20:
  v18 = glpCommaExprNodeGetExprCount(v2);
  v19 = glpCommaExprNodeGetExpr(v2, v18 - 1);
  SaFlags = glpASTNodeGetSaFlags(v19);
  glpASTNodeSetSaFlags(v2, SaFlags & 0x1F | (unint64_t)v12);
  return v2;
}

uint64_t glpSAParameterDeclaration(uint64_t a1, uint64_t a2)
{
  uint64_t Type;
  uint64_t v5;
  uint64_t v6;
  uint64_t **InfoLog;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *Name;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t SaType;
  _QWORD *v17;
  uint64_t v18;
  int v19;
  uint64_t Allocator;
  uint64_t **v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  __n128 v28;
  __n128 v29;
  __n128 v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  unsigned int *v34;

  Type = glpParameterDeclarationNodeGetType(a2);
  v5 = glpSANode(a1, Type);
  if (v5 == -1)
    return glpSAFailed();
  glpParameterDeclarationNodeSetType(a2, v5);
  v6 = glpParameterDeclarationNodeGetType(a2);
  v33 = 0;
  v34 = 0;
  v31 = 0;
  v32 = 0;
  glpASTNodeGetLocation(a2, &v30);
  if (glpEvaluateTypeNode(a1, (__int128 *)&v30, 5u, 1, v6, 0, &v34, (uint64_t)&v33, &v32, &v31))
  {
    if (glpCompilerUsingStyleGuide(a1) && !glpTypeIsAtomic(v34))
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a2, &v29);
      glpLogMessage(InfoLog, 2u, (uint64_t)&v29, "Passing large objects to functions may result in significant unnecessary copying", v8, v9, v10, v11, v27);
    }
    Name = (const char *)glpParameterDeclarationNodeGetName(a2);
    v14 = glpCheckName(a1, a2, Name, v13);
    if (v14 != -1)
    {
      v15 = v14;
      if (glpTypeGetKind(v34) != 2 || glpArrayTypeGetElementCount((uint64_t)v34) != -1)
      {
        SaType = glpASTNodeGetSaType(v6);
        glpASTNodeSetSaType(v15, SaType);
        if (v32)
        {
          v17 = (_QWORD *)*v32;
          if (*v32)
          {
            v18 = v33;
            while (1)
            {
              v19 = *((_DWORD *)v17 + 2);
              v17 = (_QWORD *)*v17;
              if (v19 == 99)
                break;
              if (v19 == 98)
              {
                v18 |= 0x800100uLL;
LABEL_16:
                v33 = v18;
              }
              if (!v17)
                goto LABEL_18;
            }
            v18 |= 0x1000000uLL;
            goto LABEL_16;
          }
LABEL_18:
          Allocator = glpCompilerGetAllocator(a1);
          glpDestroyLayoutObject(Allocator, (_QWORD **)v32);
          v32 = 0;
        }
        glpASTNodeSetSaFlags(v15, v33 | 0x400000);
        glpParameterDeclarationNodeSetType(v15, 0);
        return v15;
      }
      v22 = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v15, &v28);
      glpLogMessage(v22, 0, (uint64_t)&v28, "Unsized arrays are not allowed as parameter or return types.", v23, v24, v25, v26, v27);
    }
  }
  return glpSAFailed();
}

uint64_t glpSAFunctionPrototype(_QWORD *a1, uint64_t a2)
{
  uint64_t Parameter;
  uint64_t Type;
  uint64_t ReturnType;
  uint64_t v7;
  int v8;
  uint64_t ReturnOutParam;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  char *Name;
  uint64_t v15;
  uint64_t v16;
  uint64_t ImmediateSAContext;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t **v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  __n128 *v27;
  uint64_t **InfoLog;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t NameTable;
  uint64_t ParameterCount;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  char *v41;
  size_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  size_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  _QWORD *Allocator;
  unsigned int *v52;
  unsigned int v53;
  uint64_t FunctionType;
  uint64_t v55;
  _QWORD *v56;
  int v57;
  _QWORD *v58;
  int v59;
  uint64_t v60;
  _QWORD *v61;
  char *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t FunctionObject;
  _BOOL4 v68;
  unsigned int *SubroutineType;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  _BOOL4 IsFunctionDefinitionNode;
  uint64_t **v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t *v81;
  uint64_t v82;
  _QWORD *v83;
  char *v84;
  uint64_t v85;
  int v86;
  uint64_t **v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  char v92;
  uint64_t **v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t **v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t **v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t **v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t **v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t **v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  unsigned int **v127;
  unsigned int **v128;
  unsigned int *v129;
  uint64_t **v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  _QWORD *v135;
  int v136;
  uint64_t **v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  unsigned int *v142;
  uint64_t v143;
  uint64_t **v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t **v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t **v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t Extra;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  _QWORD *v168;
  uint64_t *StringBuffer;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  unsigned int *v173;
  uint64_t SaFlags;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t String;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  unint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t SaType;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t **v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  char v207[4];
  _BOOL4 v208;
  char *v209;
  uint64_t v210;
  uint64_t v211;
  __n128 v212;
  __n128 v213;
  __n128 v214;
  __n128 v215;
  __n128 v216;
  __n128 v217;
  __n128 v218;
  __n128 v219;
  __n128 v220;
  __n128 v221;
  __n128 v222;
  __n128 v223;
  _QWORD v224[5];
  uint64_t v225;
  uint64_t *v226;
  uint64_t v227;
  uint64_t v228;
  _QWORD v229[6];
  uint64_t v230;
  uint64_t *v231;
  uint64_t v232;
  int v233;
  uint64_t v234;
  uint64_t *v235;
  uint64_t v236;
  uint64_t v237;
  _QWORD v238[8];
  uint64_t v239;
  uint64_t *v240;
  uint64_t v241;
  int v242;
  __n128 v243;
  __n128 v244;
  __n128 v245;
  _QWORD v246[6];
  uint64_t v247;
  uint64_t *v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t *v252;
  uint64_t v253;
  int v254;
  __n128 v255;
  __n128 v256;
  __n128 v257;
  uint64_t v258;
  uint64_t *v259;
  uint64_t v260;
  unsigned int *v261;
  __n128 v262;
  uint64_t v263;

  v263 = *MEMORY[0x24BDAC8D0];
  if (glpFunctionPrototypeNodeGetParameterCount(a2) == 1)
  {
    Parameter = glpFunctionPrototypeNodeGetParameter(a2, 0);
    Type = glpParameterDeclarationNodeGetType(Parameter);
    if (glpIsPrimitiveTypeNode(Type) && !glpPrimitiveTypeNodeGetType(Type))
      glpFunctionPrototypeNodeClearParameters(a2);
  }
  ReturnType = glpFunctionPrototypeNodeGetReturnType(a2);
  v7 = glpSANode(a1, ReturnType);
  if (v7 == -1)
  {
    v8 = 0;
  }
  else
  {
    glpFunctionPrototypeNodeSetReturnType(a2, v7);
    v8 = 1;
  }
  ReturnOutParam = glpFunctionPrototypeNodeGetReturnOutParam(a2);
  v10 = glpSANode(a1, ReturnOutParam);
  if (v10 == -1)
    v8 = 0;
  else
    glpFunctionPrototypeNodeSetReturnOutParam(a2, v10);
  if (glpFunctionPrototypeNodeGetParameterCount(a2))
  {
    v11 = 0;
    do
    {
      v12 = glpFunctionPrototypeNodeGetParameter(a2, v11);
      v13 = glpSANode(a1, v12);
      if (v13 == -1)
        v8 = 0;
      else
        glpFunctionPrototypeNodeSetParameter(a2, v11, v13);
      ++v11;
    }
    while (v11 < glpFunctionPrototypeNodeGetParameterCount(a2));
  }
  if (!v8)
    return glpSAFailed();
  Name = (char *)glpFunctionPrototypeNodeGetName(a2);
  v16 = v15;
  ImmediateSAContext = glpCompilerGetImmediateSAContext((uint64_t)a1);
  if (!glpIsTopLevelNode(ImmediateSAContext) && !glpIsFunctionDefinitionNode(ImmediateSAContext))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
    glpASTNodeGetLocation(a2, &v262);
    glpLogMessage(InfoLog, 0, (uint64_t)&v262, "Prototype for function '%.*s' must occur at the top level", v30, v31, v32, v33, v16);
    return glpSAFailed();
  }
  v18 = glpFunctionPrototypeNodeGetReturnType(a2);
  v260 = 0;
  v261 = 0;
  v258 = 0;
  v259 = 0;
  glpASTNodeGetLocation(a2, &v257);
  if (!glpEvaluateTypeNode((uint64_t)a1, (__int128 *)&v257, 4u, 1, v18, 0, &v261, (uint64_t)&v260, &v259, &v258))return glpSAFailed();
  v19 = glpCheckName((uint64_t)a1, a2, Name, v16);
  if (v19 == -1)
    return glpSAFailed();
  v20 = v19;
  if (!glpStringsEqual("main", 0x83863A00000004, Name, v16))
    goto LABEL_33;
  if (!glpTypeGetKind(v261) && !glpPrimitiveTypeGetPrimitiveType((uint64_t)v261))
  {
    if (glpFunctionPrototypeNodeGetParameterCount(v20))
    {
      v21 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
      glpASTNodeGetLocation(v20, &v255);
      v26 = "main() may not take any arguments";
      v27 = &v255;
      goto LABEL_26;
    }
LABEL_33:
    ParameterCount = glpFunctionPrototypeNodeGetParameterCount(v20);
    v209 = v207;
    MEMORY[0x24BDAC7A8](ParameterCount);
    v37 = &v207[-v36];
    v38 = glpFunctionPrototypeNodeGetParameterCount(v20);
    MEMORY[0x24BDAC7A8](v38);
    v41 = &v207[-v40];
    v211 = v20;
    if (v39 >= 0x200)
      v42 = 512;
    else
      v42 = v39;
    bzero(&v207[-v40], v42);
    v43 = glpFunctionPrototypeNodeGetParameterCount(v211);
    MEMORY[0x24BDAC7A8](v43);
    v46 = &v207[-v45];
    if (v44 >= 0x200)
      v47 = 512;
    else
      v47 = v44;
    v48 = v211;
    bzero(&v207[-v45], v47);
    if (glpFunctionPrototypeNodeGetParameterCount(v48))
    {
      v49 = 0;
      do
      {
        v50 = glpFunctionPrototypeNodeGetParameter(v48, v49);
        *(_QWORD *)&v37[8 * v49] = glpASTNodeGetSaFlags(v50);
        *(_QWORD *)&v41[8 * v49] = glpASTNodeGetSaType(v50);
        *(_QWORD *)&v46[8 * v49++] = 0;
      }
      while (v49 < glpFunctionPrototypeNodeGetParameterCount(v48));
    }
    Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
    v52 = v261;
    v53 = glpFunctionPrototypeNodeGetParameterCount(v48);
    FunctionType = glpMakeFunctionType(Allocator, (uint64_t)v52, v53, (uint64_t)v41, (uint64_t)v37, (uint64_t)v46);
    glpASTNodeSetSaType(v48, FunctionType);
    v55 = v260;
    if (v259)
    {
      v56 = (_QWORD *)*v259;
      if (*v259)
      {
        v57 = 0;
        while (1)
        {
          v58 = v56;
          v56 = (_QWORD *)*v56;
          v59 = *((_DWORD *)v58 + 2);
          switch(v59)
          {
            case '[':
              v55 |= 0x2000uLL;
              if (v56)
                continue;
              goto LABEL_66;
            case '\\':
              v55 |= 0x1000uLL;
              if (v56)
                continue;
              goto LABEL_66;
            case ']':
              v55 |= 0x800uLL;
              if (v56)
                continue;
              goto LABEL_66;
            case '^':
              v55 |= 0x8000uLL;
              if (v56)
                continue;
              goto LABEL_66;
            case '_':
              v55 |= 0x10000uLL;
              if (v56)
                continue;
              goto LABEL_66;
              v55 |= 0x20000uLL;
              goto LABEL_60;
            case 'a':
              v55 |= 0x40000uLL;
              if (v56)
                continue;
              goto LABEL_66;
            default:
              if (v59 == 32)
              {
                v55 |= 0x4000uLL;
                v57 = *((_DWORD *)v58 + 4);
                if (!v56)
                  goto LABEL_66;
              }
              else
              {
LABEL_60:
                if (!v56)
                  goto LABEL_66;
              }
              break;
          }
        }
      }
      v57 = 0;
LABEL_66:
      v60 = glpCompilerGetAllocator(a1);
      glpDestroyLayoutObject(v60, (_QWORD **)v259);
      v259 = 0;
    }
    else
    {
      v57 = 0;
    }
    NameTable = glpCompilerGetNameTable((uint64_t)a1);
    v61 = (_QWORD *)glpCompilerGetAllocator(a1);
    v62 = (char *)glpAggregateTypeMangleName(FunctionType, (uint64_t)Name, v16, v61);
    v64 = v63;
    v65 = glpCompilerGetAllocator(a1);
    v210 = FunctionType;
    glpMakeFunctionObject(v65, FunctionType, v55, (uint64_t)Name, v16, (uint64_t)v62, v64);
    FunctionObject = v66;
    *(_DWORD *)(v66 + 92) = v57;
    if (v258)
      v68 = (v55 & 0x180000) != 0;
    else
      v68 = 0;
    if ((v55 & 0x180000) != 0 && !v68)
    {
      *(_QWORD *)(v66 + 8) &= ~0x100000uLL;
      SubroutineType = (unsigned int *)glpCompilerGetSubroutineType(a1, *(const char **)(v66 + 24), *(_QWORD *)(v66 + 32), (uint64_t *)v66);
      v251 = 0;
      v252 = &v251;
      v253 = 0x2000000000;
      v254 = 0;
      v247 = 0;
      v248 = &v247;
      v249 = 0x2000000000;
      v250 = 0;
      v246[0] = MEMORY[0x24BDAC760];
      v246[1] = 0x40000000;
      v246[2] = __glpSAFunctionPrototype_block_invoke;
      v246[3] = &unk_24F4B3258;
      v246[4] = &v251;
      v246[5] = &v247;
      glpNameTableGet(NameTable, *(char **)(FunctionObject + 24), *(_QWORD *)(FunctionObject + 32), 2, (uint64_t)v246);
      v70 = v248[3];
      if (v70)
      {
        v71 = v211;
        if (*((_DWORD *)v252 + 6) == 8)
        {
          if (glpTypesEqual(SubroutineType, v70))
          {
            SubroutineType = (unsigned int *)v248[3];
LABEL_90:
            FunctionObject = glpSubroutineTypeGetFunctionObject((uint64_t)SubroutineType);
            v210 = *(_QWORD *)FunctionObject;
            v92 = 1;
            goto LABEL_95;
          }
          v103 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
          glpASTNodeGetLocation(v71, &v245);
          glpLogMessage(v103, 0, (uint64_t)&v245, "Redeclaration of subroutine type '%.*s' does not match previous declaration", v104, v105, v106, v107, *(_DWORD *)(FunctionObject + 32));
        }
        else
        {
          v93 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
          glpASTNodeGetLocation(v71, &v244);
          glpLogMessage(v93, 0, (uint64_t)&v244, "subroutine type '%.*s' previously declared as another kind of object", v94, v95, v96, v97, *(_DWORD *)(FunctionObject + 32));
        }
        NameTable = glpSAFailed();
        v92 = 0;
LABEL_95:
        _Block_object_dispose(&v247, 8);
        _Block_object_dispose(&v251, 8);
        if ((v92 & 1) == 0)
          return NameTable;
        goto LABEL_131;
      }
      glpNameTablePut(NameTable, Name, v16, 8, (uint64_t)SubroutineType);
      goto LABEL_90;
    }
    v72 = glpCompilerGetImmediateSAContext((uint64_t)a1);
    IsFunctionDefinitionNode = glpIsFunctionDefinitionNode(v72);
    if (!IsFunctionDefinitionNode && v68)
    {
      v75 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
      glpASTNodeGetLocation(v211, &v243);
      glpLogMessage(v75, 0, (uint64_t)&v243, "Subroutine type declaration '%.*s' may not include a list of compatible subroutine types", v76, v77, v78, v79, v16);
      return glpSAFailed();
    }
    v208 = IsFunctionDefinitionNode;
    *(_QWORD *)(FunctionObject + 8) &= ~0x80000uLL;
    *(_QWORD *)(FunctionObject + 56) = v258;
    v251 = 0;
    v252 = &v251;
    v253 = 0x2000000000;
    v254 = 0;
    v247 = 0;
    v248 = &v247;
    v249 = 0x2000000000;
    v250 = 0;
    v239 = 0;
    v240 = &v239;
    v241 = 0x2000000000;
    v242 = 0;
    v80 = MEMORY[0x24BDAC760];
    v238[0] = MEMORY[0x24BDAC760];
    v238[1] = 0x40000000;
    v238[2] = __glpSAFunctionPrototype_block_invoke_2;
    v238[3] = &unk_24F4B3280;
    v238[4] = &v251;
    v238[5] = &v247;
    v238[7] = NameTable;
    v238[6] = &v239;
    glpNameTableGet(NameTable, Name, v16, 0, (uint64_t)v238);
    v234 = 0;
    v235 = &v234;
    v236 = 0x2000000000;
    v237 = 0;
    v230 = 0;
    v231 = &v230;
    v232 = 0x2000000000;
    v233 = 0;
    v229[0] = v80;
    v229[1] = 0x40000000;
    v229[2] = __glpSAFunctionPrototype_block_invoke_3;
    v229[3] = &unk_24F4B32A8;
    v229[4] = &v234;
    v229[5] = &v230;
    glpNameTableGet(NameTable, v62, v64, 0, (uint64_t)v229);
    v81 = (uint64_t *)v248[3];
    if (v81)
    {
      if (*((_DWORD *)v252 + 6) != 4)
      {
        v98 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
        glpASTNodeGetLocation(v211, &v218);
        glpLogMessage(v98, 0, (uint64_t)&v218, "Function '%.*s' previously declared as non-function", v99, v100, v101, v102, v16);
        goto LABEL_128;
      }
      if (!v81[1])
      {
        v82 = *v81;
        v83 = (_QWORD *)glpCompilerGetAllocator(a1);
        v84 = (char *)glpAggregateTypeMangleName(v82, (uint64_t)Name, v16, v83);
        v225 = 0;
        v226 = &v225;
        v227 = 0x2000000000;
        v228 = 0;
        v224[0] = MEMORY[0x24BDAC760];
        v224[1] = 0x40000000;
        v224[2] = __glpSAFunctionPrototype_block_invoke_4;
        v224[3] = &unk_24F4B32D0;
        v224[4] = &v225;
        glpNameTableGet(NameTable, v84, v85, 0, (uint64_t)v224);
        if ((*(_BYTE *)(v226[3] + 10) & 0x20) != 0)
        {
          v114 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
          glpASTNodeGetLocation(v211, &v223);
          glpLogMessage(v114, 0, (uint64_t)&v223, "Function '%.*s' previously declared as subroutine implementation", v115, v116, v117, v118, v16);
          NameTable = glpSAFailed();
          _Block_object_dispose(&v225, 8);
LABEL_129:
          v136 = 0;
LABEL_130:
          _Block_object_dispose(&v230, 8);
          _Block_object_dispose(&v234, 8);
          _Block_object_dispose(&v239, 8);
          _Block_object_dispose(&v247, 8);
          _Block_object_dispose(&v251, 8);
          if (!v136)
            return NameTable;
LABEL_131:
          v158 = v211;
          glpFunctionPrototypeNodeSetExtra(v211, FunctionObject);
          v261 = (unsigned int *)glpFunctionTypeGetReturnType(v210);
          if (*(_BYTE *)(FunctionObject + 112)
            && ((v260 ^ *(_QWORD *)(*(_QWORD *)(FunctionObject + 72) + 48)) & 0x8000000001FLL) != 0)
          {
            v159 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
            glpASTNodeGetLocation(v158, &v213);
            glpLogMessage(v159, 0, (uint64_t)&v213, "Qualification of return type in redeclared function '%.*s' differs from previous declaration", v160, v161, v162, v163, v16);
          }
          Extra = glpFunctionPrototypeNodeGetExtra(v158);
          v165 = glpFunctionPrototypeNodeGetReturnOutParam(v158);
          v210 = Extra;
          if (v165)
          {
            v166 = v165;
            v167 = *(_QWORD *)(Extra + 72);
            if (!v167)
            {
              v168 = (_QWORD *)glpCompilerGetAllocator(a1);
              StringBuffer = glpMakeStringBuffer(v168);
              glpStringBufferAppendCString(StringBuffer, "<Compiler Temporary ");
              v170 = glpParameterDeclarationNodeGetName(v166);
              glpStringBufferAppendString(StringBuffer, v170, v171);
              glpStringBufferAppendCString(StringBuffer, ">");
              v172 = glpCompilerGetAllocator(a1);
              v173 = v261;
              SaFlags = glpASTNodeGetSaFlags(v166);
              v175 = glpParameterDeclarationNodeGetName(v166);
              v177 = v176;
              String = glpStringBufferGetString((uint64_t)StringBuffer);
              v179 = v177;
              Extra = v210;
              glpMakeVariableObject(v172, (uint64_t)v173, 0, SaFlags, v175, v179, String, v180, 0, 0, 0);
              v167 = v181;
              *(_QWORD *)(Extra + 72) = v181;
            }
            glpParameterDeclarationNodeSetExtra(v166, v167);
          }
          v182 = *(_QWORD *)(Extra + 80);
          if (!v182)
          {
            glpFunctionPrototypeNodeGetParameterCount(v158);
            *(_QWORD *)(Extra + 80) = glpCompilerPoolAlloc((uint64_t)a1);
            *(_DWORD *)(Extra + 88) = glpFunctionPrototypeNodeGetParameterCount(v158);
          }
          if (glpFunctionPrototypeNodeGetParameterCount(v158))
          {
            v183 = 0;
            do
            {
              v184 = glpFunctionPrototypeNodeGetParameter(v158, v183);
              v185 = v184;
              if (!v182)
              {
                SaType = glpASTNodeGetSaType(v184);
                v187 = glpCompilerGetAllocator(a1);
                v188 = glpASTNodeGetSaFlags(v185);
                v189 = glpParameterDeclarationNodeGetName(v185);
                v191 = v190;
                v192 = glpParameterDeclarationNodeGetName(v185);
                v194 = v193;
                v195 = SaType;
                v196 = v191;
                Extra = v210;
                v158 = v211;
                glpMakeVariableObject(v187, v195, 0, v188, v189, v196, v192, v194, 0, 0, 0);
                *(_QWORD *)(*(_QWORD *)(Extra + 80) + 8 * v183) = v197;
              }
              glpParameterDeclarationNodeSetExtra(v185, *(_QWORD *)(*(_QWORD *)(Extra + 80) + 8 * v183++));
            }
            while (v183 < glpFunctionPrototypeNodeGetParameterCount(v158));
          }
          v198 = *(unsigned int *)(Extra + 88);
          v199 = *(_QWORD *)(Extra + 8);
          if (!(_DWORD)v198)
          {
LABEL_150:
            NameTable = v211;
            glpASTNodeSetSaFlags(v211, v199);
            glpFunctionPrototypeNodeSetReturnType(NameTable, 0);
            return NameTable;
          }
          v200 = 0;
          v201 = 8 * v198;
          while ((v199 & 0x3800) == 0
               || (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(Extra + 80) + v200) + 48) & 0x4800200) != 0)
          {
            v200 += 8;
            if (v201 == v200)
              goto LABEL_150;
          }
          v202 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
          glpASTNodeGetLocation(v211, &v212);
          glpLogMessage(v202, 0, (uint64_t)&v212, "Inline function '%.*s' argument '%.*s' not foldable/out", v203, v204, v205, v206, *(_DWORD *)(Extra + 32));
          return glpSAFailed();
        }
        _Block_object_dispose(&v225, 8);
      }
      v86 = *((_DWORD *)v240 + 6);
      if (v68)
      {
        if (v86 != 3)
        {
          v87 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
          glpASTNodeGetLocation(v211, &v222);
          glpLogMessage(v87, 0, (uint64_t)&v222, "Subroutine implementation '%.*s' previously declared as function", v88, v89, v90, v91, v16);
LABEL_128:
          NameTable = glpSAFailed();
          goto LABEL_129;
        }
LABEL_98:
        switch(glpNameTableGetGLSLVersion(NameTable))
        {
          case 0u:
            if (!v235[3])
              goto LABEL_107;
            v119 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
            glpASTNodeGetLocation(v211, &v221);
            glpLogMessage(v119, 0, (uint64_t)&v221, "Function '%.*s' redefines a built-in function", v120, v121, v122, v123, v16);
            break;
          case 2u:
          case 3u:
          case 4u:
          case 5u:
          case 7u:
          case 8u:
          case 9u:
            v248[3] = 0;
            goto LABEL_107;
          case 6u:
            v153 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
            glpASTNodeGetLocation(v211, &v220);
            glpLogMessage(v153, 0, (uint64_t)&v220, "Function '%.*s' overloads or redefines a built-in function", v154, v155, v156, v157, v16);
            goto LABEL_128;
          case 0xAu:
            abort();
          default:
            goto LABEL_107;
        }
        goto LABEL_128;
      }
      if (v86 == 3)
        goto LABEL_98;
      if (v208)
      {
        v108 = v235[3];
        if (v108)
        {
          if (*(_QWORD *)(v108 + 64))
          {
            v109 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
            glpASTNodeGetLocation(v211, &v219);
            glpLogMessage(v109, 0, (uint64_t)&v219, "Function '%.*s' redefines an existing function", v110, v111, v112, v113, v16);
            goto LABEL_128;
          }
        }
      }
    }
LABEL_107:
    v124 = v235[3];
    if (v124)
    {
      if (!*((_DWORD *)v231 + 6) && (*(_BYTE *)(FunctionObject + 10) & 0x10) != 0)
      {
        v137 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
        glpASTNodeGetLocation(v211, &v217);
        glpLogMessage(v137, 0, (uint64_t)&v217, "Subroutine implementation '%.*s' previously declared as function", v138, v139, v140, v141, v16);
        goto LABEL_128;
      }
      v125 = v211;
      if ((*(_BYTE *)(v124 + 10) & 0x20) != 0)
      {
        v130 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
        glpASTNodeGetLocation(v125, &v216);
        glpLogMessage(v130, 0, (uint64_t)&v216, "Function '%.*s' previously declared as subroutine implementation", v131, v132, v133, v134, v16);
        goto LABEL_128;
      }
      v126 = v210;
      if (!glpTypesEqual(*(unsigned int **)v124, v210))
      {
        v142 = (unsigned int *)glpFunctionTypeGetReturnType(*(_QWORD *)v235[3]);
        v143 = glpFunctionTypeGetReturnType(v126);
        LODWORD(v142) = glpTypesEqual(v142, v143);
        v144 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
        if ((_DWORD)v142)
        {
          glpASTNodeGetLocation(v125, &v214);
          glpLogMessage(v144, 0, (uint64_t)&v214, "Qualification of arguments in redeclared function '%.*s' differs from previous declaration", v145, v146, v147, v148, v16);
        }
        else
        {
          glpASTNodeGetLocation(v125, &v215);
          glpLogMessage(v144, 0, (uint64_t)&v215, "Return type in redeclared function '%.*s' differs from previous declaration", v149, v150, v151, v152, v16);
        }
        goto LABEL_128;
      }
      if (!*((_DWORD *)v231 + 6))
        FunctionObject = v235[3];
    }
    v127 = (unsigned int **)v248[3];
    if (v127)
    {
      while (1)
      {
        v128 = v127;
        if (glpTypesEqual(*v127, v210))
          break;
        v127 = (unsigned int **)v128[1];
        if (!v127)
        {
          v129 = (unsigned int *)glpCompilerPoolAlloc((uint64_t)a1);
          *(_QWORD *)v129 = v210;
          *((_QWORD *)v129 + 1) = 0;
          v128[1] = v129;
          goto LABEL_121;
        }
      }
      if (!*((_DWORD *)v231 + 6))
        goto LABEL_122;
    }
    else
    {
      v135 = (_QWORD *)glpCompilerPoolAlloc((uint64_t)a1);
      *v135 = v210;
      v135[1] = 0;
      glpNameTablePut(NameTable, Name, v16, 4, (uint64_t)v135);
    }
LABEL_121:
    glpNameTablePut(NameTable, v62, v64, 5, FunctionObject);
LABEL_122:
    v136 = 1;
    goto LABEL_130;
  }
  v21 = (uint64_t **)glpCompilerGetInfoLog((uint64_t)a1);
  glpASTNodeGetLocation(v20, &v256);
  v26 = "main() must return void";
  v27 = &v256;
LABEL_26:
  glpLogMessage(v21, 0, (uint64_t)v27, v26, v22, v23, v24, v25, v207[0]);
  return glpSAFailed();
}

uint64_t glpSAVariableDeclaration(uint64_t a1, uint64_t a2)
{
  uint64_t Type;
  uint64_t v5;
  uint64_t Initializer;
  uint64_t v7;
  char *Name;
  uint64_t v9;
  uint64_t v10;
  uint64_t NameTable;
  uint64_t CurrentFunction;
  uint64_t v13;
  unsigned int v14;
  unsigned int v16;
  uint64_t v17;
  uint64_t **v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t **InfoLog;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t **v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  char SaFlags;
  unsigned int *ElementType;
  uint64_t **v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int *SaType;
  uint64_t v45;
  unsigned int GLSLVersion;
  _BOOL4 v47;
  char v49;
  uint64_t **v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  __n128 *v56;
  uint64_t **v57;
  char v58;
  char v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int *v65;
  unsigned int *v66;
  uint64_t v67;
  unsigned int *v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD *Allocator;
  char v72;
  char v73;
  unsigned int *v74;
  _QWORD *v75;
  uint64_t **v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  unsigned int *v86;
  uint64_t StructTypeFromIBType;
  unsigned int FieldIndex;
  uint64_t ElementFlags;
  uint64_t *ElementLayout;
  uint64_t *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t Value;
  unsigned int ImplicitConversionPolicy;
  uint64_t v97;
  uint64_t PrimitiveType;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t ElementCount;
  unsigned int v103;
  uint64_t v104;
  uint64_t *v105;
  size_t v106;
  uint64_t v107;
  uint64_t *v108;
  uint64_t v109;
  uint64_t *v110;
  uint64_t v111;
  uint64_t *v112;
  uint64_t v113;
  uint64_t v114;
  _QWORD *v115;
  uint64_t v116;
  int v117;
  _QWORD *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t StructType;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  int Bank;
  int v126;
  uint64_t **v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  unint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t *v136;
  int v137;
  uint64_t v138;
  int v139;
  uint64_t v140;
  int v141;
  int v142;
  _QWORD **v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  _QWORD *v148;
  _QWORD *v149;
  uint64_t v150;
  uint64_t **v151;
  char v152;
  char v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t AssignFragment;
  uint64_t v170;
  unsigned int *v171;
  _QWORD *v172;
  char v173;
  char v174;
  uint64_t v175;
  _QWORD *v176;
  uint64_t **v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t **v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  unsigned int *v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  __n128 v194;
  __n128 v195;
  __n128 v196;
  _QWORD v197[6];
  __n128 v198;
  uint64_t v199;
  uint64_t v200;
  __n128 v201;
  uint64_t v202;
  int v203;
  __n128 v204;
  __n128 v205;
  _QWORD *v206;
  _QWORD v207[5];
  __n128 v208;
  __n128 v209;
  __n128 v210;
  __n128 v211;
  __n128 v212;
  __n128 v213;
  __n128 v214;
  __n128 v215;
  uint64_t v216;
  uint64_t *v217;
  unint64_t v218;
  unsigned int *v219;
  __n128 v220;
  __n128 v221;
  __n128 v222;
  _QWORD v223[8];
  uint64_t v224;
  uint64_t *v225;
  uint64_t v226;
  int v227;
  uint64_t v228;
  uint64_t *v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t *v233;
  uint64_t v234;
  int v235;
  uint64_t v236;

  v236 = *MEMORY[0x24BDAC8D0];
  Type = glpVariableDeclarationNodeGetType(a2);
  v5 = glpSANode(a1, Type);
  if (v5 != -1)
    glpVariableDeclarationNodeSetType(a2, v5);
  Initializer = glpVariableDeclarationNodeGetInitializer(a2);
  v7 = glpSANode(a1, Initializer);
  if (v7 == -1)
    return glpSAFailed();
  glpVariableDeclarationNodeSetInitializer(a2, v7);
  if (v5 == -1)
    return glpSAFailed();
  Name = (char *)glpVariableDeclarationNodeGetName(a2);
  v10 = v9;
  NameTable = glpCompilerGetNameTable(a1);
  CurrentFunction = glpNameTableGetCurrentFunction(NameTable);
  v232 = 0;
  v233 = &v232;
  v234 = 0x2000000000;
  v235 = 0;
  v228 = 0;
  v229 = &v228;
  v230 = 0x2000000000;
  v231 = 0;
  v224 = 0;
  v225 = &v224;
  v226 = 0x2000000000;
  v227 = 0;
  v13 = MEMORY[0x24BDAC760];
  v223[0] = MEMORY[0x24BDAC760];
  v223[1] = 0x40000000;
  v223[2] = __glpSAVariableDeclaration_block_invoke;
  v223[3] = &unk_24F4B32F8;
  v223[4] = &v232;
  v223[5] = &v228;
  v223[7] = NameTable;
  v223[6] = &v224;
  glpNameTableGet(NameTable, Name, v10, 2 * (CurrentFunction != 0), (uint64_t)v223);
  if (v229[3])
  {
    v14 = 10;
    switch(*((_DWORD *)v233 + 6))
    {
      case 1:
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v222);
        glpLogMessage(InfoLog, 0, (uint64_t)&v222, "'%.*s' already declared as an interface block instance", v24, v25, v26, v27, v10);
        goto LABEL_41;
      case 2:
        v28 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v221);
        glpLogMessage(v28, 0, (uint64_t)&v221, "'%.*s' already declared as an interface block", v29, v30, v31, v32, v10);
        goto LABEL_41;
      case 3:
        goto LABEL_22;
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
        if (*((_DWORD *)v225 + 6))
        {
          v229[3] = 0;
          goto LABEL_9;
        }
        v18 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v220);
        glpLogMessage(v18, 0, (uint64_t)&v220, "Attempt to redeclare '%.*s' as a variable", v19, v20, v21, v22, v10);
        break;
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xD:
        goto LABEL_135;
      default:
        goto LABEL_9;
    }
    goto LABEL_41;
  }
LABEL_9:
  if (CurrentFunction
    || (v10 & 0xFFFFFFFE) != 0
    && *Name == 36
    && ((v16 = Name[1], (v16 & 0x80000000) != 0)
      ? (v17 = __maskrune_l(v16, 0x400uLL, 0))
      : (v17 = *(_DWORD *)(MEMORY[0x24BDAC740] + 4 * v16 + 60) & 0x400),
        v17))
  {
    v14 = 6;
  }
  else
  {
    v14 = 1;
  }
LABEL_22:
  v33 = glpVariableDeclarationNodeGetType(a2);
  v219 = 0;
  v218 = 0;
  v217 = 0;
  v216 = 0;
  glpASTNodeGetLocation(a2, &v215);
  v34 = glpVariableDeclarationNodeGetIsFromSource(a2);
  SaFlags = glpASTNodeGetSaFlags(v33);
  if (!glpEvaluateTypeNode(a1, (__int128 *)&v215, v14, v34, v33, SaFlags & 0x1F, &v219, (uint64_t)&v218, &v217, &v216))goto LABEL_41;
  glpASTNodeSetSaType(a2, (uint64_t)v219);
  if (glpCompilerUsingStyleGuide(a1))
  {
    if (glpTypeGetKind(v219) == 2)
    {
      ElementType = (unsigned int *)glpArrayTypeGetElementType((uint64_t)v219);
      if (glpTypeGetKind(ElementType) == 1)
      {
        v37 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(a2, &v214);
        glpLogMessage(v37, 2u, (uint64_t)&v214, "Arrays of structs may be less performant than structs of arrays", v38, v39, v40, v41, v189);
      }
    }
  }
  v42 = glpVariableDeclarationNodeGetInitializer(a2);
  if (v42)
  {
    v43 = v42;
    SaType = (unsigned int *)glpASTNodeGetSaType(v42);
    if (!glpTypesEqual(SaType, (uint64_t)v219))
    {
      v65 = (unsigned int *)glpASTNodeGetSaType(v43);
      if (glpTypeGetKind(v65) || glpTypeGetKind(v219))
      {
        v66 = (unsigned int *)glpASTNodeGetSaType(v43);
        if (glpTypeGetKind(v66) != 2
          || glpTypeGetKind(v219) != 2
          || (v67 = glpASTNodeGetSaType(v43),
              v68 = (unsigned int *)glpArrayTypeGetElementType(v67),
              v69 = glpArrayTypeGetElementType((uint64_t)v219),
              !glpTypesEqual(v68, v69))
          || glpArrayTypeGetElementCount((uint64_t)v219) != -1)
        {
          v70 = glpASTNodeGetSaType(v43);
          Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
          glpTypeHumanReadableDescription(v70, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
          v73 = v72;
          v74 = v219;
          v75 = (_QWORD *)glpCompilerGetAllocator(a1);
          glpTypeHumanReadableDescription((uint64_t)v74, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v75);
          v76 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(a2, &v212);
          glpLogMessage(v76, 0, (uint64_t)&v212, "Initializer has type incompatible with declaration (got '%.*s', expected '%.*s')", v77, v78, v79, v80, v73);
          goto LABEL_41;
        }
        v219 = (unsigned int *)glpASTNodeGetSaType(v43);
        glpASTNodeSetSaType(a2, (uint64_t)v219);
      }
      else
      {
        ImplicitConversionPolicy = glpCompilerGetImplicitConversionPolicy(a1);
        v97 = glpASTNodeGetSaType(v43);
        PrimitiveType = glpPrimitiveTypeGetPrimitiveType(v97);
        v99 = glpPrimitiveTypeGetPrimitiveType((uint64_t)v219);
        if (!glpCanConvert(PrimitiveType, v99, ImplicitConversionPolicy))
        {
          v50 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(a2, &v213);
          v55 = "Incompatible types in initialization (and no available implicit conversion)";
          v56 = &v213;
          goto LABEL_38;
        }
        v100 = glpConvert(a1, v43, (uint64_t)v219, v218 & 0x1F);
        glpVariableDeclarationNodeSetInitializer(a2, v100);
      }
    }
    v45 = glpCompilerGetNameTable(a1);
    GLSLVersion = glpNameTableGetGLSLVersion(v45);
    v47 = GLSLVersion > 1;
    if ((int)glpCompilerGetIOSVersion(a1) >= 9)
      v47 = GLSLVersion > 1 && GLSLVersion != 6;
    v49 = v218;
    if ((v218 & 0xC20000000) == 0)
    {
      if ((v218 & 0x100000000) == 0
        || (glpASTNodeGetSaFlags(v43) & 0x60) != 0
        && ((v49 = v218, (v218 & 0x100000000) == 0) ? (v81 = 1) : (v81 = v47), v81 == 1))
      {
        if (((v49 & 0x60) == 0
           || (glpASTNodeGetSaFlags(v43) & 0x60) != 0
           && ((v218 & 0x60) == 0 || (glpASTNodeGetSaFlags(v43) & 0x20) != 0 || GLSLVersion != 1))
          && (glpTypeGetKind(v219) != 2 || GLSLVersion > 1))
        {
          goto LABEL_63;
        }
      }
    }
    v50 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v211);
    v55 = "Initializer not allowed";
    v56 = &v211;
LABEL_38:
    glpLogMessage(v50, 0, (uint64_t)v56, v55, v51, v52, v53, v54, v189);
    goto LABEL_41;
  }
  if ((v218 & 0x60) != 0)
  {
    v57 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v210);
    glpVariableDeclarationNodeGetName(a2);
    v59 = v58;
    glpVariableDeclarationNodeGetName(a2);
    glpLogMessage(v57, 0, (uint64_t)&v210, "Missing initializer for const variable '%.*s'", v60, v61, v62, v63, v59);
    goto LABEL_41;
  }
LABEL_63:
  if (glpNameTableGetGLSLVersion(NameTable) == 6
    && !glpNameTableIsExtensionEnabled(NameTable, 0x23u)
    && glpTypeGetKind(v219) == 2
    && glpArrayTypeGetElementCount((uint64_t)v219) == -1)
  {
    v151 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v209);
    glpVariableDeclarationNodeGetName(a2);
    v153 = v152;
    glpVariableDeclarationNodeGetName(a2);
    glpLogMessage(v151, 0, (uint64_t)&v209, "Unsized array '%.*s' requires sized initializer under GLSL 300", v154, v155, v156, v157, v153);
    goto LABEL_41;
  }
  glpASTNodeSetSaFlags(a2, v218);
  v82 = v229[3];
  if (!v82)
  {
    v92 = glpCheckName(a1, a2, Name, v10);
    if (v92 == -1)
      goto LABEL_41;
    v64 = v92;
    v93 = glpVariableDeclarationNodeGetInitializer(v92);
    v94 = v93;
    if (v93)
    {
      if (glpIsConstantNode(v93))
        Value = glpConstantNodeGetValue(v94);
      else
        Value = 0;
      v133 = v218;
      if ((v218 & 0x60) != 0)
      {
        if (glpIsConstantNode(v94))
        {
          glpVariableDeclarationNodeSetInitializer(v64, 0);
          v133 = v218;
        }
        else
        {
          v133 = v218 & 0xFFFFFFFFFFFFFE9FLL | 0x100;
          v218 = v133;
        }
        v132 = Value;
      }
      else
      {
        v132 = 0;
      }
      if ((v133 & 0x100000000) != 0 && glpIsConstantNode(v94))
        glpVariableDeclarationNodeSetInitializer(v64, 0);
    }
    else
    {
      v132 = 0;
      Value = 0;
    }
    v158 = glpCompilerGetAllocator(a1);
    glpMakeVariableObject(v158, (uint64_t)v219, (uint64_t)v217, v218, (uint64_t)Name, v10, (uint64_t)Name, v10, v94 != 0, v132, Value);
    v229[3] = v159;
    if ((v218 & 0x200000000) == 0)
    {
      v160 = v159;
      if ((v218 & 0x400000000) != 0)
      {
        v161 = glpCompilerGetAllocator(a1);
        glpMakeBufferObject(v161, (uint64_t)v219, 0, 1);
        *(_QWORD *)(v160 + 88) = v162;
      }
      glpNameTablePut(NameTable, Name, v10, 0, v160);
      if (glpVariableDeclarationNodeGetInitializer(v64) && (v218 & 0x100000000) == 0)
      {
        v201 = 0uLL;
        v202 = 0;
        glpASTNodeGetLocation(v64, &v201);
        v163 = glpCompilerGetAllocator(a1);
        v198 = v201;
        v199 = v202;
        glpMakeVariableIdentifierNode(v163, &v198, (uint64_t)Name, v10);
        v165 = glpSANode(a1, v164);
        if (v165 == -1)
          goto LABEL_41;
        v166 = v165;
        v167 = glpASTNodeGetSaFlags(v165);
        glpASTNodeSetSaFlags(v166, v167 & 0xFFFFFFFFFFFFFEFFLL);
        v168 = glpVariableDeclarationNodeGetInitializer(v64);
        v198 = v201;
        v199 = v202;
        AssignFragment = glpMakeAssignFragment(a1, &v198, v166, v168);
        glpVariableDeclarationNodeSetInitializer(v64, AssignFragment);
      }
      glpVariableDeclarationNodeSetExtra(v64, v229[3]);
      glpVariableDeclarationNodeSetType(v64, 0);
      goto LABEL_42;
    }
    v201.n128_u64[0] = 0;
    v201.n128_u64[1] = (unint64_t)&v201;
    v202 = 0x2000000000;
    v203 = 0;
    v198.n128_u64[0] = 0;
    v198.n128_u64[1] = (unint64_t)&v198;
    v199 = 0x2000000000;
    v200 = 0;
    v197[0] = v13;
    v197[1] = 0x40000000;
    v197[2] = __glpSAVariableDeclaration_block_invoke_3;
    v197[3] = &unk_24F4B3348;
    v197[4] = &v201;
    v197[5] = &v198;
    glpNameTableGet(NameTable, Name, v10, 2, (uint64_t)v197);
    v170 = *(_QWORD *)(v198.n128_u64[1] + 24);
    if (v170)
    {
      if (*(_DWORD *)(v201.n128_u64[1] + 24) != 7)
      {
        v184 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v64, &v195);
        glpLogMessage(v184, 0, (uint64_t)&v195, "subroutine uniform '%.*s' previously declared as different kind of object", v185, v186, v187, v188, v10);
        goto LABEL_133;
      }
      if (!glpTypesEqual(*(unsigned int **)(v170 + 16), (uint64_t)v219))
      {
        v171 = v219;
        v172 = (_QWORD *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription((uint64_t)v171, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v172);
        v174 = v173;
        v175 = *(_QWORD *)(v170 + 16);
        v176 = (_QWORD *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription(v175, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v176);
        v177 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v64, &v196);
        glpLogMessage(v177, 0, (uint64_t)&v196, "Type ('%.*s') of subroutine uniform '%.*s' does not match previous declaration ('%.*s')", v178, v179, v180, v181, v174);
LABEL_133:
        v64 = glpSAFailed();
        goto LABEL_134;
      }
    }
    else
    {
      v170 = glpCompilerPoolAlloc(a1);
      *(_QWORD *)v170 = Name;
      *(_QWORD *)(v170 + 8) = v10;
      *(_QWORD *)(v170 + 16) = v219;
      glpNameTablePut(NameTable, Name, v10, 7, v170);
    }
    v182 = glpCompilerGetAllocator(a1);
    glpASTNodeGetLocation(v64, &v194);
    glpMakeSubroutineUniformNode(v182, &v194, v170);
    v64 = v183;
    glpASTNodeSetSaType(v183, (uint64_t)v219);
    glpASTNodeSetSaFlags(v64, v218);
LABEL_134:
    _Block_object_dispose(&v198, 8);
    _Block_object_dispose(&v201, 8);
    goto LABEL_42;
  }
  v83 = *((_DWORD *)v233 + 6);
  if (v83)
  {
    if (v83 != 3)
LABEL_135:
      abort();
    if (glpNameTableGetLanguage(NameTable) == 3
      && glpStringsEqual("gl_ClipDistance", 0xA52D52050000000FLL, Name, v10)
      && (v218 & 0x20000000) != 0)
    {
      v84 = glpCompilerGetNameTable(a1);
      v207[0] = v13;
      v207[1] = 0x40000000;
      v207[2] = __glpSAVariableDeclaration_block_invoke_2;
      v207[3] = &unk_24F4B3320;
      v207[4] = &v228;
      glpNameTableGet(v84, "gl_in", 0x1057ED5B00000005, 0, (uint64_t)v207);
    }
    v85 = v229[3];
    v86 = *(unsigned int **)(v85 + 64);
    StructTypeFromIBType = glpGetStructTypeFromIBType(v86);
    FieldIndex = glpStructTypeGetFieldIndex(StructTypeFromIBType, Name, v10);
    v192 = glpAggregateTypeGetElementType(StructTypeFromIBType, FieldIndex);
    ElementFlags = glpAggregateTypeGetElementFlags(StructTypeFromIBType, FieldIndex);
    LODWORD(v193) = FieldIndex;
    ElementLayout = (uint64_t *)glpAggregateTypeGetElementLayout(StructTypeFromIBType, FieldIndex);
    v191 = v85;
    switch(glpInterfaceBlockObjectGetRepresentation(v85))
    {
      case 0u:
      case 2u:
        v91 = *(uint64_t **)(v85 + 72);
        goto LABEL_85;
      case 1u:
      case 3u:
        v91 = (uint64_t *)(*(_QWORD *)(v85 + 72) + 8 * v193);
LABEL_85:
        v101 = *v91;
        break;
      default:
        v101 = 0;
        break;
    }
    v201.n128_u64[0] = 0;
    v198.n128_u64[0] = 0;
    v206 = 0;
    glpASTNodeGetLocation(a2, &v205);
    if (glpHandleVariableRedeclaration(a1, (__int128 *)&v205, (uint64_t)Name, v10, (unsigned int *)v192, ElementFlags, ElementLayout, (unsigned int *)(v101 + 96), v219, v218, (_QWORD **)v217, (unsigned int **)&v201, v198.n128_u64, &v206))
    {
      v190 = v86;
      ElementCount = glpAggregateTypeGetElementCount(StructTypeFromIBType);
      v103 = ElementCount;
      v192 = ElementCount;
      MEMORY[0x24BDAC7A8](ElementCount);
      v105 = &v189 - 2 * v104;
      bzero(v105, v106);
      MEMORY[0x24BDAC7A8](v107);
      v108 = (uint64_t *)((char *)&v189 - ((8 * v103 + 15) & 0xFFFFFFFF0));
      bzero(v108, 8 * v103);
      MEMORY[0x24BDAC7A8](v109);
      v110 = v108;
      bzero(v108, 8 * v103);
      MEMORY[0x24BDAC7A8](v111);
      v112 = v108;
      v113 = v192;
      bzero(v108, 8 * v103);
      if (v103)
      {
        v114 = 0;
        v115 = v105 + 1;
        do
        {
          *(v115 - 1) = glpStructTypeGetFieldName(StructTypeFromIBType, v114);
          *v115 = v116;
          v108[v114] = glpAggregateTypeGetElementType(StructTypeFromIBType, v114);
          v108[v114] = glpAggregateTypeGetElementFlags(StructTypeFromIBType, v114);
          v108[v114] = glpAggregateTypeGetElementLayout(StructTypeFromIBType, v114);
          ++v114;
          v115 += 2;
        }
        while (v113 != v114);
      }
      v117 = v193;
      v108[v193] = v201.n128_u64[0];
      v108[v117] = v198.n128_u64[0];
      v108[v117] = (uint64_t)v206;
      v118 = (_QWORD *)glpCompilerGetAllocator(a1);
      v119 = glpStructTypeGetName(StructTypeFromIBType);
      StructType = glpMakeStructType(v118, v119, v120, v113, (uint64_t)v105, (uint64_t)v108, (uint64_t)v108, (uint64_t)v108);
      v122 = v191;
      switch(glpInterfaceBlockObjectGetRepresentation(v191))
      {
        case 0u:
          goto LABEL_92;
        case 1u:
          goto LABEL_107;
        case 2u:
          v123 = glpCompilerGetAllocator(a1);
          v124 = (uint64_t)v190;
          Bank = glpBankTypeGetBank((uint64_t)v190);
          v126 = glpBankTypeGetElementCount(v124);
          StructType = glpMakeBankType(v123, Bank, StructType, v126);
LABEL_92:
          *(_QWORD *)(v122 + 64) = StructType;
          ***(_QWORD ***)(v122 + 72) = StructType;
          goto LABEL_111;
        case 3u:
          v189 = StructType;
          v134 = (uint64_t)v190;
          if ((_DWORD)v113)
          {
            v135 = v192;
            v136 = v108;
            do
            {
              v193 = glpCompilerGetAllocator(a1);
              v137 = glpBankTypeGetBank(v134);
              v138 = *v136;
              v139 = glpBankTypeGetElementCount(v134);
              *v136++ = glpMakeBankType(v193, v137, v138, v139);
              --v135;
            }
            while (v135);
          }
          v140 = glpCompilerGetAllocator(a1);
          v141 = glpBankTypeGetBank(v134);
          v142 = glpBankTypeGetElementCount(v134);
          StructType = glpMakeBankType(v140, v141, v189, v142);
          v122 = v191;
          v113 = v192;
LABEL_107:
          if ((_DWORD)v113)
          {
            v143 = *(_QWORD ***)(v122 + 72);
            v144 = *(_QWORD *)(v122 + 40);
            do
            {
              v145 = *v108++;
              **v143 = v145;
              v146 = *v110++;
              v147 = v146 | v144;
              v149 = *v143++;
              v148 = v149;
              v149[6] = v147 | 0x80000000;
              v150 = *v112++;
              v148[1] = v150;
              --v113;
            }
            while (v113);
          }
          *(_QWORD *)(v122 + 64) = StructType;
          break;
        default:
          goto LABEL_111;
      }
      goto LABEL_111;
    }
    v127 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(a2, &v204);
    glpLogMessage(v127, 0, (uint64_t)&v204, "'%.*s' already declared within an interface block", v128, v129, v130, v131, v10);
  }
  else
  {
    glpASTNodeGetLocation(a2, &v208);
    if (glpHandleVariableRedeclaration(a1, (__int128 *)&v208, (uint64_t)Name, v10, *(unsigned int **)v82, *(_QWORD *)(v82 + 48), *(uint64_t **)(v82 + 8), (unsigned int *)(v82 + 96), v219, v218, (_QWORD **)v217, (unsigned int **)v82, (unint64_t *)(v82 + 48), (_QWORD **)(v82 + 8)))
    {
LABEL_111:
      v64 = 0;
      goto LABEL_42;
    }
  }
LABEL_41:
  v64 = glpSAFailed();
LABEL_42:
  _Block_object_dispose(&v224, 8);
  _Block_object_dispose(&v228, 8);
  _Block_object_dispose(&v232, 8);
  return v64;
}

uint64_t glpSAVariableDeclarationGroup(uint64_t a1, uint64_t a2)
{
  uint64_t BaseType;
  uint64_t v5;
  int v6;
  unsigned int v7;
  uint64_t Declaration;
  uint64_t v9;
  char *PrimitiveType;
  uint64_t v11;

  BaseType = glpVariableDeclarationGroupNodeGetBaseType(a2);
  v5 = glpSANode(a1, BaseType);
  if (v5 == -1)
  {
    v6 = 0;
  }
  else
  {
    glpVariableDeclarationGroupNodeSetBaseType(a2, v5);
    v6 = 1;
  }
  if (glpVariableDeclarationGroupNodeGetDeclarationCount(a2))
  {
    v7 = 0;
    do
    {
      Declaration = glpVariableDeclarationGroupNodeGetDeclaration(a2, v7);
      v9 = glpSANode(a1, Declaration);
      if (v9 == -1)
        v6 = 0;
      else
        glpVariableDeclarationGroupNodeSetDeclaration(a2, v7, v9);
      ++v7;
    }
    while (v7 < glpVariableDeclarationGroupNodeGetDeclarationCount(a2));
  }
  if (!v6)
    return glpSAFailed();
  PrimitiveType = glpGetPrimitiveType(0);
  glpASTNodeSetSaType(a2, (uint64_t)PrimitiveType);
  v11 = glpVariableDeclarationGroupNodeGetBaseType(a2);
  if (!glpIsStructTypeNode(v11))
  {
    if (glpVariableDeclarationGroupNodeGetDeclarationCount(a2) == 1)
      return glpVariableDeclarationGroupNodeGetDeclaration(a2, 0);
    glpVariableDeclarationGroupNodeSetBaseType(a2, 0);
  }
  return a2;
}

uint64_t glpSAPrecisionDeclaration(uint64_t a1, uint64_t a2)
{
  uint64_t Type;
  uint64_t v5;
  uint64_t v6;
  unsigned int *SaType;
  unsigned int PrimitiveType;
  int Category;
  BOOL v11;
  _QWORD *Allocator;
  char v13;
  char v14;
  uint64_t **InfoLog;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t Qualifier;
  unsigned int v21;
  uint64_t v22;
  uint64_t NameTable;
  __n128 v24;

  if (glpCompilerDoesTrackPrecision(a1))
  {
    Type = glpPrecisionDeclarationNodeGetType(a2);
    v5 = glpSANode(a1, Type);
    if (v5 == -1)
      return glpSAFailed();
    v6 = v5;
    glpPrecisionDeclarationNodeSetType(a2, v5);
    SaType = (unsigned int *)glpASTNodeGetSaType(v6);
    if (glpTypeGetKind(SaType))
    {
      glpPrimitiveTypeGetCategory(0);
LABEL_13:
      Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
      glpTypeHumanReadableDescription((uint64_t)SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
      v14 = v13;
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a2, &v24);
      glpLogMessage(InfoLog, 0, (uint64_t)&v24, "Default precision qualifier cannot be applied to type '%.*s'", v16, v17, v18, v19, v14);
      return glpSAFailed();
    }
    PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType);
    Category = glpPrimitiveTypeGetCategory(PrimitiveType);
    v11 = Category == 4 || Category == 1;
    if (!v11 || PrimitiveType == 9 || PrimitiveType == 36)
      goto LABEL_13;
    Qualifier = glpPrecisionDeclarationNodeGetQualifier(a2);
    v21 = glpKeywordQualifierNodeGetQualifier(Qualifier) - 20;
    if (v21 >= 5)
      abort();
    v22 = qword_22A980DC0[v21];
    NameTable = glpCompilerGetNameTable(a1);
    glpNameTablePutPrecision(NameTable, PrimitiveType, v22);
  }
  return 0;
}

uint64_t glpSAQualifiedDeclaration(uint64_t a1, uint64_t a2)
{
  uint64_t NameTable;
  uint64_t **v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *Name;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t StructTypeFromIBType;
  unsigned int v18;
  uint64_t **v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  unint64_t v25;
  uint64_t **InfoLog;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t Qualifiers;
  char v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  __n128 v37;
  __n128 v38;
  _QWORD v39[6];
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  int v47;
  __n128 v48;

  NameTable = glpCompilerGetNameTable(a1);
  if (!glpNameTableGetCurrentFunction(NameTable))
  {
    Name = (char *)glpQualifiedDeclarationNodeGetName(a2);
    v13 = v12;
    v44 = 0;
    v45 = &v44;
    v46 = 0x2000000000;
    v47 = 0;
    v40 = 0;
    v41 = &v40;
    v42 = 0x2000000000;
    v43 = 0;
    v39[0] = MEMORY[0x24BDAC760];
    v39[1] = 0x40000000;
    v39[2] = __glpSAQualifiedDeclaration_block_invoke;
    v39[3] = &unk_24F4B3370;
    v39[4] = &v44;
    v39[5] = &v40;
    glpNameTableGet(NameTable, Name, v12, 0, (uint64_t)v39);
    v14 = v41[3];
    if (v14)
    {
      v15 = *((_DWORD *)v45 + 6);
      if (v15)
      {
        if (v15 != 3)
        {
          InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(a2, &v37);
          glpLogMessage(InfoLog, 0, (uint64_t)&v37, "Only variables and interface block fields may retroactively qualified", v27, v28, v29, v30, v33);
          goto LABEL_16;
        }
        v16 = *(_QWORD *)(v14 + 72);
        StructTypeFromIBType = glpGetStructTypeFromIBType(*(unsigned int **)(v14 + 64));
        v14 = *(_QWORD *)(v16 + 8 * glpStructTypeGetFieldIndex(StructTypeFromIBType, Name, v13));
        v18 = 12;
      }
      else
      {
        v18 = 11;
      }
      v24 = *(uint64_t **)(v14 + 8);
      if (v24)
        v25 = (unint64_t)(glpLayoutObjectFind(v24, 30) != 0) << 28;
      else
        v25 = 0;
      v35 = 0;
      v36 = 0;
      v34 = 0;
      Qualifiers = glpQualifiedDeclarationNodeGetQualifiers(a2);
      if (glpParseQualifiers(a1, v18, Qualifiers, *(_QWORD *)(v14 + 48) | v25, &v36, &v35, &v34))
      {
        v10 = 0;
        *(_QWORD *)(v14 + 48) = v36;
LABEL_17:
        _Block_object_dispose(&v40, 8);
        _Block_object_dispose(&v44, 8);
        return v10;
      }
    }
    else
    {
      v19 = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(a2, &v38);
      glpLogMessage(v19, 0, (uint64_t)&v38, "Cannot retroactivly qualify undeclared identifier '%.*s'", v20, v21, v22, v23, v13);
    }
LABEL_16:
    v10 = glpSAFailed();
    goto LABEL_17;
  }
  v5 = (uint64_t **)glpCompilerGetInfoLog(a1);
  glpASTNodeGetLocation(a2, &v48);
  glpLogMessage(v5, 0, (uint64_t)&v48, "Retroactive qualifier declarations must appear at global scope", v6, v7, v8, v9, v33);
  return glpSAFailed();
}

uint64_t glpSAQualifiedDeclarationGroup(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t Declaration;
  uint64_t v7;

  if (!glpQualifiedDeclarationGroupNodeGetDeclarationCount(a2))
    return 0;
  v4 = 0;
  v5 = 1;
  do
  {
    Declaration = glpQualifiedDeclarationGroupNodeGetDeclaration(a2, v4);
    v7 = glpSANode(a1, Declaration);
    if (v7 == -1)
      v5 = 0;
    else
      glpQualifiedDeclarationGroupNodeSetDeclaration(a2, v4, v7);
    ++v4;
  }
  while (v4 < glpQualifiedDeclarationGroupNodeGetDeclarationCount(a2));
  if (!v5)
    return glpSAFailed();
  else
    return 0;
}

uint64_t glpSAFunctionDefinition(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t Prototype;
  uint64_t Extra;
  uint64_t v6;
  uint64_t v7;
  int TypeCount;
  uint64_t *v9;
  unint64_t v10;
  uint64_t Type;
  uint64_t SaType;
  unsigned int *v13;
  uint64_t *FunctionObject;
  uint64_t v15;
  _QWORD *Allocator;
  uint64_t v17;
  uint64_t SubroutineImplementationFragment;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t SubroutineParameterFragment;
  uint64_t **InfoLog;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  __n128 *v40;
  char v41;
  char v42;
  uint64_t ExpressionStatementNode;
  unint64_t v44;
  _QWORD *v45;
  uint64_t *StringBuffer;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t String;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD *v62;
  _QWORD *v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  _QWORD *v69;
  uint64_t v70;
  uint64_t SaFlags;
  _QWORD *NameTable;
  uint64_t Body;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unsigned int i;
  uint64_t Parameter;
  char *Name;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  _QWORD *v88;
  uint64_t **v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t **v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  _QWORD *v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  __n128 v103;
  __n128 v104;
  __n128 v105;
  __n128 v106;
  __n128 v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  __n128 v112;
  __n128 v113[2];

  v2 = a2;
  Prototype = glpFunctionDefinitionNodeGetPrototype(a2);
  if (glpSANode(a1, Prototype) == -1)
    return glpSAFailed();
  Extra = glpFunctionPrototypeNodeGetExtra(Prototype);
  v6 = Extra;
  if ((*(_BYTE *)(Extra + 10) & 8) != 0)
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, v113);
    v100 = *(_DWORD *)(v6 + 32);
    v39 = "Subroutine function definition '%.*s' must include a list of compatible subroutine types";
    v40 = v113;
    goto LABEL_12;
  }
  v7 = *(_QWORD *)(Extra + 56);
  v102 = Extra;
  if (v7)
  {
    TypeCount = glpSubroutineTypeListNodeGetTypeCount(v7);
    v9 = (uint64_t *)glpCompilerPoolAlloc(a1);
    if (glpSubroutineTypeListNodeGetTypeCount(v7))
    {
      v10 = 0;
      while (1)
      {
        Type = glpSubroutineTypeListNodeGetType(v7, v10);
        SaType = glpASTNodeGetSaType(Type);
        v13 = (unsigned int *)glpASTNodeGetSaType(Prototype);
        FunctionObject = (uint64_t *)glpSubroutineTypeGetFunctionObject(SaType);
        if (!glpTypesEqual(v13, *FunctionObject))
          break;
        v9[v10++] = SaType;
        if (v10 >= glpSubroutineTypeListNodeGetTypeCount(v7))
          goto LABEL_8;
      }
      glpSubroutineTypeGetName(SaType);
      v42 = v41;
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v2, &v112);
      LOBYTE(v100) = v42;
      v39 = "Subroutine type '%.*s' is incompatible with definition of subroutine '%.*s'";
      v40 = &v112;
LABEL_12:
      glpLogMessage(InfoLog, 0, (uint64_t)v40, v39, v35, v36, v37, v38, v100);
      return glpSAFailed();
    }
LABEL_8:
    v15 = glpSubroutineTypeListNodeGetType(v7, 0);
    glpASTNodeGetSaType(v15);
    v110 = 0;
    v111 = 0;
    v109 = 0;
    Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
    v107.n128_u64[0] = (unint64_t)"-1";
    v107.n128_u64[1] = 0xEDA00000002;
    v108 = 0xFFFFFFFFLL;
    SubroutineImplementationFragment = glpMakeSubroutineImplementationFragment(Allocator, &v107, &v111, *(_QWORD *)(v6 + 24), *(_QWORD *)(v6 + 32), &v110, &v109, v17, *(_QWORD *)(v6 + 24), *(_QWORD *)(v6 + 32));
    v19 = glpCompilerPoolAlloc(a1);
    v20 = glpSubroutineTypeGetFunctionObject(*v9);
    v22 = *(_OWORD *)(v20 + 48);
    v21 = *(_OWORD *)(v20 + 64);
    v23 = *(_OWORD *)(v20 + 80);
    *(_OWORD *)(v19 + 96) = *(_OWORD *)(v20 + 96);
    v24 = *(_OWORD *)(v20 + 16);
    v25 = *(_OWORD *)(v20 + 32);
    *(_OWORD *)v19 = *(_OWORD *)v20;
    *(_OWORD *)(v19 + 16) = v24;
    *(_OWORD *)(v19 + 32) = v25;
    *(_OWORD *)(v19 + 48) = v22;
    *(_OWORD *)(v19 + 64) = v21;
    *(_OWORD *)(v19 + 80) = v23;
    v26 = *(_OWORD *)(v20 + 112);
    v27 = *(_OWORD *)(v20 + 128);
    v28 = *(_OWORD *)(v20 + 144);
    *(_QWORD *)(v19 + 160) = *(_QWORD *)(v20 + 160);
    *(_OWORD *)(v19 + 128) = v27;
    *(_OWORD *)(v19 + 144) = v28;
    *(_OWORD *)(v19 + 112) = v26;
    *(_DWORD *)(v19 + 96) = TypeCount;
    *(_QWORD *)(v19 + 104) = v9;
    *(_QWORD *)(v19 + 8) = *(_QWORD *)(v19 + 8) & 0xFFFFFFFFFFE7FFFFLL | 0x100000;
    *(_OWORD *)(v19 + 24) = *(_OWORD *)(v6 + 24);
    *(_OWORD *)(v19 + 40) = *(_OWORD *)(v6 + 40);
    glpFunctionPrototypeNodeSetExtra(v111, v19);
    glpASTNodeSetSaType(v111, *(_QWORD *)v19);
    glpASTNodeSetSaFlags(v111, *(_QWORD *)(v19 + 8));
    v29 = *(_QWORD *)(v19 + 72);
    v30 = glpCompilerGetAllocator(a1);
    v31 = v30;
    v101 = SubroutineImplementationFragment;
    if (v29)
    {
      glpASTNodeGetLocation(v2, &v106);
      SubroutineParameterFragment = glpMakeSubroutineParameterFragment(v31, &v106, *(_QWORD *)(*(_QWORD *)(v19 + 72) + 32), *(_QWORD *)(*(_QWORD *)(v19 + 72) + 40));
      glpASTNodeSetSaType(SubroutineParameterFragment, **(_QWORD **)(v19 + 72));
      glpASTNodeSetSaFlags(SubroutineParameterFragment, *(_QWORD *)(*(_QWORD *)(v19 + 72) + 48));
      glpParameterDeclarationNodeSetExtra(SubroutineParameterFragment, *(_QWORD *)(v19 + 72));
      glpFunctionPrototypeNodeSetReturnOutParam(v111, SubroutineParameterFragment);
    }
    else
    {
      v107.n128_u64[0] = (unint64_t)"-1";
      v107.n128_u64[1] = 0xEDA00000002;
      v108 = 0xFFFFFFFFLL;
      ExpressionStatementNode = glpMakeExpressionStatementNode(v30, &v107);
      glpExpressionStatementNodeSetExpr(ExpressionStatementNode, v109);
      glpBlockNodeSetStatement(v110, 0, ExpressionStatementNode);
    }
    if (*(_DWORD *)(v19 + 88))
    {
      v44 = 0;
      do
      {
        v45 = (_QWORD *)glpCompilerGetAllocator(a1);
        StringBuffer = glpMakeStringBuffer(v45);
        glpStringBufferAppendFormat(StringBuffer, "$subroutine$implementation_parameter$%u", v47, v48, v49, v50, v51, v52, v44);
        String = glpStringBufferGetString((uint64_t)StringBuffer);
        v55 = v54;
        v56 = glpCompilerGetAllocator(a1);
        glpASTNodeGetLocation(v2, &v105);
        v57 = glpMakeSubroutineParameterFragment(v56, &v105, String, v55);
        glpASTNodeSetSaType(v57, **(_QWORD **)(*(_QWORD *)(v19 + 80) + 8 * v44));
        glpASTNodeSetSaFlags(v57, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v19 + 80) + 8 * v44) + 48));
        glpParameterDeclarationNodeSetExtra(v57, *(_QWORD *)(*(_QWORD *)(v19 + 80) + 8 * v44));
        v58 = (_QWORD *)glpCompilerGetAllocator(a1);
        glpFunctionPrototypeNodeAddParameter(v58, v111, v57);
        v59 = glpCompilerGetAllocator(a1);
        v107.n128_u64[0] = (unint64_t)"-1";
        v107.n128_u64[1] = 0xEDA00000002;
        v108 = 0xFFFFFFFFLL;
        glpMakeVariableIdentifierNode(v59, &v107, String, v55);
        v61 = v60;
        v62 = (_QWORD *)glpCompilerGetAllocator(a1);
        glpCallNodeAddArg(v62, v109, v61);
        ++v44;
      }
      while (v44 < *(unsigned int *)(v19 + 88));
    }
    v63 = (_QWORD *)glpCompilerGetAllocator(a1);
    v64 = glpMakeStringBuffer(v63);
    glpStringBufferAppendCString(v64, "$SubroutineStatic$");
    v6 = v102;
    glpStringBufferAppendString(v64, *(_QWORD *)(v102 + 24), *(_QWORD *)(v102 + 32));
    v65 = glpStringBufferGetString((uint64_t)v64);
    v67 = v66;
    *(_QWORD *)(v102 + 24) = v65;
    *(_QWORD *)(v102 + 32) = v66;
    v68 = *(_QWORD *)v102;
    v69 = (_QWORD *)glpCompilerGetAllocator(a1);
    *(_QWORD *)(v102 + 40) = glpAggregateTypeMangleName(v68, v65, v67, v69);
    *(_QWORD *)(v102 + 48) = v70;
    SaFlags = glpASTNodeGetSaFlags(Prototype);
    glpASTNodeSetSaFlags(Prototype, SaFlags & 0xFFFFFFFFFFCFFFFFLL | 0x200000);
    *(_QWORD *)(v102 + 8) = *(_QWORD *)(v102 + 8) & 0xFFFFFFFFFFCFFFFFLL | 0x200000;
  }
  else
  {
    v101 = 0;
  }
  NameTable = (_QWORD *)glpCompilerGetNameTable(a1);
  Body = glpFunctionDefinitionNodeGetBody(v2);
  v74 = glpFunctionDefinitionNodeGetPrototype(v2);
  v75 = glpFunctionPrototypeNodeGetExtra(v74);
  glpNameTablePushForFunction(NameTable, Body, v75);
  v76 = glpCompilerGetNameTable(a1);
  *(_QWORD *)(v6 + 64) = v2;
  if (glpFunctionPrototypeNodeGetParameterCount(Prototype))
  {
    for (i = 0; i < glpFunctionPrototypeNodeGetParameterCount(Prototype); ++i)
    {
      Parameter = glpFunctionPrototypeNodeGetParameter(Prototype, i);
      Name = (char *)glpParameterDeclarationNodeGetName(Parameter);
      v81 = v80;
      if (!glpStringsEqual("<<unnamed>>", 0x725D7890000000BLL, Name, v80))
      {
        if (glpNameTableGet(v76, Name, v81, 2, (uint64_t)&__block_literal_global_4))
        {
          v89 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(Parameter, &v104);
          glpLogMessage(v89, 0, (uint64_t)&v104, "'%.*s': Duplicate parameter name", v90, v91, v92, v93, v81);
          return glpSAFailed();
        }
        v82 = glpParameterDeclarationNodeGetExtra(Parameter);
        glpNameTablePut(v76, Name, v81, 0, v82);
      }
    }
  }
  v83 = glpFunctionDefinitionNodeGetBody(v2);
  if (glpSANode(a1, v83) == -1)
  {
    v88 = (_QWORD *)glpCompilerGetNameTable(a1);
    glpNameTablePop(v88);
    *(_QWORD *)(v102 + 64) = 0;
    return glpSAFailed();
  }
  glpFunctionDefinitionNodeGetBody(v2);
  if (*(_QWORD *)(v102 + 72) && !*(_BYTE *)(v102 + 112))
  {
    v94 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v103);
    glpLogMessage(v94, 0, (uint64_t)&v103, "Missing return for function '%.*s'", v95, v96, v97, v98, *(_DWORD *)(v102 + 32));
    v99 = (_QWORD *)glpCompilerGetNameTable(a1);
    glpNameTablePop(v99);
    *(_QWORD *)(v102 + 64) = 0;
    return glpSAFailed();
  }
  else
  {
    v84 = glpFunctionDefinitionNodeGetPrototype(v2);
    v85 = glpASTNodeGetSaType(v84);
    glpASTNodeSetSaType(v2, v85);
    v86 = (_QWORD *)glpCompilerGetNameTable(a1);
    glpNameTablePop(v86);
    if (v101)
    {
      v87 = glpSANode(a1, v101);
      glpCompilerInsertDef(a1, v87);
    }
  }
  return v2;
}

uint64_t glpSAQualifiedType(uint64_t a1, uint64_t a2)
{
  uint64_t Type;
  uint64_t v5;
  uint64_t v6;
  uint64_t SaType;

  Type = glpQualifiedTypeNodeGetType(a2);
  v5 = glpSANode(a1, Type);
  if (v5 == -1)
    return glpSAFailed();
  glpQualifiedTypeNodeSetType(a2, v5);
  v6 = glpQualifiedTypeNodeGetType(a2);
  SaType = glpASTNodeGetSaType(v6);
  glpASTNodeSetSaType(a2, SaType);
  glpASTNodeSetSaFlags(a2, 0);
  return a2;
}

uint64_t glpSAPrimitiveType(uint64_t a1)
{
  unsigned int Type;
  char *PrimitiveType;

  Type = glpPrimitiveTypeNodeGetType(a1);
  PrimitiveType = glpGetPrimitiveType(Type);
  glpASTNodeSetSaType(a1, (uint64_t)PrimitiveType);
  return a1;
}

uint64_t glpSAArrayType(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t ElementType;
  uint64_t v5;
  uint64_t Dimension;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t SaFlags;
  uint64_t Allocator;
  uint64_t SaType;
  uint64_t ArrayType;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t Type;
  uint64_t Qualifiers;
  uint64_t v21;
  __n128 v23;
  __n128 v24;
  int v25;

  v2 = a2;
  ElementType = glpArrayTypeNodeGetElementType(a2);
  v5 = glpSANode(a1, ElementType);
  if (v5 != -1)
    glpArrayTypeNodeSetElementType(v2, v5);
  Dimension = glpArrayTypeNodeGetDimension(v2);
  v7 = glpSANode(a1, Dimension);
  if (v7 == -1)
    return glpSAFailed();
  glpArrayTypeNodeSetDimension(v2, v7);
  if (v5 == -1)
    return glpSAFailed();
  v25 = 0;
  glpASTNodeGetLocation(v2, &v24);
  v8 = glpArrayTypeNodeGetDimension(v2);
  v9 = glpEvaluateArraySize(a1, (__int128 *)&v24, v8, &v25);
  if (!v9)
    return glpSAFailed();
  v10 = v9;
  v11 = glpArrayTypeNodeGetElementType(v2);
  SaFlags = glpASTNodeGetSaFlags(v11);
  Allocator = glpCompilerGetAllocator(a1);
  SaType = glpASTNodeGetSaType(v11);
  ArrayType = glpMakeArrayType(Allocator, SaType, v25, -1);
  glpASTNodeSetSaType(v2, ArrayType);
  if (glpIsQualifiedTypeNode(v11))
  {
    v16 = glpCompilerGetAllocator(a1);
    glpASTNodeGetLocation(v2, &v23);
    glpMakeQualifiedTypeNode(v16, &v23);
    v18 = v17;
    glpQualifiedTypeNodeSetType(v17, v2);
    Type = glpQualifiedTypeNodeGetType(v11);
    glpArrayTypeNodeSetElementType(v2, Type);
    Qualifiers = glpQualifiedTypeNodeGetQualifiers(v11);
    glpQualifiedTypeNodeSetQualifiers(v18, Qualifiers);
    glpASTNodeSetSaType(v18, ArrayType);
    v2 = v18;
  }
  if (v10 == 3)
    v21 = SaFlags | 0x8000000;
  else
    v21 = SaFlags;
  glpASTNodeSetSaFlags(v2, v21);
  return v2;
}

uint64_t glpSAFieldDeclaration(uint64_t a1, uint64_t a2)
{
  uint64_t Type;
  uint64_t v5;
  char *PrimitiveType;

  Type = glpFieldDeclarationNodeGetType(a2);
  v5 = glpSANode(a1, Type);
  if (v5 == -1)
    return glpSAFailed();
  glpFieldDeclarationNodeSetType(a2, v5);
  PrimitiveType = glpGetPrimitiveType(0);
  glpASTNodeSetSaType(a2, (uint64_t)PrimitiveType);
  return a2;
}

uint64_t glpSAStructType(uint64_t a1, uint64_t a2)
{
  const char *Name;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t FieldCount;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  size_t v21;
  unint64_t v22;
  uint64_t Field;
  uint64_t Type;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t *v29;
  char **v30;
  _QWORD *Allocator;
  unsigned int v32;
  uint64_t v33;
  char *v34;
  unsigned int *StructType;
  uint64_t NameTable;
  uint64_t v37;
  uint64_t **InfoLog;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t **v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t **v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t **v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t *v61;
  char *v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  __n128 v68;
  __n128 v69;
  _QWORD v70[7];
  uint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int *v75;
  unsigned int **v76;
  uint64_t v77;
  int v78;
  __n128 v79;
  __n128 v80;
  __n128 v81;
  uint64_t v82;
  uint64_t *v83[3];

  v83[1] = *(uint64_t **)MEMORY[0x24BDAC8D0];
  if (glpSAStructure(a1, a2) == -1)
    return glpSAFailed();
  Name = (const char *)glpStructTypeNodeGetName(a2);
  v6 = v5;
  v7 = glpCheckName(a1, a2, Name, v5);
  if (v7 == -1)
    return glpSAFailed();
  v8 = v7;
  v62 = (char *)Name;
  v63 = v6;
  FieldCount = glpStructureNodeGetFieldCount(v7);
  v64 = &v60;
  MEMORY[0x24BDAC7A8](FieldCount);
  v11 = &v60 - 2 * v10;
  v12 = glpStructureNodeGetFieldCount(v8);
  MEMORY[0x24BDAC7A8](v12);
  if (v13 >= 0x200)
    v15 = 512;
  else
    v15 = v13;
  v67 = (uint64_t)&v60 - v14;
  bzero((char *)&v60 - v14, v15);
  v16 = glpStructureNodeGetFieldCount(v8);
  MEMORY[0x24BDAC7A8](v16);
  v66 = (uint64_t)&v60 - v17;
  v18 = glpStructureNodeGetFieldCount(v8);
  MEMORY[0x24BDAC7A8](v18);
  if (v19 >= 0x200)
    v21 = 512;
  else
    v21 = v19;
  v65 = (uint64_t)&v60 - v20;
  bzero((char *)&v60 - v20, v21);
  if (glpStructureNodeGetFieldCount(v8))
  {
    v22 = 0;
    v61 = v11 + 1;
    do
    {
      Field = glpStructureNodeGetField(v8, v22);
      v75 = 0;
      v71 = 0;
      v82 = 0;
      v83[0] = 0;
      glpASTNodeGetLocation(Field, &v81);
      Type = glpFieldDeclarationNodeGetType(Field);
      if (!glpEvaluateTypeNode(a1, (__int128 *)&v81, 8u, 1, Type, 0, &v75, (uint64_t)&v71, v83, &v82))
        return glpSAFailed();
      v25 = (char *)glpFieldDeclarationNodeGetName(Field);
      v27 = v26;
      if (v22)
      {
        v28 = v22;
        v29 = v61;
        while (!glpStringsEqual((const char *)*(v29 - 1), *v29, v25, v27))
        {
          v29 += 2;
          if (!--v28)
            goto LABEL_16;
        }
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(Field, &v80);
        glpLogMessage(InfoLog, 0, (uint64_t)&v80, "Duplicate field name '%.*s' in struct type '%.*s'", v40, v41, v42, v43, v27);
        return glpSAFailed();
      }
LABEL_16:
      if (glpTypeGetKind(v75) == 2 && glpArrayTypeGetElementCount((uint64_t)v75) == -1)
      {
        v55 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v8, &v79);
        glpLogMessage(v55, 0, (uint64_t)&v79, "Unsized array field '%.*s' in struct type '%.*s'", v56, v57, v58, v59, v27);
        return glpSAFailed();
      }
      v30 = (char **)&v11[2 * v22];
      *v30 = v25;
      v30[1] = (char *)v27;
      *(_QWORD *)(v67 + 8 * v22) = v75;
      *(_QWORD *)(v66 + 8 * v22) = v71 | 0x2000000;
      *(_QWORD *)(v65 + 8 * v22++) = 0;
    }
    while (v22 < glpStructureNodeGetFieldCount(v8));
  }
  Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
  v32 = glpStructureNodeGetFieldCount(v8);
  v34 = v62;
  v33 = v63;
  StructType = (unsigned int *)glpMakeStructType(Allocator, (uint64_t)v62, v63, v32, (uint64_t)v11, v67, v66, v65);
  glpASTNodeSetSaType(v8, (uint64_t)StructType);
  if (glpStringsEqual("<<unnamed>>", 0x725D7890000000BLL, v34, v33))
    goto LABEL_33;
  NameTable = glpCompilerGetNameTable(a1);
  v75 = 0;
  v76 = &v75;
  v77 = 0x2000000000;
  v78 = 0;
  v71 = 0;
  v72 = &v71;
  v73 = 0x2000000000;
  v74 = 0;
  v70[0] = MEMORY[0x24BDAC760];
  v70[1] = 0x40000000;
  v70[2] = __glpSAStructType_block_invoke;
  v70[3] = &unk_24F4B33D8;
  v70[5] = &v71;
  v70[6] = NameTable;
  v70[4] = &v75;
  glpNameTableGet(NameTable, v34, v33, 2, (uint64_t)v70);
  v37 = v72[3];
  if (!v37)
  {
    glpNameTablePut(NameTable, v34, v33, 6, (uint64_t)StructType);
    goto LABEL_28;
  }
  if (*((_DWORD *)v76 + 6) == 6)
  {
    if (glpTypesEqual(StructType, v37))
    {
      glpASTNodeSetSaType(v8, v72[3]);
LABEL_28:
      v44 = 1;
      goto LABEL_32;
    }
    v50 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v8, &v69);
    glpLogMessage(v50, 0, (uint64_t)&v69, "Redeclaration of struct '%.*s' does not match previous declaration", v51, v52, v53, v54, v33);
  }
  else
  {
    v45 = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v8, &v68);
    glpLogMessage(v45, 0, (uint64_t)&v68, "Attempt to redeclare '%.*s' as a struct", v46, v47, v48, v49, v33);
  }
  StructType = (unsigned int *)glpSAFailed();
  v44 = 0;
LABEL_32:
  _Block_object_dispose(&v71, 8);
  _Block_object_dispose(&v75, 8);
  if (v44)
  {
LABEL_33:
    glpStructureNodeClearFields(v8);
    return v8;
  }
  return (uint64_t)StructType;
}

uint64_t glpSAInterfaceBlock(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t Dimension;
  uint64_t v5;
  uint64_t ImmediateSAContext;
  char *PrimitiveType;
  uint64_t NameTable;
  unsigned int Language;
  uint64_t Qualifiers;
  uint64_t TopLevelNode;
  uint64_t GlobalTypeQualifier;
  uint64_t Allocator;
  _QWORD *v14;
  _QWORD **Layout;
  _QWORD *LayoutObject;
  uint64_t **InfoLog;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  char v25;
  const char *v26;
  char *BlockName;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _BOOL4 v38;
  char *String;
  uint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t **v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t **v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t FieldCount;
  unsigned int v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  unint64_t v58;
  uint64_t v59;
  size_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t Field;
  uint64_t v66;
  const char *Name;
  uint64_t v68;
  uint64_t v69;
  uint64_t StructTypeFromIBType;
  unsigned int FieldIndex;
  _QWORD **ElementLayout;
  uint64_t v73;
  uint64_t Type;
  _QWORD *v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t *v80;
  uint64_t v81;
  uint64_t v82;
  int HasInstanceName;
  uint64_t v84;
  uint64_t *v85;
  uint64_t v86;
  char v87;
  char *InstanceName;
  uint64_t v89;
  uint64_t v90;
  uint64_t **v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  _QWORD *v96;
  uint64_t *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  _QWORD *v104;
  uint64_t v105;
  uint64_t v106;
  unsigned int *StructType;
  uint64_t v108;
  int IsArray;
  uint64_t v110;
  char *v111;
  int v112;
  uint64_t **v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  uint64_t v119;
  int ImpliedBankSize;
  uint64_t **v121;
  char v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t **v127;
  const char *v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t **v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t **v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  _QWORD *v144;
  uint64_t UnnamedInterfaceBlockObject;
  uint64_t *v146;
  const char *v147;
  uint64_t v148;
  uint64_t v149;
  int DefCount;
  int v151;
  unsigned int v152;
  uint64_t Def;
  uint64_t Extra;
  uint64_t **v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  char v160[4];
  unsigned int v161;
  char *v162;
  char *v163;
  uint64_t v164;
  char *v165;
  _BOOL4 v166;
  uint64_t v167;
  uint64_t *StringBuffer;
  uint64_t v169;
  char *v170;
  char *v171;
  char *v172;
  _QWORD **v173;
  uint64_t v174;
  __n128 v175;
  __n128 v176;
  __n128 v177;
  __n128 v178;
  __n128 v179;
  __n128 v180;
  __n128 v181;
  __n128 v182;
  __n128 v183;
  __n128 v184;
  uint64_t v185;
  uint64_t *v186;
  uint64_t v187;
  __n128 v188;
  __n128 v189;
  _QWORD v190[5];
  __n128 v191;
  _QWORD v192[6];
  unsigned int *v193;
  unsigned int **v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t *v198;
  uint64_t v199;
  uint64_t v200;
  __n128 v201;
  uint64_t v202;
  _QWORD *v203;
  uint64_t v204;
  __n128 v205;
  uint64_t v206;

  v2 = a2;
  v206 = *MEMORY[0x24BDAC8D0];
  if (glpSAStructure(a1, a2) == -1)
    return glpSAFailed();
  Dimension = glpInterfaceBlockNodeGetDimension(v2);
  v5 = glpSANode(a1, Dimension);
  if (v5 == -1)
    return glpSAFailed();
  glpInterfaceBlockNodeSetDimension(v2, v5);
  ImmediateSAContext = glpCompilerGetImmediateSAContext(a1);
  if (!glpIsTopLevelNode(ImmediateSAContext))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v205);
    glpLogMessage(InfoLog, 0, (uint64_t)&v205, "Interface blocks may only be declared at global scope", v19, v20, v21, v22, v160[0]);
    return glpSAFailed();
  }
  PrimitiveType = glpGetPrimitiveType(0);
  glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
  NameTable = glpCompilerGetNameTable(a1);
  Language = glpNameTableGetLanguage(NameTable);
  v203 = 0;
  v204 = 0;
  v202 = 0;
  Qualifiers = glpInterfaceBlockNodeGetQualifiers(v2);
  if (!glpParseQualifiers(a1, 7u, Qualifiers, 0, &v204, &v203, &v202))
    return glpSAFailed();
  TopLevelNode = glpCompilerGetTopLevelNode(a1);
  GlobalTypeQualifier = glpTopLevelNodeGetGlobalTypeQualifier(TopLevelNode, 0x100000000);
  Allocator = glpCompilerGetAllocator(a1);
  v14 = (_QWORD *)Allocator;
  if (GlobalTypeQualifier)
  {
    Layout = (_QWORD **)glpGlobalTypeQualifierNodeGetLayout(GlobalTypeQualifier);
    LayoutObject = glpCopyLayoutObject(v14, Layout);
  }
  else
  {
    LayoutObject = glpMakeLayoutObject(Allocator);
  }
  v23 = LayoutObject;
  if (v203)
  {
    v24 = glpCompilerGetAllocator(a1);
    glpASTNodeGetLocation(v2, &v201);
    if (!glpLayoutObjectAppendMany(v24, a1, (uint64_t)&v201, v23, (_QWORD **)v203))
      return glpSAFailed();
  }
  if ((v204 & 0x100000000) != 0)
  {
    v25 = 117;
    v26 = "uniform";
  }
  else if ((v204 & 0x20000000) != 0)
  {
    v25 = 105;
    v26 = "in";
  }
  else
  {
    if ((v204 & 0x40000000) == 0)
      goto LABEL_105;
    v25 = 111;
    v26 = "out";
  }
  v167 = (uint64_t)v26;
  BlockName = (char *)glpInterfaceBlockNodeGetBlockName(v2);
  v29 = v28;
  v30 = (_QWORD *)glpCompilerGetAllocator(a1);
  StringBuffer = glpMakeStringBuffer(v30);
  glpStringBufferAppendFormat(StringBuffer, "$IB$%c$5%.*s", v31, v32, v33, v34, v35, v36, v25);
  v197 = 0;
  v198 = &v197;
  v199 = 0x2000000000;
  LODWORD(v200) = 0;
  v193 = 0;
  v194 = &v193;
  v195 = 0x2000000000;
  v196 = 0;
  v37 = MEMORY[0x24BDAC760];
  v192[0] = MEMORY[0x24BDAC760];
  v192[1] = 0x40000000;
  v192[2] = __glpSAInterfaceBlock_block_invoke;
  v192[3] = &unk_24F4B3400;
  v192[4] = &v197;
  v192[5] = &v193;
  v38 = glpNameTableGet(NameTable, BlockName, v29, 2, (uint64_t)v192);
  if (!v194[3] || *((_DWORD *)v198 + 6) == 2)
  {
    v166 = v38;
    _Block_object_dispose(&v193, 8);
    _Block_object_dispose(&v197, 8);
    v197 = 0;
    v198 = &v197;
    v199 = 0x2000000000;
    v200 = 0;
    String = (char *)glpStringBufferGetString((uint64_t)StringBuffer);
    v190[0] = v37;
    v190[1] = 0x40000000;
    v190[2] = __glpSAInterfaceBlock_block_invoke_2;
    v190[3] = &unk_24F4B3428;
    v190[4] = &v197;
    glpNameTableGet(NameTable, String, v40, 0, (uint64_t)v190);
    v41 = v198[3];
    if (v41)
    {
      v42 = *(uint64_t **)(v41 + 56);
      if (!v42 || !glpLayoutObjectFind(v42, 82) && !glpLayoutObjectFind(*(uint64_t **)(v198[3] + 56), 81))
      {
        v43 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v189);
        glpLogMessage(v43, 0, (uint64_t)&v189, "Cannot redeclare interface block '%s %.*s'", v44, v45, v46, v47, v167);
        v2 = -1;
LABEL_110:
        _Block_object_dispose(&v197, 8);
        return v2;
      }
    }
    else
    {
      v2 = glpCheckName(a1, v2, BlockName, v29);
      if (v2 == -1)
        goto LABEL_109;
    }
    v164 = v29;
    v165 = BlockName;
    v161 = Language;
    v173 = (_QWORD **)v23;
    FieldCount = glpStructureNodeGetFieldCount(v2);
    v54 = FieldCount;
    v55 = MEMORY[0x24BDAC7A8](FieldCount);
    v174 = v56;
    v57 = &v160[-16 * v56];
    v58 = 8 * v54;
    MEMORY[0x24BDAC7A8](v55);
    v59 = (v58 + 15) & 0xFFFFFFFF0;
    if (v58 >= 0x200)
      v60 = 512;
    else
      v60 = 8 * v54;
    v172 = &v160[-v59];
    bzero(&v160[-v59], v60);
    v62 = MEMORY[0x24BDAC7A8](v61);
    v171 = &v160[-v59];
    MEMORY[0x24BDAC7A8](v62);
    v170 = &v160[-v59];
    bzero(&v160[-v59], v60);
    if (v54)
    {
      v169 = NameTable;
      v162 = v160;
      v163 = v57;
      v63 = 0;
      v64 = (uint64_t *)(v57 + 8);
      do
      {
        Field = glpStructureNodeGetField(v2, v63);
        Name = (const char *)glpFieldDeclarationNodeGetName(Field);
        v68 = v66;
        v69 = v198[3];
        if (v69)
        {
          StructTypeFromIBType = glpGetStructTypeFromIBType(*(unsigned int **)(v69 + 64));
          FieldIndex = glpStructTypeGetFieldIndex(StructTypeFromIBType, Name, v68);
          if (FieldIndex == -1)
          {
            v113 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(v2, &v188);
            glpLogMessage(v113, 0, (uint64_t)&v188, "Field name '%.*s' in redeclaration of '%s %.*s' was not in previous declaration", v114, v115, v116, v117, v68);
            goto LABEL_109;
          }
          ElementLayout = (_QWORD **)glpAggregateTypeGetElementLayout(StructTypeFromIBType, FieldIndex);
        }
        else
        {
          v73 = glpCheckName(a1, Field, Name, v66);
          if (v73 == -1)
            goto LABEL_109;
          Field = v73;
          ElementLayout = 0;
        }
        v193 = 0;
        v186 = 0;
        v187 = 0;
        v185 = 0;
        glpASTNodeGetLocation(v2, &v184);
        Type = glpFieldDeclarationNodeGetType(Field);
        if (!glpEvaluateTypeNode(a1, (__int128 *)&v184, 9u, 1, Type, v204, &v193, (uint64_t)&v187, &v186, &v185))goto LABEL_109;
        v75 = (_QWORD *)glpCompilerGetAllocator(a1);
        v76 = glpCopyLayoutObject(v75, v173);
        if (v198[3])
        {
          v77 = glpCompilerGetAllocator(a1);
          glpASTNodeGetLocation(v2, &v183);
          if (!glpLayoutObjectAppendMany(v77, a1, (uint64_t)&v183, v76, ElementLayout))
            goto LABEL_109;
          v78 = glpCompilerGetAllocator(a1);
          glpLayoutObjectRemove(v78, v76, 82);
        }
        v79 = glpCompilerGetAllocator(a1);
        glpASTNodeGetLocation(v2, &v182);
        if (!glpLayoutObjectAppendMany(v79, a1, (uint64_t)&v182, v76, (_QWORD **)v186))
          goto LABEL_109;
        if (v76)
        {
          v80 = glpLayoutObjectFind(v76, 24);
          v81 = v187;
          if (v80)
          {
            v81 = v187 | 0x400;
            v187 |= 0x400uLL;
          }
        }
        else
        {
          v81 = v187;
        }
        *(v64 - 1) = (uint64_t)Name;
        *v64 = v68;
        *(_QWORD *)&v172[8 * v63] = v193;
        *(_QWORD *)&v171[8 * v63] = v204 | v81;
        v82 = v169;
        *(_QWORD *)&v170[8 * v63] = v76;
        if (glpNameTableGetGLSLVersion(v82) == 6
          && glpTypeGetKind(v193) == 2
          && glpArrayTypeGetElementCount((uint64_t)v193) == -1)
        {
          v133 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(v2, &v181);
          glpLogMessage(v133, 0, (uint64_t)&v181, "Unsized array '%.*s' not allowed under GLSL 300", v134, v135, v136, v137, *(_DWORD *)v64);
          goto LABEL_109;
        }
        ++v63;
        v64 += 2;
      }
      while (v174 != v63);
      HasInstanceName = glpInterfaceBlockNodeGetHasInstanceName(v2);
      v57 = v163;
      NameTable = v169;
      if (!HasInstanceName)
      {
        v84 = v174;
        if ((_DWORD)v174)
        {
          v85 = (uint64_t *)(v163 + 8);
          v86 = v174;
          while (!glpNameTableGet(NameTable, (char *)*(v85 - 1), *v85, 2, (uint64_t)&__block_literal_global_138))
          {
            v85 += 2;
            if (!--v86)
            {
              v167 = 0xDFA3F2CD0000004BLL;
              v87 = 1;
              InstanceName = "<<BUG: printing instance name of interface block without an instance name>>";
              goto LABEL_65;
            }
          }
          v155 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(v2, &v179);
          glpLogMessage(v155, 0, (uint64_t)&v179, "Field name '%.*s' of interface block without instance name '%.*s' would shadow a previous declaration", v156, v157, v158, v159, *(_DWORD *)v85);
          goto LABEL_109;
        }
        v167 = 0xDFA3F2CD0000004BLL;
        InstanceName = "<<BUG: printing instance name of interface block without an instance name>>";
        v87 = 1;
        goto LABEL_65;
      }
    }
    else if (!glpInterfaceBlockNodeGetHasInstanceName(v2))
    {
      v163 = v57;
      v167 = 0xDFA3F2CD0000004BLL;
      InstanceName = "<<BUG: printing instance name of interface block without an instance name>>";
      v87 = 1;
      v84 = v174;
      goto LABEL_65;
    }
    InstanceName = (char *)glpInterfaceBlockNodeGetInstanceName(v2);
    v90 = v89;
    v84 = v174;
    if (!v198[3])
    {
      v2 = glpCheckName(a1, v2, InstanceName, v89);
      if (v2 == -1)
      {
LABEL_109:
        v2 = glpSAFailed();
        goto LABEL_110;
      }
    }
    if (glpNameTableGet(NameTable, InstanceName, v90, 2, (uint64_t)&__block_literal_global_135))
    {
      v91 = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v2, &v180);
      glpLogMessage(v91, 0, (uint64_t)&v180, "Interface block instance name '%.*s' would shadow a previous declaration", v92, v93, v94, v95, v90);
      v2 = -1;
      goto LABEL_110;
    }
    v167 = v90;
    v163 = v57;
    v87 = 0;
LABEL_65:
    v96 = (_QWORD *)glpCompilerGetAllocator(a1);
    v97 = glpMakeStringBuffer(v96);
    glpStringBufferAppendFormat(v97, "$InterfaceBlockStruct$%.*s", v98, v99, v100, v101, v102, v103, v164);
    v104 = (_QWORD *)glpCompilerGetAllocator(a1);
    v105 = glpStringBufferGetString((uint64_t)v97);
    StructType = (unsigned int *)glpMakeStructType(v104, v105, v106, v84, (uint64_t)v163, (uint64_t)v172, (uint64_t)v171, (uint64_t)v170);
    v108 = v204;
    IsArray = glpInterfaceBlockNodeGetIsArray(v2);
    LODWORD(v193) = 1;
    if (!IsArray)
    {
LABEL_89:
      v144 = (_QWORD *)glpCompilerGetAllocator(a1);
      if ((v87 & 1) != 0)
      {
        UnnamedInterfaceBlockObject = glpMakeUnnamedInterfaceBlockObject(v144, (uint64_t)v165, v164, v204, 1, StructType);
        if ((_DWORD)v84)
        {
          v146 = (uint64_t *)(v163 + 8);
          do
          {
            glpNameTablePut(NameTable, (const char *)*(v146 - 1), *v146, 3, UnnamedInterfaceBlockObject);
            v146 += 2;
            --v84;
          }
          while (v84);
        }
      }
      else
      {
        UnnamedInterfaceBlockObject = glpMakeNamedInterfaceBlockObject(v144, (uint64_t)v165, v164, (uint64_t)InstanceName, v167, v204, 1, StructType);
      }
      *(_QWORD *)(UnnamedInterfaceBlockObject + 56) = v173;
      if (!v166)
        glpNameTablePut(NameTable, v165, v164, 2, UnnamedInterfaceBlockObject);
      v147 = (const char *)glpStringBufferGetString((uint64_t)StringBuffer);
      glpNameTablePut(NameTable, v147, v148, 2, UnnamedInterfaceBlockObject);
      if ((v87 & 1) == 0)
        glpNameTablePut(NameTable, InstanceName, v167, 1, UnnamedInterfaceBlockObject);
      glpInterfaceBlockNodeSetExtra(v2, UnnamedInterfaceBlockObject);
      glpInterfaceBlockNodeSetQualifiers(v2, 0);
      glpInterfaceBlockNodeSetDimension(v2, 0);
      glpStructureNodeClearFields(v2);
      if (!v198[3])
        goto LABEL_110;
      v149 = glpCompilerGetTopLevelNode(a1);
      DefCount = glpTopLevelNodeGetDefCount(v149);
      if (DefCount)
      {
        v151 = DefCount;
        v152 = 0;
        while (1)
        {
          Def = glpTopLevelNodeGetDef(v149, v152);
          if (glpIsInterfaceBlockNode(Def))
          {
            Extra = glpInterfaceBlockNodeGetExtra(Def);
            if (Extra == v198[3])
              break;
          }
          if (v151 == ++v152)
            goto LABEL_105;
        }
        glpTopLevelNodeSetDef(v149, v152, v2);
        v2 = 0;
        goto LABEL_110;
      }
LABEL_105:
      abort();
    }
    v110 = v108 & 0x160000000;
    v111 = InstanceName;
    switch(v110)
    {
      case 0x100000000:
        v118 = 5;
LABEL_74:
        glpASTNodeGetLocation(v2, &v177);
        v119 = glpInterfaceBlockNodeGetDimension(v2);
        if (!glpEvaluateArraySize(a1, (__int128 *)&v177, v119, (int *)&v193))
          goto LABEL_109;
        ImpliedBankSize = glpCompilerGetImpliedBankSize(a1, v118);
        if ((_DWORD)v193 == -1)
        {
          LODWORD(v193) = ImpliedBankSize;
          if (v118 == 5 && ImpliedBankSize == -1)
          {
            v138 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(v2, &v175);
            glpLogMessage(v138, 0, (uint64_t)&v175, "Uniform interface block arrays must be sized", v139, v140, v141, v142, v160[0]);
            goto LABEL_109;
          }
        }
        else if (ImpliedBankSize != -1 && (_DWORD)v193 != ImpliedBankSize)
        {
          v121 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(v2, &v176);
          v122 = (char)v193;
          glpLanguageToString(v161);
          glpLogMessage(v121, 0, (uint64_t)&v176, "Declared size (%u) of %s interface block array in the %s shader is incompatible with earlier declarations (expected %u)", v123, v124, v125, v126, v122);
          goto LABEL_109;
        }
        v143 = glpCompilerGetAllocator(a1);
        StructType = (unsigned int *)glpMakeBankType(v143, v118, (uint64_t)StructType, (int)v193);
        v84 = v174;
        InstanceName = v111;
        goto LABEL_89;
      case 0x40000000:
        v112 = glpBankForOutputsInLanguage(v161);
        break;
      case 0x20000000:
        v112 = glpBankForInputsInLanguage(v161);
        break;
      default:
LABEL_79:
        v127 = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v178);
        if ((v204 & 0x20000000) != 0)
          v128 = "in";
        else
          v128 = "out";
        glpLanguageToString(v161);
        glpLogMessage(v127, 0, (uint64_t)&v178, "Interface block array not allowed as %s in %s shader", v129, v130, v131, v132, (char)v128);
        goto LABEL_109;
    }
    v118 = v112;
    if (v112)
      goto LABEL_74;
    goto LABEL_79;
  }
  v48 = (uint64_t **)glpCompilerGetInfoLog(a1);
  glpASTNodeGetLocation(v2, &v191);
  glpLogMessage(v48, 0, (uint64_t)&v191, "Interface block name '%.*s' would shadow a previous declaration", v49, v50, v51, v52, v29);
  _Block_object_dispose(&v193, 8);
  _Block_object_dispose(&v197, 8);
  return -1;
}

uint64_t glpSALayoutType(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v4;
  int v5;
  uint64_t LayoutPair;
  uint64_t v7;
  uint64_t LayoutPairCount;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  unsigned int v21;
  signed int v22;
  int v23;
  uint64_t v24;
  const void *Identifier;
  unsigned int v26;
  unsigned int v27;
  uint64_t Allocator;
  char *v29;
  uint64_t v30;
  int v31;
  int ValueKind;
  uint64_t Type;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  char *v37;
  char *v38;
  char *v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  size_t ArrayType;
  _QWORD *v45;
  uint64_t **InfoLog;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t **v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t **v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t **v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t **v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t *v74;
  int v75;
  _QWORD *v76;
  uint64_t v77;
  char *v78;
  char *v79;
  char *v80;
  const char *v81;
  uint64_t v82;
  int v83;
  int Value;
  uint64_t v85;
  uint64_t *v86;
  size_t SaType;
  __n128 v88;
  __n128 v89;
  __n128 v90;
  __n128 v91;
  __n128 v92;
  int v93;
  uint64_t v94;

  v2 = a2;
  v94 = *MEMORY[0x24BDAC8D0];
  if (glpLayoutTypeNodeGetLayoutPairCount(a2))
  {
    v4 = 0;
    v5 = 1;
    do
    {
      LayoutPair = glpLayoutTypeNodeGetLayoutPair(v2, v4);
      v7 = glpSANode(a1, LayoutPair);
      if (v7 == -1)
        v5 = 0;
      else
        glpLayoutTypeNodeSetLayoutPair(v2, v4, v7);
      ++v4;
    }
    while (v4 < glpLayoutTypeNodeGetLayoutPairCount(v2));
    if (!v5)
      return glpSAFailed();
  }
  LayoutPairCount = glpLayoutTypeNodeGetLayoutPairCount(v2);
  v86 = &v73;
  SaType = 16 * LayoutPairCount;
  v9 = MEMORY[0x24BDAC7A8](LayoutPairCount);
  v11 = &v73 - 2 * v10;
  v12 = 8 * LayoutPairCount;
  MEMORY[0x24BDAC7A8](v9);
  v13 = (v12 + 15) & 0xFFFFFFFF0;
  v14 = (char *)&v73 - v13;
  if (v12 >= 0x200)
    v15 = 512;
  else
    v15 = 8 * LayoutPairCount;
  bzero((char *)&v73 - v13, v15);
  v17 = MEMORY[0x24BDAC7A8](v16);
  v18 = (char *)&v73 - v13;
  MEMORY[0x24BDAC7A8](v17);
  v19 = (char *)&v73 - v13;
  v20 = LayoutPairCount;
  bzero(v19, v15);
  bzero(v11, SaType);
  v80 = v14;
  bzero(v14, 8 * LayoutPairCount);
  v79 = v18;
  bzero(v18, 8 * LayoutPairCount);
  v78 = v19;
  bzero(v19, 8 * LayoutPairCount);
  if ((_DWORD)LayoutPairCount)
  {
    SaType = 0;
    v21 = 0;
    v22 = 0;
    v85 = 0;
    v81 = 0;
    v82 = 0;
    v74 = v11;
    v76 = v11 + 1;
    v75 = v20 - 1;
    v23 = -1;
    v83 = -1;
    Value = -1;
    v77 = v20;
    while (2)
    {
      v24 = glpLayoutTypeNodeGetLayoutPair(v2, v21);
      Identifier = (const void *)glpLayoutPairNodeGetIdentifier(v24);
      v27 = v26;
      v93 = 0;
      Allocator = glpCompilerGetAllocator(a1);
      v29 = glpLowerCaseCopyOfString(Allocator, Identifier, v27);
      if (!glpLayoutQualifierFromString(v29, v30, &v93))
      {
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v92);
        glpLogMessage(InfoLog, 0, (uint64_t)&v92, "Unknown identifier '%.*s' in layout", v48, v49, v50, v51, v27);
        return glpSAFailed();
      }
      v31 = glpLayoutQualifierValueBehavior(v93);
      ValueKind = glpLayoutPairNodeGetValueKind(v24);
      switch(v31)
      {
        case 0:
          if (!ValueKind)
            goto LABEL_22;
          v53 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(v2, &v91);
          glpLogMessage(v53, 0, (uint64_t)&v91, "Identifier '%.*s' in layout must not have a value", v54, v55, v56, v57, v27);
          return glpSAFailed();
        case 1:
          if (ValueKind == 1)
            goto LABEL_22;
          v58 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(v2, &v90);
          glpLogMessage(v58, 0, (uint64_t)&v90, "Identifier '%.*s' in layout must have a value", v59, v60, v61, v62, v27);
          return glpSAFailed();
        case 2:
          if (ValueKind == 2)
            goto LABEL_22;
          v63 = (uint64_t **)glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(v2, &v89);
          glpLogMessage(v63, 0, (uint64_t)&v89, "Identifier '%.*s' in layout must have a type", v64, v65, v66, v67, v27);
          return glpSAFailed();
        case 3:
          if (ValueKind != 3)
          {
            v68 = (uint64_t **)glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(v2, &v88);
            glpLogMessage(v68, 0, (uint64_t)&v88, "Identifier '%.*s' in layout must have a string", v69, v70, v71, v72, v27);
            return glpSAFailed();
          }
LABEL_22:
          switch(v93)
          {
            case 'U':
              Type = glpLayoutPairNodeGetType(v24);
              SaType = glpASTNodeGetSaType(Type);
              goto LABEL_32;
            case 'V':
              v34 = glpLayoutPairNodeGetType(v24);
              v85 = glpASTNodeGetSaType(v34);
              v23 = 2;
              goto LABEL_32;
            case 'W':
              Value = glpLayoutPairNodeGetValue(v24);
              goto LABEL_32;
            case 'X':
              v83 = glpLayoutPairNodeGetValue(v24);
              goto LABEL_32;
            case 'Y':
              if (v21 + 1 >= v20)
              {
                v23 = 1;
                v82 = 0x725D7890000000BLL;
                v81 = "<<unnamed>>";
                ++v21;
              }
              else
              {
                v35 = 0;
                v36 = &v76[2 * v22];
                v37 = &v80[8 * v22];
                v38 = &v79[8 * v22];
                LODWORD(v82) = v22;
                v39 = &v78[8 * v22];
                v40 = v75 - v21;
                do
                {
                  v41 = glpLayoutTypeNodeGetLayoutPair(v2, v21 + v35 + 1);
                  *(v36 - 1) = glpLayoutPairNodeGetIdentifier(v41);
                  *v36 = v42;
                  v43 = glpLayoutPairNodeGetType(v41);
                  *(_QWORD *)&v37[8 * v35] = glpASTNodeGetSaType(v43);
                  *(_QWORD *)&v38[8 * v35] = 0;
                  *(_QWORD *)&v39[8 * v35] = 0;
                  v36 += 2;
                  ++v35;
                }
                while (v40 != (_DWORD)v35);
                v22 = v82 + v35;
                v23 = 1;
                v82 = 0x725D7890000000BLL;
                v81 = "<<unnamed>>";
                LODWORD(v20) = v77;
                v21 = v77;
              }
LABEL_32:
              if (++v21 < v20)
                continue;
              if (v23 == 2)
              {
                v52 = glpCompilerGetAllocator(a1);
                ArrayType = glpMakeArrayType(v52, v85, Value, v83);
              }
              else
              {
                ArrayType = SaType;
                if (v23 == 1)
                {
                  v45 = (_QWORD *)glpCompilerGetAllocator(a1);
                  ArrayType = glpMakeStructType(v45, (uint64_t)v81, v82, v22, (uint64_t)v74, (uint64_t)v80, (uint64_t)v79, (uint64_t)v78);
                }
              }
              break;
            default:
              goto LABEL_44;
          }
          break;
        default:
LABEL_44:
          abort();
      }
      break;
    }
  }
  else
  {
    ArrayType = 0;
  }
  glpASTNodeSetSaType(v2, ArrayType);
  glpASTNodeSetSaFlags(v2, 0);
  return v2;
}

void glpSAKeywordQualifier()
{
  abort();
}

uint64_t glpSALayoutQualifier(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t LayoutPair;
  uint64_t v7;

  if (!glpLayoutQualifierNodeGetLayoutPairCount(a2))
    goto LABEL_9;
  v4 = 0;
  v5 = 1;
  do
  {
    LayoutPair = glpLayoutQualifierNodeGetLayoutPair(a2, v4);
    v7 = glpSANode(a1, LayoutPair);
    if (v7 == -1)
      v5 = 0;
    else
      glpLayoutQualifierNodeSetLayoutPair(a2, v4, v7);
    ++v4;
  }
  while (v4 < glpLayoutQualifierNodeGetLayoutPairCount(a2));
  if (v5)
LABEL_9:
    abort();
  return glpSAFailed();
}

uint64_t glpSASubroutineTypeList(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v4;
  int v5;
  uint64_t Type;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int *SaType;
  char *PrimitiveType;
  char v13;
  char v14;
  uint64_t **InfoLog;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __n128 v20;

  v2 = a2;
  if (glpSubroutineTypeListNodeGetTypeCount(a2))
  {
    v4 = 0;
    v5 = 1;
    do
    {
      Type = glpSubroutineTypeListNodeGetType(v2, v4);
      v7 = glpSANode(a1, Type);
      if (v7 == -1)
        v5 = 0;
      else
        glpSubroutineTypeListNodeSetType(v2, v4, v7);
      ++v4;
    }
    while (v4 < glpSubroutineTypeListNodeGetTypeCount(v2));
    if (!v5)
      return glpSAFailed();
  }
  if (glpSubroutineTypeListNodeGetTypeCount(v2))
  {
    v8 = 0;
    while (1)
    {
      v9 = glpSubroutineTypeListNodeGetType(v2, v8);
      SaType = (unsigned int *)glpASTNodeGetSaType(v9);
      if (glpTypeGetKind(SaType) != 5)
        break;
      if (++v8 >= glpSubroutineTypeListNodeGetTypeCount(v2))
        goto LABEL_12;
    }
    glpTypeIdentifierNodeGetName(v9);
    v14 = v13;
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v20);
    glpLogMessage(InfoLog, 0, (uint64_t)&v20, "Non-subroutine type '%.*s' in subroutine type list", v16, v17, v18, v19, v14);
    return glpSAFailed();
  }
  else
  {
LABEL_12:
    PrimitiveType = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
  }
  return v2;
}

uint64_t glpSAQualifierList(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t Qualifier;
  uint64_t v7;

  if (!glpQualifierListNodeGetQualifierCount(a2))
    goto LABEL_9;
  v4 = 0;
  v5 = 1;
  do
  {
    Qualifier = glpQualifierListNodeGetQualifier(a2, v4);
    v7 = glpSANode(a1, Qualifier);
    if (v7 == -1)
      v5 = 0;
    else
      glpQualifierListNodeSetQualifier(a2, v4, v7);
    ++v4;
  }
  while (v4 < glpQualifierListNodeGetQualifierCount(a2));
  if (v5)
LABEL_9:
    abort();
  return glpSAFailed();
}

uint64_t glpSAGlobalTypeQualifier(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t QualifierList;
  uint64_t NameTable;
  uint64_t **InfoLog;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t TopLevelNode;
  uint64_t GlobalTypeQualifier;
  uint64_t v14;
  _QWORD *Allocator;
  _QWORD **Layout;
  _QWORD *v17;
  uint64_t v18;
  char *PrimitiveType;
  char v20;
  __n128 v21;
  __n128 v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;

  v2 = a2;
  QualifierList = glpGlobalTypeQualifierNodeGetQualifierList(a2);
  v25 = 0;
  v23 = 0;
  v24 = 0;
  if (!glpParseQualifiers(a1, 2u, QualifierList, 0, &v25, &v24, &v23))
    return glpSAFailed();
  if (v24)
  {
    NameTable = glpCompilerGetNameTable(a1);
    if (!glpNameTableGetCurrentFunction(NameTable))
    {
      TopLevelNode = glpCompilerGetTopLevelNode(a1);
      GlobalTypeQualifier = glpTopLevelNodeGetGlobalTypeQualifier(TopLevelNode, v25);
      if (GlobalTypeQualifier)
      {
        v14 = GlobalTypeQualifier;
        Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
        Layout = (_QWORD **)glpGlobalTypeQualifierNodeGetLayout(v14);
        v17 = glpCopyLayoutObject(Allocator, Layout);
        v18 = glpCompilerGetAllocator(a1);
        glpASTNodeGetLocation(v2, &v22);
        if (!glpLayoutObjectAppendMany(v18, a1, (uint64_t)&v22, v17, (_QWORD **)v24))
          return glpSAFailed();
        v2 = 0;
        v24 = v17;
      }
      else
      {
        PrimitiveType = glpGetPrimitiveType(0);
        glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
        glpASTNodeSetSaFlags(v2, v25);
        glpGlobalTypeQualifierNodeSetQualifierList(v2, 0);
        v17 = v24;
        v14 = v2;
      }
      glpGlobalTypeQualifierNodeSetLayout(v14, (uint64_t)v17);
      if (glpCompilerApplyImplictRulesForGlobalTypeQualifier(a1, v14))
        return v2;
      return glpSAFailed();
    }
  }
  InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
  glpASTNodeGetLocation(v2, &v21);
  glpLogMessage(InfoLog, 0, (uint64_t)&v21, "Invalid non-global or non-layout type-qualifier", v7, v8, v9, v10, v20);
  return glpSAFailed();
}

uint64_t glpSALayoutPair(uint64_t a1, uint64_t a2)
{
  uint64_t Type;
  uint64_t v5;
  char *PrimitiveType;

  Type = glpLayoutPairNodeGetType(a2);
  v5 = glpSANode(a1, Type);
  if (v5 == -1)
    return glpSAFailed();
  glpLayoutPairNodeSetType(a2, v5);
  PrimitiveType = glpGetPrimitiveType(0);
  glpASTNodeSetSaType(a2, (uint64_t)PrimitiveType);
  return a2;
}

uint64_t glpSAExpressionStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t Expr;
  uint64_t v5;
  char *PrimitiveType;
  uint64_t v7;
  uint64_t v8;
  unsigned int *SaType;
  unsigned int *v10;
  uint64_t DefaultPrecisionForType;
  uint64_t v13;
  _QWORD *Allocator;
  char v15;
  char v16;
  uint64_t **InfoLog;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __n128 v22;

  v2 = a2;
  glpSAStatement(a2);
  Expr = glpExpressionStatementNodeGetExpr(v2);
  v5 = glpSANode(a1, Expr);
  if (v5 == -1)
    return glpSAFailed();
  glpExpressionStatementNodeSetExpr(v2, v5);
  PrimitiveType = glpGetPrimitiveType(0);
  glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
  v7 = glpExpressionStatementNodeGetExpr(v2);
  if (v7)
  {
    v8 = v7;
    SaType = (unsigned int *)glpASTNodeGetSaType(v7);
    if (glpCompilerDoesTypeRequirePrecision(a1, SaType) && (glpASTNodeGetSaFlags(v8) & 0x1F) == 0)
    {
      v10 = (unsigned int *)glpASTNodeGetSaType(v8);
      DefaultPrecisionForType = glpGetDefaultPrecisionForType(a1, v10);
      if (DefaultPrecisionForType)
      {
        glpPushdownPrecision(a1, v8, DefaultPrecisionForType);
      }
      else
      {
        v13 = glpASTNodeGetSaType(v8);
        Allocator = (_QWORD *)glpCompilerGetAllocator(a1);
        glpTypeHumanReadableDescription(v13, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, Allocator);
        v16 = v15;
        InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(v2, &v22);
        glpLogMessage(InfoLog, 0, (uint64_t)&v22, "Expression of type '%.*s' - precision can not be inferred and no default precision available", v18, v19, v20, v21, v16);
        return glpSAFailed();
      }
    }
  }
  return v2;
}

uint64_t glpSABlock(uint64_t a1, uint64_t a2)
{
  uint64_t NameTable;
  int StatementCount;
  int v6;
  int v7;
  unsigned int v8;
  uint64_t Statement;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  int v16;
  int v17;
  unsigned int v18;
  _BOOL4 IsReturnStatementNode;
  uint64_t v20;
  uint64_t v21;
  char *PrimitiveType;
  _QWORD *v23;
  _QWORD *v25;

  glpSAStatement(a2);
  if (glpBlockNodeGetNeedsNewScope(a2))
  {
    NameTable = glpCompilerGetNameTable(a1);
    glpNameTablePush(NameTable, a2);
  }
  StatementCount = glpBlockNodeGetStatementCount(a2);
  if (!StatementCount)
    goto LABEL_17;
  v6 = -StatementCount;
  v7 = 1;
  do
  {
    v8 = glpBlockNodeGetStatementCount(a2) + v6;
    Statement = glpBlockNodeGetStatement(a2, v8);
    if (Statement)
    {
      v10 = Statement;
      v11 = glpCompilerGetNameTable(a1);
      glpNameTableSetStatementIndex(v11, v8);
      v12 = glpSANode(a1, v10);
      v13 = glpBlockNodeGetStatementCount(a2);
      if (v12 != -1)
        glpBlockNodeSetStatement(a2, v13 + v6, v12);
      if (v7)
        v14 = v12 == -1;
      else
        v14 = 1;
      v7 = !v14;
    }
  }
  while (!__CFADD__(v6++, 1));
  if (!v7)
  {
    if (glpBlockNodeGetNeedsNewScope(a2))
    {
      v25 = (_QWORD *)glpCompilerGetNameTable(a1);
      glpNameTablePop(v25);
    }
    return glpSAFailed();
  }
  else
  {
LABEL_17:
    v16 = glpBlockNodeGetStatementCount(a2);
    if (v16)
    {
      v17 = v16;
      v18 = 0;
      IsReturnStatementNode = 0;
      do
      {
        v20 = glpBlockNodeGetStatement(a2, v18);
        if (v20)
        {
          v21 = v20;
          if (IsReturnStatementNode && !glpIsCaseStatementNode(v20) && !glpIsDefaultStatementNode(v21))
          {
            glpBlockNodeSetStatement(a2, v18, 0);
LABEL_28:
            IsReturnStatementNode = 1;
            goto LABEL_29;
          }
          if (glpIsDiscardStatementNode(v21) || glpIsBreakStatementNode(v21) || glpIsContinueStatementNode(v21))
            goto LABEL_28;
          IsReturnStatementNode = glpIsReturnStatementNode(v21);
        }
LABEL_29:
        ++v18;
      }
      while (v17 != v18);
    }
    PrimitiveType = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(a2, (uint64_t)PrimitiveType);
    if (glpBlockNodeGetNeedsNewScope(a2))
    {
      v23 = (_QWORD *)glpCompilerGetNameTable(a1);
      glpNameTablePop(v23);
    }
    return a2;
  }
}

uint64_t glpSAIfStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t Cond;
  uint64_t v5;
  int v6;
  uint64_t IfStatement;
  uint64_t v8;
  uint64_t ElseStatement;
  uint64_t v10;
  uint64_t v11;
  unsigned int *SaType;
  char *PrimitiveType;
  char *v14;
  uint64_t **InfoLog;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  __n128 v22;

  v2 = a2;
  glpSAStatement(a2);
  Cond = glpIfStatementNodeGetCond(v2);
  v5 = glpSANode(a1, Cond);
  if (v5 == -1)
  {
    v6 = 0;
  }
  else
  {
    glpIfStatementNodeSetCond(v2, v5);
    v6 = 1;
  }
  IfStatement = glpIfStatementNodeGetIfStatement(v2);
  v8 = glpSANode(a1, IfStatement);
  if (v8 == -1)
    v6 = 0;
  else
    glpIfStatementNodeSetIfStatement(v2, v8);
  ElseStatement = glpIfStatementNodeGetElseStatement(v2);
  v10 = glpSANode(a1, ElseStatement);
  if (v10 == -1)
    return glpSAFailed();
  glpIfStatementNodeSetElseStatement(v2, v10);
  if (!v6)
    return glpSAFailed();
  v11 = glpIfStatementNodeGetCond(v2);
  SaType = (unsigned int *)glpASTNodeGetSaType(v11);
  PrimitiveType = glpGetPrimitiveType(9u);
  if (glpTypesEqual(SaType, (uint64_t)PrimitiveType))
  {
    v14 = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(v2, (uint64_t)v14);
  }
  else
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v22);
    glpLogMessage(InfoLog, 0, (uint64_t)&v22, "Condition must be of type BOOL", v17, v18, v19, v20, v21);
    return glpSAFailed();
  }
  return v2;
}

uint64_t glpSALoopStatement(uint64_t a1, uint64_t a2)
{
  uint64_t NameTable;
  uint64_t CurrentFunction;
  uint64_t Body0;
  uint64_t v7;
  uint64_t Body1;
  uint64_t v9;
  char *PrimitiveType;

  glpSAStatement(a2);
  NameTable = glpCompilerGetNameTable(a1);
  CurrentFunction = glpNameTableGetCurrentFunction(NameTable);
  ++*(_DWORD *)(CurrentFunction + 120);
  Body0 = glpLoopStatementNodeGetBody0(a2);
  v7 = glpSANode(a1, Body0);
  if (v7 != -1)
    glpLoopStatementNodeSetBody0(a2, v7);
  Body1 = glpLoopStatementNodeGetBody1(a2);
  v9 = glpSANode(a1, Body1);
  if (v9 == -1)
    return glpSAFailed();
  glpLoopStatementNodeSetBody1(a2, v9);
  if (v7 == -1)
    return glpSAFailed();
  PrimitiveType = glpGetPrimitiveType(0);
  glpASTNodeSetSaType(a2, (uint64_t)PrimitiveType);
  --*(_DWORD *)(CurrentFunction + 120);
  return a2;
}

uint64_t glpSASwitchStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t NameTable;
  uint64_t CurrentFunction;
  uint64_t Expr;
  uint64_t v7;
  uint64_t v8;
  unsigned int *SaType;
  uint64_t InfoLog;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  __n128 *v16;
  uint64_t **v17;
  uint64_t Allocator;
  char *PrimitiveType;
  char SaFlags;
  uint64_t TypeConversionNode;
  uint64_t v23;
  uint64_t DefaultPrecisionForType;
  uint64_t Body;
  _QWORD *v26;
  uint64_t IntHash;
  unsigned int v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t Statement;
  int Kind;
  char v34;
  uint64_t ConstValue;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;
  double v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  _QWORD *v53;
  char v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  char v58;
  unsigned int *v59;
  uint64_t v60;
  uint64_t v61;
  __n128 v62;
  __n128 v63;
  __n128 v64;
  int v65;
  __n128 v66;
  __n128 v67;
  __n128 v68;
  __n128 v69;
  __n128 v70;
  int v71;
  __n128 v72;
  __n128 v73;
  __n128 v74;
  __n128 v75[2];

  v2 = a2;
  glpSAStatement(a2);
  NameTable = glpCompilerGetNameTable(a1);
  CurrentFunction = glpNameTableGetCurrentFunction(NameTable);
  ++*(_DWORD *)(CurrentFunction + 124);
  Expr = glpSwitchStatementNodeGetExpr(v2);
  v7 = glpSANode(a1, Expr);
  if (v7 == -1)
    return glpSAFailed();
  v8 = v7;
  SaType = (unsigned int *)glpASTNodeGetSaType(v7);
  if (glpTypeGetKind(SaType)
    || glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType) != 5
    && glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType) != 36)
  {
    InfoLog = glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, v75);
    v15 = "Switch expression must be of type int or uint";
    v16 = v75;
    goto LABEL_4;
  }
  if (glpPrimitiveTypeGetPrimitiveType((uint64_t)SaType) != 5)
  {
    Allocator = glpCompilerGetAllocator(a1);
    glpASTNodeGetLocation(v8, &v74);
    PrimitiveType = glpGetPrimitiveType(5u);
    SaFlags = glpASTNodeGetSaFlags(v8);
    TypeConversionNode = glpMakeTypeConversionNode(Allocator, &v74, (uint64_t)PrimitiveType, SaFlags & 0x1F);
    glpUnaryOperatorNodeSetExpr(TypeConversionNode, v8);
    v8 = glpSANode(a1, TypeConversionNode);
    if (v8 == -1)
      return glpSAFailed();
  }
  glpSwitchStatementNodeSetExpr(v2, v8);
  if (!glpCompilerDoesTypeRequirePrecision(a1, SaType))
  {
    v23 = 0;
    goto LABEL_18;
  }
  v23 = glpASTNodeGetSaFlags(v8) & 0x1F;
  if (!v23)
  {
    DefaultPrecisionForType = glpGetDefaultPrecisionForType(a1, SaType);
    if (DefaultPrecisionForType)
    {
      v23 = DefaultPrecisionForType;
      glpPushdownPrecision(a1, v8, DefaultPrecisionForType);
      goto LABEL_18;
    }
    v53 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpTypeHumanReadableDescription((uint64_t)SaType, (uint64_t)"<<BUG: unexpected function type>>", 0x92C8B9C800000021, v53);
    v55 = v54;
    InfoLog = glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v73);
    v58 = v55;
    v15 = "Switch condition of type '%.*s' - precision can not be inferred and no default precision available";
    v16 = &v73;
LABEL_4:
    v17 = (uint64_t **)InfoLog;
    goto LABEL_5;
  }
LABEL_18:
  Body = glpSwitchStatementNodeGetBody(v2);
  v26 = (_QWORD *)glpCompilerGetAllocator(a1);
  IntHash = glpMakeIntHash(v26);
  if (glpBlockNodeGetStatementCount(Body))
  {
    v59 = SaType;
    v60 = v23;
    v61 = IntHash;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v31 = IntHash;
    while (1)
    {
      Statement = glpBlockNodeGetStatement(Body, v28);
      Kind = glpASTNodeGetKind(Statement);
      if (Kind == 70)
      {
        ConstValue = glpCaseStatementNodeGetConstValue(Statement);
        v36 = glpSANode(a1, ConstValue);
        if (v36 == -1)
          return glpSAFailed();
        v37 = v36;
        v38 = glpCompilerGetNameTable(a1);
        if (glpNameTableGetGLSLVersion(v38) == 6)
        {
          v39 = glpASTNodeGetSaType(v37);
          if (!glpTypesEqual(v59, v39))
          {
            v56 = glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(Statement, &v69);
            v15 = "Type of 'case' expressions must match type of 'switch' expression";
            v16 = &v69;
            goto LABEL_48;
          }
        }
        v40 = glpCompilerGetAllocator(a1);
        glpASTNodeGetLocation(v37, &v68);
        v41 = glpGetPrimitiveType(5u);
        v42 = glpMakeTypeConversionNode(v40, &v68, (uint64_t)v41, v60);
        glpUnaryOperatorNodeSetExpr(v42, v37);
        v43 = glpSANode(a1, v42);
        if (v43 == -1)
          return glpSAFailed();
        v44 = v43;
        glpCaseStatementNodeSetConstValue(Statement, v43);
        if (!glpIsConstantNode(v44))
        {
          v56 = glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(Statement, &v67);
          v15 = "Value of 'case' expression must be constant";
          v16 = &v67;
          goto LABEL_48;
        }
        v45 = *(_DWORD *)glpConstantNodeGetValue(v44);
        v46 = glpIntHashGet(v31, v45);
        if (v46)
        {
          v57 = v46;
          v56 = glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(Statement, &v66);
          glpASTNodeGetLocation(v57, &v64);
          v58 = v65;
          v15 = "Duplicate case value found.  Previous occurrence on line %d";
          v16 = &v66;
          goto LABEL_48;
        }
        glpIntHashPut(v31, v45, Statement, v47);
        glpCaseStatementNodeSetIsStray(Statement, 0);
        v34 = 0;
      }
      else
      {
        if (Kind == 71)
        {
          if (v29)
          {
            v56 = glpCompilerGetInfoLog(a1);
            glpASTNodeGetLocation(Statement, &v72);
            glpASTNodeGetLocation(v29, &v70);
            v58 = v71;
            v15 = "Multiple default statements in switch see line %d";
            v16 = &v72;
            goto LABEL_48;
          }
          glpDefaultStatementNodeSetIsStray(Statement, 0);
          v34 = 0;
          goto LABEL_34;
        }
        if ((v30 & 1) == 0)
        {
          v56 = glpCompilerGetInfoLog(a1);
          glpASTNodeGetLocation(Statement, &v63);
          v15 = "First statement in switch is not case/default";
          v16 = &v63;
          goto LABEL_48;
        }
        v34 = 1;
      }
      Statement = v29;
LABEL_34:
      ++v28;
      v30 = 1;
      v29 = Statement;
      if (v28 >= glpBlockNodeGetStatementCount(Body))
      {
        IntHash = v61;
        if ((v34 & 1) != 0)
          break;
        v56 = glpCompilerGetInfoLog(a1);
        glpASTNodeGetLocation(Body, &v62);
        v15 = "Expected statement after final 'case'/'default'";
        v16 = &v62;
LABEL_48:
        v17 = (uint64_t **)v56;
LABEL_5:
        glpLogMessage(v17, 0, (uint64_t)v16, v15, v11, v12, v13, v14, v58);
        return glpSAFailed();
      }
    }
  }
  glpDestroyIntHash(IntHash);
  v48 = glpSwitchStatementNodeGetExpr(v2);
  v49 = glpSANode(a1, v48);
  if (v49 != -1)
    glpSwitchStatementNodeSetExpr(v2, v49);
  v50 = glpSwitchStatementNodeGetBody(v2);
  v51 = glpSANode(a1, v50);
  if (v51 == -1)
    return glpSAFailed();
  glpSwitchStatementNodeSetBody(v2, v51);
  if (v49 == -1)
    return glpSAFailed();
  v52 = glpGetPrimitiveType(0);
  glpASTNodeSetSaType(v2, (uint64_t)v52);
  --*(_DWORD *)(CurrentFunction + 124);
  return v2;
}

uint64_t glpSACaseStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t ConstValue;
  uint64_t v5;
  uint64_t **InfoLog;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *PrimitiveType;
  char v13;
  __n128 v14;

  v2 = a2;
  glpSAStatement(a2);
  ConstValue = glpCaseStatementNodeGetConstValue(v2);
  v5 = glpSANode(a1, ConstValue);
  if (v5 == -1)
    return glpSAFailed();
  glpCaseStatementNodeSetConstValue(v2, v5);
  if (glpCaseStatementNodeGetIsStray(v2))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v14);
    glpLogMessage(InfoLog, 0, (uint64_t)&v14, "case disallowed outside switch body", v7, v8, v9, v10, v13);
    return glpSAFailed();
  }
  else
  {
    PrimitiveType = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
  }
  return v2;
}

uint64_t glpSADefaultStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t **InfoLog;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *PrimitiveType;
  char v11;
  __n128 v12;

  v2 = a2;
  glpSAStatement(a2);
  if (glpDefaultStatementNodeGetIsStray(v2))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v12);
    glpLogMessage(InfoLog, 0, (uint64_t)&v12, "default disallowed outside switch body", v5, v6, v7, v8, v11);
    return glpSAFailed();
  }
  else
  {
    PrimitiveType = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
  }
  return v2;
}

uint64_t glpSABreakStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t NameTable;
  uint64_t CurrentFunction;
  char *PrimitiveType;
  uint64_t **InfoLog;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  __n128 v14;

  v2 = a2;
  glpSAStatement(a2);
  NameTable = glpCompilerGetNameTable(a1);
  CurrentFunction = glpNameTableGetCurrentFunction(NameTable);
  if (*(_DWORD *)(CurrentFunction + 124) || *(_DWORD *)(CurrentFunction + 120))
  {
    PrimitiveType = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
  }
  else
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v14);
    glpLogMessage(InfoLog, 0, (uint64_t)&v14, "break disallowed outside switch/loop body", v9, v10, v11, v12, v13);
    return glpSAFailed();
  }
  return v2;
}

uint64_t glpSAContinueStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t NameTable;
  char *PrimitiveType;
  uint64_t **InfoLog;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v12;
  __n128 v13;

  v2 = a2;
  glpSAStatement(a2);
  NameTable = glpCompilerGetNameTable(a1);
  if (*(_DWORD *)(glpNameTableGetCurrentFunction(NameTable) + 120))
  {
    PrimitiveType = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
  }
  else
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v13);
    glpLogMessage(InfoLog, 0, (uint64_t)&v13, "continue disallowed outside loop body", v7, v8, v9, v10, v12);
    return glpSAFailed();
  }
  return v2;
}

uint64_t glpSADiscardStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t NameTable;
  char *PrimitiveType;
  uint64_t **InfoLog;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v12;
  __n128 v13;

  v2 = a2;
  glpSAStatement(a2);
  NameTable = glpCompilerGetNameTable(a1);
  if (glpNameTableGetLanguage(NameTable) == 4)
  {
    PrimitiveType = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(v2, (uint64_t)PrimitiveType);
  }
  else
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v13);
    glpLogMessage(InfoLog, 0, (uint64_t)&v13, "'discard' is only meaningful in the fragment shader.", v7, v8, v9, v10, v12);
    return glpSAFailed();
  }
  return v2;
}

uint64_t glpSAReturnStatement(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t Expr;
  uint64_t v5;
  uint64_t v6;
  uint64_t SaType;
  unsigned int *v9;
  uint64_t NameTable;
  uint64_t CurrentFunction;
  uint64_t v12;
  uint64_t **InfoLog;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  __n128 *v19;
  unsigned int *ReturnType;
  unsigned int ImplicitConversionPolicy;
  uint64_t PrimitiveType;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t LValueForVariableObject;
  uint64_t Allocator;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t AssignFragment;
  _QWORD *v35;
  char *v36;
  int v37;
  __n128 v38;
  uint64_t v39;
  __n128 v40;
  uint64_t v41;
  __n128 v42;
  __n128 v43;

  v2 = a2;
  glpSAStatement(a2);
  Expr = glpReturnStatementNodeGetExpr(v2);
  v5 = glpSANode(a1, Expr);
  if (v5 == -1)
    return glpSAFailed();
  glpReturnStatementNodeSetExpr(v2, v5);
  if (glpReturnStatementNodeGetExpr(v2))
  {
    v6 = glpReturnStatementNodeGetExpr(v2);
    SaType = glpASTNodeGetSaType(v6);
  }
  else
  {
    SaType = (uint64_t)glpGetPrimitiveType(0);
  }
  v9 = (unsigned int *)SaType;
  NameTable = glpCompilerGetNameTable(a1);
  CurrentFunction = glpNameTableGetCurrentFunction(NameTable);
  v12 = CurrentFunction;
  if ((*(_BYTE *)(CurrentFunction + 9) & 0x20) != 0 && *(_BYTE *)(CurrentFunction + 112))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v43);
    v37 = *(_DWORD *)(v12 + 32);
    v18 = "Inline function '%.*s' can only have 1 return";
    v19 = &v43;
LABEL_9:
    glpLogMessage(InfoLog, 0, (uint64_t)v19, v18, v14, v15, v16, v17, v37);
    return glpSAFailed();
  }
  *(_BYTE *)(CurrentFunction + 112) = 1;
  ReturnType = (unsigned int *)glpFunctionTypeGetReturnType(*(_QWORD *)CurrentFunction);
  if (!glpTypesEqual(v9, (uint64_t)ReturnType)
    && !glpTypeGetKind(v9)
    && !glpTypeGetKind(ReturnType))
  {
    ImplicitConversionPolicy = glpCompilerGetImplicitConversionPolicy(a1);
    PrimitiveType = glpPrimitiveTypeGetPrimitiveType((uint64_t)v9);
    v24 = glpPrimitiveTypeGetPrimitiveType((uint64_t)ReturnType);
    if (!glpCanConvert(PrimitiveType, v24, ImplicitConversionPolicy))
    {
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
      glpASTNodeGetLocation(v2, &v42);
      v18 = "Expression in 'return' statement must match return type of function (and no available implicit conversion)";
      v19 = &v42;
      goto LABEL_9;
    }
    v25 = glpReturnStatementNodeGetExpr(v2);
    v26 = glpConvert(a1, v25, (uint64_t)ReturnType, 0);
    glpReturnStatementNodeSetExpr(v2, v26);
  }
  glpASTNodeSetSaType(v2, (uint64_t)v9);
  glpReturnStatementNodeSetExtra(v2, v12);
  if (glpReturnStatementNodeGetExpr(v2))
  {
    v40 = 0uLL;
    v41 = 0;
    glpASTNodeGetLocation(v2, &v40);
    v27 = *(uint64_t **)(glpReturnStatementNodeGetExtra(v2) + 72);
    v38 = v40;
    v39 = v41;
    LValueForVariableObject = glpMakeLValueForVariableObject(a1, &v38, v27);
    Allocator = glpCompilerGetAllocator(a1);
    v38 = v40;
    v39 = v41;
    glpMakeCommaExprNode(Allocator, &v38, 0);
    v31 = v30;
    v32 = (_QWORD *)glpCompilerGetAllocator(a1);
    v33 = glpReturnStatementNodeGetExpr(v2);
    v38 = v40;
    v39 = v41;
    AssignFragment = glpMakeAssignFragment(a1, &v38, LValueForVariableObject, v33);
    glpCommaExprNodeAddExpr(v32, v31, AssignFragment);
    v35 = (_QWORD *)glpCompilerGetAllocator(a1);
    glpCommaExprNodeAddExpr(v35, v31, v2);
    glpReturnStatementNodeSetExpr(v2, 0);
    v36 = glpGetPrimitiveType(0);
    glpASTNodeSetSaType(v2, (uint64_t)v36);
    return glpSANode(a1, v31);
  }
  return v2;
}

uint64_t glpSATopLevel(uint64_t a1, uint64_t a2)
{
  uint64_t NameTable;
  int DefCount;
  int v6;
  int v7;
  unsigned int v8;
  uint64_t Def;
  uint64_t v10;
  uint64_t v11;
  int v12;
  BOOL v13;
  char *PrimitiveType;
  uint64_t v16;
  uint64_t **InfoLog;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v23;
  _QWORD v24[3];

  NameTable = glpCompilerGetNameTable(a1);
  glpNameTableSetTopLevelBlock(NameTable, a2);
  DefCount = glpTopLevelNodeGetDefCount(a2);
  if (DefCount)
  {
    v6 = -DefCount;
    v7 = 1;
    do
    {
      v8 = glpTopLevelNodeGetDefCount(a2) + v6;
      Def = glpTopLevelNodeGetDef(a2, v8);
      v10 = glpCompilerGetNameTable(a1);
      glpNameTableSetStatementIndex(v10, v8);
      v11 = glpSANode(a1, Def);
      v12 = glpTopLevelNodeGetDefCount(a2);
      if (v11 != -1)
        glpTopLevelNodeSetDef(a2, v12 + v6, v11);
      if (v7)
        v13 = v11 == -1;
      else
        v13 = 1;
      v7 = !v13;
    }
    while (!__CFADD__(v6++, 1));
    if ((v7 & 1) == 0)
      return glpSAFailed();
  }
  PrimitiveType = glpGetPrimitiveType(0);
  glpASTNodeSetSaType(a2, (uint64_t)PrimitiveType);
  v16 = glpCompilerGetNameTable(a1);
  if (glpNameTableGetLanguage(v16) == 1 && !glpCheckBarrier(a2))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    v24[0] = "-1";
    v24[1] = 0xEDA00000002;
    v24[2] = 0xFFFFFFFFLL;
    glpLogMessage(InfoLog, 0, (uint64_t)v24, "You can't call barrier() outside main, within control flow, or after a return statement.", v18, v19, v20, v21, v23);
    return glpSAFailed();
  }
  return a2;
}

void glpSAAvailabilityDeclaration()
{
  abort();
}

void glpSARawCall()
{
  abort();
}

uint64_t glpSASubroutineRawCall(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = glpSubroutineRawCallNodeGetIndexExpr(a2);
  v5 = glpSANode(a1, v4);
  if (v5 != -1)
  {
    glpSubroutineRawCallNodeSetIndexExpr(a2, v5);
    abort();
  }
  return glpSAFailed();
}

uint64_t glpSAOffset(uint64_t a1, uint64_t a2)
{
  uint64_t BankIndex;
  uint64_t v5;
  int v6;
  uint64_t OffsetExpr;
  uint64_t v8;
  uint64_t VectorElementExpr;
  uint64_t v10;

  BankIndex = glpOffsetNodeGetBankIndex(a2);
  v5 = glpSANode(a1, BankIndex);
  if (v5 == -1)
  {
    v6 = 0;
  }
  else
  {
    glpOffsetNodeSetBankIndex(a2, v5);
    v6 = 1;
  }
  OffsetExpr = glpOffsetNodeGetOffsetExpr(a2);
  v8 = glpSANode(a1, OffsetExpr);
  if (v8 == -1)
    v6 = 0;
  else
    glpOffsetNodeSetOffsetExpr(a2, v8);
  VectorElementExpr = glpOffsetNodeGetVectorElementExpr(a2);
  v10 = glpSANode(a1, VectorElementExpr);
  if (v10 != -1)
  {
    glpOffsetNodeSetVectorElementExpr(a2, v10);
    if (v6)
      abort();
  }
  return glpSAFailed();
}

uint64_t glpSALValue(uint64_t a1, uint64_t a2)
{
  if (glpSADeref(a1, a2) != -1)
    abort();
  return glpSAFailed();
}

uint64_t glpSARValue(uint64_t a1, uint64_t a2)
{
  uint64_t Base;
  uint64_t v5;

  if (glpSADeref(a1, a2) != -1)
  {
    Base = glpRValueNodeGetBase(a2);
    v5 = glpSANode(a1, Base);
    if (v5 != -1)
    {
      glpRValueNodeSetBase(a2, v5);
      abort();
    }
  }
  return glpSAFailed();
}

uint64_t glpSAIBPartialDeref(uint64_t a1, uint64_t a2)
{
  uint64_t BankIndex;
  uint64_t v5;

  BankIndex = glpIBPartialDerefNodeGetBankIndex(a2);
  v5 = glpSANode(a1, BankIndex);
  if (v5 != -1)
  {
    glpIBPartialDerefNodeSetBankIndex(a2, v5);
    abort();
  }
  return glpSAFailed();
}

uint64_t glpSAPPStreamOp(uint64_t a1, uint64_t a2)
{
  if (glpSACall(a1, a2) != -1)
    abort();
  return glpSAFailed();
}

void glpSASubroutineUniform()
{
  abort();
}

uint64_t glpSAUnaryOperator(uint64_t a1, uint64_t a2)
{
  uint64_t Expr;
  uint64_t v5;
  uint64_t v6;
  char SaFlags;

  Expr = glpUnaryOperatorNodeGetExpr(a2);
  v5 = glpSANode(a1, Expr);
  if (v5 == -1)
    return glpSAFailed();
  glpUnaryOperatorNodeSetExpr(a2, v5);
  v6 = glpUnaryOperatorNodeGetExpr(a2);
  SaFlags = glpASTNodeGetSaFlags(v6);
  glpASTNodeSetSaFlags(a2, SaFlags & 0x7F);
  return a2;
}

_QWORD *__glpSAVariableIdentifier_block_invoke(_QWORD *result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  int v6;
  BOOL v7;

  *(_DWORD *)(*(_QWORD *)(result[4] + 8) + 24) = a2;
  *(_QWORD *)(*(_QWORD *)(result[5] + 8) + 24) = a3;
  v6 = *(_DWORD *)(*(_QWORD *)(result[4] + 8) + 24);
  if (v6)
    v7 = v6 == 6;
  else
    v7 = 1;
  if (v7 || (result = (_QWORD *)glpNameTableGetGLSLVersion(result[6]), (_DWORD)result != 1))
    *a5 = 1;
  return result;
}

_QWORD *__glpSATypeIdentifier_block_invoke(_QWORD *result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  int v6;
  BOOL v7;

  *(_DWORD *)(*(_QWORD *)(result[4] + 8) + 24) = a2;
  *(_QWORD *)(*(_QWORD *)(result[5] + 8) + 24) = a3;
  v6 = *(_DWORD *)(*(_QWORD *)(result[4] + 8) + 24);
  if (v6)
    v7 = v6 == 6;
  else
    v7 = 1;
  if (v7 || (result = (_QWORD *)glpNameTableGetGLSLVersion(result[6]), (_DWORD)result != 1))
    *a5 = 1;
  return result;
}

uint64_t glpSACall(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t NameTable;
  uint64_t v6;
  char *Name;
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  if (glpIsUndeterminedCallNode(a2))
  {
    v4 = glpUndeterminedCallNodeGetCallee(a2);
    if (glpIsVariableIdentifierNode(v4))
    {
      NameTable = glpCompilerGetNameTable(a1);
      if (glpNameTableIsExtensionEnabled(NameTable, 0x24u))
      {
        v6 = glpUndeterminedCallNodeGetCallee(a2);
        Name = (char *)glpVariableIdentifierNodeGetName(v6);
        if (glpStringsEqual("$assert", 0x75B16CFF00000007, Name, v8))
          return a2;
      }
    }
  }
  if (!glpCallNodeGetArgCount(a2))
    return a2;
  v9 = 0;
  v10 = 1;
  do
  {
    v11 = glpCallNodeGetArg(a2, v9);
    v12 = glpSANode(a1, v11);
    if (v12 == -1)
      v10 = 0;
    else
      glpCallNodeSetArg(a2, v9, v12);
    ++v9;
  }
  while (v9 < glpCallNodeGetArgCount(a2));
  if (v10)
    return a2;
  else
    return glpSAFailed();
}

uint64_t __glpSAUndeterminedCall_block_invoke(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  _QWORD *v8;

  v8 = (_QWORD *)result;
  if (a2 == 4
    || a2 == 7
    || (result = glpNameTableGetGLSLVersion(*(_QWORD *)(result + 48)), (_DWORD)result != 1)
    && (result = glpCompilerGetIOSVersion(v8[7]), (int)result >= 9))
  {
    *(_DWORD *)(*(_QWORD *)(v8[4] + 8) + 24) = a2;
    *(_QWORD *)(*(_QWORD *)(v8[5] + 8) + 24) = a3;
    *a5 = 1;
  }
  return result;
}

uint64_t __glpSASubroutineArrayCall_block_invoke(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

uint64_t __glpSAMethodCall_block_invoke(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

uint64_t glpSAIncrementOperator(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t Expr;
  unsigned int *SaType;
  uint64_t **InfoLog;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  __n128 *v12;
  uint64_t v14;
  unsigned int PrimitiveType;
  __n128 v16;
  __n128 v17;
  __n128 v18;
  __n128 v19;

  v2 = a2;
  if (glpSAUnaryOperator(a1, a2) == -1)
    return glpSAFailed();
  Expr = glpUnaryOperatorNodeGetExpr(v2);
  SaType = (unsigned int *)glpASTNodeGetSaType(Expr);
  if (glpTypeGetKind(SaType))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v19);
    v11 = "Pre- or post- -increment or -decrement of nonprimitive type";
    v12 = &v19;
LABEL_11:
    glpLogMessage(InfoLog, 0, (uint64_t)v12, v11, v7, v8, v9, v10, v16.n128_i8[0]);
    return glpSAFailed();
  }
  v14 = glpASTNodeGetSaType(Expr);
  PrimitiveType = glpPrimitiveTypeGetPrimitiveType(v14);
  if (glpPrimitiveTypeGetCategory(PrimitiveType) - 1 >= 3)
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v18);
    v11 = "Pre- or post- -increment or -decrement of nonscalar nonvector nonmatrix type";
    v12 = &v18;
    goto LABEL_11;
  }
  if (!glpIsLValueNode(Expr))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v17);
    v11 = "Pre- or post- -increment or -decrement of non-lvalue";
    v12 = &v17;
    goto LABEL_11;
  }
  if ((glpASTNodeGetSaFlags(Expr) & 0x360) != 0)
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(a1);
    glpASTNodeGetLocation(v2, &v16);
    v11 = "Pre- or post- -increment or -decrement of read-only variable";
    v12 = &v16;
    goto LABEL_11;
  }
  return v2;
}

uint64_t glpSABinaryOperator(uint64_t a1, uint64_t a2)
{
  uint64_t Lhs;
  uint64_t v5;
  uint64_t Rhs;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 SaFlags;
  unsigned __int8 v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t SaType;
  uint64_t v20;

  Lhs = glpBinaryOperatorNodeGetLhs(a2);
  v5 = glpSANode(a1, Lhs);
  if (v5 != -1)
    glpBinaryOperatorNodeSetLhs(a2, v5);
  Rhs = glpBinaryOperatorNodeGetRhs(a2);
  v7 = glpSANode(a1, Rhs);
  if (v7 == -1)
    return glpSAFailed();
  glpBinaryOperatorNodeSetRhs(a2, v7);
  if (v5 == -1)
    return glpSAFailed();
  v8 = glpBinaryOperatorNodeGetLhs(a2);
  v9 = glpBinaryOperatorNodeGetRhs(a2);
  SaFlags = glpASTNodeGetSaFlags(v8);
  v11 = glpASTNodeGetSaFlags(v9);
  if (glpCompilerDoesTrackPrecision(a1))
  {
    v12 = SaFlags & 0x1F;
    v13 = v11 & 0x1F;
    if (v12 != v13 && !glpIsAssignNode(a2) && !glpIsOpAssignNode(a2))
    {
      if (v12 == 31 || (SaFlags & 0x1F) == 0)
      {
        v15 = glpBinaryOperatorNodeGetLhs(a2);
        glpPushdownPrecision(a1, v15, v11 & 0x1F);
        goto LABEL_12;
      }
      if (v13 != 31 && (v11 & 0x1F) != 0)
      {
        if (v12 <= v13)
        {
          SaType = glpASTNodeGetSaType(v8);
          v20 = glpConvert(a1, v8, SaType, v11 & 0x1F);
          glpBinaryOperatorNodeSetLhs(a2, v20);
          goto LABEL_12;
        }
        v17 = glpASTNodeGetSaType(v9);
        v18 = glpConvert(a1, v9, v17, SaFlags & 0x1F);
        glpBinaryOperatorNodeSetRhs(a2, v18);
      }
      else
      {
        v16 = glpBinaryOperatorNodeGetRhs(a2);
        glpPushdownPrecision(a1, v16, SaFlags & 0x1F);
      }
    }
    v13 = SaFlags & 0x1F;
  }
  else
  {
    v13 = 0;
  }
LABEL_12:
  glpASTNodeSetSaFlags(a2, v13 | SaFlags & v11 & 0x60);
  return a2;
}

uint64_t glpSwizzleHasDuplicateComponents(unsigned int a1)
{
  unsigned int v1;
  int v2;
  unsigned int v3;
  char v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  char v8;

  v1 = a1 & 7;
  if ((a1 & 7) == 0)
    return 0;
  v2 = 0;
  v3 = v1 - 1;
  v4 = 5;
  while (1)
  {
    v5 = v2 + 1;
    if (v2 + 1 < v1)
      break;
LABEL_7:
    v4 += 2;
    --v3;
    v2 = v5;
    if (v5 == v1)
      return 0;
  }
  v6 = a1 >> (2 * v2 + 3);
  v7 = v3;
  v8 = v4;
  while ((((a1 >> v8) ^ v6) & 3) != 0)
  {
    v8 += 2;
    if (!--v7)
      goto LABEL_7;
  }
  return 1;
}

uint64_t __glpSAFunctionPrototype_block_invoke(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

uint64_t __glpSAFunctionPrototype_block_invoke_2(uint64_t result, int a2, uint64_t a3, int a4, _DWORD *a5)
{
  _QWORD *v9;

  v9 = (_QWORD *)result;
  if (a2 == 4 || (result = glpNameTableGetGLSLVersion(*(_QWORD *)(result + 56)), (_DWORD)result != 1))
  {
    *(_DWORD *)(*(_QWORD *)(v9[4] + 8) + 24) = a2;
    *(_QWORD *)(*(_QWORD *)(v9[5] + 8) + 24) = a3;
    *(_DWORD *)(*(_QWORD *)(v9[6] + 8) + 24) = a4;
    *a5 = 1;
  }
  return result;
}

uint64_t __glpSAFunctionPrototype_block_invoke_3(uint64_t result, uint64_t a2, uint64_t a3, int a4, _DWORD *a5)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a3;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = a4 == 3;
  *a5 = 1;
  return result;
}

uint64_t __glpSAFunctionPrototype_block_invoke_4(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

uint64_t __glpSAVariableDeclaration_block_invoke(uint64_t result, int a2, uint64_t a3, int a4, _DWORD *a5)
{
  _QWORD *v9;

  v9 = (_QWORD *)result;
  if (!a2 || a2 == 6 || (result = glpNameTableGetGLSLVersion(*(_QWORD *)(result + 56)), (_DWORD)result != 1))
  {
    *(_DWORD *)(*(_QWORD *)(v9[4] + 8) + 24) = a2;
    *(_QWORD *)(*(_QWORD *)(v9[5] + 8) + 24) = a3;
    *(_DWORD *)(*(_QWORD *)(v9[6] + 8) + 24) = a4 == 3;
    *a5 = 1;
  }
  return result;
}

uint64_t __glpSAVariableDeclaration_block_invoke_2(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  if (a2 == 1)
    *a5 = 1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a3;
  return result;
}

uint64_t __glpSAVariableDeclaration_block_invoke_3(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

uint64_t __glpSAQualifiedDeclaration_block_invoke(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

void __glpSAFunctionDefinition_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *a5 = 1;
}

uint64_t glpSAStructure(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t Field;
  uint64_t v7;

  if (!glpStructureNodeGetFieldCount(a2))
    return a2;
  v4 = 0;
  v5 = 1;
  do
  {
    Field = glpStructureNodeGetField(a2, v4);
    v7 = glpSANode(a1, Field);
    if (v7 == -1)
      v5 = 0;
    else
      glpStructureNodeSetField(a2, v4, v7);
    ++v4;
  }
  while (v4 < glpStructureNodeGetFieldCount(a2));
  if (!v5)
    return glpSAFailed();
  else
    return a2;
}

uint64_t __glpSAStructType_block_invoke(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v8;

  v8 = result;
  if (!a2 || a2 == 6 || (result = glpNameTableGetGLSLVersion(*(_QWORD *)(result + 48)), (_DWORD)result != 1))
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 8) + 24) = a2;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 40) + 8) + 24) = a3;
    *a5 = 1;
  }
  return result;
}

uint64_t __glpSAInterfaceBlock_block_invoke(uint64_t result, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

uint64_t __glpSAInterfaceBlock_block_invoke_2(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a3;
  *a5 = 1;
  return result;
}

void __glpSAInterfaceBlock_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *a5 = 1;
}

void __glpSAInterfaceBlock_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  *a5 = 1;
}

uint64_t glpSAStatement(uint64_t a1)
{
  glpASTNodeSetSaFlags(a1, 0);
  return a1;
}

uint64_t glpSADeref(uint64_t a1, uint64_t a2)
{
  uint64_t Offset;
  uint64_t v5;

  Offset = glpDerefNodeGetOffset(a2);
  v5 = glpSANode(a1, Offset);
  if (v5 == -1)
    return glpSAFailed();
  glpDerefNodeSetOffset(a2, v5);
  return a2;
}

uint64_t glpSetLineNumber(uint64_t result, int a2)
{
  *(_DWORD *)(result + 300) = a2;
  return result;
}

char *glpSetFilename(uint64_t a1, char *__s)
{
  uint64_t v4;
  char *v5;
  char *result;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 784);
  strlen(__s);
  v5 = (char *)glpCompilerPoolAlloc(v4);
  result = strcpy(v5, __s);
  *(_QWORD *)(a1 + 304) = result;
  return result;
}

char *glpSetFileNumber(uint64_t a1, int a2)
{
  char __s[256];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  snprintf_l(__s, 0x100uLL, 0, "%d", a2);
  return glpSetFilename(a1, __s);
}

uint64_t glpGetFilename(uint64_t a1)
{
  return *(_QWORD *)(a1 + 304);
}

uint64_t glpGetLineNumber(uint64_t a1)
{
  return *(unsigned int *)(a1 + 300);
}

uint64_t glpIncLineNumber(uint64_t result)
{
  ++*(_DWORD *)(result + 300);
  return result;
}

uint64_t glpDecLineNumber(uint64_t result)
{
  --*(_DWORD *)(result + 300);
  return result;
}

void glpLexerFatalError()
{
  abort();
}

uint64_t yylex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int16 *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t buffer;
  _BYTE *v11;
  _QWORD *v12;
  _BYTE **v13;
  _DWORD *v14;
  unsigned __int8 *v15;
  int v16;
  unsigned __int8 *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  _BYTE **v22;
  _BYTE *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int next_buffer;
  int v31;
  int previous_state;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  _DWORD *v38;
  _QWORD *v39;
  __int16 *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char **v45;
  char *v46;
  uint64_t v48;
  const char *v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void **v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int v72;
  unsigned int v73;
  unsigned int v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  unsigned int v81;
  unsigned int v82;
  unsigned int v83;
  uint64_t **InfoLog;
  uint64_t v85;
  const char *StringZ;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  char *v99;
  uint64_t v100;
  uint64_t *StringBuffer;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  _QWORD *v109;
  _DWORD *v110;
  _DWORD *v111;
  _BYTE **v112;
  _BYTE **v113;
  uint64_t v114;
  uint64_t v115;
  _QWORD v116[3];

  v5 = a1;
  if (!*(_DWORD *)(a3 + 80))
  {
    *(_DWORD *)(a3 + 80) = 1;
    if (!*(_DWORD *)(a3 + 84))
      *(_DWORD *)(a3 + 84) = 1;
    if (!*(_QWORD *)(a3 + 8))
      *(_QWORD *)(a3 + 8) = *MEMORY[0x24BDAC8E0];
    if (!*(_QWORD *)(a3 + 16))
      *(_QWORD *)(a3 + 16) = *MEMORY[0x24BDAC8E8];
    v6 = *(_QWORD *)(a3 + 40);
    if (!v6 || (v7 = *(_QWORD *)(a3 + 24), (v8 = *(_QWORD *)(v6 + 8 * v7)) == 0))
    {
      yyensure_buffer_stack((_QWORD *)a3);
      buffer = yy_create_buffer(*(_QWORD *)(a3 + 8), 0x4000, a3);
      v5 = a1;
      v7 = *(_QWORD *)(a3 + 24);
      *(_QWORD *)(*(_QWORD *)(a3 + 40) + 8 * v7) = buffer;
      v6 = *(_QWORD *)(a3 + 40);
      v8 = *(_QWORD *)(v6 + 8 * v7);
    }
    *(_QWORD *)(a3 + 56) = *(_QWORD *)(v8 + 32);
    v11 = *(_BYTE **)(v8 + 16);
    *(_QWORD *)(a3 + 72) = v11;
    *(_QWORD *)(a3 + 136) = v11;
    *(_QWORD *)(a3 + 8) = **(_QWORD **)(v6 + 8 * v7);
    *(_BYTE *)(a3 + 48) = *v11;
  }
  v12 = (_QWORD *)(a3 + 72);
  v13 = (_BYTE **)(a3 + 120);
  v14 = (_DWORD *)(v5 + 16);
  while (1)
  {
LABEL_13:
    v15 = *(unsigned __int8 **)(a3 + 72);
    *v15 = *(_BYTE *)(a3 + 48);
    v16 = *(_DWORD *)(a3 + 84);
    v17 = v15;
    do
    {
LABEL_14:
      v18 = yy_ec[*v17];
      if (yy_accept[v16])
      {
        *(_DWORD *)(a3 + 112) = v16;
        *(_QWORD *)(a3 + 120) = v17;
      }
      v19 = v16;
      v20 = yy_base[v16] + v18;
      if (v16 != (__int16)yy_chk[v20])
      {
        do
        {
          v19 = yy_def[v19];
          if (v19 >= 876)
            v18 = *((unsigned __int8 *)&yy_meta + v18);
          v20 = yy_base[v19] + v18;
        }
        while (yy_chk[v20] != (unsigned __int16)v19);
      }
      v16 = yy_nxt[v20];
      ++v17;
    }
    while (v16 != 875);
    while (2)
    {
      v21 = *(_DWORD *)(a3 + 112);
      v22 = v13;
LABEL_22:
      v23 = *v22;
      v24 = (__int16)yy_accept[v21];
      *(_QWORD *)(a3 + 136) = v15;
      *(_QWORD *)(a3 + 64) = v23 - v15;
      *(_BYTE *)(a3 + 48) = *v23;
      *v23 = 0;
      *(_QWORD *)(a3 + 72) = v23;
LABEL_23:
      switch(v24)
      {
        case 0:
          *v23 = *(_BYTE *)(a3 + 48);
          continue;
        case 1:
          if (*(_DWORD *)(*(_QWORD *)a3 + 756) == 3)
            return 0;
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 310;
        case 2:
          if (*(_DWORD *)(*(_QWORD *)a3 + 756) == 3)
            return 0;
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 309;
        case 3:
          if (*(_DWORD *)(*(_QWORD *)a3 + 756) == 3)
            return 0;
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 428;
        case 4:
          if (*(_DWORD *)(*(_QWORD *)a3 + 756) == 3)
            return 0;
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 429;
        case 5:
          if (*(_DWORD *)(*(_QWORD *)a3 + 756) == 3)
            return 0;
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 431;
        case 6:
          if (*(_DWORD *)(*(_QWORD *)a3 + 756) == 3)
            return 0;
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 430;
        case 7:
        case 10:
        case 20:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 46:
        case 61:
        case 62:
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 86:
        case 87:
        case 90:
        case 91:
        case 92:
        case 94:
        case 96:
        case 118:
        case 122:
        case 123:
        case 124:
        case 128:
        case 130:
        case 131:
        case 136:
        case 137:
        case 143:
        case 145:
        case 146:
        case 150:
        case 153:
        case 159:
        case 160:
        case 161:
        case 162:
        case 163:
        case 164:
        case 165:
        case 170:
        case 171:
        case 174:
        case 175:
        case 176:
        case 178:
        case 180:
        case 205:
          v41 = *(_QWORD *)a3;
          goto LABEL_48;
        case 8:
        case 17:
        case 19:
        case 38:
        case 39:
        case 40:
        case 41:
        case 43:
        case 44:
        case 45:
        case 47:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 57:
        case 58:
        case 59:
        case 80:
        case 82:
        case 84:
        case 101:
        case 116:
        case 117:
        case 120:
        case 126:
        case 139:
        case 142:
        case 148:
        case 149:
        case 151:
        case 154:
        case 156:
        case 157:
        case 158:
        case 168:
        case 169:
        case 181:
        case 190:
          v48 = *(_QWORD *)a3;
          goto LABEL_53;
        case 9:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 258;
        case 11:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 260;
        case 12:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 263;
        case 13:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 271;
        case 14:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 272;
        case 15:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 273;
        case 16:
          v57 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          if (v57 <= 5)
            goto LABEL_50;
          return 342;
        case 18:
          v58 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          if (v58 <= 5)
            goto LABEL_50;
          return 290;
        case 21:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 259;
        case 22:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 264;
        case 23:
          v59 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          if (v59 <= 5)
            goto LABEL_50;
          return 343;
        case 24:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 269;
        case 37:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 265;
        case 42:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 266;
        case 48:
          v48 = *(_QWORD *)a3;
          if (*(_DWORD *)(*(_QWORD *)a3 + 40) < 6u)
            goto LABEL_53;
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(v48 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 339;
        case 49:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 261;
        case 50:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 267;
        case 56:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 306;
        case 60:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 268;
        case 79:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 291;
        case 81:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 293;
        case 83:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 262;
        case 85:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 289;
        case 88:
          v60 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v60 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 322;
        case 89:
          v61 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v61 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 327;
        case 93:
          v62 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v62 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 323;
        case 95:
          v63 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v63 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 324;
        case 97:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 274;
        case 98:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 275;
        case 99:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 276;
        case 100:
          v41 = *(_QWORD *)a3;
          if (*(_DWORD *)(*(_QWORD *)a3 + 756) == 3 && *(_DWORD *)(v41 + 620) == 3 && *(_DWORD *)(v41 + 40) < 6u)
            goto LABEL_48;
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(v41 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 347;
        case 102:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 308;
        case 103:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          goto LABEL_120;
        case 104:
          v64 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v64 < 6)
            goto LABEL_51;
LABEL_120:
          *(_DWORD *)(v43 + 20) = 1;
          return 280;
        case 105:
          v65 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v65 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 281;
        case 106:
          v66 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v66 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 282;
        case 107:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          goto LABEL_129;
        case 108:
          v67 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v67 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 283;
        case 109:
          v68 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v68 < 6)
            goto LABEL_51;
LABEL_129:
          *(_DWORD *)(v43 + 20) = 1;
          return 284;
        case 110:
          v69 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v69 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 285;
        case 111:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          goto LABEL_138;
        case 112:
          v70 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v70 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 286;
        case 113:
          v71 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v71 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 287;
        case 114:
          v72 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v72 < 6)
            goto LABEL_51;
LABEL_138:
          *(_DWORD *)(v43 + 20) = 1;
          return 288;
        case 115:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 307;
        case 119:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 292;
        case 121:
          v48 = *(_QWORD *)a3;
          if (*(_DWORD *)(*(_QWORD *)a3 + 40) < 6u)
            goto LABEL_53;
          v42 = *(_QWORD *)(v48 + 344);
          goto LABEL_49;
        case 125:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 305;
        case 127:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 270;
        case 129:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 299;
        case 132:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 303;
        case 133:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 300;
        case 134:
          v73 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v73 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 317;
        case 135:
          v74 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v74 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 320;
        case 138:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 345;
        case 140:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 304;
        case 141:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 301;
        case 144:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 302;
        case 147:
          v75 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v75 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 315;
        case 152:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 296;
        case 155:
          v48 = *(_QWORD *)a3;
          if (*(_DWORD *)(*(_QWORD *)a3 + 40) < 6u)
          {
LABEL_53:
            glpPaReservedWord(v48);
            return 0;
          }
          else
          {
            *(_QWORD *)(v5 + 8) = *(_QWORD *)(v48 + 344);
            *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
            return 341;
          }
        case 166:
          v76 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v76 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 340;
        case 167:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 294;
        case 172:
          v77 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v77 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 330;
        case 173:
          v78 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v78 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 335;
        case 177:
          v79 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v79 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 331;
        case 179:
          v80 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v80 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 332;
        case 182:
          v81 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v81 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 312;
        case 183:
          v82 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v82 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 313;
        case 184:
          v83 = *(_DWORD *)(*(_QWORD *)a3 + 40);
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          v43 = *(_QWORD *)a3;
          if (v83 < 6)
            goto LABEL_51;
          *(_DWORD *)(v43 + 20) = 1;
          return 314;
        case 185:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 295;
        case 186:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 277;
        case 187:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 278;
        case 188:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 279;
        case 189:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          *(_DWORD *)(*(_QWORD *)a3 + 20) = 1;
          return 297;
        case 191:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 298;
        case 192:
          *(_DWORD *)v5 = 1;
          goto LABEL_186;
        case 193:
          *(_DWORD *)v5 = 0;
LABEL_186:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 381;
        case 194:
        case 195:
        case 197:
          v49 = *(const char **)(a3 + 136);
          v50 = v5;
          v51 = v49[strlen(v49) - 1] & 0xDF;
          *(_DWORD *)v50 = strtoul_l(v49, 0, 0, 0);
          *(_QWORD *)(v50 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v50 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          if (v51 == 85)
            return 337;
          else
            return 380;
        case 196:
          InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(_QWORD *)(*(_QWORD *)a3 + 784));
          v85 = *(_QWORD *)a3;
          StringZ = glpMakeStringZ(*(const char **)(*(_QWORD *)a3 + 344));
          glpMakeSourceLocation((uint64_t)StringZ, v87, *(_DWORD *)(v85 + 340), v116);
          glpLogMessage(InfoLog, 0, (uint64_t)v116, "'%s' : Invalid Octal number. ", v88, v89, v90, v91, *(_QWORD *)(a3 + 136));
          glpParseRecover(*(_QWORD *)a3);
          return 0;
        case 198:
        case 199:
        case 200:
          v52 = v5;
          *(float *)v5 = strtof_l(*(const char **)(a3 + 136), 0, 0);
          *(_QWORD *)(v52 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v52 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 379;
        case 201:
        case 202:
        case 203:
          v53 = v5;
          *(double *)v5 = strtod_l(*(const char **)(a3 + 136), 0, 0);
          *(_QWORD *)(v53 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v53 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 354;
        case 204:
          v41 = *(_QWORD *)a3;
          if (*(_DWORD *)(*(_QWORD *)a3 + 756) == 3 && *(_DWORD *)(v41 + 760) == 3)
            return 0;
LABEL_48:
          v42 = *(_QWORD *)(v41 + 344);
LABEL_49:
          *(_QWORD *)(v5 + 8) = v42;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
LABEL_50:
          v43 = *(_QWORD *)a3;
LABEL_51:
          v44 = *(_QWORD *)(v43 + 784);
          v45 = (char **)v5;
          strlen(*(const char **)(a3 + 136));
          v46 = (char *)glpCompilerPoolAlloc(v44);
          *v45 = v46;
          strcpy(v46, *(const char **)(a3 + 136));
          return glpPaIdentOrType(*(_QWORD *)a3, *v45);
        case 206:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 393;
        case 207:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 425;
        case 208:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 401;
        case 209:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 386;
        case 210:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 416;
        case 211:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 403;
        case 212:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 412;
        case 213:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 415;
        case 214:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 390;
        case 215:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 427;
        case 216:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 419;
        case 217:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 394;
        case 218:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 420;
        case 219:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 395;
        case 220:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 426;
        case 221:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 391;
        case 222:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 400;
        case 223:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 421;
        case 224:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 397;
        case 225:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 418;
        case 226:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 385;
        case 227:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 396;
        case 228:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 422;
        case 229:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 383;
        case 230:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 398;
        case 231:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 387;
        case 232:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 389;
        case 233:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 423;
        case 234:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 388;
        case 235:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 384;
        case 236:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 399;
        case 237:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 424;
        case 238:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 402;
        case 239:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 392;
        case 240:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 417;
        case 241:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 406;
        case 242:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 407;
        case 243:
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 409;
        case 244:
        case 254:
        case 255:
          goto LABEL_13;
        case 245:
          v38 = v14;
          v113 = v13;
          v115 = v5;
          v39 = v12;
          glpPaParseComment(*(_QWORD *)a3, v14);
          v3 = &jpt_22A942A84;
          v14 = v38;
          goto LABEL_46;
        case 246:
          v92 = *(_QWORD *)a3;
          *(_DWORD *)(v92 + 20) = 0;
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(v92 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 414;
        case 247:
          v93 = *(_QWORD *)a3;
          *(_DWORD *)(v93 + 20) = 0;
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(v93 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 408;
        case 248:
          v94 = *(_QWORD *)a3;
          *(_DWORD *)(v94 + 20) = 0;
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(v94 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 413;
        case 249:
          v95 = *(_QWORD *)a3;
          *(_DWORD *)(v95 + 20) = 0;
          *(_DWORD *)(v95 + 4) = 1;
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(v95 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 404;
        case 250:
          v96 = *(_QWORD *)a3;
          *(_DWORD *)(v96 + 20) = 0;
          *(_DWORD *)(v96 + 4) = 0;
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(v96 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 405;
        case 251:
          v97 = *(_QWORD *)a3;
          if (*(_DWORD *)(*(_QWORD *)a3 + 4))
            *(_DWORD *)(v97 + 20) = 0;
          *(_QWORD *)(v5 + 8) = *(_QWORD *)(v97 + 344);
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 411;
        case 252:
          *(_DWORD *)(a3 + 84) = 3;
          return 410;
        case 253:
          *(_DWORD *)(a3 + 84) = 1;
          v98 = v5;
          strlen(*(const char **)(a3 + 136));
          v99 = (char *)glpCompilerPoolAlloc(*(_QWORD *)(*(_QWORD *)a3 + 784));
          *(_QWORD *)v98 = v99;
          strcpy(v99, *(const char **)(a3 + 136));
          *(_QWORD *)(v98 + 8) = *(_QWORD *)(*(_QWORD *)a3 + 344);
          *(_DWORD *)(v98 + 16) = *(_DWORD *)(*(_QWORD *)a3 + 340);
          return 382;
        case 256:
          v100 = glpCompilerGetInfoLog(*(_QWORD *)(*(_QWORD *)a3 + 784));
          StringBuffer = (uint64_t *)glpLogGetStringBuffer(v100);
          glpStringBufferAppendFormat(StringBuffer, "FLEX: Unknown char %s\n", v102, v103, v104, v105, v106, v107, *(_QWORD *)(a3 + 136));
          return 0;
        case 257:
          v111 = v14;
          v113 = v13;
          v115 = v5;
          v39 = v12;
          v40 = v3;
          fwrite(*(const void **)(a3 + 136), *(_QWORD *)(a3 + 64), 1uLL, *(FILE **)(a3 + 16));
          v3 = v40;
          v14 = v111;
LABEL_46:
          v13 = v113;
          v5 = v115;
          v12 = v39;
          goto LABEL_13;
        case 258:
          v25 = *(_QWORD *)(a3 + 136);
          *v23 = *(_BYTE *)(a3 + 48);
          v26 = *(_QWORD *)(a3 + 40);
          v27 = *(_QWORD *)(a3 + 24);
          v28 = *(_QWORD *)(v26 + 8 * v27);
          if (*(_DWORD *)(v28 + 64))
          {
            v29 = *(_QWORD *)(a3 + 56);
          }
          else
          {
            v29 = *(_QWORD *)(v28 + 32);
            *(_QWORD *)(a3 + 56) = v29;
            *(_QWORD *)v28 = *(_QWORD *)(a3 + 8);
            v28 = *(_QWORD *)(v26 + 8 * v27);
            *(_DWORD *)(v28 + 64) = 1;
          }
          v110 = v14;
          v112 = v13;
          v114 = v5;
          v109 = v12;
          if (*v12 <= (unint64_t)(*(_QWORD *)(v28 + 8) + v29))
          {
            *(_QWORD *)(a3 + 72) = *(_QWORD *)(a3 + 136) + ~(_DWORD)v25 + (int)v23;
            previous_state = yy_get_previous_state(a3);
            if (yy_accept[previous_state])
            {
              v33 = *(_QWORD *)(a3 + 72);
              *(_DWORD *)(a3 + 112) = previous_state;
              *(_QWORD *)(a3 + 120) = v33;
            }
            v34 = previous_state;
            v35 = yy_base[previous_state] + 1;
            v13 = v112;
            v5 = v114;
            v12 = v109;
            v14 = v110;
            v3 = &jpt_22A942A84;
            if (previous_state != (__int16)yy_chk[v35])
            {
              do
              {
                v36 = (unsigned __int16)yy_def[v34];
                v34 = (__int16)v36;
                v35 = yy_base[(__int16)v36] + 1;
              }
              while (v36 != yy_chk[v35]);
            }
            v37 = (unsigned __int16)yy_nxt[v35];
            v15 = *(unsigned __int8 **)(a3 + 136);
            if (yy_nxt[v35] && v37 != 875)
            {
              v16 = (__int16)v37;
              v17 = (unsigned __int8 *)(*v109 + 1);
              *v109 = v17;
              goto LABEL_14;
            }
            continue;
          }
          v108 = v25;
          next_buffer = yy_get_next_buffer((_QWORD *)a3);
          if (next_buffer == 1)
          {
            *(_DWORD *)(a3 + 88) = 0;
            *(_QWORD *)(a3 + 72) = *(_QWORD *)(a3 + 136);
            v31 = *(_DWORD *)(a3 + 84);
            if (v31 >= 1)
              --v31;
            v24 = (v31 >> 1) + 259;
            v13 = v112;
            v5 = v114;
            v12 = v109;
            v14 = v110;
            v3 = &jpt_22A942A84;
            goto LABEL_23;
          }
          v13 = v112;
          v5 = v114;
          v14 = v110;
          v3 = &jpt_22A942A84;
          if (next_buffer == 2)
          {
            *(_QWORD *)(a3 + 72) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 40) + 8 * *(_QWORD *)(a3 + 24)) + 8)
                                 + *(_QWORD *)(a3 + 56);
            v21 = yy_get_previous_state(a3);
            v3 = &jpt_22A942A84;
            v14 = v110;
            v13 = v112;
            v5 = v114;
            v15 = *(unsigned __int8 **)(a3 + 136);
            v12 = v109;
            v22 = (_BYTE **)v109;
            goto LABEL_22;
          }
          v12 = v109;
          if (!next_buffer)
          {
            *(_QWORD *)(a3 + 72) = *(_QWORD *)(a3 + 136) + ~v108 + (int)v23;
            v16 = yy_get_previous_state(a3);
            v3 = &jpt_22A942A84;
            v14 = v110;
            v13 = v112;
            v12 = v109;
            v5 = v114;
            v17 = *(unsigned __int8 **)(a3 + 72);
            v15 = *(unsigned __int8 **)(a3 + 136);
            goto LABEL_14;
          }
          break;
        case 259:
        case 260:
          v54 = *(_QWORD *)a3;
          *(_DWORD *)(*(_QWORD *)a3 + 16) = 1;
          v55 = *(_QWORD *)(a3 + 40);
          if (v55)
            v56 = *(void ***)(v55 + 8 * *(_QWORD *)(a3 + 24));
          else
            v56 = 0;
          yy_delete_buffer(v56, *(_QWORD *)(v54 + 24));
          return 0;
        default:
          glpLexerFatalError();
      }
      break;
    }
  }
}

double yyensure_buffer_stack(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  char *v6;
  double result;
  _QWORD *v8;

  v2 = (void *)a1[5];
  if (v2)
  {
    v3 = a1[4];
    if (a1[3] >= (unint64_t)(v3 - 1))
    {
      v4 = v3 + 8;
      v5 = (char *)malloc_type_realloc(v2, 8 * (v3 + 8), 0x2BDC8648uLL);
      if (v5)
      {
        a1[5] = v5;
        v6 = &v5[8 * a1[4]];
        result = 0.0;
        *((_OWORD *)v6 + 2) = 0u;
        *((_OWORD *)v6 + 3) = 0u;
        *(_OWORD *)v6 = 0u;
        *((_OWORD *)v6 + 1) = 0u;
        a1[4] = v4;
        return result;
      }
LABEL_8:
      abort();
    }
  }
  else
  {
    v8 = malloc_type_malloc(8uLL, 0x7081ABB9uLL);
    if (!v8)
      goto LABEL_8;
    a1[5] = v8;
    *v8 = 0;
    result = 0.0;
    *(_OWORD *)(a1 + 3) = xmmword_22A97FDD0;
  }
  return result;
}

uint64_t yy_create_buffer(uint64_t a1, int a2, uint64_t a3)
{
  _DWORD *v6;
  uint64_t v7;
  void *v8;

  v6 = malloc_type_malloc(0x48uLL, 0x7081ABB9uLL);
  if (!v6 || (v7 = (uint64_t)v6, v6[6] = a2, (v8 = malloc_type_malloc(a2 + 2, 0x7081ABB9uLL)) == 0))
    abort();
  *(_QWORD *)(v7 + 8) = v8;
  *(_DWORD *)(v7 + 40) = 1;
  yy_init_buffer(v7, a1, a3);
  return v7;
}

BOOL glpIsExtensionEnabled(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4 * a2 + 616) != 3;
}

uint64_t glpPaIdentOrType(uint64_t a1, char *__s)
{
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;

  if (*(_DWORD *)(a1 + 20))
    return 377;
  v5 = *(_QWORD *)(a1 + 32);
  v6 = strlen(__s);
  if (v6 >> 5 >= v6)
  {
    v8 = v6;
  }
  else
  {
    v7 = v6;
    v8 = v6;
    do
    {
      v8 ^= 32 * v8 + (v8 >> 2) + __s[v7 - 1];
      v7 += ~(v6 >> 5);
    }
    while (v7 > v6 >> 5);
  }
  if (!glpStringHashGet(v5, __s, v6 | ((unint64_t)v8 << 32)))
    return 377;
  *(_DWORD *)(a1 + 20) = 1;
  return 378;
}

uint64_t glpPaReservedWord(uint64_t a1)
{
  uint64_t v2;
  uint64_t **InfoLog;
  const char *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v13[3];

  v2 = *(_QWORD *)(a1 + 24);
  InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(_QWORD *)(a1 + 784));
  v4 = *(const char **)(a1 + 344);
  v5 = strlen(v4);
  if (v5 >> 5 >= v5)
  {
    v7 = v5;
  }
  else
  {
    v6 = v5;
    v7 = v5;
    do
    {
      v7 ^= 32 * v7 + (v7 >> 2) + v4[v6 - 1];
      v6 += ~(v5 >> 5);
    }
    while (v6 > v5 >> 5);
  }
  glpMakeSourceLocation((uint64_t)v4, v5 | ((unint64_t)v7 << 32), *(_DWORD *)(a1 + 340), v13);
  glpLogMessage(InfoLog, 0, (uint64_t)v13, "'%s' : Reserved word. ", v8, v9, v10, v11, *(_QWORD *)(v2 + 136));
  return glpParseRecover(a1);
}

const char *glpMakeStringZ(const char *a1)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;

  v2 = strlen(a1);
  if (v2 >> 5 < v2)
  {
    v3 = v2;
    v4 = v2;
    do
    {
      v4 ^= 32 * v4 + (v4 >> 2) + a1[v3 - 1];
      v3 += ~(v2 >> 5);
    }
    while (v3 > v2 >> 5);
  }
  return a1;
}

uint64_t glpPaParseComment(uint64_t a1, _DWORD *a2)
{
  char v4;
  char v5;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  int v9;
  _BYTE *v10;
  uint64_t v11;
  int next_buffer;

LABEL_1:
  v4 = 0;
  do
  {
    while (1)
    {
      v5 = v4;
      v6 = *(_QWORD *)(a1 + 24);
      **(_BYTE **)(v6 + 72) = *(_BYTE *)(v6 + 48);
      v7 = *(_BYTE **)(v6 + 72);
      if (!*v7)
      {
        if ((unint64_t)v7 >= *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 40) + 8 * *(_QWORD *)(v6 + 24)) + 8)
                                   + *(_QWORD *)(v6 + 56))
        {
          v11 = *(_QWORD *)(v6 + 136);
          *(_QWORD *)(v6 + 72) = v7 + 1;
          next_buffer = yy_get_next_buffer((_QWORD *)v6);
          if (next_buffer)
          {
            if (next_buffer == 1)
              goto LABEL_1;
            if (next_buffer == 2)
            {
              yyrestart(*(_QWORD *)(v6 + 8), v6);
              goto LABEL_1;
            }
          }
          else
          {
            *(_QWORD *)(v6 + 72) = &v7[*(_QWORD *)(v6 + 136) - v11];
          }
        }
        else
        {
          *v7 = 0;
        }
      }
      v8 = *(_BYTE **)(v6 + 72);
      v9 = *v8;
      *v8 = 0;
      v10 = (_BYTE *)(*(_QWORD *)(v6 + 72) + 1);
      *(_QWORD *)(v6 + 72) = v10;
      *(_BYTE *)(v6 + 48) = *v10;
      if (v9 == 47)
        break;
      v4 = 1;
      if (v9 != 42)
      {
        if (v9 == 10)
          ++*a2;
        goto LABEL_1;
      }
    }
    v4 = 0;
  }
  while ((v5 & 1) == 0);
  return 1;
}

void yy_delete_buffer(void **a1, uint64_t a2)
{
  uint64_t v3;
  void **v4;

  if (a1)
  {
    v3 = *(_QWORD *)(a2 + 40);
    if (v3)
      v4 = *(void ***)(v3 + 8 * *(_QWORD *)(a2 + 24));
    else
      v4 = 0;
    if (v4 == a1)
      *(_QWORD *)(v3 + 8 * *(_QWORD *)(a2 + 24)) = 0;
    if (*((_DWORD *)a1 + 10))
      free(a1[1]);
    free(a1);
  }
}

uint64_t yy_get_previous_state(uint64_t a1)
{
  uint64_t v1;
  _BYTE *v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v1 = *(unsigned int *)(a1 + 84);
  v2 = *(_BYTE **)(a1 + 136);
  v3 = *(_BYTE **)(a1 + 72);
  if (v2 < v3)
  {
    do
    {
      if (*v2)
        v4 = yy_ec[*v2];
      else
        v4 = 1u;
      if (yy_accept[(int)v1])
      {
        *(_DWORD *)(a1 + 112) = v1;
        *(_QWORD *)(a1 + 120) = v2;
      }
      v5 = (int)v1;
      v6 = yy_base[(int)v1] + v4;
      if ((_DWORD)v1 != (__int16)yy_chk[v6])
      {
        do
        {
          v5 = yy_def[v5];
          if (v5 >= 876)
            v4 = *((unsigned __int8 *)&yy_meta + v4);
          v6 = yy_base[v5] + v4;
        }
        while (yy_chk[v6] != (unsigned __int16)v5);
      }
      v1 = yy_nxt[v6];
      ++v2;
    }
    while (v2 != v3);
  }
  return v1;
}

uint64_t yy_get_next_buffer(_QWORD *a1)
{
  uint64_t v1;
  _BYTE *v2;
  unint64_t v3;
  char *v5;
  int v6;
  int v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  unsigned int v13;
  char *v14;
  void *v15;
  int v16;
  char *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  BOOL v21;
  unint64_t v22;
  unint64_t v23;
  size_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v1 = *(_QWORD *)(a1[5] + 8 * a1[3]);
  v2 = *(_BYTE **)(v1 + 8);
  v3 = a1[9];
  if (v3 > (unint64_t)&v2[a1[7] + 1])
    goto LABEL_38;
  v5 = (char *)a1[17];
  if (*(_DWORD *)(v1 + 60))
  {
    v6 = ~(_DWORD)v5 + v3;
    if (v6 >= 1)
    {
      v7 = ~(_DWORD)v5 + v3;
      do
      {
        v8 = *v5++;
        *v2++ = v8;
        --v7;
      }
      while (v7);
      v1 = *(_QWORD *)(a1[5] + 8 * a1[3]);
    }
    v9 = v6;
    if (*(_DWORD *)(v1 + 64) == 2)
    {
      a1[7] = 0;
    }
    else
    {
      v11 = ~v6;
      v12 = *(_DWORD *)(v1 + 24);
      v13 = v12 + ~v6;
      if (!v13)
      {
        v14 = (char *)a1[9];
        while (*(_DWORD *)(v1 + 40))
        {
          v15 = *(void **)(v1 + 8);
          v16 = 2 * v12;
          *(_DWORD *)(v1 + 24) = v16;
          v17 = (char *)malloc_type_realloc(v15, v16 + 2, 0x2BDC8648uLL);
          if (!v17)
            goto LABEL_36;
          *(_QWORD *)(v1 + 8) = v17;
          v14 = &v17[(int)v14 - (int)v15];
          a1[9] = v14;
          v1 = *(_QWORD *)(a1[5] + 8 * a1[3]);
          v12 = *(_DWORD *)(v1 + 24);
          v13 = v12 + v11;
          if (v12 + v11)
            goto LABEL_17;
        }
        *(_QWORD *)(v1 + 8) = 0;
        goto LABEL_38;
      }
LABEL_17:
      if (v13 >= 0x2000)
        v18 = 0x2000;
      else
        v18 = v13;
      v19 = yylex_CPP(*a1 + 40, *(_QWORD *)(v1 + 8) + v6, v18);
      a1[7] = v19;
      if (v19)
      {
        if (v19 >= v18)
          goto LABEL_38;
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1[5] + 8 * a1[3]) + 8) + v6 + v19) = 32;
        v20 = a1[7];
        v21 = __CFADD__(v20, 1);
        v22 = v20 + 1;
        a1[7] = v22;
        v1 = *(_QWORD *)(a1[5] + 8 * a1[3]);
        *(_QWORD *)(v1 + 32) = v22;
        if (!v21)
        {
          v10 = 0;
LABEL_29:
          v23 = v22 + v6;
          if (v23 <= *(int *)(v1 + 24))
          {
            v29 = *(_QWORD *)(v1 + 8);
            goto LABEL_34;
          }
          v24 = v23 + (v22 >> 1);
          v25 = malloc_type_realloc(*(void **)(v1 + 8), v24, 0x2BDC8648uLL);
          if (!v25)
LABEL_36:
            abort();
          v26 = a1[5];
          v27 = a1[3];
          *(_QWORD *)(*(_QWORD *)(v26 + 8 * v27) + 8) = v25;
          v28 = *(_QWORD *)(v26 + 8 * v27);
          v29 = *(_QWORD *)(v28 + 8);
          if (v29)
          {
            *(_DWORD *)(v28 + 24) = v24 - 2;
            v23 = a1[7] + v9;
LABEL_34:
            a1[7] = v23;
            *(_BYTE *)(v29 + v23) = 0;
            *(_BYTE *)(a1[7] + *(_QWORD *)(*(_QWORD *)(a1[5] + 8 * a1[3]) + 8) + 1) = 0;
            a1[17] = *(_QWORD *)(*(_QWORD *)(a1[5] + 8 * a1[3]) + 8);
            return v10;
          }
LABEL_38:
          glpLexerFatalError();
        }
LABEL_26:
        if (v6)
        {
          v22 = 0;
          v10 = 2;
          *(_DWORD *)(v1 + 64) = 2;
        }
        else
        {
          yyrestart(a1[1], (uint64_t)a1);
          v22 = a1[7];
          v1 = *(_QWORD *)(a1[5] + 8 * a1[3]);
          v10 = 1;
        }
        goto LABEL_29;
      }
      a1[7] = 0;
      v1 = *(_QWORD *)(a1[5] + 8 * a1[3]);
    }
    *(_QWORD *)(v1 + 32) = 0;
    goto LABEL_26;
  }
  if (v3 - (_QWORD)v5 == 1)
    return 1;
  else
    return 2;
}

int *yyrestart(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t buffer;
  uint64_t v7;
  int *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;

  v4 = *(_QWORD *)(a2 + 40);
  if (v4 && (v5 = *(_QWORD *)(a2 + 24), *(_QWORD *)(v4 + 8 * v5))
    || (yyensure_buffer_stack((_QWORD *)a2),
        buffer = yy_create_buffer(*(_QWORD *)(a2 + 8), 0x4000, a2),
        v5 = *(_QWORD *)(a2 + 24),
        *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * v5) = buffer,
        (v4 = *(_QWORD *)(a2 + 40)) != 0))
  {
    v7 = *(_QWORD *)(v4 + 8 * v5);
  }
  else
  {
    v7 = 0;
  }
  result = yy_init_buffer(v7, a1, a2);
  v9 = *(_QWORD *)(a2 + 40);
  v10 = *(_QWORD *)(a2 + 24);
  v11 = *(_QWORD *)(v9 + 8 * v10);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(v11 + 32);
  v12 = *(_BYTE **)(v11 + 16);
  *(_QWORD *)(a2 + 72) = v12;
  *(_QWORD *)(a2 + 136) = v12;
  *(_QWORD *)(a2 + 8) = **(_QWORD **)(v9 + 8 * v10);
  *(_BYTE *)(a2 + 48) = *v12;
  return result;
}

int *yy_init_buffer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t v7;
  int *result;

  v6 = *__error();
  yy_flush_buffer(a1, a3);
  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 60) = 1;
  v7 = *(_QWORD *)(a3 + 40);
  if (v7)
    v7 = *(_QWORD *)(v7 + 8 * *(_QWORD *)(a3 + 24));
  if (v7 != a1)
    *(_QWORD *)(a1 + 52) = 1;
  *(_DWORD *)(a1 + 44) = 0;
  result = __error();
  *result = v6;
  return result;
}

uint64_t yy_flush_buffer(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;

  if (result)
  {
    *(_QWORD *)(result + 32) = 0;
    **(_BYTE **)(result + 8) = 0;
    *(_BYTE *)(*(_QWORD *)(result + 8) + 1) = 0;
    *(_QWORD *)(result + 16) = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 48) = 1;
    *(_DWORD *)(result + 64) = 0;
    v2 = *(_QWORD *)(a2 + 40);
    if (v2)
      v3 = *(_QWORD *)(v2 + 8 * *(_QWORD *)(a2 + 24));
    else
      v3 = 0;
    if (v3 == result)
    {
      v4 = *(_QWORD *)(a2 + 24);
      v5 = *(_QWORD *)(v2 + 8 * v4);
      *(_QWORD *)(a2 + 56) = *(_QWORD *)(v5 + 32);
      v6 = *(_BYTE **)(v5 + 16);
      *(_QWORD *)(a2 + 72) = v6;
      *(_QWORD *)(a2 + 136) = v6;
      *(_QWORD *)(a2 + 8) = **(_QWORD **)(v2 + 8 * v4);
      *(_BYTE *)(a2 + 48) = *v6;
    }
  }
  return result;
}

void yypop_buffer_state(uint64_t a1)
{
  uint64_t v1;
  void **v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;

  v1 = *(_QWORD *)(a1 + 40);
  if (v1)
  {
    v3 = *(void ***)(v1 + 8 * *(_QWORD *)(a1 + 24));
    if (v3)
    {
      yy_delete_buffer(v3, a1);
      v4 = *(_QWORD *)(a1 + 24);
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v4) = 0;
      if (v4)
        *(_QWORD *)(a1 + 24) = --v4;
      v5 = *(_QWORD *)(a1 + 40);
      if (v5)
      {
        v6 = *(_QWORD *)(v5 + 8 * v4);
        if (v6)
        {
          *(_QWORD *)(a1 + 56) = *(_QWORD *)(v6 + 32);
          v7 = *(_BYTE **)(v6 + 16);
          *(_QWORD *)(a1 + 72) = v7;
          *(_QWORD *)(a1 + 136) = v7;
          *(_QWORD *)(a1 + 8) = **(_QWORD **)(v5 + 8 * v4);
          *(_BYTE *)(a1 + 48) = *v7;
          *(_DWORD *)(a1 + 88) = 1;
        }
      }
    }
  }
}

uint64_t yylex_init(uint64_t *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t result;
  uint64_t v5;

  if (a1)
  {
    v2 = malloc_type_malloc(0x98uLL, 0x7081ABB9uLL);
    if (!v2)
      abort();
    v3 = v2;
    result = 0;
    *a1 = (uint64_t)v3;
    v3[18] = 0;
    *((_OWORD *)v3 + 7) = 0u;
    *((_OWORD *)v3 + 8) = 0u;
    *((_OWORD *)v3 + 5) = 0u;
    *((_OWORD *)v3 + 6) = 0u;
    *((_OWORD *)v3 + 3) = 0u;
    *((_OWORD *)v3 + 4) = 0u;
    *((_OWORD *)v3 + 1) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    *(_OWORD *)v3 = 0u;
    v5 = *a1;
    *(_DWORD *)(v5 + 92) = 0;
    *(_DWORD *)(v5 + 96) = 0;
    *(_QWORD *)(v5 + 104) = 0;
    *(_OWORD *)(v5 + 8) = 0u;
    *(_OWORD *)(v5 + 24) = 0u;
    *(_QWORD *)(v5 + 40) = 0;
    *(_QWORD *)(v5 + 72) = 0;
    *(_QWORD *)(v5 + 80) = 0;
  }
  else
  {
    *__error() = 22;
    return 1;
  }
  return result;
}

uint64_t yylex_destroy(uint64_t a1)
{
  _QWORD *i;

  for (i = *(_QWORD **)(a1 + 40); i; i = *(_QWORD **)(a1 + 40))
  {
    if (!i[*(_QWORD *)(a1 + 24)])
      break;
    yy_delete_buffer((void **)i[*(_QWORD *)(a1 + 24)], a1);
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * *(_QWORD *)(a1 + 24)) = 0;
    yypop_buffer_state(a1);
  }
  free(i);
  *(_QWORD *)(a1 + 40) = 0;
  free(*(void **)(a1 + 104));
  free((void *)a1);
  return 0;
}

uint64_t glpPaParseStrings(uint64_t a1, uint64_t *a2, int *a3, int a4, int a5)
{
  uint64_t v10;
  uint64_t *v11;
  uint64_t NameTable;
  _QWORD *v13;
  uint64_t **InfoLog;
  const char *v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD v24[3];
  int v25;

  ScanFromString(a1 + 40, *a2);
  if (a4)
  {
    v25 = 0;
    if (a4 < 1)
    {
LABEL_6:
      if (!a3)
      {
        v25 = strlen((const char *)*a2);
        a3 = &v25;
      }
      yyrestart(0, *(_QWORD *)(a1 + 24));
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 364) = 0;
      *(_QWORD *)(a1 + 384) = a2;
      *(_DWORD *)(a1 + 376) = a4;
      *(_QWORD *)(a1 + 368) = a3;
      *(_DWORD *)(a1 + 68) = 0;
      NameTable = glpCompilerGetNameTable(*(_QWORD *)(a1 + 784));
      *(_DWORD *)(a1 + 40) = glpNameTableGetGLSLVersion(NameTable);
      *(_DWORD *)(a1 + 44) = 0;
      glpInitializeExtensionBehavior(a1);
      if ((**(_DWORD **)(a1 + 368) & 0x80000000) != 0)
        return 0;
      yyparse(a1);
      if (*(_DWORD *)(a1 + 360) != 1 && !*(_DWORD *)(a1 + 8) && *(int *)(a1 + 12) < 1)
        return 0;
      if (a5)
      {
        while (1)
        {
          v13 = *(_QWORD **)(a1 + 56);
          if (!v13)
            break;
          *(_QWORD *)(a1 + 56) = v13[1];
          free(v13);
        }
      }
    }
    else
    {
      v10 = a4;
      v11 = a2;
      while (*v11)
      {
        ++v11;
        if (!--v10)
          goto LABEL_6;
      }
      InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(_QWORD *)(a1 + 784));
      v15 = *(const char **)(a1 + 344);
      v16 = strlen(v15);
      if (v16 >> 5 >= v16)
      {
        v18 = v16;
      }
      else
      {
        v17 = v16;
        v18 = v16;
        do
        {
          v18 ^= 32 * v18 + (v18 >> 2) + v15[v17 - 1];
          v17 += ~(v16 >> 5);
        }
        while (v17 > v16 >> 5);
      }
      glpMakeSourceLocation((uint64_t)v15, v16 | ((unint64_t)v18 << 32), *(_DWORD *)(a1 + 340), v24);
      glpLogMessage(InfoLog, 0, (uint64_t)v24, "'' : NULL shader source string ", v20, v21, v22, v23, v24[0]);
      glpParseRecover(a1);
    }
  }
  return 1;
}

void yyerror(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t **InfoLog;
  const char *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t **v11;
  const char *v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD v24[3];
  _QWORD v25[3];

  if (*(_DWORD *)(a2 + 16))
  {
    if ((*(_BYTE *)(a2 + 392) & 1) == 0)
      return;
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(_QWORD *)(a2 + 784));
    v6 = *(const char **)(a2 + 344);
    v7 = strlen(v6);
    if (v7 >> 5 >= v7)
    {
      v9 = v7;
    }
    else
    {
      v8 = v7;
      v9 = v7;
      do
      {
        v9 ^= 32 * v9 + (v9 >> 2) + v6[v8 - 1];
        v8 += ~(v7 >> 5);
      }
      while (v8 > v7 >> 5);
    }
    glpMakeSourceLocation((uint64_t)v6, v7 | ((unint64_t)v9 << 32), *(_DWORD *)(a2 + 340), v25);
    glpLogMessage(InfoLog, 0, (uint64_t)v25, "'premature EOF' : syntax error %s", v20, v21, v22, v23, a3);
  }
  else
  {
    v10 = *(_QWORD *)(a2 + 24);
    v11 = (uint64_t **)glpCompilerGetInfoLog(*(_QWORD *)(a2 + 784));
    v12 = *(const char **)(a2 + 344);
    v13 = strlen(v12);
    if (v13 >> 5 >= v13)
    {
      v15 = v13;
    }
    else
    {
      v14 = v13;
      v15 = v13;
      do
      {
        v15 ^= 32 * v15 + (v15 >> 2) + v12[v14 - 1];
        v14 += ~(v13 >> 5);
      }
      while (v14 > v13 >> 5);
    }
    glpMakeSourceLocation((uint64_t)v12, v13 | ((unint64_t)v15 << 32), *(_DWORD *)(a2 + 340), v24);
    glpLogMessage(v11, 0, (uint64_t)v24, "'%s' : syntax error: %s", v16, v17, v18, v19, *(_QWORD *)(v10 + 136));
  }
  glpParseRecover(a2);
}

uint64_t **glpCPPWarningToInfoLog(uint64_t a1, char a2)
{
  uint64_t v3;
  uint64_t **InfoLog;
  const char *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v14[3];

  v3 = *(_QWORD *)(a1 + 32);
  InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(_QWORD *)(v3 + 784));
  v5 = *(const char **)(v3 + 344);
  v6 = strlen(v5);
  if (v6 >> 5 >= v6)
  {
    v8 = v6;
  }
  else
  {
    v7 = v6;
    v8 = v6;
    do
    {
      v8 ^= 32 * v8 + (v8 >> 2) + v5[v7 - 1];
      v7 += ~(v6 >> 5);
    }
    while (v7 > v6 >> 5);
  }
  glpMakeSourceLocation((uint64_t)v5, v6 | ((unint64_t)v8 << 32), *(_DWORD *)(v3 + 340), v14);
  return glpLogMessage(InfoLog, 1u, (uint64_t)v14, "%s", v9, v10, v11, v12, a2);
}

uint64_t glpCPPShInfoLogMsg(uint64_t a1, char a2)
{
  uint64_t v3;
  uint64_t **InfoLog;
  const char *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v14[3];

  v3 = *(_QWORD *)(a1 + 32);
  InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(_QWORD *)(v3 + 784));
  v5 = *(const char **)(v3 + 344);
  v6 = strlen(v5);
  if (v6 >> 5 >= v6)
  {
    v8 = v6;
  }
  else
  {
    v7 = v6;
    v8 = v6;
    do
    {
      v8 ^= 32 * v8 + (v8 >> 2) + v5[v7 - 1];
      v7 += ~(v6 >> 5);
    }
    while (v7 > v6 >> 5);
  }
  glpMakeSourceLocation((uint64_t)v5, v6 | ((unint64_t)v8 << 32), *(_DWORD *)(v3 + 340), v14);
  glpLogMessage(InfoLog, 0, (uint64_t)v14, "'' :  %s", v9, v10, v11, v12, a2);
  return glpParseRecover(v3);
}

uint64_t glpCPPErrorToInfoLog(uint64_t a1, char a2)
{
  uint64_t v3;
  uint64_t **InfoLog;
  const char *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v14[3];

  v3 = *(_QWORD *)(a1 + 32);
  InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(_QWORD *)(v3 + 784));
  v5 = *(const char **)(v3 + 344);
  v6 = strlen(v5);
  if (v6 >> 5 >= v6)
  {
    v8 = v6;
  }
  else
  {
    v7 = v6;
    v8 = v6;
    do
    {
      v8 ^= 32 * v8 + (v8 >> 2) + v5[v7 - 1];
      v7 += ~(v6 >> 5);
    }
    while (v7 > v6 >> 5);
  }
  glpMakeSourceLocation((uint64_t)v5, v6 | ((unint64_t)v8 << 32), *(_DWORD *)(v3 + 340), v14);
  glpLogMessage(InfoLog, 0, (uint64_t)v14, "'' : syntax error: %s", v9, v10, v11, v12, a2);
  return glpParseRecover(v3);
}

uint64_t glpHandlePragma(uint64_t a1, const char **a2, int a3)
{
  uint64_t v6;
  const char *v7;
  uint64_t result;
  const char *v9;
  const char *v10;
  const char *v11;
  int v12;
  int v13;

  v6 = *(_QWORD *)(a1 + 32);
  v7 = *a2;
  if (!strcmp(*a2, "optimize"))
  {
    if (a3 == 4)
    {
      if (!strcmp(a2[1], "("))
      {
        v10 = a2[2];
        if (!strcmp(v10, "on"))
        {
          v12 = 1;
        }
        else
        {
          if (strcmp(v10, "off"))
          {
            v9 = "\"on\" or \"off\" expected after '(' for 'optimize' pragma";
            return glpCPPShInfoLogMsg(a1, (char)v9);
          }
          v12 = 0;
        }
        *(_DWORD *)(v6 + 608) = v12;
        result = strcmp(a2[3], ")");
        if (!(_DWORD)result)
          return result;
        v9 = "\")\" expected to end 'optimize' pragma";
      }
      else
      {
        v9 = "\"(\" expected after 'optimize' keyword";
      }
    }
    else
    {
      v9 = "optimize pragma syntax is incorrect";
    }
    return glpCPPShInfoLogMsg(a1, (char)v9);
  }
  if (!strcmp(v7, "debug"))
  {
    if (a3 == 4)
    {
      if (!strcmp(a2[1], "("))
      {
        v11 = a2[2];
        if (!strcmp(v11, "on"))
        {
          v13 = 1;
        }
        else
        {
          if (strcmp(v11, "off"))
          {
            v9 = "\"on\" or \"off\" expected after '(' for 'debug' pragma";
            return glpCPPShInfoLogMsg(a1, (char)v9);
          }
          v13 = 0;
        }
        *(_DWORD *)(v6 + 612) = v13;
        result = strcmp(a2[3], ")");
        if (!(_DWORD)result)
          return result;
        v9 = "\")\" expected to end 'debug' pragma";
      }
      else
      {
        v9 = "\"(\" expected after 'debug' keyword";
      }
    }
    else
    {
      v9 = "debug pragma syntax is incorrect";
    }
    return glpCPPShInfoLogMsg(a1, (char)v9);
  }
  result = strcmp(v7, "STDGL");
  if (a3 >= 2 && !(_DWORD)result)
  {
    result = strcmp(a2[1], "invariant");
    if (!(_DWORD)result)
    {
      if (*(_DWORD *)(v6 + 40) && *(_DWORD *)v6 == 4)
      {
        v9 = "'STDGL invariant' pragma is not allowed in fragment shader except in OpenGL ES 2";
      }
      else if (a3 == 5)
      {
        if (!strcmp(a2[2], "("))
        {
          if (!strcmp(a2[3], "all"))
          {
            if (!strcmp(a2[4], ")"))
              return glpCompilerForceAllOutputsToBeInvariant(*(_QWORD *)(v6 + 784));
            v9 = "\")\" expected to end 'STDGL invariant' pragma";
          }
          else
          {
            v9 = "\"all\" expected after '(' for 'STDGL invariant' pragma";
          }
        }
        else
        {
          v9 = "\"(\" expected after 'invariant' keyword";
        }
      }
      else
      {
        v9 = "'STDGL invariant' pragma syntax is incorrect";
      }
      return glpCPPShInfoLogMsg(a1, (char)v9);
    }
  }
  return result;
}

uint64_t glpStoreErrMsg(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *StringBuffer;

  StringBuffer = *(uint64_t **)(a1 + 312);
  if (!StringBuffer)
  {
    StringBuffer = glpMakeStringBuffer(&GLP_MALLOC_ALLOCATOR);
    *(_QWORD *)(a1 + 312) = StringBuffer;
  }
  return glpStringBufferAppendFormat(StringBuffer, " %s", a3, a4, a5, a6, a7, a8, a2);
}

uint64_t glpGetErrMsg(uint64_t a1)
{
  return glpStringBufferGetCString(*(uint64_t **)(a1 + 312));
}

uint64_t glpResetErrMsg(uint64_t a1)
{
  uint64_t result;

  result = glpDestroyStringBuffer(*(_QWORD ***)(a1 + 312));
  *(_QWORD *)(a1 + 312) = 0;
  return result;
}

uint64_t **glpUpdateExtensionBehavior(uint64_t a1, char *a2, char *__s1)
{
  int v6;
  uint64_t **InfoLog;
  const char *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t **result;
  uint64_t **v22;
  const char *v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t i;
  uint64_t NameTable;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD v41[3];
  _QWORD v42[3];
  _QWORD v43[3];

  v6 = strcmp(__s1, "require");
  if (!v6)
  {
    v12 = 0;
    v13 = 1;
    goto LABEL_15;
  }
  if (!strcmp(__s1, "enable"))
  {
    v13 = 1;
    v12 = 1;
    goto LABEL_15;
  }
  if (strcmp(__s1, "disable"))
  {
    if (!strcmp(__s1, "warn"))
    {
      v13 = 0;
      v12 = 2;
      goto LABEL_15;
    }
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(_QWORD *)(a1 + 784));
    v8 = *(const char **)(a1 + 344);
    v9 = strlen(v8);
    if (v9 >> 5 >= v9)
    {
      v11 = v9;
    }
    else
    {
      v10 = v9;
      v11 = v9;
      do
      {
        v11 ^= 32 * v11 + (v11 >> 2) + v8[v10 - 1];
        v10 += ~(v9 >> 5);
      }
      while (v10 > v9 >> 5);
    }
    glpMakeSourceLocation((uint64_t)v8, v9 | ((unint64_t)v11 << 32), *(_DWORD *)(a1 + 340), v43);
    glpLogMessage(InfoLog, 0, (uint64_t)v43, "'' :  behavior '%s' is not supported", v14, v15, v16, v17, (char)__s1);
    glpParseRecover(a1);
  }
  v13 = 0;
  v12 = 3;
LABEL_15:
  if (!strcmp(a2, "all"))
  {
    if ((v13 & 1) != 0)
    {
      return (uint64_t **)glpCPPShInfoLogMsg(a1 + 40, (char)"extension 'all' cannot have 'require' or 'enable' behavior");
    }
    else
    {
      for (i = 0; i != 38; ++i)
      {
        result = (uint64_t **)glpExtensionAllowed(*(_QWORD *)(a1 + 784), i);
        if ((_DWORD)result)
        {
          *(_DWORD *)(a1 + 616 + 4 * i) = v12;
          NameTable = glpCompilerGetNameTable(*(_QWORD *)(a1 + 784));
          result = (uint64_t **)glpNameTableSetGLSLExtensionBehavior(NameTable, i, v12);
        }
      }
    }
  }
  else
  {
    v18 = glpExtensionFromString(a2);
    if (v18 == 38 || (v19 = v18, !glpExtensionAllowed(*(_QWORD *)(a1 + 784), v18)))
    {
      v22 = (uint64_t **)glpCompilerGetInfoLog(*(_QWORD *)(a1 + 784));
      v23 = *(const char **)(a1 + 344);
      v24 = strlen(v23);
      v25 = v24 >> 5;
      v26 = ~(v24 >> 5);
      if (v6)
      {
        if (v25 >= v24)
        {
          v28 = v24;
        }
        else
        {
          v27 = v24;
          v28 = v24;
          do
          {
            v28 ^= 32 * v28 + (v28 >> 2) + v23[v27 - 1];
            v27 += v26;
          }
          while (v27 > v25);
        }
        glpMakeSourceLocation((uint64_t)v23, v24 | ((unint64_t)v28 << 32), *(_DWORD *)(a1 + 340), v41);
        return glpLogMessage(v22, 1u, (uint64_t)v41, "extension '%s' is not supported", v33, v34, v35, v36, (char)a2);
      }
      else
      {
        if (v25 >= v24)
        {
          v32 = v24;
        }
        else
        {
          v31 = v24;
          v32 = v24;
          do
          {
            v32 ^= 32 * v32 + (v32 >> 2) + v23[v31 - 1];
            v31 += v26;
          }
          while (v31 > v25);
        }
        glpMakeSourceLocation((uint64_t)v23, v24 | ((unint64_t)v32 << 32), *(_DWORD *)(a1 + 340), v42);
        glpLogMessage(v22, 0, (uint64_t)v42, "'' :  extension '%s' is not supported", v37, v38, v39, v40, (char)a2);
        return (uint64_t **)glpParseRecover(a1);
      }
    }
    else
    {
      *(_DWORD *)(a1 + 4 * v19 + 616) = v12;
      v20 = glpCompilerGetNameTable(*(_QWORD *)(a1 + 784));
      return (uint64_t **)glpNameTableSetGLSLExtensionBehavior(v20, v19, v12);
    }
  }
  return result;
}

uint64_t glpParseContextSetGLSLVersion(uint64_t a1, int a2)
{
  char v2;
  int v4;
  int v5;
  uint64_t NameTable;
  uint64_t **InfoLog;
  const char *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[3];

  v2 = a2;
  v4 = glpGLSLVersionFromInt(a2);
  if (v4 == 10 || (v5 = v4, !glpGLSLVersionAllowed(*(_QWORD *)(a1 + 784), v4)))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(_QWORD *)(a1 + 784));
    v9 = *(const char **)(a1 + 344);
    v10 = strlen(v9);
    if (v10 >> 5 >= v10)
    {
      v12 = v10;
    }
    else
    {
      v11 = v10;
      v12 = v10;
      do
      {
        v12 ^= 32 * v12 + (v12 >> 2) + v9[v11 - 1];
        v11 += ~(v10 >> 5);
      }
      while (v11 > v10 >> 5);
    }
    glpMakeSourceLocation((uint64_t)v9, v10 | ((unint64_t)v12 << 32), *(_DWORD *)(a1 + 340), v17);
    glpLogMessage(InfoLog, 0, (uint64_t)v17, "'' :  version '%d' is not supported", v13, v14, v15, v16, v2);
    return glpParseRecover(a1);
  }
  else
  {
    *(_DWORD *)(a1 + 40) = v5;
    *(_DWORD *)(a1 + 44) = 1;
    NameTable = glpCompilerGetNameTable(*(_QWORD *)(a1 + 784));
    return glpNameTableSetGLSLVersion(NameTable, v5);
  }
}

uint64_t glpParseContextValidateGLSLVersion(uint64_t a1)
{
  uint64_t result;
  uint64_t **InfoLog;
  const char *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  _QWORD v13[3];

  result = glpGLSLVersionRequired(*(_QWORD *)(a1 + 784), *(_DWORD *)(a1 + 40));
  if ((_DWORD)result && !*(_DWORD *)(a1 + 44))
  {
    InfoLog = (uint64_t **)glpCompilerGetInfoLog(*(_QWORD *)(a1 + 784));
    v4 = *(const char **)(a1 + 344);
    v5 = strlen(v4);
    if (v5 >> 5 >= v5)
    {
      v7 = v5;
    }
    else
    {
      v6 = v5;
      v7 = v5;
      do
      {
        v7 ^= 32 * v7 + (v7 >> 2) + v4[v6 - 1];
        v6 += ~(v5 >> 5);
      }
      while (v6 > v5 >> 5);
    }
    glpMakeSourceLocation((uint64_t)v4, v5 | ((unint64_t)v7 << 32), *(_DWORD *)(a1 + 340), v13);
    glpLogMessage(InfoLog, 0, (uint64_t)v13, "'' :  #version required and missing.", v8, v9, v10, v11, v12);
    return glpParseRecover(a1);
  }
  return result;
}

uint64_t glpLexerNew(uint64_t a1)
{
  uint64_t result;

  result = yylex_init((uint64_t *)(a1 + 24));
  **(_QWORD **)(a1 + 24) = a1;
  return result;
}

uint64_t glpLexerFree(uint64_t a1)
{
  return yylex_destroy(*(_QWORD *)(a1 + 24));
}

uint64_t yyparse(uint64_t a1)
{
  void *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  char *v6;
  __int128 v7;
  int v8;
  uint64_t v9;
  void *v10;
  uint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  __int16 *v24;
  int v25;
  __int16 *v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  int v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unsigned int v41;
  int v42;
  char *v43;
  __int128 v44;
  int v45;
  int v46;
  int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  _QWORD *v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  char *v67;
  __int128 v68;
  int v69;
  __int128 v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  __int128 v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  _OWORD v79[8];
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  _OWORD v84[2];
  _BYTE v85[32];
  __int128 v86;
  _OWORD v87[12];
  void *v88[2];
  __int128 v89;
  void *v90[2];
  void *v91;
  unint64_t v92;
  uint64_t v93;

  *(_OWORD *)v90 = 0u;
  *(_OWORD *)v88 = 0u;
  memset(v87, 0, sizeof(v87));
  memset(v84, 0, sizeof(v84));
  v82 = 0u;
  v83 = 0u;
  v80 = 0u;
  v81 = 0u;
  memset(v79, 0, sizeof(v79));
  *(_OWORD *)&v85[16] = 0uLL;
  *((_QWORD *)&v86 + 1) = 1;
  *(_QWORD *)&v86 = 1;
  *(_OWORD *)v85 = 0xFFFFFFFE00000000;
  v89 = 0xC8uLL;
  v2 = malloc_type_malloc(0x3840uLL, 0x7081ABB9uLL);
  if (!v2)
    goto LABEL_142;
  v88[0] = v2;
  v88[1] = v2;
  *((_QWORD *)&v89 + 1) = 0;
  v90[0] = 0;
  v92 = 1;
  v93 = 16;
  v3 = malloc_type_malloc(0x80uLL, 0x7081ABB9uLL);
  if (!v3)
    goto LABEL_142;
  v90[1] = v3;
  *v3 = 0;
  v4 = malloc_type_malloc(0x10uLL, 0x7081ABB9uLL);
  if (!v4)
    goto LABEL_142;
  v91 = v4;
  v5 = setjmp((int *)v87);
  if ((_DWORD)v5 == 2)
  {
    yyerror((uint64_t)&v86, a1, (char)"memory exhausted");
    v5 = 2;
    goto LABEL_12;
  }
  if ((_DWORD)v5 == 1)
    goto LABEL_12;
  if ((_DWORD)v5)
LABEL_142:
    abort();
  v6 = (char *)v88[1];
  v88[1] = (char *)v88[1] + 72;
  *(_QWORD *)&v89 = v89 - 1;
  *((_DWORD *)v6 + 1) = 0;
  *v6 = 1;
  *((_QWORD *)v6 + 2) = 0;
  v6[1] = 1;
  *((_QWORD *)v6 + 1) = *(_QWORD *)v90[1];
  v7 = *(_OWORD *)&v85[8];
  *((_QWORD *)v6 + 5) = *(_QWORD *)&v85[24];
  *(_OWORD *)(v6 + 24) = v7;
  *((_OWORD *)v6 + 3) = v86;
  *(_QWORD *)v90[1] = v6;
  if ((unint64_t)v89 <= 1)
    yyexpandGLRStack((uint64_t)v79);
  v8 = *(_DWORD *)(*(_QWORD *)v90[1] + 4);
  if (v8 == 161)
  {
LABEL_10:
    v5 = 0;
    goto LABEL_12;
  }
  v14 = 0;
  while (1)
  {
    v15 = yypact[v8];
    v16 = v8;
    if (v15 == -400)
    {
      if (yydefact[v8])
      {
        v17 = yyglrReduce(v79, 0, yydefact[v8], 1);
        v5 = 0;
        switch(v17)
        {
          case 0:
            goto LABEL_122;
          case 1:
            goto LABEL_12;
          case 2:
            goto LABEL_140;
          case 3:
            goto LABEL_73;
          default:
            goto LABEL_142;
        }
      }
      v80 = v86;
      v22 = v79[0];
      if (LODWORD(v79[0]))
        goto LABEL_74;
LABEL_32:
      yyerror((uint64_t)&v86, a1, (char)"syntax error");
      ++*(_DWORD *)v85;
      goto LABEL_73;
    }
    v18 = *(_DWORD *)&v85[4];
    if (*(_DWORD *)&v85[4] == -2)
    {
      v19 = yylex((uint64_t)&v85[8], (uint64_t)&v86, *(_QWORD *)(a1 + 24));
      v18 = v19;
      *(_DWORD *)&v85[4] = v19;
      if (v19 < 1)
        goto LABEL_33;
      v20 = v19;
      if (v19 < 0x1B0)
        goto LABEL_29;
    }
    else
    {
      v20 = *(_DWORD *)&v85[4];
      if (*(int *)&v85[4] < 1)
      {
LABEL_33:
        v21 = 0;
        goto LABEL_34;
      }
      if (*(_DWORD *)&v85[4] <= 0x1AFu)
      {
LABEL_29:
        v21 = yytranslate[v20];
        goto LABEL_30;
      }
    }
    v21 = 2;
LABEL_30:
    v18 = 1;
LABEL_34:
    v23 = (v21 + v15);
    if (v23 >> 1 <= 0x81A && yycheck[v23] == v21)
    {
      v24 = &yyconfl[yyconflp[v23]];
      v25 = yytable[v23];
      v26 = v24;
    }
    else
    {
      v25 = -yydefact[v16];
      v26 = yyconfl;
    }
    if (*v26)
      break;
    if (v25 < 1)
    {
      if (v25)
      {
        v69 = yyglrReduce(v79, 0, -v25, 1);
        v5 = 0;
        switch(v69)
        {
          case 0:
            goto LABEL_122;
          case 1:
            goto LABEL_12;
          case 2:
            goto LABEL_140;
          case 3:
            goto LABEL_73;
          default:
            goto LABEL_142;
        }
      }
      v80 = v86;
      if (LODWORD(v79[0]))
        goto LABEL_73;
      goto LABEL_32;
    }
    if (v18)
      *(_DWORD *)&v85[4] = -2;
    v67 = (char *)v88[1];
    v88[1] = (char *)v88[1] + 72;
    *(_QWORD *)&v89 = v89 - 1;
    *v67 = 1;
    *((_DWORD *)v67 + 1) = v25;
    *((_QWORD *)v67 + 2) = v14 + 1;
    v67[1] = 1;
    *((_QWORD *)v67 + 1) = *(_QWORD *)v90[1];
    v68 = *(_OWORD *)&v85[8];
    *((_QWORD *)v67 + 5) = *(_QWORD *)&v85[24];
    *(_OWORD *)(v67 + 24) = v68;
    *((_OWORD *)v67 + 3) = v86;
    *(_QWORD *)v90[1] = v67;
    if ((unint64_t)v89 <= 1)
      yyexpandGLRStack((uint64_t)v79);
    if (SLODWORD(v79[0]) >= 1)
      --LODWORD(v79[0]);
    ++v14;
LABEL_122:
    v5 = 0;
LABEL_123:
    v8 = *(_DWORD *)(*(_QWORD *)v90[1] + 4);
    if (v8 == 161)
      goto LABEL_12;
  }
  v27 = v92;
LABEL_40:
  if (!v27)
    goto LABEL_129;
  v28 = v14;
  v29 = 0;
  do
    *((_BYTE *)v91 + v29++) = *(_DWORD *)&v85[4] != -2;
  while (v29 < v92);
  if (!v92)
  {
LABEL_129:
    if (v90[0])
    {
      *(_QWORD *)v90[1] = v90[0];
      v92 = 1;
      v90[0] = 0;
      v75 = yyresolveStack((uint64_t)v79, a1);
      v5 = 0;
      switch(v75)
      {
        case 0:
          v80 = v86;
          v22 = v79[0];
          if (!LODWORD(v79[0]))
            goto LABEL_32;
          goto LABEL_74;
        case 1:
          goto LABEL_12;
        case 2:
          goto LABEL_140;
        case 3:
          goto LABEL_73;
        default:
          goto LABEL_142;
      }
    }
    yyFail((uint64_t)v79, (uint64_t)&v86, a1, (uint64_t)"syntax error");
  }
  v30 = 0;
  while (1)
  {
    v31 = yyprocessOneStack((uint64_t)v79, v30, a1);
    if (v31)
      break;
    ++v30;
    v32 = v92;
    if (v30 >= v92)
    {
      if (!v92)
        goto LABEL_129;
      v33 = 0;
      v34 = 0;
      do
      {
        v35 = v34;
        v36 = *((_QWORD *)v90[1] + v33);
        if (v36)
        {
          *((_QWORD *)v90[1] + v34) = v36;
          *((_BYTE *)v91 + v34) = *((_BYTE *)v91 + v33);
          v35 = v34 + 1;
          v32 = v92;
        }
        else
        {
          v92 = --v32;
        }
        ++v33;
        v34 = v35;
      }
      while (v35 < v32);
      if (!v32)
        goto LABEL_129;
      if (*(int *)&v85[4] < 1)
      {
        v37 = 0;
      }
      else if (*(_DWORD *)&v85[4] > 0x1AFu)
      {
        v37 = 2;
      }
      else
      {
        v37 = yytranslate[*(unsigned int *)&v85[4]];
      }
      *(_DWORD *)&v85[4] = -2;
      v38 = v28 + 1;
      v39 = 0;
      do
      {
        v40 = *(int *)(*((_QWORD *)v90[1] + v39) + 4);
        v41 = v37 + yypact[v40];
        if (v41 >> 1 <= 0x81A && v37 == yycheck[v41])
          v42 = yytable[v37 + yypact[v40]];
        else
          v42 = -yydefact[v40];
        v43 = (char *)v88[1];
        v88[1] = (char *)v88[1] + 72;
        *(_QWORD *)&v89 = v89 - 1;
        *v43 = 1;
        *((_DWORD *)v43 + 1) = v42;
        *((_QWORD *)v43 + 2) = v38;
        v43[1] = 1;
        *((_QWORD *)v43 + 1) = *((_QWORD *)v90[1] + v39);
        v44 = *(_OWORD *)&v85[8];
        *((_QWORD *)v43 + 5) = *(_QWORD *)&v85[24];
        *(_OWORD *)(v43 + 24) = v44;
        *((_OWORD *)v43 + 3) = v86;
        *((_QWORD *)v90[1] + v39) = v43;
        if ((unint64_t)v89 <= 1)
          yyexpandGLRStack((uint64_t)v79);
        ++v39;
      }
      while (v39 < v92);
      v27 = v92;
      v14 = v38;
      if (v92 == 1)
      {
        v45 = yyresolveStack((uint64_t)v79, a1);
        v5 = 0;
        switch(v45)
        {
          case 0:
            yycompressStack((uint64_t)v79);
            goto LABEL_113;
          case 1:
            goto LABEL_12;
          case 2:
            goto LABEL_140;
          case 3:
            goto LABEL_73;
          default:
            goto LABEL_142;
        }
      }
      goto LABEL_40;
    }
  }
  if (v31 == 1)
    goto LABEL_10;
  if (v31 != 2)
  {
    if (v31 != 3)
      goto LABEL_142;
LABEL_73:
    v22 = v79[0];
LABEL_74:
    if (v22 == 3)
    {
      v46 = *(_DWORD *)&v85[4];
      while (1)
      {
        if (v46 != -2)
        {
          if (!v46)
            goto LABEL_141;
          *(_QWORD *)(*(_QWORD *)v90[1] + 56) = *((_QWORD *)&v86 + 1);
        }
        v47 = yylex((uint64_t)&v85[8], (uint64_t)&v86, *(_QWORD *)(a1 + 24));
        v46 = v47;
        *(_DWORD *)&v85[4] = v47;
        if (v47 < 1)
          v48 = 0;
        else
          v48 = v47 > 0x1AF ? 2 : yytranslate[v47];
        v49 = *(_QWORD *)v90[1];
        v50 = *(int *)(*(_QWORD *)v90[1] + 4);
        v51 = yypact[v50];
        if (v51 == -400)
          break;
        v52 = (v48 + v51);
        if (v52 >> 1 <= 0x81A && v48 == yycheck[v52])
        {
          if (yytable[v52])
            break;
        }
        else if (yydefact[v50])
        {
          break;
        }
      }
    }
    else
    {
      v53 = v92;
      if (!v92)
        goto LABEL_141;
      v54 = 0;
      while (1)
      {
        v55 = v54 + 1;
        if (*((_QWORD *)v90[1] + v54))
          break;
        ++v54;
        if (v92 == v55)
          goto LABEL_141;
      }
      v56 = v54 + 1;
      if (v55 < v92)
      {
        do
        {
          if (*((_QWORD *)v90[1] + v56))
            v90[0] = *((void **)v90[1] + v56);
          *((_QWORD *)v90[1] + v56++) = 0;
        }
        while (v53 != v56);
      }
      v57 = v53;
      v58 = 0;
      v59 = 0;
      do
      {
        v60 = *((_QWORD *)v90[1] + v58);
        if (v60)
        {
          *((_QWORD *)v90[1] + v59) = v60;
          *((_BYTE *)v91 + v59++) = *((_BYTE *)v91 + v58);
          v57 = v92;
        }
        else
        {
          v92 = --v57;
        }
        ++v58;
      }
      while (v59 < v57);
      yycompressStack((uint64_t)v79);
      LODWORD(v79[0]) = 3;
      v61 = *(_QWORD *)v90[1];
      if (*(_QWORD *)v90[1])
      {
        v62 = v89 - 1;
        v63 = v90[1];
        while (1)
        {
          v64 = yypact[*(int *)(v61 + 4)];
          if (v64 >= -1)
          {
            v65 = v64 + 1;
            if (yycheck[v65] == 1)
            {
              v66 = yytable[v65];
              if (v66 >= 1)
                break;
            }
          }
          v80 = *(_OWORD *)(v61 + 48);
          yydestroyGLRState(v61);
          *v63 = *(_QWORD *)(v61 + 8);
          v88[1] = (char *)v88[1] - 72;
          *(_QWORD *)&v89 = v62 + 2;
          v61 = *(_QWORD *)v90[1];
          ++v62;
          v63 = v90[1];
          if (!*(_QWORD *)v90[1])
            goto LABEL_111;
        }
        *(_OWORD *)((char *)v84 + 8) = v86;
        *(_QWORD *)&v70 = v80;
        v71 = *((_QWORD *)&v86 + 1);
        v72 = *(_QWORD *)(v61 + 16);
        v73 = (char *)v88[1];
        v88[1] = (char *)v88[1] + 72;
        *(_QWORD *)&v89 = v62;
        *v73 = 1;
        *((_DWORD *)v73 + 1) = (unsigned __int16)v66;
        *((_QWORD *)v73 + 2) = v72;
        v73[1] = 1;
        *((_QWORD *)v73 + 1) = *(_QWORD *)v90[1];
        v74 = *(_OWORD *)&v85[8];
        *((_QWORD *)v73 + 5) = *(_QWORD *)&v85[24];
        *((_QWORD *)&v70 + 1) = v71;
        *(_OWORD *)(v73 + 24) = v74;
        *((_OWORD *)v73 + 3) = v70;
        *(_QWORD *)v90[1] = v73;
        if ((unint64_t)v89 <= 1)
          yyexpandGLRStack((uint64_t)v79);
      }
LABEL_111:
      v49 = *(_QWORD *)v90[1];
      if (!*(_QWORD *)v90[1])
LABEL_141:
        longjmp((int *)v87, 1);
    }
    v38 = *(_QWORD *)(v49 + 16);
LABEL_113:
    v5 = 0;
    v14 = v38;
    goto LABEL_123;
  }
LABEL_140:
  v5 = 1;
LABEL_12:
  v9 = v5;
  v10 = v88[0];
  if (v88[0])
  {
    if (v90[1] && v92)
    {
      v11 = (uint64_t *)v90[1];
      v12 = v92;
      while (1)
      {
        v13 = *v11;
        if (*v11)
          break;
        ++v11;
        if (!--v12)
          goto LABEL_138;
      }
      v76 = v89 + 1;
      do
      {
        v77 = v76;
        v80 = *(_OWORD *)(v13 + 48);
        yydestroyGLRState(v13);
        *v11 = *(_QWORD *)(v13 + 8);
        v88[1] = (char *)v88[1] - 72;
        *(_QWORD *)&v89 = v77;
        v13 = *v11;
        v76 = v77 + 1;
      }
      while (*v11);
      v10 = v88[0];
    }
LABEL_138:
    free(v10);
    free(v90[1]);
    free(v91);
  }
  return v9;
}

