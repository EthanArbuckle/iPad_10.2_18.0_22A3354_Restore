uint64_t FigVideoCompositionProcessorSetSourceBufferQueue(uint64_t a1, int a2, _OWORD *a3, opaqueCMBufferQueue *a4, uint64_t a5)
{
  uint64_t v10;
  const void *v11;
  CFTypeRef v12;
  const __CFAllocator *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  _BYTE time[32];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  const void *v26;

  v26 = 0;
  if (!FigVCPIsValid())
  {
    v10 = FigSignalErrorAt();
    goto LABEL_15;
  }
  *(_OWORD *)time = *MEMORY[0x1E0CA2E18];
  *(_QWORD *)&time[16] = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  v10 = CMBufferQueueInstallTrigger(a4, (CMBufferQueueTriggerCallback)videoprocessor_triggerProcessingByBufferQueue, (void *)a1, 7, (CMTime *)time, (CMBufferQueueTriggerToken *)(a1 + 56));
  if ((_DWORD)v10)
  {
LABEL_15:
    v17 = v10;
    goto LABEL_11;
  }
  v11 = *(const void **)(a1 + 48);
  *(_QWORD *)(a1 + 48) = a4;
  if (a4)
    CFRetain(a4);
  if (v11)
    CFRelease(v11);
  v12 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 40));
  v13 = CFGetAllocator(v12);
  v24 = *(_OWORD *)a5;
  v25 = *(_QWORD *)(a5 + 16);
  v14 = a3[3];
  v20 = a3[2];
  v21 = v14;
  v15 = a3[5];
  v22 = a3[4];
  v23 = v15;
  v16 = a3[1];
  *(_OWORD *)time = *a3;
  *(_OWORD *)&time[16] = v16;
  v17 = FigVCPSourceArrayCopyAndAddNewBufferQueue(v13, (uint64_t)v12, a2, a4, &v24, time, (uint64_t)videoprocessor_AvailableTimeRangeChanged, a1, &v26);
  if (!(_DWORD)v17)
    videoprocessor_releaseAssignAndRetainAtomically(a1, (const void **)(a1 + 40), v26);
  if (v12)
    CFRelease(v12);
LABEL_11:
  if (v26)
    CFRelease(v26);
  return v17;
}

uint64_t FigVideoCompositionProcessorSetCompositionInstructionCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  CFTypeRef cf;

  cf = 0;
  if (!FigVCPIsValid())
    return FigSignalErrorAt();
  v6 = FigVCPInstructionSourceCreate(*MEMORY[0x1E0C9AE00], a2, a3, a1, &cf);
  if (!(_DWORD)v6)
    videoprocessor_releaseAssignAndRetainAtomically(a1, (const void **)(a1 + 88), cf);
  if (cf)
    CFRelease(cf);
  return v6;
}

uint64_t FigVideoCompositionProcessorSetHDRDisplayMetadataPolicy(uint64_t a1, const void *a2)
{
  if (!FigVCPIsValid())
    return FigSignalErrorAt();
  FigVCPOutputSetHDRDisplayMetadataPolicy(*(_QWORD *)(a1 + 120), a2);
  FigVCPCompositorHostSetHDRDisplayMetadataPolicy(*(_QWORD *)(a1 + 104));
  videoprocessor_triggerProcessing(a1);
  return 0;
}

uint64_t FigVideoCompositionProcessorResetCompositionInstruction(uint64_t a1, int a2, int a3)
{
  CFTypeRef v6;
  uint64_t FrameTimeToCurrentTimebaseTime;
  uint64_t v8;

  if (FigVCPIsValid())
  {
    v6 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 88));
    if (v6)
      FigVCPInstructionSourceInvalidateCache();
    if (a3)
      videoprocessor_flushOutput(a1);
    if (a2
      && (FrameTimeToCurrentTimebaseTime = FigVCPTimingResetNextFrameTimeToCurrentTimebaseTime(*(_QWORD *)(a1 + 96)),
          (_DWORD)FrameTimeToCurrentTimebaseTime))
    {
      v8 = FrameTimeToCurrentTimebaseTime;
      if (!v6)
        return v8;
    }
    else
    {
      *(_BYTE *)(a1 + 160) = 1;
      videoprocessor_triggerProcessing(a1);
      v8 = 0;
      if (!v6)
        return v8;
    }
    CFRelease(v6);
    return v8;
  }
  return FigSignalErrorAt();
}

void videoprocessor_flushOutput(uint64_t a1)
{
  CFTypeRef v2;

  FigVCPCompositorHostCancelPendingFrames(*(_QWORD **)(a1 + 104));
  v2 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 120));
  FigVCPOutputFlush((uint64_t)v2);
  if (v2)
    CFRelease(v2);
}

uint64_t FigVideoCompositionProcessorCopyProperty(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  const void *PixelBufferAttributes;
  uint64_t v9;
  uint64_t v11;
  const void **v12;
  CFTypeRef v13;
  CFTypeRef v14;
  float valuePtr;
  CFTypeRef cf;

  cf = 0;
  if (!FigVCPIsValid() || !a4)
  {
LABEL_30:
    v11 = FigSignalErrorAt();
LABEL_31:
    v9 = v11;
    goto LABEL_32;
  }
  if (CFEqual(a2, CFSTR("VideoCompositionProcessor_SourcePixelBufferAttributes")))
  {
    PixelBufferAttributes = (const void *)FigVCPPreprocessParametersGetPixelBufferAttributes(*(_QWORD *)(a1 + 24));
    if (!PixelBufferAttributes)
      goto LABEL_15;
    goto LABEL_14;
  }
  if (CFEqual(a2, CFSTR("VideoCompositionProcessor_CompositionYCbCrMatrix")))
  {
    PixelBufferAttributes = (const void *)FigVCPPreprocessParametersGetYCbCrMatrix(*(_QWORD *)(a1 + 24));
    if (!PixelBufferAttributes)
      goto LABEL_15;
    goto LABEL_14;
  }
  if (CFEqual(a2, CFSTR("VideoCompositionProcessor_CompositionColorPrimaries")))
  {
    PixelBufferAttributes = (const void *)FigVCPPreprocessParametersGetColorPrimaries(*(_QWORD *)(a1 + 24));
    if (!PixelBufferAttributes)
      goto LABEL_15;
    goto LABEL_14;
  }
  if (CFEqual(a2, CFSTR("VideoCompositionProcessor_CompositionTransferFunction")))
  {
    PixelBufferAttributes = (const void *)FigVCPPreprocessParametersGetTransferFunction(*(_QWORD *)(a1 + 24));
    if (!PixelBufferAttributes)
    {
LABEL_15:
      cf = PixelBufferAttributes;
LABEL_16:
      v9 = 0;
      *a4 = cf;
      return v9;
    }
LABEL_14:
    PixelBufferAttributes = CFRetain(PixelBufferAttributes);
    goto LABEL_15;
  }
  if (CFEqual(a2, CFSTR("VideoCompositionProcessor_DestinationPixelBufferDesiredAttributes"))
    || CFEqual(a2, CFSTR("VideoCompositionProcessor_DestinationPixelTransferProperties"))
    || CFEqual(a2, CFSTR("VideoCompositionProcessor_DestinationPixelBufferDesiredYCbCrMatrix"))
    || CFEqual(a2, CFSTR("VideoCompositionProcessor_DestinationPixelBufferDesiredColorPrimaries"))
    || CFEqual(a2, CFSTR("VideoCompositionProcessor_PixelBufferPoolSharingID"))
    || CFEqual(a2, CFSTR("VideoCompositionProcessor_DestinationPixelBufferDesiredTransferFunction")))
  {
    v11 = FigVCPOutputConformerCopyProperty(*(_QWORD *)(a1 + 112), a2, a3, &cf);
    if (!(_DWORD)v11)
      goto LABEL_16;
    goto LABEL_31;
  }
  if (CFEqual(a2, CFSTR("VideoCompositionProcessorProperty_Timebase")))
  {
    if (FigVCPTimingUsesTimebase(*(_QWORD *)(a1 + 96)))
    {
      PixelBufferAttributes = FigVCPTimingCopyTimebase(*(_QWORD *)(a1 + 96));
      goto LABEL_15;
    }
    goto LABEL_30;
  }
  if (CFEqual(a2, CFSTR("VideoCompositionProcessor_RenderScale")))
  {
    if (!FigVCPCompositorHostSupportsRenderScale(*(_QWORD *)(a1 + 104)))
    {
      valuePtr = FigVCPPreprocessParametersGetRenderScale(*(_QWORD *)(a1 + 24));
      PixelBufferAttributes = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &valuePtr);
      goto LABEL_15;
    }
    v11 = FigVCPCompositorHostCopyProperty(*(_QWORD *)(a1 + 104), CFSTR("VideoCompositionProcessor_RenderScale"), a3, (uint64_t)&cf);
    if (!(_DWORD)v11)
      goto LABEL_16;
    goto LABEL_31;
  }
  if (CFEqual(a2, CFSTR("VideoCompositionProcessor_ThrottleForBackground")))
  {
    v12 = (const void **)MEMORY[0x1E0C9AE40];
    if (*(_BYTE *)(a1 + 20))
      v12 = (const void **)MEMORY[0x1E0C9AE50];
    PixelBufferAttributes = *v12;
    goto LABEL_14;
  }
  if (CFEqual(a2, CFSTR("VideoCompositionProcessor_PerformanceDictionary")))
  {
    v13 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 32));
    v14 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 144));
    v9 = FigVCPTallyCopyPerformanceDictionary(a1 + 208, (uint64_t)v13, *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 112), (uint64_t)v14, (__CFDictionary **)&cf);
    if (v14)
      CFRelease(v14);
    if (v13)
      CFRelease(v13);
    if (!(_DWORD)v9)
      goto LABEL_16;
  }
  else
  {
    v9 = 4294954512;
  }
LABEL_32:
  if (cf)
    CFRelease(cf);
  return v9;
}

uint64_t FigVideoCompositionProcessorSetProperty(uint64_t a1, const void *a2, void *a3)
{
  CFTypeID v7;
  uint64_t v8;
  __int128 v9;
  CFTypeID v10;
  uint64_t v11;
  CFTypeID v12;
  CMTimeRange v13;
  CMTimeRange valuePtr;

  if (!FigVCPIsValid())
    return FigSignalErrorAt();
  MEMORY[0x19402F294](&videoprocessor_getReadOnlyPropertyKeys_sReadOnlyPropertyKeysOnce, videoprocessor_initReadOnlyPropertyKeys);
  if (CFSetContainsValue((CFSetRef)videoprocessor_readOnlyPropertyKeys, a2))
    return FigSignalErrorAt();
  MEMORY[0x19402F294](&videoprocessor_getStaticPropertyKeys_sStaticPropertyKeysOnce, videoprocessor_initStaticPropertyKeys);
  if (CFSetContainsValue((CFSetRef)videoprocessor_staticPropertyKeys, a2)
    && (*(_BYTE *)(a1 + 160) || FigVCPCompositorHostGetPendingFramesCount()))
  {
    FigCFStringGetCStringPtrAndBufferToFree();
    return FigSignalErrorAt();
  }
  if (CFEqual(a2, CFSTR("VideoCompositionProcessorProperty_Timebase")))
  {
    if (FigVCPTimingUsesTimebase(*(_QWORD *)(a1 + 96)))
    {
      if (a3)
      {
        v7 = CFGetTypeID(a3);
        if (v7 == CMTimebaseGetTypeID())
        {
          MEMORY[0x19402EEEC](*(_QWORD *)(a1 + 168));
          v8 = FigVCPTimingSetTimebase(*(_QWORD *)(a1 + 96), (OpaqueCMTimebase *)a3);
          MEMORY[0x19402EF04](*(_QWORD *)(a1 + 168));
          return v8;
        }
      }
    }
    return FigSignalErrorAt();
  }
  if (CFEqual(a2, CFSTR("VideoCompositionProcessorProperty_LoopTimeRange")))
  {
    v9 = *(_OWORD *)(MEMORY[0x1E0CA2E40] + 16);
    *(_OWORD *)&valuePtr.start.value = *MEMORY[0x1E0CA2E40];
    *(_OWORD *)&valuePtr.start.epoch = v9;
    *(_OWORD *)&valuePtr.duration.timescale = *(_OWORD *)(MEMORY[0x1E0CA2E40] + 32);
    if (!FigVCPTimingUsesTimebase(*(_QWORD *)(a1 + 96)))
      return FigSignalErrorAt();
    if (a3)
    {
      v10 = CFGetTypeID(a3);
      if (v10 != CFDictionaryGetTypeID())
        return FigSignalErrorAt();
      CMTimeRangeMakeFromDictionary(&valuePtr, (CFDictionaryRef)a3);
    }
    v11 = *(_QWORD *)(a1 + 96);
    v13 = valuePtr;
    return FigVCPTimingSetLoopTimeRange(v11, (uint64_t)&v13);
  }
  else if (CFEqual(a2, CFSTR("VideoCompositionProcessor_RenderScale")))
  {
    if (!a3)
      return FigSignalErrorAt();
    v12 = CFGetTypeID(a3);
    if (v12 != CFNumberGetTypeID())
      return FigSignalErrorAt();
    LODWORD(valuePtr.start.value) = 1065353216;
    CFNumberGetValue((CFNumberRef)a3, kCFNumberFloatType, &valuePtr);
    if (*(float *)&valuePtr.start.value <= 0.0
      || !FigVCPTimingUsesTimebase(*(_QWORD *)(a1 + 96)) && *(float *)&valuePtr.start.value != 1.0)
    {
      return FigSignalErrorAt();
    }
    if (FigVCPCompositorHostSupportsRenderScale(*(_QWORD *)(a1 + 104)))
      return FigVCPCompositorHostSetProperty(*(_QWORD *)(a1 + 104), CFSTR("VideoCompositionProcessor_RenderScale"), (uint64_t)a3);
    else
      return FigVCPPreprocessParametersSetProperty(*(_QWORD *)(a1 + 24), CFSTR("VideoCompositionProcessor_RenderScale"), (uint64_t)a3);
  }
  else if (CFEqual(a2, CFSTR("VideoCompositionProcessor_ClientPID")))
  {
    return videoprocessor_setClientPIDProperty(a1, (uint64_t)a3);
  }
  else if (CFEqual(a2, CFSTR("VideoCompositionProcessor_ThrottleForBackground")))
  {
    return videoprocessor_setThrottleForBackgroundProperty(a1, a3);
  }
  else if (CFEqual(a2, CFSTR("VideoCompositionProcessorProperty_FigImageQueueArray")))
  {
    return videoprocessor_updateOutputImageQueueArray((CFTypeRef *)a1, a3);
  }
  else if (CFEqual(a2, CFSTR("VideoCompositionProcessor_HDRDisplayMetadataPolicy")))
  {
    if (FigIsDeviceCapableOfGeneratingStatisticsForHDR())
      return FigVideoCompositionProcessorSetHDRDisplayMetadataPolicy(a1, a3);
    if (overrideHDRMetadataGenerationByDefaultsWrite_onceToken != -1)
      dispatch_once(&overrideHDRMetadataGenerationByDefaultsWrite_onceToken, &__block_literal_global_62);
    if (overrideHDRMetadataGenerationByDefaultsWrite_sOverrideHDRMetadataGeneration == 1)
      return FigVideoCompositionProcessorSetHDRDisplayMetadataPolicy(a1, a3);
    else
      return 0;
  }
  else
  {
    return videoprocessor_propagatePropertyToSubcomponents((uint64_t *)a1, a2, (uint64_t)a3);
  }
}

uint64_t videoprocessor_setClientPIDProperty(uint64_t a1, uint64_t a2)
{
  uint64_t FigBaseObject;
  uint64_t (*v5)(uint64_t, const __CFString *, uint64_t);
  uint64_t v6;

  FigBaseObject = FigActivitySchedulerGetFigBaseObject(*(_QWORD *)(a1 + 128));
  v5 = *(uint64_t (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
  if (v5)
    v6 = v5(FigBaseObject, CFSTR("ClientPID"), a2);
  else
    v6 = 4294954514;
  FigVCPCompositorHostSetProperty(*(_QWORD *)(a1 + 104), CFSTR("VideoCompositionProcessor_ClientPID"), a2);
  return v6;
}

uint64_t videoprocessor_setThrottleForBackgroundProperty(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4;
  uint64_t Value;

  if (!cf)
    return FigSignalErrorAt();
  v4 = CFGetTypeID(cf);
  if (v4 != CFBooleanGetTypeID())
    return FigSignalErrorAt();
  Value = CFBooleanGetValue((CFBooleanRef)cf);
  if (*(unsigned __int8 *)(a1 + 20) != (_DWORD)Value)
  {
    *(_BYTE *)(a1 + 20) = Value;
    videoprocessor_updateCoreAnimationThrottling(a1, Value);
    if (*(_DWORD *)(a1 + 136) == 3)
      FigVCPCompositorHostSetProperty(*(_QWORD *)(a1 + 104), CFSTR("VideoCompositionProcessor_ThrottleForBackground"), (uint64_t)cf);
  }
  return 0;
}

uint64_t videoprocessor_updateOutputImageQueueArray(CFTypeRef *a1, const void *a2)
{
  const void **v4;
  CFTypeRef v5;
  uint64_t OutputDurationWaterLevels;
  CFAllocatorRef v7;
  uint64_t v8;
  const void *HDRDisplayMetadataPolicy;
  uint64_t v10;
  uint64_t v12;
  CMTime v13;
  CMTime v14;
  CMTime v15;
  CMTime v16;
  const void *v17;

  v17 = 0;
  v4 = a1 + 15;
  v5 = videoprocessor_loadAndRetainAtomically((uint64_t)a1, a1 + 15);
  v16 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E18];
  v15 = v16;
  OutputDurationWaterLevels = FigVCPOutputGetOutputDurationWaterLevels((uint64_t)v5, (uint64_t)&v16, (uint64_t)&v15);
  if (!(_DWORD)OutputDurationWaterLevels)
  {
    v7 = CFGetAllocator(a1);
    v14 = v16;
    v13 = v15;
    OutputDurationWaterLevels = FigVCPOutputCreate((uint64_t)v7, a2, &v14, &v13, (uint64_t)a1, &v17);
    if (!(_DWORD)OutputDurationWaterLevels)
    {
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterRemoveWeakListener();
      CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterAddWeakListener();
      if (!v5
        || (v8 = (uint64_t)v17,
            HDRDisplayMetadataPolicy = (const void *)FigVCPOutputGetHDRDisplayMetadataPolicy((uint64_t)v5),
            v10 = FigVCPOutputSetHDRDisplayMetadataPolicy(v8, HDRDisplayMetadataPolicy),
            !(_DWORD)v10))
      {
        FigVCPOutputInvalidate((uint64_t)v5);
        videoprocessor_releaseAssignAndRetainAtomically((uint64_t)a1, v4, v17);
      }
      v12 = v10;
      goto LABEL_6;
    }
  }
  v12 = OutputDurationWaterLevels;
  if (v5)
LABEL_6:
    CFRelease(v5);
  if (v17)
    CFRelease(v17);
  return v12;
}

uint64_t videoprocessor_propagatePropertyToSubcomponents(uint64_t *a1, const void *a2, uint64_t a3)
{
  uint64_t result;
  int v7;
  BOOL v8;
  int v9;
  BOOL v11;

  result = FigVCPPreprocessParametersSetProperty(a1[3], a2, a3);
  v7 = result;
  if ((_DWORD)result)
    v8 = (_DWORD)result == -12784;
  else
    v8 = 1;
  if (v8)
  {
    result = FigVCPCompositorHostSetProperty(a1[13], a2, a3);
    v9 = result;
    if (!(_DWORD)result || (_DWORD)result == -12784)
    {
      result = FigVCPOutputConformerSetProperty(a1[14], a2, a3);
      if (!(_DWORD)result || (_DWORD)result == -12784)
      {
        if ((_DWORD)result)
          v11 = v9 == 0;
        else
          v11 = 1;
        if (v11 || v7 == 0)
          return 0;
        else
          return 4294954512;
      }
    }
  }
  return result;
}

uint64_t FigVideoCompositionProcessorGetVideoCompositor(uint64_t a1)
{
  if (FigVCPIsValid())
    return FigVCPCompositorHostGetCompositor(*(_QWORD *)(a1 + 104));
  FigSignalErrorAt();
  return 0;
}

uint64_t FigVideoCompositionProcessorStartRenderingFramesForTimeRange(uint64_t a1, CMTime *a2, uint64_t a3)
{
  CFTypeRef v6;
  CFTypeRef v7;
  uint64_t Copy;
  CFIndex v9;
  const void *SourceAtIndex;
  uint64_t v11;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  CMTime v16;
  CFTypeRef cf;

  cf = 0;
  if (!FigVCPIsValid() || FigVCPTimingUsesTimebase(*(_QWORD *)(a1 + 96)))
  {
    v13 = FigSignalErrorAt();
    v7 = 0;
    v6 = 0;
  }
  else
  {
    v6 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 88));
    FigVCPInstructionSourceInvalidateCache();
    v7 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 32));
    Copy = FigVCPPreprocessParametersCreateCopy(*MEMORY[0x1E0C9AE00], *(_QWORD *)(a1 + 24), (uint64_t *)&cf);
    if (!(_DWORD)Copy)
    {
      if ((uint64_t)FigVCPSourceArrayGetCount((uint64_t)v7) >= 1)
      {
        v9 = 0;
        do
        {
          SourceAtIndex = FigVCPSourceArrayGetSourceAtIndex((uint64_t)v7, v9);
          FigVCPSourceStartOver((uint64_t)SourceAtIndex);
          FigVCPSourceSetPreprocessParameters((uint64_t)SourceAtIndex, cf);
          ++v9;
        }
        while (v9 < (uint64_t)FigVCPSourceArrayGetCount((uint64_t)v7));
      }
      v11 = *(_QWORD *)(a1 + 96);
      v16 = *a2;
      v14 = *(_OWORD *)a3;
      v15 = *(_QWORD *)(a3 + 16);
      FigVCPTimingStartOver(v11, &v16, &v14, 0, 1);
    }
    v13 = Copy;
  }
  if (cf)
    CFRelease(cf);
  if (v6)
    CFRelease(v6);
  if (v7)
    CFRelease(v7);
  return v13;
}

uint64_t FigVideoCompositionProcessorGo(uint64_t a1)
{
  if (!FigVCPIsValid())
    return FigSignalErrorAt();
  *(_BYTE *)(a1 + 160) = 1;
  FigMemoryBarrier();
  videoprocessor_triggerProcessing(a1);
  return 0;
}

void FigVideoCompositionProcessorRequestPreroll(uint64_t *a1, __int128 *a2, __int128 *a3, uint64_t a4, int a5)
{
  char *v9;
  CFTypeRef v10;
  __int128 v11;
  __int128 v12;
  int v13;
  _OWORD v14[3];

  v9 = (char *)malloc_type_malloc(0x70uLL, 0x1020040FDFAB857uLL);
  if (a1)
    v10 = CFRetain(a1);
  else
    v10 = 0;
  *(_QWORD *)v9 = v10;
  v11 = *a2;
  *((_QWORD *)v9 + 3) = *((_QWORD *)a2 + 2);
  *(_OWORD *)(v9 + 8) = v11;
  v12 = *a3;
  *((_QWORD *)v9 + 6) = *((_QWORD *)a3 + 2);
  *((_OWORD *)v9 + 2) = v12;
  if (a5 < 1)
    v13 = -1;
  else
    v13 = 1;
  if (!a5)
    v13 = 0;
  *((_DWORD *)v9 + 14) = v13;
  FigVCPTimingGetLoopTimeRange(a1[12], v14);
}

uint64_t sub_192DD1FB4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, __int128 a10, __int128 a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  int v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  *(_OWORD *)(v21 + 60) = v23;
  *(_OWORD *)(v21 + 76) = v24;
  *(_OWORD *)(v21 + 92) = v25;
  *(_DWORD *)(v21 + 108) = v19;
  dispatch_async_f(*(dispatch_queue_t *)(v20 + 192), (void *)v21, (dispatch_function_t)videoprocessor_requestPreroll);
  return 0;
}

void videoprocessor_requestPreroll(CFTypeRef *a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7[3];
  __int128 v8;
  CFTypeRef v9;
  CMTime v10;

  v2 = *((_QWORD *)*a1 + 13);
  v3 = *((_DWORD *)a1 + 14);
  v4 = *((unsigned int *)a1 + 27);
  v10 = *(CMTime *)(a1 + 1);
  v5 = *((_OWORD *)a1 + 2);
  v9 = a1[6];
  v6 = *(_OWORD *)((char *)a1 + 76);
  v7[0] = *(_OWORD *)((char *)a1 + 60);
  v7[1] = v6;
  v7[2] = *(_OWORD *)((char *)a1 + 92);
  v8 = v5;
  FigVCPCompositorHostPrerollForRendering(v2, &v10, (uint64_t)&v8, v3, v7, v4);
  if (*a1)
    CFRelease(*a1);
  free(a1);
}

uint64_t FigVideoCompositionProcessorSetPlaybackTimeRange(uint64_t a1, CMTime *a2, uint64_t a3, int a4, int a5)
{
  uint64_t Copy;
  CFTypeRef v11;
  CFIndex v12;
  const void *SourceAtIndex;
  int v14;
  int v15;
  CFTypeRef v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v21;
  uint64_t v22;
  CMTime v23;
  CFTypeRef cf;

  cf = 0;
  if (!FigVCPIsValid() || !FigVCPTimingUsesTimebase(*(_QWORD *)(a1 + 96)))
  {
    Copy = FigSignalErrorAt();
    goto LABEL_25;
  }
  Copy = FigVCPPreprocessParametersCreateCopy(*MEMORY[0x1E0C9AE00], *(_QWORD *)(a1 + 24), (uint64_t *)&cf);
  if ((_DWORD)Copy)
  {
LABEL_25:
    v19 = Copy;
    v16 = 0;
    v11 = 0;
    goto LABEL_17;
  }
  v11 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 32));
  if ((uint64_t)FigVCPSourceArrayGetCount((uint64_t)v11) >= 1)
  {
    v12 = 0;
    do
    {
      SourceAtIndex = FigVCPSourceArrayGetSourceAtIndex((uint64_t)v11, v12);
      FigVCPSourceStartOver((uint64_t)SourceAtIndex);
      FigVCPSourceSetPreprocessParameters((uint64_t)SourceAtIndex, cf);
      ++v12;
    }
    while (v12 < (uint64_t)FigVCPSourceArrayGetCount((uint64_t)v11));
  }
  if ((a2->flags & 0x1D) == 1)
  {
    if (a5 < 1)
      v14 = -1;
    else
      v14 = 1;
    if (a5)
      v15 = v14;
    else
      v15 = 0;
    v16 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 120));
    v17 = FigVCPOutputSetDirection((uint64_t)v16, v15);
    if (!(_DWORD)v17)
    {
      v18 = *(_QWORD *)(a1 + 96);
      v23 = *a2;
      v21 = *(_OWORD *)a3;
      v22 = *(_QWORD *)(a3 + 16);
      FigVCPTimingStartOver(v18, &v23, &v21, a4, v15);
    }
    v19 = v17;
  }
  else
  {
    v16 = 0;
    v19 = 0;
    *(_BYTE *)(a1 + 160) = 0;
  }
LABEL_17:
  if (cf)
    CFRelease(cf);
  if (v11)
    CFRelease(v11);
  if (v16)
    CFRelease(v16);
  return v19;
}

uint64_t FigVideoCompositionProcessorWaitUntilCompletelyStopped(uint64_t a1)
{
  MEMORY[0x19402EEEC](*(_QWORD *)(a1 + 168));
  MEMORY[0x19402EF04](*(_QWORD *)(a1 + 168));
  return 0;
}

BOOL FigVideoCompositionProcessorIsAtEndOfOutputData(uint64_t a1)
{
  if (!FigVCPIsValid() || FigVCPTimingUsesTimebase(*(_QWORD *)(a1 + 96)))
  {
    FigSignalErrorAt();
    return 0;
  }
  if (FigVCPCompositorHostIsAcceptingRequest(*(_QWORD *)(a1 + 104)))
    return 0;
  return FigVCPCompositorHostGetPendingFramesCount() == 0;
}

dispatch_queue_t videoprocessor_Init(_QWORD *a1)
{
  dispatch_queue_t result;

  bzero(a1 + 2, 0x8C8uLL);
  a1[21] = FigSimpleMutexCreate();
  a1[22] = FigSimpleMutexCreate();
  a1[19] = FigSimpleMutexCreate();
  a1[23] = dispatch_queue_create("com.apple.coremedia.videocompositionprocessor.notification", 0);
  result = dispatch_queue_create("com.apple.coremedia.videocompositionprocessor.preroll", 0);
  a1[24] = result;
  return result;
}

void videoprocessor_Finalize(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;

  FigVideoCompositionProcessorInvalidate(a1);
  v2 = *(const void **)(a1 + 24);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 40);
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(a1 + 96);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(a1 + 88);
  if (v6)
    CFRelease(v6);
  v7 = *(const void **)(a1 + 104);
  if (v7)
    CFRelease(v7);
  v8 = *(const void **)(a1 + 112);
  if (v8)
    CFRelease(v8);
  v9 = *(const void **)(a1 + 120);
  if (v9)
    CFRelease(v9);
  v10 = *(const void **)(a1 + 128);
  if (v10)
    CFRelease(v10);
  videoprocessor_releaseAssignAndRetainAtomically(a1, (const void **)(a1 + 144), 0);
}

void sub_192DD241C()
{
  uint64_t v0;
  NSObject *v1;
  NSObject *v2;
  opaqueCMBufferQueue *v3;
  const void *v4;

  FigSimpleMutexDestroy();
  FigSimpleMutexDestroy();
  FigSimpleMutexDestroy();
  v1 = *(NSObject **)(v0 + 184);
  if (v1)
    dispatch_release(v1);
  v2 = *(NSObject **)(v0 + 192);
  if (v2)
    dispatch_release(v2);
  v3 = *(opaqueCMBufferQueue **)(v0 + 48);
  if (v3)
  {
    CMBufferQueueRemoveTrigger(v3, *(CMBufferQueueTriggerToken *)(v0 + 56));
    v4 = *(const void **)(v0 + 48);
    if (v4)
      CFRelease(v4);
  }
}

CFStringRef videoprocessor_CopyFormattingDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  int v3;
  const char *v4;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v3 = FigVCPIsValid();
  v4 = "";
  if (!v3)
    v4 = " (invalidated)";
  return CFStringCreateWithFormat(v2, 0, CFSTR("[FigVideoCompositionProcessor %p%s]"), a1, v4);
}

__CFString *videoprocessor_CopyDebugDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  CFTypeRef v4;
  CFTypeRef v5;
  CFTypeRef v6;
  CFIndex v7;
  const char *v8;
  CFAllocatorRef v9;
  const char *v10;
  const char *v11;
  _BOOL4 IsAcceptingRequest;
  const char *v13;
  const void *v14;
  CFTypeRef cf;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 120));
  v5 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 32));
  v6 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 144));
  v7 = CFGetRetainCount((CFTypeRef)a1);
  if (FigVCPIsValid())
    v8 = "";
  else
    v8 = " (invalidated)";
  v9 = CFGetAllocator((CFTypeRef)a1);
  if (FigVCPTimingUsesTimebase(*(_QWORD *)(a1 + 96)))
    v10 = "realtime";
  else
    v10 = "non-realtime";
  if (FigVCPTimingRepeatIdenticalFrames(*(_QWORD *)(a1 + 96)))
    v11 = "repeat-identical-frames";
  else
    v11 = "do-not-repeat-identical-frames";
  IsAcceptingRequest = FigVCPCompositorHostIsAcceptingRequest(*(_QWORD *)(a1 + 104));
  v13 = "is";
  if (!IsAcceptingRequest)
    v13 = "is not";
  CFStringAppendFormat(Mutable, 0, CFSTR("FigVideoCompositionProcessor %p retainCount: %d%s allocator: %p, %s, %s, compositor %s accepting input, "), a1, v7, v8, v9, v10, v11, v13);
  CFStringAppendFormat(Mutable, 0, CFSTR("sourceArray=%p, "), v5);
  CFStringAppendFormat(Mutable, 0, CFSTR("videoCompositor=%p, "), *(_QWORD *)(a1 + 104));
  CFStringAppendFormat(Mutable, 0, CFSTR("output=%p, "), v4);
  CFStringAppendFormat(Mutable, 0, CFSTR("instructionSource=%p, "), *(_QWORD *)(a1 + 88));
  CFStringAppendFormat(Mutable, 0, CFSTR("activityScheduler=%p, "), *(_QWORD *)(a1 + 128));
  CFStringAppendFormat(Mutable, 0, CFSTR("outputConformer=%p, "), *(_QWORD *)(a1 + 112));
  cf = 0;
  FigVCPTallyCopyPerformanceDictionary(a1 + 208, (uint64_t)v5, *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 112), (uint64_t)v6, (__CFDictionary **)&cf);
  if (cf)
  {
    v14 = (const void *)FigCFCopyCompactDescription();
    CFStringAppendFormat(Mutable, 0, CFSTR("performanceDictionary=%@"), v14);
    if (cf)
      CFRelease(cf);
    if (v6)
      goto LABEL_16;
  }
  else
  {
    v14 = 0;
    if (v6)
LABEL_16:
      CFRelease(v6);
  }
  if (v5)
    CFRelease(v5);
  if (v4)
    CFRelease(v4);
  if (v14)
    CFRelease(v14);
  return Mutable;
}

void videoprocessor_reportProcessingError(uint64_t a1)
{
  CFMutableDictionaryRef Mutable;

  *(_BYTE *)(a1 + 160) = 0;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetInt32();
  CMNotificationCenterGetDefaultLocalCenter();
  FigDispatchAsyncPostNotification();
  if (Mutable)
    CFRelease(Mutable);
}

uint64_t videoprocessor_setUpcomingImageInfo(uint64_t a1)
{
  CFTypeRef v2;
  uint64_t UpcomingImageInfo;
  uint64_t v4;
  __int128 v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;

  v12 = *MEMORY[0x1E0CA2E18];
  v13 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  v10 = v12;
  v11 = v13;
  v2 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 120));
  UpcomingImageInfo = FigVCPCompositorHostGetUpcomingImageInfo(*(_QWORD *)(a1 + 104), (uint64_t)&v12, (uint64_t)&v10);
  if (!(_DWORD)UpcomingImageInfo)
  {
    v4 = 0;
    if (!v2)
      return v4;
    goto LABEL_3;
  }
  v8 = v12;
  v9 = v13;
  v6 = v10;
  v7 = v11;
  v4 = FigVCPOutputSetUpcomingImageInfo((uint64_t)v2, UpcomingImageInfo, &v8, &v6);
  if (v2)
LABEL_3:
    CFRelease(v2);
  return v4;
}

uint64_t videoprocessor_updateCoreAnimationThrottling(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  CFTypeRef v4;
  CFTypeRef v5;
  int v6;
  _BOOL4 v7;
  BOOL v8;
  uint64_t v9;
  void (*v10)(uint64_t);
  char v12;

  v2 = a2;
  v12 = a2;
  v4 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 32));
  v5 = videoprocessor_loadAndRetainAtomically(a1, (CFTypeRef *)(a1 + 144));
  v6 = *(_DWORD *)(a1 + 136);
  if (v6 == 1)
  {
    if ((_DWORD)v2)
    {
      v7 = FigVCPSourceArrayContainsCoreAnimationSource((uint64_t)v4);
      if (v5)
        v8 = 0;
      else
        v8 = !v7;
      if (v8)
        v2 = 0;
      else
        v2 = 4294954993;
    }
    goto LABEL_22;
  }
  if (v6 != 3)
  {
    if (v6 == 2)
    {
      if ((_DWORD)v2)
      {
        if (FigVCPSourceArrayContainsCoreAnimationSource((uint64_t)v4) || v5)
        {
          v2 = 0;
          *(_BYTE *)(a1 + 160) = 0;
          *(_BYTE *)(a1 + 140) = 1;
          goto LABEL_22;
        }
LABEL_27:
        v2 = 0;
        if (!v4)
          return v2;
        goto LABEL_25;
      }
      if (!*(_BYTE *)(a1 + 160))
      {
        if (*(_BYTE *)(a1 + 140))
        {
          *(_BYTE *)(a1 + 160) = 1;
          *(_BYTE *)(a1 + 140) = 0;
          v9 = *(_QWORD *)(a1 + 128);
          v10 = *(void (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 16);
          if (v10)
            v10(v9);
        }
      }
    }
    v2 = 0;
LABEL_22:
    if (!v5)
      goto LABEL_24;
    goto LABEL_23;
  }
  FigVCPSourceArrayApplyFunction((uint64_t)v4, (uint64_t (*)(const void *, uint64_t))videoprocessor_throttleSourceForBackground, (uint64_t)&v12);
  if (!v5)
    goto LABEL_27;
  FigVCPCoreAnimationPostProcessorThrottleForBackground((uint64_t)v5);
  v2 = 0;
LABEL_23:
  CFRelease(v5);
LABEL_24:
  if (v4)
LABEL_25:
    CFRelease(v4);
  return v2;
}

void videoprocessor_sendSeekCompleteNotification()
{
  CFMutableDictionaryRef Mutable;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetInt32();
  CMNotificationCenterGetDefaultLocalCenter();
  FigDispatchAsyncPostNotification();
  if (Mutable)
    CFRelease(Mutable);
}

uint64_t videoprocessor_isTrackRequired(const __CFArray *a1, int a2)
{
  CFNumberRef v3;
  uint64_t v4;
  int valuePtr;
  CFRange v7;

  valuePtr = a2;
  if (!a1)
    return 1;
  v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
  v7.length = CFArrayGetCount(a1);
  v7.location = 0;
  v4 = CFArrayContainsValue(a1, v7, v3);
  if (v3)
    CFRelease(v3);
  return v4;
}

uint64_t videoprocessor_willCompositionInstructionContinueForever(const __CFDictionary *a1, int a2)
{
  const __CFDictionary *Value;
  const __CFDictionary *v5;
  CMTime v6;
  CMTime v7;
  CMTime v8;
  CMTime v9;

  if (FigVCPDirectionIsForwardOrPaused(a2))
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("EndTime"));
    CMTimeMakeFromDictionary(&v9, Value);
    if ((v9.flags & 1) != 0)
    {
      CMTimeMakeFromDictionary(&v8, Value);
      return (LOBYTE(v8.flags) >> 2) & 1;
    }
    return 0;
  }
  v5 = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("StartTime"));
  CMTimeMakeFromDictionary(&v7, v5);
  if ((v7.flags & 1) == 0)
    return 0;
  CMTimeMakeFromDictionary(&v6, v5);
  return (LOBYTE(v6.flags) >> 3) & 1;
}

uint64_t videoprocessor_throttleSourceForBackground(uint64_t a1, unsigned __int8 *a2)
{
  return FigVCPSourceThrottleForBackground(a1, *a2);
}

void videoprocessor_initReadOnlyPropertyKeys()
{
  __CFSet *Mutable;

  Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B3B0]);
  CFSetAddValue(Mutable, CFSTR("VideoCompositionProcessor_SourcePixelBufferAttributes"));
  videoprocessor_readOnlyPropertyKeys = (uint64_t)Mutable;
}

void videoprocessor_initStaticPropertyKeys()
{
  __CFSet *Mutable;

  Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B3B0]);
  CFSetAddValue(Mutable, CFSTR("VideoCompositionProcessor_ClientPID"));
  CFSetAddValue(Mutable, CFSTR("VideoCompositionProcessor_PixelBufferPoolSharingID"));
  videoprocessor_staticPropertyKeys = (uint64_t)Mutable;
}

void __overrideHDRMetadataGenerationByDefaultsWrite_block_invoke()
{
  CFPropertyListRef v0;
  const void *v1;
  CFTypeID v2;

  v0 = CFPreferencesCopyValue(CFSTR("videoCompositionHDRDisplayMetadata"), CFSTR("com.apple.avfoundation"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B230]);
  if (v0)
  {
    v1 = v0;
    v2 = CFGetTypeID(v0);
    if (v2 == CFStringGetTypeID())
    {
      if (FigCFEqual())
        overrideHDRMetadataGenerationByDefaultsWrite_sOverrideHDRMetadataGeneration = 1;
    }
    CFRelease(v1);
  }
}

uint64_t FigVisualContextCreateRemote(int a1, CFTypeRef cf, _QWORD *a3)
{
  uint64_t v5;
  CFTypeID v6;
  uint64_t v7;
  uint64_t DerivedStorage;
  uint64_t v9;
  uint64_t uint64;

  if (!a3)
    return FigSignalErrorAt();
  if (remoteXPCVisualContextClient_EnsureClientEstablished_gVisualContextRemoteClientSetupOnce != -1)
    dispatch_once(&remoteXPCVisualContextClient_EnsureClientEstablished_gVisualContextRemoteClientSetupOnce, &__block_literal_global_63);
  v5 = remoteXPCVisualContextClient_EnsureClientEstablished_err;
  if (!remoteXPCVisualContextClient_EnsureClientEstablished_err)
  {
    if (cf && (v6 = CFGetTypeID(cf), v6 == CFDictionaryGetTypeID()))
    {
      FigVisualContextGetClassID();
      v7 = CMDerivedObjectCreate();
      if ((_DWORD)v7
        || (DerivedStorage = CMBaseObjectGetDerivedStorage(),
            v9 = FigReadWriteLockCreate(),
            (*(_QWORD *)(DerivedStorage + 16) = v9) == 0)
        && (v7 = FigSignalErrorAt(), (_DWORD)v7)
        || (v7 = FigXPCCreateBasicMessage(), (_DWORD)v7)
        || (v7 = FigXPCMessageSetCFDictionary(), (_DWORD)v7)
        || (v7 = FigXPCRemoteClientSendSyncMessageCreatingReply(), (_DWORD)v7))
      {
        v5 = v7;
      }
      else
      {
        uint64 = xpc_dictionary_get_uint64(0, (const char *)*MEMORY[0x1E0CA36A0]);
        *(_QWORD *)CMBaseObjectGetDerivedStorage() = uint64;
        v5 = FigXPCRemoteClientAssociateObject();
        if (!(_DWORD)v5)
          *a3 = 0;
      }
    }
    else
    {
      v5 = FigSignalErrorAt();
    }
    FigXPCRelease();
    FigXPCRelease();
    FigXPCRemoteClientKillServerOnTimeout();
  }
  return v5;
}

uint64_t FigVisualContextXPCRemoteGetObjectID(const void *a1, _QWORD *a2)
{
  CFTypeID v4;

  if (a1
    && (v4 = CFGetTypeID(a1), v4 == FigVisualContextGetTypeID())
    && (_UNKNOWN *)CMBaseObjectGetVTable() == &kRemoteXPCVisualContext_VTable
    && a2)
  {
    return remoteXPCVisualContext_GetObjectID((uint64_t)a1, a2);
  }
  else
  {
    return FigSignalErrorAt();
  }
}

uint64_t remoteXPCVisualContext_GetObjectID(uint64_t a1, _QWORD *a2)
{
  uint64_t DerivedStorage;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(_BYTE *)(DerivedStorage + 8))
    return FigSignalErrorAt();
  *a2 = *(_QWORD *)DerivedStorage;
  return 0;
}

uint64_t remoteXPCVisualContextClient_DeadConnectionCallback()
{
  uint64_t result;

  result = CMBaseObjectGetDerivedStorage();
  *(_BYTE *)(result + 8) = 1;
  return result;
}

uint64_t remoteXPCVisualContextClient_MessageHandler(const void *a1)
{
  CFTypeID v1;
  uint64_t result;

  if (!a1)
    return FigSignalErrorAt();
  v1 = CFGetTypeID(a1);
  if (v1 != FigVisualContextGetTypeID())
    return FigSignalErrorAt();
  result = FigXPCMessageGetOpCode();
  if (!(_DWORD)result)
    return 4294951138;
  return result;
}

uint64_t rvcInvalidate(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v3;
  uint64_t v4;
  uint64_t ObjectID;
  _QWORD v7[2];

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v7[0] = 0;
  v7[1] = 0;
  if (*(_BYTE *)(DerivedStorage + 9))
    return 0;
  v4 = DerivedStorage;
  ObjectID = remoteXPCVisualContext_GetObjectID(a1, v7);
  if ((_DWORD)ObjectID
    || v7[0]
    && ((ObjectID = FigXPCCreateBasicMessage(), (_DWORD)ObjectID)
     || (ObjectID = FigXPCRemoteClientSendSyncMessage(), (_DWORD)ObjectID)))
  {
    v3 = ObjectID;
  }
  else
  {
    v3 = 0;
    *(_BYTE *)(v4 + 9) = 1;
  }
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v3;
}

uint64_t rvcFinalize(uint64_t a1)
{
  uint64_t DerivedStorage;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  rvcInvalidate(a1);
  FigReadWriteLockDestroy();
  FigXPCRemoteClientDisassociateObject();
  if (!*(_BYTE *)(DerivedStorage + 8) && !FigXPCCreateBasicMessage())
    FigXPCRemoteClientSendAsyncMessage();
  FigXPCRelease();
  return FigXPCRemoteClientKillServerOnTimeout();
}

__CFString *rvcCopyDebugDesc(const void *a1)
{
  _QWORD *DerivedStorage;
  const __CFAllocator *v3;
  __CFString *Mutable;
  CFAllocatorRef v5;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  v3 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v3, 0);
  v5 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigVisualContext %p [%p] [%016llx]>{imageAvailableImmediate:%p, imageAvailableSequential:%p, noMoreImages:%p, }"), a1, v5, *DerivedStorage, DerivedStorage[3], DerivedStorage[5], DerivedStorage[7]);
  return Mutable;
}

uint64_t rvcSetImageAvailableImmediateCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t ObjectID;
  uint64_t v8;
  uint64_t v10;
  xpc_object_t xdict;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v10 = 0;
  xdict = 0;
  FigReadWriteLockLockForWrite();
  if (a2 && *(_QWORD *)(DerivedStorage + 24))
  {
    ObjectID = FigSignalErrorAt();
LABEL_4:
    v8 = ObjectID;
    goto LABEL_9;
  }
  ObjectID = remoteXPCVisualContext_GetObjectID(a1, &v10);
  if ((_DWORD)ObjectID)
    goto LABEL_4;
  ObjectID = FigXPCCreateBasicMessage();
  if ((_DWORD)ObjectID)
    goto LABEL_4;
  xpc_dictionary_set_BOOL(xdict, "CallbackIsSet", a2 != 0);
  v8 = FigXPCRemoteClientSendSyncMessage();
  if (!(_DWORD)v8)
  {
    *(_QWORD *)(DerivedStorage + 24) = a2;
    *(_QWORD *)(DerivedStorage + 32) = a3;
  }
LABEL_9:
  FigReadWriteLockUnlockForWrite();
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v8;
}

uint64_t rvcSetImageAvailableSequentialCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t ObjectID;
  uint64_t v8;
  uint64_t v10;
  xpc_object_t xdict;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v10 = 0;
  xdict = 0;
  FigReadWriteLockLockForWrite();
  if (a2 && *(_QWORD *)(DerivedStorage + 40))
  {
    ObjectID = FigSignalErrorAt();
LABEL_4:
    v8 = ObjectID;
    goto LABEL_9;
  }
  ObjectID = remoteXPCVisualContext_GetObjectID(a1, &v10);
  if ((_DWORD)ObjectID)
    goto LABEL_4;
  ObjectID = FigXPCCreateBasicMessage();
  if ((_DWORD)ObjectID)
    goto LABEL_4;
  xpc_dictionary_set_BOOL(xdict, "CallbackIsSet", a2 != 0);
  v8 = FigXPCRemoteClientSendSyncMessage();
  if (!(_DWORD)v8)
  {
    *(_QWORD *)(DerivedStorage + 40) = a2;
    *(_QWORD *)(DerivedStorage + 48) = a3;
  }
LABEL_9:
  FigReadWriteLockUnlockForWrite();
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v8;
}

uint64_t rvcSetNoMoreImagesCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t ObjectID;
  uint64_t v8;
  uint64_t v10;
  xpc_object_t xdict;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v10 = 0;
  xdict = 0;
  FigReadWriteLockLockForWrite();
  if (a2 && *(_QWORD *)(DerivedStorage + 56))
  {
    ObjectID = FigSignalErrorAt();
LABEL_4:
    v8 = ObjectID;
    goto LABEL_9;
  }
  ObjectID = remoteXPCVisualContext_GetObjectID(a1, &v10);
  if ((_DWORD)ObjectID)
    goto LABEL_4;
  ObjectID = FigXPCCreateBasicMessage();
  if ((_DWORD)ObjectID)
    goto LABEL_4;
  xpc_dictionary_set_BOOL(xdict, "CallbackIsSet", a2 != 0);
  v8 = FigXPCRemoteClientSendSyncMessage();
  if (!(_DWORD)v8)
  {
    *(_QWORD *)(DerivedStorage + 56) = a2;
    *(_QWORD *)(DerivedStorage + 64) = a3;
  }
LABEL_9:
  FigReadWriteLockUnlockForWrite();
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v8;
}

uint64_t rvcSetBecameEmptyCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t ObjectID;
  uint64_t v8;
  uint64_t v10;
  xpc_object_t xdict;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v10 = 0;
  xdict = 0;
  FigReadWriteLockLockForWrite();
  if (a2 && *(_QWORD *)(DerivedStorage + 72))
  {
    ObjectID = FigSignalErrorAt();
LABEL_4:
    v8 = ObjectID;
    goto LABEL_9;
  }
  ObjectID = remoteXPCVisualContext_GetObjectID(a1, &v10);
  if ((_DWORD)ObjectID)
    goto LABEL_4;
  ObjectID = FigXPCCreateBasicMessage();
  if ((_DWORD)ObjectID)
    goto LABEL_4;
  xpc_dictionary_set_BOOL(xdict, "CallbackIsSet", a2 != 0);
  v8 = FigXPCRemoteClientSendSyncMessage();
  if (!(_DWORD)v8)
  {
    *(_QWORD *)(DerivedStorage + 72) = a2;
    *(_QWORD *)(DerivedStorage + 80) = a3;
  }
LABEL_9:
  FigReadWriteLockUnlockForWrite();
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v8;
}

BOOL rvcIsNewImageAvailable(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  uint64_t v4;
  xpc_object_t xdict;
  uint64_t v6;

  xdict = 0;
  v6 = 0;
  v4 = 0;
  if ((*(_DWORD *)(a2 + 12) & 0x1D) == 1)
  {
    v2 = !remoteXPCVisualContext_GetObjectID(a1, &v4)
      && !FigXPCCreateBasicMessage()
      && !FigXPCMessageSetCMTime()
      && !FigXPCRemoteClientSendSyncMessageCreatingReply()
      && xpc_dictionary_get_BOOL(xdict, "NewImageAvailable");
    FigXPCRelease();
    FigXPCRelease();
    FigXPCRemoteClientKillServerOnTimeout();
  }
  else
  {
    return FigSignalErrorAt();
  }
  return v2;
}

uint64_t rvcCopyImageForTime(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, _QWORD *a5, _QWORD *a6, uint64_t a7)
{
  __int128 v7;
  uint64_t v8;
  uint64_t ObjectID;
  IOSurfaceRef v14;
  xpc_object_t value;
  uint64_t CMTime;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  xpc_object_t xdict;
  xpc_object_t v23;

  v23 = 0;
  v21 = 0;
  xdict = 0;
  v7 = *MEMORY[0x1E0CA2E18];
  v19 = *MEMORY[0x1E0CA2E18];
  v8 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  v20 = v8;
  if ((*(_DWORD *)(a3 + 12) & 0x1D) != 1)
    return FigSignalErrorAt();
  if (a5)
    *a5 = 0;
  if (a6)
    *a6 = 0;
  if (a7)
  {
    *(_OWORD *)a7 = v7;
    *(_QWORD *)(a7 + 16) = v8;
  }
  ObjectID = remoteXPCVisualContext_GetObjectID(a1, &v21);
  if (!(_DWORD)ObjectID)
  {
    ObjectID = FigXPCCreateBasicMessage();
    if (!(_DWORD)ObjectID)
    {
      ObjectID = FigXPCMessageSetCMTime();
      if (!(_DWORD)ObjectID)
      {
        xpc_dictionary_set_uint64(v23, "Flags", a4);
        xpc_dictionary_set_BOOL(v23, "WantsImage", a5 != 0);
        xpc_dictionary_set_BOOL(v23, "WantsImageBaggage", a6 != 0);
        xpc_dictionary_set_BOOL(v23, "WantsImageOriginalTime", a7 != 0);
        ObjectID = FigXPCRemoteClientSendSyncMessageCreatingReply();
        if (!(_DWORD)ObjectID)
        {
          if (!a5 || xpc_dictionary_get_BOOL(xdict, "IsNullImage"))
          {
            v14 = 0;
LABEL_20:
            if (!a6 || (CMTime = FigXPCMessageCopyCFDictionary(), !(_DWORD)CMTime))
            {
              if (!a7 || (CMTime = FigXPCMessageGetCMTime(), !(_DWORD)CMTime))
              {
                if (a5)
                  *a5 = 0;
                if (a6)
                  *a6 = 0;
                v18 = 0;
                if (a7)
                {
                  *(_OWORD *)a7 = v19;
                  *(_QWORD *)(a7 + 16) = v20;
                }
                goto LABEL_30;
              }
            }
            goto LABEL_36;
          }
          value = xpc_dictionary_get_value(xdict, "IOSurface");
          if (value)
          {
            v14 = IOSurfaceLookupFromXPCObject(value);
            if (v14)
            {
              CMTime = FigXPCMessageCreateBlockBufferData();
              if (!(_DWORD)CMTime)
              {
                CMTime = FigRemote_CreatePixelBufferFromSerializedAtomDataAndSurface();
                if (!(_DWORD)CMTime)
                  goto LABEL_20;
              }
            }
            else
            {
              CMTime = FigSignalErrorAt();
            }
LABEL_36:
            v18 = CMTime;
            goto LABEL_30;
          }
          ObjectID = FigSignalErrorAt();
        }
      }
    }
  }
  v18 = ObjectID;
  v14 = 0;
LABEL_30:
  if (v14)
    CFRelease(v14);
  FigXPCRelease();
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v18;
}

uint64_t rvcConvertHostTimeToImageTime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t ObjectID;
  uint64_t CMTime;
  _QWORD v7[2];
  xpc_object_t xdict;

  v7[1] = 0;
  xdict = 0;
  v7[0] = 0;
  if (!a3 || a2 && (*(_BYTE *)(a2 + 64) & 2) == 0)
    return FigSignalErrorAt();
  ObjectID = remoteXPCVisualContext_GetObjectID(a1, v7);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(), (_DWORD)ObjectID))
  {
    CMTime = ObjectID;
  }
  else
  {
    if (a2)
      xpc_dictionary_set_uint64(xdict, "HostTime", *(_QWORD *)(a2 + 16));
    CMTime = FigXPCRemoteClientSendSyncMessageCreatingReply();
    if (!(_DWORD)CMTime)
      CMTime = FigXPCMessageGetCMTime();
  }
  FigXPCRelease();
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return CMTime;
}

uint64_t rvcGetEarliestSequentialImageTimeAfterTime(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, BOOL *a5)
{
  uint64_t v8;
  uint64_t ObjectID;
  uint64_t CMTime;
  uint64_t v11;
  uint64_t v13;
  xpc_object_t v14;
  xpc_object_t xdict;

  v14 = 0;
  xdict = 0;
  v13 = 0;
  if (a4)
  {
    v8 = MEMORY[0x1E0CA2E18];
    *(_OWORD *)a4 = *MEMORY[0x1E0CA2E18];
    *(_QWORD *)(a4 + 16) = *(_QWORD *)(v8 + 16);
  }
  if (a5)
    *a5 = 0;
  ObjectID = remoteXPCVisualContext_GetObjectID(a1, &v13);
  if ((_DWORD)ObjectID
    || (ObjectID = FigXPCCreateBasicMessage(), (_DWORD)ObjectID)
    || (xpc_dictionary_set_uint64(xdict, "Flags", a2), ObjectID = FigXPCMessageSetCMTime(), (_DWORD)ObjectID)
    || (ObjectID = FigXPCRemoteClientSendSyncMessageCreatingReply(), (_DWORD)ObjectID))
  {
    v11 = ObjectID;
    goto LABEL_16;
  }
  if (!a4)
  {
    if (!a5)
    {
      v11 = 0;
      goto LABEL_16;
    }
    goto LABEL_14;
  }
  CMTime = FigXPCMessageGetCMTime();
  v11 = CMTime;
  if (a5 && !(_DWORD)CMTime)
  {
LABEL_14:
    v11 = 0;
    *a5 = xpc_dictionary_get_BOOL(v14, "NoMoreImages");
  }
LABEL_16:
  FigXPCRelease();
  FigXPCRelease();
  FigXPCRemoteClientKillServerOnTimeout();
  return v11;
}

uint64_t rvcTask(uint64_t a1)
{
  _QWORD v2[2];

  v2[0] = 0;
  v2[1] = 0;
  if (!remoteXPCVisualContext_GetObjectID(a1, v2) && !FigXPCCreateBasicMessage())
    FigXPCRemoteClientSendSyncMessage();
  FigXPCRelease();
  return FigXPCRemoteClientKillServerOnTimeout();
}

uint64_t FigVideoCompositorGetClassID()
{
  MEMORY[0x19402F294](&FigVideoCompositorGetClassID_sRegisterFigVideoCompositorBaseTypeOnce, RegisterFigVideoCompositorBaseType);
  return sFigVideoCompositorClassID;
}

uint64_t RegisterFigVideoCompositorBaseType()
{
  CMBaseGetClassID();
  return FigBaseClassRegisterClass();
}

uint64_t FigVideoCompositorGetTypeID()
{
  MEMORY[0x19402F294](&FigVideoCompositorGetClassID_sRegisterFigVideoCompositorBaseTypeOnce, RegisterFigVideoCompositorBaseType);
  return CMBaseClassGetCFTypeID();
}

CFTypeID FigVideoCompositorUtilityGetPixelAspectRatio(CFTypeID result, _DWORD *a2, _DWORD *a3)
{
  const __CFDictionary *v5;
  const void *Value;
  const void *v7;
  CFTypeID TypeID;
  CFTypeID v9;

  if (result)
  {
    v5 = (const __CFDictionary *)result;
    Value = CFDictionaryGetValue((CFDictionaryRef)result, (const void *)*MEMORY[0x1E0CA8E60]);
    result = (CFTypeID)CFDictionaryGetValue(v5, (const void *)*MEMORY[0x1E0CA8E70]);
    v7 = (const void *)result;
    if (a2)
    {
      *a2 = 1;
      if (Value)
      {
        TypeID = CFNumberGetTypeID();
        result = CFGetTypeID(Value);
        if (TypeID == result)
          result = CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, a2);
      }
    }
    if (a3)
    {
      *a3 = 1;
      if (v7)
      {
        v9 = CFNumberGetTypeID();
        result = CFGetTypeID(v7);
        if (v9 == result)
          return CFNumberGetValue((CFNumberRef)v7, kCFNumberIntType, a3);
      }
    }
  }
  else
  {
    *a3 = 1;
    *a2 = 1;
  }
  return result;
}

uint64_t FigVideoCompositorUtilityGetEdgeProcessingPixels(uint64_t theArray, _QWORD *a2)
{
  _QWORD *v2;
  const __CFArray *v3;
  CFIndex i;
  const void *v5;
  CFTypeID TypeID;

  if (a2)
  {
    v2 = a2;
    v3 = (const __CFArray *)theArray;
    if (theArray && (theArray = CFArrayGetCount((CFArrayRef)theArray), theArray == 4))
    {
      for (i = 0; i != 4; ++i)
      {
        theArray = (uint64_t)CFArrayGetValueAtIndex(v3, i);
        if (theArray)
        {
          v5 = (const void *)theArray;
          TypeID = CFNumberGetTypeID();
          theArray = CFGetTypeID(v5);
          if (TypeID == theArray)
            theArray = CFNumberGetValue((CFNumberRef)v5, kCFNumberIntType, v2);
        }
        v2 = (_QWORD *)((char *)v2 + 4);
      }
    }
    else
    {
      *v2 = 0;
      v2[1] = 0;
    }
  }
  return theArray;
}

BOOL FigVideoCompositorUtilityAreCleanAperturesEqual(const void *a1, int a2, int a3, const void *a4, int a5, int a6)
{
  CFTypeID TypeID;
  CFTypeID v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v26 = 0;
  v27 = 0;
  v24 = 0;
  v25 = 0;
  v22 = 0;
  v23 = 0;
  v20 = 0;
  v21 = 0;
  if (a1 == a4)
    return 1;
  if (a1 && (TypeID = CFDictionaryGetTypeID(), TypeID != CFGetTypeID(a1))
    || a4 && (v13 = CFDictionaryGetTypeID(), v13 != CFGetTypeID(a4)))
  {
    FigSignalErrorAt();
  }
  else if (!vcu_getCleanApertureRational(a1, a2, a3, &v27, &v25, &v23, &v21)
         && !vcu_getCleanApertureRational(a4, a5, a6, &v26, &v24, &v22, &v20))
  {
    v14 = vcu_simplifyRational(v27);
    if (v14 == vcu_simplifyRational(v26))
    {
      v15 = vcu_simplifyRational(v25);
      if (v15 == vcu_simplifyRational(v24))
      {
        v16 = vcu_simplifyRational(v23);
        if (v16 == vcu_simplifyRational(v22))
        {
          v17 = vcu_simplifyRational(v21);
          v18 = vcu_simplifyRational(v20);
          if ((_DWORD)v17 == (_DWORD)v18)
            return HIDWORD(v17) == HIDWORD(v18);
        }
      }
    }
  }
  return 0;
}

uint64_t vcu_getCleanApertureRational(const void *a1, int a2, int a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  CFTypeID TypeID;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v16 = 0x100000000;
  v17 = 0x100000000;
  v14 = 0x100000000;
  v15 = 0x100000000;
  if (!a1)
  {
    LODWORD(v17) = a2;
    LODWORD(v16) = a3;
    LODWORD(v15) = 0;
    LODWORD(v14) = 0;
    if (!a4)
      goto LABEL_9;
    goto LABEL_8;
  }
  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(a1))
    return FigSignalErrorAt();
  result = vcu_getRationalFromDictionary((const __CFDictionary *)a1, (const void *)*MEMORY[0x1E0CA8D60], (void *)*MEMORY[0x1E0CA22F8], (uint64_t)&v17);
  if (!(_DWORD)result)
  {
    result = vcu_getRationalFromDictionary((const __CFDictionary *)a1, (const void *)*MEMORY[0x1E0CA8D40], (void *)*MEMORY[0x1E0CA22C8], (uint64_t)&v16);
    if (!(_DWORD)result)
    {
      result = vcu_getRationalFromDictionary((const __CFDictionary *)a1, (const void *)*MEMORY[0x1E0CA8D48], (void *)*MEMORY[0x1E0CA22D8], (uint64_t)&v15);
      if (!(_DWORD)result)
      {
        result = vcu_getRationalFromDictionary((const __CFDictionary *)a1, (const void *)*MEMORY[0x1E0CA8D58], (void *)*MEMORY[0x1E0CA22E8], (uint64_t)&v14);
        if (!(_DWORD)result)
        {
          if (!a4)
          {
LABEL_9:
            if (a5)
              *a5 = v16;
            if (a6)
              *a6 = v15;
            result = 0;
            if (a7)
              *a7 = v14;
            return result;
          }
LABEL_8:
          *a4 = v17;
          goto LABEL_9;
        }
      }
    }
  }
  return result;
}

unint64_t vcu_simplifyRational(uint64_t a1)
{
  int v1;
  int v2;
  unsigned int v3;
  int v4;

  if ((int)a1 >= 0)
    v1 = a1;
  else
    v1 = -(int)a1;
  if (a1 >= 0)
    v2 = HIDWORD(a1);
  else
    v2 = -HIDWORD(a1);
  if (v1 <= v2)
    v3 = v2;
  else
    v3 = v1;
  if (v1 >= v2)
    v1 = v2;
  if (v1)
  {
    if (v1 < 1)
    {
      v4 = v3;
    }
    else
    {
      do
      {
        v4 = v1;
        v1 = (int)v3 % v1;
        v3 = v4;
      }
      while (v1 > 0);
    }
  }
  else if (v3 <= 1)
  {
    v4 = 1;
  }
  else
  {
    v4 = v3;
  }
  return ((int)a1 / v4) | ((unint64_t)(SHIDWORD(a1) / v4) << 32);
}

BOOL FigVideoCompositorUtilityArePixelAspectRatiosEqual(CFTypeID a1, CFTypeID a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  uint64_t v8;

  v7 = 0;
  v8 = 0;
  FigVideoCompositorUtilityGetPixelAspectRatio(a1, (_DWORD *)&v8 + 1, &v8);
  FigVideoCompositorUtilityGetPixelAspectRatio(a2, (_DWORD *)&v7 + 1, &v7);
  v4 = v7;
  v3 = HIDWORD(v7);
  v5 = vcu_simplifyRational(HIDWORD(v8) | ((unint64_t)v8 << 32));
  return v5 == vcu_simplifyRational(v3 | (v4 << 32));
}

float FigVideoCompositorUtilityGetCleanAperture(const void *a1, int a2, int a3, float *a4, float *a5, float *a6, float *a7)
{
  float result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v14 = 0x100000000;
  v15 = 0x100000000;
  v12 = 0x100000000;
  v13 = 0x100000000;
  if (!vcu_getCleanApertureRational(a1, a2, a3, &v15, &v14, &v13, &v12))
  {
    if (a4)
    {
      result = (float)(int)v15 / (float)SHIDWORD(v15);
      *a4 = result;
    }
    if (a5)
    {
      result = (float)(int)v14 / (float)SHIDWORD(v14);
      *a5 = result;
    }
    if (a6)
    {
      result = (float)(int)v13 / (float)SHIDWORD(v13);
      *a6 = result;
    }
    if (a7)
    {
      result = (float)(int)v12 / (float)SHIDWORD(v12);
      *a7 = result;
    }
  }
  return result;
}

void vcu_addRationalToDictionary(unint64_t a1, __CFDictionary *a2, const void *a3, const void *a4)
{
  unint64_t v7;
  const __CFAllocator *v8;
  CFNumberRef v9;
  __CFArray *Mutable;
  CFNumberRef v11;
  CFNumberRef v12;
  double v13;
  unint64_t valuePtr;

  v7 = HIDWORD(a1);
  valuePtr = a1;
  v13 = (double)(int)a1 / (double)SHIDWORD(a1);
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &v13);
  CFDictionaryAddValue(a2, a3, v9);
  CFRelease(v9);
  if ((_DWORD)v7 != 1)
  {
    Mutable = CFArrayCreateMutable(v8, 2, MEMORY[0x1E0C9B378]);
    v11 = CFNumberCreate(v8, kCFNumberIntType, &valuePtr);
    CFArrayAppendValue(Mutable, v11);
    CFRelease(v11);
    v12 = CFNumberCreate(v8, kCFNumberIntType, (char *)&valuePtr + 4);
    CFArrayAppendValue(Mutable, v12);
    CFRelease(v12);
    CFDictionaryAddValue(a2, a4, Mutable);
    CFRelease(Mutable);
  }
}

uint64_t FigVideoCompositorUtilityCopyRenderPixelBufferDimensionsAndCleanAperture(CFTypeID a1, uint64_t theArray, _QWORD *a3, _QWORD *a4, uint64_t a5, __CFDictionary **a6, double a7, double a8, float a9)
{
  double v16;
  int v17;
  unint64_t v18;
  unsigned __int32 v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  signed __int32 v24;
  unsigned int v25;
  int v26;
  signed __int32 v27;
  __CFDictionary *Mutable;
  unint64_t v29;
  unint64_t v30;
  float v32;
  int v33;
  int v34;
  int32x4_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v33 = 1;
  v34 = 1;
  v35 = 0uLL;
  v32 = a9;
  if (a1)
  {
    FigVideoCompositorUtilityGetPixelAspectRatio(a1, &v34, &v33);
    a9 = v32;
  }
  if (theArray)
  {
    FigVideoCompositorUtilityGetEdgeProcessingPixels(theArray, &v35);
    a9 = v32;
  }
  v35 = vcvtq_s32_f32(vmulq_n_f32(vcvtq_f32_s32(v35), a9));
  v16 = (double)v33;
  if (a9 == 1.0)
  {
    v17 = v34;
    v18 = vcu_simplifyRational((int)(a7 * v16 + 0.5) | ((unint64_t)v34 << 32));
    v19 = v18;
    v20 = HIDWORD(v18);
    if ((v18 & 0x8000000000000000) == 0)
      v21 = HIDWORD(v18);
    else
      v21 = HIDWORD(v18) + 1;
    v22 = ((int)v18 + (v21 >> 1)) / SHIDWORD(v18);
    v23 = v35.i32[0];
    v24 = v35.i32[0] + v35.i32[2] + v22;
    if ((float)((float)(int)v18 / (float)SHIDWORD(v18)) > (float)v24)
    {
      v20 = 1;
      v19 = v24;
    }
    a9 = v32;
    if (a3)
      goto LABEL_12;
  }
  else
  {
    v17 = v34;
    v23 = v35.i32[0];
    v24 = (v35.i32[2] + v35.i32[0] + (int)(a7 * v16 * a9 / (double)v34 + 1.0)) & 0xFFFFFFFE;
    v19 = v24 - (v35.i32[2] + v35.i32[0]);
    v20 = 1;
    if (a3)
LABEL_12:
      *a3 = v24;
  }
  if (a9 == 1.0)
  {
    v25 = (int)(a8 + 0.5);
    v26 = v35.i32[1];
    v27 = v35.i32[1] + v35.i32[3] + v25;
    if (!a4)
      goto LABEL_16;
    goto LABEL_15;
  }
  v26 = v35.i32[1];
  v27 = (v35.i32[3] + v35.i32[1] + (int)(a8 * a9 + 1.0)) & 0xFFFFFFFE;
  v25 = v27 - (v35.i32[3] + v35.i32[1]);
  if (a4)
LABEL_15:
    *a4 = v27;
LABEL_16:
  if (a5)
  {
    *(double *)a5 = v16 / (double)v17;
    *(_QWORD *)(a5 + 8) = 0;
    *(_QWORD *)(a5 + 16) = 0;
    *(_QWORD *)(a5 + 24) = 0x3FF0000000000000;
    *(double *)(a5 + 32) = (double)v23;
    *(double *)(a5 + 40) = (double)v26;
  }
  if (a6)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    vcu_addRationalToDictionary(v19 | (unint64_t)(v20 << 32), Mutable, (const void *)*MEMORY[0x1E0CA8D60], (const void *)*MEMORY[0x1E0CA22F8]);
    vcu_addRationalToDictionary(v25 | 0x100000000, Mutable, (const void *)*MEMORY[0x1E0CA8D40], (const void *)*MEMORY[0x1E0CA22C8]);
    v29 = vcu_simplifyRational((v35.i32[0] - v35.i32[2]) | 0x200000000);
    vcu_addRationalToDictionary(v29, Mutable, (const void *)*MEMORY[0x1E0CA8D48], (const void *)*MEMORY[0x1E0CA22D8]);
    v30 = vcu_simplifyRational((v35.i32[1] - v35.i32[3]) | 0x200000000);
    vcu_addRationalToDictionary(v30, Mutable, (const void *)*MEMORY[0x1E0CA8D58], (const void *)*MEMORY[0x1E0CA22E8]);
    *a6 = Mutable;
  }
  return 0;
}

uint64_t FigVideoCompositorUtilityCopyRenderDimensionsAndEdgeProcessingPixels(int a1, int a2, CFTypeID a3, const __CFDictionary *a4, double *a5, __CFArray **a6)
{
  uint64_t result;
  double v12;
  int v13;
  int v14;
  const __CFAllocator *v15;
  __CFArray *Mutable;
  uint64_t v17;
  double v18;
  CFNumberRef v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  _DWORD v28[4];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v26 = 1;
  v27 = 1;
  v24 = a1;
  v25 = 1;
  v22 = a2;
  v23 = 1;
  v20 = 0x100000000;
  v21 = 0x100000000;
  if (a3)
    FigVideoCompositorUtilityGetPixelAspectRatio(a3, &v27, &v26);
  if (!a4
    || (result = vcu_getRationalFromDictionary(a4, (const void *)*MEMORY[0x1E0CA8D60], (void *)*MEMORY[0x1E0CA22F8], (uint64_t)&v24), !(_DWORD)result)&& (result = vcu_getRationalFromDictionary(a4, (const void *)*MEMORY[0x1E0CA8D40], (void *)*MEMORY[0x1E0CA22C8], (uint64_t)&v22), !(_DWORD)result)&& (result = vcu_getRationalFromDictionary(a4, (const void *)*MEMORY[0x1E0CA8D48], (void *)*MEMORY[0x1E0CA22D8], (uint64_t)&v21), !(_DWORD)result)&& (result = vcu_getRationalFromDictionary(a4,
                   (const void *)*MEMORY[0x1E0CA8D58],
                   (void *)*MEMORY[0x1E0CA22E8],
                   (uint64_t)&v20),
        !(_DWORD)result))
  {
    if (a5)
    {
      v12 = (double)v22 / (double)v23;
      *a5 = (double)v24 * (double)v27 / ((double)v25 * (double)v26);
      a5[1] = v12;
    }
    if (a6)
    {
      v13 = a1 - v24 / v25;
      v14 = a2 - v22 / v23;
      v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 4, MEMORY[0x1E0C9B378]);
      v17 = 0;
      v18 = (double)((int)v21 / SHIDWORD(v21));
      v28[0] = (int)(v18 + (double)v13 * 0.5);
      v28[1] = (int)(v18 + (double)v14 * 0.5);
      v28[2] = (int)-(v18 - (double)v13 * 0.5);
      v28[3] = (int)-(v18 - (double)v14 * 0.5);
      do
      {
        v19 = CFNumberCreate(v15, kCFNumberIntType, &v28[v17]);
        CFArrayAppendValue(Mutable, v19);
        CFRelease(v19);
        ++v17;
      }
      while (v17 != 4);
      result = 0;
      *a6 = Mutable;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t vcu_getRationalFromDictionary(const __CFDictionary *a1, const void *a2, void *key, uint64_t a4)
{
  const __CFArray *Value;
  const __CFArray *v8;
  CFTypeID TypeID;
  const __CFNumber *ValueAtIndex;
  const __CFNumber *v11;
  const __CFNumber *v12;

  Value = (const __CFArray *)CFDictionaryGetValue(a1, key);
  if (Value)
  {
    v8 = Value;
    TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(v8) && CFArrayGetCount(v8) == 2)
    {
      ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v8, 0);
      CFNumberGetValue(ValueAtIndex, kCFNumberIntType, (void *)a4);
      v11 = (const __CFNumber *)CFArrayGetValueAtIndex(v8, 1);
      CFNumberGetValue(v11, kCFNumberIntType, (void *)(a4 + 4));
      return 0;
    }
  }
  v12 = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  if (v12)
  {
    CFNumberGetValue(v12, kCFNumberIntType, (void *)a4);
    *(_DWORD *)(a4 + 4) = 1;
    return 0;
  }
  return FigSignalErrorAt();
}

uint64_t FigVideoCompositorCopyDeviceSpecificCompositorName(int a1, _QWORD *a2)
{
  const __CFString *v3;
  uint64_t ModelSpecificPropertyList;
  const void *v5;
  CFTypeID TypeID;
  const void *Value;
  const void *v8;
  CFTypeID v9;
  const void *v10;
  const void *v11;
  CFTypeID v12;
  const __CFString *v13;
  CFTypeRef v15;
  uint64_t v16;

  if (!a2)
    return FigSignalErrorAt();
  if (a1)
  {
    if (a1 != 1)
      return FigSignalErrorAt();
    v3 = CFSTR("Remake");
  }
  else
  {
    v3 = CFSTR("Playback");
  }
  ModelSpecificPropertyList = FigCreateModelSpecificPropertyList();
  if (!ModelSpecificPropertyList)
    return FigSignalErrorAt();
  v5 = (const void *)ModelSpecificPropertyList;
  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v5))
    goto LABEL_30;
  Value = CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("VideoCompositor"));
  if (!Value)
    goto LABEL_30;
  v8 = Value;
  v9 = CFDictionaryGetTypeID();
  if (v9 != CFGetTypeID(v8))
    goto LABEL_30;
  v10 = CFDictionaryGetValue((CFDictionaryRef)v8, v3);
  if (!v10)
    goto LABEL_30;
  v11 = v10;
  v12 = CFStringGetTypeID();
  if (v12 != CFGetTypeID(v11))
    goto LABEL_30;
  if (CFEqual(v11, CFSTR("vImage")))
  {
    v13 = CFSTR("VideoCompositorvImage");
  }
  else if (CFEqual(v11, CFSTR("Metal")))
  {
    v13 = CFSTR("VideoCompositorMetal");
  }
  else if (CFEqual(v11, CFSTR("OpenGL")))
  {
    v13 = CFSTR("VideoCompositorOpenGL");
  }
  else if (CFEqual(v11, CFSTR("Custom")))
  {
    v13 = CFSTR("VideoCompositorCustom");
  }
  else
  {
    v13 = CFSTR("VideoCompositorBasic");
  }
  v15 = CFRetain(v13);
  if (FigCFEqual() && !VTPixelTransferSessionCanUseMetalInTheBackground())
  {
    CFRetain(CFSTR("VideoCompositorvImage"));
    if (v15)
      CFRelease(v15);
    v16 = 0;
    *a2 = CFSTR("VideoCompositorvImage");
    goto LABEL_29;
  }
  *a2 = v15;
  if (v15)
    v16 = 0;
  else
LABEL_30:
    v16 = FigSignalErrorAt();
LABEL_29:
  CFRelease(v5);
  return v16;
}

BOOL FigVideoCompositorIsPixelBufferOpaque(__CVBuffer *a1)
{
  CFTypeRef v2;
  const void *v3;
  const void *v4;
  const __CFDictionary *DescriptionWithPixelFormatType;
  _BOOL8 v6;

  v2 = CVBufferCopyAttachment(a1, (CFStringRef)*MEMORY[0x1E0CA8CA8], 0);
  v3 = v2;
  v4 = (const void *)*MEMORY[0x1E0C9AE50];
  if (v2 == (CFTypeRef)*MEMORY[0x1E0C9AE50])
  {
    v6 = 1;
    if (!v2)
      return v6;
    goto LABEL_3;
  }
  CVPixelBufferGetPixelFormatType(a1);
  DescriptionWithPixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
  v6 = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E0CA9168]) != v4;
  if (v3)
LABEL_3:
    CFRelease(v3);
  return v6;
}

CFStringRef FigVideoCompositorCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigVideoCompositor %p]"), a1);
}

uint64_t FigDataQueueServer_EnsureServerAndCopyXPCEndpoint()
{
  uint64_t result;

  if (FigDataQueueServer_EnsureServerAndCopyXPCEndpoint_sFigDataQueueServerOnce != -1)
    dispatch_once(&FigDataQueueServer_EnsureServerAndCopyXPCEndpoint_sFigDataQueueServerOnce, &__block_literal_global_64);
  result = FigDataQueueServer_EnsureServerAndCopyXPCEndpoint_sFigDataQueueServerStartError;
  if (!FigDataQueueServer_EnsureServerAndCopyXPCEndpoint_sFigDataQueueServerStartError)
    return FigXPCServerCopyXPCEndpoint();
  return result;
}

uint64_t FigDataQueueServer_AssociateObjectByPID(uint64_t a1, const void *a2, _QWORD *a3)
{
  uint64_t Instance;
  _QWORD *v6;
  CFTypeRef v7;
  uint64_t v8;

  if (FigDataQueueServerStateGetTypeID_sRegisterDataQueueServerStateTypeOnce != -1)
    dispatch_once(&FigDataQueueServerStateGetTypeID_sRegisterDataQueueServerStateTypeOnce, &__block_literal_global_23_1);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v6 = (_QWORD *)Instance;
    if (a2)
      v7 = CFRetain(a2);
    else
      v7 = 0;
    v6[3] = v7;
    v8 = FigXPCServerAssociateObjectWithNeighborProcessByPID();
    if ((_DWORD)v8)
    {
      CFRelease(v6);
    }
    else
    {
      v6[4] = 0;
      *a3 = 0;
    }
    return v8;
  }
  else
  {
    FigSignalErrorAt();
    return FigSignalErrorAt();
  }
}

uint64_t FigDataQueueServer_CopyDataQueueForID()
{
  return FigXPCServerRetainNeighborObjectFromIDWithConnection();
}

uint64_t dqs_HandleRemoteMessage(uint64_t a1, void *a2)
{
  uint64_t OpCode;

  OpCode = FigXPCMessageGetOpCode();
  if ((_DWORD)OpCode)
    return OpCode;
  xpc_dictionary_get_uint64(a2, (const char *)*MEMORY[0x1E0CA36A0]);
  OpCode = FigXPCServerLookupAndRetainAssociatedObject();
  if ((_DWORD)OpCode)
    return OpCode;
  else
    return 4294951138;
}

uint64_t dqs_SetWaterLevelInMessage(uint64_t a1)
{
  void (*v2)(uint64_t);

  v2 = *(void (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 16);
  if (v2)
    v2(a1);
  return FigXPCMessageSetInt32();
}

void dqs_SendLowWaterMarkCallback()
{
  uint64_t v0;
  xpc_connection_t *v1;

  v0 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v0)
  {
    v1 = (xpc_connection_t *)v0;
    if (!FigXPCCreateBasicMessage())
      xpc_connection_send_message(v1[2], 0);
    FigXPCRelease();
    CFRelease(v1);
  }
  else
  {
    FigSignalErrorAt();
    FigXPCRelease();
  }
}

double DataQueueServerState_init(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void DataQueueServerState_finalize(uint64_t a1)
{
  uint64_t v2;
  void (*v3)(uint64_t);
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  if (a1)
  {
    if (*(_BYTE *)(a1 + 48))
    {
      v2 = *(_QWORD *)(a1 + 24);
      v3 = *(void (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
      if (v3)
        v3(v2);
    }
    v4 = *(const void **)(a1 + 56);
    if (v4)
    {
      CFRelease(v4);
      *(_QWORD *)(a1 + 56) = 0;
    }
    v5 = *(const void **)(a1 + 40);
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)(a1 + 40) = 0;
    }
    v6 = *(const void **)(a1 + 24);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(a1 + 24) = 0;
    }
    v7 = *(const void **)(a1 + 64);
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(a1 + 64) = 0;
    }
    v8 = *(const void **)(a1 + 72);
    if (v8)
    {
      CFRelease(v8);
      *(_QWORD *)(a1 + 72) = 0;
    }
  }
}

CFStringRef DataQueueServerState_copyDebugDesc(uint64_t a1)
{
  const __CFAllocator *v2;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (a1)
    return CFStringCreateWithFormat(v2, 0, CFSTR("[DataQueueServerState %p] dataQueue:%p dataQueueObjectID:%llu"), a1, *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
  else
    return CFStringCreateWithFormat(v2, 0, CFSTR("[DataQueueServerState %p]"), 0);
}

uint64_t FigAssetCacheInspectorCreate_Streaming(const void *a1, CFTypeRef cf, CFTypeRef *a3)
{
  CFTypeID v6;
  uint64_t v7;
  uint64_t DerivedStorage;
  dispatch_queue_t v9;
  CFTypeRef v10;
  BOOL v11;
  uint64_t v12;
  uint64_t CMBaseObject;
  uint64_t (*v14)(uint64_t, const __CFString *, uint64_t, uint64_t);
  uint64_t v15;

  if (!cf)
    return FigSignalErrorAt();
  v6 = CFGetTypeID(cf);
  if (v6 != FigAssetGetTypeID() || !a3)
    return FigSignalErrorAt();
  FigAssetCacheInspectorGetClassID();
  v7 = CMDerivedObjectCreate();
  if ((_DWORD)v7)
    return v7;
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v9 = dispatch_queue_create("com.apple.coremedia.streamingcacheinspector.statequeue", 0);
  *(_QWORD *)DerivedStorage = v9;
  if (!v9)
    return FigSignalErrorAt();
  if (a1)
    v10 = CFRetain(a1);
  else
    v10 = 0;
  *(_QWORD *)(DerivedStorage + 16) = v10;
  *(_QWORD *)(DerivedStorage + 24) = CFRetain(cf);
  if (FigIsItOKToLogURLs())
    v11 = FPSupport_GetAssetDoNotLogURLs((uint64_t)cf) == 0;
  else
    v11 = 0;
  *(_BYTE *)(DerivedStorage + 73) = v11;
  v12 = *(_QWORD *)(DerivedStorage + 16);
  CMBaseObject = FigAssetGetCMBaseObject(cf);
  v14 = *(uint64_t (**)(uint64_t, const __CFString *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                + 48);
  if (!v14)
    return 4294954514;
  v7 = v14(CMBaseObject, CFSTR("assetProperty_CreationURL"), v12, DerivedStorage + 32);
  if ((_DWORD)v7)
    return v7;
  if (!*(_QWORD *)(DerivedStorage + 32))
    return FigSignalErrorAt();
  CMBaseObjectGetDerivedStorage();
  CMNotificationCenterGetDefaultLocalCenter();
  v7 = FigNotificationCenterAddWeakListener();
  if ((_DWORD)v7)
    return v7;
  v15 = sci_copyCacheURL(DerivedStorage, (_QWORD *)(DerivedStorage + 40));
  if (!(_DWORD)v15)
    *a3 = CFRetain(0);
  return v15;
}

uint64_t sci_copyCacheURL(uint64_t a1, _QWORD *a2)
{
  CFTypeRef v4;
  uint64_t v5;
  CFTypeRef v6;
  CFTypeRef cf;

  cf = 0;
  if (FigCFURLIsLocalResource())
  {
    v4 = *(CFTypeRef *)(a1 + 32);
    if (v4)
      v4 = CFRetain(v4);
    cf = v4;
    goto LABEL_6;
  }
  v5 = FigAssetDownloadCoordinatorCopyDestinationURLForAsset(*(_QWORD *)(a1 + 24), &cf);
  v4 = cf;
  if (!(_DWORD)v5)
  {
LABEL_6:
    if (v4)
    {
      v6 = CFRetain(v4);
      v4 = cf;
    }
    else
    {
      v6 = 0;
    }
    v5 = 0;
    *a2 = v6;
  }
  if (v4)
    CFRelease(v4);
  return v5;
}

uint64_t sci_invalidate(uint64_t a1)
{
  _QWORD context[2];
  uint64_t v4;

  v4 = 0;
  context[0] = CMBaseObjectGetDerivedStorage();
  context[1] = a1;
  dispatch_sync_f(*(dispatch_queue_t *)context[0], context, (dispatch_function_t)sci_invalidateDispatch);
  return v4;
}

void sci_finalize(uint64_t a1)
{
  dispatch_object_t *DerivedStorage;
  void (*v3)(uint64_t);

  DerivedStorage = (dispatch_object_t *)CMBaseObjectGetDerivedStorage();
  if (a1)
  {
    v3 = *(void (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 24);
    if (v3)
      v3(a1);
  }
  if (*DerivedStorage)
  {
    dispatch_release(*DerivedStorage);
    *DerivedStorage = 0;
  }
}

uint64_t sci_copyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  dispatch_queue_t *DerivedStorage;
  _QWORD v8[3];
  uint64_t v9;

  v9 = 0;
  DerivedStorage = (dispatch_queue_t *)CMBaseObjectGetDerivedStorage();
  if (!a4)
    return FigSignalErrorAt();
  v8[0] = DerivedStorage;
  v8[1] = a2;
  v8[2] = a4;
  dispatch_sync_f(*DerivedStorage, v8, (dispatch_function_t)sci_copyPropertyDispatch);
  return v9;
}

void sci_invalidateDispatch(uint64_t *a1)
{
  uint64_t v1;
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  if (a1)
  {
    v1 = *a1;
    if (*a1)
    {
      if (!*(_BYTE *)(v1 + 8))
      {
        *(_BYTE *)(v1 + 8) = 1;
        CMBaseObjectGetDerivedStorage();
        CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterRemoveWeakListener();
        v2 = *(const void **)(v1 + 16);
        if (v2)
        {
          CFRelease(v2);
          *(_QWORD *)(v1 + 16) = 0;
        }
        v3 = *(const void **)(v1 + 24);
        if (v3)
        {
          CFRelease(v3);
          *(_QWORD *)(v1 + 24) = 0;
        }
        v4 = *(const void **)(v1 + 32);
        if (v4)
        {
          CFRelease(v4);
          *(_QWORD *)(v1 + 32) = 0;
        }
        v5 = *(const void **)(v1 + 40);
        if (v5)
        {
          CFRelease(v5);
          *(_QWORD *)(v1 + 40) = 0;
        }
        v6 = *(const void **)(v1 + 48);
        if (v6)
        {
          CFRelease(v6);
          *(_QWORD *)(v1 + 48) = 0;
        }
        v7 = *(const void **)(v1 + 56);
        if (v7)
        {
          CFRelease(v7);
          *(_QWORD *)(v1 + 56) = 0;
        }
        v8 = *(const void **)(v1 + 64);
        if (v8)
        {
          CFRelease(v8);
          *(_QWORD *)(v1 + 64) = 0;
        }
      }
    }
  }
}

uint64_t sci_assetBecameReadyForDownload()
{
  uint64_t result;

  result = CMBaseObjectGetDerivedStorage();
  if (!*(_BYTE *)(result + 8) && !*(_QWORD *)(result + 40))
    return sci_copyCacheURL(result, (_QWORD *)(result + 40));
  return result;
}

void sci_copyPropertyDispatch(uint64_t a1)
{
  uint64_t v2;
  CFTypeRef v3;
  _QWORD *v4;
  int v5;
  int isPlayableOffline;
  _QWORD *v7;
  CFTypeRef cf;
  char v9;

  if (!a1)
    return;
  v2 = *(_QWORD *)a1;
  if (!*(_QWORD *)a1 || *(_BYTE *)(v2 + 8))
    return;
  if (CFEqual(CFSTR("AssetCacheInspectorProperty_CacheURL"), *(CFTypeRef *)(a1 + 8)))
  {
    v3 = *(CFTypeRef *)(v2 + 40);
    if (v3)
      v3 = CFRetain(v3);
    **(_QWORD **)(a1 + 16) = v3;
    return;
  }
  if (!CFEqual(CFSTR("AssetCacheInspectorProperty_PlayableOffline"), *(CFTypeRef *)(a1 + 8)))
    return;
  v4 = *(_QWORD **)(a1 + 16);
  v9 = 0;
  cf = 0;
  if (*(_BYTE *)(v2 + 72))
    goto LABEL_14;
  if (!*(_QWORD *)(v2 + 40))
  {
LABEL_15:
    v7 = (_QWORD *)MEMORY[0x1E0C9AE40];
    goto LABEL_16;
  }
  v5 = sci_createAndOpenHLSPersistentStore(v2, &cf);
  if (v5)
  {
    isPlayableOffline = v5;
    goto LABEL_17;
  }
  isPlayableOffline = sci_isPlayableOffline(v2, (uint64_t)cf, &v9);
  if (!isPlayableOffline)
  {
    if (v9)
    {
LABEL_14:
      v7 = (_QWORD *)MEMORY[0x1E0C9AE50];
LABEL_16:
      isPlayableOffline = 0;
      *v4 = *v7;
      goto LABEL_17;
    }
    goto LABEL_15;
  }
LABEL_17:
  if (cf)
    CFRelease(cf);
  *(_DWORD *)(a1 + 24) = isPlayableOffline;
}

uint64_t sci_createAndOpenHLSPersistentStore(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
    return FigHLSPersistentStoreCreateAtURL(*(const void **)(a1 + 16), v3, 0, 0, a2);
  else
    return FigSignalErrorAt();
}

uint64_t sci_isPlayableOffline(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v5;
  uint64_t v7;
  __CFArray *Mutable;
  CFMutableArrayRef v9;
  __CFArray *v10;
  CFIndex i;
  const __CFArray *Count;
  const void *ValueAtIndex;
  const __CFURL *PlaylistAlternateURL;
  uint64_t StableStreamIdentifier;
  const void *v16;
  CFTypeRef v17;
  const __CFArray *v18;
  const __CFArray *v19;
  uint64_t v20;
  __CFArray *v21;
  uint64_t v22;
  char v24;

  v24 = 0;
  if (*(_BYTE *)(a1 + 72))
  {
    v18 = 0;
    v19 = 0;
    LOBYTE(v5) = 1;
    goto LABEL_26;
  }
  v5 = *(_QWORD *)(a1 + 40);
  if (!v5)
  {
    v18 = 0;
    v19 = 0;
    goto LABEL_26;
  }
  v7 = sci_ensureAlternateArrayAndMediaSelectionArray(a1, a2);
  if ((_DWORD)v7)
    return v7;
  if (*(_QWORD *)(a1 + 56))
  {
    Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(a1 + 16), 0, MEMORY[0x1E0C9B378]);
    if (Mutable)
    {
      v9 = CFArrayCreateMutable(*(CFAllocatorRef *)(a1 + 16), 0, MEMORY[0x1E0C9B378]);
      if (v9)
      {
        v10 = v9;
        for (i = 0; ; ++i)
        {
          Count = *(const __CFArray **)(a1 + 56);
          if (Count)
            Count = (const __CFArray *)CFArrayGetCount(Count);
          if (i >= (uint64_t)Count)
            break;
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), i);
          PlaylistAlternateURL = (const __CFURL *)FigAlternateGetPlaylistAlternateURL((uint64_t)ValueAtIndex);
          StableStreamIdentifier = FigAlternateGetStableStreamIdentifier((uint64_t)ValueAtIndex);
          if (PlaylistAlternateURL)
          {
            v16 = (const void *)StableStreamIdentifier;
            v17 = FigCFHTTPCreateURLString(PlaylistAlternateURL);
            CFArrayAppendValue(Mutable, v17);
            if (v17)
              CFRelease(v17);
            if (v16)
              CFArrayAppendValue(v10, v16);
          }
        }
        CFArrayAppendValue(Mutable, *(const void **)(a1 + 48));
        goto LABEL_18;
      }
    }
  }
  else
  {
    Mutable = 0;
  }
  v20 = FigSignalErrorAt();
  v10 = 0;
  v18 = 0;
  v19 = 0;
  v21 = 0;
  if (!(_DWORD)v20)
  {
LABEL_18:
    v18 = (const __CFArray *)CFRetain(Mutable);
    v19 = (const __CFArray *)CFRetain(v10);
    v20 = 0;
    v21 = v10;
  }
  if (Mutable)
    CFRelease(Mutable);
  if (v21)
    CFRelease(v21);
  if ((_DWORD)v20)
  {
LABEL_27:
    if (!v18)
      goto LABEL_29;
    goto LABEL_28;
  }
  v22 = sci_areAnyNetworkURLsOrStreamIDsCompletelyCached(a2, v18, v19, &v24);
  if (!(_DWORD)v22)
  {
    LOBYTE(v5) = v24;
    *(_BYTE *)(a1 + 72) = v24;
LABEL_26:
    v20 = 0;
    *a3 = v5;
    goto LABEL_27;
  }
  v20 = v22;
  if (v18)
LABEL_28:
    CFRelease(v18);
LABEL_29:
  if (v19)
    CFRelease(v19);
  return v20;
}

uint64_t sci_ensureAlternateArrayAndMediaSelectionArray(uint64_t a1, uint64_t a2)
{
  uint64_t (*v4)(uint64_t, const __CFString *, CFTypeRef *, _QWORD, CFTypeRef *, OpaqueCMBlockBuffer **);
  uint64_t v5;
  uint64_t v6;
  uint64_t FigBaseObject;
  uint64_t (*v8)(uint64_t, const __CFString *, uint64_t, uint64_t);
  CFStringRef *v9;
  const __CFURL *v10;
  const __CFURL *v11;
  uint64_t v12;
  const void *MediaSelectionArray;
  uint64_t v14;
  CFArrayRef v15;
  const void *Alternates;
  CFArrayRef v17;
  CFTypeRef cf;
  int v20;
  OpaqueCMBlockBuffer *v21;
  CFTypeRef v22;
  CFTypeRef v23;

  v22 = 0;
  v23 = 0;
  v21 = 0;
  v20 = 0;
  cf = 0;
  if (*(_QWORD *)(a1 + 64) || *(_QWORD *)(a1 + 56))
  {
    v14 = 0;
    goto LABEL_21;
  }
  v4 = *(uint64_t (**)(uint64_t, const __CFString *, CFTypeRef *, _QWORD, CFTypeRef *, OpaqueCMBlockBuffer **))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 48);
  if (!v4)
    goto LABEL_13;
  v5 = v4(a2, CFSTR("NetworkPlaylist"), &v23, 0, &v22, &v21);
  if (!(_DWORD)v5)
  {
    v6 = *(_QWORD *)(a1 + 16);
    FigBaseObject = FigHLSPersistentStoreGetFigBaseObject(a2);
    v8 = *(uint64_t (**)(uint64_t, const __CFString *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                             + 8)
                                                                                 + 48);
    if (v8)
    {
      v9 = (CFStringRef *)(a1 + 48);
      v5 = v8(FigBaseObject, CFSTR("MasterPlaylistNetworkURL"), v6, a1 + 48);
      if (!(_DWORD)v5)
      {
        if (*v9)
        {
          v10 = CFURLCreateWithString(*(CFAllocatorRef *)(a1 + 16), *v9, 0);
          if (v10)
          {
            v11 = v10;
            v12 = FigStreamPlaylistParse(v21, v10, 0, &v20, 0, 0, 1, *(unsigned __int8 *)(a1 + 73), 0, 0, 0, 0, (uint64_t *)&cf, 0);
            if ((_DWORD)v12)
            {
LABEL_32:
              v14 = v12;
              goto LABEL_20;
            }
            if (cf && FigMultivariantPlaylistGetMediaSelectionArray((uint64_t)cf))
            {
              MediaSelectionArray = (const void *)FigMultivariantPlaylistGetMediaSelectionArray((uint64_t)cf);
              *(_QWORD *)(a1 + 64) = CFRetain(MediaSelectionArray);
            }
            else
            {
              v15 = CFArrayCreate(*(CFAllocatorRef *)(a1 + 16), 0, 0, MEMORY[0x1E0C9B378]);
              *(_QWORD *)(a1 + 64) = v15;
              if (!v15)
              {
LABEL_31:
                v12 = FigSignalErrorAt();
                goto LABEL_32;
              }
            }
            if (cf && FigMultivariantPlaylistGetAlternates((uint64_t)cf))
            {
              Alternates = (const void *)FigMultivariantPlaylistGetAlternates((uint64_t)cf);
              v14 = 0;
              *(_QWORD *)(a1 + 56) = CFRetain(Alternates);
LABEL_20:
              CFRelease(v11);
              goto LABEL_21;
            }
            v17 = CFArrayCreate(*(CFAllocatorRef *)(a1 + 16), 0, 0, MEMORY[0x1E0C9B378]);
            *(_QWORD *)(a1 + 56) = v17;
            if (v17)
            {
              v14 = 0;
              goto LABEL_20;
            }
            goto LABEL_31;
          }
        }
        v5 = FigSignalErrorAt();
      }
      goto LABEL_34;
    }
LABEL_13:
    v14 = 4294954514;
    goto LABEL_21;
  }
LABEL_34:
  v14 = v5;
LABEL_21:
  if (v23)
    CFRelease(v23);
  if (v22)
    CFRelease(v22);
  if (v21)
    CFRelease(v21);
  if (cf)
    CFRelease(cf);
  return v14;
}

uint64_t sci_areAnyNetworkURLsOrStreamIDsCompletelyCached(uint64_t a1, const __CFArray *a2, const __CFArray *a3, _BYTE *a4)
{
  uint64_t (*v8)(uint64_t, CFArrayRef *);
  uint64_t v9;
  CFIndex i;
  CFIndex Count;
  const void *ValueAtIndex;
  uint64_t (*v13)(uint64_t, const void *, CFTypeRef *);
  const void *v14;
  CFRange v15;
  uint64_t (*v16)(uint64_t, const void *, void **);
  const __CFArray *v17;
  uint64_t (*v18)(uint64_t, const void *, char *);
  char v19;
  uint64_t v20;
  CFTypeRef cf;
  void *value;
  CFArrayRef theArray;
  char v25;

  v25 = 0;
  value = 0;
  theArray = 0;
  cf = 0;
  v8 = *(uint64_t (**)(uint64_t, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
  if (!v8)
  {
LABEL_30:
    v20 = 4294954514;
    goto LABEL_33;
  }
  v9 = v8(a1, &theArray);
  if ((_DWORD)v9)
  {
LABEL_40:
    v20 = v9;
    goto LABEL_33;
  }
  for (i = 0; ; ++i)
  {
    Count = (CFIndex)theArray;
    if (theArray)
      Count = CFArrayGetCount(theArray);
    if (i >= Count)
      break;
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
    v13 = *(uint64_t (**)(uint64_t, const void *, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 80);
    if (!v13)
      goto LABEL_30;
    v9 = v13(a1, ValueAtIndex, &cf);
    if ((_DWORD)v9)
      goto LABEL_40;
    v14 = cf;
    if (cf)
    {
      if (a3)
      {
        v15.length = CFArrayGetCount(a3);
        v14 = cf;
      }
      else
      {
        v15.length = 0;
      }
      v17 = a3;
    }
    else
    {
      v16 = *(uint64_t (**)(uint64_t, const void *, void **))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 72);
      if (!v16)
        goto LABEL_30;
      v9 = v16(a1, ValueAtIndex, &value);
      if ((_DWORD)v9)
        goto LABEL_40;
      v14 = value;
      if (!value)
        goto LABEL_24;
      if (a2)
      {
        v15.length = CFArrayGetCount(a2);
        v14 = value;
      }
      else
      {
        v15.length = 0;
      }
      v17 = a2;
    }
    v15.location = 0;
    if (CFArrayContainsValue(v17, v15, v14))
    {
      v18 = *(uint64_t (**)(uint64_t, const void *, char *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 64);
      if (!v18)
        goto LABEL_30;
      v9 = v18(a1, ValueAtIndex, &v25);
      if ((_DWORD)v9)
        goto LABEL_40;
    }
LABEL_24:
    v19 = v25;
    if (v25)
      goto LABEL_32;
    if (value)
    {
      CFRelease(value);
      value = 0;
    }
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
  }
  v19 = v25;
LABEL_32:
  v20 = 0;
  *a4 = v19;
LABEL_33:
  if (theArray)
    CFRelease(theArray);
  if (cf)
    CFRelease(cf);
  if (value)
    CFRelease(value);
  return v20;
}

uint64_t sci_copyCompletelyCachedMediaSelectionOptionsInGroup(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage;
  dispatch_queue_t *v7;
  CFTypeID v8;
  dispatch_queue_t *context;
  __int128 v11;
  __int128 v12;

  v11 = 0u;
  v12 = 0u;
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a2)
    return FigSignalErrorAt();
  v7 = (dispatch_queue_t *)DerivedStorage;
  v8 = CFGetTypeID(a2);
  if (v8 != CFDictionaryGetTypeID() || !a4)
    return FigSignalErrorAt();
  context = v7;
  *((_QWORD *)&v11 + 1) = a2;
  *(_QWORD *)&v12 = a4;
  dispatch_sync_f(*v7, &context, (dispatch_function_t)sci_copyCompletelyCachedMediaSelectionOptionsInGroupDispatch);
  return DWORD2(v12);
}

void sci_copyCompletelyCachedMediaSelectionOptionsInGroupDispatch(uint64_t *a1)
{
  uint64_t *v1;
  const void *v2;
  uint64_t v3;
  CFTypeRef v4;
  CFMutableArrayRef Mutable;
  const __CFArray *v6;
  int v7;
  const __CFArray *Value;
  CFIndex v9;
  const CFArrayCallBacks *v10;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  CFTypeRef v13;
  int isPlayableOffline;
  const void *v15;
  const void *v16;
  __CFArray *v17;
  __CFArray *v18;
  CFIndex j;
  const __CFArray *Count;
  const void *v21;
  uint64_t v22;
  const __CFDictionary *MediaGroupLocatorMap;
  const __CFDictionary *v24;
  const __CFDictionary *v25;
  const __CFURL *PlaylistAlternateURL;
  uint64_t StableStreamIdentifier;
  const void *v28;
  CFTypeRef v29;
  const void *v30;
  int v31;
  const __CFArray *v32;
  const __CFArray *v33;
  char v34;
  BOOL v35;
  uint64_t *v36;
  __CFArray *theArray;
  const __CFArray *v38;
  uint64_t v39;
  const __CFDictionary *v40;
  CFIndex v41;
  CFTypeRef cf;
  char v43;
  __int16 v44;
  int v45;

  if (!a1)
    return;
  v1 = a1;
  v3 = *a1;
  v2 = (const void *)a1[1];
  if (v2)
    v4 = CFRetain(v2);
  else
    v4 = 0;
  cf = v4;
  if (!v3
    || *(_BYTE *)(v3 + 8)
    || (Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(v3 + 16), 0, MEMORY[0x1E0C9B378])) == 0)
  {
    v7 = FigSignalErrorAt();
    v6 = 0;
    goto LABEL_73;
  }
  v6 = Mutable;
  if (!*(_QWORD *)(v3 + 40))
  {
LABEL_67:
    *(_QWORD *)v1[3] = CFArrayCreateCopy(*(CFAllocatorRef *)(v3 + 16), v6);
    if (*(_QWORD *)v1[3])
      v7 = 0;
    else
      v7 = FigSignalErrorAt();
    goto LABEL_74;
  }
  if (!v4)
  {
    v7 = sci_createAndOpenHLSPersistentStore(v3, &cf);
    if (v7 || !cf)
    {
LABEL_73:
      if (v7)
        goto LABEL_74;
      goto LABEL_67;
    }
  }
  v36 = v1;
  theArray = v6;
  Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v1[2], CFSTR("MediaSelectionGroupOptions"));
  v9 = 0;
  v10 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  v38 = Value;
  if (!Value)
    goto LABEL_14;
LABEL_13:
  for (i = CFArrayGetCount(Value); ; i = 0)
  {
    if (v9 >= i)
    {
      v1 = v36;
      v6 = theArray;
      goto LABEL_67;
    }
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, v9);
    v13 = cf;
    v44 = 0;
    isPlayableOffline = sci_isPlayableOffline(v3, (uint64_t)cf, &v44);
    if (isPlayableOffline)
      break;
    if (!(_BYTE)v44)
      goto LABEL_62;
    isPlayableOffline = sci_ensureAlternateArrayAndMediaSelectionArray(v3, (uint64_t)v13);
    if (isPlayableOffline)
      break;
    v45 = 0;
    v40 = ValueAtIndex;
    v41 = v9;
    v39 = (uint64_t)v13;
    if (*(_QWORD *)(v3 + 56)
      && (CFDictionaryGetValue(ValueAtIndex, CFSTR("MediaSelectionOptionsMediaType")),
          FigCFStringGetOSTypeValue())
      && (v15 = CFDictionaryGetValue(ValueAtIndex, CFSTR("MediaSelectionOptionsPersistentID"))) != 0)
    {
      v16 = v15;
      v17 = CFArrayCreateMutable(*(CFAllocatorRef *)(v3 + 16), 0, v10);
      if (v17)
      {
        v18 = CFArrayCreateMutable(*(CFAllocatorRef *)(v3 + 16), 0, v10);
        if (v18)
        {
          if (v45 == 1935832172 || v45 == 1986618469 || v45 == 1936684398)
          {
            for (j = 0; ; ++j)
            {
              Count = *(const __CFArray **)(v3 + 56);
              if (Count)
                Count = (const __CFArray *)CFArrayGetCount(Count);
              if (j >= (uint64_t)Count)
                break;
              v21 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 56), j);
              if (!v21)
                goto LABEL_43;
              v22 = (uint64_t)v21;
              MediaGroupLocatorMap = (const __CFDictionary *)FigAlternateGetMediaGroupLocatorMap((uint64_t)v21, v45);
              if (!MediaGroupLocatorMap
                || (v24 = (const __CFDictionary *)CFDictionaryGetValue(MediaGroupLocatorMap, v16)) == 0
                || (v25 = v24,
                    PlaylistAlternateURL = (const __CFURL *)CFDictionaryGetValue(v24, CFSTR("FBPAEGLMK_URL")),
                    StableStreamIdentifier = (uint64_t)CFDictionaryGetValue(v25, CFSTR("FBPAEGLMK_StableStreamIdentifier")), !PlaylistAlternateURL))
              {
                PlaylistAlternateURL = (const __CFURL *)FigAlternateGetPlaylistAlternateURL(v22);
                StableStreamIdentifier = FigAlternateGetStableStreamIdentifier(v22);
                if (!PlaylistAlternateURL)
                  continue;
              }
              v28 = (const void *)StableStreamIdentifier;
              v29 = FigCFHTTPCreateURLString(PlaylistAlternateURL);
              if (!v29)
                goto LABEL_43;
              v30 = v29;
              CFArrayAppendValue(v17, v29);
              CFRelease(v30);
              if (v28)
                CFArrayAppendValue(v18, v28);
            }
          }
LABEL_46:
          v32 = (const __CFArray *)CFRetain(v17);
          v33 = (const __CFArray *)CFRetain(v18);
          v7 = 0;
          if (!v17)
            goto LABEL_48;
LABEL_47:
          CFRelease(v17);
          goto LABEL_48;
        }
      }
      else
      {
        v18 = 0;
      }
    }
    else
    {
      v17 = 0;
      v18 = 0;
    }
LABEL_43:
    v31 = FigSignalErrorAt();
    if (!v31)
      goto LABEL_46;
    v7 = v31;
    v32 = 0;
    v33 = 0;
    if (v17)
      goto LABEL_47;
LABEL_48:
    if (v18)
      CFRelease(v18);
    if (v7 || (v7 = sci_areAnyNetworkURLsOrStreamIDsCompletelyCached(v39, v32, v33, (_BYTE *)&v44 + 1)) != 0)
    {
      v34 = 0;
      if (!v32)
        goto LABEL_57;
    }
    else
    {
      v43 = 0;
      FigCFDictionaryGetBooleanIfPresent();
      if (v43)
        v34 = 1;
      else
        v34 = HIBYTE(v44);
      if (!v32)
        goto LABEL_57;
    }
    CFRelease(v32);
LABEL_57:
    if (v33)
      CFRelease(v33);
    if (v7)
      goto LABEL_71;
    v35 = v34 == 0;
    Value = v38;
    v9 = v41;
    v10 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    if (!v35)
      CFArrayAppendValue(theArray, v40);
LABEL_62:
    ++v9;
    if (Value)
      goto LABEL_13;
LABEL_14:
    ;
  }
  v7 = isPlayableOffline;
LABEL_71:
  v1 = v36;
  v6 = theArray;
LABEL_74:
  if (v6)
    CFRelease(v6);
  if (cf)
    CFRelease(cf);
  *((_DWORD *)v1 + 8) = v7;
}

uint64_t FigConvertCSSStyleSheetDataToTextMarkup(const __CFAllocator *a1, const __CFData *a2, __CFArray **a3, _QWORD *a4)
{
  const __CFAllocator *v6;
  uint64_t v7;
  CFIndex Length;
  CFIndex v9;
  CFIndex v10;
  __CFArray *v11;
  __CFDictionary *v12;
  uint64_t v13;
  __CFDictionary *Mutable;
  CFIndex v15;
  __CFString *MutableCopy;
  __CFString *v17;
  CFIndex v18;
  CFIndex v19;
  CFIndex v20;
  CFMutableStringRef v21;
  uint64_t v22;
  CFStringRef v23;
  CFTypeID v24;
  CFTypeID TypeID;
  CFIndex v26;
  const __CFString *v27;
  const __CFString *v28;
  const void *v29;
  __CFArray *v30;
  int v31;
  uint64_t v32;
  CFComparisonResult v33;
  CFComparisonResult v34;
  CFComparisonResult v35;
  CFIndex v36;
  int v37;
  __CFString *v38;
  CFComparisonResult v39;
  CFComparisonResult v40;
  CFComparisonResult v41;
  CFComparisonResult v42;
  CFComparisonResult v43;
  CFComparisonResult v44;
  CFComparisonResult v45;
  CFComparisonResult v46;
  CFComparisonResult v47;
  const __CFAllocator *v48;
  __CFString *v49;
  CFIndex v50;
  int v51;
  uint64_t v52;
  const void *Value;
  uint64_t v54;
  const void *v56;
  const void *v57;
  const void *v58;
  const void *v59;
  __CFArray *v60;
  __CFArray *v61;
  __CFArray *v62;
  const void *v63;
  __CFArray *v64;
  __CFArray *v65;
  __CFArray **v66;
  _QWORD *v67;
  const __CFAllocator *allocator;
  const void *v69;
  const void *v70;
  __CFArray *v71;
  const void *v72;
  CFIndex v73;
  const void *v74;
  __CFArray *v75;
  void *key;
  void *v77;
  const void *v78;
  __CFArray *v79;
  __CFArray *v80;
  const __CFAllocator *alloc;
  int v82;
  CFTypeRef v83;
  void *v84;
  CFTypeRef v85;
  uint64_t *v86;
  const void *v87;
  CFStringRef v88;
  const __CFString *v89;
  CFTypeRef v90;
  CFStringRef v91;
  __CFArray *v92;
  int valuePtr;
  _OWORD v94[2];
  CFRange v95;
  CFRange v96;

  v86 = 0;
  v87 = 0;
  v84 = 0;
  v85 = 0;
  v83 = 0;
  if (!a2)
  {
    v54 = FigSignalErrorAt();
    goto LABEL_148;
  }
  if (!a3)
  {
    v7 = FigSignalErrorAt();
LABEL_160:
    v54 = v7;
    goto LABEL_146;
  }
  v6 = a1;
  v7 = FigTextContainerCreateWithCFData(a1, a2, 0x8000100u, 0, (uint64_t *)&v87);
  if ((_DWORD)v7)
    goto LABEL_160;
  v7 = FigCSSParserCreate((uint64_t)v6, v87, 0, &v86);
  if ((_DWORD)v7)
    goto LABEL_160;
  v7 = FigCSSParserProduceStyleSheet((uint64_t)v86, &v85);
  if ((_DWORD)v7)
    goto LABEL_160;
  v7 = FigCSSStyleSheetCopyRuleList((uint64_t)v85, &v83);
  if ((_DWORD)v7)
    goto LABEL_160;
  v66 = a3;
  v67 = a4;
  Length = FigCSSRuleListGetLength((uint64_t)v83);
  if (Length < 1)
  {
    v12 = 0;
    v54 = 0;
    v11 = 0;
LABEL_142:
    *v66 = v11;
    if (v67)
      *v67 = 0;
    if (v12)
      goto LABEL_145;
    goto LABEL_146;
  }
  v9 = Length;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  key = (void *)*MEMORY[0x1E0CA2C30];
  v58 = (const void *)*MEMORY[0x1E0CA2A28];
  v56 = (const void *)*MEMORY[0x1E0CA2A00];
  v75 = (__CFArray *)*MEMORY[0x1E0C9AE50];
  v79 = (__CFArray *)*MEMORY[0x1E0C9AE40];
  v59 = (const void *)*MEMORY[0x1E0CA2968];
  v60 = (__CFArray *)*MEMORY[0x1E0CA2CF0];
  v61 = (__CFArray *)*MEMORY[0x1E0CA2CE8];
  v62 = (__CFArray *)*MEMORY[0x1E0CA2CE0];
  v63 = (const void *)*MEMORY[0x1E0CA2B38];
  v72 = (const void *)*MEMORY[0x1E0CA2AF0];
  v64 = (__CFArray *)*MEMORY[0x1E0CA2D10];
  v65 = (__CFArray *)*MEMORY[0x1E0CA2D18];
  v70 = (const void *)*MEMORY[0x1E0CA2AE0];
  v71 = (__CFArray *)*MEMORY[0x1E0CA2D20];
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v69 = (const void *)*MEMORY[0x1E0CA2A38];
  v74 = (const void *)*MEMORY[0x1E0CA2A50];
  v77 = (void *)*MEMORY[0x1E0CA2A20];
  v78 = (const void *)*MEMORY[0x1E0CA2978];
  v57 = (const void *)*MEMORY[0x1E0CA2AD0];
  alloc = v6;
  v73 = Length;
  while (1)
  {
    v82 = 0;
    v13 = FigCSSRuleListCopyRuleAtIndex((uint64_t)v83, v10, (CFTypeRef *)&v84, &v82);
    if (v82 == 1)
      break;
    v54 = v13;
LABEL_130:
    if (v84)
    {
      CFRelease(v84);
      v84 = 0;
    }
    if (++v10 == v9)
      goto LABEL_142;
  }
  if (v12)
    CFRelease(v12);
  v12 = (__CFDictionary *)v84;
  v90 = 0;
  v91 = 0;
  v88 = 0;
  v89 = 0;
  if (!v84)
  {
    FigSignalErrorAt();
    Mutable = 0;
LABEL_137:
    v17 = 0;
    goto LABEL_140;
  }
  Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
  {
    FigSignalErrorAt();
LABEL_136:
    v12 = 0;
    goto LABEL_137;
  }
  if (FigCSSStyleRuleCopySelector((uint64_t)v12, &v91) || !v91)
    goto LABEL_136;
  v15 = CFStringGetLength(v91);
  MutableCopy = CFStringCreateMutableCopy(v6, v15, v91);
  v17 = MutableCopy;
  if (!MutableCopy)
  {
    FigSignalErrorAt();
LABEL_139:
    v12 = 0;
LABEL_140:
    v21 = 0;
    goto LABEL_111;
  }
  CFStringTrimWhitespace(MutableCopy);
  CFDictionarySetValue(Mutable, key, v17);
  if (FigCSSStyleRuleCopyDeclaration((uint64_t)v12, &v90))
    goto LABEL_139;
  v18 = FigCSSRuleListGetLength((uint64_t)v90);
  if (v18 < 1)
  {
    v21 = 0;
    goto LABEL_110;
  }
  v19 = v18;
  v80 = v11;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  do
  {
    if (v89)
    {
      CFRelease(v89);
      v89 = 0;
    }
    if (v88)
    {
      CFRelease(v88);
      v88 = 0;
    }
    if (v21)
      CFRelease(v21);
    if (FigCSSStyleDeclarationCopyPropertyNameAtIndex((uint64_t)v90, v20, &v89)
      || FigCSSStyleDeclarationCopyPropertyValue((uint64_t)v90, v89, &v88))
    {
      v21 = 0;
      goto LABEL_29;
    }
    v23 = v88;
    if (v88 && (v24 = CFGetTypeID(v88), TypeID = CFStringGetTypeID(), v23 = v88, v24 == TypeID))
    {
      v26 = CFStringGetLength(v88);
      v21 = CFStringCreateMutableCopy(alloc, v26, v88);
      CFStringTrimWhitespace(v21);
      v23 = v88;
    }
    else
    {
      v21 = 0;
    }
    v27 = v89;
    if (v21)
      v28 = v21;
    else
      v28 = v23;
    v92 = 0;
    if (CFStringCompare(CFSTR("color"), v89, 1uLL) == kCFCompareEqualTo)
    {
      if (FigCSSParserUtilitiesParseColor(alloc, v28, &v92))
        goto LABEL_95;
      v30 = v92;
      v29 = v77;
      goto LABEL_55;
    }
    if (CFStringCompare(CFSTR("font-weight"), v27, 1uLL) == kCFCompareEqualTo)
    {
      v33 = CFStringCompare(CFSTR("normal"), v28, 1uLL);
      v29 = v78;
      v30 = v79;
      if (v33 == kCFCompareEqualTo)
        goto LABEL_55;
      v34 = CFStringCompare(CFSTR("bold"), v28, 1uLL);
      v29 = v78;
      goto LABEL_62;
    }
    if (CFStringCompare(CFSTR("font-style"), v27, 1uLL) == kCFCompareEqualTo)
    {
      v35 = CFStringCompare(CFSTR("normal"), v28, 1uLL);
      v29 = v74;
      v30 = v79;
      if (v35 == kCFCompareEqualTo)
        goto LABEL_55;
      v34 = CFStringCompare(CFSTR("italic"), v28, 1uLL);
      v29 = v74;
      goto LABEL_62;
    }
    if (CFStringCompare(CFSTR("text-combine-upright"), v27, 1uLL) == kCFCompareEqualTo)
    {
      if (CFStringCompare(v28, CFSTR("none"), 1uLL) == kCFCompareEqualTo)
        goto LABEL_95;
      if (CFStringCompare(v28, CFSTR("all"), 1uLL) == kCFCompareEqualTo
        || CFStringCompare(v28, CFSTR("digits"), 1uLL) == kCFCompareEqualTo)
      {
        LODWORD(v94[0]) = -1;
        v30 = CFNumberCreate(allocator, kCFNumberSInt32Type, v94);
        v29 = v69;
        goto LABEL_55;
      }
      LODWORD(v94[0]) = 1;
      v36 = CFStringGetLength(CFSTR("digits"));
      v96.location = 0;
      v96.length = v36;
      if (CFStringCompareWithOptions(v28, CFSTR("digits"), v96, 1uLL))
      {
        v37 = FigCSSParseDigitsAsUInt32(v28, v94);
        v38 = 0;
        if (!v37)
        {
LABEL_69:
          valuePtr = v94[0];
          v30 = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
          v31 = 0;
          if (!v38)
            goto LABEL_91;
          goto LABEL_90;
        }
      }
      else
      {
        v48 = CFGetAllocator(v28);
        v49 = CFStringCreateMutableCopy(v48, 0, v28);
        v38 = v49;
        if (v49)
        {
          v95.location = 0;
          v95.length = v36;
          CFStringReplace(v49, v95, &stru_1E2FD85F8);
          v50 = CFStringGetLength(v38);
          CFStringTrimWhitespace(v38);
          if (v50 > CFStringGetLength(v38))
          {
            v51 = FigCSSParseDigitsAsUInt32(v38, v94);
            if (v51)
            {
              v31 = v51;
              v30 = 0;
              goto LABEL_90;
            }
            goto LABEL_69;
          }
        }
        v37 = FigSignalErrorAt();
      }
      v31 = v37;
      v30 = 0;
      if (!v38)
      {
LABEL_91:
        v29 = v69;
        if (v31)
          goto LABEL_92;
        goto LABEL_55;
      }
LABEL_90:
      CFRelease(v38);
      goto LABEL_91;
    }
    if (CFStringCompare(CFSTR("ruby-position"), v27, 1uLL))
    {
      if (CFStringCompare(CFSTR("ruby-align"), v27, 1uLL))
      {
        if (CFStringCompare(CFSTR("offset"), v27, 1uLL) == kCFCompareEqualTo)
          goto LABEL_95;
        if (CFStringCompare(CFSTR("text-decoration"), v27, 1uLL))
        {
          if (CFStringCompare(CFSTR("background-color"), v27, 1uLL))
          {
            if (CFStringCompare(CFSTR("font-family"), v27, 1uLL))
            {
              if (CFStringCompare(CFSTR("font-size"), v27, 1uLL))
                goto LABEL_95;
              v94[0] = *MEMORY[0x1E0CA4AC8];
              if (FigCSSParseFontSize(v28, (uint64_t *)v94))
                goto LABEL_95;
              v29 = 0;
              if ((BYTE12(v94[0]) & 0x1D) == 1)
              {
                v30 = 0;
                if (DWORD2(v94[0]) == 622862368)
                {
                  valuePtr = (int)*(double *)v94;
                  v30 = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
                  v29 = v57;
                }
              }
              else
              {
                v30 = 0;
              }
            }
            else
            {
              MEMORY[0x19402F294](&convertFontFamilyFromCSSToCMTextMarkup_once, initMapFromCSSToCMTextMarkupFontFamily);
              Value = CFDictionaryGetValue((CFDictionaryRef)sMapFromCSSToCMTextMarkupFontFamily, v28);
              if (Value)
              {
                v30 = (__CFArray *)CFRetain(Value);
                v29 = v58;
              }
              else
              {
                if (CFStringGetLength(v28) < 1)
                  goto LABEL_95;
                v30 = (__CFArray *)CFRetain(v28);
                v29 = v56;
              }
            }
          }
          else
          {
            if (FigCSSParserUtilitiesParseColor(alloc, v28, &v92))
              goto LABEL_95;
            v30 = v92;
            v29 = v59;
          }
          goto LABEL_55;
        }
        v47 = CFStringCompare(CFSTR("none"), v28, 1uLL);
        v29 = v63;
        v30 = v79;
        if (v47 == kCFCompareEqualTo)
          goto LABEL_55;
        v34 = CFStringCompare(CFSTR("underline"), v28, 1uLL);
        v29 = v63;
LABEL_62:
        v30 = v75;
        if (v34)
          goto LABEL_95;
        goto LABEL_55;
      }
      v43 = CFStringCompare(CFSTR("start"), v28, 1uLL);
      v29 = v70;
      v30 = v64;
      if (v43)
      {
        v44 = CFStringCompare(CFSTR("center"), v28, 1uLL);
        v29 = v70;
        v30 = v62;
        if (v44)
        {
          v45 = CFStringCompare(CFSTR("space-between"), v28, 1uLL);
          v29 = v70;
          v30 = v61;
          if (v45)
          {
            v46 = CFStringCompare(CFSTR("space-around"), v28, 1uLL);
            v29 = v70;
            v30 = v60;
            if (v46)
              goto LABEL_95;
          }
        }
      }
    }
    else
    {
      v39 = CFStringCompare(CFSTR("over"), v28, 1uLL);
      v30 = v71;
      v29 = v72;
      if (v39)
      {
        v40 = CFStringCompare(CFSTR("right"), v28, 1uLL);
        v30 = v71;
        v29 = v72;
        if (v40)
        {
          v41 = CFStringCompare(CFSTR("under"), v28, 1uLL);
          v29 = v72;
          v30 = v65;
          if (v41)
          {
            v42 = CFStringCompare(CFSTR("left"), v28, 1uLL);
            v29 = v72;
            v30 = v65;
            if (v42)
            {
LABEL_95:
              v52 = 0;
              goto LABEL_96;
            }
          }
        }
      }
    }
LABEL_55:
    v31 = 0;
    if (!v29 || !v30)
    {
LABEL_92:
      v32 = 0;
      v52 = 0;
      if (!v30)
        goto LABEL_94;
      goto LABEL_93;
    }
    CFDictionarySetValue(Mutable, v29, v30);
    v31 = 0;
    v32 = 1;
LABEL_93:
    CFRelease(v30);
    v52 = v32;
LABEL_94:
    if (v31)
      goto LABEL_95;
LABEL_96:
    v22 += v52;
LABEL_29:
    ++v20;
  }
  while (v19 != v20);
  if (v22)
  {
    v12 = Mutable;
    Mutable = 0;
    v11 = v80;
    v6 = alloc;
    v9 = v73;
    goto LABEL_111;
  }
  v11 = v80;
  v6 = alloc;
  v9 = v73;
LABEL_110:
  CFRelease(Mutable);
  v12 = 0;
  Mutable = 0;
LABEL_111:
  if (v89)
    CFRelease(v89);
  if (v88)
    CFRelease(v88);
  if (v21)
    CFRelease(v21);
  if (v91)
    CFRelease(v91);
  if (v17)
    CFRelease(v17);
  if (v90)
    CFRelease(v90);
  if (Mutable)
    CFRelease(Mutable);
  if (!v12)
  {
LABEL_129:
    v54 = 0;
    goto LABEL_130;
  }
  if (v11 || (v11 = CFArrayCreateMutable(v6, 0, MEMORY[0x1E0C9B378])) != 0)
  {
    CFArrayAppendValue(v11, v12);
    goto LABEL_129;
  }
  v54 = FigSignalErrorAt();
LABEL_145:
  CFRelease(v12);
LABEL_146:
  if (v83)
    CFRelease(v83);
LABEL_148:
  if (v84)
    CFRelease(v84);
  if (v85)
    CFRelease(v85);
  if (v86)
    CFRelease(v86);
  if (v87)
    CFRelease(v87);
  return v54;
}

uint64_t FigCSSParserUtilitiesParseColor(const __CFAllocator *a1, const __CFString *a2, __CFArray **a3)
{
  uint64_t v5;
  __CFArray *v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  const __CFAllocator *v11;
  __CFArray *Mutable;
  uint64_t v14;
  uint64_t valuePtr;

  v14 = 0;
  valuePtr = 0;
  *a3 = 0;
  v5 = FigCSSParseColor(a2, (float *)&valuePtr + 1, (float *)&valuePtr, (float *)&v14 + 1, (float *)&v14);
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ((_DWORD)v5)
  {
LABEL_4:
    *a3 = v6;
    if (!v10)
      goto LABEL_6;
    goto LABEL_5;
  }
  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)&valuePtr + 4);
  v8 = CFNumberCreate(v11, kCFNumberFloatType, &valuePtr);
  v9 = CFNumberCreate(v11, kCFNumberFloatType, (char *)&v14 + 4);
  v10 = CFNumberCreate(v11, kCFNumberFloatType, &v14);
  Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v6 = Mutable;
    CFArrayAppendValue(Mutable, v10);
    CFArrayAppendValue(v6, v7);
    CFArrayAppendValue(v6, v8);
    CFArrayAppendValue(v6, v9);
    goto LABEL_4;
  }
  v5 = FigSignalErrorAt();
  if (v10)
LABEL_5:
    CFRelease(v10);
LABEL_6:
  if (v7)
    CFRelease(v7);
  if (v8)
    CFRelease(v8);
  if (v9)
    CFRelease(v9);
  return v5;
}

void initMapFromCSSToCMTextMarkupFontFamily()
{
  __CFDictionary *Mutable;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionaryAddValue(Mutable, CFSTR("default"), (const void *)*MEMORY[0x1E0CA2BE0]);
  CFDictionaryAddValue(Mutable, CFSTR("serif"), (const void *)*MEMORY[0x1E0CA2C20]);
  CFDictionaryAddValue(Mutable, CFSTR("sans-serif"), (const void *)*MEMORY[0x1E0CA2C18]);
  CFDictionaryAddValue(Mutable, CFSTR("monospace"), (const void *)*MEMORY[0x1E0CA2BF0]);
  CFDictionaryAddValue(Mutable, CFSTR("cursive"), (const void *)*MEMORY[0x1E0CA2BD8]);
  CFDictionaryAddValue(Mutable, CFSTR("fantasy"), (const void *)*MEMORY[0x1E0CA2BE8]);
  sMapFromCSSToCMTextMarkupFontFamily = (uint64_t)Mutable;
}

uint64_t FigBufferedAirPlayAudioChainSubPipeTranscodeCreate(const __CFAllocator *a1, const void *a2, const void *a3, const void *a4, char a5, const void *a6, const __CFDictionary *a7, _QWORD *a8)
{
  const __CFAllocator *v13;
  uint64_t v14;
  uint64_t DerivedStorage;
  uint64_t v16;
  dispatch_queue_t v17;
  uint64_t v18;
  CMTimeEpoch epoch;
  CFDictionaryRef v20;
  __CFDictionary *MutableCopy;
  __CFDictionary *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const opaqueCMFormatDescription *v27;
  const opaqueCMFormatDescription *v28;
  NSObject *v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  CMAudioFormatDescriptionRef v33;
  NSObject *v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  const __CFDictionary *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t FigBaseObject;
  uint64_t (*v42)(uint64_t, const __CFString *, const __CFAllocator *, uint64_t);
  uint64_t v43;
  uint64_t v44;
  uint64_t (*v45)(uint64_t, uint64_t);
  uint64_t v46;
  const void *v47;
  int CFPreferenceNumberWithDefault;
  int v49;
  uint64_t RichestDecodableFormatAndChannelLayout;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int ChannelLayoutTag;
  int v55;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v57;
  unsigned int v58;
  const __CFNumber *UInt32;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  unsigned int v70;
  int v71;
  int v72;
  unsigned int v73;
  unsigned int v74;
  int v75;
  int v76;
  int v77;
  uint64_t v78;
  const __CFAllocator *v79;
  CFMutableDictionaryRef Mutable;
  const void *v81;
  const __CFDictionary *v82;
  CFNumberRef v83;
  CFNumberRef v84;
  int v85;
  CFNumberRef v86;
  CFNumberRef v87;
  CFNumberRef v88;
  uint64_t v89;
  int v90;
  CFNumberRef v91;
  uint64_t v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  CFNumberRef v99;
  uint64_t v100;
  CFTypeRef v101;
  NSObject *v102;
  unsigned int mSampleRate_low;
  unsigned int v104;
  int v106;
  int v107;
  int v108;
  int v109;
  const void *v110;
  __int128 v111;
  CMTimeEpoch v112;
  _QWORD *v113;
  const void *v115;
  CFTypeRef v117;
  CFTypeRef v119;
  void *value;
  CMTime v121;
  CMTime v122;
  AudioStreamBasicDescription asbd;
  os_log_type_t v124;
  unsigned int v125;
  int v126;
  int v127;
  int valuePtr;
  os_log_type_t type[8];
  CMAudioFormatDescriptionRef formatDescriptionOut;
  CMTime time;
  const char *v132;
  __int16 v133;
  uint64_t v134;
  __int16 v135;
  uint64_t v136;
  __int16 v137;
  int v138;
  __int16 v139;
  int v140;
  __int16 v141;
  int v142;
  __int16 v143;
  int v144;
  __int16 v145;
  int v146;
  __int16 v147;
  int v148;
  __int16 v149;
  int v150;
  __int16 v151;
  int v152;
  __int16 v153;
  int v154;
  __int16 v155;
  int v156;
  __int16 v157;
  int v158;
  __int16 v159;
  int v160;
  __int16 v161;
  unsigned int v162;
  __int16 v163;
  int v164;
  __int16 v165;
  int v166;
  __int16 v167;
  int v168;
  __int16 v169;
  unsigned int v170;
  __int16 v171;
  int v172;
  __int16 v173;
  int v174;
  __int16 v175;
  int v176;
  __int16 v177;
  int v178;
  __int16 v179;
  int v180;
  CMTime v181;
  const char *v182;
  __int16 v183;
  CFTypeRef v184;
  uint64_t v185;

  v185 = *MEMORY[0x1E0C80C00];
  value = 0;
  FigNote_AllowInternalDefaultLogs();
  fig_note_initialize_category_with_default_work_cf();
  fig_note_initialize_category_with_default_work_cf();
  v115 = a2;
  if (a2 && a3 && a4 && a8)
  {
    v117 = a4;
    FigBufferedAirPlayAudioChainSubPipeGetClassID();
    v13 = a1;
    v14 = CMDerivedObjectCreate();
    if ((_DWORD)v14)
      return v14;
    v113 = a8;
    v119 = a3;
    DerivedStorage = CMBaseObjectGetDerivedStorage();
    *(_BYTE *)DerivedStorage = 0;
    if (a7 && CFDictionaryGetValueIfPresent(a7, CFSTR("LoggingID"), (const void **)&value))
      CFStringGetCString((CFStringRef)value, (char *)DerivedStorage, 20, 0x600u);
    v16 = FigSimpleMutexCreate();
    *(_QWORD *)(DerivedStorage + 24) = v16;
    if (!v16
      || (v17 = dispatch_queue_create("com.apple.coremedia.bufferedAirPlayAudioChainTranscodeSubPipe.notificationQueue", 0), (*(_QWORD *)(DerivedStorage + 32) = v17) == 0))
    {
      UInt32 = 0;
      v37 = 4294954510;
      goto LABEL_68;
    }
    v18 = CMBaseObjectGetDerivedStorage();
    memset(&v122, 0, sizeof(v122));
    CMTimeMake(&v122, 2000, 1000);
    memset(&v121, 0, sizeof(v121));
    CMTimeMake(&v121, 10000, 1000);
    v111 = *MEMORY[0x1E0CA2E18];
    time = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E18];
    epoch = time.epoch;
    v20 = CMTimeCopyAsDictionary(&time, a1);
    formatDescriptionOut = 0;
    memset(&asbd, 0, sizeof(asbd));
    MutableCopy = (__CFDictionary *)FigCFDictionaryCreateMutableCopy();
    v112 = epoch;
    if (!MutableCopy)
    {
      v38 = 0;
      v37 = 4294954443;
      if (v20)
LABEL_45:
        CFRelease(v20);
LABEL_46:
      v39 = (_QWORD *)(DerivedStorage + 112);
      if (!(_DWORD)v37)
      {
        v40 = FigAudioQueueRenderPipelineCreate(v13, v38, (_QWORD *)(DerivedStorage + 112));
        if (!(_DWORD)v40)
        {
          FigBaseObject = FigRenderPipelineGetFigBaseObject(*v39);
          v42 = *(uint64_t (**)(uint64_t, const __CFString *, const __CFAllocator *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 48);
          if (!v42)
          {
            v37 = 4294954514;
            if (!v38)
            {
LABEL_54:
              if (!(_DWORD)v37)
              {
                v44 = *v39;
                v45 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 64);
                if (!v45)
                {
                  UInt32 = 0;
                  v37 = 4294954514;
                  goto LABEL_68;
                }
                v46 = v45(v44, 1);
                if (!(_DWORD)v46)
                {
                  v46 = FigSampleBufferConsumerCreateForSampleBufferConsumer("bapspTranscode_SampleBufferConsumerFromMixer", (_QWORD *)(DerivedStorage + 96));
                  if (!(_DWORD)v46)
                  {
                    v47 = *(const void **)(DerivedStorage + 96);
                    v122.value = 0;
                    v121.value = 0;
                    *(_QWORD *)type = 0;
                    formatDescriptionOut = 0;
                    memset(&asbd, 0, 32);
                    CFPreferenceNumberWithDefault = FigGetCFPreferenceNumberWithDefault();
                    valuePtr = 0x8000;
                    v127 = 0;
                    v126 = -1;
                    if (v47
                      && (v49 = CFPreferenceNumberWithDefault,
                          *(_QWORD *)(DerivedStorage + 104) = 0,
                          (RichestDecodableFormatAndChannelLayout = FigAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout()) != 0)
                      && (v51 = RichestDecodableFormatAndChannelLayout,
                          v110 = v47,
                          (v52 = FigEndpointStreamAudioFormatDescriptionGetASBD()) != 0))
                    {
                      v53 = v52;
                      v109 = v49;
                      ChannelLayoutTag = FigEndpointStreamAudioFormatDescriptionGetChannelLayoutTag();
                      LODWORD(asbd.mSampleRate) = ChannelLayoutTag;
                      if (dword_1EE2A31C8)
                      {
                        v55 = ChannelLayoutTag;
                        v125 = 0;
                        v124 = OS_LOG_TYPE_DEFAULT;
                        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                        v57 = v125;
                        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, v124))
                          v58 = v57;
                        else
                          v58 = v57 & 0xFFFFFFFE;
                        if (v58)
                        {
                          v60 = *(_QWORD *)v51;
                          v61 = *(_QWORD *)v53;
                          v63 = *(_DWORD *)(v51 + 16);
                          v62 = *(_DWORD *)(v51 + 20);
                          v65 = *(_DWORD *)(v53 + 16);
                          v64 = *(_DWORD *)(v53 + 20);
                          v66 = *(_DWORD *)(v51 + 24);
                          v67 = *(_DWORD *)(v51 + 28);
                          v68 = *(_DWORD *)(v53 + 24);
                          v69 = *(_DWORD *)(v53 + 28);
                          v70 = *(_DWORD *)(v51 + 8);
                          v71 = *(_DWORD *)(v51 + 12);
                          v73 = *(_DWORD *)(v53 + 8);
                          v72 = *(_DWORD *)(v53 + 12);
                          v74 = HIBYTE(v73);
                          v75 = *(_DWORD *)(v51 + 32);
                          v76 = *(_DWORD *)(v53 + 32);
                          v106 = BYTE2(v73);
                          v107 = BYTE1(v73);
                          v108 = v73;
                          v77 = (int)formatDescriptionOut;
                          if (formatDescriptionOut)
                            v77 = *(_DWORD *)formatDescriptionOut;
                          LODWORD(time.value) = 136321794;
                          *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)"bapspTranscode_createMixer";
                          LOWORD(time.flags) = 2048;
                          *(_QWORD *)((char *)&time.flags + 2) = 0;
                          HIWORD(time.epoch) = 2082;
                          v132 = "";
                          v133 = 2048;
                          v134 = v60;
                          v135 = 2048;
                          v136 = v61;
                          v137 = 1024;
                          v138 = v67;
                          v139 = 1024;
                          v140 = v69;
                          v141 = 1024;
                          v142 = v63;
                          v143 = 1024;
                          v144 = v65;
                          v145 = 1024;
                          v146 = v62;
                          v147 = 1024;
                          v148 = v64;
                          v149 = 1024;
                          v150 = v66;
                          v151 = 1024;
                          v152 = v68;
                          v153 = 1024;
                          v154 = v75;
                          v155 = 1024;
                          v156 = v76;
                          v157 = 1024;
                          v158 = v71;
                          v159 = 1024;
                          v160 = v72;
                          v161 = 1024;
                          v162 = HIBYTE(v70);
                          v163 = 1024;
                          v164 = BYTE2(v70);
                          v165 = 1024;
                          v166 = BYTE1(v70);
                          v167 = 1024;
                          v168 = v70;
                          v169 = 1024;
                          v170 = v74;
                          v171 = 1024;
                          v172 = v106;
                          v173 = 1024;
                          v174 = v107;
                          v175 = 1024;
                          v176 = v108;
                          v177 = 1024;
                          v178 = v77;
                          v179 = 1024;
                          v180 = v55;
                          _os_log_send_and_compose_impl();
                        }
                        fig_log_call_emit_and_clean_up_after_send_and_compose();
                      }
                      v78 = FigActivitySchedulerCreateForNewThread((uint64_t)v13, 36, CFSTR("com.apple.coremedia.BAPSubPipeTranscode.mixer"), &v121);
                      if (!(_DWORD)v78)
                      {
                        v79 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
                        Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                        v81 = a6;
                        if (Mutable)
                        {
                          v82 = Mutable;
                          v83 = CFNumberCreate(v79, kCFNumberIntType, &valuePtr);
                          if (v83)
                          {
                            v84 = v83;
                            FigCFDictionarySetValue();
                            v85 = *(_DWORD *)(v53 + 8);
                            if (v85 == 1634754915 || v85 == 1902211171 || v85 == 1667330147)
                            {
                              CFRelease(v84);
                              v86 = CFNumberCreate(v79, kCFNumberIntType, &v127);
                              if (!v86)
                                goto LABEL_148;
                              v87 = v86;
                              FigCFDictionarySetValue();
                              CFRelease(v87);
                              v88 = CFNumberCreate(v79, kCFNumberIntType, &v126);
                              if (!v88)
                                goto LABEL_148;
                              v84 = v88;
                              FigCFDictionarySetValue();
                            }
                            FigCFDictionarySetValueFromKeyInDict();
                            v89 = FigAudioQueueOfflineMixerCreate(v13, (__int128 *)v53, 0xCuLL, (const AudioChannelLayout *)&asbd, v82, v110, (const void *)v121.value, &v122.value);
                            if ((_DWORD)v89)
                            {
                              v37 = v89;
                              goto LABEL_117;
                            }
                            CFRelease(v84);
                            if (*(_DWORD *)(v53 + 28) >= 3u)
                              v90 = 32;
                            else
                              v90 = 64;
                            *(_DWORD *)&type[4] = v90;
                            v91 = CFNumberCreate(v79, kCFNumberIntType, &type[4]);
                            if (v91)
                            {
                              v84 = v91;
                              v92 = FigAudioQueueOfflineMixerSetProperty(v122.value, CFSTR("AudioQueueOfflineMixer_CodecQuality"), v91);
                              if ((_DWORD)v92)
                              {
LABEL_149:
                                v37 = v92;
LABEL_117:
                                CFRelease(v84);
LABEL_118:
                                CFRelease(v82);
                                goto LABEL_119;
                              }
                              v93 = *(_DWORD *)(v53 + 8);
                              if (v93 > 1902928226)
                              {
                                if (v93 == 1902928227)
                                  goto LABEL_115;
                                v94 = 2053923171;
                              }
                              else
                              {
                                if (v93 == 1634492771)
                                  goto LABEL_115;
                                v94 = 1668047203;
                              }
                              if (v93 == v94)
                              {
LABEL_115:
                                v37 = FigAudioQueueOfflineMixerSetProperty(v122.value, CFSTR("AudioQueueOfflineMixer_SampleBufferAllocator"), a6);
                                if (!(_DWORD)v37)
                                {
                                  *(_QWORD *)(DerivedStorage + 104) = v122.value;
                                  v122.value = 0;
                                }
                                goto LABEL_117;
                              }
                              CFRelease(v84);
                              v95 = *(_DWORD *)(v53 + 8);
                              if (v95 == 1634754915 || v95 == 1902211171 || v95 == 1667330147)
                              {
                                v96 = v109;
                                switch(*(_DWORD *)(v53 + 28))
                                {
                                  case 6:
                                    v97 = 512000;
                                    break;
                                  case 8:
                                  case 0xA:
                                    v97 = 768000;
                                    break;
                                  case 0xC:
                                    v97 = 896000;
                                    break;
                                  default:
                                    v97 = 256000;
                                    break;
                                }
                                *(_DWORD *)type = v97;
                              }
                              else
                              {
                                if (*(_DWORD *)(v53 + 28) <= 2u)
                                  v98 = 256000;
                                else
                                  v98 = 512000;
                                *(_DWORD *)type = v98;
                                v96 = v109;
                              }
                              if (v96)
                                *(_DWORD *)type = v96;
                              v99 = CFNumberCreate(v79, kCFNumberIntType, type);
                              if (v99)
                              {
                                v84 = v99;
                                v92 = FigAudioQueueOfflineMixerSetProperty(v122.value, CFSTR("AudioQueueOfflineMixer_BitRateForVBR"), v99);
                                if (!(_DWORD)v92)
                                  goto LABEL_115;
                                goto LABEL_149;
                              }
                            }
                          }
LABEL_148:
                          v37 = FigSignalErrorAt();
                          goto LABEL_118;
                        }
                        v37 = 4294954443;
LABEL_119:
                        if (v122.value)
                          CFRelease((CFTypeRef)v122.value);
                        if (v121.value)
                          CFRelease((CFTypeRef)v121.value);
                        if ((_DWORD)v37)
                        {
                          UInt32 = 0;
                        }
                        else
                        {
                          UInt32 = (const __CFNumber *)FigCFNumberCreateUInt32();
                          if (UInt32)
                          {
                            bapspTranscode_setThreadPriorities(0, UInt32);
                            v100 = FigSampleBufferConsumerSbufInspectorCreate((uint64_t)v13, *(const void **)(DerivedStorage + 64), (uint64_t)bapspTranscode_inspectSampleBuffer, 0, "sbcSbufInspectForTranscode", (_QWORD *)(DerivedStorage + 72));
                            if (!(_DWORD)v100)
                            {
                              v100 = FigSampleBufferConsumerOPTSAutoOrderCreate(v13, v115, "TranscodeOPTSAutoOrder", (_QWORD *)(DerivedStorage + 80));
                              if (!(_DWORD)v100)
                              {
                                *(_BYTE *)(DerivedStorage + 128) = a5;
                                *(_QWORD *)(DerivedStorage + 48) = CFRetain(v117);
                                if (v81)
                                  v101 = CFRetain(v81);
                                else
                                  v101 = 0;
                                *(_QWORD *)(DerivedStorage + 56) = v101;
                                *(_BYTE *)(DerivedStorage + 168) = 0;
                                *(_DWORD *)(DerivedStorage + 40) = 0;
                                *(_QWORD *)(DerivedStorage + 136) = CFRetain(v119);
                                *(_OWORD *)(DerivedStorage + 144) = v111;
                                *(_QWORD *)(DerivedStorage + 160) = v112;
                                if (dword_1EE2A31C8)
                                {
                                  LODWORD(asbd.mSampleRate) = 0;
                                  LOBYTE(v122.value) = 0;
                                  v102 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                                  mSampleRate_low = LODWORD(asbd.mSampleRate);
                                  if (os_log_type_enabled(v102, v122.value))
                                    v104 = mSampleRate_low;
                                  else
                                    v104 = mSampleRate_low & 0xFFFFFFFE;
                                  if (v104)
                                  {
                                    LODWORD(v181.value) = 136315650;
                                    *(CMTimeValue *)((char *)&v181.value + 4) = (CMTimeValue)"FigBufferedAirPlayAudioChai"
                                                                                             "nSubPipeTranscodeCreate";
                                    LOWORD(v181.flags) = 2048;
                                    *(_QWORD *)((char *)&v181.flags + 2) = 0;
                                    HIWORD(v181.epoch) = 2082;
                                    v182 = "";
                                    _os_log_send_and_compose_impl();
                                  }
                                  fig_log_call_emit_and_clean_up_after_send_and_compose();
                                }
                                v37 = 0;
                                *v113 = 0;
LABEL_138:
                                CFRelease(UInt32);
                                return v37;
                              }
                            }
                            v37 = v100;
                          }
                          else
                          {
                            v37 = 4294954510;
                          }
                        }
LABEL_68:
                        if (!UInt32)
                          return v37;
                        goto LABEL_138;
                      }
                    }
                    else
                    {
                      v78 = FigSignalErrorAt();
                    }
                    v37 = v78;
                    v81 = a6;
                    goto LABEL_119;
                  }
                }
                v37 = v46;
              }
              UInt32 = 0;
              goto LABEL_68;
            }
LABEL_53:
            CFRelease(v38);
            goto LABEL_54;
          }
          v40 = v42(FigBaseObject, CFSTR("SourceSampleBufferQueue"), v13, v18 + 88);
          if (!(_DWORD)v40)
          {
            v43 = *(_QWORD *)(v18 + 88);
            time = v121;
            v181 = v122;
            v40 = FigSampleBufferConsumerCreateForBufferQueue(v43, (uint64_t)&time, (uint64_t)&v181, (_QWORD *)(v18 + 64));
          }
        }
        v37 = v40;
      }
      if (!v38)
        goto LABEL_54;
      goto LABEL_53;
    }
    v22 = MutableCopy;
    CFDictionarySetValue(MutableCopy, CFSTR("BufferedAirPlayDecode"), (const void *)*MEMORY[0x1E0C9AE50]);
    CFDictionarySetValue(v22, CFSTR("PreparedQueueLowWaterLevel"), v20);
    CFDictionarySetValue(v22, CFSTR("PreparedQueueHighWaterLevel"), v20);
    if (a7)
    {
      v23 = CFDictionaryGetValue(a7, CFSTR("DisallowMultiplePlayResources"));
      if (v23)
        CFDictionarySetValue(v22, CFSTR("DisallowMultiplePlayResources"), v23);
      v24 = CFDictionaryGetValue(a7, CFSTR("AllowAudibleContent"));
      if (v24)
        CFDictionarySetValue(v22, CFSTR("AllowAudibleContent"), v24);
      v25 = CFDictionaryGetValue(a7, CFSTR("AllowAMRDecode"));
      if (v25)
        CFDictionarySetValue(v22, CFSTR("AllowAMRDecode"), v25);
      v26 = CFDictionaryGetValue(a7, CFSTR("AllowAtmosDecode"));
      if (v26)
        CFDictionarySetValue(v22, CFSTR("AllowAtmosDecode"), v26);
      v27 = (const opaqueCMFormatDescription *)CFDictionaryGetValue(a7, CFSTR("FormatDescription"));
      formatDescriptionOut = v27;
      if (v27)
      {
        v28 = v27;
        CFRetain(v27);
        CFDictionarySetValue(v22, CFSTR("FormatDescription"), v28);
        FigCFDictionarySetValueFromKeyInDict();
        v13 = a1;
        goto LABEL_33;
      }
      FigCFDictionarySetValueFromKeyInDict();
      v13 = a1;
    }
    if (dword_1EE2A31C8)
    {
      *(_DWORD *)&type[4] = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      v29 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      v30 = *(_DWORD *)&type[4];
      if (os_log_type_enabled(v29, type[0]))
        v31 = v30;
      else
        v31 = v30 & 0xFFFFFFFE;
      if (v31)
      {
        LODWORD(v181.value) = 136315650;
        *(CMTimeValue *)((char *)&v181.value + 4) = (CMTimeValue)"bapspTranscode_setupAudioRenderPipelineOptions";
        LOWORD(v181.flags) = 2048;
        *(_QWORD *)((char *)&v181.flags + 2) = 0;
        HIWORD(v181.epoch) = 2082;
        v182 = "";
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    asbd.mSampleRate = 44100.0;
    *(_OWORD *)&asbd.mFormatID = xmmword_1932FCFC0;
    *(_OWORD *)&asbd.mBytesPerFrame = xmmword_1932FCFD0;
    v32 = CMAudioFormatDescriptionCreate(v13, &asbd, 0, 0, 0, 0, 0, &formatDescriptionOut);
    v33 = formatDescriptionOut;
    if ((_DWORD)v32)
    {
      v37 = v32;
      v38 = 0;
      if (formatDescriptionOut)
LABEL_41:
        CFRelease(v33);
LABEL_42:
      if (v22)
        CFRelease(v22);
      if (v20)
        goto LABEL_45;
      goto LABEL_46;
    }
    CFDictionarySetValue(v22, CFSTR("FormatDescription"), formatDescriptionOut);
LABEL_33:
    CFDictionarySetValue(v22, CFSTR("FormatDescription"), v119);
    if (dword_1EE2A31C8)
    {
      *(_DWORD *)&type[4] = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      v34 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      v35 = *(_DWORD *)&type[4];
      if (os_log_type_enabled(v34, type[0]))
        v36 = v35;
      else
        v36 = v35 & 0xFFFFFFFE;
      if (v36)
      {
        LODWORD(v181.value) = 136315906;
        *(CMTimeValue *)((char *)&v181.value + 4) = (CMTimeValue)"bapspTranscode_setupAudioRenderPipelineOptions";
        LOWORD(v181.flags) = 2048;
        *(_QWORD *)((char *)&v181.flags + 2) = 0;
        HIWORD(v181.epoch) = 2082;
        v182 = "";
        v183 = 2112;
        v184 = v119;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    v37 = 0;
    v33 = formatDescriptionOut;
    v38 = v22;
    v22 = 0;
    if (formatDescriptionOut)
      goto LABEL_41;
    goto LABEL_42;
  }
  return FigSignalErrorAt();
}

uint64_t bapspTranscode_setThreadPriorities(uint64_t a1, const __CFNumber *a2)
{
  uint64_t result;
  uint64_t v4;
  __CFString **v5;
  uint64_t v6;
  __CFString *v7;
  uint64_t FigBaseObject;
  void (*v9)(uint64_t, const __CFString *, __CFString *);
  int valuePtr;

  result = CMBaseObjectGetDerivedStorage();
  valuePtr = 0;
  if (a2)
  {
    v4 = result;
    result = CFNumberGetValue(a2, kCFNumberSInt32Type, &valuePtr);
    switch(valuePtr)
    {
      case '$':
        v5 = kFigAudioRenderPipelineOfflineRenderPriority_BufferedAirPlayUrgent;
        break;
      case '+':
        v5 = kFigAudioRenderPipelineOfflineRenderPriority_BufferedAirPlayRelaxed;
        break;
      case '%':
        v5 = kFigAudioRenderPipelineOfflineRenderPriority_BufferedAirPlayDefault;
        break;
      default:
        return result;
    }
    v6 = *(_QWORD *)(v4 + 112);
    if (v6)
    {
      v7 = *v5;
      FigBaseObject = FigRenderPipelineGetFigBaseObject(v6);
      v9 = *(void (**)(uint64_t, const __CFString *, __CFString *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                            + 56);
      if (v9)
        v9(FigBaseObject, CFSTR("OfflineRenderPriority"), v7);
    }
    result = *(_QWORD *)(v4 + 104);
    if (result)
      return FigAudioQueueOfflineMixerSetProperty(result, CFSTR("AudioQueueOfflineMixer_ThreadPriority"), a2);
  }
  return result;
}

uint64_t bapspTranscode_inspectSampleBuffer(opaqueCMSampleBuffer *a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  CMTime *v5;
  uint64_t v6;
  const opaqueCMFormatDescription *FormatDescription;
  const __CFAllocator **v8;
  CFTypeRef *v9;
  const opaqueCMFormatDescription *v10;
  const __CFAllocator *v11;
  CMFormatDescriptionRef v12;
  uint64_t v13;
  CMTimeValue value;
  unsigned int (*v15)(uint64_t, CMTimeValue);
  uint64_t v16;
  CFTypeRef v17;
  const void *v18;
  const __CFAllocator *v19;
  int v20;
  uint64_t v21;
  CMTimeValue v22;
  uint64_t (*v23)(uint64_t, CMTimeValue);
  int v24;
  CMTime *v25;
  const __CFString *v26;
  CFTypeRef v27;
  uint64_t v28;
  const __CFString *v29;
  CMTimeFlags flags;
  CMTimeEpoch epoch;
  const __CFAllocator *v32;
  CFTypeRef v33;
  int v34;
  uint64_t v35;
  CMAttachmentBearerRef v36;
  uint64_t (*v37)(uint64_t, CMAttachmentBearerRef);
  int v38;
  const opaqueCMFormatDescription *v39;
  const opaqueCMFormatDescription *v40;
  const opaqueCMFormatDescription *v41;
  const void *v42;
  CMTimeFlags v43;
  CMTimeEpoch v44;
  CMTime v46;
  CMTime target;
  CMTime v48;
  CMAttachmentBearerRef cf;
  CMTimeValue v50;
  CMTimeScale v51;
  CMTimeValue v52;
  CMTimeScale timescale;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a1)
    return 1;
  v5 = (CMTime *)DerivedStorage;
  v6 = CMBaseObjectGetDerivedStorage();
  target.value = 0;
  FormatDescription = CMSampleBufferGetFormatDescription(a1);
  v8 = (const __CFAllocator **)MEMORY[0x1E0C9AE00];
  v9 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
  if (FormatDescription)
  {
    v10 = *(const opaqueCMFormatDescription **)(v6 + 136);
    if (!v10 || !CMAudioFormatDescriptionEqual(FormatDescription, v10, 7u, 0) || !*(_BYTE *)(v6 + 168))
    {
      v11 = *v8;
      v12 = CMSampleBufferGetFormatDescription(a1);
      CMSampleBufferGetOutputPresentationTimeStamp(&v48, a1);
      if (!FigBufferedAirPlayAudioChainSubPipeSampleBufferCreateWithTimeStampAndMarker(v11, CFSTR("InputContentFormatDesc"), v12, (__int128 *)&v48.value, &target))
      {
        CMSetAttachment((CMAttachmentBearerRef)target.value, CFSTR("SBUFForAutoOrder"), *v9, 0);
        v13 = *(_QWORD *)(v6 + 80);
        value = target.value;
        v15 = *(unsigned int (**)(uint64_t, CMTimeValue))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
        if (v15)
        {
          if (!v15(v13, value))
            *(_BYTE *)(v6 + 168) = 1;
        }
      }
    }
    if (target.value)
      CFRelease((CFTypeRef)target.value);
  }
  v16 = CMBaseObjectGetDerivedStorage();
  target.value = 0;
  v17 = CMGetAttachment(a1, CFSTR("SbufTracer"), 0);
  if (v17)
  {
    v18 = v17;
    v19 = *v8;
    CMSampleBufferGetOutputPresentationTimeStamp(&v48, a1);
    v20 = FigBufferedAirPlayAudioChainSubPipeSampleBufferCreateWithTimeStampAndMarker(v19, CFSTR("SbufTracer"), v18, (__int128 *)&v48.value, &target);
    if (v20)
    {
LABEL_16:
      v24 = v20;
      goto LABEL_19;
    }
    CMSetAttachment((CMAttachmentBearerRef)target.value, CFSTR("SBUFForAutoOrder"), *v9, 0);
    v21 = *(_QWORD *)(v16 + 80);
    v22 = target.value;
    v23 = *(uint64_t (**)(uint64_t, CMTimeValue))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
    if (v23)
    {
      v20 = v23(v21, v22);
      goto LABEL_16;
    }
    v24 = -12782;
  }
  else
  {
    v24 = 0;
  }
LABEL_19:
  if (target.value)
    CFRelease((CFTypeRef)target.value);
  if (!v24)
  {
    v25 = (CMTime *)CMBaseObjectGetDerivedStorage();
    v26 = (const __CFString *)*MEMORY[0x1E0CA4E40];
    v27 = CMGetAttachment(a1, (CFStringRef)*MEMORY[0x1E0CA4E40], 0);
    if (v27)
    {
      v48 = v25[6];
      if (bapspTranscode_setLoudnessInfo(a2, v27, (uint64_t)&v48))
        return 1;
      CMRemoveAttachment(a1, v26);
    }
    v28 = CMBaseObjectGetDerivedStorage();
    cf = 0;
    v29 = (const __CFString *)*MEMORY[0x1E0CA4E48];
    if (!CMGetAttachment(a1, (CFStringRef)*MEMORY[0x1E0CA4E48], 0))
    {
      v38 = 0;
      goto LABEL_36;
    }
    CMSampleBufferGetOutputPresentationTimeStamp(&v48, a1);
    v52 = v48.value;
    flags = v48.flags;
    timescale = v48.timescale;
    if ((v48.flags & 1) != 0)
    {
      epoch = v48.epoch;
    }
    else
    {
      v52 = *(_QWORD *)(v28 + 144);
      flags = *(_DWORD *)(v28 + 156);
      timescale = *(_DWORD *)(v28 + 152);
      epoch = *(_QWORD *)(v28 + 160);
    }
    CMSampleBufferGetOutputDuration(&v48, a1);
    v50 = v48.value;
    v51 = v48.timescale;
    if ((v48.flags & 1) != 0)
    {
      v46.epoch = v48.epoch;
      target.value = v52;
      target.timescale = timescale;
      target.flags = flags;
      target.epoch = epoch;
      v46.value = v50;
      v46.timescale = v51;
      v46.flags = v48.flags;
      CMTimeAdd(&v48, &target, &v46);
      v52 = v48.value;
      flags = v48.flags;
      timescale = v48.timescale;
      epoch = v48.epoch;
    }
    CMRemoveAttachment(a1, v29);
    v32 = *v8;
    v33 = *v9;
    v48.value = v52;
    v48.timescale = timescale;
    v48.flags = flags;
    v48.epoch = epoch;
    v34 = FigBufferedAirPlayAudioChainSubPipeSampleBufferCreateWithTimeStampAndMarker(v32, v29, v33, (__int128 *)&v48.value, &cf);
    if (!v34)
    {
      CMSetAttachment(cf, CFSTR("SBUFForAutoOrder"), v33, 0);
      v35 = *(_QWORD *)(v28 + 80);
      v36 = cf;
      v37 = *(uint64_t (**)(uint64_t, CMAttachmentBearerRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
      if (!v37)
      {
        v38 = -12782;
        goto LABEL_36;
      }
      v34 = v37(v35, v36);
      if (!v34)
      {
        MEMORY[0x19402EEEC](*(_QWORD *)(v28 + 24));
        v38 = bapspTranscode_terminateQueueWithEndMarker();
        MEMORY[0x19402EF04](*(_QWORD *)(v28 + 24));
LABEL_36:
        if (cf)
          CFRelease(cf);
        if (!v38)
        {
          v39 = CMSampleBufferGetFormatDescription(a1);
          if (v39)
          {
            v40 = v39;
            v41 = (const opaqueCMFormatDescription *)v5[5].epoch;
            if (v41)
            {
              if (!CMAudioFormatDescriptionEqual(v39, v41, 7u, 0))
              {
                v42 = (const void *)v5[5].epoch;
                v5[5].epoch = (CMTimeEpoch)v40;
                CFRetain(v40);
                if (v42)
                  CFRelease(v42);
              }
            }
            else
            {
              v5[5].epoch = (CMTimeEpoch)v39;
              CFRetain(v39);
            }
          }
          CMSampleBufferGetOutputDuration(&v48, a1);
          v50 = v48.value;
          v43 = v48.flags;
          v51 = v48.timescale;
          v44 = v48.epoch;
          CMSampleBufferGetOutputPresentationTimeStamp(&v48, a1);
          v52 = v48.value;
          timescale = v48.timescale;
          if ((v48.flags & 1) != 0)
          {
            v46.epoch = v44;
            target.value = v52;
            target.timescale = timescale;
            target.flags = v48.flags;
            target.epoch = v48.epoch;
            v46.value = v50;
            v46.timescale = v51;
            v46.flags = v43;
            CMTimeAdd(&v48, &target, &v46);
            v5[6] = v48;
          }
        }
        return 1;
      }
    }
    v38 = v34;
    goto LABEL_36;
  }
  return 1;
}

uint64_t bapspTranscode_invalidate(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!*(_BYTE *)(DerivedStorage + 42))
  {
    v3 = DerivedStorage;
    bapspTranscode_breakAudioChain(a1);
    MEMORY[0x19402EEEC](*(_QWORD *)(v3 + 24));
    *(_BYTE *)(v3 + 42) = 1;
    FigAudioQueueOfflineMixerInvalidate(*(_QWORD *)(v3 + 104));
    v4 = *(const void **)(v3 + 136);
    if (v4)
    {
      CFRelease(v4);
      *(_QWORD *)(v3 + 136) = 0;
    }
    v5 = *(const void **)(v3 + 48);
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)(v3 + 48) = 0;
    }
    v6 = *(const void **)(v3 + 56);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(v3 + 56) = 0;
    }
    v7 = *(const void **)(v3 + 64);
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(v3 + 64) = 0;
    }
    v8 = *(const void **)(v3 + 88);
    if (v8)
    {
      CFRelease(v8);
      *(_QWORD *)(v3 + 88) = 0;
    }
    v9 = *(const void **)(v3 + 72);
    if (v9)
    {
      CFRelease(v9);
      *(_QWORD *)(v3 + 72) = 0;
    }
    v10 = *(const void **)(v3 + 80);
    if (v10)
    {
      CFRelease(v10);
      *(_QWORD *)(v3 + 80) = 0;
    }
    v11 = *(const void **)(v3 + 96);
    if (v11)
    {
      CFRelease(v11);
      *(_QWORD *)(v3 + 96) = 0;
    }
    v12 = *(const void **)(v3 + 112);
    if (v12)
    {
      CFRelease(v12);
      *(_QWORD *)(v3 + 112) = 0;
    }
    v13 = *(const void **)(v3 + 104);
    if (v13)
    {
      CFRelease(v13);
      *(_QWORD *)(v3 + 104) = 0;
    }
    v14 = *(const void **)(v3 + 120);
    if (v14)
    {
      CFRelease(v14);
      *(_QWORD *)(v3 + 120) = 0;
    }
    MEMORY[0x19402EF04](*(_QWORD *)(v3 + 24));
  }
  return 0;
}

uint64_t bapspTranscode_finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  NSObject *v3;
  uint64_t result;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  bapspTranscode_invalidate(a1);
  v3 = *(NSObject **)(DerivedStorage + 32);
  if (v3)
  {
    dispatch_release(v3);
    *(_QWORD *)(DerivedStorage + 32) = 0;
  }
  result = FigSimpleMutexDestroy();
  *(_QWORD *)(DerivedStorage + 24) = 0;
  return result;
}

__CFString *bapspTranscode_copyDebugDescription(uint64_t a1)
{
  __CFString *Mutable;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigBufferedAirPlayAudioChainSubPipet %p>"), a1);
  return Mutable;
}

uint64_t bapspTranscode_copyProperty(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t DerivedStorage;
  uint64_t v8;
  const void *v9;
  CFTypeRef v10;
  const void **v11;
  uint64_t result;
  uint64_t FigBaseObject;
  uint64_t (*v14)(uint64_t, const void *, uint64_t, _QWORD *);

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(_BYTE *)(DerivedStorage + 42))
    return 0;
  v8 = DerivedStorage;
  if (CFEqual(a2, CFSTR("SourceSampleBufferConsumer")))
  {
    v9 = *(const void **)(v8 + 72);
    if (v9)
    {
LABEL_4:
      v10 = CFRetain(v9);
LABEL_13:
      result = 0;
      *a4 = v10;
      return result;
    }
LABEL_12:
    v10 = 0;
    goto LABEL_13;
  }
  if (CFEqual(a2, CFSTR("IsStarted")))
  {
    v11 = (const void **)MEMORY[0x1E0C9AE50];
    if (!*(_BYTE *)(v8 + 41))
      v11 = (const void **)MEMORY[0x1E0C9AE40];
LABEL_11:
    v9 = *v11;
    if (*v11)
      goto LABEL_4;
    goto LABEL_12;
  }
  if (CFEqual(a2, CFSTR("SubPipeType")))
  {
    v11 = (const void **)kFigBufferedAirPlayAudioChainSubPipeSubPipeType_Transcode;
    goto LABEL_11;
  }
  FigBaseObject = FigRenderPipelineGetFigBaseObject(*(_QWORD *)(v8 + 112));
  v14 = *(uint64_t (**)(uint64_t, const void *, uint64_t, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                           + 48);
  if (v14)
    return v14(FigBaseObject, a2, a3, a4);
  else
    return 4294954514;
}

uint64_t bapspTranscode_setProperty(uint64_t a1, const __CFString *a2, const void *a3)
{
  uint64_t DerivedStorage;
  uint64_t v7;
  CFTypeID v8;
  CFTypeID TypeID;
  uint64_t FigBaseObject;
  uint64_t (*v12)(uint64_t, const __CFString *, const void *);
  const __CFString *v13;
  uint64_t v14;
  CFTypeID v15;
  uint64_t v16;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(_BYTE *)(DerivedStorage + 42))
    return 0;
  v7 = DerivedStorage;
  if (CFEqual(CFSTR("LoudnessInfo"), a2))
  {
    if (!a3)
      return bapspTranscode_setLoudnessInfo(a1, a3, MEMORY[0x1E0CA2E18]);
    v8 = CFGetTypeID(a3);
    if (v8 == CFDictionaryGetTypeID())
      return bapspTranscode_setLoudnessInfo(a1, a3, MEMORY[0x1E0CA2E18]);
    return FigSignalErrorAt();
  }
  if (CFEqual(CFSTR("AudioProcessingTap"), a2))
  {
    if (!a3 || (TypeID = MTAudioProcessingTapGetTypeID(), TypeID == CFGetTypeID(a3)))
    {
      FigBaseObject = FigRenderPipelineGetFigBaseObject(*(_QWORD *)(v7 + 112));
      v12 = *(uint64_t (**)(uint64_t, const __CFString *, const void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                + 56);
      if (v12)
      {
        v13 = CFSTR("AudioProcessingTap");
        v14 = FigBaseObject;
        return v12(v14, v13, a3);
      }
      return 4294954514;
    }
    return 0;
  }
  if (CFEqual(CFSTR("ThreadPriority"), a2))
  {
    if (!a3)
      return FigSignalErrorAt();
    v15 = CFGetTypeID(a3);
    if (v15 != CFNumberGetTypeID())
      return FigSignalErrorAt();
    bapspTranscode_setThreadPriorities(a1, (const __CFNumber *)a3);
    return 0;
  }
  v16 = FigRenderPipelineGetFigBaseObject(*(_QWORD *)(v7 + 112));
  v12 = *(uint64_t (**)(uint64_t, const __CFString *, const void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                            + 56);
  if (v12)
  {
    v14 = v16;
    v13 = a2;
    return v12(v14, v13, a3);
  }
  return 4294954514;
}

uint64_t bapspTranscode_breakAudioChain(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t, uint64_t);
  uint64_t v6;
  uint64_t v7;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!*(_BYTE *)(DerivedStorage + 40))
    return 0;
  v3 = DerivedStorage;
  MEMORY[0x19402EEEC](*(_QWORD *)(DerivedStorage + 24));
  if (*(_BYTE *)(v3 + 42))
  {
    v7 = 0;
  }
  else
  {
    v4 = *(_QWORD *)(v3 + 112);
    v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 64);
    if (v5)
    {
      v6 = v5(v4, 1);
      if ((_DWORD)v6
        || (v6 = bapspTranscode_stopMixer(a1, 1), (_DWORD)v6)
        || (CMNotificationCenterGetDefaultLocalCenter(), v6 = FigNotificationCenterRemoveWeakListeners(), (_DWORD)v6))
      {
        v7 = v6;
      }
      else
      {
        CMNotificationCenterGetDefaultLocalCenter();
        v7 = FigNotificationCenterRemoveWeakListeners();
        if (!(_DWORD)v7)
          *(_BYTE *)(v3 + 40) = 0;
      }
    }
    else
    {
      v7 = 4294954514;
    }
  }
  MEMORY[0x19402EF04](*(_QWORD *)(v3 + 24));
  return v7;
}

uint64_t bapspTranscode_stopMixer(uint64_t a1, int a2)
{
  uint64_t DerivedStorage;
  uint64_t v4;
  uint64_t result;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v4 = *(_QWORD *)(DerivedStorage + 104);
  if (a2)
  {
    result = FigAudioQueueOfflineMixerInterruptAndStop(v4);
    if ((_DWORD)result)
      return result;
    return FigAudioQueueOfflineMixerWaitUntilCompletelyStopped(*(_QWORD *)(DerivedStorage + 104));
  }
  result = FigAudioQueueOfflineMixerStop(v4);
  if (!(_DWORD)result)
    return FigAudioQueueOfflineMixerWaitUntilCompletelyStopped(*(_QWORD *)(DerivedStorage + 104));
  return result;
}

void bapspTranscode_decodeError(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5)
{
  bapspTranscode_postNotification(a2, (uint64_t)CFSTR("DecodeError"), a5);
}

void bapspTranscode_ranDry(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5)
{
  bapspTranscode_postNotification(a2, (uint64_t)CFSTR("RanDry"), a5);
}

void bapspTranscode_playResourceReleased(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5)
{
  uint64_t DerivedStorage;
  uint64_t v8;
  unsigned int (*v9)(uint64_t);
  uint64_t v10;
  unsigned int (*v11)(uint64_t, uint64_t);

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19402EEEC](*(_QWORD *)(DerivedStorage + 24));
  if (!*(_BYTE *)(DerivedStorage + 42) && !bapspTranscode_stopMixer((uint64_t)a2, 0))
  {
    v8 = *(_QWORD *)(DerivedStorage + 112);
    v9 = *(unsigned int (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
    if (v9)
    {
      if (!v9(v8))
      {
        v10 = *(_QWORD *)(DerivedStorage + 112);
        v11 = *(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 64);
        if (v11)
        {
          if (!v11(v10, 1))
            *(_BYTE *)(DerivedStorage + 41) = 0;
        }
      }
    }
  }
  MEMORY[0x19402EF04](*(_QWORD *)(DerivedStorage + 24));
  bapspTranscode_postNotification(a2, (uint64_t)CFSTR("PlayResourceReleased"), a5);
}

void bapspTranscode_postNotification(const void *a1, uint64_t a2, const void *a3)
{
  uint64_t DerivedStorage;
  NSObject *v7;
  _QWORD block[7];

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a3)
    CFRetain(a3);
  if (a1)
    CFRetain(a1);
  v7 = *(NSObject **)(DerivedStorage + 32);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __bapspTranscode_postNotification_block_invoke;
  block[3] = &__block_descriptor_tmp_83;
  block[4] = a2;
  block[5] = a1;
  block[6] = a3;
  dispatch_async(v7, block);
}

void __bapspTranscode_postNotification_block_invoke(uint64_t a1)
{
  const void *v2;
  const void *v3;

  CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterPostNotification();
  v2 = *(const void **)(a1 + 48);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
}

uint64_t bapspTranscode_stopAudioChain(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t);
  uint64_t v6;
  uint64_t (*v7)(uint64_t, uint64_t);
  uint64_t v8;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19402EEEC](*(_QWORD *)(DerivedStorage + 24));
  if (*(_BYTE *)(DerivedStorage + 42))
  {
    v8 = 0;
    goto LABEL_9;
  }
  v3 = bapspTranscode_stopMixer(a1, 0);
  if ((_DWORD)v3)
    goto LABEL_11;
  v4 = *(_QWORD *)(DerivedStorage + 112);
  v5 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
  if (!v5)
  {
LABEL_8:
    v8 = 4294954514;
    goto LABEL_9;
  }
  v3 = v5(v4);
  if ((_DWORD)v3)
  {
LABEL_11:
    v8 = v3;
    goto LABEL_9;
  }
  v6 = *(_QWORD *)(DerivedStorage + 112);
  v7 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 64);
  if (!v7)
    goto LABEL_8;
  v8 = v7(v6, 1);
  if (!(_DWORD)v8)
    *(_BYTE *)(DerivedStorage + 41) = 0;
LABEL_9:
  MEMORY[0x19402EF04](*(_QWORD *)(DerivedStorage + 24));
  return v8;
}

void bapspTranscode_offlineMixerMilestonePassed(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (a5)
  {
    FigCFDictionaryGetCMTimeIfPresent();
    if (dword_1EE2A31C8)
    {
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
  }
}

void bapspTranscode_offlineMixerDidReachEndOfOutputData(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5)
{
  uint64_t DerivedStorage;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  CFTypeRef v9;
  uint64_t v10;
  void (*v11)(uint64_t, CFTypeRef);
  CFTypeRef cf[23];

  cf[22] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  cf[0] = 0;
  if (dword_1EE2A31C8)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  MEMORY[0x19402EEEC](*(_QWORD *)(DerivedStorage + 24));
  if (!*(_BYTE *)(DerivedStorage + 42))
  {
    FigBufferedAirPlayAudioChainSubPipeSampleBufferCreateWithTimeStampAndMarker((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0CA2E30], cf);
    v9 = cf[0];
    if (cf[0])
    {
      v10 = *(_QWORD *)(DerivedStorage + 80);
      v11 = *(void (**)(uint64_t, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
      if (v11)
        v11(v10, v9);
    }
    if (*(_BYTE *)(DerivedStorage + 43))
    {
      bapspTranscode_postNotification(a2, (uint64_t)CFSTR("FinishedProcessingData"), a5);
      *(_BYTE *)(DerivedStorage + 43) = 0;
    }
  }
  MEMORY[0x19402EF04](*(_QWORD *)(DerivedStorage + 24));
  if (cf[0])
    CFRelease(cf[0]);
}

uint64_t FigBufferedAirPlayAudioChainSubPipeSampleBufferCreateWithTimeStampAndMarker(CFAllocatorRef allocator, const __CFString *a2, const void *a3, __int128 *a4, _QWORD *a5)
{
  char *sampleTimingArray;
  CMItemCount v11;
  char *v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  CMAttachmentBearerRef v17;
  CMTime v19;
  CMAttachmentBearerRef target;

  target = 0;
  if (!a5)
    return FigSignalErrorAt();
  if ((*((_BYTE *)a4 + 12) & 1) == 0)
  {
    sampleTimingArray = 0;
    v11 = 0;
LABEL_6:
    v16 = CMSampleBufferCreate(allocator, 0, 1u, 0, 0, 0, 0, v11, (const CMSampleTimingInfo *)sampleTimingArray, 0, 0, (CMSampleBufferRef *)&target);
    if (!(_DWORD)v16)
    {
      if (a2)
        CMSetAttachment(target, a2, a3, 1u);
      v17 = target;
      if (target)
        v17 = CFRetain(target);
      *a5 = v17;
    }
    if (sampleTimingArray)
      CFAllocatorDeallocate(allocator, sampleTimingArray);
    goto LABEL_14;
  }
  v12 = (char *)CFAllocatorAllocate(allocator, 72, 0);
  if (v12)
  {
    sampleTimingArray = v12;
    v11 = 1;
    CMTimeMake(&v19, 0, 1);
    v13 = *(_OWORD *)&v19.value;
    *((_QWORD *)sampleTimingArray + 2) = v19.epoch;
    *(_OWORD *)sampleTimingArray = v13;
    v14 = *a4;
    *((_QWORD *)sampleTimingArray + 5) = *((_QWORD *)a4 + 2);
    *(_OWORD *)(sampleTimingArray + 24) = v14;
    v15 = MEMORY[0x1E0CA2E18];
    *((_OWORD *)sampleTimingArray + 3) = *MEMORY[0x1E0CA2E18];
    *((_QWORD *)sampleTimingArray + 8) = *(_QWORD *)(v15 + 16);
    goto LABEL_6;
  }
  v16 = FigSignalErrorAt();
LABEL_14:
  if (target)
    CFRelease(target);
  return v16;
}

uint64_t bapspTranscode_setLoudnessInfo(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  const AudioStreamBasicDescription *StreamBasicDescription;
  const void *v7;
  uint64_t v8;
  const void *v9;
  int v10;
  CFAllocatorRef *v11;
  CFDictionaryRef v12;
  int mFormatID;
  BOOL v14;
  int v15;
  uint64_t FigBaseObject;
  void (*v17)(uint64_t, const __CFString *, uint64_t);
  uint64_t v18;
  CFDictionaryRef v20;
  uint64_t v21;
  void (*v22)(uint64_t, const __CFString *, CFDictionaryRef);
  const __CFAllocator *v23;
  const __CFString *v24;
  const void *v25;
  uint64_t v26;
  uint64_t v27;
  CMAttachmentBearerRef v28;
  uint64_t (*v29)(uint64_t, CMAttachmentBearerRef);
  __int128 v31;
  uint64_t v32;
  CMAttachmentBearerRef target;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  target = 0;
  MEMORY[0x19402EEEC](*(_QWORD *)(DerivedStorage + 24));
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(*(CMAudioFormatDescriptionRef *)(DerivedStorage + 136));
  v7 = *(const void **)(DerivedStorage + 120);
  *(_QWORD *)(DerivedStorage + 120) = a2;
  if (a2)
    CFRetain(a2);
  if (v7)
    CFRelease(v7);
  v8 = *(_QWORD *)(DerivedStorage + 120);
  if (!*(_BYTE *)(DerivedStorage + 128))
  {
    if (v8)
    {
      FigBaseObject = FigRenderPipelineGetFigBaseObject(*(_QWORD *)(DerivedStorage + 112));
      v17 = *(void (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
      if (v17)
        v17(FigBaseObject, CFSTR("LoudnessInfo"), v8);
    }
    goto LABEL_14;
  }
  v9 = (const void *)*MEMORY[0x1E0C92558];
  v10 = CFDictionaryContainsKey(*(CFDictionaryRef *)(DerivedStorage + 120), (const void *)*MEMORY[0x1E0C92558]);
  v11 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  v12 = 0;
  if (!v10)
    goto LABEL_34;
  mFormatID = StreamBasicDescription->mFormatID;
  if (mFormatID > 1885547314)
  {
    if (mFormatID > 1902469938)
    {
      if (mFormatID > 2053319474)
      {
        v14 = mFormatID == 2053464883;
        v15 = 2053319475;
      }
      else
      {
        v14 = mFormatID == 1902469939;
        v15 = 2053202739;
      }
    }
    else if (mFormatID > 1902207794)
    {
      v14 = mFormatID == 1902207795;
      v15 = 1902324531;
    }
    else
    {
      v14 = mFormatID == 1885547315;
      v15 = 1885692723;
    }
  }
  else if (mFormatID > 1667575090)
  {
    if (mFormatID > 1700998450)
    {
      v14 = mFormatID == 1700998451;
      v15 = 1885430579;
    }
    else
    {
      v14 = mFormatID == 1667575091;
      v15 = 1700997939;
    }
  }
  else if (mFormatID > 1667326770)
  {
    v14 = mFormatID == 1667326771;
    v15 = 1667574579;
  }
  else
  {
    v14 = mFormatID == 1633889587;
    v15 = 1667312947;
  }
  if (!v14 && mFormatID != v15)
    goto LABEL_34;
  *(_QWORD *)&v31 = CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 120), v9);
  v20 = CFDictionaryCreate(*v11, MEMORY[0x1E0C92558], (const void **)&v31, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!v20)
  {
LABEL_14:
    MEMORY[0x19402EF04](*(_QWORD *)(DerivedStorage + 24));
    v18 = 0;
    goto LABEL_41;
  }
  v12 = v20;
  v21 = FigRenderPipelineGetFigBaseObject(*(_QWORD *)(DerivedStorage + 112));
  v22 = *(void (**)(uint64_t, const __CFString *, CFDictionaryRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                            + 56);
  if (v22)
    v22(v21, CFSTR("LoudnessInfo"), v12);
LABEL_34:
  v23 = *v11;
  v24 = (const __CFString *)*MEMORY[0x1E0CA4E40];
  v25 = *(const void **)(DerivedStorage + 120);
  v31 = *(_OWORD *)a3;
  v32 = *(_QWORD *)(a3 + 16);
  v26 = FigBufferedAirPlayAudioChainSubPipeSampleBufferCreateWithTimeStampAndMarker(v23, v24, v25, &v31, &target);
  if ((_DWORD)v26)
  {
LABEL_37:
    v18 = v26;
    goto LABEL_39;
  }
  CMSetAttachment(target, v24, *(CFTypeRef *)(DerivedStorage + 120), 0);
  CMSetAttachment(target, CFSTR("SBUFForAutoOrder"), (CFTypeRef)*MEMORY[0x1E0C9AE50], 0);
  v27 = *(_QWORD *)(DerivedStorage + 80);
  v28 = target;
  v29 = *(uint64_t (**)(uint64_t, CMAttachmentBearerRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
  if (v29)
  {
    v26 = v29(v27, v28);
    goto LABEL_37;
  }
  v18 = 4294954514;
LABEL_39:
  MEMORY[0x19402EF04](*(_QWORD *)(DerivedStorage + 24));
  if (v12)
    CFRelease(v12);
LABEL_41:
  if (target)
    CFRelease(target);
  return v18;
}

uint64_t bapspTranscode_startAudioChain(uint64_t a1, CMTime *a2)
{
  uint64_t DerivedStorage;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t Float32;
  const void *v6;
  uint64_t FigBaseObject;
  uint64_t (*v8)(uint64_t, const __CFString *, const void *);
  uint64_t v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, CMTime *);
  uint64_t v12;
  uint64_t started;
  CMTime v15;
  CMTime v16;
  CMTime time;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19402EEEC](*(_QWORD *)(DerivedStorage + 24));
  if (*(_BYTE *)(DerivedStorage + 42) || *(_BYTE *)(DerivedStorage + 41))
    goto LABEL_17;
  if ((a2->flags & 0x1D) != 1)
  {
    started = FigSignalErrorAt();
    goto LABEL_19;
  }
  if (dword_1EE2A31C8)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  Float32 = FigCFNumberCreateFloat32();
  if (!Float32)
  {
LABEL_17:
    started = 0;
LABEL_19:
    MEMORY[0x19402EF04](*(_QWORD *)(DerivedStorage + 24));
    return started;
  }
  v6 = (const void *)Float32;
  FigBaseObject = FigRenderPipelineGetFigBaseObject(*(_QWORD *)(DerivedStorage + 112));
  v8 = *(uint64_t (**)(uint64_t, const __CFString *, const void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                           + 56);
  if (v8)
  {
    v9 = v8(FigBaseObject, CFSTR("OfflineAudioQueueRate"), v6);
    if ((_DWORD)v9 || (v9 = FigAudioQueueOfflineMixerReset(*(_QWORD *)(DerivedStorage + 104), 0), (_DWORD)v9))
    {
LABEL_20:
      started = v9;
      goto LABEL_15;
    }
    v10 = *(_QWORD *)(DerivedStorage + 112);
    v16 = *a2;
    v11 = *(uint64_t (**)(uint64_t, CMTime *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
    if (v11)
    {
      time = v16;
      v9 = v11(v10, &time);
      if (!(_DWORD)v9)
      {
        *(_OWORD *)&v15.value = *(_OWORD *)&a2->value;
        v15.epoch = a2->epoch;
        v12 = *(_QWORD *)(CMBaseObjectGetDerivedStorage() + 104);
        time = v15;
        v16 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E10];
        started = FigAudioQueueOfflineMixerStartRenderingForTimeRange(v12, &time, &v16);
        if (!(_DWORD)started)
          *(_BYTE *)(DerivedStorage + 41) = 1;
        goto LABEL_15;
      }
      goto LABEL_20;
    }
  }
  started = 4294954514;
LABEL_15:
  MEMORY[0x19402EF04](*(_QWORD *)(DerivedStorage + 24));
  CFRelease(v6);
  return started;
}

uint64_t bapspTranscode_assembleAudioChain()
{
  uint64_t DerivedStorage;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t FigBaseObject;
  void (*v5)(uint64_t, const __CFString *, uint64_t);
  uint64_t v6;
  void (*v7)(uint64_t, const __CFString *, uint64_t);
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, const __CFString *, uint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, const __CFString *, uint64_t);
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v15;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19402EEEC](*(_QWORD *)(DerivedStorage + 24));
  if (*(_BYTE *)(DerivedStorage + 42) || *(_BYTE *)(DerivedStorage + 40))
  {
LABEL_16:
    v15 = 0;
    goto LABEL_17;
  }
  v1 = CMBaseObjectGetDerivedStorage();
  CMNotificationCenterGetDefaultLocalCenter();
  v2 = FigNotificationCenterAddWeakListeners();
  if ((_DWORD)v2
    || (CMNotificationCenterGetDefaultLocalCenter(), v2 = FigNotificationCenterAddWeakListeners(), (_DWORD)v2))
  {
LABEL_18:
    v15 = v2;
    goto LABEL_17;
  }
  v3 = *MEMORY[0x1E0C9AE50];
  FigBaseObject = FigRenderPipelineGetFigBaseObject(*(_QWORD *)(v1 + 112));
  v5 = *(void (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
  if (v5)
    v5(FigBaseObject, CFSTR("HandleFormatDescriptionChanges"), v3);
  v6 = FigRenderPipelineGetFigBaseObject(*(_QWORD *)(v1 + 112));
  v7 = *(void (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
  if (v7)
    v7(v6, CFSTR("DisconnectOfflineMixerWhileResetting"), v3);
  v8 = *(_QWORD *)(v1 + 104);
  v9 = FigRenderPipelineGetFigBaseObject(*(_QWORD *)(v1 + 112));
  v10 = *(uint64_t (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
  if (v10)
  {
    v2 = v10(v9, CFSTR("OfflineMixer"), v8);
    if ((_DWORD)v2)
      goto LABEL_18;
    v11 = *(_QWORD *)(v1 + 96);
    v12 = *(_QWORD *)(v1 + 80);
    v13 = *(uint64_t (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                         + 56);
    if (v13)
    {
      v2 = v13(v11, CFSTR("DownstreamConsumer"), v12);
      if (!(_DWORD)v2)
      {
        *(_BYTE *)(v1 + 40) = 1;
        if (dword_1EE2A31C8)
        {
          os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        goto LABEL_16;
      }
      goto LABEL_18;
    }
  }
  v15 = 4294954514;
LABEL_17:
  MEMORY[0x19402EF04](*(_QWORD *)(DerivedStorage + 24));
  return v15;
}

uint64_t bapspTranscode_flush(uint64_t a1, __int128 *a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  uint64_t v6;
  uint64_t (*v7)(uint64_t);
  uint64_t v8;
  void (*v9)(uint64_t, __int128 *);
  uint64_t v10;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  MEMORY[0x19402EEEC](*(_QWORD *)(DerivedStorage + 24));
  if (*(_BYTE *)(DerivedStorage + 42))
  {
    v10 = 0;
    goto LABEL_10;
  }
  v5 = bapspTranscode_terminateQueueWithEndMarker();
  if (!(_DWORD)v5)
  {
    v6 = *(_QWORD *)(DerivedStorage + 112);
    v7 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
    if (!v7)
    {
      v10 = 4294954514;
      goto LABEL_10;
    }
    v5 = v7(v6);
    if (!(_DWORD)v5)
    {
      v8 = *(_QWORD *)(DerivedStorage + 112);
      v12 = *a2;
      v13 = *((_QWORD *)a2 + 2);
      v9 = *(void (**)(uint64_t, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 88);
      if (v9)
      {
        v14 = v12;
        v15 = v13;
        v9(v8, &v14);
      }
      v5 = bapspTranscode_stopMixer(a1, 1);
    }
  }
  v10 = v5;
LABEL_10:
  MEMORY[0x19402EF04](*(_QWORD *)(DerivedStorage + 24));
  return v10;
}

uint64_t bapspTranscode_terminateQueueWithEndMarker()
{
  uint64_t DerivedStorage;
  CFDictionaryRef v1;
  uint64_t v2;
  CMSampleBufferRef v3;
  void (*v4)(uint64_t, CMSampleBufferRef);
  uint64_t v5;
  CMTime end;
  CMTime start;
  CMTimeRange range;
  CMSampleBufferRef v10;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v10 = 0;
  if (CMSampleBufferCreate(*(CFAllocatorRef *)(DerivedStorage + 56), 0, 1u, 0, 0, 0, 0, 0, 0, 0, 0, &v10))
  {
    v5 = FigSignalErrorAt();
  }
  else
  {
    CMSetAttachment(v10, (CFStringRef)*MEMORY[0x1E0CA2658], (CFTypeRef)*MEMORY[0x1E0C9AE50], 1u);
    start = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
    end = start;
    CMTimeRangeFromTimeToTime(&range, &start, &end);
    v1 = CMTimeRangeCopyAsDictionary(&range, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
    CMSetAttachment(v10, (CFStringRef)*MEMORY[0x1E0CA4E60], v1, 1u);
    v2 = *(_QWORD *)(DerivedStorage + 64);
    v3 = v10;
    v4 = *(void (**)(uint64_t, CMSampleBufferRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
    if (v4)
      v4(v2, v3);
    *(_BYTE *)(DerivedStorage + 43) = 1;
    if (v1)
      CFRelease(v1);
    v5 = 0;
  }
  if (v10)
    CFRelease(v10);
  return v5;
}

uint64_t FigTTMLSetCreate(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t DerivedStorage;
  uint64_t v9;

  if (!a4)
    return FigSignalErrorAt();
  FigTTMLNodeGetClassID();
  v7 = CMDerivedObjectCreate();
  if (!(_DWORD)v7)
  {
    FigBytePumpGetFigBaseObject(0);
    DerivedStorage = CMBaseObjectGetDerivedStorage();
    v9 = FigTTMLInitializeNodeBaseStorage(DerivedStorage, (__int128 *)a3);
    if ((_DWORD)v9)
    {
      return v9;
    }
    else
    {
      v7 = FigTTMLAddCurrentElementAttributesToDictionary(a2, *(__CFDictionary **)(DerivedStorage + 24));
      if (!(_DWORD)v7)
      {
        *(_QWORD *)a3 = 0;
        *(_QWORD *)(a3 + 8) = 0;
        v7 = FigTTMLParseNode(a2, (uint64_t (*)(uint64_t, uint64_t *, CFTypeRef *))figTTMLSetConsumeChildNode, (uint64_t *)a3);
        if (!(_DWORD)v7)
          *a4 = 0;
      }
    }
  }
  return v7;
}

uint64_t figTTMLSetConsumeChildNode(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t DerivedStorage;
  uint64_t result;

  FigBytePumpGetFigBaseObject(*a2);
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  result = FigTTMLSkipNode(a1, a2, *(__CFArray **)(DerivedStorage + 128));
  if (a3)
  {
    if (!(_DWORD)result)
      *a3 = 0;
  }
  return result;
}

void figTTMLSet_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage;

  FigBytePumpGetFigBaseObject(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigTTMLReleaseNodeBaseStorage(DerivedStorage);
}

CFStringRef figTTMLSet_CopyDebugDesc(uint64_t a1)
{
  const void *v1;
  CFStringRef v2;

  FigBytePumpGetFigBaseObject(a1);
  CMBaseObjectGetDerivedStorage();
  v1 = (const void *)FigCFCopyCompactDescription();
  v2 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("set: %@"), v1);
  if (v1)
    CFRelease(v1);
  return v2;
}

uint64_t figTTMLSet_CopyChildNodeArray(const void *a1, CFMutableArrayRef *a2)
{
  const __CFAllocator *v3;

  if (a2)
  {
    v3 = CFGetAllocator(a1);
    *a2 = CFArrayCreateMutable(v3, 0, MEMORY[0x1E0C9B378]);
  }
  else
  {
    FigSignalErrorAt();
  }
  return 0;
}

uint64_t figTTMLSet_GetNodeType(uint64_t a1, _DWORD *a2)
{
  if (!a2)
    return FigSignalErrorAt();
  *a2 = 1;
  return 0;
}

uint64_t FigVideoCompositorCreateBasic(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  uint64_t DerivedStorage;

  FigVideoCompositorGetClassID();
  v4 = CMDerivedObjectCreate();
  if (!(_DWORD)v4)
  {
    DerivedStorage = CMBaseObjectGetDerivedStorage();
    *(_DWORD *)(DerivedStorage + 80) = 1065353216;
    *(_QWORD *)(DerivedStorage + 384) = 0x7FFFFFFFLL;
    *(_QWORD *)(DerivedStorage + 416) = 0x7FFFFFFFLL;
    *(_BYTE *)(DerivedStorage + 96) = 1;
    *(_DWORD *)(DerivedStorage + 248) = 0;
    *(_QWORD *)(DerivedStorage + 256) = FigDispatchQueueCreateWithPriority();
    *(_QWORD *)(DerivedStorage + 264) = FigDispatchQueueCreateWithPriority();
    *(_QWORD *)(DerivedStorage + 272) = FigDispatchQueueCreateWithPriority();
    *(_QWORD *)(DerivedStorage + 280) = FigDispatchQueueCreateWithPriority();
    *(_QWORD *)(DerivedStorage + 288) = dispatch_group_create();
    *a3 = 0;
  }
  return v4;
}

void basicVideoCompositor_Finalize()
{
  uint64_t DerivedStorage;
  NSObject *v1;
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v1 = *(NSObject **)(DerivedStorage + 256);
  if (v1)
  {
    dispatch_sync(v1, &__block_literal_global_65);
    dispatch_release(*(dispatch_object_t *)(DerivedStorage + 256));
    *(_QWORD *)(DerivedStorage + 256) = 0;
  }
  v2 = *(NSObject **)(DerivedStorage + 264);
  if (v2)
  {
    dispatch_sync(v2, &__block_literal_global_6);
    dispatch_release(*(dispatch_object_t *)(DerivedStorage + 264));
    *(_QWORD *)(DerivedStorage + 264) = 0;
  }
  v3 = *(NSObject **)(DerivedStorage + 272);
  if (v3)
  {
    dispatch_sync(v3, &__block_literal_global_8);
    dispatch_release(*(dispatch_object_t *)(DerivedStorage + 272));
    *(_QWORD *)(DerivedStorage + 272) = 0;
  }
  v4 = *(NSObject **)(DerivedStorage + 280);
  if (v4)
  {
    dispatch_sync(v4, &__block_literal_global_10_1);
    dispatch_release(*(dispatch_object_t *)(DerivedStorage + 280));
    *(_QWORD *)(DerivedStorage + 280) = 0;
  }
  v5 = *(NSObject **)(DerivedStorage + 288);
  if (v5)
  {
    dispatch_release(v5);
    *(_QWORD *)(DerivedStorage + 288) = 0;
  }
  v6 = *(const void **)(DerivedStorage + 32);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(DerivedStorage + 32) = 0;
  }
  v7 = *(const void **)(DerivedStorage + 40);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(DerivedStorage + 40) = 0;
  }
  v8 = *(const void **)(DerivedStorage + 48);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(DerivedStorage + 48) = 0;
  }
  v9 = *(const void **)(DerivedStorage + 56);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(DerivedStorage + 56) = 0;
  }
  v10 = *(const void **)(DerivedStorage + 64);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(DerivedStorage + 64) = 0;
  }
  v11 = *(const void **)(DerivedStorage + 72);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(DerivedStorage + 72) = 0;
  }
  v12 = *(const void **)(DerivedStorage + 104);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(DerivedStorage + 104) = 0;
  }
  v13 = *(const void **)(DerivedStorage + 160);
  if (v13)
  {
    CFRelease(v13);
    *(_QWORD *)(DerivedStorage + 160) = 0;
  }
  v14 = *(const void **)(DerivedStorage + 88);
  if (v14)
  {
    CFRelease(v14);
    *(_QWORD *)(DerivedStorage + 88) = 0;
  }
  bvc_releaseLayerArrays();
}

__CFString *basicVideoCompositor_CopyDebugDescription(const void *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  CFIndex v4;
  CFAllocatorRef v5;
  CFTypeRef cf;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  cf = 0;
  v4 = CFGetRetainCount(a1);
  v5 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigVideoCompositor_Basic %p retainCount: %ld allocator: %p "), a1, v4, v5);
  bvc_copyPerformanceDictionary((uint64_t)a1, (CFDictionaryRef *)&cf);
  if (cf)
  {
    CFStringAppendFormat(Mutable, 0, CFSTR(", performanceDictionary %@"), cf);
    if (cf)
      CFRelease(cf);
  }
  CFStringAppendFormat(Mutable, 0, CFSTR(">"));
  return Mutable;
}

uint64_t basicVideoCompositor_CopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, CFDictionaryRef *a4)
{
  uint64_t DerivedStorage;
  const __CFDictionary *DictionaryRepresentation;
  const void *v10;
  const __CFAllocator *v12;
  __int128 v13;
  CMTimeRange v14;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, CFSTR("RenderDimensions")))
  {
    DictionaryRepresentation = CGSizeCreateDictionaryRepresentation(*(CGSize *)DerivedStorage);
LABEL_3:
    *a4 = DictionaryRepresentation;
    return 0;
  }
  if (CFEqual(a2, CFSTR("RenderPixelAspectRatio")))
  {
    *a4 = *(CFDictionaryRef *)(DerivedStorage + 32);
    v10 = *(const void **)(DerivedStorage + 32);
    if (!v10)
      return 0;
    goto LABEL_21;
  }
  if (CFEqual(a2, CFSTR("RenderEdgeProcessingPixels")))
  {
    *a4 = *(CFDictionaryRef *)(DerivedStorage + 40);
    v10 = *(const void **)(DerivedStorage + 40);
    if (!v10)
      return 0;
    goto LABEL_21;
  }
  if (CFEqual(a2, CFSTR("DestinationPixelBufferDesiredAttributes")))
  {
    *a4 = *(CFDictionaryRef *)(DerivedStorage + 48);
    v10 = *(const void **)(DerivedStorage + 48);
    if (!v10)
      return 0;
    goto LABEL_21;
  }
  if (CFEqual(a2, CFSTR("DestinationPixelBufferDesiredYCbCrMatrix")))
  {
    *a4 = *(CFDictionaryRef *)(DerivedStorage + 56);
    v10 = *(const void **)(DerivedStorage + 56);
    if (!v10)
      return 0;
    goto LABEL_21;
  }
  if (CFEqual(a2, CFSTR("DestinationPixelBufferDesiredColorPrimaries")))
  {
    *a4 = *(CFDictionaryRef *)(DerivedStorage + 64);
    v10 = *(const void **)(DerivedStorage + 64);
    if (!v10)
      return 0;
    goto LABEL_21;
  }
  if (CFEqual(a2, CFSTR("DestinationPixelBufferDesiredTransferFunction")))
  {
    *a4 = *(CFDictionaryRef *)(DerivedStorage + 72);
    v10 = *(const void **)(DerivedStorage + 72);
    if (!v10)
      return 0;
LABEL_21:
    CFRetain(v10);
    return 0;
  }
  if (CFEqual(a2, CFSTR("SourcePixelBufferAttributes")))
    return bvc_createPixelBufferAttributesDictionary(a3, a4);
  if (CFEqual(a2, CFSTR("RenderScale")))
  {
    DictionaryRepresentation = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (const void *)(DerivedStorage + 80));
    goto LABEL_3;
  }
  if (CFEqual(a2, CFSTR("CanApplyRenderScale")))
  {
    DictionaryRepresentation = (const __CFDictionary *)*MEMORY[0x1E0C9AE50];
    if (!*MEMORY[0x1E0C9AE50])
      goto LABEL_3;
    goto LABEL_32;
  }
  if (CFEqual(a2, CFSTR("PixelBufferPoolSharingID")))
  {
    DictionaryRepresentation = *(const __CFDictionary **)(DerivedStorage + 88);
    if (!DictionaryRepresentation)
      goto LABEL_3;
LABEL_32:
    DictionaryRepresentation = (const __CFDictionary *)CFRetain(DictionaryRepresentation);
    goto LABEL_3;
  }
  if (CFEqual(a2, CFSTR("LoopTimeRange")))
  {
    v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v13 = *(_OWORD *)(DerivedStorage + 328);
    *(_OWORD *)&v14.start.value = *(_OWORD *)(DerivedStorage + 312);
    *(_OWORD *)&v14.start.epoch = v13;
    *(_OWORD *)&v14.duration.timescale = *(_OWORD *)(DerivedStorage + 344);
    DictionaryRepresentation = CMTimeRangeCopyAsDictionary(&v14, v12);
    goto LABEL_3;
  }
  if (CFEqual(a2, CFSTR("PerformanceDictionary")))
  {
    bvc_copyPerformanceDictionary(a1, a4);
    return 0;
  }
  if (CFEqual(a2, CFSTR("SourceColorConformanceCapabilityLevel")))
  {
    DictionaryRepresentation = (const __CFDictionary *)FigCFNumberCreateUInt32();
    goto LABEL_3;
  }
  return FigSignalErrorAt();
}

uint64_t basicVideoCompositor_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage;
  CFTypeID TypeID;
  CFTypeID v7;
  const void *Value;
  const void *v9;
  const void *v10;
  CFTypeID v11;
  CFTypeID v12;
  const void *v13;
  const void *v14;
  CFTypeID v15;
  CFIndex v16;
  CFTypeID v17;
  const void *ValueAtIndex;
  CFTypeID v19;
  CFTypeID v20;
  const void *v21;
  CFTypeID v23;
  CFTypeID v24;
  CFTypeID v25;
  float v26;
  CFTypeID v27;
  void *v28;
  CFTypeID v29;
  CFTypeID v30;
  CFTypeID v31;
  _OWORD *v32;
  __int128 v33;
  uint64_t v34;
  __int128 v35;
  CMTimeRange size;
  int valuePtr;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (CFEqual(CFSTR("RenderDimensions"), a2))
  {
    size.start.value = 0;
    *(_QWORD *)&size.start.timescale = 0;
    if (a3)
    {
      TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(a3)
        && CGSizeMakeWithDictionaryRepresentation((CFDictionaryRef)a3, (CGSize *)&size)
        && *(double *)&size.start.value > 0.0
        && *(double *)&size.start.timescale > 0.0)
      {
        *(_OWORD *)DerivedStorage = *(_OWORD *)&size.start.value;
LABEL_43:
        v21 = *(const void **)(DerivedStorage + 104);
        if (v21)
        {
          CFRelease(v21);
          *(_QWORD *)(DerivedStorage + 104) = 0;
        }
        v14 = 0;
        *(_BYTE *)(DerivedStorage + 96) = 1;
        return (uint64_t)v14;
      }
    }
    return FigSignalErrorAt();
  }
  if (CFEqual(CFSTR("RenderPixelAspectRatio"), a2))
  {
    if (!a3)
    {
      v13 = *(const void **)(DerivedStorage + 32);
      *(_QWORD *)(DerivedStorage + 32) = 0;
      if (!v13)
        goto LABEL_43;
      goto LABEL_42;
    }
    v7 = CFDictionaryGetTypeID();
    if (v7 != CFGetTypeID(a3))
      return FigSignalErrorAt();
    Value = CFDictionaryGetValue((CFDictionaryRef)a3, (const void *)*MEMORY[0x1E0CA8E60]);
    v9 = CFDictionaryGetValue((CFDictionaryRef)a3, (const void *)*MEMORY[0x1E0CA8E70]);
    LODWORD(size.start.value) = 0;
    valuePtr = 0;
    if (!Value)
      return FigSignalErrorAt();
    v10 = v9;
    v11 = CFNumberGetTypeID();
    if (v11 != CFGetTypeID(Value))
      return FigSignalErrorAt();
    CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, &size);
    if (SLODWORD(size.start.value) < 1)
      return FigSignalErrorAt();
    if (!v10)
      return FigSignalErrorAt();
    v12 = CFNumberGetTypeID();
    if (v12 != CFGetTypeID(v10))
      return FigSignalErrorAt();
    CFNumberGetValue((CFNumberRef)v10, kCFNumberIntType, &valuePtr);
    if (valuePtr < 1)
      return FigSignalErrorAt();
    v13 = *(const void **)(DerivedStorage + 32);
    *(_QWORD *)(DerivedStorage + 32) = a3;
    goto LABEL_33;
  }
  if (CFEqual(CFSTR("RenderEdgeProcessingPixels"), a2))
  {
    if (a3)
    {
      v15 = CFArrayGetTypeID();
      if (v15 == CFGetTypeID(a3) && CFArrayGetCount((CFArrayRef)a3) == 4)
      {
        v16 = 0;
        while (1)
        {
          v17 = CFNumberGetTypeID();
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a3, v16);
          if (v17 != CFGetTypeID(ValueAtIndex))
            break;
          if (++v16 == 4)
          {
            v13 = *(const void **)(DerivedStorage + 40);
            *(_QWORD *)(DerivedStorage + 40) = a3;
            goto LABEL_33;
          }
        }
      }
      return FigSignalErrorAt();
    }
    v13 = *(const void **)(DerivedStorage + 40);
    *(_QWORD *)(DerivedStorage + 40) = 0;
    if (!v13)
      goto LABEL_43;
LABEL_42:
    CFRelease(v13);
    goto LABEL_43;
  }
  if (!CFEqual(CFSTR("DestinationPixelBufferDesiredAttributes"), a2))
  {
    if (CFEqual(CFSTR("DestinationPixelBufferDesiredYCbCrMatrix"), a2))
    {
      if (!a3)
      {
        v14 = *(const void **)(DerivedStorage + 56);
        *(_QWORD *)(DerivedStorage + 56) = 0;
LABEL_65:
        if (!v14)
          return (uint64_t)v14;
        CFRelease(v14);
        return 0;
      }
      v20 = CFStringGetTypeID();
      if (v20 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v14 = *(const void **)(DerivedStorage + 56);
      *(_QWORD *)(DerivedStorage + 56) = a3;
LABEL_56:
      CFRetain(a3);
      goto LABEL_65;
    }
    if (CFEqual(CFSTR("DestinationPixelBufferDesiredColorPrimaries"), a2))
    {
      if (!a3)
      {
        v14 = *(const void **)(DerivedStorage + 64);
        *(_QWORD *)(DerivedStorage + 64) = 0;
        goto LABEL_65;
      }
      v23 = CFStringGetTypeID();
      if (v23 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v14 = *(const void **)(DerivedStorage + 64);
      *(_QWORD *)(DerivedStorage + 64) = a3;
      goto LABEL_56;
    }
    if (CFEqual(CFSTR("DestinationPixelBufferDesiredTransferFunction"), a2))
    {
      if (!a3)
      {
        v14 = *(const void **)(DerivedStorage + 72);
        *(_QWORD *)(DerivedStorage + 72) = 0;
        goto LABEL_65;
      }
      v24 = CFStringGetTypeID();
      if (v24 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v14 = *(const void **)(DerivedStorage + 72);
      *(_QWORD *)(DerivedStorage + 72) = a3;
      goto LABEL_56;
    }
    if (CFEqual(CFSTR("RenderScale"), a2))
    {
      LODWORD(size.start.value) = 1065353216;
      if (a3)
      {
        v25 = CFGetTypeID(a3);
        if (v25 != CFNumberGetTypeID()
          || (CFNumberGetValue((CFNumberRef)a3, kCFNumberFloatType, &size),
              v26 = *(float *)&size.start.value,
              *(float *)&size.start.value <= 0.0))
        {
          v14 = (const void *)FigSignalErrorAt();
          if ((_DWORD)v14)
            return (uint64_t)v14;
          v26 = *(float *)&size.start.value;
        }
      }
      else
      {
        v26 = 1.0;
      }
      *(float *)(DerivedStorage + 80) = v26;
      goto LABEL_43;
    }
    if (CFEqual(CFSTR("ClientPID"), a2))
    {
      if (!a3)
      {
        *(_DWORD *)(DerivedStorage + 252) = 0;
        goto LABEL_85;
      }
      v27 = CFGetTypeID(a3);
      if (v27 != CFNumberGetTypeID())
        return 0;
      v28 = (void *)(DerivedStorage + 252);
    }
    else
    {
      if (!CFEqual(CFSTR("WorkerThreadPriority"), a2))
      {
        if (CFEqual(CFSTR("HighQualityRendering"), a2))
        {
          if (a3)
          {
            v30 = CFGetTypeID(a3);
            if (v30 == CFBooleanGetTypeID())
              v14 = 0;
            else
              v14 = (const void *)FigSignalErrorAt();
            if (CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
            {
              *(_BYTE *)(DerivedStorage + 172) = 1;
              return (uint64_t)v14;
            }
          }
          else
          {
            v14 = 0;
          }
          *(_BYTE *)(DerivedStorage + 172) = 0;
          return (uint64_t)v14;
        }
        if (!CFEqual(CFSTR("PixelBufferPoolSharingID"), a2))
        {
          if (CFEqual(CFSTR("LoopTimeRange"), a2))
          {
            if (!a3)
            {
              v14 = 0;
              v34 = MEMORY[0x1E0CA2E40];
              v35 = *(_OWORD *)(MEMORY[0x1E0CA2E40] + 16);
              *(_OWORD *)(DerivedStorage + 312) = *MEMORY[0x1E0CA2E40];
              *(_OWORD *)(DerivedStorage + 328) = v35;
              *(_OWORD *)(DerivedStorage + 344) = *(_OWORD *)(v34 + 32);
              return (uint64_t)v14;
            }
            v31 = CFGetTypeID(a3);
            if (v31 == CFDictionaryGetTypeID())
            {
              v32 = (_OWORD *)(DerivedStorage + 312);
              CMTimeRangeMakeFromDictionary(&size, (CFDictionaryRef)a3);
              v14 = 0;
              v33 = *(_OWORD *)&size.start.epoch;
              *v32 = *(_OWORD *)&size.start.value;
              v32[1] = v33;
              v32[2] = *(_OWORD *)&size.duration.timescale;
              return (uint64_t)v14;
            }
          }
          return FigSignalErrorAt();
        }
        v14 = *(const void **)(DerivedStorage + 88);
        *(_QWORD *)(DerivedStorage + 88) = a3;
        if (!a3)
          goto LABEL_65;
        goto LABEL_56;
      }
      if (!a3)
      {
        *(_DWORD *)(DerivedStorage + 248) = 0;
        goto LABEL_85;
      }
      v29 = CFGetTypeID(a3);
      if (v29 != CFNumberGetTypeID())
        return 0;
      v28 = (void *)(DerivedStorage + 248);
    }
    CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, v28);
LABEL_85:
    basicVideoCompositor_updateDispatchQueuesClientPidAndWorkerThreadPriority();
    return 0;
  }
  if (!a3)
  {
    v13 = *(const void **)(DerivedStorage + 48);
    *(_QWORD *)(DerivedStorage + 48) = 0;
    if (!v13)
      goto LABEL_43;
    goto LABEL_42;
  }
  v19 = CFDictionaryGetTypeID();
  if (v19 == CFGetTypeID(a3))
  {
    v13 = *(const void **)(DerivedStorage + 48);
    *(_QWORD *)(DerivedStorage + 48) = a3;
LABEL_33:
    CFRetain(a3);
    if (!v13)
      goto LABEL_43;
    goto LABEL_42;
  }
  return FigSignalErrorAt();
}

void bvc_releaseLayerArrays()
{
  uint64_t DerivedStorage;
  uint64_t v1;
  uint64_t v2;
  CFTypeRef *v3;
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  CFTypeRef *v7;
  uint64_t v8;
  CFTypeRef *v9;
  uint64_t v10;
  CFTypeRef *v11;
  uint64_t v12;
  CFTypeRef *v13;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v1 = DerivedStorage;
  v2 = *(_QWORD *)(DerivedStorage + 176);
  if (v2)
  {
    v3 = *(CFTypeRef **)(DerivedStorage + 184);
    do
    {
      if (*v3)
      {
        CFRelease(*v3);
        *v3 = 0;
      }
      ++v3;
      --v2;
    }
    while (v2);
    v4 = *(_QWORD *)(v1 + 176);
    if (v4)
    {
      v5 = *(CFTypeRef **)(v1 + 192);
      do
      {
        if (*v5)
        {
          CFRelease(*v5);
          *v5 = 0;
        }
        ++v5;
        --v4;
      }
      while (v4);
      v6 = *(_QWORD *)(v1 + 176);
      if (v6)
      {
        v7 = *(CFTypeRef **)(v1 + 200);
        do
        {
          if (*v7)
          {
            CFRelease(*v7);
            *v7 = 0;
          }
          ++v7;
          --v6;
        }
        while (v6);
        v8 = *(_QWORD *)(v1 + 176);
        if (v8)
        {
          v9 = *(CFTypeRef **)(v1 + 208);
          do
          {
            if (*v9)
            {
              CFRelease(*v9);
              *v9 = 0;
            }
            ++v9;
            --v8;
          }
          while (v8);
          v10 = *(_QWORD *)(v1 + 176);
          if (v10)
          {
            v11 = *(CFTypeRef **)(v1 + 232);
            do
            {
              if (*v11)
              {
                CFRelease(*v11);
                *v11 = 0;
              }
              ++v11;
              --v10;
            }
            while (v10);
            v12 = *(_QWORD *)(v1 + 176);
            if (v12)
            {
              v13 = *(CFTypeRef **)(v1 + 240);
              do
              {
                if (*v13)
                {
                  CFRelease(*v13);
                  *v13 = 0;
                }
                ++v13;
                --v12;
              }
              while (v12);
            }
          }
        }
      }
    }
  }
  free(*(void **)(v1 + 184));
  *(_QWORD *)(v1 + 184) = 0;
  free(*(void **)(v1 + 192));
  *(_QWORD *)(v1 + 192) = 0;
  free(*(void **)(v1 + 200));
  *(_QWORD *)(v1 + 200) = 0;
  free(*(void **)(v1 + 208));
  *(_QWORD *)(v1 + 208) = 0;
  free(*(void **)(v1 + 216));
  *(_QWORD *)(v1 + 216) = 0;
  free(*(void **)(v1 + 224));
  *(_QWORD *)(v1 + 224) = 0;
  free(*(void **)(v1 + 232));
  *(_QWORD *)(v1 + 232) = 0;
  free(*(void **)(v1 + 240));
  *(_QWORD *)(v1 + 240) = 0;
}

void bvc_copyPerformanceDictionary(uint64_t a1, CFDictionaryRef *a2)
{
  uint64_t DerivedStorage;
  const __CFAllocator *v4;
  unsigned int v5;
  CFIndex v6;
  void **v7;
  int valuePtr;
  double v9;
  void *values[7];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  void *keys[7];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v25 = 0;
    v24 = 0u;
    v23 = 0u;
    v22 = 0u;
    v21 = 0u;
    v20 = 0u;
    v19 = 0u;
    v11 = 0u;
    v12 = 0u;
    v13 = 0u;
    v14 = 0u;
    v15 = 0u;
    v16 = 0u;
    v17 = 0;
    v9 = 0.0;
    DerivedStorage = CMBaseObjectGetDerivedStorage();
    keys[0] = CFSTR("NumberOfSourceFramesPassedThrough");
    v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (const void *)(DerivedStorage + 360));
    keys[1] = CFSTR("NumberOfSinglePassCompositions");
    values[1] = CFNumberCreate(v4, kCFNumberIntType, (const void *)(DerivedStorage + 364));
    keys[2] = CFSTR("NumberOfMultiPassCompositions");
    values[2] = CFNumberCreate(v4, kCFNumberIntType, (const void *)(DerivedStorage + 368));
    valuePtr = *(_DWORD *)(DerivedStorage + 376) + *(_DWORD *)(DerivedStorage + 372) + *(_DWORD *)(DerivedStorage + 380);
    keys[3] = CFSTR("TotalNumberOfLayers");
    values[3] = CFNumberCreate(v4, kCFNumberIntType, &valuePtr);
    keys[4] = CFSTR("TotalNumberOfLayersSkipped");
    values[4] = CFNumberCreate(v4, kCFNumberIntType, (const void *)(DerivedStorage + 372));
    keys[5] = CFSTR("TotalNumberOfLayersComposedUsingFastPath");
    values[5] = CFNumberCreate(v4, kCFNumberIntType, (const void *)(DerivedStorage + 376));
    keys[6] = CFSTR("TotalNumberOfLayersComposedUsingSlowPath");
    values[6] = CFNumberCreate(v4, kCFNumberIntType, (const void *)(DerivedStorage + 380));
    if (*(int *)(DerivedStorage + 408) < 1)
    {
      v5 = 7;
    }
    else
    {
      v9 = (float)((float)*(uint64_t *)(DerivedStorage + 384) / 1000000.0);
      *(_QWORD *)&v19 = CFSTR("MinPreprocessingTime");
      *(_QWORD *)&v11 = CFNumberCreate(v4, kCFNumberDoubleType, &v9);
      v9 = (float)((float)*(uint64_t *)(DerivedStorage + 392) / 1000000.0);
      *((_QWORD *)&v19 + 1) = CFSTR("MaxPreprocessingTime");
      *((_QWORD *)&v11 + 1) = CFNumberCreate(v4, kCFNumberDoubleType, &v9);
      v9 = (float)((float)*(uint64_t *)(DerivedStorage + 400) / (float)((float)*(int *)(DerivedStorage + 408) * 1000000.0));
      *(_QWORD *)&v20 = CFSTR("AveragePreprocessingTime");
      *(_QWORD *)&v12 = CFNumberCreate(v4, kCFNumberDoubleType, &v9);
      v5 = 10;
    }
    if (*(int *)(DerivedStorage + 440) >= 1)
    {
      v9 = (float)((float)*(uint64_t *)(DerivedStorage + 416) / 1000000.0);
      keys[v5] = CFSTR("MinProcessingTime");
      values[v5] = CFNumberCreate(v4, kCFNumberDoubleType, &v9);
      v9 = (float)((float)*(uint64_t *)(DerivedStorage + 424) / 1000000.0);
      keys[v5 + 1] = CFSTR("MaxProcessingTime");
      values[v5 + 1] = CFNumberCreate(v4, kCFNumberDoubleType, &v9);
      v9 = (float)((float)*(uint64_t *)(DerivedStorage + 432) / (float)((float)*(int *)(DerivedStorage + 440) * 1000000.0));
      keys[v5 + 2] = CFSTR("AverageProcessingTime");
      values[v5 + 2] = CFNumberCreate(v4, kCFNumberDoubleType, &v9);
      v5 += 3;
    }
    v6 = v5;
    v7 = values;
    *a2 = CFDictionaryCreate(v4, (const void **)keys, (const void **)values, v6, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    do
    {
      if (*v7)
        CFRelease(*v7);
      ++v7;
      --v6;
    }
    while (v6);
  }
}

uint64_t bvc_createPixelBufferAttributesDictionary(const __CFAllocator *a1, _QWORD *a2)
{
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v5;
  CFMutableArrayRef v6;
  __CFArray *v7;
  uint64_t v8;
  const __CFAllocator *v9;
  CFNumberRef v10;
  CFNumberRef v11;
  uint64_t PixelBufferAttributesWithIOSurfaceSupport;
  __CFArray *v13;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v15 = *(_OWORD *)"v024f024ARGB ";
  Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return FigSignalErrorAt();
  v5 = Mutable;
  v6 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  if (v6)
  {
    v7 = v6;
    v8 = 0;
    v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    do
    {
      v10 = CFNumberCreate(v9, kCFNumberSInt32Type, (char *)&v15 + v8);
      if (!v10)
      {
        PixelBufferAttributesWithIOSurfaceSupport = FigSignalErrorAt();
        CFRelease(v5);
        v13 = v7;
        goto LABEL_9;
      }
      v11 = v10;
      CFArrayAppendValue(v7, v10);
      CFRelease(v11);
      v8 += 4;
    }
    while (v8 != 16);
    CFDictionaryAddValue(v5, (const void *)*MEMORY[0x1E0CA9040], v7);
    CFRelease(v7);
    FigGetAlignmentForIOSurfaceOutput();
    PixelBufferAttributesWithIOSurfaceSupport = FigCreatePixelBufferAttributesWithIOSurfaceSupport();
    if (!(_DWORD)PixelBufferAttributesWithIOSurfaceSupport)
      *a2 = 0;
  }
  else
  {
    PixelBufferAttributesWithIOSurfaceSupport = FigSignalErrorAt();
  }
  v13 = v5;
LABEL_9:
  CFRelease(v13);
  return PixelBufferAttributesWithIOSurfaceSupport;
}

uint64_t bvc_CFDictionarySetInt(__CFDictionary *a1, const void *a2, int a3)
{
  CFNumberRef v5;
  uint64_t v6;
  int valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
  if (v5)
  {
    CFDictionarySetValue(a1, a2, v5);
    v6 = 0;
  }
  else
  {
    v6 = FigSignalErrorAt();
  }
  CFRelease(v5);
  return v6;
}

uint64_t basicVideoCompositor_updateDispatchQueuesClientPidAndWorkerThreadPriority()
{
  _QWORD *DerivedStorage;
  uint64_t result;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  if (DerivedStorage[32])
    FigDispatchQueueSetPriorityAndClientPID();
  if (DerivedStorage[33])
    FigDispatchQueueSetPriorityAndClientPID();
  if (DerivedStorage[34])
    FigDispatchQueueSetPriorityAndClientPID();
  result = DerivedStorage[35];
  if (result)
    return FigDispatchQueueSetPriorityAndClientPID();
  return result;
}

uint64_t basicVideoCompositor_RenderFrame(const void *a1, int a2, uint64_t a3, CVBufferRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, const __CFDictionary *a8, uint64_t a9, uint64_t a10)
{
  uint64_t DerivedStorage;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  const void *v20;
  __CFDictionary **v21;
  uint64_t v22;
  CGFloat a;
  const void *v24;
  const void *Value;
  float v26;
  float v27;
  const __CFArray *v28;
  const __CFArray *v29;
  CFTypeID v30;
  int64_t v31;
  char *v32;
  char *v33;
  CFIndex v34;
  uint64_t v35;
  uint64_t v36;
  const void *ValueAtIndex;
  const void *v38;
  CFTypeID TypeID;
  const void *v40;
  const void *v41;
  CFTypeID v42;
  uint64_t v43;
  CVBufferRef v44;
  __int128 v45;
  char v46;
  _OWORD *v47;
  const __CFArray *v48;
  const __CFArray *v49;
  CFTypeID v50;
  __int128 v51;
  __int128 v52;
  const __CFNumber *v53;
  const __CFNumber *v54;
  CFTypeID v55;
  const void *v56;
  const void *v57;
  CFTypeID v58;
  char v59;
  const __CFArray *v60;
  const __CFArray *v61;
  CFIndex v62;
  double v63;
  CFIndex v64;
  double v65;
  CFIndex v66;
  const __CFArray *v67;
  const __CFArray *v68;
  const __CFArray *v69;
  CFTypeID v70;
  __int128 v71;
  __int128 v72;
  char v73;
  const void *v74;
  const void *v75;
  CFTypeID v76;
  const void *v77;
  const void *v78;
  CFTypeID v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char v84;
  uint64_t updated;
  double v86;
  double v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  CGFloat v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  float v104;
  float v105;
  uint64_t v106;
  uint64_t v107;
  _QWORD *v108;
  void *v109;
  void *v110;
  void *v111;
  void *v112;
  void *v113;
  void *v114;
  void *v115;
  void *v116;
  uint64_t v117;
  char *v118;
  uint64_t v119;
  __CVBuffer *v120;
  int v121;
  int v122;
  void *v123;
  CGFloat v124;
  CGFloat v125;
  CGFloat v126;
  CGFloat v127;
  CGFloat v128;
  CGFloat v129;
  CGFloat v130;
  CGFloat v131;
  size_t Width;
  size_t Height;
  CFTypeRef v134;
  uint64_t v135;
  double v136;
  double v137;
  const void *v138;
  double v139;
  uint64_t v140;
  double v141;
  double v142;
  int v143;
  CGFloat v144;
  CGFloat x;
  CGFloat y;
  CGFloat v147;
  CGFloat v148;
  OSType v149;
  double v150;
  double v151;
  double v152;
  double v153;
  double v154;
  double v155;
  double b;
  double v157;
  double d;
  double c;
  float v160;
  float v161;
  CGFloat v162;
  double v163;
  double v164;
  double v165;
  double v166;
  double v167;
  double v168;
  _BOOL4 v169;
  _BOOL4 v170;
  double v171;
  uint64_t v172;
  size_t v173;
  double v174;
  double v175;
  double v176;
  double v177;
  int v178;
  double v179;
  double v180;
  int v181;
  int v182;
  __int128 v183;
  __int128 v184;
  char *v185;
  int v186;
  const void *v187;
  unint64_t v188;
  unint64_t v189;
  uint64_t v190;
  uint64_t *v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t *v194;
  uint64_t *v195;
  uint64_t v196;
  char *v197;
  float v198;
  uint64_t v199;
  int v200;
  uint64_t v201;
  uint64_t v202;
  char *v203;
  char *v204;
  float v205;
  char *v206;
  uint64_t v207;
  CVPixelBufferRef *v208;
  uint64_t v209;
  CVPixelBufferRef *v210;
  OSType v211;
  BOOL v212;
  const void *v214;
  double v215;
  double v216;
  double v217;
  double v218;
  unint64_t v219;
  unint64_t v220;
  __int128 v221;
  __int128 v222;
  __int128 v223;
  __int128 v224;
  int v225;
  uint64_t v226;
  CGFloat v227;
  CGFloat v228;
  double v229;
  BOOL v230;
  double v231;
  uint64_t v233;
  char *v234;
  __int128 v235;
  __int128 v236;
  CVBufferRef *v237;
  const __CFDictionary *v238;
  const void *v239;
  _BOOL4 v240;
  const void *v241;
  const void *v242;
  _BOOL4 v243;
  const void *v244;
  const void *v245;
  _BOOL4 v246;
  const void *v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t *v250;
  uint64_t v251;
  NSObject *v252;
  NSObject *v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t *v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t *v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t *v265;
  uint64_t v266;
  uint64_t v267;
  const void *v268;
  CFTypeRef v269;
  const void *v270;
  NSObject *v271;
  const __CFDictionary *v272;
  const void *v273;
  const void *v274;
  const void *v275;
  uint64_t v276;
  const __CFAllocator *v277;
  __CFDictionary *Mutable;
  const __CFAllocator *v279;
  CFNumberRef v280;
  CFNumberRef v281;
  __CFArray *v282;
  CFNumberRef v283;
  CFNumberRef v284;
  uint64_t PixelBufferAttributesWithIOSurfaceSupport;
  CFTypeRef v286;
  uint64_t v287;
  NSObject *v288;
  OSType v289;
  BOOL v290;
  __int128 v292;
  __int128 v293;
  __int128 v294;
  CGFloat v295;
  CGFloat v296;
  int v297;
  int v298;
  OSType PixelFormatType;
  BOOL v300;
  __int128 v302;
  __int128 v303;
  int v304;
  unint64_t v305;
  __CVPixelBufferPool *v306;
  uint64_t v308;
  CFIndex v309;
  const __CFArray *theArray;
  char theArrayb;
  CFArrayRef theArraya;
  void *v313;
  void *v314;
  void *v315;
  const __CFDictionary *v316;
  CVBufferRef *v317;
  size_t count;
  uint64_t counta;
  CFTypeRef cf;
  CFStringRef v322;
  const __CFString *v323;
  uint64_t v324;
  float v325;
  char *v326;
  void *v327;
  const void *v328;
  unint64_t v329;
  const __CFDictionary *v330;
  void *key;
  char keya;
  const void *v333;
  double v334;
  uint64_t *v335;
  uint64_t v336;
  __int128 v337;
  double v338;
  uint64_t *v339;
  char *v340;
  char *v341;
  __int128 r1;
  double r1a;
  CGFloat r1b;
  uint64_t r1c;
  const void *r1d;
  __int128 v347;
  uint64_t v348;
  int8x16_t v349;
  const void *v350;
  _QWORD v351[17];
  char v352;
  _QWORD v353[7];
  _QWORD block[12];
  CGAffineTransform v355;
  uint64_t v356;
  uint64_t *v357;
  uint64_t v358;
  char v359;
  uint64_t v360;
  uint64_t *v361;
  uint64_t v362;
  int v363;
  CGAffineTransform v364;
  CGAffineTransform valuePtr;
  double v366;
  double v367;
  double v368;
  CGRect r2;
  uint64_t v370;
  CGAffineTransform v371;
  CGAffineTransform t2;
  CGAffineTransform t1;
  CGAffineTransform v374;
  double v375;
  double v376;
  uint64_t v377;
  CGRect v378;
  CGRect v379;
  CGRect v380;
  CGRect v381;
  CGRect v382;
  CGRect v383;
  CGRect v384;
  CGRect v385;
  CGRect v386;
  CGRect v387;
  CGRect v388;
  CGRect v389;
  CGRect v390;
  CGRect v391;
  CGRect v392;
  CGRect v393;
  CGRect v394;
  CGRect v395;

  v377 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v15 = DerivedStorage;
  v16 = *MEMORY[0x1E0C9BAA8];
  v17 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
  *(_OWORD *)&v364.a = *MEMORY[0x1E0C9BAA8];
  *(_OWORD *)&v364.c = v17;
  v18 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 32);
  *(_OWORD *)&v364.tx = v18;
  v360 = 0;
  v361 = &v360;
  v362 = 0x2000000000;
  v363 = 0;
  v356 = 0;
  v357 = &v356;
  v358 = 0x2000000000;
  v359 = 0;
  if (!DerivedStorage || !*(_QWORD *)(DerivedStorage + 296))
  {
    v22 = FigSignalErrorAt();
    goto LABEL_381;
  }
  if (*(double *)DerivedStorage == 0.0 || *(double *)(DerivedStorage + 8) == 0.0)
  {
    v107 = FigSignalErrorAt();
    goto LABEL_376;
  }
  v337 = v18;
  r1 = v17;
  v347 = v16;
  if (!*(_BYTE *)(DerivedStorage + 96))
    goto LABEL_10;
  v19 = CMBaseObjectGetDerivedStorage();
  v21 = (__CFDictionary **)(v19 + 160);
  v20 = *(const void **)(v19 + 160);
  if (v20)
  {
    CFRelease(v20);
    *v21 = 0;
  }
  v374.a = 0.0;
  t1.a = 0.0;
  v22 = FigVideoCompositorUtilityCopyRenderPixelBufferDimensionsAndCleanAperture(*(_QWORD *)(v19 + 32), *(_QWORD *)(v19 + 40), &v374, &t1, v19 + 112, v21, *(double *)v19, *(double *)(v19 + 8), *(float *)(v19 + 80));
  if ((_DWORD)v22)
  {
LABEL_381:
    v107 = v22;
    v256 = 0;
    v272 = 0;
    v273 = 0;
    v274 = 0;
    v247 = 0;
    v33 = 0;
    goto LABEL_363;
  }
  a = t1.a;
  *(CGFloat *)(v19 + 16) = v374.a;
  *(CGFloat *)(v19 + 24) = a;
  *(_DWORD *)(v19 + 168) = 875704438;
  *(_BYTE *)(v15 + 96) = 0;
LABEL_10:
  v24 = (const void *)*MEMORY[0x1E0C9AE50];
  Value = CFDictionaryGetValue(a8, CFSTR("ContainsTweening"));
  v26 = 0.0;
  if (v24 == Value)
  {
    *(_OWORD *)&v374.a = *(_OWORD *)a9;
    v374.c = *(CGFloat *)(a9 + 16);
    FigVideoCompositionInstructionGetNormalizedTime(a8, (CMTime *)&v374);
    v26 = v27;
  }
  v28 = (const __CFArray *)CFDictionaryGetValue(a8, CFSTR("LayerStack"));
  v324 = v15;
  cf = a1;
  v316 = a8;
  v317 = a4;
  if (v28 && (v29 = v28, v333 = Value, v30 = CFArrayGetTypeID(), v30 == CFGetTypeID(v29)))
  {
    v328 = v24;
    v31 = CFArrayGetCount(v29);
    v32 = (char *)malloc_type_calloc(v31, 0x160uLL, 0x1020040E645271BuLL);
    v33 = v32;
    if (!v32)
    {
      v256 = 0;
      v272 = 0;
      v273 = 0;
      v274 = 0;
      v247 = 0;
      v107 = 4294954510;
      goto LABEL_363;
    }
    if (v31 >= 1)
    {
      v34 = 0;
      v35 = 0;
      v322 = (CFStringRef)(v15 + 112);
      v36 = (uint64_t)v32;
      v340 = v32;
      while (1)
      {
        LODWORD(valuePtr.a) = 0;
        ValueAtIndex = CFArrayGetValueAtIndex(v29, v34);
        if (!ValueAtIndex)
          goto LABEL_360;
        v38 = ValueAtIndex;
        count = v35;
        TypeID = CFDictionaryGetTypeID();
        if (TypeID != CFGetTypeID(v38))
          goto LABEL_360;
        v40 = CFDictionaryGetValue((CFDictionaryRef)v38, CFSTR("SourceVideoTrackID"));
        if (!v40)
          goto LABEL_360;
        v41 = v40;
        v42 = CFNumberGetTypeID();
        if (v42 != CFGetTypeID(v41))
          goto LABEL_360;
        CFNumberGetValue((CFNumberRef)v41, kCFNumberSInt32Type, &valuePtr);
        if (a2 < 1)
          goto LABEL_360;
        v43 = 0;
        v35 = count;
        while (*(_DWORD *)(a3 + 4 * v43) != LODWORD(valuePtr.a))
        {
          if (a2 == ++v43)
            goto LABEL_360;
        }
        v44 = v317[v43];
        *(_QWORD *)v36 = v44;
        *(_QWORD *)(v36 + 8) = v43;
        if (!v44)
        {
          v33 = v340;
          goto LABEL_73;
        }
        *(_OWORD *)(v36 + 32) = v347;
        *(_OWORD *)(v36 + 48) = r1;
        *(_OWORD *)(v36 + 64) = v337;
        *(_DWORD *)(v36 + 24) = 1065353216;
        v45 = *(_OWORD *)(MEMORY[0x1E0C9D5E0] + 16);
        *(_OWORD *)(v36 + 128) = *MEMORY[0x1E0C9D5E0];
        *(_OWORD *)(v36 + 144) = v45;
        *(_QWORD *)(v36 + 16) = v34;
        v309 = v34;
        if (v328 != v333
          || (v60 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v38, CFSTR("TweenedAffineMatrix"))) == 0)
        {
LABEL_28:
          v46 = 0;
          goto LABEL_29;
        }
        v61 = v60;
        v62 = CFArrayGetCount(v60);
        if (v62 < 4 || (v62 & 1) != 0)
        {
          v106 = FigSignalErrorAt();
          if (!(_DWORD)v106)
            goto LABEL_30;
          goto LABEL_361;
        }
        theArray = v61;
        v63 = 0.0;
        v64 = 1;
        v65 = 0.0;
        while (1)
        {
          v66 = v62;
          t2.a = 0.0;
          v371.a = 0.0;
          memset(&v374, 0, sizeof(v374));
          v67 = (const __CFArray *)CFArrayGetValueAtIndex(theArray, v64);
          FigGetCGAffineTransformFrom3x2MatrixArray(v67, &v374.a);
          t1 = v374;
          FigVideoCompositionInstructionCGAffineTransformDecompose(&t1, 1, 0, 0, &t2.a, &v371.a, 0);
          if (v65 == 0.0)
          {
            v65 = t2.a;
            v62 = v66;
          }
          else
          {
            v62 = v66;
            if (vabdd_f64(v65, t2.a) > 0.001)
              goto LABEL_77;
          }
          if (v63 != 0.0)
            break;
          v63 = v371.a;
LABEL_52:
          v64 += 2;
          if (v64 >= v62)
            goto LABEL_28;
        }
        if (vabdd_f64(v63, v371.a) <= 0.001)
          goto LABEL_52;
LABEL_77:
        v46 = 1;
LABEL_29:
        *(_BYTE *)(v36 + 329) = v46;
LABEL_30:
        v47 = (_OWORD *)(v36 + 32);
        v48 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v38, CFSTR("ConstantAffineMatrix"));
        if (v48)
        {
          v49 = v48;
          v50 = CFArrayGetTypeID();
          if (v50 == CFGetTypeID(v49))
          {
            FigGetCGAffineTransformFrom3x2MatrixArray(v49, &v374.a);
            v52 = *(_OWORD *)&v374.c;
            v51 = *(_OWORD *)&v374.tx;
            *v47 = *(_OWORD *)&v374.a;
            *(_OWORD *)(v36 + 48) = v52;
            *(_OWORD *)(v36 + 64) = v51;
            goto LABEL_33;
          }
LABEL_360:
          v106 = FigSignalErrorAt();
LABEL_361:
          v107 = v106;
          v15 = v324;
          v33 = v340;
LABEL_362:
          v256 = 0;
          v272 = 0;
          v273 = 0;
          v274 = 0;
          v247 = 0;
          goto LABEL_363;
        }
LABEL_33:
        v53 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v38, CFSTR("ConstantOpacity"));
        if (v53)
        {
          v54 = v53;
          v55 = CFNumberGetTypeID();
          if (v55 == CFGetTypeID(v54))
          {
            LODWORD(v374.a) = 0;
            CFNumberGetValue(v54, kCFNumberFloat32Type, &v374);
            *(_DWORD *)(v36 + 24) = LODWORD(v374.a);
          }
        }
        v56 = CFDictionaryGetValue((CFDictionaryRef)v38, CFSTR("ConstantCropRectangle"));
        if (v56)
        {
          v57 = v56;
          v58 = CFDictionaryGetTypeID();
          if (v58 == CFGetTypeID(v57)
            && !CGRectMakeWithDictionaryRepresentation((CFDictionaryRef)v57, (CGRect *)(v36 + 128)))
          {
            goto LABEL_360;
          }
        }
        if (v328 == v333)
        {
          v68 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v38, CFSTR("TweenedAffineMatrix"));
          if (v68 && (v69 = v68, v70 = CFArrayGetTypeID(), v70 == CFGetTypeID(v69)))
          {
            FigVideoCompositionInstructionEvaluateTweenedAffineMatrix(v69, (uint64_t)&v374, v26);
            v72 = *(_OWORD *)&v374.c;
            v71 = *(_OWORD *)&v374.tx;
            *v47 = *(_OWORD *)&v374.a;
            *(_OWORD *)(v36 + 48) = v72;
            *(_OWORD *)(v36 + 64) = v71;
            v73 = 1;
          }
          else
          {
            v73 = 0;
          }
          v74 = CFDictionaryGetValue((CFDictionaryRef)v38, CFSTR("TweenedOpacity"));
          if (v74)
          {
            v75 = v74;
            theArrayb = v73;
            v76 = CFArrayGetTypeID();
            v212 = v76 == CFGetTypeID(v75);
            v73 = theArrayb;
            if (v212)
              *(float *)(v36 + 24) = FigVideoCompositionInstructionEvaluateTweenedOpacity(v75, v26);
          }
          v77 = CFDictionaryGetValue((CFDictionaryRef)v38, CFSTR("TweenedCropRectangle"));
          if (v77 && (v78 = v77, v79 = CFArrayGetTypeID(), v79 == CFGetTypeID(v78)))
          {
            FigVideoCompositionInstructionEvaluateTweenedCropRectangle((uint64_t)v78, v26);
            *(_QWORD *)(v36 + 128) = v80;
            *(_QWORD *)(v36 + 136) = v81;
            *(_QWORD *)(v36 + 144) = v82;
            *(_QWORD *)(v36 + 152) = v83;
            v84 = 1;
          }
          else
          {
            v84 = 0;
          }
          v33 = v340;
          v59 = v84 | v73;
        }
        else
        {
          v59 = 0;
          v33 = v340;
        }
        *(_BYTE *)(v36 + 328) = v59;
        updated = bvc_updateSourcebufferCharacteristics(v36);
        if ((_DWORD)updated)
          goto LABEL_385;
        v86 = (double)*(uint64_t *)(v36 + 184);
        v87 = (double)*(uint64_t *)(v36 + 192);
        v88 = *(_OWORD *)(v36 + 48);
        *(_OWORD *)&t1.a = *v47;
        *(_OWORD *)&t1.c = v88;
        *(_OWORD *)&t1.tx = *(_OWORD *)(v36 + 64);
        CGAffineTransformScale(&v374, &t1, v86 / v87, 1.0);
        v90 = *(_OWORD *)&v374.c;
        v89 = *(_OWORD *)&v374.tx;
        *v47 = *(_OWORD *)&v374.a;
        *(_OWORD *)(v36 + 48) = v90;
        *(_OWORD *)(v36 + 64) = v89;
        *(double *)&v89 = -*(double *)(v36 + 232);
        v91 = -*(double *)(v36 + 240);
        v92 = *(_OWORD *)(v36 + 48);
        *(_OWORD *)&t1.a = *v47;
        *(_OWORD *)&t1.c = v92;
        *(_OWORD *)&t1.tx = *(_OWORD *)(v36 + 64);
        CGAffineTransformTranslate(&v374, &t1, *(CGFloat *)&v89, v91);
        v94 = *(_OWORD *)&v374.c;
        v93 = *(_OWORD *)&v374.tx;
        *v47 = *(_OWORD *)&v374.a;
        *(_OWORD *)(v36 + 48) = v94;
        *(_OWORD *)(v36 + 64) = v93;
        CGAffineTransformMakeScale(&v364, *(float *)(v324 + 80), *(float *)(v324 + 80));
        v95 = *v47;
        v96 = *(_OWORD *)(v36 + 64);
        *(_OWORD *)&t1.c = *(_OWORD *)(v36 + 48);
        *(_OWORD *)&t1.tx = v96;
        t2 = v364;
        *(_OWORD *)&t1.a = v95;
        CGAffineTransformConcat(&v374, &t1, &t2);
        v98 = *(_OWORD *)&v374.c;
        v97 = *(_OWORD *)&v374.tx;
        *v47 = *(_OWORD *)&v374.a;
        *(_OWORD *)(v36 + 48) = v98;
        *(_OWORD *)(v36 + 64) = v97;
        v99 = *v47;
        v100 = *(_OWORD *)(v36 + 64);
        *(_OWORD *)&t1.c = *(_OWORD *)(v36 + 48);
        *(_OWORD *)&t1.tx = v100;
        v101 = *(_OWORD *)&v322->data;
        *(_OWORD *)&t2.a = *(_OWORD *)&v322->isa;
        *(_OWORD *)&t2.c = v101;
        *(_OWORD *)&t2.tx = *(_OWORD *)&v322[1].isa;
        *(_OWORD *)&t1.a = v99;
        CGAffineTransformConcat(&v374, &t1, &t2);
        v103 = *(_OWORD *)&v374.c;
        v102 = *(_OWORD *)&v374.tx;
        *v47 = *(_OWORD *)&v374.a;
        *(_OWORD *)(v36 + 48) = v103;
        *(_OWORD *)(v36 + 64) = v102;
        v104 = *(float *)(v36 + 24);
        v105 = 0.0;
        if (v104 <= 0.0 || (v105 = 1.0, v104 >= 1.0))
          *(float *)(v36 + 24) = v105;
        updated = bvc_computeScaledTransformAndTransformedRect(*(_QWORD *)(v324 + 16), *(_QWORD *)(v324 + 24), *(const void **)(v324 + 160), v36);
        v34 = v309;
        if ((_DWORD)updated)
        {
LABEL_385:
          v107 = updated;
          v15 = v324;
          goto LABEL_362;
        }
        v35 = count + 1;
        v36 += 352;
LABEL_73:
        if (++v34 == v31)
        {
          v15 = v324;
          goto LABEL_80;
        }
      }
    }
    v35 = 0;
  }
  else
  {
    v31 = 0;
    v35 = 0;
    v33 = 0;
  }
LABEL_80:
  if (*(_QWORD *)(v15 + 176) != v31)
  {
    bvc_releaseLayerArrays();
    v108 = (_QWORD *)CMBaseObjectGetDerivedStorage();
    v108[22] = v31;
    v109 = malloc_type_calloc(v31, 8uLL, 0x2004093837F09uLL);
    v108[23] = v109;
    if (!v109)
      goto LABEL_378;
    v110 = malloc_type_calloc(v31, 8uLL, 0x2004093837F09uLL);
    v108[24] = v110;
    if (!v110)
      goto LABEL_378;
    v111 = malloc_type_calloc(v31, 8uLL, 0x2004093837F09uLL);
    v108[25] = v111;
    if (!v111)
      goto LABEL_378;
    v112 = malloc_type_calloc(v31, 8uLL, 0x2004093837F09uLL);
    v108[26] = v112;
    if (!v112)
      goto LABEL_378;
    v113 = malloc_type_calloc(v31, 4uLL, 0x100004052888210uLL);
    v108[27] = v113;
    if (!v113
      || (v114 = malloc_type_calloc(v31, 0x20uLL, 0x1000040E0EAB150uLL), (v108[28] = v114) == 0)
      || (v115 = malloc_type_calloc(v31, 8uLL, 0x2004093837F09uLL), (v108[29] = v115) == 0)
      || (v116 = malloc_type_calloc(v31, 8uLL, 0x2004093837F09uLL), (v108[30] = v116) == 0))
    {
LABEL_378:
      v308 = FigSignalErrorAt();
      if ((_DWORD)v308)
      {
LABEL_383:
        v107 = v308;
        goto LABEL_362;
      }
    }
  }
  counta = v35;
  v341 = v33;
  if (v35 >= 1)
  {
    v117 = 0;
    v323 = (const __CFString *)*MEMORY[0x1E0CA8E68];
    v314 = *(void **)(MEMORY[0x1E0C9D648] + 8);
    v315 = *(void **)MEMORY[0x1E0C9D648];
    theArraya = *(CFArrayRef *)(MEMORY[0x1E0C9D648] + 24);
    v313 = *(void **)(MEMORY[0x1E0C9D648] + 16);
    v118 = (char *)v35;
    while (1)
    {
      v119 = (uint64_t)&v33[v117];
      v120 = *(__CVBuffer **)v119;
      if (*(_QWORD *)v119)
        break;
LABEL_193:
      v117 += 352;
      --v118;
      v33 = v341;
      if (!v118)
        goto LABEL_197;
    }
    v326 = v118;
    v121 = *(unsigned __int8 *)(v119 + 329);
    v122 = *(unsigned __int8 *)(v119 + 328);
    v325 = *(float *)(v15 + 80);
    v123 = *(void **)(v15 + 160);
    v355 = *(CGAffineTransform *)(v119 + 32);
    v125 = *(double *)(v119 + 264);
    v124 = *(double *)(v119 + 272);
    v126 = *(double *)(v119 + 280);
    v127 = *(double *)(v119 + 288);
    v128 = *(double *)(v119 + 200);
    v129 = *(double *)(v119 + 208);
    v130 = *(double *)(v119 + 216);
    v131 = *(double *)(v119 + 224);
    v329 = *(_QWORD *)(v15 + 16);
    key = v123;
    v327 = *(void **)(v15 + 24);
    v374 = v355;
    v370 = 0;
    memset(&r2, 0, sizeof(r2));
    v368 = 0.0;
    v367 = 0.0;
    v366 = 0.0;
    Width = CVPixelBufferGetWidth(v120);
    Height = CVPixelBufferGetHeight(v120);
    v134 = CVBufferCopyAttachment(v120, v323, 0);
    FigVideoCompositorUtilityGetPixelAspectRatio((CFTypeID)v134, (_DWORD *)&v370 + 1, &v370);
    v348 = SHIDWORD(v370);
    v135 = (int)v370;
    if (v122)
    {
      r1a = v127;
      v136 = (double)Width;
      v137 = (double)Height;
      v334 = 0.0;
      v338 = 0.0;
      v138 = v134;
      v139 = v124;
      v140 = (int)v370;
      v141 = v125;
      v142 = v126;
      v143 = v121;
    }
    else
    {
      t2 = v374;
      CGAffineTransformInvert(&t1, &t2);
      v378.origin.x = v128;
      v378.origin.y = v129;
      v378.size.width = v130;
      v378.size.height = v131;
      v379 = CGRectApplyAffineTransform(v378, &t1);
      v392.origin.x = v125;
      r1b = v124;
      v392.origin.y = v124;
      v392.size.width = v126;
      v144 = v127;
      v392.size.height = v127;
      v380 = CGRectIntersection(v379, v392);
      v381 = CGRectStandardize(v380);
      x = v381.origin.x;
      y = v381.origin.y;
      v147 = v381.size.width;
      v148 = v381.size.height;
      v149 = (CVPixelBufferGetPixelFormatType(v120) - 875704422) & 0xFFFFFFEF;
      v382.origin.x = x;
      v382.origin.y = y;
      v382.size.width = v147;
      v382.size.height = v148;
      v383 = CGRectIntegral(v382);
      v334 = v383.origin.x;
      v338 = v383.origin.y;
      v136 = v383.size.width;
      v137 = v383.size.height;
      if (!v149)
      {
        if (((int)v383.origin.x & 1) != 0)
          v150 = v383.origin.x + -1.0;
        else
          v150 = v383.origin.x;
        if (((int)v383.origin.x & 1) != 0)
          v151 = v383.size.width + 1.0;
        else
          v151 = v383.size.width;
        v152 = v383.origin.y;
        if (((int)v383.origin.y & 1) != 0)
          v152 = v383.origin.y + -1.0;
        v334 = v150;
        v338 = v152;
        if (((int)v383.origin.y & 1) != 0)
          v153 = v383.size.height + 1.0;
        else
          v153 = v383.size.height;
        if (((int)v151 & 1) != 0)
          v136 = v151 + 1.0;
        else
          v136 = v151;
        if (((int)v153 & 1) != 0)
          v137 = v153 + 1.0;
        else
          v137 = v153;
      }
      v138 = v134;
      v143 = v121;
      v384.origin.x = v125;
      v384.origin.y = r1b;
      v384.size.width = v126;
      v384.size.height = v144;
      v393.origin.x = v334;
      v393.origin.y = v338;
      v393.size.width = v136;
      v393.size.height = v137;
      v385 = CGRectIntersection(v384, v393);
      v142 = v385.size.width;
      r1a = v385.size.height;
      v141 = v385.origin.x - v334;
      v139 = v385.origin.y - v338;
      v371 = v374;
      CGAffineTransformTranslate(&t2, &v371, v334, v338);
      v374 = t2;
      Width = (uint64_t)v136;
      Height = (uint64_t)v137;
      v140 = v135;
    }
    v118 = v326;
    if (v143)
    {
      v371 = v374;
      CGAffineTransformScale(&t2, &v371, (float)(1.0 / v325), (float)(1.0 / v325));
      v374 = t2;
      v154 = v325;
      v368 = v325;
      v367 = v325;
      v155 = v325;
    }
    else
    {
      t2 = v374;
      FigVideoCompositionInstructionCGAffineTransformDecompose(&t2, 0, 0, &v374, &v368, &v367, 0);
      b = 0.0;
      v157 = 0.0;
      if (fabs(v374.a) >= 0.000001)
      {
        v157 = 1.0;
        if (fabs(v374.a + -1.0) >= 0.000001)
        {
          v157 = v374.a;
          if (fabs(v374.a + 1.0) < 0.000001)
            v157 = -1.0;
        }
      }
      v374.a = v157;
      if (fabs(v374.b) >= 0.000001)
      {
        b = 1.0;
        if (fabs(v374.b + -1.0) >= 0.000001)
        {
          b = v374.b;
          if (fabs(v374.b + 1.0) < 0.000001)
            b = -1.0;
        }
      }
      v374.b = b;
      d = 0.0;
      c = 0.0;
      if (fabs(v374.c) >= 0.000001)
      {
        c = 1.0;
        if (fabs(v374.c + -1.0) >= 0.000001)
        {
          c = v374.c;
          if (fabs(v374.c + 1.0) < 0.000001)
            c = -1.0;
        }
      }
      v374.c = c;
      if (fabs(v374.d) >= 0.000001)
      {
        d = 1.0;
        if (fabs(v374.d + -1.0) >= 0.000001)
        {
          d = v374.d;
          if (fabs(v374.d + 1.0) < 0.000001)
            d = -1.0;
        }
      }
      v374.d = d;
      v155 = v368;
      v154 = v367;
    }
    if (fabs(v155 + -1.0) <= 0.00001 && fabs(v154 + -1.0) <= 0.00001)
    {
      v162 = v141;
      v163 = v136;
      if (v143)
        goto LABEL_135;
    }
    else
    {
      v160 = v155;
      Width = (unint64_t)(v160 * v136 + 1.0) & 0xFFFFFFFFFFFFFFFELL;
      v161 = v154;
      Height = (unint64_t)(v161 * v137 + 1.0) & 0xFFFFFFFFFFFFFFFELL;
      CGAffineTransformMakeScale(&t2, (double)Width / v136, (double)Height / v137);
      v371 = t2;
      v386.origin.x = v141;
      v386.origin.y = v139;
      v386.size.width = v142;
      v386.size.height = r1a;
      v387 = CGRectApplyAffineTransform(v386, &v371);
      v162 = v387.origin.x;
      v139 = v387.origin.y;
      v142 = v387.size.width;
      r1a = v387.size.height;
      v163 = v136;
      v348 = (uint64_t)(v136 * (double)Height * (double)(int)v348);
      v140 = (uint64_t)(v137 * (double)Width * (double)(int)v140);
      if (v143)
      {
LABEL_135:
        v164 = v163;
        v165 = v162;
        goto LABEL_186;
      }
    }
    v371 = v374;
    memset(&t2, 0, sizeof(t2));
    FigVideoCompositionInstructionCGAffineTransformDecompose(&v371, 0, 1, &t2, 0, 0, &v366);
    v166 = fmod(v366 * 57.2957795 + 360.0, 360.0);
    v167 = 0.0;
    v164 = v163;
    if (fabs(v166) < 0.001)
    {
      v168 = v162;
      v165 = v139;
      goto LABEL_139;
    }
    v167 = 90.0;
    v168 = v162;
    v165 = v139;
    if (fabs(v166 + -90.0) >= 0.001)
    {
      if (fabs(v166 + -180.0) >= 0.001)
      {
        if (fabs(v166 + -270.0) >= 0.001)
        {
          v167 = v166;
          if (fabs(v166 + -360.0) < 0.001)
            v167 = 0.0;
LABEL_139:
          v366 = v167;
          v169 = v167 == 90.0;
          v170 = v167 == 270.0;
          if (v167 != 270.0 && v167 != 90.0 && v167 != 180.0)
          {
            v366 = 0.0;
            v171 = r1a;
            v139 = v165;
            v165 = v168;
            v172 = v140;
            v140 = v348;
            v173 = Height;
            Height = Width;
LABEL_185:
            Width = Height;
            v348 = v140;
            r1a = v171;
            v140 = v172;
            Height = v173;
LABEL_186:
            bvc_getCleanApertureRect(key, v329, (unint64_t)v327, &r2.origin.x);
            v182 = v181;
            if (!v181)
            {
              t2 = v374;
              v388.origin.x = v165;
              v388.origin.y = v139;
              v388.size.width = v142;
              v388.size.height = r1a;
              v389 = CGRectApplyAffineTransform(v388, &t2);
              v390 = CGRectIntersection(v389, r2);
              v391 = CGRectStandardize(v390);
              v184 = *(_OWORD *)&v374.c;
              v183 = *(_OWORD *)&v374.tx;
              *(_OWORD *)(v119 + 80) = *(_OWORD *)&v374.a;
              *(_OWORD *)(v119 + 96) = v184;
              *(_QWORD *)(v119 + 160) = Width;
              v185 = &v341[v117];
              *((_QWORD *)v185 + 21) = Height;
              *(double *)(v119 + 296) = v334;
              *((double *)v185 + 38) = v338;
              *((double *)v185 + 39) = v164;
              *((double *)v185 + 40) = v137;
              v186 = (int)v366;
              *(_OWORD *)(v119 + 112) = v183;
              *(_DWORD *)(v119 + 176) = v186;
              *(_QWORD *)(v119 + 184) = v348;
              *((_QWORD *)v185 + 24) = v140;
              *(double *)(v119 + 264) = v165;
              *(double *)(v119 + 272) = v139;
              *(double *)(v119 + 280) = v142;
              *(double *)(v119 + 288) = r1a;
              *(CGRect *)(v119 + 200) = v391;
            }
            if (v138)
              CFRelease(v138);
            v15 = v324;
            if (v182)
            {
              v187 = *(const void **)(v324 + 160);
              v188 = *(_QWORD *)(v324 + 16);
              v189 = *(_QWORD *)(v324 + 24);
              v190 = bvc_updateSourcebufferCharacteristics(v119);
              if ((_DWORD)v190
                || (v190 = bvc_computeScaledTransformAndTransformedRect(v188, v189, v187, v119), (_DWORD)v190))
              {
                v107 = v190;
                v256 = 0;
                v272 = 0;
                v273 = 0;
                v274 = 0;
                v247 = 0;
                v33 = v341;
                goto LABEL_363;
              }
            }
            goto LABEL_193;
          }
LABEL_149:
          v174 = 0.0;
          v175 = 0.0;
          if (fabs(t2.a) >= 0.000001)
          {
            v175 = 1.0;
            if (fabs(t2.a + -1.0) >= 0.000001)
            {
              v175 = t2.a;
              if (fabs(t2.a + 1.0) < 0.000001)
                v175 = -1.0;
            }
          }
          v374.a = v175;
          if (fabs(t2.b) >= 0.000001)
          {
            v174 = 1.0;
            if (fabs(t2.b + -1.0) >= 0.000001)
            {
              v174 = t2.b;
              if (fabs(t2.b + 1.0) < 0.000001)
                v174 = -1.0;
            }
          }
          v374.b = v174;
          v176 = 0.0;
          v177 = 0.0;
          if (fabs(t2.c) >= 0.000001)
          {
            v177 = 1.0;
            if (fabs(t2.c + -1.0) >= 0.000001)
            {
              v177 = t2.c;
              if (fabs(t2.c + 1.0) < 0.000001)
                v177 = -1.0;
            }
          }
          v374.c = v177;
          if (fabs(t2.d) >= 0.000001)
          {
            v176 = 1.0;
            if (fabs(t2.d + -1.0) >= 0.000001)
            {
              v176 = t2.d;
              if (fabs(t2.d + 1.0) < 0.000001)
                v176 = -1.0;
            }
          }
          v374.d = v176;
          v178 = (int)v167;
          if ((int)v167 > 179)
          {
            if (v178 != 180)
            {
              if (v178 == 270)
              {
                v139 = (double)Width - v142 - v168;
                v171 = v142;
                v142 = r1a;
                goto LABEL_175;
              }
              goto LABEL_172;
            }
            v139 = (double)Height - r1a - v165;
            v165 = (double)Width - v142 - v168;
            v171 = r1a;
          }
          else
          {
            if (v178)
            {
              if (v178 == 90)
              {
                v165 = (double)Height - r1a - v165;
                v171 = v142;
                v142 = r1a;
                v139 = v168;
                goto LABEL_175;
              }
LABEL_172:
              v171 = *(double *)&theArraya;
              v142 = *(double *)&v313;
              v139 = *(double *)&v314;
              v165 = *(double *)&v315;
              goto LABEL_175;
            }
            v171 = r1a;
            v139 = v165;
            v165 = v168;
          }
LABEL_175:
          if (v170 || v169)
          {
            v172 = v348;
            v173 = Width;
          }
          else
          {
            v172 = v140;
            v140 = v348;
            v173 = Height;
            Height = Width;
          }
          switch(v178)
          {
            case 270:
              v180 = (double)-(uint64_t)v173;
              valuePtr = v374;
              v179 = 0.0;
              break;
            case 180:
              v179 = (double)-(uint64_t)Height;
              v180 = (double)-(uint64_t)v173;
              valuePtr = v374;
              break;
            case 90:
              v179 = (double)-(uint64_t)Height;
              valuePtr = v374;
              v180 = 0.0;
              break;
            default:
              goto LABEL_185;
          }
          CGAffineTransformTranslate(&v371, &valuePtr, v179, v180);
          v374 = v371;
          goto LABEL_185;
        }
        v167 = 270.0;
      }
      else
      {
        v167 = 180.0;
      }
    }
    v366 = v167;
    v169 = v167 == 90.0;
    v170 = v167 == 270.0;
    goto LABEL_149;
  }
LABEL_197:
  v191 = v361;
  v192 = CMBaseObjectGetDerivedStorage();
  v193 = counta;
  v194 = (uint64_t *)malloc_type_calloc(counta, 8uLL, 0x100004000313F17uLL);
  v339 = v194;
  if (!v194)
  {
    v308 = FigSignalErrorAt();
    if (!(_DWORD)v308)
    {
      v199 = 0;
      keya = 1;
      goto LABEL_251;
    }
    goto LABEL_383;
  }
  r1c = counta - 1;
  if (counta < 1)
  {
    v199 = 0;
    v200 = 3;
    keya = 1;
    goto LABEL_250;
  }
  v195 = v194;
  v196 = 0;
  v197 = v33 + 160;
  while (1)
  {
    v198 = *((float *)v197 - 34);
    if (v198 != 0.0)
      break;
    ++v196;
    v197 += 352;
    if (counta == v196)
      goto LABEL_205;
  }
  if (v198 == 1.0)
  {
    PixelFormatType = CVPixelBufferGetPixelFormatType(*((CVPixelBufferRef *)v197 - 20));
    v300 = PixelFormatType == 846624121 || PixelFormatType == 875704438;
    if (v300 || PixelFormatType == 875704422)
    {
      v302 = *((_OWORD *)v197 - 5);
      v303 = *((_OWORD *)v197 - 3);
      *(_OWORD *)&v374.c = *((_OWORD *)v197 - 4);
      *(_OWORD *)&v374.tx = v303;
      *(_OWORD *)&v374.a = v302;
      if (CGAffineTransformIsIdentity(&v374))
      {
        bvc_doesPixelBufferFillCanvasExactly(*(_QWORD *)v197, *((_QWORD *)v197 + 1), *(_QWORD *)(v192 + 16), *(_QWORD *)(v192 + 24), *(const void **)(v192 + 160), *((CGFloat *)v197 + 13), *((CGFloat *)v197 + 14), *((CGFloat *)v197 + 15), *((CGFloat *)v197 + 16));
        if (v304)
        {
          keya = 0;
          *v195 = v196;
          v199 = 1;
          v200 = 1;
          goto LABEL_250;
        }
      }
    }
  }
LABEL_205:
  v335 = v191;
  v201 = 0;
  v202 = 0;
  v203 = 0;
  v204 = v33;
  while (1)
  {
    v205 = *((float *)v204 + 6);
    if (v205 != 0.0)
      break;
    v206 = v203;
    v207 = v202;
LABEL_209:
    ++v201;
    v204 += 352;
    v202 = v207;
    v203 = v206;
    if (counta == v201)
      goto LABEL_210;
  }
  v206 = v204;
  v207 = v201;
  if (!v203)
    goto LABEL_209;
  if (v205 == 1.0)
  {
    v289 = CVPixelBufferGetPixelFormatType(*(CVPixelBufferRef *)v204);
    v290 = v289 == 846624121 || v289 == 875704438;
    if (v290 || v289 == 875704422)
    {
      v292 = *((_OWORD *)v203 + 6);
      *(_OWORD *)&v374.a = *((_OWORD *)v203 + 5);
      *(_OWORD *)&v374.c = v292;
      *(_OWORD *)&v374.tx = *((_OWORD *)v203 + 7);
      if (CGAffineTransformIsIdentity(&v374))
      {
        v293 = *((_OWORD *)v204 + 5);
        v294 = *((_OWORD *)v204 + 7);
        *(_OWORD *)&v374.c = *((_OWORD *)v204 + 6);
        *(_OWORD *)&v374.tx = v294;
        *(_OWORD *)&v374.a = v293;
        if (CGAffineTransformIsIdentity(&v374))
        {
          v295 = (double)CVPixelBufferGetWidth(*(CVPixelBufferRef *)v203);
          v394.size.height = (double)CVPixelBufferGetHeight(*(CVPixelBufferRef *)v203);
          v394.origin.x = 0.0;
          v394.origin.y = 0.0;
          v394.size.width = v295;
          if (CGRectContainsRect(*(CGRect *)(v203 + 296), v394))
          {
            v296 = (double)CVPixelBufferGetWidth(*(CVPixelBufferRef *)v204);
            v395.size.height = (double)CVPixelBufferGetHeight(*(CVPixelBufferRef *)v204);
            v395.origin.x = 0.0;
            v395.origin.y = 0.0;
            v395.size.width = v296;
            if (CGRectContainsRect(*(CGRect *)(v204 + 296), v395))
            {
              bvc_doesPixelBufferFillCanvasExactly(*((_QWORD *)v203 + 20), *((_QWORD *)v203 + 21), *(_QWORD *)(v192 + 16), *(_QWORD *)(v192 + 24), *(const void **)(v192 + 160), *((CGFloat *)v203 + 33), *((CGFloat *)v203 + 34), *((CGFloat *)v203 + 35), *((CGFloat *)v203 + 36));
              if (v297)
              {
                bvc_doesPixelBufferFillCanvasExactly(*((_QWORD *)v204 + 20), *((_QWORD *)v204 + 21), *(_QWORD *)(v192 + 16), *(_QWORD *)(v192 + 24), *(const void **)(v192 + 160), *((CGFloat *)v204 + 33), *((CGFloat *)v204 + 34), *((CGFloat *)v204 + 35), *((CGFloat *)v204 + 36));
                if (v298)
                {
                  keya = 0;
                  *v339 = v202;
                  v339[1] = v201;
                  v199 = 2;
                  v200 = 2;
                  goto LABEL_249;
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_210:
  v208 = (CVPixelBufferRef *)&v33[352 * counta];
  keya = 1;
  v349 = (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFFFELL);
  v209 = counta - 1;
  do
  {
    v210 = v208;
    v208 -= 44;
    if (((CVPixelBufferGetPixelFormatType(*v208) - 875704422) & 0xFFFFFFEF) == 0)
      *((int8x16_t *)v210 - 12) = vandq_s8(*((int8x16_t *)v210 - 12), v349);
    if (*((float *)v210 - 82) == 1.0)
    {
      v211 = CVPixelBufferGetPixelFormatType(*v208);
      v212 = v211 == 846624121 || v211 == 875704438;
      if (v212 || v211 == 875704422)
      {
        v214 = *(const void **)(v192 + 160);
        v215 = *((double *)v210 - 11);
        v216 = *((double *)v210 - 10);
        v217 = *((double *)v210 - 9);
        v218 = *((double *)v210 - 8);
        v219 = *(_QWORD *)(v192 + 16);
        v220 = *(_QWORD *)(v192 + 24);
        v221 = *((_OWORD *)v210 - 17);
        v222 = *((_OWORD *)v210 - 15);
        *(_OWORD *)&v371.c = *((_OWORD *)v210 - 16);
        *(_OWORD *)&v371.tx = v222;
        *(_OWORD *)&v371.a = v221;
        memset(&valuePtr, 0, 32);
        v223 = *((_OWORD *)v210 - 17);
        v224 = *((_OWORD *)v210 - 15);
        *(_OWORD *)&t1.c = *((_OWORD *)v210 - 16);
        *(_OWORD *)&t1.tx = v224;
        *(_OWORD *)&t1.a = v223;
        if (BVCUtilityIsAffineTransformInvertible(&t1.a))
        {
          bvc_getCleanApertureRect(v214, v219, v220, &valuePtr.a);
          if (!v225)
          {
            t1 = v371;
            if (BVCUtilityIsAffineTransformInvertible(&t1.a))
            {
              t2 = v371;
              CGAffineTransformInvert(&t1, &t2);
              v226 = 0;
              v374.a = t1.tx + t1.c * valuePtr.b + t1.a * valuePtr.a;
              v374.b = t1.ty + t1.d * valuePtr.b + t1.b * valuePtr.a;
              v227 = t1.c * (valuePtr.b + valuePtr.d);
              v228 = t1.d * (valuePtr.b + valuePtr.d);
              v374.c = t1.tx + v227 + t1.a * valuePtr.a;
              v374.d = t1.ty + v228 + t1.b * valuePtr.a;
              v374.tx = t1.tx + v227 + t1.a * (valuePtr.a + valuePtr.c);
              v374.ty = t1.ty + v228 + t1.b * (valuePtr.a + valuePtr.c);
              v375 = t1.tx + t1.c * valuePtr.b + t1.a * (valuePtr.a + valuePtr.c);
              v376 = t1.ty + t1.d * valuePtr.b + t1.b * (valuePtr.a + valuePtr.c);
              while (1)
              {
                v229 = *(double *)((char *)&v374.a + v226);
                v230 = v229 >= v215 && v229 <= v215 + v217;
                if (!v230)
                  break;
                v231 = *(double *)((char *)&v374.b + v226);
                if (v231 < v216 || v231 > v216 + v218)
                  break;
                v226 += 16;
                if (v226 == 64)
                {
                  keya = 0;
                  ++*(_DWORD *)(v192 + 372);
                  r1c = v209;
                  break;
                }
              }
            }
          }
        }
      }
    }
    v230 = v209-- <= 0;
  }
  while (!v230);
  if (r1c < 0)
  {
    v199 = 0;
    v200 = 3;
    v15 = v324;
    v33 = v341;
    v193 = counta;
  }
  else
  {
    v199 = 0;
    v233 = 0;
    v33 = v341;
    v234 = v341 + 224;
    v15 = v324;
    v193 = counta;
    do
    {
      if (*((float *)v234 - 50) != 0.0)
      {
        v235 = *((_OWORD *)v234 - 9);
        v236 = *((_OWORD *)v234 - 7);
        *(_OWORD *)&v374.c = *((_OWORD *)v234 - 8);
        *(_OWORD *)&v374.tx = v236;
        *(_OWORD *)&v374.a = v235;
        if (BVCUtilityIsAffineTransformInvertible(&v374.a) && !CGRectIsEmpty(*(CGRect *)(v234 - 24)))
          v339[v199++] = v233;
      }
      ++v233;
      v234 += 352;
    }
    while (r1c + 1 != v233);
    v200 = 3;
  }
LABEL_249:
  v191 = v335;
LABEL_250:
  *((_DWORD *)v191 + 6) = v200;
LABEL_251:
  if (v193 >= 1)
  {
    v237 = (CVBufferRef *)&v33[352 * v193 - 352];
    goto LABEL_254;
  }
  v237 = v317;
  if (a2 < 1)
  {
LABEL_258:
    v240 = 0;
    v238 = 0;
    v239 = *(const void **)(v15 + 56);
    goto LABEL_259;
  }
LABEL_254:
  if (!*v237)
    goto LABEL_258;
  v238 = CVBufferCopyAttachments(*v237, kCVAttachmentMode_ShouldPropagate);
  v239 = *(const void **)(v15 + 56);
  v240 = v238 != 0;
  if (!v239 && v238)
  {
    v239 = CFDictionaryGetValue(v238, (const void *)*MEMORY[0x1E0CA8EE8]);
    v240 = 1;
  }
LABEL_259:
  if (v239)
    v241 = v239;
  else
    v241 = (const void *)*MEMORY[0x1E0CA8F18];
  if (v241)
    CFRetain(v241);
  v242 = *(const void **)(v15 + 64);
  if (v242)
    v243 = 0;
  else
    v243 = v240;
  if (v243)
    v242 = CFDictionaryGetValue(v238, (const void *)*MEMORY[0x1E0CA8D68]);
  if (v242)
    v244 = v242;
  else
    v244 = (const void *)*MEMORY[0x1E0CA8D88];
  if (v244)
    CFRetain(v244);
  v245 = *(const void **)(v15 + 72);
  if (v245)
    v246 = 0;
  else
    v246 = v240;
  if (v246)
    v245 = CFDictionaryGetValue(v238, (const void *)*MEMORY[0x1E0CA8E98]);
  r1d = v244;
  v350 = v241;
  v330 = v238;
  if (v245)
    v247 = v245;
  else
    v247 = (const void *)*MEMORY[0x1E0CA8EB0];
  if (v247)
    CFRetain(v247);
  v248 = MEMORY[0x1E0C809B0];
  v15 = v324;
  v336 = v199;
  if (v199)
  {
    v249 = v199;
    v250 = v339;
    do
    {
      v251 = *v250++;
      v253 = *(NSObject **)(v324 + 280);
      v252 = *(NSObject **)(v324 + 288);
      block[0] = v248;
      block[1] = 0x40000000;
      block[2] = __basicVideoCompositor_RenderFrame_block_invoke;
      block[3] = &unk_1E2FA65A8;
      block[7] = cf;
      block[8] = v324;
      block[9] = v350;
      block[10] = v244;
      block[11] = v247;
      block[4] = &v360;
      block[5] = &v356;
      block[6] = &v341[352 * v251];
      v254 = v248;
      dispatch_group_async(v252, v253, block);
      v248 = v254;
      --v249;
    }
    while (v249);
  }
  dispatch_group_wait(*(dispatch_group_t *)(v324 + 288), 0xFFFFFFFFFFFFFFFFLL);
  if (*((_BYTE *)v357 + 24))
    *((_DWORD *)v361 + 6) = 3;
  v255 = a10;
  v33 = v341;
  v257 = v336;
  v256 = v339;
  if (!v336)
  {
    if (*((_DWORD *)v361 + 6) != 1)
      goto LABEL_308;
    goto LABEL_303;
  }
  v259 = *(_QWORD *)(v324 + 392);
  v258 = *(_QWORD *)(v324 + 400);
  v260 = v339;
  v261 = v336;
  v262 = *(_QWORD *)(v324 + 384);
  do
  {
    v263 = *v260++;
    v264 = (*(_QWORD *)&v341[352 * v263 + 344] - *(_QWORD *)&v341[352 * v263 + 336]) / 1000;
    v258 += v264;
    if (v262 >= (int)v264)
      v262 = (int)v264;
    if (v259 <= (int)v264)
      v259 = (int)v264;
    --v261;
  }
  while (v261);
  *(_DWORD *)(v324 + 408) += v336;
  *(_QWORD *)(v324 + 392) = v259;
  *(_QWORD *)(v324 + 400) = v258;
  *(_QWORD *)(v324 + 384) = v262;
  if (*((_DWORD *)v361 + 6) == 1)
  {
LABEL_303:
    ++*(_DWORD *)(v324 + 360);
    v269 = CFRetain(*(CFTypeRef *)&v341[352 * *v339]);
    if (*(_BYTE *)(v324 + 172))
    {
      v270 = *(const void **)(v324 + 104);
      if (v270)
      {
        CFRelease(v270);
        *(_QWORD *)(v324 + 104) = 0;
      }
    }
    dispatch_sync(*(dispatch_queue_t *)(v324 + 272), &__block_literal_global_18_0);
    v271 = *(NSObject **)(v324 + 272);
    v353[0] = MEMORY[0x1E0C809B0];
    v353[1] = 0x40000000;
    v353[2] = __basicVideoCompositor_RenderFrame_block_invoke_3;
    v353[3] = &__block_descriptor_tmp_19_2;
    v353[4] = v324;
    v353[5] = a10;
    v353[6] = v269;
    dispatch_async(v271, v353);
    v107 = 0;
    v272 = v330;
    v273 = v350;
LABEL_307:
    v274 = r1d;
    goto LABEL_363;
  }
  v265 = v339;
  v266 = v336;
  do
  {
    v267 = *v265++;
    v268 = *(const void **)&v341[352 * v267];
    if (v268)
      CFRetain(v268);
    --v266;
  }
  while (v266);
LABEL_308:
  v275 = *(const void **)(v324 + 104);
  v272 = v330;
  v273 = v350;
  if (v275)
  {
LABEL_328:
    v286 = CFRetain(v275);
    goto LABEL_329;
  }
  v276 = CMBaseObjectGetDerivedStorage();
  v374.a = 0.0;
  t1.a = 0.0;
  LODWORD(v355.a) = 0;
  LODWORD(r2.origin.x) = 0;
  LOBYTE(v368) = 0;
  v277 = CFGetAllocator(cf);
  Mutable = CFDictionaryCreateMutable(v277, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  LODWORD(v371.a) = *(_QWORD *)(v276 + 16);
  v279 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v280 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &v371);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA90E0], v280);
  CFRelease(v280);
  LODWORD(valuePtr.a) = *(_QWORD *)(v276 + 24);
  v281 = CFNumberCreate(v279, kCFNumberSInt32Type, &valuePtr);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA8FD8], v281);
  CFRelease(v281);
  v282 = CFArrayCreateMutable(v279, 0, MEMORY[0x1E0C9B378]);
  if (!v282)
  {
    PixelBufferAttributesWithIOSurfaceSupport = FigSignalErrorAt();
    goto LABEL_317;
  }
  LODWORD(t2.a) = *(_DWORD *)(v276 + 168);
  v283 = CFNumberCreate(v279, kCFNumberSInt32Type, &t2);
  if (v283)
  {
    v284 = v283;
    CFArrayAppendValue(v282, v283);
    CFRelease(v284);
    goto LABEL_312;
  }
  v107 = FigSignalErrorAt();
  if (!(_DWORD)v107)
  {
LABEL_312:
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA9040], v282);
    FigGetAlignmentForIOSurfaceOutput();
    PixelBufferAttributesWithIOSurfaceSupport = bvc_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E0CA9048], SLODWORD(v355.a));
    if (!(_DWORD)PixelBufferAttributesWithIOSurfaceSupport)
    {
      PixelBufferAttributesWithIOSurfaceSupport = bvc_CFDictionarySetInt(Mutable, (const void *)*MEMORY[0x1E0CA8F68], SLODWORD(r2.origin.x));
      if (!(_DWORD)PixelBufferAttributesWithIOSurfaceSupport)
      {
        PixelBufferAttributesWithIOSurfaceSupport = FigCreatePixelBufferAttributesWithIOSurfaceSupport();
        if (!(_DWORD)PixelBufferAttributesWithIOSurfaceSupport)
        {
          PixelBufferAttributesWithIOSurfaceSupport = VTCreatePixelBufferPoolAttributesWithName();
          if (!(_DWORD)PixelBufferAttributesWithIOSurfaceSupport)
          {
            CFGetAllocator(cf);
            PixelBufferAttributesWithIOSurfaceSupport = VTBuildPixelBufferPools2();
          }
        }
      }
    }
LABEL_317:
    v107 = PixelBufferAttributesWithIOSurfaceSupport;
  }
  if (*(_QWORD *)&v374.a)
    CFRelease(*(CFTypeRef *)&v374.a);
  v15 = v324;
  v33 = v341;
  if (Mutable)
    CFRelease(Mutable);
  if (*(_QWORD *)&t1.a)
    CFRelease(*(CFTypeRef *)&t1.a);
  if (v282)
    CFRelease(v282);
  if ((_DWORD)v107)
    goto LABEL_307;
  v275 = *(const void **)(v324 + 104);
  v257 = v336;
  v255 = a10;
  if (v275)
    goto LABEL_328;
  v286 = 0;
LABEL_329:
  v287 = MEMORY[0x1E0C809B0];
  dispatch_sync(*(dispatch_queue_t *)(v15 + 264), &__block_literal_global_21_0);
  v288 = *(NSObject **)(v15 + 264);
  v351[0] = v287;
  v351[1] = 0x40000000;
  v351[2] = __basicVideoCompositor_RenderFrame_block_invoke_5;
  v351[3] = &unk_1E2FA66D0;
  v351[6] = v286;
  v351[7] = v330;
  v351[8] = v15;
  v351[9] = v350;
  v351[10] = r1d;
  v351[11] = v247;
  v351[4] = &v360;
  v351[5] = cf;
  v351[12] = v339;
  v351[13] = v33;
  v352 = keya;
  v351[14] = v257;
  v351[15] = v316;
  v351[16] = v255;
  dispatch_async(v288, v351);
  v256 = 0;
  v272 = 0;
  v273 = 0;
  v274 = 0;
  v247 = 0;
  v33 = 0;
  v107 = 0;
LABEL_363:
  if (*(_QWORD *)(v15 + 176))
  {
    v305 = 0;
    do
    {
      CVPixelBufferPoolFlush(*(CVPixelBufferPoolRef *)(*(_QWORD *)(v15 + 184) + 8 * v305), 0);
      CVPixelBufferPoolFlush(*(CVPixelBufferPoolRef *)(*(_QWORD *)(v15 + 192) + 8 * v305++), 0);
    }
    while (v305 < *(_QWORD *)(v15 + 176));
  }
  v306 = *(__CVPixelBufferPool **)(v15 + 104);
  if (v306)
    CVPixelBufferPoolFlush(v306, 0);
  free(v33);
  free(v256);
  if (v272)
    CFRelease(v272);
  if (v273)
    CFRelease(v273);
  if (v274)
    CFRelease(v274);
  if (v247)
    CFRelease(v247);
LABEL_376:
  _Block_object_dispose(&v356, 8);
  _Block_object_dispose(&v360, 8);
  return v107;
}

uint64_t basicVideoCompositor_SetOutputCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  NSObject *v6;
  uint64_t v7;
  _QWORD v9[8];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v6 = *(NSObject **)(DerivedStorage + 272);
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = __basicVideoCompositor_SetOutputCallback_block_invoke;
  v9[3] = &unk_1E2FA6748;
  v9[6] = a2;
  v9[7] = a3;
  v9[4] = &v10;
  v9[5] = DerivedStorage;
  dispatch_sync(v6, v9);
  v7 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v10, 8);
  return v7;
}

uint64_t bvc_updateSourcebufferCharacteristics(uint64_t a1)
{
  __CVBuffer *v2;
  __CVBuffer *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFTypeRef cf;
  CFTypeRef v9;
  __CVBuffer *v10;
  __CVBuffer *v11;
  uint64_t v12;
  CGRect v13;
  CGRect v14;

  v12 = 0;
  v10 = 0;
  v11 = 0;
  cf = 0;
  v9 = 0;
  bvc_copyCVBufferProperties(*(__CVBuffer **)a1, &v11, &v10, (__CVBuffer **)&cf, (__CVBuffer **)&v9);
  FigVideoCompositorUtilityGetPixelAspectRatio((CFTypeID)cf, (_DWORD *)&v12 + 1, &v12);
  v3 = v10;
  v2 = v11;
  *(_QWORD *)(a1 + 160) = v11;
  *(_QWORD *)(a1 + 168) = v3;
  v4 = (int)v12;
  *(_QWORD *)(a1 + 184) = SHIDWORD(v12);
  *(_QWORD *)(a1 + 192) = v4;
  bvc_getCleanApertureRect(v9, (unint64_t)v2, (unint64_t)v3, (double *)(a1 + 232));
  v6 = v5;
  if (!(_DWORD)v5)
  {
    v14.size.width = *(CGFloat *)(a1 + 144);
    v14.size.height = *(CGFloat *)(a1 + 152);
    v13 = *(CGRect *)(a1 + 232);
    v14.origin.x = *(double *)(a1 + 128) + v13.origin.x;
    v14.origin.y = *(double *)(a1 + 136) + v13.origin.y;
    *(CGRect *)(a1 + 264) = CGRectIntersection(v13, v14);
  }
  if (cf)
    CFRelease(cf);
  if (v9)
    CFRelease(v9);
  return v6;
}

uint64_t bvc_computeScaledTransformAndTransformedRect(unint64_t a1, unint64_t a2, const void *a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  double Width;
  double Height;
  CGAffineTransform v16;
  CGRect v17;
  CGRect v18;
  CGRect v19;

  memset(&v17, 0, sizeof(v17));
  bvc_getCleanApertureRect(a3, a1, a2, &v17.origin.x);
  v6 = v5;
  if (!(_DWORD)v5)
  {
    v7 = *(_OWORD *)(a4 + 48);
    v8 = *(_OWORD *)(a4 + 32);
    v9 = v7;
    *(_OWORD *)(a4 + 80) = v8;
    *(_OWORD *)(a4 + 96) = v7;
    *(_OWORD *)(a4 + 112) = *(_OWORD *)(a4 + 64);
    v10 = *(_QWORD *)(a4 + 264);
    *(_QWORD *)&v7 = *(_QWORD *)(a4 + 272);
    v11 = *(_QWORD *)(a4 + 280);
    v12 = *(_QWORD *)(a4 + 288);
    *(_OWORD *)&v16.a = v8;
    *(_OWORD *)&v16.c = v9;
    *(_OWORD *)&v16.tx = *(_OWORD *)(a4 + 64);
    v18 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v7 - 8), &v16);
    *(CGRect *)(a4 + 200) = v18;
    v19 = CGRectIntersection(v18, v17);
    *(CGRect *)(a4 + 200) = v19;
    *(CGRect *)(a4 + 200) = CGRectStandardize(v19);
    Width = (double)CVPixelBufferGetWidth(*(CVPixelBufferRef *)a4);
    Height = (double)CVPixelBufferGetHeight(*(CVPixelBufferRef *)a4);
    *(_QWORD *)(a4 + 296) = 0;
    *(_QWORD *)(a4 + 304) = 0;
    *(double *)(a4 + 312) = Width;
    *(double *)(a4 + 320) = Height;
  }
  return v6;
}

uint64_t bvc_mixBuffers(NSObject *a1, CVPixelBufferRef pixelBuffer, __CVBuffer *a3, __CVBuffer *a4, int a5, int a6, int a7, int a8, float a9, CGFloat a10, CGFloat a11, CGFloat a12, CGFloat a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  CFTypeRef v28;
  size_t Width;
  size_t Height;
  size_t v31;
  size_t v32;
  size_t v33;
  size_t v34;
  const void *v35;
  double PixelRectangle;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  uint64_t (*v58)();
  uint64_t (*v59)();
  uint64_t *v60;
  int v61;
  uint64_t (*v62)();
  uint64_t v63;
  int BufferCharacteristics;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  size_t v73;
  int v74;
  double v76;
  double v77;
  OSType v79;
  OSType PixelFormatType;
  OSType v81;
  _QWORD block[19];
  OSType v83;
  _DWORD v84[3];
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t *v89;
  uint64_t v90;
  int v91;
  _OWORD v92[2];
  _OWORD v93[2];
  _OWORD v94[2];
  _OWORD v95[2];
  _OWORD v96[2];
  _OWORD v97[2];
  uint64_t v98;
  CGRect v99;
  CGRect v100;
  CGRect v101;
  CGRect v102;
  CGRect v103;
  CGRect v104;
  CGRect v105;
  CGRect v106;
  CGRect v107;

  v98 = *MEMORY[0x1E0C80C00];
  v88 = 0;
  v89 = &v88;
  v90 = 0x2000000000;
  v91 = 0;
  PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
  v79 = CVPixelBufferGetPixelFormatType(a3);
  v81 = CVPixelBufferGetPixelFormatType(a4);
  v28 = CVBufferCopyAttachment(a4, (CFStringRef)*MEMORY[0x1E0CA8EE8], 0);
  Width = CVPixelBufferGetWidth(pixelBuffer);
  Height = CVPixelBufferGetHeight(pixelBuffer);
  v31 = CVPixelBufferGetWidth(a3);
  v32 = CVPixelBufferGetHeight(a3);
  v33 = CVPixelBufferGetWidth(a4);
  v34 = CVPixelBufferGetHeight(a4);
  memset(v97, 0, sizeof(v97));
  memset(v96, 0, sizeof(v96));
  memset(v95, 0, sizeof(v95));
  memset(v94, 0, sizeof(v94));
  memset(v93, 0, sizeof(v93));
  memset(v92, 0, sizeof(v92));
  v86 = 0;
  v87 = 0;
  v85 = 0;
  v105.size.width = (double)Width;
  v35 = v28;
  v105.size.height = (double)Height;
  v105.origin.x = 0.0;
  v105.origin.y = 0.0;
  v99.origin.x = a10;
  v99.origin.y = a11;
  v99.size.width = a12;
  v99.size.height = a13;
  v100 = CGRectIntersection(v99, v105);
  PixelRectangle = bvc_getPixelRectangle(v100.origin.x, v100.origin.y, v100.size.width, v100.size.height);
  v76 = v37;
  v77 = PixelRectangle;
  v39 = v38;
  v41 = v40;
  v106.size.width = (double)v31;
  v106.size.height = (double)v32;
  v106.origin.x = 0.0;
  v106.origin.y = 0.0;
  *(_QWORD *)&v101.origin.x = a14;
  *(_QWORD *)&v101.origin.y = a15;
  *(_QWORD *)&v101.size.width = a16;
  *(_QWORD *)&v101.size.height = a17;
  v102 = CGRectIntersection(v101, v106);
  v42 = bvc_getPixelRectangle(v102.origin.x, v102.origin.y, v102.size.width, v102.size.height);
  v44 = v43;
  v46 = v45;
  v48 = v47;
  v107.size.width = (double)v33;
  v107.size.height = (double)v34;
  v107.origin.x = 0.0;
  v107.origin.y = 0.0;
  *(_QWORD *)&v103.origin.y = a19;
  *(_QWORD *)&v103.origin.x = a18;
  *(_QWORD *)&v103.size.height = a21;
  *(_QWORD *)&v103.size.width = a20;
  v104 = CGRectIntersection(v103, v107);
  v52 = bvc_getPixelRectangle(v104.origin.x, v104.origin.y, v104.size.width, v104.size.height);
  if (v39 < 1.0 || v41 < 1.0 || v46 < 1.0 || v48 < 1.0 || v50 < 1.0 || v51 < 1.0)
    goto LABEL_36;
  if (v39 >= v46)
    v53 = v46;
  else
    v53 = v39;
  if (v50 >= v53)
    v54 = v53;
  else
    v54 = v50;
  if (v41 >= v48)
    v55 = v48;
  else
    v55 = v41;
  if (v51 >= v55)
    v56 = v55;
  else
    v56 = v51;
  if (v81 != 875704438)
  {
    v60 = v89;
    v61 = -12503;
LABEL_35:
    *((_DWORD *)v60 + 6) = v61;
    goto LABEL_36;
  }
  v57 = v49;
  if (PixelFormatType == 32)
  {
    if (v79 == 875704438)
    {
      if (v28 && CFEqual(v28, (CFTypeRef)*MEMORY[0x1E0CA8F18]))
      {
        v58 = (uint64_t (*)())bvc_SimpleMixing_32ARGB_420v709_420v709;
        v59 = (uint64_t (*)())bvc_SimpleMixingOpaque_32ARGB_420v709_420v709;
      }
      else
      {
        v58 = (uint64_t (*)())bvc_SimpleMixing_32ARGB_420v601_420v601;
        v59 = (uint64_t (*)())bvc_SimpleMixingOpaque_32ARGB_420v601_420v601;
      }
      goto LABEL_40;
    }
    goto LABEL_34;
  }
  if (PixelFormatType == 1111970369)
  {
    if (v79 == 875704438)
    {
      if (v28 && CFEqual(v28, (CFTypeRef)*MEMORY[0x1E0CA8F18]))
        v62 = bvc_SimpleMixing_32BGRA_420v709_420v709_vec;
      else
        v62 = bvc_SimpleMixing_32BGRA_420v601_420v601_vec;
      goto LABEL_44;
    }
    goto LABEL_34;
  }
  if (PixelFormatType != 875704438 || v79 != 875704438)
  {
LABEL_34:
    v60 = v89;
    v61 = -12502;
    goto LABEL_35;
  }
  v58 = bvc_SimpleMixing_420v_420v_420v_vec;
  v59 = bvc_SimpleMixingOpaque_420v_420v_420v_vec;
LABEL_40:
  if (a9 == 1.0)
    v62 = v59;
  else
    v62 = v58;
LABEL_44:
  CVPixelBufferLockBaseAddress(a4, 0);
  if (pixelBuffer != a4)
    CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL);
  if (a3 != a4)
    CVPixelBufferLockBaseAddress(a3, 1uLL);
  BufferCharacteristics = bvc_getBufferCharacteristics(pixelBuffer, &v87, (size_t *)v97, v94, v77, v76);
  *((_DWORD *)v89 + 6) = BufferCharacteristics;
  if (!BufferCharacteristics)
  {
    v66 = bvc_getBufferCharacteristics(a3, &v86, (size_t *)v96, v93, v42, v44);
    *((_DWORD *)v89 + 6) = v66;
    if (!v66)
    {
      v67 = bvc_getBufferCharacteristics(a4, &v85, (size_t *)v95, v92, v52, v57);
      *((_DWORD *)v89 + 6) = v67;
      if (!v67)
      {
        v68 = (unint64_t)v54;
        v69 = (unint64_t)v56;
        if (FigThreadGetMaxLogicalCoreCount() < 2)
        {
          v74 = ((uint64_t (*)(unint64_t, unint64_t, _OWORD *, _OWORD *, _OWORD *, _OWORD *, _OWORD *, _OWORD *, float))v62)((unint64_t)v54, (unint64_t)v56, v97, v94, v96, v93, v95, v92, a9);
          *((_DWORD *)v89 + 6) = v74;
        }
        else
        {
          if ((v68 * v69) >> 9 <= 0x4A)
            v70 = 1;
          else
            v70 = v68 * v69 / 0x4B00;
          v71 = v69 / v70;
          if (v71 <= 1)
            v71 = 1;
          v72 = (v71 & 1) + v71;
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 0x40000000;
          block[2] = __bvc_mixBuffers_block_invoke;
          block[3] = &unk_1E2FA66F8;
          if (v69 / v72 <= 1)
            v73 = 1;
          else
            v73 = v69 / v72;
          block[6] = v73;
          block[7] = (unint64_t)v56;
          block[8] = v87;
          block[9] = v94;
          v83 = PixelFormatType;
          qmemcpy(v84, "v024v024", 8);
          block[10] = v97;
          block[11] = v86;
          block[12] = v93;
          block[13] = v96;
          block[14] = v85;
          block[15] = v92;
          block[16] = v95;
          block[17] = v62;
          block[18] = (unint64_t)v54;
          *(float *)&v84[2] = a9;
          block[4] = &v88;
          block[5] = v72;
          dispatch_apply(v73, a1, block);
        }
      }
    }
  }
  CVPixelBufferUnlockBaseAddress(a4, 0);
  if (pixelBuffer != a4)
    CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
  if (a3 != a4)
    CVPixelBufferUnlockBaseAddress(a3, 1uLL);
LABEL_36:
  if (v35)
    CFRelease(v35);
  v63 = *((unsigned int *)v89 + 6);
  _Block_object_dispose(&v88, 8);
  return v63;
}

__CVBuffer *bvc_copyCVBufferProperties(__CVBuffer *pixelBuffer, __CVBuffer **a2, __CVBuffer **a3, __CVBuffer **a4, __CVBuffer **a5)
{
  __CVBuffer *v8;

  v8 = pixelBuffer;
  if (a2)
  {
    pixelBuffer = (__CVBuffer *)CVPixelBufferGetWidth(pixelBuffer);
    *a2 = pixelBuffer;
  }
  if (a3)
  {
    pixelBuffer = (__CVBuffer *)CVPixelBufferGetHeight(v8);
    *a3 = pixelBuffer;
  }
  if (a4)
  {
    pixelBuffer = (__CVBuffer *)CVBufferCopyAttachment(v8, (CFStringRef)*MEMORY[0x1E0CA8E68], 0);
    *a4 = pixelBuffer;
  }
  if (a5)
  {
    pixelBuffer = (__CVBuffer *)CVBufferCopyAttachment(v8, (CFStringRef)*MEMORY[0x1E0CA8D50], 0);
    *a5 = pixelBuffer;
  }
  return pixelBuffer;
}

void bvc_getCleanApertureRect(const void *a1, unint64_t a2, unint64_t a3, double *a4)
{
  int v7;
  float v8;
  float v9;
  float v10;
  float v11;
  double v12;
  uint64_t v13;
  uint64_t v14;

  v13 = 0;
  v14 = 0;
  if (a4)
  {
    FigVideoCompositorUtilityGetCleanAperture(a1, a2, a3, (float *)&v14 + 1, (float *)&v14, (float *)&v13 + 1, (float *)&v13);
    if (!v7)
    {
      v8 = (float)a2;
      v9 = *((float *)&v14 + 1);
      if (*((float *)&v14 + 1) >= (float)((float)a2 + (float)(*((float *)&v13 + 1) * 2.0)))
        v9 = (float)a2 + (float)(*((float *)&v13 + 1) * 2.0);
      if (v9 >= (float)(v8 + (float)(*((float *)&v13 + 1) * -2.0)))
        v9 = v8 + (float)(*((float *)&v13 + 1) * -2.0);
      v10 = (float)a3;
      v11 = (float)a3 + (float)(*(float *)&v13 * 2.0);
      if (*(float *)&v14 < v11)
        v11 = *(float *)&v14;
      if (v11 >= (float)(v10 + (float)(*(float *)&v13 * -2.0)))
        v11 = v10 + (float)(*(float *)&v13 * -2.0);
      v12 = (float)(*(float *)&v13 + (float)((float)(v10 - v11) * 0.5));
      *a4 = (float)(*((float *)&v13 + 1) + (float)((float)(v8 - v9) * 0.5));
      a4[1] = v12;
      a4[2] = v9;
      a4[3] = v11;
    }
  }
}

void bvc_doesPixelBufferFillCanvasExactly(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, const void *a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9)
{
  int v17;
  CGRect v18;
  CGRect v19;

  memset(&v18, 0, sizeof(v18));
  bvc_getCleanApertureRect(a5, a3, a4, &v18.origin.x);
  if (!v17 && a1 == a3 && a2 == a4)
  {
    v19.origin.x = a6;
    v19.origin.y = a7;
    v19.size.width = a8;
    v19.size.height = a9;
    CGRectEqualToRect(v19, v18);
  }
}

__CVPixelBufferPool *bvc_isPixelBufferPoolCompatibleWithDimensionsAndPixelFormat(__CVPixelBufferPool *result, uint64_t a2, uint64_t a3, int a4)
{
  const __CFDictionary *PixelBufferAttributes;
  const __CFDictionary *v8;
  const __CFNumber *Value;
  const __CFNumber *v10;
  const __CFNumber *v11;
  int v12;
  uint64_t valuePtr;

  if (result)
  {
    PixelBufferAttributes = CVPixelBufferPoolGetPixelBufferAttributes(result);
    if (!PixelBufferAttributes)
      goto LABEL_10;
    v8 = PixelBufferAttributes;
    Value = (const __CFNumber *)CFDictionaryGetValue(PixelBufferAttributes, (const void *)*MEMORY[0x1E0CA90E0]);
    if (!Value)
      goto LABEL_10;
    valuePtr = 0;
    v12 = 0;
    CFNumberGetValue(Value, kCFNumberSInt32Type, (char *)&valuePtr + 4);
    v10 = (const __CFNumber *)CFDictionaryGetValue(v8, (const void *)*MEMORY[0x1E0CA8FD8]);
    if (v10
      && (CFNumberGetValue(v10, kCFNumberSInt32Type, &valuePtr),
          (v11 = (const __CFNumber *)CFDictionaryGetValue(v8, (const void *)*MEMORY[0x1E0CA9040])) != 0))
    {
      CFNumberGetValue(v11, kCFNumberSInt32Type, &v12);
      if (SHIDWORD(valuePtr) == a2 && (int)valuePtr == a3 && v12 == a4)
        return (__CVPixelBufferPool *)1;
    }
    else
    {
LABEL_10:
      FigSignalErrorAt();
    }
    return 0;
  }
  return result;
}

uint64_t bvc_createPixelBufferPoolForPreProcessing(int a1, int a2, int a3, CVPixelBufferPoolRef *a4)
{
  const __CFAllocator *v8;
  uint64_t v9;
  CFDictionaryRef v10;
  __CFDictionary *MutableCopy;
  const __CFDictionary *v12;
  uint64_t v13;
  uint64_t v14;
  CFDictionaryRef theDict;
  CVPixelBufferPoolRef poolOut;

  theDict = 0;
  poolOut = 0;
  if (!a4)
  {
    v9 = FigSignalErrorAt();
    goto LABEL_16;
  }
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v9 = bvc_createPixelBufferAttributesDictionary((const __CFAllocator *)*MEMORY[0x1E0C9AE00], &theDict);
  if ((_DWORD)v9)
  {
LABEL_16:
    v14 = v9;
    goto LABEL_11;
  }
  v10 = theDict;
  MutableCopy = CFDictionaryCreateMutableCopy(v8, 0, theDict);
  if (!MutableCopy)
  {
    v14 = FigSignalErrorAt();
    if (!v10)
      return v14;
    goto LABEL_12;
  }
  v12 = MutableCopy;
  v13 = bvc_CFDictionarySetInt(MutableCopy, (const void *)*MEMORY[0x1E0CA90E0], a1);
  if ((_DWORD)v13
    || (v13 = bvc_CFDictionarySetInt(v12, (const void *)*MEMORY[0x1E0CA8FD8], a2), (_DWORD)v13)
    || (v13 = bvc_CFDictionarySetInt(v12, (const void *)*MEMORY[0x1E0CA9040], a3), (_DWORD)v13)
    || (v13 = VTCreatePixelBufferPoolAttributesWithName(), (_DWORD)v13))
  {
    v14 = v13;
  }
  else
  {
    v14 = CVPixelBufferPoolCreate(v8, 0, v12, &poolOut);
    if ((_DWORD)v14)
    {
      if (poolOut)
        CFRelease(poolOut);
    }
    else
    {
      *a4 = poolOut;
      poolOut = 0;
    }
  }
  CFRelease(v12);
LABEL_11:
  v10 = theDict;
  if (theDict)
LABEL_12:
    CFRelease(v10);
  return v14;
}

double bvc_getPixelRectangle(double a1, double a2, double a3, double a4)
{
  return (double)(int)(COERCE_DOUBLE(CGRectStandardize(*(CGRect *)&a1)) + 0.5);
}

uint64_t bvc_SimpleMixingOpaque_32ARGB_420v709_420v709(unint64_t a1, unint64_t a2, uint64_t *a3, _QWORD *a4, _QWORD *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 *v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  int v47;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  if (a2 >= 2)
  {
    v8 = 0;
    v9 = *a7;
    v54 = a7[1];
    v55 = a5[1];
    v53 = a2 >> 1;
    v10 = a1 >> 1;
    v12 = *a8;
    v11 = a8[1];
    v59 = *a3;
    v51 = 2 * *a5;
    v52 = 2 * *a3;
    if (a1 >> 1 <= 1)
      v10 = 1;
    v49 = v10;
    v50 = 2 * v9;
    v58 = *a4 + 3;
    v13 = v12 + v9;
    v14 = *a6;
    v15 = a6[1];
    v17 = v14 + *a5;
    do
    {
      v57 = v8;
      if (a1 >= 2)
      {
        v18 = 0;
        v19 = (unsigned __int8 *)v58;
        v20 = v49;
        do
        {
          v21 = *(v19 - 3);
          v22 = *(v19 - 2);
          v23 = *(v19 - 1);
          v24 = *v19;
          if (*(v19 - 3))
            v25 = (((16776959 * v21 + 0x10000) * *(unsigned __int8 *)(v14 + v18)) >> 16)
                + ((2120 * v21 + 5983 * v22 + 20127 * v23 + 2032 * v24) >> 15);
          else
            LOBYTE(v25) = *(_BYTE *)(v14 + v18);
          v26 = v19[1];
          v27 = v19[v59 - 3];
          v28 = v19[v59 + 1];
          v29 = v19[2];
          v30 = v19[v59 - 2];
          v31 = v19[v59 + 2];
          v32 = v19[3];
          v33 = v19[v59 - 1];
          v34 = v19[v59 + 3];
          v35 = v19[4];
          v36 = v19[v59];
          v37 = v19[v59 + 4];
          *(_BYTE *)(v12 + v18) = v25;
          if (v26)
            v38 = (((16776959 * v26 + 0x10000) * *(unsigned __int8 *)(v14 + v18 + 1)) >> 16)
                + ((2120 * v26 + 5983 * v29 + 20127 * v32 + 2032 * v35) >> 15);
          else
            LOBYTE(v38) = *(_BYTE *)(v14 + v18 + 1);
          *(_BYTE *)(v12 + v18 + 1) = v38;
          if (v27)
            v39 = (((16776959 * v27 + 0x10000) * *(unsigned __int8 *)(v17 + v18)) >> 16)
                + ((2120 * v27 + 5983 * v30 + 20127 * v33 + 2032 * v36) >> 15);
          else
            LOBYTE(v39) = *(_BYTE *)(v17 + v18);
          *(_BYTE *)(v13 + v18) = v39;
          if (v28)
            v40 = (((16776959 * v28 + 0x10000) * *(unsigned __int8 *)(v17 + v18 + 1)) >> 16)
                + ((2120 * v28 + 5983 * v31 + 20127 * v34 + 2032 * v37) >> 15);
          else
            LOBYTE(v40) = *(_BYTE *)(v17 + v18 + 1);
          *(_BYTE *)(v13 + v18 + 1) = v40;
          v41 = v26 + v21 + v27 + v28;
          if (v41 > 3)
          {
            v43 = 257 * (v41 >> 2);
            v44 = (v29 + v22 + v30 + v31) >> 2;
            v45 = (v32 + v23 + v33 + v34) >> 2;
            v46 = (v35 + v24 + v36 + v37) >> 2;
            v47 = 129 * (v41 >> 2);
            v43 = 0x10000 - v43;
            *(_BYTE *)(v11 + v18) = ((v43 * *(unsigned __int8 *)(v15 + v18)) >> 16)
                                  + ((2147480350 * v44 + (v47 << 7) + 8377515 * v45 + 14392 * v46) >> 15);
            v42 = ((v43 * *(unsigned __int8 *)(v15 + v18 + 1)) >> 16)
                + ((14392 * v44 + (v47 << 7) + 8375535 * v45 + 8387291 * v46) >> 15);
          }
          else
          {
            *(_BYTE *)(v11 + v18) = *(_BYTE *)(v15 + v18);
            LOBYTE(v42) = *(_BYTE *)(v15 + v18 + 1);
          }
          v19 += 8;
          *(_BYTE *)(v11 + v18 + 1) = v42;
          v18 += 2;
          --v20;
        }
        while (v20);
      }
      v14 += v51;
      v12 += v50;
      v15 += v55;
      v11 += v54;
      v8 = v57 + 1;
      v58 += v52;
      v13 += v50;
      v17 += v51;
    }
    while (v57 + 1 != v53);
  }
  return 0;
}

uint64_t bvc_SimpleMixing_32ARGB_420v709_420v709(unint64_t a1, unint64_t a2, uint64_t *a3, _QWORD *a4, _QWORD *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, float a9)
{
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 *v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;

  if (a2 >= 2)
  {
    v9 = 0;
    v10 = vcvts_n_s32_f32(a9, 8uLL);
    v56 = a5[1];
    v11 = *a7;
    v55 = a7[1];
    v54 = a2 >> 1;
    v12 = a1 >> 1;
    v14 = *a8;
    v13 = a8[1];
    v15 = (0x10101020000 * (v10 << 8)) >> 48;
    v52 = 2 * *a5;
    v53 = 2 * *a3;
    if (a1 >> 1 <= 1)
      v12 = 1;
    v50 = v12;
    v51 = 2 * v11;
    v59 = *a4 + 3;
    v60 = *a3;
    v16 = *a6;
    v62 = a6[1];
    v18 = v14 + v11;
    v19 = v16 + *a5;
    do
    {
      v58 = v9;
      if (a1 >= 2)
      {
        v20 = 0;
        v21 = (unsigned __int8 *)v59;
        v22 = v50;
        v61 = v13;
        do
        {
          v23 = *(v21 - 3);
          v24 = *(v21 - 2);
          v25 = *(v21 - 1);
          v26 = *v21;
          if ((_DWORD)v15 * v23)
            v27 = (((2120 * v23 + 5983 * v24 + 20127 * v25 + 2032 * v26) >> 15) * v10
                 + (((0x10000 - (_DWORD)v15 * v23) * *(unsigned __int8 *)(v16 + v20)) >> 8)) >> 8;
          else
            LOBYTE(v27) = *(_BYTE *)(v16 + v20);
          v28 = v21[1];
          v29 = v21[v60 - 3];
          v30 = v21[v60 + 1];
          v31 = v21[2];
          v32 = v21[v60 - 2];
          v33 = v21[v60 + 2];
          v34 = v21[3];
          v35 = v21[v60 - 1];
          v36 = v21[v60 + 3];
          v37 = v21[4];
          v38 = v21[v60];
          v39 = v21[v60 + 4];
          *(_BYTE *)(v14 + v20) = v27;
          if ((_DWORD)v15 * v28)
            v40 = (((2120 * v28 + 5983 * v31 + 20127 * v34 + 2032 * v37) >> 15) * v10
                 + (((0x10000 - (_DWORD)v15 * v28) * *(unsigned __int8 *)(v16 + v20 + 1)) >> 8)) >> 8;
          else
            LOBYTE(v40) = *(_BYTE *)(v16 + v20 + 1);
          *(_BYTE *)(v14 + v20 + 1) = v40;
          if ((_DWORD)v15 * v29)
            v41 = (((2120 * v29 + 5983 * v32 + 20127 * v35 + 2032 * v38) >> 15) * v10
                 + (((0x10000 - (_DWORD)v15 * v29) * *(unsigned __int8 *)(v19 + v20)) >> 8)) >> 8;
          else
            LOBYTE(v41) = *(_BYTE *)(v19 + v20);
          *(_BYTE *)(v18 + v20) = v41;
          if ((_DWORD)v15 * v30)
            v42 = (((2120 * v30 + 5983 * v33 + 20127 * v36 + 2032 * v39) >> 15) * v10
                 + (((0x10000 - (_DWORD)v15 * v30) * *(unsigned __int8 *)(v19 + v20 + 1)) >> 8)) >> 8;
          else
            LOBYTE(v42) = *(_BYTE *)(v19 + v20 + 1);
          v13 = v61;
          *(_BYTE *)(v18 + v20 + 1) = v42;
          v43 = (v28 + v23 + v29 + v30) >> 2;
          v44 = v43 * v15;
          if (v43 * (_DWORD)v15)
          {
            v45 = (v31 + v24 + v32 + v33) >> 2;
            v46 = (v34 + v25 + v35 + v36) >> 2;
            v47 = (v37 + v26 + v38 + v39) >> 2;
            *(_BYTE *)(v61 + v20) = (unsigned __int16)(((2147480350 * v45 + 16512 * v43 + 2147472555 * v46 + 14392 * v47) >> 15)
                                                     * v10
                                                     + (((0x10000 - v44) * *(unsigned __int8 *)(v62 + v20)) >> 8)) >> 8;
            v48 = (((14392 * v45 + 16512 * v43 + 2147470575 * v46 + 2147482331 * v47) >> 15) * v10
                 + (((0x10000 - v44) * *(unsigned __int8 *)(v62 + v20 + 1)) >> 8)) >> 8;
          }
          else
          {
            *(_BYTE *)(v61 + v20) = *(_BYTE *)(v62 + v20);
            LOBYTE(v48) = *(_BYTE *)(v62 + v20 + 1);
          }
          v21 += 8;
          *(_BYTE *)(v61 + v20 + 1) = v48;
          v20 += 2;
          --v22;
        }
        while (v22);
      }
      v16 += v52;
      v14 += v51;
      v62 += v56;
      v13 += v55;
      v9 = v58 + 1;
      v59 += v53;
      v18 += v51;
      v19 += v52;
    }
    while (v58 + 1 != v54);
  }
  return 0;
}

uint64_t bvc_SimpleMixingOpaque_32ARGB_420v601_420v601(unint64_t a1, unint64_t a2, uint64_t *a3, _QWORD *a4, _QWORD *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 *v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  int v47;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  if (a2 >= 2)
  {
    v8 = 0;
    v9 = *a7;
    v54 = a7[1];
    v55 = a5[1];
    v53 = a2 >> 1;
    v10 = a1 >> 1;
    v12 = *a8;
    v11 = a8[1];
    v59 = *a3;
    v51 = 2 * *a5;
    v52 = 2 * *a3;
    if (a1 >> 1 <= 1)
      v10 = 1;
    v49 = v10;
    v50 = 2 * v9;
    v58 = *a4 + 3;
    v13 = v12 + v9;
    v14 = *a6;
    v15 = a6[1];
    v17 = v14 + *a5;
    do
    {
      v57 = v8;
      if (a1 >= 2)
      {
        v18 = 0;
        v19 = (unsigned __int8 *)v58;
        v20 = v49;
        do
        {
          v21 = *(v19 - 3);
          v22 = *(v19 - 2);
          v23 = *(v19 - 1);
          v24 = *v19;
          if (*(v19 - 3))
            v25 = (((16776959 * v21 + 0x10000) * *(unsigned __int8 *)(v14 + v18)) >> 16)
                + ((2120 * v21 + 8412 * v22 + 16508 * v23 + 3219 * v24) >> 15);
          else
            LOBYTE(v25) = *(_BYTE *)(v14 + v18);
          v26 = v19[1];
          v27 = v19[v59 - 3];
          v28 = v19[v59 + 1];
          v29 = v19[2];
          v30 = v19[v59 - 2];
          v31 = v19[v59 + 2];
          v32 = v19[3];
          v33 = v19[v59 - 1];
          v34 = v19[v59 + 3];
          v35 = v19[4];
          v36 = v19[v59];
          v37 = v19[v59 + 4];
          *(_BYTE *)(v12 + v18) = v25;
          if (v26)
            v38 = (((16776959 * v26 + 0x10000) * *(unsigned __int8 *)(v14 + v18 + 1)) >> 16)
                + ((2120 * v26 + 8412 * v29 + 16508 * v32 + 3219 * v35) >> 15);
          else
            LOBYTE(v38) = *(_BYTE *)(v14 + v18 + 1);
          *(_BYTE *)(v12 + v18 + 1) = v38;
          if (v27)
            v39 = (((16776959 * v27 + 0x10000) * *(unsigned __int8 *)(v17 + v18)) >> 16)
                + ((2120 * v27 + 8412 * v30 + 16508 * v33 + 3219 * v36) >> 15);
          else
            LOBYTE(v39) = *(_BYTE *)(v17 + v18);
          *(_BYTE *)(v13 + v18) = v39;
          if (v28)
            v40 = (((16776959 * v28 + 0x10000) * *(unsigned __int8 *)(v17 + v18 + 1)) >> 16)
                + ((2120 * v28 + 8412 * v31 + 16508 * v34 + 3219 * v37) >> 15);
          else
            LOBYTE(v40) = *(_BYTE *)(v17 + v18 + 1);
          *(_BYTE *)(v13 + v18 + 1) = v40;
          v41 = v26 + v21 + v27 + v28;
          if (v41 > 3)
          {
            v43 = 257 * (v41 >> 2);
            v44 = (v29 + v22 + v30 + v31) >> 2;
            v45 = (v32 + v23 + v33 + v34) >> 2;
            v46 = (v35 + v24 + v36 + v37) >> 2;
            v47 = 129 * (v41 >> 2);
            v43 = 0x10000 - v43;
            *(_BYTE *)(v11 + v18) = ((v43 * *(unsigned __int8 *)(v15 + v18)) >> 16)
                                  + ((2147478790 * v44 + (v47 << 7) + 8379076 * v45 + 14392 * v46) >> 15);
            v42 = ((v43 * *(unsigned __int8 *)(v15 + v18 + 1)) >> 16)
                + ((14392 * v44 + (v47 << 7) + 8376568 * v45 + 8386260 * v46) >> 15);
          }
          else
          {
            *(_BYTE *)(v11 + v18) = *(_BYTE *)(v15 + v18);
            LOBYTE(v42) = *(_BYTE *)(v15 + v18 + 1);
          }
          v19 += 8;
          *(_BYTE *)(v11 + v18 + 1) = v42;
          v18 += 2;
          --v20;
        }
        while (v20);
      }
      v14 += v51;
      v12 += v50;
      v15 += v55;
      v11 += v54;
      v8 = v57 + 1;
      v58 += v52;
      v13 += v50;
      v17 += v51;
    }
    while (v57 + 1 != v53);
  }
  return 0;
}

uint64_t bvc_SimpleMixing_32ARGB_420v601_420v601(unint64_t a1, unint64_t a2, uint64_t *a3, _QWORD *a4, _QWORD *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, float a9)
{
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 *v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;

  if (a2 >= 2)
  {
    v9 = 0;
    v10 = vcvts_n_s32_f32(a9, 8uLL);
    v56 = a5[1];
    v11 = *a7;
    v55 = a7[1];
    v54 = a2 >> 1;
    v12 = a1 >> 1;
    v14 = *a8;
    v13 = a8[1];
    v15 = (0x10101020000 * (v10 << 8)) >> 48;
    v52 = 2 * *a5;
    v53 = 2 * *a3;
    if (a1 >> 1 <= 1)
      v12 = 1;
    v50 = v12;
    v51 = 2 * v11;
    v59 = *a4 + 3;
    v60 = *a3;
    v16 = *a6;
    v62 = a6[1];
    v18 = v14 + v11;
    v19 = v16 + *a5;
    do
    {
      v58 = v9;
      if (a1 >= 2)
      {
        v20 = 0;
        v21 = (unsigned __int8 *)v59;
        v22 = v50;
        v61 = v13;
        do
        {
          v23 = *(v21 - 3);
          v24 = *(v21 - 2);
          v25 = *(v21 - 1);
          v26 = *v21;
          if ((_DWORD)v15 * v23)
            v27 = (((2120 * v23 + 8412 * v24 + 16508 * v25 + 3219 * v26) >> 15) * v10
                 + (((0x10000 - (_DWORD)v15 * v23) * *(unsigned __int8 *)(v16 + v20)) >> 8)) >> 8;
          else
            LOBYTE(v27) = *(_BYTE *)(v16 + v20);
          v28 = v21[1];
          v29 = v21[v60 - 3];
          v30 = v21[v60 + 1];
          v31 = v21[2];
          v32 = v21[v60 - 2];
          v33 = v21[v60 + 2];
          v34 = v21[3];
          v35 = v21[v60 - 1];
          v36 = v21[v60 + 3];
          v37 = v21[4];
          v38 = v21[v60];
          v39 = v21[v60 + 4];
          *(_BYTE *)(v14 + v20) = v27;
          if ((_DWORD)v15 * v28)
            v40 = (((2120 * v28 + 8412 * v31 + 16508 * v34 + 3219 * v37) >> 15) * v10
                 + (((0x10000 - (_DWORD)v15 * v28) * *(unsigned __int8 *)(v16 + v20 + 1)) >> 8)) >> 8;
          else
            LOBYTE(v40) = *(_BYTE *)(v16 + v20 + 1);
          *(_BYTE *)(v14 + v20 + 1) = v40;
          if ((_DWORD)v15 * v29)
            v41 = (((2120 * v29 + 8412 * v32 + 16508 * v35 + 3219 * v38) >> 15) * v10
                 + (((0x10000 - (_DWORD)v15 * v29) * *(unsigned __int8 *)(v19 + v20)) >> 8)) >> 8;
          else
            LOBYTE(v41) = *(_BYTE *)(v19 + v20);
          *(_BYTE *)(v18 + v20) = v41;
          if ((_DWORD)v15 * v30)
            v42 = (((2120 * v30 + 8412 * v33 + 16508 * v36 + 3219 * v39) >> 15) * v10
                 + (((0x10000 - (_DWORD)v15 * v30) * *(unsigned __int8 *)(v19 + v20 + 1)) >> 8)) >> 8;
          else
            LOBYTE(v42) = *(_BYTE *)(v19 + v20 + 1);
          v13 = v61;
          *(_BYTE *)(v18 + v20 + 1) = v42;
          v43 = (v28 + v23 + v29 + v30) >> 2;
          v44 = v43 * v15;
          if (v43 * (_DWORD)v15)
          {
            v45 = (v31 + v24 + v32 + v33) >> 2;
            v46 = (v34 + v25 + v35 + v36) >> 2;
            v47 = (v37 + v26 + v38 + v39) >> 2;
            *(_BYTE *)(v61 + v20) = (unsigned __int16)(((2147478790 * v45 + 16512 * v43 + 2147474116 * v46 + 14392 * v47) >> 15)
                                                     * v10
                                                     + (((0x10000 - v44) * *(unsigned __int8 *)(v62 + v20)) >> 8)) >> 8;
            v48 = (((14392 * v45 + 16512 * v43 + 2147471608 * v46 + 2147481300 * v47) >> 15) * v10
                 + (((0x10000 - v44) * *(unsigned __int8 *)(v62 + v20 + 1)) >> 8)) >> 8;
          }
          else
          {
            *(_BYTE *)(v61 + v20) = *(_BYTE *)(v62 + v20);
            LOBYTE(v48) = *(_BYTE *)(v62 + v20 + 1);
          }
          v21 += 8;
          *(_BYTE *)(v61 + v20 + 1) = v48;
          v20 += 2;
          --v22;
        }
        while (v22);
      }
      v16 += v52;
      v14 += v51;
      v62 += v56;
      v13 += v55;
      v9 = v58 + 1;
      v59 += v53;
      v18 += v51;
      v19 += v52;
    }
    while (v58 + 1 != v54);
  }
  return 0;
}

uint64_t bvc_getBufferCharacteristics(__CVBuffer *a1, uint64_t *a2, size_t *a3, _QWORD *a4, double a5, double a6)
{
  signed int PixelFormatType;
  size_t PlaneCount;
  uint64_t v14;
  size_t v15;
  char *BaseAddressOfPlane;
  float v17;
  float v18;
  double v19;
  uint64_t v20;
  char *BaseAddress;
  double v22;
  int v23;
  char *v24;
  double v25;
  double v26;
  uint64_t v27;

  if (a2 && a3 && a4)
  {
    PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
    if (!CVPixelBufferIsPlanar(a1))
    {
      v14 = 1;
      if (CVPixelBufferIsPlanar(a1))
      {
LABEL_10:
        v15 = 0;
        while (1)
        {
          a3[v15] = CVPixelBufferGetBytesPerRowOfPlane(a1, v15);
          BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(a1, v15);
          if (PixelFormatType <= 875704421)
          {
            v17 = 1.0;
            if (PixelFormatType != 32 && PixelFormatType != 846624121)
              goto LABEL_23;
          }
          else
          {
            if (PixelFormatType != 875704422)
            {
              v17 = 1.0;
              if (PixelFormatType == 1111970369)
                goto LABEL_24;
              if (PixelFormatType != 875704438)
              {
LABEL_23:
                v17 = -1.0;
                goto LABEL_24;
              }
            }
            if (v15 == 1)
              v17 = 0.5;
            else
              v17 = -1.0;
            if (!v15)
              v17 = 1.0;
          }
LABEL_24:
          v18 = 1.0;
          if (PixelFormatType <= 875704421)
          {
            if (PixelFormatType == 32)
              goto LABEL_38;
            if (PixelFormatType == 846624121)
            {
              v19 = a5 * 0.5 + 0.5;
              goto LABEL_48;
            }
LABEL_37:
            v18 = -1.0;
            goto LABEL_38;
          }
          if (PixelFormatType != 875704422)
          {
            if (PixelFormatType == 1111970369)
              goto LABEL_38;
            if (PixelFormatType != 875704438)
              goto LABEL_37;
          }
          if (v15 == 1)
            v18 = 0.5;
          else
            v18 = -1.0;
          if (!v15)
            v18 = 1.0;
LABEL_38:
          v19 = a5 * v18 + 0.5;
          if (PixelFormatType <= 875704421)
          {
            if (PixelFormatType != 32)
              goto LABEL_51;
          }
          else
          {
            if (PixelFormatType == 875704422)
              goto LABEL_42;
            if (PixelFormatType != 1111970369)
            {
              if (PixelFormatType == 875704438)
              {
LABEL_42:
                v20 = 2;
                if (v15 != 1)
                  v20 = -1;
                if (!v15)
                  v20 = 1;
                goto LABEL_49;
              }
LABEL_51:
              v20 = -1;
              goto LABEL_49;
            }
          }
LABEL_48:
          v20 = 4;
LABEL_49:
          a4[v15] = &BaseAddressOfPlane[a3[v15] * (unint64_t)(a6 * v17 + 0.5) + v20 * (unint64_t)v19];
          if (v14 == ++v15)
            goto LABEL_77;
        }
      }
LABEL_52:
      *a3 = CVPixelBufferGetBytesPerRow(a1);
      BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
      v22 = 1.0;
      if (PixelFormatType <= 875704421)
      {
        if (PixelFormatType == 32)
          goto LABEL_60;
        v23 = 846624121;
      }
      else
      {
        if (PixelFormatType == 875704422 || PixelFormatType == 875704438)
          goto LABEL_60;
        v23 = 1111970369;
      }
      if (PixelFormatType != v23)
        v22 = -1.0;
LABEL_60:
      v24 = &BaseAddress[*a3 * (unint64_t)(a6 * v22 + 0.5)];
      v25 = 1.0;
      if (PixelFormatType <= 875704421)
      {
        if (PixelFormatType == 32)
        {
LABEL_69:
          v26 = a5 * v25 + 0.5;
          v27 = 4;
          if (PixelFormatType <= 875704421)
          {
            if (PixelFormatType == 32)
              goto LABEL_76;
            goto LABEL_75;
          }
          if (PixelFormatType == 875704422)
          {
LABEL_73:
            v27 = 1;
            goto LABEL_76;
          }
          if (PixelFormatType != 1111970369)
          {
            if (PixelFormatType == 875704438)
              goto LABEL_73;
LABEL_75:
            v27 = -1;
          }
LABEL_76:
          *a4 = &v24[v27 * (unint64_t)v26];
LABEL_77:
          *a2 = v14;
          return 0;
        }
        if (PixelFormatType == 846624121)
        {
          v26 = a5 * 0.5 + 0.5;
          v27 = 4;
          goto LABEL_76;
        }
      }
      else if (PixelFormatType == 875704422 || PixelFormatType == 875704438 || PixelFormatType == 1111970369)
      {
        goto LABEL_69;
      }
      v25 = -1.0;
      goto LABEL_69;
    }
    PlaneCount = CVPixelBufferGetPlaneCount(a1);
    if (PlaneCount < 5)
    {
      v14 = PlaneCount;
      if (CVPixelBufferIsPlanar(a1))
      {
        if (!v14)
          goto LABEL_77;
        goto LABEL_10;
      }
      goto LABEL_52;
    }
  }
  return FigSignalErrorAt();
}

uint64_t __bvc_mixBuffers_block_invoke(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  float v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  float v23;
  uint64_t result;
  _OWORD v25[2];
  _OWORD v26[2];
  _OWORD v27[2];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  memset(v27, 0, sizeof(v27));
  memset(v26, 0, sizeof(v26));
  memset(v25, 0, sizeof(v25));
  v4 = *(_QWORD *)(a1 + 40);
  v5 = v4 * a2;
  if (*(_QWORD *)(a1 + 48) - 1 == a2)
    v4 = *(_QWORD *)(a1 + 56) - v5;
  v6 = *(_QWORD *)(a1 + 64);
  v7 = *(_QWORD *)(a1 + 80);
  if (v6)
  {
    v8 = 0;
    v9 = *(_DWORD *)(a1 + 152);
    v10 = *(_QWORD *)(a1 + 72);
    while (v9 > 875704421)
    {
      if (v9 == 875704422)
        goto LABEL_9;
      v11 = 1.0;
      if (v9 != 1111970369)
      {
        if (v9 == 875704438)
        {
LABEL_9:
          if (v8 == 1)
            v11 = 0.5;
          else
            v11 = -1.0;
          if (!v8)
            v11 = 1.0;
          goto LABEL_18;
        }
LABEL_17:
        v11 = -1.0;
      }
LABEL_18:
      *((_QWORD *)v27 + v8) = *(_QWORD *)(v10 + 8 * v8)
                            + *(_QWORD *)(v7 + 8 * v8) * (unint64_t)(float)(v11 * (float)v5);
      if (v6 == ++v8)
        goto LABEL_19;
    }
    v11 = 1.0;
    if (v9 == 32 || v9 == 846624121)
      goto LABEL_18;
    goto LABEL_17;
  }
LABEL_19:
  v12 = *(_QWORD *)(a1 + 88);
  v13 = *(_QWORD *)(a1 + 104);
  if (v12)
  {
    v14 = 0;
    v15 = *(_DWORD *)(a1 + 156);
    v16 = *(_QWORD *)(a1 + 96);
    while (v15 > 875704421)
    {
      if (v15 == 875704422)
        goto LABEL_25;
      v17 = 1.0;
      if (v15 != 1111970369)
      {
        if (v15 == 875704438)
        {
LABEL_25:
          if (v14 == 1)
            v17 = 0.5;
          else
            v17 = -1.0;
          if (!v14)
            v17 = 1.0;
          goto LABEL_34;
        }
LABEL_33:
        v17 = -1.0;
      }
LABEL_34:
      *((_QWORD *)v26 + v14) = *(_QWORD *)(v16 + 8 * v14)
                             + *(_QWORD *)(v13 + 8 * v14) * (unint64_t)(float)(v17 * (float)v5);
      if (v12 == ++v14)
        goto LABEL_35;
    }
    v17 = 1.0;
    if (v15 == 32 || v15 == 846624121)
      goto LABEL_34;
    goto LABEL_33;
  }
LABEL_35:
  v18 = *(_QWORD *)(a1 + 112);
  v19 = *(_QWORD *)(a1 + 128);
  if (v18)
  {
    v20 = 0;
    v21 = *(_DWORD *)(a1 + 160);
    v22 = *(_QWORD *)(a1 + 120);
    while (v21 > 875704421)
    {
      if (v21 == 875704422)
        goto LABEL_41;
      v23 = 1.0;
      if (v21 != 1111970369)
      {
        if (v21 == 875704438)
        {
LABEL_41:
          if (v20 == 1)
            v23 = 0.5;
          else
            v23 = -1.0;
          if (!v20)
            v23 = 1.0;
          goto LABEL_50;
        }
LABEL_49:
        v23 = -1.0;
      }
LABEL_50:
      *((_QWORD *)v25 + v20) = *(_QWORD *)(v22 + 8 * v20)
                             + *(_QWORD *)(v19 + 8 * v20) * (unint64_t)(float)(v23 * (float)v5);
      if (v18 == ++v20)
        goto LABEL_51;
    }
    v23 = 1.0;
    if (v21 == 32 || v21 == 846624121)
      goto LABEL_50;
    goto LABEL_49;
  }
LABEL_51:
  result = (*(uint64_t (**)(_QWORD, unint64_t, uint64_t, _OWORD *, uint64_t, _OWORD *, uint64_t, _OWORD *, float))(a1 + 136))(*(_QWORD *)(a1 + 144), v4, v7, v27, v13, v26, v19, v25, *(float *)(a1 + 164));
  if ((_DWORD)result)
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = -12506;
  return result;
}

uint64_t bvc_Fill_32ARGB_420v709(size_t __len, unint64_t a2, unsigned __int8 *a3, uint64_t *a4, char **a5)
{
  uint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int16x8_t v14;
  int v15;
  unint64_t v16;
  int16x4_t v17;
  size_t v18;
  uint64_t v19;
  unsigned int v21;
  unsigned __int32 v22;
  unsigned __int32 __pattern4;

  v8 = *a4;
  v7 = a4[1];
  v10 = *a5;
  v9 = a5[1];
  v11 = a3[1];
  v12 = a3[2];
  v13 = 20127 * v12 + 5983 * v11 + 2032 * a3[3] + 540672;
  v21 = a3[3];
  if (*a4 == __len)
  {
    memset(v10, v13 >> 15, __len * a2);
  }
  else
  {
    if (!a2)
      return 0;
    v15 = v13 >> 15;
    v16 = a2;
    do
    {
      memset(v10, v15, __len);
      v10 += v8;
      --v16;
    }
    while (v16);
  }
  if (a2 >= 2)
  {
    v17 = (int16x4_t)vshr_n_u32((uint32x2_t)vadd_s32(vmla_s32(vmla_s32(vmul_s32(vdup_n_s32(v12), (int32x2_t)0x7FCCEF007FD4ABLL), vdup_n_s32(v11), (int32x2_t)0x3838007FF31ELL), vdup_n_s32(v21), (int32x2_t)0x7FFADB00003838), vdup_n_s32(0x404000u)), 0xFuLL);
    v18 = (__len + 1) & 0xFFFFFFFFFFFFFFFELL;
    *(int16x4_t *)v14.i8 = vuzp1_s16(v17, v17);
    if (a2 >> 1 <= 1)
      v19 = 1;
    else
      v19 = a2 >> 1;
    v22 = vmovn_s16(v14).u32[0];
    do
    {
      __pattern4 = v22;
      memset_pattern4(v9, &__pattern4, v18);
      v9 += v7;
      --v19;
    }
    while (v19);
  }
  return 0;
}

uint64_t bvc_Fill_32ARGB_420v601(size_t __len, unint64_t a2, unsigned __int8 *a3, uint64_t *a4, char **a5)
{
  uint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int16x8_t v14;
  int v15;
  unint64_t v16;
  int16x4_t v17;
  size_t v18;
  uint64_t v19;
  unsigned int v21;
  unsigned __int32 v22;
  unsigned __int32 __pattern4;

  v8 = *a4;
  v7 = a4[1];
  v10 = *a5;
  v9 = a5[1];
  v11 = a3[1];
  v12 = a3[2];
  v13 = 16508 * v12 + 8412 * v11 + 3219 * a3[3] + 540672;
  v21 = a3[3];
  if (*a4 == __len)
  {
    memset(v10, v13 >> 15, __len * a2);
  }
  else
  {
    if (!a2)
      return 0;
    v15 = v13 >> 15;
    v16 = a2;
    do
    {
      memset(v10, v15, __len);
      v10 += v8;
      --v16;
    }
    while (v16);
  }
  if (a2 >= 2)
  {
    v17 = (int16x4_t)vshr_n_u32((uint32x2_t)vadd_s32(vmla_s32(vmla_s32(vmul_s32(vdup_n_s32(v12), (int32x2_t)0x7FD0F8007FDAC4), vdup_n_s32(v11), (int32x2_t)0x3838007FED06), vdup_n_s32(v21), (int32x2_t)0x7FF6D400003838), vdup_n_s32(0x404000u)), 0xFuLL);
    v18 = (__len + 1) & 0xFFFFFFFFFFFFFFFELL;
    *(int16x4_t *)v14.i8 = vuzp1_s16(v17, v17);
    if (a2 >> 1 <= 1)
      v19 = 1;
    else
      v19 = a2 >> 1;
    v22 = vmovn_s16(v14).u32[0];
    do
    {
      __pattern4 = v22;
      memset_pattern4(v9, &__pattern4, v18);
      v9 += v7;
      --v19;
    }
    while (v19);
  }
  return 0;
}

uint64_t bvc_FullCompositionOpaque_420v_420v(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, _QWORD *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, float a14)
{
  uint64_t v20;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t VectorsFromTransform;
  unsigned int v32;
  unsigned int v33;
  int v34;
  __int128 v35;
  uint64_t v36;
  char *v37;
  _DWORD *v38;
  unsigned __int16 v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  signed int v45;
  int32x4_t v46;
  int v47;
  int v48;
  int v49;
  _DWORD *v50;
  char *v51;
  int v52;
  int v53;
  int v54;
  signed int v55;
  int v56;
  int32x4_t v57;
  int v58;
  int v59;
  int v60;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  signed int v67;
  double v68;
  signed int v69;
  _QWORD *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  CGAffineTransform v76;
  CGAffineTransform v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _DWORD *v86;
  char *v87;
  uint64_t v88;
  uint64_t v89;

  v71 = *a3;
  v72 = *a2;
  v73 = a3[1];
  v74 = a2[1];
  v88 = 0;
  v89 = 0;
  v20 = *a4;
  v75 = a4[1];
  v86 = 0;
  v87 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
    return FigSignalErrorAt();
  v84 = 0;
  v85 = 0;
  v82 = 0;
  v83 = 0;
  v80 = 0;
  v81 = 0;
  v28 = *((_OWORD *)a1 + 1);
  *(_OWORD *)&v77.a = *(_OWORD *)a1;
  *(_OWORD *)&v77.c = v28;
  *(_OWORD *)&v77.tx = *((_OWORD *)a1 + 2);
  if (BVCUtilityIsAffineTransformInvertible(&v77.a))
  {
    memset(&v76, 0, sizeof(v76));
    v29 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v77.a = *(_OWORD *)a1;
    *(_OWORD *)&v77.c = v29;
    *(_OWORD *)&v77.tx = *((_OWORD *)a1 + 2);
    CGAffineTransformInvert(&v76, &v77);
    v64 = a1[3];
    v65 = *a1;
    v62 = a1[4];
    v63 = a1[2];
    v66 = a1[5];
    v68 = a1[1];
    v30 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v77.a = *(_OWORD *)a1;
    *(_OWORD *)&v77.c = v30;
    *(_OWORD *)&v77.tx = *((_OWORD *)a1 + 2);
    VectorsFromTransform = BVCUtilityGetVectorsFromTransform(&v77.a, &v85, &v84);
    if ((_DWORD)VectorsFromTransform)
    {
      v36 = VectorsFromTransform;
      v37 = 0;
    }
    else
    {
      v32 = v85;
      if ((int)v85 < 0)
        v32 = -(int)v85;
      v33 = v84;
      if ((int)v84 < 0)
        v33 = -(int)v84;
      if (v32 <= v33)
        v34 = v33;
      else
        v34 = v32;
      v77 = v76;
      BVCUtilityGetVectorsFromTransform(&v77.a, &v83, &v82);
      v35 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v77.a = *(_OWORD *)a1;
      *(_OWORD *)&v77.c = v35;
      *(_OWORD *)&v77.tx = *((_OWORD *)a1 + 2);
      v36 = BVCUtilityCreateEdgeLists((float64x2_t *)&v77, &v87, &v86, a6, a7, a8, a9, a10, a11, a12, a13);
      v37 = v87;
      if (!(_DWORD)v36)
      {
        if (v87)
        {
          v38 = v86;
          if (v86)
          {
            v39 = vcvts_n_s32_f32(a14, 8uLL);
            v40 = vcvtd_n_s64_f64(v62 + v63 * 0.0 + v65 * 0.0, 0x10uLL);
            v41 = vcvtd_n_s64_f64(v66 + v64 * 0.0 + v68 * 0.0, 0x10uLL);
            LODWORD(v77.a) = 0;
            v79 = 0;
            v78 = 0;
            v42 = *(_DWORD *)v87;
            if (*(_DWORD *)v87 <= *v86)
              v42 = *v86;
            v43 = v42 + 0x8000;
            v44 = (v42 + 0x8000) >> 16;
            v69 = v41;
            v45 = ((v42 + 0x8000) & 0xFFFF0000) - v41 + 0x8000;
            v67 = v40;
            LODWORD(v81) = ((unint64_t)((int)v82 * (uint64_t)v45) >> 16)
                         + ((unint64_t)((int)v83 * (uint64_t)(int)(0x8000 - v40)) >> 16)
                         - ((int)v82 > 0);
            HIDWORD(v81) = ((unint64_t)(SHIDWORD(v83) * (uint64_t)(int)(0x8000 - v40)) >> 16)
                         + ((unint64_t)(SHIDWORD(v82) * (uint64_t)v45) >> 16)
                         - (SHIDWORD(v82) > 0);
            bvc_extractEdgeParameters(v87, 0, v44, v34, 1, (_DWORD *)&v80 + 1, &v77, (int *)&v79);
            bvc_extractEdgeParameters(v38, 1, v43 >> 16, v34, 1, &v80, (_DWORD *)&v79 + 1, &v78);
            v70 = a5;
            v89 = *a5 + v20 * ((uint64_t)v43 >> 16);
            do
            {
              v47 = v78;
              v48 = v79;
              if ((int)v79 >= v78)
                v49 = v78;
              else
                v49 = v79;
              if (v49 > v44)
              {
                bvc_FullCompositionOpaqueYInner_420v_420v_arm((v49 - v44), v39, &v89, v20, v71, v72, (int *)&v80 + 1, (int *)&v80, v46, SLODWORD(v77.a), SHIDWORD(v79), (int *)&v81, (int *)&v81 + 1, v83, HIDWORD(v83), v82, SHIDWORD(v82));
                v44 = v49;
              }
              if (v44 >= v48)
              {
                v37 = *(char **)(v37 + 20);
                if (v37)
                  bvc_extractEdgeParameters(v37, 0, v44, v34, 1, (_DWORD *)&v80 + 1, &v77, (int *)&v79);
              }
              if (v44 >= v47)
              {
                v38 = *(_DWORD **)(v38 + 5);
                if (!v38)
                  break;
                bvc_extractEdgeParameters(v38, 1, v44, v34, 1, &v80, (_DWORD *)&v79 + 1, &v78);
              }
            }
            while (v37);
            v50 = v86;
            v51 = v87;
            v52 = *(_DWORD *)v87 / 2;
            if (v52 <= *v86 / 2)
              v52 = *v86 / 2;
            v53 = v52 + 0x8000;
            v54 = (v52 + 0x8000) >> 16;
            v55 = ((v52 + 0x8000) & 0xFFFF0000) - v69 / 2 + 0x8000;
            v56 = 0x8000 - v67 / 2;
            LODWORD(v81) = ((unint64_t)((int)v82 * (uint64_t)v55) >> 16)
                         + ((unint64_t)((int)v83 * (uint64_t)v56) >> 16)
                         - ((int)v82 > 0);
            HIDWORD(v81) = ((unint64_t)(SHIDWORD(v83) * (uint64_t)v56) >> 16)
                         + ((unint64_t)(SHIDWORD(v82) * (uint64_t)v55) >> 16)
                         - (SHIDWORD(v82) > 0);
            bvc_extractEdgeParameters(v87, 0, v54, v34, 2, (_DWORD *)&v80 + 1, &v77, (int *)&v79);
            bvc_extractEdgeParameters(v50, 1, v53 >> 16, v34, 2, &v80, (_DWORD *)&v79 + 1, &v78);
            v88 = v70[1] + v75 * ((uint64_t)v53 >> 16);
            do
            {
              v58 = v78;
              v59 = v79;
              if ((int)v79 >= v78)
                v60 = v78;
              else
                v60 = v79;
              if (v60 > v54)
              {
                bvc_FullCompositionOpaqueCbCrInner_420v_420v_arm((v60 - v54), v39, &v88, v75, v73, v74, (int *)&v80 + 1, (int *)&v80, v57, SLODWORD(v77.a), SHIDWORD(v79), (int *)&v81, (int *)&v81 + 1, v83, HIDWORD(v83), v82, SHIDWORD(v82));
                v54 = v60;
              }
              if (v54 >= v59)
              {
                v51 = *(char **)(v51 + 20);
                if (v51)
                  bvc_extractEdgeParameters(v51, 0, v54, v34, 2, (_DWORD *)&v80 + 1, &v77, (int *)&v79);
              }
              if (v54 >= v58)
              {
                v50 = *(_DWORD **)(v50 + 5);
                if (!v50)
                  break;
                bvc_extractEdgeParameters(v50, 1, v54, v34, 2, &v80, (_DWORD *)&v79 + 1, &v78);
              }
            }
            while (v51);
            v36 = 0;
            v37 = v87;
          }
        }
      }
    }
  }
  else
  {
    v37 = 0;
    v36 = 0;
  }
  BVCUtilityDestroyEdgeList((uint64_t)v37);
  BVCUtilityDestroyEdgeList((uint64_t)v86);
  return v36;
}

uint64_t bvc_FullComposition_420v_420v(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, _QWORD *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, float a14)
{
  uint64_t v20;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t VectorsFromTransform;
  unsigned int v32;
  unsigned int v33;
  int v34;
  __int128 v35;
  uint64_t v36;
  char *v37;
  _DWORD *v38;
  unsigned __int16 v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  signed int v45;
  int32x4_t v46;
  int v47;
  int v48;
  int v49;
  _DWORD *v50;
  char *v51;
  int v52;
  int v53;
  int v54;
  signed int v55;
  int v56;
  int32x4_t v57;
  int v58;
  int v59;
  int v60;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  signed int v67;
  double v68;
  signed int v69;
  _QWORD *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  CGAffineTransform v76;
  CGAffineTransform v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _DWORD *v86;
  char *v87;
  uint64_t v88;
  uint64_t v89;

  v71 = *a3;
  v72 = *a2;
  v73 = a3[1];
  v74 = a2[1];
  v88 = 0;
  v89 = 0;
  v20 = *a4;
  v75 = a4[1];
  v86 = 0;
  v87 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
    return FigSignalErrorAt();
  v84 = 0;
  v85 = 0;
  v82 = 0;
  v83 = 0;
  v80 = 0;
  v81 = 0;
  v28 = *((_OWORD *)a1 + 1);
  *(_OWORD *)&v77.a = *(_OWORD *)a1;
  *(_OWORD *)&v77.c = v28;
  *(_OWORD *)&v77.tx = *((_OWORD *)a1 + 2);
  if (BVCUtilityIsAffineTransformInvertible(&v77.a))
  {
    memset(&v76, 0, sizeof(v76));
    v29 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v77.a = *(_OWORD *)a1;
    *(_OWORD *)&v77.c = v29;
    *(_OWORD *)&v77.tx = *((_OWORD *)a1 + 2);
    CGAffineTransformInvert(&v76, &v77);
    v64 = a1[3];
    v65 = *a1;
    v62 = a1[4];
    v63 = a1[2];
    v66 = a1[5];
    v68 = a1[1];
    v30 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v77.a = *(_OWORD *)a1;
    *(_OWORD *)&v77.c = v30;
    *(_OWORD *)&v77.tx = *((_OWORD *)a1 + 2);
    VectorsFromTransform = BVCUtilityGetVectorsFromTransform(&v77.a, &v85, &v84);
    if ((_DWORD)VectorsFromTransform)
    {
      v36 = VectorsFromTransform;
      v37 = 0;
    }
    else
    {
      v32 = v85;
      if ((int)v85 < 0)
        v32 = -(int)v85;
      v33 = v84;
      if ((int)v84 < 0)
        v33 = -(int)v84;
      if (v32 <= v33)
        v34 = v33;
      else
        v34 = v32;
      v77 = v76;
      BVCUtilityGetVectorsFromTransform(&v77.a, &v83, &v82);
      v35 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v77.a = *(_OWORD *)a1;
      *(_OWORD *)&v77.c = v35;
      *(_OWORD *)&v77.tx = *((_OWORD *)a1 + 2);
      v36 = BVCUtilityCreateEdgeLists((float64x2_t *)&v77, &v87, &v86, a6, a7, a8, a9, a10, a11, a12, a13);
      v37 = v87;
      if (!(_DWORD)v36)
      {
        if (v87)
        {
          v38 = v86;
          if (v86)
          {
            v39 = vcvts_n_s32_f32(a14, 8uLL);
            v40 = vcvtd_n_s64_f64(v62 + v63 * 0.0 + v65 * 0.0, 0x10uLL);
            v41 = vcvtd_n_s64_f64(v66 + v64 * 0.0 + v68 * 0.0, 0x10uLL);
            LODWORD(v77.a) = 0;
            v79 = 0;
            v78 = 0;
            v42 = *(_DWORD *)v87;
            if (*(_DWORD *)v87 <= *v86)
              v42 = *v86;
            v43 = v42 + 0x8000;
            v44 = (v42 + 0x8000) >> 16;
            v69 = v41;
            v45 = ((v42 + 0x8000) & 0xFFFF0000) - v41 + 0x8000;
            v67 = v40;
            LODWORD(v81) = ((unint64_t)((int)v82 * (uint64_t)v45) >> 16)
                         + ((unint64_t)((int)v83 * (uint64_t)(int)(0x8000 - v40)) >> 16)
                         - ((int)v82 > 0);
            HIDWORD(v81) = ((unint64_t)(SHIDWORD(v83) * (uint64_t)(int)(0x8000 - v40)) >> 16)
                         + ((unint64_t)(SHIDWORD(v82) * (uint64_t)v45) >> 16)
                         - (SHIDWORD(v82) > 0);
            bvc_extractEdgeParameters(v87, 0, v44, v34, 1, (_DWORD *)&v80 + 1, &v77, (int *)&v79);
            bvc_extractEdgeParameters(v38, 1, v43 >> 16, v34, 1, &v80, (_DWORD *)&v79 + 1, &v78);
            v70 = a5;
            v89 = *a5 + v20 * ((uint64_t)v43 >> 16);
            do
            {
              v47 = v78;
              v48 = v79;
              if ((int)v79 >= v78)
                v49 = v78;
              else
                v49 = v79;
              if (v49 > v44)
              {
                bvc_FullCompositionYInner_420v_420v_arm((v49 - v44), v39, &v89, v20, v71, v72, (int *)&v80 + 1, (int *)&v80, v46, SLODWORD(v77.a), SHIDWORD(v79), (int *)&v81, (int *)&v81 + 1, v83, HIDWORD(v83), v82, SHIDWORD(v82));
                v44 = v49;
              }
              if (v44 >= v48)
              {
                v37 = *(char **)(v37 + 20);
                if (v37)
                  bvc_extractEdgeParameters(v37, 0, v44, v34, 1, (_DWORD *)&v80 + 1, &v77, (int *)&v79);
              }
              if (v44 >= v47)
              {
                v38 = *(_DWORD **)(v38 + 5);
                if (!v38)
                  break;
                bvc_extractEdgeParameters(v38, 1, v44, v34, 1, &v80, (_DWORD *)&v79 + 1, &v78);
              }
            }
            while (v37);
            v50 = v86;
            v51 = v87;
            v52 = *(_DWORD *)v87 / 2;
            if (v52 <= *v86 / 2)
              v52 = *v86 / 2;
            v53 = v52 + 0x8000;
            v54 = (v52 + 0x8000) >> 16;
            v55 = ((v52 + 0x8000) & 0xFFFF0000) - v69 / 2 + 0x8000;
            v56 = 0x8000 - v67 / 2;
            LODWORD(v81) = ((unint64_t)((int)v82 * (uint64_t)v55) >> 16)
                         + ((unint64_t)((int)v83 * (uint64_t)v56) >> 16)
                         - ((int)v82 > 0);
            HIDWORD(v81) = ((unint64_t)(SHIDWORD(v83) * (uint64_t)v56) >> 16)
                         + ((unint64_t)(SHIDWORD(v82) * (uint64_t)v55) >> 16)
                         - (SHIDWORD(v82) > 0);
            bvc_extractEdgeParameters(v87, 0, v54, v34, 2, (_DWORD *)&v80 + 1, &v77, (int *)&v79);
            bvc_extractEdgeParameters(v50, 1, v53 >> 16, v34, 2, &v80, (_DWORD *)&v79 + 1, &v78);
            v88 = v70[1] + v75 * ((uint64_t)v53 >> 16);
            do
            {
              v58 = v78;
              v59 = v79;
              if ((int)v79 >= v78)
                v60 = v78;
              else
                v60 = v79;
              if (v60 > v54)
              {
                bvc_FullCompositionCbCrInner_420v_420v_arm((v60 - v54), v39, &v88, v75, v73, v74, (int *)&v80 + 1, (int *)&v80, v57, SLODWORD(v77.a), SHIDWORD(v79), (int *)&v81, (int *)&v81 + 1, v83, HIDWORD(v83), v82, SHIDWORD(v82));
                v54 = v60;
              }
              if (v54 >= v59)
              {
                v51 = *(char **)(v51 + 20);
                if (v51)
                  bvc_extractEdgeParameters(v51, 0, v54, v34, 2, (_DWORD *)&v80 + 1, &v77, (int *)&v79);
              }
              if (v54 >= v58)
              {
                v50 = *(_DWORD **)(v50 + 5);
                if (!v50)
                  break;
                bvc_extractEdgeParameters(v50, 1, v54, v34, 2, &v80, (_DWORD *)&v79 + 1, &v78);
              }
            }
            while (v51);
            v36 = 0;
            v37 = v87;
          }
        }
      }
    }
  }
  else
  {
    v37 = 0;
    v36 = 0;
  }
  BVCUtilityDestroyEdgeList((uint64_t)v37);
  BVCUtilityDestroyEdgeList((uint64_t)v86);
  return v36;
}

uint64_t bvc_FullCompositionOpaque_ARGB_420v709(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, _QWORD *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t VectorsFromTransform;
  unsigned int v31;
  unsigned int v32;
  __int128 v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  signed int v38;
  _DWORD *v39;
  signed int v40;
  int v41;
  uint64_t v42;
  int v43;
  int v44;
  char *v45;
  int v46;
  _DWORD *v47;
  char *v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int a_low;
  int v61;
  unint64_t v62;
  int v63;
  int v64;
  unsigned __int8 *v65;
  int v66;
  unsigned int v67;
  _DWORD *v68;
  uint64_t v69;
  _BOOL4 v70;
  uint64_t v71;
  uint64_t v72;
  _BOOL4 v73;
  uint64_t v74;
  _DWORD *v75;
  char *v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  int v83;
  char *v84;
  uint64_t v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  unsigned __int8 *v101;
  int v102;
  int v103;
  int v104;
  int v105;
  unsigned int v106;
  unsigned int v107;
  _BYTE *v108;
  _BYTE *v109;
  int v110;
  _DWORD *v111;
  uint64_t v113;
  signed int v114;
  signed int v115;
  uint64_t v116;
  int v117;
  double v118;
  int v119;
  int v120;
  double v121;
  int v122;
  _DWORD *v123;
  double v124;
  int v125;
  int v126;
  char *v127;
  char *v128;
  char *v129;
  double v130;
  _DWORD *v131;
  _DWORD *v132;
  _DWORD *v133;
  uint64_t v134;
  double v135;
  char *v136;
  char *v137;
  char *v138;
  int v139;
  double v140;
  int v141;
  int v142;
  int v143;
  int v144;
  CGAffineTransform v145;
  CGAffineTransform v146;
  int v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  _DWORD *v154;
  char *v155;

  v15 = *a2;
  v16 = *a3;
  v18 = *a4;
  v17 = a4[1];
  v154 = 0;
  v155 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
    return FigSignalErrorAt();
  v152 = 0;
  v153 = 0;
  v151 = 0;
  v150 = 0;
  v27 = *((_OWORD *)a1 + 1);
  *(_OWORD *)&v146.a = *(_OWORD *)a1;
  *(_OWORD *)&v146.c = v27;
  *(_OWORD *)&v146.tx = *((_OWORD *)a1 + 2);
  if (BVCUtilityIsAffineTransformInvertible(&v146.a))
  {
    memset(&v145, 0, sizeof(v145));
    v28 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v146.a = *(_OWORD *)a1;
    *(_OWORD *)&v146.c = v28;
    *(_OWORD *)&v146.tx = *((_OWORD *)a1 + 2);
    CGAffineTransformInvert(&v145, &v146);
    v135 = *a1;
    v140 = a1[1];
    v130 = a1[3];
    v118 = a1[4];
    v121 = a1[2];
    v124 = a1[5];
    v29 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v146.a = *(_OWORD *)a1;
    *(_OWORD *)&v146.c = v29;
    *(_OWORD *)&v146.tx = *((_OWORD *)a1 + 2);
    VectorsFromTransform = BVCUtilityGetVectorsFromTransform(&v146.a, &v153, &v152);
    if ((_DWORD)VectorsFromTransform)
    {
      v34 = VectorsFromTransform;
    }
    else
    {
      v31 = v153;
      if ((int)v153 < 0)
        v31 = -(int)v153;
      v32 = v152;
      if ((int)v152 < 0)
        v32 = -(int)v152;
      if (v31 <= v32)
        v31 = v32;
      v120 = v31;
      v146 = v145;
      BVCUtilityGetVectorsFromTransform(&v146.a, &v151, &v150);
      v33 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v146.a = *(_OWORD *)a1;
      *(_OWORD *)&v146.c = v33;
      *(_OWORD *)&v146.tx = *((_OWORD *)a1 + 2);
      v34 = BVCUtilityCreateEdgeLists((float64x2_t *)&v146, &v155, &v154, a6, a7, a8, a9, a10, a11, a12, a13);
      if (!(_DWORD)v34 && v155 && v154)
      {
        v116 = v17;
        v35 = vcvtd_n_s64_f64(v118 + v121 * 0.0 + v135 * 0.0, 0x10uLL);
        v36 = vcvtd_n_s64_f64(v124 + v130 * 0.0 + v140 * 0.0, 0x10uLL);
        LODWORD(v146.a) = 0;
        v148 = 0;
        v149 = 0;
        v147 = 0;
        v37 = *(_DWORD *)v155;
        if (*(_DWORD *)v155 <= *v154)
          v37 = *v154;
        v114 = v35;
        v115 = v36;
        v38 = 0x8000 - v35;
        v39 = v154;
        v141 = v37 + 0x8000;
        v40 = ((v37 + 0x8000) & 0xFFFF0000) - v36 + 0x8000;
        v41 = ((unint64_t)((int)v151 * (uint64_t)v38) >> 16)
            - ((int)v150 > 0)
            + ((unint64_t)((int)v150 * (uint64_t)v40) >> 16);
        v42 = v18;
        v43 = (v37 + 0x8000) >> 16;
        v44 = ((unint64_t)(SHIDWORD(v151) * (uint64_t)v38) >> 16)
            - (SHIDWORD(v150) > 0)
            + ((unint64_t)(SHIDWORD(v150) * (uint64_t)v40) >> 16);
        v45 = v155;
        bvc_extractEdgeParameters(v155, 0, v43, v120, 1, &v146, &v149, (int *)&v148);
        bvc_extractEdgeParameters(v39, 1, v43, v120, 1, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
        v46 = v43;
        v47 = v39;
        v48 = v45;
        v49 = *a5 + v42 * ((uint64_t)v141 >> 16);
        do
        {
          v50 = v147;
          v51 = v148;
          if ((int)v148 < v147)
            v50 = v148;
          v52 = v50 - v46;
          if (v50 > v46)
          {
            v131 = v47;
            v136 = v48;
            v53 = 0;
            v54 = HIDWORD(v148);
            v55 = v149;
            v56 = v151;
            v57 = HIDWORD(v151);
            v58 = v150;
            v59 = HIDWORD(v150);
            a_low = LODWORD(v146.a);
            v122 = HIDWORD(v149);
            v61 = HIDWORD(v149);
            do
            {
              LODWORD(v62) = a_low >> 16;
              if (a_low >> 16 < (v61 >> 16))
              {
                v62 = (int)v62;
                v63 = v44 + ((unint64_t)(v57 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                v64 = v41 + ((unint64_t)(v56 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                do
                {
                  v65 = (unsigned __int8 *)(v16
                                          + (((uint64_t)v64 >> 14) & 0xFFFFFFFFFFFFFFFCLL)
                                          + ((v63 >> 16) * v15));
                  v66 = *v65;
                  if (*v65)
                  {
                    v67 = (2120 * v66 + 2032 * v65[3] + 20127 * v65[2] + 5983 * v65[1]) >> 15;
                    if (v66 != 255)
                      v67 += ((16776959 * v66 + 0x10000) * *(unsigned __int8 *)(v49 + v62)) >> 16;
                    *(_BYTE *)(v49 + v62) = v67;
                  }
                  v64 += v56;
                  v63 += v57;
                  ++v62;
                }
                while (v62 < (uint64_t)v61 >> 16);
              }
              a_low += v55;
              v61 += v54;
              v41 += v58;
              v44 += v59;
              v49 += v42;
              ++v53;
            }
            while (v53 != v52);
            LODWORD(v146.a) = a_low;
            HIDWORD(v149) = v122 + v54 * v52;
            v51 = v148;
            v46 = v50;
            v47 = v131;
            v48 = v136;
          }
          if (v46 >= v51)
          {
            v48 = *(char **)(v48 + 20);
            if (v48)
            {
              v125 = v46;
              v132 = v47;
              v137 = v48;
              bvc_extractEdgeParameters(v48, 0, v46, v120, 1, &v146, &v149, (int *)&v148);
              v46 = v125;
              v47 = v132;
              v48 = v137;
            }
          }
          if (v46 >= v147)
          {
            v68 = *(_DWORD **)(v47 + 5);
            if (!v68)
              break;
            v126 = v46;
            v133 = v68;
            v138 = v48;
            bvc_extractEdgeParameters(v68, 1, v46, v120, 1, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
            v46 = v126;
            v47 = v133;
            v48 = v138;
          }
        }
        while (v48);
        v69 = 2 * (int)v151;
        v70 = (int)v150 > 0;
        v71 = 2 * (int)v150;
        v72 = 2 * SHIDWORD(v151);
        LODWORD(v151) = 2 * v151;
        HIDWORD(v151) *= 2;
        v73 = SHIDWORD(v150) > 0;
        v74 = 2 * SHIDWORD(v150);
        LODWORD(v150) = 2 * v150;
        HIDWORD(v150) *= 2;
        v75 = v154;
        v76 = v155;
        v77 = *(_DWORD *)v155 / 2;
        if (v77 <= *v154 / 2)
          v77 = *v154 / 2;
        v78 = v77 + 0x8000;
        v79 = (int)(((v77 + 0x8000) & 0xFFFF0000) - v115 / 2 + 0x8000);
        v80 = 0x8000 - v114 / 2;
        v81 = ((unint64_t)(v69 * v80) >> 16) - v70 + ((unint64_t)(v79 * v71) >> 16);
        v82 = ((unint64_t)(v72 * v80) >> 16) - v73 + ((unint64_t)(v79 * v74) >> 16);
        bvc_extractEdgeParameters(v155, 0, (v77 + 0x8000) >> 16, v120, 2, &v146, &v149, (int *)&v148);
        v123 = v75;
        bvc_extractEdgeParameters(v75, 1, v78 >> 16, v120, 2, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
        v83 = v78 >> 16;
        v84 = v76;
        v85 = a5[1] + v116 * ((uint64_t)v78 >> 16);
        v134 = v116;
        do
        {
          v86 = v147;
          v87 = v148;
          if ((int)v148 < v147)
            v86 = v148;
          v88 = v86 - v83;
          if (v86 > v83)
          {
            v119 = v86;
            v127 = v84;
            v89 = 0;
            v90 = HIDWORD(v148);
            v142 = v149;
            v91 = v151;
            v92 = HIDWORD(v151);
            v93 = HIDWORD(v150);
            v139 = v150;
            v94 = LODWORD(v146.a);
            v117 = HIDWORD(v149);
            v95 = HIDWORD(v149);
            do
            {
              v96 = v94 >> 16;
              if (v94 >> 16 < (v95 >> 16))
              {
                v97 = v96;
                v98 = 2 * v96;
                v99 = v82 + ((unint64_t)(v92 * (uint64_t)(int)(v94 & 0xFFFF0000)) >> 16);
                v100 = v81 + ((unint64_t)(v91 * (uint64_t)(int)(v94 & 0xFFFF0000)) >> 16);
                do
                {
                  v101 = (unsigned __int8 *)(v16
                                           + (((uint64_t)v100 >> 14) & 0xFFFFFFFFFFFFFFFCLL)
                                           + ((v99 >> 16) * v15));
                  v102 = *v101;
                  if (*v101)
                  {
                    v103 = v101[3];
                    v104 = v101[2];
                    v105 = v101[1];
                    v106 = (14392 * v103 + 16512 * v102 - 11093 * v104 - 3298 * v105) >> 15;
                    v107 = (-1317 * v103 + 16512 * v102 - 13073 * v104 + 14392 * v105) >> 15;
                    if (v102 == 255)
                    {
                      v108 = (_BYTE *)(v85 + v98);
                      *v108 = v106;
                      v108[1] = v107;
                    }
                    else
                    {
                      v109 = (_BYTE *)(v85 + v98);
                      v110 = 0x10000 - (v102 | (v102 << 8));
                      *v109 = v106 + ((v110 * *(unsigned __int8 *)(v85 + v98)) >> 16);
                      v109[1] = v107 + ((v110 * *(unsigned __int8 *)(v85 + v98 + 1)) >> 16);
                    }
                  }
                  v100 += v91;
                  v99 += v92;
                  ++v97;
                  v98 += 2;
                }
                while (v97 < (uint64_t)v95 >> 16);
              }
              v94 += v142;
              v95 += v90;
              v81 += v139;
              v82 += v93;
              v85 += v134;
              ++v89;
            }
            while (v89 != v88);
            LODWORD(v146.a) = v94;
            HIDWORD(v149) = v117 + v90 * v88;
            v87 = v148;
            v83 = v119;
            v84 = v127;
          }
          if (v83 >= v87)
          {
            v84 = *(char **)(v84 + 20);
            if (v84)
            {
              v143 = v83;
              v128 = v84;
              bvc_extractEdgeParameters(v84, 0, v83, v120, 2, &v146, &v149, (int *)&v148);
              v83 = v143;
              v84 = v128;
            }
          }
          if (v83 >= v147)
          {
            v111 = *(_DWORD **)(v123 + 5);
            if (!v111)
              goto LABEL_65;
            v123 = *(_DWORD **)(v123 + 5);
            v129 = v84;
            v144 = v83;
            bvc_extractEdgeParameters(v111, 1, v83, v120, 2, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
            v83 = v144;
            v84 = v129;
          }
          v34 = 0;
        }
        while (v84 && v123);
      }
    }
  }
  else
  {
LABEL_65:
    v34 = 0;
  }
  v113 = v34;
  BVCUtilityDestroyEdgeList((uint64_t)v155);
  BVCUtilityDestroyEdgeList((uint64_t)v154);
  return v113;
}

uint64_t bvc_FullComposition_ARGB_420v709(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, _QWORD *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, float a14)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t VectorsFromTransform;
  unsigned int v35;
  unsigned int v36;
  __int128 v37;
  uint64_t v38;
  _DWORD *v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  signed int v44;
  signed int v45;
  int v46;
  int v47;
  int v48;
  char *v49;
  int v50;
  _DWORD *v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int a_low;
  int v65;
  unint64_t v66;
  int v67;
  int v68;
  unsigned __int8 *v69;
  int v70;
  _DWORD *v71;
  uint64_t v72;
  _BOOL4 v73;
  uint64_t v74;
  uint64_t v75;
  _BOOL4 v76;
  uint64_t v77;
  char *v78;
  int v79;
  int v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  char *v86;
  uint64_t v87;
  int32x2_t v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  unint64_t v102;
  int v103;
  int v104;
  unsigned __int8 *v105;
  int v106;
  uint32x2_t v107;
  unsigned __int8 *v108;
  int32x2_t v109;
  uint32x2_t v110;
  char *v111;
  _DWORD *v112;
  char *v113;
  signed int v115;
  signed int v116;
  uint64_t v117;
  double v118;
  _QWORD *v119;
  double v120;
  int v121;
  double v122;
  int v123;
  double v124;
  _DWORD *v125;
  _DWORD *v126;
  double v127;
  char *v128;
  char *v129;
  char *v130;
  double v131;
  int v132;
  uint64_t v133;
  char *v134;
  uint64_t v135;
  int v136;
  int v137;
  int v138;
  _DWORD *v139;
  CGAffineTransform v140;
  CGAffineTransform v141;
  int v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  _DWORD *v149;
  char *v150;

  v20 = *a2;
  v21 = *a3;
  v23 = *a4;
  v22 = a4[1];
  v149 = 0;
  v150 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
    return FigSignalErrorAt();
  v147 = 0;
  v148 = 0;
  v146 = 0;
  v145 = 0;
  v31 = *((_OWORD *)a1 + 1);
  *(_OWORD *)&v141.a = *(_OWORD *)a1;
  *(_OWORD *)&v141.c = v31;
  *(_OWORD *)&v141.tx = *((_OWORD *)a1 + 2);
  if (BVCUtilityIsAffineTransformInvertible(&v141.a))
  {
    memset(&v140, 0, sizeof(v140));
    v32 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v141.a = *(_OWORD *)a1;
    *(_OWORD *)&v141.c = v32;
    *(_OWORD *)&v141.tx = *((_OWORD *)a1 + 2);
    CGAffineTransformInvert(&v140, &v141);
    v127 = *a1;
    v131 = a1[1];
    v124 = a1[3];
    v118 = a1[4];
    v120 = a1[2];
    v122 = a1[5];
    v33 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v141.a = *(_OWORD *)a1;
    *(_OWORD *)&v141.c = v33;
    *(_OWORD *)&v141.tx = *((_OWORD *)a1 + 2);
    VectorsFromTransform = BVCUtilityGetVectorsFromTransform(&v141.a, &v148, &v147);
    if ((_DWORD)VectorsFromTransform)
    {
      v38 = VectorsFromTransform;
    }
    else
    {
      v35 = v148;
      if ((int)v148 < 0)
        v35 = -(int)v148;
      v36 = v147;
      if ((int)v147 < 0)
        v36 = -(int)v147;
      if (v35 <= v36)
        v35 = v36;
      v123 = v35;
      v141 = v140;
      BVCUtilityGetVectorsFromTransform(&v141.a, &v146, &v145);
      v37 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v141.a = *(_OWORD *)a1;
      *(_OWORD *)&v141.c = v37;
      *(_OWORD *)&v141.tx = *((_OWORD *)a1 + 2);
      v38 = BVCUtilityCreateEdgeLists((float64x2_t *)&v141, &v150, &v149, a6, a7, a8, a9, a10, a11, a12, a13);
      if (!(_DWORD)v38)
      {
        if (v150)
        {
          v39 = v149;
          if (v149)
          {
            v117 = v22;
            v40 = vcvts_n_s32_f32(a14, 8uLL);
            v41 = vcvtd_n_s64_f64(v118 + v120 * 0.0 + v127 * 0.0, 0x10uLL);
            v42 = vcvtd_n_s64_f64(v122 + v124 * 0.0 + v131 * 0.0, 0x10uLL);
            LODWORD(v141.a) = 0;
            v143 = 0;
            v144 = 0;
            v142 = 0;
            v43 = *(_DWORD *)v150;
            if (*(_DWORD *)v150 <= *v149)
              v43 = *v149;
            v115 = v41;
            v116 = v42;
            v44 = 0x8000 - v41;
            v132 = v43 + 0x8000;
            v135 = v23;
            v45 = ((v43 + 0x8000) & 0xFFFF0000) - v42 + 0x8000;
            v46 = ((unint64_t)((int)v146 * (uint64_t)v44) >> 16)
                - ((int)v145 > 0)
                + ((unint64_t)((int)v145 * (uint64_t)v45) >> 16);
            v47 = (v43 + 0x8000) >> 16;
            v48 = ((unint64_t)(SHIDWORD(v146) * (uint64_t)v44) >> 16)
                - (SHIDWORD(v145) > 0)
                + ((unint64_t)(SHIDWORD(v145) * (uint64_t)v45) >> 16);
            v49 = v150;
            bvc_extractEdgeParameters(v150, 0, v47, v123, 1, &v141, &v144, (int *)&v143);
            bvc_extractEdgeParameters(v39, 1, v47, v123, 1, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
            v50 = v47;
            v51 = v39;
            v52 = v49;
            v119 = a5;
            v53 = *a5 + v135 * ((uint64_t)v132 >> 16);
            v54 = (0x10101020000 * (v40 << 8)) >> 48;
            v133 = v135;
            do
            {
              v55 = v142;
              v56 = v143;
              if ((int)v143 < v142)
                v55 = v143;
              v57 = v55 - v50;
              if (v55 > v50)
              {
                v128 = v52;
                v58 = 0;
                v59 = HIDWORD(v143);
                v136 = v144;
                v60 = v146;
                v61 = HIDWORD(v146);
                v62 = v145;
                v63 = HIDWORD(v145);
                a_low = LODWORD(v141.a);
                v121 = HIDWORD(v144);
                v65 = HIDWORD(v144);
                do
                {
                  LODWORD(v66) = a_low >> 16;
                  if (a_low >> 16 < (v65 >> 16))
                  {
                    v66 = (int)v66;
                    v67 = v48 + ((unint64_t)(v61 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                    v68 = v46 + ((unint64_t)(v60 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                    do
                    {
                      v69 = (unsigned __int8 *)(v21
                                              + (((uint64_t)v68 >> 14) & 0xFFFFFFFFFFFFFFFCLL)
                                              + ((v67 >> 16) * v20));
                      v70 = *v69;
                      if ((_DWORD)v54 * v70)
                        *(_BYTE *)(v53 + v66) = (unsigned __int16)(((2120 * v70
                                                                   + 2032 * v69[3]
                                                                   + 20127 * v69[2]
                                                                   + 5983 * v69[1]) >> 15)
                                                                 * v40
                                                                 + (((0x10000 - (_DWORD)v54 * v70)
                                                                   * *(unsigned __int8 *)(v53 + v66)) >> 8)) >> 8;
                      v68 += v60;
                      v67 += v61;
                      ++v66;
                    }
                    while (v66 < (uint64_t)v65 >> 16);
                  }
                  a_low += v136;
                  v65 += v59;
                  v46 += v62;
                  v48 += v63;
                  v53 += v133;
                  ++v58;
                }
                while (v58 != v57);
                LODWORD(v141.a) = a_low;
                HIDWORD(v144) = v121 + v59 * v57;
                v56 = v143;
                v50 = v55;
                v52 = v128;
              }
              if (v50 >= v56)
              {
                v52 = *(char **)(v52 + 20);
                if (v52)
                {
                  v137 = v50;
                  v125 = v51;
                  v129 = v52;
                  bvc_extractEdgeParameters(v52, 0, v50, v123, 1, &v141, &v144, (int *)&v143);
                  v50 = v137;
                  v51 = v125;
                  v52 = v129;
                }
              }
              if (v50 >= v142)
              {
                v71 = *(_DWORD **)(v51 + 5);
                if (!v71)
                  break;
                v138 = v50;
                v126 = v71;
                v130 = v52;
                bvc_extractEdgeParameters(v71, 1, v50, v123, 1, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
                v50 = v138;
                v51 = v126;
                v52 = v130;
              }
            }
            while (v52 && v51);
            v72 = 2 * (int)v146;
            v73 = (int)v145 > 0;
            v74 = 2 * (int)v145;
            v75 = 2 * SHIDWORD(v146);
            LODWORD(v146) = 2 * v146;
            HIDWORD(v146) *= 2;
            v76 = SHIDWORD(v145) > 0;
            v77 = 2 * SHIDWORD(v145);
            LODWORD(v145) = 2 * v145;
            HIDWORD(v145) *= 2;
            v78 = v150;
            v139 = v149;
            v79 = *(_DWORD *)v150 / 2;
            if (v79 <= *v149 / 2)
              v79 = *v149 / 2;
            v80 = v79 + 0x8000;
            v81 = (v79 + 0x8000) >> 16;
            v82 = (int)(((v79 + 0x8000) & 0xFFFF0000) - v116 / 2 + 0x8000);
            v83 = 0x8000 - v115 / 2;
            v84 = ((unint64_t)(v72 * v83) >> 16) - v73 + ((unint64_t)(v82 * v74) >> 16);
            v85 = ((unint64_t)(v75 * v83) >> 16) - v76 + ((unint64_t)(v82 * v77) >> 16);
            bvc_extractEdgeParameters(v150, 0, v81, v123, 2, &v141, &v144, (int *)&v143);
            bvc_extractEdgeParameters(v139, 1, v80 >> 16, v123, 2, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
            v86 = v78;
            v87 = v119[1] + v117 * ((uint64_t)v80 >> 16);
            v88 = vdup_n_s32(v40);
            do
            {
              v89 = v143;
              if ((int)v143 >= v142)
                v90 = v142;
              else
                v90 = v143;
              v91 = v90 - v81;
              if (v90 > v81)
              {
                v134 = v86;
                v92 = 0;
                v93 = HIDWORD(v143);
                v94 = v144;
                v95 = v146;
                v96 = HIDWORD(v146);
                v97 = v145;
                v98 = HIDWORD(v145);
                v99 = LODWORD(v141.a);
                v100 = HIDWORD(v144);
                v101 = HIDWORD(v144);
                do
                {
                  LODWORD(v102) = v99 >> 16;
                  if (v99 >> 16 < (v101 >> 16))
                  {
                    v102 = (int)v102;
                    v103 = v85 + ((unint64_t)(v96 * (uint64_t)(int)(v99 & 0xFFFF0000)) >> 16);
                    v104 = v84 + ((unint64_t)(v95 * (uint64_t)(int)(v99 & 0xFFFF0000)) >> 16);
                    do
                    {
                      v105 = (unsigned __int8 *)(v21
                                               + (((uint64_t)v104 >> 14) & 0xFFFFFFFFFFFFFFFCLL)
                                               + ((v103 >> 16) * v20));
                      v106 = *v105;
                      if ((_DWORD)v54 * v106)
                      {
                        v107 = (uint32x2_t)vmul_s32((int32x2_t)vshr_n_u32((uint32x2_t)vmla_s32(vmla_s32(vmla_s32(vdup_n_s32(16512 * v106), vdup_n_s32(v105[3]), (int32x2_t)0xFFFFFADB00003838), vdup_n_s32(v105[2]), (int32x2_t)0xFFFFCCEFFFFFD4ABLL), vdup_n_s32(v105[1]), (int32x2_t)0x3838FFFFF31ELL), 0xFuLL), v88);
                        v108 = (unsigned __int8 *)(v87 + 2 * v102);
                        v109.i32[0] = *v108;
                        v109.i32[1] = v108[1];
                        v110 = vshr_n_u32(vsra_n_u32(v107, (uint32x2_t)vmul_s32(vdup_n_s32(0x10000 - (int)v54 * v106), v109), 8uLL), 8uLL);
                        *v108 = v110.i8[0];
                        v108[1] = v110.u8[4];
                      }
                      v104 += v95;
                      v103 += v96;
                      ++v102;
                    }
                    while (v102 < (uint64_t)v101 >> 16);
                  }
                  v99 += v94;
                  v101 += v93;
                  v84 += v97;
                  v85 += v98;
                  v87 += v117;
                  ++v92;
                }
                while (v92 != v91);
                LODWORD(v141.a) = v99;
                HIDWORD(v144) = v100 + v93 * v91;
                v89 = v143;
                v81 = v90;
                v86 = v134;
              }
              if (v81 >= v89)
              {
                v86 = *(char **)(v86 + 20);
                if (v86)
                {
                  v111 = v86;
                  bvc_extractEdgeParameters(v86, 0, v81, v123, 2, &v141, &v144, (int *)&v143);
                  v86 = v111;
                }
              }
              if (v81 >= v142)
              {
                v112 = *(_DWORD **)(v139 + 5);
                if (!v112)
                  goto LABEL_63;
                v139 = *(_DWORD **)(v139 + 5);
                v113 = v86;
                bvc_extractEdgeParameters(v112, 1, v81, v123, 2, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
                v86 = v113;
              }
              v38 = 0;
            }
            while (v86 && v139);
          }
        }
      }
    }
  }
  else
  {
LABEL_63:
    v38 = 0;
  }
  BVCUtilityDestroyEdgeList((uint64_t)v150);
  BVCUtilityDestroyEdgeList((uint64_t)v149);
  return v38;
}

uint64_t bvc_FullCompositionOpaque_ARGB_420v601(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, _QWORD *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t VectorsFromTransform;
  unsigned int v31;
  unsigned int v32;
  __int128 v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  signed int v38;
  _DWORD *v39;
  signed int v40;
  int v41;
  uint64_t v42;
  int v43;
  int v44;
  char *v45;
  int v46;
  _DWORD *v47;
  char *v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int a_low;
  int v61;
  unint64_t v62;
  int v63;
  int v64;
  unsigned __int8 *v65;
  int v66;
  unsigned int v67;
  _DWORD *v68;
  uint64_t v69;
  _BOOL4 v70;
  uint64_t v71;
  uint64_t v72;
  _BOOL4 v73;
  uint64_t v74;
  _DWORD *v75;
  char *v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  int v83;
  char *v84;
  uint64_t v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  unsigned __int8 *v101;
  int v102;
  int v103;
  int v104;
  int v105;
  unsigned int v106;
  unsigned int v107;
  _BYTE *v108;
  _BYTE *v109;
  int v110;
  _DWORD *v111;
  uint64_t v113;
  signed int v114;
  signed int v115;
  uint64_t v116;
  int v117;
  double v118;
  int v119;
  int v120;
  double v121;
  int v122;
  _DWORD *v123;
  double v124;
  int v125;
  int v126;
  char *v127;
  char *v128;
  char *v129;
  double v130;
  _DWORD *v131;
  _DWORD *v132;
  _DWORD *v133;
  uint64_t v134;
  double v135;
  char *v136;
  char *v137;
  char *v138;
  int v139;
  double v140;
  int v141;
  int v142;
  int v143;
  int v144;
  CGAffineTransform v145;
  CGAffineTransform v146;
  int v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  _DWORD *v154;
  char *v155;

  v15 = *a2;
  v16 = *a3;
  v18 = *a4;
  v17 = a4[1];
  v154 = 0;
  v155 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
    return FigSignalErrorAt();
  v152 = 0;
  v153 = 0;
  v151 = 0;
  v150 = 0;
  v27 = *((_OWORD *)a1 + 1);
  *(_OWORD *)&v146.a = *(_OWORD *)a1;
  *(_OWORD *)&v146.c = v27;
  *(_OWORD *)&v146.tx = *((_OWORD *)a1 + 2);
  if (BVCUtilityIsAffineTransformInvertible(&v146.a))
  {
    memset(&v145, 0, sizeof(v145));
    v28 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v146.a = *(_OWORD *)a1;
    *(_OWORD *)&v146.c = v28;
    *(_OWORD *)&v146.tx = *((_OWORD *)a1 + 2);
    CGAffineTransformInvert(&v145, &v146);
    v135 = *a1;
    v140 = a1[1];
    v130 = a1[3];
    v118 = a1[4];
    v121 = a1[2];
    v124 = a1[5];
    v29 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v146.a = *(_OWORD *)a1;
    *(_OWORD *)&v146.c = v29;
    *(_OWORD *)&v146.tx = *((_OWORD *)a1 + 2);
    VectorsFromTransform = BVCUtilityGetVectorsFromTransform(&v146.a, &v153, &v152);
    if ((_DWORD)VectorsFromTransform)
    {
      v34 = VectorsFromTransform;
    }
    else
    {
      v31 = v153;
      if ((int)v153 < 0)
        v31 = -(int)v153;
      v32 = v152;
      if ((int)v152 < 0)
        v32 = -(int)v152;
      if (v31 <= v32)
        v31 = v32;
      v120 = v31;
      v146 = v145;
      BVCUtilityGetVectorsFromTransform(&v146.a, &v151, &v150);
      v33 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v146.a = *(_OWORD *)a1;
      *(_OWORD *)&v146.c = v33;
      *(_OWORD *)&v146.tx = *((_OWORD *)a1 + 2);
      v34 = BVCUtilityCreateEdgeLists((float64x2_t *)&v146, &v155, &v154, a6, a7, a8, a9, a10, a11, a12, a13);
      if (!(_DWORD)v34 && v155 && v154)
      {
        v116 = v17;
        v35 = vcvtd_n_s64_f64(v118 + v121 * 0.0 + v135 * 0.0, 0x10uLL);
        v36 = vcvtd_n_s64_f64(v124 + v130 * 0.0 + v140 * 0.0, 0x10uLL);
        LODWORD(v146.a) = 0;
        v148 = 0;
        v149 = 0;
        v147 = 0;
        v37 = *(_DWORD *)v155;
        if (*(_DWORD *)v155 <= *v154)
          v37 = *v154;
        v114 = v35;
        v115 = v36;
        v38 = 0x8000 - v35;
        v39 = v154;
        v141 = v37 + 0x8000;
        v40 = ((v37 + 0x8000) & 0xFFFF0000) - v36 + 0x8000;
        v41 = ((unint64_t)((int)v151 * (uint64_t)v38) >> 16)
            - ((int)v150 > 0)
            + ((unint64_t)((int)v150 * (uint64_t)v40) >> 16);
        v42 = v18;
        v43 = (v37 + 0x8000) >> 16;
        v44 = ((unint64_t)(SHIDWORD(v151) * (uint64_t)v38) >> 16)
            - (SHIDWORD(v150) > 0)
            + ((unint64_t)(SHIDWORD(v150) * (uint64_t)v40) >> 16);
        v45 = v155;
        bvc_extractEdgeParameters(v155, 0, v43, v120, 1, &v146, &v149, (int *)&v148);
        bvc_extractEdgeParameters(v39, 1, v43, v120, 1, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
        v46 = v43;
        v47 = v39;
        v48 = v45;
        v49 = *a5 + v42 * ((uint64_t)v141 >> 16);
        do
        {
          v50 = v147;
          v51 = v148;
          if ((int)v148 < v147)
            v50 = v148;
          v52 = v50 - v46;
          if (v50 > v46)
          {
            v131 = v47;
            v136 = v48;
            v53 = 0;
            v54 = HIDWORD(v148);
            v55 = v149;
            v56 = v151;
            v57 = HIDWORD(v151);
            v58 = v150;
            v59 = HIDWORD(v150);
            a_low = LODWORD(v146.a);
            v122 = HIDWORD(v149);
            v61 = HIDWORD(v149);
            do
            {
              LODWORD(v62) = a_low >> 16;
              if (a_low >> 16 < (v61 >> 16))
              {
                v62 = (int)v62;
                v63 = v44 + ((unint64_t)(v57 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                v64 = v41 + ((unint64_t)(v56 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                do
                {
                  v65 = (unsigned __int8 *)(v16
                                          + (((uint64_t)v64 >> 14) & 0xFFFFFFFFFFFFFFFCLL)
                                          + ((v63 >> 16) * v15));
                  v66 = *v65;
                  if (*v65)
                  {
                    v67 = (2120 * v66 + 3219 * v65[3] + 16508 * v65[2] + 8412 * v65[1]) >> 15;
                    if (v66 != 255)
                      v67 += ((16776959 * v66 + 0x10000) * *(unsigned __int8 *)(v49 + v62)) >> 16;
                    *(_BYTE *)(v49 + v62) = v67;
                  }
                  v64 += v56;
                  v63 += v57;
                  ++v62;
                }
                while (v62 < (uint64_t)v61 >> 16);
              }
              a_low += v55;
              v61 += v54;
              v41 += v58;
              v44 += v59;
              v49 += v42;
              ++v53;
            }
            while (v53 != v52);
            LODWORD(v146.a) = a_low;
            HIDWORD(v149) = v122 + v54 * v52;
            v51 = v148;
            v46 = v50;
            v47 = v131;
            v48 = v136;
          }
          if (v46 >= v51)
          {
            v48 = *(char **)(v48 + 20);
            if (v48)
            {
              v125 = v46;
              v132 = v47;
              v137 = v48;
              bvc_extractEdgeParameters(v48, 0, v46, v120, 1, &v146, &v149, (int *)&v148);
              v46 = v125;
              v47 = v132;
              v48 = v137;
            }
          }
          if (v46 >= v147)
          {
            v68 = *(_DWORD **)(v47 + 5);
            if (!v68)
              break;
            v126 = v46;
            v133 = v68;
            v138 = v48;
            bvc_extractEdgeParameters(v68, 1, v46, v120, 1, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
            v46 = v126;
            v47 = v133;
            v48 = v138;
          }
        }
        while (v48);
        v69 = 2 * (int)v151;
        v70 = (int)v150 > 0;
        v71 = 2 * (int)v150;
        v72 = 2 * SHIDWORD(v151);
        LODWORD(v151) = 2 * v151;
        HIDWORD(v151) *= 2;
        v73 = SHIDWORD(v150) > 0;
        v74 = 2 * SHIDWORD(v150);
        LODWORD(v150) = 2 * v150;
        HIDWORD(v150) *= 2;
        v75 = v154;
        v76 = v155;
        v77 = *(_DWORD *)v155 / 2;
        if (v77 <= *v154 / 2)
          v77 = *v154 / 2;
        v78 = v77 + 0x8000;
        v79 = (int)(((v77 + 0x8000) & 0xFFFF0000) - v115 / 2 + 0x8000);
        v80 = 0x8000 - v114 / 2;
        v81 = ((unint64_t)(v69 * v80) >> 16) - v70 + ((unint64_t)(v79 * v71) >> 16);
        v82 = ((unint64_t)(v72 * v80) >> 16) - v73 + ((unint64_t)(v79 * v74) >> 16);
        bvc_extractEdgeParameters(v155, 0, (v77 + 0x8000) >> 16, v120, 2, &v146, &v149, (int *)&v148);
        v123 = v75;
        bvc_extractEdgeParameters(v75, 1, v78 >> 16, v120, 2, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
        v83 = v78 >> 16;
        v84 = v76;
        v85 = a5[1] + v116 * ((uint64_t)v78 >> 16);
        v134 = v116;
        do
        {
          v86 = v147;
          v87 = v148;
          if ((int)v148 < v147)
            v86 = v148;
          v88 = v86 - v83;
          if (v86 > v83)
          {
            v119 = v86;
            v127 = v84;
            v89 = 0;
            v90 = HIDWORD(v148);
            v142 = v149;
            v91 = v151;
            v92 = HIDWORD(v151);
            v93 = HIDWORD(v150);
            v139 = v150;
            v94 = LODWORD(v146.a);
            v117 = HIDWORD(v149);
            v95 = HIDWORD(v149);
            do
            {
              v96 = v94 >> 16;
              if (v94 >> 16 < (v95 >> 16))
              {
                v97 = v96;
                v98 = 2 * v96;
                v99 = v82 + ((unint64_t)(v92 * (uint64_t)(int)(v94 & 0xFFFF0000)) >> 16);
                v100 = v81 + ((unint64_t)(v91 * (uint64_t)(int)(v94 & 0xFFFF0000)) >> 16);
                do
                {
                  v101 = (unsigned __int8 *)(v16
                                           + (((uint64_t)v100 >> 14) & 0xFFFFFFFFFFFFFFFCLL)
                                           + ((v99 >> 16) * v15));
                  v102 = *v101;
                  if (*v101)
                  {
                    v103 = v101[3];
                    v104 = v101[2];
                    v105 = v101[1];
                    v106 = (14392 * v103 + 16512 * v102 - 9532 * v104 - 4858 * v105) >> 15;
                    v107 = (-2348 * v103 + 16512 * v102 - 12040 * v104 + 14392 * v105) >> 15;
                    if (v102 == 255)
                    {
                      v108 = (_BYTE *)(v85 + v98);
                      *v108 = v106;
                      v108[1] = v107;
                    }
                    else
                    {
                      v109 = (_BYTE *)(v85 + v98);
                      v110 = 0x10000 - (v102 | (v102 << 8));
                      *v109 = v106 + ((v110 * *(unsigned __int8 *)(v85 + v98)) >> 16);
                      v109[1] = v107 + ((v110 * *(unsigned __int8 *)(v85 + v98 + 1)) >> 16);
                    }
                  }
                  v100 += v91;
                  v99 += v92;
                  ++v97;
                  v98 += 2;
                }
                while (v97 < (uint64_t)v95 >> 16);
              }
              v94 += v142;
              v95 += v90;
              v81 += v139;
              v82 += v93;
              v85 += v134;
              ++v89;
            }
            while (v89 != v88);
            LODWORD(v146.a) = v94;
            HIDWORD(v149) = v117 + v90 * v88;
            v87 = v148;
            v83 = v119;
            v84 = v127;
          }
          if (v83 >= v87)
          {
            v84 = *(char **)(v84 + 20);
            if (v84)
            {
              v143 = v83;
              v128 = v84;
              bvc_extractEdgeParameters(v84, 0, v83, v120, 2, &v146, &v149, (int *)&v148);
              v83 = v143;
              v84 = v128;
            }
          }
          if (v83 >= v147)
          {
            v111 = *(_DWORD **)(v123 + 5);
            if (!v111)
              goto LABEL_65;
            v123 = *(_DWORD **)(v123 + 5);
            v129 = v84;
            v144 = v83;
            bvc_extractEdgeParameters(v111, 1, v83, v120, 2, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
            v83 = v144;
            v84 = v129;
          }
          v34 = 0;
        }
        while (v84 && v123);
      }
    }
  }
  else
  {
LABEL_65:
    v34 = 0;
  }
  v113 = v34;
  BVCUtilityDestroyEdgeList((uint64_t)v155);
  BVCUtilityDestroyEdgeList((uint64_t)v154);
  return v113;
}

uint64_t bvc_FullComposition_ARGB_420v601(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, _QWORD *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, float a14)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t VectorsFromTransform;
  unsigned int v35;
  unsigned int v36;
  __int128 v37;
  uint64_t v38;
  _DWORD *v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  signed int v44;
  signed int v45;
  int v46;
  int v47;
  int v48;
  char *v49;
  int v50;
  _DWORD *v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int a_low;
  int v65;
  unint64_t v66;
  int v67;
  int v68;
  unsigned __int8 *v69;
  int v70;
  _DWORD *v71;
  uint64_t v72;
  _BOOL4 v73;
  uint64_t v74;
  uint64_t v75;
  _BOOL4 v76;
  uint64_t v77;
  char *v78;
  int v79;
  int v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  char *v86;
  uint64_t v87;
  int32x2_t v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  unint64_t v102;
  int v103;
  int v104;
  unsigned __int8 *v105;
  int v106;
  uint32x2_t v107;
  unsigned __int8 *v108;
  int32x2_t v109;
  uint32x2_t v110;
  char *v111;
  _DWORD *v112;
  char *v113;
  signed int v115;
  signed int v116;
  uint64_t v117;
  double v118;
  _QWORD *v119;
  double v120;
  int v121;
  double v122;
  int v123;
  double v124;
  _DWORD *v125;
  _DWORD *v126;
  double v127;
  char *v128;
  char *v129;
  char *v130;
  double v131;
  int v132;
  uint64_t v133;
  char *v134;
  uint64_t v135;
  int v136;
  int v137;
  int v138;
  _DWORD *v139;
  CGAffineTransform v140;
  CGAffineTransform v141;
  int v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  _DWORD *v149;
  char *v150;

  v20 = *a2;
  v21 = *a3;
  v23 = *a4;
  v22 = a4[1];
  v149 = 0;
  v150 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
    return FigSignalErrorAt();
  v147 = 0;
  v148 = 0;
  v146 = 0;
  v145 = 0;
  v31 = *((_OWORD *)a1 + 1);
  *(_OWORD *)&v141.a = *(_OWORD *)a1;
  *(_OWORD *)&v141.c = v31;
  *(_OWORD *)&v141.tx = *((_OWORD *)a1 + 2);
  if (BVCUtilityIsAffineTransformInvertible(&v141.a))
  {
    memset(&v140, 0, sizeof(v140));
    v32 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v141.a = *(_OWORD *)a1;
    *(_OWORD *)&v141.c = v32;
    *(_OWORD *)&v141.tx = *((_OWORD *)a1 + 2);
    CGAffineTransformInvert(&v140, &v141);
    v127 = *a1;
    v131 = a1[1];
    v124 = a1[3];
    v118 = a1[4];
    v120 = a1[2];
    v122 = a1[5];
    v33 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v141.a = *(_OWORD *)a1;
    *(_OWORD *)&v141.c = v33;
    *(_OWORD *)&v141.tx = *((_OWORD *)a1 + 2);
    VectorsFromTransform = BVCUtilityGetVectorsFromTransform(&v141.a, &v148, &v147);
    if ((_DWORD)VectorsFromTransform)
    {
      v38 = VectorsFromTransform;
    }
    else
    {
      v35 = v148;
      if ((int)v148 < 0)
        v35 = -(int)v148;
      v36 = v147;
      if ((int)v147 < 0)
        v36 = -(int)v147;
      if (v35 <= v36)
        v35 = v36;
      v123 = v35;
      v141 = v140;
      BVCUtilityGetVectorsFromTransform(&v141.a, &v146, &v145);
      v37 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v141.a = *(_OWORD *)a1;
      *(_OWORD *)&v141.c = v37;
      *(_OWORD *)&v141.tx = *((_OWORD *)a1 + 2);
      v38 = BVCUtilityCreateEdgeLists((float64x2_t *)&v141, &v150, &v149, a6, a7, a8, a9, a10, a11, a12, a13);
      if (!(_DWORD)v38)
      {
        if (v150)
        {
          v39 = v149;
          if (v149)
          {
            v117 = v22;
            v40 = vcvts_n_s32_f32(a14, 8uLL);
            v41 = vcvtd_n_s64_f64(v118 + v120 * 0.0 + v127 * 0.0, 0x10uLL);
            v42 = vcvtd_n_s64_f64(v122 + v124 * 0.0 + v131 * 0.0, 0x10uLL);
            LODWORD(v141.a) = 0;
            v143 = 0;
            v144 = 0;
            v142 = 0;
            v43 = *(_DWORD *)v150;
            if (*(_DWORD *)v150 <= *v149)
              v43 = *v149;
            v115 = v41;
            v116 = v42;
            v44 = 0x8000 - v41;
            v132 = v43 + 0x8000;
            v135 = v23;
            v45 = ((v43 + 0x8000) & 0xFFFF0000) - v42 + 0x8000;
            v46 = ((unint64_t)((int)v146 * (uint64_t)v44) >> 16)
                - ((int)v145 > 0)
                + ((unint64_t)((int)v145 * (uint64_t)v45) >> 16);
            v47 = (v43 + 0x8000) >> 16;
            v48 = ((unint64_t)(SHIDWORD(v146) * (uint64_t)v44) >> 16)
                - (SHIDWORD(v145) > 0)
                + ((unint64_t)(SHIDWORD(v145) * (uint64_t)v45) >> 16);
            v49 = v150;
            bvc_extractEdgeParameters(v150, 0, v47, v123, 1, &v141, &v144, (int *)&v143);
            bvc_extractEdgeParameters(v39, 1, v47, v123, 1, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
            v50 = v47;
            v51 = v39;
            v52 = v49;
            v119 = a5;
            v53 = *a5 + v135 * ((uint64_t)v132 >> 16);
            v54 = (0x10101020000 * (v40 << 8)) >> 48;
            v133 = v135;
            do
            {
              v55 = v142;
              v56 = v143;
              if ((int)v143 < v142)
                v55 = v143;
              v57 = v55 - v50;
              if (v55 > v50)
              {
                v128 = v52;
                v58 = 0;
                v59 = HIDWORD(v143);
                v136 = v144;
                v60 = v146;
                v61 = HIDWORD(v146);
                v62 = v145;
                v63 = HIDWORD(v145);
                a_low = LODWORD(v141.a);
                v121 = HIDWORD(v144);
                v65 = HIDWORD(v144);
                do
                {
                  LODWORD(v66) = a_low >> 16;
                  if (a_low >> 16 < (v65 >> 16))
                  {
                    v66 = (int)v66;
                    v67 = v48 + ((unint64_t)(v61 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                    v68 = v46 + ((unint64_t)(v60 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                    do
                    {
                      v69 = (unsigned __int8 *)(v21
                                              + (((uint64_t)v68 >> 14) & 0xFFFFFFFFFFFFFFFCLL)
                                              + ((v67 >> 16) * v20));
                      v70 = *v69;
                      if ((_DWORD)v54 * v70)
                        *(_BYTE *)(v53 + v66) = (unsigned __int16)(((2120 * v70
                                                                   + 3219 * v69[3]
                                                                   + 16508 * v69[2]
                                                                   + 8412 * v69[1]) >> 15)
                                                                 * v40
                                                                 + (((0x10000 - (_DWORD)v54 * v70)
                                                                   * *(unsigned __int8 *)(v53 + v66)) >> 8)) >> 8;
                      v68 += v60;
                      v67 += v61;
                      ++v66;
                    }
                    while (v66 < (uint64_t)v65 >> 16);
                  }
                  a_low += v136;
                  v65 += v59;
                  v46 += v62;
                  v48 += v63;
                  v53 += v133;
                  ++v58;
                }
                while (v58 != v57);
                LODWORD(v141.a) = a_low;
                HIDWORD(v144) = v121 + v59 * v57;
                v56 = v143;
                v50 = v55;
                v52 = v128;
              }
              if (v50 >= v56)
              {
                v52 = *(char **)(v52 + 20);
                if (v52)
                {
                  v137 = v50;
                  v125 = v51;
                  v129 = v52;
                  bvc_extractEdgeParameters(v52, 0, v50, v123, 1, &v141, &v144, (int *)&v143);
                  v50 = v137;
                  v51 = v125;
                  v52 = v129;
                }
              }
              if (v50 >= v142)
              {
                v71 = *(_DWORD **)(v51 + 5);
                if (!v71)
                  break;
                v138 = v50;
                v126 = v71;
                v130 = v52;
                bvc_extractEdgeParameters(v71, 1, v50, v123, 1, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
                v50 = v138;
                v51 = v126;
                v52 = v130;
              }
            }
            while (v52 && v51);
            v72 = 2 * (int)v146;
            v73 = (int)v145 > 0;
            v74 = 2 * (int)v145;
            v75 = 2 * SHIDWORD(v146);
            LODWORD(v146) = 2 * v146;
            HIDWORD(v146) *= 2;
            v76 = SHIDWORD(v145) > 0;
            v77 = 2 * SHIDWORD(v145);
            LODWORD(v145) = 2 * v145;
            HIDWORD(v145) *= 2;
            v78 = v150;
            v139 = v149;
            v79 = *(_DWORD *)v150 / 2;
            if (v79 <= *v149 / 2)
              v79 = *v149 / 2;
            v80 = v79 + 0x8000;
            v81 = (v79 + 0x8000) >> 16;
            v82 = (int)(((v79 + 0x8000) & 0xFFFF0000) - v116 / 2 + 0x8000);
            v83 = 0x8000 - v115 / 2;
            v84 = ((unint64_t)(v72 * v83) >> 16) - v73 + ((unint64_t)(v82 * v74) >> 16);
            v85 = ((unint64_t)(v75 * v83) >> 16) - v76 + ((unint64_t)(v82 * v77) >> 16);
            bvc_extractEdgeParameters(v150, 0, v81, v123, 2, &v141, &v144, (int *)&v143);
            bvc_extractEdgeParameters(v139, 1, v80 >> 16, v123, 2, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
            v86 = v78;
            v87 = v119[1] + v117 * ((uint64_t)v80 >> 16);
            v88 = vdup_n_s32(v40);
            do
            {
              v89 = v143;
              if ((int)v143 >= v142)
                v90 = v142;
              else
                v90 = v143;
              v91 = v90 - v81;
              if (v90 > v81)
              {
                v134 = v86;
                v92 = 0;
                v93 = HIDWORD(v143);
                v94 = v144;
                v95 = v146;
                v96 = HIDWORD(v146);
                v97 = v145;
                v98 = HIDWORD(v145);
                v99 = LODWORD(v141.a);
                v100 = HIDWORD(v144);
                v101 = HIDWORD(v144);
                do
                {
                  LODWORD(v102) = v99 >> 16;
                  if (v99 >> 16 < (v101 >> 16))
                  {
                    v102 = (int)v102;
                    v103 = v85 + ((unint64_t)(v96 * (uint64_t)(int)(v99 & 0xFFFF0000)) >> 16);
                    v104 = v84 + ((unint64_t)(v95 * (uint64_t)(int)(v99 & 0xFFFF0000)) >> 16);
                    do
                    {
                      v105 = (unsigned __int8 *)(v21
                                               + (((uint64_t)v104 >> 14) & 0xFFFFFFFFFFFFFFFCLL)
                                               + ((v103 >> 16) * v20));
                      v106 = *v105;
                      if ((_DWORD)v54 * v106)
                      {
                        v107 = (uint32x2_t)vmul_s32((int32x2_t)vshr_n_u32((uint32x2_t)vmla_s32(vmla_s32(vmla_s32(vdup_n_s32(16512 * v106), vdup_n_s32(v105[3]), (int32x2_t)0xFFFFF6D400003838), vdup_n_s32(v105[2]), (int32x2_t)0xFFFFD0F8FFFFDAC4), vdup_n_s32(v105[1]), (int32x2_t)0x3838FFFFED06), 0xFuLL), v88);
                        v108 = (unsigned __int8 *)(v87 + 2 * v102);
                        v109.i32[0] = *v108;
                        v109.i32[1] = v108[1];
                        v110 = vshr_n_u32(vsra_n_u32(v107, (uint32x2_t)vmul_s32(vdup_n_s32(0x10000 - (int)v54 * v106), v109), 8uLL), 8uLL);
                        *v108 = v110.i8[0];
                        v108[1] = v110.u8[4];
                      }
                      v104 += v95;
                      v103 += v96;
                      ++v102;
                    }
                    while (v102 < (uint64_t)v101 >> 16);
                  }
                  v99 += v94;
                  v101 += v93;
                  v84 += v97;
                  v85 += v98;
                  v87 += v117;
                  ++v92;
                }
                while (v92 != v91);
                LODWORD(v141.a) = v99;
                HIDWORD(v144) = v100 + v93 * v91;
                v89 = v143;
                v81 = v90;
                v86 = v134;
              }
              if (v81 >= v89)
              {
                v86 = *(char **)(v86 + 20);
                if (v86)
                {
                  v111 = v86;
                  bvc_extractEdgeParameters(v86, 0, v81, v123, 2, &v141, &v144, (int *)&v143);
                  v86 = v111;
                }
              }
              if (v81 >= v142)
              {
                v112 = *(_DWORD **)(v139 + 5);
                if (!v112)
                  goto LABEL_63;
                v139 = *(_DWORD **)(v139 + 5);
                v113 = v86;
                bvc_extractEdgeParameters(v112, 1, v81, v123, 2, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
                v86 = v113;
              }
              v38 = 0;
            }
            while (v86 && v139);
          }
        }
      }
    }
  }
  else
  {
LABEL_63:
    v38 = 0;
  }
  BVCUtilityDestroyEdgeList((uint64_t)v150);
  BVCUtilityDestroyEdgeList((uint64_t)v149);
  return v38;
}

uint64_t bvc_FullCompositionOpaque_BGRA_420v709(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, _QWORD *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t VectorsFromTransform;
  unsigned int v31;
  unsigned int v32;
  __int128 v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  signed int v38;
  _DWORD *v39;
  signed int v40;
  int v41;
  uint64_t v42;
  int v43;
  int v44;
  char *v45;
  int v46;
  _DWORD *v47;
  char *v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int a_low;
  int v61;
  unint64_t v62;
  int v63;
  int v64;
  unsigned __int8 *v65;
  int v66;
  unsigned int v67;
  _DWORD *v68;
  uint64_t v69;
  _BOOL4 v70;
  uint64_t v71;
  uint64_t v72;
  _BOOL4 v73;
  uint64_t v74;
  _DWORD *v75;
  char *v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  int v83;
  char *v84;
  uint64_t v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  unsigned __int8 *v101;
  int v102;
  int v103;
  int v104;
  int v105;
  unsigned int v106;
  unsigned int v107;
  _BYTE *v108;
  _BYTE *v109;
  int v110;
  _DWORD *v111;
  uint64_t v113;
  signed int v114;
  signed int v115;
  uint64_t v116;
  int v117;
  double v118;
  int v119;
  int v120;
  double v121;
  int v122;
  _DWORD *v123;
  double v124;
  int v125;
  int v126;
  char *v127;
  char *v128;
  char *v129;
  double v130;
  _DWORD *v131;
  _DWORD *v132;
  _DWORD *v133;
  uint64_t v134;
  double v135;
  char *v136;
  char *v137;
  char *v138;
  int v139;
  double v140;
  int v141;
  int v142;
  int v143;
  int v144;
  CGAffineTransform v145;
  CGAffineTransform v146;
  int v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  _DWORD *v154;
  char *v155;

  v15 = *a2;
  v16 = *a3;
  v18 = *a4;
  v17 = a4[1];
  v154 = 0;
  v155 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
    return FigSignalErrorAt();
  v152 = 0;
  v153 = 0;
  v151 = 0;
  v150 = 0;
  v27 = *((_OWORD *)a1 + 1);
  *(_OWORD *)&v146.a = *(_OWORD *)a1;
  *(_OWORD *)&v146.c = v27;
  *(_OWORD *)&v146.tx = *((_OWORD *)a1 + 2);
  if (BVCUtilityIsAffineTransformInvertible(&v146.a))
  {
    memset(&v145, 0, sizeof(v145));
    v28 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v146.a = *(_OWORD *)a1;
    *(_OWORD *)&v146.c = v28;
    *(_OWORD *)&v146.tx = *((_OWORD *)a1 + 2);
    CGAffineTransformInvert(&v145, &v146);
    v135 = *a1;
    v140 = a1[1];
    v130 = a1[3];
    v118 = a1[4];
    v121 = a1[2];
    v124 = a1[5];
    v29 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v146.a = *(_OWORD *)a1;
    *(_OWORD *)&v146.c = v29;
    *(_OWORD *)&v146.tx = *((_OWORD *)a1 + 2);
    VectorsFromTransform = BVCUtilityGetVectorsFromTransform(&v146.a, &v153, &v152);
    if ((_DWORD)VectorsFromTransform)
    {
      v34 = VectorsFromTransform;
    }
    else
    {
      v31 = v153;
      if ((int)v153 < 0)
        v31 = -(int)v153;
      v32 = v152;
      if ((int)v152 < 0)
        v32 = -(int)v152;
      if (v31 <= v32)
        v31 = v32;
      v120 = v31;
      v146 = v145;
      BVCUtilityGetVectorsFromTransform(&v146.a, &v151, &v150);
      v33 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v146.a = *(_OWORD *)a1;
      *(_OWORD *)&v146.c = v33;
      *(_OWORD *)&v146.tx = *((_OWORD *)a1 + 2);
      v34 = BVCUtilityCreateEdgeLists((float64x2_t *)&v146, &v155, &v154, a6, a7, a8, a9, a10, a11, a12, a13);
      if (!(_DWORD)v34 && v155 && v154)
      {
        v116 = v17;
        v35 = vcvtd_n_s64_f64(v118 + v121 * 0.0 + v135 * 0.0, 0x10uLL);
        v36 = vcvtd_n_s64_f64(v124 + v130 * 0.0 + v140 * 0.0, 0x10uLL);
        LODWORD(v146.a) = 0;
        v148 = 0;
        v149 = 0;
        v147 = 0;
        v37 = *(_DWORD *)v155;
        if (*(_DWORD *)v155 <= *v154)
          v37 = *v154;
        v114 = v35;
        v115 = v36;
        v38 = 0x8000 - v35;
        v39 = v154;
        v141 = v37 + 0x8000;
        v40 = ((v37 + 0x8000) & 0xFFFF0000) - v36 + 0x8000;
        v41 = ((unint64_t)((int)v151 * (uint64_t)v38) >> 16)
            - ((int)v150 > 0)
            + ((unint64_t)((int)v150 * (uint64_t)v40) >> 16);
        v42 = v18;
        v43 = (v37 + 0x8000) >> 16;
        v44 = ((unint64_t)(SHIDWORD(v151) * (uint64_t)v38) >> 16)
            - (SHIDWORD(v150) > 0)
            + ((unint64_t)(SHIDWORD(v150) * (uint64_t)v40) >> 16);
        v45 = v155;
        bvc_extractEdgeParameters(v155, 0, v43, v120, 1, &v146, &v149, (int *)&v148);
        bvc_extractEdgeParameters(v39, 1, v43, v120, 1, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
        v46 = v43;
        v47 = v39;
        v48 = v45;
        v49 = *a5 + v42 * ((uint64_t)v141 >> 16);
        do
        {
          v50 = v147;
          v51 = v148;
          if ((int)v148 < v147)
            v50 = v148;
          v52 = v50 - v46;
          if (v50 > v46)
          {
            v131 = v47;
            v136 = v48;
            v53 = 0;
            v54 = HIDWORD(v148);
            v55 = v149;
            v56 = v151;
            v57 = HIDWORD(v151);
            v58 = v150;
            v59 = HIDWORD(v150);
            a_low = LODWORD(v146.a);
            v122 = HIDWORD(v149);
            v61 = HIDWORD(v149);
            do
            {
              LODWORD(v62) = a_low >> 16;
              if (a_low >> 16 < (v61 >> 16))
              {
                v62 = (int)v62;
                v63 = v44 + ((unint64_t)(v57 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                v64 = v41 + ((unint64_t)(v56 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                do
                {
                  v65 = (unsigned __int8 *)(v16 + ((v63 >> 16) * v15) + (int)((v64 >> 14) & 0xFFFFFFFC));
                  v66 = v65[3];
                  if (v65[3])
                  {
                    v67 = (2120 * v66 + 2032 * *v65 + 20127 * v65[1] + 5983 * v65[2]) >> 15;
                    if (v66 != 255)
                      v67 += ((16776959 * v66 + 0x10000) * *(unsigned __int8 *)(v49 + v62)) >> 16;
                    *(_BYTE *)(v49 + v62) = v67;
                  }
                  v64 += v56;
                  v63 += v57;
                  ++v62;
                }
                while (v62 < (uint64_t)v61 >> 16);
              }
              a_low += v55;
              v61 += v54;
              v41 += v58;
              v44 += v59;
              v49 += v42;
              ++v53;
            }
            while (v53 != v52);
            LODWORD(v146.a) = a_low;
            HIDWORD(v149) = v122 + v54 * v52;
            v51 = v148;
            v46 = v50;
            v47 = v131;
            v48 = v136;
          }
          if (v46 >= v51)
          {
            v48 = *(char **)(v48 + 20);
            if (v48)
            {
              v125 = v46;
              v132 = v47;
              v137 = v48;
              bvc_extractEdgeParameters(v48, 0, v46, v120, 1, &v146, &v149, (int *)&v148);
              v46 = v125;
              v47 = v132;
              v48 = v137;
            }
          }
          if (v46 >= v147)
          {
            v68 = *(_DWORD **)(v47 + 5);
            if (!v68)
              break;
            v126 = v46;
            v133 = v68;
            v138 = v48;
            bvc_extractEdgeParameters(v68, 1, v46, v120, 1, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
            v46 = v126;
            v47 = v133;
            v48 = v138;
          }
        }
        while (v48);
        v69 = 2 * (int)v151;
        v70 = (int)v150 > 0;
        v71 = 2 * (int)v150;
        v72 = 2 * SHIDWORD(v151);
        LODWORD(v151) = 2 * v151;
        HIDWORD(v151) *= 2;
        v73 = SHIDWORD(v150) > 0;
        v74 = 2 * SHIDWORD(v150);
        LODWORD(v150) = 2 * v150;
        HIDWORD(v150) *= 2;
        v75 = v154;
        v76 = v155;
        v77 = *(_DWORD *)v155 / 2;
        if (v77 <= *v154 / 2)
          v77 = *v154 / 2;
        v78 = v77 + 0x8000;
        v79 = (int)(((v77 + 0x8000) & 0xFFFF0000) - v115 / 2 + 0x8000);
        v80 = 0x8000 - v114 / 2;
        v81 = ((unint64_t)(v69 * v80) >> 16) - v70 + ((unint64_t)(v79 * v71) >> 16);
        v82 = ((unint64_t)(v72 * v80) >> 16) - v73 + ((unint64_t)(v79 * v74) >> 16);
        bvc_extractEdgeParameters(v155, 0, (v77 + 0x8000) >> 16, v120, 2, &v146, &v149, (int *)&v148);
        v123 = v75;
        bvc_extractEdgeParameters(v75, 1, v78 >> 16, v120, 2, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
        v83 = v78 >> 16;
        v84 = v76;
        v85 = a5[1] + v116 * ((uint64_t)v78 >> 16);
        v134 = v116;
        do
        {
          v86 = v147;
          v87 = v148;
          if ((int)v148 < v147)
            v86 = v148;
          v88 = v86 - v83;
          if (v86 > v83)
          {
            v119 = v86;
            v127 = v84;
            v89 = 0;
            v90 = HIDWORD(v148);
            v142 = v149;
            v91 = v151;
            v92 = HIDWORD(v151);
            v93 = HIDWORD(v150);
            v139 = v150;
            v94 = LODWORD(v146.a);
            v117 = HIDWORD(v149);
            v95 = HIDWORD(v149);
            do
            {
              v96 = v94 >> 16;
              if (v94 >> 16 < (v95 >> 16))
              {
                v97 = v96;
                v98 = 2 * v96;
                v99 = v82 + ((unint64_t)(v92 * (uint64_t)(int)(v94 & 0xFFFF0000)) >> 16);
                v100 = v81 + ((unint64_t)(v91 * (uint64_t)(int)(v94 & 0xFFFF0000)) >> 16);
                do
                {
                  v101 = (unsigned __int8 *)(v16 + ((v99 >> 16) * v15) + (int)((v100 >> 14) & 0xFFFFFFFC));
                  v102 = v101[3];
                  if (v101[3])
                  {
                    v103 = *v101;
                    v104 = v101[1];
                    v105 = v101[2];
                    v106 = (14392 * v103 + 16512 * v102 - 11093 * v104 - 3298 * v105) >> 15;
                    v107 = (-1317 * v103 + 16512 * v102 - 13073 * v104 + 14392 * v105) >> 15;
                    if (v102 == 255)
                    {
                      v108 = (_BYTE *)(v85 + v98);
                      *v108 = v106;
                      v108[1] = v107;
                    }
                    else
                    {
                      v109 = (_BYTE *)(v85 + v98);
                      v110 = 0x10000 - (v102 | (v102 << 8));
                      *v109 = v106 + ((v110 * *(unsigned __int8 *)(v85 + v98)) >> 16);
                      v109[1] = v107 + ((v110 * *(unsigned __int8 *)(v85 + v98 + 1)) >> 16);
                    }
                  }
                  v100 += v91;
                  v99 += v92;
                  ++v97;
                  v98 += 2;
                }
                while (v97 < (uint64_t)v95 >> 16);
              }
              v94 += v142;
              v95 += v90;
              v81 += v139;
              v82 += v93;
              v85 += v134;
              ++v89;
            }
            while (v89 != v88);
            LODWORD(v146.a) = v94;
            HIDWORD(v149) = v117 + v90 * v88;
            v87 = v148;
            v83 = v119;
            v84 = v127;
          }
          if (v83 >= v87)
          {
            v84 = *(char **)(v84 + 20);
            if (v84)
            {
              v143 = v83;
              v128 = v84;
              bvc_extractEdgeParameters(v84, 0, v83, v120, 2, &v146, &v149, (int *)&v148);
              v83 = v143;
              v84 = v128;
            }
          }
          if (v83 >= v147)
          {
            v111 = *(_DWORD **)(v123 + 5);
            if (!v111)
              goto LABEL_65;
            v123 = *(_DWORD **)(v123 + 5);
            v129 = v84;
            v144 = v83;
            bvc_extractEdgeParameters(v111, 1, v83, v120, 2, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
            v83 = v144;
            v84 = v129;
          }
          v34 = 0;
        }
        while (v84 && v123);
      }
    }
  }
  else
  {
LABEL_65:
    v34 = 0;
  }
  v113 = v34;
  BVCUtilityDestroyEdgeList((uint64_t)v155);
  BVCUtilityDestroyEdgeList((uint64_t)v154);
  return v113;
}

uint64_t bvc_FullComposition_BGRA_420v709(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, _QWORD *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, float a14)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t VectorsFromTransform;
  unsigned int v35;
  unsigned int v36;
  __int128 v37;
  uint64_t v38;
  _DWORD *v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  signed int v44;
  signed int v45;
  int v46;
  int v47;
  int v48;
  char *v49;
  int v50;
  _DWORD *v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int a_low;
  int v65;
  unint64_t v66;
  int v67;
  int v68;
  unsigned __int8 *v69;
  int v70;
  _DWORD *v71;
  uint64_t v72;
  _BOOL4 v73;
  uint64_t v74;
  uint64_t v75;
  _BOOL4 v76;
  uint64_t v77;
  char *v78;
  int v79;
  int v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  char *v86;
  uint64_t v87;
  int32x2_t v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  unint64_t v102;
  int v103;
  int v104;
  unsigned __int8 *v105;
  int v106;
  uint32x2_t v107;
  unsigned __int8 *v108;
  int32x2_t v109;
  uint32x2_t v110;
  char *v111;
  _DWORD *v112;
  char *v113;
  signed int v115;
  signed int v116;
  uint64_t v117;
  double v118;
  _QWORD *v119;
  double v120;
  int v121;
  double v122;
  int v123;
  double v124;
  _DWORD *v125;
  _DWORD *v126;
  double v127;
  char *v128;
  char *v129;
  char *v130;
  double v131;
  int v132;
  uint64_t v133;
  char *v134;
  uint64_t v135;
  int v136;
  int v137;
  int v138;
  _DWORD *v139;
  CGAffineTransform v140;
  CGAffineTransform v141;
  int v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  _DWORD *v149;
  char *v150;

  v20 = *a2;
  v21 = *a3;
  v23 = *a4;
  v22 = a4[1];
  v149 = 0;
  v150 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
    return FigSignalErrorAt();
  v147 = 0;
  v148 = 0;
  v146 = 0;
  v145 = 0;
  v31 = *((_OWORD *)a1 + 1);
  *(_OWORD *)&v141.a = *(_OWORD *)a1;
  *(_OWORD *)&v141.c = v31;
  *(_OWORD *)&v141.tx = *((_OWORD *)a1 + 2);
  if (BVCUtilityIsAffineTransformInvertible(&v141.a))
  {
    memset(&v140, 0, sizeof(v140));
    v32 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v141.a = *(_OWORD *)a1;
    *(_OWORD *)&v141.c = v32;
    *(_OWORD *)&v141.tx = *((_OWORD *)a1 + 2);
    CGAffineTransformInvert(&v140, &v141);
    v127 = *a1;
    v131 = a1[1];
    v124 = a1[3];
    v118 = a1[4];
    v120 = a1[2];
    v122 = a1[5];
    v33 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v141.a = *(_OWORD *)a1;
    *(_OWORD *)&v141.c = v33;
    *(_OWORD *)&v141.tx = *((_OWORD *)a1 + 2);
    VectorsFromTransform = BVCUtilityGetVectorsFromTransform(&v141.a, &v148, &v147);
    if ((_DWORD)VectorsFromTransform)
    {
      v38 = VectorsFromTransform;
    }
    else
    {
      v35 = v148;
      if ((int)v148 < 0)
        v35 = -(int)v148;
      v36 = v147;
      if ((int)v147 < 0)
        v36 = -(int)v147;
      if (v35 <= v36)
        v35 = v36;
      v123 = v35;
      v141 = v140;
      BVCUtilityGetVectorsFromTransform(&v141.a, &v146, &v145);
      v37 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v141.a = *(_OWORD *)a1;
      *(_OWORD *)&v141.c = v37;
      *(_OWORD *)&v141.tx = *((_OWORD *)a1 + 2);
      v38 = BVCUtilityCreateEdgeLists((float64x2_t *)&v141, &v150, &v149, a6, a7, a8, a9, a10, a11, a12, a13);
      if (!(_DWORD)v38)
      {
        if (v150)
        {
          v39 = v149;
          if (v149)
          {
            v117 = v22;
            v40 = vcvts_n_s32_f32(a14, 8uLL);
            v41 = vcvtd_n_s64_f64(v118 + v120 * 0.0 + v127 * 0.0, 0x10uLL);
            v42 = vcvtd_n_s64_f64(v122 + v124 * 0.0 + v131 * 0.0, 0x10uLL);
            LODWORD(v141.a) = 0;
            v143 = 0;
            v144 = 0;
            v142 = 0;
            v43 = *(_DWORD *)v150;
            if (*(_DWORD *)v150 <= *v149)
              v43 = *v149;
            v115 = v41;
            v116 = v42;
            v44 = 0x8000 - v41;
            v132 = v43 + 0x8000;
            v135 = v23;
            v45 = ((v43 + 0x8000) & 0xFFFF0000) - v42 + 0x8000;
            v46 = ((unint64_t)((int)v146 * (uint64_t)v44) >> 16)
                - ((int)v145 > 0)
                + ((unint64_t)((int)v145 * (uint64_t)v45) >> 16);
            v47 = (v43 + 0x8000) >> 16;
            v48 = ((unint64_t)(SHIDWORD(v146) * (uint64_t)v44) >> 16)
                - (SHIDWORD(v145) > 0)
                + ((unint64_t)(SHIDWORD(v145) * (uint64_t)v45) >> 16);
            v49 = v150;
            bvc_extractEdgeParameters(v150, 0, v47, v123, 1, &v141, &v144, (int *)&v143);
            bvc_extractEdgeParameters(v39, 1, v47, v123, 1, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
            v50 = v47;
            v51 = v39;
            v52 = v49;
            v119 = a5;
            v53 = *a5 + v135 * ((uint64_t)v132 >> 16);
            v54 = (0x10101020000 * (v40 << 8)) >> 48;
            v133 = v135;
            do
            {
              v55 = v142;
              v56 = v143;
              if ((int)v143 < v142)
                v55 = v143;
              v57 = v55 - v50;
              if (v55 > v50)
              {
                v128 = v52;
                v58 = 0;
                v59 = HIDWORD(v143);
                v136 = v144;
                v60 = v146;
                v61 = HIDWORD(v146);
                v62 = v145;
                v63 = HIDWORD(v145);
                a_low = LODWORD(v141.a);
                v121 = HIDWORD(v144);
                v65 = HIDWORD(v144);
                do
                {
                  LODWORD(v66) = a_low >> 16;
                  if (a_low >> 16 < (v65 >> 16))
                  {
                    v66 = (int)v66;
                    v67 = v48 + ((unint64_t)(v61 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                    v68 = v46 + ((unint64_t)(v60 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                    do
                    {
                      v69 = (unsigned __int8 *)(v21 + ((v67 >> 16) * v20) + (int)((v68 >> 14) & 0xFFFFFFFC));
                      v70 = v69[3];
                      if ((_DWORD)v54 * v70)
                        *(_BYTE *)(v53 + v66) = (unsigned __int16)(((2120 * v70
                                                                   + 2032 * *v69
                                                                   + 20127 * v69[1]
                                                                   + 5983 * v69[2]) >> 15)
                                                                 * v40
                                                                 + (((0x10000 - (_DWORD)v54 * v70)
                                                                   * *(unsigned __int8 *)(v53 + v66)) >> 8)) >> 8;
                      v68 += v60;
                      v67 += v61;
                      ++v66;
                    }
                    while (v66 < (uint64_t)v65 >> 16);
                  }
                  a_low += v136;
                  v65 += v59;
                  v46 += v62;
                  v48 += v63;
                  v53 += v133;
                  ++v58;
                }
                while (v58 != v57);
                LODWORD(v141.a) = a_low;
                HIDWORD(v144) = v121 + v59 * v57;
                v56 = v143;
                v50 = v55;
                v52 = v128;
              }
              if (v50 >= v56)
              {
                v52 = *(char **)(v52 + 20);
                if (v52)
                {
                  v137 = v50;
                  v125 = v51;
                  v129 = v52;
                  bvc_extractEdgeParameters(v52, 0, v50, v123, 1, &v141, &v144, (int *)&v143);
                  v50 = v137;
                  v51 = v125;
                  v52 = v129;
                }
              }
              if (v50 >= v142)
              {
                v71 = *(_DWORD **)(v51 + 5);
                if (!v71)
                  break;
                v138 = v50;
                v126 = v71;
                v130 = v52;
                bvc_extractEdgeParameters(v71, 1, v50, v123, 1, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
                v50 = v138;
                v51 = v126;
                v52 = v130;
              }
            }
            while (v52 && v51);
            v72 = 2 * (int)v146;
            v73 = (int)v145 > 0;
            v74 = 2 * (int)v145;
            v75 = 2 * SHIDWORD(v146);
            LODWORD(v146) = 2 * v146;
            HIDWORD(v146) *= 2;
            v76 = SHIDWORD(v145) > 0;
            v77 = 2 * SHIDWORD(v145);
            LODWORD(v145) = 2 * v145;
            HIDWORD(v145) *= 2;
            v78 = v150;
            v139 = v149;
            v79 = *(_DWORD *)v150 / 2;
            if (v79 <= *v149 / 2)
              v79 = *v149 / 2;
            v80 = v79 + 0x8000;
            v81 = (v79 + 0x8000) >> 16;
            v82 = (int)(((v79 + 0x8000) & 0xFFFF0000) - v116 / 2 + 0x8000);
            v83 = 0x8000 - v115 / 2;
            v84 = ((unint64_t)(v72 * v83) >> 16) - v73 + ((unint64_t)(v82 * v74) >> 16);
            v85 = ((unint64_t)(v75 * v83) >> 16) - v76 + ((unint64_t)(v82 * v77) >> 16);
            bvc_extractEdgeParameters(v150, 0, v81, v123, 2, &v141, &v144, (int *)&v143);
            bvc_extractEdgeParameters(v139, 1, v80 >> 16, v123, 2, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
            v86 = v78;
            v87 = v119[1] + v117 * ((uint64_t)v80 >> 16);
            v88 = vdup_n_s32(v40);
            do
            {
              v89 = v143;
              if ((int)v143 >= v142)
                v90 = v142;
              else
                v90 = v143;
              v91 = v90 - v81;
              if (v90 > v81)
              {
                v134 = v86;
                v92 = 0;
                v93 = HIDWORD(v143);
                v94 = v144;
                v95 = v146;
                v96 = HIDWORD(v146);
                v97 = v145;
                v98 = HIDWORD(v145);
                v99 = LODWORD(v141.a);
                v100 = HIDWORD(v144);
                v101 = HIDWORD(v144);
                do
                {
                  LODWORD(v102) = v99 >> 16;
                  if (v99 >> 16 < (v101 >> 16))
                  {
                    v102 = (int)v102;
                    v103 = v85 + ((unint64_t)(v96 * (uint64_t)(int)(v99 & 0xFFFF0000)) >> 16);
                    v104 = v84 + ((unint64_t)(v95 * (uint64_t)(int)(v99 & 0xFFFF0000)) >> 16);
                    do
                    {
                      v105 = (unsigned __int8 *)(v21
                                               + ((v103 >> 16) * v20)
                                               + (int)((v104 >> 14) & 0xFFFFFFFC));
                      v106 = v105[3];
                      if ((_DWORD)v54 * v106)
                      {
                        v107 = (uint32x2_t)vmul_s32((int32x2_t)vshr_n_u32((uint32x2_t)vmla_s32(vmla_s32(vmla_s32(vdup_n_s32(16512 * v106), vdup_n_s32(*v105), (int32x2_t)0xFFFFFADB00003838), vdup_n_s32(v105[1]), (int32x2_t)0xFFFFCCEFFFFFD4ABLL), vdup_n_s32(v105[2]), (int32x2_t)0x3838FFFFF31ELL), 0xFuLL), v88);
                        v108 = (unsigned __int8 *)(v87 + 2 * v102);
                        v109.i32[0] = *v108;
                        v109.i32[1] = v108[1];
                        v110 = vshr_n_u32(vsra_n_u32(v107, (uint32x2_t)vmul_s32(vdup_n_s32(0x10000 - (int)v54 * v106), v109), 8uLL), 8uLL);
                        *v108 = v110.i8[0];
                        v108[1] = v110.u8[4];
                      }
                      v104 += v95;
                      v103 += v96;
                      ++v102;
                    }
                    while (v102 < (uint64_t)v101 >> 16);
                  }
                  v99 += v94;
                  v101 += v93;
                  v84 += v97;
                  v85 += v98;
                  v87 += v117;
                  ++v92;
                }
                while (v92 != v91);
                LODWORD(v141.a) = v99;
                HIDWORD(v144) = v100 + v93 * v91;
                v89 = v143;
                v81 = v90;
                v86 = v134;
              }
              if (v81 >= v89)
              {
                v86 = *(char **)(v86 + 20);
                if (v86)
                {
                  v111 = v86;
                  bvc_extractEdgeParameters(v86, 0, v81, v123, 2, &v141, &v144, (int *)&v143);
                  v86 = v111;
                }
              }
              if (v81 >= v142)
              {
                v112 = *(_DWORD **)(v139 + 5);
                if (!v112)
                  goto LABEL_63;
                v139 = *(_DWORD **)(v139 + 5);
                v113 = v86;
                bvc_extractEdgeParameters(v112, 1, v81, v123, 2, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
                v86 = v113;
              }
              v38 = 0;
            }
            while (v86 && v139);
          }
        }
      }
    }
  }
  else
  {
LABEL_63:
    v38 = 0;
  }
  BVCUtilityDestroyEdgeList((uint64_t)v150);
  BVCUtilityDestroyEdgeList((uint64_t)v149);
  return v38;
}

uint64_t bvc_FullCompositionOpaque_BGRA_420v601(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, _QWORD *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t VectorsFromTransform;
  unsigned int v31;
  unsigned int v32;
  __int128 v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  signed int v38;
  _DWORD *v39;
  signed int v40;
  int v41;
  uint64_t v42;
  int v43;
  int v44;
  char *v45;
  int v46;
  _DWORD *v47;
  char *v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int a_low;
  int v61;
  unint64_t v62;
  int v63;
  int v64;
  unsigned __int8 *v65;
  int v66;
  unsigned int v67;
  _DWORD *v68;
  uint64_t v69;
  _BOOL4 v70;
  uint64_t v71;
  uint64_t v72;
  _BOOL4 v73;
  uint64_t v74;
  _DWORD *v75;
  char *v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  int v83;
  char *v84;
  uint64_t v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  unsigned __int8 *v101;
  int v102;
  int v103;
  int v104;
  int v105;
  unsigned int v106;
  unsigned int v107;
  _BYTE *v108;
  _BYTE *v109;
  int v110;
  _DWORD *v111;
  uint64_t v113;
  signed int v114;
  signed int v115;
  uint64_t v116;
  int v117;
  double v118;
  int v119;
  int v120;
  double v121;
  int v122;
  _DWORD *v123;
  double v124;
  int v125;
  int v126;
  char *v127;
  char *v128;
  char *v129;
  double v130;
  _DWORD *v131;
  _DWORD *v132;
  _DWORD *v133;
  uint64_t v134;
  double v135;
  char *v136;
  char *v137;
  char *v138;
  int v139;
  double v140;
  int v141;
  int v142;
  int v143;
  int v144;
  CGAffineTransform v145;
  CGAffineTransform v146;
  int v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  _DWORD *v154;
  char *v155;

  v15 = *a2;
  v16 = *a3;
  v18 = *a4;
  v17 = a4[1];
  v154 = 0;
  v155 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
    return FigSignalErrorAt();
  v152 = 0;
  v153 = 0;
  v151 = 0;
  v150 = 0;
  v27 = *((_OWORD *)a1 + 1);
  *(_OWORD *)&v146.a = *(_OWORD *)a1;
  *(_OWORD *)&v146.c = v27;
  *(_OWORD *)&v146.tx = *((_OWORD *)a1 + 2);
  if (BVCUtilityIsAffineTransformInvertible(&v146.a))
  {
    memset(&v145, 0, sizeof(v145));
    v28 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v146.a = *(_OWORD *)a1;
    *(_OWORD *)&v146.c = v28;
    *(_OWORD *)&v146.tx = *((_OWORD *)a1 + 2);
    CGAffineTransformInvert(&v145, &v146);
    v135 = *a1;
    v140 = a1[1];
    v130 = a1[3];
    v118 = a1[4];
    v121 = a1[2];
    v124 = a1[5];
    v29 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v146.a = *(_OWORD *)a1;
    *(_OWORD *)&v146.c = v29;
    *(_OWORD *)&v146.tx = *((_OWORD *)a1 + 2);
    VectorsFromTransform = BVCUtilityGetVectorsFromTransform(&v146.a, &v153, &v152);
    if ((_DWORD)VectorsFromTransform)
    {
      v34 = VectorsFromTransform;
    }
    else
    {
      v31 = v153;
      if ((int)v153 < 0)
        v31 = -(int)v153;
      v32 = v152;
      if ((int)v152 < 0)
        v32 = -(int)v152;
      if (v31 <= v32)
        v31 = v32;
      v120 = v31;
      v146 = v145;
      BVCUtilityGetVectorsFromTransform(&v146.a, &v151, &v150);
      v33 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v146.a = *(_OWORD *)a1;
      *(_OWORD *)&v146.c = v33;
      *(_OWORD *)&v146.tx = *((_OWORD *)a1 + 2);
      v34 = BVCUtilityCreateEdgeLists((float64x2_t *)&v146, &v155, &v154, a6, a7, a8, a9, a10, a11, a12, a13);
      if (!(_DWORD)v34 && v155 && v154)
      {
        v116 = v17;
        v35 = vcvtd_n_s64_f64(v118 + v121 * 0.0 + v135 * 0.0, 0x10uLL);
        v36 = vcvtd_n_s64_f64(v124 + v130 * 0.0 + v140 * 0.0, 0x10uLL);
        LODWORD(v146.a) = 0;
        v148 = 0;
        v149 = 0;
        v147 = 0;
        v37 = *(_DWORD *)v155;
        if (*(_DWORD *)v155 <= *v154)
          v37 = *v154;
        v114 = v35;
        v115 = v36;
        v38 = 0x8000 - v35;
        v39 = v154;
        v141 = v37 + 0x8000;
        v40 = ((v37 + 0x8000) & 0xFFFF0000) - v36 + 0x8000;
        v41 = ((unint64_t)((int)v151 * (uint64_t)v38) >> 16)
            - ((int)v150 > 0)
            + ((unint64_t)((int)v150 * (uint64_t)v40) >> 16);
        v42 = v18;
        v43 = (v37 + 0x8000) >> 16;
        v44 = ((unint64_t)(SHIDWORD(v151) * (uint64_t)v38) >> 16)
            - (SHIDWORD(v150) > 0)
            + ((unint64_t)(SHIDWORD(v150) * (uint64_t)v40) >> 16);
        v45 = v155;
        bvc_extractEdgeParameters(v155, 0, v43, v120, 1, &v146, &v149, (int *)&v148);
        bvc_extractEdgeParameters(v39, 1, v43, v120, 1, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
        v46 = v43;
        v47 = v39;
        v48 = v45;
        v49 = *a5 + v42 * ((uint64_t)v141 >> 16);
        do
        {
          v50 = v147;
          v51 = v148;
          if ((int)v148 < v147)
            v50 = v148;
          v52 = v50 - v46;
          if (v50 > v46)
          {
            v131 = v47;
            v136 = v48;
            v53 = 0;
            v54 = HIDWORD(v148);
            v55 = v149;
            v56 = v151;
            v57 = HIDWORD(v151);
            v58 = v150;
            v59 = HIDWORD(v150);
            a_low = LODWORD(v146.a);
            v122 = HIDWORD(v149);
            v61 = HIDWORD(v149);
            do
            {
              LODWORD(v62) = a_low >> 16;
              if (a_low >> 16 < (v61 >> 16))
              {
                v62 = (int)v62;
                v63 = v44 + ((unint64_t)(v57 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                v64 = v41 + ((unint64_t)(v56 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                do
                {
                  v65 = (unsigned __int8 *)(v16 + ((v63 >> 16) * v15) + (int)((v64 >> 14) & 0xFFFFFFFC));
                  v66 = v65[3];
                  if (v65[3])
                  {
                    v67 = (2120 * v66 + 3219 * *v65 + 16508 * v65[1] + 8412 * v65[2]) >> 15;
                    if (v66 != 255)
                      v67 += ((16776959 * v66 + 0x10000) * *(unsigned __int8 *)(v49 + v62)) >> 16;
                    *(_BYTE *)(v49 + v62) = v67;
                  }
                  v64 += v56;
                  v63 += v57;
                  ++v62;
                }
                while (v62 < (uint64_t)v61 >> 16);
              }
              a_low += v55;
              v61 += v54;
              v41 += v58;
              v44 += v59;
              v49 += v42;
              ++v53;
            }
            while (v53 != v52);
            LODWORD(v146.a) = a_low;
            HIDWORD(v149) = v122 + v54 * v52;
            v51 = v148;
            v46 = v50;
            v47 = v131;
            v48 = v136;
          }
          if (v46 >= v51)
          {
            v48 = *(char **)(v48 + 20);
            if (v48)
            {
              v125 = v46;
              v132 = v47;
              v137 = v48;
              bvc_extractEdgeParameters(v48, 0, v46, v120, 1, &v146, &v149, (int *)&v148);
              v46 = v125;
              v47 = v132;
              v48 = v137;
            }
          }
          if (v46 >= v147)
          {
            v68 = *(_DWORD **)(v47 + 5);
            if (!v68)
              break;
            v126 = v46;
            v133 = v68;
            v138 = v48;
            bvc_extractEdgeParameters(v68, 1, v46, v120, 1, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
            v46 = v126;
            v47 = v133;
            v48 = v138;
          }
        }
        while (v48);
        v69 = 2 * (int)v151;
        v70 = (int)v150 > 0;
        v71 = 2 * (int)v150;
        v72 = 2 * SHIDWORD(v151);
        LODWORD(v151) = 2 * v151;
        HIDWORD(v151) *= 2;
        v73 = SHIDWORD(v150) > 0;
        v74 = 2 * SHIDWORD(v150);
        LODWORD(v150) = 2 * v150;
        HIDWORD(v150) *= 2;
        v75 = v154;
        v76 = v155;
        v77 = *(_DWORD *)v155 / 2;
        if (v77 <= *v154 / 2)
          v77 = *v154 / 2;
        v78 = v77 + 0x8000;
        v79 = (int)(((v77 + 0x8000) & 0xFFFF0000) - v115 / 2 + 0x8000);
        v80 = 0x8000 - v114 / 2;
        v81 = ((unint64_t)(v69 * v80) >> 16) - v70 + ((unint64_t)(v79 * v71) >> 16);
        v82 = ((unint64_t)(v72 * v80) >> 16) - v73 + ((unint64_t)(v79 * v74) >> 16);
        bvc_extractEdgeParameters(v155, 0, (v77 + 0x8000) >> 16, v120, 2, &v146, &v149, (int *)&v148);
        v123 = v75;
        bvc_extractEdgeParameters(v75, 1, v78 >> 16, v120, 2, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
        v83 = v78 >> 16;
        v84 = v76;
        v85 = a5[1] + v116 * ((uint64_t)v78 >> 16);
        v134 = v116;
        do
        {
          v86 = v147;
          v87 = v148;
          if ((int)v148 < v147)
            v86 = v148;
          v88 = v86 - v83;
          if (v86 > v83)
          {
            v119 = v86;
            v127 = v84;
            v89 = 0;
            v90 = HIDWORD(v148);
            v142 = v149;
            v91 = v151;
            v92 = HIDWORD(v151);
            v93 = HIDWORD(v150);
            v139 = v150;
            v94 = LODWORD(v146.a);
            v117 = HIDWORD(v149);
            v95 = HIDWORD(v149);
            do
            {
              v96 = v94 >> 16;
              if (v94 >> 16 < (v95 >> 16))
              {
                v97 = v96;
                v98 = 2 * v96;
                v99 = v82 + ((unint64_t)(v92 * (uint64_t)(int)(v94 & 0xFFFF0000)) >> 16);
                v100 = v81 + ((unint64_t)(v91 * (uint64_t)(int)(v94 & 0xFFFF0000)) >> 16);
                do
                {
                  v101 = (unsigned __int8 *)(v16 + ((v99 >> 16) * v15) + (int)((v100 >> 14) & 0xFFFFFFFC));
                  v102 = v101[3];
                  if (v101[3])
                  {
                    v103 = *v101;
                    v104 = v101[1];
                    v105 = v101[2];
                    v106 = (14392 * v103 + 16512 * v102 - 9532 * v104 - 4858 * v105) >> 15;
                    v107 = (-2348 * v103 + 16512 * v102 - 12040 * v104 + 14392 * v105) >> 15;
                    if (v102 == 255)
                    {
                      v108 = (_BYTE *)(v85 + v98);
                      *v108 = v106;
                      v108[1] = v107;
                    }
                    else
                    {
                      v109 = (_BYTE *)(v85 + v98);
                      v110 = 0x10000 - (v102 | (v102 << 8));
                      *v109 = v106 + ((v110 * *(unsigned __int8 *)(v85 + v98)) >> 16);
                      v109[1] = v107 + ((v110 * *(unsigned __int8 *)(v85 + v98 + 1)) >> 16);
                    }
                  }
                  v100 += v91;
                  v99 += v92;
                  ++v97;
                  v98 += 2;
                }
                while (v97 < (uint64_t)v95 >> 16);
              }
              v94 += v142;
              v95 += v90;
              v81 += v139;
              v82 += v93;
              v85 += v134;
              ++v89;
            }
            while (v89 != v88);
            LODWORD(v146.a) = v94;
            HIDWORD(v149) = v117 + v90 * v88;
            v87 = v148;
            v83 = v119;
            v84 = v127;
          }
          if (v83 >= v87)
          {
            v84 = *(char **)(v84 + 20);
            if (v84)
            {
              v143 = v83;
              v128 = v84;
              bvc_extractEdgeParameters(v84, 0, v83, v120, 2, &v146, &v149, (int *)&v148);
              v83 = v143;
              v84 = v128;
            }
          }
          if (v83 >= v147)
          {
            v111 = *(_DWORD **)(v123 + 5);
            if (!v111)
              goto LABEL_65;
            v123 = *(_DWORD **)(v123 + 5);
            v129 = v84;
            v144 = v83;
            bvc_extractEdgeParameters(v111, 1, v83, v120, 2, (_DWORD *)&v149 + 1, (_DWORD *)&v148 + 1, &v147);
            v83 = v144;
            v84 = v129;
          }
          v34 = 0;
        }
        while (v84 && v123);
      }
    }
  }
  else
  {
LABEL_65:
    v34 = 0;
  }
  v113 = v34;
  BVCUtilityDestroyEdgeList((uint64_t)v155);
  BVCUtilityDestroyEdgeList((uint64_t)v154);
  return v113;
}

uint64_t bvc_FullComposition_BGRA_420v601(double *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, _QWORD *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, float a14)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t VectorsFromTransform;
  unsigned int v35;
  unsigned int v36;
  __int128 v37;
  uint64_t v38;
  _DWORD *v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  signed int v44;
  signed int v45;
  int v46;
  int v47;
  int v48;
  char *v49;
  int v50;
  _DWORD *v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int a_low;
  int v65;
  unint64_t v66;
  int v67;
  int v68;
  unsigned __int8 *v69;
  int v70;
  _DWORD *v71;
  uint64_t v72;
  _BOOL4 v73;
  uint64_t v74;
  uint64_t v75;
  _BOOL4 v76;
  uint64_t v77;
  char *v78;
  int v79;
  int v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  char *v86;
  uint64_t v87;
  int32x2_t v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  unint64_t v102;
  int v103;
  int v104;
  unsigned __int8 *v105;
  int v106;
  uint32x2_t v107;
  unsigned __int8 *v108;
  int32x2_t v109;
  uint32x2_t v110;
  char *v111;
  _DWORD *v112;
  char *v113;
  signed int v115;
  signed int v116;
  uint64_t v117;
  double v118;
  _QWORD *v119;
  double v120;
  int v121;
  double v122;
  int v123;
  double v124;
  _DWORD *v125;
  _DWORD *v126;
  double v127;
  char *v128;
  char *v129;
  char *v130;
  double v131;
  int v132;
  uint64_t v133;
  char *v134;
  uint64_t v135;
  int v136;
  int v137;
  int v138;
  _DWORD *v139;
  CGAffineTransform v140;
  CGAffineTransform v141;
  int v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  _DWORD *v149;
  char *v150;

  v20 = *a2;
  v21 = *a3;
  v23 = *a4;
  v22 = a4[1];
  v149 = 0;
  v150 = 0;
  if (a6 + a8 >= 32767.0 || a7 + a9 >= 32767.0 || a10 + a12 >= 32767.0 || a11 + a13 >= 32767.0)
    return FigSignalErrorAt();
  v147 = 0;
  v148 = 0;
  v146 = 0;
  v145 = 0;
  v31 = *((_OWORD *)a1 + 1);
  *(_OWORD *)&v141.a = *(_OWORD *)a1;
  *(_OWORD *)&v141.c = v31;
  *(_OWORD *)&v141.tx = *((_OWORD *)a1 + 2);
  if (BVCUtilityIsAffineTransformInvertible(&v141.a))
  {
    memset(&v140, 0, sizeof(v140));
    v32 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v141.a = *(_OWORD *)a1;
    *(_OWORD *)&v141.c = v32;
    *(_OWORD *)&v141.tx = *((_OWORD *)a1 + 2);
    CGAffineTransformInvert(&v140, &v141);
    v127 = *a1;
    v131 = a1[1];
    v124 = a1[3];
    v118 = a1[4];
    v120 = a1[2];
    v122 = a1[5];
    v33 = *((_OWORD *)a1 + 1);
    *(_OWORD *)&v141.a = *(_OWORD *)a1;
    *(_OWORD *)&v141.c = v33;
    *(_OWORD *)&v141.tx = *((_OWORD *)a1 + 2);
    VectorsFromTransform = BVCUtilityGetVectorsFromTransform(&v141.a, &v148, &v147);
    if ((_DWORD)VectorsFromTransform)
    {
      v38 = VectorsFromTransform;
    }
    else
    {
      v35 = v148;
      if ((int)v148 < 0)
        v35 = -(int)v148;
      v36 = v147;
      if ((int)v147 < 0)
        v36 = -(int)v147;
      if (v35 <= v36)
        v35 = v36;
      v123 = v35;
      v141 = v140;
      BVCUtilityGetVectorsFromTransform(&v141.a, &v146, &v145);
      v37 = *((_OWORD *)a1 + 1);
      *(_OWORD *)&v141.a = *(_OWORD *)a1;
      *(_OWORD *)&v141.c = v37;
      *(_OWORD *)&v141.tx = *((_OWORD *)a1 + 2);
      v38 = BVCUtilityCreateEdgeLists((float64x2_t *)&v141, &v150, &v149, a6, a7, a8, a9, a10, a11, a12, a13);
      if (!(_DWORD)v38)
      {
        if (v150)
        {
          v39 = v149;
          if (v149)
          {
            v117 = v22;
            v40 = vcvts_n_s32_f32(a14, 8uLL);
            v41 = vcvtd_n_s64_f64(v118 + v120 * 0.0 + v127 * 0.0, 0x10uLL);
            v42 = vcvtd_n_s64_f64(v122 + v124 * 0.0 + v131 * 0.0, 0x10uLL);
            LODWORD(v141.a) = 0;
            v143 = 0;
            v144 = 0;
            v142 = 0;
            v43 = *(_DWORD *)v150;
            if (*(_DWORD *)v150 <= *v149)
              v43 = *v149;
            v115 = v41;
            v116 = v42;
            v44 = 0x8000 - v41;
            v132 = v43 + 0x8000;
            v135 = v23;
            v45 = ((v43 + 0x8000) & 0xFFFF0000) - v42 + 0x8000;
            v46 = ((unint64_t)((int)v146 * (uint64_t)v44) >> 16)
                - ((int)v145 > 0)
                + ((unint64_t)((int)v145 * (uint64_t)v45) >> 16);
            v47 = (v43 + 0x8000) >> 16;
            v48 = ((unint64_t)(SHIDWORD(v146) * (uint64_t)v44) >> 16)
                - (SHIDWORD(v145) > 0)
                + ((unint64_t)(SHIDWORD(v145) * (uint64_t)v45) >> 16);
            v49 = v150;
            bvc_extractEdgeParameters(v150, 0, v47, v123, 1, &v141, &v144, (int *)&v143);
            bvc_extractEdgeParameters(v39, 1, v47, v123, 1, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
            v50 = v47;
            v51 = v39;
            v52 = v49;
            v119 = a5;
            v53 = *a5 + v135 * ((uint64_t)v132 >> 16);
            v54 = (0x10101020000 * (v40 << 8)) >> 48;
            v133 = v135;
            do
            {
              v55 = v142;
              v56 = v143;
              if ((int)v143 < v142)
                v55 = v143;
              v57 = v55 - v50;
              if (v55 > v50)
              {
                v128 = v52;
                v58 = 0;
                v59 = HIDWORD(v143);
                v136 = v144;
                v60 = v146;
                v61 = HIDWORD(v146);
                v62 = v145;
                v63 = HIDWORD(v145);
                a_low = LODWORD(v141.a);
                v121 = HIDWORD(v144);
                v65 = HIDWORD(v144);
                do
                {
                  LODWORD(v66) = a_low >> 16;
                  if (a_low >> 16 < (v65 >> 16))
                  {
                    v66 = (int)v66;
                    v67 = v48 + ((unint64_t)(v61 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                    v68 = v46 + ((unint64_t)(v60 * (uint64_t)(int)(a_low & 0xFFFF0000)) >> 16);
                    do
                    {
                      v69 = (unsigned __int8 *)(v21 + ((v67 >> 16) * v20) + (int)((v68 >> 14) & 0xFFFFFFFC));
                      v70 = v69[3];
                      if ((_DWORD)v54 * v70)
                        *(_BYTE *)(v53 + v66) = (unsigned __int16)(((2120 * v70
                                                                   + 3219 * *v69
                                                                   + 16508 * v69[1]
                                                                   + 8412 * v69[2]) >> 15)
                                                                 * v40
                                                                 + (((0x10000 - (_DWORD)v54 * v70)
                                                                   * *(unsigned __int8 *)(v53 + v66)) >> 8)) >> 8;
                      v68 += v60;
                      v67 += v61;
                      ++v66;
                    }
                    while (v66 < (uint64_t)v65 >> 16);
                  }
                  a_low += v136;
                  v65 += v59;
                  v46 += v62;
                  v48 += v63;
                  v53 += v133;
                  ++v58;
                }
                while (v58 != v57);
                LODWORD(v141.a) = a_low;
                HIDWORD(v144) = v121 + v59 * v57;
                v56 = v143;
                v50 = v55;
                v52 = v128;
              }
              if (v50 >= v56)
              {
                v52 = *(char **)(v52 + 20);
                if (v52)
                {
                  v137 = v50;
                  v125 = v51;
                  v129 = v52;
                  bvc_extractEdgeParameters(v52, 0, v50, v123, 1, &v141, &v144, (int *)&v143);
                  v50 = v137;
                  v51 = v125;
                  v52 = v129;
                }
              }
              if (v50 >= v142)
              {
                v71 = *(_DWORD **)(v51 + 5);
                if (!v71)
                  break;
                v138 = v50;
                v126 = v71;
                v130 = v52;
                bvc_extractEdgeParameters(v71, 1, v50, v123, 1, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
                v50 = v138;
                v51 = v126;
                v52 = v130;
              }
            }
            while (v52 && v51);
            v72 = 2 * (int)v146;
            v73 = (int)v145 > 0;
            v74 = 2 * (int)v145;
            v75 = 2 * SHIDWORD(v146);
            LODWORD(v146) = 2 * v146;
            HIDWORD(v146) *= 2;
            v76 = SHIDWORD(v145) > 0;
            v77 = 2 * SHIDWORD(v145);
            LODWORD(v145) = 2 * v145;
            HIDWORD(v145) *= 2;
            v78 = v150;
            v139 = v149;
            v79 = *(_DWORD *)v150 / 2;
            if (v79 <= *v149 / 2)
              v79 = *v149 / 2;
            v80 = v79 + 0x8000;
            v81 = (v79 + 0x8000) >> 16;
            v82 = (int)(((v79 + 0x8000) & 0xFFFF0000) - v116 / 2 + 0x8000);
            v83 = 0x8000 - v115 / 2;
            v84 = ((unint64_t)(v72 * v83) >> 16) - v73 + ((unint64_t)(v82 * v74) >> 16);
            v85 = ((unint64_t)(v75 * v83) >> 16) - v76 + ((unint64_t)(v82 * v77) >> 16);
            bvc_extractEdgeParameters(v150, 0, v81, v123, 2, &v141, &v144, (int *)&v143);
            bvc_extractEdgeParameters(v139, 1, v80 >> 16, v123, 2, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
            v86 = v78;
            v87 = v119[1] + v117 * ((uint64_t)v80 >> 16);
            v88 = vdup_n_s32(v40);
            do
            {
              v89 = v143;
              if ((int)v143 >= v142)
                v90 = v142;
              else
                v90 = v143;
              v91 = v90 - v81;
              if (v90 > v81)
              {
                v134 = v86;
                v92 = 0;
                v93 = HIDWORD(v143);
                v94 = v144;
                v95 = v146;
                v96 = HIDWORD(v146);
                v97 = v145;
                v98 = HIDWORD(v145);
                v99 = LODWORD(v141.a);
                v100 = HIDWORD(v144);
                v101 = HIDWORD(v144);
                do
                {
                  LODWORD(v102) = v99 >> 16;
                  if (v99 >> 16 < (v101 >> 16))
                  {
                    v102 = (int)v102;
                    v103 = v85 + ((unint64_t)(v96 * (uint64_t)(int)(v99 & 0xFFFF0000)) >> 16);
                    v104 = v84 + ((unint64_t)(v95 * (uint64_t)(int)(v99 & 0xFFFF0000)) >> 16);
                    do
                    {
                      v105 = (unsigned __int8 *)(v21
                                               + ((v103 >> 16) * v20)
                                               + (int)((v104 >> 14) & 0xFFFFFFFC));
                      v106 = v105[3];
                      if ((_DWORD)v54 * v106)
                      {
                        v107 = (uint32x2_t)vmul_s32((int32x2_t)vshr_n_u32((uint32x2_t)vmla_s32(vmla_s32(vmla_s32(vdup_n_s32(16512 * v106), vdup_n_s32(*v105), (int32x2_t)0xFFFFF6D400003838), vdup_n_s32(v105[1]), (int32x2_t)0xFFFFD0F8FFFFDAC4), vdup_n_s32(v105[2]), (int32x2_t)0x3838FFFFED06), 0xFuLL), v88);
                        v108 = (unsigned __int8 *)(v87 + 2 * v102);
                        v109.i32[0] = *v108;
                        v109.i32[1] = v108[1];
                        v110 = vshr_n_u32(vsra_n_u32(v107, (uint32x2_t)vmul_s32(vdup_n_s32(0x10000 - (int)v54 * v106), v109), 8uLL), 8uLL);
                        *v108 = v110.i8[0];
                        v108[1] = v110.u8[4];
                      }
                      v104 += v95;
                      v103 += v96;
                      ++v102;
                    }
                    while (v102 < (uint64_t)v101 >> 16);
                  }
                  v99 += v94;
                  v101 += v93;
                  v84 += v97;
                  v85 += v98;
                  v87 += v117;
                  ++v92;
                }
                while (v92 != v91);
                LODWORD(v141.a) = v99;
                HIDWORD(v144) = v100 + v93 * v91;
                v89 = v143;
                v81 = v90;
                v86 = v134;
              }
              if (v81 >= v89)
              {
                v86 = *(char **)(v86 + 20);
                if (v86)
                {
                  v111 = v86;
                  bvc_extractEdgeParameters(v86, 0, v81, v123, 2, &v141, &v144, (int *)&v143);
                  v86 = v111;
                }
              }
              if (v81 >= v142)
              {
                v112 = *(_DWORD **)(v139 + 5);
                if (!v112)
                  goto LABEL_63;
                v139 = *(_DWORD **)(v139 + 5);
                v113 = v86;
                bvc_extractEdgeParameters(v112, 1, v81, v123, 2, (_DWORD *)&v144 + 1, (_DWORD *)&v143 + 1, &v142);
                v86 = v113;
              }
              v38 = 0;
            }
            while (v86 && v139);
          }
        }
      }
    }
  }
  else
  {
LABEL_63:
    v38 = 0;
  }
  BVCUtilityDestroyEdgeList((uint64_t)v150);
  BVCUtilityDestroyEdgeList((uint64_t)v149);
  return v38;
}

uint64_t __bvc_blitLayer_block_invoke(uint64_t a1)
{
  double v2;
  uint64_t (*v3)(_OWORD *, uint64_t, uint64_t, uint64_t, uint64_t, double, double, double, double, double);
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  double v8;
  double v9;
  double v10;
  double v11;
  __int128 v12;
  uint64_t result;
  _OWORD v14[3];

  v2 = *(double *)(a1 + 40);
  v3 = *(uint64_t (**)(_OWORD *, uint64_t, uint64_t, uint64_t, uint64_t, double, double, double, double, double))(a1 + 88);
  v4 = *(_QWORD *)(a1 + 176);
  v5 = *(_QWORD *)(a1 + 184);
  v6 = *(_QWORD *)(a1 + 192);
  v7 = *(_QWORD *)(a1 + 200);
  v8 = *(double *)(a1 + 96);
  v9 = *(double *)(a1 + 104);
  v10 = *(double *)(a1 + 112);
  v11 = *(double *)(a1 + 120);
  v12 = *(_OWORD *)(a1 + 144);
  v14[0] = *(_OWORD *)(a1 + 128);
  v14[1] = v12;
  v14[2] = *(_OWORD *)(a1 + 160);
  result = v3(v14, v4, v5, v6, v7, v8, v9, v10, v11, v2);
  if ((_DWORD)result)
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = -12506;
  return result;
}

_DWORD *bvc_extractEdgeParameters(_DWORD *result, int a2, int a3, int a4, int a5, _DWORD *a6, _DWORD *a7, int *a8)
{
  int v8;
  int v9;
  int v10;
  BOOL v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  int v15;
  int v16;
  int v17;

  v8 = result[3];
  v9 = result[1];
  v10 = result[2] / a5 + ((unint64_t)(v8 * (uint64_t)(((a3 << 16) | 0x8000) - *result / a5)) >> 16);
  v12 = v10 + 0x8000;
  v11 = v10 + 0x8000 < 0;
  v13 = -32768 - v10;
  if (!v11)
    v13 = v12;
  v14 = (unint64_t)((int)(a3 + HIWORD(v13)) * (uint64_t)a4 + 0xFFFF) >> 16;
  if (v8 >= 0)
    v15 = result[3];
  else
    v15 = -v8;
  if (a2)
    LODWORD(v14) = -(int)v14;
  v16 = v14 + v12;
  if (a2)
    v17 = -(int)((unint64_t)((int)(((v15 + 0xFFFF) >> 16) + 1) * (uint64_t)a4 + 0xFFFF) >> 16);
  else
    v17 = (unint64_t)((int)(((v15 + 0xFFFF) >> 16) + 1) * (uint64_t)a4 + 0xFFFF) >> 16;
  *a7 = v17 + v8;
  *a6 = v16;
  *a8 = (v9 / a5 + 0x8000) >> 16;
  return result;
}

uint64_t FigSecureStopManagerGetClassID()
{
  MEMORY[0x19402F294](&FigSecureStopManagerGetClassID_sRegisterFigSecureStopManagerTypeOnce, RegisterFigSecureStopManagerType);
  return sFigSecureStopManagerClassID;
}

uint64_t RegisterFigSecureStopManagerType()
{
  CMBaseGetClassID();
  return FigBaseClassRegisterClass();
}

uint64_t FigSecureStopManagerGetTypeID()
{
  MEMORY[0x19402F294](&FigSecureStopManagerGetClassID_sRegisterFigSecureStopManagerTypeOnce, RegisterFigSecureStopManagerType);
  return CMBaseClassGetCFTypeID();
}

uint64_t FigSecureStopManagerCreate(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  if (!a2)
    return FigSignalErrorAt();
  *a2 = 0;
  MEMORY[0x19402F294](&FigSecureStopManagerGetClassID_sRegisterFigSecureStopManagerTypeOnce, RegisterFigSecureStopManagerType);
  result = CMDerivedObjectCreate();
  if (!(_DWORD)result)
    return FigSignalErrorAt();
  return result;
}

uint64_t FigSecureStopManagerCopyDefaultRuntimeInstance(uint64_t a1, _QWORD *a2)
{
  CFTypeRef v3;
  const void *v4;
  uint64_t v5;
  _QWORD block[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  int v15;

  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  if (a2)
  {
    *a2 = 0;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __FigSecureStopManagerCopyDefaultRuntimeInstance_block_invoke;
    block[3] = &unk_1E2FA6790;
    block[5] = &v8;
    block[6] = a1;
    block[4] = &v12;
    if (FigSecureStopManagerCopyDefaultRuntimeInstance_once != -1)
      dispatch_once(&FigSecureStopManagerCopyDefaultRuntimeInstance_once, block);
    if (!*((_DWORD *)v13 + 6))
    {
      v3 = (CFTypeRef)v9[3];
      if (v3)
      {
        FigSecureStopManagerCopyDefaultRuntimeInstance_defaultSingletonManager = v9[3];
        v9[3] = 0;
      }
      else
      {
        v3 = (CFTypeRef)FigSecureStopManagerCopyDefaultRuntimeInstance_defaultSingletonManager;
        if (!FigSecureStopManagerCopyDefaultRuntimeInstance_defaultSingletonManager)
        {
LABEL_9:
          *a2 = v3;
          goto LABEL_10;
        }
      }
      v3 = CFRetain(v3);
      goto LABEL_9;
    }
  }
  else
  {
    *((_DWORD *)v13 + 6) = FigSignalErrorAt();
  }
LABEL_10:
  v4 = (const void *)v9[3];
  if (v4)
    CFRelease(v4);
  v5 = *((unsigned int *)v13 + 6);
  _Block_object_dispose(&v8, 8);
  _Block_object_dispose(&v12, 8);
  return v5;
}

CFStringRef FigSecureStopManagerCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigSecureStopManager %p]"), a1);
}

void fssm_finalize()
{
  uint64_t DerivedStorage;
  const void *v1;
  const void *v2;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v1 = *(const void **)(DerivedStorage + 16);
  if (v1)
  {
    CFRelease(v1);
    *(_QWORD *)(DerivedStorage + 16) = 0;
  }
  v2 = *(const void **)(DerivedStorage + 24);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(DerivedStorage + 24) = 0;
  }
  dispatch_release(*(dispatch_object_t *)DerivedStorage);
  dispatch_release(*(dispatch_object_t *)(DerivedStorage + 8));
}

__CFString *fssm_copyDebugDescription(const void *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  CFIndex v4;
  CFAllocatorRef v5;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = CFGetRetainCount(a1);
  v5 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigSecureStopManager %p retainCount: %ld allocator: %p>"), a1, v4, v5);
  return Mutable;
}

uint64_t fssm_fbo_initialize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject **DerivedStorage;
  NSObject *v7;
  uint64_t v8;
  _QWORD block[9];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;

  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  DerivedStorage = (NSObject **)CMBaseObjectGetDerivedStorage();
  if (a2 && a3)
  {
    v7 = *DerivedStorage;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __fssm_fbo_initialize_block_invoke;
    block[3] = &unk_1E2FA6868;
    block[4] = &v11;
    block[5] = DerivedStorage;
    block[6] = a3;
    block[7] = a1;
    block[8] = a2;
    dispatch_sync(v7, block);
    v8 = *((unsigned int *)v12 + 6);
  }
  else
  {
    v8 = FigSignalErrorAt();
    *((_DWORD *)v12 + 6) = v8;
  }
  _Block_object_dispose(&v11, 8);
  return v8;
}

uint64_t fssm_fbo_copyRecords(uint64_t a1, _QWORD *a2)
{
  NSObject **DerivedStorage;
  NSObject *v4;
  uint64_t v5;
  _QWORD block[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  DerivedStorage = (NSObject **)CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    *a2 = 0;
    v4 = *DerivedStorage;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __fssm_fbo_copyRecords_block_invoke;
    block[3] = &unk_1E2FA6890;
    block[4] = &v8;
    block[5] = DerivedStorage;
    block[6] = a2;
    dispatch_sync(v4, block);
    v5 = *((unsigned int *)v9 + 6);
  }
  else
  {
    v5 = FigSignalErrorAt();
    *((_DWORD *)v9 + 6) = v5;
  }
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t fssm_fbo_removeRecords(uint64_t a1, uint64_t a2)
{
  NSObject **DerivedStorage;
  NSObject *v4;
  uint64_t v5;
  _QWORD block[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  DerivedStorage = (NSObject **)CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    v4 = *DerivedStorage;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __fssm_fbo_removeRecords_block_invoke;
    block[3] = &unk_1E2FA68B8;
    block[4] = &v8;
    block[5] = DerivedStorage;
    block[6] = a2;
    dispatch_sync(v4, block);
    v5 = *((unsigned int *)v9 + 6);
  }
  else
  {
    v5 = FigSignalErrorAt();
    *((_DWORD *)v9 + 6) = v5;
  }
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t fssm_fbo_updateRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject **DerivedStorage;
  NSObject *v16;
  uint64_t v17;
  _QWORD block[13];
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  int v23;

  v20 = 0;
  v21 = &v20;
  v22 = 0x2000000000;
  v23 = 0;
  DerivedStorage = (NSObject **)CMBaseObjectGetDerivedStorage();
  if (a3 | a4 && a8)
  {
    v16 = *DerivedStorage;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __fssm_fbo_updateRecord_block_invoke;
    block[3] = &unk_1E2FA68E0;
    block[4] = &v20;
    block[5] = DerivedStorage;
    block[6] = a2;
    block[7] = a3;
    block[8] = a4;
    block[9] = a5;
    block[10] = a6;
    block[11] = a7;
    block[12] = a8;
    dispatch_sync(v16, block);
    v17 = *((unsigned int *)v21 + 6);
  }
  else
  {
    v17 = FigSignalErrorAt();
    *((_DWORD *)v21 + 6) = v17;
  }
  _Block_object_dispose(&v20, 8);
  return v17;
}

uint64_t fssm_fbo_finalizeRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  NSObject **DerivedStorage;
  NSObject *v15;
  uint64_t v16;
  _QWORD block[13];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  int v22;

  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 0;
  DerivedStorage = (NSObject **)CMBaseObjectGetDerivedStorage();
  if (a3 | a4 && a6 && a4 | a7)
  {
    v15 = *DerivedStorage;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __fssm_fbo_finalizeRecord_block_invoke;
    block[3] = &unk_1E2FA6908;
    block[4] = &v19;
    block[5] = DerivedStorage;
    block[6] = a2;
    block[7] = a3;
    block[8] = a4;
    block[9] = a5;
    block[10] = a6;
    block[11] = a7;
    block[12] = a1;
    dispatch_sync(v15, block);
    v16 = *((unsigned int *)v20 + 6);
  }
  else
  {
    v16 = FigSignalErrorAt();
    *((_DWORD *)v20 + 6) = v16;
  }
  _Block_object_dispose(&v19, 8);
  return v16;
}

void __fssm_fbo_initialize_block_invoke(uint64_t a1)
{
  const void *v2;
  uint64_t v3;
  const void *v4;
  CFURLRef v5;
  const __CFURL *v6;
  const __CFAllocator *v7;
  int v8;
  uint64_t v9;
  const void *v10;
  CFTypeRef v11;
  CFTypeRef cf;

  cf = 0;
  v3 = *(_QWORD *)(a1 + 40);
  v2 = *(const void **)(a1 + 48);
  v4 = *(const void **)(v3 + 24);
  *(_QWORD *)(v3 + 24) = v2;
  if (v2)
    CFRetain(v2);
  if (v4)
    CFRelease(v4);
  v5 = CFURLCreateFilePathURL((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFURLRef *)(a1 + 48), 0);
  if (v5)
  {
    v6 = v5;
    v7 = CFGetAllocator(*(CFTypeRef *)(a1 + 56));
    v8 = FigSecureStopArchivistCopyInstance(v7, *(const __CFData **)(a1 + 64), v6, &cf);
    v9 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v8;
    v10 = *(const void **)(v9 + 16);
    v11 = cf;
    *(_QWORD *)(v9 + 16) = cf;
    if (v11)
      CFRetain(v11);
    if (v10)
      CFRelease(v10);
    CFRelease(v6);
    if (cf)
      CFRelease(cf);
  }
  else
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = FigSignalErrorAt();
  }
}

uint64_t __fssm_fbo_copyRecords_block_invoke(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t (*v4)(uint64_t, uint64_t);

  v1 = *(_QWORD *)(*(_QWORD *)(result + 40) + 16);
  if (v1)
  {
    v2 = result;
    v3 = *(_QWORD *)(result + 48);
    v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 16);
    if (v4)
      result = v4(v1, v3);
    else
      result = 4294954514;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t __fssm_fbo_removeRecords_block_invoke(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t (*v4)(uint64_t, uint64_t);

  v1 = *(_QWORD *)(*(_QWORD *)(result + 40) + 16);
  if (v1)
  {
    v2 = result;
    v3 = *(_QWORD *)(result + 48);
    v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
    if (v4)
      result = v4(v1, v3);
    else
      result = 4294954514;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t __fssm_fbo_updateRecord_block_invoke(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  v1 = *(_QWORD *)(*(_QWORD *)(result + 40) + 16);
  if (v1)
  {
    v2 = result;
    v3 = *(_QWORD *)(result + 48);
    v4 = *(_QWORD *)(result + 56);
    v5 = *(_QWORD *)(result + 64);
    v6 = *(_QWORD *)(result + 72);
    v7 = *(_QWORD *)(result + 80);
    v8 = *(_QWORD *)(result + 88);
    v9 = *(_QWORD *)(result + 96);
    v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
    if (v10)
      result = v10(v1, v3, v4, v5, v6, v7, v8, v9);
    else
      result = 4294954514;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t __fssm_fbo_finalizeRecord_block_invoke(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  v1 = *(_QWORD *)(*(_QWORD *)(result + 40) + 16);
  if (v1)
  {
    v2 = result;
    v3 = *(_QWORD *)(result + 48);
    v4 = *(_QWORD *)(result + 56);
    v5 = *(_QWORD *)(result + 64);
    v6 = *(_QWORD *)(result + 72);
    v7 = *(_QWORD *)(result + 80);
    v8 = *(_QWORD *)(result + 88);
    v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                 + 40);
    if (v9)
      result = v9(v1, v3, v4, v5, v6, v7, v8);
    else
      result = 4294954514;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 8) + 24) = result;
    if (!*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 8) + 24))
    {
      CMNotificationCenterGetDefaultLocalCenter();
      return FigDispatchAsyncPostNotification();
    }
  }
  return result;
}

uint64_t FigXPCFormatReaderServerAssociateCopiedNeighborSampleCursor(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, void *a5)
{
  uint64_t v8;
  uint64_t v10;
  CFTypeRef v11;
  CFTypeRef v12;

  v11 = 0;
  v12 = 0;
  if (!a2)
  {
    if (a1)
    {
      v8 = FigXPCServerLookupAndRetainAssociatedObject();
      if (!(_DWORD)v8)
      {
        v10 = 0;
        goto LABEL_10;
      }
    }
    else
    {
      v8 = FigSignalErrorAt();
    }
    goto LABEL_16;
  }
  v8 = FigXPCServerLookupAndRetainAssociatedObject();
  if ((_DWORD)v8 || (v8 = FigServedSampleCursorStateCreate(*MEMORY[0x1E0C9AE00], a3, v11, (uint64_t *)&v12), (_DWORD)v8))
  {
LABEL_16:
    v10 = v8;
    goto LABEL_10;
  }
  v10 = FigXPCServerAssociateCopiedObjectWithNeighborProcess();
  if (!(_DWORD)v10)
  {
    FigSampleCursorServer_SetSampleCursorProperties((uint64_t)v12, a4, 1, 2, MEMORY[0x1E0CA2E40], 0, a5);
    v12 = 0;
  }
LABEL_10:
  if (v11)
    CFRelease(v11);
  if (v12)
    CFRelease(v12);
  return v10;
}

uint64_t FigServedTrackReaderStateCreate(uint64_t a1, const void *a2, uint64_t *a3)
{
  uint64_t Instance;
  uint64_t v7;
  uint64_t v8;

  if (!a3 || !a2)
    return FigSignalErrorAt();
  if (FigServedTrackReaderStateGetTypeID_sRegisterFigServedTrackReaderStateTypeOnce != -1)
    dispatch_once_f(&FigServedTrackReaderStateGetTypeID_sRegisterFigServedTrackReaderStateTypeOnce, 0, (dispatch_function_t)registerFigServedTrackReaderStateType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return FigSignalErrorAt();
  v7 = Instance;
  *(_QWORD *)(Instance + 16) = CFRetain(a2);
  *(_WORD *)(v7 + 32) = 1;
  v8 = FigPartialSampleTableOutOfBandObjectRegistryCreate(a1, (_QWORD *)(v7 + 24));
  if ((_DWORD)v8)
    CFRelease((CFTypeRef)v7);
  else
    *a3 = v7;
  return v8;
}

uint64_t FigServedSampleCursorStateCreate(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t Instance;
  uint64_t v7;
  CFTypeRef v8;
  uint64_t v9;
  const __CFDictionary *Mutable;
  const void *v11;
  const void *v12;

  if (!a3 || !a3[3] || !a4)
    return FigSignalErrorAt();
  if (FigServedSampleCursorStateGetTypeID_sRegisterFigServedSampleCursorStateTypeOnce != -1)
    dispatch_once_f(&FigServedSampleCursorStateGetTypeID_sRegisterFigServedSampleCursorStateTypeOnce, 0, (dispatch_function_t)registerFigServedSampleCursorStateType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return FigSignalErrorAt();
  v7 = Instance;
  *(_QWORD *)(Instance + 16) = CFRetain(a3);
  v8 = (CFTypeRef)a3[3];
  if (v8)
    v8 = CFRetain(v8);
  *(_QWORD *)(v7 + 24) = v8;
  if (FigSampleCursorServer_copyMemoryPool_sOnceToken != -1)
    dispatch_once(&FigSampleCursorServer_copyMemoryPool_sOnceToken, &__block_literal_global_91);
  MEMORY[0x19402EEEC](FigSampleCursorServer_copyMemoryPool_sSharedMemoryPoolWeakRefMutex);
  if (!FigSampleCursorServer_copyMemoryPool_sSharedMemoryPoolWeakRef
    || (v9 = FigCFWeakReferenceHolderCopyReferencedObject()) == 0)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v9 = (uint64_t)CMMemoryPoolCreate(Mutable);
    v11 = (const void *)FigCFWeakReferenceHolderCreateWithReferencedObject();
    v12 = (const void *)FigSampleCursorServer_copyMemoryPool_sSharedMemoryPoolWeakRef;
    FigSampleCursorServer_copyMemoryPool_sSharedMemoryPoolWeakRef = (uint64_t)v11;
    if (v11)
      CFRetain(v11);
    if (v12)
      CFRelease(v12);
    if (Mutable)
      CFRelease(Mutable);
  }
  MEMORY[0x19402EF04](FigSampleCursorServer_copyMemoryPool_sSharedMemoryPoolWeakRefMutex);
  *(_QWORD *)(v7 + 40) = v9;
  FigXPCServerCopyMemoryOrigin();
  FigXPCServerCopyMemoryRecipient();
  *(_BYTE *)(v7 + 32) = 0;
  *a4 = v7;
  return 0;
}

void FigSampleCursorServer_SetSampleCursorProperties(uint64_t a1, CFTypeRef cf, int a3, char a4, __int128 *a5, int a6, void *a7)
{
  unsigned __int8 v8;
  int v14;
  int v15;
  CFTypeID v16;
  _BOOL4 v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int (*v20)(CFTypeRef, char *);
  unsigned int (*v21)(CFTypeRef, __int128 *);
  unsigned int (*v22)(CFTypeRef, __int128 *);
  uint64_t (*v23)(CFTypeRef, char *, char *, _OWORD *, char *);
  int v24;
  uint64_t v25;
  unint64_t v26;
  int v27;
  __int128 v28;
  uint64_t v29;
  __CFArray *Mutable;
  unsigned int (*v31)(CFTypeRef, CFTypeRef *);
  CFTypeRef v32;
  int64_t v33;
  void (*v34)(CFTypeRef, int64_t, __int128 *);
  BOOL v35;
  const void *v36;
  int v37;
  uint64_t FigBaseObject;
  void (*v39)(uint64_t, const __CFString *, uint64_t, CFTypeRef *);
  CFTypeRef v40;
  int v41;
  CFTypeRef v42;
  void (*v43)(CFTypeRef, uint64_t, __int128 *);
  CFTypeRef cfa;
  _QWORD v45[2];
  _OWORD v46[2];
  char v47;
  int64_t value;
  _DWORD capacity[3];
  __int128 bytes;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;
  CFTypeRef v55;
  CFTypeRef v56;
  OpaqueCMBlockBuffer *v57;

  v8 = a6;
  v56 = 0;
  v57 = 0;
  v55 = 0;
  if (a6)
  {
    if (FigSampleCursorServer_maximumStepsForBuildingPartialSampleTable_maximumStepsForBuildingPartialSampleTableOnce != -1)
      dispatch_once(&FigSampleCursorServer_maximumStepsForBuildingPartialSampleTable_maximumStepsForBuildingPartialSampleTableOnce, &__block_literal_global_93);
    v14 = FigSampleCursorServer_maximumStepsForBuildingPartialSampleTable_maximumStepsForBuildingPartialSampleTable;
    v15 = 20;
  }
  else
  {
    v15 = 0;
    v14 = 1;
  }
  v16 = CFGetTypeID(cf);
  if (v16 != FigSampleCursorGetTypeID())
  {
    FigSignalErrorAt();
    goto LABEL_75;
  }
  if (a3)
  {
    v17 = *(_QWORD *)(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 64) != 0;
    if (*(_QWORD *)(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 80))
      v18 = (2 * v17) | 4;
    else
      v18 = 2 * v17;
    if (*(_QWORD *)(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 144))
      v18 |= 8u;
    if (*(_QWORD *)(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 152))
      v18 |= 0x10u;
    if (*(_QWORD *)(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 112))
      v18 |= 0x20u;
    if (*(_QWORD *)(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 72))
      v19 = v18 | 0x40;
    else
      v19 = v18;
    xpc_dictionary_set_uint64(a7, "SampleCursorOptionalMethods", v19);
  }
  if ((a4 & 1) != 0)
  {
    v54 = 0;
    v52 = 0u;
    v53 = 0u;
    bytes = 0u;
    v51 = 0u;
    v20 = *(unsigned int (**)(CFTypeRef, char *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 40);
    if (v20)
    {
      if (!v20(cf, (char *)&v51 + 8))
      {
        v21 = *(unsigned int (**)(CFTypeRef, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 48);
        if (v21)
        {
          if (!v21(cf, &v53))
          {
            v22 = *(unsigned int (**)(CFTypeRef, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
            if (v22)
            {
              if (!v22(cf, &bytes))
              {
                *(_QWORD *)&v46[0] = 0;
                if (!*(_QWORD *)(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 64)
                  || (v23 = *(uint64_t (**)(CFTypeRef, char *, char *, _OWORD *, char *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                  + 64)) != 0
                  && ((v24 = v23(cf, (char *)v46 + 4, (char *)v46 + 5, v46, (char *)v46 + 6)) == 0 || v24 == -12840))
                {
                  xpc_dictionary_set_data(a7, "SampleCursorSampleTimingInfo", &bytes, 0x48uLL);
                  xpc_dictionary_set_data(a7, "SampleCursorSyncInfo", v46, 8uLL);
                }
              }
            }
          }
        }
      }
    }
    goto LABEL_75;
  }
  memset(capacity, 0, sizeof(capacity));
  value = 0;
  v47 = 0;
  if (v14 != 1
    && FigSampleCursorServer_maximumStoragePagesForBuildingPartialSampleTable_maximumStoragePagesForBuildingPartialSampleTableOnce != -1)
  {
    dispatch_once(&FigSampleCursorServer_maximumStoragePagesForBuildingPartialSampleTable_maximumStoragePagesForBuildingPartialSampleTableOnce, &__block_literal_global_99);
  }
  if (FigMemoryPoolCreateBlockBuffer()
    || (v46[0] = xmmword_1E2FA6D60,
        v46[1] = *(_OWORD *)off_1E2FA6D70,
        FigPartialSampleTableRecommendSampleTableFlagsForCursor(1023, (uint64_t)cf, (unint64_t *)&capacity[1])))
  {
LABEL_75:
    Mutable = 0;
    goto LABEL_76;
  }
  v45[0] = a1;
  v45[1] = a7;
  v25 = *(_QWORD *)(a1 + 16);
  if (!v25)
  {
    v26 = *(_QWORD *)&capacity[1];
    if ((a4 & 4) != 0)
      goto LABEL_46;
    goto LABEL_45;
  }
  v26 = *(_QWORD *)&capacity[1];
  if (!*(_BYTE *)(v25 + 33))
  {
    v26 = *(_QWORD *)&capacity[1] & 0xFFFFFFFFFFFFFDFFLL;
    *(_QWORD *)&capacity[1] &= ~0x200uLL;
  }
  if (!*(_BYTE *)(v25 + 32))
  {
    v26 &= ~1uLL;
    *(_QWORD *)&capacity[1] = v26;
  }
  if ((a4 & 4) == 0)
  {
LABEL_45:
    v26 &= ~0x200uLL;
    *(_QWORD *)&capacity[1] = v26;
  }
LABEL_46:
  v27 = *(unsigned __int8 *)(*(_QWORD *)(v25 + 16) + 32);
  v28 = a5[1];
  bytes = *a5;
  v51 = v28;
  v52 = a5[2];
  if (FigPartialSampleTableBuildFromFigSampleCursorAndWriteToBlockBuffer(cf, v57, v46, (uint64_t)v45, v26, v27, (uint64_t)&bytes, v8, v15, v14, &value, capacity, &v47))goto LABEL_75;
  if (FigXPCMessageSetBlockBuffer())
    goto LABEL_75;
  xpc_dictionary_set_int64(a7, "SampleCursorSampleIndex", value);
  if (!v47)
    goto LABEL_75;
  *(_QWORD *)&bytes = 0;
  v29 = *MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], capacity[0], MEMORY[0x1E0C9B378]);
  v31 = *(unsigned int (**)(CFTypeRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
  if (v31 && !v31(cf, &v56))
  {
    v32 = v56;
    v33 = value;
    v34 = *(void (**)(CFTypeRef, int64_t, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 168);
    if (v34)
      v34(v32, -v33, &bytes);
    v35 = (_QWORD)bytes + value == 0;
    if (capacity[0] >= 1 && (_QWORD)bytes == -value)
    {
      v36 = (const void *)*MEMORY[0x1E0C9B0D0];
      v37 = 1;
      do
      {
        cfa = 0;
        FigBaseObject = FigSampleCursorGetFigBaseObject(v56);
        v39 = *(void (**)(uint64_t, const __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                       + 48);
        if (v39)
          v39(FigBaseObject, CFSTR("SampleDependencyAttributes"), v29, &cfa);
        v40 = cfa;
        if (!cfa)
          v40 = v36;
        CFArrayAppendValue(Mutable, v40);
        if (cfa)
          CFRelease(cfa);
        v41 = capacity[0];
        if (v37 >= capacity[0])
        {
          v35 = 1;
        }
        else
        {
          v42 = v56;
          v43 = *(void (**)(CFTypeRef, uint64_t, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 168);
          if (v43)
            v43(v42, 1, &bytes);
          v35 = (_QWORD)bytes == 1;
          v41 = capacity[0];
        }
        if (v37 >= v41)
          break;
        ++v37;
      }
      while (v35);
    }
    if (v35 && !FigRemote_CreateSerializedAtomDataBlockBufferWithFlagsForCFType())
      FigXPCMessageSetBlockBuffer();
  }
LABEL_76:
  if (v57)
    CFRelease(v57);
  if (v55)
    CFRelease(v55);
  if (Mutable)
    CFRelease(Mutable);
  if (v56)
    CFRelease(v56);
}

uint64_t FigXPCFormatReaderServerAssociateCopiedNeighborTrackReader(uint64_t a1, xpc_connection_t connection)
{
  uint64_t v2;
  uint64_t pid;
  uint64_t v4;
  uint64_t v6;
  CFTypeRef v7;
  CFTypeRef v8;
  CFTypeRef cf;

  v8 = 0;
  cf = 0;
  v7 = 0;
  if (a1)
  {
    v2 = FigXPCServerLookupAndRetainAssociatedObject();
    if (!(_DWORD)v2)
    {
      v6 = 0;
      goto LABEL_9;
    }
    goto LABEL_15;
  }
  if (!connection)
  {
    v2 = FigSignalErrorAt();
LABEL_15:
    v6 = v2;
    goto LABEL_9;
  }
  pid = xpc_connection_get_pid(connection);
  v4 = *MEMORY[0x1E0C9AE00];
  v2 = CreateServedFormatReaderState(*MEMORY[0x1E0C9AE00], pid, &v8);
  if ((_DWORD)v2)
    goto LABEL_15;
  cf = v8;
  v2 = FigServedTrackReaderStateCreate(v4, v8, (uint64_t *)&v7);
  if ((_DWORD)v2)
    goto LABEL_15;
  v6 = FigXPCServerAssociateCopiedObjectWithNeighborProcess();
  if (!(_DWORD)v6)
    v7 = 0;
LABEL_9:
  if (v7)
    CFRelease(v7);
  if (v8)
    CFRelease(v8);
  return v6;
}

uint64_t CreateServedFormatReaderState(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t Instance;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (FigServedFormatReaderStateGetTypeID_sRegisterFigServedFormatReaderStateTypeOnce != -1)
    dispatch_once(&FigServedFormatReaderStateGetTypeID_sRegisterFigServedFormatReaderStateTypeOnce, &__block_literal_global_66);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v5 = (_QWORD *)Instance;
    v6 = FigSandboxAssertionCreateForPID();
    if (!(_DWORD)v6)
    {
      v7 = FigOSTransactionCreate();
      v5[3] = v7;
      if (v7)
      {
        v8 = 0;
        *a3 = v5;
        return v8;
      }
      v6 = FigSignalErrorAt();
    }
    v8 = v6;
    CFRelease(v5);
    return v8;
  }
  return FigSignalErrorAt();
}

uint64_t FigXPCFormatReaderServerAssociateCopiedNeighborFormatReader(_xpc_connection_s *a1, uint64_t a2)
{
  uint64_t pid;
  uint64_t v4;
  BOOL v5;
  const void *v6;
  uint64_t v7;
  _BYTE *v9;

  v9 = 0;
  pid = xpc_connection_get_pid(a1);
  v4 = CreateServedFormatReaderState(*MEMORY[0x1E0C9AE00], pid, &v9);
  if ((_DWORD)v4)
  {
    v7 = v4;
    v6 = v9;
    if (!v9)
      return v7;
LABEL_5:
    CFRelease(v6);
    return v7;
  }
  v5 = mightFormatReaderBlockOnIOWhenStepping(a2);
  v6 = v9;
  v9[32] = v5;
  v7 = FigXPCServerAssociateCopiedObjectWithNeighborProcess();
  if ((_DWORD)v7)
    goto LABEL_5;
  return v7;
}

BOOL mightFormatReaderBlockOnIOWhenStepping(uint64_t a1)
{
  uint64_t FigBaseObject;
  unsigned int (*v2)(uint64_t, const __CFString *, _QWORD, CFTypeRef *);
  _BOOL8 v3;
  CFTypeRef cf;

  cf = 0;
  FigBaseObject = FigFormatReaderGetFigBaseObject(a1);
  v2 = *(unsigned int (**)(uint64_t, const __CFString *, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                       + 48);
  v3 = v2
    && !v2(FigBaseObject, CFSTR("Identifier"), *MEMORY[0x1E0C9AE00], &cf)
    && (FigCFEqual() || FigCFEqual() || FigCFEqual());
  if (cf)
    CFRelease(cf);
  return v3;
}

uint64_t FigXPCFormatReaderServerCopyFormatReaderForID()
{
  return FigXPCServerRetainNeighborObjectFromID();
}

uint64_t FigFormatReaderServerIsObjectIDLocallyServed()
{
  return FigXPCIsObjectIDLocallyServed();
}

uint64_t FigFormatReaderServerStart()
{
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v1;
  uint64_t v2;

  if (!FigServer_IsMediaparserd())
    FigServer_IsMediaplaybackd();
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return FigSignalErrorAt();
  v1 = Mutable;
  FigCFDictionarySetValue();
  FigCFDictionarySetInt32();
  v2 = FigXPCServerStart();
  CFRelease(v1);
  return v2;
}

uint64_t HandleFormatReaderMessage(uint64_t a1, void *a2)
{
  uint64_t OpCode;
  CFTypeID v6;
  CFStringRef v7;
  CFTypeRef v8;

  OpCode = FigXPCMessageGetOpCode();
  if ((_DWORD)OpCode)
    return OpCode;
  v8 = 0;
  xpc_dictionary_get_uint64(a2, (const char *)*MEMORY[0x1E0CA36A0]);
  OpCode = FigXPCServerLookupAndRetainAssociatedObject();
  if ((_DWORD)OpCode)
    return OpCode;
  v6 = CFGetTypeID(0);
  v7 = CFCopyTypeIDDescription(v6);
  if (v7)
    CFRelease(v7);
  return 0;
}

uint64_t HandleNoReplyFormatReaderMessage(uint64_t a1, void *a2)
{
  uint64_t OpCode;

  OpCode = FigXPCMessageGetOpCode();
  if ((_DWORD)OpCode)
    return OpCode;
  xpc_dictionary_get_uint64(a2, (const char *)*MEMORY[0x1E0CA36A0]);
  OpCode = FigXPCServerLookupAndRetainAssociatedObject();
  if ((_DWORD)OpCode)
    return OpCode;
  else
    return 4294951138;
}

uint64_t HandleServerSetupEventLink()
{
  return FigOSEventLinkServerSetCallbacks();
}

uint64_t FigFormatReaderServerStartLoopbackServerAndCopyXPCEndpoint()
{
  CFMutableDictionaryRef Mutable;
  uint64_t v1;
  uint64_t v2;

  if (FigFormatReaderServerStartLoopbackServerAndCopyXPCEndpoint_sEndpointServer)
    return FigSignalErrorAt();
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetInt();
  FigCFDictionarySetValue();
  v1 = FigXPCServerStartWithNewXPCEndpoint();
  if (!(_DWORD)v1)
    v1 = FigXPCServerCopyXPCEndpoint();
  v2 = v1;
  if (Mutable)
    CFRelease(Mutable);
  return v2;
}

uint64_t FigXPCFormatReaderServerCopySampleCursorForID(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  result = FigXPCServerRetainNeighborObjectFromID();
  if (!(_DWORD)result)
  {
    result = 0;
    *a2 = 0;
  }
  return result;
}

_QWORD *servedFormatReaderState_Init(_QWORD *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void servedFormatReaderState_Finalize(uint64_t a1)
{
  const void *v2;
  void *v3;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v3 = *(void **)(a1 + 24);
  if (v3)
  {
    os_release(v3);
    *(_QWORD *)(a1 + 24) = 0;
  }
}

__CFString *servedFormatReaderState_CopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;

  Mutable = CFStringCreateMutable(0, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("FigServedFormatReaderState %p"), a1);
  return Mutable;
}

uint64_t registerFigServedTrackReaderStateType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigServedTrackReaderStateID = result;
  return result;
}

_QWORD *FigServedTrackReaderState_Init(_QWORD *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void FigServedTrackReaderState_Finalize(uint64_t a1)
{
  const void *v2;
  const void *v3;

  v2 = *(const void **)(a1 + 24);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v3 = *(const void **)(a1 + 16);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

__CFString *FigServedTrackReaderState_CopyDescription(const void *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigServedTrackReaderState %p>"), a1);
  return Mutable;
}

uint64_t registerFigServedSampleCursorStateType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigServedSampleCursorStateID = result;
  return result;
}

double FigServedSampleCursorState_Init(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void FigServedSampleCursorState_Finalize(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0;
  }
  v5 = (const void *)a1[6];
  if (v5)
  {
    CFRelease(v5);
    a1[6] = 0;
  }
  v6 = (const void *)a1[7];
  if (v6)
  {
    CFRelease(v6);
    a1[7] = 0;
  }
}

__CFString *FigServedSampleCursorState_CopyDescription(const void *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigServedSampleCursorState %p>"), a1);
  return Mutable;
}

uint64_t FigSampleCursorServer_TranslateByteStream(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;

  v7 = 0;
  if (FigServer_IsMediaparserd())
  {
    result = FigByteStreamRemoteGetObjectID(a2, &v7);
    if (a3 && !(_DWORD)result)
    {
      v6 = v7;
LABEL_7:
      result = 0;
      *a3 = v6;
    }
  }
  else
  {
    if (a3)
    {
      v6 = 0;
      goto LABEL_7;
    }
    return 0;
  }
  return result;
}

uint64_t FigSampleCursorServer_TranslateDataSource(xpc_object_t *a1, CFTypeRef cf, uint64_t *a3)
{
  uint64_t IDForObjectOfType;
  xpc_object_t array;
  void *v7;
  xpc_object_t empty;
  void *v9;
  uint64_t v10;
  char v12;
  uint64_t value;

  value = 0;
  v12 = 0;
  IDForObjectOfType = FigPartialSampleTableOutOfBandObjectRegistryLookupOrMakeIDForObjectOfType(*((_QWORD *)*a1 + 3), CFSTR("DataSourceURL"), cf, &value, &v12);
  if ((_DWORD)IDForObjectOfType)
  {
    v10 = IDForObjectOfType;
  }
  else
  {
    if (v12)
    {
      array = xpc_dictionary_get_array(a1[1], "SampleCursorDataSourceArray");
      if (!array)
      {
        array = xpc_array_create(0, 0);
        xpc_dictionary_set_value(a1[1], "SampleCursorDataSourceArray", array);
        FigXPCRelease();
      }
      v7 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      if (!v7 || (empty = xpc_dictionary_create_empty(), (v9 = empty) == 0))
      {
        v10 = FigSignalErrorAt();
        goto LABEL_9;
      }
      xpc_dictionary_set_value(empty, "SampleCursorDataSourceURL", v7);
      xpc_dictionary_set_uint64(v9, "SampleCursorDataSourceOutOfBandID", value);
      xpc_array_append_value(array, v9);
    }
    v10 = 0;
    *a3 = value;
  }
LABEL_9:
  FigXPCRelease();
  FigXPCRelease();
  return v10;
}

uint64_t FigSampleCursorServer_TranslateFormatDescription(xpc_object_t *a1, CFTypeRef cf, uint64_t *a3)
{
  uint64_t IDForObjectOfType;
  xpc_object_t array;
  uint64_t SerializedAtomDataBlockBufferForFormatDescription;
  OpaqueCMBlockBuffer *v8;
  size_t DataLength;
  char *v10;
  size_t v11;
  NSObject *v12;
  NSObject *v13;
  xpc_object_t v14;
  xpc_object_t empty;
  void *v16;
  uint64_t v17;
  _QWORD destructor[5];
  char *dataPointerOut;
  char v21;
  uint64_t value;
  OpaqueCMBlockBuffer *v23;

  v23 = 0;
  value = 0;
  v21 = 0;
  IDForObjectOfType = FigPartialSampleTableOutOfBandObjectRegistryLookupOrMakeIDForObjectOfType(*((_QWORD *)*a1 + 3), CFSTR("FormatDescription"), cf, &value, &v21);
  if ((_DWORD)IDForObjectOfType)
  {
    v17 = IDForObjectOfType;
    v13 = 0;
    goto LABEL_14;
  }
  if (!v21)
  {
    v13 = 0;
    goto LABEL_13;
  }
  dataPointerOut = 0;
  array = xpc_dictionary_get_array(a1[1], "SampleCursorFormatDescriptionArray");
  if (!array)
  {
    array = xpc_array_create(0, 0);
    xpc_dictionary_set_value(a1[1], "SampleCursorFormatDescriptionArray", array);
    FigXPCRelease();
  }
  SerializedAtomDataBlockBufferForFormatDescription = FigRemote_CreateSerializedAtomDataBlockBufferForFormatDescription();
  if ((_DWORD)SerializedAtomDataBlockBufferForFormatDescription)
    goto LABEL_19;
  v8 = v23;
  DataLength = CMBlockBufferGetDataLength(v23);
  if (CMBlockBufferIsRangeContiguous(v8, 0, DataLength))
  {
    SerializedAtomDataBlockBufferForFormatDescription = CMBlockBufferGetDataPointer(v23, 0, 0, 0, &dataPointerOut);
    if (!(_DWORD)SerializedAtomDataBlockBufferForFormatDescription)
    {
      v10 = dataPointerOut;
      v11 = CMBlockBufferGetDataLength(v23);
      destructor[0] = MEMORY[0x1E0C809B0];
      destructor[1] = 0x40000000;
      destructor[2] = __FigSampleCursorServer_TranslateFormatDescription_block_invoke;
      destructor[3] = &__block_descriptor_tmp_102_0;
      destructor[4] = v23;
      v12 = dispatch_data_create(v10, v11, 0, destructor);
      v13 = v12;
      if (v12)
      {
        v23 = 0;
        v14 = xpc_data_create_with_dispatch_data(v12);
        if (v14)
        {
          empty = xpc_dictionary_create_empty();
          if (empty)
          {
            v16 = empty;
            xpc_dictionary_set_value(empty, "SampleCursorFormatDescription", v14);
            xpc_dictionary_set_uint64(v16, "SampleCursorFormatDescriptionOutOfBandID", value);
            xpc_array_append_value(array, v16);
LABEL_13:
            v17 = 0;
            *a3 = value;
            goto LABEL_14;
          }
        }
      }
      goto LABEL_22;
    }
LABEL_19:
    v17 = SerializedAtomDataBlockBufferForFormatDescription;
    v13 = 0;
    goto LABEL_14;
  }
  v13 = 0;
LABEL_22:
  v17 = FigSignalErrorAt();
LABEL_14:
  FigXPCRelease();
  FigXPCRelease();
  if (v23)
    CFRelease(v23);
  if (v13)
    dispatch_release(v13);
  return v17;
}

uint64_t HandleSampleCursorMessage(int a1, uint64_t a2, const void *a3, uint64_t a4, const void *a5, uint64_t a6, xpc_object_t xdict, void *a8)
{
  if (xpc_dictionary_get_uint64(xdict, "SampleCursorSecondSampleCursorID"))
    xpc_dictionary_set_value(xdict, "SampleCursorSecondSampleCursorID", 0);
  if (a1 > 1936159592)
  {
    if (a1 > 1936941670)
    {
      if (a1 > 1936944226)
      {
        if (a1 == 1936944227)
          return HandleSampleCursorCopySampleLocationMessage(a3, a8);
        if (a1 == 1936945268)
          return HandleSampleCursorStepByPresentationTimeMessage(a3, a4, xdict, a8);
      }
      else
      {
        if (a1 == 1936941671)
          return HandleSampleCursorGetBatchSampleTimingAndSizes(a3, a5, xdict, a8);
        if (a1 == 1936942196)
          return HandleSampleCursorStepByDecodeTimeMessage(a3, a4, xdict, a8);
      }
    }
    else if (a1 > 1936730999)
    {
      if (a1 == 1936731000)
        return HandleSampleCursorStepInPresentationOrderAndReportStepsTakenMessage(a3, a4, xdict, a8);
      if (a1 == 1936941670)
        return HandleSampleCursorCreateSampleBufferMessage(a3, (uint64_t)a5);
    }
    else
    {
      if (a1 == 1936159593)
        return HandleSampleCursorGetSampleSyncInfoMessage(a3, a8);
      if (a1 == 1936159849)
        return HandleSampleCursorGetSampleTimingInfoMessage(a3, a8);
    }
  }
  else if (a1 > 1935896690)
  {
    if (a1 > 1935944567)
    {
      if (a1 == 1935944568)
        return HandleSampleCursorStepInDecodeOrderAndReportStepsTakenMessage(a3, a4, xdict, a8);
      if (a1 == 1935962979)
        return HandleSampleCursorCopyFormatDescriptionMessage(a3);
    }
    else
    {
      if (a1 == 1935896691)
        return HandleSampleCursorCopyMessage(a2, a3, a4, xdict, a8);
      if (a1 == 1935896697)
        return HandleSampleCursorCopyPropertyMessage(a3);
    }
  }
  else if (a1 > 1935894634)
  {
    if (a1 == 1935894635)
      return HandleSampleCursorCopyChunkDetailsMessage(a3, a8);
    if (a1 == 1935895920)
      return HandleSampleCursorCompareInDecodeOrderMessage(a3, a5, a8);
  }
  else
  {
    if (a1 == 1668492075)
      return HandleSampleCursorMaybeCopyAndStepCursorsThenPerformOperationWithCopiesMessage(a2, a3, a4, a5, a6, xdict, a8);
    if (a1 == 1935830628)
      return HandleSampleCursorTestReorderingBoundaryMessage(a3, a5, xdict, a8);
  }
  return 4294951138;
}

uint64_t HandleSampleCursorCopyPropertyMessage(const void *a1)
{
  CFTypeID v1;
  uint64_t result;

  v1 = CFGetTypeID(a1);
  if (v1 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  result = FigXPCMessageCopyCFString();
  if (!(_DWORD)result)
    return FigSignalErrorAt();
  return result;
}

uint64_t HandleSampleCursorCopyMessage(uint64_t a1, CFTypeRef cf, uint64_t a3, void *a4, void *a5)
{
  CFTypeID v10;
  uint64_t v11;
  char v12;
  CFTypeRef v14;
  CFTypeRef cfa;
  uint64_t value;

  cfa = 0;
  value = 0;
  v14 = 0;
  v10 = CFGetTypeID(cf);
  if (v10 == FigSampleCursorGetTypeID())
  {
    v11 = CopySampleCursorAndReturnObjectID(a1, cf, a3, &v14, &cfa, &value);
    if (!(_DWORD)v11)
    {
      v12 = FigSampleCursorServer_obtainCacheOption(a4);
      FigSampleCursorServer_SetSampleCursorProperties((uint64_t)cfa, v14, 0, v12, MEMORY[0x1E0CA2E40], 0, a5);
      xpc_dictionary_set_uint64(a5, (const char *)*MEMORY[0x1E0CA36A0], value);
    }
  }
  else
  {
    v11 = FigSignalErrorAt();
  }
  if (cfa)
    CFRelease(cfa);
  if (v14)
    CFRelease(v14);
  return v11;
}

uint64_t HandleSampleCursorGetSampleTimingInfoMessage(const void *a1, void *a2)
{
  __int128 v4;
  __int128 v5;
  CFTypeID v6;
  uint64_t (*v7)(const void *, char *);
  uint64_t result;
  uint64_t (*v9)(const void *, __int128 *);
  uint64_t (*v10)(const void *, __int128 *);
  __int128 v11;
  _OWORD v12[2];
  __int128 v13;
  uint64_t v14;

  v4 = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 48);
  v12[1] = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 32);
  v13 = v4;
  v14 = *(_QWORD *)(MEMORY[0x1E0CA2E90] + 64);
  v5 = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 16);
  v11 = *MEMORY[0x1E0CA2E90];
  v12[0] = v5;
  v6 = CFGetTypeID(a1);
  if (v6 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  v7 = *(uint64_t (**)(const void *, char *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 40);
  if (!v7)
    return 4294954514;
  result = v7(a1, (char *)v12 + 8);
  if ((_DWORD)result)
    return result;
  v9 = *(uint64_t (**)(const void *, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 48);
  if (!v9)
    return 4294954514;
  result = v9(a1, &v13);
  if ((_DWORD)result)
    return result;
  v10 = *(uint64_t (**)(const void *, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
  if (!v10)
    return 4294954514;
  result = v10(a1, &v11);
  if (!(_DWORD)result)
  {
    xpc_dictionary_set_data(a2, "SampleCursorSampleTimingInfo", &v11, 0x48uLL);
    return 0;
  }
  return result;
}

uint64_t HandleSampleCursorGetSampleSyncInfoMessage(const void *a1, void *a2)
{
  CFTypeID v4;
  uint64_t (*v5)(const void *, char *, char *, uint64_t *, char *);
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t bytes;

  bytes = 0;
  v4 = CFGetTypeID(a1);
  if (v4 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  v5 = *(uint64_t (**)(const void *, char *, char *, uint64_t *, char *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                             + 16)
                                                                                 + 64);
  if (!v5)
    return 4294954514;
  v6 = v5(a1, (char *)&bytes + 4, (char *)&bytes + 5, &bytes, (char *)&bytes + 6);
  v7 = v6;
  if ((_DWORD)v6)
    v8 = (_DWORD)v6 == -12840;
  else
    v8 = 1;
  if (v8)
    xpc_dictionary_set_data(a2, "SampleCursorSyncInfo", &bytes, 8uLL);
  return v7;
}

uint64_t HandleSampleCursorStepByDecodeTimeMessage(const void *a1, uint64_t a2, void *a3, void *a4)
{
  CFTypeID v8;
  uint64_t result;
  uint64_t (*v10)(const void *, __int128 *);
  BOOL v11;
  char v12;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;

  v13 = *MEMORY[0x1E0CA2E18];
  v14 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  v8 = CFGetTypeID(a1);
  if (v8 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  result = FigXPCMessageGetCMTime();
  if (!(_DWORD)result)
  {
    v10 = *(uint64_t (**)(const void *, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 120);
    if (v10)
    {
      v15 = v13;
      v16 = v14;
      result = v10(a1, &v15);
      if ((_DWORD)result)
        v11 = (_DWORD)result == -12840;
      else
        v11 = 1;
      if (v11)
      {
        xpc_dictionary_set_BOOL(a4, "SampleCursorPositionWasPinned", (_DWORD)result == -12840);
        v12 = FigSampleCursorServer_obtainCacheOption(a3);
        FigSampleCursorServer_SetSampleCursorProperties(a2, a1, 0, v12, MEMORY[0x1E0CA2E40], 0, a4);
        return 0;
      }
    }
    else
    {
      return 4294954514;
    }
  }
  return result;
}

uint64_t HandleSampleCursorStepByPresentationTimeMessage(const void *a1, uint64_t a2, void *a3, void *a4)
{
  CFTypeID v8;
  uint64_t result;
  uint64_t (*v10)(const void *, __int128 *);
  BOOL v11;
  char v12;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;

  v13 = *MEMORY[0x1E0CA2E18];
  v14 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  v8 = CFGetTypeID(a1);
  if (v8 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  result = FigXPCMessageGetCMTime();
  if (!(_DWORD)result)
  {
    v10 = *(uint64_t (**)(const void *, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 128);
    if (v10)
    {
      v15 = v13;
      v16 = v14;
      result = v10(a1, &v15);
      if ((_DWORD)result)
        v11 = (_DWORD)result == -12840;
      else
        v11 = 1;
      if (v11)
      {
        xpc_dictionary_set_BOOL(a4, "SampleCursorPositionWasPinned", (_DWORD)result == -12840);
        v12 = FigSampleCursorServer_obtainCacheOption(a3);
        FigSampleCursorServer_SetSampleCursorProperties(a2, a1, 0, v12, MEMORY[0x1E0CA2E40], 0, a4);
        return 0;
      }
    }
    else
    {
      return 4294954514;
    }
  }
  return result;
}

uint64_t HandleSampleCursorStepInDecodeOrderAndReportStepsTakenMessage(const void *a1, uint64_t a2, void *a3, void *a4)
{
  __int128 v8;
  CFTypeID v9;
  int64_t int64;
  uint64_t (*v11)(const void *, int64_t, int64_t *);
  uint64_t v12;
  int v13;
  char v14;
  __int128 v16[3];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  int64_t v20;

  v20 = 0;
  v8 = *(_OWORD *)(MEMORY[0x1E0CA2E40] + 16);
  v17 = *MEMORY[0x1E0CA2E40];
  v18 = v8;
  v19 = *(_OWORD *)(MEMORY[0x1E0CA2E40] + 32);
  v9 = CFGetTypeID(a1);
  if (v9 == FigSampleCursorGetTypeID())
  {
    int64 = xpc_dictionary_get_int64(a3, "SampleCursorStepCount");
    FigXPCMessageGetCMTimeRange();
    v11 = *(uint64_t (**)(const void *, int64_t, int64_t *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 168);
    if (v11)
    {
      v12 = v11(a1, int64, &v20);
      if (!(_DWORD)v12)
      {
        if (int64 > 0)
          v13 = 1;
        else
          v13 = int64 >> 63;
        v14 = FigSampleCursorServer_obtainCacheOption(a3);
        v16[0] = v17;
        v16[1] = v18;
        v16[2] = v19;
        FigSampleCursorServer_SetSampleCursorProperties(a2, a1, 0, v14, v16, v13, a4);
      }
    }
    else
    {
      v12 = 4294954514;
    }
  }
  else
  {
    v12 = FigSignalErrorAt();
  }
  xpc_dictionary_set_int64(a4, "SampleCursorStepsTaken", v20);
  return v12;
}

uint64_t HandleSampleCursorStepInPresentationOrderAndReportStepsTakenMessage(const void *a1, uint64_t a2, void *a3, void *a4)
{
  __int128 v8;
  CFTypeID v9;
  int64_t int64;
  uint64_t (*v11)(const void *, int64_t, int64_t *);
  uint64_t v12;
  int v13;
  char v14;
  __int128 v16[3];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  int64_t v20;

  v20 = 0;
  v8 = *(_OWORD *)(MEMORY[0x1E0CA2E40] + 16);
  v17 = *MEMORY[0x1E0CA2E40];
  v18 = v8;
  v19 = *(_OWORD *)(MEMORY[0x1E0CA2E40] + 32);
  v9 = CFGetTypeID(a1);
  if (v9 == FigSampleCursorGetTypeID())
  {
    int64 = xpc_dictionary_get_int64(a3, "SampleCursorStepCount");
    FigXPCMessageGetCMTimeRange();
    v11 = *(uint64_t (**)(const void *, int64_t, int64_t *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 176);
    if (v11)
    {
      v12 = v11(a1, int64, &v20);
      if (!(_DWORD)v12)
      {
        if (int64 > 0)
          v13 = 1;
        else
          v13 = int64 >> 63;
        v14 = FigSampleCursorServer_obtainCacheOption(a3);
        v16[0] = v17;
        v16[1] = v18;
        v16[2] = v19;
        FigSampleCursorServer_SetSampleCursorProperties(a2, a1, 0, v14, v16, v13, a4);
      }
    }
    else
    {
      v12 = 4294954514;
    }
  }
  else
  {
    v12 = FigSignalErrorAt();
  }
  xpc_dictionary_set_int64(a4, "SampleCursorStepsTaken", v20);
  return v12;
}

uint64_t HandleSampleCursorCompareInDecodeOrderMessage(const void *a1, const void *a2, void *a3)
{
  CFTypeID v6;
  CFTypeID v8;
  uint64_t v9;
  int64_t v10;
  uint64_t (*v11)(const void *, const void *);

  v6 = CFGetTypeID(a1);
  if (v6 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  if (!a2)
    return FigSignalErrorAt();
  v8 = CFGetTypeID(a2);
  if (v8 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  v9 = *(_QWORD *)(CMBaseObjectGetVTable() + 16);
  if (v9 == *(_QWORD *)(CMBaseObjectGetVTable() + 16)
    && (v11 = *(uint64_t (**)(const void *, const void *))(v9 + 32)) != 0)
  {
    v10 = v11(a1, a2);
  }
  else
  {
    v10 = 0;
  }
  xpc_dictionary_set_int64(a3, "SampleCursorComparisonResult", v10);
  return 0;
}

uint64_t HandleSampleCursorTestReorderingBoundaryMessage(const void *a1, const void *a2, void *a3, void *a4)
{
  CFTypeID v8;
  CFTypeID v10;
  int64_t int64;
  uint64_t v12;
  BOOL v13;
  unsigned int (*v14)(const void *, const void *, int64_t);

  v8 = CFGetTypeID(a1);
  if (v8 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  if (!a2)
    return FigSignalErrorAt();
  v10 = CFGetTypeID(a2);
  if (v10 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  int64 = xpc_dictionary_get_int64(a3, "SampleCursorReorderingBoundary");
  v12 = *(_QWORD *)(CMBaseObjectGetVTable() + 16);
  v13 = v12 == *(_QWORD *)(CMBaseObjectGetVTable() + 16)
     && (v14 = *(unsigned int (**)(const void *, const void *, int64_t))(v12 + 80)) != 0
     && v14(a1, a2, int64) != 0;
  xpc_dictionary_set_BOOL(a4, "SampleCursorTestReorderingBoundaryResult", v13);
  return 0;
}

uint64_t HandleSampleCursorCopySampleLocationMessage(const void *a1, void *a2)
{
  CFTypeID v4;
  uint64_t (*v5)(const void *, uint64_t *, uint64_t *, CFTypeRef *, CFTypeRef *);
  uint64_t v6;
  uint64_t CMBaseObject;
  void (*v8)(uint64_t, _QWORD, _QWORD, CFTypeRef *);
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  CFTypeRef cf;
  CFTypeRef v14;

  cf = 0;
  v14 = 0;
  v4 = CFGetTypeID(a1);
  if (v4 != FigSampleCursorGetTypeID())
  {
    v6 = FigSignalErrorAt();
    goto LABEL_19;
  }
  v11 = 0;
  v12 = 0;
  v5 = *(uint64_t (**)(const void *, uint64_t *, uint64_t *, CFTypeRef *, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                              + 144);
  if (!v5)
  {
    v9 = 4294954514;
    goto LABEL_12;
  }
  v6 = v5(a1, &v11, &v12, &v14, &cf);
  if ((_DWORD)v6)
  {
LABEL_19:
    v9 = v6;
    goto LABEL_12;
  }
  xpc_dictionary_set_data(a2, "SampleCursorSampleStorageRange", &v11, 0x10uLL);
  if (v14)
  {
    if (!cf)
    {
      CMBaseObject = CMByteStreamGetCMBaseObject();
      v8 = *(void (**)(uint64_t, _QWORD, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 48);
      if (v8)
        v8(CMBaseObject, *MEMORY[0x1E0CA2098], *MEMORY[0x1E0C9AE00], &cf);
    }
  }
  else if (!cf)
  {
    return 0;
  }
  FigXPCMessageSetCFURL();
  v9 = 0;
LABEL_12:
  if (cf)
    CFRelease(cf);
  if (v14)
    CFRelease(v14);
  return v9;
}

uint64_t HandleSampleCursorCopyChunkDetailsMessage(const void *a1, void *a2)
{
  CFTypeID v4;
  uint64_t (*v5)(const void *, CFTypeRef *, CFTypeRef *, uint64_t *, uint64_t *, uint64_t *, int64_t *, uint64_t *, char *, char *);
  uint64_t v6;
  uint64_t CMBaseObject;
  void (*v8)(uint64_t, _QWORD, _QWORD, CFTypeRef *);
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t bytes;
  uint64_t v14;
  CFTypeRef cf;
  CFTypeRef v16;
  int64_t v17;

  v16 = 0;
  v17 = 0;
  cf = 0;
  v4 = CFGetTypeID(a1);
  if (v4 != FigSampleCursorGetTypeID())
  {
    v6 = FigSignalErrorAt();
    goto LABEL_19;
  }
  bytes = 0;
  v14 = 0;
  v11 = 0;
  v12 = 0;
  v5 = *(uint64_t (**)(const void *, CFTypeRef *, CFTypeRef *, uint64_t *, uint64_t *, uint64_t *, int64_t *, uint64_t *, char *, char *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 152);
  if (!v5)
  {
    v9 = 4294954514;
    goto LABEL_12;
  }
  v6 = v5(a1, &v16, &cf, &bytes, &v14, &v11, &v17, &v12, (char *)&v12 + 1, (char *)&v12 + 2);
  if ((_DWORD)v6)
  {
LABEL_19:
    v9 = v6;
    goto LABEL_12;
  }
  xpc_dictionary_set_data(a2, "SampleCursorSampleStorageRange", &bytes, 0x10uLL);
  xpc_dictionary_set_data(a2, "SampleCursorChunkInfo", &v11, 0x10uLL);
  xpc_dictionary_set_int64(a2, "SampleCursorSampleIndex", v17);
  if (v16)
  {
    if (!cf)
    {
      CMBaseObject = CMByteStreamGetCMBaseObject();
      v8 = *(void (**)(uint64_t, _QWORD, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 48);
      if (v8)
        v8(CMBaseObject, *MEMORY[0x1E0CA2098], *MEMORY[0x1E0C9AE00], &cf);
    }
  }
  else if (!cf)
  {
    return 0;
  }
  FigXPCMessageSetCFURL();
  v9 = 0;
LABEL_12:
  if (cf)
    CFRelease(cf);
  if (v16)
    CFRelease(v16);
  return v9;
}

uint64_t HandleSampleCursorCopyFormatDescriptionMessage(const void *a1)
{
  CFTypeID v2;
  uint64_t (*v3)(const void *, CFTypeRef *);
  uint64_t v4;
  CFTypeRef v5;
  uint64_t v6;
  CFTypeRef cf;

  cf = 0;
  v2 = CFGetTypeID(a1);
  if (v2 == FigSampleCursorGetTypeID())
  {
    v3 = *(uint64_t (**)(const void *, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 160);
    if (!v3)
      return 4294954514;
    v4 = v3(a1, &cf);
    v5 = cf;
    if ((_DWORD)v4)
    {
      v6 = v4;
      if (!cf)
        return v6;
    }
    else
    {
      v6 = FigXPCMessageSetFormatDescription();
      v5 = cf;
      if (!cf)
        return v6;
    }
    CFRelease(v5);
    return v6;
  }
  return FigSignalErrorAt();
}

uint64_t HandleSampleCursorCreateSampleBufferMessage(const void *a1, uint64_t a2)
{
  CFTypeID v4;
  uint64_t (*v5)(const void *, uint64_t, CFTypeRef *);
  uint64_t SerializedAtomDataBlockBufferForSampleBuffer;
  const __CFAllocator *v7;
  uint64_t v8;
  CMBlockBufferRef blockBufferOut;
  CMBlockBufferRef theBuffer;
  CFTypeRef cf;

  theBuffer = 0;
  cf = 0;
  v4 = CFGetTypeID(a1);
  if (v4 != FigSampleCursorGetTypeID())
  {
    SerializedAtomDataBlockBufferForSampleBuffer = FigSignalErrorAt();
    goto LABEL_11;
  }
  v5 = *(uint64_t (**)(const void *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 112);
  if (v5)
  {
    SerializedAtomDataBlockBufferForSampleBuffer = v5(a1, a2, &cf);
    if ((_DWORD)SerializedAtomDataBlockBufferForSampleBuffer)
      goto LABEL_11;
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    SerializedAtomDataBlockBufferForSampleBuffer = FigRemote_CreateSerializedAtomDataBlockBufferForSampleBuffer();
    if ((_DWORD)SerializedAtomDataBlockBufferForSampleBuffer)
      goto LABEL_11;
    if (!CMBlockBufferIsRangeContiguous(theBuffer, 0, 0))
    {
      blockBufferOut = 0;
      SerializedAtomDataBlockBufferForSampleBuffer = CMBlockBufferCreateContiguous(v7, theBuffer, v7, 0, 0, 0, 0, &blockBufferOut);
      if ((_DWORD)SerializedAtomDataBlockBufferForSampleBuffer)
      {
LABEL_11:
        v8 = SerializedAtomDataBlockBufferForSampleBuffer;
        goto LABEL_13;
      }
      if (theBuffer)
        CFRelease(theBuffer);
      theBuffer = blockBufferOut;
    }
    SerializedAtomDataBlockBufferForSampleBuffer = FigXPCMessageSetBlockBuffer();
    goto LABEL_11;
  }
  v8 = 4294954514;
LABEL_13:
  if (cf)
    CFRelease(cf);
  if (theBuffer)
    CFRelease(theBuffer);
  return v8;
}

uint64_t HandleSampleCursorGetBatchSampleTimingAndSizes(const void *a1, const void *a2, void *a3, void *a4)
{
  CFTypeID v8;
  CFTypeID v9;
  unint64_t int64;
  _BOOL4 v11;
  uint64_t *v12;
  uint64_t *p_value;
  uint64_t BatchSampleTimingAndSizes;
  int64_t v15;
  CFAllocatorRef *v16;
  char *v17;
  uint64_t v18;
  int64_t v20;
  int64_t value;
  int64_t v22;
  CMBlockBufferRef blockBufferOut;
  CMBlockBufferRef theBuffer;
  char *dataPointerOut;
  char *v26;

  dataPointerOut = 0;
  v26 = 0;
  blockBufferOut = 0;
  theBuffer = 0;
  value = 0;
  v22 = 0;
  v20 = 0;
  v8 = CFGetTypeID(a1);
  if (v8 != FigSampleCursorGetTypeID())
    goto LABEL_35;
  if (a2)
  {
    v9 = CFGetTypeID(a2);
    if (v9 != FigSampleCursorGetTypeID())
      goto LABEL_35;
  }
  int64 = xpc_dictionary_get_int64(a3, "SampleCursorBatchMaxSamplesToInclude");
  v11 = xpc_dictionary_get_BOOL(a3, "SampleCursorBatchRequiresSampleSizeEntries");
  if (xpc_dictionary_get_BOOL(a3, "SampleCursorBatchRequiresSampleTimingEntries"))
    v12 = &v20;
  else
    v12 = 0;
  if (v11)
    p_value = &value;
  else
    p_value = 0;
  BatchSampleTimingAndSizes = FigSampleCursorUtilityGetBatchSampleTimingAndSizes((uint64_t)a1, int64, (uint64_t)a2, 0, v12, 0, p_value, 0);
  if ((_DWORD)BatchSampleTimingAndSizes)
    goto LABEL_36;
  v15 = v20;
  if (v20 > int64 || value > int64)
  {
LABEL_35:
    BatchSampleTimingAndSizes = FigSignalErrorAt();
    goto LABEL_36;
  }
  v16 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (value)
  {
    BatchSampleTimingAndSizes = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 8 * value, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 8 * value, 1u, &theBuffer);
    if ((_DWORD)BatchSampleTimingAndSizes)
      goto LABEL_36;
    BatchSampleTimingAndSizes = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
    if ((_DWORD)BatchSampleTimingAndSizes)
      goto LABEL_36;
    v15 = v20;
  }
  if (v15)
  {
    BatchSampleTimingAndSizes = CMBlockBufferCreateWithMemoryBlock(*v16, 0, 72 * v15, *v16, 0, 0, 72 * v15, 1u, &blockBufferOut);
    if ((_DWORD)BatchSampleTimingAndSizes)
      goto LABEL_36;
    BatchSampleTimingAndSizes = CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &v26);
    if ((_DWORD)BatchSampleTimingAndSizes)
      goto LABEL_36;
    v17 = v26;
  }
  else
  {
    v17 = 0;
  }
  BatchSampleTimingAndSizes = FigSampleCursorUtilityGetBatchSampleTimingAndSizes((uint64_t)a1, int64, (uint64_t)a2, &v22, v12, (uint64_t)v17, p_value, (uint64_t)dataPointerOut);
  if (!(_DWORD)BatchSampleTimingAndSizes)
  {
    if (theBuffer)
    {
      BatchSampleTimingAndSizes = FigXPCMessageSetBlockBuffer();
      if ((_DWORD)BatchSampleTimingAndSizes)
        goto LABEL_36;
      xpc_dictionary_set_int64(a4, "SampleCursorBatchNumSampleSizeEntries", value);
    }
    if (!blockBufferOut)
    {
LABEL_29:
      xpc_dictionary_set_int64(a4, "SampleCursorBatchNumSamplesIncluded", v22);
      v18 = 0;
      goto LABEL_30;
    }
    BatchSampleTimingAndSizes = FigXPCMessageSetBlockBuffer();
    if (!(_DWORD)BatchSampleTimingAndSizes)
    {
      xpc_dictionary_set_int64(a4, "SampleCursorBatchNumSampleTimingEntries", v20);
      goto LABEL_29;
    }
  }
LABEL_36:
  v18 = BatchSampleTimingAndSizes;
LABEL_30:
  if (theBuffer)
    CFRelease(theBuffer);
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  return v18;
}

uint64_t HandleSampleCursorMaybeCopyAndStepCursorsThenPerformOperationWithCopiesMessage(uint64_t a1, CFTypeRef cf, uint64_t a3, CFTypeRef a4, uint64_t a5, void *a6, void *a7)
{
  CFTypeRef v11;
  CFTypeID v13;
  _BOOL4 v14;
  CFTypeRef int64;
  CFTypeID v16;
  _BOOL4 v17;
  CFTypeRef v18;
  uint64_t v19;
  uint64_t (*v20)(CFTypeRef, CFTypeRef, CFTypeRef *);
  uint64_t (*v21)(CFTypeRef, CFTypeRef, CFTypeRef *);
  xpc_object_t v22;
  void *v23;
  int uint64;
  xpc_object_t empty;
  uint64_t v26;
  CFTypeRef cfa;
  uint64_t v30;
  uint64_t value;
  CFTypeRef v32;
  CFTypeRef v33;

  v11 = cf;
  v32 = 0;
  v33 = 0;
  v30 = 0;
  value = 0;
  v13 = CFGetTypeID(cf);
  if (v13 != FigSampleCursorGetTypeID())
    goto LABEL_32;
  v14 = xpc_dictionary_get_BOOL(a6, "SampleCursorCursorMustCopy");
  int64 = (CFTypeRef)xpc_dictionary_get_int64(a6, "SampleCursorMatchCacheSteps");
  if (a4)
  {
    v16 = CFGetTypeID(a4);
    if (v16 != FigSampleCursorGetTypeID())
    {
LABEL_32:
      v19 = FigSignalErrorAt();
      goto LABEL_33;
    }
    v17 = xpc_dictionary_get_BOOL(a6, "SampleCursorSecondCursorMustCopy");
    v18 = (CFTypeRef)xpc_dictionary_get_int64(a6, "SampleCursorSecondCursorMatchCacheSteps");
    if (!v14)
      goto LABEL_10;
  }
  else
  {
    v17 = 0;
    v18 = 0;
    if (!v14)
      goto LABEL_10;
  }
  cfa = 0;
  v19 = CopySampleCursorAndReturnObjectID(a1, v11, a3, &v33, &cfa, &value);
  if ((_DWORD)v19)
    goto LABEL_33;
  xpc_dictionary_set_uint64(a7, (const char *)*MEMORY[0x1E0CA36A0], value);
  v11 = v33;
  LODWORD(a3) = (_DWORD)cfa;
  if (cfa)
    CFRelease(cfa);
LABEL_10:
  if (v17)
  {
    cfa = 0;
    v19 = CopySampleCursorAndReturnObjectID(a1, a4, a5, &v32, &cfa, &v30);
    if ((_DWORD)v19)
      goto LABEL_33;
    xpc_dictionary_set_uint64(a7, "SampleCursorSecondSampleCursorID", v30);
    a4 = v32;
    LODWORD(a5) = (_DWORD)cfa;
    if (cfa)
      CFRelease(cfa);
  }
  if (!int64)
    goto LABEL_18;
  cfa = 0;
  v20 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 168);
  if (!v20)
    goto LABEL_25;
  v19 = v20(v11, int64, &cfa);
  if ((_DWORD)v19)
  {
LABEL_33:
    v26 = v19;
    goto LABEL_27;
  }
  if (int64 != cfa)
    goto LABEL_32;
LABEL_18:
  if (!v18)
    goto LABEL_22;
  cfa = 0;
  v21 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 168);
  if (!v21)
  {
LABEL_25:
    v26 = 4294954514;
    goto LABEL_27;
  }
  v19 = v21(a4, v18, &cfa);
  if ((_DWORD)v19)
    goto LABEL_33;
  if (v18 != cfa)
    goto LABEL_32;
LABEL_22:
  v22 = xpc_dictionary_get_value(a6, "SampleCursorAdditionalOperation");
  if (v22)
  {
    v23 = v22;
    uint64 = xpc_dictionary_get_uint64(v22, (const char *)*MEMORY[0x1E0CA36A8]);
    empty = xpc_dictionary_create_empty();
    if (empty)
    {
      HandleSampleCursorMessage(uint64, a1, (int)v11, a3, (int)a4, a5, v23);
      FigXPCMessageSetOSStatus();
      xpc_dictionary_set_value(a7, "SampleCursorAdditionalReply", empty);
      v26 = 0;
    }
    else
    {
      v26 = FigSignalErrorAt();
    }
  }
  else
  {
    v26 = 0;
  }
LABEL_27:
  FigXPCRelease();
  if (v33)
    CFRelease(v33);
  if (v32)
    CFRelease(v32);
  return v26;
}

uint64_t CopySampleCursorAndReturnObjectID(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4, CFTypeRef *a5, _QWORD *a6)
{
  uint64_t (*v12)(const void *, CFTypeRef *);
  uint64_t v13;
  CFAllocatorRef v14;
  CFTypeRef v15;
  uint64_t v16;
  CFTypeRef cf;
  CFTypeRef v19;

  cf = 0;
  v19 = 0;
  v12 = *(uint64_t (**)(const void *, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
  if (v12)
  {
    v13 = v12(a2, &v19);
    if ((_DWORD)v13
      || (v14 = CFGetAllocator(a2),
          v13 = FigServedSampleCursorStateCreate((uint64_t)v14, a1, *(_QWORD **)(a3 + 16), (uint64_t *)&cf),
          (_DWORD)v13)
      || (v15 = cf,
          *((_BYTE *)cf + 32) = *(_BYTE *)(a3 + 32),
          *(_BYTE *)(a3 + 32) = 0,
          CFRetain(v15),
          v13 = FigXPCServerAssociateObjectWithConnectionWithFlags(),
          (_DWORD)v13))
    {
      v16 = v13;
      if (!a5)
        goto LABEL_16;
      goto LABEL_14;
    }
    if (a4)
    {
      *a4 = v19;
      v19 = 0;
    }
    if (a5)
      *a5 = cf;
    v16 = 0;
    if (a6)
    {
      *a6 = 0;
      if (!a5)
        goto LABEL_16;
      goto LABEL_14;
    }
  }
  else
  {
    v16 = 4294954514;
  }
  if (!a5)
    goto LABEL_16;
LABEL_14:
  if (*a5)
    CFRetain(*a5);
LABEL_16:
  if (cf)
    CFRelease(cf);
  if (v19)
    CFRelease(v19);
  return v16;
}

uint64_t FigSampleCursorServer_obtainCacheOption(void *a1)
{
  _BOOL4 v1;
  unsigned int v2;

  v1 = xpc_dictionary_get_BOOL(a1, "UseSimpleCache");
  if (FigSampleCursorServer_shouldCacheMinimumUpcomingPTSInPartialSampleTable_shouldCacheMinimumUpcomingPTSInPartialSampleTableOnce != -1)
    dispatch_once(&FigSampleCursorServer_shouldCacheMinimumUpcomingPTSInPartialSampleTable_shouldCacheMinimumUpcomingPTSInPartialSampleTableOnce, &__block_literal_global_106_0);
  if (v1)
    v2 = 1;
  else
    v2 = 2;
  if (FigSampleCursorServer_shouldCacheMinimumUpcomingPTSInPartialSampleTable_shouldCacheMinimumUpcomingPTSInPartialSampleTable)
    return v2 | 4;
  else
    return v2;
}

uint64_t HandleTrackReaderCopyPropertyMessage(const void *a1)
{
  CFTypeID v1;
  uint64_t result;

  v1 = CFGetTypeID(a1);
  if (v1 != FigTrackReaderGetTypeID())
    return FigSignalErrorAt();
  result = FigXPCMessageCopyCFString();
  if (!(_DWORD)result)
    return FigSignalErrorAt();
  return result;
}

uint64_t HandleTrackReaderCopyMetadataReaderForTypeMessage(int a1, CFTypeRef cf)
{
  CFTypeID v2;
  uint64_t result;

  v2 = CFGetTypeID(cf);
  if (v2 != FigTrackReaderGetTypeID())
    return FigSignalErrorAt();
  result = FigXPCMessageCopyCFString();
  if (!(_DWORD)result)
    return FigSignalErrorAt();
  return result;
}

uint64_t HandleTrackReaderCopyMetadataReadersMessage(int a1, CFTypeRef cf, const void *a3, void *a4)
{
  CFTypeID v7;
  uint64_t FigBaseObject;
  uint64_t (*v9)(uint64_t, const __CFString *, _QWORD, CFArrayRef *);
  uint64_t v10;
  CFIndex Count;
  uint64_t v12;
  xpc_object_t v13;
  CFIndex v14;
  CFTypeRef v15;
  uint64_t v16;
  uint64_t v17;
  CFArrayRef theArray;

  theArray = 0;
  v7 = CFGetTypeID(cf);
  if (v7 != FigTrackReaderGetTypeID())
  {
    v10 = FigSignalErrorAt();
LABEL_19:
    v17 = v10;
    goto LABEL_13;
  }
  FigBaseObject = FigTrackReaderGetFigBaseObject(cf);
  v9 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                               + 8)
                                                                                   + 48);
  if (!v9)
  {
    v17 = 4294954514;
    goto LABEL_13;
  }
  v10 = v9(FigBaseObject, CFSTR("MetadataReaders"), *MEMORY[0x1E0C9AE00], &theArray);
  if ((_DWORD)v10)
    goto LABEL_19;
  if (!theArray)
    goto LABEL_12;
  Count = CFArrayGetCount(theArray);
  if (!Count)
    goto LABEL_12;
  v12 = Count;
  v13 = xpc_array_create(0, 0);
  if (v12 < 1)
  {
LABEL_10:
    xpc_dictionary_set_value(a4, "ObjectIDArray", v13);
LABEL_12:
    v17 = 0;
    goto LABEL_13;
  }
  v14 = 0;
  while (1)
  {
    CFArrayGetValueAtIndex(theArray, v14);
    v15 = CFRetain(a3);
    v16 = FigXPCServerAssociateObjectWithConnection();
    if ((_DWORD)v16)
      break;
    xpc_array_set_uint64(v13, 0xFFFFFFFFFFFFFFFFLL, 0);
    if (v12 == ++v14)
      goto LABEL_10;
  }
  v17 = v16;
  if (v15)
    CFRelease(v15);
LABEL_13:
  FigXPCRelease();
  if (theArray)
    CFRelease(theArray);
  return v17;
}

uint64_t HandleTrackReaderCreatePrimaryEditCursorServiceMessage(int a1, CFTypeRef cf, const void *a3, void *a4)
{
  CFTypeID v7;
  uint64_t FigBaseObject;
  uint64_t (*v9)(uint64_t, const __CFString *, _QWORD, CFTypeRef *);
  uint64_t v10;
  CFTypeRef v11;
  uint64_t v12;
  CFTypeRef cfa;
  uint64_t value;

  cfa = 0;
  value = 0;
  v7 = CFGetTypeID(cf);
  if (v7 != FigTrackReaderGetTypeID())
  {
    v10 = FigSignalErrorAt();
LABEL_11:
    v12 = v10;
    goto LABEL_7;
  }
  FigBaseObject = FigTrackReaderGetFigBaseObject(cf);
  v9 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                              + 8)
                                                                                  + 48);
  if (!v9)
  {
    v12 = 4294954514;
    goto LABEL_7;
  }
  v10 = v9(FigBaseObject, CFSTR("EditCursorService"), *MEMORY[0x1E0C9AE00], &cfa);
  if ((_DWORD)v10)
    goto LABEL_11;
  v11 = CFRetain(a3);
  v12 = FigXPCServerAssociateObjectWithConnection();
  if ((_DWORD)v12)
  {
    if (v11)
      CFRelease(v11);
  }
  else
  {
    xpc_dictionary_set_uint64(a4, (const char *)*MEMORY[0x1E0CA36A0], value);
  }
LABEL_7:
  if (cfa)
    CFRelease(cfa);
  return v12;
}

uint64_t HandleTrackReaderCreateSecondaryEditCursorServiceMessage(int a1, CFTypeRef cf, const void *a3, void *a4)
{
  CFTypeID v7;
  uint64_t FigBaseObject;
  uint64_t (*v9)(uint64_t, const __CFString *, _QWORD, CFTypeRef *);
  uint64_t v10;
  CFTypeRef v11;
  uint64_t v12;
  CFTypeRef cfa;
  uint64_t value;

  cfa = 0;
  value = 0;
  v7 = CFGetTypeID(cf);
  if (v7 != FigTrackReaderGetTypeID())
  {
    v10 = FigSignalErrorAt();
LABEL_11:
    v12 = v10;
    goto LABEL_7;
  }
  FigBaseObject = FigTrackReaderGetFigBaseObject(cf);
  v9 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                              + 8)
                                                                                  + 48);
  if (!v9)
  {
    v12 = 4294954514;
    goto LABEL_7;
  }
  v10 = v9(FigBaseObject, CFSTR("SecondaryEditCursorService"), *MEMORY[0x1E0C9AE00], &cfa);
  if ((_DWORD)v10)
    goto LABEL_11;
  v11 = CFRetain(a3);
  v12 = FigXPCServerAssociateObjectWithConnection();
  if ((_DWORD)v12)
  {
    if (v11)
      CFRelease(v11);
  }
  else
  {
    xpc_dictionary_set_uint64(a4, (const char *)*MEMORY[0x1E0CA36A0], value);
  }
LABEL_7:
  if (cfa)
    CFRelease(cfa);
  return v12;
}

uint64_t HandleTrackReaderCreateSampleCursorServiceMessage(int a1, CFTypeRef cf, const void *a3, void *a4)
{
  CFTypeID v7;
  uint64_t (*v8)(CFTypeRef, CFTypeRef *);
  uint64_t v9;
  _BYTE *v10;
  _DWORD *v11;
  void (*v12)(CFTypeRef, _QWORD, _DWORD *);
  uint64_t FigBaseObject;
  void (*v14)(uint64_t, const __CFString *, _QWORD, CFTypeRef *);
  uint64_t v15;
  CFTypeRef v17;
  CFTypeRef cfa;
  uint64_t value;

  cfa = 0;
  value = 0;
  v17 = 0;
  v7 = CFGetTypeID(cf);
  if (v7 != FigTrackReaderGetTypeID())
  {
    v9 = FigSignalErrorAt();
LABEL_21:
    v15 = v9;
    goto LABEL_15;
  }
  v8 = *(uint64_t (**)(CFTypeRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
  if (!v8)
  {
    v15 = 4294954514;
    goto LABEL_15;
  }
  v9 = v8(cf, &cfa);
  if ((_DWORD)v9)
    goto LABEL_21;
  v10 = CFRetain(a3);
  v11 = v10 + 36;
  v12 = *(void (**)(CFTypeRef, _QWORD, _DWORD *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
  if (v12)
    v12(cf, 0, v11);
  if (*v11 == 1986618469)
  {
    v10[33] = 1;
  }
  else if (*v11 == 1936684398)
  {
    FigBaseObject = FigTrackReaderGetFigBaseObject(cf);
    v14 = *(void (**)(uint64_t, const __CFString *, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                              + 8)
                                                                                  + 48);
    if (v14)
    {
      v14(FigBaseObject, CFSTR("HasAudioSampleDependencyInformation"), *MEMORY[0x1E0C9AE00], &v17);
      v14 = (void (*)(uint64_t, const __CFString *, _QWORD, CFTypeRef *))v17;
    }
    v10[32] = v14 == (void (*)(uint64_t, const __CFString *, _QWORD, CFTypeRef *))*MEMORY[0x1E0C9AE50];
  }
  v15 = FigXPCServerAssociateObjectWithConnection();
  if ((_DWORD)v15)
    CFRelease(v10);
  else
    xpc_dictionary_set_uint64(a4, (const char *)*MEMORY[0x1E0CA36A0], value);
LABEL_15:
  if (cfa)
    CFRelease(cfa);
  if (v17)
    CFRelease(v17);
  return v15;
}

uint64_t HandleTrackReaderCreateCaptionCursorServiceMessage(int a1, CFTypeRef cf, const void *a3, void *a4)
{
  CFTypeID v7;
  uint64_t FigBaseObject;
  uint64_t (*v9)(uint64_t, const __CFString *, _QWORD, CFTypeRef *);
  uint64_t v10;
  CFTypeRef v11;
  uint64_t v12;
  CFTypeRef cfa;
  uint64_t value;

  cfa = 0;
  value = 0;
  v7 = CFGetTypeID(cf);
  if (v7 != FigTrackReaderGetTypeID())
  {
    v10 = FigSignalErrorAt();
LABEL_11:
    v12 = v10;
    goto LABEL_7;
  }
  FigBaseObject = FigTrackReaderGetFigBaseObject(cf);
  v9 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                              + 8)
                                                                                  + 48);
  if (!v9)
  {
    v12 = 4294954514;
    goto LABEL_7;
  }
  v10 = v9(FigBaseObject, CFSTR("CaptionSampleCursorService"), *MEMORY[0x1E0C9AE00], &cfa);
  if ((_DWORD)v10)
    goto LABEL_11;
  v11 = CFRetain(a3);
  v12 = FigXPCServerAssociateObjectWithConnection();
  if ((_DWORD)v12)
  {
    if (v11)
      CFRelease(v11);
  }
  else
  {
    xpc_dictionary_set_uint64(a4, (const char *)*MEMORY[0x1E0CA36A0], value);
  }
LABEL_7:
  if (cfa)
    CFRelease(cfa);
  return v12;
}

uint64_t HandleEditCursorServiceCreateCursorAtTrackTimeMessage(int a1, CFTypeRef cf, const void *a3, uint64_t a4, void *a5)
{
  CFTypeID v8;
  uint64_t (*v9)(CFTypeRef, __int128 *, CFTypeRef *);
  uint64_t v10;
  CFTypeRef v11;
  uint64_t v12;
  CFTypeRef cfa;
  __int128 v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;

  cfa = 0;
  v15 = *MEMORY[0x1E0CA2E18];
  v16 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  v8 = CFGetTypeID(cf);
  if (v8 != FigEditCursorServiceGetTypeID())
  {
    v10 = FigSignalErrorAt();
LABEL_11:
    v12 = v10;
    goto LABEL_7;
  }
  FigXPCMessageGetCMTime();
  v9 = *(uint64_t (**)(CFTypeRef, __int128 *, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
  if (!v9)
  {
    v12 = 4294954514;
    goto LABEL_7;
  }
  v17 = v15;
  v18 = v16;
  v10 = v9(cf, &v17, &cfa);
  if ((_DWORD)v10)
    goto LABEL_11;
  v11 = CFRetain(a3);
  v12 = FigXPCServerAssociateObjectWithConnection();
  if ((_DWORD)v12)
  {
    if (v11)
      CFRelease(v11);
  }
  else
  {
    xpc_dictionary_set_uint64(a5, (const char *)*MEMORY[0x1E0CA36A0], 0);
  }
LABEL_7:
  if (cfa)
    CFRelease(cfa);
  return v12;
}

uint64_t HandleEditCursorCopyPropertyMessage(const void *a1)
{
  CFTypeID v1;
  uint64_t result;

  v1 = CFGetTypeID(a1);
  if (v1 != FigEditCursorGetTypeID())
    return FigSignalErrorAt();
  result = FigXPCMessageCopyCFString();
  if (!(_DWORD)result)
    return FigSignalErrorAt();
  return result;
}

uint64_t HandleEditCursorCopyMessage(int a1, CFTypeRef cf, const void *a3, void *a4)
{
  CFTypeID v7;
  uint64_t (*v8)(CFTypeRef, CFTypeRef *);
  uint64_t v9;
  CFTypeRef v10;
  uint64_t v11;
  CFTypeRef cfa;

  cfa = 0;
  v7 = CFGetTypeID(cf);
  if (v7 != FigEditCursorGetTypeID())
  {
    v9 = FigSignalErrorAt();
LABEL_11:
    v11 = v9;
    goto LABEL_7;
  }
  v8 = *(uint64_t (**)(CFTypeRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
  if (!v8)
  {
    v11 = 4294954514;
    goto LABEL_7;
  }
  v9 = v8(cf, &cfa);
  if ((_DWORD)v9)
    goto LABEL_11;
  v10 = CFRetain(a3);
  v11 = FigXPCServerAssociateObjectWithConnection();
  if ((_DWORD)v11)
  {
    if (v10)
      CFRelease(v10);
  }
  else
  {
    xpc_dictionary_set_uint64(a4, (const char *)*MEMORY[0x1E0CA36A0], 0);
  }
LABEL_7:
  if (cfa)
    CFRelease(cfa);
  return v11;
}

uint64_t HandleEditCursorStepMessage(const void *a1, void *a2)
{
  CFTypeID v4;
  int64_t int64;
  uint64_t (*v6)(const void *, int64_t);

  v4 = CFGetTypeID(a1);
  if (v4 != FigEditCursorGetTypeID())
    return FigSignalErrorAt();
  int64 = xpc_dictionary_get_int64(a2, "EditCursorStepCount");
  v6 = *(uint64_t (**)(const void *, int64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 16);
  if (v6)
    return v6(a1, int64);
  else
    return 4294954514;
}

uint64_t HandleEditCursorGetEditSegmentMessage(const void *a1)
{
  CFTypeID v2;
  uint64_t (*v3)(const void *, _OWORD *);
  uint64_t result;
  _OWORD v5[6];

  memset(v5, 0, sizeof(v5));
  v2 = CFGetTypeID(a1);
  if (v2 != FigEditCursorGetTypeID())
    return FigSignalErrorAt();
  v3 = *(uint64_t (**)(const void *, _OWORD *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
  if (!v3)
    return 4294954514;
  result = v3(a1, v5);
  if (!(_DWORD)result)
    return FigXPCMessageSetCMTimeMapping();
  return result;
}

uint64_t HandleSampleCursorServiceCreateCursorAtPresentationTimeStampMessage(uint64_t a1, CFTypeRef cf, _QWORD *a3, void *a4, void *a5)
{
  CFTypeID v10;
  uint64_t CMTime;
  uint64_t (*v12)(CFTypeRef, __int128 *, CFTypeRef *, char *, __int16 *);
  CFAllocatorRef v13;
  char v14;
  uint64_t v15;
  __int16 v17;
  CFTypeRef cfa;
  uint64_t value;
  CFTypeRef v20;
  __int128 v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;

  v20 = 0;
  v21 = *MEMORY[0x1E0CA2E18];
  v22 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  cfa = 0;
  value = 0;
  v17 = 0;
  v10 = CFGetTypeID(cf);
  if (v10 != FigSampleCursorServiceGetTypeID())
  {
    CMTime = FigSignalErrorAt();
LABEL_15:
    v15 = CMTime;
    goto LABEL_9;
  }
  CMTime = FigXPCMessageGetCMTime();
  if ((_DWORD)CMTime)
    goto LABEL_15;
  v12 = *(uint64_t (**)(CFTypeRef, __int128 *, CFTypeRef *, char *, __int16 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                        + 8);
  if (!v12)
  {
    v15 = 4294954514;
    goto LABEL_9;
  }
  v23 = v21;
  v24 = v22;
  CMTime = v12(cf, &v23, &v20, (char *)&v17 + 1, &v17);
  if ((_DWORD)CMTime)
    goto LABEL_15;
  v13 = CFGetAllocator(cf);
  CMTime = FigServedSampleCursorStateCreate((uint64_t)v13, a1, a3, (uint64_t *)&cfa);
  if ((_DWORD)CMTime)
    goto LABEL_15;
  v14 = FigSampleCursorServer_obtainCacheOption(a4);
  FigSampleCursorServer_SetSampleCursorProperties((uint64_t)cfa, v20, 1, v14, MEMORY[0x1E0CA2E40], 0, a5);
  v15 = FigXPCServerAssociateObjectWithConnectionWithFlags();
  if (!(_DWORD)v15)
  {
    cfa = 0;
    xpc_dictionary_set_uint64(a5, (const char *)*MEMORY[0x1E0CA36A0], value);
    xpc_dictionary_set_BOOL(a5, "SampleCursorCreatedBeforeStart", HIBYTE(v17) != 0);
    xpc_dictionary_set_BOOL(a5, "SampleCursorCreatedAfterEnd", (_BYTE)v17 != 0);
  }
LABEL_9:
  if (cfa)
    CFRelease(cfa);
  if (v20)
    CFRelease(v20);
  return v15;
}

uint64_t HandleSampleCursorServiceCreateCursorNearPresentationTimeStampMessage(uint64_t a1, CFTypeRef cf, _QWORD *a3, void *a4, void *a5)
{
  CFTypeID v10;
  uint64_t CMTime;
  _BOOL8 v12;
  uint64_t (*v13)(CFTypeRef, __int128 *, _BOOL8, CFTypeRef *, char *, __int16 *);
  CFAllocatorRef v14;
  char v15;
  uint64_t v16;
  __int16 v18;
  CFTypeRef cfa;
  uint64_t value;
  CFTypeRef v21;
  __int128 v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;

  v21 = 0;
  v22 = *MEMORY[0x1E0CA2E18];
  v23 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  cfa = 0;
  value = 0;
  v18 = 0;
  v10 = CFGetTypeID(cf);
  if (v10 != FigSampleCursorServiceGetTypeID())
  {
    CMTime = FigSignalErrorAt();
LABEL_15:
    v16 = CMTime;
    goto LABEL_9;
  }
  CMTime = FigXPCMessageGetCMTime();
  if ((_DWORD)CMTime)
    goto LABEL_15;
  v12 = xpc_dictionary_get_BOOL(a4, "SampleCursorAllowCreationAfterPTS");
  v13 = *(uint64_t (**)(CFTypeRef, __int128 *, _BOOL8, CFTypeRef *, char *, __int16 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                + 16);
  if (!v13)
  {
    v16 = 4294954514;
    goto LABEL_9;
  }
  v24 = v22;
  v25 = v23;
  CMTime = v13(cf, &v24, v12, &v21, (char *)&v18 + 1, &v18);
  if ((_DWORD)CMTime)
    goto LABEL_15;
  v14 = CFGetAllocator(cf);
  CMTime = FigServedSampleCursorStateCreate((uint64_t)v14, a1, a3, (uint64_t *)&cfa);
  if ((_DWORD)CMTime)
    goto LABEL_15;
  v15 = FigSampleCursorServer_obtainCacheOption(a4);
  FigSampleCursorServer_SetSampleCursorProperties((uint64_t)cfa, v21, 1, v15, MEMORY[0x1E0CA2E40], 0, a5);
  v16 = FigXPCServerAssociateObjectWithConnectionWithFlags();
  if (!(_DWORD)v16)
  {
    cfa = 0;
    xpc_dictionary_set_uint64(a5, (const char *)*MEMORY[0x1E0CA36A0], value);
    xpc_dictionary_set_BOOL(a5, "SampleCursorCreatedBeforeStart", HIBYTE(v18) != 0);
    xpc_dictionary_set_BOOL(a5, "SampleCursorCreatedAfterEnd", (_BYTE)v18 != 0);
  }
LABEL_9:
  if (cfa)
    CFRelease(cfa);
  if (v21)
    CFRelease(v21);
  return v16;
}

uint64_t HandleSampleCursorServiceCreateCursorAtFirstSampleInDecodeOrderMessage(uint64_t a1, CFTypeRef cf, _QWORD *a3, void *a4, void *a5)
{
  CFTypeID v10;
  uint64_t (*v11)(CFTypeRef, CFTypeRef *);
  uint64_t v12;
  CFAllocatorRef v13;
  char v14;
  uint64_t v15;
  CFTypeRef cfa;
  uint64_t value;
  CFTypeRef v19;

  value = 0;
  v19 = 0;
  cfa = 0;
  v10 = CFGetTypeID(cf);
  if (v10 != FigSampleCursorServiceGetTypeID())
  {
    v12 = FigSignalErrorAt();
LABEL_14:
    v15 = v12;
    goto LABEL_8;
  }
  v11 = *(uint64_t (**)(CFTypeRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
  if (!v11)
  {
    v15 = 4294954514;
    goto LABEL_8;
  }
  v12 = v11(cf, &v19);
  if ((_DWORD)v12)
    goto LABEL_14;
  v13 = CFGetAllocator(cf);
  v12 = FigServedSampleCursorStateCreate((uint64_t)v13, a1, a3, (uint64_t *)&cfa);
  if ((_DWORD)v12)
    goto LABEL_14;
  v14 = FigSampleCursorServer_obtainCacheOption(a4);
  FigSampleCursorServer_SetSampleCursorProperties((uint64_t)cfa, v19, 1, v14, MEMORY[0x1E0CA2E40], 0, a5);
  v15 = FigXPCServerAssociateObjectWithConnectionWithFlags();
  if (!(_DWORD)v15)
  {
    cfa = 0;
    xpc_dictionary_set_uint64(a5, (const char *)*MEMORY[0x1E0CA36A0], value);
  }
LABEL_8:
  if (cfa)
    CFRelease(cfa);
  if (v19)
    CFRelease(v19);
  return v15;
}

uint64_t HandleSampleCursorServiceCreateCursorAtLastSampleInDecodeOrderMessage(uint64_t a1, CFTypeRef cf, _QWORD *a3, void *a4, void *a5)
{
  CFTypeID v10;
  uint64_t (*v11)(CFTypeRef, CFTypeRef *);
  uint64_t v12;
  CFAllocatorRef v13;
  char v14;
  uint64_t v15;
  CFTypeRef cfa;
  uint64_t value;
  CFTypeRef v19;

  value = 0;
  v19 = 0;
  cfa = 0;
  v10 = CFGetTypeID(cf);
  if (v10 != FigSampleCursorServiceGetTypeID())
  {
    v12 = FigSignalErrorAt();
LABEL_14:
    v15 = v12;
    goto LABEL_8;
  }
  v11 = *(uint64_t (**)(CFTypeRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
  if (!v11)
  {
    v15 = 4294954514;
    goto LABEL_8;
  }
  v12 = v11(cf, &v19);
  if ((_DWORD)v12)
    goto LABEL_14;
  v13 = CFGetAllocator(cf);
  v12 = FigServedSampleCursorStateCreate((uint64_t)v13, a1, a3, (uint64_t *)&cfa);
  if ((_DWORD)v12)
    goto LABEL_14;
  v14 = FigSampleCursorServer_obtainCacheOption(a4);
  FigSampleCursorServer_SetSampleCursorProperties((uint64_t)cfa, v19, 1, v14, MEMORY[0x1E0CA2E40], 0, a5);
  v15 = FigXPCServerAssociateObjectWithConnectionWithFlags();
  if (!(_DWORD)v15)
  {
    cfa = 0;
    xpc_dictionary_set_uint64(a5, (const char *)*MEMORY[0x1E0CA36A0], value);
  }
LABEL_8:
  if (cfa)
    CFRelease(cfa);
  if (v19)
    CFRelease(v19);
  return v15;
}

uint64_t HandleMetadataReaderCopyPropertyMessage(const void *a1)
{
  CFTypeID v1;
  uint64_t result;

  v1 = CFGetTypeID(a1);
  if (v1 != FigMetadataReaderGetTypeID())
    return FigSignalErrorAt();
  result = FigXPCMessageCopyCFString();
  if (!(_DWORD)result)
    return FigSignalErrorAt();
  return result;
}

uint64_t HandleMetadataReaderCopyValueMessage(const void *a1, void *a2, void *a3)
{
  CFTypeID v6;
  uint64_t MetadataPropertiesBinaryPListData;
  _BOOL4 v8;
  _BOOL4 v9;
  uint64_t uint64;
  uint64_t (*v11)(const void *, CFTypeRef, CFTypeRef, uint64_t, _QWORD, CFTypeRef *, CFTypeRef *);
  const __CFAllocator *v12;
  CFTypeRef *v13;
  CFTypeRef *v14;
  uint64_t v15;
  void *v16;
  const UInt8 *BytePtr;
  size_t Length;
  CFTypeRef v20;
  CFDataRef theData;
  CFTypeRef v22;
  CFTypeRef v23;
  CFTypeRef cf;

  v23 = 0;
  cf = 0;
  theData = 0;
  v22 = 0;
  v20 = 0;
  v6 = CFGetTypeID(a1);
  if (v6 != FigMetadataReaderGetTypeID())
  {
    MetadataPropertiesBinaryPListData = FigSignalErrorAt();
    goto LABEL_33;
  }
  MetadataPropertiesBinaryPListData = FigXPCMessageCopyCFString();
  if ((_DWORD)MetadataPropertiesBinaryPListData)
    goto LABEL_33;
  MetadataPropertiesBinaryPListData = FigXPCMessageCopyCFObject();
  if ((_DWORD)MetadataPropertiesBinaryPListData)
    goto LABEL_33;
  v8 = xpc_dictionary_get_BOOL(a2, "MetadataPropertiesDesired");
  v9 = xpc_dictionary_get_BOOL(a2, "MetadataValueDesired");
  uint64 = xpc_dictionary_get_uint64(a2, "MetadataValueType");
  v11 = *(uint64_t (**)(const void *, CFTypeRef, CFTypeRef, uint64_t, _QWORD, CFTypeRef *, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
  if (!v11)
  {
    v15 = 4294954514;
    goto LABEL_21;
  }
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v13 = v8 ? &v22 : 0;
  v14 = v9 ? &v20 : 0;
  MetadataPropertiesBinaryPListData = v11(a1, cf, v23, uint64, *MEMORY[0x1E0C9AE00], v14, v13);
  if ((_DWORD)MetadataPropertiesBinaryPListData)
    goto LABEL_33;
  if (!v20)
  {
    v16 = (void *)v22;
    if (!v22)
    {
LABEL_20:
      v15 = 0;
      goto LABEL_21;
    }
    goto LABEL_18;
  }
  v15 = FigXPCMessageSetCFObject();
  if (!(_DWORD)v15)
  {
    v16 = (void *)v22;
    if (v22)
    {
LABEL_18:
      MetadataPropertiesBinaryPListData = FigRemote_CreateMetadataPropertiesBinaryPListData(v16, v12, (uint64_t)&theData);
      if (!(_DWORD)MetadataPropertiesBinaryPListData)
      {
        BytePtr = CFDataGetBytePtr(theData);
        Length = CFDataGetLength(theData);
        xpc_dictionary_set_data(a3, "MetadataProperties", BytePtr, Length);
        goto LABEL_20;
      }
LABEL_33:
      v15 = MetadataPropertiesBinaryPListData;
    }
  }
LABEL_21:
  if (cf)
    CFRelease(cf);
  if (v23)
    CFRelease(v23);
  if (v20)
    CFRelease(v20);
  if (v22)
    CFRelease(v22);
  if (theData)
    CFRelease(theData);
  return v15;
}

uint64_t HandleMetadataReaderGetItemCountMessage(const void *a1, uint64_t a2, void *a3)
{
  CFTypeID v5;
  uint64_t v6;
  uint64_t (*v7)(const void *, _QWORD, _QWORD);
  int64_t v8;

  v5 = CFGetTypeID(a1);
  if (v5 != FigMetadataReaderGetTypeID())
    return FigSignalErrorAt();
  v6 = FigXPCMessageCopyCFString();
  if ((_DWORD)v6)
    return v6;
  v6 = FigXPCMessageCopyCFObject();
  if ((_DWORD)v6)
    return v6;
  v7 = *(uint64_t (**)(const void *, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 40);
  if (v7)
    v8 = v7(a1, 0, 0);
  else
    v8 = 0;
  xpc_dictionary_set_int64(a3, "MetadataItemCount", v8);
  return 0;
}

uint64_t HandleMetadataReaderCopyItemWithKeyAndIndexMessage(const void *a1, void *a2, void *a3)
{
  CFTypeID v6;
  uint64_t MetadataPropertiesBinaryPListData;
  _BOOL4 v8;
  _BOOL4 v9;
  int64_t int64;
  uint64_t (*v11)(const void *, CFTypeRef, CFTypeRef, int64_t, _QWORD, CFTypeRef *, CFTypeRef *);
  const __CFAllocator *v12;
  CFTypeRef *v13;
  CFTypeRef *v14;
  uint64_t v15;
  void *v16;
  const UInt8 *BytePtr;
  size_t Length;
  CFTypeRef v20;
  CFDataRef theData;
  CFTypeRef v22;
  CFTypeRef v23;
  CFTypeRef cf;

  v23 = 0;
  cf = 0;
  theData = 0;
  v22 = 0;
  v20 = 0;
  v6 = CFGetTypeID(a1);
  if (v6 != FigMetadataReaderGetTypeID())
  {
    MetadataPropertiesBinaryPListData = FigSignalErrorAt();
    goto LABEL_33;
  }
  MetadataPropertiesBinaryPListData = FigXPCMessageCopyCFString();
  if ((_DWORD)MetadataPropertiesBinaryPListData)
    goto LABEL_33;
  MetadataPropertiesBinaryPListData = FigXPCMessageCopyCFObject();
  if ((_DWORD)MetadataPropertiesBinaryPListData)
    goto LABEL_33;
  v8 = xpc_dictionary_get_BOOL(a2, "MetadataPropertiesDesired");
  v9 = xpc_dictionary_get_BOOL(a2, "MetadataValueDesired");
  int64 = xpc_dictionary_get_int64(a2, "MetadataItemIndex");
  v11 = *(uint64_t (**)(const void *, CFTypeRef, CFTypeRef, int64_t, _QWORD, CFTypeRef *, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 48);
  if (!v11)
  {
    v15 = 4294954514;
    goto LABEL_21;
  }
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v13 = v8 ? &v22 : 0;
  v14 = v9 ? &v20 : 0;
  MetadataPropertiesBinaryPListData = v11(a1, cf, v23, int64, *MEMORY[0x1E0C9AE00], v14, v13);
  if ((_DWORD)MetadataPropertiesBinaryPListData)
    goto LABEL_33;
  if (!v20)
  {
    v16 = (void *)v22;
    if (!v22)
    {
LABEL_20:
      v15 = 0;
      goto LABEL_21;
    }
    goto LABEL_18;
  }
  v15 = FigXPCMessageSetCFObject();
  if (!(_DWORD)v15)
  {
    v16 = (void *)v22;
    if (v22)
    {
LABEL_18:
      MetadataPropertiesBinaryPListData = FigRemote_CreateMetadataPropertiesBinaryPListData(v16, v12, (uint64_t)&theData);
      if (!(_DWORD)MetadataPropertiesBinaryPListData)
      {
        BytePtr = CFDataGetBytePtr(theData);
        Length = CFDataGetLength(theData);
        xpc_dictionary_set_data(a3, "MetadataProperties", BytePtr, Length);
        goto LABEL_20;
      }
LABEL_33:
      v15 = MetadataPropertiesBinaryPListData;
    }
  }
LABEL_21:
  if (cf)
    CFRelease(cf);
  if (v23)
    CFRelease(v23);
  if (v20)
    CFRelease(v20);
  if (v22)
    CFRelease(v22);
  if (theData)
    CFRelease(theData);
  return v15;
}

uint64_t EventLinkServerMessageHandler(uint64_t a1, uint64_t a2, OpaqueCMBlockBuffer *a3, OpaqueCMBlockBuffer *a4)
{
  uint64_t DataPointer;
  char *v8;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;

  FigOSEventLinkServerGetAssociatedFigXPCServerXPCConnection();
  lengthAtOffsetOut = 0;
  dataPointerOut = 0;
  DataPointer = CMBlockBufferGetDataPointer(a3, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
  if (!(_DWORD)DataPointer)
  {
    DataPointer = 4294949526;
    if ((dataPointerOut & 7) == 0 && lengthAtOffsetOut > 0x197)
    {
      lengthAtOffsetOut = 0;
      dataPointerOut = 0;
      DataPointer = CMBlockBufferGetDataPointer(a4, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
      if (!(_DWORD)DataPointer)
      {
        v8 = dataPointerOut;
        DataPointer = 4294949526;
        if ((dataPointerOut & 7) == 0 && lengthAtOffsetOut > 0x197)
        {
          *((_QWORD *)dataPointerOut + 50) = 0;
          *((_OWORD *)v8 + 23) = 0u;
          *((_OWORD *)v8 + 24) = 0u;
          *((_OWORD *)v8 + 21) = 0u;
          *((_OWORD *)v8 + 22) = 0u;
          *((_OWORD *)v8 + 19) = 0u;
          *((_OWORD *)v8 + 20) = 0u;
          *((_OWORD *)v8 + 17) = 0u;
          *((_OWORD *)v8 + 18) = 0u;
          *((_OWORD *)v8 + 15) = 0u;
          *((_OWORD *)v8 + 16) = 0u;
          *((_OWORD *)v8 + 13) = 0u;
          *((_OWORD *)v8 + 14) = 0u;
          *((_OWORD *)v8 + 11) = 0u;
          *((_OWORD *)v8 + 12) = 0u;
          *((_OWORD *)v8 + 9) = 0u;
          *((_OWORD *)v8 + 10) = 0u;
          *((_OWORD *)v8 + 7) = 0u;
          *((_OWORD *)v8 + 8) = 0u;
          *((_OWORD *)v8 + 5) = 0u;
          *((_OWORD *)v8 + 6) = 0u;
          *((_OWORD *)v8 + 3) = 0u;
          *((_OWORD *)v8 + 4) = 0u;
          *((_OWORD *)v8 + 1) = 0u;
          *((_OWORD *)v8 + 2) = 0u;
          *(_OWORD *)v8 = 0u;
          FigOSEventLinkServerGetAssociatedFigXPCServerXPCConnection();
          return FigXPCServerLookupAndRetainAssociatedObjectAndCFTypeRefcon();
        }
      }
    }
  }
  return DataPointer;
}

uint64_t HandleSampleCursorCopyPropertyFromEventLink(const void *a1, uint64_t a2, uint64_t a3)
{
  CFTypeID v4;
  uint64_t result;

  v4 = CFGetTypeID(a1);
  if (v4 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  if (!*(_QWORD *)(a3 + 336))
    return FigSignalErrorAt();
  result = FigInMemoryDeserializerCopyCFString();
  if (!(_DWORD)result)
    return FigSignalErrorAt();
  return result;
}

uint64_t HandleSampleCursorSetPropertyFromEventLink(const void *a1, uint64_t a2, uint64_t a3)
{
  CFTypeID v4;
  uint64_t result;

  v4 = CFGetTypeID(a1);
  if (v4 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  if (!*(_QWORD *)(a3 + 336))
    return FigSignalErrorAt();
  result = FigInMemoryDeserializerCopyCFString();
  if (!(_DWORD)result)
    return FigSignalErrorAt();
  return result;
}

uint64_t HandleSampleCursorCopyFromEventLink(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4)
{
  CFTypeID v8;
  uint64_t v9;
  CFTypeRef v11;
  CFTypeRef cfa;
  uint64_t v13;

  cfa = 0;
  v13 = 0;
  v11 = 0;
  v8 = CFGetTypeID(cf);
  if (v8 == FigSampleCursorGetTypeID())
  {
    v9 = CopySampleCursorAndReturnObjectID(a1, cf, a3, &v11, &cfa, &v13);
    if (!(_DWORD)v9)
      *(_QWORD *)(a4 + 336) = v13;
  }
  else
  {
    v9 = FigSignalErrorAt();
  }
  if (cfa)
    CFRelease(cfa);
  if (v11)
    CFRelease(v11);
  return v9;
}

uint64_t HandleSampleCursorGetSampleTimingInfoFromEventLink(const void *a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  CFTypeID v6;
  uint64_t (*v7)(const void *, char *);
  uint64_t result;
  uint64_t (*v9)(const void *, __int128 *);
  uint64_t (*v10)(const void *, __int128 *);
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v4 = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 48);
  v15 = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 32);
  v16 = v4;
  v17 = *(_QWORD *)(MEMORY[0x1E0CA2E90] + 64);
  v5 = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 16);
  v13 = *MEMORY[0x1E0CA2E90];
  v14 = v5;
  v6 = CFGetTypeID(a1);
  if (v6 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  v7 = *(uint64_t (**)(const void *, char *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 40);
  if (!v7)
    return 4294954514;
  result = v7(a1, (char *)&v14 + 8);
  if ((_DWORD)result)
    return result;
  v9 = *(uint64_t (**)(const void *, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 48);
  if (!v9)
    return 4294954514;
  result = v9(a1, &v16);
  if ((_DWORD)result)
    return result;
  v10 = *(uint64_t (**)(const void *, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
  if (!v10)
    return 4294954514;
  result = v10(a1, &v13);
  if (!(_DWORD)result)
  {
    v11 = v16;
    *(_OWORD *)(a2 + 368) = v15;
    *(_OWORD *)(a2 + 384) = v11;
    *(_QWORD *)(a2 + 400) = v17;
    v12 = v14;
    *(_OWORD *)(a2 + 336) = v13;
    *(_OWORD *)(a2 + 352) = v12;
  }
  return result;
}

uint64_t HandleSampleCursorGetSampleSyncInfoFromEventLink(const void *a1, uint64_t a2)
{
  CFTypeID v4;
  uint64_t (*v5)(const void *, char *, char *, uint64_t *, char *);
  uint64_t result;
  BOOL v7;
  uint64_t v8;

  v8 = 0;
  v4 = CFGetTypeID(a1);
  if (v4 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  v5 = *(uint64_t (**)(const void *, char *, char *, uint64_t *, char *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                             + 16)
                                                                                 + 64);
  if (!v5)
    return 4294954514;
  result = v5(a1, (char *)&v8 + 4, (char *)&v8 + 5, &v8, (char *)&v8 + 6);
  if ((_DWORD)result)
    v7 = (_DWORD)result == -12840;
  else
    v7 = 1;
  if (v7)
    *(_QWORD *)(a2 + 336) = v8;
  return result;
}

uint64_t HandleSampleCursorStepByDecodeTimeFromEventLink(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFTypeID v10;
  uint64_t v11;
  CFTypeRef v12;
  uint64_t (*v13)(CFTypeRef, __int128 *);
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  __int128 v18;
  uint64_t v19;
  CFTypeRef v20;
  CFTypeRef cfa;
  __int128 v22;
  uint64_t v23;

  v20 = a3;
  cfa = cf;
  v10 = CFGetTypeID(cf);
  if (v10 != FigSampleCursorGetTypeID())
  {
    v11 = FigSignalErrorAt();
    goto LABEL_17;
  }
  v11 = FigSampleCursorServer_ResolveCopiedCursorObjectIDForEventLinkReplyAndCopyCursorToUse(a1, &cfa, (uint64_t *)&v20, a4, a5);
  if ((_DWORD)v11)
  {
LABEL_17:
    v15 = v11;
    goto LABEL_11;
  }
  v12 = cfa;
  v18 = *(_OWORD *)(a4 + 336);
  v19 = *(_QWORD *)(a4 + 352);
  v13 = *(uint64_t (**)(CFTypeRef, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 120);
  if (v13)
  {
    v22 = v18;
    v23 = v19;
    v14 = v13(v12, &v22);
    v15 = v14;
    if ((_DWORD)v14)
      v16 = (_DWORD)v14 == -12840;
    else
      v16 = 1;
    if (v16)
    {
      *(_BYTE *)(a5 + 336) = (_DWORD)v14 == -12840;
      FigSampleCursorServer_SetSampleCursorPropertiesFromEventLink((uint64_t)v20, a6, cfa, a5);
      v15 = 0;
    }
  }
  else
  {
    v15 = 4294954514;
  }
LABEL_11:
  if (cfa)
    CFRelease(cfa);
  if (v20)
    CFRelease(v20);
  return v15;
}

uint64_t HandleSampleCursorStepByPresentationTimeFromEventLink(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFTypeID v10;
  uint64_t v11;
  CFTypeRef v12;
  uint64_t (*v13)(CFTypeRef, __int128 *);
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  __int128 v18;
  uint64_t v19;
  CFTypeRef v20;
  CFTypeRef cfa;
  __int128 v22;
  uint64_t v23;

  v20 = a3;
  cfa = cf;
  v10 = CFGetTypeID(cf);
  if (v10 != FigSampleCursorGetTypeID())
  {
    v11 = FigSignalErrorAt();
    goto LABEL_17;
  }
  v11 = FigSampleCursorServer_ResolveCopiedCursorObjectIDForEventLinkReplyAndCopyCursorToUse(a1, &cfa, (uint64_t *)&v20, a4, a5);
  if ((_DWORD)v11)
  {
LABEL_17:
    v15 = v11;
    goto LABEL_11;
  }
  v12 = cfa;
  v18 = *(_OWORD *)(a4 + 336);
  v19 = *(_QWORD *)(a4 + 352);
  v13 = *(uint64_t (**)(CFTypeRef, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 128);
  if (v13)
  {
    v22 = v18;
    v23 = v19;
    v14 = v13(v12, &v22);
    v15 = v14;
    if ((_DWORD)v14)
      v16 = (_DWORD)v14 == -12840;
    else
      v16 = 1;
    if (v16)
    {
      *(_BYTE *)(a5 + 336) = (_DWORD)v14 == -12840;
      FigSampleCursorServer_SetSampleCursorPropertiesFromEventLink((uint64_t)v20, a6, cfa, a5);
      v15 = 0;
    }
  }
  else
  {
    v15 = 4294954514;
  }
LABEL_11:
  if (cfa)
    CFRelease(cfa);
  if (v20)
    CFRelease(v20);
  return v15;
}

uint64_t HandleSampleCursorStepInDecodeOrderAndReportStepsTakenFromEventLink(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFTypeID v10;
  uint64_t v11;
  uint64_t v12;
  CFTypeRef v13;
  uint64_t (*v14)(CFTypeRef, uint64_t, uint64_t *);
  uint64_t v15;
  uint64_t v17;
  CFTypeRef v18;
  CFTypeRef cfa;

  v18 = a3;
  cfa = cf;
  v17 = 0;
  v10 = CFGetTypeID(cf);
  if (v10 != FigSampleCursorGetTypeID())
  {
    v11 = FigSignalErrorAt();
    goto LABEL_13;
  }
  v11 = FigSampleCursorServer_ResolveCopiedCursorObjectIDForEventLinkReplyAndCopyCursorToUse(a1, &cfa, (uint64_t *)&v18, a4, a5);
  if ((_DWORD)v11)
  {
LABEL_13:
    v15 = v11;
    goto LABEL_7;
  }
  v12 = *(_QWORD *)(a4 + 336);
  v13 = cfa;
  v14 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 168);
  if (v14)
  {
    v15 = v14(v13, v12, &v17);
    if (!(_DWORD)v15)
      FigSampleCursorServer_SetSampleCursorPropertiesFromEventLink((uint64_t)v18, a6, cfa, a5);
  }
  else
  {
    v15 = 4294954514;
  }
LABEL_7:
  *(_QWORD *)(a5 + 336) = v17;
  if (cfa)
    CFRelease(cfa);
  if (v18)
    CFRelease(v18);
  return v15;
}

uint64_t HandleSampleCursorStepInPresentationOrderAndReportStepsTakenFromEventLink(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFTypeID v10;
  uint64_t v11;
  uint64_t v12;
  CFTypeRef v13;
  uint64_t (*v14)(CFTypeRef, uint64_t, uint64_t *);
  uint64_t v15;
  uint64_t v17;
  CFTypeRef v18;
  CFTypeRef cfa;

  v18 = a3;
  cfa = cf;
  v17 = 0;
  v10 = CFGetTypeID(cf);
  if (v10 != FigSampleCursorGetTypeID())
  {
    v11 = FigSignalErrorAt();
    goto LABEL_13;
  }
  v11 = FigSampleCursorServer_ResolveCopiedCursorObjectIDForEventLinkReplyAndCopyCursorToUse(a1, &cfa, (uint64_t *)&v18, a4, a5);
  if ((_DWORD)v11)
  {
LABEL_13:
    v15 = v11;
    goto LABEL_7;
  }
  v12 = *(_QWORD *)(a4 + 336);
  v13 = cfa;
  v14 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 176);
  if (v14)
  {
    v15 = v14(v13, v12, &v17);
    if (!(_DWORD)v15)
      FigSampleCursorServer_SetSampleCursorPropertiesFromEventLink((uint64_t)v18, a6, cfa, a5);
  }
  else
  {
    v15 = 4294954514;
  }
LABEL_7:
  *(_QWORD *)(a5 + 336) = v17;
  if (cfa)
    CFRelease(cfa);
  if (v18)
    CFRelease(v18);
  return v15;
}

uint64_t HandleSampleCursorCompareInDecodeOrderFromEventLink(const void *a1, const void *a2, uint64_t a3)
{
  CFTypeID v6;
  CFTypeID v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t (*v11)(const void *, const void *);

  v6 = CFGetTypeID(a1);
  if (v6 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  if (!a2)
    return FigSignalErrorAt();
  v8 = CFGetTypeID(a2);
  if (v8 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  v9 = *(_QWORD *)(CMBaseObjectGetVTable() + 16);
  if (v9 == *(_QWORD *)(CMBaseObjectGetVTable() + 16)
    && (v11 = *(uint64_t (**)(const void *, const void *))(v9 + 32)) != 0)
  {
    v10 = v11(a1, a2);
  }
  else
  {
    v10 = 0;
  }
  *(_QWORD *)(a3 + 336) = v10;
  return 0;
}

uint64_t HandleSampleCursorTestReorderingBoundaryFromEventLink(const void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  CFTypeID v8;
  CFTypeID v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t (*v14)(const void *, const void *, uint64_t);

  v8 = CFGetTypeID(a1);
  if (v8 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  if (!a2)
    return FigSignalErrorAt();
  v10 = CFGetTypeID(a2);
  if (v10 != FigSampleCursorGetTypeID())
    return FigSignalErrorAt();
  v11 = *(unsigned int *)(a3 + 336);
  v12 = *(_QWORD *)(CMBaseObjectGetVTable() + 16);
  if (v12 == *(_QWORD *)(CMBaseObjectGetVTable() + 16)
    && (v14 = *(uint64_t (**)(const void *, const void *, uint64_t))(v12 + 80)) != 0)
  {
    v13 = v14(a1, a2, v11);
  }
  else
  {
    v13 = 0;
  }
  *(_BYTE *)(a4 + 336) = v13;
  return 0;
}

uint64_t HandleSampleCursorCopySampleLocationFromEventLink(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFTypeID v8;
  uint64_t (*v9)(const void *, __int128 *, char *, CFTypeRef *, CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  __int128 v13;
  CFTypeRef cf;
  CFTypeRef v15;

  cf = 0;
  v15 = 0;
  v13 = 0uLL;
  v8 = CFGetTypeID(a1);
  if (v8 != FigSampleCursorGetTypeID())
  {
    v10 = FigSignalErrorAt();
LABEL_7:
    v11 = v10;
    goto LABEL_9;
  }
  v9 = *(uint64_t (**)(const void *, __int128 *, char *, CFTypeRef *, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                            + 144);
  if (v9)
  {
    v10 = v9(a1, &v13, (char *)&v13 + 8, &v15, &cf);
    if (!(_DWORD)v10)
    {
      *(_OWORD *)(a3 + 24) = 0u;
      *(_OWORD *)(a3 + 296) = 0u;
      *(_OWORD *)(a3 + 312) = 0u;
      *(_OWORD *)(a3 + 264) = 0u;
      *(_OWORD *)(a3 + 280) = 0u;
      *(_OWORD *)(a3 + 232) = 0u;
      *(_OWORD *)(a3 + 248) = 0u;
      *(_OWORD *)(a3 + 200) = 0u;
      *(_OWORD *)(a3 + 216) = 0u;
      *(_OWORD *)(a3 + 168) = 0u;
      *(_OWORD *)(a3 + 184) = 0u;
      *(_OWORD *)(a3 + 136) = 0u;
      *(_OWORD *)(a3 + 152) = 0u;
      *(_OWORD *)(a3 + 104) = 0u;
      *(_OWORD *)(a3 + 120) = 0u;
      *(_OWORD *)(a3 + 72) = 0u;
      *(_OWORD *)(a3 + 88) = 0u;
      *(_OWORD *)(a3 + 40) = 0u;
      *(_OWORD *)(a3 + 56) = 0u;
      *(_QWORD *)(a3 + 368) = 0;
      *(_OWORD *)(a3 + 352) = 0u;
      *(_OWORD *)(a3 + 336) = v13;
      if (!v15
        || (v10 = FigSampleCursorServer_TranslateByteStream(v10, (uint64_t)v15, (_QWORD *)(a3 + 352)), !(_DWORD)v10))
      {
        v10 = FigSampleCursorServer_TranslateDataSourceFromEventLink(a2, *(_QWORD *)(a2 + 48), cf, a3, 0, a4, (_QWORD *)(a3 + 360), (_QWORD *)(a3 + 368));
      }
    }
    goto LABEL_7;
  }
  v11 = 4294954514;
LABEL_9:
  if (cf)
    CFRelease(cf);
  if (v15)
    CFRelease(v15);
  return v11;
}

uint64_t HandleSampleCursorCopyChunkDetailsFromEventLink(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFTypeID v8;
  uint64_t (*v9)(const void *, CFTypeRef *, CFTypeRef *, __int128 *, char *, __int128 *, uint64_t *, char *, char *, char *);
  uint64_t v10;
  uint64_t v11;
  __int128 v13;
  __int128 v14;
  CFTypeRef cf;
  CFTypeRef v16;
  uint64_t v17;

  v17 = 0;
  cf = 0;
  v16 = 0;
  v8 = CFGetTypeID(a1);
  if (v8 != FigSampleCursorGetTypeID())
  {
    v10 = FigSignalErrorAt();
LABEL_7:
    v11 = v10;
    goto LABEL_9;
  }
  v14 = 0uLL;
  v13 = 0uLL;
  v9 = *(uint64_t (**)(const void *, CFTypeRef *, CFTypeRef *, __int128 *, char *, __int128 *, uint64_t *, char *, char *, char *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 152);
  if (v9)
  {
    v10 = v9(a1, &v16, &cf, &v14, (char *)&v14 + 8, &v13, &v17, (char *)&v13 + 8, (char *)&v13 + 9, (char *)&v13 + 10);
    if (!(_DWORD)v10)
    {
      *(_OWORD *)(a3 + 24) = 0u;
      *(_OWORD *)(a3 + 296) = 0u;
      *(_OWORD *)(a3 + 312) = 0u;
      *(_OWORD *)(a3 + 264) = 0u;
      *(_OWORD *)(a3 + 280) = 0u;
      *(_OWORD *)(a3 + 232) = 0u;
      *(_OWORD *)(a3 + 248) = 0u;
      *(_OWORD *)(a3 + 200) = 0u;
      *(_OWORD *)(a3 + 216) = 0u;
      *(_OWORD *)(a3 + 168) = 0u;
      *(_OWORD *)(a3 + 184) = 0u;
      *(_OWORD *)(a3 + 136) = 0u;
      *(_OWORD *)(a3 + 152) = 0u;
      *(_OWORD *)(a3 + 104) = 0u;
      *(_OWORD *)(a3 + 120) = 0u;
      *(_OWORD *)(a3 + 72) = 0u;
      *(_OWORD *)(a3 + 88) = 0u;
      *(_OWORD *)(a3 + 40) = 0u;
      *(_OWORD *)(a3 + 56) = 0u;
      *(_OWORD *)(a3 + 368) = 0u;
      *(_OWORD *)(a3 + 384) = 0u;
      *(_OWORD *)(a3 + 336) = v14;
      *(_OWORD *)(a3 + 352) = v13;
      *(_QWORD *)(a3 + 368) = v17;
      if (!v16
        || (v10 = FigSampleCursorServer_TranslateByteStream(v10, (uint64_t)v16, (_QWORD *)(a3 + 376)), !(_DWORD)v10))
      {
        v10 = FigSampleCursorServer_TranslateDataSourceFromEventLink(a2, *(_QWORD *)(a2 + 48), cf, a3, 0, a4, (_QWORD *)(a3 + 384), (_QWORD *)(a3 + 392));
      }
    }
    goto LABEL_7;
  }
  v11 = 4294954514;
LABEL_9:
  if (cf)
    CFRelease(cf);
  if (v16)
    CFRelease(v16);
  return v11;
}

uint64_t HandleSampleCursorCopyFormatDescriptionFromEventLink(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFTypeID v8;
  uint64_t (*v9)(const void *, CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  CFTypeRef cf;

  cf = 0;
  v8 = CFGetTypeID(a1);
  if (v8 != FigSampleCursorGetTypeID())
  {
    v10 = FigSignalErrorAt();
LABEL_5:
    v11 = v10;
    goto LABEL_7;
  }
  v9 = *(uint64_t (**)(const void *, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 160);
  if (v9)
  {
    v10 = v9(a1, &cf);
    if (!(_DWORD)v10)
    {
      *(_OWORD *)(a3 + 248) = 0u;
      *(_OWORD *)(a3 + 232) = 0u;
      *(_OWORD *)(a3 + 216) = 0u;
      *(_OWORD *)(a3 + 200) = 0u;
      *(_OWORD *)(a3 + 184) = 0u;
      *(_OWORD *)(a3 + 168) = 0u;
      *(_OWORD *)(a3 + 152) = 0u;
      *(_OWORD *)(a3 + 136) = 0u;
      *(_OWORD *)(a3 + 120) = 0u;
      *(_OWORD *)(a3 + 104) = 0u;
      *(_OWORD *)(a3 + 88) = 0u;
      *(_OWORD *)(a3 + 72) = 0u;
      *(_OWORD *)(a3 + 56) = 0u;
      *(_OWORD *)(a3 + 40) = 0u;
      *(_OWORD *)(a3 + 24) = 0u;
      *(_OWORD *)(a3 + 296) = 0u;
      *(_OWORD *)(a3 + 312) = 0u;
      *(_OWORD *)(a3 + 264) = 0u;
      *(_OWORD *)(a3 + 280) = 0u;
      *(_QWORD *)(a3 + 336) = 0;
      *(_QWORD *)(a3 + 344) = 0;
      v10 = FigSampleCursorServer_TranslateFormatDescriptionFromEventLink(a2, *(_QWORD *)(a2 + 48), cf, a3, a4, (_QWORD *)(a3 + 336), (_QWORD *)(a3 + 344));
    }
    goto LABEL_5;
  }
  v11 = 4294954514;
LABEL_7:
  if (cf)
    CFRelease(cf);
  return v11;
}

uint64_t HandleSampleCursorCreateSampleBufferFromEventLink(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFTypeID v7;
  uint64_t (*v8)(const void *, uint64_t, CFTypeRef *);
  uint64_t v9;
  uint64_t v10;
  uint64_t appended;
  CFTypeRef v13;

  v13 = 0;
  v7 = CFGetTypeID(a1);
  if (v7 == FigSampleCursorGetTypeID())
  {
    v8 = *(uint64_t (**)(const void *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 112);
    if (!v8)
    {
      appended = 4294954514;
      goto LABEL_6;
    }
    v9 = v8(a1, a2, &v13);
    if (!(_DWORD)v9)
    {
      *(_OWORD *)(a4 + 24) = 0u;
      v10 = a4 + 24;
      *(_OWORD *)(v10 + 272) = 0u;
      *(_OWORD *)(v10 + 288) = 0u;
      *(_OWORD *)(v10 + 240) = 0u;
      *(_OWORD *)(v10 + 256) = 0u;
      *(_OWORD *)(v10 + 208) = 0u;
      *(_OWORD *)(v10 + 224) = 0u;
      *(_OWORD *)(v10 + 176) = 0u;
      *(_OWORD *)(v10 + 192) = 0u;
      *(_OWORD *)(v10 + 144) = 0u;
      *(_OWORD *)(v10 + 160) = 0u;
      *(_OWORD *)(v10 + 112) = 0u;
      *(_OWORD *)(v10 + 128) = 0u;
      *(_OWORD *)(v10 + 80) = 0u;
      *(_OWORD *)(v10 + 96) = 0u;
      *(_OWORD *)(v10 + 48) = 0u;
      *(_OWORD *)(v10 + 64) = 0u;
      *(_OWORD *)(v10 + 16) = 0u;
      *(_OWORD *)(v10 + 32) = 0u;
      *(_QWORD *)(v10 + 312) = 0;
      appended = FigInMemorySerializerAppendCMSampleBuffer();
      goto LABEL_6;
    }
  }
  else
  {
    v9 = FigSignalErrorAt();
  }
  appended = v9;
LABEL_6:
  if (v13)
    CFRelease(v13);
  return appended;
}

uint64_t HandleSampleCursorGetBatchSampleTimingAndSizesFromEventLink(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFTypeID v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t *v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t BatchSampleTimingAndSizes;
  unint64_t v16;
  unint64_t v17;
  CFAllocatorRef *v18;
  __CFData *Mutable;
  __CFData *v20;
  UInt8 *MutableBytePtr;
  __CFData *v22;
  __CFData *v23;
  UInt8 *v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t appended;
  uint64_t v29;

  v9 = CFGetTypeID(a1);
  if (v9 == FigSampleCursorGetTypeID())
  {
    v10 = *(_QWORD *)(a4 + 336);
    *(_QWORD *)(a5 + 368) = 0;
    *(_OWORD *)(a5 + 336) = 0u;
    *(_OWORD *)(a5 + 352) = 0u;
    v11 = (unint64_t *)(a5 + 352);
    v12 = (unint64_t *)(a5 + 360);
    if (*(_BYTE *)(a4 + 344))
      v13 = (uint64_t *)(a5 + 360);
    else
      v13 = 0;
    if (*(_BYTE *)(a4 + 345))
      v14 = (uint64_t *)(a5 + 352);
    else
      v14 = 0;
    BatchSampleTimingAndSizes = FigSampleCursorUtilityGetBatchSampleTimingAndSizes((uint64_t)a1, v10, a2, 0, v13, 0, v14, 0);
    if ((_DWORD)BatchSampleTimingAndSizes)
      return BatchSampleTimingAndSizes;
    v16 = *v12;
    if (*v12 <= v10)
    {
      v17 = *v11;
      if (*v11 <= v10)
      {
        v18 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
        if (!v17)
        {
          MutableBytePtr = 0;
          v20 = 0;
          if (v16)
            goto LABEL_14;
          goto LABEL_17;
        }
        Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 8 * v17);
        if (Mutable)
        {
          v20 = Mutable;
          CFDataSetLength(Mutable, 8 * *v11);
          MutableBytePtr = CFDataGetMutableBytePtr(v20);
          v16 = *v12;
          if (*v12)
          {
LABEL_14:
            v22 = CFDataCreateMutable(*v18, 72 * v16);
            v23 = v22;
            if (!v22)
            {
              v27 = FigSignalErrorAt();
              goto LABEL_31;
            }
            CFDataSetLength(v22, 72 * *v12);
            v24 = CFDataGetMutableBytePtr(v23);
LABEL_18:
            if (*(_BYTE *)(a4 + 344))
              v25 = (uint64_t *)(a5 + 360);
            else
              v25 = 0;
            if (*(_BYTE *)(a4 + 345))
              v26 = (uint64_t *)(a5 + 352);
            else
              v26 = 0;
            v27 = FigSampleCursorUtilityGetBatchSampleTimingAndSizes((uint64_t)a1, v10, a2, (uint64_t *)(a5 + 368), v25, (uint64_t)v24, v26, (uint64_t)MutableBytePtr);
            if (!(_DWORD)v27)
            {
              if (v20)
              {
                appended = FigInMemorySerializerAppendCFType();
                v29 = appended;
                if (!v23 || (_DWORD)appended)
                {
LABEL_32:
                  CFRelease(v20);
LABEL_33:
                  if (v23)
                    CFRelease(v23);
                  return v29;
                }
                goto LABEL_30;
              }
              if (v23)
              {
LABEL_30:
                v27 = FigInMemorySerializerAppendCFType();
                goto LABEL_31;
              }
              return 0;
            }
LABEL_31:
            v29 = v27;
            if (!v20)
              goto LABEL_33;
            goto LABEL_32;
          }
LABEL_17:
          v24 = 0;
          v23 = 0;
          goto LABEL_18;
        }
      }
    }
  }
  return FigSignalErrorAt();
}

uint64_t FigSampleCursorServer_TranslateSampleDependencyAttributesFromEventLink(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7, _QWORD *a8)
{
  uint64_t result;
  char v11;
  uint64_t v12;
  uint64_t v13;

  v12 = 0;
  v13 = 0;
  v11 = 0;
  result = FigPartialSampleTableOutOfBandObjectRegistryLookupOrMakeIDForObjectOfType(*(_QWORD *)(a1 + 24), CFSTR("SampleDependencyAttributes"), a3, &v13, &v11);
  if (!(_DWORD)result)
  {
    if (v11)
    {
      result = FigInMemorySerializerAppendCFType();
      if ((_DWORD)result)
        return result;
      if (!a7)
        goto LABEL_6;
    }
    else
    {
      v12 = 0;
      if (!a7)
      {
LABEL_6:
        result = 0;
        if (a8)
          *a8 = v12;
        return result;
      }
    }
    *a7 = v13;
    goto LABEL_6;
  }
  return result;
}

uint64_t FigSampleCursorServer_ResolveCopiedCursorObjectIDForEventLinkReplyAndCopyCursorToUse(uint64_t a1, const void **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v10;
  CFTypeRef v11;
  CFTypeRef cf;

  v11 = 0;
  cf = 0;
  v10 = 0;
  if (*(_BYTE *)(a4 + 328))
  {
    v8 = CopySampleCursorAndReturnObjectID(a1, *a2, *a3, &cf, &v11, &v10);
    if (!(_DWORD)v8)
    {
      *a2 = cf;
      *a3 = (uint64_t)v11;
      *(_QWORD *)(a5 + 328) = v10;
    }
  }
  else
  {
    v8 = 0;
    *(_QWORD *)(a5 + 328) = 0;
    if (!a2)
      goto LABEL_7;
  }
  if (*a2)
    CFRetain(*a2);
LABEL_7:
  if (a3 && *a3)
    CFRetain((CFTypeRef)*a3);
  if (cf)
    CFRelease(cf);
  if (v11)
    CFRelease(v11);
  return v8;
}

void FigSampleCursorServer_SetSampleCursorPropertiesFromEventLink(uint64_t a1, uint64_t a2, CFTypeRef cf, uint64_t a4)
{
  CFTypeID v8;
  unsigned int (*v9)(CFTypeRef, char *);
  unsigned int (*v10)(CFTypeRef, __int128 *);
  unsigned int (*v11)(CFTypeRef, __int128 *);
  void (*v12)(CFTypeRef, char *, char *, _QWORD, char *);
  __int128 v13;
  __int128 v14;
  void (*v15)(CFTypeRef, CFTypeRef *);
  CFTypeRef v16;
  uint64_t FigBaseObject;
  void (*v18)(uint64_t, const __CFString *, _QWORD, CFTypeRef *);
  uint64_t (*v19)(CFTypeRef, __int128 *, char *, CFTypeRef *, const void **);
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  void (*v27)(CFTypeRef, uint64_t, uint64_t);
  void (*v28)(CFTypeRef, char *, char *, _QWORD, char *);
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  CFTypeRef v34;
  CFTypeRef cfa;
  __int128 v36;
  const void *v37;
  CFTypeRef v38;

  v37 = 0;
  v38 = 0;
  v36 = 0uLL;
  v34 = 0;
  cfa = 0;
  v8 = CFGetTypeID(cf);
  if (v8 != FigSampleCursorGetTypeID())
  {
    FigSignalErrorAt();
    goto LABEL_35;
  }
  *(_OWORD *)(a4 + 24) = 0u;
  *(_OWORD *)(a4 + 296) = 0u;
  *(_OWORD *)(a4 + 312) = 0u;
  *(_OWORD *)(a4 + 264) = 0u;
  *(_OWORD *)(a4 + 280) = 0u;
  *(_OWORD *)(a4 + 232) = 0u;
  *(_OWORD *)(a4 + 248) = 0u;
  *(_OWORD *)(a4 + 200) = 0u;
  *(_OWORD *)(a4 + 216) = 0u;
  *(_OWORD *)(a4 + 168) = 0u;
  *(_OWORD *)(a4 + 184) = 0u;
  *(_OWORD *)(a4 + 136) = 0u;
  *(_OWORD *)(a4 + 152) = 0u;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_OWORD *)(a4 + 72) = 0u;
  *(_OWORD *)(a4 + 88) = 0u;
  *(_OWORD *)(a4 + 40) = 0u;
  *(_OWORD *)(a4 + 56) = 0u;
  v33 = 0;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v9 = *(unsigned int (**)(CFTypeRef, char *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 40);
  if (v9)
  {
    if (!v9(cf, (char *)&v30 + 8))
    {
      v10 = *(unsigned int (**)(CFTypeRef, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 48);
      if (v10)
      {
        if (!v10(cf, &v32))
        {
          v11 = *(unsigned int (**)(CFTypeRef, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
          if (v11)
          {
            if (!v11(cf, &v29))
            {
              v28 = 0;
              if (*(_BYTE *)(*(_QWORD *)(a1 + 16) + 32)
                && *(_QWORD *)(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 64))
              {
                v12 = *(void (**)(CFTypeRef, char *, char *, _QWORD, char *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                       + 64);
                if (v12)
                {
                  v12(cf, (char *)&v28 + 4, (char *)&v28 + 5, &v28, (char *)&v28 + 6);
                  v12 = v28;
                }
                *(_QWORD *)(a4 + 96) = v12;
              }
              v13 = v32;
              *(_OWORD *)(a4 + 56) = v31;
              *(_OWORD *)(a4 + 72) = v13;
              *(_QWORD *)(a4 + 88) = v33;
              v14 = v30;
              *(_OWORD *)(a4 + 24) = v29;
              *(_OWORD *)(a4 + 40) = v14;
              v15 = *(void (**)(CFTypeRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 160);
              if (v15)
              {
                v15(cf, &cfa);
                v16 = cfa;
              }
              else
              {
                v16 = 0;
              }
              *(_QWORD *)(a4 + 104) = 0;
              if (!FigSampleCursorServer_TranslateFormatDescriptionFromEventLink(a1, *(_QWORD *)(a1 + 48), v16, a4, a2, (_QWORD *)(a4 + 104), (_QWORD *)(a4 + 144)))
              {
                *(_QWORD *)(a4 + 152) = 0;
                *(_QWORD *)(a4 + 112) = 0;
                *(_QWORD *)(a4 + 120) = 0;
                *(_QWORD *)(a4 + 168) = 0;
                if (*(_BYTE *)(a1 + 32))
                {
                  FigBaseObject = FigSampleCursorGetFigBaseObject(cf);
                  v18 = *(void (**)(uint64_t, const __CFString *, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                                + 48);
                  if (v18 && (v18(FigBaseObject, CFSTR("SampleDependencyAttributes"), *MEMORY[0x1E0C9AE00], &v34), v34))
                  {
                    if (FigSampleCursorServer_TranslateSampleDependencyAttributesFromEventLink(a1, *(_QWORD *)(a1 + 48), v34, a4, *(_QWORD *)(a4 + 144), a2, (_QWORD *)(a4 + 112), (_QWORD *)(a4 + 152)))goto LABEL_35;
                  }
                  else
                  {
                    *(_QWORD *)(a4 + 112) = -1;
                  }
                }
                if (*(_QWORD *)(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 144))
                {
                  v19 = *(uint64_t (**)(CFTypeRef, __int128 *, char *, CFTypeRef *, const void **))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 144);
                  if (v19)
                  {
                    v20 = v19(cf, &v36, (char *)&v36 + 8, &v38, &v37);
                    v21 = (uint64_t)v38;
                    *(_OWORD *)(a4 + 128) = v36;
                    if (v21 && FigSampleCursorServer_TranslateByteStream(v20, v21, (_QWORD *)(a4 + 168)))
                      goto LABEL_35;
                  }
                  else
                  {
                    *(_OWORD *)(a4 + 128) = v36;
                  }
                  if (FigSampleCursorServer_TranslateDataSourceFromEventLink(a1, *(_QWORD *)(a1 + 48), v37, a4, *(_QWORD *)(a4 + 152) + *(_QWORD *)(a4 + 144), a2, (_QWORD *)(a4 + 120), (_QWORD *)(a4 + 160)))goto LABEL_35;
                }
                v23 = *(_OWORD *)(MEMORY[0x1E0CA2E40] + 16);
                v22 = *(_OWORD *)(MEMORY[0x1E0CA2E40] + 32);
                *(_OWORD *)(a4 + 176) = *MEMORY[0x1E0CA2E40];
                *(_OWORD *)(a4 + 192) = v23;
                v24 = MEMORY[0x1E0CA2E18];
                v25 = *MEMORY[0x1E0CA2E18];
                *(_OWORD *)(a4 + 208) = v22;
                *(_OWORD *)(a4 + 224) = v25;
                v26 = *(_QWORD *)(v24 + 16);
                *(_QWORD *)(a4 + 240) = v26;
                *(_OWORD *)(a4 + 248) = v25;
                *(_QWORD *)(a4 + 264) = v26;
                *(_BYTE *)(a4 + 272) = 0;
                *(_QWORD *)(a4 + 292) = v26;
                *(_OWORD *)(a4 + 276) = v25;
                *(_QWORD *)(a4 + 316) = v26;
                *(_OWORD *)(a4 + 300) = v25;
                if (*(_DWORD *)(*(_QWORD *)(a1 + 16) + 36) != 1936684398)
                {
                  FigSampleCursorUtilityGetPresentationTimeRange(cf, (_OWORD *)(a4 + 176));
                  if (*(_QWORD *)(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 200))
                  {
                    v27 = *(void (**)(CFTypeRef, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                             + 200);
                    if (v27)
                      v27(cf, a4 + 224, a4 + 248);
                  }
                  FigSampleCursorUtilityGetMinimumUpcomingPresentationTime((uint64_t)cf, 0, (CMTime *)(a4 + 276), (CMTime *)(a4 + 300));
                  *(_BYTE *)(a4 + 272) = 1;
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_35:
  if (v37)
    CFRelease(v37);
  if (v38)
    CFRelease(v38);
  if (cfa)
    CFRelease(cfa);
  if (v34)
    CFRelease(v34);
}

uint64_t FigSampleCursorServer_TranslateFormatDescriptionFromEventLink(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, _QWORD *a6, _QWORD *a7)
{
  uint64_t result;
  char v10;
  uint64_t v11;
  uint64_t v12;

  v11 = 0;
  v12 = 0;
  v10 = 0;
  result = FigPartialSampleTableOutOfBandObjectRegistryLookupOrMakeIDForObjectOfType(*(_QWORD *)(a1 + 24), CFSTR("FormatDescription"), a3, &v12, &v10);
  if (!(_DWORD)result)
  {
    if (!v12)
      return FigSignalErrorAt();
    if (v10)
    {
      result = FigInMemorySerializerAppendCMFormatDescription();
      if ((_DWORD)result)
        return result;
      if (!a6)
        goto LABEL_7;
    }
    else
    {
      v11 = 0;
      if (!a6)
      {
LABEL_7:
        result = 0;
        if (a7)
          *a7 = v11;
        return result;
      }
    }
    *a6 = v12;
    goto LABEL_7;
  }
  return result;
}

uint64_t FigSampleCursorServer_TranslateDataSourceFromEventLink(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7, _QWORD *a8)
{
  uint64_t result;
  char v11;
  uint64_t v12;
  uint64_t v13;

  v12 = 0;
  v13 = 0;
  if (!a3)
    goto LABEL_6;
  v11 = 0;
  result = FigPartialSampleTableOutOfBandObjectRegistryLookupOrMakeIDForObjectOfType(*(_QWORD *)(a1 + 24), CFSTR("DataSourceURL"), a3, &v13, &v11);
  if ((_DWORD)result)
    return result;
  if (!v13)
    return FigSignalErrorAt();
  if (v11)
  {
    result = FigInMemorySerializerAppendCFURL();
    if ((_DWORD)result)
      return result;
LABEL_6:
    if (!a7)
      goto LABEL_8;
    goto LABEL_7;
  }
  v12 = 0;
  if (a7)
LABEL_7:
    *a7 = v13;
LABEL_8:
  result = 0;
  if (a8)
    *a8 = v12;
  return result;
}

uint64_t FigRemote_CreateEditArrayData(size_t a1, uint64_t a2, const __CFAllocator *a3, __CFData **a4)
{
  uint64_t v7;
  CFURLRef *v8;
  CFURLRef *v9;
  uint64_t v10;
  CFURLRef *v11;
  const __CFURL **v12;
  uint64_t v13;
  const __CFURL *v14;
  const __CFString *v15;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  CFURLRef *v18;
  _DWORD *v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  const __CFString *v23;
  UInt8 *v24;
  UInt8 *v25;
  int v26;
  __CFData *v27;
  uint64_t v28;
  CFTypeRef *v29;
  __CFData *v31;
  CFURLRef *v32;
  __CFData **v33;
  _BYTE v34[32];
  _BYTE v35[32];
  CFIndex usedBufLen;
  CFRange v37;
  CFRange v38;
  CFRange v39;

  v7 = a1;
  v8 = (CFURLRef *)malloc_type_calloc(a1, 8uLL, 0x6004044C4A2DFuLL);
  usedBufLen = 0;
  if (!v8)
    return FigSignalErrorAt();
  v9 = v8;
  if (v7 < 1)
  {
    v27 = 0;
  }
  else
  {
    v33 = a4;
    v10 = 0;
    v11 = (CFURLRef *)(a2 + 96);
    v12 = v8;
    v13 = v7;
    do
    {
      if (*v11)
      {
        v14 = CFURLCopyAbsoluteURL(*v11);
        *v12 = v14;
        if (!v14)
          goto LABEL_23;
        v15 = CFURLGetString(v14);
        v37.length = CFStringGetLength(v15);
        v37.location = 0;
        CFStringGetBytes(v15, v37, 0x8000100u, 0x2Au, 0, 0, 0, &usedBufLen);
        v10 += usedBufLen + (-(char)usedBufLen & 3);
      }
      ++v12;
      v11 = (CFURLRef *)((char *)v11 + 108);
      --v13;
    }
    while (v13);
    Mutable = CFDataCreateMutable(a3, v10 + 104 * v7);
    CFDataSetLength(Mutable, v10 + 104 * v7);
    if (!Mutable)
    {
LABEL_23:
      v28 = FigSignalErrorAt();
      goto LABEL_17;
    }
    v31 = Mutable;
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    v18 = v9;
    v19 = (_DWORD *)(a2 + 104);
    v32 = v18;
    v20 = v7;
    do
    {
      *(_QWORD *)v35 = *((_QWORD *)v19 - 5);
      *(_QWORD *)&v35[24] = *((_QWORD *)v19 - 2);
      *(_OWORD *)&v35[8] = *((_OWORD *)v19 - 2);
      v21 = *(_OWORD *)(v19 - 26);
      *(_QWORD *)v34 = *((_QWORD *)v19 - 11);
      *(_QWORD *)&v34[24] = *((_QWORD *)v19 - 8);
      *(_OWORD *)&v34[8] = *((_OWORD *)v19 - 5);
      v22 = *(_OWORD *)(v19 - 14);
      *((_OWORD *)MutableBytePtr + 2) = *(_OWORD *)&v34[16];
      *((_OWORD *)MutableBytePtr + 3) = v22;
      *((_OWORD *)MutableBytePtr + 4) = *(_OWORD *)v35;
      *((_OWORD *)MutableBytePtr + 5) = *(_OWORD *)&v35[16];
      *(_OWORD *)MutableBytePtr = v21;
      *((_OWORD *)MutableBytePtr + 1) = *(_OWORD *)v34;
      if (*((_QWORD *)v19 - 1))
      {
        v23 = CFURLGetString(*v18);
        v38.length = CFStringGetLength(v23);
        v38.location = 0;
        CFStringGetBytes(v23, v38, 0x8000100u, 0x2Au, 0, 0, 0, &usedBufLen);
        *((_DWORD *)MutableBytePtr + 24) = usedBufLen;
        v24 = MutableBytePtr + 100;
        v39.length = CFStringGetLength(v23);
        v39.location = 0;
        CFStringGetBytes(v23, v39, 0x8000100u, 0x2Au, 0, v24, usedBufLen, 0);
        v25 = &v24[usedBufLen + (-(char)usedBufLen & 3)];
      }
      else
      {
        *((_DWORD *)MutableBytePtr + 24) = 0;
        v25 = MutableBytePtr + 100;
      }
      v26 = *v19;
      v19 += 27;
      *(_DWORD *)v25 = v26;
      MutableBytePtr = v25 + 4;
      ++v18;
      --v20;
    }
    while (v20);
    v9 = v32;
    a4 = v33;
    v27 = v31;
  }
  v28 = 0;
  *a4 = v27;
LABEL_17:
  if (v7 >= 1)
  {
    v29 = (CFTypeRef *)v9;
    do
    {
      if (*v29)
        CFRelease(*v29);
      ++v29;
      --v7;
    }
    while (v7);
  }
  free(v9);
  return v28;
}

uint64_t FigRemote_CreateEditArrayFromData(const UInt8 *a1, unint64_t a2, CFAllocatorRef alloc, uint64_t a4, uint64_t a5)
{
  const UInt8 *v5;
  uint64_t v6;
  _DWORD *v8;
  CFIndex v9;
  unint64_t v10;
  uint64_t v11;
  const UInt8 *v12;
  const __CFString *v13;
  const __CFString *v14;
  int v15;
  __int128 v17;
  _BYTE v18[32];
  _BYTE v19[32];

  if (!a4)
    return 0;
  v5 = a1;
  if (a1)
  {
    if (a2)
    {
      v6 = a4;
      if (a4 >= 1)
      {
        v8 = (_DWORD *)(a5 + 104);
        while (a2 >= 0x68)
        {
          *(_OWORD *)v19 = *((_OWORD *)v5 + 4);
          *(_OWORD *)&v19[16] = *((_OWORD *)v5 + 5);
          v17 = *(_OWORD *)v5;
          *(_OWORD *)v18 = *((_OWORD *)v5 + 1);
          *(_OWORD *)&v18[16] = *((_OWORD *)v5 + 2);
          *(_OWORD *)(v8 - 14) = *((_OWORD *)v5 + 3);
          *((_QWORD *)v8 - 5) = *(_QWORD *)v19;
          *((_OWORD *)v8 - 2) = *(_OWORD *)&v19[8];
          *((_QWORD *)v8 - 2) = *(_QWORD *)&v19[24];
          *((_QWORD *)v8 - 11) = *(_QWORD *)v18;
          *(_OWORD *)(v8 - 26) = v17;
          *((_QWORD *)v8 - 8) = *(_QWORD *)&v18[24];
          *((_OWORD *)v8 - 5) = *(_OWORD *)&v18[8];
          v9 = *((unsigned int *)v5 + 24);
          v10 = a2 - 100;
          v11 = (-(int)v9 & 3) + v9;
          if (a2 - 100 < v11 + 4)
            break;
          v12 = v5 + 100;
          if ((_DWORD)v9)
          {
            v13 = CFStringCreateWithBytes(alloc, v12, v9, 0x8000100u, 0);
            if (!v13)
              return FigSignalErrorAt();
            v14 = v13;
            *((_QWORD *)v8 - 1) = CFURLCreateWithString(alloc, v13, 0);
            CFRelease(v14);
            if (!*((_QWORD *)v8 - 1))
              return FigSignalErrorAt();
            v12 += v11;
            v10 -= v11;
          }
          else
          {
            *((_QWORD *)v8 - 1) = 0;
          }
          v15 = *(_DWORD *)v12;
          v5 = v12 + 4;
          *v8 = v15;
          v8 += 27;
          a2 = v10 - 4;
          if (!--v6)
          {
            if (v10 != 4)
              return FigSignalErrorAt();
            return 0;
          }
        }
      }
    }
  }
  return FigSignalErrorAt();
}

const __CFArray *FigMutableCompositionClientServer_CreateFlattenedFormatDescriptionReplacementTable(const __CFArray *cf, __CFArray **a2)
{
  const __CFArray *v3;
  CFTypeID v4;
  CFIndex Count;
  uint64_t v6;
  __CFArray *Mutable;
  CFIndex v8;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v10;
  CFTypeID v11;
  const void *Value;
  const void *v13;
  const void *v14;
  const void *v15;

  v3 = cf;
  if (!cf)
  {
    *a2 = 0;
    return v3;
  }
  v4 = CFGetTypeID(cf);
  if (v4 == CFArrayGetTypeID())
  {
    Count = CFArrayGetCount(v3);
    if (Count)
    {
      v6 = Count;
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2 * Count, MEMORY[0x1E0C9B378]);
      if (v6 < 1)
      {
LABEL_11:
        v3 = 0;
        *a2 = Mutable;
      }
      else
      {
        v8 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v3, v8);
          if (!ValueAtIndex)
            break;
          v10 = ValueAtIndex;
          v11 = CFGetTypeID(ValueAtIndex);
          if (v11 != CFDictionaryGetTypeID())
            break;
          Value = CFDictionaryGetValue(v10, CFSTR("MutableCompositionFormatDescriptionReplacementTableKey_OldFormatDescription"));
          if (!Value)
            break;
          v13 = Value;
          v14 = CFDictionaryGetValue(v10, CFSTR("MutableCompositionFormatDescriptionReplacementTableKey_NewFormatDescription"));
          if (!v14)
            break;
          v15 = v14;
          CFArrayAppendValue(Mutable, v13);
          CFArrayAppendValue(Mutable, v15);
          if (v6 == ++v8)
            goto LABEL_11;
        }
        v3 = (const __CFArray *)FigSignalErrorAt();
        if (Mutable)
          CFRelease(Mutable);
      }
    }
    else
    {
      *a2 = v3;
      CFRetain(v3);
      return 0;
    }
    return v3;
  }
  return (const __CFArray *)FigSignalErrorAt();
}

uint64_t FigMutableCompositionClientServer_CreateUnflattenedFormatDescriptionReplacementTable(void *a1, CFMutableArrayRef *a2)
{
  CFTypeID v4;
  CFIndex Count;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const __CFAllocator *v9;
  CFMutableArrayRef Mutable;
  __CFArray *v11;
  CFMutableDictionaryRef v12;
  CFIndex v13;
  const void *ValueAtIndex;
  const void *v15;

  if (!a1)
  {
    *a2 = 0;
    return 0;
  }
  v4 = CFGetTypeID(a1);
  if (v4 == CFArrayGetTypeID() && (CFArrayGetCount((CFArrayRef)a1) & 1) == 0)
  {
    Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 0)
      v6 = Count;
    else
      v6 = Count + 1;
    if ((unint64_t)(Count + 1) > 2)
    {
      v7 = Count;
      v8 = v6 >> 1;
      v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6 >> 1, MEMORY[0x1E0C9B378]);
      v11 = Mutable;
      if (v7 <= 1)
      {
        *a2 = Mutable;
      }
      else
      {
        v12 = 0;
        v13 = 1;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v13 - 1);
          v15 = CFArrayGetValueAtIndex((CFArrayRef)a1, v13);
          if (v12)
            CFRelease(v12);
          v12 = CFDictionaryCreateMutable(v9, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          CFDictionarySetValue(v12, CFSTR("MutableCompositionFormatDescriptionReplacementTableKey_OldFormatDescription"), ValueAtIndex);
          CFDictionarySetValue(v12, CFSTR("MutableCompositionFormatDescriptionReplacementTableKey_NewFormatDescription"), v15);
          CFArrayAppendValue(v11, v12);
          v13 += 2;
          --v8;
        }
        while (v8);
        *a2 = v11;
        if (v12)
          CFRelease(v12);
      }
    }
    else
    {
      *a2 = (CFMutableArrayRef)a1;
      CFRetain(a1);
    }
    return 0;
  }
  return FigSignalErrorAt();
}

uint64_t FigBytePumpCreateForHTTPChunk(const void *a1, const __CFURL *a2, const void *a3, const __CFDictionary *a4, NSObject *a5, uint64_t a6, uint64_t a7, _QWORD *a8)
{
  const __CFURL *v10;
  uint64_t v12;
  uint64_t DerivedStorage;
  uint64_t v14;
  uint64_t v15;
  int IsItOKToLogURLs;
  const void **v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const __CFDictionary *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  CFTypeRef v27;
  uint64_t v28;
  const __CFDictionary *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  CFTypeRef v35;
  char v36;
  const void *v37;
  const void *v38;
  const void *v39;
  const void *v40;
  const __CFDictionary *v41;
  const void *v42;
  const __CFDictionary *v43;
  CFMutableDictionaryRef *v44;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  int v49;
  int v50;
  double v51;
  double v52;
  double v53;
  double v54;
  int v55;
  int v56;
  uint64_t v57;
  char *v58;
  CFMutableDictionaryRef *v59;
  const __CFArray *v60;
  const __CFArray *v61;
  CFTypeID v62;
  CFIndex Count;
  CFIndex v64;
  CFIndex i;
  const void *ValueAtIndex;
  CFTypeID v67;
  uint64_t v68;
  CFTypeRef *v69;
  const __CFAllocator *AllocatorForMedia;
  CFMutableDictionaryRef Mutable;
  uint64_t v72;
  double v73;
  double v74;
  double v75;
  int v76;
  const void *v77;
  CFNumberRef v78;
  double v79;
  double v80;
  uint64_t v81;
  uint64_t j;
  uint64_t *v83;
  const __CFAllocator *v84;
  const __CFDictionary *v85;
  const void *v86;
  CFTypeRef v87;
  uint64_t v88;
  void (*v89)(uint64_t, __CFString *, CFTypeRef);
  int v90;
  unsigned __int8 v91;
  int v92;
  unsigned int v93;
  int v94;
  int v95;
  int v96;
  uint64_t v97;
  int v98;
  uint64_t *v99;
  uint64_t inited;
  NSObject *Local;
  uint64_t v102;
  const __CFURL *v103;
  const __CFDictionary *v104;
  const __CFDictionary **v105;
  uint64_t v106;
  CFTypeRef v107;
  const void *v108;
  const void *v109;
  const void *v110;
  const void *v111;
  const void *v112;
  const void *v113;
  const void *v114;
  CFTypeID v115;
  const void *v116;
  CFTypeID v117;
  const void *v118;
  CFTypeID v119;
  const void *v120;
  CFTypeID v121;
  const void *v122;
  CFTypeID v123;
  const __CFDictionary *v124;
  const __CFAllocator *v125;
  CFMutableDictionaryRef v126;
  __CFDictionary *v127;
  const void *v128;
  const void *v129;
  uint64_t k;
  __CFString **v131;
  const void *v132;
  const void *v133;
  const __CFDictionary *v134;
  const __CFDictionary *v135;
  const void *v136;
  uint64_t *v137;
  uint64_t v138;
  CFStringRef v139;
  CFStringRef v140;
  void (*v141)(uint64_t, __CFString *, __CFString *, CFStringRef, _QWORD);
  uint64_t v142;
  void (*v143)(uint64_t, __CFString *, const void *);
  uint64_t v144;
  uint64_t v145;
  BOOL v146;
  double v147;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v149;
  unsigned int v150;
  const __CFString *v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  const void *v155;
  const void *v156;
  void *v157;
  char v159;
  const __CFDictionary *v160;
  const __CFURL *v164;
  CFTypeRef cf;
  uint64_t v166;
  const void *v167;
  void *v168;
  const void *v169;
  uint64_t value;
  const void *valuea;
  _OWORD v172[14];
  char v173;
  int valuePtr;
  const void *v175;
  unsigned int v176;
  _BYTE v177[24];
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  double v186;
  BOOL v187;
  __int128 v188;
  __int128 v189;
  _BYTE v190[31];
  __int128 context;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  uint64_t v205;

  v205 = *MEMORY[0x1E0C80C00];
  valuePtr = -1;
  v173 = 0;
  if (!a2 || !a6 || !a8)
    return FigSignalErrorAt();
  v10 = a2;
  v175 = 0;
  cf = FigCFHTTPCreateURLString(a2);
  CFPreferencesSynchronize(CFSTR("com.apple.coremedia"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B230]);
  FigNote_AllowInternalDefaultLogs();
  fig_note_initialize_category_with_default_work_cf();
  fig_note_initialize_category_with_default_work_cf();
  MTEnableCaption2015Behavior();
  FigBytePumpGetClassID();
  v12 = CMDerivedObjectCreate();
  if ((_DWORD)v12)
    goto LABEL_25;
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v14 = FigRetainProxyCreate();
  if ((_DWORD)v14)
    goto LABEL_43;
  v15 = DerivedStorage + 7904;
  if (a1)
    *(_QWORD *)(DerivedStorage + 56) = CFRetain(a1);
  *(_BYTE *)(DerivedStorage + 9032) = 1;
  IsItOKToLogURLs = FigIsItOKToLogURLs();
  *(_BYTE *)(DerivedStorage + 339) = IsItOKToLogURLs;
  v17 = (const void **)MEMORY[0x1E0C9AE50];
  if (!a4)
  {
    v19 = (const void *)*MEMORY[0x1E0C9AE50];
    goto LABEL_53;
  }
  v18 = CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_InheritURIQueryComponentFromReferencingURI"));
  v19 = *v17;
  *(_BYTE *)(DerivedStorage + 320) = v18 == *v17;
  v20 = CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_HTTPRequestOptions"));
  if (v20)
  {
    v21 = (const __CFDictionary *)CFRetain(v20);
    *(_QWORD *)(DerivedStorage + 240) = v21;
    if (v21)
    {
      v22 = CFDictionaryGetValue(v21, CFSTR("FHRP_InterfaceName"));
      if (v22)
        v22 = CFRetain(v22);
      *(_QWORD *)(DerivedStorage + 8880) = v22;
      v23 = CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 240), CFSTR("FHRP_ClientAuditToken"));
      if (v23)
        v23 = CFRetain(v23);
      *(_QWORD *)(DerivedStorage + 8888) = v23;
      *(_QWORD *)(DerivedStorage + 8896) = FigCFHTTPCopyClientProcessName((const __CFData *)v23);
      v24 = CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 240), CFSTR("FHRP_StorageSession"));
      if (v24)
        v24 = CFRetain(v24);
      *(_QWORD *)(DerivedStorage + 32) = v24;
    }
  }
  else
  {
    *(_QWORD *)(DerivedStorage + 240) = 0;
  }
  v25 = CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_OutOfBandAlternateTracks"));
  if (v25)
    v25 = CFRetain(v25);
  *(_QWORD *)(DerivedStorage + 8384) = v25;
  v26 = CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_StreamingCache"));
  if (v26)
  {
    v27 = CFRetain(v26);
    *(_QWORD *)(DerivedStorage + 296) = v27;
    if (v27)
    {
      CMNotificationCenterGetDefaultLocalCenter();
      v12 = FigNotificationCenterAddWeakListener();
      if ((_DWORD)v12)
      {
LABEL_25:
        v28 = v12;
LABEL_238:
        v37 = cf;
        goto LABEL_239;
      }
    }
  }
  else
  {
    *(_QWORD *)(DerivedStorage + 296) = 0;
  }
  v29 = (const __CFDictionary *)CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_CPECryptors"));
  if (!v29
    || (context = (unint64_t)DerivedStorage,
        CFDictionaryApplyFunction(v29, (CFDictionaryApplierFunction)segPumpSetupInitialCryptorApplierFunction, &context),
        v28 = DWORD2(context),
        !DWORD2(context)))
  {
    *(_BYTE *)(DerivedStorage + 324) = v19 == CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_DisallowCellularAccess"));
    *(_BYTE *)(DerivedStorage + 325) = v19 == CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_DisallowsExpensiveNetworkAccess"));
    *(_BYTE *)(DerivedStorage + 326) = v19 == CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_DisallowsConstrainedNetworkAccess"));
    v30 = CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_iTunesRentalID"));
    if (v30)
      v30 = CFRetain(v30);
    *(_QWORD *)(DerivedStorage + 9448) = v30;
    v31 = CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_iTunesAccountID"));
    if (v31)
      v31 = CFRetain(v31);
    *(_QWORD *)(DerivedStorage + 9456) = v31;
    v32 = CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_PrimarySessionID"));
    if (v32)
      v32 = CFRetain(v32);
    *(_QWORD *)(DerivedStorage + 232) = v32;
    v33 = CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_CustomURLLoader"));
    if (v33)
      v33 = CFRetain(v33);
    *(_QWORD *)(DerivedStorage + 80) = v33;
    v34 = CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_DefaultContentKeySession"));
    if (v34)
    {
      v35 = CFRetain(v34);
      *(_QWORD *)(DerivedStorage + 9472) = v35;
      if (v35)
      {
        if (FigCFDictionaryGetBooleanIfPresent())
          v36 = v173 == 0;
        else
          v36 = PKDIsContentKeyBossEnabled();
        *(_BYTE *)(DerivedStorage + 9480) = v36;
        v38 = CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_ContentKeyBoss"));
        if (v38)
          v38 = CFRetain(v38);
        *(_QWORD *)(DerivedStorage + 9488) = v38;
        *(_BYTE *)(DerivedStorage + 327) = CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_DisableNativeHTTPReads")) == v19;
        v39 = CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_ParentNetworkActivity"));
        if (v39)
          v39 = CFRetain(v39);
        *(_QWORD *)(DerivedStorage + 9104) = v39;
        if (v19 == CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_DoNotLogURLs")))
        {
          *(_BYTE *)(DerivedStorage + 339) = 0;
          v169 = (const void *)*MEMORY[0x1E0C9AE40];
          goto LABEL_56;
        }
        IsItOKToLogURLs = *(unsigned __int8 *)(DerivedStorage + 339);
LABEL_53:
        v169 = (const void *)*MEMORY[0x1E0C9AE40];
        v40 = v19;
        if (IsItOKToLogURLs)
        {
LABEL_57:
          v14 = segPumpSetHTTPRequestOptionsValue(DerivedStorage, CFSTR("FHRP_OKToLogURLs"), v40);
          if (!(_DWORD)v14)
          {
            v14 = segPumpSetHTTPRequestOptionsValue(DerivedStorage, CFSTR("FHRP_NetworkHistory"), *(const void **)(DerivedStorage + 88));
            if (!(_DWORD)v14)
            {
              FigNetworkUrgencyMonitorCreate((uint64_t)a1, (uint64_t *)(DerivedStorage + 9512));
              if (a4)
              {
                v41 = (const __CFDictionary *)CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_AlternativeConfigurationOptions"));
                if (v41)
                {
                  FigCFDictionaryGetBooleanIfPresent();
                  v159 = 0;
                  goto LABEL_64;
                }
              }
              else
              {
                v41 = 0;
              }
              v159 = 1;
LABEL_64:
              v42 = CFDictionaryGetValue(a4, CFSTR("FBPCreateOption_StoreBagSessionConfiguration"));
              if (v42)
              {
                v43 = (const __CFDictionary *)CFRetain(v42);
                v44 = (CFMutableDictionaryRef *)(DerivedStorage + 9128);
                *(_QWORD *)(DerivedStorage + 9128) = v43;
                if (v43)
                  goto LABEL_69;
              }
              else
              {
                v44 = (CFMutableDictionaryRef *)(DerivedStorage + 9128);
                *(_QWORD *)(DerivedStorage + 9128) = 0;
              }
              FigRCLCreateConfiguration(*(const void **)(DerivedStorage + 8896), CFSTR("kFigRemoteConfigurationLoaderStoreBagType_Pump"), v41, v44);
              v43 = *(const __CFDictionary **)(DerivedStorage + 9128);
LABEL_69:
              v45 = FigRCLGetNumberWithDefault(v43, CFSTR("networkHistoryPredictorAlgorithm"));
              LODWORD(v46) = v45 & ~(v45 >> 31);
              if (v46 >= 8)
                v46 = 8;
              else
                v46 = v46;
              *(_QWORD *)(DerivedStorage + 112) = v46;
              v47 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("networkHistoryLowLatencyPredictorAlgorithm"));
              LODWORD(v48) = v47 & ~(v47 >> 31);
              if (v48 >= 8)
                v48 = 8;
              else
                v48 = v48;
              *(_QWORD *)(DerivedStorage + 104) = v48;
              v49 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("networkHistorySecondaryPredictorAlgorithm"));
              if (v49 >= 8)
                v50 = 8;
              else
                v50 = v49;
              *(_QWORD *)(DerivedStorage + 120) = v50;
              *(_QWORD *)(DerivedStorage + 128) = (int)FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("minBytesForGlobalNetworkHistoryPrediction"));
              *(_QWORD *)(DerivedStorage + 136) = (int)FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("minActiveNetworkTimeForGlobalNetworkHistoryPrediction"));
              *(_QWORD *)(DerivedStorage + 144) = (int)FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("networkHistoryPredictorReportingInterval"));
              *(_DWORD *)(DerivedStorage + 7944) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("minReserveSegments"));
              *(_DWORD *)(DerivedStorage + 7976) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("highSegmentLatencyThresholdForRTCReporting"));
              *(double *)(DerivedStorage + 7984) = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("minDownloadTimerInterval"));
              *(double *)(DerivedStorage + 8056) = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("fastStartBandwidthAddend"));
              v51 = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("fastStartBandwidthMultiplier"));
              if (v51 < 1.0)
                v51 = 1.0;
              *(double *)(DerivedStorage + 8048) = v51;
              v52 = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("slowDownloadBufferMaximum"));
              if (v52 < 0.0)
                v52 = 0.0;
              *(double *)(DerivedStorage + 8024) = v52;
              v53 = (double)(int)FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("fastStartTargetDurationPercentage"))/ 100.0;
              if (v53 < 0.1)
                v53 = 0.1;
              *(double *)(DerivedStorage + 8040) = v53;
              v54 = (double)(int)FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("startTargetDurationPercentage"))/ 100.0;
              if (v54 < 0.2)
                v54 = 0.2;
              *(double *)(DerivedStorage + 8032) = v54;
              *(_BYTE *)(DerivedStorage + 7993) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("allowAverageBandwidth")) != 0;
              *(_BYTE *)(DerivedStorage + 8009) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("halveExpectedSwitchBandwidthWhenAudioIsActive")) != 0;
              *(_BYTE *)(DerivedStorage + 8010) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("issueLowBandwidthAlertWhenNWPathUpdates")) != 0;
              *(_BYTE *)(DerivedStorage + 8012) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("allowDownloadPerfReports")) != 0;
              *(_BYTE *)(DerivedStorage + 9584) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("enableHTTP3Connection")) != 0;
              *(_BYTE *)(DerivedStorage + 9632) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("disableHSHPBuffering")) != 0;
              v55 = MGGetSInt32Answer();
              v56 = MGGetSInt32Answer();
              value = DerivedStorage;
              v166 = DerivedStorage + 7904;
              v164 = v10;
              v160 = v41;
              if (v55 >= 1 && v56 >= 1)
              {
                v57 = 0;
                if (v55 >= v56)
                  v55 = v56;
                *(_QWORD *)&context = DerivedStorage + 192;
                *((_QWORD *)&context + 1) = DerivedStorage + 200;
                *(_QWORD *)&v192 = DerivedStorage + 208;
                v168 = (void *)v19;
                v58 = (char *)&unk_1932FD160;
                do
                {
                  v59 = v44;
                  v60 = (const __CFArray *)FigRCLCopyCFType(*v44, off_1E2FA71B8[v57]);
                  v61 = v60;
                  if (v60)
                  {
                    v62 = CFGetTypeID(v60);
                    if (v62 == CFArrayGetTypeID())
                    {
                      Count = CFArrayGetCount(v61);
                      v176 = 0;
                      *(_DWORD *)v177 = 0;
                      if (Count >= 1)
                      {
                        v64 = Count;
                        for (i = 0; i != v64; ++i)
                        {
                          ValueAtIndex = CFArrayGetValueAtIndex(v61, i);
                          if (!ValueAtIndex)
                            break;
                          v67 = CFGetTypeID(ValueAtIndex);
                          if (v67 != CFDictionaryGetTypeID())
                            break;
                          if (!FigCFDictionaryGetInt32IfPresent())
                            break;
                          if (!FigCFDictionaryGetInt32IfPresent())
                            break;
                        }
                      }
                    }
                  }
                  v68 = 0;
                  while (v55 > dword_1932FD14C[v68])
                  {
                    if (++v68 == 5)
                      goto LABEL_109;
                  }
                  if (*(int *)&v58[v68 * 4] >= 1)
                  {
                    v69 = (CFTypeRef *)*((_QWORD *)&context + v57);
                    if (*v69)
                      CFRelease(*v69);
                    AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
                    Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                    *v69 = Mutable;
                    if (Mutable)
                    {
                      FigCFDictionarySetInt32();
                      CFDictionaryAddValue((CFMutableDictionaryRef)*v69, CFSTR("FBPBTK_IsSetByStoreBag"), v169);
                    }
                  }
LABEL_109:
                  if (v61)
                    CFRelease(v61);
                  ++v57;
                  v58 += 20;
                  v44 = v59;
                }
                while (v57 != 3);
                v15 = v166;
                v10 = v164;
                DerivedStorage = value;
                v19 = v168;
              }
              *(double *)(DerivedStorage + 8080) = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("extraTargetDurationsReqToSwitchSecsAhead"));
              FigGetCFPreferenceDoubleWithDefault();
              *(_QWORD *)(DerivedStorage + 8080) = v72;
              *(_DWORD *)(DerivedStorage + 8088) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("switchUpWalkBackMode"));
              FigGetCFPreferenceDoubleWithDefault();
              *(_DWORD *)(DerivedStorage + 8088) = (int)v73;
              *(_BYTE *)(v15 + 288) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("budgetSwitchBackDownWhenCurveKnown"));
              FigGetCFPreferenceDoubleWithDefault();
              *(_BYTE *)(v15 + 288) = (int)v74;
              FigGetCFPreferenceDoubleWithDefault();
              *(_BYTE *)(v15 + 289) = (int)v75;
              v76 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("enableQUIC"));
              if (v76 != -1)
              {
                if (v76 == 1)
                  v77 = v19;
                else
                  v77 = v169;
                segPumpSetHTTPRequestOptionsValue(DerivedStorage, CFSTR("FHRP_EnableQUIC"), v77);
              }
              valuePtr = FigGetCFPreferenceNumberWithDefault();
              if (valuePtr != -1
                || (valuePtr = FigRCLGetNumberWithDefault(*v44, CFSTR("connectionCacheCellPurgeTimeout")), valuePtr != -1))
              {
                v78 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
                segPumpSetHTTPRequestOptionsValue(DerivedStorage, CFSTR("FHRP_ConnectionCacheCellPurgeTimeout"), v78);
                if (v78)
                  CFRelease(v78);
              }
              v79 = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("averageBWSwitchUpSafetyMargin"));
              *(double *)(DerivedStorage + 8064) = v79;
              v80 = 0.0;
              if (v79 < 0.0 || (v80 = 5.0, v79 > 5.0))
                *(double *)(DerivedStorage + 8064) = v80;
              *(_DWORD *)(DerivedStorage + 8072) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("increaseBitsRequiredToSwitchVODSecsBackMargin"));
              if (*(_QWORD *)(DerivedStorage + 9128))
              {
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, (uint64_t)CFSTR("networkPredictorCoefPredictionTimeInterval"), (__CFArray **)(DerivedStorage + 9136));
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, (uint64_t)CFSTR("networkPredictorCoefBandwidth"), (__CFArray **)(DerivedStorage + 9144));
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, (uint64_t)CFSTR("networkPredictorCoefBandwidthRelativeStdDev"), (__CFArray **)(DerivedStorage + 9152));
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, (uint64_t)CFSTR("networkPredictorCoefBandwidthStdError"), (__CFArray **)(DerivedStorage + 9160));
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, (uint64_t)CFSTR("networkPredictorCoefLatency"), (__CFArray **)(DerivedStorage + 9176));
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, (uint64_t)CFSTR("networkPredictorCoefLatencyRelativeStdDev"), (__CFArray **)(DerivedStorage + 9184));
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, (uint64_t)CFSTR("networkPredictorCoefLatencyStdError"), (__CFArray **)(DerivedStorage + 9192));
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, (uint64_t)CFSTR("networkPredictorCoefActiveNetworkTime"), (__CFArray **)(DerivedStorage + 9200));
                segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(DerivedStorage, (uint64_t)CFSTR("networkPredictorCoefBandwidthRelativeStdDev"), (__CFArray **)(DerivedStorage + 9168));
                *(double *)(DerivedStorage + 9208) = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("networkPredictorCoefKonstant"));
              }
              *(_DWORD *)(DerivedStorage + 8212) = FigGetCFPreferenceNumberWithDefault();
              *(_BYTE *)(v15 + 1681) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("enablePeriodicBandwidthReporting")) != 0;
              *(_BYTE *)(DerivedStorage + 334) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("enablePairedLLABR"));
              *(_BYTE *)(DerivedStorage + 334) = FigGetCFPreferenceNumberWithDefault();
              v81 = DerivedStorage + 4056;
              for (j = 392; j != 440; j += 16)
              {
                v83 = (uint64_t *)(DerivedStorage + j);
                *(v83 - 1) = v81 - 3624;
                *v83 = v81;
                v81 += 1208;
              }
              *(_QWORD *)(*(_QWORD *)(DerivedStorage + 384) + 16) = CFRetain(v10);
              *(_QWORD *)(*(_QWORD *)(DerivedStorage + 384) + 8) = CFRetain(v10);
              *(_QWORD *)(*(_QWORD *)(DerivedStorage + 384) + 24) = CFRetain(v10);
              *(_QWORD *)(DerivedStorage + 160) = a6;
              *(_QWORD *)(DerivedStorage + 176) = FigRetainProxyRetain();
              *(_QWORD *)(DerivedStorage + 8704) = 0x3FF0000000000000;
              *(_DWORD *)(DerivedStorage + 8696) = 1065353216;
              *(_WORD *)(v15 + 93) = 257;
              *(_DWORD *)(DerivedStorage + 8664) = 0;
              *(_WORD *)(DerivedStorage + 322) = 257;
              *(_WORD *)(v15 + 272) = 257;
              *(_BYTE *)(v15 + 336) = 1;
              *(_QWORD *)(DerivedStorage + 8200) = 0x4034000000000000;
              *(_BYTE *)v15 = 1;
              *(_BYTE *)(DerivedStorage + 330) = 1;
              v84 = (const __CFAllocator *)FigGetAllocatorForMedia();
              *(_QWORD *)(DerivedStorage + 8760) = CFStringCreateWithFormat(v84, 0, CFSTR("%p"), v175);
              *(_BYTE *)(v15 + 96) = 1;
              v14 = segPumpSetupNetworkHistory(DerivedStorage);
              if (!(_DWORD)v14)
              {
                *(_QWORD *)(DerivedStorage + 352) = 0;
                *(_QWORD *)(DerivedStorage + 360) = DerivedStorage + 352;
                *(_QWORD *)(DerivedStorage + 8096) = 0;
                *(_QWORD *)(DerivedStorage + 8104) = DerivedStorage + 8096;
                *(_QWORD *)(DerivedStorage + 8112) = 0;
                *(_QWORD *)(DerivedStorage + 8120) = DerivedStorage + 8112;
                segPumpClearStatistics(DerivedStorage);
                if (a3)
                {
                  v85 = (const __CFDictionary *)CFRetain(a3);
                  *(_QWORD *)(DerivedStorage + 216) = v85;
                  if (v85)
                  {
                    v86 = CFDictionaryGetValue(v85, CFSTR("X-Playback-Session-Id"));
                    v87 = v86 ? CFRetain(v86) : 0;
                    *(_QWORD *)(DerivedStorage + 224) = v87;
                    v88 = *(_QWORD *)(DerivedStorage + 96);
                    v89 = *(void (**)(uint64_t, __CFString *, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                              + 8)
                                                                                  + 56);
                    if (v89)
                      v89(v88, CFSTR("NetworkPredictorProperty_CMSessionID"), v87);
                  }
                }
                else
                {
                  *(_QWORD *)(DerivedStorage + 216) = 0;
                }
                *(_QWORD *)(DerivedStorage + 368) = -1;
                v90 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(DerivedStorage + 9128), CFSTR("maxParallelConnectionCount"));
                v91 = 0;
                if (v90 <= 1)
                  v92 = 1;
                else
                  v92 = v90;
                if (v92 >= 6)
                  v93 = 6;
                else
                  v93 = v92;
                if (v93 >= 2)
                  v91 = FigRCLGetNumberWithDefault(*v44, CFSTR("startWithSingleConnection"));
                v94 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(value + 9128), CFSTR("maxReadAheadConnectionCount"));
                if (v94 >= 5)
                  v95 = 5;
                else
                  v95 = v94;
                v96 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(value + 9128), CFSTR("maxStepAheadConnectionCount"));
                v97 = 0;
                if (v95 >= v96)
                  v98 = v96;
                else
                  v98 = v95;
                v99 = (uint64_t *)(value + 392);
                do
                {
                  inited = segPumpStreamInitStorage(value, *(v99 - 1), v97, v93, v95, v98, v91);
                  if ((_DWORD)inited
                    || (inited = segPumpStreamInitStorage(value, *v99, v97, v93, v95, v98, v91), (_DWORD)inited))
                  {
                    v28 = inited;
                    goto LABEL_44;
                  }
                  ++v97;
                  v99 += 2;
                }
                while (v97 != 3);
                if (a5)
                {
                  Local = FigHTTPSchedulerRetain(a5);
                  v102 = value;
                  *(_QWORD *)(value + 64) = Local;
                  v103 = v164;
                  v104 = v160;
                }
                else
                {
                  Local = FigHTTPSchedulerCreateLocal(v175);
                  v102 = value;
                  *(_QWORD *)(value + 64) = Local;
                  v103 = v164;
                  v104 = v160;
                  if (!Local)
                  {
                    Local = FigHTTPSchedulerRetain(0);
                    *(_QWORD *)(value + 64) = Local;
                  }
                }
                *(_QWORD *)(v102 + 72) = FigHTTPSchedulerRetain(Local);
                *(_BYTE *)(v102 + 48) = 1;
                v105 = v44;
                v106 = v102;
                if (*(_QWORD *)(v102 + 32)
                  || (v107 = FigURLStorageSessionCopyGlobalSession(), (*(_QWORD *)(v102 + 32) = v107) != 0))
                {
                  *(_QWORD *)(v102 + 312) = CFRetain(v103);
                  *(_QWORD *)(v102 + 9120) = FigNetworkInterfaceReporterCreate();
                  if ((v159 & 1) != 0)
                  {
                    v108 = 0;
                    v109 = 0;
                    v110 = 0;
                    v111 = 0;
                    v112 = 0;
                    v113 = 0;
                  }
                  else
                  {
                    v114 = CFDictionaryGetValue(v104, CFSTR("ServiceIdentifier"));
                    if (!v114 || (v108 = v114, v115 = CFGetTypeID(v114), v115 != CFStringGetTypeID()))
                      v108 = 0;
                    v116 = CFDictionaryGetValue(v104, CFSTR("StorefrontID"));
                    if (!v116 || (v109 = v116, v117 = CFGetTypeID(v116), v117 != CFStringGetTypeID()))
                      v109 = 0;
                    v118 = CFDictionaryGetValue(v104, CFSTR("MediaIdentifier"));
                    if (!v118 || (v111 = v118, v119 = CFGetTypeID(v118), v119 != CFStringGetTypeID()))
                      v111 = 0;
                    v120 = CFDictionaryGetValue(v104, CFSTR("ContentProvider"));
                    if (!v120 || (v112 = v120, v121 = CFGetTypeID(v120), v121 != CFStringGetTypeID()))
                      v112 = 0;
                    v122 = CFDictionaryGetValue(v104, CFSTR("ServiceInformationKey"));
                    if (!v122 || (v113 = v122, v123 = CFGetTypeID(v122), v123 != CFDictionaryGetTypeID()))
                      v113 = 0;
                    v110 = CFDictionaryGetValue(v104, CFSTR("HierarchyToken"));
                  }
                  v124 = *v105;
                  v125 = (const __CFAllocator *)FigGetAllocatorForMedia();
                  v126 = CFDictionaryCreateMutable(v125, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                  if (v126)
                  {
                    v127 = v126;
                    v167 = v110;
                    valuea = v112;
                    v128 = v111;
                    v129 = v109;
                    for (k = 0; k != 13; ++k)
                    {
                      v131 = featureOptionsList[k];
                      v132 = FigRCLCopyCFType(v124, *v131);
                      if (v132)
                      {
                        v133 = v132;
                        CFDictionarySetValue(v127, *v131, v132);
                        CFRelease(v133);
                      }
                    }
                    v134 = FigRCLCopyConfigurationGroupName(v124);
                    if (v134)
                    {
                      v135 = v134;
                      CFDictionarySetValue(v127, CFSTR("configurationGroup"), v134);
                      CFRelease(v135);
                    }
                    v136 = CFDictionaryGetValue(*(CFDictionaryRef *)(v106 + 240), CFSTR("FHRP_ClientBundleIdentifier"));
                    if (v128)
                      CFDictionarySetValue(v127, CFSTR("MediaIdentifier"), v128);
                    if (valuea)
                      CFDictionarySetValue(v127, CFSTR("ContentProvider"), valuea);
                    if (v129)
                      CFDictionarySetValue(v127, CFSTR("StorefrontID"), v129);
                    if (v113)
                      CFDictionarySetValue(v127, CFSTR("ServiceInformationKey"), v113);
                    v137 = (uint64_t *)(v106 + 9048);
                    if (!FigReportingAgentCreate(*(const void **)(v106 + 224), *(const void **)(v106 + 8896), v108, v167, v136, 1, v127, *(_BYTE *)(v106 + 339), (_QWORD *)(v106 + 9048)))
                    {
                      v138 = *v137;
                      if (*v137)
                      {
                        v139 = CFURLCopyHostName(*(CFURLRef *)(v106 + 312));
                        if (v139)
                        {
                          v140 = v139;
                          if (*(_BYTE *)(v166 + 1176))
                          {
                            v141 = *(void (**)(uint64_t, __CFString *, __CFString *, CFStringRef, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 48);
                            if (v141)
                              v141(v138, CFSTR("bytePumpStats"), CFSTR("ContentHostname"), v140, 0);
                          }
                          CFRelease(v140);
                        }
                        v142 = *v137;
                        v143 = *(void (**)(uint64_t, __CFString *, const void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                          + 56);
                        if (v143)
                          v143(v142, CFSTR("IssueEndEvents"), v169);
                      }
                    }
                    CFRelease(v127);
                  }
                  *(_QWORD *)(v106 + 9496) = nw_activity_create();
                  *(_QWORD *)(*(_QWORD *)(v106 + 384) + 1176) = nw_activity_create();
                  *(_QWORD *)(*(_QWORD *)(v106 + 400) + 1176) = nw_activity_create();
                  *(_QWORD *)(*(_QWORD *)(v106 + 416) + 1176) = nw_activity_create();
                  if (*(_QWORD *)(v106 + 9496))
                  {
                    if (!*(_QWORD *)(v106 + 9104) || (nw_activity_set_parent_activity(), *(_QWORD *)(v106 + 9496)))
                      nw_activity_activate();
                  }
                  if (*(_QWORD *)(*(_QWORD *)(v106 + 384) + 1176) && *(_QWORD *)(v106 + 9496))
                    nw_activity_set_parent_activity();
                  if (*(_QWORD *)(*(_QWORD *)(v106 + 400) + 1176) && *(_QWORD *)(v106 + 9496))
                    nw_activity_set_parent_activity();
                  if (*(_QWORD *)(*(_QWORD *)(v106 + 416) + 1176) && *(_QWORD *)(v106 + 9496))
                    nw_activity_set_parent_activity();
                  if (*(_QWORD *)(*(_QWORD *)(v106 + 384) + 1176))
                    nw_activity_activate();
                  if (*(_QWORD *)(*(_QWORD *)(v106 + 400) + 1176))
                    nw_activity_activate();
                  if (*(_QWORD *)(*(_QWORD *)(v106 + 416) + 1176))
                    nw_activity_activate();
                  FigNetworkInterfaceReporterSamplePhysicalStatistics(*(_QWORD *)(v106 + 9120), 0, 0, 0, 0);
                  *(_DWORD *)(v106 + 288) = -1;
                  memset((char *)v172 + 8, 0, 216);
                  segPumpMakeNetworkPredictionInput(v106, (uint64_t)v172);
                  v144 = *(_QWORD *)(v106 + 104);
                  v145 = *(_QWORD *)(v106 + 112);
                  *(_QWORD *)&v172[0] = v145;
                  *(_OWORD *)((char *)&v172[2] + 8) = xmmword_1932FD0D0;
                  v146 = *(_BYTE *)(v106 + 334) != 0;
                  if (*(_BYTE *)(v106 + 334))
                    v147 = 0.96;
                  else
                    v147 = 0.0;
                  if (dword_1EE2A31E8)
                  {
                    v176 = 0;
                    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                    v149 = v176;
                    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT))
                      v150 = v149;
                    else
                      v150 = v149 & 0xFFFFFFFE;
                    if (v150)
                    {
                      v151 = *(const __CFString **)(v106 + 8760);
                      v152 = *(_QWORD *)(v106 + 120);
                      if (!v151)
                        v151 = &stru_1E2FD85F8;
                      *(_DWORD *)v177 = 136316418;
                      *(_QWORD *)&v177[4] = "FigBytePumpCreateForHTTPChunk";
                      *(_WORD *)&v177[12] = 2114;
                      *(_QWORD *)&v177[14] = v151;
                      *(_WORD *)&v177[22] = 1024;
                      LODWORD(v178) = v145;
                      WORD2(v178) = 1024;
                      *(_DWORD *)((char *)&v178 + 6) = v144;
                      WORD5(v178) = 1024;
                      HIDWORD(v178) = v152;
                      LOWORD(v179) = 1024;
                      *(_DWORD *)((char *)&v179 + 2) = 1;
                      _os_log_send_and_compose_impl();
                    }
                    fig_log_call_emit_and_clean_up_after_send_and_compose();
                  }
                  v153 = FigGetAllocatorForMedia();
                  v154 = *(_QWORD *)v106;
                  v155 = *(const void **)(v106 + 96);
                  v202 = v172[11];
                  v203 = v172[12];
                  v204 = v172[13];
                  v198 = v172[7];
                  v199 = v172[8];
                  v200 = v172[9];
                  v201 = v172[10];
                  v194 = v172[3];
                  v195 = v172[4];
                  v196 = v172[5];
                  v197 = v172[6];
                  v192 = v172[1];
                  v193 = v172[2];
                  *(_OWORD *)&v177[8] = xmmword_1932FD0E0;
                  v178 = xmmword_1932FD0F0;
                  v156 = *(const void **)(v106 + 9128);
                  *(_QWORD *)v177 = v144;
                  v179 = xmmword_1932FD0D0;
                  v180 = 0u;
                  v181 = 0u;
                  v182 = 0u;
                  v183 = 0u;
                  v184 = 0u;
                  v185 = 0u;
                  v186 = v147;
                  v187 = v146;
                  v188 = 0u;
                  v189 = 0u;
                  memset(v190, 0, sizeof(v190));
                  context = v172[0];
                  v28 = FigAlternateFilterMonitorCreateForPlaybackBitrate(v153, v154, (uint64_t)segPumpStallRiskCallback, v155, &context, v177, v156, (uint64_t)v175, (CFTypeRef *)(v106 + 9560));
                  if (!(_DWORD)v28)
                  {
                    *(_BYTE *)(v166 + 1208) = FigDebugIsInternalBuild();
                    *(_DWORD *)(v106 + 9068) = FigGetCFPreferenceNumberWithDefault();
                    FigNetworkWirelessReportingInterfaceInit();
                    v157 = (void *)FigRetainProxyRetain();
                    dispatch_async_f(*(dispatch_queue_t *)(v106 + 64), v157, (dispatch_function_t)segPumpAttemptNetworkMonitorSetupDispatch);
                    *a8 = v175;
                    v175 = 0;
                    goto LABEL_238;
                  }
                }
                else
                {
                  v28 = 4294954655;
                }
                goto LABEL_44;
              }
            }
          }
LABEL_43:
          v28 = v14;
          goto LABEL_44;
        }
LABEL_56:
        v40 = v169;
        goto LABEL_57;
      }
    }
    else
    {
      *(_QWORD *)(DerivedStorage + 9472) = 0;
    }
    v14 = FigSignalErrorAt();
    goto LABEL_43;
  }
LABEL_44:
  v37 = cf;
  if (v175)
    CFRelease(v175);
LABEL_239:
  if (v37)
    CFRelease(v37);
  return v28;
}

uint64_t segPumpSetHTTPRequestOptionsValue(uint64_t a1, const void *a2, const void *a3)
{
  const __CFAllocator *AllocatorForMedia;
  __CFDictionary *MutableCopy;
  __CFDictionary *v8;
  const void *v9;

  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  MutableCopy = CFDictionaryCreateMutableCopy(AllocatorForMedia, 0, *(CFDictionaryRef *)(a1 + 240));
  if (!MutableCopy)
    return FigSignalErrorAt();
  v8 = MutableCopy;
  if (a3)
    CFDictionarySetValue(MutableCopy, a2, a3);
  else
    CFDictionaryRemoveValue(MutableCopy, a2);
  v9 = *(const void **)(a1 + 240);
  *(_QWORD *)(a1 + 240) = v8;
  CFRetain(v8);
  if (v9)
    CFRelease(v9);
  CFRelease(v8);
  return 0;
}

uint64_t segPumpSetupNetworkHistory(uint64_t a1)
{
  const __CFAllocator *AllocatorForMedia;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v4;
  uint64_t v5;
  uint64_t v6;

  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 4294954655;
  v4 = Mutable;
  FigCFDictionarySetInt64();
  FigCFDictionarySetValue();
  v5 = FigNetworkHistoryCreate();
  if (!(_DWORD)v5)
    v5 = segPumpSetNetworkHistory(a1, 0);
  v6 = v5;
  CFRelease(v4);
  return v6;
}

uint64_t segPumpClearStatistics(uint64_t a1)
{
  uint64_t i;
  uint64_t result;
  uint64_t v4;
  uint64_t (*v5)(uint64_t, __CFString *);

  for (i = 0; i != 48; i += 16)
  {
    segPumpStreamClearStatistics(*(_QWORD *)(a1 + i + 384));
    segPumpStreamClearStatistics(*(_QWORD *)(a1 + i + 392));
  }
  *(_OWORD *)(a1 + 8560) = 0u;
  *(_OWORD *)(a1 + 8544) = 0u;
  *(_OWORD *)(a1 + 8528) = 0u;
  *(_OWORD *)(a1 + 8512) = 0u;
  *(_OWORD *)(a1 + 8496) = 0u;
  *(_OWORD *)(a1 + 8480) = 0u;
  *(_OWORD *)(a1 + 8632) = 0u;
  *(_OWORD *)(a1 + 8648) = 0u;
  result = FigNetworkInterfaceResetStatistics(*(_QWORD *)(a1 + 9120));
  v4 = *(_QWORD *)(a1 + 9048);
  if (v4)
  {
    result = CMBaseObjectGetVTable();
    v5 = *(uint64_t (**)(uint64_t, __CFString *))(*(_QWORD *)(result + 16) + 72);
    if (v5)
      return v5(v4, CFSTR("bytePumpStats"));
  }
  return result;
}

uint64_t segPumpStreamInitStorage(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7)
{
  BOOL v15;
  uint64_t result;
  int64_t v17;
  int v18;

  *(_QWORD *)a2 = a3;
  *(_BYTE *)(a2 + 866) = 1;
  *(_BYTE *)(a2 + 112) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a2 + 120) = _Q0;
  *(_DWORD *)(a2 + 72) = 1;
  *(_QWORD *)(a2 + 936) = -1;
  *(_QWORD *)(a2 + 680) = 0;
  *(_QWORD *)(a2 + 688) = a2 + 680;
  *(_QWORD *)(a2 + 336) = 0;
  *(_QWORD *)(a2 + 344) = a2 + 336;
  *(_QWORD *)(a2 + 752) = 1;
  *(_QWORD *)(a2 + 760) = a4;
  if (a4 >= 2)
  {
    if (a7)
      v15 = 0;
    else
      v15 = *(_BYTE *)(a1 + 48) == 0;
    *(_BYTE *)(a2 + 406) = v15;
  }
  result = segPumpCreateMediaConnection(a2);
  if (!(_DWORD)result)
  {
    *(_QWORD *)(a2 + 696) = *(_QWORD *)(a2 + 680);
    v17 = a5 <= 1 ? 1 : a5;
    result = segPumpStreamSetReadAheadConnectionCountMax(a2, v17);
    if (!(_DWORD)result)
    {
      if (a6 <= 1)
        v18 = 1;
      else
        v18 = a6;
      if (v18 >= a5)
        v18 = a5;
      *(_QWORD *)(a2 + 784) = v18;
      *(_QWORD *)(a2 + 360) = -1;
      *(_QWORD *)(a2 + 368) = -1;
    }
  }
  return result;
}

__n128 segPumpMakeNetworkPredictionInput@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  void (*v7)(uint64_t, __CFString *, _QWORD);
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __n128 result;
  __int128 v16;

  if (!*(_BYTE *)(a1 + 9216))
  {
    *(_BYTE *)(a1 + 9216) = 1;
    v4 = *(_OWORD *)(a1 + 9152);
    v5 = *(_OWORD *)(a1 + 9184);
    *(_OWORD *)(a1 + 9336) = *(_OWORD *)(a1 + 9168);
    *(_OWORD *)(a1 + 9352) = v5;
    *(_OWORD *)(a1 + 9368) = *(_OWORD *)(a1 + 9200);
    *(_OWORD *)(a1 + 9304) = *(_OWORD *)(a1 + 9136);
    *(_OWORD *)(a1 + 9320) = v4;
    *(_QWORD *)(a1 + 9288) = (int)FigRCLGetNumberWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("minActiveNetworkTimeForNetworkHistory"));
    *(_OWORD *)(a1 + 9264) = xmmword_1932FD0D0;
    *(_QWORD *)(a1 + 9392) = 1;
    if (FigRCLGetNumberWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("allowMLPredictions")))
    {
      *(_QWORD *)(a1 + 9392) |= 2uLL;
      v6 = *(_QWORD *)(a1 + 96);
      v7 = *(void (**)(uint64_t, __CFString *, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
      if (v7)
        v7(v6, CFSTR("NetworkPredictorProperty_EnableMLPredictions"), *MEMORY[0x1E0C9AE50]);
    }
  }
  v8 = *(_QWORD *)(a1 + 9280);
  if (!v8)
    v8 = 0x40000;
  *(_QWORD *)(a1 + 9280) = v8;
  v9 = *(_OWORD *)(a1 + 9400);
  *(_OWORD *)(a2 + 160) = *(_OWORD *)(a1 + 9384);
  *(_OWORD *)(a2 + 176) = v9;
  v10 = *(_OWORD *)(a1 + 9432);
  *(_OWORD *)(a2 + 192) = *(_OWORD *)(a1 + 9416);
  *(_OWORD *)(a2 + 208) = v10;
  v11 = *(_OWORD *)(a1 + 9336);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(a1 + 9320);
  *(_OWORD *)(a2 + 112) = v11;
  v12 = *(_OWORD *)(a1 + 9368);
  *(_OWORD *)(a2 + 128) = *(_OWORD *)(a1 + 9352);
  *(_OWORD *)(a2 + 144) = v12;
  v13 = *(_OWORD *)(a1 + 9304);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(a1 + 9288);
  *(_OWORD *)(a2 + 80) = v13;
  v14 = *(_OWORD *)(a1 + 9240);
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 9224);
  *(_OWORD *)(a2 + 16) = v14;
  result = *(__n128 *)(a1 + 9256);
  v16 = *(_OWORD *)(a1 + 9272);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v16;
  return result;
}

BOOL segPumpStallRiskCallback(uint64_t a1, uint64_t a2, CMTime *a3, CMTime *a4, int a5, double a6)
{
  int v11;
  _BOOL8 v12;
  uint64_t v13;
  unint64_t v14;
  _BOOL4 v15;
  unint64_t v16;
  _BOOL4 v17;
  _BOOL4 v18;
  uint64_t v19;
  int PeakBitRate;
  CMTime v22;
  CMTime v23;
  int v24[2];
  unint64_t v25;
  uint64_t v26;
  CFTypeRef v27;

  v27 = 0;
  v25 = 0;
  v26 = 0;
  *(_QWORD *)v24 = 0;
  v11 = segPumpLockAndCopyPumpFromRetainProxy(a1, &v27, &v26);
  v12 = 0;
  if (a2 && !v11)
  {
    FigAlternateGetRenditionInfoForMediaType(a2, 1936684398, *(const void **)(v26 + 8392), *(const void **)(v26 + 8400), *(const void **)(v26 + 8408), 0, 0, v24, 0);
    FigAlternateGetRenditionInfoForMediaType(a2, 1986618469, *(const void **)(v26 + 8392), *(const void **)(v26 + 8400), *(const void **)(v26 + 8408), 0, 0, &v25, 0);
    v13 = v26;
    v14 = *(_QWORD *)(*(_QWORD *)(v26 + 384) + 8);
    if (v25 | v14)
    {
      v15 = FigCFHTTPCompareURLs((const void *)v25, (CFTypeRef)v14) == 0;
      v13 = v26;
    }
    else
    {
      v15 = 0;
    }
    v16 = *(_QWORD *)(*(_QWORD *)(v13 + 400) + 8);
    if (*(_QWORD *)v24 | v16)
    {
      v17 = FigCFHTTPCompareURLs(*(const void **)v24, (CFTypeRef)v16) != 0;
      v13 = v26;
    }
    else
    {
      v17 = 1;
    }
    v18 = 0;
    if (*(_BYTE *)(v13 + 8009) && v15 && v17)
    {
      v19 = *(_QWORD *)(v13 + 400);
      if (*(_QWORD *)(v19 + 16))
        v18 = *(unsigned __int8 *)(v19 + 869) == 0;
      else
        v18 = 0;
    }
    if (*(_BYTE *)(*(_QWORD *)(v13 + 16 * *(_QWORD *)(v13 + 8416) + 384) + 1169))
    {
      FigSignalErrorAt();
      v12 = 0;
    }
    else
    {
      PeakBitRate = FigAlternateGetPeakBitRate(a2);
      v23 = *a3;
      v22 = *a4;
      v12 = segPumpRejectSwitchDueToStallRisk(v13, a2, PeakBitRate, &v23, &v22, v18, a5, a6);
    }
  }
  segPumpUnlockAndSendAllPendingNotifications();
  if (v27)
    CFRelease(v27);
  return v12;
}

void segPumpAttemptNetworkMonitorSetupDispatch(const void *a1)
{
  const void *v2;
  _QWORD *v3;
  CFTypeRef cf;

  v3 = 0;
  cf = 0;
  if (!segPumpLockAndCopyPumpFromRetainProxy((uint64_t)a1, &cf, (uint64_t *)&v3))
  {
    v2 = (const void *)v3[1054];
    if (!v2)
      v2 = (const void *)v3[39];
    AttemptNetworkMonitorSetup(v3, v2);
  }
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
  if (a1)
    CFRelease(a1);
}

uint64_t segPumpInvalidate()
{
  uint64_t DerivedStorage;
  int v1;
  const void *v2;
  _BYTE *v3;
  NSObject *v4;
  NSObject *v5;
  CFTypeRef *v6;
  const void *v7;
  uint64_t v8;
  char v9;
  char v10;
  uint64_t *v11;
  uint64_t i;
  uint64_t v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  _QWORD *j;
  const void *v23;
  uint64_t v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  OpaqueCMMemoryPool *v32;
  const void *v33;
  const void *v34;
  const void *v35;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigRetainProxyRetain();
  FigRetainProxyLockMutex();
  v1 = *(_DWORD *)(DerivedStorage + 8960);
  *(_DWORD *)(DerivedStorage + 8960) = 0;
  v2 = *(const void **)(DerivedStorage + 8968);
  *(_QWORD *)(DerivedStorage + 8968) = 0;
  FigRetainProxyUnlockMutex();
  if ((v1 & 0x20) != 0)
  {
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
  }
  v3 = (_BYTE *)(DerivedStorage + 7752);
  if (v2)
    CFRelease(v2);
  FigRetainProxyLockMutex();
  FigRetainProxyInvalidate();
  v4 = *(NSObject **)(DerivedStorage + 7744);
  if (v4)
  {
    if (*v3)
    {
      *v3 = 0;
      while (dispatch_group_wait(v4, 0))
      {
        dispatch_group_leave(*(dispatch_group_t *)(DerivedStorage + 7744));
        v4 = *(NSObject **)(DerivedStorage + 7744);
      }
    }
    v5 = *(NSObject **)(DerivedStorage + 7744);
    if (v5)
    {
      dispatch_release(v5);
      *(_QWORD *)(DerivedStorage + 7744) = 0;
    }
  }
  FigHTTPStopAndReleaseTimer((dispatch_object_t *)(DerivedStorage + 7936));
  FigHTTPStopAndReleaseTimer((dispatch_object_t *)(DerivedStorage + 8168));
  FigHTTPStopAndReleaseTimer((dispatch_object_t *)(DerivedStorage + 8616));
  while (1)
  {
    v6 = *(CFTypeRef **)(DerivedStorage + 352);
    if (!v6)
      break;
    segPumpFreeSavedEntry(DerivedStorage, v6);
  }
  v7 = *(const void **)(DerivedStorage + 7688);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(DerivedStorage + 7688) = 0;
  }
  v8 = 0;
  v9 = 1;
  do
  {
    v10 = v9;
    v11 = (uint64_t *)(DerivedStorage + 16 * v8 + 384);
    for (i = 1; i != 4; ++i)
    {
      v13 = *v11;
      if (*v11)
      {
        *(_BYTE *)(v13 + 859) = 0;
        *(_BYTE *)(v13 + 400) = 0;
        FigHTTPStopAndReleaseTimer((dispatch_object_t *)(v13 + 392));
        FigHTTPStopAndReleaseTimer((dispatch_object_t *)(v13 + 640));
        segPumpResetConnection(DerivedStorage, v13 + 544);
        segPumpResetConnection(DerivedStorage, DerivedStorage + 7760);
        segPumpCancelMediaFileReadAndResetData(DerivedStorage, v13, 0, 0);
        segPumpResetConnection(DerivedStorage, v13 + 408);
        *(_BYTE *)(v13 + 859) = 0;
        segPumpStreamUpdateIndexExpectedArrival(DerivedStorage, v13);
        v14 = *(const void **)(v13 + 840);
        if (v14)
        {
          CFRelease(v14);
          *(_QWORD *)(v13 + 840) = 0;
        }
        v15 = *(const void **)(v13 + 832);
        if (v15)
        {
          CFRelease(v15);
          *(_QWORD *)(v13 + 832) = 0;
        }
        v16 = *(const void **)(v13 + 296);
        if (v16)
        {
          CFRelease(v16);
          *(_QWORD *)(v13 + 296) = 0;
        }
        v17 = *(const void **)(v13 + 1144);
        if (v17)
        {
          CFRelease(v17);
          *(_QWORD *)(v13 + 1144) = 0;
        }
        v18 = *(const void **)(v13 + 248);
        if (v18)
        {
          CFRelease(v18);
          *(_QWORD *)(v13 + 248) = 0;
        }
        v19 = *(const void **)(v13 + 256);
        if (v19)
        {
          CFRelease(v19);
          *(_QWORD *)(v13 + 256) = 0;
        }
        v20 = *(const void **)(v13 + 264);
        if (v20)
        {
          CFRelease(v20);
          *(_QWORD *)(v13 + 264) = 0;
        }
        v21 = *(const void **)(v13 + 288);
        if (v21)
        {
          CFRelease(v21);
          *(_QWORD *)(v13 + 288) = 0;
        }
        for (j = *(_QWORD **)(v13 + 680); j; j = (_QWORD *)*j)
          segPumpResetMediaConnection(DerivedStorage, j, 0);
        segPumpCompleteNWAlternateForStream(v13);
        if (*(_QWORD *)(v13 + 1176))
        {
          nw_activity_complete_with_reason();
          v23 = *(const void **)(v13 + 1176);
          if (v23)
          {
            CFRelease(v23);
            *(_QWORD *)(v13 + 1176) = 0;
          }
        }
        v24 = *(_QWORD *)(v13 + 56);
        if (v24)
        {
          if (FigMediaPlaylistGetXPCClientObject(v24))
          {
            FigMediaPlaylistGetXPCClientObject(*(_QWORD *)(v13 + 56));
            FigStopForwardingMediaServicesProcessDeathNotification();
          }
          v25 = *(const void **)(v13 + 56);
          if (v25)
          {
            CFRelease(v25);
            *(_QWORD *)(v13 + 56) = 0;
          }
        }
        v26 = *(const void **)(v13 + 48);
        if (v26)
        {
          CFRelease(v26);
          *(_QWORD *)(v13 + 48) = 0;
        }
        v27 = *(const void **)(v13 + 1152);
        if (v27)
        {
          CFRelease(v27);
          *(_QWORD *)(v13 + 1152) = 0;
        }
      }
      v11 = (uint64_t *)(DerivedStorage + 16 * v8 + 8 * i + 384);
    }
    v9 = 0;
    v8 = 1;
  }
  while ((v10 & 1) != 0);
  if (*(_QWORD *)(DerivedStorage + 9496))
  {
    nw_activity_complete_with_reason();
    v28 = *(const void **)(DerivedStorage + 9496);
    if (v28)
    {
      CFRelease(v28);
      *(_QWORD *)(DerivedStorage + 9496) = 0;
    }
  }
  v29 = *(const void **)(DerivedStorage + 9104);
  if (v29)
  {
    CFRelease(v29);
    *(_QWORD *)(DerivedStorage + 9104) = 0;
  }
  if (*(_QWORD *)(DerivedStorage + 296))
  {
    CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener();
    FigStreamingCacheInvalidate(*(_QWORD *)(DerivedStorage + 296));
    v30 = *(const void **)(DerivedStorage + 296);
    if (v30)
    {
      CFRelease(v30);
      *(_QWORD *)(DerivedStorage + 296) = 0;
    }
  }
  v31 = *(const void **)(DerivedStorage + 304);
  if (v31)
  {
    CFRelease(v31);
    *(_QWORD *)(DerivedStorage + 304) = 0;
  }
  v32 = *(OpaqueCMMemoryPool **)(DerivedStorage + 7920);
  if (v32)
  {
    CMMemoryPoolInvalidate(v32);
    v33 = *(const void **)(DerivedStorage + 7920);
    if (v33)
    {
      CFRelease(v33);
      *(_QWORD *)(DerivedStorage + 7920) = 0;
    }
  }
  v34 = *(const void **)(DerivedStorage + 9560);
  if (v34)
  {
    CFRelease(v34);
    *(_QWORD *)(DerivedStorage + 9560) = 0;
  }
  v35 = *(const void **)(DerivedStorage + 9576);
  if (v35)
  {
    CFRelease(v35);
    *(_QWORD *)(DerivedStorage + 9576) = 0;
  }
  FigRetainProxyUnlockMutex();
  FigRetainProxyRelease();
  return 0;
}

void segPumpFinalize()
{
  uint64_t DerivedStorage;
  const void *v1;
  const void *v2;
  const void *v3;
  const void *v4;
  uint64_t i;
  _QWORD *v6;
  const void *v7;
  void *v8;
  dispatch_object_t *v9;
  uint64_t j;
  uint64_t v11;
  _QWORD *v12;
  void *v13;
  dispatch_object_t *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  NSObject *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  const void *v38;
  const void *v39;
  const void *v40;
  const void *v41;
  const void *v42;
  const void *v43;
  const void *v44;
  const void *v45;
  const void *v46;
  const void *v47;
  const void *v48;
  const void *v49;
  const void *v50;
  const void *v51;
  const void *v52;
  const void *v53;
  const void *v54;
  const void *v55;
  const void *v56;
  const void *v57;
  const void *v58;
  const void *v59;
  const void *v60;
  const void *v61;
  const void *v62;
  const void *v63;
  const void *v64;
  const void *v65;
  const void *v66;
  const void *v67;
  NSObject *v68;
  const void *v69;
  const void *v70;
  const void *v71;
  const void *v72;
  const void *v73;
  const void *v74;
  const void *v75;
  const void *v76;
  const void *v77;
  const void *v78;
  const void *v79;
  const void *v80;
  const void *v81;
  const void *v82;
  const void *v83;
  const void *v84;
  const void *v85;
  const void *v86;
  const void *v87;
  const void *v88;
  const void *v89;
  const void *v90;
  NSObject *v91;
  const void *v92;
  const void *v93;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  segPumpInvalidate();
  v1 = *(const void **)(DerivedStorage + 8432);
  if (v1)
    CFRelease(v1);
  v2 = *(const void **)(DerivedStorage + 8440);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(DerivedStorage + 8440) = 0;
  }
  v3 = *(const void **)(DerivedStorage + 8448);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(DerivedStorage + 8448) = 0;
  }
  v4 = *(const void **)(DerivedStorage + 8472);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(DerivedStorage + 8472) = 0;
  }
  for (i = 0; i != 3; ++i)
  {
    v6 = *(_QWORD **)(DerivedStorage + 16 * i + 384);
    if (v6)
    {
      v7 = *(const void **)(DerivedStorage + 40 * *v6 + 8288);
      if (v7)
      {
        CFRelease(v7);
        *(_QWORD *)(DerivedStorage + 40 * *v6 + 8288) = 0;
      }
      segPumpStreamDisposeStorage(v6);
      v8 = (void *)v6[96];
      if (v8)
      {
        v6[96] = 0;
        free(v8);
      }
      while (1)
      {
        v9 = (dispatch_object_t *)v6[85];
        if (!v9)
          break;
        segPumpDestroyMediaConnection(DerivedStorage, v6, v9);
      }
    }
  }
  for (j = 0; j != 3; ++j)
  {
    v11 = DerivedStorage + 16 * j;
    v12 = *(_QWORD **)(v11 + 392);
    if (v12)
    {
      segPumpStreamDisposeStorage(*(_QWORD **)(v11 + 392));
      v13 = (void *)v12[96];
      if (v13)
      {
        v12[96] = 0;
        free(v13);
      }
      while (1)
      {
        v14 = (dispatch_object_t *)v12[85];
        if (!v14)
          break;
        segPumpDestroyMediaConnection(DerivedStorage, v12, v14);
      }
    }
  }
  AlternateQueueFree(DerivedStorage + 8096);
  AlternateQueueFree(DerivedStorage + 8112);
  v15 = *(const void **)(DerivedStorage + 7896);
  if (v15)
  {
    CFRelease(v15);
    *(_QWORD *)(DerivedStorage + 7896) = 0;
  }
  v16 = *(const void **)(DerivedStorage + 8128);
  if (v16)
    CFRelease(v16);
  v17 = *(const void **)(DerivedStorage + 8136);
  if (v17)
    CFRelease(v17);
  v18 = *(const void **)(DerivedStorage + 8152);
  if (v18)
    CFRelease(v18);
  v19 = *(const void **)(DerivedStorage + 8160);
  if (v19)
    CFRelease(v19);
  v20 = *(const void **)(DerivedStorage + 9544);
  if (v20)
    CFRelease(v20);
  v21 = *(const void **)(DerivedStorage + 9552);
  if (v21)
    CFRelease(v21);
  segPumpUpdateCurrentAlternate(DerivedStorage, 0);
  v22 = *(const void **)(DerivedStorage + 9512);
  if (v22)
    CFRelease(v22);
  v23 = *(const void **)(DerivedStorage + 8376);
  if (v23)
    CFRelease(v23);
  v24 = *(const void **)(DerivedStorage + 8248);
  if (v24)
  {
    CFRelease(v24);
    *(_QWORD *)(DerivedStorage + 8248) = 0;
  }
  v25 = *(const void **)(DerivedStorage + 80);
  if (v25)
    CFRelease(v25);
  v26 = *(NSObject **)(DerivedStorage + 152);
  if (v26)
    dispatch_release(v26);
  v27 = *(const void **)(DerivedStorage + 88);
  if (v27)
    CFRelease(v27);
  v28 = *(const void **)(DerivedStorage + 216);
  if (v28)
    CFRelease(v28);
  v29 = *(const void **)(DerivedStorage + 224);
  if (v29)
    CFRelease(v29);
  v30 = *(const void **)(DerivedStorage + 232);
  if (v30)
    CFRelease(v30);
  v31 = *(const void **)(DerivedStorage + 192);
  if (v31)
  {
    CFRelease(v31);
    *(_QWORD *)(DerivedStorage + 192) = 0;
  }
  v32 = *(const void **)(DerivedStorage + 200);
  if (v32)
  {
    CFRelease(v32);
    *(_QWORD *)(DerivedStorage + 200) = 0;
  }
  v33 = *(const void **)(DerivedStorage + 208);
  if (v33)
  {
    CFRelease(v33);
    *(_QWORD *)(DerivedStorage + 208) = 0;
  }
  v34 = *(const void **)(DerivedStorage + 248);
  if (v34)
    CFRelease(v34);
  v35 = *(const void **)(DerivedStorage + 264);
  if (v35)
    CFRelease(v35);
  v36 = *(const void **)(DerivedStorage + 272);
  if (v36)
    CFRelease(v36);
  v37 = *(const void **)(DerivedStorage + 280);
  if (v37)
    CFRelease(v37);
  v38 = *(const void **)(DerivedStorage + 8672);
  if (v38)
    CFRelease(v38);
  v39 = *(const void **)(DerivedStorage + 8968);
  if (v39)
    CFRelease(v39);
  v40 = *(const void **)(DerivedStorage + 8976);
  if (v40)
    CFRelease(v40);
  v41 = *(const void **)(DerivedStorage + 9000);
  if (v41)
    CFRelease(v41);
  v42 = *(const void **)(DerivedStorage + 8992);
  if (v42)
    CFRelease(v42);
  v43 = *(const void **)(DerivedStorage + 8984);
  if (v43)
    CFRelease(v43);
  v44 = *(const void **)(DerivedStorage + 312);
  if (v44)
    CFRelease(v44);
  FigHTTPSchedulerRelease(*(dispatch_object_t *)(DerivedStorage + 64));
  *(_QWORD *)(DerivedStorage + 64) = 0;
  v45 = *(const void **)(DerivedStorage + 8880);
  if (v45)
    CFRelease(v45);
  v46 = *(const void **)(DerivedStorage + 8888);
  if (v46)
    CFRelease(v46);
  v47 = *(const void **)(DerivedStorage + 8896);
  if (v47)
    CFRelease(v47);
  v48 = *(const void **)(DerivedStorage + 240);
  if (v48)
    CFRelease(v48);
  v49 = *(const void **)(DerivedStorage + 8384);
  if (v49)
    CFRelease(v49);
  v50 = *(const void **)(DerivedStorage + 8392);
  if (v50)
    CFRelease(v50);
  v51 = *(const void **)(DerivedStorage + 8400);
  if (v51)
    CFRelease(v51);
  v52 = *(const void **)(DerivedStorage + 8408);
  if (v52)
    CFRelease(v52);
  v53 = *(const void **)(DerivedStorage + 8424);
  if (v53)
    CFRelease(v53);
  v54 = *(const void **)(DerivedStorage + 8224);
  if (v54)
    CFRelease(v54);
  v55 = *(const void **)(DerivedStorage + 8232);
  if (v55)
    CFRelease(v55);
  v56 = *(const void **)(DerivedStorage + 7776);
  if (v56)
    CFRelease(v56);
  v57 = *(const void **)(DerivedStorage + 7768);
  if (v57)
    CFRelease(v57);
  v58 = *(const void **)(DerivedStorage + 7912);
  if (v58)
    CFRelease(v58);
  v59 = *(const void **)(DerivedStorage + 7712);
  if (v59)
  {
    CFRelease(v59);
    *(_QWORD *)(DerivedStorage + 7712) = 0;
  }
  v60 = *(const void **)(DerivedStorage + 7696);
  if (v60)
  {
    CFRelease(v60);
    *(_QWORD *)(DerivedStorage + 7696) = 0;
  }
  v61 = *(const void **)(DerivedStorage + 7720);
  if (v61)
  {
    CFRelease(v61);
    *(_QWORD *)(DerivedStorage + 7720) = 0;
  }
  v62 = *(const void **)(DerivedStorage + 7736);
  if (v62)
  {
    CFRelease(v62);
    *(_QWORD *)(DerivedStorage + 7736) = 0;
  }
  v63 = *(const void **)(DerivedStorage + 7728);
  if (v63)
  {
    CFRelease(v63);
    *(_QWORD *)(DerivedStorage + 7728) = 0;
  }
  v64 = *(const void **)(DerivedStorage + 7704);
  if (v64)
  {
    CFRelease(v64);
    *(_QWORD *)(DerivedStorage + 7704) = 0;
  }
  v65 = *(const void **)(DerivedStorage + 256);
  if (v65)
  {
    CFRelease(v65);
    *(_QWORD *)(DerivedStorage + 256) = 0;
  }
  v66 = *(const void **)(DerivedStorage + 8760);
  if (v66)
  {
    CFRelease(v66);
    *(_QWORD *)(DerivedStorage + 8760) = 0;
  }
  v67 = *(const void **)(DerivedStorage + 9128);
  if (v67)
    CFRelease(v67);
  if (*(_QWORD *)(DerivedStorage + 8808))
  {
    FigGzipDispose();
    *(_QWORD *)(DerivedStorage + 8808) = 0;
  }
  v68 = *(NSObject **)(DerivedStorage + 72);
  if (v68)
  {
    dispatch_release(v68);
    *(_QWORD *)(DerivedStorage + 72) = 0;
  }
  FigNetworkInterfaceReporterDestroy(*(_QWORD **)(DerivedStorage + 9120));
  v69 = *(const void **)(DerivedStorage + 32);
  if (v69)
    CFRelease(v69);
  v70 = *(const void **)(DerivedStorage + 40);
  if (v70)
    CFRelease(v70);
  v71 = *(const void **)(DerivedStorage + 9040);
  if (v71)
    CFRelease(v71);
  v72 = *(const void **)(DerivedStorage + 9088);
  if (v72)
    CFRelease(v72);
  v73 = *(const void **)(DerivedStorage + 9048);
  if (v73)
    CFRelease(v73);
  FigRetainProxyRelease();
  *(_QWORD *)(DerivedStorage + 176) = 0;
  FigRetainProxyRelease();
  *(_QWORD *)DerivedStorage = 0;
  v74 = *(const void **)(DerivedStorage + 9448);
  if (v74)
  {
    CFRelease(v74);
    *(_QWORD *)(DerivedStorage + 9448) = 0;
  }
  v75 = *(const void **)(DerivedStorage + 9456);
  if (v75)
  {
    CFRelease(v75);
    *(_QWORD *)(DerivedStorage + 9456) = 0;
  }
  v76 = *(const void **)(DerivedStorage + 9464);
  if (v76)
  {
    CFRelease(v76);
    *(_QWORD *)(DerivedStorage + 9464) = 0;
  }
  v77 = *(const void **)(DerivedStorage + 9472);
  if (v77)
  {
    CFRelease(v77);
    *(_QWORD *)(DerivedStorage + 9472) = 0;
  }
  v78 = *(const void **)(DerivedStorage + 9488);
  if (v78)
  {
    CFRelease(v78);
    *(_QWORD *)(DerivedStorage + 9488) = 0;
  }
  v79 = *(const void **)(DerivedStorage + 96);
  if (v79)
  {
    CFRelease(v79);
    *(_QWORD *)(DerivedStorage + 96) = 0;
  }
  v80 = *(const void **)(DerivedStorage + 8016);
  if (v80)
  {
    CFRelease(v80);
    *(_QWORD *)(DerivedStorage + 8016) = 0;
  }
  v81 = *(const void **)(DerivedStorage + 9568);
  if (v81)
  {
    CFRelease(v81);
    *(_QWORD *)(DerivedStorage + 9568) = 0;
  }
  v82 = *(const void **)(DerivedStorage + 9136);
  if (v82)
  {
    CFRelease(v82);
    *(_QWORD *)(DerivedStorage + 9136) = 0;
  }
  v83 = *(const void **)(DerivedStorage + 9144);
  if (v83)
  {
    CFRelease(v83);
    *(_QWORD *)(DerivedStorage + 9144) = 0;
  }
  v84 = *(const void **)(DerivedStorage + 9152);
  if (v84)
  {
    CFRelease(v84);
    *(_QWORD *)(DerivedStorage + 9152) = 0;
  }
  v85 = *(const void **)(DerivedStorage + 9176);
  if (v85)
  {
    CFRelease(v85);
    *(_QWORD *)(DerivedStorage + 9176) = 0;
  }
  v86 = *(const void **)(DerivedStorage + 9184);
  if (v86)
  {
    CFRelease(v86);
    *(_QWORD *)(DerivedStorage + 9184) = 0;
  }
  v87 = *(const void **)(DerivedStorage + 9200);
  if (v87)
  {
    CFRelease(v87);
    *(_QWORD *)(DerivedStorage + 9200) = 0;
  }
  v88 = *(const void **)(DerivedStorage + 9168);
  if (v88)
  {
    CFRelease(v88);
    *(_QWORD *)(DerivedStorage + 9168) = 0;
  }
  v89 = *(const void **)(DerivedStorage + 9520);
  if (v89)
  {
    CFRelease(v89);
    *(_QWORD *)(DerivedStorage + 9520) = 0;
  }
  v90 = *(const void **)(DerivedStorage + 9528);
  if (v90)
  {
    CFRelease(v90);
    *(_QWORD *)(DerivedStorage + 9528) = 0;
  }
  v91 = *(NSObject **)(DerivedStorage + 9536);
  if (v91)
  {
    dispatch_release(v91);
    *(_QWORD *)(DerivedStorage + 9536) = 0;
  }
  v92 = *(const void **)(DerivedStorage + 9024);
  if (v92)
    CFRelease(v92);
  v93 = *(const void **)(DerivedStorage + 9016);
  if (v93)
    CFRelease(v93);
}

__CFString *segPumpCopyDebugDescription(uint64_t a1)
{
  const __CFAllocator *AllocatorForMedia;
  __CFString *Mutable;

  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  Mutable = CFStringCreateMutable(AllocatorForMedia, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigBytePumpHTTPSegment %p>"), a1);
  return Mutable;
}

uint64_t segPumpCopyProperty(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t DerivedStorage;
  const __CFAllocator *AllocatorForMedia;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v10;
  uint64_t v11;
  const void *v12;
  CFTypeRef v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  double MinTime;
  int v18;
  uint64_t v19;
  uint64_t v20;
  CMTimeRange *p_value;
  uint64_t v22;
  int64_t v23;
  double v24;
  const __CFAllocator *v25;
  CFNumberType v26;
  const void *Copy;
  double v28;
  double MaxTime;
  int AccessLog;
  CFNumberRef v31;
  uint64_t v32;
  uint64_t v33;
  double v34;
  uint64_t v35;
  int v36;
  double v37;
  CFTypeRef v38;
  BOOL v40;
  unsigned int v41;
  _QWORD *v42;
  const __CFData *v43;
  const __CFArray *v44;
  uint64_t v45;
  uint64_t v46;
  const __CFArray *ContentKeySpecifiers;
  double v48;
  double v49;
  const __CFAllocator *v50;
  CMTimeRange *v51;
  CFNumberType v52;
  CFNumberRef v53;
  const void **v54;
  const void *v55;
  double MinimumPrebufferReservation;
  __CFError *v57;
  uint64_t v58;
  const __CFArray *SessionDataSpecifiers;
  __CFArray *v60;
  __CFArray *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  double v65;
  uint64_t NetworkStatistics;
  int v67;
  const void **v68;
  const void **v69;
  BOOL v70;
  const void *v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  CFIndex v75;
  const __CFArray *Count;
  _DWORD *ValueAtIndex;
  const void **v78;
  CMTimeRange v79;
  CMTime time;
  CMTimeRange value;
  __int128 v82;
  __int128 v83;
  uint64_t v84;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigRetainProxyLockMutex();
  if (FigRetainProxyIsInvalidated())
    goto LABEL_75;
  if (CFEqual(a2, CFSTR("FBP_AlternateInfo")))
  {
    if (*(_QWORD *)(DerivedStorage + 8096))
    {
      value.start.value = 0;
      AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
      Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (Mutable)
      {
        v10 = Mutable;
        LODWORD(a3) = segPumpCreateFigAlternatesArrayAndCalculateStartupScore(DerivedStorage, (__CFArray **)&value);
        if ((_DWORD)a3)
        {
          v13 = 0;
        }
        else
        {
          CFDictionarySetValue(v10, CFSTR("FBPAIK_FigAlternateArray"), (const void *)value.start.value);
          v11 = *(_QWORD *)(DerivedStorage + 8144);
          if (v11)
            CFDictionarySetValue(v10, CFSTR("FBPAIK_CurrentFigAlternate"), *(const void **)(v11 + 8));
          v12 = *(const void **)(DerivedStorage + 8376);
          if (v12)
            CFDictionarySetValue(v10, CFSTR("FBPAIK_MediaSelectionArray"), v12);
          v13 = CFRetain(v10);
        }
        CFRelease(v10);
        if (value.start.value)
          CFRelease((CFTypeRef)value.start.value);
        if (v13)
          *a4 = v13;
        goto LABEL_15;
      }
      goto LABEL_75;
    }
    goto LABEL_86;
  }
  if (CFEqual(a2, CFSTR("FBP_MinTime")))
  {
    v14 = *(unsigned __int8 *)(*(_QWORD *)(DerivedStorage + 384) + 1169);
    v15 = *(_QWORD *)(DerivedStorage + 400);
    if (*(_QWORD *)(v15 + 16))
      v14 = (*(_BYTE *)(v15 + 1169) & v14);
    v16 = *(_QWORD *)(DerivedStorage + 416);
    if (*(_QWORD *)(v16 + 16))
      v14 = (*(_BYTE *)(v16 + 1169) & v14);
    if (!v14)
    {
      MinTime = segPumpGetMinTime((_QWORD *)DerivedStorage);
      memset(&value, 0, 24);
LABEL_43:
      CMTimeMakeWithSeconds(&value.start, MinTime, 1000);
LABEL_44:
      *(_OWORD *)&v79.start.value = *(_OWORD *)&value.start.value;
      v79.start.epoch = value.start.epoch;
      p_value = &v79;
      goto LABEL_45;
    }
LABEL_31:
    *(_OWORD *)&value.start.value = *MEMORY[0x1E0CA2E18];
    value.start.epoch = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
    p_value = &value;
LABEL_45:
    Copy = CMTimeCopyAsDictionary(&p_value->start, (CFAllocatorRef)a3);
    goto LABEL_46;
  }
  if (CFEqual(a2, CFSTR("FBP_MaxTime")))
  {
    v18 = *(unsigned __int8 *)(*(_QWORD *)(DerivedStorage + 384) + 1169);
    v19 = *(_QWORD *)(DerivedStorage + 400);
    if (*(_QWORD *)(v19 + 16))
      v18 = (*(_BYTE *)(v19 + 1169) & v18);
    v20 = *(_QWORD *)(DerivedStorage + 416);
    if (*(_QWORD *)(v20 + 16))
      v18 = (*(_BYTE *)(v20 + 1169) & v18);
    if (!v18)
    {
      memset(&value, 0, 24);
      v28 = segPumpGetMinTime((_QWORD *)DerivedStorage);
      MaxTime = segPumpGetMaxTime((_QWORD *)DerivedStorage);
      if (!*(_BYTE *)(DerivedStorage + 8002))
        MaxTime = MaxTime
                - (segPumpGetMinimumPrebufferReservation(DerivedStorage, 0)
                 + *(double *)(DerivedStorage + 7960));
      if (MaxTime >= v28)
        MinTime = MaxTime;
      else
        MinTime = v28;
      goto LABEL_43;
    }
    goto LABEL_31;
  }
  if (CFEqual(a2, CFSTR("FBP_TimeAvailableModDate")))
  {
    v22 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 16 * *(_QWORD *)(DerivedStorage + 8416) + 384) + 1056);
    if (v22)
    {
      v23 = (FigGetUpTimeNanoseconds() - v22) / 0xF4240uLL;
      v24 = CACurrentMediaTime() + (double)v23 / -1000.0;
LABEL_35:
      *(double *)&value.start.value = v24;
LABEL_36:
      v25 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v26 = kCFNumberDoubleType;
LABEL_37:
      Copy = CFNumberCreate(v25, v26, &value);
LABEL_46:
      a3 = 0;
      *a4 = Copy;
LABEL_87:
      segPumpUnlockAndSendAllPendingNotifications();
      return a3;
    }
    goto LABEL_86;
  }
  if (CFEqual(a2, CFSTR("FBP_CachedTimeRanges")))
  {
    AccessLog = segPumpCopyCachedTimeRanges(DerivedStorage, a4);
LABEL_49:
    LODWORD(a3) = AccessLog;
    goto LABEL_15;
  }
  if (CFEqual(a2, CFSTR("FBP_MeasuredBandwidth")))
  {
    v84 = 0;
    v82 = 0u;
    v83 = 0u;
    memset(&value, 0, sizeof(value));
    LODWORD(a3) = segPumpGetObservedNetworkStats(DerivedStorage, 0, (uint64_t)&value);
    if ((_DWORD)a3)
      goto LABEL_15;
    v31 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &value);
    goto LABEL_57;
  }
  if (CFEqual(a2, CFSTR("FBP_RequiredBandwidth")))
  {
    v32 = *(_QWORD *)(DerivedStorage + 8144);
    if (!v32)
    {
      v33 = 0;
      v34 = 0.0;
      do
      {
        v35 = *(_QWORD *)(DerivedStorage + 384 + v33);
        if (*(_QWORD *)(v35 + 16))
        {
          v36 = *(_DWORD *)(v35 + 1080);
          if (!v36)
            goto LABEL_86;
          LODWORD(v32) = v36 + v32;
          if (v34 == 0.0)
          {
            v34 = *(double *)(v35 + 1088);
          }
          else if (v34 >= *(double *)(v35 + 1088))
          {
            v34 = *(double *)(v35 + 1088);
          }
        }
        v33 += 16;
      }
      while (v33 != 48);
      if (v34 > 0.0)
      {
        v24 = (double)v32;
        goto LABEL_35;
      }
LABEL_86:
      a3 = 4294954513;
      goto LABEL_87;
    }
    LODWORD(value.start.value) = FigAlternateGetPeakBitRate(*(_QWORD *)(v32 + 8));
    if (LODWORD(value.start.value))
    {
      v31 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &value);
      LODWORD(a3) = 0;
LABEL_57:
      *a4 = v31;
      goto LABEL_15;
    }
LABEL_75:
    AccessLog = FigSignalErrorAt();
    goto LABEL_49;
  }
  if (CFEqual(a2, CFSTR("FBP_NetworkBandwidth")))
  {
    value.start.value = 0;
    if (!segPumpGetSafeNetworkBandwidth(DerivedStorage, (double *)&value.start.value, 0, 0))
      goto LABEL_36;
    goto LABEL_86;
  }
  if (CFEqual(a2, CFSTR("FBP_CanContinueWithoutGapBitField")))
  {
    LODWORD(value.start.value) = 0;
    segPumpCanContinueWithoutGap(DerivedStorage, (int *)&value);
    v25 = (const __CFAllocator *)a3;
    v26 = kCFNumberSInt32Type;
    goto LABEL_37;
  }
  if (CFEqual(a2, CFSTR("FBP_Duration")))
  {
    *(_OWORD *)&value.start.value = *MEMORY[0x1E0CA2E10];
    value.start.epoch = *(_QWORD *)(MEMORY[0x1E0CA2E10] + 16);
    if (*(_BYTE *)(DerivedStorage + 8002))
    {
      v37 = segPumpGetMaxTime((_QWORD *)DerivedStorage);
      MinTime = v37 - segPumpGetMinTime((_QWORD *)DerivedStorage);
      goto LABEL_43;
    }
    if (*(double *)(DerivedStorage + 344) > 0.0)
      goto LABEL_44;
    goto LABEL_86;
  }
  if (CFEqual(a2, CFSTR("FBP_MaximumRecommendedCellularBitrate")))
  {
    if (!segPumpConnectedInterfaceIsWWAN(DerivedStorage))
    {
      v38 = *a4;
      goto LABEL_92;
    }
    v38 = *(CFTypeRef *)(DerivedStorage + 208);
    if (!v38)
    {
LABEL_84:
      *a4 = v38;
LABEL_92:
      v40 = v38 == 0;
LABEL_93:
      v41 = -12783;
      goto LABEL_94;
    }
LABEL_83:
    v38 = CFRetain(v38);
    goto LABEL_84;
  }
  if (CFEqual(a2, CFSTR("FBP_AccessLog")))
  {
    AccessLog = segPumpCreateAccessLog(DerivedStorage, (CFAllocatorRef)a3, (__CFDictionary **)a4);
    goto LABEL_49;
  }
  if (CFEqual(a2, CFSTR("FBP_LastServerIPAddress")))
  {
    v42 = (_QWORD *)(*(_QWORD *)(DerivedStorage + 16 * *(_QWORD *)(DerivedStorage + 8416) + 384) + 680);
    while (1)
    {
      v42 = (_QWORD *)*v42;
      if (!v42)
        break;
      v43 = (const __CFData *)v42[22];
      if (v43)
        goto LABEL_107;
    }
    v43 = 0;
LABEL_107:
    Copy = FigCFHTTPCreateAddressString(v43);
    if (Copy)
      goto LABEL_46;
    goto LABEL_86;
  }
  if (CFEqual(a2, CFSTR("FBP_ErrorLog")))
  {
    v44 = *(const __CFArray **)(DerivedStorage + 8672);
    if (v44)
    {
      Copy = CFArrayCreateCopy((CFAllocatorRef)a3, v44);
      if (!Copy)
      {
        a3 = 4294954510;
        goto LABEL_87;
      }
      goto LABEL_46;
    }
    goto LABEL_86;
  }
  if (CFEqual(a2, CFSTR("FBP_EndError")))
  {
    Copy = *(const void **)(DerivedStorage + 8016);
    if (!Copy)
      goto LABEL_86;
LABEL_120:
    Copy = CFRetain(Copy);
    goto LABEL_46;
  }
  if (CFEqual(a2, CFSTR("FBP_PlaybackSessionID")))
  {
    Copy = *(const void **)(DerivedStorage + 224);
    if (!Copy)
      goto LABEL_86;
    goto LABEL_120;
  }
  if (CFEqual(a2, CFSTR("FBP_SegmentCache")))
  {
    Copy = *(const void **)(DerivedStorage + 296);
    if (!Copy)
      goto LABEL_86;
    goto LABEL_120;
  }
  if (CFEqual(a2, CFSTR("FBP_ExternalProtectionMethods")))
  {
    Copy = *(const void **)(DerivedStorage + 264);
    if (Copy)
      goto LABEL_120;
    value.start.value = 0;
LABEL_129:
    v25 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v26 = kCFNumberSInt64Type;
    goto LABEL_37;
  }
  if (CFEqual(a2, CFSTR("FBP_HasKeyContent")))
  {
    v45 = 0;
    *a4 = (CFTypeRef)*MEMORY[0x1E0C9AE40];
    while (1)
    {
      v46 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 384 + v45) + 56);
      if (v46)
      {
        ContentKeySpecifiers = (const __CFArray *)FigMediaPlaylistGetContentKeySpecifiers(v46);
        if (ContentKeySpecifiers)
        {
          if (CFArrayGetCount(ContentKeySpecifiers) >= 1)
            break;
        }
      }
      a3 = 0;
      v45 += 16;
      if (v45 == 48)
        goto LABEL_87;
    }
    a3 = 0;
    v54 = (const void **)MEMORY[0x1E0C9AE50];
    goto LABEL_139;
  }
  if (CFEqual(a2, CFSTR("FBP_SpecifiedPreciseStartTime")))
  {
    if (!*(_BYTE *)(DerivedStorage + 8685) || !*(_BYTE *)(DerivedStorage + 8686))
      goto LABEL_86;
    v48 = *(double *)(DerivedStorage + 8688);
    *(double *)&value.start.value = v48;
    if (v48 >= 0.0)
      goto LABEL_136;
    v49 = v48 + *(double *)(DerivedStorage + 344);
LABEL_135:
    *(double *)&value.start.value = v49;
LABEL_136:
    v50 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v51 = &value;
    v52 = kCFNumberDoubleType;
LABEL_137:
    v53 = CFNumberCreate(v50, v52, v51);
LABEL_146:
    *a4 = v53;
    v40 = v53 == 0;
    v41 = -12786;
LABEL_94:
    if (v40)
      a3 = v41;
    else
      a3 = 0;
    goto LABEL_87;
  }
  if (CFEqual(a2, CFSTR("FBP_PrebufferReservation")))
  {
    if (!*(_DWORD *)(DerivedStorage + 8))
      goto LABEL_86;
    MinimumPrebufferReservation = segPumpGetMinimumPrebufferReservation(DerivedStorage, 0);
    CMTimeMakeWithSeconds(&time, MinimumPrebufferReservation + *(double *)(DerivedStorage + 7960), 1000000);
    v53 = CMTimeCopyAsDictionary(&time, (CFAllocatorRef)a3);
    goto LABEL_146;
  }
  if (CFEqual(a2, CFSTR("FBP_ManagedLiveEdgeSeekablePoint")))
  {
    memset(&value, 0, sizeof(value));
    segPumpGetLiveEdge(DerivedStorage, 7u, 1, (uint64_t)&value);
    v79 = value;
    v53 = CMTimeRangeCopyAsDictionary(&v79, (CFAllocatorRef)a3);
    goto LABEL_146;
  }
  if (CFEqual(a2, CFSTR("FBP_RecommendedPrebufferReservation")))
  {
    value.start.value = *(_QWORD *)(DerivedStorage + 7968);
    if (*(double *)&value.start.value <= 0.0)
      goto LABEL_86;
    goto LABEL_136;
  }
  if (CFEqual(a2, CFSTR("FBSP_Chapters")))
  {
    AccessLog = segPumpLoadSynchronousProperties(DerivedStorage);
    if (AccessLog)
      goto LABEL_49;
    v57 = *(__CFError **)(DerivedStorage + 7720);
    if (!v57)
    {
      Copy = *(const void **)(DerivedStorage + 7712);
      if (!Copy)
        goto LABEL_86;
      goto LABEL_120;
    }
    goto LABEL_189;
  }
  if (CFEqual(a2, CFSTR("FBSP_LocalizedMSODisplayName")))
  {
    AccessLog = segPumpLoadSynchronousProperties(DerivedStorage);
    if (AccessLog)
      goto LABEL_49;
    v57 = *(__CFError **)(DerivedStorage + 7736);
    if (!v57)
    {
      Copy = *(const void **)(DerivedStorage + 7728);
      if (!Copy)
        goto LABEL_86;
      goto LABEL_120;
    }
    goto LABEL_189;
  }
  if (CFEqual(a2, CFSTR("FBSP_Metadata")))
  {
    AccessLog = segPumpLoadSynchronousProperties(DerivedStorage);
    if (AccessLog)
      goto LABEL_49;
    v57 = *(__CFError **)(DerivedStorage + 7704);
    if (!v57)
    {
      Copy = *(const void **)(DerivedStorage + 7696);
      if (!Copy)
        goto LABEL_86;
      goto LABEL_120;
    }
LABEL_189:
    LODWORD(a3) = CFErrorGetCode(v57);
    goto LABEL_15;
  }
  if (CFEqual(a2, CFSTR("FBSP_MetadataFormats")))
  {
    v58 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 384) + 48);
    if (!v58)
      goto LABEL_86;
    SessionDataSpecifiers = (const __CFArray *)FigMultivariantPlaylistGetSessionDataSpecifiers(v58);
    if (!SessionDataSpecifiers || CFArrayGetCount(SessionDataSpecifiers) < 1)
      goto LABEL_86;
    v60 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    if (!v60)
      goto LABEL_75;
    v61 = v60;
    CFArrayAppendValue(v60, CFSTR("com.apple.quicktime.HLS"));
    *a4 = CFRetain(v61);
    CFRelease(v61);
LABEL_171:
    a3 = 0;
    goto LABEL_87;
  }
  if (CFEqual(a2, CFSTR("FBP_SessionConfiguration")))
  {
    Copy = *(const void **)(DerivedStorage + 9128);
    if (!Copy)
      goto LABEL_86;
    goto LABEL_120;
  }
  if (CFEqual(a2, CFSTR("FBP_TaggedRangeMetadataArray")))
  {
    v62 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 16 * *(_QWORD *)(DerivedStorage + 8416) + 384) + 56);
    if (!v62 || !FigMediaPlaylistGetDateEntryArray(v62))
      goto LABEL_86;
    Copy = (const void *)FigMediaPlaylistGetDateEntryArray(*(_QWORD *)(*(_QWORD *)(DerivedStorage
                                                                                 + 16
                                                                                 * *(_QWORD *)(DerivedStorage + 8416)
                                                                                 + 384)
                                                                     + 56));
    goto LABEL_120;
  }
  if (CFEqual(a2, CFSTR("FBP_BandwidthEstimateStatistics")))
  {
    v63 = *(_QWORD *)(DerivedStorage + 9120);
    if (v63)
    {
      Copy = FigNetworkInterfaceReporterCopyBandwidthEstimates(v63);
      if (Copy)
        goto LABEL_46;
    }
    goto LABEL_86;
  }
  if (CFEqual(a2, CFSTR("FBP_IFrameReport")))
  {
    AccessLog = segPumpCreateIFrameReport(DerivedStorage, (const __CFAllocator *)a3, (CFMutableDictionaryRef *)a4);
    goto LABEL_49;
  }
  if (CFEqual(a2, CFSTR("FBP_MaxIFrameRate")))
  {
    if (!*(_BYTE *)(DerivedStorage + 8712))
      goto LABEL_86;
    v64 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 16 * *(_QWORD *)(DerivedStorage + 8416) + 384) + 56);
    if (!v64)
      goto LABEL_86;
    v65 = fabsf(*(float *)(DerivedStorage + 8696));
    v49 = v65 / FigMediaPlaylistGetAvgSegmentDuration(v64);
    goto LABEL_135;
  }
  if (CFEqual(a2, CFSTR("FBP_NetworkInterfaceStatistics")))
  {
    NetworkStatistics = segPumpCreateNetworkStatistics(DerivedStorage, (CFAllocatorRef)a3, (__CFDictionary **)a4);
LABEL_193:
    a3 = NetworkStatistics;
    goto LABEL_87;
  }
  if (CFEqual(a2, CFSTR("FBP_PrefetchKeys")))
  {
    a3 = 0;
    v67 = *(unsigned __int8 *)(DerivedStorage + 7994);
LABEL_196:
    v68 = (const void **)MEMORY[0x1E0C9AE50];
    v69 = (const void **)MEMORY[0x1E0C9AE40];
    v70 = v67 == 0;
    goto LABEL_197;
  }
  if (CFEqual(a2, CFSTR("FBP_NetworkServiceType")))
  {
    Copy = *(const void **)(DerivedStorage + 256);
    goto LABEL_120;
  }
  if (CFEqual(a2, CFSTR("FBP_StartupStatistics")))
  {
    NetworkStatistics = segPumpCreateStartupStatistics(DerivedStorage, (CFAllocatorRef)a3, (CFMutableDictionaryRef *)a4);
    goto LABEL_193;
  }
  if (CFEqual(a2, CFSTR("FBP_RecoveryAlternate")))
  {
    v38 = segPumpCopyRecoveryAlternateIfViable(DerivedStorage);
    goto LABEL_84;
  }
  if (CFEqual(a2, CFSTR("FBP_MinimizeNetworkingWhilePaused")))
  {
    a3 = 0;
    v67 = *(unsigned __int8 *)(DerivedStorage + 7995);
    goto LABEL_196;
  }
  if (CFEqual(a2, CFSTR("FBP_InitialBandwidthTargetForNetwork")))
  {
    if (segPumpConnectedInterfaceIsWWAN(DerivedStorage))
    {
      v38 = *(CFTypeRef *)(DerivedStorage + 192);
      if (!v38)
        goto LABEL_84;
    }
    else
    {
      v38 = *(CFTypeRef *)(DerivedStorage + 200);
      if (!v38)
        goto LABEL_84;
    }
    goto LABEL_83;
  }
  if (CFEqual(a2, CFSTR("FPB_CPECryptorsForSessionCryptKeys")))
  {
    AccessLog = segPumpCreateCPECryptorsSessionCryptKeysDict(DerivedStorage, a4);
    goto LABEL_49;
  }
  if (CFEqual(a2, CFSTR("FBP_ReportingAgent")))
  {
    v71 = *(const void **)(DerivedStorage + 9048);
    if (v71)
    {
      CFRetain(v71);
      v55 = *(const void **)(DerivedStorage + 9048);
    }
    else
    {
      v55 = 0;
    }
    a3 = 0;
    goto LABEL_140;
  }
  if (CFEqual(a2, CFSTR("FBP_LiveUpdateInterval")))
  {
    v51 = (CMTimeRange *)(DerivedStorage + 8);
    if (!*(_DWORD *)(DerivedStorage + 8))
      goto LABEL_86;
    if (*(_BYTE *)(DerivedStorage + 8002) || *(_DWORD *)(DerivedStorage + 24) > 1u)
    {
      a3 = 4294954509;
      goto LABEL_87;
    }
    goto LABEL_224;
  }
  if (CFEqual(a2, CFSTR("FBP_DownloadDestinationURL")))
  {
    v72 = *(_QWORD *)(DerivedStorage + 296);
    if (!v72)
      goto LABEL_86;
    v73 = FigGetAllocatorForMedia();
    FigStreamingCacheCopyProperty(v72, CFSTR("FSC_DownloadDestinationURL"), v73, a4);
    goto LABEL_171;
  }
  if (CFEqual(a2, CFSTR("FBP_AlternatesInPenaltybox")))
  {
    value.start.value = 0;
    v74 = segPumpCopyAlternatesInPenaltyBox(DerivedStorage, (__CFArray **)&value);
    goto LABEL_233;
  }
  if (CFEqual(a2, CFSTR("FBP_MaxOverlapDurationForSwitching")))
  {
    v51 = (CMTimeRange *)(DerivedStorage + 8);
    if (!*(_DWORD *)(DerivedStorage + 8))
      goto LABEL_86;
LABEL_224:
    v50 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v52 = kCFNumberSInt32Type;
    goto LABEL_137;
  }
  if (CFEqual(a2, CFSTR("FBP_PrefersConcurrentSwitch")))
  {
    a3 = 0;
    v67 = *(unsigned __int8 *)(DerivedStorage + 329);
    goto LABEL_196;
  }
  if (CFEqual(a2, CFSTR("FBP_NetworkUrgencyMonitor")))
  {
    Copy = *(const void **)(DerivedStorage + 9512);
    if (!Copy)
      goto LABEL_86;
    goto LABEL_120;
  }
  if (CFEqual(a2, CFSTR("FBP_NominalVideoFramerate")))
  {
    segPumpCopyNominalVideoFrameRate(DerivedStorage, (CFNumberRef *)a4);
    v40 = *a4 == 0;
    goto LABEL_93;
  }
  if (CFEqual(a2, CFSTR("FBP_HasAlternates")))
  {
    a3 = 0;
    v68 = (const void **)MEMORY[0x1E0C9AE50];
    v69 = (const void **)MEMORY[0x1E0C9AE40];
    v70 = *(_QWORD *)(DerivedStorage + 8096) == 0;
LABEL_197:
    if (v70)
      v54 = v69;
    else
      v54 = v68;
LABEL_139:
    v55 = *v54;
LABEL_140:
    *a4 = v55;
    goto LABEL_87;
  }
  if (CFEqual(a2, CFSTR("FBP_SessionKeys")))
  {
    value.start.value = 0;
    v74 = segPumpCopySessionKeys(DerivedStorage, (__CFArray **)&value);
LABEL_233:
    LODWORD(a3) = v74;
    if (!v74)
      *a4 = (CFTypeRef)value.start.value;
    goto LABEL_15;
  }
  if (CFEqual(a2, CFSTR("FBP_LastMediaFileInterfaceType")))
  {
    if (!*(_DWORD *)(DerivedStorage + 8464))
      goto LABEL_86;
    v51 = (CMTimeRange *)(DerivedStorage + 8464);
    v50 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v52 = kCFNumberIntType;
    goto LABEL_137;
  }
  if (!CFEqual(a2, CFSTR("FBP_NetworkCostMonitor")))
  {
    if (CFEqual(a2, CFSTR("FBP_PlaybackRateMonitor")))
    {
      Copy = *(const void **)(DerivedStorage + 9560);
      if (!Copy)
        goto LABEL_46;
      goto LABEL_120;
    }
    if (CFEqual(a2, CFSTR("FBP_EnableContentSteering")))
    {
      a3 = 0;
      v67 = *(unsigned __int8 *)(DerivedStorage + 7904);
      goto LABEL_196;
    }
    if (CFEqual(a2, CFSTR("FBP_ContentSteeringMonitor")))
    {
      Copy = *(const void **)(DerivedStorage + 9552);
      if (!Copy)
        goto LABEL_46;
      goto LABEL_120;
    }
    if (CFEqual(a2, CFSTR("FBP_MainSegmentBytesInTransit")))
    {
      value.start.value = (CMTimeValue)segPumpMainSegmentBytesInTransit(DerivedStorage);
      goto LABEL_129;
    }
    if (CFEqual(a2, CFSTR("FBP_PlaylistCache")))
    {
      Copy = *(const void **)(DerivedStorage + 304);
      if (!Copy)
        goto LABEL_46;
      goto LABEL_120;
    }
    if (CFEqual(a2, CFSTR("FBP_ClientNetworkActivity")))
    {
      Copy = *(const void **)(DerivedStorage + 9104);
      if (!Copy)
        goto LABEL_46;
      goto LABEL_120;
    }
    if (CFEqual(a2, CFSTR("FBP_HasFairPlayEncryptedContent")))
    {
      v75 = 0;
      while (1)
      {
        Count = *(const __CFArray **)(DerivedStorage + 7688);
        if (Count)
          Count = (const __CFArray *)CFArrayGetCount(Count);
        if (v75 >= (uint64_t)Count)
          break;
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 7688), v75++);
        if (ValueAtIndex[6] == 1)
          goto LABEL_281;
      }
    }
    else
    {
      if (!CFEqual(a2, CFSTR("FBP_DidTransitionFromLiveToVOD")))
      {
        if (CFEqual(a2, CFSTR("FBP_OfflineInterstitialURLs")))
        {
          AccessLog = segPumpCopyOfflineInterstitialURLs(DerivedStorage, a3, a4);
          goto LABEL_49;
        }
        if (!CFEqual(a2, CFSTR("FBP_CMCDHeaderVendor")))
          goto LABEL_75;
        if (!segPumpEnsureCMCDHeaderVendor(DerivedStorage))
          goto LABEL_86;
        Copy = *(const void **)(DerivedStorage + 9576);
        if (!Copy)
          goto LABEL_46;
        goto LABEL_120;
      }
      if (*(_BYTE *)(DerivedStorage + 8003))
      {
LABEL_281:
        v78 = (const void **)MEMORY[0x1E0C9AE50];
        goto LABEL_290;
      }
    }
    v78 = (const void **)MEMORY[0x1E0C9AE40];
LABEL_290:
    Copy = *v78;
    if (!*v78)
      goto LABEL_46;
    goto LABEL_120;
  }
  LODWORD(a3) = segPumpEnsureNetworkCostMonitor(DerivedStorage, a3);
  if (!(_DWORD)a3)
  {
    Copy = *(const void **)(DerivedStorage + 8472);
    if (!Copy)
      goto LABEL_46;
    goto LABEL_120;
  }
LABEL_15:
  segPumpUnlockAndSendAllPendingNotifications();
  if ((_DWORD)a3 == -15626)
    return 0;
  else
    return a3;
}

uint64_t segPumpSetProperty(const void *a1, const void *a2, NSObject *a3)
{
  uint64_t DerivedStorage;
  CFTypeID v7;
  const void *v8;
  int v9;
  int v10;
  __CFDictionary *v11;
  CFTypeID v12;
  uint64_t v13;
  const __CFAllocator *AllocatorForMedia;
  __CFDictionary *Mutable;
  const void *v16;
  const void *Value;
  const void *v18;
  CFTypeID v19;
  const void *v20;
  uint64_t v21;
  uint64_t (*v22)(uint64_t, __CFString *, __CFDictionary *);
  unsigned int v23;
  NSObject *v24;
  unsigned int v25;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v28;
  NSObject *v29;
  CFTypeID v30;
  uint64_t v31;
  void (*v32)(uint64_t, uint64_t);
  CFTypeID v33;
  CFTypeID v34;
  unsigned int NextCryptKeyForAllStreams;
  CFTypeID v36;
  const void *v37;
  CFTypeID v38;
  const void *v39;
  const void *v40;
  const void *v41;
  CFTypeID v42;
  const __CFData **v43;
  const void *v44;
  CFTypeID v45;
  unsigned int v46;
  uint64_t v47;
  void (*v48)(uint64_t, __CFString *, NSObject *);
  const void *v49;
  const void *v50;
  const void *v51;
  const void *v52;
  const void *v53;
  const void *v54;
  const void *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t (*v58)(uint64_t, _QWORD, uint64_t);
  BOOL v59;
  uint64_t i;
  uint64_t v61;
  CFTypeID v62;
  const void *v63;
  NSObject *v64;
  NSObject *v65;
  BOOL v66;
  CFTypeID v67;
  void *v68;
  const __CFNumber *v69;
  CFNumberType v70;
  const void *v71;
  CFTypeID v72;
  double Seconds;
  CFTypeID v74;
  const void *v75;
  CFTypeID v76;
  CFTypeID v77;
  CMTime time;
  CMTime valuePtr;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigRetainProxyLockMutex();
  if (FigRetainProxyIsInvalidated())
    goto LABEL_208;
  if (CFEqual(a2, CFSTR("FBP_SendToNero")))
  {
    if (a3)
    {
      v7 = CFGetTypeID(a3);
      if (v7 == CFDictionaryGetTypeID())
      {
        CFDictionaryGetValue((CFDictionaryRef)a3, CFSTR("FBPSTN_Video"));
        v8 = (const void *)*MEMORY[0x1E0C9AE50];
        v9 = FigCFEqual();
        v10 = v9;
        if (*(unsigned __int8 *)(DerivedStorage + 7992) == v9)
        {
          v11 = 0;
          goto LABEL_30;
        }
        *(_BYTE *)(DerivedStorage + 7992) = v9;
        segPumpResetContentKeyState(a1);
        AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
        Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        if (Mutable)
        {
          v11 = Mutable;
          if (v10)
            v16 = v8;
          else
            v16 = (const void *)*MEMORY[0x1E0C9AE40];
          CFDictionarySetValue(Mutable, CFSTR("kFigCKSPropertyKeySendToNero_Visuals"), v16);
          if (*(_BYTE *)(DerivedStorage + 7992))
          {
            Value = CFDictionaryGetValue((CFDictionaryRef)a3, CFSTR("FBPSTN_NeroTransport"));
            if (Value)
            {
              v18 = *(const void **)(DerivedStorage + 9520);
              *(_QWORD *)(DerivedStorage + 9520) = Value;
              CFRetain(Value);
              if (v18)
                CFRelease(v18);
              CFDictionarySetValue(v11, CFSTR("kFigCKSPropertyKeySendToNero_NeroTransport"), *(const void **)(DerivedStorage + 9520));
            }
            else
            {
              FigSignalErrorAt();
            }
          }
          else
          {
            v20 = *(const void **)(DerivedStorage + 9520);
            if (v20)
            {
              CFRelease(v20);
              *(_QWORD *)(DerivedStorage + 9520) = 0;
            }
          }
          v21 = *(_QWORD *)(DerivedStorage + 9472);
          v22 = *(uint64_t (**)(uint64_t, __CFString *, __CFDictionary *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                              + 8)
                                                                                  + 56);
          if (v22)
          {
            v23 = v22(v21, CFSTR("kFigCKSPropertyKey_SendToNero"), v11);
            if (!v23)
            {
              if (!*(_BYTE *)(DerivedStorage + 7992))
              {
                if (dword_1EE2A31E8)
                {
                  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                  os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
                  fig_log_call_emit_and_clean_up_after_send_and_compose();
                }
                v31 = *(_QWORD *)(DerivedStorage + 9488);
                if (v31)
                {
                  v32 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 72);
                  if (v32)
                    v32(v31, 4);
                }
              }
LABEL_30:
              if (dword_1EE2A31E8)
              {
                v24 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT);
                fig_log_call_emit_and_clean_up_after_send_and_compose();
              }
              v25 = 0;
              v13 = 0;
              if (!v11)
                goto LABEL_33;
              goto LABEL_35;
            }
            v25 = v23;
          }
          else
          {
            v25 = -12782;
          }
LABEL_35:
          CFRelease(v11);
          goto LABEL_36;
        }
      }
    }
    goto LABEL_208;
  }
  if (CFEqual(a2, CFSTR("FBP_CacheIFrames")))
  {
    if (a3)
    {
      v12 = CFGetTypeID(a3);
      if (v12 == CFBooleanGetTypeID())
      {
        v13 = 0;
        *(_BYTE *)(DerivedStorage + 7996) = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
LABEL_33:
        segPumpUnlockAndSendAllPendingNotifications();
        return v13;
      }
    }
    goto LABEL_208;
  }
  if (CFEqual(a2, CFSTR("FBP_CacheNonIFrames")))
  {
    if (a3)
    {
      v19 = CFGetTypeID(a3);
      if (v19 == CFBooleanGetTypeID())
      {
        v13 = 0;
        *(_BYTE *)(DerivedStorage + 7997) = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
        goto LABEL_33;
      }
    }
LABEL_208:
    NextCryptKeyForAllStreams = FigSignalErrorAt();
    goto LABEL_209;
  }
  if (CFEqual(a2, CFSTR("FBP_CacheMediaSegmentsToDisk")))
  {
    v28 = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
    if (*(unsigned __int8 *)(DerivedStorage + 7998) != v28)
    {
      if (dword_1EE2A31E8)
      {
        v29 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      v13 = 0;
      *(_BYTE *)(DerivedStorage + 7998) = v28;
      goto LABEL_33;
    }
    goto LABEL_58;
  }
  if (CFEqual(a2, CFSTR("FBP_NetworkReadsAreOpportunistic")))
  {
    if (a3)
    {
      v30 = CFGetTypeID(a3);
      if (v30 == CFBooleanGetTypeID())
      {
        v13 = 0;
        *(_BYTE *)(DerivedStorage + 7999) = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
        goto LABEL_33;
      }
    }
    goto LABEL_208;
  }
  if (CFEqual(a2, CFSTR("FBP_NetworkReadsContributeToGlobalHistory")))
  {
    if (!a3)
      goto LABEL_208;
    v33 = CFGetTypeID(a3);
    if (v33 != CFBooleanGetTypeID())
      goto LABEL_208;
    segPumpSetNetworkReadsContributeToNetworkHistory(DerivedStorage, *MEMORY[0x1E0C9AE50] == (_QWORD)a3);
    goto LABEL_58;
  }
  if (!CFEqual(a2, CFSTR("FBP_SegmentCache")))
  {
    if (CFEqual(a2, CFSTR("FBP_PlaylistCache")))
    {
      if (a3)
      {
        v36 = CFGetTypeID(a3);
        if (v36 != FigStreamingCacheGetTypeID())
          goto LABEL_208;
        v37 = *(const void **)(DerivedStorage + 304);
        *(_QWORD *)(DerivedStorage + 304) = a3;
        CFRetain(a3);
      }
      else
      {
        v37 = *(const void **)(DerivedStorage + 304);
        *(_QWORD *)(DerivedStorage + 304) = 0;
      }
      if (v37)
        CFRelease(v37);
LABEL_58:
      v13 = 0;
      goto LABEL_33;
    }
    if (CFEqual(a2, CFSTR("FBP_ExternalProtectionMethods")))
    {
      if (!a3)
        goto LABEL_208;
      v38 = CFGetTypeID(a3);
      if (v38 != CFNumberGetTypeID())
        goto LABEL_208;
      if (!FigCFEqual())
      {
        v39 = *(const void **)(DerivedStorage + 264);
        *(_QWORD *)(DerivedStorage + 264) = a3;
        CFRetain(a3);
        if (v39)
          CFRelease(v39);
        v40 = *(const void **)(DerivedStorage + 272);
        if (v40)
        {
          CFRelease(v40);
          *(_QWORD *)(DerivedStorage + 272) = 0;
        }
        v41 = *(const void **)(DerivedStorage + 280);
        if (v41)
        {
          CFRelease(v41);
          *(_QWORD *)(DerivedStorage + 280) = 0;
        }
        segPumpEnsureAndSetupBasicAESProtector(DerivedStorage);
      }
      goto LABEL_58;
    }
    if (CFEqual(a2, CFSTR("FBP_ClientAuditToken")))
    {
      if (a3)
      {
        v42 = CFGetTypeID(a3);
        if (v42 != CFDataGetTypeID())
          goto LABEL_208;
        v43 = (const __CFData **)(DerivedStorage + 8888);
        v44 = *(const void **)(DerivedStorage + 8888);
        *(_QWORD *)(DerivedStorage + 8888) = a3;
        CFRetain(a3);
      }
      else
      {
        v43 = (const __CFData **)(DerivedStorage + 8888);
        v44 = *(const void **)(DerivedStorage + 8888);
        *(_QWORD *)(DerivedStorage + 8888) = 0;
      }
      if (v44)
        CFRelease(v44);
      v51 = *(const void **)(DerivedStorage + 8896);
      if (v51)
      {
        CFRelease(v51);
        *(_QWORD *)(DerivedStorage + 8896) = 0;
      }
      *(_QWORD *)(DerivedStorage + 8896) = FigCFHTTPCopyClientProcessName(*(const __CFData **)(DerivedStorage + 8888));
      v25 = segPumpSetHTTPRequestOptionsValue(DerivedStorage, CFSTR("FHRP_ClientAuditToken"), a3);
      if (v25)
        goto LABEL_36;
      v52 = (const void *)FigCFHTTPCopyClientBundleIdentifier(*v43);
      if (v52)
      {
        v53 = v52;
        segPumpSetHTTPRequestOptionsValue(DerivedStorage, CFSTR("FHRP_ClientBundleIdentifier"), v52);
        CFRelease(v53);
      }
      v54 = *(const void **)(DerivedStorage + 8432);
      if (v54)
      {
        v55 = *(const void **)(DerivedStorage + 8440);
        if (v55)
        {
          CFRelease(v55);
          *(_QWORD *)(DerivedStorage + 8440) = 0;
          v54 = *(const void **)(DerivedStorage + 8432);
        }
        AttemptNetworkMonitorSetup((_QWORD *)DerivedStorage, v54);
      }
      v56 = *(_QWORD *)(DerivedStorage + 9472);
      v57 = *(_QWORD *)(DerivedStorage + 8888);
      v58 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
      if (!v58)
      {
        v13 = 4294954514;
        goto LABEL_33;
      }
      NextCryptKeyForAllStreams = v58(v56, *MEMORY[0x1E0CA3088], v57);
      goto LABEL_209;
    }
    if (CFEqual(a2, CFSTR("FBP_ClientBundleIdentifier")))
    {
      if (a3)
      {
        v45 = CFGetTypeID(a3);
        if (v45 != CFStringGetTypeID())
          goto LABEL_208;
      }
      v46 = segPumpSetHTTPRequestOptionsValue(DerivedStorage, CFSTR("FHRP_ClientBundleIdentifier"), a3);
      v47 = *(_QWORD *)(DerivedStorage + 96);
      v48 = *(void (**)(uint64_t, __CFString *, NSObject *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
      if (v48)
        v48(v47, CFSTR("NetworkPredictorProperty_ClientBundleIdentifier"), a3);
      v25 = v46;
      if (v46)
        goto LABEL_36;
      v49 = *(const void **)(DerivedStorage + 8432);
      if (v49)
      {
        v50 = *(const void **)(DerivedStorage + 8440);
        if (v50)
        {
          CFRelease(v50);
          *(_QWORD *)(DerivedStorage + 8440) = 0;
          v49 = *(const void **)(DerivedStorage + 8432);
        }
        AttemptNetworkMonitorSetup((_QWORD *)DerivedStorage, v49);
      }
      goto LABEL_58;
    }
    if (CFEqual(a2, CFSTR("FBP_PrefetchKeys")))
    {
      v59 = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
      *(_BYTE *)(DerivedStorage + 7994) = v59;
      if (!v59)
        goto LABEL_58;
      NextCryptKeyForAllStreams = segPumpReadNextCryptKeyForAllStreams((uint64_t)a1, DerivedStorage);
      goto LABEL_209;
    }
    if (CFEqual(a2, CFSTR("FBP_MinimizeNetworkingWhilePaused")))
    {
      v59 = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
      *(_BYTE *)(DerivedStorage + 7995) = v59;
      if (!v59)
      {
        for (i = 384; i != 432; i += 16)
        {
          v61 = *(_QWORD *)(DerivedStorage + i);
          if (*(_QWORD *)(v61 + 16) && *(_BYTE *)(v61 + 1169))
          {
            segPumpReadOrScheduleIndexFileRead((uint64_t)a1, DerivedStorage, *(_QWORD *)(DerivedStorage + i));
            *(_BYTE *)(v61 + 1169) = 0;
          }
          v13 = 0;
        }
        goto LABEL_33;
      }
      goto LABEL_58;
    }
    if (CFEqual(a2, CFSTR("FBP_NetworkServiceType")))
    {
      if (a3)
      {
        v62 = CFGetTypeID(a3);
        if (v62 != CFNumberGetTypeID())
          goto LABEL_208;
        v63 = *(const void **)(DerivedStorage + 256);
        *(_QWORD *)(DerivedStorage + 256) = a3;
        CFRetain(a3);
      }
      else
      {
        v63 = *(const void **)(DerivedStorage + 256);
        *(_QWORD *)(DerivedStorage + 256) = 0;
      }
      if (v63)
        CFRelease(v63);
      NextCryptKeyForAllStreams = segPumpSetHTTPRequestOptionsValue(DerivedStorage, CFSTR("FHRP_NetworkServiceType"), a3);
      goto LABEL_209;
    }
    if (CFEqual(a2, CFSTR("FBP_Scheduler")))
    {
      if (*(_BYTE *)(DerivedStorage + 8684))
        goto LABEL_208;
      FigHTTPSchedulerRelease(*(dispatch_object_t *)(DerivedStorage + 64));
      *(_QWORD *)(DerivedStorage + 64) = FigHTTPSchedulerRetain(a3);
      FigHTTPSchedulerRelease(*(dispatch_object_t *)(DerivedStorage + 72));
      *(_QWORD *)(DerivedStorage + 72) = FigHTTPSchedulerRetain(a3);
      if (*(_QWORD *)(DerivedStorage + 9528))
      {
        v64 = *(NSObject **)(DerivedStorage + 9536);
        if (v64)
        {
          FigHTTPSchedulerRelease(v64);
          v13 = 0;
          *(_QWORD *)(DerivedStorage + 9536) = FigHTTPSchedulerRetain(a3);
          goto LABEL_33;
        }
      }
      goto LABEL_58;
    }
    if (CFEqual(a2, CFSTR("FBP_PersistCurrentAlternate")))
    {
      NextCryptKeyForAllStreams = segPumpMarkCurrentAlternatePersistentInCache(DerivedStorage, *MEMORY[0x1E0C9AE50] == (_QWORD)a3);
      goto LABEL_209;
    }
    if (CFEqual(a2, CFSTR("FBP_StoreCryptKeysInCache")))
    {
      NextCryptKeyForAllStreams = segPumpSetShouldStoreCryptKeysInCache(DerivedStorage, *MEMORY[0x1E0C9AE50] == (_QWORD)a3);
      goto LABEL_209;
    }
    if (CFEqual(a2, CFSTR("FBP_RequiresCryptKeysForMediaDelivery")))
    {
      NextCryptKeyForAllStreams = segPumpSetRequiresCryptKeysForMediaDelivery(DerivedStorage, *MEMORY[0x1E0C9AE50] == (_QWORD)a3);
      goto LABEL_209;
    }
    if (CFEqual(a2, CFSTR("FBP_EnableCryptKeyRequests")))
    {
      v65 = *MEMORY[0x1E0C9AE50];
      v66 = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
      v67 = CFGetTypeID(a3);
      if (v67 == CFBooleanGetTypeID() && (v65 == a3 || !*(_BYTE *)(DerivedStorage + 322)))
      {
        v13 = 0;
        *(_BYTE *)(DerivedStorage + 323) = v66;
        goto LABEL_33;
      }
      goto LABEL_208;
    }
    if (CFEqual(a2, CFSTR("FBP_EnablePenaltyBox")))
    {
      v13 = 0;
      *(_BYTE *)(DerivedStorage + 8176) = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
      goto LABEL_33;
    }
    if (CFEqual(a2, CFSTR("FBP_EnableNetworkRetry")))
    {
      v13 = 0;
      *(_BYTE *)(DerivedStorage + 8177) = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
      goto LABEL_33;
    }
    if (CFEqual(a2, CFSTR("FBP_RetryTimeout")))
    {
      *(_BYTE *)(DerivedStorage + 8178) = a3 != 0;
      if (!a3)
        goto LABEL_58;
      v68 = (void *)(DerivedStorage + 8184);
      v69 = (const __CFNumber *)a3;
      v70 = kCFNumberSInt64Type;
    }
    else
    {
      if (CFEqual(a2, CFSTR("FBP_PumpClientName")))
      {
        v71 = *(const void **)(DerivedStorage + 9464);
        *(_QWORD *)(DerivedStorage + 9464) = a3;
        if (a3)
          CFRetain(a3);
        if (v71)
          CFRelease(v71);
        segPumpRTCReportingUpdatePumpClientName((_QWORD *)DerivedStorage);
        goto LABEL_58;
      }
      if (CFEqual(a2, CFSTR("FBP_AlternatesInPenaltybox")))
      {
        NextCryptKeyForAllStreams = segPumpSetAlternatesInPenaltyBox(DerivedStorage, a3);
        goto LABEL_209;
      }
      if (CFEqual(a2, CFSTR("FBP_DisallowsExpensiveNetwork")))
      {
        v13 = 0;
        *(_BYTE *)(DerivedStorage + 325) = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
        goto LABEL_33;
      }
      if (CFEqual(a2, CFSTR("FBP_DisallowsConstrainedNetwork")))
      {
        v13 = 0;
        *(_BYTE *)(DerivedStorage + 326) = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
        goto LABEL_33;
      }
      if (CFEqual(a2, CFSTR("FBP_PrebufferReservation")))
      {
        if (a3)
        {
          v72 = CFGetTypeID(a3);
          if (v72 != CFDictionaryGetTypeID())
            goto LABEL_208;
          memset(&valuePtr, 0, sizeof(valuePtr));
          CMTimeMakeFromDictionary(&valuePtr, (CFDictionaryRef)a3);
          if ((valuePtr.flags & 0x1D) == 1)
          {
            time = valuePtr;
            Seconds = CMTimeGetSeconds(&time);
            segPumpSetExtraHoldbackFromClient((uint64_t)a1, DerivedStorage, Seconds);
          }
        }
        goto LABEL_58;
      }
      if (!CFEqual(a2, CFSTR("FBP_InitialPlaylistDownloadTimeout")))
      {
        if (CFEqual(a2, CFSTR("FBP_AlternateSelectionBoss")))
        {
          v75 = *(const void **)(DerivedStorage + 9528);
          *(_QWORD *)(DerivedStorage + 9528) = a3;
          if (a3)
            CFRetain(a3);
          if (v75)
            CFRelease(v75);
          NextCryptKeyForAllStreams = segPumpInitAlternateSelectionBoss((uint64_t)a1, DerivedStorage);
          goto LABEL_209;
        }
        if (CFEqual(a2, CFSTR("FBP_CoalesceByteRangeMediaSegmentRequests")))
        {
          v13 = 0;
          *(_BYTE *)(DerivedStorage + 8208) = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
          goto LABEL_33;
        }
        if (CFEqual(a2, CFSTR("FBP_AllowPipelinedMediaSegmentRequests")))
        {
          v13 = 0;
          *(_BYTE *)(DerivedStorage + 8209) = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
          goto LABEL_33;
        }
        if (CFEqual(a2, CFSTR("FBP_EnableSuggestedAlternate")))
        {
          v13 = 0;
          *(_BYTE *)(DerivedStorage + 8240) = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
          goto LABEL_33;
        }
        if (CFEqual(a2, CFSTR("FBP_NetworkHistory")))
        {
          if (!a3)
            goto LABEL_208;
          v76 = CFGetTypeID(a3);
          if (v76 != FigNetworkHistoryGetCFTypeID())
            goto LABEL_208;
          segPumpSetNetworkHistory(DerivedStorage, a3);
          goto LABEL_58;
        }
        if (CFEqual(a2, CFSTR("FBP_EnableContentSteering")))
        {
          v13 = 0;
          *(_BYTE *)(DerivedStorage + 7904) = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
          goto LABEL_33;
        }
        if (CFEqual(a2, CFSTR("FBP_ContentSteeringMonitor")))
        {
          if (a3)
          {
            v77 = CFGetTypeID(a3);
            if (v77 != FigAlternateFilterMonitorGetTypeID())
              goto LABEL_208;
          }
          segPumpSetContentSteeringMonitor(DerivedStorage, a3);
          goto LABEL_58;
        }
        if (CFEqual(a2, CFSTR("FBP_MaxPipelinedMediaConnections")))
        {
          LODWORD(valuePtr.value) = 0;
          CFNumberGetValue((CFNumberRef)a3, kCFNumberIntType, &valuePtr);
          NextCryptKeyForAllStreams = segPumpSetMaxPipelinedConnections(DerivedStorage, valuePtr.value);
        }
        else if (CFEqual(a2, CFSTR("FBP_ReportingAgent")))
        {
          NextCryptKeyForAllStreams = segPumpSetRTCReportingAgent((_QWORD *)DerivedStorage, a3);
        }
        else
        {
          if (!CFEqual(a2, CFSTR("FBP_MetricEventTimeline")))
            goto LABEL_208;
          NextCryptKeyForAllStreams = segPumpSetMetricEventTimeline((uint64_t)a1, DerivedStorage, a3);
        }
        goto LABEL_209;
      }
      if (!a3)
        goto LABEL_58;
      v74 = CFGetTypeID(a3);
      if (v74 != CFNumberGetTypeID())
        goto LABEL_208;
      v68 = (void *)(DerivedStorage + 8200);
      v69 = (const __CFNumber *)a3;
      v70 = kCFNumberDoubleType;
    }
    CFNumberGetValue(v69, v70, v68);
    goto LABEL_58;
  }
  if (a3)
  {
    v34 = CFGetTypeID(a3);
    if (v34 != FigStreamingCacheGetTypeID())
      goto LABEL_208;
  }
  if (*(NSObject **)(DerivedStorage + 296) == a3)
    goto LABEL_58;
  NextCryptKeyForAllStreams = segPumpSetMediaSegmentCache(DerivedStorage, a3);
LABEL_209:
  v25 = NextCryptKeyForAllStreams;
LABEL_36:
  segPumpUnlockAndSendAllPendingNotifications();
  if (v25 == -15626)
    return 0;
  else
    return v25;
}

void segPumpFreeSavedEntry(uint64_t a1, CFTypeRef *a2)
{
  CFTypeRef *v3;
  CFTypeRef *v4;
  CFTypeRef v5;
  CFTypeRef v6;
  CFTypeRef v7;

  v3 = *(CFTypeRef **)(a1 + 352);
  if (v3 == a2)
  {
    v4 = (CFTypeRef *)(a1 + 352);
  }
  else
  {
    do
    {
      v4 = v3;
      v3 = (CFTypeRef *)*v3;
    }
    while (v3 != a2);
  }
  v5 = *a2;
  *v4 = *a2;
  if (!v5)
    *(_QWORD *)(a1 + 360) = v4;
  CFRelease(a2[1]);
  v6 = a2[2];
  if (v6)
    CFRelease(v6);
  v7 = a2[5];
  if (v7)
    CFRelease(v7);
  free((void *)a2[6]);
  free(a2);
}

double segPumpResetConnection(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  void (*v5)(uint64_t);
  const void *v6;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t);
  const void *v11;
  const void *v12;
  double result;

  if (a2)
  {
    v4 = *(_QWORD *)(a2 + 16);
    if (v4)
    {
      v5 = *(void (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 24);
      if (v5)
        v5(v4);
    }
    FigHTTPStopAndReleaseTimer((dispatch_object_t *)(a2 + 96));
    v6 = *(const void **)(a2 + 16);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(a2 + 16) = 0;
    }
    v7 = *(const void **)(a2 + 8);
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(a2 + 8) = 0;
    }
    v8 = *(_QWORD *)(a2 + 88);
    if (v8)
    {
      v9 = *(_QWORD *)(a1 + 80);
      if (v9)
      {
        v10 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
        if (v10)
          v10(v9, v8);
      }
      *(_QWORD *)(a2 + 88) = 0;
    }
    if (*(_QWORD *)a2)
    {
      CFRelease(*(CFTypeRef *)a2);
      *(_QWORD *)a2 = 0;
    }
    v11 = *(const void **)(a2 + 112);
    if (v11)
    {
      CFRelease(v11);
      *(_QWORD *)(a2 + 112) = 0;
    }
    v12 = *(const void **)(a2 + 72);
    if (v12)
    {
      CFRelease(v12);
      *(_QWORD *)(a2 + 72) = 0;
    }
    *(_QWORD *)(a2 + 120) = 0;
    *(_WORD *)(a2 + 128) = 0;
    *(_QWORD *)(a2 + 104) = 0;
    *(_DWORD *)(a2 + 80) = 0;
    result = 0.0;
    *(_OWORD *)(a2 + 24) = 0u;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 52) = 0u;
  }
  return result;
}

void segPumpCancelMediaFileReadAndResetData(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v8;
  const void *v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;
  const void *v13;
  CFTypeRef v14;
  const void *v15;
  _QWORD *MediaFilePrivateData;
  const void *v17;
  const void *v18;
  CFTypeRef *v19;
  const void *v20;
  CFTypeRef v21;
  uint64_t v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  __int128 v28;
  __int128 v29;

  if (*(uint64_t *)(a2 + 776) >= 1)
  {
    v8 = 0;
    do
    {
      segPumpStreamCancelReadAheadAndResetDataAtIndex(a1, a2, 0);
      ++v8;
    }
    while (v8 < *(_QWORD *)(a2 + 776));
  }
  segPumpStreamCancelPreloadReadAndResetData(a1, a2);
  segPumpStreamCancelPreloadMapReadAndResetData(a1, a2);
  v9 = *(const void **)(a2 + 840);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a2 + 840) = 0;
  }
  v10 = *(uint64_t **)(a2 + 680);
  if (v10)
  {
    while (1)
    {
      v11 = v10[9];
      v12 = *((_DWORD *)v10 + 20);
      v13 = (const void *)v10[11];
      v28 = *(_OWORD *)(v10 + 7);
      v29 = *(_OWORD *)(v10 + 5);
      v14 = v13 ? CFRetain(v13) : 0;
      v15 = (const void *)v10[1];
      if (v15)
        break;
LABEL_20:
      segPumpResetMediaConnection(a1, v10, a3);
      if (a4)
      {
        *(_OWORD *)(v10 + 5) = v29;
        *(_OWORD *)(v10 + 7) = v28;
        v10[9] = v11;
        *((_DWORD *)v10 + 20) = v12;
        if (v14)
          v21 = CFRetain(v14);
        else
          v21 = 0;
        v10[11] = (uint64_t)v21;
      }
      if (v14)
        CFRelease(v14);
      v10 = (uint64_t *)*v10;
      if (!v10)
        goto LABEL_28;
    }
    MediaFilePrivateData = segPumpGetMediaFilePrivateData(v15);
    v17 = (const void *)v10[1];
    if (v17)
    {
      if (FigMediaSegmentSpecifierGetType((uint64_t)v17) == 1)
      {
        v18 = *(const void **)(a2 + 288);
        if (v18)
        {
          CFRelease(v18);
          *(_QWORD *)(a2 + 288) = 0;
          *(_QWORD *)(a2 + 320) = -1;
        }
LABEL_18:
        MediaFilePrivateData[13] = 0;
        MediaFilePrivateData[14] = 0;
        MediaFilePrivateData[15] = 0;
        v20 = (const void *)v10[1];
        if (v20)
        {
          CFRelease(v20);
          v10[1] = 0;
        }
        goto LABEL_20;
      }
      v17 = (const void *)v10[1];
    }
    if (*((_QWORD *)segPumpGetMediaFilePrivateData(v17) + 2))
    {
      v19 = (CFTypeRef *)segPumpGetMediaFilePrivateData((const void *)v10[1]);
      CFRelease(v19[2]);
      *((_QWORD *)segPumpGetMediaFilePrivateData((const void *)v10[1]) + 2) = 0;
    }
    goto LABEL_18;
  }
LABEL_28:
  v22 = *(_QWORD *)(a2 + 760);
  if (v22 >= 1)
    bzero((void *)(a2 + 696), 8 * v22);
  *(_QWORD *)(a2 + 696) = *(_QWORD *)(a2 + 680);
  v23 = *(const void **)(a2 + 256);
  if (v23)
  {
    CFRelease(v23);
    *(_QWORD *)(a2 + 256) = 0;
  }
  v24 = *(const void **)(a2 + 264);
  if (v24)
  {
    CFRelease(v24);
    *(_QWORD *)(a2 + 264) = 0;
  }
  v25 = *(const void **)(a2 + 840);
  if (v25)
  {
    CFRelease(v25);
    *(_QWORD *)(a2 + 840) = 0;
  }
  v26 = *(const void **)(a2 + 832);
  if (v26)
  {
    CFRelease(v26);
    *(_QWORD *)(a2 + 832) = 0;
  }
  *(_QWORD *)(a2 + 848) = 0;
  *(_BYTE *)(a2 + 403) = 0;
  if (!*(_BYTE *)(a2 + 870))
    *(_BYTE *)(a2 + 869) = 0;
  *(_BYTE *)(a2 + 871) = 0;
  *(_BYTE *)(a2 + 1136) = 0;
  v27 = *(const void **)(a2 + 1144);
  if (v27)
  {
    CFRelease(v27);
    *(_QWORD *)(a2 + 1144) = 0;
  }
}

void segPumpResetMediaConnection(uint64_t a1, _QWORD *a2, int a3)
{
  const void *v6;
  const void *v7;
  const void *v8;

  segPumpResetConnection(a1, (uint64_t)(a2 + 2));
  if (!a3)
    segPumpStreamDontReuseHTTPRequest(a1, (uint64_t)a2);
  a2[30] = 0;
  a2[31] = 0;
  v6 = (const void *)a2[34];
  if (v6)
  {
    CFRelease(v6);
    a2[34] = 0;
  }
  v7 = (const void *)a2[21];
  if (v7)
  {
    CFRelease(v7);
    a2[21] = 0;
  }
  a2[27] = 0;
  a2[28] = 0;
  a2[29] = 0;
  v8 = (const void *)a2[1];
  if (v8)
  {
    CFRelease(v8);
    a2[1] = 0;
  }
  a2[37] = 0;
  a2[38] = 0;
}

void segPumpCompleteNWAlternateForStream(uint64_t a1)
{
  const void *v2;
  const void *v3;

  if (*(_QWORD *)(a1 + 1192))
  {
    nw_activity_complete_with_reason();
    v2 = *(const void **)(a1 + 1192);
    if (v2)
    {
      CFRelease(v2);
      *(_QWORD *)(a1 + 1192) = 0;
    }
  }
  if (*(_QWORD *)(a1 + 1184))
  {
    nw_activity_complete_with_reason();
    v3 = *(const void **)(a1 + 1184);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(a1 + 1184) = 0;
    }
  }
}

void segPumpStreamCancelPreloadReadAndResetData(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  const void *v4;
  const void *v5;

  v3 = *(_QWORD **)(a2 + 792);
  if (v3)
  {
    if (v3[4] || v3[13])
    {
      segPumpResetMediaConnection(a1, v3, 0);
    }
    else
    {
      v4 = (const void *)v3[34];
      if (v4)
      {
        CFRelease(v4);
        v3 = *(_QWORD **)(a2 + 792);
        v3[34] = 0;
      }
      v5 = (const void *)v3[1];
      if (v5)
      {
        CFRelease(v5);
        *(_QWORD *)(*(_QWORD *)(a2 + 792) + 8) = 0;
      }
    }
    *(_QWORD *)(a2 + 792) = 0;
  }
}

void segPumpStreamCancelPreloadMapReadAndResetData(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  const void *v4;
  const void *v5;

  v3 = *(_QWORD **)(a2 + 800);
  if (v3)
  {
    if (v3[4] || v3[13])
    {
      segPumpResetMediaConnection(a1, v3, 0);
    }
    else
    {
      v4 = (const void *)v3[34];
      if (v4)
      {
        CFRelease(v4);
        v3 = *(_QWORD **)(a2 + 800);
        v3[34] = 0;
      }
      v5 = (const void *)v3[1];
      if (v5)
      {
        CFRelease(v5);
        *(_QWORD *)(*(_QWORD *)(a2 + 800) + 8) = 0;
      }
    }
    *(_QWORD *)(a2 + 800) = 0;
  }
}

const void *segPumpGetMediaFilePrivateData(const void *a1)
{
  const void *Instance;
  __int128 v4;

  Instance = CMGetAttachment(a1, CFSTR("SegPumpMediaFilePrivateData"), 0);
  if (!Instance)
  {
    FigGetAllocatorForMedia();
    v4 = xmmword_1E2FA6FF0;
    if (segPumpMediaFilePrivateDataGetTypeID_once != -1)
      dispatch_once_f(&segPumpMediaFilePrivateDataGetTypeID_once, &v4, (dispatch_function_t)segPumpRegisterClassUtil);
    Instance = (const void *)_CFRuntimeCreateInstance();
    if (Instance)
    {
      CMSetAttachment(a1, CFSTR("SegPumpMediaFilePrivateData"), Instance, 0);
      CFRelease(Instance);
    }
    else
    {
      FigSignalErrorAt();
    }
  }
  return Instance;
}

void segPumpStreamCancelReadAheadAndResetDataAtIndex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const void *v8;
  uint64_t v9;
  const void *v10;

  v4 = *(_QWORD **)(*(_QWORD *)(a2 + 768) + 8 * a3);
  if (v4)
  {
    v5 = a3;
    if (v4[4] || v4[13])
    {
      segPumpResetMediaConnection(a1, v4, 0);
    }
    else
    {
      v8 = (const void *)v4[34];
      if (v8)
      {
        CFRelease(v8);
        v9 = *(_QWORD *)(a2 + 768);
        *(_QWORD *)(*(_QWORD *)(v9 + 8 * v5) + 272) = 0;
        v4 = *(_QWORD **)(v9 + 8 * v5);
      }
      v10 = (const void *)v4[1];
      if (v10)
      {
        CFRelease(v10);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 768) + 8 * v5) + 8) = 0;
      }
    }
    v6 = *(_QWORD *)(a2 + 776);
    if (v6 > v5)
    {
      v7 = v6 - 1;
      if (v7 > v5)
      {
        do
        {
          *(_QWORD *)(*(_QWORD *)(a2 + 768) + 8 * v5) = *(_QWORD *)(*(_QWORD *)(a2 + 768) + 8 * v5 + 8);
          ++v5;
        }
        while (v7 != v5);
      }
      *(_QWORD *)(*(_QWORD *)(a2 + 768) + 8 * v7) = 0;
    }
  }
}

void segPumpMediaFilePrivateDataFinalize(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  v2 = (const void *)a1[16];
  if (v2)
  {
    CFRelease(v2);
    a1[16] = 0;
  }
  v3 = (const void *)a1[26];
  if (v3)
  {
    CFRelease(v3);
    a1[26] = 0;
  }
  v4 = (const void *)a1[27];
  if (v4)
  {
    CFRelease(v4);
    a1[27] = 0;
  }
  v5 = (const void *)a1[2];
  if (v5)
  {
    CFRelease(v5);
    a1[2] = 0;
  }
  v6 = (const void *)a1[3];
  if (v6)
  {
    CFRelease(v6);
    a1[3] = 0;
  }
}

CFStringRef segPumpMediaFilePrivateDataCopyDesc(uint64_t a1)
{
  const __CFAllocator *AllocatorForMedia;

  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  return CFStringCreateWithFormat(AllocatorForMedia, 0, CFSTR("MediaFilePrivateData: %p"), a1);
}

uint64_t segPumpRegisterClassUtil(uint64_t a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  **(_QWORD **)(a1 + 8) = result;
  return result;
}

void segPumpStreamUpdateIndexExpectedArrival(uint64_t a1, uint64_t a2)
{
  const void *SInt64;
  uint64_t v4;
  void (*v5)(uint64_t, const __CFString *, const void *);

  if (*(_QWORD *)(a1 + 9560) && *(_BYTE *)(a1 + 329) && *(_QWORD *)(a1 + 384) == a2)
  {
    SInt64 = (const void *)FigCFNumberCreateSInt64();
    v4 = *(_QWORD *)(a1 + 9560);
    v5 = *(void (**)(uint64_t, const __CFString *, const void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                          + 56);
    if (v5)
      v5(v4, CFSTR("AfmfpbProperty_MainPlaylistExpectedUpdateTime"), SInt64);
    if (SInt64)
      CFRelease(SInt64);
  }
}

void segPumpStreamDontReuseHTTPRequest(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  uint64_t v6;
  void (*v7)(uint64_t);
  const void *v8;
  const void *v9;
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(uint64_t, uint64_t);

  v4 = *(const void **)(a2 + 160);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a2 + 160) = 0;
  }
  v5 = *(const void **)(a2 + 152);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a2 + 152) = 0;
  }
  v6 = *(_QWORD *)(a2 + 32);
  if (v6)
  {
    v7 = *(void (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 24);
    if (v7)
      v7(v6);
    v8 = *(const void **)(a2 + 32);
    if (v8)
    {
      CFRelease(v8);
      *(_QWORD *)(a2 + 32) = 0;
    }
  }
  v9 = *(const void **)(a2 + 24);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a2 + 24) = 0;
  }
  v10 = *(const void **)(a2 + 88);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a2 + 88) = 0;
  }
  *(_BYTE *)(a2 + 145) = 0;
  *(_QWORD *)(a2 + 192) = 0;
  *(_DWORD *)(a2 + 80) = 0;
  v11 = *(_QWORD *)(a2 + 104);
  if (v11)
  {
    v12 = *(_QWORD *)(a1 + 80);
    if (v12)
    {
      v13 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
      if (v13)
        v13(v12, v11);
    }
    *(_QWORD *)(a2 + 104) = 0;
  }
}

void segPumpStreamingCacheDiskWriteErrorCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  CFTypeRef cf;
  unsigned int v11;

  v11 = 0;
  v9 = 0;
  cf = 0;
  if (!segPumpLockAndCopyPumpFromRetainProxy(a2, &cf, &v9) && *(_QWORD *)(v9 + 296) == a4)
  {
    if (a5)
    {
      FigCFDictionaryGetInt32IfPresent();
      v8 = v11;
    }
    else
    {
      v8 = 0;
    }
    segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(a2, v8);
  }
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
}

uint64_t segPumpLockAndCopyPumpFromRetainProxy(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  const void *Owner;
  CFTypeRef v6;
  CFTypeID v7;
  uint64_t DerivedStorage;
  uint64_t result;

  FigRetainProxyLockMutex();
  if (FigRetainProxyIsInvalidated())
    return 4294954413;
  if (a2 && a3)
  {
    Owner = (const void *)FigRetainProxyGetOwner();
    if (Owner)
    {
      v6 = CFRetain(Owner);
      *a2 = v6;
      if (v6)
      {
        v7 = CFGetTypeID(v6);
        if (v7 == FigBytePumpGetTypeID())
        {
          DerivedStorage = CMBaseObjectGetDerivedStorage();
          result = 0;
          *a3 = DerivedStorage;
          return result;
        }
      }
    }
    else
    {
      *a2 = 0;
    }
  }
  return FigSignalErrorAt();
}

void segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf;

  cf = 0;
  if ((_DWORD)a2 != -15626)
  {
    FigCreateErrorForOSStatus(a2, (CFErrorRef *)&cf);
    segPumpSendEndCallbackForAllActiveStreams(a1, (void *)cf);
    if (cf)
      CFRelease(cf);
  }
}

void segPumpUnlockAndSendAllPendingNotifications()
{
  const void *Owner;
  uint64_t DerivedStorage;
  int v2;
  uint64_t v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;

  if (FigRetainProxyIsInvalidated())
  {
    FigRetainProxyUnlockMutex();
    return;
  }
  Owner = (const void *)FigRetainProxyGetOwner();
  CFRetain(Owner);
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (FigRetainProxyGetLockCount() < 2)
  {
    v2 = *(_DWORD *)(DerivedStorage + 8960);
    v3 = DerivedStorage + 8968;
    *(_DWORD *)(DerivedStorage + 8960) = 0;
    v4 = *(const void **)(DerivedStorage + 8968);
    v5 = *(const void **)(DerivedStorage + 8976);
    v6 = *(const void **)(DerivedStorage + 8984);
    v7 = *(const void **)(DerivedStorage + 8992);
    *(_OWORD *)(DerivedStorage + 8968) = 0u;
    *(_OWORD *)(DerivedStorage + 8984) = 0u;
    v8 = *(const void **)(DerivedStorage + 9000);
    v9 = *(const void **)(DerivedStorage + 9008);
    *(_OWORD *)(v3 + 32) = 0u;
    FigRetainProxyUnlockMutex();
    if (!v2)
      goto LABEL_26;
    if ((v2 & 0x20) != 0)
      goto LABEL_25;
    if ((v2 & 2) != 0)
    {
      CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterPostNotification();
      if ((v2 & 0x10) == 0)
      {
LABEL_8:
        if ((v2 & 0x40) == 0)
          goto LABEL_9;
        goto LABEL_19;
      }
    }
    else if ((v2 & 0x10) == 0)
    {
      goto LABEL_8;
    }
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
    if ((v2 & 0x40) == 0)
    {
LABEL_9:
      if ((v2 & 1) == 0)
        goto LABEL_10;
      goto LABEL_20;
    }
LABEL_19:
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
    if ((v2 & 1) == 0)
    {
LABEL_10:
      if ((v2 & 0x80) == 0)
        goto LABEL_11;
      goto LABEL_21;
    }
LABEL_20:
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
    if ((v2 & 0x80) == 0)
    {
LABEL_11:
      if ((v2 & 0x100) == 0)
        goto LABEL_12;
      goto LABEL_22;
    }
LABEL_21:
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
    if ((v2 & 0x100) == 0)
    {
LABEL_12:
      if ((v2 & 0x200) == 0)
        goto LABEL_13;
      goto LABEL_23;
    }
LABEL_22:
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
    if ((v2 & 0x200) == 0)
    {
LABEL_13:
      if ((v2 & 0x400) == 0)
        goto LABEL_14;
      goto LABEL_24;
    }
LABEL_23:
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
    if ((v2 & 0x400) == 0)
    {
LABEL_14:
      if ((v2 & 0x800) == 0)
        goto LABEL_26;
      goto LABEL_25;
    }
LABEL_24:
    CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification();
    if ((v2 & 0x800) != 0)
    {
LABEL_25:
      CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterPostNotification();
    }
LABEL_26:
    if (v4)
      CFRelease(v4);
    if (v5)
      CFRelease(v5);
    if (v6)
      CFRelease(v6);
    if (v7)
      CFRelease(v7);
    if (v8)
      CFRelease(v8);
    if (v9)
      CFRelease(v9);
    goto LABEL_38;
  }
  FigRetainProxyUnlockMutex();
LABEL_38:
  CFRelease(Owner);
}

uint64_t segPumpSendEndCallbackForAllActiveStreams(uint64_t a1, void *a2)
{
  uint64_t v4;
  const void *v5;
  const __CFAllocator *AllocatorForMedia;
  CFDictionaryRef v7;
  int v9[2];
  CFTypeRef cf;
  void *values;

  cf = 0;
  values = a2;
  *(_QWORD *)v9 = 0;
  FigRetainProxyRetain();
  v4 = segPumpLockAndCopyPumpFromRetainProxy(a1, &cf, (uint64_t *)v9);
  if (!(_DWORD)v4
    && !segPumpSentEndCallbackForAllActiveStreams(*(_QWORD **)v9)
    && !FigCFErrorIsEqualToOSStatus((__CFError *)a2, (uint64_t)CFSTR("CoreMediaErrorDomain"), -15626))
  {
    if (a2)
    {
      v5 = *(const void **)(*(_QWORD *)v9 + 8016);
      *(_QWORD *)(*(_QWORD *)v9 + 8016) = a2;
      CFRetain(a2);
      if (v5)
        CFRelease(v5);
      AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
      v7 = CFDictionaryCreate(AllocatorForMedia, (const void **)&kFigBytePumpFatalErrorNotificationValue_Error, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      segPumpReadyNotification(*(_QWORD **)v9, CFSTR("FBP_FatalErrorOccurred"), v7);
      if (v7)
        CFRelease(v7);
    }
    segPumpSendEndCallbackForActiveStream((uint64_t)cf, *(_QWORD *)(*(_QWORD *)v9 + 416), values);
    segPumpSendEndCallbackForActiveStream((uint64_t)cf, *(_QWORD *)(*(_QWORD *)v9 + 400), values);
    segPumpSendEndCallbackForActiveStream((uint64_t)cf, *(_QWORD *)(*(_QWORD *)v9 + 384), values);
    segPumpSendEndCallbackForActiveStream((uint64_t)cf, *(_QWORD *)(*(_QWORD *)v9 + 424), values);
    segPumpSendEndCallbackForActiveStream((uint64_t)cf, *(_QWORD *)(*(_QWORD *)v9 + 408), values);
    segPumpSendEndCallbackForActiveStream((uint64_t)cf, *(_QWORD *)(*(_QWORD *)v9 + 392), values);
  }
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
  FigRetainProxyRelease();
  return v4;
}

uint64_t segPumpSentEndCallbackForAllActiveStreams(_QWORD *a1)
{
  unsigned __int8 v1;
  uint64_t v2;
  uint64_t v3;

  if (*(_BYTE *)(a1[48] + 1136) || *(_BYTE *)(a1[50] + 1136) || (v1 = *(_BYTE *)(a1[52] + 1136)) != 0)
  {
    v2 = 0;
    v1 = 1;
    do
    {
      v3 = a1[v2 + 48];
      if (*(_QWORD *)(v3 + 16))
        v1 &= *(_BYTE *)(v3 + 1136);
      v2 += 2;
    }
    while (v2 != 6);
  }
  return v1;
}

_QWORD *segPumpReadyNotification(_QWORD *result, __CFString *a2, CFTypeRef cf)
{
  _QWORD *v3;
  int v5;
  const void *v6;
  const void *v7;
  const void *v8;

  v3 = result;
  if (a2 == CFSTR("FBPAL_AlternateListChanged"))
  {
    v5 = *((_DWORD *)result + 2240) | 1;
    goto LABEL_16;
  }
  if (a2 == CFSTR("FBPAL_SeekableTimeRangeChanged"))
  {
    v5 = *((_DWORD *)result + 2240) | 2;
    goto LABEL_16;
  }
  if (a2 == CFSTR("FBP_DurationChanged"))
  {
    v5 = *((_DWORD *)result + 2240) | 0x10;
    goto LABEL_16;
  }
  if (CFSTR("FBP_FatalErrorOccurred") == a2)
  {
    v6 = (const void *)result[1121];
    if (v6)
    {
      CFRelease(v6);
      v3[1121] = 0;
    }
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    v3[1121] = result;
    *((_DWORD *)v3 + 2240) |= 0x20u;
    *((_BYTE *)v3 + 9504) = 1;
  }
  else if (a2 == CFSTR("FBP_NewErrorLogEntry"))
  {
    v7 = (const void *)result[1124];
    if (v7)
    {
      CFRelease(v7);
      v3[1124] = 0;
    }
    *((_DWORD *)v3 + 2240) |= 0x40u;
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    v3[1124] = result;
  }
  else
  {
    if (a2 != CFSTR("FBP_SuggestedAlternate"))
    {
      if (a2 == CFSTR("FBP_TaggedRangeMetadataChanged"))
      {
        v5 = *((_DWORD *)result + 2240) | 0x100;
      }
      else if (a2 == CFSTR("FBP_PrefersConcurrentSwitchChanged"))
      {
        v5 = *((_DWORD *)result + 2240) | 0x200;
      }
      else
      {
        if (a2 != CFSTR("FBP_RecommendedPrebufferReservationChanged"))
        {
          if (CFSTR("FBP_PlaylistUpdateNotification") == a2)
          {
            *((_DWORD *)result + 2240) |= 0x800u;
            if (cf)
              result = CFRetain(cf);
            else
              result = 0;
            v3[1126] = result;
          }
          return result;
        }
        v5 = *((_DWORD *)result + 2240) | 0x400;
      }
LABEL_16:
      *((_DWORD *)result + 2240) = v5;
      return result;
    }
    *((_DWORD *)result + 2240) |= 0x80u;
    v8 = (const void *)result[1123];
    if (v8)
    {
      CFRelease(v8);
      v3[1123] = 0;
    }
    if (cf)
      result = CFRetain(cf);
    else
      result = 0;
    v3[1123] = result;
  }
  return result;
}

void segPumpSendEndCallbackForActiveStream(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t DerivedStorage;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v7 = DerivedStorage;
  v8 = DerivedStorage + 16 * *(_QWORD *)a2;
  v9 = a2;
  if (*(_QWORD *)(v8 + 392) != a2)
    v9 = *(_QWORD *)(v8 + 384);
  if (*(_QWORD *)(v9 + 16) && !*(_BYTE *)(a2 + 1136))
  {
    segPumpMakeDataCallback(a1, (uint64_t *)a2, *(const void **)(DerivedStorage + 176), 0, 2u, *(_QWORD *)(a2 + 304), MEMORY[0x1E0CA2E18], 0, 0, (uint64_t)a3, 0, 0);
    segPumpStopStream(v7, a2, 0);
    *(_BYTE *)(a2 + 1136) = 1;
    v10 = *(const void **)(a2 + 1144);
    *(_QWORD *)(a2 + 1144) = a3;
    if (a3)
      CFRetain(a3);
    if (v10)
      CFRelease(v10);
  }
}

uint64_t segPumpMakeDataCallback(uint64_t a1, uint64_t *a2, const void *a3, uint64_t a4, unsigned int a5, uint64_t a6, __int128 *a7, uint64_t a8, int a9, uint64_t a10, uint64_t a11, _DWORD *a12)
{
  void (*v20)(uint64_t, const void *, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, __int128 *, uint64_t, int, uint64_t, uint64_t, uint64_t, int *);
  uint64_t v21;
  unsigned int v22;
  uint64_t result;
  uint64_t v24;
  unsigned int v25;
  __int128 v26;
  uint64_t v27;
  int v28;

  v20 = *(void (**)(uint64_t, const void *, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, __int128 *, uint64_t, int, uint64_t, uint64_t, uint64_t, int *))(CMBaseObjectGetDerivedStorage() + 160);
  v21 = *a2;
  v22 = *((_DWORD *)a2 + 18);
  v28 = 0;
  if (!v20)
    goto LABEL_9;
  v25 = v22;
  v24 = a2[110];
  if (a3)
    CFRetain(a3);
  FigRetainProxyUnlockAll();
  v26 = *a7;
  v27 = *((_QWORD *)a7 + 2);
  v20(a1, a3, a4, a5, v21, v25, 0, &v26, a8, a9, a6, a10, a11, &v28);
  if (a3)
    CFRelease(a3);
  FigRetainProxyRelock();
  if (FigRetainProxyIsInvalidated())
    return 4294954413;
  if (v24 != a2[110])
    return 4294951670;
LABEL_9:
  result = 0;
  if (a12)
    *a12 = v28;
  return result;
}

uint64_t segPumpStopStream(uint64_t a1, uint64_t a2, int a3)
{
  const void *v6;
  int v7;
  const void *v8;
  const void *v9;
  _QWORD *i;
  const void *v11;
  uint64_t v12;

  FigRetainProxyRetain();
  ++*(_QWORD *)(a2 + 880);
  *(_BYTE *)(a2 + 860) = 0;
  v6 = *(const void **)(a2 + 288);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a2 + 288) = 0;
    *(_QWORD *)(a2 + 320) = -1;
  }
  segPumpCancelMediaFileReadAndResetData(a1, a2, a3, 0);
  if (FigRetainProxyIsInvalidated()
    || (segPumpSetStreamDiscontinuityDomain(a1, (_QWORD *)a2, 0),
        v7 = *(unsigned __int8 *)(a2 + 537),
        segPumpResetConnection(a1, a2 + 408),
        *(_BYTE *)(a2 + 859) = 0,
        segPumpStreamUpdateIndexExpectedArrival(a1, a2),
        FigRetainProxyIsInvalidated()))
  {
    v12 = 4294954511;
  }
  else
  {
    *(_BYTE *)(a2 + 400) = 0;
    FigHTTPStopAndReleaseTimer((dispatch_object_t *)(a2 + 392));
    if (!a3 || v7)
    {
      v8 = *(const void **)(a2 + 280);
      if (v8)
      {
        CFRelease(v8);
        *(_QWORD *)(a2 + 280) = 0;
      }
      v9 = *(const void **)(a2 + 272);
      if (v9)
      {
        CFRelease(v9);
        *(_QWORD *)(a2 + 272) = 0;
      }
      for (i = *(_QWORD **)(a2 + 680); i; i = (_QWORD *)*i)
        segPumpStreamDontReuseHTTPRequest(a1, (uint64_t)i);
    }
    v11 = *(const void **)(a2 + 56);
    if (v11)
    {
      CFRelease(v11);
      *(_QWORD *)(a2 + 56) = 0;
    }
    segPumpCompleteNWAlternateForStream(a2);
    v12 = 0;
    *(_DWORD *)(a2 + 1200) = 0;
  }
  FigRetainProxyRelease();
  return v12;
}

uint64_t segPumpSetStreamDiscontinuityDomain(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;

  v4 = a2[38];
  if (a3)
  {
    v6 = a2[39];
    a2[38] = FigMediaSegmentSpecifierGetDiscontinuityDomain(a3) + v6;
    result = FigMediaSegmentSpecifierGetMediaSequence(a3);
    v8 = a2[38];
  }
  else
  {
    v8 = 0;
    result = 0;
    a2[38] = 0;
  }
  a2[41] = result;
  if (v4 != v8 && dword_1EE2A31E8 != 0)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    return fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  return result;
}

void segPumpStreamDisposeStorage(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  segPumpFreeDiscoQueue((uint64_t)(a1 + 42));
  v2 = (const void *)a1[35];
  if (v2)
  {
    CFRelease(v2);
    a1[35] = 0;
  }
  v3 = (const void *)a1[34];
  if (v3)
  {
    CFRelease(v3);
    a1[34] = 0;
  }
  v4 = (const void *)a1[29];
  if (v4)
  {
    CFRelease(v4);
    a1[29] = 0;
  }
  v5 = (const void *)a1[30];
  if (v5)
  {
    CFRelease(v5);
    a1[30] = 0;
  }
  segPumpStreamUpdateIndexFile(a1, 0, 0, 0, 0, 0);
}

void segPumpDestroyMediaConnection(uint64_t a1, _QWORD *a2, dispatch_object_t *a3)
{
  dispatch_object_t *v4;
  dispatch_object_t *v5;
  dispatch_object_t v6;
  dispatch_object_t v7;
  dispatch_object_t v8;
  dispatch_object_t v9;
  dispatch_object_t v10;
  dispatch_object_t v11;
  dispatch_object_t v12;
  dispatch_object_t v13;
  dispatch_object_t v14;

  --a2[93];
  v4 = (dispatch_object_t *)a2[85];
  if (v4 == a3)
  {
    v5 = (dispatch_object_t *)(a2 + 85);
  }
  else
  {
    do
    {
      v5 = v4;
      v4 = (dispatch_object_t *)*v4;
    }
    while (v4 != a3);
  }
  v6 = *a3;
  *v5 = *a3;
  if (!v6)
    a2[86] = v5;
  segPumpResetMediaConnection(a1, a3, 0);
  FigHTTPStopAndReleaseTimer(a3 + 14);
  v7 = a3[2];
  if (v7)
  {
    CFRelease(v7);
    a3[2] = 0;
  }
  v8 = a3[21];
  if (v8)
  {
    CFRelease(v8);
    a3[21] = 0;
  }
  v9 = a3[22];
  if (v9)
  {
    CFRelease(v9);
    a3[22] = 0;
  }
  v10 = a3[3];
  if (v10)
  {
    CFRelease(v10);
    a3[3] = 0;
  }
  v11 = a3[4];
  if (v11)
  {
    CFRelease(v11);
    a3[4] = 0;
  }
  v12 = a3[11];
  if (v12)
  {
    CFRelease(v12);
    a3[11] = 0;
  }
  v13 = a3[19];
  if (v13)
  {
    CFRelease(v13);
    a3[19] = 0;
  }
  v14 = a3[20];
  if (v14)
    CFRelease(v14);
  free(a3);
}

uint64_t *AlternateQueueFree(uint64_t a1)
{
  uint64_t *result;
  uint64_t v3;

  result = *(uint64_t **)a1;
  if (result)
  {
    do
    {
      v3 = *result;
      *(_QWORD *)a1 = *result;
      if (!v3)
        *(_QWORD *)(a1 + 8) = a1;
      AlternateEntryFree(result);
      result = *(uint64_t **)a1;
    }
    while (*(_QWORD *)a1);
  }
  return result;
}

uint64_t segPumpUpdateCurrentAlternate(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t (*v7)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD);
  uint64_t (*v8)(uint64_t, __CFString *, __CFString *);

  *(_QWORD *)(a1 + 8144) = a2;
  result = segPumpUpdateBytesRequiredForNetworkPrediction(a1);
  v4 = *(_QWORD *)(a1 + 8144);
  v5 = *(_QWORD *)(a1 + 9048);
  if (v4)
  {
    result = FigAlternateGetAlternateIndex(*(_QWORD *)(v4 + 8));
    if (v5)
    {
      v6 = result;
      result = CMBaseObjectGetVTable();
      v7 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD))(*(_QWORD *)(result + 16)
                                                                                         + 56);
      if (v7)
        return v7(v5, CFSTR("bytePumpStats"), CFSTR("PumpAltID"), v6, 0);
    }
  }
  else if (v5)
  {
    result = CMBaseObjectGetVTable();
    v8 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *))(*(_QWORD *)(result + 16) + 64);
    if (v8)
      return v8(v5, CFSTR("bytePumpStats"), CFSTR("PumpAltID"));
  }
  return result;
}

uint64_t *segPumpFreeDiscoQueue(uint64_t a1)
{
  uint64_t *result;
  uint64_t v3;
  _QWORD *v4;

  result = *(uint64_t **)a1;
  if (result)
  {
    do
    {
      v3 = *result;
      v4 = (_QWORD *)result[1];
      if (*result)
      {
        *(_QWORD *)(v3 + 8) = v4;
        v4 = (_QWORD *)result[1];
      }
      else
      {
        *(_QWORD *)(a1 + 8) = v4;
      }
      *v4 = v3;
      free(result);
      result = *(uint64_t **)a1;
    }
    while (*(_QWORD *)a1);
  }
  return result;
}

void segPumpStreamUpdateIndexFile(_QWORD *a1, CFTypeRef cf, CFTypeRef a3, CFTypeRef a4, CFTypeRef a5, CFTypeRef a6)
{
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;

  v11 = (const void *)a1[2];
  a1[2] = cf;
  if (cf)
    CFRetain(cf);
  if (v11)
    CFRelease(v11);
  v12 = (const void *)a1[1];
  a1[1] = a3;
  if (a3)
    CFRetain(a3);
  if (v12)
    CFRelease(v12);
  v13 = (const void *)a1[3];
  a1[3] = a4;
  if (a4)
    CFRetain(a4);
  if (v13)
    CFRelease(v13);
  v14 = (const void *)a1[4];
  a1[4] = a5;
  if (a5)
    CFRetain(a5);
  if (v14)
    CFRelease(v14);
  v15 = (const void *)a1[5];
  a1[5] = a6;
  if (a6)
    CFRetain(a6);
  if (v15)
    CFRelease(v15);
}

void AlternateEntryFree(_QWORD *a1)
{
  const void *v2;

  if (a1)
  {
    v2 = (const void *)a1[1];
    if (v2)
      CFRelease(v2);
  }
  free(a1);
}

uint64_t segPumpUpdateBytesRequiredForNetworkPrediction(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t AllocatorForMedia;
  void (*v6)(uint64_t, const __CFString *, uint64_t, CFArrayRef *);
  CFIndex Count;
  __CFArray *v8;
  const __CFAllocator *v9;
  CFMutableArrayRef Mutable;
  uint64_t **v11;
  _BOOL4 HasOnlyAudioOnly;
  uint64_t v13;
  uint64_t v14;
  uint64_t inserted;
  uint64_t v16;
  uint64_t v17;
  CFTypeRef v18;
  CFTypeRef v19;
  int v20;
  const __CFAllocator *v21;
  _BOOL4 HasHDVideoResolution;
  uint64_t v23;
  double v24;
  double v25;
  const __CFAllocator *v26;
  uint64_t v27;
  uint64_t v28;
  CFTypeRef v29;
  uint64_t (*v30)(CFTypeRef, __CFArray *, _BYTE *);
  const void *ValueAtIndex;
  uint64_t v32;
  int PeakBitRate;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v39;
  unsigned int v40;
  const __CFString *v41;
  CFNumberRef v42;
  CFNumberRef v43;
  uint64_t v44;
  uint64_t (*v45)(uint64_t, const __CFString *, CFNumberRef);
  uint64_t valuePtr;
  CFTypeRef cf;
  CFTypeRef v49;
  CFTypeRef v50;
  CFTypeRef v51;
  CFTypeRef v52;
  CFTypeRef v53;
  CFTypeRef v54;
  CFTypeRef v55;
  _BYTE v56[12];
  __int16 v57;
  const __CFString *v58;
  __int16 v59;
  uint64_t v60;
  CFArrayRef theArray[17];

  theArray[16] = *(CFArrayRef *)MEMORY[0x1E0C80C00];
  v55 = 0;
  *(_QWORD *)v56 = 0;
  v53 = 0;
  v54 = 0;
  v51 = 0;
  v52 = 0;
  v49 = 0;
  v50 = 0;
  cf = 0;
  v2 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("minRequiredBytesForNetworkHistory"));
  v3 = v2;
  valuePtr = v2;
  theArray[0] = 0;
  v4 = *(_QWORD *)(a1 + 9560);
  if (v4)
  {
    AllocatorForMedia = FigGetAllocatorForMedia();
    v6 = *(void (**)(uint64_t, const __CFString *, uint64_t, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                               + 8)
                                                                                   + 48);
    if (v6)
    {
      v6(v4, CFSTR("AfmfpbProperty_CandidateAlternatesForAdaptiveBitrateSwitching"), AllocatorForMedia, theArray);
      if (theArray[0])
      {
        Count = CFArrayGetCount(theArray[0]);
        v8 = theArray[0];
        if (Count)
          goto LABEL_10;
        if (theArray[0])
        {
          CFRelease(theArray[0]);
          theArray[0] = 0;
        }
      }
    }
  }
  v9 = (const __CFAllocator *)FigGetAllocatorForMedia();
  Mutable = CFArrayCreateMutable(v9, 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    v36 = FigSignalErrorAt();
    if (theArray[0])
      CFRelease(theArray[0]);
    if ((_DWORD)v36)
    {
      v8 = 0;
      goto LABEL_53;
    }
    goto LABEL_51;
  }
  v8 = Mutable;
  v11 = *(uint64_t ***)(a1 + 8096);
  if (!v11)
    goto LABEL_11;
  do
  {
    CFArrayAppendValue(v8, v11[1]);
    v11 = (uint64_t **)*v11;
  }
  while (v11);
LABEL_10:
  if (!v8)
  {
LABEL_51:
    v8 = 0;
    goto LABEL_52;
  }
LABEL_11:
  if (CFArrayGetCount(v8) < 1)
  {
LABEL_52:
    v36 = 0;
    goto LABEL_53;
  }
  HasOnlyAudioOnly = FigAlternateSelectionUtility_AlternateListHasOnlyAudioOnly(v8);
  v13 = *(_QWORD *)(a1 + 16 * *(_QWORD *)(a1 + 8416) + 384);
  v14 = FigGetAllocatorForMedia();
  inserted = FigAlternateFilterTreeCreate(v14, &cf);
  if ((_DWORD)inserted)
    goto LABEL_46;
  v16 = *(_QWORD *)(a1 + 8144);
  if (!v16 || FigAlternateIs4k(*(_QWORD *)(v16 + 8)) || HasOnlyAudioOnly)
  {
    v17 = FigGetAllocatorForMedia();
    inserted = FigAlternateHighestPeakBitRateFilterCreate(v17, &v51);
    if (!(_DWORD)inserted)
    {
      v18 = cf;
      v19 = v51;
      v20 = 600;
      goto LABEL_30;
    }
LABEL_46:
    v36 = inserted;
    goto LABEL_53;
  }
  if (*(_BYTE *)(a1 + 8002)
    && *(double *)(v13 + 96) - *(double *)(v13 + 904) < (double)(3 * *(_DWORD *)(a1 + 8)))
  {
    v21 = (const __CFAllocator *)FigGetAllocatorForMedia();
    inserted = FigAlternateNextHighestPeakBitRateFilterCreate(v21, *(_QWORD *)(*(_QWORD *)(a1 + 8144) + 8), &v49, 1.1);
    if ((_DWORD)inserted)
      goto LABEL_46;
    v18 = cf;
    v19 = v49;
    v20 = 500;
  }
  else
  {
    HasHDVideoResolution = FigAlternateHasHDVideoResolution(*(_QWORD *)(*(_QWORD *)(a1 + 8144) + 8));
    v23 = FigGetAllocatorForMedia();
    inserted = FigAlternateLowestPeakBitRateFilterCreate(v23, &v53);
    if ((_DWORD)inserted)
      goto LABEL_46;
    v24 = dbl_1932FD100[!HasHDVideoResolution];
    v25 = HasHDVideoResolution ? 4800.0 : 2560.0;
    v26 = (const __CFAllocator *)FigGetAllocatorForMedia();
    inserted = FigAlternateResolutionClosestHeightFilterCreate(v26, &v54, v25, v24);
    if ((_DWORD)inserted)
      goto LABEL_46;
    v27 = FigGetAllocatorForMedia();
    inserted = FigAlternateContinuousFramesOnlyFilterCreate(v27, &v52);
    if ((_DWORD)inserted)
      goto LABEL_46;
    inserted = FigAlternateFilterTreeInsertLeaf((uint64_t)cf, v52, 400);
    if ((_DWORD)inserted)
      goto LABEL_46;
    inserted = FigAlternateFilterTreeInsertLeaf((uint64_t)cf, v54, 300);
    if ((_DWORD)inserted)
      goto LABEL_46;
    v18 = cf;
    v19 = v53;
    v20 = 200;
  }
LABEL_30:
  inserted = FigAlternateFilterTreeInsertLeaf((uint64_t)v18, v19, v20);
  if ((_DWORD)inserted)
    goto LABEL_46;
  v28 = FigGetAllocatorForMedia();
  inserted = FigAlternateLowestIndexAlternateFilterCreate(v28, &v50);
  if ((_DWORD)inserted)
    goto LABEL_46;
  inserted = FigAlternateFilterTreeInsertLeaf((uint64_t)cf, v50, 100);
  if ((_DWORD)inserted)
    goto LABEL_46;
  inserted = FigAlternateFilterTreeCreateFilter(cf, CFSTR("FigNetworkHistoryTree"), -1, &v55);
  if ((_DWORD)inserted)
    goto LABEL_46;
  v29 = v55;
  v30 = *(uint64_t (**)(CFTypeRef, __CFArray *, _BYTE *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
  if (!v30)
  {
    v36 = 4294954514;
    goto LABEL_53;
  }
  inserted = v30(v29, v8, v56);
  if ((_DWORD)inserted)
    goto LABEL_46;
  if (!*(_QWORD *)v56 || CFArrayGetCount(*(CFArrayRef *)v56) != 1)
  {
    inserted = FigSignalErrorAt();
    goto LABEL_46;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)v56, 0);
  v32 = (uint64_t)ValueAtIndex;
  if (*(_QWORD *)(a1 + 8144))
  {
    PeakBitRate = FigAlternateGetPeakBitRate((uint64_t)ValueAtIndex);
    if (PeakBitRate <= (int)FigAlternateGetPeakBitRate(*(_QWORD *)(*(_QWORD *)(a1 + 8144) + 8)))
      v32 = *(_QWORD *)(*(_QWORD *)(a1 + 8144) + 8);
  }
  v34 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("minContentMillisecondsBeforePredicting"));
  v35 = FigAlternateGetPeakBitRate(v32);
  v36 = 0;
  v37 = v35 * (uint64_t)v34 / 8000;
  if (v37 <= v3)
    v37 = v3;
  valuePtr = v37;
LABEL_53:
  if (cf)
    CFRelease(cf);
  if (v8)
    CFRelease(v8);
  if (v55)
    CFRelease(v55);
  if (v52)
    CFRelease(v52);
  if (*(_QWORD *)v56)
    CFRelease(*(CFTypeRef *)v56);
  if (v54)
    CFRelease(v54);
  if (v53)
    CFRelease(v53);
  if (v51)
    CFRelease(v51);
  if (v50)
    CFRelease(v50);
  if (v49)
    CFRelease(v49);
  if (!(_DWORD)v36)
  {
    if (dword_1EE2A31E8)
    {
      LODWORD(v55) = 0;
      LOBYTE(v54) = 0;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      v39 = v55;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, (os_log_type_t)v54))
        v40 = v39;
      else
        v40 = v39 & 0xFFFFFFFE;
      if (v40)
      {
        v41 = &stru_1E2FD85F8;
        if (a1 && *(_QWORD *)(a1 + 8760))
          v41 = *(const __CFString **)(a1 + 8760);
        *(_DWORD *)v56 = 136315650;
        *(_QWORD *)&v56[4] = "segPumpUpdateBytesRequiredForNetworkPrediction";
        v57 = 2114;
        v58 = v41;
        v59 = 2048;
        v60 = valuePtr;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    *(_QWORD *)(a1 + 9280) = valuePtr;
    v42 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
    if (v42)
    {
      v43 = v42;
      v44 = *(_QWORD *)(a1 + 9560);
      if (v44)
      {
        v45 = *(uint64_t (**)(uint64_t, const __CFString *, CFNumberRef))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                             + 8)
                                                                                 + 56);
        if (v45)
          v36 = v45(v44, CFSTR("AfmfpbProperty_BytesRequiredForNetworkPrediction"), v43);
        else
          v36 = 4294954514;
      }
      else
      {
        v36 = 0;
      }
      CFRelease(v43);
    }
    else
    {
      return FigSignalErrorAt();
    }
  }
  return v36;
}

double segPumpGetMinTime(_QWORD *a1)
{
  uint64_t v2;
  double v3;
  uint64_t v4;
  const __CFArray *MediaSegmentSpecifiers;
  uint64_t v6;
  uint64_t v8;
  const __CFArray *v9;

  v2 = a1[1052];
  v3 = *(double *)(a1[2 * v2 + 48] + 88);
  if (v2 == 1
    && (v4 = *(_QWORD *)(a1[48] + 56)) != 0
    && (MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v4)) != 0
    && CFArrayGetCount(MediaSegmentSpecifiers) >= 1
    && (v6 = a1[48], *(_QWORD *)(v6 + 16))
    || !a1[1052]
    && (v8 = *(_QWORD *)(a1[50] + 56)) != 0
    && (v9 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v8)) != 0
    && CFArrayGetCount(v9) >= 1
    && (v6 = a1[50], *(_QWORD *)(v6 + 16)))
  {
    if (v3 <= *(double *)(v6 + 88))
      return *(double *)(v6 + 88);
  }
  return v3;
}

double segPumpGetMaxTime(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  double result;
  double v4;
  uint64_t v5;
  double v6;
  double v7;

  v1 = a1[1052];
  v2 = a1[2 * v1 + 48];
  result = -1.0;
  if (*(_QWORD *)(v2 + 16))
  {
    v4 = *(double *)(v2 + 96);
    if (v4 > 0.0)
      result = v4 + *(double *)(v2 + 88);
  }
  if (v1)
  {
    if (v1 != 1)
    {
LABEL_11:
      v7 = result;
      goto LABEL_12;
    }
    v5 = a1[48];
  }
  else
  {
    v5 = a1[50];
  }
  if (!*(_QWORD *)(v5 + 16))
    goto LABEL_11;
  v6 = *(double *)(v5 + 96);
  if (v6 <= 0.0)
    goto LABEL_11;
  v7 = v6 + *(double *)(v5 + 88);
  if (v7 < 0.0)
    goto LABEL_11;
  if (result < 0.0)
    result = v7;
LABEL_12:
  if (result >= v7)
    result = v7;
  if (result < 0.0)
    return 0.0;
  return result;
}

uint64_t segPumpCopyCachedTimeRanges(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v3;
  const __CFAllocator *AllocatorForMedia;
  const __CFArray *Mutable;
  int v6;
  uint64_t v7;
  const CFArrayCallBacks *v8;
  uint64_t v9;
  uint64_t v10;
  int IsEqualToOSStatus;
  uint64_t v13;
  uint64_t v14;
  const __CFAllocator *v15;
  __int128 v16;
  const __CFAllocator *v17;
  const __CFAllocator *v18;
  CFMutableArrayRef v19;
  CFIndex v20;
  CFIndex v21;
  const __CFArray *v22;
  CMTimeFlags flags;
  CMTimeEpoch epoch;
  CMTimeValue v25;
  CMTimeFlags v26;
  CMTimeScale v27;
  CMTimeEpoch v28;
  const __CFAllocator *v29;
  CFDictionaryRef v30;
  int32_t v31;
  __CFArray *v32;
  const __CFAllocator *v33;
  __int128 v34;
  CFDictionaryRef v35;
  const __CFArray *v36;
  const __CFAllocator *v37;
  __int128 v38;
  CFDictionaryRef v39;
  uint64_t v40;
  CFTypeRef *v42;
  uint64_t v43;
  int v44;
  __CFArray *theArray;
  CMTime time2;
  CMTime time1;
  CMTimeRange otherRange;
  CMTimeRange v49;
  CMTimeRange v50;
  CMTimeRange v51;
  CMTimeRange range;
  void *values;
  const __CFArray *v54;
  CMTimeValue value;
  CMTimeScale timescale;
  uint64_t v57;
  CFRange v58;

  v57 = *MEMORY[0x1E0C80C00];
  values = 0;
  v54 = 0;
  if (*(_QWORD *)(a1 + 296))
  {
    v3 = a1;
    AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    Mutable = CFArrayCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B378]);
    if (Mutable)
    {
      v42 = a2;
      v6 = 0;
      v7 = 0;
      v8 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
      v43 = v3;
      do
      {
        v9 = *(_QWORD *)(v3 + 16 * v7 + 384);
        if (*(_QWORD *)(v9 + 16))
        {
          LOBYTE(range.start.value) = 0;
          v10 = *(_QWORD *)(v9 + 64);
          if (v10)
          {
            IsEqualToOSStatus = FigCFErrorIsEqualToOSStatus(*(__CFError **)(v9 + 1144), (uint64_t)CFSTR("CoreMediaErrorDomain"), -15642);
            LODWORD(v10) = IsEqualToOSStatus == 0;
            if (!IsEqualToOSStatus && v6 != 0)
            {
              if (*(_QWORD *)v9 != *(_QWORD *)(v3 + 8416))
                FigStreamingCacheMediaStreamIsComplete(*(_QWORD *)(v3 + 296), *(_QWORD *)(v9 + 64), &range);
              LODWORD(v10) = 1;
            }
          }
          if (LOBYTE(range.start.value))
            LODWORD(v10) = 0;
          if (*(_QWORD *)v9 == *(_QWORD *)(v3 + 8416))
            v6 = v10;
          if ((_DWORD)v10 == 1)
          {
            v13 = *(_QWORD *)(v9 + 64);
            if (v13)
            {
              v14 = FigStreamingCacheMediaStreamCopyCachedTimeRanges(*(_QWORD *)(v3 + 296), v13, (CFTypeRef *)&v54);
              if ((_DWORD)v14)
                goto LABEL_65;
            }
            if (!v54 || !CFArrayGetCount(v54))
            {
              v15 = (const __CFAllocator *)FigGetAllocatorForMedia();
              v16 = *(_OWORD *)(MEMORY[0x1E0CA2E50] + 16);
              *(_OWORD *)&range.start.value = *MEMORY[0x1E0CA2E50];
              *(_OWORD *)&range.start.epoch = v16;
              *(_OWORD *)&range.duration.timescale = *(_OWORD *)(MEMORY[0x1E0CA2E50] + 32);
              values = CMTimeRangeCopyAsDictionary(&range, v15);
              if (!values)
                goto LABEL_64;
              v17 = (const __CFAllocator *)FigGetAllocatorForMedia();
              v54 = CFArrayCreate(v17, (const void **)&values, 1, v8);
              if (values)
              {
                CFRelease(values);
                values = 0;
              }
            }
            if (CFArrayGetCount(Mutable))
            {
              v18 = (const __CFAllocator *)FigGetAllocatorForMedia();
              v19 = CFArrayCreateMutable(v18, 0, v8);
              if (!v19)
                goto LABEL_64;
              theArray = v19;
              v44 = v6;
              if (CFArrayGetCount(v54) >= 1)
              {
                v20 = 0;
                v21 = 0;
                while (v20 < CFArrayGetCount(Mutable))
                {
                  memset(&v51, 0, sizeof(v51));
                  timescale = 0;
                  value = 0;
                  values = (void *)CFArrayGetValueAtIndex(v54, v21);
                  CMTimeRangeMakeFromDictionary(&range, (CFDictionaryRef)values);
                  v22 = Mutable;
                  values = (void *)CFArrayGetValueAtIndex(Mutable, v20);
                  CMTimeRangeMakeFromDictionary(&v51, (CFDictionaryRef)values);
                  v49 = range;
                  otherRange = v51;
                  CMTimeRangeGetIntersection(&v50, &v49, &otherRange);
                  value = v50.start.value;
                  flags = v50.start.flags;
                  timescale = v50.start.timescale;
                  epoch = v50.start.epoch;
                  v25 = v50.duration.value;
                  v27 = v50.duration.timescale;
                  v26 = v50.duration.flags;
                  v28 = v50.duration.epoch;
                  if ((v50.start.flags & 1) == 0
                    || (v50.duration.flags & 1) == 0
                    || v50.duration.epoch
                    || v50.duration.value < 0
                    || (v50.start.value = v50.duration.value,
                        v50.start.timescale = v50.duration.timescale,
                        v50.start.flags = v50.duration.flags,
                        v50.start.epoch = 0,
                        *(_OWORD *)&v49.start.value = *MEMORY[0x1E0CA2E68],
                        v49.start.epoch = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16),
                        CMTimeCompare(&v50.start, &v49.start)))
                  {
                    v29 = (const __CFAllocator *)FigGetAllocatorForMedia();
                    v50.start.value = value;
                    v50.start.timescale = timescale;
                    v50.start.flags = flags;
                    v50.start.epoch = epoch;
                    v50.duration.value = v25;
                    v50.duration.timescale = v27;
                    v50.duration.flags = v26;
                    v50.duration.epoch = v28;
                    v30 = CMTimeRangeCopyAsDictionary(&v50, v29);
                    values = v30;
                    if (!v30)
                    {
                      v40 = FigSignalErrorAt();
                      Mutable = v22;
                      v32 = theArray;
                      goto LABEL_63;
                    }
                    CFArrayAppendValue(theArray, v30);
                    if (values)
                    {
                      CFRelease(values);
                      values = 0;
                    }
                  }
                  v50 = range;
                  CMTimeRangeGetEnd(&time1, &v50);
                  v50 = v51;
                  CMTimeRangeGetEnd(&time2, &v50);
                  v31 = CMTimeCompare(&time1, &time2);
                  v21 += v31 >> 31;
                  v20 += v31 >= 0;
                  Mutable = v22;
                  if (v21 >= CFArrayGetCount(v54))
                    break;
                }
              }
              v32 = theArray;
              v3 = v43;
              v6 = v44;
              if (!CFArrayGetCount(theArray))
              {
                v33 = (const __CFAllocator *)FigGetAllocatorForMedia();
                v34 = *(_OWORD *)(MEMORY[0x1E0CA2E50] + 16);
                *(_OWORD *)&range.start.value = *MEMORY[0x1E0CA2E50];
                *(_OWORD *)&range.start.epoch = v34;
                *(_OWORD *)&range.duration.timescale = *(_OWORD *)(MEMORY[0x1E0CA2E50] + 32);
                v35 = CMTimeRangeCopyAsDictionary(&range, v33);
                values = v35;
                if (!v35)
                {
                  v40 = FigSignalErrorAt();
LABEL_63:
                  CFRelease(v32);
                  goto LABEL_57;
                }
                CFArrayAppendValue(theArray, v35);
                if (values)
                {
                  CFRelease(values);
                  values = 0;
                }
              }
              CFRetain(theArray);
              CFRelease(Mutable);
              CFRelease(theArray);
              v8 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
            }
            else
            {
              v36 = v54;
              v58.length = CFArrayGetCount(v54);
              v58.location = 0;
              CFArrayAppendArray(Mutable, v36, v58);
              v32 = Mutable;
            }
            if (v54)
            {
              CFRelease(v54);
              v54 = 0;
            }
            Mutable = v32;
          }
        }
        else if (*(_QWORD *)v9 == *(_QWORD *)(v3 + 8416))
        {
          v6 = 0;
        }
        ++v7;
      }
      while (v7 != 3);
      if (!CFArrayGetCount(Mutable))
      {
        v37 = (const __CFAllocator *)FigGetAllocatorForMedia();
        v38 = *(_OWORD *)(MEMORY[0x1E0CA2E50] + 16);
        *(_OWORD *)&range.start.value = *MEMORY[0x1E0CA2E50];
        *(_OWORD *)&range.start.epoch = v38;
        *(_OWORD *)&range.duration.timescale = *(_OWORD *)(MEMORY[0x1E0CA2E50] + 32);
        v39 = CMTimeRangeCopyAsDictionary(&range, v37);
        values = v39;
        if (!v39)
          goto LABEL_64;
        CFArrayAppendValue(Mutable, v39);
        if (values)
        {
          CFRelease(values);
          values = 0;
        }
      }
      v40 = 0;
      *v42 = CFRetain(Mutable);
    }
    else
    {
LABEL_64:
      v14 = FigSignalErrorAt();
LABEL_65:
      v40 = v14;
    }
  }
  else
  {
    Mutable = 0;
    *a2 = 0;
    v40 = 4294954513;
  }
LABEL_57:
  if (v54)
    CFRelease(v54);
  if (Mutable)
    CFRelease(Mutable);
  return v40;
}

uint64_t segPumpGetObservedNetworkStats(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t UpTimeNanoseconds;
  uint64_t v7;
  uint64_t (*v8)(uint64_t, uint64_t, _OWORD *, uint64_t);
  uint64_t result;
  _BYTE v10[224];
  _OWORD v11[14];

  memset(&v10[8], 0, 216);
  segPumpMakeNetworkPredictionInput(a1, (uint64_t)v10);
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  *(_QWORD *)&v10[16] = UpTimeNanoseconds - a2;
  *(_QWORD *)v10 = 0;
  *(_QWORD *)&v10[168] = 9;
  v7 = *(_QWORD *)(a1 + 96);
  v8 = *(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
  if (v8)
  {
    v11[10] = *(_OWORD *)&v10[160];
    v11[11] = *(_OWORD *)&v10[176];
    v11[12] = *(_OWORD *)&v10[192];
    v11[13] = *(_OWORD *)&v10[208];
    v11[6] = *(_OWORD *)&v10[96];
    v11[7] = *(_OWORD *)&v10[112];
    v11[8] = *(_OWORD *)&v10[128];
    v11[9] = *(_OWORD *)&v10[144];
    v11[2] = *(_OWORD *)&v10[32];
    v11[3] = *(_OWORD *)&v10[48];
    v11[4] = *(_OWORD *)&v10[64];
    v11[5] = *(_OWORD *)&v10[80];
    v11[0] = *(_OWORD *)v10;
    v11[1] = *(_OWORD *)&v10[16];
    LODWORD(result) = v8(v7, UpTimeNanoseconds, v11, a3);
  }
  else
  {
    LODWORD(result) = -12782;
  }
  if (result >> 1 == 2147474779)
    return 0;
  else
    return result;
}

uint64_t segPumpGetAverageEstimatedMediaBitrate(uint64_t a1, int a2, _DWORD *a3, double *a4)
{
  uint64_t v4;
  int v5;
  double v6;
  uint64_t v7;
  int v8;

  v4 = 0;
  v5 = 0;
  v6 = 0.0;
  while (!*(_QWORD *)(*(_QWORD *)(a1 + v4 + 384) + 16))
  {
LABEL_11:
    v4 += 16;
    if (v4 == 48)
    {
      *a3 = v5;
      *a4 = v6;
      return 1;
    }
  }
  if (!a2 || (v7 = *(_QWORD *)(a1 + v4 + 392)) == 0)
    v7 = *(_QWORD *)(a1 + v4 + 384);
  v8 = *(_DWORD *)(v7 + 1080);
  if (v8)
  {
    v5 += v8;
    if (v6 == 0.0)
    {
      v6 = *(double *)(v7 + 1088);
    }
    else if (v6 >= *(double *)(v7 + 1088))
    {
      v6 = *(double *)(v7 + 1088);
    }
    goto LABEL_11;
  }
  return 0;
}

uint64_t segPumpGetSafeNetworkBandwidth(uint64_t a1, double *a2, int a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  double v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t AllocatorForMedia;
  void (*v16)(uint64_t, const __CFString *, uint64_t, CFNumberRef *);
  uint64_t v17;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v19;
  unsigned int v20;
  const __CFString *v21;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  os_log_type_t type;
  unsigned int v30;
  uint64_t valuePtr;
  CFNumberRef number;
  int v33;
  const char *v34;
  __int16 v35;
  const __CFString *v36;
  __int16 v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v28 = 0;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v23 = 0u;
  segPumpMakeNetworkPrediction(a1, (uint64_t)&v23);
  v9 = v8;
  v10 = 0.0;
  if (!(_DWORD)v8)
  {
    v10 = *((double *)&v24 + 1) * (double)(uint64_t)v23;
    if (v10 != 0.0)
    {
      v9 = 0;
      goto LABEL_25;
    }
  }
  if (!(a4 | a3) || *(_BYTE *)(a1 + 8712))
    goto LABEL_25;
  if (!segPumpSentEndCallbackForAllActiveStreams((_QWORD *)a1))
  {
    v11 = 0;
    v12 = 1;
    do
    {
      v13 = *(_QWORD *)(a1 + 384 + v11);
      if (*(_QWORD *)(v13 + 16))
        v12 = (*(_BYTE *)(v13 + 869) & v12);
      v11 += 16;
    }
    while (v11 != 48);
    if (!(v12 | a4))
    {
LABEL_25:
      if (!a2)
        return v9;
      goto LABEL_26;
    }
  }
  number = 0;
  v14 = *(_QWORD *)(a1 + 9560);
  if (!v14
    || (AllocatorForMedia = FigGetAllocatorForMedia(),
        (v16 = *(void (**)(uint64_t, const __CFString *, uint64_t, CFNumberRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                          + 48)) == 0)
    || (v16(v14, CFSTR("AfmfpbProperty_PredictedBitrate"), AllocatorForMedia, &number), !number))
  {
    v10 = 0.0;
    if (!a2)
      return v9;
    goto LABEL_26;
  }
  valuePtr = 0;
  CFNumberGetValue(number, kCFNumberSInt64Type, &valuePtr);
  v17 = valuePtr;
  if (dword_1EE2A31E8)
  {
    v30 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    v19 = v30;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v20 = v19;
    else
      v20 = v19 & 0xFFFFFFFE;
    if (v20)
    {
      v21 = *(const __CFString **)(a1 + 8760);
      if (!v21)
        v21 = &stru_1E2FD85F8;
      v33 = 136315650;
      v34 = "segPumpGetNetworkBandwidthFromMonitor";
      v35 = 2114;
      v36 = v21;
      v37 = 2048;
      v38 = valuePtr;
      _os_log_send_and_compose_impl();
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (number)
    CFRelease(number);
  v9 = 0;
  v10 = (double)v17;
  if (a2)
LABEL_26:
    *a2 = v10;
  return v9;
}

void segPumpCanContinueWithoutGap(uint64_t a1, int *a2)
{
  uint64_t v4;
  const __CFArray *v5;
  int v6;
  uint64_t UpTimeNanoseconds;
  uint64_t v8;
  uint64_t v9;
  double v10;
  int v11;
  CFIndex v12;
  const __CFArray *MediaSegmentSpecifiers;
  const __CFArray *v14;
  const void *ValueAtIndex;
  _BYTE *MediaFilePrivateData;
  _BYTE *v17;
  const __CFArray *PartialSegments;
  const __CFArray *v19;
  CFIndex v20;
  CFIndex Count;
  const void *v22;
  _BYTE *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  double v27;
  uint64_t v28;
  int *v29;

  if (*(_BYTE *)(a1 + 8002)
    || *(_DWORD *)(a1 + 24) == 1
    || (v4 = *(_QWORD *)(*(_QWORD *)(a1 + 16 * *(_QWORD *)(a1 + 8416) + 384) + 56)) == 0
    || (v5 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v4)) == 0
    || CFArrayGetCount(v5) < 1)
  {
    v6 = 7;
  }
  else if (*(_BYTE *)(*(_QWORD *)(a1 + 16 * *(_QWORD *)(a1 + 8416) + 384) + 1169))
  {
    v6 = 0;
  }
  else
  {
    v6 = 7;
    UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    v8 = 0;
    v28 = UpTimeNanoseconds;
    v29 = a2;
    do
    {
      v9 = *(_QWORD *)(a1 + 16 * v8 + 384);
      if (*(_QWORD *)(v9 + 16))
      {
        if (*(_QWORD *)(v9 + 56))
        {
          if (*(_BYTE *)(v9 + 862))
          {
            v10 = fmax(*(double *)(v9 + 912) + (double)(UpTimeNanoseconds - *(_QWORD *)(v9 + 896)) / -1000000000.0 + 0.0, 0.0);
          }
          else
          {
            v12 = 0;
            v10 = 0.0;
            while (1)
            {
              MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(v9 + 56));
              if (MediaSegmentSpecifiers)
                MediaSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MediaSegmentSpecifiers);
              if (v12 >= (uint64_t)MediaSegmentSpecifiers)
                break;
              v14 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(v9 + 56));
              ValueAtIndex = CFArrayGetValueAtIndex(v14, v12);
              MediaFilePrivateData = segPumpGetMediaFilePrivateData(ValueAtIndex);
              v17 = MediaFilePrivateData;
              if (!MediaFilePrivateData[96])
              {
                if (MediaFilePrivateData[73] || MediaFilePrivateData[74])
                {
                  v10 = v10 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
                }
                else
                {
                  PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)ValueAtIndex);
                  if (PartialSegments && CFArrayGetCount(PartialSegments) >= 1)
                  {
                    v19 = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)ValueAtIndex);
                    v20 = 0;
                    if (v19)
                    {
LABEL_31:
                      Count = CFArrayGetCount(v19);
                      goto LABEL_33;
                    }
                    while (1)
                    {
                      Count = 0;
LABEL_33:
                      if (v20 >= Count)
                        break;
                      v22 = CFArrayGetValueAtIndex(v19, v20);
                      v23 = segPumpGetMediaFilePrivateData(v22);
                      if (v23[73] || v23[74])
                        v10 = v10 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v22);
                      ++v20;
                      if (v19)
                        goto LABEL_31;
                    }
                    UpTimeNanoseconds = v28;
                    a2 = v29;
                  }
                }
              }
              ++v12;
              if (!v17[73])
              {
                if (ValueAtIndex)
                {
                  v24 = *(_QWORD *)(v9 + 376) + 1;
                  if (v24 != FigMediaSegmentSpecifierGetMediaSequence((uint64_t)ValueAtIndex))
                    v6 += -1 << v8;
                }
                break;
              }
            }
          }
          v25 = *(_QWORD *)(v9 + 1048);
          v26 = *(_QWORD *)(v9 + 1056);
          v27 = (double)v25 + v10 * 1000000000.0;
          if (v25 >= v26)
            v27 = (double)v26 + v10 * 1000000000.0;
          if (UpTimeNanoseconds <= (uint64_t)v27)
            v11 = 0;
          else
            v11 = -1 << v8;
        }
        else
        {
          v11 = -1 << v8;
        }
        v6 += v11;
      }
      ++v8;
    }
    while (v8 != 3);
  }
  if (a2)
    *a2 = v6;
}

uint64_t segPumpConnectedInterfaceIsWWAN(uint64_t a1)
{
  int v1;
  uint64_t result;

  v1 = *(_DWORD *)(a1 + 8464);
  if (v1)
    return FigNetworkInterfaceIsCellular(v1);
  v1 = *(_DWORD *)(a1 + 8460);
  if (v1)
    return FigNetworkInterfaceIsCellular(v1);
  result = *(_QWORD *)(a1 + 8448);
  if (result)
    return FigNetworkPathInformationDoesUseCellular();
  return result;
}

uint64_t segPumpCreateAccessLog(uint64_t a1, CFAllocatorRef allocator, __CFDictionary **a3)
{
  _QWORD *v5;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v7;
  _QWORD *v8;
  const __CFData *v9;
  const __CFData *v10;
  const __CFData *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t UpTimeNanoseconds;
  uint64_t ObservedNetworkStats;
  uint64_t v17;
  CFTypeRef v18;
  const void *v19;
  uint64_t v20;
  int AverageBitRate;
  const void *v22;
  const __CFString *v23;
  const void *v24;
  __CFDictionary *v25;
  __CFDictionary *v26;
  const void **v27;
  _OWORD v29[5];
  uint64_t v30;
  _OWORD v31[5];
  uint64_t v32;

  v5 = *(_QWORD **)(a1 + 16 * *(_QWORD *)(a1 + 8416) + 384);
  v30 = 0;
  memset(v29, 0, sizeof(v29));
  Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 4294954510;
  v7 = Mutable;
  v8 = (_QWORD *)(*(_QWORD *)(a1 + 16 * *(_QWORD *)(a1 + 8416) + 384) + 680);
  do
  {
    v8 = (_QWORD *)*v8;
    if (!v8)
      goto LABEL_11;
    v9 = (const __CFData *)v8[22];
  }
  while (!v9);
  v10 = FigCFHTTPCreateAddressString(v9);
  if (v10)
  {
    v11 = v10;
    CFDictionarySetValue(v7, CFSTR("s-ip"), v10);
    CFRelease(v11);
  }
  v12 = 0;
  v13 = 0;
  do
  {
    v13 += *(_QWORD *)(*(_QWORD *)(a1 + 384 + v12) + 944);
    v12 += 16;
  }
  while (v12 != 48);
  v14 = FigCFDictionarySetCFIndex();
  if ((_DWORD)v14)
  {
LABEL_10:
    CFRelease(v7);
    return v14;
  }
LABEL_11:
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  ObservedNetworkStats = segPumpGetObservedNetworkStats(a1, UpTimeNanoseconds - 60000000000, (uint64_t)v29);
  if ((_DWORD)ObservedNetworkStats)
    goto LABEL_61;
  ObservedNetworkStats = FigCFDictionarySetDouble();
  if ((_DWORD)ObservedNetworkStats)
    goto LABEL_61;
  ObservedNetworkStats = FigCFDictionarySetDouble();
  if ((_DWORD)ObservedNetworkStats)
    goto LABEL_61;
  v32 = 0;
  memset(v31, 0, sizeof(v31));
  v17 = v5[119];
  if (v17 >= 1)
    segPumpGetObservedNetworkStats(a1, v17, (uint64_t)v31);
  ObservedNetworkStats = FigCFDictionarySetDouble();
  if ((_DWORD)ObservedNetworkStats)
    goto LABEL_61;
  if (*(double *)(a1 + 8576) > 0.0)
  {
    ObservedNetworkStats = FigCFDictionarySetDouble();
    if ((_DWORD)ObservedNetworkStats)
      goto LABEL_61;
  }
  ObservedNetworkStats = FigCFDictionarySetInt64();
  if ((_DWORD)ObservedNetworkStats)
    goto LABEL_61;
  if (*(uint64_t *)(a1 + 8544) >= 1)
  {
    ObservedNetworkStats = FigCFDictionarySetInt64();
    if ((_DWORD)ObservedNetworkStats)
      goto LABEL_61;
    if (*(uint64_t *)(a1 + 8552) >= 1)
    {
      ObservedNetworkStats = FigCFDictionarySetInt64();
      if ((_DWORD)ObservedNetworkStats)
        goto LABEL_61;
    }
  }
  ObservedNetworkStats = FigCFDictionarySetDouble();
  if ((_DWORD)ObservedNetworkStats)
    goto LABEL_61;
  ObservedNetworkStats = FigCFDictionarySetDouble();
  if ((_DWORD)ObservedNetworkStats)
    goto LABEL_61;
  v18 = FigCFHTTPCreateURLString(*(const __CFURL **)(*(_QWORD *)(a1 + 384) + 8));
  if (v18)
  {
    v19 = v18;
    CFDictionarySetValue(v7, CFSTR("uri"), v18);
    CFRelease(v19);
  }
  ObservedNetworkStats = FigCFDictionarySetCFIndex();
  if ((_DWORD)ObservedNetworkStats)
    goto LABEL_61;
  ObservedNetworkStats = FigCFDictionarySetCFIndex();
  if ((_DWORD)ObservedNetworkStats
    || (ObservedNetworkStats = FigCFDictionarySetDouble(), (_DWORD)ObservedNetworkStats)
    || (FigCFDictionarySetDouble(), ObservedNetworkStats = FigCFDictionarySetCFIndex(), (_DWORD)ObservedNetworkStats)
    || (ObservedNetworkStats = FigCFDictionarySetCFIndex(), (_DWORD)ObservedNetworkStats)
    || (ObservedNetworkStats = FigCFDictionarySetCFIndex(), (_DWORD)ObservedNetworkStats)
    || (ObservedNetworkStats = FigCFDictionarySetCFIndex(), (_DWORD)ObservedNetworkStats)
    || (ObservedNetworkStats = FigCFDictionarySetCFIndex(), (_DWORD)ObservedNetworkStats))
  {
LABEL_61:
    v14 = ObservedNetworkStats;
    goto LABEL_10;
  }
  v20 = *(_QWORD *)(a1 + 8144);
  if (v20)
  {
    AverageBitRate = FigAlternateGetAverageBitRate(*(_QWORD *)(v20 + 8));
    if (FigAlternateGetDeclaredPeakBitRate(*(_QWORD *)(*(_QWORD *)(a1 + 8144) + 8)))
      FigCFDictionarySetInt32();
    if (AverageBitRate)
      FigCFDictionarySetInt32();
    if (FigAlternateGetFrameRate(*(_QWORD *)(*(_QWORD *)(a1 + 8144) + 8)) != 0.0)
      FigCFDictionarySetDouble();
  }
  v22 = *(const void **)(a1 + 224);
  if (v22)
    CFDictionarySetValue(v7, CFSTR("cs-guid"), v22);
  if (*(_BYTE *)(a1 + 8002))
    v23 = CFSTR("VOD");
  else
    v23 = CFSTR("LIVE");
  CFDictionarySetValue(v7, CFSTR("s-playback-type"), v23);
  v24 = *(const void **)(a1 + 8896);
  if (v24)
    CFDictionarySetValue(v7, CFSTR("c-client-name"), v24);
  v25 = FigNetworkInterfaceReporterCopyPhysicalStatistics(*(_QWORD *)(a1 + 9120));
  if (v25)
  {
    v26 = v25;
    FigAccessLogUpdateWithPhysicalStatistcs(v7, v25);
    CFRelease(v26);
  }
  if (*(_QWORD *)(a1 + 8416) == 1)
    v27 = (const void **)MEMORY[0x1E0C9AE50];
  else
    v27 = (const void **)MEMORY[0x1E0C9AE40];
  CFDictionarySetValue(v7, CFSTR("c-audio-only"), *v27);
  if ((uint64_t)v5[141] >= 1)
    FigCFDictionarySetInt64();
  if ((uint64_t)v5[138] >= 1)
  {
    FigCFDictionarySetInt64();
    FigCFDictionarySetDouble();
  }
  v14 = 0;
  *a3 = v7;
  return v14;
}

CMTimeRange *segPumpGetLiveEdge@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  char v9;
  double v10;
  char v11;
  uint64_t v12;
  double v13;
  double v14;
  double v15;
  uint64_t UpTimeNanoseconds;
  double v17;
  uint64_t v18;
  double v19;
  double v20;
  CMTimeRange *result;
  CMTime v22;
  CMTime start;

  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  if (*(_BYTE *)(a1 + 8002))
    goto LABEL_22;
  v8 = 0;
  v9 = 1;
  v10 = 1.79769313e308;
  do
  {
    v11 = v9;
    v12 = *(_QWORD *)(a1 + 16 * v8 + 384);
    if (*(_QWORD *)(v12 + 16) && ((a2 >> v8) & 1) != 0)
    {
      v13 = *(double *)(v12 + 88);
      v14 = *(double *)(v12 + 96);
      v15 = segPumpGetMinimumPrebufferReservation(a1, *(_QWORD *)(v12 + 56)) + *(double *)(a1 + 7960);
      if (*(uint64_t *)(v12 + 1056) >= 1 && *(_BYTE *)(a1 + 334))
      {
        UpTimeNanoseconds = FigGetUpTimeNanoseconds();
        v17 = *(double *)(a1 + 16);
        if (v17 <= 0.0)
        {
          LODWORD(v17) = *(_DWORD *)(a1 + 8);
          v17 = (double)*(unint64_t *)&v17;
        }
        v18 = UpTimeNanoseconds - *(_QWORD *)(v12 + 1056);
        if ((double)v18 / 1000000000.0 < v17)
          v17 = (double)v18 / 1000000000.0;
        v15 = v15 - v17;
      }
      if (v10 > v13 + v14 - v15)
        v10 = v13 + v14 - v15;
    }
    v9 = 0;
    v8 = 1;
  }
  while ((v11 & 1) != 0);
  if (v10 >= 1.79769313e308)
  {
LABEL_22:
    start = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E18];
    v22 = start;
    return CMTimeRangeMake((CMTimeRange *)a4, &start, &v22);
  }
  else
  {
    v19 = *(double *)(a1 + 16);
    if (v19 <= 0.0)
    {
      LODWORD(v19) = *(_DWORD *)(a1 + 8);
      v19 = (double)*(unint64_t *)&v19;
    }
    if (a3)
      v20 = v19 * 1.5;
    else
      v20 = v19;
    CMTimeMakeWithSeconds((CMTime *)a4, v10, 90000);
    result = (CMTimeRange *)CMTimeMakeWithSeconds(&start, v20, 90000);
    *(CMTime *)(a4 + 24) = start;
  }
  return result;
}

uint64_t segPumpLoadSynchronousProperties(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const __CFArray *SessionDataSpecifiers;
  const void *v6;
  _BYTE *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void (*v12)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD);
  NSObject *v13;
  char v15;

  if (*(_QWORD *)(a1 + 7712) || *(_QWORD *)(a1 + 7696))
    return 0;
  v2 = *(_QWORD *)(a1 + 384);
  v3 = *(_QWORD *)(v2 + 48);
  if (!v3)
    return 4294954513;
  v4 = *(NSObject **)(a1 + 7744);
  SessionDataSpecifiers = (const __CFArray *)FigMultivariantPlaylistGetSessionDataSpecifiers(v3);
  if (!SessionDataSpecifiers || CFArrayGetCount(SessionDataSpecifiers) < 1)
    return 0;
  if (*(_QWORD *)(a1 + 7744))
    goto LABEL_10;
  v4 = dispatch_group_create();
  *(_QWORD *)(a1 + 7744) = v4;
  v6 = *(const void **)(a1 + 7896);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 7896) = 0;
    v4 = *(NSObject **)(a1 + 7744);
  }
  if (v4)
  {
LABEL_10:
    dispatch_retain(v4);
    v7 = (_BYTE *)(a1 + 7752);
    if (!*(_BYTE *)(a1 + 7752))
    {
      *v7 = 1;
      v15 = 0;
      v8 = *(NSObject **)(a1 + 7744);
      if (v8)
      {
        dispatch_group_enter(v8);
        if (!*(_QWORD *)(a1 + 9600))
          *(_QWORD *)(a1 + 9600) = FigGetUpTimeNanoseconds();
        v9 = segPumpSendNextSessionDataRequest(a1, v2, &v15);
        if (!v15)
          dispatch_group_leave(*(dispatch_group_t *)(a1 + 7744));
        if ((_DWORD)v9)
          return v9;
      }
      else
      {
        v9 = FigSignalErrorAt();
        if ((_DWORD)v9)
          return v9;
      }
    }
    FigRetainProxyRetain();
    FigRetainProxyUnlockAll();
    dispatch_group_wait(v4, 0xFFFFFFFFFFFFFFFFLL);
    if (*(uint64_t *)(a1 + 9600) >= 1)
    {
      v10 = FigGetUpTimeNanoseconds() - *(_QWORD *)(a1 + 9600);
      if (v10 >= 1)
      {
        v11 = *(_QWORD *)(a1 + 9048);
        if (v11)
        {
          v12 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
          if (v12)
            v12(v11, CFSTR("startupStats"), CFSTR("SDataTime"), v10 / 0xF4240uLL, 0);
        }
      }
    }
    FigRetainProxyRelock();
    dispatch_release(v4);
    if (!FigRetainProxyIsInvalidated())
    {
      *v7 = 0;
      v13 = *(NSObject **)(a1 + 7744);
      if (v13)
      {
        dispatch_release(v13);
        *(_QWORD *)(a1 + 7744) = 0;
      }
    }
    FigRetainProxyRelease();
    return 0;
  }
  return FigSignalErrorAt();
}

uint64_t segPumpCreateIFrameReport(uint64_t a1, const __CFAllocator *a2, CFMutableDictionaryRef *a3)
{
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v6;
  uint64_t result;

  if (!*(_BYTE *)(a1 + 8712))
  {
    v6 = 0;
    goto LABEL_5;
  }
  FigGetUpTimeNanoseconds();
  Mutable = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v6 = Mutable;
    FigCFDictionarySetInt64();
    FigCFDictionarySetInt64();
    FigCFDictionarySetDouble();
    FigCFDictionarySetDouble();
    FigCFDictionarySetInt64();
    FigCFDictionarySetDouble();
LABEL_5:
    result = 0;
    *a3 = v6;
    return result;
  }
  return 4294954510;
}

uint64_t segPumpCreateNetworkStatistics(uint64_t a1, CFAllocatorRef allocator, __CFDictionary **a3)
{
  uint64_t v6;
  __CFDictionary *Mutable;
  int InterfaceTypeEnum;
  const __CFString *StringFromInterfaceType;
  uint64_t result;

  if (!a3)
    return 0;
  v6 = *(_QWORD *)(a1 + 9120);
  if (!v6 || (Mutable = FigNetworkInterfaceReporterCopyPhysicalStatistics(v6)) == 0)
  {
    Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (!Mutable)
      return 4294954510;
  }
  InterfaceTypeEnum = segPumpGetInterfaceTypeEnum(a1, 0);
  StringFromInterfaceType = FigErrorLogGetStringFromInterfaceType(InterfaceTypeEnum);
  CFDictionarySetValue(Mutable, CFSTR("cs-iftype"), StringFromInterfaceType);
  result = 0;
  *a3 = Mutable;
  return result;
}

uint64_t segPumpCreateStartupStatistics(uint64_t a1, CFAllocatorRef allocator, CFMutableDictionaryRef *a3)
{
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v6;
  uint64_t result;

  Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 4294954510;
  v6 = Mutable;
  if (*(_DWORD *)(a1 + 8664))
    FigCFDictionarySetInt32();
  if (*(_DWORD *)(a1 + 8))
    FigCFDictionarySetInt32();
  result = 0;
  *a3 = v6;
  return result;
}

CFTypeRef segPumpCopyRecoveryAlternateIfViable(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  int AverageBitRate;
  double v6;

  if (*(_QWORD *)(a1 + 8248))
  {
    v2 = (_QWORD *)(a1 + 8096);
    while (1)
    {
      v2 = (_QWORD *)*v2;
      if (!v2)
        break;
      if (CFEqual((CFTypeRef)v2[1], *(CFTypeRef *)(a1 + 8248)))
      {
        v6 = 0.0;
        if (*(double *)(a1 + 8904) <= 0.0)
        {
          AverageBitRate = FigAlternateGetAverageBitRate(*(_QWORD *)(a1 + 8248));
          if (!AverageBitRate)
            AverageBitRate = FigAlternateGetPeakBitRate(v2[1]);
          v3 = AverageBitRate;
        }
        else
        {
          v3 = (uint64_t)(*(double *)(a1 + 8904) * (double)(int)FigAlternateGetPeakBitRate(v2[1]));
        }
        if (!segPumpGetSafeNetworkBandwidth(a1, &v6, 0, 0) && v6 >= (double)v3)
          return CFRetain(*(CFTypeRef *)(a1 + 8248));
        return 0;
      }
    }
  }
  return 0;
}

uint64_t segPumpCreateCPECryptorsSessionCryptKeysDict(uint64_t a1, CFTypeRef *a2)
{
  const __CFAllocator *AllocatorForMedia;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v6;
  CFIndex i;
  const __CFArray *Count;
  _QWORD *ValueAtIndex;
  _QWORD *v10;
  uint64_t v11;
  const __CFAllocator *v12;
  CFMutableDictionaryRef v13;
  __CFDictionary *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a2)
    return FigSignalErrorAt();
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return FigSignalErrorAt();
  v6 = Mutable;
  for (i = 0; ; ++i)
  {
    Count = *(const __CFArray **)(a1 + 7688);
    if (Count)
      Count = (const __CFArray *)CFArrayGetCount(Count);
    if (i >= (uint64_t)Count)
    {
      v17 = 0;
      *a2 = CFRetain(v6);
      goto LABEL_22;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 7688), i);
    if (ValueAtIndex[2])
    {
      v10 = ValueAtIndex;
      v11 = ValueAtIndex[8];
      if (v11)
      {
        if (*((_BYTE *)v10 + 147) && *((_BYTE *)v10 + 144) && segPumpIsCryptorReadyToDecrypt(v11))
          break;
      }
    }
LABEL_20:
    ;
  }
  v12 = (const __CFAllocator *)FigGetAllocatorForMedia();
  v13 = CFDictionaryCreateMutable(v12, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v13)
  {
    v14 = v13;
    v15 = v10[8];
    if (v15 && segPumpIsCryptorReadyToDecrypt(v15))
      CFDictionarySetValue(v14, CFSTR("FPBCPECryptorsKey_Video"), (const void *)v10[8]);
    v16 = v10[13];
    if (v16)
    {
      if (segPumpIsCryptorReadyToDecrypt(v16))
        CFDictionarySetValue(v14, CFSTR("FPBCPECryptorsKey_Audio"), (const void *)v10[13]);
    }
    FigCFDictionarySetInt32();
    FigCFDictionarySetInt32();
    CFDictionarySetValue(v6, (const void *)v10[2], v14);
    CFRelease(v14);
    goto LABEL_20;
  }
  v17 = FigSignalErrorAt();
LABEL_22:
  CFRelease(v6);
  return v17;
}

uint64_t segPumpCopyAlternatesInPenaltyBox(uint64_t a1, __CFArray **a2)
{
  const __CFAllocator *AllocatorForMedia;
  CFMutableArrayRef Mutable;
  __CFArray *v6;
  uint64_t **i;

  if (!*(_BYTE *)(a1 + 8176))
    return FigSignalErrorAt();
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  Mutable = CFArrayCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
    return FigSignalErrorAt();
  v6 = Mutable;
  for (i = *(uint64_t ***)(a1 + 8112); i; i = (uint64_t **)*i)
    CFArrayAppendValue(v6, i[1]);
  if (a2)
    *a2 = v6;
  else
    CFRelease(v6);
  return 0;
}

CFNumberRef segPumpCopyNominalVideoFrameRate(uint64_t a1, CFNumberRef *a2)
{
  _QWORD *v3;
  float v4;
  double FrameRate;
  float v6;
  float v7;
  CFNumberRef result;
  float valuePtr;

  if (!a2 || !a1)
    return (CFNumberRef)FigSignalErrorAt();
  v3 = *(_QWORD **)(a1 + 8096);
  if (v3)
  {
    v4 = 0.0;
    while (1)
    {
      FrameRate = FigAlternateGetFrameRate(v3[1]);
      v6 = FrameRate;
      if (v6 == 0.0)
        goto LABEL_18;
      if (v4 != 0.0)
        break;
      v7 = FrameRate;
LABEL_19:
      v3 = (_QWORD *)*v3;
      v4 = v7;
      if (!v3)
        goto LABEL_22;
    }
    if (vabds_f32(v4, v6) > 0.01)
    {
      if (v4 <= v6)
        v7 = FrameRate;
      else
        v7 = v4;
      if (v4 < v6)
        v6 = v4;
      if (fabsf(v7 + (float)(v6 * -2.0)) >= 0.01
        && fabsf(v7 + (float)(v6 * -3.0)) >= 0.01
        && fabsf(v7 + (float)(v6 * -4.0)) >= 0.01)
      {
        v7 = 0.0;
      }
      goto LABEL_19;
    }
LABEL_18:
    v7 = v4;
    goto LABEL_19;
  }
  v7 = 0.0;
LABEL_22:
  valuePtr = v7;
  result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &valuePtr);
  if (!result)
    return (CFNumberRef)FigSignalErrorAt();
  *a2 = result;
  return result;
}

uint64_t segPumpCopySessionKeys(uint64_t a1, __CFArray **a2)
{
  const __CFAllocator *AllocatorForMedia;
  CFMutableArrayRef Mutable;
  __CFArray *v6;
  uint64_t v7;
  uint64_t v8;
  CFIndex i;
  const __CFArray *ContentKeySpecifiers;
  const __CFArray *v11;
  const void *ValueAtIndex;

  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  Mutable = CFArrayCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
    return FigSignalErrorAt();
  v6 = Mutable;
  v7 = *(_QWORD *)(a1 + 384);
  v8 = *(_QWORD *)(v7 + 48);
  if (v8)
  {
    for (i = 0; ; ++i)
    {
      ContentKeySpecifiers = (const __CFArray *)FigMultivariantPlaylistGetContentKeySpecifiers(v8);
      if (ContentKeySpecifiers)
        ContentKeySpecifiers = (const __CFArray *)CFArrayGetCount(ContentKeySpecifiers);
      if (i >= (uint64_t)ContentKeySpecifiers)
        break;
      v11 = (const __CFArray *)FigMultivariantPlaylistGetContentKeySpecifiers(*(_QWORD *)(v7 + 48));
      ValueAtIndex = CFArrayGetValueAtIndex(v11, i);
      if (FigContentKeySpecifierGetIsPrefetchKey((uint64_t)ValueAtIndex))
        CFArrayAppendValue(v6, ValueAtIndex);
      v8 = *(_QWORD *)(v7 + 48);
    }
  }
  *a2 = v6;
  return 0;
}

uint64_t segPumpEnsureNetworkCostMonitor(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t result;
  uint64_t v5;
  void (*v6)(uint64_t, __CFString *, _QWORD);

  if (!*(_QWORD *)(a1 + 8472))
  {
    v3 = (uint64_t *)(a1 + 8472);
    result = FigNetworkCostMonitorCreate(a2, a1 + 8472);
    if ((_DWORD)result)
      return result;
    v5 = *v3;
    if (v5 && *(_BYTE *)(a1 + 9632))
    {
      v6 = *(void (**)(uint64_t, __CFString *, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
      if (v6)
        v6(v5, CFSTR("FNCM_DisableHighSpeedHighPowerBuffering"), *MEMORY[0x1E0C9AE50]);
    }
    segPumpUpdateNetworkCostHasHighSpeedHighPower(a1);
    segPumpUpdateNetworkCostIsExpensive(a1);
    segPumpUpdateNetworkCostHasEndTag(a1);
  }
  return 0;
}

uint64_t *segPumpMainSegmentBytesInTransit(uint64_t a1)
{
  uint64_t v2;
  uint64_t *result;

  v2 = *(_QWORD *)(a1 + 16 * *(_QWORD *)(a1 + 8416) + 384);
  result = segPumpGetBytesInTransit(*(uint64_t **)(v2 + 696), *(_QWORD *)(a1 + 8144));
  if (!result)
    return segPumpGetBytesInTransit(*(uint64_t **)(v2 + 792), *(_QWORD *)(a1 + 8144));
  return result;
}

uint64_t segPumpCopyOfflineInterstitialURLs(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  CFTypeRef v4;
  uint64_t v5;
  CFTypeRef cf;

  cf = 0;
  v4 = *(CFTypeRef *)(a1 + 296);
  if (v4
    && (v5 = FigStreamingCacheCopyProperty((uint64_t)v4, CFSTR("FSC_OfflineInterstitialURLs"), a2, &cf),
        v4 = cf,
        (_DWORD)v5))
  {
    if (cf)
      CFRelease(cf);
  }
  else
  {
    v5 = 0;
    *a3 = v4;
  }
  return v5;
}

BOOL segPumpEnsureCMCDHeaderVendor(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v3;
  uint64_t v4;
  unsigned int (*v5)(uint64_t, _QWORD, uint64_t, CFTypeRef *);
  uint64_t UInt64;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  uint64_t Value;
  const void *v11;
  uint64_t v12;
  uint64_t v13;
  void (*v14)(uint64_t, const __CFString *, uint64_t);
  CFTypeRef cf;

  cf = 0;
  v1 = (uint64_t *)(a1 + 9576);
  if (*(_QWORD *)(a1 + 9576))
    return *v1 != 0;
  v3 = *(_QWORD *)(a1 + 80);
  v4 = *(_QWORD *)(a1 + 56);
  v5 = *(unsigned int (**)(uint64_t, _QWORD, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                            + 48);
  if (!v5 || v5(v3, *MEMORY[0x1E0CA36F8], v4, &cf))
    goto LABEL_14;
  UInt64 = FigCFNumberGetUInt64();
  if (UInt64)
  {
    v7 = UInt64;
    v8 = *(_QWORD *)(a1 + 56);
    v9 = *(const void **)(a1 + 224);
    Value = FigCFDictionaryGetValue();
    if (!FigCMCDHeaderVendorCreate(v8, v9, Value, *(const __CFDictionary **)(a1 + 9128), v1))
    {
      v11 = *(const void **)(a1 + 88);
      if ((!v11 || !FigCMCDHeaderVendorSetNetworkHistory(*v1, v11))
        && !segPumpUpdateCMCDStreamType(a1)
        && !FigCMCDHeaderVendorSetStreamingFormat(*(_QWORD *)(a1 + 9576), *(_BYTE *)(a1 + 329) != 0)
        && !FigCMCDHeaderVendorSetAllowedKeys(*v1, v7))
      {
        v12 = *(_QWORD *)(a1 + 9488);
        if (v12)
        {
          v13 = *v1;
          v14 = *(void (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                            + 56);
          if (v14)
            v14(v12, CFSTR("kCKBP_CMCDHeaderVendor"), v13);
        }
        goto LABEL_16;
      }
    }
LABEL_14:
    if (*v1)
    {
      CFRelease((CFTypeRef)*v1);
      *v1 = 0;
    }
  }
LABEL_16:
  if (cf)
    CFRelease(cf);
  return *v1 != 0;
}

uint64_t segPumpCreateFigAlternatesArrayAndCalculateStartupScore(uint64_t a1, __CFArray **a2)
{
  const __CFAllocator *AllocatorForMedia;
  CFMutableArrayRef Mutable;
  __CFArray *v6;
  uint64_t UpTimeNanoseconds;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t, _OWORD *, __int128 *);
  int v10;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v14;
  uint64_t v15;
  void (*v16)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  int v17;
  _BOOL4 v18;
  uint64_t *v19;
  double v20;
  double v22;
  double v23;
  int v24;
  int v25;
  int v26;
  double v27;
  double v28;
  double v29;
  int v30;
  unsigned int v31;
  double *v32;
  double v33;
  float v34;
  double v35;
  double v36;
  double v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  double v42;
  double v43;
  double v44;
  int NormalizedPeakBitrate;
  double v46;
  float v47;
  uint64_t **i;
  __CFArray **v50;
  float v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  _BYTE v58[224];
  _OWORD v59[14];
  double v60[3];

  if (!a2)
    return FigSignalErrorAt();
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  Mutable = CFArrayCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
    return FigSignalErrorAt();
  v6 = Mutable;
  memset(&v58[8], 0, 216);
  segPumpMakeNetworkPredictionInput(a1, (uint64_t)v58);
  v57 = 0;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v52 = 0u;
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  *(_QWORD *)&v58[16] = 0;
  *(_QWORD *)v58 = 1;
  *(_OWORD *)&v58[56] = *(_OWORD *)(a1 + 128);
  *(_QWORD *)&v58[168] |= 4uLL;
  v8 = *(_QWORD *)(a1 + 96);
  v9 = *(uint64_t (**)(uint64_t, uint64_t, _OWORD *, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
  v50 = a2;
  if (v9)
  {
    v59[10] = *(_OWORD *)&v58[160];
    v59[11] = *(_OWORD *)&v58[176];
    v59[12] = *(_OWORD *)&v58[192];
    v59[13] = *(_OWORD *)&v58[208];
    v59[6] = *(_OWORD *)&v58[96];
    v59[7] = *(_OWORD *)&v58[112];
    v59[8] = *(_OWORD *)&v58[128];
    v59[9] = *(_OWORD *)&v58[144];
    v59[2] = *(_OWORD *)&v58[32];
    v59[3] = *(_OWORD *)&v58[48];
    v59[4] = *(_OWORD *)&v58[64];
    v59[5] = *(_OWORD *)&v58[80];
    v59[0] = *(_OWORD *)v58;
    v59[1] = *(_OWORD *)&v58[16];
    v10 = v9(v8, UpTimeNanoseconds, v59, &v52);
    if (v10)
    {
      LODWORD(v12) = v10;
      v11 = 0;
      v14 = 0;
    }
    else
    {
      v11 = (uint64_t)(*((double *)&v53 + 1) * (double)(uint64_t)v52);
      v12 = *(_QWORD *)(a1 + 9048);
      if (v12)
      {
        v13 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                          + 56);
        if (v13)
          v13(v12, CFSTR("bytePumpStats"), CFSTR("GlobalBW"), v11, 0);
        LODWORD(v12) = 0;
      }
      v14 = 1;
    }
  }
  else
  {
    v11 = 0;
    v14 = 0;
    LODWORD(v12) = -12782;
  }
  if (!*(_BYTE *)(a1 + 9586))
  {
    *(_BYTE *)(a1 + 9586) = 1;
    v15 = *(_QWORD *)(a1 + 9048);
    if (v15)
    {
      v16 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                        + 56);
      if (v16)
        v16(v15, CFSTR("bandwidthPredictionStats"), CFSTR("hasSuffBWHist"), v14, 0);
    }
  }
  if ((_DWORD)v12)
  {
    v17 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("coldStartArbitraryBandwidthGuess"));
    v11 = v17;
    v18 = v17 > 0;
  }
  else
  {
    v18 = 1;
  }
  v19 = *(uint64_t **)(a1 + 8096);
  if (v19)
  {
    v20 = (double)v11;
    v51 = (float)v11;
    do
    {
      if (FigAlternateGetStartupScore(v19[1]) == -1.79769313e308 && v18)
      {
        v22 = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("adaptiveStartupRewardWeight"));
        v23 = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("adaptiveStartupCostWeight"));
        v24 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("fastStartupThresholdMS"));
        v25 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("slowStartupThresholdMS"));
        v26 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("superSlowStartupThresholdMS"));
        v27 = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("fastStartCostScore"));
        v28 = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("slowStartCostScore"));
        v29 = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("superSlowStartCostScore"));
        v30 = *((_DWORD *)v19 + 6);
        *(_QWORD *)&v59[0] = 0;
        *(_QWORD *)v58 = 0;
        *(_QWORD *)&v52 = 0;
        v60[0] = 0.0;
        if (*(_DWORD *)(a1 + 8))
          v31 = *(_DWORD *)(a1 + 8);
        else
          v31 = 6;
        v32 = v60;
        segPumpGetStartupRequirements(a1, v31, (double *)v59, (double *)v58, (double *)&v52, v60, (double)v30);
        if (*(double *)v58 > v20)
        {
          if (*(double *)v59 > v20)
            v32 = (double *)(a1 + 8024);
          else
            v32 = (double *)&v52;
        }
        v33 = (double)v24;
        v34 = *v32 * 1000.0;
        v35 = (float)((float)((float)v30 * v34) / v51);
        if (v35 <= (double)v24)
        {
          v37 = v27 / v33 * v35;
        }
        else
        {
          v36 = (double)v25;
          if (v35 > (double)v25)
            v37 = v28 + (v29 - v28) / ((double)v26 - v36) * (v35 - v36);
          else
            v37 = v27 + (v28 - v27) / (v36 - v33) * (v35 - v33);
        }
        v38 = v19[1];
        v39 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("lowQualityBWThreshold"));
        v40 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("highQualityBWThreshold"));
        v41 = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("superHighQualityBWThreshold"));
        v42 = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("lowQualityRewardScore"));
        v43 = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("highQualityRewardScore"));
        v44 = FigRCLGetDoubleWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("superHighQualityRewardScore"));
        NormalizedPeakBitrate = FigAlternateGetNormalizedPeakBitrate(v38);
        if (NormalizedPeakBitrate <= v39)
        {
          v46 = v42 / (double)v39 * (double)NormalizedPeakBitrate;
        }
        else
        {
          v46 = v43 + (v44 - v43) / (double)(v41 - v40) * (double)(NormalizedPeakBitrate - v40);
          if (NormalizedPeakBitrate <= v40)
            v46 = v42 + (v43 - v42) / (double)(v40 - v39) * (double)(NormalizedPeakBitrate - v39);
        }
        v47 = v37;
        FigAlternateSetStartupScore(v19[1], v22 * (double)(int)v46 - v23 * v47);
      }
      CFArrayAppendValue(v6, (const void *)v19[1]);
      v19 = (uint64_t *)*v19;
    }
    while (v19);
  }
  for (i = *(uint64_t ***)(a1 + 8112); i; i = (uint64_t **)*i)
    CFArrayAppendValue(v6, i[1]);
  *v50 = v6;
  return 0;
}

uint64_t segPumpGetStartupRequirements(uint64_t result, unsigned int a2, double *a3, double *a4, double *a5, double *a6, double a7)
{
  unsigned int v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;

  if (a2 >= 0xF)
    v7 = 15;
  else
    v7 = a2;
  v8 = (double)v7;
  if (*(_BYTE *)(result + 329))
  {
    v9 = *(double *)(result + 16) + *(double *)(result + 16);
    if (v9 >= *(double *)(result + 7952))
      v9 = *(double *)(result + 7952);
  }
  else
  {
    v9 = *(double *)(result + 8032) * v8;
  }
  v10 = *(double *)(result + 8040) * v8;
  if (v10 < 1.0)
    v10 = 1.0;
  if (v10 > v9)
    v10 = v9;
  if (a3)
    *a3 = a7;
  if (a4)
  {
    v11 = *(double *)(result + 8704);
    v12 = *(double *)(result + 8048) * a7 * v11;
    v13 = *(double *)(result + 8056);
    v14 = v13 + a7 * v11;
    if (v12 < v14)
      v14 = v12;
    if (v13 == 0.0)
      v14 = v12;
    *a4 = v14;
  }
  if (a5)
    *a5 = v9;
  if (a6)
    *a6 = v10;
  return result;
}

const __CFArray *segPumpStreamHasMediaFiles(uint64_t a1)
{
  const __CFArray *result;

  result = *(const __CFArray **)(a1 + 56);
  if (result)
  {
    result = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers((uint64_t)result);
    if (result)
      return (const __CFArray *)(CFArrayGetCount(result) > 0);
  }
  return result;
}

double segPumpGetMinimumPrebufferReservation(uint64_t a1, uint64_t a2)
{
  double v3;
  double result;
  int v5;

  if (*(_BYTE *)(a1 + 328) && (v3 = *(double *)(a1 + 16), v3 > 0.0))
  {
    result = v3 + v3;
    if (*(double *)(a1 + 7952) > result)
      return *(double *)(a1 + 7952);
  }
  else
  {
    result = segPumpGetDurationOfLastMediaSegment(a2);
    v5 = *(_DWORD *)(a1 + 7944);
    if (result == 0.0)
    {
      result = (double)(*(_DWORD *)(a1 + 8) * v5);
    }
    else if (v5 >= 2)
    {
      result = result + (double)(*(_DWORD *)(a1 + 8) * (v5 - 1));
    }
    if (result < *(double *)(a1 + 7952))
      return *(double *)(a1 + 7952);
  }
  return result;
}

double segPumpGetDurationOfLastMediaSegment(uint64_t a1)
{
  const __CFArray *MediaSegmentSpecifiers;
  uint64_t LastValue;

  if (!a1)
    return 0.0;
  MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
  if (!MediaSegmentSpecifiers || CFArrayGetCount(MediaSegmentSpecifiers) < 1)
    return 0.0;
  FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
  LastValue = FigCFArrayGetLastValue();
  return FigMediaSegmentSpecifierGetTimeInSeconds(LastValue);
}

double segPumpMakeNetworkPrediction(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  double v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int AverageBitRate;
  uint64_t v13;
  uint64_t UpTimeNanoseconds;
  void (*v15)(uint64_t, uint64_t, _OWORD *, __int128 *);
  __int128 v16;
  double result;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  _OWORD v25[4];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  _OWORD v36[14];

  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  memset(v25, 0, sizeof(v25));
  segPumpMakeNetworkPredictionInput(a1, (uint64_t)v25);
  v24 = 0;
  HIDWORD(v4) = 0;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v19 = 0u;
  v5 = *(_QWORD *)(a1 + 16 * *(_QWORD *)(a1 + 8416) + 384);
  v6 = 104;
  if (!*(_BYTE *)(a1 + 329))
    v6 = 112;
  v7 = *(double *)(a1 + 16);
  if (v7 <= 0.0)
  {
    LODWORD(v4) = *(_DWORD *)(a1 + 8);
    v7 = (double)v4;
  }
  v8 = *(_QWORD *)(a1 + v6);
  v9 = *(_QWORD *)(v5 + 256);
  if (v9 && FigMediaSegmentSpecifierGetBytesToRead(v9))
  {
    v10 = FigMediaSegmentSpecifierGetBytesToRead(*(_QWORD *)(v5 + 256));
LABEL_14:
    *(_QWORD *)&v25[2] = v10;
    goto LABEL_15;
  }
  v11 = *(_QWORD *)(a1 + 8144);
  if (v11)
  {
    AverageBitRate = FigAlternateGetAverageBitRate(*(_QWORD *)(v11 + 8));
    if (!AverageBitRate)
      AverageBitRate = FigAlternateGetPeakBitRate(*(_QWORD *)(*(_QWORD *)(a1 + 8144) + 8));
    if (AverageBitRate && v7 != 0.0)
    {
      v10 = (uint64_t)(v7 * (double)AverageBitRate * 0.125);
      goto LABEL_14;
    }
  }
LABEL_15:
  *(_QWORD *)&v25[1] = 60000000000;
  if (*(_BYTE *)(a1 + 329))
  {
    *(_OWORD *)((char *)&v25[2] + 8) = xmmword_1932FD0D0;
    *(_OWORD *)((char *)v25 + 8) = xmmword_1932FD0E0;
    *((_QWORD *)&v25[1] + 1) = 10000000000;
    if (*(_BYTE *)(a1 + 334))
    {
      *((_QWORD *)&v31 + 1) = 0x3FEEB851EB851EB8;
      LOBYTE(v32) = 1;
    }
  }
  *(_QWORD *)&v25[0] = v8;
  *((_QWORD *)&v32 + 1) |= 8uLL;
  v13 = *(_QWORD *)(a1 + 96);
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v15 = *(void (**)(uint64_t, uint64_t, _OWORD *, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
  if (v15)
  {
    v36[10] = v32;
    v36[11] = v33;
    v36[12] = v34;
    v36[13] = v35;
    v36[6] = v28;
    v36[7] = v29;
    v36[8] = v30;
    v36[9] = v31;
    v36[2] = v25[2];
    v36[3] = v25[3];
    v36[4] = v26;
    v36[5] = v27;
    v36[0] = v25[0];
    v36[1] = v25[1];
    v15(v13, UpTimeNanoseconds, v36, &v19);
  }
  v16 = v22;
  *(_OWORD *)(a2 + 32) = v21;
  *(_OWORD *)(a2 + 48) = v16;
  *(_OWORD *)(a2 + 64) = v23;
  *(_QWORD *)(a2 + 80) = v24;
  result = *(double *)&v19;
  v18 = v20;
  *(_OWORD *)a2 = v19;
  *(_OWORD *)(a2 + 16) = v18;
  return result;
}

uint64_t segPumpSendNextSessionDataRequest(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v4;
  const void *v7;
  const void *v8;
  CFTypeRef *v9;
  const void *v10;
  _QWORD *v11;
  CFIndex i;
  const __CFArray *SessionDataSpecifiers;
  const __CFArray *v14;
  const void *ValueAtIndex;
  _QWORD *SessionDataPrivateData;
  uint64_t v17;
  void *Identifier;
  const void *v19;
  const void *Language;
  const void *v21;
  const void *v22;
  uint64_t v23;
  const void *URL;
  const void *v25;
  uint64_t UpTimeNanoseconds;
  CFTypeRef v27;
  int URLAndString;
  CFTypeRef v29;
  int v30;
  uint64_t v31;
  void (*v32)(uint64_t, __CFString *, __CFString *, uint64_t);
  CFTypeRef v33;
  _QWORD *v34;
  _QWORD *v35;
  CFTypeRef v36;
  uint64_t HTTPRequest;
  const __CFURL *v38;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v40;
  uint64_t v41;
  void (*v42)(uint64_t, __CFString *, __CFString *, uint64_t);
  BOOL v43;
  uint64_t v44;
  void (*v45)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v46;
  const void *v47;
  const void *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void *value;
  CFTypeRef v54;
  CFTypeRef cf[2];
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  value = 0;
  v54 = 0;
  v4 = *(_QWORD *)(a2 + 48);
  if (!v4)
  {
    v7 = 0;
LABEL_82:
    HTTPRequest = 0;
    goto LABEL_71;
  }
  v7 = *(const void **)(a1 + 7776);
  v8 = *(const void **)(a1 + 7872);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 7872) = 0;
  }
  v9 = (CFTypeRef *)(a1 + 7760);
  *(_QWORD *)(a1 + 7776) = 0;
  *(_QWORD *)(a1 + 7848) = 0;
  v10 = *(const void **)(a1 + 7896);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 7896) = 0;
  }
  v11 = 0;
  for (i = 0; ; ++i)
  {
    SessionDataSpecifiers = (const __CFArray *)FigMultivariantPlaylistGetSessionDataSpecifiers(*(_QWORD *)(a2 + 48));
    if (SessionDataSpecifiers)
      SessionDataSpecifiers = (const __CFArray *)CFArrayGetCount(SessionDataSpecifiers);
    if (i >= (uint64_t)SessionDataSpecifiers)
      break;
    v14 = (const __CFArray *)FigMultivariantPlaylistGetSessionDataSpecifiers(*(_QWORD *)(a2 + 48));
    ValueAtIndex = CFArrayGetValueAtIndex(v14, i);
    if (FigSessionDataSpecifierGetURL((uint64_t)ValueAtIndex))
    {
      SessionDataPrivateData = segPumpEnsureAndGetSessionDataPrivateData(ValueAtIndex);
      v11 = SessionDataPrivateData;
      if (SessionDataPrivateData && !*((_BYTE *)SessionDataPrivateData + 16))
      {
        v21 = (const void *)SessionDataPrivateData[4];
        if (v21)
        {
          CFRelease(v21);
          v11[4] = 0;
        }
        segPumpFreeChapterArtworkQueue((uint64_t)(v11 + 23));
        *((_WORD *)v11 + 9) = 0;
        v22 = *(const void **)(a1 + 7896);
        *(_QWORD *)(a1 + 7896) = ValueAtIndex;
        if (ValueAtIndex)
          CFRetain(ValueAtIndex);
        if (v22)
          CFRelease(v22);
        v11[23] = 0;
        v11[24] = v11 + 23;
        break;
      }
    }
    else if (FigSessionDataSpecifierGetValue((uint64_t)ValueAtIndex))
    {
      v17 = segPumpEnsureMetadataArray(a1);
      if ((_DWORD)v17)
        goto LABEL_88;
      Identifier = (void *)FigSessionDataSpecifierGetIdentifier((uint64_t)ValueAtIndex);
      v19 = (const void *)FigSessionDataSpecifierGetValue((uint64_t)ValueAtIndex);
      Language = (const void *)FigSessionDataSpecifierGetLanguage((uint64_t)ValueAtIndex);
      v17 = FigHLSSessionDataCopyMetadataEntry(Identifier, v19, Language, 0, (CFMutableDictionaryRef *)&value);
      if ((_DWORD)v17)
        goto LABEL_88;
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 7696), value);
      if (value)
      {
        CFRelease(value);
        value = 0;
      }
    }
  }
  v23 = *(_QWORD *)(a1 + 7896);
  if (!v23)
  {
    LOBYTE(v4) = 0;
    goto LABEL_82;
  }
  if (!FigSessionDataSpecifierGetURL(v23))
  {
    v17 = FigSignalErrorAt();
    goto LABEL_88;
  }
  if (!*(_BYTE *)(a1 + 320))
    goto LABEL_35;
  cf[0] = 0;
  URL = (const void *)FigSessionDataSpecifierGetURL(*(_QWORD *)(a1 + 7896));
  if (URL)
    URL = CFRetain(URL);
  cf[0] = URL;
  v17 = FigCFHTTPCopyURLAndInheritQueyComponentIfNotPresent(*(const __CFURL **)(a1 + 312), (CFURLRef *)cf);
  if ((_DWORD)v17)
  {
LABEL_88:
    HTTPRequest = v17;
    LOBYTE(v4) = 0;
    goto LABEL_71;
  }
  FigSessionDataSpecifierSetURL(*(_QWORD *)(a1 + 7896), cf[0]);
  if (cf[0])
    CFRelease(cf[0]);
LABEL_35:
  if (*v9)
  {
    CFRelease(*v9);
    *v9 = 0;
  }
  v25 = (const void *)FigSessionDataSpecifierGetURL(*(_QWORD *)(a1 + 7896));
  *(_QWORD *)(a1 + 7760) = CFRetain(v25);
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  *(_QWORD *)(a1 + 7792) = UpTimeNanoseconds;
  if (!*(_DWORD *)(a1 + 7824))
    *(_QWORD *)(a1 + 7784) = UpTimeNanoseconds;
  if (!*(_QWORD *)(a1 + 296))
    goto LABEL_44;
  v27 = *v9;
  cf[0] = 0;
  URLAndString = segPumpCreateURLAndString(v27, 0, cf);
  v29 = cf[0];
  if (!(_WORD)URLAndString)
  {
    v30 = FigStreamingCacheCopySessionData(*(_QWORD *)(a1 + 296), cf[0], &v54);
    v29 = cf[0];
    if (!cf[0])
      goto LABEL_43;
    goto LABEL_42;
  }
  v30 = URLAndString;
  if (cf[0])
LABEL_42:
    CFRelease(v29);
LABEL_43:
  if (v30 << 16)
  {
    LOBYTE(v4) = 0;
    HTTPRequest = (__int16)v30;
    goto LABEL_71;
  }
LABEL_44:
  v31 = *(_QWORD *)(a1 + 9048);
  if (v31)
  {
    v32 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                              + 32);
    if (v32)
      v32(v31, CFSTR("startupStats"), CFSTR("SDataCount"), 1);
  }
  v33 = v54;
  if (v54)
  {
    *((_BYTE *)v11 + 16) = 1;
    v34 = malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
    if (v34)
    {
      v35 = v34;
      v36 = *(CFTypeRef *)a1;
      if (*(_QWORD *)a1)
        v36 = CFRetain(v36);
      *v35 = v36;
      v35[1] = a2;
      v35[2] = CFRetain(v33);
      dispatch_async_f(*(dispatch_queue_t *)(a1 + 72), v35, (dispatch_function_t)segPumpDispatchParseSessionDataFromCacheFunc);
      goto LABEL_52;
    }
    v17 = FigSignalErrorAt();
    if (!(_DWORD)v17)
    {
LABEL_52:
      HTTPRequest = 0;
      LOBYTE(v4) = 1;
      goto LABEL_71;
    }
    goto LABEL_88;
  }
  v38 = (const __CFURL *)FigSessionDataSpecifierGetURL(*(_QWORD *)(a1 + 7896));
  if (segPumpShouldRequestURLAsHTTPURL(a1, v38))
  {
    if (dword_1EE2A31E8)
    {
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    if (!*(_QWORD *)(a1 + 9616))
      *(_QWORD *)(a1 + 9616) = FigGetUpTimeNanoseconds();
    v44 = *(_QWORD *)(a1 + 9048);
    if (v44)
    {
      v45 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                            + 16)
                                                                                + 32);
      if (v45)
        v45(v44, CFSTR("startupStats"), CFSTR("SDataHTTPCount"), 1);
    }
    v46 = *(_QWORD *)(a1 + 56);
    v47 = *(const void **)(a1 + 7768);
    v48 = (const void *)FigSessionDataSpecifierGetURL(*(_QWORD *)(a1 + 7896));
    v49 = *(_QWORD *)(a1 + 216);
    v50 = *(_QWORD *)(a1 + 240);
    v51 = *(_QWORD *)a1;
    v57 = 0u;
    v58 = 0u;
    *(_OWORD *)cf = 0u;
    v56 = 0u;
    v59 = 0x900000000;
    v60 = 0u;
    v61 = 0u;
    v62 = 0;
    HTTPRequest = segPumpCreateHTTPRequest(a1, v46, 0, v47, (uint64_t)v7, v48, v49, v50, 0.5, 0, 8, 1u, (__int128 *)cf, 0, 0, 0, (uint64_t)segPumpSessionDataReadCallback, v51, 0,
                    (uint64_t)v9);
    v43 = (_DWORD)HTTPRequest == 0;
  }
  else
  {
    v40 = FigSessionDataSpecifierGetURL(*(_QWORD *)(a1 + 7896));
    HTTPRequest = segPumpCustomURLLoaderGetURLGuts((uint64_t *)a1, v40, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)(v11 + 3));
    if (!*(_QWORD *)(a1 + 9624))
      *(_QWORD *)(a1 + 9624) = FigGetUpTimeNanoseconds();
    v41 = *(_QWORD *)(a1 + 9048);
    if (v41)
    {
      v42 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                            + 16)
                                                                                + 32);
      if (v42)
        v42(v41, CFSTR("startupStats"), CFSTR("SDataCURLCount"), 1);
    }
    v43 = (_DWORD)HTTPRequest == 0;
  }
  LOBYTE(v4) = v43;
LABEL_71:
  if (a3)
    *a3 = v4;
  if (value)
    CFRelease(value);
  if (v7)
    CFRelease(v7);
  if (v54)
    CFRelease(v54);
  return HTTPRequest;
}

const void *segPumpEnsureAndGetSessionDataPrivateData(const void *a1)
{
  const void *Instance;
  __int128 v4;

  Instance = CMGetAttachment(a1, CFSTR("SegPumpSessionDataPrivateData"), 0);
  if (!Instance)
  {
    FigGetAllocatorForMedia();
    v4 = xmmword_1E2FA7060;
    if (segPumpSessionDataPrivateDataGetTypeID_once != -1)
      dispatch_once_f(&segPumpSessionDataPrivateDataGetTypeID_once, &v4, (dispatch_function_t)segPumpRegisterClassUtil);
    Instance = (const void *)_CFRuntimeCreateInstance();
    if (Instance)
    {
      CMSetAttachment(a1, CFSTR("SegPumpSessionDataPrivateData"), Instance, 0);
      CFRelease(Instance);
    }
    else
    {
      FigSignalErrorAt();
    }
  }
  return Instance;
}

void segPumpFreeChapterArtworkQueue(uint64_t a1)
{
  uint64_t *i;
  uint64_t v3;
  _QWORD *v4;
  const void *v5;
  const void *v6;

  for (i = *(uint64_t **)a1; *(_QWORD *)a1; i = *(uint64_t **)a1)
  {
    v3 = *i;
    v4 = (_QWORD *)i[1];
    if (*i)
    {
      *(_QWORD *)(v3 + 8) = v4;
      v4 = (_QWORD *)i[1];
    }
    else
    {
      *(_QWORD *)(a1 + 8) = v4;
    }
    *v4 = v3;
    v5 = (const void *)i[2];
    if (v5)
      CFRelease(v5);
    v6 = (const void *)i[4];
    if (v6)
      CFRelease(v6);
    free(i);
  }
}

uint64_t segPumpEnsureMetadataArray(uint64_t a1)
{
  const __CFAllocator *AllocatorForMedia;
  CFMutableArrayRef Mutable;

  if (*(_QWORD *)(a1 + 7696))
    return 0;
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  Mutable = CFArrayCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B378]);
  *(_QWORD *)(a1 + 7696) = Mutable;
  if (Mutable)
    return 0;
  else
    return FigSignalErrorAt();
}

BOOL segPumpShouldRequestURLAsHTTPURL(uint64_t a1, const __CFURL *a2)
{
  if (*(_BYTE *)(a1 + 327))
    return 0;
  if (FigCFHTTPIsHTTPBasedURL(a2))
    return 1;
  return FigCFHTTPIsDataURL(a2);
}

uint64_t segPumpCreateHTTPRequest(uint64_t a1, uint64_t a2, _QWORD *a3, const void *a4, uint64_t a5, CFTypeRef cf, uint64_t a7, uint64_t a8, float a9, const __CFArray *a10, int a11, unsigned int a12, __int128 *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, const void *a19, uint64_t a20)
{
  _BOOL4 v21;
  uint64_t URLWithQueryParams;
  CFTypeRef v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t (*v33)(uint64_t, uint64_t, _QWORD, CFTypeRef *);
  char v34;
  uint64_t v35;
  uint64_t v36;
  __int128 *v37;
  __CFDictionary *v38;
  CFTypeRef v39;
  uint64_t v40;
  void (*v41)(CFTypeRef, __CFString *, uint64_t);
  CFTypeRef v42;
  CFTypeRef v43;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  uint64_t (*v48)(CFTypeRef, uint64_t, uint64_t, CFTypeRef, _QWORD, uint64_t, __CFDictionary *, uint64_t, _OWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *, int *);
  uint64_t v49;
  uint64_t v50;
  int v51;
  const void *v52;
  CFTypeRef v53;
  const void *v54;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  const void *v56;
  CFNumberRef v57;
  CFNumberRef v58;
  uint64_t v59;
  void (*v60)(uint64_t, __CFString *, CFNumberRef);
  uint64_t v62;
  char v63;
  CFTypeRef v64;
  int v65;
  uint64_t v66;
  CFTypeRef cfa;
  _OWORD valuePtr[8];
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  v66 = 0;
  cfa = a4;
  v65 = 0;
  v21 = (a12 & 1) == 0 || a5 == 0;
  v64 = 0;
  if (*(_BYTE *)(a1 + 327))
  {
LABEL_62:
    URLWithQueryParams = FigSignalErrorAt();
    goto LABEL_63;
  }
  URLWithQueryParams = segPumpCreateURLWithQueryParams(a1, cf, a10, (const __CFURL **)&v64);
  if ((_DWORD)URLWithQueryParams)
  {
LABEL_63:
    v50 = URLWithQueryParams;
    goto LABEL_58;
  }
  if (*(_BYTE *)(a1 + 48))
  {
    v30 = *(CFTypeRef *)(a1 + 40);
    cfa = v30;
    if (!v30)
      goto LABEL_15;
LABEL_13:
    if (!v21 || v30 == *(CFTypeRef *)(a1 + 40))
    {
      v34 = 1;
      goto LABEL_23;
    }
    goto LABEL_15;
  }
  v30 = cfa;
  if (cfa)
    goto LABEL_13;
LABEL_15:
  v31 = *(_QWORD *)(a1 + 32);
  if (!v31)
    goto LABEL_62;
  v32 = *(_QWORD *)(a1 + 64);
  v33 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                        + 40);
  if (!v33)
  {
    v50 = 4294954514;
    goto LABEL_58;
  }
  URLWithQueryParams = v33(v31, v32, 0, &cfa);
  if ((_DWORD)URLWithQueryParams)
    goto LABEL_63;
  if (!cfa)
    goto LABEL_62;
  if (*(_BYTE *)(a1 + 48) && !*(_QWORD *)(a1 + 40))
  {
    v34 = 0;
    *(_QWORD *)(a1 + 40) = CFRetain(cfa);
  }
  else
  {
    v34 = 0;
  }
LABEL_23:
  v35 = segPumpAmendHTTPRequestFlags((_BYTE *)a1, &a12);
  if ((_DWORD)v35)
  {
    v50 = v35;
    if ((v34 & 1) == 0)
LABEL_57:
      CFRelease(cfa);
  }
  else
  {
    v62 = a7;
    v63 = v34;
    v36 = a20;
    v37 = a13;
    v38 = segPumpCopyHTTPRequestCreationsOptionsAndSetNWActivityAndStuff(a9, a8, a1, a3, a11, a19);
    if (segPumpEnsureCMCDHeaderVendor(a1))
    {
      v39 = cfa;
      v40 = *(_QWORD *)(a1 + 9576);
      v41 = *(void (**)(CFTypeRef, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
      if (v41)
        v41(v39, CFSTR("FHRSP_CMCDHeaderVendor"), v40);
    }
    v42 = cfa;
    v43 = v64;
    v44 = a12;
    v45 = v37[5];
    v73 = v37[4];
    v74 = v45;
    v75 = v37[6];
    v46 = v37[1];
    v69 = *v37;
    v70 = v46;
    v47 = v37[3];
    v71 = v37[2];
    v72 = v47;
    v48 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t, CFTypeRef, _QWORD, uint64_t, __CFDictionary *, uint64_t, _OWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *, int *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
    if (v48)
    {
      valuePtr[4] = v73;
      valuePtr[5] = v74;
      valuePtr[6] = v75;
      valuePtr[0] = v69;
      valuePtr[1] = v70;
      valuePtr[2] = v71;
      valuePtr[3] = v72;
      v49 = v48(v42, a2, a5, v43, 0, v62, v38, v44, valuePtr, a14, a15, a16, a17, a18, &v66, &v65);
      if ((_DWORD)v49)
      {
        v50 = v49;
        v51 = 0;
      }
      else
      {
        if (!*(_BYTE *)(a1 + 328))
          FigNetworkUrgencyMonitorAddHTTPRequest(*(_QWORD *)(a1 + 9512), v66);
        v50 = 0;
        v51 = 1;
      }
    }
    else
    {
      v51 = 0;
      v50 = 4294954514;
    }
    v52 = *(const void **)(v36 + 8);
    v53 = cfa;
    *(_QWORD *)(v36 + 8) = cfa;
    if (v53)
      CFRetain(v53);
    if (v52)
      CFRelease(v52);
    v54 = *(const void **)(v36 + 16);
    if (v54)
      CFRelease(v54);
    *(_QWORD *)(v36 + 16) = v66;
    *(_DWORD *)(v36 + 80) = v65;
    if (dword_1EE2A31E8)
    {
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    v56 = *(const void **)v36;
    *(_QWORD *)v36 = v43;
    if (v43)
      CFRetain(v43);
    if (v56)
      CFRelease(v56);
    if (v51)
    {
      if ((a12 & 0x400) != 0)
      {
        *(_QWORD *)&valuePtr[0] = segPumpGetCurrentRTT((_QWORD *)a1);
        v57 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, valuePtr);
        if (v57)
        {
          v58 = v57;
          v59 = v66;
          v60 = *(void (**)(uint64_t, __CFString *, CFNumberRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                          + 56);
          if (v60)
            v60(v59, CFSTR("FHRP_DefaultLatency"), v58);
          CFRelease(v58);
        }
      }
      v50 = 0;
    }
    if (v38)
      CFRelease(v38);
    if ((v63 & 1) == 0)
      goto LABEL_57;
  }
LABEL_58:
  if (v64)
    CFRelease(v64);
  return v50;
}

uint64_t segPumpSessionDataReadCallback(uint64_t a1, uint64_t a2, uint64_t a3, OpaqueCMBlockBuffer *a4, size_t a5, size_t a6, char a7, int a8)
{
  uint64_t v14;
  uint64_t v15;
  _BOOL4 v16;
  OpaqueCMBlockBuffer *v17;
  const __CFAllocator *AllocatorForMedia;
  uint64_t Empty;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD);
  BOOL v25;
  uint64_t v26;
  CFTypeRef cf;

  v26 = 0;
  cf = 0;
  v25 = 0;
  FigRetainProxyRetain();
  if (!segPumpLockAndCopyPumpFromRetainProxy(a3, &cf, &v26))
  {
    if (*(_QWORD *)(v26 + 7744))
    {
      if (!*(_QWORD *)(v26 + 7896))
        goto LABEL_21;
      v14 = *(_QWORD *)(v26 + 384);
      if (a8)
      {
        v15 = segPumpHandleSessionDataNetworkError((uint64_t)cf, *(_QWORD *)(v26 + 384), a8, 0, 0, &v25);
        v16 = (v15 | v25) == 0;
        goto LABEL_6;
      }
      if (a4)
      {
        v17 = *(OpaqueCMBlockBuffer **)(v26 + 7872);
        if (!v17)
        {
          AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
          Empty = CMBlockBufferCreateEmpty(AllocatorForMedia, 0, 0, (CMBlockBufferRef *)(v26 + 7872));
          if ((_DWORD)Empty)
            goto LABEL_31;
          v17 = *(OpaqueCMBlockBuffer **)(v26 + 7872);
        }
        Empty = CMBlockBufferAppendBufferReference(v17, a4, a5, a6, 0);
        if ((_DWORD)Empty)
          goto LABEL_31;
      }
      if ((a7 & 2) == 0)
        goto LABEL_21;
      *((_BYTE *)segPumpEnsureAndGetSessionDataPrivateData(*(const void **)(v26 + 7896)) + 16) = 1;
      v20 = v26;
      *(_DWORD *)(v26 + 7824) = 0;
      if (*(_QWORD *)(v20 + 7832))
      {
        CFRelease(*(CFTypeRef *)(v20 + 7832));
        v20 = v26;
        *(_QWORD *)(v26 + 7832) = 0;
      }
      Empty = segPumpSetWiFiStatsOnNetworkPredictor(v20, v20 + 7760);
      if (!(_DWORD)Empty)
      {
        segPumpParseSessionDataFromConnection((uint64_t)cf, v26, v14);
        v15 = segPumpSendNextSessionDataRequest(v26, v14, &v25);
        if (v25)
        {
          v16 = 0;
        }
        else
        {
          segPumpResetConnection(v26, v26 + 7760);
          if (*(uint64_t *)(v26 + 9616) >= 1)
          {
            v22 = FigGetUpTimeNanoseconds() - *(_QWORD *)(v26 + 9616);
            if (v22 >= 1)
            {
              v23 = *(_QWORD *)(v26 + 9048);
              if (v23)
              {
                v24 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
                if (v24)
                  v24(v23, CFSTR("startupStats"), CFSTR("SDataHTTPTime"), v22 / 0xF4240uLL, 0);
              }
            }
          }
          v16 = 1;
        }
LABEL_6:
        if (!(_DWORD)v15)
        {
          if (!v16)
            goto LABEL_21;
          goto LABEL_20;
        }
LABEL_7:
        segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(a3, v15);
LABEL_20:
        dispatch_group_leave(*(dispatch_group_t *)(v26 + 7744));
        goto LABEL_21;
      }
LABEL_31:
      v15 = Empty;
      goto LABEL_7;
    }
    FigSignalErrorAt();
  }
LABEL_21:
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
  return FigRetainProxyRelease();
}

void segPumpSessionDataPrivateDataFinalize(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 32);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 32) = 0;
  }
  segPumpFreeChapterArtworkQueue(a1 + 184);
}

CFStringRef segPumpSessionDataPrivateDataCopyDesc(uint64_t a1)
{
  const __CFAllocator *AllocatorForMedia;

  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  return CFStringCreateWithFormat(AllocatorForMedia, 0, CFSTR("SessionDataPrivateData: %p"), a1);
}

uint64_t segPumpCreateURLAndString(const void *a1, CFTypeRef *a2, CFTypeRef *a3)
{
  const __CFURL *v5;
  const __CFURL *v6;

  if (!a1)
    return FigSignalErrorAt();
  v5 = (const __CFURL *)CFRetain(a1);
  if (!v5)
    return FigSignalErrorAt();
  v6 = v5;
  if (a2)
    *a2 = CFRetain(v5);
  if (a3)
    *a3 = FigCFHTTPCreateURLString(v6);
  CFRelease(v6);
  return 0;
}

void segPumpDispatchParseSessionDataFromCacheFunc(void *a1)
{
  OpaqueCMBlockBuffer *v2;
  uint64_t v3;
  const void *v4;
  const __CFAllocator *AllocatorForMedia;
  const __CFAllocator *v6;
  int v7;
  CMBlockBufferRef blockBufferOut;
  uint64_t v9;
  CFTypeRef v10;
  char v11;

  v3 = *((_QWORD *)a1 + 1);
  v2 = (OpaqueCMBlockBuffer *)*((_QWORD *)a1 + 2);
  v4 = *(const void **)a1;
  v11 = 0;
  v9 = 0;
  v10 = 0;
  blockBufferOut = 0;
  if (!segPumpLockAndCopyPumpFromRetainProxy((uint64_t)v4, &v10, &v9))
  {
    AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    v6 = (const __CFAllocator *)FigGetAllocatorForMedia();
    if (!CMBlockBufferCreateContiguous(AllocatorForMedia, v2, v6, 0, 0, 0, 0, &blockBufferOut))
    {
      FigGetAllocatorForMedia();
      if (!FigCreateCFDataWithBlockBufferNoCopy()
        && !segPumpParseSessionDataBuffer(v9, 0, 0))
      {
        v7 = segPumpSendNextSessionDataRequest(v9, v3, &v11);
        if (v11)
        {
          if (!v7)
            goto LABEL_10;
        }
        else
        {
          segPumpResetConnection(v9, v9 + 7760);
        }
      }
    }
    dispatch_group_leave(*(dispatch_group_t *)(v9 + 7744));
  }
LABEL_10:
  segPumpUnlockAndSendAllPendingNotifications();
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  if (v10)
    CFRelease(v10);
  if (v2)
    CFRelease(v2);
  if (v4)
    CFRelease(v4);
  free(a1);
}

uint64_t segPumpParseSessionDataBuffer(uint64_t a1, const void *a2, void *a3)
{
  uint64_t v5;
  const void *v6;
  const void *SessionDataPrivateData;
  const __CFAllocator *v8;
  const __CFURL *v9;
  int v10;
  uint64_t v11;
  const __CFURL *URL;
  const __CFAllocator *v13;
  const __CFURL *v14;
  __CFDictionary *Entry;
  __CFDictionary *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  CFIndex i;
  const __CFArray *SessionDataSpecifiers;
  const __CFArray *v23;
  const void *ValueAtIndex;
  _BYTE *v25;
  _QWORD *v26;
  _QWORD *v27;
  const __CFAllocator *v28;
  CFMutableArrayRef Mutable;
  const void *Identifier;
  double v31;
  const __CFURL *v32;
  const __CFAllocator *v33;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v35;
  int v36;
  __CFArray *v37;
  const __CFArray *v38;
  CFRange v39;
  const __CFArray *v40;
  const __CFArray *v41;
  const __CFAllocator *v42;
  CFMutableArrayRef v43;
  CFIndex v44;
  const __CFDictionary *v45;
  const __CFArray *v46;
  const __CFAllocator *v47;
  CFMutableDictionaryRef v48;
  const __CFAllocator *v49;
  CFMutableArrayRef v50;
  CFIndex v51;
  const __CFDictionary *v52;
  const __CFString *v53;
  const __CFAllocator *v54;
  CFMutableDictionaryRef v55;
  const __CFAllocator *v56;
  const __CFURL *v57;
  uint64_t v58;
  CFStringRef v59;
  const void *v60;
  const void *v61;
  void *v62;
  const void *Language;
  const __CFURL *v64;
  CFTypeRef v65;
  uint64_t v66;
  uint64_t v67;
  void (*v68)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD);
  uint64_t v69;
  void (*v70)(uint64_t, __CFString *, __CFString *, uint64_t);
  const __CFAllocator *AllocatorForMedia;
  const void *v73;
  const __CFURL *v74;
  const void *v75;
  uint64_t v76;
  __CFArray *v77;
  void *value;
  CFArrayRef theArray;
  CFDictionaryRef theDict;
  CFURLRef anURL;

  v5 = a1;
  v6 = *(const void **)(a1 + 7896);
  SessionDataPrivateData = segPumpEnsureAndGetSessionDataPrivateData(v6);
  theArray = 0;
  theDict = 0;
  value = 0;
  anURL = 0;
  if (FigSessionDataSpecifierGetFormatType((uint64_t)v6) != 2)
  {
    if (FigSessionDataSpecifierGetFormatType((uint64_t)v6) == 1)
    {
LABEL_5:
      v10 = FigCFHTTPCreatePropertyListFromJSON((uint64_t)a2, (CFTypeRef *)&anURL);
      v9 = anURL;
      if (v10)
        goto LABEL_6;
      goto LABEL_16;
    }
    if (FigSessionDataSpecifierGetFormatType((uint64_t)v6) == 3
      || (FigSessionDataSpecifierGetIdentifier((uint64_t)v6), FigCFEqual()))
    {
      if (a2)
      {
        v9 = (const __CFURL *)CFRetain(a2);
        goto LABEL_16;
      }
    }
    else if (!FigSessionDataSpecifierGetFormatType((uint64_t)v6))
    {
      AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
      v9 = (const __CFURL *)CFPropertyListCreateWithData(AllocatorForMedia, (CFDataRef)a2, 1uLL, 0, 0);
      anURL = v9;
      if (v9)
        goto LABEL_16;
      goto LABEL_5;
    }
    v9 = 0;
    goto LABEL_16;
  }
  v8 = (const __CFAllocator *)FigGetAllocatorForMedia();
  v9 = (const __CFURL *)CFPropertyListCreateWithData(v8, (CFDataRef)a2, 1uLL, 0, 0);
  if (!v9)
  {
    v10 = -12642;
LABEL_6:
    v11 = v10;
    URL = (const __CFURL *)FigSessionDataSpecifierGetURL((uint64_t)v6);
    segPumpRTCReportingUpdateAndIssueErrorEvent(v5, v11, (uint64_t)CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Failed to parse HLS Session Data"), 4u, 3u, URL);
    v13 = (const __CFAllocator *)FigGetAllocatorForMedia();
    v14 = (const __CFURL *)FigSessionDataSpecifierGetURL((uint64_t)v6);
    Entry = FigErrorLogCreateEntry(v13, 0, v14, *(const void **)(v5 + 224), v11, CFSTR("CoreMediaErrorDomain"), CFSTR("Failed to parse HLS Session Data"), 0, 0, 0, 4, 3, a3);
    if (Entry)
    {
      v16 = Entry;
      segPumpAppendErrorLogDictionary(v5, Entry);
      CFRelease(v16);
    }
    v17 = FigSignalErrorAt();
    goto LABEL_9;
  }
LABEL_16:
  if (!*(_QWORD *)(v5 + 9608))
    *(_QWORD *)(v5 + 9608) = FigGetUpTimeNanoseconds();
  v19 = *(_QWORD *)(v5 + 384);
  v20 = *(_QWORD *)(v19 + 48);
  if (v20)
  {
    for (i = 0; ; ++i)
    {
      SessionDataSpecifiers = (const __CFArray *)FigMultivariantPlaylistGetSessionDataSpecifiers(v20);
      if (SessionDataSpecifiers)
        SessionDataSpecifiers = (const __CFArray *)CFArrayGetCount(SessionDataSpecifiers);
      if (i >= (uint64_t)SessionDataSpecifiers)
        break;
      v23 = (const __CFArray *)FigMultivariantPlaylistGetSessionDataSpecifiers(*(_QWORD *)(v19 + 48));
      ValueAtIndex = CFArrayGetValueAtIndex(v23, i);
      v25 = segPumpEnsureAndGetSessionDataPrivateData(ValueAtIndex);
      if (segPumpSessionDataIsChapterMetadata((uint64_t)ValueAtIndex) && v25[16] && *((_QWORD *)v25 + 23))
        goto LABEL_37;
      v20 = *(_QWORD *)(v19 + 48);
    }
  }
  v26 = segPumpEnsureAndGetSessionDataPrivateData(*(const void **)(v5 + 7896));
  if (!v26[4])
  {
    v27 = v26;
    v28 = (const __CFAllocator *)FigGetAllocatorForMedia();
    Mutable = CFArrayCreateMutable(v28, 0, MEMORY[0x1E0C9B378]);
    v27[4] = Mutable;
    if (!Mutable)
    {
      v17 = FigSignalErrorAt();
      if ((_DWORD)v17)
        goto LABEL_9;
    }
  }
  Identifier = (const void *)FigSessionDataSpecifierGetIdentifier((uint64_t)v6);
  v31 = *(double *)(v5 + 344);
  v32 = (const __CFURL *)FigSessionDataSpecifierGetURL(*(_QWORD *)(v5 + 7896));
  v18 = FigHLSSessionDataCopyChapterMetadataAndCopyErrorLogEntry(Identifier, v9, v32, (uint64_t)a3, &theArray, &theDict, v31);
  if (theDict)
  {
    v33 = (const __CFAllocator *)FigGetAllocatorForMedia();
    MutableCopy = CFDictionaryCreateMutableCopy(v33, 0, theDict);
    if (MutableCopy)
    {
      v35 = MutableCopy;
      v36 = FigGetAllocatorForMedia();
      FigErrorLogSetSeverity(v36, v35, 3);
      segPumpAppendErrorLogDictionary(v5, v35);
      CFRelease(v35);
    }
  }
  if (!(_DWORD)v18)
  {
    v37 = (__CFArray *)*((_QWORD *)SessionDataPrivateData + 4);
    v38 = theArray;
    if (theArray)
      v39.length = CFArrayGetCount(theArray);
    else
      v39.length = 0;
    v39.location = 0;
    CFArrayAppendArray(v37, v38, v39);
LABEL_37:
    v40 = (const __CFArray *)*((_QWORD *)SessionDataPrivateData + 4);
    if (!v40 || CFArrayGetCount(v40) < 1)
    {
      if (segPumpSessionDataIsLocalizedRenditionNameMetadata(*(_QWORD *)(v5 + 7896)))
      {
        v61 = *(const void **)(v5 + 7728);
        *(_QWORD *)(v5 + 7728) = v9;
        if (v9)
          CFRetain(v9);
        if (v61)
          CFRelease(v61);
      }
      else
      {
        v17 = segPumpEnsureMetadataArray(v5);
        if ((_DWORD)v17
          || (v62 = (void *)FigSessionDataSpecifierGetIdentifier((uint64_t)v6),
              Language = (const void *)FigSessionDataSpecifierGetLanguage(*(_QWORD *)(v5 + 7896)),
              v64 = (const __CFURL *)FigSessionDataSpecifierGetURL(*(_QWORD *)(v5 + 7896)),
              v17 = FigHLSSessionDataCopyMetadataEntry(v62, v9, Language, v64, (CFMutableDictionaryRef *)&value),
              (_DWORD)v17))
        {
LABEL_9:
          v18 = v17;
          goto LABEL_95;
        }
        CFArrayAppendValue(*(CFMutableArrayRef *)(v5 + 7696), value);
      }
      goto LABEL_86;
    }
    if (!*(_BYTE *)(v5 + 320))
      goto LABEL_113;
    v75 = SessionDataPrivateData;
    v76 = v5;
    v73 = segPumpEnsureAndGetSessionDataPrivateData(v6);
    v41 = (const __CFArray *)*((_QWORD *)v73 + 4);
    anURL = 0;
    v42 = (const __CFAllocator *)FigGetAllocatorForMedia();
    v43 = CFArrayCreateMutable(v42, 0, MEMORY[0x1E0C9B378]);
    if (v41)
    {
      v74 = v9;
      if (CFArrayGetCount(v41) < 1)
      {
LABEL_55:
        v60 = (const void *)*((_QWORD *)v73 + 4);
        *((_QWORD *)v73 + 4) = v43;
        if (v43)
          CFRetain(v43);
        if (v60)
          CFRelease(v60);
        v18 = 0;
        v55 = 0;
        v50 = 0;
        v48 = 0;
LABEL_60:
        v9 = v74;
      }
      else
      {
        v44 = 0;
        v77 = v43;
        while (1)
        {
          v45 = (const __CFDictionary *)CFArrayGetValueAtIndex(v41, v44);
          v46 = (const __CFArray *)CFDictionaryGetValue(v45, CFSTR("ChapterMetadataItems"));
          v47 = (const __CFAllocator *)FigGetAllocatorForMedia();
          v48 = CFDictionaryCreateMutableCopy(v47, 0, v45);
          if (!v48)
          {
            v18 = FigSignalErrorAt();
            v55 = 0;
            v50 = 0;
            goto LABEL_60;
          }
          CFArrayAppendValue(v43, v48);
          v49 = (const __CFAllocator *)FigGetAllocatorForMedia();
          v50 = CFArrayCreateMutable(v49, 0, MEMORY[0x1E0C9B378]);
          if (!v50)
          {
            v18 = FigSignalErrorAt();
            v55 = 0;
            goto LABEL_60;
          }
          CFDictionarySetValue(v48, CFSTR("ChapterMetadataItems"), v50);
          if (CFArrayGetCount(v46) >= 1)
            break;
LABEL_54:
          CFRelease(v50);
          CFRelease(v48);
          ++v44;
          v43 = v77;
          if (v44 >= CFArrayGetCount(v41))
            goto LABEL_55;
        }
        v51 = 0;
        while (1)
        {
          v52 = (const __CFDictionary *)CFArrayGetValueAtIndex(v46, v51);
          v53 = (const __CFString *)CFDictionaryGetValue(v52, CFSTR("URL"));
          v54 = (const __CFAllocator *)FigGetAllocatorForMedia();
          v55 = CFDictionaryCreateMutableCopy(v54, 0, v52);
          if (!v55)
            break;
          CFArrayAppendValue(v50, v55);
          if (v53)
          {
            v56 = (const __CFAllocator *)FigGetAllocatorForMedia();
            anURL = CFURLCreateWithString(v56, v53, 0);
            if (!anURL)
              break;
            v57 = (const __CFURL *)FigSessionDataSpecifierGetURL((uint64_t)v6);
            v58 = FigCFHTTPCopyURLAndInheritQueyComponentIfNotPresent(v57, &anURL);
            if ((_DWORD)v58)
              goto LABEL_70;
            v59 = CFURLGetString(anURL);
            CFDictionarySetValue(v55, CFSTR("URL"), v59);
            if (anURL)
            {
              CFRelease(anURL);
              anURL = 0;
            }
          }
          CFRelease(v55);
          if (++v51 >= CFArrayGetCount(v46))
            goto LABEL_54;
        }
        v58 = FigSignalErrorAt();
LABEL_70:
        v18 = v58;
        v9 = v74;
        v43 = v77;
      }
    }
    else
    {
      v18 = FigSignalErrorAt();
      v55 = 0;
      v50 = 0;
      v48 = 0;
    }
    if (anURL)
      CFRelease(anURL);
    if (v43)
      CFRelease(v43);
    if (v48)
      CFRelease(v48);
    if (v50)
      CFRelease(v50);
    if (v55)
      CFRelease(v55);
    SessionDataPrivateData = v75;
    v5 = v76;
    if (!(_DWORD)v18)
    {
LABEL_113:
      if (!*(_QWORD *)(v5 + 7712))
      {
        v65 = (CFTypeRef)*((_QWORD *)SessionDataPrivateData + 4);
        if (v65)
          v65 = CFRetain(v65);
        *(_QWORD *)(v5 + 7712) = v65;
      }
LABEL_86:
      if (*(uint64_t *)(v5 + 9608) >= 1)
      {
        v66 = FigGetUpTimeNanoseconds() - *(_QWORD *)(v5 + 9608);
        if (v66 >= 1)
        {
          v67 = *(_QWORD *)(v5 + 9048);
          if (v67)
          {
            v68 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
            if (v68)
              v68(v67, CFSTR("startupStats"), CFSTR("SDataParsingTime"), v66 / 0xF4240uLL, 0);
            v69 = *(_QWORD *)(v5 + 9048);
            if (v69)
            {
              v70 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                        + 32);
              if (v70)
                v70(v69, CFSTR("startupStats"), CFSTR("SDataParsingCount"), 1);
            }
          }
        }
      }
      v18 = 0;
    }
  }
LABEL_95:
  if (value)
    CFRelease(value);
  if (theArray)
    CFRelease(theArray);
  if (theDict)
    CFRelease(theDict);
  if (v9)
    CFRelease(v9);
  return v18;
}

void segPumpRTCReportingUpdateAndIssueErrorEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, const __CFURL *a7)
{
  CFTypeRef v13;
  uint64_t v14;
  void (*v15)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v16;
  void (*v17)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v18;
  void (*v19)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v20;
  void (*v21)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD);
  uint64_t v22;
  _BOOL8 v23;
  void (*v24)(uint64_t, __CFString *, __CFString *, _BOOL8, _QWORD);
  uint64_t v25;
  void (*v26)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD);
  uint64_t v27;
  void (*v28)(uint64_t, __CFString *, __CFString *, CFTypeRef, _QWORD);
  BOOL v29;

  v13 = FigCFHTTPCreateURLString(a7);
  v29 = 0;
  v14 = *(_QWORD *)(a1 + 9048);
  if (v14)
  {
    v15 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v15)
      v15(v14, CFSTR("bytePumpStats"), CFSTR("PumpErrCode"), a2, 0);
    v16 = *(_QWORD *)(a1 + 9048);
    if (v16)
    {
      v17 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                        + 48);
      if (v17)
        v17(v16, CFSTR("bytePumpStats"), CFSTR("PumpErrMsg"), a4, 0);
      v18 = *(_QWORD *)(a1 + 9048);
      if (v18)
      {
        v19 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                          + 48);
        if (v19)
          v19(v18, CFSTR("bytePumpStats"), CFSTR("PumpErrDomain"), a3, 0);
        v20 = *(_QWORD *)(a1 + 9048);
        if (v20)
        {
          v21 = *(void (**)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                           + 56);
          if (v21)
            v21(v20, CFSTR("bytePumpStats"), CFSTR("PumpConnTy"), a5, 0);
        }
      }
    }
  }
  if (!segPumpIsConnectedWithHighSpeedHighPower(a1, &v29))
  {
    v22 = *(_QWORD *)(a1 + 9048);
    if (!v22)
      goto LABEL_20;
    v23 = v29;
    v24 = *(void (**)(uint64_t, __CFString *, __CFString *, _BOOL8, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                 + 16)
                                                                                     + 56);
    if (v24)
      v24(v22, CFSTR("bytePumpStats"), CFSTR("HSHP"), v23, 0);
  }
  v25 = *(_QWORD *)(a1 + 9048);
  if (v25)
  {
    v26 = *(void (**)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                 + 16)
                                                                                     + 56);
    if (v26)
      v26(v25, CFSTR("bytePumpStats"), CFSTR("PumpErrType"), a6, 0);
  }
LABEL_20:
  if (v13)
  {
    v27 = *(_QWORD *)(a1 + 9048);
    if (v27)
    {
      v28 = *(void (**)(uint64_t, __CFString *, __CFString *, CFTypeRef, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                          + 48);
      if (v28)
        v28(v27, CFSTR("bytePumpStats"), CFSTR("AssetID"), v13, 0);
    }
    segPumpRTCReportingIssueRTCReportingEvent(a1, 202);
    CFRelease(v13);
  }
  else
  {
    segPumpRTCReportingIssueRTCReportingEvent(a1, 202);
  }
}

void segPumpAppendErrorLogDictionary(uint64_t a1, const void *a2)
{
  const __CFArray *v4;
  CFMutableArrayRef Mutable;
  const __CFAllocator *AllocatorForMedia;
  CFDictionaryRef v7;
  CFDictionaryRef v8;

  if (a2)
  {
    v4 = *(const __CFArray **)(a1 + 8672);
    if (v4
      || (v4 = CFArrayCreateMutable(*(CFAllocatorRef *)(a1 + 56), 64, MEMORY[0x1E0C9B378]),
          (*(_QWORD *)(a1 + 8672) = v4) != 0))
    {
      if (!*(_QWORD *)(a1 + 9000))
      {
        Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(a1 + 56), 0, MEMORY[0x1E0C9B378]);
        *(_QWORD *)(a1 + 9000) = Mutable;
        if (!Mutable)
          return;
        v4 = *(const __CFArray **)(a1 + 8672);
      }
      if (CFArrayGetCount(v4) >= 65)
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 8672), 0);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 8672), a2);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 9000), a2);
      AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
      v7 = CFDictionaryCreate(AllocatorForMedia, (const void **)kFigBytePumpErrorLogNotificationKey_ErrorLogs, (const void **)(a1 + 9000), 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v7)
      {
        v8 = v7;
        segPumpReadyNotification((_QWORD *)a1, CFSTR("FBP_NewErrorLogEntry"), v7);
        CFRelease(v8);
      }
    }
  }
}

uint64_t segPumpSessionDataIsLocalizedRenditionNameMetadata(uint64_t a1)
{
  uint64_t result;

  result = FigSessionDataSpecifierGetURL(a1);
  if (result)
  {
    if (FigSessionDataSpecifierGetFormatType(a1)
      && FigSessionDataSpecifierGetFormatType(a1) != 1)
    {
      return 0;
    }
    else
    {
      FigSessionDataSpecifierGetIdentifier(a1);
      return FigCFEqual() != 0;
    }
  }
  return result;
}

uint64_t segPumpIsConnectedWithHighSpeedHighPower(uint64_t a1, BOOL *a2)
{
  uint64_t v2;
  uint64_t AllocatorForMedia;
  uint64_t (*v5)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  uint64_t v6;
  CFTypeRef v7;
  CFTypeRef cf;

  v2 = *(_QWORD *)(a1 + 8472);
  if (!v2)
    return 4294954513;
  cf = 0;
  AllocatorForMedia = FigGetAllocatorForMedia();
  v5 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                             + 48);
  if (!v5)
    return 4294954514;
  v6 = v5(v2, CFSTR("FNCM_HighSpeedHighPower"), AllocatorForMedia, &cf);
  v7 = cf;
  if (!(_DWORD)v6)
    *a2 = cf == (CFTypeRef)*MEMORY[0x1E0C9AE50];
  if (v7)
    CFRelease(v7);
  return v6;
}

uint64_t segPumpRTCReportingIssueRTCReportingEvent(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t (*v4)(uint64_t, __CFString *, uint64_t, uint64_t, _QWORD);
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (result)
  {
    v2 = *(_QWORD *)(result + 9048);
    if (v2)
    {
      result = CMBaseObjectGetVTable();
      v4 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(result + 16) + 8);
      if ((_DWORD)a2 == 202)
      {
        if (!v4)
          return result;
        v5 = v2;
        v6 = 202;
        v7 = 1;
      }
      else
      {
        if (!v4)
          return result;
        v5 = v2;
        v6 = a2;
        v7 = 0;
      }
      return v4(v5, CFSTR("bytePumpStats"), v6, v7, 0);
    }
  }
  return result;
}

uint64_t segPumpSessionDataIsChapterMetadata(uint64_t a1)
{
  uint64_t result;

  result = FigSessionDataSpecifierGetURL(a1);
  if (result)
  {
    FigSessionDataSpecifierGetIdentifier(a1);
    return FigCFEqual() != 0;
  }
  return result;
}

uint64_t segPumpCreateURLWithQueryParams(uint64_t a1, CFTypeRef cf, const __CFArray *a3, const __CFURL **a4)
{
  const __CFArray *v5;
  const __CFURL *v8;
  const __CFAllocator *AllocatorForMedia;
  CFMutableArrayRef MutableCopy;
  __CFArray *v11;
  const __CFAllocator *v12;
  CFMutableArrayRef Mutable;
  const __CFArray *v14;
  CFIndex v15;
  CFIndex v16;
  const CFArrayCallBacks *v17;
  const __CFAllocator *v18;
  CFMutableArrayRef v19;
  __CFArray *v20;
  const void *v21;
  const void *v22;
  CFIndex Count;
  uint64_t v24;
  CFIndex v25;
  const __CFArray *ValueAtIndex;
  const void *v27;
  const __CFArray *v28;
  const void *v29;
  uint64_t v30;
  __CFArray *Params;
  uint64_t v32;
  CFIndex v33;
  const __CFString *v34;
  const void *v35;
  CFIndex v36;
  uint64_t v37;
  CFIndex v38;
  CFIndex v39;
  CFIndex v40;
  const __CFString *v41;
  CFIndex v42;
  const void *v43;
  uint64_t v44;
  const __CFURL *v45;
  CFTypeRef cfa;
  CFRange v48;

  v5 = a3;
  if (cf)
  {
    v8 = (const __CFURL *)CFRetain(cf);
    if (v5)
      goto LABEL_3;
LABEL_31:
    v30 = 0;
LABEL_49:
    *a4 = v8;
    return v30;
  }
  v8 = 0;
  if (!a3)
    goto LABEL_31;
LABEL_3:
  if (!*(_BYTE *)(a1 + 328))
  {
    v11 = 0;
    goto LABEL_33;
  }
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  MutableCopy = CFArrayCreateMutableCopy(AllocatorForMedia, 0, v5);
  if (!MutableCopy)
  {
    v30 = FigSignalErrorAt();
    goto LABEL_49;
  }
  v11 = MutableCopy;
  v12 = (const __CFAllocator *)FigGetAllocatorForMedia();
  Mutable = CFArrayCreateMutable(v12, 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v14 = Mutable;
    if (CFArrayGetCount(v11) <= 1)
    {
LABEL_13:
      v48.length = CFArrayGetCount(v14);
      v48.location = 0;
      CFArraySortValues(v14, v48, (CFComparatorFunction)segPumpQueryParamsCFComparator, 0);
      CFArrayRemoveAllValues(v11);
      if (CFArrayGetCount(v14) >= 1)
      {
        v25 = 0;
        do
        {
          ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(v14, v25);
          v27 = CFArrayGetValueAtIndex(ValueAtIndex, 0);
          CFArrayAppendValue(v11, v27);
          v28 = (const __CFArray *)CFArrayGetValueAtIndex(v14, v25);
          v29 = CFArrayGetValueAtIndex(v28, 1);
          CFArrayAppendValue(v11, v29);
          ++v25;
        }
        while (v25 < CFArrayGetCount(v14));
      }
      v30 = 0;
    }
    else
    {
      v15 = 0;
      v16 = 1;
      v17 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
      while (1)
      {
        v18 = (const __CFAllocator *)FigGetAllocatorForMedia();
        v19 = CFArrayCreateMutable(v18, 0, v17);
        if (!v19)
          break;
        v20 = v19;
        v21 = CFArrayGetValueAtIndex(v11, v16 - 1);
        CFArraySetValueAtIndex(v20, 0, v21);
        v22 = CFArrayGetValueAtIndex(v11, v16);
        CFArraySetValueAtIndex(v20, 1, v22);
        CFArraySetValueAtIndex(v14, v15, v20);
        CFRelease(v20);
        ++v15;
        Count = CFArrayGetCount(v11);
        if (Count >= 0)
          v24 = Count;
        else
          v24 = Count + 1;
        v16 += 2;
        if (v15 >= v24 >> 1)
          goto LABEL_13;
      }
      v30 = FigSignalErrorAt();
    }
    CFRelease(v14);
    if ((_DWORD)v30)
      goto LABEL_44;
    goto LABEL_18;
  }
  v30 = FigSignalErrorAt();
  if (!(_DWORD)v30)
  {
LABEL_18:
    Params = FigCFHTTPCopyQueryParams((uint64_t)cf);
    if (CFArrayGetCount(Params) >= 1 && CFArrayGetCount(Params) >= 2)
    {
      v32 = 0;
      v33 = 1;
      do
      {
        v34 = (const __CFString *)CFArrayGetValueAtIndex(Params, v33 - 1);
        if (!CFStringHasPrefix(v34, CFSTR("_HLS")))
        {
          CFArrayAppendValue(v11, v34);
          v35 = CFArrayGetValueAtIndex(Params, v33);
          CFArrayAppendValue(v11, v35);
        }
        ++v32;
        v36 = CFArrayGetCount(Params);
        if (v36 >= 0)
          v37 = v36;
        else
          v37 = v36 + 1;
        v33 += 2;
      }
      while (v32 < v37 >> 1);
    }
    if (Params)
      CFRelease(Params);
    v5 = v11;
LABEL_33:
    v38 = CFArrayGetCount(v5);
    if (v38 < 1)
    {
      v30 = 0;
    }
    else
    {
      v39 = v38;
      v40 = 0;
      while (1)
      {
        cfa = 0;
        v41 = (const __CFString *)CFArrayGetValueAtIndex(v5, v40);
        v42 = v40 + 1;
        v43 = CFArrayGetValueAtIndex(v5, v40 + 1);
        v44 = FigCFHTTPCreateURLWithQueryParam(v8, v41, (uint64_t)v43, &cfa);
        if ((_DWORD)v44)
          break;
        v45 = (const __CFURL *)cfa;
        if (cfa)
          CFRetain(cfa);
        if (v8)
          CFRelease(v8);
        CFRelease(cfa);
        v40 += 2;
        v8 = v45;
        if (v42 + 1 >= v39)
        {
          v30 = 0;
          v8 = v45;
          goto LABEL_44;
        }
      }
      v30 = v44;
    }
  }
LABEL_44:
  *a4 = v8;
  if (v11)
    CFRelease(v11);
  return v30;
}

uint64_t segPumpAmendHTTPRequestFlags(_BYTE *a1, _DWORD *a2)
{
  if (!a2)
    return FigSignalErrorAt();
  if (a1[324])
    *a2 |= 0x80u;
  if (a1[325])
    *a2 |= 0x800u;
  if (a1[326])
    *a2 |= 0x1000u;
  if (a1[328])
    *a2 |= 0x4000u;
  if (a1[9584])
    *a2 |= 0x8000u;
  return 0;
}

__CFDictionary *segPumpCopyHTTPRequestCreationsOptionsAndSetNWActivityAndStuff(float a1, uint64_t a2, uint64_t a3, _QWORD *a4, int a5, const void *a6)
{
  __CFDictionary *MutableCopy;
  int v12;
  const void *v13;
  int v14;
  const void *v15;
  CFTypeRef cf;

  FigGetAllocatorForMedia();
  MutableCopy = (__CFDictionary *)FigCFDictionaryCreateMutableCopy();
  if (!a3)
  {
    FigSignalErrorAt();
    return MutableCopy;
  }
  if (!a5)
  {
    v13 = 0;
    if (!a6)
      goto LABEL_13;
    goto LABEL_12;
  }
  cf = 0;
  v12 = segPumpCopyParentNWActivity(a3, a4, &cf);
  if (v12)
  {
    v14 = v12;
    v13 = 0;
  }
  else
  {
    v13 = (const void *)nw_activity_create();
    if (v13)
    {
      if (!cf)
      {
LABEL_10:
        FigCFDictionarySetValue();
        goto LABEL_11;
      }
      nw_activity_set_parent_activity();
      v14 = 0;
    }
    else
    {
      v14 = FigSignalErrorAt();
    }
  }
  if (cf)
    CFRelease(cf);
  if (!v14)
    goto LABEL_10;
LABEL_11:
  if (a6)
LABEL_12:
    CFDictionarySetValue(MutableCopy, CFSTR("FHRP_DependentPipelinePrecursor"), a6);
LABEL_13:
  if (a1 != 0.5)
    FigCFDictionarySetDouble();
  if (*(_BYTE *)(a3 + 328))
  {
    v15 = 0;
  }
  else
  {
    v15 = (const void *)FigNetworkUrgencyMonitorCopyExpectedProgressTarget(*(_QWORD *)(a3 + 9512));
    if (v15)
      CFDictionarySetValue(MutableCopy, CFSTR("FHRP_CreateExpectedProgressTarget"), v15);
  }
  if (v13)
    CFRelease(v13);
  if (v15)
    CFRelease(v15);
  return MutableCopy;
}

uint64_t segPumpGetCurrentRTT(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;

  v1 = (a1[1073] + 2 * a1[1074]) / 3;
  if (a1[1075] <= a1[1076])
    v2 = 0;
  else
    v2 = FigGetUpTimeNanoseconds() - a1[1075];
  if (v2 > v1)
  {
    v3 = (unsigned __int128)((v2 + 2 * v1) * (__int128)0x5555555555555556) >> 64;
    v1 = v3 + (v3 >> 63);
  }
  if (v1 <= 0)
    return 100000;
  else
    return v1;
}

CFComparisonResult segPumpQueryParamsCFComparator(const __CFArray *a1, const __CFArray *a2)
{
  const __CFString *ValueAtIndex;
  const __CFString *v5;
  CFComparisonResult result;
  const __CFString *v7;
  const __CFString *v8;

  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1, 0);
  v5 = (const __CFString *)CFArrayGetValueAtIndex(a2, 0);
  result = CFStringCompare(ValueAtIndex, v5, 0);
  if (result == kCFCompareEqualTo)
  {
    v7 = (const __CFString *)CFArrayGetValueAtIndex(a1, 1);
    v8 = (const __CFString *)CFArrayGetValueAtIndex(a2, 1);
    return CFStringCompare(v7, v8, 0);
  }
  return result;
}

uint64_t segPumpCopyParentNWActivity(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  const void *v5;
  CFTypeRef v6;
  const void *v7;
  uint64_t v8;
  const void *v9;
  uint64_t v11;

  if (!a1 || !a3)
    return FigSignalErrorAt();
  if (!a2
    || (v5 = (const void *)a2[148]) == 0
    && (v5 = *(const void **)(*(_QWORD *)(a1 + 16 * *a2 + 384) + 1176)) == 0
    || (v6 = CFRetain(v5)) == 0)
  {
    v7 = *(const void **)(a1 + 9496);
    if (!v7)
      return FigSignalErrorAt();
    v6 = CFRetain(v7);
    if (!v6)
      return FigSignalErrorAt();
  }
  if (!FigCFEqual())
  {
LABEL_12:
    *a3 = v6;
    return 0;
  }
  v8 = nw_activity_create();
  if (v8)
  {
    v9 = (const void *)v8;
    nw_activity_set_parent_activity();
    CFRelease(v6);
    v6 = v9;
    goto LABEL_12;
  }
  v11 = FigSignalErrorAt();
  CFRelease(v6);
  return v11;
}

uint64_t segPumpHandleSessionDataNetworkError(uint64_t a1, uint64_t a2, int a3, const __CFString *a4, const void *a5, BOOL *a6)
{
  uint64_t DerivedStorage;
  uint64_t v13;
  _BYTE *SessionDataPrivateData;
  uint64_t ErrorFromHTTPRequestIfAvailable;
  void *v16;
  const void *v17;
  CFTypeRef v18;
  CFTypeRef v19;
  CFTypeRef v20;
  uint64_t v21;
  CFDictionaryRef v22;
  uint64_t CommonActionForNetworkError;
  uint64_t v24;
  uint64_t v25;
  const void *v26;
  uint64_t URL;
  BOOL v28;
  uint64_t v29;
  CFTypeRef cf;
  uint64_t v32;
  CFTypeRef v33;
  uint64_t v34;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v13 = *(_QWORD *)(DerivedStorage + 7776);
  v32 = 0;
  SessionDataPrivateData = segPumpEnsureAndGetSessionDataPrivateData(*(const void **)(DerivedStorage + 7896));
  cf = 0;
  if (a6)
    *a6 = 0;
  ++*(_DWORD *)(DerivedStorage + 7824);
  ErrorFromHTTPRequestIfAvailable = segPumpCreateErrorFromHTTPRequestIfAvailable(v13, a3, a4, a5, (uint64_t *)&cf);
  v16 = (void *)cf;
  if ((_DWORD)ErrorFromHTTPRequestIfAvailable)
    goto LABEL_54;
  v17 = *(const void **)(DerivedStorage + 7832);
  *(_QWORD *)(DerivedStorage + 7832) = cf;
  if (v16)
    CFRetain(v16);
  if (v17)
    CFRelease(v17);
  if (segPumpSessionDataIsChapterMetadata(*(_QWORD *)(DerivedStorage + 7896)))
  {
    if (!*(_QWORD *)(DerivedStorage + 7720))
    {
      v18 = *(CFTypeRef *)(DerivedStorage + 7832);
      if (v18)
        v18 = CFRetain(v18);
      *(_QWORD *)(DerivedStorage + 7720) = v18;
    }
  }
  else if (segPumpSessionDataIsLocalizedRenditionNameMetadata(*(_QWORD *)(DerivedStorage + 7896)))
  {
    if (!*(_QWORD *)(DerivedStorage + 7736))
    {
      v19 = *(CFTypeRef *)(DerivedStorage + 7832);
      if (v19)
        v19 = CFRetain(v19);
      *(_QWORD *)(DerivedStorage + 7736) = v19;
    }
  }
  else if (!*(_QWORD *)(DerivedStorage + 7704))
  {
    v20 = *(CFTypeRef *)(DerivedStorage + 7832);
    if (v20)
      v20 = CFRetain(v20);
    *(_QWORD *)(DerivedStorage + 7704) = v20;
  }
  v21 = *(_QWORD *)(DerivedStorage + 7776);
  v34 = 0;
  CFErrorGetCode((CFErrorRef)v16);
  CFErrorGetDomain((CFErrorRef)v16);
  v22 = CFErrorCopyUserInfo((CFErrorRef)v16);
  v33 = 0;
  CommonActionForNetworkError = segPumpGetCommonActionForNetworkError((__CFError *)v16, &v34, &v32);
  if ((_DWORD)CommonActionForNetworkError)
    goto LABEL_53;
  v24 = v34;
  if (v21 || v34 != 1)
    goto LABEL_28;
  CommonActionForNetworkError = FigCFHTTPCreateCFErrorFromHTTPStatusCode(-12938, (CFErrorRef *)&v33);
  if ((_DWORD)CommonActionForNetworkError
    || (CommonActionForNetworkError = segPumpGetCommonActionForNetworkError((__CFError *)v33, &v34, &v32),
        (_DWORD)CommonActionForNetworkError))
  {
LABEL_53:
    v25 = CommonActionForNetworkError;
    v24 = 0;
    goto LABEL_35;
  }
  v24 = v34;
LABEL_28:
  if ((v24 & 0xFFFFFFFFFFFFFFFDLL) == 1)
  {
    if (v24 == 3)
    {
      v25 = 0;
      if (*(_BYTE *)(DerivedStorage + 8177))
      {
        v24 = 3;
      }
      else
      {
        v24 = 6;
        v34 = 6;
      }
    }
    else
    {
      v25 = 0;
    }
  }
  else
  {
    v24 = 0;
    v25 = 0;
    v34 = 0;
  }
LABEL_35:
  if (v33)
    CFRelease(v33);
  if (v22)
    CFRelease(v22);
  if ((_DWORD)v25)
    goto LABEL_50;
  if (v24 == 1)
  {
    segPumpResetConnectionByPreservingConnectionStats(DerivedStorage, DerivedStorage + 7760);
    v26 = segPumpEnsureAndGetSessionDataPrivateData(*(const void **)(DerivedStorage + 7896));
    URL = FigSessionDataSpecifierGetURL(*(_QWORD *)(DerivedStorage + 7896));
    ErrorFromHTTPRequestIfAvailable = segPumpCustomURLLoaderGetURLGuts((uint64_t *)DerivedStorage, URL, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint64_t)v26 + 24);
    if (!(_DWORD)ErrorFromHTTPRequestIfAvailable)
    {
      segPumpAppendErrorLogEntryWithCFError(a1, DerivedStorage, a2, (const __CFURL **)(DerivedStorage + 7760), (CFErrorRef)v16, 4u, 3u);
      if (a6)
      {
        v28 = 1;
        goto LABEL_47;
      }
      v25 = 0;
      goto LABEL_50;
    }
LABEL_54:
    v25 = ErrorFromHTTPRequestIfAvailable;
    if (!v16)
      return v25;
    goto LABEL_51;
  }
  SessionDataPrivateData[16] = 0;
  v29 = segPumpHandleCommonNetworkError(a1, a2, v24, v32, (const __CFURL **)(DerivedStorage + 7760), 3u, v16);
  v25 = v29;
  if (a6 && !(_DWORD)v29)
  {
    v28 = v24 == 3;
LABEL_47:
    v25 = 0;
    *a6 = v28;
    if (!v16)
      return v25;
    goto LABEL_51;
  }
LABEL_50:
  if (v16)
LABEL_51:
    CFRelease(v16);
  return v25;
}

uint64_t segPumpSetWiFiStatsOnNetworkPredictor(uint64_t a1, uint64_t a2)
{
  CFNumberRef v3;
  CFNumberRef v4;
  uint64_t v5;
  void (*v6)(uint64_t, __CFString *, CFNumberRef);
  uint64_t v7;
  const void *StringValue;
  CFTypeRef v9;
  uint64_t NumberValue;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(uint64_t, __CFString *, uint64_t);
  uint64_t v14;
  void (*v15)(uint64_t, __CFString *, CFTypeRef);
  int valuePtr;
  CFTypeRef cf;

  valuePtr = segPumpGetInterfaceTypeEnum(a1, a2);
  v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
  if (!v3)
    return FigSignalErrorAt();
  v4 = v3;
  v5 = *(_QWORD *)(a1 + 96);
  v6 = *(void (**)(uint64_t, __CFString *, CFNumberRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
  if (v6)
    v6(v5, CFSTR("NetworkPredictorProperty_InterfaceType"), v4);
  if (FigRCLGetNumberWithDefault(*(const __CFDictionary **)(a1 + 9128), CFSTR("useAdaptiveBayesianNetworkPrediction")))
  {
    cf = 0;
    v7 = FigNetworkWirelessReportingInterfaceCopyWifiStats(&cf);
    if (!(_DWORD)v7)
    {
      StringValue = (const void *)FigCFDictionaryGetStringValue();
      if (StringValue)
        v9 = CFRetain(StringValue);
      else
        v9 = 0;
      NumberValue = FigCFDictionaryGetNumberValue();
      if (NumberValue)
      {
        v11 = NumberValue;
        v12 = *(_QWORD *)(a1 + 96);
        v13 = *(void (**)(uint64_t, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
        if (v13)
          v13(v12, CFSTR("NetworkPredictorProperty_RSSI"), v11);
      }
      if (v9)
      {
        v14 = *(_QWORD *)(a1 + 96);
        v15 = *(void (**)(uint64_t, __CFString *, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
        if (v15)
          v15(v14, CFSTR("NetworkPredictorProperty_SSID"), v9);
        CFRelease(v9);
      }
    }
    if (cf)
      CFRelease(cf);
  }
  else
  {
    v7 = 0;
  }
  CFRelease(v4);
  return v7;
}

void segPumpParseSessionDataFromConnection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  const __CFAllocator *AllocatorForMedia;
  OpaqueCMBlockBuffer *v8;
  const __CFAllocator *v9;
  const void *URL;
  CMBlockBufferRef v11;
  __int16 URLAndString;
  CFTypeRef v13;
  __int16 v14;
  CFHTTPMessageRef message;
  CFTypeRef v16;
  CMBlockBufferRef blockBufferOut;
  CFTypeRef cf[17];

  cf[16] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  v16 = 0;
  blockBufferOut = 0;
  message = 0;
  if (CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(a2 + 7872)) <= 1)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    segPumpAppendErrorLogEntry(a1, a2, a3, (const __CFURL **)(a2 + 7760), -12886, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("0 length session data file"), 0, 0, 4u, 1u);
    segPumpResetConnection(a2, a2 + 7760);
    goto LABEL_12;
  }
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  v8 = *(OpaqueCMBlockBuffer **)(a2 + 7872);
  v9 = (const __CFAllocator *)FigGetAllocatorForMedia();
  if (!CMBlockBufferCreateContiguous(AllocatorForMedia, v8, v9, 0, 0, 0, 0, &blockBufferOut))
  {
    if (!*(_QWORD *)(a2 + 296))
    {
LABEL_10:
      FigGetAllocatorForMedia();
      if (!FigCreateCFDataWithBlockBufferNoCopy())
        FigSignalErrorAt();
      goto LABEL_12;
    }
    URL = (const void *)FigSessionDataSpecifierGetURL(*(_QWORD *)(a2 + 7896));
    v11 = blockBufferOut;
    cf[0] = 0;
    if (*(_QWORD *)(a2 + 296))
    {
      URLAndString = segPumpCreateURLAndString(URL, 0, cf);
      v13 = cf[0];
      if (!URLAndString)
      {
        v14 = FigStreamingCacheSetSessionData(*(_QWORD *)(a2 + 296), cf[0], v11);
        v13 = cf[0];
        if (!cf[0])
          goto LABEL_9;
        goto LABEL_8;
      }
      v14 = URLAndString;
      if (cf[0])
LABEL_8:
        CFRelease(v13);
    }
    else
    {
      v14 = FigSignalErrorAt();
    }
LABEL_9:
    if (v14)
      goto LABEL_12;
    goto LABEL_10;
  }
LABEL_12:
  if (blockBufferOut)
    CFRelease(blockBufferOut);
}

uint64_t segPumpCreateErrorFromHTTPRequestIfAvailable(uint64_t a1, int a2, const __CFString *a3, CFTypeRef cf, uint64_t *a5)
{
  uint64_t AllocatorForMedia;
  void (*v11)(uint64_t, __CFString *, uint64_t, uint64_t *);
  uint64_t CFError;
  uint64_t v13;
  uint64_t (*v14)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  uint64_t v15;
  BOOL v16;
  CFTypeRef v17;
  uint64_t v18;
  CFTypeRef cfa;
  uint64_t v21;

  cfa = 0;
  v21 = 0;
  if (!a1)
    goto LABEL_12;
  AllocatorForMedia = FigGetAllocatorForMedia();
  v11 = *(void (**)(uint64_t, __CFString *, uint64_t, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                         + 48);
  if (v11)
  {
    v11(a1, CFSTR("FHRP_ErrorReturned"), AllocatorForMedia, &v21);
    CFError = v21;
    if (v21)
      goto LABEL_17;
  }
  v13 = FigGetAllocatorForMedia();
  v14 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                              + 48);
  if (!v14)
  {
    v18 = 4294954514;
    goto LABEL_18;
  }
  v15 = v14(a1, CFSTR("FHRP_ErrorComment"), v13, &cfa);
  if ((_DWORD)v15)
    v16 = (_DWORD)v15 == -12783;
  else
    v16 = 1;
  if (v16)
  {
    CFError = v21;
    if (v21)
      goto LABEL_17;
    a3 = CFSTR("CoreMediaErrorDomain");
    v17 = cfa;
    if (cfa)
    {
LABEL_16:
      CFError = FigCreateCFError(a3, a2, v17, 0, 0, 0, 0);
      v21 = CFError;
      if (!CFError)
      {
        v15 = FigSignalErrorAt();
        goto LABEL_23;
      }
LABEL_17:
      v18 = 0;
      *a5 = CFError;
      goto LABEL_18;
    }
LABEL_12:
    if (cf)
      v17 = CFRetain(cf);
    else
      v17 = 0;
    cfa = v17;
    goto LABEL_16;
  }
LABEL_23:
  v18 = v15;
LABEL_18:
  if (cfa)
    CFRelease(cfa);
  return v18;
}

void segPumpResetConnectionByPreservingConnectionStats(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  const void *v6;
  CFTypeRef v7;

  if (a2)
  {
    v4 = *(_QWORD *)(a2 + 24);
    v5 = *(_DWORD *)(a2 + 64);
    v6 = *(const void **)(a2 + 72);
    if (v6)
      v7 = CFRetain(v6);
    else
      v7 = 0;
    segPumpResetConnection(a1, a2);
    *(_QWORD *)(a2 + 24) = v4;
    *(_DWORD *)(a2 + 64) = v5;
    if (v7)
    {
      *(_QWORD *)(a2 + 72) = CFRetain(v7);
      CFRelease(v7);
    }
    else
    {
      *(_QWORD *)(a2 + 72) = 0;
    }
  }
}

void segPumpAppendErrorLogEntryWithCFError(uint64_t a1, uint64_t a2, uint64_t a3, const __CFURL **a4, CFErrorRef err, unsigned int a6, unsigned int a7)
{
  int Code;
  CFErrorDomain Domain;
  CFStringRef v16;
  CFDictionaryRef v17;

  Code = CFErrorGetCode(err);
  Domain = CFErrorGetDomain(err);
  v16 = CFErrorCopyDescription(err);
  v17 = CFErrorCopyUserInfo(err);
  segPumpAppendErrorLogEntry(a1, a2, a3, a4, Code, Domain, (uint64_t)v16, v17, 1, a6, a7);
  if (v16)
    CFRelease(v16);
  if (v17)
    CFRelease(v17);
}

uint64_t segPumpHandleCommonNetworkError(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, const __CFURL **a5, unsigned int a6, void *a7)
{
  uint64_t DerivedStorage;
  uint64_t v14;
  int v15;
  int v16;
  void *v17;
  unsigned int v18;
  uint64_t result;
  const void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  int v24;
  unsigned int v25;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  void *v27;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a7)
    return FigSignalErrorAt();
  v14 = DerivedStorage;
  v15 = 1;
  v16 = 3;
  v17 = a7;
  v18 = 1;
  switch(a3)
  {
    case 0:
      break;
    case 1:
    case 5:
      return FigSignalErrorAt();
    case 3:
      v20 = *(const void **)(a2 + 1152);
      *(_QWORD *)(a2 + 1152) = a7;
      CFRetain(a7);
      if (v20)
        CFRelease(v20);
      if (*(_BYTE *)(v14 + 8176))
        v21 = 7;
      else
        v21 = 6;
      result = segPumpAttemptToRetryRequest(a1, a2, (uint64_t)a5, v21, a4);
      if ((_DWORD)result)
        return result;
      goto LABEL_19;
    case 6:
      goto LABEL_21;
    case 7:
      if ((a4 & 4) != 0)
      {
        result = segPumpMoveAlternatesMatchingHostAndPathwayToPenaltyBox(a1, *(const __CFURL **)(a2 + 16), *(_QWORD *)(a2 + 40), a4 & 1);
        if ((_DWORD)result)
          return result;
      }
      v22 = a1;
      v23 = (uint64_t *)a2;
      v24 = 0;
LABEL_15:
      result = segPumpMoveStreamAlternateToPenaltyBox(v22, v23, v24, a4 & 1);
      if ((_DWORD)result)
        return result;
      v16 = 2;
      break;
    case 8:
      v22 = a1;
      v23 = (uint64_t *)a2;
      v24 = 1;
      goto LABEL_15;
    case 9:
      result = FigSignalErrorAt();
      if (!(_DWORD)result)
        goto LABEL_18;
      return result;
    default:
LABEL_18:
      result = FigSignalErrorAt();
      if ((_DWORD)result)
        return result;
LABEL_19:
      v16 = 3;
      break;
  }
  v15 = 0;
  v17 = 0;
  v18 = v16;
LABEL_21:
  v27 = v17;
  if (a6 < 4)
    v25 = a6 + 1;
  else
    v25 = 0;
  segPumpAppendErrorLogEntryWithCFError(a1, v14, a2, a5, (CFErrorRef)a7, v25, v18);
  if (dword_1EE2A31E8)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (v15)
    segPumpSendEndCallbackForAllActiveStreams(*(_QWORD *)v14, v27);
  return 0;
}

uint64_t segPumpGetCommonActionForNetworkError(__CFError *a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v7 = 0;
  v8 = 0;
  result = FigStreamingNetworkErrorGetRecommendedAction(a1, &v8, &v7);
  if (!(_DWORD)result)
  {
    if (a2)
    {
      v6 = v8;
      if (v8 == 2)
        v6 = 7;
      *a2 = v6;
    }
    if (a3)
      *a3 = v7;
  }
  return result;
}

void segPumpAppendErrorLogEntry(uint64_t a1, uint64_t a2, uint64_t a3, const __CFURL **a4, uint64_t a5, const void *a6, uint64_t a7, const void *a8, char a9, unsigned int a10, unsigned int a11)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int InterfaceTypeEnum;
  __CFString *value;
  __CFDictionary *theDict;
  const void *v19;
  CFDictionaryRef v20;
  uint64_t AllocatorForMedia;
  void (*v22)(CFDictionaryRef, __CFString *, uint64_t, CFHTTPMessageRef *);
  uint64_t v23;
  __CFDictionary *Entry;
  const void *CFError;
  const __CFAllocator *v26;
  const __CFURL *v30;
  CFTypeRef cf;
  CFHTTPMessageRef message;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (a4)
    v30 = *a4;
  else
    v30 = 0;
  cf = 0;
  message = 0;
  if (dword_1EE2A31E8)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (a9)
  {
    InterfaceTypeEnum = segPumpGetInterfaceTypeEnum(a2, (uint64_t)a4);
    value = (__CFString *)FigErrorLogGetStringFromInterfaceType(InterfaceTypeEnum);
  }
  else
  {
    value = 0;
  }
  theDict = FigNetworkInterfaceReporterCopyPhysicalStatistics(*(_QWORD *)(a2 + 9120));
  v19 = (const void *)a7;
  segPumpRTCReportingUpdateAndIssueErrorEvent(a2, a5, (uint64_t)a6, a7, a10, a11, v30);
  if (a4)
  {
    v20 = a4[2];
    if (v20)
    {
      AllocatorForMedia = FigGetAllocatorForMedia();
      v22 = *(void (**)(CFDictionaryRef, __CFString *, uint64_t, CFHTTPMessageRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                              + 48);
      if (v22 && (v22(v20, CFSTR("FHRP_HTTPResponseHeaders"), AllocatorForMedia, &message), message))
        v20 = CFHTTPMessageCopyAllHeaderFields(message);
      else
        v20 = 0;
      v19 = (const void *)a7;
    }
    v23 = (uint64_t)a4[2];
  }
  else
  {
    v20 = 0;
    v23 = 0;
  }
  Entry = FigErrorLogCreateEntry(*(const __CFAllocator **)(a2 + 56), v23, v30, *(const void **)(a2 + 224), a5, a6, v19, a8, value, theDict, a10, a11, v20);
  if (theDict)
    CFRelease(theDict);
  segPumpAppendErrorLogDictionary(a2, Entry);
  CFError = (const void *)FigCreateCFError(a6, a5, v19, 0, 0, v30, 0);
  v26 = (const __CFAllocator *)FigGetAllocatorForMedia();
  v33 = *MEMORY[0x1E0CA2E18];
  v34 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  FigMetricErrorEventCreate(v26, &v33, 0, 0, 1, CFError, &cf);
  segPumpPublishMetricEvent(a1, a2, (void *)cf);
  if (v20)
    CFRelease(v20);
  if (message)
    CFRelease(message);
  if (Entry)
    CFRelease(Entry);
  if (cf)
    CFRelease(cf);
  if (CFError)
    CFRelease(CFError);
}

uint64_t segPumpPublishMetricEvent(uint64_t a1, uint64_t a2, void *value)
{
  uint64_t v5;
  uint64_t (*v7)(uint64_t, uint64_t, void *);
  __CFArray *Mutable;
  const __CFAllocator *AllocatorForMedia;

  if (!value)
    return 4294954656;
  v5 = *(_QWORD *)(a2 + 9016);
  if (!v5)
  {
    if (*(_BYTE *)(a2 + 9032))
    {
      Mutable = *(__CFArray **)(a2 + 9024);
      if (!Mutable)
      {
        AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
        Mutable = CFArrayCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B378]);
        *(_QWORD *)(a2 + 9024) = Mutable;
        if (!Mutable)
          return 4294954510;
      }
      CFArrayAppendValue(Mutable, value);
    }
    return 0;
  }
  v7 = *(uint64_t (**)(uint64_t, uint64_t, void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 40);
  if (v7)
    return v7(v5, a1, value);
  else
    return 4294954514;
}

uint64_t segPumpGetInterfaceTypeEnum(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t AllocatorForMedia;
  uint64_t (*v6)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  int v7;
  CFTypeRef v8;
  uint64_t InterfaceTypeFromCFNStats;
  CFTypeRef cf;

  if (!a1)
    return 0;
  if (a2 && (v3 = *(_QWORD *)(a2 + 16)) != 0
    || (v4 = *(_QWORD *)(a1 + 16 * *(_QWORD *)(a1 + 8416) + 384), (v3 = *(_QWORD *)(*(_QWORD *)(v4 + 696) + 32)) != 0)
    || (v3 = *(_QWORD *)(v4 + 424)) != 0)
  {
    cf = 0;
    AllocatorForMedia = FigGetAllocatorForMedia();
    v6 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                               + 48);
    if (v6)
    {
      v7 = v6(v3, CFSTR("FHRP_CFNetworkTimingData"), AllocatorForMedia, &cf);
      v8 = cf;
      if (v7)
      {
        InterfaceTypeFromCFNStats = 0;
        if (!cf)
          goto LABEL_10;
      }
      else
      {
        InterfaceTypeFromCFNStats = FigNetworkInterfaceGetInterfaceTypeFromCFNStats((uint64_t)cf);
        v8 = cf;
        if (!cf)
        {
LABEL_10:
          if ((_DWORD)InterfaceTypeFromCFNStats)
            return InterfaceTypeFromCFNStats;
          goto LABEL_11;
        }
      }
      CFRelease(v8);
      goto LABEL_10;
    }
  }
LABEL_11:
  InterfaceTypeFromCFNStats = (uint64_t)FigNetworkInterfaceReporterGetInterfaceType(*(_BYTE **)(a1 + 9120));
  if (!(_DWORD)InterfaceTypeFromCFNStats)
  {
    if (*(_QWORD *)(a1 + 8448))
      return FigNetworkPathInformationGetInterfaceType();
    return 0;
  }
  return InterfaceTypeFromCFNStats;
}

uint64_t segPumpMoveAlternatesMatchingHostAndPathwayToPenaltyBox(uint64_t a1, const __CFURL *a2, uint64_t a3, char a4)
{
  _QWORD *DerivedStorage;
  CFStringRef v9;
  const __CFString *v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;
  const __CFURL *PlaylistAlternateURL;
  const __CFString *v15;
  const __CFString *v16;
  int v17;
  uint64_t valid;
  uint64_t updated;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    if (a3)
    {
      v9 = CFURLCopyHostName(a2);
      if (v9)
      {
        v10 = v9;
        v11 = (uint64_t *)DerivedStorage[1012];
        while (v11)
        {
          v12 = v11;
          v11 = (uint64_t *)*v11;
          v13 = v12[1];
          if (v13)
          {
            PlaylistAlternateURL = (const __CFURL *)FigAlternateGetPlaylistAlternateURL(v12[1]);
            if (PlaylistAlternateURL)
            {
              v15 = CFURLCopyHostName(PlaylistAlternateURL);
              if (v15)
              {
                v16 = v15;
                if (CFStringCompare(v15, v10, 1uLL))
                {
                  CFRelease(v16);
                }
                else
                {
                  FigAlternateGetPathwayID(v13);
                  v17 = FigCFEqual();
                  CFRelease(v16);
                  if (v17)
                  {
                    valid = MoveAlternateFromValidList(a1, v12, 0, a4);
                    if ((_DWORD)valid)
                    {
                      updated = valid;
                      goto LABEL_15;
                    }
                  }
                }
              }
            }
          }
        }
        goto LABEL_17;
      }
    }
  }
  updated = FigSignalErrorAt();
  v10 = 0;
LABEL_15:
  if (!(_DWORD)updated || (_DWORD)updated == -12880)
LABEL_17:
    updated = segPumpUpdateAlternateSelectionBossNetworkErrorFilter(DerivedStorage, 0);
  if (v10)
    CFRelease(v10);
  return updated;
}

uint64_t segPumpMoveStreamAlternateToPenaltyBox(uint64_t a1, uint64_t *a2, int a3, char a4)
{
  uint64_t DerivedStorage;
  _QWORD *v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  const void *v20;
  CFTypeRef v21;
  uint64_t *v22;
  int v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t v26;
  _BOOL4 v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v9 = (_QWORD *)DerivedStorage;
  v10 = *(_QWORD *)(DerivedStorage + 8416);
  for (i = 384; i != 432; i += 16)
  {
    if (v10 && *(_QWORD *)(*(_QWORD *)(DerivedStorage + i) + 16))
    {
      v13 = CMBaseObjectGetDerivedStorage();
      v14 = CMBaseObjectGetDerivedStorage();
      v15 = v14 + 16 * *a2;
      if (*(uint64_t **)(v15 + 384) == a2)
      {
        v17 = 8144;
      }
      else
      {
        if (*(uint64_t **)(v15 + 392) != a2)
          return segPumpUpdateAlternateSelectionBossNetworkErrorFilter(v9, a3);
        v17 = 7680;
      }
      v18 = (uint64_t *)(v14 + v17);
      if ((unint64_t)*a2 > 2)
        return segPumpUpdateAlternateSelectionBossNetworkErrorFilter(v9, a3);
      v19 = *v18;
      if (!*v18)
        return segPumpUpdateAlternateSelectionBossNetworkErrorFilter(v9, a3);
      v34 = 0;
      v35 = 0;
      v33 = 0;
      FigAlternateGetRenditionInfoForMediaType(*(_QWORD *)(v19 + 8), 1936684398, *(const void **)(v13 + 8392), *(const void **)(v13 + 8400), *(const void **)(v13 + 8408), 0, 0, 0, &v35);
      FigAlternateGetRenditionInfoForMediaType(*(_QWORD *)(v19 + 8), 1986618469, *(const void **)(v13 + 8392), *(const void **)(v13 + 8400), *(const void **)(v13 + 8408), 1, 0, 0, &v34);
      FigAlternateGetRenditionInfoForMediaType(*(_QWORD *)(v19 + 8), 1935832172, *(const void **)(v13 + 8392), *(const void **)(v13 + 8400), *(const void **)(v13 + 8408), 0, 0, 0, &v33);
      if (!FigCFEqual() && !FigCFEqual() && !FigCFEqual())
        return segPumpUpdateAlternateSelectionBossNetworkErrorFilter(v9, a3);
      v20 = *(const void **)(v19 + 8);
      if (v20)
        v21 = CFRetain(v20);
      else
        v21 = 0;
      if (segPumGetGroupIDString((uint64_t)v21, *a2))
      {
        v31 = a1;
        v32 = a3;
        v22 = *(uint64_t **)(v13 + 8096);
        if (v22)
        {
          v12 = 0;
          v23 = 0;
          while (1)
          {
            v24 = v22;
            v22 = (uint64_t *)*v22;
            if (segPumpAlternateGroupIDsAndPathwaysAreEqual((uint64_t)v21, v24[1], a2))
            {
              v25 = v24;
              a3 = v32;
              v26 = MoveAlternateFromListWithNoNotification(v13, (uint64_t *)(v13 + 8096), v25, v32, a4);
              v12 = v26;
              v23 = 1;
              if ((_DWORD)v26)
              {
                if ((_DWORD)v26 != -12880)
                  break;
              }
            }
            if (!v22)
              goto LABEL_34;
          }
          v27 = 1;
        }
        else
        {
          v23 = 0;
          v12 = 0;
LABEL_34:
          if (v32 && (v28 = *(uint64_t **)(v13 + 8112)) != 0)
          {
            while (1)
            {
              v29 = v28;
              v28 = (uint64_t *)*v28;
              if (segPumpAlternateGroupIDsAndPathwaysAreEqual((uint64_t)v21, v29[1], a2))
              {
                v23 = 1;
                v30 = MoveAlternateFromListWithNoNotification(v13, (uint64_t *)(v13 + 8112), v29, 1, a4);
                v12 = v30;
                if ((_DWORD)v30)
                {
                  if ((_DWORD)v30 != -12880)
                    break;
                }
              }
              if (!v28)
                goto LABEL_40;
            }
          }
          else
          {
LABEL_40:
            if (v23)
            {
              segPumpReadyNotification((_QWORD *)v13, CFSTR("FBPAL_AlternateListChanged"), 0);
              segPumpDispatchAsyncAlternateSelectionApplyFilter(v13);
              if (!*(_QWORD *)(v13 + 8096))
              {
                segPumpAppendErrorLogEntry(v31, v13, 0, 0, -12880, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Can not proceed after removing variants"), 0, 0, 0, 1u);
                StopAllActiveStreams(v13);
                v12 = 4294954416;
                a3 = v32;
                if (!v21)
                  goto LABEL_6;
                goto LABEL_47;
              }
            }
          }
          v27 = 1;
          a3 = v32;
        }
        a1 = v31;
        if (!(_DWORD)v12)
        {
LABEL_46:
          if (!v21)
            goto LABEL_6;
LABEL_47:
          CFRelease(v21);
          goto LABEL_6;
        }
      }
      else
      {
        v12 = MoveAllAlternatesWithSameMasterStreamWithStreamAlternate(a1, a2, a3, a4);
        v27 = v12 == 0;
        if (!(_DWORD)v12)
          goto LABEL_46;
      }
      if (v27)
        segPumpAppendErrorLogEntry(a1, v13, (uint64_t)a2, 0, (int)v12, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Failed to remove variant"), 0, 0, 0, 1u);
      goto LABEL_46;
    }
    --v10;
  }
  v12 = MoveAllAlternatesWithSameMasterStreamWithStreamAlternate(a1, a2, a3, a4);
LABEL_6:
  if (!(_DWORD)v12 || (_DWORD)v12 == -12880)
    return segPumpUpdateAlternateSelectionBossNetworkErrorFilter(v9, a3);
  return v12;
}

uint64_t segPumpAttemptToRetryRequest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t DerivedStorage;
  uint64_t v10;
  uint64_t UpTimeNanoseconds;
  int v12;
  _BOOL4 IsAlternateLastValidAlternate;
  uint64_t v14;
  void (*v15)(uint64_t);
  const void *v16;
  unsigned int v17;
  uint64_t v18;
  const void *v19;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  char v24;
  uint64_t v25;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a3)
  {
    v10 = *(_QWORD *)(a3 + 24);
    v25 = *(_QWORD *)(a3 + 32);
  }
  else
  {
    v10 = 0;
    v25 = 0;
  }
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v12 = (a5 >> 2) & 1;
  IsAlternateLastValidAlternate = segPumpIsAlternateLastValidAlternate(DerivedStorage, (_QWORD *)a2, *(_QWORD *)(DerivedStorage + 8144), v12);
  if (a3)
  {
    v14 = *(_QWORD *)(a3 + 16);
    if (v14)
    {
      v15 = *(void (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 24);
      if (v15)
        v15(v14);
      v16 = *(const void **)(a3 + 16);
      if (v16)
      {
        CFRelease(v16);
        *(_QWORD *)(a3 + 16) = 0;
      }
    }
    v17 = *(_DWORD *)(a3 + 64);
  }
  else
  {
    v17 = 0;
  }
  v24 = a5;
  if (*(_BYTE *)(DerivedStorage + 8178))
  {
    v18 = *(_QWORD *)(DerivedStorage + 8184);
  }
  else
  {
    if (a4 == 7 && *(_QWORD *)(DerivedStorage + 8096) && !IsAlternateLastValidAlternate)
    {
      if (UpTimeNanoseconds - v10 < 15000000000)
        goto LABEL_15;
LABEL_43:
      if (v12)
        return segPumpMoveAlternatesMatchingHostAndPathwayToPenaltyBox(a1, *(const __CFURL **)(a2 + 16), *(_QWORD *)(a2 + 40), v24 & 1);
      else
        return segPumpMoveStreamAlternateToPenaltyBox(a1, (uint64_t *)a2, 0, 0);
    }
    v18 = 30000000000;
    if (*(_QWORD *)(DerivedStorage + 8440))
    {
      v21 = *(_QWORD *)(DerivedStorage + 8448);
      if (v21)
      {
        if (!FigNetworkPathInformationIsHostReachable(v21, 1))
          v18 = 120000000000;
      }
    }
  }
  if (UpTimeNanoseconds - v10 >= v18)
  {
    if (IsAlternateLastValidAlternate || !*(_QWORD *)(DerivedStorage + 8096) || a4 == 6)
      return segPumpSendEndCallbackForAllActiveStreams(*(_QWORD *)DerivedStorage, *(void **)(a2 + 1152));
    if (a4 != 7)
      return FigSignalErrorAt();
    goto LABEL_43;
  }
LABEL_15:
  if (a3)
  {
    if (a2 + 408 == a3)
    {
      v17 += *(_DWORD *)(a2 + 384);
    }
    else if (a2 + 544 != a3 && DerivedStorage + 7760 != a3)
    {
      v19 = *(const void **)(DerivedStorage + 7896);
      if (v19)
        segPumpEnsureAndGetSessionDataPrivateData(v19);
    }
  }
  if (v17 >= 5)
    v22 = 5;
  else
    v22 = v17;
  v23 = 1000000000 * v22;
  if (UpTimeNanoseconds - v25 >= v23)
    v23 = 1000000000;
  *(_BYTE *)(a2 + 400) = 1;
  return FigHTTPCreateTimer(*(const void **)DerivedStorage, (uint64_t)segPumpRetryTimerCallback, *(NSObject **)(DerivedStorage + 64), (dispatch_object_t *)(a2 + 392), (double)v23 / 1000000000.0);
}

uint64_t MoveAlternateFromValidList(uint64_t a1, uint64_t *a2, int a3, char a4)
{
  _QWORD *DerivedStorage;
  uint64_t v9;
  uint64_t v10;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  v9 = MoveAlternateFromListWithNoNotification((uint64_t)DerivedStorage, DerivedStorage + 1012, a2, a3, a4);
  v10 = v9;
  if ((_DWORD)v9)
  {
    segPumpAppendErrorLogEntry(a1, (uint64_t)DerivedStorage, 0, 0, (int)v9, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Can not proceed after removing variant"), 0, 0, 0, 1u);
    StopAllActiveStreams((uint64_t)DerivedStorage);
  }
  else
  {
    segPumpReadyNotification(DerivedStorage, CFSTR("FBPAL_AlternateListChanged"), 0);
    segPumpDispatchAsyncAlternateSelectionApplyFilter((uint64_t)DerivedStorage);
  }
  return v10;
}

uint64_t segPumpUpdateAlternateSelectionBossNetworkErrorFilter(_QWORD *a1, int a2)
{
  __CFString **v3;
  CFArrayRef *v4;
  unsigned int v5;
  const __CFAllocator *AllocatorForMedia;
  const __CFArray *Copy;
  const __CFArray *v8;
  __CFString *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v13;
  uint64_t v14;
  CFTypeRef cf[25];

  cf[24] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  cf[0] = 0;
  if (!a1[1191])
    return 0;
  if (!a2)
  {
    v3 = kFigAlternateFilterName_NetworkTemporaryError;
    if (a1[1017])
    {
      v4 = (CFArrayRef *)(a1 + 1017);
      v5 = 878;
      goto LABEL_7;
    }
LABEL_12:
    v8 = 0;
    v9 = *v3;
LABEL_13:
    FigAlternateSelectionBossRemoveFilter(a1[1191], (uint64_t)v9);
    goto LABEL_14;
  }
  v3 = kFigAlternateFilterName_NetworkPermanentError;
  if (!a1[1016])
    goto LABEL_12;
  v4 = (CFArrayRef *)(a1 + 1016);
  v5 = 890;
LABEL_7:
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  Copy = CFArrayCreateCopy(AllocatorForMedia, *v4);
  v8 = Copy;
  v9 = *v3;
  if (!Copy || !CFArrayGetCount(Copy))
    goto LABEL_13;
  v10 = FigGetAllocatorForMedia();
  v11 = FigAlternateDenyListFilterCreate(v10, v8, v9, v5, 0, cf);
  if (!(_DWORD)v11)
  {
    v11 = FigAlternateSelectionBossAddFilter(a1[1191], cf[0]);
    if (!(_DWORD)v11)
    {
LABEL_14:
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      v13 = 0;
      v14 = 0;
      if (!v8)
        goto LABEL_16;
      goto LABEL_15;
    }
  }
  v13 = v11;
LABEL_15:
  CFRelease(v8);
  v14 = v13;
LABEL_16:
  if (cf[0])
    CFRelease(cf[0]);
  return v14;
}

uint64_t MoveAlternateFromListWithNoNotification(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4, char a5)
{
  uint64_t *v10;
  uint64_t *v11;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  const __CFArray *v13;
  const __CFAllocator *v14;
  CFIndex FirstIndexOfValue;
  __CFArray *v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  const __CFAllocator *AllocatorForMedia;
  CFMutableArrayRef Mutable;
  uint64_t result;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  NSObject *v30;
  CFRange v31;

  v10 = *(uint64_t **)(a1 + 8144);
  if (v10 == a3)
    segPumpUpdateCurrentAlternate(a1, 0);
  if (*(uint64_t **)(a1 + 7680) == a3)
    *(_QWORD *)(a1 + 7680) = 0;
  v11 = a2;
  do
  {
    v11 = (uint64_t *)*v11;
    if (!v11)
      goto LABEL_27;
  }
  while (!FigCFEqual());
  if (a4)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    v17 = (uint64_t *)*a2;
    if ((uint64_t *)*a2 == a3)
    {
      v23 = *a3;
      *a2 = *a3;
      v18 = a2;
      if (v23)
        goto LABEL_21;
    }
    else
    {
      do
      {
        v18 = v17;
        v17 = (uint64_t *)*v17;
      }
      while (v17 != a3);
      v19 = *a3;
      *v18 = *a3;
      if (v19)
        goto LABEL_21;
    }
    a2[1] = (uint64_t)v18;
LABEL_21:
    if (*(_QWORD *)(a1 + 9528))
    {
      if (*(_QWORD *)(a1 + 8128)
        || (AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia(),
            Mutable = CFArrayCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B378]),
            (*(_QWORD *)(a1 + 8128) = Mutable) != 0))
      {
        if (!FigCFArrayContainsValue())
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 8128), (const void *)a3[1]);
      }
      else
      {
        result = FigSignalErrorAt();
        if ((_DWORD)result)
          return result;
      }
    }
    AlternateEntryFree(a3);
    goto LABEL_27;
  }
  if ((uint64_t *)(a1 + 8096) != a2)
    goto LABEL_27;
  v13 = *(const __CFArray **)(a1 + 8136);
  if (v13
    || (v14 = (const __CFAllocator *)FigGetAllocatorForMedia(),
        v13 = CFArrayCreateMutable(v14, 0, MEMORY[0x1E0C9B378]),
        (*(_QWORD *)(a1 + 8136) = v13) != 0))
  {
    v31.length = CFArrayGetCount(v13);
    v31.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v13, v31, (const void *)a3[1]);
    if ((FirstIndexOfValue & 0x8000000000000000) == 0)
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 8136), FirstIndexOfValue);
    v16 = *(__CFArray **)(a1 + 8136);
    if (v10 == a3)
      CFArrayAppendValue(v16, (const void *)a3[1]);
    else
      CFArrayInsertValueAtIndex(v16, 0, (const void *)a3[1]);
  }
  else
  {
    result = FigSignalErrorAt();
    if ((_DWORD)result)
      return result;
  }
  v24 = *(_QWORD *)(a1 + 8112);
  v25 = (uint64_t *)*a2;
  if ((uint64_t *)*a2 == a3)
  {
    v29 = *a3;
    *a2 = *a3;
    v26 = a2;
    if (v29)
      goto LABEL_38;
  }
  else
  {
    do
    {
      v26 = v25;
      v25 = (uint64_t *)*v25;
    }
    while (v25 != a3);
    v27 = *a3;
    *v26 = *a3;
    if (v27)
      goto LABEL_38;
  }
  *(_QWORD *)(a1 + 8104) = v26;
LABEL_38:
  *a3 = 0;
  **(_QWORD **)(a1 + 8120) = a3;
  *(_QWORD *)(a1 + 8120) = a3;
  if (*a2)
  {
    v28 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    a3[2] = FigGetUpTimeNanoseconds() + 120000000000;
    *((_BYTE *)a3 + 32) = a5;
    v30 = *(NSObject **)(a1 + 8168);
    if (v30)
    {
      if (!v24)
        FigHTTPRescheduleTimer(120.0, *(_QWORD *)(a1 + 64), v30);
      goto LABEL_27;
    }
    result = FigHTTPCreateTimer(*(const void **)a1, (uint64_t)HandlePenaltyBoxTimer, *(NSObject **)(a1 + 64), (dispatch_object_t *)(a1 + 8168), 120.0);
  }
  else
  {
    result = FigSignalErrorAt();
  }
  if ((_DWORD)result)
    return result;
LABEL_27:
  if (*(_QWORD *)(a1 + 8096))
    return 0;
  else
    return FigSignalErrorAt();
}

void segPumpDispatchAsyncAlternateSelectionApplyFilter(uint64_t a1)
{
  const void *v2;
  void *v3;

  v2 = *(const void **)(a1 + 9528);
  if (v2)
  {
    v3 = (void *)CFRetain(v2);
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 9536), v3, (dispatch_function_t)segPumpDispatchAsyncAlternateSelectionBossApplyFilterFunc);
  }
}

void StopAllActiveStreams(uint64_t a1)
{
  NSObject *v2;
  uint64_t i;
  uint64_t v4;

  v2 = *(NSObject **)(a1 + 8168);
  if (v2)
    FigHTTPRescheduleTimer(0.0, *(_QWORD *)(a1 + 64), v2);
  for (i = 384; i != 432; i += 16)
  {
    v4 = *(_QWORD *)(a1 + i);
    if (*(_QWORD *)(v4 + 16))
      segPumpStopStream(a1, v4, 0);
  }
}

void HandlePenaltyBoxTimer(uint64_t a1, uint64_t a2)
{
  uint64_t UpTimeNanoseconds;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  int v6[2];
  CFTypeRef cf;

  *(_QWORD *)v6 = 0;
  cf = 0;
  if (segPumpLockAndCopyPumpFromRetainProxy(a2, &cf, (uint64_t *)v6))
    goto LABEL_12;
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v3 = *(uint64_t **)v6;
  v4 = *(uint64_t **)(*(_QWORD *)v6 + 8112);
  if (!v4)
    goto LABEL_5;
  v5 = v4[2];
  if (v5 > UpTimeNanoseconds)
  {
    LODWORD(v4) = 0;
LABEL_5:
    segPumpUpdateAlternateSelectionBossNetworkErrorFilter(*(_QWORD **)v6, (int)v4);
    segPumpResetPenaltyBoxTimer(*(uint64_t **)v6);
    goto LABEL_12;
  }
  do
  {
    MoveAlternateFromPenaltyBox((uint64_t)v3, v4);
    v3 = *(uint64_t **)v6;
    v4 = *(uint64_t **)(*(_QWORD *)v6 + 8112);
    if (!v4)
    {
      segPumpUpdateAlternateSelectionBossNetworkErrorFilter(*(_QWORD **)v6, 0);
      segPumpResetPenaltyBoxTimer(*(uint64_t **)v6);
      goto LABEL_11;
    }
  }
  while (v4[2] <= UpTimeNanoseconds);
  segPumpUpdateAlternateSelectionBossNetworkErrorFilter(*(_QWORD **)v6, 0);
  segPumpResetPenaltyBoxTimer(*(uint64_t **)v6);
  if (v5 > UpTimeNanoseconds)
    goto LABEL_12;
LABEL_11:
  segPumpReadyNotification(*(_QWORD **)v6, CFSTR("FBPAL_AlternateListChanged"), 0);
  segPumpDispatchAsyncAlternateSelectionApplyFilter(*(uint64_t *)v6);
LABEL_12:
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
}

uint64_t MoveAlternateFromPenaltyBox(uint64_t a1, uint64_t *a2)
{
  const __CFArray *v4;
  CFIndex Count;
  const void *ValueAtIndex;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;

  *((_BYTE *)a2 + 32) = 0;
  if (*(_QWORD *)(a1 + 9528))
  {
    v4 = *(const __CFArray **)(a1 + 8136);
    if (v4)
      Count = CFArrayGetCount(v4);
    else
      Count = 0;
    while (Count-- >= 1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8136), Count);
      if (CFEqual(ValueAtIndex, (CFTypeRef)a2[1]))
      {
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 8136), Count);
        break;
      }
    }
  }
  v8 = *(uint64_t **)(a1 + 8112);
  if (v8 == a2)
  {
    v9 = (uint64_t *)(a1 + 8112);
  }
  else
  {
    do
    {
      v9 = v8;
      v8 = (uint64_t *)*v8;
    }
    while (v8 != a2);
  }
  v10 = *a2;
  *v9 = *a2;
  if (!v10)
    *(_QWORD *)(a1 + 8120) = v9;
  *a2 = 0;
  **(_QWORD **)(a1 + 8104) = a2;
  *(_QWORD *)(a1 + 8104) = a2;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
  os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
  return fig_log_call_emit_and_clean_up_after_send_and_compose();
}

void segPumpResetPenaltyBoxTimer(uint64_t *a1)
{
  NSObject *v1;
  uint64_t v3;
  uint64_t v4;
  double v5;

  v1 = a1[1021];
  if (v1)
  {
    v3 = a1[1014];
    if (v3)
    {
      v4 = *(_QWORD *)(v3 + 16);
      v5 = (double)(v4 - FigGetUpTimeNanoseconds()) / 1000000000.0;
      v1 = a1[1021];
    }
    else
    {
      v5 = 0.0;
    }
    FigHTTPRescheduleTimer(v5, a1[8], v1);
  }
}

void segPumpDispatchAsyncAlternateSelectionBossApplyFilterFunc(const void *a1)
{
  FigAlternateSelectionBossApplyFilters(a1);
  if (a1)
    CFRelease(a1);
}

uint64_t MoveAllAlternatesWithSameMasterStreamWithStreamAlternate(uint64_t a1, _QWORD *a2, int a3, char a4)
{
  _QWORD *DerivedStorage;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  CFTypeRef v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  v9 = CMBaseObjectGetDerivedStorage();
  v10 = v9 + 16 * *a2;
  if (*(_QWORD **)(v10 + 384) == a2)
  {
    v12 = 8144;
  }
  else
  {
    if (*(_QWORD **)(v10 + 392) != a2)
      return 0;
    v12 = 7680;
  }
  v13 = *(_QWORD *)(v9 + v12);
  if (!v13)
    return 0;
  v14 = *(const void **)(v13 + 8);
  if (v14)
    v15 = CFRetain(v14);
  else
    v15 = 0;
  v16 = (uint64_t *)DerivedStorage[1012];
  if (v16)
  {
    v11 = 0;
    while (1)
    {
      v17 = v16;
      v16 = (uint64_t *)*v16;
      if (segPumpAlternateURLsAndPathwaysAreEqual((uint64_t)v15, v17[1]))
      {
        v18 = MoveAlternateFromListWithNoNotification((uint64_t)DerivedStorage, DerivedStorage + 1012, v17, a3, a4);
        v11 = v18;
        if ((_DWORD)v18)
        {
          if ((_DWORD)v18 != -12880)
            goto LABEL_29;
        }
      }
      if (!v16)
      {
        if (a3)
          goto LABEL_19;
        goto LABEL_24;
      }
    }
  }
  v11 = 0;
  if (a3)
  {
LABEL_19:
    v19 = (uint64_t *)DerivedStorage[1014];
    if (v19)
    {
      while (1)
      {
        v20 = v19;
        v19 = (uint64_t *)*v19;
        if (segPumpAlternateURLsAndPathwaysAreEqual((uint64_t)v15, v20[1]))
        {
          v21 = MoveAlternateFromListWithNoNotification((uint64_t)DerivedStorage, DerivedStorage + 1014, v20, 1, a4);
          v11 = 0;
          if ((_DWORD)v21)
          {
            if ((_DWORD)v21 != -12880)
              break;
          }
        }
        if (!v19)
          goto LABEL_24;
      }
      v11 = v21;
LABEL_29:
      segPumpAppendErrorLogEntry(a1, (uint64_t)DerivedStorage, 0, 0, (int)v11, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Failed to remove variant"), 0, 0, 0, 1u);
      goto LABEL_30;
    }
  }
LABEL_24:
  segPumpReadyNotification(DerivedStorage, CFSTR("FBPAL_AlternateListChanged"), 0);
  segPumpDispatchAsyncAlternateSelectionApplyFilter((uint64_t)DerivedStorage);
  if (!DerivedStorage[1012])
  {
    segPumpAppendErrorLogEntry(a1, (uint64_t)DerivedStorage, 0, 0, -12880, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Can not proceed after removing variants"), 0, 0, 0, 1u);
    v11 = 4294954416;
    goto LABEL_30;
  }
  if ((_DWORD)v11)
    goto LABEL_29;
LABEL_30:
  if (v15)
    CFRelease(v15);
  return v11;
}

uint64_t segPumGetGroupIDString(uint64_t a1, uint64_t a2)
{
  if (a2 == 2)
    return FigAlternateGetSubtitleGroupIDString(a1);
  if (a2 == 1)
    return FigAlternateGetAudioGroupIDString(a1);
  if (a2)
    return 0;
  return FigAlternateGetVideoGroupIDString(a1);
}

uint64_t segPumpAlternateGroupIDsAndPathwaysAreEqual(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;

  if (a1 == a2)
    return 1;
  result = 0;
  if (a1 && a2)
  {
    segPumGetGroupIDString(a1, *a3);
    segPumGetGroupIDString(a2, *a3);
    result = FigCFEqual();
    if ((_DWORD)result)
    {
      FigAlternateGetPathwayID(a1);
      FigAlternateGetPathwayID(a2);
      return FigCFEqual() != 0;
    }
  }
  return result;
}

uint64_t segPumpAlternateURLsAndPathwaysAreEqual(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  const void *PlaylistAlternateURL;
  const void *v6;

  if (a1 == a2)
    return 1;
  result = 0;
  if (a1 && a2)
  {
    PlaylistAlternateURL = (const void *)FigAlternateGetPlaylistAlternateURL(a1);
    v6 = (const void *)FigAlternateGetPlaylistAlternateURL(a2);
    result = FigCFHTTPCompareURLs(PlaylistAlternateURL, v6);
    if ((_DWORD)result)
    {
      FigAlternateGetPathwayID(a1);
      FigAlternateGetPathwayID(a2);
      return FigCFEqual() != 0;
    }
  }
  return result;
}

BOOL segPumpIsAlternateLastValidAlternate(uint64_t a1, _QWORD *a2, uint64_t a3, int a4)
{
  uint64_t v8;
  uint64_t AllocatorForMedia;
  unsigned int (*v10)(uint64_t, const __CFString *, uint64_t, CFArrayRef *);
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, const __CFString *, uint64_t, CFTypeRef *);
  int v14;
  CFTypeRef v15;
  int v16;
  CFIndex Count;
  const __CFURL *PlaylistAlternateURL;
  CFStringRef v20;
  CFStringRef v21;
  _QWORD *v22;
  const __CFURL *v23;
  CFStringRef v24;
  CFStringRef v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int (*v29)(uint64_t, const __CFString *, uint64_t, CFTypeRef *);
  int v30;
  int v31;
  __CFArray *Mutable;
  __CFArray *v33;
  CFTypeRef v34;
  CFTypeRef v35;
  unsigned int (*v36)(CFTypeRef, CFTypeRef, CFArrayRef *);
  _BOOL4 v37;
  CFTypeRef v38;
  CFArrayRef v39;
  CFTypeRef cf;
  CFArrayRef theArray;

  if (!a3)
    return 0;
  if (!*(_QWORD *)(a1 + 8096))
    return 0;
  cf = 0;
  theArray = 0;
  v8 = *(_QWORD *)(a1 + 9552);
  if (v8
    && (AllocatorForMedia = FigGetAllocatorForMedia(),
        (v10 = *(unsigned int (**)(uint64_t, const __CFString *, uint64_t, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                                 + 48)) != 0)
    && !v10(v8, CFSTR("AlternateFilterMonitorProperty_KnownPathwayPriorityList"), AllocatorForMedia, &theArray)
    && (v11 = *(_QWORD *)(a1 + 9552),
        v12 = FigGetAllocatorForMedia(),
        (v13 = *(uint64_t (**)(uint64_t, const __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                           + 48)) != 0))
  {
    v14 = v13(v11, CFSTR("AlternateFilterMonitorProperty_CurrentPathwayID"), v12, &cf);
    v15 = cf;
    if (v14)
    {
      v16 = 1;
      if (cf)
LABEL_13:
        CFRelease(v15);
    }
    else
    {
      v16 = 1;
      if (theArray)
      {
        if (cf)
        {
          Count = CFArrayGetCount(theArray);
          v15 = cf;
          if (Count >= 2)
          {
            CFArrayGetValueAtIndex(theArray, Count - 1);
            v16 = FigCFEqual();
            v15 = cf;
          }
        }
      }
      if (v15)
        goto LABEL_13;
    }
  }
  else
  {
    v16 = 1;
  }
  if (theArray)
    CFRelease(theArray);
  if (!v16)
    return 0;
  if (*(_QWORD *)(a1 + 8096) == a3 && *(_QWORD *)(a1 + 8104) == a3)
    return 1;
  if (a4)
  {
    PlaylistAlternateURL = (const __CFURL *)FigAlternateGetPlaylistAlternateURL(*(_QWORD *)(a3 + 8));
    if (PlaylistAlternateURL)
    {
      v20 = CFURLCopyHostName(PlaylistAlternateURL);
      if (v20)
      {
        v21 = v20;
        v22 = *(_QWORD **)(a1 + 8096);
        if (v22)
        {
          while (1)
          {
            v23 = (const __CFURL *)FigAlternateGetPlaylistAlternateURL(v22[1]);
            v24 = CFURLCopyHostName(v23);
            if (v24)
            {
              v25 = v24;
              v26 = CFEqual(v21, v24);
              CFRelease(v25);
              if (!v26)
                break;
            }
            v22 = (_QWORD *)*v22;
            if (!v22)
              goto LABEL_28;
          }
          CFRelease(v21);
          goto LABEL_32;
        }
LABEL_28:
        CFRelease(v21);
      }
    }
    return 1;
  }
LABEL_32:
  cf = 0;
  theArray = 0;
  v38 = 0;
  v39 = 0;
  if (!*(_QWORD *)(a1 + 8144))
    goto LABEL_54;
  if (!*(_QWORD *)(a1 + 9528))
  {
    v33 = 0;
    goto LABEL_56;
  }
  v27 = *(_QWORD *)(a1 + 9568);
  v28 = FigGetAllocatorForMedia();
  v29 = *(unsigned int (**)(uint64_t, const __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                         + 48);
  if (!v29 || v29(v27, CFSTR("FAFProperty_AlternateList"), v28, &cf))
  {
    v33 = 0;
    goto LABEL_53;
  }
  if (!cf
    || CFArrayGetCount((CFArrayRef)cf) < 1
    || (*a2 != 1 ? (v30 = 1935832172) : (v30 = 1936684398),
        *a2 ? (v31 = v30) : (v31 = 1986618469),
        FigAlternateGetRenditionInfoForMediaType(*(_QWORD *)(*(_QWORD *)(a1 + 8144) + 8), v31, *(const void **)(a1 + 8392), *(const void **)(a1 + 8400), *(const void **)(a1 + 8408), 1, 0, &theArray, 0), !theArray))
  {
LABEL_54:
    v37 = 0;
    v33 = 0;
    goto LABEL_58;
  }
  Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(a1 + 56), 0, MEMORY[0x1E0C9B378]);
  v33 = Mutable;
  if (!Mutable)
    goto LABEL_56;
  CFArrayAppendValue(Mutable, theArray);
  if (FigAlternateURLDependencyDenyListFilterCreate(*(void **)(a1 + 56), v33, *(const void **)(a1 + 8152), 1, &v38))goto LABEL_53;
  v34 = v38;
  if (!v38)
  {
LABEL_56:
    if (!FigSignalErrorAt())
      goto LABEL_57;
LABEL_53:
    v37 = 0;
    goto LABEL_58;
  }
  v35 = cf;
  v36 = *(unsigned int (**)(CFTypeRef, CFTypeRef, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                          + 24);
  if (!v36 || v36(v34, v35, &v39))
    goto LABEL_53;
  if (!v39)
  {
LABEL_57:
    v37 = 1;
    goto LABEL_58;
  }
  v37 = CFArrayGetCount(v39) < 1;
LABEL_58:
  if (v38)
    CFRelease(v38);
  if (v33)
    CFRelease(v33);
  if (cf)
    CFRelease(cf);
  if (v39)
    CFRelease(v39);
  return v37;
}

void segPumpRetryTimerCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFTypeRef cf;

  v10 = 0;
  cf = 0;
  FigRetainProxyRetain();
  if (!segPumpLockAndCopyPumpFromRetainProxy(a2, &cf, &v10))
  {
    v4 = 0;
    v5 = 1;
    do
    {
      v6 = 0;
      v7 = v5;
      v8 = v10 + 16 * v4 + 384;
      while (1)
      {
        v9 = *(_QWORD *)(v8 + v6);
        if (*(_QWORD *)(v9 + 392) == a1)
          break;
        v6 += 8;
        if (v6 == 24)
          goto LABEL_8;
      }
      *(_BYTE *)(v9 + 400) = 0;
      segPumpRestartStreamReads(cf);
LABEL_8:
      v5 = 0;
      v4 = 1;
    }
    while ((v7 & 1) != 0);
  }
  segPumpUnlockAndSendAllPendingNotifications();
  FigRetainProxyRelease();
  if (cf)
    CFRelease(cf);
}

uint64_t segPumpRestartStreamReads(const void *a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t SessionDataRequest;
  uint64_t MediaForSingleStream;
  const __CFURL *v8;
  const __CFAllocator *AllocatorForMedia;
  const __CFString *Identifier;
  const __CFURL *v12;
  const void *v13;
  uint64_t CryptKeyCommonData;
  const void *v15;
  uint64_t v16;
  uint64_t v17;

  v16 = 0;
  v17 = 0;
  SessionDataRequest = segPumpReadOrScheduleIndexFileRead((uint64_t)a1, (uint64_t)a2, (uint64_t)a3);
  if ((_DWORD)SessionDataRequest)
    goto LABEL_12;
  MediaForSingleStream = segPumpDeliverNextMediaForSingleStream(a1, (uint64_t)a2, (uint64_t)a3);
  if ((_DWORD)MediaForSingleStream == -15626)
  {
    SessionDataRequest = 4294951670;
    goto LABEL_12;
  }
  SessionDataRequest = MediaForSingleStream;
  if (a3[31] && !a3[70])
  {
    AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    Identifier = (const __CFString *)FigContentKeySpecifierGetIdentifier(a3[31]);
    v12 = CFURLCreateWithString(AllocatorForMedia, Identifier, 0);
    if (!v12)
    {
      SessionDataRequest = FigSignalErrorAt();
      if (!(_DWORD)SessionDataRequest)
        return SessionDataRequest;
      goto LABEL_12;
    }
    v8 = v12;
    if (segPumpShouldRequestURLAsHTTPURL((uint64_t)a2, v12))
    {
      v13 = (const void *)a3[31];
      CryptKeyCommonData = segPumpGetCryptKeyCommonData(v13, &v17, &v16);
      if ((_DWORD)CryptKeyCommonData)
      {
        SessionDataRequest = CryptKeyCommonData;
LABEL_10:
        CFRelease(v8);
        goto LABEL_11;
      }
      if (*(_BYTE *)(v16 + 145))
        segPumpCancelCryptReadAndResetData((uint64_t)a2, (uint64_t)a3);
      v15 = (const void *)a3[31];
      a3[31] = v13;
      if (v13)
        CFRetain(v13);
      if (v15)
        CFRelease(v15);
      SessionDataRequest = segPumpSendCryptKeyRequest((uint64_t)a1, (uint64_t)a2, (uint64_t)a3, (const __CFString *)a3[31]);
      if ((_DWORD)SessionDataRequest)
        goto LABEL_10;
    }
  }
  else
  {
    v8 = 0;
  }
  if (!*a3 && a2[987])
    SessionDataRequest = segPumpSendNextSessionDataRequest((uint64_t)a2, (uint64_t)a3, 0);
  if (v8)
    goto LABEL_10;
LABEL_11:
  if ((_DWORD)SessionDataRequest)
LABEL_12:
    segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(*a2, SessionDataRequest);
  return SessionDataRequest;
}

uint64_t segPumpReadOrScheduleIndexFileRead(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t result;
  __CFError *v8;
  CFIndex Code;
  uint64_t UpTimeNanoseconds;
  double v11;
  uint64_t v12;

  v6 = *(_QWORD *)(a3 + 56);
  if (!v6 || (result = FigStreamPlaylistParserHTTPServerMayMutatePlaylist(v6), (_DWORD)result))
  {
    if (!*(_DWORD *)(a2 + 8) || *(_BYTE *)(a3 + 1169))
      return 0;
    v8 = *(__CFError **)(a3 + 480);
    if (v8)
    {
      Code = CFErrorGetCode(v8);
      if (Code == -16839 || Code == -1005 || Code == -1009)
        *(_BYTE *)(a3 + 1168) = 1;
    }
    if (*(_BYTE *)(a3 + 859) || *(_QWORD *)(a3 + 424) || *(_BYTE *)(a3 + 870) || *(_BYTE *)(a3 + 400))
    {
      return 0;
    }
    else
    {
      UpTimeNanoseconds = FigGetUpTimeNanoseconds();
      v12 = UpTimeNanoseconds;
      segPumpGetIndexFileRefreshTimestamp(a2, a3, UpTimeNanoseconds, &v12);
      if (v12 <= UpTimeNanoseconds + 10000000)
      {
        return segPumpSendIndexFileRequest(a1, a2, a3);
      }
      else
      {
        v11 = (double)(v12 - UpTimeNanoseconds) / 1000000000.0;
        *(_BYTE *)(a3 + 400) = 1;
        return FigHTTPCreateTimer(*(const void **)a2, (uint64_t)segPumpRetryTimerCallback, *(NSObject **)(a2 + 64), (dispatch_object_t *)(a3 + 392), v11);
      }
    }
  }
  return result;
}

uint64_t segPumpDeliverNextMediaForSingleStream(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  const __CFArray *MediaSegmentSpecifiers;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  int v11;
  uint64_t v13;
  uint64_t i;
  _QWORD *v15;
  const void *v16;
  double v17;
  double v18;
  float v19;
  uint64_t UpTimeNanoseconds;
  const void *v21;
  const void *v22;
  const void *v23;
  double v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFURL *v29;
  const __CFURL *v30;
  _QWORD *MediaFilePrivateData;
  const void *v32;
  uint64_t v33;
  CFTypeRef cf;
  CMTime v35;
  CMTime v36;
  unsigned __int8 v37;
  __int16 v38;
  const void *v39;
  const void *v40;
  char v41;
  uint64_t v42;
  const void *v43;

  v39 = 0;
  v40 = 0;
  v38 = 0;
  v37 = 0;
  FigRetainProxyRetain();
  v6 = *(_QWORD *)(a3 + 56);
  if (!v6)
    goto LABEL_20;
  MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v6);
  if (!MediaSegmentSpecifiers
    || CFArrayGetCount(MediaSegmentSpecifiers) < 1
    || *(_BYTE *)(a3 + 866)
    || (*(_DWORD *)(a3 + 160) & 0xFFFFFFFE) != 4
    || *(_BYTE *)(a3 + 1136))
  {
    goto LABEL_20;
  }
  if (*(_BYTE *)(a2 + 8712))
  {
    if (!*(_BYTE *)(a2 + 8768) && !*(_BYTE *)(a2 + 8713) && (*(_BYTE *)(a3 + 857) || *(_BYTE *)(a3 + 862)))
    {
      v17 = *(double *)(a3 + 120);
      if (v17 >= 0.0)
      {
        v18 = dbl_1932FD110[*(float *)(a2 + 8736) >= 0.0];
        CMTimeMakeWithSeconds(&v36, v17, 1000);
        v19 = *(float *)(a2 + 8736);
        UpTimeNanoseconds = FigGetUpTimeNanoseconds();
        CMTimeMakeWithSeconds(&v35, v18 + *(double *)(a3 + 120), 1000);
        v8 = segPumpStepNextFrame(a1, &v36, UpTimeNanoseconds, &v35, 1, 0, v19);
        goto LABEL_11;
      }
LABEL_20:
      v9 = 0;
      goto LABEL_21;
    }
    v8 = segPumpTryIFrameFetch((uint64_t)a1, a2);
LABEL_11:
    v9 = v8;
    goto LABEL_21;
  }
  v10 = *(const void **)(a3 + 256);
  if (v10)
  {
    if (*(_QWORD *)(a3 + 264))
      v10 = *(const void **)(a3 + 264);
    v40 = v10;
    goto LABEL_18;
  }
  v8 = segPumpDetermineMediaSegmentToDeliver(a2, a3, &v40, &v39);
  if ((_DWORD)v8)
    goto LABEL_11;
  if (segPumpStreamShouldYieldToTrialSwitch(a2, (_QWORD *)a3))
    goto LABEL_18;
  v22 = v39;
  v21 = v40;
  v23 = v39 ? v39 : v40;
  if (!segPumpStreamReadAheadPermitsNextRead(a2, a3, (uint64_t)v23) || !v21)
    goto LABEL_18;
  if (*(_QWORD *)a3 == *(_QWORD *)(a2 + 8416) && *(_QWORD *)(a2 + 296))
  {
    v25 = *(_QWORD *)(a3 + 80);
    v26 = *(_QWORD *)(a3 + 880);
    v8 = segPumpCheckCachedVariantsAndRequestSwitch(a2, a3, v21, 0, v24);
    if ((_DWORD)v8)
      goto LABEL_11;
    if (FigRetainProxyIsInvalidated() || *(_QWORD *)(a3 + 80) != v25 || v26 != *(_QWORD *)(a3 + 880))
      goto LABEL_20;
  }
  if (*(_BYTE *)(a3 + 862))
    *(_QWORD *)(a3 + 376) = FigMediaSegmentSpecifierGetMediaSequence((uint64_t)v21) - 1;
  v8 = segPumpFetchOrDispatchMediaSegment((uint64_t)a1, a2, a3, v21, v22, (char *)&v37, (_BYTE *)&v38 + 1);
  if ((_DWORD)v8)
    goto LABEL_11;
  if (*(_BYTE *)(a3 + 1136))
  {
    v40 = 0;
LABEL_18:
    v11 = v37;
    goto LABEL_19;
  }
  v11 = v37;
  if (!v37 && !HIBYTE(v38))
  {
    if (!segPumpIsMediaSegmentWaitingOnCryptKey((uint64_t)v21) && !*(_BYTE *)(a3 + 869))
    {
      v27 = FigGetUpTimeNanoseconds();
      v28 = *(_QWORD *)(a3 + 696);
      ++*(_DWORD *)(v28 + 80);
      if (!*(_QWORD *)(v28 + 40))
        *(_QWORD *)(v28 + 40) = v27;
      *(_QWORD *)(v28 + 48) = v27;
      cf = *(CFTypeRef *)(v28 + 16);
      v29 = *(const __CFURL **)(a3 + 16);
      v30 = *(const __CFURL **)(a3 + 24);
      MediaFilePrivateData = segPumpGetMediaFilePrivateData(v21);
      segPumpEnsureMediaSegmentURLs(v21, v29, v30);
      v32 = (const void *)MediaFilePrivateData[2];
      *(_QWORD *)(v28 + 16) = v32;
      if (v32)
        CFRetain(v32);
      if (cf)
        CFRelease(cf);
      if (*(_BYTE *)(a2 + 8176))
        v33 = 7;
      else
        v33 = 6;
      v8 = segPumpAttemptToRetryRequest((uint64_t)a1, a3, v28 + 16, v33, 4u);
      if ((_DWORD)v8)
        goto LABEL_11;
      if (*(_BYTE *)(a3 + 1136))
        goto LABEL_20;
    }
    goto LABEL_18;
  }
LABEL_19:
  if (v11)
    goto LABEL_20;
  v9 = segPumpStreamDoDeliveryFollowUp((uint64_t)a1, a2, a3, HIBYTE(v38), v40, &v38);
  if (!(_DWORD)v9 && (_BYTE)v38)
  {
    v13 = *(_QWORD *)a3;
    for (i = 384; i != 432; i += 16)
    {
      if (v13)
      {
        v15 = *(_QWORD **)(a2 + i);
        if (v15[2])
        {
          if (!*(_QWORD *)(v15[87] + 8))
          {
            v42 = 0;
            v43 = 0;
            if (v15[32])
            {
              if (v15[33])
                v16 = (const void *)v15[33];
              else
                v16 = (const void *)v15[32];
              if (v16)
                goto LABEL_37;
            }
            else
            {
              v8 = segPumpDetermineMediaSegmentToDeliver(a2, (uint64_t)v15, &v43, &v42);
              if ((_DWORD)v8)
                goto LABEL_11;
              if (v42)
                goto LABEL_20;
              v16 = v43;
              if (v43)
              {
LABEL_37:
                v8 = segPumpTrySpeculativeRead((uint64_t)a1, (uint64_t *)a2, (uint64_t)v15, v16, &v41);
                if ((_DWORD)v8)
                  goto LABEL_11;
              }
            }
          }
        }
      }
      v9 = 0;
      --v13;
    }
  }
LABEL_21:
  FigRetainProxyRelease();
  return v9;
}

uint64_t segPumpGetCryptKeyCommonData(const void *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v6;
  _QWORD *Instance;
  uint64_t result;
  __int128 v9;

  if (!a1)
    return FigSignalErrorAt();
  v6 = CMGetAttachment(a1, CFSTR("SegPumpCryptKeyPrivateData"), 0);
  if (!v6)
  {
    FigGetAllocatorForMedia();
    v9 = xmmword_1E2FA7190;
    if (segPumpCryptKeyPrivateDataGetTypeID_once != -1)
      dispatch_once_f(&segPumpCryptKeyPrivateDataGetTypeID_once, &v9, (dispatch_function_t)segPumpRegisterClassUtil);
    Instance = (_QWORD *)_CFRuntimeCreateInstance();
    if (!Instance)
      return FigSignalErrorAt();
    v6 = Instance;
    CMSetAttachment(a1, CFSTR("SegPumpCryptKeyPrivateData"), Instance, 0);
    CFRelease(v6);
  }
  if (a2)
    *a2 = v6;
  result = 0;
  if (a3)
    *a3 = v6[2];
  return result;
}

double segPumpCancelCryptReadAndResetData(uint64_t a1, uint64_t a2)
{
  const void *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  void (*v8)(uint64_t, uint64_t);
  uint64_t v9;
  uint64_t v10;
  void (*v11)(uint64_t, uint64_t);
  const void *v12;
  uint64_t v14;
  uint64_t v15;

  v14 = 0;
  v15 = 0;
  v4 = *(const void **)(a2 + 248);
  if (v4 && !segPumpGetCryptKeyCommonData(v4, &v15, &v14))
  {
    v5 = (_QWORD *)v14;
    *(_WORD *)(v14 + 144) = 0;
    v5[4] = 0;
    v5[15] = 0;
    v6 = v5[10];
    if (v6)
    {
      v7 = *(_QWORD *)(a1 + 80);
      if (v7)
      {
        v8 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
        if (v8)
          v8(v7, v6);
      }
      segPumpResetCryptKeyRequestDataForCustomURLRequestID(*(const void **)(a2 + 248), *(_QWORD *)(v14 + 80));
      v9 = *(_QWORD *)(v14 + 120);
      if (v9)
      {
        v10 = *(_QWORD *)(a1 + 80);
        if (v10)
        {
          v11 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
          if (v11)
            v11(v10, v9);
        }
        segPumpResetCryptKeyRequestDataForCustomURLRequestID(*(const void **)(a2 + 248), *(_QWORD *)(v14 + 120));
      }
    }
    FigHTTPStopAndReleaseTimer((dispatch_object_t *)(a2 + 640));
    v12 = *(const void **)(a2 + 248);
    if (v12)
    {
      CFRelease(v12);
      *(_QWORD *)(a2 + 248) = 0;
    }
  }
  return segPumpResetConnection(a1, a2 + 544);
}

uint64_t segPumpSendCryptKeyRequest(uint64_t a1, uint64_t a2, uint64_t a3, const __CFString *a4)
{
  unsigned __int8 *v7;
  NSObject *v8;
  uint64_t CryptKeyCommonData;
  char IsLowValueFairPlayStreamingKey;
  const void *v11;
  uint64_t AllocatorForMedia;
  uint64_t v13;
  CFTypeRef v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, CFTypeRef, uint64_t, _QWORD, uint64_t, uint64_t, CFTypeRef *, uint64_t, uint64_t, uint64_t *);
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v21;
  const __CFAllocator *v22;
  const __CFString *Identifier;
  CFURLRef v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v31;
  uint64_t UpTimeNanoseconds;
  const void *v33;
  CFTypeRef v34;
  uint64_t v35;
  CFTypeRef v36;
  uint64_t v37;
  CFTypeRef v38;
  NSObject *v39;
  unsigned int v40;
  unsigned int v41;
  const __CFString *v42;
  uint64_t v43;
  const __CFString *v44;
  uint64_t v45;
  int v46;
  uint64_t CFDataWithBlockBufferNoCopy;
  const __CFAllocator *v48;
  __CFDictionary *Mutable;
  uint64_t v50;
  const void *v51;
  int EncryptionMethod;
  __CFString **v53;
  uint64_t SupportedProtocolVersions;
  const void *v55;
  const void *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  uint64_t (*v61)(uint64_t, uint64_t, uint64_t, uint64_t, char *);
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  void (*v65)(uint64_t, _QWORD, uint64_t, CFTypeRef *);
  __CFError *v66;
  const __CFURL *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t (*v72)(uint64_t, uint64_t, uint64_t, _QWORD, char *);
  NSObject *v73;
  unsigned int v74;
  unsigned int v75;
  const __CFString *v76;
  uint64_t v77;
  const __CFString *v78;
  uint64_t v79;
  NSObject *v80;
  unsigned int v81;
  unsigned int v82;
  const __CFString *v83;
  uint64_t v84;
  const __CFString *v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t (*v92)(uint64_t, _QWORD, uint64_t);
  uint64_t v93;
  uint64_t (*v94)(uint64_t, _QWORD, uint64_t);
  NSObject *v95;
  unsigned int v96;
  unsigned int v97;
  const __CFString *v98;
  uint64_t v99;
  const __CFString *v100;
  uint64_t v101;
  uint64_t v102;
  int v103;
  _BOOL4 v104;
  uint64_t v105;
  const void *v106;
  CFTypeRef v107;
  uint64_t v108;
  CFTypeRef v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  const void *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  NSObject *v118;
  unsigned int v119;
  unsigned int v120;
  const __CFString *v121;
  uint64_t v122;
  const __CFString *v123;
  int v124;
  unsigned int v125;
  double v126;
  CFTypeRef v127;
  int v128;
  uint64_t v129;
  uint64_t v130;
  CFTypeRef v131;
  int v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t (*v137)(uint64_t, CFTypeRef, uint64_t, BOOL, uint64_t, uint64_t, CFTypeRef *, uint64_t, uint64_t, uint64_t *);
  NSObject *v138;
  uint64_t v139;
  uint64_t v140;
  void (*v141)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v143;
  uint64_t *v144;
  uint64_t v145;
  uint64_t v146;
  char *v147;
  uint64_t (*v148)(uint64_t, uint64_t, uint64_t, uint64_t, char *);
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t (*v152)(uint64_t, _QWORD, uint64_t);
  uint64_t v153;
  uint64_t v154;
  uint64_t (*v155)(uint64_t, _QWORD, uint64_t);
  uint64_t v156;
  uint64_t v157;
  CFTypeRef v158;
  uint64_t v159;
  NSObject *v160;
  unsigned int v161;
  unsigned int v162;
  const __CFString *v163;
  uint64_t v164;
  const __CFString *v165;
  uint64_t v166;
  uint64_t v167;
  int v168;
  uint64_t v169;
  uint64_t v170;
  const __CFURL *v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  os_log_type_t type;
  int v177;
  uint64_t v178;
  os_log_type_t v179[8];
  uint64_t v180;
  CFTypeRef v181[2];
  void (*v182)(uint64_t, int, const void *, uint64_t, CFErrorRef, const sockaddr *);
  CFTypeRef cf;
  CFTypeRef v184;
  _BYTE v185[12];
  __int16 v186;
  const __CFString *v187;
  __int16 v188;
  uint64_t v189;
  __int16 v190;
  const __CFString *v191;
  __int16 v192;
  uint64_t v193;
  __int16 v194;
  uint64_t v195;
  __int16 v196;
  int v197;
  __int128 v198[4];
  uint64_t v199;
  __int128 v200;
  __int128 v201;
  uint64_t v202;
  uint64_t v203;

  v203 = *MEMORY[0x1E0C80C00];
  v174 = 0;
  v175 = 0;
  if (!*(_BYTE *)(a2 + 323))
    return 0;
  v7 = (unsigned __int8 *)(a2 + 7992);
  if (*(_BYTE *)(a2 + 9480))
  {
    cf = 0;
    v184 = 0;
    *(_OWORD *)v181 = xmmword_1E2FA71A0;
    v182 = segPumpKeyRequestDidFail;
    *(_QWORD *)v179 = 0;
    v180 = 0;
    v178 = 0;
    if (!*(_QWORD *)(a2 + 152))
    {
      v8 = *(NSObject **)(a2 + 64);
      *(_QWORD *)(a2 + 152) = v8;
      dispatch_retain(v8);
    }
    CryptKeyCommonData = segPumpGetCryptKeyCommonData(a4, v179, &v178);
    if ((_DWORD)CryptKeyCommonData)
      goto LABEL_255;
    if (*(_BYTE *)(v178 + 145) || !v7[1488])
    {
LABEL_222:
      CFDataWithBlockBufferNoCopy = 0;
      goto LABEL_223;
    }
    IsLowValueFairPlayStreamingKey = segPumpCryptKeyIsLowValueFairPlayStreamingKey((uint64_t)a4);
    if (!FigContentKeySpecifierGetIdentifier((uint64_t)a4))
    {
      CryptKeyCommonData = FigSignalErrorAt();
      goto LABEL_255;
    }
    v11 = *(const void **)(a2 + 9520);
    segPumpEnsureCMCDHeaderVendor(a2);
    if (FigContentKeySpecifierGetKeySystem((uint64_t)a4) == 1)
    {
      if (*v7)
      {
        if (FigContentKeySpecifierGetEncryptionMethod((uint64_t)a4) == 1)
        {
          AllocatorForMedia = FigGetAllocatorForMedia();
          CryptKeyCommonData = FigContentKeyRequestParamsCreate(AllocatorForMedia, a4, IsLowValueFairPlayStreamingKey, 1, 0, 0, v11, 0, 0, 1, 1, 0, (uint64_t *)&cf);
          if ((_DWORD)CryptKeyCommonData)
            goto LABEL_255;
          v13 = *(_QWORD *)(a2 + 9488);
          v14 = cf;
          v169 = *(_QWORD *)(a2 + 240);
          v15 = *(_QWORD *)(a2 + 216);
          v16 = *(_QWORD *)a2;
          v17 = *(_QWORD *)(a2 + 152);
          v18 = *(uint64_t (**)(uint64_t, CFTypeRef, uint64_t, _QWORD, uint64_t, uint64_t, CFTypeRef *, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
          if (!v18)
          {
LABEL_216:
            CFDataWithBlockBufferNoCopy = 4294954514;
            goto LABEL_223;
          }
          CryptKeyCommonData = v18(v13, v14, 1, 0, v169, v15, v181, v16, v17, &v180);
          if ((_DWORD)CryptKeyCommonData)
            goto LABEL_255;
          *(_QWORD *)(v178 + 40) = v180;
          if (dword_1EE2A31E8)
          {
            v177 = 0;
            type = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
            v128 = 1;
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          else
          {
            v128 = 1;
          }
        }
        else
        {
          v128 = 0;
        }
        if (*v7)
        {
          v26 = 1;
          v27 = 4;
          v128 = 1;
          goto LABEL_211;
        }
        v26 = 0;
      }
      else
      {
        v26 = 0;
        v128 = 0;
      }
      v27 = 1;
    }
    else
    {
      v25 = *(_DWORD *)(v178 + 24);
      if (v25 == 4 || v25 == 2)
      {
        v26 = 0;
        v128 = 0;
        v27 = 2;
      }
      else
      {
        v26 = 0;
        v128 = 0;
        v27 = 0;
      }
    }
LABEL_211:
    v129 = FigGetAllocatorForMedia();
    CryptKeyCommonData = FigContentKeyRequestParamsCreate(v129, a4, IsLowValueFairPlayStreamingKey, v128, v26, 0, v11, 0, 0, 1, 1, 0, (uint64_t *)&v184);
    if ((_DWORD)CryptKeyCommonData)
      goto LABEL_255;
    v130 = *(_QWORD *)(a2 + 9488);
    v131 = v184;
    v132 = *v7;
    v133 = *(_QWORD *)(a2 + 240);
    v134 = *(_QWORD *)(a2 + 216);
    v135 = *(_QWORD *)a2;
    v136 = *(_QWORD *)(a2 + 152);
    v137 = *(uint64_t (**)(uint64_t, CFTypeRef, uint64_t, BOOL, uint64_t, uint64_t, CFTypeRef *, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
    if (v137)
    {
      CryptKeyCommonData = v137(v130, v131, v27, v132 == 0, v133, v134, v181, v135, v136, &v180);
      if (!(_DWORD)CryptKeyCommonData)
      {
        if (dword_1EE2A31E8)
        {
          v177 = 0;
          type = OS_LOG_TYPE_DEFAULT;
          v138 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        v139 = v178;
        *(_QWORD *)(v178 + 32) = v180;
        *(_BYTE *)(v139 + 145) = 1;
        if (*(_QWORD *)v179)
          *(_QWORD *)(*(_QWORD *)v179 + 56) = FigGetUpTimeNanoseconds();
        v140 = *(_QWORD *)(a2 + 9048);
        if (v140)
        {
          v141 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                             + 56);
          if (v141)
            v141(v140, CFSTR("playerStats"), CFSTR("FetchingKey"), 1, 0);
        }
        goto LABEL_222;
      }
LABEL_255:
      CFDataWithBlockBufferNoCopy = CryptKeyCommonData;
LABEL_223:
      if (v184)
        CFRelease(v184);
      v127 = cf;
      if (cf)
        goto LABEL_226;
      return CFDataWithBlockBufferNoCopy;
    }
    goto LABEL_216;
  }
  v21 = segPumpGetCryptKeyCommonData(a4, &v175, &v174);
  if ((_DWORD)v21)
    return v21;
  if (*(_BYTE *)(v174 + 145))
    return FigSignalErrorAt();
  v173 = a1;
  if (FigContentKeySpecifierGetIdentifier((uint64_t)a4))
  {
    v22 = (const __CFAllocator *)FigGetAllocatorForMedia();
    Identifier = (const __CFString *)FigContentKeySpecifierGetIdentifier((uint64_t)a4);
    v24 = CFURLCreateWithString(v22, Identifier, 0);
  }
  else
  {
    v24 = 0;
  }
  v28 = v174;
  *(_QWORD *)(v174 + 152) = 0;
  *(_BYTE *)(v28 + 145) = 1;
  v29 = *(_QWORD *)(a2 + 9048);
  if (v29)
  {
    v30 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v30)
      v30(v29, CFSTR("playerStats"), CFSTR("FetchingKey"), 1, 0);
  }
  *(_QWORD *)(v175 + 56) = FigGetUpTimeNanoseconds();
  if (*(const __CFString **)(a3 + 248) == a4)
  {
    UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    *(_QWORD *)(a3 + 576) = UpTimeNanoseconds;
    if (!*(_DWORD *)(a3 + 608))
      *(_QWORD *)(a3 + 568) = UpTimeNanoseconds;
    v31 = *(_QWORD *)(a3 + 560);
    *(_QWORD *)(a3 + 560) = 0;
    *(_QWORD *)(a3 + 632) = 0;
    v33 = *(const void **)(a3 + 544);
    if (v33)
    {
      CFRelease(v33);
      *(_QWORD *)(a3 + 544) = 0;
    }
    if (v24)
      v34 = CFRetain(v24);
    else
      v34 = 0;
    *(_QWORD *)(a3 + 544) = v34;
  }
  else
  {
    v31 = 0;
  }
  v181[0] = 0;
  cf = 0;
  v184 = 0;
  v35 = segPumpGetCryptKeyCommonData(a4, v181, &v184);
  if ((_DWORD)v35)
    goto LABEL_180;
  if (FigContentKeySpecifierGetKeySystem((uint64_t)a4) == 1 && !*((_QWORD *)v184 + 8))
  {
    v48 = (const __CFAllocator *)FigGetAllocatorForMedia();
    Mutable = CFDictionaryCreateMutable(v48, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v50 = (uint64_t)Mutable;
    if (!Mutable)
    {
      CFDataWithBlockBufferNoCopy = FigSignalErrorAt();
      goto LABEL_139;
    }
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA3058], CFSTR("com.apple.pkd"));
    v51 = (const void *)FigContentKeySpecifierGetIdentifier((uint64_t)a4);
    CFDictionarySetValue((CFMutableDictionaryRef)v50, (const void *)*MEMORY[0x1E0CA3030], v51);
    FigCFDictionarySetInt32();
    EncryptionMethod = FigContentKeySpecifierGetEncryptionMethod((uint64_t)a4);
    v53 = kFigCPEProtectorCryptorCreationOptionDecryptFormatType_Pastis;
    if (EncryptionMethod == 2)
      v53 = kFigCPEProtectorCryptorCreationOptionDecryptFormatType_MSE;
    CFDictionarySetValue((CFMutableDictionaryRef)v50, (const void *)*MEMORY[0x1E0CA3048], *v53);
    SupportedProtocolVersions = FigContentKeySpecifierGetSupportedProtocolVersions((uint64_t)a4);
    if (!*v7
      || *(_QWORD *)a3
      || FigContentKeySpecifierGetEncryptionMethod((uint64_t)a4) == 3
      || FigContentKeySpecifierGetEncryptionMethod((uint64_t)a4) == 2
      || *((_QWORD *)v184 + 13))
    {
LABEL_74:
      v55 = *(const void **)(a2 + 9448);
      if (v55)
        CFDictionarySetValue((CFMutableDictionaryRef)v50, (const void *)*MEMORY[0x1E0CA3078], v55);
      v56 = *(const void **)(a2 + 9456);
      if (v56)
        CFDictionarySetValue((CFMutableDictionaryRef)v50, (const void *)*MEMORY[0x1E0CA3070], v56);
      if (segPumpCryptKeyIsLowValueFairPlayStreamingKey((uint64_t)a4))
        CFDictionarySetValue((CFMutableDictionaryRef)v50, (const void *)*MEMORY[0x1E0CA3068], (const void *)*MEMORY[0x1E0C9AE50]);
      v170 = SupportedProtocolVersions;
      v57 = v31;
      if (FigContentKeySpecifierGetEncryptionMethod((uint64_t)a4) != 3 && *v7 && !*(_QWORD *)a3)
        CFDictionarySetValue((CFMutableDictionaryRef)v50, (const void *)*MEMORY[0x1E0CA3040], CFSTR("DestinationNero"));
      v58 = *(_QWORD *)(a2 + 9472);
      v59 = FigGetAllocatorForMedia();
      v60 = (char *)v184;
      v61 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                             + 16)
                                                                                 + 16);
      if (!v61)
        goto LABEL_135;
      v62 = v61(v58, v59, v50, 1, v60 + 64);
      if (!(_DWORD)v62)
      {
        v63 = *((_QWORD *)v184 + 8);
        v64 = FigGetAllocatorForMedia();
        v65 = *(void (**)(uint64_t, _QWORD, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                           + 48);
        if (v65)
        {
          v65(v63, *MEMORY[0x1E0CA31E0], v64, &cf);
          v66 = (__CFError *)cf;
        }
        else
        {
          v66 = 0;
        }
        v31 = v57;
        segPumpRTCReportingUpdateCryptorErrorKeys(a2, v66);
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
        CMNotificationCenterGetDefaultLocalCenter();
        v88 = FigNotificationCenterAddWeakListener();
        if ((_DWORD)v88)
        {
          CFDataWithBlockBufferNoCopy = v88;
          if ((_DWORD)v88 != -12724)
            goto LABEL_137;
        }
        *((_QWORD *)v184 + 9) = *(_QWORD *)a2;
        CMNotificationCenterGetDefaultLocalCenter();
        v89 = FigNotificationCenterAddWeakListener();
        if ((_DWORD)v89)
        {
          CFDataWithBlockBufferNoCopy = v89;
          if ((_DWORD)v89 != -12724)
            goto LABEL_137;
        }
        v90 = *(_QWORD *)(a2 + 264);
        if (!v90)
          goto LABEL_123;
        v91 = *((_QWORD *)v184 + 8);
        v92 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
        if (!v92)
          goto LABEL_135;
        v62 = v92(v91, *MEMORY[0x1E0CA31C0], v90);
        if (!(_DWORD)v62)
        {
LABEL_123:
          if (!v170)
          {
LABEL_126:
            CFDataWithBlockBufferNoCopy = segPumpPrepareCryptorForKeyLoading(*((_QWORD *)v184 + 8), *((_QWORD *)v184 + 9), 0, (_QWORD *)v184 + 12, (unsigned __int8 *)v184 + 88);
            v31 = v57;
            if (!(_DWORD)CFDataWithBlockBufferNoCopy && dword_1EE2A31E8)
            {
              LODWORD(v180) = 0;
              v179[0] = OS_LOG_TYPE_DEFAULT;
              v95 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              v96 = v180;
              if (os_log_type_enabled(v95, v179[0]))
                v97 = v96;
              else
                v97 = v96 & 0xFFFFFFFE;
              if (v97)
              {
                v98 = &stru_1E2FD85F8;
                v99 = *(_QWORD *)a3;
                if (*(_QWORD *)(a2 + 8760))
                  v98 = *(const __CFString **)(a2 + 8760);
                v100 = *(const __CFString **)(a2 + 9472);
                v101 = *((_QWORD *)v184 + 8);
                v102 = *((_QWORD *)v184 + 12);
                v103 = *((unsigned __int8 *)v184 + 88);
                *(_DWORD *)v185 = 136316674;
                *(_QWORD *)&v185[4] = "segPumpSetupCryptorForCryptKey";
                v186 = 2114;
                v187 = v98;
                v188 = 2048;
                v189 = v99;
                v190 = 2048;
                v191 = v100;
                v192 = 2048;
                v193 = v101;
                v194 = 2048;
                v195 = v102;
                v196 = 1024;
                v197 = v103;
                _os_log_send_and_compose_impl();
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose();
              CFDataWithBlockBufferNoCopy = 0;
            }
            goto LABEL_137;
          }
          v93 = *((_QWORD *)v184 + 8);
          v94 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
          if (v94)
          {
            v62 = v94(v93, *MEMORY[0x1E0CA3208], v170);
            if (!(_DWORD)v62)
              goto LABEL_126;
            goto LABEL_265;
          }
LABEL_135:
          CFDataWithBlockBufferNoCopy = 4294954514;
LABEL_136:
          v31 = v57;
LABEL_137:
          CFRelease((CFTypeRef)v50);
          goto LABEL_138;
        }
      }
LABEL_265:
      CFDataWithBlockBufferNoCopy = v62;
      goto LABEL_136;
    }
    v143 = SupportedProtocolVersions;
    v172 = v31;
    v144 = (uint64_t *)a3;
    v145 = *(_QWORD *)(a2 + 9472);
    v146 = FigGetAllocatorForMedia();
    v147 = (char *)v184;
    v148 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                            + 16)
                                                                                + 16);
    if (v148)
    {
      v149 = v148(v145, v146, v50, 1, v147 + 104);
      if (!(_DWORD)v149)
      {
        v150 = *(_QWORD *)(a2 + 264);
        a3 = (uint64_t)v144;
        if (v150)
        {
          v151 = *((_QWORD *)v184 + 13);
          v152 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
          if (!v152)
          {
LABEL_252:
            CFDataWithBlockBufferNoCopy = 4294954514;
            goto LABEL_253;
          }
          v153 = v152(v151, *MEMORY[0x1E0CA31C0], v150);
          if ((_DWORD)v153)
          {
LABEL_267:
            CFDataWithBlockBufferNoCopy = v153;
            goto LABEL_253;
          }
        }
        if (!v143)
          goto LABEL_238;
        v154 = *((_QWORD *)v184 + 13);
        v155 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
        if (v155)
        {
          v153 = v155(v154, *MEMORY[0x1E0CA3208], v143);
          if (!(_DWORD)v153)
          {
LABEL_238:
            CMNotificationCenterGetDefaultLocalCenter();
            v156 = FigNotificationCenterAddWeakListener();
            v31 = v172;
            if ((_DWORD)v156)
            {
              CFDataWithBlockBufferNoCopy = v156;
              if ((_DWORD)v156 != -12724)
                goto LABEL_137;
            }
            v157 = *(_QWORD *)a2;
            v158 = v184;
            *((_QWORD *)v184 + 14) = *(_QWORD *)a2;
            v159 = segPumpPrepareCryptorForKeyLoading(*((_QWORD *)v158 + 13), v157, 0, (_QWORD *)v158 + 17, (unsigned __int8 *)v158 + 128);
            if ((_DWORD)v159)
            {
              CFDataWithBlockBufferNoCopy = v159;
              goto LABEL_137;
            }
            SupportedProtocolVersions = v143;
            if (dword_1EE2A31E8)
            {
              LODWORD(v180) = 0;
              v179[0] = OS_LOG_TYPE_DEFAULT;
              v160 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              v161 = v180;
              if (os_log_type_enabled(v160, v179[0]))
                v162 = v161;
              else
                v162 = v161 & 0xFFFFFFFE;
              if (v162)
              {
                v163 = &stru_1E2FD85F8;
                v164 = *v144;
                if (*(_QWORD *)(a2 + 8760))
                  v163 = *(const __CFString **)(a2 + 8760);
                v165 = *(const __CFString **)(a2 + 9472);
                v166 = *((_QWORD *)v184 + 13);
                v167 = *((_QWORD *)v184 + 17);
                v168 = *((unsigned __int8 *)v184 + 128);
                *(_DWORD *)v185 = 136316674;
                *(_QWORD *)&v185[4] = "segPumpSetupCryptorForCryptKey";
                v186 = 2114;
                v187 = v163;
                v188 = 2048;
                v189 = v164;
                v190 = 2048;
                v191 = v165;
                v192 = 2048;
                v193 = v166;
                v194 = 2048;
                v195 = v167;
                v196 = 1024;
                v197 = v168;
                _os_log_send_and_compose_impl();
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose();
              v31 = v172;
              SupportedProtocolVersions = v143;
            }
            goto LABEL_74;
          }
          goto LABEL_267;
        }
        goto LABEL_252;
      }
      CFDataWithBlockBufferNoCopy = v149;
    }
    else
    {
      CFDataWithBlockBufferNoCopy = 4294954514;
    }
    a3 = (uint64_t)v144;
LABEL_253:
    v31 = v172;
    goto LABEL_137;
  }
  if (FigContentKeySpecifierGetKeySystem((uint64_t)a4) != 1
    || (v36 = v184, (v37 = *((_QWORD *)v184 + 8)) == 0))
  {
    if (a4 && FigContentKeySpecifierGetKeySystem((uint64_t)a4) == 2)
    {
      v35 = segPumpEnsureAndSetupBasicAESProtector(a2);
      if ((_DWORD)v35)
        goto LABEL_180;
      if (*((_QWORD *)v181[0] + 5))
      {
        if (!dword_1EE2A31E8)
          goto LABEL_100;
      }
      else
      {
        v67 = v24;
        v68 = v31;
        v69 = *(_QWORD *)(a2 + 248);
        v70 = FigGetAllocatorForMedia();
        v71 = (char *)v181[0];
        v72 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                              + 16)
                                                                                  + 104);
        if (!v72)
        {
          CFDataWithBlockBufferNoCopy = 4294954514;
          v31 = v68;
          v24 = v67;
          goto LABEL_181;
        }
        CFDataWithBlockBufferNoCopy = v72(v69, v70, 1, 0, v71 + 40);
        v50 = 0;
        if ((_DWORD)CFDataWithBlockBufferNoCopy)
        {
          v31 = v68;
          v24 = v67;
          goto LABEL_139;
        }
        v31 = v68;
        v24 = v67;
        if (!dword_1EE2A31E8)
          goto LABEL_139;
      }
      LODWORD(v180) = 0;
      v179[0] = OS_LOG_TYPE_DEFAULT;
      v73 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      v74 = v180;
      if (os_log_type_enabled(v73, v179[0]))
        v75 = v74;
      else
        v75 = v74 & 0xFFFFFFFE;
      if (v75)
      {
        v76 = *(const __CFString **)(a2 + 8760);
        if (!v76)
          v76 = &stru_1E2FD85F8;
        v77 = *(_QWORD *)a3;
        v78 = (const __CFString *)*((_QWORD *)v181[0] + 5);
        *(_DWORD *)v185 = 136315906;
        *(_QWORD *)&v185[4] = "segPumpSetupCryptorForCryptKey";
        v186 = 2114;
        v187 = v76;
        v188 = 2048;
        v189 = v77;
        v190 = 2048;
        v191 = v78;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      goto LABEL_100;
    }
    CFDataWithBlockBufferNoCopy = FigSignalErrorAt();
LABEL_138:
    v50 = 0;
    goto LABEL_139;
  }
  if (!*((_BYTE *)v184 + 88))
    goto LABEL_49;
  if (segPumpGetDecryptorState(v37) == 2)
  {
LABEL_100:
    v50 = 0;
    goto LABEL_140;
  }
  v36 = v184;
  v37 = *((_QWORD *)v184 + 8);
LABEL_49:
  v35 = segPumpPrepareCryptorForKeyLoading(v37, *((_QWORD *)v36 + 9), 1, (_QWORD *)v36 + 12, (unsigned __int8 *)v36 + 88);
  if ((_DWORD)v35)
  {
LABEL_180:
    CFDataWithBlockBufferNoCopy = v35;
    goto LABEL_181;
  }
  v38 = v184;
  if (!*((_BYTE *)v184 + 88))
    goto LABEL_112;
  if (dword_1EE2A31E8)
  {
    LODWORD(v180) = 0;
    v179[0] = OS_LOG_TYPE_DEFAULT;
    v39 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    v40 = v180;
    if (os_log_type_enabled(v39, v179[0]))
      v41 = v40;
    else
      v41 = v40 & 0xFFFFFFFE;
    if (v41)
    {
      v42 = *(const __CFString **)(a2 + 8760);
      if (!v42)
        v42 = &stru_1E2FD85F8;
      v43 = *(_QWORD *)a3;
      v44 = (const __CFString *)*((_QWORD *)v184 + 8);
      v45 = *((_QWORD *)v184 + 12);
      v46 = *((unsigned __int8 *)v184 + 88);
      *(_DWORD *)v185 = 136316418;
      *(_QWORD *)&v185[4] = "segPumpSetupCryptorForCryptKey";
      v186 = 2114;
      v187 = v42;
      v188 = 2048;
      v189 = v43;
      v190 = 2048;
      v191 = v44;
      v192 = 2048;
      v193 = v45;
      v194 = 1024;
      LODWORD(v195) = v46;
      _os_log_send_and_compose_impl();
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    v38 = v184;
  }
  v79 = *((_QWORD *)v38 + 13);
  if (!v79)
  {
LABEL_112:
    v50 = 1;
    goto LABEL_140;
  }
  v50 = 1;
  CFDataWithBlockBufferNoCopy = segPumpPrepareCryptorForKeyLoading(v79, *((_QWORD *)v38 + 14), 1, (_QWORD *)v38 + 17, (unsigned __int8 *)v38 + 128);
  if (!(_DWORD)CFDataWithBlockBufferNoCopy && dword_1EE2A31E8)
  {
    LODWORD(v180) = 0;
    v179[0] = OS_LOG_TYPE_DEFAULT;
    v80 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    v81 = v180;
    if (os_log_type_enabled(v80, v179[0]))
      v82 = v81;
    else
      v82 = v81 & 0xFFFFFFFE;
    if (v82)
    {
      v83 = *(const __CFString **)(a2 + 8760);
      if (!v83)
        v83 = &stru_1E2FD85F8;
      v84 = *(_QWORD *)a3;
      v85 = (const __CFString *)*((_QWORD *)v184 + 13);
      v86 = *((_QWORD *)v184 + 17);
      v87 = *((unsigned __int8 *)v184 + 128);
      *(_DWORD *)v185 = 136316418;
      *(_QWORD *)&v185[4] = "segPumpSetupCryptorForCryptKey";
      v186 = 2114;
      v187 = v83;
      v188 = 2048;
      v189 = v84;
      v190 = 2048;
      v191 = v85;
      v192 = 2048;
      v193 = v86;
      v194 = 1024;
      LODWORD(v195) = v87;
      _os_log_send_and_compose_impl();
    }
    v50 = 1;
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    goto LABEL_140;
  }
LABEL_139:
  if ((_DWORD)CFDataWithBlockBufferNoCopy)
  {
LABEL_181:
    v109 = 0;
    goto LABEL_199;
  }
LABEL_140:
  v104 = v50 == 0;
  if ((_DWORD)v50)
    *(_BYTE *)(v174 + 144) = 0;
  if (!*(_QWORD *)(a2 + 296))
    goto LABEL_161;
  *(_QWORD *)&v198[0] = 0;
  v184 = 0;
  *(_QWORD *)v185 = 0;
  v181[0] = 0;
  v105 = segPumpGetCryptKeyCommonData(a4, v198, v185);
  if ((_DWORD)v105)
    goto LABEL_259;
  v106 = (const void *)FigContentKeySpecifierGetIdentifier((uint64_t)a4);
  if (!v106)
  {
    v105 = FigSignalErrorAt();
    goto LABEL_259;
  }
  v105 = FigStreamingCacheCopyCryptKey(*(_QWORD *)(a2 + 296), v106, v181);
  if ((_DWORD)v105)
  {
LABEL_259:
    CFDataWithBlockBufferNoCopy = v105;
    v109 = 0;
    goto LABEL_152;
  }
  if (!v181[0])
    goto LABEL_161;
  FigGetAllocatorForMedia();
  CFDataWithBlockBufferNoCopy = FigCreateCFDataWithBlockBufferNoCopy();
  v107 = v184;
  if ((_DWORD)CFDataWithBlockBufferNoCopy)
  {
    v109 = 0;
    if (v184)
LABEL_150:
      CFRelease(v107);
  }
  else
  {
    v108 = *(_QWORD *)v185;
    *(_WORD *)(*(_QWORD *)v185 + 144) = 1;
    *(_BYTE *)(v108 + 146) = 1;
    if (v107)
    {
      v109 = CFRetain(v107);
      v107 = v184;
      if (!v184)
        goto LABEL_152;
      goto LABEL_150;
    }
    v109 = 0;
    CFDataWithBlockBufferNoCopy = 0;
  }
LABEL_152:
  if (v181[0])
    CFRelease(v181[0]);
  if (!(_DWORD)CFDataWithBlockBufferNoCopy)
  {
    if (v109)
    {
      v110 = segPumpCryptSetKey(v173, a2, a3, a4, *(_QWORD *)(v174 + 80), 1, v109, 0);
      if ((_DWORD)v110)
      {
LABEL_198:
        CFDataWithBlockBufferNoCopy = v110;
        goto LABEL_199;
      }
      if (*(_QWORD *)(v174 + 104))
      {
        v111 = segPumpCryptSetKey(v173, a2, a3, a4, *(_QWORD *)(v174 + 120), 1, v109, 0);
        CFDataWithBlockBufferNoCopy = v111;
        if ((_DWORD)v50 || (_DWORD)v111)
          goto LABEL_199;
        goto LABEL_197;
      }
      CFDataWithBlockBufferNoCopy = 0;
LABEL_196:
      if ((_DWORD)v50)
        goto LABEL_199;
LABEL_197:
      v110 = segPumpContinueIfCryptKeyResponseWasAlreadySet(v173, a2, a3, a4, v174);
      goto LABEL_198;
    }
LABEL_161:
    if (segPumpShouldRequestURLAsHTTPURL(a2, v24))
    {
      if (a4 && FigContentKeySpecifierGetKeySystem((uint64_t)a4) == 2)
      {
        v112 = *(_QWORD *)(a2 + 56);
        v113 = *(const void **)(a3 + 552);
        v114 = *(_QWORD *)(a2 + 216);
        v115 = *(_QWORD *)(a2 + 240);
        v116 = *(_QWORD *)a2;
        memset(v198, 0, sizeof(v198));
        v200 = 0u;
        v201 = 0u;
        v199 = 0x800000000;
        v202 = 0;
        CFDataWithBlockBufferNoCopy = segPumpCreateHTTPRequest(a2, v112, (_QWORD *)a3, v113, v31, v24, v114, v115, 0.794, 0, 12, 1u, v198, 0, 0, (uint64_t)segPumpCryptMemoryRequestCallback, (uint64_t)segPumpCryptFileReadCallback, v116, 0,
                                        a3 + 544);
        if (dword_1EE2A31E8)
        {
          v171 = v24;
          v117 = v31;
          LODWORD(v181[0]) = 0;
          LOBYTE(v184) = 0;
          v118 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          v119 = v181[0];
          if (os_log_type_enabled(v118, (os_log_type_t)v184))
            v120 = v119;
          else
            v120 = v119 & 0xFFFFFFFE;
          if (v120)
          {
            v121 = *(const __CFString **)(a2 + 8760);
            if (!v121)
              v121 = &stru_1E2FD85F8;
            v122 = *(_QWORD *)a3;
            v123 = CFSTR("[]");
            if (*(_BYTE *)(a2 + 339))
              v123 = a4;
            *(_DWORD *)v185 = 136316162;
            *(_QWORD *)&v185[4] = "segPumpSendCryptKeyRequest";
            v186 = 2114;
            v187 = v121;
            v188 = 2048;
            v189 = v122;
            v190 = 2114;
            v191 = v123;
            v192 = 1024;
            LODWORD(v193) = CFDataWithBlockBufferNoCopy;
            _os_log_send_and_compose_impl();
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose();
          v31 = v117;
          v24 = v171;
        }
        goto LABEL_189;
      }
      segPumpAppendErrorLogEntry(v173, a2, a3, (const __CFURL **)(a3 + 544), -12885, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Cannot fetch wrapped key via http"), 0, 0, 3u, 3u);
      v35 = FigSignalErrorAt();
      goto LABEL_180;
    }
    *(_QWORD *)&v198[0] = 0;
    *(_QWORD *)v185 = 0;
    if (segPumpGetCryptKeyCommonData(a4, v198, v185))
      goto LABEL_187;
    if (*(_QWORD *)(*(_QWORD *)v185 + 64))
    {
      if (*(_BYTE *)(*(_QWORD *)v185 + 88))
        goto LABEL_184;
      if (!*(_QWORD *)(*(_QWORD *)v185 + 104))
        goto LABEL_187;
    }
    else if (!*(_QWORD *)(*(_QWORD *)v185 + 104))
    {
      goto LABEL_184;
    }
    if (!*(_BYTE *)(*(_QWORD *)v185 + 128))
    {
LABEL_187:
      CFDataWithBlockBufferNoCopy = 0;
      goto LABEL_189;
    }
LABEL_184:
    CFDataWithBlockBufferNoCopy = segPumpRequestCustomURLForCryptKey(a2, a3, a4, v50);
    if ((_DWORD)CFDataWithBlockBufferNoCopy)
      goto LABEL_181;
    v104 = 1;
LABEL_189:
    v109 = 0;
    if (v104 && !(_DWORD)CFDataWithBlockBufferNoCopy)
    {
      v124 = *(_DWORD *)(a2 + 8);
      v125 = 2 * v124;
      if ((2 * v124) <= 3)
        v125 = 3;
      v126 = (double)v125;
      if (!v124)
        v126 = 20.0;
      FigHTTPCreateTimer(*(const void **)a2, (uint64_t)segPumpCryptKeyTimeoutHandler, *(NSObject **)(a2 + 64), (dispatch_object_t *)(a3 + 640), v126);
      v109 = 0;
    }
    goto LABEL_196;
  }
LABEL_199:
  if (v24)
    CFRelease(v24);
  if (v109)
    CFRelease(v109);
  if (v31)
  {
    v127 = (CFTypeRef)v31;
LABEL_226:
    CFRelease(v127);
  }
  return CFDataWithBlockBufferNoCopy;
}

void segPumpGetIndexFileRefreshTimestamp(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5;
  uint64_t v7;
  const __CFArray *MediaSegmentSpecifiers;
  unsigned int v10;
  double v11;
  uint64_t v12;
  uint64_t v13;

  v5 = a3;
  v13 = a3;
  v7 = *(_QWORD *)(a2 + 56);
  if (v7)
  {
    if (!*(_BYTE *)(a2 + 1168))
    {
      MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v7);
      if (MediaSegmentSpecifiers)
      {
        if (CFArrayGetCount(MediaSegmentSpecifiers) >= 1)
        {
          if (FigMediaPlaylistHasEndTag(*(_QWORD *)(a2 + 56)))
          {
            v10 = *(_DWORD *)(a1 + 8);
            v11 = *(double *)(a1 + 344) - (double)v10;
            v12 = *(_DWORD *)(a1 + 7944) * v10;
            if ((uint64_t)v11 > v12)
              v12 = (uint64_t)v11;
            v5 = *(_QWORD *)(a2 + 1048) + 1000000000 * v12;
          }
          else if ((*(_DWORD *)(a2 + 160) & 0xFFFFFFFE) != 2 && !*(_BYTE *)(a1 + 328))
          {
            segPumpGetLiveIndexRefreshTimestamp(a1, a2, &v13);
            v5 = v13;
          }
        }
      }
    }
  }
  *a4 = v5;
}

uint64_t segPumpSendIndexFileRequest(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _BYTE *v5;
  uint64_t UpTimeNanoseconds;
  const void *v7;
  const void *v8;
  unsigned int v9;
  const void *v10;
  const void *v11;
  const void *v12;
  uint64_t v13;
  const __CFString *PathwayID;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const __CFAllocator *v18;
  __CFArray *v19;
  __CFArray *Mutable;
  CFIndex v21;
  const __CFArray *MediaSegmentSpecifiers;
  const void *v23;
  const void *v24;
  uint64_t v25;
  int IsFragment;
  uint64_t MediaSequence;
  const __CFArray *Count;
  CFIndex v29;
  const __CFURL *v30;
  const __CFArray *RenditionReportSpecifiers;
  const __CFArray *v32;
  const void *ValueAtIndex;
  const __CFURL *URL;
  const void *v35;
  uint64_t LastMediaSequenceNumber;
  int LastPart;
  CFIndex v38;
  _BOOL4 v39;
  const __CFAllocator *v41;
  uint64_t v42;
  const __CFString *v43;
  const __CFAllocator *v44;
  uint64_t HTTPRequest;
  int v46;
  uint64_t v47;
  uint64_t v48;
  const void *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t LastValue;
  uint64_t v56;
  const __CFArray *PartialSegments;
  const __CFAllocator *AllocatorForMedia;
  uint64_t v59;
  _BOOL4 v60;
  uint64_t v61;
  const void *v62;
  const void *v64;
  _BYTE *v65;
  CFIndex v66;
  uint64_t v67;
  __int128 v68[4];
  uint64_t v69;
  __int128 v70;
  __int128 v71;
  uint64_t v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  v5 = (_BYTE *)(a2 + 7999);
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v66 = 0;
  v67 = -1;
  if (v5[685] && *(_DWORD *)(a3 + 160) == 1)
  {
    *(_DWORD *)(a3 + 160) = 2;
    *(_OWORD *)(a3 + 168) = 0u;
    *(_OWORD *)(a3 + 184) = 0u;
    *(_DWORD *)(a3 + 200) = 0;
  }
  v7 = *(const void **)(a3 + 280);
  if (v7)
  {
    v8 = *(const void **)(a3 + 272);
    *(_QWORD *)(a3 + 272) = 0;
    *(_QWORD *)(a3 + 280) = 0;
  }
  else
  {
    v8 = 0;
  }
  v65 = v5;
  if (*v5)
    v9 = 519;
  else
    v9 = 7;
  v10 = *(const void **)(a3 + 416);
  v11 = *(const void **)(a3 + 424);
  v12 = *(const void **)(a3 + 520);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(a3 + 520) = 0;
  }
  *(_QWORD *)(a3 + 496) = 0;
  *(_QWORD *)(a3 + 416) = 0;
  *(_QWORD *)(a3 + 424) = 0;
  if (*(_BYTE *)(a2 + 320))
  {
    v13 = *(_QWORD *)(a2 + 8144);
    if (v13)
      PathwayID = FigAlternateGetPathwayID(*(_QWORD *)(v13 + 8));
    else
      PathwayID = CFSTR(".");
    v15 = FigCFHTTPCopyURLAndInheritQueyComponentIfNotPresent(*(const __CFURL **)(a2 + 312), (CFURLRef *)(a3 + 8));
    if ((_DWORD)v15)
    {
      HTTPRequest = v15;
      Mutable = 0;
      goto LABEL_88;
    }
    segPumpStreamUpdateIndexFile((_QWORD *)a3, *(CFTypeRef *)(a3 + 8), *(CFTypeRef *)(a3 + 8), *(CFTypeRef *)(a3 + 24), *(CFTypeRef *)(a3 + 32), PathwayID);
  }
  if (*(_BYTE *)(a3 + 876)
    && UpTimeNanoseconds - *(_QWORD *)(a3 + 1056) > 1000000000
                                                  * (unint64_t)(3 * *(_DWORD *)(a2 + 8)))
  {
    *(_BYTE *)(a3 + 876) = 0;
  }
  *(_QWORD *)(a3 + 440) = UpTimeNanoseconds;
  if (!*(_DWORD *)(a3 + 472))
    *(_QWORD *)(a3 + 432) = UpTimeNanoseconds;
  *(_QWORD *)(a3 + 1048) = UpTimeNanoseconds;
  *(_BYTE *)(a3 + 867) = 0;
  *(_QWORD *)(a3 + 360) = -1;
  *(_QWORD *)(a3 + 368) = -1;
  v16 = *(_QWORD *)(a3 + 56);
  if (!v16)
    goto LABEL_139;
  if (*(_DWORD *)(a3 + 160) == 3)
  {
    FigStreamPlaylistPredictMediaSequenceAndPartForAdvance(v16, &v67, &v66, *(double *)(a3 + 192));
    v17 = v67;
    goto LABEL_26;
  }
  MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v16);
  if (!MediaSegmentSpecifiers
    || CFArrayGetCount(MediaSegmentSpecifiers) < 1
    || !*(_BYTE *)(a2 + 328)
    || (*(_DWORD *)(a3 + 160) & 0xFFFFFFFE) != 4)
  {
LABEL_139:
    if (*(_BYTE *)(a2 + 328) && *(_BYTE *)(a3 + 862) && *(_BYTE *)(a3 + 864))
    {
      Mutable = *(__CFArray **)(*(_QWORD *)(a2 + 16 * *(_QWORD *)a3 + 384) + 56);
      if (!Mutable)
        goto LABEL_56;
      v62 = v11;
      v29 = 0;
      v30 = *(const __CFURL **)(a3 + 16);
      v64 = v8;
      do
      {
        RenditionReportSpecifiers = (const __CFArray *)FigMediaPlaylistGetRenditionReportSpecifiers(*(_QWORD *)(*(_QWORD *)(a2 + 16 * *(_QWORD *)a3 + 384) + 56));
        if (RenditionReportSpecifiers)
          RenditionReportSpecifiers = (const __CFArray *)CFArrayGetCount(RenditionReportSpecifiers);
        if (v29 >= (uint64_t)RenditionReportSpecifiers)
        {
          v35 = v7;
          ValueAtIndex = 0;
          v61 = -1;
          v60 = 1;
          v39 = 1;
          LastMediaSequenceNumber = -1;
          goto LABEL_102;
        }
        v32 = (const __CFArray *)FigMediaPlaylistGetRenditionReportSpecifiers(*(_QWORD *)(*(_QWORD *)(a2 + 16 * *(_QWORD *)a3 + 384)
                                                                                        + 56));
        ValueAtIndex = CFArrayGetValueAtIndex(v32, v29);
        URL = (const __CFURL *)FigRenditionReportSpecifierGetURL((uint64_t)ValueAtIndex);
        ++v29;
      }
      while (!segPumpRenditionReportURLsAreEqual(v30, URL));
      v35 = v7;
      LastMediaSequenceNumber = FigRenditionReportSpecifierGetLastMediaSequenceNumber((uint64_t)ValueAtIndex);
      LastPart = FigRenditionReportSpecifierGetLastPart((uint64_t)ValueAtIndex);
      v38 = LastPart;
      v39 = LastMediaSequenceNumber == -1;
      if (LastMediaSequenceNumber != -1 && LastPart != -1)
      {
        v7 = v35;
        v8 = v64;
        if ((LastMediaSequenceNumber & 0x8000000000000000) == 0)
          goto LABEL_114;
LABEL_129:
        Mutable = 0;
        v11 = v62;
LABEL_130:
        if (ValueAtIndex && *(_BYTE *)(a2 + 329) && *(_DWORD *)(a3 + 160) != 4)
          *(_DWORD *)(a3 + 160) = 4;
        goto LABEL_56;
      }
      v60 = LastPart == -1;
      v61 = LastPart;
LABEL_102:
      FigMediaPlaylistGetMediaSegmentSpecifiers((uint64_t)Mutable);
      LastValue = FigCFArrayGetLastValue();
      if (LastValue)
      {
        v56 = LastValue;
        if (v39)
          LastMediaSequenceNumber = FigMediaSegmentSpecifierGetMediaSequence(LastValue);
        v7 = v35;
        if (v60)
        {
          PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments(v56);
          v8 = v64;
          if (PartialSegments)
          {
            v38 = CFArrayGetCount(PartialSegments) - 1;
            if ((LastMediaSequenceNumber & 0x8000000000000000) == 0)
              goto LABEL_114;
            goto LABEL_129;
          }
          v38 = -1;
          if (LastMediaSequenceNumber < 0)
            goto LABEL_129;
LABEL_114:
          AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
          Mutable = CFArrayCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B378]);
          CFArrayAppendValue(Mutable, CFSTR("_HLS_msn="));
          FigCFArrayAppendInt64();
          if ((v38 & 0x8000000000000000) == 0)
          {
            CFArrayAppendValue(Mutable, CFSTR("_HLS_part="));
            FigCFArrayAppendInt64();
          }
          if (ValueAtIndex || !Mutable)
          {
            v11 = v62;
            if (Mutable)
              v9 |= 0x400u;
            goto LABEL_130;
          }
          v11 = v62;
          if (!*(_BYTE *)(a2 + 329))
          {
            v9 |= 0x400u;
            goto LABEL_56;
          }
          *(_BYTE *)(a2 + 331) = 1;
          v59 = segPumpSetupBlockingReload(a1, a2, *(_QWORD *)(a2 + 16 * *(_QWORD *)a3 + 384));
          if (!(_DWORD)v59)
            goto LABEL_56;
          goto LABEL_136;
        }
      }
      else
      {
        v7 = v35;
      }
      v8 = v64;
      v38 = v61;
      if ((LastMediaSequenceNumber & 0x8000000000000000) == 0)
        goto LABEL_114;
      goto LABEL_129;
    }
LABEL_55:
    Mutable = 0;
    goto LABEL_56;
  }
  v23 = v8;
  v24 = v7;
  FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a3 + 56));
  v25 = FigCFArrayGetLastValue();
  IsFragment = FigMediaSegmentSpecifierIsFragment(v25);
  MediaSequence = FigMediaSegmentSpecifierGetMediaSequence(v25);
  v17 = MediaSequence;
  if (IsFragment)
  {
    v67 = MediaSequence;
    Count = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments(v25);
    if (Count)
      Count = (const __CFArray *)CFArrayGetCount(Count);
    v7 = v24;
    v66 = (CFIndex)Count;
  }
  else
  {
    v17 = MediaSequence + 1;
    v67 = MediaSequence + 1;
    if (*(double *)(a2 + 16) == 0.0)
      v66 = -1;
    v7 = v24;
  }
  v8 = v23;
  FigMediaSegmentSpecifierGetPartialSegments(v25);
LABEL_26:
  v9 |= 0x400u;
  if (v17 < 0)
    goto LABEL_55;
  v18 = (const __CFAllocator *)FigGetAllocatorForMedia();
  v19 = CFArrayCreateMutable(v18, 0, MEMORY[0x1E0C9B378]);
  Mutable = v19;
  if (!v19)
  {
    v59 = FigSignalErrorAt();
LABEL_136:
    HTTPRequest = v59;
    goto LABEL_88;
  }
  CFArrayAppendValue(v19, CFSTR("_HLS_msn="));
  FigCFArrayAppendInt64();
  if ((v66 & 0x8000000000000000) == 0)
  {
    CFArrayAppendValue(Mutable, CFSTR("_HLS_part="));
    FigCFArrayAppendInt64();
  }
  if ((v67 & 0x8000000000000000) == 0)
  {
    v21 = v66;
    *(_QWORD *)(a3 + 360) = v67;
    *(_QWORD *)(a3 + 368) = v21;
  }
LABEL_56:
  if (*(_BYTE *)(a3 + 876))
  {
    if (Mutable
      || (v41 = (const __CFAllocator *)FigGetAllocatorForMedia(),
          (Mutable = CFArrayCreateMutable(v41, 0, MEMORY[0x1E0C9B378])) != 0))
    {
      v42 = *(_QWORD *)(a3 + 56);
      v43 = CFSTR("YES");
      if (v42 && FigMediaPlaylistCanSkipDATERANGES(v42))
        v43 = CFSTR("v2");
      CFArrayAppendValue(Mutable, CFSTR("_HLS_skip="));
      CFArrayAppendValue(Mutable, v43);
    }
  }
  if (*(_QWORD *)(a2 + 232))
  {
    if (!v65[5] && !*(_QWORD *)(a3 + 56) && !*(_QWORD *)a3)
    {
      if (Mutable
        || (v44 = (const __CFAllocator *)FigGetAllocatorForMedia(),
            (Mutable = CFArrayCreateMutable(v44, 0, MEMORY[0x1E0C9B378])) != 0))
      {
        CFArrayAppendValue(Mutable, CFSTR("_HLS_primary_id="));
        CFArrayAppendValue(Mutable, *(const void **)(a2 + 232));
      }
    }
  }
  if (*(_BYTE *)(a3 + 858) || !segPumpShouldRequestURLAsHTTPURL(a2, *(const __CFURL **)(a3 + 16)))
  {
    HTTPRequest = segPumpPostIndexFileRequest(a2, a3, Mutable, v9 >> 10);
    if (!dword_1EE2A31E8)
      goto LABEL_84;
  }
  else
  {
    if (!v65[457])
    {
      v65[457] = 1;
      AttemptNetworkMonitorSetup(a2, *(_QWORD *)(a3 + 16));
    }
    if (*(_QWORD *)(a3 + 56) || *(_QWORD *)a3)
      v46 = 11;
    else
      v46 = 10;
    v47 = *(_QWORD *)(a2 + 56);
    if (v7)
      v48 = (uint64_t)v7;
    else
      v48 = (uint64_t)v11;
    v49 = *(const void **)(a3 + 16);
    v50 = *(_QWORD *)(a2 + 216);
    v51 = *(_QWORD *)(a2 + 240);
    v52 = *(_QWORD *)a2;
    memset(v68, 0, sizeof(v68));
    v69 = 0x100000000;
    v70 = 0u;
    v71 = 0u;
    v72 = 0;
    HTTPRequest = segPumpCreateHTTPRequest(a2, v47, (_QWORD *)a3, v8, v48, v49, v50, v51, 0.794, Mutable, v46, v9, v68, 0, 0, 0, (uint64_t)segPumpIndexFileReadCallback, v52, 0,
                    a3 + 408);
    if (!dword_1EE2A31E8)
      goto LABEL_84;
  }
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
  os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
  fig_log_call_emit_and_clean_up_after_send_and_compose();
LABEL_84:
  if (*(_BYTE *)(a3 + 866) || !v65[3] && *(_QWORD *)(a2 + 8096))
    segPumpScheduleIndexFileLongDownloadTimer(a2, a3);
  *(_BYTE *)(a3 + 1168) = 0;
  *(_BYTE *)(a3 + 400) = 0;
  FigHTTPStopAndReleaseTimer((dispatch_object_t *)(a3 + 392));
LABEL_88:
  if (v8)
    CFRelease(v8);
  if (v7)
    CFRelease(v7);
  if (v10)
    CFRelease(v10);
  if (v11)
    CFRelease(v11);
  if (Mutable)
    CFRelease(Mutable);
  return HTTPRequest;
}

void segPumpGetLiveIndexRefreshTimestamp(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  unsigned int v5;
  uint64_t v6;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v8;
  uint64_t v9;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = (uint64_t)(segPumpGetDurationOfLastMediaSegment(*(_QWORD *)(a2 + 56)) * 1000000000.0);
  if (dword_1EE2A31E8 >= 2)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  v8 = 500000000 * v5;
  if (*(_DWORD *)(a2 + 384))
  {
    v9 = *(_QWORD *)(a2 + 1048);
  }
  else
  {
    v9 = *(_QWORD *)(a2 + 1048);
    if (v8 < v6)
      v8 = 1000000000 * v5;
  }
  *a3 = v9 + v8;
}

uint64_t segPumpSetupBlockingReload(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  _BOOL4 IsCompliantWithBlockingReloadPolicy;
  BOOL v8;
  int v9;
  uint64_t v10;
  void (*v11)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v13;
  void (*v14)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v20 = 0;
  if (!*(_QWORD *)(a3 + 56))
    return 0;
  v6 = *(unsigned __int8 *)(a2 + 329);
  IsCompliantWithBlockingReloadPolicy = segPumpPlaylistIsCompliantWithBlockingReloadPolicy(a3, &v20);
  *(_BYTE *)(a2 + 328) = IsCompliantWithBlockingReloadPolicy;
  if (*(_BYTE *)(a2 + 329))
    v8 = 1;
  else
    v8 = !IsCompliantWithBlockingReloadPolicy;
  if (v8)
  {
    if (*(_BYTE *)(a2 + 329))
    {
      if (!segPumpCanContinueWithLowLatencyMode(a1, a2, a3, &v20))
      {
        *(_BYTE *)(a2 + 329) = 0;
        *(_QWORD *)(a2 + 16) = 0;
        *(_QWORD *)(a2 + 7952) = 0;
        segPumpReadyNotification((_QWORD *)a2, CFSTR("FBP_PrefersConcurrentSwitchChanged"), 0);
        v10 = segPumpHandleLowLatencySetupError(a1, a2, a3, v20);
        v13 = *(_QWORD *)(a2 + 9048);
        if (!v13)
          goto LABEL_33;
        v14 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                          + 56);
        if (!v14)
          goto LABEL_33;
        v15 = v13;
        v16 = 3;
LABEL_29:
        v14(v15, CFSTR("bytePumpStats"), CFSTR("LLState"), v16, 0);
        goto LABEL_33;
      }
      v9 = *(unsigned __int8 *)(a2 + 328);
    }
    else
    {
      v9 = IsCompliantWithBlockingReloadPolicy;
    }
    if (v9 != FigMediaPlaylistDoesServerSupportsBlockingReload(*(_QWORD *)(a3 + 56)))
    {
      if (FigMediaPlaylistHasEndTag(*(_QWORD *)(a3 + 56)))
      {
        if (dword_1EE2A31E8)
        {
          os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
      }
      else
      {
        v18 = *(unsigned __int8 *)(a2 + 328);
        if (v18 != FigMediaPlaylistDoesServerSupportsBlockingReload(*(_QWORD *)(a3 + 56)))
          return FigSignalErrorAt();
      }
    }
    goto LABEL_32;
  }
  if (*(_DWORD *)(a3 + 160) == 5)
  {
LABEL_32:
    v10 = 0;
    goto LABEL_33;
  }
  if (!segPumpCanContinueWithLowLatencyMode(a1, a2, a3, &v20))
  {
    if (FigMediaPlaylistGetPartTargetDuration(*(_QWORD *)(a3 + 56)) > 0.0)
    {
      v10 = segPumpHandleLowLatencySetupError(a1, a2, a3, v20);
      v17 = *(_QWORD *)(a2 + 9048);
      if (!v17)
        goto LABEL_33;
      v14 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                        + 56);
      if (!v14)
        goto LABEL_33;
      v15 = v17;
      v16 = 2;
      goto LABEL_29;
    }
    goto LABEL_32;
  }
  *(_BYTE *)(a2 + 329) = 1;
  segPumpReadyNotification((_QWORD *)a2, CFSTR("FBP_PrefersConcurrentSwitchChanged"), 0);
  *(_DWORD *)(a2 + 7944) = FigRCLGetNumberWithDefault(*(const __CFDictionary **)(a2 + 9128), CFSTR("minReserveSegments"));
  if (segPumpEnsureCMCDHeaderVendor(a2))
    FigCMCDHeaderVendorSetStreamingFormat(*(_QWORD *)(a2 + 9576), 1);
  v10 = *(_QWORD *)(a2 + 9048);
  if (v10)
  {
    v11 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v11)
      v11(v10, CFSTR("bytePumpStats"), CFSTR("LLState"), 1, 0);
    goto LABEL_32;
  }
LABEL_33:
  if (v6 != *(unsigned __int8 *)(a2 + 329))
  {
    segPumpSetPartTargetDuration(a2, *(_QWORD *)(a3 + 56));
    *(_QWORD *)(a2 + 7952) = 0;
    segPumpSetActiveHoldBack(a2, *(_QWORD *)(a3 + 56));
    return 0;
  }
  return v10;
}

void AttemptNetworkMonitorSetup(_QWORD *a1, const void *a2)
{
  const __CFAllocator *AllocatorForMedia;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v6;
  CFTypeRef *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  CFTypeRef v11;
  uint64_t (*v12)(CFTypeRef);
  uint64_t v13;
  const void *v14;

  if (!a1[1055] && FigCFHTTPIsHTTPBasedURL((const __CFURL *)a2))
  {
    AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v6 = Mutable;
      v7 = (CFTypeRef *)(a1 + 1055);
      FigCFDictionarySetValueFromKeyInDict();
      v8 = (const void *)a1[1110];
      if (v8)
        CFDictionarySetValue(v6, CFSTR("kFigNetworkPathEvaluatorCreateOption_InterfaceName"), v8);
      v9 = (const void *)a1[1111];
      if (v9)
        CFDictionarySetValue(v6, CFSTR("kFigNetworkPathEvaluatorCreateOption_ClientAuditToken"), v9);
      if (!FigNetworkPathEvaluatorCreate(a1[7], a2, v6, a1[8], *a1, segPumpUpdatePathEvaluation, a1 + 1055))
      {
        v10 = (const void *)a1[1056];
        if (v10)
        {
          CFRelease(v10);
          a1[1056] = 0;
        }
        v11 = *v7;
        v12 = *(uint64_t (**)(CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
        if (v12)
          v13 = v12(v11);
        else
          v13 = 0;
        a1[1056] = v13;
        segPumpUpdateNetworkCostHasHighSpeedHighPower((uint64_t)a1);
        v14 = (const void *)a1[1054];
        a1[1054] = a2;
        if (a2)
          CFRetain(a2);
        if (v14)
          CFRelease(v14);
        if (FigNetworkPathInformationIsHostLocal())
        {
          if (*v7)
          {
            CFRelease(*v7);
            *v7 = 0;
          }
        }
      }
      CFRelease(v6);
    }
    else
    {
      FigSignalErrorAt();
    }
  }
}

void segPumpIndexFileReadCallback(uint64_t a1, int a2, uint64_t a3, OpaqueCMBlockBuffer *a4, size_t a5, size_t a6, char a7, uint64_t a8)
{
  uint64_t v16;
  uint64_t UpTimeNanoseconds;
  uint64_t v18;
  uint64_t AllocatorForMedia;
  void (*v20)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t (*v24)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  int InterfaceTypeFromCFNStats;
  uint64_t v26;
  OpaqueCMBlockBuffer *v27;
  const __CFAllocator *v28;
  uint64_t Empty;
  const void *v30;
  uint64_t v31;
  const void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  const void *v37;
  const void *v38;
  const void *v39;
  const void *v40;
  const void *v41;
  uint64_t v42;
  unsigned int (*v43)(uint64_t, _QWORD, uint64_t *, uint64_t *);
  uint64_t v44;
  uint64_t v45;
  BOOL v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  void (*v52)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, CFTypeRef *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v53;
  void (*v54)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v55;
  unint64_t v56;
  void (*v57)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v58;
  unint64_t v59;
  void (*v60)(uint64_t, __CFString *, __CFString *, unint64_t, uint64_t);
  __CFString *v61;
  void (*v62)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v63;
  unint64_t v64;
  void (*v65)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v66;
  const __CFArray *MediaSegmentSpecifiers;
  uint64_t v68;
  char v69;
  CFTypeRef v70;
  uint64_t v71;
  _QWORD *v72;
  uint64_t v73;
  uint64_t v74;
  double v75;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v77;
  unsigned int v78;
  const __CFString *v79;
  uint64_t v80;
  NSObject *v81;
  unsigned int v82;
  unsigned int v83;
  const __CFString *v84;
  double v85;
  uint64_t v86;
  uint64_t v87;
  unsigned __int8 v88;
  CFTypeRef v89;
  CFTypeRef v90;
  CFTypeRef v91;
  int v92[2];
  CFTypeRef v93;
  os_log_type_t type;
  unsigned int v95;
  os_log_type_t v96[8];
  double v97;
  int v98;
  const char *v99;
  __int16 v100;
  const __CFString *v101;
  __int16 v102;
  double v103;
  __int16 v104;
  uint64_t v105;
  CFTypeRef cf[17];

  cf[16] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  *(_QWORD *)v92 = 0;
  v93 = 0;
  v90 = 0;
  v91 = 0;
  v89 = 0;
  v88 = 0;
  FigRetainProxyRetain();
  if (!segPumpLockAndCopyPumpFromRetainProxy(a3, &v93, (uint64_t *)v92))
  {
    if ((v16 = *(_QWORD *)(*(_QWORD *)v92 + 384), *(_QWORD *)(v16 + 424) == a1) && *(_DWORD *)(v16 + 488) == a2
      || (v16 = *(_QWORD *)(*(_QWORD *)v92 + 400), *(_QWORD *)(v16 + 424) == a1) && *(_DWORD *)(v16 + 488) == a2
      || (v16 = *(_QWORD *)(*(_QWORD *)v92 + 416), *(_QWORD *)(v16 + 424) == a1) && *(_DWORD *)(v16 + 488) == a2
      || (v16 = *(_QWORD *)(*(_QWORD *)v92 + 392), *(_QWORD *)(v16 + 424) == a1) && *(_DWORD *)(v16 + 488) == a2
      || (v16 = *(_QWORD *)(*(_QWORD *)v92 + 408), *(_QWORD *)(v16 + 424) == a1) && *(_DWORD *)(v16 + 488) == a2
      || (v16 = *(_QWORD *)(*(_QWORD *)v92 + 424), *(_QWORD *)(v16 + 424) == a1) && *(_DWORD *)(v16 + 488) == a2)
    {
      if (a1)
      {
        *(_BYTE *)(v16 + 867) = 0;
        if (!*(_QWORD *)(v16 + 456))
        {
          UpTimeNanoseconds = FigGetUpTimeNanoseconds();
          v18 = UpTimeNanoseconds - *(_QWORD *)(v16 + 432);
          *(_QWORD *)(v16 + 456) = UpTimeNanoseconds;
          *(_QWORD *)(v16 + 464) = v18;
        }
        AllocatorForMedia = FigGetAllocatorForMedia();
        v20 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                             + 8)
                                                                                 + 48);
        if (v20)
          v20(a1, CFSTR("FHRP_CFNetworkTimingData"), AllocatorForMedia, &v89);
        if ((_DWORD)a8)
        {
          FigCreateErrorForOSStatus(a8, (CFErrorRef *)&v90);
          v21 = segPumpHandleIndexFileNetworkError(v93, v16, 0, a8, CFSTR("CoreMediaErrorDomain"), 0);
LABEL_21:
          v22 = v21;
          goto LABEL_129;
        }
        if ((a7 & 1) != 0)
        {
          cf[0] = 0;
          v23 = FigGetAllocatorForMedia();
          v24 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 8)
                                                                                      + 48);
          if (v24)
          {
            v22 = v24(a1, CFSTR("FHRP_HTTPFinalURL"), v23, cf);
            segPumpRTCReportingUpdatePreLTKUStats_HeadersAvailable(*(uint64_t *)v92, a1);
            if (!(_DWORD)v22)
              segPumpStreamUpdateIndexFileURLWithResponse(*(uint64_t *)v92, v16, cf[0]);
          }
          else
          {
            segPumpRTCReportingUpdatePreLTKUStats_HeadersAvailable(*(uint64_t *)v92, a1);
            v22 = 4294954514;
          }
          if (v89)
          {
            InterfaceTypeFromCFNStats = FigNetworkInterfaceGetInterfaceTypeFromCFNStats((uint64_t)v89);
            v26 = *(_QWORD *)v92;
            *(_DWORD *)(*(_QWORD *)v92 + 8460) = InterfaceTypeFromCFNStats;
            segPumpUpdateNetworkCostHasHighSpeedHighPower(v26);
          }
          if (cf[0])
            CFRelease(cf[0]);
        }
        else
        {
          v22 = 0;
        }
        if (!a4)
        {
LABEL_38:
          if ((a7 & 2) == 0)
            goto LABEL_129;
          v86 = 0;
          v87 = 0;
          if (!*(_BYTE *)(*(_QWORD *)v92 + 48)
            && (segPumpIsProtocolUsedByRequest(a1, CFSTR("h3")) || segPumpIsProtocolUsedByRequest(a1, CFSTR("h2"))))
          {
            v30 = *(const void **)(v16 + 416);
            if (v30)
            {
              v31 = *(_QWORD *)v92;
              if (!*(_BYTE *)(*(_QWORD *)v92 + 48))
              {
                *(_BYTE *)(*(_QWORD *)v92 + 48) = 1;
                v32 = *(const void **)(v31 + 40);
                *(_QWORD *)(v31 + 40) = v30;
                CFRetain(v30);
                if (v32)
                  CFRelease(v32);
              }
            }
          }
          FigHTTPStopAndReleaseTimer((dispatch_object_t *)(v16 + 504));
          v33 = FigGetUpTimeNanoseconds();
          v34 = *(_QWORD *)(v16 + 424);
          v35 = FigGetAllocatorForMedia();
          v36 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                               + 8)
                                                                                   + 48);
          if (v36)
            v36(v34, CFSTR("FHRP_HTTPResponseHeaders"), v35, &v91);
          FigNetworkInterfaceReporterSamplePhysicalStatistics(*(_QWORD *)(*(_QWORD *)v92 + 9120), a1, *(_QWORD *)(*(_QWORD *)v92 + 9048), 0x1E301B658, 0);
          segPumpCheckAndUpdateLowLatencyServerCompliance(*(uint64_t *)v92, a1, 0);
          v21 = segPumpSetWiFiStatsOnNetworkPredictor(*(uint64_t *)v92, v16 + 408);
          if ((_DWORD)v21)
            goto LABEL_21;
          v37 = *(const void **)(v16 + 280);
          if (v37)
          {
            CFRelease(v37);
            *(_QWORD *)(v16 + 280) = 0;
          }
          v38 = *(const void **)(v16 + 272);
          if (v38)
          {
            CFRelease(v38);
            *(_QWORD *)(v16 + 272) = 0;
          }
          v39 = *(const void **)(v16 + 424);
          if (*(_BYTE *)(v16 + 537))
          {
            if (v39)
            {
              CFRelease(v39);
              *(_QWORD *)(v16 + 424) = 0;
            }
            v40 = *(const void **)(v16 + 416);
            if (v40)
              CFRelease(v40);
            *(_BYTE *)(v16 + 537) = 0;
          }
          else
          {
            *(_QWORD *)(v16 + 272) = *(_QWORD *)(v16 + 416);
            *(_QWORD *)(v16 + 280) = v39;
          }
          *(_QWORD *)(v16 + 496) = 0;
          *(_QWORD *)(v16 + 416) = 0;
          *(_QWORD *)(v16 + 424) = 0;
          *(_QWORD *)(v16 + 448) = v33;
          *(_DWORD *)(v16 + 472) = 0;
          v41 = *(const void **)(v16 + 480);
          if (v41)
          {
            CFRelease(v41);
            *(_QWORD *)(v16 + 480) = 0;
          }
          v42 = *(_QWORD *)(v16 + 280);
          if (v42)
          {
            v43 = *(unsigned int (**)(uint64_t, _QWORD, uint64_t *, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                       + 24);
            if (v43)
            {
              if (!v43(v42, 0, &v87, &v86))
              {
                v44 = *(_QWORD *)(v16 + 1072);
                if (v44)
                {
                  v45 = v87 + v44;
                  v46 = __OFADD__(v45, v86);
                  v47 = v45 + v86;
                  if (v47 < 0 != v46)
                    ++v47;
                  v48 = v47 >> 1;
                  v49 = v86 + v87;
                }
                else
                {
                  v49 = v86 + v87;
                  v48 = v86 + v87;
                }
                *(_QWORD *)(v16 + 1064) = v48;
                *(_QWORD *)(v16 + 1072) = v49;
              }
            }
          }
          v21 = segPumpParseIndexFile2(v93, *(uint64_t *)v92, v16, (__CFHTTPMessage *)v91, 1, 0, &v88);
          if ((_DWORD)v21)
            goto LABEL_21;
          if (FigRetainProxyIsInvalidated())
            goto LABEL_131;
          v50 = *(_QWORD *)v92;
          v51 = v88;
          cf[0] = 0;
          v52 = *(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, CFTypeRef *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 40);
          if (v52)
          {
            v52(a1, 0, 0, 0, 0, 0, cf, 0, 0, 0, 0, 0, 0);
            if ((uint64_t)cf[0] >= 1)
            {
              v53 = *(_QWORD *)(v50 + 9048);
              if (v51)
              {
                if (v53)
                {
                  v54 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                            + 32);
                  if (v54)
                    v54(v53, CFSTR("startupStats"), CFSTR("MVPResponseCount"), 1);
                  v55 = *(_QWORD *)(v50 + 9048);
                  if (v55)
                  {
                    v56 = (unint64_t)cf[0];
                    v57 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
                    if (v57)
                      v57(v55, CFSTR("startupStats"), CFSTR("MVPResponseTimeSum"), v56 / 0xF4240);
                    v58 = *(_QWORD *)(v50 + 9048);
                    if (v58)
                    {
                      v59 = (unint64_t)cf[0];
                      v60 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
                      if (v60)
                      {
                        v61 = CFSTR("MVPResponseTime0");
LABEL_94:
                        v60(v58, CFSTR("startupStats"), v61, v59 / 0xF4240, 1);
                      }
                    }
                  }
                }
              }
              else if (v53)
              {
                v62 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                          + 32);
                if (v62)
                  v62(v53, CFSTR("startupStats"), CFSTR("IndexResponseCount"), 1);
                v63 = *(_QWORD *)(v50 + 9048);
                if (v63)
                {
                  v64 = (unint64_t)cf[0];
                  v65 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
                  if (v65)
                    v65(v63, CFSTR("startupStats"), CFSTR("IndexResponseTimeSum"), v64 / 0xF4240);
                  v58 = *(_QWORD *)(v50 + 9048);
                  if (v58)
                  {
                    v59 = (unint64_t)cf[0];
                    v60 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
                    if (v60)
                    {
                      v61 = CFSTR("IndexResponseTime0");
                      goto LABEL_94;
                    }
                  }
                }
              }
            }
          }
          if (*(_BYTE *)(*(_QWORD *)v92 + 329) && *(_QWORD *)v16 == *(_QWORD *)(*(_QWORD *)v92 + 8416))
            segPumpResumeRoundTripMonitoring(*(uint64_t *)v92);
          v66 = *(_QWORD *)(v16 + 56);
          if (v66)
          {
            MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v66);
            if (MediaSegmentSpecifiers)
            {
              if (CFArrayGetCount(MediaSegmentSpecifiers) >= 1
                && !FigMediaPlaylistHasEndTag(*(_QWORD *)(v16 + 56)))
              {
                if (*(_QWORD *)(*(_QWORD *)v92 + 8096))
                {
                  if (*(_BYTE *)(v16 + 875))
                  {
                    if (segPumpIsIndexFileResponseOutOfDate(*(uint64_t *)v92, v16, (__CFHTTPMessage *)v91))
                    {
                      v21 = segPumpHandleIndexFileNetworkError(v93, v16, 0, -12888, CFSTR("CoreMediaErrorDomain"), CFSTR("Stale index file"));
                      if ((_DWORD)v21)
                        goto LABEL_21;
                    }
                  }
                }
              }
            }
          }
          v68 = *(_QWORD *)v92;
          if (!*(_BYTE *)(*(_QWORD *)v92 + 329)
            || *(_QWORD *)v16 != *(_QWORD *)(*(_QWORD *)v92 + 8416)
            || *(_BYTE *)(*(_QWORD *)v92 + 338))
          {
            goto LABEL_128;
          }
          v69 = 0;
          v70 = v93;
          *(double *)v96 = 0.0;
          v97 = 0.0;
          v71 = *(_QWORD *)(*(_QWORD *)v92 + 384);
          if (v71)
          {
            v72 = *(_QWORD **)(*(_QWORD *)v92 + 400);
            if (v72)
            {
              if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v92 + 16 * *(_QWORD *)v71 + 384) + 16))
              {
                v73 = *(_QWORD *)(v71 + 56);
                if (v73)
                {
                  if (FigMediaPlaylistGetDateStampCount(v73) >= 1)
                  {
                    if (*(_QWORD *)(*(_QWORD *)(v68 + 16 * *v72 + 384) + 16))
                    {
                      v74 = v72[7];
                      if (v74)
                      {
                        if (FigMediaPlaylistGetDateStampCount(v74) >= 1
                          && !segPumpPlaylistGetImputedLiveEdgeDate(v71, &v97)
                          && !segPumpPlaylistGetImputedLiveEdgeDate((uint64_t)v72, (double *)v96))
                        {
                          v69 = 0;
                          if (v97 == 0.0 || *(double *)v96 == 0.0)
                            goto LABEL_127;
                          v75 = vabdd_f64(v97, *(double *)v96);
                          if (v75 > *(double *)(v68 + 16) + *(double *)(v68 + 16))
                          {
                            segPumpAppendErrorLogEntry((uint64_t)v70, v68, v71, (const __CFURL **)(v71 + 408), -15621, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Low Latency: Live edges are out of sync."), 0, 0, 2u, 3u);
                            if (dword_1EE2A31E8)
                            {
                              v95 = 0;
                              type = OS_LOG_TYPE_DEFAULT;
                              os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                              v77 = v95;
                              if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
                                v78 = v77;
                              else
                                v78 = v77 & 0xFFFFFFFE;
                              if (v78)
                              {
                                v79 = &stru_1E2FD85F8;
                                if (*(_QWORD *)(v68 + 8760))
                                  v79 = *(const __CFString **)(v68 + 8760);
                                v80 = *(_QWORD *)(v68 + 16);
                                v98 = 136315906;
                                v99 = "segPumpAreLiveEdgesOutOfSync";
                                v100 = 2114;
                                v101 = v79;
                                v102 = 2048;
                                v103 = v75;
                                v104 = 2048;
                                v105 = v80;
                                _os_log_send_and_compose_impl();
                              }
                              v69 = 1;
                              fig_log_call_emit_and_clean_up_after_send_and_compose();
                            }
                            else
                            {
                              v69 = 1;
                            }
                            goto LABEL_127;
                          }
                        }
                      }
                    }
                  }
                }
              }
              v69 = 0;
            }
          }
LABEL_127:
          v68 = *(_QWORD *)v92;
          *(_BYTE *)(*(_QWORD *)v92 + 338) = v69;
LABEL_128:
          segPumpPublishPlaylistRequestEvent((uint64_t)v93, v68, (_QWORD *)v16, (uint64_t)v89, a1, v90, v88);
          v22 = 0;
LABEL_129:
          if (!(_DWORD)v22)
            goto LABEL_131;
          goto LABEL_130;
        }
        v27 = *(OpaqueCMBlockBuffer **)(v16 + 520);
        if (!v27)
        {
          v28 = (const __CFAllocator *)FigGetAllocatorForMedia();
          Empty = CMBlockBufferCreateEmpty(v28, 0, 0, (CMBlockBufferRef *)(v16 + 520));
          if ((_DWORD)Empty)
            goto LABEL_145;
          v27 = *(OpaqueCMBlockBuffer **)(v16 + 520);
        }
        Empty = CMBlockBufferAppendBufferReference(v27, a4, a5, a6, 0);
        if (!(_DWORD)Empty)
        {
          v22 = segPumpVerifyM3UPlaylist((uint64_t)v93, *(uint64_t *)v92, v16);
          if (!(_DWORD)v22)
            goto LABEL_38;
          if (dword_1EE2A31E8)
          {
            LODWORD(v97) = 0;
            v96[0] = OS_LOG_TYPE_DEFAULT;
            v81 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            v82 = LODWORD(v97);
            if (os_log_type_enabled(v81, v96[0]))
              v83 = v82;
            else
              v83 = v82 & 0xFFFFFFFE;
            if (v83)
            {
              v84 = &stru_1E2FD85F8;
              if (*(_QWORD *)v92 && *(_QWORD *)(*(_QWORD *)v92 + 8760))
                v84 = *(const __CFString **)(*(_QWORD *)v92 + 8760);
              v85 = *(double *)v16;
              v98 = 136315650;
              v99 = "segPumpIndexFileReadCallback";
              v100 = 2114;
              v101 = v84;
              v102 = 2048;
              v103 = v85;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
LABEL_130:
          segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(a3, v22);
          goto LABEL_131;
        }
LABEL_145:
        v22 = Empty;
        goto LABEL_130;
      }
    }
  }
LABEL_131:
  segPumpUnlockAndSendAllPendingNotifications();
  FigRetainProxyRelease();
  if (v93)
    CFRelease(v93);
  if (v91)
    CFRelease(v91);
  if (v90)
    CFRelease(v90);
  if (v89)
    CFRelease(v89);
}

uint64_t segPumpPostIndexFileRequest(uint64_t a1, uint64_t a2, const __CFArray *a3, uint64_t a4)
{
  uint64_t URLGuts;
  const __CFURL *v8;
  const void *v9;
  uint64_t v10;
  const __CFURL *v12;

  v12 = 0;
  *(_BYTE *)(a2 + 859) = 1;
  URLGuts = segPumpCreateURLWithQueryParams(a1, *(CFTypeRef *)(a2 + 16), a3, &v12);
  v8 = v12;
  if ((_DWORD)URLGuts
    || (URLGuts = segPumpCustomURLLoaderGetURLGuts(a1, v12, 0, 0, 0, 0, a4, 0, 1, 0, 0, a2 + 496),
        (_DWORD)URLGuts))
  {
    v10 = URLGuts;
    *(_BYTE *)(a2 + 859) = 0;
    if (!v8)
      return v10;
    goto LABEL_8;
  }
  v9 = *(const void **)(a2 + 408);
  *(_QWORD *)(a2 + 408) = v8;
  if (v8)
    CFRetain(v8);
  if (v9)
    CFRelease(v9);
  v10 = 0;
  if (v8)
LABEL_8:
    CFRelease(v8);
  return v10;
}

void segPumpScheduleIndexFileLongDownloadTimer(uint64_t a1, uint64_t a2)
{
  uint64_t UpTimeNanoseconds;
  double v5;
  double v6;
  double v7;
  uint64_t v8;
  uint64_t PendingMediaDeadline;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  int v14;

  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v5 = *(double *)(a1 + 16);
  if (v5 <= 0.0)
    v6 = *(double *)(a1 + 7984);
  else
    v6 = v5 * 0.5;
  v7 = 2.0;
  if (!*(_BYTE *)(a2 + 538))
  {
    if (*(_BYTE *)(a1 + 329))
    {
      v7 = v5 + (double)(3 * segPumpGetCurrentRTT((_QWORD *)a1)) / 1000000000.0;
    }
    else if (*(_QWORD *)(*(_QWORD *)(a1 + 384) + 56))
    {
      v14 = *(_DWORD *)(a1 + 8);
      if (v14)
        v7 = (double)(2 * v14);
      else
        v7 = 20.0;
    }
    else
    {
      v7 = *(double *)(a1 + 8200);
    }
  }
  if (v7 > v6)
    v6 = v7;
  if (*(_BYTE *)(a1 + 328) && *(_BYTE *)(a1 + 48))
  {
    v8 = *(_QWORD *)(a1 + 384);
    if (*(_QWORD *)(v8 + 16))
      PendingMediaDeadline = segPumpConnectionGetPendingMediaDeadline(*(uint64_t **)(v8 + 696));
    else
      PendingMediaDeadline = 0;
    v10 = *(_QWORD *)(a1 + 400);
    if (*(_QWORD *)(v10 + 16))
    {
      v11 = segPumpConnectionGetPendingMediaDeadline(*(uint64_t **)(v10 + 696));
      v12 = v11 < PendingMediaDeadline || PendingMediaDeadline == 0;
      v13 = v12 ? v11 : PendingMediaDeadline;
      if (v11)
        PendingMediaDeadline = v13;
    }
    if (PendingMediaDeadline >= 1 && v6 < (double)(PendingMediaDeadline - UpTimeNanoseconds) / 1000000000.0)
      v6 = (double)(PendingMediaDeadline - UpTimeNanoseconds) / 1000000000.0;
  }
  FigHTTPCreateTimer(*(const void **)a1, (uint64_t)IndexFileHandleLongDownloadTimer, *(NSObject **)(a1 + 64), (dispatch_object_t *)(a2 + 504), v6);
  segPumpStreamUpdateIndexExpectedArrival(a1, a2);
}

BOOL segPumpRenditionReportURLsAreEqual(const __CFURL *a1, const __CFURL *a2)
{
  _BOOL8 v2;
  const __CFURL *v4;
  CFURLRef v5;
  const __CFURL *v6;
  CFStringRef v7;
  CFStringRef v8;
  _BOOL8 v9;
  CFStringRef v10;
  CFStringRef v11;

  v2 = 0;
  if (!a1 || !a2)
    return v2;
  v4 = CFURLCopyAbsoluteURL(a1);
  v5 = CFURLCopyAbsoluteURL(a2);
  v6 = v5;
  if (v4 && v5)
  {
    v7 = CFURLCopyPath(v4);
    v8 = CFURLCopyPath(v6);
    if (FigCFEqual())
      v9 = FigCFHTTPDoURLHostsAndPortsMatch(v4, v6) != 0;
    else
      v9 = 0;
  }
  else
  {
    v9 = 0;
    v8 = 0;
    v7 = 0;
    v2 = 0;
    v10 = 0;
    v11 = 0;
    if (!v4)
      goto LABEL_9;
  }
  CFRelease(v4);
  v2 = v9;
  v10 = v8;
  v11 = v7;
LABEL_9:
  if (v6)
    CFRelease(v6);
  if (v11)
    CFRelease(v11);
  if (v10)
    CFRelease(v10);
  return v2;
}

BOOL segPumpPlaylistIsCompliantWithBlockingReloadPolicy(uint64_t a1, int *a2)
{
  int v4;

  if (FigMediaPlaylistDoesServerSupportsBlockingReload(*(_QWORD *)(a1 + 56)))
  {
    if (FigMediaPlaylistHasEndTag(*(_QWORD *)(a1 + 56)))
      v4 = -15413;
    else
      v4 = 0;
  }
  else
  {
    v4 = -15411;
  }
  *a2 = v4;
  return v4 == 0;
}

BOOL segPumpCanContinueWithLowLatencyMode(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  _BOOL8 result;
  int v9;
  uint64_t LastValue;
  const __CFArray *PartialSegments;
  const __CFArray *MediaSegmentSpecifiers;
  CFIndex Count;
  _QWORD *v14;
  const __CFAllocator *AllocatorForMedia;
  __CFDictionary *Mutable;
  const CFArrayCallBacks *v17;
  const __CFURL *PlaylistAlternateURL;
  CFStringRef v19;
  CFStringRef v20;
  const __CFAllocator *v21;
  const __CFArray *v22;
  uint64_t v23;
  const __CFDictionary *VideoGroups;
  const __CFDictionary *AudioGroups;
  const __CFDictionary *SubtitleGroups;
  int HaveMatchingAlternates;
  int v28;
  void *value;

  if (!*(_BYTE *)(a2 + 332) && *(_BYTE *)(a2 + 333) == 1)
  {
    segPumpAppendErrorLogEntry(a1, a2, 0, 0, -15410, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Server should support ECN for Low Latency"), 0, 0, 1u, 3u);
    *(_BYTE *)(a2 + 332) = 1;
  }
  if (!*(_BYTE *)(a2 + 330))
  {
    result = 0;
    v9 = -15410;
    goto LABEL_34;
  }
  if (*(_DWORD *)(a3 + 160) == 6)
  {
    result = 0;
    v9 = -15417;
    goto LABEL_34;
  }
  v28 = 0;
  if (segPumpPlaylistIsCompliantWithBlockingReloadPolicy(a3, &v28))
  {
    if (FigMediaPlaylistGetDateStampCount(*(_QWORD *)(a3 + 56)) < 1)
    {
      v9 = -15412;
    }
    else
    {
      v9 = v28;
      if (!v28)
      {
        FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a3 + 56));
        LastValue = FigCFArrayGetLastValue();
        PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments(LastValue);
        MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a3 + 56));
        if (!MediaSegmentSpecifiers)
          goto LABEL_32;
        Count = CFArrayGetCount(MediaSegmentSpecifiers);
        v9 = -15620;
        if (!Count || !PartialSegments)
          goto LABEL_33;
        if (CFArrayGetCount(PartialSegments) && FigMediaPlaylistGetPartTargetDuration(*(_QWORD *)(a3 + 56)) > 0.0)
        {
          if (FigMediaPlaylistHasEndTag(*(_QWORD *)(a3 + 56))
            || segPumpStreamHasPreloadHint(a3))
          {
            if (!*(_BYTE *)(a2 + 337))
            {
              v14 = *(_QWORD **)(a2 + 8096);
              AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
              Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              if (v14)
              {
                v17 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
                do
                {
                  PlaylistAlternateURL = (const __CFURL *)FigAlternateGetPlaylistAlternateURL(v14[1]);
                  v19 = CFURLCopyHostName(PlaylistAlternateURL);
                  value = 0;
                  if (v19)
                  {
                    v20 = v19;
                    if (CFDictionaryGetValueIfPresent(Mutable, v19, (const void **)&value))
                    {
                      CFArrayAppendValue((CFMutableArrayRef)value, (const void *)v14[1]);
                    }
                    else
                    {
                      v21 = (const __CFAllocator *)FigGetAllocatorForMedia();
                      value = CFArrayCreateMutable(v21, 0, v17);
                      CFArrayAppendValue((CFMutableArrayRef)value, (const void *)v14[1]);
                      CFDictionaryAddValue(Mutable, v20, value);
                      CFRelease(value);
                    }
                    CFRelease(v20);
                  }
                  v14 = (_QWORD *)*v14;
                }
                while (v14);
              }
              v22 = (const __CFArray *)FigCFDictionaryCopyArrayOfValues();
              if (Mutable)
                CFRelease(Mutable);
              v23 = *(_QWORD *)(a3 + 48);
              if (v23)
              {
                VideoGroups = (const __CFDictionary *)FigMultivariantPlaylistGetVideoGroups(v23);
                AudioGroups = (const __CFDictionary *)FigMultivariantPlaylistGetAudioGroups(*(_QWORD *)(a3 + 48));
                SubtitleGroups = (const __CFDictionary *)FigMultivariantPlaylistGetSubtitleGroups(*(_QWORD *)(a3 + 48));
              }
              else
              {
                VideoGroups = 0;
                AudioGroups = 0;
                SubtitleGroups = 0;
              }
              *(_BYTE *)(a2 + 335) = FigAlternateAreAllAlternatesOnSameHost(v22, VideoGroups, AudioGroups, SubtitleGroups);
              HaveMatchingAlternates = FigAlternateDoAllHostsHaveMatchingAlternates(v22);
              *(_BYTE *)(a2 + 336) = HaveMatchingAlternates;
              if (v22)
              {
                CFRelease(v22);
                HaveMatchingAlternates = *(unsigned __int8 *)(a2 + 336);
              }
              if (!HaveMatchingAlternates)
                segPumpAppendErrorLogEntry(a1, a2, 0, 0, -15410, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Low Latency: Not all hosts have matching alternates"), 0, 0, 1u, 3u);
              *(_BYTE *)(a2 + 337) = 1;
            }
            if (!*(_BYTE *)(a2 + 335))
            {
              result = 0;
              v9 = -15414;
              goto LABEL_34;
            }
            goto LABEL_43;
          }
          v9 = -15415;
        }
        else
        {
LABEL_32:
          v9 = -15620;
        }
      }
    }
LABEL_33:
    result = 0;
    goto LABEL_34;
  }
  v9 = v28;
  if (v28)
    goto LABEL_33;
LABEL_43:
  result = *(_BYTE *)(a2 + 331) == 0;
  if (*(_BYTE *)(a2 + 331))
    v9 = -15418;
  else
    v9 = 0;
LABEL_34:
  *a4 = v9;
  return result;
}

uint64_t segPumpHandleLowLatencySetupError(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t i;
  uint64_t v8;
  uint64_t v9;

  switch(a4)
  {
    case -15418:
      segPumpAppendErrorLogEntry(a1, a2, a3, (const __CFURL **)(a3 + 408), -15418, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Dropping out of Low Latency: missing Rendition Report"), 0, 0, 1u, 3u);
      goto LABEL_12;
    case -15417:
      segPumpAppendErrorLogEntry(a1, a2, a3, (const __CFURL **)(a3 + 408), -15417, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Was unable to tune in to Low Latency"), 0, 0, 1u, 3u);
      goto LABEL_12;
    case -15415:
      segPumpAppendErrorLogEntry(a1, a2, a3, (const __CFURL **)(a3 + 408), -15415, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Low Latency: Playlist does not have EXT-X-PRELOAD-HINT tag"), 0, 0, 1u, 3u);
      goto LABEL_12;
    case -15414:
      segPumpAppendErrorLogEntry(a1, a2, a3, (const __CFURL **)(a3 + 408), -15414, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Low Latency: All variants must be on the same host"), 0, 0, 1u, 3u);
      goto LABEL_12;
    case -15413:
      if (dword_1EE2A31E8)
      {
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      goto LABEL_12;
    case -15412:
      segPumpAppendErrorLogEntry(a1, a2, a3, (const __CFURL **)(a3 + 408), -15412, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Low Latency: Playlist does not have EXT-X-PROGRAM-DATE-TIME tag"), 0, 0, 1u, 3u);
      goto LABEL_12;
    case -15411:
      segPumpAppendErrorLogEntry(a1, a2, a3, (const __CFURL **)(a3 + 408), -15411, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Low Latency: Server does not offer blocking playlist reloads"), 0, 0, 1u, 3u);
      goto LABEL_12;
    case -15410:
      segPumpAppendErrorLogEntry(a1, a2, a3, (const __CFURL **)(a3 + 408), -15410, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Low Latency: Server must support http2 ECN and SACK"), 0, 0, 1u, 3u);
LABEL_12:
      result = 0;
      break;
    default:
      result = FigSignalErrorAt();
      break;
  }
  for (i = 0; i != 48; i += 16)
  {
    v8 = *(_QWORD *)(a2 + i + 384);
    if (*(_DWORD *)(v8 + 160) != 5)
      *(_DWORD *)(v8 + 160) = 5;
    v9 = *(_QWORD *)(a2 + i + 392);
    if (*(_DWORD *)(v9 + 160) != 5)
      *(_DWORD *)(v9 + 160) = 5;
  }
  return result;
}

void segPumpSetPartTargetDuration(uint64_t a1, uint64_t a2)
{
  double *v3;
  double v4;
  double PartTargetDuration;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  double v9;
  BOOL v10;
  CFNumberRef v11;
  uint64_t v12;
  void (*v13)(uint64_t, const __CFString *, CFNumberRef);
  uint64_t v14;
  double v15;
  void (*v16)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);

  v3 = (double *)(a1 + 16);
  v4 = *(double *)(a1 + 16);
  if (*(_BYTE *)(a1 + 329))
  {
    if (FigMediaPlaylistGetPartTargetDuration(a2) <= 0.0)
      return;
    PartTargetDuration = v4;
    if (v4 <= FigMediaPlaylistGetPartTargetDuration(a2))
      PartTargetDuration = FigMediaPlaylistGetPartTargetDuration(a2);
  }
  else
  {
    PartTargetDuration = 0.0;
  }
  *v3 = PartTargetDuration;
  if (vabdd_f64(v4, PartTargetDuration) >= 2.22044605e-16 && dword_1EE2A31E8 != 0)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  v9 = vabdd_f64(PartTargetDuration, v4);
  if (*(_QWORD *)(a1 + 9560))
    v10 = v9 <= 2.22044605e-16;
  else
    v10 = 1;
  if (!v10)
  {
    v11 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, v3);
    v12 = *(_QWORD *)(a1 + 9560);
    v13 = *(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                          + 56);
    if (v13)
      v13(v12, CFSTR("AfmfpbProperty_PartTargetDuration"), v11);
    if (v11)
      CFRelease(v11);
  }
  v14 = *(_QWORD *)(a1 + 9048);
  if (v14)
  {
    v15 = *(double *)(a1 + 16);
    v16 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v16)
      v16(v14, CFSTR("bytePumpStats"), CFSTR("PartDur"), (uint64_t)(v15 * 1000.0), 0);
  }
}

void segPumpSetActiveHoldBack(uint64_t a1, uint64_t a2)
{
  double v4;
  BOOL v5;
  double PartHoldBackDuration;
  double v7;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v10;
  void (*v11)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);

  v4 = *(double *)(a1 + 7952);
  if (*(_BYTE *)(a1 + 329))
  {
    v5 = v4 <= FigMediaPlaylistGetPartHoldBackDuration(a2);
    PartHoldBackDuration = v4;
    if (v5)
      PartHoldBackDuration = FigMediaPlaylistGetPartHoldBackDuration(a2);
  }
  else if (FigMediaPlaylistHasHoldBackDuration(a2))
  {
    v5 = v4 <= FigMediaPlaylistGetHoldBackDuration(a2);
    PartHoldBackDuration = v4;
    if (v5)
      PartHoldBackDuration = FigMediaPlaylistGetHoldBackDuration(a2);
  }
  else
  {
    PartHoldBackDuration = 0.0;
  }
  if (PartHoldBackDuration >= 0.0)
    v7 = PartHoldBackDuration;
  else
    v7 = 0.0;
  if (v4 != v7 && v7 > *(double *)(a1 + 7968))
  {
    *(double *)(a1 + 7968) = v7;
    segPumpReadyNotification((_QWORD *)a1, CFSTR("FBP_RecommendedPrebufferReservationChanged"), 0);
  }
  *(double *)(a1 + 7952) = v7;
  if (vabdd_f64(v4, v7) >= 2.22044605e-16 && dword_1EE2A31E8 != 0)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  v10 = *(_QWORD *)(a1 + 9048);
  if (v10)
  {
    v11 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v11)
      v11(v10, CFSTR("bytePumpStats"), CFSTR("HoldBackDur"), (uint64_t)(v7 * 1000.0), 0);
  }
}

uint64_t segPumpStreamHasPreloadHint(uint64_t a1)
{
  uint64_t result;
  uint64_t PreloadHint;

  result = *(_QWORD *)(a1 + 56);
  if (result)
  {
    result = FigMediaPlaylistGetPreloadHint(result);
    if (result)
    {
      PreloadHint = FigMediaPlaylistGetPreloadHint(*(_QWORD *)(a1 + 56));
      return FigMediaSegmentSpecifierIsReadInCurrent(PreloadHint) != 0;
    }
  }
  return result;
}

void segPumpUpdatePathEvaluation(uint64_t a1, const void *a2)
{
  const void *v3;
  CFTypeRef v4;
  const void *v5;
  int DoesUseCellular;
  int v7;
  int IsHostLocal;
  _QWORD *v9;
  const void *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int restarted;
  const void *v15;
  uint64_t *i;
  const void *v17;
  uint64_t v19;
  int v20;
  uint64_t v21;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v23[2];
  CFTypeRef cf[21];

  cf[20] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  *(_QWORD *)v23 = 0;
  cf[0] = 0;
  if (a2)
  {
    if (a1)
    {
      if (segPumpLockAndCopyPumpFromRetainProxy(a1, cf, (uint64_t *)v23))
      {
        v4 = 0;
      }
      else
      {
        v3 = *(const void **)(*(_QWORD *)v23 + 8448);
        if (v3)
        {
          v4 = CFRetain(v3);
          v5 = *(const void **)(*(_QWORD *)v23 + 8448);
          *(_QWORD *)(*(_QWORD *)v23 + 8448) = a2;
          CFRetain(a2);
          if (v5)
            CFRelease(v5);
        }
        else
        {
          *(_QWORD *)(*(_QWORD *)v23 + 8448) = a2;
          CFRetain(a2);
          v4 = 0;
        }
        segPumpUpdateNetworkCostHasHighSpeedHighPower(*(uint64_t *)v23);
        DoesUseCellular = FigNetworkPathInformationDoesUseCellular();
        v7 = FigNetworkPathInformationDoesUseCellular();
        IsHostLocal = FigNetworkPathInformationIsHostLocal();
        v9 = *(_QWORD **)v23;
        if (IsHostLocal)
        {
          v10 = *(const void **)(*(_QWORD *)v23 + 8440);
          if (v10)
          {
            CFRelease(v10);
            *(_QWORD *)(*(_QWORD *)v23 + 8440) = 0;
          }
        }
        else
        {
          *(_OWORD *)(*(_QWORD *)v23 + 8584) = 0u;
          if (!segPumpSentEndCallbackForAllActiveStreams(v9))
          {
            if (v9[1055] && (v11 = v9[1056]) != 0 && !FigNetworkPathInformationIsHostReachable(v11, 1))
            {
              if (dword_1EE2A31E8)
              {
                os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
                fig_log_call_emit_and_clean_up_after_send_and_compose();
              }
            }
            else
            {
              v12 = 0;
              do
              {
                v13 = *(_QWORD *)(*(_QWORD *)v23 + 16 * v12 + 384);
                if (*(_QWORD *)(v13 + 16) && !*(_BYTE *)(v13 + 869))
                {
                  if (v7 != DoesUseCellular)
                  {
                    v15 = *(const void **)(v13 + 280);
                    if (v15)
                    {
                      if (!*(_QWORD *)(v13 + 272)
                        || (CFRelease(*(CFTypeRef *)(v13 + 272)),
                            *(_QWORD *)(v13 + 272) = 0,
                            (v15 = *(const void **)(v13 + 280)) != 0))
                      {
                        CFRelease(v15);
                        *(_QWORD *)(v13 + 280) = 0;
                      }
                    }
                    for (i = *(uint64_t **)(v13 + 680); i; i = (uint64_t *)*i)
                    {
                      v17 = (const void *)i[20];
                      if (v17)
                      {
                        if (!i[19] || (CFRelease((CFTypeRef)i[19]), i[19] = 0, (v17 = (const void *)i[20]) != 0))
                        {
                          CFRelease(v17);
                          i[20] = 0;
                        }
                      }
                      if (i[4])
                        *((_BYTE *)i + 145) = 1;
                    }
                    if (*(_QWORD *)(v13 + 424))
                      *(_BYTE *)(v13 + 537) = 1;
                  }
                  if (*(_BYTE *)(v13 + 400))
                  {
                    *(_BYTE *)(v13 + 400) = 0;
                    FigHTTPStopAndReleaseTimer((dispatch_object_t *)(v13 + 392));
                  }
                  restarted = segPumpRestartStreamReads(cf[0], *(uint64_t **)v23, *(_QWORD **)(*(_QWORD *)v23 + 16 * v12 + 384));
                  if (restarted == -15626)
                    goto LABEL_49;
                }
                else
                {
                  restarted = 0;
                }
                if (restarted)
                  break;
              }
              while (v12++ < 2);
              v19 = *(_QWORD *)(*(_QWORD *)v23 + 8112);
              if (v19)
              {
                v20 = 0;
                do
                {
                  v21 = *(_QWORD *)v19;
                  if (!*(_BYTE *)(v19 + 32))
                  {
                    MoveAlternateFromPenaltyBox(*(uint64_t *)v23, (uint64_t *)v19);
                    v20 = 1;
                  }
                  v19 = v21;
                }
                while (v21);
                if (v20)
                {
                  segPumpResetPenaltyBoxTimer(*(uint64_t **)v23);
                  segPumpUpdateAlternateSelectionBossNetworkErrorFilter(*(_QWORD **)v23, 0);
                  segPumpDispatchAsyncAlternateSelectionApplyFilter(*(uint64_t *)v23);
                  segPumpReadyNotification(*(_QWORD **)v23, CFSTR("FBPAL_AlternateListChanged"), 0);
                }
              }
            }
          }
        }
      }
LABEL_49:
      segPumpUnlockAndSendAllPendingNotifications();
      if (cf[0])
        CFRelease(cf[0]);
      if (v4)
        CFRelease(v4);
    }
  }
  else
  {
    FigSignalErrorAt();
  }
}

void segPumpUpdateNetworkCostHasHighSpeedHighPower(uint64_t a1)
{
  uint64_t UInt64;
  const void *v3;
  uint64_t v4;
  void (*v5)(uint64_t, __CFString *, const void *);

  if (*(_QWORD *)(a1 + 8472))
  {
    if (!*(_DWORD *)(a1 + 8464) && !*(_DWORD *)(a1 + 8460) && *(_QWORD *)(a1 + 8448))
      FigNetworkPathInformationGetInterfaceType();
    UInt64 = FigCFNumberCreateUInt64();
    if (UInt64)
    {
      v3 = (const void *)UInt64;
      v4 = *(_QWORD *)(a1 + 8472);
      v5 = *(void (**)(uint64_t, __CFString *, const void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
      if (v5)
        v5(v4, CFSTR("FNCM_ConnectedPhysicalInterface"), v3);
      CFRelease(v3);
    }
    else
    {
      FigSignalErrorAt();
    }
  }
}

uint64_t segPumpHandleIndexFileNetworkError(const void *a1, uint64_t a2, uint64_t a3, int a4, const __CFString *a5, const void *a6)
{
  uint64_t DerivedStorage;
  uint64_t ErrorFromHTTPRequestIfAvailable;
  void *v14;
  const void *v15;
  uint64_t v16;
  BOOL v17;
  int Code;
  const __CFDictionary *v19;
  __CFError *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  _BOOL4 v27;
  CFIndex v28;
  CFIndex v29;
  unsigned int v30;
  uint64_t v32;
  uint64_t CommonActionForNetworkError;
  uint64_t v34;
  const __CFAllocator *AllocatorForMedia;
  __CFError *v36;
  uint64_t RecommendedAction;
  CFTypeRef cf;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  cf = 0;
  ++*(_DWORD *)(a2 + 472);
  ErrorFromHTTPRequestIfAvailable = segPumpCreateErrorFromHTTPRequestIfAvailable(*(_QWORD *)(a2 + 424), a4, a5, a6, (uint64_t *)&cf);
  v14 = (void *)cf;
  if ((_DWORD)ErrorFromHTTPRequestIfAvailable)
    goto LABEL_82;
  v15 = *(const void **)(a2 + 480);
  *(_QWORD *)(a2 + 480) = cf;
  if (v14)
    CFRetain(v14);
  if (v15)
    CFRelease(v15);
  v16 = *(_QWORD *)(a2 + 424);
  v39 = 0;
  v40 = 0;
  if (*(_QWORD *)a2)
    v17 = 0;
  else
    v17 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 384) + 56) == 0;
  Code = CFErrorGetCode((CFErrorRef)v14);
  CFErrorGetDomain((CFErrorRef)v14);
  v19 = CFErrorCopyUserInfo((CFErrorRef)v14);
  if (!*(_QWORD *)(*(_QWORD *)(DerivedStorage + 16 * *(_QWORD *)a2 + 384) + 16))
  {
    v23 = 0;
    v26 = 0;
    v25 = 0;
    goto LABEL_50;
  }
  if (!(_DWORD)a3 && *(_BYTE *)(a2 + 538))
  {
    v20 = 0;
    v40 = 0;
    goto LABEL_16;
  }
  if (Code >> 1 == 2147477204)
  {
    v20 = 0;
    v21 = 7;
LABEL_15:
    v40 = v21;
    v39 = 2;
    goto LABEL_16;
  }
  if (Code > -15417)
  {
    if (Code > -12647)
    {
      if (Code == -12642)
        goto LABEL_34;
      v22 = -12646;
    }
    else
    {
      if (Code == -15416)
      {
        v20 = 0;
        if (*(_DWORD *)(a2 + 384) >= 2u)
          v32 = 6;
        else
          v32 = 3;
        v39 = 1;
        v40 = v32;
LABEL_16:
        segPumpModifyErrorActionIfCurrentAlternateIsLastValidAlternate(DerivedStorage, (_QWORD *)a2, &v40, &v39);
        if (!*(_DWORD *)(a2 + 384) && *(_BYTE *)(a2 + 875) && v40 == 3 && Code == -12888)
          v40 = 0;
LABEL_35:
        if (v17)
        {
          v23 = v40;
        }
        else
        {
          v23 = v40;
          if (*(_BYTE *)(a2 + 868))
            goto LABEL_41;
        }
        if (v23 == 3)
        {
          if (*(_QWORD *)(DerivedStorage + 16 * *(_QWORD *)a2 + 384) == a2)
            goto LABEL_47;
          goto LABEL_45;
        }
LABEL_41:
        if (*(_BYTE *)(DerivedStorage + 8176) || (unint64_t)(v23 - 9) < 0xFFFFFFFFFFFFFFFELL)
        {
          if (v23 != 3)
            goto LABEL_48;
        }
        else
        {
          v40 = 3;
        }
LABEL_45:
        if (*(_BYTE *)(DerivedStorage + 8177))
        {
          v23 = 3;
          goto LABEL_48;
        }
LABEL_47:
        v23 = 6;
        v40 = 6;
LABEL_48:
        v24 = 0;
        v25 = 0;
        v26 = v39;
        if (!v20)
          goto LABEL_50;
        goto LABEL_49;
      }
      v22 = -12885;
    }
    goto LABEL_33;
  }
  if (Code > -15623)
  {
    if (Code == -15622)
      goto LABEL_34;
    v22 = -15417;
LABEL_33:
    if (Code != v22)
      goto LABEL_91;
LABEL_34:
    v20 = 0;
    v40 = 8;
    goto LABEL_35;
  }
  if (Code == -17633)
  {
    v20 = 0;
    v39 = 3;
    v40 = 3;
    goto LABEL_16;
  }
  if (Code == -16839)
  {
    v20 = 0;
    v21 = 3;
    goto LABEL_15;
  }
LABEL_91:
  CommonActionForNetworkError = segPumpGetCommonActionForNetworkError((__CFError *)v14, &v40, &v39);
  if ((_DWORD)CommonActionForNetworkError)
  {
    v25 = CommonActionForNetworkError;
LABEL_106:
    v23 = 0;
    v26 = 0;
    goto LABEL_50;
  }
  v20 = 0;
  v34 = v40;
  if (v16 || v40 != 1)
    goto LABEL_99;
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  v36 = CFErrorCreate(AllocatorForMedia, CFSTR("CoreMediaErrorDomain"), -12938, v19);
  if (v36)
  {
    v20 = v36;
    v41 = 0;
    v42 = 0;
    RecommendedAction = FigStreamingNetworkErrorGetRecommendedAction(v36, &v42, &v41);
    if ((_DWORD)RecommendedAction)
    {
      v24 = RecommendedAction;
      v23 = 0;
      v26 = 0;
LABEL_49:
      CFRelease(v20);
      v25 = v24;
      goto LABEL_50;
    }
    v34 = v42;
    if (v42 == 2)
      v34 = 7;
    v40 = v34;
LABEL_99:
    if (v34 == 8)
      goto LABEL_35;
    goto LABEL_16;
  }
  v25 = FigSignalErrorAt();
  if ((_DWORD)v25)
    goto LABEL_106;
  v26 = v39;
  v23 = v40;
LABEL_50:
  if (v19)
    CFRelease(v19);
  if ((_DWORD)v25)
  {
    v14 = (void *)cf;
    if (!cf)
      return v25;
    goto LABEL_84;
  }
  if (*(_BYTE *)(DerivedStorage + 328) && *(_QWORD *)a2 == *(_QWORD *)(DerivedStorage + 8416))
    segPumpSendPlaylistUpdateNotification((_QWORD *)DerivedStorage);
  if (*(_BYTE *)(a2 + 538) && !v23)
  {
    if (*(_QWORD *)(a2 + 56))
      v27 = 0;
    else
      v27 = *(_QWORD *)a2 == 0;
    segPumpCopyIndexFileFromCache(DerivedStorage, a2, v27, (CFTypeRef *)(a2 + 520), 0, 0);
    if (*(_QWORD *)(a2 + 520))
    {
      segPumpParseIndexFile2(a1, DerivedStorage, a2, 0, 0, a3, 0);
      v23 = 0;
    }
    else
    {
      v23 = 6;
    }
LABEL_68:
    v14 = (void *)cf;
    v28 = CFErrorGetCode((CFErrorRef)cf);
    v29 = CFErrorGetCode((CFErrorRef)v14);
    if (v28 == -17633 && v23 == 3)
    {
      segPumpAppendErrorLogEntry((uint64_t)a1, DerivedStorage, a2, (const __CFURL **)(a2 + 408), v29, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Could not apply Playlist delta"), 0, 0, 1u, 3u);
    }
    else
    {
      if (v29 != -15416)
      {
        ErrorFromHTTPRequestIfAvailable = segPumpHandleCommonNetworkError((uint64_t)a1, a2, v23, v26, (const __CFURL **)(a2 + 408), 0, v14);
        goto LABEL_82;
      }
      if (v23 == 3)
        v30 = 3;
      else
        v30 = 1;
      segPumpAppendErrorLogEntry((uint64_t)a1, DerivedStorage, 0, 0, -15410, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Invalid server blocking reload behavior for low latency"), 0, 0, 1u, v30);
      if (v23 == 6)
      {
        ErrorFromHTTPRequestIfAvailable = segPumpSendEndCallbackForAllActiveStreams(*(_QWORD *)DerivedStorage, v14);
        goto LABEL_82;
      }
      if (v23 != 3)
      {
        v25 = 0;
        if (!v14)
          return v25;
        goto LABEL_84;
      }
    }
    ErrorFromHTTPRequestIfAvailable = segPumpSendIndexFileRequest(a1, DerivedStorage, a2);
LABEL_82:
    v25 = ErrorFromHTTPRequestIfAvailable;
    goto LABEL_83;
  }
  if (v23 != 1)
    goto LABEL_68;
  segPumpResetConnectionByPreservingConnectionStats(DerivedStorage, a2 + 408);
  v25 = segPumpPostIndexFileRequest(DerivedStorage, a2, 0, 0);
  v14 = (void *)cf;
  if (!(_DWORD)v25)
  {
    segPumpAppendErrorLogEntryWithCFError((uint64_t)a1, DerivedStorage, a2, (const __CFURL **)(a2 + 408), (CFErrorRef)cf, 1u, 3u);
    if (!v14)
      return v25;
    goto LABEL_84;
  }
LABEL_83:
  if (v14)
LABEL_84:
    CFRelease(v14);
  return v25;
}

uint64_t segPumpRTCReportingUpdatePreLTKUStats_HeadersAvailable(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t (*v5)(uint64_t, uint64_t *, uint64_t *, uint64_t *, _QWORD, uint64_t *, _QWORD, uint64_t *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v6;
  uint64_t (*v7)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v8;
  unint64_t v9;
  uint64_t (*v10)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v11;
  uint64_t (*v12)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v13;
  unint64_t v14;
  uint64_t (*v15)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v16;
  uint64_t (*v17)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v18;
  unint64_t v19;
  uint64_t (*v20)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v21;
  uint64_t (*v22)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v23;
  unint64_t v24;
  uint64_t (*v25)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v26;
  uint64_t (*v27)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v28;
  unint64_t v29;
  uint64_t (*v30)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v35 = 0;
  v33 = 0;
  v34 = 0;
  v31 = 0;
  v32 = 0;
  result = CMBaseObjectGetVTable();
  v5 = *(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, _QWORD, uint64_t *, _QWORD, uint64_t *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(result + 16) + 40);
  if (v5)
  {
    result = v5(a2, &v35, &v34, &v33, 0, &v32, 0, &v31, 0, 0, 0, 0, 0);
    if (v35 >= 1)
    {
      v6 = *(_QWORD *)(a1 + 9048);
      if (v6)
      {
        result = CMBaseObjectGetVTable();
        v7 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(result + 16) + 32);
        if (v7)
          result = v7(v6, CFSTR("startupStats"), CFSTR("DNSCount"), 1);
        v8 = *(_QWORD *)(a1 + 9048);
        if (v8)
        {
          v9 = v35;
          result = CMBaseObjectGetVTable();
          v10 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(result + 16)
                                                                                                + 32);
          if (v10)
            result = v10(v8, CFSTR("startupStats"), CFSTR("DNSTimeSum"), v9 / 0xF4240);
        }
      }
    }
  }
  if (v34 >= 1)
  {
    v11 = *(_QWORD *)(a1 + 9048);
    if (v11)
    {
      result = CMBaseObjectGetVTable();
      v12 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(result + 16) + 32);
      if (v12)
        result = v12(v11, CFSTR("startupStats"), CFSTR("TLSCount"), 1);
      v13 = *(_QWORD *)(a1 + 9048);
      if (v13)
      {
        v14 = v34;
        result = CMBaseObjectGetVTable();
        v15 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(result + 16)
                                                                                              + 32);
        if (v15)
          result = v15(v13, CFSTR("startupStats"), CFSTR("TLSTimeSum"), v14 / 0xF4240);
      }
    }
  }
  if (v33 >= 1)
  {
    v16 = *(_QWORD *)(a1 + 9048);
    if (v16)
    {
      result = CMBaseObjectGetVTable();
      v17 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(result + 16) + 32);
      if (v17)
        result = v17(v16, CFSTR("startupStats"), CFSTR("ConnCount"), 1);
      v18 = *(_QWORD *)(a1 + 9048);
      if (v18)
      {
        v19 = v33;
        result = CMBaseObjectGetVTable();
        v20 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(result + 16)
                                                                                              + 32);
        if (v20)
          result = v20(v18, CFSTR("startupStats"), CFSTR("ConnTimeSum"), v19 / 0xF4240);
      }
    }
  }
  if (v32 >= 1)
  {
    v21 = *(_QWORD *)(a1 + 9048);
    if (v21)
    {
      result = CMBaseObjectGetVTable();
      v22 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(result + 16) + 32);
      if (v22)
        result = v22(v21, CFSTR("startupStats"), CFSTR("RequestCount"), 1);
      v23 = *(_QWORD *)(a1 + 9048);
      if (v23)
      {
        v24 = v32;
        result = CMBaseObjectGetVTable();
        v25 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(result + 16)
                                                                                              + 32);
        if (v25)
          result = v25(v23, CFSTR("startupStats"), CFSTR("RequestTimeSum"), v24 / 0xF4240);
      }
    }
  }
  if (v31 >= 1)
  {
    v26 = *(_QWORD *)(a1 + 9048);
    if (v26)
    {
      result = CMBaseObjectGetVTable();
      v27 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(result + 16) + 32);
      if (v27)
        result = v27(v26, CFSTR("startupStats"), CFSTR("SchedulingDelayCount"), 1);
      v28 = *(_QWORD *)(a1 + 9048);
      if (v28)
      {
        v29 = v31;
        result = CMBaseObjectGetVTable();
        v30 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(result + 16)
                                                                                              + 32);
        if (v30)
          return v30(v28, CFSTR("startupStats"), CFSTR("SchedulingDelayTimeSum"), v29 / 0xF4240);
      }
    }
  }
  return result;
}

void segPumpStreamUpdateIndexFileURLWithResponse(uint64_t a1, uint64_t a2, const void *a3)
{
  const void *v3;
  uint64_t v6;
  const __CFString *PathwayID;
  CFTypeRef v8;
  CFTypeRef v9;
  CFTypeRef v10;
  CFTypeRef cf;

  v3 = a3;
  v6 = *(_QWORD *)(a1 + 8144);
  if (v6)
  {
    PathwayID = FigAlternateGetPathwayID(*(_QWORD *)(v6 + 8));
    if (!v3)
      goto LABEL_4;
    goto LABEL_3;
  }
  PathwayID = CFSTR(".");
  if (a3)
LABEL_3:
    CFRetain(v3);
LABEL_4:
  if (*(_BYTE *)(a2 + 876))
  {
    cf = 0;
    if (FigCFHTTPCreateURLMinusQueryParam((const __CFURL *)v3, CFSTR("_HLS_skip="), &cf))
    {
      v8 = v3;
    }
    else
    {
      v8 = cf;
      if (cf)
        CFRetain(cf);
      if (v3)
        CFRelease(v3);
      if (cf)
        CFRelease(cf);
    }
    v3 = v8;
  }
  if (*(_BYTE *)(a1 + 328))
  {
    v10 = 0;
    cf = 0;
    if (FigCFHTTPCreateURLMinusQueryParam((const __CFURL *)v3, CFSTR("_HLS_msn="), &cf)
      || FigCFHTTPCreateURLMinusQueryParam((const __CFURL *)cf, CFSTR("_HLS_part="), &v10))
    {
      v9 = v3;
    }
    else
    {
      v9 = v10;
      if (v10)
        CFRetain(v10);
      if (v3)
        CFRelease(v3);
    }
    if (cf)
      CFRelease(cf);
    if (v10)
      CFRelease(v10);
  }
  else
  {
    v9 = v3;
  }
  segPumpStreamUpdateIndexFile((_QWORD *)a2, v9, *(CFTypeRef *)(a2 + 8), *(CFTypeRef *)(a2 + 24), *(CFTypeRef *)(a2 + 32), PathwayID);
  if (v9)
    CFRelease(v9);
}

uint64_t segPumpVerifyM3UPlaylist(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _BOOL4 v6;
  uint64_t result;
  char v9;

  v9 = 0;
  v6 = FigStreamingPlaylistVerifyM3UPlaylist(*(CMBlockBufferRef *)(a3 + 520), &v9);
  result = 0;
  if (!v6 && v9 != 0)
  {
    segPumpAppendErrorLogEntry(a1, a2, a3, (const __CFURL **)(a3 + 408), -12646, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Playlist parse error"), 0, 0, 1u, 1u);
    return 4294954650;
  }
  return result;
}

void segPumpCheckAndUpdateLowLatencyServerCompliance(uint64_t a1, uint64_t a2, CFDictionaryRef theDict)
{
  uint64_t AllocatorForMedia;
  unsigned int (*v6)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  const __CFString *Value;
  const __CFString *v8;
  BOOL v9;
  _BOOL4 v10;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  CFTypeRef cf[21];

  cf[20] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  cf[0] = 0;
  if (*(_DWORD *)(a1 + 8) && *(double *)(a1 + 16) <= 0.0)
    return;
  if (a2)
  {
    AllocatorForMedia = FigGetAllocatorForMedia();
    v6 = *(unsigned int (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                + 8)
                                                                                    + 48);
    if (v6)
    {
      if (!v6(a2, CFSTR("FHRP_CFNetworkTimingData"), AllocatorForMedia, cf))
      {
        if (!cf[0] || (CFRelease(cf[0]), !cf[0]))
        {
          if (dword_1EE2A31E8)
          {
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          *(_BYTE *)(a1 + 330) = 1;
          return;
        }
      }
    }
    if (segPumpIsProtocolUsedByRequest(a2, CFSTR("h2")))
    {
      *(_BYTE *)(a1 + 330) = 1;
LABEL_8:
      if (!*(_BYTE *)(a1 + 332)
        && FigNetworkInterfaceReporterECNRefused(*(_QWORD *)(a1 + 9120))
        && FigNetworkInterfaceReporterGetInterfaceType(*(_BYTE **)(a1 + 9120)))
      {
        *(_BYTE *)(a1 + 333) = 1;
      }
      if (!FigNetworkInterfaceReporterDoesSupportSACK(*(_QWORD *)(a1 + 9120)))
        FigNetworkInterfaceReporterGetInterfaceType(*(_BYTE **)(a1 + 9120));
      return;
    }
    if (!segPumpIsProtocolUsedByRequest(a2, CFSTR("h3")) || !*(_BYTE *)(a1 + 330))
    {
      *(_BYTE *)(a1 + 330) = 0;
      return;
    }
    v10 = segPumpCheckPriorityHeaderLowLatencyServerCompliance(a2, 0);
    *(_BYTE *)(a1 + 330) = v10;
    if (v10)
      goto LABEL_8;
  }
  else
  {
    if (theDict
      && (Value = (const __CFString *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E0CA36E8])) != 0)
    {
      v8 = Value;
      v9 = 1;
      if (CFStringCompare(Value, CFSTR("h2"), 1uLL))
        v9 = CFStringCompare(v8, CFSTR("h3"), 1uLL) == kCFCompareEqualTo;
    }
    else
    {
      v9 = 1;
    }
    *(_BYTE *)(a1 + 330) = v9;
  }
}

uint64_t segPumpParseIndexFile2(const void *a1, uint64_t a2, uint64_t a3, __CFHTTPMessage *a4, int a5, uint64_t a6, _BYTE *a7)
{
  _BOOL4 v13;
  unsigned __int8 *v14;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  const __CFArray *v16;
  const void *v17;
  unsigned int v18;
  NSObject *v19;
  uint64_t v20;
  CFNumberRef v21;
  CFNumberRef v22;
  int v23;
  int v24;
  uint64_t MediaForSingleStream;
  uint64_t UpTimeNanoseconds;
  uint64_t ParamsAsDict;
  unsigned __int8 *v28;
  CFArrayRef *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  void (*v33)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD);
  uint64_t v34;
  unint64_t v35;
  void (*v36)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD);
  const __CFAllocator *v37;
  uint64_t v38;
  void (*v39)(uint64_t, __CFString *, __CFString *, CFNumberRef, uint64_t);
  uint64_t v40;
  void (*v41)(uint64_t, __CFString *, __CFString *, CFNumberRef, uint64_t);
  uint64_t started;
  CFIndex v43;
  char v44;
  int v45;
  _BOOL4 v46;
  uint64_t v47;
  uint64_t v48;
  void (*v49)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD);
  __CFString *v50;
  const void *v51;
  uint64_t *v52;
  NSObject *v53;
  uint64_t v54;
  uint64_t (*v55)(uint64_t, __CFString *, uint64_t);
  __CFString *v56;
  uint64_t v57;
  uint64_t v58;
  const __CFString *v59;
  size_t DataLength;
  int v61;
  _BYTE *v62;
  const __CFArray *v63;
  uint64_t v64;
  const __CFArray *v65;
  NSObject *v66;
  uint64_t v67;
  NSObject *v68;
  unsigned int v69;
  unsigned int v70;
  const __CFString *v71;
  uint64_t v72;
  const __CFString *v73;
  int v74;
  uint64_t v75;
  uint64_t *v76;
  unsigned int v77;
  uint64_t v78;
  const __CFNumber *v79;
  uint64_t v80;
  BOOL v81;
  uint64_t v82;
  CFIndex i;
  const __CFArray *ContentKeySpecifiers;
  const __CFArray *v85;
  const void *ValueAtIndex;
  NSObject *v87;
  const void *v88;
  const void *PlaylistVariables;
  char v90;
  const __CFArray *MediaSegmentSpecifiers;
  __CFDictionary *v92;
  __CFDictionary *v93;
  int AllocatorForMedia;
  uint64_t v95;
  uint64_t (*v96)(uint64_t, __CFString *, _QWORD);
  uint64_t v97;
  uint64_t v98;
  int v99;
  uint64_t v100;
  uint64_t NextMediaFileWithDate;
  uint64_t v102;
  uint64_t v103;
  uint64_t DateStamp;
  double v105;
  uint64_t v106;
  double v107;
  uint64_t v108;
  uint64_t v109;
  double *v110;
  double v111;
  uint64_t v112;
  uint64_t v113;
  const void *v114;
  uint64_t v115;
  uint64_t NextSegment;
  _BYTE *v117;
  const __CFArray *PartialSegments;
  CFIndex v119;
  const void *v120;
  _QWORD *v121;
  CFIndex v122;
  double Current;
  const void *LastValue;
  _QWORD *v125;
  const __CFArray *v126;
  CFIndex v127;
  CFIndex v128;
  const void *v129;
  int v130;
  _QWORD *j;
  uint64_t MapSegmentSpecifier;
  uint64_t ContentKeySpecifier;
  int PlaylistType;
  int v135;
  char v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  const void *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  CFMutableDictionaryRef *v146;
  CFTypeRef v147;
  uint64_t StartOffset;
  uint64_t MediaSequence;
  uint64_t v150;
  const void *v151;
  uint64_t v152;
  uint64_t v153;
  CFTypeRef *SavedEntry;
  const __CFArray *v155;
  const void *v156;
  const __CFAllocator *v157;
  CFMutableDictionaryRef Mutable;
  const __CFDictionary *v159;
  CFIndex v160;
  const CFArrayCallBacks *v161;
  const __CFArray *v162;
  const __CFArray *v163;
  const void *v164;
  uint64_t URLString;
  uint64_t v166;
  const __CFAllocator *v167;
  CFStringRef v168;
  CFStringRef v169;
  const __CFAllocator *v170;
  CFMutableArrayRef v171;
  CFMutableArrayRef v172;
  const __CFAllocator *v173;
  const __CFDictionary *Copy;
  CFIndex m;
  const __CFArray *v176;
  const __CFArray *v177;
  const void *v178;
  _QWORD *v179;
  uint64_t v180;
  uint64_t v181;
  const __CFAllocator *v182;
  CFStringRef v183;
  CFStringRef v184;
  const void *Value;
  uint64_t v186;
  const __CFArray *Alternates;
  CFIndex v188;
  CFIndex v189;
  CFIndex v190;
  const __CFArray *v191;
  const void *v192;
  uint64_t v193;
  char v194;
  const void *v195;
  const void *MediaSelectionArray;
  unsigned __int8 HasIndependentSegments;
  uint64_t k;
  uint64_t inited;
  uint64_t v200;
  const __CFArray *v201;
  double IntValue;
  _BOOL4 v203;
  CFStringRef v204;
  const __CFString *v205;
  const __CFString *v206;
  int v207;
  double PlaylistActiveDurationSecs;
  uint64_t v209;
  int v210;
  const __CFArray *v211;
  const void *FirstValue;
  const void *v213;
  const __CFURL *v214;
  const __CFURL *v215;
  _QWORD *MediaFilePrivateData;
  const __CFURL *v217;
  const __CFURL *v218;
  const __CFURL *v219;
  const __CFURL **v220;
  uint64_t v221;
  void (*v222)(uint64_t, __CFString *, __CFString *, uint64_t);
  const void *v223;
  unsigned int v224;
  const __CFURL *v226;
  const __CFURL *v227;
  _QWORD *v228;
  const void *v229;
  int v230;
  uint64_t v231;
  double v232;
  uint64_t v233;
  NSObject *v234;
  uint64_t v235;
  __CFHTTPMessage *v236;
  uint64_t v237;
  int v238;
  uint64_t v239;
  uint64_t v240;
  int v241;
  uint64_t v242;
  uint64_t v243;
  double v244;
  double v245;
  OpaqueCMClock *HostTimeClock;
  double v247;
  double v248;
  double v249;
  unint64_t v250;
  NSObject *v251;
  unsigned int v252;
  unsigned int v253;
  const __CFString *v254;
  uint64_t v255;
  const __CFString *v256;
  uint64_t v257;
  NSObject *v258;
  unsigned int v259;
  unsigned int v260;
  const __CFString *v261;
  uint64_t v262;
  const __CFString *v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  double v267;
  double v268;
  uint64_t v269;
  double v270;
  double v271;
  double v272;
  unint64_t v273;
  uint64_t v274;
  unsigned int v275;
  unint64_t v276;
  unint64_t v277;
  uint64_t *v279;
  const __CFArray *v280;
  uint64_t v281;
  uint64_t v282;
  const __CFArray *v283;
  const void *PreloadHint;
  BOOL v285;
  char v286;
  const void *PreloadMapHint;
  BOOL v288;
  CFIndex v289;
  const __CFArray *MapSegmentSpecifiers;
  const __CFArray *v291;
  const void *v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  const void *v296;
  char v297;
  const __CFArray *RenditionReportSpecifiers;
  const __CFArray *v299;
  CFNumberRef v300;
  CFNumberRef v301;
  uint64_t v302;
  void (*v303)(uint64_t, const __CFString *, CFNumberRef);
  _BYTE *v304;
  int v305;
  double *v306;
  double *v307;
  uint64_t v308;
  const __CFAllocator *allocator;
  int v310;
  __CFHTTPMessage *message;
  CFIndex Count;
  int v313;
  unsigned int v314;
  const __CFURL **v315;
  CFNumberRef v316;
  CFNumberRef v317;
  unsigned __int8 *v318;
  uint64_t v320;
  uint64_t *v321;
  int v322;
  uint64_t *v323;
  CMTime v324;
  CMTime v325;
  os_log_type_t type;
  unsigned int v327;
  CFTypeRef v328;
  unint64_t valuePtr;
  unint64_t v330;
  CFTypeRef v331;
  int v332;
  _BYTE cf[12];
  __int16 v334;
  const __CFString *v335;
  __int16 v336;
  uint64_t v337;
  __int16 v338;
  const __CFString *v339;
  __int16 v340;
  uint64_t v341;
  CFTypeRef v342[19];

  v13 = 0;
  v342[16] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  v14 = (unsigned __int8 *)(a2 + 7993);
  v332 = 0;
  v321 = (uint64_t *)(a3 + 48);
  if (!*(_QWORD *)(a3 + 48))
  {
    if (*(_QWORD *)(a3 + 56))
      v13 = 0;
    else
      v13 = *(_QWORD *)a3 == 0;
  }
  v330 = 0;
  v331 = 0;
  v328 = 0;
  valuePtr = 0;
  *(_BYTE *)(a3 + 860) = 1;
  segPumpStreamUpdateIndexExpectedArrival(a2, a3);
  v315 = (const __CFURL **)(a3 + 408);
  v320 = (uint64_t)a1;
  if (CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(a3 + 520)) <= 1)
  {
    v327 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    if (!*(_DWORD *)(a3 + 820))
      segPumpAppendErrorLogEntry((uint64_t)a1, a2, a3, v315, -12887, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("0 Length playlist returned"), 0, 0, 1u, 3u);
    v17 = *(const void **)(a3 + 520);
    if (v17)
    {
      CFRelease(v17);
      *(_QWORD *)(a3 + 520) = 0;
    }
    v18 = *(_DWORD *)(a3 + 820) + 1;
    *(_DWORD *)(a3 + 820) = v18;
    if (v18 >= 3)
    {
      v327 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v19 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      if (*(_QWORD *)(a2 + 8144))
        ParamsAsDict = segPumpHandleIndexFileNetworkError(a1, a3, a6, 4294954409, CFSTR("CoreMediaErrorDomain"), CFSTR("More than 2 empty playlists in a row."));
      else
        ParamsAsDict = FigSignalErrorAt();
LABEL_139:
      v20 = ParamsAsDict;
      LOBYTE(v322) = 0;
      v22 = 0;
      v21 = 0;
      goto LABEL_438;
    }
    v314 = a6;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v322 = 0;
    v24 = 0;
    v313 = 0;
LABEL_16:
    if ((v332 & 3) == 0)
    {
      v67 = *(_QWORD *)(a3 + 56);
      if (v67)
      {
        if (!FigMediaPlaylistHasEndTag(v67))
        {
          if (*(_BYTE *)(a3 + 866))
            v24 = 1;
          ++*(_DWORD *)(a3 + 384);
          if (dword_1EE2A31E8)
          {
            v327 = 0;
            type = OS_LOG_TYPE_DEFAULT;
            v68 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            v69 = v327;
            if (os_log_type_enabled(v68, type))
              v70 = v69;
            else
              v70 = v69 & 0xFFFFFFFE;
            if (v70)
            {
              v71 = &stru_1E2FD85F8;
              if (a2 && *(_QWORD *)(a2 + 8760))
                v71 = *(const __CFString **)(a2 + 8760);
              v72 = *(_QWORD *)a3;
              v73 = *(const __CFString **)(a3 + 16);
              if (!*(_BYTE *)(a2 + 339))
                v73 = CFSTR("[]");
              v74 = *(_DWORD *)(a3 + 384);
              *(_DWORD *)cf = 136316162;
              *(_QWORD *)&cf[4] = "segPumpParseIndexFile2";
              v334 = 2114;
              v335 = v71;
              v336 = 2048;
              v337 = v72;
              v338 = 2114;
              v339 = v73;
              v340 = 1024;
              LODWORD(v341) = v74;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
            a1 = (const void *)v320;
          }
          v209 = *(_QWORD *)(a3 + 56);
          if (v209)
          {
            if (!*(_BYTE *)(a2 + 328)
              && *(_QWORD *)(a3 + 1048) - *(_QWORD *)(a3 + 1056) >= 1500000000 * *(unsigned int *)(a2 + 8)
              && !FigMediaPlaylistHasEndTag(v209))
            {
              v20 = segPumpHandleIndexFileNetworkError(a1, a3, v314, 4294954408, CFSTR("CoreMediaErrorDomain"), CFSTR("Playlist File unchanged for longer than 1.5 * target duration"));
              if ((_DWORD)v20)
                goto LABEL_148;
            }
          }
        }
      }
    }
    goto LABEL_17;
  }
  *(_DWORD *)(a3 + 820) = 0;
  v16 = *(const __CFArray **)(a2 + 8672);
  message = a4;
  v314 = a6;
  if (v16)
    Count = CFArrayGetCount(v16);
  else
    Count = 0;
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  ParamsAsDict = FigCFHTTPCopyQueryParamsAsDict(*(_QWORD *)(a3 + 16), (CFMutableDictionaryRef *)&v328);
  if ((_DWORD)ParamsAsDict)
    goto LABEL_139;
  v28 = v14;
  v29 = (CFArrayRef *)(a2 + 8672);
  v318 = v28;
  v323 = (uint64_t *)(a3 + 56);
  v20 = FigStreamPlaylistParse(*(OpaqueCMBlockBuffer **)(a3 + 520), *(const __CFURL **)(a3 + 16), *(const __CFURL **)(a3 + 24), &v332, 0, 0, *v28, *(unsigned __int8 *)(a2 + 339), (CFMutableArrayRef *)(a2 + 8672), *(_QWORD *)(a2 + 8384), *(const __CFDictionary **)(a2 + 8160), (const __CFDictionary *)v328, v321, (CFTypeRef *)(a3 + 56));
  v30 = *(_QWORD *)(a3 + 56);
  if (v30)
    v330 = FigMediaPlaylistGetMessagingDelayTime(v30) / 0xF4240uLL;
  valuePtr = (FigGetUpTimeNanoseconds() - UpTimeNanoseconds) / 0xF4240uLL;
  if (!v318[1103])
  {
    v318[1103] = 1;
    v31 = *(_QWORD *)(a2 + 9048);
    if (v31)
    {
      v32 = v330;
      v33 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                 + 56);
      if (v33)
        v33(v31, CFSTR("parserStats"), CFSTR("PMDelayTime"), v32, 0);
      v34 = *(_QWORD *)(a2 + 9048);
      if (v34)
      {
        v35 = valuePtr;
        v36 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
        if (v36)
          v36(v34, CFSTR("parserStats"), CFSTR("PPTime"), v35, 0);
      }
    }
  }
  v37 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v316 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
  allocator = v37;
  v317 = CFNumberCreate(v37, kCFNumberSInt64Type, &v330);
  v38 = *(_QWORD *)(a2 + 9048);
  if (v38)
  {
    v39 = *(void (**)(uint64_t, __CFString *, __CFString *, CFNumberRef, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                           + 120);
    if (v39)
      v39(v38, CFSTR("parserStats"), CFSTR("PMDelayTimeArr"), v317, 100);
    v40 = *(_QWORD *)(a2 + 9048);
    if (v40)
    {
      v41 = *(void (**)(uint64_t, __CFString *, __CFString *, CFNumberRef, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                             + 120);
      if (v41)
        v41(v40, CFSTR("parserStats"), CFSTR("PPTimeArr"), v316, 100);
    }
  }
  if (v13)
  {
    if (*v323)
    {
      if (FigMediaPlaylistGetXPCClientObject(*v323))
      {
        FigMediaPlaylistGetXPCClientObject(*v323);
        started = FigStartForwardingMediaServicesProcessDeathNotification();
        if ((_DWORD)started)
        {
          LOBYTE(v322) = 0;
          goto LABEL_638;
        }
      }
    }
  }
  if (*v29)
    v43 = CFArrayGetCount(*v29);
  else
    v43 = 0;
  v44 = v332;
  v322 = v332 & 1;
  if (!(_DWORD)v20)
  {
    if (*v323)
    {
      if ((v332 & 1) == 0)
      {
        v45 = segPumpSetupBlockingReload((uint64_t)a1, a2, a3);
        if (v45)
          goto LABEL_636;
      }
    }
  }
  if (*(_BYTE *)(a2 + 329))
  {
    if ((_DWORD)v20)
    {
LABEL_62:
      v46 = (v44 & 1) == 0;
LABEL_63:
      v310 = v46;
      goto LABEL_64;
    }
  }
  else
  {
    segPumpStreamCancelPreloadReadAndResetData(a2, a3);
    segPumpStreamCancelPreloadMapReadAndResetData(a2, a3);
    if ((_DWORD)v20)
      goto LABEL_62;
  }
  if (*v323 && FigMediaPlaylistHasSkipDeltaBoundary(*v323))
    *(_BYTE *)(a3 + 876) = 1;
  if ((v44 & 1) == 0)
  {
    if (*v323)
    {
      if (FigMediaPlaylistGetPlaylistType(*v323) == 2
        && FigMediaPlaylistGetPlaylistActiveDurationSecs(*v323) < 300.0)
      {
        v54 = *(_QWORD *)(a2 + 96);
        v55 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
        if (v55)
        {
          v56 = CFSTR("NetworkPredictorProperty_EnableMLTraining");
          v57 = *MEMORY[0x1E0C9AE40];
          v58 = v54;
          goto LABEL_200;
        }
        goto LABEL_282;
      }
      if (FigMediaPlaylistGetPlaylistType(*v323) != 2)
      {
        v95 = *(_QWORD *)(a2 + 96);
        v96 = *(uint64_t (**)(uint64_t, __CFString *, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
        if (v96)
        {
          v97 = *MEMORY[0x1E0C9AE40];
          v45 = v96(v95, CFSTR("NetworkPredictorProperty_EnableMLTraining"), *MEMORY[0x1E0C9AE40]);
          if (v45)
            goto LABEL_636;
          v98 = *(_QWORD *)(a2 + 96);
          v55 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                         + 56);
          if (v55)
          {
            v56 = CFSTR("NetworkPredictorProperty_EnableMLPredictions");
            v58 = v98;
            v57 = v97;
LABEL_200:
            v45 = v55(v58, v56, v57);
            if (!v45)
              goto LABEL_201;
LABEL_636:
            LODWORD(v20) = v45;
            goto LABEL_283;
          }
        }
LABEL_282:
        LODWORD(v20) = -12782;
        goto LABEL_283;
      }
    }
LABEL_201:
    v46 = 1;
    goto LABEL_63;
  }
  v310 = 0;
LABEL_64:
  if (v322)
  {
    v48 = *(_QWORD *)(a2 + 9048);
    if (v48)
    {
      v47 = *(_QWORD *)(a3 + 1072);
      v49 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                 + 56);
      if (v49)
      {
        v50 = CFSTR("MasterPlaylistDT");
        goto LABEL_72;
      }
    }
  }
  else
  {
    v47 = *(_QWORD *)(a3 + 1072);
    if (v47 > *(_QWORD *)(a2 + 9072))
    {
      *(_QWORD *)(a2 + 9072) = v47;
      v48 = *(_QWORD *)(a2 + 9048);
      if (v48)
      {
        v49 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
        if (v49)
        {
          v50 = CFSTR("MaxPlaylistDT");
LABEL_72:
          v49(v48, CFSTR("bytePumpStats"), v50, v47 / 0xF4240uLL, 0);
        }
      }
    }
  }
  if ((_DWORD)v20 || !*v323 && !*v321)
    goto LABEL_74;
  if (message && a5)
  {
    v59 = (const __CFString *)FigCFHTTPCreateURLString(*(const __CFURL **)(a3 + 16));
    DataLength = CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(a3 + 520));
    v61 = FigCFHTTPCreateCacheHeaders(v59, DataLength, message, 0, (CFDictionaryRef *)&v331);
    if (v59)
      CFRelease(v59);
    if (v61)
    {
      LODWORD(v20) = v61;
LABEL_283:
      v21 = v316;
      v22 = v317;
      goto LABEL_432;
    }
  }
  if ((v310 & 1) != 0)
  {
    v75 = *(_QWORD *)(a2 + 296);
    if (!v75)
    {
      v76 = (uint64_t *)(a3 + 56);
      if (!*v323)
        goto LABEL_418;
      if (!FigMediaPlaylistHasEndTag(*v323))
        goto LABEL_418;
      v77 = segPumpStreamHasMediaFiles(a3);
      if (!a5 || !v77)
        goto LABEL_418;
LABEL_278:
      if (*v76)
      {
        PlaylistType = FigMediaPlaylistGetPlaylistType(*v76);
        v135 = v310;
        if (PlaylistType)
          v136 = 0;
        else
          v136 = v310;
      }
      else
      {
        v136 = 0;
        v135 = v310;
      }
      v45 = segPumpSaveEntry(a2, *(const void **)(a3 + 24), 0, 0, *(CMBlockBufferRef *)(a3 + 520), v331, v135, v136, *(_QWORD *)(a3 + 1048));
      if (v45)
        goto LABEL_636;
      if (v322)
      {
        v210 = segPumpEnsurePlaylistCache(a2);
        if (v210
          || (v210 = FigStreamingCacheSetMasterPlaylist(*(_QWORD *)(a2 + 304), *(const void **)(a3 + 520), v331)) != 0)
        {
          LOBYTE(v322) = 1;
          LODWORD(v20) = v210;
          v21 = v316;
          v22 = v317;
          goto LABEL_433;
        }
      }
      goto LABEL_418;
    }
  }
  else
  {
    if (*v321)
    {
      v88 = *(const void **)(a2 + 8160);
      PlaylistVariables = (const void *)FigMultivariantPlaylistGetPlaylistVariables(*v321);
      *(_QWORD *)(a2 + 8160) = PlaylistVariables;
      if (PlaylistVariables)
        CFRetain(PlaylistVariables);
      if (v88)
        CFRelease(v88);
    }
    v75 = *(_QWORD *)(a2 + 296);
    if (!v75)
    {
      v76 = (uint64_t *)(a3 + 56);
      if (!a5)
        goto LABEL_418;
      goto LABEL_278;
    }
  }
  v90 = !v13;
  if (!a5)
    v90 = 1;
  if ((v90 & 1) == 0)
  {
    v45 = FigStreamingCacheSetMasterPlaylist(v75, *(const void **)(a3 + 520), v331);
    if (v45)
      goto LABEL_636;
  }
  if (!*v323)
    goto LABEL_418;
  if (!FigMediaPlaylistHasEndTag(*v323))
    goto LABEL_418;
  if (!*v323)
    goto LABEL_418;
  MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*v323);
  if (!MediaSegmentSpecifiers || CFArrayGetCount(MediaSegmentSpecifiers) < 1 || !*(_QWORD *)(a2 + 296))
    goto LABEL_418;
  if (!v318[719])
  {
    if (!v318[4])
      goto LABEL_418;
LABEL_533:
    v45 = segPumpEnsureCacheForStreamPossiblyEndingStream((uint64_t)a1, (uint64_t *)a3);
    if (v45)
      goto LABEL_636;
    if (*(_BYTE *)(a3 + 1136))
    {
      LODWORD(v20) = 0;
      goto LABEL_283;
    }
    if (a5)
    {
      if (*(_QWORD *)(a3 + 64))
      {
        v45 = segPumpSetPlaylistForStreamCache(a2, a3, *(const void **)(a3 + 520), v331);
        if (v45)
          goto LABEL_636;
      }
    }
    goto LABEL_418;
  }
  if (v318[3] && *(_QWORD *)(a2 + 384) == a3)
    goto LABEL_533;
LABEL_418:
  if (*(_QWORD *)(a2 + 8416) == *(_QWORD *)a3)
  {
    if (*v323)
    {
      v211 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*v323);
      if (v211)
      {
        if (CFArrayGetCount(v211) >= 1)
        {
          FigMediaPlaylistGetMediaSegmentSpecifiers(*v323);
          FirstValue = (const void *)FigCFArrayGetFirstValue();
          v213 = FirstValue;
          if (*(_QWORD *)(a2 + 8424))
          {
            v214 = *(const __CFURL **)(a3 + 16);
            v215 = *(const __CFURL **)(a3 + 24);
            MediaFilePrivateData = segPumpGetMediaFilePrivateData(FirstValue);
            segPumpEnsureMediaSegmentURLs(v213, v214, v215);
            if (MediaFilePrivateData[3])
            {
              v217 = *(const __CFURL **)(a2 + 8424);
              v218 = *(const __CFURL **)(a3 + 16);
              v219 = *(const __CFURL **)(a3 + 24);
              v220 = (const __CFURL **)segPumpGetMediaFilePrivateData(v213);
              segPumpEnsureMediaSegmentURLs(v213, v218, v219);
              if (!FigCFHTTPURLHostEqual(v217, v220[3]))
              {
                v221 = *(_QWORD *)(a2 + 9048);
                if (v221)
                {
                  v222 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                             + 32);
                  if (v222)
                    v222(v221, CFSTR("bytePumpStats"), CFSTR("MainHostSwitches"), 1);
                }
              }
            }
            v223 = *(const void **)(a2 + 8424);
          }
          else
          {
            v223 = 0;
          }
          v226 = *(const __CFURL **)(a3 + 16);
          v227 = *(const __CFURL **)(a3 + 24);
          v228 = segPumpGetMediaFilePrivateData(v213);
          segPumpEnsureMediaSegmentURLs(v213, v226, v227);
          v229 = (const void *)v228[3];
          *(_QWORD *)(a2 + 8424) = v229;
          if (v229)
            CFRetain(v229);
          if (v223)
            CFRelease(v223);
        }
      }
    }
  }
LABEL_74:
  v51 = *(const void **)(a3 + 520);
  if (v51)
  {
    CFRelease(v51);
    *(_QWORD *)(a3 + 520) = 0;
  }
  v52 = (uint64_t *)(a3 + 56);
  if ((_DWORD)v20)
    goto LABEL_77;
  if (!*(_QWORD *)a3)
  {
    v82 = *v323;
    if (!*v323)
      goto LABEL_165;
    for (i = 0; ; ++i)
    {
      ContentKeySpecifiers = (const __CFArray *)FigMediaPlaylistGetContentKeySpecifiers(v82);
      if (ContentKeySpecifiers)
        ContentKeySpecifiers = (const __CFArray *)CFArrayGetCount(ContentKeySpecifiers);
      if (i >= (uint64_t)ContentKeySpecifiers)
        goto LABEL_101;
      v85 = (const __CFArray *)FigMediaPlaylistGetContentKeySpecifiers(*v323);
      ValueAtIndex = CFArrayGetValueAtIndex(v85, i);
      if (FigContentKeySpecifierGetKeySystem((uint64_t)ValueAtIndex) == 1
        && (FigContentKeySpecifierGetEncryptionMethod((uint64_t)ValueAtIndex) == 2
         || FigContentKeySpecifierGetEncryptionMethod((uint64_t)ValueAtIndex) == 1))
      {
        break;
      }
      v82 = *v323;
    }
    v137 = *(_QWORD *)(a2 + 8144);
    if (v137)
    {
      v138 = *(_QWORD *)(v137 + 8);
      if (v138)
      {
        FigAlternateSetIsFairPlayStreamingVideoAlternate(v138, 1);
        if (!FigAlternateHasValidCodecs(*(_QWORD *)(*(_QWORD *)(a2 + 8144) + 8))
          || !FigAlternateWillPlayIfFairplayProtected(*(_QWORD *)(*(_QWORD *)(a2 + 8144) + 8)))
        {
          v20 = FigSignalErrorAt();
LABEL_77:
          if ((v20 & 0xFFFFFFFB) == 0xFFFFCE9A)
          {
            if ((_DWORD)v20 != -12646)
              segPumpAppendErrorLogEntry(v320, a2, a3, v315, (int)v20, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Playlist parse error"), 0, 0, 1u, 2u);
            if (!*(_QWORD *)(a2 + 8096))
              goto LABEL_283;
            v327 = 0;
            type = OS_LOG_TYPE_DEFAULT;
            v53 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT);
            v21 = v316;
            v22 = v317;
            fig_log_call_emit_and_clean_up_after_send_and_compose();
            v99 = segPumpHandleIndexFileNetworkError(v320, a3, v314, v20, CFSTR("CoreMediaErrorDomain"), CFSTR("playlist parse error."));
LABEL_203:
            LODWORD(v20) = v99;
            goto LABEL_432;
          }
          if ((_DWORD)v20 == -17633)
          {
            v22 = v317;
            if (*(_BYTE *)(a3 + 876))
            {
              *(_BYTE *)(a3 + 876) = 0;
              LODWORD(v20) = segPumpHandleIndexFileNetworkError(v320, a3, v314, 4294949663, CFSTR("CoreMediaErrorDomain"), CFSTR("Could not apply Playlist delta"));
            }
            else
            {
              segPumpAppendErrorLogEntry(v320, a2, a3, v315, -17633, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Did not request delta"), 0, 0, 1u, 1u);
              segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(*(_QWORD *)a2, 4294949663);
              LODWORD(v20) = 0;
            }
            goto LABEL_431;
          }
          if ((_DWORD)v20 == -12885)
          {
            v22 = v317;
            v14 = v318;
            a1 = (const void *)v320;
            if (dword_1EE2A31E8)
            {
              v327 = 0;
              type = OS_LOG_TYPE_DEFAULT;
              v66 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT);
              fig_log_call_emit_and_clean_up_after_send_and_compose();
              v22 = v317;
            }
            v21 = v316;
            if (*(_QWORD *)(a2 + 8416) == *(_QWORD *)a3 && *(_BYTE *)(a3 + 866) && *v323)
            {
              PlaylistActiveDurationSecs = FigMediaPlaylistGetPlaylistActiveDurationSecs(*v323);
              *(double *)(a3 + 96) = PlaylistActiveDurationSecs;
              *(double *)(a2 + 344) = PlaylistActiveDurationSecs;
              v24 = 1;
            }
            else
            {
              v24 = 0;
            }
            v20 = segPumpHandleIndexFileNetworkError(v320, a3, v314, 4294954411, CFSTR("CoreMediaErrorDomain"), CFSTR("unsupported crypt format."));
            v313 = 0;
            v23 = 1;
            goto LABEL_16;
          }
          if ((_DWORD)v20)
          {
            if (!*v29 || Count >= v43)
            {
              segPumpAppendErrorLogEntry(v320, a2, a3, v315, (int)v20, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Playlist error"), 0, 0, 1u, 1u);
              goto LABEL_283;
            }
            v92 = (__CFDictionary *)CFArrayGetValueAtIndex(*v29, v43 - 1);
            v22 = v317;
            if (v92)
            {
              v93 = v92;
              AllocatorForMedia = FigGetAllocatorForMedia();
              FigErrorLogSetSeverity(AllocatorForMedia, v93, 1);
            }
LABEL_431:
            v21 = v316;
            goto LABEL_432;
          }
        }
      }
    }
  }
LABEL_101:
  if (*v323)
  {
    v14 = v318;
    v62 = v318 + 719;
    if (v318[719])
    {
      v63 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*v323);
      a1 = (const void *)v320;
      if (!v63 || CFArrayGetCount(v63) <= 0)
        goto LABEL_167;
    }
    else
    {
      a1 = (const void *)v320;
    }
    goto LABEL_205;
  }
LABEL_165:
  if (!*v321)
  {
    v45 = FigSignalErrorAt();
    goto LABEL_636;
  }
  v14 = v318;
  a1 = (const void *)v320;
  if (v318[719])
  {
LABEL_167:
    v327 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    v87 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT);
    v21 = v316;
    v22 = v317;
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    segPumpAppendErrorLogEntry((uint64_t)a1, a2, a3, v315, -12642, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("no media files in stream playlist"), 0, 0, 1u, 1u);
    v99 = FigSignalErrorAt();
    goto LABEL_203;
  }
  v62 = v318 + 719;
LABEL_205:
  if (*(_BYTE *)(a3 + 861))
  {
    if (*(_BYTE *)(a3 + 864))
    {
      v100 = *(_QWORD *)(a2 + 16 * *(_QWORD *)(a2 + 8416) + 384);
      if (*(_QWORD *)(v100 + 56))
      {
        v342[0] = 0;
        *(_QWORD *)cf = 0;
        NextMediaFileWithDate = segPumpGetNextMediaFileWithDate(*v323, (double *)v342);
        v102 = segPumpGetNextMediaFileWithDate(*(_QWORD *)(v100 + 56), (double *)cf);
        if (NextMediaFileWithDate)
        {
          v103 = v102;
          if (v102)
          {
            DateStamp = FigMediaSegmentSpecifierGetDateStamp(NextMediaFileWithDate);
            v105 = MEMORY[0x194029D14](DateStamp);
            v106 = FigMediaSegmentSpecifierGetDateStamp(v103);
            v107 = MEMORY[0x194029D14](v106);
            *(double *)(a3 + 88) = *(double *)(v100 + 88) + v105 - *(double *)v342 - (v107 - *(double *)cf);
            *(_QWORD *)(a3 + 928) = 0;
          }
        }
      }
    }
  }
  v108 = FigGetUpTimeNanoseconds();
  if (!*v323)
  {
    LOBYTE(v305) = 0;
    v313 = 0;
    v110 = (double *)(a3 + 88);
    v111 = *(double *)(a3 + 88);
LABEL_285:
    v308 = 0x1E1338000;
    goto LABEL_294;
  }
  if (FigMediaPlaylistGetPlaylistActiveDurationSecs(*v323) == 0.0)
    v109 = 0;
  else
    v109 = 1000000000;
  v110 = (double *)(a3 + 88);
  v111 = *(double *)(a3 + 88);
  v112 = *(_QWORD *)(a3 + 56);
  if (!v112)
  {
    LOBYTE(v305) = 0;
    v313 = 0;
    goto LABEL_285;
  }
  v304 = v62;
  v306 = (double *)(a3 + 88);
  FigMediaPlaylistGetMediaSegmentSpecifiers(v112);
  v113 = FigCFArrayGetFirstValue();
  if (v113)
  {
    v114 = (const void *)v113;
    v313 = 0;
    v305 = 0;
    v115 = v109 + v108;
    v308 = 0x1E1338000;
    while (1)
    {
      NextSegment = FigMediaSegmentSpecifierGetNextSegment((uint64_t)v114);
      v117 = segPumpGetMediaFilePrivateData(v114);
      if (FigMediaSegmentSpecifierAreFragmentsExpired((uint64_t)v114))
      {
        PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v114);
        v119 = 0;
        if (!PartialSegments)
        {
LABEL_228:
          v122 = 0;
          goto LABEL_229;
        }
        while (1)
        {
          v122 = CFArrayGetCount(PartialSegments);
LABEL_229:
          if (v119 >= v122)
            break;
          v120 = CFArrayGetValueAtIndex(PartialSegments, v119);
          v121 = *(_QWORD **)(a3 + 680);
          if (v121)
          {
            while (!segPumpMediaConnectionIncludesMedia(a3, (uint64_t)v121, v120))
            {
              v121 = (_QWORD *)*v121;
              if (!v121)
                goto LABEL_224;
            }
          }
          else
          {
LABEL_224:
            if (*(const void **)(a3 + 264) != v120)
            {
              FigMediaPlaylistRemovePartSegmentSpecifier((_BYTE *)*v323, (uint64_t)v114, (uint64_t)v120);
              --v119;
            }
          }
          ++v119;
          if (!PartialSegments)
            goto LABEL_228;
        }
      }
      if (FigMediaSegmentSpecifierIsReadInCurrent((uint64_t)v114))
      {
        v52 = (uint64_t *)(a3 + 56);
        if (!FigMediaPlaylistHasEndTag(*v323))
        {
          if (v117[96])
          {
            *v306 = *v306 - FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v114);
            v117[96] = 0;
          }
          *((_QWORD *)v117 + 11) = v115;
          if (v308 == 0x1E1338000)
          {
            Current = CFAbsoluteTimeGetCurrent();
            v308 = (uint64_t)(Current + FigMediaPlaylistGetPlaylistActiveDurationSecs(*v323));
          }
          v313 = 1;
        }
        FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v114);
        if (FigCFArrayGetLastValue())
        {
          LastValue = (const void *)FigCFArrayGetLastValue();
          if (*((_BYTE *)segPumpGetMediaFilePrivateData(LastValue) + 73))
          {
            if (FigMediaSegmentSpecifierGetURLString((uint64_t)v114)
              && !FigMediaSegmentSpecifierIsFragment((uint64_t)v114)
              && !v117[73])
            {
              segPumpMarkMediaFileAsDelivered((uint64_t *)a3, v114);
            }
          }
        }
        goto LABEL_273;
      }
      if (!v117[96])
        *v306 = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v114) + *v306;
      v125 = *(_QWORD **)(a3 + 680);
      if (v125)
      {
LABEL_246:
        while (2)
        {
          if (segPumpMediaConnectionIncludesMedia(a3, (uint64_t)v125, v114))
            goto LABEL_267;
          v126 = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v114);
          v127 = 0;
          while (1)
          {
            v128 = v126 ? CFArrayGetCount(v126) : 0;
            if (v127 >= v128)
              break;
            v129 = CFArrayGetValueAtIndex(v126, v127++);
            if (segPumpMediaConnectionIncludesMedia(a3, (uint64_t)v125, v129))
            {
              v125 = (_QWORD *)*v125;
              if (v125)
                goto LABEL_246;
              goto LABEL_267;
            }
          }
          v125 = (_QWORD *)*v125;
          if (v125)
            continue;
          break;
        }
      }
      if (*(const void **)(a3 + 256) != v114 && *(const void **)(a3 + 264) != v114)
      {
        if (!*v304)
        {
          v130 = v305;
          if (!v117[73])
            v130 = 1;
          v305 = v130;
        }
        v52 = (uint64_t *)(a3 + 56);
        for (j = *(_QWORD **)(a3 + 680); j; j = (_QWORD *)*j)
        {
          if ((const void *)j[1] == v114)
            segPumpResetMediaConnection(a2, j, 1);
        }
        FigMediaPlaylistRemoveMediaSegmentSpecifier(*v323, (uint64_t)v114);
        goto LABEL_271;
      }
LABEL_267:
      v117[96] = 1;
      if (FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v114))
      {
        MapSegmentSpecifier = FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v114);
        FigMediaSegmentSpecifierSetIsReadInCurrent(MapSegmentSpecifier, 1);
      }
      v52 = (uint64_t *)(a3 + 56);
      if (FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v114))
      {
        ContentKeySpecifier = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v114);
        FigContentKeySpecifierSetIsReadInCurrent(ContentKeySpecifier, 1);
      }
LABEL_271:
      v22 = v317;
      if (FigMediaPlaylistGetPlaylistType(*v52) == 1)
      {
        LODWORD(v20) = FigSignalErrorAt();
        segPumpAppendErrorLogEntry(v320, a2, a3, v315, (int)v20, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Removing media file from EVENT playlist."), 0, 0, 1u, 1u);
        goto LABEL_431;
      }
      v313 = 1;
LABEL_273:
      v114 = (const void *)NextSegment;
      if (!NextSegment)
      {
        a1 = (const void *)v320;
        v14 = v318;
        goto LABEL_293;
      }
    }
  }
  LOBYTE(v305) = 0;
  v313 = 0;
  v308 = 0x1E1338000;
LABEL_293:
  v110 = (double *)(a3 + 88);
LABEL_294:
  v307 = v110;
  segPumpPlaylistRecalculatePumpTimeOffsets(*v52, *v110);
  if ((v310 & 1) != 0)
    v139 = segPumpSetupCommonCryptKeyData(a2, (uint64_t *)a3, *(_BYTE **)(a3 + 56), *(_QWORD *)(a2 + 8144));
  else
    v139 = segPumpSetupCommonCryptKeyDataForSessionKeys(a2, *v321);
  v20 = v139;
  if ((_DWORD)v139)
    goto LABEL_639;
  if (*v52)
  {
    FigMediaPlaylistGetMapSegmentSpecifiers(*v52);
    v140 = FigCFArrayGetFirstValue();
    if (v140)
    {
      v141 = (const void *)v140;
      do
      {
        v142 = FigMediaSegmentSpecifierGetNextSegment((uint64_t)v141);
        if (!FigMediaSegmentSpecifierIsReadInCurrent((uint64_t)v141))
        {
          v143 = *(_QWORD *)(a3 + 696);
          if (!v143 || (v144 = *(_QWORD *)(v143 + 8)) == 0 || FigMediaSegmentSpecifierGetType(v144) != 1)
          {
            v342[0] = 0;
            *(_QWORD *)cf = 0;
            *((_BYTE *)segPumpGetMediaFilePrivateData(v141) + 98) = 0;
            if (!segPumpCreateCacheNameFromSegment(a3, (uint64_t)v141, cf, v342))
            {
              v145 = *(_QWORD *)(a2 + 296);
              if (v145)
              {
                v146 = *(CFMutableDictionaryRef **)(a3 + 64);
                v147 = v342[0];
                StartOffset = FigMediaSegmentSpecifierGetStartOffset((uint64_t)v141);
                MediaSequence = FigMediaSegmentSpecifierGetMediaSequence((uint64_t)v141);
                v150 = StartOffset;
                v52 = (uint64_t *)(a3 + 56);
                FigStreamingCacheRemoveMediaMap(v145, v146, (uint64_t)v147, v150, MediaSequence);
              }
              v151 = *(const void **)cf;
              v152 = FigMediaSegmentSpecifierGetStartOffset((uint64_t)v141);
              v153 = FigMediaSegmentSpecifierGetBytesToRead((uint64_t)v141);
              SavedEntry = (CFTypeRef *)segPumpFindSavedEntry(a2, v151, v152, v153);
              if (SavedEntry)
                segPumpFreeSavedEntry(a2, SavedEntry);
            }
            if (*(_QWORD *)cf)
              CFRelease(*(CFTypeRef *)cf);
            if (v342[0])
              CFRelease(v342[0]);
            FigMediaPlaylistRemoveMapSegmentSpecifier(*v52, (uint64_t)v141);
          }
        }
        v141 = (const void *)v142;
      }
      while (v142);
    }
  }
  if (!*(_QWORD *)(a2 + 296)
    || !*v52
    || (v155 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*v52)) == 0
    || CFArrayGetCount(v155) < 1
    || !FigMediaPlaylistHasEndTag(*v52)
    || (FigMediaPlaylistGetMediaSegmentSpecifiers(*v52),
        v156 = (const void *)FigCFArrayGetFirstValue(),
        *((_QWORD *)segPumpGetMediaFilePrivateData(v156) + 16)))
  {
LABEL_347:
    v21 = v316;
    if (v14[2] && *(_BYTE *)(a3 + 869) && (_BYTE)v305)
    {
      v186 = *(_QWORD *)a3;
      v22 = v317;
      if (*(_QWORD *)a3 == *(_QWORD *)(a2 + 8416))
      {
        segPumpStopPlaylistReadsAndResetAllData(a2);
        v20 = 0;
        v23 = 0;
        v24 = 0;
LABEL_17:
        if (!*(_BYTE *)(a3 + 868))
        {
          v64 = *(_QWORD *)(a3 + 56);
          if (v64)
          {
            v65 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v64);
            if (v65)
            {
              if (CFArrayGetCount(v65) >= 1)
                *(_BYTE *)(a3 + 868) = 1;
            }
          }
        }
        if (v24)
          segPumpReadyNotification((_QWORD *)a2, CFSTR("FBP_DurationChanged"), 0);
        if (v313)
          segPumpReadyNotification((_QWORD *)a2, CFSTR("FBPAL_SeekableTimeRangeChanged"), 0);
        if ((v332 & 8) != 0 && *(_QWORD *)a3 == *(_QWORD *)(a2 + 8416))
          segPumpReadyNotification((_QWORD *)a2, CFSTR("FBP_TaggedRangeMetadataChanged"), 0);
        if (*(_BYTE *)(a3 + 866) || (v20 = segPumpReadOrScheduleIndexFileRead((uint64_t)a1, a2, a3), !(_DWORD)v20))
        {
          if (v14[691])
          {
            MediaForSingleStream = segPumpDeliverNextMediaForSingleStream(a1, a2, a3);
            if ((_DWORD)MediaForSingleStream == -12644)
            {
              if (*(_BYTE *)(a3 + 864))
                v20 = 0;
              else
                v20 = 4294954652;
            }
            else
            {
              v20 = MediaForSingleStream;
              if ((_DWORD)MediaForSingleStream == -12642)
              {
                v20 = segPumpHandleIndexFileNetworkError(a1, a3, v314, 4294954654, CFSTR("CoreMediaErrorDomain"), CFSTR("No matching mediaFile found from playlist"));
                if ((_DWORD)v20)
                  goto LABEL_148;
              }
              else if ((_DWORD)MediaForSingleStream == -15626)
              {
                goto LABEL_148;
              }
            }
          }
          if (*(_QWORD *)a3 != *(_QWORD *)(a2 + 8416))
            goto LABEL_147;
          if (v14[12])
            goto LABEL_147;
          v78 = *(_QWORD *)(a3 + 56);
          if (!v78 || FigMediaPlaylistGetDateStampCount(v78) < 1 || !*(_QWORD *)(a2 + 168))
            goto LABEL_147;
          v79 = v21;
          v80 = *(_QWORD *)(a3 + 880);
          v20 = segPumpSendDateMapping((uint64_t)a1, a2, (unsigned __int8 *)a3);
          if ((_DWORD)v20)
          {
            v21 = v79;
            goto LABEL_148;
          }
          v81 = v80 == *(_QWORD *)(a3 + 880);
          v21 = v79;
          if (v81)
LABEL_147:
            segPumpUpdateNetworkCostHasEndTag(a2);
        }
LABEL_148:
        if (!v23)
          goto LABEL_438;
LABEL_432:
        if (!v322)
        {
          v224 = segPumpSetupCommonCryptKeyData(a2, (uint64_t *)a3, *(_BYTE **)(a3 + 56), *(_QWORD *)(a2 + 8144));
          LOBYTE(v322) = 0;
LABEL_435:
          if ((_DWORD)v20)
            v20 = v20;
          else
            v20 = v224;
          goto LABEL_438;
        }
LABEL_433:
        v224 = segPumpSetupCommonCryptKeyDataForSessionKeys(a2, *v321);
        goto LABEL_435;
      }
    }
    else
    {
      v186 = *(_QWORD *)a3;
      v22 = v317;
    }
    if (!v186 && v14[720])
      *(float64x2_t *)(a2 + 8720) = vaddq_f64(*(float64x2_t *)(a2 + 8720), (float64x2_t)vdupq_lane_s64(COERCE__INT64(*v307 - v111), 0));
    if (v308 != 0x1E1338000)
      segPumpSetMediaFileExpireTimer(a2, (double)v308);
    if (!v14[691] && !v14[692] && *v52 && FigMediaPlaylistHasStartTime(*v52))
    {
      v14[692] = 1;
      v14[693] = FigMediaPlaylistIsStartTimePrecise(*v52);
      *(double *)(a2 + 8688) = FigMediaPlaylistGetStartTimeValue(*v52);
    }
    if ((v332 & 1) != 0)
    {
      Alternates = (const __CFArray *)FigMultivariantPlaylistGetAlternates(*v321);
      if (Alternates)
      {
        v188 = CFArrayGetCount(Alternates);
        if (v188 >= 1)
        {
          v189 = v188;
          v190 = 0;
          while (1)
          {
            v191 = (const __CFArray *)FigMultivariantPlaylistGetAlternates(*v321);
            v192 = CFArrayGetValueAtIndex(v191, v190);
            v193 = segPumpAddFigAlternate(a2, v192);
            if ((_DWORD)v193)
              goto LABEL_631;
            if (v189 == ++v190)
            {
              v194 = 0;
              goto LABEL_372;
            }
          }
        }
      }
      v194 = 1;
LABEL_372:
      if (FigMultivariantPlaylistGetMediaSelectionArray(*v321))
      {
        v195 = *(const void **)(a2 + 8376);
        MediaSelectionArray = (const void *)FigMultivariantPlaylistGetMediaSelectionArray(*v321);
        *(_QWORD *)(a2 + 8376) = MediaSelectionArray;
        if (MediaSelectionArray)
          CFRetain(MediaSelectionArray);
        if (v195)
          CFRelease(v195);
      }
      HasIndependentSegments = FigMultivariantPlaylistHasIndependentSegments(*v321);
      v14[15] = HasIndependentSegments;
      for (k = 384; k != 432; k += 16)
        *(_BYTE *)(*(_QWORD *)(a2 + k) + 872) = HasIndependentSegments;
      v21 = v316;
      if ((v194 & 1) == 0)
      {
        segPumpReadyNotification((_QWORD *)a2, CFSTR("FBPAL_AlternateListChanged"), 0);
        inited = segPumpInitAlternateSelectionBoss((uint64_t)a1, a2);
        if ((_DWORD)inited)
          goto LABEL_476;
      }
      if (v14[1])
      {
        inited = segPumpReadNextCryptKeyForStream((uint64_t)a1, a2, (_QWORD *)a3);
        if ((_DWORD)inited)
          goto LABEL_476;
      }
    }
    else
    {
      if (*(_BYTE *)(a3 + 866) && *(_QWORD *)a3 == *(_QWORD *)(a2 + 8416))
      {
        segPumpSetTargetDurationAndType((uint64_t)a1, a2, *(_QWORD *)(a3 + 56));
        segPumpRTCReportingRespondToFirstIndexFileWithMedia(a2, (_QWORD *)a3);
      }
      segPumpSetPartTargetDuration(a2, *v52);
      segPumpSetActiveHoldBack(a2, *v52);
    }
    if (!*v52)
      goto LABEL_483;
    if (FigMediaPlaylistHasEndTag(*v52) && (*(_QWORD *)(a3 + 360) & 0x8000000000000000) == 0)
    {
      *(_QWORD *)(a3 + 360) = -1;
      *(_QWORD *)(a3 + 368) = -1;
    }
    v200 = *(_QWORD *)(a3 + 56);
    if (!v200
      || (v201 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v200)) == 0
      || CFArrayGetCount(v201) < 1
      || (*(_DWORD *)(a3 + 160) - 4) < 3)
    {
LABEL_483:
      if ((v332 & 2) == 0)
      {
        v24 = 0;
        v233 = v314;
LABEL_571:
        if ((*(_QWORD *)(a3 + 360) & 0x8000000000000000) == 0)
        {
          v279 = (uint64_t *)(a3 + 360);
          if (*v52)
          {
            v280 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*v52);
            if (v280)
            {
              if (CFArrayGetCount(v280) >= 1 && (*v279 & 0x8000000000000000) == 0)
              {
                FigMediaPlaylistGetMediaSegmentSpecifiers(*v52);
                v281 = FigCFArrayGetLastValue();
                v282 = FigMediaSegmentSpecifierGetMediaSequence(v281);
                v283 = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments(v281);
                if (v283)
                  v283 = (const __CFArray *)CFArrayGetCount(v283);
                if (v282 < *v279 || v282 == *v279 && (uint64_t)v283 <= *(_QWORD *)(a3 + 368))
                {
                  v20 = segPumpHandleIndexFileNetworkError(a1, a3, v233, 4294951880, CFSTR("CoreMediaErrorDomain"), CFSTR("Blocking Playlist Reload failed"));
                  v23 = 0;
                  v21 = v316;
                  v22 = v317;
                  goto LABEL_16;
                }
              }
            }
          }
          *v279 = -1;
          *(_QWORD *)(a3 + 368) = -1;
        }
        v22 = v317;
        if (!*(_QWORD *)(a3 + 792))
          goto LABEL_593;
        if (segPumpStreamHasPreloadHint(a3))
        {
          PreloadHint = (const void *)FigMediaPlaylistGetPreloadHint(*(_QWORD *)(a3 + 56));
          v285 = segPumpStreamHasPreloadConnectionForSegment((_QWORD *)a3, PreloadHint, 0) != 0;
        }
        else
        {
          v285 = 0;
        }
        v193 = segPumpRealizePreload((uint64_t)a1, (_QWORD *)a3);
        if (!(_DWORD)v193)
        {
          if (*(_QWORD *)(a3 + 792))
            v286 = v285;
          else
            v286 = 1;
          if ((v286 & 1) == 0)
            segPumpStreamCancelPreloadReadAndResetData(a2, a3);
LABEL_593:
          v21 = v316;
          if (!*(_QWORD *)(a3 + 800))
            goto LABEL_617;
          if (segPumpStreamHasPreloadMapHint(a3))
          {
            PreloadMapHint = (const void *)FigMediaPlaylistGetPreloadMapHint(*(_QWORD *)(a3 + 56));
            v288 = segPumpStreamHasPreloadConnectionForMap((_QWORD *)a3, PreloadMapHint) != 0;
          }
          else
          {
            v288 = 0;
          }
          if (segPumpShouldDoSegmentReadAheads((_BYTE *)a2))
          {
            v289 = 0;
            while (1)
            {
              MapSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMapSegmentSpecifiers(*v323);
              if (MapSegmentSpecifiers)
                MapSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MapSegmentSpecifiers);
              if (v289 >= (uint64_t)MapSegmentSpecifiers)
                goto LABEL_612;
              v291 = (const __CFArray *)FigMediaPlaylistGetMapSegmentSpecifiers(*(_QWORD *)(a3 + 56));
              v292 = CFArrayGetValueAtIndex(v291, v289++);
              if (segPumpStreamHasPreloadConnectionForMap((_QWORD *)a3, v292))
              {
                if (v292)
                {
                  v293 = *(_QWORD *)(a3 + 776);
                  if (v293 >= 1)
                  {
                    v294 = 0;
                    while (*(_QWORD *)(*(_QWORD *)(a3 + 768) + 8 * v294))
                    {
                      if (v293 == ++v294)
                        goto LABEL_612;
                    }
                    v295 = *(_QWORD *)(a3 + 800);
                    v296 = *(const void **)(v295 + 8);
                    *(_QWORD *)(v295 + 8) = v292;
                    CFRetain(v292);
                    if (v296)
                      CFRelease(v296);
                    *(_QWORD *)(*(_QWORD *)(a3 + 768) + 8 * v294) = *(_QWORD *)(a3 + 800);
                    *(_QWORD *)(a3 + 800) = 0;
                  }
                }
                goto LABEL_612;
              }
            }
          }
          started = FigSignalErrorAt();
          if (!(_DWORD)started)
          {
LABEL_612:
            if (*(_QWORD *)(a3 + 800))
              v297 = v288;
            else
              v297 = 1;
            v21 = v316;
            v22 = v317;
            v52 = (uint64_t *)(a3 + 56);
            if ((v297 & 1) == 0)
              segPumpStreamCancelPreloadMapReadAndResetData(a2, a3);
LABEL_617:
            if (*v52)
            {
              RenditionReportSpecifiers = (const __CFArray *)FigMediaPlaylistGetRenditionReportSpecifiers(*v52);
              if (RenditionReportSpecifiers)
              {
                if (CFArrayGetCount(RenditionReportSpecifiers) >= 1)
                {
                  v299 = (const __CFArray *)FigMediaPlaylistGetRenditionReportSpecifiers(*v52);
                  segPumpReconcileGapRenditionReports(a2, v299);
                }
              }
            }
            if (*(_QWORD *)(a2 + 9560) && *(_BYTE *)(a2 + 329))
            {
              v342[0] = COERCE_CFTYPEREF(segPumpGetEstIndependentInterval(a2));
              v300 = CFNumberCreate(allocator, kCFNumberDoubleType, v342);
              if (!v300)
              {
                v20 = FigSignalErrorAt();
                if ((_DWORD)v20)
                  goto LABEL_639;
                v23 = 0;
                v21 = v316;
                v22 = v317;
                a1 = (const void *)v320;
                v14 = v318;
                goto LABEL_16;
              }
              v301 = v300;
              v302 = *(_QWORD *)(a2 + 9560);
              v303 = *(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                 + 8)
                                                                                     + 56);
              if (v303)
                v303(v302, CFSTR("AfmfpbProperty_EstimatedGOPInterval"), v301);
              CFRelease(v301);
              v21 = v316;
            }
            v20 = 0;
            v23 = 0;
            goto LABEL_16;
          }
LABEL_638:
          v20 = started;
          goto LABEL_639;
        }
LABEL_631:
        v20 = v193;
        v21 = v316;
        goto LABEL_438;
      }
      if (*(uint64_t *)(a3 + 352) >= 1)
      {
        inited = segPumpCalculateDiscoDomainOffset((_QWORD *)a3, (uint64_t *)(a3 + 312));
        if ((_DWORD)inited)
        {
LABEL_476:
          v20 = inited;
          goto LABEL_438;
        }
        if (dword_1EE2A31E8)
        {
          v327 = 0;
          type = OS_LOG_TYPE_DEFAULT;
          v234 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(v234, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        segPumpFreeDiscoQueue(a3 + 336);
        *(_QWORD *)(a3 + 352) = 0;
      }
      v235 = *(_QWORD *)(a3 + 56);
      if (*(_QWORD *)a3 == *(_QWORD *)(a2 + 8416))
      {
        segPumpSetTargetDurationAndType((uint64_t)a1, a2, v235);
        v235 = *v52;
        v236 = message;
        if ((*(_QWORD *)(a2 + 368) & 0x8000000000000000) != 0)
        {
          *(_QWORD *)(a2 + 368) = *(_QWORD *)(a3 + 448);
          *(_QWORD *)(a2 + 368) = (uint64_t)((double)*(uint64_t *)(a2 + 368)
                                          + FigMediaPlaylistGetPlaylistActiveDurationSecs(v235) * -1000000000.0);
          *(_BYTE *)(a2 + 376) = 0;
          v235 = *(_QWORD *)(a3 + 56);
        }
        v233 = v314;
      }
      else
      {
        v233 = v314;
        v236 = message;
      }
      segPumpSetPartTargetDuration(a2, v235);
      segPumpSetActiveHoldBack(a2, *v52);
      if (!v14[15])
      {
        v237 = 0;
        v238 = 1;
        do
        {
          v239 = *(_QWORD *)(a2 + 384 + v237);
          v240 = *(_QWORD *)(v239 + 56);
          if (v240)
          {
            v241 = FigMediaPlaylistHasIndependentSegments(v240);
            *(_BYTE *)(v239 + 872) = v241;
            if (!v241)
              v238 = 0;
          }
          v237 += 16;
        }
        while (v237 != 48);
        v236 = message;
        if (v238)
          v14[15] = 1;
      }
      if (FigMediaPlaylistHasEndTag(*v52))
      {
        if (!v14[9])
        {
          v14[9] = 1;
          if (!*(_BYTE *)(a3 + 866))
            v14[10] = 1;
        }
      }
      *(_QWORD *)(a3 + 1056) = *(_QWORD *)(a3 + 448);
      *(_DWORD *)(a3 + 384) = 0;
      if (*(_BYTE *)(a2 + 328))
      {
        if (*(_QWORD *)a3 == *(_QWORD *)(a2 + 8416))
        {
          v342[0] = 0;
          v242 = segPumpGetNextMediaFileWithDate(*v52, (double *)v342);
          if (v242)
          {
            v243 = FigMediaSegmentSpecifierGetDateStamp(v242);
            v244 = MEMORY[0x194029D14](v243);
            v245 = FigMediaPlaylistGetPlaylistActiveDurationSecs(*v52);
            CMTimeMake(&v325, (uint64_t)((v244 + v245 - *(double *)v342) * 1000000000.0), 1000000000);
            HostTimeClock = CMClockGetHostTimeClock();
            CMClockGetTime(&v324, HostTimeClock);
            segPumpSendPlaylistUpdateNotification((_QWORD *)a2);
          }
        }
      }
      v247 = *(double *)(a3 + 96);
      if (v247 != FigMediaPlaylistGetPlaylistActiveDurationSecs(*(_QWORD *)(a3 + 56)))
      {
        v249 = FigMediaPlaylistGetPlaylistActiveDurationSecs(*(_QWORD *)(a3 + 56));
        *(double *)(a3 + 96) = v249;
        if (*(_QWORD *)(a2 + 8416) == *(_QWORD *)a3)
        {
          v248 = *(double *)(a2 + 344);
          if (v248 != v249)
          {
            if (v249 > v248 || (LODWORD(v250) = *(_DWORD *)(a2 + 8), v248 = v248 - (double)v250, v249 <= v248))
            {
              if (dword_1EE2A31E8)
              {
                v327 = 0;
                type = OS_LOG_TYPE_DEFAULT;
                v258 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                v259 = v327;
                if (os_log_type_enabled(v258, type))
                  v260 = v259;
                else
                  v260 = v259 & 0xFFFFFFFE;
                if (v260)
                {
                  v261 = *(const __CFString **)(a2 + 8760);
                  v262 = *(_QWORD *)a3;
                  if (!v261)
                    v261 = &stru_1E2FD85F8;
                  v263 = *(const __CFString **)(a2 + 344);
                  v264 = *(_QWORD *)(a3 + 96);
                  *(_DWORD *)cf = 136316162;
                  *(_QWORD *)&cf[4] = "segPumpParseIndexFile2";
                  v334 = 2114;
                  v335 = v261;
                  v336 = 2048;
                  v337 = v262;
                  v338 = 2048;
                  v339 = v263;
                  v340 = 2048;
                  v341 = v264;
                  _os_log_send_and_compose_impl();
                }
                v236 = message;
                fig_log_call_emit_and_clean_up_after_send_and_compose();
                v249 = *(double *)(a3 + 96);
              }
              *(double *)(a2 + 344) = v249;
              v24 = 1;
              v313 = 1;
              goto LABEL_544;
            }
            if (dword_1EE2A31E8)
            {
              v327 = 0;
              type = OS_LOG_TYPE_DEFAULT;
              v251 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              v252 = v327;
              if (os_log_type_enabled(v251, type))
                v253 = v252;
              else
                v253 = v252 & 0xFFFFFFFE;
              if (v253)
              {
                v254 = *(const __CFString **)(a2 + 8760);
                v255 = *(_QWORD *)a3;
                if (!v254)
                  v254 = &stru_1E2FD85F8;
                v256 = *(const __CFString **)(a3 + 96);
                v257 = *(_QWORD *)(a2 + 344);
                *(_DWORD *)cf = 136316162;
                *(_QWORD *)&cf[4] = "segPumpParseIndexFile2";
                v334 = 2114;
                v335 = v254;
                v336 = 2048;
                v337 = v255;
                v338 = 2048;
                v339 = v256;
                v340 = 2048;
                v341 = v257;
                _os_log_send_and_compose_impl();
              }
              v236 = message;
              fig_log_call_emit_and_clean_up_after_send_and_compose();
            }
          }
        }
      }
      v24 = 0;
LABEL_544:
      v265 = *(_QWORD *)(a2 + 296);
      if (v265)
      {
        v266 = 0;
        v267 = 0.0;
        v268 = INFINITY;
        do
        {
          v269 = *(_QWORD *)(a2 + 384 + v266);
          if (*(_QWORD *)(v269 + 16))
          {
            v270 = *(double *)(v269 + 88);
            if (v268 > v270)
              v268 = *(double *)(v269 + 88);
            v271 = v270 + *(double *)(v269 + 96);
            if (v267 < v271)
              v267 = v271;
          }
          v266 += 16;
        }
        while (v266 != 48);
        FigStreamingCacheSetCacheTimeRange(v265, v268, v267);
      }
      if (*(_BYTE *)(a3 + 866) && v14[691])
        segPumpSetStartingOffset(a1, a2, a3);
      if (*(_QWORD *)a3 == *(_QWORD *)(a2 + 8416))
      {
        if (*(_BYTE *)(a2 + 376))
        {
          *(_BYTE *)(a2 + 376) = 0;
          if (!v14[9] && !*(_DWORD *)(a2 + 24))
          {
            v272 = *v307;
            if (*v307 > 0.0)
            {
              v248 = (double)*(uint64_t *)(a3 + 448) + (v272 + *(double *)(a3 + 96)) * -1000000000.0;
              v273 = (uint64_t)v248;
              v274 = *(_QWORD *)(a2 + 368);
              v275 = *(_DWORD *)(a2 + 8);
              v276 = v274 + 1000000000 * v275;
              v277 = v274 - 1000000000 * v275;
              if (v276 < (uint64_t)v248 || v277 > v273)
              {
                v248 = (double)(uint64_t)(v273 - v274) / 1000000000.0;
                *v307 = v272 + v248;
              }
            }
          }
        }
      }
      if (!*(_BYTE *)(a3 + 875))
      {
        LODWORD(v248) = *(_DWORD *)(a2 + 8);
        if (*v307 > (double)*(unint64_t *)&v248 * 3.0 && !segPumpIsIndexFileResponseOutOfDate(a2, a3, v236))
          *(_BYTE *)(a3 + 875) = 1;
      }
      goto LABEL_571;
    }
    if (!*(_BYTE *)(a2 + 329))
    {
      *(_DWORD *)(a3 + 160) = 5;
      goto LABEL_483;
    }
    IntValue = 0.0;
    v203 = (int)message;
    if (!message)
    {
      v207 = 0;
      goto LABEL_459;
    }
    v204 = CFHTTPMessageCopyHeaderFieldValue(message, CFSTR("Age"));
    v205 = CFHTTPMessageCopyHeaderFieldValue(message, CFSTR("ms-in-cache"));
    v203 = v205 != 0;
    if (v205)
    {
      v206 = v205;
      IntValue = (double)CFStringGetIntValue(v205) / 1000.0;
      if (v204)
      {
        CFRelease(v204);
        v207 = 1;
      }
      else
      {
        v207 = 0;
      }
    }
    else
    {
      if (!v204)
      {
        v203 = 0;
        v207 = 0;
        goto LABEL_458;
      }
      IntValue = (double)CFStringGetIntValue(v204);
      v207 = 1;
      v206 = v204;
    }
    CFRelease(v206);
LABEL_458:
    v21 = v316;
LABEL_459:
    v230 = *(_DWORD *)(a3 + 160);
    if (v230)
    {
      if (v230 != 2)
        goto LABEL_472;
      if (((v203 | v207) & 1) != 0)
      {
LABEL_462:
        *(_QWORD *)(a3 + 176) = FigGetUpTimeNanoseconds();
        *(double *)(a3 + 184) = IntValue;
        v22 = v317;
        if (!v203 && FigMediaPlaylistGetPartTargetDuration(*v52) < 1.0)
          *(double *)(a3 + 184) = *(double *)(a3 + 184) + 1.0;
        *(double *)(a3 + 168) = segPumpPlaylistGetEndDateOfLastPart(*(_QWORD *)(a3 + 56));
        if (*(_DWORD *)(a3 + 160) != 3)
          *(_DWORD *)(a3 + 160) = 3;
LABEL_473:
        if (*(int *)(a3 + 200) <= 5)
        {
          if (IntValue < floor(FigMediaPlaylistGetPartTargetDuration(*v52))
            || (*(double *)(a3 + 192) = *(double *)(a3 + 184)
                                      - (segPumpPlaylistGetEndDateOfLastPart(*(_QWORD *)(a3 + 56))
                                       - *(double *)(a3 + 168)),
                v232 = *(double *)(a3 + 192)
                     + (double)(FigGetUpTimeNanoseconds() - *(_QWORD *)(a3 + 176)) / 1000000000.0,
                *(double *)(a3 + 192) = v232,
                v232 <= FigMediaPlaylistGetPartTargetDuration(*(_QWORD *)(a3 + 56))))
          {
            if (*(_DWORD *)(a3 + 160) != 4)
              *(_DWORD *)(a3 + 160) = 4;
            segPumpSetStartingOffset(a1, a2, a3);
          }
          else
          {
            ++*(_DWORD *)(a3 + 200);
          }
        }
        else
        {
          *(_DWORD *)(a3 + 160) = 6;
          v231 = segPumpSetupBlockingReload((uint64_t)a1, a2, a3);
          if ((_DWORD)v231)
          {
            inited = segPumpHandleIndexFileNetworkError(a1, a3, v314, v231, CFSTR("CoreMediaErrorDomain"), CFSTR("tuneIn failed"));
            if ((_DWORD)inited)
              goto LABEL_476;
          }
        }
        goto LABEL_483;
      }
    }
    else
    {
      if ((v203 | v207) == 1 && !v14[691])
      {
        *(_DWORD *)(a3 + 160) = 1;
        v22 = v317;
        goto LABEL_483;
      }
      *(_DWORD *)(a3 + 160) = 2;
      *(_OWORD *)(a3 + 168) = 0u;
      *(_OWORD *)(a3 + 184) = 0u;
      *(_DWORD *)(a3 + 200) = 0;
      if (v203 | v207)
        goto LABEL_462;
    }
    *(_DWORD *)(a3 + 160) = 4;
    segPumpSetStartingOffset(a1, a2, a3);
    v230 = *(_DWORD *)(a3 + 160);
LABEL_472:
    v22 = v317;
    if (v230 != 3)
      goto LABEL_483;
    goto LABEL_473;
  }
  v157 = (const __CFAllocator *)FigGetAllocatorForMedia();
  Mutable = CFDictionaryCreateMutable(v157, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
  {
    v20 = FigSignalErrorAt();
    Copy = 0;
    goto LABEL_334;
  }
  v159 = Mutable;
  v160 = 0;
  v161 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  while (1)
  {
    v162 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*v323);
    if (v162)
      v162 = (const __CFArray *)CFArrayGetCount(v162);
    if (v160 >= (uint64_t)v162)
    {
      v173 = (const __CFAllocator *)FigGetAllocatorForMedia();
      Copy = CFDictionaryCreateCopy(v173, v159);
      v20 = 0;
      goto LABEL_333;
    }
    v163 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*v323);
    v164 = CFArrayGetValueAtIndex(v163, v160);
    segPumpGetMediaFilePrivateData(v164);
    URLString = FigMediaSegmentSpecifierGetURLString((uint64_t)v164);
    v166 = FigMediaSegmentSpecifierGetStartOffset((uint64_t)v164);
    v167 = (const __CFAllocator *)FigGetAllocatorForMedia();
    v168 = CFStringCreateWithFormat(v167, 0, CFSTR("%@-%lld"), URLString, v166);
    if (!v168)
    {
      v20 = FigSignalErrorAt();
      goto LABEL_633;
    }
    v169 = v168;
    if (!CFDictionaryGetValue(v159, v168))
      break;
LABEL_331:
    FigCFArrayAppendDouble();
    CFRelease(v169);
    ++v160;
    a1 = (const void *)v320;
    v14 = v318;
  }
  v170 = (const __CFAllocator *)FigGetAllocatorForMedia();
  v171 = CFArrayCreateMutable(v170, 0, v161);
  if (v171)
  {
    v172 = v171;
    CFDictionarySetValue(v159, v169, v171);
    CFRelease(v172);
    goto LABEL_331;
  }
  v20 = FigSignalErrorAt();
  CFRelease(v169);
LABEL_633:
  Copy = 0;
  a1 = (const void *)v320;
  v14 = v318;
LABEL_333:
  CFRelease(v159);
LABEL_334:
  v52 = (uint64_t *)(a3 + 56);
  if ((_DWORD)v20)
  {
LABEL_344:
    if (!Copy)
      goto LABEL_346;
    goto LABEL_345;
  }
  for (m = 0; ; ++m)
  {
    v176 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*v52);
    if (v176)
      v176 = (const __CFArray *)CFArrayGetCount(v176);
    if (m >= (uint64_t)v176)
    {
      v20 = 0;
      goto LABEL_344;
    }
    v177 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*v52);
    v178 = CFArrayGetValueAtIndex(v177, m);
    v179 = segPumpGetMediaFilePrivateData(v178);
    v180 = FigMediaSegmentSpecifierGetURLString((uint64_t)v178);
    v181 = FigMediaSegmentSpecifierGetStartOffset((uint64_t)v178);
    v182 = (const __CFAllocator *)FigGetAllocatorForMedia();
    v183 = CFStringCreateWithFormat(v182, 0, CFSTR("%@-%lld"), v180, v181);
    if (!v183)
      break;
    v184 = v183;
    Value = CFDictionaryGetValue(Copy, v183);
    if (Value)
      Value = CFRetain(Value);
    v179[16] = Value;
    CFRelease(v184);
    v52 = (uint64_t *)(a3 + 56);
  }
  v20 = FigSignalErrorAt();
  v52 = (uint64_t *)(a3 + 56);
  if (Copy)
LABEL_345:
    CFRelease(Copy);
LABEL_346:
  if (!(_DWORD)v20)
    goto LABEL_347;
LABEL_639:
  v21 = v316;
  v22 = v317;
LABEL_438:
  if (a7)
    *a7 = v322;
  if (v331)
    CFRelease(v331);
  if (v22)
    CFRelease(v22);
  if (v21)
    CFRelease(v21);
  if (v328)
    CFRelease(v328);
  return v20;
}

uint64_t segPumpResumeRoundTripMonitoring(uint64_t a1)
{
  double v2;
  double v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  const void *PreloadHint;
  const __CFURL *v19;
  const __CFURL *v20;
  _QWORD *MediaFilePrivateData;
  const void *v22;
  const __CFURL *v23;
  const __CFURL *v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const void *v30;
  uint64_t (*v31)(uint64_t, uint64_t, uint64_t, void (*)(uint64_t, double, uint64_t, int), uint64_t, _QWORD, const void *);

  v2 = *(double *)(a1 + 16);
  if (v2 <= 0.0)
  {
    LODWORD(v2) = *(_DWORD *)(a1 + 8);
    v2 = (double)*(unint64_t *)&v2;
  }
  v3 = v2 * 0.5 * 1000000000.0;
  if ((uint64_t)v3 <= 1100000000)
    v4 = 1100000000;
  else
    v4 = (uint64_t)v3;
  result = FigGetUpTimeNanoseconds();
  v6 = *(_QWORD *)(a1 + 16 * *(_QWORD *)(a1 + 8416) + 384);
  if (!*(_BYTE *)(v6 + 1169))
  {
    v7 = result;
    v8 = *(_QWORD *)(a1 + 8600);
    if (v8 > *(_QWORD *)(a1 + 8608))
    {
      v9 = v8 + v4;
      if (v8 + v4 <= result + 5000000)
        v10 = result + 5000000;
      else
        v10 = v8 + v4;
      if (v8 + v4 >= result + 5000000)
        v11 = v8 + v4;
      else
        v11 = v9 + 1;
      v12 = (v10 - v11) / (unint64_t)v4;
      if (v9 < result + 5000000)
        ++v12;
      v13 = v8 + v4 + v4 * v12;
      goto LABEL_24;
    }
    if (result - v8 <= v4)
    {
LABEL_23:
      v13 = v7 + v4 + 5000000;
LABEL_24:
      if (v13 >= 1 && !*(_QWORD *)(a1 + 8616))
        return FigHTTPCreateTimer(*(const void **)a1, (uint64_t)RoundTripMonitorTimeoutTimer, *(NSObject **)(a1 + 64), (dispatch_object_t *)(a1 + 8616), (double)(v13 - v7) / 1000000000.0);
      return result;
    }
    v14 = 0;
    v15 = (uint64_t *)(a1 + 392);
    do
    {
      result = segPumpStreamHasActiveMediaRequest(*(v15 - 1));
      if ((_DWORD)result)
        goto LABEL_23;
      v16 = *v15;
      v15 += 2;
      result = segPumpStreamHasActiveMediaRequest(v16);
      if (v14 > 1)
        break;
      ++v14;
    }
    while (!(_DWORD)result);
    if ((_DWORD)result)
      goto LABEL_23;
    if (*(_BYTE *)(a1 + 327))
    {
      v17 = *(_QWORD *)(v6 + 16);
      if (segPumpStreamHasPreloadHint(v6))
      {
        PreloadHint = (const void *)FigMediaPlaylistGetPreloadHint(*(_QWORD *)(v6 + 56));
        v19 = *(const __CFURL **)(v6 + 16);
        v20 = *(const __CFURL **)(v6 + 24);
        MediaFilePrivateData = segPumpGetMediaFilePrivateData(PreloadHint);
        segPumpEnsureMediaSegmentURLs(PreloadHint, v19, v20);
        if (MediaFilePrivateData[2])
        {
          v22 = (const void *)FigMediaPlaylistGetPreloadHint(*(_QWORD *)(v6 + 56));
          v24 = *(const __CFURL **)(v6 + 16);
          v23 = *(const __CFURL **)(v6 + 24);
          v25 = segPumpGetMediaFilePrivateData(v22);
          segPumpEnsureMediaSegmentURLs(v22, v24, v23);
          v17 = v25[2];
        }
      }
      result = segPumpCustomURLLoaderGetURLGuts(a1, v17, 0, 0, 0, 1, 0, 0, 0, 0, 0, a1 + 8624);
      if ((_DWORD)result)
        return result;
    }
    else
    {
      v26 = *(_QWORD *)(a1 + 40);
      if (v26)
      {
        v27 = *(_QWORD *)(a1 + 240);
        v29 = *(_QWORD *)(a1 + 56);
        v28 = *(_QWORD *)(a1 + 64);
        v30 = *(const void **)a1;
        result = CMBaseObjectGetVTable();
        v31 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void (*)(uint64_t, double, uint64_t, int), uint64_t, _QWORD, const void *))(*(_QWORD *)(result + 16) + 16);
        if (!v31)
          return result;
        result = v31(v26, v29, v27, segPumpPongCallback, v28, 0, v30);
        if ((_DWORD)result)
          return result;
      }
    }
    *(_QWORD *)(a1 + 8600) = v7;
  }
  return result;
}

void segPumpPublishPlaylistRequestEvent(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, const void *a6, char a7)
{
  uint64_t AllocatorForMedia;
  void (*v14)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  uint64_t v15;
  void (*v16)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  _QWORD *v17;
  const __CFData *v18;
  const __CFData *v19;
  const __CFAllocator *v20;
  const void *v21;
  const void *v22;
  int v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  CFTypeRef cf;
  CFAbsoluteTime v29;
  CFAbsoluteTime v30;
  CFAbsoluteTime v31;
  CFAbsoluteTime v32;
  CFTypeRef v33;
  void *v34;

  v33 = 0;
  v34 = 0;
  v31 = 0.0;
  v32 = 0.0;
  v29 = 0.0;
  v30 = 0.0;
  v27 = 0;
  cf = 0;
  v26 = 0;
  if (a4)
  {
    FigCFDictionaryGetDoubleIfPresent();
    FigCFDictionaryGetDoubleIfPresent();
    FigCFDictionaryGetDoubleIfPresent();
    FigCFDictionaryGetDoubleIfPresent();
  }
  if (a5)
  {
    AllocatorForMedia = FigGetAllocatorForMedia();
    v14 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                             + 48);
    if (v14)
      v14(a5, CFSTR("FHRP_CFNetworkTransactionMetrics"), AllocatorForMedia, &cf);
    v15 = FigGetAllocatorForMedia();
    v16 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                             + 48);
    if (v16)
      v16(a5, CFSTR("FHRP_ByteRange"), v15, &v33);
    FigCFDictionaryGetInt64IfPresent();
    FigCFDictionaryGetInt64IfPresent();
  }
  v17 = (_QWORD *)(*(_QWORD *)(a2 + 16 * *(_QWORD *)(a2 + 8416) + 384) + 680);
  while (1)
  {
    v17 = (_QWORD *)*v17;
    if (!v17)
      break;
    v18 = (const __CFData *)v17[22];
    if (v18)
      goto LABEL_14;
  }
  v18 = 0;
LABEL_14:
  v19 = FigCFHTTPCreateAddressString(v18);
  v20 = (const __CFAllocator *)FigGetAllocatorForMedia();
  v21 = (const void *)a3[51];
  v22 = *(const void **)(a2 + 224);
  if (*a3 > 2uLL)
    v23 = 0;
  else
    v23 = dword_1932FD19C[*a3];
  v24 = *MEMORY[0x1E0CA2E18];
  v25 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  FigMetricHLSPlaylistRequestEventCreate(v20, v21, v19, &v24, 0, v22, v27, v26, v32, v31, v30, v29, 0, a6, cf, v23, a7, &v34);
  segPumpPublishMetricEvent(a1, a2, v34);
  if (cf)
    CFRelease(cf);
  if (v33)
    CFRelease(v33);
  if (v19)
    CFRelease(v19);
  if (v34)
    CFRelease(v34);
}

void segPumpSendPlaylistUpdateNotification(_QWORD *a1)
{
  const __CFAllocator *AllocatorForMedia;
  CFMutableDictionaryRef Mutable;

  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetCMTime();
  FigCFDictionarySetCMTime();
  segPumpReadyNotification(a1, CFSTR("FBP_PlaylistUpdateNotification"), Mutable);
  CFRelease(Mutable);
}

uint64_t segPumpCopyIndexFileFromCache(uint64_t a1, uint64_t a2, int a3, CFTypeRef *a4, CFTypeRef *a5, CFTypeRef *a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFAllocator *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t CacheForStream;
  const __CFAllocator *AllocatorForMedia;
  const __CFString *Value;
  const __CFAllocator *v23;
  CFURLRef v24;
  const void *v25;
  uint64_t SavedEntry;
  uint64_t v28;
  CFTypeRef v29;
  const void *v30;
  CFStringRef v31;
  CFTypeRef cf2;
  CFTypeRef v33;
  CFTypeRef v34;
  uint64_t v35;
  CFStringRef URLString;
  CFTypeRef cf;

  v33 = 0;
  v34 = 0;
  v31 = 0;
  cf2 = 0;
  if (!a4)
    goto LABEL_73;
  v12 = *(_QWORD *)(a1 + 296);
  *a4 = 0;
  if (a5)
    *a5 = 0;
  URLString = 0;
  cf = 0;
  v13 = *(_QWORD *)(a1 + 304);
  if (!v13)
  {
LABEL_22:
    if (v12)
    {
      if (v33)
      {
        CFRelease(v33);
        v33 = 0;
      }
      if (cf2)
      {
        CFRelease(cf2);
        cf2 = 0;
      }
      if (a3)
      {
        v18 = FigStreamingCacheCopyMasterPlaylist(*(_QWORD *)(a1 + 296), (unint64_t)&v34, (unint64_t)&v33);
        if ((_DWORD)v18
          || (v18 = FigStreamingCacheCopyStreamNetworkURL(*(_QWORD *)(a1 + 296), (CFURLRef *)&cf2), (_DWORD)v18))
        {
LABEL_72:
          v15 = v18;
          goto LABEL_56;
        }
      }
      else if (!*(_BYTE *)(a1 + 8712) || *(_BYTE *)(a1 + 7996))
      {
        v19 = *(_QWORD *)(a2 + 64);
        if (v19)
          goto LABEL_37;
        CacheForStream = segPumpCreateCacheForStream(a1, (uint64_t *)a2);
        if (*(_BYTE *)(a1 + 8216))
        {
          v15 = CacheForStream;
          if ((_DWORD)CacheForStream)
            goto LABEL_56;
        }
        v19 = *(_QWORD *)(a2 + 64);
        if (v19)
        {
LABEL_37:
          v18 = FigStreamingCacheMediaStreamCopyPlaylist(*(_QWORD *)(a1 + 296), v19, (unint64_t)&v34, (unint64_t)&v33);
          if ((_DWORD)v18)
            goto LABEL_72;
          v18 = FigStreamingCacheMediaStreamCopyNetworkURL(*(_QWORD *)(a1 + 296), *(_QWORD *)(a2 + 64), &v31);
          if ((_DWORD)v18)
            goto LABEL_72;
          AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
          cf2 = CFURLCreateWithString(AllocatorForMedia, v31, 0);
          if (!cf2)
            goto LABEL_73;
        }
      }
    }
LABEL_40:
    if (v33 && FigCFHTTPCompareURLs(*(const void **)(a2 + 24), cf2))
    {
      Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v33, CFSTR("URL"));
      if (Value)
      {
        v23 = (const __CFAllocator *)FigGetAllocatorForMedia();
        v24 = CFURLCreateWithString(v23, Value, 0);
        if (v24)
        {
          Value = (const __CFString *)v24;
          if (!FigCFHTTPCompareURLs(*(const void **)(a2 + 16), v24))
          {
            v25 = *(const void **)(a2 + 16);
            *(_QWORD *)(a2 + 16) = Value;
            CFRetain(Value);
            if (v25)
              CFRelease(v25);
          }
          goto LABEL_48;
        }
LABEL_73:
        v15 = FigSignalErrorAt();
        if ((_DWORD)v15)
          goto LABEL_56;
        Value = 0;
        goto LABEL_49;
      }
    }
    else
    {
      Value = 0;
    }
LABEL_48:
    if (!v34)
    {
      SavedEntry = segPumpFindSavedEntry(a1, *(const void **)(a2 + 24), 0, 0);
      if (SavedEntry)
      {
        v28 = SavedEntry;
        segPumpCreateIndexFileBBFromSavedIndexFile(a1, SavedEntry, &v34);
        v29 = cf2;
        v30 = *(const void **)(v28 + 8);
        cf2 = v30;
        if (v30)
          CFRetain(v30);
        if (v29)
          CFRelease(v29);
      }
    }
LABEL_49:
    *a4 = v34;
    v34 = 0;
    if (a5)
    {
      *a5 = v33;
      v33 = 0;
    }
    if (a6)
    {
      *a6 = cf2;
      cf2 = 0;
    }
    if (Value)
      CFRelease(Value);
    v15 = 0;
    goto LABEL_56;
  }
  if (a3)
  {
    v14 = FigStreamingCacheCopyMasterPlaylist(v13, (unint64_t)&v34, (unint64_t)&v33);
    if (!(_DWORD)v14)
      v14 = FigStreamingCacheCopyStreamNetworkURL(*(_QWORD *)(a1 + 304), (CFURLRef *)&cf2);
    v15 = v14;
    goto LABEL_18;
  }
  v35 = 0;
  v16 = segPumpCreateURLAndString(*(const void **)(a2 + 24), 0, &cf);
  if (!(_DWORD)v16)
  {
    v16 = FigStreamingCacheCreateMediaStream(*(_QWORD *)(a1 + 304), *(_DWORD *)a2, (__CFDictionary *)cf, *(const void **)(a2 + 32), 0, 0, &v35);
    if (!(_DWORD)v16)
    {
      if (!v35)
      {
LABEL_15:
        v15 = 0;
        goto LABEL_16;
      }
      v16 = FigStreamingCacheMediaStreamCopyPlaylist(*(_QWORD *)(a1 + 304), v35, (unint64_t)&v34, (unint64_t)&v33);
      if (!(_DWORD)v16)
      {
        v16 = FigStreamingCacheMediaStreamCopyNetworkURL(*(_QWORD *)(a1 + 304), v35, &URLString);
        if (!(_DWORD)v16)
        {
          v17 = (const __CFAllocator *)FigGetAllocatorForMedia();
          cf2 = CFURLCreateWithString(v17, URLString, 0);
          if (cf2)
            goto LABEL_15;
          v16 = FigSignalErrorAt();
        }
      }
    }
  }
  v15 = v16;
LABEL_16:
  if (cf)
    CFRelease(cf);
LABEL_18:
  if (URLString)
    CFRelease(URLString);
  if (!(_DWORD)v15)
  {
    if (v34)
      goto LABEL_40;
    goto LABEL_22;
  }
LABEL_56:
  if (v34)
    CFRelease(v34);
  if (v33)
    CFRelease(v33);
  if (cf2)
    CFRelease(cf2);
  if (v31)
    CFRelease(v31);
  return v15;
}

uint64_t segPumpModifyErrorActionIfCurrentAlternateIsLastValidAlternate(uint64_t result, _QWORD *a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t v6;

  if ((unint64_t)(*a3 - 7) <= 1)
  {
    if (!*(_QWORD *)(result + 8096)
      || (result = segPumpIsAlternateLastValidAlternate(result, a2, *(_QWORD *)(result + 8144), (*(unsigned __int8 *)a4 >> 2) & 1), (_DWORD)result))
    {
      v6 = 3;
      if ((*a4 & 3) == 1)
        v6 = 6;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t segPumpCreateCacheForStream(uint64_t a1, uint64_t *a2)
{
  uint64_t MediaStream;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  int v8;
  _QWORD *v9;
  uint64_t v10;
  CFTypeRef cf;

  cf = 0;
  MediaStream = segPumpCreateURLAndString((const void *)a2[3], 0, &cf);
  if ((_DWORD)MediaStream)
    goto LABEL_11;
  v5 = *(_QWORD *)(a1 + 8144);
  v6 = *a2;
  v7 = v5 && v6 == 0;
  v8 = v7 ? *(_DWORD *)(v5 + 28) : 0;
  a2[8] = 0;
  v9 = a2 + 8;
  MediaStream = FigStreamingCacheCreateMediaStream(*(_QWORD *)(a1 + 296), v6, (__CFDictionary *)cf, (const void *)*(v9 - 4), v8, v6 == 2, v9);
  if ((_DWORD)MediaStream)
    goto LABEL_11;
  if (*(_BYTE *)(a1 + 8011))
  {
    MediaStream = FigStreamingCacheMediaStreamSetPersistent(*(_QWORD *)(a1 + 296), (_BYTE *)*v9, *MEMORY[0x1E0C9AE50]);
LABEL_11:
    v10 = MediaStream;
    goto LABEL_13;
  }
  v10 = 0;
LABEL_13:
  if (cf)
    CFRelease(cf);
  return v10;
}

uint64_t segPumpFindSavedEntry(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v10;
  unsigned int v11;
  double v12;
  uint64_t v13;

  v4 = *(_QWORD *)(a1 + 352);
  if (v4)
  {
    while (FigMediaSegmentSpecifierGetStartOffset(v4) != a3
         || *(_QWORD *)(v4 + 32) != a4
         || !FigCFHTTPCompareURLs(a2, *(CFTypeRef *)(v4 + 8)))
    {
      v4 = *(_QWORD *)v4;
      if (!v4)
        return v4;
    }
    if (*(_BYTE *)(v4 + 80))
    {
      v10 = FigGetUpTimeNanoseconds() - *(_QWORD *)(v4 + 72);
      v11 = *(_DWORD *)(a1 + 8);
      v12 = *(double *)(a1 + 344) - (double)v11;
      v13 = *(_DWORD *)(a1 + 7944) * v11;
      if ((uint64_t)v12 > v13)
        v13 = (uint64_t)v12;
      if (v10 >= 1000000000 * v13)
      {
        segPumpFreeSavedEntry(a1, (CFTypeRef *)v4);
        return 0;
      }
    }
  }
  return v4;
}

uint64_t segPumpCreateIndexFileBBFromSavedIndexFile(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  const void *v3;
  uint64_t v4;
  void *v5;
  void *v6;

  *a3 = 0;
  v3 = *(const void **)(a2 + 16);
  if (v3)
  {
    v4 = 0;
    *a3 = CFRetain(v3);
  }
  else
  {
    v5 = malloc_type_malloc(*(_QWORD *)(a2 + 64), 0x4616A7A8uLL);
    if (v5)
    {
      v6 = v5;
      FigGzipDecompressMemory();
      FigGzipReset();
      free(v6);
      return 4294954651;
    }
    else
    {
      return FigSignalErrorAt();
    }
  }
  return v4;
}

BOOL segPumpIsProtocolUsedByRequest(uint64_t a1, const __CFString *a2)
{
  uint64_t AllocatorForMedia;
  unsigned int (*v5)(uint64_t, __CFString *, uint64_t, CFDictionaryRef *);
  const __CFString *Value;
  _BOOL8 v7;
  CFDictionaryRef theDict;

  theDict = 0;
  if (!a1)
    return 0;
  AllocatorForMedia = FigGetAllocatorForMedia();
  v5 = *(unsigned int (**)(uint64_t, __CFString *, uint64_t, CFDictionaryRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                        + 48);
  if (!v5 || v5(a1, CFSTR("FHRP_CFNetworkTimingData"), AllocatorForMedia, &theDict))
    goto LABEL_7;
  if (!theDict)
    return 0;
  Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("_kCFNTimingDataNetworkProtocolName"));
  if (Value)
  {
    v7 = CFStringCompare(Value, a2, 1uLL) == kCFCompareEqualTo;
    goto LABEL_8;
  }
LABEL_7:
  v7 = 0;
LABEL_8:
  if (theDict)
    CFRelease(theDict);
  return v7;
}

BOOL segPumpCheckPriorityHeaderLowLatencyServerCompliance(uint64_t a1, int a2)
{
  uint64_t AllocatorForMedia;
  void (*v5)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  int v6;
  int v7;
  _BOOL8 v9;
  int v11;
  CFTypeRef cf;

  cf = 0;
  v11 = 0;
  AllocatorForMedia = FigGetAllocatorForMedia();
  v5 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                          + 48);
  if (!v5)
    return 0;
  v5(a1, CFSTR("FHRP_HTTPResponseHeaders"), AllocatorForMedia, &cf);
  if (!cf)
    return 0;
  if (FigCFHTTPGetPriorityFromHTTPResponse((__CFHTTPMessage *)cf, &v11))
  {
    if (a2)
      v6 = 2;
    else
      v6 = 1;
    if (a2)
      v7 = 6;
    else
      v7 = 1;
    v9 = v11 >= v6 && v11 <= v7;
  }
  else
  {
    v9 = 0;
  }
  if (cf)
    CFRelease(cf);
  return v9;
}

uint64_t segPumpEnsureCacheForStreamPossiblyEndingStream(uint64_t a1, uint64_t *a2)
{
  uint64_t DerivedStorage;
  _BYTE *v5;
  uint64_t result;
  CFTypeRef cf;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  cf = 0;
  if (!*(_QWORD *)(DerivedStorage + 296))
    return 0;
  v5 = (_BYTE *)(DerivedStorage + 7996);
  if (*(_BYTE *)(DerivedStorage + 8712))
  {
    if (!*v5 || *(uint64_t **)(DerivedStorage + 384) != a2)
      return 0;
  }
  else if (!*(_BYTE *)(DerivedStorage + 7997))
  {
    return 0;
  }
  if (a2[8])
    return 0;
  result = segPumpCreateCacheForStream(DerivedStorage, a2);
  if (!v5[220])
    return 0;
  if ((_DWORD)result == -15642)
  {
    FigCreateErrorForOSStatus(4294951654, (CFErrorRef *)&cf);
    segPumpSendEndCallbackForActiveStream(a1, (uint64_t)a2, cf);
    result = (uint64_t)cf;
    if (cf)
    {
      CFRelease(cf);
      return 0;
    }
  }
  return result;
}

uint64_t segPumpSetPlaylistForStreamCache(uint64_t a1, uint64_t a2, const void *a3, const void *a4)
{
  uint64_t v5;
  _QWORD *v7;
  uint64_t v8;
  CFTypeRef v9;
  const void *v10;
  uint64_t v11;

  v5 = *(_QWORD *)(a1 + 296);
  if (v5)
  {
    v7 = *(_QWORD **)(a2 + 64);
    if (v7)
    {
      v8 = FigStreamingCacheMediaStreamSetPlaylist(v5, v7, a3, a4);
      if ((_DWORD)v8)
        return v8;
      v9 = FigCFHTTPCreateURLString(*(const __CFURL **)(a2 + 24));
      if (v9)
      {
        v10 = v9;
        v11 = FigStreamingCacheMediaStreamSetNetworkURL(*(_QWORD *)(a1 + 296), *(_QWORD *)(a2 + 64), v9);
        if (!(_DWORD)v11)
          *(_BYTE *)(a2 + 538) = 0;
        CFRelease(v10);
        return v11;
      }
    }
  }
  return FigSignalErrorAt();
}

uint64_t segPumpSaveEntry(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, CMBlockBufferRef theBuffer, const void *a6, int a7, char a8, uint64_t a9)
{
  _QWORD *v17;
  _QWORD *v18;
  CFTypeRef v19;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t v23;
  void *v24;
  void *v25;
  int v26;
  void *v27;
  uint64_t v28;
  char v29;
  const void *v31;
  char *returnedPointerOut;

  if (!theBuffer || !CMBlockBufferGetDataLength(theBuffer) || segPumpFindSavedEntry(a1, a2, a3, a4))
    return 0;
  v17 = malloc_type_calloc(1uLL, 0x58uLL, 0x1070040389C493CuLL);
  if (!v17)
    return FigSignalErrorAt();
  v18 = v17;
  v17[1] = CFRetain(a2);
  v18[9] = a9;
  *((_BYTE *)v18 + 80) = a8;
  v18[8] = CMBlockBufferGetDataLength(theBuffer);
  v18[3] = a3;
  v18[4] = a4;
  if (a6)
    v19 = CFRetain(a6);
  else
    v19 = 0;
  returnedPointerOut = 0;
  v18[5] = v19;
  if (!a7)
  {
    v22 = 0;
    v25 = 0;
    goto LABEL_18;
  }
  if (!*(_QWORD *)(a1 + 8808))
  {
    v20 = FigGzipCreate();
    if ((_DWORD)v20)
    {
      v28 = v20;
      goto LABEL_28;
    }
  }
  v21 = malloc_type_malloc(v18[8], 0x503F5DDCuLL);
  if (!v21)
  {
    v28 = 4294954510;
    goto LABEL_28;
  }
  v22 = v21;
  v23 = CMBlockBufferAccessDataBytes(theBuffer, 0, v18[8], v21, &returnedPointerOut);
  if ((_DWORD)v23)
  {
    v28 = v23;
LABEL_27:
    free(v22);
    goto LABEL_28;
  }
  v24 = malloc_type_malloc(v18[8], 0x2B2F36BAuLL);
  if (!v24)
  {
    v28 = 4294954510;
    goto LABEL_27;
  }
  v25 = v24;
  v26 = FigGzipCompressMemory();
  FigGzipReset();
  if (!v26)
  {
    v27 = malloc_type_malloc(0, 0x4F5C96BCuLL);
    v18[6] = v27;
    if (!v27)
    {
      v29 = 0;
      v28 = 4294954510;
      goto LABEL_21;
    }
    v18[7] = 0;
  }
LABEL_18:
  if (!v18[6])
    v18[2] = CFRetain(theBuffer);
  v28 = 0;
  *v18 = 0;
  **(_QWORD **)(a1 + 360) = v18;
  *(_QWORD *)(a1 + 360) = v18;
  v29 = 1;
LABEL_21:
  free(v25);
  free(v22);
  if ((v29 & 1) == 0)
  {
LABEL_28:
    v31 = (const void *)v18[1];
    if (v31)
      CFRelease(v31);
    free(v18);
    return v28;
  }
  return 0;
}

uint64_t segPumpEnsurePlaylistCache(uint64_t a1)
{
  __CFDictionary *Mutable;
  const __CFDictionary *v3;
  uint64_t v4;

  if (*(_QWORD *)(a1 + 304))
    return 0;
  Mutable = CFDictionaryCreateMutable(*(CFAllocatorRef *)(a1 + 56), 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return FigSignalErrorAt();
  v3 = Mutable;
  CFDictionarySetValue(Mutable, CFSTR("FSC_Backing"), CFSTR("FSC_MemoryBacking"));
  v4 = FigStreamingCacheCreate(*(const __CFAllocator **)(a1 + 56), *(const __CFURL **)(a1 + 312), v3, (uint64_t *)(a1 + 304));
  CFRelease(v3);
  return v4;
}

uint64_t segPumpGetNextMediaFileWithDate(uint64_t a1, double *a2)
{
  uint64_t FirstValue;
  double i;

  FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
  FirstValue = FigCFArrayGetFirstValue();
  for (i = 0.0; FirstValue; FirstValue = FigMediaSegmentSpecifierGetNextSegment(FirstValue))
  {
    if (FigMediaSegmentSpecifierGetDateStamp(FirstValue)
      && FigMediaSegmentSpecifierIsReadInCurrent(FirstValue))
    {
      break;
    }
    i = i + FigMediaSegmentSpecifierGetTimeInSeconds(FirstValue);
  }
  if (a2)
    *a2 = i;
  return FirstValue;
}

void segPumpMarkMediaFileAsDelivered(uint64_t *a1, const void *a2)
{
  const void *v4;
  const void *v5;
  uint64_t v6;
  const __CFArray *PartialSegments;
  CFIndex v8;
  CFIndex v9;
  const void *ValueAtIndex;

  if (a2)
  {
    segPumpSetDeliveryStatusForMediaFileAndParts(a2, 1);
    if (FigMediaSegmentSpecifierGetType((uint64_t)a2) != 1
      && !FigMediaSegmentSpecifierIsFragment((uint64_t)a2))
    {
      a1[47] = FigMediaSegmentSpecifierGetMediaSequence((uint64_t)a2);
    }
    if ((const void *)a1[33] == a2)
    {
      v6 = a1[32];
      if (v6)
      {
        if (!FigMediaSegmentSpecifierIsFragment(v6))
        {
          PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments(a1[32]);
          v8 = 0;
          while (1)
          {
            v9 = PartialSegments ? CFArrayGetCount(PartialSegments) : 0;
            if (v8 >= v9)
              break;
            ValueAtIndex = CFArrayGetValueAtIndex(PartialSegments, v8++);
            if (!*((_BYTE *)segPumpGetMediaFilePrivateData(ValueAtIndex) + 73))
            {
              if (ValueAtIndex)
                goto LABEL_6;
              break;
            }
          }
          *((_BYTE *)segPumpGetMediaFilePrivateData((const void *)a1[32]) + 73) = 1;
          a1[47] = FigMediaSegmentSpecifierGetMediaSequence(a1[32]);
        }
      }
    }
LABEL_6:
    v4 = (const void *)a1[32];
    if (v4 == a2 || (const void *)a1[33] == a2)
    {
      if (!v4)
        goto LABEL_12;
    }
    else if (!v4)
    {
      return;
    }
    CFRelease(v4);
    a1[32] = 0;
LABEL_12:
    v5 = (const void *)a1[33];
    if (v5)
    {
      CFRelease(v5);
      a1[33] = 0;
    }
  }
}

uint64_t segPumpPlaylistRecalculatePumpTimeOffsets(uint64_t result, double a2)
{
  uint64_t v3;
  CFIndex v4;
  double v5;
  const __CFArray *MediaSegmentSpecifiers;
  const __CFArray *v7;
  const void *ValueAtIndex;
  double *MediaFilePrivateData;
  const __CFArray *PartialSegments;
  CFIndex v11;
  CFIndex Count;
  const void *v13;
  uint64_t PreloadHint;
  uint64_t LastValue;
  const void *v16;

  if (result)
  {
    v3 = result;
    v4 = 0;
    v5 = 0.0;
    while (1)
    {
      MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v3);
      if (MediaSegmentSpecifiers)
        MediaSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MediaSegmentSpecifiers);
      if (v4 >= (uint64_t)MediaSegmentSpecifiers)
        break;
      v7 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v3);
      ValueAtIndex = CFArrayGetValueAtIndex(v7, v4);
      MediaFilePrivateData = (double *)segPumpGetMediaFilePrivateData(ValueAtIndex);
      if (!*((_BYTE *)MediaFilePrivateData + 96))
      {
        MediaFilePrivateData[4] = a2;
        PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)ValueAtIndex);
        v11 = 0;
        v5 = 0.0;
        if (PartialSegments)
        {
LABEL_8:
          Count = CFArrayGetCount(PartialSegments);
          goto LABEL_10;
        }
        while (1)
        {
          Count = 0;
LABEL_10:
          if (v11 >= Count)
            break;
          v13 = CFArrayGetValueAtIndex(PartialSegments, v11);
          *((double *)segPumpGetMediaFilePrivateData(v13) + 4) = a2 + v5;
          v5 = v5 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v13);
          ++v11;
          if (PartialSegments)
            goto LABEL_8;
        }
        a2 = a2 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
      }
      ++v4;
    }
    result = FigMediaPlaylistGetPreloadHint(v3);
    if (result)
    {
      PreloadHint = FigMediaPlaylistGetPreloadHint(v3);
      result = FigMediaSegmentSpecifierIsReadInCurrent(PreloadHint);
      if ((_DWORD)result)
      {
        FigMediaPlaylistGetMediaSegmentSpecifiers(v3);
        if (FigCFArrayGetLastValue())
        {
          FigMediaPlaylistGetMediaSegmentSpecifiers(v3);
          LastValue = FigCFArrayGetLastValue();
          a2 = a2 - FigMediaSegmentSpecifierGetTimeInSeconds(LastValue);
        }
        v16 = (const void *)FigMediaPlaylistGetPreloadHint(v3);
        result = (uint64_t)segPumpGetMediaFilePrivateData(v16);
        *(double *)(result + 32) = v5 + a2;
      }
    }
  }
  return result;
}

uint64_t segPumpSetupCommonCryptKeyDataForSessionKeys(uint64_t a1, uint64_t a2)
{
  int v4;
  CFIndex i;
  const __CFArray *ContentKeySpecifiers;
  const __CFArray *v7;
  const void *ValueAtIndex;
  uint64_t result;
  const void *CryptKeyCommonData;
  const void *Identifier;
  int KeySystem;
  int EncryptionMethod;
  char IsPrefetchKey;
  const void *v15;
  uint64_t UpTimeNanoseconds;
  CFTypeRef v17;
  CFTypeRef cf;
  uint64_t v19;

  cf = 0;
  v19 = 0;
  if (!a2)
    return 0;
  v4 = 0;
  for (i = 0; ; ++i)
  {
    ContentKeySpecifiers = (const __CFArray *)FigMultivariantPlaylistGetContentKeySpecifiers(a2);
    if (ContentKeySpecifiers)
      ContentKeySpecifiers = (const __CFArray *)CFArrayGetCount(ContentKeySpecifiers);
    if (i >= (uint64_t)ContentKeySpecifiers)
      break;
    v7 = (const __CFArray *)FigMultivariantPlaylistGetContentKeySpecifiers(a2);
    ValueAtIndex = CFArrayGetValueAtIndex(v7, i);
    result = segPumpGetCryptKeyCommonData(ValueAtIndex, &v19, &cf);
    if ((_DWORD)result)
      return result;
    if (cf)
    {
      v4 = 0;
    }
    else
    {
      CryptKeyCommonData = segPumpFindCryptKeyCommonData(a1, (uint64_t)ValueAtIndex);
      cf = CryptKeyCommonData;
      if (CryptKeyCommonData)
      {
        v4 = 0;
      }
      else
      {
        cf = segPumpCreateCryptKeyCommonData(a1);
        if (!cf)
          return FigSignalErrorAt();
        Identifier = (const void *)FigContentKeySpecifierGetIdentifier((uint64_t)ValueAtIndex);
        if (Identifier)
          Identifier = CFRetain(Identifier);
        *((_QWORD *)cf + 2) = Identifier;
        KeySystem = FigContentKeySpecifierGetKeySystem((uint64_t)ValueAtIndex);
        *((_DWORD *)cf + 6) = KeySystem;
        EncryptionMethod = FigContentKeySpecifierGetEncryptionMethod((uint64_t)ValueAtIndex);
        *((_DWORD *)cf + 7) = EncryptionMethod;
        IsPrefetchKey = FigContentKeySpecifierGetIsPrefetchKey((uint64_t)ValueAtIndex);
        CryptKeyCommonData = cf;
        *((_BYTE *)cf + 147) = IsPrefetchKey;
        v4 = 1;
      }
      v15 = *(const void **)(v19 + 16);
      *(_QWORD *)(v19 + 16) = CryptKeyCommonData;
      CFRetain(CryptKeyCommonData);
      if (v15)
        CFRelease(v15);
    }
    UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    v17 = cf;
    *((_QWORD *)cf + 21) = UpTimeNanoseconds;
    if (v4)
    {
      if (v17)
      {
        CFRelease(v17);
        cf = 0;
      }
    }
  }
  if (!v4)
    return 0;
  result = (uint64_t)cf;
  if (cf)
  {
    CFRelease(cf);
    return 0;
  }
  return result;
}

uint64_t segPumpSetupCommonCryptKeyData(uint64_t a1, uint64_t *a2, _BYTE *a3, uint64_t a4)
{
  int v8;
  CFIndex i;
  const __CFArray *ContentKeySpecifiers;
  const __CFArray *v11;
  const void *ValueAtIndex;
  uint64_t result;
  const void *CryptKeyCommonData;
  const void *Identifier;
  int KeySystem;
  int EncryptionMethod;
  char IsPrefetchKey;
  const void *v19;
  uint64_t UpTimeNanoseconds;
  _QWORD *v21;
  CFIndex j;
  const __CFArray *Count;
  const __CFArray *v24;
  const void *v25;
  uint64_t v26;
  uint64_t v27;
  CFTypeRef cf;
  uint64_t v29;

  cf = 0;
  v29 = 0;
  if (a3)
  {
    v8 = 0;
    for (i = 0; ; ++i)
    {
      ContentKeySpecifiers = (const __CFArray *)FigMediaPlaylistGetContentKeySpecifiers(a2[7]);
      if (ContentKeySpecifiers)
        ContentKeySpecifiers = (const __CFArray *)CFArrayGetCount(ContentKeySpecifiers);
      if (i >= (uint64_t)ContentKeySpecifiers)
        break;
      v11 = (const __CFArray *)FigMediaPlaylistGetContentKeySpecifiers(a2[7]);
      ValueAtIndex = CFArrayGetValueAtIndex(v11, i);
      result = segPumpGetCryptKeyCommonData(ValueAtIndex, &v29, &cf);
      if ((_DWORD)result)
        return result;
      if (FigContentKeySpecifierGetIsReadInCurrent((uint64_t)ValueAtIndex)
        || FigContentKeySpecifierGetIsPrefetchKey((uint64_t)ValueAtIndex))
      {
        if (cf)
        {
          v8 = 0;
        }
        else
        {
          CryptKeyCommonData = segPumpFindCryptKeyCommonData(a1, (uint64_t)ValueAtIndex);
          cf = CryptKeyCommonData;
          if (CryptKeyCommonData)
          {
            v8 = 0;
          }
          else
          {
            cf = segPumpCreateCryptKeyCommonData(a1);
            if (!cf)
              return FigSignalErrorAt();
            Identifier = (const void *)FigContentKeySpecifierGetIdentifier((uint64_t)ValueAtIndex);
            if (Identifier)
              Identifier = CFRetain(Identifier);
            *((_QWORD *)cf + 2) = Identifier;
            KeySystem = FigContentKeySpecifierGetKeySystem((uint64_t)ValueAtIndex);
            *((_DWORD *)cf + 6) = KeySystem;
            EncryptionMethod = FigContentKeySpecifierGetEncryptionMethod((uint64_t)ValueAtIndex);
            *((_DWORD *)cf + 7) = EncryptionMethod;
            IsPrefetchKey = FigContentKeySpecifierGetIsPrefetchKey((uint64_t)ValueAtIndex);
            CryptKeyCommonData = cf;
            *((_BYTE *)cf + 147) = IsPrefetchKey;
            v8 = 1;
          }
          v19 = *(const void **)(v29 + 16);
          *(_QWORD *)(v29 + 16) = CryptKeyCommonData;
          CFRetain(CryptKeyCommonData);
          if (v19)
            CFRelease(v19);
        }
        UpTimeNanoseconds = FigGetUpTimeNanoseconds();
        v21 = cf;
        *((_QWORD *)cf + 21) = UpTimeNanoseconds;
        if (a4)
          v21[20] = *(_QWORD *)(a4 + 8);
      }
      else
      {
        v8 = 0;
      }
      if (!*(_QWORD *)(v29 + 16))
      {
        CryptKeyRemoveKeyFromPlaylist(a1, a3, ValueAtIndex);
        --i;
      }
      if (v8)
      {
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
      }
    }
    for (j = 0; ; ++j)
    {
      Count = (const __CFArray *)FigMediaPlaylistGetContentKeySpecifiers((uint64_t)a3);
      if (Count)
        Count = (const __CFArray *)CFArrayGetCount(Count);
      if (j >= (uint64_t)Count)
        break;
      v24 = (const __CFArray *)FigMediaPlaylistGetContentKeySpecifiers(a2[7]);
      v25 = CFArrayGetValueAtIndex(v24, j);
      if (FigContentKeySpecifierGetIsPrefetchKey((uint64_t)v25))
      {
        FigContentKeySpecifierSetIsReadInCurrent((uint64_t)v25, 1);
      }
      else if (!FigContentKeySpecifierGetIsReadInCurrent((uint64_t)v25))
      {
        v26 = *(_QWORD *)(a2[87] + 8);
        if (!v26 || v25 != (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier(v26))
        {
          v27 = a2[32];
          if (!v27 || v25 != (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier(v27))
          {
            if (v25 == (const void *)a2[31])
              segPumpCancelCryptReadAndResetData(a1, (uint64_t)a2);
            CryptKeyRemoveKeyFromPlaylist(a1, a3, v25);
            --j;
          }
        }
      }
    }
    if (v8)
    {
      result = (uint64_t)cf;
      if (!cf)
        return result;
      CFRelease(cf);
    }
  }
  return 0;
}

_QWORD *segPumpStopPlaylistReadsAndResetAllData(uint64_t a1)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v3;
  uint64_t i;
  uint64_t j;
  uint64_t v6;

  if (dword_1EE2A31E8)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  *(_BYTE *)(a1 + 376) = 1;
  *(_BYTE *)(a1 + 8005) = 0;
  v3 = *(_QWORD *)(a1 + 296);
  if (v3)
    FigStreamingCacheSetCacheTimeRange(v3, 0.0, 0.0);
  for (i = 384; i != 432; i += 16)
  {
    segPumpStopStream(a1, *(_QWORD *)(a1 + i), 0);
    *(_BYTE *)(*(_QWORD *)(a1 + i) + 1169) = 1;
  }
  for (j = 384; j != 432; j += 16)
  {
    v6 = *(_QWORD *)(a1 + j);
    if ((*(_DWORD *)(v6 + 160) - 2) <= 2)
      *(_DWORD *)(v6 + 160) = 1;
  }
  return segPumpReadyNotification((_QWORD *)a1, CFSTR("FBPAL_SeekableTimeRangeChanged"), 0);
}

void segPumpSetMediaFileExpireTimer(uint64_t a1, double a2)
{
  double v2;
  NSObject *v4;
  CFAbsoluteTime v5;
  CFAbsoluteTime Current;

  v2 = a2;
  v4 = *(NSObject **)(a1 + 7936);
  if (v4)
  {
    if (a2 == 8073216000.0)
    {
      FigHTTPRescheduleTimer(0.0, *(_QWORD *)(a1 + 64), v4);
      v2 = 8073216000.0;
    }
    else
    {
      Current = CFAbsoluteTimeGetCurrent();
      FigHTTPRescheduleTimer(v2 - Current, *(_QWORD *)(a1 + 64), *(NSObject **)(a1 + 7936));
    }
  }
  else
  {
    v5 = CFAbsoluteTimeGetCurrent();
    FigHTTPCreateTimer(*(const void **)a1, (uint64_t)segPumpMediaExpiryTimerCallback, *(NSObject **)(a1 + 64), (dispatch_object_t *)(a1 + 7936), v2 - v5);
  }
  *(double *)(a1 + 7928) = v2;
}

uint64_t segPumpAddFigAlternate(uint64_t a1, const void *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  CFTypeRef v6;
  int PeakBitRate;
  const __CFString *PathwayID;
  __CFSet *Mutable;
  const __CFAllocator *AllocatorForMedia;
  uint64_t v12;

  v4 = malloc_type_calloc(1uLL, 0x28uLL, 0x102004000B479F3uLL);
  if (!v4)
    return FigSignalErrorAt();
  v5 = v4;
  if (a2)
    v6 = CFRetain(a2);
  else
    v6 = 0;
  v5[1] = v6;
  PeakBitRate = FigAlternateGetPeakBitRate((uint64_t)a2);
  *((_DWORD *)v5 + 6) = PeakBitRate;
  *((_DWORD *)v5 + 7) = PeakBitRate;
  PathwayID = FigAlternateGetPathwayID(v5[1]);
  Mutable = *(__CFSet **)(a1 + 7912);
  if (Mutable
    || (AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia(),
        Mutable = CFSetCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B3B0]),
        (*(_QWORD *)(a1 + 7912) = Mutable) != 0))
  {
    CFSetAddValue(Mutable, PathwayID);
    *v5 = 0;
    **(_QWORD **)(a1 + 8104) = v5;
    *(_QWORD *)(a1 + 8104) = v5;
    return 0;
  }
  else
  {
    v12 = FigSignalErrorAt();
    AlternateEntryFree(v5);
    return v12;
  }
}

uint64_t segPumpInitAlternateSelectionBoss(uint64_t a1, uint64_t a2)
{
  uint64_t updated;
  uint64_t v5;
  void (*v6)(int, uint64_t, CFArrayRef);
  uint64_t v7;
  const void **v8;
  const __CFArray *Alternates;
  uint64_t v10;
  void (*v11)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v12;
  uint64_t v13;
  __CFDictionary *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t (*v17)(uint64_t, uint64_t, _QWORD, uint64_t);
  uint64_t v18;
  void *AllocatorForMedia;
  const void *ContentSteeringServerURL;
  const void *ContentSteeringInitPathwayID;
  CFIndex Count;
  uint64_t v23;
  const __CFAllocator *v24;
  CFIndex v25;
  CFArrayRef v26;
  uint64_t v27;
  void (*v28)(uint64_t, __CFString *, __CFString *, CFArrayRef, _QWORD);
  uint64_t v29;
  uint64_t v30;
  void (*v31)(uint64_t, const __CFString *, uint64_t);
  NSObject *v32;
  unsigned int v33;
  unsigned int v34;
  const __CFString *v35;
  uint64_t v36;
  CFIndex v37;
  uint64_t v38;
  uint64_t (*v39)(uint64_t, const __CFString *, uint64_t, CFTypeRef *);
  const void *v40;
  uint64_t v41;
  NSObject *v42;
  unsigned int v43;
  unsigned int v44;
  const __CFString *v45;
  uint64_t v46;
  CFIndex v47;
  CFIndex v48;
  const void *v49;
  uint64_t v50;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v53;
  unsigned int v54;
  const __CFString *v55;
  NSObject *v56;
  unsigned int v57;
  unsigned int v58;
  const __CFString *v59;
  uint64_t v60;
  void (*v61)(int, uint64_t, CFArrayRef);
  CFTypeRef v62;
  CFArrayRef v63;
  CFArrayRef theArray;
  os_log_type_t type;
  unsigned int v66;
  CFTypeRef cf;
  int v68;
  CFTypeRef v69;
  int v70;
  const char *v71;
  __int16 v72;
  const __CFString *v73;
  __int16 v74;
  uint64_t v75;
  __int16 v76;
  CFIndex v77;
  __int16 v78;
  CFIndex v79;
  __int128 v80;
  void (*v81)(int, uint64_t, CFArrayRef);
  uint64_t v82;

  v82 = *MEMORY[0x1E0C80C00];
  v63 = 0;
  theArray = 0;
  v62 = 0;
  if (!*(_QWORD *)(a2 + 9528))
    goto LABEL_33;
  if (!*(_QWORD *)(a2 + 9536))
    *(_QWORD *)(a2 + 9536) = FigHTTPSchedulerRetain(*(dispatch_object_t *)(a2 + 64));
  updated = segPumpCreateFigAlternatesArrayAndCalculateStartupScore(a2, &theArray);
  if ((_DWORD)updated)
    goto LABEL_92;
  if (!theArray)
  {
    v23 = 0;
    goto LABEL_95;
  }
  if (CFArrayGetCount(theArray) < 1)
  {
LABEL_33:
    v23 = 0;
    goto LABEL_93;
  }
  v5 = *(_QWORD *)(a2 + 9552);
  v69 = 0;
  if (v5)
    v6 = 0;
  else
    v6 = segPumpContentSteeringAlternateListChangedCallback;
  v68 = 0;
  cf = 0;
  v61 = v6;
  if (v5)
    goto LABEL_64;
  if (!*(_QWORD *)(a2 + 9528))
  {
    if (dword_1EE2A31E8)
    {
      v66 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      v53 = v66;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v54 = v53;
      else
        v54 = v53 & 0xFFFFFFFE;
      if (v54)
      {
        v55 = &stru_1E2FD85F8;
        if (*(_QWORD *)(a2 + 8760))
          v55 = *(const __CFString **)(a2 + 8760);
        v70 = 136315394;
        v71 = "segPumpInitContentSteeringMonitor";
        v72 = 2114;
        v73 = v55;
        _os_log_send_and_compose_impl();
      }
      goto LABEL_122;
    }
LABEL_123:
    v14 = 0;
    v26 = 0;
    v8 = 0;
    goto LABEL_50;
  }
  v7 = *(_QWORD *)(a2 + 384);
  if (!v7)
  {
    v13 = FigSignalErrorAt();
LABEL_109:
    v23 = v13;
    v14 = 0;
LABEL_121:
    v26 = 0;
    v8 = 0;
    goto LABEL_52;
  }
  v8 = *(const void ***)(v7 + 48);
  if (!v8)
  {
    v14 = 0;
    v26 = 0;
LABEL_50:
    v23 = 0;
    goto LABEL_52;
  }
  if (!FigMultivariantPlaylistGetContentSteeringServerURL(*(_QWORD *)(v7 + 48))
    || !*(_QWORD *)(a2 + 7912)
    || *(_QWORD *)(a2 + 9552))
  {
    goto LABEL_123;
  }
  if (!*(_BYTE *)(a2 + 7904))
  {
    if (dword_1EE2A31E8)
    {
      v66 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v56 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      v57 = v66;
      if (os_log_type_enabled(v56, type))
        v58 = v57;
      else
        v58 = v57 & 0xFFFFFFFE;
      if (v58)
      {
        v59 = *(const __CFString **)(a2 + 8760);
        if (!v59)
          v59 = &stru_1E2FD85F8;
        v60 = *(_QWORD *)v7;
        v70 = 136315650;
        v71 = "segPumpInitContentSteeringMonitor";
        v72 = 2114;
        v73 = v59;
        v74 = 2048;
        v75 = v60;
        _os_log_send_and_compose_impl();
      }
LABEL_122:
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      goto LABEL_123;
    }
    goto LABEL_123;
  }
  Alternates = (const __CFArray *)FigMultivariantPlaylistGetAlternates((uint64_t)v8);
  if (FigPathwayValidateStableVariantAndRenditionIDs(Alternates))
  {
    segPumpAppendErrorLogEntry(a1, a2, v7, (const __CFURL **)(v7 + 408), -15625, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Stable Variant/Rendition ID validation failed"), 0, 0, 6u, 3u);
    goto LABEL_123;
  }
  v10 = *(_QWORD *)(a2 + 9048);
  if (v10)
  {
    v11 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v11)
      v11(v10, CFSTR("bytePumpStats"), CFSTR("HasSteering"), 1, 0);
  }
  if (*(_BYTE *)(a2 + 327))
    v12 = 2;
  else
    v12 = 3;
  v13 = segPumpAmendHTTPRequestFlags((_BYTE *)a2, &v68);
  if ((_DWORD)v13)
    goto LABEL_109;
  v14 = segPumpCopyHTTPRequestCreationsOptionsAndSetNWActivityAndStuff(0.5, *(_QWORD *)(a2 + 240), a2, (_QWORD *)v7, 0, 0);
  segPumpCopyParentNWActivity(a2, (_QWORD *)v7, &cf);
  if (!*(_QWORD *)(a2 + 40))
  {
    v15 = *(_QWORD *)(a2 + 32);
    v16 = *(_QWORD *)(a2 + 64);
    v17 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 40);
    if (!v17)
    {
      v26 = 0;
      v8 = 0;
      v23 = 4294954514;
      goto LABEL_52;
    }
    v18 = v17(v15, v16, 0, a2 + 40);
    if ((_DWORD)v18)
      goto LABEL_120;
  }
  AllocatorForMedia = (void *)FigGetAllocatorForMedia();
  ContentSteeringServerURL = (const void *)FigMultivariantPlaylistGetContentSteeringServerURL((uint64_t)v8);
  ContentSteeringInitPathwayID = (const void *)FigMultivariantPlaylistGetContentSteeringInitPathwayID((uint64_t)v8);
  v18 = FigAlternateFilterMonitorCreateForContentSteering(AllocatorForMedia, ContentSteeringServerURL, ContentSteeringInitPathwayID, *(const __CFSet **)(a2 + 7912), *(_QWORD *)(a2 + 88), v12, v68, *(const void **)(a2 + 216), v14, cf, *(CFTypeRef *)(a2 + 40), *(const void **)(a2 + 80), *(_BYTE *)(a2 + 339), &v69);
  if ((_DWORD)v18)
  {
LABEL_120:
    v23 = v18;
    goto LABEL_121;
  }
  segPumpSetContentSteeringMonitor(a2, v69);
  if (CFSetGetCount(*(CFSetRef *)(a2 + 7912)) < 1)
  {
    v8 = 0;
  }
  else
  {
    Count = CFSetGetCount(*(CFSetRef *)(a2 + 7912));
    v8 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
    CFSetGetValues(*(CFSetRef *)(a2 + 7912), v8);
  }
  v24 = (const __CFAllocator *)FigGetAllocatorForMedia();
  v25 = CFSetGetCount(*(CFSetRef *)(a2 + 7912));
  v26 = CFArrayCreate(v24, v8, v25, MEMORY[0x1E0C9B378]);
  v27 = *(_QWORD *)(a2 + 9048);
  if (v27)
  {
    v28 = *(void (**)(uint64_t, __CFString *, __CFString *, CFArrayRef, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                         + 48);
    if (v28)
      v28(v27, CFSTR("bytePumpStats"), CFSTR("AvailablePathways"), v26, 0);
  }
  v29 = *(_QWORD *)(a2 + 9552);
  v30 = *(_QWORD *)(a2 + 9048);
  v31 = *(void (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
  if (v31)
    v31(v29, CFSTR("AlternateFilterMonitorProperty_ReportingAgent"), v30);
  v23 = FigAlternateSelectionBossAddMonitor(*(const void **)(a2 + 9528), *(const void **)(a2 + 9552));
  if (!(_DWORD)v23 && dword_1EE2A31E8)
  {
    v66 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    v32 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    v33 = v66;
    if (os_log_type_enabled(v32, type))
      v34 = v33;
    else
      v34 = v33 & 0xFFFFFFFE;
    if (v34)
    {
      v35 = *(const __CFString **)(a2 + 8760);
      if (!v35)
        v35 = &stru_1E2FD85F8;
      v36 = *(_QWORD *)v7;
      v37 = *(_QWORD *)(a2 + 9552);
      v70 = 136315906;
      v71 = "segPumpInitContentSteeringMonitor";
      v72 = 2114;
      v73 = v35;
      v74 = 2048;
      v75 = v36;
      v76 = 2048;
      v77 = v37;
      _os_log_send_and_compose_impl();
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    goto LABEL_50;
  }
LABEL_52:
  if (cf)
    CFRelease(cf);
  if (v14)
    CFRelease(v14);
  if (v69)
    CFRelease(v69);
  if (v26)
    CFRelease(v26);
  if (v8)
    free(v8);
  if ((_DWORD)v23)
    goto LABEL_93;
  v5 = *(_QWORD *)(a2 + 9552);
  if (!v5)
  {
LABEL_67:
    updated = segPumpUpdateBytesRequiredForNetworkPrediction(a2);
    if (!(_DWORD)updated)
    {
      updated = FigAlternateSelectionBossInitializeAlternateList(*(void **)(a2 + 9528), theArray, *(const __CFArray **)(a2 + 8376), (const __CFArray *)v62, (CFTypeRef *)&v63);
      if (!(_DWORD)updated)
      {
        if (dword_1EE2A31E8)
        {
          LODWORD(v69) = 0;
          LOBYTE(cf) = 0;
          v42 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          v43 = v69;
          if (os_log_type_enabled(v42, (os_log_type_t)cf))
            v44 = v43;
          else
            v44 = v43 & 0xFFFFFFFE;
          if (v44)
          {
            if (*(_QWORD *)(a2 + 8760))
              v45 = *(const __CFString **)(a2 + 8760);
            else
              v45 = &stru_1E2FD85F8;
            v46 = *(_QWORD *)(a2 + 9528);
            if (theArray)
              v47 = CFArrayGetCount(theArray);
            else
              v47 = 0;
            v48 = (CFIndex)v63;
            if (v63)
              v48 = CFArrayGetCount(v63);
            v70 = 136316162;
            v71 = "segPumpInitAlternateSelectionBoss";
            v72 = 2114;
            v73 = v45;
            v74 = 2048;
            v75 = v46;
            v76 = 2048;
            v77 = v47;
            v78 = 2048;
            v79 = v48;
            _os_log_send_and_compose_impl();
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        v49 = *(const void **)(a2 + 9568);
        if (v49)
        {
          CFRelease(v49);
          *(_QWORD *)(a2 + 9568) = 0;
        }
        v50 = FigGetAllocatorForMedia();
        updated = FigAlternatePassthroughFilterCreate(v50, CFSTR("EligibleCandidatesForPlaybackPassThrough"), 877, (_QWORD *)(a2 + 9568));
        if (!(_DWORD)updated)
        {
          updated = FigAlternateSelectionBossAddFilter(*(_QWORD *)(a2 + 9528), *(const void **)(a2 + 9568));
          if (!(_DWORD)updated)
          {
            updated = segPumpUpdateAlternateSelectionBossNetworkErrorFilter((_QWORD *)a2, 0);
            if (!(_DWORD)updated)
              updated = segPumpAddNewAlternatesToValidAlternatesQueue(a2, v63);
          }
        }
      }
    }
    goto LABEL_92;
  }
LABEL_64:
  v38 = FigGetAllocatorForMedia();
  v39 = *(uint64_t (**)(uint64_t, const __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                + 8)
                                                                                    + 48);
  if (!v39)
  {
    v23 = 4294954514;
    goto LABEL_93;
  }
  updated = v39(v5, CFSTR("AlternateFilterMonitorProperty_Expanders"), v38, &v62);
  if (!(_DWORD)updated)
  {
    v40 = *(const void **)(a2 + 9528);
    v41 = *(_QWORD *)a2;
    v80 = (unint64_t)v61;
    v81 = segPumpContentSteeringAlternatesAddedCallback;
    updated = FigAlternateSelectionBossAddDelegate(v40, v41, &v80, 0);
    if (!(_DWORD)updated)
      goto LABEL_67;
  }
LABEL_92:
  v23 = updated;
LABEL_93:
  if (theArray)
    CFRelease(theArray);
LABEL_95:
  if (v63)
    CFRelease(v63);
  if (v62)
    CFRelease(v62);
  return v23;
}

uint64_t segPumpReadNextCryptKeyForStream(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  const __CFArray *ContentKeySpecifiers;
  CFIndex v8;
  CFIndex v9;
  const void *ValueAtIndex;
  uint64_t v11;
  int v12;
  uint64_t i;
  const __CFArray *Count;
  uint64_t result;
  CFIndex j;
  const __CFArray *MediaSegmentSpecifiers;
  const __CFArray *v18;
  const void *v19;
  const void *v20;
  uint64_t v21;
  uint64_t v22;

  if (a3[31])
    return 0;
  v6 = a3[6];
  if (v6)
  {
    ContentKeySpecifiers = (const __CFArray *)FigMultivariantPlaylistGetContentKeySpecifiers(v6);
    v8 = 0;
    while (1)
    {
      v9 = ContentKeySpecifiers ? CFArrayGetCount(ContentKeySpecifiers) : 0;
      if (v8 >= v9)
        break;
      ValueAtIndex = (const void *)FigCFArrayGetValueAtIndex();
      ++v8;
      if (segPumpDoesCryptKeyRequireFetch(ValueAtIndex))
        goto LABEL_37;
    }
  }
  if (!a3[7])
    return 0;
  v11 = a3[32];
  if (!v11
    || !FigMediaSegmentSpecifierGetContentKeySpecifier(v11)
    || (ValueAtIndex = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier(a3[32]),
        !segPumpDoesCryptKeyRequireFetch(ValueAtIndex))
    || !ValueAtIndex)
  {
    v12 = 0;
    for (i = 0; ; ++i)
    {
      Count = (const __CFArray *)FigMediaPlaylistGetContentKeySpecifiers(a3[7]);
      if (Count)
        Count = (const __CFArray *)CFArrayGetCount(Count);
      if (i >= (uint64_t)Count)
        break;
      FigMediaPlaylistGetContentKeySpecifiers(a3[7]);
      ValueAtIndex = (const void *)FigCFArrayGetValueAtIndex();
      v21 = 0;
      v22 = 0;
      result = segPumpGetCryptKeyCommonData(ValueAtIndex, &v22, &v21);
      if ((_DWORD)result)
        return result;
      if (segPumpDoesCryptKeyRequireFetch(ValueAtIndex) && segPumpStreamWaitingForCryptKey(a2, a3, v21))
        goto LABEL_26;
      if (segPumpDoesCryptKeyRequireFetch(ValueAtIndex))
        v12 = 1;
    }
    ValueAtIndex = 0;
LABEL_26:
    if (!ValueAtIndex && v12)
    {
      ValueAtIndex = 0;
      for (j = 0; ; ++j)
      {
        MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a3[7]);
        if (MediaSegmentSpecifiers)
          MediaSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MediaSegmentSpecifiers);
        if (j >= (uint64_t)MediaSegmentSpecifiers)
          break;
        v18 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a3[7]);
        v19 = CFArrayGetValueAtIndex(v18, j);
        if (!*((_BYTE *)segPumpGetMediaFilePrivateData(v19) + 73))
        {
          if (FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v19))
          {
            if ((const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v19) != ValueAtIndex)
            {
              ValueAtIndex = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v19);
              if (segPumpDoesCryptKeyRequireFetch(ValueAtIndex))
                goto LABEL_37;
            }
          }
        }
      }
      return 0;
    }
LABEL_37:
    if (!ValueAtIndex)
      return 0;
  }
  v20 = (const void *)a3[31];
  a3[31] = ValueAtIndex;
  CFRetain(ValueAtIndex);
  if (v20)
    CFRelease(v20);
  return segPumpSendCryptKeyRequest(a1, a2, a3, a3[31]);
}

double segPumpSetTargetDurationAndType(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  double result;
  int TargetDuration;
  CFNumberRef v9;
  uint64_t v10;
  void (*v11)(uint64_t, const __CFString *, CFNumberRef);
  double v12;
  double v13;
  double valuePtr;

  v6 = *(_DWORD *)(a2 + 8);
  if (v6 != FigMediaPlaylistGetTargetDuration(a3))
  {
    TargetDuration = FigMediaPlaylistGetTargetDuration(a3);
    *(_DWORD *)(a2 + 8) = TargetDuration;
    if (*(_QWORD *)(a2 + 9560))
    {
      valuePtr = (double)(2 * TargetDuration);
      v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &valuePtr);
      v10 = *(_QWORD *)(a2 + 9560);
      v11 = *(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                            + 56);
      if (v11)
        v11(v10, CFSTR("AfmfpbProperty_SwitchMinDuration"), v9);
      if (v9)
        CFRelease(v9);
    }
    *(_DWORD *)(a2 + 24) = FigMediaPlaylistGetPlaylistType(a3);
    v12 = *(double *)(a2 + 7968);
    if (v12 == 0.0)
    {
      v13 = (double)(*(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 7944));
      if (v12 != v13)
      {
        *(double *)(a2 + 7968) = v13;
        segPumpReadyNotification((_QWORD *)a2, CFSTR("FBP_RecommendedPrebufferReservationChanged"), 0);
      }
    }
    result = *(double *)(a2 + 7960);
    if (result > 0.0)
      return segPumpSetExtraHoldbackFromClient(a1, a2, result);
  }
  return result;
}

void segPumpRTCReportingRespondToFirstIndexFileWithMedia(uint64_t a1, _QWORD *a2)
{
  int HasEndTag;
  const __CFString *v5;
  const __CFString *v6;
  const __CFString *v7;
  uint64_t v8;
  void (*v9)(uint64_t, __CFString *, __CFString *, const __CFString *, _QWORD);
  uint64_t v10;
  uint64_t v11;
  void (*v12)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v13;
  void (*v14)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  double PlaylistActiveDurationSecs;
  uint64_t v16;
  double v17;
  void (*v18)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD);

  if (!*(_QWORD *)(a1 + 9056))
  {
    if (*a2 == 1)
    {
      HasEndTag = FigMediaPlaylistHasEndTag(a2[7]);
      v5 = CFSTR("AOD");
      v6 = CFSTR("ALIVE");
    }
    else
    {
      if (*a2)
        goto LABEL_12;
      HasEndTag = FigMediaPlaylistHasEndTag(a2[7]);
      v5 = CFSTR("VOD");
      v6 = CFSTR("LIVE");
    }
    if (HasEndTag)
      v7 = v5;
    else
      v7 = v6;
    *(_QWORD *)(a1 + 9056) = v7;
    v8 = *(_QWORD *)(a1 + 9048);
    if (v8)
    {
      v9 = *(void (**)(uint64_t, __CFString *, __CFString *, const __CFString *, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                  + 48);
      if (v9)
        v9(v8, CFSTR("bytePumpStats"), CFSTR("PlayType"), v7, 0);
    }
  }
LABEL_12:
  v10 = *(unsigned int *)(a1 + 8);
  v11 = *(_QWORD *)(a1 + 9048);
  if (v11)
  {
    v12 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v12)
      v12(v11, CFSTR("bytePumpStats"), CFSTR("TargetDur"), 1000 * v10, 0);
    v11 = *(_QWORD *)(a1 + 9048);
  }
  if (*(_BYTE *)(a1 + 8002))
    v13 = 300;
  else
    v13 = 3 * v10;
  if (v11)
  {
    v14 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v14)
      v14(v11, CFSTR("bytePumpStats"), CFSTR("IRAT_TimeHorizon"), v13, 0);
  }
  if (FigMediaPlaylistHasEndTag(a2[7]))
  {
    if (!*a2)
    {
      PlaylistActiveDurationSecs = FigMediaPlaylistGetPlaylistActiveDurationSecs(a2[7]);
      v16 = *(_QWORD *)(a1 + 9048);
      if (v16)
      {
        v17 = PlaylistActiveDurationSecs;
        v18 = *(void (**)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                         + 56);
        if (v18)
          v18(v16, CFSTR("bytePumpStats"), CFSTR("ContentDur"), (int)(ceil(v17 / 300.0) * 300.0 / 60.0), 0);
      }
    }
  }
}

uint64_t segPumpCalculateDiscoDomainOffset(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  double *v6;
  uint64_t v7;
  double *v8;
  double *v9;
  double *v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v17;
  double v18;
  double *v19;
  uint64_t v20;
  double *v21;
  uint64_t v22;
  double v23;
  _BOOL4 v24;
  double v26;
  _BOOL4 v27;
  double v29;
  double v32;
  BOOL v33;
  double v35;
  double v37;
  uint64_t v39;
  uint64_t v41;
  _QWORD v42[2];

  v41 = 0;
  v42[0] = 0;
  v42[1] = v42;
  if ((uint64_t)a1[44] <= 0 || !a1[42])
  {
    v4 = FigSignalErrorAt();
    goto LABEL_97;
  }
  v4 = segPumpCreateDiscoInfoList((uint64_t)a1, v42, 0, &v41);
  if ((_DWORD)v4)
  {
LABEL_97:
    v7 = v4;
    goto LABEL_95;
  }
  *a2 = 0;
  v5 = **(_QWORD **)(a1[43] + 8);
  if (v41 < 1 || *(double *)(v42[0] + 16) >= *(double *)(v5 + 16) + *(double *)(v5 + 40))
  {
    v7 = 0;
    v39 = *(_QWORD *)(v5 + 32) + 1;
LABEL_93:
    *a2 = v39;
    goto LABEL_95;
  }
  v6 = (double *)a1[42];
  if (!v6)
  {
    v7 = 0;
    goto LABEL_95;
  }
  v7 = 0;
  do
  {
    v8 = (double *)v42;
    while (2)
    {
      v8 = *(double **)v8;
      if (!v8)
        break;
      v9 = v6;
      v10 = v8;
      while (1)
      {
        v11 = v9[2];
        v12 = v9[5];
        v13 = v11 + v12;
        v14 = v10[2];
        v15 = v11 + v12 - v14;
        if (v15 <= 1.0 && v15 < -1.0)
          goto LABEL_82;
        v17 = v10[5];
        v18 = v14 + v17;
        v19 = v9;
        v9 = *(double **)v9;
        v20 = **(_QWORD **)(*((_QWORD *)v19 + 1) + 8);
        v21 = v10;
        v10 = *(double **)v10;
        v22 = **(_QWORD **)(*((_QWORD *)v21 + 1) + 8);
        if (!(v20 | (unint64_t)v9))
        {
          if (!((unint64_t)v10 | v22))
            goto LABEL_92;
          if (!v22)
          {
            if (v13 - v18 > 1.0)
              goto LABEL_82;
            goto LABEL_92;
          }
          v32 = v11 - v14;
          v33 = v32 > 1.0;
          if (v32 >= -1.0)
            v33 = 1;
          if (!v10)
            goto LABEL_71;
          goto LABEL_57;
        }
        if (!v9)
        {
          v35 = v11 - v14;
          if (!(v22 | (unint64_t)v10))
          {
            if (v35 > 1.0)
              goto LABEL_82;
LABEL_92:
            v7 = 0;
            v39 = *((_QWORD *)v6 + 4) - *((_QWORD *)v8 + 4);
            goto LABEL_93;
          }
          if (!v22)
          {
            v37 = v13 - v18;
            if (v35 > 1.0 || v37 > 1.0)
              goto LABEL_82;
            goto LABEL_92;
          }
          v33 = v35 <= 1.0;
          if (v35 < -1.0)
            v33 = 0;
          if (!v10)
          {
LABEL_71:
            if (!v33)
              goto LABEL_82;
            goto LABEL_92;
          }
LABEL_57:
          if (v13 - v18 > 1.0 || !v33)
            goto LABEL_82;
          goto LABEL_92;
        }
        if (!v20)
        {
          v26 = v13 - v18;
          if (!v10)
            goto LABEL_77;
          v27 = v26 <= 1.0;
          if (v26 < -1.0)
            v27 = 0;
          if (v22)
          {
            if (!v27)
              goto LABEL_82;
            if (v11 - v14 <= 1.0 && v11 - v14 < -1.0)
              goto LABEL_82;
          }
          else if (!v27)
          {
            goto LABEL_82;
          }
          goto LABEL_50;
        }
        v23 = v11 - v14;
        if (!(v22 | (unint64_t)v10))
          break;
        if (v22)
        {
          v24 = v23 <= 1.0;
          if (v23 < -1.0)
            v24 = 0;
          if (!v10)
          {
            if (v24)
              goto LABEL_76;
            goto LABEL_82;
          }
          if (v24)
            goto LABEL_82;
          if (v12 - v17 <= 1.0 && v12 - v17 >= -1.0)
            goto LABEL_82;
        }
        else
        {
          v29 = v13 - v18;
          if (v23 > 1.0 || v29 > 1.0 || v29 < -1.0)
            goto LABEL_82;
        }
LABEL_50:
        if (!v10)
          goto LABEL_92;
      }
      if (v23 > 1.0)
        goto LABEL_82;
LABEL_76:
      v26 = v13 - v18;
LABEL_77:
      if (v26 > 1.0 || v26 >= -1.0)
        goto LABEL_92;
LABEL_82:
      if (v8[2] <= v6[2] + v6[5])
        continue;
      break;
    }
    v6 = *(double **)v6;
  }
  while (v6);
LABEL_95:
  segPumpFreeDiscoQueue((uint64_t)v42);
  return v7;
}

void segPumpSetStartingOffset(const void *a1, uint64_t a2, uint64_t a3)
{
  double MinimumPrebufferReservation;
  double v7;
  const void *v8;
  const void *v9;
  _BYTE *v10;
  double v11;
  double v12;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  double Current;
  double v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  double *v19;
  double v20;
  double v21;
  double v22;
  double v23;
  NSObject *v24;
  int v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  unsigned int value;
  unsigned int v31;
  const __CFString *v32;
  uint64_t v33;
  uint64_t v34;
  double v35;
  NSObject *v36;
  unsigned int v37;
  unsigned int v38;
  const __CFString *v39;
  uint64_t v40;
  uint64_t v41;
  double v42;
  NSObject *v43;
  unsigned int v44;
  unsigned int v45;
  const __CFString *v46;
  uint64_t v47;
  uint64_t v48;
  double PlaylistActiveDurationSecs;
  uint64_t DateStamp;
  CFIndex v51;
  double v52;
  double v53;
  const __CFArray *MediaSegmentSpecifiers;
  const __CFArray *v55;
  const void *ValueAtIndex;
  double *MediaFilePrivateData;
  double *v58;
  const __CFAllocator *AllocatorForMedia;
  double v60;
  CFDateRef v61;
  CFDateRef v62;
  CFTypeRef v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  CFTypeRef v67;
  NSObject *v68;
  double v69;
  double v70;
  CMTime v71;
  CMTime v72;
  int v73;
  const char *v74;
  __int16 v75;
  const __CFString *v76;
  __int16 v77;
  uint64_t v78;
  __int16 v79;
  uint64_t v80;
  __int16 v81;
  double v82;
  __int16 v83;
  double v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  MinimumPrebufferReservation = segPumpGetMinimumPrebufferReservation(a2, *(_QWORD *)(a3 + 56));
  v7 = *(double *)(a2 + 7960);
  v8 = *(const void **)(a3 + 232);
  if (v8)
    v9 = CFRetain(v8);
  else
    v9 = 0;
  v10 = (_BYTE *)(a2 + 8002);
  *(_BYTE *)(a3 + 866) = 0;
  segPumpUpdateCMCDStreamType(a2);
  if (*(_BYTE *)(a3 + 864))
  {
    v11 = *(double *)(a3 + 920);
    if (v11 != 0.0)
    {
      if (v9)
      {
        CFRelease(v9);
        v11 = *(double *)(a3 + 920);
      }
      v9 = CFDateCreate(*(CFAllocatorRef *)(a2 + 56), v11);
    }
  }
  v12 = MinimumPrebufferReservation + v7;
  if (v9)
  {
    memset(&v72, 0, sizeof(v72));
    memset(&v71, 0, sizeof(v71));
    v70 = 0.0;
    if (segPumpGetTimeRangeForDateWithSegmentOffset(a1, *(_QWORD *)(a3 + 56), (const __CFDate *)v9, &v72, &v71, &v70))
    {
      LODWORD(v69) = 0;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
LABEL_47:
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      goto LABEL_48;
    }
    v69 = 0.0;
    v17 = *(_QWORD *)a3;
    if (*(_BYTE *)(a3 + 864))
    {
      v18 = *(_QWORD *)(a2 + 16 * v17 + 384);
      v19 = (double *)(a3 + 88);
      *(double *)(a3 + 120) = v70 - *(double *)(a3 + 88);
      if (!v18)
        goto LABEL_43;
LABEL_25:
      if (!*v10
        && !segPumpGetTimeRangeForDateWithSegmentOffset(a1, *(_QWORD *)(v18 + 56), (const __CFDate *)v9, &v72, &v71, &v69))
      {
        v20 = v69;
        v21 = v70 - *v19;
        if (*v19 != v69 - v21)
        {
          if (dword_1EE2A31E8)
          {
            v68 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
            v20 = v69;
            v21 = v70 - *v19;
          }
          segPumpStreamSyncTimeRolledPast(a3, v21, v20);
        }
      }
      goto LABEL_43;
    }
    if (v17)
    {
      v18 = *(_QWORD *)(a2 + 384);
      if (!*(_BYTE *)(v18 + 866))
        goto LABEL_24;
      if (v17 == 1)
      {
LABEL_23:
        *(double *)(a3 + 120) = v70 - *(double *)(a3 + 88);
LABEL_43:
        if (!dword_1EE2A31E8)
          goto LABEL_48;
        v27 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
        goto LABEL_47;
      }
    }
    v18 = *(_QWORD *)(a2 + 400);
    if (*(_BYTE *)(v18 + 866))
      goto LABEL_23;
LABEL_24:
    v19 = (double *)(a3 + 88);
    *(double *)(a3 + 120) = v70 - *(double *)(a3 + 88);
    goto LABEL_25;
  }
  if (*(_QWORD *)(a3 + 240) && !*v10)
  {
    Current = CFAbsoluteTimeGetCurrent();
    v15 = MEMORY[0x194029D14](*(_QWORD *)(a3 + 240));
    if (dword_1EE2A31E8)
    {
      LODWORD(v72.value) = 0;
      LOBYTE(v71.value) = 0;
      v16 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    if (Current <= v15)
      goto LABEL_46;
    v22 = Current - v15;
    v23 = *(double *)(a3 + 96);
    if (v22 > v23)
    {
      LODWORD(v72.value) = 0;
      LOBYTE(v71.value) = 0;
      v24 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      *(_QWORD *)(a3 + 120) = 0x3F847AE147AE147BLL;
      goto LABEL_48;
    }
    v25 = dword_1EE2A31E8;
    if (!*(_BYTE *)(a3 + 857) && v22 < v12)
    {
      if (v12 >= v23)
        v22 = *(double *)(a3 + 96);
      else
        v22 = v12;
      if (!dword_1EE2A31E8)
      {
        *(double *)(a3 + 120) = v23 - v22;
        goto LABEL_48;
      }
      LODWORD(v72.value) = 0;
      LOBYTE(v71.value) = 0;
      v26 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      v25 = dword_1EE2A31E8;
      v23 = *(double *)(a3 + 96);
    }
    *(double *)(a3 + 120) = v23 - v22;
    if (v25)
    {
LABEL_46:
      LODWORD(v72.value) = 0;
      LOBYTE(v71.value) = 0;
      v28 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
      goto LABEL_47;
    }
  }
LABEL_48:
  if (*(double *)(a3 + 120) >= 0.0)
  {
    if (dword_1EE2A31E8)
    {
      LODWORD(v72.value) = 0;
      LOBYTE(v71.value) = 0;
      v29 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      value = v72.value;
      if (os_log_type_enabled(v29, v71.value))
        v31 = value;
      else
        v31 = value & 0xFFFFFFFE;
      if (v31)
      {
        v32 = *(const __CFString **)(a2 + 8760);
        if (!v32)
          v32 = &stru_1E2FD85F8;
        v33 = *(_QWORD *)a3;
        v34 = *(_QWORD *)(a3 + 120);
        v73 = 136315906;
        v74 = "segPumpSetStartingOffset";
        v75 = 2114;
        v76 = v32;
        v77 = 2048;
        v78 = v33;
        v79 = 2048;
        v80 = v34;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    goto LABEL_64;
  }
  if (!*(_BYTE *)(a2 + 8685) || *(_BYTE *)(a2 + 8686))
  {
    if (!*v10)
    {
LABEL_52:
      *(_BYTE *)(a3 + 112) = 1;
      goto LABEL_64;
    }
    goto LABEL_64;
  }
  v35 = *(double *)(a2 + 8688);
  *(double *)(a3 + 120) = v35;
  if (v35 < 0.0)
  {
    v35 = v35 + *(double *)(a3 + 96);
LABEL_105:
    *(double *)(a3 + 120) = v35;
    goto LABEL_106;
  }
  if (fabs(v35) < 0.00000011920929)
  {
    v35 = 0.01;
    goto LABEL_105;
  }
LABEL_106:
  if (!*v10 && v35 > *(double *)(a3 + 96) - v12)
  {
    segPumpAppendErrorLogEntry((uint64_t)a1, a2, a3, (const __CFURL **)(a3 + 408), -16831, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("START-TIME is too close to live"), 0, 0, 1u, 3u);
    goto LABEL_52;
  }
LABEL_64:
  if (*(_BYTE *)(a3 + 112) && (*(_DWORD *)(a3 + 160) & 0xFFFFFFFE) == 4)
  {
    if (v12 * 0.95 >= FigMediaPlaylistGetPlaylistActiveDurationSecs(*(_QWORD *)(a3 + 56)))
    {
      *(_QWORD *)(a3 + 120) = 0;
      if (dword_1EE2A31E8)
      {
        LODWORD(v72.value) = 0;
        LOBYTE(v71.value) = 0;
        v43 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        v44 = v72.value;
        if (os_log_type_enabled(v43, v71.value))
          v45 = v44;
        else
          v45 = v44 & 0xFFFFFFFE;
        if (!v45)
          goto LABEL_86;
        if (*(_QWORD *)(a2 + 8760))
          v46 = *(const __CFString **)(a2 + 8760);
        else
          v46 = &stru_1E2FD85F8;
        v47 = *(_QWORD *)a3;
        v48 = *(_QWORD *)(a3 + 120);
        PlaylistActiveDurationSecs = FigMediaPlaylistGetPlaylistActiveDurationSecs(*(_QWORD *)(a3 + 56));
        v73 = 136316418;
        v74 = "segPumpSetStartingOffset";
        v75 = 2114;
        v76 = v46;
        v77 = 2048;
        v78 = v47;
        v79 = 2048;
        v80 = v48;
        v81 = 2048;
        v82 = v12 * 0.95;
        v83 = 2048;
        v84 = PlaylistActiveDurationSecs;
        goto LABEL_85;
      }
    }
    else
    {
      *(double *)(a3 + 120) = FigMediaPlaylistGetPlaylistActiveDurationSecs(*(_QWORD *)(a3 + 56)) - v12 * 0.95;
      if (dword_1EE2A31E8)
      {
        LODWORD(v72.value) = 0;
        LOBYTE(v71.value) = 0;
        v36 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        v37 = v72.value;
        if (os_log_type_enabled(v36, v71.value))
          v38 = v37;
        else
          v38 = v37 & 0xFFFFFFFE;
        if (!v38)
          goto LABEL_86;
        if (*(_QWORD *)(a2 + 8760))
          v39 = *(const __CFString **)(a2 + 8760);
        else
          v39 = &stru_1E2FD85F8;
        v40 = *(_QWORD *)a3;
        v41 = *(_QWORD *)(a3 + 120);
        v42 = FigMediaPlaylistGetPlaylistActiveDurationSecs(*(_QWORD *)(a3 + 56));
        v73 = 136316162;
        v74 = "segPumpSetStartingOffset";
        v75 = 2114;
        v76 = v39;
        v77 = 2048;
        v78 = v40;
        v79 = 2048;
        v80 = v41;
        v81 = 2048;
        v82 = v42;
LABEL_85:
        _os_log_send_and_compose_impl();
LABEL_86:
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
    }
    *(_BYTE *)(a3 + 856) = 1;
    *(_BYTE *)(a3 + 112) = 0;
  }
  if (FigMediaPlaylistGetDateStampCount(*(_QWORD *)(a3 + 56)) >= 1 && (*(_DWORD *)(a3 + 160) & 0xFFFFFFFE) == 4)
  {
    DateStamp = 0;
    v51 = 0;
    v52 = *(double *)(a3 + 120) + *(double *)(a3 + 88);
    v53 = 0.0;
    while (1)
    {
      MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a3 + 56));
      if (MediaSegmentSpecifiers)
        MediaSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MediaSegmentSpecifiers);
      if (v51 >= (uint64_t)MediaSegmentSpecifiers)
        break;
      v55 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a3 + 56));
      ValueAtIndex = CFArrayGetValueAtIndex(v55, v51);
      MediaFilePrivateData = (double *)segPumpGetMediaFilePrivateData(ValueAtIndex);
      v58 = MediaFilePrivateData;
      if (DateStamp && MediaFilePrivateData[4] >= v52)
        goto LABEL_100;
      if (FigMediaSegmentSpecifierGetDateStamp((uint64_t)ValueAtIndex))
      {
        DateStamp = FigMediaSegmentSpecifierGetDateStamp((uint64_t)ValueAtIndex);
        v53 = v58[4];
      }
      ++v51;
    }
    if (!DateStamp)
      goto LABEL_121;
LABEL_100:
    AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    v60 = MEMORY[0x194029D14](DateStamp);
    v61 = CFDateCreate(AllocatorForMedia, v52 + v60 - v53);
    v62 = v61;
    if (!*(_QWORD *)(a3 + 232))
    {
      if (v61)
        v63 = CFRetain(v61);
      else
        v63 = 0;
      *(_QWORD *)(a3 + 232) = v63;
    }
    v64 = 0;
    v65 = a2 + 384;
    do
    {
      v66 = *(_QWORD *)(v65 + v64);
      if (*(double *)(v66 + 120) < 0.0 && !*(_QWORD *)(v66 + 232))
      {
        if (v62)
        {
          v67 = CFRetain(v62);
          v66 = *(_QWORD *)(v65 + v64);
        }
        else
        {
          v67 = 0;
        }
        *(_QWORD *)(v66 + 232) = v67;
      }
      v64 += 16;
    }
    while (v64 != 48);
    if (v62)
      CFRelease(v62);
  }
LABEL_121:
  *(_QWORD *)(a3 + 128) = 0xBFF0000000000000;
  if (v9)
    CFRelease(v9);
}

BOOL segPumpIsIndexFileResponseOutOfDate(uint64_t a1, uint64_t a2, __CFHTTPMessage *a3)
{
  _BOOL8 v3;
  unsigned int v4;
  const __CFString *v6;
  const __CFDate *v7;
  const __CFDate *ModifiedDateFromHTTPResponse;
  const __CFDate *v9;

  v3 = 0;
  if (a3)
  {
    v4 = *(_DWORD *)(a1 + 8);
    if (v4)
    {
      if (FigMediaPlaylistHasEndTag(*(_QWORD *)(a2 + 56)))
        return 0;
      v6 = FigCFHTTPCopyDateFromHTTPResponse(a3);
      if (!v6)
      {
        return 0;
      }
      else
      {
        v7 = (const __CFDate *)v6;
        ModifiedDateFromHTTPResponse = (const __CFDate *)FigCFHTTPCopyLastModifiedDateFromHTTPResponse(a3);
        if (ModifiedDateFromHTTPResponse)
        {
          v9 = ModifiedDateFromHTTPResponse;
          v3 = CFDateGetTimeIntervalSinceDate(v7, ModifiedDateFromHTTPResponse) > (double)v4 * 3.0;
          CFRelease(v9);
        }
        else
        {
          v3 = 0;
        }
        CFRelease(v7);
      }
    }
  }
  return v3;
}

uint64_t segPumpStreamHasPreloadConnectionForSegment(_QWORD *a1, const void *a2, int a3)
{
  uint64_t result;
  const __CFURL *v7;
  const __CFURL *v8;
  _QWORD *MediaFilePrivateData;
  const __CFURL *v10;
  const __CFURL *v11;

  if (!a2)
    return 0;
  result = FigMediaSegmentSpecifierGetURLString((uint64_t)a2);
  if (!result)
    return result;
  if (!a1[99])
    return 0;
  v7 = (const __CFURL *)a1[2];
  v8 = (const __CFURL *)a1[3];
  MediaFilePrivateData = segPumpGetMediaFilePrivateData(a2);
  segPumpEnsureMediaSegmentURLs(a2, v7, v8);
  if (!MediaFilePrivateData[2])
    return 0;
  v10 = (const __CFURL *)a1[2];
  v11 = (const __CFURL *)a1[3];
  segPumpGetMediaFilePrivateData(a2);
  segPumpEnsureMediaSegmentURLs(a2, v10, v11);
  result = FigCFEqual();
  if (a3)
  {
    if ((_DWORD)result)
      return segPumpMediaConnectionRangeIncludesMedia((_QWORD *)a1[99], (uint64_t)a2);
  }
  return result;
}

uint64_t segPumpRealizePreload(uint64_t a1, _QWORD *a2)
{
  uint64_t DerivedStorage;
  const void *i;
  const void *v6;
  CFIndex j;
  const __CFArray *PartialSegments;
  const __CFArray *v9;
  const void *ValueAtIndex;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const void *v18;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!segPumpShouldDoSegmentReadAheads((_BYTE *)DerivedStorage))
    return FigSignalErrorAt();
  FigMediaPlaylistGetMediaSegmentSpecifiers(a2[7]);
  for (i = (const void *)FigCFArrayGetLastValue();
        ;
        i = (const void *)FigMediaSegmentSpecifierGetPreviousSegment((uint64_t)v6))
  {
    v6 = i;
    if (!i)
      break;
    if (*((_BYTE *)segPumpGetMediaFilePrivateData(i) + 73))
    {
      v6 = 0;
      break;
    }
    for (j = 0; ; ++j)
    {
      PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v6);
      if (PartialSegments)
        PartialSegments = (const __CFArray *)CFArrayGetCount(PartialSegments);
      if (j >= (uint64_t)PartialSegments)
        break;
      v9 = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v6);
      ValueAtIndex = CFArrayGetValueAtIndex(v9, j);
      if (!*((_BYTE *)segPumpGetMediaFilePrivateData(ValueAtIndex) + 73)
        && segPumpStreamHasPreloadConnectionForSegment(a2, ValueAtIndex, 1))
      {
        if (ValueAtIndex)
          goto LABEL_17;
        break;
      }
    }
    if (segPumpStreamHasPreloadConnectionForSegment(a2, v6, 1))
      break;
  }
  ValueAtIndex = 0;
LABEL_17:
  if (ValueAtIndex)
    v6 = ValueAtIndex;
  if (!v6)
    return 0;
  if (FigMediaSegmentSpecifierIsMarkedAsGap((uint64_t)v6))
  {
    result = segPumpHandleMediaFileNetworkError(a1, a2, 0, (uint64_t)v6, 4294951877);
    if ((_DWORD)result)
      return result;
    return 0;
  }
  result = segPumpMediaConnectionRangeIncludesMedia((_QWORD *)a2[99], (uint64_t)v6);
  if ((_DWORD)result)
  {
    segPumpSetMediaConnectionIsDormant((_QWORD *)DerivedStorage, a2[99], 0);
    *(_QWORD *)(a2[99] + 40) = FigGetUpTimeNanoseconds();
    if ((uint64_t)a2[97] >= 1)
    {
      v12 = 0;
      v13 = 0;
      while (1)
      {
        v14 = *(_QWORD *)(a2[96] + 8 * v13);
        if (!v14)
          break;
        v15 = *(_QWORD *)(v14 + 8);
        if (v15)
        {
          if (FigMediaSegmentSpecifierGetType(v15) == 1)
            ++v12;
        }
        if (++v13 >= a2[97])
          return 0;
      }
      v16 = *(_BYTE *)(DerivedStorage + 329) ? 1 : *(int *)(DerivedStorage + 8212);
      if (v13 - v12 < v16)
      {
        v17 = a2[99];
        v18 = *(const void **)(v17 + 8);
        *(_QWORD *)(v17 + 8) = v6;
        CFRetain(v6);
        if (v18)
          CFRelease(v18);
        result = 0;
        *(_QWORD *)(a2[96] + 8 * v13) = a2[99];
        a2[99] = 0;
        return result;
      }
    }
    return 0;
  }
  return result;
}

uint64_t segPumpStreamHasPreloadMapHint(uint64_t a1)
{
  uint64_t result;
  uint64_t PreloadMapHint;

  result = *(_QWORD *)(a1 + 56);
  if (result)
  {
    result = FigMediaPlaylistGetPreloadMapHint(result);
    if (result)
    {
      PreloadMapHint = FigMediaPlaylistGetPreloadMapHint(*(_QWORD *)(a1 + 56));
      return FigMediaSegmentSpecifierIsReadInCurrent(PreloadMapHint) != 0;
    }
  }
  return result;
}

uint64_t segPumpStreamHasPreloadConnectionForMap(_QWORD *a1, const void *a2)
{
  const __CFURL *v4;
  const __CFURL *v5;
  _QWORD *MediaFilePrivateData;
  const __CFURL *v7;
  const __CFURL *v8;

  if (!a2)
    return 0;
  if (!a1[100])
    return 0;
  v4 = (const __CFURL *)a1[2];
  v5 = (const __CFURL *)a1[3];
  MediaFilePrivateData = segPumpGetMediaFilePrivateData(a2);
  segPumpEnsureMediaSegmentURLs(a2, v4, v5);
  if (!MediaFilePrivateData[2])
    return 0;
  v7 = (const __CFURL *)a1[2];
  v8 = (const __CFURL *)a1[3];
  segPumpGetMediaFilePrivateData(a2);
  segPumpEnsureMediaSegmentURLs(a2, v7, v8);
  return FigCFEqual();
}

void segPumpReconcileGapRenditionReports(uint64_t a1, CFArrayRef theArray)
{
  __CFArray *v4;
  CFIndex v5;
  _OWORD *v6;
  CFIndex i;
  const void *ValueAtIndex;
  __int128 v9;
  const __CFAllocator *AllocatorForMedia;
  const void *URL;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void (*v15)(uint64_t, const __CFString *, uint64_t);
  const void *v16;
  uint64_t v17;
  void (*v18)(uint64_t, __CFArray *);
  CFArrayCallBacks v19;

  v4 = 0;
  v5 = 0;
  v6 = (_OWORD *)MEMORY[0x1E0C9B378];
  if (!theArray)
    goto LABEL_3;
LABEL_2:
  for (i = CFArrayGetCount(theArray); v5 < i; i = 0)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, v5);
    if (FigRenditionReportSpecifierIsGapAtLive((uint64_t)ValueAtIndex))
    {
      if (!v4)
      {
        v9 = v6[1];
        *(_OWORD *)&v19.version = *v6;
        *(_OWORD *)&v19.release = v9;
        v19.equal = (CFArrayEqualCallBack)segPumpRenditionReportURLsAreEqual;
        AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
        v4 = CFArrayCreateMutable(AllocatorForMedia, 0, &v19);
      }
      URL = (const void *)FigRenditionReportSpecifierGetURL((uint64_t)ValueAtIndex);
      CFArrayAppendValue(v4, URL);
    }
    ++v5;
    if (theArray)
      goto LABEL_2;
LABEL_3:
    ;
  }
  if (v4 && !*(_QWORD *)(a1 + 9544))
  {
    v12 = FigGetAllocatorForMedia();
    if (!FigAlternateFilterMonitorCreateForRenditionDenyList(v12, (Boolean (__cdecl *)(const void *, const void *))segPumpRenditionReportURLsAreEqual, (CFTypeRef *)(a1 + 9544)))
    {
      v13 = *(_QWORD *)(a1 + 9544);
      v14 = *(_QWORD *)(a1 + 8152);
      v15 = *(void (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
      if (v15)
        v15(v13, CFSTR("AlternateFilterMonitorProperty_SelectedMedia"), v14);
      v16 = *(const void **)(a1 + 9528);
      if (v16)
      {
        if (!FigAlternateSelectionBossAddMonitor(v16, *(const void **)(a1 + 9544)))
          goto LABEL_18;
      }
      else
      {
        FigSignalErrorAt();
      }
    }
LABEL_22:
    CFRelease(v4);
    return;
  }
LABEL_18:
  v17 = *(_QWORD *)(a1 + 9544);
  if (v17)
  {
    v18 = *(void (**)(uint64_t, __CFArray *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
    if (v18)
      v18(v17, v4);
  }
  if (v4)
    goto LABEL_22;
}

uint64_t segPumpSendDateMapping(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  size_t DateStampCount;
  unint64_t v7;
  malloc_type_id_t v9;
  CFTypeRef *v10;
  double v11;
  uint64_t FirstValue;
  uint64_t NextSegment;
  uint64_t v14;
  const void *DateStamp;
  CFTypeRef *v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  uint64_t v21;
  uint64_t DerivedStorage;
  void (*v23)(uint64_t, const void *, _QWORD, uint64_t, CFTypeRef *);
  uint64_t v24;
  uint64_t v25;
  int v26;
  CFTypeRef *v27;
  CMTime v29;

  DateStampCount = FigMediaPlaylistGetDateStampCount(*((_QWORD *)a3 + 7));
  if (DateStampCount)
  {
    v7 = DateStampCount;
    DateStampCount *= 40;
    if (v7 > 0x666666666666666 || DateStampCount == 0)
      return 0;
    v9 = 1556728742;
  }
  else
  {
    v9 = 1270757447;
  }
  v10 = (CFTypeRef *)malloc_type_malloc(DateStampCount, v9);
  if (!v10)
    return 0;
  v11 = *((double *)a3 + 11);
  FigMediaPlaylistGetMediaSegmentSpecifiers(*((_QWORD *)a3 + 7));
  FirstValue = FigCFArrayGetFirstValue();
  if (FirstValue)
  {
    NextSegment = FirstValue;
    v14 = 0;
    do
    {
      if (v14 >= FigMediaPlaylistGetDateStampCount(*((_QWORD *)a3 + 7)))
        break;
      if (FigMediaSegmentSpecifierGetDateStamp(NextSegment))
      {
        DateStamp = (const void *)FigMediaSegmentSpecifierGetDateStamp(NextSegment);
        v16 = &v10[5 * v14];
        v16[3] = CFRetain(DateStamp);
        CMTimeMakeWithSeconds(&v29, v11, 90000);
        v17 = *(_OWORD *)&v29.value;
        v16[2] = (CFTypeRef)v29.epoch;
        *(_OWORD *)v16 = v17;
        v18 = *((_QWORD *)a3 + 39);
        v16[4] = (CFTypeRef)(FigMediaSegmentSpecifierGetDiscontinuityDomain(NextSegment) + v18);
        ++v14;
      }
      v11 = v11 + FigMediaSegmentSpecifierGetTimeInSeconds(NextSegment);
      NextSegment = FigMediaSegmentSpecifierGetNextSegment(NextSegment);
    }
    while (NextSegment);
  }
  else
  {
    v14 = 0;
  }
  v20 = *(const void **)(a2 + 176);
  v21 = *a3;
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v23 = *(void (**)(uint64_t, const void *, _QWORD, uint64_t, CFTypeRef *))(DerivedStorage + 168);
  if (!v23)
  {
LABEL_26:
    v19 = 0;
    v26 = 1;
    goto LABEL_28;
  }
  v24 = *(_QWORD *)(DerivedStorage + 16 * v21 + 384);
  v25 = *(_QWORD *)(v24 + 880);
  if (v20)
    CFRetain(v20);
  FigRetainProxyUnlockAll();
  v23(a1, v20, 0, v14, v10);
  if (v20)
    CFRelease(v20);
  FigRetainProxyRelock();
  if (!FigRetainProxyIsInvalidated())
  {
    if (v25 != *(_QWORD *)(v24 + 880))
    {
      v26 = 0;
      v19 = 4294951670;
      goto LABEL_28;
    }
    goto LABEL_26;
  }
  v26 = 0;
  v19 = 4294954413;
LABEL_28:
  if (v14 >= 1)
  {
    v27 = v10 + 3;
    do
    {
      if (*v27)
        CFRelease(*v27);
      v27 += 5;
      --v14;
    }
    while (v14);
  }
  free(v10);
  if (v26)
  {
    v19 = 0;
    *(_BYTE *)(a2 + 8005) = 1;
  }
  return v19;
}

uint64_t segPumpUpdateNetworkCostHasEndTag(uint64_t result)
{
  uint64_t v1;
  int v2;
  uint64_t (*v3)(uint64_t, __CFString *, uint64_t);
  uint64_t v4;

  v1 = *(_QWORD *)(result + 8472);
  if (v1)
  {
    v2 = *(unsigned __int8 *)(result + 8002);
    result = CMBaseObjectGetVTable();
    v3 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t))(*(_QWORD *)(result + 8) + 56);
    if (v3)
    {
      if (v2)
        v4 = *MEMORY[0x1E0C9AE50];
      else
        v4 = *MEMORY[0x1E0C9AE40];
      return v3(v1, CFSTR("FNCM_FullThrottleDutyCycleAllowable"), v4);
    }
  }
  return result;
}

uint64_t segPumpEnsureMediaSegmentURLs(const void *a1, const __CFURL *a2, const __CFURL *a3)
{
  const void *MediaFilePrivateData;
  uint64_t URLString;

  MediaFilePrivateData = segPumpGetMediaFilePrivateData(a1);
  URLString = FigMediaSegmentSpecifierGetURLString((uint64_t)a1);
  return FigStreamingPlaylistEnsureMediaURL(URLString, a2, a3, (CFTypeRef *)MediaFilePrivateData + 2, (CFURLRef *)MediaFilePrivateData + 3);
}

uint64_t segPumpMediaConnectionIncludesMedia(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t result;
  const __CFURL *v7;
  const __CFURL *v8;
  const void **MediaFilePrivateData;

  result = segPumpMediaConnectionIsActive(a2);
  if ((_DWORD)result)
  {
    v8 = *(const __CFURL **)(a1 + 16);
    v7 = *(const __CFURL **)(a1 + 24);
    MediaFilePrivateData = (const void **)segPumpGetMediaFilePrivateData(a3);
    segPumpEnsureMediaSegmentURLs(a3, v8, v7);
    result = FigCFHTTPCompareURLs(MediaFilePrivateData[2], *(CFTypeRef *)(a2 + 168));
    if ((_DWORD)result)
      return segPumpMediaConnectionRangeIncludesMedia((_QWORD *)a2, (uint64_t)a3);
  }
  return result;
}

uint64_t segPumpMediaConnectionIsActive(uint64_t result)
{
  if (result)
  {
    if (*(_QWORD *)(result + 32) || *(_QWORD *)(result + 104))
    {
      return 1;
    }
    else
    {
      result = *(_QWORD *)(result + 272);
      if (result)
        return CMBlockBufferGetDataLength((CMBlockBufferRef)result) != 0;
    }
  }
  return result;
}

BOOL segPumpMediaConnectionRangeIncludesMedia(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t StartOffset;
  _BOOL8 result;

  v4 = a1[38] + a1[30];
  result = 0;
  if (v4 <= FigMediaSegmentSpecifierGetStartOffset(a2))
  {
    v5 = a1[31];
    if (v5 < 1)
      return 1;
    v6 = a1[30] + v5;
    StartOffset = FigMediaSegmentSpecifierGetStartOffset(a2);
    if (v6 >= FigMediaSegmentSpecifierGetBytesToRead(a2) + StartOffset)
      return 1;
  }
  return result;
}

CFIndex segPumpSetDeliveryStatusForMediaFileAndParts(const void *a1, char a2)
{
  const __CFArray *PartialSegments;
  CFIndex v5;
  CFIndex result;
  const void *ValueAtIndex;

  *((_BYTE *)segPumpGetMediaFilePrivateData(a1) + 73) = a2;
  PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)a1);
  v5 = 0;
  if (!PartialSegments)
    goto LABEL_3;
LABEL_2:
  for (result = CFArrayGetCount(PartialSegments); v5 < result; result = 0)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(PartialSegments, v5);
    *((_BYTE *)segPumpGetMediaFilePrivateData(ValueAtIndex) + 73) = a2;
    ++v5;
    if (PartialSegments)
      goto LABEL_2;
LABEL_3:
    ;
  }
  return result;
}

const void *segPumpFindCryptKeyCommonData(uint64_t a1, uint64_t a2)
{
  const void *v4;
  CFIndex i;
  const __CFArray *Count;
  const void *ValueAtIndex;

  v4 = 0;
  for (i = 0; ; ++i)
  {
    Count = *(const __CFArray **)(a1 + 7688);
    if (Count)
      Count = (const __CFArray *)CFArrayGetCount(Count);
    if (i >= (uint64_t)Count)
      break;
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 7688), i);
    FigContentKeySpecifierGetIdentifier(a2);
    if (FigCFEqual())
      v4 = ValueAtIndex;
  }
  return v4;
}

const void *segPumpCreateCryptKeyCommonData(uint64_t a1)
{
  const void *Instance;
  __CFArray *Mutable;
  const __CFAllocator *AllocatorForMedia;
  __int128 v6;

  FigGetAllocatorForMedia();
  v6 = xmmword_1E2FA70D0;
  if (segPumpCryptKeyCommonDataGetTypeID_once != -1)
    dispatch_once_f(&segPumpCryptKeyCommonDataGetTypeID_once, &v6, (dispatch_function_t)segPumpRegisterClassUtil);
  Instance = (const void *)_CFRuntimeCreateInstance();
  if (Instance
    && ((Mutable = *(__CFArray **)(a1 + 7688)) != 0
     || (AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia(),
         Mutable = CFArrayCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B378]),
         (*(_QWORD *)(a1 + 7688) = Mutable) != 0)))
  {
    CFArrayAppendValue(Mutable, Instance);
  }
  else
  {
    FigSignalErrorAt();
  }
  return Instance;
}

void segPumpCryptKeyCommonDataFinalize(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  v3 = (const void *)a1[6];
  if (v3)
  {
    CFRelease(v3);
    a1[6] = 0;
  }
  v4 = (const void *)a1[7];
  if (v4)
  {
    CFRelease(v4);
    a1[7] = 0;
  }
  CryptKeyReleaseAndClearVideoDecryptor((uint64_t)a1);
  CryptKeyReleaseAndClearAudioDecryptor((uint64_t)a1);
}

CFStringRef segPumpCryptKeyCommonDataCopyDesc(uint64_t a1)
{
  const __CFAllocator *AllocatorForMedia;

  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  return CFStringCreateWithFormat(AllocatorForMedia, 0, CFSTR("CryptKeyCommonData: %p"), a1);
}

void CryptKeyReleaseAndClearVideoDecryptor(uint64_t a1)
{
  const void *v2;

  CMNotificationCenterGetDefaultLocalCenter();
  if (*(_QWORD *)(a1 + 64))
  {
    FigNotificationCenterRemoveWeakListener();
    FigNotificationCenterRemoveWeakListener();
    FigNotificationCenterRemoveWeakListener();
    FigNotificationCenterRemoveWeakListener();
    v2 = *(const void **)(a1 + 64);
    if (v2)
    {
      CFRelease(v2);
      *(_QWORD *)(a1 + 64) = 0;
    }
  }
  *(_QWORD *)(a1 + 72) = 0;
}

void CryptKeyReleaseAndClearAudioDecryptor(uint64_t a1)
{
  const void *v2;

  CMNotificationCenterGetDefaultLocalCenter();
  if (*(_QWORD *)(a1 + 104))
  {
    FigNotificationCenterRemoveWeakListener();
    FigNotificationCenterRemoveWeakListener();
    FigNotificationCenterRemoveWeakListener();
    v2 = *(const void **)(a1 + 104);
    if (v2)
    {
      CFRelease(v2);
      *(_QWORD *)(a1 + 104) = 0;
    }
  }
  *(_QWORD *)(a1 + 112) = 0;
}

uint64_t segPumpDecryptorNativeCryptorInvalidatedCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  CFTypeRef cf;

  v6 = 0;
  cf = 0;
  FigRetainProxyRetain();
  if (!segPumpLockAndCopyPumpFromRetainProxy(a2, &cf, &v6))
  {
    FigRetainProxyRetain();
    CMNotificationCenterGetDefaultLocalCenter();
    FigGetAllocatorForMedia();
    v3 = FigDeferNotificationToDispatchQueue();
    if ((_DWORD)v3)
    {
      v4 = v3;
      FigRetainProxyRelease();
      segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(a2, v4);
    }
  }
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
  return FigRetainProxyRelease();
}

uint64_t segPumpDecryptorReceivedKeyResponseCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  uint64_t v11;
  CFTypeRef cf;
  uint64_t v13;
  _QWORD v14[17];

  v14[16] = *MEMORY[0x1E0C80C00];
  v11 = 0;
  cf = 0;
  FigRetainProxyRetain();
  if (!segPumpLockAndCopyPumpFromRetainProxy(a2, &cf, &v11))
  {
    if (dword_1EE2A31E8)
    {
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    v7 = 384;
    while (1)
    {
      v8 = *(_QWORD *)(v11 + v7);
      v9 = *(const void **)(v8 + 248);
      if (v9)
      {
        v14[0] = 0;
        v13 = 0;
        if (segPumpGetCryptKeyCommonData(v9, v14, &v13))
          goto LABEL_12;
        if (*(_QWORD *)(v13 + 64) == a4 || *(_QWORD *)(v13 + 104) == a4)
          break;
      }
      v7 += 16;
      if (v7 == 432)
        goto LABEL_12;
    }
    segPumpContinueIfCryptKeyResponseWasAlreadySet((uint64_t)cf, v11, v8, v9, v13);
  }
LABEL_12:
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
  return FigRetainProxyRelease();
}

void segPumpDecryptorReceivedKeyRequestErrorCallback(int a1, uint64_t a2, int a3, uint64_t a4, CFDictionaryRef theDict)
{
  __CFError *Value;
  __CFError *v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  uint64_t AllocatorForMedia;
  void (*v13)(uint64_t, _QWORD, uint64_t, CFTypeRef *);
  __CFError *v14;
  CFIndex Code;
  CFTypeRef v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  int v21;
  CFTypeRef v22;
  const __CFString *Domain;
  uint64_t v24;
  uint64_t v25;
  CFTypeRef cf;
  int v27[2];
  CFTypeRef v28;
  uint64_t v29;
  uint64_t v30;

  *(_QWORD *)v27 = 0;
  v28 = 0;
  cf = 0;
  if (!theDict || (Value = (__CFError *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E0CA3120])) == 0)
  {
LABEL_32:
    FigSignalErrorAt();
    goto LABEL_29;
  }
  v8 = Value;
  if (segPumpLockAndCopyPumpFromRetainProxy(a2, &v28, (uint64_t *)v27))
    goto LABEL_29;
  v9 = 384;
  while (1)
  {
    v10 = *(_QWORD *)(*(_QWORD *)v27 + v9);
    v11 = *(const void **)(v10 + 248);
    if (v11)
    {
      v24 = 0;
      v25 = 0;
      if (segPumpGetCryptKeyCommonData(v11, &v25, &v24))
        goto LABEL_29;
      if (*(_QWORD *)(v24 + 64) == a4 || *(_QWORD *)(v24 + 104) == a4)
        break;
    }
    v9 += 16;
    if (v9 == 432)
      goto LABEL_29;
  }
  AllocatorForMedia = FigGetAllocatorForMedia();
  v13 = *(void (**)(uint64_t, _QWORD, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 48);
  if (v13)
  {
    v13(a4, *MEMORY[0x1E0CA31E0], AllocatorForMedia, &cf);
    v14 = (__CFError *)cf;
  }
  else
  {
    v14 = 0;
  }
  segPumpRTCReportingUpdateCryptorErrorKeys(*(uint64_t *)v27, v14);
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  Code = CFErrorGetCode(v8);
  if (Code != -16229)
  {
    v21 = Code;
    if (Code == (int)Code)
    {
      v22 = v28;
      Domain = CFErrorGetDomain(v8);
      segPumpHandleCryptKeyNetworkError((uint64_t)v22, v10, v11, v21, Domain, 0);
      goto LABEL_29;
    }
    goto LABEL_32;
  }
  v17 = *(_QWORD *)v27;
  v16 = v28;
  v29 = 0;
  v30 = 0;
  if (!segPumpGetCryptKeyCommonData(v11, &v30, &v29) && !*(_BYTE *)(v29 + 88))
  {
    v18 = *(_QWORD *)(v29 + 64);
    if (v18)
    {
      if (!segPumpPrepareCryptorForKeyLoading(v18, *(_QWORD *)(v29 + 72), 0, v29 + 96, v29 + 88))
      {
        if (*(_BYTE *)(v29 + 88))
        {
          v19 = *(_QWORD *)(v29 + 104);
          if (!v19
            || !segPumpPrepareCryptorForKeyLoading(v19, *(_QWORD *)(v29 + 112), 0, v29 + 136, v29 + 128))
          {
            v20 = *(const void **)(v10 + 248);
            *(_QWORD *)(v10 + 248) = v11;
            CFRetain(v11);
            if (v20)
              CFRelease(v20);
            *(_BYTE *)(v29 + 145) = 0;
            segPumpSendCryptKeyRequest(v16, v17, v10, v11);
          }
        }
      }
    }
  }
LABEL_29:
  segPumpUnlockAndSendAllPendingNotifications();
  if (v28)
    CFRelease(v28);
}

void segPumpCryptKeyRenewalCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t i;
  uint64_t v6;
  CFIndex v7;
  const __CFArray *ContentKeySpecifiers;
  const __CFArray *v9;
  const void *ValueAtIndex;
  const void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFTypeRef cf;

  v14 = 0;
  cf = 0;
  v12 = 0;
  v13 = 0;
  if (!segPumpLockAndCopyPumpFromRetainProxy(a2, &cf, &v14))
  {
    for (i = 0; i != 3; ++i)
    {
      v6 = *(_QWORD *)(v14 + 16 * i + 384);
      if (*(_QWORD *)(v6 + 56))
      {
        v7 = 0;
        while (1)
        {
          ContentKeySpecifiers = (const __CFArray *)FigMediaPlaylistGetContentKeySpecifiers(*(_QWORD *)(v6 + 56));
          if (ContentKeySpecifiers)
            ContentKeySpecifiers = (const __CFArray *)CFArrayGetCount(ContentKeySpecifiers);
          if (v7 >= (uint64_t)ContentKeySpecifiers)
            break;
          v9 = (const __CFArray *)FigMediaPlaylistGetContentKeySpecifiers(*(_QWORD *)(v6 + 56));
          ValueAtIndex = CFArrayGetValueAtIndex(v9, v7);
          if (segPumpGetCryptKeyCommonData(ValueAtIndex, &v13, &v12))
            goto LABEL_17;
          ++v7;
          if (*(_QWORD *)(v12 + 64) == a4)
          {
            if (!ValueAtIndex)
              break;
            if (v12)
            {
              v11 = *(const void **)(v6 + 248);
              *(_QWORD *)(v6 + 248) = ValueAtIndex;
              CFRetain(ValueAtIndex);
              if (v11)
                CFRelease(v11);
              *(_BYTE *)(v12 + 145) = 0;
              segPumpSendCryptKeyRequest(cf, v14, v6, ValueAtIndex);
            }
            goto LABEL_17;
          }
        }
      }
    }
  }
LABEL_17:
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
}

void segPumpDeferredDecryptorNativeCryptorInvalidatedCallback(int a1, int a2, int a3, uint64_t a4, CFDictionaryRef theDict)
{
  const __CFNumber *Value;
  uint64_t v7;
  unsigned int valuePtr;

  valuePtr = 0;
  if (theDict && (Value = (const __CFNumber *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E0CA3140])) != 0)
  {
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
    v7 = valuePtr;
  }
  else
  {
    v7 = 0;
  }
  segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(a4, v7);
}

uint64_t segPumpContinueIfCryptKeyResponseWasAlreadySet(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t AllocatorForMedia;
  unsigned int (*v16)(uint64_t, _QWORD, uint64_t, uint64_t);
  uint64_t v17;
  unsigned int (*v18)(uint64_t, _QWORD, uint64_t, uint64_t);

  v10 = *(_QWORD *)(a5 + 64);
  if (!v10)
  {
    if (!*(_QWORD *)(a5 + 104))
      return 0;
    v11 = 0;
    goto LABEL_6;
  }
  if (segPumpGetDecryptorState(v10) == 3)
  {
    v11 = *(_QWORD *)(a5 + 64);
LABEL_6:
    v12 = 1;
    goto LABEL_8;
  }
  v12 = 0;
  v11 = 0;
LABEL_8:
  v13 = *(_QWORD *)(a5 + 104);
  if (v13)
  {
    if (segPumpGetDecryptorState(v13) != 3)
      goto LABEL_21;
    v14 = *(_QWORD *)(a5 + 104);
  }
  else
  {
    v14 = 0;
  }
  if (v14)
    v11 = v14;
  if (!v12
    || (*(_BYTE *)(a5 + 144) = 1, !*(_BYTE *)(a2 + 322))
    || !segPumpCryptKeyIsLowValueFairPlayStreamingKey((uint64_t)a4)
    || (AllocatorForMedia = FigGetAllocatorForMedia(),
        (v16 = *(unsigned int (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                + 48)) != 0)
    && !v16(v11, *MEMORY[0x1E0CA31D8], AllocatorForMedia, a5 + 48)
    && (v17 = FigGetAllocatorForMedia(),
        (v18 = *(unsigned int (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                + 48)) != 0)
    && !v18(v11, *MEMORY[0x1E0CA31C8], v17, a5 + 56))
  {
LABEL_21:
    if (*(_BYTE *)(a5 + 144))
    {
      FigHTTPStopAndReleaseTimer((dispatch_object_t *)(a3 + 640));
      return segPumpContinueAfterKeyFetched(a1, a2, (_QWORD *)a3, a4);
    }
    return 0;
  }
  return FigSignalErrorAt();
}

uint64_t segPumpGetDecryptorState(uint64_t a1)
{
  uint64_t AllocatorForMedia;
  uint64_t (*v3)(uint64_t, _QWORD, uint64_t, CFNumberRef *);
  int v4;
  CFNumberRef v5;
  uint64_t v6;
  unsigned int valuePtr;
  CFNumberRef number;

  number = 0;
  valuePtr = 0;
  AllocatorForMedia = FigGetAllocatorForMedia();
  v3 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t, CFNumberRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                         + 48);
  if (!v3)
    return 0;
  v4 = v3(a1, *MEMORY[0x1E0CA31E8], AllocatorForMedia, &number);
  v5 = number;
  if (v4)
  {
    v6 = 0;
    if (!number)
      return v6;
    goto LABEL_4;
  }
  CFNumberGetValue(number, kCFNumberSInt32Type, &valuePtr);
  v6 = valuePtr;
  v5 = number;
  if (number)
LABEL_4:
    CFRelease(v5);
  return v6;
}

BOOL segPumpCryptKeyIsLowValueFairPlayStreamingKey(uint64_t a1)
{
  return FigContentKeySpecifierGetKeySystem(a1) == 1
      && FigContentKeySpecifierGetEncryptionMethod(a1) == 3;
}

uint64_t segPumpContinueAfterKeyFetched(uint64_t a1, uint64_t a2, _QWORD *a3, const void *a4)
{
  uint64_t CryptKeyCommonData;
  const void *v8;
  uint64_t v9;
  uint64_t NextCryptKeyForStream;
  uint64_t v12;
  uint64_t v13;

  v12 = 0;
  v13 = 0;
  CryptKeyCommonData = segPumpGetCryptKeyCommonData(a4, &v13, &v12);
  if (!(_DWORD)CryptKeyCommonData)
  {
    v8 = (const void *)a3[31];
    if (v8)
    {
      CFRelease(v8);
      a3[31] = 0;
    }
    v9 = 0;
    *(_BYTE *)(v12 + 145) = 0;
    while (1)
    {
      CryptKeyCommonData = segPumpContinueStreamAfterCryptKeyArrival(a1, a2, *(_QWORD **)(a2 + v9 + 384), v12);
      if ((_DWORD)CryptKeyCommonData)
        break;
      if (FigRetainProxyIsInvalidated())
        return FigSignalErrorAt();
      if (*(_QWORD *)(a2 + 7680))
      {
        CryptKeyCommonData = segPumpContinueStreamAfterCryptKeyArrival(a1, a2, *(_QWORD **)(a2 + v9 + 392), v12);
        if ((_DWORD)CryptKeyCommonData)
          return CryptKeyCommonData;
        if (FigRetainProxyIsInvalidated())
          return FigSignalErrorAt();
      }
      v9 += 16;
      if (v9 == 48)
      {
        if (a3[31])
          return 0;
        NextCryptKeyForStream = segPumpReadNextCryptKeyForStream(a1, a2, a3);
        if (!a3[31])
          segPumpResetConnection(a2, (uint64_t)(a3 + 68));
        return NextCryptKeyForStream;
      }
    }
  }
  return CryptKeyCommonData;
}

uint64_t segPumpContinueStreamAfterCryptKeyArrival(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  const void *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  void (*v11)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD);
  uint64_t v12;
  void (*v13)(uint64_t, __CFString *, __CFString *, uint64_t);
  const void *ContentKeySpecifier;
  const void *v15;
  uint64_t v17;
  _BOOL4 v18;
  char v19;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v21;
  const void *v22;
  uint64_t ParallelConnection;
  _QWORD *v24;
  unsigned int MediaForSingleStream;

  v7 = *(const void **)(a3[87] + 8);
  FigRetainProxyRetain();
  v8 = segPumpStreamWaitingForCryptKey(a2, a3, a4);
  if (*(uint64_t *)(a2 + 9592) >= 1)
  {
    v9 = FigGetUpTimeNanoseconds() - *(_QWORD *)(a2 + 9592);
    if (v9 >= 1)
    {
      v10 = *(_QWORD *)(a2 + 9048);
      if (v10)
      {
        v11 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
        if (v11)
          v11(v10, CFSTR("startupStats"), CFSTR("MediaFile2CKTime"), v9 / 0xF4240uLL, 0);
        v12 = *(_QWORD *)(a2 + 9048);
        if (v12)
        {
          v13 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                + 16)
                                                                                    + 32);
          if (v13)
            v13(v12, CFSTR("startupStats"), CFSTR("MediaFile2CKCount"), 1);
        }
      }
    }
  }
  if (!v8)
  {
    ParallelConnection = 0;
LABEL_51:
    v22 = (const void *)a1;
LABEL_40:
    if (!a3[32])
    {
      MediaForSingleStream = segPumpDeliverNextMediaForSingleStream(v22, a2, (uint64_t)a3);
      if (MediaForSingleStream == -12644)
        ParallelConnection = 0;
      else
        ParallelConnection = MediaForSingleStream;
    }
    goto LABEL_44;
  }
  if (!*(_BYTE *)(a4 + 144))
  {
    ParallelConnection = FigSignalErrorAt();
    goto LABEL_51;
  }
  ContentKeySpecifier = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v7);
  v15 = (const void *)a3[31];
  if (ContentKeySpecifier == v15 && v15 != 0)
  {
    CFRelease(ContentKeySpecifier);
    a3[31] = 0;
  }
  v17 = a3[87];
  if (v17 && (*(_QWORD *)(v17 + 32) || *(_QWORD *)(v17 + 104)))
  {
    v18 = 0;
    v19 = 1;
  }
  else
  {
    v19 = 0;
    v18 = a3[88] == 0;
  }
  if (dword_1EE2A31E8)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    v17 = a3[87];
  }
  v21 = a3[110];
  v22 = (const void *)a1;
  ParallelConnection = segPumpDeliverAccumulatedBuffer(a1, a2, (uint64_t)a3, v17, *(const void **)(v17 + 8), v18);
  if (!FigRetainProxyIsInvalidated())
  {
    if ((_DWORD)ParallelConnection)
      goto LABEL_40;
    if (v21 != a3[110])
      goto LABEL_39;
    v24 = (_QWORD *)a3[87];
    if ((const void *)v24[1] != v7)
      goto LABEL_39;
    if ((v19 & 1) == 0)
    {
      if (a3[88])
      {
        ParallelConnection = segPumpMoveToNextParallelConnection(a1, a2, (uint64_t)a3);
        if (FigRetainProxyIsInvalidated())
          goto LABEL_44;
        if ((_DWORD)ParallelConnection)
          goto LABEL_40;
        if (v21 != a3[110])
          goto LABEL_39;
        v24 = (_QWORD *)a3[87];
        if ((const void *)v24[1] != v7)
          goto LABEL_39;
      }
      else if (v7)
      {
        CFRelease(v7);
        *(_QWORD *)(a3[87] + 8) = 0;
        v24 = (_QWORD *)a3[87];
        if (!v24)
          goto LABEL_38;
      }
    }
    if (v24[4] || v24[13])
    {
LABEL_39:
      ParallelConnection = 0;
      goto LABEL_40;
    }
LABEL_38:
    if (!a3[88])
    {
      ParallelConnection = segPumpStreamProceedAfterMediaAndKeyArrival(a1, a2, (uint64_t)a3, v7, 1, 1);
      if (FigRetainProxyIsInvalidated() || !(_DWORD)ParallelConnection && v21 != a3[110])
        goto LABEL_44;
      goto LABEL_40;
    }
    goto LABEL_39;
  }
LABEL_44:
  FigRetainProxyRelease();
  return ParallelConnection;
}

const void *segPumpStreamWaitingForCryptKey(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v3;
  BOOL v4;
  const void *result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v8 = 0;
  v9 = 0;
  v3 = *(_QWORD *)(a2[87] + 8);
  if (*(_BYTE *)(a1 + 322))
    v4 = v3 == 0;
  else
    v4 = 1;
  if (v4 || a2[32] != v3 && a2[33] != v3)
    return 0;
  result = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier(*(_QWORD *)(a2[87] + 8));
  if (!result)
    return result;
  v7 = (uint64_t)result;
  if (segPumpGetCryptKeyCommonData(result, &v9, &v8)
    || FigMediaSegmentSpecifierGetType(v3) == 1
    && FigContentKeySpecifierGetEncryptionMethod(v7) - 1 < 2)
  {
    return 0;
  }
  return (const void *)(v8 == a3);
}

uint64_t segPumpDeliverAccumulatedBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, int a6)
{
  uint64_t v12;
  OpaqueCMBlockBuffer *v13;
  BOOL v14;
  size_t DataLength;
  int64_t v16;
  uint64_t v17;
  int64_t v18;
  const __CFAllocator *AllocatorForMedia;
  uint64_t appended;
  const __CFAllocator *v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  size_t v25;
  uint64_t v26;
  unsigned int v27;
  _QWORD *MediaFilePrivateData;
  BOOL v30;
  int v31;
  CMBlockBufferRef blockBufferOut;

  MediaFilePrivateData = segPumpGetMediaFilePrivateData(a5);
  v12 = MediaFilePrivateData[6];
  v13 = *(OpaqueCMBlockBuffer **)(a4 + 272);
  FigRetainProxyRetain();
  v14 = (*(const void **)(a3 + 256) == a5 || *(const void **)(a3 + 264) == a5) && *(_BYTE *)(a3 + 404) != 0;
  if (!v13)
  {
    v23 = 0;
    goto LABEL_49;
  }
  v30 = v14;
  v31 = a6;
  *(_QWORD *)(a4 + 272) = 0;
  DataLength = CMBlockBufferGetDataLength(v13);
  if (FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a5) < 1)
  {
    v16 = DataLength;
  }
  else
  {
    v16 = DataLength;
    v17 = DataLength + v12;
    if (v17 > FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a5)
      && !segPumpShouldPadByteCountForMediaSegment(a2, (uint64_t)a5))
    {
      v18 = v17 - FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a5);
      if (v18 >= 1)
      {
        blockBufferOut = 0;
        AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
        appended = CMBlockBufferCreateEmpty(AllocatorForMedia, 0, 0, &blockBufferOut);
        if ((_DWORD)appended
          || (v16 -= v18,
              appended = CMBlockBufferAppendBufferReference(blockBufferOut, v13, 0, v16, 0),
              (_DWORD)appended)
          || (v21 = (const __CFAllocator *)FigGetAllocatorForMedia(),
              appended = CMBlockBufferCreateEmpty(v21, 0, 0, (CMBlockBufferRef *)(a4 + 272)),
              (_DWORD)appended)
          || (appended = CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)(a4 + 272), v13, v16, v18, 0),
              (_DWORD)appended))
        {
          v23 = appended;
          goto LABEL_48;
        }
        CFRelease(v13);
        v13 = blockBufferOut;
      }
    }
  }
  if (v16 >= 1)
  {
    if (*(_QWORD *)(a2 + 296)
      && *(_QWORD *)(a3 + 64)
      && (!a5 || FigMediaSegmentSpecifierGetType((uint64_t)a5) != 1)
      && !MediaFilePrivateData[13]
      && segPumpCanAddSegmentToCache((uint64_t *)a2, (_QWORD *)a3, a5, 0))
    {
      segPumpCreateMediaSegmentCache(a2, a3, a5);
    }
    if (MediaFilePrivateData[13])
    {
      v22 = segPumpAppendBytesToCache(a2, a3, a5, v13, 0, v16, v31);
      if ((_DWORD)v22)
      {
LABEL_51:
        v23 = v22;
        if (!v13)
          goto LABEL_49;
        goto LABEL_48;
      }
    }
  }
  if (v31)
  {
    v23 = segPumpStreamUnchainMediaConnIfChaining(a1, (_QWORD *)a3, (_QWORD *)a4);
    v24 = v30;
    if ((_DWORD)v23)
      v24 = 0;
    if (!v24)
      goto LABEL_47;
    segPumpMarkMediaFileAsDelivered((uint64_t *)a3, a5);
  }
  else if (!v30)
  {
    goto LABEL_39;
  }
  if (!FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a5) || !*(_BYTE *)(a2 + 322))
  {
    if (v31 || v16 >= 1)
    {
      if (v31 && segPumpIsLastMediaFileDelivering(a3, (uint64_t)a5))
      {
        segPumpCheckAndMarkStreamCacheComplete(a2, a3, (uint64_t)a5);
        v27 = 2;
      }
      else
      {
        v27 = 0;
      }
      v23 = segPumpSendMediaCallback(a1, a2, a3, a5, v13, 0, v16, v31 != 0, v27);
      if (!(_DWORD)v23)
        FigRetainProxyIsInvalidated();
      goto LABEL_47;
    }
LABEL_39:
    v23 = 0;
    if (!v13)
      goto LABEL_49;
    goto LABEL_48;
  }
  v25 = CMBlockBufferGetDataLength(v13);
  v26 = segPumpMediaFileHandleCryptData(a1, a2, a3, a5, v13, 0, v25, v31 != 0, 0);
  if ((_DWORD)v26 == -12465)
  {
    v22 = segPumpHandleMediaFileNetworkError(a1, (_QWORD *)a3, 0, (uint64_t)a5, 4294954831);
    goto LABEL_51;
  }
  v23 = v26;
  if ((_DWORD)v26 == -12463)
  {
    v22 = segPumpHandleCryptFailure(a1, a2, a3);
    goto LABEL_51;
  }
LABEL_47:
  if (v13)
LABEL_48:
    CFRelease(v13);
LABEL_49:
  FigRetainProxyRelease();
  return v23;
}

uint64_t segPumpMoveToNextParallelConnection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  const void *v10;
  __int128 v11;
  __int128 v12;
  int v13;
  int v14;
  OpaqueCMBlockBuffer *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v6 = a3 + 696;
  v7 = *(_QWORD *)(*(_QWORD *)(a3 + 696) + 8);
  FigGetUpTimeNanoseconds();
  FigRetainProxyRetain();
  v8 = a3 + 704;
  v9 = *(_QWORD **)(a3 + 696);
  while (1)
  {
    v10 = (const void *)v9[1];
    if (v10)
    {
      CFRelease(v10);
      *(_QWORD *)(*(_QWORD *)v6 + 8) = 0;
    }
    if ((v11 = *(_OWORD *)v8,
          v12 = *(_OWORD *)(a3 + 720),
          *(_QWORD *)(v6 + 32) = *(_QWORD *)(a3 + 736),
          *(_OWORD *)v6 = v11,
          *(_OWORD *)(v6 + 16) = v12,
          *(_QWORD *)(a3 + 736) = 0,
          (v9 = *(_QWORD **)(a3 + 696)) != 0)
      && (v9[4] || v9[13])
      || *(_QWORD *)v8 && *(_QWORD *)(*(_QWORD *)v8 + 8) == v7)
    {
      v14 = 0;
      v13 = 1;
    }
    else
    {
      v13 = 0;
      v14 = 1;
    }
    v15 = (OpaqueCMBlockBuffer *)v9[34];
    if (v15)
      break;
LABEL_16:
    if (!v13 || v9[4] || v9[13])
    {
      FigGetUpTimeNanoseconds();
LABEL_20:
      v18 = 0;
      goto LABEL_21;
    }
  }
  v16 = *(_QWORD *)(a3 + 880);
  CMBlockBufferGetDataLength(v15);
  v17 = segPumpDeliverAccumulatedBuffer(a1, a2, a3, *(_QWORD *)(a3 + 696), *(const void **)(*(_QWORD *)(a3 + 696) + 8), v14);
  if (!(_DWORD)v17)
  {
    if (FigRetainProxyIsInvalidated())
      goto LABEL_20;
    if (v16 != *(_QWORD *)(a3 + 880))
      goto LABEL_20;
    v9 = *(_QWORD **)v6;
    if (*(_QWORD *)(*(_QWORD *)v6 + 8) != v7)
      goto LABEL_20;
    goto LABEL_16;
  }
  v18 = v17;
LABEL_21:
  FigRetainProxyRelease();
  return v18;
}

uint64_t segPumpStreamProceedAfterMediaAndKeyArrival(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, int a5, int a6)
{
  int Type;
  _QWORD *MediaFilePrivateData;
  _QWORD *v14;
  const void *v15;
  double TimeInSeconds;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  double ImputedDate;
  double PlaylistActiveDurationSecs;
  double v23;

  if (a4)
  {
    Type = FigMediaSegmentSpecifierGetType((uint64_t)a4);
    MediaFilePrivateData = segPumpGetMediaFilePrivateData(a4);
    if (Type == 1)
      goto LABEL_7;
  }
  else
  {
    MediaFilePrivateData = segPumpGetMediaFilePrivateData(0);
  }
  v14 = MediaFilePrivateData;
  v15 = (const void *)MediaFilePrivateData[2];
  if (!v15)
  {
    Type = 0;
    if (!a5)
      goto LABEL_31;
    goto LABEL_10;
  }
  CFRelease(v15);
  Type = 0;
  v14[2] = 0;
LABEL_7:
  if (!a5)
    goto LABEL_31;
LABEL_10:
  if (*(const void **)(a3 + 264) == a4)
  {
    v18 = *(_QWORD *)(a3 + 256);
    if (v18)
    {
      if (FigMediaSegmentSpecifierIsFragment(v18)
        || (FigMediaSegmentSpecifierGetPartialSegments(*(_QWORD *)(a3 + 256)),
            (const void *)FigCFArrayGetLastValue() != a4))
      {
        segPumpMarkMediaFileAsDelivered((uint64_t *)a3, a4);
        goto LABEL_26;
      }
    }
  }
  segPumpMarkMediaFileAsDelivered((uint64_t *)a3, a4);
  if (!a4 || FigMediaSegmentSpecifierGetType((uint64_t)a4) != 1)
  {
    ++*(_QWORD *)(a2 + 8480);
    if (segPumpConnectedInterfaceIsWWAN(a2))
      ++*(_QWORD *)(a2 + 8488);
    *(double *)(a2 + 8560) = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)a4) + *(double *)(a2 + 8560);
    *(double *)(a2 + 8568) = *((double *)segPumpGetMediaFilePrivateData(a4) + 10) + *(double *)(a2 + 8568);
    *(int64x2_t *)(a3 + 1104) = vaddq_s64(*(int64x2_t *)(a3 + 1104), vdupq_n_s64(1uLL));
    *(double *)(a3 + 1120) = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)a4) + *(double *)(a3 + 1120);
    if (*(_BYTE *)(a3 + 816))
      ++*(_QWORD *)(a3 + 1128);
    if (*(_QWORD *)a3 == 1)
    {
      TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)a4);
      v17 = 8656;
      goto LABEL_25;
    }
    if (!*(_QWORD *)a3)
    {
      TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)a4);
      v17 = 8648;
LABEL_25:
      *(double *)(a2 + v17) = TimeInSeconds + *(double *)(a2 + v17);
    }
  }
LABEL_26:
  v19 = a2 + 16 * *(_QWORD *)a3;
  if (*(_QWORD *)(v19 + 384) == a3)
  {
    v20 = *(_QWORD *)(v19 + 392);
    if (*(_BYTE *)(v20 + 861))
    {
      if (FigMediaSegmentSpecifierGetImputedDate((uint64_t)a4) != 0.0)
      {
        ImputedDate = FigMediaSegmentSpecifierGetImputedDate((uint64_t)a4);
        *(double *)(v20 + 920) = ImputedDate + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)a4) * 0.5;
      }
      PlaylistActiveDurationSecs = FigMediaPlaylistGetPlaylistActiveDurationSecs(*(_QWORD *)(a3 + 56));
      v23 = *((double *)segPumpGetMediaFilePrivateData(a4) + 4) - *(double *)(a3 + 88);
      *(double *)(v20 + 904) = PlaylistActiveDurationSecs
                             - (v23
                              + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)a4));
    }
  }
LABEL_31:
  if (a6)
    return segPumpMoveToNextMedia(a1, a2, a3, Type);
  else
    return 0;
}

uint64_t segPumpShouldPadByteCountForMediaSegment(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t ContentKeySpecifier;
  uint64_t v6;

  result = FigMediaSegmentSpecifierGetContentKeySpecifier(a2);
  if (result)
  {
    ContentKeySpecifier = FigMediaSegmentSpecifierGetContentKeySpecifier(a2);
    if (FigContentKeySpecifierGetEncryptionMethod(ContentKeySpecifier) != 3)
      return 0;
    v6 = FigMediaSegmentSpecifierGetContentKeySpecifier(a2);
    if (FigContentKeySpecifierGetEncryptionMethod(v6) == 4)
      return 0;
    result = 0;
    if (a2 && *(_BYTE *)(a1 + 8712))
    {
      if (!FigMediaSegmentSpecifierGetType(a2))
        return FigMediaSegmentSpecifierGetBytesToRead(a2) > 0;
      return 0;
    }
  }
  return result;
}

uint64_t segPumpCanAddSegmentToCache(uint64_t *a1, _QWORD *a2, const void *a3, _BYTE *a4)
{
  int v8;
  _QWORD *MediaFilePrivateData;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  double *v13;
  double *v14;
  uint64_t v16;
  double v17;
  char v18;
  uint64_t v19;
  _QWORD *v20;

  v19 = 0;
  v20 = 0;
  v18 = 0;
  if (a4)
    *a4 = 0;
  if (!a1[37])
    return 0;
  if (!a2[8])
    return 0;
  v8 = segPumpSeeIfMediaFileIsInCache((uint64_t)a1, (uint64_t)a2, a3, &v20, &v18);
  if (v8)
  {
    if (v18)
      return 0;
  }
  if (a4)
    *a4 = 1;
  MediaFilePrivateData = segPumpGetMediaFilePrivateData(a3);
  v10 = MediaFilePrivateData;
  if (v8)
  {
    v11 = v20;
    MediaFilePrivateData[13] = v20;
    if (MediaFilePrivateData[5])
    {
      FigStreamingCacheMediaSegmentGetLength(a1[37], a2[8], v11, 0, (unint64_t *)&v19);
      v12 = v10[5] - v19;
LABEL_12:
      v19 = v12;
      goto LABEL_16;
    }
    v12 = 0;
  }
  else if (FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a3))
  {
    v12 = FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a3);
    v19 = v12;
  }
  else
  {
    v12 = v10[5];
    if (v12)
      goto LABEL_12;
  }
LABEL_16:
  v13 = (double *)segPumpGetMediaFilePrivateData(a3);
  if (a1[37] && a2[8])
  {
    v14 = v13;
    if (!v12)
    {
      if (FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a3))
      {
        v12 = FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a3);
      }
      else
      {
        v12 = 1000000;
        v16 = a1[1018];
        if (v16)
        {
          if (*a2 == a1[1052])
          {
            v17 = (double)*(int *)(v16 + 24);
            v12 = (unint64_t)(FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)a3) * v17 * 0.125);
          }
        }
      }
    }
    if (FigStreamingCacheMediaStreamReserveSpaceForByteSize(a1[37], a2[8], (const void *)v12, v14[4]))
      return 0;
  }
  v10[13] = v20;
  return 1;
}

void segPumpCreateMediaSegmentCache(uint64_t a1, uint64_t a2, const void *a3)
{
  double *MediaFilePrivateData;
  uint64_t v7;
  uint64_t v8;
  CFTypeRef v9;
  uint64_t StartOffset;
  double v11;
  double TimeInSeconds;
  uint64_t MediaSequence;
  CFTypeRef cf;

  cf = 0;
  MediaFilePrivateData = (double *)segPumpGetMediaFilePrivateData(a3);
  if ((*(_BYTE *)(a1 + 7998) || !segPumpIsCacheDiskBacked(a1))
    && !segPumpCreateCacheNameFromSegment(a2, (uint64_t)a3, 0, &cf))
  {
    v7 = *(_QWORD *)(a1 + 296);
    v8 = *(_QWORD *)(a2 + 64);
    v9 = cf;
    StartOffset = FigMediaSegmentSpecifierGetStartOffset((uint64_t)a3);
    v11 = MediaFilePrivateData[4];
    TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)a3);
    MediaSequence = FigMediaSegmentSpecifierGetMediaSequence((uint64_t)a3);
    if (!FigStreamingCacheMediaStreamCreateMediaSegment(v7, v8, v9, StartOffset, MediaSequence, (_QWORD *)MediaFilePrivateData + 13, v11, TimeInSeconds))segPumpSetMediaFilePumpTimeOffsetsArray(a1, a2, a3);
  }
  if (cf)
    CFRelease(cf);
}

uint64_t segPumpAppendBytesToCache(uint64_t a1, uint64_t a2, const void *a3, OpaqueCMBlockBuffer *a4, size_t a5, size_t a6, int a7)
{
  char *MediaFilePrivateData;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  _DWORD **v18;
  uint64_t v19;
  unint64_t v20;

  MediaFilePrivateData = (char *)segPumpGetMediaFilePrivateData(a3);
  result = *(_QWORD *)(a1 + 296);
  if (result)
  {
    v16 = *(_QWORD *)(a2 + 64);
    if (v16)
    {
      v18 = (_DWORD **)(MediaFilePrivateData + 104);
      v17 = *((_QWORD *)MediaFilePrivateData + 13);
      if (v17)
      {
        if (a6)
        {
          result = FigStreamingCacheMediaSegmentAppendBytes(result, v16, v17, *((_QWORD *)MediaFilePrivateData + 15), a4, a5, a6);
          if ((_DWORD)result)
            goto LABEL_12;
        }
        *((_QWORD *)MediaFilePrivateData + 15) += a6;
        if (a7)
        {
          v20 = 0;
          FigStreamingCacheMediaSegmentGetLength(*(_QWORD *)(a1 + 296), *(_QWORD *)(a2 + 64), *v18, 0, &v20);
          if (FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a3)
            && (v19 = FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a3), v19 != v20))
          {
            result = 4294951672;
          }
          else
          {
            result = FigStreamingCacheMediaSegmentMarkComplete(*(_QWORD *)(a1 + 296), *(_QWORD *)(a2 + 64), *v18);
            *v18 = 0;
          }
LABEL_12:
          if ((int)result > -16244)
          {
            if ((_DWORD)result != -15641)
            {
              if ((_DWORD)result != -16243)
                return result;
              result = 0;
              *((_QWORD *)MediaFilePrivateData + 6) = 0;
              *((_QWORD *)MediaFilePrivateData + 7) = 0;
              *(_DWORD *)(MediaFilePrivateData + 71) = 0;
              *((_QWORD *)MediaFilePrivateData + 8) = 0;
              *((_QWORD *)MediaFilePrivateData + 14) = 0;
              *((_QWORD *)MediaFilePrivateData + 15) = 0;
              goto LABEL_20;
            }
          }
          else if ((result + 16246) >= 2 && (_DWORD)result != -16249)
          {
            return result;
          }
          result = 0;
LABEL_20:
          *v18 = 0;
          return result;
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t segPumpStreamUnchainMediaConnIfChaining(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *DerivedStorage;
  uint64_t result;
  OpaqueCMBlockBuffer *v8;
  size_t v9;
  uint64_t UpTimeNanoseconds;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  const void *v14;
  const void *PreloadHint;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  result = a2[7];
  if (result)
  {
    result = FigMediaPlaylistGetPreloadHint(result);
    if (result)
    {
      if ((_QWORD *)a2[87] != a3)
        return 0;
      result = segPumpMediaConnectionIsActive((uint64_t)a3);
      if ((_DWORD)result)
      {
        v8 = (OpaqueCMBlockBuffer *)a3[34];
        v9 = v8 ? CMBlockBufferGetDataLength(v8) : 0;
        UpTimeNanoseconds = FigGetUpTimeNanoseconds();
        v11 = a3[27] - v9;
        a3[37] = UpTimeNanoseconds;
        a3[38] = v11;
        if (a2[99])
          return 0;
        v12 = a3[31];
        if (v11 >= v12 && v12 > 0)
          return 0;
        a2[87] = 0;
        segPumpStreamMoveToNextFreeMediaConnection((uint64_t)a2);
        a2[99] = a3;
        result = segPumpRealizePreload(a1, a2);
        if (!(_DWORD)result)
        {
          if (a2[99])
          {
            if (segPumpStreamHasPreloadHint((uint64_t)a2)
              && (v13 = (const void *)FigMediaPlaylistGetPreloadHint(a2[7]),
                  segPumpStreamHasPreloadConnectionForSegment(a2, v13, 0)))
            {
              v14 = *(const void **)(a2[99] + 8);
              PreloadHint = (const void *)FigMediaPlaylistGetPreloadHint(a2[7]);
              *(_QWORD *)(a2[99] + 8) = PreloadHint;
              if (PreloadHint)
                CFRetain(PreloadHint);
              if (v14)
                CFRelease(v14);
              segPumpSetMediaConnectionIsDormant(DerivedStorage, a2[99], 1);
            }
            else
            {
              segPumpStreamCancelPreloadReadAndResetData((uint64_t)DerivedStorage, (uint64_t)a2);
            }
          }
          result = segPumpStreamSchedulePreloadHintRead(a1, a2);
          if (!(_DWORD)result)
            return 0;
        }
      }
    }
  }
  return result;
}

uint64_t segPumpMediaFileHandleCryptData(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, OpaqueCMBlockBuffer *a5, size_t a6, size_t a7, char a8, unsigned int a9)
{
  uint64_t ContentKeySpecifier;
  int EncryptionMethod;
  int v18;
  const void *v19;
  uint64_t CryptKeyCommonData;
  unsigned int v21;
  const __CFAllocator *AllocatorForMedia;
  uint64_t v23;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  size_t v25;
  size_t v26;
  size_t DataLength;
  uint64_t v28;
  CMBlockBufferRef blockBufferOut;
  uint64_t v32;
  uint64_t v33;
  size_t lengthAtOffsetOut[18];

  lengthAtOffsetOut[16] = *MEMORY[0x1E0C80C00];
  v32 = 0;
  v33 = 0;
  blockBufferOut = 0;
  ContentKeySpecifier = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a4);
  EncryptionMethod = FigContentKeySpecifierGetEncryptionMethod(ContentKeySpecifier);
  if (!*(_BYTE *)(a2 + 322))
  {
    CryptKeyCommonData = FigSignalErrorAt();
    goto LABEL_28;
  }
  v18 = EncryptionMethod;
  v19 = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a4);
  CryptKeyCommonData = segPumpGetCryptKeyCommonData(v19, &v33, &v32);
  if ((_DWORD)CryptKeyCommonData)
  {
LABEL_28:
    v28 = CryptKeyCommonData;
LABEL_29:
    if (blockBufferOut)
      CFRelease(blockBufferOut);
    return v28;
  }
  v21 = v18 - 3;
  if (*(_BYTE *)(v32 + 144))
  {
    if (v21 < 0xFFFFFFFE)
    {
      AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
      CryptKeyCommonData = CMBlockBufferCreateEmpty(AllocatorForMedia, 0, 0, &blockBufferOut);
      if (!(_DWORD)CryptKeyCommonData)
      {
        if (a7 || (a8 & 1) == 0)
        {
          v23 = a3;
          if (a7)
          {
            v25 = a7 + a6;
            do
            {
              lengthAtOffsetOut[0] = 0;
              CryptKeyCommonData = CMBlockBufferGetDataPointer(a5, a6, lengthAtOffsetOut, 0, 0);
              if ((_DWORD)CryptKeyCommonData)
                goto LABEL_28;
              v26 = lengthAtOffsetOut[0] >= a7 ? a7 : lengthAtOffsetOut[0];
              CryptKeyCommonData = segPumpMediaFileCreateDecryptedData(a1, a2, v23, a4, a5, a6, (char *)v26, a8 & (lengthAtOffsetOut[0] + a6 >= v25), blockBufferOut);
              if ((_DWORD)CryptKeyCommonData)
                goto LABEL_28;
              a6 += lengthAtOffsetOut[0];
              a7 -= v26;
            }
            while (a7);
          }
        }
        else
        {
          v23 = a3;
          CryptKeyCommonData = segPumpMediaFileCreateDecryptedData(a1, a2, a3, a4, a5, a6, 0, 1u, blockBufferOut);
          if ((_DWORD)CryptKeyCommonData)
            goto LABEL_28;
        }
        DataLength = CMBlockBufferGetDataLength(blockBufferOut);
        if ((a8 & 1) == 0 && !DataLength)
        {
          v28 = 0;
          goto LABEL_29;
        }
        CryptKeyCommonData = segPumpSendMediaCallback(a1, a2, v23, a4, blockBufferOut, 0, DataLength, a8, a9);
      }
      goto LABEL_28;
    }
LABEL_13:
    CryptKeyCommonData = segPumpSendMediaCallback(a1, a2, a3, a4, a5, a6, a7, a8, a9);
    goto LABEL_28;
  }
  if (a4 && v21 >= 0xFFFFFFFE && FigMediaSegmentSpecifierGetType((uint64_t)a4) == 1)
    goto LABEL_13;
  if (dword_1EE2A31E8)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  return FigSignalErrorAt();
}

uint64_t segPumpHandleCryptFailure(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const void *v6;
  _BYTE *MediaFilePrivateData;
  _BYTE *v8;
  uint64_t v9;
  const void *v10;

  v6 = *(const void **)(*(_QWORD *)(a3 + 696) + 8);
  if (v6 && (MediaFilePrivateData = segPumpGetMediaFilePrivateData(v6)) != 0)
  {
    v8 = MediaFilePrivateData;
    MediaFilePrivateData[99] = 1;
    v9 = *(_QWORD *)(a3 + 696);
    v10 = *(const void **)(v9 + 8);
    if (*(const void **)(a3 + 256) == v10 || *(const void **)(a3 + 264) == v10)
      v8[73] = 1;
    v8[97] = 1;
  }
  else
  {
    FigSignalErrorAt();
    v9 = *(_QWORD *)(a3 + 696);
    v10 = *(const void **)(v9 + 8);
  }
  *(_BYTE *)(a3 + 403) = 1;
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(*(_QWORD *)(a3 + 696) + 8) = 0;
    v9 = *(_QWORD *)(a3 + 696);
  }
  segPumpStreamDontReuseHTTPRequest(a2, v9);
  return segPumpDeliverNextMediaForSingleStream(a1, a2, a3);
}

uint64_t segPumpHandleMediaFileNetworkError(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage;
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  _BYTE *v13;
  uint64_t ErrorForOSStatus;
  const void *v15;
  CFTypeRef v16;
  const void *v17;
  CFTypeRef v18;
  __CFError *v19;
  int Code;
  CFDictionaryRef v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t MediaSequence;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v34;
  uint64_t v35;
  uint64_t CommonActionForNetworkError;
  CFTypeRef cf;
  uint64_t v39;
  uint64_t v40[18];

  v40[16] = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v10 = DerivedStorage;
  v11 = (_BYTE *)(DerivedStorage + 8176);
  cf = 0;
  if (!a3)
  {
    v13 = (_BYTE *)(DerivedStorage + 8177);
    if ((_DWORD)a5 != -12889 || *(_BYTE *)(DerivedStorage + 8177))
    {
LABEL_11:
      ErrorForOSStatus = FigCreateErrorForOSStatus(a5, (CFErrorRef *)&cf);
      if ((_DWORD)ErrorForOSStatus)
      {
LABEL_55:
        v25 = ErrorForOSStatus;
        goto LABEL_62;
      }
LABEL_12:
      if (!a3)
        goto LABEL_17;
      goto LABEL_13;
    }
LABEL_9:
    ErrorForOSStatus = segPumpCreateErrorFromHTTPRequestIfAvailable(0, -1005, (const __CFString *)*MEMORY[0x1E0C930A8], 0, (uint64_t *)&cf);
    if ((_DWORD)ErrorForOSStatus)
      goto LABEL_55;
    goto LABEL_12;
  }
  v12 = *(_QWORD *)(a3 + 16);
  ++*(_DWORD *)(a3 + 64);
  v13 = v11 + 1;
  if ((_DWORD)a5 == -12889 && !v11[1])
    goto LABEL_9;
  if (!v12)
    goto LABEL_11;
  ErrorForOSStatus = segPumpCreateErrorFromHTTPRequestIfAvailable(v12, a5, 0, 0, (uint64_t *)&cf);
  if ((_DWORD)ErrorForOSStatus)
    goto LABEL_55;
LABEL_13:
  v15 = *(const void **)(a3 + 72);
  v16 = cf;
  *(_QWORD *)(a3 + 72) = cf;
  if (v16)
    CFRetain(v16);
  if (v15)
    CFRelease(v15);
LABEL_17:
  v17 = (const void *)a2[37];
  v18 = cf;
  a2[37] = cf;
  if (v18)
    CFRetain(v18);
  if (v17)
    CFRelease(v17);
  v19 = (__CFError *)cf;
  v40[0] = 0;
  v39 = 0;
  Code = CFErrorGetCode((CFErrorRef)cf);
  CFErrorGetDomain(v19);
  v21 = CFErrorCopyUserInfo(v19);
  if (!*(_QWORD *)(*(_QWORD *)(v10 + 16 * *a2 + 384) + 16))
  {
    v24 = 0;
    goto LABEL_41;
  }
  v39 = 32;
  if (v11[536])
  {
LABEL_23:
    v22 = 5;
LABEL_24:
    v40[0] = v22;
    goto LABEL_28;
  }
  if (FigMediaSegmentSpecifierIsMarkedAsGap(a4))
  {
    v40[0] = 7;
    v23 = 48;
    goto LABEL_27;
  }
  if (FigCFEqual())
  {
    if (Code > -12669)
    {
      if (Code == -12465)
      {
        v22 = 8;
        goto LABEL_24;
      }
      if (Code != -12668)
        goto LABEL_72;
    }
    else if ((Code + 12939) >= 2)
    {
      if (Code == -12889)
      {
        v22 = 7;
        goto LABEL_24;
      }
      goto LABEL_72;
    }
    v34 = 0;
    v35 = v10 + 384;
    while (*(_QWORD *)(v10 + 8416) == v34 || !*(_QWORD *)(*(_QWORD *)v35 + 16))
    {
      ++v34;
      v35 += 16;
      if (v34 == 3)
      {
        if (!*(_QWORD *)(v10 + 8096))
          goto LABEL_23;
        break;
      }
    }
  }
LABEL_72:
  CommonActionForNetworkError = segPumpGetCommonActionForNetworkError(v19, v40, &v39);
  if (!(_DWORD)CommonActionForNetworkError)
  {
    if (v40[0] != 1)
    {
LABEL_28:
      segPumpModifyErrorActionIfCurrentAlternateIsLastValidAlternate(v10, a2, v40, &v39);
      v24 = v40[0];
      if (*v11)
      {
        if (v40[0] != 6 && v40[0] != 3)
        {
LABEL_41:
          v25 = 0;
          v26 = v39;
          if (!v21)
            goto LABEL_43;
          goto LABEL_42;
        }
        if ((v39 & 0x10) != 0)
        {
          v24 = 9;
LABEL_40:
          v40[0] = v24;
          goto LABEL_41;
        }
      }
      else if ((unint64_t)(v40[0] - 9) >= 0xFFFFFFFFFFFFFFFELL)
      {
        v40[0] = 3;
        goto LABEL_37;
      }
      if (v40[0] != 3)
        goto LABEL_41;
LABEL_37:
      if (*v13)
      {
        v24 = 3;
        goto LABEL_41;
      }
      v24 = 6;
      goto LABEL_40;
    }
    v40[0] = 7;
    v23 = v39 | 1;
LABEL_27:
    v39 = v23;
    goto LABEL_28;
  }
  v25 = CommonActionForNetworkError;
  v24 = 0;
  v26 = 0;
  if (v21)
LABEL_42:
    CFRelease(v21);
LABEL_43:
  if ((_DWORD)v25)
    goto LABEL_62;
  if (v24 == 3)
  {
    segPumpCancelMediaFileReadAndResetData(v10, (uint64_t)a2, 0, 1);
    v28 = (void *)cf;
    v29 = a1;
    v30 = (uint64_t)a2;
    v31 = 3;
LABEL_54:
    ErrorForOSStatus = segPumpHandleCommonNetworkError(v29, v30, v31, v26, (const __CFURL **)a3, 1u, v28);
    goto LABEL_55;
  }
  if (v24 != 9)
  {
    if (v24 == 5)
    {
      MediaSequence = FigMediaSegmentSpecifierGetMediaSequence(a4);
      segPumpDispatchAsyncMediaDelivery(v10, (uint64_t)a2, MediaSequence, -1, cf, (uint64_t)segPumpReplaceMediaFileWithDiscontinuity);
      goto LABEL_52;
    }
    v28 = (void *)cf;
    v29 = a1;
    v30 = (uint64_t)a2;
    v31 = v24;
    goto LABEL_54;
  }
  if (FigMediaSegmentSpecifierIsMarkedAsGap(a4))
  {
    if (dword_1EE2A31E8)
    {
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    goto LABEL_61;
  }
LABEL_52:
  segPumpAppendErrorLogEntryWithCFError(a1, v10, (uint64_t)a2, (const __CFURL **)a3, (CFErrorRef)cf, 2u, 3u);
LABEL_61:
  v25 = 0;
LABEL_62:
  if (cf)
    CFRelease(cf);
  return v25;
}

BOOL segPumpIsLastMediaFileDelivering(uint64_t a1, uint64_t a2)
{
  const void *NextSegment;
  int HasEndTag;
  _BOOL8 result;
  double *MediaFilePrivateData;
  CMTime v8;

  NextSegment = (const void *)FigMediaSegmentSpecifierGetNextSegment(a2);
  HasEndTag = FigMediaPlaylistHasEndTag(*(_QWORD *)(a1 + 56));
  result = 0;
  if (a2 && HasEndTag)
  {
    if (!FigMediaSegmentSpecifierGetType(a2))
    {
      if (!NextSegment)
        return 1;
      if ((*(_DWORD *)(a1 + 220) & 0x1D) == 1)
      {
        MediaFilePrivateData = (double *)segPumpGetMediaFilePrivateData(NextSegment);
        v8 = *(CMTime *)(a1 + 208);
        return CMTimeGetSeconds(&v8) <= MediaFilePrivateData[4];
      }
    }
    return 0;
  }
  return result;
}

void segPumpCheckAndMarkStreamCacheComplete(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  const __CFArray *MediaSegmentSpecifiers;
  const void *FirstValue;
  double *MediaFilePrivateData;
  CFTypeRef v10;
  const __CFDictionary *ValueAtIndex;
  CMTimeRange v12;
  CFTypeRef cf;
  CFArrayRef theArray;
  CMTimeValue value;
  CMTimeScale timescale;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  theArray = 0;
  cf = (CFTypeRef)*MEMORY[0x1E0C9AE40];
  if (*(_QWORD *)(a1 + 296))
  {
    if (*(_QWORD *)(a2 + 64))
    {
      v5 = *(_QWORD *)(a2 + 56);
      if (v5)
      {
        MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v5);
        if (MediaSegmentSpecifiers)
        {
          if (CFArrayGetCount(MediaSegmentSpecifiers) >= 1)
          {
            FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a2 + 56));
            FirstValue = (const void *)FigCFArrayGetFirstValue();
            MediaFilePrivateData = (double *)segPumpGetMediaFilePrivateData(FirstValue);
            FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a2 + 56));
            if (FigCFArrayGetLastValue() == a3
              && !FigStreamingCacheMediaStreamCopyPersistent(*(_QWORD *)(a1 + 296), *(_QWORD *)(a2 + 64), &cf))
            {
              v10 = cf;
              if (cf != (CFTypeRef)*MEMORY[0x1E0C9AE50])
                goto LABEL_19;
              if (!FigStreamingCacheMediaStreamCopyCachedTimeRanges(*(_QWORD *)(a1 + 296), *(_QWORD *)(a2 + 64), (CFTypeRef *)&theArray)&& CFArrayGetCount(theArray) == 1)
              {
                ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, 0);
                CMTimeRangeMakeFromDictionary(&v12, ValueAtIndex);
                value = v12.start.value;
                timescale = v12.start.timescale;
                if ((v12.start.flags & 1) == 0
                  || (v12.duration.flags & 1) == 0
                  || v12.duration.epoch
                  || v12.duration.value < 0)
                {
                  FigSignalErrorAt();
                }
                else
                {
                  v12.start.value = value;
                  v12.start.timescale = timescale;
                  if (vabdd_f64(CMTimeGetSeconds(&v12.start), MediaFilePrivateData[4]) < 2.22044605e-16)
                    FigStreamingCacheMediaStreamMarkComplete(*(_QWORD *)(a1 + 296), *(_QWORD *)(a2 + 64));
                }
              }
            }
          }
        }
      }
    }
  }
  v10 = cf;
LABEL_19:
  if (v10)
    CFRelease(v10);
  if (theArray)
    CFRelease(theArray);
}

uint64_t segPumpSendMediaCallback(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, OpaqueCMBlockBuffer *a5, size_t a6, size_t a7, char a8, unsigned int a9)
{
  _QWORD *MediaFilePrivateData;
  _QWORD *v17;
  unint64_t v18;
  size_t v19;
  const void *v20;
  uint64_t appended;
  size_t v22;
  size_t v23;
  uint64_t ContentKeySpecifier;
  OpaqueCMBlockBuffer *v25;
  size_t DataLength;
  unsigned int v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  size_t v31;
  const __CFAllocator *v32;
  uint64_t MapMediaBBuf;
  CFNumberRef v34;
  CFNumberRef v35;
  const void *v36;
  CFDictionaryRef v37;
  const void *v38;
  const void *v39;
  uint64_t v40;
  const void *v41;
  const void *v42;
  const void *IV;
  uint64_t v44;
  uint64_t v45;
  uint64_t AllocatorForMedia;
  uint64_t v47;
  uint64_t (*v48)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t);
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v50;
  uint64_t MapSegmentSpecifier;
  const __CFAllocator *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t (*v55)(uint64_t, uint64_t, uint64_t, CFDictionaryRef, uint64_t);
  NSObject *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t (*v59)(uint64_t, _QWORD, uint64_t);
  uint64_t v60;
  uint64_t v61;
  uint64_t (*v62)(uint64_t, uint64_t, uint64_t);
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t (*v70)(uint64_t, _QWORD, uint64_t);
  const __CFNumber *v71;
  const void **v72;
  _BOOL4 IsLastMediaFileDelivering;
  char v74;
  int v75;
  int v76;
  _BOOL4 v77;
  uint64_t v79;
  _BOOL4 v80;
  int v81;
  CMTimeValue value;
  int v83;
  const void *v84;
  const void *v85;
  uint64_t v86;
  unsigned int v87;
  CMTimeValue v88;
  void *v89;
  const void *v90;
  uint64_t ContiguousBlockBuffer;
  _QWORD *v92;
  CFDictionaryRef v93;
  const __CFAllocator *v94;
  uint64_t v95;
  uint64_t (*v96)(uint64_t, uint64_t, uint64_t, CFDictionaryRef, uint64_t *);
  size_t v97;
  OpaqueCMBlockBuffer *v98;
  size_t v99;
  OpaqueCMBlockBuffer *v100;
  void *v101;
  uint64_t v102;
  uint64_t v103;
  CMBlockBufferRef v104;
  unsigned int v105;
  void *v106;
  size_t v107;
  uint64_t StartOffset;
  uint64_t MediaSequence;
  uint64_t v110;
  const void *v111;
  uint64_t v112;
  uint64_t v113;
  const void *v114;
  uint64_t v116;
  const void *v117;
  uint64_t v118;
  char v119;
  const void *v120;
  uint64_t v121;
  const void *v122;
  const void *v123;
  uint64_t v124;
  double Seconds;
  uint64_t v126;
  uint64_t (*v127)(uint64_t, _QWORD, const void *);
  uint64_t (*v128)(uint64_t);
  const void *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t (*v132)(uint64_t, uint64_t, uint64_t, _QWORD, const void **);
  uint64_t v133;
  uint64_t (*v134)(const void *, _QWORD, const void *);
  const void *v135;
  uint64_t (*v136)(const void *, uint64_t, uint64_t);
  uint64_t v137;
  uint64_t v138;
  CMTimeEpoch v139;
  uint64_t v140;
  const void **v141;
  __int128 v142;
  uint64_t *v143;
  char v144;
  uint64_t v145;
  size_t v146;
  int v147;
  uint64_t v148;
  const void *v149;
  _BYTE *v151;
  NSObject *v152;
  unint64_t v153;
  uint64_t DateStamp;
  uint64_t v155;
  os_log_type_t type[8];
  _QWORD *v157;
  uint64_t v158;
  int v159;
  CMTime v160;
  CMBlockBufferRef blockBufferOut;
  CMTime v162;
  CMTime cf;
  CMBlockBufferRef valuePtr[17];
  uint64_t v165;

  v165 = *MEMORY[0x1E0C80C00];
  memset(&v162, 0, sizeof(v162));
  blockBufferOut = 0;
  memset(&v160, 0, sizeof(v160));
  FigRetainProxyRetain();
  v159 = 0;
  MediaFilePrivateData = segPumpGetMediaFilePrivateData(a4);
  v17 = MediaFilePrivateData;
  v18 = MediaFilePrivateData[6];
  v153 = MediaFilePrivateData[8];
  v19 = v153 - v18;
  if (v153 > v18)
  {
    if (a7 < v19)
    {
      v20 = 0;
      appended = 0;
      v22 = MediaFilePrivateData[7] + a7;
      MediaFilePrivateData[6] = v18 + a7;
      MediaFilePrivateData[7] = v22;
LABEL_14:
      LOBYTE(v27) = a9;
      goto LABEL_269;
    }
    v23 = MediaFilePrivateData[7] + v19;
    MediaFilePrivateData[6] = v153;
    MediaFilePrivateData[7] = v23;
    a7 -= v19;
    if (!a7)
    {
      v20 = 0;
      appended = 0;
      goto LABEL_14;
    }
    a6 += v19;
  }
  v145 = a1;
  if (FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a4) >= 1)
  {
    if (FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a4))
    {
      ContentKeySpecifier = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a4);
      if (FigContentKeySpecifierGetEncryptionMethod(ContentKeySpecifier) == 3)
      {
        if (a4 && FigMediaSegmentSpecifierGetType((uint64_t)a4) == 1)
        {
          v25 = *(OpaqueCMBlockBuffer **)(a3 + 832);
          if (v25)
            DataLength = CMBlockBufferGetDataLength(v25);
          else
            DataLength = 0;
          if (DataLength + a7 > FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a4))
            a7 = FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a4) - DataLength;
        }
        else
        {
          v28 = v17[8] + FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a4);
          v29 = v17[6];
          v30 = v29 + a7;
          v31 = v28 - v29;
          if (v30 > v28)
            a7 = v31;
        }
      }
    }
  }
  v32 = *(const __CFAllocator **)(a2 + 56);
  if (a5 && a7)
    MapMediaBBuf = CMBlockBufferCreateWithBufferReference(v32, a5, a6, a7, 0, &blockBufferOut);
  else
    MapMediaBBuf = CMBlockBufferCreateEmpty(v32, 0, 0, &blockBufferOut);
  v27 = a9;
  if ((_DWORD)MapMediaBBuf)
    goto LABEL_232;
  if ((a9 & 0x800) != 0)
  {
    valuePtr[0] = 0;
    valuePtr[0] = COERCE_CMBLOCKBUFFERREF(FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)a4));
    v34 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, valuePtr);
    if (!v34)
      goto LABEL_231;
    v35 = v34;
    CMSetAttachment(blockBufferOut, CFSTR("FBPAKey_ApproximateDuration"), v34, 1u);
    CFRelease(v35);
  }
  if (*((_BYTE *)v17 + 74))
    goto LABEL_26;
  if (!a4 || FigMediaSegmentSpecifierGetType((uint64_t)a4) != 1)
  {
    if (blockBufferOut)
    {
      if (!FigMediaSegmentSpecifierIsMarkedAsGap((uint64_t)a4))
      {
        v50 = *(_QWORD *)(a3 + 288);
        if (v50 != FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)a4)
          || *(_QWORD *)(a3 + 320) != *(_QWORD *)(a3 + 304)
          || *(_BYTE *)(a3 + 403))
        {
          if (FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)a4))
          {
            MapSegmentSpecifier = FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)a4);
            MapMediaBBuf = segPumpCreateMapMediaBBuf(a2, a3, MapSegmentSpecifier, (CFTypeRef *)&blockBufferOut);
            if ((_DWORD)MapMediaBBuf)
              goto LABEL_232;
          }
          goto LABEL_70;
        }
      }
      if (blockBufferOut && *(_BYTE *)(a2 + 8712) && *(_BYTE *)(a3 + 862))
        v27 = (FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)a4) == 0) | a9;
    }
LABEL_26:
    v144 = 1;
    goto LABEL_27;
  }
LABEL_70:
  v144 = 0;
  v27 = (*(_BYTE *)(a2 + 8712) != 0) | a9;
LABEL_27:
  v151 = (_BYTE *)(a2 + 7992);
  if (!FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a4))
  {
    v38 = 0;
    v39 = 0;
    if (!a4)
      goto LABEL_102;
    goto LABEL_100;
  }
  v146 = a7;
  v36 = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a4);
  v157 = 0;
  v158 = 0;
  MapMediaBBuf = segPumpGetCryptKeyCommonData(v36, &v158, &v157);
  if ((_DWORD)MapMediaBBuf)
    goto LABEL_232;
  if (FigContentKeySpecifierGetKeySystem((uint64_t)v36) == 2
    && FigContentKeySpecifierGetEncryptionMethod((uint64_t)v36) == 1
    && (!a4 || FigMediaSegmentSpecifierGetType((uint64_t)a4) != 1))
  {
    v40 = v158;
    if (*(_QWORD *)(v158 + 40))
    {
      FigMediaSegmentSpecifierGetIV((uint64_t)a4);
      if (FigCFEqual())
        goto LABEL_94;
      v40 = v158;
      v41 = *(const void **)(v158 + 40);
      if (v41)
      {
        CFRelease(v41);
        v40 = v158;
        *(_QWORD *)(v158 + 40) = 0;
      }
    }
    v42 = *(const void **)(v40 + 32);
    IV = (const void *)FigMediaSegmentSpecifierGetIV((uint64_t)a4);
    *(_QWORD *)(v158 + 32) = IV;
    if (IV)
      CFRetain(IV);
    if (v42)
      CFRelease(v42);
    v44 = segPumpEnsureAndSetupBasicAESProtector(a2);
    if (!(_DWORD)v44)
    {
      v45 = *(_QWORD *)(a2 + 248);
      AllocatorForMedia = FigGetAllocatorForMedia();
      v47 = v158;
      v48 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                             + 16)
                                                                                 + 104);
      if (!v48)
        goto LABEL_87;
      v44 = v48(v45, AllocatorForMedia, 1, 0, v47 + 40);
      if (!(_DWORD)v44)
      {
        if (dword_1EE2A31E8)
        {
          *(_DWORD *)&type[4] = 0;
          type[0] = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        v57 = *(_QWORD *)(v158 + 40);
        v58 = v157[6];
        v59 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
        if (v59)
        {
          MapMediaBBuf = v59(v57, *MEMORY[0x1E0CA31D8], v58);
          if ((_DWORD)MapMediaBBuf)
            goto LABEL_232;
          v60 = *(_QWORD *)(v158 + 32);
          v61 = *(_QWORD *)(v158 + 40);
          v62 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
          if (v62)
          {
            v63 = *MEMORY[0x1E0CA31C8];
            v64 = v61;
            v65 = v60;
            goto LABEL_90;
          }
LABEL_177:
          appended = 4294954514;
          goto LABEL_233;
        }
LABEL_87:
        appended = 4294954514;
LABEL_233:
        v20 = 0;
        goto LABEL_269;
      }
    }
    appended = v44;
    goto LABEL_233;
  }
  if (FigContentKeySpecifierGetKeySystem((uint64_t)v36) == 2
    && FigContentKeySpecifierGetEncryptionMethod((uint64_t)v36) == 2
    && (!a4 || FigMediaSegmentSpecifierGetType((uint64_t)a4) != 1))
  {
    if (!*(_QWORD *)(v158 + 40))
    {
      MapMediaBBuf = segPumpEnsureAndSetupBasicAESProtector(a2);
      if ((_DWORD)MapMediaBBuf)
        goto LABEL_232;
      if (*v151 && !*(_QWORD *)a3)
      {
        v52 = (const __CFAllocator *)FigGetAllocatorForMedia();
        v37 = CFDictionaryCreate(v52, (const void **)kFigCPEProtectorCryptorCreationOption_DecryptDestination, (const void **)kFigCPEProtectorCryptorCreationOptionDecryptDestination_Nero, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      }
      else
      {
        v37 = 0;
      }
      v53 = *(_QWORD *)(a2 + 248);
      v148 = FigGetAllocatorForMedia();
      v54 = v158;
      v55 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFDictionaryRef, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                          + 104);
      if (v55)
        appended = v55(v53, v148, 1, v37, v54 + 40);
      else
        appended = 4294954514;
      if (v37)
        CFRelease(v37);
      if ((_DWORD)appended)
        goto LABEL_233;
      if (dword_1EE2A31E8)
      {
        *(_DWORD *)&type[4] = 0;
        type[0] = OS_LOG_TYPE_DEFAULT;
        v56 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
    }
    v66 = *(_QWORD *)(v158 + 40);
    v67 = v157[6];
    v62 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
    if (v62)
    {
      v63 = *MEMORY[0x1E0CA31D8];
      v64 = v66;
      v65 = v67;
LABEL_90:
      MapMediaBBuf = v62(v64, v63, v65);
      if ((_DWORD)MapMediaBBuf)
        goto LABEL_232;
      v68 = *(_QWORD *)(a2 + 264);
      if (!v68)
        goto LABEL_94;
      v69 = *(_QWORD *)(v158 + 40);
      v70 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
      if (v70)
      {
        MapMediaBBuf = v70(v69, *MEMORY[0x1E0CA31C0], v68);
        if (!(_DWORD)MapMediaBBuf)
          goto LABEL_94;
LABEL_232:
        appended = MapMediaBBuf;
        goto LABEL_233;
      }
      goto LABEL_177;
    }
    goto LABEL_177;
  }
LABEL_94:
  if (FigContentKeySpecifierGetEncryptionMethod((uint64_t)v36) == 3)
  {
    v38 = 0;
    v39 = 0;
    a7 = v146;
    if (!a4)
      goto LABEL_102;
  }
  else
  {
    v39 = *(const void **)(v158 + 40);
    a7 = v146;
    if (!v39)
      v39 = (const void *)v157[8];
    v38 = (const void *)v157[13];
    if (!a4)
      goto LABEL_102;
  }
LABEL_100:
  if (FigMediaSegmentSpecifierGetType((uint64_t)a4) == 1)
  {
    v149 = 0;
    goto LABEL_112;
  }
LABEL_102:
  v149 = 0;
  if (*(_QWORD *)a3 == *(_QWORD *)(a2 + 8416) && !v39)
  {
    v71 = *(const __CFNumber **)(a2 + 264);
    if (!v71 && (*(_DWORD *)(a2 + 288) & 0x80000000) != 0)
    {
      v149 = 0;
      goto LABEL_116;
    }
    v72 = (const void **)(a2 + 272);
    if (*(_QWORD *)(a2 + 272))
    {
      if (v38)
      {
        v149 = 0;
LABEL_111:
        v39 = *v72;
        goto LABEL_112;
      }
      if (*(_QWORD *)(a2 + 280))
      {
        v149 = 0;
        v38 = *(const void **)(a2 + 280);
        goto LABEL_111;
      }
    }
    valuePtr[0] = 0;
    cf.value = 0;
    v81 = *(_DWORD *)(a2 + 288);
    if (v81 == 1)
    {
      value = 2;
    }
    else
    {
      value = 0;
      if (v81)
      {
LABEL_213:
        if (v71)
        {
          CFNumberGetValue(v71, kCFNumberSInt64Type, valuePtr);
          value = cf.value;
          v88 = (CMTimeValue)valuePtr[0];
        }
        else
        {
          v88 = 0;
        }
        v143 = (uint64_t *)(a2 + 272);
        if (value > v88)
        {
          v89 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &cf);
          goto LABEL_220;
        }
        v90 = *(const void **)(a2 + 264);
        if (v90)
        {
          v89 = (void *)CFRetain(v90);
LABEL_220:
          v149 = v89;
          if (v89)
          {
            ContiguousBlockBuffer = segPumpEnsureAndSetupBasicAESProtector(a2);
            if ((_DWORD)ContiguousBlockBuffer)
              goto LABEL_316;
            if (*v151)
            {
              v92 = (_QWORD *)(a2 + 272);
              if (*(_QWORD *)a3)
              {
                v93 = 0;
              }
              else
              {
                v94 = (const __CFAllocator *)FigGetAllocatorForMedia();
                v93 = CFDictionaryCreate(v94, (const void **)kFigCPEProtectorCryptorCreationOption_DecryptDestination, (const void **)kFigCPEProtectorCryptorCreationOptionDecryptDestination_Nero, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              }
            }
            else
            {
              v93 = 0;
              v92 = (_QWORD *)(a2 + 272);
            }
            if (*v92)
            {
              appended = 0;
            }
            else
            {
              v95 = *(_QWORD *)(a2 + 248);
              v140 = FigGetAllocatorForMedia();
              v96 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFDictionaryRef, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 104);
              if (v96)
                appended = v96(v95, v140, 1, v93, v143);
              else
                appended = 4294954514;
            }
            if (v93)
              CFRelease(v93);
            if ((_DWORD)appended)
              goto LABEL_268;
            v126 = *v143;
            if (!*v151)
            {
              v127 = *(uint64_t (**)(uint64_t, _QWORD, const void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                             + 56);
              if (!v127)
                goto LABEL_317;
              ContiguousBlockBuffer = v127(v126, *MEMORY[0x1E0CA31C0], v149);
              if ((_DWORD)ContiguousBlockBuffer)
                goto LABEL_316;
              v126 = *v143;
            }
            v128 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
            if (v128)
            {
              v137 = *MEMORY[0x1E0C9AE50];
              v138 = *MEMORY[0x1E0CA3218];
              ContiguousBlockBuffer = v128(v126);
              if ((_DWORD)ContiguousBlockBuffer)
                goto LABEL_316;
              v141 = (const void **)(a2 + 280);
              v129 = *(const void **)(a2 + 280);
              if (!v129)
              {
                v130 = *(_QWORD *)(a2 + 248);
                v131 = FigGetAllocatorForMedia();
                v132 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, const void **))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                  + 104);
                if (!v132)
                {
                  appended = 4294954514;
                  goto LABEL_268;
                }
                v133 = v132(v130, v131, 1, 0, v141);
                if ((_DWORD)v133)
                {
                  appended = v133;
                  goto LABEL_268;
                }
                v129 = *v141;
              }
              v134 = *(uint64_t (**)(const void *, _QWORD, const void *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                              + 8)
                                                                                  + 56);
              if (v134)
              {
                ContiguousBlockBuffer = v134(v129, *MEMORY[0x1E0CA31C0], v149);
                if ((_DWORD)ContiguousBlockBuffer)
                  goto LABEL_316;
                v135 = *v141;
                v136 = *(uint64_t (**)(const void *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                + 56);
                if (v136)
                {
                  ContiguousBlockBuffer = v136(v135, v138, v137);
                  if ((_DWORD)ContiguousBlockBuffer)
                    goto LABEL_316;
                  if (!v38)
                    v38 = *v141;
                  v72 = (const void **)(a2 + 272);
                  goto LABEL_111;
                }
              }
            }
LABEL_317:
            appended = 4294954514;
            goto LABEL_268;
          }
        }
LABEL_231:
        MapMediaBBuf = FigSignalErrorAt();
        goto LABEL_232;
      }
      value = 1;
    }
    cf.value = value;
    goto LABEL_213;
  }
LABEL_112:
  if (blockBufferOut && v39 && *(_BYTE *)(a2 + 322))
    CMSetAttachment(blockBufferOut, CFSTR("FBPAKey_Decryptor"), v39, 1u);
LABEL_116:
  if (blockBufferOut && v38 && *(_BYTE *)(a2 + 322))
    CMSetAttachment(blockBufferOut, CFSTR("FBPAKey_AudioDecryptor"), v38, 1u);
  IsLastMediaFileDelivering = segPumpIsLastMediaFileDelivering(a3, (uint64_t)a4);
  v74 = a8;
  if ((a8 & 1) != 0 && IsLastMediaFileDelivering)
  {
    v27 |= 2u;
    segPumpCheckAndMarkStreamCacheComplete(a2, a3, *(_QWORD *)(a3 + 256));
  }
  if (*(_BYTE *)(a3 + 864))
    v75 = v27 | 0x1000;
  else
    v75 = v27;
  if (*(_BYTE *)(a3 + 865))
    v76 = v75 | 0x2000;
  else
    v76 = v75;
  if (*(_BYTE *)(a3 + 862))
  {
    *(_BYTE *)(a3 + 862) = 0;
    if (!*(_BYTE *)(a3 + 857))
      v76 |= 4u;
  }
  if (*(_BYTE *)(a3 + 863))
  {
    *(_BYTE *)(a3 + 863) = 0;
    v76 |= 0x200u;
  }
  if (*(_BYTE *)(a3 + 403))
  {
    v76 |= 1u;
    *(_BYTE *)(a3 + 403) = 0;
  }
  if (a4 && *(_BYTE *)(a3 + 856) && !FigMediaSegmentSpecifierGetType((uint64_t)a4))
  {
    *(_BYTE *)(a3 + 856) = 0;
    v76 |= 0x4000u;
  }
  if (*(_BYTE *)(a2 + 8712))
  {
    if (v153 > v18 || !*((_BYTE *)v17 + 74))
      v76 |= 0x10u;
    if (a4)
      v77 = FigMediaSegmentSpecifierGetType((uint64_t)a4) == 0;
    else
      v77 = 0;
    if (v77 && (a8 & 1) != 0)
      v76 |= 0x20u;
  }
  if (*((_BYTE *)v17 + 74))
    v27 = v76;
  else
    v27 = v76 | 0x100;
  if (a4 && (v27 & 0x20) != 0 && !FigMediaSegmentSpecifierGetType((uint64_t)a4))
  {
    FigGetUpTimeNanoseconds();
    *(_OWORD *)(a2 + 8824) = 0u;
  }
  if ((a8 & 1) != 0)
  {
    v79 = *(_QWORD *)(a3 + 56);
    if (v79)
    {
      FigMediaPlaylistGetMediaSegmentSpecifiers(v79);
      if ((const void *)FigCFArrayGetLastValue() == a4)
        v27 |= 0xC0u;
      else
        v27 |= 0x40u;
    }
    else
    {
      v27 |= 0x40u;
    }
  }
  v142 = *MEMORY[0x1E0CA2E18];
  *(_OWORD *)&v162.value = *MEMORY[0x1E0CA2E18];
  v139 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  v162.epoch = v139;
  if (*((_BYTE *)v17 + 74))
  {
    v147 = 0;
    DateStamp = 0;
    goto LABEL_234;
  }
  if (v153 > v18)
  {
    v80 = 0;
    if (!a4 || !*(_BYTE *)(a2 + 8712))
      goto LABEL_185;
    goto LABEL_184;
  }
  if (*(_BYTE *)(a2 + 8712))
  {
    if (!a4)
    {
      v80 = 0;
      goto LABEL_185;
    }
    goto LABEL_184;
  }
  if (a4 && !*(_BYTE *)(a2 + 8002))
  {
    if (!FigMediaSegmentSpecifierGetType((uint64_t)a4))
    {
      v80 = 1;
      goto LABEL_185;
    }
    if (*(_BYTE *)(a2 + 8712))
      goto LABEL_184;
  }
  v83 = *(unsigned __int8 *)(a2 + 8002);
  v80 = v83 == 1;
  if (a4)
  {
    if (v83 != 1)
LABEL_184:
      v80 = FigMediaSegmentSpecifierGetType((uint64_t)a4) == 0;
  }
LABEL_185:
  *((_BYTE *)v17 + 74) = 1;
  if ((v144 & 1) == 0)
  {
    v84 = *(const void **)(a3 + 288);
    if (v84)
    {
      CFRelease(v84);
      *(_QWORD *)(a3 + 288) = 0;
    }
    if (a4 && FigMediaSegmentSpecifierGetType((uint64_t)a4) == 1)
    {
      *(_QWORD *)(a3 + 288) = a4;
      v85 = a4;
    }
    else
    {
      v85 = (const void *)FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)a4);
      *(_QWORD *)(a3 + 288) = v85;
      if (!v85)
      {
LABEL_193:
        *(_QWORD *)(a3 + 320) = *(_QWORD *)(a3 + 304);
        goto LABEL_194;
      }
    }
    CFRetain(v85);
    goto LABEL_193;
  }
LABEL_194:
  if (*(_BYTE *)(a3 + 857))
  {
    v147 = 0;
    *(_BYTE *)(a3 + 857) = 0;
    v27 |= 8u;
    if (*(_QWORD *)(a2 + 8416) == *(_QWORD *)a3)
    {
      v147 = *(_DWORD *)(a2 + 8680);
      *(_DWORD *)(a2 + 8680) = 0;
    }
  }
  else
  {
    v147 = 0;
  }
  DateStamp = FigMediaSegmentSpecifierGetDateStamp((uint64_t)a4);
  if (v80)
  {
    CFAbsoluteTimeGetCurrent();
    if (DateStamp)
      MEMORY[0x194029D14](DateStamp, v86);
    else
      FigMediaSegmentSpecifierGetImputedDate((uint64_t)a4);
    CMTimeMakeWithSeconds(&v162, *((Float64 *)v17 + 4), 90000);
    v157 = 0;
    v158 = 0;
    *(_QWORD *)type = 0;
    segPumpGetCryptorInfoFromBBuf(blockBufferOut, CFSTR("FBPAKey_Decryptor"), &v158, &type[4]);
    segPumpGetCryptorInfoFromBBuf(blockBufferOut, CFSTR("FBPAKey_AudioDecryptor"), &v157, type);
    if (*(_QWORD *)(a2 + 296))
    {
      v87 = 1;
      if (*(_BYTE *)(a2 + 7996))
      {
        if (*(_BYTE *)(a2 + 7997))
          v87 = 1;
        else
          v87 = 2;
      }
    }
    else
    {
      v87 = 1;
    }
    if (v87 <= dword_1EE2A31E8)
    {
      v152 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
  }
LABEL_234:
  if (*(_BYTE *)(a3 + 404))
    v17[6] += a7;
  if (!a4 || FigMediaSegmentSpecifierGetType((uint64_t)a4) != 1)
    goto LABEL_266;
  if (blockBufferOut)
  {
    v97 = CMBlockBufferGetDataLength(blockBufferOut);
    if (FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a4) >= 1)
    {
      v98 = *(OpaqueCMBlockBuffer **)(a3 + 832);
      v99 = v98 ? CMBlockBufferGetDataLength(v98) : 0;
      v74 = a8;
      if (v99 + v97 > FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a4))
        v97 = FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a4) - v99;
    }
    if (!v97)
    {
LABEL_251:
      v27 |= 0x8000u;
      goto LABEL_252;
    }
    valuePtr[0] = 0;
    segPumpGetMediaDataMemoryPool(a2);
    ContiguousBlockBuffer = FigMemoryPoolCreateContiguousBlockBuffer();
    if (!(_DWORD)ContiguousBlockBuffer)
    {
      v100 = *(OpaqueCMBlockBuffer **)(a3 + 832);
      if (v100)
      {
        appended = CMBlockBufferAppendBufferReference(v100, valuePtr[0], 0, 0, 0);
        CFRelease(valuePtr[0]);
        if ((_DWORD)appended)
          goto LABEL_268;
      }
      else
      {
        *(CMBlockBufferRef *)(a3 + 832) = valuePtr[0];
      }
      goto LABEL_251;
    }
LABEL_316:
    appended = ContiguousBlockBuffer;
    goto LABEL_268;
  }
LABEL_252:
  if ((v74 & 1) != 0 && (a9 & 0x400) == 0)
  {
    v101 = *(void **)(a3 + 832);
    valuePtr[0] = 0;
    cf.value = 0;
    v102 = segPumpCreateCacheNameFromSegment(a3, (uint64_t)a4, &cf, valuePtr);
    if ((_DWORD)v102)
    {
      appended = v102;
    }
    else
    {
      v103 = *(_QWORD *)(a2 + 296);
      if (v103)
      {
        v155 = *(_QWORD *)(a3 + 64);
        v104 = valuePtr[0];
        v105 = v27;
        v106 = v101;
        v107 = a7;
        StartOffset = FigMediaSegmentSpecifierGetStartOffset((uint64_t)a4);
        MediaSequence = FigMediaSegmentSpecifierGetMediaSequence((uint64_t)a4);
        v110 = StartOffset;
        a7 = v107;
        v101 = v106;
        v27 = v105;
        if (!FigStreamingCacheAddMediaMap(v103, v155, v104, v110, MediaSequence, v101))
          goto LABEL_258;
      }
      v111 = (const void *)cf.value;
      v112 = FigMediaSegmentSpecifierGetStartOffset((uint64_t)a4);
      v113 = FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a4);
      appended = segPumpSaveEntry(a2, v111, v112, v113, (CMBlockBufferRef)v101, 0, 0, 0, 0);
      if (!(_DWORD)appended)
      {
LABEL_258:
        appended = 0;
        *((_BYTE *)segPumpGetMediaFilePrivateData(a4) + 98) = 1;
      }
    }
    if (cf.value)
      CFRelease((CFTypeRef)cf.value);
    if (valuePtr[0])
      CFRelease(valuePtr[0]);
    v114 = *(const void **)(a3 + 832);
    if (v114)
    {
      CFRelease(v114);
      *(_QWORD *)(a3 + 832) = 0;
    }
    if ((_DWORD)appended)
      goto LABEL_268;
  }
LABEL_266:
  if (!*(_BYTE *)(a3 + 871))
  {
    v116 = *(_QWORD *)(a3 + 880);
    *(_OWORD *)&v160.value = v142;
    v160.epoch = v139;
    v117 = *(const void **)(a2 + 176);
    ++*(_QWORD *)(a2 + 184);
    v118 = *(_QWORD *)(a3 + 304);
    *(CMTime *)valuePtr = v162;
    appended = segPumpMakeDataCallbackWithOSStatus(v145, (uint64_t *)a3, v117, (uint64_t)blockBufferOut, v27, v118, (uint64_t)valuePtr, DateStamp, v147, 0, (uint64_t)&v160, &v159);
    --*(_QWORD *)(a2 + 184);
    if (!FigRetainProxyIsInvalidated())
    {
      if ((_DWORD)appended)
        goto LABEL_268;
      if (v116 != *(_QWORD *)(a3 + 880))
      {
LABEL_325:
        appended = 0;
        goto LABEL_326;
      }
      v119 = v159;
      if (*(_BYTE *)(a3 + 404) && (v159 & 1) == 0)
        v17[7] += a7;
      if ((v119 & 2) == 0 || (v27 & 0x40) == 0)
      {
LABEL_287:
        if (!a4 || FigMediaSegmentSpecifierGetType((uint64_t)a4) != 1)
        {
          v122 = *(const void **)(a3 + 232);
          if (v122)
          {
            CFRelease(v122);
            *(_QWORD *)(a3 + 232) = 0;
          }
          v123 = *(const void **)(a3 + 240);
          if (v123)
          {
            CFRelease(v123);
            *(_QWORD *)(a3 + 240) = 0;
          }
        }
        if (*(_QWORD *)(a2 + 296))
        {
          if (*(_QWORD *)a3 == *(_QWORD *)(a2 + 8416) && (v160.flags & 1) != 0)
          {
            *(CMTime *)valuePtr = v160;
            cf = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
            if ((CMTimeCompare((CMTime *)valuePtr, &cf) & 0x80000000) == 0)
            {
              v124 = *(_QWORD *)(a2 + 296);
              *(CMTime *)valuePtr = v160;
              Seconds = CMTimeGetSeconds((CMTime *)valuePtr);
              FigStreamingCacheHintPlaybackTime(v124, Seconds);
            }
          }
        }
        goto LABEL_267;
      }
      v159 = 0;
      v27 = v27 & 0x1000 | 0x10000;
      v120 = *(const void **)(a2 + 176);
      v121 = *(_QWORD *)(a3 + 304);
      *(CMTime *)valuePtr = v162;
      appended = segPumpMakeDataCallbackWithOSStatus(v145, (uint64_t *)a3, v120, 0, v27, v121, (uint64_t)valuePtr, DateStamp, 0, 0, (uint64_t)&v160, &v159);
      if (!FigRetainProxyIsInvalidated())
      {
        if ((_DWORD)appended)
          goto LABEL_268;
        if (v116 == *(_QWORD *)(a3 + 880))
          goto LABEL_287;
        goto LABEL_325;
      }
    }
LABEL_326:
    v20 = v149;
    goto LABEL_271;
  }
LABEL_267:
  appended = 0;
LABEL_268:
  v20 = v149;
LABEL_269:
  if ((v27 & 2) != 0)
  {
    *(_BYTE *)(a3 + 871) = 1;
    *(_BYTE *)(a3 + 1136) = 1;
  }
LABEL_271:
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  if (v20)
    CFRelease(v20);
  FigRetainProxyRelease();
  return appended;
}

uint64_t segPumpSeeIfMediaFileIsInCache(uint64_t a1, uint64_t a2, const void *a3, _QWORD *a4, _BYTE *a5)
{
  char *MediaFilePrivateData;
  char *v11;
  uint64_t v12;
  _QWORD *v13;
  CFTypeRef v14;
  uint64_t StartOffset;
  int MediaSegmentAtOffset;
  uint64_t v17;
  uint64_t v18;
  uint64_t MediaSequence;
  uint64_t result;
  char v21;
  uint64_t v22;
  CFTypeRef cf;

  MediaFilePrivateData = (char *)segPumpGetMediaFilePrivateData(a3);
  v22 = 0;
  cf = 0;
  v21 = 0;
  if (!*(_QWORD *)(a1 + 296))
    return 0;
  if (!*(_QWORD *)(a2 + 64))
    return 0;
  v11 = MediaFilePrivateData;
  if (segPumpCreateCacheNameFromSegment(a2, (uint64_t)a3, 0, &cf))
    return 0;
  v12 = *(_QWORD *)(a1 + 296);
  v13 = *(_QWORD **)(a2 + 64);
  v14 = cf;
  StartOffset = FigMediaSegmentSpecifierGetStartOffset((uint64_t)a3);
  MediaSegmentAtOffset = FigStreamingCacheMediaStreamGetMediaSegmentAtOffset(v12, v13, (uint64_t)v14, StartOffset, &v21, &v22);
  if (MediaSegmentAtOffset == -16243)
  {
    v17 = *(_QWORD *)(a1 + 296);
    v18 = *(_QWORD *)(a2 + 64);
    MediaSequence = FigMediaSegmentSpecifierGetMediaSequence((uint64_t)a3);
    MediaSegmentAtOffset = FigStreamingCacheMediaStreamGetMediaSegmentWithMediaSequenceNumber(v17, v18, MediaSequence, &v21, &v22);
  }
  CFRelease(cf);
  if (MediaSegmentAtOffset)
  {
    if (*((_QWORD *)v11 + 13))
    {
      result = 0;
      *((_QWORD *)v11 + 6) = 0;
      *((_QWORD *)v11 + 7) = 0;
      *(_DWORD *)(v11 + 71) = 0;
      *((_QWORD *)v11 + 8) = 0;
      *((_QWORD *)v11 + 14) = 0;
      *((_QWORD *)v11 + 15) = 0;
      *((_QWORD *)v11 + 13) = 0;
      if (!a5)
        return result;
    }
    else
    {
      result = 0;
      if (!a5)
        return result;
    }
    goto LABEL_15;
  }
  if (a4)
    *a4 = v22;
  result = 1;
  if (a5)
LABEL_15:
    *a5 = v21;
  return result;
}

uint64_t segPumpCreateCacheNameFromSegment(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  const __CFAllocator *AllocatorForMedia;
  const __CFString *URLString;
  CFURLRef v10;
  uint64_t v11;
  CFTypeRef v12;
  CFTypeRef v13;
  CFTypeRef v15;
  CFTypeRef cf;

  v15 = 0;
  cf = 0;
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  URLString = (const __CFString *)FigMediaSegmentSpecifierGetURLString(a2);
  v10 = CFURLCreateWithString(AllocatorForMedia, URLString, *(CFURLRef *)(a1 + 24));
  if (v10 || (v11 = FigSignalErrorAt(), !(_DWORD)v11))
  {
    v11 = segPumpCreateURLAndString(v10, &cf, &v15);
    if (!(_DWORD)v11)
    {
      if (a3)
      {
        v12 = cf;
        if (cf)
          v12 = CFRetain(cf);
        *a3 = v12;
      }
      if (a4)
      {
        v13 = v15;
        if (v15)
          v13 = CFRetain(v15);
        *a4 = v13;
      }
    }
    if (v10)
      CFRelease(v10);
  }
  if (cf)
    CFRelease(cf);
  if (v15)
    CFRelease(v15);
  return v11;
}

BOOL segPumpIsCacheDiskBacked(uint64_t a1)
{
  uint64_t v1;
  uint64_t AllocatorForMedia;
  CFTypeRef v3;
  CFTypeRef v4;
  CFTypeRef cf;

  cf = (CFTypeRef)*MEMORY[0x1E0C9AE40];
  v1 = *(_QWORD *)(a1 + 296);
  AllocatorForMedia = FigGetAllocatorForMedia();
  FigStreamingCacheCopyProperty(v1, CFSTR("FSC_IsDiskBacked"), AllocatorForMedia, &cf);
  v3 = (CFTypeRef)*MEMORY[0x1E0C9AE50];
  v4 = cf;
  if (cf)
    CFRelease(cf);
  return v3 == v4;
}

uint64_t segPumpSetMediaFilePumpTimeOffsetsArray(uint64_t a1, uint64_t a2, const void *a3)
{
  const void *MediaFilePrivateData;
  const __CFArray *v6;

  MediaFilePrivateData = segPumpGetMediaFilePrivateData(a3);
  v6 = (const __CFArray *)*((_QWORD *)MediaFilePrivateData + 16);
  if (v6 && CFArrayGetCount(v6) >= 2)
    return FigStreamingCacheMediaSegmentSetDuplicateSegments(*(_QWORD *)(a1 + 296), *(_QWORD *)(a2 + 64), *((_QWORD *)MediaFilePrivateData + 13), *((const void **)MediaFilePrivateData + 16));
  else
    return 0;
}

uint64_t segPumpStreamMoveToNextFreeMediaConnection(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t result;

  v2 = *(_QWORD **)(a1 + 696);
  if (!v2)
    v2 = *(_QWORD **)(a1 + 680);
  v3 = v2;
  while (1)
  {
    v3 = (_QWORD *)*v3;
    if (!v3)
      v3 = *(_QWORD **)(a1 + 680);
    result = segPumpMediaConnectionIsActive((uint64_t)v3);
    if (!(_DWORD)result)
      break;
    if (v3 == v2)
    {
      v3 = v2;
      break;
    }
  }
  *(_QWORD *)(a1 + 696) = v3;
  return result;
}

_QWORD *segPumpSetMediaConnectionIsDormant(_QWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t (*v5)(uint64_t, __CFString *, uint64_t);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t, uint64_t);

  if (a2)
  {
    v4 = *(_QWORD *)(a2 + 32);
    if (v4)
    {
      result = (_QWORD *)CMBaseObjectGetVTable();
      v5 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t))(result[1] + 56);
      if (v5)
      {
        if ((_DWORD)a3)
          v6 = *MEMORY[0x1E0C9AE50];
        else
          v6 = *MEMORY[0x1E0C9AE40];
        return (_QWORD *)v5(v4, CFSTR("FHRP_IsDormant"), v6);
      }
    }
    else
    {
      v7 = *(_QWORD *)(a2 + 104);
      if (v7)
      {
        v8 = result[10];
        result = (_QWORD *)CMBaseObjectGetVTable();
        v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(result[2] + 40);
        if (v9)
          return (_QWORD *)v9(v8, v7, a3);
      }
    }
  }
  return result;
}

uint64_t segPumpStreamSchedulePreloadHintRead(uint64_t a1, _QWORD *a2)
{
  uint64_t DerivedStorage;
  uint64_t result;
  const void *PreloadHint;
  const __CFURL *v7;
  const __CFURL *v8;
  _QWORD *MediaFilePrivateData;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  result = segPumpStreamHasPreloadHint((uint64_t)a2);
  if ((_DWORD)result)
  {
    result = segPumpShouldDoSegmentReadAheads((_BYTE *)DerivedStorage);
    if ((_DWORD)result)
    {
      result = segPumpStreamGetFuturePreloadCount(DerivedStorage, a2);
      if ((_DWORD)result)
      {
        if (segPumpMediaConnectionIsActive(a2[99]))
          return 0;
        PreloadHint = (const void *)FigMediaPlaylistGetPreloadHint(a2[7]);
        v7 = (const __CFURL *)a2[2];
        v8 = (const __CFURL *)a2[3];
        MediaFilePrivateData = segPumpGetMediaFilePrivateData(PreloadHint);
        segPumpEnsureMediaSegmentURLs(PreloadHint, v7, v8);
        if (!MediaFilePrivateData[2])
          return FigSignalErrorAt();
        v10 = (_QWORD *)a2[85];
        if (v10)
        {
          while (!segPumpMediaConnectionIncludesMedia((uint64_t)a2, (uint64_t)v10, PreloadHint))
          {
            v10 = (_QWORD *)*v10;
            if (!v10)
              goto LABEL_9;
          }
          return 0;
        }
LABEL_9:
        v11 = a2[87];
        if (v11)
          v12 = *(_QWORD *)(v11 + 32);
        else
          v12 = 0;
        if ((uint64_t)a2[97] >= 1)
        {
          v13 = 0;
          do
          {
            if (*(_BYTE *)(DerivedStorage + 329))
              v14 = 1;
            else
              v14 = *(int *)(DerivedStorage + 8212);
            if (v13 >= v14)
              break;
            v15 = *(_QWORD *)(a2[96] + 8 * v13);
            if (!v15)
              break;
            if (!segPumpMediaConnectionIsActive(v15))
              v12 = *(_QWORD *)(*(_QWORD *)(a2[96] + 8 * v13) + 32);
            ++v13;
          }
          while (v13 < a2[97]);
        }
        *((_QWORD *)segPumpGetMediaFilePrivateData(PreloadHint) + 6) = 0;
        *((_QWORD *)segPumpGetMediaFilePrivateData(PreloadHint) + 7) = 0;
        result = segPumpReadMediaFile(a1, a2, PreloadHint, 1, 0, v12, a2 + 99);
        if (!(_DWORD)result)
        {
          segPumpSetMediaConnectionIsDormant((_QWORD *)DerivedStorage, a2[99], 1);
          return 0;
        }
      }
    }
  }
  return result;
}

BOOL segPumpShouldDoSegmentReadAheads(_BYTE *a1)
{
  uint64_t v3;
  _BYTE *v4;
  double TimeDeliveredFromBeginningForVOD;
  uint64_t v6;

  if (a1[329])
    return 1;
  if (!a1[8209] || !a1[7998] && segPumpIsCacheDiskBacked((uint64_t)a1))
    return 0;
  if (a1[330])
    return 1;
  v3 = 0;
  v4 = a1 + 384;
  TimeDeliveredFromBeginningForVOD = 1.79769313e308;
  do
  {
    v6 = *(_QWORD *)&v4[v3];
    if (*(_QWORD *)(v6 + 16)
      && !*(_BYTE *)(v6 + 1136)
      && TimeDeliveredFromBeginningForVOD >= segPumpStreamGetTimeDeliveredFromBeginningForVOD(*(_QWORD *)&v4[v3]))
    {
      TimeDeliveredFromBeginningForVOD = segPumpStreamGetTimeDeliveredFromBeginningForVOD(v6);
    }
    v3 += 16;
  }
  while (v3 != 48);
  return TimeDeliveredFromBeginningForVOD > 120.0;
}

uint64_t segPumpStreamGetFuturePreloadCount(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  const void *LastValue;
  const __CFArray *PartialSegments;
  int IsFragment;
  uint64_t v7;

  if (segPumpStreamShouldYieldToTrialSwitch(a1, a2))
    return 0;
  result = a2[7];
  if (result)
  {
    FigMediaPlaylistGetMediaSegmentSpecifiers(result);
    result = FigCFArrayGetLastValue();
    if (result)
    {
      LastValue = (const void *)result;
      PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments(result);
      if (PartialSegments && CFArrayGetCount(PartialSegments) >= 1)
        LastValue = (const void *)FigCFArrayGetLastValue();
      IsFragment = FigMediaSegmentSpecifierIsFragment((uint64_t)LastValue);
      v7 = 33;
      if (!IsFragment)
        v7 = 32;
      return LastValue == (const void *)a2[v7] || *((_BYTE *)segPumpGetMediaFilePrivateData(LastValue) + 73);
    }
  }
  return result;
}

uint64_t segPumpReadMediaFile(uint64_t a1, uint64_t a2, const void *a3, int a4, int a5, const void *a6, uint64_t *a7)
{
  uint64_t DerivedStorage;
  _QWORD *MediaFilePrivateData;
  uint64_t v13;
  uint64_t UpTimeNanoseconds;
  const __CFURL *v15;
  const __CFURL *v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t MediaConnection;
  dispatch_object_t *v24;
  _QWORD *v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  double v29;
  const __CFURL *v30;
  const __CFURL *v31;
  _QWORD *v32;
  const void *v33;
  CFTypeRef v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  const __CFURL *v38;
  const __CFURL *v39;
  CFTypeRef *v40;
  uint64_t v41;
  double TimeInSeconds;
  const void *MapSegmentSpecifier;
  double *v44;
  double v45;
  double v46;
  uint64_t v47;
  uint64_t v48;
  double v49;
  double v50;
  double v51;
  double v53;
  uint64_t v54;
  uint64_t i;
  uint64_t v56;
  uint64_t *v60;
  CFTypeRef cf;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  MediaFilePrivateData = segPumpGetMediaFilePrivateData(a3);
  v13 = *(_QWORD *)(a2 + 752);
  cf = 0;
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  if (a7)
    *a7 = 0;
  v60 = a7;
  v15 = *(const __CFURL **)(a2 + 16);
  v16 = *(const __CFURL **)(a2 + 24);
  v17 = segPumpGetMediaFilePrivateData(a3);
  segPumpEnsureMediaSegmentURLs(a3, v15, v16);
  if (!v17[2])
  {
LABEL_111:
    MediaConnection = FigSignalErrorAt();
    goto LABEL_67;
  }
  *(_QWORD *)(a2 + 104) = MediaFilePrivateData[4];
  *((_BYTE *)MediaFilePrivateData + 72) = 0;
  *((_BYTE *)MediaFilePrivateData + 74) = 0;
  if (!*(_BYTE *)(DerivedStorage + 8208) || (v18 = *(_QWORD **)(a2 + 680)) == 0)
  {
LABEL_8:
    if (a4 || segPumpShouldDoSegmentReadAheads((_BYTE *)DerivedStorage))
    {
      v19 = *(_QWORD *)(a2 + 776) + v13;
      v20 = v19 + segPumpStreamHasPreloadHint(a2);
      v13 = v20 + segPumpStreamHasPreloadMapHint(a2);
    }
    else if (!*(_BYTE *)(DerivedStorage + 8712)
           && FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a3) >= 1
           && *(_QWORD *)(a2 + 752) < *(_QWORD *)(a2 + 760)
           && *(_QWORD *)a2 == *(_QWORD *)(DerivedStorage + 8416)
           && *(_BYTE *)(a2 + 406)
           && !FigMediaSegmentSpecifierIsFragment((uint64_t)a3)
           && (!a3 || FigMediaSegmentSpecifierGetType((uint64_t)a3) != 1))
    {
      v47 = *(_QWORD *)(a2 + 760);
      v13 = v47 + 1;
      *(_QWORD *)(a2 + 752) = v47;
    }
    v21 = *(_QWORD *)(a2 + 744);
    if (v13 <= v21)
    {
      if (v21 > v13 && (*(unsigned __int8 *)(DerivedStorage + 8712) | a4) == 0)
      {
        do
        {
          if (*(_QWORD *)(a2 + 680))
            v24 = *(dispatch_object_t **)(a2 + 688);
          else
            v24 = 0;
          if (segPumpMediaConnectionIsActive((uint64_t)v24))
            break;
          segPumpDestroyMediaConnection(DerivedStorage, (_QWORD *)a2, v24);
        }
        while (*(_QWORD *)(a2 + 744) > v13);
        v25 = *(_QWORD **)(a2 + 680);
        v26 = v25;
        while (1)
        {
          v26 = (_QWORD *)*v26;
          if (!v26)
            v26 = *(_QWORD **)(a2 + 680);
          if (!segPumpMediaConnectionIsActive((uint64_t)v26))
            break;
          if (v26 == v25)
          {
            v26 = v25;
            break;
          }
        }
        *(_QWORD *)(a2 + 696) = v26;
      }
    }
    else
    {
      while (*(_QWORD *)(a2 + 744) < v13)
      {
        MediaConnection = segPumpCreateMediaConnection(a2);
        if ((_DWORD)MediaConnection)
          goto LABEL_67;
      }
    }
    if (a4)
    {
      v27 = *(_QWORD *)(a2 + 696);
      if (!v27)
        v27 = *(_QWORD *)(a2 + 680);
      v28 = v27;
      while (1)
      {
        v28 = *(_QWORD *)v28;
        if (!v28)
          v28 = *(_QWORD *)(a2 + 680);
        if (!segPumpMediaConnectionIsActive(v28))
          break;
        if (v28 == v27)
        {
          v28 = v27;
          break;
        }
      }
      if (!v28 || v28 == *(_QWORD *)(a2 + 696))
        goto LABEL_111;
    }
    else
    {
      if (!*(_DWORD *)(a2 + 1080))
      {
        v48 = FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a3);
        if (a3)
        {
          if (v48 >= 1 && !FigMediaSegmentSpecifierGetType((uint64_t)a3))
          {
            v49 = (double)(8 * FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a3));
            *(_DWORD *)(a2 + 1080) = (v49 / FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)a3));
          }
        }
      }
      v28 = *(_QWORD *)(a2 + 696);
    }
    *(_QWORD *)(a2 + 952) = UpTimeNanoseconds;
    *(_BYTE *)(v28 + 144) = 0;
    *(_QWORD *)(v28 + 56) = 0;
    *(_QWORD *)(v28 + 64) = 0;
    *(_QWORD *)(v28 + 48) = UpTimeNanoseconds;
    if (*(_DWORD *)(v28 + 80))
    {
      v29 = (double)(UpTimeNanoseconds - *(_QWORD *)(v28 + 40)) / 1000000000.0;
    }
    else
    {
      *(_QWORD *)(v28 + 40) = UpTimeNanoseconds;
      *(_QWORD *)(v28 + 72) = 0;
      v29 = 0.0;
    }
    v30 = *(const __CFURL **)(a2 + 16);
    v31 = *(const __CFURL **)(a2 + 24);
    v32 = segPumpGetMediaFilePrivateData(a3);
    segPumpEnsureMediaSegmentURLs(a3, v30, v31);
    v33 = (const void *)v32[2];
    if (v33)
      v34 = CFRetain(v33);
    else
      v34 = 0;
    cf = v34;
    if (*(_BYTE *)(DerivedStorage + 320))
    {
      MediaConnection = FigCFHTTPCopyURLAndInheritQueyComponentIfNotPresent(*(const __CFURL **)(a2 + 8), (CFURLRef *)&cf);
      if ((_DWORD)MediaConnection)
        goto LABEL_67;
      v34 = cf;
    }
    MediaConnection = segPumpReadMediaFileURL(a1, a2, a3, v34, v28, a6, a5);
    if (!(_DWORD)MediaConnection)
    {
      if (a3 && !FigMediaSegmentSpecifierGetType((uint64_t)a3))
        *(_BYTE *)(a2 + 402) = 0;
      if (*(_QWORD *)(DerivedStorage + 8096) && !*(_BYTE *)(DerivedStorage + 8712))
      {
        TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)a3);
        MapSegmentSpecifier = (const void *)FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)a3);
        *(_QWORD *)(a2 + 808) = 0;
        if (MapSegmentSpecifier)
        {
          v44 = (double *)segPumpGetMediaFilePrivateData(MapSegmentSpecifier);
          v45 = v44[10];
          if (v45 > 0.0 && TimeInSeconds > v45)
          {
            TimeInSeconds = TimeInSeconds - v45;
            *(double *)(a2 + 808) = v45;
          }
          v44[10] = 0.0;
        }
        if (TimeInSeconds >= 0.25 || FigMediaSegmentSpecifierIsFragment((uint64_t)a3))
        {
          if (FigMediaSegmentSpecifierIsFragment((uint64_t)a3))
            v46 = *(double *)(DerivedStorage + 16) * 0.5;
          else
            v46 = *(double *)(DerivedStorage + 7984);
          if (TimeInSeconds / *(double *)(DerivedStorage + 8704) > v46)
            v46 = TimeInSeconds / *(double *)(DerivedStorage + 8704);
        }
        else
        {
          v46 = 0.25 / *(double *)(DerivedStorage + 8704);
        }
        v50 = fmin(v46, 30.0);
        v51 = 0.0;
        if (v29 < v50 && v29 > 0.0)
          v51 = v29;
        v53 = v50 - v51;
        if (v28 == *(_QWORD *)(a2 + 696))
        {
          v54 = *(_QWORD *)(a2 + 752);
          if (v54 >= 1)
          {
            for (i = 0; i < v54; ++i)
            {
              v56 = *(_QWORD *)(a2 + 696 + 8 * i);
              if (v56)
              {
                FigHTTPCreateTimer(*(const void **)DerivedStorage, (uint64_t)MediaHandleDownloadTimer, *(NSObject **)(DerivedStorage + 64), (dispatch_object_t *)(v56 + 112), v53);
                v54 = *(_QWORD *)(a2 + 752);
              }
            }
          }
        }
        else
        {
          FigHTTPCreateTimer(*(const void **)DerivedStorage, (uint64_t)MediaHandleDownloadTimer, *(NSObject **)(DerivedStorage + 64), (dispatch_object_t *)(v28 + 112), v50 - v51);
        }
        segPumpRTCReportingUpdateMediaTimerStats(DerivedStorage, (_QWORD *)a2, v28, v53);
        if (!v60)
          goto LABEL_106;
      }
      else if (!v60)
      {
        goto LABEL_106;
      }
      v35 = 0;
      *v60 = v28;
      goto LABEL_107;
    }
LABEL_67:
    v35 = MediaConnection;
    goto LABEL_107;
  }
  while (!segPumpMediaConnectionIncludesMedia(a2, (uint64_t)v18, a3))
  {
    v18 = (_QWORD *)*v18;
    if (!v18)
      goto LABEL_8;
  }
  v36 = CMBaseObjectGetDerivedStorage();
  v37 = segPumpAccumConnCompletesMediaRange((uint64_t)v18, a3);
  v38 = *(const __CFURL **)(a2 + 16);
  v39 = *(const __CFURL **)(a2 + 24);
  v40 = (CFTypeRef *)segPumpGetMediaFilePrivateData(a3);
  segPumpEnsureMediaSegmentURLs(a3, v38, v39);
  segPumpSetMediaFileForMediaConnection(v18, a2, a3, v40[2]);
  if (!v37)
    goto LABEL_106;
  v41 = *(_QWORD *)(a2 + 880);
  MediaConnection = segPumpDeliverAccumulatedBuffer(a1, v36, a2, (uint64_t)v18, a3, 1);
  if ((_DWORD)MediaConnection)
    goto LABEL_67;
  if (v41 == *(_QWORD *)(a2 + 880))
  {
    MediaConnection = segPumpStreamProceedAfterMediaAndKeyArrival(a1, v36, a2, a3, 1, 1);
    goto LABEL_67;
  }
LABEL_106:
  v35 = 0;
LABEL_107:
  if (cf)
    CFRelease(cf);
  return v35;
}

double segPumpStreamGetTimeDeliveredFromBeginningForVOD(uint64_t a1)
{
  uint64_t v2;
  double v3;
  CFIndex i;
  const __CFArray *MediaSegmentSpecifiers;
  const __CFArray *v6;
  const void *ValueAtIndex;
  const void *MediaFilePrivateData;

  v2 = *(_QWORD *)(a1 + 56);
  v3 = 0.0;
  if (v2
    && FigMediaPlaylistHasEndTag(v2)
    && FigMediaPlaylistGetPlaylistType(*(_QWORD *)(a1 + 56)) == 2)
  {
    for (i = 0; ; ++i)
    {
      MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a1 + 56));
      if (MediaSegmentSpecifiers)
        MediaSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MediaSegmentSpecifiers);
      if (i >= (uint64_t)MediaSegmentSpecifiers)
        break;
      v6 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a1 + 56));
      ValueAtIndex = CFArrayGetValueAtIndex(v6, i);
      MediaFilePrivateData = segPumpGetMediaFilePrivateData(ValueAtIndex);
      if (!*((_BYTE *)MediaFilePrivateData + 73))
        break;
      v3 = *((double *)MediaFilePrivateData + 4);
    }
  }
  return v3;
}

BOOL segPumpStreamShouldYieldToTrialSwitch(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  int PeakBitRate;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *(_QWORD *)(a1 + 7680);
  if (v2
    && *(_QWORD **)(a1 + 16 * *a2 + 384) == a2
    && *(_QWORD *)(a1 + 8144)
    && (PeakBitRate = FigAlternateGetPeakBitRate(*(_QWORD *)(v2 + 8)),
        PeakBitRate < (int)FigAlternateGetPeakBitRate(*(_QWORD *)(*(_QWORD *)(a1 + 8144) + 8)))
    && ((v9 = 0, v10 = 0, *a2 > 2uLL) ? (v7 = 0) : (v7 = dword_1932FD19C[*a2]),
        !FigAlternateGetRenditionInfoForMediaType(*(_QWORD *)(*(_QWORD *)(a1 + 7680) + 8), v7, *(const void **)(a1 + 8392), *(const void **)(a1 + 8400), *(const void **)(a1 + 8408), 1, 0, &v9, 0)&& (*a2 > 2uLL ? (v8 = 0) : (v8 = dword_1932FD19C[*a2]), !FigAlternateGetRenditionInfoForMediaType(*(_QWORD *)(*(_QWORD *)(a1 + 8144) + 8), v8, *(const void **)(a1 + 8392), *(const void **)(a1 + 8400), *(const void **)(a1 + 8408), 1, 0, &v10,
                          0))))
  {
    return FigCFEqual() == 0;
  }
  else
  {
    return 0;
  }
}

uint64_t segPumpCreateMediaConnection(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t result;
  uint64_t v5;

  v2 = malloc_type_calloc(1uLL, 0x138uLL, 0x1060040D8227916uLL);
  if (!v2)
    return 4294954510;
  v3 = v2;
  result = 0;
  v5 = *(_QWORD *)(a1 + 744);
  v3[23] = v5;
  *(_QWORD *)(a1 + 744) = v5 + 1;
  *v3 = 0;
  **(_QWORD **)(a1 + 688) = v3;
  *(_QWORD *)(a1 + 688) = v3;
  return result;
}

uint64_t segPumpReadMediaFileURL(uint64_t a1, uint64_t a2, const void *a3, const void *a4, uint64_t a5, const void *a6, int a7)
{
  uint64_t DerivedStorage;
  unint64_t *MediaFilePrivateData;
  unint64_t *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  int Length;
  unint64_t v20;
  unsigned int v21;
  uint64_t ContentKeySpecifier;
  unint64_t v23;
  int v24;
  unsigned int v25;
  unint64_t v26;
  uint64_t result;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v39 = 0;
  v40 = 0;
  MediaFilePrivateData = (unint64_t *)segPumpGetMediaFilePrivateData(a3);
  v38 = 0;
  if (!a5)
    return FigSignalErrorAt();
  v15 = MediaFilePrivateData;
  v17 = MediaFilePrivateData + 13;
  v16 = (_QWORD *)MediaFilePrivateData[13];
  if (!v16)
  {
    v20 = MediaFilePrivateData[7];
    v21 = 1;
    if (!v20)
      goto LABEL_20;
    goto LABEL_10;
  }
  v18 = MediaFilePrivateData + 6;
  Length = FigStreamingCacheMediaSegmentGetLength(*(_QWORD *)(DerivedStorage + 296), *(_QWORD *)(a2 + 64), v16, 0, MediaFilePrivateData + 6);
  v20 = v15[6];
  v15[15] = v20;
  v15[7] = v20;
  if (Length == -16243)
  {
    LODWORD(v20) = 0;
    *v18 = 0;
    v15[7] = 0;
    *(_DWORD *)((char *)v15 + 71) = 0;
    v15[8] = 0;
    v17[1] = 0;
    v17[2] = 0;
    v21 = 1;
    *v17 = 0;
    goto LABEL_20;
  }
  if (Length)
    v21 = 1;
  else
    v21 = v20 == 0;
  if (v20)
  {
LABEL_10:
    ContentKeySpecifier = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a3);
    v23 = v15[8];
    if (v23 <= v15[7])
      v23 = v15[7];
    v15[8] = v23;
    if (v21
      && ContentKeySpecifier
      && FigContentKeySpecifierGetEncryptionMethod(ContentKeySpecifier) - 5 >= 0xFFFFFFFE)
    {
      LODWORD(v20) = 0;
      v15[6] = 0;
      v15[7] = 0;
      v21 = 1;
    }
    else if (FigMediaSegmentSpecifierGetStartOffset((uint64_t)a3))
    {
      LODWORD(v20) = 0;
    }
    else
    {
      LODWORD(v20) = 8 * (FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a3) == 0);
    }
  }
LABEL_20:
  if (*(_QWORD *)a2 == 2 || *(_BYTE *)(DerivedStorage + 329))
    LODWORD(v20) = v20 | 4;
  *(_BYTE *)(a5 + 281) = a7;
  if (a7)
    v24 = 1025;
  else
    v24 = 1;
  v25 = v20 | v24;
  segPumpGetRequestedByteRangeForMediaFileHelper(DerivedStorage, (_QWORD *)a2, a3, a3, v21, &v40, &v39, &v38);
  v26 = v38;
  if (v38)
  {
    v15[6] = 0;
    v15[7] = 0;
    v15[8] = v26;
  }
  *(_BYTE *)(a2 + 873) = 0;
  if (*(_BYTE *)(DerivedStorage + 8712)
    || *(_BYTE *)(DerivedStorage + 48)
    || !a3
    || !*(_BYTE *)(a2 + 406)
    || FigMediaSegmentSpecifierGetType((uint64_t)a3)
    || (v28 = *(_QWORD *)(a2 + 752), v28 < 2)
    || (v29 = v39, v39 < 0x10000))
  {
    *(_BYTE *)(a2 + 816) = 0;
    result = segPumpCreateMediaURLRequest(a1, a2, a3, a4, a5, v40, v39, v25, a6);
    if (!(_DWORD)result)
    {
LABEL_31:
      result = 0;
      *(_QWORD *)(a5 + 120) = v15[6];
    }
  }
  else if (*(_BYTE *)(DerivedStorage + 327))
  {
    return FigSignalErrorAt();
  }
  else
  {
    v30 = 0;
    v31 = ((v28 + v39 - 1) / (unint64_t)v28 + 15) & 0xFFFFFFFFFFFFFFF0;
    v15[5] = v39;
    *(_BYTE *)(a2 + 816) = 1;
    while (1)
    {
      v32 = a2 + 8 * v30;
      v33 = *(_QWORD *)(v32 + 696);
      if (!v33)
      {
        v34 = *(uint64_t **)(v32 + 688);
        v33 = *v34;
        *(_QWORD *)(v32 + 696) = *v34;
        if (!v33)
        {
          v33 = *(_QWORD *)(a2 + 680);
          *(_QWORD *)(v32 + 696) = v33;
        }
      }
      v35 = *(_QWORD *)(*(_QWORD *)(a2 + 696) + 40);
      *(_QWORD *)(v33 + 40) = v35;
      *(_QWORD *)(v33 + 48) = v35;
      v36 = v31 >= v29 ? v29 : v31;
      result = segPumpCreateMediaURLRequest(a1, a2, a3, a4, v33, v40, v36, v25, 0);
      if ((_DWORD)result)
        break;
      v40 += v36;
      v29 -= v36;
      if (++v30 >= *(_QWORD *)(a2 + 752))
        goto LABEL_31;
    }
  }
  return result;
}

void MediaHandleDownloadTimer(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t **v12;
  const void *v13;
  uint64_t *v14;
  double v15;
  double TimeInSeconds;
  unsigned int v17;
  double v18;
  unsigned int v19;
  uint64_t UpTimeNanoseconds;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  double v24;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  double v27;
  double v28;
  int v29;
  uint64_t v30;
  unint64_t v31;
  double v32;
  uint64_t *v33;
  double v34;
  uint64_t v35;
  void (*v36)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v37;
  void (*v38)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v39;
  uint64_t v40;
  unsigned int (*v41)(uint64_t, uint64_t, uint64_t *);
  uint64_t v42;
  size_t v43;
  size_t v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  CFTypeRef v53;
  uint64_t v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t CryptKeyCommonData;
  uint64_t v59;
  const __CFAllocator *AllocatorForMedia;
  uint64_t v61;
  uint64_t v62;
  const char *v63;
  unsigned int v64;
  uint64_t MediaURLRequest;
  unint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  double v70;
  unint64_t v71;
  CFStringRef v72;
  const void *ContentKeySpecifier;
  _QWORD *MediaFilePrivateData;
  _QWORD *v75;
  uint64_t v76;
  const void *v77;
  uint64_t v78;
  uint64_t v79;
  unsigned int v80;
  uint64_t v81;
  os_log_type_t type;
  _OWORD v83[5];
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t *v87;
  uint64_t *v88;
  CFTypeRef cf;
  uint64_t v90;
  _QWORD v91[20];

  v91[17] = *MEMORY[0x1E0C80C00];
  v88 = 0;
  cf = 0;
  v84 = 0;
  v85 = 0;
  memset(v83, 0, sizeof(v83));
  if (!segPumpLockAndCopyPumpFromRetainProxy(a2, &cf, (uint64_t *)&v88))
  {
    v4 = 0;
    v86 = 0;
    v87 = 0;
    v5 = v88;
    v6 = v88 + 48;
    while (1)
    {
      v7 = v6[v4];
      if (findConnectionFromMediaDownloadTimer((_QWORD *)v7, a1, &v87, &v85, &v86))
        break;
      v4 += 2;
      if (v4 == 6)
      {
        v8 = 0;
        v9 = v5 + 49;
        while (1)
        {
          v7 = v9[v8];
          if (findConnectionFromMediaDownloadTimer((_QWORD *)v7, a1, &v87, &v85, &v86))
            goto LABEL_9;
          v8 += 2;
          if (v8 == 6)
            goto LABEL_114;
        }
      }
    }
LABEL_9:
    if (v7)
    {
      v10 = v87;
      if (v87)
      {
        v11 = *(_QWORD *)(v7 + 776);
        if (v11 >= 1)
        {
          v12 = *(uint64_t ***)(v7 + 768);
          while (*v12 != v87)
          {
            ++v12;
            if (!--v11)
              goto LABEL_15;
          }
          goto LABEL_114;
        }
      }
LABEL_15:
      if (*(uint64_t **)(v7 + 792) == v87)
        goto LABEL_114;
      if (*(uint64_t **)(v7 + 800) == v87)
        goto LABEL_114;
      v13 = (const void *)v87[1];
      if (!v13 || !v87[5])
        goto LABEL_114;
      v14 = v88;
      if (FigMediaSegmentSpecifierIsFragment(v87[1]))
        v15 = *((double *)v14 + 2) * 0.5;
      else
        v15 = *((double *)v14 + 998);
      TimeInSeconds = 30.0;
      if (FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v13) < 30.0)
        TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v13);
      segPumpStreamBitRateRequiredForStream((uint64_t)v88, (_QWORD *)v7);
      v17 = *((_DWORD *)v88 + 2);
      if (v17 >= 0x1E)
        v17 = 30;
      v80 = v17;
      if (FigMediaSegmentSpecifierIsFragment((uint64_t)v13))
      {
        v18 = *((double *)v88 + 2);
      }
      else
      {
        v19 = *((_DWORD *)v88 + 2);
        if (v19 <= 0xA)
          v19 = 10;
        v18 = (double)v19;
      }
      UpTimeNanoseconds = FigGetUpTimeNanoseconds();
      v21 = 8;
      if (!*((_BYTE *)v10 + 281))
        v21 = 5;
      v22 = v10[v21];
      if (v10[37] <= 0)
        v23 = v22;
      else
        v23 = v10[37];
      v24 = *(double *)(v7 + 808) + (double)(FigGetUpTimeNanoseconds() - v23) / 1000000000.0;
      if (v10[31] < 1)
      {
        if (!dword_1EE2A31E8)
          goto LABEL_41;
      }
      else if (!dword_1EE2A31E8)
      {
        goto LABEL_41;
      }
      LODWORD(v81) = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
LABEL_41:
      if (v24 < TimeInSeconds || v24 < v15)
      {
        if (TimeInSeconds <= v15)
          v27 = v15;
        else
          v27 = TimeInSeconds;
        v28 = v27 - v24;
        v30 = (uint64_t)v87;
        goto LABEL_110;
      }
      v29 = *(unsigned __int8 *)(v7 + 873);
      segPumpSetCurrentSegmentTooSlow(v88, v7);
      FigNetworkInterfaceReporterSamplePhysicalStatistics(v88[1140], 0, 0, 0, 0);
      v30 = (uint64_t)v87;
      FigReportingAgentUpdateFinalTransactionMetrics(v88[1131], v87[4], 1, 0);
      if (!v29)
        segPumpAddMediaSegmentNoResponseErrorIfNecessary((uint64_t)cf, (uint64_t)v88, v7, v30);
      v32 = (double)(UpTimeNanoseconds - *(_QWORD *)(v30 + 48)) / 1000000000.0;
      v33 = v88;
      LODWORD(v31) = *((_DWORD *)v88 + 2);
      v34 = fmax((double)v31 * 0.5, 2.0);
      if (v15 > v34)
        v34 = v15;
      if (v34 > 30.0)
        v34 = 30.0;
      if (v32 < v34)
      {
        v28 = v34 - v32;
LABEL_110:
        *(_QWORD *)(v30 + 120) = *(_QWORD *)(v30 + 224);
LABEL_111:
        v59 = FigHTTPCreateTimer((const void *)*v88, (uint64_t)MediaHandleDownloadTimer, v88[8], (dispatch_object_t *)(v30 + 112), v28);
        segPumpRTCReportingUpdateMediaTimerStats((uint64_t)v88, (_QWORD *)v7, v30, v28);
        goto LABEL_112;
      }
      v28 = fmin(v18, 30.0);
      if (*(_BYTE *)(v30 + 280) && *(_QWORD *)(v30 + 224) != *(_QWORD *)(v30 + 120))
      {
        if (v24 >= TimeInSeconds + (double)v80 && !*((_BYTE *)v88 + 8208) && !*(_BYTE *)(v30 + 144))
        {
          if (v30 == *(_QWORD *)(v7 + 696))
          {
            AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
            v61 = *(_QWORD *)(v7 + 696);
            if (v61)
            {
              v62 = *(_QWORD *)(v61 + 8);
              v63 = "Media file";
              if (v62 && FigMediaSegmentSpecifierGetType(v62) == 1)
                v63 = "Map";
            }
            else
            {
              v63 = "Media file";
            }
            v70 = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v13);
            LODWORD(v71) = *((_DWORD *)v88 + 2);
            v72 = CFStringCreateWithFormat(AllocatorForMedia, 0, CFSTR("%s not received in %ds"), v63, (int)(v70 + (double)v71));
            segPumpAppendErrorLogEntry((uint64_t)cf, (uint64_t)v88, v7, (const __CFURL **)(v30 + 16), -16830, CFSTR("CoreMediaErrorDomain"), (uint64_t)v72, 0, 1, 2u, 3u);
            CFRelease(v72);
          }
          *(_BYTE *)(v30 + 144) = 1;
        }
        goto LABEL_110;
      }
      if (*((_BYTE *)v88 + 328))
      {
        if (FigMediaSegmentSpecifierIsFragment((uint64_t)v13))
          goto LABEL_110;
        v33 = v88;
      }
      ++v33[1064];
      v35 = v33[1131];
      if (v35)
      {
        v36 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                              + 16)
                                                                                  + 32);
        if (v36)
          v36(v35, CFSTR("bytePumpStats"), CFSTR("AbortReqCount"), 1);
      }
      if (!*(_BYTE *)(v30 + 280))
      {
        v37 = v88[1131];
        if (v37)
        {
          v38 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                + 16)
                                                                                    + 32);
          if (v38)
            v38(v37, CFSTR("bytePumpStats"), CFSTR("AbortNoResponseCount"), 1);
        }
      }
      if (*(_QWORD *)(v30 + 224) <= *(_QWORD *)(v30 + 216))
        goto LABEL_75;
      v90 = 0;
      v39 = *(_QWORD *)(v30 + 32);
      if (!v39)
        goto LABEL_75;
      v40 = *(_QWORD *)(v30 + 128);
      v41 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
      if (!v41)
        goto LABEL_75;
      if (v41(v39, v40, &v90))
        goto LABEL_75;
      v42 = v90;
      v43 = *(_QWORD *)(v30 + 136);
      v44 = v90 - v43;
      if (v90 == v43)
        goto LABEL_75;
      v66 = *(_QWORD *)(v30 + 216) + v44;
      if (*(_QWORD *)(v30 + 256) - 1 < v66 || (v67 = *(_QWORD *)(v30 + 248), v67 >= 1) && v66 >= v67)
      {
LABEL_103:
        v59 = 0;
        goto LABEL_112;
      }
      v68 = v88;
      v88[1067] += v44;
      *(_QWORD *)(v7 + 1096) += v44;
      *(_QWORD *)(v30 + 136) = v42;
      *(_QWORD *)(v30 + 216) = v66;
      if (*(_QWORD *)v7 == 1)
      {
        v69 = 1080;
      }
      else
      {
        if (*(_QWORD *)v7)
        {
LABEL_119:
          if (v30 != *(_QWORD *)(v7 + 696))
            goto LABEL_120;
          if (FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v13))
          {
            v91[0] = 0;
            v81 = 0;
            ContentKeySpecifier = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v13);
            CryptKeyCommonData = segPumpGetCryptKeyCommonData(ContentKeySpecifier, v91, &v81);
            if ((_DWORD)CryptKeyCommonData)
              goto LABEL_83;
            if (!*(_BYTE *)(v81 + 144))
            {
              v79 = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v13);
              if (FigContentKeySpecifierGetEncryptionMethod(v79) - 3 < 0xFFFFFFFE
                || FigMediaSegmentSpecifierGetType((uint64_t)v13) != 1)
              {
                if (*((_BYTE *)v88 + 322))
                {
LABEL_120:
                  CryptKeyCommonData = segPumpAppendBytesToMediaConnectionBuffer(v30, v43, v44);
                  if ((_DWORD)CryptKeyCommonData)
                    goto LABEL_83;
                  goto LABEL_75;
                }
              }
            }
          }
          MediaFilePrivateData = segPumpGetMediaFilePrivateData(v13);
          if (v88[37] && *(_QWORD *)(v7 + 64))
          {
            v75 = MediaFilePrivateData;
            if (FigMediaSegmentSpecifierGetType((uint64_t)v13) != 1
              && !v75[13]
              && segPumpCanAddSegmentToCache(v88, (_QWORD *)v7, v13, 0))
            {
              segPumpCreateMediaSegmentCache((uint64_t)v88, v7, v13);
            }
            if (v75[13])
            {
              CryptKeyCommonData = segPumpAppendBytesToCache((uint64_t)v88, v7, v13, *(OpaqueCMBlockBuffer **)(v30 + 128), v43, v44, 0);
              if ((_DWORD)CryptKeyCommonData)
                goto LABEL_83;
            }
          }
          v76 = *(_QWORD *)(v7 + 880);
          if (FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v13) && *((_BYTE *)v88 + 322))
          {
            v77 = v13;
            v78 = segPumpMediaFileHandleCryptData((uint64_t)cf, (uint64_t)v88, v7, *(const void **)(v30 + 8), *(OpaqueCMBlockBuffer **)(v30 + 128), v43, v44, 0, 0);
            if ((_DWORD)v78 == -12465)
            {
              v53 = cf;
              v56 = *(_QWORD *)(v30 + 8);
              v55 = (_QWORD *)v7;
              v54 = 0;
              v57 = 4294954831;
LABEL_82:
              CryptKeyCommonData = segPumpHandleMediaFileNetworkError((uint64_t)v53, v55, v54, v56, v57);
LABEL_83:
              v59 = CryptKeyCommonData;
              goto LABEL_112;
            }
            v59 = v78;
            if ((_DWORD)v78 == -12463)
            {
              CryptKeyCommonData = segPumpHandleCryptFailure((uint64_t)cf, (uint64_t)v88, v7);
              goto LABEL_83;
            }
          }
          else
          {
            v77 = v13;
            v59 = segPumpSendMediaCallback((uint64_t)cf, (uint64_t)v88, v7, *(const void **)(v30 + 8), *(OpaqueCMBlockBuffer **)(v30 + 128), v43, v44, 0, 0);
          }
          if (!(_DWORD)v59)
          {
            if (!FigRetainProxyIsInvalidated() && v76 == *(_QWORD *)(v7 + 880))
            {
              v13 = v77;
              if (*(const void **)(v30 + 8) == v77)
              {
LABEL_75:
                *(_BYTE *)(v30 + 144) = 0;
                v45 = *(_DWORD *)(v30 + 80) + 1;
                segPumpStreamDontReuseHTTPRequest((uint64_t)v88, v30);
                *(_DWORD *)(v30 + 80) = v45;
                v46 = *(_QWORD *)(v30 + 216);
                v47 = *(_QWORD *)(v30 + 248);
                *(_QWORD *)(v30 + 240) += v46;
                if (v47)
                  *(_QWORD *)(v30 + 248) = v47 - v46;
                v48 = v88;
                v49 = FigGetUpTimeNanoseconds();
                segPumpGetObservedNetworkStats((uint64_t)v48, (uint64_t)((double)v49 + v28 * -1000000000.0), (uint64_t)v83);
                if (v45 <= 6)
                {
                  v50 = v88[1018];
                  if (!v50
                    || (v51 = *(_QWORD *)&v83[0], v51 < (int)FigAlternateGetPeakBitRate(*(_QWORD *)(v50 + 8)))
                    || (LODWORD(v52) = *((_DWORD *)v88 + 2), v24 <= (double)v52))
                  {
                    if (FigMediaSegmentSpecifierGetStartOffset((uint64_t)v13))
                    {
                      v64 = 1;
                    }
                    else if (FigMediaSegmentSpecifierGetBytesToRead((uint64_t)v13))
                    {
                      v64 = 1;
                    }
                    else
                    {
                      v64 = 9;
                    }
                    MediaURLRequest = segPumpCreateMediaURLRequest((uint64_t)cf, v7, v13, *(const void **)(v30 + 16), v30, *(_QWORD *)(v30 + 240), *(_QWORD *)(v30 + 248), v64, 0);
                    if ((_DWORD)MediaURLRequest)
                    {
                      v59 = MediaURLRequest;
LABEL_113:
                      segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(a2, v59);
                      goto LABEL_114;
                    }
                    goto LABEL_111;
                  }
                }
                v53 = cf;
                v54 = v30 + 16;
                v55 = (_QWORD *)v7;
                v56 = (uint64_t)v13;
                v57 = 4294954407;
                goto LABEL_82;
              }
              goto LABEL_103;
            }
            v59 = 0;
          }
LABEL_112:
          if (!(_DWORD)v59)
            goto LABEL_114;
          goto LABEL_113;
        }
        v69 = 1079;
      }
      v68[v69] += v44;
      goto LABEL_119;
    }
  }
LABEL_114:
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
}

void segPumpRTCReportingUpdateMediaTimerStats(uint64_t a1, _QWORD *a2, uint64_t a3, double a4)
{
  uint64_t v6;
  _QWORD *v7;
  CFNumberRef v8;
  uint64_t v9;
  void (*v10)(uint64_t, __CFString *, __CFString *, CFNumberRef, _QWORD);
  __CFString *v11;
  double valuePtr;

  valuePtr = a4;
  v6 = a2[97];
  if (v6 < 1)
  {
LABEL_5:
    v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &valuePtr);
    if (*a2 == 1)
    {
      v9 = *(_QWORD *)(a1 + 9048);
      if (!v9)
        goto LABEL_14;
      v10 = *(void (**)(uint64_t, __CFString *, __CFString *, CFNumberRef, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                            + 48);
      if (!v10)
        goto LABEL_14;
      v11 = CFSTR("AuDefTime");
    }
    else
    {
      if (*a2)
        goto LABEL_14;
      v9 = *(_QWORD *)(a1 + 9048);
      if (!v9)
        goto LABEL_14;
      v10 = *(void (**)(uint64_t, __CFString *, __CFString *, CFNumberRef, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                            + 48);
      if (!v10)
        goto LABEL_14;
      v11 = CFSTR("VidDefTime");
    }
    v10(v9, CFSTR("bytePumpStats"), v11, v8, 0);
LABEL_14:
    if (v8)
      CFRelease(v8);
    return;
  }
  v7 = (_QWORD *)a2[96];
  while (*v7 != a3)
  {
    ++v7;
    if (!--v6)
      goto LABEL_5;
  }
}

OpaqueCMBlockBuffer *segPumpAccumConnCompletesMediaRange(uint64_t a1, const void *a2)
{
  OpaqueCMBlockBuffer *result;
  size_t DataLength;

  result = *(OpaqueCMBlockBuffer **)(a1 + 272);
  if (result)
  {
    DataLength = CMBlockBufferGetDataLength(result);
    return (OpaqueCMBlockBuffer *)(segPumpReadCompletesMediaRange(a2, DataLength) != 0);
  }
  return result;
}

void segPumpSetMediaFileForMediaConnection(_QWORD *a1, uint64_t a2, const void *a3, CFTypeRef cf)
{
  const void *v7;
  const void *v8;
  const __CFURL *v9;
  const __CFURL *v10;
  _QWORD *MediaFilePrivateData;
  const void *v12;
  const void *v13;

  v7 = (const void *)a1[2];
  a1[2] = cf;
  if (cf)
    CFRetain(cf);
  if (v7)
    CFRelease(v7);
  v8 = (const void *)a1[21];
  v10 = *(const __CFURL **)(a2 + 16);
  v9 = *(const __CFURL **)(a2 + 24);
  MediaFilePrivateData = segPumpGetMediaFilePrivateData(a3);
  segPumpEnsureMediaSegmentURLs(a3, v10, v9);
  v12 = (const void *)MediaFilePrivateData[2];
  a1[21] = v12;
  if (v12)
    CFRetain(v12);
  if (v8)
    CFRelease(v8);
  v13 = (const void *)a1[1];
  a1[1] = a3;
  if (a3)
    CFRetain(a3);
  if (v13)
    CFRelease(v13);
}

const void *segPumpReadCompletesMediaRange(const void *result, uint64_t a2)
{
  const void *v3;
  unint64_t v4;

  if (result)
  {
    v3 = result;
    if (FigMediaSegmentSpecifierGetBytesToRead((uint64_t)result) < 1)
    {
      return 0;
    }
    else
    {
      result = segPumpGetMediaFilePrivateData(v3);
      if (result)
      {
        v4 = *((_QWORD *)result + 6) + a2;
        return (const void *)(v4 >= FigMediaSegmentSpecifierGetBytesToRead((uint64_t)v3));
      }
    }
  }
  return result;
}

uint64_t segPumpCreateMediaURLRequest(uint64_t a1, uint64_t a2, const void *a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, const void *a9)
{
  uint64_t DerivedStorage;
  uint64_t v17;
  float v18;
  int PeakBitRate;
  double TimeInSeconds;
  uint64_t v21;
  int v22;
  uint64_t URLGuts;
  const __CFURL *v24;
  const __CFURL *v25;
  _QWORD *MediaFilePrivateData;
  const void *NextSegment;
  const __CFURL *v28;
  const __CFURL *v29;
  uint64_t v30;
  uint64_t v31;
  const void *v32;
  const void *v33;
  _QWORD *v34;
  uint64_t v35;
  const void *v36;
  int v37;
  const __CFURL **v38;
  const void *v39;
  const void *v40;
  const void *v41;
  const void *v42;
  const void *v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t HTTPRequest;
  NSObject *v51;
  uint64_t v53;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v55;
  int v56;
  unsigned int v57;
  const void *v58;
  BOOL v59;
  int v60;
  __int128 v61[8];
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v58 = a3;
  v56 = a8;
  if (!segPumpShouldRequestURLAsHTTPURL(DerivedStorage, (const __CFURL *)a4))
  {
    segPumpPrepareMediaConnectionForNewRequest(DerivedStorage, a2, a3, a4, a5, a6, a7, 0);
    URLGuts = segPumpCustomURLLoaderGetURLGuts(DerivedStorage, a4, 0, 0, 0, 0, (a8 >> 10) & 1, 0, (a8 & 4) != 0, a6, a7, a5 + 104);
    if (!(_DWORD)URLGuts)
    {
      if (!dword_1EE2A31E8)
        return 0;
      v60 = 0;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
LABEL_58:
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      return 0;
    }
    return URLGuts;
  }
  v17 = *(_QWORD *)(DerivedStorage + 7680);
  v18 = 0.5;
  if (v17 && *(_QWORD *)(DerivedStorage + 16 * *(_QWORD *)a2 + 392) == a2 && *(_QWORD *)(DerivedStorage + 8144))
  {
    PeakBitRate = FigAlternateGetPeakBitRate(*(_QWORD *)(v17 + 8));
    if (PeakBitRate >= (int)FigAlternateGetPeakBitRate(*(_QWORD *)(*(_QWORD *)(DerivedStorage + 8144) + 8)))
      v18 = 0.5;
    else
      v18 = 0.794;
  }
  v59 = 0;
  v67 = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v62 = 0u;
  TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)a3);
  CMTimeMakeWithSeconds((CMTime *)((char *)&v64 + 12), TimeInSeconds, 1000);
  v21 = *(_QWORD *)a2;
  if (*(_QWORD *)a2 == 2)
  {
    v22 = 6;
  }
  else if (v21 == 1)
  {
    v22 = 2;
  }
  else
  {
    if (v21)
      goto LABEL_20;
    if (*(_QWORD *)(DerivedStorage + 8392))
      v22 = 3;
    else
      v22 = 4;
  }
  DWORD1(v66) = v22;
LABEL_20:
  v53 = a6;
  v24 = *(const __CFURL **)(a2 + 16);
  v25 = *(const __CFURL **)(a2 + 24);
  MediaFilePrivateData = segPumpGetMediaFilePrivateData(a3);
  segPumpEnsureMediaSegmentURLs(a3, v24, v25);
  *((_QWORD *)&v67 + 1) = MediaFilePrivateData[2];
  if (FigMediaSegmentSpecifierGetNextSegment((uint64_t)a3))
  {
    NextSegment = (const void *)FigMediaSegmentSpecifierGetNextSegment((uint64_t)a3);
    v28 = *(const __CFURL **)(a2 + 16);
    v29 = *(const __CFURL **)(a2 + 24);
    v30 = a7;
    v31 = a2;
    v32 = a4;
    v33 = a3;
    v34 = segPumpGetMediaFilePrivateData(NextSegment);
    segPumpEnsureMediaSegmentURLs(NextSegment, v28, v29);
    v35 = v34[2];
    a3 = v33;
    a4 = v32;
    a2 = v31;
    a7 = v30;
    *(_QWORD *)&v68 = v35;
  }
  *((_QWORD *)&v68 + 1) = a3;
  if (*(_BYTE *)(DerivedStorage + 327))
    return FigSignalErrorAt();
  if (!*(_QWORD *)(a5 + 160)
    && *(_QWORD *)(a2 + 280)
    && !FigCFHTTPCanURLsBePersistent(*(const __CFURL **)(a2 + 16), (const __CFURL *)a4, &v59)
    && v59)
  {
    *(_OWORD *)(a5 + 152) = *(_OWORD *)(a2 + 272);
    *(_QWORD *)(a2 + 272) = 0;
    *(_QWORD *)(a2 + 280) = 0;
  }
  v36 = *(const void **)(a5 + 32);
  v37 = v56;
  if (v36)
  {
    CFRelease(v36);
    *(_QWORD *)(a5 + 32) = 0;
  }
  v38 = (const __CFURL **)(a5 + 16);
  v39 = *(const void **)(a5 + 24);
  if (v39)
  {
    CFRelease(v39);
    *(_QWORD *)(a5 + 24) = 0;
  }
  v40 = *(const void **)(a5 + 160);
  if (v40 && *v38)
  {
    if (FigCFHTTPCanURLsBePersistent(*v38, (const __CFURL *)a4, &v59) || v59)
    {
      v40 = *(const void **)(a5 + 160);
    }
    else
    {
      v41 = *(const void **)(a5 + 152);
      if (v41)
      {
        CFRelease(v41);
        *(_QWORD *)(a5 + 152) = 0;
      }
      v42 = *(const void **)(a5 + 160);
      if (v42)
        CFRelease(v42);
      v40 = 0;
    }
  }
  v43 = *(const void **)(a5 + 152);
  *(_QWORD *)(a5 + 152) = 0;
  *(_QWORD *)(a5 + 160) = 0;
  v55 = a7;
  if (*(_QWORD *)(a2 + 696) == a5)
  {
    v44 = v53;
    if (*(_BYTE *)(a2 + 402))
      v37 = v56 | 0x20;
  }
  else
  {
    v44 = v53;
  }
  if (*(_BYTE *)(DerivedStorage + 7999))
    v45 = v37 | 0x200;
  else
    v45 = v37;
  v57 = v45;
  segPumpPrepareMediaConnectionForNewRequest(DerivedStorage, a2, v58, a4, a5, v44, v55, 1);
  if (!*(_BYTE *)(DerivedStorage + 8457))
  {
    *(_BYTE *)(DerivedStorage + 8457) = 1;
    AttemptNetworkMonitorSetup(DerivedStorage, a4);
  }
  v46 = *(_QWORD *)(DerivedStorage + 56);
  v47 = *(_QWORD *)DerivedStorage;
  v61[3] = v65;
  v61[4] = v66;
  v61[5] = v67;
  v61[6] = v68;
  v61[0] = v62;
  v48 = *(_QWORD *)(DerivedStorage + 216);
  v49 = *(_QWORD *)(DerivedStorage + 240);
  v61[1] = v63;
  v61[2] = v64;
  HTTPRequest = segPumpCreateHTTPRequest(DerivedStorage, v46, (_QWORD *)a2, v43, (uint64_t)v40, a4, v48, v49, v18, 0, 13, v57, v61, v44, v55, (uint64_t)segPumpMediaFileMemoryRequestCallback, (uint64_t)segPumpMediaFileReadCallback, v47, a9,
                  a5 + 16);
  if (v43)
    CFRelease(v43);
  if (v40)
    CFRelease(v40);
  if (!(_DWORD)HTTPRequest && dword_1EE2A31E8)
  {
    v51 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT);
    goto LABEL_58;
  }
  return HTTPRequest;
}

unint64_t segPumpGetRequestedByteRangeForMediaFileHelper(uint64_t a1, _QWORD *a2, const void *a3, const void *a4, unsigned int a5, uint64_t *a6, uint64_t *a7, unint64_t *a8)
{
  _QWORD *MediaFilePrivateData;
  uint64_t v15;
  unint64_t result;
  int64_t v17;
  uint64_t ContentKeySpecifier;
  uint64_t v19;
  uint64_t v20;
  int CryptAlgForKey;
  unint64_t BlockSize;
  unint64_t v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  BOOL v35;
  const void *v36;
  CFIndex v37;
  const __CFArray *MediaSegmentSpecifiers;
  const void *ValueAtIndex;
  _BYTE *v40;
  const __CFURL *v41;
  const __CFURL *v42;
  _QWORD *v43;
  const void *v44;
  const __CFURL *v45;
  const __CFURL *v46;
  CFTypeRef *v47;
  uint64_t v48;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unint64_t *v50;
  uint64_t *v51;
  uint64_t *v52;
  _BYTE *v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v58;
  _QWORD v59[18];

  v59[16] = *MEMORY[0x1E0C80C00];
  MediaFilePrivateData = segPumpGetMediaFilePrivateData(a3);
  v15 = MediaFilePrivateData[7] + FigMediaSegmentSpecifierGetStartOffset((uint64_t)a3);
  result = FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a3);
  v17 = result;
  if (a3)
  {
    result = FigMediaSegmentSpecifierGetType((uint64_t)a3);
    if ((_DWORD)result == 1)
    {
      result = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a3);
      if (result)
      {
        ContentKeySpecifier = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a3);
        result = FigContentKeySpecifierGetEncryptionMethod(ContentKeySpecifier);
        if ((_DWORD)result == 3)
        {
          v19 = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a3);
          result = FigContentKeySpecifierGetEncryptionMethod(v19);
          if ((_DWORD)result != 4 && v17 >= 1)
          {
            v20 = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a3);
            CryptAlgForKey = segPumpGetCryptAlgForKey(v20);
            BlockSize = FigCryptGetBlockSize(CryptAlgForKey);
            result = FigMediaSegmentSpecifierGetBytesToRead((uint64_t)a3);
            v17 = (result + 2 * BlockSize - 1) / BlockSize * BlockSize;
          }
        }
      }
    }
  }
  v23 = MediaFilePrivateData[7];
  v24 = v17 >= v23;
  v25 = v17 - v23;
  if (v24)
    v26 = v25;
  else
    v26 = 0;
  if (a5)
  {
    v27 = a1;
    result = segPumpShouldPadByteCountForMediaSegment(a1, (uint64_t)a3);
    if ((_DWORD)result)
    {
      v28 = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a3);
      v29 = segPumpGetCryptAlgForKey(v28);
      v30 = FigCryptGetBlockSize(v29);
      result = FigMediaSegmentSpecifierGetStartOffset((uint64_t)a3);
      if (result >= 2 * v30)
      {
        result = FigMediaSegmentSpecifierGetStartOffset((uint64_t)a3);
        v31 = result % v30 + v30;
        v15 -= v31;
        v54 = v31;
        v26 += v31;
      }
      else
      {
        v54 = 0;
      }
      v32 = (v15 + v26) % v30;
      if (v32)
        v33 = v30 - v32;
      else
        v33 = 0;
      v26 += v30 + v33;
    }
    else
    {
      v54 = 0;
    }
  }
  else
  {
    v54 = 0;
    v27 = a1;
  }
  v55 = v15;
  if (a4 != a3 || ((v53 = (_BYTE *)(v27 + 8208), v26 >= 1) ? (v35 = *(_BYTE *)(v27 + 8208) == 0) : (v35 = 1), v35))
  {
    v34 = v26;
  }
  else
  {
    v36 = a3;
    v34 = v26;
    v50 = a8;
    v51 = a6;
    v52 = a7;
    while (v36 && v34 >= 1 && *v53)
    {
      if (FigMediaSegmentSpecifierGetType((uint64_t)v36) == 1)
      {
        v37 = 0;
        while (1)
        {
          result = FigMediaPlaylistGetMediaSegmentSpecifiers(a2[7]);
          if (result)
            result = CFArrayGetCount((CFArrayRef)result);
          if (v37 >= (uint64_t)result)
            goto LABEL_49;
          MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a2[7]);
          ValueAtIndex = CFArrayGetValueAtIndex(MediaSegmentSpecifiers, v37);
          result = FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)ValueAtIndex);
          ++v37;
          if ((const void *)result == v36)
            goto LABEL_40;
        }
      }
      result = FigMediaSegmentSpecifierGetNextSegment((uint64_t)v36);
      ValueAtIndex = (const void *)result;
LABEL_40:
      if (!ValueAtIndex)
        goto LABEL_48;
      v40 = segPumpGetMediaFilePrivateData(ValueAtIndex);
      v41 = (const __CFURL *)a2[2];
      v42 = (const __CFURL *)a2[3];
      v43 = segPumpGetMediaFilePrivateData(v36);
      segPumpEnsureMediaSegmentURLs(v36, v41, v42);
      v44 = (const void *)v43[2];
      v45 = (const __CFURL *)a2[2];
      v46 = (const __CFURL *)a2[3];
      v47 = (CFTypeRef *)segPumpGetMediaFilePrivateData(ValueAtIndex);
      segPumpEnsureMediaSegmentURLs(ValueAtIndex, v45, v46);
      result = FigCFHTTPCompareURLs(v44, v47[2]);
      if (!(_DWORD)result)
      {
LABEL_48:
        a8 = v50;
        a6 = v51;
        a7 = v52;
        break;
      }
      a8 = v50;
      a6 = v51;
      a7 = v52;
      if (!v40[73])
      {
        v59[0] = 0;
        v58 = 0;
        result = segPumpSeeIfMediaFileIsInCache(a1, (uint64_t)a2, ValueAtIndex, 0, 0);
        if (!(_DWORD)result)
        {
          result = segPumpGetRequestedByteRangeForMediaFileHelper(a1, a2, ValueAtIndex, 0, a5, v59, &v58, 0);
          if (v58 >= 1 && v59[0] <= v34 + v55)
          {
            v48 = v59[0] - (v34 + v55) + v58;
            v34 = v59[0] - v55 + v58;
            v36 = ValueAtIndex;
            if (v48 > 0)
              continue;
          }
        }
      }
      break;
    }
LABEL_49:
    if (v34 > v26 && dword_1EE2A31E8)
    {
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      a7 = v52;
      result = fig_log_call_emit_and_clean_up_after_send_and_compose();
      a6 = v51;
    }
  }
  if (a6)
    *a6 = v55;
  if (a7)
    *a7 = v34;
  if (a8)
    *a8 = v54;
  return result;
}

uint64_t segPumpGetCryptAlgForKey(uint64_t a1)
{
  if (FigContentKeySpecifierGetEncryptionMethod(a1) == 4)
    return 3;
  else
    return FigContentKeySpecifierGetEncryptionMethod(a1) == 3;
}

void segPumpPrepareMediaConnectionForNewRequest(uint64_t a1, uint64_t a2, const void *a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  const void *v13;
  uint64_t v14;
  void (*v15)(uint64_t, __CFString *, __CFString *, uint64_t);
  int InterfaceType;
  CFTypeRef cf;

  segPumpSetMediaFileForMediaConnection((_QWORD *)a5, a2, a3, a4);
  *(_QWORD *)(a5 + 120) = 0;
  *(_DWORD *)(a5 + 96) = 0;
  *(_QWORD *)(a5 + 216) = 0;
  *(_QWORD *)(a5 + 224) = 0;
  *(_QWORD *)(a5 + 232) = 0;
  *(_QWORD *)(a5 + 240) = a6;
  *(_QWORD *)(a5 + 248) = a7;
  *(_QWORD *)(a5 + 256) = 0;
  *(_WORD *)(a5 + 280) = 0;
  *(_QWORD *)(a5 + 296) = 0;
  *(_QWORD *)(a5 + 304) = 0;
  ++*(_QWORD *)(a1 + 8504);
  if (!a8 || *(_BYTE *)(a5 + 208) != 1)
  {
    v13 = *(const void **)(a5 + 128);
    if (v13)
    {
      CFRelease(v13);
      *(_QWORD *)(a5 + 128) = 0;
    }
    *(_QWORD *)(a5 + 136) = 0;
  }
  *(_BYTE *)(a5 + 208) = a8;
  v14 = *(_QWORD *)(a1 + 9048);
  if (v14)
  {
    v15 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                              + 32);
    if (v15)
      v15(v14, CFSTR("bytePumpStats"), CFSTR("MReqCount"), 1);
  }
  InterfaceType = *(_DWORD *)(a1 + 8464);
  if (!InterfaceType)
  {
    InterfaceType = *(_DWORD *)(a1 + 8460);
    if (!InterfaceType)
    {
      if (!*(_QWORD *)(a1 + 8448))
        return;
      InterfaceType = FigNetworkPathInformationGetInterfaceType();
    }
  }
  if ((InterfaceType - 3) >= 2)
  {
    if (InterfaceType != 5)
      return;
    cf = 0;
    FigNetworkWirelessReportingInterfaceCopyCellStats(&cf);
    FigNetworkWirelessReportingReportCellStats(*(_QWORD *)(a1 + 9048), (uint64_t)cf);
  }
  else
  {
    cf = 0;
    FigNetworkWirelessReportingInterfaceCopyWifiStats(&cf);
    FigNetworkWirelessReportingReportWiFiStats(*(_QWORD *)(a1 + 9048), (uint64_t)cf);
  }
  if (cf)
    CFRelease(cf);
}

uint64_t segPumpMediaFileMemoryRequestCallback(uint64_t a1, uint64_t a2, int a3, uint64_t a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t BlockBuffer;
  uint64_t StreamFromMediaHTTPRequest;
  _QWORD *v13;
  BOOL v14;
  unint64_t v15;
  const void *v16;
  CFTypeRef v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v21;
  uint64_t v22;
  CFTypeRef cf;

  v22 = 0;
  cf = 0;
  v21 = 0;
  BlockBuffer = segPumpLockAndCopyPumpFromRetainProxy(a1, &cf, &v22);
  if (!(_DWORD)BlockBuffer)
  {
    StreamFromMediaHTTPRequest = segPumpGetStreamFromMediaHTTPRequest(v22, a2, a3, &v21);
    v13 = v21;
    if (StreamFromMediaHTTPRequest)
      v14 = v21 == 0;
    else
      v14 = 1;
    if (v14 || !v21[1])
    {
      v19 = 0;
      goto LABEL_17;
    }
    v15 = v21[17];
    if (a4 - 1 >= 0x20000 - v15 && v15 > 0x10000)
    {
      v16 = (const void *)v21[16];
      if (v16)
      {
        CFRelease(v16);
        v13 = v21;
        v21[16] = 0;
      }
      v13[17] = 0;
    }
    v17 = (CFTypeRef)v13[16];
    if (v17)
      goto LABEL_15;
    segPumpGetMediaDataMemoryPool(v22);
    BlockBuffer = FigMemoryPoolCreateBlockBuffer();
    if (!(_DWORD)BlockBuffer)
    {
      v18 = v21;
      v21[17] = 0;
      v17 = (CFTypeRef)v18[16];
      if (!v17)
      {
LABEL_16:
        v19 = 0;
        *a5 = v17;
        *a6 = v18[17];
        goto LABEL_17;
      }
LABEL_15:
      v17 = CFRetain(v17);
      v18 = v21;
      goto LABEL_16;
    }
  }
  v19 = BlockBuffer;
LABEL_17:
  FigRetainProxyUnlockMutex();
  if (cf)
    CFRelease(cf);
  return v19;
}

void segPumpMediaFileReadCallback(uint64_t a1, int a2, uint64_t a3, uint64_t a4, size_t a5, int64_t a6, char a7, uint64_t a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t StreamFromMediaHTTPRequest;
  const void *v18;
  CFMutableDictionaryRef Mutable;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t AllocatorForMedia;
  void (*v24)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  uint64_t v25;
  uint64_t v26;
  void (*v27)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  uint64_t v28;
  uint64_t v29;
  void (*v30)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  int v31;
  _BOOL4 v32;
  uint64_t v33;
  void (*v34)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int128 *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v35;
  void (*v36)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v37;
  unint64_t v38;
  void (*v39)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v40;
  uint64_t v41;
  CFStringRef v42;
  CFStringRef v43;
  void (*v44)(uint64_t, __CFString *, __CFString *, CFStringRef, _QWORD);
  uint64_t v45;
  int64_t v46;
  CFTypeRef v47;
  uint64_t v48;
  CFTypeRef v49;
  uint64_t v50;
  _QWORD *v51;
  const __CFData *v52;
  const __CFData *v53;
  uint64_t v54;
  const __CFAllocator *v55;
  const void *v56;
  const void *v57;
  int v58;
  CFAbsoluteTime v59;
  CFAbsoluteTime v60;
  CFAbsoluteTime v61;
  const void *v62;
  uint64_t v63;
  char v64;
  int v65;
  CFTypeRef v66;
  uint64_t v67;
  uint64_t v68;
  unsigned int (*v69)(uint64_t, const __CFString *, uint64_t, CFNumberRef *);
  uint64_t v70;
  uint64_t v71;
  unsigned int (*v72)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  uint64_t v73;
  uint64_t v74;
  unsigned int (*v75)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  uint64_t v76;
  const __CFAllocator *v77;
  int InterfaceTypeFromCFNStats;
  uint64_t v79;
  uint64_t v80;
  BOOL v81;
  int64_t v82;
  uint64_t v83;
  char v84;
  NSObject *v85;
  unsigned int v86;
  unsigned int v87;
  const __CFString *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  void (*v93)(uint64_t, __CFString *, __CFString *, uint64_t);
  const void *v94;
  CFTypeRef v95;
  uint64_t v96;
  const __CFData *v97;
  const __CFData *v98;
  uint64_t v99;
  void (*v100)(uint64_t, __CFString *, __CFString *, const __CFData *, _QWORD);
  void *v101;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v103;
  unsigned int v104;
  const __CFString *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  const void *v109;
  uint64_t v110;
  char v111;
  int64_t v112;
  unsigned int v113;
  size_t v114;
  uint64_t v115;
  CFTypeRef v116;
  CFTypeRef v117;
  CFTypeRef v118;
  CFTypeRef v119;
  CFTypeRef v120;
  uint64_t valuePtr;
  CFNumberRef number;
  uint64_t v123;
  uint64_t v124;
  CFTypeRef v125[2];
  double v126;
  double v127;
  os_log_type_t type[8];
  CFTypeRef cf;
  _BYTE v130[12];
  __int16 v131;
  const __CFString *v132;
  __int16 v133;
  uint64_t v134;
  __int16 v135;
  uint64_t v136;
  __int16 v137;
  const void *v138;
  __int128 v139;
  uint64_t v140;
  uint64_t v141;

  v141 = *MEMORY[0x1E0C80C00];
  v124 = 0;
  v125[0] = 0;
  number = 0;
  v123 = 0;
  v120 = 0;
  valuePtr = 0;
  v118 = 0;
  v119 = 0;
  v116 = 0;
  v117 = 0;
  FigRetainProxyRetain();
  v15 = segPumpLockAndCopyPumpFromRetainProxy(a3, v125, &v124);
  if ((_DWORD)v15)
  {
    v90 = v15;
    v18 = 0;
LABEL_151:
    Mutable = 0;
LABEL_96:
    segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(a3, v90);
    goto LABEL_97;
  }
  v114 = a5;
  v16 = v124;
  StreamFromMediaHTTPRequest = segPumpGetStreamFromMediaHTTPRequest(v124, a1, a2, &v123);
  v18 = 0;
  if (!StreamFromMediaHTTPRequest)
  {
    Mutable = 0;
    goto LABEL_97;
  }
  v115 = a1;
  Mutable = 0;
  if (!v123)
    goto LABEL_97;
  if (!*(_QWORD *)(v123 + 32))
  {
    v18 = 0;
    Mutable = 0;
    goto LABEL_97;
  }
  v20 = (uint64_t *)StreamFromMediaHTTPRequest;
  if ((a7 & 1) != 0)
  {
    segPumpRTCReportingUpdatePreLTKUStats_HeadersAvailable(v16, a1);
    v21 = v124;
    if (*(_BYTE *)(v124 + 330))
    {
      if (segPumpIsProtocolUsedByRequest(v115, CFSTR("h3")))
        *(_BYTE *)(v21 + 330) = segPumpCheckPriorityHeaderLowLatencyServerCompliance(v115, 1);
    }
  }
  v22 = *(_QWORD *)(v123 + 32);
  AllocatorForMedia = FigGetAllocatorForMedia();
  v24 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                           + 48);
  if (v24)
    v24(v22, CFSTR("FHRP_CFNetworkTimingData"), AllocatorForMedia, &v118);
  v25 = *(_QWORD *)(v123 + 32);
  v26 = FigGetAllocatorForMedia();
  v27 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                           + 48);
  if (v27)
    v27(v25, CFSTR("FHRP_CFNetworkTransactionMetrics"), v26, &v119);
  v28 = *(_QWORD *)(v123 + 32);
  v29 = FigGetAllocatorForMedia();
  v30 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                           + 48);
  if (v30)
    v30(v28, CFSTR("FHRP_ByteRange"), v29, &v117);
  FigCFDictionaryGetInt64IfPresent();
  FigCFDictionaryGetInt64IfPresent();
  if ((a7 & 2) != 0)
  {
    v31 = *(_DWORD *)(v124 + 9068);
    if (*(_BYTE *)(v124 + 9112))
      v32 = v31 != 0;
    else
      v32 = v31 == 2;
    FigNetworkInterfaceReporterSamplePhysicalStatistics(*(_QWORD *)(v124 + 9120), v115, *(_QWORD *)(v124 + 9048), 0x1E301B658, v32);
    segPumpRTCReportingUpdatePrivateAppleCDNInfo(v124, v115);
    FigReportingAgentUpdateFinalTransactionMetrics(*(_QWORD *)(v124 + 9048), v115, 0, 0);
    v33 = v124;
    *(_QWORD *)&v139 = 0;
    v34 = *(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int128 *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 40);
    if (v34)
    {
      v34(v115, 0, 0, 0, 0, 0, &v139, 0, 0, 0, 0, 0, 0);
      if ((uint64_t)v139 >= 1)
      {
        v35 = *(_QWORD *)(v33 + 9048);
        if (v35)
        {
          v36 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                + 16)
                                                                                    + 32);
          if (v36)
            v36(v35, CFSTR("startupStats"), CFSTR("MediaResponseCount"), 1);
          v37 = *(_QWORD *)(v33 + 9048);
          if (v37)
          {
            v38 = v139;
            v39 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                               + 32);
            if (v39)
              v39(v37, CFSTR("startupStats"), CFSTR("MediaResponseTimeSum"), v38 / 0xF4240);
          }
        }
      }
    }
    v40 = v124;
    v41 = *(_QWORD *)(v124 + 9048);
    if (v41)
    {
      v42 = CFURLCopyHostName(*(CFURLRef *)(v123 + 16));
      if (v42)
      {
        v43 = v42;
        if (*(_BYTE *)(v40 + 9080))
        {
          v44 = *(void (**)(uint64_t, __CFString *, __CFString *, CFStringRef, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                + 48);
          if (v44)
            v44(v41, CFSTR("bytePumpStats"), CFSTR("ContentHostname"), v43, 0);
        }
        CFRelease(v43);
      }
    }
    v45 = a8;
    v46 = a6;
    v48 = v124;
    v47 = v125[0];
    v49 = v119;
    v50 = v123;
    cf = 0;
    *(_QWORD *)v130 = 0;
    v127 = 0.0;
    *(double *)type = 0.0;
    v125[1] = 0;
    v126 = 0.0;
    if (v118)
    {
      FigCFDictionaryGetDoubleIfPresent();
      FigCFDictionaryGetDoubleIfPresent();
      FigCFDictionaryGetDoubleIfPresent();
      FigCFDictionaryGetDoubleIfPresent();
      if (!FigCreateErrorForOSStatus(v45, (CFErrorRef *)v130))
      {
        v51 = (_QWORD *)(*(_QWORD *)(v48 + 16 * *(_QWORD *)(v48 + 8416) + 384) + 680);
        v112 = v46;
        v113 = v45;
        v111 = a7;
        v109 = v49;
        while (1)
        {
          v51 = (_QWORD *)*v51;
          if (!v51)
            break;
          v52 = (const __CFData *)v51[22];
          if (v52)
            goto LABEL_40;
        }
        v52 = 0;
LABEL_40:
        v110 = a3;
        v53 = FigCFHTTPCreateAddressString(v52);
        v55 = (const __CFAllocator *)FigGetAllocatorForMedia();
        v56 = *(const void **)(v50 + 16);
        v57 = (const void *)v20[2];
        if ((unint64_t)*v20 > 2)
          v58 = 0;
        else
          v58 = dword_1932FD19C[*v20];
        v59 = v127;
        v60 = *(double *)type;
        v61 = v126;
        v62 = *(const void **)v130;
        v63 = *(_QWORD *)(v50 + 8);
        if (v63)
          v64 = FigMediaSegmentSpecifierGetType(v63) == 1;
        else
          v64 = 0;
        v139 = *MEMORY[0x1E0CA2E18];
        v140 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
        v65 = FigMetricHLSMediaSegmentRequestEventCreate(v55, v56, v57, v53, &v139, 0, 0, v60, v59, v61, v59, v54, 0, 0, 0, v62, v109, v58, v64,
                &cf);
        v66 = cf;
        if (!v65)
        {
          segPumpPublishMetricEvent((uint64_t)v47, v48, (void *)cf);
          v66 = cf;
        }
        a3 = v110;
        a7 = v111;
        v45 = v113;
        if (v66)
          CFRelease(v66);
        v46 = v112;
        if (v53)
          CFRelease(v53);
      }
    }
    if (*(_QWORD *)v130)
      CFRelease(*(CFTypeRef *)v130);
    segPumpSetWiFiStatsOnNetworkPredictor(v124, v123 + 16);
    a6 = v46;
    a8 = v45;
  }
  v67 = *(_QWORD *)(v123 + 32);
  v68 = FigGetAllocatorForMedia();
  v69 = *(unsigned int (**)(uint64_t, const __CFString *, uint64_t, CFNumberRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                           + 48);
  if (v69 && !v69(v67, CFSTR("FHRP_PayloadLength"), v68, &number))
    CFNumberGetValue(number, kCFNumberSInt64Type, &valuePtr);
  v70 = *(_QWORD *)(v123 + 32);
  v71 = FigGetAllocatorForMedia();
  v72 = *(unsigned int (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                               + 8)
                                                                                   + 48);
  if (!v72 || v72(v70, CFSTR("FHRP_RemoteIPAddress"), v71, &v120) || FigCFEqual())
    goto LABEL_61;
  v91 = v123;
  if (*(_QWORD *)(v123 + 176))
  {
    v92 = *(_QWORD *)(v124 + 9048);
    if (v92)
    {
      v93 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                            + 16)
                                                                                + 32);
      if (v93)
        v93(v92, CFSTR("bytePumpStats"), CFSTR("SrvAddrCount"), 1);
    }
    ++v20[118];
    v91 = v123;
    v94 = *(const void **)(v123 + 176);
  }
  else
  {
    v94 = 0;
  }
  v95 = v120;
  *(_QWORD *)(v91 + 176) = v120;
  if (v95)
    CFRetain(v95);
  if (v94)
    CFRelease(v94);
  v96 = v124;
  v97 = FigCFHTTPCreateAddressString(*(const __CFData **)(v123 + 176));
  if (v97)
  {
    v98 = v97;
    v99 = *(_QWORD *)(v96 + 9048);
    if (v99)
    {
      v100 = *(void (**)(uint64_t, __CFString *, __CFString *, const __CFData *, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                  + 48);
      if (v100)
        v100(v99, CFSTR("bytePumpStats"), CFSTR("ServerIP"), v98, 0);
    }
    CFRelease(v98);
  }
  if (!dword_1EE2A31E8)
  {
LABEL_61:
    v18 = 0;
  }
  else
  {
    if (*(_BYTE *)(v124 + 339))
      v101 = FigCFHTTPCreateAddressString(*(const __CFData **)(v123 + 176));
    else
      v101 = (void *)CFRetain(CFSTR("<redacted>"));
    v18 = v101;
    if (v101 && dword_1EE2A31E8)
    {
      LODWORD(cf) = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      v103 = cf;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0]))
        v104 = v103;
      else
        v104 = v103 & 0xFFFFFFFE;
      if (v104)
      {
        v105 = &stru_1E2FD85F8;
        if (v124 && *(_QWORD *)(v124 + 8760))
          v105 = *(const __CFString **)(v124 + 8760);
        v106 = *v20;
        if (v123)
          v107 = *(_QWORD *)(v123 + 184);
        else
          v107 = -1;
        *(_DWORD *)v130 = 136316162;
        *(_QWORD *)&v130[4] = "segPumpMediaFileReadCallback";
        v131 = 2114;
        v132 = v105;
        v133 = 2048;
        v134 = v106;
        v135 = 2048;
        v136 = v107;
        v137 = 2114;
        v138 = v18;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
  }
  if (*(_QWORD *)(v123 + 64))
    goto LABEL_63;
  v73 = *(_QWORD *)(v123 + 32);
  v74 = FigGetAllocatorForMedia();
  v75 = *(unsigned int (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                               + 8)
                                                                                   + 48);
  if (v75 && !v75(v73, CFSTR("FHRP_IsExpensive"), v74, &v116))
  {
    v76 = v124;
    *(_BYTE *)(v124 + 8468) = v116 == (CFTypeRef)*MEMORY[0x1E0C9AE50];
    segPumpUpdateNetworkCostIsExpensive(v76);
  }
  if (!v118)
  {
LABEL_63:
    Mutable = 0;
    goto LABEL_72;
  }
  *(_QWORD *)&v139 = 0;
  cf = 0;
  *(_QWORD *)v130 = 0;
  v77 = (const __CFAllocator *)FigGetAllocatorForMedia();
  Mutable = CFDictionaryCreateMutable(v77, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    FigCFDictionarySetValueFromKeyInDict();
    FigCFDictionarySetValueFromKeyInDict();
    FigCFDictionarySetValueFromKeyInDict();
    FigCFDictionaryGetInt64IfPresent();
    FigCFDictionaryGetDoubleIfPresent();
    FigCFDictionaryGetDoubleIfPresent();
    if (*(double *)v130 - *(double *)&v139 > 0.0)
      FigCFDictionarySetDouble();
    goto LABEL_71;
  }
  v108 = FigSignalErrorAt();
  if ((_DWORD)v108)
  {
    v90 = v108;
    goto LABEL_151;
  }
LABEL_71:
  InterfaceTypeFromCFNStats = FigNetworkInterfaceGetInterfaceTypeFromCFNStats((uint64_t)v118);
  v79 = v124;
  *(_DWORD *)(v124 + 8464) = InterfaceTypeFromCFNStats;
  segPumpUpdateNetworkCostHasHighSpeedHighPower(v79);
  a8 = a8;
LABEL_72:
  v80 = *(_QWORD *)(v123 + 8);
  if (v80)
  {
    v81 = FigMediaSegmentSpecifierGetType(v80) == 1;
    if ((a7 & 2) == 0)
      goto LABEL_78;
  }
  else
  {
    v81 = 0;
    if ((a7 & 2) == 0)
      goto LABEL_78;
  }
  if (!v81)
    segPumpRTCReportingUpdatePrivateAppleCDNInfo(v124, v115);
LABEL_78:
  if ((a7 & 0x10) != 0 && !*(_BYTE *)(v123 + 280))
  {
    if (dword_1EE2A31E8)
    {
      v82 = a6;
      v83 = a8;
      v84 = a7;
      LODWORD(cf) = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      v85 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      v86 = cf;
      if (os_log_type_enabled(v85, type[0]))
        v87 = v86;
      else
        v87 = v86 & 0xFFFFFFFE;
      if (v87)
      {
        v88 = &stru_1E2FD85F8;
        if (v124 && *(_QWORD *)(v124 + 8760))
          v88 = *(const __CFString **)(v124 + 8760);
        v89 = *v20;
        *(_DWORD *)v130 = 136315650;
        *(_QWORD *)&v130[4] = "segPumpMediaFileReadCallback";
        v131 = 2114;
        v132 = v88;
        v133 = 2048;
        v134 = v89;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      a7 = v84;
      a8 = v83;
      a6 = v82;
    }
    *(_BYTE *)(v124 + 8001) = 1;
  }
  if ((a7 & 4) != 0)
    *(_QWORD *)(v124 + 8544) += a6;
  if ((a7 & 8) != 0)
    *(_QWORD *)(v124 + 8552) += a6;
  v90 = segPumpHandleMediaFileData((uint64_t)v125[0], (uint64_t)v20, v123, v114, a6, valuePtr, (a7 & 2) != 0, a8);
  if ((_DWORD)v90)
    goto LABEL_96;
LABEL_97:
  segPumpUnlockAndSendAllPendingNotifications();
  if (v116)
    CFRelease(v116);
  if (v118)
    CFRelease(v118);
  if (Mutable)
    CFRelease(Mutable);
  if (v119)
    CFRelease(v119);
  if (v117)
    CFRelease(v117);
  if (number)
    CFRelease(number);
  if (v18)
    CFRelease(v18);
  if (v120)
    CFRelease(v120);
  FigRetainProxyRelease();
  if (v125[0])
    CFRelease(v125[0]);
}

uint64_t segPumpGetStreamFromMediaHTTPRequest(uint64_t a1, uint64_t a2, int a3, _QWORD *a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t *v8;

  v5 = 0;
  while (1)
  {
    v6 = a1 + 16 * v5;
    result = *(_QWORD *)(v6 + 384);
    v8 = *(uint64_t **)(result + 680);
    if (v8)
      break;
LABEL_6:
    result = *(_QWORD *)(v6 + 392);
    v8 = *(uint64_t **)(result + 680);
    if (v8)
    {
      while (v8[4] != a2 || *((_DWORD *)v8 + 24) != a3)
      {
        v8 = (uint64_t *)*v8;
        if (!v8)
          goto LABEL_10;
      }
      goto LABEL_13;
    }
LABEL_10:
    if (++v5 == 3)
      return 0;
  }
  while (v8[4] != a2 || *((_DWORD *)v8 + 24) != a3)
  {
    v8 = (uint64_t *)*v8;
    if (!v8)
      goto LABEL_6;
  }
LABEL_13:
  if (a4)
    *a4 = v8;
  return result;
}

uint64_t segPumpGetMediaDataMemoryPool(uint64_t a1)
{
  uint64_t result;
  CFNumberRef v3;
  const __CFAllocator *AllocatorForMedia;
  __CFDictionary *Mutable;
  const __CFAllocator *v6;
  CFStringRef v7;
  uint64_t valuePtr;

  result = *(_QWORD *)(a1 + 7920);
  if (!result)
  {
    valuePtr = 0x4014000000000000;
    v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &valuePtr);
    AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v6 = (const __CFAllocator *)FigGetAllocatorForMedia();
    v7 = CFStringCreateWithFormat(v6, 0, CFSTR("BytePumpHTTPSegment-%p"), a1);
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA4BA0], v7);
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA23D0], v3);
    *(_QWORD *)(a1 + 7920) = CMMemoryPoolCreate(Mutable);
    if (v3)
      CFRelease(v3);
    if (v7)
      CFRelease(v7);
    if (Mutable)
      CFRelease(Mutable);
    return *(_QWORD *)(a1 + 7920);
  }
  return result;
}

void segPumpRTCReportingUpdatePrivateAppleCDNInfo(uint64_t a1, uint64_t a2)
{
  uint64_t AllocatorForMedia;
  void (*v5)(uint64_t, __CFString *, uint64_t, CFHTTPMessageRef *);
  CFStringRef v6;
  const __CFString *v7;
  const __CFAllocator *v8;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v10;
  CFIndex Count;
  unint64_t v12;
  int v13;
  uint64_t v14;
  const __CFString *ValueAtIndex;
  int IsCacheHit;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __CFString *, uint64_t, uint64_t);
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(uint64_t, __CFString *, __CFString *, BOOL);
  uint64_t v27;
  void (*v28)(uint64_t, __CFString *, __CFString *, uint64_t);
  _BYTE *v29;
  __CFHTTPMessage *v30;
  const __CFAllocator *v31;
  CFMutableArrayRef Mutable;
  CFTypeRef v33;
  const __CFAllocator *v34;
  CFStringRef v35;
  CFStringRef v36;
  uint64_t v37;
  void (*v38)(uint64_t, __CFString *, __CFString *, CFStringRef, _QWORD);
  uint64_t v39;
  CFTypeRef v40;
  void (*v41)(uint64_t, __CFString *, __CFString *, CFTypeRef, _QWORD);
  __CFHTTPMessage *v42;
  int v43;
  CFHTTPMessageRef message;
  CFTypeRef v45;
  CFRange v46;

  message = 0;
  if (!a2)
    return;
  AllocatorForMedia = FigGetAllocatorForMedia();
  v5 = *(void (**)(uint64_t, __CFString *, uint64_t, CFHTTPMessageRef *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                             + 8)
                                                                                 + 48);
  if (!v5)
    return;
  v5(a2, CFSTR("FHRP_HTTPResponseHeaders"), AllocatorForMedia, &message);
  if (!message)
    return;
  v6 = CFHTTPMessageCopyHeaderFieldValue(message, CFSTR("Via"));
  if (v6)
  {
    v7 = v6;
    v8 = (const __CFAllocator *)FigGetAllocatorForMedia();
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v8, v7, CFSTR(","));
    if (ArrayBySeparatingStrings)
    {
      v10 = ArrayBySeparatingStrings;
      Count = CFArrayGetCount(ArrayBySeparatingStrings);
      if (Count >= 1)
      {
        v12 = Count;
        v13 = 0;
        v14 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v10, v12 - 1);
          IsCacheHit = FigCFHTTPVIAHeaderIsCacheHit(ValueAtIndex);
          if (IsCacheHit == -1)
            goto LABEL_22;
          if (v13 || !IsCacheHit)
            break;
          if (IsCacheHit != 1)
          {
            v13 = 0;
            goto LABEL_21;
          }
          v13 = 1;
          FigReportingAgentStatsUpdateSampleValueWithBool(*(_QWORD *)(a1 + 9048), 0x1E301B658, (uint64_t)*kReportingVIAHeaderCDNHitPctKeys[v14], 1);
          v17 = *(_QWORD *)(a1 + 9048);
          if (v17)
          {
            v18 = (uint64_t)*kReportingVIAHeaderCDNHitCountKeys[v14];
            v19 = *(void (**)(uint64_t, __CFString *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                             + 16)
                                                                                 + 32);
            if (!v19)
            {
              v13 = 1;
              goto LABEL_21;
            }
            v13 = 1;
            v20 = v17;
            v21 = v18;
            v22 = 1;
            goto LABEL_18;
          }
LABEL_21:
          ++v14;
LABEL_22:
          if (v12 >= 2)
          {
            --v12;
            if (v14 < 5)
              continue;
          }
          goto LABEL_26;
        }
        FigReportingAgentStatsUpdateSampleValueWithBool(*(_QWORD *)(a1 + 9048), 0x1E301B658, (uint64_t)*kReportingVIAHeaderCDNHitPctKeys[v14], 0);
        v23 = *(_QWORD *)(a1 + 9048);
        if (!v23)
          goto LABEL_21;
        v24 = (uint64_t)*kReportingVIAHeaderCDNHitCountKeys[v14];
        v19 = *(void (**)(uint64_t, __CFString *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                             + 32);
        if (!v19)
          goto LABEL_21;
        v20 = v23;
        v21 = v24;
        v22 = 0;
LABEL_18:
        v19(v20, CFSTR("bytePumpStats"), v21, v22);
        goto LABEL_21;
      }
      v13 = 0;
LABEL_26:
      v25 = *(_QWORD *)(a1 + 9048);
      if (v25)
      {
        v26 = *(void (**)(uint64_t, __CFString *, __CFString *, BOOL))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                               + 32);
        if (v26)
          v26(v25, CFSTR("bytePumpStats"), CFSTR("AppleCDNMissCount"), v13 == 0);
      }
      FigReportingAgentStatsUpdateSampleValueWithBool(*(_QWORD *)(a1 + 9048), 0x1E301B658, 0x1E2FFAB58, v13 == 0);
      v27 = *(_QWORD *)(a1 + 9048);
      if (v27)
      {
        v28 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                              + 16)
                                                                                  + 32);
        if (v28)
          v28(v27, CFSTR("bytePumpStats"), CFSTR("AppleCDNTotalCount"), 1);
      }
      CFRelease(v7);
    }
    else
    {
      v10 = (const __CFArray *)v7;
    }
    CFRelease(v10);
  }
  v29 = (_BYTE *)(a1 + 9064);
  v30 = message;
  v45 = 0;
  if (!*(_QWORD *)(a1 + 9088))
  {
    v31 = (const __CFAllocator *)FigGetAllocatorForMedia();
    Mutable = CFArrayCreateMutable(v31, 0, MEMORY[0x1E0C9B378]);
    *(_QWORD *)(a1 + 9088) = Mutable;
    if (!Mutable)
    {
      FigSignalErrorAt();
      goto LABEL_48;
    }
  }
  if (FigCFHTTPCreateRTCReportingAppleCDNVIAEdgeDomainString(v30, (CFStringRef *)&v45))
  {
LABEL_48:
    v40 = v45;
    goto LABEL_49;
  }
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 9088)) < 6)
  {
    v33 = v45;
    v46.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 9088));
    v46.location = 0;
    if (!CFArrayContainsValue(*(CFArrayRef *)(a1 + 9088), v46, v33))
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 9088), v33);
    v34 = (const __CFAllocator *)FigGetAllocatorForMedia();
    v35 = CFStringCreateByCombiningStrings(v34, *(CFArrayRef *)(a1 + 9088), CFSTR(","));
    if (v35)
    {
      v36 = v35;
      v37 = *(_QWORD *)(a1 + 9048);
      if (v37)
      {
        v38 = *(void (**)(uint64_t, __CFString *, __CFString *, CFStringRef, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                              + 48);
        if (v38)
          v38(v37, CFSTR("bytePumpStats"), CFSTR("VIAEdgeArr"), v36, 0);
      }
      CFRelease(v36);
    }
  }
  v39 = *(_QWORD *)(a1 + 9048);
  v40 = v45;
  if (v39)
  {
    v41 = *(void (**)(uint64_t, __CFString *, __CFString *, CFTypeRef, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                        + 48);
    if (v41)
      v41(v39, CFSTR("bytePumpStats"), CFSTR("LastVIAEdge"), v40, 0);
    goto LABEL_48;
  }
LABEL_49:
  if (v40)
    CFRelease(v40);
  v42 = message;
  v43 = *(_DWORD *)(a1 + 9068);
  if (!*(_BYTE *)(a1 + 9112))
  {
    if (v43 != 2)
      goto LABEL_54;
    goto LABEL_53;
  }
  if (v43)
  {
LABEL_53:
    segPumpRTCReportingLogAndUpdateStats(a1, message, CFSTR("Via"), 0x1E301D698);
    segPumpRTCReportingLogAndUpdateStats(a1, v42, CFSTR("Age"), 0x1E2FFAA38);
    segPumpRTCReportingLogAndUpdateStats(a1, v42, CFSTR("x-amz-request-id"), 0x1E2FFAA58);
    segPumpRTCReportingLogAndUpdateStats(a1, v42, CFSTR("apple-timing-app"), 0x1E2FFAA78);
    segPumpRTCReportingLogAndUpdateStats(a1, v42, CFSTR("CDN-Server"), 0x1E301D9B8);
    v42 = message;
  }
LABEL_54:
  if (!*v29)
  {
    segPumpRTCReportingLogAndUpdateStats(a1, v42, CFSTR("Via"), 0x1E301D698);
    segPumpRTCReportingLogAndUpdateStats(a1, message, CFSTR("CDN-Server"), 0x1E301D9B8);
    *v29 = 1;
    v42 = message;
  }
  if (v42)
    CFRelease(v42);
}

uint64_t segPumpUpdateNetworkCostIsExpensive(uint64_t result)
{
  uint64_t v1;
  int v2;
  uint64_t (*v3)(uint64_t, __CFString *, uint64_t);
  uint64_t v4;

  v1 = *(_QWORD *)(result + 8472);
  if (v1)
  {
    v2 = *(unsigned __int8 *)(result + 8468);
    result = CMBaseObjectGetVTable();
    v3 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t))(*(_QWORD *)(result + 8) + 56);
    if (v3)
    {
      if (v2)
        v4 = *MEMORY[0x1E0C9AE50];
      else
        v4 = *MEMORY[0x1E0C9AE40];
      return v3(v1, CFSTR("FNCM_ConnectionExpensive"), v4);
    }
  }
  return result;
}

uint64_t segPumpHandleMediaFileData(uint64_t a1, uint64_t a2, uint64_t a3, size_t a4, int64_t a5, uint64_t a6, char a7, uint64_t a8)
{
  uint64_t UpTimeNanoseconds;
  uint64_t DerivedStorage;
  const void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const void *v25;
  uint64_t v26;
  __int128 v27;
  uint64_t StartOffset;
  uint64_t v29;
  uint64_t v30;
  int64_t v31;
  int64_t v32;
  _QWORD *v33;
  size_t DataLength;
  _BOOL4 v35;
  _BOOL4 v36;
  uint64_t v37;
  unsigned int (*v38)(uint64_t, _OWORD *, _BYTE *, _QWORD, double *, uint64_t *, uint64_t *, os_log_type_t *, char *, uint64_t *, int *, _QWORD, _QWORD);
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  char v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  int v48;
  _BOOL4 v49;
  double TimeInSeconds;
  unint64_t v51;
  double v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  int DeclaredPeakBitRate;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v60;
  unsigned int v61;
  const __CFString *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t *i;
  int v67;
  int v68;
  _BYTE *v69;
  _BOOL4 v70;
  _QWORD *v71;
  const void *v72;
  uint64_t v73;
  uint64_t v74;
  double ElapsedTimeForConnectionOnMedia;
  uint64_t v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  const void *ContentKeySpecifier;
  uint64_t CryptKeyCommonData;
  _BOOL4 v83;
  int v84;
  uint64_t v85;
  const void *v86;
  CFTypeRef *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  size_t v97;
  uint64_t v98;
  const void *v99;
  const void *v100;
  _BOOL4 v101;
  uint64_t v102;
  _QWORD *v103;
  int v104;
  uint64_t appended;
  uint64_t v106;
  size_t v107;
  uint64_t v108;
  char v109;
  uint64_t v110;
  const void *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  CFTypeRef *v115;
  const void *v116;
  uint64_t v117;
  BOOL v118;
  uint64_t v119;
  double *v120;
  uint64_t v121;
  void (*v122)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v123;
  double *v124;
  double v125;
  void (*v126)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v127;
  _QWORD *v128;
  unint64_t v129;
  void (*v130)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v131;
  _QWORD *v132;
  unint64_t v133;
  void (*v134)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v135;
  _QWORD *v136;
  unint64_t v137;
  void (*v138)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v139;
  _QWORD *v140;
  unint64_t v141;
  void (*v142)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v143;
  _QWORD *v144;
  unint64_t v145;
  void (*v146)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v147;
  _QWORD *v148;
  unint64_t v149;
  void (*v150)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v151;
  uint64_t v152;
  void (*v153)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v154;
  double v155;
  double v156;
  void (*v157)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v158;
  _QWORD *v159;
  uint64_t v160;
  void (*v161)(uint64_t, __CFString *, __CFString *, uint64_t);
  int v162;
  uint64_t v163;
  uint64_t v164;
  void (*v165)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v166;
  _QWORD *v167;
  uint64_t v168;
  void (*v169)(uint64_t, __CFString *, __CFString *, uint64_t);
  double *v170;
  uint64_t v171;
  uint64_t v172;
  double v173;
  void (*v174)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v175;
  void (*v176)(uint64_t, __CFString *, __CFString *, unint64_t);
  double *v177;
  double v178;
  void (*v179)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v180;
  _QWORD *v181;
  unint64_t v182;
  void (*v183)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v184;
  _QWORD *v185;
  unint64_t v186;
  void (*v187)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v188;
  _QWORD *v189;
  unint64_t v190;
  void (*v191)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v192;
  _QWORD *v193;
  unint64_t v194;
  void (*v195)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v196;
  _QWORD *v197;
  unint64_t v198;
  void (*v199)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v200;
  _QWORD *v201;
  unint64_t v202;
  void (*v203)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v204;
  uint64_t v205;
  void (*v206)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v207;
  double v208;
  double v209;
  void (*v210)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v211;
  _QWORD *v212;
  uint64_t v213;
  void (*v214)(uint64_t, __CFString *, __CFString *, uint64_t);
  int v215;
  double v216;
  unint64_t v217;
  double v218;
  uint64_t v219;
  uint64_t v220;
  void (*v221)(uint64_t, __CFString *, __CFString *, uint64_t);
  unsigned __int8 *v222;
  uint64_t v223;
  void (*v224)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  _BOOL4 v225;
  uint64_t v226;
  _QWORD *v227;
  uint64_t v228;
  void (*v229)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v230;
  uint64_t v231;
  double v232;
  void (*v233)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v234;
  unint64_t v235;
  void (*v236)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v237;
  int v238;
  uint64_t v239;
  int v240;
  void (*v241)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD);
  uint64_t v242;
  uint64_t v243;
  void (*v244)(uint64_t, __CFString *, __CFString *, uint64_t);
  unsigned __int8 *v245;
  uint64_t v246;
  void (*v247)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v248;
  _QWORD *v249;
  uint64_t v250;
  void (*v251)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v252;
  void (*v253)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD);
  uint64_t v254;
  uint64_t v255;
  void (*v256)(uint64_t, __CFString *, __CFString *);
  uint64_t v257;
  void (*v258)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD);
  unsigned int v260;
  _BOOL4 v261;
  size_t v262;
  unint64_t v263;
  unint64_t v264;
  uint64_t v265;
  char v266;
  int v267;
  _BYTE *v268;
  _BOOL4 v269;
  int v270;
  uint64_t v271;
  uint64_t v272;
  double *MediaFilePrivateData;
  uint64_t v275;
  int v276;
  char v277;
  uint64_t v278;
  os_log_type_t type[8];
  uint64_t v280;
  uint64_t v281;
  double v282;
  _BYTE v283[12];
  __int16 v284;
  const __CFString *v285;
  __int16 v286;
  uint64_t v287;
  __int16 v288;
  unsigned int v289;
  __int16 v290;
  int v291;
  _OWORD v292[5];
  uint64_t v293;
  uint64_t v294;

  v294 = *MEMORY[0x1E0C80C00];
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v272 = *(_QWORD *)(a2 + 880);
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v17 = *(const void **)(a3 + 8);
  if (v17)
    MediaFilePrivateData = (double *)segPumpGetMediaFilePrivateData(*(const void **)(a3 + 8));
  else
    MediaFilePrivateData = 0;
  v18 = *(_QWORD *)(a3 + 64);
  if (v18)
  {
    if ((_DWORD)a8)
      goto LABEL_6;
  }
  else
  {
    v24 = UpTimeNanoseconds - *(_QWORD *)(a3 + 40);
    *(_QWORD *)(a3 + 64) = UpTimeNanoseconds;
    *(_QWORD *)(a3 + 72) = v24;
    v18 = UpTimeNanoseconds;
    if ((_DWORD)a8)
    {
LABEL_6:
      v19 = *(_QWORD *)(a2 + 776);
      if (v19 >= 1)
      {
        v20 = 0;
        while (*(_QWORD *)(*(_QWORD *)(a2 + 768) + 8 * v20) != a3)
        {
          if (v19 == ++v20)
            goto LABEL_10;
        }
        segPumpStreamCancelReadAheadAndResetDataAtIndex(DerivedStorage, a2, v20);
        goto LABEL_44;
      }
LABEL_10:
      if (*(_QWORD *)(a2 + 792) == a3)
      {
        segPumpStreamCancelPreloadReadAndResetData(DerivedStorage, a2);
      }
      else if (*(_QWORD *)(a2 + 800) == a3)
      {
        segPumpStreamCancelPreloadMapReadAndResetData(DerivedStorage, a2);
      }
      else
      {
        v21 = *(_QWORD *)(a3 + 8);
        if (v21)
        {
          v22 = segPumpHandleMediaFileNetworkError(a1, (_QWORD *)a2, a3 + 16, v21, a8);
          if ((_DWORD)v22)
            return v22;
        }
      }
LABEL_44:
      FigHTTPStopAndReleaseTimer((dispatch_object_t *)(a3 + 112));
      return 0;
    }
  }
  v25 = *(const void **)(a2 + 296);
  if (v25)
  {
    CFRelease(v25);
    *(_QWORD *)(a2 + 296) = 0;
    v18 = *(_QWORD *)(a3 + 64);
  }
  v265 = v18;
  v263 = *(_QWORD *)(a3 + 40);
  v264 = *(_QWORD *)(a3 + 72);
  v275 = DerivedStorage;
  if (!v17)
  {
    *(_QWORD *)(a3 + 224) += a5;
    v33 = (_QWORD *)(a3 + 136);
    v32 = a5;
LABEL_38:
    *v33 += a5;
    a5 = v32;
    goto LABEL_39;
  }
  if (!*(_BYTE *)(a3 + 280))
  {
    *(_BYTE *)(a3 + 280) = 1;
    if (!*(_QWORD *)(a3 + 256))
    {
      if (!FigMediaSegmentSpecifierGetBytesToRead((uint64_t)v17))
      {
        *((_QWORD *)MediaFilePrivateData + 5) += a6;
        *(_QWORD *)(DerivedStorage + 8904) = 0;
        v26 = MEMORY[0x1E0CA2E40];
        v27 = *(_OWORD *)(MEMORY[0x1E0CA2E40] + 16);
        *(_OWORD *)(DerivedStorage + 8912) = *MEMORY[0x1E0CA2E40];
        *(_OWORD *)(DerivedStorage + 8928) = v27;
        *(_OWORD *)(DerivedStorage + 8944) = *(_OWORD *)(v26 + 32);
      }
      *(_QWORD *)(a3 + 256) = a6;
    }
  }
  *(_QWORD *)(a3 + 224) += a5;
  if (*(_QWORD *)(DerivedStorage + 296)
    && *(_QWORD *)(a2 + 64)
    && FigMediaSegmentSpecifierGetType((uint64_t)v17) != 1
    && !*((_QWORD *)MediaFilePrivateData + 13)
    && segPumpCanAddSegmentToCache((uint64_t *)DerivedStorage, (_QWORD *)a2, v17, 0))
  {
    segPumpCreateMediaSegmentCache(DerivedStorage, a2, v17);
  }
  *(_QWORD *)(a3 + 136) += a5;
  if (*(uint64_t *)(a3 + 304) >= 1)
  {
    StartOffset = FigMediaSegmentSpecifierGetStartOffset(*(_QWORD *)(a3 + 8));
    v29 = *(_QWORD *)(a3 + 304) + *(_QWORD *)(a3 + 240);
    if (StartOffset <= v29)
    {
      DerivedStorage = v275;
      if ((a7 & 1) != 0)
        goto LABEL_46;
      goto LABEL_40;
    }
    v30 = FigMediaSegmentSpecifierGetStartOffset(*(_QWORD *)(a3 + 8));
    v31 = a5;
    if (v30 - v29 < (unint64_t)a5)
      v31 = FigMediaSegmentSpecifierGetStartOffset(*(_QWORD *)(a3 + 8)) - v29;
    a4 += v31;
    v32 = a5 - v31;
    *(_QWORD *)(a3 + 304) += v31;
    v33 = (_QWORD *)(a3 + 216);
    a5 = v31;
    DerivedStorage = v275;
    goto LABEL_38;
  }
LABEL_39:
  if ((a7 & 1) != 0)
    goto LABEL_46;
LABEL_40:
  DataLength = CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(a3 + 272));
  if (!segPumpReadCompletesMediaRange(v17, DataLength + a5))
  {
    v35 = 0;
    v266 = a7;
    v267 = 1;
    if ((a7 & 1) != 0)
      goto LABEL_48;
    goto LABEL_47;
  }
LABEL_46:
  v266 = a7 | 1;
  v267 = 0;
  v35 = 1;
  if ((a7 & 1) != 0)
    goto LABEL_48;
LABEL_47:
  if (a5 < 1)
    goto LABEL_460;
LABEL_48:
  if (!*(_QWORD *)(a3 + 232))
    *(_QWORD *)(a3 + 232) = a5;
  *(_QWORD *)(a3 + 216) += a5;
  if ((a7 & 1) != 0)
    *(_QWORD *)(a3 + 56) = UpTimeNanoseconds;
  if (v17)
    v36 = v35;
  else
    v36 = 0;
  v269 = v36;
  v271 = a1;
  if (v36)
  {
    *(_QWORD *)&v292[0] = 0;
    v282 = 0.0;
    *(_QWORD *)v283 = 0;
    v280 = 0;
    v281 = 0;
    v278 = 0;
    *(_QWORD *)type = 0;
    v277 = 0;
    v276 = 0;
    v37 = *(_QWORD *)(a3 + 32);
    if (v37)
    {
      v38 = *(unsigned int (**)(uint64_t, _OWORD *, _BYTE *, _QWORD, double *, uint64_t *, uint64_t *, os_log_type_t *, char *, uint64_t *, int *, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 40);
      if (v38)
      {
        if (!v38(v37, v292, v283, 0, &v282, &v281, &v280, type, &v277, &v278, &v276, 0, 0))
        {
          v39 = *(_QWORD *)v283;
          MediaFilePrivateData[17] = *(double *)v292;
          *((_QWORD *)MediaFilePrivateData + 18) = v39;
          v40 = v281;
          MediaFilePrivateData[19] = v282;
          *((_QWORD *)MediaFilePrivateData + 20) = v40;
          v41 = *(_QWORD *)type;
          *((_QWORD *)MediaFilePrivateData + 21) = v280;
          *((_QWORD *)MediaFilePrivateData + 22) = v41;
          *((_BYTE *)MediaFilePrivateData + 184) = v277;
          *((_QWORD *)MediaFilePrivateData + 24) = v278;
          *((_DWORD *)MediaFilePrivateData + 50) = v276;
        }
      }
    }
  }
  else if (!v17)
  {
    goto LABEL_116;
  }
  v42 = FigMediaSegmentSpecifierGetType((uint64_t)v17);
  v43 = !v35;
  if (v42)
    v43 = 1;
  if ((v43 & 1) == 0)
  {
    v261 = v35;
    v44 = *((_QWORD *)MediaFilePrivateData + 6) + a5;
    v45 = CMBaseObjectGetDerivedStorage();
    v260 = segPumpStreamBitRateRequiredForStream(v45, (_QWORD *)a2);
    if (v44 >= 1 && FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v17) > 0.5)
    {
      v46 = (uint64_t)((double)(8 * v44) / FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v17));
      *(double *)(a2 + 1088) = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v17) + *(double *)(a2 + 1088);
      v47 = *(_DWORD *)(a2 + 1080);
      v48 = v47 ? (9 * v47 + (int)v46) / 0xAu : v46;
      *(_DWORD *)(a2 + 1080) = v48;
      *(_DWORD *)(a2 + 1084) = v46;
      if (*(_QWORD *)(v45 + 8144))
      {
        if (*(_QWORD *)(v45 + 7680))
          v49 = *(_QWORD *)(v45 + 16 * *(_QWORD *)a2 + 392) == a2;
        else
          v49 = 0;
        TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v17);
        LODWORD(v51) = *(_DWORD *)(v45 + 8);
        v52 = (double)v51;
        if (TimeInSeconds >= (double)v51)
        {
          v54 = 0;
          v53 = 0;
          while (1)
          {
            if (*(_QWORD *)(*(_QWORD *)(v45 + v54 + 384) + 16))
            {
              if (!v49 || (v55 = *(_QWORD *)(v45 + v54 + 392)) == 0)
                v55 = *(_QWORD *)(v45 + v54 + 384);
              v56 = *(_DWORD *)(v55 + 1084);
              if (!v56)
                goto LABEL_115;
              v53 += v56;
            }
            v54 += 16;
            if (v54 == 48)
              goto LABEL_86;
          }
        }
        LODWORD(v281) = 0;
        v282 = 0.0;
        if (segPumpGetAverageEstimatedMediaBitrate(v45, v49, &v281, &v282) && v282 > v52)
        {
          v53 = v281;
LABEL_86:
          if (v53 > v260)
          {
            if (!*(_BYTE *)(v45 + 8006))
            {
              DeclaredPeakBitRate = FigAlternateGetDeclaredPeakBitRate(*(_QWORD *)(*(_QWORD *)(v45 + 8144) + 8));
              if (DeclaredPeakBitRate && DeclaredPeakBitRate / 10 + DeclaredPeakBitRate < v53)
              {
                segPumpAppendErrorLogEntry(v271, v45, a2, (const __CFURL **)(*(_QWORD *)(a2 + 696) + 16), -12318, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Segment exceeds specified bandwidth for variant"), 0, 0, 2u, 3u);
                *(_BYTE *)(v45 + 8006) = 1;
              }
            }
            LODWORD(v280) = 0;
            type[0] = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            v60 = v280;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0]))
              v61 = v60;
            else
              v61 = v60 & 0xFFFFFFFE;
            if (v61)
            {
              v62 = *(const __CFString **)(v45 + 8760);
              if (!v62)
                v62 = &stru_1E2FD85F8;
              if (a2)
                v63 = *(_QWORD *)a2;
              else
                v63 = -1;
              *(_DWORD *)v283 = 136316162;
              *(_QWORD *)&v283[4] = "segPumpVerifyMediaBitrateIsBelowAlternatePeakBitrate";
              v284 = 2114;
              v285 = v62;
              v286 = 2048;
              v287 = v63;
              v288 = 1024;
              v289 = v260;
              v290 = 1024;
              v291 = v53;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
            v64 = 8144;
            if (v49)
              v64 = 7680;
            v65 = *(_QWORD *)(v45 + v64);
            *(_DWORD *)(v65 + 24) = v53;
            FigAlternateSetPeakBitRate(*(_QWORD *)(v65 + 8), v53);
            for (i = *(uint64_t **)(v45 + 8096); i; i = (uint64_t *)*i)
            {
              if (i != (uint64_t *)v65)
              {
                v67 = *(_DWORD *)(v65 + 28);
                v68 = *((_DWORD *)i + 7) - v67;
                if (v68 < 0)
                  v68 = v67 - *((_DWORD *)i + 7);
                if ((double)v68 / (double)v67 <= 0.01)
                {
                  *((_DWORD *)i + 6) = v53;
                  FigAlternateSetPeakBitRate(i[1], v53);
                }
              }
            }
            segPumpReadyNotification((_QWORD *)v45, CFSTR("FBPAL_AlternateListChanged"), 0);
            segPumpInitAlternateSelectionBoss(v271, v45);
          }
        }
      }
    }
LABEL_115:
    DerivedStorage = v275;
    v35 = v261;
  }
LABEL_116:
  v69 = (_BYTE *)(DerivedStorage + 8007);
  *(_QWORD *)(DerivedStorage + 8536) += a5;
  *(_QWORD *)(a2 + 1096) += a5;
  if (*(_QWORD *)a2 == 1)
  {
    v71 = (_QWORD *)(DerivedStorage + 8640);
    v70 = v269;
    goto LABEL_120;
  }
  v70 = v269;
  if (!*(_QWORD *)a2)
  {
    v71 = (_QWORD *)(DerivedStorage + 8632);
LABEL_120:
    *v71 += a5;
  }
  if ((a7 & 1) != 0)
  {
    *(_QWORD *)(a3 + 104) = 0;
    FigHTTPStopAndReleaseTimer((dispatch_object_t *)(a3 + 112));
    *(_DWORD *)(a3 + 80) = 0;
    v72 = *(const void **)(a3 + 88);
    if (v72)
    {
      CFRelease(v72);
      *(_QWORD *)(a3 + 88) = 0;
    }
    if (*(_BYTE *)(DerivedStorage + 8712))
    {
      v73 = 8840;
      if (UpTimeNanoseconds > *(_QWORD *)(a3 + 288))
        v73 = 8848;
      ++*(_QWORD *)(DerivedStorage + v73);
    }
    *(_QWORD *)(a3 + 288) = 0x7FFFFFFFFFFFFFFFLL;
    v74 = *(_QWORD *)(a3 + 32);
    if (v74)
    {
      if (!*(_BYTE *)(a3 + 145)
        || (segPumpStreamDontReuseHTTPRequest(DerivedStorage, a3), (v74 = *(_QWORD *)(a3 + 32)) != 0))
      {
        *(_QWORD *)(a3 + 152) = *(_QWORD *)(a3 + 24);
        *(_QWORD *)(a3 + 160) = v74;
        *(_QWORD *)(a3 + 104) = 0;
        *(_QWORD *)(a3 + 24) = 0;
        *(_QWORD *)(a3 + 32) = 0;
        ++*(_QWORD *)(a3 + 192);
      }
    }
  }
  if (v70
    && !*(_BYTE *)(DerivedStorage + 8712)
    && !*(_BYTE *)(a2 + 873)
    && !FigMediaSegmentSpecifierGetType((uint64_t)v17)
    && !segPumpStreamHasPreloadConnectionForSegment((_QWORD *)a2, v17, 1))
  {
    ElapsedTimeForConnectionOnMedia = segPumpGetElapsedTimeForConnectionOnMedia(a2, a3);
    if (ElapsedTimeForConnectionOnMedia <= FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v17))
    {
      if (*(_BYTE *)(a2 + 874))
      {
        v76 = *(_QWORD *)(a2 + 752);
        if (v76 < 1)
          goto LABEL_147;
        v77 = a2 + 696;
        v78 = 1;
        do
        {
          if (*(_QWORD *)v77 && *(_QWORD *)(*(_QWORD *)v77 + 32))
            v78 = 0;
          v77 += 8;
          --v76;
        }
        while (v76);
        if (v78)
LABEL_147:
          *(_BYTE *)(a2 + 874) = 0;
      }
    }
    else
    {
      segPumpSetCurrentSegmentTooSlow((_QWORD *)DerivedStorage, a2);
    }
  }
  if (segPumpShouldDoSegmentReadAheads((_BYTE *)DerivedStorage))
  {
    v79 = *(_QWORD *)(a2 + 776);
    if (v79 >= 1)
    {
      v80 = *(_QWORD *)(a2 + 768);
      do
      {
        if (*(_QWORD *)v80)
          *(_QWORD *)(*(_QWORD *)v80 + 40) = UpTimeNanoseconds;
        v80 += 8;
        --v79;
      }
      while (v79);
    }
  }
  if (!v17
    || !FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v17)
    || *(const void **)(a2 + 256) != v17 && *(const void **)(a2 + 264) != v17)
  {
    goto LABEL_160;
  }
  *(_QWORD *)&v292[0] = 0;
  *(_QWORD *)v283 = 0;
  ContentKeySpecifier = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v17);
  CryptKeyCommonData = segPumpGetCryptKeyCommonData(ContentKeySpecifier, v292, v283);
  if ((_DWORD)CryptKeyCommonData)
    goto LABEL_458;
  if (*(_BYTE *)(*(_QWORD *)v283 + 144))
    goto LABEL_160;
  if (!*(_QWORD *)(DerivedStorage + 9592))
    *(_QWORD *)(DerivedStorage + 9592) = FigGetUpTimeNanoseconds();
  v112 = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v17);
  if (FigContentKeySpecifierGetEncryptionMethod(v112) - 3 < 0xFFFFFFFE
    || FigMediaSegmentSpecifierGetType((uint64_t)v17) != 1)
  {
    v118 = *(_BYTE *)(DerivedStorage + 322) == 0;
    v83 = *(_BYTE *)(DerivedStorage + 322) != 0;
    v84 = v267;
    if (v118)
      v84 = 1;
  }
  else
  {
LABEL_160:
    v83 = 0;
    v84 = 1;
  }
  v270 = v84;
  if (v69[705] || *(_QWORD *)(a2 + 696) != a3)
    v83 = 1;
  if (!v267)
  {
LABEL_170:
    if (!v17)
      goto LABEL_182;
    goto LABEL_171;
  }
  if ((a7 & 1) == 0 || (v85 = *(_QWORD *)(a2 + 696)) != 0 && (*(_QWORD *)(v85 + 32) || *(_QWORD *)(v85 + 104)))
  {
    v35 = 0;
    goto LABEL_170;
  }
  v35 = *(_QWORD *)(a2 + 704) == 0;
  if (!v17)
    goto LABEL_182;
LABEL_171:
  if (v35)
  {
    if (FigMediaSegmentSpecifierGetType((uint64_t)v17) != 1)
    {
      v86 = *(const void **)(a3 + 8);
      if (v86)
      {
        if (*((_QWORD *)segPumpGetMediaFilePrivateData(v86) + 2))
        {
          v87 = (CFTypeRef *)segPumpGetMediaFilePrivateData(*(const void **)(a3 + 8));
          CFRelease(v87[2]);
          *((_QWORD *)segPumpGetMediaFilePrivateData(*(const void **)(a3 + 8)) + 2) = 0;
        }
      }
    }
    v88 = 64;
    if (!*(_BYTE *)(a3 + 281))
      v88 = 40;
    v89 = *(_QWORD *)(a3 + v88);
    if (*(uint64_t *)(a3 + 296) <= 0)
      v90 = v89;
    else
      v90 = *(_QWORD *)(a3 + 296);
    MediaFilePrivateData[10] = *(double *)(a2 + 808) + (double)(FigGetUpTimeNanoseconds() - v90) / 1000000000.0;
  }
LABEL_182:
  if (v17 && !v83)
  {
    v268 = v69;
    v91 = *(_QWORD *)(a3 + 8);
    if (v91)
    {
      v92 = v35;
      if (FigMediaSegmentSpecifierGetBytesToRead(v91))
      {
        v93 = *(_QWORD *)(a3 + 240);
        v94 = *(_QWORD *)(a3 + 216);
        v95 = FigMediaSegmentSpecifierGetStartOffset(*(_QWORD *)(a3 + 8));
        v96 = FigMediaSegmentSpecifierGetBytesToRead(*(_QWORD *)(a3 + 8));
        v97 = (v94 + v93 - (v95 + v96)) & ~((v94 + v93 - (v95 + v96)) >> 63);
        goto LABEL_206;
      }
    }
    else
    {
      v92 = v35;
    }
    v97 = 0;
LABEL_206:
    v104 = segPumpAccumConnCompletesMediaRange(a3, v17);
    if (!v104 || (appended = segPumpAppendBytesToMediaConnectionBuffer(a3, a4, a5), !(_DWORD)appended))
    {
      appended = segPumpDeliverAccumulatedBuffer(v271, v275, a2, a3, v17, v104);
      if (!(_DWORD)appended)
      {
        if (FigRetainProxyIsInvalidated() || v272 != *(_QWORD *)(a2 + 880))
        {
          v23 = 0;
          goto LABEL_462;
        }
        if (v104)
        {
          v101 = 0;
          DerivedStorage = v275;
          v35 = v92;
          v69 = v268;
          if ((a7 & 1) == 0)
            goto LABEL_281;
          goto LABEL_242;
        }
        v106 = a5 - v97;
        v107 = (a5 - v97) & ~((uint64_t)(a5 - v97) >> 63);
        if ((a7 & 1) != 0)
        {
          v108 = *(_QWORD *)(a2 + 704);
          if (v108)
          {
            v109 = v266;
            if (*(_QWORD *)(a3 + 8) == *(_QWORD *)(v108 + 8))
              v109 = v266 & 0xFE;
            v266 = v109;
          }
        }
        if (!*((_QWORD *)MediaFilePrivateData + 13)
          || (appended = segPumpAppendBytesToCache(v275, a2, v17, *(OpaqueCMBlockBuffer **)(a3 + 128), a4, v107, v92),
              !(_DWORD)appended))
        {
          v262 = v107;
          v110 = *(_QWORD *)(a3 + 8);
          if (*(_QWORD *)(a2 + 256) == v110 || *(_QWORD *)(a2 + 264) == v110)
          {
            v101 = *(_BYTE *)(a2 + 404) != 0;
            if (!v97)
              goto LABEL_232;
          }
          else
          {
            v101 = 0;
            if (!v97)
            {
LABEL_232:
              v35 = v92;
              if (v270 && v92)
              {
                v111 = *(const void **)(a3 + 8);
                v69 = v268;
                if (v111)
                {
                  CFRelease(v111);
                  *(_QWORD *)(a3 + 8) = 0;
                }
              }
              else
              {
                v69 = v268;
                if (!v35)
                {
LABEL_238:
                  if (v101 && (v106 > 0 || (v266 & 1) != 0))
                  {
                    DerivedStorage = v275;
                    if (FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v17) && *(_BYTE *)(v275 + 322))
                    {
                      v113 = segPumpMediaFileHandleCryptData(v271, v275, a2, v17, *(OpaqueCMBlockBuffer **)(a3 + 128), a4, v262, v266, 0);
                      if ((_DWORD)v113 == -12465)
                      {
                        CryptKeyCommonData = segPumpHandleMediaFileNetworkError(v271, (_QWORD *)a2, 0, (uint64_t)v17, 4294954831);
                        goto LABEL_458;
                      }
                      v23 = v113;
                      if ((_DWORD)v113 == -12463)
                      {
                        CryptKeyCommonData = segPumpHandleCryptFailure(v271, v275, a2);
                        goto LABEL_458;
                      }
                    }
                    else
                    {
                      v23 = segPumpSendMediaCallback(v271, v275, a2, v17, *(OpaqueCMBlockBuffer **)(a3 + 128), a4, v262, v266, 0);
                    }
                    if ((_DWORD)v23)
                      goto LABEL_453;
                    if (FigRetainProxyIsInvalidated()
                      || v272 != *(_QWORD *)(a2 + 880)
                      || *(const void **)(a2 + 256) != v17 && *(const void **)(a2 + 264) != v17)
                    {
                      goto LABEL_460;
                    }
                    v101 = 1;
                    if ((a7 & 1) == 0)
                      goto LABEL_281;
                  }
                  else
                  {
                    DerivedStorage = v275;
                    *((_QWORD *)MediaFilePrivateData + 6) += v262;
                    if ((a7 & 1) == 0)
                      goto LABEL_281;
                  }
LABEL_242:
                  if (*(_QWORD *)(a2 + 704))
                  {
                    CryptKeyCommonData = segPumpMoveToNextParallelConnection(v271, DerivedStorage, a2);
                    if (!(_DWORD)CryptKeyCommonData)
                    {
                      if (!FigRetainProxyIsInvalidated())
                      {
                        v23 = 0;
                        if (v272 != *(_QWORD *)(a2 + 880))
                          goto LABEL_453;
                        goto LABEL_282;
                      }
                      goto LABEL_460;
                    }
                    goto LABEL_458;
                  }
LABEL_281:
                  v23 = 0;
                  goto LABEL_282;
                }
              }
              v98 = segPumpStreamUnchainMediaConnIfChaining(v271, (_QWORD *)a2, (_QWORD *)a3);
              if (!(_DWORD)v98)
                goto LABEL_238;
LABEL_463:
              v23 = v98;
LABEL_397:
              DerivedStorage = v275;
              goto LABEL_453;
            }
          }
          appended = segPumpAppendBytesToMediaConnectionBuffer(a3, v262 + a4, v97);
          if (!(_DWORD)appended)
            goto LABEL_232;
        }
      }
    }
    v23 = appended;
LABEL_462:
    DerivedStorage = v275;
    v35 = v92;
    goto LABEL_453;
  }
  v98 = segPumpAppendBytesToMediaConnectionBuffer(a3, a4, a5);
  if ((_DWORD)v98)
    goto LABEL_463;
  DerivedStorage = v275;
  if ((a7 & 1) != 0 && v17 && v69[705] && v270 && *(_QWORD *)(a2 + 696) == a3)
  {
    v99 = *(const void **)(a3 + 8);
    if (v99)
    {
      if (FigMediaSegmentSpecifierGetType(*(_QWORD *)(a3 + 8)) == 1)
        goto LABEL_267;
      v100 = *(const void **)(a3 + 8);
    }
    else
    {
      v100 = 0;
    }
    if (*((_QWORD *)segPumpGetMediaFilePrivateData(v100) + 2))
    {
      v115 = (CFTypeRef *)segPumpGetMediaFilePrivateData(*(const void **)(a3 + 8));
      CFRelease(v115[2]);
      *((_QWORD *)segPumpGetMediaFilePrivateData(*(const void **)(a3 + 8)) + 2) = 0;
    }
LABEL_267:
    v116 = *(const void **)(a3 + 8);
    if (v116)
    {
      CFRelease(v116);
      *(_QWORD *)(a3 + 8) = 0;
    }
    CryptKeyCommonData = segPumpDeliverAccumulatedBuffer(v271, v275, a2, a3, v17, 1);
    if (!(_DWORD)CryptKeyCommonData)
    {
      if (!FigRetainProxyIsInvalidated())
      {
        v23 = 0;
        if (v99 != v17 || v272 != *(_QWORD *)(a2 + 880))
          goto LABEL_453;
        v270 = 1;
        v101 = 1;
LABEL_282:
        if (v35)
        {
LABEL_288:
          if (!v17)
            goto LABEL_294;
LABEL_289:
          v118 = v35 && v69[705] == 0;
          if (!v118 && (a7 & (v69[705] != 0)) == 0)
            goto LABEL_294;
          if (FigMediaSegmentSpecifierGetType((uint64_t)v17))
          {
LABEL_451:
            v23 = segPumpStreamProceedAfterMediaAndKeyArrival(v271, DerivedStorage, a2, v17, v101, v270);
            if (!(_DWORD)v23)
              FigRetainProxyIsInvalidated();
            goto LABEL_453;
          }
          v283[0] = 0;
          if (!segPumpIsConnectedWithHighSpeedHighPower(DerivedStorage, v283))
          {
            v163 = *(_QWORD *)(v275 + 9048);
            v164 = v283[0];
            if (v163)
            {
              v165 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                 + 56);
              if (v165)
                v165(v163, CFSTR("bytePumpStats"), CFSTR("HSHP"), v164, 0);
            }
            if ((_DWORD)v164)
            {
              v166 = *(_QWORD *)(v275 + 9048);
              v167 = segPumpGetMediaFilePrivateData(v17);
              if (v166)
              {
                v168 = v167[5];
                v169 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                           + 32);
                if (v169)
                  v169(v166, CFSTR("bytePumpStats"), CFSTR("HSHPBytes"), v168);
              }
            }
          }
          if (*(_QWORD *)a2 != 1)
          {
            DerivedStorage = v275;
            if (*(_QWORD *)a2)
              goto LABEL_451;
            v120 = (double *)segPumpGetMediaFilePrivateData(v17);
            segPumpRTCReportingUpdateBandwidthStats(v275, a2, (uint64_t)(v120[10] * 1000000000.0));
            FigReportingAgentStatsUpdateSampleValueWithBool(*(_QWORD *)(v275 + 9048), 0x1E301B658, 0x1E2FFAA98, v264 / 0xF4240 > *(int *)(v275 + 7976));
            v121 = *(_QWORD *)(v275 + 9048);
            if (v121)
            {
              v122 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                  + 40);
              if (v122)
                v122(v121, CFSTR("bytePumpStats"), CFSTR("SegLatency"), v264 / 0xF4240);
              v123 = *(_QWORD *)(v275 + 9048);
            }
            else
            {
              v123 = 0;
            }
            v124 = (double *)segPumpGetMediaFilePrivateData(v17);
            if (v123)
            {
              v125 = v124[10];
              v126 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                         + 40);
              if (v126)
                v126(v123, CFSTR("bytePumpStats"), CFSTR("SDT"), (uint64_t)(v125 * 1000.0));
            }
            v127 = *(_QWORD *)(v275 + 9048);
            v128 = segPumpGetMediaFilePrivateData(v17);
            if (v127)
            {
              v129 = v128[17];
              v130 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                  + 40);
              if (v130)
                v130(v127, CFSTR("bytePumpStats"), CFSTR("DNSTime"), v129 / 0xF4240);
            }
            v131 = *(_QWORD *)(v275 + 9048);
            v132 = segPumpGetMediaFilePrivateData(v17);
            if (v131)
            {
              v133 = v132[18];
              v134 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                  + 40);
              if (v134)
                v134(v131, CFSTR("bytePumpStats"), CFSTR("TLSTime"), v133 / 0xF4240);
            }
            v135 = *(_QWORD *)(v275 + 9048);
            v136 = segPumpGetMediaFilePrivateData(v17);
            if (v135)
            {
              v137 = v136[19];
              v138 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                  + 40);
              if (v138)
                v138(v135, CFSTR("bytePumpStats"), CFSTR("ConnTime"), v137 / 0xF4240);
            }
            v139 = *(_QWORD *)(v275 + 9048);
            v140 = segPumpGetMediaFilePrivateData(v17);
            if (v139)
            {
              v141 = v140[21];
              v142 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                  + 40);
              if (v142)
                v142(v139, CFSTR("bytePumpStats"), CFSTR("ResponseTime"), v141 / 0xF4240);
            }
            v143 = *(_QWORD *)(v275 + 9048);
            v144 = segPumpGetMediaFilePrivateData(v17);
            if (v143)
            {
              v145 = v144[20];
              v146 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                  + 40);
              if (v146)
                v146(v143, CFSTR("bytePumpStats"), CFSTR("RequestTime"), v145 / 0xF4240);
            }
            v147 = *(_QWORD *)(v275 + 9048);
            v148 = segPumpGetMediaFilePrivateData(v17);
            if (v147)
            {
              v149 = v148[22];
              v150 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                  + 40);
              if (v150)
                v150(v147, CFSTR("bytePumpStats"), CFSTR("SchedulingDelay"), v149 / 0xF4240);
            }
            v151 = *(_QWORD *)(v275 + 9048);
            if (v151)
            {
              v152 = *(_QWORD *)(a2 + 1112);
              v153 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                 + 56);
              if (v153)
                v153(v151, CFSTR("bytePumpStats"), CFSTR("SegNumber"), v152 + 1, 0);
            }
            v154 = *(_QWORD *)(v275 + 9048);
            v155 = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v17);
            if (v154)
            {
              v156 = v155;
              v157 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                         + 40);
              if (v157)
                v157(v154, CFSTR("bytePumpStats"), CFSTR("AvgSegDur"), (uint64_t)(v156 * 1000.0));
            }
            v158 = *(_QWORD *)(v275 + 9048);
            v159 = segPumpGetMediaFilePrivateData(v17);
            if (v158)
            {
              v160 = v159[5];
              v161 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                         + 40);
              if (v161)
                v161(v158, CFSTR("bytePumpStats"), CFSTR("SS"), v160);
            }
            DerivedStorage = v275;
            v162 = *(_DWORD *)(v275 + 9068);
            if (v69[1105])
            {
              if (!v162)
              {
LABEL_418:
                if (!v69[5])
                  goto LABEL_451;
                v237 = *(_QWORD *)(DerivedStorage + 8144);
                if (v237)
                {
                  v238 = FigAlternateGetDeclaredPeakBitRate(*(_QWORD *)(v237 + 8));
                  if (!v238)
                  {
LABEL_446:
                    v257 = *(_QWORD *)(v275 + 9048);
                    if (v257)
                    {
                      v258 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
                      if (v258)
                        v258(v257, CFSTR("bytePumpStats"), CFSTR("SST"), v263 / 0xF4240, 0);
                    }
                    goto LABEL_449;
                  }
                  v239 = *(_QWORD *)(v275 + 9048);
                  if (v239)
                  {
                    v240 = v238;
                    v241 = *(void (**)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
                    if (v241)
                      v241(v239, CFSTR("bytePumpStats"), CFSTR("br"), v240 / 1000, 0);
                    goto LABEL_446;
                  }
                }
                else
                {
                  v255 = *(_QWORD *)(DerivedStorage + 9048);
                  if (v255)
                  {
                    v256 = *(void (**)(uint64_t, __CFString *, __CFString *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 64);
                    if (v256)
                      v256(v255, CFSTR("bytePumpStats"), CFSTR("br"));
                    goto LABEL_446;
                  }
                }
LABEL_449:
                v254 = 2001;
LABEL_450:
                DerivedStorage = v275;
                segPumpRTCReportingIssueRTCReportingEvent(v275, v254);
                goto LABEL_451;
              }
            }
            else if (v162 != 2)
            {
              goto LABEL_418;
            }
            if (!segPumpShouldIssueVerboseEvent(v275, a2, (uint64_t)v17))
              goto LABEL_418;
            *(_QWORD *)&v292[0] = 0;
            v219 = *(_QWORD *)(v275 + 9048);
            if (v219)
            {
              v220 = *(_QWORD *)(a2 + 752);
              v221 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                         + 40);
              if (v221)
                v221(v219, CFSTR("bytePumpStats"), CFSTR("PCC"), v220);
              v219 = *(_QWORD *)(v275 + 9048);
            }
            v222 = (unsigned __int8 *)segPumpGetMediaFilePrivateData(v17);
            if (v219)
            {
              v223 = v222[184];
              v224 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                 + 56);
              if (v224)
                v224(v219, CFSTR("bytePumpStats"), CFSTR("IsReusedConn"), v223, 0);
            }
            v225 = v35;
            v226 = *(_QWORD *)(v275 + 9048);
            v227 = segPumpGetMediaFilePrivateData(v17);
            if (v226)
            {
              v228 = v227[24];
              v229 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                 + 56);
              if (v229)
                v229(v226, CFSTR("bytePumpStats"), CFSTR("RedirectCount"), v228, 0);
            }
            FigSymptomsManagerTriggerScorecardsUpdate();
            if (!FigSymptomsManagerGetBandwidthPredictionFromLastUpdate(v292, 0))
            {
              v230 = v275;
              v231 = *(_QWORD *)(v275 + 9048);
              if (!v231)
              {
LABEL_417:
                segPumpRTCReportingIssueRTCReportingEvent(v230, 1001);
                DerivedStorage = v230;
                v35 = v225;
                goto LABEL_418;
              }
              v232 = *(double *)v292;
              v233 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                         + 40);
              if (v233)
                v233(v231, CFSTR("bytePumpStats"), CFSTR("SymptomOBR"), (uint64_t)v232);
            }
            v230 = v275;
            v234 = *(_QWORD *)(v275 + 9048);
            if (v234)
            {
              v235 = *(_QWORD *)(v275 + 8584);
              v236 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                  + 40);
              if (v236)
                v236(v234, CFSTR("bytePumpStats"), CFSTR("PPRTT"), v235 / 0xF4240);
            }
            goto LABEL_417;
          }
          if (*(_QWORD *)(v275 + 8416) == 1)
          {
            v170 = (double *)segPumpGetMediaFilePrivateData(v17);
            segPumpRTCReportingUpdateBandwidthStats(v275, a2, (uint64_t)(v170[10] * 1000000000.0));
          }
          v171 = *(_QWORD *)(v275 + 9048);
          v293 = 0;
          memset(v292, 0, sizeof(v292));
          v172 = *(_QWORD *)(a2 + 952);
          if (v172 < 1)
          {
            v173 = 0.0;
            if (!v171)
              goto LABEL_356;
          }
          else
          {
            segPumpGetObservedNetworkStats(v275, v172, (uint64_t)v292);
            v173 = (double)*(uint64_t *)&v292[0];
            if (!v171)
              goto LABEL_356;
          }
          v174 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                 + 16)
                                                                                     + 40);
          if (v174)
            v174(v171, CFSTR("bytePumpStats"), CFSTR("AudioSegOBR"), (uint64_t)v173);
LABEL_356:
          v175 = *(_QWORD *)(v275 + 9048);
          if (v175)
          {
            v176 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                + 40);
            if (v176)
              v176(v175, CFSTR("bytePumpStats"), CFSTR("AudioSegLatency"), v264 / 0xF4240);
            v175 = *(_QWORD *)(v275 + 9048);
          }
          v177 = (double *)segPumpGetMediaFilePrivateData(v17);
          if (v175)
          {
            v178 = v177[10];
            v179 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                       + 40);
            if (v179)
              v179(v175, CFSTR("bytePumpStats"), CFSTR("AudioSegDT"), (uint64_t)(v178 * 1000.0));
          }
          v180 = *(_QWORD *)(v275 + 9048);
          v181 = segPumpGetMediaFilePrivateData(v17);
          if (v180)
          {
            v182 = v181[17];
            v183 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                + 40);
            if (v183)
              v183(v180, CFSTR("bytePumpStats"), CFSTR("AudioDNSTime"), v182 / 0xF4240);
          }
          v184 = *(_QWORD *)(v275 + 9048);
          v185 = segPumpGetMediaFilePrivateData(v17);
          if (v184)
          {
            v186 = v185[18];
            v187 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                + 40);
            if (v187)
              v187(v184, CFSTR("bytePumpStats"), CFSTR("AudioTLSTime"), v186 / 0xF4240);
          }
          v188 = *(_QWORD *)(v275 + 9048);
          v189 = segPumpGetMediaFilePrivateData(v17);
          if (v188)
          {
            v190 = v189[19];
            v191 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                + 40);
            if (v191)
              v191(v188, CFSTR("bytePumpStats"), CFSTR("AudioConnTime"), v190 / 0xF4240);
          }
          v192 = *(_QWORD *)(v275 + 9048);
          v193 = segPumpGetMediaFilePrivateData(v17);
          if (v192)
          {
            v194 = v193[21];
            v195 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                + 40);
            if (v195)
              v195(v192, CFSTR("bytePumpStats"), CFSTR("AudioResponseTime"), v194 / 0xF4240);
          }
          v196 = *(_QWORD *)(v275 + 9048);
          v197 = segPumpGetMediaFilePrivateData(v17);
          if (v196)
          {
            v198 = v197[20];
            v199 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                + 40);
            if (v199)
              v199(v196, CFSTR("bytePumpStats"), CFSTR("AudioRequestTime"), v198 / 0xF4240);
          }
          v200 = *(_QWORD *)(v275 + 9048);
          v201 = segPumpGetMediaFilePrivateData(v17);
          if (v200)
          {
            v202 = v201[22];
            v203 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                + 40);
            if (v203)
              v203(v200, CFSTR("bytePumpStats"), CFSTR("AudioSchedulingDelay"), v202 / 0xF4240);
          }
          v204 = *(_QWORD *)(v275 + 9048);
          if (v204)
          {
            v205 = *(_QWORD *)(a2 + 1112);
            v206 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                               + 56);
            if (v206)
              v206(v204, CFSTR("bytePumpStats"), CFSTR("AudioSegNumber"), v205 + 1, 0);
          }
          v207 = *(_QWORD *)(v275 + 9048);
          v208 = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v17);
          if (v207)
          {
            v209 = v208;
            v210 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                       + 40);
            if (v210)
              v210(v207, CFSTR("bytePumpStats"), CFSTR("AudioSegDur"), (uint64_t)(v209 * 1000.0));
          }
          v211 = *(_QWORD *)(v275 + 9048);
          v212 = segPumpGetMediaFilePrivateData(v17);
          if (v211)
          {
            v213 = v212[5];
            v214 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                       + 40);
            if (v214)
              v214(v211, CFSTR("bytePumpStats"), CFSTR("AudioSegSize"), v213);
          }
          DerivedStorage = v275;
          v215 = *(_DWORD *)(v275 + 9068);
          if (v69[1105])
          {
            if (!v215)
              goto LABEL_437;
          }
          else if (v215 != 2)
          {
LABEL_437:
            if (!v69[5])
              goto LABEL_451;
            v252 = *(_QWORD *)(DerivedStorage + 9048);
            if (v252)
            {
              v253 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
              if (v253)
                v253(v252, CFSTR("bytePumpStats"), CFSTR("AudSST"), v263 / 0xF4240, 0);
            }
            v254 = 2002;
            goto LABEL_450;
          }
          if (segPumpShouldIssueVerboseEvent(v275, a2, (uint64_t)v17))
          {
            v242 = *(_QWORD *)(v275 + 9048);
            if (v242)
            {
              v243 = *(_QWORD *)(a2 + 752);
              v244 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                         + 40);
              if (v244)
                v244(v242, CFSTR("bytePumpStats"), CFSTR("AudioPCC"), v243);
              v242 = *(_QWORD *)(v275 + 9048);
            }
            v245 = (unsigned __int8 *)segPumpGetMediaFilePrivateData(v17);
            if (v242)
            {
              v246 = v245[184];
              v247 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                 + 56);
              if (v247)
                v247(v242, CFSTR("bytePumpStats"), CFSTR("AudioIsReusedConn"), v246, 0);
            }
            v248 = *(_QWORD *)(v275 + 9048);
            v249 = segPumpGetMediaFilePrivateData(v17);
            if (v248)
            {
              v250 = v249[24];
              v251 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                                 + 56);
              if (v251)
                v251(v248, CFSTR("bytePumpStats"), CFSTR("AudioRedirectCount"), v250, 0);
            }
            DerivedStorage = v275;
            segPumpRTCReportingIssueRTCReportingEvent(v275, 1002);
          }
          goto LABEL_437;
        }
LABEL_283:
        if ((a7 & 1) != 0)
        {
          v117 = *(_QWORD *)(a2 + 696);
          if (!v117 || !*(_QWORD *)(v117 + 32) && !*(_QWORD *)(v117 + 104))
          {
            v35 = *(_QWORD *)(a2 + 704) == 0;
            if (!v17)
              goto LABEL_294;
            goto LABEL_289;
          }
        }
        v35 = 0;
        goto LABEL_288;
      }
LABEL_460:
      v23 = 0;
      goto LABEL_453;
    }
LABEL_458:
    v23 = CryptKeyCommonData;
    goto LABEL_453;
  }
  v101 = 0;
  if (!v35)
  {
    v270 = 0;
    v23 = 0;
    goto LABEL_283;
  }
  if (!a3 || !v69[705])
  {
    v270 = 0;
    v23 = 0;
    if (!v17)
      goto LABEL_294;
    goto LABEL_289;
  }
  v102 = *(_QWORD *)(a2 + 776);
  if (v102 >= 1)
  {
    v103 = *(_QWORD **)(a2 + 768);
    while (*v103 != a3)
    {
      ++v103;
      if (!--v102)
      {
        v23 = 0;
LABEL_263:
        v270 = 0;
        v101 = 0;
        goto LABEL_282;
      }
    }
    v114 = segPumpCheckAndTryToAdoptStepAhead(v271, v275);
    if ((_DWORD)v114 != -15626)
    {
      v23 = v114;
      goto LABEL_263;
    }
    v35 = 1;
    v23 = 4294951670;
    goto LABEL_453;
  }
  v101 = 0;
  v270 = 0;
  v23 = 0;
  if (v17)
    goto LABEL_289;
LABEL_294:
  if (!*v69 && *(_QWORD *)a2 == *(_QWORD *)(DerivedStorage + 8416) && v17 && !v69[705])
  {
    if (FigMediaSegmentSpecifierGetBytesToRead((uint64_t)v17) < 1)
      v119 = *((_QWORD *)MediaFilePrivateData + 5);
    else
      v119 = FigMediaSegmentSpecifierGetBytesToRead((uint64_t)v17);
    if (v119)
    {
      v216 = (double)(UpTimeNanoseconds - v265) / 1000000.0;
      v217 = *((_QWORD *)MediaFilePrivateData + 6);
      v218 = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v17);
      if (v216 >= 2000.0 && v216 - v218 * ((double)v217 / (double)v119) * 1000.0 >= 1000.0)
      {
        *v69 = 1;
        DerivedStorage = v275;
        segPumpAddMediaSegmentNoResponseErrorIfNecessary(v271, v275, a2, *(_QWORD *)(a2 + 696));
        goto LABEL_453;
      }
    }
    goto LABEL_397;
  }
LABEL_453:
  if (*(_BYTE *)(DerivedStorage + 329) && v35)
    segPumpResumeRoundTripMonitoring(DerivedStorage);
  return v23;
}

void segPumpRTCReportingLogAndUpdateStats(uint64_t a1, CFHTTPMessageRef message, CFStringRef headerField, uint64_t a4)
{
  CFStringRef v6;
  CFStringRef v7;
  uint64_t v8;
  void (*v9)(uint64_t, __CFString *, uint64_t, CFStringRef, _QWORD);

  v6 = CFHTTPMessageCopyHeaderFieldValue(message, headerField);
  if (v6)
  {
    v7 = v6;
    v8 = *(_QWORD *)(a1 + 9048);
    if (v8)
    {
      v9 = *(void (**)(uint64_t, __CFString *, uint64_t, CFStringRef, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 48);
      if (v9)
        v9(v8, CFSTR("bytePumpStats"), a4, v7, 0);
    }
    CFRelease(v7);
  }
}

double segPumpGetElapsedTimeForConnectionOnMedia(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = 64;
  if (!*(_BYTE *)(a2 + 281))
    v2 = 40;
  v3 = *(_QWORD *)(a2 + v2);
  if (*(uint64_t *)(a2 + 296) <= 0)
    v4 = v3;
  else
    v4 = *(_QWORD *)(a2 + 296);
  return *(double *)(a1 + 808) + (double)(FigGetUpTimeNanoseconds() - v4) / 1000000000.0;
}

_QWORD *segPumpSetCurrentSegmentTooSlow(_QWORD *result, uint64_t a2)
{
  uint64_t v3;
  uint64_t (*v4)(uint64_t, __CFString *, __CFString *, uint64_t);

  if (!*(_BYTE *)(a2 + 873))
  {
    ++result[1062];
    v3 = result[1131];
    if (v3)
    {
      result = (_QWORD *)CMBaseObjectGetVTable();
      v4 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, uint64_t))(result[2] + 32);
      if (v4)
        result = (_QWORD *)v4(v3, CFSTR("bytePumpStats"), CFSTR("DownloadLimitCount"), 1);
    }
  }
  *(_WORD *)(a2 + 873) = 257;
  return result;
}

uint64_t segPumpAppendBytesToMediaConnectionBuffer(uint64_t a1, size_t offsetToData, size_t dataLength)
{
  const __CFAllocator *AllocatorForMedia;
  uint64_t result;

  if (*(_QWORD *)(a1 + 272)
    || (AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia(),
        result = CMBlockBufferCreateEmpty(AllocatorForMedia, 0, 0, (CMBlockBufferRef *)(a1 + 272)),
        !(_DWORD)result))
  {
    if (dataLength)
      return CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)(a1 + 272), *(CMBlockBufferRef *)(a1 + 128), offsetToData, dataLength, 0);
    else
      return 0;
  }
  return result;
}

uint64_t segPumpCheckAndTryToAdoptStepAhead(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t UpTimeNanoseconds;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  double v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  dispatch_object_t *v15;
  uint64_t v16;
  uint64_t v18;

  v4 = *(_QWORD *)(a2 + 384);
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v6 = *(_QWORD **)(v4 + 696);
  if (!v6)
    return 0;
  v7 = UpTimeNanoseconds;
  v8 = v6[1];
  if (v8)
  {
    if (FigMediaSegmentSpecifierGetType(v8) == 1)
      return 0;
    v6 = *(_QWORD **)(v4 + 696);
  }
  if (!v6[4])
    return 0;
  v9 = (double)(v6[36] - v7) / 1000000000.0;
  if (v9 >= 0.0)
  {
    v16 = v6[14];
    v15 = (dispatch_object_t *)(v6 + 14);
    if (!v16)
      FigHTTPCreateTimer(*(const void **)a2, (uint64_t)MediaKeyStreamHandleDownloadTimer, *(NSObject **)(a2 + 64), v15, v9);
    return 0;
  }
  if (*(uint64_t *)(v4 + 776) < 1)
    return 0;
  v10 = 0;
  for (i = 0; i < *(_QWORD *)(v4 + 776); ++i)
  {
    v12 = **(_QWORD **)(v4 + 768);
    if (!v12)
      break;
    v13 = *(const void **)(v12 + 8);
    if (!v13)
      break;
    segPumpGetMediaFilePrivateData(*(const void **)(v12 + 8));
    v14 = **(_QWORD **)(v4 + 768);
    if (*(_QWORD *)(v14 + 288) > v7)
      goto LABEL_21;
    if (!*(_QWORD *)(v14 + 32))
    {
      if (!*(_QWORD *)(v14 + 104))
      {
LABEL_21:
        segPumpResetMediaConnection(a2, *(_QWORD **)(v4 + 696), 0);
        *(_QWORD *)(v4 + 696) = 0;
        v18 = **(_QWORD **)(v4 + 768);
        if (*(_QWORD *)(v18 + 32))
          FigHTTPCreateTimer(*(const void **)a2, (uint64_t)MediaKeyStreamHandleDownloadTimer, *(NSObject **)(a2 + 64), (dispatch_object_t *)(v18 + 112), (double)(*(_QWORD *)(v18 + 288) - v7));
        segPumpAdoptReadAhead(a2, v4, v13, 0, 0);
        return v10;
      }
      v10 = segPumpDeliverAccumulatedBuffer(a1, a2, v4, v14, *(const void **)(v14 + 8), 1);
      if ((_DWORD)v10 == -15626)
        return 4294951670;
    }
    ++*(_QWORD *)(a2 + 8856);
    segPumpStreamCancelReadAheadAndResetDataAtIndex(a2, v4, 0);
  }
  return v10;
}

void segPumpAddMediaSegmentNoResponseErrorIfNecessary(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  double TimeInSeconds;
  const __CFAllocator *AllocatorForMedia;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  CFStringRef v14;

  if (a4 && !*(_BYTE *)(a4 + 280) && !*(_QWORD *)(a4 + 224))
  {
    v8 = *(_QWORD *)(a4 + 8);
    if (v8)
      TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds(v8);
    else
      TimeInSeconds = -1.0;
    AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    v11 = *(_QWORD *)(a3 + 696);
    if (v11)
    {
      v12 = *(_QWORD *)(v11 + 8);
      v13 = "media file";
      if (v12)
      {
        if (FigMediaSegmentSpecifierGetType(v12) == 1)
          v13 = "map";
      }
    }
    else
    {
      v13 = "media file";
    }
    v14 = CFStringCreateWithFormat(AllocatorForMedia, 0, CFSTR("No response for %s in %1.5gs"), v13, *(_QWORD *)&TimeInSeconds);
    segPumpAppendErrorLogEntry(a1, a2, a3, (const __CFURL **)(a4 + 16), -12889, CFSTR("CoreMediaErrorDomain"), (uint64_t)v14, 0, 1, 2u, 3u);
    CFRelease(v14);
  }
}

uint64_t segPumpStreamBitRateRequiredForStream(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 7680);
  if (v2 && *(_QWORD **)(a1 + 16 * *a2 + 392) == a2)
    return FigAlternateGetPeakBitRate(*(_QWORD *)(v2 + 8));
  v2 = *(_QWORD *)(a1 + 8144);
  if (v2)
    return FigAlternateGetPeakBitRate(*(_QWORD *)(v2 + 8));
  else
    return 0;
}

void MediaKeyStreamHandleDownloadTimer(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  CFTypeRef cf;

  v2 = 0;
  cf = 0;
  if (!segPumpLockAndCopyPumpFromRetainProxy(a2, &cf, &v2))
    segPumpCheckAndTryToAdoptStepAhead(cf, v2);
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
}

uint64_t segPumpAdoptReadAhead(uint64_t a1, uint64_t a2, const void *a3, const void *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  const void *v14;
  uint64_t FragmentNumber;
  uint64_t result;
  const void *ContentKeySpecifier;
  const void *v18;
  _QWORD *v19;
  _QWORD *v20;
  const __CFURL *v21;
  const __CFURL *v22;
  uint64_t MapNumber;
  uint64_t v24;
  uint64_t v25;

  v5 = a5;
  v10 = *(_QWORD *)(*(_QWORD *)(a2 + 768) + 8 * a5);
  segPumpSetStreamDiscontinuityDomain(a1, (_QWORD *)a2, (uint64_t)a3);
  *(_QWORD *)(a2 + 696) = v10;
  v11 = *(_QWORD *)(a2 + 776);
  if (v11 > v5)
  {
    v12 = v11 - 1;
    if (v12 > v5)
    {
      do
      {
        *(_QWORD *)(*(_QWORD *)(a2 + 768) + 8 * v5) = *(_QWORD *)(*(_QWORD *)(a2 + 768) + 8 * v5 + 8);
        ++v5;
      }
      while (v12 != v5);
    }
    *(_QWORD *)(*(_QWORD *)(a2 + 768) + 8 * v12) = 0;
  }
  v13 = *(const void **)(a2 + 256);
  *(_QWORD *)(a2 + 256) = a3;
  if (a3)
    CFRetain(a3);
  if (v13)
    CFRelease(v13);
  v14 = *(const void **)(a2 + 264);
  *(_QWORD *)(a2 + 264) = a4;
  if (a4)
    CFRetain(a4);
  if (v14)
    CFRelease(v14);
  *(_BYTE *)(a2 + 404) = 1;
  if (a4)
  {
    FragmentNumber = segPumpGetFragmentNumber((uint64_t)a3, a4);
    if (FragmentNumber < 0)
      return FigSignalErrorAt();
  }
  else
  {
    FragmentNumber = -1;
  }
  if (!FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a3)
    || (v24 = 0,
        v25 = 0,
        ContentKeySpecifier = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a3),
        result = segPumpGetCryptKeyCommonData(ContentKeySpecifier, &v25, &v24),
        !(_DWORD)result)
    && (*(_BYTE *)(v24 + 144) || !*(_BYTE *)(a1 + 322)))
  {
    if (!v10
      || !*(_QWORD *)(v10 + 32) && !*(_QWORD *)(v10 + 104)
      || (a4 ? (v18 = a4) : (v18 = a3), result = (uint64_t)segPumpAccumConnCompletesMediaRange(v10, v18), (_DWORD)result))
    {
      v19 = malloc_type_malloc(0x48uLL, 0x10A00404BD41864uLL);
      if (v19)
      {
        v20 = v19;
        *v19 = FigRetainProxyRetain();
        v20[1] = a2;
        if (FigMediaSegmentSpecifierGetType((uint64_t)a3))
        {
          if (FigMediaSegmentSpecifierGetType((uint64_t)a3) == 1)
          {
            v20[4] = -1;
            v20[5] = -1;
            v21 = *(const __CFURL **)(a2 + 16);
            v22 = *(const __CFURL **)(a2 + 24);
            segPumpGetMediaFilePrivateData(a3);
            segPumpEnsureMediaSegmentURLs(a3, v21, v22);
            MapNumber = segPumpStreamGetMapNumber((_QWORD *)a2);
            v20[6] = MapNumber;
            if (MapNumber < 0)
            {
              free(v20);
              return FigSignalErrorAt();
            }
          }
        }
        else
        {
          v20[4] = FigMediaSegmentSpecifierGetMediaSequence((uint64_t)a3);
          v20[5] = FragmentNumber;
          v20[6] = -1;
        }
        dispatch_async_f(*(dispatch_queue_t *)(a1 + 72), v20, (dispatch_function_t)segPumpDispatchedAdoptReadAhead);
        return 0;
      }
      else
      {
        return 4294954655;
      }
    }
  }
  return result;
}

uint64_t segPumpGetFragmentNumber(uint64_t a1, const void *a2)
{
  const __CFArray *PartialSegments;
  uint64_t v4;
  CFIndex v5;
  CFIndex v6;

  PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments(a1);
  v4 = -1;
  while (1)
  {
    v5 = PartialSegments ? CFArrayGetCount(PartialSegments) : 0;
    v6 = v4 + 1;
    if (v4 + 1 >= v5)
      break;
    ++v4;
    if (CFArrayGetValueAtIndex(PartialSegments, v6) == a2)
      goto LABEL_9;
  }
  a2 = 0;
LABEL_9:
  if (a2)
    return v4;
  else
    return -1;
}

uint64_t segPumpStreamGetMapNumber(_QWORD *a1)
{
  CFIndex i;
  const __CFArray *MapSegmentSpecifiers;
  const __CFArray *v4;
  const void *ValueAtIndex;
  const __CFURL *v6;
  const __CFURL *v7;

  for (i = 0; ; ++i)
  {
    MapSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMapSegmentSpecifiers(a1[7]);
    if (MapSegmentSpecifiers)
      MapSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MapSegmentSpecifiers);
    if (i >= (uint64_t)MapSegmentSpecifiers)
      break;
    v4 = (const __CFArray *)FigMediaPlaylistGetMapSegmentSpecifiers(a1[7]);
    ValueAtIndex = CFArrayGetValueAtIndex(v4, i);
    v6 = (const __CFURL *)a1[2];
    v7 = (const __CFURL *)a1[3];
    segPumpGetMediaFilePrivateData(ValueAtIndex);
    segPumpEnsureMediaSegmentURLs(ValueAtIndex, v6, v7);
    if (FigCFEqual())
      goto LABEL_8;
  }
  ValueAtIndex = 0;
LABEL_8:
  if (ValueAtIndex)
    return i;
  else
    return -1;
}

void segPumpDispatchedAdoptReadAhead(uint64_t *a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  CFIndex v5;
  const __CFArray *MapSegmentSpecifiers;
  CFIndex Count;
  const __CFArray *v8;
  const void *ValueAtIndex;
  const void *MediaEntryForMediaSequence;
  uint64_t v11;
  uint64_t FirstValue;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CFTypeRef cf;

  v2 = *a1;
  v15 = 0;
  cf = 0;
  if (segPumpLockAndCopyPumpFromRetainProxy(v2, &cf, &v15))
    goto LABEL_24;
  v3 = (_QWORD *)a1[1];
  if (!v3)
    goto LABEL_24;
  v4 = v3[7];
  if (!v4)
    goto LABEL_24;
  v5 = a1[6];
  if ((v5 & 0x8000000000000000) == 0)
  {
    MapSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMapSegmentSpecifiers(v4);
    if (MapSegmentSpecifiers)
    {
      Count = CFArrayGetCount(MapSegmentSpecifiers);
      v4 = v3[7];
      if (v5 < Count)
      {
        v8 = (const __CFArray *)FigMediaPlaylistGetMapSegmentSpecifiers(v4);
        ValueAtIndex = CFArrayGetValueAtIndex(v8, a1[6]);
        goto LABEL_16;
      }
    }
    else
    {
      v4 = v3[7];
    }
  }
  MediaEntryForMediaSequence = segPumpGetMediaEntryForMediaSequence(v4, a1[4]);
  if (!MediaEntryForMediaSequence)
    goto LABEL_24;
  ValueAtIndex = MediaEntryForMediaSequence;
  if ((a1[5] & 0x8000000000000000) == 0)
  {
    v11 = -1;
    do
    {
      if (v11 == -1)
      {
        FigMediaSegmentSpecifierGetPartialSegments((uint64_t)ValueAtIndex);
        FirstValue = FigCFArrayGetFirstValue();
      }
      else
      {
        FirstValue = FigMediaSegmentSpecifierGetNextSegment((uint64_t)ValueAtIndex);
      }
      ValueAtIndex = (const void *)FirstValue;
      ++v11;
    }
    while (v11 < a1[5]);
LABEL_16:
    if (!ValueAtIndex)
      goto LABEL_24;
  }
  v13 = v3[87];
  if (v13)
  {
    if (*(const void **)(v13 + 8) == ValueAtIndex)
    {
      v14 = v3[110];
      if (!*(_QWORD *)(v13 + 272)
        || (CFRelease(ValueAtIndex),
            *(_QWORD *)(v13 + 8) = 0,
            segPumpDeliverAccumulatedBuffer((uint64_t)cf, v15, (uint64_t)v3, v13, ValueAtIndex, 1) != -15626))
      {
        if (!FigRetainProxyIsInvalidated() && v14 == v3[110])
          segPumpStreamProceedAfterMediaAndKeyArrival(cf, v15, v3, ValueAtIndex, 1, 1);
      }
    }
  }
LABEL_24:
  FigRetainProxyUnlockMutex();
  FigRetainProxyRelease();
  if (cf)
    CFRelease(cf);
  free(a1);
}

const void *segPumpGetMediaEntryForMediaSequence(uint64_t a1, unint64_t a2)
{
  CFIndex v4;
  const __CFArray *MediaSegmentSpecifiers;
  const __CFArray *v6;
  const void *ValueAtIndex;

  v4 = 0;
  do
  {
    MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
    if (MediaSegmentSpecifiers)
      MediaSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MediaSegmentSpecifiers);
    if (v4 >= (uint64_t)MediaSegmentSpecifiers)
      break;
    v6 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
    ValueAtIndex = CFArrayGetValueAtIndex(v6, v4);
    if (FigMediaSegmentSpecifierGetMediaSequence((uint64_t)ValueAtIndex) == a2)
      return ValueAtIndex;
    ++v4;
  }
  while (FigMediaSegmentSpecifierGetMediaSequence((uint64_t)ValueAtIndex) <= a2);
  return 0;
}

void segPumpRTCReportingUpdateBandwidthStats(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  void (*v9)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v10;
  void (*v11)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v12;
  void (*v13)(uint64_t, __CFString *, __CFString *, unint64_t);
  uint64_t v14;
  double AggregateBandwidth;
  double v16;
  void (*v17)(uint64_t, __CFString *, __CFString *, uint64_t);
  _OWORD v18[5];
  uint64_t v19;

  v19 = 0;
  memset(v18, 0, sizeof(v18));
  v5 = *(_QWORD *)(a2 + 952);
  if (v5 < 1)
  {
    v6 = 0;
  }
  else
  {
    segPumpGetObservedNetworkStats(a1, v5, (uint64_t)v18);
    v6 = (uint64_t)(double)*(uint64_t *)&v18[0];
  }
  v7 = *(_QWORD *)(a1 + 9048);
  if (v7)
  {
    v8 = a3 / 0xF4240;
    v9 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 32);
    if (v9)
      v9(v7, CFSTR("bytePumpStats"), CFSTR("ADT"), v8);
    v10 = *(_QWORD *)(a1 + 9048);
    if (v10)
    {
      v11 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                            + 16)
                                                                                + 40);
      if (v11)
        v11(v10, CFSTR("bytePumpStats"), CFSTR("OBR"), v6);
      v12 = *(_QWORD *)(a1 + 9048);
      if (!v12)
      {
        v14 = 0;
        goto LABEL_13;
      }
      v13 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                         + 32);
      if (v13)
        v13(v12, CFSTR("bytePumpStats"), CFSTR("TWOBR_Bits"), v6 * v8);
    }
  }
  v14 = *(_QWORD *)(a1 + 9048);
LABEL_13:
  AggregateBandwidth = FigGlobalNetworkBandwidthTrackerGetAggregateBandwidth();
  if (v14)
  {
    v16 = AggregateBandwidth;
    v17 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                              + 40);
    if (v17)
      v17(v14, CFSTR("bytePumpStats"), CFSTR("NSOBR"), (uint64_t)v16);
  }
  segPumpRTCReportingSetCurrentAlternateIndexAndBitRate(a1);
}

uint64_t segPumpShouldIssueVerboseEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int IsFragment;
  uint64_t v7;
  _BOOL4 v8;

  IsFragment = FigMediaSegmentSpecifierIsFragment(a3);
  v7 = *(_QWORD *)(a2 + 256);
  if (v7)
  {
    FigMediaSegmentSpecifierGetPartialSegments(v7);
    v8 = FigCFArrayGetFirstValue() == a3;
  }
  else
  {
    v8 = 0;
  }
  if (!IsFragment)
    v8 = 1;
  return *(_DWORD *)(a1 + 9068) == 3 || v8;
}

void segPumpRTCReportingSetCurrentAlternateIndexAndBitRate(uint64_t a1)
{
  uint64_t v1;
  int AlternateIndex;
  const __CFAllocator *v4;
  CFNumberRef v5;
  uint64_t v6;
  void (*v7)(uint64_t, __CFString *, __CFString *, CFNumberRef, _QWORD);
  CFNumberRef v8;
  uint64_t v9;
  void (*v10)(uint64_t, __CFString *, __CFString *, CFNumberRef, _QWORD);
  uint64_t v11;
  void (*v12)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD);
  int valuePtr;
  int AverageBitRate;

  v1 = *(_QWORD *)(a1 + 8144);
  if (v1)
  {
    AverageBitRate = FigAlternateGetAverageBitRate(*(_QWORD *)(v1 + 8));
    valuePtr = FigAlternateGetDeclaredPeakBitRate(*(_QWORD *)(*(_QWORD *)(a1 + 8144) + 8));
    AlternateIndex = FigAlternateGetAlternateIndex(*(_QWORD *)(*(_QWORD *)(a1 + 8144) + 8));
    v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
    v6 = *(_QWORD *)(a1 + 9048);
    if (v6)
    {
      v7 = *(void (**)(uint64_t, __CFString *, __CFString *, CFNumberRef, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                           + 48);
      if (v7)
        v7(v6, CFSTR("bytePumpStats"), CFSTR("IBR"), v5, 0);
    }
    v8 = CFNumberCreate(v4, kCFNumberIntType, &AverageBitRate);
    v9 = *(_QWORD *)(a1 + 9048);
    if (v9)
    {
      v10 = *(void (**)(uint64_t, __CFString *, __CFString *, CFNumberRef, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                            + 48);
      if (v10)
        v10(v9, CFSTR("bytePumpStats"), CFSTR("IABR"), v8, 0);
      v11 = *(_QWORD *)(a1 + 9048);
      if (v11)
      {
        v12 = *(void (**)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                         + 56);
        if (v12)
          v12(v11, CFSTR("bytePumpStats"), CFSTR("PumpAltID"), AlternateIndex, 0);
      }
    }
    if (v8)
      CFRelease(v8);
    if (v5)
      CFRelease(v5);
  }
}

uint64_t segPumpCustomURLLoaderGetURLGuts(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, char a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t Mutable;
  CFTypeRef v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t, _QWORD, uint64_t, uint64_t, void (*)(uint64_t, uint64_t, uint64_t, OpaqueCMBlockBuffer *, char, __CFError *, const __CFDictionary *), uint64_t);
  uint64_t v22;

  if (a2)
  {
    if (!a1[10])
      return FigSignalErrorAt();
    FigGetAllocatorForMedia();
    Mutable = FigCustomURLRequestInfoCreateMutable();
    if (!(_DWORD)Mutable)
    {
      Mutable = FigCustomURLRequestInfoSetCryptor();
      if (!(_DWORD)Mutable)
      {
        Mutable = FigCustomURLRequestInfoSetIsRenewalRequest();
        if (!(_DWORD)Mutable)
        {
          Mutable = FigCustomURLRequestInfoSetIsPingRequest();
          if (!(_DWORD)Mutable)
          {
            Mutable = FigCustomURLRequestInfoSetCryptorKeyRequestID();
            if (!(_DWORD)Mutable)
            {
              Mutable = FigCustomURLRequestInfoSetHTTPHeaders();
              if (!(_DWORD)Mutable)
              {
                Mutable = FigCustomURLRequestInfoSetAllowedUniversalTypeIdentifiers();
                if (!(_DWORD)Mutable)
                {
                  Mutable = FigCustomURLRequestInfoSetIsSecureStopSupported();
                  if (!(_DWORD)Mutable)
                  {
                    Mutable = FigCustomURLRequestInfoSetNetworkHistory();
                    if (!(_DWORD)Mutable)
                    {
                      Mutable = FigCustomURLRequestInfoSetExpectedToBlock();
                      if (!(_DWORD)Mutable)
                      {
                        if (!a7
                          || !a1[1075]
                          || (segPumpGetCurrentRTT(a1),
                              Mutable = FigCustomURLRequestInfoSetDefaultLatency(),
                              !(_DWORD)Mutable))
                        {
                          v15 = FigCFHTTPCreateUserAgent();
                          v16 = FigCustomURLRequestInfoSetUserAgent();
                          if (!(_DWORD)v16)
                          {
                            if (!a9 || (v16 = FigCustomURLRequestInfoSetAcceptEncoding(), !(_DWORD)v16))
                            {
                              if (a10 <= 0 && a11 < 1 || (v16 = FigCustomURLRequestInfoSetByteRange(), !(_DWORD)v16))
                              {
                                v17 = a1[19];
                                if (!v17)
                                {
                                  v18 = a1[8];
                                  a1[19] = (uint64_t)v18;
                                  dispatch_retain(v18);
                                  v17 = a1[19];
                                }
                                v19 = a1[10];
                                v20 = *a1;
                                v21 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t, void (*)(uint64_t, uint64_t, uint64_t, OpaqueCMBlockBuffer *, char, __CFError *, const __CFDictionary *), uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
                                if (!v21)
                                {
                                  v22 = 4294954514;
                                  if (!v15)
                                    return v22;
LABEL_29:
                                  CFRelease(v15);
                                  return v22;
                                }
                                v16 = v21(v19, 0, v20, v17, segPumpCustomURLLoaderDataCallback, a12);
                              }
                            }
                          }
                          v22 = v16;
                          if (!v15)
                            return v22;
                          goto LABEL_29;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return Mutable;
  }
  return FigSignalErrorAt();
}

void segPumpCustomURLLoaderDataCallback(uint64_t a1, uint64_t a2, uint64_t a3, OpaqueCMBlockBuffer *a4, char a5, __CFError *a6, const __CFDictionary *a7)
{
  uint64_t v12;
  uint64_t CFDataWithBlockBufferNoCopy;
  const __CFAllocator *AllocatorForMedia;
  const __CFAllocator *v15;
  const __CFAllocator *v16;
  size_t v17;
  const void *v18;
  CFIndex Length;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t HTTPStatusCode;
  uint64_t ContentLength;
  double v26;
  double v27;
  const __CFString *v28;
  uint64_t v29;
  const __CFData *v30;
  uint64_t DerivedStorage;
  CFIndex Code;
  uint64_t BlockBufferWithCFDataNoCopy;
  uint64_t v34;
  char v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  CFIndex v40;
  const __CFArray *ContentKeySpecifiers;
  const __CFArray *v42;
  const void *ValueAtIndex;
  uint64_t v44;
  const void *v45;
  uint64_t v46;
  const void *v47;
  uint64_t i;
  uint64_t v49;
  uint64_t v50;
  _QWORD *CryptKeyCommonDataForRequestID;
  uint64_t v52;
  NSObject *v53;
  unsigned int v54;
  unsigned int v55;
  const __CFString *v56;
  uint64_t v57;
  const __CFString *v58;
  const void *v59;
  const void *v62;
  NSObject *v63;
  unsigned int v64;
  unsigned int v65;
  const __CFString *v66;
  uint64_t v67;
  CFStringRef v68;
  CFURLRef v69;
  NSObject *v70;
  unsigned int v71;
  unsigned int v72;
  const __CFString *v73;
  uint64_t v74;
  const __CFString *v75;
  __CFHTTPMessage *v76;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v78;
  unsigned int v79;
  const __CFString *v80;
  uint64_t v81;
  const __CFString *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t UpTimeNanoseconds;
  uint64_t CryptKeyCommonData;
  NSObject *v88;
  unsigned int v89;
  unsigned int v90;
  const __CFString *v91;
  uint64_t v92;
  const __CFString *v93;
  uint64_t appended;
  const __CFAllocator *v95;
  size_t v96;
  const void *v97;
  const __CFAllocator *v98;
  OpaqueCMBlockBuffer *v99;
  const __CFAllocator *v100;
  const __CFAllocator *v101;
  __CFDictionary *Mutable;
  const __CFString *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  void (*v107)(uint64_t, uint64_t);
  uint64_t MediaFileURL;
  const __CFAllocator *v109;
  uint64_t Empty;
  _QWORD *v111;
  const __CFURL *v112;
  const __CFURL *v113;
  _QWORD *MediaFilePrivateData;
  CFTypeRef v115;
  uint64_t v116;
  const __CFAllocator *v117;
  uint64_t v118;
  const void *v119;
  uint64_t v120;
  uint64_t *v121;
  _BYTE *v122;
  uint64_t v123;
  _QWORD *v124;
  uint64_t (*v125)(uint64_t, uint64_t, uint64_t, char *, _QWORD);
  uint64_t v126;
  CFErrorRef v127;
  void (*v128)(uint64_t, uint64_t, CFErrorRef);
  uint64_t v129;
  _QWORD *v130;
  NSObject *v131;
  unsigned int v132;
  unsigned int v133;
  const __CFString *v134;
  uint64_t v135;
  const void *v136;
  uint64_t v137;
  uint64_t SessionDataRequest;
  OpaqueCMBlockBuffer *v139;
  const __CFAllocator *v140;
  int v141;
  const void *v142;
  uint64_t v143;
  NSObject *v144;
  unsigned int v145;
  unsigned int v146;
  const __CFString *v147;
  uint64_t v148;
  int v149;
  uint64_t v150;
  void *key;
  CFTypeRef v152;
  CFTypeRef v153;
  _BOOL4 v154;
  size_t dataLength;
  const __CFString *Domain;
  const __CFDictionary *v157;
  char v158;
  CFTypeRef v159;
  uint64_t v160;
  uint64_t v161;
  CFStringRef v162;
  const __CFDictionary *v163;
  int v164;
  const __CFString *v165;
  CFURLRef cf;
  CFTypeRef v167;
  CFTypeRef v168;
  CFTypeRef v169;
  CFTypeRef v170;
  CFTypeRef v171;
  CFTypeRef v172;
  CFTypeRef v173;
  CMBlockBufferRef blockBufferOut;
  CFTypeRef v175;
  uint64_t v176;
  CFTypeRef v177;
  CMBlockBufferRef v178;
  CMBlockBufferRef theBuffer;
  os_log_type_t v180;
  unsigned int v181;
  char v182;
  os_log_type_t type[8];
  uint64_t v184;
  _BYTE v185[12];
  __int16 v186;
  const __CFString *v187;
  __int16 v188;
  uint64_t v189;
  __int16 v190;
  uint64_t v191;
  __int16 v192;
  int v193;
  __int16 v194;
  CFURLRef v195;
  CFErrorRef v196[19];

  v12 = a1;
  v196[16] = *(CFErrorRef *)MEMORY[0x1E0C80C00];
  v176 = 0;
  v177 = 0;
  blockBufferOut = 0;
  v175 = 0;
  v172 = 0;
  v173 = 0;
  v170 = 0;
  v171 = 0;
  v168 = 0;
  v169 = 0;
  v167 = 0;
  if (segPumpLockAndCopyPumpFromRetainProxy(a1, &v177, &v176))
    goto LABEL_307;
  CFDataWithBlockBufferNoCopy = FigCustomURLResponseInfoCopyRequestInfo();
  if ((_DWORD)CFDataWithBlockBufferNoCopy)
    goto LABEL_241;
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  v15 = AllocatorForMedia;
  if (a4)
  {
    v16 = (const __CFAllocator *)FigGetAllocatorForMedia();
    v17 = CMBlockBufferGetDataLength(a4);
    CFDataWithBlockBufferNoCopy = CMBlockBufferCreateContiguous(v15, a4, v16, 0, 0, v17, 0, &blockBufferOut);
    if ((_DWORD)CFDataWithBlockBufferNoCopy)
      goto LABEL_241;
    FigGetAllocatorForMedia();
    CMBlockBufferGetDataLength(blockBufferOut);
    CFDataWithBlockBufferNoCopy = FigCreateCFDataWithBlockBufferNoCopy();
    if ((_DWORD)CFDataWithBlockBufferNoCopy)
      goto LABEL_241;
    v18 = v173;
  }
  else
  {
    v18 = CFDataCreate(AllocatorForMedia, 0, 0);
    v173 = v18;
  }
  Length = CFDataGetLength((CFDataRef)v18);
  if ((a5 & 1) == 0 && !Length)
  {
LABEL_307:
    v28 = 0;
    goto LABEL_244;
  }
  CFDataWithBlockBufferNoCopy = FigCustomURLRequestInfoCopyURL();
  if ((_DWORD)CFDataWithBlockBufferNoCopy)
    goto LABEL_241;
  v20 = FigCustomURLResponseInfoCopyUniversalTypeIdentifier();
  if ((_DWORD)v20)
  {
    v21 = v20;
    if ((_DWORD)v20 != -17360)
      goto LABEL_242;
  }
  v22 = FigCustomURLResponseInfoCopyContentRenewalDate();
  if ((_DWORD)v22)
  {
    v21 = v22;
    if ((_DWORD)v22 != -17360)
      goto LABEL_242;
  }
  v23 = FigCustomURLResponseInfoCopyHTTPHeaders();
  if ((_DWORD)v23)
  {
    v21 = v23;
    if ((_DWORD)v23 != -17360)
      goto LABEL_242;
  }
  HTTPStatusCode = FigCustomURLResponseInfoGetHTTPStatusCode();
  if ((_DWORD)HTTPStatusCode)
  {
    v21 = HTTPStatusCode;
    if ((_DWORD)HTTPStatusCode != -17360)
      goto LABEL_242;
  }
  ContentLength = FigCustomURLResponseInfoGetContentLength();
  if ((_DWORD)ContentLength)
  {
    v21 = ContentLength;
    if ((_DWORD)ContentLength != -17360)
      goto LABEL_242;
  }
  FigCustomURLResponseInfoGetRoundTripTime();
  v27 = v26;
  CFDataWithBlockBufferNoCopy = FigCustomURLResponseInfoCopyFinalURL();
  if ((_DWORD)CFDataWithBlockBufferNoCopy)
  {
LABEL_241:
    v21 = CFDataWithBlockBufferNoCopy;
LABEL_242:
    v28 = 0;
    goto LABEL_243;
  }
  v28 = (const __CFString *)FigCFHTTPCreateURLString((const __CFURL *)v172);
  if (!v28)
  {
    v21 = FigSignalErrorAt();
    if (!(_DWORD)v21)
      goto LABEL_244;
LABEL_243:
    segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(v12, v21);
    goto LABEL_244;
  }
  if (a6)
    goto LABEL_26;
  v29 = FigCFHTTPCreateCFErrorFromHTTPStatusCode(0, (CFErrorRef *)&v167);
  if ((_DWORD)v29)
  {
    v21 = v29;
    goto LABEL_243;
  }
  a6 = (__CFError *)v167;
LABEL_26:
  v30 = (const __CFData *)v173;
  v152 = v169;
  v153 = v171;
  v163 = (const __CFDictionary *)v168;
  v159 = v177;
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v178 = 0;
  theBuffer = 0;
  if (a6)
  {
    Domain = CFErrorGetDomain(a6);
    Code = CFErrorGetCode(a6);
    v162 = CFErrorCopyDescription(a6);
  }
  else
  {
    v162 = 0;
    Code = 0;
    Domain = CFSTR("CoreMediaErrorDomain");
  }
  v160 = Code;
  v161 = v12;
  v165 = v28;
  v157 = a7;
  if (v30 && CFDataGetLength(v30) >= 1)
  {
    FigGetAllocatorForMedia();
    BlockBufferWithCFDataNoCopy = FigCreateBlockBufferWithCFDataNoCopy();
    if ((_DWORD)BlockBufferWithCFDataNoCopy)
    {
      v21 = BlockBufferWithCFDataNoCopy;
      v69 = 0;
      v76 = 0;
      v68 = v162;
      goto LABEL_213;
    }
    dataLength = CMBlockBufferGetDataLength(theBuffer);
  }
  else
  {
    dataLength = 0;
  }
  v154 = a6 != 0;
  cf = FigCFHTTPCopyRedirectLocationFromHTTPHeaders(v163);
  v35 = 0;
  key = (void *)*MEMORY[0x1E0CA4D70];
  v150 = *MEMORY[0x1E0CA31E0];
  v36 = 1;
LABEL_35:
  v37 = 0;
  v158 = v36;
  while (1)
  {
    if ((v35 & 1) != 0)
      v38 = 392;
    else
      v38 = 384;
    v39 = *(_QWORD *)(DerivedStorage + 16 * v37 + v38);
    v196[0] = 0;
    *(_QWORD *)v185 = 0;
    if (!*(_QWORD *)(v39 + 56))
      goto LABEL_66;
    v40 = 0;
    do
    {
      ContentKeySpecifiers = (const __CFArray *)FigMediaPlaylistGetContentKeySpecifiers(*(_QWORD *)(v39 + 56));
      if (ContentKeySpecifiers)
        ContentKeySpecifiers = (const __CFArray *)CFArrayGetCount(ContentKeySpecifiers);
      if (v40 < (uint64_t)ContentKeySpecifiers)
      {
        v42 = (const __CFArray *)FigMediaPlaylistGetContentKeySpecifiers(*(_QWORD *)(v39 + 56));
        ValueAtIndex = CFArrayGetValueAtIndex(v42, v40);
        if (!segPumpGetCryptKeyCommonData(ValueAtIndex, v196, v185))
          goto LABEL_45;
      }
      goto LABEL_66;
LABEL_45:
      if (*(_QWORD *)(*(_QWORD *)v185 + 80) == a2)
        break;
      if (*(_QWORD *)(*(_QWORD *)v185 + 120) == a2)
        break;
      ++v40;
    }
    while (*((_QWORD *)v196[0] + 6) != a2);
    if (!ValueAtIndex)
      goto LABEL_66;
    if (*(_QWORD *)(DerivedStorage + 8416) != 1 || !*(_BYTE *)(*(_QWORD *)v185 + 147))
      goto LABEL_128;
    v44 = *(_QWORD *)(DerivedStorage + 400);
    v45 = *(const void **)(v44 + 248);
    if (v45)
    {
      if (segPumpGetCryptKeyCommonData(v45, v196, v185))
        goto LABEL_128;
      if (*(_QWORD *)(*(_QWORD *)v185 + 80) != a2 && *(_QWORD *)(*(_QWORD *)v185 + 120) != a2)
      {
        if (v44 == v39 || *((_QWORD *)v196[0] + 6) != a2)
          goto LABEL_60;
LABEL_59:
        ValueAtIndex = 0;
        goto LABEL_60;
      }
      if (v44 != v39)
        goto LABEL_59;
    }
LABEL_60:
    v46 = *(_QWORD *)(DerivedStorage + 408);
    v47 = *(const void **)(v46 + 248);
    if (!v47 || segPumpGetCryptKeyCommonData(v47, v196, v185))
      goto LABEL_65;
    if (*(_QWORD *)(*(_QWORD *)v185 + 80) == a2 || *(_QWORD *)(*(_QWORD *)v185 + 120) == a2)
    {
      if (v46 != v39)
        goto LABEL_66;
LABEL_65:
      if (!ValueAtIndex)
        goto LABEL_66;
LABEL_128:
      v164 = FigCFEqual();
      if (dword_1EE2A31E8)
      {
        LODWORD(v184) = 0;
        type[0] = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        v78 = v184;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0]))
          v79 = v78;
        else
          v79 = v78 & 0xFFFFFFFE;
        if (v79)
        {
          v80 = *(const __CFString **)(DerivedStorage + 8760);
          if (!v80)
            v80 = &stru_1E2FD85F8;
          v81 = *(_QWORD *)v39;
          v82 = CFSTR("[]");
          if (*(_BYTE *)(DerivedStorage + 339))
            v82 = v28;
          *(_DWORD *)v185 = 136316162;
          *(_QWORD *)&v185[4] = "segPumpHandleCustomURLResponse";
          v186 = 2114;
          v187 = v80;
          v188 = 2048;
          v189 = v81;
          v190 = 2114;
          v191 = (uint64_t)v82;
          v192 = 1024;
          v193 = v160;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      if (!*(_QWORD *)(v39 + 592))
      {
        UpTimeNanoseconds = FigGetUpTimeNanoseconds();
        *(_QWORD *)(v39 + 592) = UpTimeNanoseconds;
        *(_QWORD *)(v39 + 600) = UpTimeNanoseconds - *(_QWORD *)(v39 + 568);
      }
      v12 = v161;
      if ((_DWORD)v160)
      {
        if ((_DWORD)v160 != -17296 || !FigCFEqual())
        {
          v68 = v162;
          v21 = segPumpHandleCryptKeyNetworkError((uint64_t)v159, v39, ValueAtIndex, v160, Domain, v162);
          goto LABEL_163;
        }
        *(_QWORD *)type = 0;
        v184 = 0;
        v182 = 0;
        CryptKeyCommonData = segPumpGetCryptKeyCommonData(ValueAtIndex, &v184, type);
        if ((_DWORD)CryptKeyCommonData)
        {
          v21 = CryptKeyCommonData;
        }
        else
        {
          FigHTTPStopAndReleaseTimer((dispatch_object_t *)(v39 + 640));
          if (dword_1EE2A31E8)
          {
            v181 = 0;
            v180 = OS_LOG_TYPE_DEFAULT;
            v88 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            v89 = v181;
            if (os_log_type_enabled(v88, v180))
              v90 = v89;
            else
              v90 = v89 & 0xFFFFFFFE;
            if (v90)
            {
              v91 = *(const __CFString **)(DerivedStorage + 8760);
              if (!v91)
                v91 = &stru_1E2FD85F8;
              v92 = *(_QWORD *)v39;
              v93 = *(const __CFString **)(*(_QWORD *)type + 16);
              if (!*(_BYTE *)(DerivedStorage + 339))
                v93 = CFSTR("[]");
              *(_DWORD *)v185 = 136315906;
              *(_QWORD *)&v185[4] = "segPumpHandlePreloadedCryptor";
              v186 = 2114;
              v187 = v91;
              v188 = 2048;
              v189 = v92;
              v190 = 2114;
              v191 = (uint64_t)v93;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          if (*(_QWORD *)(*(_QWORD *)type + 80) == a2)
          {
            v121 = (uint64_t *)(*(_QWORD *)type + 64);
            v122 = (_BYTE *)(*(_QWORD *)type + 88);
            goto LABEL_278;
          }
          if (*(_QWORD *)(*(_QWORD *)type + 120) == a2)
          {
            v121 = (uint64_t *)(*(_QWORD *)type + 104);
            v122 = (_BYTE *)(*(_QWORD *)type + 128);
LABEL_278:
            v69 = cf;
            if (*v122)
            {
              v123 = *v121;
              v124 = *(_QWORD **)(CMBaseObjectGetVTable() + 16);
              if (*v124 >= 6uLL
                && (v125 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, char *, _QWORD))v124[20]) != 0)
              {
                v126 = v125(v123, 2, 1, &v182, 0);
                if (!(_DWORD)v126)
                {
                  if (v182)
                  {
                    v196[0] = 0;
                    FigCreateErrorForOSStatus(4294951067, v196);
                    v127 = v196[0];
                    v128 = *(void (**)(uint64_t, uint64_t, CFErrorRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                               + 56);
                    if (v128)
                      v128(v123, v150, v127);
                    if (v196[0])
                      CFRelease(v196[0]);
                  }
                  goto LABEL_287;
                }
                v21 = v126;
              }
              else
              {
                v21 = 4294954514;
              }
LABEL_313:
              v68 = v162;
LABEL_315:
              v76 = 0;
              goto LABEL_213;
            }
LABEL_287:
            v129 = *(_QWORD *)type;
            if (*(_QWORD *)(*(_QWORD *)type + 80) == a2)
            {
              CryptKeyReleaseAndClearVideoDecryptor(*(uint64_t *)type);
              v129 = *(_QWORD *)type;
              *(_QWORD *)(*(_QWORD *)type + 80) = 0;
              *(_BYTE *)(v129 + 88) = 0;
              v130 = (_QWORD *)(v129 + 96);
              goto LABEL_300;
            }
            if (*(_QWORD *)(*(_QWORD *)type + 120) == a2)
            {
              CryptKeyReleaseAndClearAudioDecryptor(*(uint64_t *)type);
              v129 = *(_QWORD *)type;
              *(_QWORD *)(*(_QWORD *)type + 120) = 0;
              *(_BYTE *)(v129 + 128) = 0;
              v130 = (_QWORD *)(v129 + 136);
LABEL_300:
              v68 = v162;
              *v130 = 0;
            }
            else
            {
              v68 = v162;
            }
            *(_WORD *)(v129 + 144) = 0;
            v120 = segPumpSendCryptKeyRequest((uint64_t)v159, DerivedStorage, v39, *(const __CFString **)(v39 + 248));
            v76 = 0;
            if ((_DWORD)v120)
              goto LABEL_272;
LABEL_310:
            v21 = 0;
            goto LABEL_213;
          }
          if (dword_1EE2A31E8)
          {
            v181 = 0;
            v180 = OS_LOG_TYPE_DEFAULT;
            v131 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            v132 = v181;
            if (os_log_type_enabled(v131, v180))
              v133 = v132;
            else
              v133 = v132 & 0xFFFFFFFE;
            if (v133)
            {
              v134 = &stru_1E2FD85F8;
              if (*(_QWORD *)(DerivedStorage + 8760))
                v134 = *(const __CFString **)(DerivedStorage + 8760);
              v135 = *(_QWORD *)v39;
              *(_DWORD *)v185 = 136315906;
              *(_QWORD *)&v185[4] = "segPumpHandlePreloadedCryptor";
              v186 = 2114;
              v187 = v134;
              v188 = 2048;
              v189 = v135;
              v190 = 2048;
              v191 = a2;
              _os_log_send_and_compose_impl();
            }
            v68 = v162;
            fig_log_call_emit_and_clean_up_after_send_and_compose();
            v21 = 4294951673;
            v69 = cf;
            goto LABEL_315;
          }
          v21 = 4294951673;
        }
        v69 = cf;
        goto LABEL_313;
      }
      if (theBuffer)
      {
        v196[0] = 0;
        *(_QWORD *)v185 = 0;
        appended = segPumpGetCryptKeyCommonData(ValueAtIndex, v196, v185);
        if (!(_DWORD)appended)
        {
          if (*(_QWORD *)(v39 + 656) && *(_QWORD *)(*(_QWORD *)v185 + 152)
            || (v95 = (const __CFAllocator *)FigGetAllocatorForMedia(),
                appended = CMBlockBufferCreateEmpty(v95, 0, 0, (CMBlockBufferRef *)(v39 + 656)),
                !(_DWORD)appended))
          {
            if (!dataLength
              || (appended = CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)(v39 + 656), theBuffer, 0, 0, 0), !(_DWORD)appended))
            {
              v96 = CMBlockBufferGetDataLength(theBuffer);
              *(_QWORD *)(*(_QWORD *)v185 + 152) += v96;
              goto LABEL_172;
            }
          }
        }
      }
      else
      {
LABEL_172:
        if ((a5 & 1) == 0)
          goto LABEL_173;
        v196[0] = 0;
        *(_QWORD *)(v39 + 584) = FigGetUpTimeNanoseconds();
        *(_DWORD *)(v39 + 608) = 0;
        v97 = *(const void **)(v39 + 616);
        if (v97)
        {
          CFRelease(v97);
          *(_QWORD *)(v39 + 616) = 0;
        }
        if (!*(_QWORD *)(v39 + 656)
          || (v98 = (const __CFAllocator *)FigGetAllocatorForMedia(),
              v99 = *(OpaqueCMBlockBuffer **)(v39 + 656),
              v100 = (const __CFAllocator *)FigGetAllocatorForMedia(),
              appended = CMBlockBufferCreateContiguous(v98, v99, v100, 0, 0, 0, 0, &v178),
              !(_DWORD)appended)
          && (FigGetAllocatorForMedia(), appended = FigCreateCFDataWithBlockBufferNoCopy(), !(_DWORD)appended))
        {
          if (v196[0])
          {
            v69 = cf;
            if (v152)
            {
              v101 = (const __CFAllocator *)FigGetAllocatorForMedia();
              Mutable = CFDictionaryCreateMutable(v101, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              CFDictionarySetValue(Mutable, key, v152);
              v21 = segPumpCryptSetKey((uint64_t)v159, DerivedStorage, v39, ValueAtIndex, a2, v164, v196[0], (uint64_t)Mutable);
              if (Mutable)
                CFRelease(Mutable);
            }
            else
            {
              v21 = segPumpCryptSetKey((uint64_t)v159, DerivedStorage, v39, ValueAtIndex, a2, v164, v196[0], 0);
            }
            v68 = v162;
          }
          else
          {
            v68 = v162;
            v21 = segPumpHandleCryptKeyNetworkError((uint64_t)v159, v39, ValueAtIndex, -15622, Domain, v162);
            v69 = cf;
          }
          if (v196[0])
            CFRelease(v196[0]);
          v136 = *(const void **)(v39 + 656);
          if (v136)
          {
            CFRelease(v136);
            *(_QWORD *)(v39 + 656) = 0;
          }
          goto LABEL_315;
        }
      }
      v21 = appended;
LABEL_174:
      v76 = 0;
LABEL_127:
      v68 = v162;
LABEL_212:
      v69 = cf;
      goto LABEL_213;
    }
    if (v46 == v39 || *((_QWORD *)v196[0] + 6) != a2)
      goto LABEL_65;
LABEL_66:
    for (i = 0; i != 3; ++i)
    {
      v49 = *(_QWORD *)(DerivedStorage + 16 * i + 384);
      v50 = v49 + 680;
      while (1)
      {
        v50 = *(_QWORD *)v50;
        if (!v50)
          break;
        if (*(_QWORD *)(v50 + 104) == a2)
          goto LABEL_77;
      }
      v49 = *(_QWORD *)(DerivedStorage + 16 * i + 392);
      v50 = v49 + 680;
      while (1)
      {
        v50 = *(_QWORD *)v50;
        if (!v50)
          break;
        if (*(_QWORD *)(v50 + 104) == a2)
          goto LABEL_77;
      }
    }
    v50 = 0;
    v49 = 0;
LABEL_77:
    if (v39 == v49)
    {
      v59 = *(const void **)(v50 + 8);
      if ((dword_1EE2A31E8 > 2 || *(_BYTE *)(DerivedStorage + 327) == 0) && dword_1EE2A31E8 != 0)
      {
        v62 = *(const void **)(v50 + 8);
        LODWORD(v184) = 0;
        type[0] = OS_LOG_TYPE_DEFAULT;
        v63 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        v64 = v184;
        if (os_log_type_enabled(v63, type[0]))
          v65 = v64;
        else
          v65 = v64 & 0xFFFFFFFE;
        if (v65)
        {
          v66 = *(const __CFString **)(DerivedStorage + 8760);
          if (!v66)
            v66 = &stru_1E2FD85F8;
          if (v39)
            v67 = *(_QWORD *)v39;
          else
            v67 = -1;
          v103 = CFSTR("[]");
          if (*(_BYTE *)(DerivedStorage + 339))
            v103 = v28;
          *(_DWORD *)v185 = 136316162;
          *(_QWORD *)&v185[4] = "segPumpHandleCustomURLResponse";
          v186 = 2114;
          v187 = v66;
          v188 = 2048;
          v189 = v67;
          v190 = 2114;
          v191 = (uint64_t)v103;
          v192 = 1024;
          v193 = v160;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        v59 = v62;
        a7 = v157;
      }
      v68 = v162;
      if (FigCFHTTPIsStatusCodeRedirect(0) && !*(_BYTE *)(DerivedStorage + 327) && cf)
      {
        v104 = *(_QWORD *)(v39 + 792);
        v105 = *(_QWORD *)(CMBaseObjectGetDerivedStorage() + 80);
        if (v105)
        {
          v106 = *(_QWORD *)(v50 + 104);
          v107 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
          if (v107)
            v107(v105, v106);
        }
        *(_QWORD *)(v50 + 104) = 0;
        v69 = cf;
        if (v59
          && (MediaFileURL = segPumpReadMediaFileURL((uint64_t)v159, v39, v59, cf, v50, 0, 0), (_DWORD)MediaFileURL))
        {
          v21 = MediaFileURL;
        }
        else
        {
          if (v50 == v104)
            segPumpSetMediaConnectionIsDormant((_QWORD *)DerivedStorage, v50, 1);
          v21 = 0;
        }
        v76 = 0;
        v12 = v161;
        goto LABEL_213;
      }
      v12 = v161;
      if (!*(_BYTE *)(DerivedStorage + 327)
        && (!v59 || FigMediaSegmentSpecifierGetType((uint64_t)v59) != 1))
      {
        v111 = (_QWORD *)(v50 + 16);
        segPumpAppendErrorLogEntry((uint64_t)v159, DerivedStorage, v39, (const __CFURL **)(v50 + 16), -12881, Domain, (uint64_t)CFSTR("custom url not redirect"), 0, 0, 2u, 3u);
        segPumpResetConnection(DerivedStorage, v50 + 16);
        v112 = *(const __CFURL **)(v39 + 16);
        v113 = *(const __CFURL **)(v39 + 24);
        MediaFilePrivateData = segPumpGetMediaFilePrivateData(v59);
        segPumpEnsureMediaSegmentURLs(v59, v112, v113);
        v115 = (CFTypeRef)MediaFilePrivateData[2];
        if (v115)
          v115 = CFRetain(v115);
        v69 = cf;
        v76 = 0;
        *v111 = v115;
        v21 = 4294954415;
        goto LABEL_213;
      }
      *(_DWORD *)(DerivedStorage + 8464) = 0;
      segPumpUpdateNetworkCostHasHighSpeedHighPower(DerivedStorage);
      if (*(_QWORD *)(v50 + 128)
        || (v109 = (const __CFAllocator *)FigGetAllocatorForMedia(),
            Empty = CMBlockBufferCreateEmpty(v109, 0, 0, (CMBlockBufferRef *)(v50 + 128)),
            !(_DWORD)Empty))
      {
        if (!theBuffer
          || !dataLength
          || (Empty = CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)(v50 + 128), theBuffer, 0, 0, 0),
              !(_DWORD)Empty))
        {
          if ((a5 & 1) != 0)
            FigReportingAgentUpdateFinalReportFromCustomURLResponse(*(_QWORD *)(DerivedStorage + 9048), a7, v154);
          Empty = segPumpHandleMediaFileData((uint64_t)v159, v39, v50, *(_QWORD *)(v50 + 136), dataLength, 0, a5, v160);
        }
      }
LABEL_210:
      v21 = Empty;
LABEL_211:
      v76 = 0;
      goto LABEL_212;
    }
    if (*(_QWORD *)(v39 + 496) == a2)
      break;
    if (*(_QWORD *)(DerivedStorage + 8624) == a2)
    {
      segPumpPongCallback(*(_QWORD *)DerivedStorage, v27, v34, v160);
      v21 = 0;
      v76 = 0;
      *(_QWORD *)(DerivedStorage + 8624) = 0;
      v12 = v161;
      goto LABEL_127;
    }
    if (++v37 == 3)
    {
      v36 = 0;
      v35 = 1;
      if ((v158 & 1) == 0)
      {
        CryptKeyCommonDataForRequestID = segPumpFindCryptKeyCommonDataForRequestID(DerivedStorage, a2);
        v12 = v161;
        if (CryptKeyCommonDataForRequestID)
        {
          v52 = (uint64_t)CryptKeyCommonDataForRequestID;
          if (dword_1EE2A31E8)
          {
            LODWORD(v184) = 0;
            type[0] = OS_LOG_TYPE_DEFAULT;
            v53 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            v54 = v184;
            if (os_log_type_enabled(v53, type[0]))
              v55 = v54;
            else
              v55 = v54 & 0xFFFFFFFE;
            if (v55)
            {
              v56 = *(const __CFString **)(DerivedStorage + 8760);
              if (!v56)
                v56 = &stru_1E2FD85F8;
              v57 = *(_QWORD *)v39;
              v58 = CFSTR("[]");
              if (*(_BYTE *)(DerivedStorage + 339))
                v58 = v28;
              *(_DWORD *)v185 = 136316162;
              *(_QWORD *)&v185[4] = "segPumpHandleCustomURLResponse";
              v186 = 2114;
              v187 = v56;
              v188 = 2048;
              v189 = v57;
              v190 = 2114;
              v191 = (uint64_t)v58;
              v192 = 1024;
              v193 = v160;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          *(_BYTE *)(v52 + 145) = 0;
          CryptKeyReleaseAndClearVideoDecryptor(v52);
          CryptKeyReleaseAndClearAudioDecryptor(v52);
        }
        if (!segPumpFindSessionDataEntryForRequestID(*(_QWORD *)(DerivedStorage + 384), a2))
        {
LABEL_173:
          v21 = 0;
          goto LABEL_174;
        }
        LOBYTE(v196[0]) = 0;
        v68 = v162;
        if (*(_QWORD *)(DerivedStorage + 7744))
        {
          if ((_DWORD)v160)
          {
            v137 = v161;
            SessionDataRequest = segPumpHandleSessionDataNetworkError(v159, v39);
            if ((_DWORD)SessionDataRequest)
              goto LABEL_368;
LABEL_333:
            v141 = 0;
            if ((a5 & 1) == 0)
            {
LABEL_344:
              v69 = cf;
              goto LABEL_345;
            }
            v69 = cf;
            if (LOBYTE(v196[0]))
              goto LABEL_345;
            *((_BYTE *)segPumpEnsureAndGetSessionDataPrivateData(*(const void **)(DerivedStorage + 7896)) + 16) = 1;
            *(_DWORD *)(DerivedStorage + 7824) = 0;
            v142 = *(const void **)(DerivedStorage + 7832);
            if (v142)
            {
              CFRelease(v142);
              *(_QWORD *)(DerivedStorage + 7832) = 0;
            }
            SessionDataRequest = segPumpSendNextSessionDataRequest(DerivedStorage, *(_QWORD *)(DerivedStorage + 384), v196);
            if (!(_DWORD)SessionDataRequest)
            {
              if (LOBYTE(v196[0]))
              {
                v141 = 0;
                goto LABEL_345;
              }
              segPumpResetConnection(DerivedStorage, DerivedStorage + 7760);
              if (*(uint64_t *)(DerivedStorage + 9624) >= 1)
              {
                v143 = FigGetUpTimeNanoseconds() - *(_QWORD *)(DerivedStorage + 9624);
                if (v143 >= 1)
                  FigReportingAgentStatsSetIntValue(*(_QWORD *)(DerivedStorage + 9048), 0x1E301B798, 0x1E301DAD8, v143 / 0xF4240uLL);
                v141 = 1;
                v68 = v162;
                goto LABEL_344;
              }
              v141 = 1;
LABEL_345:
              v21 = 0;
              if (v141)
LABEL_346:
                dispatch_group_leave(*(dispatch_group_t *)(DerivedStorage + 7744));
LABEL_347:
              v76 = 0;
              v12 = v137;
              v28 = v165;
              goto LABEL_213;
            }
LABEL_368:
            v21 = SessionDataRequest;
            v149 = 1;
LABEL_371:
            v68 = v162;
            v69 = cf;
            if (v149)
              goto LABEL_346;
            goto LABEL_347;
          }
          if (theBuffer && !CMBlockBufferIsEmpty(theBuffer))
          {
            v137 = v161;
            v139 = *(OpaqueCMBlockBuffer **)(DerivedStorage + 7872);
            if (!v139)
            {
              v140 = (const __CFAllocator *)FigGetAllocatorForMedia();
              SessionDataRequest = CMBlockBufferCreateEmpty(v140, 0, 0, (CMBlockBufferRef *)(DerivedStorage + 7872));
              if ((_DWORD)SessionDataRequest)
                goto LABEL_368;
              v139 = *(OpaqueCMBlockBuffer **)(DerivedStorage + 7872);
            }
            SessionDataRequest = CMBlockBufferAppendBufferReference(v139, theBuffer, 0, dataLength, 0);
            v68 = v162;
            if ((_DWORD)SessionDataRequest)
              goto LABEL_368;
          }
          v137 = v161;
          if ((a5 & 1) == 0)
          {
            v141 = 0;
            goto LABEL_344;
          }
          if (*(_QWORD *)(DerivedStorage + 7872))
          {
            segPumpParseSessionDataFromConnection((uint64_t)v159, DerivedStorage, v39);
            goto LABEL_333;
          }
          v149 = 1;
        }
        else
        {
          v137 = v161;
          v149 = 0;
        }
        v21 = FigSignalErrorAt();
        goto LABEL_371;
      }
      goto LABEL_35;
    }
  }
  v12 = v161;
  v68 = v162;
  if (!*(_BYTE *)(v39 + 859))
  {
    v21 = 0;
LABEL_163:
    v76 = 0;
    goto LABEL_212;
  }
  if (FigCFHTTPIsStatusCodeRedirect(0))
  {
    v69 = cf;
    if (cf)
    {
      if (dword_1EE2A31E8)
      {
        LODWORD(v184) = 0;
        type[0] = OS_LOG_TYPE_DEFAULT;
        v70 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        v71 = v184;
        if (os_log_type_enabled(v70, type[0]))
          v72 = v71;
        else
          v72 = v71 & 0xFFFFFFFE;
        if (v72)
        {
          v73 = &stru_1E2FD85F8;
          if (DerivedStorage && *(_QWORD *)(DerivedStorage + 8760))
            v73 = *(const __CFString **)(DerivedStorage + 8760);
          v74 = *(_QWORD *)v39;
          v75 = v28;
          if (!*(_BYTE *)(DerivedStorage + 339))
            v75 = CFSTR("[]");
          *(_DWORD *)v185 = 136316418;
          *(_QWORD *)&v185[4] = "segPumpHandleCustomURLResponse";
          v186 = 2114;
          v187 = v73;
          v188 = 2048;
          v189 = v74;
          v190 = 2114;
          v191 = (uint64_t)v75;
          v192 = 1024;
          v193 = 0;
          v194 = 2114;
          v195 = cf;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      segPumpStreamUpdateIndexFileURLWithResponse(DerivedStorage, v39, cf);
      v116 = segPumpSendIndexFileRequest((uint64_t)v159, DerivedStorage, v39);
    }
    else
    {
      v116 = FigSignalErrorAt();
    }
    v21 = v116;
    v76 = 0;
    goto LABEL_213;
  }
  if (!*(_QWORD *)(v39 + 456))
  {
    v83 = FigGetUpTimeNanoseconds();
    v84 = v83 - *(_QWORD *)(v39 + 432);
    *(_QWORD *)(v39 + 456) = v83;
    *(_QWORD *)(v39 + 464) = v84;
    *(_DWORD *)(DerivedStorage + 8460) = 0;
    segPumpUpdateNetworkCostHasHighSpeedHighPower(DerivedStorage);
  }
  if ((_DWORD)v160)
  {
    *(_BYTE *)(v39 + 859) = 0;
    v85 = segPumpHandleIndexFileNetworkError(v159, v39, 0, v160, Domain, v162);
    v76 = 0;
    if ((_DWORD)v85)
      v21 = v85;
    else
      v21 = 0;
    goto LABEL_212;
  }
  segPumpStreamUpdateIndexFileURLWithResponse(DerivedStorage, v39, v153);
  if (theBuffer)
  {
    if (!*(_QWORD *)(v39 + 520))
    {
      v117 = (const __CFAllocator *)FigGetAllocatorForMedia();
      CMBlockBufferCreateEmpty(v117, 0, 0, (CMBlockBufferRef *)(v39 + 520));
    }
    if (dataLength)
    {
      Empty = CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)(v39 + 520), theBuffer, 0, 0, 0);
      if ((_DWORD)Empty)
        goto LABEL_210;
    }
    v118 = segPumpVerifyM3UPlaylist((uint64_t)v159, DerivedStorage, v39);
    if ((_DWORD)v118)
    {
      v21 = v118;
      if (dword_1EE2A31E8)
      {
        LODWORD(v184) = 0;
        type[0] = OS_LOG_TYPE_DEFAULT;
        v144 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        v145 = v184;
        if (os_log_type_enabled(v144, type[0]))
          v146 = v145;
        else
          v146 = v145 & 0xFFFFFFFE;
        if (v146)
        {
          v147 = &stru_1E2FD85F8;
          if (DerivedStorage && *(_QWORD *)(DerivedStorage + 8760))
            v147 = *(const __CFString **)(DerivedStorage + 8760);
          v148 = *(_QWORD *)v39;
          *(_DWORD *)v185 = 136315650;
          *(_QWORD *)&v185[4] = "segPumpHandleCustomURLResponse";
          v186 = 2114;
          v187 = v147;
          v188 = 2048;
          v189 = v148;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      v76 = 0;
      goto LABEL_127;
    }
  }
  if ((a5 & 1) == 0)
  {
    v21 = 0;
    goto LABEL_211;
  }
  if (!*(_QWORD *)(v39 + 520))
  {
    Empty = FigSignalErrorAt();
    goto LABEL_210;
  }
  v76 = FigCFHTTPCreateHTTPMessageFromHTTPResponseHeaders(v163);
  *(_BYTE *)(v39 + 859) = 0;
  *(_QWORD *)(v39 + 448) = FigGetUpTimeNanoseconds();
  *(_DWORD *)(v39 + 472) = 0;
  v119 = *(const void **)(v39 + 480);
  if (v119)
  {
    CFRelease(v119);
    *(_QWORD *)(v39 + 480) = 0;
  }
  *(_BYTE *)(v39 + 858) = 1;
  *(_BYTE *)(v39 + 867) = 0;
  FigHTTPStopAndReleaseTimer((dispatch_object_t *)(v39 + 504));
  segPumpCheckAndUpdateLowLatencyServerCompliance(DerivedStorage, 0, a7);
  v120 = segPumpParseIndexFile2(v159, DerivedStorage, v39, v76, 1, 0, 0);
  v69 = cf;
  if (!(_DWORD)v120)
    goto LABEL_310;
LABEL_272:
  v21 = v120;
LABEL_213:
  if (v178)
    CFRelease(v178);
  if (theBuffer)
    CFRelease(theBuffer);
  if (v68)
    CFRelease(v68);
  if (v69)
    CFRelease(v69);
  if (v76)
    CFRelease(v76);
  if ((_DWORD)v21)
    goto LABEL_243;
LABEL_244:
  if (v168)
    CFRelease(v168);
  if (v172)
    CFRelease(v172);
  if (v169)
    CFRelease(v169);
  if (v170)
    CFRelease(v170);
  if (v28)
    CFRelease(v28);
  if (v175)
    CFRelease(v175);
  if (v173)
    CFRelease(v173);
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  if (v171)
    CFRelease(v171);
  if (v167)
    CFRelease(v167);
  segPumpUnlockAndSendAllPendingNotifications();
  if (v177)
    CFRelease(v177);
}

uint64_t segPumpHandleCryptKeyNetworkError(uint64_t a1, uint64_t a2, const void *a3, int a4, const __CFString *a5, const void *a6)
{
  uint64_t DerivedStorage;
  uint64_t v13;
  uint64_t CryptKeyCommonData;
  uint64_t ErrorFromHTTPRequestIfAvailable;
  void *v16;
  const void *v17;
  _BYTE *v18;
  uint64_t v19;
  int Code;
  const __CFDictionary *v21;
  uint64_t CommonActionForNetworkError;
  __CFError *v23;
  uint64_t v24;
  const __CFAllocator *AllocatorForMedia;
  __CFError *v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  const void *v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  unsigned int (*v36)(uint64_t, uint64_t, uint64_t, uint64_t *, _QWORD);
  uint64_t v37;
  void (*v38)(uint64_t, _QWORD, void *);
  uint64_t v39;
  _QWORD *v40;
  unsigned int (*v41)(uint64_t, uint64_t, uint64_t, uint64_t *, _QWORD);
  uint64_t v42;
  void (*v43)(uint64_t, _QWORD, void *);
  uint64_t v44;
  CFTypeRef cf;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v47 = 0;
  v48 = 0;
  cf = 0;
  if (a3)
  {
    v13 = DerivedStorage;
    CryptKeyCommonData = segPumpGetCryptKeyCommonData(a3, &v48, &v47);
    if ((_DWORD)CryptKeyCommonData)
      return CryptKeyCommonData;
    ++*(_DWORD *)(a2 + 608);
    ErrorFromHTTPRequestIfAvailable = segPumpCreateErrorFromHTTPRequestIfAvailable(*(_QWORD *)(a2 + 560), a4, a5, a6, (uint64_t *)&cf);
    v16 = (void *)cf;
    if ((_DWORD)ErrorFromHTTPRequestIfAvailable)
      goto LABEL_66;
    v17 = *(const void **)(a2 + 616);
    *(_QWORD *)(a2 + 616) = cf;
    if (v16)
      CFRetain(v16);
    v18 = (_BYTE *)(v13 + 8176);
    if (v17)
      CFRelease(v17);
    v19 = *(_QWORD *)(a2 + 560);
    v49 = 0;
    v50 = 0;
    Code = CFErrorGetCode((CFErrorRef)v16);
    CFErrorGetDomain((CFErrorRef)v16);
    v21 = CFErrorCopyUserInfo((CFErrorRef)v16);
    if (!*(_QWORD *)(*(_QWORD *)(v13 + 16 * *(_QWORD *)a2 + 384) + 16))
    {
      v24 = 0;
      v31 = 0;
      v30 = 0;
      goto LABEL_35;
    }
    if (!*(_BYTE *)(v13 + 322))
    {
      v24 = 0;
      v31 = 0;
      v30 = 0;
      v50 = 0;
      goto LABEL_35;
    }
    if (Code == -16833)
    {
      v49 = 3;
    }
    else
    {
      CommonActionForNetworkError = segPumpGetCommonActionForNetworkError((__CFError *)v16, &v50, &v49);
      if ((_DWORD)CommonActionForNetworkError)
      {
        v30 = CommonActionForNetworkError;
        goto LABEL_79;
      }
      v23 = 0;
      v24 = v50;
      if (v50 == 3)
      {
LABEL_19:
        segPumpModifyErrorActionIfCurrentAlternateIsLastValidAlternate(v13, (_QWORD *)a2, &v50, &v49);
        v24 = v50;
        goto LABEL_20;
      }
      if (v50 == 8)
      {
LABEL_20:
        v28 = *v18;
        if (*v18 || (unint64_t)(v24 - 9) < 0xFFFFFFFFFFFFFFFELL)
        {
          if (v24 != 3)
            goto LABEL_27;
        }
        else
        {
          v50 = 3;
        }
        if (*(_BYTE *)(v13 + 8177))
        {
          v24 = 3;
        }
        else
        {
          v24 = 6;
          v50 = 6;
        }
LABEL_27:
        if (*(_BYTE *)(v13 + 9480))
        {
          if (v28
            && *(_QWORD *)(v13 + 8096)
            && !segPumpIsAlternateLastValidAlternate(v13, (_QWORD *)a2, *(_QWORD *)(v13 + 8144), 0))
          {
            v24 = 7;
          }
          else
          {
            v24 = 6;
          }
          v50 = v24;
        }
        v29 = 0;
        v30 = 0;
        v31 = v49;
        if (!v23)
          goto LABEL_35;
        goto LABEL_34;
      }
    }
    v50 = 1;
    if (v19)
    {
      v23 = 0;
      goto LABEL_19;
    }
    AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    v26 = CFErrorCreate(AllocatorForMedia, CFSTR("CoreMediaErrorDomain"), -12938, v21);
    if (v26)
    {
      v23 = v26;
      v27 = segPumpGetCommonActionForNetworkError(v26, &v50, &v49);
      if ((_DWORD)v27)
      {
        v29 = v27;
        v24 = 0;
        v31 = 0;
LABEL_34:
        CFRelease(v23);
        v30 = v29;
LABEL_35:
        if (v21)
          CFRelease(v21);
        if ((_DWORD)v30)
        {
          v16 = (void *)cf;
          if (!cf)
            return v30;
          goto LABEL_68;
        }
        if (v24 == 1)
        {
          segPumpResetConnectionByPreservingConnectionStats(v13, a2 + 544);
          v30 = segPumpRequestCustomURLForCryptKey(v13, a2, *(const void **)(a2 + 248), 0);
          v16 = (void *)cf;
          if (!(_DWORD)v30)
          {
            segPumpAppendErrorLogEntryWithCFError(a1, v13, a2, (const __CFURL **)(a2 + 544), (CFErrorRef)cf, 3u, 3u);
            if (!v16)
              return v30;
            goto LABEL_68;
          }
          goto LABEL_67;
        }
        v32 = *(const void **)(a2 + 248);
        if (v32)
        {
          CFRelease(v32);
          *(_QWORD *)(a2 + 248) = 0;
        }
        v33 = v47;
        *(_BYTE *)(v47 + 145) = 0;
        if (*(_BYTE *)(v13 + 9480))
        {
          v16 = (void *)cf;
        }
        else
        {
          if (!v24)
            *(_BYTE *)(v33 + 144) = 1;
          v16 = (void *)cf;
          LOBYTE(v50) = 0;
          if (*(_BYTE *)(v33 + 88))
          {
            v34 = *(_QWORD *)(v33 + 64);
            if (v34)
            {
              v35 = *(_QWORD **)(CMBaseObjectGetVTable() + 16);
              if (*v35 >= 6uLL)
              {
                v36 = (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t *, _QWORD))v35[20];
                if (v36)
                {
                  if (!v36(v34, 2, 1, &v50, 0))
                  {
                    if ((_BYTE)v50)
                    {
                      v37 = *(_QWORD *)(v33 + 64);
                      v38 = *(void (**)(uint64_t, _QWORD, void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                           + 56);
                      if (v38)
                        v38(v37, *MEMORY[0x1E0CA31E0], v16);
                    }
                  }
                }
              }
            }
          }
          if (*(_BYTE *)(v33 + 128))
          {
            v39 = *(_QWORD *)(v33 + 104);
            if (v39)
            {
              v40 = *(_QWORD **)(CMBaseObjectGetVTable() + 16);
              if (*v40 >= 6uLL)
              {
                v41 = (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t *, _QWORD))v40[20];
                if (v41)
                {
                  if (!v41(v39, 2, 1, &v50, 0) && (_BYTE)v50)
                  {
                    v42 = *(_QWORD *)(v33 + 104);
                    v43 = *(void (**)(uint64_t, _QWORD, void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                         + 56);
                    if (v43)
                      v43(v42, *MEMORY[0x1E0CA31E0], v16);
                  }
                }
              }
            }
          }
          v44 = v47;
          CryptKeyReleaseAndClearVideoDecryptor(v47);
          CryptKeyReleaseAndClearAudioDecryptor(v44);
        }
        ErrorFromHTTPRequestIfAvailable = segPumpHandleCommonNetworkError(a1, a2, v24, v31, (const __CFURL **)(a2 + 544), 2u, v16);
LABEL_66:
        v30 = ErrorFromHTTPRequestIfAvailable;
LABEL_67:
        if (!v16)
          return v30;
LABEL_68:
        CFRelease(v16);
        return v30;
      }
      goto LABEL_19;
    }
    v30 = FigSignalErrorAt();
    if (!(_DWORD)v30)
    {
      v31 = v49;
      v24 = v50;
      goto LABEL_35;
    }
LABEL_79:
    v24 = 0;
    v31 = 0;
    goto LABEL_35;
  }
  return FigSignalErrorAt();
}

uint64_t segPumpCryptSetKey(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, int a6, const void *a7, uint64_t a8)
{
  uint64_t CryptKeyCommonData;
  CFTypeRef v17;
  int KeySystem;
  _BYTE *v19;
  uint64_t v20;
  _QWORD *v21;
  CFIndex Length;
  int CryptAlgForKey;
  uint64_t v24;
  uint64_t result;
  uint64_t v26;
  void (*v27)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD);
  uint64_t (*v28)(uint64_t, _QWORD, _QWORD);
  uint64_t (*v29)(uint64_t, _QWORD, const void *);
  _QWORD *v30;
  uint64_t (*v31)(uint64_t, const void *, uint64_t);
  const void *Identifier;
  _QWORD *v33;
  uint64_t (*v34)(uint64_t, uint64_t, uint64_t, char *, _QWORD);
  uint64_t AllocatorForMedia;
  uint64_t v36;
  unsigned int (*v37)(uint64_t, _QWORD, uint64_t, uint64_t);
  uint64_t v38;
  uint64_t v39;
  unsigned int (*v40)(uint64_t, _QWORD, uint64_t, uint64_t);
  char v41;
  uint64_t v42;
  uint64_t v43;

  v42 = 0;
  v43 = 0;
  CryptKeyCommonData = segPumpGetCryptKeyCommonData(a4, &v43, &v42);
  if ((_DWORD)CryptKeyCommonData)
    goto LABEL_16;
  FigHTTPStopAndReleaseTimer((dispatch_object_t *)(a3 + 640));
  if (a4 && FigContentKeySpecifierGetKeySystem((uint64_t)a4) == 2)
  {
    if (a7)
      v17 = CFRetain(a7);
    else
      v17 = 0;
    *(_QWORD *)(v42 + 48) = v17;
    Length = CFDataGetLength((CFDataRef)a7);
    CryptAlgForKey = segPumpGetCryptAlgForKey((uint64_t)a4);
    if (Length == FigCryptGetKeySize(CryptAlgForKey))
    {
      v19 = (_BYTE *)v42;
      *(_BYTE *)(v42 + 144) = 1;
      goto LABEL_12;
    }
    segPumpAppendErrorLogEntry(a1, a2, a3, (const __CFURL **)(a3 + 544), -12885, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Invalid crypt key length"), 0, 0, 3u, 1u);
LABEL_15:
    CryptKeyCommonData = FigSignalErrorAt();
    goto LABEL_16;
  }
  KeySystem = FigContentKeySpecifierGetKeySystem((uint64_t)a4);
  v19 = (_BYTE *)v42;
  if (KeySystem != 1)
    goto LABEL_12;
  v41 = 0;
  if (*(_QWORD *)(v42 + 80) == a5)
  {
    v20 = *(_QWORD *)(v42 + 64);
    *(_QWORD *)(v42 + 80) = 0;
    v21 = v19 + 96;
    v19[88] = 0;
  }
  else
  {
    if (*(_QWORD *)(v42 + 120) != a5)
    {
LABEL_35:
      v24 = 0;
      goto LABEL_17;
    }
    v20 = *(_QWORD *)(v42 + 104);
    *(_QWORD *)(v42 + 120) = 0;
    v21 = v19 + 136;
    v19[128] = 0;
  }
  *v21 = 0;
  if (!v20)
    goto LABEL_35;
  if (!a6)
  {
    v30 = *(_QWORD **)(CMBaseObjectGetVTable() + 16);
    if (*v30 >= 4uLL && (v31 = (uint64_t (*)(uint64_t, const void *, uint64_t))v30[12]) != 0)
      v24 = v31(v20, a7, a8);
    else
      v24 = 4294954514;
    if (!*(_BYTE *)(a2 + 322) || !(_DWORD)v24)
      goto LABEL_47;
LABEL_17:
    result = 4294951670;
    if ((_DWORD)v24 == -15626)
      return result;
    goto LABEL_20;
  }
  v28 = *(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
  if (!v28)
  {
LABEL_53:
    v24 = 4294954514;
    goto LABEL_17;
  }
  CryptKeyCommonData = v28(v20, *MEMORY[0x1E0CA3238], *MEMORY[0x1E0C9AE50]);
  if ((_DWORD)CryptKeyCommonData)
    goto LABEL_16;
  v29 = *(uint64_t (**)(uint64_t, _QWORD, const void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
  if (v29)
    v24 = v29(v20, *MEMORY[0x1E0CA31F0], a7);
  else
    v24 = 4294954514;
  if (*(_BYTE *)(a2 + 322) && (_DWORD)v24)
    goto LABEL_17;
  if (*(_QWORD *)(a2 + 296))
  {
    if (*(_BYTE *)(a2 + 321))
    {
      if (!*(_BYTE *)(v42 + 146))
      {
        Identifier = (const void *)FigContentKeySpecifierGetIdentifier((uint64_t)a4);
        CryptKeyCommonData = segPumpSaveCryptKeyToCache(a2, Identifier);
        if ((_DWORD)CryptKeyCommonData)
          goto LABEL_16;
      }
    }
  }
LABEL_47:
  v33 = *(_QWORD **)(CMBaseObjectGetVTable() + 16);
  if (*v33 < 6uLL)
    goto LABEL_53;
  v34 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, char *, _QWORD))v33[20];
  if (!v34)
    goto LABEL_53;
  CryptKeyCommonData = v34(v20, 2, 3, &v41, 0);
  if ((_DWORD)CryptKeyCommonData)
    goto LABEL_16;
  if (!*(_QWORD *)(v42 + 80) && !*(_QWORD *)(v42 + 120))
  {
    *(_BYTE *)(v42 + 144) = 1;
    if (*(_BYTE *)(a2 + 322))
    {
      if (segPumpCryptKeyIsLowValueFairPlayStreamingKey((uint64_t)a4))
      {
        AllocatorForMedia = FigGetAllocatorForMedia();
        v36 = v42;
        v37 = *(unsigned int (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                               + 48);
        if (!v37)
          goto LABEL_15;
        if (v37(v20, *MEMORY[0x1E0CA31D8], AllocatorForMedia, v36 + 48))
          goto LABEL_15;
        v38 = FigGetAllocatorForMedia();
        v39 = v42;
        v40 = *(unsigned int (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                               + 48);
        if (!v40 || v40(v20, *MEMORY[0x1E0CA31C8], v38, v39 + 56))
          goto LABEL_15;
      }
    }
  }
  v19 = (_BYTE *)v42;
LABEL_12:
  if (v19[144])
  {
    CryptKeyCommonData = segPumpContinueAfterKeyFetched(a1, a2, (_QWORD *)a3, a4);
LABEL_16:
    v24 = CryptKeyCommonData;
    goto LABEL_17;
  }
  v24 = 0;
LABEL_20:
  v26 = *(_QWORD *)(a2 + 9048);
  if (v26)
  {
    v27 = *(void (**)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                 + 16)
                                                                                     + 56);
    if (v27)
      v27(v26, CFSTR("playerStats"), CFSTR("FetchingKey"), 0, 0);
  }
  return v24;
}

void segPumpPongCallback(uint64_t a1, double a2, uint64_t a3, int a4)
{
  uint64_t UpTimeNanoseconds;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, const __CFString *, _QWORD);
  CFNumberRef v11;
  uint64_t v12;
  void (*v13)(uint64_t, const __CFString *, CFNumberRef);
  _QWORD *v14;
  CFTypeRef cf;

  v14 = 0;
  cf = 0;
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  if (!segPumpLockAndCopyPumpFromRetainProxy(a1, &cf, (uint64_t *)&v14))
  {
    v8 = (uint64_t)v14;
    if (a4)
    {
      v14[1073] = 0;
      *(_OWORD *)(v8 + 8600) = 0u;
      v9 = *(_QWORD *)(v8 + 9560);
      if (v9)
      {
        v10 = *(void (**)(uint64_t, const __CFString *, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                         + 56);
        if (v10)
          v10(v9, CFSTR("AfmfpbProperty_RTT"), 0);
      }
    }
    else
    {
      v14[1076] = UpTimeNanoseconds;
      *(_QWORD *)(v8 + 8592) = (*(_QWORD *)(v8 + 8584) + 2 * *(_QWORD *)(v8 + 8592)) / 3;
      *(_QWORD *)(v8 + 8584) = (uint64_t)(a2 * 1000000000.0);
      if (*(_QWORD *)(v8 + 9560))
      {
        v11 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, (const void *)(v8 + 8584));
        v12 = v14[1195];
        v13 = *(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                              + 56);
        if (v13)
          v13(v12, CFSTR("AfmfpbProperty_RTT"), v11);
        if (v11)
          CFRelease(v11);
      }
    }
    segPumpResumeRoundTripMonitoring(v14);
  }
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
}

_QWORD *segPumpFindCryptKeyCommonDataForRequestID(uint64_t a1, uint64_t a2)
{
  CFIndex v4;
  const __CFArray *Count;
  _QWORD *result;

  v4 = 0;
  while (1)
  {
    Count = *(const __CFArray **)(a1 + 7688);
    if (Count)
      Count = (const __CFArray *)CFArrayGetCount(Count);
    if (v4 >= (uint64_t)Count)
      break;
    result = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 7688), v4);
    if (result[10] != a2)
    {
      ++v4;
      if (result[15] != a2)
        continue;
    }
    return result;
  }
  return 0;
}

const void *segPumpFindSessionDataEntryForRequestID(uint64_t a1, uint64_t a2)
{
  CFIndex v4;
  const __CFArray *SessionDataSpecifiers;
  const __CFArray *v6;
  const void *ValueAtIndex;

  if (*(_QWORD *)(a1 + 48))
  {
    v4 = 0;
    while (1)
    {
      SessionDataSpecifiers = (const __CFArray *)FigMultivariantPlaylistGetSessionDataSpecifiers(*(_QWORD *)(a1 + 48));
      if (SessionDataSpecifiers)
        SessionDataSpecifiers = (const __CFArray *)CFArrayGetCount(SessionDataSpecifiers);
      if (v4 >= (uint64_t)SessionDataSpecifiers)
        break;
      v6 = (const __CFArray *)FigMultivariantPlaylistGetSessionDataSpecifiers(*(_QWORD *)(a1 + 48));
      ValueAtIndex = CFArrayGetValueAtIndex(v6, v4++);
      if (*((_QWORD *)segPumpEnsureAndGetSessionDataPrivateData(ValueAtIndex) + 3) == a2)
        return ValueAtIndex;
    }
  }
  return 0;
}

uint64_t segPumpRequestCustomURLForCryptKey(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  uint64_t CryptKeyCommonData;
  int v8;
  const __CFAllocator *AllocatorForMedia;
  __CFArray *Mutable;
  __CFArray *v11;
  _BOOL4 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFString *Identifier;
  const __CFAllocator *v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, _QWORD, uint64_t, CFTypeRef *);
  NSObject *v21;
  uint64_t v22;
  void (*v23)(uint64_t, _QWORD, uint64_t, CFTypeRef *);
  uint64_t URLGuts;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v27;
  CFTypeRef v28;
  CFTypeRef cf;
  uint64_t v30;
  _QWORD v31[29];

  v31[27] = *MEMORY[0x1E0C80C00];
  v30 = 0;
  v31[0] = 0;
  v28 = 0;
  cf = 0;
  CryptKeyCommonData = segPumpGetCryptKeyCommonData(a3, v31, &v30);
  if ((_DWORD)CryptKeyCommonData)
    goto LABEL_40;
  if (FigContentKeySpecifierGetKeySystem((uint64_t)a3) != 1)
  {
    if (a3 && FigContentKeySpecifierGetKeySystem((uint64_t)a3) == 2)
    {
      v14 = 0;
      v11 = 0;
      v13 = *(_QWORD *)(v31[0] + 40);
      v15 = v31[0] + 48;
    }
    else
    {
      v15 = 0;
      v14 = 0;
      v13 = 0;
      v11 = 0;
    }
    v12 = 1;
    goto LABEL_11;
  }
  if (!*(_QWORD *)(v30 + 64))
  {
    CryptKeyCommonData = FigSignalErrorAt();
LABEL_40:
    URLGuts = CryptKeyCommonData;
    v11 = 0;
    goto LABEL_30;
  }
  v8 = *(unsigned __int8 *)(v30 + 88);
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  Mutable = CFArrayCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B378]);
  v11 = Mutable;
  if (!Mutable)
  {
    URLGuts = FigSignalErrorAt();
    goto LABEL_30;
  }
  v12 = v8 != 0;
  CFArrayAppendValue(Mutable, CFSTR("com.apple.streamingkeydelivery.contentkey"));
  CFArrayAppendValue(v11, CFSTR("com.apple.streamingkeydelivery.persistentcontentkey"));
  v13 = *(_QWORD *)(v30 + 64);
  v14 = *(_QWORD *)(v30 + 96);
  v15 = v30 + 80;
LABEL_11:
  Identifier = (const __CFString *)FigContentKeySpecifierGetIdentifier((uint64_t)a3);
  if (Identifier)
  {
    v17 = (const __CFAllocator *)FigGetAllocatorForMedia();
    Identifier = (const __CFString *)CFURLCreateWithString(v17, Identifier, 0);
  }
  if (!v12)
  {
LABEL_20:
    if (*(_QWORD *)(v30 + 104) && *(_BYTE *)(v30 + 128))
    {
      v22 = FigGetAllocatorForMedia();
      v23 = *(void (**)(uint64_t, _QWORD, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                         + 48);
      if (v23)
        v23(v13, *MEMORY[0x1E0CA3230], v22, &v28);
      LOBYTE(v27) = 0;
      URLGuts = segPumpCustomURLLoaderGetURLGuts(a1, Identifier, *(_QWORD *)(v30 + 104), v11, a4, 0, 0, *(_QWORD *)(v30 + 136), v27, 0, 0, v30 + 120);
      if ((_DWORD)URLGuts || !dword_1EE2A31E8)
      {
LABEL_28:
        if (!Identifier)
          goto LABEL_30;
        goto LABEL_29;
      }
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    URLGuts = 0;
    goto LABEL_28;
  }
  v18 = segPumpCustomURLLoaderGetURLGuts(a1, Identifier, v13, v11, a4, 0, 0, v14, 0, 0, 0, v15);
  if (!(_DWORD)v18)
  {
    if (v13)
    {
      v19 = FigGetAllocatorForMedia();
      v20 = *(void (**)(uint64_t, _QWORD, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                         + 48);
      if (v20)
        v20(v13, *MEMORY[0x1E0CA3230], v19, &cf);
    }
    if (dword_1EE2A31E8)
    {
      v21 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    goto LABEL_20;
  }
  URLGuts = v18;
  if (Identifier)
LABEL_29:
    CFRelease(Identifier);
LABEL_30:
  if (cf)
    CFRelease(cf);
  if (v28)
    CFRelease(v28);
  if (v11)
    CFRelease(v11);
  return URLGuts;
}

uint64_t segPumpSaveCryptKeyToCache(uint64_t a1, const void *a2)
{
  uint64_t BlockBufferWithCFDataNoCopy;

  if (!*(_QWORD *)(a1 + 296) || !*(_BYTE *)(a1 + 321))
    return FigSignalErrorAt();
  FigGetAllocatorForMedia();
  BlockBufferWithCFDataNoCopy = FigCreateBlockBufferWithCFDataNoCopy();
  if ((_DWORD)BlockBufferWithCFDataNoCopy)
    return BlockBufferWithCFDataNoCopy;
  else
    return FigStreamingCacheSetCryptKey(*(_QWORD *)(a1 + 296), a2, 0);
}

uint64_t findConnectionFromMediaDownloadTimer(_QWORD *a1, uint64_t a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v11;

  v5 = a1[94];
  if (v5 < 1)
  {
LABEL_6:
    v8 = a1[97];
    if (v8 < 1)
      return 0;
    v6 = 0;
    while (1)
    {
      v9 = *(_QWORD *)(a1[96] + 8 * v6);
      if (v9)
      {
        if (*(_QWORD *)(v9 + 112) == a2)
          break;
      }
      if (v8 == ++v6)
        return 0;
    }
    *a3 = v9;
    v11 = (_QWORD *)a1[96];
  }
  else
  {
    v6 = 0;
    while (1)
    {
      v7 = a1[v6 + 87];
      if (v7)
      {
        if (*(_QWORD *)(v7 + 112) == a2)
          break;
      }
      if (v5 == ++v6)
        goto LABEL_6;
    }
    v11 = a1 + 87;
    *a3 = v7;
  }
  *a4 = v11;
  *a5 = v6;
  return 1;
}

uint64_t segPumpMediaFileCreateDecryptedData(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, OpaqueCMBlockBuffer *a5, size_t a6, char *a7, unsigned __int8 a8, OpaqueCMBlockBuffer *a9)
{
  const void *ContentKeySpecifier;
  uint64_t CryptKeyCommonData;
  uint64_t v17;
  unint64_t TagSize;
  const __CFAllocator *AllocatorForMedia;
  OpaqueCMBlockBuffer *v20;
  CFTypeRef *v21;
  size_t v22;
  const __CFAllocator *v23;
  size_t v24;
  const __CFAllocator *v25;
  OpaqueCMBlockBuffer *v26;
  const __CFAllocator *v27;
  uint64_t v28;
  const __CFAllocator *v29;
  OpaqueCMBlockBuffer *v30;
  const __CFAllocator *v31;
  uint64_t v32;
  const __CFData *IV;
  uint64_t v34;
  size_t v35;
  uint64_t v36;
  UInt8 *v37;
  uint64_t v38;
  int CryptAlgForKey;
  uint64_t BlockSize;
  uint64_t v41;
  unint64_t v42;
  BOOL v43;
  uint64_t v44;
  _BYTE *v45;
  CFTypeRef *v46;
  unint64_t v47;
  void *v48;
  size_t v49;
  uint64_t BlockBuffer;
  _BOOL4 v51;
  uint64_t v52;
  int v53;
  size_t v54;
  uint64_t v55;
  uint64_t v56;
  CMBlockBufferRef *v57;
  const __CFAllocator *v58;
  size_t v59;
  uint64_t appended;
  size_t v61;
  NSObject *v62;
  const UInt8 *BytePtr;
  size_t Length;
  uint64_t v65;
  int v66;
  const void *v67;
  const void *v68;
  BOOL v69;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  CMBlockBufferRef *v72;
  uint64_t v73;
  char *MediaFilePrivateData;
  CMBlockBufferRef blockBufferOut;
  CMBlockBufferRef theBuffer;
  uint64_t v79;
  uint64_t v80;
  size_t dataLength;
  size_t v82;
  char v83;
  char *v84;
  char *v85;
  size_t lengthAtOffsetOut;
  char *dataPointerOut[19];

  dataPointerOut[16] = *(char **)MEMORY[0x1E0C80C00];
  v84 = 0;
  v85 = 0;
  v83 = 0;
  dataLength = 0;
  v82 = 0;
  v79 = 0;
  v80 = 0;
  blockBufferOut = 0;
  theBuffer = 0;
  if (a4)
  {
    if (!a9)
      goto LABEL_95;
    ContentKeySpecifier = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a4);
    CryptKeyCommonData = segPumpGetCryptKeyCommonData(ContentKeySpecifier, &v80, &v79);
    if ((_DWORD)CryptKeyCommonData)
      goto LABEL_96;
    MediaFilePrivateData = (char *)segPumpGetMediaFilePrivateData(a4);
    v17 = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a4);
    if (FigContentKeySpecifierGetEncryptionMethod(v17) != 4)
      goto LABEL_19;
    TagSize = FigCryptGetTagSize(3);
    AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    CryptKeyCommonData = CMBlockBufferCreateEmpty(AllocatorForMedia, 0, 0, &blockBufferOut);
    if ((_DWORD)CryptKeyCommonData)
      goto LABEL_96;
    v21 = (CFTypeRef *)(MediaFilePrivateData + 216);
    v20 = (OpaqueCMBlockBuffer *)*((_QWORD *)MediaFilePrivateData + 27);
    if (v20)
    {
      CryptKeyCommonData = CMBlockBufferAppendBufferReference(blockBufferOut, v20, 0, 0, 0);
      if ((_DWORD)CryptKeyCommonData)
        goto LABEL_96;
      if (*v21)
      {
        CFRelease(*v21);
        *v21 = 0;
      }
    }
    if (a7)
    {
      CryptKeyCommonData = CMBlockBufferAppendBufferReference(blockBufferOut, a5, a6, (size_t)a7, 0);
      if ((_DWORD)CryptKeyCommonData)
        goto LABEL_96;
    }
    if ((a8 & 1) != 0)
    {
      v29 = (const __CFAllocator *)FigGetAllocatorForMedia();
      v30 = blockBufferOut;
      v31 = (const __CFAllocator *)FigGetAllocatorForMedia();
      CryptKeyCommonData = CMBlockBufferCreateContiguous(v29, v30, v31, 0, 0, 0, 0, &theBuffer);
      if ((_DWORD)CryptKeyCommonData)
        goto LABEL_96;
LABEL_18:
      a5 = theBuffer;
      a7 = (char *)CMBlockBufferGetDataLength(theBuffer);
      a6 = 0;
LABEL_19:
      if (MediaFilePrivateData[72])
      {
        if (!a7)
        {
LABEL_35:
          v38 = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a4);
          CryptAlgForKey = segPumpGetCryptAlgForKey(v38);
          BlockSize = FigCryptGetBlockSize(CryptAlgForKey);
          v73 = a2;
          if ((a8 & 1) != 0)
          {
            v41 = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a4);
            if (FigContentKeySpecifierGetEncryptionMethod(v41) == 4)
            {
              v42 = FigCryptGetTagSize(3);
              v43 = (unint64_t)a7 >= v42;
              a7 -= v42;
              if (!v43)
              {
LABEL_95:
                CryptKeyCommonData = FigSignalErrorAt();
                goto LABEL_96;
              }
            }
          }
          else if (!a7)
          {
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
            goto LABEL_95;
          }
          v44 = (uint64_t)a4;
          v45 = (_BYTE *)(a2 + 8193);
          v46 = (CFTypeRef *)(a3 + 840);
          v47 = 0x20000 - 2 * BlockSize;
          v72 = (CMBlockBufferRef *)(MediaFilePrivateData + 208);
          while (1)
          {
            dataPointerOut[0] = 0;
            v83 = 0;
            v48 = (void *)*v46;
            if (*v46)
            {
              v49 = *(_QWORD *)(a3 + 848);
              if (v47 >= v49)
                goto LABEL_46;
              CFRelease(v48);
              *v46 = 0;
            }
            segPumpGetMediaDataMemoryPool(a2);
            BlockBuffer = FigMemoryPoolCreateBlockBuffer();
            if ((_DWORD)BlockBuffer)
              goto LABEL_97;
            v49 = 0;
            *(_QWORD *)(a3 + 848) = 0;
            v48 = *(void **)(a3 + 840);
LABEL_46:
            BlockBuffer = CMBlockBufferGetDataPointer((CMBlockBufferRef)v48, v49, (size_t *)dataPointerOut, 0, &v84);
            if ((_DWORD)BlockBuffer)
              goto LABEL_97;
            if (v45[519])
              v51 = FigMediaSegmentSpecifierGetBytesToRead(v44) > 0;
            else
              v51 = 0;
            v52 = FigCryptDecryptMemory(*(_QWORD *)(v80 + 24), a8 & 1, v51, v85, (size_t)a7, &v82, v84, (size_t)dataPointerOut[0], &dataLength, &v83);
            v28 = v52;
            if ((_DWORD)v52)
            {
              segPumpAppendErrorLogEntry(a1, a2, a3, (const __CFURL **)(*(_QWORD *)(a3 + 696) + 16), (int)v52, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Decryption error"), 0, 0, 0, 2u);
              a7 = 0;
              goto LABEL_86;
            }
            v43 = (unint64_t)a7 >= v82;
            a7 -= v82;
            if (!v43)
            {
              BlockBuffer = FigSignalErrorAt();
LABEL_97:
              appended = BlockBuffer;
LABEL_98:
              v28 = appended;
              goto LABEL_99;
            }
            v85 += v82;
            v53 = a8 & (a7 == 0);
            if (v83)
              v53 = 0;
            MediaFilePrivateData[97] = v53;
            v54 = dataLength;
            if ((a8 & 1) != 0 || dataLength)
            {
              v55 = *(_QWORD *)(a3 + 880);
              if (*v45)
              {
                v56 = FigMediaSegmentSpecifierGetContentKeySpecifier(v44);
                if (FigContentKeySpecifierGetEncryptionMethod(v56) == 4)
                {
                  v57 = (CMBlockBufferRef *)(MediaFilePrivateData + 208);
                  if (!*v72)
                  {
                    v58 = (const __CFAllocator *)FigGetAllocatorForMedia();
                    BlockBuffer = CMBlockBufferCreateEmpty(v58, 0, 0, v72);
                    v57 = (CMBlockBufferRef *)(MediaFilePrivateData + 208);
                    if ((_DWORD)BlockBuffer)
                      goto LABEL_97;
                  }
                  if (dataLength)
                  {
                    BlockBuffer = CMBlockBufferAppendBufferReference(*v72, *(CMBlockBufferRef *)(a3 + 840), *(_QWORD *)(a3 + 848), dataLength, 0);
                    v57 = (CMBlockBufferRef *)(MediaFilePrivateData + 208);
                    if ((_DWORD)BlockBuffer)
                      goto LABEL_97;
                  }
                  if (MediaFilePrivateData[97])
                  {
                    v59 = CMBlockBufferGetDataLength(*v57);
                    if (v59)
                      appended = CMBlockBufferAppendBufferReference(a9, *v57, 0, v59, 0);
                    else
                      appended = 0;
                    if (*v57)
                    {
                      CFRelease(*v57);
                      *v57 = 0;
                    }
                    v47 = 0x20000 - 2 * BlockSize;
                    goto LABEL_79;
                  }
                  v61 = dataLength;
                  v47 = 0x20000 - 2 * BlockSize;
LABEL_74:
                  *(_QWORD *)(a3 + 848) += v61;
                  goto LABEL_80;
                }
                v54 = dataLength;
              }
              if (!v54)
              {
                v61 = 0;
                goto LABEL_74;
              }
              appended = CMBlockBufferAppendBufferReference(a9, *(CMBlockBufferRef *)(a3 + 840), *(_QWORD *)(a3 + 848), v54, 0);
LABEL_79:
              *(_QWORD *)(a3 + 848) += dataLength;
              if ((_DWORD)appended)
                goto LABEL_98;
LABEL_80:
              if (v55 != *(_QWORD *)(a3 + 880))
                goto LABEL_93;
              a2 = v73;
              if (MediaFilePrivateData[97])
              {
LABEL_83:
                if (*v46)
                {
                  CFRelease(*v46);
                  *v46 = 0;
                }
                *(_QWORD *)(a3 + 848) = 0;
                goto LABEL_86;
              }
              goto LABEL_82;
            }
            if (v53)
              goto LABEL_83;
LABEL_82:
            if ((unint64_t)&a7[2 * BlockSize] >= CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(a3 + 840))
                                                       - *(_QWORD *)(a3 + 848))
              goto LABEL_83;
LABEL_86:
            if (!a7 && !v83)
            {
              if ((a8 & 1) != 0 && !MediaFilePrivateData[97])
              {
                v62 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT);
                fig_log_call_emit_and_clean_up_after_send_and_compose();
                v69 = (_DWORD)v28 == -12465;
                v28 = 4294954831;
                if (!v69)
                  goto LABEL_95;
              }
              goto LABEL_99;
            }
          }
        }
      }
      else
      {
        if (!*(_QWORD *)(v80 + 24))
        {
          BytePtr = CFDataGetBytePtr(*(CFDataRef *)(v79 + 48));
          Length = CFDataGetLength(*(CFDataRef *)(v79 + 48));
          v65 = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a4);
          v66 = segPumpGetCryptAlgForKey(v65);
          v67 = (const void *)FigGetAllocatorForMedia();
          v68 = (const void *)FigGetAllocatorForMedia();
          v28 = FigCryptCreateForDecrypt(v66, v67, 0, v68, BytePtr, Length, (_QWORD *)(v80 + 24));
          if ((_DWORD)v28)
            goto LABEL_99;
        }
        v32 = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a4);
        if (FigContentKeySpecifierGetKeySystem(v32) == 1)
          IV = *(const __CFData **)(v79 + 56);
        else
          IV = (const __CFData *)FigMediaSegmentSpecifierGetIV((uint64_t)a4);
        v34 = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a4);
        if (FigContentKeySpecifierGetEncryptionMethod(v34) == 4)
        {
          dataPointerOut[0] = 0;
          lengthAtOffsetOut = 0;
          v35 = FigCryptGetBlockSize(3);
          CryptKeyCommonData = CMBlockBufferGetDataPointer(a5, a6, &lengthAtOffsetOut, 0, dataPointerOut);
          if ((_DWORD)CryptKeyCommonData)
            goto LABEL_96;
          if (lengthAtOffsetOut <= v35)
            goto LABEL_95;
          v28 = FigCryptSetIV(*(_QWORD *)(v80 + 24), dataPointerOut[0]);
          a6 += v35;
          a7 -= v35;
        }
        else
        {
          v36 = *(_QWORD *)(v80 + 24);
          v37 = (UInt8 *)CFDataGetBytePtr(IV);
          CFDataGetLength(IV);
          v28 = FigCryptSetIV(v36, v37);
        }
        if ((_DWORD)v28)
          goto LABEL_99;
        MediaFilePrivateData[72] = 1;
        if (!a7)
          goto LABEL_35;
      }
      dataPointerOut[0] = 0;
      CryptKeyCommonData = CMBlockBufferGetDataPointer(a5, a6, (size_t *)dataPointerOut, 0, &v85);
      if (!(_DWORD)CryptKeyCommonData)
      {
        if (dataPointerOut[0] < a7)
          goto LABEL_95;
        goto LABEL_35;
      }
LABEL_96:
      v28 = CryptKeyCommonData;
      goto LABEL_99;
    }
    v22 = CMBlockBufferGetDataLength(blockBufferOut);
    v23 = (const __CFAllocator *)FigGetAllocatorForMedia();
    v24 = v22 - TagSize;
    CryptKeyCommonData = CMBlockBufferCreateWithBufferReference(v23, blockBufferOut, v22 - TagSize, 0, 0, (CMBlockBufferRef *)v21);
    if ((_DWORD)CryptKeyCommonData)
      goto LABEL_96;
    if (v22 <= TagSize)
    {
LABEL_93:
      v28 = 0;
      goto LABEL_99;
    }
    v25 = (const __CFAllocator *)FigGetAllocatorForMedia();
    v26 = blockBufferOut;
    v27 = (const __CFAllocator *)FigGetAllocatorForMedia();
    v28 = CMBlockBufferCreateContiguous(v25, v26, v27, 0, 0, v24, 0, &theBuffer);
    if (!(_DWORD)v28)
      goto LABEL_18;
LABEL_99:
    if (blockBufferOut)
      CFRelease(blockBufferOut);
  }
  else
  {
    v28 = FigSignalErrorAt();
  }
  if (theBuffer)
    CFRelease(theBuffer);
  return v28;
}

uint64_t segPumpDispatchAsyncMediaDelivery(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6)
{
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  CFTypeRef v15;

  v12 = malloc_type_malloc(0x48uLL, 0x10A00404BD41864uLL);
  if (!v12)
    return 4294954655;
  v13 = v12;
  *v12 = FigRetainProxyRetain();
  v13[1] = a2;
  v14 = *(_QWORD *)(a2 + 880);
  v13[2] = *(_QWORD *)(a2 + 1160);
  v13[3] = v14;
  v13[4] = a3;
  v13[5] = a4;
  v13[6] = -1;
  if (a5)
    v15 = CFRetain(a5);
  else
    v15 = 0;
  v13[7] = v15;
  v13[8] = a6;
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 72), v13, (dispatch_function_t)segPumpDispatchAsyncMediaDeliveryFunc);
  return 0;
}

void segPumpReplaceMediaFileWithDiscontinuity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  const void *MediaEntryForMediaSequence;
  const void *v13;
  uint64_t v14;
  double TimeInSeconds;
  _QWORD *v16;
  int v17[2];
  CFTypeRef cf;

  *(_QWORD *)v17 = 0;
  cf = 0;
  if (!segPumpLockAndCopyPumpFromRetainProxy(a1, &cf, (uint64_t *)v17))
  {
    v10 = 0;
    v11 = *(_QWORD *)v17 + 384;
    do
    {
      if (*(_QWORD *)(*(_QWORD *)v17 + 8416) != v10 && *(_QWORD *)(*(_QWORD *)v11 + 16))
      {
        FigSignalErrorAt();
        goto LABEL_17;
      }
      ++v10;
      v11 += 16;
    }
    while (v10 != 3);
    MediaEntryForMediaSequence = segPumpGetMediaEntryForMediaSequence(*(_QWORD *)(a2 + 56), a5);
    if (MediaEntryForMediaSequence)
    {
      if (*(_BYTE *)(*(_QWORD *)v17 + 8712))
      {
        segPumpMakeDataCallback((uint64_t)cf, (uint64_t *)a2, *(const void **)(*(_QWORD *)v17 + 176), 0, 0x20u, *(_QWORD *)(a2 + 304), MEMORY[0x1E0CA2E18], 0, 0, a7, 0, 0);
      }
      else
      {
        v13 = MediaEntryForMediaSequence;
        *((_BYTE *)segPumpGetMediaFilePrivateData(MediaEntryForMediaSequence) + 99) = 1;
        if (*(const void **)(a2 + 256) == v13 || *(const void **)(a2 + 264) == v13)
          segPumpSetDeliveryStatusForMediaFileAndParts(v13, 1);
        v14 = *(_QWORD *)v17;
        if (*(_BYTE *)(*(_QWORD *)v17 + 8002) && *(_QWORD *)(*(_QWORD *)v17 + 384) == a2)
        {
          *(double *)(a2 + 96) = *(double *)(a2 + 96) - FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v13);
          TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v13);
          v16 = *(_QWORD **)v17;
          *(double *)(*(_QWORD *)v17 + 344) = *(double *)(*(_QWORD *)v17 + 344) - TimeInSeconds;
          segPumpReadyNotification(v16, CFSTR("FBPAL_SeekableTimeRangeChanged"), 0);
          segPumpReadyNotification(*(_QWORD **)v17, CFSTR("FBP_DurationChanged"), 0);
          v14 = *(_QWORD *)v17;
        }
        segPumpCancelMediaFileReadAndResetData(v14, a2, 0, 0);
        *(_BYTE *)(a2 + 403) = 1;
        segPumpDeliverNextMediaForSingleStream(cf, *(_QWORD *)v17, a2);
      }
    }
  }
LABEL_17:
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
}

void segPumpDispatchAsyncMediaDeliveryFunc(_QWORD *a1)
{
  void (*v2)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  const void *v3;

  v2 = (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))a1[8];
  if (v2)
    v2(*a1, a1[1], a1[2], a1[3], a1[4], a1[5], a1[7]);
  FigRetainProxyRelease();
  v3 = (const void *)a1[7];
  if (v3)
    CFRelease(v3);
  free(a1);
}

uint64_t segPumpCreateMapMediaBBuf(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v6;
  void *v7;
  uint64_t appended;
  uint64_t v9;
  void *v11;
  CMBlockBufferRef blockBufferOut;

  v11 = 0;
  blockBufferOut = 0;
  v6 = segPumpCopyMapEntryFromCache(a1, a2, a3, &v11);
  v7 = v11;
  if ((_DWORD)v6)
  {
    v9 = v6;
    if (v11)
LABEL_9:
      CFRelease(v7);
  }
  else
  {
    if (v11)
    {
      appended = CMBlockBufferCreateEmpty(*(CFAllocatorRef *)(a1 + 56), 2u, 0, &blockBufferOut);
      if ((_DWORD)appended
        || !CMBlockBufferIsEmpty((CMBlockBufferRef)v7)
        && (appended = CMBlockBufferAppendBufferReference(blockBufferOut, (CMBlockBufferRef)v7, 0, 0, 0),
            (_DWORD)appended)
        || !CMBlockBufferIsEmpty((CMBlockBufferRef)*a4)
        && (appended = CMBlockBufferAppendBufferReference(blockBufferOut, (CMBlockBufferRef)*a4, 0, 0, 0),
            (_DWORD)appended))
      {
        v9 = appended;
      }
      else
      {
        CFRelease(*a4);
        v9 = 0;
        *a4 = blockBufferOut;
        blockBufferOut = 0;
      }
      goto LABEL_9;
    }
    v9 = FigSignalErrorAt();
  }
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  return v9;
}

uint64_t segPumpEnsureAndSetupBasicAESProtector(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t AllocatorForMedia;
  uint64_t result;
  uint64_t v6;
  uint64_t (*v7)(uint64_t, const __CFString *, uint64_t);

  v3 = (uint64_t *)(a1 + 248);
  v2 = *(_QWORD *)(a1 + 248);
  if (!v2)
  {
    AllocatorForMedia = FigGetAllocatorForMedia();
    result = FigCPEProtectorCreateForScheme(AllocatorForMedia, CFSTR("com.apple.basicAES"), 0, (uint64_t)v3);
    if ((_DWORD)result)
      return result;
    v2 = *v3;
  }
  v6 = *(_QWORD *)(a1 + 9520);
  v7 = *(uint64_t (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
  if (v7)
    return v7(v2, CFSTR("NeroTransport"), v6);
  else
    return 4294954514;
}

void segPumpGetCryptorInfoFromBBuf(const void *a1, const __CFString *a2, _QWORD *a3, _DWORD *a4)
{
  CFTypeRef v6;
  CFTypeRef v7;
  uint64_t AllocatorForMedia;
  uint64_t (*v9)(CFTypeRef, _QWORD, uint64_t, CFTypeRef *);
  int v10;
  CFTypeRef v11;
  CFTypeRef cf;

  *a4 = 0;
  v6 = CMGetAttachment(a1, a2, 0);
  *a3 = v6;
  if (v6)
  {
    v7 = v6;
    cf = 0;
    AllocatorForMedia = FigGetAllocatorForMedia();
    v9 = *(uint64_t (**)(CFTypeRef, _QWORD, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                           + 48);
    if (v9)
    {
      v10 = v9(v7, *MEMORY[0x1E0CA31E8], AllocatorForMedia, &cf);
      v11 = cf;
      if (!v10)
      {
        *a4 = FigCFNumberGetSInt64();
        v11 = cf;
      }
      if (v11)
        CFRelease(v11);
    }
  }
}

uint64_t segPumpMakeDataCallbackWithOSStatus(uint64_t a1, uint64_t *a2, const void *a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, unsigned int a10, uint64_t a11, _DWORD *a12)
{
  uint64_t DataCallback;
  __int128 v22;
  uint64_t v23;
  CFTypeRef cf;

  cf = 0;
  FigCreateErrorForOSStatus(a10, (CFErrorRef *)&cf);
  v22 = *(_OWORD *)a7;
  v23 = *(_QWORD *)(a7 + 16);
  DataCallback = segPumpMakeDataCallback(a1, a2, a3, a4, a5, a6, &v22, a8, a9, (uint64_t)cf, a11, a12);
  if (cf)
    CFRelease(cf);
  return DataCallback;
}

uint64_t segPumpCopyMapEntryFromCache(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFTypeRef v11;
  uint64_t StartOffset;
  uint64_t MediaSequence;
  CFTypeRef v14;
  CFTypeRef v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t SavedEntry;
  const void *v20;
  CFTypeRef v21;
  CFTypeRef cf;

  v21 = 0;
  cf = 0;
  v20 = 0;
  *a4 = 0;
  v8 = segPumpCreateCacheNameFromSegment(a2, a3, &v21, &cf);
  if (!(_DWORD)v8)
  {
    v9 = *(_QWORD *)(a1 + 296);
    if (v9)
    {
      v10 = *(_QWORD *)(a2 + 64);
      if (v10)
      {
        v11 = cf;
        StartOffset = FigMediaSegmentSpecifierGetStartOffset(a3);
        MediaSequence = FigMediaSegmentSpecifierGetMediaSequence(a3);
        v9 = FigStreamingCacheCopyMediaMap(v9, v10, (uint64_t)v11, StartOffset, MediaSequence, &v20);
        if (!(_DWORD)v9)
        {
          v14 = v20;
          if (v20)
          {
            v9 = 0;
LABEL_11:
            *a4 = v14;
            goto LABEL_12;
          }
        }
      }
      else
      {
        v9 = 0;
      }
    }
    v15 = v21;
    v16 = FigMediaSegmentSpecifierGetStartOffset(a3);
    v17 = FigMediaSegmentSpecifierGetBytesToRead(a3);
    SavedEntry = segPumpFindSavedEntry(a1, v15, v16, v17);
    if (!SavedEntry)
      goto LABEL_12;
    v14 = *(CFTypeRef *)(SavedEntry + 16);
    if (v14)
      v14 = CFRetain(v14);
    goto LABEL_11;
  }
  v9 = v8;
LABEL_12:
  if (cf)
    CFRelease(cf);
  if (v21)
    CFRelease(v21);
  return v9;
}

uint64_t segPumpMoveToNextMedia(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  _BYTE *v7;
  uint64_t result;
  const void *v9;
  CFTypeRef *MediaFilePrivateData;
  _QWORD *v11;
  const void *v12;
  uint64_t v13;
  const void *v14;

  v7 = (_BYTE *)(a2 + 8712);
  if (!a4)
  {
    v9 = *(const void **)(*(_QWORD *)(a3 + 696) + 8);
    if (v9 && *((_QWORD *)segPumpGetMediaFilePrivateData(v9) + 2))
    {
      MediaFilePrivateData = (CFTypeRef *)segPumpGetMediaFilePrivateData(*(const void **)(*(_QWORD *)(a3 + 696) + 8));
      CFRelease(MediaFilePrivateData[2]);
      *((_QWORD *)segPumpGetMediaFilePrivateData(*(const void **)(*(_QWORD *)(a3 + 696) + 8)) + 2) = 0;
    }
    if (*v7)
      return 0;
LABEL_12:
    v11 = *(_QWORD **)(a3 + 696);
    v12 = (const void *)v11[1];
    if (v12 && (CFRelease(v12), *(_QWORD *)(*(_QWORD *)(a3 + 696) + 8) = 0, (v11 = *(_QWORD **)(a3 + 696)) == 0)
      || !v11[4] && !v11[13])
    {
      segPumpStreamMoveToNextFreeMediaConnection(a3);
    }
    return segPumpDeliverNextMediaForSingleStream(a1, a2, a3);
  }
  if (!*v7)
    goto LABEL_12;
  if (*(_BYTE *)(a2 + 8768))
  {
    *(_BYTE *)(a2 + 8768) = 0;
    result = segPumpRetrieveNextIFrame(a1, a2);
    if ((_DWORD)result)
      return segPumpMakeDataCallbackWithOSStatus(a1, (uint64_t *)a3, *(const void **)(a2 + 176), 0, 0x20u, *(_QWORD *)(*(_QWORD *)(a2 + 384) + 304), MEMORY[0x1E0CA2E18], 0, 0, result, 0, 0);
    return result;
  }
  v13 = **(_QWORD **)(a3 + 768);
  if (!v13)
    return segPumpDoNextStep(a1, a2);
  v14 = *(const void **)(v13 + 8);
  segPumpAdoptReadAhead(a2, a3, v14, 0, 0);
  if (*(float *)(a2 + 8736) == 0.0)
    return 0;
  result = segPumpDoAllStepAheads(a1, v14);
  if (!(_DWORD)result)
    return 0;
  return result;
}

uint64_t segPumpRetrieveNextIFrame(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  double v5;
  const void *MediaEntryForTimeFromEnd;
  uint64_t v7;
  double v8;
  double v9;
  double TimeInSeconds;
  double v11;
  int v12;
  double v13;
  double v14;
  const void *MapSegmentSpecifier;
  uint64_t result;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  _QWORD *MediaFilePrivateData;
  const void *v19;
  const void *ContentKeySpecifier;
  const void *v21;
  const void *v22;
  double v23;
  char v24[128];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v4 = *(uint64_t **)(a2 + 384);
  v5 = *(double *)(a2 + 8720);
  v23 = 0.0;
  MediaEntryForTimeFromEnd = segPumpGetMediaEntryForTimeFromEnd(v4[7], 0, &v23, v5);
  v7 = 0;
  if (MediaEntryForTimeFromEnd)
  {
    while (1)
    {
      v8 = v23;
      v9 = *(double *)(a2 + 8784);
      if (v23 == v9)
        goto LABEL_24;
      if (v23 < v9)
        v7 = (uint64_t)MediaEntryForTimeFromEnd;
      if (v8 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)MediaEntryForTimeFromEnd) > *(double *)(a2 + 8784))
        break;
      TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)MediaEntryForTimeFromEnd);
      v23 = TimeInSeconds + v23;
      MediaEntryForTimeFromEnd = (const void *)FigMediaSegmentSpecifierGetNextSegment((uint64_t)MediaEntryForTimeFromEnd);
      if (!MediaEntryForTimeFromEnd)
      {
        if (!v7)
          goto LABEL_12;
        goto LABEL_10;
      }
    }
    MediaEntryForTimeFromEnd = (const void *)FigMediaSegmentSpecifierGetNextSegment((uint64_t)MediaEntryForTimeFromEnd);
    if (!v7)
    {
LABEL_12:
      if (MediaEntryForTimeFromEnd && v23 > *(double *)(a2 + 8800))
        MediaEntryForTimeFromEnd = 0;
      goto LABEL_15;
    }
LABEL_10:
    v11 = v23;
    if (v11 - FigMediaSegmentSpecifierGetTimeInSeconds(v7) < *(double *)(a2 + 8792))
      v7 = 0;
    goto LABEL_12;
  }
LABEL_15:
  v12 = *(_DWORD *)(a2 + 8776);
  if (v12 != 1)
  {
    if (v12 == 2)
    {
      v7 = (uint64_t)MediaEntryForTimeFromEnd;
    }
    else if (MediaEntryForTimeFromEnd)
    {
      if (v7)
      {
        v13 = v23;
        v14 = v23 - *(double *)(a2 + 8784);
        if (v13 - FigMediaSegmentSpecifierGetTimeInSeconds(v7) - *(double *)(a2 + 8784) < v14)
          MediaEntryForTimeFromEnd = (const void *)v7;
      }
      goto LABEL_24;
    }
  }
  MediaEntryForTimeFromEnd = (const void *)v7;
  if (!v7)
    return FigSignalErrorAt();
LABEL_24:
  if (FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)MediaEntryForTimeFromEnd))
  {
    v24[0] = 0;
    MapSegmentSpecifier = (const void *)FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)MediaEntryForTimeFromEnd);
    result = segPumpIsMapEntryCached(a2, (uint64_t)v4, MapSegmentSpecifier, v24);
    if ((_DWORD)result)
      return result;
    if (!v24[0])
      *(_BYTE *)(a2 + 8768) = 1;
  }
  if (dword_1EE2A31E8)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  ++v4[110];
  MediaFilePrivateData = segPumpGetMediaFilePrivateData(MediaEntryForTimeFromEnd);
  MediaFilePrivateData[6] = 0;
  MediaFilePrivateData[7] = 0;
  v19 = (const void *)v4[32];
  if (v19)
  {
    CFRelease(v19);
    v4[32] = 0;
  }
  result = segPumpFetchOrDispatchMediaSegment(a1, a2, v4, MediaEntryForTimeFromEnd, 0, 0, 0);
  if (!(_DWORD)result)
  {
    if (v4[31])
    {
      return 0;
    }
    else
    {
      result = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)MediaEntryForTimeFromEnd);
      if (result)
      {
        ContentKeySpecifier = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)MediaEntryForTimeFromEnd);
        result = segPumpDoesCryptKeyRequireFetch(ContentKeySpecifier);
        if ((_DWORD)result)
        {
          v21 = (const void *)v4[31];
          v22 = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)MediaEntryForTimeFromEnd);
          v4[31] = (uint64_t)v22;
          if (v22)
            CFRetain(v22);
          if (v21)
            CFRelease(v21);
          return segPumpSendCryptKeyRequest(a1, a2, v4, v4[31]);
        }
      }
    }
  }
  return result;
}

uint64_t segPumpDoAllStepAheads(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  double PlaylistActiveDurationSecs;
  const void *v16;
  const __CFURL *v17;
  const __CFURL *v18;
  _QWORD *MediaFilePrivateData;
  const __CFURL *v20;
  const __CFURL *v21;
  const __CFURL **v22;
  const void *ContentKeySpecifier;
  _QWORD *v24;
  uint64_t MediaFile;
  uint64_t v26;
  uint64_t v27;
  uint64_t v29;
  uint64_t v30;
  double v31;
  __int16 v32;
  __int16 v33;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v5 = DerivedStorage;
  v33 = 0;
  v32 = 0;
  v31 = 0.0;
  v6 = *(_QWORD *)(DerivedStorage + 384);
  v7 = *(_QWORD *)(v6 + 696);
  if (*(const void **)(v7 + 8) == a2)
    v8 = *(_QWORD *)(v7 + 288);
  else
    v8 = *(_QWORD *)(DerivedStorage + 8752);
  v9 = *(_QWORD *)(v6 + 784);
  if (v9 < 1)
    return 0;
  v10 = 0;
  while (1)
  {
    v11 = *(_QWORD *)(*(_QWORD *)(v6 + 768) + 8 * v10);
    if (!v11)
      break;
    if (*(_QWORD *)(v11 + 8))
    {
      v8 = *(_QWORD *)(v11 + 288);
      a2 = *(const void **)(v11 + 8);
    }
    if (v9 == ++v10)
      return 0;
  }
  if (v10 >= v9)
    return 0;
  v29 = a1;
  v30 = 0;
  v12 = 0;
  v13 = 0;
  do
  {
    v14 = *((double *)segPumpGetMediaFilePrivateData(a2) + 4) - *(double *)(v6 + 88);
    PlaylistActiveDurationSecs = FigMediaPlaylistGetPlaylistActiveDurationSecs(*(_QWORD *)(v6 + 56));
    v16 = segPumpChooseNextStep(v5, (uint64_t)a2, v8, 0, 0, 0, (BOOL *)&v32 + 1, &v31, PlaylistActiveDurationSecs - v14, PlaylistActiveDurationSecs - v14 + *(double *)(v5 + 8728) - *(double *)(v5 + 8720), &v33, (_BYTE *)&v33 + 1, &v32, &v30);
    if (!v16)
      break;
    a2 = v16;
    v17 = *(const __CFURL **)(v6 + 16);
    v18 = *(const __CFURL **)(v6 + 24);
    MediaFilePrivateData = segPumpGetMediaFilePrivateData(v16);
    segPumpEnsureMediaSegmentURLs(a2, v17, v18);
    if (!MediaFilePrivateData[2])
      return FigSignalErrorAt();
    if (HIBYTE(v32))
      return v12;
    v20 = *(const __CFURL **)(v6 + 16);
    v21 = *(const __CFURL **)(v6 + 24);
    v22 = (const __CFURL **)segPumpGetMediaFilePrivateData(a2);
    segPumpEnsureMediaSegmentURLs(a2, v20, v21);
    if (!segPumpShouldRequestURLAsHTTPURL(v5, v22[2]))
      return v12;
    if (HIBYTE(v33))
    {
      ++v13;
    }
    else
    {
      if (FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a2))
      {
        ContentKeySpecifier = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)a2);
        if (segPumpDoesCryptKeyRequireFetch(ContentKeySpecifier))
          return v12;
      }
      v24 = segPumpGetMediaFilePrivateData(a2);
      v24[6] = 0;
      v24[7] = 0;
      MediaFile = segPumpReadMediaFile(v29, v6, a2, 1, 0, 0, *(_QWORD *)(v6 + 768) + 8 * v10);
      if ((_DWORD)MediaFile == -15626)
        return 4294951670;
      v12 = MediaFile;
      *(int64x2_t *)(v5 + 8864) = vaddq_s64(*(int64x2_t *)(v5 + 8864), vdupq_n_s64(1uLL));
      v26 = *(_QWORD *)(*(_QWORD *)(v6 + 768) + 8 * v10);
      if (!v26)
        return v12;
      v8 = v30;
      *(_QWORD *)(v26 + 288) = v30;
      ++v10;
    }
    v27 = *(_QWORD *)(v6 + 784);
  }
  while (v10 < v27 && v13 < v27);
  return v12;
}

uint64_t segPumpDoNextStep(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _BOOL4 v5;
  const void *v6;
  const void *v7;
  char *MediaFilePrivateData;
  const void *v9;
  const void *v10;
  uint64_t result;
  uint64_t v12;
  const void *ContentKeySpecifier;
  const void *v14;
  const void *v15;
  BOOL v16;
  uint64_t v17;
  __int16 v18;
  char v19;
  char v20;
  double v21;

  v4 = *(_QWORD **)(a2 + 384);
  v19 = 0;
  v18 = 0;
  v5 = *(float *)(a2 + 8736) != 0.0;
  v17 = 0;
  v6 = segPumpChooseNextStep(a2, 0, *(_QWORD *)(a2 + 8752), 1, 1, 1, (BOOL *)&v18 + 1, &v21, *(double *)(a2 + 8720), *(double *)(a2 + 8728), &v19, &v20, &v18, &v17);
  if ((_BYTE)v18)
    return 0;
  v7 = v6;
  if (!v6)
    return 4294954648;
  ++v4[110];
  if (!v19)
  {
    MediaFilePrivateData = (char *)segPumpGetMediaFilePrivateData(v6);
    *((_QWORD *)MediaFilePrivateData + 7) = 0;
    *((_QWORD *)MediaFilePrivateData + 8) = 0;
    *((_QWORD *)MediaFilePrivateData + 6) = 0;
    *(_DWORD *)(MediaFilePrivateData + 71) = 0;
    *((_QWORD *)MediaFilePrivateData + 14) = 0;
    *((_QWORD *)MediaFilePrivateData + 15) = 0;
    v9 = (const void *)v4[32];
    if (v9)
    {
      CFRelease(v9);
      v4[32] = 0;
    }
    v10 = (const void *)v4[33];
    if (v10)
    {
      CFRelease(v10);
      v4[33] = 0;
    }
    result = segPumpFetchOrDispatchMediaSegment(a1, a2, v4, v7, 0, 0, 0);
    if ((_DWORD)result)
      return result;
    v12 = v17;
    *(_QWORD *)(v4[87] + 288) = v17;
    ++*(_QWORD *)(a2 + 8872);
    if (HIBYTE(v18))
    {
      result = segPumpReadMediaFile(a1, v4, v7, 1, 0, 0, v4[96]);
      if ((_DWORD)result)
        return result;
      v5 = 0;
      *(_QWORD *)(*(_QWORD *)v4[96] + 288) = v12;
    }
  }
  if (v4[31]
    || !FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v7)
    || (ContentKeySpecifier = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v7),
        !segPumpDoesCryptKeyRequireFetch(ContentKeySpecifier)))
  {
    if (v5)
      return segPumpDoAllStepAheads(a1, v7);
    return 0;
  }
  v14 = (const void *)v4[31];
  v15 = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v7);
  v4[31] = v15;
  if (v15)
    CFRetain(v15);
  if (v14)
    CFRelease(v14);
  result = segPumpSendCryptKeyRequest(a1, a2, v4, v4[31]);
  if ((_DWORD)result)
    v16 = 0;
  else
    v16 = v5;
  if (v16)
    return segPumpDoAllStepAheads(a1, v7);
  return result;
}

const void *segPumpGetMediaEntryForTimeFromEnd(uint64_t a1, int a2, _QWORD *a3, double a4)
{
  uint64_t FirstValue;
  CFIndex v9;
  double v10;
  double v11;
  const __CFArray *MediaSegmentSpecifiers;
  const __CFArray *v13;
  const void *ValueAtIndex;

  if (FigMediaPlaylistGetPlaylistActiveDurationSecs(a1) < a4)
  {
    FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
    FirstValue = FigCFArrayGetFirstValue();
LABEL_15:
    ValueAtIndex = (const void *)FirstValue;
    goto LABEL_16;
  }
  if (a4 <= 0.0)
  {
    FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
    FirstValue = FigCFArrayGetLastValue();
    goto LABEL_15;
  }
  v9 = 0;
  v10 = FigMediaPlaylistGetPlaylistActiveDurationSecs(a1) - a4;
  v11 = 0.0;
  while (1)
  {
    MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
    if (MediaSegmentSpecifiers)
      MediaSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MediaSegmentSpecifiers);
    if (v9 >= (uint64_t)MediaSegmentSpecifiers)
      return 0;
    v13 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
    ValueAtIndex = CFArrayGetValueAtIndex(v13, v9);
    if (v11 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex) > v10)
      break;
    v11 = v11 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
    ++v9;
  }
  if (a2 && v11 < v10)
  {
    FirstValue = FigMediaSegmentSpecifierGetNextSegment((uint64_t)ValueAtIndex);
    goto LABEL_15;
  }
LABEL_16:
  if (a3 && ValueAtIndex)
    *a3 = *((_QWORD *)segPumpGetMediaFilePrivateData(ValueAtIndex) + 4);
  return ValueAtIndex;
}

uint64_t segPumpIsMapEntryCached(uint64_t a1, uint64_t a2, const void *a3, char *a4)
{
  _BYTE *MediaFilePrivateData;
  uint64_t v9;
  char v10;
  _BYTE *v11;
  BOOL v12;
  CFTypeRef cf;

  MediaFilePrivateData = segPumpGetMediaFilePrivateData(a3);
  if (MediaFilePrivateData[98])
  {
    v9 = 0;
    v10 = 1;
  }
  else
  {
    v11 = MediaFilePrivateData;
    cf = 0;
    v9 = segPumpCopyMapEntryFromCache(a1, a2, (uint64_t)a3, &cf);
    if ((_DWORD)v9)
      v12 = 1;
    else
      v12 = cf == 0;
    v10 = !v12;
    if (cf)
      CFRelease(cf);
    v11[98] = v10;
  }
  *a4 = v10;
  return v9;
}

uint64_t segPumpFetchOrDispatchMediaSegment(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, const void *a5, char *a6, _BYTE *a7)
{
  const void *v9;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  const void *MapSegmentSpecifier;
  uint64_t IsMapEntryCached;
  int v16;
  int v17;
  const void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t DerivedStorage;
  const void *v24;
  _QWORD *v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const void *v30;
  const void *v31;
  const void *v32;
  double TimeInSeconds;
  uint64_t MediaFile;
  uint64_t Ahead;
  char v36;
  uint64_t ContentKeySpecifier;
  const void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const void *v44;
  uint64_t v45;
  const void *v46;
  uint64_t v47;
  const void *v48;
  BOOL v49;
  BOOL v50;
  const void *v51;
  const void *v52;
  uint64_t v53;
  uint64_t FragmentNumber;
  uint64_t MediaSequence;
  NSObject *v56;
  NSObject *v58;
  const void *v59;
  const void *v60;
  uint64_t v61;
  const void *v62;
  const void *v63;
  uint64_t v64;
  const void *v65;
  const void *v66;
  NSObject *v67;
  CFTypeRef cf;
  _QWORD *MediaFilePrivateData;
  CFTypeRef cf2;
  unsigned __int8 v72;
  _QWORD *v73;
  char v74;
  uint64_t v75;
  unint64_t v76[18];

  v9 = a4;
  v76[16] = *MEMORY[0x1E0C80C00];
  MediaFilePrivateData = segPumpGetMediaFilePrivateData(a4);
  v74 = 0;
  v73 = 0;
  v72 = 0;
  cf2 = 0;
  if (!v9 || *(_QWORD *)(a3 + 256))
    goto LABEL_159;
  if (*(_QWORD *)(a3 + 264))
  {
    IsMapEntryCached = FigSignalErrorAt();
    goto LABEL_161;
  }
  cf = a5;
  if (dword_1EE2A31E8 >= 3)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v9))
  {
    MapSegmentSpecifier = (const void *)FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v9);
    IsMapEntryCached = segPumpIsMapEntryCached(a2, a3, MapSegmentSpecifier, (char *)&v72);
    if ((_DWORD)IsMapEntryCached)
      goto LABEL_161;
    v16 = v72;
    if (v72)
    {
      if (FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v9) == *(_QWORD *)(a3 + 288))
        FigMediaSegmentSpecifierGetDiscontinuityDomain((uint64_t)v9);
      v17 = 0;
    }
    else
    {
      v17 = 1;
    }
    if (FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v9))
    {
      if (FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v9) != *(_QWORD *)(a3 + 288))
      {
        v19 = *(_QWORD *)(a3 + 312);
        if (FigMediaSegmentSpecifierGetDiscontinuityDomain((uint64_t)v9) + v19 == *(_QWORD *)(a3 + 304))
          *(_BYTE *)(a3 + 403) = 1;
      }
    }
    v18 = (const void *)FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v9);
  }
  else
  {
    v16 = 0;
    v18 = 0;
    v17 = 0;
  }
  if (*(_BYTE *)(a3 + 401))
  {
    if (!MediaFilePrivateData[6] && !*(_BYTE *)(a2 + 8712))
    {
      v20 = a1;
      v21 = *(_QWORD *)(a3 + 376) + 1;
      v49 = v21 == FigMediaSegmentSpecifierGetMediaSequence((uint64_t)v9);
      a1 = v20;
      if (!v49)
      {
        *(_BYTE *)(a3 + 403) = 1;
        if (dword_1EE2A31E8)
        {
          v67 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
      }
    }
    segPumpSetStreamDiscontinuityDomain(a2, (_QWORD *)a3, (uint64_t)v9);
    *(_QWORD *)(a3 + 936) = -1;
    if (v17)
    {
LABEL_29:
      v22 = a1;
      DerivedStorage = CMBaseObjectGetDerivedStorage();
      v24 = (const void *)FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v9);
      v25 = segPumpGetMediaFilePrivateData(v9);
      v26 = segPumpGetMediaFilePrivateData(v24);
      if (v24)
      {
        v27 = *(_QWORD *)(a3 + 776);
        if (v27 >= 1)
        {
          v28 = 0;
          while (1)
          {
            v29 = *(_QWORD *)(*(_QWORD *)(a3 + 768) + 8 * v28);
            if (v29)
            {
              if (*(const void **)(v29 + 8) == v24)
                break;
            }
            if (v27 == ++v28)
              goto LABEL_35;
          }
          Ahead = segPumpAdoptReadAhead(DerivedStorage, a3, v24, 0, v28);
          v36 = 0;
          goto LABEL_120;
        }
LABEL_35:
        v30 = *(const void **)(a3 + 256);
        *(_QWORD *)(a3 + 256) = v24;
        CFRetain(v24);
        if (!v30)
          goto LABEL_37;
      }
      else
      {
        v30 = *(const void **)(a3 + 256);
        *(_QWORD *)(a3 + 256) = 0;
        if (!v30)
          goto LABEL_37;
      }
      CFRelease(v30);
LABEL_37:
      v31 = *(const void **)(a3 + 264);
      if (v31)
      {
        CFRelease(v31);
        *(_QWORD *)(a3 + 264) = 0;
      }
      LOBYTE(v32) = 1;
      *(_BYTE *)(a3 + 404) = 1;
      TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v9);
      FigMediaSegmentSpecifierSetTimeInSeconds((uint64_t)v24, TimeInSeconds);
      v26[4] = v25[4];
      v26[6] = 0;
      v26[7] = 0;
      MediaFile = segPumpReadMediaFile(v22, a3, v24, 0, 0, 0, 0);
      goto LABEL_40;
    }
  }
  else
  {
    *(_QWORD *)(a3 + 376) = FigMediaSegmentSpecifierGetMediaSequence((uint64_t)v9) - 1;
    if (v17)
    {
      segPumpSetStreamDiscontinuityDomain(a2, (_QWORD *)a3, (uint64_t)v9);
      *(_QWORD *)(a3 + 936) = -1;
      goto LABEL_29;
    }
    *(_BYTE *)(a3 + 401) = 1;
    segPumpSetStreamDiscontinuityDomain(a2, (_QWORD *)a3, (uint64_t)v9);
    *(_QWORD *)(a3 + 936) = -1;
  }
  if (!v16 || *(const void **)(a3 + 288) == v18)
  {
    v32 = cf;
  }
  else
  {
    ContentKeySpecifier = FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v18);
    v32 = cf;
    if (ContentKeySpecifier && FigContentKeySpecifierGetKeySystem(ContentKeySpecifier) == 2)
    {
      v38 = *(const void **)(a3 + 256);
      *(_QWORD *)(a3 + 256) = v18;
      if (v18)
        CFRetain(v18);
      if (v38)
        CFRelease(v38);
      v9 = v18;
    }
  }
  if (*(_BYTE *)(a3 + 869))
  {
    if (!v32)
      goto LABEL_121;
    FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v9);
    if ((const void *)FigCFArrayGetFirstValue() == v32)
      goto LABEL_159;
  }
  if (*(_QWORD *)(a2 + 8416) == *(_QWORD *)a3)
    *(_BYTE *)(a2 + 8007) = 0;
  if (*(_QWORD *)(a2 + 296))
  {
    IsMapEntryCached = segPumpEnsureCacheForStreamPossiblyEndingStream(a1, (uint64_t *)a3);
    if ((_DWORD)IsMapEntryCached)
      goto LABEL_161;
    if (*(_BYTE *)(a3 + 1136))
      goto LABEL_159;
  }
  if (v32)
  {
    v39 = *(_QWORD *)(a3 + 776);
    if (v39 >= 1)
    {
      v40 = 0;
      do
      {
        v41 = *(_QWORD *)(*(_QWORD *)(a3 + 768) + 8 * v40);
        if (v41)
        {
          if (*(const void **)(v41 + 8) == v32)
            goto LABEL_93;
        }
      }
      while (v39 != ++v40);
    }
  }
  else if (v9)
  {
    v42 = *(_QWORD *)(a3 + 776);
    if (v42 >= 1)
    {
      v40 = 0;
      while (1)
      {
        v43 = *(_QWORD *)(*(_QWORD *)(a3 + 768) + 8 * v40);
        if (v43)
        {
          if (*(const void **)(v43 + 8) == v9)
            break;
        }
        if (v42 == ++v40)
          goto LABEL_73;
      }
LABEL_93:
      IsMapEntryCached = segPumpAdoptReadAhead(a2, a3, v9, v32, v40);
      if (!(_DWORD)IsMapEntryCached)
      {
        v47 = 0;
        v46 = 0;
        LOBYTE(v32) = 1;
        goto LABEL_95;
      }
      goto LABEL_161;
    }
  }
LABEL_73:
  if (!*(_QWORD *)(a2 + 296)
    || !*(_QWORD *)(a3 + 64)
    || !segPumpSeeIfMediaFileIsInCache(a2, a3, v9, &v73, &v74))
  {
    if (v32)
      v46 = v32;
    else
      v46 = v9;
    v48 = *(const void **)(*(_QWORD *)(a3 + 696) + 8);
    if (v48)
      v49 = v48 == v46;
    else
      v49 = 1;
    if (!v49)
      segPumpCancelMediaFileReadAndResetData(a2, a3, 1, 0);
    LOBYTE(v32) = 0;
    v47 = 0;
    v50 = 1;
    goto LABEL_92;
  }
  if (v32)
  {
LABEL_159:
    v36 = 0;
    LOBYTE(v32) = 0;
    goto LABEL_122;
  }
  if (!FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v9))
    goto LABEL_80;
  v76[0] = 0;
  v75 = 0;
  v44 = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v9);
  IsMapEntryCached = segPumpGetCryptKeyCommonData(v44, v76, &v75);
  if ((_DWORD)IsMapEntryCached)
  {
LABEL_161:
    Ahead = IsMapEntryCached;
    goto LABEL_158;
  }
  v45 = v75;
  if (!*(_BYTE *)(v75 + 144))
  {
    v60 = *(const void **)(a3 + 256);
    if (v60)
    {
      CFRelease(v60);
      *(_QWORD *)(a3 + 256) = 0;
      v45 = v75;
    }
    if (*(_BYTE *)(v45 + 145)
      || (v64 = *(_QWORD *)(a3 + 248), v64 == FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v9)))
    {
      Ahead = 0;
    }
    else
    {
      segPumpCancelCryptReadAndResetData(a2, a3);
      v65 = *(const void **)(a3 + 248);
      v66 = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v9);
      *(_QWORD *)(a3 + 248) = v66;
      if (v66)
        CFRetain(v66);
      if (v65)
        CFRelease(v65);
      Ahead = segPumpSendCryptKeyRequest(a1, a2, a3, *(_QWORD *)(a3 + 248));
      if ((_DWORD)Ahead == -15626)
      {
        Ahead = 4294951670;
        goto LABEL_158;
      }
    }
    if (*(_BYTE *)(a2 + 322))
    {
LABEL_158:
      v36 = 0;
      LOBYTE(v32) = 0;
      goto LABEL_123;
    }
  }
LABEL_80:
  MediaFilePrivateData[13] = v73;
  IsMapEntryCached = segPumpSetMediaFilePumpTimeOffsetsArray(a2, a3, v9);
  if ((_DWORD)IsMapEntryCached)
    goto LABEL_161;
  if (!v74)
  {
    v76[0] = 0;
    v59 = *(const void **)(*(_QWORD *)(a3 + 696) + 8);
    if (v59 == v9)
    {
      v46 = 0;
    }
    else
    {
      v46 = v9;
      if (v59)
      {
        segPumpCancelMediaFileReadAndResetData(a2, a3, 1, 0);
        v46 = v9;
      }
    }
    FigStreamingCacheMediaSegmentGetLength(*(_QWORD *)(a2 + 296), *(_QWORD *)(a3 + 64), v73, 0, v76);
    if (v76[0])
    {
      v61 = MediaFilePrivateData[7];
      v50 = v76[0] == v61;
      if (v76[0] == v61)
        v47 = 0;
      else
        v47 = (uint64_t)v9;
    }
    else
    {
      v47 = 0;
      v50 = 1;
    }
    LOBYTE(v32) = 0;
LABEL_92:
    *(_BYTE *)(a3 + 404) = v50;
    goto LABEL_95;
  }
  LOBYTE(v32) = 0;
  v46 = 0;
  v47 = (uint64_t)v9;
LABEL_95:
  v51 = *(const void **)(a3 + 256);
  *(_QWORD *)(a3 + 256) = v9;
  if (v9)
    CFRetain(v9);
  if (v51)
    CFRelease(v51);
  v52 = *(const void **)(a3 + 264);
  *(_QWORD *)(a3 + 264) = cf;
  if (cf)
    CFRetain(cf);
  if (v52)
    CFRelease(v52);
  if (!v46)
  {
LABEL_115:
    if (v47)
    {
      MediaFilePrivateData[14] = 0;
      MediaSequence = FigMediaSegmentSpecifierGetMediaSequence(v47);
      MediaFile = segPumpDispatchAsyncMediaDelivery(a2, a3, MediaSequence, -1, 0, (uint64_t)segPumpDeliverFromCache);
      if (!(_DWORD)MediaFile)
      {
        v36 = dword_1EE2A31E8;
        if (!dword_1EE2A31E8)
        {
          Ahead = 0;
LABEL_120:
          LOBYTE(v32) = 1;
          goto LABEL_123;
        }
        v56 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT);
        LOBYTE(v32) = 1;
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        goto LABEL_121;
      }
LABEL_40:
      Ahead = MediaFile;
      v36 = 0;
      goto LABEL_123;
    }
LABEL_121:
    v36 = 0;
LABEL_122:
    Ahead = 0;
    goto LABEL_123;
  }
  if (FigMediaSegmentSpecifierIsMarkedAsGap((uint64_t)v46))
  {
    MediaFile = segPumpHandleMediaFileNetworkError(a1, (_QWORD *)a3, 0, (uint64_t)v46, 4294951877);
    if ((_DWORD)MediaFile)
      goto LABEL_40;
    if (*(_QWORD *)(a2 + 8144) || !*(_QWORD *)(a2 + 8096))
    {
      v53 = FigMediaSegmentSpecifierGetMediaSequence((uint64_t)v46);
      FragmentNumber = segPumpGetFragmentNumber((uint64_t)v9, cf);
      MediaFile = segPumpDispatchAsyncMediaDelivery(a2, a3, v53, FragmentNumber, 0, (uint64_t)segPumpDeliverGapSegment);
      if ((_DWORD)MediaFile)
        goto LABEL_40;
    }
LABEL_114:
    LOBYTE(v32) = 1;
    goto LABEL_115;
  }
  MediaFile = segPumpCopyAndCreateNetworkURLFromPumpCache(a2, a3, &cf2);
  if ((_DWORD)MediaFile)
    goto LABEL_40;
  if (FigCFHTTPCompareURLs(*(const void **)(a3 + 24), cf2))
  {
    MediaFile = segPumpReadMediaFile(a1, a3, v46, 0, 0, 0, 0);
    if ((_DWORD)MediaFile)
      goto LABEL_40;
    goto LABEL_114;
  }
  if (dword_1EE2A31E8)
  {
    v58 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  *(_QWORD *)(a3 + 136) = *(_QWORD *)(a3 + 376);
  segPumpStopStream(a2, a3, 1);
  v62 = *(const void **)(a3 + 256);
  if (v62)
  {
    CFRelease(v62);
    *(_QWORD *)(a3 + 256) = 0;
  }
  v63 = *(const void **)(a3 + 264);
  if (v63)
  {
    CFRelease(v63);
    *(_QWORD *)(a3 + 264) = 0;
  }
  Ahead = segPumpSendIndexFileRequest(a1, a2, a3);
  v36 = 1;
LABEL_123:
  if (a7)
    *a7 = (_BYTE)v32;
  if (a6)
    *a6 = v36;
  if (cf2)
    CFRelease(cf2);
  return Ahead;
}

BOOL segPumpDoesCryptKeyRequireFetch(const void *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = 0;
  v3 = 0;
  return !segPumpGetCryptKeyCommonData(a1, &v3, &v2) && !*(_BYTE *)(v2 + 144) && *(_BYTE *)(v2 + 145) == 0;
}

void segPumpDeliverGapSegment(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  uint64_t v11;
  uint64_t v12;
  const void *MediaEntryForMediaSequence;
  const void *v14;
  CFIndex i;
  const __CFArray *PartialSegments;
  const __CFArray *v17;
  const void *ValueAtIndex;
  const void *v19;
  uint64_t v20;
  const void *v21;
  CFTypeRef v22;
  uint64_t v23;
  _BOOL4 v24;
  uint64_t Media;
  uint64_t v26;
  uint64_t v27;
  CFTypeRef cf;

  v27 = 0;
  cf = 0;
  v11 = segPumpLockAndCopyPumpFromRetainProxy(a1, &cf, &v27);
  if ((_DWORD)v11)
    goto LABEL_34;
  v12 = a2[7];
  if (v12)
  {
    MediaEntryForMediaSequence = segPumpGetMediaEntryForMediaSequence(v12, a5);
    if (MediaEntryForMediaSequence)
    {
      v14 = MediaEntryForMediaSequence;
      if (a6 < 0)
        goto LABEL_13;
      for (i = 0; ; ++i)
      {
        PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v14);
        if (PartialSegments)
          PartialSegments = (const __CFArray *)CFArrayGetCount(PartialSegments);
        if (i >= (uint64_t)PartialSegments)
          break;
        v17 = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v14);
        ValueAtIndex = CFArrayGetValueAtIndex(v17, i);
        if (a6 == i)
        {
          v14 = ValueAtIndex;
          break;
        }
      }
      if (v14)
      {
LABEL_13:
        v19 = (const void *)a2[37];
        if (v19)
        {
          CFRelease(v19);
          a2[37] = 0;
        }
        v20 = a2[110];
        if (FigMediaSegmentSpecifierGetType((uint64_t)v14))
        {
          Media = FigSignalErrorAt();
          goto LABEL_29;
        }
        if (((const void *)a2[32] == v14 || (const void *)a2[33] == v14)
          && (!*(_QWORD *)(v27 + 8096) || *(_QWORD *)(v27 + 8144)))
        {
          if (a2[145] == a3)
          {
            v11 = segPumpSendMediaCallback((uint64_t)cf, v27, (uint64_t)a2, v14, 0, 0, 0, 2, 0x800u);
            if (!(_DWORD)v11)
            {
              if (FigRetainProxyIsInvalidated()
                || v20 != a2[110]
                || (const void *)a2[32] != v14 && (const void *)a2[33] != v14)
              {
                goto LABEL_31;
              }
              v21 = (const void *)a2[36];
              if (v21)
              {
                CFRelease(v21);
                a2[36] = 0;
                a2[40] = -1;
              }
              segPumpMarkMediaFileAsDelivered(a2, v14);
              v23 = v27;
              v22 = cf;
              v24 = FigMediaSegmentSpecifierGetType((uint64_t)v14) == 1;
              Media = segPumpMoveToNextMedia((uint64_t)v22, v23, (uint64_t)a2, v24);
LABEL_29:
              v26 = Media;
              if (!(_DWORD)Media)
                goto LABEL_31;
              goto LABEL_30;
            }
LABEL_34:
            v26 = v11;
LABEL_30:
            segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(a1, v26);
            goto LABEL_31;
          }
          FigSignalErrorAt();
        }
      }
    }
  }
LABEL_31:
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
}

uint64_t segPumpCopyAndCreateNetworkURLFromPumpCache(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  const __CFAllocator *AllocatorForMedia;
  const void *v8;
  uint64_t v9;
  CFStringRef URLString;

  URLString = 0;
  v5 = *(_QWORD *)(a1 + 296);
  if (!v5)
    goto LABEL_10;
  if (*(_BYTE *)(a1 + 8712))
  {
    if (*(_BYTE *)(a1 + 7996) && *(_QWORD *)(a1 + 384) == a2)
      goto LABEL_7;
LABEL_10:
    v8 = *(const void **)(a2 + 24);
    if (v8)
      v8 = CFRetain(v8);
    goto LABEL_12;
  }
  if (!*(_BYTE *)(a1 + 7997))
    goto LABEL_10;
LABEL_7:
  if (!*(_QWORD *)(a2 + 64))
    goto LABEL_10;
  v6 = FigStreamingCacheMediaStreamCopyNetworkURL(v5, *(_QWORD *)(a2 + 64), &URLString);
  if (!(_DWORD)v6)
  {
    AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    v8 = CFURLCreateWithString(AllocatorForMedia, URLString, 0);
LABEL_12:
    v9 = 0;
    *a3 = v8;
    goto LABEL_13;
  }
  v9 = v6;
LABEL_13:
  if (URLString)
    CFRelease(URLString);
  return v9;
}

void segPumpDeliverFromCache(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  const __CFArray *MediaSegmentSpecifiers;
  uint64_t v13;
  const void *MediaEntryForMediaSequence;
  const void *v15;
  const void *MediaFilePrivateData;
  uint64_t MapSegmentSpecifier;
  const void *v18;
  uint64_t v19;
  char v20;
  uint64_t MediaForSingleStream;
  uint64_t v22;
  size_t DataLength;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v27;
  void (*v28)(uint64_t, __CFString *, __CFString *, size_t);
  uint64_t v29;
  uint64_t MediaSequence;
  uint64_t v31;
  unint64_t v32;
  __int16 v33;
  CMBlockBufferRef theBuffer;
  uint64_t v35;
  CFTypeRef cf;

  v35 = 0;
  cf = 0;
  theBuffer = 0;
  v33 = 0;
  v32 = 0;
  v10 = segPumpLockAndCopyPumpFromRetainProxy(a1, &cf, &v35);
  if ((_DWORD)v10)
    goto LABEL_51;
  if (!*(_QWORD *)(v35 + 296))
    goto LABEL_45;
  v11 = *(_QWORD *)(a2 + 56);
  if (!v11)
    goto LABEL_20;
  MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v11);
  if (!MediaSegmentSpecifiers || CFArrayGetCount(MediaSegmentSpecifiers) <= 0)
    goto LABEL_20;
  v13 = *(_QWORD *)(a2 + 56);
  if (!v13)
    goto LABEL_45;
  MediaEntryForMediaSequence = segPumpGetMediaEntryForMediaSequence(v13, a5);
  if (!MediaEntryForMediaSequence)
    goto LABEL_45;
  v15 = MediaEntryForMediaSequence;
  MediaFilePrivateData = segPumpGetMediaFilePrivateData(MediaEntryForMediaSequence);
  MapSegmentSpecifier = FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v15);
  v18 = *(const void **)(a2 + 256);
  if (v15 != v18)
  {
    if (!MapSegmentSpecifier)
      goto LABEL_45;
    v15 = (const void *)MapSegmentSpecifier;
    if ((const void *)MapSegmentSpecifier != v18)
      goto LABEL_45;
  }
  if (*(_QWORD *)(v35 + 8096) && !*(_QWORD *)(v35 + 8144))
    goto LABEL_45;
  if (*(_QWORD *)(a2 + 1160) != a3 || *(_QWORD *)(a2 + 880) != a4)
  {
LABEL_20:
    FigSignalErrorAt();
    goto LABEL_45;
  }
  if (!*((_QWORD *)MediaFilePrivateData + 14))
  {
    segPumpGetRequestedByteRangeForMediaFileHelper(v35, (_QWORD *)a2, v15, v15, 1u, 0, 0, &v32);
    *((_QWORD *)MediaFilePrivateData + 8) = v32;
    a4 = *(_QWORD *)(a2 + 880);
  }
  if (FigMediaSegmentSpecifierGetType((uint64_t)v15) == 1)
  {
    v19 = segPumpCopyMapEntryFromCache(v35, a2, (uint64_t)v15, &theBuffer);
    v20 = 1;
    if ((_DWORD)v19)
    {
LABEL_19:
      MediaForSingleStream = segPumpHandleMediaFileNetworkError((uint64_t)cf, (_QWORD *)a2, 0, (uint64_t)v15, v19);
      goto LABEL_43;
    }
  }
  else
  {
    v19 = FigStreamingCacheMediaSegmentCopyBytes(*(_QWORD *)(v35 + 296), *(_QWORD *)(a2 + 64), *((CMBlockBufferRef **)MediaFilePrivateData + 13), *((_QWORD *)MediaFilePrivateData + 14), 0x20000uLL, (BOOL *)&v33 + 1, &theBuffer);
    v20 = 0;
    if ((_DWORD)v19)
      goto LABEL_19;
  }
  v22 = v35;
  *(_DWORD *)(v35 + 8464) = 100;
  segPumpUpdateNetworkCostHasHighSpeedHighPower(v22);
  if (!HIBYTE(v33))
  {
    FigStreamingCacheMediaSegmentIsComplete(*(_QWORD *)(v35 + 296), *(_QWORD *)(a2 + 64), *((_BYTE **)MediaFilePrivateData + 13), &v33);
    if ((_BYTE)v33)
      v20 = 1;
  }
  DataLength = CMBlockBufferGetDataLength(theBuffer);
  *((_QWORD *)MediaFilePrivateData + 14) += DataLength;
  v24 = v35;
  v25 = *(_QWORD *)(v35 + 9048);
  if (v25)
  {
    v26 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                              + 96);
    if (v26)
      v26(v25, CFSTR("bytePumpStats"), CFSTR("IfTy"), 100);
    v27 = *(_QWORD *)(v24 + 9048);
    if (v27)
    {
      v28 = *(void (**)(uint64_t, __CFString *, __CFString *, size_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                               + 32);
      if (v28)
        v28(v27, CFSTR("bytePumpStats"), CFSTR("CachedBytes"), DataLength);
    }
  }
  segPumpRTCReportingSetCurrentAlternateIndexAndBitRate(v24);
  if (FigMediaSegmentSpecifierGetContentKeySpecifier(*(_QWORD *)(a2 + 256)) && *(_BYTE *)(v35 + 322))
  {
    if (segPumpMediaFileHandleCryptData((uint64_t)cf, v35, a2, *(const void **)(a2 + 256), theBuffer, 0, DataLength, v20, 0x400u))goto LABEL_45;
    goto LABEL_36;
  }
  v10 = segPumpSendMediaCallback((uint64_t)cf, v35, a2, v15, theBuffer, 0, DataLength, v20, 0x400u);
  if ((_DWORD)v10)
  {
LABEL_51:
    v31 = v10;
LABEL_44:
    segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(a1, v31);
    goto LABEL_45;
  }
LABEL_36:
  if (!FigRetainProxyIsInvalidated() && a4 == *(_QWORD *)(a2 + 880) && *(const void **)(a2 + 256) == v15)
  {
    if (HIBYTE(v33))
    {
      v29 = v35;
      MediaSequence = FigMediaSegmentSpecifierGetMediaSequence((uint64_t)v15);
      MediaForSingleStream = segPumpDispatchAsyncMediaDelivery(v29, a2, MediaSequence, -1, 0, (uint64_t)segPumpDeliverFromCache);
    }
    else
    {
      if (v15 == *(const void **)(*(_QWORD *)(a2 + 696) + 8))
      {
        *(_BYTE *)(a2 + 404) = 1;
        goto LABEL_45;
      }
      segPumpMarkMediaFileAsDelivered((uint64_t *)a2, v15);
      *((_QWORD *)MediaFilePrivateData + 13) = 0;
      MediaForSingleStream = segPumpDeliverNextMediaForSingleStream(cf, v35, a2);
    }
LABEL_43:
    v31 = MediaForSingleStream;
    if (!(_DWORD)MediaForSingleStream)
      goto LABEL_45;
    goto LABEL_44;
  }
LABEL_45:
  FigRetainProxyUnlockMutex();
  if (theBuffer)
    CFRelease(theBuffer);
  if (cf)
    CFRelease(cf);
}

const void *segPumpChooseNextStep(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, BOOL *a7, double *a8, double a9, double a10, _BYTE *a11, _BYTE *a12, _BYTE *a13, uint64_t *a14)
{
  uint64_t MediaEntryForTimeFromEnd;
  uint64_t v19;
  _BYTE *v20;
  const void *v21;
  uint64_t LastValue;
  int v23;
  const void *v24;
  uint64_t v25;
  double LiveBoundary;
  unint64_t MediaSequence;
  unint64_t v28;
  uint64_t v31;
  uint64_t NextSegment;
  int v33;
  unint64_t v34;
  unint64_t v35;
  BOOL v36;
  uint64_t v37;
  const void *v38;
  int v39;
  uint64_t PreviousSegment;
  uint64_t v41;
  uint64_t v42;
  double v43;
  float v44;
  double v45;
  uint64_t v46;
  uint64_t UpTimeNanoseconds;
  double v48;
  double v49;
  double v50;
  uint64_t v51;
  int v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  double TimeInSeconds;
  char v57;
  _BOOL4 v58;
  const __CFURL *v59;
  const __CFURL *v60;
  _QWORD *MediaFilePrivateData;
  uint64_t v62;
  uint64_t v63;
  const void *MapSegmentSpecifier;
  char v65;
  uint64_t v66;
  const void *v67;
  unsigned int v68;
  uint64_t *v69;
  BOOL *v70;
  NSObject *v71;
  char v73;
  uint64_t v74;
  uint64_t v75;
  float v76;
  double v77;
  double *v78;
  uint64_t v79;
  double v80;
  uint64_t v81;
  const void *v82;
  double *v83;
  double v84;
  uint64_t v85;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  const void *v87;
  BOOL v88;
  double *v89;
  _BYTE *v90;
  const void *v93;
  uint64_t v96;
  int v98;
  uint64_t v99;
  char v100;
  int v101;
  uint64_t v102;

  MediaEntryForTimeFromEnd = a2;
  v102 = *MEMORY[0x1E0C80C00];
  v19 = *(_QWORD *)(a1 + 384);
  v98 = *(unsigned __int8 *)(v19 + 857);
  v20 = (_BYTE *)(a1 + 7996);
  v100 = 0;
  *a11 = 0;
  *a12 = 0;
  *a13 = 0;
  if (!a2)
    MediaEntryForTimeFromEnd = (uint64_t)segPumpGetMediaEntryForTimeFromEnd(*(_QWORD *)(v19 + 56), 0, 0, a9);
  v21 = segPumpGetMediaEntryForTimeFromEnd(*(_QWORD *)(v19 + 56), a9 > a10, 0, a10);
  if (!v21)
  {
    FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(v19 + 56));
    if (a9 > a10)
      LastValue = FigCFArrayGetLastValue();
    else
      LastValue = FigCFArrayGetFirstValue();
    v21 = (const void *)LastValue;
  }
  v90 = v20;
  if (v20[6])
  {
    v23 = 0;
    v24 = 0;
  }
  else
  {
    v25 = *(_QWORD *)(v19 + 56);
    LiveBoundary = segPumpGetLiveBoundary(a1, v25);
    v24 = segPumpGetMediaEntryForTimeFromEnd(v25, 0, 0, LiveBoundary);
    if (v24)
    {
      if (MediaEntryForTimeFromEnd)
      {
        MediaSequence = FigMediaSegmentSpecifierGetMediaSequence(MediaEntryForTimeFromEnd);
        if (MediaSequence > FigMediaSegmentSpecifierGetMediaSequence((uint64_t)v24))
          MediaEntryForTimeFromEnd = (uint64_t)v24;
      }
      if (v21)
      {
        v28 = FigMediaSegmentSpecifierGetMediaSequence((uint64_t)v21);
        if (v28 > FigMediaSegmentSpecifierGetMediaSequence((uint64_t)v24))
          v21 = v24;
      }
      v23 = 1;
    }
    else
    {
      v23 = 0;
    }
  }
  if ((const void *)MediaEntryForTimeFromEnd == v21 && MediaEntryForTimeFromEnd != 0 && v98 == 0)
  {
    if (a9 > a10)
    {
      v31 = (uint64_t)v24;
      if (v21 == v24)
        goto LABEL_32;
      NextSegment = FigMediaSegmentSpecifierGetNextSegment((uint64_t)v21);
    }
    else
    {
      NextSegment = FigMediaSegmentSpecifierGetPreviousSegment((uint64_t)v21);
    }
    v31 = NextSegment;
    goto LABEL_32;
  }
  v31 = (uint64_t)v21;
LABEL_32:
  if (v31)
    v33 = v23;
  else
    v33 = 0;
  if (v33 == 1)
  {
    v34 = FigMediaSegmentSpecifierGetMediaSequence(v31);
    v35 = FigMediaSegmentSpecifierGetMediaSequence((uint64_t)v24);
    if (a9 > a10 && v34 >= v35 && *((_BYTE *)segPumpGetMediaFilePrivateData(v24) + 73))
    {
      v36 = 0;
      v37 = 0;
      v38 = 0;
      *a13 = 1;
LABEL_58:
      v43 = 0.0;
      goto LABEL_128;
    }
  }
  else if (!v31)
  {
    v36 = 0;
    v37 = 0;
    v38 = 0;
    goto LABEL_58;
  }
  if (!MediaEntryForTimeFromEnd)
  {
    FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(v19 + 56));
    MediaEntryForTimeFromEnd = FigCFArrayGetLastValue();
  }
  v39 = a6;
  if (v31 == MediaEntryForTimeFromEnd)
  {
    v42 = 1;
    v38 = (const void *)v31;
  }
  else
  {
    if (a9 > a10)
    {
      v41 = FigMediaSegmentSpecifierGetNextSegment(MediaEntryForTimeFromEnd);
      PreviousSegment = v31;
      v38 = (const void *)v41;
      if (!v41)
      {
        FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(v19 + 56));
        v41 = FigCFArrayGetLastValue();
        PreviousSegment = v31;
        v38 = (const void *)v41;
      }
    }
    else
    {
      PreviousSegment = FigMediaSegmentSpecifierGetPreviousSegment(MediaEntryForTimeFromEnd);
      v41 = v31;
      v38 = (const void *)PreviousSegment;
      if (!PreviousSegment)
      {
        FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(v19 + 56));
        PreviousSegment = FigCFArrayGetFirstValue();
        v41 = v31;
        v38 = (const void *)PreviousSegment;
      }
    }
    v42 = 1;
    if (v38 == (const void *)v31)
    {
      v38 = (const void *)v31;
    }
    else if (v41 && v41 != PreviousSegment)
    {
      v42 = 1;
      do
      {
        v41 = FigMediaSegmentSpecifierGetNextSegment(v41);
        ++v42;
      }
      while (v41 && v41 != PreviousSegment);
    }
    v39 = a6;
  }
  v44 = *(float *)(a1 + 8736);
  if (v44 == 0.0)
    v45 = 1.0;
  else
    v45 = 1.0 / fabsf(v44);
  v89 = a8;
  v99 = 0;
  v46 = *(_QWORD *)(a1 + 8744);
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v48 = 0.0;
  if ((double)(a3 - UpTimeNanoseconds) / 1000000000.0 >= 0.0)
    v49 = (double)(a3 - UpTimeNanoseconds) / 1000000000.0;
  else
    v49 = 0.0;
  if (!v38)
  {
    v37 = 0;
    v36 = 0;
    v43 = 0.0;
    goto LABEL_113;
  }
  v36 = 0;
  v50 = v45 * (vabdd_f64(a10, a9) / (double)v46);
  v96 = v19;
  v51 = 1;
  v93 = (const void *)v31;
  while (1)
  {
    if (*(_QWORD *)(a1 + 296)
      && *(_QWORD *)(v19 + 64)
      && segPumpSeeIfMediaFileIsInCache(a1, v19, v38, &v99, &v100))
    {
      v52 = 0;
      v53 = 1;
      v43 = 0.0;
    }
    else
    {
      v54 = FigMediaSegmentSpecifierGetBytesToRead((uint64_t)v38);
      v43 = segPumpPredictIFrameDownload(a1, v54);
      v53 = 0;
      v52 = 1;
    }
    v55 = (uint64_t)v38;
    if (a9 <= a10 || (v55 = FigMediaSegmentSpecifierGetPreviousSegment((uint64_t)v38)) != 0)
      TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds(v55);
    else
      TimeInSeconds = 0.0;
    v48 = v48 + v45 * TimeInSeconds;
    v57 = v52 ^ 1;
    if (v39)
      v57 = 0;
    if ((v57 & 1) == 0)
    {
      v58 = v43 < v49 + v48;
      if (v48 < v50)
        v58 = 0;
      if (v38 == (const void *)v31 || v58)
        break;
    }
LABEL_96:
    if (v98)
    {
      if (!v52)
      {
        if (v53)
        {
LABEL_110:
          v37 = 0;
LABEL_111:
          *a12 = 1;
          goto LABEL_113;
        }
LABEL_112:
        v37 = 0;
        goto LABEL_113;
      }
    }
    else
    {
      v65 = v53 ^ 1;
      if (v42 - 1 > v51)
        v65 = 1;
      if ((v65 & 1) == 0)
        goto LABEL_110;
    }
    if (a9 > a10)
      v66 = FigMediaSegmentSpecifierGetNextSegment((uint64_t)v38);
    else
      v66 = FigMediaSegmentSpecifierGetPreviousSegment((uint64_t)v38);
    v38 = (const void *)v66;
    ++v51;
    if (!v66)
      goto LABEL_112;
  }
  v60 = *(const __CFURL **)(v19 + 16);
  v59 = *(const __CFURL **)(v19 + 24);
  MediaFilePrivateData = segPumpGetMediaFilePrivateData(v38);
  segPumpEnsureMediaSegmentURLs(v38, v60, v59);
  if (!MediaFilePrivateData[2])
  {
    FigSignalErrorAt();
    goto LABEL_143;
  }
  v31 = (uint64_t)v93;
  v39 = a6;
  if (!v36)
  {
    if (!FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v38))
      goto LABEL_92;
    LOBYTE(v101) = 0;
    MapSegmentSpecifier = (const void *)FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v38);
    if (!segPumpIsMapEntryCached(a1, v96, MapSegmentSpecifier, (char *)&v101))
    {
      if (!(_BYTE)v101)
      {
        v36 = 1;
        goto LABEL_86;
      }
LABEL_92:
      v36 = 0;
      goto LABEL_93;
    }
    v36 = 0;
LABEL_143:
    v37 = 0;
    goto LABEL_127;
  }
LABEL_86:
  if (!a4)
  {
    v37 = 0;
    v38 = 0;
    goto LABEL_127;
  }
  v62 = FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v38);
  v63 = FigMediaSegmentSpecifierGetBytesToRead(v62);
  v43 = v43 + segPumpPredictIFrameDownload(a1, v63);
LABEL_93:
  if (v38 != v93 && v43 >= v49 + v48)
  {
    v19 = v96;
    goto LABEL_96;
  }
  v37 = (uint64_t)((double)a3 + v48 * 1000000000.0);
  if (v53)
  {
    v19 = v96;
    goto LABEL_111;
  }
  if (a5)
    v73 = v52;
  else
    v73 = 0;
  if ((v73 & 1) == 0)
    goto LABEL_141;
  v19 = v96;
  if (!**(_QWORD **)(v96 + 768))
    goto LABEL_113;
  v74 = *(_QWORD *)(v96 + 696);
  if (v74 && (v75 = *(_QWORD *)(v74 + 8)) != 0 && FigMediaSegmentSpecifierGetType(v75) == 1)
  {
LABEL_141:
    v19 = v96;
  }
  else
  {
    v76 = *(float *)(a1 + 8736);
    if (v76 == 0.0)
      v77 = 1.0;
    else
      v77 = 1.0 / v76;
    v78 = (double *)segPumpGetMediaFilePrivateData(v38);
    if (*(uint64_t *)(v96 + 776) > 0)
    {
      v79 = 0;
      v80 = v78[4];
      v19 = v96;
      while (1)
      {
        v81 = **(_QWORD **)(v19 + 768);
        if (!v81)
          goto LABEL_167;
        v82 = *(const void **)(v81 + 8);
        if (v82)
        {
          v83 = (double *)segPumpGetMediaFilePrivateData(*(const void **)(v81 + 8));
          if (v38 == v82)
          {
            v87 = v38;
            v37 = (uint64_t)((double)a3 + v48 * 1000000000.0);
LABEL_171:
            v19 = v96;
            segPumpAdoptReadAhead(a1, v96, v87, 0, 0);
            *a11 = 1;
            goto LABEL_113;
          }
          v84 = v83[4];
          if (v84 <= v80)
            v85 = FigMediaSegmentSpecifierGetPreviousSegment((uint64_t)v38);
          else
            v85 = FigMediaSegmentSpecifierGetNextSegment((uint64_t)v38);
          v87 = (const void *)v85;
          if (v85 == *(_QWORD *)(**(_QWORD **)(v96 + 768) + 8))
          {
            v37 = (uint64_t)((double)(uint64_t)((double)a3 + v48 * 1000000000.0) + v77 * (v84 - v80) * 1000000000.0);
            v38 = (const void *)v85;
            goto LABEL_171;
          }
          v88 = v84 > v80;
          if (a9 <= a10)
            v88 = v84 < v80;
          v19 = v96;
          if (v88)
            goto LABEL_167;
          segPumpStreamCancelReadAheadAndResetDataAtIndex(a1, v96, 0);
          ++*(_QWORD *)(a1 + 8856);
        }
        else
        {
          if (dword_1EE2A31E8)
          {
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          v19 = v96;
          segPumpStreamCancelReadAheadAndResetDataAtIndex(a1, v96, 0);
        }
        if (++v79 >= *(_QWORD *)(v19 + 776))
          goto LABEL_167;
      }
    }
    v19 = v96;
LABEL_167:
    v37 = (uint64_t)((double)a3 + v48 * 1000000000.0);
  }
LABEL_113:
  if (v36 && v38)
  {
    if (FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v38))
    {
      LOBYTE(v101) = 0;
      v67 = (const void *)FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v38);
      if (segPumpIsMapEntryCached(a1, v19, v67, (char *)&v101))
      {
        v36 = 0;
        goto LABEL_127;
      }
      v36 = (_BYTE)v101 == 0;
    }
    else
    {
      v36 = 0;
    }
  }
  if (*(_QWORD *)(a1 + 296))
  {
    v68 = 1;
    if (*v90)
    {
      if (v90[1])
        v68 = 1;
      else
        v68 = 2;
    }
  }
  else
  {
    v68 = 1;
  }
  if (v68 <= dword_1EE2A31E8)
  {
    v71 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT);
    a8 = v89;
    v70 = a7;
    v69 = a14;
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  else
  {
LABEL_127:
    a8 = v89;
LABEL_128:
    v70 = a7;
    v69 = a14;
  }
  *v70 = v36;
  *a8 = v43;
  *v69 = v37;
  return v38;
}

double segPumpGetLiveBoundary(uint64_t a1, uint64_t a2)
{
  double MinimumPrebufferReservation;
  double v4;
  double result;
  double v6;
  double v7;
  double v8;

  MinimumPrebufferReservation = segPumpGetMinimumPrebufferReservation(a1, a2);
  v4 = *(double *)(a1 + 7960);
  result = MinimumPrebufferReservation + v4;
  if (*(int *)(a1 + 7944) >= 2)
  {
    LODWORD(v4) = *(_DWORD *)(a1 + 8);
    v6 = (double)*(unint64_t *)&v4;
    if (result > v6)
      result = result - v6;
  }
  v7 = *(double *)(a1 + 7952);
  if (v7 > 0.0 && (v7 > result || *(_BYTE *)(a1 + 328)))
  {
    v8 = *(double *)(a1 + 16);
    if (v8 <= 0.0)
    {
      LODWORD(v8) = *(_DWORD *)(a1 + 8);
      v8 = (double)*(unint64_t *)&v8;
    }
    return v7 - v8;
  }
  return result;
}

double segPumpPredictIFrameDownload(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t UpTimeNanoseconds;
  unsigned int (*v6)(uint64_t, uint64_t, _OWORD *, __int128 *);
  double v7;
  double v8;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  _BYTE v16[224];
  _OWORD v17[14];

  memset(&v16[8], 0, 216);
  segPumpMakeNetworkPredictionInput(a1, (uint64_t)v16);
  v15 = 0;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v10 = 0u;
  *(_QWORD *)v16 = *(_QWORD *)(a1 + 112);
  *(_QWORD *)&v16[32] = a2;
  *(_QWORD *)&v16[168] |= 8uLL;
  v4 = *(_QWORD *)(a1 + 96);
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v6 = *(unsigned int (**)(uint64_t, uint64_t, _OWORD *, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                             + 8);
  v7 = 0.0;
  if (v6)
  {
    v17[10] = *(_OWORD *)&v16[160];
    v17[11] = *(_OWORD *)&v16[176];
    v17[12] = *(_OWORD *)&v16[192];
    v17[13] = *(_OWORD *)&v16[208];
    v17[6] = *(_OWORD *)&v16[96];
    v17[7] = *(_OWORD *)&v16[112];
    v17[8] = *(_OWORD *)&v16[128];
    v17[9] = *(_OWORD *)&v16[144];
    v17[2] = *(_OWORD *)&v16[32];
    v17[3] = *(_OWORD *)&v16[48];
    v17[4] = *(_OWORD *)&v16[64];
    v17[5] = *(_OWORD *)&v16[80];
    v17[0] = *(_OWORD *)v16;
    v17[1] = *(_OWORD *)&v16[16];
    if (!v6(v4, UpTimeNanoseconds, v17, &v10))
    {
      v8 = *((double *)&v11 + 1) * (double)(uint64_t)v10;
      if (v8 > 0.0)
        return (double)(unint64_t)(8 * a2) / v8;
    }
  }
  return v7;
}

void segPumpRTCReportingUpdateCryptorErrorKeys(uint64_t a1, CFErrorRef err)
{
  CFNumberRef v4;
  uint64_t v5;
  void (*v6)(uint64_t, __CFString *, __CFString *, CFNumberRef, uint64_t);
  uint64_t v7;
  CFErrorDomain Domain;
  CFErrorDomain v9;
  void (*v10)(uint64_t, __CFString *, __CFString *, CFErrorDomain, uint64_t);
  CFIndex valuePtr;

  if (err)
  {
    valuePtr = CFErrorGetCode(err);
    v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberLongType, &valuePtr);
    v5 = *(_QWORD *)(a1 + 9048);
    if (!v5)
    {
      CFErrorGetDomain(err);
      if (!v4)
        return;
      goto LABEL_9;
    }
    v6 = *(void (**)(uint64_t, __CFString *, __CFString *, CFNumberRef, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                          + 120);
    if (v6)
      v6(v5, CFSTR("cryptorStats"), CFSTR("CryptorErrorCode"), v4, 100);
    v7 = *(_QWORD *)(a1 + 9048);
    Domain = CFErrorGetDomain(err);
    if (v7)
    {
      v9 = Domain;
      v10 = *(void (**)(uint64_t, __CFString *, __CFString *, CFErrorDomain, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                               + 120);
      if (v10)
        v10(v7, CFSTR("cryptorStats"), CFSTR("CryptorErrorDomain"), v9, 100);
    }
    if (v4)
LABEL_9:
      CFRelease(v4);
  }
}

uint64_t segPumpPrepareCryptorForKeyLoading(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, unsigned __int8 *a5)
{
  uint64_t v8;
  _QWORD *v9;
  uint64_t (*v10)(uint64_t, uint64_t, uint64_t, unsigned __int8 *, uint64_t *);
  uint64_t result;
  int v12;
  BOOL v13;
  uint64_t v15;
  unsigned __int8 v16;

  v16 = 0;
  v15 = 0;
  if (a3)
    v8 = 3;
  else
    v8 = 1;
  v9 = *(_QWORD **)(CMBaseObjectGetVTable() + 16);
  if (*v9 < 6uLL)
    return 4294954514;
  v10 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, unsigned __int8 *, uint64_t *))v9[20];
  if (!v10)
    return 4294954514;
  result = v10(a1, v8, 2, &v16, &v15);
  if (!(_DWORD)result)
  {
    v12 = v16;
    *a5 = v16;
    *a4 = v15;
    if (a1)
    {
      CMNotificationCenterGetDefaultLocalCenter();
      if (v12)
      {
        FigNotificationCenterRemoveWeakListener();
        CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterRemoveWeakListener();
        return 0;
      }
      else
      {
        result = FigNotificationCenterAddWeakListener();
        if ((_DWORD)result)
          v13 = (_DWORD)result == -12724;
        else
          v13 = 1;
        if (v13)
        {
          CMNotificationCenterGetDefaultLocalCenter();
          LODWORD(result) = FigNotificationCenterAddWeakListener();
          if ((_DWORD)result == -12724 || (_DWORD)result == 0)
            return 0;
          else
            return result;
        }
      }
    }
    else
    {
      return FigSignalErrorAt();
    }
  }
  return result;
}

CFIndex CryptKeyRemoveKeyFromPlaylist(uint64_t a1, _BYTE *a2, const void *a3)
{
  CFIndex result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFTypeRef cf;

  cf = 0;
  segPumpGetCryptKeyCommonData(a3, 0, &cf);
  FigMediaPlaylistRemoveContentKeySpecifier(a2, (uint64_t)a3);
  result = (CFIndex)cf;
  if (cf)
  {
    v7 = *(_QWORD *)(a1 + 8144);
    if (!v7)
    {
      result = CFGetRetainCount(cf);
      if (result != 1)
        return result;
      return FigCFArrayRemoveLastElementOfValue();
    }
    v8 = *((_QWORD *)cf + 20);
    v9 = *(_QWORD *)(v7 + 8);
    result = CFGetRetainCount(cf);
    if (result == 1 && (v8 == v9 || !*(_BYTE *)(a1 + 8002)))
      return FigCFArrayRemoveLastElementOfValue();
  }
  return result;
}

void segPumpMediaExpiryTimerCallback(uint64_t a1, uint64_t a2)
{
  __n128 v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  const void *LastValue;
  uint64_t UpTimeNanoseconds;
  double v11;
  uint64_t PreviousSegment;
  _BYTE *MediaFilePrivateData;
  _BYTE *v14;
  uint64_t v15;
  _BOOL4 v17;
  BOOL v18;
  const __CFArray *PartialSegments;
  CFIndex v21;
  CFIndex Count;
  const void *ValueAtIndex;
  _BOOL4 v24;
  int v26;
  int v27[2];
  CFTypeRef cf;

  *(_QWORD *)v27 = 0;
  cf = 0;
  if (segPumpLockAndCopyPumpFromRetainProxy(a2, &cf, (uint64_t *)v27))
    goto LABEL_53;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v26 = 0;
  v6 = 0;
  v2.n128_u64[0] = 0x41FE133800000000;
  do
  {
    v7 = *(_QWORD *)(*(_QWORD *)v27 + 16 * v3 + 384);
    v8 = *(_QWORD *)(v7 + 56);
    if (!v8)
      goto LABEL_43;
    FigMediaPlaylistGetMediaSegmentSpecifiers(v8);
    LastValue = (const void *)FigCFArrayGetLastValue();
    UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    v11 = *(double *)(v7 + 88);
    v6 = 0;
    if (!LastValue)
    {
LABEL_37:
      if (!v3)
        goto LABEL_38;
      goto LABEL_40;
    }
    while (1)
    {
      PreviousSegment = FigMediaSegmentSpecifierGetPreviousSegment((uint64_t)LastValue);
      MediaFilePrivateData = segPumpGetMediaFilePrivateData(LastValue);
      if (!MediaFilePrivateData[96])
        break;
LABEL_36:
      LastValue = (const void *)PreviousSegment;
      if (!PreviousSegment)
        goto LABEL_37;
    }
    v14 = MediaFilePrivateData;
    v15 = *((_QWORD *)MediaFilePrivateData + 11);
    if (UpTimeNanoseconds < v15 && v6 == 0)
    {
      v6 = 0;
      if (v5)
        v18 = v15 < v4;
      else
        v18 = 1;
      if (v18)
      {
        v5 = 1;
        v4 = *((_QWORD *)MediaFilePrivateData + 11);
      }
      goto LABEL_36;
    }
    if (MediaFilePrivateData[73])
    {
      FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(v7 + 56));
      v17 = LastValue == (const void *)FigCFArrayGetLastValue();
    }
    else
    {
      v17 = 1;
    }
    v26 = *(unsigned __int8 *)(*(_QWORD *)v27 + 8002);
    v14[96] = 1;
    *(double *)(v7 + 88) = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)LastValue) + *(double *)(v7 + 88);
    *(double *)(v7 + 96) = *(double *)(v7 + 96) - FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)LastValue);
    PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)LastValue);
    v21 = 0;
    if (PartialSegments)
    {
LABEL_23:
      Count = CFArrayGetCount(PartialSegments);
      goto LABEL_25;
    }
    while (1)
    {
      Count = 0;
LABEL_25:
      if (v21 >= Count)
        break;
      ValueAtIndex = CFArrayGetValueAtIndex(PartialSegments, v21);
      *((_BYTE *)segPumpGetMediaFilePrivateData(ValueAtIndex) + 96) = 1;
      ++v21;
      if (PartialSegments)
        goto LABEL_23;
    }
    if (!*(_BYTE *)(*(_QWORD *)v27 + 7995)
      || (*(_QWORD *)(*(_QWORD *)v27 + 8416) == v3 ? (v24 = v17) : (v24 = 0),
          !v24 || *(_BYTE *)(v7 + 400) || !*(_QWORD *)(v7 + 424)))
    {
      v6 = 1;
      goto LABEL_36;
    }
    segPumpStopPlaylistReadsAndResetAllData(*(uint64_t *)v27);
    if (*(_QWORD *)(v7 + 504) && *(_BYTE *)(v7 + 867))
      segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(a2, 4294954412);
    v5 = 0;
    v6 = 1;
    if (!v3)
    {
LABEL_38:
      if (*(_BYTE *)(*(_QWORD *)v27 + 8713))
      {
        v2 = (__n128)vaddq_f64(*(float64x2_t *)(*(_QWORD *)v27 + 8720), (float64x2_t)vdupq_lane_s64(COERCE__INT64(*(double *)(v7 + 88) - v11), 0));
        *(__n128 *)(*(_QWORD *)v27 + 8720) = v2;
      }
    }
LABEL_40:
    if (v5)
    {
      v2.n128_f64[0] = (double)(v4 - UpTimeNanoseconds) / 1000000000.0 + CFAbsoluteTimeGetCurrent();
    }
    else
    {
      v5 = 0;
      v2.n128_u64[0] = 0x41FE133800000000;
    }
LABEL_43:
    ++v3;
  }
  while (v3 != 3);
  segPumpSetMediaFileExpireTimer(*(_QWORD *)v27, v2);
  if (v6)
  {
    segPumpReadyNotification(*(_QWORD **)v27, CFSTR("FBPAL_SeekableTimeRangeChanged"), 0);
    if (v26)
      segPumpReadyNotification(*(_QWORD **)v27, CFSTR("FBP_DurationChanged"), 0);
  }
LABEL_53:
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
}

void segPumpContentSteeringAlternateListChangedCallback(int a1, uint64_t a2, CFArrayRef theArray)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t AllocatorForMedia;
  uint64_t (*v8)(uint64_t, const __CFString *, uint64_t, CFTypeRef *);
  const void *ValueAtIndex;
  const __CFString *PathwayID;
  uint64_t v11;
  void (*v12)(uint64_t, __CFString *, __CFString *, const __CFString *, _QWORD);
  uint64_t v13;
  void (*v14)(uint64_t, __CFString *, __CFString *, uint64_t);
  uint64_t v15;
  uint64_t (*v16)(uint64_t, const __CFString *, const __CFString *);
  uint64_t v17;
  CFTypeRef cf;
  uint64_t v19;
  CFTypeRef v20;

  v19 = 0;
  v20 = 0;
  cf = 0;
  if (!theArray || CFArrayGetCount(theArray) < 1)
    return;
  v5 = segPumpLockAndCopyPumpFromRetainProxy(a2, &v20, &v19);
  if ((_DWORD)v5)
    goto LABEL_24;
  if (FigCFEqual())
  {
    v6 = *(_QWORD *)(v19 + 9552);
    AllocatorForMedia = FigGetAllocatorForMedia();
    v8 = *(uint64_t (**)(uint64_t, const __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                 + 8)
                                                                                     + 48);
    if (!v8)
    {
LABEL_17:
      v17 = 4294954514;
LABEL_18:
      segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(a2, v17);
      goto LABEL_19;
    }
    v5 = v8(v6, CFSTR("AlternateFilterMonitorProperty_CurrentPathwayID"), AllocatorForMedia, &cf);
    if (!(_DWORD)v5)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
      PathwayID = FigAlternateGetPathwayID((uint64_t)ValueAtIndex);
      v11 = *(_QWORD *)(v19 + 9048);
      if (v11)
      {
        v12 = *(void (**)(uint64_t, __CFString *, __CFString *, const __CFString *, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 48);
        if (v12)
          v12(v11, CFSTR("bytePumpStats"), CFSTR("CurrentPathway"), PathwayID, 0);
      }
      if (FigCFEqual())
        goto LABEL_19;
      v13 = *(_QWORD *)(v19 + 9048);
      if (v13)
      {
        v14 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                              + 16)
                                                                                  + 32);
        if (v14)
          v14(v13, CFSTR("bytePumpStats"), CFSTR("PathwaySwitches"), 1);
      }
      v15 = *(_QWORD *)(v19 + 9552);
      v16 = *(uint64_t (**)(uint64_t, const __CFString *, const __CFString *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 8)
                                                                                      + 56);
      if (v16)
      {
        v17 = v16(v15, CFSTR("AlternateFilterMonitorProperty_CurrentPathwayID"), PathwayID);
        if (!(_DWORD)v17)
          goto LABEL_19;
        goto LABEL_18;
      }
      goto LABEL_17;
    }
LABEL_24:
    v17 = v5;
    goto LABEL_18;
  }
LABEL_19:
  if (cf)
    CFRelease(cf);
  segPumpUnlockAndSendAllPendingNotifications();
  if (v20)
    CFRelease(v20);
}

void segPumpContentSteeringAlternatesAddedCallback(int a1, uint64_t a2, CFArrayRef theArray)
{
  uint64_t v5;
  uint64_t valid;
  int v7[2];
  CFTypeRef cf;

  *(_QWORD *)v7 = 0;
  cf = 0;
  if (theArray && CFArrayGetCount(theArray) >= 1)
  {
    v5 = segPumpLockAndCopyPumpFromRetainProxy(a2, &cf, (uint64_t *)v7);
    if ((_DWORD)v5)
    {
      valid = v5;
    }
    else
    {
      valid = segPumpAddNewAlternatesToValidAlternatesQueue(*(uint64_t *)v7, theArray);
      if (!(_DWORD)valid)
        goto LABEL_6;
    }
    segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(a2, valid);
LABEL_6:
    segPumpUnlockAndSendAllPendingNotifications();
    if (cf)
      CFRelease(cf);
  }
}

uint64_t segPumpAddNewAlternatesToValidAlternatesQueue(uint64_t a1, CFArrayRef theArray)
{
  CFIndex v4;
  const void *ValueAtIndex;
  uint64_t result;

  if (!theArray)
    return 0;
  if (CFArrayGetCount(theArray) < 1 || CFArrayGetCount(theArray) < 1)
    return 0;
  v4 = 0;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, v4);
    result = segPumpAddFigAlternate(a1, ValueAtIndex);
    if ((_DWORD)result)
      break;
    if (++v4 >= CFArrayGetCount(theArray))
      return 0;
  }
  return result;
}

void segPumpSetContentSteeringMonitor(uint64_t a1, CFTypeRef cf)
{
  const void *v2;

  v2 = *(const void **)(a1 + 9552);
  *(_QWORD *)(a1 + 9552) = cf;
  if (cf)
    CFRetain(cf);
  if (v2)
    CFRelease(v2);
}

double segPumpSetExtraHoldbackFromClient(uint64_t a1, uint64_t a2, double a3)
{
  double MinimumPrebufferReservation;
  double result;

  MinimumPrebufferReservation = segPumpGetMinimumPrebufferReservation(a2, 0);
  if (MinimumPrebufferReservation > a3)
  {
    segPumpAppendErrorLogEntry(a1, a2, 0, 0, -12640, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Cannot get that close to live"), 0, 0, 0, 3u);
    a3 = MinimumPrebufferReservation;
  }
  result = a3 - MinimumPrebufferReservation;
  *(double *)(a2 + 7960) = a3 - MinimumPrebufferReservation;
  return result;
}

double segPumpPlaylistGetEndDateOfLastPart(uint64_t a1)
{
  CFIndex v2;
  double v3;
  double v4;
  const __CFArray *MediaSegmentSpecifiers;
  CFIndex v6;
  const __CFArray *v7;
  const void *ValueAtIndex;
  uint64_t DateStamp;
  uint64_t LastValue;
  double v11;
  const void *v12;
  uint64_t v13;
  double v14;

  v2 = 0;
  v3 = 0.0;
  v4 = 0.0;
  while (1)
  {
    MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
    v6 = MediaSegmentSpecifiers ? CFArrayGetCount(MediaSegmentSpecifiers) : 0;
    v7 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
    if (v2 >= v6)
      break;
    ValueAtIndex = CFArrayGetValueAtIndex(v7, v2);
    if (FigMediaSegmentSpecifierGetDateStamp((uint64_t)ValueAtIndex))
    {
      DateStamp = FigMediaSegmentSpecifierGetDateStamp((uint64_t)ValueAtIndex);
      v3 = MEMORY[0x194029D14](DateStamp);
      v4 = *((double *)segPumpGetMediaFilePrivateData(ValueAtIndex) + 4);
    }
    ++v2;
  }
  LastValue = FigCFArrayGetLastValue();
  v11 = 0.0;
  if (LastValue)
  {
    FigMediaSegmentSpecifierGetPartialSegments(LastValue);
    v12 = (const void *)FigCFArrayGetLastValue();
    if (v12)
    {
      v13 = (uint64_t)v12;
      v14 = v3 + *((double *)segPumpGetMediaFilePrivateData(v12) + 4) - v4;
      return FigMediaSegmentSpecifierGetTimeInSeconds(v13) + v14;
    }
  }
  return v11;
}

uint64_t segPumpCreateDiscoInfoList(uint64_t a1, _QWORD *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  const __CFArray *MediaSegmentSpecifiers;
  uint64_t v10;
  const __CFArray *v11;
  const void *NextMediaFileWithDate;
  uint64_t v13;
  double *MediaFilePrivateData;
  uint64_t DateStamp;
  double v16;
  uint64_t FirstValue;
  uint64_t v18;
  CFIndex v19;
  uint64_t v20;
  double v21;
  const __CFArray *Count;
  const __CFArray *v23;
  const void *ValueAtIndex;
  uint64_t v25;
  _QWORD *v26;
  double *v27;
  double *v28;
  uint64_t v29;
  double **v30;
  uint64_t v31;

  v5 = *(_QWORD *)(a1 + 56);
  if (!v5)
    return 0;
  MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v5);
  if (!MediaSegmentSpecifiers
    || CFArrayGetCount(MediaSegmentSpecifiers) < 1
    || FigMediaPlaylistGetDateStampCount(*(_QWORD *)(a1 + 56)) < 1)
  {
    return 0;
  }
  segPumpFreeDiscoQueue((uint64_t)a2);
  v10 = *(_QWORD *)(a1 + 56);
  if (!v10
    || (v11 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v10)) == 0
    || CFArrayGetCount(v11) < 1
    || FigMediaPlaylistGetDateStampCount(*(_QWORD *)(a1 + 56)) < 1
    || (NextMediaFileWithDate = (const void *)segPumpGetNextMediaFileWithDate(*(_QWORD *)(a1 + 56), 0)) == 0)
  {
    v31 = 4294954513;
LABEL_22:
    segPumpFreeDiscoQueue((uint64_t)a2);
    v18 = 0;
LABEL_25:
    *a4 = v18;
    return v31;
  }
  v13 = (uint64_t)NextMediaFileWithDate;
  MediaFilePrivateData = (double *)segPumpGetMediaFilePrivateData(NextMediaFileWithDate);
  DateStamp = FigMediaSegmentSpecifierGetDateStamp(v13);
  v16 = MEMORY[0x194029D14](DateStamp) - MediaFilePrivateData[4] + *(double *)(a1 + 88);
  FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a1 + 56));
  FirstValue = FigCFArrayGetFirstValue();
  v18 = 0;
  v19 = 0;
  v20 = a3 + FigMediaSegmentSpecifierGetDiscontinuityDomain(FirstValue) - 1;
  v21 = 0.0;
  while (1)
  {
    Count = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a1 + 56));
    if (Count)
      Count = (const __CFArray *)CFArrayGetCount(Count);
    if (v19 >= (uint64_t)Count)
      break;
    v23 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a1 + 56));
    ValueAtIndex = CFArrayGetValueAtIndex(v23, v19);
    if (FigMediaSegmentSpecifierGetDateStamp((uint64_t)ValueAtIndex))
    {
      v25 = FigMediaSegmentSpecifierGetDateStamp((uint64_t)ValueAtIndex);
      v16 = MEMORY[0x194029D14](v25);
    }
    if (v20 != FigMediaSegmentSpecifierGetDiscontinuityDomain((uint64_t)ValueAtIndex) + a3)
    {
      v26 = segPumpGetMediaFilePrivateData(ValueAtIndex);
      v27 = (double *)malloc_type_calloc(1uLL, 0x30uLL, 0x10A0040CA010D23uLL);
      if (!v27)
        goto LABEL_27;
      v28 = v27;
      v29 = v26[4];
      v27[2] = v16;
      *((_QWORD *)v27 + 3) = v29;
      v20 = FigMediaSegmentSpecifierGetDiscontinuityDomain((uint64_t)ValueAtIndex) + a3;
      *((_QWORD *)v28 + 4) = v20;
      v28[5] = v21;
      v30 = (double **)a2[1];
      *v28 = 0.0;
      *((_QWORD *)v28 + 1) = v30;
      *v30 = v28;
      a2[1] = v28;
      ++v18;
      v21 = 0.0;
    }
    v16 = v16 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
    v21 = v21 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
    ++v19;
  }
  if (*a2)
  {
    v31 = 0;
    goto LABEL_25;
  }
LABEL_27:
  v31 = FigSignalErrorAt();
  if ((_DWORD)v31)
    goto LABEL_22;
  return v31;
}

uint64_t segPumpUpdateCMCDStreamType(uint64_t a1)
{
  uint64_t v2;

  if (!*(_QWORD *)(a1 + 9576)
    || *(_BYTE *)(*(_QWORD *)(a1 + 16 * *(_QWORD *)(a1 + 8416) + 384) + 866)
    || !segPumpEnsureCMCDHeaderVendor(a1))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 8002))
    v2 = 1;
  else
    v2 = 2;
  return FigCMCDHeaderVendorSetStreamType(*(_QWORD *)(a1 + 9576), v2);
}

uint64_t segPumpGetTimeRangeForDateWithSegmentOffset(const void *a1, uint64_t a2, const __CFDate *a3, CMTime *a4, CMTime *a5, _QWORD *a6)
{
  CFIndex v12;
  double v13;
  uint64_t FirstValue;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  const void *v16;
  int v17;
  int v18;
  const void *v19;
  double v20;
  uint64_t v21;
  double v22;
  double v23;
  double v24;
  double v25;
  uint64_t v27;
  const void *v28;
  const __CFDate *DateStamp;
  const __CFDate *v30;
  uint64_t v31;
  CMTimeValue value;
  uint64_t v33;
  const void *v34;
  uint64_t v35;
  BOOL v36;
  char v37;
  double v38;
  Float64 v39;
  _QWORD *v40;
  CMTime *v42;
  _QWORD *v43;
  os_log_type_t type[8];
  const void *v45;
  uint64_t v46;
  const void *v47;
  const void *v48;
  CMTime v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  CMBaseObjectGetDerivedStorage();
  v46 = 0;
  v12 = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if ((_DWORD)v12)
    goto LABEL_61;
  if (!a4)
  {
    v12 = FigSignalErrorAt();
LABEL_61:
    v35 = v12;
    return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v35);
  }
  if (!a2 || FigMediaPlaylistGetPlaylistActiveDurationSecs(a2) == 0.0)
    goto LABEL_32;
  v13 = MEMORY[0x194029D14](a3);
  FigMediaPlaylistGetMediaSegmentSpecifiers(a2);
  FirstValue = FigCFArrayGetFirstValue();
  v47 = (const void *)FirstValue;
  if (FirstValue || !dword_1EE2A31E8)
  {
    if (!FirstValue)
      goto LABEL_32;
    v42 = a5;
    v43 = a6;
    v48 = 0;
    if (!segPumpIterateMedia(a2, (uint64_t *)&v48, &v46, (uint64_t *)&v47))
    {
      v19 = 0;
      v18 = 0;
      v16 = 0;
      v25 = 0.0;
      v24 = 0.0;
      v23 = 0.0;
      v22 = 0.0;
      v21 = 0;
      v20 = 0.0;
LABEL_34:
      v36 = v13 > v25 + v20 || v16 == 0;
      v37 = v36;
      if (v36)
        v38 = v24;
      else
        v38 = v25;
      if (v36)
        v39 = v22;
      else
        v39 = v23;
      if (v18)
      {
        if (v19)
          v37 = 0;
        v40 = v43;
        if ((v37 & 1) != 0)
        {
          v35 = 4294954648;
          if (!v43)
            return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v35);
        }
        else
        {
          CMTimeMakeWithSeconds(&v49, v39, 90000);
          *a4 = v49;
          if (v42)
          {
            CMTimeMakeWithSeconds(&v49, v39 + v38, 90000);
            v35 = 0;
            *v42 = v49;
            if (!v43)
              return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v35);
          }
          else
          {
            v35 = 0;
            if (!v43)
              return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v35);
          }
        }
      }
      else
      {
        v35 = 4294954647;
        v40 = v43;
        if (!v43)
          return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v35);
      }
      *v40 = v21;
      return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v35);
    }
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0.0;
    v21 = 0;
    v22 = 0.0;
    v23 = 0.0;
    v24 = 0.0;
    v25 = 0.0;
    while (1)
    {
      if (v13 <= v25 + v20 && v16 != 0)
      {
        v19 = v16;
        v24 = v25;
        v22 = v23;
      }
      v27 = v46;
      v28 = v48;
      FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v48);
      if (v27 != FigCFArrayGetFirstValue() || !FigMediaSegmentSpecifierGetDateStamp((uint64_t)v28))
        goto LABEL_22;
      if (!v17)
      {
        DateStamp = (const __CFDate *)FigMediaSegmentSpecifierGetDateStamp((uint64_t)v28);
        if (CFDateCompare(a3, DateStamp, 0) == kCFCompareLessThan)
          break;
      }
      v30 = (const __CFDate *)FigMediaSegmentSpecifierGetDateStamp((uint64_t)v28);
      if (CFDateCompare(a3, v30, 0) != kCFCompareLessThan)
        break;
      v16 = 0;
      v18 = 1;
LABEL_29:
      FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v47);
      if (!segPumpIterateMedia(a2, (uint64_t *)&v48, &v46, (uint64_t *)&v47))
        goto LABEL_34;
    }
    v31 = FigMediaSegmentSpecifierGetDateStamp((uint64_t)v28);
    v20 = MEMORY[0x194029D14](v31);
    v23 = *((double *)segPumpGetMediaFilePrivateData(v28) + 4);
    v18 = 1;
    v25 = 0.0;
    v17 = 1;
    v16 = v28;
LABEL_22:
    if (v16 && v13 > v25 + v20)
    {
      v49.value = 0;
      *(_QWORD *)type = v27;
      v45 = v28;
      if (segPumpIterateMedia(a2, (uint64_t *)&v45, (uint64_t *)type, &v49.value)
        && (value = v49.value, FigMediaSegmentSpecifierGetDateStamp(v49.value)))
      {
        v33 = FigMediaSegmentSpecifierGetDateStamp(value);
        v25 = MEMORY[0x194029D14](v33) - v20;
        v34 = v47;
      }
      else
      {
        v34 = v47;
        v25 = v25 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v47);
      }
      v21 = *((_QWORD *)segPumpGetMediaFilePrivateData(v34) + 4);
    }
    goto LABEL_29;
  }
  LODWORD(v45) = 0;
  type[0] = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
  os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
  fig_log_call_emit_and_clean_up_after_send_and_compose();
LABEL_32:
  v35 = 4294954513;
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v35);
}

uint64_t segPumpStreamSyncTimeRolledPast(uint64_t a1, double a2, double a3)
{
  double v4;
  uint64_t result;
  double v6;

  v4 = a3 - (*(double *)(a1 + 88) + a2);
  result = FigMediaPlaylistGetTargetDuration(*(_QWORD *)(a1 + 56));
  if (v4 >= (double)result * -3.0)
  {
    result = FigMediaPlaylistGetTargetDuration(*(_QWORD *)(a1 + 56));
    if (v4 <= (double)result * 3.0)
    {
      v6 = v4 + *(double *)(a1 + 88);
      *(double *)(a1 + 88) = v6;
      if (fabs(v4) > 2.22044605e-16)
        return segPumpPlaylistRecalculatePumpTimeOffsets(*(_QWORD *)(a1 + 56), v6);
    }
  }
  return result;
}

CFIndex segPumpAPILockAndEnsureAPIStatus(const void *a1, int a2)
{
  _QWORD *DerivedStorage;
  CFIndex result;
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  CFRetain(a1);
  FigRetainProxyLockMutex();
  result = segPumpAPICheckStatus(DerivedStorage, 0);
  if (a2 && (_DWORD)result && (_DWORD)result != -12883)
  {
    v6 = (const void *)DerivedStorage[1002];
    if (v6)
    {
      CFRelease(v6);
      DerivedStorage[1002] = 0;
    }
    v7 = 48;
    while (1)
    {
      v8 = DerivedStorage[v7];
      if (*(_QWORD *)(v8 + 16))
      {
        *(_BYTE *)(v8 + 1136) = 0;
        v9 = *(const void **)(v8 + 1144);
        if (v9)
        {
          CFRelease(v9);
          *(_QWORD *)(v8 + 1144) = 0;
        }
        *(_BYTE *)(v8 + 866) = 1;
        result = segPumpRestartStreamReads(a1);
        if ((_DWORD)result)
          break;
      }
      v7 += 2;
      if (v7 == 54)
        return 0;
    }
  }
  return result;
}

BOOL segPumpIterateMedia(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v7;
  uint64_t v8;
  const __CFArray *NextSegment;
  CFIndex Count;
  uint64_t v11;

  v7 = *a2;
  if (*a2)
  {
    v8 = *a3;
    do
    {
      if (v8)
      {
        NextSegment = (const __CFArray *)FigMediaSegmentSpecifierGetNextSegment(v8);
        if (NextSegment)
          break;
      }
      else
      {
        FigMediaSegmentSpecifierGetPartialSegments(v7);
        NextSegment = (const __CFArray *)FigCFArrayGetFirstValue();
        if (NextSegment)
          break;
      }
      NextSegment = (const __CFArray *)FigMediaSegmentSpecifierGetNextSegment(v7);
      v7 = (uint64_t)NextSegment;
      if (!NextSegment)
        break;
      NextSegment = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)NextSegment);
      if (!NextSegment)
        break;
      Count = CFArrayGetCount(NextSegment);
      v8 = 0;
      NextSegment = 0;
    }
    while (Count);
  }
  else
  {
    FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
    NextSegment = (const __CFArray *)FigCFArrayGetFirstValue();
    v7 = (uint64_t)NextSegment;
    if (NextSegment)
    {
      FigMediaSegmentSpecifierGetPartialSegments((uint64_t)NextSegment);
      NextSegment = (const __CFArray *)FigCFArrayGetFirstValue();
    }
  }
  *a2 = v7;
  *a3 = (uint64_t)NextSegment;
  if (NextSegment)
    v11 = (uint64_t)NextSegment;
  else
    v11 = v7;
  *a4 = v11;
  return v7 != 0;
}

uint64_t segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(const void *a1, uint64_t a2)
{
  _QWORD *DerivedStorage;
  unsigned int v5;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  v5 = segPumpAPICheckStatus(DerivedStorage, a2);
  segPumpUnlockAndSendAllPendingNotifications();
  if (!v5)
  {
    if (!FigRetainProxyIsInvalidated())
    {
      CFRelease(a1);
      return 0;
    }
    v5 = FigSignalErrorAt();
  }
  CFRelease(a1);
  if (v5 == -15626)
    return 0;
  else
    return v5;
}

CFIndex segPumpAPICheckStatus(_QWORD *a1, uint64_t a2)
{
  __CFError *v3;

  if ((_DWORD)a2)
    return a2;
  if (!FigRetainProxyIsInvalidated())
  {
    if ((*(_BYTE *)(a1[48] + 1136) || *(_BYTE *)(a1[50] + 1136) || *(_BYTE *)(a1[52] + 1136))
      && (v3 = (__CFError *)a1[1002]) != 0)
    {
      return CFErrorGetCode(v3);
    }
    else
    {
      return 0;
    }
  }
  return FigSignalErrorAt();
}

double segPumpGetEstIndependentInterval(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double v5;
  CFIndex v6;
  int v7;
  double v8;
  double v9;
  const __CFArray *MediaSegmentSpecifiers;
  const __CFArray *v11;
  const void *ValueAtIndex;
  const __CFArray *PartialSegments;
  CFIndex v14;
  CFIndex Count;
  const void *v16;

  v2 = *(_QWORD *)(a1 + 384);
  v3 = *(_QWORD *)(v2 + 56);
  if (!v3)
    return 0.0;
  v5 = 0.0;
  if (FigMediaPlaylistHasIndependentSegments(v3))
  {
    LODWORD(v4) = *(_DWORD *)(a1 + 8);
    v5 = (double)v4;
  }
  v6 = 0;
  v7 = -1;
  v8 = 0.0;
  v9 = 0.0;
  while (1)
  {
    MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(v2 + 56));
    if (MediaSegmentSpecifiers)
      MediaSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MediaSegmentSpecifiers);
    if (v6 >= (uint64_t)MediaSegmentSpecifiers)
      break;
    v11 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(v2 + 56));
    ValueAtIndex = CFArrayGetValueAtIndex(v11, v6);
    PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)ValueAtIndex);
    v14 = 0;
    if (PartialSegments)
    {
LABEL_9:
      Count = CFArrayGetCount(PartialSegments);
      goto LABEL_11;
    }
    while (1)
    {
      Count = 0;
LABEL_11:
      if (v14 >= Count)
        break;
      v16 = CFArrayGetValueAtIndex(PartialSegments, v14);
      if (FigMediaSegmentSpecifierIsMarkedIndependent((uint64_t)v16))
      {
        v9 = 0.0;
        ++v7;
      }
      if ((v7 & 0x80000000) == 0)
      {
        v8 = v8 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v16);
        v9 = v9 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v16);
      }
      ++v14;
      if (PartialSegments)
        goto LABEL_9;
    }
    ++v6;
  }
  if (v7 > 0)
    return (v8 - v9) / (double)v7;
  return v5;
}

void RoundTripMonitorTimeoutTimer(uint64_t a1, uint64_t a2)
{
  dispatch_object_t *v2;
  CFTypeRef cf;

  v2 = 0;
  cf = 0;
  if (!segPumpLockAndCopyPumpFromRetainProxy(a2, &cf, (uint64_t *)&v2))
  {
    FigHTTPStopAndReleaseTimer(v2 + 1077);
    segPumpGetCurrentRTT(v2);
    segPumpResumeRoundTripMonitoring(v2);
  }
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
}

BOOL segPumpStreamHasActiveMediaRequest(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(a1 + 696);
  if (v1 && (*(_QWORD *)(v1 + 32) || *(_QWORD *)(v1 + 104)))
    return 1;
  v2 = **(_QWORD **)(a1 + 768);
  if (!v2)
    return 0;
  if (*(_QWORD *)(v2 + 32))
    return 1;
  return *(_QWORD *)(v2 + 104) != 0;
}

uint64_t segPumpPlaylistGetImputedLiveEdgeDate(uint64_t a1, double *a2)
{
  uint64_t LastValue;
  uint64_t v4;
  const __CFArray *PartialSegments;
  uint64_t v6;
  double ImputedDate;

  FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a1 + 56));
  LastValue = FigCFArrayGetLastValue();
  if (!LastValue)
    return FigSignalErrorAt();
  v4 = LastValue;
  PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments(LastValue);
  if (PartialSegments && CFArrayGetCount(PartialSegments) >= 1)
  {
    FigMediaSegmentSpecifierGetPartialSegments(v4);
    v6 = FigCFArrayGetLastValue();
    v4 = v6;
  }
  else
  {
    v6 = v4;
  }
  ImputedDate = FigMediaSegmentSpecifierGetImputedDate(v6);
  *a2 = ImputedDate + FigMediaSegmentSpecifierGetTimeInSeconds(v4);
  return 0;
}

void IndexFileHandleLongDownloadTimer(uint64_t a1, uint64_t a2)
{
  uint64_t UpTimeNanoseconds;
  uint64_t v5;
  int v6;
  unint64_t v7;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  CFTypeRef *v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  NSObject *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  const void *v21;
  void *v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  CFTypeRef v26;
  CFTypeRef v27;
  CFTypeRef v28;
  uint64_t v29;
  CFTypeRef cf[25];

  cf[23] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  v29 = 0;
  cf[0] = 0;
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v28 = 0;
  if (segPumpLockAndCopyPumpFromRetainProxy(a2, cf, &v29))
    goto LABEL_56;
  v5 = *(_QWORD *)(v29 + 384);
  if (*(_QWORD *)(v5 + 504) == a1
    || (v5 = *(_QWORD *)(v29 + 400), *(_QWORD *)(v5 + 504) == a1)
    || (v5 = *(_QWORD *)(v29 + 416), *(_QWORD *)(v5 + 504) == a1))
  {
    v6 = 1;
  }
  else
  {
    v5 = *(_QWORD *)(v29 + 392);
    if (*(_QWORD *)(v5 + 504) != a1)
    {
      v5 = *(_QWORD *)(v29 + 408);
      if (*(_QWORD *)(v5 + 504) != a1)
      {
        v5 = *(_QWORD *)(v29 + 424);
        if (*(_QWORD *)(v5 + 504) != a1)
          goto LABEL_56;
      }
    }
    v6 = 0;
  }
  v7 = UpTimeNanoseconds - *(_QWORD *)(v5 + 432);
  if (dword_1EE2A31E8)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  v9 = (CFTypeRef *)(v5 + 408);
  if (*(_BYTE *)(v5 + 538))
  {
    v10 = v29;
    segPumpResetConnection(v29, v5 + 408);
    *(_BYTE *)(v5 + 859) = 0;
    segPumpStreamUpdateIndexExpectedArrival(v10, v5);
    goto LABEL_44;
  }
  v11 = v6 ^ 1;
  v12 = v29;
  if (!*(_BYTE *)(v5 + 866))
    v11 = 1;
  if ((v11 & 1) == 0 && *(unsigned int *)(v29 + 8) < v7 / 0x3B9ACA00)
  {
    v13 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    v21 = *(const void **)(v5 + 480);
    if (v21)
    {
      v22 = (void *)CFRetain(v21);
      v28 = v22;
      if (v22)
      {
LABEL_37:
        if (!segPumpSendEndCallbackForAllActiveStreams(a2, v22))
          goto LABEL_46;
        goto LABEL_56;
      }
    }
    else
    {
      v28 = 0;
    }
    if (FigCreateErrorForOSStatus(4294954412, (CFErrorRef *)&v28))
      goto LABEL_56;
    v22 = (void *)v28;
    goto LABEL_37;
  }
  v14 = 7680;
  if (v6)
    v14 = 8144;
  v15 = *(uint64_t **)(v29 + v14);
  if (!v15)
    goto LABEL_43;
  v16 = (uint64_t *)(v29 + 8112);
  do
  {
    v16 = (uint64_t *)*v16;
    if (!v16)
    {
      v18 = *(uint64_t **)(v29 + 8096);
      if (v18 == v15)
      {
        v19 = (uint64_t *)(v29 + 8096);
        v23 = *v15;
        *(_QWORD *)(v29 + 8096) = *v15;
        if (v23)
        {
LABEL_41:
          *v15 = 0;
          **(_QWORD **)(v29 + 8104) = v15;
          *(_QWORD *)(v29 + 8104) = v15;
          v24 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT);
          goto LABEL_42;
        }
      }
      else
      {
        do
        {
          v19 = v18;
          v18 = (uint64_t *)*v18;
        }
        while (v18 != v15);
        v20 = *v15;
        *v19 = *v15;
        if (v20)
          goto LABEL_41;
        v12 = v29;
      }
      *(_QWORD *)(v12 + 8104) = v19;
      goto LABEL_41;
    }
  }
  while (v16 != v15);
  if (!dword_1EE2A31E8)
    goto LABEL_43;
  v17 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
  os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
LABEL_42:
  fig_log_call_emit_and_clean_up_after_send_and_compose();
LABEL_43:
  *(_BYTE *)(v5 + 867) = 1;
LABEL_44:
  if (*(_BYTE *)(v29 + 328))
    segPumpScheduleIndexFileLongDownloadTimer(v29, v5);
LABEL_46:
  v25 = v29;
  if (!*(_BYTE *)(v29 + 328))
  {
    if (*v9)
    {
      v26 = CFRetain(*v9);
      v25 = v29;
    }
    else
    {
      v26 = 0;
    }
    segPumpResetConnectionByPreservingConnectionStats(v25, v5 + 408);
    v27 = *v9;
    *v9 = v26;
    if (v26)
      CFRetain(v26);
    if (v27)
      CFRelease(v27);
    *(_BYTE *)(v5 + 859) = 0;
    segPumpHandleIndexFileNetworkError(cf[0], v5, 0, -16839, CFSTR("CoreMediaErrorDomain"), CFSTR("Unable to get playlist before long download timer."));
    if (v26)
      CFRelease(v26);
  }
LABEL_56:
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf[0])
    CFRelease(cf[0]);
  if (v28)
    CFRelease(v28);
}

uint64_t segPumpConnectionGetPendingMediaDeadline(uint64_t *a1)
{
  uint64_t v1;

  if (!a1[4] || !a1[1])
    return 0;
  v1 = a1[5];
  return v1 + (uint64_t)(FigMediaSegmentSpecifierGetTimeInSeconds(a1[1]) * 1000000000.0);
}

uint64_t segPumpStepNextFrame(const void *a1, CMTime *a2, uint64_t a3, CMTime *a4, uint64_t a5, int *a6, float a7)
{
  double Seconds;
  double v14;
  uint64_t DerivedStorage;
  uint64_t v16;
  CFIndex Step;
  int v18;
  uint64_t v19;
  uint64_t v20;
  double PlaylistActiveDurationSecs;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  uint64_t v27;
  const __CFArray *MediaSegmentSpecifiers;
  uint64_t v29;
  CMTime v31;

  v31 = *a2;
  Seconds = CMTimeGetSeconds(&v31);
  v31 = *a4;
  v14 = CMTimeGetSeconds(&v31);
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v16 = *(_QWORD *)(DerivedStorage + 384);
  Step = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if ((_DWORD)Step)
    goto LABEL_33;
  if (!*(_BYTE *)(DerivedStorage + 8712) || *(_BYTE *)(DerivedStorage + 8713))
    goto LABEL_34;
  if (a6)
  {
    v18 = *(_DWORD *)(v16 + 72) + 1;
    *(_DWORD *)(v16 + 72) = v18;
    *a6 = v18;
  }
  v19 = *(_QWORD *)(DerivedStorage + 384);
  v20 = *(_QWORD *)(v19 + 56);
  if (v20)
  {
    PlaylistActiveDurationSecs = FigMediaPlaylistGetPlaylistActiveDurationSecs(v20);
    v19 = *(_QWORD *)(DerivedStorage + 384);
  }
  else
  {
    PlaylistActiveDurationSecs = *(double *)(DerivedStorage + 344);
  }
  v22 = *(double *)(v19 + 88);
  v23 = PlaylistActiveDurationSecs + v22;
  if (Seconds >= v14)
  {
    v24 = v23 + -0.000001;
    if (Seconds < v23)
      v24 = Seconds;
    if (v14 >= v22)
      v26 = v14;
    else
      v26 = *(double *)(v19 + 88);
    if (v24 < v22)
      goto LABEL_34;
  }
  else
  {
    if (Seconds >= v22)
      v24 = Seconds;
    else
      v24 = *(double *)(v19 + 88);
    if (v14 <= v22)
      v25 = v22 + 0.001;
    else
      v25 = v14;
    v26 = v23 + -0.000001;
    if (v25 < v23)
      v26 = v25;
    if (v24 >= v23)
    {
LABEL_34:
      Step = FigSignalErrorAt();
      goto LABEL_33;
    }
  }
  *(double *)(DerivedStorage + 8720) = v23 - v24;
  *(double *)(DerivedStorage + 8728) = v23 - v26;
  *(_QWORD *)(DerivedStorage + 8744) = a5;
  *(float *)(DerivedStorage + 8736) = a7;
  *(_QWORD *)(DerivedStorage + 8752) = a3;
  v27 = *(_QWORD *)(v19 + 56);
  if (v27)
  {
    MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v27);
    if (MediaSegmentSpecifiers)
    {
      if (CFArrayGetCount(MediaSegmentSpecifiers) >= 1 && !*(_BYTE *)(*(_QWORD *)(DerivedStorage + 384) + 869))
      {
        Step = segPumpDoNextStep((uint64_t)a1, DerivedStorage);
LABEL_33:
        v29 = Step;
        return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v29);
      }
    }
  }
  v29 = 0;
  *(_BYTE *)(DerivedStorage + 8713) = 1;
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v29);
}

uint64_t segPumpTryIFrameFetch(uint64_t a1, uint64_t a2)
{
  unsigned int NextIFrame;

  if (!*(_BYTE *)(a2 + 8713))
  {
    if (!*(_BYTE *)(a2 + 8768))
      return 0;
    *(_BYTE *)(a2 + 8768) = 0;
    NextIFrame = segPumpRetrieveNextIFrame(a1, a2);
    if (!NextIFrame)
      return 0;
    return segPumpMakeDataCallbackWithOSStatus(a1, *(uint64_t **)(a2 + 384), *(const void **)(a2 + 176), 0, 0x20u, *(_QWORD *)(*(_QWORD *)(a2 + 384) + 304), MEMORY[0x1E0CA2E18], 0, 0, NextIFrame, 0, 0);
  }
  *(_BYTE *)(a2 + 8713) = 0;
  NextIFrame = segPumpDoNextStep(a1, a2);
  if (NextIFrame)
    return segPumpMakeDataCallbackWithOSStatus(a1, *(uint64_t **)(a2 + 384), *(const void **)(a2 + 176), 0, 0x20u, *(_QWORD *)(*(_QWORD *)(a2 + 384) + 304), MEMORY[0x1E0CA2E18], 0, 0, NextIFrame, 0, 0);
  return 0;
}

uint64_t segPumpDetermineMediaSegmentToDeliver(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  int v8;
  uint64_t result;
  _QWORD *v10;
  CFIndex i;
  const __CFArray *MediaSegmentSpecifiers;
  const __CFArray *v13;
  const void *ValueAtIndex;
  _QWORD *MediaFilePrivateData;
  int v16;
  uint64_t PreviousSegment;
  uint64_t DiscontinuityDomain;
  const void *v19;
  const void *MapSegmentSpecifier;
  _QWORD *v21;
  const __CFArray *PartialSegments;
  CFIndex v23;
  CFIndex j;
  const void *v25;
  _BYTE *v26;
  int matched;
  double v28;
  double v29;
  double v30;
  uint64_t v31;
  int PeakBitRate;
  _BOOL4 v33;
  int v34;
  double v35;
  double v36;
  NSObject *v37;
  unsigned int v38;
  unsigned int v39;
  const __CFString *v40;
  _QWORD *v41;
  uint64_t v42;
  double v43;
  double PlaylistActiveDurationSecs;
  NSObject *v45;
  unsigned int v46;
  unsigned int v47;
  const __CFString *v48;
  uint64_t v49;
  double v50;
  double v51;
  const void *v52;
  uint64_t v53;
  double v54;
  const void *v55;
  int IsMarkedIndependent;
  const void *v57;
  double v59;
  double v60;
  const void *NextSegment;
  const void *k;
  uint64_t v63;
  double v64;
  double v65;
  double v66;
  NSObject *v67;
  unsigned int v68;
  unsigned int v69;
  const __CFString *v70;
  uint64_t v71;
  double v72;
  unint64_t v73;
  NSObject *v74;
  unsigned int v75;
  unsigned int v76;
  const __CFString *v77;
  uint64_t v78;
  const void *v83;
  _BYTE *v84;
  const void *v85;
  _BYTE *v86;
  const void *FirstValue;
  _BYTE *v88;
  double v89;
  uint64_t v90;
  double v91;
  CFAbsoluteTime v92;
  double v93;
  double v94;
  double v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  double v99;
  int v100;
  const __CFArray *v101;
  const void *v102;
  const void *v103;
  _BYTE *v104;
  const void *LastValue;
  _BYTE *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v112;
  _QWORD *v113;
  int v114;
  double type;
  double v116;
  const void *v117;
  const void *v118;
  const void *v119;
  _BYTE v120[12];
  __int16 v121;
  const __CFString *v122;
  __int16 v123;
  uint64_t v124;
  __int16 v125;
  double v126;
  __int16 v127;
  double v128;
  __int16 v129;
  unint64_t v130;
  double v131[18];

  v131[16] = *(double *)MEMORY[0x1E0C80C00];
  v117 = 0;
  v118 = 0;
  v8 = segPumpStreamBitRateRequiredForStream(a1, (_QWORD *)a2);
  *a3 = 0;
  result = *(_QWORD *)(a2 + 56);
  if (!result)
    return result;
  if (*(_QWORD *)(a2 + 256))
    return 0;
  if (*(_QWORD *)(a2 + 264))
    return FigSignalErrorAt();
  FigMediaPlaylistGetMediaSegmentSpecifiers(result);
  result = FigCFArrayGetFirstValue();
  v119 = (const void *)result;
  if (result)
  {
    v10 = (_QWORD *)(a2 + 136);
    if (*(_QWORD *)(a2 + 136) == -1)
    {
      v16 = 0;
      goto LABEL_40;
    }
    for (i = 0; ; ++i)
    {
      MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a2 + 56));
      if (MediaSegmentSpecifiers)
        MediaSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MediaSegmentSpecifiers);
      if (i >= (uint64_t)MediaSegmentSpecifiers)
        break;
      v13 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a2 + 56));
      ValueAtIndex = CFArrayGetValueAtIndex(v13, i);
      MediaFilePrivateData = segPumpGetMediaFilePrivateData(ValueAtIndex);
      if (FigMediaSegmentSpecifierGetMediaSequence((uint64_t)ValueAtIndex) == *(_QWORD *)(a2 + 136))
        MediaFilePrivateData[8] = *(_QWORD *)(a2 + 152);
      if ((unint64_t)FigMediaSegmentSpecifierGetMediaSequence((uint64_t)ValueAtIndex) >= *v10)
      {
        if (ValueAtIndex)
        {
          PreviousSegment = FigMediaSegmentSpecifierGetPreviousSegment((uint64_t)ValueAtIndex);
          *(_QWORD *)(a2 + 120) = 0xBFF0000000000000;
          *(_QWORD *)(a2 + 920) = 0;
          if (PreviousSegment
            && (DiscontinuityDomain = FigMediaSegmentSpecifierGetDiscontinuityDomain(PreviousSegment),
                DiscontinuityDomain < FigMediaSegmentSpecifierGetDiscontinuityDomain((uint64_t)ValueAtIndex))
            && !*(_QWORD *)(a2 + 152))
          {
            v102 = *(const void **)(a2 + 288);
            if (v102)
            {
              CFRelease(v102);
              *(_QWORD *)(a2 + 288) = 0;
            }
          }
          else
          {
            v19 = *(const void **)(a2 + 288);
            MapSegmentSpecifier = (const void *)FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)ValueAtIndex);
            *(_QWORD *)(a2 + 288) = MapSegmentSpecifier;
            if (MapSegmentSpecifier)
              CFRetain(MapSegmentSpecifier);
            if (v19)
              CFRelease(v19);
          }
          *(_QWORD *)(a2 + 320) = FigMediaSegmentSpecifierGetDiscontinuityDomain((uint64_t)ValueAtIndex);
          segPumpSetStreamDiscontinuityDomain(a1, (_QWORD *)a2, (uint64_t)ValueAtIndex);
          v112 = v8;
          if ((*(_QWORD *)(a2 + 144) & 0x8000000000000000) != 0)
          {
            v25 = 0;
          }
          else
          {
            v21 = a3;
            PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)ValueAtIndex);
            v23 = 0;
            if (!PartialSegments)
              goto LABEL_27;
LABEL_26:
            for (j = CFArrayGetCount(PartialSegments); v23 < j; j = 0)
            {
              v25 = CFArrayGetValueAtIndex(PartialSegments, v23);
              v26 = segPumpGetMediaFilePrivateData(v25);
              if (v23 == *(_QWORD *)(a2 + 144))
                goto LABEL_35;
              v26[73] = 1;
              ++v23;
              if (PartialSegments)
                goto LABEL_26;
LABEL_27:
              ;
            }
            v25 = 0;
LABEL_35:
            a3 = v21;
            v8 = v112;
          }
          if (dword_1EE2A31E8)
          {
            LODWORD(v116) = 0;
            LOBYTE(type) = 0;
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
            v16 = 1;
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          else
          {
            v16 = 1;
          }
LABEL_39:
          *v10 = -1;
          *(_QWORD *)(a2 + 144) = -1;
          *(_QWORD *)(a2 + 152) = 0;
          v118 = v25;
          v119 = ValueAtIndex;
LABEL_40:
          if (!*(_BYTE *)(a2 + 861))
          {
            v114 = v16;
            v28 = *(double *)(a2 + 920);
            if (v28 == 0.0)
            {
              matched = 0;
            }
            else
            {
              matched = segPumpTryToMatchDate(a1, *(_QWORD *)(a2 + 56), (double *)(a2 + 120), v131, v28, *(double *)(a2 + 120));
              if (matched)
              {
                if (!*(_BYTE *)(a1 + 8002))
                {
                  v29 = *(double *)(a2 + 928);
                  if (v29 > 0.0)
                    segPumpStreamSyncTimeRolledPast(a2, *(double *)(a2 + 120), v29);
                }
              }
              *(_QWORD *)(a2 + 920) = 0;
              *(_QWORD *)(a2 + 928) = 0;
            }
LABEL_62:
            v35 = *(double *)(a2 + 120);
            if (v35 <= 0.0)
              goto LABEL_136;
            v113 = a3;
            if (v35 >= FigMediaPlaylistGetPlaylistActiveDurationSecs(*(_QWORD *)(a2 + 56)))
            {
              v36 = 1.0;
              if (!FigMediaPlaylistHasEndTag(*(_QWORD *)(a2 + 56)))
                v36 = segPumpGetMinimumPrebufferReservation(a1, *(_QWORD *)(a2 + 56)) + *(double *)(a1 + 7960);
              LODWORD(v116) = 0;
              LOBYTE(type) = 0;
              v37 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              v38 = LODWORD(v116);
              if (os_log_type_enabled(v37, LOBYTE(type)))
                v39 = v38;
              else
                v39 = v38 & 0xFFFFFFFE;
              if (v39)
              {
                v40 = &stru_1E2FD85F8;
                v41 = a4;
                if (a1 && *(_QWORD *)(a1 + 8760))
                  v40 = *(const __CFString **)(a1 + 8760);
                v42 = *(_QWORD *)a2;
                v43 = *(double *)(a2 + 120);
                PlaylistActiveDurationSecs = FigMediaPlaylistGetPlaylistActiveDurationSecs(*(_QWORD *)(a2 + 56));
                *(_DWORD *)v120 = 136316162;
                *(_QWORD *)&v120[4] = "segPumpDetermineMediaSegmentToDeliver";
                v121 = 2114;
                v122 = v40;
                v123 = 2048;
                v124 = v42;
                v125 = 2048;
                v126 = v43;
                v127 = 2048;
                v128 = PlaylistActiveDurationSecs;
                _os_log_send_and_compose_impl();
                a4 = v41;
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose();
              *(double *)(a2 + 120) = fmax(FigMediaPlaylistGetPlaylistActiveDurationSecs(*(_QWORD *)(a2 + 56)) - v36, 0.0);
              *(_QWORD *)(a2 + 128) = 0xBFF0000000000000;
            }
            if (dword_1EE2A31E8)
            {
              LODWORD(v116) = 0;
              LOBYTE(type) = 0;
              v45 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              v46 = LODWORD(v116);
              if (os_log_type_enabled(v45, LOBYTE(type)))
                v47 = v46;
              else
                v47 = v46 & 0xFFFFFFFE;
              if (v47)
              {
                v48 = &stru_1E2FD85F8;
                if (a1 && *(_QWORD *)(a1 + 8760))
                  v48 = *(const __CFString **)(a1 + 8760);
                v49 = *(_QWORD *)a2;
                v50 = *(double *)(a2 + 120);
                v51 = *(double *)(a2 + 128);
                *(_DWORD *)v120 = 136316162;
                *(_QWORD *)&v120[4] = "segPumpDetermineMediaSegmentToDeliver";
                v121 = 2114;
                v122 = v48;
                v123 = 2048;
                v124 = v49;
                v125 = 2048;
                v126 = v50;
                v127 = 2048;
                v128 = v51;
                _os_log_send_and_compose_impl();
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose();
            }
            if (!FigMediaPlaylistHasEndTag(*(_QWORD *)(a2 + 56)) && !matched)
            {
              v64 = *(double *)(a2 + 128);
              if (v64 > 0.0)
              {
                v65 = (double)*(uint64_t *)(a2 + 448) / 1000000000.0 - v64;
                v66 = FigMediaPlaylistGetPlaylistActiveDurationSecs(*(_QWORD *)(a2 + 56)) - v65;
                *(double *)(a2 + 120) = v66;
                *(double *)(a2 + 120) = segPumpEnsureOffsetInDiscDomain(*(_QWORD *)(a2 + 312), *(_QWORD *)(a2 + 56), *(_QWORD *)(a2 + 936), v66);
                if (dword_1EE2A31E8)
                {
                  LODWORD(v116) = 0;
                  LOBYTE(type) = 0;
                  v67 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                  v68 = LODWORD(v116);
                  if (os_log_type_enabled(v67, LOBYTE(type)))
                    v69 = v68;
                  else
                    v69 = v68 & 0xFFFFFFFE;
                  if (v69)
                  {
                    v70 = &stru_1E2FD85F8;
                    if (a1 && *(_QWORD *)(a1 + 8760))
                      v70 = *(const __CFString **)(a1 + 8760);
                    v71 = *(_QWORD *)a2;
                    v72 = *(double *)(a2 + 120);
                    v73 = *(_QWORD *)(a2 + 448) / 0x3B9ACA00uLL;
                    *(_DWORD *)v120 = 136316418;
                    *(_QWORD *)&v120[4] = "segPumpDetermineMediaSegmentToDeliver";
                    v121 = 2114;
                    v122 = v70;
                    v123 = 2048;
                    v124 = v71;
                    v125 = 2048;
                    v126 = v65;
                    v127 = 2048;
                    v128 = v72;
                    v129 = 2048;
                    v130 = v73;
                    _os_log_send_and_compose_impl();
                  }
                  fig_log_call_emit_and_clean_up_after_send_and_compose();
                }
              }
            }
            v119 = 0;
            if (!segPumpIterateMedia(*(_QWORD *)(a2 + 56), (uint64_t *)&v119, (uint64_t *)&v118, (uint64_t *)&v117))
            {
              v54 = 0.0;
              goto LABEL_122;
            }
            v52 = 0;
            v53 = 0;
            v54 = 0.0;
            while (1)
            {
              v55 = v117;
              if (!*((_BYTE *)segPumpGetMediaFilePrivateData(v117) + 96))
              {
                IsMarkedIndependent = FigMediaSegmentSpecifierIsMarkedIndependent((uint64_t)v55);
                v57 = v119;
                if (IsMarkedIndependent)
                {
                  v53 = (uint64_t)v119;
                  v52 = v55;
                }
                if (v54 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v55) > *(double *)(a2 + 120))
                {
LABEL_97:
                  if (v118)
                  {
                    if (v52 && v118 != v52)
                    {
                      v59 = *((double *)segPumpGetMediaFilePrivateData(v118) + 4);
                      v60 = *((double *)segPumpGetMediaFilePrivateData(v52) + 4);
                      if (v53 != FigMediaSegmentSpecifierGetNextSegment((uint64_t)v119))
                      {
                        NextSegment = (const void *)v53;
                        do
                        {
                          segPumpSetDeliveryStatusForMediaFileAndParts(NextSegment, 0);
                          NextSegment = (const void *)FigMediaSegmentSpecifierGetNextSegment((uint64_t)NextSegment);
                        }
                        while (NextSegment != (const void *)FigMediaSegmentSpecifierGetNextSegment((uint64_t)v119));
                      }
                      FigMediaSegmentSpecifierGetPartialSegments(v53);
                      for (k = (const void *)FigCFArrayGetFirstValue();
                            k != v52;
                            k = (const void *)FigMediaSegmentSpecifierGetNextSegment(v63))
                      {
                        v63 = (uint64_t)k;
                        if (!k)
                          break;
                        segPumpSetDeliveryStatusForMediaFileAndParts(k, 1);
                      }
                      v54 = v54 - (v59 - v60);
                      v118 = v52;
                      v119 = (const void *)v53;
                    }
                  }
LABEL_122:
                  a3 = v113;
                  if (dword_1EE2A31E8)
                  {
                    LODWORD(v116) = 0;
                    LOBYTE(type) = 0;
                    v74 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                    v75 = LODWORD(v116);
                    if (os_log_type_enabled(v74, LOBYTE(type)))
                      v76 = v75;
                    else
                      v76 = v75 & 0xFFFFFFFE;
                    if (v76)
                    {
                      v77 = &stru_1E2FD85F8;
                      if (a1 && *(_QWORD *)(a1 + 8760))
                        v77 = *(const __CFString **)(a1 + 8760);
                      if (a2)
                        v78 = *(_QWORD *)a2;
                      else
                        v78 = -1;
                      *(_DWORD *)v120 = 136315906;
                      *(_QWORD *)&v120[4] = "segPumpDetermineMediaSegmentToDeliver";
                      v121 = 2114;
                      v122 = v77;
                      v123 = 2048;
                      v124 = v78;
                      v125 = 2048;
                      v126 = v54;
                      _os_log_send_and_compose_impl();
                    }
                    fig_log_call_emit_and_clean_up_after_send_and_compose();
                  }
LABEL_136:
                  __asm { FMOV            V0.2D, #-1.0 }
                  *(_OWORD *)(a2 + 120) = _Q0;
                  if (v114)
                    *(_BYTE *)(a2 + 863) = 1;
                  v83 = v119;
                  if (!v119)
                    goto LABEL_143;
                  while (1)
                  {
                    v84 = segPumpGetMediaFilePrivateData(v83);
                    if (!v84[73] && !v84[96] && !v84[99])
                      break;
                    v83 = (const void *)FigMediaSegmentSpecifierGetNextSegment((uint64_t)v83);
                    if (!v83)
                      goto LABEL_143;
                  }
                  v119 = v83;
                  FirstValue = v118;
                  if (v118)
                  {
LABEL_153:
                    while (1)
                    {
                      v88 = segPumpGetMediaFilePrivateData(FirstValue);
                      if (!v88[73] && !v88[96] && !v88[99])
                        break;
                      FirstValue = (const void *)FigMediaSegmentSpecifierGetNextSegment((uint64_t)FirstValue);
                      if (!FirstValue)
                        goto LABEL_157;
                    }
                    v118 = FirstValue;
                    v83 = v119;
                    goto LABEL_182;
                  }
                  v101 = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v83);
                  if (FigMediaSegmentSpecifierIsFragment((uint64_t)v83))
                  {
LABEL_167:
                    FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v83);
                    FirstValue = (const void *)FigCFArrayGetFirstValue();
                    v118 = FirstValue;
                    if (FirstValue)
                      goto LABEL_153;
LABEL_157:
                    v118 = 0;
                    goto LABEL_143;
                  }
                  if (!v101 || CFArrayGetCount(v101) < 1)
                    goto LABEL_147;
                  v103 = (const void *)FigCFArrayGetFirstValue();
                  v104 = segPumpGetMediaFilePrivateData(v103);
                  if (!v104[73] && !v104[96] && !v104[99])
                  {
                    v107 = FigCFArrayGetFirstValue();
                    if (v107 && (v108 = *(_QWORD *)(a2 + 776), v108 >= 1))
                    {
                      v109 = *(_QWORD *)(a2 + 768);
                      while (!*(_QWORD *)v109 || *(_QWORD *)(*(_QWORD *)v109 + 8) != v107)
                      {
                        v109 += 8;
                        if (!--v108)
                          goto LABEL_192;
                      }
                    }
                    else
                    {
LABEL_192:
                      v110 = FigCFArrayGetFirstValue();
                      if (v110 != FigCFArrayGetLastValue())
                        goto LABEL_182;
                    }
                  }
                  LastValue = (const void *)FigCFArrayGetLastValue();
                  v106 = segPumpGetMediaFilePrivateData(LastValue);
                  if (!v106[73] && !v106[96] && !v106[99])
                    goto LABEL_167;
LABEL_182:
                  if (v83)
                  {
LABEL_147:
                    result = 0;
                  }
                  else
                  {
LABEL_143:
                    FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a2 + 56));
                    v85 = (const void *)FigCFArrayGetLastValue();
                    v86 = segPumpGetMediaFilePrivateData(v85);
                    result = FigMediaPlaylistHasEndTag(*(_QWORD *)(a2 + 56));
                    if ((_DWORD)result)
                    {
                      if (!v86[73] || *(_BYTE *)(a2 + 871))
                      {
                        v83 = 0;
                        goto LABEL_147;
                      }
                      result = segPumpDispatchAsyncMediaDelivery(a1, a2, -1, -1, *(const void **)(a2 + 296), (uint64_t)segPumpDeliverEnd);
                    }
                    v83 = 0;
                  }
                  *a3 = v83;
                  *a4 = v118;
                  return result;
                }
                segPumpSetDeliveryStatusForMediaFileAndParts(v55, 1);
                v54 = v54 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v55);
                if (v55 == v118)
                {
                  FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v57);
                  if (v55 == (const void *)FigCFArrayGetLastValue()
                    && !FigMediaSegmentSpecifierIsFragment((uint64_t)v57))
                  {
                    segPumpSetDeliveryStatusForMediaFileAndParts(v57, 1);
                  }
                }
              }
              if (!segPumpIterateMedia(*(_QWORD *)(a2 + 56), (uint64_t *)&v119, (uint64_t *)&v118, (uint64_t *)&v117))
                goto LABEL_97;
            }
          }
          v131[0] = 0.0;
          *(_QWORD *)v120 = 0;
          if (!segPumpGetSafeNetworkBandwidth(a1, (double *)v120, 0, 1))
          {
            segPumpGetNetworkLatencyFromPredictor(a1, v131);
            if (!*(_BYTE *)(a1 + 8002))
            {
              v30 = *(double *)(a2 + 920);
              if (v30 != 0.0 && *(double *)(a2 + 928) > 0.0)
              {
                v116 = *(double *)(a2 + 96) - *(double *)(a2 + 904);
                if (segPumpTryToMatchDate(a1, *(_QWORD *)(a2 + 56), &v116, &type, v30, v116))
                  segPumpStreamSyncTimeRolledPast(a2, v116, *(double *)(a2 + 928));
                *(_QWORD *)(a2 + 928) = 0;
              }
            }
            if (!v16)
            {
              if (*(_QWORD *)(a1 + 8144) && (v31 = *(_QWORD *)(a1 + 7680)) != 0)
              {
                if (*(_BYTE *)(a2 + 864))
                {
                  PeakBitRate = FigAlternateGetPeakBitRate(*(_QWORD *)(v31 + 8));
                  v33 = PeakBitRate > (int)FigAlternateGetPeakBitRate(*(_QWORD *)(*(_QWORD *)(a1 + 8144) + 8));
                }
                else
                {
                  v33 = 0;
                }
                v34 = v16;
              }
              else
              {
                v34 = v16;
                v33 = 0;
              }
              v89 = *(double *)(a2 + 96) - *(double *)(a2 + 904);
              v90 = *(_QWORD *)(a2 + 888);
              v91 = (double)(v90 - FigGetUpTimeNanoseconds()) / 1000000000.0;
              v92 = *(double *)(a2 + 920);
              v93 = (double)v8;
              v94 = *(double *)v120;
              v95 = (double)(uint64_t)(*(_QWORD *)(a2 + 448) - *(_QWORD *)(a2 + 896)) / 1000000000.0;
              v96 = *(_QWORD *)(a2 + 56);
              v97 = *(_QWORD *)(a2 + 936);
              v98 = *(_QWORD *)(a2 + 312);
              v99 = (double)*(uint64_t *)&v131[0] / 1000000000.0;
              v100 = !segPumpConnectedInterfaceIsWWAN(a1)
                  && *(uint64_t *)a2 <= 1
                  && *(_BYTE *)(a2 + 864) == 0;
              result = segPumpDetermineMediaSegmentToSwitchTo(a1, v96, v97, v98, 1, v100, v33, v89, v91, v92, v93, v94, v95, v99, a2, (uint64_t *)&v118, &v119);
              v16 = v34;
              if ((_DWORD)result)
                return result;
            }
            v114 = v16;
            matched = 0;
            *(_QWORD *)(a2 + 920) = 0;
            *(_QWORD *)(a2 + 120) = 0xBFF0000000000000;
            *(_BYTE *)(a2 + 861) = 0;
            goto LABEL_62;
          }
          return 0;
        }
LABEL_32:
        v16 = 0;
        v25 = 0;
        goto LABEL_39;
      }
      segPumpSetDeliveryStatusForMediaFileAndParts(ValueAtIndex, 1);
    }
    ValueAtIndex = 0;
    goto LABEL_32;
  }
  return result;
}

uint64_t segPumpStreamReadAheadPermitsNextRead(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  if (*(_BYTE *)(a1 + 8712))
    return 1;
  if (*(_BYTE *)(a1 + 8209))
    return 1;
  v4 = *(_QWORD *)(a2 + 768);
  if (!*(_QWORD *)v4)
    return 1;
  if (a3)
  {
    v5 = *(_QWORD *)(a2 + 776);
    if (v5 >= 1)
    {
      while (!*(_QWORD *)v4 || *(_QWORD *)(*(_QWORD *)v4 + 8) != a3)
      {
        v4 += 8;
        if (!--v5)
          return 0;
      }
      return 1;
    }
  }
  return 0;
}

uint64_t segPumpCheckCachedVariantsAndRequestSwitch(uint64_t a1, uint64_t a2, const void *a3, int a4, double a5)
{
  uint64_t v9;
  const void *v10;
  BOOL v11;
  int v12;
  CFTypeRef v13;
  double v14;
  double v15;
  const __CFNumber *v16;
  CFTypeRef v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t LongestContiguousMediaStreamInCacheAtTime;
  double v21;
  double v22;
  char v23;
  _BOOL4 v24;
  _QWORD *AlternateEntryFromURLForCacheLookup;
  uint64_t v26;
  double v27;
  uint64_t v28;
  double v29;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  const void *v31;
  CFNumberRef v32;
  const void *v33;
  const void *v34;
  uint64_t v35;
  CFTypeRef v36;
  __CFDictionary *Mutable;
  const __CFAllocator *AllocatorForMedia;
  const void *v39;
  NSObject *v40;
  int v42;
  CFTypeRef v43;
  uint64_t v44;
  CFTypeRef cf;
  CFTypeRef v46;
  double v47;
  double valuePtr[18];

  valuePtr[16] = *(double *)MEMORY[0x1E0C80C00];
  v46 = 0;
  v47 = 0.0;
  v44 = 0;
  cf = 0;
  v9 = *(_QWORD *)(a1 + 9560);
  v10 = *(const void **)(a1 + 9528);
  if (v9)
    v11 = v10 == 0;
  else
    v11 = 1;
  v12 = !v11;
  if (v10)
    v13 = CFRetain(v10);
  else
    v13 = 0;
  v43 = 0;
  if (!*(_BYTE *)(a1 + 8240) || *(_QWORD *)a2 != *(_QWORD *)(a1 + 8416) || *(_QWORD *)(a2 + 256))
  {
    v36 = 0;
    Mutable = 0;
    v17 = 0;
LABEL_78:
    LongestContiguousMediaStreamInCacheAtTime = 0;
    goto LABEL_79;
  }
  if (a3)
    v14 = *((double *)segPumpGetMediaFilePrivateData(a3) + 4);
  else
    v14 = 0.0;
  v47 = v14;
  v15 = v14;
  if (!*(_BYTE *)(a2 + 872))
  {
    LODWORD(a5) = *(_DWORD *)(a1 + 8);
    v15 = v14 - (double)*(unint64_t *)&a5;
    v47 = v15;
  }
  if (v15 < 0.0)
  {
    v47 = 0.0;
    v15 = 0.0;
  }
  v42 = v12;
  v16 = *(const __CFNumber **)(a1 + 8232);
  if (v16)
  {
    valuePtr[0] = 0.0;
    CFNumberGetValue(v16, kCFNumberDoubleType, valuePtr);
    if (valuePtr[0] <= v47)
      v15 = v47;
    else
      v15 = valuePtr[0];
    v47 = v15;
  }
  v17 = 0;
  v18 = 0;
  v19 = 0;
  while (1)
  {
    valuePtr[0] = 0.0;
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
    LongestContiguousMediaStreamInCacheAtTime = FigStreamingCacheGetLongestContiguousMediaStreamInCacheAtTime(*(_QWORD *)(a1 + 296), *(_DWORD *)a2, &v44, &v46, &cf, valuePtr, v15);
    if ((_DWORD)LongestContiguousMediaStreamInCacheAtTime)
    {
LABEL_94:
      v36 = 0;
      Mutable = 0;
      goto LABEL_79;
    }
    v21 = v47;
    v22 = valuePtr[0];
    if (v17)
    {
      v23 = 1;
    }
    else
    {
      v18 = v44;
      if (v46)
      {
        v17 = CFRetain(v46);
        v23 = 0;
      }
      else
      {
        v23 = 0;
        v17 = 0;
      }
    }
    *(_BYTE *)(a2 + 405) = v23;
    v24 = a4 != 0;
    if (!a4)
    {
      v24 = 0;
      if (v46)
      {
        AlternateEntryFromURLForCacheLookup = segPumpGetAlternateEntryFromURLForCacheLookup(a1, v46, (uint64_t)cf);
        if (!AlternateEntryFromURLForCacheLookup)
          goto LABEL_94;
        v26 = *(_QWORD *)(a1 + 8144);
        if (v26)
          v24 = *((_DWORD *)AlternateEntryFromURLForCacheLookup + 6) >= *(_DWORD *)(v26 + 24);
        else
          v24 = 1;
      }
    }
    v27 = v15 - v21 + v22;
    v28 = v44;
    if (v44 == v19 || !v46 || !v24)
      break;
    v29 = v27 + v47;
    if (!*(_BYTE *)(a2 + 872))
      v29 = v29 - (double)(*(_DWORD *)(a1 + 8) >> 1);
    if (v29 <= v15)
      goto LABEL_94;
    CFRelease(v46);
    v46 = 0;
    v15 = v29;
    v19 = v28;
    if (v27 > 60.0)
      goto LABEL_51;
  }
  if (v17)
    CFRelease(v17);
  v17 = 0;
  v29 = v15;
LABEL_51:
  if (v29 + v27 <= v14 + 1.0)
    segPumpClearSuggestedAlternate((_QWORD *)a1);
  if (!v17 || v18 == *(_QWORD *)(a2 + 64))
  {
    v36 = 0;
    Mutable = 0;
    goto LABEL_78;
  }
  if (dword_1EE2A31E8)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  LongestContiguousMediaStreamInCacheAtTime = (uint64_t)segPumpGetAlternateEntryFromURLForCacheLookup(a1, v17, (uint64_t)cf);
  if (!LongestContiguousMediaStreamInCacheAtTime)
    goto LABEL_70;
  v31 = *(const void **)(a1 + 8232);
  if (v31)
  {
    CFRelease(v31);
    *(_QWORD *)(a1 + 8232) = 0;
  }
  v32 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &v47);
  *(_QWORD *)(a1 + 8232) = v32;
  if (v32)
  {
    v33 = *(const void **)(a1 + 8224);
    v34 = *(const void **)(LongestContiguousMediaStreamInCacheAtTime + 8);
    *(_QWORD *)(a1 + 8224) = v34;
    if (v34)
      CFRetain(v34);
    if (v33)
      CFRelease(v33);
    if (v42)
    {
      v35 = FigAlternateSkipEqualOrLowerBitratesFilterCreate(*(void **)(a1 + 56), *(CFTypeRef *)(a1 + 8224), CFSTR("PartialCache"), 630, &v43);
      if (!(_DWORD)v35)
      {
        v35 = FigAlternateSelectionBossAddFilter(*(_QWORD *)(a1 + 9528), v43);
        if (!(_DWORD)v35)
          v35 = FigAlternateSelectionBossApplyFilters(v13);
      }
      LongestContiguousMediaStreamInCacheAtTime = v35;
LABEL_70:
      v36 = 0;
      Mutable = 0;
      goto LABEL_79;
    }
    AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v39 = *(const void **)(a1 + 8232);
      if (v39)
        v36 = CFRetain(v39);
      else
        v36 = 0;
      CFDictionaryAddValue(Mutable, CFSTR("FBP_AlternateValue"), *(const void **)(LongestContiguousMediaStreamInCacheAtTime + 8));
      CFDictionaryAddValue(Mutable, CFSTR("FBP_CacheContext"), v36);
      segPumpReadyNotification((_QWORD *)a1, CFSTR("FBP_SuggestedAlternate"), Mutable);
      if (FigRetainProxyGetLockCount() >= 2)
      {
        v40 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        LongestContiguousMediaStreamInCacheAtTime = 4294954651;
        goto LABEL_79;
      }
      segPumpUnlockAndSendAllPendingNotifications();
      FigRetainProxyLockMutex();
      goto LABEL_78;
    }
    v36 = 0;
  }
  else
  {
    v36 = 0;
    Mutable = 0;
  }
  LongestContiguousMediaStreamInCacheAtTime = 4294954655;
LABEL_79:
  if (v13)
    CFRelease(v13);
  if (v43)
    CFRelease(v43);
  if (v46)
    CFRelease(v46);
  if (v36)
    CFRelease(v36);
  if (Mutable)
    CFRelease(Mutable);
  if (v17)
    CFRelease(v17);
  if (cf)
    CFRelease(cf);
  return LongestContiguousMediaStreamInCacheAtTime;
}

uint64_t segPumpIsMediaSegmentWaitingOnCryptKey(uint64_t result)
{
  uint64_t v1;
  const void *ContentKeySpecifier;
  uint64_t v3;
  uint64_t v4;

  v3 = 0;
  v4 = 0;
  if (result)
  {
    v1 = result;
    result = FigMediaSegmentSpecifierGetContentKeySpecifier(result);
    if (result)
    {
      ContentKeySpecifier = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier(v1);
      return !segPumpGetCryptKeyCommonData(ContentKeySpecifier, &v4, &v3) && *(_BYTE *)(v3 + 144) == 0;
    }
  }
  return result;
}

uint64_t segPumpStreamDoDeliveryFollowUp(uint64_t a1, uint64_t a2, uint64_t a3, int a4, const void *a5, _BYTE *a6)
{
  _BYTE *v6;
  uint64_t v8;
  uint64_t result;
  uint64_t v11;
  _BYTE *DerivedStorage;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const void *NextSegment;
  uint64_t v23;
  uint64_t LastValue;
  uint64_t PreviousSegment;
  _QWORD *v26;
  _QWORD *v27;
  const void *MapSegmentSpecifier;
  const void *ContentKeySpecifier;
  const __CFURL *v30;
  const __CFURL *v31;
  _QWORD *v32;
  const __CFURL *v33;
  const __CFURL *v34;
  const __CFURL **v35;
  _QWORD *v36;
  int v37;
  CFTypeRef v38;
  uint64_t v39;
  int v40;
  const void *v41;
  int v42;
  _BYTE *v43;
  const void *PreloadMapHint;
  const __CFURL *v45;
  const __CFURL *v46;
  _QWORD *MediaFilePrivateData;
  const __CFURL *v48;
  const __CFURL *v49;
  int MediaFile;
  int v51;
  uint64_t v52;
  _BYTE *v53;
  uint64_t v54;
  char v55;
  char v56;
  CFTypeRef cf;
  uint64_t v58;

  v6 = a6;
  v55 = 0;
  if (!*(_BYTE *)(a3 + 1136))
  {
    v8 = a2;
    if ((a4 || !*(_QWORD *)(*(_QWORD *)(a3 + 696) + 8)) && (!*(_BYTE *)(a3 + 869) || !*(_BYTE *)(a2 + 7995)))
    {
      result = segPumpTrySpeculativeRead(a1, (uint64_t *)a2, a3, a5, &v55);
      if ((_DWORD)result)
        goto LABEL_94;
      segPumpReadOrScheduleIndexFileRead(a1, v8, a3);
    }
    if (!*(_QWORD *)(a3 + 256))
      goto LABEL_84;
    v11 = *(_QWORD *)(a3 + 264) ? *(_QWORD *)(a3 + 264) : *(_QWORD *)(a3 + 256);
    DerivedStorage = (_BYTE *)CMBaseObjectGetDerivedStorage();
    v13 = (uint64_t)DerivedStorage;
    v58 = 0;
    v14 = *(_QWORD *)(a3 + 696);
    v15 = v14 ? *(const void **)(v14 + 32) : 0;
    cf = 0;
    if (!segPumpShouldDoSegmentReadAheads(DerivedStorage))
      goto LABEL_84;
    v54 = v8;
    v16 = *(_QWORD *)(a3 + 776);
    if (v16 < 1)
    {
      v17 = 0;
      if (!v11)
        goto LABEL_77;
    }
    else
    {
      v17 = 0;
      while (1)
      {
        v18 = *(_BYTE *)(v13 + 329) ? 1 : *(int *)(v13 + 8212);
        if (v17 >= v18)
          break;
        v19 = *(_QWORD *)(*(_QWORD *)(a3 + 768) + 8 * v17);
        if (!v19)
          break;
        if (*(_QWORD *)(v19 + 32))
          v15 = *(const void **)(v19 + 32);
        v20 = *(_QWORD *)(v19 + 8);
        if (v20)
          v11 = v20;
        if (v16 == ++v17)
        {
          v17 = *(_QWORD *)(a3 + 776);
          break;
        }
      }
      if (!v11)
      {
LABEL_77:
        v40 = 0;
LABEL_80:
        v38 = cf;
LABEL_81:
        v8 = v54;
        if (v38)
          CFRelease(v38);
        result = 4294951670;
        if (v40 == -15626)
        {
LABEL_94:
          if (!v6)
            return result;
          goto LABEL_95;
        }
LABEL_84:
        v42 = segPumpStreamSchedulePreloadHintRead(a1, (_QWORD *)a3);
        result = 4294951670;
        if (v42 == -15626)
          goto LABEL_94;
        v43 = (_BYTE *)CMBaseObjectGetDerivedStorage();
        if (segPumpStreamHasPreloadMapHint(a3)
          && segPumpShouldDoSegmentReadAheads(v43)
          && segPumpStreamGetFuturePreloadCount((uint64_t)v43, (_QWORD *)a3)
          && !segPumpMediaConnectionIsActive(*(_QWORD *)(a3 + 800)))
        {
          PreloadMapHint = (const void *)FigMediaPlaylistGetPreloadMapHint(*(_QWORD *)(a3 + 56));
          v45 = *(const __CFURL **)(a3 + 16);
          v46 = *(const __CFURL **)(a3 + 24);
          MediaFilePrivateData = segPumpGetMediaFilePrivateData(PreloadMapHint);
          segPumpEnsureMediaSegmentURLs(PreloadMapHint, v45, v46);
          if (!MediaFilePrivateData[2])
          {
            MediaFile = FigSignalErrorAt();
LABEL_92:
            v51 = MediaFile;
            result = 4294951670;
            if (v51 == -15626)
              goto LABEL_94;
            goto LABEL_93;
          }
          v48 = *(const __CFURL **)(a3 + 16);
          v49 = *(const __CFURL **)(a3 + 24);
          segPumpGetMediaFilePrivateData(PreloadMapHint);
          segPumpEnsureMediaSegmentURLs(PreloadMapHint, v48, v49);
          if (segPumpStreamGetMapNumber((_QWORD *)a3) < 0)
          {
            *((_QWORD *)segPumpGetMediaFilePrivateData(PreloadMapHint) + 6) = 0;
            *((_QWORD *)segPumpGetMediaFilePrivateData(PreloadMapHint) + 7) = 0;
            MediaFile = segPumpReadMediaFile(a1, a3, PreloadMapHint, 1, 1, 0, (uint64_t *)(a3 + 800));
            goto LABEL_92;
          }
        }
LABEL_93:
        result = segPumpReadNextCryptKeyForStream(a1, v8, (_QWORD *)a3);
        goto LABEL_94;
      }
    }
    v53 = v6;
    while (1)
    {
      if (v17 >= *(_QWORD *)(a3 + 776))
        goto LABEL_77;
      v21 = *(_BYTE *)(v13 + 329) ? 1 : *(int *)(v13 + 8212);
      if (v17 >= v21)
        goto LABEL_77;
      NextSegment = (const void *)FigMediaSegmentSpecifierGetNextSegment(v11);
      if (!NextSegment)
      {
        if (!FigMediaSegmentSpecifierIsFragment(v11))
          goto LABEL_77;
        v23 = *(_QWORD *)(a3 + 56);
        if (!v23)
          goto LABEL_77;
        FigMediaPlaylistGetMediaSegmentSpecifiers(v23);
        LastValue = FigCFArrayGetLastValue();
        if (!LastValue)
          goto LABEL_77;
        PreviousSegment = LastValue;
        while (1)
        {
          FigMediaSegmentSpecifierGetPartialSegments(PreviousSegment);
          if (v11 == FigCFArrayGetLastValue())
            break;
          PreviousSegment = FigMediaSegmentSpecifierGetPreviousSegment(PreviousSegment);
          if (!PreviousSegment)
            goto LABEL_77;
        }
        NextSegment = (const void *)FigMediaSegmentSpecifierGetNextSegment(PreviousSegment);
        if (!NextSegment)
          goto LABEL_77;
      }
      FigMediaSegmentSpecifierGetPartialSegments((uint64_t)NextSegment);
      if (FigCFArrayGetFirstValue() && FigMediaSegmentSpecifierIsFragment((uint64_t)NextSegment))
      {
        FigMediaSegmentSpecifierGetPartialSegments((uint64_t)NextSegment);
        NextSegment = (const void *)FigCFArrayGetFirstValue();
      }
      v26 = segPumpGetMediaFilePrivateData(NextSegment);
      if (v26[13])
        goto LABEL_78;
      v27 = v26;
      if (FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)NextSegment))
      {
        v56 = 0;
        MapSegmentSpecifier = (const void *)FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)NextSegment);
        if (!segPumpIsMapEntryCached(v13, a3, MapSegmentSpecifier, &v56) && !v56)
          goto LABEL_78;
      }
      if (NextSegment && FigMediaSegmentSpecifierGetType((uint64_t)NextSegment) == 1)
        goto LABEL_78;
      if (*(_BYTE *)(v13 + 322))
      {
        if (FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)NextSegment))
        {
          ContentKeySpecifier = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)NextSegment);
          if (segPumpDoesCryptKeyRequireFetch(ContentKeySpecifier))
            goto LABEL_78;
        }
      }
      if (FigMediaSegmentSpecifierIsMarkedAsGap(v11)
        || FigMediaSegmentSpecifierIsMarkedAsGap((uint64_t)NextSegment))
      {
        break;
      }
      if (segPumpSeeIfMediaFileIsInCache(v13, a3, NextSegment, &v58, 0))
        goto LABEL_78;
      v30 = *(const __CFURL **)(a3 + 16);
      v31 = *(const __CFURL **)(a3 + 24);
      v32 = segPumpGetMediaFilePrivateData(NextSegment);
      segPumpEnsureMediaSegmentURLs(NextSegment, v30, v31);
      if (!v32[2])
      {
        v37 = FigSignalErrorAt();
LABEL_101:
        v40 = v37;
        goto LABEL_79;
      }
      v33 = *(const __CFURL **)(a3 + 16);
      v34 = *(const __CFURL **)(a3 + 24);
      v35 = (const __CFURL **)segPumpGetMediaFilePrivateData(NextSegment);
      segPumpEnsureMediaSegmentURLs(NextSegment, v33, v34);
      if (!segPumpShouldRequestURLAsHTTPURL(v13, v35[2]))
        goto LABEL_78;
      v36 = *(_QWORD **)(a3 + 680);
      if (v36)
      {
        while (!segPumpMediaConnectionIncludesMedia(a3, (uint64_t)v36, NextSegment))
        {
          v36 = (_QWORD *)*v36;
          if (!v36)
            goto LABEL_67;
        }
LABEL_78:
        v40 = 0;
LABEL_79:
        v6 = v53;
        goto LABEL_80;
      }
LABEL_67:
      v37 = segPumpCopyAndCreateNetworkURLFromPumpCache(v13, a3, &cf);
      if (v37)
        goto LABEL_101;
      v38 = cf;
      if (!FigCFHTTPCompareURLs(*(const void **)(a3 + 24), cf))
      {
        v40 = 0;
        v6 = v53;
        goto LABEL_81;
      }
      if (v38)
      {
        CFRelease(v38);
        cf = 0;
      }
      v27[6] = 0;
      v27[7] = 0;
      v27[13] = v58;
      v37 = segPumpReadMediaFile(a1, a3, NextSegment, 1, 0, v15, (uint64_t *)(*(_QWORD *)(a3 + 768) + 8 * v17));
      if (v37)
        goto LABEL_101;
      v39 = *(_QWORD *)(*(_QWORD *)(a3 + 768) + 8 * v17);
      v6 = v53;
      if (!v39)
        goto LABEL_77;
      v40 = 0;
      v41 = *(const void **)(v39 + 32);
      if (v41)
        v15 = v41;
      ++v17;
      v11 = (uint64_t)NextSegment;
      if (!NextSegment)
        goto LABEL_80;
    }
    if (FigMediaSegmentSpecifierIsMarkedAsGap(v11))
      v52 = v11;
    else
      v52 = (uint64_t)NextSegment;
    v37 = segPumpHandleMediaFileNetworkError(a1, (_QWORD *)a3, 0, v52, 4294951877);
    goto LABEL_101;
  }
  result = 0;
  if (a6)
LABEL_95:
    *v6 = v55;
  return result;
}

uint64_t segPumpGetNetworkLatencyFromPredictor(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t UpTimeNanoseconds;
  uint64_t result;
  uint64_t (*v8)(uint64_t, uint64_t, _OWORD *, _OWORD *);
  _OWORD v9[2];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  _BYTE v14[224];
  _OWORD v15[14];

  memset(&v14[8], 0, 216);
  segPumpMakeNetworkPredictionInput(a1, (uint64_t)v14);
  v13 = 0;
  v11 = 0u;
  v12 = 0u;
  v10 = 0u;
  memset(v9, 0, sizeof(v9));
  *a2 = 0;
  v4 = *(_QWORD *)(a1 + 112);
  *(_QWORD *)&v14[16] = 60000000000;
  *(_QWORD *)v14 = v4;
  *(_QWORD *)&v14[168] |= 8uLL;
  v5 = *(_QWORD *)(a1 + 96);
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  result = CMBaseObjectGetVTable();
  v8 = *(uint64_t (**)(uint64_t, uint64_t, _OWORD *, _OWORD *))(*(_QWORD *)(result + 16) + 8);
  if (v8)
  {
    v15[10] = *(_OWORD *)&v14[160];
    v15[11] = *(_OWORD *)&v14[176];
    v15[12] = *(_OWORD *)&v14[192];
    v15[13] = *(_OWORD *)&v14[208];
    v15[6] = *(_OWORD *)&v14[96];
    v15[7] = *(_OWORD *)&v14[112];
    v15[8] = *(_OWORD *)&v14[128];
    v15[9] = *(_OWORD *)&v14[144];
    v15[2] = *(_OWORD *)&v14[32];
    v15[3] = *(_OWORD *)&v14[48];
    v15[4] = *(_OWORD *)&v14[64];
    v15[5] = *(_OWORD *)&v14[80];
    v15[0] = *(_OWORD *)v14;
    v15[1] = *(_OWORD *)&v14[16];
    result = v8(v5, UpTimeNanoseconds, v15, v9);
    if (!(_DWORD)result)
      *a2 = v10;
  }
  return result;
}

uint64_t segPumpTryToMatchDate(uint64_t a1, uint64_t a2, double *a3, double *a4, CFAbsoluteTime a5, double a6)
{
  const __CFAllocator *AllocatorForMedia;
  CFDateRef v13;
  double v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t DateStamp;
  const void *v18;
  double v19;
  const void *FirstValue;
  double v21;
  const __CFAllocator *v22;
  CFDateRef v23;
  unsigned int v24;
  double v26;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  double PlaylistActiveDurationSecs;
  double v29;
  const __CFAllocator *v30;
  CFDateRef v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39[31];

  v39[29] = *MEMORY[0x1E0C80C00];
  v39[0] = 0;
  v37 = 0;
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  v13 = CFDateCreate(AllocatorForMedia, a5);
  v38 = 0;
  v14 = 0.0;
  while (segPumpIterateMedia(a2, &v38, &v37, v39))
  {
    v15 = v37;
    v16 = v38;
    FigMediaSegmentSpecifierGetPartialSegments(v38);
    if (v15 == FigCFArrayGetFirstValue() && FigMediaSegmentSpecifierGetDateStamp(v16))
    {
      DateStamp = FigMediaSegmentSpecifierGetDateStamp(v16);
      v14 = MEMORY[0x194029D14](DateStamp);
    }
    if (v14 != 0.0)
    {
      v18 = (const void *)v39[0];
      if (v14 <= a5 && v14 + FigMediaSegmentSpecifierGetTimeInSeconds(v39[0]) > a5)
        goto LABEL_11;
      v14 = v14 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v18);
    }
  }
  v18 = (const void *)v39[0];
LABEL_11:
  if (v18)
  {
    v19 = *((double *)segPumpGetMediaFilePrivateData(v18) + 4);
    FigMediaPlaylistGetMediaSegmentSpecifiers(a2);
    FirstValue = (const void *)FigCFArrayGetFirstValue();
    v21 = v19 - *((double *)segPumpGetMediaFilePrivateData(FirstValue) + 4);
    v22 = (const __CFAllocator *)FigGetAllocatorForMedia();
    v23 = CFDateCreate(v22, v14);
    v24 = 3 * *(_DWORD *)(a1 + 8);
    if (v21 <= a6 - (double)v24 || v21 >= (double)v24 + a6)
    {
      v26 = 0.0;
      if (dword_1EE2A31E8)
      {
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      v35 = 0;
      PlaylistActiveDurationSecs = 0.0;
      if (!v23)
        goto LABEL_37;
LABEL_30:
      CFRelease(v23);
      if (!v13)
        goto LABEL_39;
LABEL_38:
      CFRelease(v13);
      goto LABEL_39;
    }
    v26 = v14 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v18) - a5;
    if (dword_1EE2A31E8)
    {
      v33 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    PlaylistActiveDurationSecs = v21 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v18) - v26;
    v35 = 1;
    if (v23)
      goto LABEL_30;
LABEL_37:
    if (!v13)
      goto LABEL_39;
    goto LABEL_38;
  }
  PlaylistActiveDurationSecs = FigMediaPlaylistGetPlaylistActiveDurationSecs(a2);
  v29 = *(double *)(a1 + 16);
  if (v29 <= 0.0)
  {
    LODWORD(v29) = *(_DWORD *)(a1 + 8);
    v29 = (double)*(unint64_t *)&v29;
  }
  if (v14 > v29 + a5 + 2.22044605e-16)
  {
    v30 = (const __CFAllocator *)FigGetAllocatorForMedia();
    v31 = CFDateCreate(v30, v14);
    if (dword_1EE2A31E8)
    {
      v32 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    v26 = 0.0;
    if (v31)
      CFRelease(v31);
    v35 = 0;
    PlaylistActiveDurationSecs = 0.0;
    goto LABEL_37;
  }
  v26 = 0.0;
  if (dword_1EE2A31E8)
  {
    v34 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT);
    v35 = 1;
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    if (v13)
      goto LABEL_38;
  }
  else
  {
    v35 = 1;
    if (v13)
      goto LABEL_38;
  }
LABEL_39:
  if ((_DWORD)v35)
  {
    *a3 = PlaylistActiveDurationSecs;
    *a4 = v26;
  }
  return v35;
}

uint64_t segPumpDetermineMediaSegmentToSwitchTo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, double a8, double a9, CFAbsoluteTime a10, double a11, double a12, double a13, double a14, uint64_t a15, uint64_t *a16, _QWORD *a17)
{
  int matched;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v27;
  CFIndex v28;
  uint64_t v29;
  const void *v30;
  double v31;
  double v32;
  double v33;
  int v34;
  const __CFArray *MediaSegmentSpecifiers;
  const __CFArray *v36;
  const void *ValueAtIndex;
  const __CFArray *PartialSegments;
  const __CFArray *v39;
  CFIndex v40;
  CFIndex Count;
  const void *v42;
  double TimeInSeconds;
  uint64_t NextSegment;
  NSObject *v45;
  const void *v46;
  const __CFArray *v47;
  CFIndex v48;
  CFIndex i;
  const void *v50;
  double v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  double v55;
  double v56;
  double v57;
  double v58;
  NSObject *v59;
  uint64_t result;
  double v61;
  double v62;
  unint64_t v63;
  uint64_t PreviousSegment;
  const void *v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  double v69;
  double v70;
  const void *v71;
  uint64_t DiscontinuityDomain;
  double v73;
  BOOL v74;
  double BitRate;
  double v76;
  double v77;
  NSObject *v78;
  int v79;
  NSObject *v80;
  int v81;
  int v82;
  uint64_t v87;
  double v88[33];

  v88[31] = *(double *)MEMORY[0x1E0C80C00];
  v88[0] = a8;
  v87 = 0;
  *a16 = 0;
  if (a10 == 0.0)
    matched = 0;
  else
    matched = segPumpTryToMatchDate(a1, a2, v88, (double *)&v87, a10, a8);
  if (!FigMediaPlaylistHasEndTag(a2) && !matched && v88[0] >= a13)
  {
    v88[0] = segPumpEnsureOffsetInDiscDomain(a4, a2, a3, v88[0] - a13);
    if (dword_1EE2A31E8)
    {
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
  }
  v82 = a6;
  v81 = matched;
  if (a7)
  {
    if (FigMediaPlaylistHasEndTag(a2))
      v27 = 0;
    else
      v27 = a7;
  }
  else
  {
    v27 = 0;
  }
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = v88[0];
  v32 = 0.0;
  v33 = 0.0;
  v34 = a5;
  while (1)
  {
    MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a2);
    if (MediaSegmentSpecifiers)
      MediaSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MediaSegmentSpecifiers);
    if (v28 >= (uint64_t)MediaSegmentSpecifiers)
      break;
    v36 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a2);
    ValueAtIndex = CFArrayGetValueAtIndex(v36, v28);
    PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)ValueAtIndex);
    if (PartialSegments && CFArrayGetCount(PartialSegments))
    {
      v39 = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)ValueAtIndex);
      v40 = 0;
      if (v39)
      {
LABEL_21:
        Count = CFArrayGetCount(v39);
        goto LABEL_23;
      }
      while (2)
      {
        Count = 0;
LABEL_23:
        if (v40 >= Count)
          goto LABEL_53;
        v42 = CFArrayGetValueAtIndex(v39, v40);
        if (FigMediaSegmentSpecifierIsFragment((uint64_t)v42))
        {
          if (!FigMediaSegmentSpecifierIsMarkedIndependent((uint64_t)v42)
            && FigMediaPlaylistHasIndependentParts(a2))
          {
            goto LABEL_34;
          }
LABEL_30:
          if (v27 || v33 < v31)
          {
            if (FigMediaSegmentSpecifierGetDiscontinuityDomain((uint64_t)v42) + a4 == a3)
            {
              v32 = v33;
              v29 = (uint64_t)ValueAtIndex;
              v30 = v42;
            }
            goto LABEL_34;
          }
        }
        else
        {
          if (FigMediaPlaylistHasIndependentSegments(a2))
            goto LABEL_30;
LABEL_34:
          if (v27)
          {
            if (FigMediaSegmentSpecifierIsMarkedAsGap((uint64_t)v42))
              v30 = 0;
          }
        }
        v33 = v33 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v42);
        ++v40;
        if (v39)
          goto LABEL_21;
        continue;
      }
    }
    if (v27 && FigMediaSegmentSpecifierIsMarkedAsGap((uint64_t)ValueAtIndex))
    {
      v33 = v33 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
    }
    else
    {
      FigMediaPlaylistGetMediaSegmentSpecifiers(a2);
      if ((const void *)FigCFArrayGetLastValue() == ValueAtIndex)
        goto LABEL_49;
      TimeInSeconds = 0.0;
      if (!v27)
        TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
      if (v33 + TimeInSeconds >= v31)
      {
LABEL_49:
        if (FigMediaSegmentSpecifierGetDiscontinuityDomain((uint64_t)ValueAtIndex) + a4 == a3)
          goto LABEL_58;
        if (dword_1EE2A31E8)
        {
          v45 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
          v34 = a5;
        }
      }
      else if (FigMediaSegmentSpecifierGetNextSegment((uint64_t)ValueAtIndex))
      {
        NextSegment = FigMediaSegmentSpecifierGetNextSegment((uint64_t)ValueAtIndex);
        if (FigMediaSegmentSpecifierGetDiscontinuityDomain(NextSegment) + a4 > a3)
          goto LABEL_58;
      }
    }
    v33 = v33 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
LABEL_53:
    if (v34 && !FigMediaSegmentSpecifierIsFragment((uint64_t)ValueAtIndex))
      segPumpSetDeliveryStatusForMediaFileAndParts(ValueAtIndex, 1);
    ++v28;
  }
  ValueAtIndex = 0;
LABEL_58:
  if (v27 && (!v30 || v32 < v31 - (segPumpGetMinimumPrebufferReservation(a1, 0) + *(double *)(a1 + 7960))))
  {
    *a16 = 0;
    return 4294954652;
  }
  if (v34 && v30)
  {
    if (v29)
    {
      v46 = (const void *)v29;
      do
      {
        segPumpSetDeliveryStatusForMediaFileAndParts(v46, 0);
        v46 = (const void *)FigMediaSegmentSpecifierGetNextSegment((uint64_t)v46);
      }
      while (v46);
    }
    v47 = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments(v29);
    v48 = 0;
    if (!v47)
      goto LABEL_69;
LABEL_68:
    for (i = CFArrayGetCount(v47); v48 < i; i = 0)
    {
      v50 = CFArrayGetValueAtIndex(v47, v48);
      if (v50 == v30)
        break;
      segPumpSetDeliveryStatusForMediaFileAndParts(v50, 1);
      ++v48;
      if (v47)
        goto LABEL_68;
LABEL_69:
      ;
    }
    v33 = v32;
    ValueAtIndex = (const void *)v29;
  }
  *a16 = (uint64_t)v30;
  if (ValueAtIndex)
    goto LABEL_145;
  if (v27)
    return 4294954652;
  result = FigSignalErrorAt();
  if (!(_DWORD)result)
  {
LABEL_145:
    if (FigMediaSegmentSpecifierIsDiscontinuity((uint64_t)ValueAtIndex))
    {
      v51 = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
      v52 = a1;
      v53 = v82;
      goto LABEL_78;
    }
    v53 = v82;
    if (!v82 && *a16)
    {
LABEL_133:
      v71 = ValueAtIndex;
LABEL_134:
      if (!v71)
        return 0;
      if (FigMediaSegmentSpecifierIsFragment((uint64_t)v71) && !*a16)
      {
        FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v71);
        *a16 = FigCFArrayGetFirstValue();
      }
      if (dword_1EE2A31E8)
      {
        v80 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      result = 0;
      *a17 = v71;
      return result;
    }
    v51 = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
    v61 = v88[0] - v33;
    v62 = 1.0;
    if (!v81
      && !*a16
      && (!FigMediaPlaylistHasIndependentSegments(a2)
       || FigMediaPlaylistGetPlaylistType(a2) != 2))
    {
      LODWORD(v63) = *(_DWORD *)(a1 + 8);
      v62 = (double)v63;
    }
    if (v61 < v62)
    {
      while (1)
      {
        PreviousSegment = FigMediaSegmentSpecifierGetPreviousSegment((uint64_t)ValueAtIndex);
        if (!PreviousSegment)
          break;
        v65 = (const void *)PreviousSegment;
        if (FigMediaSegmentSpecifierGetDiscontinuityDomain(PreviousSegment) + a4 != a3)
          break;
        if (v34)
          segPumpSetDeliveryStatusForMediaFileAndParts(v65, 0);
        v51 = v51 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v65);
        v61 = v61 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v65);
        v33 = v33 - FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v65);
        ValueAtIndex = v65;
        if (v61 >= v62)
          goto LABEL_102;
      }
    }
    v65 = ValueAtIndex;
    if (FigMediaPlaylistHasIndependentSegments(a2))
      goto LABEL_103;
LABEL_102:
    v52 = a1;
    LODWORD(v66) = *(_DWORD *)(a1 + 8);
    if (v61 >= (double)v66)
    {
      ValueAtIndex = v65;
LABEL_78:
      if (v53 && a12 > 0.0 && (*(_DWORD *)(v52 + 8088) & 0x80000000) == 0)
      {
        v54 = v52;
        v55 = v51 * a11 / a12 + a14;
        v56 = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
        v57 = v33 + v56 - v88[0] + a9;
        v58 = a9 / *(double *)(v54 + 8704);
        segPumpGetMediaFilePrivateData(ValueAtIndex);
        if (dword_1EE2A31E8)
        {
          v59 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        v68 = FigMediaSegmentSpecifierGetPreviousSegment((uint64_t)ValueAtIndex);
        if (v68)
        {
          v69 = v58 - v55;
          v70 = 0.0;
          while (1)
          {
            v71 = (const void *)v68;
            if (FigMediaSegmentSpecifierIsDiscontinuity((uint64_t)ValueAtIndex))
              break;
            DiscontinuityDomain = FigMediaSegmentSpecifierGetDiscontinuityDomain((uint64_t)v71);
            if (DiscontinuityDomain != FigMediaSegmentSpecifierGetDiscontinuityDomain((uint64_t)ValueAtIndex))
              break;
            segPumpGetMediaFilePrivateData(v71);
            v73 = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v71);
            v74 = FigMediaSegmentSpecifierGetBitRate((uint64_t)v71) <= 0.0;
            BitRate = a11;
            if (!v74)
              BitRate = FigMediaSegmentSpecifierGetBitRate((uint64_t)v71);
            v76 = v73 * BitRate;
            if (v70 < (double)(4 * *(_DWORD *)(a1 + 8)))
            {
              v76 = v76 + v76;
              v70 = v70 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
            }
            v77 = v76 / a12 + a14;
            v57 = v57 - FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
            if (dword_1EE2A31E8)
            {
              v78 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT);
              fig_log_call_emit_and_clean_up_after_send_and_compose();
            }
            if (v77 >= v69
              || v57 <= 0.0
              || v57 < 30.0
              && FigMediaSegmentSpecifierGetBitRate((uint64_t)v71) > 0.0
              && FigMediaSegmentSpecifierGetBitRate((uint64_t)v71) > a12)
            {
              break;
            }
            if (v57 <= FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v71))
            {
              v77 = v77 * 1.1;
              v79 = a5;
              if (v57 / *(double *)(a1 + 8704) < v77)
                goto LABEL_133;
            }
            else
            {
              v79 = a5;
            }
            if (v79)
              segPumpSetDeliveryStatusForMediaFileAndParts(v71, 0);
            v69 = v69 - v77;
            FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v71);
            v33 = v33 - FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v71);
            v68 = FigMediaSegmentSpecifierGetPreviousSegment((uint64_t)v71);
            ValueAtIndex = v71;
            if (!v68)
              goto LABEL_134;
          }
        }
      }
      goto LABEL_133;
    }
    v67 = FigMediaSegmentSpecifierGetPreviousSegment((uint64_t)v65);
    if (v67 && (ValueAtIndex = (const void *)v67, FigMediaSegmentSpecifierGetDiscontinuityDomain(v67) + a4 == a3))
    {
      if (v34)
        segPumpSetDeliveryStatusForMediaFileAndParts(ValueAtIndex, 0);
      v51 = v51 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
      v33 = v33 - FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
    }
    else
    {
LABEL_103:
      ValueAtIndex = v65;
    }
    v52 = a1;
    goto LABEL_78;
  }
  return result;
}

double segPumpEnsureOffsetInDiscDomain(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  double i;
  uint64_t v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v13 = 0;
  v14 = 0;
  v12 = 0;
  for (i = 0.0; segPumpIterateMedia(a2, &v13, &v12, &v14); i = i + FigMediaSegmentSpecifierGetTimeInSeconds(v9))
  {
    v9 = v14;
    if (FigMediaSegmentSpecifierGetDiscontinuityDomain(v14) + a1 > a3)
      break;
    if (i + FigMediaSegmentSpecifierGetTimeInSeconds(v9) > a4
      && FigMediaSegmentSpecifierGetDiscontinuityDomain(v9) + a1 == a3)
    {
      if (i < a4)
        i = a4;
      break;
    }
  }
  if (i != a4 && v14 != 0)
    return i + FigMediaSegmentSpecifierGetTimeInSeconds(v14) * 0.125;
  return i;
}

void segPumpDeliverEnd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  unsigned int v11;
  uint64_t DataCallback;
  uint64_t v13;
  CFTypeRef cf;

  v13 = 0;
  cf = 0;
  v10 = segPumpLockAndCopyPumpFromRetainProxy(a1, &cf, &v13);
  if ((_DWORD)v10)
  {
    DataCallback = v10;
LABEL_6:
    segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(a1, DataCallback);
    goto LABEL_7;
  }
  if (*(_BYTE *)(a2 + 857))
  {
    *(_BYTE *)(a2 + 857) = 0;
    v11 = 10;
  }
  else
  {
    v11 = 2;
  }
  DataCallback = segPumpMakeDataCallback((uint64_t)cf, (uint64_t *)a2, *(const void **)(v13 + 176), 0, v11, *(_QWORD *)(a2 + 304), MEMORY[0x1E0CA2E18], 0, 0, a7, 0, 0);
  *(_BYTE *)(a2 + 1136) = 1;
  if ((_DWORD)DataCallback)
    goto LABEL_6;
LABEL_7:
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
}

_QWORD *segPumpGetAlternateEntryFromURLForCacheLookup(uint64_t a1, const void *a2, uint64_t a3)
{
  _QWORD *v3;
  CFTypeRef v7;
  const __CFDictionary *v9;
  const __CFURL *v10;

  v3 = *(_QWORD **)(a1 + 8096);
  if (v3)
  {
    while (1)
    {
      v9 = 0;
      v10 = 0;
      FigAlternateGetRenditionInfoForMediaType(v3[1], 1986618469, *(const void **)(a1 + 8392), *(const void **)(a1 + 8400), *(const void **)(a1 + 8408), 1, &v9, 0, &v10);
      v7 = FigCFHTTPCreateURLString(v10);
      if (CFEqual(v7, a2) || a3 && FigCFEqual())
        break;
      if (v7)
        CFRelease(v7);
      v3 = (_QWORD *)*v3;
      if (!v3)
        return v3;
    }
    if (v7)
      CFRelease(v7);
  }
  return v3;
}

void segPumpClearSuggestedAlternate(_QWORD *a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;

  if (a1[1028])
  {
    if (a1[1195])
    {
      v2 = a1[1191];
      if (v2)
      {
        FigAlternateSelectionBossRemoveFilter(v2, (uint64_t)CFSTR("PartialCache"));
        FigAlternateSelectionBossApplyFilters((const void *)a1[1191]);
      }
    }
  }
  v3 = (const void *)a1[1029];
  if (v3)
  {
    CFRelease(v3);
    a1[1029] = 0;
  }
  v4 = (const void *)a1[1028];
  if (v4)
  {
    CFRelease(v4);
    a1[1028] = 0;
  }
}

uint64_t segPumpTrySpeculativeRead(uint64_t a1, uint64_t *a2, uint64_t a3, const void *NextSegment, _BYTE *a5)
{
  uint64_t v10;
  uint64_t MediaFile;
  uint64_t v12;
  double v13;
  const void *v14;
  uint64_t v15;
  const void *PreviousSegment;
  uint64_t v17;
  double *MediaFilePrivateData;
  uint64_t v19;
  uint64_t *v20;
  double v21;
  double v22;
  const void *v23;
  const void *v24;
  char v26;

  v10 = *(_QWORD *)(a3 + 80);
  FigRetainProxyRetain();
  MediaFile = 0;
  *a5 = 0;
  if (!NextSegment || !a2[37])
    goto LABEL_34;
  if (*(_BYTE *)(a3 + 405) || *(_QWORD *)(a3 + 256))
    goto LABEL_11;
  v12 = *(_QWORD *)(a3 + 880);
  while (*((_BYTE *)segPumpGetMediaFilePrivateData(NextSegment) + 99))
  {
LABEL_10:
    NextSegment = (const void *)FigMediaSegmentSpecifierGetNextSegment((uint64_t)NextSegment);
    if (!NextSegment)
      goto LABEL_11;
  }
  v26 = 0;
  if (*(const void **)(*(_QWORD *)(a3 + 696) + 8) == NextSegment)
  {
    v14 = NextSegment;
    goto LABEL_14;
  }
  if (!segPumpCanAddSegmentToCache(a2, (_QWORD *)a3, NextSegment, &v26))
  {
    if (v26)
      goto LABEL_11;
    goto LABEL_10;
  }
  v14 = *(const void **)(*(_QWORD *)(a3 + 696) + 8);
LABEL_14:
  if (NextSegment == v14)
  {
LABEL_11:
    MediaFile = 0;
  }
  else
  {
    v15 = segPumpCheckCachedVariantsAndRequestSwitch((uint64_t)a2, a3, NextSegment, 0, v13);
    if (!(_DWORD)v15)
    {
      if (!FigRetainProxyIsInvalidated() && *(_QWORD *)(a3 + 80) == v10 && v12 == *(_QWORD *)(a3 + 880))
      {
        PreviousSegment = (const void *)FigMediaSegmentSpecifierGetPreviousSegment((uint64_t)NextSegment);
        if (PreviousSegment)
          v17 = *((_QWORD *)segPumpGetMediaFilePrivateData(PreviousSegment) + 4);
        else
          v17 = 0;
        *(_QWORD *)(a3 + 104) = v17;
        MediaFilePrivateData = (double *)segPumpGetMediaFilePrivateData(NextSegment);
        v19 = 0;
        v20 = a2 + 48;
        while (1)
        {
          if (v19 != *(_QWORD *)a3)
          {
            if (*(_QWORD *)(*v20 + 16))
            {
              v21 = *(double *)(*v20 + 104);
              v22 = MediaFilePrivateData[4];
              if (v21 < v22 - (double)(3 * FigMediaPlaylistGetTargetDuration(*(_QWORD *)(a3 + 56))))
                break;
            }
          }
          ++v19;
          v20 += 2;
          if (v19 == 3)
          {
            if (*(_QWORD *)(*(_QWORD *)(a3 + 696) + 8))
            {
              v23 = *(const void **)(a3 + 256);
              segPumpCancelMediaFileReadAndResetData((uint64_t)a2, a3, 1, 0);
              v24 = *(const void **)(a3 + 256);
              *(_QWORD *)(a3 + 256) = v23;
              if (v23)
                CFRetain(v23);
              if (v24)
                CFRelease(v24);
            }
            MediaFile = segPumpReadMediaFile(a1, a3, NextSegment, 0, 0, 0, 0);
            if (!(_DWORD)MediaFile)
              *a5 = 1;
            goto LABEL_34;
          }
        }
      }
      goto LABEL_11;
    }
    MediaFile = v15;
  }
LABEL_34:
  FigRetainProxyRelease();
  return MediaFile;
}

void segPumpCryptKeyPrivateDataFinalize(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  CCCryptorRef *v4;
  const void *v5;

  v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0;
  }
  v4 = (CCCryptorRef *)a1[3];
  if (v4)
  {
    FigCryptDispose(v4);
    a1[3] = 0;
  }
  v5 = (const void *)a1[5];
  if (v5)
  {
    CFRelease(v5);
    a1[5] = 0;
  }
}

CFStringRef segPumpCryptKeyPrivateDataCopyDesc(uint64_t a1)
{
  const __CFAllocator *AllocatorForMedia;

  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  return CFStringCreateWithFormat(AllocatorForMedia, 0, CFSTR("CryptKeyPrivateData: %p"), a1);
}

uint64_t segPumpResetCryptKeyRequestDataForCustomURLRequestID(const void *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;

  v6 = 0;
  v7 = 0;
  result = segPumpGetCryptKeyCommonData(a1, &v7, &v6);
  if (!(_DWORD)result)
  {
    v4 = v6;
    if (*(_QWORD *)(v6 + 80) == a2)
    {
      *(_QWORD *)(v6 + 80) = 0;
      *(_BYTE *)(v4 + 88) = 0;
      v5 = (_QWORD *)(v4 + 96);
    }
    else
    {
      if (*(_QWORD *)(v6 + 120) != a2)
        return result;
      *(_QWORD *)(v6 + 120) = 0;
      *(_BYTE *)(v4 + 128) = 0;
      v5 = (_QWORD *)(v4 + 136);
    }
    *v5 = 0;
  }
  return result;
}

uint64_t segPumpCryptMemoryRequestCallback(uint64_t a1, uint64_t a2, int a3, uint64_t a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t v10;
  uint64_t StreamFromCryptHTTPRequest;
  CMBlockBufferRef v12;
  CMBlockBufferRef *blockBufferOut;
  int CryptAlgForKey;
  size_t v15;
  const __CFAllocator *AllocatorForMedia;
  const __CFAllocator *v17;
  CFTypeRef v18;
  uint64_t v19;
  _QWORD *v21;
  CFTypeRef cf;

  v21 = 0;
  cf = 0;
  v10 = segPumpLockAndCopyPumpFromRetainProxy(a1, &cf, (uint64_t *)&v21);
  if (!(_DWORD)v10)
  {
    StreamFromCryptHTTPRequest = segPumpGetStreamFromCryptHTTPRequest(v21, a2, a3);
    if (!StreamFromCryptHTTPRequest || !*(_QWORD *)(StreamFromCryptHTTPRequest + 248))
    {
      v19 = 0;
      goto LABEL_9;
    }
    v12 = *(CMBlockBufferRef *)(StreamFromCryptHTTPRequest + 656);
    if (v12)
      goto LABEL_7;
    blockBufferOut = (CMBlockBufferRef *)(StreamFromCryptHTTPRequest + 656);
    CryptAlgForKey = segPumpGetCryptAlgForKey(*(_QWORD *)(StreamFromCryptHTTPRequest + 248));
    v15 = 2 * FigCryptGetKeySize(CryptAlgForKey);
    AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    v17 = (const __CFAllocator *)FigGetAllocatorForMedia();
    v10 = CMBlockBufferCreateWithMemoryBlock(AllocatorForMedia, 0, v15, v17, 0, 0, v15, 1u, blockBufferOut);
    if (!(_DWORD)v10)
    {
      v12 = *blockBufferOut;
      if (!*blockBufferOut)
      {
        v18 = 0;
        goto LABEL_8;
      }
LABEL_7:
      v18 = CFRetain(v12);
LABEL_8:
      v19 = 0;
      *a5 = v18;
      *a6 = 0;
      goto LABEL_9;
    }
  }
  v19 = v10;
LABEL_9:
  FigRetainProxyUnlockMutex();
  if (cf)
    CFRelease(cf);
  return v19;
}

uint64_t segPumpCryptFileReadCallback(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, int a8)
{
  uint64_t CryptKeyCommonData;
  _QWORD *v16;
  uint64_t StreamFromCryptHTTPRequest;
  _QWORD *CryptKeyCommonDataForRequestID;
  uint64_t v19;
  uint64_t DataPointer;
  uint64_t v21;
  uint64_t UpTimeNanoseconds;
  const void *v24;
  unint64_t v25;
  int CryptAlgForKey;
  const void *v27;
  const __CFAllocator *AllocatorForMedia;
  CFDataRef v29;
  CFDataRef v30;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;
  _QWORD *v33;
  uint64_t v34;
  _QWORD *v35;
  CFTypeRef cf;

  v35 = 0;
  cf = 0;
  v33 = 0;
  v34 = 0;
  FigRetainProxyRetain();
  CryptKeyCommonData = segPumpLockAndCopyPumpFromRetainProxy(a3, &cf, (uint64_t *)&v35);
  if ((_DWORD)CryptKeyCommonData)
    goto LABEL_27;
  v16 = v35;
  StreamFromCryptHTTPRequest = segPumpGetStreamFromCryptHTTPRequest(v35, a1, a2);
  if (StreamFromCryptHTTPRequest)
  {
    v19 = StreamFromCryptHTTPRequest;
    if (*(_QWORD *)(StreamFromCryptHTTPRequest + 592))
    {
      if (a8)
      {
LABEL_7:
        DataPointer = segPumpHandleCryptKeyNetworkError((uint64_t)cf, v19, *(const void **)(v19 + 248), a8, 0, 0);
        goto LABEL_8;
      }
    }
    else
    {
      UpTimeNanoseconds = FigGetUpTimeNanoseconds();
      *(_QWORD *)(v19 + 592) = UpTimeNanoseconds;
      *(_QWORD *)(v19 + 600) = UpTimeNanoseconds - *(_QWORD *)(v19 + 568);
      if (a8)
        goto LABEL_7;
    }
    v24 = *(const void **)(v19 + 248);
    if (!v24)
      goto LABEL_10;
    CryptKeyCommonData = segPumpGetCryptKeyCommonData(v24, &v34, &v33);
    if (!(_DWORD)CryptKeyCommonData)
    {
      if (a4)
      {
        v25 = v33[19] + a6;
        v33[19] = v25;
        CryptAlgForKey = segPumpGetCryptAlgForKey(*(_QWORD *)(v19 + 248));
        if (v25 > FigCryptGetKeySize(CryptAlgForKey))
        {
          segPumpAppendErrorLogEntry((uint64_t)cf, (uint64_t)v35, v19, (const __CFURL **)(v19 + 544), -12885, CFSTR("CoreMediaErrorDomain"), (uint64_t)CFSTR("Invalid Crypt key length"), 0, 0, 3u, 1u);
LABEL_19:
          DataPointer = FigSignalErrorAt();
LABEL_8:
          v21 = DataPointer;
          if (!(_DWORD)DataPointer)
            goto LABEL_10;
          goto LABEL_9;
        }
      }
      if ((a7 & 2) == 0)
        goto LABEL_10;
      lengthAtOffsetOut = 0;
      dataPointerOut = 0;
      *(_DWORD *)(v19 + 608) = 0;
      *(_QWORD *)(v19 + 584) = FigGetUpTimeNanoseconds();
      v27 = *(const void **)(v19 + 616);
      if (v27)
      {
        CFRelease(v27);
        *(_QWORD *)(v19 + 616) = 0;
      }
      DataPointer = CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(v19 + 656), 0, &lengthAtOffsetOut, 0, &dataPointerOut);
      if ((_DWORD)DataPointer)
        goto LABEL_8;
      AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
      v29 = CFDataCreate(AllocatorForMedia, (const UInt8 *)dataPointerOut, v33[19]);
      if (!v29)
        goto LABEL_19;
      v30 = v29;
      v21 = segPumpCryptSetKey((uint64_t)cf, (uint64_t)v35, v19, *(const void **)(v19 + 248), v33[10], 0, v29, 0);
      CFRelease(v30);
      if (!(_DWORD)v21)
        goto LABEL_10;
LABEL_9:
      segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(a3, v21);
      goto LABEL_10;
    }
LABEL_27:
    v21 = CryptKeyCommonData;
    goto LABEL_9;
  }
  CryptKeyCommonDataForRequestID = segPumpFindCryptKeyCommonDataForRequestID((uint64_t)v16, a2);
  v33 = CryptKeyCommonDataForRequestID;
  if (CryptKeyCommonDataForRequestID)
    *((_BYTE *)CryptKeyCommonDataForRequestID + 145) = 0;
LABEL_10:
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
  return FigRetainProxyRelease();
}

void segPumpCryptKeyTimeoutHandler(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CFTypeRef cf;

  v7 = 0;
  cf = 0;
  if (!segPumpLockAndCopyPumpFromRetainProxy(a2, &cf, &v7))
  {
    v3 = 384;
    while (1)
    {
      v4 = *(_QWORD *)(v7 + v3);
      if (*(_QWORD *)(v4 + 640) == a1 && *(_QWORD *)(v4 + 248))
      {
        v5 = 0;
        v6 = 0;
        if (segPumpGetCryptKeyCommonData(*(const void **)(*(_QWORD *)(v7 + v3) + 248), &v6, &v5))
          goto LABEL_10;
        if (!*(_BYTE *)(v5 + 144))
          break;
      }
      v3 += 16;
      if (v3 == 432)
        goto LABEL_10;
    }
    segPumpHandleCryptKeyNetworkError((uint64_t)cf, *(_QWORD *)(v7 + v3), *(const void **)(*(_QWORD *)(v7 + v3) + 248), -16833, CFSTR("CoreMediaErrorDomain"), CFSTR("crypt key received slowly"));
  }
LABEL_10:
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf)
    CFRelease(cf);
}

void segPumpKeyRequestDidSucceed(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, const void *a5, const sockaddr *a6)
{
  uint64_t StreamForKeyRequestID;
  _QWORD *v11;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v13;
  void (*v14)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD);
  const void *v15;
  uint64_t v16;
  const void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void (*v21)(uint64_t, _QWORD, uint64_t, uint64_t);
  const void *v22;
  uint64_t AllocatorForMedia;
  uint64_t v24;
  unsigned int (*v25)(const void *, _QWORD, uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  unsigned int (*v28)(const void *, _QWORD, uint64_t, uint64_t);
  uint64_t v29;
  uint64_t UpTimeNanoseconds;
  uint64_t v31;
  uint64_t v32;
  void (*v33)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  CFTypeRef cf[27];

  cf[25] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  v36 = 0;
  cf[0] = 0;
  v34 = 0;
  v35 = 0;
  if (!segPumpLockAndCopyPumpFromRetainProxy(a1, cf, &v36))
  {
    StreamForKeyRequestID = segPumpGetStreamForKeyRequestID(v36, a4);
    if (StreamForKeyRequestID)
    {
      v11 = (_QWORD *)StreamForKeyRequestID;
      if (dword_1EE2A31E8)
      {
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
      v13 = *(_QWORD *)(v36 + 9048);
      if (v13)
      {
        v14 = *(void (**)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                         + 56);
        if (v14)
          v14(v13, CFSTR("playerStats"), CFSTR("FetchingKey"), 0, 0);
      }
      if (!segPumpGetCryptKeyCommonData((const void *)v11[31], &v35, &v34))
      {
        if (FigContentKeySpecifierGetKeySystem((uint64_t)a3) == 1)
        {
          if (*(_QWORD *)(v34 + 32) == a4)
          {
            v15 = *(const void **)(v34 + 64);
            *(_QWORD *)(v34 + 64) = a5;
            if (a5)
              CFRetain(a5);
            if (v15)
              CFRelease(v15);
            v16 = v34;
            if (*(_QWORD *)(v34 + 40) && !*(_QWORD *)(v34 + 104))
              goto LABEL_38;
          }
          else
          {
            v22 = *(const void **)(v34 + 104);
            *(_QWORD *)(v34 + 104) = a5;
            if (a5)
              CFRetain(a5);
            if (v22)
              CFRelease(v22);
            v16 = v34;
            if (!*(_QWORD *)(v34 + 64))
              goto LABEL_38;
          }
          *(_WORD *)(v16 + 144) = 1;
          if (*(_BYTE *)(v36 + 322))
          {
            if (segPumpCryptKeyIsLowValueFairPlayStreamingKey(v11[31]))
            {
              AllocatorForMedia = FigGetAllocatorForMedia();
              v24 = v34;
              v25 = *(unsigned int (**)(const void *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                          + 48);
              if (!v25)
                goto LABEL_42;
              if (v25(a5, *MEMORY[0x1E0CA31D8], AllocatorForMedia, v24 + 48))
                goto LABEL_42;
              v26 = FigGetAllocatorForMedia();
              v27 = v34;
              v28 = *(unsigned int (**)(const void *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                          + 48);
              if (!v28 || v28(a5, *MEMORY[0x1E0CA31C8], v26, v27 + 56))
                goto LABEL_42;
            }
          }
        }
        else
        {
          if (FigContentKeySpecifierGetKeySystem((uint64_t)a3) != 2
            && FigContentKeySpecifierGetKeySystem((uint64_t)a3) != 4)
          {
LABEL_38:
            segPumpPublishContentKeyRequestEvent((uint64_t)cf[0], v36, v11, a3, 0, a6);
            if (v35)
            {
              v29 = *(_QWORD *)(v36 + 9048);
              UpTimeNanoseconds = FigGetUpTimeNanoseconds();
              if (v29)
              {
                v31 = UpTimeNanoseconds;
                v32 = *(_QWORD *)(v35 + 56);
                v33 = *(void (**)(uint64_t, __CFString *, __CFString *, unint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
                if (v33)
                  v33(v29, CFSTR("bytePumpStats"), CFSTR("CKFetchTime"), (v31 - v32) / 0xF4240uLL, 0);
              }
            }
            goto LABEL_42;
          }
          v17 = *(const void **)(v35 + 40);
          *(_QWORD *)(v35 + 40) = a5;
          if (a5)
            CFRetain(a5);
          if (v17)
            CFRelease(v17);
          *(_WORD *)(v34 + 144) = 1;
          v18 = *(_QWORD *)(v35 + 40);
          v19 = FigGetAllocatorForMedia();
          v20 = v34;
          v21 = *(void (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                         + 48);
          if (v21)
            v21(v18, *MEMORY[0x1E0CA31D8], v19, v20 + 48);
        }
        if (segPumpContinueAfterKeyFetched((uint64_t)cf[0], v36, v11, (const void *)v11[31]))
          goto LABEL_42;
        goto LABEL_38;
      }
    }
  }
LABEL_42:
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf[0])
    CFRelease(cf[0]);
}

void segPumpKeyRequestDidFail(uint64_t a1, int a2, const void *a3, uint64_t a4, CFErrorRef err, const sockaddr *a6)
{
  const __CFString *Domain;
  CFStringRef v12;
  uint64_t StreamForKeyRequestID;
  uint64_t v14;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v16;
  void (*v17)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD);
  CFNumberRef v18;
  uint64_t v19;
  void (*v20)(uint64_t, __CFString *, __CFString *, const __CFString *, uint64_t);
  uint64_t v21;
  void (*v22)(uint64_t, __CFString *, __CFString *, CFStringRef, uint64_t);
  uint64_t v23;
  void (*v24)(uint64_t, __CFString *, __CFString *, CFNumberRef, uint64_t);
  int valuePtr;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  CFTypeRef cf[29];

  cf[27] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  v28 = 0;
  cf[0] = 0;
  v26 = 0;
  v27 = 0;
  valuePtr = 0;
  if (err)
  {
    Domain = CFErrorGetDomain(err);
    valuePtr = CFErrorGetCode(err);
    v12 = CFErrorCopyDescription(err);
  }
  else
  {
    v12 = 0;
    Domain = CFSTR("CoreMediaErrorDomain");
  }
  if (segPumpLockAndCopyPumpFromRetainProxy(a1, cf, &v28)
    || (StreamForKeyRequestID = segPumpGetStreamForKeyRequestID(v28, a4)) == 0)
  {
    v18 = 0;
  }
  else
  {
    v14 = StreamForKeyRequestID;
    if (dword_1EE2A31E8)
    {
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    v16 = *(_QWORD *)(v28 + 9048);
    if (v16)
    {
      v17 = *(void (**)(uint64_t, __CFString *, __CFString *, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                       + 56);
      if (v17)
        v17(v16, CFSTR("playerStats"), CFSTR("FetchingKey"), 0, 0);
    }
    if (err)
    {
      v18 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
      v19 = *(_QWORD *)(v28 + 9048);
      if (v19)
      {
        v20 = *(void (**)(uint64_t, __CFString *, __CFString *, const __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 120);
        if (v20)
          v20(v19, CFSTR("bytePumpStats"), CFSTR("CKErrorDomain"), Domain, 100);
      }
      v21 = *(_QWORD *)(v28 + 9048);
      if (v21)
      {
        v22 = *(void (**)(uint64_t, __CFString *, __CFString *, CFStringRef, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                               + 120);
        if (v22)
          v22(v21, CFSTR("bytePumpStats"), CFSTR("CKErrorComment"), v12, 100);
      }
      v23 = *(_QWORD *)(v28 + 9048);
      if (v23)
      {
        v24 = *(void (**)(uint64_t, __CFString *, __CFString *, CFNumberRef, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                               + 120);
        if (v24)
          v24(v23, CFSTR("bytePumpStats"), CFSTR("CKErrorCode"), v18, 100);
      }
    }
    else
    {
      v18 = 0;
    }
    if (!segPumpGetCryptKeyCommonData(*(const void **)(v14 + 248), &v27, &v26)
      && !segPumpHandleCryptKeyNetworkError((uint64_t)cf[0], v14, *(const void **)(v14 + 248), valuePtr, Domain, v12))
    {
      segPumpPublishContentKeyRequestEvent((uint64_t)cf[0], v28, (_QWORD *)v14, a3, err, a6);
    }
  }
  segPumpUnlockAndSendAllPendingNotifications();
  if (cf[0])
    CFRelease(cf[0]);
  if (v12)
    CFRelease(v12);
  if (v18)
    CFRelease(v18);
}

uint64_t segPumpGetStreamForKeyRequestID(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  uint64_t v8;
  uint64_t v9;

  v3 = 0;
  v8 = 0;
  v9 = 0;
  v4 = a1 + 384;
  do
  {
    v5 = *(_QWORD *)(v4 + v3);
    v6 = *(const void **)(v5 + 248);
    if (v6)
    {
      if (segPumpGetCryptKeyCommonData(v6, &v9, &v8))
        return 0;
      if (*(_QWORD *)(v8 + 32) == a2 || *(_QWORD *)(v8 + 40) == a2)
        return v5;
    }
    v3 += 16;
  }
  while (v3 != 48);
  return 0;
}

void segPumpPublishContentKeyRequestEvent(uint64_t a1, uint64_t a2, _QWORD *a3, const void *a4, const void *a5, const sockaddr *a6)
{
  const sockaddr *v6;
  uint64_t Value;
  uint64_t BooleanValue;
  uint64_t v14;
  uint64_t AllocatorForMedia;
  void (*v16)(uint64_t, __CFString *, uint64_t, const void **);
  uint64_t v17;
  void (*v18)(uint64_t, __CFString *, uint64_t, CFDataRef *);
  const sockaddr *BytePtr;
  socklen_t Length;
  uint64_t v21;
  void (*v22)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  uint64_t v23;
  void (*v24)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  uint64_t v25;
  void (*v26)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  const __CFAllocator *v27;
  uint64_t v28;
  char v29;
  int v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  CFTypeRef cf;
  CFDataRef theData;
  CFAbsoluteTime v37;
  CFAbsoluteTime v38;
  CFAbsoluteTime v39;
  CFAbsoluteTime v40;
  CFTypeRef v41;
  CFTypeRef v42;
  const void *v43;
  void *v44;

  v6 = a6;
  v43 = 0;
  v44 = 0;
  v41 = 0;
  v42 = 0;
  v39 = 0.0;
  v40 = 0.0;
  v37 = 0.0;
  v38 = 0.0;
  cf = 0;
  theData = 0;
  v33 = 0;
  v34 = 0;
  if (a6)
  {
    Value = FigCFDictionaryGetValue();
    BooleanValue = FigCFDictionaryGetBooleanValue();
    v14 = FigCFDictionaryGetBooleanValue();
    if (Value)
    {
      AllocatorForMedia = FigGetAllocatorForMedia();
      v16 = *(void (**)(uint64_t, __CFString *, uint64_t, const void **))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                             + 8)
                                                                                 + 48);
      if (v16)
        v16(Value, CFSTR("FHRP_HTTPFinalURL"), AllocatorForMedia, &v43);
      v17 = FigGetAllocatorForMedia();
      v18 = *(void (**)(uint64_t, __CFString *, uint64_t, CFDataRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                               + 48);
      if (v18 && (v18(Value, CFSTR("FHRP_RemoteIPAddress"), v17, &theData), theData))
      {
        BytePtr = (const sockaddr *)CFDataGetBytePtr(theData);
        Length = CFDataGetLength(theData);
        v6 = FigCFHTTPCreateAddressStringFromSockaddr(BytePtr, Length);
      }
      else
      {
        v6 = 0;
      }
      v21 = FigGetAllocatorForMedia();
      v22 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                               + 48);
      if (v22)
        v22(Value, CFSTR("FHRP_CFNetworkTimingData"), v21, &v42);
      FigCFDictionaryGetDoubleIfPresent();
      FigCFDictionaryGetDoubleIfPresent();
      FigCFDictionaryGetDoubleIfPresent();
      FigCFDictionaryGetDoubleIfPresent();
      v23 = FigGetAllocatorForMedia();
      v24 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                               + 48);
      if (v24)
        v24(Value, CFSTR("FHRP_CFNetworkTransactionMetrics"), v23, &cf);
      v25 = FigGetAllocatorForMedia();
      v26 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                               + 48);
      if (v26)
        v26(Value, CFSTR("FHRP_ByteRange"), v25, &v41);
      FigCFDictionaryGetInt64IfPresent();
      FigCFDictionaryGetInt64IfPresent();
    }
    else
    {
      v6 = 0;
    }
  }
  else
  {
    BooleanValue = 0;
    v14 = 0;
  }
  v27 = (const __CFAllocator *)FigGetAllocatorForMedia();
  v28 = *MEMORY[0x1E0C9AE50];
  v29 = BooleanValue == *MEMORY[0x1E0C9AE50];
  if (*a3 > 2uLL)
    v30 = 0;
  else
    v30 = dword_1932FD19C[*a3];
  v31 = *MEMORY[0x1E0CA2E18];
  v32 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  if (!FigMetricContentKeyRequestEventCreate(v27, v43, v6, &v31, 0, 0, v34, v33, v40, v39, v38, v37, v29, a5, cf, v30, v14 == v28, a4, &v44))
    segPumpPublishMetricEvent(a1, a2, v44);
  if (cf)
    CFRelease(cf);
  if (v42)
    CFRelease(v42);
  if (v43)
    CFRelease(v43);
  if (v41)
    CFRelease(v41);
  if (v6)
    CFRelease(v6);
  if (theData)
    CFRelease(theData);
  if (v44)
    CFRelease(v44);
}

uint64_t segPumpGetStreamFromCryptHTTPRequest(_QWORD *a1, uint64_t a2, int a3)
{
  uint64_t result;
  uint64_t v5;

  result = a1[48];
  if (*(_QWORD *)(result + 560) != a2 || *(_DWORD *)(result + 624) != a3)
  {
    result = a1[50];
    if (*(_QWORD *)(result + 560) != a2 || *(_DWORD *)(result + 624) != a3)
    {
      result = a1[52];
      if (*(_QWORD *)(result + 560) != a2 || *(_DWORD *)(result + 624) != a3)
      {
        result = a1[49];
        if (*(_QWORD *)(result + 560) != a2 || *(_DWORD *)(result + 624) != a3)
        {
          result = a1[51];
          if (*(_QWORD *)(result + 560) != a2 || *(_DWORD *)(result + 624) != a3)
          {
            v5 = a1[53];
            if (*(_QWORD *)(v5 + 560) == a2)
            {
              if (*(_DWORD *)(v5 + 624) == a3)
                return v5;
              else
                return 0;
            }
            else
            {
              return 0;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t segPumpIsCryptorReadyToDecrypt(uint64_t a1)
{
  CFTypeRef v2;
  uint64_t AllocatorForMedia;
  uint64_t (*v4)(uint64_t, _QWORD, uint64_t, CFTypeRef *);
  int v5;
  BOOL v6;
  uint64_t v7;
  CFTypeRef cf;

  v2 = (CFTypeRef)*MEMORY[0x1E0C9AE40];
  cf = (CFTypeRef)*MEMORY[0x1E0C9AE40];
  AllocatorForMedia = FigGetAllocatorForMedia();
  v4 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 48);
  if (!v4)
  {
    v7 = 0;
    if (!v2)
      return v7;
    goto LABEL_9;
  }
  v5 = v4(a1, *MEMORY[0x1E0CA3218], AllocatorForMedia, &cf);
  v2 = cf;
  if (v5)
    v6 = 0;
  else
    v6 = *MEMORY[0x1E0C9AE50] == (_QWORD)cf;
  v7 = v6;
  if (cf)
LABEL_9:
    CFRelease(v2);
  return v7;
}

uint64_t *segPumpGetBytesInTransit(uint64_t *result, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  double ExpectedAverageBitrate;

  if (result)
  {
    v3 = result;
    if (result[4] || result[13])
    {
      result = (uint64_t *)result[1];
      if (!result)
        return result;
      if (!*((_BYTE *)segPumpGetMediaFilePrivateData(result) + 73))
      {
        v4 = v3[32];
        if (v4)
          return (uint64_t *)(v4 - v3[28]);
        if (a2)
        {
          ExpectedAverageBitrate = (double)(int)FigAlternateGetExpectedAverageBitrate(*(_QWORD *)(a2 + 8));
          return (uint64_t *)(uint64_t)(FigMediaSegmentSpecifierGetTimeInSeconds(v3[1]) * ExpectedAverageBitrate * 0.125);
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t segPumpSetNetworkReadsContributeToNetworkHistory(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  void (*v4)(uint64_t);

  if (*(unsigned __int8 *)(result + 8000) != a2)
  {
    v2 = result;
    *(_BYTE *)(result + 8000) = a2;
    v3 = *(_QWORD *)(result + 9040);
    if (v3)
    {
      v4 = *(void (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 24);
      if (v4)
        v4(v3);
    }
    return segPumpSetupNetworkHistory(v2);
  }
  return result;
}

uint64_t segPumpSetMediaSegmentCache(uint64_t a1, CFTypeRef cf)
{
  const void *v4;
  CFTypeRef v5;
  uint64_t v6;
  uint64_t SavedEntry;
  uint64_t v8;
  CFTypeRef v9;
  uint64_t i;
  uint64_t v11;
  uint64_t v12;
  const __CFArray *MediaSegmentSpecifiers;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFTypeRef v17;
  uint64_t CacheForStream;
  uint64_t v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t, const __CFString *, CFTypeRef);
  CFTypeRef cfa;
  CFTypeRef v24;

  cfa = 0;
  v24 = 0;
  v4 = *(const void **)(a1 + 296);
  if (cf)
    v5 = CFRetain(cf);
  else
    v5 = 0;
  *(_QWORD *)(a1 + 296) = v5;
  if (v4)
  {
    CMNotificationCenterGetDefaultLocalCenter();
    v6 = FigNotificationCenterRemoveWeakListener();
    if ((_DWORD)v6)
      goto LABEL_59;
    v5 = *(CFTypeRef *)(a1 + 296);
  }
  if (v5)
  {
    CMNotificationCenterGetDefaultLocalCenter();
    v6 = FigNotificationCenterAddWeakListener();
    if ((_DWORD)v6)
      goto LABEL_59;
    if (v4)
    {
      v6 = FigStreamingCacheCopyMasterPlaylist((uint64_t)v4, (unint64_t)&v24, (unint64_t)&cfa);
      if ((_DWORD)v6)
      {
LABEL_59:
        v19 = v6;
        goto LABEL_61;
      }
    }
    else
    {
      SavedEntry = segPumpFindSavedEntry(a1, *(const void **)(a1 + 312), 0, 0);
      if (SavedEntry)
      {
        v8 = SavedEntry;
        v6 = segPumpCreateIndexFileBBFromSavedIndexFile(a1, SavedEntry, &v24);
        if ((_DWORD)v6)
          goto LABEL_59;
        v9 = *(CFTypeRef *)(v8 + 40);
        if (v9)
          v9 = CFRetain(v9);
        cfa = v9;
      }
    }
    if (v24)
    {
      v6 = FigStreamingCacheSetMasterPlaylist(*(_QWORD *)(a1 + 296), v24, cfa);
      if ((_DWORD)v6)
        goto LABEL_59;
      if (cfa)
      {
        CFRelease(cfa);
        cfa = 0;
      }
      if (v24)
      {
        CFRelease(v24);
        v24 = 0;
      }
    }
  }
  for (i = 384; i != 432; i += 16)
  {
    v11 = *(_QWORD *)(a1 + i);
    if (!*(_QWORD *)(a1 + 296)
      || (v12 = *(_QWORD *)(v11 + 56)) == 0
      || (MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v12)) == 0
      || CFArrayGetCount(MediaSegmentSpecifiers) < 1
      || !*(_QWORD *)(a1 + 296))
    {
LABEL_32:
      *(_QWORD *)(v11 + 64) = 0;
      goto LABEL_33;
    }
    if (*(_BYTE *)(a1 + 8712))
    {
      if (!*(_BYTE *)(a1 + 7996) || *(_QWORD *)(a1 + 384) != v11)
        goto LABEL_32;
    }
    else if (!*(_BYTE *)(a1 + 7997))
    {
      goto LABEL_32;
    }
    if (v4 && (v14 = *(_QWORD *)(v11 + 64)) != 0)
    {
      v6 = FigStreamingCacheMediaStreamCopyPlaylist((uint64_t)v4, v14, (unint64_t)&v24, (unint64_t)&cfa);
      if ((_DWORD)v6)
        goto LABEL_59;
    }
    else
    {
      v15 = segPumpFindSavedEntry(a1, *(const void **)(v11 + 24), 0, 0);
      if (v15)
      {
        v16 = v15;
        v6 = segPumpCreateIndexFileBBFromSavedIndexFile(a1, v15, &v24);
        if ((_DWORD)v6)
          goto LABEL_59;
        v17 = *(CFTypeRef *)(v16 + 40);
        if (v17)
          v17 = CFRetain(v17);
        cfa = v17;
      }
    }
    CacheForStream = segPumpCreateCacheForStream(a1, (uint64_t *)v11);
    if ((_DWORD)CacheForStream != -15642)
    {
      v19 = CacheForStream;
      if ((_DWORD)CacheForStream)
        goto LABEL_61;
      if (v24)
      {
        v6 = segPumpSetPlaylistForStreamCache(a1, v11, v24, cfa);
        if ((_DWORD)v6)
          goto LABEL_59;
LABEL_33:
        if (v24)
        {
          CFRelease(v24);
          v24 = 0;
        }
      }
      if (cfa)
      {
        CFRelease(cfa);
        cfa = 0;
      }
      continue;
    }
  }
  if (*(_BYTE *)(a1 + 8011))
    segPumpMarkCurrentAlternatePersistentInCache(a1, 1);
  v20 = *(_QWORD *)(a1 + 9552);
  if (v20)
  {
    v21 = *(uint64_t (**)(uint64_t, const __CFString *, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                           + 56);
    if (v21)
    {
      v6 = v21(v20, CFSTR("AlternateFilterMonitorProperty_StreamingCache"), cf);
      goto LABEL_59;
    }
    v19 = 4294954514;
  }
  else
  {
    v19 = 0;
  }
LABEL_61:
  if (cfa)
    CFRelease(cfa);
  if (v24)
    CFRelease(v24);
  if (v4)
    CFRelease(v4);
  return v19;
}

uint64_t segPumpReadNextCryptKeyForAllStreams(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;

  v4 = 384;
  while (1)
  {
    v5 = *(_QWORD **)(a2 + v4);
    if (v5[2])
    {
      result = segPumpReadNextCryptKeyForStream(a1, a2, v5);
      if ((_DWORD)result)
        break;
    }
    v4 += 16;
    if (v4 == 432)
      return 0;
  }
  return result;
}

uint64_t segPumpMarkCurrentAlternatePersistentInCache(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  char v13;

  *(_BYTE *)(a1 + 8011) = a2;
  if (*(_QWORD *)(a1 + 296))
  {
    v4 = 0;
    v5 = *MEMORY[0x1E0C9AE50];
    v6 = *MEMORY[0x1E0C9AE40];
    v7 = a1 + 384;
    do
    {
      v8 = *(_QWORD *)(v7 + v4);
      if (*(_QWORD *)(v8 + 16))
      {
        v9 = *(_BYTE **)(v8 + 64);
        if (v9)
        {
          if (a2)
          {
            v10 = *(_QWORD *)(a1 + 296);
            v11 = v5;
          }
          else
          {
            v13 = 0;
            result = FigStreamingCacheMediaStreamIsComplete(*(_QWORD *)(a1 + 296), (uint64_t)v9, &v13);
            if ((_DWORD)result)
              return result;
            if (v13)
              goto LABEL_11;
            v10 = *(_QWORD *)(a1 + 296);
            v9 = *(_BYTE **)(v8 + 64);
            v11 = v6;
          }
          result = FigStreamingCacheMediaStreamSetPersistent(v10, v9, v11);
          if ((_DWORD)result)
            return result;
        }
      }
LABEL_11:
      v4 += 16;
    }
    while (v4 != 48);
  }
  return 0;
}

uint64_t segPumpSetShouldStoreCryptKeysInCache(uint64_t a1, int a2)
{
  CFIndex v3;
  uint64_t v4;
  const __CFArray *Count;
  _QWORD *ValueAtIndex;
  _QWORD *v7;
  uint64_t v8;
  uint64_t AllocatorForMedia;
  uint64_t (*v10)(uint64_t, uint64_t, uint64_t, CFTypeRef *);
  int v11;
  CFTypeRef v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  CFTypeRef cf;

  cf = 0;
  if (*(unsigned __int8 *)(a1 + 321) == a2)
    return 0;
  *(_BYTE *)(a1 + 321) = a2;
  if (!a2)
    return 0;
  v3 = 0;
  v4 = *MEMORY[0x1E0CA31F0];
  while (1)
  {
    Count = *(const __CFArray **)(a1 + 7688);
    if (Count)
      Count = (const __CFArray *)CFArrayGetCount(Count);
    if (v3 >= (uint64_t)Count)
    {
      v15 = 0;
      goto LABEL_20;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 7688), v3);
    if (!*((_BYTE *)ValueAtIndex + 146))
    {
      v7 = ValueAtIndex;
      v8 = ValueAtIndex[8];
      if (v8)
        break;
    }
LABEL_8:
    ++v3;
  }
  AllocatorForMedia = FigGetAllocatorForMedia();
  v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                         + 48);
  if (!v10)
    goto LABEL_16;
  v11 = v10(v8, v4, AllocatorForMedia, &cf);
  v12 = cf;
  if (v11)
    v13 = 1;
  else
    v13 = cf == 0;
  if (v13)
    goto LABEL_17;
  v14 = segPumpSaveCryptKeyToCache(a1, (const void *)v7[2]);
  if (!(_DWORD)v14)
  {
LABEL_16:
    v12 = cf;
LABEL_17:
    if (v12)
    {
      CFRelease(v12);
      cf = 0;
    }
    goto LABEL_8;
  }
  v15 = v14;
LABEL_20:
  if (cf)
    CFRelease(cf);
  return v15;
}

uint64_t segPumpSetRequiresCryptKeysForMediaDelivery(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 322) == a2)
    return 0;
  if (!*(_BYTE *)(a1 + 8684))
  {
    *(_BYTE *)(a1 + 322) = a2;
    return 0;
  }
  return FigSignalErrorAt();
}

_QWORD *segPumpRTCReportingUpdatePumpClientName(_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t (*v3)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);

  v1 = result[1183];
  if (v1)
  {
    v2 = result[1131];
    if (v2)
    {
      result = (_QWORD *)CMBaseObjectGetVTable();
      v3 = *(uint64_t (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(result[2] + 48);
      if (v3)
        return (_QWORD *)v3(v2, CFSTR("bytePumpStats"), CFSTR("PumpName"), v1, 0);
    }
  }
  return result;
}

uint64_t segPumpSetAlternatesInPenaltyBox(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4;
  CFIndex Count;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  unsigned int CurrentErrorCategory;
  char v12;
  int v13;
  CFRange v15;
  CFRange v16;
  CFRange v17;

  if (!*(_BYTE *)(a1 + 8176))
    return FigSignalErrorAt();
  if (!cf)
    return FigSignalErrorAt();
  v4 = CFGetTypeID(cf);
  if (v4 != CFArrayGetTypeID())
    return FigSignalErrorAt();
  Count = CFArrayGetCount((CFArrayRef)cf);
  v6 = *(_QWORD *)(a1 + 8144);
  if (v6)
  {
    v15.location = 0;
    v15.length = Count;
    if (CFArrayContainsValue((CFArrayRef)cf, v15, *(const void **)(v6 + 8)))
      return FigSignalErrorAt();
  }
  v7 = *(_QWORD *)(a1 + 8112);
  if (v7)
  {
    do
    {
      v8 = *(_QWORD *)v7;
      v16.location = 0;
      v16.length = Count;
      if (!CFArrayContainsValue((CFArrayRef)cf, v16, *(const void **)(v7 + 8)))
        MoveAlternateFromPenaltyBox(a1, (uint64_t *)v7);
      v7 = v8;
    }
    while (v8);
  }
  v9 = *(uint64_t **)(a1 + 8096);
  if (v9)
  {
    do
    {
      v10 = *v9;
      v17.location = 0;
      v17.length = Count;
      if (CFArrayContainsValue((CFArrayRef)cf, v17, (const void *)v9[1]))
      {
        CurrentErrorCategory = FigAlternateGetCurrentErrorCategory(v9[1]);
        v12 = CurrentErrorCategory;
        v13 = (CurrentErrorCategory >> 2) & 1;
        FigAlternateSetErrorCategory(v9[1], 0);
        MoveAlternateFromListWithNoNotification(a1, (uint64_t *)(a1 + 8096), v9, v13, v12 & 1);
      }
      v9 = (uint64_t *)v10;
    }
    while (v10);
  }
  return 0;
}

uint64_t segPumpSetNetworkHistory(uint64_t a1, CFTypeRef cf)
{
  uint64_t v2;
  const void *v4;
  const void *v5;
  uint64_t *v6;
  CFTypeRef *v7;
  const void *v8;
  uint64_t v9;
  const __CFAllocator *AllocatorForMedia;
  CFMutableDictionaryRef Mutable;
  const __CFDictionary *v12;
  const void *v13;
  uint64_t v14;
  const void *Value;
  const void *v16;
  uint64_t v17;
  void (*v18)(uint64_t, __CFString *, const void *);
  uint64_t v19;
  uint64_t v20;
  void (*v21)(uint64_t, __CFString *, uint64_t);
  const __CFAllocator *v22;
  CFStringRef v23;
  CFStringRef v24;
  uint64_t v25;

  v2 = a1 + 8684;
  if (!*(_BYTE *)(a1 + 8684))
  {
    v4 = *(const void **)(a1 + 88);
    *(_QWORD *)(a1 + 88) = cf;
    if (cf)
      CFRetain(cf);
    if (v4)
      CFRelease(v4);
    v6 = (uint64_t *)(a1 + 96);
    v5 = *(const void **)(a1 + 96);
    if (v5)
    {
      CFRelease(v5);
      *v6 = 0;
    }
    v7 = (CFTypeRef *)(a1 + 9040);
    v8 = *(const void **)(a1 + 9040);
    if (v8)
    {
      CFRelease(v8);
      *v7 = 0;
    }
    v9 = segPumpSetHTTPRequestOptionsValue(a1, CFSTR("FHRP_NetworkHistory"), *(const void **)(a1 + 88));
    if ((_DWORD)v9)
      return v9;
    AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v12 = Mutable;
      FigCFDictionarySetValue();
      v13 = (const void *)FigGetAllocatorForMedia();
      v14 = FigNetworkPredictionArbiterCreate(v13, *(const void **)(a1 + 88), v12, (_QWORD *)(a1 + 96));
      if (!(_DWORD)v14)
      {
        Value = (const void *)FigCFDictionaryGetValue();
        if (!Value || (v16 = CFRetain(Value)) == 0)
          v16 = (const void *)FigCFHTTPCopyClientBundleIdentifier(*(const __CFData **)(a1 + 8888));
        v17 = *v6;
        v18 = *(void (**)(uint64_t, __CFString *, const void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                         + 56);
        if (v18)
          v18(v17, CFSTR("NetworkPredictorProperty_ClientBundleIdentifier"), v16);
        v19 = *(_QWORD *)(a1 + 96);
        v20 = *(_QWORD *)(a1 + 9048);
        v21 = *(void (**)(uint64_t, __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
        if (v21)
          v21(v19, CFSTR("NetworkPredictorProperty_ReportingAgent"), v20);
        if (*(_BYTE *)(v2 + 901))
        {
          if (*(_QWORD *)(a1 + 88)
            && (v22 = (const __CFAllocator *)FigGetAllocatorForMedia(),
                (v23 = CFStringCreateWithFormat(v22, 0, CFSTR("%@"), *(_QWORD *)(a1 + 8760))) != 0))
          {
            v24 = v23;
            if (*v7)
            {
              CFRelease(*v7);
              *v7 = 0;
            }
            FigBandwidthPeriodicReporterCreate(*(_QWORD *)(a1 + 56), 1000000000 * *(_QWORD *)(a1 + 144), v24, *(_QWORD *)a1, &segPumpEnsureBandwidthPeriodicReporterIfEnabled_bandwidthPeriodicReportingCallbacks, *(_QWORD *)(a1 + 88), (_QWORD *)(a1 + 9040));
            CFRelease(v24);
          }
          else
          {
            FigSignalErrorAt();
          }
        }
        v25 = *(_QWORD *)(a1 + 9576);
        if (v25)
          FigCMCDHeaderVendorSetNetworkHistory(v25, *(const void **)(a1 + 88));
        if (v16)
          CFRelease(v16);
      }
      CFRelease(v12);
      return v14;
    }
  }
  return FigSignalErrorAt();
}

uint64_t segPumpSetMaxPipelinedConnections(uint64_t a1, int a2)
{
  uint64_t v3;
  unsigned int v4;
  int64_t v5;
  uint64_t result;

  v3 = 0;
  if (a2 <= 1)
    v4 = 1;
  else
    v4 = a2;
  if (v4 >= 0x100)
    v5 = 256;
  else
    v5 = v4;
  while (1)
  {
    result = segPumpStreamSetReadAheadConnectionCountMax(*(_QWORD *)(a1 + v3 + 384), v5);
    if ((_DWORD)result)
      break;
    result = segPumpStreamSetReadAheadConnectionCountMax(*(_QWORD *)(a1 + v3 + 392), v5);
    if ((_DWORD)result)
      break;
    v3 += 16;
    if (v3 == 48)
    {
      result = 0;
      *(_DWORD *)(a1 + 8212) = v5;
      return result;
    }
  }
  return result;
}

uint64_t segPumpSetRTCReportingAgent(_QWORD *a1, CFTypeRef cf)
{
  uint64_t v4;
  uint64_t (*v5)(CFTypeRef, uint64_t, __CFString *);
  uint64_t result;
  uint64_t v7;
  uint64_t (*v8)(CFTypeRef, uint64_t, __CFString *);
  uint64_t v9;
  uint64_t (*v10)(CFTypeRef, uint64_t, __CFString *);
  uint64_t v11;
  uint64_t (*v12)(CFTypeRef, uint64_t, __CFString *);
  const void *v13;
  const void *v14;
  uint64_t v15;
  void (*v16)(uint64_t, __CFString *, CFTypeRef);
  const __CFDictionary *v17;
  uint64_t v18;
  void (*v19)(uint64_t, __CFString *, __CFString *, const __CFDictionary *, _QWORD);

  if (!cf)
    return 0;
  v4 = a1[1131];
  if (!v4)
  {
    a1[1131] = cf;
    CFRetain(cf);
    goto LABEL_18;
  }
  v5 = *(uint64_t (**)(CFTypeRef, uint64_t, __CFString *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
  if (!v5)
    return 4294954514;
  result = v5(cf, v4, CFSTR("bytePumpStats"));
  if ((_DWORD)result)
    return result;
  v7 = a1[1131];
  if (!v7)
    return 4294955296;
  v8 = *(uint64_t (**)(CFTypeRef, uint64_t, __CFString *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
  if (!v8)
    return 4294954514;
  result = v8(cf, v7, CFSTR("cryptorStats"));
  if ((_DWORD)result)
    return result;
  v9 = a1[1131];
  if (!v9)
    return 4294955296;
  v10 = *(uint64_t (**)(CFTypeRef, uint64_t, __CFString *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
  if (!v10)
    return 4294954514;
  result = v10(cf, v9, CFSTR("parserStats"));
  if ((_DWORD)result)
    return result;
  v11 = a1[1131];
  if (!v11)
    return 4294955296;
  v12 = *(uint64_t (**)(CFTypeRef, uint64_t, __CFString *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
  if (!v12)
    return 4294954514;
  result = v12(cf, v11, CFSTR("startupStats"));
  if ((_DWORD)result)
    return result;
  v13 = (const void *)a1[1131];
  a1[1131] = cf;
  CFRetain(cf);
  if (v13)
    CFRelease(v13);
LABEL_18:
  v14 = (const void *)a1[1130];
  if (!v14 || (result = FigBandwidthPeriodicReporterSetReportingAgent(v14, cf), !(_DWORD)result))
  {
    v15 = a1[12];
    if (v15)
    {
      v16 = *(void (**)(uint64_t, __CFString *, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
      if (v16)
        v16(v15, CFSTR("NetworkPredictorProperty_ReportingAgent"), cf);
    }
    result = a1[1141];
    if (result)
    {
      v17 = FigRCLCopyConfigurationGroupName((CFDictionaryRef)result);
      v18 = a1[1131];
      if (v18)
      {
        v19 = *(void (**)(uint64_t, __CFString *, __CFString *, const __CFDictionary *, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 48);
        if (v19)
          v19(v18, CFSTR("bytePumpStats"), CFSTR("configurationGroup"), v17, 0);
      }
      if (v17)
        CFRelease(v17);
      return 0;
    }
  }
  return result;
}

uint64_t segPumpSetMetricEventTimeline(uint64_t a1, uint64_t a2, CFTypeRef cf)
{
  const void *v6;
  uint64_t v7;
  const __CFArray *v8;
  CFIndex v9;
  uint64_t v10;
  const void *ValueAtIndex;
  uint64_t (*v12)(uint64_t, uint64_t, const void *);
  uint64_t v13;

  v6 = *(const void **)(a2 + 9016);
  *(_QWORD *)(a2 + 9016) = cf;
  if (cf)
    CFRetain(cf);
  if (v6)
    CFRelease(v6);
  v7 = 0;
  if (cf)
  {
    v8 = *(const __CFArray **)(a2 + 9024);
    if (v8)
    {
      if (CFArrayGetCount(v8) < 1)
      {
LABEL_12:
        v7 = 0;
      }
      else
      {
        v9 = 0;
        while (1)
        {
          v10 = *(_QWORD *)(a2 + 9016);
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 9024), v9);
          v12 = *(uint64_t (**)(uint64_t, uint64_t, const void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                         + 40);
          if (!v12)
          {
            v7 = 4294954514;
            goto LABEL_14;
          }
          v13 = v12(v10, a1, ValueAtIndex);
          if ((_DWORD)v13)
            break;
          if (++v9 >= CFArrayGetCount(*(CFArrayRef *)(a2 + 9024)))
            goto LABEL_12;
        }
        v7 = v13;
      }
LABEL_14:
      FigCFArrayRemoveAllValues();
    }
  }
  return v7;
}

uint64_t segPumpResetContentKeyState(const void *a1)
{
  uint64_t DerivedStorage;
  uint64_t i;
  CFIndex j;
  const __CFArray *Count;
  _DWORD *ValueAtIndex;
  uint64_t v7;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v10;
  const void *v11;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v11 = a1;
  v10 = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if (!v10)
  {
    for (i = 384; i != 432; i += 16)
      segPumpCancelCryptReadAndResetData(DerivedStorage, *(_QWORD *)(DerivedStorage + i));
    for (j = 0; ; ++j)
    {
      Count = *(const __CFArray **)(DerivedStorage + 7688);
      if (Count)
        Count = (const __CFArray *)CFArrayGetCount(Count);
      if (j >= (uint64_t)Count)
        break;
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 7688), j);
      if (ValueAtIndex[6] == 1)
      {
        v7 = (uint64_t)ValueAtIndex;
        if (dword_1EE2A31E8)
        {
          os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        *(_QWORD *)(v7 + 80) = 0;
        *(_QWORD *)(v7 + 96) = 0;
        *(_BYTE *)(v7 + 88) = 0;
        *(_QWORD *)(v7 + 120) = 0;
        *(_BYTE *)(v7 + 128) = 0;
        *(_QWORD *)(v7 + 32) = 0;
        *(_QWORD *)(v7 + 40) = 0;
        *(_QWORD *)(v7 + 136) = 0;
        *(_DWORD *)(v7 + 143) = 0;
        CryptKeyReleaseAndClearVideoDecryptor(v7);
        CryptKeyReleaseAndClearAudioDecryptor(v7);
      }
    }
  }
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(v11, v10);
}

uint64_t segPumpBandwidthReportingPerformPredictionCallback(uint64_t a1, __CFDictionary *a2)
{
  uint64_t UpTimeNanoseconds;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int AverageBitRate;
  uint64_t v13;
  unsigned int (*v14)(uint64_t, uint64_t, __int128 *, _OWORD *);
  uint64_t v15;
  unsigned int (*v16)(uint64_t, uint64_t, __int128 *, _OWORD *);
  uint64_t v17;
  unsigned int (*v18)(uint64_t, uint64_t, __int128 *, _OWORD *);
  uint64_t v19;
  unsigned int (*v20)(uint64_t, uint64_t, __int128 *, _OWORD *);
  uint64_t v21;
  unsigned int (*v22)(uint64_t, uint64_t, __int128 *, _OWORD *);
  uint64_t v23;
  unsigned int (*v24)(uint64_t, uint64_t, __int128 *, _OWORD *);
  uint64_t v25;
  unsigned int (*v26)(uint64_t, uint64_t, __int128 *, _OWORD *);
  uint64_t v27;
  unsigned int (*v28)(uint64_t, uint64_t, __int128 *, _OWORD *);
  uint64_t v29;
  unsigned int (*v30)(uint64_t, uint64_t, __int128 *, _OWORD *);
  const void *SInt64;
  _OWORD v33[5];
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  CFTypeRef cf;
  __int128 v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  v42 = 0;
  cf = 0;
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v34 = 0;
  memset(v33, 0, sizeof(v33));
  if (segPumpLockAndCopyPumpFromRetainProxy(a1, &cf, &v42))
  {
    segPumpUnlockAndSendAllPendingNotifications();
  }
  else
  {
    segPumpMakeNetworkPredictionInput(v42, (uint64_t)&v44);
    v5 = *((_QWORD *)&v44 + 1);
    v6 = v46;
    v7 = v47;
    v8 = v48;
    v39 = v53;
    v40 = v54;
    v41 = v55;
    v35 = v49;
    v36 = v50;
    v37 = v51;
    v38 = v52;
    v61 = v58;
    v62 = v59;
    v60 = v57;
    v9 = v42;
    v10 = *(_QWORD *)(v42 + 8144);
    if (v10)
    {
      v11 = *(_QWORD *)(v10 + 8);
      if (v11)
      {
        AverageBitRate = FigAlternateGetAverageBitRate(v11);
        if (AverageBitRate
          || (AverageBitRate = FigAlternateGetPeakBitRate(*(_QWORD *)(*(_QWORD *)(v42 + 8144) + 8))) != 0)
        {
          v9 = v42;
          if (*(_DWORD *)(v42 + 8))
            v7 = *(_QWORD *)(v42 + 144) * AverageBitRate / 8;
        }
        else
        {
          v9 = v42;
        }
      }
    }
    v13 = *(_QWORD *)(v9 + 96);
    v14 = *(unsigned int (**)(uint64_t, uint64_t, __int128 *, _OWORD *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                            + 16)
                                                                                + 8);
    if (v14)
    {
      v52 = v38;
      v53 = v39;
      v54 = v40;
      v55 = v41;
      v49 = v35;
      *(_QWORD *)&v44 = 0;
      *((_QWORD *)&v44 + 1) = v5;
      v45 = 60000000000;
      v46 = v6;
      v47 = v7;
      v48 = v8;
      v50 = v36;
      v51 = v37;
      v56 = 9;
      v58 = v61;
      v59 = v62;
      v57 = v60;
      if (!v14(v13, UpTimeNanoseconds, &v44, v33))
      {
        FigCFDictionarySetInt64();
        FigCFDictionarySetInt64();
        FigCFDictionarySetInt64();
      }
    }
    v15 = *(_QWORD *)(v42 + 96);
    v16 = *(unsigned int (**)(uint64_t, uint64_t, __int128 *, _OWORD *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                            + 16)
                                                                                + 8);
    if (v16)
    {
      v52 = v38;
      v53 = v39;
      v54 = v40;
      v55 = v41;
      v49 = v35;
      *(_QWORD *)&v44 = 1;
      *((_QWORD *)&v44 + 1) = v5;
      v45 = 60000000000;
      v46 = v6;
      v47 = v7;
      v48 = v8;
      v50 = v36;
      v51 = v37;
      v56 = 9;
      v58 = v61;
      v59 = v62;
      v57 = v60;
      if (!v16(v15, UpTimeNanoseconds, &v44, v33))
      {
        FigCFDictionarySetInt64();
        FigCFDictionarySetInt64();
        FigCFDictionarySetInt64();
      }
    }
    v17 = *(_QWORD *)(v42 + 96);
    v18 = *(unsigned int (**)(uint64_t, uint64_t, __int128 *, _OWORD *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                            + 16)
                                                                                + 8);
    if (v18)
    {
      v48 = v8;
      v52 = v38;
      v53 = v39;
      v54 = v40;
      v55 = v41;
      v49 = v35;
      *(_QWORD *)&v44 = 2;
      *((_QWORD *)&v44 + 1) = v5;
      v45 = 60000000000;
      v46 = v6;
      v47 = v7;
      v50 = v36;
      v51 = v37;
      v56 = 9;
      v58 = v61;
      v59 = v62;
      v57 = v60;
      if (!v18(v17, UpTimeNanoseconds, &v44, v33))
      {
        FigCFDictionarySetInt64();
        FigCFDictionarySetInt64();
        FigCFDictionarySetInt64();
      }
    }
    v19 = *(_QWORD *)(v42 + 96);
    v20 = *(unsigned int (**)(uint64_t, uint64_t, __int128 *, _OWORD *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                            + 16)
                                                                                + 8);
    if (v20)
    {
      v48 = xmmword_1932FD0D0;
      v52 = v38;
      v53 = v39;
      v54 = v40;
      v55 = v41;
      v49 = v35;
      *(_QWORD *)&v44 = 4;
      *((_QWORD *)&v44 + 1) = v5;
      v45 = 60000000000;
      v46 = v6;
      v50 = v36;
      v51 = v37;
      v47 = v7;
      v56 = 9;
      v58 = v61;
      v59 = v62;
      v57 = v60;
      if (!v20(v19, UpTimeNanoseconds, &v44, v33))
      {
        FigCFDictionarySetInt64();
        FigCFDictionarySetInt64();
        FigCFDictionarySetInt64();
      }
    }
    v21 = *(_QWORD *)(v42 + 96);
    v22 = *(unsigned int (**)(uint64_t, uint64_t, __int128 *, _OWORD *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                            + 16)
                                                                                + 8);
    if (v22)
    {
      v48 = xmmword_1932FD0D0;
      v52 = v38;
      v53 = v39;
      v54 = v40;
      v55 = v41;
      v49 = v35;
      *(_QWORD *)&v44 = 3;
      *((_QWORD *)&v44 + 1) = v5;
      v45 = 60000000000;
      v46 = v6;
      v50 = v36;
      v51 = v37;
      v47 = v7;
      v56 = 9;
      v58 = v61;
      v59 = v62;
      v57 = v60;
      if (!v22(v21, UpTimeNanoseconds, &v44, v33))
      {
        FigCFDictionarySetInt64();
        FigCFDictionarySetInt64();
        FigCFDictionarySetInt64();
        FigCFDictionarySetInt64();
        FigCFDictionarySetInt64();
        FigCFDictionarySetInt64();
      }
    }
    v23 = *(_QWORD *)(v42 + 96);
    v24 = *(unsigned int (**)(uint64_t, uint64_t, __int128 *, _OWORD *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                            + 16)
                                                                                + 8);
    if (v24)
    {
      v48 = xmmword_1932FD0D0;
      v52 = v38;
      v53 = v39;
      v54 = v40;
      v55 = v41;
      v49 = v35;
      *(_QWORD *)&v44 = 5;
      *((_QWORD *)&v44 + 1) = v5;
      v45 = 60000000000;
      v46 = v6;
      v50 = v36;
      v51 = v37;
      v47 = v7;
      v56 = 9;
      v58 = v61;
      v59 = v62;
      v57 = v60;
      if (!v24(v23, UpTimeNanoseconds, &v44, v33))
      {
        FigCFDictionarySetInt64();
        FigCFDictionarySetInt64();
        FigCFDictionarySetInt64();
      }
    }
    v25 = *(_QWORD *)(v42 + 96);
    v26 = *(unsigned int (**)(uint64_t, uint64_t, __int128 *, _OWORD *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                            + 16)
                                                                                + 8);
    if (v26)
    {
      v44 = xmmword_1932FC870;
      v48 = xmmword_1932FD0D0;
      v52 = v38;
      v53 = v39;
      v54 = v40;
      v55 = v41;
      v49 = v35;
      v45 = 60000000000;
      v46 = v6;
      v50 = v36;
      v51 = v37;
      v47 = v7;
      v56 = 9;
      v58 = v61;
      v59 = v62;
      v57 = v60;
      if (!v26(v25, UpTimeNanoseconds, &v44, v33))
        FigCFDictionarySetInt64();
    }
    v27 = *(_QWORD *)(v42 + 96);
    v28 = *(unsigned int (**)(uint64_t, uint64_t, __int128 *, _OWORD *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                            + 16)
                                                                                + 8);
    if (v28)
    {
      v44 = xmmword_1932FC870;
      v48 = xmmword_1932FD0D0;
      v52 = v38;
      v53 = v39;
      v54 = v40;
      v55 = v41;
      v49 = v35;
      v45 = 60000000000;
      v46 = v6;
      v50 = v36;
      v51 = v37;
      v47 = v7;
      v56 = 2;
      v58 = v61;
      v59 = v62;
      v57 = v60;
      if (!v28(v27, UpTimeNanoseconds, &v44, v33))
        FigCFDictionarySetDouble();
    }
    v29 = *(_QWORD *)(v42 + 96);
    v30 = *(unsigned int (**)(uint64_t, uint64_t, __int128 *, _OWORD *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                            + 16)
                                                                                + 8);
    if (v30)
    {
      v44 = xmmword_1932FD120;
      v48 = xmmword_1932FD0D0;
      v52 = v38;
      v53 = v39;
      v54 = v40;
      v55 = v41;
      v49 = v35;
      v45 = 60000000000;
      v46 = v6;
      v50 = v36;
      v51 = v37;
      v47 = v7;
      v56 = 2;
      v58 = v61;
      v59 = v62;
      v57 = v60;
      if (!v30(v29, UpTimeNanoseconds, &v44, v33))
        FigCFDictionarySetDouble();
    }
    FigNetworkInterfaceReporterGetPredictedWirelessThroughput();
    SInt64 = (const void *)FigCFNumberCreateSInt64();
    CFDictionarySetValue(a2, CFSTR("PATH_bw"), SInt64);
    segPumpUnlockAndSendAllPendingNotifications();
    if (SInt64)
      CFRelease(SInt64);
  }
  if (cf)
    CFRelease(cf);
  return 0;
}

uint64_t segPumpStreamSetReadAheadConnectionCountMax(uint64_t a1, int64_t count)
{
  int64_t v4;
  void *v5;
  void *v6;
  void *v7;

  if (count > 0)
  {
    v4 = *(_QWORD *)(a1 + 776);
    if (v4 >= count)
      return 0;
    v5 = *(void **)(a1 + 768);
    v6 = malloc_type_calloc(count, 8uLL, 0x2004093837F09uLL);
    if (v6)
    {
      v7 = v6;
      memcpy(v6, v5, 8 * v4);
      *(_QWORD *)(a1 + 768) = v7;
      *(_QWORD *)(a1 + 776) = count;
      free(v5);
      return 0;
    }
  }
  return FigSignalErrorAt();
}

uint64_t segPumpClientHasEnough(const void *a1, unsigned int a2, int a3)
{
  uint64_t DerivedStorage;
  CFIndex v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v11;
  NSObject *v12;
  double v14;
  double v15[25];

  v15[23] = *(double *)MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v14 = 0.0;
  v15[0] = 0.0;
  v7 = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if (!(_DWORD)v7)
  {
    v8 = a2;
    v9 = *(_QWORD *)(DerivedStorage + 16 * a2 + 384);
    *(_BYTE *)(v9 + 870) = a3 == 0;
    if (!*(_BYTE *)(v9 + 869))
    {
      *(_BYTE *)(v9 + 869) = 1;
      if (dword_1EE2A31E8)
      {
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
      }
    }
    if (!a3)
    {
      *(_BYTE *)(v9 + 400) = 0;
      FigHTTPStopAndReleaseTimer((dispatch_object_t *)(v9 + 392));
    }
    v11 = *(_QWORD *)(DerivedStorage + 16 * v8 + 392);
    if (segPumpGetDeliveredTimeStamp(v11, v15))
    {
      if (segPumpGetDeliveredTimeStamp(v9, &v14))
      {
        if (v15[0] - v14 > 2.22044605e-16 && !*(_BYTE *)(v11 + 869))
        {
          *(_BYTE *)(v11 + 869) = 1;
          if (dword_1EE2A31E8)
          {
            v12 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
        }
      }
    }
  }
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v7);
}

uint64_t segPumpClientNeedsMore(const void *a1, unsigned int a2)
{
  uint64_t DerivedStorage;
  CFIndex v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double v10;
  double v11;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v10 = 0.0;
  v11 = 0.0;
  v5 = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if ((_DWORD)v5
    || (v6 = *(_QWORD *)(DerivedStorage + 16 * a2 + 384),
        v5 = segPumpStreamNeedsMore(a1, DerivedStorage, v6),
        (_DWORD)v5))
  {
    v8 = v5;
  }
  else
  {
    v7 = *(_QWORD *)(DerivedStorage + 16 * a2 + 392);
    if (segPumpGetDeliveredTimeStamp(v7, &v11)
      && segPumpGetDeliveredTimeStamp(v6, &v10)
      && v10 - v11 > 2.22044605e-16)
    {
      segPumpStreamNeedsMore(a1, DerivedStorage, v7);
    }
    v8 = 0;
  }
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v8);
}

uint64_t segPumpSetCurrentTime(const void *a1, CMTime *a2, uint64_t a3, int a4, int a5, CMTime *a6, CMTime *a7, CMTime *a8, int *a9)
{
  uint64_t DerivedStorage;
  CMTimeFlags flags;
  CFIndex v18;
  _BYTE *v19;
  double MinTime;
  double MaxTime;
  double v22;
  const void *v23;
  uint64_t v24;
  Float64 Seconds;
  uint64_t v26;
  uint64_t v27;
  const __CFArray *MediaSegmentSpecifiers;
  CMTimeEpoch v29;
  _BOOL4 v30;
  double v31;
  double v32;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v34;
  const __CFArray *v35;
  uint64_t v36;
  char v37;
  char v38;
  uint64_t v39;
  uint64_t v40;
  const __CFArray *v41;
  _BOOL4 v42;
  uint64_t v43;
  uint64_t LastValue;
  int v45;
  BOOL v46;
  uint64_t i;
  uint64_t v48;
  uint64_t v49;
  const __CFArray *v50;
  BOOL v51;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t j;
  uint64_t v57;
  CFDateRef v58;
  double v59;
  int v60;
  double v61;
  double v62;
  uint64_t v63;
  uint64_t v64;
  double v65;
  uint64_t v66;
  const __CFArray *v67;
  int v68;
  double v69;
  NSObject *v70;
  unsigned int v71;
  unsigned int v72;
  const __CFString *v73;
  uint64_t v74;
  uint64_t v75;
  double Current;
  uint64_t UpTimeNanoseconds;
  NSObject *v78;
  unsigned int v79;
  unsigned int v80;
  const __CFString *v81;
  uint64_t v82;
  int v83;
  NSObject *v84;
  unsigned int v85;
  unsigned int v86;
  const __CFString *v87;
  uint64_t v88;
  double v89;
  CFTypeRef v90;
  uint64_t MediaForAllStreams;
  uint64_t v92;
  const __CFArray *v93;
  double v94;
  uint64_t v95;
  CFIndex v96;
  double v97;
  const __CFArray *Count;
  const __CFArray *v99;
  const void *ValueAtIndex;
  const void *v101;
  NSObject *v102;
  unsigned int v103;
  unsigned int v104;
  const __CFString *v105;
  uint64_t v106;
  double v107;
  int v108;
  const void *v109;
  float v110;
  uint64_t v111;
  double v112;
  BOOL v113;
  double TimeInSeconds;
  double v116;
  double v117;
  double v118;
  CMTime *v119;
  CMTime *v120;
  int v121;
  int v122;
  const void *v123;
  __int128 v125;
  int v126;
  CMTime v127;
  os_log_type_t type;
  unsigned int v129;
  CMTime rhs;
  CMTime lhs;
  uint64_t v132;
  __int16 v133;
  double v134;
  __int16 v135;
  double v136;
  __int16 v137;
  double v138;
  CMTime time;
  uint64_t v140;

  v140 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  flags = a2->flags;
  v123 = a1;
  v18 = segPumpAPILockAndEnsureAPIStatus(a1, 1);
  if ((_DWORD)v18)
    goto LABEL_189;
  if (a2->value < 0)
  {
    v18 = FigSignalErrorAt();
LABEL_189:
    MediaForAllStreams = v18;
    v23 = v123;
    return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(v23, MediaForAllStreams);
  }
  v19 = (_BYTE *)(DerivedStorage + 8002);
  MinTime = segPumpGetMinTime((_QWORD *)DerivedStorage);
  MaxTime = segPumpGetMaxTime((_QWORD *)DerivedStorage);
  v22 = segPumpGetMinimumPrebufferReservation(DerivedStorage, 0) + *(double *)(DerivedStorage + 7960);
  v126 = flags & 5;
  v23 = a1;
  if (v126 == 5 && !*v19)
  {
    LODWORD(lhs.value) = 0;
    segPumpCanContinueWithoutGap(DerivedStorage, (int *)&lhs);
    if (LODWORD(lhs.value) == 7 && (*(_BYTE *)(a3 + 12) & 1) != 0)
    {
      time = *(CMTime *)a3;
      if (CMTimeGetSeconds(&time) >= MaxTime - v22)
      {
        MediaForAllStreams = 4294950458;
        return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(v23, MediaForAllStreams);
      }
    }
  }
  if (a5)
  {
    v24 = *(_QWORD *)(DerivedStorage + 384);
    if (!*(_BYTE *)(v24 + 872))
    {
      time = *a8;
      Seconds = CMTimeGetSeconds(&time);
      CMTimeMakeWithSeconds(&rhs, Seconds * 1.5, 1000);
      lhs = *a2;
      CMTimeSubtract(&time, &lhs, &rhs);
      *a2 = time;
      v24 = *(_QWORD *)(DerivedStorage + 384);
    }
    v26 = *(_QWORD *)(v24 + 56);
    v27 = a3;
    if (v26)
    {
      MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v26);
      if (MediaSegmentSpecifiers)
      {
        if (CFArrayGetCount(MediaSegmentSpecifiers) >= 1)
        {
          *(_BYTE *)(DerivedStorage + 8713) = 0;
          *(_BYTE *)(DerivedStorage + 8768) = 0;
        }
      }
    }
    v121 = 1;
  }
  else
  {
    if ((a6->flags & 0x1D) != 1)
      goto LABEL_21;
    if ((a7->flags & 0x1D) != 1)
      goto LABEL_21;
    time = *a6;
    v125 = *MEMORY[0x1E0CA2E68];
    *(_OWORD *)&lhs.value = *MEMORY[0x1E0CA2E68];
    v29 = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
    lhs.epoch = v29;
    if (CMTimeCompare(&time, &lhs)
      || (time = *a7, *(_OWORD *)&lhs.value = v125, lhs.epoch = v29, CMTimeCompare(&time, &lhs)))
    {
      v121 = 0;
    }
    else
    {
LABEL_21:
      v121 = 1;
    }
    v27 = a3;
  }
  v120 = a6;
  if ((*(_BYTE *)(v27 + 12) & 1) != 0)
  {
    time = *a2;
    lhs = *(CMTime *)v27;
    v30 = CMTimeCompare(&time, &lhs) > 0;
  }
  else
  {
    v30 = 0;
  }
  time = *a2;
  v31 = CMTimeGetSeconds(&time);
  time = *(CMTime *)v27;
  v32 = CMTimeGetSeconds(&time);
  if (dword_1EE2A31E8)
  {
    v129 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  if (*v19)
  {
    if (v31 > MaxTime
      && (v34 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 384) + 56)) != 0
      && (v35 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v34)) != 0
      && CFArrayGetCount(v35) >= 1
      || v31 == MaxTime)
    {
      v31 = MaxTime + -0.001;
    }
  }
  v36 = 0;
  v37 = 1;
  do
  {
    v38 = v37;
    v39 = *(_QWORD *)(DerivedStorage + 16 * v36 + 384);
    v40 = *(_QWORD *)(v39 + 56);
    if (v40)
    {
      v41 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v40);
      if (v41)
      {
        if (CFArrayGetCount(v41) >= 1)
        {
          if (*v19)
            v42 = v30;
          else
            v42 = 0;
          if (v42)
          {
            v43 = *(_QWORD *)(v39 + 56);
            if (v43)
            {
              FigMediaPlaylistGetMediaSegmentSpecifiers(v43);
              LastValue = FigCFArrayGetLastValue();
              if (!LastValue || MaxTime - FigMediaSegmentSpecifierGetTimeInSeconds(LastValue) <= v32)
              {
LABEL_184:
                MediaForAllStreams = FigSignalErrorAt();
                return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(v23, MediaForAllStreams);
              }
            }
          }
          if (v31 < MinTime)
            v31 = MinTime;
        }
      }
    }
    v37 = 0;
    v36 = 1;
  }
  while ((v38 & 1) != 0);
  v45 = *(_BYTE *)(a3 + 12) & (v31 > v32);
  v46 = v31 >= MinTime && v31 <= MaxTime;
  for (i = 384; i != 432; i += 16)
  {
    v48 = *(_QWORD *)(DerivedStorage + i);
    if (*(_QWORD *)(v48 + 16))
    {
      v49 = *(_QWORD *)(v48 + 56);
      if (v49)
      {
        v50 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v49);
        if (v50)
        {
          if (CFArrayGetCount(v50) >= 1)
          {
            v51 = v126 != 5 && *v19 == 0;
            if (v51 && !v46)
              goto LABEL_184;
          }
        }
      }
    }
  }
  *(_DWORD *)(DerivedStorage + 8680) = a4;
  segPumpClearSuggestedAlternate((_QWORD *)DerivedStorage);
  v53 = *(_QWORD *)(DerivedStorage + 296);
  if (v53)
    FigStreamingCacheHintPlaybackTime(v53, v31);
  segPumpClearStatistics(DerivedStorage);
  segPumpCancelAllReadAheadAndResetData(DerivedStorage);
  v54 = 384;
  v55 = v126;
  do
  {
    segPumpStreamCancelPreloadReadAndResetData(DerivedStorage, *(_QWORD *)(DerivedStorage + v54));
    v54 += 16;
  }
  while (v54 != 432);
  v119 = a7;
  for (j = 384; j != 432; j += 16)
    segPumpStreamCancelPreloadMapReadAndResetData(DerivedStorage, *(_QWORD *)(DerivedStorage + j));
  v57 = 0;
  v58 = 0;
  if (MaxTime - v22 >= 0.0)
    v59 = MaxTime - v22;
  else
    v59 = 0.0;
  if (v126 == 5)
    v60 = 0;
  else
    v60 = v45;
  v122 = v121 & v60;
  v61 = 1000000000.0;
  v62 = -1000000000.0;
  while (1)
  {
    v63 = DerivedStorage + 16 * v57;
    v64 = *(_QWORD *)(v63 + 384);
    ++*(_QWORD *)(v64 + 880);
    segPumpCancelMediaFileReadAndResetData(DerivedStorage, v64, 1, 0);
    segPumpSetStreamDiscontinuityDomain(DerivedStorage, (_QWORD *)v64, 0);
    if (!*(_QWORD *)(*(_QWORD *)(v63 + 384) + 16))
      goto LABEL_161;
    if (v58)
      CFRelease(v58);
    v66 = *(_QWORD *)(v64 + 56);
    if (!v66
      || (v67 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v66)) == 0
      || CFArrayGetCount(v67) < 1)
    {
LABEL_110:
      v58 = 0;
      v68 = 1;
LABEL_111:
      v69 = v31;
      goto LABEL_112;
    }
    v58 = 0;
    v68 = 1;
    if (*v19)
      goto LABEL_111;
    v69 = v31;
    if (v31 <= v59)
      goto LABEL_112;
    if (v55 != 5 && dword_1EE2A31E8)
    {
      v129 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v70 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      v71 = v129;
      if (os_log_type_enabled(v70, type))
        v72 = v71;
      else
        v72 = v71 & 0xFFFFFFFE;
      if (v72)
      {
        v73 = *(const __CFString **)(DerivedStorage + 8760);
        if (!v73)
          v73 = &stru_1E2FD85F8;
        v74 = *(_QWORD *)v64;
        LODWORD(lhs.value) = 136316418;
        *(CMTimeValue *)((char *)&lhs.value + 4) = (CMTimeValue)"segPumpSetCurrentTime";
        LOWORD(lhs.flags) = 2114;
        *(_QWORD *)((char *)&lhs.flags + 2) = v73;
        HIWORD(lhs.epoch) = 2048;
        v132 = v74;
        v133 = 2048;
        v134 = v31;
        v135 = 2048;
        v136 = MaxTime;
        v137 = 2048;
        v138 = v22;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    v75 = *(_QWORD *)(v64 + 1048) + 1000000000 * *(unsigned int *)(DerivedStorage + 8);
    if (FigGetUpTimeNanoseconds() >= v75 || *(_BYTE *)(v64 + 1168))
    {
      if (v55 == 5)
      {
        v68 = 0;
        v58 = 0;
      }
      else
      {
        Current = CFAbsoluteTimeGetCurrent();
        UpTimeNanoseconds = FigGetUpTimeNanoseconds();
        v58 = CFDateCreate(*(CFAllocatorRef *)(DerivedStorage + 56), v31+ Current+ (double)(UpTimeNanoseconds - *(_QWORD *)(v64 + 1056)) / v62- *(double *)(v64 + 96)- *(double *)(v64 + 88));
        v68 = 0;
      }
      goto LABEL_111;
    }
    if (v55 != 5)
      goto LABEL_110;
    if (dword_1EE2A31E8)
    {
      v129 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v78 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      v79 = v129;
      if (os_log_type_enabled(v78, type))
        v80 = v79;
      else
        v80 = v79 & 0xFFFFFFFE;
      if (v80)
      {
        v81 = *(const __CFString **)(DerivedStorage + 8760);
        if (!v81)
          v81 = &stru_1E2FD85F8;
        v82 = *(_QWORD *)v64;
        LODWORD(lhs.value) = 136316162;
        *(CMTimeValue *)((char *)&lhs.value + 4) = (CMTimeValue)"segPumpSetCurrentTime";
        LOWORD(lhs.flags) = 2114;
        *(_QWORD *)((char *)&lhs.flags + 2) = v81;
        HIWORD(lhs.epoch) = 2048;
        v132 = v82;
        v133 = 2048;
        v134 = v31;
        v135 = 2048;
        v136 = v59;
        _os_log_send_and_compose_impl();
      }
      v68 = 1;
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      v58 = 0;
      v69 = v59;
    }
    else
    {
      v58 = 0;
      v68 = 1;
      v69 = v59;
    }
LABEL_112:
    *(_BYTE *)(v64 + 857) = 1;
    if (!*(_BYTE *)(DerivedStorage + 8712))
    {
      v83 = *(_DWORD *)(v64 + 72) + 1;
      *(_DWORD *)(v64 + 72) = v83;
      a9[v57] = v83;
    }
    *(_BYTE *)(v64 + 861) = 0;
    *(_WORD *)(v64 + 401) = 256;
    if (v55 == 5 && *(_BYTE *)(v64 + 866))
    {
      if (dword_1EE2A31E8)
      {
        v129 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        v84 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        v85 = v129;
        if (os_log_type_enabled(v84, type))
          v86 = v85;
        else
          v86 = v85 & 0xFFFFFFFE;
        if (v86)
        {
          if (*(_QWORD *)(DerivedStorage + 8760))
            v87 = *(const __CFString **)(DerivedStorage + 8760);
          else
            v87 = &stru_1E2FD85F8;
          v88 = *(_QWORD *)v64;
          v89 = (double)(FigGetUpTimeNanoseconds() - *(_QWORD *)(v64 + 1056));
          LODWORD(lhs.value) = 136315906;
          *(CMTimeValue *)((char *)&lhs.value + 4) = (CMTimeValue)"segPumpSetCurrentTime";
          LOWORD(lhs.flags) = 2114;
          *(_QWORD *)((char *)&lhs.flags + 2) = v87;
          HIWORD(lhs.epoch) = 2048;
          v132 = v88;
          v23 = v123;
          v133 = 2048;
          v134 = v89 / v61;
          _os_log_send_and_compose_impl();
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        v55 = v126;
      }
      goto LABEL_158;
    }
    if (v68 && !*(_BYTE *)(v64 + 1169))
    {
      v92 = *(_QWORD *)(v64 + 56);
      if (v92
        && (v93 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v92)) != 0
        && CFArrayGetCount(v93) > 0)
      {
        v118 = v61;
        v94 = v62;
        *(_QWORD *)(v64 + 120) = 0xBFF0000000000000;
        v95 = *(_QWORD *)(v64 + 56);
        segPumpResetAllMediaFilePrivateDataForStream(v64);
        v96 = 0;
        v97 = *(double *)(v64 + 88);
        while (1)
        {
          Count = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v95);
          if (Count)
            Count = (const __CFArray *)CFArrayGetCount(Count);
          if (v96 >= (uint64_t)Count)
            break;
          v99 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v95);
          ValueAtIndex = CFArrayGetValueAtIndex(v99, v96);
          if (!*((_BYTE *)segPumpGetMediaFilePrivateData(ValueAtIndex) + 96))
          {
            v65 = v97 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
            if (v65 > v69 && (!v122 || *(_QWORD *)v64 != *(_QWORD *)(DerivedStorage + 8416) || v97 >= v32))
            {
              if ((v121 & 1) == 0)
              {
                time = *v120;
                v117 = CMTimeGetSeconds(&time);
                if (FigMediaSegmentSpecifierGetNextSegment((uint64_t)ValueAtIndex))
                {
                  v116 = v22;
                  TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
                  time = *v119;
                  v112 = CMTimeGetSeconds(&time);
                  v65 = v97 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
                  if (v97 < v117 || v112 < v65)
                  {
                    v113 = v112 < v65;
                    v22 = v116;
                    if (v113)
                      break;
                  }
                  else
                  {
                    v65 = v69 - v97;
                    v22 = v116;
                    if (v69 - v97 <= v97 + TimeInSeconds - v69)
                      break;
                  }
                  segPumpSetDeliveryStatusForMediaFileAndParts(ValueAtIndex, 1);
                  v65 = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
                  v97 = v97 + v65;
                }
              }
              break;
            }
            segPumpSetDeliveryStatusForMediaFileAndParts(ValueAtIndex, 1);
            v97 = v97 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
          }
          ++v96;
        }
        *(double *)(v64 + 104) = v97;
        if (!*(_BYTE *)(DerivedStorage + 8712))
        {
          *(_BYTE *)(v64 + 1169) = 0;
          v62 = v94;
          v61 = v118;
LABEL_159:
          v109 = *(const void **)(v64 + 288);
          if (v109)
          {
            CFRelease(v109);
            *(_QWORD *)(v64 + 288) = 0;
            *(_QWORD *)(v64 + 320) = -1;
          }
          goto LABEL_161;
        }
        v110 = *(float *)(DerivedStorage + 8696);
        v111 = FigGetUpTimeNanoseconds();
        CMTimeMakeWithSeconds(&v127, v69, 1000);
        time = *(CMTime *)a3;
        MediaForAllStreams = segPumpStepNextFrame(v23, &time, v111, &v127, 1, a9, v110);
        v62 = v94;
        v61 = v118;
        if ((_DWORD)MediaForAllStreams)
          break;
      }
      else
      {
        v65 = v69 - *(double *)(v64 + 88);
        *(double *)(v64 + 120) = v65;
        *(_QWORD *)(v64 + 128) = 0xBFF0000000000000;
        *(_QWORD *)(v64 + 920) = 0;
        v101 = *(const void **)(v64 + 232);
        if (v101)
        {
          CFRelease(v101);
          *(_QWORD *)(v64 + 232) = 0;
        }
        if (dword_1EE2A31E8)
        {
          v129 = 0;
          type = OS_LOG_TYPE_DEFAULT;
          v102 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          v103 = v129;
          if (os_log_type_enabled(v102, type))
            v104 = v103;
          else
            v104 = v103 & 0xFFFFFFFE;
          if (v104)
          {
            v105 = *(const __CFString **)(DerivedStorage + 8760);
            if (!v105)
              v105 = &stru_1E2FD85F8;
            v106 = *(_QWORD *)v64;
            v107 = *(double *)(v64 + 120);
            LODWORD(lhs.value) = 136316162;
            *(CMTimeValue *)((char *)&lhs.value + 4) = (CMTimeValue)"segPumpSetCurrentTime";
            LOWORD(lhs.flags) = 2114;
            *(_QWORD *)((char *)&lhs.flags + 2) = v105;
            HIWORD(lhs.epoch) = 2048;
            v132 = v106;
            v133 = 2048;
            v134 = v107;
            v135 = 1024;
            LODWORD(v136) = v57;
            _os_log_send_and_compose_impl();
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
      }
      goto LABEL_158;
    }
    v90 = v58 ? CFRetain(v58) : 0;
    *(_QWORD *)(v64 + 240) = v90;
    *(_BYTE *)(v64 + 866) = 1;
    segPumpResetConnection(DerivedStorage, v64 + 408);
    *(_BYTE *)(v64 + 859) = 0;
    segPumpStreamUpdateIndexExpectedArrival(DerivedStorage, v64);
    segPumpResetAllMediaFilePrivateDataForStream(v64);
    MediaForAllStreams = segPumpSendIndexFileRequest((uint64_t)v23, DerivedStorage, v64);
    if ((_DWORD)MediaForAllStreams)
      break;
LABEL_158:
    v108 = *(unsigned __int8 *)(DerivedStorage + 8712);
    *(_BYTE *)(v64 + 1169) = 0;
    if (!v108)
      goto LABEL_159;
LABEL_161:
    if (++v57 == 3)
    {
      if (*(_BYTE *)(DerivedStorage + 8712))
      {
        MediaForAllStreams = 0;
        if (!v58)
          return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(v23, MediaForAllStreams);
      }
      else
      {
        MediaForAllStreams = segPumpDeliverNextMediaForAllStreams(v23, DerivedStorage, v65);
        if (!v58)
          return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(v23, MediaForAllStreams);
      }
      goto LABEL_183;
    }
  }
  *(_BYTE *)(v64 + 857) = 0;
  if (!v58)
    return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(v23, MediaForAllStreams);
LABEL_183:
  CFRelease(v58);
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(v23, MediaForAllStreams);
}

uint64_t segPumpSetCurrentAlternate(const void *a1, const void *a2, const __CFArray *a3, uint64_t a4, int a5, unsigned int a6, uint64_t a7, CMTime *a8, CMTime *a9, _DWORD *a10, unsigned int *a11, uint64_t a12)
{
  uint64_t DerivedStorage;
  int v18;
  CFIndex v19;
  uint64_t v20;
  uint64_t i;
  uint64_t v22;
  uint64_t v23;
  const void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const void *v28;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  CMTimeValue v30;
  const void *v31;
  const void *v32;
  uint64_t v33;
  unsigned int *v34;
  uint64_t j;
  uint64_t v36;
  uint64_t v37;
  uint64_t k;
  uint64_t v39;
  uint64_t **v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  NSObject *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int LongestContiguousMediaStreamInCacheAtTime;
  const void *value;
  _QWORD *AlternateEntryFromURLForCacheLookup;
  NSObject *v51;
  unsigned int v52;
  unsigned int v53;
  const __CFString *v54;
  NSObject *v55;
  unsigned int v56;
  unsigned int v57;
  NSObject *v58;
  unsigned int v59;
  unsigned int v60;
  const __CFString *v61;
  int HasAudio;
  int HasVideo;
  BOOL v64;
  int v65;
  NSObject *v66;
  unsigned int v67;
  unsigned int v68;
  const __CFString *v69;
  int HDCPLevel;
  int v71;
  const void *PlaylistAlternateURL;
  CFTypeRef v73;
  __int128 v74;
  CMTimeValue v75;
  const void *v76;
  const void *v77;
  const void *v78;
  CFIndex v79;
  CFIndex v80;
  const void *v81;
  CFIndex v82;
  const __CFDictionary *v83;
  BOOL v84;
  const void *v86;
  const void *v87;
  CFTypeID v88;
  CFTypeID TypeID;
  BOOL v90;
  const void *v91;
  int v92;
  const void *v93;
  uint64_t v94;
  CMTimeValue v95;
  CMTimeValue v96;
  unsigned int v97;
  BOOL v98;
  int v99;
  uint64_t v100;
  uint64_t v101;
  void (*v102)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v103;
  _BOOL4 v104;
  unint64_t v105;
  _BOOL4 v106;
  unint64_t v107;
  unint64_t v108;
  int v109;
  int v110;
  _BYTE *v111;
  uint64_t v112;
  BOOL v113;
  uint64_t v114;
  uint64_t v115;
  int IsFullyCached;
  int v117;
  uint64_t v118;
  _BOOL4 v119;
  NSObject *v120;
  unsigned int v121;
  unsigned int v122;
  const __CFString *v123;
  Float64 Seconds;
  double v125;
  const char *v126;
  const char *v127;
  int v128;
  char v129;
  char v130;
  uint64_t *v131;
  int v132;
  int v133;
  int v134;
  int v135;
  _BOOL4 v136;
  const __CFArray *v137;
  uint64_t UpTimeNanoseconds;
  uint64_t v139;
  unsigned int v140;
  NSObject *v141;
  unsigned int v142;
  unsigned int v143;
  const __CFString *v144;
  uint64_t v145;
  const __CFString *v146;
  uint64_t m;
  uint64_t n;
  const void *v149;
  uint64_t ii;
  uint64_t v151;
  BOOL v152;
  const void *v155;
  uint64_t v156;
  void (*v157)(uint64_t, const __CFString *, const __CFArray *);
  _BOOL4 v158;
  uint64_t valid;
  uint64_t v160;
  uint64_t v161;
  const __CFArray *v162;
  uint64_t v163;
  uint64_t *v164;
  int v165;
  uint8x8_t v166;
  uint64_t jj;
  uint64_t v168;
  double v169;
  uint64_t v170;
  double v171;
  CFIndex kk;
  const __CFArray *Count;
  const __CFArray *v174;
  const void *ValueAtIndex;
  double v176;
  uint64_t v177;
  uint64_t v178;
  CMTime *v179;
  NSObject *v180;
  unsigned int v181;
  unsigned int v182;
  const __CFString *v183;
  uint64_t v184;
  uint64_t v185;
  CMTime *v186;
  uint64_t v187;
  uint64_t v188;
  NSObject *v189;
  int v190;
  unsigned int v191;
  const __CFString *v192;
  uint64_t v193;
  int v194;
  int v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  NSObject *v202;
  unsigned int v203;
  unsigned int v204;
  const __CFString *v205;
  uint64_t v206;
  const __CFString *v207;
  NSObject *v208;
  unsigned int v209;
  unsigned int v210;
  const __CFString *v211;
  NSObject *v212;
  unsigned int v213;
  unsigned int v214;
  const __CFString *v215;
  uint64_t v216;
  CMTime *v217;
  __int128 v218;
  unsigned __int8 v219;
  uint64_t *v220;
  uint64_t *v221;
  NSObject *v222;
  unsigned int v223;
  unsigned int v224;
  const __CFString *v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  const void *v229;
  const void *v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t *v233;
  int v234;
  const __CFArray *MediaSegmentSpecifiers;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t *v240;
  uint64_t v241;
  NSObject *v243;
  unsigned int v244;
  unsigned int v245;
  const __CFString *v246;
  uint64_t v247;
  const char *v248;
  uint64_t v249;
  const void *v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  _BOOL4 v255;
  int v256;
  int v257;
  int v258;
  const void *URLForCacheLookup;
  const void *StableStreamIdentifier;
  BOOL v261;
  BOOL v262;
  BOOL v263;
  const void *v264;
  const void *v265;
  const void *v266;
  const void *v267;
  int PeakBitRate;
  int v269;
  _BYTE *v270;
  _BOOL4 v271;
  _BOOL4 v272;
  int v273;
  uint64_t *v274;
  CMTime *v275;
  _BOOL4 v276;
  CMTimeValue v277;
  int v278;
  CFTypeRef cf2;
  CMTimeValue v280;
  int v281;
  int v282;
  uint64_t v283;
  CMTime *key;
  const void *v285;
  unsigned int v286;
  uint64_t *v287;
  unsigned int v289;
  int IsIFrameOnly;
  os_log_type_t v292;
  CMTime v293;
  CMTime v294;
  CFTypeRef v295;
  os_log_type_t type[8];
  CMTime cf;
  _BYTE v298[14];
  __int16 v299;
  double v300;
  __int16 v301;
  int v302;
  __int16 v303;
  const char *v304;
  __int16 v305;
  const char *v306;
  CMTime time;
  uint64_t v308;

  v308 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v269 = segPumpStreamBitRateRequiredForStream(DerivedStorage, *(_QWORD **)(DerivedStorage + 384));
  v295 = 0;
  v286 = a6;
  v18 = (*(_QWORD *)(DerivedStorage + 8144) != 0) & (a6 >> 2);
  v285 = a1;
  v19 = segPumpAPILockAndEnsureAPIStatus(a1, 1);
  if ((_DWORD)v19)
    goto LABEL_120;
  if (!*(_QWORD *)(DerivedStorage + 8096))
    goto LABEL_119;
  v274 = (uint64_t *)(DerivedStorage + 384);
  if (*(_BYTE *)(*(_QWORD *)(DerivedStorage + 384) + 856))
  {
    v20 = MEMORY[0x1E0CA2E18];
    *(_OWORD *)a7 = *MEMORY[0x1E0CA2E18];
    *(_QWORD *)(a7 + 16) = *(_QWORD *)(v20 + 16);
  }
  if ((a6 & 8) != 0 && *(_QWORD *)(DerivedStorage + 7680) && FigCFEqual())
  {
    for (i = 0; i != 48; i += 16)
    {
      v22 = DerivedStorage + i;
      v23 = *(_QWORD *)(DerivedStorage + i + 392);
      if (*(_QWORD *)(v23 + 1192))
      {
        nw_activity_complete_with_reason();
        v24 = *(const void **)(v23 + 1192);
        if (v24)
        {
          CFRelease(v24);
          *(_QWORD *)(v23 + 1192) = 0;
        }
      }
      if (*(_QWORD *)(v23 + 16))
      {
        segPumpStopConcurrentStream(DerivedStorage, *(_QWORD *)(DerivedStorage + i + 384));
        *(_WORD *)(v23 + 864) = 256;
        v25 = *(_QWORD *)(DerivedStorage + i + 384);
        v26 = *(_QWORD *)(v22 + 392);
        *(_QWORD *)(DerivedStorage + i + 384) = v26;
        *(_QWORD *)(v22 + 392) = v25;
        if (!*(_QWORD *)(v26 + 1176))
        {
          v27 = *(_QWORD *)(v25 + 1176);
          if (v27)
          {
            *(_QWORD *)(v26 + 1176) = v27;
            *(_QWORD *)(*(_QWORD *)(v22 + 392) + 1176) = 0;
          }
        }
        if (*(_QWORD *)(v23 + 256) && !*(_QWORD *)(*(_QWORD *)(v23 + 696) + 8))
        {
          if (*(_QWORD *)(v23 + 264))
            v28 = *(const void **)(v23 + 264);
          else
            v28 = *(const void **)(v23 + 256);
          if (dword_1EE2A31E8)
          {
            LODWORD(v293.value) = 0;
            type[0] = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          segPumpStreamProceedAfterMediaAndKeyArrival((uint64_t)a1, DerivedStorage, v23, v28, 1, 1);
        }
      }
    }
    segPumpClearStatistics(DerivedStorage);
    segPumpUpdateCurrentAlternate(DerivedStorage, *(_QWORD *)(DerivedStorage + 7680));
    v289 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    *(_QWORD *)(DerivedStorage + 8416) = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 384) + 16) == 0;
    *(_QWORD *)(DerivedStorage + 7680) = 0;
    v34 = a11;
    if (a11)
      goto LABEL_561;
    goto LABEL_562;
  }
  if (*(_QWORD *)(DerivedStorage + 7680))
  {
    for (j = 392; j != 440; j += 16)
    {
      v36 = *(_QWORD *)(DerivedStorage + j);
      if (*(_QWORD *)(v36 + 16))
      {
        segPumpStopConcurrentStream(DerivedStorage, *(_QWORD *)(DerivedStorage + j));
        *(_QWORD *)(v36 + 936) = -1;
      }
    }
    *(_QWORD *)(DerivedStorage + 7680) = 0;
  }
  v275 = a8;
  v283 = a7;
  v37 = DerivedStorage + 8096;
  v278 = v18;
  if ((v18 & 1) == 0)
  {
    for (k = 0; k != 48; k += 16)
      *(_QWORD *)(*(_QWORD *)(DerivedStorage + 384 + k) + 136) = -1;
    if ((a6 & 0x20) != 0 && *(_QWORD *)(DerivedStorage + 8248))
    {
      v39 = 0;
      v40 = (uint64_t **)(DerivedStorage + 384);
      do
      {
        v41 = *v40;
        v42 = **v40;
        if (*(_BYTE *)(DerivedStorage + 40 * v42 + 8280))
        {
          v43 = DerivedStorage + 40 * v42;
          *(_OWORD *)(v41 + 17) = *(_OWORD *)(v43 + 8256);
          v41[19] = *(_QWORD *)(v43 + 8272);
          if (dword_1EE2A31E8)
          {
            LODWORD(v293.value) = 0;
            type[0] = OS_LOG_TYPE_DEFAULT;
            v44 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
        }
        ++v39;
        v40 += 2;
      }
      while (v39 != 3);
    }
  }
  if (!a2)
  {
    if (*(_QWORD *)(DerivedStorage + 8144))
    {
      v289 = 0;
      v30 = 0;
      v280 = 0;
      v32 = 0;
      v33 = 0;
      goto LABEL_49;
    }
    v47 = *(_QWORD *)(DerivedStorage + 296);
    v18 = v278;
    if (!v47)
      goto LABEL_64;
    time.value = 0;
    *(_QWORD *)type = 0;
    cf.value = 0;
    v293.value = 0;
    LongestContiguousMediaStreamInCacheAtTime = FigStreamingCacheGetLongestContiguousMediaStreamInCacheAtTime(v47, 0, &v293.value, (CFTypeRef *)&time, &cf, (double *)type, 0.0);
    value = (const void *)time.value;
    if (LongestContiguousMediaStreamInCacheAtTime)
    {
      AlternateEntryFromURLForCacheLookup = 0;
      if (time.value)
LABEL_59:
        CFRelease(value);
    }
    else
    {
      if (time.value)
      {
        AlternateEntryFromURLForCacheLookup = segPumpGetAlternateEntryFromURLForCacheLookup(DerivedStorage, (const void *)time.value, cf.value);
        value = (const void *)time.value;
        if (!time.value)
          goto LABEL_61;
        goto LABEL_59;
      }
      AlternateEntryFromURLForCacheLookup = 0;
    }
LABEL_61:
    if (cf.value)
      CFRelease((CFTypeRef)cf.value);
    if (AlternateEntryFromURLForCacheLookup)
    {
LABEL_100:
      v46 = AlternateEntryFromURLForCacheLookup[1];
      HasAudio = FigAlternateHasAudio(v46);
      HasVideo = FigAlternateHasVideo(AlternateEntryFromURLForCacheLookup[1]);
      if (HasAudio)
        v64 = HasVideo == 0;
      else
        v64 = 0;
      v65 = v64;
      a5 = v65;
      v37 = (uint64_t)AlternateEntryFromURLForCacheLookup;
      goto LABEL_107;
    }
LABEL_64:
    AlternateEntryFromURLForCacheLookup = *(_QWORD **)v37;
    if (*(_QWORD *)v37)
    {
      while (FigAlternateIsIFrameOnly(AlternateEntryFromURLForCacheLookup[1])
           || !FigAlternateHasValidCodecs(AlternateEntryFromURLForCacheLookup[1]))
      {
        AlternateEntryFromURLForCacheLookup = (_QWORD *)*AlternateEntryFromURLForCacheLookup;
        if (!AlternateEntryFromURLForCacheLookup)
          goto LABEL_68;
      }
    }
    else
    {
LABEL_68:
      AlternateEntryFromURLForCacheLookup = (_QWORD *)(DerivedStorage + 8096);
      do
      {
        AlternateEntryFromURLForCacheLookup = (_QWORD *)*AlternateEntryFromURLForCacheLookup;
        if (!AlternateEntryFromURLForCacheLookup)
        {
          AlternateEntryFromURLForCacheLookup = (_QWORD *)(DerivedStorage + 8096);
          do
          {
            AlternateEntryFromURLForCacheLookup = (_QWORD *)*AlternateEntryFromURLForCacheLookup;
            if (!AlternateEntryFromURLForCacheLookup)
            {
              LODWORD(v293.value) = 0;
              type[0] = OS_LOG_TYPE_DEFAULT;
              v58 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
              v59 = v293.value;
              if (os_log_type_enabled(v58, type[0]))
                v60 = v59;
              else
                v60 = v59 & 0xFFFFFFFE;
              if (v60)
              {
                v61 = &stru_1E2FD85F8;
                if (DerivedStorage && *(_QWORD *)(DerivedStorage + 8760))
                  v61 = *(const __CFString **)(DerivedStorage + 8760);
                LODWORD(cf.value) = 136315394;
                *(CMTimeValue *)((char *)&cf.value + 4) = (CMTimeValue)"segPumpGetFirstMatchingAlternateEntry";
                LOWORD(cf.flags) = 2114;
                *(_QWORD *)((char *)&cf.flags + 2) = v61;
                _os_log_send_and_compose_impl();
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose();
              AlternateEntryFromURLForCacheLookup = *(_QWORD **)v37;
              goto LABEL_100;
            }
          }
          while (FigAlternateIsIFrameOnly(AlternateEntryFromURLForCacheLookup[1]));
          LODWORD(v293.value) = 0;
          type[0] = OS_LOG_TYPE_DEFAULT;
          v55 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          v56 = v293.value;
          if (os_log_type_enabled(v55, type[0]))
            v57 = v56;
          else
            v57 = v56 & 0xFFFFFFFE;
          if (!v57)
            goto LABEL_90;
          v54 = &stru_1E2FD85F8;
          if (DerivedStorage && *(_QWORD *)(DerivedStorage + 8760))
            v54 = *(const __CFString **)(DerivedStorage + 8760);
          goto LABEL_89;
        }
      }
      while (!FigAlternateHasValidCodecs(AlternateEntryFromURLForCacheLookup[1]));
      LODWORD(v293.value) = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      v51 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      v52 = v293.value;
      if (os_log_type_enabled(v51, type[0]))
        v53 = v52;
      else
        v53 = v52 & 0xFFFFFFFE;
      if (v53)
      {
        v54 = &stru_1E2FD85F8;
        if (DerivedStorage && *(_QWORD *)(DerivedStorage + 8760))
          v54 = *(const __CFString **)(DerivedStorage + 8760);
LABEL_89:
        LODWORD(cf.value) = 136315394;
        *(CMTimeValue *)((char *)&cf.value + 4) = (CMTimeValue)"segPumpGetFirstMatchingAlternateEntry";
        LOWORD(cf.flags) = 2114;
        *(_QWORD *)((char *)&cf.flags + 2) = v54;
        _os_log_send_and_compose_impl();
      }
LABEL_90:
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    goto LABEL_100;
  }
  v45 = DerivedStorage + 8112;
  while (1)
  {
    v45 = *(_QWORD *)v45;
    if (!v45)
      break;
    if (CFEqual(*(CFTypeRef *)(v45 + 8), a2))
    {
      v33 = FigSignalErrorAt();
      v289 = 0;
      v30 = 0;
      goto LABEL_48;
    }
  }
  v18 = v278;
  do
  {
    v37 = *(_QWORD *)v37;
    if (!v37)
      goto LABEL_119;
  }
  while (!CFEqual(*(CFTypeRef *)(v37 + 8), a2));
  v46 = *(_QWORD *)(v37 + 8);
LABEL_107:
  if (!v46 || (PeakBitRate = FigAlternateGetPeakBitRate(v46), PeakBitRate <= 0))
  {
LABEL_119:
    v19 = FigSignalErrorAt();
LABEL_120:
    v33 = v19;
    v289 = 0;
    v30 = 0;
    v280 = 0;
    v32 = 0;
    goto LABEL_552;
  }
  if (*(_QWORD *)(DerivedStorage + 8224) && !FigCFEqual())
  {
    if (dword_1EE2A31E8)
    {
      LODWORD(v293.value) = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      v66 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      v67 = v293.value;
      if (os_log_type_enabled(v66, type[0]))
        v68 = v67;
      else
        v68 = v67 & 0xFFFFFFFE;
      if (v68)
      {
        v69 = &stru_1E2FD85F8;
        if (*(_QWORD *)(DerivedStorage + 8760))
          v69 = *(const __CFString **)(DerivedStorage + 8760);
        LODWORD(cf.value) = 136315394;
        *(CMTimeValue *)((char *)&cf.value + 4) = (CMTimeValue)"segPumpSetCurrentAlternate";
        LOWORD(cf.flags) = 2114;
        *(_QWORD *)((char *)&cf.flags + 2) = v69;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    segPumpClearSuggestedAlternate((_QWORD *)DerivedStorage);
  }
  HDCPLevel = FigAlternateGetHDCPLevel(v46);
  if (HDCPLevel == -2)
    v71 = -1;
  else
    v71 = HDCPLevel;
  IsIFrameOnly = FigAlternateIsIFrameOnly(v46);
  PlaylistAlternateURL = (const void *)FigAlternateGetPlaylistAlternateURL(v46);
  if (PlaylistAlternateURL)
  {
    v295 = CFRetain(PlaylistAlternateURL);
    if (v295)
    {
      if (*(_BYTE *)(DerivedStorage + 320))
      {
        v19 = FigCFHTTPCopyURLAndInheritQueyComponentIfNotPresent(*(const __CFURL **)(DerivedStorage + 312), (CFURLRef *)&v295);
        if ((_DWORD)v19)
          goto LABEL_120;
      }
    }
  }
  else
  {
    v295 = 0;
  }
  v73 = v295;
  v256 = v71;
  if (a5)
  {
    if (v295)
      CFRetain(v295);
    URLForCacheLookup = (const void *)FigAlternateGetURLForCacheLookup(v46);
    StableStreamIdentifier = (const void *)FigAlternateGetStableStreamIdentifier(v46);
    v267 = 0;
    v264 = 0;
    v75 = (CMTimeValue)v73;
    v73 = 0;
  }
  else
  {
    if (v295)
      CFRetain(v295);
    v264 = (const void *)FigAlternateGetURLForCacheLookup(v46);
    v267 = (const void *)FigAlternateGetStableStreamIdentifier(v46);
    URLForCacheLookup = 0;
    StableStreamIdentifier = 0;
    v75 = 0;
  }
  v76 = *(const void **)(DerivedStorage + 8392);
  if (v76)
  {
    CFRelease(v76);
    *(_QWORD *)(DerivedStorage + 8392) = 0;
  }
  v77 = *(const void **)(DerivedStorage + 8400);
  if (v77)
  {
    CFRelease(v77);
    *(_QWORD *)(DerivedStorage + 8400) = 0;
  }
  v280 = v75;
  v277 = (CMTimeValue)v73;
  v78 = *(const void **)(DerivedStorage + 8408);
  if (v78)
  {
    CFRelease(v78);
    *(_QWORD *)(DerivedStorage + 8408) = 0;
  }
  cf2 = (CFTypeRef)v46;
  if (!a3 || (v79 = CFArrayGetCount(a3), v79 < 1))
  {
    LOBYTE(v281) = 0;
    v265 = 0;
    v266 = 0;
    v30 = 0;
LABEL_216:
    v32 = (const void *)v277;
    if (!(v280 | v277))
    {
      v33 = FigSignalErrorAt();
      v289 = 0;
LABEL_48:
      v280 = 0;
      v32 = 0;
      goto LABEL_49;
    }
    v97 = v277 != 0;
    if (v277)
      v98 = 1;
    else
      v98 = v280 == 0;
    v99 = a5;
    if (!v98)
      v99 = 1;
    v257 = v99;
    if (v280)
      v97 |= 2u;
    if (v30)
      v100 = v97 | 4;
    else
      v100 = v97;
    *a10 = v100;
    v101 = *(_QWORD *)(DerivedStorage + 9048);
    if (v101)
    {
      v102 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                         + 56);
      if (v102)
        v102(v101, CFSTR("bytePumpStats"), CFSTR("ActiveSubstreams"), v100, 0);
    }
    v103 = *(_QWORD *)(DerivedStorage + 8144);
    if (v103)
      v104 = CFEqual(*(CFTypeRef *)(v103 + 8), cf2) == 0;
    else
      v104 = 1;
    v272 = v104;
    v105 = *(_QWORD *)(*v274 + 8);
    if (v277 | v105)
      v106 = FigCFHTTPCompareURLs((const void *)v277, (CFTypeRef)v105) == 0;
    else
      v106 = 0;
    v107 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 400) + 8);
    if (v280 | v107)
      v276 = FigCFHTTPCompareURLs((const void *)v280, (CFTypeRef)v107) == 0;
    else
      v276 = 0;
    v108 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 416) + 8);
    if (v30 | v108)
    {
      v110 = FigCFHTTPCompareURLs((const void *)v30, (CFTypeRef)v108);
      v109 = v106 | 2;
      if (!v276)
        v109 = v106;
      v255 = v110 == 0;
      if (!v110)
        v109 |= 4u;
    }
    else
    {
      v255 = 0;
      v109 = v106 | 2;
      if (!v276)
        v109 = v106;
    }
    v289 = v109;
    v111 = (_BYTE *)(DerivedStorage + 8004);
    v112 = *(_QWORD *)(DerivedStorage + 8144);
    if (v112)
    {
      FigAlternateGetVideoGroupIDString(*(_QWORD *)(v112 + 8));
      FigAlternateGetVideoGroupIDString(*(_QWORD *)(v37 + 8));
      v113 = FigCFEqual() == 0;
      v114 = *(_QWORD *)(DerivedStorage + 8144);
      if (v114)
      {
        FigAlternateGetAudioGroupIDString(*(_QWORD *)(v114 + 8));
        FigAlternateGetAudioGroupIDString(*(_QWORD *)(v37 + 8));
        v263 = FigCFEqual() == 0;
        v115 = *(_QWORD *)(DerivedStorage + 8144);
        if (v115)
        {
          FigAlternateGetSubtitleGroupIDString(*(_QWORD *)(v115 + 8));
          FigAlternateGetSubtitleGroupIDString(*(_QWORD *)(v37 + 8));
          v262 = FigCFEqual() == 0;
          if (*(_QWORD *)(DerivedStorage + 8144))
          {
            if (*(_QWORD *)(DerivedStorage + 296))
              IsFullyCached = FigAlternateGetLastKnownValueForIsFullyCached();
            else
              IsFullyCached = 0;
            v261 = IsFullyCached != 0;
          }
          else
          {
            v261 = 0;
          }
        }
        else
        {
          v261 = 0;
          v262 = 1;
        }
        goto LABEL_256;
      }
      v261 = 0;
      v262 = 1;
    }
    else
    {
      v261 = 0;
      v262 = 1;
      v113 = 1;
    }
    v263 = 1;
LABEL_256:
    if (*(_QWORD *)(DerivedStorage + 296))
      v117 = FigAlternateGetLastKnownValueForIsFullyCached();
    else
      v117 = 0;
    v258 = (v286 >> 4) & 1;
    *(_BYTE *)(DerivedStorage + 8216) = (v286 & 0x10) != 0;
    if ((*(_QWORD *)v283 & 0x8000000000000000) != 0)
    {
      v118 = MEMORY[0x1E0CA2E68];
      v74 = *MEMORY[0x1E0CA2E68];
      *(_OWORD *)v283 = *MEMORY[0x1E0CA2E68];
      *(_QWORD *)(v283 + 16) = *(_QWORD *)(v118 + 16);
    }
    key = a9;
    v273 = v286 & 1;
    v270 = (_BYTE *)(DerivedStorage + 8004);
    v119 = v272;
    v271 = v106;
    if (dword_1EE2A31E8)
    {
      LODWORD(v293.value) = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      v120 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      v121 = v293.value;
      if (os_log_type_enabled(v120, type[0]))
        v122 = v121;
      else
        v122 = v121 & 0xFFFFFFFE;
      if (v122)
      {
        if (*(_QWORD *)(DerivedStorage + 8760))
          v123 = *(const __CFString **)(DerivedStorage + 8760);
        else
          v123 = &stru_1E2FD85F8;
        time = *(CMTime *)v283;
        Seconds = CMTimeGetSeconds(&time);
        time = *v275;
        v125 = CMTimeGetSeconds(&time);
        LODWORD(cf.value) = 136316930;
        *(CMTimeValue *)((char *)&cf.value + 4) = (CMTimeValue)"segPumpSetCurrentAlternate";
        v126 = "false";
        LOWORD(cf.flags) = 2114;
        *(_QWORD *)((char *)&cf.flags + 2) = v123;
        HIWORD(cf.epoch) = 1024;
        if (v278)
          v127 = "true";
        else
          v127 = "false";
        *(_DWORD *)v298 = PeakBitRate;
        if (IsIFrameOnly)
          v126 = "true";
        *(_WORD *)&v298[4] = 2048;
        *(Float64 *)&v298[6] = Seconds;
        v299 = 2048;
        v300 = v125;
        v301 = 1024;
        v302 = v286 & 1;
        v303 = 2082;
        v304 = v127;
        v305 = 2082;
        v306 = v126;
        v119 = v272;
        _os_log_send_and_compose_impl();
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      v32 = (const void *)v277;
      v111 = (_BYTE *)(DerivedStorage + 8004);
      v106 = v271;
    }
    v128 = v119 || v106;
    if (!v119 && !v106 && !v276)
    {
      v282 = 0;
      v287 = 0;
      v18 = v278;
      v179 = v275;
      v195 = v256;
      v165 = v258;
LABEL_500:
      if (*(_DWORD *)(DerivedStorage + 288) != v195)
      {
        v229 = *(const void **)(DerivedStorage + 272);
        if (v229)
        {
          CFRelease(v229);
          *(_QWORD *)(DerivedStorage + 272) = 0;
        }
        v230 = *(const void **)(DerivedStorage + 280);
        if (v230)
        {
          CFRelease(v230);
          *(_QWORD *)(DerivedStorage + 280) = 0;
        }
        *(_DWORD *)(DerivedStorage + 288) = v195;
      }
      if (v255)
      {
        if (key && (key[2].flags & 1) != 0)
          v179 = key + 2;
        time = *v179;
        v231 = *(_QWORD *)(DerivedStorage + 416);
        if (v30)
        {
          v232 = *(_QWORD *)(v231 + 56);
          v233 = v287;
          v234 = v282;
          if (v232
            && (MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v232)) != 0
            && CFArrayGetCount(MediaSegmentSpecifiers) > 0)
          {
            v236 = 0;
          }
          else
          {
            v236 = *(_QWORD *)(DerivedStorage + 16 * *(_QWORD *)(DerivedStorage + 8416) + 384);
          }
          v237 = *(_QWORD *)(DerivedStorage + 416);
          cf = *(CMTime *)v283;
          v293 = time;
          v33 = segPumpSetAlternateForStream(v285, DerivedStorage, v237, v236, (const void *)v30, v265, v266, v273, 1u, (uint64_t)&cf, (uint64_t)&v293);
LABEL_520:
          if (v165 && !(_DWORD)v33)
          {
            v238 = 0;
            v239 = 384;
            type[0] = OS_LOG_TYPE_DEFAULT;
            v292 = OS_LOG_TYPE_DEFAULT;
            while (1)
            {
              v240 = *(uint64_t **)(DerivedStorage + v239);
              v241 = v240[8];
              if (v241)
              {
                FigStreamingCacheMediaStreamIsComplete(*(_QWORD *)(DerivedStorage + 296), v241, type);
                FigStreamingCacheMediaStreamIsWritableToDisk(*(_QWORD *)(DerivedStorage + 296), v240[8], &v292);
                if (type[0] || v292 == OS_LOG_TYPE_DEFAULT)
                {
                  *a10 &= ~(1 << v238);
                  if (dword_1EE2A31E8)
                  {
                    LODWORD(v293.value) = 0;
                    v243 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                    v244 = v293.value;
                    if (os_log_type_enabled(v243, OS_LOG_TYPE_DEFAULT))
                      v245 = v244;
                    else
                      v245 = v244 & 0xFFFFFFFE;
                    if (v245)
                    {
                      v246 = *(const __CFString **)(DerivedStorage + 8760);
                      if (!v246)
                        v246 = &stru_1E2FD85F8;
                      v247 = *v240;
                      v248 = "complete";
                      if (type[0] == OS_LOG_TYPE_DEFAULT)
                        v248 = "not writable";
                      LODWORD(cf.value) = 136316162;
                      *(CMTimeValue *)((char *)&cf.value + 4) = (CMTimeValue)"segPumpSetCurrentAlternate";
                      LOWORD(cf.flags) = 2114;
                      *(_QWORD *)((char *)&cf.flags + 2) = v246;
                      HIWORD(cf.epoch) = 2048;
                      *(_QWORD *)v298 = v247;
                      *(_WORD *)&v298[8] = 1024;
                      *(_DWORD *)&v298[10] = v238;
                      v299 = 2080;
                      v300 = *(double *)&v248;
                      _os_log_send_and_compose_impl();
                    }
                    fig_log_call_emit_and_clean_up_after_send_and_compose();
                  }
                  v249 = segPumpStopStream(DerivedStorage, (uint64_t)v240, 0);
                  if ((_DWORD)v249)
                  {
                    v33 = v249;
LABEL_545:
                    v18 = v278;
LABEL_546:
                    v32 = (const void *)v277;
                    goto LABEL_547;
                  }
                  v250 = (const void *)v240[2];
                  if (v250)
                  {
                    CFRelease(v250);
                    v240[2] = 0;
                  }
                }
              }
              ++v238;
              v239 += 16;
              if (v238 == 3)
              {
                v33 = 0;
                goto LABEL_545;
              }
            }
          }
          goto LABEL_548;
        }
        ++*(_DWORD *)(v231 + 72);
        v33 = segPumpStopStream(DerivedStorage, v231, 0);
        segPumpStreamUpdateIndexFile((_QWORD *)v231, 0, 0, 0, 0, CFSTR("."));
      }
      else
      {
        v33 = 0;
      }
      v233 = v287;
      v234 = v282;
      goto LABEL_520;
    }
    v129 = !v261;
    if (v117)
      v129 = 1;
    if (v129 & 1 | !v119 | (v113 || v263 || v262) || (_BYTE)v281)
    {
      v130 = IsIFrameOnly || v113;
      if ((v129 & 1) != 0 || (v130 & 1) == 0)
      {
        v131 = (uint64_t *)(DerivedStorage + 400);
        v18 = v278;
        if ((v286 & 1) == 0)
        {
          v132 = !v271;
          if (!v111[5])
            v132 = 1;
          v133 = ((v132 | v276) & 1) == 0 && *(_QWORD *)(*v131 + 16) && *(unsigned __int8 *)(*v131 + 869) == 0;
          v293.value = 0;
          if (*(_BYTE *)(*(_QWORD *)(DerivedStorage + 16 * *(_QWORD *)(DerivedStorage + 8416) + 384) + 1169))
          {
            valid = FigSignalErrorAt();
            goto LABEL_551;
          }
          segPumpGetSafeNetworkBandwidth(DerivedStorage, (double *)&v293.value, 1, 0);
          if ((*(_BYTE *)(v283 + 12) & 1) != 0)
          {
            v134 = (v286 & 2) != 0 ? 0 : v278 ^ 1;
            time = *(CMTime *)v283;
            cf = *v275;
            if (segPumpRejectSwitchDueToStallRisk(DerivedStorage, (uint64_t)cf2, PeakBitRate, &time, &cf, v133, v134, *(double *)&v293.value))
            {
              v33 = 4294954652;
              goto LABEL_552;
            }
          }
          v135 = v286 & 1;
          if (PeakBitRate <= v269)
            v135 = 1;
          v273 = v135;
        }
        if (*(_QWORD *)(DerivedStorage + 8144))
          v136 = v119;
        else
          v136 = 0;
        if (v136)
        {
          v137 = a3;
          if (v111[172]
            && !*(_BYTE *)(*(_QWORD *)(DerivedStorage + 16 * *(_QWORD *)(DerivedStorage + 8416) + 384) + 860))
          {
            UpTimeNanoseconds = FigGetUpTimeNanoseconds();
            v139 = *(_QWORD *)(DerivedStorage + 16 * *(_QWORD *)(DerivedStorage + 8416) + 384);
            v140 = *(_DWORD *)(DerivedStorage + 8);
            if (v140 <= 0xA)
              v140 = 10;
            if (UpTimeNanoseconds - *(_QWORD *)(v139 + 432) > 1000000000 * (unint64_t)v140)
            {
              v287 = *(uint64_t **)(DerivedStorage + 8144);
              if (*(_DWORD *)(v139 + 472))
              {
                LODWORD(v293.value) = 0;
                type[0] = OS_LOG_TYPE_DEFAULT;
                v141 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                v142 = v293.value;
                if (os_log_type_enabled(v141, type[0]))
                  v143 = v142;
                else
                  v143 = v142 & 0xFFFFFFFE;
                if (v143)
                {
                  if (*(_QWORD *)(DerivedStorage + 8760))
                    v144 = *(const __CFString **)(DerivedStorage + 8760);
                  else
                    v144 = &stru_1E2FD85F8;
                  v145 = FigAlternateGetPlaylistAlternateURL(v287[1]);
                  v146 = CFSTR("[]");
                  v64 = *(_BYTE *)(DerivedStorage + 339) == 0;
                  LODWORD(cf.value) = 136315650;
                  *(CMTimeValue *)((char *)&cf.value + 4) = (CMTimeValue)"segPumpSetCurrentAlternate";
                  if (!v64)
                    v146 = (const __CFString *)v145;
                  LOWORD(cf.flags) = 2114;
                  *(_QWORD *)((char *)&cf.flags + 2) = v144;
                  HIWORD(cf.epoch) = 2114;
                  *(_QWORD *)v298 = v146;
                  _os_log_send_and_compose_impl();
                }
                v137 = a3;
                v111 = (_BYTE *)(DerivedStorage + 8004);
                v282 = 1;
                fig_log_call_emit_and_clean_up_after_send_and_compose();
              }
              else
              {
                LODWORD(v293.value) = 0;
                type[0] = OS_LOG_TYPE_DEFAULT;
                v202 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                v203 = v293.value;
                if (os_log_type_enabled(v202, type[0]))
                  v204 = v203;
                else
                  v204 = v203 & 0xFFFFFFFE;
                if (v204)
                {
                  if (*(_QWORD *)(DerivedStorage + 8760))
                    v205 = *(const __CFString **)(DerivedStorage + 8760);
                  else
                    v205 = &stru_1E2FD85F8;
                  v206 = FigAlternateGetPlaylistAlternateURL(v287[1]);
                  v207 = CFSTR("[]");
                  v64 = *(_BYTE *)(DerivedStorage + 339) == 0;
                  LODWORD(cf.value) = 136315650;
                  *(CMTimeValue *)((char *)&cf.value + 4) = (CMTimeValue)"segPumpSetCurrentAlternate";
                  if (!v64)
                    v207 = (const __CFString *)v206;
                  LOWORD(cf.flags) = 2114;
                  *(_QWORD *)((char *)&cf.flags + 2) = v205;
                  HIWORD(cf.epoch) = 2114;
                  *(_QWORD *)v298 = v207;
                  _os_log_send_and_compose_impl();
                }
                v137 = a3;
                v111 = (_BYTE *)(DerivedStorage + 8004);
                fig_log_call_emit_and_clean_up_after_send_and_compose();
                v282 = 0;
              }
              v18 = v278;
              v32 = (const void *)v277;
              if (!v278)
                goto LABEL_324;
LABEL_322:
              *(_QWORD *)(DerivedStorage + 7680) = v37;
              goto LABEL_345;
            }
          }
          v282 = 0;
          v287 = 0;
          if (v278)
            goto LABEL_322;
        }
        else
        {
          v282 = 0;
          v287 = 0;
          v137 = a3;
          if (v278)
            goto LABEL_322;
        }
LABEL_324:
        segPumpCancelAllReadAheadAndResetData(DerivedStorage);
        for (m = 384; m != 432; m += 16)
          segPumpStreamCancelPreloadReadAndResetData(DerivedStorage, *(_QWORD *)(DerivedStorage + m));
        for (n = 384; n != 432; n += 16)
          segPumpStreamCancelPreloadMapReadAndResetData(DerivedStorage, *(_QWORD *)(DerivedStorage + n));
        segPumpRTCReportingIssueRTCReportingEvent(DerivedStorage, 201);
        v149 = *(const void **)(DerivedStorage + 8248);
        if (v149)
        {
          CFRelease(v149);
          *(_QWORD *)(DerivedStorage + 8248) = 0;
        }
        for (ii = 0; ii != 120; ii += 40)
          *(_BYTE *)(DerivedStorage + 8280 + ii) = 0;
        v151 = *(_QWORD *)(DerivedStorage + 8144);
        if (v151)
          v152 = v287 == 0;
        else
          v152 = 0;
        if (v152 && IsIFrameOnly == 0 && !*(_QWORD *)(DerivedStorage + 184) && PeakBitRate > v269)
          *(_QWORD *)(DerivedStorage + 8248) = CFRetain(*(CFTypeRef *)(v151 + 8));
LABEL_345:
        v155 = *(const void **)(DerivedStorage + 8152);
        *(_QWORD *)(DerivedStorage + 8152) = v137;
        if (v137)
          CFRetain(v137);
        if (v155)
          CFRelease(v155);
        v156 = *(_QWORD *)(DerivedStorage + 9544);
        if (v156)
        {
          v157 = *(void (**)(uint64_t, const __CFString *, const __CFArray *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                       + 56);
          if (v157)
            v157(v156, CFSTR("AlternateFilterMonitorProperty_SelectedMedia"), v137);
        }
        if (IsIFrameOnly)
        {
          v158 = v271;
          if (!v32)
            v158 = 0;
          v289 = v158;
          if (!v128)
          {
            v33 = 0;
            goto LABEL_547;
          }
          if (!*(_QWORD *)(*v131 + 16) || (valid = segPumpStopStream(DerivedStorage, *v131, 0), !(_DWORD)valid))
          {
            v160 = *(_QWORD *)(DerivedStorage + 416);
            if (!*(_QWORD *)(v160 + 16) || (valid = segPumpStopStream(DerivedStorage, v160, 0), !(_DWORD)valid))
            {
              segPumpClearStatistics(DerivedStorage);
              segPumpUpdateCurrentAlternate(DerivedStorage, v37);
              *(_BYTE *)(DerivedStorage + 8712) = 1;
              if (!v272)
                *(_BYTE *)(DerivedStorage + 8713) = 1;
              *(_QWORD *)(*(_QWORD *)(DerivedStorage + 384) + 896) = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 384)
                                                                                 + 1056);
              segPumpStreamUpdateIndexFile(*(_QWORD **)(DerivedStorage + 400), 0, 0, 0, 0, CFSTR("."));
              segPumpStreamUpdateIndexFile(*(_QWORD **)(DerivedStorage + 416), 0, 0, 0, 0, CFSTR("."));
              v161 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 384) + 56);
              if (v161)
              {
                v162 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v161);
                if (v162)
                {
                  if (CFArrayGetCount(v162) >= 1)
                  {
                    *(_BYTE *)(DerivedStorage + 8713) = 0;
                    *(_BYTE *)(DerivedStorage + 8768) = 0;
                  }
                }
              }
              v163 = *(_QWORD *)(DerivedStorage + 384);
              time = *(CMTime *)v283;
              cf = *v275;
              v33 = segPumpSetAlternateForStream(v285, DerivedStorage, v163, 0, v32, v264, v267, v273, 1u, (uint64_t)&time, (uint64_t)&cf);
              ++*(_DWORD *)(*(_QWORD *)(DerivedStorage + 400) + 72);
              ++*(_DWORD *)(*(_QWORD *)(DerivedStorage + 416) + 72);
              goto LABEL_552;
            }
          }
LABEL_551:
          v33 = valid;
          goto LABEL_552;
        }
        v164 = (uint64_t *)(DerivedStorage + 400);
        if (v111[708])
          v111[708] = 0;
        v165 = v258;
        if (a9)
        {
          if ((*(_DWORD *)(v283 + 12) & 1) != 0)
          {
            LODWORD(v74) = v289;
            v166 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v74);
            v166.i16[0] = vaddlv_u8(v166);
            if (v166.i32[0] >= 2u)
            {
              for (jj = 0; jj != 3; ++jj)
              {
                if (((v289 >> jj) & 1) != 0 && (a9[jj].flags & 1) != 0)
                {
                  v168 = *(_QWORD *)(DerivedStorage + 16 * jj + 384);
                  time = *(CMTime *)v283;
                  cf = a9[jj];
                  CMTimeAdd(&v294, &time, &cf);
                  time = v294;
                  v169 = CMTimeGetSeconds(&time);
                  v170 = *(_QWORD *)(v168 + 56);
                  if (v170)
                  {
                    v171 = v169;
                    for (kk = 0; ; ++kk)
                    {
                      Count = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v170);
                      if (Count)
                        Count = (const __CFArray *)CFArrayGetCount(Count);
                      if (kk >= (uint64_t)Count)
                        break;
                      v174 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(v168 + 56));
                      ValueAtIndex = CFArrayGetValueAtIndex(v174, kk);
                      if (FigMediaSegmentSpecifierIsDiscontinuity((uint64_t)ValueAtIndex)
                        && FigMediaSegmentSpecifierGetDiscontinuityDomain((uint64_t)ValueAtIndex) == *(_QWORD *)(v168 + 304))
                      {
                        v176 = vabdd_f64(v171, *((double *)segPumpGetMediaFilePrivateData(ValueAtIndex) + 4));
                        if (v176 >= (double)(FigMediaPlaylistGetTargetDuration(*(_QWORD *)(v168 + 56)) >> 1))
                          break;
                        key = 0;
                        goto LABEL_385;
                      }
                      v170 = *(_QWORD *)(v168 + 56);
                    }
                  }
                }
              }
LABEL_385:
              v165 = v258;
              v164 = (uint64_t *)(DerivedStorage + 400);
            }
          }
        }
        if ((v18 & 1) == 0)
        {
          segPumpClearStatistics(DerivedStorage);
          segPumpUpdateCurrentAlternate(DerivedStorage, v37);
          *(_QWORD *)(DerivedStorage + 8416) = v257 != 0;
        }
        v177 = *v164;
        v178 = *(_QWORD *)(*v164 + 16);
        if (v257)
        {
          v179 = v275;
          if (dword_1EE2A31E8)
          {
            LODWORD(v293.value) = 0;
            type[0] = OS_LOG_TYPE_DEFAULT;
            v180 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            v181 = v293.value;
            if (os_log_type_enabled(v180, type[0]))
              v182 = v181;
            else
              v182 = v181 & 0xFFFFFFFE;
            if (v182)
            {
              v183 = &stru_1E2FD85F8;
              if (*(_QWORD *)(DerivedStorage + 8760))
                v183 = *(const __CFString **)(DerivedStorage + 8760);
              LODWORD(cf.value) = 136315394;
              *(CMTimeValue *)((char *)&cf.value + 4) = (CMTimeValue)"segPumpSetCurrentAlternate";
              LOWORD(cf.flags) = 2114;
              *(_QWORD *)((char *)&cf.flags + 2) = v183;
              _os_log_send_and_compose_impl();
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose();
          }
          v195 = v256;
          if (v276)
          {
            v196 = 400;
            v197 = 384;
            if (v178)
              v197 = 400;
            v198 = *(_QWORD *)(DerivedStorage + v197);
            if (v18)
              v196 = 408;
            v199 = *(_QWORD *)(DerivedStorage + v196);
            time = *(CMTime *)v283;
            cf = *v275;
            v200 = segPumpSetAlternateForStream(v285, DerivedStorage, v199, v198, (const void *)v280, URLForCacheLookup, StableStreamIdentifier, v273, v273 == 0, (uint64_t)&time, (uint64_t)&cf);
            if ((_DWORD)v200)
            {
              v33 = v200;
              goto LABEL_546;
            }
          }
          v32 = (const void *)v277;
          if ((v18 & 1) != 0)
            goto LABEL_499;
          v201 = *(_QWORD *)(DerivedStorage + 384);
          ++*(_DWORD *)(v201 + 72);
          v188 = segPumpStopStream(DerivedStorage, v201, 0);
          if (!(_DWORD)v188)
          {
            segPumpStreamUpdateIndexFile((_QWORD *)*v274, 0, 0, 0, 0, CFSTR("."));
LABEL_499:
            *(_BYTE *)(DerivedStorage + 8011) = 0;
            goto LABEL_500;
          }
LABEL_584:
          v33 = v188;
          goto LABEL_547;
        }
        v179 = v275;
        v184 = *v274;
        v185 = *(_QWORD *)(*v274 + 16);
        if (!v276)
        {
          v194 = 0;
          v33 = 0;
          v32 = (const void *)v277;
          v195 = v256;
          goto LABEL_474;
        }
        v186 = v275;
        if (key)
        {
          v186 = key + 1;
          if ((key[1].flags & 1) == 0)
            v186 = v275;
        }
        v293 = *v186;
        if (v178)
          v187 = v177;
        else
          v187 = v184;
        if (v280)
        {
          if (v18)
            v177 = *(_QWORD *)(DerivedStorage + 408);
          time = *(CMTime *)v283;
          cf = v293;
          v188 = segPumpSetAlternateForStream(v285, DerivedStorage, v177, v187, (const void *)v280, URLForCacheLookup, StableStreamIdentifier, v273, v273 == 0, (uint64_t)&time, (uint64_t)&cf);
          v32 = (const void *)v277;
          if ((_DWORD)v188)
            goto LABEL_584;
          if (dword_1EE2A31E8)
          {
            *(_DWORD *)type = 0;
            v292 = OS_LOG_TYPE_DEFAULT;
            v189 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            v190 = *(_DWORD *)type;
            if (os_log_type_enabled(v189, OS_LOG_TYPE_DEFAULT))
              v191 = v190;
            else
              v191 = v190 & 0xFFFFFFFE;
            if (v191)
            {
              v192 = &stru_1E2FD85F8;
              if (*(_QWORD *)(DerivedStorage + 8760))
                v192 = *(const __CFString **)(DerivedStorage + 8760);
              v193 = *(_QWORD *)v187;
              LODWORD(cf.value) = 136315906;
              *(CMTimeValue *)((char *)&cf.value + 4) = (CMTimeValue)"segPumpSetCurrentAlternate";
              LOWORD(cf.flags) = 2114;
              *(_QWORD *)((char *)&cf.flags + 2) = v192;
              HIWORD(cf.epoch) = 1024;
              *(_DWORD *)v298 = v193;
              *(_WORD *)&v298[4] = 1024;
              *(_DWORD *)&v298[6] = v278;
              _os_log_send_and_compose_impl();
            }
            v195 = v256;
            v164 = (uint64_t *)(DerivedStorage + 400);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
            v194 = 0;
            v33 = 0;
            v32 = (const void *)v277;
            goto LABEL_474;
          }
          v194 = 0;
          v33 = 0;
        }
        else
        {
          if ((v18 & 1) == 0)
          {
            v32 = (const void *)v277;
            if (v271)
            {
              if (dword_1EE2A31E8)
              {
                *(_DWORD *)type = 0;
                v292 = OS_LOG_TYPE_DEFAULT;
                v208 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                v209 = *(_DWORD *)type;
                if (os_log_type_enabled(v208, OS_LOG_TYPE_DEFAULT))
                  v210 = v209;
                else
                  v210 = v209 & 0xFFFFFFFE;
                if (v210)
                {
                  v211 = &stru_1E2FD85F8;
                  if (*(_QWORD *)(DerivedStorage + 8760))
                    v211 = *(const __CFString **)(DerivedStorage + 8760);
                  LODWORD(cf.value) = 136315394;
                  *(CMTimeValue *)((char *)&cf.value + 4) = (CMTimeValue)"segPumpSetCurrentAlternate";
                  LOWORD(cf.flags) = 2114;
                  *(_QWORD *)((char *)&cf.flags + 2) = v211;
                  _os_log_send_and_compose_impl();
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose();
                v32 = (const void *)v277;
              }
              v33 = 0;
              ++*(_DWORD *)(v187 + 72);
              v194 = 1;
            }
            else
            {
              if (dword_1EE2A31E8)
              {
                *(_DWORD *)type = 0;
                v292 = OS_LOG_TYPE_DEFAULT;
                v212 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                v213 = *(_DWORD *)type;
                if (os_log_type_enabled(v212, OS_LOG_TYPE_DEFAULT))
                  v214 = v213;
                else
                  v214 = v213 & 0xFFFFFFFE;
                if (v214)
                {
                  v215 = *(const __CFString **)(DerivedStorage + 8760);
                  if (!v215)
                    v215 = &stru_1E2FD85F8;
                  v216 = *(_QWORD *)v177;
                  LODWORD(cf.value) = 136315650;
                  *(CMTimeValue *)((char *)&cf.value + 4) = (CMTimeValue)"segPumpSetCurrentAlternate";
                  LOWORD(cf.flags) = 2114;
                  *(_QWORD *)((char *)&cf.flags + 2) = v215;
                  HIWORD(cf.epoch) = 2048;
                  *(_QWORD *)v298 = v216;
                  _os_log_send_and_compose_impl();
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose();
                v32 = (const void *)v277;
              }
              ++*(_DWORD *)(v177 + 72);
              v33 = segPumpStopStream(DerivedStorage, v177, 0);
              v194 = 0;
            }
            v195 = v256;
            v164 = (uint64_t *)(DerivedStorage + 400);
            segPumpStreamUpdateIndexFile((_QWORD *)*v131, 0, 0, 0, 0, CFSTR("."));
LABEL_474:
            if (v271)
            {
              if (!key || (v217 = key, (key->flags & 1) == 0))
                v217 = v275;
              v218 = *(_OWORD *)&v217->value;
              v293.epoch = v217->epoch;
              *(_OWORD *)&v293.value = v218;
              if (v273)
                v219 = *v270 == 0;
              else
                v219 = 1;
              v220 = (uint64_t *)(DerivedStorage + 384);
              if (!v185)
                v220 = v164;
              v221 = (uint64_t *)*v220;
              if (dword_1EE2A31E8)
              {
                *(_DWORD *)type = 0;
                v292 = OS_LOG_TYPE_DEFAULT;
                v222 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                v223 = *(_DWORD *)type;
                if (os_log_type_enabled(v222, OS_LOG_TYPE_DEFAULT))
                  v224 = v223;
                else
                  v224 = v223 & 0xFFFFFFFE;
                if (v224)
                {
                  v225 = &stru_1E2FD85F8;
                  if (*(_QWORD *)(DerivedStorage + 8760))
                    v225 = *(const __CFString **)(DerivedStorage + 8760);
                  v226 = *v221;
                  LODWORD(cf.value) = 136315906;
                  *(CMTimeValue *)((char *)&cf.value + 4) = (CMTimeValue)"segPumpSetCurrentAlternate";
                  LOWORD(cf.flags) = 2114;
                  *(_QWORD *)((char *)&cf.flags + 2) = v225;
                  HIWORD(cf.epoch) = 1024;
                  *(_DWORD *)v298 = v226;
                  *(_WORD *)&v298[4] = 1024;
                  *(_DWORD *)&v298[6] = v278;
                  _os_log_send_and_compose_impl();
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose();
                v32 = (const void *)v277;
              }
              v227 = 384;
              if (v278)
                v227 = 392;
              v228 = *(_QWORD *)(DerivedStorage + v227);
              time = *(CMTime *)v283;
              cf = v293;
              v33 = segPumpSetAlternateForStream(v285, DerivedStorage, v228, (uint64_t)v221, v32, v264, v267, v273, v219, (uint64_t)&time, (uint64_t)&cf);
              if ((_DWORD)v33)
              {
                v18 = v278;
                goto LABEL_547;
              }
              *v270 = 1;
              v179 = v275;
            }
            if (v194)
              v33 = segPumpStopStream(DerivedStorage, *(_QWORD *)(DerivedStorage + 400), 0);
            v18 = v278;
            v165 = v258;
            if ((_DWORD)v33)
            {
LABEL_547:
              v233 = v287;
              v234 = v282;
LABEL_548:
              if (!v233)
                goto LABEL_552;
              valid = MoveAlternateFromValidList((uint64_t)v285, v233, v234, 0);
              if (!(_DWORD)valid)
                valid = segPumpUpdateAlternateSelectionBossNetworkErrorFilter((_QWORD *)DerivedStorage, v234);
              goto LABEL_551;
            }
            goto LABEL_499;
          }
          v194 = 0;
          v33 = 0;
          v32 = (const void *)v277;
        }
        v195 = v256;
        v164 = (uint64_t *)(DerivedStorage + 400);
        goto LABEL_474;
      }
    }
    v33 = 4294950461;
LABEL_49:
    v18 = v278;
    goto LABEL_552;
  }
  v80 = v79;
  v81 = 0;
  v265 = 0;
  v266 = 0;
  v281 = 0;
  v82 = 0;
  while (1)
  {
    v83 = (const __CFDictionary *)CFArrayGetValueAtIndex(a3, v82);
    if (CFDictionaryGetValue(v83, CFSTR("MediaSelectionGroupMediaType")))
    {
      time.value = 0;
      cf.value = 0;
      v293.value = 0;
      *(_DWORD *)type = 0;
      if (!FigCFStringGetOSTypeValue())
        goto LABEL_429;
      v84 = *(_DWORD *)type == 1986618469 || IsIFrameOnly == 0;
      if (v84 && *(_DWORD *)type != 1668047728)
        break;
    }
    v30 = (CMTimeValue)v81;
LABEL_213:
    ++v82;
    v81 = (const void *)v30;
    if (v80 == v82)
      goto LABEL_216;
  }
  v86 = CFDictionaryGetValue(v83, CFSTR("MediaSelectionOptionsPersistentID"));
  if (v86)
  {
    v87 = v86;
    v88 = CFGetTypeID(v86);
    TypeID = CFNumberGetTypeID();
    v90 = v88 == TypeID;
    if (v88 == TypeID)
      v91 = v87;
    else
      v91 = 0;
    v92 = v281;
    if (v90)
      v92 = 1;
    v281 = v92;
  }
  else
  {
    v91 = 0;
  }
  if (*(_DWORD *)type == 1986618469)
  {
    v93 = *(const void **)(DerivedStorage + 8392);
    *(_QWORD *)(DerivedStorage + 8392) = v91;
    if (!v91)
      goto LABEL_173;
    goto LABEL_172;
  }
  if (*(_DWORD *)type != 1936684398)
  {
    if (*(_DWORD *)type != 1935832172)
      goto LABEL_429;
    v93 = *(const void **)(DerivedStorage + 8408);
    *(_QWORD *)(DerivedStorage + 8408) = v91;
    if (v91)
      goto LABEL_172;
LABEL_173:
    if (v93)
      CFRelease(v93);
    FigAlternateGetRenditionInfoForMediaType((uint64_t)cf2, *(int *)type, *(const void **)(DerivedStorage + 8392), *(const void **)(DerivedStorage + 8400), *(const void **)(DerivedStorage + 8408), 0, (const __CFDictionary **)&v293, &time, &cf);
    if (time.value)
    {
      CFRetain((CFTypeRef)time.value);
      if (time.value)
      {
        if (*(_BYTE *)(DerivedStorage + 320))
        {
          v94 = FigCFHTTPCopyURLAndInheritQueyComponentIfNotPresent(*(const __CFURL **)(DerivedStorage + 312), (CFURLRef *)&time);
          if ((_DWORD)v94)
            goto LABEL_430;
        }
      }
    }
    switch(*(_DWORD *)type)
    {
      case 0x76696465:
        if (v91)
        {
          if (!a5)
          {
            v95 = time.value;
            if (time.value)
            {
              CFRetain((CFTypeRef)time.value);
              if (v277)
                CFRelease((CFTypeRef)v277);
              v264 = (const void *)cf.value;
              v267 = (const void *)v293.value;
              v30 = (CMTimeValue)v81;
              v277 = v95;
              goto LABEL_211;
            }
          }
        }
        else
        {
          if (v277)
            CFRelease((CFTypeRef)v277);
          v267 = 0;
          v277 = 0;
        }
        break;
      case 0x736F756E:
        if (v91)
        {
          v96 = time.value;
          if (time.value)
          {
            CFRetain((CFTypeRef)time.value);
            if (v280)
              CFRelease((CFTypeRef)v280);
            URLForCacheLookup = (const void *)cf.value;
            StableStreamIdentifier = (const void *)v293.value;
            v30 = (CMTimeValue)v81;
            v280 = v96;
            goto LABEL_211;
          }
        }
        else
        {
          if (v280)
            CFRelease((CFTypeRef)v280);
          URLForCacheLookup = 0;
          StableStreamIdentifier = 0;
          v280 = 0;
        }
        break;
      case 0x7362746C:
        v30 = time.value;
        if (time.value)
          CFRetain((CFTypeRef)time.value);
        if (v81)
          CFRelease(v81);
        v265 = (const void *)cf.value;
        v266 = (const void *)v293.value;
        goto LABEL_211;
    }
    v30 = (CMTimeValue)v81;
LABEL_211:
    if (time.value)
      CFRelease((CFTypeRef)time.value);
    goto LABEL_213;
  }
  if (!a5 || v91)
  {
    v93 = *(const void **)(DerivedStorage + 8400);
    *(_QWORD *)(DerivedStorage + 8400) = v91;
    if (!v91)
      goto LABEL_173;
LABEL_172:
    CFRetain(v91);
    goto LABEL_173;
  }
LABEL_429:
  v94 = FigSignalErrorAt();
LABEL_430:
  v33 = v94;
  v18 = v278;
  v32 = (const void *)v277;
  v289 = 0;
  v30 = (CMTimeValue)v81;
LABEL_552:
  if (a12)
  {
    v251 = 0;
    v252 = DerivedStorage + 392;
    v34 = a11;
    do
    {
      if (!v18 || (v253 = *(_QWORD *)v252, !*(_QWORD *)(*(_QWORD *)v252 + 16)))
        v253 = *(_QWORD *)(v252 - 8);
      *(_DWORD *)(a12 + v251) = *(_DWORD *)(v253 + 72);
      v251 += 4;
      v252 += 16;
    }
    while (v251 != 12);
  }
  else
  {
    v34 = a11;
  }
  v31 = (const void *)v280;
  if (v34)
LABEL_561:
    *v34 = v289;
LABEL_562:
  if (v30)
    CFRelease((CFTypeRef)v30);
  if (v31)
    CFRelease(v31);
  if (v32)
    CFRelease(v32);
  if (v295)
    CFRelease(v295);
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(v285, v33);
}

uint64_t segPumpGetTimeRangeForDate(const void *a1, const __CFDate *a2, CMTime *a3, CMTime *a4)
{
  uint64_t DerivedStorage;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  return segPumpGetTimeRangeForDateWithSegmentOffset(a1, *(_QWORD *)(*(_QWORD *)(DerivedStorage + 16 * *(_QWORD *)(DerivedStorage + 8416) + 384) + 56), a2, a3, a4, 0);
}

uint64_t segPumpGetEstimatedDateForTime(const void *a1, CMTime *a2, CFDateRef *a3)
{
  uint64_t DerivedStorage;
  CFIndex v7;
  uint64_t v8;
  const __CFArray *MediaSegmentSpecifiers;
  uint64_t v10;
  double Current;
  uint64_t UpTimeNanoseconds;
  uint64_t v14;
  double v15;
  Float64 Seconds;
  CFDateRef v17;
  CMTime v18;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v7 = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if ((_DWORD)v7)
  {
    v10 = v7;
  }
  else
  {
    v8 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 16 * *(_QWORD *)(DerivedStorage + 8416) + 384) + 56);
    if (v8
      && (MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v8)) != 0
      && CFArrayGetCount(MediaSegmentSpecifiers) >= 1
      && !*(_BYTE *)(DerivedStorage + 8002))
    {
      Current = CFAbsoluteTimeGetCurrent();
      UpTimeNanoseconds = FigGetUpTimeNanoseconds();
      v14 = *(_QWORD *)(DerivedStorage + 16 * *(_QWORD *)(DerivedStorage + 8416) + 384);
      v15 = Current
          + (double)(UpTimeNanoseconds - *(_QWORD *)(v14 + 1056)) / -1000000000.0
          - *(double *)(v14 + 96)
          - *(double *)(v14 + 88);
      v18 = *a2;
      Seconds = CMTimeGetSeconds(&v18);
      v17 = CFDateCreate(*(CFAllocatorRef *)(DerivedStorage + 56), Seconds + v15);
      v10 = 0;
      *a3 = v17;
    }
    else
    {
      v10 = 4294954513;
    }
  }
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v10);
}

uint64_t segPumpLikelyToKeepUp(const void *a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, float *a6, _OWORD *a7, _DWORD *a8, _BYTE *a9)
{
  uint64_t DerivedStorage;
  float v16;
  _BYTE *v17;
  double Seconds;
  int v19;
  double v20;
  double v21;
  float v22;
  int *v23;
  float v24;
  double v25;
  uint64_t v27;
  char v28;
  char v29;
  uint64_t v30;
  double v31;
  uint64_t v32;
  double v33;
  int v34;
  char v35;
  uint64_t v36;
  int v37;
  char v38;
  char v39;
  uint64_t v40;
  double v41;
  double v42;
  double v43;
  double LiveBoundary;
  double v45;
  int *v46;
  float v47;
  double v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  NSObject *v52;
  _OWORD *v53;
  uint64_t v54;
  uint64_t v55;
  void (*v56)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  __int128 v57;
  __int128 v58;
  float v59;
  float *v60;
  float v61;
  uint64_t i;
  uint64_t v64;
  double v65;
  double v66;
  double v67;
  double v68;
  double v69;
  double v70;
  const __CFAllocator *AllocatorForMedia;
  CFStringRef v72;
  uint64_t v73;
  const __CFURL **v74;
  double v75;
  float v76;
  NSObject *v77;
  double TimeInSeconds;
  uint64_t v79;
  uint64_t *v80;
  double v81;
  uint64_t v82;
  unint64_t v83;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v85;
  _DWORD *v86;
  unsigned int v87;
  const void *v90;
  double v91;
  uint64_t v92;
  double v93;
  double v94;
  _BYTE time[32];
  __int128 v96;
  __int128 v97;
  __int128 v98;
  uint64_t v99;
  uint64_t v100;

  v100 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v93 = 0.0;
  v94 = 0.0;
  v91 = 0.0;
  v92 = 0;
  v90 = a1;
  v16 = 0.0;
  v87 = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if (v87)
    goto LABEL_126;
  v17 = (_BYTE *)(DerivedStorage + 8002);
  if (*(_BYTE *)(DerivedStorage + 8712))
  {
    v34 = 1;
    goto LABEL_128;
  }
  *(_OWORD *)time = *(_OWORD *)a2;
  *(_QWORD *)&time[16] = *(_QWORD *)(a2 + 16);
  Seconds = CMTimeGetSeconds((CMTime *)time);
  v99 = 0;
  v97 = 0u;
  v98 = 0u;
  v96 = 0u;
  memset(time, 0, sizeof(time));
  segPumpMakeNetworkPrediction(DerivedStorage, (uint64_t)time);
  if (v19)
  {
LABEL_126:
    v34 = 0;
LABEL_128:
    v24 = INFINITY;
    goto LABEL_129;
  }
  v85 = a5;
  v20 = (double)*(uint64_t *)time;
  segPumpGetRequiredBandwidthForCurrentStreamingAlternate(DerivedStorage);
  segPumpGetStartupRequirements(DerivedStorage, *(_DWORD *)(DerivedStorage + 8), (double *)&v92, &v91, &v94, &v93, v21);
  v22 = Seconds / v94;
  v16 = fmaxf(v22, 0.0);
  v23 = &dword_1EE2A3000;
  if (*v17)
  {
    v24 = INFINITY;
  }
  else
  {
    v36 = 0;
    v37 = 0;
    v38 = 1;
    v24 = INFINITY;
    do
    {
      v39 = v38;
      v40 = *(_QWORD *)(DerivedStorage + 16 * v36 + 384);
      if (*(_QWORD *)(v40 + 16))
      {
        if (((a4 >> v36) & 1) != 0 && (*(_BYTE *)(a3 + 12) & 1) != 0)
        {
          v41 = *(double *)(v40 + 88);
          v42 = *(double *)(v40 + 96);
          *(_OWORD *)time = *(_OWORD *)a3;
          *(_QWORD *)&time[16] = *(_QWORD *)(a3 + 16);
          if (CMTimeGetSeconds((CMTime *)time) > *(double *)(v40 + 88) && !*(_BYTE *)(DerivedStorage + 329))
          {
            v43 = v41 + v42;
            LiveBoundary = segPumpGetLiveBoundary(DerivedStorage, *(_QWORD *)(v40 + 56));
            *(_OWORD *)time = *(_OWORD *)a3;
            *(_QWORD *)&time[16] = *(_QWORD *)(a3 + 16);
            v45 = v43 - CMTimeGetSeconds((CMTime *)time);
            if (LiveBoundary >= v45)
            {
              if (*(int *)(DerivedStorage + 7944) < 2)
              {
                v46 = &dword_1EE2A3000;
              }
              else
              {
                v46 = &dword_1EE2A3000;
                if (*(_DWORD *)(DerivedStorage + 8))
                {
                  v47 = v45 / (LiveBoundary + 0.01);
                  if (v24 >= v47)
                    v24 = v45 / (LiveBoundary + 0.01);
                }
              }
              if (v46[122] < 2)
              {
                v37 = 1;
              }
              else
              {
                os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
                v37 = 1;
                fig_log_call_emit_and_clean_up_after_send_and_compose();
              }
            }
          }
        }
      }
      v38 = 0;
      v36 = 1;
    }
    while ((v39 & 1) != 0);
    if (v37)
    {
LABEL_49:
      v34 = 0;
LABEL_68:
      v53 = a7;
      goto LABEL_69;
    }
    v23 = &dword_1EE2A3000;
  }
  v25 = *(double *)(DerivedStorage + 8024);
  if (v25 != 0.0 && Seconds >= v25)
  {
LABEL_27:
    v33 = v94;
    v86 = a8;
    if (Seconds >= v94)
    {
      v35 = 0;
      *(_DWORD *)(DerivedStorage + 8664) = 2;
      goto LABEL_51;
    }
    if (Seconds >= v93)
    {
      if (v91 > v20)
      {
LABEL_30:
        v34 = 0;
        v35 = 1;
LABEL_63:
        if (v23[122] >= 2)
        {
          v52 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT);
          fig_log_call_emit_and_clean_up_after_send_and_compose();
        }
        if (!*v17)
        {
          for (i = 384; i != 432; i += 16)
          {
            v64 = *(_QWORD *)(DerivedStorage + i);
            if (*(_QWORD *)(v64 + 16))
            {
              v65 = *(double *)(v64 + 88);
              v66 = *(double *)(v64 + 96);
              *(_OWORD *)time = *(_OWORD *)a3;
              *(_QWORD *)&time[16] = *(_QWORD *)(a3 + 16);
              v67 = CMTimeGetSeconds((CMTime *)time);
              v68 = segPumpGetLiveBoundary(DerivedStorage, *(_QWORD *)(v64 + 56));
              v69 = *(double *)(DerivedStorage + 16);
              if (v69 <= 0.0)
              {
                LODWORD(v69) = *(_DWORD *)(DerivedStorage + 8);
                v69 = (double)*(unint64_t *)&v69;
              }
              if ((v35 & 1) == 0 && (*(_BYTE *)(a3 + 12) & 1) != 0)
              {
                v70 = v65 + v66 - v67;
                if (v70 <= v68 - v69 && *(_BYTE *)(v64 + 868) == 1)
                {
                  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
                  v72 = CFStringCreateWithFormat(AllocatorForMedia, 0, CFSTR("Warning: restarting %fs from end of live playlist; target duration %ds - stall danger"),
                          *(_QWORD *)&v70,
                          *(unsigned int *)(DerivedStorage + 8));
                  v73 = *(_QWORD *)(v64 + 696);
                  v74 = v73 ? (const __CFURL **)(v73 + 16) : 0;
                  segPumpAppendErrorLogEntry((uint64_t)v90, DerivedStorage, v64, v74, -16832, CFSTR("CoreMediaErrorDomain"), (uint64_t)v72, 0, 1, 0, 3u);
                  if (v72)
                    CFRelease(v72);
                }
              }
            }
          }
        }
        a8 = v86;
        goto LABEL_68;
      }
      *(_DWORD *)(DerivedStorage + 8664) = 3;
      if (!*(_BYTE *)(DerivedStorage + 8712) && !*(_QWORD *)(DerivedStorage + 8416))
      {
        v35 = 0;
        v34 = 1;
        if ((a4 & 1) == 0 || *(uint64_t *)(*(_QWORD *)(DerivedStorage + 384) + 752) < 2)
          goto LABEL_63;
        v48 = Seconds;
        if (v85)
        {
          *(_OWORD *)time = *(_OWORD *)v85;
          *(_QWORD *)&time[16] = *(_QWORD *)(v85 + 16);
          v48 = CMTimeGetSeconds((CMTime *)time);
          v33 = v94;
        }
        if (v48 >= v33
          || (v49 = *(_QWORD **)(DerivedStorage + 384), (v50 = v49[87]) == 0)
          || (v51 = v49[32]) == 0
          || v51 != *(_QWORD *)(v50 + 8)
          || (TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds(v51), v79 = v49[94], v79 < 1))
        {
          v35 = 0;
          goto LABEL_63;
        }
        v80 = v49 + 87;
        v81 = v48 / TimeInSeconds;
        v35 = 0;
        while (1)
        {
          v82 = *v80;
          if (*v80)
          {
            v83 = *(_QWORD *)(v82 + 256);
            if (!v83 || (double)*(unint64_t *)(v82 + 224) / (double)v83 < v81)
              goto LABEL_30;
          }
          ++v80;
          if (!--v79)
            goto LABEL_63;
        }
      }
      v35 = 0;
LABEL_51:
      v34 = 1;
      goto LABEL_63;
    }
    v34 = 0;
LABEL_129:
    v53 = a7;
    if (a7)
      goto LABEL_74;
    goto LABEL_75;
  }
  v27 = 0;
  v28 = 1;
  while (1)
  {
    v29 = v28;
    v30 = *(_QWORD *)(DerivedStorage + 16 * v27 + 384);
    if (!*(_QWORD *)(v30 + 16) || ((a4 >> v27) & 1) == 0)
      goto LABEL_21;
    if (!*(_BYTE *)(DerivedStorage + 329))
      break;
    if (*(_BYTE *)(v30 + 867)
      || *(_BYTE *)(v30 + 874)
      || *(_QWORD *)(DerivedStorage + 7680)
      && ((v32 = *(_QWORD *)(DerivedStorage + 16 * v27 + 392), *(_BYTE *)(v32 + 867)) || *(_BYTE *)(v32 + 874)))
    {
      *(_OWORD *)time = *(_OWORD *)a3;
      *(_QWORD *)&time[16] = *(_QWORD *)(a3 + 16);
      v31 = CMTimeGetSeconds((CMTime *)time);
      if (!*v17
        && *(double *)(v30 + 96) + *(double *)(v30 + 88) - (double)(3 * *(_DWORD *)(DerivedStorage + 8)) <= v31)
      {
        *(_DWORD *)(DerivedStorage + 8664) = 2;
        if (v23[122] < 2)
          goto LABEL_49;
        goto LABEL_117;
      }
    }
LABEL_21:
    v28 = 0;
    v27 = 1;
    if ((v29 & 1) == 0)
      goto LABEL_27;
  }
  if (!*(_BYTE *)(v30 + 874))
    goto LABEL_21;
  *(_DWORD *)(DerivedStorage + 8664) = 1;
  v75 = *(double *)(DerivedStorage + 8024);
  if (v75 == 0.0)
    v76 = 0.0;
  else
    v76 = Seconds / v75;
  v53 = a7;
  if (v76 > 0.0)
    v16 = v76;
  if (v23[122] >= 2)
  {
LABEL_117:
    v77 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT);
    v53 = a7;
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  v34 = 0;
LABEL_69:
  v54 = *(unsigned int *)(DerivedStorage + 8664);
  if ((_DWORD)v54)
  {
    v55 = *(_QWORD *)(DerivedStorage + 9048);
    if (v55)
    {
      v56 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                                        + 56);
      if (v56)
        v56(v55, CFSTR("bytePumpStats"), CFSTR("StaAlg"), v54, 0);
    }
  }
  if (v53)
  {
LABEL_74:
    segPumpGetLiveEdge(DerivedStorage, a4, 0, (uint64_t)time);
    v57 = *(_OWORD *)&time[16];
    v58 = v96;
    *v53 = *(_OWORD *)time;
    v53[1] = v57;
    v53[2] = v58;
  }
LABEL_75:
  if (*(_BYTE *)(DerivedStorage + 329))
  {
    if (v24 >= v16)
      v59 = v16;
    else
      v59 = v24;
    v60 = a6;
  }
  else
  {
    v59 = 1.0;
    v60 = a6;
    if (!v34)
    {
      if (v24 >= v16)
        v61 = v16;
      else
        v61 = v24;
      if (v61 > 0.99)
        v61 = 0.99;
      v59 = fmaxf(v61, 0.0);
    }
  }
  if (v60)
    *v60 = v59;
  if (a8)
    *a8 = *(_DWORD *)(DerivedStorage + 8664);
  if (a9)
    *a9 = v34;
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(v90, v87);
}

uint64_t segPumpLoadInformation(const void *a1)
{
  uint64_t *DerivedStorage;
  CFIndex v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;

  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  v3 = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if ((_DWORD)v3)
    goto LABEL_9;
  v4 = DerivedStorage[48];
  if (!*(_QWORD *)(v4 + 48) && !*(_QWORD *)(v4 + 56))
  {
    for (i = 48; i != 54; i += 2)
      *(_WORD *)(DerivedStorage[i] + 869) = 257;
    v3 = segPumpRequestIndexForStream(a1, DerivedStorage, v4, 1);
LABEL_9:
    v5 = v3;
    return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v5);
  }
  v5 = 0;
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v5);
}

uint64_t segPumpOpen(const void *a1, uint64_t a2, const void *a3, const void *a4, int a5, _DWORD *a6, BOOL *a7)
{
  uint64_t DerivedStorage;
  CFIndex v14;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int *v16;
  NSObject *v17;
  const void *v18;
  unsigned int v19;
  double v20;
  uint64_t v21;
  int v22;
  double Seconds;
  uint64_t MediaForAllStreams;
  _BYTE *v25;
  uint64_t v26;
  uint64_t v31;
  CFTypeRef v32;
  CFTypeRef v33;
  double v34;
  __int128 v35;
  uint64_t v36;
  const __CFArray *MediaSegmentSpecifiers;
  uint64_t v38;
  uint64_t v39;
  const void *v40;
  const void *v41;
  uint64_t v42;
  BOOL v43;
  uint64_t v44;
  uint64_t i;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const __CFArray *v49;
  BOOL v50;
  uint64_t v54;
  int v56;
  const void *v57;
  CMTimeEpoch epoch;
  CMTimeFlags flags;
  __int128 v60;
  uint64_t v61;
  CMTime rhs;
  os_log_type_t type;
  int v64;
  CMTime lhs;
  CMTimeRange time[2];
  CMTimeValue value;
  CMTimeScale timescale;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  FigRetainProxyRetain();
  value = *(_QWORD *)a2;
  flags = *(_DWORD *)(a2 + 12);
  timescale = *(_DWORD *)(a2 + 8);
  v61 = a2;
  epoch = *(_QWORD *)(a2 + 16);
  v14 = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if ((_DWORD)v14)
  {
    MediaForAllStreams = v14;
    goto LABEL_79;
  }
  v57 = a3;
  if (dword_1EE2A31E8)
  {
    v64 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    if ((flags & 1) != 0)
    {
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      v16 = &dword_1EE2A3000;
    }
    else
    {
      v16 = &dword_1EE2A3000;
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
    if ((*(_DWORD *)(v61 + 36) & 0x1D) == 1 && v16[122])
    {
      v64 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v17 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
    }
  }
  if (!*(_QWORD *)(DerivedStorage + 9016))
  {
    *(_BYTE *)(DerivedStorage + 9032) = 0;
    v18 = *(const void **)(DerivedStorage + 9024);
    if (v18)
    {
      CFRelease(v18);
      *(_QWORD *)(DerivedStorage + 9024) = 0;
    }
  }
  if (a5 && !*(_BYTE *)(*(_QWORD *)(DerivedStorage + 384) + 872))
  {
    v19 = *(_DWORD *)(DerivedStorage + 8);
    v20 = (double)v19;
    if (!v19)
      v20 = 10.0;
    CMTimeMakeWithSeconds(&rhs, v20, 1000);
    lhs.value = value;
    lhs.timescale = timescale;
    lhs.flags = flags;
    lhs.epoch = epoch;
    CMTimeSubtract(&time[0].start, &lhs, &rhs);
    value = time[0].start.value;
    flags = time[0].start.flags;
    timescale = time[0].start.timescale;
    epoch = time[0].start.epoch;
  }
  v21 = *(_QWORD *)(DerivedStorage + 296);
  v22 = flags & 0x1D;
  if (v21)
  {
    Seconds = 0.0;
    if (v22 == 1)
    {
      time[0].start.value = value;
      time[0].start.timescale = timescale;
      time[0].start.flags = flags;
      time[0].start.epoch = epoch;
      if (CMTimeGetSeconds(&time[0].start) >= 0.0)
      {
        time[0].start.value = value;
        time[0].start.timescale = timescale;
        time[0].start.flags = flags;
        time[0].start.epoch = epoch;
        Seconds = CMTimeGetSeconds(&time[0].start);
      }
    }
    FigStreamingCacheHintPlaybackTime(v21, Seconds);
  }
  MediaForAllStreams = 0;
  v25 = (_BYTE *)(DerivedStorage + 8002);
  *(_BYTE *)(DerivedStorage + 8684) = 1;
  v26 = 384;
  __asm { FMOV            V0.2D, #-1.0 }
  v60 = _Q0;
  v56 = 1;
  do
  {
    v31 = *(_QWORD *)(DerivedStorage + v26);
    if (*(_BYTE *)(DerivedStorage + 8684) && *(_DWORD *)(v31 + 160) == 1)
    {
      *(_DWORD *)(v31 + 160) = 2;
      *(_OWORD *)(v31 + 168) = 0u;
      *(_OWORD *)(v31 + 184) = 0u;
      *(_DWORD *)(v31 + 200) = 0;
    }
    if (!*(_QWORD *)(v31 + 232))
    {
      if (a3)
        v32 = CFRetain(a3);
      else
        v32 = 0;
      *(_QWORD *)(v31 + 232) = v32;
    }
    *a6 = *(_DWORD *)(v31 + 72);
    if (a4)
      v33 = CFRetain(a4);
    else
      v33 = 0;
    *(_QWORD *)(v31 + 240) = v33;
    v34 = *(double *)&v60;
    *(_OWORD *)(v31 + 120) = v60;
    *(_QWORD *)(v31 + 304) = 0;
    *(_QWORD *)(v31 + 328) = 0;
    if (v22 == 1)
    {
      time[0].start.value = value;
      time[0].start.timescale = timescale;
      time[0].start.flags = flags;
      time[0].start.epoch = epoch;
      v34 = CMTimeGetSeconds(&time[0].start);
      *(double *)(v31 + 120) = v34;
    }
    else if ((flags & 5) == 5)
    {
      *(_BYTE *)(v31 + 112) = 1;
    }
    if ((*(_DWORD *)(v61 + 36) & 0x1D) == 1)
    {
      v35 = *(_OWORD *)(v61 + 16);
      *(_OWORD *)&time[0].start.value = *(_OWORD *)v61;
      *(_OWORD *)&time[0].start.epoch = v35;
      *(_OWORD *)&time[0].duration.timescale = *(_OWORD *)(v61 + 32);
      CMTimeRangeGetEnd(&lhs, time);
      v34 = *(double *)&lhs.value;
      *(CMTime *)(v31 + 208) = lhs;
    }
    v36 = *(_QWORD *)(v31 + 56);
    if (v36)
    {
      MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v36);
      if (MediaSegmentSpecifiers)
      {
        if (CFArrayGetCount(MediaSegmentSpecifiers) >= 1)
        {
          if (*v25
            || (v40 = a4,
                v41 = a1,
                v42 = *(_QWORD *)(v31 + 1048) + 1000000000 * *(unsigned int *)(DerivedStorage + 8),
                v43 = FigGetUpTimeNanoseconds() < v42,
                a1 = v41,
                a4 = v40,
                a3 = v57,
                v43)
            && !*(_BYTE *)(v31 + 1168))
          {
            segPumpSetStartingOffset(a1, DerivedStorage, v31);
            if (*(_QWORD *)v31 == *(_QWORD *)(DerivedStorage + 8416) && !*(_BYTE *)(DerivedStorage + 8005))
            {
              v38 = *(_QWORD *)(v31 + 56);
              if (v38)
              {
                if (FigMediaPlaylistGetDateStampCount(v38) >= 1 && *(_QWORD *)(DerivedStorage + 168))
                {
                  v54 = *(_QWORD *)(v31 + 880);
                  v39 = segPumpSendDateMapping((uint64_t)a1, DerivedStorage, (unsigned __int8 *)v31);
                  if ((_DWORD)v39 == -15626)
                  {
                    MediaForAllStreams = 4294951670;
LABEL_78:
                    *(_BYTE *)(DerivedStorage + 8684) = 0;
                    goto LABEL_79;
                  }
                  MediaForAllStreams = v39;
                  if (FigRetainProxyIsInvalidated())
                    goto LABEL_79;
                  if (v54 != *(_QWORD *)(v31 + 880))
                    goto LABEL_77;
                }
              }
            }
          }
          else
          {
            v56 = 0;
            *(_BYTE *)(v31 + 866) = 1;
          }
        }
      }
    }
    *(_WORD *)(v31 + 869) = 0;
    if (*(_QWORD *)(*(_QWORD *)(DerivedStorage + v26) + 16))
    {
      if (*(_QWORD *)v31 == *(_QWORD *)(DerivedStorage + 8416))
      {
        v44 = *(_QWORD *)(v31 + 56);
        if (v44)
        {
          if (FigMediaPlaylistGetDateEntryArray(v44))
            segPumpReadyNotification((_QWORD *)DerivedStorage, CFSTR("FBP_TaggedRangeMetadataChanged"), 0);
        }
      }
      MediaForAllStreams = segPumpReadOrScheduleIndexFileRead((uint64_t)a1, DerivedStorage, v31);
      if ((_DWORD)MediaForAllStreams)
        goto LABEL_78;
    }
    v26 += 16;
    ++a6;
  }
  while (v26 != 432);
  for (i = 0; i != 48; i += 16)
  {
    v47 = *(_QWORD *)(DerivedStorage + i + 384);
    v46 = *(_QWORD *)(DerivedStorage + i + 392);
    *(_QWORD *)(v47 + 136) = -1;
    *(_QWORD *)(v47 + 144) = -1;
    *(_QWORD *)(v46 + 136) = -1;
    *(_QWORD *)(v46 + 144) = -1;
  }
  if (v56)
    MediaForAllStreams = segPumpDeliverNextMediaForAllStreams(a1, DerivedStorage, v34);
  if (!a7 || (_DWORD)MediaForAllStreams)
  {
LABEL_77:
    if (!(_DWORD)MediaForAllStreams)
      goto LABEL_79;
    goto LABEL_78;
  }
  v48 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 16 * *(_QWORD *)(DerivedStorage + 8416) + 384) + 56);
  v50 = v48
     && (v49 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v48)) != 0
     && CFArrayGetCount(v49) >= 1
     && !*v25
     && !*(_BYTE *)(DerivedStorage + 8685)
     && (*(_BYTE *)(v61 + 12) & 1) == 0
     && a3 == 0
     && a4 == 0;
  MediaForAllStreams = 0;
  *a7 = v50;
LABEL_79:
  FigRetainProxyRelease();
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, MediaForAllStreams);
}

uint64_t segPumpSetCallback(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  CFIndex v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v7 = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if ((_DWORD)v7)
    goto LABEL_10;
  *(_QWORD *)(DerivedStorage + 160) = a2;
  *(_QWORD *)(DerivedStorage + 168) = a3;
  *(_QWORD *)(DerivedStorage + 176) = FigRetainProxyRetain();
  FigRetainProxyRelease();
  v8 = *(_QWORD *)(DerivedStorage + 8416);
  v9 = *(_QWORD *)(DerivedStorage + 16 * v8 + 384);
  if (*(_QWORD *)v9 == v8 && !*(_BYTE *)(DerivedStorage + 8005))
  {
    v12 = *(_QWORD *)(v9 + 56);
    if (v12)
    {
      if (FigMediaPlaylistGetDateStampCount(v12) >= 1 && *(_QWORD *)(DerivedStorage + 168))
      {
        v7 = segPumpSendDateMapping((uint64_t)a1, DerivedStorage, (unsigned __int8 *)v9);
LABEL_10:
        v10 = v7;
        return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v10);
      }
    }
  }
  v10 = 0;
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v10);
}

uint64_t segPumpSetDeliveryRate(const void *a1, float a2)
{
  uint64_t DerivedStorage;
  CFIndex v5;
  int v6;
  float v7;
  uint64_t v8;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v5 = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if ((_DWORD)v5)
    goto LABEL_16;
  if (!*(_BYTE *)(DerivedStorage + 8712))
  {
    if (a2 >= 0.0)
    {
      *(float *)(DerivedStorage + 8696) = a2;
      goto LABEL_9;
    }
    v5 = FigSignalErrorAt();
LABEL_16:
    v8 = v5;
    return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v8);
  }
  if (*(float *)(DerivedStorage + 8696) == a2)
  {
LABEL_12:
    *(float *)(DerivedStorage + 8696) = a2;
    goto LABEL_13;
  }
  if (!*(_QWORD *)(DerivedStorage + 8816))
  {
    *(_QWORD *)(DerivedStorage + 8816) = 0;
    *(_QWORD *)(DerivedStorage + 8872) = 0;
    *(_OWORD *)(DerivedStorage + 8840) = 0u;
    *(_OWORD *)(DerivedStorage + 8856) = 0u;
    goto LABEL_12;
  }
  FigGetUpTimeNanoseconds();
  v6 = *(unsigned __int8 *)(DerivedStorage + 8712);
  *(_QWORD *)(DerivedStorage + 8816) = 0;
  *(_QWORD *)(DerivedStorage + 8872) = 0;
  *(_OWORD *)(DerivedStorage + 8840) = 0u;
  *(_OWORD *)(DerivedStorage + 8856) = 0u;
  *(float *)(DerivedStorage + 8696) = a2;
  if (v6)
  {
LABEL_13:
    v8 = 0;
    *(_QWORD *)(DerivedStorage + 8704) = 0x3FF0000000000000;
    return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v8);
  }
LABEL_9:
  v7 = fabsf(a2);
  *(double *)(DerivedStorage + 8704) = v7;
  if (v7 < 1.0)
    goto LABEL_13;
  v8 = 0;
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v8);
}

uint64_t segPumpRetrieveAnIFrame(const void *a1, uint64_t a2, int a3, CMTime *a4, CMTime *a5, int *a6)
{
  uint64_t DerivedStorage;
  uint64_t v13;
  CFIndex NextIFrame;
  uint64_t v15;
  uint64_t v16;
  double PlaylistActiveDurationSecs;
  double v18;
  double Seconds;
  double v20;
  double v21;
  uint64_t v22;
  double v23;
  int v24;
  double v25;
  int v27;
  uint64_t v28;
  const __CFArray *MediaSegmentSpecifiers;
  uint64_t v30;
  CMTime v32;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v13 = *(_QWORD *)(DerivedStorage + 384);
  NextIFrame = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if (!(_DWORD)NextIFrame)
  {
    if ((*(_BYTE *)(a2 + 12) & 1) == 0)
      goto LABEL_34;
    if (!a3)
      goto LABEL_34;
    if (!*(_BYTE *)(DerivedStorage + 8712))
      goto LABEL_34;
    if (*(_BYTE *)(DerivedStorage + 8713))
      goto LABEL_34;
    if (*(_BYTE *)(DerivedStorage + 8768))
      goto LABEL_34;
    v15 = *(_QWORD *)(DerivedStorage + 384);
    if (*(_BYTE *)(v15 + 857))
      goto LABEL_34;
    v16 = *(_QWORD *)(v15 + 56);
    if (v16)
    {
      PlaylistActiveDurationSecs = FigMediaPlaylistGetPlaylistActiveDurationSecs(v16);
      v15 = *(_QWORD *)(DerivedStorage + 384);
    }
    else
    {
      PlaylistActiveDurationSecs = *(double *)(DerivedStorage + 344);
    }
    v18 = *(double *)(v15 + 88);
    Seconds = v18;
    if ((a4->flags & 9) == 1)
    {
      v32 = *a4;
      Seconds = CMTimeGetSeconds(&v32);
    }
    v20 = PlaylistActiveDurationSecs + v18;
    v21 = v20;
    if ((a5->flags & 5) == 1)
    {
      v32 = *a5;
      v21 = CMTimeGetSeconds(&v32);
    }
    v22 = *(_QWORD *)(DerivedStorage + 384);
    if (Seconds < *(double *)(v22 + 88))
      Seconds = *(double *)(v22 + 88);
    if (v21 <= v20)
      v23 = v21;
    else
      v23 = v20;
    v24 = *(_DWORD *)(a2 + 12);
    v25 = Seconds;
    if ((~v24 & 9) != 0)
    {
      v25 = v23;
      if ((~v24 & 5) != 0)
      {
        v32 = *(CMTime *)a2;
        v25 = CMTimeGetSeconds(&v32);
      }
    }
    if (v25 < Seconds || v25 > v23)
    {
LABEL_34:
      NextIFrame = FigSignalErrorAt();
    }
    else
    {
      v27 = *(_DWORD *)(v13 + 72) + 1;
      *(_DWORD *)(v13 + 72) = v27;
      *a6 = v27;
      *(_DWORD *)(DerivedStorage + 8776) = a3;
      *(double *)(DerivedStorage + 8784) = v25;
      *(double *)(DerivedStorage + 8792) = Seconds;
      *(double *)(DerivedStorage + 8800) = v23;
      *(double *)(DerivedStorage + 8720) = v20 - Seconds;
      *(double *)(DerivedStorage + 8728) = v20 - v23;
      v28 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 384) + 56);
      if (!v28
        || (MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v28)) == 0
        || CFArrayGetCount(MediaSegmentSpecifiers) <= 0)
      {
        v30 = 0;
        *(_BYTE *)(DerivedStorage + 8768) = 1;
        return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v30);
      }
      NextIFrame = segPumpRetrieveNextIFrame((uint64_t)a1, DerivedStorage);
    }
  }
  v30 = NextIFrame;
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v30);
}

uint64_t segPumpResetCachedMemory(const void *a1)
{
  uint64_t DerivedStorage;
  CFIndex v3;
  const void *v4;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v3 = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if (!(_DWORD)v3)
  {
    v4 = *(const void **)(DerivedStorage + 7920);
    if (v4)
    {
      CFRelease(v4);
      *(_QWORD *)(DerivedStorage + 7920) = 0;
    }
  }
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v3);
}

uint64_t segPumpResetDownloadStatistics(const void *a1)
{
  uint64_t DerivedStorage;
  CFIndex v3;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v3 = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if (!(_DWORD)v3)
    segPumpClearStatistics(DerivedStorage);
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v3);
}

uint64_t segPumpTimeRequiredToSwitchToAlternate(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, uint64_t a8, double *a9)
{
  uint64_t DerivedStorage;
  _BOOL4 v14;
  CFIndex v15;
  uint64_t CurrentRTT;
  double v17;
  uint64_t v18;
  double v19;
  uint64_t v20;
  int PeakBitRate;
  double v22;
  double v23;
  uint64_t v24;
  uint64_t v25;
  double v27;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v14 = *(_QWORD *)(DerivedStorage + 8144) != 0;
  v15 = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if ((_DWORD)v15)
    goto LABEL_21;
  if (!a3)
  {
    v15 = FigSignalErrorAt();
LABEL_21:
    v25 = v15;
LABEL_17:
    v17 = NAN;
    if (!a9)
      return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v25);
LABEL_18:
    *a9 = v17;
    return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v25);
  }
  if ((v14 & (a7 >> 2)) == 0)
  {
    v25 = 0;
    goto LABEL_17;
  }
  v27 = 0.0;
  CurrentRTT = segPumpGetCurrentRTT((_QWORD *)DerivedStorage);
  v17 = NAN;
  if (a2 && a2 != a3)
  {
    v18 = CurrentRTT;
    v19 = *(double *)(DerivedStorage + 16);
    if (v19 <= 0.0)
    {
      LODWORD(v17) = *(_DWORD *)(DerivedStorage + 8);
      v19 = (double)*(unint64_t *)&v17;
    }
    v20 = *(_QWORD *)(DerivedStorage + 7680);
    if (v20)
    {
      PeakBitRate = FigAlternateGetPeakBitRate(*(_QWORD *)(v20 + 8));
      if (PeakBitRate > (int)FigAlternateGetPeakBitRate(a2))
        a2 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 7680) + 8);
    }
    v22 = v19 + segPumpGetEstIndependentInterval(DerivedStorage);
    v23 = v22 * (double)(int)FigAlternateGetPeakBitRate(a3);
    v24 = (uint64_t)((double)(uint64_t)v23 + v19 * (double)(int)FigAlternateGetPeakBitRate(a2));
    segPumpGetSafeNetworkBandwidth(DerivedStorage, &v27, 0, 0);
    v17 = NAN;
    if (v24 && v27 != 0.0)
      v17 = (double)v24 / v27 + (double)v18 / 1000000000.0 * 2.0;
  }
  v25 = 0;
  if (a9)
    goto LABEL_18;
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v25);
}

uint64_t segPumpGetLocalBitrateFraction(const void *a1, uint64_t a2, double *a3, CMTime *a4)
{
  uint64_t DerivedStorage;
  CFIndex v9;
  uint64_t v10;
  __int128 v12;
  __int128 v13;
  double v14;
  double LocalBitrateForSubStream;
  __int128 v16;
  __int128 v17;
  double v18;
  uint64_t v19;
  double v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  CMTime rhs;
  CMTimeRange lhs;
  CMTimeRange v26;
  CMTime start;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  start = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E18];
  v9 = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if ((_DWORD)v9)
    goto LABEL_6;
  if ((*(_BYTE *)(a2 + 12) & 1) == 0
    || (*(_BYTE *)(a2 + 36) & 1) == 0
    || *(_QWORD *)(a2 + 40)
    || (*(_QWORD *)(a2 + 24) & 0x8000000000000000) != 0
    || !a3)
  {
    v9 = FigSignalErrorAt();
LABEL_6:
    v10 = v9;
    return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v10);
  }
  if (*(double *)(DerivedStorage + 8904) <= 0.0)
    goto LABEL_14;
  if ((*(_BYTE *)(DerivedStorage + 8924) & 1) == 0)
    goto LABEL_14;
  if ((*(_BYTE *)(DerivedStorage + 8948) & 1) == 0)
    goto LABEL_14;
  if (*(_QWORD *)(DerivedStorage + 8952))
    goto LABEL_14;
  if ((*(_QWORD *)(DerivedStorage + 8936) & 0x8000000000000000) != 0)
    goto LABEL_14;
  v22 = *(_OWORD *)(DerivedStorage + 8928);
  *(_OWORD *)&v26.start.value = *(_OWORD *)(DerivedStorage + 8912);
  *(_OWORD *)&v26.start.epoch = v22;
  *(_OWORD *)&v26.duration.timescale = *(_OWORD *)(DerivedStorage + 8944);
  v23 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&lhs.start.value = *(_OWORD *)a2;
  *(_OWORD *)&lhs.start.epoch = v23;
  *(_OWORD *)&lhs.duration.timescale = *(_OWORD *)(a2 + 32);
  if (CMTimeRangeContainsTimeRange(&v26, &lhs))
  {
    v20 = *(double *)(DerivedStorage + 8904);
  }
  else
  {
LABEL_14:
    v12 = *(_OWORD *)(MEMORY[0x1E0CA2E40] + 32);
    v13 = *MEMORY[0x1E0CA2E40];
    *(_OWORD *)&v26.start.epoch = *(_OWORD *)(MEMORY[0x1E0CA2E40] + 16);
    *(_OWORD *)&v26.duration.timescale = v12;
    *(_OWORD *)&v26.start.value = v13;
    v14 = 0.0;
    LocalBitrateForSubStream = 0.0;
    if (*(_QWORD *)(*(_QWORD *)(DerivedStorage + 400) + 16))
    {
      v16 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)&lhs.start.value = *(_OWORD *)a2;
      *(_OWORD *)&lhs.start.epoch = v16;
      *(_OWORD *)&lhs.duration.timescale = *(_OWORD *)(a2 + 32);
      LocalBitrateForSubStream = segPumpGetLocalBitrateForSubStream(DerivedStorage, 1, (uint64_t)&lhs, &start, &v26);
    }
    if (*(_QWORD *)(*(_QWORD *)(DerivedStorage + 384) + 16))
    {
      v17 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)&lhs.start.value = *(_OWORD *)a2;
      *(_OWORD *)&lhs.start.epoch = v17;
      *(_OWORD *)&lhs.duration.timescale = *(_OWORD *)(a2 + 32);
      v14 = segPumpGetLocalBitrateForSubStream(DerivedStorage, 0, (uint64_t)&lhs, &start, &v26);
    }
    if (v14 >= 0.0
      && (v18 = LocalBitrateForSubStream + v14, v18 > 2.22044605e-16)
      && LocalBitrateForSubStream >= 0.0
      && (v19 = *(_QWORD *)(DerivedStorage + 8144)) != 0)
    {
      v20 = v18 / (double)(int)FigAlternateGetPeakBitRate(*(_QWORD *)(v19 + 8));
      if (v20 < 0.33)
        v20 = 0.33;
      if (v20 > 1.0)
        v20 = 1.0;
      if (!*(_BYTE *)(DerivedStorage + 8712))
      {
        *(double *)(DerivedStorage + 8904) = v20;
        v21 = *(_OWORD *)&v26.start.epoch;
        *(_OWORD *)(DerivedStorage + 8912) = *(_OWORD *)&v26.start.value;
        *(_OWORD *)(DerivedStorage + 8928) = v21;
        *(_OWORD *)(DerivedStorage + 8944) = *(_OWORD *)&v26.duration.timescale;
      }
    }
    else
    {
      v20 = *(double *)(DerivedStorage + 8904);
      if (v20 <= 0.0)
        v20 = 1.0;
    }
  }
  *a3 = v20;
  if (a4)
  {
    if ((start.flags & 1) == 0)
    {
      LODWORD(v20) = *(_DWORD *)(DerivedStorage + 8);
      CMTimeMakeWithSeconds(&rhs, (double)*(unint64_t *)&v20 + 0.5, 1000);
      *(_OWORD *)&lhs.start.value = *(_OWORD *)a2;
      lhs.start.epoch = *(_QWORD *)(a2 + 16);
      CMTimeAdd(&v26.start, &lhs.start, &rhs);
      start = v26.start;
    }
    v10 = 0;
    *a4 = start;
  }
  else
  {
    v10 = 0;
  }
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v10);
}

uint64_t segPumpSnapToTime(const void *a1, CMTime *a2, int a3, CMTime *a4, uint64_t a5)
{
  uint64_t DerivedStorage;
  CFIndex v11;
  CMTimeFlags flags;
  uint64_t v13;
  double Seconds;
  double v15;
  int v16;
  float v17;
  double v18;
  int v19;
  uint64_t v20;
  double v21;
  double v22;
  CFIndex v23;
  CMTime *p_time1;
  double i;
  const __CFArray *MediaSegmentSpecifiers;
  const __CFArray *v27;
  const void *ValueAtIndex;
  double *MediaFilePrivateData;
  double v30;
  double v31;
  double v32;
  double v34;
  uint64_t v35;
  __int128 v36;
  double MaxTime;
  double MinimumPrebufferReservation;
  __int128 v39;
  CMTimeEpoch v40;
  uint64_t v41;
  CFIndex j;
  const __CFArray *Count;
  const __CFArray *v44;
  const void *v45;
  double *v46;
  double v47;
  double *v48;
  unint64_t v49;
  uint64_t v50;
  CMTimeEpoch epoch;
  CMTimeEpoch v52;
  double v53;
  double v54;
  const void *NextSegment;
  double *v56;
  uint64_t v57;
  uint64_t v59;
  const __CFArray *v60;
  double v61;
  uint64_t v62;
  uint64_t v63;
  double *v64;
  double v65;
  uint64_t v66;
  double *v67;
  double v68;
  uint64_t v69;
  double *v70;
  double v71;
  __int128 v72;
  CMTime v73;
  CMTime v74;
  CMTime v75;
  CMTime time2;
  CMTime time1;
  CMTime v78;
  CMTime v79;
  CMTime v80;
  _BYTE time[32];
  __int128 v82;
  __int128 v83;
  __int128 v84;
  uint64_t v85;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v11 = segPumpAPILockAndEnsureAPIStatus(a1, 0);
  if ((_DWORD)v11)
    goto LABEL_98;
  flags = a2->flags;
  if ((flags & 1) == 0 || !a4 || !a5)
  {
    v11 = FigSignalErrorAt();
LABEL_98:
    v35 = v11;
    return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v35);
  }
  if (a3 == 4)
  {
    v79 = *a2;
    v13 = *(_QWORD *)(DerivedStorage + 16 * *(_QWORD *)(DerivedStorage + 8416) + 384);
    *(_OWORD *)time = *(_OWORD *)&a2->value;
    *(_QWORD *)&time[16] = a2->epoch;
    Seconds = CMTimeGetSeconds((CMTime *)time);
    if (v13)
    {
      v15 = Seconds;
      if (!*(_QWORD *)(DerivedStorage + 8144)
        || !*(_QWORD *)(DerivedStorage + 296)
        || !FigAlternateGetLastKnownValueForIsFullyCached())
      {
        v85 = 0;
        v83 = 0u;
        v84 = 0u;
        v82 = 0u;
        memset(time, 0, sizeof(time));
        segPumpMakeNetworkPrediction(DerivedStorage, (uint64_t)time);
        if (!v16)
        {
          v17 = *(float *)(DerivedStorage + 8696);
          if (v17 > 0.0 && v17 <= 2.0)
          {
            v18 = (double)*(uint64_t *)time;
            v19 = _os_feature_enabled_impl();
            v20 = *(_QWORD *)(v13 + 56);
            if (v19)
            {
              if (v20)
              {
                *(_QWORD *)time = 0;
                v80.value = 0;
                v78.value = 0;
                time1.value = 0;
                segPumpGetRequiredBandwidthForCurrentStreamingAlternate(DerivedStorage);
                v22 = v21;
                segPumpGetStartupRequirements(DerivedStorage, *(_DWORD *)(DerivedStorage + 8), (double *)time, (double *)&v80.value, (double *)&v78.value, (double *)&time1.value, v21);
                v23 = 0;
                if (*(double *)&v80.value >= v18)
                  p_time1 = &v78;
                else
                  p_time1 = &time1;
                for (i = v15 + v22 * *(double *)&p_time1->value / v18 * *(float *)(DerivedStorage + 8696); ; i = v31)
                {
                  MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(v13 + 56));
                  if (MediaSegmentSpecifiers)
                    MediaSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MediaSegmentSpecifiers);
                  if (v23 >= (uint64_t)MediaSegmentSpecifiers)
                    break;
                  v27 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(v13 + 56));
                  ValueAtIndex = CFArrayGetValueAtIndex(v27, v23);
                  MediaFilePrivateData = (double *)segPumpGetMediaFilePrivateData(ValueAtIndex);
                  v30 = MediaFilePrivateData[4];
                  v31 = v30 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
                  v32 = MediaFilePrivateData[4];
                  if (v32 <= i && i < v31)
                  {
                    v34 = i + v22 * (i - v32) / v18 * *(float *)(DerivedStorage + 8696);
                    if (v34 < v31)
                    {
                      CMTimeMakeWithSeconds(&v79, v34, 1000000);
                      break;
                    }
                  }
                  else
                  {
                    v31 = i;
                  }
                  ++v23;
                }
              }
            }
            else if (v20)
            {
              for (j = 0; ; ++j)
              {
                Count = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v20);
                if (Count)
                  Count = (const __CFArray *)CFArrayGetCount(Count);
                if (j >= (uint64_t)Count)
                  break;
                v44 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(v13 + 56));
                v45 = CFArrayGetValueAtIndex(v44, j);
                v46 = (double *)segPumpGetMediaFilePrivateData(v45);
                v47 = v46[4];
                if (v47 <= v15)
                {
                  v48 = v46;
                  if (v15 <= v47 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v45))
                  {
                    LODWORD(v49) = *(_DWORD *)(DerivedStorage + 8);
                    v53 = (v15 - v48[4]) / (double)v49;
                    segPumpGetRequiredBandwidthForCurrentStreamingAlternate(DerivedStorage);
                    if ((v53 + 1.0) * (v54 * *(float *)(DerivedStorage + 8696)) >= v18)
                    {
                      NextSegment = (const void *)FigMediaSegmentSpecifierGetNextSegment((uint64_t)v45);
                      if (NextSegment)
                      {
                        v56 = (double *)segPumpGetMediaFilePrivateData(NextSegment);
                        CMTimeMakeWithSeconds((CMTime *)time, v56[4] + 0.000001, 1000000);
                        v79 = *(CMTime *)time;
                      }
                    }
                    break;
                  }
                }
                v20 = *(_QWORD *)(v13 + 56);
              }
            }
          }
        }
      }
    }
    if (!*(_QWORD *)(DerivedStorage + 8416))
    {
      v59 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 400) + 56);
      if (v59)
      {
        v60 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v59);
        if (v60)
        {
          if (CFArrayGetCount(v60) >= 1)
          {
            v80 = v79;
            *(CMTime *)time = v79;
            v61 = CMTimeGetSeconds((CMTime *)time);
            v62 = *(_QWORD *)(DerivedStorage + 384);
            if (!*(_QWORD *)(v62 + 16))
              v62 = 0;
            v63 = *(_QWORD *)(DerivedStorage + 400);
            if (*(_QWORD *)(v63 + 16) && v62)
            {
              v64 = *(double **)(v62 + 336);
              if (v64)
              {
                while (1)
                {
                  v65 = v64[3];
                  if (v65 <= v61 && v65 + v64[5] > v61)
                    break;
                  v64 = *(double **)v64;
                  if (!v64)
                    goto LABEL_76;
                }
                v66 = *((_QWORD *)v64 + 4);
              }
              else
              {
LABEL_76:
                v66 = -1;
              }
              v67 = *(double **)(v63 + 336);
              if (v67)
              {
                while (1)
                {
                  v68 = v67[3];
                  if (v68 <= v61 && v68 + v67[5] > v61)
                    break;
                  v67 = *(double **)v67;
                  if (!v67)
                    goto LABEL_82;
                }
                v69 = *((_QWORD *)v67 + 4);
              }
              else
              {
LABEL_82:
                v69 = -1;
              }
              if (v66 <= v69)
              {
                if (v69 > v66)
                {
                  v70 = (double *)(v62 + 336);
                  while (1)
                  {
                    v70 = *(double **)v70;
                    if (!v70)
                      break;
                    if (*((_QWORD *)v70 + 4) == v69)
                    {
LABEL_93:
                      v71 = v70[3];
                      if (v71 == -1.0)
                        break;
                      CMTimeMakeWithSeconds((CMTime *)time, v71, 1000);
                      goto LABEL_95;
                    }
                  }
                }
              }
              else
              {
                v70 = (double *)(v63 + 336);
                while (1)
                {
                  v70 = *(double **)v70;
                  if (!v70)
                    break;
                  if (*((_QWORD *)v70 + 4) == v66)
                    goto LABEL_93;
                }
              }
            }
            *(CMTime *)time = v80;
LABEL_95:
            v79 = *(CMTime *)time;
          }
        }
      }
    }
    v35 = 0;
    *a4 = v79;
    goto LABEL_63;
  }
  if (a3 != 3)
  {
    v35 = 0;
    v36 = *(_OWORD *)&a2->value;
    a4->epoch = a2->epoch;
    *(_OWORD *)&a4->value = v36;
LABEL_63:
    v57 = MEMORY[0x1E0CA2E18];
    *(_OWORD *)a5 = *MEMORY[0x1E0CA2E18];
    *(_QWORD *)(a5 + 16) = *(_QWORD *)(v57 + 16);
    return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v35);
  }
  memset(&v74, 0, sizeof(v74));
  if ((flags & 4) != 0)
  {
    MaxTime = segPumpGetMaxTime((_QWORD *)DerivedStorage);
    MinimumPrebufferReservation = segPumpGetMinimumPrebufferReservation(DerivedStorage, 0);
    CMTimeMakeWithSeconds(&v74, MaxTime - (MinimumPrebufferReservation + *(double *)(DerivedStorage + 7960)), 1000);
  }
  else
  {
    v74 = *a2;
  }
  v73 = v74;
  *(_OWORD *)time = *MEMORY[0x1E0CA2E18];
  v39 = *(_OWORD *)time;
  v40 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  *(_QWORD *)&time[16] = v40;
  *(_OWORD *)&v80.value = *(_OWORD *)time;
  v80.epoch = v40;
  memset(&v79, 0, sizeof(v79));
  v41 = *(_QWORD *)(DerivedStorage + 384);
  if (*(_QWORD *)(v41 + 16))
  {
    v72 = *(_OWORD *)time;
    v78 = v74;
    segPumpStreamSnapToSegmentBoundary(v41, &v78, (uint64_t)&v80, &v79);
    v39 = v72;
  }
  else
  {
    *(_OWORD *)&v79.value = *(_OWORD *)time;
    v79.epoch = v40;
  }
  memset(&v78, 0, sizeof(v78));
  v50 = *(_QWORD *)(DerivedStorage + 400);
  if (*(_QWORD *)(v50 + 16))
  {
    time1 = v73;
    segPumpStreamSnapToSegmentBoundary(v50, &time1, (uint64_t)time, &v78);
  }
  else
  {
    *(_OWORD *)&v78.value = v39;
    v78.epoch = v40;
  }
  if ((v79.flags & 1) != 0 || (v78.flags & 1) != 0)
  {
    time1 = v79;
    time2 = v78;
    CMTimeMinimum(&v73, &time1, &time2);
    if ((v80.flags & 1) != 0)
    {
      if ((time[12] & 1) != 0)
      {
        time2 = v80;
        v75 = *(CMTime *)time;
        CMTimeMaximum(&time1, &time2, &v75);
        *(_OWORD *)a5 = *(_OWORD *)&time1.value;
        epoch = time1.epoch;
      }
      else
      {
        *(_OWORD *)a5 = *(_OWORD *)&v80.value;
        epoch = v80.epoch;
      }
    }
    else
    {
      *(_OWORD *)a5 = *(_OWORD *)time;
      epoch = *(_QWORD *)&time[16];
    }
    *(_QWORD *)(a5 + 16) = epoch;
  }
  v35 = 0;
  time1 = v73;
  v52 = v73.epoch;
  *(_OWORD *)&a4->value = *(_OWORD *)&v73.value;
  a4->epoch = v52;
  return segPumpAPIUnlockAndSendNotificationThenCheckAPIStatus(a1, v35);
}

uint64_t segPumpGetDeliveredTimeStamp(uint64_t a1, double *a2)
{
  uint64_t result;
  const void *v4;
  const void *MediaFilePrivateData;
  double v6;

  *a2 = 0.0;
  result = *(_QWORD *)(a1 + 56);
  if (result)
  {
    FigMediaPlaylistGetMediaSegmentSpecifiers(result);
    result = FigCFArrayGetLastValue();
    if (result)
    {
      v4 = (const void *)result;
      while (1)
      {
        MediaFilePrivateData = segPumpGetMediaFilePrivateData(v4);
        if (*((_BYTE *)MediaFilePrivateData + 73))
          break;
        result = FigMediaSegmentSpecifierGetPreviousSegment((uint64_t)v4);
        v4 = (const void *)result;
        if (!result)
          return result;
      }
      v6 = *((double *)MediaFilePrivateData + 4);
      *a2 = v6 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v4);
      return 1;
    }
  }
  return result;
}

uint64_t segPumpStreamNeedsMore(const void *a1, uint64_t a2, uint64_t a3)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;

  *(_BYTE *)(a3 + 870) = 0;
  if (!*(_BYTE *)(a3 + 869) && !*(_BYTE *)(a3 + 1169))
    return 0;
  *(_BYTE *)(a3 + 869) = 0;
  *(_BYTE *)(a3 + 1169) = 0;
  if (!*(_BYTE *)(a2 + 8684) || !*(_QWORD *)(a3 + 16))
    return 0;
  if (dword_1EE2A31E8)
  {
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
    fig_log_call_emit_and_clean_up_after_send_and_compose();
  }
  v8 = *(_QWORD *)(a3 + 56);
  if (v8)
  {
    v9 = *(_QWORD *)(a3 + 1048);
    v10 = *(_DWORD *)(a2 + 8);
    if (!FigMediaPlaylistHasEndTag(v8)
      && (FigGetUpTimeNanoseconds() >= v9 + 1000000000 * v10 || *(_BYTE *)(a3 + 1168)))
    {
      return segPumpReadOrScheduleIndexFileRead((uint64_t)a1, a2, a3);
    }
  }
  result = segPumpDeliverNextMediaForSingleStream(a1, a2, a3);
  if (!(_DWORD)result)
    return segPumpReadOrScheduleIndexFileRead((uint64_t)a1, a2, a3);
  return result;
}

void segPumpCancelAllReadAheadAndResetData(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  for (i = 0; i != 3; ++i)
  {
    v3 = *(_QWORD *)(a1 + 16 * i + 384);
    if (*(uint64_t *)(v3 + 776) >= 1)
    {
      v4 = 0;
      do
      {
        segPumpStreamCancelReadAheadAndResetDataAtIndex(a1, v3, 0);
        ++v4;
      }
      while (v4 < *(_QWORD *)(v3 + 776));
    }
  }
}

const __CFArray *segPumpResetAllMediaFilePrivateDataForStream(uint64_t a1)
{
  const __CFArray *result;
  CFIndex i;
  const __CFArray *MediaSegmentSpecifiers;
  const __CFArray *v5;
  const void *ValueAtIndex;
  char *MediaFilePrivateData;
  const __CFArray *PartialSegments;
  CFIndex v9;
  CFIndex Count;
  const void *v11;
  char *v12;
  CFIndex j;
  const __CFArray *MapSegmentSpecifiers;
  const void *v15;
  char *v16;

  result = *(const __CFArray **)(a1 + 56);
  if (result)
  {
    for (i = 0; ; ++i)
    {
      MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers((uint64_t)result);
      if (MediaSegmentSpecifiers)
        MediaSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MediaSegmentSpecifiers);
      if (i >= (uint64_t)MediaSegmentSpecifiers)
        break;
      v5 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a1 + 56));
      ValueAtIndex = CFArrayGetValueAtIndex(v5, i);
      MediaFilePrivateData = (char *)segPumpGetMediaFilePrivateData(ValueAtIndex);
      if (!MediaFilePrivateData[96])
      {
        *((_QWORD *)MediaFilePrivateData + 6) = 0;
        *((_QWORD *)MediaFilePrivateData + 7) = 0;
        *(_DWORD *)(MediaFilePrivateData + 71) = 0;
        *((_QWORD *)MediaFilePrivateData + 8) = 0;
        *((_QWORD *)MediaFilePrivateData + 14) = 0;
        *((_QWORD *)MediaFilePrivateData + 15) = 0;
        PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)ValueAtIndex);
        v9 = 0;
        if (PartialSegments)
        {
LABEL_9:
          Count = CFArrayGetCount(PartialSegments);
          goto LABEL_11;
        }
        while (1)
        {
          Count = 0;
LABEL_11:
          if (v9 >= Count)
            break;
          v11 = CFArrayGetValueAtIndex(PartialSegments, v9);
          v12 = (char *)segPumpGetMediaFilePrivateData(v11);
          *((_QWORD *)v12 + 7) = 0;
          *((_QWORD *)v12 + 8) = 0;
          *((_QWORD *)v12 + 6) = 0;
          *(_DWORD *)(v12 + 71) = 0;
          ++v9;
          *((_QWORD *)v12 + 14) = 0;
          *((_QWORD *)v12 + 15) = 0;
          if (PartialSegments)
            goto LABEL_9;
        }
      }
      result = *(const __CFArray **)(a1 + 56);
    }
    for (j = 0; ; ++j)
    {
      result = (const __CFArray *)FigMediaPlaylistGetMapSegmentSpecifiers(*(_QWORD *)(a1 + 56));
      if (result)
        result = (const __CFArray *)CFArrayGetCount(result);
      if (j >= (uint64_t)result)
        break;
      MapSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMapSegmentSpecifiers(*(_QWORD *)(a1 + 56));
      v15 = CFArrayGetValueAtIndex(MapSegmentSpecifiers, j);
      v16 = (char *)segPumpGetMediaFilePrivateData(v15);
      if (!v16[96])
      {
        *((_QWORD *)v16 + 6) = 0;
        *((_QWORD *)v16 + 7) = 0;
        *(_DWORD *)(v16 + 71) = 0;
        *((_QWORD *)v16 + 8) = 0;
        *((_QWORD *)v16 + 14) = 0;
        *((_QWORD *)v16 + 15) = 0;
      }
    }
  }
  return result;
}

uint64_t segPumpDeliverNextMediaForAllStreams(const void *a1, uint64_t a2, double a3)
{
  uint64_t result;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t i;
  _QWORD *v10;
  uint64_t v11;
  const __CFArray *MediaSegmentSpecifiers;
  uint64_t v13;
  const void *v14;
  const void **v15;
  const void **v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFArray *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  uint64_t v25;
  double v26;
  double v27;
  float v28;
  uint64_t UpTimeNanoseconds;
  CMTime v30;
  CMTime v31;
  __int16 v32;
  _QWORD v33[3];
  _QWORD v34[3];
  _QWORD v35[4];

  v35[3] = *MEMORY[0x1E0C80C00];
  memset(v35, 0, 24);
  memset(v34, 0, sizeof(v34));
  memset(v33, 0, sizeof(v33));
  v32 = 0;
  if (*(_BYTE *)(a2 + 8712))
  {
    if (*(_BYTE *)(a2 + 8768))
      return segPumpTryIFrameFetch((uint64_t)a1, a2);
    if (*(_BYTE *)(a2 + 8713))
      return segPumpTryIFrameFetch((uint64_t)a1, a2);
    v25 = *(_QWORD *)(a2 + 384);
    if (!*(_BYTE *)(v25 + 857) && !*(_BYTE *)(v25 + 862))
      return segPumpTryIFrameFetch((uint64_t)a1, a2);
    v26 = *(double *)(v25 + 120);
    if (v26 >= 0.0)
    {
      v27 = dbl_1932FD110[*(float *)(a2 + 8736) >= 0.0];
      CMTimeMakeWithSeconds(&v31, v26, 1000);
      v28 = *(float *)(a2 + 8736);
      UpTimeNanoseconds = FigGetUpTimeNanoseconds();
      CMTimeMakeWithSeconds(&v30, v27 + *(double *)(v25 + 120), 1000);
      return segPumpStepNextFrame(a1, &v31, UpTimeNanoseconds, &v30, 1, 0, v28);
    }
    return 0;
  }
  v6 = v34;
  v7 = v35;
  v8 = v33;
  for (i = 384; i != 432; i += 16)
  {
    v10 = *(_QWORD **)(a2 + i);
    v11 = v10[7];
    if (v11)
    {
      MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v11);
      if (MediaSegmentSpecifiers)
      {
        if (CFArrayGetCount(MediaSegmentSpecifiers) >= 1)
        {
          *v8 = v10[10];
          if (v10[32])
          {
            *v7 = 0;
          }
          else
          {
            result = segPumpDetermineMediaSegmentToDeliver(a2, (uint64_t)v10, v7, v6);
            if ((_DWORD)result)
              return result;
          }
        }
      }
    }
    ++v6;
    ++v7;
    ++v8;
  }
  v13 = *(_QWORD *)(a2 + 8416);
  v14 = (const void *)v35[v13];
  if (v14 && *(_QWORD *)(a2 + 296))
  {
    result = segPumpCheckCachedVariantsAndRequestSwitch(a2, *(_QWORD *)(a2 + 16 * v13 + 384), v14, 1, a3);
    if ((_DWORD)result)
      return result;
    if (FigRetainProxyIsInvalidated())
      return 0;
  }
  v15 = (const void **)v35;
  v16 = (const void **)v34;
  v17 = v33;
  v18 = 384;
  while (1)
  {
    v19 = *(_QWORD *)(a2 + v18);
    v20 = *(_QWORD *)(v19 + 56);
    if (v20)
    {
      v21 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v20);
      if (v21)
      {
        if (CFArrayGetCount(v21) >= 1
          && (*(_DWORD *)(v19 + 160) & 0xFFFFFFFE) == 4
          && !*(_BYTE *)(v19 + 866)
          && *(_QWORD *)(v19 + 80) == *v17
          && !segPumpStreamShouldYieldToTrialSwitch(a2, (_QWORD *)v19))
        {
          v22 = *v16;
          v23 = *v16;
          if (!*v16)
            v23 = *v15;
          if (segPumpStreamReadAheadPermitsNextRead(a2, v19, (uint64_t)v23) && !*(_BYTE *)(v19 + 1136))
          {
            HIBYTE(v32) = 0;
            v24 = *v15;
            if (*v15)
            {
              result = segPumpFetchOrDispatchMediaSegment((uint64_t)a1, a2, v19, *v15, v22, (char *)&v32, (_BYTE *)&v32 + 1);
              if ((_DWORD)result)
                return result;
            }
            else
            {
              v24 = *(const void **)(v19 + 256);
              *v15 = v24;
            }
            if (!(_BYTE)v32)
            {
              result = segPumpStreamDoDeliveryFollowUp((uint64_t)a1, a2, v19, HIBYTE(v32), v24, 0);
              if ((_DWORD)result)
                break;
            }
          }
        }
      }
    }
    ++v15;
    ++v16;
    ++v17;
    v18 += 16;
    if (v18 == 432)
      return 0;
  }
  return result;
}

__n128 segPumpStopConcurrentStream(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __n128 result;

  if (*(uint64_t *)(a2 + 776) >= 1)
  {
    v4 = 0;
    do
    {
      segPumpStreamCancelReadAheadAndResetDataAtIndex(a1, a2, 0);
      ++v4;
    }
    while (v4 < *(_QWORD *)(a2 + 776));
  }
  segPumpStreamCancelPreloadReadAndResetData(a1, a2);
  segPumpStreamCancelPreloadMapReadAndResetData(a1, a2);
  segPumpStopStream(a1, a2, 0);
  segPumpStreamDisposeStorage((_QWORD *)a2);
  *(_BYTE *)(a2 + 866) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(__n128 *)(a2 + 120) = result;
  ++*(_DWORD *)(a2 + 72);
  return result;
}

BOOL segPumpRejectSwitchDueToStallRisk(uint64_t a1, uint64_t a2, int a3, CMTime *a4, CMTime *a5, int a6, int a7, double a8)
{
  unsigned __int8 *v16;
  int v17;
  uint64_t v18;
  double v19;
  Float64 Seconds;
  uint64_t v21;
  double v22;
  double v23;
  const __CFArray *MediaSegmentSpecifiers;
  uint64_t v25;
  unsigned int v26;
  double v27;
  uint64_t NextSegment;
  int v29;
  double v31;
  uint64_t v32;
  double v33;
  double v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const __CFArray *v39;
  uint64_t v40;
  double v41;
  unsigned int v42;
  uint64_t v43;
  int v44;
  const __CFURL *PlaylistAlternateURL;
  __CFDictionary *v46;
  int PeakBitRate;
  _BOOL4 v49;
  unsigned int v50;
  uint64_t v54;
  const void *StableStreamIdentifier;
  int v56;
  OpaqueCMBlockBuffer *v57;
  const void *v58;
  uint64_t SavedEntry;
  const __CFURL *v60;
  const __CFURL *URLForCacheLookup;
  int v62;
  double v63;
  double v64;
  CFTypeRef v65;
  uint64_t v66;
  uint64_t v67;
  double v68;
  int v69;
  uint64_t v70;
  int AverageBitRate;
  int v72;
  BOOL v73;
  BOOL v74;
  int v75;
  CMTimeValue value;
  double v77;
  double TimeInSeconds;
  double v79;
  uint64_t v80;
  uint64_t v81;
  CMTime v82;
  CFTypeRef cf;
  int v84;
  uint64_t v85;
  uint64_t v86;
  CMBlockBufferRef theBuffer;
  CFTypeRef v88;
  CMTime time;

  v16 = (unsigned __int8 *)(a1 + 7993);
  v17 = segPumpStreamBitRateRequiredForStream(a1, *(_QWORD **)(a1 + 384));
  if (FigAlternateIsIFrameOnly(a2))
  {
    v82 = *a5;
    if (v16[719])
    {
      v18 = *(_QWORD *)(a1 + 384);
      v19 = segPumpPredictIFrameDownload(a1, 0);
      time = v82;
      Seconds = CMTimeGetSeconds(&time);
      v21 = *(_QWORD *)(v18 + 56);
      v22 = 2.0;
      v23 = Seconds * 0.0 / v19;
      if (v21)
      {
        MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v21);
        if (MediaSegmentSpecifiers)
        {
          if (CFArrayGetCount(MediaSegmentSpecifiers) >= 1)
          {
            v25 = *(_QWORD *)(v18 + 256);
            if (v25)
            {
              v26 = 0;
              v27 = 0.0;
              do
              {
                v27 = v27 + (double)(8 * FigMediaSegmentSpecifierGetBytesToRead(v25));
                NextSegment = FigMediaSegmentSpecifierGetNextSegment(v25);
                v29 = v26 + 1;
                if (!NextSegment)
                  break;
                v25 = NextSegment;
              }
              while (v26++ < 7);
              v31 = v27 / (double)v29;
            }
            else
            {
              v31 = 0.0;
            }
            v22 = v31 * ((double)a3 / (double)(int)segPumpStreamBitRateRequiredForStream(a1, *(_QWORD **)(a1 + 384)));
          }
        }
      }
    }
    else
    {
      v23 = 0.0;
      v22 = 1.0;
    }
    goto LABEL_57;
  }
  v32 = *(_QWORD *)(a1 + 16 * *(_QWORD *)(a1 + 8416) + 384);
  time = *a4;
  v33 = CMTimeGetSeconds(&time);
  v34 = 0.0;
  if ((a5->flags & 0x1D) == 1)
  {
    time = *a5;
    v34 = CMTimeGetSeconds(&time);
  }
  v35 = 0;
  v36 = 384;
  v23 = 0.0;
  v22 = 1.0;
  do
  {
    v37 = *(_QWORD *)(a1 + v36);
    if (*(_QWORD *)(v37 + 16))
    {
      if (v17 < a3)
      {
        v38 = *(_QWORD *)(v37 + 56);
        if (!v38)
          goto LABEL_57;
        v39 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v38);
        if (!v39 || CFArrayGetCount(v39) < 1)
          goto LABEL_57;
      }
      if (v35)
      {
        v35 = 1;
      }
      else
      {
        v40 = *(_QWORD *)(*(_QWORD *)(a1 + v36) + 56);
        if (v40)
          v35 = FigMediaPlaylistGetDateStampCount(v40) > 0;
        else
          v35 = 0;
      }
    }
    v36 += 16;
  }
  while (v36 != 432);
  if (!a7)
  {
    v23 = 14.0;
    v22 = 13.0;
    goto LABEL_38;
  }
  v23 = v34 * a8;
  v22 = (double)segPumpBitsRequiredToSwitch(a1, a3, v35, v33, v34);
  if (v16[199])
  {
    if ((double)a3 <= a8)
      goto LABEL_32;
  }
  else
  {
    v50 = segPumpStreamHavePerSegmentBitrate(v32);
    if ((double)a3 <= a8 || v50 != 0)
      goto LABEL_32;
  }
  v41 = (double)v17;
  if (v17 >= a3)
    v41 = a8;
  v22 = *(double *)(a1 + 8064) * (double)segPumpBitsRequiredToSwitch(a1, (int)v41, v35, v33, v34) + v22;
LABEL_32:
  if (a6)
    v23 = v23 * 0.5;
  if (v23 < v22)
    goto LABEL_57;
LABEL_38:
  v42 = segPumpStreamHavePerSegmentBitrate(v32);
  if (!a7 || !v42)
  {
    if (v17 >= a3)
    {
      v49 = (double)a3 > a8 && a7 != 0;
      return v23 < v22 || v49;
    }
    goto LABEL_57;
  }
  v82.value = 0;
  v88 = *(CFTypeRef *)(v32 + 56);
  time.value = 0;
  v86 = 0;
  theBuffer = 0;
  v85 = 0;
  if (*(_QWORD *)(a1 + 296))
  {
    v81 = v32;
    v43 = *(_QWORD *)v32;
    v44 = *(_QWORD *)v32;
    PlaylistAlternateURL = (const __CFURL *)FigAlternateGetPlaylistAlternateURL(a2);
    v46 = (__CFDictionary *)FigCFHTTPCreateURLString(PlaylistAlternateURL);
    if (v44)
      PeakBitRate = 0;
    else
      PeakBitRate = FigAlternateGetPeakBitRate(a2);
    v54 = *(_QWORD *)(a1 + 296);
    StableStreamIdentifier = (const void *)FigAlternateGetStableStreamIdentifier(a2);
    v56 = FigStreamingCacheCreateMediaStream(v54, v43, v46, StableStreamIdentifier, PeakBitRate, v44 == 2, &v86);
    if (v46)
      CFRelease(v46);
    v32 = v81;
    if (!v56)
      FigStreamingCacheMediaStreamCopyPlaylist(*(_QWORD *)(a1 + 296), v86, (unint64_t)&theBuffer, 0);
  }
  v57 = theBuffer;
  if (!theBuffer)
  {
    v58 = (const void *)FigAlternateGetPlaylistAlternateURL(a2);
    SavedEntry = segPumpFindSavedEntry(a1, v58, 0, 0);
    if (SavedEntry)
      segPumpCreateIndexFileBBFromSavedIndexFile(a1, SavedEntry, (CFTypeRef *)&theBuffer);
    v57 = theBuffer;
    if (!theBuffer)
      goto LABEL_81;
  }
  if (CMBlockBufferGetDataLength(v57))
  {
    v60 = (const __CFURL *)FigAlternateGetPlaylistAlternateURL(a2);
    URLForCacheLookup = (const __CFURL *)FigAlternateGetURLForCacheLookup(a2);
    v84 = 0;
    v88 = 0;
    cf = 0;
    if (!FigCFHTTPCopyQueryParamsAsDict((uint64_t)v60, (CFMutableDictionaryRef *)&cf))
    {
      v62 = FigStreamPlaylistParse(theBuffer, v60, URLForCacheLookup, &v84, 0, 0, *v16, *(unsigned __int8 *)(a1 + 339), 0, *(_QWORD *)(a1 + 8384), *(const __CFDictionary **)(a1 + 8160), (const __CFDictionary *)cf, 0, &v88);
      if (cf)
        CFRelease(cf);
      if (v62)
        v88 = *(CFTypeRef *)(v32 + 56);
      goto LABEL_79;
    }
LABEL_57:
    v49 = 0;
    return v23 < v22 || v49;
  }
LABEL_79:
  if (theBuffer)
  {
    CFRelease(theBuffer);
    theBuffer = 0;
  }
LABEL_81:
  v63 = 1.0;
  if (v88 == *(CFTypeRef *)(v32 + 56))
  {
    v70 = *(_QWORD *)(a1 + 8144);
    if (v70)
    {
      AverageBitRate = FigAlternateGetAverageBitRate(*(_QWORD *)(v70 + 8));
      v72 = FigAlternateGetAverageBitRate(a2);
      if (!AverageBitRate || !v72)
      {
        AverageBitRate = FigAlternateGetPeakBitRate(*(_QWORD *)(*(_QWORD *)(a1 + 8144) + 8));
        v72 = FigAlternateGetPeakBitRate(a2);
      }
      if (AverageBitRate && v72)
        v63 = (double)(v72 / AverageBitRate);
    }
  }
  segPumpGetNetworkLatencyFromPredictor(a1, &v85);
  v64 = (double)(uint64_t)(*(_QWORD *)(v32 + 448) - *(_QWORD *)(v32 + 896)) / 1000000000.0;
  v65 = v88;
  v66 = *(_QWORD *)(v32 + 304);
  v67 = *(_QWORD *)(v32 + 312);
  v68 = (double)v85 / 1000000000.0;
  if (segPumpConnectedInterfaceIsWWAN(a1))
  {
    v69 = 0;
  }
  else
  {
    if (*(_QWORD *)v32)
      v73 = 0;
    else
      v73 = v17 < a3;
    v69 = v73;
  }
  if (*(_BYTE *)(v32 + 864))
    v74 = v17 < a3;
  else
    v74 = 0;
  v75 = v74;
  v22 = 0.0;
  segPumpDetermineMediaSegmentToSwitchTo(a1, (uint64_t)v65, v66, v67, 0, v69, v75, v33 + v34, v34, 0.0, (double)v17, a8 / v63, v64, v68, v32, &v82.value, &time);
  value = time.value;
  if (time.value)
  {
    v77 = 0.0;
    v23 = 0.0;
    v49 = 0;
    while (1)
    {
      v23 = v23 + FigMediaSegmentSpecifierGetTimeInSeconds(value) * a8;
      TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds(value);
      v22 = v22 + TimeInSeconds * FigMediaSegmentSpecifierGetBitRate(value) * v63;
      if (v23 < v22)
      {
        v49 = 0;
        goto LABEL_115;
      }
      if (v63 * FigMediaSegmentSpecifierGetBitRate(value) > a8 && v34 > 0.0 && v34 < 30.0)
        break;
      v79 = FigMediaSegmentSpecifierGetTimeInSeconds(value);
      v80 = FigMediaSegmentSpecifierGetNextSegment(value);
      if (v80)
      {
        value = v80;
        v77 = v77 + v79;
        if (v77 < 30.0)
          continue;
      }
      goto LABEL_115;
    }
    v49 = 1;
  }
  else
  {
    v49 = 0;
    v23 = 0.0;
  }
LABEL_115:
  if (v88 && v88 != *(CFTypeRef *)(v32 + 56))
    CFRelease(v88);
  return v23 < v22 || v49;
}

uint64_t segPumpSetAlternateForStream(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, const void *a6, const void *a7, int a8, unsigned __int8 a9, uint64_t a10, uint64_t a11)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFArray *MediaSegmentSpecifiers;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  uint64_t v24;
  uint64_t *v25;
  CFIndex v26;
  const __CFArray *Count;
  const __CFArray *v28;
  const void *ValueAtIndex;
  _QWORD *MediaFilePrivateData;
  uint64_t MediaSequence;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const void **v36;
  uint64_t v37;
  uint64_t v38;
  const void *v39;
  const void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const __CFArray *v44;
  uint64_t v45;
  int v46;
  double v47;
  Float64 v48;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v50;
  _BYTE *v51;
  NSObject *v52;
  double Seconds;
  double v54;
  int v55;
  uint64_t v56;
  uint64_t DateStampCount;
  double v58;
  double v59;
  double v60;
  double v61;
  const __CFArray *PartialSegments;
  CFIndex v63;
  const void *v64;
  uint64_t v65;
  uint64_t v66;
  double v67;
  NSObject *v68;
  uint64_t LastValue;
  uint64_t v70;
  uint64_t DiscoInfoList;
  const __CFAllocator *AllocatorForMedia;
  CFDateRef v73;
  double v74;
  int v75;
  NSObject *v76;
  NSObject *v77;
  double v78;
  double v79;
  double v80;
  double v81;
  NSObject *v82;
  Float64 v83;
  unint64_t v84;
  double v85;
  NSObject *v86;
  int v87;
  uint64_t v88;
  const __CFString *PathwayID;
  const void *v90;
  uint64_t CryptKeyCommonData;
  CMTimeValue value;
  uint64_t v93;
  _QWORD *v94;
  uint64_t (*v95)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD);
  uint64_t v96;
  _QWORD *v97;
  uint64_t (*v98)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD);
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  NSObject *v103;
  const void *v104;
  uint64_t v105;
  const void *v106;
  const void *v107;
  CFTypeRef v108;
  double valuePtr;
  CMTime v111;
  CMTime v112;
  double v113;
  CMTime rhs;
  CMTime time;
  uint64_t v116;

  v116 = *MEMORY[0x1E0C80C00];
  v113 = 0.0;
  if (!*(_QWORD *)a3)
    *(_QWORD *)(a2 + 8576) = 0;
  if (a4)
    v17 = a4;
  else
    v17 = a3;
  v18 = 936;
  if (*(_QWORD *)(a3 + 936) == -1)
    v18 = 304;
  *(_QWORD *)(a3 + 936) = *(_QWORD *)(v17 + v18);
  v19 = *(_QWORD *)(v17 + 56);
  if (v19)
  {
    MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v19);
    if (MediaSegmentSpecifiers)
    {
      if (CFArrayGetCount(MediaSegmentSpecifiers) >= 1
        && !FigMediaPlaylistHasDiscontinuitySequence(*(_QWORD *)(v17 + 56))
        && !FigMediaPlaylistGetPlaylistType(*(_QWORD *)(v17 + 56)))
      {
        FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(v17 + 56));
        LastValue = FigCFArrayGetLastValue();
        if (FigMediaSegmentSpecifierGetDiscontinuityDomain(LastValue) >= 1)
        {
          v70 = a3 + 336;
          DiscoInfoList = segPumpCreateDiscoInfoList(a3, (_QWORD *)(a3 + 336), *(_QWORD *)(a3 + 312), (_QWORD *)(a3 + 352));
          if ((_DWORD)DiscoInfoList)
            return DiscoInfoList;
          while (1)
          {
            v70 = *(_QWORD *)v70;
            if (!v70)
              break;
            AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
            v73 = CFDateCreate(AllocatorForMedia, *(CFAbsoluteTime *)(v70 + 16));
            if (v73)
              CFRelease(v73);
          }
        }
      }
    }
  }
  v106 = a5;
  v107 = a6;
  v21 = a10;
  v22 = a11;
  v23 = (_BYTE *)(a2 + 8005);
  *(_BYTE *)(a3 + 863) = 0;
  v24 = *(_QWORD *)a3;
  v108 = a7;
  if (*(_QWORD *)(a2 + 8248))
  {
    v104 = a1;
    v105 = v17;
    v25 = (uint64_t *)(a2 + 40 * v24 + 8256);
    if (*(_QWORD *)(a3 + 56))
    {
      v26 = 0;
      while (1)
      {
        Count = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a3 + 56));
        if (Count)
          Count = (const __CFArray *)CFArrayGetCount(Count);
        if (v26 >= (uint64_t)Count)
          break;
        v28 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a3 + 56));
        ValueAtIndex = CFArrayGetValueAtIndex(v28, v26);
        MediaFilePrivateData = segPumpGetMediaFilePrivateData(ValueAtIndex);
        MediaSequence = FigMediaSegmentSpecifierGetMediaSequence((uint64_t)ValueAtIndex);
        ++v26;
        if (!*((_BYTE *)MediaFilePrivateData + 73))
        {
          v32 = MediaSequence;
          v33 = a10;
          if (*((_BYTE *)MediaFilePrivateData + 74))
            v34 = MediaFilePrivateData[7];
          else
            v34 = 0;
          PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)ValueAtIndex);
          v35 = -1;
          do
          {
            if (PartialSegments)
              v63 = CFArrayGetCount(PartialSegments);
            else
              v63 = 0;
            if (v35 + 1 >= v63)
              break;
            v64 = CFArrayGetValueAtIndex(PartialSegments, ++v35);
          }
          while (*((_BYTE *)segPumpGetMediaFilePrivateData(v64) + 73));
          if (ValueAtIndex)
            goto LABEL_24;
          goto LABEL_23;
        }
      }
    }
    v33 = a10;
    v34 = 0;
LABEL_23:
    v32 = *(_QWORD *)(a3 + 376) + 1;
    v35 = -1;
LABEL_24:
    v36 = (const void **)(a2 + 40 * v24 + 8288);
    if (FigCFEqual() && *v36 && v32 == *v25)
    {
      v37 = a2 + 40 * v24;
      v38 = *(_QWORD *)(v37 + 8272);
      if (v34 > v38)
        v38 = v34;
      *(_QWORD *)(v37 + 8272) = v38;
    }
    else
    {
      *(_QWORD *)(a2 + 40 * v24 + 8272) = v34;
    }
    v21 = v33;
    if ((v32 & 0x8000000000000000) == 0)
      *v25 = v32;
    v39 = *v36;
    v40 = *(const void **)(a2 + 8248);
    *v36 = v40;
    if (v40)
      CFRetain(v40);
    a1 = v104;
    v17 = v105;
    v22 = a11;
    if (v39)
      CFRelease(v39);
    v41 = a2 + 40 * v24;
    *(_QWORD *)(v41 + 8264) = v35;
    *(_BYTE *)(v41 + 8280) = 1;
    v24 = *(_QWORD *)a3;
    v23 = (_BYTE *)(a2 + 8005);
  }
  v42 = *(_QWORD *)(a2 + 16 * v24 + 392);
  *(_BYTE *)(a3 + 864) = v42 == a3;
  if (a8)
  {
    if (v42 == a3)
      goto LABEL_46;
  }
  else if ((*(_BYTE *)(v22 + 12) & 1) != 0 || v42 == a3)
  {
LABEL_46:
    if ((*(_BYTE *)(v21 + 12) & 1) != 0
      && (v43 = *(_QWORD *)(v17 + 56)) != 0
      && (v44 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v43)) != 0
      && CFArrayGetCount(v44) >= 1)
    {
      if (*(_BYTE *)(a3 + 864))
      {
        if ((*(_BYTE *)(v22 + 12) & 1) != 0)
        {
          v46 = 1;
        }
        else
        {
          v45 = MEMORY[0x1E0CA2E68];
          *(_OWORD *)v22 = *MEMORY[0x1E0CA2E68];
          *(_QWORD *)(v22 + 16) = *(_QWORD *)(v45 + 16);
          v46 = *(unsigned __int8 *)(a3 + 864);
        }
        if (a8 && v46)
          segPumpStreamCancelPreloadReadAndResetData(a2, v17);
      }
      time = *(CMTime *)v21;
      rhs = *(CMTime *)v22;
      CMTimeAdd(&v112, &time, &rhs);
      v78 = CMTimeGetSeconds(&v112) - *(double *)(v17 + 88);
      DiscoInfoList = segPumpGetLastDiscAndDateForTimeReadInPlaylist(*(_QWORD *)(v17 + 56), &v113, (double *)(a3 + 920), v78);
      if ((_DWORD)DiscoInfoList)
        return DiscoInfoList;
      time = *(CMTime *)v21;
      rhs = *(CMTime *)v22;
      CMTimeAdd(&v111, &time, &rhs);
      v79 = CMTimeGetSeconds(&v111) - *(double *)(v17 + 88);
      v80 = v113;
      if (v79 < v113)
      {
        *(double *)(a3 + 920) = *(double *)(a3 + 920) - (v113 - v79);
        v78 = v80;
      }
      v81 = *(double *)(v17 + 96) - v78;
      *(double *)(a3 + 904) = v81;
      *(double *)(a3 + 912) = v78;
      *(double *)(a3 + 928) = v78 + *(double *)(a3 + 88);
      if (v81 < 0.0)
        *(_QWORD *)(a3 + 904) = 0;
    }
    else
    {
      v47 = *(double *)(v17 + 120);
      if (v47 > 0.0)
        *(double *)(a3 + 120) = v47;
    }
    *(_QWORD *)(a3 + 896) = *(_QWORD *)(v17 + 1056);
    time = *(CMTime *)v22;
    v48 = CMTimeGetSeconds(&time) * 1000000000.0;
    *(_QWORD *)(a3 + 888) = (uint64_t)(v48 + (double)FigGetUpTimeNanoseconds());
    *(_BYTE *)(a3 + 861) = 1;
    if (dword_1EE2A31E8)
    {
      LODWORD(valuePtr) = 0;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
LABEL_99:
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      goto LABEL_132;
    }
    goto LABEL_132;
  }
  if (*(_BYTE *)(a3 + 1169))
  {
    if (!dword_1EE2A31E8)
      goto LABEL_132;
    goto LABEL_113;
  }
  if (*(_QWORD *)(a2 + 8224))
  {
    if (*(_QWORD *)(a2 + 8144))
    {
      v50 = FigCFEqual();
      if (!a8)
      {
        if (v50)
        {
          valuePtr = 0.0;
          *(_BYTE *)(a3 + 866) = 0;
          *(_QWORD *)(a3 + 88) = *(_QWORD *)(v17 + 88);
          CFNumberGetValue(*(CFNumberRef *)(a2 + 8232), kCFNumberDoubleType, &valuePtr);
          *(double *)(a3 + 120) = valuePtr - *(double *)(a3 + 88);
          if (!dword_1EE2A31E8)
            goto LABEL_132;
          v51 = v23;
          v52 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
          os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT);
          goto LABEL_131;
        }
      }
    }
  }
  if ((*(_BYTE *)(v17 + 401)
     || (v65 = *(_QWORD *)(v17 + 696)) != 0
     && (v66 = *(_QWORD *)(v65 + 8)) != 0
     && FigMediaSegmentSpecifierGetType(v66) == 1)
    && (*(_BYTE *)(v21 + 12) & 1) != 0)
  {
    valuePtr = 0.0;
    *(_BYTE *)(a3 + 866) = 0;
    *(_QWORD *)(a3 + 88) = *(_QWORD *)(v17 + 88);
    time = *(CMTime *)v21;
    Seconds = CMTimeGetSeconds(&time);
    v54 = Seconds - *(double *)(v17 + 88);
    v55 = *(_DWORD *)(v22 + 12);
    if ((v55 & 1) != 0)
    {
      time = *(CMTime *)v22;
      Seconds = CMTimeGetSeconds(&time);
      v54 = v54 + Seconds;
      v55 = *(_DWORD *)(v22 + 12);
    }
    if ((v55 & 1) != 0 || !*(_QWORD *)a3 || *(_QWORD *)v17)
    {
      if (!v23[3] || (Seconds = 1.0, *(_DWORD *)(a2 + 24) != 2))
      {
        v56 = *(_QWORD *)(a3 + 56);
        if (!v56 || (DateStampCount = FigMediaPlaylistGetDateStampCount(v56), Seconds = 1.0, DateStampCount <= 0))
        {
          LODWORD(Seconds) = *(_DWORD *)(a2 + 8);
          Seconds = (double)*(unint64_t *)&Seconds;
        }
      }
      if (*(_BYTE *)(a3 + 872))
        v58 = Seconds;
      else
        v58 = Seconds + 1.0;
    }
    else
    {
      v58 = 0.0;
    }
    segPumpGetLastDiscAndDateForTimeReadInPlaylist(*(_QWORD *)(v17 + 56), &v113, &valuePtr, v54);
    v59 = *(double *)(a3 + 88);
    if (v54 <= v58)
    {
      v61 = v113;
      v74 = v113 + v59;
      *(double *)(a3 + 120) = v113;
      *(double *)(a3 + 928) = v74;
    }
    else
    {
      v60 = v54 - v58;
      v61 = v113;
      *(double *)(a3 + 120) = v54 - v58;
      *(double *)(a3 + 928) = v54 - v58 + v59;
      if (v54 - v58 >= v61)
        goto LABEL_107;
      *(double *)(a3 + 120) = v61;
    }
    v60 = v61;
LABEL_107:
    if (valuePtr != 0.0)
      *(double *)(a3 + 920) = valuePtr + v60 - v54;
    v75 = dword_1EE2A31E8;
    if (dword_1EE2A31E8)
    {
      v76 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      v75 = dword_1EE2A31E8;
      if (dword_1EE2A31E8 >= 2)
      {
        v82 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
        os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT);
        fig_log_call_emit_and_clean_up_after_send_and_compose();
        v75 = dword_1EE2A31E8;
      }
    }
    *(double *)(a3 + 128) = (double)*(uint64_t *)(v17 + 1056) / 1000000000.0
                          - (*(double *)(v17 + 96)
                           - *(double *)(a3 + 120));
    if (v75)
    {
      v103 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT);
      goto LABEL_99;
    }
    goto LABEL_132;
  }
  v67 = *(double *)(v17 + 120);
  if (v67 > 0.0)
  {
    *(double *)(a3 + 120) = v67;
    if (!dword_1EE2A31E8)
      goto LABEL_132;
    goto LABEL_113;
  }
  if (!*(_BYTE *)(v17 + 861))
  {
    if ((*(_BYTE *)(v21 + 12) & 1) != 0)
    {
      time = *(CMTime *)v21;
      v83 = CMTimeGetSeconds(&time);
      LODWORD(v84) = *(_DWORD *)(a2 + 8);
      v85 = v83 - (double)v84 + -1.0;
      *(double *)(a3 + 120) = v85;
      if ((*(_BYTE *)(v22 + 12) & 1) != 0)
      {
        time = *(CMTime *)v22;
        v85 = CMTimeGetSeconds(&time) + *(double *)(a3 + 120);
        *(double *)(a3 + 120) = v85;
      }
      if (v85 < 0.0)
        *(_QWORD *)(a3 + 120) = 0;
      if (!dword_1EE2A31E8)
        goto LABEL_132;
      v51 = v23;
      LODWORD(valuePtr) = 0;
      v86 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT);
LABEL_131:
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      v23 = v51;
      goto LABEL_132;
    }
    *(_BYTE *)(a3 + 866) = 1;
    if (!dword_1EE2A31E8)
      goto LABEL_132;
LABEL_113:
    v51 = v23;
    LODWORD(valuePtr) = 0;
    v77 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT);
    goto LABEL_131;
  }
  *(double *)(a3 + 120) = *(double *)(v17 + 96) - *(double *)(v17 + 904);
  if (dword_1EE2A31E8)
  {
    LODWORD(valuePtr) = 0;
    v68 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT);
    goto LABEL_99;
  }
LABEL_132:
  if (*(_BYTE *)(a3 + 857))
  {
    if (*(_QWORD *)(a2 + 8416) == *(_QWORD *)a3)
    {
      v87 = *(_DWORD *)(a2 + 8680);
      *(_DWORD *)(a2 + 8680) = 0;
    }
    else
    {
      v87 = 0;
    }
    *(_BYTE *)(a3 + 857) = 0;
    DiscoInfoList = segPumpMakeDataCallbackWithOSStatus((uint64_t)a1, (uint64_t *)a3, *(const void **)(a2 + 176), 0, 8u, *(_QWORD *)(a3 + 304), MEMORY[0x1E0CA2E18], 0, v87, 0, 0, 0);
    if ((_DWORD)DiscoInfoList)
      return DiscoInfoList;
  }
  ++*(_DWORD *)(a3 + 72);
  ++*(_QWORD *)(a3 + 80);
  *(_BYTE *)(a3 + 858) = 0;
  *(_BYTE *)(a3 + 401) = 0;
  *(_BYTE *)(a3 + 874) = 0;
  *(_BYTE *)(a3 + 876) = 0;
  *(_OWORD *)(a3 + 1080) = 0u;
  if (!v23[707])
    *(_BYTE *)(a3 + 402) = 1;
  *(_QWORD *)(a3 + 64) = 0;
  *(_QWORD *)(a3 + 312) = 0;
  ++*(_QWORD *)(a3 + 1160);
  v88 = *(_QWORD *)(a2 + 8144);
  if (v88)
    PathwayID = FigAlternateGetPathwayID(*(_QWORD *)(v88 + 8));
  else
    PathwayID = CFSTR(".");
  segPumpStreamUpdateIndexFile((_QWORD *)a3, v106, v106, v107, v108, PathwayID);
  time.value = 0;
  rhs.value = 0;
  v90 = *(const void **)(a3 + 248);
  if (!v90)
    goto LABEL_167;
  if (!v23[679])
  {
    if (FigContentKeySpecifierGetIsPrefetchKey((uint64_t)v90))
      goto LABEL_160;
    v90 = *(const void **)(a3 + 248);
  }
  CryptKeyCommonData = segPumpGetCryptKeyCommonData(v90, &time, &rhs);
  if ((_DWORD)CryptKeyCommonData)
    goto LABEL_159;
  if (FigContentKeySpecifierGetKeySystem(*(_QWORD *)(a3 + 248)) != 1)
    goto LABEL_160;
  value = rhs.value;
  if (!*(_BYTE *)(rhs.value + 88))
    goto LABEL_154;
  v93 = *(_QWORD *)(rhs.value + 64);
  if (!v93)
    goto LABEL_154;
  v94 = *(_QWORD **)(CMBaseObjectGetVTable() + 16);
  if (*v94 >= 6uLL)
  {
    v95 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))v94[20];
    if (v95)
    {
      CryptKeyCommonData = v95(v93, 2, 1, 0, 0);
      if (!(_DWORD)CryptKeyCommonData)
      {
        value = rhs.value;
LABEL_154:
        if (!*(_BYTE *)(value + 128))
        {
          v99 = 0;
          goto LABEL_165;
        }
        v96 = *(_QWORD *)(value + 104);
        if (v96)
        {
          v97 = *(_QWORD **)(CMBaseObjectGetVTable() + 16);
          if (*v97 >= 6uLL)
          {
            v98 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))v97[20];
            if (v98)
            {
              CryptKeyCommonData = v98(v96, 2, 1, 0, 0);
              goto LABEL_159;
            }
          }
          goto LABEL_161;
        }
LABEL_160:
        v99 = 0;
        goto LABEL_162;
      }
LABEL_159:
      v99 = CryptKeyCommonData;
      goto LABEL_162;
    }
  }
LABEL_161:
  v99 = 4294954514;
LABEL_162:
  value = rhs.value;
  if (rhs.value)
  {
LABEL_165:
    CryptKeyReleaseAndClearVideoDecryptor(value);
    CryptKeyReleaseAndClearAudioDecryptor(value);
    segPumpCancelCryptReadAndResetData(a2, a3);
  }
  if ((_DWORD)v99)
    return v99;
LABEL_167:
  DiscoInfoList = segPumpStopStream(a2, a3, a9);
  if ((_DWORD)DiscoInfoList)
    return DiscoInfoList;
  if (!*(_QWORD *)(a3 + 1184))
  {
    v100 = nw_activity_create();
    *(_QWORD *)(a3 + 1184) = v100;
    if (!v100 || !*(_QWORD *)(*(_QWORD *)(a2 + 16 * *(_QWORD *)a3 + 384) + 1176))
      goto LABEL_191;
    nw_activity_set_parent_activity();
    if (*(_QWORD *)(a3 + 1184))
      nw_activity_activate();
    if (*(_QWORD *)(a2 + 16 * *(_QWORD *)a3 + 392) == a3)
    {
      v101 = nw_activity_create();
      *(_QWORD *)(a3 + 1192) = v101;
      if (v101)
      {
        if (!*(_QWORD *)(a3 + 1184) || (nw_activity_set_parent_activity(), *(_QWORD *)(a3 + 1192)))
          nw_activity_activate();
        goto LABEL_178;
      }
LABEL_191:
      FigSignalErrorAt();
    }
  }
LABEL_178:
  *(_BYTE *)(a3 + 862) = 1;
  if (*(_QWORD *)(a2 + 8416) == *(_QWORD *)a3 && !*(_BYTE *)(a3 + 864))
  {
    *v23 = 0;
    *(_BYTE *)(a2 + 376) = 1;
  }
  v99 = 0;
  v23[1] = 0;
  *(_QWORD *)(a3 + 64) = 0;
  if (!*(_BYTE *)(a3 + 1169))
  {
    DiscoInfoList = segPumpRequestIndexForStream(a1, (uint64_t *)a2, a3, 0);
    if (!(_DWORD)DiscoInfoList)
    {
      if (*(_QWORD *)(a2 + 8144))
        return 0;
      return FigSignalErrorAt();
    }
    return DiscoInfoList;
  }
  return v99;
}

uint64_t segPumpBitsRequiredToSwitch(uint64_t a1, int a2, int a3, double a4, double a5)
{
  uint64_t v5;
  uint64_t v7;
  unsigned int v11;
  double v12;
  int PlaylistType;
  double v14;
  double v15;
  double v16;

  v5 = *(_QWORD *)(a1 + 16 * *(_QWORD *)(a1 + 8416) + 384);
  if (!v5)
    return 0x7FFFFFFFFFFFFFFFLL;
  v7 = *(_QWORD *)(v5 + 56);
  if (!v7)
    return 0x7FFFFFFFFFFFFFFFLL;
  v11 = *(_DWORD *)(a1 + 8);
  v12 = (double)v11;
  if (a3 || (PlaylistType = FigMediaPlaylistGetPlaylistType(v7), v11 = *(_DWORD *)(a1 + 8), PlaylistType == 2))
  {
    v14 = (double)v11;
    v15 = 1.0;
    if (*(_DWORD *)(a1 + 8072))
      v15 = (double)v11;
  }
  else
  {
    v14 = (double)v11;
    v15 = (double)v11;
  }
  v16 = v15 + v12;
  if (a4 + a5 - v16 < 0.0)
    v16 = a4 + a5;
  return (uint64_t)((v16 + (*(double *)(a1 + 8080) + 1.0) * v14) * (double)a2);
}

const __CFArray *segPumpStreamHavePerSegmentBitrate(uint64_t a1)
{
  const __CFArray *result;
  uint64_t FirstValue;

  result = *(const __CFArray **)(a1 + 56);
  if (result)
  {
    FigMediaPlaylistGetMediaSegmentSpecifiers((uint64_t)result);
    FirstValue = FigCFArrayGetFirstValue();
    result = *(const __CFArray **)(a1 + 56);
    if (result)
    {
      result = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers((uint64_t)result);
      if (result)
      {
        if (CFArrayGetCount(result) < 1 || FirstValue == 0)
          return 0;
        else
          return (const __CFArray *)(FigMediaSegmentSpecifierGetBitRate(FirstValue) != 0.0);
      }
    }
  }
  return result;
}

uint64_t segPumpGetLastDiscAndDateForTimeReadInPlaylist(uint64_t a1, double *a2, double *a3, double a4)
{
  double v8;
  double v9;
  double v10;
  uint64_t v11;
  _BYTE *MediaFilePrivateData;
  uint64_t v13;
  uint64_t v14;
  uint64_t DateStamp;
  double TimeInSeconds;
  double v17;
  double v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  double v22;
  const __CFAllocator *AllocatorForMedia;
  CFDateRef v24;
  uint64_t v26;
  uint64_t v27;
  const void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v27 = 0;
  v28 = 0;
  if (!a1)
    return FigSignalErrorAt();
  v26 = 0;
  if (segPumpIterateMedia(a1, &v26, &v27, (uint64_t *)&v28))
  {
    v8 = 0.0;
    v9 = 0.0;
    v10 = 0.0;
    while (1)
    {
      v11 = (uint64_t)v28;
      MediaFilePrivateData = segPumpGetMediaFilePrivateData(v28);
      v13 = v26;
      v14 = v27;
      FigMediaSegmentSpecifierGetPartialSegments(v26);
      if (v14 == FigCFArrayGetFirstValue() && FigMediaSegmentSpecifierGetDateStamp(v13))
      {
        DateStamp = FigMediaSegmentSpecifierGetDateStamp(v13);
        v8 = MEMORY[0x194029D14](DateStamp);
      }
      if (FigMediaSegmentSpecifierIsDiscontinuity(v11) && MediaFilePrivateData[74])
        v9 = v10 + FigMediaSegmentSpecifierGetTimeInSeconds(v11) * 0.5;
      if (v10 + FigMediaSegmentSpecifierGetTimeInSeconds(v11) > a4)
        break;
      TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds(v11);
      if (v8 != 0.0)
        v8 = v8 + FigMediaSegmentSpecifierGetTimeInSeconds(v11);
      v10 = v10 + TimeInSeconds;
      if (!segPumpIterateMedia(a1, &v26, &v27, (uint64_t *)&v28))
        goto LABEL_31;
    }
    v17 = a4 - v10;
    if (v8 == 0.0)
    {
      v30 = 0;
      v31 = 0;
      v29 = 0;
      if (segPumpIterateMedia(a1, &v29, &v30, &v31))
      {
        v18 = 0.0;
        while (1)
        {
          v19 = v29;
          v20 = v30;
          FigMediaSegmentSpecifierGetPartialSegments(v29);
          if (v20 == FigCFArrayGetFirstValue())
          {
            if (FigMediaSegmentSpecifierGetDateStamp(v19))
              break;
          }
          v18 = v18 + FigMediaSegmentSpecifierGetTimeInSeconds(v31);
          if (!segPumpIterateMedia(a1, &v29, &v30, &v31))
            goto LABEL_22;
        }
        v21 = FigMediaSegmentSpecifierGetDateStamp(v19);
        v22 = MEMORY[0x194029D14](v21) - v18;
        if (v22 == 0.0)
          v8 = v22;
        else
          v8 = v10 + v17 + v22;
      }
      else
      {
LABEL_22:
        v8 = 0.0;
      }
    }
    else
    {
      v8 = v17 + v8;
    }
    AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    v24 = CFDateCreate(AllocatorForMedia, v8);
    if (v9 >= a4 + 2.0)
      v9 = a4 + 2.0;
    if (v24)
      CFRelease(v24);
  }
  else
  {
    v9 = 0.0;
    v8 = 0.0;
  }
LABEL_31:
  *a2 = v9;
  if (a3)
    *a3 = v8;
  return 0;
}

uint64_t segPumpRequestIndexForStream(const void *a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v12;
  uint64_t AllocatorForMedia;
  void (*v14)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  uint64_t v15;
  uint64_t v16;
  void (*v17)(uint64_t, __CFString *, uint64_t, CFTypeRef *);
  const void *v18;
  CFTypeRef v19;
  uint64_t v20;
  CFTypeRef v22;
  char v23;
  CFTypeRef v24;
  CFTypeRef v25;
  CFDictionaryRef theDict;
  CFTypeRef cf[25];

  cf[24] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  theDict = 0;
  cf[0] = 0;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  v22 = 0;
  if (a2[37])
  {
    v8 = segPumpEnsureCacheForStreamPossiblyEndingStream((uint64_t)a1, (uint64_t *)a3);
    if ((_DWORD)v8)
    {
LABEL_28:
      v20 = v8;
      goto LABEL_29;
    }
    if (*(_BYTE *)(a3 + 1136))
    {
      v20 = 0;
      goto LABEL_29;
    }
  }
  v8 = segPumpCopyIndexFileFromCache((uint64_t)a2, a3, a4, cf, (CFTypeRef *)&theDict, &v24);
  if ((_DWORD)v8)
    goto LABEL_28;
  if (!a2[1055] || (v9 = a2[1056]) == 0 || FigNetworkPathInformationIsHostReachable(v9, 1))
  {
    if (theDict)
    {
      v10 = (const void *)*MEMORY[0x1E0C9AE50];
      if (v10 == CFDictionaryGetValue(theDict, CFSTR("must-validate")))
      {
        if (cf[0])
        {
          CFRelease(cf[0]);
          cf[0] = 0;
        }
        *(_BYTE *)(a3 + 538) = 1;
      }
    }
  }
  if (!cf[0]
    || dword_1EE2A31E8
    && (os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(),
        os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT),
        fig_log_call_emit_and_clean_up_after_send_and_compose(),
        !cf[0]))
  {
    v8 = segPumpSendIndexFileRequest((uint64_t)a1, (uint64_t)a2, a3);
    goto LABEL_28;
  }
  *(_QWORD *)(a3 + 1048) = FigGetUpTimeNanoseconds();
  v12 = *(_QWORD *)(a3 + 424);
  if (v12)
  {
    AllocatorForMedia = FigGetAllocatorForMedia();
    v14 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                             + 48);
    if (v14)
      v14(v12, CFSTR("FHRP_ErrorReturned"), AllocatorForMedia, &v22);
    v15 = *(_QWORD *)(a3 + 424);
    v16 = FigGetAllocatorForMedia();
    v17 = *(void (**)(uint64_t, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                             + 48);
    if (v17)
      v17(v15, CFSTR("FHRP_CFNetworkTimingData"), v16, &v25);
  }
  v18 = *(const void **)(a3 + 520);
  v19 = cf[0];
  *(CFTypeRef *)(a3 + 520) = cf[0];
  if (v19)
    CFRetain(v19);
  if (v18)
    CFRelease(v18);
  v20 = segPumpParseIndexFile2(a1, (uint64_t)a2, a3, 0, 0, 1, &v23);
  segPumpPublishPlaylistRequestEvent((uint64_t)a1, (uint64_t)a2, (_QWORD *)a3, (uint64_t)v25, *(_QWORD *)(a3 + 424), v22, v23);
  if ((_DWORD)v20)
    segPumpSendEndCallbackForAllActiveStreamsWithOSStatus(*a2, v20);
LABEL_29:
  if (v24)
    CFRelease(v24);
  if (theDict)
    CFRelease(theDict);
  if (cf[0])
    CFRelease(cf[0]);
  if (v25)
    CFRelease(v25);
  if (v22)
    CFRelease(v22);
  return v20;
}

uint64_t segPumpGetRequiredBandwidthForCurrentStreamingAlternate(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;

  v1 = result;
  if (!*(_QWORD *)(result + 8144))
    goto LABEL_6;
  if (!*(_QWORD *)(result + 296))
    return segPumpStreamBitRateRequiredForStream(v1, *(_QWORD **)(v1 + 384));
  result = FigAlternateGetLastKnownValueForIsFullyCached();
  if ((_DWORD)result)
    return result;
  if (*(_QWORD *)(v1 + 8144))
    return segPumpStreamBitRateRequiredForStream(v1, *(_QWORD **)(v1 + 384));
LABEL_6:
  v2 = 0;
  v3 = 0;
  do
  {
    v4 = *(_QWORD *)(v1 + 384 + v2);
    if (*(_QWORD *)(v4 + 16))
    {
      v5 = *(_DWORD *)(v4 + 1084);
      if (!v5)
        return result;
      v3 += v5;
    }
    v2 += 16;
  }
  while (v2 != 48);
  return result;
}

double segPumpGetLocalBitrateForSubStream(uint64_t a1, uint64_t a2, uint64_t a3, CMTime *a4, _OWORD *a5)
{
  uint64_t v9;
  uint64_t v10;
  CMTimeEpoch v11;
  uint64_t v12;
  double v13;
  double v14;
  const __CFArray *MediaSegmentSpecifiers;
  double Seconds;
  double v17;
  CFIndex v18;
  const __CFArray *Count;
  const __CFArray *v20;
  double *ValueAtIndex;
  double *MediaFilePrivateData;
  double v23;
  double v24;
  double TimeInSeconds;
  double v26;
  unint64_t v27;
  double v28;
  const void *NextSegment;
  double v30;
  double BitRate;
  double v32;
  uint64_t v33;
  double v34;
  double v35;
  double v36;
  double v37;
  uint64_t v38;
  __int128 v39;
  __int128 v41;
  CMTime duration;
  CMTime start;
  CMTimeRange time;
  CMTime v45;
  CMTime v46;
  CMTime v47;

  v9 = a1 + 16 * a2;
  v10 = *(_QWORD *)(v9 + 392);
  if (!*(_QWORD *)(v10 + 16))
    v10 = *(_QWORD *)(v9 + 384);
  *(_OWORD *)&v47.value = *MEMORY[0x1E0CA2E18];
  v11 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  v47.epoch = v11;
  v12 = *(_QWORD *)(v10 + 56);
  v13 = 0.0;
  v14 = -1.0;
  v41 = *(_OWORD *)&v47.value;
  if (v12)
  {
    MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v12);
    if (MediaSegmentSpecifiers)
    {
      if (CFArrayGetCount(MediaSegmentSpecifiers) >= 1)
      {
        *(_OWORD *)&time.start.value = *(_OWORD *)a3;
        time.start.epoch = *(_QWORD *)(a3 + 16);
        Seconds = CMTimeGetSeconds(&time.start);
        *(_OWORD *)&time.start.value = *(_OWORD *)(a3 + 24);
        time.start.epoch = *(_QWORD *)(a3 + 40);
        v17 = CMTimeGetSeconds(&time.start);
        v18 = 0;
        while (1)
        {
          Count = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(v10 + 56));
          if (Count)
            Count = (const __CFArray *)CFArrayGetCount(Count);
          if (v18 >= (uint64_t)Count)
            break;
          v20 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(v10 + 56));
          ValueAtIndex = (double *)CFArrayGetValueAtIndex(v20, v18);
          MediaFilePrivateData = (double *)segPumpGetMediaFilePrivateData(ValueAtIndex);
          v23 = MediaFilePrivateData[4];
          ++v18;
          if (v23 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex) > Seconds)
          {
            v24 = MediaFilePrivateData[4];
            TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
            CMTimeMakeWithSeconds(&v47, v24 + TimeInSeconds + 0.001, 1000);
            if (ValueAtIndex)
            {
              v26 = v17 + Seconds - v24;
              if (v26 > 0.0)
              {
                v14 = -1.0;
                do
                {
                  v27 = 0;
                  v28 = 0.0;
                  NextSegment = ValueAtIndex;
                  do
                  {
                    v30 = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)NextSegment);
                    if (FigMediaSegmentSpecifierGetBitRate((uint64_t)NextSegment) <= 0.0)
                    {
                      v33 = 8 * *((_QWORD *)segPumpGetMediaFilePrivateData(NextSegment) + 5);
                    }
                    else
                    {
                      BitRate = FigMediaSegmentSpecifierGetBitRate((uint64_t)NextSegment);
                      v32 = BitRate * FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)NextSegment);
                      v33 = (unint64_t)v32;
                    }
                    v28 = v28 + v30;
                    LODWORD(v32) = *(_DWORD *)(a1 + 8);
                    v34 = (double)*(unint64_t *)&v32;
                    if (v28 > v34 * 1.5 + 0.5)
                      break;
                    v27 += v33;
                    if (v28 >= v34 * 0.5 && v14 <= (double)v27 / v28)
                      v14 = (double)v27 / v28;
                    NextSegment = (const void *)FigMediaSegmentSpecifierGetNextSegment((uint64_t)NextSegment);
                  }
                  while (NextSegment);
                  v35 = ValueAtIndex[4];
                  v36 = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
                  v37 = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
                  v38 = FigMediaSegmentSpecifierGetNextSegment((uint64_t)ValueAtIndex);
                  if (!v38)
                    break;
                  ValueAtIndex = (double *)v38;
                  v26 = v26 - v37;
                }
                while (v26 > 0.0);
                v13 = v35 + v36;
              }
            }
            goto LABEL_27;
          }
        }
      }
    }
  }
  v24 = 0.0;
LABEL_27:
  if (a4)
    *a4 = v47;
  if (a5)
  {
    memset(&v46, 0, sizeof(v46));
    CMTimeMakeWithSeconds(&v46, v24, 1000);
    memset(&v45, 0, sizeof(v45));
    if (v24 >= v13)
    {
      *(_OWORD *)&v45.value = v41;
      v45.epoch = v11;
    }
    else
    {
      CMTimeMakeWithSeconds(&v45, v13 - v24, 1000);
    }
    start = v46;
    duration = v45;
    CMTimeRangeMake(&time, &start, &duration);
    v39 = *(_OWORD *)&time.start.epoch;
    *a5 = *(_OWORD *)&time.start.value;
    a5[1] = v39;
    a5[2] = *(_OWORD *)&time.duration.timescale;
  }
  return v14;
}

const __CFArray *segPumpStreamSnapToSegmentBoundary@<X0>(uint64_t a1@<X0>, CMTime *a2@<X1>, uint64_t a3@<X2>, CMTime *a4@<X8>)
{
  uint64_t v7;
  CMTimeEpoch v8;
  double Seconds;
  const __CFArray *result;
  CFIndex i;
  const __CFArray *MediaSegmentSpecifiers;
  const void *ValueAtIndex;
  double *MediaFilePrivateData;
  double v15;
  double *v16;
  double v17;
  double TimeInSeconds;
  __int128 v19;
  CMTime time;

  v7 = MEMORY[0x1E0CA2E18];
  v19 = *MEMORY[0x1E0CA2E18];
  *(_OWORD *)&a4->value = *MEMORY[0x1E0CA2E18];
  v8 = *(_QWORD *)(v7 + 16);
  a4->epoch = v8;
  time = *a2;
  Seconds = CMTimeGetSeconds(&time);
  *(_QWORD *)(a3 + 16) = v8;
  *(_OWORD *)a3 = v19;
  result = *(const __CFArray **)(a1 + 56);
  if (result)
  {
    for (i = 0; ; ++i)
    {
      result = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers((uint64_t)result);
      if (result)
        result = (const __CFArray *)CFArrayGetCount(result);
      if (i >= (uint64_t)result)
        break;
      MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(*(_QWORD *)(a1 + 56));
      ValueAtIndex = CFArrayGetValueAtIndex(MediaSegmentSpecifiers, i);
      MediaFilePrivateData = (double *)segPumpGetMediaFilePrivateData(ValueAtIndex);
      v15 = MediaFilePrivateData[4];
      if (v15 <= Seconds)
      {
        v16 = MediaFilePrivateData;
        if (Seconds <= v15 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex))
        {
          v17 = v16[4];
          if (Seconds - v17 > FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex) * 0.5)
          {
            v17 = v17 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
            ValueAtIndex = (const void *)FigMediaSegmentSpecifierGetNextSegment((uint64_t)ValueAtIndex);
          }
          result = (const __CFArray *)CMTimeMakeWithSeconds(a4, v17 + 0.000001, 1000000);
          if (ValueAtIndex)
          {
            TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
            result = (const __CFArray *)CMTimeMakeWithSeconds(&time, v17 + TimeInSeconds + 0.000001, 1000000);
            *(CMTime *)a3 = time;
          }
          return result;
        }
      }
      result = *(const __CFArray **)(a1 + 56);
    }
  }
  return result;
}

void segPumpSetupInitialCryptorApplierFunction(const void *a1, const void *a2, uint64_t a3)
{
  uint64_t v4;
  const void *v5;
  CFTypeID TypeID;
  CFTypeID v9;
  const void *Value;
  const void *v11;
  uint64_t v12;
  _QWORD *CryptKeyCommonData;
  _QWORD *v14;
  uint64_t v15;
  CFTypeRef v16;

  v4 = *(_QWORD *)a3;
  LODWORD(v5) = *(_DWORD *)(a3 + 8);
  if (!(_DWORD)v5)
  {
    TypeID = CFStringGetTypeID();
    if (TypeID != CFGetTypeID(a1))
      goto LABEL_15;
    v9 = CFDictionaryGetTypeID();
    if (v9 != CFGetTypeID(a2))
      goto LABEL_15;
    Value = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("FPBCPECryptorsKey_Video"));
    v11 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("FPBCPECryptorsKey_Audio"));
    if (!Value)
    {
      LODWORD(v5) = 0;
      goto LABEL_14;
    }
    v5 = v11;
    v12 = FigCPECryptorGetTypeID();
    if (v12 != CFGetTypeID(Value)
      || !FigCFDictionaryGetInt32IfPresent()
      || !FigCFDictionaryGetInt32IfPresent()
      || (CryptKeyCommonData = segPumpCreateCryptKeyCommonData(v4)) == 0)
    {
LABEL_15:
      LODWORD(v5) = FigSignalErrorAt();
      goto LABEL_14;
    }
    v14 = CryptKeyCommonData;
    CryptKeyCommonData[2] = CFRetain(a1);
    *((_DWORD *)v14 + 6) = 0;
    *((_DWORD *)v14 + 7) = 0;
    *((_BYTE *)v14 + 147) = 1;
    v14[8] = CFRetain(Value);
    *((_BYTE *)v14 + 144) = 1;
    if (v5)
    {
      v15 = FigCPECryptorGetTypeID();
      if (v15 == CFGetTypeID(v5))
      {
        v16 = CFRetain(v5);
        LODWORD(v5) = 0;
        v14[13] = v16;
      }
      else
      {
        LODWORD(v5) = FigSignalErrorAt();
      }
    }
    CFRelease(v14);
  }
LABEL_14:
  *(_DWORD *)(a3 + 8) = (_DWORD)v5;
}

void segPumpCreateSafeBandwidthCoefficientsForBaseStoreBagKey(uint64_t a1, uint64_t a2, __CFArray **a3)
{
  CFMutableArrayRef Mutable;
  __CFArray *v7;
  uint64_t i;
  __CFString *v9;
  __CFString *v10;
  __CFString *v11;
  __CFString *v12;
  CFTypeID v13;
  __CFString *v14;

  Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(a1 + 56), 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v7 = Mutable;
    for (i = 0; i != 16; ++i)
    {
      v9 = (__CFString *)CFStringCreateWithFormat(*(CFAllocatorRef *)(a1 + 56), 0, CFSTR("%@%d"), a2, i);
      if (!v9)
      {
        FigSignalErrorAt();
        goto LABEL_14;
      }
      v10 = v9;
      v11 = (__CFString *)FigRCLCopyCFType(*(CFDictionaryRef *)(a1 + 9128), v9);
      if (!v11)
        goto LABEL_8;
      v12 = v11;
      v13 = CFGetTypeID(v11);
      if (v13 != CFNumberGetTypeID())
      {
        FigSignalErrorAt();
        CFRelease(v10);
        v14 = v12;
        goto LABEL_12;
      }
      CFArrayAppendValue(v7, v12);
      CFRelease(v10);
      CFRelease(v12);
    }
    v10 = 0;
LABEL_8:
    if (CFArrayGetCount(v7) >= 1)
    {
      *a3 = v7;
      v7 = 0;
    }
    if (v10)
    {
      v14 = v10;
LABEL_12:
      CFRelease(v14);
    }
    if (!v7)
      return;
LABEL_14:
    CFRelease(v7);
  }
  else
  {
    FigSignalErrorAt();
  }
}

void segPumpStreamClearStatistics(uint64_t a1)
{
  _QWORD *i;
  const void *v2;

  *(_QWORD *)(a1 + 944) = 0;
  *(_QWORD *)(a1 + 1104) = 0;
  *(_OWORD *)(a1 + 1120) = 0u;
  for (i = *(_QWORD **)(a1 + 680); i; i = (_QWORD *)*i)
  {
    v2 = (const void *)i[22];
    if (v2)
    {
      CFRelease(v2);
      i[22] = 0;
    }
  }
}

uint64_t registerFigNetworkWirelessReportingInterfaceType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigNetworkWirelessReportingInterfaceID = result;
  return result;
}

uint64_t FigNetworkWirelessReportingInterfaceCopyWifiStats(_QWORD *a1)
{
  void *v2;
  uint64_t v3;

  v2 = (void *)MEMORY[0x19403137C]();
  if (FigNetworkWirelessReportingInterfaceGetGlobal_onceToken != -1)
    dispatch_once_f(&FigNetworkWirelessReportingInterfaceGetGlobal_onceToken, 0, (dispatch_function_t)fnwri_globalNetworkWirelessReportingInterfaceInitOnce);
  if (gNetworkWirelessInterface && a1)
  {
    v3 = 0;
    *a1 = objc_msgSend(*(id *)(gNetworkWirelessInterface + 16), "copyAllWiFiStats");
  }
  else
  {
    v3 = FigSignalErrorAt();
  }
  objc_autoreleasePoolPop(v2);
  return v3;
}

uint64_t FigNetworkWirelessReportingInterfaceCopyCellStats(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  uint64_t v6;

  v2 = (void *)MEMORY[0x19403137C]();
  if (CelestialIsAudioAccessory())
    goto LABEL_10;
  if (FigNetworkWirelessReportingInterfaceGetGlobal_onceToken != -1)
    dispatch_once_f(&FigNetworkWirelessReportingInterfaceGetGlobal_onceToken, 0, (dispatch_function_t)fnwri_globalNetworkWirelessReportingInterfaceInitOnce);
  v3 = gNetworkWirelessInterface;
  if (!gNetworkWirelessInterface || !a1)
  {
    v6 = FigSignalErrorAt();
    goto LABEL_8;
  }
  v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithDictionary:", objc_msgSend(*(id *)(gNetworkWirelessInterface + 24), "signalStrength"));
  if (!v4)
  {
LABEL_10:
    v6 = 0;
    goto LABEL_8;
  }
  v5 = v4;
  objc_msgSend(v4, "setValue:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", objc_msgSend(*(id *)(v3 + 24), "bars")), CFSTR("bars"));
  objc_msgSend(v5, "setValue:forKey:", objc_msgSend(*(id *)(v3 + 24), "carrierName"), CFSTR("carrier"));
  v6 = 0;
  *a1 = v5;
LABEL_8:
  objc_autoreleasePoolPop(v2);
  return v6;
}

uint64_t FigNetworkWirelessReportingInterfaceInit()
{
  if (FigNetworkWirelessReportingInterfaceGetGlobal_onceToken != -1)
    dispatch_once_f(&FigNetworkWirelessReportingInterfaceGetGlobal_onceToken, 0, (dispatch_function_t)fnwri_globalNetworkWirelessReportingInterfaceInitOnce);
  return 0;
}

uint64_t FigNetworkWirelessReportingReportWiFiStats(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t SInt64;
  void (*v5)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v6;
  void (*v7)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v8;
  void (*v9)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v10;
  void (*v11)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t Value;
  void (*v13)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v14;
  void (*v15)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v16;
  void (*v17)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v18;
  void (*v19)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v20;
  void (*v21)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  double v22;
  double v23;
  void (*v24)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  double v25;
  double v26;
  void (*v27)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t UInt64;
  void (*v29)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v30;
  void (*v31)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v32;
  void (*v33)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v34;
  void (*v35)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v36;
  void (*v37)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);

  result = 4294948045;
  if (a1 && a2)
  {
    FigCFDictionaryGetValue();
    SInt64 = FigCFNumberGetSInt64();
    v5 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                 + 16)
                                                                                     + 56);
    if (v5)
      v5(a1, CFSTR("wirelessInterface"), CFSTR("snr"), SInt64, 0);
    FigCFDictionaryGetValue();
    v6 = FigCFNumberGetSInt64();
    v7 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                 + 16)
                                                                                     + 56);
    if (v7)
      v7(a1, CFSTR("wirelessInterface"), CFSTR("noise"), v6, 0);
    FigCFDictionaryGetValue();
    v8 = FigCFNumberGetSInt64();
    v9 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                 + 16)
                                                                                     + 56);
    if (v9)
      v9(a1, CFSTR("wirelessInterface"), CFSTR("rssi"), v8, 0);
    FigCFDictionaryGetValue();
    v10 = FigCFNumberGetSInt64();
    v11 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v11)
      v11(a1, CFSTR("wirelessInterface"), CFSTR("cca"), v10, 0);
    Value = FigCFDictionaryGetValue();
    v13 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 48);
    if (v13)
      v13(a1, CFSTR("wirelessInterface"), CFSTR("channel"), Value, 0);
    FigCFDictionaryGetValue();
    v14 = FigCFNumberGetSInt64();
    v15 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v15)
      v15(a1, CFSTR("wirelessInterface"), CFSTR("netScore"), v14, 0);
    FigCFDictionaryGetValue();
    v16 = FigCFNumberGetSInt64();
    v17 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v17)
      v17(a1, CFSTR("wirelessInterface"), CFSTR("txRetries"), v16, 0);
    FigCFDictionaryGetValue();
    v18 = FigCFNumberGetSInt64();
    v19 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v19)
      v19(a1, CFSTR("wirelessInterface"), CFSTR("txFails"), v18, 0);
    FigCFDictionaryGetValue();
    v20 = FigCFNumberGetSInt64();
    v21 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v21)
      v21(a1, CFSTR("wirelessInterface"), CFSTR("rxRetries"), v20, 0);
    FigCFDictionaryGetValue();
    FigCFNumberGetFloat64();
    v23 = v22;
    v24 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v24)
      v24(a1, CFSTR("wirelessInterface"), CFSTR("rxRate"), 1000 * (uint64_t)v23, 0);
    FigCFDictionaryGetValue();
    FigCFNumberGetFloat64();
    v26 = v25;
    v27 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v27)
      v27(a1, CFSTR("wirelessInterface"), CFSTR("txRate"), 1000 * (uint64_t)v26, 0);
    FigCFDictionaryGetValue();
    UInt64 = FigCFNumberGetUInt64();
    v29 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v29)
      v29(a1, CFSTR("wirelessInterface"), CFSTR("dataStallScore"), UInt64, 0);
    FigCFDictionaryGetValue();
    v30 = FigCFNumberGetSInt64();
    v31 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v31)
      v31(a1, CFSTR("wirelessInterface"), CFSTR("txFrames"), v30, 0);
    FigCFDictionaryGetValue();
    v32 = FigCFNumberGetSInt64();
    v33 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v33)
      v33(a1, CFSTR("wirelessInterface"), CFSTR("rxFCSErrors"), v32, 0);
    FigCFDictionaryGetValue();
    v34 = FigCFNumberGetSInt64();
    v35 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v35)
      v35(a1, CFSTR("wirelessInterface"), CFSTR("rxDupErrors"), v34, 0);
    FigCFDictionaryGetValue();
    v36 = FigCFNumberGetUInt64();
    v37 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v37)
      v37(a1, CFSTR("wirelessInterface"), CFSTR("isCached"), v36, 0);
    return 0;
  }
  return result;
}

uint64_t FigNetworkWirelessReportingReportCellStats(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t SInt64;
  void (*v5)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v6;
  void (*v7)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v8;
  void (*v9)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v10;
  void (*v11)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);
  uint64_t v12;
  void (*v13)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD);

  result = 4294948045;
  if (a1 && a2)
  {
    FigCFDictionaryGetValue();
    SInt64 = FigCFNumberGetSInt64();
    v5 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                 + 16)
                                                                                     + 56);
    if (v5)
      v5(a1, CFSTR("wirelessInterface"), CFSTR("snr"), SInt64, 0);
    FigCFDictionaryGetValue();
    v6 = FigCFNumberGetSInt64();
    v7 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                 + 16)
                                                                                     + 56);
    if (v7)
      v7(a1, CFSTR("wirelessInterface"), CFSTR("rssi"), v6, 0);
    FigCFDictionaryGetValue();
    v8 = FigCFNumberGetSInt64();
    v9 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                 + 16)
                                                                                     + 56);
    if (v9)
      v9(a1, CFSTR("wirelessInterface"), CFSTR("rscp"), v8, 0);
    FigCFDictionaryGetValue();
    v10 = FigCFNumberGetSInt64();
    v11 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v11)
      v11(a1, CFSTR("wirelessInterface"), CFSTR("rsrp"), v10, 0);
    FigCFDictionaryGetValue();
    v12 = FigCFNumberGetSInt64();
    v13 = *(void (**)(uint64_t, __CFString *, __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                  + 16)
                                                                                      + 56);
    if (v13)
      v13(a1, CFSTR("wirelessInterface"), CFSTR("rsrq"), v12, 0);
    return 0;
  }
  return result;
}

uint64_t FigNetworkWirelessReportingInterface_Init(uint64_t result)
{
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  return result;
}

void FigNetworkWirelessReportingInterface_Finalize(uint64_t a1)
{
  void *v2;

  v2 = (void *)MEMORY[0x19403137C]();

  objc_autoreleasePoolPop(v2);
}

CFStringRef FigNetworkWirelessReportingInterface_CopyFormattingDescription(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<FigNetworkWirelessReportingInterfaceRef %p>"), a1);
}

CFStringRef FigNetworkWirelessReportingInterface_CopyDebugDescription(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<FigNetworkWirelessReportingInterfaceRef %p>"), a1);
}

void fnwri_globalNetworkWirelessReportingInterfaceInitOnce()
{
  void *v0;
  int IsAudioAccessory;
  uint64_t Instance;
  _QWORD *v3;
  void *v4;
  void *v5;

  v0 = (void *)MEMORY[0x19403137C]();
  v5 = 0;
  IsAudioAccessory = CelestialIsAudioAccessory();
  if (FigNetworkWirelessReportingInterfaceGetTypeID_sRegisterFigNetworkWirelessReportingInterfaceTypeOnce != -1)
    dispatch_once_f(&FigNetworkWirelessReportingInterfaceGetTypeID_sRegisterFigNetworkWirelessReportingInterfaceTypeOnce, 0, (dispatch_function_t)registerFigNetworkWirelessReportingInterfaceType);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v3 = (_QWORD *)Instance;
    *(_QWORD *)(Instance + 16) = -[FigCoreWiFi initWithError:]([FigCoreWiFi alloc], "initWithError:", &v5);
    v4 = v5;
    if (v5
      || !IsAudioAccessory
      && (v3[3] = -[FigCoreTelephony initWithError:]([FigCoreTelephony alloc], "initWithError:", &v5),
          (v4 = v5) != 0))
    {
      objc_msgSend(v4, "code");
      CFRelease(v3);
    }
    else
    {
      gNetworkWirelessInterface = (uint64_t)v3;
    }
  }
  else
  {
    FigSignalErrorAt();
  }
  objc_autoreleasePoolPop(v0);
}

uint64_t FigStreamingPlaylistEnsureMediaURL(uint64_t a1, const __CFURL *a2, const __CFURL *a3, CFTypeRef *a4, CFURLRef *a5)
{
  CFURLRef v9;
  CFTypeRef v10;
  CFURLRef CFURLFromCFString;

  if (!a4 || *a4 || (v9 = StreamingPlaylistCreateCFURLFromCFString(a1, a2), (*a4 = v9) != 0))
  {
    if (!a5 || *a5)
      return 0;
    if (FigCFEqual())
    {
      v10 = *a4;
      if (*a4)
        v10 = CFRetain(v10);
      *a5 = (CFURLRef)v10;
      return 0;
    }
    CFURLFromCFString = StreamingPlaylistCreateCFURLFromCFString(a1, a3);
    *a5 = CFURLFromCFString;
    if (CFURLFromCFString)
      return 0;
  }
  return FigSignalErrorAt();
}

CFURLRef StreamingPlaylistCreateCFURLFromCFString(uint64_t a1, const __CFURL *a2)
{
  uint64_t CStringPtrAndBufferToFree;
  const char *v4;
  const __CFAllocator *AllocatorForMedia;
  size_t v6;
  CFURLRef v7;

  CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree();
  if (CStringPtrAndBufferToFree)
  {
    v4 = (const char *)CStringPtrAndBufferToFree;
    AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
    v6 = strlen(v4);
    v7 = CFURLCreateWithBytes(AllocatorForMedia, (const UInt8 *)v4, v6, 0x8000100u, a2);
  }
  else
  {
    v7 = 0;
  }
  free(0);
  return v7;
}

uint64_t FigStreamingPlaylistMakeUniqueAlternateIndex()
{
  return FigAtomicIncrement32();
}

uint64_t FigStreamPlaylistParseStringAndCreateProtocolVersionList(const __CFString *a1, CFTypeRef *a2)
{
  const __CFAllocator *v4;
  CFMutableArrayRef Mutable;
  __CFArray *v6;
  char *v7;
  BOOL v8;
  int v9;
  BOOL v10;
  CFNumberRef v11;
  CFNumberRef v12;
  uint64_t v13;
  int valuePtr;
  char *__endptr;
  char *__stringp;
  char buffer[16];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v20 = 0u;
  v21 = 0u;
  *(_OWORD *)buffer = 0u;
  v19 = 0u;
  __endptr = 0;
  if (!a1)
    return 0;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v6 = Mutable;
    CFStringGetFileSystemRepresentation(a1, buffer, 64);
    __stringp = buffer;
    v7 = strsep(&__stringp, "/");
    if (v7)
    {
      while (1)
      {
        valuePtr = 0;
        valuePtr = strtol(v7, &__endptr, 0);
        v8 = valuePtr < 1 || __endptr == 0;
        if (v8 || ((v9 = *__endptr, v9 != 47) ? (v10 = v9 == 0) : (v10 = 1), !v10))
        {
          v13 = 4294955032;
          goto LABEL_17;
        }
        v11 = CFNumberCreate(v4, kCFNumberIntType, &valuePtr);
        if (!v11)
          break;
        v12 = v11;
        CFArrayAppendValue(v6, v11);
        CFRelease(v12);
        v7 = strsep(&__stringp, "/");
        if (!v7)
          goto LABEL_15;
      }
      v13 = FigSignalErrorAt();
    }
    else
    {
LABEL_15:
      v13 = 0;
      *a2 = CFRetain(v6);
    }
LABEL_17:
    CFRelease(v6);
    return v13;
  }
  return FigSignalErrorAt();
}

const __CFArray *FigStreamPlaylistInitializeIndexValidation(uint64_t a1)
{
  CFIndex i;
  const __CFArray *MediaSegmentSpecifiers;
  const __CFArray *v4;
  const void *ValueAtIndex;
  CFIndex j;
  const __CFArray *MapSegmentSpecifiers;
  const __CFArray *v8;
  const void *v9;
  CFIndex k;
  const __CFArray *result;
  const __CFArray *ContentKeySpecifiers;
  const void *v13;

  FigMediaPlaylistSetHasEndTag(a1, 0);
  FigMediaPlaylistSetPlaylistActiveDurationSecs(a1, 0.0);
  FigMediaPlaylistSetHasOnlyIFrames(a1, 0);
  for (i = 0; ; ++i)
  {
    MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
    if (MediaSegmentSpecifiers)
      MediaSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MediaSegmentSpecifiers);
    if (i >= (uint64_t)MediaSegmentSpecifiers)
      break;
    v4 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
    ValueAtIndex = CFArrayGetValueAtIndex(v4, i);
    FigMediaSegmentSpecifierSetIsReadInCurrent((uint64_t)ValueAtIndex, 0);
    FigMediaSegmentSpecifierSetChangedInCurrent((uint64_t)ValueAtIndex, 0);
  }
  for (j = 0; ; ++j)
  {
    MapSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMapSegmentSpecifiers(a1);
    if (MapSegmentSpecifiers)
      MapSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MapSegmentSpecifiers);
    if (j >= (uint64_t)MapSegmentSpecifiers)
      break;
    v8 = (const __CFArray *)FigMediaPlaylistGetMapSegmentSpecifiers(a1);
    v9 = CFArrayGetValueAtIndex(v8, j);
    FigMediaSegmentSpecifierSetIsReadInCurrent((uint64_t)v9, 0);
    FigMediaSegmentSpecifierSetChangedInCurrent((uint64_t)v9, 0);
  }
  for (k = 0; ; ++k)
  {
    result = (const __CFArray *)FigMediaPlaylistGetContentKeySpecifiers(a1);
    if (result)
      result = (const __CFArray *)CFArrayGetCount(result);
    if (k >= (uint64_t)result)
      break;
    ContentKeySpecifiers = (const __CFArray *)FigMediaPlaylistGetContentKeySpecifiers(a1);
    v13 = CFArrayGetValueAtIndex(ContentKeySpecifiers, k);
    FigContentKeySpecifierSetIsReadInCurrent((uint64_t)v13, 0);
    FigContentKeySpecifierSetIsChangedInCurrent((uint64_t)v13, 0);
  }
  return result;
}

uint64_t FigStreamPlaylistParserMinBytesRequiredToVerifyM3UPlaylist()
{
  return 11;
}

BOOL FigStreamingPlaylistVerifyM3UPlaylist(CMBlockBufferRef theBuffer, _BYTE *a2)
{
  char *v5;
  _BYTE temporaryBlock[11];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a2)
    *a2 = 0;
  if (CMBlockBufferGetDataLength(theBuffer) < 0xB)
    return 0;
  v5 = 0;
  if (CMBlockBufferAccessDataBytes(theBuffer, 0, 0xBuLL, temporaryBlock, &v5))
    return 0;
  if (a2)
    *a2 = 1;
  return StreamingPlaylist_VerifyLeadingMagicNumber(v5, 0) == 0;
}

uint64_t StreamingPlaylist_VerifyLeadingMagicNumber(const char *a1, const char **a2)
{
  const char *v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  const char *v7;
  unsigned int v8;
  uint64_t result;

  if (!a1)
  {
    FigSignalErrorAt();
    FigSignalErrorAt();
    return 4294954650;
  }
  v3 = a1;
  if (!strncmp(a1, "﻿", 3uLL))
  {
    v4 = v3[3];
    if ((v4 & 0x80000000) != 0)
      v5 = __maskrune(v4, 0x500uLL);
    else
      v5 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v4 + 60) & 0x500;
    if (!v5)
      v3 += 3;
  }
  if (strncmp(v3, "#EXTM3U", 7uLL))
    return 4294954650;
  v8 = v3[7];
  v7 = v3 + 7;
  v6 = v8;
  if ((v8 & 0x80000000) != 0)
  {
    if (!__maskrune(v6, 0x500uLL))
      goto LABEL_15;
    return 4294954650;
  }
  if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v6 + 60) & 0x500) != 0)
    return 4294954650;
LABEL_15:
  result = 0;
  if (a2)
    *a2 = v7;
  return result;
}

uint64_t FigStreamPlaylistGetSelectionGroup(uint64_t a1, int a2, const __CFDictionary *a3, _QWORD *a4)
{
  return PlaylistGetSelectionGroupGuts(a1, a2, a3, 0, a4);
}

uint64_t PlaylistGetSelectionGroupGuts(uint64_t a1, int a2, const __CFDictionary *a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v5;
  const char *v9;
  uint64_t v10;
  const void *Value;
  uint64_t v13;

  v5 = a1;
  if (a1)
  {
    if (a2 > 1936684397)
    {
      if (a2 == 1986618469)
      {
        v9 = "video";
        v10 = 4294954981;
      }
      else
      {
        if (a2 != 1936684398)
          goto LABEL_14;
        v9 = "audio";
        v10 = 4294954982;
      }
    }
    else
    {
      if (a2 != 1668047728)
      {
        if (a2 == 1935832172)
        {
          v9 = "subtitle";
          v10 = 4294954980;
          goto LABEL_11;
        }
LABEL_14:
        v5 = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294954985, a4, CFSTR("Illegal type %c%c%c%c in EXT-X-MEDIA"), HIBYTE(a2), BYTE2(a2), BYTE1(a2), a2);
        return v5;
      }
      v9 = "closed caption";
      v10 = 4294951058;
    }
LABEL_11:
    if (FigCFDictionaryGetCount())
    {
      Value = CFDictionaryGetValue(a3, (const void *)v5);
      v5 = 0;
      *a5 = Value;
    }
    else
    {
      v13 = v5;
      v5 = 4294954654;
      _StreamPlaylistLogError(4294954654, v10, a4, CFSTR("have %s %@ in STREAMINF without EXT-X-MEDIA %s group"), v9, v13, v9);
    }
  }
  return v5;
}

uint64_t FigStreamPlaylistParseInProcess(OpaqueCMBlockBuffer *a1, const __CFURL *a2, const __CFURL *a3, _DWORD *a4, uint64_t a5, int a6, uint64_t a7, int a8, uint64_t a9, uint64_t a10, const __CFDictionary *a11, const __CFDictionary *a12, CFTypeRef *a13, CFTypeRef *a14)
{
  const __CFURL *v18;
  int v19;
  size_t DataLength;
  const __CFString *v21;
  uint64_t appended;
  const __CFAllocator *v23;
  uint64_t matched;
  CMBlockBufferRef v25;
  uint64_t DataPointer;
  char *v27;
  size_t v28;
  uint64_t LastValue;
  uint64_t v30;
  double HoldBackDuration;
  uint64_t v32;
  char HasIndependentSegments;
  uint64_t v34;
  double StartTimeValue;
  uint64_t v36;
  char IsStartTimePrecise;
  uint64_t v38;
  char HasStartTime;
  uint64_t v40;
  int Version;
  double PartHoldBackDuration;
  uint64_t v43;
  CFIndex i;
  const __CFArray *DateRangeSpecifiers;
  const __CFArray *v46;
  const void *ValueAtIndex;
  uint64_t PreloadHint;
  uint64_t PreloadMapHint;
  uint64_t AllocatorForMedia;
  uint64_t v51;
  uint64_t v52;
  CFTypeRef v53;
  CFStringRef v54;
  const __CFString *v55;
  const __CFString *v56;
  __CFString *v57;
  char *v58;
  const char *v59;
  size_t v60;
  uint64_t v61;
  unsigned int TargetDuration;
  const __CFAllocator *v63;
  CFAbsoluteTime Current;
  CFDateRef v65;
  uint64_t NextSegment;
  unint64_t v67;
  double v68;
  double v69;
  double v70;
  double v71;
  double v72;
  uint64_t StringWithReplacement;
  char *v74;
  const __CFAllocator *v75;
  CFStringRef v76;
  CFStringRef v77;
  int v78;
  unsigned int v79;
  uint64_t URLString;
  double v81;
  const void *v82;
  uint64_t v83;
  uint64_t v84;
  unsigned int v85;
  uint64_t v86;
  int v87;
  void *v88;
  BOOL v89;
  char *v90;
  double MaxSegmentDuration;
  uint64_t v92;
  CFURLRef v93;
  CFStringRef v94;
  CFTypeRef v95;
  char *v96;
  unsigned int v97;
  BOOL v98;
  int v99;
  BOOL v100;
  void *v101;
  uint64_t v102;
  os_log_type_t v103;
  const char *v104;
  const UInt8 *v105;
  UInt8 *v106;
  CFURLRef v107;
  const UInt8 *v108;
  size_t v109;
  int v110;
  int v111;
  unsigned int v112;
  unsigned int v114;
  uint64_t v115;
  CFTypeRef v117;
  char *v118;
  uint64_t v119;
  CFIndex v120;
  const __CFArray *v121;
  const __CFArray *v122;
  const void *v123;
  const void *v124;
  const void *MapSegmentSpecifier;
  const char *v126;
  unsigned int v127;
  int v128;
  const char *v130;
  size_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  const void *v135;
  uint64_t v136;
  CFTypeRef v137;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v139;
  unsigned int v140;
  uint64_t v141;
  uint64_t v142;
  const __CFString *v143;
  uint64_t v144;
  uint64_t v145;
  double v146;
  double v147;
  const void *v148;
  uint64_t MediaSequence;
  uint64_t v150;
  uint64_t v151;
  double v152;
  CFTypeRef v153;
  char v154;
  char IsMarkedAsGap;
  double v156;
  const void *v157;
  uint64_t v158;
  char *v159;
  uint64_t v160;
  char *v161;
  double v162;
  const __CFArray *v163;
  int v164;
  int v165;
  int v166;
  const char *v167;
  char *v168;
  CFStringRef v169;
  int v170;
  unsigned int v171;
  int v172;
  uint64_t v174;
  char v175;
  const char *v176;
  UInt8 *v177;
  CFURLRef v178;
  const char *v179;
  uint64_t v180;
  const char *v181;
  uint64_t v182;
  uint64_t v183;
  void *v184;
  uint64_t v185;
  void *v186;
  int v187;
  CFIndex v188;
  size_t v189;
  int v190;
  int v191;
  unsigned int v192;
  unsigned int v194;
  uint64_t v195;
  CFTypeRef v197;
  CFStringRef v198;
  CFTypeRef v199;
  int v200;
  CFURLRef v201;
  CFTypeRef v202;
  int v203;
  const char *v204;
  uint64_t v205;
  int v206;
  char *v207;
  unsigned int v208;
  char v209;
  char v210;
  char *v211;
  size_t v212;
  char *v213;
  int v214;
  int v216;
  int v217;
  uint64_t v218;
  int v219;
  uint64_t v220;
  int v221;
  uint64_t v222;
  unsigned int v223;
  unsigned int v224;
  int v225;
  uint64_t v227;
  os_log_type_t v228;
  char *v229;
  UInt8 *v230;
  const char *v231;
  char *v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  CFStringRef v236;
  int v237;
  unsigned int v238;
  int v239;
  uint64_t v241;
  char v242;
  const UInt8 *v243;
  const __CFAllocator *v244;
  CFTypeID v245;
  int CharacterAtIndex;
  uint64_t v247;
  char *v248;
  const void *MatchingMapEntry;
  CFIndex v250;
  const __CFArray *v251;
  const __CFArray *v252;
  const void *v253;
  uint64_t v254;
  double v255;
  uint64_t v256;
  char *v257;
  uint64_t v258;
  uint64_t v259;
  double v260;
  BOOL v261;
  uint64_t v262;
  CFTypeRef v263;
  int EncryptionMethod;
  NSObject *v265;
  unsigned int v266;
  unsigned int v267;
  const __CFArray *v268;
  uint64_t v269;
  CFURLRef v270;
  char v271;
  CFStringRef v272;
  CFStringRef v273;
  uint64_t v274;
  char *v275;
  uint64_t v276;
  char *v277;
  const char *v278;
  int v279;
  char v280;
  unsigned int v281;
  int v282;
  uint64_t v284;
  CMBlockBufferRef v285;
  char *v286;
  int v287;
  char v288;
  char *v289;
  char v290;
  char *v291;
  char *v292;
  char *v293;
  uint64_t v294;
  uint64_t v295;
  const char *v296;
  uint64_t v297;
  char *v298;
  const __CFArray *v299;
  const __CFArray *v300;
  uint64_t v301;
  uint64_t v302;
  CFTypeRef v303;
  const void *v304;
  const void *v305;
  const void *v306;
  const __CFArray *PartialSegments;
  CFIndex Count;
  char v309;
  char v310;
  uint64_t v311;
  CFTypeRef v312;
  uint64_t v313;
  uint64_t v314;
  BOOL v315;
  char v316;
  uint64_t v317;
  const void *v318;
  CFTypeRef v319;
  char IsDiscontinuity;
  const void *MediaFileEntry;
  uint64_t v322;
  const __CFArray *v323;
  CFIndex v324;
  const void *v325;
  uint64_t v326;
  double PlaylistActiveDurationSecs;
  double TimeInSeconds;
  CFIndex j;
  CFTypeRef *v330;
  int HasOnlyIFrames;
  char v332;
  const __CFString *v333;
  uint64_t v334;
  BOOL v335;
  BOOL v336;
  double SkipDeltaBoundary;
  double v338;
  double PartTargetDuration;
  double v340;
  double v341;
  double v342;
  double v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  const __CFString *v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t StartOffset;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  int v365;
  const __CFArray *v366;
  const __CFArray *MediaSelectionArray;
  const void *CFStringForOSTypeValue;
  const __CFArray *MediaSelectionOptionArrayByMediaType;
  char v370;
  uint64_t v371;
  unint64_t v372;
  unint64_t v373;
  CFIndex v374;
  const __CFArray *Alternates;
  const __CFArray *v376;
  const void *v377;
  uint64_t AudioGroupIDString;
  const __CFDictionary *AudioGroups;
  uint64_t SelectionGroupGuts;
  uint64_t VideoGroupIDString;
  const __CFDictionary *VideoGroups;
  uint64_t SubtitleGroupIDString;
  const __CFDictionary *SubtitleGroups;
  uint64_t ClosedCaptionGroupIDString;
  const __CFDictionary *ClosedCaptionGroups;
  const __CFString *v387;
  const __CFString *v388;
  void *Mutable;
  const __CFAllocator *v390;
  const __CFArray *v391;
  CFMutableArrayRef v392;
  CFMutableArrayRef v393;
  const __CFString *v394;
  CFIndex v395;
  CFIndex v396;
  CFIndex v397;
  const void *v398;
  CFDictionaryRef v399;
  const __CFDictionary *v400;
  const __CFDictionary *v401;
  const __CFArray *v402;
  uint64_t ConcatenationOfTwoArrays;
  __CFDictionary *MutableCopy;
  CFArrayRef v405;
  CFArrayRef v406;
  uint64_t v407;
  uint64_t v408;
  CFArrayRef v409;
  _DWORD *v410;
  int v411;
  CFIndex v412;
  uint64_t v413;
  const __CFArray *v414;
  const __CFArray *v415;
  const void *v416;
  CFIndex v417;
  const void *Identifier;
  double TempDuration;
  const void *TempEndDate;
  const void *ParseDate;
  double TempPlannedDuration;
  const __CFArray *v423;
  char v424;
  __CFArray *MutableDateRangeSpecifiers;
  void *v426;
  double Duration;
  const __CFDate *EndDate;
  const __CFDate *StartDate;
  _DWORD *v430;
  const __CFAllocator *v431;
  uint64_t v432;
  const __CFArray *v433;
  CFIndex v434;
  const void *v435;
  const CFArrayCallBacks *v436;
  const __CFArray *v437;
  const __CFArray *v438;
  const __CFString *v439;
  CFMutableDictionaryRef v440;
  __CFDictionary *v441;
  const void *DiscoveryTimestamp;
  const void *ModificationTimestamp;
  const void *v444;
  const void *v445;
  CFStringRef v446;
  const void *v447;
  const __CFDictionary *TagsFirstFoundDateDict;
  const void *v449;
  CFNumberRef v450;
  CFNumberRef v451;
  const void *TaggedRangeClass;
  const void *TaggedRangeCue;
  const __CFDictionary *MetadataDict;
  const __CFDictionary *v455;
  const void *v456;
  const void *Scte35cmd;
  uint64_t v458;
  const __CFDictionary *v459;
  const void *v460;
  const void *Scte35in;
  const __CFDictionary *v462;
  const void *v463;
  const void *Scte35out;
  const void *v465;
  const __CFArray *v466;
  uint64_t v467;
  uint64_t v468;
  CFIndex v469;
  const __CFArray *MediaSegmentSpecifiers;
  const __CFArray *v471;
  const void *v472;
  double ImputedDate;
  uint64_t k;
  uint64_t PreviousSegment;
  double v476;
  const __CFArray *v477;
  CFIndex v478;
  const void *v479;
  CFIndex v480;
  void *v481;
  uint64_t v483;
  uint64_t v484;
  const __CFString *v485;
  const char *v486;
  const __CFString *v487;
  const char *v488;
  uint64_t v489;
  const char *p_blockBufferOut;
  const __CFString *v491;
  int v492[2];
  __CFString *v493;
  const __CFString *v494;
  CFTypeRef ContentKeySpecifier;
  CFStringRef v496;
  unsigned int v497;
  unsigned int v498;
  int v499;
  char v500;
  int v501;
  uint64_t v502;
  int v503;
  const void *v504;
  uint64_t v505;
  uint64_t v506;
  uint64_t v507;
  uint64_t v508;
  int v509;
  int v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  uint64_t v514;
  int v515;
  _DWORD v516[5];
  int v517;
  int v518;
  int v519;
  uint64_t v520;
  CFStringRef v521;
  uint64_t v522;
  int v523;
  const __CFURL *v524;
  uint64_t v525;
  int v526;
  const void *v527;
  void *v528;
  void *v529;
  void *v530;
  void *v531;
  void *v532;
  void *v533;
  void *v534;
  int v535;
  int v536;
  void *DiscontinuityDomain;
  CFTypeRef v538;
  CFTypeRef v539;
  _DWORD *v540;
  CFTypeRef v541;
  CFSetRef theSet;
  CFMutableArrayRef v543;
  CFTypeRef v544;
  void *key;
  uint64_t v546;
  _BOOL4 v547;
  CFTypeRef v548;
  CFTypeRef v549;
  CFTypeRef cf;
  CFTypeRef v551;
  CFTypeRef v552;
  CFURLRef anURL;
  CFAllocatorRef structureAllocator;
  CFTypeRef v555;
  CFArrayRef theArray;
  char v557[2];
  os_log_type_t type[8];
  char v559[4];
  CFTypeRef v560;
  void *value;
  uint64_t v562;
  uint64_t v563;
  uint64_t v564;
  uint64_t v565;
  CFTypeRef v566;
  uint64_t v567;
  double v568;
  double v569;
  __int16 v570;
  uint64_t valuePtr;
  __int128 v572;
  __int128 v573;
  __int128 v574;
  void *v575;
  CFArrayRef v576;
  const void *v577;
  CFURLRef v578;
  void *v579;
  CFURLRef v580;
  char v581;
  CFTypeRef v582;
  CFTypeRef v583;
  uint64_t v584;
  CFTypeRef v585;
  int v586;
  int v587;
  double BitRate;
  const void *v589;
  CFTypeRef v590;
  unint64_t v591;
  char *v592;
  char *dataPointerOut;
  double v594;
  UInt8 *v595;
  UInt8 *temporaryBlock;
  CMBlockBufferRef v597;
  char *returnedPointerOut;
  const __CFString *v599;
  const __CFString *v600;
  const __CFString *v601;
  __int128 blockBufferOut;
  uint64_t v603;
  CFArrayRef v604;
  uint64_t v605;
  CFRange v606;
  CFRange v607;
  CFRange v608;

  v526 = a8;
  LODWORD(theArray) = a6;
  v540 = a4;
  v605 = *MEMORY[0x1E0C80C00];
  *(double *)&v592 = 0.0;
  dataPointerOut = 0;
  v590 = 0;
  v591 = 0;
  BitRate = 0.0;
  v589 = 0;
  v586 = -1;
  v587 = -1;
  v584 = 0;
  v585 = 0;
  v582 = 0;
  v583 = 0;
  v581 = 0;
  v579 = 0;
  v580 = 0;
  v577 = 0;
  v578 = 0;
  v575 = 0;
  v576 = 0;
  v573 = 0u;
  v574 = 0u;
  v572 = 0u;
  valuePtr = 0;
  v570 = 0;
  v569 = 0.0;
  v568 = 0.0;
  v567 = -1;
  v566 = 0;
  v565 = 0;
  v564 = 0;
  v563 = 0;
  v562 = 0;
  value = 0;
  v560 = 0;
  structureAllocator = (CFAllocatorRef)*MEMORY[0x1E0C9AE00];
  theSet = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B3B0]);
  if (!theSet)
  {
    matched = FigSignalErrorAt();
    v541 = 0;
    cf = 0;
    v551 = 0;
    v552 = 0;
    v549 = 0;
    v53 = 0;
    v21 = 0;
    v535 = 0;
    goto LABEL_50;
  }
  anURL = a2;
  if ((readPref & 1) == 0)
  {
    fig_note_initialize_category_with_default_work_cf();
    fig_note_initialize_category_with_default_work_cf();
    readPref = 1;
  }
  if (a3)
    v18 = a3;
  else
    v18 = a2;
  if (*__error())
  {
    v19 = *__error();
    *__error() = 0;
  }
  else
  {
    v19 = 0;
  }
  LOBYTE(temporaryBlock) = 0;
  *(_QWORD *)&blockBufferOut = 0;
  v597 = 0;
  *(double *)&returnedPointerOut = 0.0;
  DataLength = CMBlockBufferGetDataLength(a1);
  v21 = (const __CFString *)DataLength;
  v535 = v19;
  if (!DataLength)
  {
    cf = 0;
    v551 = 0;
    v552 = 0;
    v549 = 0;
    v53 = 0;
    v54 = 0;
    v55 = 0;
    v56 = 0;
    v57 = 0;
    theArray = 0;
    v544 = 0;
    v555 = 0;
    LODWORD(v546) = 0;
    v547 = 0;
    v541 = v597;
    matched = 4294954656;
    goto LABEL_1300;
  }
  appended = CMBlockBufferAccessDataBytes(a1, DataLength - 1, 1uLL, &temporaryBlock, &returnedPointerOut);
  if (!(_DWORD)appended)
  {
    if (*(double *)&returnedPointerOut == 0.0)
    {
      matched = 4294954656;
      goto LABEL_1188;
    }
    if (!*returnedPointerOut)
    {
LABEL_17:
      v23 = structureAllocator;
      matched = CMBlockBufferCreateContiguous(structureAllocator, a1, structureAllocator, 0, 0, 0, 0, &v597);
      goto LABEL_18;
    }
    LOBYTE(temporaryBlock) = 0;
    appended = CMBlockBufferCreateWithBufferReference(structureAllocator, a1, 0, (size_t)v21, 0, (CMBlockBufferRef *)&blockBufferOut);
    if (!(_DWORD)appended)
    {
      appended = CMBlockBufferAppendMemoryBlock((CMBlockBufferRef)blockBufferOut, &temporaryBlock, 1uLL, (CFAllocatorRef)*MEMORY[0x1E0C9AE20], 0, 0, 1uLL, 0);
      if (!(_DWORD)appended)
      {
        a1 = (OpaqueCMBlockBuffer *)blockBufferOut;
        goto LABEL_17;
      }
    }
  }
  matched = appended;
LABEL_1188:
  v23 = structureAllocator;
LABEL_18:
  v25 = v597;
  if ((_QWORD)blockBufferOut)
    CFRelease((CFTypeRef)blockBufferOut);
  v541 = v25;
  if ((_DWORD)matched)
    goto LABEL_49;
  DataPointer = CMBlockBufferGetDataPointer(v25, 0, 0, 0, &dataPointerOut);
  if ((_DWORD)DataPointer)
    goto LABEL_44;
  v27 = dataPointerOut;
  v28 = CMBlockBufferGetDataLength(v25);
  *(_QWORD *)&v573 = anURL;
  BYTE8(v574) = (_BYTE)theArray;
  *((_QWORD *)&v572 + 1) = a9;
  *(_QWORD *)&v574 = v27;
  BYTE9(v574) = a5;
  *((_QWORD *)&v573 + 1) = CFDictionaryCreateMutable(v23, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!*((_QWORD *)&v573 + 1))
    goto LABEL_1183;
  if (a14 && *a14)
  {
    v585 = CFRetain(*a14);
    FigMediaPlaylistGetMediaSegmentSpecifiers((uint64_t)v585);
    LastValue = FigCFArrayGetLastValue();
    if (LastValue)
      DiscontinuityDomain = (void *)FigMediaSegmentSpecifierGetDiscontinuityDomain(LastValue);
    else
      DiscontinuityDomain = 0;
    for (i = 0; ; ++i)
    {
      DateRangeSpecifiers = (const __CFArray *)FigMediaPlaylistGetDateRangeSpecifiers((uint64_t)v585);
      if (DateRangeSpecifiers)
        DateRangeSpecifiers = (const __CFArray *)CFArrayGetCount(DateRangeSpecifiers);
      if (i >= (uint64_t)DateRangeSpecifiers)
        break;
      v46 = (const __CFArray *)FigMediaPlaylistGetDateRangeSpecifiers((uint64_t)v585);
      ValueAtIndex = CFArrayGetValueAtIndex(v46, i);
      FigDateRangeSpecifierSetTempDuration((uint64_t)ValueAtIndex, -1.0);
      FigDateRangeSpecifierSetTempPlannedDuration((uint64_t)ValueAtIndex, -1.0);
      FigDateRangeSpecifierSetReadInCurrent((uint64_t)ValueAtIndex, 0);
      FigDateRangeSpecifierSetTempEndDate((uint64_t)ValueAtIndex, 0);
    }
    FigMediaPlaylistSetRenditionReportSpecifiers((uint64_t)v585, 0);
    if (FigMediaPlaylistGetPreloadHint((uint64_t)v585))
    {
      PreloadHint = FigMediaPlaylistGetPreloadHint((uint64_t)v585);
      FigMediaSegmentSpecifierSetIsReadInCurrent(PreloadHint, 0);
    }
    if (FigMediaPlaylistGetPreloadMapHint((uint64_t)v585))
    {
      PreloadMapHint = FigMediaPlaylistGetPreloadMapHint((uint64_t)v585);
      FigMediaSegmentSpecifierSetIsReadInCurrent(PreloadMapHint, 0);
    }
    PartHoldBackDuration = FigMediaPlaylistGetPartHoldBackDuration((uint64_t)v585);
    HoldBackDuration = FigMediaPlaylistGetHoldBackDuration((uint64_t)v585);
    AllocatorForMedia = FigGetAllocatorForMedia();
    DataPointer = FigMultivariantPlaylistCreateEmpty(AllocatorForMedia, &v560);
    if ((_DWORD)DataPointer)
      goto LABEL_44;
  }
  else
  {
    v30 = FigGetAllocatorForMedia();
    DataPointer = FigMediaPlaylistCreateEmpty(v30, &v585);
    if ((_DWORD)DataPointer)
    {
LABEL_44:
      matched = DataPointer;
LABEL_49:
      cf = 0;
      v551 = 0;
      v552 = 0;
      v549 = 0;
      v53 = 0;
      v21 = 0;
LABEL_50:
      v54 = 0;
      v55 = 0;
      v56 = 0;
      v57 = 0;
      theArray = 0;
      v544 = 0;
LABEL_51:
      v555 = 0;
      LODWORD(v546) = 0;
      v547 = 0;
      goto LABEL_1300;
    }
    FigMediaPlaylistSetPlaylistType((uint64_t)v585, 0);
    FigMediaPlaylistSetHasDiscontinuitySequence((uint64_t)v585, 0);
    FigMediaPlaylistSetDoesServerSupportsBlockingReload((uint64_t)v585, 0);
    HoldBackDuration = 0.0;
    FigMediaPlaylistSetSkipDeltaBoundary((uint64_t)v585, 0.0);
    if (a13 && *a13)
    {
      v560 = CFRetain(*a13);
      v32 = (uint64_t)v585;
      HasIndependentSegments = FigMultivariantPlaylistHasIndependentSegments((uint64_t)v560);
      FigMediaPlaylistSetHasIndependentSegments(v32, HasIndependentSegments);
      v34 = (uint64_t)v585;
      StartTimeValue = FigMultivariantPlaylistGetStartTimeValue((uint64_t)v560);
      FigMediaPlaylistSetStartTimeValue(v34, StartTimeValue);
      v36 = (uint64_t)v585;
      IsStartTimePrecise = FigMultivariantPlaylistIsStartTimePrecise((uint64_t)v560);
      FigMediaPlaylistSetIsStartTimePrecise(v36, IsStartTimePrecise);
      v38 = (uint64_t)v585;
      HasStartTime = FigMultivariantPlaylistHasStartTime((uint64_t)v560);
      FigMediaPlaylistSetHasStartTime(v38, HasStartTime);
      v40 = (uint64_t)v585;
      Version = FigMultivariantPlaylistGetVersion((uint64_t)v560);
      FigMediaPlaylistSetVersion(v40, Version);
      DiscontinuityDomain = 0;
      PartHoldBackDuration = 0.0;
    }
    else
    {
      v43 = FigGetAllocatorForMedia();
      DataPointer = FigMultivariantPlaylistCreateEmpty(v43, &v560);
      DiscontinuityDomain = 0;
      PartHoldBackDuration = 0.0;
      if ((_DWORD)DataPointer)
        goto LABEL_44;
    }
  }
  FigMediaPlaylistSetHasPartTag((uint64_t)v585, 0);
  FigMediaPlaylistSetDateStampCount((uint64_t)v585, 0);
  v51 = FigGetAllocatorForMedia();
  DataPointer = FigMediaSegmentSpecifierCreateEmpty(v51, (uint64_t *)&v583);
  if ((_DWORD)DataPointer)
    goto LABEL_44;
  FigMediaSegmentSpecifierSetTimeInSeconds((uint64_t)v583, 0.0);
  FigStreamPlaylistInitializeIndexValidation((uint64_t)v585);
  v52 = StreamingPlaylist_VerifyLeadingMagicNumber(v27, (const char **)&v592);
  matched = v52;
  if ((_DWORD)theArray == 1 && (_DWORD)v52)
  {
    _StreamPlaylistLogError(v52, 4294955027, (uint64_t)&v572, CFSTR("Missing #EXTM3U"));
    goto LABEL_49;
  }
  v524 = v18;
  if ((_DWORD)v52)
    goto LABEL_49;
  v58 = v592;
  v59 = &v58[strcspn(v592, "\r\n")];
  v60 = strspn(v59, "\r\n");
  v61 = (uint64_t)v585;
  TargetDuration = FigMediaPlaylistGetTargetDuration((uint64_t)v585);
  FigMediaPlaylistSetAvgSegmentDuration(v61, (double)TargetDuration);
  FigMediaPlaylistSetMaxSegmentDuration((uint64_t)v585, 0.0);
  FigMediaPlaylistSetParseDate((uint64_t)v585, 0);
  v63 = (const __CFAllocator *)FigGetAllocatorForMedia();
  Current = CFAbsoluteTimeGetCurrent();
  v65 = CFDateCreate(v63, Current);
  FigMediaPlaylistSetParseDate((uint64_t)v585, v65);
  if (v65)
    CFRelease(v65);
  if (!FigMediaPlaylistGetParseDate((uint64_t)v585))
  {
LABEL_1183:
    DataPointer = FigSignalErrorAt();
    goto LABEL_44;
  }
  v538 = 0;
  v528 = 0;
  v529 = 0;
  cf = 0;
  v551 = 0;
  v552 = 0;
  v549 = 0;
  v548 = 0;
  v517 = 0;
  LODWORD(v533) = 0;
  v536 = 0;
  LOBYTE(v525) = 0;
  NextSegment = 0;
  v509 = 0;
  v510 = 0;
  v499 = 0;
  v500 = 0;
  v519 = 0;
  v513 = 0;
  v514 = 0;
  v507 = 0;
  v508 = 0;
  v502 = 0;
  v520 = 0;
  v511 = 0;
  v512 = 0;
  memset(v516, 0, sizeof(v516));
  v505 = 0;
  v506 = 0;
  v523 = 0;
  v546 = 0;
  LODWORD(v530) = 0;
  LODWORD(v531) = 0;
  theArray = 0;
  v522 = 0;
  v539 = 0;
  LOBYTE(v534) = 0;
  LODWORD(key) = 0;
  LODWORD(v543) = 0;
  v544 = 0;
  v503 = 0;
  v501 = 0;
  LOBYTE(v547) = 0;
  v67 = (unint64_t)&v59[v60];
  v21 = 0;
  v555 = &v27[v28];
  v68 = -1.0;
  v69 = 0.0;
  v70 = 0.0;
  v71 = 0.0;
  v72 = 0.0;
  LODWORD(v527) = -2;
  v518 = 1;
  LODWORD(v532) = -1;
  while (1)
  {
    if (v67 >= (unint64_t)v555 || !*(_BYTE *)v67)
    {
      PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v583);
      v521 = v21;
      if (PartialSegments)
      {
        Count = CFArrayGetCount(PartialSegments);
        v309 = v547;
        v310 = BYTE4(v520);
        v311 = v522;
        if (Count < 1)
          goto LABEL_951;
        LOBYTE(returnedPointerOut) = 0;
        LOBYTE(blockBufferOut) = 0;
        FigMediaSegmentSpecifierSetIsDiscontinuityDomain((uint64_t)v583, (uint64_t)DiscontinuityDomain);
        v312 = v590;
        FigMediaSegmentSpecifierSetContentKeySpecifier((uint64_t)v583, v590);
        FigMediaSegmentSpecifierSetMapSegmentSpecifier((uint64_t)v583, v589);
        v313 = v591;
        FigMediaSegmentSpecifierSetMediaSequence((uint64_t)v583, v591);
        v314 = MergeLeadingPartialMediaEntries((uint64_t)v585, (uint64_t)v583, (uint64_t)&v572, (char *)&returnedPointerOut, (char *)&blockBufferOut, v526);
        if (!(_DWORD)a5)
        {
          matched = v314;
          if ((_DWORD)v314)
            goto LABEL_1387;
        }
        if (v525 | blockBufferOut)
          v315 = 1;
        else
          v315 = returnedPointerOut == 0;
        v316 = v315;
        LOBYTE(v525) = v316;
        if (!(_BYTE)returnedPointerOut)
        {
          v317 = (uint64_t)v585;
          v318 = v589;
          v319 = v582;
          IsDiscontinuity = FigMediaSegmentSpecifierIsDiscontinuity((uint64_t)v583);
          MediaFileEntry = (const void *)CreateMediaFileEntry(v317, 0, 0, v312, v318, v313, (uint64_t)DiscontinuityDomain, 0, 0.0, v71, 0, v319, v544, IsDiscontinuity, (char)v534);
          FigMediaSegmentSpecifierSetIsFragment((uint64_t)MediaFileEntry, 1);
          FigStreamPlaylistTransferPartialEntryQueue((uint64_t)v583, (uint64_t)MediaFileEntry);
          FigMediaPlaylistAddMediaSegmentSpecifier((uint64_t)v585, MediaFileEntry);
          if (MediaFileEntry)
            CFRelease(MediaFileEntry);
          if (v544)
            CFRelease(v544);
          v544 = 0;
        }
        FigMediaPlaylistGetMediaSegmentSpecifiers((uint64_t)v585);
        v322 = FigCFArrayGetLastValue();
        v323 = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments(v322);
        v324 = 0;
        if (v323)
          goto LABEL_946;
LABEL_947:
        for (j = 0; v324 < j; j = CFArrayGetCount(v323))
        {
          v325 = CFArrayGetValueAtIndex(v323, v324);
          v326 = (uint64_t)v585;
          PlaylistActiveDurationSecs = FigMediaPlaylistGetPlaylistActiveDurationSecs((uint64_t)v585);
          TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v325);
          FigMediaPlaylistSetPlaylistActiveDurationSecs(v326, PlaylistActiveDurationSecs + TimeInSeconds);
          ++v324;
          if (!v323)
            goto LABEL_947;
LABEL_946:
          ;
        }
        v21 = v521;
      }
      v309 = v547;
      v310 = BYTE4(v520);
      v311 = v522;
LABEL_951:
      if (v311 >= 1)
        FigMediaPlaylistSetAvgSegmentDuration((uint64_t)v585, v70 / (double)v311);
      *(_QWORD *)&v574 = 0;
      v547 = (v536 | HIDWORD(v514) | v516[0] | v513 | v523) != 0;
      LODWORD(v546) = 1;
      if (!(_BYTE)v525)
      {
        v330 = a14;
        if (v519 || (_DWORD)v520 || *(_OWORD *)&v516[1] != 0 || (_DWORD)v514)
          goto LABEL_967;
        LODWORD(v546) = 1;
        if (!FigMediaPlaylistHasPartTag((uint64_t)v585) && !(_DWORD)v511)
        {
          v330 = a14;
          if (v309 || v310)
            goto LABEL_967;
          LODWORD(v546) = 1;
          if (!FigMediaPlaylistHasEndTag((uint64_t)v585))
          {
            v330 = a14;
            if (!(_DWORD)v507)
            {
              HasOnlyIFrames = FigMediaPlaylistHasOnlyIFrames((uint64_t)v585);
              v330 = a14;
              LODWORD(v546) = (HasOnlyIFrames | HIDWORD(v512) | HIDWORD(v506) | v505 | v508 | HIDWORD(v505) | v506) != 0;
            }
LABEL_967:
            v100 = v330 == 0;
            v332 = !v547;
            if (v100)
              v332 = 1;
            if ((v332 & 1) == 0 && *a14)
              _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("Multivariant playlist can only be the top-level playlist"));
            if (v536 && (_BYTE)v525)
            {
              v333 = CFSTR("Alternates found in a media playlist");
LABEL_976:
              v334 = 4294951066;
LABEL_1018:
              _StreamPlaylistLogError(0, v334, (uint64_t)&v572, v333, p_blockBufferOut);
              goto LABEL_1019;
            }
            if (v536)
            {
              if (v519)
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-BYTERANGE");
              if ((_DWORD)v511)
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-TARGETDURATION");
              if (v309)
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-MEDIA-SEQUENCE");
              if (v516[2])
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-PROGRAM-DATE-TIME");
              if ((_DWORD)v507)
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-PLAYLIST-TYPE");
              if (FigMediaPlaylistHasEndTag((uint64_t)v585))
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-ENDLIST");
              if ((_DWORD)v520)
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-DISCONTINUITY");
              if (v310)
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-DISCONTINUITY-SEQUENCE");
              if (FigMediaPlaylistHasOnlyIFrames((uint64_t)v585))
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-I-FRAMES-ONLY");
              if (v516[3])
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-MAP");
              if ((_DWORD)v505)
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-DATERANGE");
              if (v516[4])
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-KEY");
              if (v516[1])
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-GAP");
              if ((_DWORD)v514)
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-BITRATE");
              if (FigMediaPlaylistHasPartTag((uint64_t)v585))
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-PART");
              if (HIDWORD(v512))
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-PART-INF");
              if (HIDWORD(v505))
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-PRELOAD-HINT");
              if ((_DWORD)v506)
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-RENDITION-REPORT");
              if (HIDWORD(v506))
                _StreamPlaylistLogError(0, 4294951065, (uint64_t)&v572, CFSTR("%s can only be in media playlist"), "#EXT-X-SERVER-CONTROL");
              if ((_DWORD)v508)
              {
                p_blockBufferOut = "#EXT-X-SKIP";
                v333 = CFSTR("%s can only be in media playlist");
                v334 = 4294951065;
                goto LABEL_1018;
              }
            }
            else if ((_BYTE)v525)
            {
              if (HIDWORD(v514))
                _StreamPlaylistLogError(0, 4294951066, (uint64_t)&v572, CFSTR("%s can only be in multivariant playlist"), "#EXT-X-MEDIA");
              if (v516[0])
                _StreamPlaylistLogError(0, 4294951066, (uint64_t)&v572, CFSTR("%s can only be in multivariant playlist"), "#EXT-X-SESSION-DATA");
              if ((_DWORD)v513)
                _StreamPlaylistLogError(0, 4294951066, (uint64_t)&v572, CFSTR("%s can only be in multivariant playlist"), "#EXT-X-SESSION-KEY");
              if (v523)
              {
                p_blockBufferOut = "#EXT-X-CONTENT-STEERING";
                v333 = CFSTR("%s can only be in multivariant playlist");
                goto LABEL_976;
              }
            }
LABEL_1019:
            if (BYTE4(v513) && (int)v572 < 5
              || HIDWORD(v507) && (int)v572 < 12
              || v581 && (int)v572 < 11
              || (_DWORD)v508 && (int)v572 < 9
              || BYTE10(v574) && (int)v572 < 8
              || (!v517 ? (v335 = (_DWORD)v502 == 0) : (v335 = 1),
                  v335 ? (v336 = BYTE4(v502) == 0) : (v336 = 0),
                  !v336 && (int)v572 < 6
               || v519 | v517 && (int)v572 < 4
               || BYTE4(v508) && (int)v572 < 3
               || v501 && (int)v572 < 13
               || v500 && (int)v572 <= 1))
            {
              matched = 4294954654;
              _StreamPlaylistLogError(4294954654, 4294954986, (uint64_t)&v572, CFSTR("incorrect version number for feature"), p_blockBufferOut);
              if (!(_DWORD)a5)
                goto LABEL_1190;
            }
            if (FigMediaPlaylistHasSkipDeltaBoundary((uint64_t)v585))
            {
              SkipDeltaBoundary = FigMediaPlaylistGetSkipDeltaBoundary((uint64_t)v585);
              if (SkipDeltaBoundary < (double)(6 * FigMediaPlaylistGetTargetDuration((uint64_t)v585)))
              {
                matched = 4294954654;
                _StreamPlaylistLogError(4294954654, 4294949662, (uint64_t)&v572, CFSTR("CAN-SKIP-UNTIL too small"));
                if (!(_DWORD)a5)
                  goto LABEL_1190;
              }
            }
            if (FigMediaPlaylistHasSkipDeltaBoundary((uint64_t)v585))
            {
              if (NextSegment)
              {
                v338 = 0.0;
                do
                {
                  v338 = v338 + FigMediaSegmentSpecifierGetTimeInSeconds(NextSegment);
                  NextSegment = FigMediaSegmentSpecifierGetNextSegment(NextSegment);
                }
                while (NextSegment);
                if (v338 < FigMediaPlaylistGetSkipDeltaBoundary((uint64_t)v585))
                {
                  matched = 4294954654;
                  _StreamPlaylistLogError(4294954654, 4294949661, (uint64_t)&v572, CFSTR("EXT-X-SKIP too close to live edge"));
                  if (!(_DWORD)a5)
                  {
LABEL_1190:
                    v54 = 0;
                    v55 = 0;
                    v56 = 0;
                    v57 = 0;
                    v555 = 0;
                    goto LABEL_1299;
                  }
                }
              }
            }
            if (HIDWORD(v512) == 1)
            {
              PartTargetDuration = FigMediaPlaylistGetPartTargetDuration((uint64_t)v585);
              v53 = v548;
              if (PartTargetDuration > (double)FigMediaPlaylistGetTargetDuration((uint64_t)v585))
              {
                v340 = FigMediaPlaylistGetPartTargetDuration((uint64_t)v585);
                matched = 4294954654;
                _StreamPlaylistLogError(4294954654, 4294949662, (uint64_t)&v572, CFSTR("%s Partial Segment target duration %f exceeds %s"), "PART-TARGET", *(_QWORD *)&v340, "#EXT-X-TARGETDURATION");
                if (!(_DWORD)a5)
                  goto LABEL_1378;
              }
              v341 = v569;
              if (v341 > FigMediaPlaylistGetPartTargetDuration((uint64_t)v585))
              {
                matched = 4294954654;
                _StreamPlaylistLogError(4294954654, 4294949662, (uint64_t)&v572, CFSTR("%s Partial Segment duration %f exceeds %s"), "#EXT-X-PART", *(_QWORD *)&v341, "PART-TARGET");
                if (!(_DWORD)a5)
                  goto LABEL_1378;
              }
              if (FigMediaPlaylistHasPartHoldBackDuration((uint64_t)v585))
                goto LABEL_1065;
              matched = 4294954650;
              _StreamPlaylistLogError(4294954650, 4294955032, (uint64_t)&v572, CFSTR("%s required with %s"), "PART-HOLD-BACK", "#EXT-X-PART-INF");
            }
            else
            {
              v53 = v548;
              if (!FigMediaPlaylistHasPartTag((uint64_t)v585))
                goto LABEL_1065;
              matched = 4294954654;
              _StreamPlaylistLogError(4294954654, 4294955024, (uint64_t)&v572, CFSTR("Partial segments, but no part target duration"), p_blockBufferOut, v491);
            }
            if (!(_DWORD)a5)
            {
LABEL_1378:
              v54 = 0;
              v55 = 0;
              v56 = 0;
              v57 = 0;
              v555 = 0;
              goto LABEL_1300;
            }
LABEL_1065:
            if (FigMediaPlaylistGetPlaylistType((uint64_t)v585) == 2
              && !FigMediaPlaylistHasEndTag((uint64_t)v585))
            {
              matched = 4294954654;
              _StreamPlaylistLogError(4294954654, 4294954983, (uint64_t)&v572, CFSTR("VOD playlist has no ENDLIST tag"));
              if (!(_DWORD)a5)
                goto LABEL_1378;
            }
            if (a14)
            {
              if (*a14)
              {
                if (!v309)
                {
                  if (FigMediaPlaylistHasMediaSequence((uint64_t)v585))
                  {
                    matched = 4294954654;
                    _StreamPlaylistLogError(4294954654, 4294955026, (uint64_t)&v572, CFSTR("#EXT-X-MEDIA-SEQUENCE suddenly disappeared"));
                    if (!(_DWORD)a5)
                      goto LABEL_1378;
                  }
                }
              }
              FigMediaPlaylistSetHasMediaSequence((uint64_t)v585, v309);
              if (*a14)
              {
                if (!v310)
                {
                  if (FigMediaPlaylistHasDiscontinuitySequence((uint64_t)v585))
                  {
                    matched = 4294954654;
                    _StreamPlaylistLogError(4294954654, 4294951061, (uint64_t)&v572, CFSTR("%s is no longer in Media Playlist"), "#EXT-X-DISCONTINUITY-SEQUENCE");
                    if (!(_DWORD)a5)
                      goto LABEL_1378;
                  }
                }
              }
            }
            else
            {
              FigMediaPlaylistSetHasMediaSequence((uint64_t)v585, v309);
            }
            FigMediaPlaylistSetHasDiscontinuitySequence((uint64_t)v585, v310);
            if (FigMediaPlaylistGetPlaylistType((uint64_t)v585) == 1
              && FigMediaPlaylistHasEndTag((uint64_t)v585))
            {
              FigMediaPlaylistSetPlaylistType((uint64_t)v585, 2);
            }
            if (!(FigMediaPlaylistGetTargetDuration((uint64_t)v585) | v536))
            {
              if (v309 == 1)
              {
                matched = 4294954654;
                _StreamPlaylistLogError(4294954654, 4294955024, (uint64_t)&v572, CFSTR("Media sequence, but no target duration"), p_blockBufferOut);
              }
              else
              {
                matched = 4294954650;
                _StreamPlaylistLogError(4294954650, 4294954985, (uint64_t)&v572, CFSTR("Stream type unrecognized"), p_blockBufferOut);
              }
              if (!(_DWORD)a5)
                goto LABEL_1378;
            }
            if (v536)
            {
              if (HIDWORD(v511))
              {
                if (v510)
                {
                  matched = 4294954654;
                  _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("Some stream definitions have %s groups while some have opted out"), "CLOSED-CAPTIONS");
                  if (!(_DWORD)a5)
                    goto LABEL_1378;
                }
              }
            }
            if (FigMediaPlaylistHasHoldBackDuration((uint64_t)v585))
            {
              v342 = FigMediaPlaylistGetHoldBackDuration((uint64_t)v585);
              if (v342 < (double)(3 * FigMediaPlaylistGetTargetDuration((uint64_t)v585)))
              {
                matched = 4294954650;
                _StreamPlaylistLogError(4294954650, 4294955032, (uint64_t)&v572, CFSTR("%s less than 3 * target-duration"), "HOLD-BACK");
                if (!(_DWORD)a5)
                  goto LABEL_1378;
              }
            }
            if (FigMediaPlaylistGetPartTargetDuration((uint64_t)v585) > 0.0)
            {
              v343 = FigMediaPlaylistGetPartHoldBackDuration((uint64_t)v585);
              if (v343 < FigMediaPlaylistGetPartTargetDuration((uint64_t)v585))
              {
                if (FigMediaPlaylistDoesServerSupportsBlockingReload((uint64_t)v585))
                {
                  matched = 4294954650;
                  _StreamPlaylistLogError(4294954650, 4294955032, (uint64_t)&v572, CFSTR("%s less than %s"), "PART-HOLD-BACK", "PART-TARGET");
                  if (!(_DWORD)a5)
                    goto LABEL_1378;
                }
              }
            }
            FigMediaPlaylistSetHasIndependentParts((uint64_t)v585, v512);
            if (FigMediaPlaylistGetPreloadHint((uint64_t)v585))
            {
              v344 = FigMediaPlaylistGetPreloadHint((uint64_t)v585);
              if (FigMediaSegmentSpecifierIsReadInCurrent(v344))
              {
                FigMediaPlaylistGetMediaSegmentSpecifiers((uint64_t)v585);
                v345 = FigCFArrayGetLastValue();
                if (v345)
                {
                  FigMediaSegmentSpecifierGetPartialSegments(v345);
                  v346 = FigCFArrayGetLastValue();
                  if (v346)
                  {
                    v347 = v346;
                    FigMediaSegmentSpecifierGetURLString(v346);
                    v348 = v21;
                    v349 = FigMediaPlaylistGetPreloadHint((uint64_t)v585);
                    FigMediaSegmentSpecifierGetURLString(v349);
                    if (FigCFEqual())
                    {
                      v350 = FigMediaPlaylistGetPreloadHint((uint64_t)v585);
                      StartOffset = FigMediaSegmentSpecifierGetStartOffset(v350);
                      v352 = FigMediaSegmentSpecifierGetStartOffset(v347);
                      v98 = StartOffset < FigMediaSegmentSpecifierGetBytesToRead(v347) + v352;
                      v21 = v348;
                      if (v98)
                      {
                        v353 = FigMediaPlaylistGetPreloadHint((uint64_t)v585);
                        if (FigMediaSegmentSpecifierGetBytesToRead(v353) >= 1)
                        {
                          v354 = FigMediaPlaylistGetPreloadHint((uint64_t)v585);
                          v355 = FigMediaPlaylistGetPreloadHint((uint64_t)v585);
                          v356 = FigMediaSegmentSpecifierGetBytesToRead(v355);
                          v357 = FigMediaSegmentSpecifierGetStartOffset(v347);
                          v358 = FigMediaSegmentSpecifierGetBytesToRead(v347);
                          v359 = FigMediaPlaylistGetPreloadHint((uint64_t)v585);
                          v360 = FigMediaSegmentSpecifierGetStartOffset(v359);
                          v361 = v357 + v358;
                          v53 = v548;
                          FigMediaSegmentSpecifierSetBytesToRead(v354, v356 - v361 + v360);
                        }
                        v362 = FigMediaPlaylistGetPreloadHint((uint64_t)v585);
                        v363 = FigMediaSegmentSpecifierGetStartOffset(v347);
                        v364 = FigMediaSegmentSpecifierGetBytesToRead(v347);
                        FigMediaSegmentSpecifierSetStartOffset(v362, v364 + v363);
                        v21 = v348;
                      }
                    }
                  }
                }
              }
            }
            *v540 = 0;
            if (!v536)
            {
              v555 = 0;
              goto LABEL_1140;
            }
            *v540 = 1;
            FigMultivariantPlaylistGetClosedCaptionGroups((uint64_t)v560);
            if (FigCFDictionaryGetCount()
              || (FigMultivariantPlaylistGetSubtitleGroups((uint64_t)v560), FigCFDictionaryGetCount()))
            {
              v365 = 0;
            }
            else
            {
              v366 = theArray;
              v365 = 0;
              v370 = 1;
              if (!HIBYTE(v570) || v510)
                goto LABEL_1117;
              v371 = PlaylistAddCharacteristicsForClosedCaptions(&v576);
              if ((_DWORD)v371)
                goto LABEL_1377;
              v409 = v576;
              matched = PlaylistAddMediaGroup((uint64_t)v560, 1668047728, CFSTR("CC"), 0, 0, 0, 0, 0, 0.0, 1, 1, 0, 1, v576, 0, CFSTR("UnspecifiedClosedCaptionChannel"), 0, 0, &valuePtr);
              if (v409)
              {
                CFRelease(v409);
                v576 = 0;
              }
              if ((_DWORD)matched)
                goto LABEL_1378;
              v365 = 1;
            }
            v366 = theArray;
            MediaSelectionArray = (const __CFArray *)FigMultivariantPlaylistGetMediaSelectionArray((uint64_t)v560);
            CFStringForOSTypeValue = (const void *)FigGetCFStringForOSTypeValue();
            MediaSelectionOptionArrayByMediaType = (const __CFArray *)FindMediaSelectionOptionArrayByMediaType(MediaSelectionArray, CFStringForOSTypeValue);
            if (MediaSelectionOptionArrayByMediaType && CFArrayGetCount(MediaSelectionOptionArrayByMediaType))
            {
              v370 = 1;
              goto LABEL_1117;
            }
            v371 = PlaylistAddMediaGroup((uint64_t)v560, 1936684398, CFSTR("AUDIO"), 0, 0, 0, 0, 0, 0.0, 1, 1, 0, 0, 0, 0, 0, 0, 0, &valuePtr);
            v370 = 0;
            if (!(_DWORD)v371)
            {
LABEL_1117:
              v372 = 0;
              v373 = 0;
              v555 = 0;
              v374 = 0;
              theArray = v366;
              while (1)
              {
                Alternates = (const __CFArray *)FigMultivariantPlaylistGetAlternates((uint64_t)v560);
                if (Alternates)
                  Alternates = (const __CFArray *)CFArrayGetCount(Alternates);
                if (v374 >= (uint64_t)Alternates)
                  break;
                v376 = (const __CFArray *)FigMultivariantPlaylistGetAlternates((uint64_t)v560);
                v377 = CFArrayGetValueAtIndex(v376, v374);
                AudioGroupIDString = FigAlternateGetAudioGroupIDString((uint64_t)v377);
                AudioGroups = (const __CFDictionary *)FigMultivariantPlaylistGetAudioGroups((uint64_t)v560);
                SelectionGroupGuts = PlaylistGetSelectionGroupGuts(AudioGroupIDString, 1936684398, AudioGroups, (uint64_t)&v572, &v565);
                if ((_DWORD)SelectionGroupGuts)
                  goto LABEL_1180;
                VideoGroupIDString = FigAlternateGetVideoGroupIDString((uint64_t)v377);
                VideoGroups = (const __CFDictionary *)FigMultivariantPlaylistGetVideoGroups((uint64_t)v560);
                SelectionGroupGuts = PlaylistGetSelectionGroupGuts(VideoGroupIDString, 1986618469, VideoGroups, (uint64_t)&v572, &v564);
                if ((_DWORD)SelectionGroupGuts)
                  goto LABEL_1180;
                SubtitleGroupIDString = FigAlternateGetSubtitleGroupIDString((uint64_t)v377);
                SubtitleGroups = (const __CFDictionary *)FigMultivariantPlaylistGetSubtitleGroups((uint64_t)v560);
                SelectionGroupGuts = PlaylistGetSelectionGroupGuts(SubtitleGroupIDString, 1935832172, SubtitleGroups, (uint64_t)&v572, &v563);
                if ((_DWORD)SelectionGroupGuts)
                  goto LABEL_1180;
                ClosedCaptionGroupIDString = FigAlternateGetClosedCaptionGroupIDString((uint64_t)v377);
                ClosedCaptionGroups = (const __CFDictionary *)FigMultivariantPlaylistGetClosedCaptionGroups((uint64_t)v560);
                SelectionGroupGuts = PlaylistGetSelectionGroupGuts(ClosedCaptionGroupIDString, 1668047728, ClosedCaptionGroups, (uint64_t)&v572, &v562);
                if ((_DWORD)SelectionGroupGuts)
                  goto LABEL_1180;
                if ((v370 & 1) != 0)
                {
                  v387 = 0;
                }
                else
                {
                  v372 = 1;
                  v387 = CFSTR("AUDIO");
                }
                if (v365)
                {
                  v373 = 1;
                  v388 = CFSTR("CC");
                }
                else
                {
                  v388 = 0;
                }
                SelectionGroupGuts = FigAlternateCopy((uint64_t)v377, 0, 0, 0, 0, 0, (uint64_t)v387, v372, 0, 0, (uint64_t)v388, v373, 0, 0, 0, v565, v564, v563, v562,
                                       &value);
                if ((_DWORD)SelectionGroupGuts)
                {
LABEL_1180:
                  matched = SelectionGroupGuts;
                  goto LABEL_1181;
                }
                Mutable = (void *)v555;
                if (!v555)
                {
                  v390 = (const __CFAllocator *)FigGetAllocatorForMedia();
                  Mutable = CFArrayCreateMutable(v390, 0, MEMORY[0x1E0C9B378]);
                  if (!Mutable)
                  {
                    matched = FigSignalErrorAt();
                    v54 = 0;
                    v55 = 0;
                    v56 = 0;
                    v57 = 0;
                    v555 = 0;
                    goto LABEL_1298;
                  }
                }
                v555 = Mutable;
                CFArrayAppendValue((CFMutableArrayRef)Mutable, value);
                if (value)
                  CFRelease(value);
                v365 = 0;
                value = 0;
                v565 = 0;
                v564 = 0;
                v563 = 0;
                ++v374;
                v370 = 1;
                v562 = 0;
              }
              if (v555)
                FigMultivariantPlaylistSetAlternates((uint64_t)v560, v555);
              FigMultivariantPlaylistSetPlaylistVariables((uint64_t)v560, *((CFTypeRef *)&v573 + 1));
              v21 = v521;
              v53 = v548;
LABEL_1140:
              if (a10 && v560)
              {
                v391 = (const __CFArray *)FigMultivariantPlaylistGetMediaSelectionArray((uint64_t)v560);
                v392 = CFArrayCreateMutable(structureAllocator, 0, MEMORY[0x1E0C9B378]);
                if (v392)
                {
                  v393 = v392;
                  v394 = v21;
                  if (v391)
                  {
                    v395 = CFArrayGetCount(v391);
                    if (v395 >= 1)
                    {
                      v396 = v395;
                      v397 = 0;
                      v398 = 0;
                      v399 = 0;
                      while (1)
                      {
                        v400 = (const __CFDictionary *)CFArrayGetValueAtIndex(v391, v397);
                        v401 = v400;
                        if (!v399)
                        {
                          v402 = (const __CFArray *)CFDictionaryGetValue(v400, CFSTR("MediaSelectionGroupMediaCharacteristics"));
                          v607.length = CFArrayGetCount(v402);
                          v607.location = 0;
                          if (CFArrayContainsValue(v402, v607, CFSTR("public.legible")))
                          {
                            CFDictionaryGetValue(v401, CFSTR("MediaSelectionGroupOptions"));
                            ConcatenationOfTwoArrays = FigCFArrayCreateConcatenationOfTwoArrays();
                            if (!ConcatenationOfTwoArrays)
                            {
                              matched = FigSignalErrorAt();
                              v53 = v548;
                              if (!(_DWORD)matched)
                                goto LABEL_1192;
LABEL_1163:
                              CFRelease(v393);
                              v54 = 0;
                              v55 = 0;
                              v56 = 0;
                              v57 = 0;
                              v21 = v394;
                              goto LABEL_1300;
                            }
                            v398 = (const void *)ConcatenationOfTwoArrays;
                            MutableCopy = (__CFDictionary *)FigCFDictionaryCreateMutableCopy();
                            if (!MutableCopy)
                            {
                              matched = FigSignalErrorAt();
                              v53 = v548;
                              goto LABEL_1161;
                            }
                            v399 = MutableCopy;
                            CFDictionarySetValue(MutableCopy, CFSTR("MediaSelectionGroupOptions"), v398);
                            v401 = v399;
                          }
                          else
                          {
                            v399 = 0;
                          }
                        }
                        CFArrayAppendValue(v393, v401);
                        if (v396 == ++v397)
                        {
                          if (!v399)
                            goto LABEL_1156;
LABEL_1159:
                          CFRelease(v399);
                          matched = 0;
                          goto LABEL_1160;
                        }
                      }
                    }
                  }
                  v398 = 0;
LABEL_1156:
                  v405 = CFArrayCreate(structureAllocator, (const void **)kFigStdAssetMediaCharacteristic_Legible, 1, MEMORY[0x1E0C9B378]);
                  if (v405)
                  {
                    v406 = v405;
                    *(double *)&returnedPointerOut = COERCE_DOUBLE(CFSTR("MediaSelectionGroupMediaType"));
                    v407 = FigGetCFStringForOSTypeValue();
                    v408 = *MEMORY[0x1E0C9AE50];
                    *(_QWORD *)&blockBufferOut = v407;
                    *((_QWORD *)&blockBufferOut + 1) = v408;
                    v599 = CFSTR("MediaSelectionGroupAllowEmptySelection");
                    v600 = CFSTR("MediaSelectionGroupOptions");
                    v601 = CFSTR("MediaSelectionGroupMediaCharacteristics");
                    v603 = a10;
                    v604 = v406;
                    v399 = CFDictionaryCreate(structureAllocator, (const void **)&returnedPointerOut, (const void **)&blockBufferOut, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                    CFRelease(v406);
                    if (v399)
                    {
                      CFArrayAppendValue(v393, v399);
                      goto LABEL_1159;
                    }
                  }
                  matched = FigSignalErrorAt();
LABEL_1160:
                  v53 = v548;
                  if (v398)
LABEL_1161:
                    CFRelease(v398);
                  if ((_DWORD)matched)
                    goto LABEL_1163;
LABEL_1192:
                  FigMultivariantPlaylistSetMediaSelectionArray((uint64_t)v560, v393);
                  CFRelease(v393);
                  v21 = v394;
                }
                else
                {
                  v483 = FigSignalErrorAt();
                  if ((_DWORD)v483)
                  {
                    matched = v483;
                    v54 = 0;
                    v55 = 0;
                    v56 = 0;
                    v57 = 0;
                    goto LABEL_1299;
                  }
                  FigMultivariantPlaylistSetMediaSelectionArray((uint64_t)v560, 0);
                  v53 = v548;
                }
              }
              v410 = v540;
              if ((_BYTE)v525)
              {
                if (!v517)
                {
                  v411 = FigMediaPlaylistGetTargetDuration((uint64_t)v585);
                  v410 = v540;
                  if (v69 > (double)(2 * v411))
                  {
                    v484 = FigMediaPlaylistGetTargetDuration((uint64_t)v585);
                    matched = 4294954654;
                    _StreamPlaylistLogError(4294954654, 4294955023, (uint64_t)&v572, CFSTR("Max extinf duration of %g more than 2 * target duration %d"), *(_QWORD *)&v69, v484);
                    v54 = 0;
                    v55 = 0;
                    v56 = 0;
                    v57 = 0;
                    goto LABEL_1300;
                  }
                }
                *v410 |= 2u;
              }
              v412 = 0;
              matched = 0;
              v413 = (uint64_t)v585;
              while (1)
              {
                v414 = (const __CFArray *)FigMediaPlaylistGetDateRangeSpecifiers(v413);
                if (v414)
                  v414 = (const __CFArray *)CFArrayGetCount(v414);
                if (v412 >= (uint64_t)v414)
                  break;
                v415 = (const __CFArray *)FigMediaPlaylistGetDateRangeSpecifiers(v413);
                v416 = CFArrayGetValueAtIndex(v415, v412);
                if (theArray)
                {
                  v417 = CFArrayGetCount(theArray);
                  Identifier = (const void *)FigDateRangeSpecifierGetIdentifier((uint64_t)v416);
                  v608.location = 0;
                  v608.length = v417;
                  if (CFArrayContainsValue(theArray, v608, Identifier))
                  {
                    if (FigDateRangeSpecifierGetReadInCurrent((uint64_t)v416))
                    {
                      matched = 4294954654;
                      _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s: %s cannot be present in Playlist and also appear in %s"), "#EXT-X-DATERANGE", "ID", "RECENTLY-REMOVED-DATERANGES");
                    }
                  }
                  else
                  {
                    FigDateRangeSpecifierSetReadInCurrent((uint64_t)v416, 1);
                  }
                }
                if (FigDateRangeSpecifierGetReadInCurrent((uint64_t)v416))
                {
                  TempDuration = FigDateRangeSpecifierGetTempDuration((uint64_t)v416);
                  FigDateRangeSpecifierSetDuration((uint64_t)v416, TempDuration);
                  TempEndDate = (const void *)FigDateRangeSpecifierGetTempEndDate((uint64_t)v416);
                  FigDateRangeSpecifierSetEndDate((uint64_t)v416, TempEndDate);
                  if (FigDateRangeSpecifierGetPlannedDuration((uint64_t)v416) == -1.0)
                  {
                    ParseDate = (const void *)FigMediaPlaylistGetParseDate(v413);
                    FigDateRangeSpecifierSetValueForTagsFirstFoundDateDict((uint64_t)v416, CFSTR("PLANNED-DURATION"), ParseDate);
                  }
                  TempPlannedDuration = FigDateRangeSpecifierGetTempPlannedDuration((uint64_t)v416);
                  FigDateRangeSpecifierSetPlannedDuration((uint64_t)v416, TempPlannedDuration);
                  if (FigDateRangeSpecifierGetEndDate((uint64_t)v416)
                    && FigDateRangeSpecifierGetDuration((uint64_t)v416) >= 0.0)
                  {
                    if ((_QWORD)v574 || !FigDateRangeSpecifierGetTaggedRangeLine((uint64_t)v416))
                    {
                      v423 = theArray;
                      v424 = 1;
                    }
                    else
                    {
                      v423 = theArray;
                      v426 = v575;
                      if (v575)
                      {
                        v575 = 0;
                        free(v426);
                      }
                      FigDateRangeSpecifierGetTaggedRangeLine((uint64_t)v416);
                      v424 = 0;
                      *(_QWORD *)&v574 = FigCFStringGetCStringPtrAndBufferToFree();
                    }
                    Duration = FigDateRangeSpecifierGetDuration((uint64_t)v416);
                    EndDate = (const __CFDate *)FigDateRangeSpecifierGetEndDate((uint64_t)v416);
                    StartDate = (const __CFDate *)FigDateRangeSpecifierGetStartDate((uint64_t)v416);
                    theArray = v423;
                    if (vabdd_f64(Duration, CFDateGetTimeIntervalSinceDate(EndDate, StartDate)) >= 0.001)
                    {
                      matched = 4294954654;
                      _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s: %s not equal to the value of %s minus the value of %s"), "#EXT-X-DATERANGE", "DURATION", "START-DATE", "END-DATE");
                      v55 = 0;
                      v56 = 0;
                      v57 = 0;
                      v21 = v521;
                      v53 = v548;
                      v54 = 0;
                      goto LABEL_1300;
                    }
                    if ((v424 & 1) == 0)
                      *(_QWORD *)&v574 = 0;
                  }
                }
                else
                {
                  MutableDateRangeSpecifiers = (__CFArray *)FigMediaPlaylistGetMutableDateRangeSpecifiers(v413);
                  CFArrayRemoveValueAtIndex(MutableDateRangeSpecifiers, v412--);
                  LOBYTE(v570) = 1;
                }
                ++v412;
              }
              if ((_DWORD)matched)
              {
LABEL_1181:
                v54 = 0;
                v55 = 0;
                v56 = 0;
                v57 = 0;
                goto LABEL_1298;
              }
              v430 = v540;
              v431 = structureAllocator;
              if ((_BYTE)v570)
              {
                v432 = (uint64_t)v585;
                v433 = (const __CFArray *)FigMediaPlaylistGetDateRangeSpecifiers((uint64_t)v585);
                if (!v433 || CFArrayGetCount(v433) < 1)
                  goto LABEL_1264;
                v543 = CFArrayCreateMutable(structureAllocator, 0, MEMORY[0x1E0C9B378]);
                if (v543)
                {
                  v434 = 0;
                  *(double *)&returnedPointerOut = 0.0;
                  v599 = 0;
                  v600 = 0;
                  v527 = (const void *)*MEMORY[0x1E0CA23F8];
                  v435 = (const void *)*MEMORY[0x1E0CA2440];
                  v436 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
                  while (1)
                  {
                    v437 = (const __CFArray *)FigMediaPlaylistGetDateRangeSpecifiers(v432);
                    if (v437)
                      v437 = (const __CFArray *)CFArrayGetCount(v437);
                    if (v434 >= (uint64_t)v437)
                    {
                      FigMediaPlaylistSetDateEntryArray((uint64_t)v585, v543);
                      CFRelease(v543);
                      goto LABEL_1265;
                    }
                    v438 = (const __CFArray *)FigMediaPlaylistGetDateRangeSpecifiers(v432);
                    v439 = (const __CFString *)CFArrayGetValueAtIndex(v438, v434);
                    v440 = CFDictionaryCreateMutable(v431, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                    if (!v440)
                      break;
                    v441 = v440;
                    *(double *)&key = COERCE_DOUBLE(CFArrayCreateMutable(v431, 0, v436));
                    if (*(double *)&key == 0.0)
                      goto LABEL_1258;
                    DiscoveryTimestamp = (const void *)FigDateRangeSpecifierGetDiscoveryTimestamp((uint64_t)v439);
                    CFDictionaryAddValue(v441, CFSTR("TaggedRangeMetadataKey_DiscoveryTimestamp"), DiscoveryTimestamp);
                    ModificationTimestamp = (const void *)FigDateRangeSpecifierGetModificationTimestamp((uint64_t)v439);
                    CFDictionaryAddValue(v441, CFSTR("TaggedRangeMetadataKey_ModificationTimestamp"), ModificationTimestamp);
                    v444 = (const void *)FigDateRangeSpecifierGetIdentifier((uint64_t)v439);
                    CFDictionaryAddValue(v441, CFSTR("TaggedRangeMetadataKey_ID"), v444);
                    v445 = (const void *)FigDateRangeSpecifierGetStartDate((uint64_t)v439);
                    CFDictionaryAddValue(v441, CFSTR("TaggedRangeMetadataKey_StartDate"), v445);
                    if (anURL)
                    {
                      v446 = CFURLGetString(anURL);
                      CFDictionaryAddValue(v441, CFSTR("TaggedRangeMetadataKey_BaseURL"), v446);
                    }
                    if (FigDateRangeSpecifierGetEndDate((uint64_t)v439))
                    {
                      v447 = (const void *)FigDateRangeSpecifierGetEndDate((uint64_t)v439);
                      CFDictionarySetValue(v441, CFSTR("TaggedRangeMetadataKey_EndDate"), v447);
                    }
                    if (FigDateRangeSpecifierGetDuration((uint64_t)v439) >= 0.0)
                    {
                      FigDateRangeSpecifierGetDuration((uint64_t)v439);
                      FigCFDictionarySetDouble();
                    }
                    *(_QWORD *)&blockBufferOut = 0;
                    *(_QWORD *)&blockBufferOut = FigDateRangeSpecifierGetPlannedDuration((uint64_t)v439);
                    if (*(double *)&blockBufferOut >= 0.0)
                    {
                      TagsFirstFoundDateDict = (const __CFDictionary *)FigDateRangeSpecifierGetTagsFirstFoundDateDict((uint64_t)v439);
                      v449 = CFDictionaryGetValue(TagsFirstFoundDateDict, CFSTR("PLANNED-DURATION"));
                      v450 = CFNumberCreate(v431, kCFNumberDoubleType, &blockBufferOut);
                      if (!v450)
                      {
LABEL_1258:
                        v458 = FigSignalErrorAt();
LABEL_1259:
                        matched = v458;
LABEL_1260:
                        CFRelease(v543);
                        CFRelease(v441);
                        if (*(double *)&key != 0.0)
                        {
                          v465 = key;
                          goto LABEL_1262;
                        }
                        goto LABEL_1263;
                      }
                      v451 = v450;
                      CFDictionarySetValue(v441, CFSTR("TaggedRangeMetadataKey_PlannedDuration"), v450);
                      matched = PlaylistAddTaggedRangeMetadataDictionaryToArray((__CFArray *)key, CFSTR("PLANNED-DURATION"), v451, v527, v449);
                      CFRelease(v451);
                      if ((_DWORD)matched)
                        goto LABEL_1260;
                    }
                    if (FigDateRangeSpecifierGetTaggedRangeClass((uint64_t)v439))
                    {
                      TaggedRangeClass = (const void *)FigDateRangeSpecifierGetTaggedRangeClass((uint64_t)v439);
                      CFDictionaryAddValue(v441, CFSTR("TaggedRangeMetadataKey_Class"), TaggedRangeClass);
                    }
                    if (FigDateRangeSpecifierGetTaggedRangeCue((uint64_t)v439))
                    {
                      TaggedRangeCue = (const void *)FigDateRangeSpecifierGetTaggedRangeCue((uint64_t)v439);
                      CFDictionaryAddValue(v441, CFSTR("TaggedRangeMetadataKey_Cue"), TaggedRangeCue);
                    }
                    LODWORD(v600) = 0;
                    returnedPointerOut = (char *)key;
                    v599 = v439;
                    MetadataDict = (const __CFDictionary *)FigDateRangeSpecifierGetMetadataDict((uint64_t)v439);
                    CFDictionaryApplyFunction(MetadataDict, (CFDictionaryApplierFunction)TaggedRangeTagApplier, &returnedPointerOut);
                    matched = v600;
                    if ((_DWORD)v600)
                      goto LABEL_1260;
                    if (FigDateRangeSpecifierGetScte35cmd((uint64_t)v439))
                    {
                      v455 = (const __CFDictionary *)FigDateRangeSpecifierGetTagsFirstFoundDateDict((uint64_t)v439);
                      v456 = CFDictionaryGetValue(v455, CFSTR("SCTE35-CMD"));
                      Scte35cmd = (const void *)FigDateRangeSpecifierGetScte35cmd((uint64_t)v439);
                      v458 = PlaylistAddTaggedRangeMetadataDictionaryToArray((__CFArray *)key, CFSTR("SCTE35-CMD"), Scte35cmd, v435, v456);
                      if ((_DWORD)v458)
                        goto LABEL_1259;
                    }
                    if (FigDateRangeSpecifierGetScte35in((uint64_t)v439))
                    {
                      v459 = (const __CFDictionary *)FigDateRangeSpecifierGetTagsFirstFoundDateDict((uint64_t)v439);
                      v460 = CFDictionaryGetValue(v459, CFSTR("SCTE35-IN"));
                      Scte35in = (const void *)FigDateRangeSpecifierGetScte35in((uint64_t)v439);
                      v458 = PlaylistAddTaggedRangeMetadataDictionaryToArray((__CFArray *)key, CFSTR("SCTE35-IN"), Scte35in, v435, v460);
                      if ((_DWORD)v458)
                        goto LABEL_1259;
                    }
                    if (FigDateRangeSpecifierGetScte35out((uint64_t)v439))
                    {
                      v462 = (const __CFDictionary *)FigDateRangeSpecifierGetTagsFirstFoundDateDict((uint64_t)v439);
                      v463 = CFDictionaryGetValue(v462, CFSTR("SCTE35-OUT"));
                      Scte35out = (const void *)FigDateRangeSpecifierGetScte35out((uint64_t)v439);
                      v458 = PlaylistAddTaggedRangeMetadataDictionaryToArray((__CFArray *)key, CFSTR("SCTE35-OUT"), Scte35out, v435, v463);
                      if ((_DWORD)v458)
                        goto LABEL_1259;
                    }
                    if (CFArrayGetCount((CFArrayRef)key) >= 1)
                      CFDictionaryAddValue(v441, CFSTR("TaggedRangeMetadataKey_MetadataArray"), key);
                    CFRelease(key);
                    CFArrayAppendValue(v543, v441);
                    CFRelease(v441);
                    ++v434;
                    v431 = structureAllocator;
                  }
                  matched = FigSignalErrorAt();
                  v465 = v543;
LABEL_1262:
                  CFRelease(v465);
LABEL_1263:
                  if (!(_DWORD)matched)
                  {
LABEL_1264:
                    FigMediaPlaylistSetDateEntryArray((uint64_t)v585, 0);
LABEL_1265:
                    v430 = v540;
                    *v540 |= 8u;
                    goto LABEL_1266;
                  }
                }
                else
                {
                  matched = FigSignalErrorAt();
                  if (!(_DWORD)matched)
                    goto LABEL_1264;
                }
                v54 = 0;
                v55 = 0;
                v56 = 0;
                v57 = 0;
                goto LABEL_1298;
              }
LABEL_1266:
              if (v518)
                *v430 |= 4u;
              if (v536)
              {
                v466 = (const __CFArray *)FigMultivariantPlaylistGetAlternates((uint64_t)v560);
                if (v466)
                {
                  if (CFArrayGetCount(v466) > 1)
                  {
                    LOBYTE(returnedPointerOut) = 0;
                    LOBYTE(blockBufferOut) = 0;
                    v467 = FigMultivariantPlaylistGetAlternates((uint64_t)v560);
                    PlaylistCheckAllAlternatesCarryScore(v467, (char *)&returnedPointerOut, (BOOL *)&blockBufferOut);
                    if ((_BYTE)returnedPointerOut)
                      _StreamPlaylistLogError(0, 4294949665, (uint64_t)&v572, CFSTR("Not all non-iframe alternates carry SCORE, SCORE disabled for non-iframe alternates"));
                    if ((_BYTE)blockBufferOut)
                      _StreamPlaylistLogError(0, 4294949665, (uint64_t)&v572, CFSTR("Not all iframe alternates carry SCORE, SCORE disabled for iframe alternates"));
                  }
                }
              }
              v468 = (uint64_t)v585;
              if (FigMediaPlaylistGetDateStampCount((uint64_t)v585) < 1)
                goto LABEL_1295;
              v469 = 0;
              do
              {
                MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v468);
                if (MediaSegmentSpecifiers)
                  MediaSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MediaSegmentSpecifiers);
                if (v469 >= (uint64_t)MediaSegmentSpecifiers)
                  goto LABEL_1295;
                v471 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(v468);
                v472 = CFArrayGetValueAtIndex(v471, v469++);
              }
              while (!FigMediaSegmentSpecifierGetDateStamp((uint64_t)v472));
              if (v472)
              {
                ImputedDate = FigMediaSegmentSpecifierGetImputedDate((uint64_t)v472);
                for (k = (uint64_t)v472; ; k = (uint64_t)v57)
                {
                  PreviousSegment = FigMediaSegmentSpecifierGetPreviousSegment(k);
                  v57 = (__CFString *)PreviousSegment;
                  if (!PreviousSegment)
                    break;
                  ImputedDate = ImputedDate - FigMediaSegmentSpecifierGetTimeInSeconds(PreviousSegment);
                  if (FigMediaSegmentSpecifierGetImputedDate((uint64_t)v57) == 0.0)
                    FigMediaSegmentSpecifierSetImputedDate((uint64_t)v57, ImputedDate);
                  v476 = FigMediaSegmentSpecifierGetImputedDate((uint64_t)v57);
                  v477 = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v57);
                  v478 = 0;
                  if (!v477)
                  {
LABEL_1292:
                    v480 = 0;
                    goto LABEL_1293;
                  }
                  while (1)
                  {
                    v480 = CFArrayGetCount(v477);
LABEL_1293:
                    if (v478 >= v480)
                      break;
                    v479 = CFArrayGetValueAtIndex(v477, v478);
                    if (FigMediaSegmentSpecifierGetImputedDate((uint64_t)v479) == 0.0)
                      FigMediaSegmentSpecifierSetImputedDate((uint64_t)v479, v476);
                    v476 = v476 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v479);
                    ++v478;
                    if (!v477)
                      goto LABEL_1292;
                  }
                }
                v54 = 0;
                v55 = 0;
                v56 = 0;
              }
              else
              {
LABEL_1295:
                v54 = 0;
                v55 = 0;
                v56 = 0;
                v57 = 0;
              }
              matched = 0;
              goto LABEL_1298;
            }
LABEL_1377:
            matched = v371;
            goto LABEL_1378;
          }
        }
      }
      v330 = a14;
      goto LABEL_967;
    }
    *(_QWORD *)&v574 = v67;
    if (*(_BYTE *)v67 == 35)
      break;
    temporaryBlock = 0;
    v597 = 0;
    v595 = 0;
    v597 = (CMBlockBufferRef)StreamingPlaylist_SkipSpacesAndTabs((const char *)v67, (uint64_t)&v572);
    StringWithReplacement = sp_GetStringWithReplacement((char *)v597, 0, 1, &v592, (const char **)&v597, (size_t *)&temporaryBlock, &v595, (uint64_t)&v572);
    matched = StringWithReplacement;
    if (!(_DWORD)a5 && (_DWORD)StringWithReplacement)
      goto LABEL_72;
    v74 = (char *)temporaryBlock;
    if (!temporaryBlock)
    {
      v546 = 0;
      goto LABEL_100;
    }
    v75 = (const __CFAllocator *)FigGetAllocatorForMedia();
    v76 = CFStringCreateWithBytes(v75, (const UInt8 *)v597, (CFIndex)v74, 0x8000100u, 0);
    if (!v76)
    {
      matched = FigSignalErrorAt();
      v546 = 0;
      v78 = 196;
      goto LABEL_259;
    }
    v77 = v76;
    FigMediaSegmentSpecifierSetURLString((uint64_t)v583, v76);
    CFRelease(v77);
    if ((_DWORD)key && (_DWORD)v543)
    {
      matched = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294951065, (uint64_t)&v572, CFSTR("Segment found in a multivariant playlist"));
      if ((_DWORD)a5)
      {
LABEL_80:
        *(double *)&returnedPointerOut = 0.0;
        *(_QWORD *)&blockBufferOut = 0;
        URLString = FigMediaSegmentSpecifierGetURLString((uint64_t)v583);
        FigStreamingPlaylistEnsureMediaURL(URLString, anURL, v524, (CFTypeRef *)&returnedPointerOut, (CFURLRef *)&blockBufferOut);
        v82 = (const void *)blockBufferOut;
        if (*(double *)&returnedPointerOut == 0.0 || !(_QWORD)blockBufferOut)
        {
          if (*(double *)&returnedPointerOut != 0.0)
          {
            CFRelease(returnedPointerOut);
            *(double *)&returnedPointerOut = 0.0;
            v82 = (const void *)blockBufferOut;
          }
          if (v82)
          {
            CFRelease(v82);
            *(_QWORD *)&blockBufferOut = 0;
          }
LABEL_93:
          matched = 4294954654;
          _StreamPlaylistLogError(4294954654, 4294955034, (uint64_t)&v572, CFSTR("URL parse failed"), v81, p_blockBufferOut, v491);
          goto LABEL_94;
        }
        if ((_DWORD)matched == -12783)
        {
          matched = 4294954513;
          _StreamPlaylistLogError(4294954513, 4294955033, (uint64_t)&v572, CFSTR("no media URL"), v81, p_blockBufferOut, v491);
          goto LABEL_94;
        }
        if ((_DWORD)matched == -12642)
          goto LABEL_93;
        if ((_DWORD)matched || (_BYTE)v533)
        {
          if ((_DWORD)matched)
            goto LABEL_94;
        }
        else if (((_DWORD)v532 - 1) <= 1 && v568 == 0.0)
        {
          matched = 4294954654;
          _StreamPlaylistLogError(4294954654, 4294951059, (uint64_t)&v572, CFSTR("HDR alternate is missing FRAME-RATE"), v568, p_blockBufferOut, v491);
LABEL_94:
          if (*(double *)&returnedPointerOut != 0.0)
          {
            CFRelease(returnedPointerOut);
            *(double *)&returnedPointerOut = 0.0;
          }
          if ((_QWORD)blockBufferOut)
            CFRelease((CFTypeRef)blockBufferOut);
          v546 = 0;
          goto LABEL_99;
        }
        if ((_DWORD)v531)
          goto LABEL_160;
        matched = PlaylistProcessAlternate((uint64_t)v560, returnedPointerOut, (void *)blockBufferOut, (uint64_t)v528, v529, (const __CFString *)cf, (const __CFString *)v551, (uint64_t)v552, v568, v68, (void *)v549, (uint64_t)v548, (uint64_t)v21, v533, v587, v586, (uint64_t)v539, (int)v527, (int)v532,
                    v567,
                    (uint64_t)v566,
                    (uint64_t)v538,
                    (_BYTE *)&v570 + 1,
                    (uint64_t)&v572);
        if (*(double *)&returnedPointerOut != 0.0)
        {
          CFRelease(returnedPointerOut);
          *(double *)&returnedPointerOut = 0.0;
        }
        if ((_QWORD)blockBufferOut)
        {
          CFRelease((CFTypeRef)blockBufferOut);
          *(_QWORD *)&blockBufferOut = 0;
        }
        if ((_DWORD)a5 || !(_DWORD)matched)
        {
          if (!(_DWORD)matched)
          {
LABEL_160:
            matched = 0;
            v536 = 1;
          }
          goto LABEL_94;
        }
      }
LABEL_72:
      v546 = 0;
      goto LABEL_73;
    }
    if ((_DWORD)v543)
      goto LABEL_80;
    if (!(_DWORD)key)
    {
      matched = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294951059, (uint64_t)&v572, CFSTR("a URI found without leading a EXTINF / EXT-X-STREAM-INF."));
      v546 = 0;
      if ((_DWORD)a5)
        goto LABEL_99;
      goto LABEL_73;
    }
    if (FigMediaSegmentSpecifierGetBytesToRead((uint64_t)v583))
    {
      if (!v509)
      {
        matched = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955019, (uint64_t)&v572, CFSTR("Reading URL, and have byte range but no offset"));
        if (!(_DWORD)a5)
        {
          v509 = 0;
          goto LABEL_72;
        }
      }
    }
    v521 = v21;
    if (FigMediaSegmentSpecifierGetBytesToRead((uint64_t)v583))
    {
      v84 = FigMediaSegmentSpecifierGetStartOffset((uint64_t)v583);
      v546 = FigMediaSegmentSpecifierGetBytesToRead((uint64_t)v583) + v84;
    }
    else
    {
      FigMediaSegmentSpecifierSetStartOffset((uint64_t)v583, 0);
      v509 = 0;
      v546 = 0;
    }
    v117 = v590;
    FigMediaSegmentSpecifierSetContentKeySpecifier((uint64_t)v583, v590);
    if (v517
      && (!v589 && FigMediaSegmentSpecifierGetStartOffset((uint64_t)v583)
       || FigMediaSegmentSpecifierIsDiscontinuity((uint64_t)v583) && !(_DWORD)v530))
    {
      v119 = FigMediaSegmentSpecifierGetStartOffset((uint64_t)v583);
      if (v589)
      {
        CFRelease(v589);
        v589 = 0;
      }
      v120 = 0;
      while (1)
      {
        v121 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers((uint64_t)v585);
        if (v121)
          v121 = (const __CFArray *)CFArrayGetCount(v121);
        if (v120 >= (uint64_t)v121)
          break;
        v122 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers((uint64_t)v585);
        v123 = CFArrayGetValueAtIndex(v122, v120);
        FigMediaSegmentSpecifierGetURLString((uint64_t)v123);
        FigMediaSegmentSpecifierGetURLString((uint64_t)v583);
        ++v120;
        if (FigCFEqual())
        {
          if (FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v123))
          {
            v124 = v589;
            MapSegmentSpecifier = (const void *)FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v123);
            v589 = MapSegmentSpecifier;
            if (MapSegmentSpecifier)
              CFRetain(MapSegmentSpecifier);
            if (v124)
              CFRelease(v124);
          }
          else
          {
            v119 = FigMediaSegmentSpecifierGetStartOffset((uint64_t)v123);
          }
          break;
        }
      }
      if (!v589)
      {
        if (v119 > 0x100000)
        {
          _StreamPlaylistLogError(0, 4294951060, (uint64_t)&v572, CFSTR("implicit map of size %lld too large"), v119);
          v119 = 0x100000;
        }
        v134 = (uint64_t)v585;
        v135 = (const void *)FigMediaSegmentSpecifierGetURLString((uint64_t)v583);
        v136 = PlaylistCreateMapEntry(v134, v135, 0, v119, v591, &v589);
        matched = v136;
        if (!(_DWORD)a5 && (_DWORD)v136)
        {
          v78 = 4;
          v21 = v521;
          goto LABEL_259;
        }
        FigMediaSegmentSpecifierSetContentKeySpecifier((uint64_t)v589, v117);
        v137 = v582;
        FigMediaSegmentSpecifierSetIV((uint64_t)v589, v582);
        if (v117)
        {
          if (FigContentKeySpecifierGetEncryptionMethod((uint64_t)v117) == 3 && !v137)
          {
            _StreamPlaylistLogError(0, 4294949666, (uint64_t)&v572, CFSTR("Explicit IV is required for implicit map entry for full segment encryption"));
            matched = 0;
            if (!(_DWORD)a5)
            {
              if (dword_1EE2A3208)
              {
                LODWORD(v594) = 0;
                type[0] = OS_LOG_TYPE_DEFAULT;
                os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                v139 = LODWORD(v594);
                if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0]))
                  v140 = v139;
                else
                  v140 = v139 & 0xFFFFFFFE;
                if (v140)
                {
                  LODWORD(blockBufferOut) = 136315138;
                  *(_QWORD *)((char *)&blockBufferOut + 4) = "FigStreamPlaylistParseInProcess";
                  LODWORD(v491) = 12;
                  p_blockBufferOut = (const char *)&blockBufferOut;
                  _os_log_send_and_compose_impl();
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose();
                matched = 0;
              }
            }
          }
        }
      }
    }
    FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v583);
    v132 = FigCFArrayGetLastValue();
    if (!v132)
    {
      v21 = v521;
LABEL_275:
      FigMediaSegmentSpecifierSetType((uint64_t)v583, 0);
      FigMediaSegmentSpecifierSetMapSegmentSpecifier((uint64_t)v583, v589);
      FigMediaSegmentSpecifierSetIsDiscontinuityDomain((uint64_t)v583, (uint64_t)DiscontinuityDomain);
      FigMediaSegmentSpecifierSetIsMarkedAsGap((uint64_t)v583, (char)v534);
      if (!a14 || !*a14 || (_BYTE)v525)
        goto LABEL_307;
      LOBYTE(returnedPointerOut) = 0;
      LOBYTE(blockBufferOut) = 0;
      v133 = MergeLeadingPartialMediaEntries((uint64_t)v585, (uint64_t)v583, (uint64_t)&v572, (char *)&returnedPointerOut, (char *)&blockBufferOut, v526);
      matched = v133;
      if ((_DWORD)a5 || !(_DWORD)v133)
      {
        if ((_BYTE)returnedPointerOut)
        {
          FigMediaPlaylistGetMediaSegmentSpecifiers((uint64_t)v585);
          v584 = FigCFArrayGetLastValue();
          FigMediaSegmentSpecifierSetIsFragment(v584, 0);
          LOBYTE(v525) = (_BYTE)blockBufferOut != 0;
          goto LABEL_305;
        }
        if (v584)
        {
          LOBYTE(v594) = 0;
          matched = DoesMediaFileMatchEntry(v584, (uint64_t)v583, &v594, (uint64_t)&v572, 0, v526);
          if (!(_DWORD)matched && !LOBYTE(v594))
          {
            matched = 4294954984;
            _StreamPlaylistLogError(4294954984, 4294954984, (uint64_t)&v572, CFSTR("Media segment doesn't match - sequence %llu"), v591);
          }
          goto LABEL_304;
        }
        matched = FindMatchingMediaEntry((uint64_t)v585, (uint64_t)v583, &v584, (uint64_t)&v572, v526);
        LOBYTE(v525) = 0;
        if (!(_DWORD)matched && v503 && v584)
        {
          matched = 4294954984;
          _StreamPlaylistLogError(4294954984, 4294954984, (uint64_t)&v572, CFSTR("Mismatched media segment.  Found old media segment after added new one."), p_blockBufferOut);
LABEL_304:
          LOBYTE(v525) = 0;
        }
LABEL_305:
        if (!(_DWORD)a5 && (_DWORD)matched)
          goto LABEL_965;
LABEL_307:
        v141 = v584;
        if (v584)
        {
          DiscontinuityDomain = (void *)FigMediaSegmentSpecifierGetDiscontinuityDomain(v584);
          FigStreamPlaylistValidateMediaEntry((uint64_t)v585, v141, v544);
          if (v544)
            CFRelease(v544);
          v142 = v584;
          if (FigMediaSegmentSpecifierGetBytesToRead(v584))
          {
            v143 = v21;
            v144 = FigMediaSegmentSpecifierGetStartOffset(v142);
            v546 = FigMediaSegmentSpecifierGetBytesToRead(v142) + v144;
            v21 = v143;
          }
          v584 = FigMediaSegmentSpecifierGetNextSegment(v142);
        }
        else
        {
          v497 = a5;
          v145 = (uint64_t)v585;
          v146 = FigMediaPlaylistGetPlaylistActiveDurationSecs((uint64_t)v585);
          v147 = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v583);
          FigMediaPlaylistSetPlaylistActiveDurationSecs(v145, v146 + v147);
          if (FigMediaSegmentSpecifierGetImputedDate((uint64_t)v583) == 0.0)
            FigMediaSegmentSpecifierSetImputedDate((uint64_t)v583, v71);
          v525 = (uint64_t)v585;
          v504 = (const void *)FigMediaSegmentSpecifierGetURLString((uint64_t)v583);
          ContentKeySpecifier = (CFTypeRef)FigMediaSegmentSpecifierGetContentKeySpecifier((uint64_t)v583);
          v148 = (const void *)FigMediaSegmentSpecifierGetMapSegmentSpecifier((uint64_t)v583);
          MediaSequence = FigMediaSegmentSpecifierGetMediaSequence((uint64_t)v583);
          v150 = FigMediaSegmentSpecifierGetStartOffset((uint64_t)v583);
          v151 = FigMediaSegmentSpecifierGetBytesToRead((uint64_t)v583);
          v152 = FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v583);
          v153 = v582;
          v154 = FigMediaSegmentSpecifierIsDiscontinuity((uint64_t)v583);
          IsMarkedAsGap = FigMediaSegmentSpecifierIsMarkedAsGap((uint64_t)v583);
          v156 = FigMediaSegmentSpecifierGetImputedDate((uint64_t)v583);
          v157 = (const void *)CreateMediaFileEntry(v525, v504, 0, ContentKeySpecifier, v148, MediaSequence, (uint64_t)DiscontinuityDomain, v150, v152, v156, v151, v153, v544, v154, IsMarkedAsGap);
          FigStreamPlaylistTransferPartialEntryQueue((uint64_t)v583, (uint64_t)v157);
          if (!FigMediaSegmentSpecifierGetBytesToRead((uint64_t)v157))
            FigMediaSegmentSpecifierSetBitRate((uint64_t)v157, BitRate);
          FigMediaPlaylistAddMediaSegmentSpecifier((uint64_t)v585, v157);
          if (v157)
            CFRelease(v157);
          v21 = v521;
          a5 = v497;
          if (v544)
            CFRelease(v544);
          LOBYTE(v525) = 1;
          v503 = 1;
        }
        ++v591;
        v72 = 0.0;
        v544 = 0;
        if (v71 != 0.0)
          v71 = v71 + FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)v583);
LABEL_99:
        LODWORD(v74) = 1;
LABEL_100:
        free(v595);
        if ((_DWORD)v74)
        {
LABEL_101:
          if (cf)
            CFRelease(cf);
          if (v551)
            CFRelease(v551);
          if (v552)
            CFRelease(v552);
          if (v549)
            CFRelease(v549);
          if (v548)
            CFRelease(v548);
          if (v21)
            CFRelease(v21);
          if (v539)
            CFRelease(v539);
          if (v566)
          {
            CFRelease(v566);
            v566 = 0;
          }
          if (v538)
            CFRelease(v538);
          v586 = -1;
          v587 = -1;
          v568 = 0.0;
          v567 = -1;
          if (v583)
          {
            CFRelease(v583);
            v583 = 0;
          }
          v83 = FigGetAllocatorForMedia();
          matched = FigMediaSegmentSpecifierCreateEmpty(v83, (uint64_t *)&v583);
          if ((_DWORD)matched)
          {
            cf = 0;
            v551 = 0;
            v552 = 0;
            v549 = 0;
            v53 = 0;
            v21 = 0;
            v54 = 0;
            v55 = 0;
            v56 = 0;
            v57 = 0;
            goto LABEL_51;
          }
          FigMediaSegmentSpecifierSetStartOffset((uint64_t)v583, v546);
          FigMediaSegmentSpecifierSetContentKeySpecifier((uint64_t)v583, v590);
          FigMediaSegmentSpecifierSetMapSegmentSpecifier((uint64_t)v583, v589);
          FigMediaSegmentSpecifierSetMediaSequence((uint64_t)v583, v591);
          LODWORD(v543) = 0;
          LODWORD(key) = 0;
          LOBYTE(v534) = 0;
          v538 = 0;
          v539 = 0;
          LODWORD(v531) = 0;
          LODWORD(v530) = 0;
          LODWORD(v533) = 0;
          v21 = 0;
          v548 = 0;
          v549 = 0;
          v552 = 0;
          v551 = 0;
          cf = 0;
          v528 = 0;
          v529 = 0;
          v68 = -1.0;
          LODWORD(v527) = -2;
          LODWORD(v532) = -1;
          goto LABEL_252;
        }
LABEL_250:
        if (!(_DWORD)a5 && (_DWORD)matched)
          goto LABEL_965;
LABEL_252:
        v126 = v592;
        v127 = *v592;
        v98 = v127 > 0xD;
        v128 = (1 << v127) & 0x2401;
        if (v98 || v128 == 0)
          _StreamPlaylistLogError(0, 4294955032, (uint64_t)&v572, CFSTR("extra characters at end of line"));
        v130 = &v126[strcspn(v126, "\r\n")];
        v131 = strspn(v130, "\r\n");
        v78 = 0;
        v67 = (unint64_t)&v130[v131];
        goto LABEL_259;
      }
      LOBYTE(v525) = 0;
      goto LABEL_73;
    }
    v21 = v521;
    if (DiscontinuityDomain == (void *)FigMediaSegmentSpecifierGetDiscontinuityDomain(v132))
      goto LABEL_275;
    matched = 4294954654;
    _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s not allowed on partial segment boundaries"), "#EXT-X-DISCONTINUITY");
    if ((_DWORD)a5)
      goto LABEL_275;
LABEL_73:
    v78 = 4;
LABEL_259:
    if (v78)
    {
      if (v78 == 4)
        goto LABEL_965;
      v53 = v548;
      v54 = 0;
      v55 = 0;
      v56 = 0;
      v57 = 0;
      v555 = 0;
      LODWORD(v546) = 0;
      v547 = 0;
      goto LABEL_1302;
    }
  }
  if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-MEDIA-SEQUENCE", 0x15uLL, (const char **)&v592, (uint64_t)&v572))
  {
    if (v547)
    {
      matched = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294949660, (uint64_t)&v572, CFSTR("Can only have one of each Media Playlist Tag"));
      if (!(_DWORD)a5)
        goto LABEL_965;
    }
    LOBYTE(v547) = 1;
    matched = sp_strtoull(v592, &v592, &v591, 10, 0, 1, (uint64_t)"Media Sequence", (uint64_t)&v572);
    if ((_DWORD)matched)
      goto LABEL_250;
    FigMediaSegmentSpecifierSetMediaSequence((uint64_t)v583, v591);
    LOBYTE(v547) = 1;
    goto LABEL_252;
  }
  if (sp_MatchTagAndColon((const char *)v67, "#EXTINF", 7uLL, (const char **)&v592, (uint64_t)&v572))
  {
    *(double *)&returnedPointerOut = 0.0;
    LOBYTE(v597) = 0;
    *(_QWORD *)&blockBufferOut = 0;
    v79 = sp_strtod(v592, (char **)&blockBufferOut, (double *)&returnedPointerOut, &v597, (uint64_t)"Segment Duration", (uint64_t)&v572);
    if (v79 || *(double *)&returnedPointerOut >= 0.0)
    {
      if (v79)
      {
        if (v79 == -12642)
          matched = 4294954650;
        else
          matched = v79;
      }
      else
      {
        if (*(double *)&returnedPointerOut > v69)
          v69 = *(double *)&returnedPointerOut;
        v89 = *(double *)&returnedPointerOut != floor(*(double *)&returnedPointerOut);
        FigMediaSegmentSpecifierSetTimeInSeconds((uint64_t)v583, *(double *)&returnedPointerOut);
        v90 = returnedPointerOut;
        MaxSegmentDuration = FigMediaPlaylistGetMaxSegmentDuration((uint64_t)v585);
        if (MaxSegmentDuration < *(double *)&returnedPointerOut)
          FigMediaPlaylistSetMaxSegmentDuration((uint64_t)v585, *(double *)&returnedPointerOut);
        BYTE4(v508) |= v89;
        ++v522;
        v70 = v70 + *(double *)&v90;
        v518 = (v597 & v518);
        v92 = blockBufferOut;
        v592 = *(char **)&blockBufferOut;
        if ((_QWORD)blockBufferOut && *(_BYTE *)blockBufferOut == 44)
        {
          matched = 0;
          v592 = (char *)(v92 + strcspn((const char *)blockBufferOut, "\r\n"));
        }
        else
        {
          matched = 0;
        }
      }
    }
    else
    {
      matched = 4294954650;
      _StreamPlaylistLogError(4294954650, 4294955032, (uint64_t)&v572, CFSTR("Negative number in EXTINF"), *(double *)&returnedPointerOut);
    }
    LODWORD(key) = 1;
    goto LABEL_250;
  }
  if (!strncmp((const char *)v67, "#EXT-X-I-FRAMES-ONLY", 0x14uLL))
  {
    v85 = *(char *)(v67 + 20);
    if ((v85 & 0x80000000) != 0)
    {
      if (!__maskrune(v85, 0x500uLL))
      {
LABEL_221:
        v592 = (char *)(v67 + 20);
        if (v517)
        {
          matched = 4294954654;
          _StreamPlaylistLogError(4294954654, 4294949660, (uint64_t)&v572, CFSTR("Can only have one of each Media Playlist Tag"));
          if (!(_DWORD)a5)
            goto LABEL_965;
        }
        else
        {
          matched = 0;
        }
        v517 = 1;
        FigMediaPlaylistSetHasOnlyIFrames((uint64_t)v585, 1);
        goto LABEL_250;
      }
    }
    else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v85 + 60) & 0x500) == 0)
    {
      goto LABEL_221;
    }
  }
  if (!sp_MatchTagAndColon((const char *)v67, "#EXT-X-CONTENT-STEERING", 0x17uLL, (const char **)&v592, (uint64_t)&v572))
  {
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-DISCONTINUITY-SEQUENCE", 0x1DuLL, (const char **)&v592, (uint64_t)&v572))
    {
      *(double *)&returnedPointerOut = 0.0;
      if (BYTE4(v520))
      {
        _StreamPlaylistLogError(4294954654, 4294949660, (uint64_t)&v572, CFSTR("Can only have one of each Media Playlist Tag"));
        if (!(_DWORD)a5)
          goto LABEL_1382;
      }
      v86 = sp_strtoull(v592, &v592, (unint64_t *)&returnedPointerOut, 10, 0, 0, (uint64_t)"Discontinuity Sequence", (uint64_t)&v572);
      matched = v86;
      v87 = HIDWORD(v520);
      if (!(_DWORD)v86)
        v87 = 1;
      HIDWORD(v520) = v87;
      v88 = DiscontinuityDomain;
      if (!(_DWORD)v86)
        v88 = returnedPointerOut;
      DiscontinuityDomain = v88;
      goto LABEL_250;
    }
    if (StreamingPlaylist_MatchAlphanumericStringExactly((const char *)v67, "#EXT-X-DISCONTINUITY", 0x14uLL, (const char **)&v592))
    {
      DiscontinuityDomain = (char *)DiscontinuityDomain + 1;
      LODWORD(v520) = 1;
      FigMediaSegmentSpecifierSetIsDiscontinuity((uint64_t)v583, 1);
      matched = 0;
      v509 = 0;
      goto LABEL_252;
    }
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-TARGETDURATION", 0x15uLL, (const char **)&v592, (uint64_t)&v572))
    {
      LODWORD(returnedPointerOut) = 0;
      if ((_DWORD)v511)
      {
        _StreamPlaylistLogError(4294954654, 4294949660, (uint64_t)&v572, CFSTR("Can only have one of each Media Playlist Tag"));
        if (!(_DWORD)a5)
        {
LABEL_1382:
          v54 = 0;
          v55 = 0;
          v56 = 0;
          v57 = 0;
          v555 = 0;
          LODWORD(v546) = 0;
          v547 = 0;
          matched = 4294954654;
          goto LABEL_1299;
        }
      }
      if (sp_strtol(v592, &v592, &returnedPointerOut, 1, (uint64_t)"target duration", (uint64_t)&v572)
        || (returnedPointerOut & 0x80000000) != 0)
      {
        matched = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955025, (uint64_t)&v572, CFSTR("Illegal target duration (negative)"), p_blockBufferOut);
      }
      else if ((_DWORD)returnedPointerOut)
      {
        FigMediaPlaylistSetTargetDuration((uint64_t)v585, (int)returnedPointerOut);
        matched = 0;
        LODWORD(v511) = 1;
      }
      else
      {
        matched = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955025, (uint64_t)&v572, CFSTR("Illegal target duration (out of range)"), p_blockBufferOut);
      }
      goto LABEL_250;
    }
    if (StreamingPlaylist_MatchAlphanumericStringExactly((const char *)v67, "#EXT-X-ENDLIST", 0xEuLL, (const char **)&v592))
    {
      if (FigMediaPlaylistHasEndTag((uint64_t)v585))
      {
        matched = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294949660, (uint64_t)&v572, CFSTR("Can only have one of each Media Playlist Tag"));
        if (!(_DWORD)a5)
          goto LABEL_965;
      }
      else
      {
        matched = 0;
      }
      FigMediaPlaylistSetHasEndTag((uint64_t)v585, 1);
      goto LABEL_250;
    }
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-ALLOW-CACHE", 0x12uLL, (const char **)&v592, (uint64_t)&v572))
    {
      _StreamPlaylistLogError(0, 4294955028, (uint64_t)&v572, CFSTR("%s has been deprecated"), "#EXT-X-ALLOW-CACHE");
      matched = 0;
      goto LABEL_252;
    }
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-KEY", 0xAuLL, (const char **)&v592, (uint64_t)&v572))
    {
      matched = PlaylistProcessKey(0, (uint64_t)v585, "#EXT-X-KEY", v592, &v582, &v590, &v592, (uint64_t)&v572);
      if (!(_DWORD)matched)
      {
        v500 |= v582 != 0;
        v158 = (uint64_t)v590;
        if (v590)
        {
          BYTE4(v513) |= FigContentKeySpecifierGetEncryptionMethod((uint64_t)v590) == 1;
          BYTE4(v502) |= FigContentKeySpecifierGetEncryptionMethod(v158) == 2;
        }
        v516[4] = 1;
      }
      v159 = v592;
      v592 = &v159[strcspn(v592, "\r\n")];
      goto LABEL_250;
    }
    v498 = a5;
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-SESSION-KEY", 0x12uLL, (const char **)&v592, (uint64_t)&v572))
    {
      matched = PlaylistProcessKey((uint64_t)v560, 0, "#EXT-X-SESSION-KEY", v592, &v582, &v590, &v592, (uint64_t)&v572);
      if (!(_DWORD)matched)
      {
        v160 = (uint64_t)v590;
        if (v590)
        {
          LODWORD(v513) = 1;
          FigContentKeySpecifierSetIsReadInCurrent((uint64_t)v590, 1);
          FigContentKeySpecifierSetIsPrefetchKey(v160, 1);
        }
      }
      v161 = v592;
      v592 = &v161[strcspn(v592, "\r\n")];
      goto LABEL_351;
    }
    v162 = 0.0;
    v163 = theArray;
    v521 = v21;
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-STREAM-INF", 0x11uLL, (const char **)&v592, (uint64_t)&v572)|| sp_MatchTagAndColon((const char *)v67, "#EXT-X-I-FRAME-STREAM-INF", 0x19uLL, (const char **)&v592, (uint64_t)&v572))
    {
      *(double *)&returnedPointerOut = 0.0;
      *(_QWORD *)&blockBufferOut = 0;
      v164 = sp_MatchTagAndColon((const char *)v67, "#EXT-X-I-FRAME-STREAM-INF", 0x19uLL, (const char **)&returnedPointerOut, (uint64_t)&v572);
      v165 = v164;
      v166 = (int)v533;
      if (v164)
        v166 = 1;
      LODWORD(v533) = v166;
      if (v164)
        v167 = "#EXT-X-I-FRAME-STREAM-INF";
      else
        v167 = "#EXT-X-STREAM-INF";
      v168 = (char *)StreamingPlaylist_SkipSpacesAndTabs(v592, (uint64_t)&v572);
      v169 = 0;
      LODWORD(v543) = 0;
      matched = 0;
      v592 = v168;
      v170 = a5;
      while (1)
      {
        v171 = *v168;
        v98 = v171 > 0xD;
        v172 = (1 << v171) & 0x2401;
        if (!v98 && v172 != 0)
          break;
        temporaryBlock = 0;
        v597 = 0;
        v594 = 0.0;
        v595 = 0;
        *(_DWORD *)v559 = 0;
        free((void *)blockBufferOut);
        *(_QWORD *)&blockBufferOut = 0;
        v174 = sp_ParseAttribute(v167, v592, 1, 0, (char **)&v597, &v595, (const char **)&temporaryBlock, (size_t *)&v594, (const char **)&v592, (int *)v559, (UInt8 **)&blockBufferOut, (uint64_t)&v572);
        matched = v174;
        if (!v170 && (_DWORD)v174)
          goto LABEL_1387;
        v175 = v559[0];
        if ((v559[0] & 2) != 0)
        {
          LODWORD(v531) = 1;
        }
        else
        {
          v176 = (const char *)v597;
          if (v597)
          {
            v177 = temporaryBlock;
            if (temporaryBlock)
            {
              switch((unint64_t)v595)
              {
                case 3uLL:
                  if (strncmp((const char *)v597, "URI", 3uLL))
                    goto LABEL_422;
                  if (!(_BYTE)v533)
                  {
                    matched = 4294954654;
                    _StreamPlaylistLogError(4294954654, 4294955018, (uint64_t)&v572, CFSTR("Use of URI in %s"), v167);
                    if (!(_DWORD)a5)
                      goto LABEL_1387;
                  }
                  v178 = v580;
                  if (v580)
                  {
                    _StreamPlaylistLogError(0, 4294955018, (uint64_t)&v572, CFSTR("Multiple URL in %s - ignoring old one"), v167);
                    CFRelease(v178);
                    v580 = 0;
                    if (v579)
                    {
                      CFRelease(v579);
                      v579 = 0;
                    }
                  }
                  if ((v175 & 1) != 0)
                  {
                    StreamingPlaylistCreateMediaURLWithBytes(temporaryBlock, *(CFIndex *)&v594, anURL, v524, &v580, &v579);
                    if (v580)
                      break;
                  }
                  else
                  {
                    _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s: missing quotes"), "URI");
                  }
                  matched = 4294954654;
                  _StreamPlaylistLogError(4294954654, 4294955034, (uint64_t)&v572, CFSTR("Invalid URI"), p_blockBufferOut, v491);
                  break;
                case 5uLL:
                  if (!strncmp((const char *)v597, "AUDIO", 5uLL))
                  {
                    if ((v175 & 1) == 0)
                    {
                      v179 = "AUDIO";
                      goto LABEL_451;
                    }
                    v552 = CFStringCreateWithBytes(structureAllocator, v177, *(CFIndex *)&v594, 0x600u, 1u);
                  }
                  else if (!strncmp(v176, "VIDEO", 5uLL))
                  {
                    if ((v175 & 1) == 0)
                    {
                      v179 = "VIDEO";
                      goto LABEL_451;
                    }
                    v549 = CFStringCreateWithBytes(structureAllocator, v177, *(CFIndex *)&v594, 0x600u, 1u);
                  }
                  else
                  {
                    if (strncmp(v176, "SCORE", 5uLL))
                      goto LABEL_422;
                    *(double *)type = -1.0;
                    matched = sp_strtod((const char *)v177, (char **)&temporaryBlock, (double *)type, 0, (uint64_t)"Alternate score", (uint64_t)&v572);
                    if ((_DWORD)matched || (v182 = *(_QWORD *)type, *(double *)type < 0.0))
                    {
                      _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s: Invalid ranking score"), "#EXT-X-STREAM-INF");
                      v182 = *(_QWORD *)&v68;
                      if ((_DWORD)matched)
                        goto LABEL_1387;
                    }
                    matched = 0;
                    v68 = *(double *)&v182;
                  }
                  break;
                case 6uLL:
                  if (strncmp((const char *)v597, "CODECS", 6uLL))
                    goto LABEL_422;
                  if ((v175 & 1) == 0)
                  {
                    v179 = "CODECS";
                    goto LABEL_451;
                  }
                  cf = CFStringCreateWithBytes(structureAllocator, v177, *(CFIndex *)&v594, 0x600u, 1u);
                  break;
                case 9uLL:
                  if (!strncmp((const char *)v597, "BANDWIDTH", 9uLL))
                  {
                    *(double *)type = 0.0;
                    v185 = sp_strtoll((const char *)v177, (char **)&temporaryBlock, (uint64_t *)type, 1, (uint64_t)"bandwidth", (uint64_t)&v572);
                    if (*(uint64_t *)type <= 0)
                    {
                      matched = 4294954654;
                      _StreamPlaylistLogError(4294954654, 4294955021, (uint64_t)&v572, CFSTR("Zero bandwidth"), p_blockBufferOut, v491);
                    }
                    else
                    {
                      matched = v185;
                      v186 = v528;
                      if (!(_DWORD)v185)
                        v186 = *(void **)type;
                      v528 = v186;
                    }
                  }
                  else
                  {
                    if (strncmp(v176, "SUBTITLES", 9uLL))
                      goto LABEL_422;
                    if ((v175 & 1) == 0)
                    {
                      v179 = "SUBTITLES";
                      goto LABEL_451;
                    }
                    v548 = CFStringCreateWithBytes(structureAllocator, v177, *(CFIndex *)&v594, 0x600u, 1u);
                  }
                  break;
                case 0xAuLL:
                  v180 = strncmp((const char *)v597, "PROGRAM-ID", 0xAuLL);
                  if (!(_DWORD)v180)
                  {
                    _StreamPlaylistLogError(v180, 4294955022, (uint64_t)&v572, CFSTR("%s has been deprecated and is no longer a valid attribute for %s"), "PROGRAM-ID", v167);
                    break;
                  }
                  if (!strncmp(v176, "RESOLUTION", 0xAuLL))
                  {
                    if (!StreamingPlaylist_FindResolution((const char *)v177, &v587, &v586, &temporaryBlock, (uint64_t)&v572))
                    {
                      matched = 4294954654;
                      _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("Could not parse resolution"), p_blockBufferOut, v491);
                    }
                  }
                  else if (!strncmp(v176, "FRAME-RATE", 0xAuLL))
                  {
                    if ((_BYTE)v533)
                    {
                      matched = 4294954654;
                      _StreamPlaylistLogError(4294954654, 4294951063, (uint64_t)&v572, CFSTR("%s: illegal attribute in %s"), "FRAME-RATE", v167);
                    }
                    else
                    {
                      matched = sp_strtod((const char *)v177, 0, &v568, 0, (uint64_t)"frame rate", (uint64_t)&v572);
                    }
                  }
                  else if (!strncmp(v176, "HDCP-LEVEL", 0xAuLL))
                  {
                    if (!strncasecmp((const char *)v177, "TYPE-0", 6uLL))
                    {
                      LODWORD(v527) = 0;
                      break;
                    }
                    if (!strncasecmp((const char *)v177, "NONE", 4uLL))
                    {
                      v200 = -1;
LABEL_501:
                      LODWORD(v527) = v200;
                      break;
                    }
                    if (!strncasecmp((const char *)v177, "TYPE-1", 6uLL))
                    {
                      v200 = 1;
                      goto LABEL_501;
                    }
                    v181 = "HDCP-LEVEL";
LABEL_467:
                    matched = 4294954654;
                    _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s: illegal value"), v181, v491);
                  }
                  else
                  {
                    if (strncmp(v176, "PATHWAY-ID", 0xAuLL))
                      goto LABEL_422;
                    if ((v175 & 1) != 0)
                    {
                      v188 = *(_QWORD *)&v594;
                      if (v594 != 0.0)
                      {
                        v189 = *(_QWORD *)&v594;
                        while (1)
                        {
                          v191 = *v177++;
                          v190 = v191;
                          v192 = (v191 & 0xFFFFFFDF) - 65;
                          if ((v191 - 48) >= 0xA && v192 >= 0x1A)
                          {
                            v194 = v190 - 45;
                            v98 = v194 > 0x32;
                            v195 = (1 << v194) & 0x4000000000003;
                            if (v98 || v195 == 0)
                              break;
                          }
                          if (!--v189)
                            goto LABEL_487;
                        }
                        matched = 4294954654;
                        _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s: attribute %s contains illegal characters"), v167, "PATHWAY-ID");
                      }
LABEL_487:
                      if (!(_DWORD)a5 && (_DWORD)matched)
                        goto LABEL_1387;
                      if (v165)
                        v197 = v169;
                      else
                        v197 = v538;
                      if (v197)
                      {
                        CFRelease(v197);
                        v188 = *(_QWORD *)&v594;
                      }
                      v198 = CFStringCreateWithBytes(structureAllocator, temporaryBlock, v188, 0x8000100u, 1u);
                      v199 = v538;
                      if (!v165)
                        v199 = v198;
                      v538 = v199;
                      if (v165)
                        v169 = v198;
                    }
                    else
                    {
                      v179 = "PATHWAY-ID";
LABEL_451:
                      matched = 4294954654;
                      _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s: missing quotes"), v179, v491);
                    }
                  }
                  break;
                case 0xBuLL:
                  if (!strncmp((const char *)v597, "ALLOWED-CPC", 0xBuLL))
                  {
                    matched = PlaylistExtractallowedCPCForFairPlayStreaming((char *)v177, *(size_t *)&v594, (uint64_t)&v572, &v567);
                    if ((_DWORD)matched)
                    {
                      v567 = 0;
                      if (!(_DWORD)a5)
                        goto LABEL_1387;
                    }
                  }
                  else
                  {
                    if (strncmp(v176, "VIDEO-RANGE", 0xBuLL))
                      goto LABEL_422;
                    if (!strncasecmp((const char *)v177, "SDR", 3uLL))
                    {
                      LODWORD(v532) = 0;
                    }
                    else
                    {
                      if (!strncasecmp((const char *)v177, "PQ", 2uLL))
                      {
                        v187 = 2;
                      }
                      else
                      {
                        if (strncasecmp((const char *)v177, "HLG", 3uLL))
                        {
                          v181 = "VIDEO-RANGE";
                          goto LABEL_467;
                        }
                        v187 = 1;
                      }
                      LODWORD(v532) = v187;
                    }
                  }
                  break;
                case 0xEuLL:
                  if (!strncmp((const char *)v597, "_AVG-BANDWIDTH", 0xEuLL))
                    goto LABEL_425;
                  goto LABEL_422;
                case 0xFuLL:
                  if (!strncmp((const char *)v597, "CLOSED-CAPTIONS", 0xFuLL))
                  {
                    if ((v175 & 1) != 0)
                    {
                      HIDWORD(v511) = 1;
                      v521 = CFStringCreateWithBytes(structureAllocator, v177, *(CFIndex *)&v594, 0x600u, 1u);
                    }
                    else if (!strncasecmp((const char *)v177, "NONE", 4uLL))
                    {
                      v510 = 1;
                    }
                    else
                    {
                      matched = 4294954654;
                      _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s: missing quotes or illegal value"), "CLOSED-CAPTIONS", v491);
                    }
                  }
                  else if (!strncmp(v176, "VIDEO-IMMERSIVE", 0xFuLL))
                  {
                    if (!(_DWORD)v543)
                    {
                      if (PlaylistExtractVideoImmersiveAttribute((char *)v177, *(size_t *)&v594, (uint64_t)&v572, (__CFArray **)&v566))
                      {
                        v485 = CFSTR("%s: Invalid video immersive tag");
LABEL_1385:
                        v486 = "#EXT-X-STREAM-INF";
LABEL_1386:
                        matched = 4294954654;
                        _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, v485, v486);
LABEL_1387:
                        v54 = 0;
                        v55 = 0;
                        v56 = 0;
                        v57 = 0;
                        v555 = 0;
                        LODWORD(v546) = 0;
                        v547 = 0;
LABEL_1298:
                        v21 = v521;
                        goto LABEL_1299;
                      }
                      LODWORD(v543) = 0;
                      matched = 0;
                    }
                  }
                  else
                  {
LABEL_422:
                    _StreamPlaylistLogError(0, 4294955022, (uint64_t)&v572, CFSTR("Invalid attribute for %s"), v167, v491);
                  }
                  break;
                case 0x10uLL:
                  if (strncmp((const char *)v597, "REQ-VIDEO-LAYOUT", 0x10uLL))
                    goto LABEL_422;
                  if (v566)
                  {
                    CFRelease(v566);
                    v566 = 0;
                    v177 = temporaryBlock;
                  }
                  if (PlaylistExtractVideoLayoutAttribute((char *)v177, *(size_t *)&v594, (uint64_t)&v572, (__CFArray **)&v566))
                  {
                    v485 = CFSTR("%s: Invalid video layout tag");
                    goto LABEL_1385;
                  }
                  matched = 0;
                  HIDWORD(v507) = 1;
                  LODWORD(v543) = 1;
                  break;
                case 0x11uLL:
                  if (!strncmp((const char *)v597, "AVERAGE-BANDWIDTH", 0x11uLL))
                  {
LABEL_425:
                    *(double *)type = 0.0;
                    v183 = sp_strtoll((const char *)v177, (char **)&temporaryBlock, (uint64_t *)type, 1, (uint64_t)"avg_bandwidth", (uint64_t)&v572);
                    if (*(uint64_t *)type <= 0)
                    {
                      matched = 4294954654;
                      _StreamPlaylistLogError(4294954654, 4294955021, (uint64_t)&v572, CFSTR("Zero average bandwidth"), p_blockBufferOut, v491);
                    }
                    else
                    {
                      matched = v183;
                      v184 = v529;
                      if (!(_DWORD)v183)
                        v184 = *(void **)type;
                      v529 = v184;
                    }
                  }
                  else
                  {
                    if (strncmp(v176, "STABLE-VARIANT-ID", 0x11uLL))
                      goto LABEL_422;
                    v539 = CFStringCreateWithBytes(structureAllocator, v177, *(CFIndex *)&v594, 0x600u, 1u);
                  }
                  break;
                case 0x13uLL:
                  if (strncmp((const char *)v597, "SUPPLEMENTAL-CODECS", 0x13uLL))
                    goto LABEL_422;
                  if ((v175 & 1) == 0)
                  {
                    v179 = "SUPPLEMENTAL-CODECS";
                    goto LABEL_451;
                  }
                  v551 = CFStringCreateWithBytes(structureAllocator, v177, *(CFIndex *)&v594, 0x600u, 1u);
                  break;
                default:
                  goto LABEL_422;
              }
            }
            v170 = a5;
          }
        }
        v168 = v592;
      }
      free((void *)blockBufferOut);
      v201 = v580;
      if (v580)
      {
        if ((_DWORD)v531)
          goto LABEL_508;
        v202 = v538;
        if (v165)
          v202 = v169;
        matched = PlaylistProcessAlternate((uint64_t)v560, v580, v579, (uint64_t)v528, v529, (const __CFString *)cf, (const __CFString *)v551, (uint64_t)v552, v568, v68, (void *)v549, (uint64_t)v548, (uint64_t)v521, v533, v587, v586, (uint64_t)v539, (int)v527, (int)v532,
                    v567,
                    (uint64_t)v566,
                    (uint64_t)v202,
                    (_BYTE *)&v570 + 1,
                    (uint64_t)&v572);
        v201 = v580;
        if (v580)
        {
LABEL_508:
          CFRelease(v201);
          v580 = 0;
        }
        if (v579)
        {
          CFRelease(v579);
          v579 = 0;
        }
        if (v169)
          CFRelease(v169);
        if ((_DWORD)matched)
          goto LABEL_1387;
        v536 = 1;
        v203 = 1;
      }
      else
      {
        if ((_BYTE)v533)
        {
          matched = 4294954654;
          _StreamPlaylistLogError(4294954654, 4294955033, (uint64_t)&v572, CFSTR("No URI in I-Frame variant"));
        }
        v203 = 0;
      }
      LODWORD(v543) = 1;
      v21 = v521;
      goto LABEL_526;
    }
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-PROGRAM-DATE-TIME", 0x18uLL, (const char **)&v592, (uint64_t)&v572))
    {
      *(double *)&returnedPointerOut = 0.0;
      if (v544)
        CFRelease(v544);
      v205 = FigCFParseISO8601Date();
      matched = v205;
      if ((_DWORD)v205)
      {
        _StreamPlaylistLogError(v205, 4294955017, (uint64_t)&v572, CFSTR("%s: ISO8601 Date parse error"), "#EXT-X-PROGRAM-DATE-TIME");
        v544 = 0;
      }
      else
      {
        v544 = CFDateCreate(structureAllocator, *(CFAbsoluteTime *)&returnedPointerOut);
        FigMediaSegmentSpecifierSetImputedDate((uint64_t)v583, *(double *)&returnedPointerOut);
        v516[2] = 1;
        v71 = *(double *)&returnedPointerOut;
      }
      v211 = v592;
      v212 = strcspn(v592, "\r\n");
      v213 = &v211[v212];
      v592 = &v211[v212 - 1];
      v214 = *v592;
      if ((v214 - 48) >= 0xA && v214 != 90)
        v213 = &v211[v212 - 1];
      goto LABEL_560;
    }
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-VERSION", 0xEuLL, (const char **)&v592, (uint64_t)&v572))
    {
      if (v499)
        _StreamPlaylistLogError(4294954654, 4294949660, (uint64_t)&v572, CFSTR("Can only have one %s tag"), "#EXT-X-VERSION");
      LODWORD(v572) = 0;
      if ((*v592 - 58) < 0xFFFFFFF6)
      {
        matched = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("No Version"), p_blockBufferOut);
      }
      else
      {
        v206 = 0;
        v207 = v592 + 1;
        do
        {
          LODWORD(v572) = 10 * v206;
          v206 = *(v207 - 1) + 10 * v206 - 48;
          LODWORD(v572) = v206;
          v592 = v207;
          v208 = *v207++;
        }
        while (v208 - 48 < 0xA);
        if ((v208 & 0x80000000) != 0)
          v216 = __maskrune(v208, 0x500uLL);
        else
          v216 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v208 + 60) & 0x500;
        if (v216)
        {
          matched = 4294954654;
          _StreamPlaylistLogError(4294954654, 4294954986, (uint64_t)&v572, CFSTR("Characters after version"), p_blockBufferOut);
        }
        else
        {
          if ((v572 - 14) > 0xFFFFFFF2)
          {
            matched = 0;
            v209 = 1;
            goto LABEL_546;
          }
          matched = 4294954654;
          _StreamPlaylistLogError(4294954654, 4294954986, (uint64_t)&v572, CFSTR("Unsupported version: %u"), v572);
        }
      }
      v209 = 0;
LABEL_546:
      FigMediaPlaylistSetVersion((uint64_t)v585, v572);
      if (v560)
        FigMultivariantPlaylistSetVersion((uint64_t)v560, v572);
      if ((_DWORD)a5)
        v210 = 1;
      else
        v210 = v209;
      if ((v210 & 1) == 0)
        goto LABEL_1387;
      v499 = 1;
      goto LABEL_561;
    }
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-PLAYLIST-TYPE", 0x14uLL, (const char **)&v592, (uint64_t)&v572))
    {
      if ((_DWORD)v507)
      {
        matched = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294949660, (uint64_t)&v572, CFSTR("Can only have one of each Media Playlist Tag"));
        if (!(_DWORD)a5)
          goto LABEL_1387;
      }
      else
      {
        matched = 0;
      }
      if (StreamingPlaylist_MatchAlphanumericStringExactly(v592, "VOD", 3uLL, (const char **)&v592))
      {
        v218 = (uint64_t)v585;
        v219 = 2;
      }
      else
      {
        if (StreamingPlaylist_MatchAlphanumericStringExactly(v592, "EVENT", 5uLL, (const char **)&v592))
        {
          LODWORD(v507) = 1;
          FigMediaPlaylistSetPlaylistType((uint64_t)v585, 1);
          goto LABEL_561;
        }
        v222 = StreamingPlaylist_MatchAlphanumericStringExactly(v592, "LIVE", 4uLL, (const char **)&v592);
        if (!(_DWORD)v222)
        {
          _StreamPlaylistLogError(v222, 4294955032, (uint64_t)&v572, CFSTR("Invalid playlist type"));
          LODWORD(v507) = 1;
          goto LABEL_561;
        }
        v218 = (uint64_t)v585;
        v219 = 0;
      }
      FigMediaPlaylistSetPlaylistType(v218, v219);
      LODWORD(v507) = 1;
      goto LABEL_561;
    }
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-BYTERANGE", 0x10uLL, (const char **)&v592, (uint64_t)&v572))
    {
      LOBYTE(v597) = 0;
      *(double *)&returnedPointerOut = COERCE_DOUBLE(FigMediaSegmentSpecifierGetStartOffset((uint64_t)v583));
      *(_QWORD *)&blockBufferOut = 0;
      matched = PlaylistProcessByteRange((uint64_t *)&blockBufferOut, (uint64_t *)&returnedPointerOut, &v597, (const char **)&v592, 0, (uint64_t)&v572);
      FigMediaSegmentSpecifierSetBytesToRead((uint64_t)v583, blockBufferOut);
      FigMediaSegmentSpecifierSetStartOffset((uint64_t)v583, (uint64_t)returnedPointerOut);
      if ((_DWORD)matched)
      {
        _StreamPlaylistLogError(matched, 4294955021, (uint64_t)&v572, CFSTR("Couldn't read byte range start offset"));
        v217 = v509;
      }
      else
      {
        v217 = 1;
        if ((_BYTE)v597)
        {
          v221 = 1;
          goto LABEL_589;
        }
        v221 = 1;
        if (v509)
        {
LABEL_589:
          v519 = v221;
          v509 = v217;
          goto LABEL_561;
        }
        matched = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955021, (uint64_t)&v572, CFSTR("Initial offset not received"));
        v217 = 0;
      }
      v221 = v519;
      goto LABEL_589;
    }
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-BITRATE", 0xEuLL, (const char **)&v592, (uint64_t)&v572))
    {
      v220 = PlaylistProcessBitRate(&BitRate, (const char **)&v592, (uint64_t)&v572);
      matched = v220;
      if ((_DWORD)v220)
      {
        _StreamPlaylistLogError(v220, 4294948093, (uint64_t)&v572, CFSTR("Couldn't read bitrate value"));
        LODWORD(v514) = 1;
        goto LABEL_561;
      }
      LODWORD(v514) = 1;
      goto LABEL_690;
    }
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-MEDIA", 0xCuLL, (const char **)&v592, (uint64_t)&v572))
    {
      *(_QWORD *)v492 = 0;
      v493 = 0;
      v223 = 0;
      v494 = 0;
      v496 = 0;
      v57 = 0;
      v56 = 0;
      v55 = 0;
      v559[0] = 0;
      *(_WORD *)v557 = 0;
      *(_QWORD *)&blockBufferOut = 0;
      v515 = 1;
      while (1)
      {
        v224 = *v592;
        v98 = v224 > 0xD;
        v225 = (1 << v224) & 0x2401;
        if (!v98 && v225 != 0)
          break;
        v597 = 0;
        *(double *)&returnedPointerOut = 0.0;
        v595 = 0;
        temporaryBlock = 0;
        *(_DWORD *)type = 0;
        free((void *)blockBufferOut);
        *(_QWORD *)&blockBufferOut = 0;
        v227 = sp_ParseAttribute("#EXT-X-MEDIA", v592, 1, 0, &returnedPointerOut, &temporaryBlock, (const char **)&v597, (size_t *)&v595, (const char **)&v592, (int *)type, (UInt8 **)&blockBufferOut, (uint64_t)&v572);
        matched = v227;
        if (!v498 && (_DWORD)v227)
          goto LABEL_1401;
        v228 = type[0];
        if ((type[0] & 2) != 0)
          goto LABEL_727;
        v229 = returnedPointerOut;
        if (*(double *)&returnedPointerOut != 0.0)
        {
          v230 = (UInt8 *)v597;
          if (v597)
          {
            switch((unint64_t)temporaryBlock)
            {
              case 3uLL:
                if (!strncmp(returnedPointerOut, "URI", 3uLL))
                {
                  if ((v228 & 1) == 0)
                  {
                    v231 = "URI";
                    goto LABEL_663;
                  }
                  StreamingPlaylistCreateMediaURLWithBytes(v230, (CFIndex)v595, anURL, v524, &v578, &v577);
                }
                break;
              case 4uLL:
                if (!strncmp(returnedPointerOut, "TYPE", 4uLL))
                {
                  if (!strncasecmp((const char *)v230, "AUDIO", 5uLL))
                  {
                    v223 = 1936684398;
                  }
                  else if (!strncasecmp((const char *)v230, "VIDEO", 5uLL))
                  {
                    v223 = 1986618469;
                  }
                  else if (!strncasecmp((const char *)v230, "SUBTITLES", 9uLL))
                  {
                    v223 = 1935832172;
                  }
                  else if (!strncasecmp((const char *)v230, "CLOSED-CAPTIONS", 0xFuLL))
                  {
                    v223 = 1668047728;
                  }
                  else
                  {
                    _StreamPlaylistLogError(0, 4294954985, (uint64_t)&v572, CFSTR("Unknown type %s in EXT-X-MEDIA"), v230);
                    v515 = 0;
                  }
                }
                else if (!strncmp(v229, "NAME", 4uLL))
                {
                  if (v496)
                  {
                    matched = 4294954654;
                    _StreamPlaylistLogError(4294954654, 4294955031, (uint64_t)&v572, CFSTR("%s: duplicate name"), "NAME");
                  }
                  if ((v228 & 1) == 0)
                  {
                    v231 = "NAME";
                    goto LABEL_663;
                  }
                  v496 = CFStringCreateWithBytes(structureAllocator, (const UInt8 *)v597, (CFIndex)v595, 0x8000100u, 1u);
                }
                break;
              case 6uLL:
                if (!strncmp(returnedPointerOut, "FORCED", 6uLL))
                {
                  v232 = v557;
                  goto LABEL_619;
                }
                break;
              case 7uLL:
                if (!strncmp(returnedPointerOut, "DEFAULT", 7uLL))
                {
                  v232 = &v557[1];
LABEL_619:
                  v233 = sp_MatchYesOrNo((uint64_t)v229, (char *)v230, (uint64_t)&v572, v232);
                  goto LABEL_620;
                }
                break;
              case 8uLL:
                if (!strncmp(returnedPointerOut, "GROUP-ID", 8uLL))
                {
                  if ((v228 & 1) == 0)
                  {
                    v231 = "GROUP-ID";
                    goto LABEL_663;
                  }
                  if (v57)
                  {
                    CFRelease(v57);
                    v230 = (UInt8 *)v597;
                  }
                  v57 = (__CFString *)CFStringCreateWithBytes(structureAllocator, v230, (CFIndex)v595, 0x600u, 1u);
                }
                else if (!strncmp(v229, "LANGUAGE", 8uLL))
                {
                  if (v55)
                  {
                    matched = 4294954654;
                    _StreamPlaylistLogError(4294954654, 4294955031, (uint64_t)&v572, CFSTR("%s: duplicate language"), "LANGUAGE");
                  }
                  if ((v228 & 1) == 0)
                  {
                    v231 = "LANGUAGE";
                    goto LABEL_663;
                  }
                  v55 = CFStringCreateWithBytes(structureAllocator, (const UInt8 *)v597, (CFIndex)v595, 0x600u, 1u);
                }
                else if (!strncmp(v229, "CHANNELS", 8uLL))
                {
                  if ((v228 & 1) == 0)
                  {
                    v231 = "CHANNELS";
                    goto LABEL_663;
                  }
                  if (v493)
                  {
                    CFRelease(v493);
                    v230 = (UInt8 *)v597;
                  }
                  v493 = (__CFString *)CFStringCreateWithBytes(structureAllocator, v230, (CFIndex)v595, 0x600u, 1u);
                }
                break;
              case 9uLL:
                if (!strncmp(returnedPointerOut, "BIT-DEPTH", 9uLL))
                {
                  v594 = 0.0;
                  if (sp_strtod((const char *)v230, (char **)&v597, &v594, 0, (uint64_t)"bit depth", (uint64_t)&v572)|| v594 <= 0.0)
                  {
                    matched = 4294954654;
                    _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s: invalid bit depth"), "#EXT-X-MEDIA");
                  }
                  else
                  {
                    matched = 0;
                    v492[1] = (int)v594;
                  }
                }
                break;
              case 0xAuLL:
                if (!strncmp(returnedPointerOut, "AUTOSELECT", 0xAuLL))
                {
                  matched = sp_MatchYesOrNo((uint64_t)v229, (char *)v230, (uint64_t)&v572, v559);
                  v492[0] = 1;
                }
                break;
              case 0xBuLL:
                if (!strncmp(returnedPointerOut, "INSTREAM-ID", 0xBuLL))
                {
                  if ((v228 & 1) == 0)
                  {
                    v231 = "INSTREAM-ID";
                    goto LABEL_663;
                  }
                  v494 = CFStringCreateWithBytes(structureAllocator, v230, (CFIndex)v595, 0x8000100u, 0);
                }
                else if (!strncmp(v229, "SAMPLE-RATE", 0xBuLL))
                {
                  v594 = 0.0;
                  if (sp_strtod((const char *)v230, (char **)&v597, &v594, 0, (uint64_t)"sample rate", (uint64_t)&v572)|| v594 <= 0.0)
                  {
                    matched = 4294954654;
                    _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s: invalid sample rate"), "#EXT-X-MEDIA");
                  }
                  else
                  {
                    matched = 0;
                    v162 = v594;
                  }
                }
                break;
              case 0xEuLL:
                if (!strncmp(returnedPointerOut, "ASSOC-LANGUAGE", 0xEuLL))
                {
                  if (v56)
                  {
                    matched = 4294954654;
                    _StreamPlaylistLogError(4294954654, 4294955031, (uint64_t)&v572, CFSTR("%s: duplicate language"), "ASSOC-LANGUAGE");
                  }
                  if ((v228 & 1) == 0)
                  {
                    v231 = "ASSOC-LANGUAGE";
                    goto LABEL_663;
                  }
                  v56 = CFStringCreateWithBytes(structureAllocator, (const UInt8 *)v597, (CFIndex)v595, 0x600u, 1u);
                }
                break;
              case 0xFuLL:
                if (!strncmp(returnedPointerOut, "CHARACTERISTICS", 0xFuLL))
                {
                  if ((v228 & 1) == 0)
                  {
                    v231 = "CHARACTERISTICS";
                    goto LABEL_663;
                  }
                  if (v576)
                  {
                    CFRelease(v576);
                    v576 = 0;
                    v230 = (UInt8 *)v597;
                  }
                  v233 = PlaylistCreateCharacteristicsArray((char *)v230, (size_t)v595, (uint64_t)&v572, &v576);
LABEL_620:
                  matched = v233;
                }
                break;
              case 0x13uLL:
                if (!strncmp(returnedPointerOut, "STABLE-RENDITION-ID", 0x13uLL))
                {
                  if (v539)
                  {
                    matched = 4294954654;
                    _StreamPlaylistLogError(4294954654, 4294955031, (uint64_t)&v572, CFSTR("%s: duplicate stable stream identifier"), "STABLE-RENDITION-ID");
                  }
                  if ((v228 & 1) != 0)
                  {
                    v539 = CFStringCreateWithBytes(structureAllocator, (const UInt8 *)v597, (CFIndex)v595, 0x600u, 1u);
                  }
                  else
                  {
                    v231 = "STABLE-RENDITION-ID";
LABEL_663:
                    matched = 4294954654;
                    _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s: missing quotes"), v231);
                  }
                }
                break;
              default:
                break;
            }
            if (!v498 && (_DWORD)matched)
              goto LABEL_1401;
          }
        }
        if (!v515)
        {
LABEL_727:
          free((void *)blockBufferOut);
          goto LABEL_807;
        }
      }
      free((void *)blockBufferOut);
      v234 = FigGetCFStringForOSTypeValue();
      if (v223 && v57 && v496)
      {
        v235 = v234;
        if (v557[1] && v492[0] && !v559[0])
        {
          v487 = CFSTR("%s: DEFAULT=YES when AUTOSELECT=NO");
          v488 = "#EXT-X-MEDIA";
          goto LABEL_1393;
        }
        if (v223 == 1668047728)
        {
          if (v578)
          {
            v487 = CFSTR("URL specified for Closed Captions");
LABEL_1394:
            matched = 4294954654;
            v489 = 4294955030;
LABEL_1400:
            _StreamPlaylistLogError(4294954654, v489, (uint64_t)&v572, v487, p_blockBufferOut, v491);
            goto LABEL_1401;
          }
          if (!v494)
          {
            matched = 4294954654;
            _StreamPlaylistLogError(4294954654, 4294954977, (uint64_t)&v572, CFSTR("Closed Caption INSTREAM-ID not specified"), p_blockBufferOut, v491);
            goto LABEL_1401;
          }
          if (!FigClosedCaptionGetClosedCaptionTypeAndChannelNumber(v494, 0, 0))
          {
            v487 = CFSTR("Invalid Entry for %s %@");
            v491 = v494;
            v488 = "INSTREAM-ID";
LABEL_1393:
            p_blockBufferOut = v488;
            goto LABEL_1394;
          }
LABEL_793:
          v268 = v576;
          if (BYTE8(v574) && v576)
          {
            returnedPointerOut = (char *)v223;
            v599 = (const __CFString *)&v572;
            v606.length = CFArrayGetCount(v576);
            v606.location = 0;
            CFArrayApplyFunction(v268, v606, (CFArrayApplierFunction)PlaylistCharacteristicsCheckFn, &returnedPointerOut);
          }
          if (v223 == 1668047728)
          {
            v269 = PlaylistAddCharacteristicsForClosedCaptions(&v576);
            if ((_DWORD)v269)
              goto LABEL_1403;
            v270 = v578;
            v271 = v578 == 0;
            v268 = v576;
          }
          else
          {
            v271 = 0;
            v270 = v578;
          }
          matched = PlaylistAddMediaGroup((uint64_t)v560, v223, v57, v55, v496, v270, v577, v539, v162, v557[1], v559[0], v557[0], v271, v268, v56, v494, v493, v492[1], &valuePtr);
          if ((_DWORD)matched || !v235)
          {
LABEL_807:
            if (v493)
              CFRelease(v493);
            if (v494)
              CFRelease(v494);
            if (v57)
              CFRelease(v57);
            if (v55)
              CFRelease(v55);
            if (v56)
              CFRelease(v56);
            if (v578)
            {
              CFRelease(v578);
              v578 = 0;
            }
            if (v577)
            {
              CFRelease(v577);
              v577 = 0;
            }
            if (v496)
              CFRelease(v496);
            if (v576)
            {
              CFRelease(v576);
              v576 = 0;
            }
            if (v539)
              CFRelease(v539);
            if (v498 || !(_DWORD)matched)
            {
              v539 = 0;
              HIDWORD(v514) = 1;
              goto LABEL_561;
            }
            v496 = 0;
            v55 = 0;
            v56 = 0;
            v57 = 0;
LABEL_1401:
            v555 = 0;
            LODWORD(v546) = 0;
            v547 = 0;
            v21 = v521;
            v53 = v548;
            v54 = v496;
            goto LABEL_1300;
          }
          v272 = CFStringCreateWithFormat(structureAllocator, 0, CFSTR("%@%@%@"), v57, v496, v235);
          if (v272)
          {
            v273 = v272;
            if (CFSetContainsValue(theSet, v272))
              _StreamPlaylistLogError(4294954654, 4294955031, (uint64_t)&v572, CFSTR("%s: duplicate name (%@) for rendition group \"%@\""), "#EXT-X-MEDIA", v496, v57);
            else
              CFSetAddValue(theSet, v273);
            CFRelease(v273);
            matched = 0;
            goto LABEL_807;
          }
          v269 = FigSignalErrorAt();
LABEL_1403:
          matched = v269;
          goto LABEL_1401;
        }
        if (v223 == 1986618469 && v56)
        {
          v487 = CFSTR("Cannot specify alternate language for video streams");
        }
        else
        {
          if (v223 == 1935832172 && !v578)
          {
            matched = 4294954654;
            _StreamPlaylistLogError(4294954654, 4294955033, (uint64_t)&v572, CFSTR("Missing mandatory URL for subtitle media selection"), p_blockBufferOut, v491);
            goto LABEL_1401;
          }
          if (v223 == 1936684398)
          {
            if (!v494)
              goto LABEL_793;
            if ((int)v572 <= 12)
              _StreamPlaylistLogError(4294954654, 4294954986, (uint64_t)&v572, CFSTR("Audio instream ID requires version 13 or greater"));
            v245 = CFGetTypeID(v494);
            if (v245 == CFStringGetTypeID())
            {
              CharacterAtIndex = CFStringGetCharacterAtIndex(v494, 0);
              v501 = 1;
              if (v498 || (CharacterAtIndex - 48) < 0xA)
                goto LABEL_793;
            }
            else if (v498)
            {
              v501 = 1;
              goto LABEL_793;
            }
            v487 = CFSTR("Audio instream ID must be a quoted, numerical, string");
          }
          else
          {
            if (!v494)
              goto LABEL_793;
            v487 = CFSTR("Instream ID only valid for Audio and Closed Captions");
          }
        }
      }
      else
      {
        v487 = CFSTR("Missing mandatory media selection tags");
      }
      matched = 4294954654;
      v489 = 4294955032;
      goto LABEL_1400;
    }
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-MAP", 0xAuLL, (const char **)&v592, (uint64_t)&v572))
    {
      v236 = 0;
      v237 = 0;
      temporaryBlock = 0;
      v597 = 0;
      v595 = 0;
      while (1)
      {
        v238 = *v592;
        v98 = v238 > 0xD;
        v239 = (1 << v238) & 0x2401;
        if (!v98 && v239 != 0)
          break;
        *(double *)&returnedPointerOut = 0.0;
        *(_QWORD *)&blockBufferOut = 0;
        v594 = 0.0;
        *(double *)type = 0.0;
        *(_DWORD *)v559 = 0;
        free(v595);
        v595 = 0;
        v241 = sp_ParseAttribute("#EXT-X-MAP", v592, 1, 0, &returnedPointerOut, &v594, (const char **)&blockBufferOut, (size_t *)type, (const char **)&v592, (int *)v559, &v595, (uint64_t)&v572);
        matched = v241;
        if (!(_DWORD)a5 && (_DWORD)v241)
          goto LABEL_1387;
        v242 = v559[0];
        if ((v559[0] & 2) != 0)
        {
          v237 = 1;
        }
        else if (*(double *)&returnedPointerOut != 0.0)
        {
          v243 = (const UInt8 *)blockBufferOut;
          if ((_QWORD)blockBufferOut)
          {
            if (*(_QWORD *)&v594 == 9)
            {
              if (!strncmp(returnedPointerOut, "BYTERANGE", 9uLL))
              {
                if ((v242 & 1) == 0)
                {
                  v278 = "BYTERANGE";
LABEL_846:
                  matched = 4294954654;
                  _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s %s: missing quotes"), "#EXT-X-MAP", v278);
LABEL_742:
                  free(v595);
                  if (!v236)
                  {
LABEL_778:
                    if (!(_DWORD)a5 && (_DWORD)matched)
                      goto LABEL_1387;
                    if (v589)
                    {
                      LODWORD(v530) = 1;
                      FigMediaSegmentSpecifierSetIsReadInCurrent((uint64_t)v589, 1);
                      v262 = (uint64_t)v590;
                      FigMediaSegmentSpecifierSetContentKeySpecifier((uint64_t)v589, v590);
                      v263 = v582;
                      FigMediaSegmentSpecifierSetIV((uint64_t)v589, v582);
                      if (v262)
                      {
                        EncryptionMethod = FigContentKeySpecifierGetEncryptionMethod(v262);
                        LODWORD(v530) = 1;
                        if (!v263 && EncryptionMethod == 3)
                        {
                          _StreamPlaylistLogError(0, 4294949666, (uint64_t)&v572, CFSTR("Explicit IV is required for map entry for full segment encryption"));
                          matched = 0;
                          LODWORD(v530) = 1;
                          if (!(_DWORD)a5)
                          {
                            if (dword_1EE2A3208)
                            {
                              LODWORD(v594) = 0;
                              type[0] = OS_LOG_TYPE_DEFAULT;
                              v265 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
                              v266 = LODWORD(v594);
                              if (os_log_type_enabled(v265, type[0]))
                                v267 = v266;
                              else
                                v267 = v266 & 0xFFFFFFFE;
                              if (v267)
                              {
                                LODWORD(blockBufferOut) = 136315138;
                                *(_QWORD *)((char *)&blockBufferOut + 4) = "FigStreamPlaylistParseInProcess";
                                LODWORD(v491) = 12;
                                p_blockBufferOut = (const char *)&blockBufferOut;
                                _os_log_send_and_compose_impl();
                              }
                              LODWORD(v530) = 1;
                              fig_log_call_emit_and_clean_up_after_send_and_compose();
                              matched = 0;
                            }
                          }
                        }
                      }
                    }
                    v516[3] = 1;
                    goto LABEL_561;
                  }
LABEL_777:
                  CFRelease(v236);
                  goto LABEL_778;
                }
                matched = PlaylistProcessByteRange((uint64_t *)&temporaryBlock, (uint64_t *)&v597, 0, (const char **)&blockBufferOut, *(uint64_t *)type, (uint64_t)&v572);
              }
            }
            else if (*(_QWORD *)&v594 == 3 && !strncmp(returnedPointerOut, "URI", 3uLL))
            {
              if ((v242 & 1) == 0)
              {
                v278 = "URI";
                goto LABEL_846;
              }
              v244 = (const __CFAllocator *)FigGetAllocatorForMedia();
              v236 = CFStringCreateWithBytes(v244, v243, *(CFIndex *)type, 0x8000100u, 0);
            }
          }
        }
        if ((_DWORD)matched)
          goto LABEL_742;
      }
      if (v237)
      {
        matched = 0;
        goto LABEL_742;
      }
      if (!v236)
      {
        v485 = CFSTR("Missing mandatory URL for %s");
        v486 = "#EXT-X-MAP";
        goto LABEL_1386;
      }
      if (v589)
      {
        CFRelease(v589);
        v589 = 0;
      }
      MatchingMapEntry = FindMatchingMapEntry((uint64_t)v585, (uint64_t)v236, (uint64_t)v597, (uint64_t)temporaryBlock);
      v589 = MatchingMapEntry;
      if (MatchingMapEntry && (CFRetain(MatchingMapEntry), v589))
        matched = 0;
      else
        matched = PlaylistCreateMapEntry((uint64_t)v585, v236, (uint64_t)v597, (uint64_t)temporaryBlock, v591, &v589);
      free(v595);
      LODWORD(v502) = 1;
      goto LABEL_777;
    }
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-PART-INF", 0xFuLL, (const char **)&v592, (uint64_t)&v572))
    {
      v247 = PlaylistProcessPartInfTag((uint64_t)v585, v592, (uint64_t)&v572);
      matched = v247;
      if (!(_DWORD)a5 && (_DWORD)v247)
        goto LABEL_1387;
      if (HIDWORD(v512))
      {
        matched = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294949660, (uint64_t)&v572, CFSTR("Can only have one of each Media Playlist Tag"));
      }
      if (!(_DWORD)a5 && (_DWORD)matched)
        goto LABEL_1387;
      v248 = v592;
      v592 = &v248[strcspn(v592, "\r\n")];
      HIDWORD(v512) = 1;
      goto LABEL_561;
    }
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-PART", 0xBuLL, (const char **)&v592, (uint64_t)&v572))
    {
      if (!v584)
      {
        v250 = 0;
        do
        {
          v251 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers((uint64_t)v585);
          if (v251)
            v251 = (const __CFArray *)CFArrayGetCount(v251);
          if (v250 >= (uint64_t)v251)
            goto LABEL_768;
          v252 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers((uint64_t)v585);
          v253 = CFArrayGetValueAtIndex(v252, v250);
          v254 = FigMediaSegmentSpecifierGetMediaSequence((uint64_t)v253);
          ++v250;
        }
        while (v254 != FigMediaSegmentSpecifierGetMediaSequence((uint64_t)v583));
        DiscontinuityDomain = (void *)FigMediaSegmentSpecifierGetMediaSequence((uint64_t)v253);
      }
LABEL_768:
      v255 = v71 + v72;
      if (v71 == 0.0)
        v255 = 0.0;
      v256 = PlaylistProcessPartTag((uint64_t)v585, v592, (uint64_t)v583, v590, v589, (uint64_t)DiscontinuityDomain, v582, (uint64_t)&v572, v255, &v569);
      matched = v256;
      if (!(_DWORD)a5 && (_DWORD)v256)
        goto LABEL_1387;
      v257 = v592;
      v592 = &v257[strcspn(v592, "\r\n")];
      FigMediaPlaylistSetHasPartTag((uint64_t)v585, 1);
      FigMediaSegmentSpecifierGetPartialSegments((uint64_t)v583);
      v258 = FigCFArrayGetLastValue();
      if (v258)
      {
        v259 = v258;
        v260 = FigMediaSegmentSpecifierGetTimeInSeconds(v258);
        if ((_BYTE)v512)
          v261 = 1;
        else
          v261 = FigMediaSegmentSpecifierIsMarkedIndependent(v259) != 0;
        LOBYTE(v512) = v261;
      }
      else
      {
        LOBYTE(v512) = v512 != 0;
        v260 = 0.0;
      }
      v72 = v72 + v260;
      goto LABEL_561;
    }
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-RENDITION-REPORT", 0x17uLL, (const char **)&v592, (uint64_t)&v572))
    {
      v274 = PlaylistProcessRenditionReportTag((uint64_t)v585, v592, anURL, (uint64_t)&v572);
      matched = v274;
      if (!(_DWORD)a5 && (_DWORD)v274)
        goto LABEL_1387;
      v275 = v592;
      v592 = &v275[strcspn(v592, "\r\n")];
      LODWORD(v506) = 1;
      goto LABEL_561;
    }
    if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-PRELOAD-HINT", 0x13uLL, (const char **)&v592, (uint64_t)&v572))
    {
      v276 = PlaylistProcessPreloadHintTag((uint64_t)v585, v592, (uint64_t)&v572);
      matched = v276;
      if (!(_DWORD)a5 && (_DWORD)v276)
        goto LABEL_1387;
      v277 = v592;
      v592 = &v277[strcspn(v592, "\r\n")];
      HIDWORD(v505) = 1;
      goto LABEL_561;
    }
    if (!sp_MatchTagAndColon((const char *)v67, "#EXT-X-START", 0xCuLL, (const char **)&v592, (uint64_t)&v572))
    {
      if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-SESSION-DATA", 0x13uLL, (const char **)&v592, (uint64_t)&v572)|| sp_MatchTagAndColon((const char *)v67, "#EXT-X-SESSION-DATA-ITUNES", 0x1AuLL, (const char **)&v592, (uint64_t)&v572))
      {
        matched = PlaylistProcessSessionDataTag((uint64_t)v560, v592, anURL, (uint64_t)&v572);
        v289 = v592;
        v592 = &v289[strcspn(v592, "\r\n")];
        v516[0] = 1;
        goto LABEL_561;
      }
      if (StreamingPlaylist_MatchAlphanumericStringExactly((const char *)v67, "#EXT-X-INDEPENDENT-SEGMENTS", 0x1BuLL, (const char **)&v592))
      {
        FigMediaPlaylistSetHasIndependentSegments((uint64_t)v585, 1);
        if (v560)
          FigMultivariantPlaylistSetHasIndependentSegments((uint64_t)v560, 1);
        matched = 0;
      }
      else
      {
        if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-DATERANGE", 0x10uLL, (const char **)&v592, (uint64_t)&v572))
        {
          matched = PlaylistProcessTaggedRangeTag((uint64_t)v585, v592, &v570, (uint64_t)&v572);
          v291 = v592;
          v592 = &v291[strcspn(v592, "\r\n")];
          LODWORD(v505) = 1;
          goto LABEL_561;
        }
        if (StreamingPlaylist_MatchAlphanumericStringExactly((const char *)v67, "#EXT-X-GAP", 0xAuLL, (const char **)&v592))
        {
          matched = 0;
          v592 = (char *)(v67 + strcspn((const char *)v67, "\r\n"));
          LOBYTE(v534) = 1;
          v516[1] = 1;
        }
        else
        {
          if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-DEFINE", 0xDuLL, (const char **)&v592, (uint64_t)&v572))
          {
            matched = PlaylistProcessVariableTag(v592, a11, a12, &v581, (uint64_t)&v572);
            v292 = v592;
            v213 = &v292[strcspn(v592, "\r\n")];
LABEL_560:
            v592 = v213;
            goto LABEL_561;
          }
          if (sp_MatchTagAndColon((const char *)v67, "#EXT-X-SERVER-CONTROL", 0x15uLL, (const char **)&v592, (uint64_t)&v572))
          {
            if (HIDWORD(v506))
            {
              matched = 4294954654;
              _StreamPlaylistLogError(4294954654, 4294949660, (uint64_t)&v572, CFSTR("Can only have one of each Media Playlist Tag"));
              if (!(_DWORD)a5)
                goto LABEL_1387;
            }
            matched = PlaylistProcessServerControlTag((uint64_t)v585, v592, (uint64_t)&v572, PartHoldBackDuration, HoldBackDuration);
            v293 = v592;
            v592 = &v293[strcspn(v592, "\r\n")];
            HIDWORD(v506) = 1;
            goto LABEL_561;
          }
          v294 = sp_MatchTagAndColon((const char *)v67, "#EXT-X-SKIP", 0xBuLL, (const char **)&v592, (uint64_t)&v572);
          if ((_DWORD)v294)
          {
            *(_QWORD *)&blockBufferOut = 0;
            v597 = 0;
            *(double *)&returnedPointerOut = 0.0;
            v295 = (uint64_t)v585;
            v296 = v592;
            v297 = FigMediaSegmentSpecifierGetMediaSequence((uint64_t)v583);
            matched = PlaylistProcessSkipTag(v295, v296, (uint64_t)&v572, v297, (uint64_t)v544, v584, &v584, (unint64_t *)&returnedPointerOut, (double *)&blockBufferOut, (CFTypeRef *)&v597);
            v298 = v592;
            v592 = &v298[strcspn(v592, "\r\n")];
            if (v584)
              NextSegment = FigMediaSegmentSpecifierGetPreviousSegment(v584);
            else
              NextSegment = 0;
            if (v597)
            {
              if (theArray)
              {
                v299 = (const __CFArray *)FigCFArrayCreateConcatenationOfTwoArrays();
                v300 = v299;
                if (v299)
                  CFRetain(v299);
                CFRelease(theArray);
                CFRelease(v597);
                v163 = v300;
              }
              else
              {
                v163 = v597;
              }
            }
            v203 = 0;
            if (!(_DWORD)matched && NextSegment)
            {
              v301 = FigMediaSegmentSpecifierGetStartOffset(NextSegment);
              v302 = FigMediaSegmentSpecifierGetBytesToRead(NextSegment);
              v303 = v590;
              v304 = (const void *)FigMediaSegmentSpecifierGetContentKeySpecifier(NextSegment);
              v590 = v304;
              if (v304)
                CFRetain(v304);
              if (v303)
                CFRelease(v303);
              v305 = v589;
              v306 = (const void *)FigMediaSegmentSpecifierGetMapSegmentSpecifier(NextSegment);
              v589 = v306;
              if (v306)
                CFRetain(v306);
              if (v305)
                CFRelease(v305);
              BitRate = FigMediaSegmentSpecifierGetBitRate(NextSegment);
              DiscontinuityDomain = (void *)FigMediaSegmentSpecifierGetDiscontinuityDomain(NextSegment);
              LOBYTE(v534) = FigMediaSegmentSpecifierIsMarkedAsGap(NextSegment);
              v591 = FigMediaSegmentSpecifierGetMediaSequence(v584);
              if (v544)
                CFRelease(v544);
              v544 = 0;
              v546 = v302 + v301;
              v522 += (uint64_t)returnedPointerOut;
              v70 = v70 + *(double *)&blockBufferOut;
              v203 = 1;
            }
            LODWORD(v508) = 1;
            v21 = v521;
            theArray = v163;
LABEL_526:
            a5 = a5;
            if (!v203)
              goto LABEL_250;
            goto LABEL_101;
          }
          _StreamPlaylistLogError(v294, 4294955028, (uint64_t)&v572, CFSTR("Unknown tag in playlist"));
          matched = 0;
          v592 = (char *)(v67 + strcspn((const char *)v67, "\r\n"));
        }
      }
LABEL_690:
      a5 = a5;
      goto LABEL_252;
    }
    v279 = 0;
    v280 = 0;
    *(double *)&returnedPointerOut = 0.0;
    v557[1] = 0;
    *(_QWORD *)&blockBufferOut = 0;
    while (1)
    {
      while (1)
      {
        v281 = *v592;
        v98 = v281 > 0xD;
        v282 = (1 << v281) & 0x2401;
        if (!v98 && v282 != 0)
        {
          matched = 0;
          v287 = 1;
          goto LABEL_870;
        }
        temporaryBlock = 0;
        v597 = 0;
        v595 = 0;
        *(_DWORD *)v559 = 0;
        free((void *)blockBufferOut);
        *(_QWORD *)&blockBufferOut = 0;
        v284 = sp_ParseAttribute("#EXT-X-START", v592, 1, 0, (char **)&v597, &v595, (const char **)&temporaryBlock, (size_t *)&v594, (const char **)&v592, (int *)v559, (UInt8 **)&blockBufferOut, (uint64_t)&v572);
        matched = v284;
        if (!(_DWORD)a5 && (_DWORD)v284)
          goto LABEL_1387;
        if ((v559[0] & 2) == 0)
          break;
        v279 = 1;
        if ((_DWORD)v284)
        {
LABEL_869:
          v287 = 0;
LABEL_870:
          free((void *)blockBufferOut);
          if (!v287 || v279)
          {
            if ((_DWORD)a5)
              v290 = 1;
            else
              v290 = v287;
            if ((v290 & 1) == 0)
              goto LABEL_1387;
          }
          else if (v280)
          {
            if (v560)
            {
              FigMultivariantPlaylistSetHasStartTime((uint64_t)v560, 1);
              FigMultivariantPlaylistSetStartTimeValue((uint64_t)v560, *(double *)&returnedPointerOut);
              v288 = v557[1];
              FigMultivariantPlaylistSetIsStartTimePrecise((uint64_t)v560, v557[1]);
            }
            else
            {
              v288 = v557[1];
            }
            FigMediaPlaylistSetHasStartTime((uint64_t)v585, 1);
            FigMediaPlaylistSetStartTimeValue((uint64_t)v585, *(double *)&returnedPointerOut);
            FigMediaPlaylistSetIsStartTimePrecise((uint64_t)v585, v288);
          }
          else
          {
            _StreamPlaylistLogError(4294954654, 4294954977, (uint64_t)&v572, CFSTR("%s : missing %s"), "#EXT-X-START", "TIME-OFFSET");
          }
LABEL_561:
          v21 = v521;
LABEL_351:
          a5 = v498;
          goto LABEL_250;
        }
      }
      v285 = v597;
      if (!v597)
        goto LABEL_866;
      v286 = (char *)temporaryBlock;
      if (!temporaryBlock)
        goto LABEL_866;
      if (v595 == (UInt8 *)7)
      {
        if (!strncmp((const char *)v597, "PRECISE", 7uLL))
          matched = sp_MatchYesOrNo((uint64_t)v285, v286, (uint64_t)&v572, &v557[1]);
        goto LABEL_866;
      }
      if (v595 == (UInt8 *)11 && !strncmp((const char *)v597, "TIME-OFFSET", 0xBuLL))
      {
        *(double *)type = 0.0;
        matched = sp_strtod(v286, (char **)type, (double *)&returnedPointerOut, 0, (uint64_t)"Time Offset", (uint64_t)&v572);
        if ((_DWORD)matched)
          goto LABEL_869;
        v280 = 1;
      }
      else
      {
LABEL_866:
        if ((_DWORD)matched)
          goto LABEL_869;
      }
    }
  }
  if (v523)
  {
    matched = 4294954654;
    _StreamPlaylistLogError(4294954654, 4294949660, (uint64_t)&v572, CFSTR("Can only have one %s tag"), "#EXT-X-CONTENT-STEERING");
    goto LABEL_219;
  }
  v521 = v21;
  v93 = 0;
  v94 = 0;
  matched = 0;
  v95 = v560;
  v96 = v592;
  returnedPointerOut = v592;
  *(_QWORD *)&blockBufferOut = 0;
  while (2)
  {
    v97 = *v96;
    v98 = v97 > 0xD;
    v99 = (1 << v97) & 0x2401;
    v100 = v98 || v99 == 0;
    if (!v100)
    {
      FigMultivariantPlaylistSetContentSteeringServerURL((uint64_t)v95, v93);
      FigMultivariantPlaylistSetContentSteeringInitPathwayID((uint64_t)v95, v94);
      if (!v93)
      {
        matched = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s: missing %s attribute"), "#EXT-X-CONTENT-STEERING", "SERVER-URI");
        goto LABEL_213;
      }
LABEL_212:
      CFRelease(v93);
      goto LABEL_213;
    }
    temporaryBlock = 0;
    v597 = 0;
    v594 = 0.0;
    v595 = 0;
    *(_DWORD *)type = 0;
    v101 = (void *)blockBufferOut;
    if ((_QWORD)blockBufferOut)
    {
      *(_QWORD *)&blockBufferOut = 0;
      free(v101);
    }
    matched = sp_ParseAttribute("#EXT-X-CONTENT-STEERING", v96, 1, 0, (char **)&v597, &v595, (const char **)&temporaryBlock, (size_t *)&v594, (const char **)&returnedPointerOut, (int *)type, (UInt8 **)&blockBufferOut, (uint64_t)&v572);
    if ((_DWORD)matched && !BYTE9(v574))
      goto LABEL_326;
    v102 = a5;
    v103 = type[0];
    if ((type[0] & 2) != 0)
      goto LABEL_521;
    v104 = (const char *)v597;
    if (!v597 || (v105 = temporaryBlock) == 0)
    {
LABEL_180:
      a5 = v102;
      goto LABEL_181;
    }
    v106 = v595;
    if (v595 != (UInt8 *)10)
      goto LABEL_179;
    if (!strncmp((const char *)v597, "SERVER-URI", 0xAuLL))
    {
      if ((v103 & 1) == 0)
      {
        v204 = "SERVER-URI";
LABEL_519:
        matched = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s: attribute %s has invalid value format"), "#EXT-X-CONTENT-STEERING", v204);
        a5 = v102;
        goto LABEL_326;
      }
      if (v93)
      {
        matched = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s has multiple %s attributes"), "#EXT-X-CONTENT-STEERING", "SERVER-URI");
        a5 = v102;
        goto LABEL_212;
      }
      v107 = CFURLCreateWithBytes(structureAllocator, v105, *(CFIndex *)&v594, 0x8000100u, (CFURLRef)v573);
      a5 = v102;
      if (v107)
      {
        v93 = v107;
        matched = 0;
      }
      else
      {
        matched = FigSignalErrorAt();
        if ((_DWORD)matched && !BYTE9(v574))
          goto LABEL_213;
        v93 = 0;
      }
LABEL_181:
      v96 = returnedPointerOut;
      continue;
    }
    break;
  }
  if (strncmp(v104, "PATHWAY-ID", 0xAuLL))
  {
LABEL_179:
    _StreamPlaylistLogError(0, 4294955022, (uint64_t)&v572, CFSTR("Unrecognized attribute %.*s in %s"), v106, v104, "#EXT-X-CONTENT-STEERING");
    goto LABEL_180;
  }
  if ((v103 & 1) == 0)
  {
    v204 = "PATHWAY-ID";
    goto LABEL_519;
  }
  if (!v94)
  {
    a5 = v102;
    if (v594 != 0.0)
    {
      v108 = v105;
      v109 = *(_QWORD *)&v594;
      while (1)
      {
        v111 = *v108++;
        v110 = v111;
        v112 = (v111 & 0xFFFFFFDF) - 65;
        if ((v111 - 48) >= 0xA && v112 >= 0x1A)
        {
          v114 = v110 - 45;
          v98 = v114 > 0x32;
          v115 = (1 << v114) & 0x4000000000003;
          if (v98 || v115 == 0)
            break;
        }
        if (!--v109)
          goto LABEL_200;
      }
      matched = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s: attribute %s contains illegal characters"), "#EXT-X-CONTENT-STEERING", "PATHWAY-ID");
      v94 = 0;
      goto LABEL_326;
    }
LABEL_200:
    v94 = CFStringCreateWithBytes(structureAllocator, v105, *(CFIndex *)&v594, 0x8000100u, 1u);
    if (!v94)
    {
      matched = FigSignalErrorAt();
      goto LABEL_326;
    }
    goto LABEL_181;
  }
  matched = 4294954654;
  _StreamPlaylistLogError(4294954654, 4294955032, (uint64_t)&v572, CFSTR("%s: illegal multiple occurrences of attribute %s"), "#EXT-X-CONTENT-STEERING", "PATHWAY-ID");
LABEL_521:
  a5 = v102;
LABEL_326:
  if (v93)
    goto LABEL_212;
LABEL_213:
  if (v94)
    CFRelease(v94);
  if ((_QWORD)blockBufferOut)
    free((void *)blockBufferOut);
  v21 = v521;
  if ((_DWORD)a5 || !(_DWORD)matched)
  {
LABEL_219:
    v118 = v592;
    v592 = &v118[strcspn(v592, "\r\n")];
    v523 = 1;
    goto LABEL_250;
  }
LABEL_965:
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  v555 = 0;
  LODWORD(v546) = 0;
  v547 = 0;
LABEL_1299:
  v53 = v548;
LABEL_1300:
  if (v583)
    CFRelease(v583);
LABEL_1302:
  if (!*__error())
    *__error() = v535;
  if ((v547 & ~(_DWORD)v546 & 1) != 0 || (*(_BYTE *)v540 & 1) != 0)
  {
    if (!a13 || *a13)
      goto LABEL_1312;
    *a13 = v560;
    v560 = 0;
  }
  else
  {
    if (a14 && !*a14 && !(_DWORD)matched)
    {
      *a14 = v585;
      v585 = 0;
    }
LABEL_1312:
    if (v560)
      CFRelease(v560);
  }
  if (v585)
    CFRelease(v585);
  if (v555)
    CFRelease(v555);
  if (v590)
    CFRelease(v590);
  if (v589)
    CFRelease(v589);
  if (v541)
    CFRelease(v541);
  if (v580)
  {
    CFRelease(v580);
    v580 = 0;
  }
  if (v579)
  {
    CFRelease(v579);
    v579 = 0;
  }
  if (v544)
    CFRelease(v544);
  if (theArray)
    CFRelease(theArray);
  if (cf)
    CFRelease(cf);
  if (v551)
    CFRelease(v551);
  if (v552)
    CFRelease(v552);
  if (v549)
    CFRelease(v549);
  if (v53)
    CFRelease(v53);
  if (v21)
    CFRelease(v21);
  if (v582)
    CFRelease(v582);
  if (v57)
    CFRelease(v57);
  if (v576)
  {
    CFRelease(v576);
    v576 = 0;
  }
  if (v55)
    CFRelease(v55);
  if (v56)
    CFRelease(v56);
  if (v578)
  {
    CFRelease(v578);
    v578 = 0;
  }
  if (v577)
  {
    CFRelease(v577);
    v577 = 0;
  }
  if (v54)
    CFRelease(v54);
  if (*((_QWORD *)&v573 + 1))
  {
    CFRelease(*((CFTypeRef *)&v573 + 1));
    *((_QWORD *)&v573 + 1) = 0;
  }
  v481 = v575;
  if (v575)
  {
    v575 = 0;
    free(v481);
  }
  if (v566)
  {
    CFRelease(v566);
    v566 = 0;
  }
  if (theSet)
    CFRelease(theSet);
  if (value)
    CFRelease(value);
  return matched;
}

uint64_t _StreamPlaylistLogError(uint64_t a1, uint64_t a2, uint64_t a3, CFStringRef format, ...)
{
  const __CFAllocator *v6;
  CFStringRef v7;
  CFStringRef v8;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  const UInt8 *v10;
  size_t v11;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v13;
  CFAbsoluteTime Current;
  CFDateRef v15;
  CFDateRef v16;
  const __CFURL *v17;
  CFTypeRef v18;
  const void *v19;
  __CFArray *v20;
  va_list va;

  va_start(va, format);
  if (a3 && ((_DWORD)a1 || *(_BYTE *)(a3 + 40)))
  {
    v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (format)
      v7 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, format, va);
    else
      v7 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], "Format Error", 0x8000100u);
    v8 = v7;
    if ((_DWORD)a1)
    {
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
      os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
      fig_log_call_emit_and_clean_up_after_send_and_compose();
      FigSignalErrorAt();
    }
    if (*(_QWORD *)(a3 + 8))
    {
      v10 = *(const UInt8 **)(a3 + 32);
      if (v10)
      {
        v11 = strcspn(*(const char **)(a3 + 32), "\r\n");
        v10 = (const UInt8 *)CFStringCreateWithBytes(v6, v10, v11, 0x8000100u, 1u);
      }
      Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (Mutable)
      {
        v13 = Mutable;
        Current = CFAbsoluteTimeGetCurrent();
        v15 = CFDateCreate(v6, Current);
        if (v15)
        {
          v16 = v15;
          CFDictionarySetValue(v13, CFSTR("date"), v15);
          CFRelease(v16);
        }
        v17 = *(const __CFURL **)(a3 + 16);
        if (v17)
        {
          v18 = FigCFHTTPCreateURLString(v17);
          if (v18)
          {
            v19 = v18;
            CFDictionarySetValue(v13, CFSTR("uri"), v18);
            CFRelease(v19);
          }
        }
        CFDictionarySetValue(v13, CFSTR("domain"), CFSTR("CoreMediaErrorDomain"));
        FigCFDictionarySetInt32();
        FigCFDictionarySetInt32();
        if (v8)
          CFDictionarySetValue(v13, CFSTR("comment"), v8);
        if (v10)
          CFDictionarySetValue(v13, CFSTR("StreamPlaylistLine"), v10);
        v20 = **(__CFArray ***)(a3 + 8);
        if (!v20)
        {
          **(_QWORD **)(a3 + 8) = CFArrayCreateMutable(v6, 0, MEMORY[0x1E0C9B378]);
          v20 = **(__CFArray ***)(a3 + 8);
        }
        CFArrayAppendValue(v20, v13);
        CFRelease(v13);
      }
      if (v10)
        CFRelease(v10);
    }
    if (v8)
      CFRelease(v8);
  }
  return a1;
}

uint64_t sp_MatchTagAndColon(const char *a1, const char *a2, size_t a3, const char **a4, uint64_t a5)
{
  const char *v9;
  const char *v10;

  if (strncmp(a1, a2, a3))
    return 0;
  v9 = StreamingPlaylist_SkipSpacesAndTabs(&a1[a3], a5);
  if (*v9 != 58)
    return 0;
  v10 = StreamingPlaylist_SkipSpacesAndTabs(v9 + 1, a5);
  if (a4)
    *a4 = v10;
  return 1;
}

uint64_t sp_strtoull(const char *a1, char **a2, unint64_t *a3, int a4, int a5, int a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v16;
  uint64_t v17;
  char *v19;
  unsigned int v20;
  BOOL v21;
  uint64_t v22;
  BOOL v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  char *__endptr;

  __endptr = 0;
  *__error() = 0;
  *a3 = strtoull(a1, &__endptr, a4);
  if (*__error() == 22)
  {
    v16 = CFSTR("%s:Illegal integer conversion");
LABEL_5:
    v25 = a7;
    v17 = 4294954654;
    _StreamPlaylistLogError(4294954654, 4294955032, a8, v16, v25);
    goto LABEL_6;
  }
  if (*__error() == 34)
  {
    v16 = CFSTR("%s:out of range");
    goto LABEL_5;
  }
  if (a5 != 1)
  {
    v19 = (char *)(__endptr - a1);
    if (__endptr > a1)
    {
      v16 = CFSTR("%s:Illegal character before integer");
      while ((*a1 - 48) < 0xA)
      {
        ++a1;
        if (!--v19)
          goto LABEL_13;
      }
      goto LABEL_5;
    }
  }
LABEL_13:
  if (a6 != 1
    || ((v20 = *__endptr, v21 = v20 > 0x2C, v22 = (1 << v20) & 0x100000002400, !v21)
      ? (v23 = v22 == 0)
      : (v23 = 1),
        !v23))
  {
    v17 = 0;
    v24 = 1;
    if (!a2)
      goto LABEL_20;
    goto LABEL_19;
  }
  v26 = a7;
  v17 = 4294954654;
  _StreamPlaylistLogError(4294954654, 4294955032, a8, CFSTR("%s:Illegal characters after integer"), v26);
  v24 = 0;
  if (a2)
LABEL_19:
    *a2 = __endptr;
LABEL_20:
  if ((v24 & 1) != 0)
    return 0;
LABEL_6:
  *a3 = 0;
  return v17;
}

uint64_t sp_strtod(const char *a1, char **a2, double *a3, _BYTE *a4, uint64_t a5, uint64_t a6)
{
  double v12;
  const __CFString *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;

  v28 = 0;
  *__error() = 0;
  if (!a3 || (*a3 = 0.0, !a1))
  {
    v14 = CFSTR("NULL param");
    v15 = 4294954656;
    v16 = 4294954656;
LABEL_36:
    v17 = 4294955032;
    goto LABEL_11;
  }
  v12 = strtod_l(a1, &v28, 0);
  *a3 = v12;
  if (v12 == 0.0 && v28 == a1)
  {
    v14 = CFSTR("%s: Illegal decimal conversion");
    goto LABEL_10;
  }
  if (*__error() == 34)
  {
    v14 = CFSTR("%s: Out of range.");
LABEL_10:
    v25 = a5;
    v15 = 4294954654;
    v16 = 4294954654;
    v17 = 4294955023;
LABEL_11:
    _StreamPlaylistLogError(v16, v17, a6, v14, v25, v27);
    goto LABEL_12;
  }
  v19 = v28;
  if (v28 > a1)
  {
    v20 = MEMORY[0x1E0C80978];
    do
    {
      v21 = *a1;
      if (v21 == 46)
      {
        if (a4)
          *a4 = 1;
        goto LABEL_24;
      }
      if ((v21 & 0x80000000) != 0)
      {
        if (__maskrune(v21, 0x400uLL))
          goto LABEL_24;
      }
      else if ((*(_DWORD *)(v20 + 4 * v21 + 60) & 0x400) != 0)
      {
        goto LABEL_24;
      }
      if (*a1 != 45)
      {
        v14 = CFSTR("%s: Illegal character '%c' in decimal number");
        v25 = a5;
        v27 = *a1;
        v15 = 4294954654;
        v16 = 4294954654;
        goto LABEL_36;
      }
LABEL_24:
      ++a1;
      v19 = v28;
    }
    while (a1 < v28);
  }
  v22 = *v19;
  if (v22 <= 0x2C && ((1 << v22) & 0x100000002400) != 0)
  {
    v15 = 0;
    v24 = 1;
    if (!a2)
      goto LABEL_31;
    goto LABEL_30;
  }
  v26 = a5;
  v15 = 4294954654;
  _StreamPlaylistLogError(4294954654, 4294955032, a6, CFSTR("%s: Illegal character '%c' after decimal number"), v26, (char)v22);
  v24 = 0;
  if (a2)
LABEL_30:
    *a2 = v28;
LABEL_31:
  if ((v24 & 1) != 0)
    return 0;
LABEL_12:
  *a3 = 0.0;
  return v15;
}

uint64_t StreamingPlaylist_MatchAlphanumericStringExactly(const char *a1, const char *a2, size_t a3, const char **a4)
{
  const char *v7;
  unsigned int v8;

  if (!a1 || !a2)
  {
    FigSignalErrorAt();
    return 0;
  }
  if (strncmp(a1, a2, a3))
    return 0;
  v7 = &a1[a3];
  v8 = *v7;
  if ((v8 & 0x80000000) == 0)
  {
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v8 + 60) & 0x500) == 0)
      goto LABEL_9;
    return 0;
  }
  if (__maskrune(v8, 0x500uLL))
    return 0;
LABEL_9:
  if (a4)
    *a4 = v7;
  return 1;
}

uint64_t sp_strtol(const char *a1, char **a2, _DWORD *a3, int a4, uint64_t a5, uint64_t a6)
{
  const __CFString *v12;
  char *v13;
  char *v14;
  unsigned int v15;
  uint64_t v16;
  char v17;
  uint64_t v19;
  uint64_t v20;
  char *__endptr;

  __endptr = 0;
  *__error() = 0;
  *a3 = strtol(a1, &__endptr, 10);
  if (*__error() == 22)
  {
    v12 = CFSTR("%s:Illegal integer conversion");
LABEL_18:
    v19 = a5;
    v16 = 4294954654;
    _StreamPlaylistLogError(4294954654, 4294955032, a6, v12, v19);
    goto LABEL_19;
  }
  if (*__error() == 34)
  {
    v12 = CFSTR("%s:out of range");
    goto LABEL_18;
  }
  if ((*a3 & 0x80000000) != 0)
  {
    v12 = CFSTR("%s:Decimal value less than 0");
    goto LABEL_18;
  }
  v13 = __endptr;
  v14 = (char *)(__endptr - a1);
  if (__endptr > a1)
  {
    v12 = CFSTR("%s:Illegal character before integer");
    while ((*a1 - 48) < 0xA)
    {
      ++a1;
      if (!--v14)
        goto LABEL_10;
    }
    goto LABEL_18;
  }
LABEL_10:
  if (a4 != 1 || (v15 = *__endptr, v15 <= 0x2C) && ((1 << v15) & 0x100000002400) != 0)
  {
    v16 = 0;
    v17 = 1;
    if (!a2)
      goto LABEL_15;
    goto LABEL_14;
  }
  v20 = a5;
  v16 = 4294954654;
  _StreamPlaylistLogError(4294954654, 4294955032, a6, CFSTR("%s:Illegal characters after integer"), v20);
  v17 = 0;
  if (a2)
LABEL_14:
    *a2 = v13;
LABEL_15:
  if ((v17 & 1) == 0)
  {
LABEL_19:
    *a3 = 0;
    return v16;
  }
  return 0;
}

uint64_t PlaylistProcessKey(uint64_t a1, uint64_t a2, const char *a3, const char *a4, CFTypeRef *a5, CFTypeRef *a6, char **a7, uint64_t a8)
{
  char *v9;
  uint64_t v11;
  unsigned int v12;
  BOOL v13;
  int v14;
  char v16;
  char *v17;
  char *v18;
  size_t v19;
  uint64_t v20;
  unint64_t v21;
  CFIndex v22;
  int v23;
  char *v24;
  CFIndex v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  CFIndex v30;
  const char *v31;
  const char *v32;
  size_t v33;
  int v34;
  int v35;
  char *v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  int v40;
  BOOL v41;
  int v42;
  CFURLRef v43;
  CFTypeRef v44;
  const __CFString *v45;
  char **v46;
  CFDataRef v47;
  uint64_t ContentKeySpecifiers;
  const __CFArray *v49;
  CFIndex v50;
  const void *ValueAtIndex;
  CFIndex i;
  CFTypeRef v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t CryptKeyCount;
  CFTypeRef v58;
  uint64_t v59;
  CFTypeRef v60;
  CFTypeRef v61;
  CFTypeRef v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  const __CFAllocator *allocator;
  CFStringRef v72;
  int v73;
  CFDataRef cf;
  int v75;
  CFURLRef v76;
  unint64_t v77;
  int v78;
  CFIndex numBytes;
  uint64_t v80;
  char *v81;
  char *__s1;
  CFTypeRef v83;
  CFTypeRef v84;
  UInt8 *v85;
  char *v86;
  char v87[48];
  UInt8 bytes[8];
  unint64_t v89;
  uint64_t v90;

  v72 = 0;
  v9 = (char *)a4;
  v76 = 0;
  cf = 0;
  v75 = 0;
  v73 = 0;
  v11 = 0;
  v90 = *MEMORY[0x1E0C80C00];
  v85 = 0;
  v86 = (char *)a4;
  v84 = 0;
  v83 = 0;
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  while (2)
  {
    v12 = *v9;
    v13 = v12 > 0xD;
    v14 = (1 << v12) & 0x2401;
    if (v13 || v14 == 0)
    {
      v81 = 0;
      __s1 = 0;
      numBytes = 0;
      v80 = 0;
      v78 = 0;
      free(v85);
      v85 = 0;
      v11 = sp_ParseAttribute(a3, v9, 1, 0, &__s1, &v80, (const char **)&v81, (size_t *)&numBytes, (const char **)&v86, &v78, &v85, a8);
      if ((_DWORD)v11 && !*(_BYTE *)(a8 + 41))
        goto LABEL_157;
      v16 = v78;
      if ((v78 & 2) != 0)
        goto LABEL_157;
      if (!__s1)
        goto LABEL_61;
      v17 = v81;
      if (!v81)
        goto LABEL_61;
      switch(v80)
      {
        case 2:
          if (strncmp(__s1, "IV", 2uLL))
            goto LABEL_54;
          if (*v17 != 48 || __tolower(v17[1]) != 120)
          {
            v11 = 4294954654;
            _StreamPlaylistLogError(4294954654, 4294955029, a8, CFSTR("No 0x at start of IV"), v63, v64);
            goto LABEL_60;
          }
          v77 = 0;
          v18 = v81 + 2;
          v19 = strcspn(v81 + 2, ",\r\n");
          strcpy(v87, "00000000000000000000000000000000");
          if (v19 >= 0x21)
          {
            v11 = 4294954654;
            _StreamPlaylistLogError(4294954654, 4294955029, a8, CFSTR("IV too long"), v63, v64, v65);
            goto LABEL_157;
          }
          memcpy(&v87[-v19 + 32], v18, v19);
          v20 = sp_strtoull(&v87[16], 0, &v77, 16, 1, 0, (uint64_t)"IV lower", a8);
          if ((_DWORD)v20
            || (v21 = v77, v87[16] = 0,
                           v20 = sp_strtoull(v87, 0, &v77, 16, 1, 0, (uint64_t)"IV upper", a8),
                           (_DWORD)v20))
          {
            v11 = v20;
            goto LABEL_157;
          }
          *(_QWORD *)bytes = bswap64(v77);
          v89 = bswap64(v21);
          if (cf)
            CFRelease(cf);
          cf = CFDataCreate(allocator, bytes, 16);
          goto LABEL_37;
        case 3:
          if (strncmp(__s1, "URI", 3uLL))
            goto LABEL_54;
          if ((v16 & 1) == 0)
            goto LABEL_58;
          if (v76)
          {
            _StreamPlaylistLogError(0, 4294955035, a8, CFSTR("%s has multiple %s params. Ignoring old one."), a3, "URI");
            CFRelease(v76);
            v17 = v81;
          }
          v76 = CFURLCreateWithBytes(allocator, (const UInt8 *)v17, numBytes, 0x8000100u, *(CFURLRef *)(a8 + 16));
          if (v76)
            goto LABEL_55;
          v11 = 4294954654;
          _StreamPlaylistLogError(4294954654, 4294955034, a8, CFSTR("Invalid %s: %s"), a3, "URI");
          v76 = 0;
          goto LABEL_60;
        case 4:
        case 5:
        case 7:
        case 8:
          goto LABEL_54;
        case 6:
          if (strncmp(__s1, "METHOD", 6uLL))
            goto LABEL_54;
          if (strncmp(v17, "NONE", 4uLL))
            goto LABEL_49;
          v28 = v17[4];
          if ((v28 & 0x80000000) != 0)
          {
            if (__maskrune(v28, 0x500uLL))
            {
LABEL_48:
              v17 = v81;
              if (v81)
              {
LABEL_49:
                if (strncmp(v17, "AES-128", 7uLL))
                  goto LABEL_75;
                v29 = v17[7];
                if ((v29 & 0x80000000) != 0)
                {
                  if (!__maskrune(v29, 0x500uLL))
                  {
LABEL_88:
                    v40 = 3;
LABEL_96:
                    v73 = v40;
                    goto LABEL_97;
                  }
                }
                else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v29 + 60) & 0x500) == 0)
                {
                  goto LABEL_88;
                }
              }
              else
              {
                FigSignalErrorAt();
              }
              v17 = v81;
              if (!v81)
              {
                FigSignalErrorAt();
                goto LABEL_76;
              }
LABEL_75:
              if (strncmp(v17, "SAMPLE-AES", 0xAuLL))
                goto LABEL_76;
              v38 = v17[10];
              if ((v38 & 0x80000000) != 0)
              {
                if (!__maskrune(v38, 0x500uLL))
                {
LABEL_90:
                  v35 = 1;
                  goto LABEL_104;
                }
              }
              else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v38 + 60) & 0x500) == 0)
              {
                goto LABEL_90;
              }
LABEL_76:
              v36 = v81;
              if (v81)
              {
                if (strncmp(v81, "ISO-23001-7", 0xBuLL))
                {
LABEL_78:
                  if (strncmp(v36, "SAMPLE-AES-CTR", 0xEuLL))
                    goto LABEL_94;
                  v37 = v36[14];
                  if ((v37 & 0x80000000) == 0)
                  {
                    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v37 + 60) & 0x500) == 0)
                      goto LABEL_103;
LABEL_94:
                    if (!StreamingPlaylist_MatchAlphanumericStringExactly(v81, "AES-256-GCM", 0xBuLL, (const char **)&v81))
                    {
                      v11 = 4294954654;
                      _StreamPlaylistLogError(4294954654, 4294955036, a8, CFSTR("Unrecognized %s: %s"), a3, "METHOD");
                      goto LABEL_60;
                    }
                    v40 = 4;
                    goto LABEL_96;
                  }
                  if (__maskrune(v37, 0x500uLL))
                    goto LABEL_94;
LABEL_103:
                  v35 = 2;
                  goto LABEL_104;
                }
                v39 = v36[11];
                if ((v39 & 0x80000000) != 0)
                {
                  if (!__maskrune(v39, 0x500uLL))
                    goto LABEL_103;
                }
                else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v39 + 60) & 0x500) == 0)
                {
                  goto LABEL_103;
                }
              }
              else
              {
                FigSignalErrorAt();
              }
              v36 = v81;
              if (!v81)
              {
                FigSignalErrorAt();
                goto LABEL_94;
              }
              goto LABEL_78;
            }
          }
          else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v28 + 60) & 0x500) != 0)
          {
            goto LABEL_48;
          }
          v35 = 5;
LABEL_104:
          v73 = v35;
LABEL_55:
          if ((_DWORD)v11)
            goto LABEL_60;
          goto LABEL_61;
        case 9:
          if (strncmp(__s1, "KEYFORMAT", 9uLL))
            goto LABEL_54;
          if ((v16 & 1) == 0)
            goto LABEL_58;
          v30 = numBytes;
          if (numBytes == 8)
          {
            if (!strncmp(v17, "identity", 8uLL))
            {
LABEL_97:
              v34 = 2;
              goto LABEL_98;
            }
          }
          else
          {
            if (numBytes == 16)
            {
              v31 = v17;
              v32 = "com.apple.pastis";
              v33 = 16;
            }
            else
            {
              if (numBytes != 30)
                goto LABEL_155;
              v31 = v17;
              v32 = "com.apple.streamingkeydelivery";
              v33 = 30;
            }
            if (!strncmp(v31, v32, v33))
            {
              v34 = 1;
LABEL_98:
              v75 = v34;
              goto LABEL_55;
            }
          }
LABEL_155:
          if (*(_BYTE *)(a8 + 40) == 1)
            _StreamPlaylistLogError(0, 4294955032, a8, CFSTR("%s: invalid KEYFORMAT \"%.*s\""), a3, v30, v17);
LABEL_157:
          v44 = 0;
          v46 = a7;
          v45 = v72;
          v47 = cf;
          v43 = v76;
          goto LABEL_158;
        default:
          if (v80 != 17 || strncmp(__s1, "KEYFORMATVERSIONS", 0x11uLL))
          {
LABEL_54:
            _StreamPlaylistLogError(0, 4294955022, a8, CFSTR("Unrecognized attribute in %s"), a3);
            goto LABEL_55;
          }
          if ((v16 & 1) == 0)
          {
LABEL_58:
            v11 = 4294954654;
            _StreamPlaylistLogError(4294954654, 4294955032, a8, CFSTR("%s: missing quotes"), a3, v64);
            goto LABEL_60;
          }
          v22 = numBytes;
          if (!numBytes)
          {
LABEL_33:
            if ((_DWORD)v11)
              goto LABEL_60;
            if (v72)
            {
              CFRelease(v72);
              v17 = v81;
              v22 = numBytes;
            }
            v72 = CFStringCreateWithBytes(allocator, (const UInt8 *)v17, v22, 0x8000100u, 1u);
LABEL_37:
            v11 = 0;
            goto LABEL_61;
          }
          v23 = 0;
          v24 = v17;
          v25 = numBytes;
          while (2)
          {
            v27 = *v24++;
            v26 = v27;
            if (v27 - 48 < 0xA)
            {
              v23 = 1;
              goto LABEL_32;
            }
            if ((_DWORD)v26 != 47)
            {
              v11 = 4294954654;
              _StreamPlaylistLogError(4294954654, 4294955030, a8, CFSTR("illegal character \"%c\" in %s"), v26, "KEYFORMATVERSIONS");
              goto LABEL_60;
            }
            if (v23)
            {
              v23 = 0;
LABEL_32:
              if (!--v25)
                goto LABEL_33;
              continue;
            }
            break;
          }
          v11 = 4294954654;
          _StreamPlaylistLogError(4294954654, 4294955030, a8, CFSTR("illegal \"/\" character in %s"), "KEYFORMATVERSIONS", v64);
LABEL_60:
          if (!*(_BYTE *)(a8 + 41))
            goto LABEL_157;
LABEL_61:
          v9 = v86;
          continue;
      }
    }
    break;
  }
  if (v75)
    v41 = 1;
  else
    v41 = (v73 - 1) >= 2;
  if (v41)
    v42 = v75;
  else
    v42 = 2;
  v43 = v76;
  if (v73 == 5 && v76)
  {
    v11 = 4294954654;
    _StreamPlaylistLogError(4294954654, 4294955032, a8, CFSTR("URL in crypt Key with no algorithm"));
    v44 = 0;
    v46 = a7;
    v45 = v72;
    v47 = cf;
    goto LABEL_158;
  }
  v45 = v72;
  v47 = cf;
  if (v73 != 5 && !v76)
  {
    v11 = 4294954654;
    _StreamPlaylistLogError(4294954654, 4294955032, a8, CFSTR("Missing URL in crypt Key"));
LABEL_123:
    v44 = 0;
LABEL_124:
    v46 = a7;
    goto LABEL_158;
  }
  if (v73 == 2 && cf)
  {
    CFRelease(cf);
    v11 = 4294954654;
    _StreamPlaylistLogError(4294954654, 4294955032, a8, CFSTR("IV not allowed for KEY/METHOD"));
    v47 = 0;
    goto LABEL_123;
  }
  if ((_DWORD)v11)
    goto LABEL_123;
  if (v42 == 1 && !v72)
    v45 = CFStringCreateWithCString(allocator, "1", 0x8000100u);
  if (v76)
    v44 = FigCFHTTPCreateURLString(v76);
  else
    v44 = 0;
  if (v73 != 5)
  {
    if (v73)
    {
      if (a1)
        ContentKeySpecifiers = FigMultivariantPlaylistGetContentKeySpecifiers(a1);
      else
        ContentKeySpecifiers = FigMediaPlaylistGetContentKeySpecifiers(a2);
      v49 = (const __CFArray *)ContentKeySpecifiers;
      v50 = 0;
      if (ContentKeySpecifiers)
        goto LABEL_150;
LABEL_151:
      for (i = 0; ; i = CFArrayGetCount(v49))
      {
        if (v50 >= i)
        {
          v43 = v76;
          if (v83)
            goto LABEL_182;
          goto LABEL_175;
        }
        ValueAtIndex = CFArrayGetValueAtIndex(v49, v50);
        FigContentKeySpecifierGetIdentifier((uint64_t)ValueAtIndex);
        if (FigCFEqual())
        {
          if (FigContentKeySpecifierGetKeySystem((uint64_t)ValueAtIndex) == v42
            && FigContentKeySpecifierGetEncryptionMethod((uint64_t)ValueAtIndex) == v73)
          {
            break;
          }
        }
        ++v50;
        if (!v49)
          goto LABEL_151;
LABEL_150:
        ;
      }
      if (ValueAtIndex)
        v54 = CFRetain(ValueAtIndex);
      else
        v54 = 0;
      v43 = v76;
      v83 = v54;
      if (v54)
        goto LABEL_182;
LABEL_175:
      v55 = FigStreamPlaylistParseStringAndCreateProtocolVersionList(v45, &v84);
      if ((_DWORD)v55 || (v55 = FigContentKeySpecifierCreate(v42, v44, v73, v84, (uint64_t *)&v83), (_DWORD)v55))
      {
        v11 = v55;
        goto LABEL_124;
      }
      v56 = a2;
      if (a2)
      {
        CryptKeyCount = FigMediaPlaylistGetCryptKeyCount(a2);
        FigMediaPlaylistSetCryptKeyCount(a2, CryptKeyCount + 1);
        v58 = v83;
        v59 = FigMediaPlaylistGetCryptKeyCount(a2);
        v56 = a2;
        FigContentKeySpecifierSetCryptKeyParsedIndex((uint64_t)v58, v59);
      }
      FigContentKeySpecifierSetIsChangedInCurrent((uint64_t)v83, 1);
      if (a1)
        FigMultivariantPlaylistAddContentKeySpecifier(a1, v83);
      else
        FigMediaPlaylistAddContentKeySpecifier(v56, v83);
LABEL_182:
      v60 = *a5;
      *a5 = cf;
      if (cf)
        CFRetain(cf);
      if (v60)
        CFRelease(v60);
      v61 = *a6;
      v62 = v83;
      *a6 = v83;
      if (v62)
        CFRetain(v62);
      if (v61)
        CFRelease(v61);
    }
    else if (*a6)
    {
      CFRelease(*a6);
      v11 = 0;
      *a6 = 0;
      goto LABEL_124;
    }
    v11 = 0;
    goto LABEL_124;
  }
  v46 = a7;
  if (*a6)
  {
    CFRelease(*a6);
    *a6 = 0;
  }
  if (*a5)
  {
    CFRelease(*a5);
    v11 = 0;
    *a5 = 0;
  }
  else
  {
    v11 = 0;
  }
LABEL_158:
  *v46 = v86;
  if (v83)
    CFRelease(v83);
  if (v44)
    CFRelease(v44);
  if (v84)
    CFRelease(v84);
  if (v47)
    CFRelease(v47);
  if (v43)
    CFRelease(v43);
  if (v45)
    CFRelease(v45);
  free(v85);
  return v11;
}

const char *StreamingPlaylist_SkipSpacesAndTabs(const char *a1, uint64_t a2)
{
  size_t v4;

  v4 = strspn(a1, " \t");
  if (v4)
    _StreamPlaylistLogError(0, 4294955032, a2, CFSTR("Unneeded space in line"));
  return &a1[v4];
}

uint64_t sp_ParseAttribute(const char *a1, char *a2, int a3, int a4, char **a5, _QWORD *a6, const char **a7, size_t *a8, const char **a9, int *a10, UInt8 **a11, uint64_t a12)
{
  int *v13;
  const char **v14;
  char *v21;
  _BOOL4 matched;
  uint64_t v23;
  char *v24;
  const char *v25;
  char *v26;
  int v27;
  uint64_t StringWithReplacement;
  uint64_t v29;
  size_t v30;
  char *v31;
  int v32;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v34;
  unsigned int v35;
  int *v36;
  char *v37;
  size_t v38;
  const __CFString *v39;
  const char *v40;
  int v41;
  int v42;
  BOOL v43;
  const __CFString *v45;
  const char *v46;
  uint64_t v47;
  char *v48;
  int v49;
  int v50;
  char *__s1;
  size_t v52;
  uint64_t v53;
  os_log_type_t type;
  unsigned int v55;
  int v56;
  const char *v57;
  __int16 v58;
  const char *v59;
  uint64_t v60;

  v14 = a9;
  v13 = a10;
  v60 = *MEMORY[0x1E0C80C00];
  v52 = 0;
  v53 = 0;
  __s1 = a2;
  if (!a2)
  {
    v29 = 4294954656;
    _StreamPlaylistLogError(4294954656, 4294955032, a12, CFSTR("%s: no attributes"), a1);
    v27 = 0;
    goto LABEL_28;
  }
  *a5 = 0;
  *a6 = 0;
  *a7 = 0;
  *a8 = 0;
  *a10 = 0;
  *a11 = 0;
  v21 = (char *)sp_SkipSpacesTabsAndCommas(a2, a12, 0);
  __s1 = v21;
  if (*v21 == 61)
  {
    v45 = CFSTR("%s: Missing or blank attribute");
    v46 = a1;
LABEL_48:
    v29 = 4294954654;
    _StreamPlaylistLogError(4294954654, 4294955032, a12, v45, v46, v47);
    v27 = 0;
    v14 = a9;
LABEL_28:
    v31 = __s1;
    if (!*(_BYTE *)(a12 + 41))
    {
      v40 = &v31[strcspn(__s1, "\r\n")];
      v31 = (char *)&v40[strspn(v40, "\r\n")];
    }
    goto LABEL_44;
  }
  v50 = a3;
  matched = sp_MatchAttributeName((uint64_t)v21, 0, &__s1, &v53);
  v23 = v53;
  if (!matched)
  {
    v27 = 0;
    v14 = a9;
    v25 = a1;
    goto LABEL_13;
  }
  v49 = a4;
  v24 = __s1;
  *a5 = __s1;
  *a6 = v23;
  v25 = a1;
  if (strncmp(v24, "REQ-", 4uLL))
  {
LABEL_5:
    v26 = (char *)StreamingPlaylist_SkipSpacesAndTabs(&v24[v23], a12);
    __s1 = v26;
    if (*v26 == 61)
    {
      __s1 = (char *)StreamingPlaylist_SkipSpacesAndTabs(v26 + 1, a12);
      v27 = *__s1 == 34;
      StringWithReplacement = sp_GetStringWithReplacement(__s1, 1, v50, &__s1, a7, &v52, a11, a12);
      if ((_DWORD)StringWithReplacement == -16239)
      {
        v36 = v13;
        v37 = __s1;
        v38 = strcspn(__s1, " \t,\r\n");
        if (v38)
        {
          *a7 = v37;
          *a8 = v38;
          __s1 = (char *)StreamingPlaylist_SkipSpacesAndTabs(&v37[v38], a12);
        }
        v13 = v36;
        v14 = a9;
        if (!v23)
          goto LABEL_26;
LABEL_14:
        if (*a5)
        {
          if (*a7)
          {
            v29 = 0;
            v31 = __s1;
            goto LABEL_44;
          }
          v47 = v23;
          v48 = *a5;
          v39 = CFSTR("%s: %.*s: Empty or blank attribute value");
          goto LABEL_27;
        }
LABEL_26:
        v39 = CFSTR("%s: Illegal attribute name");
LABEL_27:
        v29 = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955032, a12, v39, v25, v47, v48);
        goto LABEL_28;
      }
      v29 = StringWithReplacement;
      v14 = a9;
      if ((_DWORD)StringWithReplacement)
        goto LABEL_28;
      v30 = v52;
      *a8 = v52;
      if (v49 && !v30)
      {
        *a7 = __s1;
        if (!v23)
          goto LABEL_26;
        goto LABEL_14;
      }
LABEL_13:
      if (!v23)
        goto LABEL_26;
      goto LABEL_14;
    }
    v45 = CFSTR("%s: missing \"=\"");
    v46 = v25;
    goto LABEL_48;
  }
  v32 = *(_DWORD *)a12;
  if (!*(_DWORD *)a12)
  {
    v55 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
    v34 = v55;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v35 = v34;
    else
      v35 = v34 & 0xFFFFFFFE;
    if (v35)
    {
      v56 = 136315394;
      v57 = "sp_ParseForUnknownREQPrefixAttribute";
      v58 = 2080;
      v59 = a1;
      LODWORD(v47) = 22;
      _os_log_send_and_compose_impl();
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose();
    v25 = a1;
  }
  if (strncasecmp(v25, "#EXT-X-STREAM-INF", 0x11uLL))
  {
    if (v23 != 16)
      goto LABEL_40;
LABEL_37:
    v42 = strncmp(v24, "REQ-VIDEO-LAYOUT", 0x10uLL);
    v43 = v32 < 12;
    v13 = a10;
    if (v43 || !v42)
      goto LABEL_5;
    goto LABEL_41;
  }
  v41 = strncasecmp(v25, "#EXT-X-I-FRAME-STREAM-INF", 0x19uLL);
  if (v23 == 16 && v41)
    goto LABEL_37;
LABEL_40:
  v43 = v32 < 12;
  v13 = a10;
  if (v43)
    goto LABEL_5;
LABEL_41:
  if (*(_QWORD *)(a12 + 32))
    FigIsItOKToLogURLs();
  v29 = 0;
  v31 = &v24[strcspn(v24, "\r\n")];
  v27 = 2;
  v14 = a9;
LABEL_44:
  *v14 = sp_SkipSpacesTabsAndCommas(v31, a12, 1);
  *v13 = v27;
  return v29;
}

uint64_t sp_strtoll(const char *a1, char **a2, uint64_t *a3, int a4, uint64_t a5, uint64_t a6)
{
  const __CFString *v12;
  char *v13;
  char *v14;
  unsigned int v15;
  uint64_t v16;
  char v17;
  uint64_t v19;
  uint64_t v20;
  char *__endptr;

  __endptr = 0;
  *__error() = 0;
  *a3 = strtoll(a1, &__endptr, 10);
  if (*__error() == 22)
  {
    v12 = CFSTR("%s:Illegal integer conversion");
LABEL_18:
    v19 = a5;
    v16 = 4294954654;
    _StreamPlaylistLogError(4294954654, 4294955032, a6, v12, v19);
    goto LABEL_19;
  }
  if (*__error() == 34)
  {
    v12 = CFSTR("%s:out of range");
    goto LABEL_18;
  }
  if (*a3 < 0)
  {
    v12 = CFSTR("%s:Decimal value less than 0");
    goto LABEL_18;
  }
  v13 = __endptr;
  v14 = (char *)(__endptr - a1);
  if (__endptr > a1)
  {
    v12 = CFSTR("%s:Illegal character before integer");
    while ((*a1 - 48) < 0xA)
    {
      ++a1;
      if (!--v14)
        goto LABEL_10;
    }
    goto LABEL_18;
  }
LABEL_10:
  if (a4 != 1 || (v15 = *__endptr, v15 <= 0x2C) && ((1 << v15) & 0x100000002400) != 0)
  {
    v16 = 0;
    v17 = 1;
    if (!a2)
      goto LABEL_15;
    goto LABEL_14;
  }
  v20 = a5;
  v16 = 4294954654;
  _StreamPlaylistLogError(4294954654, 4294955032, a6, CFSTR("%s:Illegal characters after integer"), v20);
  v17 = 0;
  if (a2)
LABEL_14:
    *a2 = v13;
LABEL_15:
  if ((v17 & 1) == 0)
  {
LABEL_19:
    *a3 = 0;
    return v16;
  }
  return 0;
}

uint64_t StreamingPlaylist_FindResolution(const char *a1, int *a2, int *a3, _QWORD *a4, uint64_t a5)
{
  int v9;
  int v10;
  int v11;
  uint64_t result;
  char *v13;
  int v14;

  v14 = 0;
  v13 = 0;
  if (sp_strtol(a1, &v13, &v14, 0, (uint64_t)"horizontal resolution", a5))
  {
    v9 = -1;
    goto LABEL_10;
  }
  v9 = v14;
  if (!v13 || *v13 != 120)
  {
    _StreamPlaylistLogError(4294954654, 4294955032, a5, CFSTR("No resolution separator"));
LABEL_10:
    v11 = -1;
    if (!a4)
      goto LABEL_12;
    goto LABEL_11;
  }
  ++v13;
  v13 = (char *)StreamingPlaylist_SkipSpacesAndTabs(v13, a5);
  v10 = sp_strtol(v13, &v13, &v14, 1, (uint64_t)"vertical resolution", a5);
  v11 = v14;
  if (v10)
    v11 = -1;
  if (a4)
LABEL_11:
    *a4 = v13;
LABEL_12:
  result = 0;
  if ((v9 & 0x80000000) == 0 && (v11 & 0x80000000) == 0)
  {
    *a2 = v9;
    *a3 = v11;
    return 1;
  }
  return result;
}

uint64_t PlaylistExtractallowedCPCForFairPlayStreaming(char *a1, size_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v6;
  CFArrayRef v7;
  CFIndex v8;
  CFIndex v9;
  const char *CStringPtrAndBufferToFree;
  const char *v11;
  size_t v12;
  const __CFArray *v13;
  uint64_t v14;
  int v16[2];
  CFArrayRef v17;
  CFArrayRef theArray;

  v17 = 0;
  theArray = 0;
  *(_QWORD *)v16 = 0;
  v6 = PlaylistTokenizeString(a1, a2, a3, 0x2Cu, &theArray);
  v7 = theArray;
  if ((_DWORD)v6)
  {
LABEL_15:
    v14 = v6;
    if (v7)
LABEL_16:
      CFRelease(v7);
  }
  else
  {
    v8 = 0;
    while (1)
    {
      v9 = v7 ? CFArrayGetCount(v7) : 0;
      if (v8 >= v9)
        break;
      CFArrayGetValueAtIndex(v7, v8);
      CStringPtrAndBufferToFree = (const char *)FigCFStringGetCStringPtrAndBufferToFree();
      v11 = sp_SkipSpacesTabsAndCommas(CStringPtrAndBufferToFree, a3, 0);
      ++v8;
      if (sp_MatchTagAndColon(v11, "com.apple.streamingkeydelivery", 0x1EuLL, (const char **)v16, a3))
      {
        *(_QWORD *)v16 = sp_SkipSpacesTabsAndCommas(*(const char **)v16, a3, 0);
        v12 = strlen(*(const char **)v16);
        v6 = PlaylistTokenizeString(*(char **)v16, v12, a3, 0x2Fu, &v17);
        if (!(_DWORD)v6)
        {
          v13 = v17;
          if (v17 && CFArrayGetCount(v17) > 0)
            v6 = PKDGetCPCBitfieldFromLabels(v13, a4);
          else
            v6 = FigSignalErrorAt();
        }
        goto LABEL_15;
      }
    }
    v14 = 0;
    if (v7)
      goto LABEL_16;
  }
  if (v17)
    CFRelease(v17);
  free(0);
  return v14;
}

const void *StreamingPlaylistCreateMediaURLWithBytes(UInt8 *URLBytes, CFIndex length, CFURLRef baseURL, const __CFURL *a4, CFURLRef *a5, _QWORD *a6)
{
  const __CFAllocator *v11;
  const void *result;

  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *a5 = CFURLCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], URLBytes, length, 0x8000100u, baseURL);
  if (FigCFEqual())
  {
    result = *a5;
    if (*a5)
      result = CFRetain(result);
  }
  else
  {
    result = CFURLCreateWithBytes(v11, URLBytes, length, 0x8000100u, a4);
  }
  *a6 = result;
  return result;
}

uint64_t PlaylistExtractVideoImmersiveAttribute(char *a1, size_t a2, uint64_t a3, __CFArray **a4)
{
  uint64_t v6;
  __CFArray *Mutable;
  const __CFArray *v8;
  CFIndex v9;
  CFIndex i;
  const __CFString *ValueAtIndex;
  char *CStringPtrAndBufferToFree;
  size_t Length;
  uint64_t v14;
  const __CFArray *v15;
  const __CFString *v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  int v20;
  __int128 *v21;
  const __CFString *v22;
  uint64_t v23;
  const char *v24;
  int v25;
  __int128 *v26;
  const __CFString *v27;
  uint64_t v28;
  const char *v29;
  int v30;
  __int128 *v31;
  int Count;
  uint64_t v33;
  __CFArray **v35;
  CFArrayRef theArray;
  void *v37;
  __int128 v38;
  CFArrayRef v39;
  void *v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  theArray = 0;
  v42 = 0u;
  v43 = 0u;
  v41 = 0u;
  v6 = PlaylistTokenizeString(a1, a2, a3, 0x2Cu, &theArray);
  if ((_DWORD)v6)
  {
    v19 = v6;
    Mutable = 0;
    v8 = theArray;
    goto LABEL_63;
  }
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v8 = theArray;
  if (!Mutable)
  {
LABEL_62:
    v19 = 0;
    goto LABEL_63;
  }
  v35 = a4;
  v9 = 0;
  if (!theArray)
    goto LABEL_5;
LABEL_4:
  for (i = CFArrayGetCount(v8); v9 < i; i = 0)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v8, v9);
    v39 = 0;
    v37 = 0;
    v38 = 0uLL;
    CStringPtrAndBufferToFree = (char *)FigCFStringGetCStringPtrAndBufferToFree();
    Length = CFStringGetLength(ValueAtIndex);
    v14 = PlaylistTokenizeString(CStringPtrAndBufferToFree, Length, a3, 0x2Fu, &v39);
    v15 = v39;
    if ((_DWORD)v14)
    {
      v19 = v14;
      if (!v39)
      {
LABEL_59:
        free(v37);
        goto LABEL_63;
      }
    }
    else
    {
      if (v39 && CFArrayGetCount(v39) > 2)
      {
        v16 = (const __CFString *)CFArrayGetValueAtIndex(v15, 0);
        v40 = 0;
        v17 = FigCFStringGetCStringPtrAndBufferToFree();
        if (v16 && (v18 = (const char *)v17, CFStringGetLength(v16)))
        {
          if (!strncasecmp(v18, "NONE", 4uLL))
          {
            v19 = 0;
            v21 = (__int128 *)MEMORY[0x1E0CA5230];
          }
          else if (!strncasecmp(v18, "SIDE", 4uLL))
          {
            v19 = 0;
            v21 = (__int128 *)MEMORY[0x1E0CA5240];
          }
          else
          {
            if (strncasecmp(v18, "OVER", 4uLL))
            {
              v19 = 4294954654;
              _StreamPlaylistLogError(4294954654, 4294949659, a3, CFSTR("Invalid packing value in VIDEO-IMMERSIVE"));
              goto LABEL_17;
            }
            v19 = 0;
            v21 = (__int128 *)MEMORY[0x1E0CA5238];
          }
          v38 = *v21;
          v20 = 1;
        }
        else
        {
          v19 = 4294954654;
          _StreamPlaylistLogError(4294954654, 4294949659, a3, CFSTR("Missing packing value in VIDEO-IMMERSIVE"));
LABEL_17:
          v20 = 0;
        }
        free(v40);
        v41 = v38;
        if (!v20)
          goto LABEL_54;
        v22 = (const __CFString *)CFArrayGetValueAtIndex(v15, 1);
        v40 = 0;
        v23 = FigCFStringGetCStringPtrAndBufferToFree();
        if (v22 && (v24 = (const char *)v23, CFStringGetLength(v22)))
        {
          if (!strncasecmp(v24, "LR", 2uLL))
          {
            v19 = 0;
            v26 = (__int128 *)MEMORY[0x1E0CA5278];
          }
          else if (!strncasecmp(v24, "L", 1uLL))
          {
            v19 = 0;
            v26 = (__int128 *)MEMORY[0x1E0CA5280];
          }
          else if (!strncasecmp(v24, "R", 1uLL))
          {
            v19 = 0;
            v26 = (__int128 *)MEMORY[0x1E0CA5290];
          }
          else
          {
            if (strncasecmp(v24, "M", 1uLL))
            {
              v19 = 4294954654;
              _StreamPlaylistLogError(4294954654, 4294949659, a3, CFSTR("Invalid channels value in VIDEO-IMMERSIVE"));
              goto LABEL_33;
            }
            v19 = 0;
            v26 = (__int128 *)MEMORY[0x1E0CA5288];
          }
          v38 = *v26;
          v25 = 1;
        }
        else
        {
          v19 = 4294954654;
          _StreamPlaylistLogError(4294954654, 4294949659, a3, CFSTR("Missing channels value in VIDEO-IMMERSIVE"));
LABEL_33:
          v25 = 0;
        }
        free(v40);
        v42 = v38;
        if (!v25)
          goto LABEL_54;
        v27 = (const __CFString *)CFArrayGetValueAtIndex(v15, 2);
        v40 = 0;
        v28 = FigCFStringGetCStringPtrAndBufferToFree();
        if (v27 && (v29 = (const char *)v28, CFStringGetLength(v27)))
        {
          if (!strncasecmp(v29, "FISH", 4uLL))
          {
            v19 = 0;
            v31 = (__int128 *)MEMORY[0x1E0CA5250];
          }
          else
          {
            if (strncasecmp(v29, "RECT", 4uLL))
            {
              v19 = 4294954654;
              _StreamPlaylistLogError(4294954654, 4294949659, a3, CFSTR("Invalid projection value in VIDEO-IMMERSIVE"));
              goto LABEL_46;
            }
            v19 = 0;
            v31 = (__int128 *)MEMORY[0x1E0CA5260];
          }
          v38 = *v31;
          v30 = 1;
        }
        else
        {
          v19 = 4294954654;
          _StreamPlaylistLogError(4294954654, 4294949659, a3, CFSTR("Missing projection value in VIDEO-IMMERSIVE"));
LABEL_46:
          v30 = 0;
        }
        free(v40);
        v43 = v38;
        if (v30)
        {
          if (CFArrayGetCount(v15) >= 4)
          {
            Count = CFArrayGetCount(v15);
            _StreamPlaylistLogError(0, 4294949659, a3, CFSTR("Unexpected values in VIDEO-IMMERSIVE ignored %d"), (Count - 3));
          }
          v19 = 0;
        }
        goto LABEL_54;
      }
      v19 = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294949659, a3, CFSTR("Unexpected number of tags in VIDEO-IMMERSIVE"));
      if (!v15)
        goto LABEL_59;
    }
LABEL_54:
    CFRelease(v15);
    free(v37);
    if ((_DWORD)v19)
      goto LABEL_63;
    v33 = FigTagCollectionCreate();
    if ((_DWORD)v33)
    {
      v19 = v33;
      goto LABEL_63;
    }
    CFArrayAppendValue(Mutable, 0);
    ++v9;
    if (v8)
      goto LABEL_4;
LABEL_5:
    ;
  }
  if (!v35)
    goto LABEL_62;
  v19 = 0;
  *v35 = Mutable;
  Mutable = 0;
LABEL_63:
  if (v8)
    CFRelease(v8);
  if (Mutable)
    CFRelease(Mutable);
  return v19;
}

uint64_t PlaylistExtractVideoLayoutAttribute(char *a1, size_t a2, uint64_t a3, __CFArray **a4)
{
  uint64_t v6;
  CFMutableArrayRef Mutable;
  __CFArray *v8;
  const __CFArray *v9;
  CFIndex v10;
  CFIndex Count;
  const __CFString *ValueAtIndex;
  char *CStringPtrAndBufferToFree;
  size_t Length;
  uint64_t v15;
  const __CFArray *v16;
  CFIndex v17;
  int v18;
  int v19;
  int v20;
  const __CFString *v21;
  uint64_t v22;
  const char *v23;
  __int128 v24;
  __int128 v25;
  __int128 *v26;
  __int128 v27;
  const __CFString *v28;
  uint64_t v29;
  uint64_t v30;
  __CFArray **v32;
  __CFArray *v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  CFArrayRef theArray;
  void *v38;
  CFArrayRef v39;
  void *v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  theArray = 0;
  v42 = 0u;
  v43 = 0u;
  v41 = 0u;
  v6 = PlaylistTokenizeString(a1, a2, a3, 0x2Cu, &theArray);
  if ((_DWORD)v6)
  {
    v30 = v6;
    v8 = 0;
    v9 = theArray;
    goto LABEL_60;
  }
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v8 = Mutable;
  v9 = theArray;
  if (!Mutable)
  {
LABEL_59:
    v30 = 0;
    goto LABEL_60;
  }
  v32 = a4;
  v10 = 0;
  v33 = Mutable;
  if (!theArray)
    goto LABEL_5;
  while (2)
  {
    Count = CFArrayGetCount(v9);
LABEL_6:
    if (v10 >= Count)
    {
      if (v32)
      {
        v30 = 0;
        *v32 = v8;
        v8 = 0;
        break;
      }
      goto LABEL_59;
    }
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v9, v10);
    v38 = 0;
    v39 = 0;
    CStringPtrAndBufferToFree = (char *)FigCFStringGetCStringPtrAndBufferToFree();
    Length = CFStringGetLength(ValueAtIndex);
    v15 = PlaylistTokenizeString(CStringPtrAndBufferToFree, Length, a3, 0x2Fu, &v39);
    v16 = v39;
    if ((_DWORD)v15)
    {
      v30 = v15;
      if (v39)
        goto LABEL_48;
      goto LABEL_49;
    }
    if (!v39 || !CFArrayGetCount(v39))
    {
      v30 = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294949659, a3, CFSTR("No valid tags in VIDEO-LAYOUT"));
      if (v16)
        goto LABEL_48;
      goto LABEL_49;
    }
    v36 = *MEMORY[0x1E0CA5230];
    v41 = *MEMORY[0x1E0CA5230];
    v35 = *MEMORY[0x1E0CA5260];
    v43 = *MEMORY[0x1E0CA5260];
    v34 = *MEMORY[0x1E0CA5288];
    v42 = *MEMORY[0x1E0CA5288];
    if (CFArrayGetCount(v16) < 1)
    {
      v30 = 0;
      goto LABEL_48;
    }
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    while (1)
    {
      v21 = (const __CFString *)CFArrayGetValueAtIndex(v16, v17);
      v40 = 0;
      v22 = FigCFStringGetCStringPtrAndBufferToFree();
      if (!v21 || (v23 = (const char *)v22, !CFStringGetLength(v21)))
      {
        v28 = CFSTR("Invalid tag in VIDEO-LAYOUT");
        goto LABEL_46;
      }
      if (!strncasecmp(v23, "PACK-NONE", 9uLL))
      {
        if (v20)
          goto LABEL_45;
        v25 = v36;
        goto LABEL_30;
      }
      if (!strncasecmp(v23, "PACK-SIDE", 9uLL))
      {
        if (v20)
          goto LABEL_45;
        v26 = (__int128 *)MEMORY[0x1E0CA5240];
LABEL_29:
        v25 = *v26;
LABEL_30:
        v41 = v25;
        v20 = 1;
        goto LABEL_31;
      }
      if (!strncasecmp(v23, "PACK-OVER", 9uLL))
      {
        if (v20)
        {
LABEL_45:
          v28 = CFSTR("Multiple packing tags in VIDEO-LAYOUT");
          goto LABEL_46;
        }
        v26 = (__int128 *)MEMORY[0x1E0CA5238];
        goto LABEL_29;
      }
      if (!strncasecmp(v23, "PROJ-RECT", 9uLL))
      {
        if (v18)
          goto LABEL_53;
        v27 = v35;
LABEL_37:
        v43 = v27;
        v18 = 1;
        goto LABEL_31;
      }
      if (!strncasecmp(v23, "PROJ-FISH", 9uLL))
      {
        if (v18)
        {
LABEL_53:
          v28 = CFSTR("Multiple projection tags in VIDEO-LAYOUT");
          goto LABEL_46;
        }
        v27 = *MEMORY[0x1E0CA5250];
        goto LABEL_37;
      }
      if (!strncasecmp(v23, "CH-STEREO", 9uLL))
        break;
      if (!strncasecmp(v23, "CH-MONO", 7uLL))
      {
        if (v19)
          goto LABEL_54;
        v24 = v34;
        goto LABEL_40;
      }
LABEL_31:
      free(v40);
      if (++v17 >= CFArrayGetCount(v16))
      {
        v30 = 0;
        goto LABEL_47;
      }
    }
    if (!v19)
    {
      v24 = *MEMORY[0x1E0CA5278];
LABEL_40:
      v42 = v24;
      v19 = 1;
      goto LABEL_31;
    }
LABEL_54:
    v28 = CFSTR("Multiple channel tags in VIDEO-LAYOUT");
LABEL_46:
    v30 = 4294954654;
    _StreamPlaylistLogError(4294954654, 4294949659, a3, v28);
    free(v40);
LABEL_47:
    v8 = v33;
    if (v16)
LABEL_48:
      CFRelease(v16);
LABEL_49:
    free(v38);
    if (!(_DWORD)v30)
    {
      v29 = FigTagCollectionCreate();
      if (!(_DWORD)v29)
      {
        CFArrayAppendValue(v8, 0);
        ++v10;
        if (v9)
          continue;
LABEL_5:
        Count = 0;
        goto LABEL_6;
      }
      v30 = v29;
    }
    break;
  }
LABEL_60:
  if (v9)
    CFRelease(v9);
  if (v8)
    CFRelease(v8);
  return v30;
}

uint64_t PlaylistProcessAlternate(uint64_t a1, const void *PlaylistAlternateURL, void *a3, uint64_t a4, void *a5, const __CFString *a6, const __CFString *a7, uint64_t a8, double a9, double a10, void *a11, uint64_t a12, uint64_t a13, unsigned __int8 a14, int a15, int a16, uint64_t a17, int a18, int a19, uint64_t a20,uint64_t a21,uint64_t a22,_BYTE *a23,uint64_t a24)
{
  int v32;
  int v33;
  char *CStringPtrAndBufferToFree;
  size_t Length;
  CFIndex v36;
  uint64_t v37;
  __CFArray *v38;
  CFIndex i;
  const __CFString *ValueAtIndex;
  const __CFString *v41;
  void *v42;
  char *v43;
  size_t v44;
  CFIndex v45;
  const __CFArray *v46;
  CFIndex Count;
  const __CFString *v48;
  const __CFString *v49;
  double v50;
  double v51;
  uint64_t v52;
  int v53;
  const __CFArray *v54;
  int v55;
  const __CFArray *Alternates;
  const __CFArray *v57;
  CFIndex v58;
  CFIndex v59;
  CFIndex v60;
  const __CFArray *v61;
  const void *v62;
  const void *v63;
  uint64_t SubtitleGroupIDString;
  uint64_t AudioGroupIDString;
  void *v67;
  BOOL v71;
  void *v72[6];
  char v73;
  _BYTE v74[7];
  uint64_t v75;
  char v76;
  _BYTE v77[7];
  uint64_t v78;
  char v79;
  _BYTE v80[7];
  uint64_t v81;
  char v82;
  _BYTE v83[7];
  uint64_t v84;
  int v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  double v90;
  double v91;
  __int128 v92;
  __int128 v93;
  int v94;
  __int128 v95;
  __int128 v96;
  _DWORD v97[2];
  _DWORD v98[2];
  _DWORD v99[2];
  _DWORD v100[2];
  void *v101;
  __CFArray *v102;
  __CFArray *v103;
  void *v104;
  _DWORD v105[5];

  v101 = 0;
  v100[0] = 0;
  *(_DWORD *)((char *)v100 + 3) = 0;
  v99[0] = 0;
  *(_DWORD *)((char *)v99 + 3) = 0;
  v98[0] = 0;
  *(_DWORD *)((char *)v98 + 3) = 0;
  v97[0] = 0;
  *(_DWORD *)((char *)v97 + 3) = 0;
  v95 = 0u;
  v96 = 0u;
  if (!a4)
  {
    v37 = 4294954654;
    _StreamPlaylistLogError(4294954654, 4294955020, a24, CFSTR("No byte rate"));
    return v37;
  }
  v32 = a14;
  v94 = 0;
  if (!a6)
  {
    if (a7)
    {
      v37 = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294951416, a24, CFSTR("no base layer CODECS for SUPPLEMENTAL-CODECS"));
    }
    else
    {
      v37 = 0;
    }
    goto LABEL_39;
  }
  v33 = FigMediaValidatorValidateRFC4281CodecsForStreaming(a6, 0, &v94);
  if (a7)
  {
    v71 = (v33 | v94 & 2) != 0;
    v105[0] = 0;
    v72[0] = 0;
    v103 = 0;
    v104 = 0;
    v102 = 0;
    CStringPtrAndBufferToFree = (char *)FigCFStringGetCStringPtrAndBufferToFree();
    Length = CFStringGetLength(a7);
    if (PlaylistTokenizeString(CStringPtrAndBufferToFree, Length, a24, 0x2Cu, &v103))
    {
      v37 = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294951415, a24, CFSTR("illegal SUPPLEMENTAL-CODECS"));
      v38 = v103;
      if (v103)
LABEL_35:
        CFRelease(v38);
    }
    else
    {
      v67 = a5;
      v36 = 0;
      v37 = 0;
      v38 = v103;
      if (!v103)
        goto LABEL_7;
LABEL_6:
      for (i = CFArrayGetCount(v38); v36 < i; i = 0)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v38, v36);
        if (!ValueAtIndex)
        {
          v49 = CFSTR("illegal SUPPLEMENTAL-CODECS");
LABEL_33:
          v37 = 4294954654;
          _StreamPlaylistLogError(4294954654, 4294951415, a24, v49);
          break;
        }
        v41 = ValueAtIndex;
        if (v102)
        {
          CFRelease(v102);
          v102 = 0;
        }
        v42 = v104;
        if (v104)
        {
          v104 = 0;
          free(v42);
        }
        v43 = (char *)FigCFStringGetCStringPtrAndBufferToFree();
        v44 = CFStringGetLength(v41);
        v37 = PlaylistTokenizeString(v43, v44, a24, 0x2Fu, &v102);
        if (!(_DWORD)v37)
        {
          v45 = 0;
          v46 = v102;
          if (v102)
          {
LABEL_18:
            Count = CFArrayGetCount(v46);
            goto LABEL_20;
          }
          while (1)
          {
            Count = 0;
LABEL_20:
            if (v45 >= Count)
              break;
            v48 = (const __CFString *)CFArrayGetValueAtIndex(v46, v45);
            if (v45)
            {
              if (CFStringGetLength(v48) != 4)
              {
                v37 = 4294954654;
                _StreamPlaylistLogError(4294954654, 4294951414, a24, CFSTR("illegal Brand in SUPPLEMENTAL-CODECS"));
                goto LABEL_34;
              }
            }
            else if (FigMediaValidatorValidateRFC4281CodecsForStreaming(v48, 0, v105))
            {
              v49 = CFSTR("illegal CODECS member in SUPPLEMENTAL-CODECS");
              goto LABEL_33;
            }
            ++v45;
            if (v46)
              goto LABEL_18;
          }
        }
        ++v36;
        if (v38)
          goto LABEL_6;
LABEL_7:
        ;
      }
LABEL_34:
      v32 = a14;
      a5 = v67;
      if (v38)
        goto LABEL_35;
    }
    if (v102)
      CFRelease(v102);
    free(v104);
    free(v72[0]);
    if (!v71)
      goto LABEL_40;
    goto LABEL_39;
  }
  v37 = 0;
  if (v33 | v94 & 2)
LABEL_39:
    *a23 = 1;
LABEL_40:
  if (!v32)
  {
    Alternates = (const __CFArray *)FigMultivariantPlaylistGetAlternates(a1);
    if (Alternates)
    {
      if (CFArrayGetCount(Alternates) >= 1)
      {
        v57 = (const __CFArray *)FigMultivariantPlaylistGetAlternates(a1);
        if (v57)
        {
          v58 = CFArrayGetCount(v57);
          if (v58 >= 1)
          {
            v59 = v58;
            v60 = 0;
            while (1)
            {
              v61 = (const __CFArray *)FigMultivariantPlaylistGetAlternates(a1);
              v62 = CFArrayGetValueAtIndex(v61, v60);
              if (!FigAlternateIsIFrameOnly((uint64_t)v62))
                break;
              if (v59 == ++v60)
                goto LABEL_41;
            }
            if (v62)
            {
              SubtitleGroupIDString = FigAlternateGetSubtitleGroupIDString((uint64_t)v62);
              if (!a12 && SubtitleGroupIDString)
                goto LABEL_74;
              if (a12 && !SubtitleGroupIDString)
              {
                PlaylistAlternateURL = (const void *)FigAlternateGetPlaylistAlternateURL((uint64_t)v62);
LABEL_74:
                v37 = 4294954654;
                _StreamPlaylistLogError(4294954654, 4294954980, a24, CFSTR("Variant %@ is missing subtitle group"), PlaylistAlternateURL);
                return v37;
              }
              AudioGroupIDString = FigAlternateGetAudioGroupIDString((uint64_t)v62);
              if (!a8 && AudioGroupIDString)
              {
LABEL_81:
                v37 = 4294954654;
                _StreamPlaylistLogError(4294954654, 4294954982, a24, CFSTR("Variant %@ is missing audio group"), PlaylistAlternateURL);
                return v37;
              }
              if (a8 && !AudioGroupIDString)
              {
                PlaylistAlternateURL = (const void *)FigAlternateGetPlaylistAlternateURL((uint64_t)v62);
                goto LABEL_81;
              }
              if ((_DWORD)v37)
                return v37;
            }
          }
        }
      }
    }
  }
LABEL_41:
  if (a5 && (uint64_t)a5 > a4)
  {
    _StreamPlaylistLogError(0, 4294955032, a24, CFSTR("Ignoring AVERAGE-BANDWIDTH %lld as it exceeds peak BANDWIDTH %lld"), a5, a4);
    a5 = 0;
  }
  if ((a16 | a15) < 0)
    v50 = 0.0;
  else
    v50 = (double)a15;
  if ((a16 | a15) < 0)
    v51 = 0.0;
  else
    v51 = (double)a16;
  if (a10 <= 0.0)
    a10 = -1.0;
  v52 = *MEMORY[0x1E0C9AE00];
  v53 = FigAtomicIncrement32();
  v54 = (const __CFArray *)FigMultivariantPlaylistGetAlternates(a1);
  if (v54)
    v55 = CFArrayGetCount(v54);
  else
    v55 = 0;
  v72[0] = a3;
  v72[1] = a5;
  v72[2] = *(void **)&a9;
  v72[3] = *(void **)&a10;
  v72[4] = (void *)a7;
  v72[5] = a11;
  v73 = 0;
  *(_DWORD *)v74 = v100[0];
  *(_DWORD *)&v74[3] = *(_DWORD *)((char *)v100 + 3);
  v75 = a8;
  v76 = 0;
  *(_DWORD *)v77 = v99[0];
  *(_DWORD *)&v77[3] = *(_DWORD *)((char *)v99 + 3);
  v78 = a12;
  v79 = 0;
  *(_DWORD *)v80 = v98[0];
  *(_DWORD *)&v80[3] = *(_DWORD *)((char *)v98 + 3);
  v81 = a13;
  v82 = 0;
  *(_DWORD *)v83 = v97[0];
  *(_DWORD *)&v83[3] = *(_DWORD *)((char *)v97 + 3);
  v84 = a17;
  v85 = a18;
  v86 = a19;
  v87 = a20;
  v88 = a21;
  v89 = a22;
  v90 = v50;
  v91 = v51;
  v93 = v96;
  v92 = v95;
  v37 = FigAlternateCreate(v52, 0, PlaylistAlternateURL, a4, a6, a14, v53, v55, (uint64_t)v72, &v101);
  v63 = v101;
  if (!(_DWORD)v37)
  {
    FigMultivariantPlaylistAddAlternate(a1, v101);
    v63 = v101;
  }
  if (v63)
    CFRelease(v63);
  return v37;
}

uint64_t PlaylistProcessByteRange(uint64_t *a1, uint64_t *a2, _BYTE *a3, const char **a4, uint64_t a5, uint64_t a6)
{
  uint64_t result;
  char *v13;
  char *v14;

  v14 = (char *)*a4;
  *__error() = 0;
  if (a3)
    *a3 = 0;
  result = sp_strtoll(*a4, &v14, a1, 0, (uint64_t)"byte range", a6);
  if (!(_DWORD)result)
  {
    v13 = (char *)StreamingPlaylist_SkipSpacesAndTabs(v14, a6);
    v14 = v13;
    if (*v13 == 64)
    {
      v14 = (char *)(StreamingPlaylist_SkipSpacesAndTabs(v13, a6) + 1);
      result = sp_strtoll(v14, &v14, a2, a5 == 0, (uint64_t)"byte range offset", a6);
      if (a3 && !(_DWORD)result)
      {
        result = 0;
        *a3 = 1;
      }
    }
    else
    {
      result = 0;
    }
  }
  *a4 = v14;
  return result;
}

uint64_t PlaylistProcessBitRate(double *a1, const char **a2, uint64_t a3)
{
  char *v6;
  uint64_t result;
  unint64_t v8;
  char *v9;

  v6 = (char *)*a2;
  v8 = 0;
  v9 = v6;
  *__error() = 0;
  result = sp_strtoull(*a2, &v9, &v8, 10, 0, 1, (uint64_t)"BitRate", a3);
  if (!(_DWORD)result)
    *a1 = (double)v8 * 1000.0;
  *a2 = v9;
  return result;
}

uint64_t sp_MatchYesOrNo(uint64_t a1, char *a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v8;
  uint64_t v10;

  if (!strncasecmp(a2, "YES", 3uLL))
  {
    v8 = 0;
    *a4 = 1;
  }
  else if (!strncasecmp(a2, "NO", 2uLL))
  {
    v8 = 0;
    *a4 = 0;
  }
  else
  {
    v10 = a1;
    v8 = 4294954654;
    _StreamPlaylistLogError(4294954654, 4294955030, a3, CFSTR("%s must be YES or NO"), v10);
  }
  return v8;
}

uint64_t PlaylistCreateCharacteristicsArray(char *a1, size_t a2, uint64_t a3, CFMutableArrayRef *a4)
{
  uint64_t v5;
  CFArrayRef v6;
  CFMutableArrayRef MutableCopy;
  uint64_t v8;
  CFArrayRef theArray;

  theArray = 0;
  v5 = PlaylistTokenizeString(a1, a2, a3, 0x2Cu, &theArray);
  v6 = theArray;
  if ((_DWORD)v5)
  {
LABEL_7:
    v8 = v5;
    if (!v6)
      return v8;
    goto LABEL_4;
  }
  MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, theArray);
  *a4 = MutableCopy;
  if (!MutableCopy)
  {
    v5 = FigSignalErrorAt();
    goto LABEL_7;
  }
  v8 = 0;
  if (v6)
LABEL_4:
    CFRelease(v6);
  return v8;
}

uint64_t PlaylistCharacteristicsCheckFn(CFStringRef theString, int *a2)
{
  int v4;
  uint64_t result;
  __CFString **v6;
  char buffer[80];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v4 = *a2;
  if (*a2 != 1668047728)
  {
    if (v4 == 1936684398)
    {
      v6 = kFigStdAssetMediaCharacteristic_TaggedDescribesVideoForAccessibility;
LABEL_8:
      result = CFEqual(theString, *v6);
      if ((_DWORD)result)
        return result;
      goto LABEL_9;
    }
    if (v4 != 1935832172)
    {
LABEL_9:
      buffer[0] = 0;
      CFStringGetCString(theString, buffer, 80, 0x600u);
      return _StreamPlaylistLogError(0, 4294955028, *((_QWORD *)a2 + 1), CFSTR("Unrecognized characteristic tag %s"), buffer);
    }
  }
  result = CFEqual(theString, CFSTR("public.accessibility.transcribes-spoken-dialog"));
  if (!(_DWORD)result)
  {
    result = CFEqual(theString, CFSTR("public.accessibility.describes-music-and-sound"));
    if (!(_DWORD)result)
    {
      v6 = kFigStdAssetMediaCharacteristic_TaggedEasyToRead;
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t PlaylistAddCharacteristicsForClosedCaptions(CFArrayRef *a1)
{
  const __CFArray *v2;
  CFIndex Count;
  int v4;
  int v5;
  int v6;
  __CFArray *Mutable;
  CFRange v9;
  CFRange v10;

  v2 = *a1;
  if (v2)
  {
    Count = CFArrayGetCount(v2);
    v9.location = 0;
    v9.length = Count;
    v4 = CFArrayContainsValue(*a1, v9, CFSTR("public.accessibility.transcribes-spoken-dialog"));
    v10.location = 0;
    v10.length = Count;
    v5 = CFArrayContainsValue(*a1, v10, CFSTR("public.accessibility.describes-music-and-sound"));
    v6 = v5;
    if (v4)
    {
      if (v5)
        return 0;
    }
    else
    {
      CFArrayAppendValue(*a1, CFSTR("public.accessibility.transcribes-spoken-dialog"));
      if (v6)
        return 0;
    }
LABEL_7:
    CFArrayAppendValue(*a1, CFSTR("public.accessibility.describes-music-and-sound"));
    return 0;
  }
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  *a1 = Mutable;
  if (Mutable)
  {
    CFArrayAppendValue(Mutable, CFSTR("public.accessibility.transcribes-spoken-dialog"));
    goto LABEL_7;
  }
  return FigSignalErrorAt();
}

uint64_t PlaylistAddMediaGroup(uint64_t a1, int a2, void *a3, const __CFString *a4, const void *a5, const void *a6, const void *a7, const void *a8, double a9, char a10, char a11, char a12, char a13, const void *a14, CFStringRef localeIdentifier, const __CFString *a16, void *a17, int a18, _QWORD *valuePtr)
{
  void *CFStringForOSTypeValue;
  const __CFArray *MediaSelectionArray;
  const __CFArray *MediaSelectionOptionArrayByMediaType;
  const __CFAllocator *v26;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v28;
  CFMutableArrayRef v29;
  __CFString **v30;
  CFIndex v31;
  uint64_t v32;
  __CFString **v33;
  CFDictionaryRef v34;
  uint64_t v35;
  const __CFArray *v36;
  void *v37;
  CFIndex Count;
  CFIndex v39;
  CFIndex v40;
  const __CFDictionary *ValueAtIndex;
  const __CFAllocator *v42;
  CFNumberRef v43;
  uint64_t v44;
  const __CFString *v45;
  unsigned int PackedISO639_2TFromLocaleIdentifier;
  uint64_t v47;
  CFLocaleIdentifier v48;
  CFLocaleIdentifier v49;
  int v50;
  CFStringRef StringForLanguageCode;
  CFStringRef v52;
  uint64_t v53;
  CFLocaleIdentifier v54;
  __CFString **v55;
  void *v56;
  void *v57;
  void *v58;
  uint64_t v59;
  uint64_t v60;
  void **v61;
  uint64_t v62;
  CFLocaleIdentifier v63;
  CFLocaleIdentifier v64;
  __CFDictionary *v65;
  uint64_t v66;
  void **v67;
  void **p_keys;
  const void *v69;
  const void *v70;
  const void *v71;
  CFStringRef v72;
  const void *v73;
  const void *v74;
  const __CFDictionary *MutableAudioGroups;
  const void *v76;
  CFAllocatorRef *v77;
  uint64_t MutableSubtitleGroups;
  const __CFDictionary *v79;
  CFMutableDictionaryRef v80;
  const __CFDictionary *v81;
  const __CFAllocator *v82;
  __CFDictionary *v83;
  __CFDictionary *v84;
  CFTypeID v85;
  const void *SInt32;
  const void *v87;
  CFTypeID v88;
  const void *v89;
  const void *v90;
  const void *v91;
  const void *v92;
  CFLocaleIdentifier CanonicalLanguageIdentifierFromString;
  const void *v94;
  CFNumberRef cf;
  uint64_t v100;
  void *v101;
  int v102;
  void *values;
  void *v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  uint64_t v114;
  void *keys;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  uint64_t v123;
  uint64_t v124;

  v124 = *MEMORY[0x1E0C80C00];
  values = 0;
  CFStringForOSTypeValue = (void *)FigGetCFStringForOSTypeValue();
  MediaSelectionArray = (const __CFArray *)FigMultivariantPlaylistGetMediaSelectionArray(a1);
  MediaSelectionOptionArrayByMediaType = (const __CFArray *)FindMediaSelectionOptionArrayByMediaType(MediaSelectionArray, CFStringForOSTypeValue);
  v100 = a1;
  v101 = a3;
  if (MediaSelectionOptionArrayByMediaType)
  {
    v36 = MediaSelectionOptionArrayByMediaType;
    goto LABEL_20;
  }
  v26 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
    return 4294954510;
  v28 = Mutable;
  v29 = 0;
  *((_QWORD *)&v116 + 1) = 0;
  *(_QWORD *)&v117 = 0;
  *(_QWORD *)&v108 = 0;
  v107 = 0uLL;
  v106 = CFStringForOSTypeValue;
  keys = CFSTR("MediaSelectionGroupMediaType");
  *(_QWORD *)&v116 = CFSTR("MediaSelectionGroupAllowEmptySelection");
  v30 = kFigStdAssetMediaSelectionGroupKey_OptionsArray;
  v31 = 3;
  v32 = 2;
  if (a2 <= 1936684397)
  {
    if (a2 == 1668047728 || a2 == 1935832172)
    {
      *(_QWORD *)&v107 = *MEMORY[0x1E0C9AE50];
      v33 = kFigStdAssetMediaCharacteristic_Legible;
      goto LABEL_11;
    }
LABEL_14:
    *(&keys + v32) = *v30;
    *(&v106 + v32) = Mutable;
    goto LABEL_16;
  }
  if (a2 == 1986618469)
  {
    *(_QWORD *)&v107 = *MEMORY[0x1E0C9AE50];
    v33 = kFigStdAssetMediaCharacteristic_Visual;
  }
  else
  {
    if (a2 != 1936684398)
      goto LABEL_14;
    *(_QWORD *)&v107 = *MEMORY[0x1E0C9AE50];
    v33 = kFigStdAssetMediaCharacteristic_Audible;
  }
LABEL_11:
  values = *v33;
  *((_QWORD *)&v116 + 1) = CFSTR("MediaSelectionGroupOptions");
  *((_QWORD *)&v107 + 1) = Mutable;
  if (values)
  {
    Mutable = CFArrayCreate(v26, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
    if (!Mutable)
    {
      CFRelease(v28);
      return 4294954510;
    }
    v30 = kFigStdAssetMediaSelectionGroupKey_MediaCharacteristics;
    v31 = 4;
    v32 = 3;
    v29 = Mutable;
    goto LABEL_14;
  }
  v29 = 0;
  v31 = 3;
LABEL_16:
  v34 = CFDictionaryCreate(v26, (const void **)&keys, (const void **)&v106, v31, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v34)
  {
    FigMultivariantPlaylistAddMediaSelection(a1, v34);
    CFRelease(v34);
    v35 = 0;
    v36 = v28;
    if (!v29)
      goto LABEL_19;
    goto LABEL_18;
  }
  v36 = 0;
  v35 = 4294954510;
  if (v29)
LABEL_18:
    CFRelease(v29);
LABEL_19:
  CFRelease(v28);
  if (!v34)
    return v35;
LABEL_20:
  v102 = a2;
  v37 = (void *)FigGetCFStringForOSTypeValue();
  Count = CFArrayGetCount(v36);
  if (Count >= 1)
  {
    v39 = Count;
    v40 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v36, v40);
      CFDictionaryGetValue(ValueAtIndex, CFSTR("MediaSelectionOptionsName"));
      CFDictionaryGetValue(ValueAtIndex, CFSTR("MediaSelectionOptionsMediaType"));
      if (FigCFEqual())
      {
        if (FigCFEqual())
        {
          CFDictionaryGetValue(ValueAtIndex, CFSTR("MediaSelectionOptionsExtendedLanguageTag"));
          if (FigCFEqual())
            break;
        }
      }
      if (v39 == ++v40)
        goto LABEL_28;
    }
    if (ValueAtIndex)
    {
      v50 = a2;
      v73 = CFDictionaryGetValue(ValueAtIndex, CFSTR("MediaSelectionOptionsPersistentID"));
LABEL_81:
      v74 = v73;
      if (v50 == 1936684398)
      {
        MutableAudioGroups = (const __CFDictionary *)FigMultivariantPlaylistGetMutableAudioGroups(v100);
        v76 = v101;
      }
      else
      {
        v76 = v101;
        if (v50 != 1668047728)
        {
          v77 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
          if (v50 == 1935832172)
          {
            MutableSubtitleGroups = FigMultivariantPlaylistGetMutableSubtitleGroups(v100);
          }
          else
          {
            if (v50 != 1986618469)
              return FigSignalErrorAt();
            MutableSubtitleGroups = FigMultivariantPlaylistGetMutableVideoGroups(v100);
          }
          MutableAudioGroups = (const __CFDictionary *)MutableSubtitleGroups;
          goto LABEL_91;
        }
        MutableAudioGroups = (const __CFDictionary *)FigMultivariantPlaylistGetMutableClosedCaptionGroups(v100);
      }
      v77 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
LABEL_91:
      v79 = (const __CFDictionary *)CFDictionaryGetValue(MutableAudioGroups, v76);
      if (v79)
      {
        v81 = v79;
LABEL_94:
        if (CFDictionaryGetValue(v81, v74))
          return 0;
        v82 = *v77;
        v83 = CFDictionaryCreateMutable(*v77, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        if (v83)
        {
          v84 = v83;
          if (v76)
            CFDictionarySetValue(v83, CFSTR("FBPAEGLMK_GroupID"), v76);
          if (a6)
          {
            CFDictionarySetValue(v84, CFSTR("FBPAEGLMK_URL"), a6);
          }
          else if (v50 == 1668047728 && a16)
          {
            v88 = CFGetTypeID(a16);
            if (v88 == CFStringGetTypeID())
              CFDictionarySetValue(v84, CFSTR("FBPAEGLMK_ClosedCaptionType"), a16);
            goto LABEL_111;
          }
          if (v50 != 1936684398 || !a16 || (v85 = CFGetTypeID(a16), v85 != CFStringGetTypeID()))
          {
LABEL_111:
            if (a7)
              CFDictionarySetValue(v84, CFSTR("FBPAEGLMK_URLForCacheLookup"), a7);
            if (v50 == 1936684398 && a17)
              CFDictionarySetValue(v84, CFSTR("FBPAEGLMK_Channels"), a17);
            if (a14)
              CFDictionarySetValue(v84, CFSTR("FBPAEGLMK_Characteristics"), a14);
            if (v50 == 1936684398 && a18 >= 1)
              FigCFDictionarySetInt32();
            if (v50 == 1936684398 && a9 > 0.0)
              FigCFDictionarySetDouble();
            if (a8)
              CFDictionarySetValue(v84, CFSTR("FBPAEGLMK_StableStreamIdentifier"), a8);
            v89 = (const void *)*MEMORY[0x1E0C9AE50];
            v90 = (const void *)*MEMORY[0x1E0C9AE40];
            if (a11)
              v91 = (const void *)*MEMORY[0x1E0C9AE50];
            else
              v91 = (const void *)*MEMORY[0x1E0C9AE40];
            CFDictionarySetValue(v84, CFSTR("FBPAEGLMK_Autoselect"), v91);
            if (a10)
              v92 = v89;
            else
              v92 = v90;
            CFDictionarySetValue(v84, CFSTR("FBPAEGLMK_Default"), v92);
            CanonicalLanguageIdentifierFromString = CFLocaleCreateCanonicalLanguageIdentifierFromString(v82, a4);
            if (CanonicalLanguageIdentifierFromString)
              CFDictionarySetValue(v84, CFSTR("FBPAEGLMK_UnicodeLanguageIdentifier"), CanonicalLanguageIdentifierFromString);
            if (a5)
              CFDictionarySetValue(v84, CFSTR("FBPAEGLMK_Name"), a5);
            if (a12)
              v94 = v89;
            else
              v94 = v90;
            CFDictionarySetValue(v84, CFSTR("FBPAEGLMK_Forced"), v94);
            CFDictionaryAddValue(v81, v74, v84);
            CFRelease(v84);
            if (CanonicalLanguageIdentifierFromString)
              CFRelease(CanonicalLanguageIdentifierFromString);
            return 0;
          }
          FigGetAllocatorForMedia();
          CFStringGetIntValue(a16);
          SInt32 = (const void *)FigCFNumberCreateSInt32();
          if (SInt32)
          {
            v87 = SInt32;
            CFDictionarySetValue(v84, CFSTR("FBPAEGLMK_AudioInstreamID"), SInt32);
            CFRelease(v87);
            goto LABEL_111;
          }
        }
        return FigSignalErrorAt();
      }
      v80 = CFDictionaryCreateMutable(*v77, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v80)
      {
        v81 = v80;
        CFDictionaryAddValue(MutableAudioGroups, v76, v80);
        CFRelease(v81);
        goto LABEL_94;
      }
      return 4294954510;
    }
  }
LABEL_28:
  keys = CFSTR("MediaSelectionOptionsPersistentID");
  v42 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v43 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCFIndexType, valuePtr);
  v106 = v43;
  if (!v43)
    return 4294954510;
  cf = v43;
  v123 = 0;
  v121 = 0u;
  v122 = 0u;
  v119 = 0u;
  v120 = 0u;
  v117 = 0u;
  v118 = 0u;
  v116 = 0u;
  v107 = 0u;
  v108 = 0u;
  v109 = 0u;
  v110 = 0u;
  v111 = 0u;
  v112 = 0u;
  v113 = 0u;
  v114 = 0;
  ++*valuePtr;
  if (a5)
  {
    *(_QWORD *)&v116 = CFSTR("MediaSelectionOptionsName");
    *(_QWORD *)&v107 = a5;
    v44 = 2;
  }
  else
  {
    v44 = 1;
  }
  v45 = a4;
  if (!a4)
  {
    v52 = 0;
    v49 = 0;
    *(&keys + v44) = CFSTR("MediaSelectionOptionsLanguageCode");
    v54 = CFSTR("und");
    *(&v106 + v44) = CFSTR("und");
    v53 = v44 + 1;
    v50 = a2;
    goto LABEL_39;
  }
  PackedISO639_2TFromLocaleIdentifier = FigMetadataGetPackedISO639_2TFromLocaleIdentifier(a4);
  *(&keys + v44) = CFSTR("MediaSelectionOptionsExtendedLanguageTag");
  *(&v106 + v44) = (void *)a4;
  v47 = v44 + 1;
  v48 = CFLocaleCreateCanonicalLanguageIdentifierFromString(v42, a4);
  v49 = v48;
  if (v48)
  {
    *(&keys + v47) = CFSTR("MediaSelectionOptionsUnicodeLanguageIdentifier");
    *(&v106 + v47) = (void *)v48;
    v47 = v44 + 2;
  }
  v50 = v102;
  StringForLanguageCode = FigCreateStringForLanguageCode(v42, PackedISO639_2TFromLocaleIdentifier, 1);
  v52 = StringForLanguageCode;
  if (StringForLanguageCode)
  {
    *(&keys + v47) = CFSTR("MediaSelectionOptionsLanguageCode");
    *(&v106 + v47) = (void *)StringForLanguageCode;
    v53 = v47 + 1;
    v54 = CFLocaleCreateCanonicalLanguageIdentifierFromString(v42, StringForLanguageCode);
    if (v54)
    {
      v44 = v47;
      v45 = v54;
LABEL_39:
      *(&keys + v53) = CFSTR("MediaSelectionOptionsUnicodeLanguageCode");
      *(&v106 + v53) = (void *)v54;
      v47 = v44 + 2;
      goto LABEL_42;
    }
    v45 = 0;
    ++v47;
  }
  else
  {
    v45 = 0;
  }
LABEL_42:
  if (a10)
  {
    v55 = kFigStdAssetMediaSelectionOptionsKey_IsDefault;
LABEL_44:
    *(&keys + v47) = *v55;
    *(&v106 + v47++) = (void *)*MEMORY[0x1E0C9AE50];
    goto LABEL_46;
  }
  if (!a11)
  {
    v55 = kFigStdAssetMediaSelectionOptionsKey_IsAuxiliaryContent;
    goto LABEL_44;
  }
LABEL_46:
  if (v50 == 1668047728)
  {
    *(&keys + v47) = CFSTR("MediaSelectionOptionsIsMuxedClosedCaption");
    v61 = (void **)MEMORY[0x1E0C9AE40];
    if (a13)
      v61 = (void **)MEMORY[0x1E0C9AE50];
    v56 = *v61;
    v60 = 1;
    v59 = v47;
  }
  else
  {
    if (v50 != 1935832172)
      goto LABEL_58;
    *(&keys + v47) = CFSTR("MediaSelectionOptionsDisplaysNonForcedSubtitles");
    v56 = (void *)*MEMORY[0x1E0C9AE40];
    v57 = (void *)*MEMORY[0x1E0C9AE50];
    if (a12)
      v58 = (void *)*MEMORY[0x1E0C9AE40];
    else
      v58 = (void *)*MEMORY[0x1E0C9AE50];
    *(&v106 + v47) = v58;
    v59 = v47 + 1;
    *(&keys + v47 + 1) = CFSTR("MediaSelectionOptionsDisplaysForcedSubtitlesOnly");
    if (a12)
      v56 = v57;
    v60 = 2;
  }
  *(&v106 + v59) = v56;
  v47 += v60;
LABEL_58:
  if (a14)
  {
    *(&keys + v47) = CFSTR("MediaSelectionOptionsTaggedMediaCharacteristics");
    *(&v106 + v47++) = (void *)a14;
  }
  if (localeIdentifier)
  {
    *(&keys + v47) = CFSTR("MediaSelectionOptionsAssociatedExtendedLanguageTag");
    *(&v106 + v47) = (void *)localeIdentifier;
    v62 = v47 + 1;
    v63 = CFLocaleCreateCanonicalLanguageIdentifierFromString(v42, localeIdentifier);
    v64 = v63;
    if (v63)
    {
      *(&keys + v62) = CFSTR("MediaSelectionOptionsAssociatedUnicodeLanguageIdentifier");
      *(&v106 + v62) = (void *)v63;
      v47 += 2;
    }
    else
    {
      ++v47;
    }
    v50 = v102;
  }
  else
  {
    v64 = 0;
  }
  *(&keys + v47) = CFSTR("MediaSelectionOptionsMediaType");
  *(&v106 + v47) = v37;
  v65 = CFDictionaryCreateMutable(v42, v47 + 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v65)
  {
    v66 = v47 + 1;
    v67 = &v106;
    p_keys = &keys;
    do
    {
      v70 = *p_keys++;
      v69 = v70;
      v71 = *v67++;
      CFDictionaryAddValue(v65, v69, v71);
      --v66;
    }
    while (v66);
    v72 = FigCopyGMLoggingDescriptionForOption(v65);
    CFDictionaryAddValue(v65, CFSTR("MediaSelectionOptionsDebugDescription"), v72);
    v50 = v102;
    if (v72)
      CFRelease(v72);
    CFArrayAppendValue(v36, v65);
    CFRelease(v65);
    v35 = 0;
    if (v52)
      goto LABEL_72;
  }
  else
  {
    v35 = 4294954510;
    if (v52)
LABEL_72:
      CFRelease(v52);
  }
  CFRelease(cf);
  if (v49)
    CFRelease(v49);
  if (v45)
    CFRelease(v45);
  if (v64)
    CFRelease(v64);
  if (v65)
  {
    v73 = CFDictionaryGetValue(v65, CFSTR("MediaSelectionOptionsPersistentID"));
    goto LABEL_81;
  }
  return v35;
}

const void *FindMatchingMapEntry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFIndex i;
  const __CFArray *MapSegmentSpecifiers;
  const __CFArray *v9;
  const void *ValueAtIndex;

  for (i = 0; ; ++i)
  {
    MapSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMapSegmentSpecifiers(a1);
    if (MapSegmentSpecifiers)
      MapSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MapSegmentSpecifiers);
    if (i >= (uint64_t)MapSegmentSpecifiers)
      break;
    v9 = (const __CFArray *)FigMediaPlaylistGetMapSegmentSpecifiers(a1);
    ValueAtIndex = CFArrayGetValueAtIndex(v9, i);
    if (FigMediaSegmentSpecifierGetStartOffset((uint64_t)ValueAtIndex) == a3
      && FigMediaSegmentSpecifierGetBytesToRead((uint64_t)ValueAtIndex) == a4)
    {
      FigMediaSegmentSpecifierGetURLString((uint64_t)ValueAtIndex);
      if (FigCFEqual())
        return ValueAtIndex;
    }
  }
  return 0;
}

uint64_t PlaylistCreateMapEntry(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  uint64_t MediaEntryCount;
  uint64_t AllocatorForMedia;
  uint64_t v14;
  uint64_t v15;
  const void *v17;

  v17 = 0;
  if (!a6)
    return FigSignalErrorAt();
  *a6 = 0;
  MediaEntryCount = FigMediaPlaylistGetMediaEntryCount(a1);
  FigMediaPlaylistSetMediaEntryCount(a1, MediaEntryCount + 1);
  AllocatorForMedia = FigGetAllocatorForMedia();
  v14 = FigMediaPlaylistGetMediaEntryCount(a1);
  v15 = FigMediaSegmentSpecifierCreate(0.0, 0.0, 0.0, AllocatorForMedia, a2, 0, 0, a5, 0, a3, a4, 0, 0, 1, 0, 0, 1, 0, 0,
          0,
          v14,
          1,
          (uint64_t *)&v17);
  FigMediaPlaylistAddMapSegmentSpecifier(a1, v17);
  *a6 = v17;
  return v15;
}

uint64_t PlaylistProcessPartInfTag(uint64_t a1, const char *a2, uint64_t a3)
{
  char *v4;
  unsigned int v5;
  BOOL v6;
  int v7;
  const char *v9;
  uint64_t v10;
  int v13;
  size_t v14;
  uint64_t v15;
  const char *v16;
  char *__s1;
  void *v18;
  double v19;
  char *v20;

  v20 = (char *)a2;
  v18 = 0;
  v19 = 0.0;
  while (1)
  {
    v4 = v20;
    v5 = *v20;
    v6 = v5 > 0xD;
    v7 = (1 << v5) & 0x2401;
    if (!v6 && v7 != 0)
    {
      v10 = 0;
      goto LABEL_17;
    }
    v16 = 0;
    __s1 = 0;
    v15 = 0;
    v13 = 0;
    free(v18);
    v18 = 0;
    v10 = sp_ParseAttribute("#EXT-X-PART-INF", v4, 1, 0, &__s1, &v15, &v16, &v14, (const char **)&v20, &v13, (UInt8 **)&v18, a3);
    if ((_DWORD)v10 && !*(_BYTE *)(a3 + 41) || (v13 & 2) != 0)
      return v10;
    if (__s1)
    {
      v9 = v16;
      if (v16)
      {
        if (v15 == 11 && !strncmp(__s1, "PART-TARGET", 0xBuLL))
        {
          v10 = sp_strtod(v9, 0, &v19, 0, (uint64_t)"Blocking reload part target", a3);
          if (!(_DWORD)v10 && v19 <= 0.0)
            break;
        }
      }
    }
    if ((_DWORD)v10)
      goto LABEL_17;
  }
  v10 = 4294954654;
  _StreamPlaylistLogError(4294954654, 4294955032, a3, CFSTR("%s must have %s"), v19, "#EXT-X-PART-INF", "PART-TARGET");
LABEL_17:
  FigMediaPlaylistSetPartTargetDuration(a1, v19);
  free(v18);
  return v10;
}

uint64_t PlaylistProcessPartTag(uint64_t a1, const char *a2, uint64_t a3, const void *a4, const void *a5, uint64_t a6, const void *a7, uint64_t a8, double a9, double *a10)
{
  char *v12;
  unsigned int v13;
  BOOL v14;
  int v15;
  char v17;
  char *v18;
  const char *v19;
  BOOL v21;
  BOOL v23;
  uint64_t v24;
  UInt8 *v25;
  const UInt8 *v26;
  const __CFAllocator *AllocatorForMedia;
  uint64_t v28;
  char v29;
  const char *v30;
  UInt8 *v31;
  CFStringRef v32;
  double v33;
  double v34;
  const __CFString *v35;
  const __CFArray *PartialSegments;
  uint64_t LastValue;
  int v38;
  _QWORD *MediaFileEntry;
  uint64_t v40;
  char v41;
  uint64_t MediaSequence;
  uint64_t FirstValue;
  uint64_t v44;
  uint64_t PreviousSegment;
  uint64_t v46;
  double TimeInSeconds;
  uint64_t v54;
  CFStringRef v56;
  UInt8 *v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  void *__src;
  char *__s1;
  uint64_t v63;
  uint64_t v64;
  UInt8 *v65;
  double v66;
  char *v67;

  v56 = 0;
  v54 = 0;
  v57 = 0;
  v66 = 0.0;
  v67 = (char *)a2;
  v64 = 0;
  v65 = 0;
  v63 = 0;
  while (1)
  {
LABEL_2:
    v12 = v67;
    v13 = *v67;
    v14 = v13 > 0xD;
    v15 = (1 << v13) & 0x2401;
    if (!v14 && v15 != 0)
    {
      v28 = 0;
      v29 = 1;
      goto LABEL_54;
    }
    __src = 0;
    __s1 = 0;
    v59 = 0;
    v60 = 0;
    v58 = 0;
    free(v65);
    v65 = 0;
    v28 = sp_ParseAttribute("#EXT-X-PART", v12, 1, 0, &__s1, &v60, (const char **)&__src, (size_t *)&v59, (const char **)&v67, &v58, &v65, a8);
    if ((_DWORD)v28 && !*(_BYTE *)(a8 + 41) || (v17 = v58, (v58 & 2) != 0))
    {
      v31 = v57;
      goto LABEL_89;
    }
    v18 = __s1;
    if (__s1)
    {
      v19 = (const char *)__src;
      if (__src)
        break;
    }
LABEL_46:
    if ((_DWORD)v28)
      goto LABEL_53;
  }
  switch(v60)
  {
    case 3:
      if (strncmp(__s1, "URI", 3uLL))
      {
        if (strncmp(v18, "GAP", 3uLL))
          goto LABEL_46;
        if (v59 == 3)
        {
          v21 = *(_WORD *)v19 == 17753 && v19[2] == 83;
          LOBYTE(v54) = v21;
          if ((_DWORD)v28)
            goto LABEL_53;
        }
        else
        {
          LOBYTE(v54) = 0;
          if ((_DWORD)v28)
            goto LABEL_53;
        }
        goto LABEL_2;
      }
      if ((v17 & 1) == 0)
      {
        v30 = "URI";
        goto LABEL_52;
      }
      free(v57);
      v24 = v59;
      v25 = (UInt8 *)malloc_type_malloc(v59 + 1, 0xDEBF9A72uLL);
      if (v25)
      {
        v26 = v25;
        memcpy(v25, __src, v24);
        v26[v24] = 0;
        AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
        v57 = (UInt8 *)v26;
        v56 = CFStringCreateWithBytes(AllocatorForMedia, v26, v24, 0x8000100u, 0);
        if ((_DWORD)v28)
          goto LABEL_53;
        goto LABEL_2;
      }
      v28 = FigSignalErrorAt();
      v31 = 0;
LABEL_89:
      v32 = v56;
      if (v56)
        goto LABEL_86;
LABEL_87:
      free(v31);
      return v28;
    case 8:
      if (strncmp(__s1, "DURATION", 8uLL))
        goto LABEL_46;
      v28 = sp_strtod(v19, 0, &v66, 0, (uint64_t)"Partial Segment Duration", a8);
      if ((_DWORD)v28)
        goto LABEL_53;
      goto LABEL_2;
    case 9:
      if (strncmp(__s1, "BYTERANGE", 9uLL))
        goto LABEL_46;
      if ((v17 & 1) == 0)
      {
        v30 = "BYTERANGE";
LABEL_52:
        v28 = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955032, a8, CFSTR("%s %s: missing quotes"), "#EXT-X-PART", v30);
LABEL_53:
        v29 = 0;
LABEL_54:
        v32 = v56;
        v31 = v57;
        v33 = *a10;
        v34 = v66;
        if (*a10 < v66)
          *a10 = v66;
        if (v57)
          v29 = 0;
        if ((v29 & 1) != 0)
        {
          v35 = CFSTR("Missing mandatory URL for %s");
        }
        else
        {
          if ((_DWORD)v28 || v34 != 0.0)
          {
LABEL_64:
            PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments(a3);
            LastValue = FigCFArrayGetLastValue();
            if (!(_DWORD)v28)
            {
              v40 = LastValue;
              if (!FigCFArrayGetLastValue() || FigMediaSegmentSpecifierGetDiscontinuityDomain(v40) == a6)
              {
                if (FigMediaSegmentSpecifierIsDiscontinuity(a3))
                {
                  if (PartialSegments)
                    v41 = CFArrayGetCount(PartialSegments) == 0;
                  else
                    v41 = 1;
                }
                else
                {
                  v41 = 0;
                }
                MediaSequence = FigMediaSegmentSpecifierGetMediaSequence(a3);
                MediaFileEntry = (_QWORD *)CreateMediaFileEntry(a1, v56, 0, a4, a5, MediaSequence, a6, v63, v66, a9, v64, a7, 0, v41, v54);
                v38 = 1;
                FigMediaSegmentSpecifierSetIsFragment((uint64_t)MediaFileEntry, 1);
                FigMediaSegmentSpecifierSetIsIndependent((uint64_t)MediaFileEntry, SBYTE4(v54));
                FigMediaSegmentSpecifierAddPartialSegment(a3, MediaFileEntry);
                v28 = 0;
LABEL_75:
                FirstValue = FigCFArrayGetFirstValue();
                if (FirstValue != FigCFArrayGetLastValue())
                {
                  v44 = FigCFArrayGetLastValue();
                  PreviousSegment = FigMediaSegmentSpecifierGetPreviousSegment(v44);
                  if (v38)
                  {
                    v46 = PreviousSegment;
                    if (FigMediaPlaylistGetPartTargetDuration(a1) == 0.0
                      || FigMediaSegmentSpecifierIsMarkedIndependent(v46)
                      || (TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds(v46),
                          TimeInSeconds >= FigMediaPlaylistGetPartTargetDuration(a1) * 0.85)
                      || FigMediaSegmentSpecifierIsMarkedAsGap(v46) | v54)
                    {
                      v28 = 0;
                    }
                    else
                    {
                      v28 = 4294954654;
                      _StreamPlaylistLogError(4294954654, 4294955032, a8, CFSTR("%s non-terminal partial segment duration must be at least 85%% of %s"), "#EXT-X-PART", "PART-TARGET");
                    }
                  }
                }
                free(v65);
                if (MediaFileEntry)
                  CFRelease(MediaFileEntry);
                if (!v56)
                  goto LABEL_87;
LABEL_86:
                CFRelease(v32);
                goto LABEL_87;
              }
              v28 = 4294954654;
              _StreamPlaylistLogError(4294954654, 4294955032, a8, CFSTR("%s not allowed on partial segment boundaries"), "#EXT-X-DISCONTINUITY");
            }
            v38 = 0;
            MediaFileEntry = 0;
            goto LABEL_75;
          }
          v35 = CFSTR("%s partial segment must have positive duration");
        }
        v28 = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955032, a8, v35, v34, v33, "#EXT-X-PART");
        goto LABEL_64;
      }
      v28 = PlaylistProcessByteRange(&v64, &v63, 0, (const char **)&__src, v59, a8);
      if ((_DWORD)v28)
        goto LABEL_53;
      goto LABEL_2;
    case 11:
      if (strncmp(__s1, "INDEPENDENT", 0xBuLL))
        goto LABEL_46;
      if (v59 != 3)
      {
        BYTE4(v54) = 0;
        goto LABEL_46;
      }
      v23 = *(_WORD *)v19 == 17753 && v19[2] == 83;
      BYTE4(v54) = v23;
      if ((_DWORD)v28)
        goto LABEL_53;
      goto LABEL_2;
    default:
      goto LABEL_46;
  }
}

uint64_t PlaylistProcessRenditionReportTag(uint64_t a1, const char *a2, const __CFURL *a3, uint64_t a4)
{
  char *v5;
  CFURLRef v7;
  uint64_t v8;
  unsigned int v9;
  BOOL v10;
  int v11;
  char v13;
  const char *v14;
  char *v15;
  CFIndex v16;
  BOOL v18;
  uint64_t *v19;
  const char *v20;
  const char *v21;
  int *v22;
  const char *v23;
  const char *v24;
  uint64_t v25;
  CFIndex v26;
  const __CFArray *RenditionReportSpecifiers;
  const __CFArray *v28;
  const void *ValueAtIndex;
  const __CFAllocator *v31;
  char v33;
  int v34;
  CFIndex v35;
  uint64_t v36;
  char *v37;
  void *v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;

  v5 = (char *)a2;
  v7 = 0;
  v33 = 0;
  v8 = 0;
  v43 = (char *)a2;
  v41 = -1;
  v42 = -1;
  v39 = -1;
  v40 = -1;
  v38 = 0;
  v31 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  while (1)
  {
    v9 = *v5;
    v10 = v9 > 0xD;
    v11 = (1 << v9) & 0x2401;
    if (!v10 && v11 != 0)
      break;
    v44 = 0;
    v36 = 0;
    v37 = 0;
    v35 = 0;
    v34 = 0;
    free(v38);
    v38 = 0;
    v8 = sp_ParseAttribute("#EXT-X-RENDITION-REPORT", v5, 1, 0, &v44, &v36, (const char **)&v37, (size_t *)&v35, (const char **)&v43, &v34, (UInt8 **)&v38, a4);
    if ((_DWORD)v8 && !*(_BYTE *)(a4 + 41))
      goto LABEL_54;
    v13 = v34;
    if ((v34 & 2) != 0)
      goto LABEL_54;
    v14 = v44;
    if (v44)
    {
      v15 = v37;
      if (v37)
      {
        v16 = v35;
        if (v35)
        {
          switch(v36)
          {
            case 3:
              if (!strncmp(v44, "URI", 3uLL))
              {
                if ((v13 & 1) == 0)
                {
                  v8 = 4294954654;
                  _StreamPlaylistLogError(4294954654, 4294955032, a4, CFSTR("%s %s: missing quotes"), "#EXT-X-RENDITION-REPORT", "URI");
                  goto LABEL_36;
                }
                v7 = CFURLCreateWithBytes(v31, (const UInt8 *)v15, v16, 0x8000100u, a3);
              }
              else if (!strncmp(v14, "GAP", 3uLL))
              {
                if (v16 == 3)
                {
                  v18 = *(_WORD *)v15 == 17753 && v15[2] == 83;
                  v33 = v18;
                }
                else
                {
                  v33 = 0;
                }
              }
              break;
            case 8:
              if (!strncmp(v44, "LAST-MSN", 8uLL))
              {
                v19 = &v42;
                v20 = v15;
                v21 = "last_media_seq_num";
                goto LABEL_30;
              }
              break;
            case 9:
              if (!strncmp(v44, "LAST-PART", 9uLL))
              {
                v22 = &v40;
                v23 = v15;
                v24 = "last_part";
                goto LABEL_33;
              }
              break;
            case 10:
              if (!strncmp(v44, "LAST-I-MSN", 0xAuLL))
              {
                v19 = &v41;
                v20 = v15;
                v21 = "last_indepdendent_media_seq_num";
LABEL_30:
                v25 = sp_strtoll(v20, &v37, v19, 1, (uint64_t)v21, a4);
                goto LABEL_34;
              }
              break;
            case 11:
              if (!strncmp(v44, "LAST-I-PART", 0xBuLL))
              {
                v22 = &v39;
                v23 = v15;
                v24 = "last_indepdendent_part";
LABEL_33:
                v25 = sp_strtol(v23, &v37, v22, 1, (uint64_t)v24, a4);
LABEL_34:
                v8 = v25;
              }
              break;
            default:
              break;
          }
          if ((_DWORD)v8)
          {
LABEL_36:
            if (!*(_BYTE *)(a4 + 41))
              goto LABEL_54;
          }
        }
      }
    }
    v5 = v43;
  }
  if (!(_DWORD)v8)
  {
    if (!v7)
    {
      v8 = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294954977, a4, CFSTR("%s %s: Missing Mandatory identifier"), "#EXT-X-RENDITION-REPORT", "URI");
      goto LABEL_56;
    }
    v26 = 0;
    while (1)
    {
      RenditionReportSpecifiers = (const __CFArray *)FigMediaPlaylistGetRenditionReportSpecifiers(a1);
      if (RenditionReportSpecifiers)
        RenditionReportSpecifiers = (const __CFArray *)CFArrayGetCount(RenditionReportSpecifiers);
      if (v26 >= (uint64_t)RenditionReportSpecifiers)
        break;
      v28 = (const __CFArray *)FigMediaPlaylistGetRenditionReportSpecifiers(a1);
      ValueAtIndex = CFArrayGetValueAtIndex(v28, v26);
      FigRenditionReportSpecifierGetURL((uint64_t)ValueAtIndex);
      ++v26;
      if (FigCFEqual())
      {
        v8 = FigSignalErrorAt();
        goto LABEL_54;
      }
    }
    v44 = 0;
    v8 = FigRenditionReportSpecifierCreate(v7, v42, v41, v40, v39, 1, v33, (uint64_t *)&v44);
    if (!(_DWORD)v8)
      FigMediaPlaylistAddRenditionReportSpecifier(a1, v44);
    if (v44)
      CFRelease(v44);
  }
LABEL_54:
  if (v7)
    CFRelease(v7);
LABEL_56:
  free(v38);
  return v8;
}

uint64_t PlaylistProcessPreloadHintTag(uint64_t a1, const char *a2, uint64_t a3)
{
  char *v4;
  uint64_t PreloadHint;
  const char *v6;
  unsigned int v7;
  BOOL v8;
  int v9;
  char v11;
  UInt8 *v12;
  const char *v13;
  CFIndex v14;
  uint64_t *v15;
  const char *v16;
  const char *v17;
  const __CFAllocator *AllocatorForMedia;
  CFStringRef v19;
  uint64_t v20;
  uint64_t PreloadMapHint;
  uint64_t v22;
  uint64_t v23;
  uint64_t v26;
  CFStringRef v27;
  int v28;
  CFIndex v29;
  uint64_t v30;
  UInt8 *bytes;
  char *__s1;
  uint64_t v33;
  uint64_t v34;
  UInt8 *v35;
  char *v36;

  v4 = (char *)a2;
  v26 = 0;
  PreloadHint = 0;
  v27 = 0;
  v35 = 0;
  v36 = (char *)a2;
  v33 = -1;
  v34 = 0;
  v6 = "BYTERANGE-START";
  while (1)
  {
    v7 = *v4;
    v8 = v7 > 0xD;
    v9 = (1 << v7) & 0x2401;
    if (!v8 && v9 != 0)
      break;
    bytes = 0;
    __s1 = 0;
    v29 = 0;
    v30 = 0;
    v28 = 0;
    free(v35);
    v35 = 0;
    PreloadHint = sp_ParseAttribute("#EXT-X-PRELOAD-HINT", v4, 1, 0, &__s1, &v30, (const char **)&bytes, (size_t *)&v29, (const char **)&v36, &v28, &v35, a3);
    if ((_DWORD)PreloadHint && !*(_BYTE *)(a3 + 41))
      goto LABEL_60;
    v11 = v28;
    if ((v28 & 2) != 0)
      goto LABEL_60;
    if (__s1)
    {
      v12 = bytes;
      if (bytes)
      {
        v13 = v6;
        v14 = v29;
        if (!v29)
        {
          v6 = v13;
          goto LABEL_34;
        }
        if (v30 <= 14)
        {
          if (v30 == 3)
          {
            if (strncmp(__s1, "URI", 3uLL))
              goto LABEL_31;
            if ((v11 & 1) != 0)
            {
              AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
              v27 = CFStringCreateWithBytes(AllocatorForMedia, bytes, v14, 0x8000100u, 0);
              goto LABEL_31;
            }
            PreloadHint = 4294954654;
            _StreamPlaylistLogError(4294954654, 4294955032, a3, CFSTR("%s %s: missing quotes"), "#EXT-X-PRELOAD-HINT", "URI");
            v6 = v13;
          }
          else
          {
            if (v30 == 4)
            {
              v6 = v13;
              if (!strncmp(__s1, "TYPE", 4uLL))
              {
                if (!strncasecmp((const char *)v12, "PART", 4uLL))
                {
                  HIDWORD(v26) = 1;
                }
                else
                {
                  if (strncasecmp((const char *)v12, "MAP", 3uLL))
                  {
                    _StreamPlaylistLogError(0, 4294954985, a3, CFSTR("Unknown %s %s in %s"), "TYPE", v12, "#EXT-X-PRELOAD-HINT");
                    PreloadHint = 0;
                    goto LABEL_34;
                  }
                  LODWORD(v26) = 1;
                }
              }
              goto LABEL_32;
            }
LABEL_31:
            v6 = v13;
LABEL_32:
            if (!(_DWORD)PreloadHint)
              goto LABEL_34;
          }
          if (!*(_BYTE *)(a3 + 41))
            goto LABEL_60;
          goto LABEL_34;
        }
        if (v30 == 15)
        {
          v6 = v13;
          if (strncmp(__s1, v13, 0xFuLL))
            goto LABEL_32;
          v15 = &v34;
          v16 = (const char *)v12;
          v17 = v13;
        }
        else
        {
          v6 = v13;
          if (v30 != 16 || strncmp(__s1, "BYTERANGE-LENGTH", 0x10uLL))
            goto LABEL_32;
          v15 = &v33;
          v16 = (const char *)v12;
          v17 = "BYTERANGE-LENGTH";
        }
        PreloadHint = sp_strtoll(v16, (char **)&bytes, v15, 1, (uint64_t)v17, a3);
        goto LABEL_32;
      }
    }
LABEL_34:
    v4 = v36;
  }
  if ((_DWORD)PreloadHint)
  {
LABEL_60:
    v19 = v27;
    if (v27)
      goto LABEL_58;
  }
  else
  {
    v19 = v27;
    if (v26)
    {
      if (v27)
      {
        if (HIDWORD(v26)
          && FigMediaPlaylistGetPreloadHint(a1)
          && (v20 = FigMediaPlaylistGetPreloadHint(a1), FigMediaSegmentSpecifierIsReadInCurrent(v20))
          || (_DWORD)v26
          && FigMediaPlaylistGetPreloadMapHint(a1)
          && (PreloadMapHint = FigMediaPlaylistGetPreloadMapHint(a1),
              FigMediaSegmentSpecifierIsReadInCurrent(PreloadMapHint)))
        {
LABEL_57:
          PreloadHint = 0;
        }
        else
        {
          v23 = v33;
          v22 = v34;
          if (v34 >= 1 && v33 == -1)
          {
            v23 = 0x20000000000000 - v34;
            v33 = 0x20000000000000 - v34;
          }
          if (HIDWORD(v26))
          {
            PreloadHint = FigMediaPlaylistGetPreloadHint(a1);
            if (!PreloadHint)
            {
              PreloadHint = CreateMediaFileEntry(a1, 0, 0, 0, 0, 0, -1, v22, 1.0, 0.0, v23, 0, 0, 0, 0);
              FigMediaPlaylistSetPreloadHint(a1, (CFTypeRef)PreloadHint);
              goto LABEL_55;
            }
LABEL_54:
            CFRetain((CFTypeRef)PreloadHint);
            FigMediaSegmentSpecifierSetStartOffset(PreloadHint, v22);
            FigMediaSegmentSpecifierSetBytesToRead(PreloadHint, v23);
          }
          else
          {
            PreloadHint = FigMediaPlaylistGetPreloadMapHint(a1);
            if (PreloadHint)
              goto LABEL_54;
            PreloadHint = CreateMediaFileEntry(a1, 0, 1, 0, 0, 0, -1, v22, 1.0, 0.0, v23, 0, 0, 0, 0);
            FigMediaPlaylistSetPreloadMapHint(a1, (CFTypeRef)PreloadHint);
          }
LABEL_55:
          FigMediaSegmentSpecifierSetURLString(PreloadHint, v27);
          FigMediaSegmentSpecifierSetIsReadInCurrent(PreloadHint, 1);
          if (PreloadHint)
          {
            CFRelease((CFTypeRef)PreloadHint);
            goto LABEL_57;
          }
        }
LABEL_58:
        CFRelease(v19);
        goto LABEL_59;
      }
      PreloadHint = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294954977, a3, CFSTR("%s %s: Missing Mandatory identifier"), "#EXT-X-PRELOAD-HINT", "URI");
    }
    else
    {
      PreloadHint = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294954977, a3, CFSTR("%s %s: Missing Mandatory identifier"), "#EXT-X-PRELOAD-HINT", "TYPE");
      if (v27)
        goto LABEL_58;
    }
  }
LABEL_59:
  free(v35);
  return PreloadHint;
}

uint64_t PlaylistProcessSessionDataTag(uint64_t a1, const char *a2, const __CFURL *a3, uint64_t a4)
{
  char *v5;
  CFStringRef v7;
  uint64_t v8;
  unsigned int v9;
  BOOL v10;
  int v11;
  char v13;
  const char *v14;
  const UInt8 *v15;
  CFIndex v16;
  const char *v17;
  int v18;
  CFStringRef v19;
  const void *v20;
  const void *v21;
  const __CFArray *SessionDataSpecifiers;
  CFIndex Count;
  CFIndex v24;
  CFIndex v25;
  const __CFArray *v26;
  const void *ValueAtIndex;
  uint64_t v28;
  int v31;
  const __CFAllocator *alloc;
  CFURLRef v33;
  CFStringRef v34;
  CFStringRef v35;
  int v36;
  CFIndex v37;
  uint64_t v38;
  const UInt8 *v39;
  UInt8 *v40;
  char *v41;
  char *v42;

  v40 = 0;
  v41 = (char *)a2;
  if (!a1)
  {
    v8 = 0;
    goto LABEL_66;
  }
  v5 = (char *)a2;
  v7 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v8 = 0;
  v31 = 0;
  alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  while (1)
  {
    v9 = *v5;
    v10 = v9 > 0xD;
    v11 = (1 << v9) & 0x2401;
    if (!v10 && v11 != 0)
      break;
    v42 = 0;
    v38 = 0;
    v39 = 0;
    v37 = 0;
    v36 = 0;
    free(v40);
    v40 = 0;
    v8 = sp_ParseAttribute("#EXT-X-SESSION-DATA", v5, 1, 1, &v42, &v38, (const char **)&v39, (size_t *)&v37, (const char **)&v41, &v36, &v40, a4);
    if ((_DWORD)v8 && !*(_BYTE *)(a4 + 41))
      goto LABEL_67;
    v13 = v36;
    if ((v36 & 2) != 0)
      goto LABEL_67;
    v14 = v42;
    if (v42)
    {
      v15 = v39;
      if (v39)
      {
        v16 = v37;
        if (v37)
        {
          switch(v38)
          {
            case 3:
              if (strncmp(v42, "URI", 3uLL))
                break;
              if ((v13 & 1) == 0)
              {
                v17 = "URI";
                goto LABEL_34;
              }
              v33 = CFURLCreateWithBytes(alloc, v15, v16, 0x8000100u, a3);
              break;
            case 5:
              goto LABEL_20;
            case 6:
              if (strncmp(v42, "FORMAT", 6uLL))
                break;
              if (!strncasecmp((const char *)v15, "JSON", 4uLL))
              {
                v18 = 1;
              }
              else if (!strncasecmp((const char *)v15, "PLIST", 5uLL))
              {
                v18 = 2;
              }
              else
              {
                if (strncasecmp((const char *)v15, "RAW", 3uLL))
                {
                  v8 = 4294954654;
                  _StreamPlaylistLogError(4294954654, 4294955032, a4, CFSTR("%s unknown format %s"), "#EXT-X-SESSION-DATA", v15);
                  break;
                }
                v18 = 3;
              }
              v31 = v18;
              break;
            case 7:
              if (strncmp(v42, "DATA-ID", 7uLL))
                break;
              if ((v13 & 1) == 0)
              {
                v17 = "DATA-ID";
                goto LABEL_34;
              }
              v7 = CFStringCreateWithBytes(alloc, v15, v16, 0x600u, 1u);
              break;
            case 8:
              if (strncmp(v42, "LANGUAGE", 8uLL))
                break;
              if ((v13 & 1) == 0)
              {
                v17 = "LANGUAGE";
                goto LABEL_34;
              }
              v34 = CFStringCreateWithBytes(alloc, v15, v16, 0x8000100u, 1u);
              break;
            default:
              break;
          }
        }
        else if (v38 == 5 && !strncmp(v42, "VALUE", 5uLL))
        {
LABEL_20:
          if (!strncmp(v14, "VALUE", 5uLL))
          {
            if ((v13 & 1) != 0)
            {
              v35 = CFStringCreateWithBytes(alloc, v15, v16, 0x8000100u, 1u);
            }
            else
            {
              v17 = "VALUE";
LABEL_34:
              v8 = 4294954654;
              _StreamPlaylistLogError(4294954654, 4294955032, a4, CFSTR("%s %s: missing quotes"), "#EXT-X-SESSION-DATA", v17);
            }
          }
        }
      }
    }
    v5 = v41;
  }
  if ((_DWORD)v8)
  {
LABEL_67:
    v19 = v34;
    v20 = v35;
    v21 = v33;
  }
  else
  {
    v19 = v34;
    v20 = v35;
    v21 = v33;
    if (!v7)
    {
      v8 = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294954977, a4, CFSTR("%s %s: Missing Mandatory identifier"), "#EXT-X-SESSION-DATA", "DATA-ID");
      if (v33)
      {
LABEL_61:
        CFRelease(v21);
        goto LABEL_62;
      }
      goto LABEL_62;
    }
    SessionDataSpecifiers = (const __CFArray *)FigMultivariantPlaylistGetSessionDataSpecifiers(a1);
    if (SessionDataSpecifiers && (Count = CFArrayGetCount(SessionDataSpecifiers), Count >= 1))
    {
      v24 = Count;
      v25 = 0;
      while (1)
      {
        v26 = (const __CFArray *)FigMultivariantPlaylistGetSessionDataSpecifiers(a1);
        ValueAtIndex = CFArrayGetValueAtIndex(v26, v25);
        FigSessionDataSpecifierGetIdentifier((uint64_t)ValueAtIndex);
        if (FigCFEqual())
        {
          FigSessionDataSpecifierGetLanguage((uint64_t)ValueAtIndex);
          if (FigCFEqual())
            break;
        }
        if (v24 == ++v25)
          goto LABEL_52;
      }
      v8 = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294955031, a4, CFSTR("%s %s: duplicate identifier in session data"), "#EXT-X-SESSION-DATA", "DATA-ID");
    }
    else
    {
LABEL_52:
      if ((unint64_t)v33 | (unint64_t)v35)
      {
        v42 = 0;
        v28 = FigSessionDataSpecifierCreate(v7, v33, v35, v34, v31, (uint64_t *)&v42);
        if (!(_DWORD)v28)
          v28 = FigMultivariantPlaylistAddSessionDataSpecifier(a1, v42);
        v8 = v28;
        if (v42)
          CFRelease(v42);
      }
      else
      {
        v8 = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955032, a4, CFSTR("%s: Either URL or Value should be valid, not both"), "#EXT-X-SESSION-DATA");
        v21 = 0;
        v20 = 0;
      }
    }
  }
  if (v7)
    CFRelease(v7);
  if (v21)
    goto LABEL_61;
LABEL_62:
  if (v20)
    CFRelease(v20);
  if (v19)
    CFRelease(v19);
LABEL_66:
  free(v40);
  return v8;
}

uint64_t PlaylistProcessTaggedRangeTag(uint64_t a1, const char *a2, _BYTE *a3, uint64_t a4)
{
  char *v5;
  uint64_t v7;
  CFStringRef v8;
  unsigned int v9;
  BOOL v10;
  int v11;
  char v13;
  const char *v14;
  UInt8 *v15;
  CFIndex v16;
  double v17;
  const char *v18;
  CFStringRef v19;
  CFStringRef v20;
  CFIndex v21;
  CFStringRef v22;
  CFStringRef v23;
  CFIndex v24;
  CFTypeRef *v25;
  UInt8 *v26;
  const char *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  CFStringRef v31;
  CFIndex v32;
  const __CFArray *DateRangeSpecifiers;
  const __CFArray *v34;
  char *ValueAtIndex;
  const void *Identifier;
  const void *StartDate;
  const void *EndDate;
  const void *TaggedRangeClass;
  const void *TaggedRangeCue;
  CFTypeRef v41;
  const void *Scte35cmd;
  CFTypeRef v43;
  const void *Scte35in;
  CFTypeRef v45;
  const void *Scte35out;
  const char *v47;
  CFDateRef v48;
  const void *v49;
  const void *v50;
  uint64_t v51;
  const char *v52;
  size_t v53;
  CFStringRef v54;
  char v55;
  const __CFArray *v56;
  CFIndex Count;
  int v58;
  CFIndex v59;
  const __CFArray *v60;
  const void *v61;
  uint64_t v62;
  CFDateRef v63;
  const __CFDictionary *v64;
  CFStringRef v65;
  const __CFString *v66;
  const char *v67;
  const void *ParseDate;
  double TempDuration;
  double TempPlannedDuration;
  uint64_t v71;
  const void *v72;
  const void *v73;
  CFTypeRef v74;
  const void *v75;
  CFTypeRef v76;
  const void *v77;
  CFTypeRef v78;
  const void *v79;
  uint64_t v81;
  const char *v82;
  const char *v83;
  unsigned __int8 v84;
  int v86;
  CFStringRef v87;
  CFDateRef cf1;
  CFDateRef v89;
  CFStringRef cf;
  const __CFAllocator *alloc;
  const __CFDictionary *theDict;
  void *value;
  int v94;
  CFIndex numBytes;
  CFIndex v96;
  UInt8 *v97;
  void *v98;
  CFTypeRef v99;
  CFTypeRef v100;
  CFTypeRef v101;
  __int128 context;
  __int128 v103;
  double v104;
  double v105;
  char *v106;
  char *v107[2];

  v5 = (char *)a2;
  v105 = -1.0;
  v106 = (char *)a2;
  v104 = -1.0;
  context = 0u;
  v103 = 0u;
  v100 = 0;
  v101 = 0;
  v99 = 0;
  v98 = 0;
  alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v7 = 0;
  v8 = 0;
  cf1 = 0;
  v89 = 0;
  v84 = 0;
  v86 = 0;
  cf = 0;
  v87 = 0;
  while (1)
  {
    v9 = *v5;
    v10 = v9 > 0xD;
    v11 = (1 << v9) & 0x2401;
    if (!v10 && v11 != 0)
    {
      if ((_DWORD)v7)
      {
        v54 = 0;
        v19 = 0;
        v31 = v87;
        goto LABEL_210;
      }
      v31 = v87;
      if (!v8)
      {
        v7 = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294954977, a4, CFSTR("%s: missing id"), "#EXT-X-DATERANGE");
        v19 = 0;
        v54 = 0;
        v64 = theDict;
        v48 = v89;
        v65 = cf;
        v63 = cf1;
        goto LABEL_225;
      }
      v32 = 0;
      DWORD2(v103) = 0;
      *((_QWORD *)&context + 1) = a4;
      do
      {
        DateRangeSpecifiers = (const __CFArray *)FigMediaPlaylistGetDateRangeSpecifiers(a1);
        if (DateRangeSpecifiers)
          DateRangeSpecifiers = (const __CFArray *)CFArrayGetCount(DateRangeSpecifiers);
        if (v32 >= (uint64_t)DateRangeSpecifiers)
          goto LABEL_133;
        v34 = (const __CFArray *)FigMediaPlaylistGetDateRangeSpecifiers(a1);
        ValueAtIndex = (char *)CFArrayGetValueAtIndex(v34, v32);
        Identifier = (const void *)FigDateRangeSpecifierGetIdentifier((uint64_t)ValueAtIndex);
        ++v32;
      }
      while (!CFEqual(v8, Identifier));
      if (ValueAtIndex)
      {
        *(_QWORD *)&context = ValueAtIndex;
        *(_QWORD *)&v103 = FigMediaPlaylistGetParseDate(a1);
        BYTE12(v103) = 0;
        CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)TaggedRangeUniquenessApplier, &context);
        v7 = DWORD2(v103);
        *a3 = BYTE12(v103);
        if ((_DWORD)v7)
        {
LABEL_209:
          v54 = 0;
          v19 = 0;
LABEL_210:
          v64 = theDict;
          v48 = v89;
          goto LABEL_211;
        }
        if (!v89
          || (StartDate = (const void *)FigDateRangeSpecifierGetStartDate((uint64_t)ValueAtIndex), CFEqual(v89, StartDate)))
        {
          if (cf1)
          {
            if (FigDateRangeSpecifierGetEndDate((uint64_t)ValueAtIndex))
            {
              EndDate = (const void *)FigDateRangeSpecifierGetEndDate((uint64_t)ValueAtIndex);
              if (!CFEqual(cf1, EndDate))
              {
                v66 = CFSTR("%s has changed");
                v67 = "END-DATE";
                goto LABEL_207;
              }
            }
          }
          if (cf
            && FigDateRangeSpecifierGetTaggedRangeClass((uint64_t)ValueAtIndex)
            && (TaggedRangeClass = (const void *)FigDateRangeSpecifierGetTaggedRangeClass((uint64_t)ValueAtIndex),
                !CFEqual(cf, TaggedRangeClass)))
          {
            v66 = CFSTR("%s has changed");
            v67 = "CLASS";
          }
          else if (v87
                 && FigDateRangeSpecifierGetTaggedRangeCue((uint64_t)ValueAtIndex)
                 && (TaggedRangeCue = (const void *)FigDateRangeSpecifierGetTaggedRangeCue((uint64_t)ValueAtIndex),
                     !CFEqual(v87, TaggedRangeCue)))
          {
            v66 = CFSTR("%s has changed");
            v67 = "CUE";
          }
          else
          {
            v41 = v101;
            if (v101
              && FigDateRangeSpecifierGetScte35cmd((uint64_t)ValueAtIndex)
              && (Scte35cmd = (const void *)FigDateRangeSpecifierGetScte35cmd((uint64_t)ValueAtIndex),
                  !CFEqual(v41, Scte35cmd)))
            {
              v66 = CFSTR("%s has changed");
              v67 = "SCTE35-CMD";
            }
            else
            {
              v43 = v100;
              if (v100
                && FigDateRangeSpecifierGetScte35in((uint64_t)ValueAtIndex)
                && (Scte35in = (const void *)FigDateRangeSpecifierGetScte35in((uint64_t)ValueAtIndex),
                    !CFEqual(v43, Scte35in)))
              {
                v66 = CFSTR("%s has changed");
                v67 = "SCTE35-IN";
              }
              else
              {
                v45 = v99;
                if (v99
                  && FigDateRangeSpecifierGetScte35out((uint64_t)ValueAtIndex)
                  && (Scte35out = (const void *)FigDateRangeSpecifierGetScte35out((uint64_t)ValueAtIndex),
                      !CFEqual(v45, Scte35out)))
                {
                  v66 = CFSTR("%s has changed");
                  v67 = "SCTE35-OUT";
                }
                else
                {
                  if (!v86
                    || !FigDateRangeSpecifierGetEndOnNextSet((uint64_t)ValueAtIndex)
                    || FigDateRangeSpecifierGetEndOnNext((uint64_t)ValueAtIndex) == v84)
                  {
                    if (v84)
                    {
                      if (FigDateRangeSpecifierGetTempEndDate((uint64_t)ValueAtIndex))
                      {
                        v47 = "END-DATE";
LABEL_206:
                        v83 = v47;
                        v66 = CFSTR("%s: %s indicated after %s specified");
                        v82 = "END-ON-NEXT";
                        v67 = "#EXT-X-DATERANGE";
                        goto LABEL_207;
                      }
                      if (FigDateRangeSpecifierGetTempDuration((uint64_t)ValueAtIndex) >= 0.0)
                      {
                        v47 = "DURATION";
                        goto LABEL_206;
                      }
                    }
                    if (v105 >= 0.0 && FigDateRangeSpecifierGetDuration((uint64_t)ValueAtIndex) == -1.0
                      || cf1 && !FigDateRangeSpecifierGetEndDate((uint64_t)ValueAtIndex))
                    {
                      ParseDate = (const void *)FigMediaPlaylistGetParseDate(a1);
                      FigDateRangeSpecifierSetModificationTimestamp((uint64_t)ValueAtIndex, ParseDate);
                      *a3 = 1;
                    }
                    if (FigDateRangeSpecifierGetTempDuration((uint64_t)ValueAtIndex) >= 0.0 && v105 >= 0.0)
                    {
                      TempDuration = FigDateRangeSpecifierGetTempDuration((uint64_t)ValueAtIndex);
                      if (TempDuration != v105)
                      {
                        v66 = CFSTR("duplicate duration");
LABEL_171:
                        v7 = 4294954654;
                        v71 = 4294955031;
LABEL_208:
                        _StreamPlaylistLogError(4294954654, v71, a4, v66, v81, v82, v83);
                        goto LABEL_209;
                      }
                    }
                    v54 = 0;
                    v55 = 1;
                    if (FigDateRangeSpecifierGetTempPlannedDuration((uint64_t)ValueAtIndex) >= 0.0 && v104 >= 0.0)
                    {
                      TempPlannedDuration = FigDateRangeSpecifierGetTempPlannedDuration((uint64_t)ValueAtIndex);
                      if (TempPlannedDuration != v104)
                      {
                        v66 = CFSTR("duplicate planned duration");
                        goto LABEL_171;
                      }
                      v54 = 0;
                    }
                    goto LABEL_137;
                  }
                  v66 = CFSTR("%s has changed");
                  v67 = "END-ON-NEXT";
                }
              }
            }
          }
LABEL_207:
          v81 = (uint64_t)v67;
          v7 = 4294954654;
          v71 = 4294955030;
          goto LABEL_208;
        }
        v7 = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955030, a4, CFSTR("%s has changed"), "START-DATE");
        v54 = 0;
        v19 = 0;
        v64 = theDict;
        v48 = v89;
      }
      else
      {
LABEL_133:
        v48 = v89;
        if (v89)
        {
          v107[0] = 0;
          v49 = (const void *)FigMediaPlaylistGetParseDate(a1);
          v50 = (const void *)FigMediaPlaylistGetParseDate(a1);
          v51 = FigDateRangeSpecifierCreate(0, 0, 0, 0, 0, 0, 0, 0, -1.0, -1.0, -1.0, -1.0, 0, 0, 0, 0, 0, 0, 0,
                  v49,
                  v50,
                  (uint64_t *)v107);
          if ((_DWORD)v51)
          {
            v7 = v51;
            v64 = theDict;
            v63 = cf1;
            if (v107[0])
              CFRelease(v107[0]);
            v54 = 0;
            v19 = 0;
            goto LABEL_203;
          }
          FigMediaPlaylistAddDateRangeSpecifier(a1, v107[0]);
          ValueAtIndex = v107[0];
          FigDateRangeSpecifierSetIdentifier((uint64_t)v107[0], v8);
          FigDateRangeSpecifierSetStartDate((uint64_t)ValueAtIndex, v89);
          v52 = *(const char **)(a4 + 32);
          v53 = strcspn(v52, "\r\n");
          v54 = CFStringCreateWithBytes(alloc, (const UInt8 *)v52, v53, 0x8000100u, 1u);
          if (!v54)
          {
            v7 = FigSignalErrorAt();
            v63 = cf1;
            goto LABEL_221;
          }
          FigDateRangeSpecifierSetTaggedRangeLine((uint64_t)ValueAtIndex, v54);
          *(_QWORD *)&context = ValueAtIndex;
          *(_QWORD *)&v103 = FigMediaPlaylistGetParseDate(a1);
          CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)TaggedRangeUniquenessApplier, &context);
          v55 = 0;
          *a3 = 1;
LABEL_137:
          if (cf)
          {
            if (FigDateRangeSpecifierGetTaggedRangeClass((uint64_t)ValueAtIndex))
            {
LABEL_176:
              if (v31 && !FigDateRangeSpecifierGetTaggedRangeCue((uint64_t)ValueAtIndex))
              {
                FigDateRangeSpecifierSetTaggedRangeCue((uint64_t)ValueAtIndex, v31);
                CFRelease(v31);
                v31 = 0;
              }
              v74 = v101;
              if (v101 && !FigDateRangeSpecifierGetScte35cmd((uint64_t)ValueAtIndex))
              {
                FigDateRangeSpecifierSetScte35cmd((uint64_t)ValueAtIndex, v74);
                CFRelease(v74);
                v101 = 0;
                v75 = (const void *)FigMediaPlaylistGetParseDate(a1);
                FigDateRangeSpecifierSetValueForTagsFirstFoundDateDict((uint64_t)ValueAtIndex, CFSTR("SCTE35-CMD"), v75);
              }
              v76 = v100;
              if (v100 && !FigDateRangeSpecifierGetScte35in((uint64_t)ValueAtIndex))
              {
                FigDateRangeSpecifierSetScte35in((uint64_t)ValueAtIndex, v76);
                CFRelease(v76);
                v100 = 0;
                v77 = (const void *)FigMediaPlaylistGetParseDate(a1);
                FigDateRangeSpecifierSetValueForTagsFirstFoundDateDict((uint64_t)ValueAtIndex, CFSTR("SCTE35-IN"), v77);
              }
              v78 = v99;
              if (v99 && !FigDateRangeSpecifierGetScte35out((uint64_t)ValueAtIndex))
              {
                FigDateRangeSpecifierSetScte35out((uint64_t)ValueAtIndex, v78);
                CFRelease(v78);
                v99 = 0;
                v79 = (const void *)FigMediaPlaylistGetParseDate(a1);
                FigDateRangeSpecifierSetValueForTagsFirstFoundDateDict((uint64_t)ValueAtIndex, CFSTR("SCTE35-OUT"), v79);
              }
              if (cf1)
              {
                FigDateRangeSpecifierSetTempEndDate((uint64_t)ValueAtIndex, cf1);
                CFRelease(cf1);
              }
              if (v105 >= 0.0)
                FigDateRangeSpecifierSetTempDuration((uint64_t)ValueAtIndex, v105);
              if (v104 >= 0.0)
                FigDateRangeSpecifierSetTempPlannedDuration((uint64_t)ValueAtIndex, v104);
              if (v86)
              {
                FigDateRangeSpecifierSetEndOnNext((uint64_t)ValueAtIndex, v84);
                FigDateRangeSpecifierSetEndOnNextSet((uint64_t)ValueAtIndex, 1);
                if (FigDateRangeSpecifierGetEndOnNext((uint64_t)ValueAtIndex)
                  && FigDateRangeSpecifierGetTempEndDate((uint64_t)ValueAtIndex))
                {
                  _StreamPlaylistLogError(0, 4294955030, a4, CFSTR("%s: %s and %s both specified"), "#EXT-X-DATERANGE", "END-ON-NEXT", "END-DATE");
                  FigDateRangeSpecifierSetTempEndDate((uint64_t)ValueAtIndex, 0);
                }
                if (FigDateRangeSpecifierGetEndOnNext((uint64_t)ValueAtIndex)
                  && FigDateRangeSpecifierGetTempDuration((uint64_t)ValueAtIndex) >= 0.0)
                {
                  _StreamPlaylistLogError(0, 4294955030, a4, CFSTR("%s: %s and %s both specified"), "#EXT-X-DATERANGE", "END-ON-NEXT", "DURATION");
                  FigDateRangeSpecifierSetTempDuration((uint64_t)ValueAtIndex, -1.0);
                }
              }
              FigDateRangeSpecifierSetReadInCurrent((uint64_t)ValueAtIndex, 1);
              v7 = 0;
              v63 = 0;
              if ((v55 & 1) != 0)
              {
                v19 = 0;
                v64 = theDict;
                v48 = v89;
LABEL_203:
                v65 = cf;
                goto LABEL_224;
              }
LABEL_221:
              v65 = cf;
              if (ValueAtIndex)
                CFRelease(ValueAtIndex);
              v19 = 0;
              v64 = theDict;
              v48 = v89;
              goto LABEL_224;
            }
            FigDateRangeSpecifierSetTaggedRangeClass((uint64_t)ValueAtIndex, cf);
            CFRelease(cf);
            if (FigDateRangeSpecifierGetTaggedRangeClass((uint64_t)ValueAtIndex))
            {
              v56 = (const __CFArray *)FigMediaPlaylistGetDateRangeSpecifiers(a1);
              if (v56)
              {
                Count = CFArrayGetCount(v56);
                if (Count >= 1)
                {
                  v58 = 0;
                  v59 = Count + 1;
                  while (1)
                  {
                    v60 = (const __CFArray *)FigMediaPlaylistGetDateRangeSpecifiers(a1);
                    v61 = CFArrayGetValueAtIndex(v60, v59 - 2);
                    v62 = (uint64_t)v61;
                    if (v58)
                    {
                      FigDateRangeSpecifierGetTaggedRangeClass((uint64_t)v61);
                      if (FigCFEqual())
                        break;
                    }
                    if ((char *)v62 == ValueAtIndex)
                      v58 = 1;
                    if ((unint64_t)--v59 < 2)
                      goto LABEL_148;
                  }
                  if (!v62)
                  {
LABEL_148:
                    cf = 0;
                    v31 = v87;
                    goto LABEL_176;
                  }
                  v31 = v87;
                  if (FigDateRangeSpecifierGetEndOnNext(v62))
                  {
                    v72 = (const void *)FigDateRangeSpecifierGetStartDate((uint64_t)ValueAtIndex);
                    FigDateRangeSpecifierSetTempEndDate(v62, v72);
                    v73 = (const void *)FigMediaPlaylistGetParseDate(a1);
                    FigDateRangeSpecifierSetModificationTimestamp(v62, v73);
                    cf = 0;
                    *a3 = 1;
                    goto LABEL_176;
                  }
                }
              }
            }
          }
          cf = 0;
          goto LABEL_176;
        }
        v7 = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294954977, a4, CFSTR("%s: missing date range"), "#EXT-X-DATERANGE");
        v54 = 0;
        v19 = 0;
        v64 = theDict;
      }
LABEL_211:
      v65 = cf;
      v63 = cf1;
      if (!v8)
        goto LABEL_225;
LABEL_224:
      CFRelease(v8);
      goto LABEL_225;
    }
    v107[0] = 0;
    v96 = 0;
    v97 = 0;
    numBytes = 0;
    v94 = 0;
    free(v98);
    v98 = 0;
    v7 = sp_ParseAttribute("#EXT-X-DATERANGE", v5, 1, 0, v107, &v96, (const char **)&v97, (size_t *)&numBytes, (const char **)&v106, &v94, (UInt8 **)&v98, a4);
    if ((_DWORD)v7 && !*(_BYTE *)(a4 + 41) || (v13 = v94, (v94 & 2) != 0))
    {
LABEL_149:
      v19 = 0;
      goto LABEL_150;
    }
    v14 = v107[0];
    if (v107[0])
    {
      v15 = v97;
      if (v97)
        break;
    }
LABEL_81:
    v5 = v106;
  }
  v16 = v96;
  switch(v96)
  {
    case 2:
      if (strncmp(v107[0], "ID", 2uLL))
        goto LABEL_40;
      if (v8)
      {
        v7 = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955031, a4, CFSTR("duplicate id"), v81);
        goto LABEL_80;
      }
      if ((v13 & 1) == 0)
      {
        v7 = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955030, a4, CFSTR("Invalid %s: %s: %s"), v106, "ID", v15);
        v8 = 0;
        goto LABEL_80;
      }
      v8 = CFStringCreateWithBytes(alloc, v15, numBytes, 0x8000100u, 1u);
      if (v8)
        goto LABEL_47;
      v19 = 0;
      goto LABEL_248;
    case 3:
      if (strncmp(v107[0], "CUE", 3uLL))
        goto LABEL_40;
      if (v87)
      {
        v7 = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955031, a4, CFSTR("duplicate cue"), v81);
        goto LABEL_80;
      }
      v87 = CFStringCreateWithBytes(alloc, v15, numBytes, 0x8000100u, 1u);
      goto LABEL_47;
    case 5:
      if (strncmp(v107[0], "CLASS", 5uLL))
        goto LABEL_40;
      if (cf)
      {
        v7 = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955031, a4, CFSTR("duplicate class"), v81);
        goto LABEL_80;
      }
      cf = CFStringCreateWithBytes(alloc, v15, numBytes, 0x8000100u, 1u);
      goto LABEL_47;
    case 8:
      if (!strncmp(v107[0], "END-DATE", 8uLL))
      {
        if (cf1)
        {
          v7 = 4294954654;
          _StreamPlaylistLogError(4294954654, 4294955031, a4, CFSTR("duplicate endDate"), v81);
          goto LABEL_80;
        }
        if ((v13 & 1) != 0)
        {
          value = 0;
          v29 = FigCFParseISO8601Date();
          v7 = v29;
          if ((_DWORD)v29)
          {
            _StreamPlaylistLogError(v29, 4294955017, a4, CFSTR("%s: ISO8601 Date parse error"), "#EXT-X-DATERANGE");
            cf1 = 0;
          }
          else
          {
            cf1 = CFDateCreate(alloc, *(CFAbsoluteTime *)&value);
          }
          goto LABEL_47;
        }
        v7 = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955030, a4, CFSTR("Invalid %s: %s: no quotes"), "#EXT-X-DATERANGE", "END-DATE");
        cf1 = 0;
        goto LABEL_80;
      }
      if (strncmp(v14, "DURATION", 8uLL))
        goto LABEL_40;
      if (v105 < 0.0)
      {
        v7 = sp_strtod((const char *)v15, 0, &v105, 0, (uint64_t)"Date Range Duration", a4);
        if (!(_DWORD)v7)
        {
          v17 = v105;
LABEL_63:
          if (v17 < 0.0)
          {
            v7 = 4294954654;
            _StreamPlaylistLogError(4294954654, 4294955032, a4, CFSTR("illegal duration value"), v81);
            goto LABEL_80;
          }
        }
LABEL_47:
        if (!(_DWORD)v7)
          goto LABEL_81;
        goto LABEL_80;
      }
      v7 = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294955031, a4, CFSTR("duplicate duration"), v81);
      goto LABEL_80;
    case 9:
      if (strncmp(v107[0], "SCTE35-IN", 9uLL))
        goto LABEL_40;
      if (v100)
      {
        v18 = "SCTE35-IN";
        goto LABEL_67;
      }
      v24 = numBytes;
      v25 = &v100;
      v26 = v15;
      v27 = "Date Range SCTE35_IN";
      goto LABEL_95;
    case 10:
      if (!strncmp(v107[0], "START-DATE", 0xAuLL))
      {
        if (v89)
        {
          v7 = 4294954654;
          _StreamPlaylistLogError(4294954654, 4294955031, a4, CFSTR("duplicate startDate"), v81);
          goto LABEL_80;
        }
        if ((v13 & 1) != 0)
        {
          value = 0;
          v30 = FigCFParseISO8601Date();
          v7 = v30;
          if ((_DWORD)v30)
          {
            _StreamPlaylistLogError(v30, 4294955017, a4, CFSTR("%s: ISO8601 Date parse error"), "#EXT-X-DATERANGE");
            v89 = 0;
          }
          else
          {
            v89 = CFDateCreate(alloc, *(CFAbsoluteTime *)&value);
          }
          goto LABEL_47;
        }
        v7 = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955030, a4, CFSTR("Invalid %s: %s: no quotes"), "#EXT-X-DATERANGE", "START-DATE");
        v89 = 0;
LABEL_80:
        if (!*(_BYTE *)(a4 + 41))
          goto LABEL_149;
        goto LABEL_81;
      }
      if (!strncmp(v14, "SCTE35-CMD", 0xAuLL))
      {
        if (v101)
        {
          v18 = "SCTE35-CMD";
          goto LABEL_67;
        }
        v24 = numBytes;
        v25 = &v101;
        v26 = v15;
        v27 = "Date Range SCTE35_CMD";
LABEL_95:
        v7 = sp_strtohex(v26, v24, (CFDataRef *)v25, (uint64_t)v27, a4);
        goto LABEL_47;
      }
      if (!strncmp(v14, "SCTE35-OUT", 0xAuLL))
      {
        if (v99)
        {
          v18 = "SCTE35-OUT";
LABEL_67:
          v7 = 4294954654;
          _StreamPlaylistLogError(4294954654, 4294955031, a4, CFSTR("duplicate %s"), v18);
          goto LABEL_80;
        }
        v24 = numBytes;
        v25 = &v99;
        v26 = v15;
        v27 = "Date Range SCTE35_OUTE";
        goto LABEL_95;
      }
LABEL_40:
      if (strncmp(v14, "X-", 2uLL))
      {
        _StreamPlaylistLogError(0, 4294955022, a4, CFSTR("unrecognized attribute %.*s"), v16, v14);
        goto LABEL_47;
      }
      v19 = CFStringCreateWithBytes(alloc, (const UInt8 *)v14, v16, 0x8000100u, 1u);
      if (!v19)
        goto LABEL_248;
      if (CFDictionaryGetValue(theDict, v19))
      {
        v7 = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955031, a4, CFSTR("duplicate key entry"));
LABEL_45:
        v20 = v19;
LABEL_46:
        CFRelease(v20);
        goto LABEL_47;
      }
      v21 = numBytes;
      if ((v13 & 1) == 0)
      {
        if ((unint64_t)numBytes >= 3 && !strncasecmp((const char *)v15, "0x", 2uLL))
        {
          value = 0;
          v7 = sp_strtohex(v15, v21, (CFDataRef *)&value, (uint64_t)"Date range hex", a4);
          if (!(_DWORD)v7)
          {
            v28 = value;
            if (value)
            {
              CFDictionaryAddValue(theDict, v19, value);
              CFRelease(v28);
            }
          }
        }
        else
        {
          value = 0;
          v7 = sp_strtod((const char *)v15, 0, (double *)&value, 0, (uint64_t)"tag double value", a4);
          if (!(_DWORD)v7)
            v7 = FigCFDictionarySetDouble();
        }
        goto LABEL_45;
      }
      v22 = CFStringCreateWithBytes(alloc, v15, numBytes, 0x8000100u, 1u);
      if (v22)
      {
        v23 = v22;
        CFDictionaryAddValue(theDict, v19, v22);
        CFRelease(v19);
        v20 = v23;
        goto LABEL_46;
      }
LABEL_248:
      v7 = FigSignalErrorAt();
LABEL_150:
      v31 = v87;
      v63 = cf1;
      v64 = theDict;
      v48 = v89;
      v65 = cf;
      v54 = 0;
      if (v8)
        goto LABEL_224;
LABEL_225:
      if (v64)
        CFRelease(v64);
      if (v63)
        CFRelease(v63);
      if (v48)
        CFRelease(v48);
      if (v19)
        CFRelease(v19);
      if (v65)
        CFRelease(v65);
      if (v31)
        CFRelease(v31);
      if (v101)
        CFRelease(v101);
      if (v100)
        CFRelease(v100);
      if (v99)
        CFRelease(v99);
      if (v54)
        CFRelease(v54);
      free(v98);
      return v7;
    case 11:
      if (strncmp(v107[0], "END-ON-NEXT", 0xBuLL))
        goto LABEL_40;
      if (!strncasecmp((const char *)v15, "YES", 3uLL))
      {
        v84 = 1;
      }
      else
      {
        if (strncasecmp((const char *)v15, "NO", 2uLL))
        {
          _StreamPlaylistLogError(4294954654, 4294955030, a4, CFSTR("%s: read error"), "END-ON-NEXT", v82);
          goto LABEL_47;
        }
        v84 = 0;
      }
      v86 = 1;
      goto LABEL_47;
    case 16:
      if (strncmp(v107[0], "PLANNED-DURATION", 0x10uLL))
        goto LABEL_40;
      if (v104 >= 0.0)
      {
        v7 = 4294954654;
        _StreamPlaylistLogError(4294954654, 4294955031, a4, CFSTR("duplicate planned duration"), v81);
        goto LABEL_80;
      }
      v7 = sp_strtod((const char *)v15, 0, &v104, 0, (uint64_t)"Date Range Planned Duration", a4);
      if ((_DWORD)v7)
        goto LABEL_47;
      v17 = v104;
      goto LABEL_63;
    default:
      goto LABEL_40;
  }
}

uint64_t PlaylistProcessVariableTag(const char *a1, const __CFDictionary *a2, const __CFDictionary *a3, _BYTE *a4, uint64_t a5)
{
  char *v6;
  uint64_t v7;
  unsigned int v8;
  BOOL v9;
  int v10;
  char v12;
  const UInt8 *v13;
  const char *v14;
  CFStringRef v15;
  CFStringRef v16;
  CFStringRef v17;
  CFStringRef v18;
  const __CFString *Value;
  const __CFString *v20;
  const __CFString *v22;
  const __CFString *v23;
  const __CFString *v24;
  CFStringRef v25;
  const __CFAllocator *alloc;
  CFStringRef cf;
  CFStringRef v31;
  CFStringRef v32;
  CFStringRef v33;
  int v34;
  CFIndex numBytes;
  uint64_t v36;
  const UInt8 *v37;
  char *v38;
  UInt8 *v39;
  char *v40;

  v6 = (char *)a1;
  cf = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v7 = 0;
  v39 = 0;
  v40 = (char *)a1;
  alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  while (1)
  {
    v8 = *v6;
    v9 = v8 > 0xD;
    v10 = (1 << v8) & 0x2401;
    if (!v9 && v10 != 0)
    {
      v16 = v32;
      v15 = v33;
      v18 = cf;
      v17 = v31;
      if (v31 && cf && v33)
      {
        v23 = CFSTR("%s: name can only come from one of NAME, IMPORT, and QUERYPARAM");
      }
      else
      {
        if (!cf)
        {
          if (v31)
          {
            if (CFDictionaryGetValue(*(CFDictionaryRef *)(a5 + 24), v31))
            {
              v24 = CFSTR("%s: IMPORT %@ already declared");
            }
            else
            {
              if (a2)
              {
                Value = (const __CFString *)CFDictionaryGetValue(a2, v31);
                if (!Value)
                {
                  v7 = 4294954654;
                  _StreamPlaylistLogError(4294954654, 4294955032, a5, CFSTR("%s: IMPORT %@ not found in multivariant playlist"), "#EXT-X-DEFINE", v31);
                  goto LABEL_65;
                }
                v16 = Value;
                CFRetain(Value);
                CFDictionarySetValue(*(CFMutableDictionaryRef *)(a5 + 24), v31, v16);
                goto LABEL_64;
              }
              v24 = CFSTR("%s: IMPORT %@ found but no imports available");
            }
            v7 = 4294954654;
            _StreamPlaylistLogError(4294954654, 4294955032, a5, v24, "#EXT-X-DEFINE", v31);
            goto LABEL_49;
          }
          if (v33)
          {
            if (CFDictionaryGetValue(*(CFDictionaryRef *)(a5 + 24), v33))
            {
              v22 = CFSTR("%s: QUERYPARAM %@ already declared");
            }
            else
            {
              if (a3)
              {
                v20 = (const __CFString *)CFDictionaryGetValue(a3, v33);
                if (!v20)
                {
                  v7 = 4294954654;
                  _StreamPlaylistLogError(4294954654, 4294955032, a5, CFSTR("%s: QUERYPARAM %@ not found in query parameters"), "#EXT-X-DEFINE", v33);
                  goto LABEL_66;
                }
                v16 = v20;
                CFRetain(v20);
                CFDictionarySetValue(*(CFMutableDictionaryRef *)(a5 + 24), v33, v16);
                if (a4)
                {
                  v17 = 0;
                  *a4 = 1;
                }
                else
                {
                  v7 = FigSignalErrorAt();
                  v17 = 0;
                }
                goto LABEL_64;
              }
              v22 = CFSTR("%s: QUERYPARAM %@ found, but no query parameters available");
            }
            v25 = v33;
          }
          else
          {
            v22 = CFSTR("%s: Did not find NAME, IMPORT or QUERYPARAM");
          }
          v7 = 4294954654;
          _StreamPlaylistLogError(4294954654, 4294955032, a5, v22, "#EXT-X-DEFINE", v25);
          v17 = 0;
          goto LABEL_49;
        }
        if (v32)
        {
          if (CFDictionaryGetValue(*(CFDictionaryRef *)(a5 + 24), cf))
          {
            v23 = CFSTR("%s: NAME %@ already declared");
          }
          else
          {
            if (!a2 || !CFDictionaryGetValue(a2, cf))
            {
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(a5 + 24), cf, v32);
LABEL_48:
              CFRelease(v18);
              goto LABEL_49;
            }
            v23 = CFSTR("%s: NAME %@ declared in multivariant playlist cannot be redeclared");
          }
        }
        else
        {
          v23 = CFSTR("%s: Must have VALUE for NAME %@");
        }
        v25 = cf;
      }
      v7 = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294955032, a5, v23, "#EXT-X-DEFINE", v25);
      goto LABEL_48;
    }
    v38 = 0;
    v36 = 0;
    v37 = 0;
    numBytes = 0;
    v34 = 0;
    free(v39);
    v39 = 0;
    v7 = sp_ParseAttribute("#EXT-X-DEFINE", v6, 0, 0, &v38, &v36, (const char **)&v37, (size_t *)&numBytes, (const char **)&v40, &v34, &v39, a5);
    if ((_DWORD)v7)
    {
      if (!*(_BYTE *)(a5 + 41))
        break;
    }
    v12 = v34;
    if ((v34 & 2) != 0)
      break;
    if (v38)
    {
      v13 = v37;
      if (v37)
      {
        switch(v36)
        {
          case 4:
            if (!strncmp(v38, "NAME", 4uLL))
            {
              if ((v12 & 1) == 0)
              {
                v14 = "NAME";
                goto LABEL_25;
              }
              if (cf)
                CFRelease(cf);
              cf = CFStringCreateWithBytes(alloc, v13, numBytes, 0x8000100u, 1u);
            }
            break;
          case 5:
            if (!strncmp(v38, "VALUE", 5uLL))
            {
              if ((v12 & 1) == 0)
              {
                v14 = "VALUE";
                goto LABEL_25;
              }
              if (v32)
                CFRelease(v32);
              v32 = CFStringCreateWithBytes(alloc, v13, numBytes, 0x8000100u, 1u);
            }
            break;
          case 6:
            if (!strncmp(v38, "IMPORT", 6uLL))
            {
              if ((v12 & 1) == 0)
              {
                v14 = "IMPORT";
                goto LABEL_25;
              }
              if (v31)
                CFRelease(v31);
              v31 = CFStringCreateWithBytes(alloc, v13, numBytes, 0x8000100u, 1u);
            }
            break;
          case 10:
            if (!strncmp(v38, "QUERYPARAM", 0xAuLL))
            {
              if ((v12 & 1) != 0)
              {
                if (v33)
                  CFRelease(v33);
                v33 = CFStringCreateWithBytes(alloc, v13, numBytes, 0x8000100u, 1u);
              }
              else
              {
                v14 = "QUERYPARAM";
LABEL_25:
                v7 = 4294954654;
                _StreamPlaylistLogError(4294954654, 4294955032, a5, CFSTR("%s %s: missing quotes"), "#EXT-X-DEFINE", v14);
              }
            }
            break;
          default:
            break;
        }
      }
    }
    v6 = v40;
  }
  v16 = v32;
  v15 = v33;
  v18 = cf;
  v17 = v31;
  if (cf)
    goto LABEL_48;
LABEL_49:
  if (!v16)
  {
    if (!v17)
      goto LABEL_51;
    goto LABEL_65;
  }
LABEL_64:
  CFRelease(v16);
  if (!v17)
  {
LABEL_51:
    if (!v15)
      goto LABEL_67;
    goto LABEL_66;
  }
LABEL_65:
  CFRelease(v17);
  if (!v15)
    goto LABEL_67;
LABEL_66:
  CFRelease(v15);
LABEL_67:
  free(v39);
  return v7;
}

uint64_t PlaylistProcessServerControlTag(uint64_t a1, const char *a2, uint64_t a3, double a4, double a5)
{
  char *v8;
  unsigned int v9;
  BOOL v10;
  int v11;
  uint64_t v13;
  char *v14;
  char *v15;
  uint64_t matched;
  __int16 *v17;
  double v18;
  uint64_t v19;
  int v20;
  int HasSkipDeltaBoundary;
  double v22;
  const char *v23;
  int v26;
  size_t v27;
  uint64_t v28;
  char *v29;
  char *__s1;
  __int16 v31;
  void *v32;
  double v33;
  double v34;
  double v35;
  char *v36;

  v36 = (char *)a2;
  v34 = 0.0;
  v35 = 0.0;
  v32 = 0;
  v33 = 0.0;
  v31 = 0;
  while (1)
  {
    v8 = v36;
    v9 = *v36;
    v10 = v9 > 0xD;
    v11 = (1 << v9) & 0x2401;
    if (!v10 && v11 != 0)
      break;
    v29 = 0;
    __s1 = 0;
    v28 = 0;
    v26 = 0;
    free(v32);
    v32 = 0;
    v13 = sp_ParseAttribute("#EXT-X-SERVER-CONTROL", v8, 1, 0, &__s1, &v28, (const char **)&v29, &v27, (const char **)&v36, &v26, (UInt8 **)&v32, a3);
    if ((_DWORD)v13 && !*(_BYTE *)(a3 + 41) || (v26 & 2) != 0)
      goto LABEL_50;
    v14 = __s1;
    if (!__s1)
      goto LABEL_30;
    v15 = v29;
    if (!v29)
      goto LABEL_30;
    if (v28 > 15)
    {
      if (v28 != 16)
      {
        if (v28 != 19 || strncmp(__s1, "CAN-SKIP-DATERANGES", 0x13uLL))
          goto LABEL_30;
        v17 = &v31;
LABEL_28:
        matched = sp_MatchYesOrNo((uint64_t)v14, v15, a3, v17);
LABEL_29:
        v13 = matched;
        goto LABEL_30;
      }
      if (!strncmp(__s1, "CAN-BLOCK-RELOAD", 0x10uLL))
      {
        v17 = (__int16 *)((char *)&v31 + 1);
        goto LABEL_28;
      }
    }
    else if (v28 == 9)
    {
      if (!strncmp(__s1, "HOLD-BACK", 9uLL))
      {
        v13 = sp_strtod(v15, 0, &v34, 0, (uint64_t)"holdback", a3);
        if (!(_DWORD)v13)
        {
          v18 = v34;
          if (v34 <= 0.0)
          {
            v23 = "HOLD-BACK";
LABEL_42:
            v13 = 4294954654;
            _StreamPlaylistLogError(4294954654, 4294955032, a3, CFSTR("%s must be positive"), v18, v23);
LABEL_43:
            v19 = a1;
            FigMediaPlaylistSetDoesServerSupportsBlockingReload(a1, SHIBYTE(v31));
            FigMediaPlaylistSetSkipDeltaBoundary(a1, v35);
            FigMediaPlaylistSetCanSkipDATERANGES(a1, v31);
            goto LABEL_44;
          }
        }
      }
    }
    else if (v28 == 14)
    {
      if (!strncmp(__s1, "CAN-SKIP-UNTIL", 0xEuLL))
      {
        v13 = sp_strtod(v15, 0, &v35, 0, (uint64_t)"skip boundary", a3);
        if (!(_DWORD)v13)
        {
          v18 = v35;
          if (v35 <= 0.0)
          {
            v23 = "CAN-SKIP-UNTIL";
            goto LABEL_42;
          }
        }
      }
      else if (!strncmp(v14, "PART-HOLD-BACK", 0xEuLL))
      {
        matched = sp_strtod(v15, 0, &v33, 0, (uint64_t)"part holdback", a3);
        goto LABEL_29;
      }
    }
LABEL_30:
    if ((_DWORD)v13)
      goto LABEL_43;
  }
  v19 = a1;
  FigMediaPlaylistSetDoesServerSupportsBlockingReload(a1, SHIBYTE(v31));
  FigMediaPlaylistSetSkipDeltaBoundary(a1, v35);
  v20 = v31;
  FigMediaPlaylistSetCanSkipDATERANGES(a1, v31);
  HasSkipDeltaBoundary = FigMediaPlaylistHasSkipDeltaBoundary(a1);
  if (!v20 || HasSkipDeltaBoundary)
  {
    if (a4 != 0.0 && vabdd_f64(a4, v33) > 2.22044605e-16)
    {
      v13 = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294955032, a3, CFSTR("illegal %s change"), "PART-HOLD-BACK");
      v22 = v34;
      goto LABEL_49;
    }
    v13 = 0;
  }
  else
  {
    v13 = 4294954654;
    _StreamPlaylistLogError(4294954654, 4294955032, a3, CFSTR("%s requires %s"), "CAN-SKIP-DATERANGES", "CAN-SKIP-UNTIL");
  }
LABEL_44:
  FigMediaPlaylistSetPartHoldBackDuration(v19, v33);
  v22 = v34;
  if (a5 != 0.0 && !(_DWORD)v13)
  {
    if (vabdd_f64(a5, v34) > 2.22044605e-16)
    {
      v13 = 4294954654;
      _StreamPlaylistLogError(4294954654, 4294955032, a3, CFSTR("illegal %s change"), v34, "HOLD-BACK");
      goto LABEL_50;
    }
    v13 = 0;
  }
LABEL_49:
  FigMediaPlaylistSetHoldBackDuration(v19, v22);
LABEL_50:
  free(v32);
  return v13;
}

uint64_t PlaylistProcessSkipTag(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t ValueAtIndex, uint64_t *a7, unint64_t *a8, double *a9, CFTypeRef *a10)
{
  char *v15;
  unsigned int v16;
  BOOL v17;
  int v18;
  char v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  CFIndex v24;
  const __CFArray *MediaSegmentSpecifiers;
  const __CFArray *v26;
  unint64_t v27;
  double v28;
  unint64_t v29;
  const void *DateStamp;
  uint64_t NextSegment;
  void *v32;
  int v36;
  size_t v37;
  uint64_t v38;
  char *v39;
  char *__s1;
  CFTypeRef cf;
  void *v42;
  unint64_t v43;
  char *v44;

  v44 = (char *)a2;
  v42 = 0;
  v43 = 0;
  cf = 0;
  while (1)
  {
    v15 = v44;
    v16 = *v44;
    v17 = v16 > 0xD;
    v18 = (1 << v16) & 0x2401;
    if (!v17 && v18 != 0)
    {
      v23 = 0;
      goto LABEL_22;
    }
    v39 = 0;
    __s1 = 0;
    v37 = 0;
    v38 = 0;
    v36 = 0;
    free(v42);
    v42 = 0;
    v23 = sp_ParseAttribute("#EXT-X-SKIP", v15, 1, 1, &__s1, &v38, (const char **)&v39, &v37, (const char **)&v44, &v36, (UInt8 **)&v42, a3);
    if ((_DWORD)v23 && !*(_BYTE *)(a3 + 41))
      goto LABEL_43;
    v20 = v36;
    if ((v36 & 2) != 0)
      goto LABEL_43;
    if (!__s1)
      goto LABEL_21;
    v21 = v39;
    if (!v39)
      goto LABEL_21;
    if (v38 == 27)
      break;
    if (v38 == 16 && !strncmp(__s1, "SKIPPED-SEGMENTS", 0x10uLL))
    {
      v22 = sp_strtoull(v21, 0, &v43, 10, 0, 1, (uint64_t)"SKIPPED-SEGMENTS", a3);
      v23 = 0;
      if ((_DWORD)v22)
      {
        v23 = v22;
        if (!*(_BYTE *)(a3 + 41))
          goto LABEL_43;
LABEL_22:
        if (!ValueAtIndex)
        {
          v24 = 0;
          while (1)
          {
            MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
            if (MediaSegmentSpecifiers)
              MediaSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MediaSegmentSpecifiers);
            if (v24 >= (uint64_t)MediaSegmentSpecifiers)
              break;
            v26 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
            ValueAtIndex = (uint64_t)CFArrayGetValueAtIndex(v26, v24++);
            if (FigMediaSegmentSpecifierGetMediaSequence(ValueAtIndex) == a4)
              goto LABEL_30;
          }
          ValueAtIndex = 0;
        }
LABEL_30:
        v27 = v43;
        if (v43)
        {
          v28 = 0.0;
          v29 = v43;
          do
          {
            if (!ValueAtIndex)
            {
              v23 = 4294949663;
              _StreamPlaylistLogError(4294949663, 4294949663, a3, CFSTR("Delta sequence out of range"));
              goto LABEL_43;
            }
            if (a5)
            {
              FigMediaSegmentSpecifierGetDateStamp(ValueAtIndex);
              if (!FigCFEqual())
              {
                v23 = 4294949663;
                _StreamPlaylistLogError(4294949663, 4294955017, a3, CFSTR("Leading date in Delta does not match"));
                goto LABEL_43;
              }
            }
            DateStamp = (const void *)FigMediaSegmentSpecifierGetDateStamp(ValueAtIndex);
            FigStreamPlaylistValidateMediaEntry(a1, ValueAtIndex, DateStamp);
            v28 = v28 + FigMediaSegmentSpecifierGetTimeInSeconds(ValueAtIndex);
            NextSegment = FigMediaSegmentSpecifierGetNextSegment(ValueAtIndex);
            ValueAtIndex = NextSegment;
            a5 = 0;
            --v29;
          }
          while (v29);
          if (!NextSegment)
            goto LABEL_39;
        }
        else
        {
          v28 = 0.0;
          if (!ValueAtIndex)
          {
LABEL_39:
            v23 = 4294949663;
            _StreamPlaylistLogError(4294949663, 4294949663, a3, CFSTR("Delta exceeded current range"));
            goto LABEL_40;
          }
        }
        *a7 = ValueAtIndex;
LABEL_40:
        *a8 = v27;
        *a9 = v28;
        v32 = v42;
        *a10 = cf;
        free(v32);
        return v23;
      }
    }
LABEL_21:
    if ((_DWORD)v23)
      goto LABEL_22;
  }
  if (strncmp(__s1, "RECENTLY-REMOVED-DATERANGES", 0x1BuLL))
    goto LABEL_21;
  if ((v20 & 1) == 0)
  {
    v23 = 4294954654;
    _StreamPlaylistLogError(4294954654, 4294955032, a3, CFSTR("%s %s: missing quotes"), "#EXT-X-SKIP", "RECENTLY-REMOVED-DATERANGES");
    goto LABEL_22;
  }
  if (!v37)
    goto LABEL_21;
  v23 = PlaylistTokenizeString(v21, v37, a3, 9u, (__CFArray **)&cf);
  if (!(_DWORD)v23)
    goto LABEL_21;
  if (*(_BYTE *)(a3 + 41))
    goto LABEL_22;
LABEL_43:
  if (cf)
    CFRelease(cf);
  return v23;
}

uint64_t sp_GetStringWithReplacement(char *__s, int a2, int a3, char **a4, const char **a5, size_t *a6, UInt8 **a7, uint64_t a8)
{
  int v8;
  char *v10;
  const char *v11;
  size_t v12;
  UInt8 *v13;
  unsigned int v14;
  const char *v16;
  const char *v17;
  size_t v18;
  UInt8 *v19;
  const char *v20;
  char *v21;
  char *v22;
  const UInt8 *v23;
  CFStringRef v24;
  CFStringRef v25;
  const __CFDictionary *v26;
  const char *CStringPtrAndBufferToFree;
  char **v28;
  int v29;
  uint64_t v30;
  size_t v31;
  const char *v32;
  size_t v33;
  size_t v34;
  const char *v35;
  unsigned int v37;
  const __CFAllocator *alloc;
  CFIndex v46;
  UInt8 *v47;

  v8 = a2;
  if (!__s)
  {
    v37 = FigSignalErrorAt();
    v13 = 0;
    if (v8)
      v30 = 4294951057;
    else
      v30 = v37;
    goto LABEL_56;
  }
  v10 = __s;
  if (a2)
  {
    if (*__s != 34)
    {
      v13 = 0;
      v30 = 4294951057;
      goto LABEL_56;
    }
    v10 = __s + 1;
  }
  v11 = 0;
  v12 = 0;
  v13 = 0;
  alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  while (1)
  {
    v14 = *v10;
    if (v14 <= 0xD && ((1 << v14) & 0x2401) != 0)
    {
      v28 = a4;
      if (v8)
        goto LABEL_55;
      v29 = 0;
      goto LABEL_49;
    }
    if (v8 && v14 == 34)
    {
      ++v10;
      v29 = 1;
      v28 = a4;
LABEL_49:
      v30 = 0;
      *v28 = v10;
      *a5 = v11;
      *a6 = v12;
      *a7 = v13;
      v13 = 0;
      if (!v8)
        goto LABEL_56;
      goto LABEL_54;
    }
    if (!a3 || v14 != 123 || v10[1] != 36)
    {
      v17 = 0;
      v18 = 0;
      while (v14 > 0xD || ((1 << v14) & 0x2401) == 0)
      {
        if (a3 && v14 == 123)
        {
          v14 = v10[v18 + 1];
          if (v14 == 36)
            break;
        }
        else
        {
          if (v8 && v14 == 34)
            break;
          v14 = v10[v18 + 1];
        }
        if (!v17)
          v17 = &v10[v18];
        ++v18;
      }
      v19 = 0;
      v10 += v18;
      if (!v11)
        goto LABEL_44;
      goto LABEL_34;
    }
    v46 = 0;
    v47 = 0;
    if (*v10 != 123 || v10[1] != 36)
      goto LABEL_52;
    v16 = v11;
    if (v10[2] == 36)
    {
      v10 += 3;
      goto LABEL_42;
    }
    if (!sp_MatchAttributeName((uint64_t)(v10 + 2), 1, &v47, &v46))
      goto LABEL_52;
    v23 = &v47[v46];
    if (v47[v46] != 125)
      goto LABEL_52;
    v24 = CFStringCreateWithBytes(alloc, v47, v46, 0x8000100u, 1u);
    if (!v24)
      goto LABEL_52;
    v25 = v24;
    v26 = *(const __CFDictionary **)(a8 + 24);
    if (!v26 || !CFDictionaryGetValue(v26, v25))
      break;
    v10 = (char *)(v23 + 1);
    CFRelease(v25);
LABEL_42:
    v47 = 0;
    CStringPtrAndBufferToFree = (const char *)FigCFStringGetCStringPtrAndBufferToFree();
    if (!CStringPtrAndBufferToFree)
    {
LABEL_57:
      v30 = FigSignalErrorAt();
      v29 = 0;
      v28 = a4;
      goto LABEL_53;
    }
    v17 = CStringPtrAndBufferToFree;
    v19 = v47;
    v18 = strlen(CStringPtrAndBufferToFree);
    *(_BYTE *)(a8 + 42) = 1;
    v11 = v16;
    v8 = a2;
    if (!v11)
    {
LABEL_44:
      v13 = v19;
      v19 = 0;
      goto LABEL_45;
    }
LABEL_34:
    v20 = v11;
    v21 = (char *)malloc_type_malloc(v18 + v12 + 1, 0x62FCA3F3uLL);
    if (!v21)
      goto LABEL_57;
    v22 = v21;
    memcpy(v21, v20, v12);
    memcpy(&v22[v12], v17, v18);
    v22[v18 + v12] = 0;
    free(v13);
    v17 = v22;
    v18 += v12;
    v13 = (UInt8 *)v22;
    v8 = a2;
LABEL_45:
    free(v19);
    v11 = v17;
    v12 = v18;
  }
  CFRelease(v25);
LABEL_52:
  v31 = strcspn(v10, "\r\n");
  v30 = 4294954654;
  _StreamPlaylistLogError(4294954654, 4294955032, a8, CFSTR("%.*s: illegal variable use"), v31, v10);
  v32 = &v10[strcspn(v10, "\r\n")];
  v33 = strspn(v32, "\r\n");
  v29 = 0;
  v28 = a4;
  *a4 = (char *)&v32[v33];
LABEL_53:
  if (!a2)
    goto LABEL_56;
LABEL_54:
  if (v29)
    goto LABEL_56;
LABEL_55:
  v34 = strcspn(__s, "\r\n");
  v30 = 4294951057;
  _StreamPlaylistLogError(4294951057, 4294955032, a8, CFSTR("%.*s: unterminated quoted string"), v34, __s);
  v35 = &v10[strcspn(v10, "\r\n")];
  *v28 = (char *)&v35[strspn(v35, "\r\n")];
LABEL_56:
  free(v13);
  return v30;
}

uint64_t MergeLeadingPartialMediaEntries(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, char *a5, int a6)
{
  uint64_t LastValue;
  uint64_t v12;
  uint64_t MediaSequence;
  uint64_t DiscontinuityDomain;
  uint64_t v15;
  uint64_t v16;
  char v17;
  char v18;
  uint64_t v20;
  const __CFArray *PartialSegments;
  uint64_t FirstValue;
  _QWORD *NextSegment;
  CFIndex v24;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t matched;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  const __CFString *v31;
  const void *URLString;
  double TimeInSeconds;
  char IsMarkedAsGap;
  uint64_t StartOffset;
  uint64_t v36;
  double BitRate;
  uint64_t v38;
  char *v39;
  char v40;

  v40 = 1;
  FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
  LastValue = FigCFArrayGetLastValue();
  if (!LastValue
    || (v12 = LastValue,
        MediaSequence = FigMediaSegmentSpecifierGetMediaSequence(a2),
        MediaSequence != FigMediaSegmentSpecifierGetMediaSequence(v12)))
  {
    v16 = 0;
    v17 = 0;
    v18 = 0;
LABEL_6:
    *a4 = v17;
    *a5 = v18;
    return v16;
  }
  v39 = a5;
  DiscontinuityDomain = FigMediaSegmentSpecifierGetDiscontinuityDomain(v12);
  v15 = FigMediaSegmentSpecifierGetDiscontinuityDomain(a2);
  if (DiscontinuityDomain == v15)
  {
    v16 = 0;
  }
  else
  {
    v20 = FigMediaSegmentSpecifierGetMediaSequence(v12);
    v16 = 4294954984;
    _StreamPlaylistLogError(4294954984, 4294954984, a3, CFSTR("Media Entry discontinuity value does not match previous playlist for MEDIA-SEQUENCE %llu"), v20);
    if (!*(_BYTE *)(a3 + 41))
      return v16;
  }
  PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments(v12);
  v38 = FigMediaSegmentSpecifierGetPartialSegments(a2);
  FirstValue = FigCFArrayGetFirstValue();
  if (!FirstValue)
  {
    if (PartialSegments && CFArrayGetCount(PartialSegments) >= 1)
      FigMediaSegmentSpecifierSetAreFragmentsExpired(v12, 1);
    v18 = 0;
    v17 = 0;
    v30 = DiscontinuityDomain == v15;
    a5 = v39;
    if (v30)
    {
LABEL_40:
      if (v38)
        FigMediaSegmentSpecifierSetPartialSegments(a2, 0);
      if (!FigMediaSegmentSpecifierGetURLString(v12))
      {
        URLString = (const void *)FigMediaSegmentSpecifierGetURLString(a2);
        FigMediaSegmentSpecifierSetURLString(v12, URLString);
      }
      TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds(a2);
      FigMediaSegmentSpecifierSetTimeInSeconds(v12, TimeInSeconds);
      IsMarkedAsGap = FigMediaSegmentSpecifierIsMarkedAsGap(a2);
      FigMediaSegmentSpecifierSetIsMarkedAsGap(v12, IsMarkedAsGap);
      StartOffset = FigMediaSegmentSpecifierGetStartOffset(a2);
      FigMediaSegmentSpecifierSetStartOffset(v12, StartOffset);
      v36 = FigMediaSegmentSpecifierGetBytesToRead(a2);
      FigMediaSegmentSpecifierSetBytesToRead(v12, v36);
      BitRate = FigMediaSegmentSpecifierGetBitRate(a2);
      FigMediaSegmentSpecifierSetBitRate(v12, BitRate);
      v17 = 1;
      FigMediaSegmentSpecifierSetIsReadInCurrent(v12, 1);
      FigMediaSegmentSpecifierSetChangedInCurrent(v12, 1);
      v16 = 0;
    }
    goto LABEL_6;
  }
  NextSegment = (_QWORD *)FirstValue;
  v24 = 0;
  if (!PartialSegments)
    goto LABEL_12;
LABEL_11:
  for (i = CFArrayGetCount(PartialSegments); ; i = 0)
  {
    if (v24 >= i)
      goto LABEL_20;
    ValueAtIndex = CFArrayGetValueAtIndex(PartialSegments, v24);
    if (!NextSegment)
      break;
    matched = DoesMediaFileMatchEntry((uint64_t)ValueAtIndex, (uint64_t)NextSegment, &v40, a3, 1, a6);
    if ((_DWORD)matched)
    {
      v16 = matched;
      goto LABEL_38;
    }
    if (!v40)
      break;
    NextSegment = (_QWORD *)FigMediaSegmentSpecifierGetNextSegment((uint64_t)NextSegment);
    v16 = 0;
    ++v24;
    if (PartialSegments)
      goto LABEL_11;
LABEL_12:
    ;
  }
  v16 = 4294954984;
  _StreamPlaylistLogError(4294954984, 4294954984, a3, CFSTR("The set of EXT-X-PART segments of the last entry has changed"));
  if (!*(_BYTE *)(a3 + 41))
    return v16;
LABEL_20:
  if (!NextSegment || FigMediaSegmentSpecifierIsFragment(v12))
  {
    if (!(_DWORD)v16)
    {
      a5 = v39;
      if (NextSegment)
      {
        do
        {
          v28 = FigMediaSegmentSpecifierGetNextSegment((uint64_t)NextSegment);
          FigMediaSegmentSpecifierAddPartialSegment(v12, NextSegment);
          NextSegment = (_QWORD *)v28;
        }
        while (v28);
        v18 = 1;
      }
      else
      {
        v18 = 0;
      }
      goto LABEL_40;
    }
LABEL_38:
    v17 = 0;
    v18 = 0;
    a5 = v39;
    goto LABEL_6;
  }
  v29 = FigMediaSegmentSpecifierGetURLString(v12);
  if (FigIsItOKToLogURLs())
    v30 = a6 == 0;
  else
    v30 = 1;
  v31 = CFSTR("[]");
  if (!v30)
    v31 = (const __CFString *)v29;
  v16 = 4294954984;
  _StreamPlaylistLogError(4294954984, 4294954984, a3, CFSTR("New EXT-X-PART segments cannot be added after parent segment %@ appears"), v31);
  if (*(_BYTE *)(a3 + 41))
    goto LABEL_38;
  return v16;
}

uint64_t FindMatchingMediaEntry(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, int a5)
{
  CFIndex i;
  const __CFArray *MediaSegmentSpecifiers;
  const __CFArray *v12;
  const void *ValueAtIndex;
  uint64_t result;
  char v15;

  for (i = 0; ; ++i)
  {
    MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
    if (MediaSegmentSpecifiers)
      MediaSegmentSpecifiers = (const __CFArray *)CFArrayGetCount(MediaSegmentSpecifiers);
    if (i >= (uint64_t)MediaSegmentSpecifiers)
      return 0;
    v12 = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
    ValueAtIndex = CFArrayGetValueAtIndex(v12, i);
    v15 = 0;
    result = DoesMediaFileMatchEntry((uint64_t)ValueAtIndex, a2, &v15, a4, 1, a5);
    if ((_DWORD)result)
      return result;
    if (v15)
      break;
  }
  *a3 = ValueAtIndex;
  return result;
}

uint64_t DoesMediaFileMatchEntry(uint64_t a1, uint64_t a2, _BYTE *a3, uint64_t a4, int a5, int a6)
{
  uint64_t MediaSequence;
  uint64_t v13;
  double TimeInSeconds;
  uint64_t v15;
  double v16;
  double v17;
  uint64_t DiscontinuityDomain;
  uint64_t v19;
  uint64_t StartOffset;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFString *URLString;
  BOOL v30;
  const __CFString *v31;
  __CFString *v32;
  int IsMarkedAsGap;
  uint64_t v34;
  const char *v35;
  const char *v36;
  uint64_t v37;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;

  *a3 = 0;
  MediaSequence = FigMediaSegmentSpecifierGetMediaSequence(a1);
  v13 = 0;
  if (MediaSequence != FigMediaSegmentSpecifierGetMediaSequence(a2))
    return v13;
  TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds(a1);
  if (TimeInSeconds == FigMediaSegmentSpecifierGetTimeInSeconds(a2))
  {
    v13 = 0;
    if (!a5)
      goto LABEL_7;
  }
  else
  {
    v15 = FigMediaSegmentSpecifierGetMediaSequence(a1);
    v16 = FigMediaSegmentSpecifierGetTimeInSeconds(a1);
    v17 = FigMediaSegmentSpecifierGetTimeInSeconds(a2);
    v40 = v15;
    v13 = 4294954984;
    _StreamPlaylistLogError(4294954984, 4294954984, a4, CFSTR("Media Entry time value does not match previous playlist for MEDIA-SEQUENCE %llu: %f vs %f"), v40, *(_QWORD *)&v16, *(_QWORD *)&v17);
    if (!*(_BYTE *)(a4 + 41))
      return v13;
    if (!a5)
    {
LABEL_7:
      DiscontinuityDomain = FigMediaSegmentSpecifierGetDiscontinuityDomain(a1);
      if (DiscontinuityDomain != FigMediaSegmentSpecifierGetDiscontinuityDomain(a2))
      {
        v19 = FigMediaSegmentSpecifierGetMediaSequence(a1);
        v13 = 4294954984;
        _StreamPlaylistLogError(4294954984, 4294954984, a4, CFSTR("Media Entry discontinuity value does not match previous playlist for MEDIA-SEQUENCE %llu"), v19);
        if (!*(_BYTE *)(a4 + 41))
          return v13;
      }
    }
  }
  StartOffset = FigMediaSegmentSpecifierGetStartOffset(a1);
  if (StartOffset == FigMediaSegmentSpecifierGetStartOffset(a2)
    || (v21 = FigMediaSegmentSpecifierGetMediaSequence(a1),
        v22 = FigMediaSegmentSpecifierGetStartOffset(a1),
        v23 = FigMediaSegmentSpecifierGetStartOffset(a2),
        v41 = v21,
        v13 = 4294954984,
        _StreamPlaylistLogError(4294954984, 4294954984, a4, CFSTR("Media Entry start offset does not match previous playlist for MEDIA-SEQUENCE %llu: %lld vs %lld"), v41, v22, v23), *(_BYTE *)(a4 + 41)))
  {
    v24 = FigMediaSegmentSpecifierGetBytesToRead(a1);
    if (v24 == FigMediaSegmentSpecifierGetBytesToRead(a2)
      || (v25 = FigMediaSegmentSpecifierGetMediaSequence(a1),
          v26 = FigMediaSegmentSpecifierGetBytesToRead(a1),
          v27 = FigMediaSegmentSpecifierGetBytesToRead(a2),
          v42 = v25,
          v13 = 4294954984,
          _StreamPlaylistLogError(4294954984, 4294954984, a4, CFSTR("Media Entry bytes to read does not match previous playlist for MEDIA-SEQUENCE %llu: %lld vs %lld"), v42, v26, v27), *(_BYTE *)(a4 + 41)))
    {
      FigMediaSegmentSpecifierGetURLString(a1);
      FigMediaSegmentSpecifierGetURLString(a2);
      if (FigCFEqual())
        goto LABEL_20;
      v28 = FigMediaSegmentSpecifierGetMediaSequence(a1);
      URLString = (const __CFString *)FigMediaSegmentSpecifierGetURLString(a1);
      v30 = a6 != 0;
      if (((a6 != 0) & (FigIsItOKToLogURLs() != 0)) == 0)
        URLString = CFSTR("[]");
      v31 = (const __CFString *)FigMediaSegmentSpecifierGetURLString(a2);
      v32 = (v30 & (FigIsItOKToLogURLs() != 0)) != 0 ? (__CFString *)v31 : CFSTR("[]");
      v43 = v28;
      v13 = 4294954984;
      _StreamPlaylistLogError(4294954984, 4294954984, a4, CFSTR("Media Entry URL not match previous playlist for MEDIA-SEQUENCE %llu: %@ vs %@"), v43, URLString, v32);
      if (*(_BYTE *)(a4 + 41))
      {
LABEL_20:
        IsMarkedAsGap = FigMediaSegmentSpecifierIsMarkedAsGap(a1);
        if (IsMarkedAsGap == FigMediaSegmentSpecifierIsMarkedAsGap(a2)
          || ((v34 = FigMediaSegmentSpecifierGetMediaSequence(a1),
               FigMediaSegmentSpecifierIsMarkedAsGap(a1))
            ? (v35 = "YES")
            : (v35 = "NO"),
              FigMediaSegmentSpecifierIsMarkedAsGap(a2) ? (v36 = "YES") : (v36 = "NO"),
              v13 = 4294954984,
              _StreamPlaylistLogError(4294954984, 4294954984, a4, CFSTR("Media Entry gap mode not match previous playlist for MEDIA-SEQUENCE %llu: %s vs %s"), v34, v35, v36), *(_BYTE *)(a4 + 41)))
        {
          FigMediaSegmentSpecifierGetContentKeySpecifier(a1);
          FigMediaSegmentSpecifierGetContentKeySpecifier(a2);
          if (FigCFEqual())
          {
            if (!(_DWORD)v13)
              *a3 = 1;
          }
          else
          {
            v37 = FigMediaSegmentSpecifierGetMediaSequence(a1);
            _StreamPlaylistLogError(4294954984, 4294954984, a4, CFSTR("Media Entry crypt key URL does not match previous playlist for MEDIA-SEQUENCE %llu"), v37);
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type();
            os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, OS_LOG_TYPE_DEFAULT);
            fig_log_call_emit_and_clean_up_after_send_and_compose();
            return 4294954984;
          }
        }
      }
    }
  }
  return v13;
}

uint64_t FigStreamPlaylistValidateMediaEntry(uint64_t a1, uint64_t a2, const void *a3)
{
  double PlaylistActiveDurationSecs;
  double TimeInSeconds;
  uint64_t ContentKeySpecifier;
  uint64_t result;
  uint64_t MapSegmentSpecifier;
  uint64_t v11;

  PlaylistActiveDurationSecs = FigMediaPlaylistGetPlaylistActiveDurationSecs(a1);
  TimeInSeconds = FigMediaSegmentSpecifierGetTimeInSeconds(a2);
  FigMediaPlaylistSetPlaylistActiveDurationSecs(a1, PlaylistActiveDurationSecs + TimeInSeconds);
  FigMediaSegmentSpecifierSetIsReadInCurrent(a2, 1);
  if (FigMediaSegmentSpecifierGetContentKeySpecifier(a2))
  {
    ContentKeySpecifier = FigMediaSegmentSpecifierGetContentKeySpecifier(a2);
    FigContentKeySpecifierSetIsReadInCurrent(ContentKeySpecifier, 1);
  }
  result = FigMediaSegmentSpecifierGetMapSegmentSpecifier(a2);
  if (result)
  {
    MapSegmentSpecifier = FigMediaSegmentSpecifierGetMapSegmentSpecifier(a2);
    result = FigMediaSegmentSpecifierSetIsReadInCurrent(MapSegmentSpecifier, 1);
  }
  if (a3)
  {
    FigMediaSegmentSpecifierSetChangedInCurrent(a2, 1);
    FigMediaSegmentSpecifierSetDateStamp(a2, a3);
    v11 = FigMediaPlaylistGetDateStampCount(a1) + 1;
    return FigMediaPlaylistSetDateStampCount(a1, v11);
  }
  return result;
}

uint64_t CreateMediaFileEntry(uint64_t a1, const void *a2, int a3, const void *a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, uint64_t a11, const void *a12, const void *a13, char a14, char a15)
{
  double v22;
  void *v23;
  const void *v24;
  uint64_t v25;
  unint64_t v26;
  const __CFAllocator *AllocatorForMedia;
  uint64_t v28;
  uint64_t MediaEntryCount;
  uint64_t v30;
  uint64_t v31;
  uint64_t v37;
  UInt8 bytes[8];
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v37 = 0;
  if (a11)
    v22 = (double)(8 * a11) / a9;
  else
    v22 = 0.0;
  if (a4)
  {
    FigContentKeySpecifierSetIsReadInCurrent((uint64_t)a4, 1);
    if (a12)
    {
      v23 = (void *)CFRetain(a12);
    }
    else
    {
      *(_QWORD *)bytes = 0;
      v39 = 0;
      v25 = 15;
      v26 = a6;
      do
      {
        bytes[v25] = v26;
        v26 >>= 8;
        --v25;
      }
      while (v25 != -1);
      AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
      v23 = CFDataCreate(AllocatorForMedia, bytes, 16);
      if (!v23)
      {
        FigSignalErrorAt();
        return v37;
      }
    }
    v24 = v23;
  }
  else
  {
    v24 = 0;
  }
  v28 = a8;
  if (a5)
  {
    FigMediaSegmentSpecifierSetIsDiscontinuityDomain((uint64_t)a5, a7);
    FigMediaSegmentSpecifierSetIsReadInCurrent((uint64_t)a5, 1);
    if (!FigMediaSegmentSpecifierGetIV((uint64_t)a5))
      FigMediaSegmentSpecifierSetIV((uint64_t)a5, v24);
  }
  MediaEntryCount = FigMediaPlaylistGetMediaEntryCount(a1);
  FigMediaPlaylistSetMediaEntryCount(a1, MediaEntryCount + 1);
  v30 = FigGetAllocatorForMedia();
  v31 = FigMediaPlaylistGetMediaEntryCount(a1);
  FigMediaSegmentSpecifierCreate(a9, v22, a10, v30, a2, a4, a5, a6, a7, v28, a11, v24, a13, a3, 0, a14, 1, a15, 0,
    0,
    v31,
    1,
    &v37);
  if (v24)
    CFRelease(v24);
  return v37;
}

void FigStreamPlaylistTransferPartialEntryQueue(uint64_t a1, uint64_t a2)
{
  const void *PartialSegments;

  PartialSegments = (const void *)FigMediaSegmentSpecifierGetPartialSegments(a1);
  FigMediaSegmentSpecifierSetPartialSegments(a2, PartialSegments);
  FigMediaSegmentSpecifierSetPartialSegments(a1, 0);
}

const void *FindMediaSelectionOptionArrayByMediaType(const __CFArray *a1, const void *a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  const __CFDictionary *ValueAtIndex;
  const void *Value;

  if (!a1)
    return 0;
  Count = CFArrayGetCount(a1);
  if (Count < 1)
    return 0;
  v5 = Count;
  v6 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1, v6);
    Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("MediaSelectionGroupMediaType"));
    if (CFEqual(Value, a2))
      break;
    if (v5 == ++v6)
      return 0;
  }
  return CFDictionaryGetValue(ValueAtIndex, CFSTR("MediaSelectionGroupOptions"));
}

uint64_t PlaylistCheckAllAlternatesCarryScore(uint64_t result, char *a2, BOOL *a3)
{
  const __CFArray *v5;
  uint64_t v6;
  int v7;
  int v8;
  CFIndex v9;
  int v10;
  int v11;
  const void *ValueAtIndex;
  int IsIFrameOnly;
  int v14;
  int v15;
  int v16;
  int v17;
  BOOL v18;
  char v19;
  BOOL v20;

  if (!result || (v5 = (const __CFArray *)result, result = CFArrayGetCount((CFArrayRef)result), result < 2))
  {
    LOBYTE(v11) = 0;
    LOBYTE(v10) = 0;
    LOBYTE(v8) = 0;
    v7 = 0;
    if (!a2)
      goto LABEL_31;
    goto LABEL_24;
  }
  if (!((unint64_t)a2 | (unint64_t)a3))
    return result;
  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v5, v9);
    IsIFrameOnly = FigAlternateIsIFrameOnly((uint64_t)ValueAtIndex);
    result = FigAlternateHasRankingScore((_BOOL8)ValueAtIndex);
    if ((_DWORD)result)
      v14 = v8;
    else
      v14 = 1;
    if ((_DWORD)result)
      v15 = 1;
    else
      v15 = v7;
    if ((_DWORD)result)
      v16 = 1;
    else
      v16 = v11;
    if ((_DWORD)result)
      v17 = v10;
    else
      v17 = 1;
    if (IsIFrameOnly)
    {
      v11 = v16;
      v10 = v17;
    }
    else
    {
      v8 = v14;
    }
    if (!IsIFrameOnly)
      v7 = v15;
    ++v9;
  }
  while (v6 != v9);
  if (a2)
  {
LABEL_24:
    if ((_BYTE)v8)
      v18 = v7 == 0;
    else
      v18 = 1;
    v19 = !v18;
    *a2 = v19;
  }
LABEL_31:
  if (a3)
  {
    v20 = v11 != 0;
    if (!(_BYTE)v10)
      v20 = 0;
    *a3 = v20;
  }
  return result;
}

uint64_t FigStreamPlaylistParse(OpaqueCMBlockBuffer *a1, const __CFURL *a2, const __CFURL *a3, _DWORD *a4, unsigned int a5, int a6, int a7, int a8, CFMutableArrayRef *a9, uint64_t a10, const __CFDictionary *a11, const __CFDictionary *a12, uint64_t *a13, CFTypeRef *a14)
{
  if (_os_feature_enabled_impl())
    return FigStreamPlaylistParseRemote((uint64_t)a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)a11, (uint64_t)a12, a13, a14);
  else
    return FigStreamPlaylistParseInProcess(a1, a2, a3, a4, a5, a6, 0, a8, (uint64_t)a9, a10, a11, a12, (CFTypeRef *)a13, a14);
}

void FigStreamPlaylistPredictMediaSequenceAndPartForAdvance(uint64_t a1, uint64_t *a2, CFIndex *a3, double a4)
{
  double TargetDuration;
  uint64_t LastValue;
  uint64_t v10;
  uint64_t v11;
  uint64_t MediaSequence;
  int v13;
  double v14;
  CFIndex v15;
  double v16;
  const __CFArray *PartialSegments;
  const __CFArray *v18;
  const void *ValueAtIndex;

  if (FigMediaPlaylistGetMaxSegmentDuration(a1) <= 0.0)
    TargetDuration = (double)FigMediaPlaylistGetTargetDuration(a1);
  else
    TargetDuration = FigMediaPlaylistGetMaxSegmentDuration(a1);
  FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
  LastValue = FigCFArrayGetLastValue();
  v10 = LastValue;
  if (LastValue)
  {
    FigMediaSegmentSpecifierGetPartialSegments(LastValue);
    v11 = FigCFArrayGetLastValue();
    MediaSequence = FigMediaSegmentSpecifierGetMediaSequence(v10);
  }
  else
  {
    v11 = 0;
    MediaSequence = 0;
  }
  v13 = (int)(ceil(TargetDuration / FigMediaPlaylistGetPartTargetDuration(a1)) + -1.0);
  v14 = 0.0;
  v15 = 0;
  if (v11)
  {
    v16 = TargetDuration;
    while (1)
    {
      PartialSegments = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments(v10);
      if (PartialSegments)
        PartialSegments = (const __CFArray *)CFArrayGetCount(PartialSegments);
      if (v15 >= (uint64_t)PartialSegments)
        break;
      v18 = (const __CFArray *)FigMediaSegmentSpecifierGetPartialSegments(v10);
      ValueAtIndex = CFArrayGetValueAtIndex(v18, v15);
      v16 = v16 - FigMediaSegmentSpecifierGetTimeInSeconds((uint64_t)ValueAtIndex);
      if (ValueAtIndex == (const void *)v11)
        break;
      ++v15;
    }
    if (v16 < a4 && vabdd_f64(a4, v16) >= 0.001)
    {
      v15 = v13;
      if (FigMediaSegmentSpecifierIsFragment(v10))
        v14 = v16;
      else
        v14 = 0.0;
    }
  }
  while (TargetDuration + v14 < a4 || vabdd_f64(TargetDuration + v14, a4) < 0.001)
  {
    ++MediaSequence;
    v14 = TargetDuration + v14;
    v15 = v13;
  }
  while (v14 <= a4 && vabdd_f64(v14, a4) >= 0.001)
  {
    if (v15 == v13)
    {
      ++MediaSequence;
      v15 = 0;
    }
    else
    {
      ++v15;
    }
    v14 = v14 + FigMediaPlaylistGetPartTargetDuration(a1);
  }
  *a2 = MediaSequence;
  *a3 = v15;
}

BOOL FigStreamPlaylistParserHTTPServerMayMutatePlaylist(uint64_t a1)
{
  const __CFArray *MediaSegmentSpecifiers;

  if (!FigMediaPlaylistHasEndTag(a1))
    return 1;
  MediaSegmentSpecifiers = (const __CFArray *)FigMediaPlaylistGetMediaSegmentSpecifiers(a1);
  if (!MediaSegmentSpecifiers || !CFArrayGetCount(MediaSegmentSpecifiers))
    return 1;
  if (FigMediaPlaylistGetPlaylistType(a1) == 2)
    return 0;
  return FigMediaPlaylistGetPlaylistType(a1) != 1;
}

const char *sp_SkipSpacesTabsAndCommas(const char *a1, uint64_t a2, int a3)
{
  int v6;
  unsigned int v7;
  const char *v8;

  v6 = 0;
  while (1)
  {
    v7 = *(unsigned __int8 *)a1;
    if (v7 > 0x2C)
      goto LABEL_12;
    if (((1 << v7) & 0x100100000200) == 0)
      break;
    v8 = StreamingPlaylist_SkipSpacesAndTabs(a1, a2);
    a1 = v8;
    if (*v8 == 44)
    {
      ++v6;
      a1 = StreamingPlaylist_SkipSpacesAndTabs(v8 + 1, a2);
    }
  }
  if (((1 << v7) & 0x2401) != 0)
  {
LABEL_7:
    if (v6)
    {
      if (v6 == 1)
        _StreamPlaylistLogError(4294954654, 4294955032, a2, CFSTR("Misplaced comma"));
      else
        _StreamPlaylistLogError(4294954654, 4294955032, a2, CFSTR("Multiple misplaced comma"));
    }
    return a1;
  }
LABEL_12:
  if (!a3)
    goto LABEL_7;
  if (v6)
  {
    if (v6 != 1)
      _StreamPlaylistLogError(4294954654, 4294955032, a2, CFSTR("Multiple commas found"));
  }
  else
  {
    _StreamPlaylistLogError(4294954654, 4294955032, a2, CFSTR("Expected a comma but not found"));
  }
  return a1;
}

BOOL sp_MatchAttributeName(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t i;
  int v5;
  BOOL v6;
  BOOL v7;

  for (i = 0; ; ++i)
  {
    v5 = *(unsigned __int8 *)(a1 + i);
    v6 = (v5 - 65) >= 0x1A && (v5 - 48) >= 0xA;
    if (v6 && v5 != 45 && v5 != 95 && (!a2 || (v5 - 97) > 0x19))
      break;
    if (!i)
      *a3 = a1;
  }
  *a4 = i;
  if (i)
    v7 = *a3 == 0;
  else
    v7 = 1;
  return !v7;
}

uint64_t PlaylistTokenizeString(char *a1, size_t a2, uint64_t a3, unsigned __int8 a4, __CFArray **a5)
{
  __CFArray *Mutable;
  uint64_t v9;
  unsigned int v10;
  int v11;
  _BYTE *v13;
  _BYTE *v14;
  size_t v15;
  size_t v16;
  char *v17;
  unsigned int v18;
  int v19;
  CFStringRef v22;
  CFStringRef v23;
  uint64_t v24;
  const __CFAllocator *alloc;

  alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    if (a2)
    {
      v9 = MEMORY[0x1E0C80978];
      do
      {
        while (1)
        {
          v10 = *a1;
          v11 = (v10 & 0x80000000) != 0 ? __maskrune(*a1, 0x4000uLL) : *(_DWORD *)(v9 + 4 * v10 + 60) & 0x4000;
          if (v10 == a4 || v11 == 0)
            break;
          ++a1;
          if (!--a2)
            goto LABEL_37;
        }
        v13 = memchr(a1, a4, a2);
        v14 = v13;
        if (v13)
          v15 = v13 - a1;
        else
          v15 = a2;
        if (v15)
        {
          v16 = v15 - 1;
          do
          {
            v17 = &a1[v16];
            v18 = a1[v16];
            if ((v18 & 0x80000000) != 0)
              v19 = __maskrune(a1[v16], 0x4000uLL);
            else
              v19 = *(_DWORD *)(v9 + 4 * v18 + 60) & 0x4000;
            --v16;
          }
          while (v18 != a4 && v19 != 0 && v17 > a1);
          if (v16 != -2)
          {
            v22 = CFStringCreateWithBytes(alloc, (const UInt8 *)a1, v16 + 2, 0x600u, 0);
            if (!v22)
              goto LABEL_43;
            v23 = v22;
            CFArrayAppendValue(Mutable, v22);
            CFRelease(v23);
          }
        }
        if (v14)
          a1 += v15 + 1;
        else
          a1 += v15;
        if (!v14)
          break;
        a2 += ~v15;
      }
      while (a2);
    }
LABEL_37:
    if (CFArrayGetCount(Mutable))
      goto LABEL_38;
    v24 = 4294955032;
    _StreamPlaylistLogError(4294955032, 4294955032, a3, CFSTR("empty tokens field"));
  }
  else
  {
LABEL_43:
    v24 = FigSignalErrorAt();
    if (!(_DWORD)v24)
    {
LABEL_38:
      v24 = 0;
      *a5 = Mutable;
      return v24;
    }
  }
  if (Mutable)
    CFRelease(Mutable);
  return v24;
}

uint64_t sp_strtohex(_BYTE *a1, unint64_t a2, CFDataRef *a3, uint64_t a4, uint64_t a5)
{
  void *v10;
  uint64_t v11;
  char *v12;
  BOOL v13;
  uint64_t v14;
  const __CFAllocator *v15;
  const __CFAllocator *GlobalCFAllocatorFigMalloc;
  CFDataRef v17;
  uint64_t v18;
  const __CFString *v20;
  __int16 v21;

  v21 = 0;
  if (a2 < 3)
  {
    v20 = CFSTR("%s:No value in hexadecimal-integer");
    goto LABEL_19;
  }
  if (*a1 != 48 || __tolower((char)a1[1]) != 120)
  {
    v20 = CFSTR("%s:Illegal start to hexadecimal-integer");
LABEL_19:
    v18 = 4294954654;
    _StreamPlaylistLogError(4294954654, 4294955032, a5, v20, a4);
    v10 = 0;
    goto LABEL_14;
  }
  v10 = malloc_type_malloc((a2 - 1) >> 1, 0xE3C090C1uLL);
  if (!v10)
  {
LABEL_13:
    v18 = FigSignalErrorAt();
    if (!(_DWORD)v18)
      return v18;
LABEL_14:
    free(v10);
    return v18;
  }
  v11 = 0;
  v12 = a1 + 2;
  v13 = (a2 & 1) == 0;
  do
  {
    if (v13)
    {
      v14 = sp_chartohex(*v12, a4, a5, &v21);
      if ((_DWORD)v14)
        goto LABEL_16;
      ++v12;
    }
    v14 = sp_chartohex(*v12, a4, a5, (_BYTE *)&v21 + 1);
    if ((_DWORD)v14)
    {
LABEL_16:
      v18 = v14;
      goto LABEL_14;
    }
    ++v12;
    *((_BYTE *)v10 + v11++) = HIBYTE(v21) | (16 * v21);
    v13 = 1;
  }
  while ((a2 - 1) >> 1 != v11);
  v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
  v17 = CFDataCreateWithBytesNoCopy(v15, (const UInt8 *)v10, (a2 - 1) >> 1, GlobalCFAllocatorFigMalloc);
  *a3 = v17;
  if (!v17)
    goto LABEL_13;
  return 0;
}

void TaggedRangeUniquenessApplier(const void *a1, const void *a2, uint64_t a3)
{
  const __CFDictionary *MetadataDict;
  const void *Value;

  if (!*(_DWORD *)(a3 + 24))
  {
    MetadataDict = (const __CFDictionary *)FigDateRangeSpecifierGetMetadataDict(*(_QWORD *)a3);
    Value = CFDictionaryGetValue(MetadataDict, a1);
    if (Value)
    {
      if (!CFEqual(Value, a2))
      {
        _StreamPlaylistLogError(4294954654, 4294955031, *(_QWORD *)(a3 + 8), CFSTR("metadata entry doesn't match"));
        *(_DWORD *)(a3 + 24) = -12642;
      }
    }
    else
    {
      FigDateRangeSpecifierSetValueForMetadataDict(*(_QWORD *)a3, a1, a2);
      FigDateRangeSpecifierSetValueForTagsFirstFoundDateDict(*(_QWORD *)a3, a1, *(const void **)(a3 + 16));
      *(_BYTE *)(a3 + 28) = 1;
    }
  }
}

uint64_t sp_chartohex(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  int v4;
  uint64_t v5;
  char v7;

  if ((a1 & 0x80000000) == 0
    && (v4 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * a1 + 60), (v4 & 0x10000) != 0))
  {
    if ((v4 & 0x100) != 0)
      v7 = __tolower(a1) - 87;
    else
      v7 = a1 - 48;
    v5 = 0;
    *a4 = v7;
  }
  else
  {
    v5 = 4294954654;
    _StreamPlaylistLogError(4294954654, 4294955032, a3, CFSTR("%s:Illegal hexadecimal digit %c"), a2, a1);
  }
  return v5;
}

uint64_t PlaylistAddTaggedRangeMetadataDictionaryToArray(__CFArray *a1, const void *a2, const void *a3, const void *a4, const void *a5)
{
  __CFDictionary *Mutable;
  __CFDictionary *v11;

  if (!a2 || !a3)
    return 0;
  if (a5)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v11 = Mutable;
      CFDictionaryAddValue(Mutable, CFSTR("key"), a2);
      CFDictionaryAddValue(v11, CFSTR("value"), a3);
      CFDictionaryAddValue(v11, CFSTR("keyspace"), (const void *)*MEMORY[0x1E0CA2598]);
      CFDictionaryAddValue(v11, CFSTR("dataTypeNamespace"), CFSTR("com.apple.coremedia"));
      CFDictionaryAddValue(v11, CFSTR("dataType"), a4);
      CFDictionaryAddValue(v11, CFSTR("discoveryTimestamp"), a5);
      CFArrayAppendValue(a1, v11);
      CFRelease(v11);
      return 0;
    }
  }
  return FigSignalErrorAt();
}

const void *TaggedRangeTagApplier(const void *result, CFTypeRef cf, uint64_t a3)
{
  const void *v5;
  CFTypeID v6;
  const void **v7;
  CFTypeID TypeID;
  const void *v9;
  const __CFDictionary *TagsFirstFoundDateDict;
  const void *Value;

  if (!*(_DWORD *)(a3 + 16))
  {
    v5 = result;
    v6 = CFGetTypeID(cf);
    if (v6 == CFStringGetTypeID())
    {
      v7 = (const void **)MEMORY[0x1E0CA2498];
    }
    else
    {
      TypeID = CFNumberGetTypeID();
      v7 = (const void **)MEMORY[0x1E0CA2440];
      if (v6 == TypeID)
        v7 = (const void **)MEMORY[0x1E0CA23F8];
    }
    v9 = *v7;
    TagsFirstFoundDateDict = (const __CFDictionary *)FigDateRangeSpecifierGetTagsFirstFoundDateDict(*(_QWORD *)(a3 + 8));
    Value = CFDictionaryGetValue(TagsFirstFoundDateDict, v5);
    result = (const void *)PlaylistAddTaggedRangeMetadataDictionaryToArray(*(__CFArray **)a3, v5, cf, v9, Value);
    *(_DWORD *)(a3 + 16) = (_DWORD)result;
  }
  return result;
}

uint64_t FigTTMLSerializerCreateIndenter(uint64_t a1, const void *a2, _QWORD *a3)
{
  uint64_t v5;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v7;
  _QWORD *DerivedStorage;
  uint64_t v9;

  if (a2)
  {
    if (a3)
    {
      FigTTMLSerializerGetClassID();
      v5 = CMDerivedObjectCreate();
      if ((_DWORD)v5)
        return v5;
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
      if (Mutable)
      {
        v7 = Mutable;
        FigBytePumpGetFigBaseObject(0);
        DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
        v9 = 0;
        *DerivedStorage = CFRetain(a2);
        DerivedStorage[1] = v7;
        DerivedStorage[2] = 0;
        *a3 = 0;
        return v9;
      }
    }
    return FigSignalErrorAt();
  }
  return FigSignalErrorAt();
}

uint64_t figTTMLSerializerIndenter_Invalidate()
{
  return 0;
}

void figTTMLSerializerIndenter_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  const void *v2;

  FigBytePumpGetFigBaseObject(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v2 = *(const void **)(DerivedStorage + 8);
  if (v2)
    CFRelease(v2);
  if (*(_QWORD *)DerivedStorage)
    CFRelease(*(CFTypeRef *)DerivedStorage);
}

CFStringRef figTTMLSerializerIndenter_CopyDebugDesc(uint64_t a1)
{
  _QWORD *DerivedStorage;

  FigBytePumpGetFigBaseObject(a1);
  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("FigTTMLSerializerIndenter: %@"), *DerivedStorage);
}

uint64_t figTTMLSerializerIndenter_StartElement(uint64_t a1, const __CFString *a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  uint64_t v6;
  __CFString *Indentation;
  uint64_t v8;
  uint64_t started;

  FigBytePumpGetFigBaseObject(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (startTagUsesIndentation(a2))
  {
    if (*(_QWORD *)(DerivedStorage + 16))
    {
      v5 = FigTTMLSerializerAddText(a1, (uint64_t)CFSTR("\n"));
      if ((_DWORD)v5)
        return v5;
      v6 = *(_QWORD *)(DerivedStorage + 16);
    }
    else
    {
      v6 = 0;
    }
    Indentation = createIndentation(v6);
    v8 = FigTTMLSerializerAddText(a1, (uint64_t)Indentation);
    if ((_DWORD)v8)
    {
      started = v8;
      if (!Indentation)
        return started;
      goto LABEL_12;
    }
    ++*(_QWORD *)(DerivedStorage + 16);
  }
  else
  {
    Indentation = 0;
  }
  started = FigTTMLSerializerStartElement(*(_QWORD *)DerivedStorage, (uint64_t)a2);
  if (!(_DWORD)started)
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)(DerivedStorage + 8), a2);
    *(_BYTE *)(DerivedStorage + 24) = 1;
  }
  if (Indentation)
LABEL_12:
    CFRelease(Indentation);
  return started;
}

uint64_t figTTMLSerializerIndenter_SetAttribute(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *DerivedStorage;

  FigBytePumpGetFigBaseObject(a1);
  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  return FigTTMLSerializerSetAttribute(*DerivedStorage, a2, a3);
}

uint64_t figTTMLSerializerIndenter_EndElement(uint64_t a1)
{
  uint64_t DerivedStorage;
  const __CFArray *v3;
  CFIndex Count;
  const __CFString *ValueAtIndex;
  int v6;
  CFTypeRef v7;
  char v8;
  __CFString *Indentation;
  uint64_t v10;
  const __CFArray *v11;
  CFIndex v12;
  uint64_t v14;
  uint64_t v15;
  CFTypeRef cf1;

  FigBytePumpGetFigBaseObject(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 8)))
  {
    v3 = *(const __CFArray **)(DerivedStorage + 8);
    Count = CFArrayGetCount(v3);
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v3, Count - 1);
    if (startTagUsesIndentation(ValueAtIndex))
      --*(_QWORD *)(DerivedStorage + 16);
    cf1 = 0;
    v6 = copyElementLocalName(ValueAtIndex, &cf1);
    v7 = cf1;
    if (!v6
      && (CFEqual(cf1, CFSTR("span"))
       || CFEqual(v7, CFSTR("br"))
       || CFEqual(v7, CFSTR("extension"))
       || CFEqual(v7, CFSTR("p"))))
    {
      v8 = 1;
      if (!v7)
      {
LABEL_11:
        if ((v8 & 1) != 0 || *(_BYTE *)(DerivedStorage + 24))
        {
          Indentation = 0;
        }
        else
        {
          v14 = FigTTMLSerializerAddText(a1, (uint64_t)CFSTR("\n"));
          if ((_DWORD)v14)
            return v14;
          Indentation = createIndentation(*(_QWORD *)(DerivedStorage + 16));
          v15 = FigTTMLSerializerAddText(a1, (uint64_t)Indentation);
          if ((_DWORD)v15)
          {
            v10 = v15;
            if (!Indentation)
              return v10;
            goto LABEL_17;
          }
        }
        v10 = FigTTMLSerializerEndElement(*(_QWORD *)DerivedStorage);
        if (!(_DWORD)v10)
        {
          v11 = *(const __CFArray **)(DerivedStorage + 8);
          v12 = CFArrayGetCount(v11);
          CFArrayRemoveValueAtIndex(v11, v12 - 1);
          *(_BYTE *)(DerivedStorage + 24) = 0;
        }
        if (!Indentation)
          return v10;
LABEL_17:
        CFRelease(Indentation);
        return v10;
      }
    }
    else
    {
      v8 = 0;
      if (!v7)
        goto LABEL_11;
    }
    CFRelease(v7);
    goto LABEL_11;
  }
  return FigSignalErrorAt();
}

uint64_t figTTMLSerializerIndenter_AddText(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  uint64_t result;

  FigBytePumpGetFigBaseObject(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  result = FigTTMLSerializerAddText(*(_QWORD *)DerivedStorage, a2);
  if (!(_DWORD)result)
    *(_BYTE *)(DerivedStorage + 24) = 0;
  return result;
}

uint64_t figTTMLSerializerIndenter_Flush(uint64_t a1)
{
  uint64_t *DerivedStorage;

  FigBytePumpGetFigBaseObject(a1);
  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  return FigTTMLSerializerFlush(*DerivedStorage);
}

uint64_t startTagUsesIndentation(const __CFString *a1)
{
  int v1;
  CFTypeRef v2;
  uint64_t v3;
  CFTypeRef cf1;

  cf1 = 0;
  v1 = copyElementLocalName(a1, &cf1);
  v2 = cf1;
  if (v1 || !CFEqual(cf1, CFSTR("span")) && !CFEqual(v2, CFSTR("br")))
  {
    v3 = 1;
    if (!v2)
      return v3;
    goto LABEL_5;
  }
  v3 = 0;
  if (v2)
LABEL_5:
    CFRelease(v2);
  return v3;
}

__CFString *createIndentation(uint64_t a1)
{
  uint64_t v2;
  __CFString *Mutable;

  v2 = 2 * a1;
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2 * a1);
  if (Mutable)
  {
    if (a1)
    {
      do
      {
        CFStringAppend(Mutable, CFSTR(" "));
        --v2;
      }
      while (v2);
    }
  }
  else
  {
    FigSignalErrorAt();
  }
  return Mutable;
}

uint64_t copyElementLocalName(CFStringRef theString, _QWORD *a2)
{
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v4;
  CFIndex v5;
  const void *ValueAtIndex;
  const void *v8;
  uint64_t v9;

  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theString, CFSTR(":"));
  if (!ArrayBySeparatingStrings)
    return FigSignalErrorAt();
  v4 = ArrayBySeparatingStrings;
  if (CFArrayGetCount(ArrayBySeparatingStrings) < 1 || CFArrayGetCount(v4) >= 3)
  {
    v9 = FigSignalErrorAt();
    goto LABEL_13;
  }
  if (CFArrayGetCount(v4) == 1)
  {
    v5 = 0;
    goto LABEL_9;
  }
  if (CFArrayGetCount(v4) == 2)
  {
    v5 = 1;
LABEL_9:
    ValueAtIndex = CFArrayGetValueAtIndex(v4, v5);
    v8 = ValueAtIndex;
    if (ValueAtIndex)
      CFRetain(ValueAtIndex);
    goto LABEL_12;
  }
  v8 = 0;
LABEL_12:
  v9 = 0;
  *a2 = v8;
LABEL_13:
  CFRelease(v4);
  return v9;
}

uint64_t FigRenderPipelineCreateForBufferQueue(uint64_t a1, const void *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  uint64_t v7;
  uint64_t DerivedStorage;
  const __CFNumber *Value;
  CMTimeEpoch epoch;
  CMTime v12;
  Float64 valuePtr;
  CFTypeRef cf;

  cf = 0;
  if (!a4 || !a2)
    return FigSignalErrorAt();
  FigRenderPipelineGetClassID();
  v7 = CMDerivedObjectCreate();
  if (!(_DWORD)v7)
  {
    DerivedStorage = CMBaseObjectGetDerivedStorage();
    CFRetain(a2);
    *(_QWORD *)(DerivedStorage + 8) = a2;
    if (a3)
    {
      Value = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("PipelineLatency"));
      if (Value)
      {
        valuePtr = 0.0;
        CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr);
        CMTimeMakeWithSeconds(&v12, valuePtr, 1000);
        epoch = v12.epoch;
        *(_OWORD *)(DerivedStorage + 16) = *(_OWORD *)&v12.value;
        *(_QWORD *)(DerivedStorage + 32) = epoch;
      }
    }
    v7 = 0;
    *a4 = cf;
  }
  return v7;
}

uint64_t figRenderPipelineForBufferQueueInvalidate()
{
  uint64_t DerivedStorage;
  const void *v1;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (DerivedStorage)
  {
    if (!*(_BYTE *)DerivedStorage)
    {
      *(_BYTE *)DerivedStorage = 1;
      v1 = *(const void **)(DerivedStorage + 8);
      if (v1)
        CFRelease(v1);
    }
  }
  return 0;
}

__CFString *figRenderPipelineForBufferQueueCopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage;
  __CFString *Mutable;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigRenderPipelineForBufferQueue %p: "), a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("bufferQueue %@"), *(_QWORD *)(DerivedStorage + 8));
  CFStringAppendFormat(Mutable, 0, CFSTR(">"));
  return Mutable;
}

uint64_t figRenderPipelineForBufferQueueCopyProperty(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  _BYTE *DerivedStorage;
  _BYTE *v7;
  uint64_t result;
  const void *v9;
  void *v10;
  void *v11;
  const __CFAllocator *v12;
  CMTime v13;

  DerivedStorage = (_BYTE *)CMBaseObjectGetDerivedStorage();
  if (!DerivedStorage)
    return FigSignalErrorAt();
  v7 = DerivedStorage;
  if (*DerivedStorage)
    return FigSignalErrorAt();
  if (!CFEqual(CFSTR("SourceSampleBufferQueue"), a2))
  {
    if (!CFEqual(a2, CFSTR("PipelineLatency")))
      return 4294954446;
    if ((v7[28] & 1) == 0)
    {
      result = 0;
      *a4 = 0;
      return result;
    }
    v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v13 = *(CMTime *)(v7 + 16);
    v10 = CMTimeCopyAsDictionary(&v13, v12);
    goto LABEL_13;
  }
  v9 = (const void *)*((_QWORD *)v7 + 1);
  if (v9)
  {
    v10 = (void *)CFRetain(v9);
LABEL_13:
    v11 = v10;
    goto LABEL_14;
  }
  v11 = 0;
LABEL_14:
  result = 0;
  *a4 = v11;
  return result;
}

uint64_t figRenderPipelineForBufferQueueSetProperty()
{
  _BYTE *DerivedStorage;

  DerivedStorage = (_BYTE *)CMBaseObjectGetDerivedStorage();
  if (DerivedStorage && !*DerivedStorage)
    return 4294954446;
  else
    return FigSignalErrorAt();
}

uint64_t RegisterFigOVCGLObjectCacheWrapperType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigOVCGLObjectCacheWrapperTypeID = result;
  return result;
}

uint64_t FigOVCGLObjectCacheWrapperCreate(const __CFAllocator *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t Instance;
  _QWORD *v7;
  uint64_t v8;
  CFMutableDictionaryRef Mutable;
  CFMutableArrayRef v10;
  uint64_t v12;

  if (!a2)
    return FigSignalErrorAt();
  if (!a3)
    return FigSignalErrorAt();
  MEMORY[0x19402F294](&sRegisterFigOVCGLObjectCacheWrapperTypeOnce, RegisterFigOVCGLObjectCacheWrapperType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return FigSignalErrorAt();
  v7 = (_QWORD *)Instance;
  *(_QWORD *)(Instance + 32) = a2;
  v8 = FigSimpleMutexCreate();
  v7[3] = v8;
  if (v8
    && (Mutable = CFDictionaryCreateMutable(a1, 0, 0, 0), (v7[5] = Mutable) != 0)
    && (v10 = CFArrayCreateMutable(a1, 0, 0), (v7[6] = v10) != 0))
  {
    *a3 = v7;
    return 0;
  }
  else
  {
    v12 = FigSignalErrorAt();
    CFRelease(v7);
    return v12;
  }
}

uint64_t FigOVCGLObjectCacheWrapperInvalidate(uint64_t a1)
{
  const void *v2;
  const void *v3;

  if (a1)
  {
    MEMORY[0x19402EEEC](*(_QWORD *)(a1 + 24));
    if (!*(_BYTE *)(a1 + 16))
    {
      *(_BYTE *)(a1 + 16) = 1;
      *(_QWORD *)(a1 + 32) = 0;
      v2 = *(const void **)(a1 + 48);
      if (v2)
      {
        CFRelease(v2);
        *(_QWORD *)(a1 + 48) = 0;
      }
      v3 = *(const void **)(a1 + 40);
      if (v3)
      {
        CFRelease(v3);
        *(_QWORD *)(a1 + 40) = 0;
      }
    }
    JUMPOUT(0x19402EF04);
  }
  return FigSignalErrorAt();
}

uint64_t FigOVCGLObjectCacheWrapperFlushCacheEntriesForDeletedBackings(uint64_t a1)
{
  const __CFArray *v2;
  uint64_t v3;
  CFRange v5;

  if (!a1)
    return FigSignalErrorAt();
  MEMORY[0x19402EEEC](*(_QWORD *)(a1 + 24));
  if (*(_BYTE *)(a1 + 16))
  {
    v3 = FigSignalErrorAt();
  }
  else
  {
    v2 = *(const __CFArray **)(a1 + 48);
    v5.length = CFArrayGetCount(v2);
    v5.location = 0;
    CFArrayApplyFunction(v2, v5, (CFArrayApplierFunction)glObjectCacheWrapper_flushSurfaceFromGLObjectCache, *(void **)(a1 + 32));
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 48));
    v3 = 0;
  }
  MEMORY[0x19402EF04](*(_QWORD *)(a1 + 24));
  return v3;
}

uint64_t glObjectCacheWrapper_flushSurfaceFromGLObjectCache(int a1, unint64_t *a2)
{
  return OVCGLObjectCacheFlushObjectsForSurface(a2, a1);
}

uint64_t FigOVCGLObjectCacheWrapperGetObjectForPixelBufferAndPlane(uint64_t a1, CVPixelBufferRef pixelBuffer, uint64_t a3, int a4, _DWORD *a5, BOOL *a6)
{
  __IOSurface *IOSurface;
  IOSurfaceID ID;
  const void *BufferBacking;
  uint64_t ObjectForSurfaceAndPlane;
  const void *v15;
  __CFNotificationCenter *LocalCenter;
  uint64_t v17;

  if (a1)
  {
    if (pixelBuffer)
    {
      IOSurface = CVPixelBufferGetIOSurface(pixelBuffer);
      if (IOSurface)
      {
        ID = IOSurfaceGetID(IOSurface);
        BufferBacking = (const void *)CVPixelBufferGetBufferBacking();
        MEMORY[0x19402EEEC](*(_QWORD *)(a1 + 24));
        if (*(_BYTE *)(a1 + 16))
        {
          ObjectForSurfaceAndPlane = FigSignalErrorAt();
        }
        else
        {
          ObjectForSurfaceAndPlane = OVCGLObjectCacheGetObjectForSurfaceAndPlane(*(unint64_t **)(a1 + 32), ID, a3, a4, a5, a6);
          if (!(_DWORD)ObjectForSurfaceAndPlane)
          {
            if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a1 + 40), BufferBacking, 0))
            {
              MEMORY[0x19402EF04](*(_QWORD *)(a1 + 24));
            }
            else
            {
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), BufferBacking, (const void *)ID);
              MEMORY[0x19402EF04](*(_QWORD *)(a1 + 24));
              v15 = (const void *)FigCFWeakReferenceHolderCreateWithReferencedObject();
              LocalCenter = CFNotificationCenterGetLocalCenter();
              CFNotificationCenterAddObserver(LocalCenter, v15, (CFNotificationCallback)glObjectCacheWrapper_deregisterPixelBufferBackingThatWillBeDeleted, (CFStringRef)*MEMORY[0x1E0CA8C50], BufferBacking, CFNotificationSuspensionBehaviorDeliverImmediately);
            }
            return 0;
          }
        }
        v17 = ObjectForSurfaceAndPlane;
        MEMORY[0x19402EF04](*(_QWORD *)(a1 + 24));
        return v17;
      }
    }
  }
  return FigSignalErrorAt();
}

void glObjectCacheWrapper_deregisterPixelBufferBackingThatWillBeDeleted(uint64_t a1, const void *a2, const __CFString *a3, const void *a4)
{
  uint64_t v7;
  uint64_t v8;
  __CFArray *v9;
  __CFNotificationCenter *v10;
  __CFNotificationCenter *LocalCenter;
  void *value;

  v7 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (!v7)
  {
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterRemoveObserver(LocalCenter, a2, a3, a4);
    if (!a2)
      return;
    goto LABEL_8;
  }
  v8 = v7;
  MEMORY[0x19402EEEC](*(_QWORD *)(v7 + 24));
  if (!*(_BYTE *)(v8 + 16))
  {
    value = 0;
    if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(v8 + 40), a4, (const void **)&value))
    {
      v9 = *(__CFArray **)(v8 + 48);
      if (v9)
        CFArrayAppendValue(v9, (const void *)value);
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v8 + 40), a4);
  }
  MEMORY[0x19402EF04](*(_QWORD *)(v8 + 24));
  v10 = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveObserver(v10, a2, a3, a4);
  CFRelease((CFTypeRef)v8);
  if (a2)
LABEL_8:
    CFRelease(a2);
}

uint64_t glObjectCacheWrapper_Finalize(uint64_t a1)
{
  uint64_t result;

  FigOVCGLObjectCacheWrapperInvalidate(a1);
  result = *(_QWORD *)(a1 + 24);
  if (result)
  {
    result = FigSimpleMutexDestroy();
    *(_QWORD *)(a1 + 24) = 0;
  }
  return result;
}

CFStringRef glObjectCacheWrapper_CopyFormattingDesc(uint64_t a1)
{
  const char *v1;

  if (*(_BYTE *)(a1 + 16))
    v1 = " (invalidated)";
  else
    v1 = "";
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigOVCGLObjectCacheWrapper %p%s]"), a1, v1);
}

__CFString *glObjectCacheWrapper_CopyDebugDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  CFIndex v4;
  int v5;
  CFAllocatorRef v6;
  const __CFDictionary *Count;
  const char *v8;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = CFGetRetainCount((CFTypeRef)a1);
  v5 = *(unsigned __int8 *)(a1 + 16);
  v6 = CFGetAllocator((CFTypeRef)a1);
  Count = *(const __CFDictionary **)(a1 + 40);
  if (Count)
    Count = (const __CFDictionary *)CFDictionaryGetCount(Count);
  v8 = " (invalidated)";
  if (!v5)
    v8 = "";
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigOVCGLObjectCacheWrapper %p retainCount: %d%s allocator: %p, tracking %d buffers>"), a1, v4, v8, v6, Count);
  return Mutable;
}

double FigPlayerResourceArbiterPlayerSpecifierGetDisplaySize(uint64_t a1)
{
  return *(double *)(a1 + 24);
}

uint64_t FigPlayerResourceArbiterPlayerSpecifierGetIsMuted(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 72);
}

uint64_t FigPlayerResourceArbiterPlayerSpecifierGetIsFullyActive(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 88);
}

double FigPlayerResourceArbiterPlayerSpecifierGetResolutionCeiling(uint64_t a1)
{
  return *(double *)(a1 + 40);
}

uint64_t FigPlayerResourceArbiterPlayerSpecifierGetPlayerRole(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

double FigPlayerResourceArbiterPlayerSpecifierGetResolutionFloor(uint64_t a1)
{
  return *(double *)(a1 + 56);
}

uint64_t FigPlayerResourceArbiterPlayerSpecifierSetDisplaySize(uint64_t a1, double a2, double a3)
{
  if (!*(_BYTE *)(a1 + 16))
    return FigSignalErrorAt();
  *(double *)(a1 + 24) = a2;
  *(double *)(a1 + 32) = a3;
  return 0;
}

uint64_t FigPlayerResourceArbiterPlayerSpecifierSetIsMuted(uint64_t a1, char a2)
{
  if (!*(_BYTE *)(a1 + 16))
    return FigSignalErrorAt();
  *(_BYTE *)(a1 + 72) = a2;
  return 0;
}

uint64_t FigPlayerResourceArbiterPlayerSpecifierSetIsFullyActive(uint64_t a1, char a2)
{
  if (!*(_BYTE *)(a1 + 16))
    return FigSignalErrorAt();
  *(_BYTE *)(a1 + 88) = a2;
  return 0;
}

uint64_t FigPlayerResourceArbiterPlayerSpecifierSetResolutionCeiling(uint64_t a1, double a2, double a3)
{
  if (!*(_BYTE *)(a1 + 16))
    return FigSignalErrorAt();
  *(double *)(a1 + 40) = a2;
  *(double *)(a1 + 48) = a3;
  return 0;
}

uint64_t FigPlayerResourceArbiterPlayerSpecifierSetPlayerRole(uint64_t a1, CFTypeRef cf)
{
  const void *v2;

  if (!*(_BYTE *)(a1 + 16))
    return FigSignalErrorAt();
  v2 = *(const void **)(a1 + 80);
  *(_QWORD *)(a1 + 80) = cf;
  if (cf)
    CFRetain(cf);
  if (v2)
    CFRelease(v2);
  return 0;
}

uint64_t FigPlayerResourceArbiterPlayerSpecifierSetResolutionFloor(uint64_t a1, double a2, double a3)
{
  if (!*(_BYTE *)(a1 + 16))
    return FigSignalErrorAt();
  *(double *)(a1 + 56) = a2;
  *(double *)(a1 + 64) = a3;
  return 0;
}

uint64_t FigPlayerResourceArbiterPlayerSpecifierMarkAsImmutable(uint64_t a1)
{
  *(_BYTE *)(a1 + 16) = 0;
  return 0;
}

uint64_t FigPlayerResourceArbiterPlayerSpecifierCreate(uint64_t *a1)
{
  uint64_t Instance;

  if (!a1)
    return FigSignalErrorAt();
  FigGetAllocatorForMedia();
  MEMORY[0x19402F294](&FigPlayerResourceArbiterPlayerSpecifierGetTypeID_sFigPlayerResourceArbiterRegisterOnce, FigPlayerResourceArbiter_initOnce);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return FigSignalErrorAt();
  *(_BYTE *)(Instance + 16) = 1;
  *a1 = Instance;
  return 0;
}

uint64_t FigPlayerResourceArbiter_initOnce()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigPlayerResourceArbiterPlayerSpecifierID = result;
  return result;
}

double fpraps_init(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void fpraps_finalize(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 80);
  if (v1)
    CFRelease(v1);
}

__CFString *fpraps_copyFormattingDesc(uint64_t a1)
{
  const __CFAllocator *AllocatorForMedia;
  __CFString *Mutable;
  __CFString *v4;
  double v5;
  double v7;
  double v9;

  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  Mutable = CFStringCreateMutable(AllocatorForMedia, 0);
  v4 = Mutable;
  if (Mutable)
  {
    v5 = *(double *)(a1 + 32);
    if (*(double *)(a1 + 24) > 2.22044605e-16 || v5 > 2.22044605e-16)
      CFStringAppendFormat(Mutable, 0, CFSTR(" [Display Size: %.0fx%.0f]"), *(_QWORD *)(a1 + 24), *(_QWORD *)&v5);
    v7 = *(double *)(a1 + 48);
    if (*(double *)(a1 + 40) > 2.22044605e-16 || v7 > 2.22044605e-16)
      CFStringAppendFormat(v4, 0, CFSTR(" [Ceiling: %.0fx%.0f]"), *(_QWORD *)(a1 + 40), *(_QWORD *)&v7);
    v9 = *(double *)(a1 + 64);
    if (*(double *)(a1 + 56) > 2.22044605e-16 || v9 > 2.22044605e-16)
      CFStringAppendFormat(v4, 0, CFSTR(" [Floor: %.0fx%.0f]"), *(_QWORD *)(a1 + 56), *(_QWORD *)&v9);
    if (*(_QWORD *)(a1 + 80))
      CFStringAppendFormat(v4, 0, CFSTR(" [Role: %@]"), *(_QWORD *)(a1 + 80));
    if (!*(_BYTE *)(a1 + 88))
      CFStringAppend(v4, CFSTR(" [Not Active]"));
    if (*(_BYTE *)(a1 + 72))
      CFStringAppend(v4, CFSTR(" [Muted]"));
  }
  return v4;
}

uint64_t FigTTMLDocumentWriterCreateForSerializer(uint64_t a1, const void *a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t DerivedStorage;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = 0;
  if (!a2 || !a3)
    return FigSignalErrorAt();
  FigTTMLDocumentWriterGetClassID();
  v5 = CMDerivedObjectCreate();
  if (!(_DWORD)v5)
  {
    FigTTMLDocumentWriterGetCMBaseObject(v31);
    DerivedStorage = CMBaseObjectGetDerivedStorage();
    *(_QWORD *)DerivedStorage = CFRetain(a2);
    *(_QWORD *)&v18 = 0;
    v20 = 0u;
    v21 = 0u;
    v22 = 0u;
    v23 = 0u;
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    *((_QWORD *)&v18 + 1) = CFSTR("utc");
    *(_QWORD *)&v19 = CFSTR("nonDrop");
    *((_QWORD *)&v19 + 1) = 30;
    v30 = 0;
    CMTimeMake((CMTime *)((char *)&v19 + 12), 1, 1);
    *((_QWORD *)&v21 + 1) = CFSTR("discontinuous");
    *(_QWORD *)&v22 = 0x100000001;
    *((_QWORD *)&v22 + 1) = *MEMORY[0x1E0CA4AC0];
    v7 = *(_OWORD *)(MEMORY[0x1E0CA4AE8] + 16);
    v23 = *MEMORY[0x1E0CA4AE8];
    v24 = v7;
    v8 = *(_OWORD *)(MEMORY[0x1E0CA4AE8] + 48);
    v25 = *(_OWORD *)(MEMORY[0x1E0CA4AE8] + 32);
    v26 = v8;
    LODWORD(v27) = 1;
    CMTimeMake((CMTime *)((char *)&v27 + 4), 1, 1);
    v5 = 0;
    *((_QWORD *)&v29 + 1) = 0;
    v30 = 0;
    *(_QWORD *)&v29 = CFSTR("smpte");
    v10 = v21;
    v9 = v22;
    v11 = v19;
    *(_OWORD *)(DerivedStorage + 40) = v20;
    *(_OWORD *)(DerivedStorage + 56) = v10;
    *(_OWORD *)(DerivedStorage + 72) = v9;
    v12 = v25;
    v13 = v26;
    v14 = v24;
    *(_OWORD *)(DerivedStorage + 88) = v23;
    *(_OWORD *)(DerivedStorage + 136) = v13;
    *(_OWORD *)(DerivedStorage + 120) = v12;
    *(_OWORD *)(DerivedStorage + 104) = v14;
    *(_OWORD *)(DerivedStorage + 8) = v18;
    *(_OWORD *)(DerivedStorage + 24) = v11;
    v15 = v29;
    v16 = v27;
    *(_OWORD *)(DerivedStorage + 168) = v28;
    *(_OWORD *)(DerivedStorage + 152) = v16;
    *(_OWORD *)(DerivedStorage + 184) = v15;
    *(_QWORD *)(DerivedStorage + 200) = 0;
    *a3 = v31;
  }
  return v5;
}

uint64_t figTTMLDocumentWriterForSerializer_Invalidate()
{
  return 0;
}

void figTTMLDocumentWriterForSerializer_Finalize(uint64_t a1)
{
  const void *v1;

  FigTTMLDocumentWriterGetCMBaseObject(a1);
  v1 = *(const void **)CMBaseObjectGetDerivedStorage();
  if (v1)
    CFRelease(v1);
}

CFStringRef figTTMLDocumentWriterForSerializer_CopyDebugDesc(uint64_t a1)
{
  _QWORD *DerivedStorage;

  FigTTMLDocumentWriterGetCMBaseObject(a1);
  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("FigTTMLDocumentWriterForSerializer: %@"), *DerivedStorage);
}

uint64_t figTTMLDocumentWriterForSerializer_StartElement(void *a1, int a2)
{
  uint64_t *DerivedStorage;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t result;
  uint64_t *v9;

  FigTTMLDocumentWriterGetCMBaseObject(a1);
  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  switch(a2)
  {
    case 1:
      v5 = *DerivedStorage;
      v6 = (uint64_t *)&kFigTTML_ElementLocalName_set;
      return FigTTMLSerializerStartElement(v5, *v6);
    case 2:
      v5 = *DerivedStorage;
      v6 = (uint64_t *)&kFigTTML_ElementLocalName_body;
      return FigTTMLSerializerStartElement(v5, *v6);
    case 3:
      v5 = *DerivedStorage;
      v6 = (uint64_t *)&kFigTTML_ElementLocalName_div;
      return FigTTMLSerializerStartElement(v5, *v6);
    case 4:
      v5 = *DerivedStorage;
      v6 = (uint64_t *)&kFigTTML_ElementLocalName_p;
      return FigTTMLSerializerStartElement(v5, *v6);
    case 5:
      v5 = *DerivedStorage;
      v6 = (uint64_t *)&kFigTTML_ElementLocalName_span;
      return FigTTMLSerializerStartElement(v5, *v6);
    case 6:
      v5 = *DerivedStorage;
      v6 = (uint64_t *)&kFigTTML_ElementLocalName_br;
      return FigTTMLSerializerStartElement(v5, *v6);
    case 7:
      FigTTMLDocumentWriterGetCMBaseObject(a1);
      v7 = CMBaseObjectGetDerivedStorage();
      result = FigTTMLSerializerStartElement(*(_QWORD *)v7, (uint64_t)CFSTR("tt"));
      if (!(_DWORD)result)
      {
        *(_DWORD *)(v7 + 208) = 0;
        MEMORY[0x19402F294](&getNamespaceToPrefixDictionary_sNamespaceURIToPrefixOnce, initializeNamespaceToPrefixDictionary);
        CFDictionaryApplyFunction((CFDictionaryRef)sNamespaceToPrefixDictionary, (CFDictionaryApplierFunction)declareNamespace, a1);
        result = *(unsigned int *)(v7 + 208);
        if (!(_DWORD)result)
          return FigTTMLSerializerSetAttribute(*(_QWORD *)v7, (uint64_t)CFSTR("xmlns"), (uint64_t)CFSTR("http://www.w3.org/ns/ttml"));
      }
      return result;
    case 8:
      v5 = *DerivedStorage;
      v6 = (uint64_t *)&kFigTTML_ElementLocalName_head;
      return FigTTMLSerializerStartElement(v5, *v6);
    case 9:
      v5 = *DerivedStorage;
      v6 = (uint64_t *)&kFigTTML_ElementLocalName_layout;
      return FigTTMLSerializerStartElement(v5, *v6);
    case 10:
      v5 = *DerivedStorage;
      v6 = (uint64_t *)&kFigTTML_ElementLocalName_region;
      return FigTTMLSerializerStartElement(v5, *v6);
    case 11:
      v5 = *DerivedStorage;
      v6 = (uint64_t *)&kFigTTML_ElementLocalName_metadata;
      return FigTTMLSerializerStartElement(v5, *v6);
    case 12:
      v5 = *DerivedStorage;
      v6 = (uint64_t *)&kFigTTML_ElementLocalName_styling;
      return FigTTMLSerializerStartElement(v5, *v6);
    case 13:
      v5 = *DerivedStorage;
      v6 = (uint64_t *)&kFigTTML_ElementLocalName_style;
      return FigTTMLSerializerStartElement(v5, *v6);
    case 15:
      v9 = (uint64_t *)&kFigTTML_ElementLocalName_profile;
      goto LABEL_22;
    case 17:
      v9 = (uint64_t *)&kFigTTML_ElementLocalName_extensions;
      goto LABEL_22;
    case 19:
      v9 = (uint64_t *)&kFigTTML_ElementLocalName_extension;
LABEL_22:
      result = startElementWithNamespace((uint64_t)a1, CFSTR("http://www.w3.org/ns/ttml#parameter"), *v9);
      break;
    default:
      result = FigSignalErrorAt();
      break;
  }
  return result;
}

uint64_t figTTMLDocumentWriterForSerializer_EndElement(uint64_t a1)
{
  uint64_t *DerivedStorage;

  FigTTMLDocumentWriterGetCMBaseObject(a1);
  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  return FigTTMLSerializerEndElement(*DerivedStorage);
}

uint64_t figTTMLDocumentWriterForSerializer_AddCaptionData(uint64_t a1, uint64_t a2)
{
  uint64_t *DerivedStorage;
  uint64_t (*v4)(uint64_t);
  const __CFString *v5;

  FigTTMLDocumentWriterGetCMBaseObject(a1);
  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  v4 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
  if (v4)
    v5 = (const __CFString *)v4(a2);
  else
    v5 = &stru_1E2FD85F8;
  return FigTTMLSerializerAddText(*DerivedStorage, (uint64_t)v5);
}

uint64_t figTTMLDocumentWriterForSerializer_SetAttribute(uint64_t a1, const __CFString *a2, const void *a3)
{
  uint64_t DerivedStorage;
  uint64_t v7;
  const __CFString *v8;
  CFTypeID v10;
  int32_t v11;
  CFStringRef v12;
  CFStringRef v13;
  uint64_t v14;
  uint64_t v15;
  CFTypeID v16;
  uint64_t v17;
  const __CFString *v18;
  CFTypeID v19;
  const __CFString *v20;
  CFTypeID v21;
  const __CFString *v22;
  CFTypeID v23;
  const __CFString *v24;
  CFTypeID v25;
  CFTypeID v26;
  CFTypeID v27;
  CMTime v28;
  CMTime v29;
  CMTime valuePtr;

  FigTTMLDocumentWriterGetCMBaseObject(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (FigCFEqual())
  {
    v7 = *(_QWORD *)DerivedStorage;
    v8 = CFSTR("xml:id");
    return FigTTMLSerializerSetAttribute(v7, (uint64_t)v8, (uint64_t)a3);
  }
  if (FigCFEqual())
  {
    v7 = *(_QWORD *)DerivedStorage;
    v8 = CFSTR("xml:space");
    return FigTTMLSerializerSetAttribute(v7, (uint64_t)v8, (uint64_t)a3);
  }
  if (FigCFEqual())
  {
    v7 = *(_QWORD *)DerivedStorage;
    v8 = CFSTR("xml:lang");
    return FigTTMLSerializerSetAttribute(v7, (uint64_t)v8, (uint64_t)a3);
  }
  if (FigCFEqual())
  {
    v7 = *(_QWORD *)DerivedStorage;
    v8 = CFSTR("xml:base");
    return FigTTMLSerializerSetAttribute(v7, (uint64_t)v8, (uint64_t)a3);
  }
  if (FigCFEqual() || FigCFEqual() || FigCFEqual())
  {
    if (a3)
    {
      v10 = CFGetTypeID(a3);
      if (v10 == CFDictionaryGetTypeID())
      {
        memset(&valuePtr, 0, sizeof(valuePtr));
        CMTimeMakeFromDictionary(&valuePtr, (CFDictionaryRef)a3);
        if ((valuePtr.flags & 0x1D) == 1)
        {
          if (FigCFEqual())
          {
            v11 = *(_DWORD *)(DerivedStorage + 32);
            v29 = valuePtr;
            v28 = *(CMTime *)(DerivedStorage + 36);
            v12 = FigTTMLCMTimeCopyAsClockTimeSyntax(&v29, v11, &v28);
          }
          else
          {
            v29 = valuePtr;
            v12 = FigTTMLCMTimeCopyAsOffsetTimeSyntax(&v29);
          }
          v13 = v12;
          v14 = FigTTMLSerializerSetAttribute(*(_QWORD *)DerivedStorage, (uint64_t)a2, (uint64_t)v12);
          goto LABEL_20;
        }
LABEL_62:
        v15 = FigSignalErrorAt();
        v13 = 0;
LABEL_21:
        if (v13)
          CFRelease(v13);
        return v15;
      }
    }
    return FigSignalErrorAt();
  }
  if (FigCFEqual())
  {
    if (a3)
    {
      v16 = CFGetTypeID(a3);
      if (v16 == CFStringGetTypeID())
      {
        v17 = writeStringAttributeWithNamespace(a1, a2, (uint64_t)a3);
        if (!(_DWORD)v17)
        {
          v18 = CFSTR("utc");
          if (CFEqual(a3, CFSTR("utc"))
            || (v18 = CFSTR("local"), CFEqual(a3, CFSTR("local")))
            || (v18 = CFSTR("gps"), CFEqual(a3, CFSTR("gps"))))
          {
            v15 = 0;
            *(_QWORD *)(DerivedStorage + 16) = v18;
            return v15;
          }
          return 0;
        }
        return v17;
      }
    }
  }
  else if (FigCFEqual())
  {
    if (a3)
    {
      v19 = CFGetTypeID(a3);
      if (v19 == CFStringGetTypeID())
      {
        v17 = writeStringAttributeWithNamespace(a1, a2, (uint64_t)a3);
        if (!(_DWORD)v17)
        {
          v20 = CFSTR("media");
          if (CFEqual(a3, CFSTR("media"))
            || (v20 = CFSTR("smpte"), CFEqual(a3, CFSTR("smpte")))
            || (v20 = CFSTR("clock"), CFEqual(a3, CFSTR("clock"))))
          {
            v15 = 0;
            *(_QWORD *)(DerivedStorage + 184) = v20;
            return v15;
          }
          return 0;
        }
        return v17;
      }
    }
  }
  else if (FigCFEqual())
  {
    if (a3)
    {
      v21 = CFGetTypeID(a3);
      if (v21 == CFStringGetTypeID())
      {
        v17 = writeStringAttributeWithNamespace(a1, a2, (uint64_t)a3);
        if (!(_DWORD)v17)
        {
          v22 = CFSTR("dropNTSC");
          if (CFEqual(a3, CFSTR("dropNTSC"))
            || (v22 = CFSTR("dropPAL"), CFEqual(a3, CFSTR("dropPAL")))
            || (v22 = CFSTR("nonDrop"), CFEqual(a3, CFSTR("nonDrop"))))
          {
            v15 = 0;
            *(_QWORD *)(DerivedStorage + 24) = v22;
            return v15;
          }
          return 0;
        }
        return v17;
      }
    }
  }
  else
  {
    if (!FigCFEqual())
    {
      if (FigCFEqual())
      {
        if (!a3)
          return FigSignalErrorAt();
        v25 = CFGetTypeID(a3);
        if (v25 != CFNumberGetTypeID())
          return FigSignalErrorAt();
        LODWORD(valuePtr.value) = 0;
        CFNumberGetValue((CFNumberRef)a3, kCFNumberIntType, &valuePtr);
        v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%d"), LODWORD(valuePtr.value));
        if (v13)
        {
          v15 = FigTTMLSerializerSetAttribute(*(_QWORD *)DerivedStorage, (uint64_t)CFSTR("ttp:frameRate"), (uint64_t)v13);
          if (!(_DWORD)v15)
            *(_DWORD *)(DerivedStorage + 32) = valuePtr.value;
          goto LABEL_21;
        }
      }
      else
      {
        if (!FigCFEqual())
        {
          if (a3)
          {
            v27 = CFGetTypeID(a3);
            if (v27 == CFStringGetTypeID())
              return writeStringAttributeWithNamespace(a1, a2, (uint64_t)a3);
          }
          return FigSignalErrorAt();
        }
        if (!a3)
          return FigSignalErrorAt();
        v26 = CFGetTypeID(a3);
        if (v26 != CFDictionaryGetTypeID())
          return FigSignalErrorAt();
        memset(&valuePtr, 0, sizeof(valuePtr));
        CMTimeMakeFromDictionary(&valuePtr, (CFDictionaryRef)a3);
        if ((valuePtr.flags & 0x1D) != 1)
          goto LABEL_62;
        v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%lld %d"), valuePtr.value, valuePtr.timescale);
        if (v13)
        {
          v15 = FigTTMLSerializerSetAttribute(*(_QWORD *)DerivedStorage, (uint64_t)CFSTR("ttp:frameRateMultiplier"), (uint64_t)v13);
          if (!(_DWORD)v15)
            *(CMTime *)(DerivedStorage + 36) = valuePtr;
          goto LABEL_21;
        }
      }
      v14 = FigSignalErrorAt();
LABEL_20:
      v15 = v14;
      goto LABEL_21;
    }
    if (a3)
    {
      v23 = CFGetTypeID(a3);
      if (v23 == CFStringGetTypeID())
      {
        v17 = writeStringAttributeWithNamespace(a1, a2, (uint64_t)a3);
        if (!(_DWORD)v17)
        {
          v24 = CFSTR("continuous");
          if (CFEqual(a3, CFSTR("continuous")) || (v24 = CFSTR("discontinuous"), CFEqual(a3, CFSTR("discontinuous"))))
          {
            v15 = 0;
            *(_QWORD *)(DerivedStorage + 64) = v24;
            return v15;
          }
          return 0;
        }
        return v17;
      }
    }
  }
  return FigSignalErrorAt();
}

uint64_t figTTMLDocumentWriterForSerializer_Flush(uint64_t a1)
{
  uint64_t *DerivedStorage;

  FigTTMLDocumentWriterGetCMBaseObject(a1);
  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  return FigTTMLSerializerFlush(*DerivedStorage);
}

uint64_t startElementWithNamespace(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t *DerivedStorage;
  const __CFAllocator *v6;
  const void *Value;
  CFStringRef v8;
  uint64_t started;

  FigTTMLDocumentWriterGetCMBaseObject(a1);
  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  MEMORY[0x19402F294](&getNamespaceToPrefixDictionary_sNamespaceURIToPrefixOnce, initializeNamespaceToPrefixDictionary);
  Value = CFDictionaryGetValue((CFDictionaryRef)sNamespaceToPrefixDictionary, a2);
  v8 = CFStringCreateWithFormat(v6, 0, CFSTR("%@:%@"), Value, a3);
  started = FigTTMLSerializerStartElement(*DerivedStorage, (uint64_t)v8);
  if (v8)
    CFRelease(v8);
  return started;
}

void declareNamespace(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t v6;
  CFStringRef v7;

  FigTTMLDocumentWriterGetCMBaseObject(a3);
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!*(_DWORD *)(DerivedStorage + 208))
  {
    v6 = DerivedStorage;
    v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("xmlns:%@"), a2);
    *(_DWORD *)(v6 + 208) = FigTTMLSerializerSetAttribute(*(_QWORD *)v6, (uint64_t)v7, a1);
    if (v7)
      CFRelease(v7);
  }
}

CFDictionaryRef initializeNamespaceToPrefixDictionary()
{
  CFDictionaryRef result;
  _OWORD v1[5];
  const __CFString *v2;
  void *keys[12];

  keys[11] = *(void **)MEMORY[0x1E0C80C00];
  keys[0] = CFSTR("http://www.w3.org/ns/ttml#parameter");
  keys[1] = CFSTR("http://www.w3.org/ns/ttml#styling");
  keys[2] = CFSTR("http://www.w3.org/ns/ttml#metadata");
  keys[3] = CFSTR("http://www.w3.org/ns/ttml/profile/");
  keys[4] = CFSTR("http://www.w3.org/ns/ttml/feature/");
  keys[5] = CFSTR("http://www.w3.org/ns/ttml/extension/");
  keys[6] = CFSTR("http://namespace.itunes.apple.com/itt/ttml-extension#ruby");
  keys[7] = CFSTR("http://namespace.itunes.apple.com/itt/ttml-extension#vertical");
  keys[8] = CFSTR("http://www.w3.org/ns/ttml/profile/imsc1#parameter");
  keys[9] = CFSTR("http://www.w3.org/ns/ttml/profile/imsc1#styling");
  keys[10] = CFSTR("urn:ebu:tt:style");
  v1[2] = xmmword_1E2FA7798;
  v1[3] = *(_OWORD *)&off_1E2FA77A8;
  v1[4] = xmmword_1E2FA77B8;
  v2 = CFSTR("ebutts");
  v1[0] = xmmword_1E2FA7778;
  v1[1] = *(_OWORD *)&off_1E2FA7788;
  result = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)v1, 11, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  sNamespaceToPrefixDictionary = (uint64_t)result;
  return result;
}

uint64_t writeStringAttributeWithNamespace(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  uint64_t *DerivedStorage;
  const __CFAllocator *v6;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v8;
  const void *ValueAtIndex;
  const void *v10;
  const void *Value;
  CFStringRef v12;
  CFTypeRef v13;
  uint64_t v14;
  const void *v15;

  FigTTMLDocumentWriterGetCMBaseObject(a1);
  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage();
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, CFSTR(" "));
  v8 = ArrayBySeparatingStrings;
  if (ArrayBySeparatingStrings && CFArrayGetCount(ArrayBySeparatingStrings) == 2)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v8, 0);
    v10 = CFArrayGetValueAtIndex(v8, 1);
    MEMORY[0x19402F294](&getNamespaceToPrefixDictionary_sNamespaceURIToPrefixOnce, initializeNamespaceToPrefixDictionary);
    Value = CFDictionaryGetValue((CFDictionaryRef)sNamespaceToPrefixDictionary, ValueAtIndex);
    v12 = CFStringCreateWithFormat(v6, 0, CFSTR("%@:%@"), Value, v10);
    if (v12)
    {
      v13 = v12;
      v14 = FigTTMLSerializerSetAttribute(*DerivedStorage, (uint64_t)v12, a3);
LABEL_7:
      CFRelease(v13);
LABEL_8:
      if (!v8)
        return v14;
      goto LABEL_11;
    }
    v14 = FigSignalErrorAt();
    goto LABEL_11;
  }
  v15 = CFArrayGetValueAtIndex(v8, 0);
  if (v15)
  {
    v13 = CFRetain(v15);
    v14 = FigTTMLSerializerSetAttribute(*DerivedStorage, (uint64_t)v13, a3);
    if (!v13)
      goto LABEL_8;
    goto LABEL_7;
  }
  v14 = FigTTMLSerializerSetAttribute(*DerivedStorage, 0, a3);
  if (v8)
LABEL_11:
    CFRelease(v8);
  return v14;
}

uint64_t FigAlternateFilterMonitorForHDCPNeedsNewExternalProtectionMonitorIfNecessary(void *a1, int a2, const void *a3)
{
  _QWORD *DerivedStorage;
  const void *v7;
  CFAllocatorRef v8;
  uint64_t v9;
  CFTypeRef cf;

  cf = 0;
  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  MEMORY[0x19402EA0C](*DerivedStorage);
  *((_BYTE *)DerivedStorage + 72) = a2;
  v7 = (const void *)DerivedStorage[10];
  DerivedStorage[10] = a3;
  if (a3)
    CFRetain(a3);
  if (v7)
    CFRelease(v7);
  if (!a2)
    famhdcp_releaseAndClearHDCPExternalProtectionMonitor((uint64_t)a1, 3);
  v8 = CFGetAllocator(a1);
  if (!FigAlternateHDCPLazyEPMFilterCreate((uint64_t)v8, (uint64_t)famhdcp_lazyEPMFilterGetHDCPProtectionStatusCallback, (uint64_t)famhdcp_lazyEPMFilterGetHDCPProtectionStatusCallback, (uint64_t)a1, &cf))
  {
    famhdcp_releaseAssignAndRetainCurrentEPM((uint64_t)a1, 0);
    famhdcp_removeAllEPMListeners(a1);
  }
  MEMORY[0x19402EA24](*DerivedStorage);
  v9 = famhdcp_setFilterForState(a1, cf, 0);
  if (cf)
    CFRelease(cf);
  return v9;
}

void famhdcp_releaseAndClearHDCPExternalProtectionMonitor(uint64_t a1, int a2)
{
  uint64_t DerivedStorage;
  CFTypeRef *v4;
  uint64_t *v5;
  CFTypeRef *v6;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v4 = (CFTypeRef *)DerivedStorage;
  if (a2 == 3)
  {
    v5 = (uint64_t *)(DerivedStorage + 64);
  }
  else if (a2 == 2)
  {
    v5 = (uint64_t *)(DerivedStorage + 56);
  }
  else
  {
    v5 = (uint64_t *)(DerivedStorage + 48);
  }
  if (*v5)
    FigCPEExternalProtectionMonitorEndMonitoring(*v5);
  if (a2 == 3)
  {
    v6 = v4 + 8;
  }
  else if (a2 == 2)
  {
    v6 = v4 + 7;
  }
  else
  {
    v6 = v4 + 6;
  }
  if (*v6)
  {
    CFRelease(*v6);
    *v6 = 0;
  }
}

void famhdcp_releaseAssignAndRetainCurrentEPM(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage;
  uint64_t v4;
  uint64_t v5;
  const void *v6;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (a2)
  {
    v4 = CMBaseObjectGetDerivedStorage();
    if (!CFBagContainsValue(*(CFBagRef *)(v4 + 128), a2))
    {
      CMNotificationCenterGetDefaultLocalCenter();
      if (!FigNotificationCenterAddWeakListener())
        CFBagAddValue(*(CFMutableBagRef *)(v4 + 128), a2);
    }
  }
  v5 = CMBaseObjectGetDerivedStorage();
  *(_DWORD *)(v5 + 104) = -1;
  *(_QWORD *)(v5 + 120) = 0x100000001;
  v6 = *(const void **)(DerivedStorage + 112);
  *(_QWORD *)(DerivedStorage + 112) = a2;
  if (a2)
    CFRetain(a2);
  if (v6)
    CFRelease(v6);
}

void famhdcp_removeAllEPMListeners(void *a1)
{
  uint64_t DerivedStorage;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFBagApplyFunction(*(CFBagRef *)(DerivedStorage + 128), (CFBagApplierFunction)famhdcp_removeEPMListenersApplierFunc, a1);
  CFBagRemoveAllValues(*(CFMutableBagRef *)(DerivedStorage + 128));
}

uint64_t famhdcp_setFilterForState(const void *a1, const void *a2, const void *a3)
{
  _QWORD *DerivedStorage;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFTypeRef cf;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  cf = 0;
  MEMORY[0x19402EA0C](*DerivedStorage);
  v7 = famhdcp_copyFilterForCurrentStateGuts((uint64_t)a1, &cf);
  if ((_DWORD)v7)
  {
    v9 = v7;
    MEMORY[0x19402EA24](*DerivedStorage);
  }
  else
  {
    v8 = DerivedStorage[5];
    CFDictionarySetValue((CFMutableDictionaryRef)DerivedStorage[4], a3, a2);
    MEMORY[0x19402EA24](*DerivedStorage);
    v9 = FigAlternateFilterMonitorUtilityPostStateChangedNotificationForNewFilterIfNecessary(a1, cf, a2, (uint64_t)a3, v8);
  }
  if (cf)
    CFRelease(cf);
  return v9;
}

uint64_t FigAlternateFilterMonitorCreateForHDCP(const __CFAllocator *a1, uint64_t a2, uint64_t (*a3)(int a1, uint64_t a2, _DWORD *a3, _QWORD *a4), CFTypeRef *a4)
{
  uint64_t v7;
  uint64_t DerivedStorage;
  uint64_t v9;
  uint64_t v10;
  CFAllocatorRef v11;
  CFTypeRef v12;
  CFTypeRef v13;
  uint64_t (*v14)(CFTypeRef, CFTypeRef, _QWORD);
  uint64_t v15;
  CFTypeRef v17;
  CFTypeRef cf;

  v17 = 0;
  cf = 0;
  FigAlternateFilterMonitorGetClassID();
  v7 = CMDerivedObjectCreate();
  if ((_DWORD)v7)
    goto LABEL_16;
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v9 = FigReentrantMutexCreate();
  *(_QWORD *)DerivedStorage = v9;
  if (!v9)
  {
    v7 = FigSignalErrorAt();
LABEL_16:
    v15 = v7;
    goto LABEL_10;
  }
  *(_QWORD *)(DerivedStorage + 24) = dispatch_queue_create("com.apple.coremedia.alternateFilterMonitorForHDCP.notification", 0);
  if (!a3)
    a3 = famhdcp_copyHDCPEPM;
  *(_QWORD *)(DerivedStorage + 8) = FigCFWeakReferenceHolderCreateWithReferencedObject();
  *(_QWORD *)(DerivedStorage + 16) = a3;
  *(_QWORD *)(DerivedStorage + 32) = CFDictionaryCreateMutable(a1, 0, 0, MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(DerivedStorage + 128) = CFBagCreateMutable(a1, 0, MEMORY[0x1E0C9B388]);
  *(_DWORD *)(DerivedStorage + 96) = -2;
  v10 = CMBaseObjectGetDerivedStorage();
  *(_DWORD *)(v10 + 104) = -1;
  *(_QWORD *)(v10 + 120) = 0x100000001;
  v11 = CFGetAllocator(cf);
  v7 = FigAlternateHDCPLazyEPMFilterCreate((uint64_t)v11, (uint64_t)famhdcp_lazyEPMFilterGetHDCPProtectionStatusCallback, (uint64_t)famhdcp_lazyEPMFilterGetHDCPProtectionStatusCallback, (uint64_t)cf, &v17);
  if ((_DWORD)v7)
    goto LABEL_16;
  v13 = v17;
  v12 = cf;
  v14 = *(uint64_t (**)(CFTypeRef, CFTypeRef, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
  if (v14)
  {
    v15 = v14(v12, v13, 0);
    if (!(_DWORD)v15)
    {
      *a4 = cf;
      cf = 0;
      goto LABEL_12;
    }
  }
  else
  {
    v15 = 4294954514;
  }
LABEL_10:
  if (cf)
    CFRelease(cf);
LABEL_12:
  if (v17)
    CFRelease(v17);
  return v15;
}

uint64_t famhdcp_copyHDCPEPM(int a1, uint64_t a2, _DWORD *a3, _QWORD *a4)
{
  uint64_t DerivedStorage;
  uint64_t *v8;
  uint64_t result;
  const __CFDictionary *v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  const __CFAllocator *v14;
  __CFDictionary *Mutable;
  uint64_t updated;
  CFTypeRef v17;
  uint64_t v18;

  if (*(_BYTE *)(CMBaseObjectGetDerivedStorage() + 72))
  {
    *a3 = 0;
    DerivedStorage = CMBaseObjectGetDerivedStorage();
    v8 = (uint64_t *)(DerivedStorage + 64);
    if (!*(_QWORD *)(DerivedStorage + 64))
    {
      result = FigCPEOctaviaExternalProtectionMonitorCreate(*MEMORY[0x1E0C9AE00], *(_QWORD **)(DerivedStorage + 48), 1, *(const void **)(DerivedStorage + 80), v8);
      if ((_DWORD)result)
        return result;
      v10 = 0;
LABEL_16:
      FigCPEExternalProtectionMonitorBeginMonitoring(*v8);
      if (!a4)
        goto LABEL_20;
LABEL_17:
      v17 = (CFTypeRef)*v8;
      if (*v8)
        v17 = CFRetain(v17);
      *a4 = v17;
LABEL_20:
      v18 = 0;
      result = 0;
      if (!v10)
        return result;
      goto LABEL_21;
    }
LABEL_11:
    v10 = 0;
    if (!a4)
      goto LABEL_20;
    goto LABEL_17;
  }
  if (a1)
  {
    if (a1 == 1)
    {
      *a3 = 1;
      v11 = CMBaseObjectGetDerivedStorage();
      v8 = (uint64_t *)(v11 + 56);
      v12 = 2;
      v13 = 2;
    }
    else
    {
      v11 = CMBaseObjectGetDerivedStorage();
      v13 = 0;
      v8 = 0;
      v12 = 2;
    }
  }
  else
  {
    *a3 = 0;
    v11 = CMBaseObjectGetDerivedStorage();
    v8 = (uint64_t *)(v11 + 48);
    v12 = 1;
    v13 = 1;
  }
  if (*v8)
    goto LABEL_11;
  v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return FigSignalErrorAt();
  v10 = Mutable;
  CFDictionarySetValue(Mutable, CFSTR("InformationalMode"), (const void *)*MEMORY[0x1E0C9AE50]);
  updated = FigCPEExternalProtectionMonitorCreateForMethods(v14, v12, v10, 0, v8);
  if (!(_DWORD)updated)
  {
    updated = (uint64_t)famhdcp_updateDisplayListForHDCPExternalProtectionMonitor((_QWORD **)v11, v13, *(const __CFArray **)(v11 + 88));
    if (!(_DWORD)updated)
      goto LABEL_16;
  }
  v18 = updated;
LABEL_21:
  CFRelease(v10);
  return v18;
}

uint64_t famhdcp_lazyEPMFilterGetHDCPProtectionStatusCallback(uint64_t a1, uint64_t a2)
{
  _QWORD *DerivedStorage;
  const void *v5;
  uint64_t v6;
  unsigned int HDCPStateFromExternalProtectionMonitor;
  int v8;
  int v9;
  int v11;
  CFTypeRef cf;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  cf = 0;
  v11 = -2;
  MEMORY[0x19402EA0C](*DerivedStorage);
  if (*((_DWORD *)DerivedStorage + 26) >= (int)a1)
  {
    v5 = 0;
    v6 = 1;
    goto LABEL_20;
  }
  if (DerivedStorage[14] && *((_DWORD *)DerivedStorage + 30) == (_DWORD)a1)
  {
    v5 = 0;
    v6 = *((unsigned int *)DerivedStorage + 31);
    goto LABEL_20;
  }
  v5 = (const void *)FigCFWeakReferenceHolderCopyReferencedObject();
  if (!v5
    || ((unsigned int (*)(uint64_t, const void *, int *, CFTypeRef *))DerivedStorage[2])(a1, v5, &v11, &cf))
  {
    goto LABEL_26;
  }
  if (!cf)
  {
    FigSignalErrorAt();
LABEL_26:
    v6 = 0xFFFFFFFFLL;
    goto LABEL_20;
  }
  if (!FigCFEqual())
    famhdcp_releaseAssignAndRetainCurrentEPM(a2, cf);
  *((_DWORD *)DerivedStorage + 30) = v11;
  HDCPStateFromExternalProtectionMonitor = famhdcp_getHDCPStateFromExternalProtectionMonitor(DerivedStorage[14]);
  *((_DWORD *)DerivedStorage + 31) = HDCPStateFromExternalProtectionMonitor;
  v8 = *((_DWORD *)DerivedStorage + 30);
  if (v8 < (int)a1)
    v6 = 0xFFFFFFFFLL;
  else
    v6 = HDCPStateFromExternalProtectionMonitor;
  v9 = *((_DWORD *)DerivedStorage + 30);
  if (HDCPStateFromExternalProtectionMonitor >= 2)
  {
    if (HDCPStateFromExternalProtectionMonitor == -1)
      v9 = -1;
    else
      v9 = -2;
  }
  if (*((_DWORD *)DerivedStorage + 26) < v9)
    *((_DWORD *)DerivedStorage + 26) = v8;
LABEL_20:
  MEMORY[0x19402EA24](*DerivedStorage);
  if (cf)
    CFRelease(cf);
  if (v5)
    CFRelease(v5);
  return v6;
}

uint64_t famhdcp_getHDCPStateFromExternalProtectionMonitor(uint64_t a1)
{
  uint64_t result;

  result = FigCPEExternalProtectionMonitorStableStatusDetermined(a1);
  if ((_DWORD)result)
  {
    if (FigCPEExternalProtectionMonitorGetStatus(a1) == 4)
      return 1;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

void famhdcp_observingEPMStatusChanged(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *DerivedStorage;
  uint64_t v8;
  int v9;
  int CurrentMaxSupportedHDCPLevel;
  CFAllocatorRef v11;
  uint64_t v12;
  CFTypeRef cf;
  int v14;

  cf = 0;
  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  MEMORY[0x19402EA0C](*DerivedStorage);
  v8 = CMBaseObjectGetDerivedStorage();
  v9 = *(_DWORD *)(v8 + 96);
  CurrentMaxSupportedHDCPLevel = famhdcp_getCurrentMaxSupportedHDCPLevel();
  v14 = 0;
  if (a5)
    FigCFDictionaryGetInt32IfPresent();
  if (CurrentMaxSupportedHDCPLevel != -2)
    *(_DWORD *)(v8 + 96) = CurrentMaxSupportedHDCPLevel;
  if ((v9 & 0x80000000) == 0 && CurrentMaxSupportedHDCPLevel < 0 && v14 == 1)
    ++*(_DWORD *)(v8 + 100);
  v11 = CFGetAllocator(a2);
  if (!FigAlternateHDCPLazyEPMFilterCreate((uint64_t)v11, (uint64_t)famhdcp_lazyEPMFilterGetHDCPProtectionStatusCallback, (uint64_t)famhdcp_lazyEPMFilterGetHDCPProtectionStatusCallback, (uint64_t)a2, &cf))
  {
    v12 = CMBaseObjectGetDerivedStorage();
    *(_DWORD *)(v12 + 104) = -1;
    *(_QWORD *)(v12 + 120) = 0x100000001;
  }
  MEMORY[0x19402EA24](*DerivedStorage);
  famhdcp_setFilterForState(a2, cf, 0);
  if (cf)
    CFRelease(cf);
}

uint64_t famhdcp_getCurrentMaxSupportedHDCPLevel()
{
  uint64_t DerivedStorage;
  uint64_t v1;
  uint64_t v2;
  unsigned int v3;
  uint64_t result;
  uint64_t v5;
  unsigned int HDCPStateFromExternalProtectionMonitor;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v1 = DerivedStorage;
  if (*(_BYTE *)(DerivedStorage + 72))
  {
    v2 = *(_QWORD *)(DerivedStorage + 64);
    if (v2)
    {
      v3 = famhdcp_getHDCPStateFromExternalProtectionMonitor(v2) + 1;
      if (v3 < 3)
        return dword_1932FD2A4[v3];
    }
    return 4294967294;
  }
  v5 = *(_QWORD *)(DerivedStorage + 56);
  if (v5)
  {
    HDCPStateFromExternalProtectionMonitor = famhdcp_getHDCPStateFromExternalProtectionMonitor(v5);
    if (HDCPStateFromExternalProtectionMonitor < 2)
      return 1;
    if (HDCPStateFromExternalProtectionMonitor == -1)
      result = 0xFFFFFFFFLL;
    else
      result = 4294967294;
  }
  else
  {
    result = 4294967294;
  }
  if (*(_QWORD *)(v1 + 48))
  {
    v3 = famhdcp_getHDCPStateFromExternalProtectionMonitor(*(_QWORD *)(v1 + 48)) + 1;
    if (v3 <= 2)
      return dword_1932FD2A4[v3];
    return 4294967294;
  }
  return result;
}

uint64_t famhdcp_removeEPMListenersApplierFunc()
{
  CMNotificationCenterGetDefaultLocalCenter();
  return FigNotificationCenterRemoveWeakListener();
}

uint64_t famhdcp_copyFilterForCurrentStateGuts(uint64_t a1, _QWORD *a2)
{
  uint64_t DerivedStorage;
  const void *v4;
  uint64_t v5;
  const void *Value;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!a2)
    return FigSignalErrorAt();
  v4 = *(const void **)(DerivedStorage + 40);
  v5 = CMBaseObjectGetDerivedStorage();
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 32), v4);
  *a2 = Value;
  if (Value)
    CFRetain(Value);
  return 0;
}

uint64_t famhdcp_finalize(void *a1)
{
  _QWORD *DerivedStorage;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  famhdcp_removeAllEPMListeners(a1);
  famhdcp_releaseAndClearHDCPExternalProtectionMonitor((uint64_t)a1, 1);
  famhdcp_releaseAndClearHDCPExternalProtectionMonitor((uint64_t)a1, 2);
  famhdcp_releaseAndClearHDCPExternalProtectionMonitor((uint64_t)a1, 3);
  v3 = (const void *)DerivedStorage[11];
  if (v3)
    CFRelease(v3);
  v4 = (const void *)DerivedStorage[10];
  if (v4)
    CFRelease(v4);
  v5 = (const void *)DerivedStorage[3];
  if (v5)
    CFRelease(v5);
  v6 = (const void *)DerivedStorage[1];
  if (v6)
    CFRelease(v6);
  v7 = (const void *)DerivedStorage[4];
  if (v7)
    CFRelease(v7);
  v8 = (const void *)DerivedStorage[14];
  if (v8)
    CFRelease(v8);
  v9 = (const void *)DerivedStorage[16];
  if (v9)
    CFRelease(v9);
  return FigSimpleMutexDestroy();
}

CFStringRef famhdcp_copyDebugDesc()
{
  _QWORD *DerivedStorage;
  CFStringRef v1;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  MEMORY[0x19402EA0C](*DerivedStorage);
  v1 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigAlternateFilterMonitorForHDCP currentMaxProtectedHDCPLevel:%d currentEPM:%@]"), *((unsigned int *)DerivedStorage + 26), DerivedStorage[14]);
  MEMORY[0x19402EA24](*DerivedStorage);
  return v1;
}

uint64_t famhdcp_copyProperty(uint64_t a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  _QWORD *DerivedStorage;
  uint64_t v7;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  MEMORY[0x19402EA0C](*DerivedStorage);
  if (CFEqual(a2, CFSTR("AlternateFilterMonitorProperty_MaxProtectedAlternateHDCPLevel")))
  {
    famhdcp_getCurrentMaxSupportedHDCPLevel();
  }
  else if (!CFEqual(a2, CFSTR("AlternateFilterMonitorProperty_HDCPErrorCount")))
  {
    v7 = 4294954512;
    goto LABEL_5;
  }
  v7 = 0;
  *a4 = FigCFNumberCreateSInt32();
LABEL_5:
  MEMORY[0x19402EA24](*DerivedStorage);
  return v7;
}

uint64_t famhdcp_setProperty(uint64_t a1, const void *a2, const __CFArray *a3)
{
  _QWORD *DerivedStorage;
  CFMutableArrayRef MutableCopy;
  const void *v7;
  CFArrayRef *v8;
  char v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  MEMORY[0x19402EA0C](*DerivedStorage);
  if (!CFEqual(a2, CFSTR("AlternateFilterMonitorProperty_DisplayList")))
  {
    v10 = FigSignalErrorAt();
    goto LABEL_17;
  }
  if (a3)
  {
    MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a3);
    a3 = MutableCopy;
    v8 = (CFArrayRef *)(DerivedStorage + 11);
    v7 = (const void *)DerivedStorage[11];
    DerivedStorage[11] = MutableCopy;
    if (MutableCopy)
    {
      CFRetain(MutableCopy);
      v9 = 0;
      if (!v7)
        goto LABEL_10;
      goto LABEL_9;
    }
  }
  else
  {
    v8 = (CFArrayRef *)(DerivedStorage + 11);
    v7 = (const void *)DerivedStorage[11];
    DerivedStorage[11] = 0;
  }
  v9 = 1;
  if (v7)
LABEL_9:
    CFRelease(v7);
LABEL_10:
  v11 = (_QWORD *)DerivedStorage[6];
  if (!v11 || !FigCPEExternalProtectionMonitorSetProperty(v11, CFSTR("DisplayList"), *v8))
  {
    v12 = (_QWORD *)DerivedStorage[7];
    if (v12)
      FigCPEExternalProtectionMonitorSetProperty(v12, CFSTR("DisplayList"), *v8);
  }
  if ((v9 & 1) == 0)
    CFRelease(a3);
  v10 = 0;
LABEL_17:
  MEMORY[0x19402EA24](*DerivedStorage);
  return v10;
}

_QWORD *famhdcp_updateDisplayListForHDCPExternalProtectionMonitor(_QWORD **a1, int a2, const __CFArray *a3)
{
  _QWORD **v3;
  _QWORD *result;

  if (a2 == 3)
  {
    v3 = a1 + 8;
  }
  else if (a2 == 2)
  {
    v3 = a1 + 7;
  }
  else
  {
    v3 = a1 + 6;
  }
  result = *v3;
  if (*v3)
    return (_QWORD *)FigCPEExternalProtectionMonitorSetProperty(result, CFSTR("DisplayList"), a3);
  return result;
}

uint64_t famhdcp_setState(const void *a1, const void *a2)
{
  _QWORD *DerivedStorage;
  const void *v5;
  uint64_t v6;
  const void *Value;
  const void *v8;
  uint64_t v9;
  const void *v10;
  const void *v11;
  uint64_t v12;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  MEMORY[0x19402EA0C](*DerivedStorage);
  v5 = (const void *)DerivedStorage[5];
  DerivedStorage[5] = a2;
  v6 = CMBaseObjectGetDerivedStorage();
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v6 + 32), v5);
  v8 = Value;
  if (Value)
    CFRetain(Value);
  v9 = CMBaseObjectGetDerivedStorage();
  v10 = CFDictionaryGetValue(*(CFDictionaryRef *)(v9 + 32), a2);
  v11 = v10;
  if (v10)
    CFRetain(v10);
  MEMORY[0x19402EA24](*DerivedStorage);
  v12 = FigAlternateFilterMonitorUtilityPostStateChangedNotificationForNewStateIfNecessary(a1, v8, v11, (uint64_t)v5, (uint64_t)a2);
  if (v8)
    CFRelease(v8);
  if (v11)
    CFRelease(v11);
  return v12;
}

uint64_t famhdcp_copyFilterForCurrentState(uint64_t a1, _QWORD *a2)
{
  _QWORD *DerivedStorage;
  uint64_t v5;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  MEMORY[0x19402EA0C](*DerivedStorage);
  v5 = famhdcp_copyFilterForCurrentStateGuts(a1, a2);
  MEMORY[0x19402EA24](*DerivedStorage);
  return v5;
}

uint64_t FigTTMLGetLibXMLAccess()
{
  MEMORY[0x19402F294](&FigTTMLGetLibXMLAccess_sFigLibXMLLoadOnce, figTTMLInitLibXMLLibrary);
  return s_accessLibXML;
}

void *figTTMLInitLibXMLLibrary()
{
  void *result;
  void *v1;
  uint64_t v2;

  result = dlopen("/usr/lib/libxml2.dylib", 6);
  if (result)
  {
    v1 = result;
    s_accessLibXMLFunctionPointerStorage = dlsym(result, "xmlTextReaderIsEmptyElement");
    off_1EE2A1520 = dlsym(v1, "xmlTextReaderLocalName");
    qword_1EE2A1528 = (uint64_t)dlsym(v1, "xmlStrEqual");
    off_1EE2A1530 = dlsym(v1, "xmlTextReaderMoveToNextAttribute");
    off_1EE2A1538 = dlsym(v1, "xmlTextReaderMoveToElement");
    off_1EE2A1540 = dlsym(v1, "xmlTextReaderConstLocalName");
    off_1EE2A1548 = dlsym(v1, "xmlTextReaderNamespaceUri");
    off_1EE2A1550 = dlsym(v1, "xmlTextReaderRead");
    qword_1EE2A1558 = (uint64_t)dlsym(v1, "xmlFreeTextReader");
    off_1EE2A1560 = dlsym(v1, "xmlTextReaderNodeType");
    off_1EE2A1568 = dlsym(v1, "xmlTextReaderValue");
    off_1EE2A1570 = dlsym(v1, "xmlTextReaderMoveToFirstAttribute");
    off_1EE2A1578 = dlsym(v1, "xmlTextReaderConstNamespaceUri");
    qword_1EE2A1580 = (uint64_t)dlsym(v1, "xmlTextReaderReadString");
    qword_1EE2A1590 = (uint64_t)dlsym(v1, "xmlFree");
    off_1EE2A1588 = *(_UNKNOWN **)qword_1EE2A1590;
    qword_1EE2A1598 = (uint64_t)dlsym(v1, "xmlReaderForMemory");
    qword_1EE2A15A0 = (uint64_t)dlsym(v1, "xmlOutputBufferCreateIO");
    qword_1EE2A15A8 = (uint64_t)dlsym(v1, "xmlNewTextWriter");
    qword_1EE2A15B0 = (uint64_t)dlsym(v1, "xmlOutputBufferClose");
    qword_1EE2A15B8 = (uint64_t)dlsym(v1, "xmlFreeTextWriter");
    qword_1EE2A15C0 = (uint64_t)dlsym(v1, "xmlTextWriterStartDocument");
    qword_1EE2A15C8 = (uint64_t)dlsym(v1, "xmlTextWriterEndDocument");
    qword_1EE2A15D0 = (uint64_t)dlsym(v1, "xmlTextWriterStartElementNS");
    qword_1EE2A15D8 = (uint64_t)dlsym(v1, "xmlTextWriterStartElement");
    qword_1EE2A15E0 = (uint64_t)dlsym(v1, "xmlTextWriterEndElement");
    qword_1EE2A15E8 = (uint64_t)dlsym(v1, "xmlTextWriterWriteString");
    qword_1EE2A15F0 = (uint64_t)dlsym(v1, "xmlTextWriterFlush");
    qword_1EE2A15F8 = (uint64_t)dlsym(v1, "xmlTextWriterSetQuoteChar");
    qword_1EE2A1600 = (uint64_t)dlsym(v1, "xmlTextWriterWriteAttribute");
    qword_1EE2A1608 = (uint64_t)dlsym(v1, "xmlTextWriterWriteFormatAttributeNS");
    qword_1EE2A1610 = (uint64_t)dlsym(v1, "xmlTextWriterSetIndent");
    qword_1EE2A1618 = (uint64_t)dlsym(v1, "xmlTextWriterSetIndentString");
    result = dlsym(v1, "xmlTextWriterWriteAttributeNS");
    qword_1EE2A1620 = (uint64_t)result;
    s_accessLibXML = (uint64_t)&s_accessLibXMLFunctionPointerStorage;
    v2 = 0;
    while (*(_UNKNOWN **)((char *)&s_accessLibXMLFunctionPointerStorage + v2))
    {
      v2 += 8;
      if (v2 == 272)
        return result;
    }
    s_accessLibXML = 0;
  }
  return result;
}

uint64_t FigTTMLInitializeNodeBaseStorage(uint64_t a1, __int128 *a2)
{
  __int128 v3;
  const __CFAllocator *v4;
  CFMutableDictionaryRef Mutable;
  CFMutableArrayRef v6;

  *(_QWORD *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (a2)
  {
    v3 = *a2;
    *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)a1 = v3;
  }
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(a1 + 24) = Mutable;
  if (Mutable && (v6 = CFArrayCreateMutable(v4, 0, MEMORY[0x1E0C9B378]), (*(_QWORD *)(a1 + 128) = v6) != 0))
    return 0;
  else
    return FigSignalErrorAt();
}

void FigTTMLReleaseNodeBaseStorage(uint64_t a1)
{
  const void *v2;
  const void *v3;

  v2 = *(const void **)(a1 + 128);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 128) = 0;
  }
  v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 24) = 0;
  }
}

__CFArray *FigTTMLCreateStringArrayFromNMTOKENS(const __CFString *a1)
{
  CFIndex Length;
  __CFArray *Mutable;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  CFIndex v6;
  CFIndex v7;
  CFIndex v8;
  UniChar v9;
  CFIndex v10;
  CFIndex v12;
  unsigned int v13;
  uint64_t v14;
  _OWORD v17[8];
  CFStringRef theString;
  const UniChar *v19;
  const char *v20;
  uint64_t v21;
  CFIndex v22;
  CFIndex v23;
  CFIndex v24;
  CFRange v25;
  CFRange v26;
  CFRange v27;

  Length = CFStringGetLength(a1);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  theString = a1;
  v21 = 0;
  v22 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v19 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v23 = 0;
  v24 = 0;
  v20 = CStringPtr;
  if (Length >= 1)
  {
    v6 = 0;
    v7 = 0;
    memset(v17, 0, sizeof(v17));
    do
    {
      v8 = v22;
      if (v22 <= v6)
        goto LABEL_27;
      if (v19)
      {
        v9 = v19[v21 + v6];
      }
      else if (v20)
      {
        v9 = v20[v21 + v6];
      }
      else
      {
        v10 = v23;
        if (v24 <= v6 || v23 > v6)
        {
          v12 = v6 - 4;
          if ((unint64_t)v6 < 4)
            v12 = 0;
          if (v12 + 64 < v22)
            v8 = v12 + 64;
          v23 = v12;
          v24 = v8;
          v25.location = v21 + v12;
          v25.length = v8 - v12;
          CFStringGetCharacters(theString, v25, (UniChar *)v17);
          v10 = v23;
        }
        v9 = *((_WORD *)v17 + v6 - v10);
      }
      v13 = v9;
      v14 = (1 << v9) & 0x100002600;
      if (v13 > 0x20 || v14 == 0)
      {
LABEL_27:
        ++v6;
      }
      else
      {
        if (v7 != v6)
        {
          v26.location = v7;
          v26.length = v6;
          figTTMLAddSubstringToArray(a1, v26, Mutable);
        }
        v7 = ++v6;
      }
    }
    while (v6 != Length);
    if (v7 != v6)
    {
      v27.location = v7;
      v27.length = v6;
      figTTMLAddSubstringToArray(a1, v27, Mutable);
    }
  }
  return Mutable;
}

void figTTMLAddSubstringToArray(CFStringRef str, CFRange range, __CFArray *a3)
{
  CFStringRef v4;
  CFRange v5;

  v5.length = range.length - range.location;
  v5.location = range.location;
  v4 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], str, v5);
  CFArrayAppendValue(a3, v4);
  if (v4)
    CFRelease(v4);
}

__CFArray *FigTTMLCreateReversedStringArrayFromNMTOKENS(const __CFString *a1)
{
  __CFArray *v1;
  __CFArray *v2;
  CFIndex Count;
  uint64_t v4;
  CFIndex v5;
  uint64_t v6;
  CFIndex v7;

  v1 = FigTTMLCreateStringArrayFromNMTOKENS(a1);
  v2 = v1;
  if (v1)
  {
    Count = CFArrayGetCount(v1);
    if (Count >= 0)
      v4 = Count;
    else
      v4 = Count + 1;
    if (Count >= 2)
    {
      v5 = 0;
      v6 = v4 >> 1;
      v7 = Count - 1;
      do
        CFArrayExchangeValuesAtIndices(v2, v5++, v7--);
      while (v6 != v5);
    }
  }
  return v2;
}

uint64_t FigTTMLCopyNamespaceAndLocalNameOfCurrentNode(uint64_t a1, const char **a2, CFStringRef *a3)
{
  const char *v6;
  CFAllocatorRef *v7;
  CFStringRef v8;
  const char *v9;

  MEMORY[0x19402F294](&FigTTMLGetLibXMLAccess_sFigLibXMLLoadOnce, figTTMLInitLibXMLLibrary);
  if (off_1EE2A1560(a1) != 1)
    return FigSignalErrorAt();
  v6 = (const char *)off_1EE2A1540(a1);
  v7 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (v6)
    v8 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6, 0x8000100u);
  else
    v8 = 0;
  v9 = (const char *)off_1EE2A1578(a1);
  if (v9)
    v9 = (const char *)CFStringCreateWithCString(*v7, v9, 0x8000100u);
  if (a2)
  {
    *a2 = v9;
    v9 = 0;
  }
  if (a3)
  {
    *a3 = v8;
    v8 = 0;
  }
  if (v9)
    CFRelease(v9);
  if (v8)
    CFRelease(v8);
  return 0;
}

uint64_t FigTTMLMoveCurrentNodeTo(uint64_t a1, int a2)
{
  MEMORY[0x19402F294](&FigTTMLGetLibXMLAccess_sFigLibXMLLoadOnce, figTTMLInitLibXMLLibrary);
  if (s_accessLibXML)
  {
    while (off_1EE2A1550(a1) == 1)
    {
      if (off_1EE2A1560(a1) == a2)
        return 0;
    }
  }
  return FigSignalErrorAt();
}

uint64_t FigTTMLAddCurrentElementAttributesToDictionary(uint64_t a1, __CFDictionary *a2)
{
  const char *v4;
  const char *v5;
  const char *v6;
  CFStringRef v7;
  __CFString *v8;
  const __CFAllocator *v9;
  uint64_t v10;

  MEMORY[0x19402F294](&FigTTMLGetLibXMLAccess_sFigLibXMLLoadOnce, figTTMLInitLibXMLLibrary);
  if (!s_accessLibXML)
    return FigSignalErrorAt();
  if (off_1EE2A1560(a1) == 1)
  {
    if (off_1EE2A1570(a1))
    {
      v4 = 0;
      v5 = 0;
      v6 = 0;
      v7 = 0;
      v8 = 0;
      v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      do
      {
        off_1EE2A1588(v6);
        off_1EE2A1588(v5);
        off_1EE2A1588(v4);
        if (v8)
          CFRelease(v8);
        if (v7)
          CFRelease(v7);
        v6 = (const char *)off_1EE2A1548(a1);
        v5 = (const char *)off_1EE2A1520(a1);
        v4 = (const char *)off_1EE2A1568(a1);
        v8 = figTTMLCreateNamespaceAndName(v6, v5);
        v7 = CFStringCreateWithCString(v9, v4, 0x8000100u);
        CFDictionaryAddValue(a2, v8, v7);
      }
      while (off_1EE2A1530(a1));
      off_1EE2A1538(a1);
      if (v8)
        CFRelease(v8);
      if (v7)
        CFRelease(v7);
    }
    else
    {
      off_1EE2A1538(a1);
      v4 = 0;
      v5 = 0;
      v6 = 0;
    }
    v10 = 0;
  }
  else
  {
    v10 = FigSignalErrorAt();
    v4 = 0;
    v5 = 0;
    v6 = 0;
  }
  off_1EE2A1588(v6);
  off_1EE2A1588(v5);
  off_1EE2A1588(v4);
  return v10;
}

__CFString *figTTMLCreateNamespaceAndName(const char *a1, const char *a2)
{
  __CFString *Mutable;
  __CFString *v5;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v5 = Mutable;
  if (Mutable)
  {
    if (a1)
    {
      CFStringAppendCString(Mutable, a1, 0x8000100u);
      CFStringAppendCString(v5, " ", 0x8000100u);
    }
    CFStringAppendCString(v5, a2, 0x8000100u);
  }
  return v5;
}

uint64_t FigTTMLAddAttributeToCFDictionary(uint64_t a1, __CFDictionary *a2)
{
  const char *v4;
  const char *v5;
  const char *v6;
  __CFString *v7;
  CFStringRef v8;

  MEMORY[0x19402F294](&FigTTMLGetLibXMLAccess_sFigLibXMLLoadOnce, figTTMLInitLibXMLLibrary);
  if (!s_accessLibXML || off_1EE2A1560(a1) != 2)
    return FigSignalErrorAt();
  v4 = (const char *)off_1EE2A1548(a1);
  v5 = (const char *)off_1EE2A1520(a1);
  v6 = (const char *)off_1EE2A1568(a1);
  v7 = figTTMLCreateNamespaceAndName(v4, v5);
  v8 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6, 0x8000100u);
  CFDictionaryAddValue(a2, v7, v8);
  if (v7)
    CFRelease(v7);
  if (v8)
    CFRelease(v8);
  return 0;
}

uint64_t FigTTMLSkipNode(uint64_t a1, uint64_t *a2, __CFArray *a3)
{
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *value;

  value = 0;
  MEMORY[0x19402F294](&FigTTMLGetLibXMLAccess_sFigLibXMLLoadOnce, figTTMLInitLibXMLLibrary);
  if (s_accessLibXML)
  {
    if (off_1EE2A1560(a1) == 1)
    {
      v6 = FigTTMLCopyNamespaceAndLocalNameOfCurrentNode(a1, 0, (CFStringRef *)&value);
      v7 = value;
      if ((_DWORD)v6)
      {
        v8 = v6;
        if (!value)
          return v8;
        goto LABEL_6;
      }
      CFArrayAppendValue(a3, value);
    }
    v8 = FigTTMLParseNode(a1, (uint64_t (*)(uint64_t, uint64_t *, CFTypeRef *))figTTMLSkipNode, a2);
    v7 = value;
    if (!value)
      return v8;
LABEL_6:
    CFRelease(v7);
    return v8;
  }
  return FigSignalErrorAt();
}

uint64_t FigTTMLParseNode(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t *, CFTypeRef *), uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  CFTypeRef v11;
  uint64_t v12;
  CFTypeRef cf;

  v6 = *a3;
  v7 = a3[1];
  cf = 0;
  MEMORY[0x19402F294](&FigTTMLGetLibXMLAccess_sFigLibXMLLoadOnce, figTTMLInitLibXMLLibrary);
  if (!s_accessLibXML)
    goto LABEL_20;
  if (off_1EE2A1560(a1) == 1)
  {
    v8 = s_accessLibXMLFunctionPointerStorage(a1);
    v9 = off_1EE2A1550(a1);
    if (v8)
      goto LABEL_15;
    if (v9 != 1)
      goto LABEL_20;
    ++a3[2];
    while (off_1EE2A1560(a1) != 15)
    {
      if (cf)
      {
        CFRelease(cf);
        cf = 0;
      }
      v10 = a2(a1, a3, &cf);
      if ((_DWORD)v10)
        goto LABEL_21;
      v11 = cf;
      if (cf)
      {
        ++a3[2];
        v7 = (uint64_t)v11;
      }
      *a3 = v6;
      a3[1] = v7;
    }
    --a3[2];
  }
  v9 = off_1EE2A1550(a1);
LABEL_15:
  if (v9 != -1)
  {
    v12 = 0;
    goto LABEL_17;
  }
LABEL_20:
  v10 = FigSignalErrorAt();
LABEL_21:
  v12 = v10;
LABEL_17:
  if (cf)
    CFRelease(cf);
  return v12;
}

uint64_t figTTMLSkipNode(uint64_t a1, uint64_t *a2)
{
  return FigTTMLParseNode(a1, (uint64_t (*)(uint64_t, uint64_t *, CFTypeRef *))figTTMLSkipNode, a2);
}

void FigTTMLAppendDebugDescToCFString(const void *a1, __CFString *a2)
{
  const __CFString *v3;

  v3 = CFCopyDescription(a1);
  CFStringAppend(a2, v3);
  if (v3)
    CFRelease(v3);
}

uint64_t FigTTMLParseAndCreateBlockClassNode(const __CFAllocator *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v8;
  uint64_t v9;
  CFTypeRef cf;
  CFTypeRef v12;
  CFTypeRef v13;

  v12 = 0;
  v13 = 0;
  cf = 0;
  MEMORY[0x19402F294](&FigTTMLGetLibXMLAccess_sFigLibXMLLoadOnce, figTTMLInitLibXMLLibrary);
  if (s_accessLibXML)
  {
    if (off_1EE2A1560(a2) != 1)
      goto LABEL_13;
    v8 = FigTTMLCopyNamespaceAndLocalNameOfCurrentNode(a2, (const char **)&v12, (CFStringRef *)&cf);
    if (!(_DWORD)v8)
    {
      if (FigCFEqual() && FigCFEqual())
      {
        v8 = FigTTMLDivCreate(a1, a2, a3, &v13);
        if ((_DWORD)v8)
          goto LABEL_22;
      }
      else if (FigCFEqual())
      {
        if (FigCFEqual())
        {
          v8 = FigTTMLPCreate(a1, a2, a3, &v13);
          if ((_DWORD)v8)
            goto LABEL_22;
        }
      }
      if (a4)
      {
        v9 = 0;
        *a4 = v13;
        v13 = 0;
        goto LABEL_14;
      }
LABEL_13:
      v9 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    v8 = FigSignalErrorAt();
  }
LABEL_22:
  v9 = v8;
LABEL_14:
  if (cf)
    CFRelease(cf);
  if (v12)
    CFRelease(v12);
  if (v13)
    CFRelease(v13);
  return v9;
}

uint64_t FigTTMLParseAndCreateInlineClassNode(const __CFAllocator *a1, uint64_t a2, __int128 *a3, CFTypeRef *a4)
{
  int v8;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef cf;
  CFTypeRef v14;
  CFTypeRef v15;

  v14 = 0;
  v15 = 0;
  cf = 0;
  MEMORY[0x19402F294](&FigTTMLGetLibXMLAccess_sFigLibXMLLoadOnce, figTTMLInitLibXMLLibrary);
  if (!s_accessLibXML)
  {
    v10 = FigSignalErrorAt();
    goto LABEL_28;
  }
  v8 = off_1EE2A1560(a2);
  if (v8 == 14 || v8 == 3)
  {
    v10 = FigTTMLTextCreate(a1, a2, a3, &v15);
    if (!(_DWORD)v10)
      goto LABEL_18;
    goto LABEL_28;
  }
  if (v8 != 1)
    goto LABEL_18;
  v10 = FigTTMLCopyNamespaceAndLocalNameOfCurrentNode(a2, (const char **)&v14, (CFStringRef *)&cf);
  if ((_DWORD)v10)
  {
LABEL_28:
    v11 = v10;
    goto LABEL_20;
  }
  if (FigCFEqual() && FigCFEqual())
  {
    v10 = FigTTMLSpanCreate(a1, a2, (uint64_t)a3, &v15);
    if ((_DWORD)v10)
      goto LABEL_28;
  }
  else if (FigCFEqual())
  {
    if (FigCFEqual())
    {
      v10 = FigTTMLBrCreate((uint64_t)a1, a2, (uint64_t)a3, &v15);
      if ((_DWORD)v10)
        goto LABEL_28;
    }
  }
LABEL_18:
  v11 = 0;
  if (a4)
  {
    *a4 = v15;
    v15 = 0;
  }
LABEL_20:
  if (cf)
    CFRelease(cf);
  if (v14)
    CFRelease(v14);
  if (v15)
    CFRelease(v15);
  return v11;
}

uint64_t FigTTMLParseAndCreateAnimationClassNode(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFTypeRef v11;
  CFTypeRef cf;
  CFTypeRef v14;
  CFTypeRef v15;

  v14 = 0;
  v15 = 0;
  cf = 0;
  MEMORY[0x19402F294](&FigTTMLGetLibXMLAccess_sFigLibXMLLoadOnce, figTTMLInitLibXMLLibrary);
  if (!s_accessLibXML)
  {
    v8 = FigSignalErrorAt();
    goto LABEL_21;
  }
  if (off_1EE2A1560(a2) != 1)
    goto LABEL_9;
  v8 = FigTTMLCopyNamespaceAndLocalNameOfCurrentNode(a2, (const char **)&v14, (CFStringRef *)&cf);
  if ((_DWORD)v8)
  {
LABEL_21:
    v10 = v8;
    goto LABEL_13;
  }
  if (FigCFEqual() && FigCFEqual())
  {
    v9 = FigTTMLSetCreate(a1, a2, a3, &v15);
    v10 = v9;
    if (a4 && !(_DWORD)v9)
    {
      v11 = v15;
LABEL_11:
      v10 = 0;
      *a4 = v11;
      v15 = 0;
      goto LABEL_13;
    }
    goto LABEL_13;
  }
LABEL_9:
  if (a4)
  {
    v11 = 0;
    goto LABEL_11;
  }
  v10 = 0;
LABEL_13:
  if (cf)
    CFRelease(cf);
  if (v14)
    CFRelease(v14);
  if (v15)
    CFRelease(v15);
  return v10;
}

uint64_t FigTTMLParseTimeExpression(uint64_t a1, CFStringRef theString, CMTime *a3)
{
  CMTimeEpoch v6;
  CFIndex Length;
  CMTimeValue v8;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  int32_t v11;
  int64_t v12;
  unint64_t v13;
  int v14;
  CMTimeValue v15;
  uint64_t result;
  int32_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  int32_t v23;
  unint64_t v24;
  unint64_t value;
  CMTimeValue v26;
  UniChar *v27;
  unint64_t v28;
  UniChar v29;
  int64_t v30;
  CMTimeValue v31;
  UniChar *v32;
  int64_t v33;
  UniChar v34;
  int v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  CMTimeValue v41;
  CMTimeValue v42;
  double v43;
  CMTimeValue v44;
  CMTimeValue v45;
  __int128 v46;
  UniChar buffer[8];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  CFStringRef theStringa;
  UniChar *v56;
  const char *v57;
  uint64_t v58;
  CMTimeValue v59;
  CMTimeValue v60;
  CMTimeValue v61;
  CMTime v62;
  CMTime v63;
  CMTime rhs;
  CMTime lhs;
  uint64_t v66;
  double v67;
  _BYTE v68[12];
  uint64_t v69;
  CMTime time;
  CMTime v71;
  CMTime v72;
  CFRange v73;
  CFRange v74;

  v46 = *MEMORY[0x1E0CA2E18];
  *(_OWORD *)&v62.value = *MEMORY[0x1E0CA2E18];
  v6 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  v62.epoch = v6;
  Length = CFStringGetLength(theString);
  if (a3)
  {
    v8 = Length;
    theStringa = theString;
    v58 = 0;
    v59 = Length;
    CharactersPtr = CFStringGetCharactersPtr(theString);
    CStringPtr = 0;
    v56 = (UniChar *)CharactersPtr;
    if (!CharactersPtr)
      CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
    v53 = 0u;
    v54 = 0u;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    *(_OWORD *)buffer = 0u;
    v48 = 0u;
    v60 = 0;
    v61 = 0;
    v57 = CStringPtr;
    *(_OWORD *)&v72.value = v46;
    v72.epoch = v6;
    v69 = 0;
    memset(v68, 0, sizeof(v68));
    v66 = 0;
    v67 = 0.0;
    if (figTTMLParseCharacter(45, buffer, 0, v8, &v66))
      v11 = 1;
    else
      v11 = -1;
    if (figTTMLParseTwoOrMoreDigits(buffer, v66, v8, &v66, (_DWORD *)&v69 + 1)
      || figTTMLParseCharacter(58, buffer, v66, v8, &v66)
      || figTTMLParseDigits(2u, buffer, v66, v8, &v66, (unsigned int *)&v69)
      || figTTMLParseCharacter(58, buffer, v66, v8, &v66)
      || figTTMLParseDigits(2u, buffer, v66, v8, &v66, (unsigned int *)&v68[8])
      || (v12 = v66, figTTMLParseFraction(buffer, v66, v8, &v66, &v67))
      && (!figTTMLParseCharacter(58, buffer, v12, v8, &v66)
       || !figTTMLParseCharacter(59, buffer, v12, v8, &v66))
      && !figTTMLParseTwoOrMoreDigits(buffer, v66, v8, &v66, &v68[4])
      && !figTTMLParseCharacter(46, buffer, v66, v8, &v66)
      && figTTMLParseOneOrMoreDigits(buffer, v66, v8, &v66, v68))
    {
      v15 = 0;
      goto LABEL_43;
    }
    if (v69 < 0x3C && *(_DWORD *)&v68[8] < 0x3Du && *(_DWORD *)&v68[4] < *(_DWORD *)(a1 + 24))
    {
      v13 = *(unsigned int *)&v68[8] + 60 * v69 + 3600 * HIDWORD(v69);
      if (FigCFEqual())
      {
        if (!*(_QWORD *)v68)
        {
LABEL_23:
          CMTimeMakeWithSeconds(&v72, v67 + (double)v13, 1000);
LABEL_24:
          time = v72;
          CMTimeMultiply(&v71, &time, v11);
          v14 = 0;
          v72 = v71;
          v62 = v71;
          v15 = v66;
LABEL_25:
          if (!v14 && v15 == v8)
            goto LABEL_27;
LABEL_43:
          lhs.value = 0;
          LODWORD(v63.value) = 0;
          rhs.value = 0;
          v72 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
          memset(&v71, 0, sizeof(v71));
          v23 = *(_DWORD *)(a1 + 24);
          time = *(CMTime *)(a1 + 28);
          CMTimeMultiply(&v71, &time, v23);
          if (figTTMLParseOneOrMoreDigits(buffer, 0, v8, &lhs, &v63))
            return FigSignalErrorAt();
          figTTMLParseFraction(buffer, lhs.value, v8, &lhs, (double *)&rhs.value);
          value = lhs.value;
          if (lhs.value < 0)
            return FigSignalErrorAt();
          if (lhs.value >= v8)
            return FigSignalErrorAt();
          v26 = v59;
          if (v59 <= lhs.value)
            return FigSignalErrorAt();
          v27 = v56;
          if (v56)
          {
            v28 = v58 + lhs.value;
          }
          else
          {
            if (v57)
            {
              v29 = v57[v58 + lhs.value];
LABEL_52:
              v30 = value + 1;
              if (v29 <= 0x6Cu)
              {
                if (v29 == 102)
                {
                  v35 = 0;
                  lhs.value = value + 1;
                  LODWORD(v24) = v63.value;
                  v40 = *(double *)&rhs.value + (double)v24;
                  v36 = 0.0;
                  v37 = 0.0;
                  v39 = 0.0;
LABEL_83:
                  v38 = 0.0;
                  goto LABEL_84;
                }
                if (v29 != 104)
                  return FigSignalErrorAt();
                v35 = 0;
                lhs.value = value + 1;
                LODWORD(v24) = v63.value;
                v36 = *(double *)&rhs.value + (double)v24;
                v37 = 0.0;
                goto LABEL_81;
              }
              if (v29 == 116)
              {
                lhs.value = value + 1;
                LODWORD(v24) = v63.value;
                v38 = *(double *)&rhs.value + (double)v24;
                v36 = 0.0;
                v35 = 1;
                v37 = 0.0;
                v39 = 0.0;
                v40 = 0.0;
LABEL_84:
                if (FigCFEqual())
                {
                  if (!v35)
                  {
                    v43 = v37 + v36 * 3600.0 + v39;
LABEL_92:
                    CMTimeMakeWithSeconds(&v72, v43, 1000000);
                    v62 = v72;
                    v15 = lhs.value;
                    goto LABEL_93;
                  }
LABEL_90:
                  time = *(CMTime *)(a1 + 148);
                  v43 = v38 / CMTimeGetSeconds(&time);
                  goto LABEL_92;
                }
                if (FigCFEqual() || FigCFEqual())
                {
                  if (!v35)
                  {
                    time = v71;
                    v43 = v37 + v36 * 3600.0 + v39 + v40 / CMTimeGetSeconds(&time);
                    goto LABEL_92;
                  }
                  goto LABEL_90;
                }
                if (!FigSignalErrorAt())
                {
LABEL_93:
                  if (v15 == v8)
                  {
LABEL_27:
                    result = 0;
                    *a3 = v62;
                    return result;
                  }
                }
                return FigSignalErrorAt();
              }
              if (v29 == 115)
              {
                v35 = 0;
                lhs.value = value + 1;
                LODWORD(v24) = v63.value;
                v39 = *(double *)&rhs.value + (double)v24;
LABEL_66:
                v36 = 0.0;
                v37 = 0.0;
LABEL_82:
                v40 = 0.0;
                goto LABEL_83;
              }
              if (v29 != 109)
                return FigSignalErrorAt();
              if (v30 >= v8 || (v31 = v59, v59 <= v30))
              {
LABEL_80:
                v35 = 0;
                lhs.value = value + 1;
                LODWORD(v24) = v63.value;
                v37 = (*(double *)&rhs.value + (double)v24) * 60.0;
                v36 = 0.0;
LABEL_81:
                v39 = 0.0;
                goto LABEL_82;
              }
              v32 = v56;
              if (v56)
              {
                v33 = v58 + v30;
              }
              else
              {
                if (v57)
                {
                  v34 = v57[v58 + v30];
LABEL_78:
                  if (v34 == 115)
                  {
                    v35 = 0;
                    lhs.value = value + 2;
                    LODWORD(v24) = v63.value;
                    v39 = (*(double *)&rhs.value + (double)v24) / 1000.0;
                    goto LABEL_66;
                  }
                  goto LABEL_80;
                }
                if (v61 <= v30 || (v44 = v60, v60 > v30))
                {
                  v45 = value - 3;
                  if (value < 3)
                    v45 = 0;
                  if (v45 + 64 < v59)
                    v31 = v45 + 64;
                  v60 = v45;
                  v61 = v31;
                  v74.location = v58 + v45;
                  v74.length = v31 - v45;
                  CFStringGetCharacters(theStringa, v74, buffer);
                  v44 = v60;
                }
                v33 = v30 - v44;
                v32 = buffer;
              }
              v34 = v32[v33];
              goto LABEL_78;
            }
            if (v61 <= lhs.value || (v41 = v60, v60 > lhs.value))
            {
              v42 = lhs.value - 4;
              if (lhs.value < 4uLL)
                v42 = 0;
              if (v42 + 64 < v59)
                v26 = v42 + 64;
              v60 = v42;
              v61 = v26;
              v73.location = v58 + v42;
              v73.length = v26 - v42;
              CFStringGetCharacters(theStringa, v73, buffer);
              v41 = v60;
            }
            v28 = value - v41;
            v27 = buffer;
          }
          v29 = v27[v28];
          goto LABEL_52;
        }
LABEL_30:
        v15 = 0;
        v14 = 0;
        goto LABEL_25;
      }
      if (FigCFEqual())
      {
        if (*(_DWORD *)(a1 + 144))
          goto LABEL_23;
        goto LABEL_30;
      }
      if (FigCFEqual())
      {
        memset(&v71, 0, sizeof(v71));
        v17 = *(_DWORD *)(a1 + 24);
        time = *(CMTime *)(a1 + 28);
        CMTimeMultiply(&v71, &time, v17);
        memset(&time, 0, sizeof(time));
        CMTimeMake(&time, *(unsigned int *)v68, *(_DWORD *)(a1 + 144));
        v18 = *(unsigned int *)(a1 + 24);
        if (!v13 || 0xFFFFFFFFFFFFFFFFLL / v13 > (v18 + 1))
        {
          v19 = *(unsigned int *)&v68[4];
          if (FigCFEqual())
          {
            LODWORD(v20) = v69;
            v21 = -2
                * ((unint64_t)((double)v20 - floor((double)v20 / 10.0)) + (54 * HIDWORD(v69)));
          }
          else if (FigCFEqual())
          {
            LODWORD(v22) = v69;
            v21 = -4 * (vcvtmd_u64_f64((double)v22 * 0.5 + (double)v22 / -20.0) + (27 * HIDWORD(v69)));
          }
          else
          {
            v21 = 0;
          }
          if (v71.value < 0x80000000)
          {
            CMTimeMake(&lhs, v19 + v13 * v18 + v21, 1);
            rhs = time;
            CMTimeAdd(&v72, &lhs, &rhs);
            v63 = v72;
            CMTimeMultiplyByRatio(&rhs, &v63, v71.timescale, v71.value);
            v72 = rhs;
            goto LABEL_24;
          }
        }
      }
    }
    v14 = FigSignalErrorAt();
    v15 = 0;
    goto LABEL_25;
  }
  return FigSignalErrorAt();
}

uint64_t FigTTMLParseFrameRate(const __CFString *a1, _DWORD *a2)
{
  CFIndex Length;
  uint64_t v5;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t result;
  int v9;
  uint64_t v10;
  UniChar buffer[8];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  const __CFString *v19;
  const UniChar *v20;
  const char *v21;
  uint64_t v22;
  CFIndex v23;
  uint64_t v24;
  uint64_t v25;

  Length = CFStringGetLength(a1);
  v10 = 0;
  v9 = 0;
  if (!a2)
    return FigSignalErrorAt();
  v5 = Length;
  v19 = a1;
  v22 = 0;
  v23 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v20 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  *(_OWORD *)buffer = 0u;
  v12 = 0u;
  v21 = CStringPtr;
  v24 = 0;
  v25 = 0;
  result = figTTMLParseOneOrMoreDigits(buffer, 0, v5, &v10, &v9);
  if (!(_DWORD)result)
  {
    if (v9)
    {
      result = 0;
      *a2 = v9;
    }
    else
    {
      return FigSignalErrorAt();
    }
  }
  return result;
}

uint64_t figTTMLParseOneOrMoreDigits(UniChar *buffer, uint64_t a2, uint64_t a3, _QWORD *a4, _DWORD *a5)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;

  v10 = 0;
  v11 = a2;
  if (!a4 || !a5)
    return FigSignalErrorAt();
  result = figTTMLParseDigits(1u, buffer, a2, a3, &v11, (unsigned int *)&v10 + 1);
  if (!(_DWORD)result)
  {
    if (figTTMLParseDigits(1u, buffer, v11, a3, &v11, (unsigned int *)&v10))
    {
LABEL_7:
      result = 0;
      *a4 = v11;
      *a5 = HIDWORD(v10);
    }
    else
    {
      while (HIDWORD(v10) <= 0x1745D173)
      {
        HIDWORD(v10) = v10 + 10 * HIDWORD(v10);
        if (figTTMLParseDigits(1u, buffer, v11, a3, &v11, (unsigned int *)&v10))
          goto LABEL_7;
      }
      return 4294950725;
    }
  }
  return result;
}

uint64_t FigTTMLParseFrameRateMultiplier(const __CFString *a1, CMTime *a2)
{
  CFIndex Length;
  uint64_t v5;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t result;
  CMTime v9;
  int32_t timescale[2];
  uint64_t v11;
  UniChar buffer[8];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  const __CFString *v20;
  const UniChar *v21;
  const char *v22;
  uint64_t v23;
  CFIndex v24;
  uint64_t v25;
  uint64_t v26;

  Length = CFStringGetLength(a1);
  v11 = 0;
  if (!a2)
    return FigSignalErrorAt();
  v5 = Length;
  v20 = a1;
  v23 = 0;
  v24 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v21 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  *(_OWORD *)buffer = 0u;
  v13 = 0u;
  *(_QWORD *)timescale = 0;
  v25 = 0;
  v26 = 0;
  v22 = CStringPtr;
  result = figTTMLParseOneOrMoreDigits(buffer, 0, v5, &v11, &timescale[1]);
  if (!(_DWORD)result)
  {
    result = figTTMLParseOneOrMoreWhitespaces(buffer, v11, &v11);
    if (!(_DWORD)result)
    {
      result = figTTMLParseOneOrMoreDigits(buffer, v11, v5, &v11, timescale);
      if (!(_DWORD)result)
      {
        if (timescale[1] && timescale[0])
        {
          CMTimeMake(&v9, timescale[1], timescale[0]);
          result = 0;
          *a2 = v9;
        }
        else
        {
          return FigSignalErrorAt();
        }
      }
    }
  }
  return result;
}

uint64_t figTTMLParseOneOrMoreWhitespaces(UniChar *buffer, int64_t a2, uint64_t *a3)
{
  int64_t v6;
  uint64_t v7;
  UniChar v8;
  uint64_t i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  int64_t v19;
  int64_t v20;
  CFRange v21;
  CFRange v22;

  if (!a3)
    return FigSignalErrorAt();
  if (a2 < 0 || (v6 = *((_QWORD *)buffer + 20), v6 <= a2))
  {
    v8 = 0;
  }
  else
  {
    v7 = *((_QWORD *)buffer + 17);
    if (v7)
    {
      v8 = *(_WORD *)(v7 + 2 * (*((_QWORD *)buffer + 19) + a2));
    }
    else
    {
      v18 = *((_QWORD *)buffer + 18);
      if (v18)
      {
        v8 = *(char *)(v18 + *((_QWORD *)buffer + 19) + a2);
      }
      else
      {
        if (*((_QWORD *)buffer + 22) <= a2 || (v19 = *((_QWORD *)buffer + 21), v19 > a2))
        {
          v20 = a2 - 4;
          if ((unint64_t)a2 < 4)
            v20 = 0;
          if (v20 + 64 < v6)
            v6 = v20 + 64;
          *((_QWORD *)buffer + 21) = v20;
          *((_QWORD *)buffer + 22) = v6;
          v22.location = *((_QWORD *)buffer + 19) + v20;
          v22.length = v6 - v20;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v22, buffer);
          v19 = *((_QWORD *)buffer + 21);
        }
        v8 = buffer[a2 - v19];
      }
    }
  }
  for (i = 0; ; ++i)
  {
    v10 = a2 + i;
    if (v8 > 0x20u || ((1 << v8) & 0x100002600) == 0)
      break;
    if (v10 <= -2 || (v11 = a2 + i + 1, v12 = *((_QWORD *)buffer + 20), v12 <= v11))
    {
      v8 = 0;
    }
    else
    {
      v13 = *((_QWORD *)buffer + 17);
      if (v13)
      {
        v8 = *(_WORD *)(v13 + 2 * (a2 + i + *((_QWORD *)buffer + 19)) + 2);
      }
      else
      {
        v14 = *((_QWORD *)buffer + 18);
        if (v14)
        {
          v8 = *(char *)(v14 + *((_QWORD *)buffer + 19) + a2 + i + 1);
        }
        else
        {
          if (*((_QWORD *)buffer + 22) <= v11 || (v15 = *((_QWORD *)buffer + 21), v15 > v11))
          {
            if ((unint64_t)v11 >= 4)
              v16 = a2 + i - 3;
            else
              v16 = 0;
            if (v16 + 64 < v12)
              v12 = v16 + 64;
            *((_QWORD *)buffer + 21) = v16;
            *((_QWORD *)buffer + 22) = v12;
            v21.location = *((_QWORD *)buffer + 19) + v16;
            v21.length = v12 - v16;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v21, buffer);
            v15 = *((_QWORD *)buffer + 21);
          }
          v8 = buffer[a2 + 1 - v15 + i];
        }
      }
    }
  }
  if (!i)
    return FigSignalErrorAt();
  *a3 = v10;
  return 0;
}

uint64_t FigTTMLParsePixelAspectRatio(const __CFString *a1, uint64_t *a2)
{
  CFIndex Length;
  uint64_t v5;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  UniChar buffer[8];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  const __CFString *v20;
  const UniChar *v21;
  const char *v22;
  uint64_t v23;
  CFIndex v24;
  uint64_t v25;
  uint64_t v26;

  Length = CFStringGetLength(a1);
  v11 = 0;
  if (!a2)
    return FigSignalErrorAt();
  v5 = Length;
  v20 = a1;
  v23 = 0;
  v24 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v21 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  *(_OWORD *)buffer = 0u;
  v13 = 0u;
  v10 = 0;
  v25 = 0;
  v26 = 0;
  v22 = CStringPtr;
  result = figTTMLParseOneOrMoreDigits(buffer, 0, v5, &v11, (_DWORD *)&v10 + 1);
  if (!(_DWORD)result)
  {
    result = figTTMLParseOneOrMoreWhitespaces(buffer, v11, &v11);
    if (!(_DWORD)result)
    {
      result = figTTMLParseOneOrMoreDigits(buffer, v11, v5, &v11, &v10);
      if (!(_DWORD)result)
      {
        if (HIDWORD(v10) && (_DWORD)v10)
        {
          v9 = FigGeometryAspectRatioMake();
          result = 0;
          *a2 = v9;
        }
        else
        {
          return FigSignalErrorAt();
        }
      }
    }
  }
  return result;
}

uint64_t FigTTMLParseActiveArea(const __CFString *a1, _OWORD *a2)
{
  CFIndex Length;
  uint64_t v5;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  unint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  double v16;
  int v17;
  uint64_t v18;
  UniChar buffer[8];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  const __CFString *v27;
  const UniChar *v28;
  const char *v29;
  uint64_t v30;
  CFIndex v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD v34[5];

  v34[4] = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  v18 = 0;
  v17 = 0;
  v16 = 0.0;
  if (!a2)
    return FigSignalErrorAt();
  v5 = Length;
  v27 = a1;
  v30 = 0;
  v31 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v28 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v8 = 0;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v22 = 0u;
  v20 = 0u;
  v21 = 0u;
  *(_OWORD *)buffer = 0u;
  v32 = 0;
  v33 = 0;
  v29 = CStringPtr;
  while (1)
  {
    v9 = v18;
    if (v8 * 8)
    {
      result = figTTMLParseOneOrMoreWhitespaces(buffer, v18, &v18);
      if ((_DWORD)result)
        return result;
      v9 = v18;
    }
    figTTMLParseOneOrMoreDigits(buffer, v9, v5, &v18, &v17);
    figTTMLParseFraction(buffer, v18, v5, &v18, &v16);
    result = figTTMLParseString("%", buffer, v18, v5, &v18);
    if ((_DWORD)result)
      break;
    LODWORD(v11) = v17;
    *(double *)&v34[v8++] = v16 + (double)v11;
    if (v8 == 4)
    {
      FigGeometryDimensionMake();
      FigGeometryDimensionMake();
      FigGeometryDimensionMake();
      FigGeometryDimensionMake();
      FigGeometryRectMake();
      result = 0;
      *a2 = v12;
      a2[1] = v13;
      a2[2] = v14;
      a2[3] = v15;
      return result;
    }
  }
  return result;
}

uint64_t figTTMLParseFraction(UniChar *buffer, int64_t a2, int64_t a3, _QWORD *a4, double *a5)
{
  uint64_t result;
  unint64_t v10;
  double v11;
  double v12;
  unsigned int v13;
  uint64_t v14;

  v14 = a2;
  v13 = 0;
  if (!a4 || !a5)
    return FigSignalErrorAt();
  result = figTTMLParseCharacter(46, buffer, a2, a3, &v14);
  if (!(_DWORD)result)
  {
    v11 = 0.0;
    if (!figTTMLParseDigits(1u, buffer, v14, a3, &v14, &v13))
    {
      v12 = 10.0;
      do
      {
        LODWORD(v10) = v13;
        v11 = v11 + (double)v10 / v12;
        v12 = v12 * 10.0;
      }
      while (!figTTMLParseDigits(1u, buffer, v14, a3, &v14, &v13));
    }
    result = 0;
    *a4 = v14;
    *a5 = v11;
  }
  return result;
}

uint64_t figTTMLParseString(char *a1, UniChar *buffer, int64_t a3, int64_t a4, int64_t *a5)
{
  int64_t v6;
  char v8;
  uint64_t v10;
  int64_t v11;
  int64_t v12;
  int64_t v13;
  uint64_t v14;
  UniChar v15;
  uint64_t v16;
  int64_t v17;
  int64_t v18;
  uint64_t result;
  CFRange v20;

  if (!a5)
    return FigSignalErrorAt();
  v6 = a3;
  v8 = *a1;
  if (*a1)
  {
    v10 = 0;
    if (a4 <= a3)
      v11 = a3;
    else
      v11 = a4;
    v12 = v11 - a3;
    while (v10 != v12)
    {
      if (v6 < 0 || (v13 = *((_QWORD *)buffer + 20), v13 <= v6))
      {
        v15 = 0;
      }
      else
      {
        v14 = *((_QWORD *)buffer + 17);
        if (v14)
        {
          v15 = *(_WORD *)(v14 + 2 * (*((_QWORD *)buffer + 19) + v6));
        }
        else
        {
          v16 = *((_QWORD *)buffer + 18);
          if (v16)
          {
            v15 = *(char *)(v16 + *((_QWORD *)buffer + 19) + v6);
          }
          else
          {
            if (*((_QWORD *)buffer + 22) <= v6 || (v17 = *((_QWORD *)buffer + 21), v17 > v6))
            {
              v18 = v6 - 4;
              if ((unint64_t)v6 < 4)
                v18 = 0;
              if (v18 + 64 < v13)
                v13 = v18 + 64;
              *((_QWORD *)buffer + 21) = v18;
              *((_QWORD *)buffer + 22) = v13;
              v20.location = *((_QWORD *)buffer + 19) + v18;
              v20.length = v13 - v18;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v20, buffer);
              v17 = *((_QWORD *)buffer + 21);
            }
            v15 = buffer[v6 - v17];
          }
        }
      }
      if (v8 != v15)
        break;
      ++v6;
      v8 = a1[++v10];
      if (!v8)
        goto LABEL_26;
    }
    return 4294950724;
  }
  else
  {
LABEL_26:
    result = 0;
    *a5 = v6;
  }
  return result;
}

uint64_t FigTTMLParseTickRate(const __CFString *a1, CMTime *a2)
{
  CFIndex Length;
  uint64_t v5;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t result;
  CMTime v9;
  _DWORD value[3];
  UniChar buffer[8];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  const __CFString *v19;
  const UniChar *v20;
  const char *v21;
  uint64_t v22;
  CFIndex v23;
  uint64_t v24;
  uint64_t v25;

  Length = CFStringGetLength(a1);
  *(_QWORD *)&value[1] = 0;
  if (!a2)
    return FigSignalErrorAt();
  v5 = Length;
  v19 = a1;
  v22 = 0;
  v23 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v20 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  *(_OWORD *)buffer = 0u;
  v12 = 0u;
  value[0] = 0;
  v21 = CStringPtr;
  v24 = 0;
  v25 = 0;
  result = figTTMLParseOneOrMoreDigits(buffer, 0, v5, &value[1], value);
  if (!(_DWORD)result)
  {
    if (value[0])
    {
      CMTimeMake(&v9, value[0], 1);
      result = 0;
      *a2 = v9;
    }
    else
    {
      return FigSignalErrorAt();
    }
  }
  return result;
}

uint64_t FigTTMLParseColor(const __CFString *a1, float *a2, float *a3, float *a4, float *a5)
{
  CFIndex Length;
  int64_t v11;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  int v14;
  uint64_t result;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  float v19;
  float v20;
  float v21;
  float v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  UniChar buffer[8];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  const __CFString *v35;
  const UniChar *v36;
  const char *v37;
  uint64_t v38;
  CFIndex v39;
  uint64_t v40;
  uint64_t v41;

  Length = CFStringGetLength(a1);
  v25 = 0;
  v26 = 0;
  v24 = 0;
  if (!a2 || !a3 || !a4 || !a5)
    return FigSignalErrorAt();
  v11 = Length;
  v35 = a1;
  v38 = 0;
  v39 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v36 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v34 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  *(_OWORD *)buffer = 0u;
  v37 = CStringPtr;
  v40 = 0;
  v41 = 0;
  if (figTTMLParseCharacter(35, buffer, 0, v11, &v26))
  {
    if (figTTMLParseString("rgb", buffer, v26, v11, &v26))
    {
      MEMORY[0x19402F294](&initNamedColorToRGBAMapOnce, figTTMLInitNamedColorToRGBAMap);
      if (!FigCFDictionaryGetInt32IfPresent())
        return FigSignalErrorAt();
      v25 = 0;
      HIDWORD(v24) = 0;
      v14 = 0;
      goto LABEL_16;
    }
    v23 = figTTMLParseString("a(", buffer, v26, v11, &v26);
    if (v23 && figTTMLParseCharacter(40, buffer, v26, v11, &v26))
      return FigSignalErrorAt();
    result = figTTMLParseOneOrMoreDigits(buffer, v26, v11, &v26, (_DWORD *)&v25 + 1);
    if (!(_DWORD)result)
    {
      result = figTTMLParseCharacter(44, buffer, v26, v11, &v26);
      if (!(_DWORD)result)
      {
        result = figTTMLParseOneOrMoreDigits(buffer, v26, v11, &v26, &v25);
        if (!(_DWORD)result)
        {
          result = figTTMLParseCharacter(44, buffer, v26, v11, &v26);
          if (!(_DWORD)result)
          {
            result = figTTMLParseOneOrMoreDigits(buffer, v26, v11, &v26, (_DWORD *)&v24 + 1);
            if (!(_DWORD)result)
            {
              if (v23)
              {
                LODWORD(v24) = 255;
              }
              else
              {
                result = figTTMLParseCharacter(44, buffer, v26, v11, &v26);
                if ((_DWORD)result)
                  return result;
                result = figTTMLParseOneOrMoreDigits(buffer, v26, v11, &v26, &v24);
                if ((_DWORD)result)
                  return result;
              }
              result = figTTMLParseCharacter(41, buffer, v26, v11, &v26);
              if (!(_DWORD)result)
                goto LABEL_17;
            }
          }
        }
      }
    }
  }
  else
  {
    result = figTTMLParseHexDigits(buffer, v26, v11, &v26, (unsigned int *)&v25 + 1);
    if (!(_DWORD)result)
    {
      result = figTTMLParseHexDigits(buffer, v26, v11, &v26, (unsigned int *)&v25);
      if (!(_DWORD)result)
      {
        result = figTTMLParseHexDigits(buffer, v26, v11, &v26, (unsigned int *)&v24 + 1);
        if (!(_DWORD)result)
        {
          if (!figTTMLParseHexDigits(buffer, v26, v11, &v26, (unsigned int *)&v24))
          {
LABEL_17:
            if (HIDWORD(v25) < 0x100)
            {
              v16 = v25;
              if (v25 < 0x100)
              {
                v17 = HIDWORD(v24);
                if (HIDWORD(v24) < 0x100)
                {
                  v18 = v24;
                  if (v24 < 0x100)
                  {
                    result = 0;
                    v19 = (double)HIDWORD(v25) / 255.0;
                    *a2 = v19;
                    v20 = (double)v16 / 255.0;
                    *a3 = v20;
                    v21 = (double)v17 / 255.0;
                    *a4 = v21;
                    v22 = (double)v18 / 255.0;
                    *a5 = v22;
                    return result;
                  }
                }
              }
            }
            return FigSignalErrorAt();
          }
          v14 = 255;
LABEL_16:
          LODWORD(v24) = v14;
          goto LABEL_17;
        }
      }
    }
  }
  return result;
}

uint64_t figTTMLParseCharacter(int a1, UniChar *buffer, int64_t a3, int64_t a4, _QWORD *a5)
{
  int64_t v9;
  uint64_t v10;
  UniChar v11;
  uint64_t result;
  uint64_t v13;
  int64_t v14;
  int64_t v15;
  const __CFString *v16;
  CFRange v17;

  if (a4 <= a3)
    return 4294950724;
  if (a3 < 0 || (v9 = *((_QWORD *)buffer + 20), v9 <= a3))
  {
    v11 = 0;
  }
  else
  {
    v10 = *((_QWORD *)buffer + 17);
    if (v10)
    {
      v11 = *(_WORD *)(v10 + 2 * (*((_QWORD *)buffer + 19) + a3));
    }
    else
    {
      v13 = *((_QWORD *)buffer + 18);
      if (v13)
      {
        v11 = *(char *)(v13 + *((_QWORD *)buffer + 19) + a3);
      }
      else
      {
        if (*((_QWORD *)buffer + 22) <= a3 || (v14 = *((_QWORD *)buffer + 21), v14 > a3))
        {
          v15 = a3 - 4;
          if ((unint64_t)a3 < 4)
            v15 = 0;
          if (v15 + 64 < v9)
            v9 = v15 + 64;
          *((_QWORD *)buffer + 21) = v15;
          *((_QWORD *)buffer + 22) = v9;
          v16 = (const __CFString *)*((_QWORD *)buffer + 16);
          v17.location = *((_QWORD *)buffer + 19) + v15;
          v17.length = v9 - v15;
          CFStringGetCharacters(v16, v17, buffer);
          v14 = *((_QWORD *)buffer + 21);
        }
        v11 = buffer[a3 - v14];
      }
    }
  }
  if (a1 != v11)
    return 4294950724;
  result = 0;
  if (a5)
    *a5 = a3 + 1;
  return result;
}

uint64_t figTTMLParseHexDigits(UniChar *buffer, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int *a5)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  UniChar v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t result;
  CFRange v29;

  if (!a4 || !a5)
    return FigSignalErrorAt();
  if (a3 - a2 >= 2)
  {
    v8 = 0;
    v9 = -a2;
    v10 = a2 + 64;
    v11 = 1;
    v12 = a2;
    while (1)
    {
      v13 = v11;
      v14 = (unint64_t)v12 >= 4 ? 4 : v12;
      if (a2 < 0)
        break;
      v15 = *((_QWORD *)buffer + 20);
      if (v15 <= v12)
        break;
      v16 = *((_QWORD *)buffer + 17);
      if (v16)
      {
        v17 = *(_WORD *)(v16 + 2 * (v12 + *((_QWORD *)buffer + 19)));
      }
      else
      {
        v18 = *((_QWORD *)buffer + 18);
        if (v18)
        {
          v17 = *(char *)(v18 + *((_QWORD *)buffer + 19) + v12);
        }
        else
        {
          if (*((_QWORD *)buffer + 22) <= v12 || (v19 = *((_QWORD *)buffer + 21), v19 > v12))
          {
            v20 = -v14;
            v21 = v14 + v9;
            v22 = v10 - v14;
            v23 = v12 + v20;
            v24 = v23 + 64;
            if (v23 + 64 >= v15)
              v24 = *((_QWORD *)buffer + 20);
            *((_QWORD *)buffer + 21) = v23;
            *((_QWORD *)buffer + 22) = v24;
            if (v15 >= v22)
              v15 = v22;
            v29.length = v15 + v21;
            v29.location = v23 + *((_QWORD *)buffer + 19);
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v29, buffer);
            v19 = *((_QWORD *)buffer + 21);
          }
          v17 = buffer[v12 - v19];
        }
      }
      v25 = v17;
      if ((unsigned __int16)(v17 - 48) >= 0xAu)
      {
        if (v17 - 65 >= 6)
        {
          if (v17 - 97 > 5)
            return 4294950724;
          v26 = -87;
        }
        else
        {
          v26 = -55;
        }
      }
      else
      {
        v26 = -48;
      }
      if (v8 > 0xF0F0F0E)
        return 4294950725;
      v11 = 0;
      v8 = v26 + v25 + 16 * v8;
      ++v12;
      --v9;
      ++v10;
      if ((v13 & 1) == 0)
      {
        result = 0;
        *a4 = v12;
        *a5 = v8;
        return result;
      }
    }
  }
  return 4294950724;
}

CFStringRef FigTTMLCopyRGBAColorAsColorSyntax(float32x4_t a1, float32_t a2, float a3, float a4)
{
  uint64_t v4;
  const void *v5;
  unsigned int v6;
  const void *Value;
  const void *v8;
  int32x4_t v10;
  uint64_t v11;

  v4 = 0;
  LODWORD(v5) = 0;
  a1.f32[1] = a2;
  a1.i64[1] = __PAIR64__(LODWORD(a4), LODWORD(a3));
  v11 = *MEMORY[0x1E0C80C00];
  v10 = vcvtq_s32_f32(vmulq_f32(a1, (float32x4_t)vdupq_n_s32(0x437F0000u)));
  do
  {
    v6 = v10.i32[v4] & ~(v10.i32[v4] >> 31);
    if (v6 >= 0xFF)
      v6 = 255;
    v5 = (const void *)(v6 | ((_DWORD)v5 << 8));
    v10.i32[v4++] = v6;
  }
  while (v4 != 4);
  MEMORY[0x19402F294](&initRGBAToNamedColorMap, figTTMLInitRGBAToNamedColorMap);
  Value = CFDictionaryGetValue((CFDictionaryRef)sRGBAToNamedColorMap, v5);
  if (!Value)
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("rgba(%d,%d,%d,%d)"), v10.u32[0], v10.u32[1], v10.u32[2], v10.u32[3]);
  v8 = Value;
  CFRetain(Value);
  return (CFStringRef)v8;
}

uint64_t FigTTMLParseNumber(const __CFString *a1, float *a2)
{
  CFIndex Length;
  int64_t v5;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  int v8;
  uint64_t result;
  unint64_t v10;
  double v11;
  float v12;
  double v13;
  int v14;
  uint64_t v15;
  UniChar buffer[8];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  const __CFString *v24;
  const UniChar *v25;
  const char *v26;
  uint64_t v27;
  CFIndex v28;
  uint64_t v29;
  uint64_t v30;

  Length = CFStringGetLength(a1);
  v15 = 0;
  v14 = 0;
  v13 = 0.0;
  if (!a1 || !a2)
    return FigSignalErrorAt();
  v5 = Length;
  v24 = a1;
  v27 = 0;
  v28 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v25 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  *(_OWORD *)buffer = 0u;
  v17 = 0u;
  v29 = 0;
  v30 = 0;
  v26 = CStringPtr;
  v8 = figTTMLParseCharacter(45, buffer, 0, v5, &v15);
  result = figTTMLParseOneOrMoreDigits(buffer, v15, v5, &v15, &v14);
  if (!(_DWORD)result)
  {
    figTTMLParseFraction(buffer, v15, v5, &v15, &v13);
    if (v15 == v5)
    {
      result = 0;
      LODWORD(v10) = v14;
      v11 = v13 + (double)v10;
      if (!v8)
        v11 = -v11;
      v12 = v11;
      *a2 = v12;
    }
    else
    {
      return FigSignalErrorAt();
    }
  }
  return result;
}

uint64_t FigTTMLParseLength(const __CFString *a1, float *a2, int *a3)
{
  CFIndex Length;
  int64_t v7;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  unint64_t v10;
  float v11;
  uint64_t result;
  int v13;
  float v14;
  double v15;
  int v16;
  int64_t v17;
  UniChar buffer[8];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  const __CFString *v26;
  const UniChar *v27;
  const char *v28;
  uint64_t v29;
  CFIndex v30;
  uint64_t v31;
  uint64_t v32;

  Length = CFStringGetLength(a1);
  v17 = 0;
  v16 = 0;
  v15 = 0.0;
  if (!a1 || !a2 || !a3)
    return FigSignalErrorAt();
  v7 = Length;
  v26 = a1;
  v29 = 0;
  v30 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v27 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  *(_OWORD *)buffer = 0u;
  v19 = 0u;
  v31 = 0;
  v32 = 0;
  v28 = CStringPtr;
  if (figTTMLParseString("normal", buffer, 0, v7, &v17))
  {
    if (figTTMLParseCharacter(45, buffer, v17, v7, &v17))
      v11 = 1.0;
    else
      v11 = -1.0;
    figTTMLParseOneOrMoreDigits(buffer, v17, v7, &v17, &v16);
    figTTMLParseFraction(buffer, v17, v7, &v17, &v15);
    if (figTTMLParseString("%", buffer, v17, v7, &v17))
    {
      if (figTTMLParseString("px", buffer, v17, v7, &v17))
      {
        if (figTTMLParseString("em", buffer, v17, v7, &v17))
        {
          if (figTTMLParseString("c", buffer, v17, v7, &v17))
          {
            if (figTTMLParseString("rh", buffer, v17, v7, &v17))
            {
              if (figTTMLParseString("rw", buffer, v17, v7, &v17))
                return FigSignalErrorAt();
              v13 = 4;
            }
            else
            {
              v13 = 5;
            }
          }
          else
          {
            v13 = 3;
          }
        }
        else
        {
          v13 = 2;
        }
      }
      else
      {
        v13 = 1;
      }
    }
    else
    {
      v13 = 0;
    }
  }
  else
  {
    v13 = 0;
    v16 = 125;
    v11 = 1.0;
  }
  result = 0;
  LODWORD(v10) = v16;
  v14 = (v15 + (double)v10) * v11;
  *a2 = v14;
  *a3 = v13;
  return result;
}

uint64_t FigTTMLParseFontFamilyAndCreateFontFamilyNameList(const __CFString *a1, _QWORD *a2)
{
  CFIndex Length;
  int64_t v5;
  const __CFAllocator *v6;
  uint64_t Mutable;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  const void *v10;
  CFMutableStringRef v11;
  int64_t v12;
  const void **v13;
  uint64_t v14;
  int64_t v15;
  __CFString *v16;
  int64_t v17;
  const void **v18;
  char *v19;
  UniChar *v20;
  uint64_t v21;
  UniChar v22;
  uint64_t v23;
  char *v24;
  __CFString *v25;
  char *v26;
  UniChar *v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  __CFString *v33;
  __CFString *v34;
  CFMutableStringRef cf;
  _QWORD *v36;
  __CFString *v37;
  UniChar buffer[8];
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 theString;
  __int128 v47;
  __int128 v48;
  uint64_t v49;
  CFTypeRef v50;
  __CFString *v51;
  UniChar v52;
  UniChar chars;
  __CFString *v54;
  UniChar v55;
  UniChar v56[4];
  CFRange v57;
  CFRange v58;

  v50 = 0;
  v49 = 0;
  v47 = 0u;
  v48 = 0u;
  theString = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  *(_OWORD *)buffer = 0u;
  v39 = 0u;
  Length = CFStringGetLength(a1);
  v37 = 0;
  if (!a1 || !a2)
  {
    Mutable = FigSignalErrorAt();
    goto LABEL_127;
  }
  v5 = Length;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = FigCaptionFontFamilyNameListCreateMutable();
  if ((_DWORD)Mutable)
  {
LABEL_127:
    v31 = Mutable;
    goto LABEL_121;
  }
  v36 = a2;
  *(_QWORD *)&theString = a1;
  *((_QWORD *)&v47 + 1) = 0;
  *(_QWORD *)&v48 = v5;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  *((_QWORD *)&theString + 1) = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v10 = 0;
  v11 = 0;
  *((_QWORD *)&v48 + 1) = 0;
  v49 = 0;
  *(_QWORD *)&v47 = CStringPtr;
  v12 = (int64_t)v37;
  if ((uint64_t)v37 >= v5)
  {
LABEL_117:
    v31 = 0;
    *v36 = v50;
    v50 = 0;
    if (v11)
      goto LABEL_118;
    goto LABEL_119;
  }
  v11 = 0;
  v10 = 0;
  v13 = (const void **)MEMORY[0x1E0CA32C0];
  while (1)
  {
    if (v12)
    {
      figCSSParseLWSP(buffer, v12, v5, (int64_t *)&v37);
      v14 = figTTMLParseCharacter(44, buffer, (int64_t)v37, v5, &v37);
      if ((_DWORD)v14)
        break;
      figCSSParseLWSP(buffer, (int64_t)v37, v5, (int64_t *)&v37);
    }
    if (v10)
      CFRelease(v10);
    v15 = (int64_t)v37;
    *(_QWORD *)v56 = v37;
    if (!figTTMLParseCFString((uint64_t)CFSTR("proportionalSerif"), buffer, (int64_t)v37, v5, (int64_t *)v56))
    {
      v18 = v13;
      goto LABEL_37;
    }
    if (!figTTMLParseCFString((uint64_t)CFSTR("proportionalSansSerif"), buffer, v15, v5, (int64_t *)v56))
    {
      v18 = (const void **)MEMORY[0x1E0CA32B8];
      goto LABEL_37;
    }
    if (!figTTMLParseCFString((uint64_t)CFSTR("monospaceSerif"), buffer, v15, v5, (int64_t *)v56))
    {
      v18 = (const void **)MEMORY[0x1E0CA32B0];
      goto LABEL_37;
    }
    if (!figTTMLParseCFString((uint64_t)CFSTR("monospaceSansSerif"), buffer, v15, v5, (int64_t *)v56))
    {
      v18 = (const void **)MEMORY[0x1E0CA32A8];
      goto LABEL_37;
    }
    if (!figTTMLParseCFString((uint64_t)CFSTR("default"), buffer, v15, v5, (int64_t *)v56))
    {
      v18 = (const void **)MEMORY[0x1E0CA3290];
      goto LABEL_37;
    }
    if (!figTTMLParseCFString((uint64_t)CFSTR("monospace"), buffer, v15, v5, (int64_t *)v56))
    {
      v18 = (const void **)MEMORY[0x1E0CA32A0];
      goto LABEL_37;
    }
    if (!figTTMLParseCFString((uint64_t)CFSTR("serif"), buffer, v15, v5, (int64_t *)v56))
    {
      v18 = (const void **)MEMORY[0x1E0CA32D0];
      goto LABEL_37;
    }
    if (!figTTMLParseCFString((uint64_t)CFSTR("sansSerif"), buffer, v15, v5, (int64_t *)v56))
    {
      v18 = (const void **)MEMORY[0x1E0CA32C8];
LABEL_37:
      v10 = *v18;
      v37 = *(__CFString **)v56;
      v14 = FigCaptionFontFamilyNameListAppend();
      if ((_DWORD)v14)
        break;
      goto LABEL_38;
    }
    if (v11)
      CFRelease(v11);
    v16 = v37;
    *(_QWORD *)v56 = v37;
    v54 = 0;
    if (!figTTMLParseCharacter(34, buffer, (int64_t)v37, v5, v56))
    {
      if (!figTTMLCopyEscapedCharactersUntil(34, (uint64_t)buffer, *(int64_t *)v56, v5, (int64_t *)v56, &v54)&& !figTTMLParseCharacter(34, buffer, *(int64_t *)v56, v5, v56))
      {
LABEL_26:
        v17 = *(_QWORD *)v56;
        v11 = v54;
        goto LABEL_27;
      }
      if (v54)
        CFRelease(v54);
    }
    *(_QWORD *)v56 = v16;
    v54 = 0;
    if (!figTTMLParseCharacter(39, buffer, (int64_t)v16, v5, v56))
    {
      if (!figTTMLCopyEscapedCharactersUntil(39, (uint64_t)buffer, *(int64_t *)v56, v5, (int64_t *)v56, &v54)&& !figTTMLParseCharacter(39, buffer, *(int64_t *)v56, v5, v56))
      {
        goto LABEL_26;
      }
      if (v54)
        CFRelease(v54);
    }
    v51 = v16;
    v11 = CFStringCreateMutable(v6, 0);
    v33 = v16;
    if ((uint64_t)v16 >= v5)
    {
      v17 = (int64_t)v16;
      goto LABEL_27;
    }
    cf = 0;
    v17 = (int64_t)v16;
    do
    {
      v34 = v33;
      if (v16 != v33)
      {
        if (!figTTMLParseCharacter(44, buffer, (int64_t)v16, v5, 0))
          break;
        figCSSParseLWSP(buffer, (int64_t)v16, v5, (int64_t *)&v51);
        v34 = v51;
        v17 = (int64_t)v16;
      }
      if (cf)
        CFRelease(cf);
      v54 = v34;
      cf = CFStringCreateMutable(v6, 0);
      chars = 45;
      if (!figTTMLParseCharacter(45, buffer, (int64_t)v34, v5, &v54))
        CFStringAppendCharacters(cf, &chars, 1);
      v16 = v54;
      *(_QWORD *)v56 = v54;
      if ((uint64_t)v54 >= v5)
        goto LABEL_113;
      if (((unint64_t)v54 & 0x8000000000000000) != 0 || (v19 = (char *)v48, (uint64_t)v48 <= (uint64_t)v54))
      {
        v22 = 0;
      }
      else
      {
        v20 = (UniChar *)*((_QWORD *)&theString + 1);
        if (*((_QWORD *)&theString + 1))
        {
          v21 = (uint64_t)v54 + *((_QWORD *)&v47 + 1);
        }
        else
        {
          if ((_QWORD)v47)
          {
            v22 = *((char *)&v54->isa + *((_QWORD *)&v47 + 1) + v47);
            goto LABEL_63;
          }
          if (v49 <= (uint64_t)v54 || (v23 = *((_QWORD *)&v48 + 1), *((uint64_t *)&v48 + 1) > (uint64_t)v54))
          {
            v24 = (char *)&v54[-1].length + 4;
            if ((unint64_t)v54 < 4)
              v24 = 0;
            if ((uint64_t)(v24 + 64) < (uint64_t)v48)
              v19 = v24 + 64;
            *((_QWORD *)&v48 + 1) = v24;
            v49 = (uint64_t)v19;
            v57.location = (CFIndex)&v24[*((_QWORD *)&v47 + 1)];
            v57.length = v19 - v24;
            CFStringGetCharacters((CFStringRef)theString, v57, buffer);
            v23 = *((_QWORD *)&v48 + 1);
          }
          v21 = (uint64_t)v16 - v23;
          v20 = buffer;
        }
        v22 = v20[v21];
      }
LABEL_63:
      v55 = v22;
      if (v22 != 95 && (unsigned __int16)(v22 - 97) >= 0x1Au && v22 <= 0xEDu && (unsigned __int16)(v22 - 91) < 0xFFE6u)
      {
        if (!figTTMLParseEscape(buffer, (int64_t)v16, v5, v56, &v55))
        {
LABEL_80:
          v22 = v55;
          v25 = *(__CFString **)v56;
          goto LABEL_81;
        }
LABEL_113:
        if (cf)
          CFRelease(cf);
        if (CFStringGetLength(v11))
          goto LABEL_27;
        v31 = 4294950724;
        goto LABEL_121;
      }
      do
      {
        v25 = (__CFString *)((char *)&v16->isa + 1);
LABEL_81:
        v52 = v22;
        v54 = v25;
        CFStringAppendCharacters(cf, &v52, 1);
        v16 = v54;
        if ((uint64_t)v54 >= v5)
          goto LABEL_95;
        *(_QWORD *)v56 = v54;
        if (((unint64_t)v54 & 0x8000000000000000) != 0 || (v26 = (char *)v48, (uint64_t)v48 <= (uint64_t)v54))
        {
          v22 = 0;
        }
        else
        {
          v27 = (UniChar *)*((_QWORD *)&theString + 1);
          if (*((_QWORD *)&theString + 1))
          {
            v28 = (uint64_t)v54 + *((_QWORD *)&v47 + 1);
          }
          else
          {
            if ((_QWORD)v47)
            {
              v22 = *((char *)&v54->isa + *((_QWORD *)&v47 + 1) + v47);
              goto LABEL_88;
            }
            if (v49 <= (uint64_t)v54 || (v29 = *((_QWORD *)&v48 + 1), *((uint64_t *)&v48 + 1) > (uint64_t)v54))
            {
              v30 = (char *)&v54[-1].length + 4;
              if ((unint64_t)v54 < 4)
                v30 = 0;
              if ((uint64_t)(v30 + 64) < (uint64_t)v48)
                v26 = v30 + 64;
              *((_QWORD *)&v48 + 1) = v30;
              v49 = (uint64_t)v26;
              v58.location = (CFIndex)&v30[*((_QWORD *)&v47 + 1)];
              v58.length = v26 - v30;
              CFStringGetCharacters((CFStringRef)theString, v58, buffer);
              v29 = *((_QWORD *)&v48 + 1);
            }
            v28 = (uint64_t)v16 - v29;
            v27 = buffer;
          }
          v22 = v27[v28];
        }
LABEL_88:
        v55 = v22;
      }
      while (v22 == 95
           || (unsigned __int16)((v22 & 0xFFDF) - 65) < 0x1Au
           || v22 > 0xEDu
           || v22 == 45
           || (unsigned __int16)(v22 - 58) >= 0xFFF6u);
      if (!figTTMLParseEscape(buffer, (int64_t)v16, v5, v56, &v55))
        goto LABEL_80;
      v16 = v54;
LABEL_95:
      v51 = v16;
      if ((__CFString *)v17 != v34)
      {
        v56[0] = 32;
        CFStringAppendCharacters(v11, v56, 1);
      }
      CFStringAppend(v11, cf);
    }
    while ((uint64_t)v16 < v5);
    if (cf)
      CFRelease(cf);
    v17 = (int64_t)v16;
LABEL_27:
    v37 = (__CFString *)v17;
    v14 = FigCaptionFontFamilyNameListAppend();
    v10 = 0;
    if ((_DWORD)v14)
      break;
LABEL_38:
    v12 = (int64_t)v37;
    if ((uint64_t)v37 >= v5)
      goto LABEL_117;
  }
  v31 = v14;
  if (!v11)
    goto LABEL_119;
LABEL_118:
  CFRelease(v11);
LABEL_119:
  if (v10)
    CFRelease(v10);
LABEL_121:
  if (v50)
    CFRelease(v50);
  return v31;
}

uint64_t FigTTMLParseTextEmphasisSyntaxAndCreateCaptionTextEmphasis(uint64_t a1, _QWORD *a2)
{
  const __CFArray *v3;
  const __CFArray *v4;
  int v5;
  CFIndex v6;
  int v7;
  char v8;
  int Int32IfPresent;
  int v10;
  int v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;

  if (!a1)
    return FigSignalErrorAt();
  if (!a2)
    return FigSignalErrorAt();
  v3 = (const __CFArray *)FigTTMLCFStringArrayCreateWithNMTOKENS(a1);
  v4 = v3;
  if (v3 && CFArrayGetCount(v3) >= 1)
  {
    v5 = 0;
    v6 = 0;
    v7 = 1;
    v8 = 1;
    while (1)
    {
      if (v8)
      {
        if (CFArrayGetCount(v4) <= v6)
        {
          v7 = 2;
        }
        else
        {
          MEMORY[0x19402F294](&initTextEmphasisParseMapOnce, figTTMLInitTextEmphasisParseMap);
          CFArrayGetValueAtIndex(v4, v6);
          Int32IfPresent = FigCFDictionaryGetInt32IfPresent();
          v7 = 1;
          if (Int32IfPresent)
            ++v6;
          else
            v7 = 13;
        }
      }
      switch(v5)
      {
        case 0:
          v8 = 0;
          v5 = 1;
          goto LABEL_29;
        case 1:
          v8 = 0;
          v5 = 2;
          goto LABEL_29;
        case 2:
          v8 = 0;
          v5 = 3;
          goto LABEL_29;
        case 3:
          v10 = 4;
          v11 = 4;
          v12 = v7 == 6;
          goto LABEL_19;
        case 4:
          v10 = 5;
          v11 = 5;
          v12 = v7 == 7;
LABEL_19:
          v8 = v12;
          if (v12)
            v5 = v10;
          else
            v5 = v11;
          goto LABEL_29;
        case 5:
          v8 = 0;
          v5 = 6;
          goto LABEL_29;
        case 6:
          v8 = 0;
          if (v7 == 2)
            v5 = 7;
          else
            v5 = 8;
          goto LABEL_29;
        case 7:
        case 8:
          if (v5 == 8 || v7 == 13)
          {
            v13 = FigSignalErrorAt();
            if ((_DWORD)v13)
              goto LABEL_37;
          }
          v13 = FigCaptionTextEmphasisCreate();
          if ((_DWORD)v13)
            goto LABEL_37;
          v14 = 0;
          *a2 = 0;
          if (v4)
            goto LABEL_41;
          return v14;
        default:
          v8 = 0;
LABEL_29:
          if (v5 != 8 && v7 == 13)
          {
            v7 = 13;
            v5 = 8;
            v8 = 0;
          }
          break;
      }
    }
  }
  v13 = FigSignalErrorAt();
LABEL_37:
  v14 = v13;
  if (v4)
LABEL_41:
    CFRelease(v4);
  return v14;
}

uint64_t FigTTMLParseTextShadowSyntaxAndCreateCaptionTextShadowList(uint64_t a1, CFTypeRef *a2)
{
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex Count;
  CFAllocatorRef *v6;
  int NextToken;
  __CFArray *v8;
  CFTypeRef v9;
  CFMutableArrayRef v10;
  uint64_t v11;
  const __CFAllocator *v12;
  __CFArray *Mutable;
  CFStringRef v14;
  CFIndex i;
  const __CFString *ValueAtIndex;
  CFIndex Length;
  const __CFArray *Results;
  const __CFArray *v19;
  const __CFAllocator *v20;
  CFIndex v21;
  CFIndex v22;
  CFIndex *v23;
  CFIndex v24;
  CFIndex v25;
  CFIndex v26;
  BOOL v27;
  int v28;
  BOOL v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t None;
  int v38;
  CFTypeRef *v39;
  const __CFArray *v40;
  CFIndex v41;
  CFAllocatorRef allocator;
  CFIndex v43;
  CFTypeRef cf;
  uint64_t v45[2];
  CFIndex v46;
  CFTypeRef v47;
  CFTypeRef v48;
  CFAllocatorRef v49;
  CFMutableArrayRef theArray;
  void *value;
  uint64_t v52;
  CFRange v53;
  CFRange v54;
  CFRange v55;
  CFRange v56;

  v47 = 0;
  v48 = 0;
  v45[1] = 0;
  v46 = 0;
  cf = 0;
  v45[0] = 0;
  if (!a1 || !a2)
  {
    v11 = FigSignalErrorAt();
    v9 = 0;
    v4 = 0;
    goto LABEL_9;
  }
  v3 = (const __CFArray *)FigTTMLCFStringArrayCreateWithNMTOKENS(a1);
  v4 = v3;
  if (!v3 || (Count = CFArrayGetCount(v3), Count <= 0))
  {
    v11 = FigSignalErrorAt();
    v9 = 0;
LABEL_9:
    v8 = 0;
    goto LABEL_102;
  }
  v6 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  v39 = a2;
  if (Count == 1)
  {
    NextToken = figTTMLTextShadowParseGetNextToken(v4, 0, (CFIndex *)&v49, 0, 0);
    if (NextToken == 3)
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
LABEL_98:
      None = FigCaptionTextShadowListCreateNone();
      if ((_DWORD)None)
      {
        v11 = None;
      }
      else
      {
LABEL_99:
        v11 = 0;
        *v39 = v48;
        v48 = 0;
      }
LABEL_100:
      if (v10)
LABEL_101:
        CFRelease(v10);
      goto LABEL_102;
    }
  }
  else
  {
    NextToken = 1;
  }
  v38 = NextToken;
  v12 = *v6;
  Mutable = CFArrayCreateMutable(*v6, 0, MEMORY[0x1E0C9B378]);
  v40 = v4;
  if (Mutable)
  {
    v41 = CFArrayGetCount(v4);
    if (v41 >= 1)
    {
      v14 = 0;
      for (i = 0; i != v41; ++i)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v4, i);
        Length = CFStringGetLength(ValueAtIndex);
        v56.location = 0;
        v56.length = Length;
        Results = CFStringCreateArrayWithFindResults(v12, ValueAtIndex, CFSTR(","), v56, 0);
        if (Results)
        {
          v19 = Results;
          allocator = (CFAllocatorRef)Length;
          v43 = i;
          v20 = v12;
          if (CFArrayGetCount(Results) < 1)
          {
            v22 = 0;
          }
          else
          {
            v21 = 0;
            v22 = 0;
            do
            {
              v23 = (CFIndex *)CFArrayGetValueAtIndex(v19, v21);
              v25 = *v23;
              v24 = v23[1];
              v26 = *v23 - v22;
              if (v26 >= 1)
              {
                if (v14)
                  CFRelease(v14);
                v53.location = v22;
                v53.length = v26;
                v14 = CFStringCreateWithSubstring(v20, ValueAtIndex, v53);
                CFArrayAppendValue(Mutable, v14);
              }
              if (v24 >= 1)
              {
                if (v14)
                  CFRelease(v14);
                v54.location = v25;
                v54.length = v24;
                v14 = CFStringCreateWithSubstring(v20, ValueAtIndex, v54);
                CFArrayAppendValue(Mutable, v14);
              }
              v22 = v24 + v25;
              ++v21;
            }
            while (v21 < CFArrayGetCount(v19));
          }
          v12 = v20;
          if ((uint64_t)allocator > v22)
          {
            if (v14)
              CFRelease(v14);
            v55.location = v22;
            v55.length = (CFIndex)allocator - v22;
            v14 = CFStringCreateWithSubstring(v20, ValueAtIndex, v55);
            CFArrayAppendValue(Mutable, v14);
          }
          CFRelease(v19);
          v4 = v40;
          i = v43;
        }
        else
        {
          CFArrayAppendValue(Mutable, ValueAtIndex);
        }
      }
      if (v14)
        CFRelease(v14);
    }
  }
  else
  {
    FigSignalErrorAt();
  }
  v8 = CFArrayCreateMutable(v12, 0, MEMORY[0x1E0C9B378]);
  if (!v8)
  {
    v11 = FigSignalErrorAt();
    if (!Mutable)
      goto LABEL_44;
    goto LABEL_43;
  }
  v52 = 0;
  v49 = CFGetAllocator(v4);
  theArray = v8;
  value = 0;
  FigCFArrayApplyFunction();
  if (value)
  {
    CFArrayAppendValue(theArray, value);
    if (value)
    {
      CFRelease(value);
      v11 = 0;
      value = 0;
      if (!Mutable)
        goto LABEL_44;
      goto LABEL_43;
    }
  }
  v11 = 0;
  if (Mutable)
LABEL_43:
    CFRelease(Mutable);
LABEL_44:
  if (!(_DWORD)v11)
  {
    v10 = 0;
    v9 = 0;
    v27 = 1;
    v28 = v38;
    while (1)
    {
      if (v27)
      {
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
        v28 = figTTMLTextShadowParseGetNextToken(v8, v46, &v46, v45, &cf);
      }
      switch((int)v11)
      {
        case 0:
          v27 = 0;
          LODWORD(v11) = 1;
          goto LABEL_86;
        case 1:
          v27 = 0;
          LODWORD(v11) = 2;
          goto LABEL_86;
        case 2:
          v29 = v28 == 3;
          v27 = v28 == 3;
          v30 = 3;
          v31 = 6;
          goto LABEL_66;
        case 3:
          v27 = 0;
          LODWORD(v11) = 4;
          goto LABEL_86;
        case 4:
          v27 = 0;
          LODWORD(v11) = 6;
          goto LABEL_86;
        case 5:
          if ((v28 | 4) != 6)
            goto LABEL_80;
          if (!v10)
          {
            v10 = CFArrayCreateMutable(v12, 0, MEMORY[0x1E0C9B378]);
            if (!v10)
            {
              v11 = FigSignalErrorAt();
              goto LABEL_122;
            }
          }
          v32 = FigCaptionTextShadowCreate();
          if ((_DWORD)v32)
          {
            v11 = v32;
            v4 = v40;
            goto LABEL_101;
          }
          CFArrayAppendValue(v10, v47);
          if (v47)
          {
            CFRelease(v47);
            v47 = 0;
          }
          if (v9)
            CFRelease(v9);
          v9 = 0;
          v29 = v28 == 6;
          v27 = v28 == 6;
          v30 = 10;
          v31 = 4;
LABEL_66:
          if (v29)
            LODWORD(v11) = v31;
          else
            LODWORD(v11) = v30;
LABEL_86:
          if ((_DWORD)v11 != 12 && v28 == 7)
          {
            v27 = 0;
            LODWORD(v11) = 12;
          }
          break;
        case 6:
          if (v28 != 4)
            goto LABEL_80;
          LODWORD(v11) = 7;
          v27 = 1;
          goto LABEL_86;
        case 7:
          if (v28 != 4)
            goto LABEL_80;
          LODWORD(v11) = 8;
          v27 = 1;
          goto LABEL_86;
        case 8:
          v27 = 0;
          LODWORD(v11) = 5;
          switch(v28)
          {
            case 2:
            case 6:
              goto LABEL_86;
            case 4:
              LODWORD(v11) = 9;
              v27 = 1;
              break;
            case 5:
              goto LABEL_78;
            default:
              goto LABEL_80;
          }
          goto LABEL_86;
        case 9:
          v27 = 0;
          LODWORD(v11) = 5;
          if (v28 == 2 || v28 == 6)
            goto LABEL_86;
          if (v28 == 5)
          {
LABEL_78:
            if (cf)
              v9 = CFRetain(cf);
            else
              v9 = 0;
            v27 = 1;
          }
          else
          {
LABEL_80:
            v27 = 0;
            LODWORD(v11) = 12;
          }
          goto LABEL_86;
        case 10:
          v27 = 0;
          if (v28 == 2)
            LODWORD(v11) = 11;
          else
            LODWORD(v11) = 12;
          goto LABEL_86;
        case 11:
        case 12:
          if ((_DWORD)v11 == 12 || v28 == 7)
          {
            v34 = FigSignalErrorAt();
            if ((_DWORD)v34)
            {
              v11 = v34;
              v4 = v40;
              goto LABEL_100;
            }
          }
          v4 = v40;
          if (!v10 || !CFArrayGetCount(v10))
            goto LABEL_98;
          v35 = FigCaptionTextShadowListCreate();
          if (!(_DWORD)v35)
            goto LABEL_99;
          v11 = v35;
          goto LABEL_101;
        default:
          v27 = 0;
          goto LABEL_86;
      }
    }
  }
  v9 = 0;
LABEL_122:
  v4 = v40;
LABEL_102:
  if (cf)
    CFRelease(cf);
  if (v9)
    CFRelease(v9);
  if (v8)
    CFRelease(v8);
  if (v4)
    CFRelease(v4);
  if (v47)
    CFRelease(v47);
  if (v48)
    CFRelease(v48);
  return v11;
}

uint64_t figTTMLTextShadowParseGetNextToken(CFArrayRef theArray, CFIndex a2, CFIndex *a3, uint64_t *a4, _QWORD *a5)
{
  const __CFArray *v9;
  uint64_t v10;
  uint64_t v11;
  const __CFString *ValueAtIndex;
  const void *CGColorSRGB;
  uint64_t v14;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  unsigned int v20;

  v9 = theArray;
  if (theArray)
    theArray = (CFArrayRef)CFArrayGetCount(theArray);
  v10 = *MEMORY[0x1E0CA4AD0];
  v11 = *(_QWORD *)(MEMORY[0x1E0CA4AD0] + 8);
  if ((uint64_t)theArray <= a2)
  {
    CGColorSRGB = 0;
    v14 = 2;
  }
  else
  {
    MEMORY[0x19402F294](&initTextShadowParseMapOnce, figTTMLInitTextShadowParseMap);
    v20 = 1;
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v9, a2);
    if (FigCFDictionaryGetInt32IfPresent())
    {
      CGColorSRGB = 0;
      v14 = v20;
      ++a2;
    }
    else
    {
      v10 = FigTTMLParseLengthSyntax(ValueAtIndex);
      v11 = v16;
      if ((v16 & 0x100000000) != 0)
      {
        CGColorSRGB = 0;
        ++a2;
        v14 = 4;
      }
      else
      {
        v19 = 0;
        v18 = 0;
        v17 = 0;
        if (FigTTMLParseColor(ValueAtIndex, (float *)&v19, (float *)&v18 + 1, (float *)&v18, (float *)&v17))
        {
          CGColorSRGB = 0;
          v14 = 7;
        }
        else
        {
          CGColorSRGB = (const void *)FigCreateCGColorSRGB();
          ++a2;
          v14 = 5;
        }
      }
    }
  }
  *a3 = a2;
  if (a4)
  {
    *a4 = v10;
    a4[1] = v11;
  }
  if (a5)
  {
    *a5 = CGColorSRGB;
  }
  else if (CGColorSRGB)
  {
    CFRelease(CGColorSRGB);
  }
  return v14;
}

uint64_t FigTTMLParseRubyReserveSyntaxAndCreateCaptionRubyReserve(uint64_t a1, _QWORD *a2)
{
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  const void *ValueAtIndex;
  const void *v8;
  uint64_t None;
  const __CFString *v11;
  uint64_t v12;

  if (!a1)
    return FigSignalErrorAt();
  if (!a2)
    return FigSignalErrorAt();
  v3 = (const __CFArray *)FigTTMLCFStringArrayCreateWithNMTOKENS(a1);
  if (!v3)
    return FigSignalErrorAt();
  v4 = v3;
  Count = CFArrayGetCount(v3);
  if ((unint64_t)(Count - 3) < 0xFFFFFFFFFFFFFFFELL)
    goto LABEL_23;
  v6 = Count;
  ValueAtIndex = CFArrayGetValueAtIndex(v4, 0);
  if (!ValueAtIndex)
    goto LABEL_23;
  v8 = ValueAtIndex;
  if (!CFEqual(ValueAtIndex, CFSTR("none")))
  {
    if (!CFEqual(v8, CFSTR("before"))
      && !CFEqual(v8, CFSTR("after"))
      && !CFEqual(v8, CFSTR("outside"))
      && !CFEqual(v8, CFSTR("both")))
    {
      FigSignalErrorAt();
    }
    if (v6 == 2)
    {
      v11 = (const __CFString *)CFArrayGetValueAtIndex(v4, 1);
      if (!v11)
        goto LABEL_23;
      FigTTMLParseLengthSyntax(v11);
    }
    None = FigCaptionRubyReserveCreate();
    if (!(_DWORD)None)
      goto LABEL_20;
LABEL_24:
    v12 = None;
    goto LABEL_21;
  }
  if (v6 != 1)
  {
LABEL_23:
    None = FigSignalErrorAt();
    goto LABEL_24;
  }
  None = FigCaptionRubyReserveCreateNone();
  if ((_DWORD)None)
    goto LABEL_24;
LABEL_20:
  v12 = 0;
  *a2 = 0;
LABEL_21:
  CFRelease(v4);
  return v12;
}

uint64_t FigTTMLNodeGetParameters(uint64_t ParentNode, _QWORD *a2)
{
  uint64_t v3;

  do
  {
    v3 = ParentNode;
    ParentNode = FigTTMLNodeGetParentNode();
  }
  while (ParentNode);
  return FigTTMLRootGetParameters(v3, a2);
}

uint64_t FigTTMLNodeUseDefaultWhitespaceHandling(uint64_t a1)
{
  uint64_t DerivedStorage;
  void *value;

  if (!a1)
    return 1;
  while (1)
  {
    value = 0;
    DerivedStorage = CMBaseObjectGetDerivedStorage();
    if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(DerivedStorage + 24), CFSTR("http://www.w3.org/XML/1998/namespace space"), (const void **)&value))
    {
      if (CFEqual(value, CFSTR("default")))
        return 1;
      if (CFEqual(value, CFSTR("preserve")))
        break;
    }
    if (!FigTTMLNodeGetParentNode())
      return 1;
  }
  return 0;
}

__CFString *FigTTMLCopyStringWithDefaultWhitespaceHandling(const __CFString *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v7;
  int64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  CFIndex v12;
  UniChar v13;
  int64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int64_t v19;
  CFIndex v20;
  unsigned int v21;
  uint64_t v22;
  UniChar v25;
  UniChar chars;
  UniChar buffer[8];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  CFStringRef v35;
  const UniChar *v36;
  const char *v37;
  uint64_t v38;
  CFIndex v39;
  int64_t v40;
  int64_t v41;
  CFRange v42;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  Length = CFStringGetLength(a1);
  v35 = a1;
  v38 = 0;
  v39 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v36 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v37 = CStringPtr;
  v40 = 0;
  v41 = 0;
  if (Length >= 1)
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v10 = 64;
    *(_OWORD *)buffer = 0u;
    v28 = 0u;
    do
    {
      if ((unint64_t)v8 >= 4)
        v11 = 4;
      else
        v11 = v8;
      chars = 0;
      v12 = v39;
      if (v39 <= v8)
        goto LABEL_29;
      if (v36)
      {
        v13 = v36[v8 + v38];
      }
      else if (v37)
      {
        v13 = v37[v38 + v8];
      }
      else
      {
        v14 = v40;
        if (v41 <= v8 || v40 > v8)
        {
          v16 = -v11;
          v17 = v11 + v7;
          v18 = v10 - v11;
          v19 = v8 + v16;
          v20 = v19 + 64;
          if (v19 + 64 >= v39)
            v20 = v39;
          v40 = v19;
          v41 = v20;
          if (v39 >= v18)
            v12 = v18;
          v42.length = v12 + v17;
          v42.location = v19 + v38;
          CFStringGetCharacters(v35, v42, buffer);
          v14 = v40;
        }
        v13 = buffer[v8 - v14];
      }
      chars = v13;
      v21 = v13;
      v22 = (1 << v13) & 0x100002600;
      if (v21 > 0x20 || v22 == 0)
      {
LABEL_29:
        CFStringAppendCharacters(Mutable, &chars, 1);
        v9 = 0;
      }
      else if (v9)
      {
        v9 = 1;
      }
      else
      {
        v25 = 32;
        v9 = 1;
        CFStringAppendCharacters(Mutable, &v25, 1);
      }
      ++v8;
      --v7;
      ++v10;
    }
    while (Length != v8);
  }
  return Mutable;
}

uint64_t FigTTMLParseCellResolution(const __CFString *a1, _DWORD *a2, _DWORD *a3)
{
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  UniChar buffer[8];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  const __CFString *v20;
  const UniChar *v21;
  const char *v22;
  uint64_t v23;
  CFIndex v24;
  uint64_t v25;
  uint64_t v26;

  Length = CFStringGetLength(a1);
  v11 = 0;
  v20 = a1;
  v23 = 0;
  v24 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v21 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  *(_OWORD *)buffer = 0u;
  v13 = 0u;
  v10 = 0;
  v25 = 0;
  v26 = 0;
  v22 = CStringPtr;
  result = figTTMLParseOneOrMoreDigits(buffer, 0, Length, &v11, (_DWORD *)&v10 + 1);
  if (!(_DWORD)result)
  {
    result = figTTMLParseOneOrMoreWhitespaces(buffer, v11, &v11);
    if (!(_DWORD)result)
    {
      result = figTTMLParseOneOrMoreDigits(buffer, v11, Length, &v11, &v10);
      if (!(_DWORD)result)
      {
        *a2 = HIDWORD(v10);
        *a3 = v10;
      }
    }
  }
  return result;
}

uint64_t FigTTMLParsePixelResolution(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  const __CFArray *v5;
  const __CFArray *v6;
  const __CFString *ValueAtIndex;
  double v8;
  uint64_t v9;
  uint64_t v10;
  const __CFString *v11;
  double v12;
  uint64_t v13;
  uint64_t v14;

  v5 = (const __CFArray *)FigTTMLCFStringArrayCreateWithNMTOKENS();
  if (!v5)
    return FigSignalErrorAt();
  v6 = v5;
  if (CFArrayGetCount(v5) == 2
    && (ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, 0),
        v8 = COERCE_DOUBLE(FigTTMLParseLengthSyntax(ValueAtIndex)),
        v10 = v9,
        v11 = (const __CFString *)CFArrayGetValueAtIndex(v6, 1),
        v12 = COERCE_DOUBLE(FigTTMLParseLengthSyntax(v11)),
        (v10 & 0x100000000) != 0)
    && (_DWORD)v10 == 1886920736
    && (v13 & 0x100000000) != 0
    && v13 == 1886920736)
  {
    v14 = 0;
    *a2 = v8;
    *a3 = v12;
  }
  else
  {
    v14 = FigSignalErrorAt();
  }
  CFRelease(v6);
  return v14;
}

uint64_t FigTTMLParseTextCombineDigits(const __CFString *a1, int *a2)
{
  CFIndex Length;
  int64_t v5;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t result;
  int v9;
  unsigned int v10;
  uint64_t v11;
  UniChar buffer[8];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  const __CFString *v20;
  const UniChar *v21;
  const char *v22;
  uint64_t v23;
  CFIndex v24;
  uint64_t v25;
  uint64_t v26;

  v11 = 0;
  v10 = 2;
  Length = CFStringGetLength(a1);
  if (!a2)
    return FigSignalErrorAt();
  v5 = Length;
  v20 = a1;
  v23 = 0;
  v24 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v21 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  *(_OWORD *)buffer = 0u;
  v13 = 0u;
  v22 = CStringPtr;
  v25 = 0;
  v26 = 0;
  result = figTTMLParseString("digits", buffer, 0, v5, &v11);
  if (!(_DWORD)result)
  {
    if (v11 == v5)
      goto LABEL_8;
    result = figTTMLParseOneOrMoreWhitespaces(buffer, v11, &v11);
    if ((_DWORD)result)
      return result;
    if (v11 == v5)
    {
LABEL_8:
      v9 = 2;
    }
    else
    {
      result = figTTMLParseOneOrMoreDigits(buffer, v11, v5, &v11, &v10);
      if ((_DWORD)result)
        return result;
      v9 = v10;
      if (v10 >= 5)
        return FigSignalErrorAt();
    }
    result = 0;
    *a2 = v9;
  }
  return result;
}

uint64_t FigTTMLParsePositionSyntaxAndCreateCaptionPosition(uint64_t a1, _QWORD *a2)
{
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  __int128 v8;
  _QWORD *v9;
  int NextToken;
  const __CFString *ValueAtIndex;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  int v17;
  int v18;
  int v19;
  char v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  char v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  __int128 *v40;
  int v41;
  __int128 *v42;
  int v43;
  __int128 *v44;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  int32x2_t v52;
  __int128 v53;
  __int128 v54;
  CFIndex v55;
  CFTypeRef v56;
  CFIndex v57[4];

  v56 = 0;
  if (!a1 || !a2)
    return FigSignalErrorAt();
  v3 = (const __CFArray *)FigTTMLCFStringArrayCreateWithNMTOKENS(a1);
  v4 = v3;
  if (!v3)
    goto LABEL_13;
  Count = CFArrayGetCount(v3);
  if ((unint64_t)(Count - 5) <= 0xFFFFFFFFFFFFFFFBLL)
    goto LABEL_13;
  v6 = Count;
  v7 = 0;
  *(_QWORD *)&v8 = 0x200000002;
  *((_QWORD *)&v8 + 1) = 0x200000002;
  v50 = *MEMORY[0x1E0CA4AC8];
  v51 = v50;
  v48 = v50;
  v49 = v50;
  v46 = v50;
  v47 = v8;
  v52 = 0;
  v53 = v50;
  v54 = v50;
  v9 = (_QWORD *)&v48 + 1;
  do
  {
    NextToken = figTTMLPositionParseGetNextToken(v4, v7, v57);
    if (NextToken == 8)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v4, v7);
      *(v9 - 1) = FigTTMLParseLengthSyntax(ValueAtIndex);
      *v9 = v12;
    }
    *((_DWORD *)&v47 + v7++) = NextToken;
    v9 += 2;
  }
  while (v6 != v7);
  v55 = v6;
  if (figTTMLPositionParseGetNextToken(v4, v6, &v55) == 2)
  {
    switch(v6)
    {
      case 1:
        switch((int)v47)
        {
          case 3:
            v13 = 1818584692;
            goto LABEL_64;
          case 4:
            v13 = 1919510376;
            goto LABEL_64;
          case 5:
            v30 = 1953460256;
            goto LABEL_57;
          case 6:
            v30 = 1651471476;
            goto LABEL_57;
          case 7:
            goto LABEL_63;
          case 8:
            v53 = v48;
            goto LABEL_129;
          default:
            goto LABEL_128;
        }
      case 2:
        v16 = 0;
        v17 = 1;
        v18 = 1;
        switch((int)v47)
        {
          case 3:
            v17 = 0;
            v19 = 1818584692;
            goto LABEL_35;
          case 4:
            v17 = 0;
            v19 = 1919510376;
LABEL_35:
            v52.i32[0] = v19;
            goto LABEL_40;
          case 5:
            v18 = 0;
            v31 = 1953460256;
            goto LABEL_38;
          case 6:
            v18 = 0;
            v31 = 1651471476;
LABEL_38:
            v52.i32[1] = v31;
            goto LABEL_40;
          case 7:
            goto LABEL_41;
          case 8:
            v17 = 0;
            v53 = v48;
LABEL_40:
            v16 = 1;
LABEL_41:
            switch(DWORD1(v47))
            {
              case 3:
                if (!v17)
                  goto LABEL_128;
                v32 = 1818584692;
                goto LABEL_55;
              case 4:
                if (!v17)
                  goto LABEL_128;
                v32 = 1919510376;
LABEL_55:
                v52.i32[0] = v32;
                if ((v16 & 1) == 0)
                  goto LABEL_56;
                goto LABEL_129;
              case 5:
                if (!v18)
                  goto LABEL_128;
                v35 = 1953460256;
                goto LABEL_62;
              case 6:
                if (!v18)
                  goto LABEL_128;
                v35 = 1651471476;
LABEL_62:
                v52.i32[1] = v35;
                if ((v16 & 1) == 0)
                  goto LABEL_63;
                goto LABEL_129;
              case 7:
                if ((v16 & 1) != 0)
                {
                  if (v17)
                  {
LABEL_63:
                    v13 = 1667591796;
LABEL_64:
                    v52.i32[0] = v13;
                  }
                  else
                  {
LABEL_56:
                    v30 = 1667591796;
LABEL_57:
                    v52.i32[1] = v30;
                  }
                }
                else
                {
                  v52 = vdup_n_s32(0x63656E74u);
                }
                break;
              default:
                goto LABEL_128;
            }
            break;
          default:
            goto LABEL_128;
        }
        goto LABEL_129;
      case 3:
        *(_OWORD *)v57 = v46;
        v20 = 0;
        v21 = 1;
        v22 = 1;
        switch((int)v47)
        {
          case 3:
            v21 = 0;
            v23 = 1818584692;
            goto LABEL_45;
          case 4:
            v21 = 0;
            v23 = 1919510376;
LABEL_45:
            v52.i32[0] = v23;
            goto LABEL_49;
          case 5:
            v22 = 0;
            v33 = 1953460256;
            goto LABEL_48;
          case 6:
            v22 = 0;
            v33 = 1651471476;
LABEL_48:
            v52.i32[1] = v33;
LABEL_49:
            v20 = 1;
            goto LABEL_50;
          case 7:
LABEL_50:
            switch(DWORD2(v47))
            {
              case 3:
                if ((v21 & 1) == 0)
                  goto LABEL_112;
                v34 = 1818584692;
                goto LABEL_71;
              case 4:
                if ((v21 & 1) == 0)
                  goto LABEL_112;
                v34 = 1919510376;
LABEL_71:
                v52.i32[0] = v34;
                v15 = 0;
                v36 = 0;
                if ((v20 & 1) == 0)
                  v52.i32[1] = 1667591796;
                goto LABEL_83;
              case 5:
                if ((v22 & 1) == 0)
                  goto LABEL_112;
                v37 = 1953460256;
                goto LABEL_77;
              case 6:
                if ((v22 & 1) == 0)
                  goto LABEL_112;
                v37 = 1651471476;
LABEL_77:
                v52.i32[1] = v37;
                if ((v20 & 1) != 0)
                  goto LABEL_78;
                goto LABEL_81;
              case 7:
                if ((v20 & 1) == 0)
                  goto LABEL_112;
                if (v21)
                {
LABEL_81:
                  v15 = 0;
                  v52.i32[0] = 1667591796;
                }
                else if (v22)
                {
                  v15 = 0;
                  v52.i32[1] = 1667591796;
                }
                else
                {
LABEL_78:
                  v15 = 0;
                }
                goto LABEL_82;
              case 8:
                v15 = 0;
                v38 = 0;
                *(_OWORD *)v57 = v50;
                v36 = 1;
                goto LABEL_84;
              default:
                v15 = FigSignalErrorAt();
LABEL_82:
                v36 = 1;
LABEL_83:
                v38 = 1;
LABEL_84:
                switch(DWORD1(v47))
                {
                  case 3:
                    if ((v21 & 1) == 0 || v38)
                      goto LABEL_112;
                    v39 = 1818584692;
                    goto LABEL_92;
                  case 4:
                    if ((v21 & 1) == 0 || v38)
                      goto LABEL_112;
                    v39 = 1919510376;
LABEL_92:
                    v52.i32[0] = v39;
                    if (v36)
                      v40 = &v54;
                    else
                      v40 = &v53;
                    *v40 = *(_OWORD *)v57;
                    if ((v20 & 1) == 0)
                      v52.i32[1] = 1667591796;
                    goto LABEL_113;
                  case 5:
                    if ((v22 & 1) == 0 || v38)
                      goto LABEL_112;
                    v41 = 1953460256;
                    goto LABEL_103;
                  case 6:
                    if ((v22 & 1) == 0 || v38)
                      goto LABEL_112;
                    v41 = 1651471476;
LABEL_103:
                    v52.i32[1] = v41;
                    if (v36)
                      v42 = &v54;
                    else
                      v42 = &v53;
                    *v42 = *(_OWORD *)v57;
                    if ((v20 & 1) == 0)
                      v52.i32[0] = 1667591796;
                    break;
                  case 8:
                    if ((v38 & 1) == 0 || (v20 & 1) == 0)
                      goto LABEL_112;
                    if ((v21 & 1) != 0)
                      v54 = v49;
                    else
                      v53 = v49;
                    break;
                  default:
                    goto LABEL_112;
                }
                break;
            }
            break;
          default:
LABEL_112:
            v15 = FigSignalErrorAt();
            break;
        }
LABEL_113:
        if ((_DWORD)v15)
          break;
        goto LABEL_129;
      case 4:
        switch((int)v47)
        {
          case 3:
            v24 = 0;
            v25 = 1818584692;
            goto LABEL_22;
          case 4:
            v24 = 0;
            v25 = 1919510376;
LABEL_22:
            v52.i32[0] = v25;
            v26 = 1;
            goto LABEL_26;
          case 5:
            v26 = 0;
            v27 = 1953460256;
            goto LABEL_25;
          case 6:
            v26 = 0;
            v27 = 1651471476;
LABEL_25:
            v52.i32[1] = v27;
            v24 = 1;
LABEL_26:
            if (DWORD1(v47) != 8)
              goto LABEL_128;
            switch(DWORD2(v47))
            {
              case 3:
                if (!v24)
                  goto LABEL_128;
                v28 = 0;
                v29 = 1818584692;
                goto LABEL_117;
              case 4:
                if (!v24)
                  goto LABEL_128;
                v28 = 0;
                v29 = 1919510376;
LABEL_117:
                v52.i32[0] = v29;
                goto LABEL_122;
              case 5:
                if (!v26)
                  goto LABEL_128;
                v43 = 1953460256;
                goto LABEL_121;
              case 6:
                v43 = 1651471476;
LABEL_121:
                v52.i32[1] = v43;
                v28 = 1;
LABEL_122:
                if (HIDWORD(v47) != 8)
                  goto LABEL_128;
                if (v24)
                  v44 = &v54;
                else
                  v44 = &v53;
                *v44 = v49;
                if ((v28 & 1) != 0)
                  v54 = v51;
                else
                  v53 = v51;
                break;
              default:
                goto LABEL_128;
            }
            goto LABEL_129;
          default:
LABEL_128:
            v14 = FigSignalErrorAt();
            if (!(_DWORD)v14)
              goto LABEL_129;
            goto LABEL_14;
        }
      default:
LABEL_129:
        v15 = FigCaptionPositionCreate();
        *a2 = v56;
        v56 = 0;
        break;
    }
  }
  else
  {
LABEL_13:
    v14 = FigSignalErrorAt();
LABEL_14:
    v15 = v14;
  }
  if (v4)
  {
    CFRelease(v4);
    if (v56)
      CFRelease(v56);
  }
  return v15;
}

uint64_t figTTMLPositionParseGetNextToken(CFArrayRef theArray, CFIndex a2, CFIndex *a3)
{
  const __CFArray *v5;
  const __CFString *ValueAtIndex;
  uint64_t result;
  uint64_t v8;

  v5 = theArray;
  if (theArray)
    theArray = (CFArrayRef)CFArrayGetCount(theArray);
  if ((uint64_t)theArray <= a2)
  {
    result = 2;
  }
  else
  {
    MEMORY[0x19402F294](&initPositionParseMapOnce, figTTMLInitPositionParseMap);
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, a2);
    if (FigCFDictionaryGetInt32IfPresent())
    {
      result = 1;
      ++a2;
    }
    else
    {
      FigTTMLParseLengthSyntax(ValueAtIndex);
      if ((v8 & 0x100000000) != 0)
        result = 8;
      else
        result = 9;
    }
  }
  *a3 = a2;
  return result;
}

uint64_t figTTMLParseTwoOrMoreDigits(UniChar *buffer, uint64_t a2, uint64_t a3, _QWORD *a4, _DWORD *a5)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;

  v10 = 0;
  v11 = a2;
  if (!a4 || !a5)
    return FigSignalErrorAt();
  result = figTTMLParseDigits(2u, buffer, a2, a3, &v11, (unsigned int *)&v10 + 1);
  if (!(_DWORD)result)
  {
    if (figTTMLParseDigits(1u, buffer, v11, a3, &v11, (unsigned int *)&v10))
    {
LABEL_7:
      result = 0;
      *a4 = v11;
      *a5 = HIDWORD(v10);
    }
    else
    {
      while (HIDWORD(v10) <= 0x1745D173)
      {
        HIDWORD(v10) = v10 + 10 * HIDWORD(v10);
        if (figTTMLParseDigits(1u, buffer, v11, a3, &v11, (unsigned int *)&v10))
          goto LABEL_7;
      }
      return 4294950725;
    }
  }
  return result;
}

uint64_t figTTMLParseDigits(unsigned int a1, UniChar *buffer, uint64_t a3, uint64_t a4, uint64_t *a5, unsigned int *a6)
{
  unsigned int v8;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  UniChar v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t result;
  CFRange v27;

  if (!a5 || !a6)
    return FigSignalErrorAt();
  v8 = a1;
  if (a4 - a3 < a1)
    return 4294950724;
  if (a1)
  {
    v11 = 0;
    v12 = -a3;
    v13 = a3 + 64;
    v14 = a3;
    while (1)
    {
      v15 = (unint64_t)v14 >= 4 ? 4 : v14;
      if (a3 < 0)
        return 4294950724;
      v16 = *((_QWORD *)buffer + 20);
      if (v16 <= v14)
        return 4294950724;
      v17 = *((_QWORD *)buffer + 17);
      if (v17)
      {
        v18 = *(_WORD *)(v17 + 2 * (v14 + *((_QWORD *)buffer + 19)));
      }
      else
      {
        v19 = *((_QWORD *)buffer + 18);
        if (v19)
        {
          v18 = *(char *)(v19 + *((_QWORD *)buffer + 19) + v14);
        }
        else
        {
          if (*((_QWORD *)buffer + 22) <= v14 || (v20 = *((_QWORD *)buffer + 21), v20 > v14))
          {
            v21 = -v15;
            v22 = v15 + v12;
            v23 = v13 - v15;
            v24 = v14 + v21;
            v25 = v24 + 64;
            if (v24 + 64 >= v16)
              v25 = *((_QWORD *)buffer + 20);
            *((_QWORD *)buffer + 21) = v24;
            *((_QWORD *)buffer + 22) = v25;
            if (v16 >= v23)
              v16 = v23;
            v27.length = v16 + v22;
            v27.location = v24 + *((_QWORD *)buffer + 19);
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v27, buffer);
            v20 = *((_QWORD *)buffer + 21);
          }
          v18 = buffer[v14 - v20];
        }
      }
      if ((unsigned __int16)(v18 - 58) < 0xFFF6u)
        return 4294950724;
      if (v11 > 0x1745D173)
        return 4294950725;
      v11 = v18 + 10 * v11 - 48;
      ++v14;
      --v12;
      ++v13;
      if (!--v8)
        goto LABEL_29;
    }
  }
  v11 = 0;
  v14 = a3;
LABEL_29:
  result = 0;
  *a5 = v14;
  *a6 = v11;
  return result;
}

uint64_t figTTMLInitNamedColorToRGBAMap()
{
  CFMutableDictionaryRef Mutable;
  uint64_t result;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  FigCFDictionarySetInt32();
  result = FigCFDictionarySetInt32();
  sNamedColorToRGBAMap = (uint64_t)Mutable;
  return result;
}

void figTTMLInitRGBAToNamedColorMap()
{
  __CFDictionary *Mutable;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue(Mutable, 0, CFSTR("transparent"));
  CFDictionarySetValue(Mutable, (const void *)0xFF, CFSTR("black"));
  CFDictionarySetValue(Mutable, (const void *)0xC0C0C0FFLL, CFSTR("silver"));
  CFDictionarySetValue(Mutable, (const void *)0x808080FFLL, CFSTR("gray"));
  CFDictionarySetValue(Mutable, (const void *)0xFFFFFFFFLL, CFSTR("white"));
  CFDictionarySetValue(Mutable, (const void *)0x8000FFFFLL, CFSTR("maroon"));
  CFDictionarySetValue(Mutable, (const void *)0xFF0000FFLL, CFSTR("red"));
  CFDictionarySetValue(Mutable, (const void *)0x800080FFLL, CFSTR("purple"));
  CFDictionarySetValue(Mutable, (const void *)0xFF00FFFFLL, CFSTR("magenta"));
  CFDictionarySetValue(Mutable, (const void *)0x8000FF, CFSTR("green"));
  CFDictionarySetValue(Mutable, (const void *)0xFF00FF, CFSTR("lime"));
  CFDictionarySetValue(Mutable, (const void *)0x808000FFLL, CFSTR("olive"));
  CFDictionarySetValue(Mutable, (const void *)0xFFFF00FFLL, CFSTR("yellow"));
  CFDictionarySetValue(Mutable, (const void *)0x80FF, CFSTR("navy"));
  CFDictionarySetValue(Mutable, (const void *)0xFFFF, CFSTR("blue"));
  CFDictionarySetValue(Mutable, (const void *)0x8080FF, CFSTR("teal"));
  CFDictionarySetValue(Mutable, (const void *)0xFFFFFF, CFSTR("aqua"));
  sRGBAToNamedColorMap = (uint64_t)Mutable;
}

uint64_t figTTMLParseCFString(uint64_t a1, UniChar *a2, int64_t a3, int64_t a4, int64_t *a5)
{
  const __CFAllocator *v9;
  char *BytesFromCFString;
  uint64_t v11;

  v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  BytesFromCFString = (char *)FigCreateBytesFromCFString();
  v11 = figTTMLParseString(BytesFromCFString, a2, a3, a4, a5);
  CFAllocatorDeallocate(v9, BytesFromCFString);
  return v11;
}

uint64_t figTTMLCopyEscapedCharactersUntil(int a1, uint64_t a2, int64_t a3, int64_t a4, int64_t *a5, __CFString **a6)
{
  int64_t v9;
  __CFString *Mutable;
  int64_t v13;
  int64_t v14;
  uint64_t v15;
  UniChar v16;
  uint64_t v17;
  uint64_t v18;
  int64_t v19;
  uint64_t v20;
  uint64_t v21;
  UniChar chars;
  UniChar v24;
  int64_t v25;
  CFRange v26;

  v9 = a3;
  v25 = a3;
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  while (1)
  {
    while (1)
    {
      if (v9 >= a4)
        goto LABEL_24;
      if (!figTTMLParseCharacter(a1, (UniChar *)a2, v9, a4, &v25))
      {
        v9 = v25 - 1;
LABEL_24:
        v21 = 0;
        *a5 = v9;
        *a6 = Mutable;
        return v21;
      }
      if (!figTTMLParseCharacter(92, (UniChar *)a2, v25, a4, &v25))
        break;
      chars = 0;
      v13 = v25;
      if (v25 < 0 || (v14 = *(_QWORD *)(a2 + 160), v14 <= v25))
      {
        v16 = 0;
      }
      else
      {
        v15 = *(_QWORD *)(a2 + 136);
        if (v15)
        {
          v16 = *(_WORD *)(v15 + 2 * (*(_QWORD *)(a2 + 152) + v25));
        }
        else
        {
          v18 = *(_QWORD *)(a2 + 144);
          if (v18)
          {
            v16 = *(char *)(v18 + *(_QWORD *)(a2 + 152) + v25);
          }
          else
          {
            if (*(_QWORD *)(a2 + 176) <= v25 || (v19 = *(_QWORD *)(a2 + 168), v19 > v25))
            {
              v20 = v25 - 4;
              if ((unint64_t)v25 < 4)
                v20 = 0;
              if (v20 + 64 < v14)
                v14 = v20 + 64;
              *(_QWORD *)(a2 + 168) = v20;
              *(_QWORD *)(a2 + 176) = v14;
              v26.location = *(_QWORD *)(a2 + 152) + v20;
              v26.length = v14 - v20;
              CFStringGetCharacters(*(CFStringRef *)(a2 + 128), v26, (UniChar *)a2);
              v19 = *(_QWORD *)(a2 + 168);
            }
            v16 = *(_WORD *)(a2 + 2 * (v13 - v19));
          }
        }
      }
      chars = v16;
      CFStringAppendCharacters(Mutable, &chars, 1);
      v9 = ++v25;
    }
    --v25;
    v24 = 0;
    v17 = figTTMLParseEscape((UniChar *)a2, v25, a4, &v25, &v24);
    if ((_DWORD)v17)
      break;
    CFStringAppendCharacters(Mutable, &v24, 1);
    v9 = v25;
  }
  v21 = v17;
  if (Mutable)
    CFRelease(Mutable);
  return v21;
}

